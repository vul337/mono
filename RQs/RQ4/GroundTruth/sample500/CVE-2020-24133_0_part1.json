{
  "cve_id": "CVE-2020-24133",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "radareorg/radare2-extras",
  "commit_msg": "patch Heap overflow",
  "commit_hash": "9f6a221433964d9b14f3ed78bc9fb059395b893b",
  "git_url": "https://github.com/radareorg/radare2-extras/commit/9f6a221433964d9b14f3ed78bc9fb059395b893b",
  "file_path": "libr/asm/arch/swf/swfdis.c",
  "func_name": "r_asm_swf_disass",
  "func_before": "int r_asm_swf_disass(RBinObject *obj, char* buf_asm, const ut8* buf, int len, ut64 pc) {\n\tut8 isTag = false;\n\tint dlen = 0;\n\tRListIter *it;\n\tRBinSection *sect;\n\n\tr_list_foreach(obj->sections, it, sect) {\n\t\tif (pc == sect->vaddr) {\n\t\t\tisTag = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (isTag && len > 1) {\n\t\tdlen = 2;\n\t\tut16 tagCodeAndLength = 0;\n\t\tut16 tagCode = 0;\n\t\tut32 tagLength;\n\t\ttagCodeAndLength = buf[0] + (buf[1] << 8);\n\n\t\ttagCode = tagCodeAndLength >> 6;\n\t\ttagLength = tagCodeAndLength & 0x3f;\n\n\t\tif (tagLength >= 0x3f) {\n\t\t\tdlen = 6;\n\t\t}\n\t\tswf_tag_t tag = r_asm_swf_gettag (tagCode);\n\n\t\tswitch (tagCode) {\n\t\tcase TAG_SETBACKGROUNDCOLOR: {\n\t\t\tut8 red = buf[2];\n\t\t\tut8 green = buf[3];\n\t\t\tut8 blue = buf[4];\n\t\t\tsprintf (buf_asm, \"Color(%u,%u,%u)\", red, green, blue);\n\t\t\tdlen = 5;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tstrcpy (buf_asm, tag.name);\n\t\t\tbreak;\n\n\t\t}\n\n\t} else {\n\t\tswf_op_t op = r_asm_swf_getop (buf[0]);\n\t\tswitch (op.op) {\n\t\tcase SWFACTION_PUSH: {\n\t\t\tut16 len;\n\t\t\tut8 pushtype;\n\t\t\tlen = r_mem_get_num (buf+1, 2);\n\n\t\t\tut8 i = 3; // Buffer index\n\t\t\tut8 l = 0; // String index\n\t\t\tut8 strsize = 20; // Max size of a push name\n\t\t\tut8 max = strsize*(len/2); // Max size of the whole opcode name\n\t\t\tchar* name = malloc(strsize);\n\t\t\tchar* type = malloc(max);\n\t\t\twhile (i < len+2) {\n\t\t\t\teprintf (\"%d, %d\\n\", i, len+2);\n\t\t\t\tpushtype = buf[i];\n\t\t\t\ti += 1;\n\n\t\t\t\tswitch (pushtype) {\n\t\t\t\tcase 0: { /* String */\n\t\t\t\t\tchar* str = (char*) (buf+i);\n\t\t\t\t\ti += strlen (str);\n\t\t\t\t\tsprintf (name, \"str: \\\"%s\\\"\", str);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 1: { /* Floating point */\n\t\t\t\t\tfloat f = r_mem_get_num (buf+i, 4);\n\t\t\t\t\ti += 4;\n\t\t\t\t\tsprintf (name, \"float: %lf\", f);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 2: { /* Null */\n\t\t\t\t\tstrcpy (name, \"null\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 3: { /* Undefined */\n\t\t\t\t\tstrcpy (name, \"undefined\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 4: { /* Register */\n\t\t\t\t\tut8 reg = buf[i];\n\t\t\t\t\tsprintf (name, \"reg:%u\", reg);\n\t\t\t\t\ti++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 5: { /* Boolean */\n\t\t\t\t\tsprintf (name, \"bool: %s\", \n\t\t\t\t\t\tbuf[i] > 0 ? \"true\" : \"false\");\n\t\t\t\t\ti++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 6: { /* Double */\n\t\t\t\t\tdouble d = r_mem_get_num (buf+i, 8);\n\t\t\t\t\tsprintf (name, \"double:%f\", d);\n\t\t\t\t\ti += 8;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 7: { /* Integer */\n\t\t\t\t\tint integer = r_mem_get_num (buf+i, 4);\n\t\t\t\t\tsprintf (name, \"int:0x%x\", integer);\n\t\t\t\t\ti += 4;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 8: { /* Constant8 */\n\t\t\t\t\tsprintf (name, \"const:%u\", buf[i]);\n\t\t\t\t\ti += 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 9: { /* Constant16 */\n\t\t\t\t\tut16 c = r_mem_get_num (buf+i, 2);\n\t\t\t\t\tsprintf (name, \"const:%u\", c);\n\t\t\t\t\ti += 2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tstrcpy(name, \"unknown\");\n\t\t\t\t\ttype = name;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (i < len+2) strcat (name, \", \");\n\t\t\t\tstrncpy (type+l, name, max-l);\n\t\t\t\tl += strlen(name);\n\t\t\t}\n\t\t\tdlen = 2 + len + 1;\n\t\t\tsprintf (buf_asm, \"%s %s\", op.name, type);\n\t\t\tbreak;\n\t\t}\n\t\tcase SWFACTION_GOTOFRAME: {\n\t\t\tut16 frame = r_mem_get_num (buf+1, 2);\n\t\t\tsprintf (buf_asm, \"%s %u\", op.name, frame);\n\t\t\tdlen = 3;\n\t\t\tbreak;\n\t\t}\n\t\tcase SWFACTION_GETURL: {\n\t\t\tchar* url = (char*) buf+1;\n\t\t\tsprintf (buf_asm, \"%s %s\", op.name, url);\n\t\t\tdlen = strlen (url) + 2;\n\t\t\tbreak;\n\t\t}\n\t\tcase SWFACTION_JUMP:\n\t\tcase SWFACTION_BRANCHIFTRUE: {\n\t\t\tshort offset = r_mem_get_num (buf+1, 2);\n\t\t\tsprintf (buf_asm, \"%s %d\", op.name, offset);\n\t\t\tbreak;\n\t\t}\n\t\tcase SWFACTION_GETURL2: {\n\t\t\tut8 method = buf[1];\n\t\t\tchar* m = malloc (5);\n\t\t\tswitch (method) {\n\t\t\tcase 1:\n\t\t\t\tstrcpy (m, \"GET\");\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tstrcpy (m, \"POST\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstrcpy (m, \"None\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsprintf (buf_asm, \"%s %s\", op.name, m);\n\t\t\tdlen = 2;\n\t\t\tbreak;\n\t\t}\n\t\tcase SWFACTION_GOTOFRAME2: {\n\t\t\tdlen = 8;\n\t\t\tut8 biasFlag = buf[7];\n\t\t\tut8 playFlag = buf[8];\n\t\t\tif (biasFlag == 1) {\n\t\t\t\t//ut16 bias = r_mem_get_num (buf+9, 2);\n\t\t\t\tdlen += 2;\n\t\t\t}\n\t\t\tsprintf (buf_asm, \"%s %u %u\", op.name, biasFlag, playFlag);\n\t\t\tbreak;\n\t\t}\n\t\tcase SWFACTION_SETTARGET: {\n\t\t\tchar* target = (char*) buf+1;\n\t\t\tsprintf (buf_asm, \"%s %s\", op.name, target);\n\t\t\tdlen = 1;\n\t\t\tbreak;\n\t\t}\n\t\tcase SWFACTION_CONSTANTPOOL: {\n\t\t\tut16 size = r_mem_get_num (buf+1, 2);\n\t\t\tut16 count = r_mem_get_num (buf+3, 2);\n\t\t\tsprintf (buf_asm, \"%s (nb: %u, size: %u)\", op.name, count, size);\n\t\t\tdlen = 5;\n\t\t\tbreak;\n\t\t}\n\t\tcase SWFACTION_WITH: {\n\t\t\tut16 size = r_mem_get_num (buf+1, 2);\n\t\t\tsprintf (buf_asm, \"%s %u\", op.name, size);\n\t\t\tdlen = 3;\n\t\t\tbreak;\n\t\t}\n\t\tcase SWFACTION_DEFINEFUNCTION: {\n\t\t\t//char* name = (char*) buf+1;\n\t\t\tut16 nbParams = r_mem_get_num (buf+2, 2);\n\t\t\tut32 size = 0;\n\t\t\tut16 i;\n\t\t\tfor (i = 0; i < nbParams; i++) {\n\t\t\t\tchar* param = (char*) buf+3+i;\n\t\t\t\tsize += strlen(param);\n\t\t\t}\n\t\t\t//ut16 codeSize = r_mem_get_num (buf+4+i, 2);\n\t\t\tbreak;\n\t\t}\n\t\tcase SWFACTION_STOREREGISTER: {\n\t\t\tut8 reg = buf[1];\n\t\t\tsprintf (buf_asm, \"%s %u\", op.name, reg);\n\t\t\tdlen = 2;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tstrcpy (buf_asm, op.name);\n\t\t\tdlen = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn dlen;\n}",
  "abstract_func_before": "int r_asm_swf_disass(RBinObject *VAR_0, char* VAR_1, const ut8* VAR_2, int VAR_3, ut64 VAR_4) {\n\tut8 VAR_5 = false;\n\tint VAR_6 = 0;\n\tRListIter *VAR_7;\n\tRBinSection *VAR_8;\n\n\tr_list_foreach(VAR_0->sections, VAR_7, VAR_8) {\n\t\tif (VAR_4 == VAR_8->vaddr) {\n\t\t\tVAR_5 = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (VAR_5 && VAR_3 > 1) {\n\t\tVAR_6 = 2;\n\t\tut16 VAR_9 = 0;\n\t\tut16 VAR_10 = 0;\n\t\tut32 VAR_11;\n\t\tVAR_9 = VAR_2[0] + (VAR_2[1] << 8);\n\n\t\tVAR_10 = VAR_9 >> 6;\n\t\tVAR_11 = VAR_9 & 0x3f;\n\n\t\tif (VAR_11 >= 0x3f) {\n\t\t\tVAR_6 = 6;\n\t\t}\n\t\tswf_tag_t VAR_12 = r_asm_swf_gettag (VAR_10);\n\n\t\tswitch (VAR_10) {\n\t\tcase VAR_13: {\n\t\t\tut8 VAR_14 = VAR_2[2];\n\t\t\tut8 VAR_15 = VAR_2[3];\n\t\t\tut8 VAR_16 = VAR_2[4];\n\t\t\tsprintf (VAR_1, \"Color(%u,%u,%u)\", VAR_14, VAR_15, VAR_16);\n\t\t\tVAR_6 = 5;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tstrcpy (VAR_1, VAR_12.name);\n\t\t\tbreak;\n\n\t\t}\n\n\t} else {\n\t\tswf_op_t VAR_17 = r_asm_swf_getop (VAR_2[0]);\n\t\tswitch (VAR_17.op) {\n\t\tcase VAR_18: {\n\t\t\tut16 VAR_3;\n\t\t\tut8 VAR_19;\n\t\t\tVAR_3 = r_mem_get_num (VAR_2+1, 2);\n\n\t\t\tut8 VAR_20 = 3; /* COMMENT_0 */\n\t\t\tut8 VAR_21 = 0; /* COMMENT_1 */\n\t\t\tut8 VAR_22 = 20; /* COMMENT_2 */\n\t\t\tut8 VAR_23 = VAR_22*(VAR_3/2); /* COMMENT_3 */\n\t\t\tchar* VAR_24 = malloc(VAR_22);\n\t\t\tchar* VAR_25 = malloc(VAR_23);\n\t\t\twhile (VAR_20 < VAR_3+2) {\n\t\t\t\teprintf (\"%d, %d\\n\", VAR_20, VAR_3+2);\n\t\t\t\tVAR_19 = VAR_2[VAR_20];\n\t\t\t\tVAR_20 += 1;\n\n\t\t\t\tswitch (VAR_19) {\n\t\t\t\tcase 0: { /* COMMENT_4 */\n\t\t\t\t\tchar* VAR_26 = (char*) (VAR_2+VAR_20);\n\t\t\t\t\tVAR_20 += strlen (VAR_26);\n\t\t\t\t\tsprintf (VAR_24, \"str: \\\"%s\\\"\", VAR_26);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 1: { /* COMMENT_5 */\n\t\t\t\t\tfloat VAR_27 = r_mem_get_num (VAR_2+VAR_20, 4);\n\t\t\t\t\tVAR_20 += 4;\n\t\t\t\t\tsprintf (VAR_24, \"float: %lf\", VAR_27);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 2: { /* COMMENT_6 */\n\t\t\t\t\tstrcpy (VAR_24, \"null\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 3: { /* COMMENT_7 */\n\t\t\t\t\tstrcpy (VAR_24, \"undefined\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 4: { /* COMMENT_8 */\n\t\t\t\t\tut8 VAR_28 = VAR_2[VAR_20];\n\t\t\t\t\tsprintf (VAR_24, \"reg:%u\", VAR_28);\n\t\t\t\t\tVAR_20++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 5: { /* COMMENT_9 */\n\t\t\t\t\tsprintf (VAR_24, \"bool: %s\", \n\t\t\t\t\t\tVAR_2[VAR_20] > 0 ? \"true\" : \"false\");\n\t\t\t\t\tVAR_20++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 6: { /* COMMENT_10 */\n\t\t\t\t\tdouble VAR_29 = r_mem_get_num (VAR_2+VAR_20, 8);\n\t\t\t\t\tsprintf (VAR_24, \"double:%f\", VAR_29);\n\t\t\t\t\tVAR_20 += 8;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 7: { /* COMMENT_11 */\n\t\t\t\t\tint VAR_30 = r_mem_get_num (VAR_2+VAR_20, 4);\n\t\t\t\t\tsprintf (VAR_24, \"int:0x%x\", VAR_30);\n\t\t\t\t\tVAR_20 += 4;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 8: { /* COMMENT_12 */\n\t\t\t\t\tsprintf (VAR_24, \"const:%u\", VAR_2[VAR_20]);\n\t\t\t\t\tVAR_20 += 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 9: { /* COMMENT_13 */\n\t\t\t\t\tut16 VAR_31 = r_mem_get_num (VAR_2+VAR_20, 2);\n\t\t\t\t\tsprintf (VAR_24, \"const:%u\", VAR_31);\n\t\t\t\t\tVAR_20 += 2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tstrcpy(VAR_24, \"unknown\");\n\t\t\t\t\tVAR_25 = VAR_24;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (VAR_20 < VAR_3+2) strcat (VAR_24, \", \");\n\t\t\t\tstrncpy (VAR_25+VAR_21, VAR_24, VAR_23-VAR_21);\n\t\t\t\tVAR_21 += strlen(VAR_24);\n\t\t\t}\n\t\t\tVAR_6 = 2 + VAR_3 + 1;\n\t\t\tsprintf (VAR_1, \"%s %s\", VAR_17.name, VAR_25);\n\t\t\tbreak;\n\t\t}\n\t\tcase VAR_32: {\n\t\t\tut16 VAR_33 = r_mem_get_num (VAR_2+1, 2);\n\t\t\tsprintf (VAR_1, \"%s %u\", VAR_17.name, VAR_33);\n\t\t\tVAR_6 = 3;\n\t\t\tbreak;\n\t\t}\n\t\tcase VAR_34: {\n\t\t\tchar* VAR_35 = (char*) VAR_2+1;\n\t\t\tsprintf (VAR_1, \"%s %s\", VAR_17.name, VAR_35);\n\t\t\tVAR_6 = strlen (VAR_35) + 2;\n\t\t\tbreak;\n\t\t}\n\t\tcase VAR_36:\n\t\tcase VAR_37: {\n\t\t\tshort VAR_38 = r_mem_get_num (VAR_2+1, 2);\n\t\t\tsprintf (VAR_1, \"%s %d\", VAR_17.name, VAR_38);\n\t\t\tbreak;\n\t\t}\n\t\tcase VAR_39: {\n\t\t\tut8 VAR_40 = VAR_2[1];\n\t\t\tchar* VAR_41 = malloc (5);\n\t\t\tswitch (VAR_40) {\n\t\t\tcase 1:\n\t\t\t\tstrcpy (VAR_41, \"GET\");\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tstrcpy (VAR_41, \"POST\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstrcpy (VAR_41, \"None\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsprintf (VAR_1, \"%s %s\", VAR_17.name, VAR_41);\n\t\t\tVAR_6 = 2;\n\t\t\tbreak;\n\t\t}\n\t\tcase VAR_42: {\n\t\t\tVAR_6 = 8;\n\t\t\tut8 VAR_43 = VAR_2[7];\n\t\t\tut8 VAR_44 = VAR_2[8];\n\t\t\tif (VAR_43 == 1) {\n\t\t\t\t/* COMMENT_14 */\n\t\t\t\tVAR_6 += 2;\n\t\t\t}\n\t\t\tsprintf (VAR_1, \"%s %u %u\", VAR_17.name, VAR_43, VAR_44);\n\t\t\tbreak;\n\t\t}\n\t\tcase VAR_45: {\n\t\t\tchar* VAR_46 = (char*) VAR_2+1;\n\t\t\tsprintf (VAR_1, \"%s %s\", VAR_17.name, VAR_46);\n\t\t\tVAR_6 = 1;\n\t\t\tbreak;\n\t\t}\n\t\tcase VAR_47: {\n\t\t\tut16 VAR_48 = r_mem_get_num (VAR_2+1, 2);\n\t\t\tut16 VAR_49 = r_mem_get_num (VAR_2+3, 2);\n\t\t\tsprintf (VAR_1, \"%s (nb: %u, size: %u)\", VAR_17.name, VAR_49, VAR_48);\n\t\t\tVAR_6 = 5;\n\t\t\tbreak;\n\t\t}\n\t\tcase VAR_50: {\n\t\t\tut16 VAR_48 = r_mem_get_num (VAR_2+1, 2);\n\t\t\tsprintf (VAR_1, \"%s %u\", VAR_17.name, VAR_48);\n\t\t\tVAR_6 = 3;\n\t\t\tbreak;\n\t\t}\n\t\tcase VAR_51: {\n\t\t\t/* COMMENT_15 */\n\t\t\tut16 VAR_52 = r_mem_get_num (VAR_2+2, 2);\n\t\t\tut32 VAR_48 = 0;\n\t\t\tut16 VAR_20;\n\t\t\tfor (VAR_20 = 0; VAR_20 < VAR_52; VAR_20++) {\n\t\t\t\tchar* VAR_53 = (char*) VAR_2+3+VAR_20;\n\t\t\t\tVAR_48 += strlen(VAR_53);\n\t\t\t}\n\t\t\t/* COMMENT_16 */\n\t\t\tbreak;\n\t\t}\n\t\tcase VAR_54: {\n\t\t\tut8 VAR_28 = VAR_2[1];\n\t\t\tsprintf (VAR_1, \"%s %u\", VAR_17.name, VAR_28);\n\t\t\tVAR_6 = 2;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tstrcpy (VAR_1, VAR_17.name);\n\t\t\tVAR_6 = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn VAR_6;\n}",
  "func_graph_path_before": "radareorg/radare2-extras/9f6a221433964d9b14f3ed78bc9fb059395b893b/swfdis.c/vul/before/0.json",
  "func": "int r_asm_swf_disass(RBinObject *obj, char* buf_asm, const ut8* buf, int len, ut64 pc) {\n\tut8 isTag = false;\n\tint dlen = 0;\n\tRListIter *it;\n\tRBinSection *sect;\n\n\tr_list_foreach(obj->sections, it, sect) {\n\t\tif (pc == sect->vaddr) {\n\t\t\tisTag = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (isTag && len > 1) {\n\t\tdlen = 2;\n\t\tut16 tagCodeAndLength = 0;\n\t\tut16 tagCode = 0;\n\t\tut32 tagLength;\n\t\ttagCodeAndLength = buf[0] + (buf[1] << 8);\n\n\t\ttagCode = tagCodeAndLength >> 6;\n\t\ttagLength = tagCodeAndLength & 0x3f;\n\n\t\tif (tagLength >= 0x3f) {\n\t\t\tdlen = 6;\n\t\t}\n\t\tswf_tag_t tag = r_asm_swf_gettag (tagCode);\n\n\t\tswitch (tagCode) {\n\t\tcase TAG_SETBACKGROUNDCOLOR: {\n\t\t\tut8 red = buf[2];\n\t\t\tut8 green = buf[3];\n\t\t\tut8 blue = buf[4];\n\t\t\tsprintf (buf_asm, \"Color(%u,%u,%u)\", red, green, blue);\n\t\t\tdlen = 5;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tstrcpy (buf_asm, tag.name);\n\t\t\tbreak;\n\n\t\t}\n\n\t} else {\n\t\tswf_op_t op = r_asm_swf_getop (buf[0]);\n\t\tswitch (op.op) {\n\t\tcase SWFACTION_PUSH: {\n\t\t\tut16 len;\n\t\t\tut8 pushtype;\n\t\t\tlen = r_mem_get_num (buf+1, 2);\n\n\t\t\tut8 i = 3; // Buffer index\n\t\t\tut8 l = 0; // String index\n\t\t\tut8 strsize = 20; // Max size of a push name\n\t\t\tut8 max = strsize*(len/2); // Max size of the whole opcode name\n\t\t\tchar* name = malloc(strsize);\n\t\t\tchar* type = malloc(max);\n\t\t\twhile (i < len+2) {\n\t\t\t\teprintf (\"%d, %d\\n\", i, len+2);\n\t\t\t\tpushtype = buf[i];\n\t\t\t\ti += 1;\n\n\t\t\t\tswitch (pushtype) {\n\t\t\t\tcase 0: { /* String */\n\t\t\t\t\tchar* str = (char*) (buf+i);\n\t\t\t\t\ti += strlen (str);\n\t\t\t\t\tsnprintf (name,strsize, \"str: \\\"%s\\\"\", str);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 1: { /* Floating point */\n\t\t\t\t\tfloat f = r_mem_get_num (buf+i, 4);\n\t\t\t\t\ti += 4;\n\t\t\t\t\tsprintf (name, \"float: %lf\", f);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 2: { /* Null */\n\t\t\t\t\tstrcpy (name, \"null\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 3: { /* Undefined */\n\t\t\t\t\tstrcpy (name, \"undefined\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 4: { /* Register */\n\t\t\t\t\tut8 reg = buf[i];\n\t\t\t\t\tsprintf (name, \"reg:%u\", reg);\n\t\t\t\t\ti++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 5: { /* Boolean */\n\t\t\t\t\tsprintf (name, \"bool: %s\", \n\t\t\t\t\t\tbuf[i] > 0 ? \"true\" : \"false\");\n\t\t\t\t\ti++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 6: { /* Double */\n\t\t\t\t\tdouble d = r_mem_get_num (buf+i, 8);\n\t\t\t\t\tsprintf (name, \"double:%f\", d);\n\t\t\t\t\ti += 8;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 7: { /* Integer */\n\t\t\t\t\tint integer = r_mem_get_num (buf+i, 4);\n\t\t\t\t\tsprintf (name, \"int:0x%x\", integer);\n\t\t\t\t\ti += 4;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 8: { /* Constant8 */\n\t\t\t\t\tsprintf (name, \"const:%u\", buf[i]);\n\t\t\t\t\ti += 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 9: { /* Constant16 */\n\t\t\t\t\tut16 c = r_mem_get_num (buf+i, 2);\n\t\t\t\t\tsprintf (name, \"const:%u\", c);\n\t\t\t\t\ti += 2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tstrcpy(name, \"unknown\");\n\t\t\t\t\ttype = name;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (i < len+2) strcat (name, \", \");\n\t\t\t\tstrncpy (type+l, name, max-l);\n\t\t\t\tl += strlen(name);\n\t\t\t}\n\t\t\tdlen = 2 + len + 1;\n\t\t\tsprintf (buf_asm, \"%s %s\", op.name, type);\n\t\t\tbreak;\n\t\t}\n\t\tcase SWFACTION_GOTOFRAME: {\n\t\t\tut16 frame = r_mem_get_num (buf+1, 2);\n\t\t\tsprintf (buf_asm, \"%s %u\", op.name, frame);\n\t\t\tdlen = 3;\n\t\t\tbreak;\n\t\t}\n\t\tcase SWFACTION_GETURL: {\n\t\t\tchar* url = (char*) buf+1;\n\t\t\tsprintf (buf_asm, \"%s %s\", op.name, url);\n\t\t\tdlen = strlen (url) + 2;\n\t\t\tbreak;\n\t\t}\n\t\tcase SWFACTION_JUMP:\n\t\tcase SWFACTION_BRANCHIFTRUE: {\n\t\t\tshort offset = r_mem_get_num (buf+1, 2);\n\t\t\tsprintf (buf_asm, \"%s %d\", op.name, offset);\n\t\t\tbreak;\n\t\t}\n\t\tcase SWFACTION_GETURL2: {\n\t\t\tut8 method = buf[1];\n\t\t\tchar* m = malloc (5);\n\t\t\tswitch (method) {\n\t\t\tcase 1:\n\t\t\t\tstrcpy (m, \"GET\");\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tstrcpy (m, \"POST\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstrcpy (m, \"None\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsprintf (buf_asm, \"%s %s\", op.name, m);\n\t\t\tdlen = 2;\n\t\t\tbreak;\n\t\t}\n\t\tcase SWFACTION_GOTOFRAME2: {\n\t\t\tdlen = 8;\n\t\t\tut8 biasFlag = buf[7];\n\t\t\tut8 playFlag = buf[8];\n\t\t\tif (biasFlag == 1) {\n\t\t\t\t//ut16 bias = r_mem_get_num (buf+9, 2);\n\t\t\t\tdlen += 2;\n\t\t\t}\n\t\t\tsprintf (buf_asm, \"%s %u %u\", op.name, biasFlag, playFlag);\n\t\t\tbreak;\n\t\t}\n\t\tcase SWFACTION_SETTARGET: {\n\t\t\tchar* target = (char*) buf+1;\n\t\t\tsprintf (buf_asm, \"%s %s\", op.name, target);\n\t\t\tdlen = 1;\n\t\t\tbreak;\n\t\t}\n\t\tcase SWFACTION_CONSTANTPOOL: {\n\t\t\tut16 size = r_mem_get_num (buf+1, 2);\n\t\t\tut16 count = r_mem_get_num (buf+3, 2);\n\t\t\tsprintf (buf_asm, \"%s (nb: %u, size: %u)\", op.name, count, size);\n\t\t\tdlen = 5;\n\t\t\tbreak;\n\t\t}\n\t\tcase SWFACTION_WITH: {\n\t\t\tut16 size = r_mem_get_num (buf+1, 2);\n\t\t\tsprintf (buf_asm, \"%s %u\", op.name, size);\n\t\t\tdlen = 3;\n\t\t\tbreak;\n\t\t}\n\t\tcase SWFACTION_DEFINEFUNCTION: {\n\t\t\t//char* name = (char*) buf+1;\n\t\t\tut16 nbParams = r_mem_get_num (buf+2, 2);\n\t\t\tut32 size = 0;\n\t\t\tut16 i;\n\t\t\tfor (i = 0; i < nbParams; i++) {\n\t\t\t\tchar* param = (char*) buf+3+i;\n\t\t\t\tsize += strlen(param);\n\t\t\t}\n\t\t\t//ut16 codeSize = r_mem_get_num (buf+4+i, 2);\n\t\t\tbreak;\n\t\t}\n\t\tcase SWFACTION_STOREREGISTER: {\n\t\t\tut8 reg = buf[1];\n\t\t\tsprintf (buf_asm, \"%s %u\", op.name, reg);\n\t\t\tdlen = 2;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tstrcpy (buf_asm, op.name);\n\t\t\tdlen = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn dlen;\n}",
  "abstract_func": "int r_asm_swf_disass(RBinObject *VAR_0, char* VAR_1, const ut8* VAR_2, int VAR_3, ut64 VAR_4) {\n\tut8 VAR_5 = false;\n\tint VAR_6 = 0;\n\tRListIter *VAR_7;\n\tRBinSection *VAR_8;\n\n\tr_list_foreach(VAR_0->sections, VAR_7, VAR_8) {\n\t\tif (VAR_4 == VAR_8->vaddr) {\n\t\t\tVAR_5 = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (VAR_5 && VAR_3 > 1) {\n\t\tVAR_6 = 2;\n\t\tut16 VAR_9 = 0;\n\t\tut16 VAR_10 = 0;\n\t\tut32 VAR_11;\n\t\tVAR_9 = VAR_2[0] + (VAR_2[1] << 8);\n\n\t\tVAR_10 = VAR_9 >> 6;\n\t\tVAR_11 = VAR_9 & 0x3f;\n\n\t\tif (VAR_11 >= 0x3f) {\n\t\t\tVAR_6 = 6;\n\t\t}\n\t\tswf_tag_t VAR_12 = r_asm_swf_gettag (VAR_10);\n\n\t\tswitch (VAR_10) {\n\t\tcase VAR_13: {\n\t\t\tut8 VAR_14 = VAR_2[2];\n\t\t\tut8 VAR_15 = VAR_2[3];\n\t\t\tut8 VAR_16 = VAR_2[4];\n\t\t\tsprintf (VAR_1, \"Color(%u,%u,%u)\", VAR_14, VAR_15, VAR_16);\n\t\t\tVAR_6 = 5;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tstrcpy (VAR_1, VAR_12.name);\n\t\t\tbreak;\n\n\t\t}\n\n\t} else {\n\t\tswf_op_t VAR_17 = r_asm_swf_getop (VAR_2[0]);\n\t\tswitch (VAR_17.op) {\n\t\tcase VAR_18: {\n\t\t\tut16 VAR_3;\n\t\t\tut8 VAR_19;\n\t\t\tVAR_3 = r_mem_get_num (VAR_2+1, 2);\n\n\t\t\tut8 VAR_20 = 3; /* COMMENT_0 */\n\t\t\tut8 VAR_21 = 0; /* COMMENT_1 */\n\t\t\tut8 VAR_22 = 20; /* COMMENT_2 */\n\t\t\tut8 VAR_23 = VAR_22*(VAR_3/2); /* COMMENT_3 */\n\t\t\tchar* VAR_24 = malloc(VAR_22);\n\t\t\tchar* VAR_25 = malloc(VAR_23);\n\t\t\twhile (VAR_20 < VAR_3+2) {\n\t\t\t\teprintf (\"%d, %d\\n\", VAR_20, VAR_3+2);\n\t\t\t\tVAR_19 = VAR_2[VAR_20];\n\t\t\t\tVAR_20 += 1;\n\n\t\t\t\tswitch (VAR_19) {\n\t\t\t\tcase 0: { /* COMMENT_4 */\n\t\t\t\t\tchar* VAR_26 = (char*) (VAR_2+VAR_20);\n\t\t\t\t\tVAR_20 += strlen (VAR_26);\n\t\t\t\t\tsnprintf (VAR_24,VAR_22, \"str: \\\"%s\\\"\", VAR_26);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 1: { /* COMMENT_5 */\n\t\t\t\t\tfloat VAR_27 = r_mem_get_num (VAR_2+VAR_20, 4);\n\t\t\t\t\tVAR_20 += 4;\n\t\t\t\t\tsprintf (VAR_24, \"float: %lf\", VAR_27);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 2: { /* COMMENT_6 */\n\t\t\t\t\tstrcpy (VAR_24, \"null\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 3: { /* COMMENT_7 */\n\t\t\t\t\tstrcpy (VAR_24, \"undefined\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 4: { /* COMMENT_8 */\n\t\t\t\t\tut8 VAR_28 = VAR_2[VAR_20];\n\t\t\t\t\tsprintf (VAR_24, \"reg:%u\", VAR_28);\n\t\t\t\t\tVAR_20++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 5: { /* COMMENT_9 */\n\t\t\t\t\tsprintf (VAR_24, \"bool: %s\", \n\t\t\t\t\t\tVAR_2[VAR_20] > 0 ? \"true\" : \"false\");\n\t\t\t\t\tVAR_20++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 6: { /* COMMENT_10 */\n\t\t\t\t\tdouble VAR_29 = r_mem_get_num (VAR_2+VAR_20, 8);\n\t\t\t\t\tsprintf (VAR_24, \"double:%f\", VAR_29);\n\t\t\t\t\tVAR_20 += 8;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 7: { /* COMMENT_11 */\n\t\t\t\t\tint VAR_30 = r_mem_get_num (VAR_2+VAR_20, 4);\n\t\t\t\t\tsprintf (VAR_24, \"int:0x%x\", VAR_30);\n\t\t\t\t\tVAR_20 += 4;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 8: { /* COMMENT_12 */\n\t\t\t\t\tsprintf (VAR_24, \"const:%u\", VAR_2[VAR_20]);\n\t\t\t\t\tVAR_20 += 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 9: { /* COMMENT_13 */\n\t\t\t\t\tut16 VAR_31 = r_mem_get_num (VAR_2+VAR_20, 2);\n\t\t\t\t\tsprintf (VAR_24, \"const:%u\", VAR_31);\n\t\t\t\t\tVAR_20 += 2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tstrcpy(VAR_24, \"unknown\");\n\t\t\t\t\tVAR_25 = VAR_24;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (VAR_20 < VAR_3+2) strcat (VAR_24, \", \");\n\t\t\t\tstrncpy (VAR_25+VAR_21, VAR_24, VAR_23-VAR_21);\n\t\t\t\tVAR_21 += strlen(VAR_24);\n\t\t\t}\n\t\t\tVAR_6 = 2 + VAR_3 + 1;\n\t\t\tsprintf (VAR_1, \"%s %s\", VAR_17.name, VAR_25);\n\t\t\tbreak;\n\t\t}\n\t\tcase VAR_32: {\n\t\t\tut16 VAR_33 = r_mem_get_num (VAR_2+1, 2);\n\t\t\tsprintf (VAR_1, \"%s %u\", VAR_17.name, VAR_33);\n\t\t\tVAR_6 = 3;\n\t\t\tbreak;\n\t\t}\n\t\tcase VAR_34: {\n\t\t\tchar* VAR_35 = (char*) VAR_2+1;\n\t\t\tsprintf (VAR_1, \"%s %s\", VAR_17.name, VAR_35);\n\t\t\tVAR_6 = strlen (VAR_35) + 2;\n\t\t\tbreak;\n\t\t}\n\t\tcase VAR_36:\n\t\tcase VAR_37: {\n\t\t\tshort VAR_38 = r_mem_get_num (VAR_2+1, 2);\n\t\t\tsprintf (VAR_1, \"%s %d\", VAR_17.name, VAR_38);\n\t\t\tbreak;\n\t\t}\n\t\tcase VAR_39: {\n\t\t\tut8 VAR_40 = VAR_2[1];\n\t\t\tchar* VAR_41 = malloc (5);\n\t\t\tswitch (VAR_40) {\n\t\t\tcase 1:\n\t\t\t\tstrcpy (VAR_41, \"GET\");\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tstrcpy (VAR_41, \"POST\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstrcpy (VAR_41, \"None\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsprintf (VAR_1, \"%s %s\", VAR_17.name, VAR_41);\n\t\t\tVAR_6 = 2;\n\t\t\tbreak;\n\t\t}\n\t\tcase VAR_42: {\n\t\t\tVAR_6 = 8;\n\t\t\tut8 VAR_43 = VAR_2[7];\n\t\t\tut8 VAR_44 = VAR_2[8];\n\t\t\tif (VAR_43 == 1) {\n\t\t\t\t/* COMMENT_14 */\n\t\t\t\tVAR_6 += 2;\n\t\t\t}\n\t\t\tsprintf (VAR_1, \"%s %u %u\", VAR_17.name, VAR_43, VAR_44);\n\t\t\tbreak;\n\t\t}\n\t\tcase VAR_45: {\n\t\t\tchar* VAR_46 = (char*) VAR_2+1;\n\t\t\tsprintf (VAR_1, \"%s %s\", VAR_17.name, VAR_46);\n\t\t\tVAR_6 = 1;\n\t\t\tbreak;\n\t\t}\n\t\tcase VAR_47: {\n\t\t\tut16 VAR_48 = r_mem_get_num (VAR_2+1, 2);\n\t\t\tut16 VAR_49 = r_mem_get_num (VAR_2+3, 2);\n\t\t\tsprintf (VAR_1, \"%s (nb: %u, size: %u)\", VAR_17.name, VAR_49, VAR_48);\n\t\t\tVAR_6 = 5;\n\t\t\tbreak;\n\t\t}\n\t\tcase VAR_50: {\n\t\t\tut16 VAR_48 = r_mem_get_num (VAR_2+1, 2);\n\t\t\tsprintf (VAR_1, \"%s %u\", VAR_17.name, VAR_48);\n\t\t\tVAR_6 = 3;\n\t\t\tbreak;\n\t\t}\n\t\tcase VAR_51: {\n\t\t\t/* COMMENT_15 */\n\t\t\tut16 VAR_52 = r_mem_get_num (VAR_2+2, 2);\n\t\t\tut32 VAR_48 = 0;\n\t\t\tut16 VAR_20;\n\t\t\tfor (VAR_20 = 0; VAR_20 < VAR_52; VAR_20++) {\n\t\t\t\tchar* VAR_53 = (char*) VAR_2+3+VAR_20;\n\t\t\t\tVAR_48 += strlen(VAR_53);\n\t\t\t}\n\t\t\t/* COMMENT_16 */\n\t\t\tbreak;\n\t\t}\n\t\tcase VAR_54: {\n\t\t\tut8 VAR_28 = VAR_2[1];\n\t\t\tsprintf (VAR_1, \"%s %u\", VAR_17.name, VAR_28);\n\t\t\tVAR_6 = 2;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tstrcpy (VAR_1, VAR_17.name);\n\t\t\tVAR_6 = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn VAR_6;\n}",
  "func_graph_path": "radareorg/radare2-extras/9f6a221433964d9b14f3ed78bc9fb059395b893b/swfdis.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -64,7 +64,7 @@\n \t\t\t\tcase 0: { /* String */\n \t\t\t\t\tchar* str = (char*) (buf+i);\n \t\t\t\t\ti += strlen (str);\n-\t\t\t\t\tsprintf (name, \"str: \\\"%s\\\"\", str);\n+\t\t\t\t\tsnprintf (name,strsize, \"str: \\\"%s\\\"\", str);\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tcase 1: { /* Floating point */",
  "diff_line_info": {
    "deleted_lines": [
      "\t\t\t\t\tsprintf (name, \"str: \\\"%s\\\"\", str);"
    ],
    "added_lines": [
      "\t\t\t\t\tsnprintf (name,strsize, \"str: \\\"%s\\\"\", str);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/radareorg/radare2-extras/pull/255",
  "description": {
    "pr_info": {
      "title": "patch Heap overflow",
      "number": 255
    },
    "comment": [
      "<!--- Filling this template is mandatory -->\r\n\r\n**Detailed description**\r\n\r\n<!-- Explain the **details** for making this change. Is a new feature implemented? What existing problem does the pull request solve? How does the pull request solve these issues? Please provide enough information so that others can review your pull request. -->\r\n\r\npatch for \"https://github.com/radareorg/radare2-extras/issues/254\"\r\n\r\n**Test plan**\r\n\r\n<!-- What steps should the reviewer take to test your pull request? Demonstrate the code is solid. Example: The exact commands you ran and their output, screenshots/videos. This is your time to re-check that everything works and that you covered all the edge cases -->\r\n\r\n...\r\n\r\n**Closing issues**\r\n\r\n<!-- put \"closes #XXXX\" in your comment to auto-close the issue that your PR fixes (if any). -->\r\n\r\n...\r\n",
      "There are some more coding style and lots of refactoring needed to cleanup this code. But im merging to save the world from segfaults for now. Would you like to do further cleanips in here?\r\n\r\nThanks!"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "Final Classification: Security Vulnerability Fix; Confidence: 1.0"
}