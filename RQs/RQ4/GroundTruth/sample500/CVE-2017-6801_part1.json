{
  "cve_id": "CVE-2017-6801",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "Yeraze/ytnef",
  "commit_msg": "BugFix - Potential OOB with Fields of Size 0\n\nThanks to @hannob for contributing a malformed TNEF stream with\na Version field of size 0.  Now such files will return an error\nindicating invalid data.",
  "commit_hash": "3cb0f914d6427073f262e1b2b5fd973e3043cdf7",
  "git_url": "https://github.com/Yeraze/ytnef/commit/3cb0f914d6427073f262e1b2b5fd973e3043cdf7",
  "file_path": "lib/ytnef.c",
  "func_name": "TNEFParse",
  "func_before": "int TNEFParse(TNEFStruct *TNEF) {\n  WORD key;\n  DWORD type;\n  DWORD size;\n  DWORD signature;\n  BYTE *data;\n  WORD checksum, header_checksum;\n  int i;\n\n  if (TNEF->IO.ReadProc == NULL) {\n    printf(\"ERROR: Setup incorrectly: No ReadProc\\n\");\n    return YTNEF_INCORRECT_SETUP;\n  }\n\n  if (TNEF->IO.InitProc != NULL) {\n    DEBUG(TNEF->Debug, 2, \"About to initialize\");\n    if (TNEF->IO.InitProc(&TNEF->IO) != 0) {\n      return YTNEF_CANNOT_INIT_DATA;\n    }\n    DEBUG(TNEF->Debug, 2, \"Initialization finished\");\n  }\n\n  DEBUG(TNEF->Debug, 2, \"Reading Signature\");\n  if (TNEF->IO.ReadProc(&TNEF->IO, sizeof(DWORD), 1, &signature) < 1) {\n    printf(\"ERROR: Error reading signature\\n\");\n    if (TNEF->IO.CloseProc != NULL) {\n      TNEF->IO.CloseProc(&TNEF->IO);\n    }\n    return YTNEF_ERROR_READING_DATA;\n  }\n\n  DEBUG(TNEF->Debug, 2, \"Checking Signature\");\n  if (TNEFCheckForSignature(signature) < 0) {\n    printf(\"ERROR: Signature does not match. Not TNEF.\\n\");\n    if (TNEF->IO.CloseProc != NULL) {\n      TNEF->IO.CloseProc(&TNEF->IO);\n    }\n    return YTNEF_NOT_TNEF_STREAM;\n  }\n\n  DEBUG(TNEF->Debug, 2, \"Reading Key.\");\n\n  if (TNEFGetKey(TNEF, &key) < 0) {\n    printf(\"ERROR: Unable to retrieve key.\\n\");\n    if (TNEF->IO.CloseProc != NULL) {\n      TNEF->IO.CloseProc(&TNEF->IO);\n    }\n    return YTNEF_NO_KEY;\n  }\n\n  DEBUG(TNEF->Debug, 2, \"Starting Full Processing.\");\n\n  while (TNEFGetHeader(TNEF, &type, &size) == 0) {\n    DEBUG2(TNEF->Debug, 2, \"Header says type=0x%X, size=%u\", type, size);\n    DEBUG2(TNEF->Debug, 2, \"Header says type=%u, size=%u\", type, size);\n    data = calloc(size, sizeof(BYTE));\n    ALLOCCHECK(data);\n    if (TNEFRawRead(TNEF, data, size, &header_checksum) < 0) {\n      printf(\"ERROR: Unable to read data.\\n\");\n      if (TNEF->IO.CloseProc != NULL) {\n        TNEF->IO.CloseProc(&TNEF->IO);\n      }\n      free(data);\n      return YTNEF_ERROR_READING_DATA;\n    }\n    if (TNEFRawRead(TNEF, (BYTE *)&checksum, 2, NULL) < 0) {\n      printf(\"ERROR: Unable to read checksum.\\n\");\n      if (TNEF->IO.CloseProc != NULL) {\n        TNEF->IO.CloseProc(&TNEF->IO);\n      }\n      free(data);\n      return YTNEF_ERROR_READING_DATA;\n    }\n    checksum = SwapWord((BYTE *)&checksum, sizeof(WORD));\n    if (checksum != header_checksum) {\n      printf(\"ERROR: Checksum mismatch. Data corruption?:\\n\");\n      if (TNEF->IO.CloseProc != NULL) {\n        TNEF->IO.CloseProc(&TNEF->IO);\n      }\n      free(data);\n      return YTNEF_BAD_CHECKSUM;\n    }\n    for (i = 0; i < (sizeof(TNEFList) / sizeof(TNEFHandler)); i++) {\n      if (TNEFList[i].id == type) {\n        if (TNEFList[i].handler != NULL) {\n          if (TNEFList[i].handler(TNEF, i, (char*)data, size) < 0) {\n            free(data);\n            if (TNEF->IO.CloseProc != NULL) {\n              TNEF->IO.CloseProc(&TNEF->IO);\n            }\n            return YTNEF_ERROR_IN_HANDLER;\n          } else {\n            //  Found our handler and processed it.  now time to get out\n            break;\n          }\n        } else {\n          DEBUG2(TNEF->Debug, 1, \"No handler for %s: %u bytes\",\n                 TNEFList[i].name, size);\n        }\n      }\n    }\n\n    free(data);\n  }\n\n  if (TNEF->IO.CloseProc != NULL) {\n    TNEF->IO.CloseProc(&TNEF->IO);\n  }\n  return 0;\n\n}",
  "abstract_func_before": "int TNEFParse(TNEFStruct *VAR_0) {\n  WORD VAR_1;\n  DWORD VAR_2;\n  DWORD VAR_3;\n  DWORD VAR_4;\n  BYTE *VAR_5;\n  WORD VAR_6, VAR_7;\n  int VAR_8;\n\n  if (VAR_0->IO.ReadProc == NULL) {\n    printf(\"ERROR: Setup incorrectly: No ReadProc\\n\");\n    return VAR_9;\n  }\n\n  if (VAR_0->IO.InitProc != NULL) {\n    DEBUG(VAR_0->Debug, 2, \"About to initialize\");\n    if (VAR_0->IO.InitProc(&VAR_0->IO) != 0) {\n      return VAR_10;\n    }\n    DEBUG(VAR_0->Debug, 2, \"Initialization finished\");\n  }\n\n  DEBUG(VAR_0->Debug, 2, \"Reading Signature\");\n  if (VAR_0->IO.ReadProc(&VAR_0->IO, sizeof(DWORD), 1, &VAR_4) < 1) {\n    printf(\"ERROR: Error reading signature\\n\");\n    if (VAR_0->IO.CloseProc != NULL) {\n      VAR_0->IO.CloseProc(&VAR_0->IO);\n    }\n    return VAR_11;\n  }\n\n  DEBUG(VAR_0->Debug, 2, \"Checking Signature\");\n  if (TNEFCheckForSignature(VAR_4) < 0) {\n    printf(\"ERROR: Signature does not match. Not TNEF.\\n\");\n    if (VAR_0->IO.CloseProc != NULL) {\n      VAR_0->IO.CloseProc(&VAR_0->IO);\n    }\n    return VAR_12;\n  }\n\n  DEBUG(VAR_0->Debug, 2, \"Reading Key.\");\n\n  if (TNEFGetKey(VAR_0, &VAR_1) < 0) {\n    printf(\"ERROR: Unable to retrieve key.\\n\");\n    if (VAR_0->IO.CloseProc != NULL) {\n      VAR_0->IO.CloseProc(&VAR_0->IO);\n    }\n    return VAR_13;\n  }\n\n  DEBUG(VAR_0->Debug, 2, \"Starting Full Processing.\");\n\n  while (TNEFGetHeader(VAR_0, &VAR_2, &VAR_3) == 0) {\n    DEBUG2(VAR_0->Debug, 2, \"Header says type=0x%X, size=%u\", VAR_2, VAR_3);\n    DEBUG2(VAR_0->Debug, 2, \"Header says type=%u, size=%u\", VAR_2, VAR_3);\n    VAR_5 = calloc(VAR_3, sizeof(BYTE));\n    ALLOCCHECK(VAR_5);\n    if (TNEFRawRead(VAR_0, VAR_5, VAR_3, &VAR_7) < 0) {\n      printf(\"ERROR: Unable to read data.\\n\");\n      if (VAR_0->IO.CloseProc != NULL) {\n        VAR_0->IO.CloseProc(&VAR_0->IO);\n      }\n      free(VAR_5);\n      return VAR_11;\n    }\n    if (TNEFRawRead(VAR_0, (BYTE *)&VAR_6, 2, NULL) < 0) {\n      printf(\"ERROR: Unable to read checksum.\\n\");\n      if (VAR_0->IO.CloseProc != NULL) {\n        VAR_0->IO.CloseProc(&VAR_0->IO);\n      }\n      free(VAR_5);\n      return VAR_11;\n    }\n    VAR_6 = SwapWord((BYTE *)&VAR_6, sizeof(WORD));\n    if (VAR_6 != VAR_7) {\n      printf(\"ERROR: Checksum mismatch. Data corruption?:\\n\");\n      if (VAR_0->IO.CloseProc != NULL) {\n        VAR_0->IO.CloseProc(&VAR_0->IO);\n      }\n      free(VAR_5);\n      return VAR_14;\n    }\n    for (VAR_8 = 0; VAR_8 < (sizeof(TNEFList) / sizeof(VAR_15)); VAR_8++) {\n      if (TNEFList[VAR_8].id == VAR_2) {\n        if (TNEFList[VAR_8].handler != NULL) {\n          if (TNEFList[VAR_8].handler(VAR_0, VAR_8, (char*)VAR_5, VAR_3) < 0) {\n            free(VAR_5);\n            if (VAR_0->IO.CloseProc != NULL) {\n              VAR_0->IO.CloseProc(&VAR_0->IO);\n            }\n            return VAR_16;\n          } else {\n            /* COMMENT_0 */\n            break;\n          }\n        } else {\n          DEBUG2(VAR_0->Debug, 1, \"No handler for %s: %u bytes\",\n                 TNEFList[VAR_8].name, VAR_3);\n        }\n      }\n    }\n\n    free(VAR_5);\n  }\n\n  if (VAR_0->IO.CloseProc != NULL) {\n    VAR_0->IO.CloseProc(&VAR_0->IO);\n  }\n  return 0;\n\n}",
  "func_graph_path_before": "Yeraze/ytnef/3cb0f914d6427073f262e1b2b5fd973e3043cdf7/ytnef.c/vul/before/0.json",
  "func": "int TNEFParse(TNEFStruct *TNEF) {\n  WORD key;\n  DWORD type;\n  DWORD size;\n  DWORD signature;\n  BYTE *data;\n  WORD checksum, header_checksum;\n  int i;\n\n  if (TNEF->IO.ReadProc == NULL) {\n    printf(\"ERROR: Setup incorrectly: No ReadProc\\n\");\n    return YTNEF_INCORRECT_SETUP;\n  }\n\n  if (TNEF->IO.InitProc != NULL) {\n    DEBUG(TNEF->Debug, 2, \"About to initialize\");\n    if (TNEF->IO.InitProc(&TNEF->IO) != 0) {\n      return YTNEF_CANNOT_INIT_DATA;\n    }\n    DEBUG(TNEF->Debug, 2, \"Initialization finished\");\n  }\n\n  DEBUG(TNEF->Debug, 2, \"Reading Signature\");\n  if (TNEF->IO.ReadProc(&TNEF->IO, sizeof(DWORD), 1, &signature) < 1) {\n    printf(\"ERROR: Error reading signature\\n\");\n    if (TNEF->IO.CloseProc != NULL) {\n      TNEF->IO.CloseProc(&TNEF->IO);\n    }\n    return YTNEF_ERROR_READING_DATA;\n  }\n\n  DEBUG(TNEF->Debug, 2, \"Checking Signature\");\n  if (TNEFCheckForSignature(signature) < 0) {\n    printf(\"ERROR: Signature does not match. Not TNEF.\\n\");\n    if (TNEF->IO.CloseProc != NULL) {\n      TNEF->IO.CloseProc(&TNEF->IO);\n    }\n    return YTNEF_NOT_TNEF_STREAM;\n  }\n\n  DEBUG(TNEF->Debug, 2, \"Reading Key.\");\n\n  if (TNEFGetKey(TNEF, &key) < 0) {\n    printf(\"ERROR: Unable to retrieve key.\\n\");\n    if (TNEF->IO.CloseProc != NULL) {\n      TNEF->IO.CloseProc(&TNEF->IO);\n    }\n    return YTNEF_NO_KEY;\n  }\n\n  DEBUG(TNEF->Debug, 2, \"Starting Full Processing.\");\n\n  while (TNEFGetHeader(TNEF, &type, &size) == 0) {\n    DEBUG2(TNEF->Debug, 2, \"Header says type=0x%X, size=%u\", type, size);\n    DEBUG2(TNEF->Debug, 2, \"Header says type=%u, size=%u\", type, size);\n    if(size == 0) {\n      printf(\"ERROR: Field with size of 0\\n\");\n      return YTNEF_ERROR_READING_DATA;\n    }\n    data = calloc(size, sizeof(BYTE));\n    ALLOCCHECK(data);\n    if (TNEFRawRead(TNEF, data, size, &header_checksum) < 0) {\n      printf(\"ERROR: Unable to read data.\\n\");\n      if (TNEF->IO.CloseProc != NULL) {\n        TNEF->IO.CloseProc(&TNEF->IO);\n      }\n      free(data);\n      return YTNEF_ERROR_READING_DATA;\n    }\n    if (TNEFRawRead(TNEF, (BYTE *)&checksum, 2, NULL) < 0) {\n      printf(\"ERROR: Unable to read checksum.\\n\");\n      if (TNEF->IO.CloseProc != NULL) {\n        TNEF->IO.CloseProc(&TNEF->IO);\n      }\n      free(data);\n      return YTNEF_ERROR_READING_DATA;\n    }\n    checksum = SwapWord((BYTE *)&checksum, sizeof(WORD));\n    if (checksum != header_checksum) {\n      printf(\"ERROR: Checksum mismatch. Data corruption?:\\n\");\n      if (TNEF->IO.CloseProc != NULL) {\n        TNEF->IO.CloseProc(&TNEF->IO);\n      }\n      free(data);\n      return YTNEF_BAD_CHECKSUM;\n    }\n    for (i = 0; i < (sizeof(TNEFList) / sizeof(TNEFHandler)); i++) {\n      if (TNEFList[i].id == type) {\n        if (TNEFList[i].handler != NULL) {\n          if (TNEFList[i].handler(TNEF, i, (char*)data, size) < 0) {\n            free(data);\n            if (TNEF->IO.CloseProc != NULL) {\n              TNEF->IO.CloseProc(&TNEF->IO);\n            }\n            return YTNEF_ERROR_IN_HANDLER;\n          } else {\n            //  Found our handler and processed it.  now time to get out\n            break;\n          }\n        } else {\n          DEBUG2(TNEF->Debug, 1, \"No handler for %s: %u bytes\",\n                 TNEFList[i].name, size);\n        }\n      }\n    }\n\n    free(data);\n  }\n\n  if (TNEF->IO.CloseProc != NULL) {\n    TNEF->IO.CloseProc(&TNEF->IO);\n  }\n  return 0;\n\n}",
  "abstract_func": "int TNEFParse(TNEFStruct *VAR_0) {\n  WORD VAR_1;\n  DWORD VAR_2;\n  DWORD VAR_3;\n  DWORD VAR_4;\n  BYTE *VAR_5;\n  WORD VAR_6, VAR_7;\n  int VAR_8;\n\n  if (VAR_0->IO.ReadProc == NULL) {\n    printf(\"ERROR: Setup incorrectly: No ReadProc\\n\");\n    return VAR_9;\n  }\n\n  if (VAR_0->IO.InitProc != NULL) {\n    DEBUG(VAR_0->Debug, 2, \"About to initialize\");\n    if (VAR_0->IO.InitProc(&VAR_0->IO) != 0) {\n      return VAR_10;\n    }\n    DEBUG(VAR_0->Debug, 2, \"Initialization finished\");\n  }\n\n  DEBUG(VAR_0->Debug, 2, \"Reading Signature\");\n  if (VAR_0->IO.ReadProc(&VAR_0->IO, sizeof(DWORD), 1, &VAR_4) < 1) {\n    printf(\"ERROR: Error reading signature\\n\");\n    if (VAR_0->IO.CloseProc != NULL) {\n      VAR_0->IO.CloseProc(&VAR_0->IO);\n    }\n    return VAR_11;\n  }\n\n  DEBUG(VAR_0->Debug, 2, \"Checking Signature\");\n  if (TNEFCheckForSignature(VAR_4) < 0) {\n    printf(\"ERROR: Signature does not match. Not TNEF.\\n\");\n    if (VAR_0->IO.CloseProc != NULL) {\n      VAR_0->IO.CloseProc(&VAR_0->IO);\n    }\n    return VAR_12;\n  }\n\n  DEBUG(VAR_0->Debug, 2, \"Reading Key.\");\n\n  if (TNEFGetKey(VAR_0, &VAR_1) < 0) {\n    printf(\"ERROR: Unable to retrieve key.\\n\");\n    if (VAR_0->IO.CloseProc != NULL) {\n      VAR_0->IO.CloseProc(&VAR_0->IO);\n    }\n    return VAR_13;\n  }\n\n  DEBUG(VAR_0->Debug, 2, \"Starting Full Processing.\");\n\n  while (TNEFGetHeader(VAR_0, &VAR_2, &VAR_3) == 0) {\n    DEBUG2(VAR_0->Debug, 2, \"Header says type=0x%X, size=%u\", VAR_2, VAR_3);\n    DEBUG2(VAR_0->Debug, 2, \"Header says type=%u, size=%u\", VAR_2, VAR_3);\n    if(VAR_3 == 0) {\n      printf(\"ERROR: Field with size of 0\\n\");\n      return VAR_11;\n    }\n    VAR_5 = calloc(VAR_3, sizeof(BYTE));\n    ALLOCCHECK(VAR_5);\n    if (TNEFRawRead(VAR_0, VAR_5, VAR_3, &VAR_7) < 0) {\n      printf(\"ERROR: Unable to read data.\\n\");\n      if (VAR_0->IO.CloseProc != NULL) {\n        VAR_0->IO.CloseProc(&VAR_0->IO);\n      }\n      free(VAR_5);\n      return VAR_11;\n    }\n    if (TNEFRawRead(VAR_0, (BYTE *)&VAR_6, 2, NULL) < 0) {\n      printf(\"ERROR: Unable to read checksum.\\n\");\n      if (VAR_0->IO.CloseProc != NULL) {\n        VAR_0->IO.CloseProc(&VAR_0->IO);\n      }\n      free(VAR_5);\n      return VAR_11;\n    }\n    VAR_6 = SwapWord((BYTE *)&VAR_6, sizeof(WORD));\n    if (VAR_6 != VAR_7) {\n      printf(\"ERROR: Checksum mismatch. Data corruption?:\\n\");\n      if (VAR_0->IO.CloseProc != NULL) {\n        VAR_0->IO.CloseProc(&VAR_0->IO);\n      }\n      free(VAR_5);\n      return VAR_14;\n    }\n    for (VAR_8 = 0; VAR_8 < (sizeof(TNEFList) / sizeof(VAR_15)); VAR_8++) {\n      if (TNEFList[VAR_8].id == VAR_2) {\n        if (TNEFList[VAR_8].handler != NULL) {\n          if (TNEFList[VAR_8].handler(VAR_0, VAR_8, (char*)VAR_5, VAR_3) < 0) {\n            free(VAR_5);\n            if (VAR_0->IO.CloseProc != NULL) {\n              VAR_0->IO.CloseProc(&VAR_0->IO);\n            }\n            return VAR_16;\n          } else {\n            /* COMMENT_0 */\n            break;\n          }\n        } else {\n          DEBUG2(VAR_0->Debug, 1, \"No handler for %s: %u bytes\",\n                 TNEFList[VAR_8].name, VAR_3);\n        }\n      }\n    }\n\n    free(VAR_5);\n  }\n\n  if (VAR_0->IO.CloseProc != NULL) {\n    VAR_0->IO.CloseProc(&VAR_0->IO);\n  }\n  return 0;\n\n}",
  "func_graph_path": "Yeraze/ytnef/3cb0f914d6427073f262e1b2b5fd973e3043cdf7/ytnef.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -53,6 +53,10 @@\n   while (TNEFGetHeader(TNEF, &type, &size) == 0) {\n     DEBUG2(TNEF->Debug, 2, \"Header says type=0x%X, size=%u\", type, size);\n     DEBUG2(TNEF->Debug, 2, \"Header says type=%u, size=%u\", type, size);\n+    if(size == 0) {\n+      printf(\"ERROR: Field with size of 0\\n\");\n+      return YTNEF_ERROR_READING_DATA;\n+    }\n     data = calloc(size, sizeof(BYTE));\n     ALLOCCHECK(data);\n     if (TNEFRawRead(TNEF, data, size, &header_checksum) < 0) {",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "    if(size == 0) {",
      "      printf(\"ERROR: Field with size of 0\\n\");",
      "      return YTNEF_ERROR_READING_DATA;",
      "    }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/Yeraze/ytnef/pull/32",
  "description": {
    "pr_info": {
      "title": "BugFix - data length error",
      "number": 32
    },
    "comment": [
      "Even tho this is a \"LONG\" type, it's actually only 4 bytes. Typecasting\r\nit to a long* caused a dereference beyond the end of the allocated\r\nregion.\r\n\r\nPotential fix for #28 .. @jmallach please review.",
      "The long -> int change looks reasonable to me, but I don't consider my C knowledge to be too good to actually act as a reviewer ;) \r\n\r\nWhat I do notice is the lack of warning reporting in general. You should use -Wall at the very least. In Debian I actually add -Wextra as well and the result is... interesting. Fedora has patches to silence all of these. ",
      "I do that myself regularly as a first-step static analysis (and I run cppcheck regularly).  All I see is some rather harmless 'unused parameters' and 'comparing int & unsigned int' warnings, nothing I consider too harmful.\r\n\r\nAre you seeing something more serious?",
      "Finally, these two new issues could probably get additional CVE numbers. I requested the others for you and can do these two as well, but you can do it using the mitre web form at https://cveform.mitre.org/",
      "Re: warnings, no. It's just I'm unused to seeing a project not using at least -Wall. I'm unsure if any of them are actually potentially dangerous or can cause problems. "
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}