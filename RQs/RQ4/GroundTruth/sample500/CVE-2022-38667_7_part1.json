{
  "cve_id": "CVE-2022-38667",
  "cwe_ids": [
    "CWE-416"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "CrowCpp/Crow",
  "commit_msg": "Prevent HTTP pipelining which Crow doesn't support.",
  "commit_hash": "fba01dc76d6ea940ad7c8392e8f39f9647241d8e",
  "git_url": "https://github.com/CrowCpp/Crow/commit/fba01dc76d6ea940ad7c8392e8f39f9647241d8e",
  "file_path": "include/crow/http_connection.h",
  "func_name": "handle",
  "func_before": "void handle()\n        {\n            // TODO(EDev): cancel_deadline_timer should be looked into, it might be a good idea to add it to handle_url() and then restart the timer once everything passes\n            cancel_deadline_timer();\n            bool is_invalid_request = false;\n            add_keep_alive_ = false;\n\n            req_.remote_ip_address = adaptor_.remote_endpoint().address().to_string();\n\n            add_keep_alive_ = req_.keep_alive;\n            close_connection_ = req_.close_connection;\n\n            if (req_.check_version(1, 1)) // HTTP/1.1\n            {\n                if (!req_.headers.count(\"host\"))\n                {\n                    is_invalid_request = true;\n                    res = response(400);\n                }\n                if (req_.upgrade)\n                {\n                    // h2 or h2c headers\n                    if (req_.get_header_value(\"upgrade\").substr(0, 2) == \"h2\")\n                    {\n                        // TODO(ipkn): HTTP/2\n                        // currently, ignore upgrade header\n                    }\n                    else\n                    {\n                        close_connection_ = true;\n                        handler_->handle_upgrade(req_, res, std::move(adaptor_));\n                        return;\n                    }\n                }\n            }\n\n            CROW_LOG_INFO << \"Request: \" << utility::lexical_cast<std::string>(adaptor_.remote_endpoint()) << \" \" << this << \" HTTP/\" << (char)(req_.http_ver_major + '0') << \".\" << (char)(req_.http_ver_minor + '0') << ' ' << method_name(req_.method) << \" \" << req_.url;\n\n\n            need_to_call_after_handlers_ = false;\n            if (!is_invalid_request)\n            {\n                res.complete_request_handler_ = [] {};\n                res.is_alive_helper_ = [this]() -> bool {\n                    return adaptor_.is_open();\n                };\n\n                ctx_ = detail::context<Middlewares...>();\n                req_.middleware_context = static_cast<void*>(&ctx_);\n                req_.middleware_container = static_cast<void*>(middlewares_);\n                req_.io_service = &adaptor_.get_io_service();\n\n                detail::middleware_call_helper<detail::middleware_call_criteria_only_global,\n                                               0, decltype(ctx_), decltype(*middlewares_)>({}, *middlewares_, req_, res, ctx_);\n\n                if (!res.completed_)\n                {\n                    res.complete_request_handler_ = [this] {\n                        this->complete_request();\n                    };\n                    need_to_call_after_handlers_ = true;\n                    handler_->handle(req_, res, routing_handle_result_);\n                    if (add_keep_alive_)\n                        res.set_header(\"connection\", \"Keep-Alive\");\n                }\n                else\n                {\n                    complete_request();\n                }\n            }\n            else\n            {\n                complete_request();\n            }\n        }",
  "abstract_func_before": "void handle()\n        {\n            /* COMMENT_0 */\n            cancel_deadline_timer();\n            bool VAR_0 = false;\n            VAR_1 = false;\n\n            VAR_2.remote_ip_address = VAR_3.remote_endpoint().address().to_string();\n\n            VAR_1 = VAR_2.keep_alive;\n            VAR_4 = VAR_2.close_connection;\n\n            if (VAR_2.check_version(1, 1)) /* COMMENT_1 */\n            {\n                if (!VAR_2.headers.count(\"host\"))\n                {\n                    VAR_0 = true;\n                    VAR_5 = response(400);\n                }\n                if (VAR_2.upgrade)\n                {\n                    /* COMMENT_2 */\n                    if (VAR_2.get_header_value(\"upgrade\").substr(0, 2) == \"h2\")\n                    {\n                        /* COMMENT_3 */\n                        /* COMMENT_4 */\n                    }\n                    else\n                    {\n                        VAR_4 = true;\n                        VAR_6->handle_upgrade(VAR_2, VAR_5, std::move(VAR_3));\n                        return;\n                    }\n                }\n            }\n\n            VAR_7 << \"Request: \" << utility::VAR_8<std::string>(VAR_3.remote_endpoint()) << \" \" << this << \" HTTP/\" << (char)(VAR_2.http_ver_major + '0') << \".\" << (char)(VAR_2.http_ver_minor + '0') << ' ' << method_name(VAR_2.method) << \" \" << VAR_2.url;\n\n\n            VAR_9 = false;\n            if (!VAR_0)\n            {\n                VAR_5.complete_request_handler_ = [] {};\n                VAR_5.is_alive_helper_ = [this]() -> bool {\n                    return VAR_3.is_open();\n                };\n\n                VAR_10 = detail::VAR_11<Middlewares...>();\n                VAR_2.middleware_context = VAR_12<void*>(&VAR_10);\n                VAR_2.middleware_container = VAR_12<void*>(VAR_13);\n                VAR_2.io_service = &VAR_3.get_io_service();\n\n                detail::VAR_14<detail::middleware_call_criteria_only_global,\n                                               0, decltype(VAR_10), decltype(*VAR_13)>({}, *VAR_13, VAR_2, VAR_5, VAR_10);\n\n                if (!VAR_5.completed_)\n                {\n                    VAR_5.complete_request_handler_ = [this] {\n                        this->complete_request();\n                    };\n                    VAR_9 = true;\n                    VAR_6->handle(VAR_2, VAR_5, VAR_15);\n                    if (VAR_1)\n                        VAR_5.set_header(\"connection\", \"Keep-Alive\");\n                }\n                else\n                {\n                    complete_request();\n                }\n            }\n            else\n            {\n                complete_request();\n            }\n        }",
  "func_graph_path_before": "CrowCpp/Crow/fba01dc76d6ea940ad7c8392e8f39f9647241d8e/http_connection.h/vul/before/3.json",
  "func": "void handle()\n        {\n            // TODO(EDev): cancel_deadline_timer should be looked into, it might be a good idea to add it to handle_url() and then restart the timer once everything passes\n            cancel_deadline_timer();\n            bool is_invalid_request = false;\n            add_keep_alive_ = false;\n\n            req_.remote_ip_address = adaptor_.remote_endpoint().address().to_string();\n\n            add_keep_alive_ = req_.keep_alive;\n            close_connection_ = req_.close_connection;\n\n            if (req_.check_version(1, 1)) // HTTP/1.1\n            {\n                if (!req_.headers.count(\"host\"))\n                {\n                    is_invalid_request = true;\n                    res = response(400);\n                }\n                else if (req_.upgrade)\n                {\n                    // h2 or h2c headers\n                    if (req_.get_header_value(\"upgrade\").substr(0, 2) == \"h2\")\n                    {\n                        // TODO(ipkn): HTTP/2\n                        // currently, ignore upgrade header\n                    }\n                    else\n                    {\n                        close_connection_ = true;\n                        handler_->handle_upgrade(req_, res, std::move(adaptor_));\n                        return;\n                    }\n                }\n            }\n\n            CROW_LOG_INFO << \"Request: \" << utility::lexical_cast<std::string>(adaptor_.remote_endpoint()) << \" \" << this << \" HTTP/\" << (char)(req_.http_ver_major + '0') << \".\" << (char)(req_.http_ver_minor + '0') << ' ' << method_name(req_.method) << \" \" << req_.url;\n\n\n            need_to_call_after_handlers_ = false;\n            if (!is_invalid_request)\n            {\n                res.complete_request_handler_ = [] {};\n                res.is_alive_helper_ = [this]() -> bool {\n                    return adaptor_.is_open();\n                };\n\n                ctx_ = detail::context<Middlewares...>();\n                req_.middleware_context = static_cast<void*>(&ctx_);\n                req_.middleware_container = static_cast<void*>(middlewares_);\n                req_.io_service = &adaptor_.get_io_service();\n\n                detail::middleware_call_helper<detail::middleware_call_criteria_only_global,\n                                               0, decltype(ctx_), decltype(*middlewares_)>({}, *middlewares_, req_, res, ctx_);\n\n                if (!res.completed_)\n                {\n                    res.complete_request_handler_ = [this] {\n                        this->complete_request();\n                    };\n                    need_to_call_after_handlers_ = true;\n                    handler_->handle(req_, res, routing_handle_result_);\n                    if (add_keep_alive_)\n                        res.set_header(\"connection\", \"Keep-Alive\");\n                }\n                else\n                {\n                    complete_request();\n                }\n            }\n            else\n            {\n                complete_request();\n            }\n        }",
  "abstract_func": "void handle()\n        {\n            /* COMMENT_0 */\n            cancel_deadline_timer();\n            bool VAR_0 = false;\n            VAR_1 = false;\n\n            VAR_2.remote_ip_address = VAR_3.remote_endpoint().address().to_string();\n\n            VAR_1 = VAR_2.keep_alive;\n            VAR_4 = VAR_2.close_connection;\n\n            if (VAR_2.check_version(1, 1)) /* COMMENT_1 */\n            {\n                if (!VAR_2.headers.count(\"host\"))\n                {\n                    VAR_0 = true;\n                    VAR_5 = response(400);\n                }\n                else if (VAR_2.upgrade)\n                {\n                    /* COMMENT_2 */\n                    if (VAR_2.get_header_value(\"upgrade\").substr(0, 2) == \"h2\")\n                    {\n                        /* COMMENT_3 */\n                        /* COMMENT_4 */\n                    }\n                    else\n                    {\n                        VAR_4 = true;\n                        VAR_6->handle_upgrade(VAR_2, VAR_5, std::move(VAR_3));\n                        return;\n                    }\n                }\n            }\n\n            VAR_7 << \"Request: \" << utility::VAR_8<std::string>(VAR_3.remote_endpoint()) << \" \" << this << \" HTTP/\" << (char)(VAR_2.http_ver_major + '0') << \".\" << (char)(VAR_2.http_ver_minor + '0') << ' ' << method_name(VAR_2.method) << \" \" << VAR_2.url;\n\n\n            VAR_9 = false;\n            if (!VAR_0)\n            {\n                VAR_5.complete_request_handler_ = [] {};\n                VAR_5.is_alive_helper_ = [this]() -> bool {\n                    return VAR_3.is_open();\n                };\n\n                VAR_10 = detail::VAR_11<Middlewares...>();\n                VAR_2.middleware_context = VAR_12<void*>(&VAR_10);\n                VAR_2.middleware_container = VAR_12<void*>(VAR_13);\n                VAR_2.io_service = &VAR_3.get_io_service();\n\n                detail::VAR_14<detail::middleware_call_criteria_only_global,\n                                               0, decltype(VAR_10), decltype(*VAR_13)>({}, *VAR_13, VAR_2, VAR_5, VAR_10);\n\n                if (!VAR_5.completed_)\n                {\n                    VAR_5.complete_request_handler_ = [this] {\n                        this->complete_request();\n                    };\n                    VAR_9 = true;\n                    VAR_6->handle(VAR_2, VAR_5, VAR_15);\n                    if (VAR_1)\n                        VAR_5.set_header(\"connection\", \"Keep-Alive\");\n                }\n                else\n                {\n                    complete_request();\n                }\n            }\n            else\n            {\n                complete_request();\n            }\n        }",
  "func_graph_path": "CrowCpp/Crow/fba01dc76d6ea940ad7c8392e8f39f9647241d8e/http_connection.h/vul/after/3.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -17,7 +17,7 @@\n                     is_invalid_request = true;\n                     res = response(400);\n                 }\n-                if (req_.upgrade)\n+                else if (req_.upgrade)\n                 {\n                     // h2 or h2c headers\n                     if (req_.get_header_value(\"upgrade\").substr(0, 2) == \"h2\")",
  "diff_line_info": {
    "deleted_lines": [
      "                if (req_.upgrade)"
    ],
    "added_lines": [
      "                else if (req_.upgrade)"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/CrowCpp/Crow/pull/524",
  "description": {
    "pr_info": {
      "title": "Prevent HTTP pipelining",
      "number": 524
    },
    "comment": [
      "Fixes a potential use-after-free vulnerability where using HTTP pipelining could cause Crow to execute code related to a connection after deleting it.\r\n\r\nIt also fixes a small bug where websocket connections could be established with invalid HTTP requests (ones that don't have a `Host` header)\r\n\r\nThanks to hebi Gynvael Coldwind for discovering and reporting the vulnerability."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "The commit addresses a use-after-free vulnerability and a related bug in handling WebSocket connections, indicating it's a security fix.\n\n**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95"
}