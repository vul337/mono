{
  "cve_id": "CVE-2023-51713",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "proftpd",
  "commit_msg": "Issue #1683: Avoid an edge case when handling unexpectedly formatted input text from client, caused by quote/backslash semantics, by skipping those semantics.",
  "commit_hash": "1376d8ccc0966d1ce9a1c76b32c6a9ca61bbe67f",
  "git_url": "https://github.com/proftpd/proftpd/commit/1376d8ccc0966d1ce9a1c76b32c6a9ca61bbe67f",
  "file_path": "src/main.c",
  "func_name": "make_ftp_cmd",
  "func_before": "static cmd_rec *make_ftp_cmd(pool *p, char *buf, size_t buflen, int flags) {\n  register unsigned int i, j;\n  char *arg, *ptr, *wrd;\n  size_t arg_len;\n  cmd_rec *cmd;\n  pool *subpool;\n  array_header *tarr;\n  int have_crnul = FALSE, str_flags = PR_STR_FL_PRESERVE_COMMENTS|flags;\n\n  /* Be pedantic (and RFC-compliant) by not allowing leading whitespace\n   * in an issued FTP command.  Will this cause troubles with many clients?\n   */\n  if (PR_ISSPACE(buf[0])) {\n    pr_trace_msg(\"ctrl\", 5,\n      \"command '%s' has illegal leading whitespace, rejecting\", buf);\n    errno = EINVAL;\n    return NULL;\n  }\n\n  ptr = buf;\n  wrd = pr_str_get_word(&ptr, str_flags);\n  if (wrd == NULL) {\n    /* Nothing there...bail out. */\n    pr_trace_msg(\"ctrl\", 5, \"command '%s' is empty, ignoring\", buf);\n    errno = ENOENT;\n    return NULL;\n  }\n\n  subpool = make_sub_pool(p);\n  pr_pool_tag(subpool, \"make_ftp_cmd pool\");\n  cmd = pcalloc(subpool, sizeof(cmd_rec));\n  cmd->pool = subpool;\n  cmd->tmp_pool = NULL;\n  cmd->stash_index = -1;\n  cmd->stash_hash = 0;\n\n  tarr = make_array(cmd->pool, 2, sizeof(char *));\n\n  *((char **) push_array(tarr)) = pstrdup(cmd->pool, wrd);\n  cmd->argc++;\n\n  /* Make a copy of the command argument; we need to scan through it,\n   * looking for any CR+NUL sequences, per RFC 2640, Section 3.1.\n   *\n   * Note for future readers that this scanning may cause problems for\n   * commands such as ADAT, ENC, and MIC.  Per RFC 2228, the arguments for\n   * these commands are base64-encoded Telnet strings, thus there is no\n   * chance of them containing CRNUL sequences.  Any modules which implement\n   * the translating of those arguments, e.g. mod_gss, will need to ensure\n   * it does the proper handling of CRNUL sequences itself.\n   */\n  arg_len = buflen - strlen(wrd);\n  arg = pcalloc(cmd->pool, arg_len + 1);\n\n  for (i = 0, j = 0; i < arg_len; i++) {\n    pr_signals_handle();\n    if (i > 1 &&\n        ptr[i] == '\\0' &&\n        ptr[i-1] == '\\r') {\n\n      /* Strip out the NUL by simply not copying it into the new buffer. */\n      have_crnul = TRUE;\n    } else {\n      arg[j++] = ptr[i];\n    }\n  }\n\n  cmd->arg = arg;\n\n  if (have_crnul) {\n    char *dup_arg;\n\n    /* Now make a copy of the stripped argument; this is what we need to\n     * tokenize into words, for further command dispatching/processing.\n     */\n    dup_arg = pstrdup(cmd->pool, arg);\n    ptr = dup_arg;\n  }\n\n  while ((wrd = pr_str_get_word(&ptr, str_flags)) != NULL) {\n    pr_signals_handle();\n    *((char **) push_array(tarr)) = pstrdup(cmd->pool, wrd);\n    cmd->argc++;\n  }\n\n  *((char **) push_array(tarr)) = NULL;\n  cmd->argv = tarr->elts;\n  pr_pool_tag(cmd->pool, cmd->argv[0]);\n\n  /* This table will not contain that many entries, so a low number\n   * of chains should suffice.\n   */\n  cmd->notes = pr_table_nalloc(cmd->pool, 0, 8);\n\n  return cmd;\n}",
  "abstract_func_before": "static cmd_rec *make_ftp_cmd(pool *VAR_0, char *VAR_1, size_t VAR_2, int VAR_3) {\n  register unsigned int VAR_4, VAR_5;\n  char *VAR_6, *VAR_7, *VAR_8;\n  size_t VAR_9;\n  cmd_rec *VAR_10;\n  pool *VAR_11;\n  array_header *VAR_12;\n  int VAR_13 = FALSE, VAR_14 = VAR_15|VAR_3;\n\n  /* COMMENT_0 */\n                                                                           \n     \n  if (PR_ISSPACE(VAR_1[0])) {\n    pr_trace_msg(\"ctrl\", 5,\n      \"command '%s' has illegal leading whitespace, rejecting\", VAR_1);\n    VAR_16 = VAR_17;\n    return NULL;\n  }\n\n  VAR_7 = VAR_1;\n  VAR_8 = pr_str_get_word(&VAR_7, VAR_14);\n  if (VAR_8 == NULL) {\n    /* COMMENT_3 */\n    pr_trace_msg(\"ctrl\", 5, \"command '%s' is empty, ignoring\", VAR_1);\n    VAR_16 = VAR_18;\n    return NULL;\n  }\n\n  VAR_11 = make_sub_pool(VAR_0);\n  pr_pool_tag(VAR_11, \"make_ftp_cmd pool\");\n  VAR_10 = pcalloc(VAR_11, sizeof(cmd_rec));\n  VAR_10->pool = VAR_11;\n  VAR_10->tmp_pool = NULL;\n  VAR_10->stash_index = -1;\n  VAR_10->stash_hash = 0;\n\n  VAR_12 = make_array(VAR_10->pool, 2, sizeof(char *));\n\n  *((char **) push_array(VAR_12)) = pstrdup(VAR_10->pool, VAR_8);\n  VAR_10->argc++;\n\n  /* COMMENT_4 */\n                                                                 \n    \n                                                                      \n                                                                          \n                                                                       \n                                                                            \n                                                                          \n                                                           \n     \n  VAR_9 = VAR_2 - strlen(VAR_8);\n  VAR_6 = pcalloc(VAR_10->pool, VAR_9 + 1);\n\n  for (VAR_4 = 0, VAR_5 = 0; VAR_4 < VAR_9; VAR_4++) {\n    pr_signals_handle();\n    if (VAR_4 > 1 &&\n        VAR_7[VAR_4] == '\\0' &&\n        VAR_7[VAR_4-1] == '\\r') {\n\n      /* COMMENT_14 */\n      VAR_13 = TRUE;\n    } else {\n      VAR_6[VAR_5++] = VAR_7[VAR_4];\n    }\n  }\n\n  VAR_10->arg = VAR_6;\n\n  if (VAR_13) {\n    char *VAR_19;\n\n    /* COMMENT_15 */\n                                                                       \n       \n    VAR_19 = pstrdup(VAR_10->pool, VAR_6);\n    VAR_7 = VAR_19;\n  }\n\n  while ((VAR_8 = pr_str_get_word(&VAR_7, VAR_14)) != NULL) {\n    pr_signals_handle();\n    *((char **) push_array(VAR_12)) = pstrdup(VAR_10->pool, VAR_8);\n    VAR_10->argc++;\n  }\n\n  *((char **) push_array(VAR_12)) = NULL;\n  VAR_10->argv = VAR_12->elts;\n  pr_pool_tag(VAR_10->pool, VAR_10->argv[0]);\n\n  /* COMMENT_18 */\n                              \n     \n  VAR_10->notes = pr_table_nalloc(VAR_10->pool, 0, 8);\n\n  return VAR_10;\n}",
  "func_graph_path_before": "proftpd/1376d8ccc0966d1ce9a1c76b32c6a9ca61bbe67f/main.c/vul/before/0.json",
  "func": "static cmd_rec *make_ftp_cmd(pool *p, char *buf, size_t buflen, int flags) {\n  register unsigned int i, j;\n  char *arg, *ptr, *wrd;\n  size_t arg_len;\n  cmd_rec *cmd;\n  pool *subpool;\n  array_header *tarr;\n  int have_crnul = FALSE, str_flags = PR_STR_FL_PRESERVE_COMMENTS|flags;\n\n  /* Be pedantic (and RFC-compliant) by not allowing leading whitespace\n   * in an issued FTP command.  Will this cause troubles with many clients?\n   */\n  if (PR_ISSPACE(buf[0])) {\n    pr_trace_msg(\"ctrl\", 5,\n      \"command '%s' has illegal leading whitespace, rejecting\", buf);\n    errno = EINVAL;\n    return NULL;\n  }\n\n  /* By default, pr_str_get_word will handle quotes and backslashes for\n   * escaping characters.  This can produce words which are shorter, use\n   * fewer bytes than the corresponding input buffer.\n   *\n   * In this particular situation, we use the length of this initial word\n   * for determining the length of the remaining buffer bytes, assumed to\n   * contain the FTP command arguments.  If this initial word is thus\n   * unexpectedly \"shorter\", due to nonconformant FTP text, it can lead\n   * the subsequent buffer scan, looking for CRNUL sequencees, to access\n   * unexpected memory addresses (Issue #1683).\n   *\n   * Thus for this particular situation, we tell the function to ignore/skip\n   * such quote/backslash semantics, and treat them as any other character\n   * using the IGNORE_QUOTES flag.\n   */\n\n  ptr = buf;\n  wrd = pr_str_get_word(&ptr, str_flags|PR_STR_FL_IGNORE_QUOTES);\n  if (wrd == NULL) {\n    /* Nothing there...bail out. */\n    pr_trace_msg(\"ctrl\", 5, \"command '%s' is empty, ignoring\", buf);\n    errno = ENOENT;\n    return NULL;\n  }\n\n  /* Note that this first word is the FTP command.  This is why we make\n   * use of the ptr buffer, which advances through the input buffer as\n   * we read words from the buffer.\n   */\n\n  subpool = make_sub_pool(p);\n  pr_pool_tag(subpool, \"make_ftp_cmd pool\");\n  cmd = pcalloc(subpool, sizeof(cmd_rec));\n  cmd->pool = subpool;\n  cmd->tmp_pool = NULL;\n  cmd->stash_index = -1;\n  cmd->stash_hash = 0;\n\n  tarr = make_array(cmd->pool, 2, sizeof(char *));\n\n  *((char **) push_array(tarr)) = pstrdup(cmd->pool, wrd);\n  cmd->argc++;\n\n  /* Make a copy of the command argument; we need to scan through it,\n   * looking for any CR+NUL sequences, per RFC 2640, Section 3.1.\n   *\n   * Note for future readers that this scanning may cause problems for\n   * commands such as ADAT, ENC, and MIC.  Per RFC 2228, the arguments for\n   * these commands are base64-encoded Telnet strings, thus there is no\n   * chance of them containing CRNUL sequences.  Any modules which implement\n   * the translating of those arguments, e.g. mod_gss, will need to ensure\n   * it does the proper handling of CRNUL sequences itself.\n   */\n  arg_len = buflen - strlen(wrd);\n  arg = pcalloc(cmd->pool, arg_len + 1);\n\n  /* Remember that ptr here is advanced past the first word. */\n  for (i = 0, j = 0; i < arg_len; i++) {\n    pr_signals_handle();\n    if (i > 1 &&\n        ptr[i] == '\\0' &&\n        ptr[i-1] == '\\r') {\n\n      /* Strip out the NUL by simply not copying it into the new buffer. */\n      have_crnul = TRUE;\n\n    } else {\n      arg[j++] = ptr[i];\n    }\n  }\n\n  if (have_crnul == TRUE) {\n    char *dup_arg;\n\n    /* Now make a copy of the stripped argument; this is what we need to\n     * tokenize into words, for further command dispatching/processing.\n     */\n    dup_arg = pstrdup(cmd->pool, arg);\n    ptr = dup_arg;\n  }\n\n  cmd->arg = arg;\n\n  /* Now we can read the remamining words, as command arguments, from the\n   * input buffer.\n   */\n  while ((wrd = pr_str_get_word(&ptr, str_flags)) != NULL) {\n    pr_signals_handle();\n    *((char **) push_array(tarr)) = pstrdup(cmd->pool, wrd);\n    cmd->argc++;\n  }\n\n  *((char **) push_array(tarr)) = NULL;\n  cmd->argv = tarr->elts;\n  pr_pool_tag(cmd->pool, cmd->argv[0]);\n\n  /* This table will not contain that many entries, so a low number\n   * of chains should suffice.\n   */\n  cmd->notes = pr_table_nalloc(cmd->pool, 0, 8);\n\n  return cmd;\n}",
  "abstract_func": "static cmd_rec *make_ftp_cmd(pool *VAR_0, char *VAR_1, size_t VAR_2, int VAR_3) {\n  register unsigned int VAR_4, VAR_5;\n  char *VAR_6, *VAR_7, *VAR_8;\n  size_t VAR_9;\n  cmd_rec *VAR_10;\n  pool *VAR_11;\n  array_header *VAR_12;\n  int VAR_13 = FALSE, VAR_14 = VAR_15|VAR_3;\n\n  /* COMMENT_0 */\n                                                                           \n     \n  if (PR_ISSPACE(VAR_1[0])) {\n    pr_trace_msg(\"ctrl\", 5,\n      \"command '%s' has illegal leading whitespace, rejecting\", VAR_1);\n    VAR_16 = VAR_17;\n    return NULL;\n  }\n\n  /* COMMENT_3 */\n                                                                        \n                                                     \n    \n                                                                         \n                                                                         \n                                                                     \n                                                                       \n                                                                        \n                                               \n    \n                                                                            \n                                                                          \n                                  \n     \n\n  VAR_7 = VAR_1;\n  VAR_8 = pr_str_get_word(&VAR_7, VAR_14|VAR_18);\n  if (VAR_8 == NULL) {\n    /* COMMENT_17 */\n    pr_trace_msg(\"ctrl\", 5, \"command '%s' is empty, ignoring\", VAR_1);\n    VAR_16 = VAR_19;\n    return NULL;\n  }\n\n  /* COMMENT_18 */\n                                                                      \n                                   \n     \n\n  VAR_11 = make_sub_pool(VAR_0);\n  pr_pool_tag(VAR_11, \"make_ftp_cmd pool\");\n  VAR_10 = pcalloc(VAR_11, sizeof(cmd_rec));\n  VAR_10->pool = VAR_11;\n  VAR_10->tmp_pool = NULL;\n  VAR_10->stash_index = -1;\n  VAR_10->stash_hash = 0;\n\n  VAR_12 = make_array(VAR_10->pool, 2, sizeof(char *));\n\n  *((char **) push_array(VAR_12)) = pstrdup(VAR_10->pool, VAR_8);\n  VAR_10->argc++;\n\n  /* COMMENT_22 */\n                                                                 \n    \n                                                                      \n                                                                          \n                                                                       \n                                                                            \n                                                                          \n                                                           \n     \n  VAR_9 = VAR_2 - strlen(VAR_8);\n  VAR_6 = pcalloc(VAR_10->pool, VAR_9 + 1);\n\n  /* COMMENT_32 */\n  for (VAR_4 = 0, VAR_5 = 0; VAR_4 < VAR_9; VAR_4++) {\n    pr_signals_handle();\n    if (VAR_4 > 1 &&\n        VAR_7[VAR_4] == '\\0' &&\n        VAR_7[VAR_4-1] == '\\r') {\n\n      /* COMMENT_33 */\n      VAR_13 = TRUE;\n\n    } else {\n      VAR_6[VAR_5++] = VAR_7[VAR_4];\n    }\n  }\n\n  if (VAR_13 == TRUE) {\n    char *VAR_20;\n\n    /* COMMENT_34 */\n                                                                       \n       \n    VAR_20 = pstrdup(VAR_10->pool, VAR_6);\n    VAR_7 = VAR_20;\n  }\n\n  VAR_10->arg = VAR_6;\n\n  /* COMMENT_37 */\n                  \n     \n  while ((VAR_8 = pr_str_get_word(&VAR_7, VAR_14)) != NULL) {\n    pr_signals_handle();\n    *((char **) push_array(VAR_12)) = pstrdup(VAR_10->pool, VAR_8);\n    VAR_10->argc++;\n  }\n\n  *((char **) push_array(VAR_12)) = NULL;\n  VAR_10->argv = VAR_12->elts;\n  pr_pool_tag(VAR_10->pool, VAR_10->argv[0]);\n\n  /* COMMENT_40 */\n                              \n     \n  VAR_10->notes = pr_table_nalloc(VAR_10->pool, 0, 8);\n\n  return VAR_10;\n}",
  "func_graph_path": "proftpd/1376d8ccc0966d1ce9a1c76b32c6a9ca61bbe67f/main.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -17,14 +17,35 @@\n     return NULL;\n   }\n \n+  /* By default, pr_str_get_word will handle quotes and backslashes for\n+   * escaping characters.  This can produce words which are shorter, use\n+   * fewer bytes than the corresponding input buffer.\n+   *\n+   * In this particular situation, we use the length of this initial word\n+   * for determining the length of the remaining buffer bytes, assumed to\n+   * contain the FTP command arguments.  If this initial word is thus\n+   * unexpectedly \"shorter\", due to nonconformant FTP text, it can lead\n+   * the subsequent buffer scan, looking for CRNUL sequencees, to access\n+   * unexpected memory addresses (Issue #1683).\n+   *\n+   * Thus for this particular situation, we tell the function to ignore/skip\n+   * such quote/backslash semantics, and treat them as any other character\n+   * using the IGNORE_QUOTES flag.\n+   */\n+\n   ptr = buf;\n-  wrd = pr_str_get_word(&ptr, str_flags);\n+  wrd = pr_str_get_word(&ptr, str_flags|PR_STR_FL_IGNORE_QUOTES);\n   if (wrd == NULL) {\n     /* Nothing there...bail out. */\n     pr_trace_msg(\"ctrl\", 5, \"command '%s' is empty, ignoring\", buf);\n     errno = ENOENT;\n     return NULL;\n   }\n+\n+  /* Note that this first word is the FTP command.  This is why we make\n+   * use of the ptr buffer, which advances through the input buffer as\n+   * we read words from the buffer.\n+   */\n \n   subpool = make_sub_pool(p);\n   pr_pool_tag(subpool, \"make_ftp_cmd pool\");\n@@ -52,6 +73,7 @@\n   arg_len = buflen - strlen(wrd);\n   arg = pcalloc(cmd->pool, arg_len + 1);\n \n+  /* Remember that ptr here is advanced past the first word. */\n   for (i = 0, j = 0; i < arg_len; i++) {\n     pr_signals_handle();\n     if (i > 1 &&\n@@ -60,14 +82,13 @@\n \n       /* Strip out the NUL by simply not copying it into the new buffer. */\n       have_crnul = TRUE;\n+\n     } else {\n       arg[j++] = ptr[i];\n     }\n   }\n \n-  cmd->arg = arg;\n-\n-  if (have_crnul) {\n+  if (have_crnul == TRUE) {\n     char *dup_arg;\n \n     /* Now make a copy of the stripped argument; this is what we need to\n@@ -77,6 +98,11 @@\n     ptr = dup_arg;\n   }\n \n+  cmd->arg = arg;\n+\n+  /* Now we can read the remamining words, as command arguments, from the\n+   * input buffer.\n+   */\n   while ((wrd = pr_str_get_word(&ptr, str_flags)) != NULL) {\n     pr_signals_handle();\n     *((char **) push_array(tarr)) = pstrdup(cmd->pool, wrd);",
  "diff_line_info": {
    "deleted_lines": [
      "  wrd = pr_str_get_word(&ptr, str_flags);",
      "  cmd->arg = arg;",
      "",
      "  if (have_crnul) {"
    ],
    "added_lines": [
      "  /* By default, pr_str_get_word will handle quotes and backslashes for",
      "   * escaping characters.  This can produce words which are shorter, use",
      "   * fewer bytes than the corresponding input buffer.",
      "   *",
      "   * In this particular situation, we use the length of this initial word",
      "   * for determining the length of the remaining buffer bytes, assumed to",
      "   * contain the FTP command arguments.  If this initial word is thus",
      "   * unexpectedly \"shorter\", due to nonconformant FTP text, it can lead",
      "   * the subsequent buffer scan, looking for CRNUL sequencees, to access",
      "   * unexpected memory addresses (Issue #1683).",
      "   *",
      "   * Thus for this particular situation, we tell the function to ignore/skip",
      "   * such quote/backslash semantics, and treat them as any other character",
      "   * using the IGNORE_QUOTES flag.",
      "   */",
      "",
      "  wrd = pr_str_get_word(&ptr, str_flags|PR_STR_FL_IGNORE_QUOTES);",
      "",
      "  /* Note that this first word is the FTP command.  This is why we make",
      "   * use of the ptr buffer, which advances through the input buffer as",
      "   * we read words from the buffer.",
      "   */",
      "  /* Remember that ptr here is advanced past the first word. */",
      "",
      "  if (have_crnul == TRUE) {",
      "  cmd->arg = arg;",
      "",
      "  /* Now we can read the remamining words, as command arguments, from the",
      "   * input buffer.",
      "   */"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/proftpd/proftpd/pull/1696",
  "description": {
    "pr_info": {
      "title": "Issue #1683: Avoid an edge case when handling unexpectedly formatted …",
      "number": 1696
    },
    "comment": [
      "…input text from client, caused by quote/backslash semantics, by skipping those semantics."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}