{
  "cve_id": "CVE-2022-35977",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "redis",
  "commit_msg": "Avoid integer overflows in SETRANGE and SORT (CVE-2022-35977) (#11720)\n\nAuthenticated users issuing specially crafted SETRANGE and SORT(_RO)\r\ncommands can trigger an integer overflow, resulting with Redis attempting\r\nto allocate impossible amounts of memory and abort with an OOM panic.",
  "commit_hash": "1ec82e6e97e1db06a72ca505f9fbf6b981f31ef7",
  "git_url": "https://github.com/redis/redis/commit/1ec82e6e97e1db06a72ca505f9fbf6b981f31ef7",
  "file_path": "src/sort.c",
  "func_name": "sortCommandGeneric",
  "func_before": "void sortCommandGeneric(client *c, int readonly) {\n    list *operations;\n    unsigned int outputlen = 0;\n    int desc = 0, alpha = 0;\n    long limit_start = 0, limit_count = -1, start, end;\n    int j, dontsort = 0, vectorlen;\n    int getop = 0; /* GET operation counter */\n    int int_conversion_error = 0;\n    int syntax_error = 0;\n    robj *sortval, *sortby = NULL, *storekey = NULL;\n    redisSortObject *vector; /* Resulting vector to sort */\n    int user_has_full_key_access = 0; /* ACL - used in order to verify 'get' and 'by' options can be used */\n    /* Create a list of operations to perform for every sorted element.\n     * Operations can be GET */\n    operations = listCreate();\n    listSetFreeMethod(operations,zfree);\n    j = 2; /* options start at argv[2] */\n\n    user_has_full_key_access = ACLUserCheckCmdWithUnrestrictedKeyAccess(c->user, c->cmd, c->argv, c->argc, CMD_KEY_ACCESS);\n\n    /* The SORT command has an SQL-alike syntax, parse it */\n    while(j < c->argc) {\n        int leftargs = c->argc-j-1;\n        if (!strcasecmp(c->argv[j]->ptr,\"asc\")) {\n            desc = 0;\n        } else if (!strcasecmp(c->argv[j]->ptr,\"desc\")) {\n            desc = 1;\n        } else if (!strcasecmp(c->argv[j]->ptr,\"alpha\")) {\n            alpha = 1;\n        } else if (!strcasecmp(c->argv[j]->ptr,\"limit\") && leftargs >= 2) {\n            if ((getLongFromObjectOrReply(c, c->argv[j+1], &limit_start, NULL)\n                 != C_OK) ||\n                (getLongFromObjectOrReply(c, c->argv[j+2], &limit_count, NULL)\n                 != C_OK))\n            {\n                syntax_error++;\n                break;\n            }\n            j+=2;\n        } else if (readonly == 0 && !strcasecmp(c->argv[j]->ptr,\"store\") && leftargs >= 1) {\n            storekey = c->argv[j+1];\n            j++;\n        } else if (!strcasecmp(c->argv[j]->ptr,\"by\") && leftargs >= 1) {\n            sortby = c->argv[j+1];\n            /* If the BY pattern does not contain '*', i.e. it is constant,\n             * we don't need to sort nor to lookup the weight keys. */\n            if (strchr(c->argv[j+1]->ptr,'*') == NULL) {\n                dontsort = 1;\n            } else {\n                /* If BY is specified with a real pattern, we can't accept\n                 * it in cluster mode. */\n                if (server.cluster_enabled) {\n                    addReplyError(c,\"BY option of SORT denied in Cluster mode.\");\n                    syntax_error++;\n                    break;\n                }\n                /* If BY is specified with a real pattern, we can't accept\n                 * it if no full ACL key access is applied for this command. */\n                if (!user_has_full_key_access) {\n                    addReplyError(c,\"BY option of SORT denied due to insufficient ACL permissions.\");\n                    syntax_error++;\n                    break;\n                }\n            }\n            j++;\n        } else if (!strcasecmp(c->argv[j]->ptr,\"get\") && leftargs >= 1) {\n            if (server.cluster_enabled) {\n                addReplyError(c,\"GET option of SORT denied in Cluster mode.\");\n                syntax_error++;\n                break;\n            }\n            if (!user_has_full_key_access) {\n                addReplyError(c,\"GET option of SORT denied due to insufficient ACL permissions.\");\n                syntax_error++;\n                break;\n            }\n            listAddNodeTail(operations,createSortOperation(\n                SORT_OP_GET,c->argv[j+1]));\n            getop++;\n            j++;\n        } else {\n            addReplyErrorObject(c,shared.syntaxerr);\n            syntax_error++;\n            break;\n        }\n        j++;\n    }\n\n    /* Handle syntax errors set during options parsing. */\n    if (syntax_error) {\n        listRelease(operations);\n        return;\n    }\n\n    /* Lookup the key to sort. It must be of the right types */\n    sortval = lookupKeyRead(c->db, c->argv[1]);\n    if (sortval && sortval->type != OBJ_SET &&\n                   sortval->type != OBJ_LIST &&\n                   sortval->type != OBJ_ZSET)\n    {\n        listRelease(operations);\n        addReplyErrorObject(c,shared.wrongtypeerr);\n        return;\n    }\n\n    /* Now we need to protect sortval incrementing its count, in the future\n     * SORT may have options able to overwrite/delete keys during the sorting\n     * and the sorted key itself may get destroyed */\n    if (sortval)\n        incrRefCount(sortval);\n    else\n        sortval = createQuicklistObject();\n\n\n    /* When sorting a set with no sort specified, we must sort the output\n     * so the result is consistent across scripting and replication.\n     *\n     * The other types (list, sorted set) will retain their native order\n     * even if no sort order is requested, so they remain stable across\n     * scripting and replication. */\n    if (dontsort &&\n        sortval->type == OBJ_SET &&\n        (storekey || c->flags & CLIENT_SCRIPT))\n    {\n        /* Force ALPHA sorting */\n        dontsort = 0;\n        alpha = 1;\n        sortby = NULL;\n    }\n\n    /* Destructively convert encoded sorted sets for SORT. */\n    if (sortval->type == OBJ_ZSET)\n        zsetConvert(sortval, OBJ_ENCODING_SKIPLIST);\n\n    /* Obtain the length of the object to sort. */\n    switch(sortval->type) {\n    case OBJ_LIST: vectorlen = listTypeLength(sortval); break;\n    case OBJ_SET: vectorlen =  setTypeSize(sortval); break;\n    case OBJ_ZSET: vectorlen = dictSize(((zset*)sortval->ptr)->dict); break;\n    default: vectorlen = 0; serverPanic(\"Bad SORT type\"); /* Avoid GCC warning */\n    }\n\n    /* Perform LIMIT start,count sanity checking. */\n    start = (limit_start < 0) ? 0 : limit_start;\n    end = (limit_count < 0) ? vectorlen-1 : start+limit_count-1;\n    if (start >= vectorlen) {\n        start = vectorlen-1;\n        end = vectorlen-2;\n    }\n    if (end >= vectorlen) end = vectorlen-1;\n\n    /* Whenever possible, we load elements into the output array in a more\n     * direct way. This is possible if:\n     *\n     * 1) The object to sort is a sorted set or a list (internally sorted).\n     * 2) There is nothing to sort as dontsort is true (BY <constant string>).\n     *\n     * In this special case, if we have a LIMIT option that actually reduces\n     * the number of elements to fetch, we also optimize to just load the\n     * range we are interested in and allocating a vector that is big enough\n     * for the selected range length. */\n    if ((sortval->type == OBJ_ZSET || sortval->type == OBJ_LIST) &&\n        dontsort &&\n        (start != 0 || end != vectorlen-1))\n    {\n        vectorlen = end-start+1;\n    }\n\n    /* Load the sorting vector with all the objects to sort */\n    vector = zmalloc(sizeof(redisSortObject)*vectorlen);\n    j = 0;\n\n    if (sortval->type == OBJ_LIST && dontsort) {\n        /* Special handling for a list, if 'dontsort' is true.\n         * This makes sure we return elements in the list original\n         * ordering, accordingly to DESC / ASC options.\n         *\n         * Note that in this case we also handle LIMIT here in a direct\n         * way, just getting the required range, as an optimization. */\n        if (end >= start) {\n            listTypeIterator *li;\n            listTypeEntry entry;\n            li = listTypeInitIterator(sortval,\n                    desc ? (long)(listTypeLength(sortval) - start - 1) : start,\n                    desc ? LIST_HEAD : LIST_TAIL);\n\n            while(j < vectorlen && listTypeNext(li,&entry)) {\n                vector[j].obj = listTypeGet(&entry);\n                vector[j].u.score = 0;\n                vector[j].u.cmpobj = NULL;\n                j++;\n            }\n            listTypeReleaseIterator(li);\n            /* Fix start/end: output code is not aware of this optimization. */\n            end -= start;\n            start = 0;\n        }\n    } else if (sortval->type == OBJ_LIST) {\n        listTypeIterator *li = listTypeInitIterator(sortval,0,LIST_TAIL);\n        listTypeEntry entry;\n        while(listTypeNext(li,&entry)) {\n            vector[j].obj = listTypeGet(&entry);\n            vector[j].u.score = 0;\n            vector[j].u.cmpobj = NULL;\n            j++;\n        }\n        listTypeReleaseIterator(li);\n    } else if (sortval->type == OBJ_SET) {\n        setTypeIterator *si = setTypeInitIterator(sortval);\n        sds sdsele;\n        while((sdsele = setTypeNextObject(si)) != NULL) {\n            vector[j].obj = createObject(OBJ_STRING,sdsele);\n            vector[j].u.score = 0;\n            vector[j].u.cmpobj = NULL;\n            j++;\n        }\n        setTypeReleaseIterator(si);\n    } else if (sortval->type == OBJ_ZSET && dontsort) {\n        /* Special handling for a sorted set, if 'dontsort' is true.\n         * This makes sure we return elements in the sorted set original\n         * ordering, accordingly to DESC / ASC options.\n         *\n         * Note that in this case we also handle LIMIT here in a direct\n         * way, just getting the required range, as an optimization. */\n\n        zset *zs = sortval->ptr;\n        zskiplist *zsl = zs->zsl;\n        zskiplistNode *ln;\n        sds sdsele;\n        int rangelen = vectorlen;\n\n        /* Check if starting point is trivial, before doing log(N) lookup. */\n        if (desc) {\n            long zsetlen = dictSize(((zset*)sortval->ptr)->dict);\n\n            ln = zsl->tail;\n            if (start > 0)\n                ln = zslGetElementByRank(zsl,zsetlen-start);\n        } else {\n            ln = zsl->header->level[0].forward;\n            if (start > 0)\n                ln = zslGetElementByRank(zsl,start+1);\n        }\n\n        while(rangelen--) {\n            serverAssertWithInfo(c,sortval,ln != NULL);\n            sdsele = ln->ele;\n            vector[j].obj = createStringObject(sdsele,sdslen(sdsele));\n            vector[j].u.score = 0;\n            vector[j].u.cmpobj = NULL;\n            j++;\n            ln = desc ? ln->backward : ln->level[0].forward;\n        }\n        /* Fix start/end: output code is not aware of this optimization. */\n        end -= start;\n        start = 0;\n    } else if (sortval->type == OBJ_ZSET) {\n        dict *set = ((zset*)sortval->ptr)->dict;\n        dictIterator *di;\n        dictEntry *setele;\n        sds sdsele;\n        di = dictGetIterator(set);\n        while((setele = dictNext(di)) != NULL) {\n            sdsele =  dictGetKey(setele);\n            vector[j].obj = createStringObject(sdsele,sdslen(sdsele));\n            vector[j].u.score = 0;\n            vector[j].u.cmpobj = NULL;\n            j++;\n        }\n        dictReleaseIterator(di);\n    } else {\n        serverPanic(\"Unknown type\");\n    }\n    serverAssertWithInfo(c,sortval,j == vectorlen);\n\n    /* Now it's time to load the right scores in the sorting vector */\n    if (!dontsort) {\n        for (j = 0; j < vectorlen; j++) {\n            robj *byval;\n            if (sortby) {\n                /* lookup value to sort by */\n                byval = lookupKeyByPattern(c->db,sortby,vector[j].obj);\n                if (!byval) continue;\n            } else {\n                /* use object itself to sort by */\n                byval = vector[j].obj;\n            }\n\n            if (alpha) {\n                if (sortby) vector[j].u.cmpobj = getDecodedObject(byval);\n            } else {\n                if (sdsEncodedObject(byval)) {\n                    char *eptr;\n\n                    vector[j].u.score = strtod(byval->ptr,&eptr);\n                    if (eptr[0] != '\\0' || errno == ERANGE ||\n                        isnan(vector[j].u.score))\n                    {\n                        int_conversion_error = 1;\n                    }\n                } else if (byval->encoding == OBJ_ENCODING_INT) {\n                    /* Don't need to decode the object if it's\n                     * integer-encoded (the only encoding supported) so\n                     * far. We can just cast it */\n                    vector[j].u.score = (long)byval->ptr;\n                } else {\n                    serverAssertWithInfo(c,sortval,1 != 1);\n                }\n            }\n\n            /* when the object was retrieved using lookupKeyByPattern,\n             * its refcount needs to be decreased. */\n            if (sortby) {\n                decrRefCount(byval);\n            }\n        }\n\n        server.sort_desc = desc;\n        server.sort_alpha = alpha;\n        server.sort_bypattern = sortby ? 1 : 0;\n        server.sort_store = storekey ? 1 : 0;\n        if (sortby && (start != 0 || end != vectorlen-1))\n            pqsort(vector,vectorlen,sizeof(redisSortObject),sortCompare, start,end);\n        else\n            qsort(vector,vectorlen,sizeof(redisSortObject),sortCompare);\n    }\n\n    /* Send command output to the output buffer, performing the specified\n     * GET/DEL/INCR/DECR operations if any. */\n    outputlen = getop ? getop*(end-start+1) : end-start+1;\n    if (int_conversion_error) {\n        addReplyError(c,\"One or more scores can't be converted into double\");\n    } else if (storekey == NULL) {\n        /* STORE option not specified, sent the sorting result to client */\n        addReplyArrayLen(c,outputlen);\n        for (j = start; j <= end; j++) {\n            listNode *ln;\n            listIter li;\n\n            if (!getop) addReplyBulk(c,vector[j].obj);\n            listRewind(operations,&li);\n            while((ln = listNext(&li))) {\n                redisSortOperation *sop = ln->value;\n                robj *val = lookupKeyByPattern(c->db,sop->pattern,\n                                               vector[j].obj);\n\n                if (sop->type == SORT_OP_GET) {\n                    if (!val) {\n                        addReplyNull(c);\n                    } else {\n                        addReplyBulk(c,val);\n                        decrRefCount(val);\n                    }\n                } else {\n                    /* Always fails */\n                    serverAssertWithInfo(c,sortval,sop->type == SORT_OP_GET);\n                }\n            }\n        }\n    } else {\n        /* We can't predict the size and encoding of the stored list, we\n         * assume it's a large list and then convert it at the end if needed. */\n        robj *sobj = createQuicklistObject();\n\n        /* STORE option specified, set the sorting result as a List object */\n        for (j = start; j <= end; j++) {\n            listNode *ln;\n            listIter li;\n\n            if (!getop) {\n                listTypePush(sobj,vector[j].obj,LIST_TAIL);\n            } else {\n                listRewind(operations,&li);\n                while((ln = listNext(&li))) {\n                    redisSortOperation *sop = ln->value;\n                    robj *val = lookupKeyByPattern(c->db,sop->pattern,\n                                                   vector[j].obj);\n\n                    if (sop->type == SORT_OP_GET) {\n                        if (!val) val = createStringObject(\"\",0);\n\n                        /* listTypePush does an incrRefCount, so we should take care\n                         * care of the incremented refcount caused by either\n                         * lookupKeyByPattern or createStringObject(\"\",0) */\n                        listTypePush(sobj,val,LIST_TAIL);\n                        decrRefCount(val);\n                    } else {\n                        /* Always fails */\n                        serverAssertWithInfo(c,sortval,sop->type == SORT_OP_GET);\n                    }\n                }\n            }\n        }\n        if (outputlen) {\n            listTypeTryConversion(sobj,LIST_CONV_AUTO,NULL,NULL);\n            setKey(c,c->db,storekey,sobj,0);\n            notifyKeyspaceEvent(NOTIFY_LIST,\"sortstore\",storekey,\n                                c->db->id);\n            server.dirty += outputlen;\n        } else if (dbDelete(c->db,storekey)) {\n            signalModifiedKey(c,c->db,storekey);\n            notifyKeyspaceEvent(NOTIFY_GENERIC,\"del\",storekey,c->db->id);\n            server.dirty++;\n        }\n        decrRefCount(sobj);\n        addReplyLongLong(c,outputlen);\n    }\n\n    /* Cleanup */\n    for (j = 0; j < vectorlen; j++)\n        decrRefCount(vector[j].obj);\n\n    decrRefCount(sortval);\n    listRelease(operations);\n    for (j = 0; j < vectorlen; j++) {\n        if (alpha && vector[j].u.cmpobj)\n            decrRefCount(vector[j].u.cmpobj);\n    }\n    zfree(vector);\n}",
  "abstract_func_before": "void sortCommandGeneric(client *VAR_0, int VAR_1) {\n    list *VAR_2;\n    unsigned int VAR_3 = 0;\n    int VAR_4 = 0, VAR_5 = 0;\n    long VAR_6 = 0, VAR_7 = -1, VAR_8, VAR_9;\n    int VAR_10, VAR_11 = 0, VAR_12;\n    int VAR_13 = 0; /* COMMENT_0 */\n    int VAR_14 = 0;\n    int VAR_15 = 0;\n    robj *VAR_16, *VAR_17 = NULL, *VAR_18 = NULL;\n    redisSortObject *VAR_19; /* COMMENT_1 */\n    int VAR_20 = 0; /* COMMENT_2 */\n    /* COMMENT_3 */\n                               \n    VAR_2 = listCreate();\n    listSetFreeMethod(VAR_2,VAR_21);\n    VAR_10 = 2; /* COMMENT_5 */\n\n    VAR_20 = ACLUserCheckCmdWithUnrestrictedKeyAccess(VAR_0->user, VAR_0->cmd, VAR_0->argv, VAR_0->argc, VAR_22);\n\n    /* COMMENT_6 */\n    while(VAR_10 < VAR_0->argc) {\n        int VAR_23 = VAR_0->argc-VAR_10-1;\n        if (!strcasecmp(VAR_0->argv[VAR_10]->ptr,\"asc\")) {\n            VAR_4 = 0;\n        } else if (!strcasecmp(VAR_0->argv[VAR_10]->ptr,\"desc\")) {\n            VAR_4 = 1;\n        } else if (!strcasecmp(VAR_0->argv[VAR_10]->ptr,\"alpha\")) {\n            VAR_5 = 1;\n        } else if (!strcasecmp(VAR_0->argv[VAR_10]->ptr,\"limit\") && VAR_23 >= 2) {\n            if ((getLongFromObjectOrReply(VAR_0, VAR_0->argv[VAR_10+1], &VAR_6, NULL)\n                 != VAR_24) ||\n                (getLongFromObjectOrReply(VAR_0, VAR_0->argv[VAR_10+2], &VAR_7, NULL)\n                 != VAR_24))\n            {\n                VAR_15++;\n                break;\n            }\n            VAR_10+=2;\n        } else if (VAR_1 == 0 && !strcasecmp(VAR_0->argv[VAR_10]->ptr,\"store\") && VAR_23 >= 1) {\n            VAR_18 = VAR_0->argv[VAR_10+1];\n            VAR_10++;\n        } else if (!strcasecmp(VAR_0->argv[VAR_10]->ptr,\"by\") && VAR_23 >= 1) {\n            VAR_17 = VAR_0->argv[VAR_10+1];\n            /* COMMENT_7 */\n                                                                      \n            if (strchr(VAR_0->argv[VAR_10+1]->ptr,'*') == NULL) {\n                VAR_11 = 1;\n            } else {\n                /* COMMENT_9 */\n                                         \n                if (VAR_25.cluster_enabled) {\n                    addReplyError(VAR_0,\"BY option of SORT denied in Cluster mode.\");\n                    VAR_15++;\n                    break;\n                }\n                /* COMMENT_11 */\n                                                                               \n                if (!VAR_20) {\n                    addReplyError(VAR_0,\"BY option of SORT denied due to insufficient ACL permissions.\");\n                    VAR_15++;\n                    break;\n                }\n            }\n            VAR_10++;\n        } else if (!strcasecmp(VAR_0->argv[VAR_10]->ptr,\"get\") && VAR_23 >= 1) {\n            if (VAR_25.cluster_enabled) {\n                addReplyError(VAR_0,\"GET option of SORT denied in Cluster mode.\");\n                VAR_15++;\n                break;\n            }\n            if (!VAR_20) {\n                addReplyError(VAR_0,\"GET option of SORT denied due to insufficient ACL permissions.\");\n                VAR_15++;\n                break;\n            }\n            listAddNodeTail(VAR_2,createSortOperation(\n                VAR_26,VAR_0->argv[VAR_10+1]));\n            VAR_13++;\n            VAR_10++;\n        } else {\n            addReplyErrorObject(VAR_0,VAR_27.syntaxerr);\n            VAR_15++;\n            break;\n        }\n        VAR_10++;\n    }\n\n    /* COMMENT_13 */\n    if (VAR_15) {\n        listRelease(VAR_2);\n        return;\n    }\n\n    /* COMMENT_14 */\n    VAR_16 = lookupKeyRead(VAR_0->db, VAR_0->argv[1]);\n    if (VAR_16 && VAR_16->type != VAR_28 &&\n                   VAR_16->type != VAR_29 &&\n                   VAR_16->type != VAR_30)\n    {\n        listRelease(VAR_2);\n        addReplyErrorObject(VAR_0,VAR_27.wrongtypeerr);\n        return;\n    }\n\n    /* COMMENT_15 */\n                                                                             \n                                                     \n    if (VAR_16)\n        incrRefCount(VAR_16);\n    else\n        VAR_16 = createQuicklistObject();\n\n\n    /* COMMENT_18 */\n                                                                    \n      \n                                                                        \n                                                                       \n                                    \n    if (VAR_11 &&\n        VAR_16->type == VAR_28 &&\n        (VAR_18 || VAR_0->flags & VAR_31))\n    {\n        /* COMMENT_24 */\n        VAR_11 = 0;\n        VAR_5 = 1;\n        VAR_17 = NULL;\n    }\n\n    /* COMMENT_25 */\n    if (VAR_16->type == VAR_30)\n        zsetConvert(VAR_16, VAR_32);\n\n    /* COMMENT_26 */\n    switch(VAR_16->type) {\n    case VAR_29: VAR_12 = listTypeLength(VAR_16); break;\n    case VAR_28: VAR_12 =  setTypeSize(VAR_16); break;\n    case VAR_30: VAR_12 = dictSize(((zset*)VAR_16->ptr)->dict); break;\n    default: VAR_12 = 0; serverPanic(\"Bad SORT type\"); /* COMMENT_27 */\n    }\n\n    /* COMMENT_28 */\n    VAR_8 = (VAR_6 < 0) ? 0 : VAR_6;\n    VAR_9 = (VAR_7 < 0) ? VAR_12-1 : VAR_8+VAR_7-1;\n    if (VAR_8 >= VAR_12) {\n        VAR_8 = VAR_12-1;\n        VAR_9 = VAR_12-2;\n    }\n    if (VAR_9 >= VAR_12) VAR_9 = VAR_12-1;\n\n    /* COMMENT_29 */\n                                       \n      \n                                                                           \n                                                                              \n      \n                                                                            \n                                                                         \n                                                                            \n                                        \n    if ((VAR_16->type == VAR_30 || VAR_16->type == VAR_29) &&\n        VAR_11 &&\n        (VAR_8 != 0 || VAR_9 != VAR_12-1))\n    {\n        VAR_12 = VAR_9-VAR_8+1;\n    }\n\n    /* COMMENT_38 */\n    VAR_19 = zmalloc(sizeof(redisSortObject)*VAR_12);\n    VAR_10 = 0;\n\n    if (VAR_16->type == VAR_29 && VAR_11) {\n        /* COMMENT_39 */\n                                                                  \n                                                       \n          \n                                                                       \n                                                                       \n        if (VAR_9 >= VAR_8) {\n            listTypeIterator *VAR_33;\n            listTypeEntry VAR_34;\n            VAR_33 = listTypeInitIterator(VAR_16,\n                    VAR_4 ? (long)(listTypeLength(VAR_16) - VAR_8 - 1) : VAR_8,\n                    VAR_4 ? VAR_35 : VAR_36);\n\n            while(VAR_10 < VAR_12 && listTypeNext(VAR_33,&VAR_34)) {\n                VAR_19[VAR_10].obj = listTypeGet(&VAR_34);\n                VAR_19[VAR_10].u.score = 0;\n                VAR_19[VAR_10].u.cmpobj = NULL;\n                VAR_10++;\n            }\n            listTypeReleaseIterator(VAR_33);\n            /* COMMENT_45 */\n            VAR_9 -= VAR_8;\n            VAR_8 = 0;\n        }\n    } else if (VAR_16->type == VAR_29) {\n        listTypeIterator *VAR_33 = listTypeInitIterator(VAR_16,0,VAR_36);\n        listTypeEntry VAR_34;\n        while(listTypeNext(VAR_33,&VAR_34)) {\n            VAR_19[VAR_10].obj = listTypeGet(&VAR_34);\n            VAR_19[VAR_10].u.score = 0;\n            VAR_19[VAR_10].u.cmpobj = NULL;\n            VAR_10++;\n        }\n        listTypeReleaseIterator(VAR_33);\n    } else if (VAR_16->type == VAR_28) {\n        setTypeIterator *VAR_37 = setTypeInitIterator(VAR_16);\n        sds VAR_38;\n        while((VAR_38 = setTypeNextObject(VAR_37)) != NULL) {\n            VAR_19[VAR_10].obj = createObject(VAR_39,VAR_38);\n            VAR_19[VAR_10].u.score = 0;\n            VAR_19[VAR_10].u.cmpobj = NULL;\n            VAR_10++;\n        }\n        setTypeReleaseIterator(VAR_37);\n    } else if (VAR_16->type == VAR_30 && VAR_11) {\n        /* COMMENT_46 */\n                                                                        \n                                                       \n          \n                                                                       \n                                                                       \n\n        zset *VAR_40 = VAR_16->ptr;\n        zskiplist *VAR_41 = VAR_40->zsl;\n        zskiplistNode *VAR_42;\n        sds VAR_38;\n        int VAR_43 = VAR_12;\n\n        /* COMMENT_52 */\n        if (VAR_4) {\n            long VAR_44 = dictSize(((zset*)VAR_16->ptr)->dict);\n\n            VAR_42 = VAR_41->tail;\n            if (VAR_8 > 0)\n                VAR_42 = zslGetElementByRank(VAR_41,VAR_44-VAR_8);\n        } else {\n            VAR_42 = VAR_41->header->level[0].forward;\n            if (VAR_8 > 0)\n                VAR_42 = zslGetElementByRank(VAR_41,VAR_8+1);\n        }\n\n        while(VAR_43--) {\n            serverAssertWithInfo(VAR_0,VAR_16,VAR_42 != NULL);\n            VAR_38 = VAR_42->ele;\n            VAR_19[VAR_10].obj = createStringObject(VAR_38,sdslen(VAR_38));\n            VAR_19[VAR_10].u.score = 0;\n            VAR_19[VAR_10].u.cmpobj = NULL;\n            VAR_10++;\n            VAR_42 = VAR_4 ? VAR_42->backward : VAR_42->level[0].forward;\n        }\n        /* COMMENT_45 */\n        VAR_9 -= VAR_8;\n        VAR_8 = 0;\n    } else if (VAR_16->type == VAR_30) {\n        dict *VAR_45 = ((zset*)VAR_16->ptr)->dict;\n        dictIterator *VAR_46;\n        dictEntry *VAR_47;\n        sds VAR_38;\n        VAR_46 = dictGetIterator(VAR_45);\n        while((VAR_47 = dictNext(VAR_46)) != NULL) {\n            VAR_38 =  dictGetKey(VAR_47);\n            VAR_19[VAR_10].obj = createStringObject(VAR_38,sdslen(VAR_38));\n            VAR_19[VAR_10].u.score = 0;\n            VAR_19[VAR_10].u.cmpobj = NULL;\n            VAR_10++;\n        }\n        dictReleaseIterator(VAR_46);\n    } else {\n        serverPanic(\"Unknown type\");\n    }\n    serverAssertWithInfo(VAR_0,VAR_16,VAR_10 == VAR_12);\n\n    /* COMMENT_53 */\n    if (!VAR_11) {\n        for (VAR_10 = 0; VAR_10 < VAR_12; VAR_10++) {\n            robj *VAR_48;\n            if (VAR_17) {\n                /* COMMENT_54 */\n                VAR_48 = lookupKeyByPattern(VAR_0->db,VAR_17,VAR_19[VAR_10].obj);\n                if (!VAR_48) continue;\n            } else {\n                /* COMMENT_55 */\n                VAR_48 = VAR_19[VAR_10].obj;\n            }\n\n            if (VAR_5) {\n                if (VAR_17) VAR_19[VAR_10].u.cmpobj = getDecodedObject(VAR_48);\n            } else {\n                if (sdsEncodedObject(VAR_48)) {\n                    char *VAR_49;\n\n                    VAR_19[VAR_10].u.score = strtod(VAR_48->ptr,&VAR_49);\n                    if (VAR_49[0] != '\\0' || VAR_50 == VAR_51 ||\n                        isnan(VAR_19[VAR_10].u.score))\n                    {\n                        VAR_14 = 1;\n                    }\n                } else if (VAR_48->encoding == VAR_52) {\n                    /* COMMENT_56 */\n                                                                       \n                                                  \n                    VAR_19[VAR_10].u.score = (long)VAR_48->ptr;\n                } else {\n                    serverAssertWithInfo(VAR_0,VAR_16,1 != 1);\n                }\n            }\n\n            /* COMMENT_59 */\n                                                     \n            if (VAR_17) {\n                decrRefCount(VAR_48);\n            }\n        }\n\n        VAR_25.sort_desc = VAR_4;\n        VAR_25.sort_alpha = VAR_5;\n        VAR_25.sort_bypattern = VAR_17 ? 1 : 0;\n        VAR_25.sort_store = VAR_18 ? 1 : 0;\n        if (VAR_17 && (VAR_8 != 0 || VAR_9 != VAR_12-1))\n            pqsort(VAR_19,VAR_12,sizeof(redisSortObject),VAR_53, VAR_8,VAR_9);\n        else\n            qsort(VAR_19,VAR_12,sizeof(redisSortObject),VAR_53);\n    }\n\n    /* COMMENT_61 */\n                                              \n    VAR_3 = VAR_13 ? VAR_13*(VAR_9-VAR_8+1) : VAR_9-VAR_8+1;\n    if (VAR_14) {\n        addReplyError(VAR_0,\"One or more scores can't be converted into double\");\n    } else if (VAR_18 == NULL) {\n        /* COMMENT_63 */\n        addReplyArrayLen(VAR_0,VAR_3);\n        for (VAR_10 = VAR_8; VAR_10 <= VAR_9; VAR_10++) {\n            listNode *VAR_42;\n            listIter VAR_33;\n\n            if (!VAR_13) addReplyBulk(VAR_0,VAR_19[VAR_10].obj);\n            listRewind(VAR_2,&VAR_33);\n            while((VAR_42 = listNext(&VAR_33))) {\n                redisSortOperation *VAR_54 = VAR_42->value;\n                robj *VAR_55 = lookupKeyByPattern(VAR_0->db,VAR_54->pattern,\n                                               VAR_19[VAR_10].obj);\n\n                if (VAR_54->type == VAR_26) {\n                    if (!VAR_55) {\n                        addReplyNull(VAR_0);\n                    } else {\n                        addReplyBulk(VAR_0,VAR_55);\n                        decrRefCount(VAR_55);\n                    }\n                } else {\n                    /* COMMENT_64 */\n                    serverAssertWithInfo(VAR_0,VAR_16,VAR_54->type == VAR_26);\n                }\n            }\n        }\n    } else {\n        /* COMMENT_65 */\n                                                                                \n        robj *VAR_56 = createQuicklistObject();\n\n        /* COMMENT_67 */\n        for (VAR_10 = VAR_8; VAR_10 <= VAR_9; VAR_10++) {\n            listNode *VAR_42;\n            listIter VAR_33;\n\n            if (!VAR_13) {\n                listTypePush(VAR_56,VAR_19[VAR_10].obj,VAR_36);\n            } else {\n                listRewind(VAR_2,&VAR_33);\n                while((VAR_42 = listNext(&VAR_33))) {\n                    redisSortOperation *VAR_54 = VAR_42->value;\n                    robj *VAR_55 = lookupKeyByPattern(VAR_0->db,VAR_54->pattern,\n                                                   VAR_19[VAR_10].obj);\n\n                    if (VAR_54->type == VAR_26) {\n                        if (!VAR_55) VAR_55 = createStringObject(\"\",0);\n\n                        /* COMMENT_68 */\n                                                                            \n                                                                            \n                        listTypePush(VAR_56,VAR_55,VAR_36);\n                        decrRefCount(VAR_55);\n                    } else {\n                        /* COMMENT_64 */\n                        serverAssertWithInfo(VAR_0,VAR_16,VAR_54->type == VAR_26);\n                    }\n                }\n            }\n        }\n        if (VAR_3) {\n            listTypeTryConversion(VAR_56,VAR_57,NULL,NULL);\n            setKey(VAR_0,VAR_0->db,VAR_18,VAR_56,0);\n            notifyKeyspaceEvent(VAR_58,\"sortstore\",VAR_18,\n                                VAR_0->db->id);\n            VAR_25.dirty += VAR_3;\n        } else if (dbDelete(VAR_0->db,VAR_18)) {\n            signalModifiedKey(VAR_0,VAR_0->db,VAR_18);\n            notifyKeyspaceEvent(VAR_59,\"del\",VAR_18,VAR_0->db->id);\n            VAR_25.dirty++;\n        }\n        decrRefCount(VAR_56);\n        addReplyLongLong(VAR_0,VAR_3);\n    }\n\n    /* COMMENT_71 */\n    for (VAR_10 = 0; VAR_10 < VAR_12; VAR_10++)\n        decrRefCount(VAR_19[VAR_10].obj);\n\n    decrRefCount(VAR_16);\n    listRelease(VAR_2);\n    for (VAR_10 = 0; VAR_10 < VAR_12; VAR_10++) {\n        if (VAR_5 && VAR_19[VAR_10].u.cmpobj)\n            decrRefCount(VAR_19[VAR_10].u.cmpobj);\n    }\n    VAR_21(VAR_19);\n}",
  "func_graph_path_before": "redis/1ec82e6e97e1db06a72ca505f9fbf6b981f31ef7/sort.c/vul/before/0.json",
  "func": "void sortCommandGeneric(client *c, int readonly) {\n    list *operations;\n    unsigned int outputlen = 0;\n    int desc = 0, alpha = 0;\n    long limit_start = 0, limit_count = -1, start, end;\n    int j, dontsort = 0, vectorlen;\n    int getop = 0; /* GET operation counter */\n    int int_conversion_error = 0;\n    int syntax_error = 0;\n    robj *sortval, *sortby = NULL, *storekey = NULL;\n    redisSortObject *vector; /* Resulting vector to sort */\n    int user_has_full_key_access = 0; /* ACL - used in order to verify 'get' and 'by' options can be used */\n    /* Create a list of operations to perform for every sorted element.\n     * Operations can be GET */\n    operations = listCreate();\n    listSetFreeMethod(operations,zfree);\n    j = 2; /* options start at argv[2] */\n\n    user_has_full_key_access = ACLUserCheckCmdWithUnrestrictedKeyAccess(c->user, c->cmd, c->argv, c->argc, CMD_KEY_ACCESS);\n\n    /* The SORT command has an SQL-alike syntax, parse it */\n    while(j < c->argc) {\n        int leftargs = c->argc-j-1;\n        if (!strcasecmp(c->argv[j]->ptr,\"asc\")) {\n            desc = 0;\n        } else if (!strcasecmp(c->argv[j]->ptr,\"desc\")) {\n            desc = 1;\n        } else if (!strcasecmp(c->argv[j]->ptr,\"alpha\")) {\n            alpha = 1;\n        } else if (!strcasecmp(c->argv[j]->ptr,\"limit\") && leftargs >= 2) {\n            if ((getLongFromObjectOrReply(c, c->argv[j+1], &limit_start, NULL)\n                 != C_OK) ||\n                (getLongFromObjectOrReply(c, c->argv[j+2], &limit_count, NULL)\n                 != C_OK))\n            {\n                syntax_error++;\n                break;\n            }\n            j+=2;\n        } else if (readonly == 0 && !strcasecmp(c->argv[j]->ptr,\"store\") && leftargs >= 1) {\n            storekey = c->argv[j+1];\n            j++;\n        } else if (!strcasecmp(c->argv[j]->ptr,\"by\") && leftargs >= 1) {\n            sortby = c->argv[j+1];\n            /* If the BY pattern does not contain '*', i.e. it is constant,\n             * we don't need to sort nor to lookup the weight keys. */\n            if (strchr(c->argv[j+1]->ptr,'*') == NULL) {\n                dontsort = 1;\n            } else {\n                /* If BY is specified with a real pattern, we can't accept\n                 * it in cluster mode. */\n                if (server.cluster_enabled) {\n                    addReplyError(c,\"BY option of SORT denied in Cluster mode.\");\n                    syntax_error++;\n                    break;\n                }\n                /* If BY is specified with a real pattern, we can't accept\n                 * it if no full ACL key access is applied for this command. */\n                if (!user_has_full_key_access) {\n                    addReplyError(c,\"BY option of SORT denied due to insufficient ACL permissions.\");\n                    syntax_error++;\n                    break;\n                }\n            }\n            j++;\n        } else if (!strcasecmp(c->argv[j]->ptr,\"get\") && leftargs >= 1) {\n            if (server.cluster_enabled) {\n                addReplyError(c,\"GET option of SORT denied in Cluster mode.\");\n                syntax_error++;\n                break;\n            }\n            if (!user_has_full_key_access) {\n                addReplyError(c,\"GET option of SORT denied due to insufficient ACL permissions.\");\n                syntax_error++;\n                break;\n            }\n            listAddNodeTail(operations,createSortOperation(\n                SORT_OP_GET,c->argv[j+1]));\n            getop++;\n            j++;\n        } else {\n            addReplyErrorObject(c,shared.syntaxerr);\n            syntax_error++;\n            break;\n        }\n        j++;\n    }\n\n    /* Handle syntax errors set during options parsing. */\n    if (syntax_error) {\n        listRelease(operations);\n        return;\n    }\n\n    /* Lookup the key to sort. It must be of the right types */\n    sortval = lookupKeyRead(c->db, c->argv[1]);\n    if (sortval && sortval->type != OBJ_SET &&\n                   sortval->type != OBJ_LIST &&\n                   sortval->type != OBJ_ZSET)\n    {\n        listRelease(operations);\n        addReplyErrorObject(c,shared.wrongtypeerr);\n        return;\n    }\n\n    /* Now we need to protect sortval incrementing its count, in the future\n     * SORT may have options able to overwrite/delete keys during the sorting\n     * and the sorted key itself may get destroyed */\n    if (sortval)\n        incrRefCount(sortval);\n    else\n        sortval = createQuicklistObject();\n\n\n    /* When sorting a set with no sort specified, we must sort the output\n     * so the result is consistent across scripting and replication.\n     *\n     * The other types (list, sorted set) will retain their native order\n     * even if no sort order is requested, so they remain stable across\n     * scripting and replication. */\n    if (dontsort &&\n        sortval->type == OBJ_SET &&\n        (storekey || c->flags & CLIENT_SCRIPT))\n    {\n        /* Force ALPHA sorting */\n        dontsort = 0;\n        alpha = 1;\n        sortby = NULL;\n    }\n\n    /* Destructively convert encoded sorted sets for SORT. */\n    if (sortval->type == OBJ_ZSET)\n        zsetConvert(sortval, OBJ_ENCODING_SKIPLIST);\n\n    /* Obtain the length of the object to sort. */\n    switch(sortval->type) {\n    case OBJ_LIST: vectorlen = listTypeLength(sortval); break;\n    case OBJ_SET: vectorlen =  setTypeSize(sortval); break;\n    case OBJ_ZSET: vectorlen = dictSize(((zset*)sortval->ptr)->dict); break;\n    default: vectorlen = 0; serverPanic(\"Bad SORT type\"); /* Avoid GCC warning */\n    }\n\n    /* Perform LIMIT start,count sanity checking.\n     * And avoid integer overflow by limiting inputs to object sizes. */\n    start = min(max(limit_start, 0), vectorlen);\n    limit_count = min(max(limit_count, -1), vectorlen);\n    end = (limit_count < 0) ? vectorlen-1 : start+limit_count-1;\n    if (start >= vectorlen) {\n        start = vectorlen-1;\n        end = vectorlen-2;\n    }\n    if (end >= vectorlen) end = vectorlen-1;\n\n    /* Whenever possible, we load elements into the output array in a more\n     * direct way. This is possible if:\n     *\n     * 1) The object to sort is a sorted set or a list (internally sorted).\n     * 2) There is nothing to sort as dontsort is true (BY <constant string>).\n     *\n     * In this special case, if we have a LIMIT option that actually reduces\n     * the number of elements to fetch, we also optimize to just load the\n     * range we are interested in and allocating a vector that is big enough\n     * for the selected range length. */\n    if ((sortval->type == OBJ_ZSET || sortval->type == OBJ_LIST) &&\n        dontsort &&\n        (start != 0 || end != vectorlen-1))\n    {\n        vectorlen = end-start+1;\n    }\n\n    /* Load the sorting vector with all the objects to sort */\n    vector = zmalloc(sizeof(redisSortObject)*vectorlen);\n    j = 0;\n\n    if (sortval->type == OBJ_LIST && dontsort) {\n        /* Special handling for a list, if 'dontsort' is true.\n         * This makes sure we return elements in the list original\n         * ordering, accordingly to DESC / ASC options.\n         *\n         * Note that in this case we also handle LIMIT here in a direct\n         * way, just getting the required range, as an optimization. */\n        if (end >= start) {\n            listTypeIterator *li;\n            listTypeEntry entry;\n            li = listTypeInitIterator(sortval,\n                    desc ? (long)(listTypeLength(sortval) - start - 1) : start,\n                    desc ? LIST_HEAD : LIST_TAIL);\n\n            while(j < vectorlen && listTypeNext(li,&entry)) {\n                vector[j].obj = listTypeGet(&entry);\n                vector[j].u.score = 0;\n                vector[j].u.cmpobj = NULL;\n                j++;\n            }\n            listTypeReleaseIterator(li);\n            /* Fix start/end: output code is not aware of this optimization. */\n            end -= start;\n            start = 0;\n        }\n    } else if (sortval->type == OBJ_LIST) {\n        listTypeIterator *li = listTypeInitIterator(sortval,0,LIST_TAIL);\n        listTypeEntry entry;\n        while(listTypeNext(li,&entry)) {\n            vector[j].obj = listTypeGet(&entry);\n            vector[j].u.score = 0;\n            vector[j].u.cmpobj = NULL;\n            j++;\n        }\n        listTypeReleaseIterator(li);\n    } else if (sortval->type == OBJ_SET) {\n        setTypeIterator *si = setTypeInitIterator(sortval);\n        sds sdsele;\n        while((sdsele = setTypeNextObject(si)) != NULL) {\n            vector[j].obj = createObject(OBJ_STRING,sdsele);\n            vector[j].u.score = 0;\n            vector[j].u.cmpobj = NULL;\n            j++;\n        }\n        setTypeReleaseIterator(si);\n    } else if (sortval->type == OBJ_ZSET && dontsort) {\n        /* Special handling for a sorted set, if 'dontsort' is true.\n         * This makes sure we return elements in the sorted set original\n         * ordering, accordingly to DESC / ASC options.\n         *\n         * Note that in this case we also handle LIMIT here in a direct\n         * way, just getting the required range, as an optimization. */\n\n        zset *zs = sortval->ptr;\n        zskiplist *zsl = zs->zsl;\n        zskiplistNode *ln;\n        sds sdsele;\n        int rangelen = vectorlen;\n\n        /* Check if starting point is trivial, before doing log(N) lookup. */\n        if (desc) {\n            long zsetlen = dictSize(((zset*)sortval->ptr)->dict);\n\n            ln = zsl->tail;\n            if (start > 0)\n                ln = zslGetElementByRank(zsl,zsetlen-start);\n        } else {\n            ln = zsl->header->level[0].forward;\n            if (start > 0)\n                ln = zslGetElementByRank(zsl,start+1);\n        }\n\n        while(rangelen--) {\n            serverAssertWithInfo(c,sortval,ln != NULL);\n            sdsele = ln->ele;\n            vector[j].obj = createStringObject(sdsele,sdslen(sdsele));\n            vector[j].u.score = 0;\n            vector[j].u.cmpobj = NULL;\n            j++;\n            ln = desc ? ln->backward : ln->level[0].forward;\n        }\n        /* Fix start/end: output code is not aware of this optimization. */\n        end -= start;\n        start = 0;\n    } else if (sortval->type == OBJ_ZSET) {\n        dict *set = ((zset*)sortval->ptr)->dict;\n        dictIterator *di;\n        dictEntry *setele;\n        sds sdsele;\n        di = dictGetIterator(set);\n        while((setele = dictNext(di)) != NULL) {\n            sdsele =  dictGetKey(setele);\n            vector[j].obj = createStringObject(sdsele,sdslen(sdsele));\n            vector[j].u.score = 0;\n            vector[j].u.cmpobj = NULL;\n            j++;\n        }\n        dictReleaseIterator(di);\n    } else {\n        serverPanic(\"Unknown type\");\n    }\n    serverAssertWithInfo(c,sortval,j == vectorlen);\n\n    /* Now it's time to load the right scores in the sorting vector */\n    if (!dontsort) {\n        for (j = 0; j < vectorlen; j++) {\n            robj *byval;\n            if (sortby) {\n                /* lookup value to sort by */\n                byval = lookupKeyByPattern(c->db,sortby,vector[j].obj);\n                if (!byval) continue;\n            } else {\n                /* use object itself to sort by */\n                byval = vector[j].obj;\n            }\n\n            if (alpha) {\n                if (sortby) vector[j].u.cmpobj = getDecodedObject(byval);\n            } else {\n                if (sdsEncodedObject(byval)) {\n                    char *eptr;\n\n                    vector[j].u.score = strtod(byval->ptr,&eptr);\n                    if (eptr[0] != '\\0' || errno == ERANGE ||\n                        isnan(vector[j].u.score))\n                    {\n                        int_conversion_error = 1;\n                    }\n                } else if (byval->encoding == OBJ_ENCODING_INT) {\n                    /* Don't need to decode the object if it's\n                     * integer-encoded (the only encoding supported) so\n                     * far. We can just cast it */\n                    vector[j].u.score = (long)byval->ptr;\n                } else {\n                    serverAssertWithInfo(c,sortval,1 != 1);\n                }\n            }\n\n            /* when the object was retrieved using lookupKeyByPattern,\n             * its refcount needs to be decreased. */\n            if (sortby) {\n                decrRefCount(byval);\n            }\n        }\n\n        server.sort_desc = desc;\n        server.sort_alpha = alpha;\n        server.sort_bypattern = sortby ? 1 : 0;\n        server.sort_store = storekey ? 1 : 0;\n        if (sortby && (start != 0 || end != vectorlen-1))\n            pqsort(vector,vectorlen,sizeof(redisSortObject),sortCompare, start,end);\n        else\n            qsort(vector,vectorlen,sizeof(redisSortObject),sortCompare);\n    }\n\n    /* Send command output to the output buffer, performing the specified\n     * GET/DEL/INCR/DECR operations if any. */\n    outputlen = getop ? getop*(end-start+1) : end-start+1;\n    if (int_conversion_error) {\n        addReplyError(c,\"One or more scores can't be converted into double\");\n    } else if (storekey == NULL) {\n        /* STORE option not specified, sent the sorting result to client */\n        addReplyArrayLen(c,outputlen);\n        for (j = start; j <= end; j++) {\n            listNode *ln;\n            listIter li;\n\n            if (!getop) addReplyBulk(c,vector[j].obj);\n            listRewind(operations,&li);\n            while((ln = listNext(&li))) {\n                redisSortOperation *sop = ln->value;\n                robj *val = lookupKeyByPattern(c->db,sop->pattern,\n                                               vector[j].obj);\n\n                if (sop->type == SORT_OP_GET) {\n                    if (!val) {\n                        addReplyNull(c);\n                    } else {\n                        addReplyBulk(c,val);\n                        decrRefCount(val);\n                    }\n                } else {\n                    /* Always fails */\n                    serverAssertWithInfo(c,sortval,sop->type == SORT_OP_GET);\n                }\n            }\n        }\n    } else {\n        /* We can't predict the size and encoding of the stored list, we\n         * assume it's a large list and then convert it at the end if needed. */\n        robj *sobj = createQuicklistObject();\n\n        /* STORE option specified, set the sorting result as a List object */\n        for (j = start; j <= end; j++) {\n            listNode *ln;\n            listIter li;\n\n            if (!getop) {\n                listTypePush(sobj,vector[j].obj,LIST_TAIL);\n            } else {\n                listRewind(operations,&li);\n                while((ln = listNext(&li))) {\n                    redisSortOperation *sop = ln->value;\n                    robj *val = lookupKeyByPattern(c->db,sop->pattern,\n                                                   vector[j].obj);\n\n                    if (sop->type == SORT_OP_GET) {\n                        if (!val) val = createStringObject(\"\",0);\n\n                        /* listTypePush does an incrRefCount, so we should take care\n                         * care of the incremented refcount caused by either\n                         * lookupKeyByPattern or createStringObject(\"\",0) */\n                        listTypePush(sobj,val,LIST_TAIL);\n                        decrRefCount(val);\n                    } else {\n                        /* Always fails */\n                        serverAssertWithInfo(c,sortval,sop->type == SORT_OP_GET);\n                    }\n                }\n            }\n        }\n        if (outputlen) {\n            listTypeTryConversion(sobj,LIST_CONV_AUTO,NULL,NULL);\n            setKey(c,c->db,storekey,sobj,0);\n            notifyKeyspaceEvent(NOTIFY_LIST,\"sortstore\",storekey,\n                                c->db->id);\n            server.dirty += outputlen;\n        } else if (dbDelete(c->db,storekey)) {\n            signalModifiedKey(c,c->db,storekey);\n            notifyKeyspaceEvent(NOTIFY_GENERIC,\"del\",storekey,c->db->id);\n            server.dirty++;\n        }\n        decrRefCount(sobj);\n        addReplyLongLong(c,outputlen);\n    }\n\n    /* Cleanup */\n    for (j = 0; j < vectorlen; j++)\n        decrRefCount(vector[j].obj);\n\n    decrRefCount(sortval);\n    listRelease(operations);\n    for (j = 0; j < vectorlen; j++) {\n        if (alpha && vector[j].u.cmpobj)\n            decrRefCount(vector[j].u.cmpobj);\n    }\n    zfree(vector);\n}",
  "abstract_func": "void sortCommandGeneric(client *VAR_0, int VAR_1) {\n    list *VAR_2;\n    unsigned int VAR_3 = 0;\n    int VAR_4 = 0, VAR_5 = 0;\n    long VAR_6 = 0, VAR_7 = -1, VAR_8, VAR_9;\n    int VAR_10, VAR_11 = 0, VAR_12;\n    int VAR_13 = 0; /* COMMENT_0 */\n    int VAR_14 = 0;\n    int VAR_15 = 0;\n    robj *VAR_16, *VAR_17 = NULL, *VAR_18 = NULL;\n    redisSortObject *VAR_19; /* COMMENT_1 */\n    int VAR_20 = 0; /* COMMENT_2 */\n    /* COMMENT_3 */\n                               \n    VAR_2 = listCreate();\n    listSetFreeMethod(VAR_2,VAR_21);\n    VAR_10 = 2; /* COMMENT_5 */\n\n    VAR_20 = ACLUserCheckCmdWithUnrestrictedKeyAccess(VAR_0->user, VAR_0->cmd, VAR_0->argv, VAR_0->argc, VAR_22);\n\n    /* COMMENT_6 */\n    while(VAR_10 < VAR_0->argc) {\n        int VAR_23 = VAR_0->argc-VAR_10-1;\n        if (!strcasecmp(VAR_0->argv[VAR_10]->ptr,\"asc\")) {\n            VAR_4 = 0;\n        } else if (!strcasecmp(VAR_0->argv[VAR_10]->ptr,\"desc\")) {\n            VAR_4 = 1;\n        } else if (!strcasecmp(VAR_0->argv[VAR_10]->ptr,\"alpha\")) {\n            VAR_5 = 1;\n        } else if (!strcasecmp(VAR_0->argv[VAR_10]->ptr,\"limit\") && VAR_23 >= 2) {\n            if ((getLongFromObjectOrReply(VAR_0, VAR_0->argv[VAR_10+1], &VAR_6, NULL)\n                 != VAR_24) ||\n                (getLongFromObjectOrReply(VAR_0, VAR_0->argv[VAR_10+2], &VAR_7, NULL)\n                 != VAR_24))\n            {\n                VAR_15++;\n                break;\n            }\n            VAR_10+=2;\n        } else if (VAR_1 == 0 && !strcasecmp(VAR_0->argv[VAR_10]->ptr,\"store\") && VAR_23 >= 1) {\n            VAR_18 = VAR_0->argv[VAR_10+1];\n            VAR_10++;\n        } else if (!strcasecmp(VAR_0->argv[VAR_10]->ptr,\"by\") && VAR_23 >= 1) {\n            VAR_17 = VAR_0->argv[VAR_10+1];\n            /* COMMENT_7 */\n                                                                      \n            if (strchr(VAR_0->argv[VAR_10+1]->ptr,'*') == NULL) {\n                VAR_11 = 1;\n            } else {\n                /* COMMENT_9 */\n                                         \n                if (VAR_25.cluster_enabled) {\n                    addReplyError(VAR_0,\"BY option of SORT denied in Cluster mode.\");\n                    VAR_15++;\n                    break;\n                }\n                /* COMMENT_11 */\n                                                                               \n                if (!VAR_20) {\n                    addReplyError(VAR_0,\"BY option of SORT denied due to insufficient ACL permissions.\");\n                    VAR_15++;\n                    break;\n                }\n            }\n            VAR_10++;\n        } else if (!strcasecmp(VAR_0->argv[VAR_10]->ptr,\"get\") && VAR_23 >= 1) {\n            if (VAR_25.cluster_enabled) {\n                addReplyError(VAR_0,\"GET option of SORT denied in Cluster mode.\");\n                VAR_15++;\n                break;\n            }\n            if (!VAR_20) {\n                addReplyError(VAR_0,\"GET option of SORT denied due to insufficient ACL permissions.\");\n                VAR_15++;\n                break;\n            }\n            listAddNodeTail(VAR_2,createSortOperation(\n                VAR_26,VAR_0->argv[VAR_10+1]));\n            VAR_13++;\n            VAR_10++;\n        } else {\n            addReplyErrorObject(VAR_0,VAR_27.syntaxerr);\n            VAR_15++;\n            break;\n        }\n        VAR_10++;\n    }\n\n    /* COMMENT_13 */\n    if (VAR_15) {\n        listRelease(VAR_2);\n        return;\n    }\n\n    /* COMMENT_14 */\n    VAR_16 = lookupKeyRead(VAR_0->db, VAR_0->argv[1]);\n    if (VAR_16 && VAR_16->type != VAR_28 &&\n                   VAR_16->type != VAR_29 &&\n                   VAR_16->type != VAR_30)\n    {\n        listRelease(VAR_2);\n        addReplyErrorObject(VAR_0,VAR_27.wrongtypeerr);\n        return;\n    }\n\n    /* COMMENT_15 */\n                                                                             \n                                                     \n    if (VAR_16)\n        incrRefCount(VAR_16);\n    else\n        VAR_16 = createQuicklistObject();\n\n\n    /* COMMENT_18 */\n                                                                    \n      \n                                                                        \n                                                                       \n                                    \n    if (VAR_11 &&\n        VAR_16->type == VAR_28 &&\n        (VAR_18 || VAR_0->flags & VAR_31))\n    {\n        /* COMMENT_24 */\n        VAR_11 = 0;\n        VAR_5 = 1;\n        VAR_17 = NULL;\n    }\n\n    /* COMMENT_25 */\n    if (VAR_16->type == VAR_30)\n        zsetConvert(VAR_16, VAR_32);\n\n    /* COMMENT_26 */\n    switch(VAR_16->type) {\n    case VAR_29: VAR_12 = listTypeLength(VAR_16); break;\n    case VAR_28: VAR_12 =  setTypeSize(VAR_16); break;\n    case VAR_30: VAR_12 = dictSize(((zset*)VAR_16->ptr)->dict); break;\n    default: VAR_12 = 0; serverPanic(\"Bad SORT type\"); /* COMMENT_27 */\n    }\n\n    /* COMMENT_28 */\n                                                                        \n    VAR_8 = min(max(VAR_6, 0), VAR_12);\n    VAR_7 = min(max(VAR_7, -1), VAR_12);\n    VAR_9 = (VAR_7 < 0) ? VAR_12-1 : VAR_8+VAR_7-1;\n    if (VAR_8 >= VAR_12) {\n        VAR_8 = VAR_12-1;\n        VAR_9 = VAR_12-2;\n    }\n    if (VAR_9 >= VAR_12) VAR_9 = VAR_12-1;\n\n    /* COMMENT_30 */\n                                       \n      \n                                                                           \n                                                                              \n      \n                                                                            \n                                                                         \n                                                                            \n                                        \n    if ((VAR_16->type == VAR_30 || VAR_16->type == VAR_29) &&\n        VAR_11 &&\n        (VAR_8 != 0 || VAR_9 != VAR_12-1))\n    {\n        VAR_12 = VAR_9-VAR_8+1;\n    }\n\n    /* COMMENT_39 */\n    VAR_19 = zmalloc(sizeof(redisSortObject)*VAR_12);\n    VAR_10 = 0;\n\n    if (VAR_16->type == VAR_29 && VAR_11) {\n        /* COMMENT_40 */\n                                                                  \n                                                       \n          \n                                                                       \n                                                                       \n        if (VAR_9 >= VAR_8) {\n            listTypeIterator *VAR_33;\n            listTypeEntry VAR_34;\n            VAR_33 = listTypeInitIterator(VAR_16,\n                    VAR_4 ? (long)(listTypeLength(VAR_16) - VAR_8 - 1) : VAR_8,\n                    VAR_4 ? VAR_35 : VAR_36);\n\n            while(VAR_10 < VAR_12 && listTypeNext(VAR_33,&VAR_34)) {\n                VAR_19[VAR_10].obj = listTypeGet(&VAR_34);\n                VAR_19[VAR_10].u.score = 0;\n                VAR_19[VAR_10].u.cmpobj = NULL;\n                VAR_10++;\n            }\n            listTypeReleaseIterator(VAR_33);\n            /* COMMENT_46 */\n            VAR_9 -= VAR_8;\n            VAR_8 = 0;\n        }\n    } else if (VAR_16->type == VAR_29) {\n        listTypeIterator *VAR_33 = listTypeInitIterator(VAR_16,0,VAR_36);\n        listTypeEntry VAR_34;\n        while(listTypeNext(VAR_33,&VAR_34)) {\n            VAR_19[VAR_10].obj = listTypeGet(&VAR_34);\n            VAR_19[VAR_10].u.score = 0;\n            VAR_19[VAR_10].u.cmpobj = NULL;\n            VAR_10++;\n        }\n        listTypeReleaseIterator(VAR_33);\n    } else if (VAR_16->type == VAR_28) {\n        setTypeIterator *VAR_37 = setTypeInitIterator(VAR_16);\n        sds VAR_38;\n        while((VAR_38 = setTypeNextObject(VAR_37)) != NULL) {\n            VAR_19[VAR_10].obj = createObject(VAR_39,VAR_38);\n            VAR_19[VAR_10].u.score = 0;\n            VAR_19[VAR_10].u.cmpobj = NULL;\n            VAR_10++;\n        }\n        setTypeReleaseIterator(VAR_37);\n    } else if (VAR_16->type == VAR_30 && VAR_11) {\n        /* COMMENT_47 */\n                                                                        \n                                                       \n          \n                                                                       \n                                                                       \n\n        zset *VAR_40 = VAR_16->ptr;\n        zskiplist *VAR_41 = VAR_40->zsl;\n        zskiplistNode *VAR_42;\n        sds VAR_38;\n        int VAR_43 = VAR_12;\n\n        /* COMMENT_53 */\n        if (VAR_4) {\n            long VAR_44 = dictSize(((zset*)VAR_16->ptr)->dict);\n\n            VAR_42 = VAR_41->tail;\n            if (VAR_8 > 0)\n                VAR_42 = zslGetElementByRank(VAR_41,VAR_44-VAR_8);\n        } else {\n            VAR_42 = VAR_41->header->level[0].forward;\n            if (VAR_8 > 0)\n                VAR_42 = zslGetElementByRank(VAR_41,VAR_8+1);\n        }\n\n        while(VAR_43--) {\n            serverAssertWithInfo(VAR_0,VAR_16,VAR_42 != NULL);\n            VAR_38 = VAR_42->ele;\n            VAR_19[VAR_10].obj = createStringObject(VAR_38,sdslen(VAR_38));\n            VAR_19[VAR_10].u.score = 0;\n            VAR_19[VAR_10].u.cmpobj = NULL;\n            VAR_10++;\n            VAR_42 = VAR_4 ? VAR_42->backward : VAR_42->level[0].forward;\n        }\n        /* COMMENT_46 */\n        VAR_9 -= VAR_8;\n        VAR_8 = 0;\n    } else if (VAR_16->type == VAR_30) {\n        dict *VAR_45 = ((zset*)VAR_16->ptr)->dict;\n        dictIterator *VAR_46;\n        dictEntry *VAR_47;\n        sds VAR_38;\n        VAR_46 = dictGetIterator(VAR_45);\n        while((VAR_47 = dictNext(VAR_46)) != NULL) {\n            VAR_38 =  dictGetKey(VAR_47);\n            VAR_19[VAR_10].obj = createStringObject(VAR_38,sdslen(VAR_38));\n            VAR_19[VAR_10].u.score = 0;\n            VAR_19[VAR_10].u.cmpobj = NULL;\n            VAR_10++;\n        }\n        dictReleaseIterator(VAR_46);\n    } else {\n        serverPanic(\"Unknown type\");\n    }\n    serverAssertWithInfo(VAR_0,VAR_16,VAR_10 == VAR_12);\n\n    /* COMMENT_54 */\n    if (!VAR_11) {\n        for (VAR_10 = 0; VAR_10 < VAR_12; VAR_10++) {\n            robj *VAR_48;\n            if (VAR_17) {\n                /* COMMENT_55 */\n                VAR_48 = lookupKeyByPattern(VAR_0->db,VAR_17,VAR_19[VAR_10].obj);\n                if (!VAR_48) continue;\n            } else {\n                /* COMMENT_56 */\n                VAR_48 = VAR_19[VAR_10].obj;\n            }\n\n            if (VAR_5) {\n                if (VAR_17) VAR_19[VAR_10].u.cmpobj = getDecodedObject(VAR_48);\n            } else {\n                if (sdsEncodedObject(VAR_48)) {\n                    char *VAR_49;\n\n                    VAR_19[VAR_10].u.score = strtod(VAR_48->ptr,&VAR_49);\n                    if (VAR_49[0] != '\\0' || VAR_50 == VAR_51 ||\n                        isnan(VAR_19[VAR_10].u.score))\n                    {\n                        VAR_14 = 1;\n                    }\n                } else if (VAR_48->encoding == VAR_52) {\n                    /* COMMENT_57 */\n                                                                       \n                                                  \n                    VAR_19[VAR_10].u.score = (long)VAR_48->ptr;\n                } else {\n                    serverAssertWithInfo(VAR_0,VAR_16,1 != 1);\n                }\n            }\n\n            /* COMMENT_60 */\n                                                     \n            if (VAR_17) {\n                decrRefCount(VAR_48);\n            }\n        }\n\n        VAR_25.sort_desc = VAR_4;\n        VAR_25.sort_alpha = VAR_5;\n        VAR_25.sort_bypattern = VAR_17 ? 1 : 0;\n        VAR_25.sort_store = VAR_18 ? 1 : 0;\n        if (VAR_17 && (VAR_8 != 0 || VAR_9 != VAR_12-1))\n            pqsort(VAR_19,VAR_12,sizeof(redisSortObject),VAR_53, VAR_8,VAR_9);\n        else\n            qsort(VAR_19,VAR_12,sizeof(redisSortObject),VAR_53);\n    }\n\n    /* COMMENT_62 */\n                                              \n    VAR_3 = VAR_13 ? VAR_13*(VAR_9-VAR_8+1) : VAR_9-VAR_8+1;\n    if (VAR_14) {\n        addReplyError(VAR_0,\"One or more scores can't be converted into double\");\n    } else if (VAR_18 == NULL) {\n        /* COMMENT_64 */\n        addReplyArrayLen(VAR_0,VAR_3);\n        for (VAR_10 = VAR_8; VAR_10 <= VAR_9; VAR_10++) {\n            listNode *VAR_42;\n            listIter VAR_33;\n\n            if (!VAR_13) addReplyBulk(VAR_0,VAR_19[VAR_10].obj);\n            listRewind(VAR_2,&VAR_33);\n            while((VAR_42 = listNext(&VAR_33))) {\n                redisSortOperation *VAR_54 = VAR_42->value;\n                robj *VAR_55 = lookupKeyByPattern(VAR_0->db,VAR_54->pattern,\n                                               VAR_19[VAR_10].obj);\n\n                if (VAR_54->type == VAR_26) {\n                    if (!VAR_55) {\n                        addReplyNull(VAR_0);\n                    } else {\n                        addReplyBulk(VAR_0,VAR_55);\n                        decrRefCount(VAR_55);\n                    }\n                } else {\n                    /* COMMENT_65 */\n                    serverAssertWithInfo(VAR_0,VAR_16,VAR_54->type == VAR_26);\n                }\n            }\n        }\n    } else {\n        /* COMMENT_66 */\n                                                                                \n        robj *VAR_56 = createQuicklistObject();\n\n        /* COMMENT_68 */\n        for (VAR_10 = VAR_8; VAR_10 <= VAR_9; VAR_10++) {\n            listNode *VAR_42;\n            listIter VAR_33;\n\n            if (!VAR_13) {\n                listTypePush(VAR_56,VAR_19[VAR_10].obj,VAR_36);\n            } else {\n                listRewind(VAR_2,&VAR_33);\n                while((VAR_42 = listNext(&VAR_33))) {\n                    redisSortOperation *VAR_54 = VAR_42->value;\n                    robj *VAR_55 = lookupKeyByPattern(VAR_0->db,VAR_54->pattern,\n                                                   VAR_19[VAR_10].obj);\n\n                    if (VAR_54->type == VAR_26) {\n                        if (!VAR_55) VAR_55 = createStringObject(\"\",0);\n\n                        /* COMMENT_69 */\n                                                                            \n                                                                            \n                        listTypePush(VAR_56,VAR_55,VAR_36);\n                        decrRefCount(VAR_55);\n                    } else {\n                        /* COMMENT_65 */\n                        serverAssertWithInfo(VAR_0,VAR_16,VAR_54->type == VAR_26);\n                    }\n                }\n            }\n        }\n        if (VAR_3) {\n            listTypeTryConversion(VAR_56,VAR_57,NULL,NULL);\n            setKey(VAR_0,VAR_0->db,VAR_18,VAR_56,0);\n            notifyKeyspaceEvent(VAR_58,\"sortstore\",VAR_18,\n                                VAR_0->db->id);\n            VAR_25.dirty += VAR_3;\n        } else if (dbDelete(VAR_0->db,VAR_18)) {\n            signalModifiedKey(VAR_0,VAR_0->db,VAR_18);\n            notifyKeyspaceEvent(VAR_59,\"del\",VAR_18,VAR_0->db->id);\n            VAR_25.dirty++;\n        }\n        decrRefCount(VAR_56);\n        addReplyLongLong(VAR_0,VAR_3);\n    }\n\n    /* COMMENT_72 */\n    for (VAR_10 = 0; VAR_10 < VAR_12; VAR_10++)\n        decrRefCount(VAR_19[VAR_10].obj);\n\n    decrRefCount(VAR_16);\n    listRelease(VAR_2);\n    for (VAR_10 = 0; VAR_10 < VAR_12; VAR_10++) {\n        if (VAR_5 && VAR_19[VAR_10].u.cmpobj)\n            decrRefCount(VAR_19[VAR_10].u.cmpobj);\n    }\n    VAR_21(VAR_19);\n}",
  "func_graph_path": "redis/1ec82e6e97e1db06a72ca505f9fbf6b981f31ef7/sort.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -140,8 +140,10 @@\n     default: vectorlen = 0; serverPanic(\"Bad SORT type\"); /* Avoid GCC warning */\n     }\n \n-    /* Perform LIMIT start,count sanity checking. */\n-    start = (limit_start < 0) ? 0 : limit_start;\n+    /* Perform LIMIT start,count sanity checking.\n+     * And avoid integer overflow by limiting inputs to object sizes. */\n+    start = min(max(limit_start, 0), vectorlen);\n+    limit_count = min(max(limit_count, -1), vectorlen);\n     end = (limit_count < 0) ? vectorlen-1 : start+limit_count-1;\n     if (start >= vectorlen) {\n         start = vectorlen-1;",
  "diff_line_info": {
    "deleted_lines": [
      "    /* Perform LIMIT start,count sanity checking. */",
      "    start = (limit_start < 0) ? 0 : limit_start;"
    ],
    "added_lines": [
      "    /* Perform LIMIT start,count sanity checking.",
      "     * And avoid integer overflow by limiting inputs to object sizes. */",
      "    start = min(max(limit_start, 0), vectorlen);",
      "    limit_count = min(max(limit_count, -1), vectorlen);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/redis/redis/pull/11720",
  "description": {
    "pr_info": {
      "title": "Avoid integer overflows in SETRANGE and SORT (CVE-2022-35977)",
      "number": 11720
    },
    "comment": [
      "Authenticated users issuing specially crafted SETRANGE and SORT(_RO) commands can trigger an integer overflow, resulting with Redis attempting to allocate impossible amounts of memory and abort with an OOM panic."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Step-by-Step Explanation:**\n\n1. **Input Analysis:** The commit message references a CVE and mentions integer overflows, indicating a security issue. The vulnerability description confirms this by detailing an OOM panic caused by crafted commands. The code diff shows bounds checks on LIMIT parameters.\n\n2. **Consistency Check:** The code changes align with the commit message, specifically mitigating integer overflow through input bounding.\n\n3. **Purpose Evaluation:** The code modifies core logic to prevent overflow, directly addressing a non-functional bug that impacts security.\n\n4. **Security Assessment:** The patch fixes an integer overflow vulnerability, which is a clear security issue, especially with the CVE reference.\n\n5. **Confidence Scoring:** High confidence as all elements clearly indicate a security fix.\n\n**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}