{
  "cve_id": "CVE-2023-34188",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "cesanta/mongoose",
  "commit_msg": "Added check for negative value for HTTP Content-Length header",
  "commit_hash": "4663090a8fb036146dfe77718cff612b0101cb0f",
  "git_url": "https://github.com/cesanta/mongoose/commit/4663090a8fb036146dfe77718cff612b0101cb0f",
  "file_path": "mongoose.c",
  "func_name": "mg_http_parse",
  "func_before": "int mg_http_parse(const char *s, size_t len, struct mg_http_message *hm) {\n  int is_response, req_len = mg_http_get_request_len((unsigned char *) s, len);\n  const char *end = s == NULL ? NULL : s + req_len, *qs;  // Cannot add to NULL\n  struct mg_str *cl;\n\n  memset(hm, 0, sizeof(*hm));\n  if (req_len <= 0) return req_len;\n\n  hm->message.ptr = hm->head.ptr = s;\n  hm->body.ptr = end;\n  hm->head.len = (size_t) req_len;\n  hm->chunk.ptr = end;\n  hm->message.len = hm->body.len = (size_t) ~0;  // Set body length to infinite\n\n  // Parse request line\n  s = skip(s, end, \" \", &hm->method);\n  s = skip(s, end, \" \", &hm->uri);\n  s = skip(s, end, \"\\r\\n\", &hm->proto);\n\n  // Sanity check. Allow protocol/reason to be empty\n  if (hm->method.len == 0 || hm->uri.len == 0) return -1;\n\n  // If URI contains '?' character, setup query string\n  if ((qs = (const char *) memchr(hm->uri.ptr, '?', hm->uri.len)) != NULL) {\n    hm->query.ptr = qs + 1;\n    hm->query.len = (size_t) (&hm->uri.ptr[hm->uri.len] - (qs + 1));\n    hm->uri.len = (size_t) (qs - hm->uri.ptr);\n  }\n\n  mg_http_parse_headers(s, end, hm->headers,\n                        sizeof(hm->headers) / sizeof(hm->headers[0]));\n  if ((cl = mg_http_get_header(hm, \"Content-Length\")) != NULL) {\n    hm->body.len = (size_t) mg_to64(*cl);\n    hm->message.len = (size_t) req_len + hm->body.len;\n  }\n\n  // mg_http_parse() is used to parse both HTTP requests and HTTP\n  // responses. If HTTP response does not have Content-Length set, then\n  // body is read until socket is closed, i.e. body.len is infinite (~0).\n  //\n  // For HTTP requests though, according to\n  // http://tools.ietf.org/html/rfc7231#section-8.1.3,\n  // only POST and PUT methods have defined body semantics.\n  // Therefore, if Content-Length is not specified and methods are\n  // not one of PUT or POST, set body length to 0.\n  //\n  // So, if it is HTTP request, and Content-Length is not set,\n  // and method is not (PUT or POST) then reset body length to zero.\n  is_response = mg_ncasecmp(hm->method.ptr, \"HTTP/\", 5) == 0;\n  if (hm->body.len == (size_t) ~0 && !is_response &&\n      mg_vcasecmp(&hm->method, \"PUT\") != 0 &&\n      mg_vcasecmp(&hm->method, \"POST\") != 0) {\n    hm->body.len = 0;\n    hm->message.len = (size_t) req_len;\n  }\n\n  // The 204 (No content) responses also have 0 body length\n  if (hm->body.len == (size_t) ~0 && is_response &&\n      mg_vcasecmp(&hm->uri, \"204\") == 0) {\n    hm->body.len = 0;\n    hm->message.len = (size_t) req_len;\n  }\n\n  return req_len;\n}",
  "abstract_func_before": "int mg_http_parse(const char *VAR_0, size_t VAR_1, struct mg_http_message *VAR_2) {\n  int VAR_3, VAR_4 = mg_http_get_request_len((unsigned char *) VAR_0, VAR_1);\n  const char *VAR_5 = VAR_0 == NULL ? NULL : VAR_0 + VAR_4, *VAR_6;  /* COMMENT_0 */\n  struct mg_str *VAR_7;\n\n  memset(VAR_2, 0, sizeof(*VAR_2));\n  if (VAR_4 <= 0) return VAR_4;\n\n  VAR_2->message.ptr = VAR_2->head.ptr = VAR_0;\n  VAR_2->body.ptr = VAR_5;\n  VAR_2->head.len = (size_t) VAR_4;\n  VAR_2->chunk.ptr = VAR_5;\n  VAR_2->message.len = VAR_2->body.len = (size_t) ~0;  /* COMMENT_1 */\n\n  /* COMMENT_2 */\n  VAR_0 = skip(VAR_0, VAR_5, \" \", &VAR_2->method);\n  VAR_0 = skip(VAR_0, VAR_5, \" \", &VAR_2->uri);\n  VAR_0 = skip(VAR_0, VAR_5, \"\\r\\n\", &VAR_2->proto);\n\n  /* COMMENT_3 */\n  if (VAR_2->method.len == 0 || VAR_2->uri.len == 0) return -1;\n\n  /* COMMENT_4 */\n  if ((VAR_6 = (const char *) memchr(VAR_2->uri.ptr, '?', VAR_2->uri.len)) != NULL) {\n    VAR_2->query.ptr = VAR_6 + 1;\n    VAR_2->query.len = (size_t) (&VAR_2->uri.ptr[VAR_2->uri.len] - (VAR_6 + 1));\n    VAR_2->uri.len = (size_t) (VAR_6 - VAR_2->uri.ptr);\n  }\n\n  mg_http_parse_headers(VAR_0, VAR_5, VAR_2->headers,\n                        sizeof(VAR_2->headers) / sizeof(VAR_2->headers[0]));\n  if ((VAR_7 = mg_http_get_header(VAR_2, \"Content-Length\")) != NULL) {\n    VAR_2->body.len = (size_t) mg_to64(*VAR_7);\n    VAR_2->message.len = (size_t) VAR_4 + VAR_2->body.len;\n  }\n\n  /* COMMENT_5 */\n  /* COMMENT_6 */\n  /* COMMENT_7 */\n  /* COMMENT_8 */\n  /* COMMENT_9 */\n  /* COMMENT_10 */\n  /* COMMENT_11 */\n  /* COMMENT_12 */\n  /* COMMENT_13 */\n  /* COMMENT_8 */\n  /* COMMENT_14 */\n  /* COMMENT_15 */\n  VAR_3 = mg_ncasecmp(VAR_2->method.ptr, \"HTTP/\", 5) == 0;\n  if (VAR_2->body.len == (size_t) ~0 && !VAR_3 &&\n      mg_vcasecmp(&VAR_2->method, \"PUT\") != 0 &&\n      mg_vcasecmp(&VAR_2->method, \"POST\") != 0) {\n    VAR_2->body.len = 0;\n    VAR_2->message.len = (size_t) VAR_4;\n  }\n\n  /* COMMENT_16 */\n  if (VAR_2->body.len == (size_t) ~0 && VAR_3 &&\n      mg_vcasecmp(&VAR_2->uri, \"204\") == 0) {\n    VAR_2->body.len = 0;\n    VAR_2->message.len = (size_t) VAR_4;\n  }\n\n  return VAR_4;\n}",
  "func_graph_path_before": "cesanta/mongoose/4663090a8fb036146dfe77718cff612b0101cb0f/mongoose.c/vul/before/0.json",
  "func": "int mg_http_parse(const char *s, size_t len, struct mg_http_message *hm) {\n  int is_response, req_len = mg_http_get_request_len((unsigned char *) s, len);\n  const char *end = s == NULL ? NULL : s + req_len, *qs;  // Cannot add to NULL\n  struct mg_str *cl;\n\n  memset(hm, 0, sizeof(*hm));\n  if (req_len <= 0) return req_len;\n\n  hm->message.ptr = hm->head.ptr = s;\n  hm->body.ptr = end;\n  hm->head.len = (size_t) req_len;\n  hm->chunk.ptr = end;\n  hm->message.len = hm->body.len = (size_t) ~0;  // Set body length to infinite\n\n  // Parse request line\n  s = skip(s, end, \" \", &hm->method);\n  s = skip(s, end, \" \", &hm->uri);\n  s = skip(s, end, \"\\r\\n\", &hm->proto);\n\n  // Sanity check. Allow protocol/reason to be empty\n  if (hm->method.len == 0 || hm->uri.len == 0) return -1;\n\n  // If URI contains '?' character, setup query string\n  if ((qs = (const char *) memchr(hm->uri.ptr, '?', hm->uri.len)) != NULL) {\n    hm->query.ptr = qs + 1;\n    hm->query.len = (size_t) (&hm->uri.ptr[hm->uri.len] - (qs + 1));\n    hm->uri.len = (size_t) (qs - hm->uri.ptr);\n  }\n\n  mg_http_parse_headers(s, end, hm->headers,\n                        sizeof(hm->headers) / sizeof(hm->headers[0]));\n  if ((cl = mg_http_get_header(hm, \"Content-Length\")) != NULL) {\n    int64_t content_len = mg_to64(*cl);\n    if(content_len < 0) return -1;\n    hm->body.len = (size_t) content_len;\n    hm->message.len = (size_t) req_len + hm->body.len;\n  }\n\n  // mg_http_parse() is used to parse both HTTP requests and HTTP\n  // responses. If HTTP response does not have Content-Length set, then\n  // body is read until socket is closed, i.e. body.len is infinite (~0).\n  //\n  // For HTTP requests though, according to\n  // http://tools.ietf.org/html/rfc7231#section-8.1.3,\n  // only POST and PUT methods have defined body semantics.\n  // Therefore, if Content-Length is not specified and methods are\n  // not one of PUT or POST, set body length to 0.\n  //\n  // So, if it is HTTP request, and Content-Length is not set,\n  // and method is not (PUT or POST) then reset body length to zero.\n  is_response = mg_ncasecmp(hm->method.ptr, \"HTTP/\", 5) == 0;\n  if (hm->body.len == (size_t) ~0 && !is_response &&\n      mg_vcasecmp(&hm->method, \"PUT\") != 0 &&\n      mg_vcasecmp(&hm->method, \"POST\") != 0) {\n    hm->body.len = 0;\n    hm->message.len = (size_t) req_len;\n  }\n\n  // The 204 (No content) responses also have 0 body length\n  if (hm->body.len == (size_t) ~0 && is_response &&\n      mg_vcasecmp(&hm->uri, \"204\") == 0) {\n    hm->body.len = 0;\n    hm->message.len = (size_t) req_len;\n  }\n\n  return req_len;\n}",
  "abstract_func": "int mg_http_parse(const char *VAR_0, size_t VAR_1, struct mg_http_message *VAR_2) {\n  int VAR_3, VAR_4 = mg_http_get_request_len((unsigned char *) VAR_0, VAR_1);\n  const char *VAR_5 = VAR_0 == NULL ? NULL : VAR_0 + VAR_4, *VAR_6;  /* COMMENT_0 */\n  struct mg_str *VAR_7;\n\n  memset(VAR_2, 0, sizeof(*VAR_2));\n  if (VAR_4 <= 0) return VAR_4;\n\n  VAR_2->message.ptr = VAR_2->head.ptr = VAR_0;\n  VAR_2->body.ptr = VAR_5;\n  VAR_2->head.len = (size_t) VAR_4;\n  VAR_2->chunk.ptr = VAR_5;\n  VAR_2->message.len = VAR_2->body.len = (size_t) ~0;  /* COMMENT_1 */\n\n  /* COMMENT_2 */\n  VAR_0 = skip(VAR_0, VAR_5, \" \", &VAR_2->method);\n  VAR_0 = skip(VAR_0, VAR_5, \" \", &VAR_2->uri);\n  VAR_0 = skip(VAR_0, VAR_5, \"\\r\\n\", &VAR_2->proto);\n\n  /* COMMENT_3 */\n  if (VAR_2->method.len == 0 || VAR_2->uri.len == 0) return -1;\n\n  /* COMMENT_4 */\n  if ((VAR_6 = (const char *) memchr(VAR_2->uri.ptr, '?', VAR_2->uri.len)) != NULL) {\n    VAR_2->query.ptr = VAR_6 + 1;\n    VAR_2->query.len = (size_t) (&VAR_2->uri.ptr[VAR_2->uri.len] - (VAR_6 + 1));\n    VAR_2->uri.len = (size_t) (VAR_6 - VAR_2->uri.ptr);\n  }\n\n  mg_http_parse_headers(VAR_0, VAR_5, VAR_2->headers,\n                        sizeof(VAR_2->headers) / sizeof(VAR_2->headers[0]));\n  if ((VAR_7 = mg_http_get_header(VAR_2, \"Content-Length\")) != NULL) {\n    int64_t VAR_8 = mg_to64(*VAR_7);\n    if(VAR_8 < 0) return -1;\n    VAR_2->body.len = (size_t) VAR_8;\n    VAR_2->message.len = (size_t) VAR_4 + VAR_2->body.len;\n  }\n\n  /* COMMENT_5 */\n  /* COMMENT_6 */\n  /* COMMENT_7 */\n  /* COMMENT_8 */\n  /* COMMENT_9 */\n  /* COMMENT_10 */\n  /* COMMENT_11 */\n  /* COMMENT_12 */\n  /* COMMENT_13 */\n  /* COMMENT_8 */\n  /* COMMENT_14 */\n  /* COMMENT_15 */\n  VAR_3 = mg_ncasecmp(VAR_2->method.ptr, \"HTTP/\", 5) == 0;\n  if (VAR_2->body.len == (size_t) ~0 && !VAR_3 &&\n      mg_vcasecmp(&VAR_2->method, \"PUT\") != 0 &&\n      mg_vcasecmp(&VAR_2->method, \"POST\") != 0) {\n    VAR_2->body.len = 0;\n    VAR_2->message.len = (size_t) VAR_4;\n  }\n\n  /* COMMENT_16 */\n  if (VAR_2->body.len == (size_t) ~0 && VAR_3 &&\n      mg_vcasecmp(&VAR_2->uri, \"204\") == 0) {\n    VAR_2->body.len = 0;\n    VAR_2->message.len = (size_t) VAR_4;\n  }\n\n  return VAR_4;\n}",
  "func_graph_path": "cesanta/mongoose/4663090a8fb036146dfe77718cff612b0101cb0f/mongoose.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -30,7 +30,9 @@\n   mg_http_parse_headers(s, end, hm->headers,\n                         sizeof(hm->headers) / sizeof(hm->headers[0]));\n   if ((cl = mg_http_get_header(hm, \"Content-Length\")) != NULL) {\n-    hm->body.len = (size_t) mg_to64(*cl);\n+    int64_t content_len = mg_to64(*cl);\n+    if(content_len < 0) return -1;\n+    hm->body.len = (size_t) content_len;\n     hm->message.len = (size_t) req_len + hm->body.len;\n   }\n ",
  "diff_line_info": {
    "deleted_lines": [
      "    hm->body.len = (size_t) mg_to64(*cl);"
    ],
    "added_lines": [
      "    int64_t content_len = mg_to64(*cl);",
      "    if(content_len < 0) return -1;",
      "    hm->body.len = (size_t) content_len;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/cesanta/mongoose/pull/2197",
  "description": {
    "pr_info": {
      "title": "Added check for negative value for HTTP Content-Length header",
      "number": 2197
    },
    "comment": [
      "Added check for negative value for HTTP Content-Length. HTTP \"Bad request\"(400) will be sent as responce."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}