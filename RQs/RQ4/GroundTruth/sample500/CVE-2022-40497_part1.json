{
  "cve_id": "CVE-2022-40497",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "wazuh",
  "commit_msg": "Fix typo in the AR directory traversal error",
  "commit_hash": "065b175952c344d00a4af9cc9f5d28e964ce33fd",
  "git_url": "https://github.com/wazuh/wazuh/commit/065b175952c344d00a4af9cc9f5d28e964ce33fd",
  "file_path": "src/os_execd/exec.c",
  "func_name": "ReadExecConfig",
  "func_before": "int ReadExecConfig()\n{\n    int i = 0, j = 0, dup_entry = 0;\n    FILE *fp;\n    FILE *process_file;\n    char buffer[OS_MAXSTR + 1];\n\n    /* Clean up */\n    for (i = 0; i <= exec_size + 1; i++) {\n        memset(exec_names[i], '\\0', OS_FLSIZE + 1);\n        memset(exec_cmd[i], '\\0', OS_FLSIZE + 1);\n        exec_timeout[i] = 0;\n    }\n    exec_size = 0;\n\n    /* Open file */\n    fp = fopen(DEFAULTAR, \"r\");\n    if (!fp) {\n        merror(FOPEN_ERROR, DEFAULTAR, errno, strerror(errno));\n        return (0);\n    }\n\n    /* Read config */\n    while (fgets(buffer, OS_MAXSTR, fp) != NULL) {\n        char *str_pt;\n        char *tmp_str;\n\n        str_pt = buffer;\n\n        // The command name must not start with '!'\n\n        if (buffer[0] == '!') {\n            merror(EXEC_INV_CONF, DEFAULTAR);\n            continue;\n        }\n\n        /* Clean up the buffer */\n        tmp_str = strstr(buffer, \" - \");\n        if (!tmp_str) {\n            merror(EXEC_INV_CONF, DEFAULTAR);\n            continue;\n        }\n        *tmp_str = '\\0';\n        tmp_str += 3;\n\n        /* Set the name */\n        strncpy(exec_names[exec_size], str_pt, OS_FLSIZE);\n        exec_names[exec_size][OS_FLSIZE] = '\\0';\n\n        str_pt = tmp_str;\n\n        /* Search for ' ' and - */\n        tmp_str = strstr(tmp_str, \" - \");\n        if (!tmp_str) {\n            merror(EXEC_INV_CONF, DEFAULTAR);\n            continue;\n        }\n        *tmp_str = '\\0';\n        tmp_str += 3;\n\n        // Directory transversal test\n\n        if (w_ref_parent_folder(str_pt)) {\n            merror(\"Active response command '%s' vulnerable to directory transversal attack. Ignoring.\", str_pt);\n            exec_cmd[exec_size][0] = '\\0';\n        } else {\n            /* Write the full command path */\n            snprintf(exec_cmd[exec_size], OS_FLSIZE,\n                     \"%s/%s\",\n                     AR_BINDIR,\n                     str_pt);\n            process_file = fopen(exec_cmd[exec_size], \"r\");\n            if (!process_file) {\n                if (f_time_reading) {\n                    minfo(\"Active response command not present: '%s'. \"\n                            \"Not using it on this system.\",\n                            exec_cmd[exec_size]);\n                }\n\n                exec_cmd[exec_size][0] = '\\0';\n            } else {\n                fclose(process_file);\n            }\n        }\n\n        str_pt = tmp_str;\n        tmp_str = strchr(tmp_str, '\\n');\n        if (tmp_str) {\n            *tmp_str = '\\0';\n        }\n\n        /* Get the exec timeout */\n        exec_timeout[exec_size] = atoi(str_pt);\n\n        /* Check if name is duplicated */\n        dup_entry = 0;\n        for (j = 0; j < exec_size; j++) {\n            if (strcmp(exec_names[j], exec_names[exec_size]) == 0) {\n                if (exec_cmd[j][0] == '\\0') {\n                    strncpy(exec_cmd[j], exec_cmd[exec_size], OS_FLSIZE);\n                    exec_cmd[j][OS_FLSIZE] = '\\0';\n                    dup_entry = 1;\n                    break;\n                } else if (exec_cmd[exec_size][0] == '\\0') {\n                    dup_entry = 1;\n                }\n            }\n        }\n\n        if (dup_entry) {\n            exec_cmd[exec_size][0] = '\\0';\n            exec_names[exec_size][0] = '\\0';\n            exec_timeout[exec_size] = 0;\n        } else {\n            exec_size++;\n        }\n    }\n\n    fclose(fp);\n    f_time_reading = 0;\n\n    return (1);\n}",
  "abstract_func_before": "int ReadExecConfig()\n{\n    int VAR_0 = 0, VAR_1 = 0, VAR_2 = 0;\n    FILE *VAR_3;\n    FILE *VAR_4;\n    char VAR_5[VAR_6 + 1];\n\n    /* COMMENT_0 */\n    for (VAR_0 = 0; VAR_0 <= VAR_7 + 1; VAR_0++) {\n        memset(VAR_8[VAR_0], '\\0', VAR_9 + 1);\n        memset(VAR_10[VAR_0], '\\0', VAR_9 + 1);\n        VAR_11[VAR_0] = 0;\n    }\n    VAR_7 = 0;\n\n    /* COMMENT_1 */\n    VAR_3 = fopen(VAR_12, \"r\");\n    if (!VAR_3) {\n        merror(VAR_13, VAR_12, VAR_14, strerror(VAR_14));\n        return (0);\n    }\n\n    /* COMMENT_2 */\n    while (fgets(VAR_5, VAR_6, VAR_3) != NULL) {\n        char *VAR_15;\n        char *VAR_16;\n\n        VAR_15 = VAR_5;\n\n        /* COMMENT_3 */\n\n        if (VAR_5[0] == '!') {\n            merror(VAR_17, VAR_12);\n            continue;\n        }\n\n        /* COMMENT_4 */\n        VAR_16 = strstr(VAR_5, \" - \");\n        if (!VAR_16) {\n            merror(VAR_17, VAR_12);\n            continue;\n        }\n        *VAR_16 = '\\0';\n        VAR_16 += 3;\n\n        /* COMMENT_5 */\n        strncpy(VAR_8[VAR_7], VAR_15, VAR_9);\n        VAR_8[VAR_7][VAR_9] = '\\0';\n\n        VAR_15 = VAR_16;\n\n        /* COMMENT_6 */\n        VAR_16 = strstr(VAR_16, \" - \");\n        if (!VAR_16) {\n            merror(VAR_17, VAR_12);\n            continue;\n        }\n        *VAR_16 = '\\0';\n        VAR_16 += 3;\n\n        /* COMMENT_7 */\n\n        if (w_ref_parent_folder(VAR_15)) {\n            merror(\"Active response command '%s' vulnerable to directory transversal attack. Ignoring.\", VAR_15);\n            VAR_10[VAR_7][0] = '\\0';\n        } else {\n            /* COMMENT_8 */\n            snprintf(VAR_10[VAR_7], VAR_9,\n                     \"%s/%s\",\n                     VAR_18,\n                     VAR_15);\n            VAR_4 = fopen(VAR_10[VAR_7], \"r\");\n            if (!VAR_4) {\n                if (VAR_19) {\n                    minfo(\"Active response command not present: '%s'. \"\n                            \"Not using it on this system.\",\n                            VAR_10[VAR_7]);\n                }\n\n                VAR_10[VAR_7][0] = '\\0';\n            } else {\n                fclose(VAR_4);\n            }\n        }\n\n        VAR_15 = VAR_16;\n        VAR_16 = strchr(VAR_16, '\\n');\n        if (VAR_16) {\n            *VAR_16 = '\\0';\n        }\n\n        /* COMMENT_9 */\n        VAR_11[VAR_7] = atoi(VAR_15);\n\n        /* COMMENT_10 */\n        VAR_2 = 0;\n        for (VAR_1 = 0; VAR_1 < VAR_7; VAR_1++) {\n            if (strcmp(VAR_8[VAR_1], VAR_8[VAR_7]) == 0) {\n                if (VAR_10[VAR_1][0] == '\\0') {\n                    strncpy(VAR_10[VAR_1], VAR_10[VAR_7], VAR_9);\n                    VAR_10[VAR_1][VAR_9] = '\\0';\n                    VAR_2 = 1;\n                    break;\n                } else if (VAR_10[VAR_7][0] == '\\0') {\n                    VAR_2 = 1;\n                }\n            }\n        }\n\n        if (VAR_2) {\n            VAR_10[VAR_7][0] = '\\0';\n            VAR_8[VAR_7][0] = '\\0';\n            VAR_11[VAR_7] = 0;\n        } else {\n            VAR_7++;\n        }\n    }\n\n    fclose(VAR_3);\n    VAR_19 = 0;\n\n    return (1);\n}",
  "func_graph_path_before": "wazuh/065b175952c344d00a4af9cc9f5d28e964ce33fd/exec.c/vul/before/0.json",
  "func": "int ReadExecConfig()\n{\n    int i = 0, j = 0, dup_entry = 0;\n    FILE *fp;\n    FILE *process_file;\n    char buffer[OS_MAXSTR + 1];\n\n    /* Clean up */\n    for (i = 0; i <= exec_size + 1; i++) {\n        memset(exec_names[i], '\\0', OS_FLSIZE + 1);\n        memset(exec_cmd[i], '\\0', OS_FLSIZE + 1);\n        exec_timeout[i] = 0;\n    }\n    exec_size = 0;\n\n    /* Open file */\n    fp = fopen(DEFAULTAR, \"r\");\n    if (!fp) {\n        merror(FOPEN_ERROR, DEFAULTAR, errno, strerror(errno));\n        return (0);\n    }\n\n    /* Read config */\n    while (fgets(buffer, OS_MAXSTR, fp) != NULL) {\n        char *str_pt;\n        char *tmp_str;\n\n        str_pt = buffer;\n\n        // The command name must not start with '!'\n\n        if (buffer[0] == '!') {\n            merror(EXEC_INV_CONF, DEFAULTAR);\n            continue;\n        }\n\n        /* Clean up the buffer */\n        tmp_str = strstr(buffer, \" - \");\n        if (!tmp_str) {\n            merror(EXEC_INV_CONF, DEFAULTAR);\n            continue;\n        }\n        *tmp_str = '\\0';\n        tmp_str += 3;\n\n        /* Set the name */\n        strncpy(exec_names[exec_size], str_pt, OS_FLSIZE);\n        exec_names[exec_size][OS_FLSIZE] = '\\0';\n\n        str_pt = tmp_str;\n\n        /* Search for ' ' and - */\n        tmp_str = strstr(tmp_str, \" - \");\n        if (!tmp_str) {\n            merror(EXEC_INV_CONF, DEFAULTAR);\n            continue;\n        }\n        *tmp_str = '\\0';\n        tmp_str += 3;\n\n        // Directory traversal test\n\n        if (w_ref_parent_folder(str_pt)) {\n            merror(\"Active response command '%s' vulnerable to directory traversal attack. Ignoring.\", str_pt);\n            exec_cmd[exec_size][0] = '\\0';\n        } else {\n            /* Write the full command path */\n            snprintf(exec_cmd[exec_size], OS_FLSIZE,\n                     \"%s/%s\",\n                     AR_BINDIR,\n                     str_pt);\n            process_file = fopen(exec_cmd[exec_size], \"r\");\n            if (!process_file) {\n                if (f_time_reading) {\n                    minfo(\"Active response command not present: '%s'. \"\n                            \"Not using it on this system.\",\n                            exec_cmd[exec_size]);\n                }\n\n                exec_cmd[exec_size][0] = '\\0';\n            } else {\n                fclose(process_file);\n            }\n        }\n\n        str_pt = tmp_str;\n        tmp_str = strchr(tmp_str, '\\n');\n        if (tmp_str) {\n            *tmp_str = '\\0';\n        }\n\n        /* Get the exec timeout */\n        exec_timeout[exec_size] = atoi(str_pt);\n\n        /* Check if name is duplicated */\n        dup_entry = 0;\n        for (j = 0; j < exec_size; j++) {\n            if (strcmp(exec_names[j], exec_names[exec_size]) == 0) {\n                if (exec_cmd[j][0] == '\\0') {\n                    strncpy(exec_cmd[j], exec_cmd[exec_size], OS_FLSIZE);\n                    exec_cmd[j][OS_FLSIZE] = '\\0';\n                    dup_entry = 1;\n                    break;\n                } else if (exec_cmd[exec_size][0] == '\\0') {\n                    dup_entry = 1;\n                }\n            }\n        }\n\n        if (dup_entry) {\n            exec_cmd[exec_size][0] = '\\0';\n            exec_names[exec_size][0] = '\\0';\n            exec_timeout[exec_size] = 0;\n        } else {\n            exec_size++;\n        }\n    }\n\n    fclose(fp);\n    f_time_reading = 0;\n\n    return (1);\n}",
  "abstract_func": "int ReadExecConfig()\n{\n    int VAR_0 = 0, VAR_1 = 0, VAR_2 = 0;\n    FILE *VAR_3;\n    FILE *VAR_4;\n    char VAR_5[VAR_6 + 1];\n\n    /* COMMENT_0 */\n    for (VAR_0 = 0; VAR_0 <= VAR_7 + 1; VAR_0++) {\n        memset(VAR_8[VAR_0], '\\0', VAR_9 + 1);\n        memset(VAR_10[VAR_0], '\\0', VAR_9 + 1);\n        VAR_11[VAR_0] = 0;\n    }\n    VAR_7 = 0;\n\n    /* COMMENT_1 */\n    VAR_3 = fopen(VAR_12, \"r\");\n    if (!VAR_3) {\n        merror(VAR_13, VAR_12, VAR_14, strerror(VAR_14));\n        return (0);\n    }\n\n    /* COMMENT_2 */\n    while (fgets(VAR_5, VAR_6, VAR_3) != NULL) {\n        char *VAR_15;\n        char *VAR_16;\n\n        VAR_15 = VAR_5;\n\n        /* COMMENT_3 */\n\n        if (VAR_5[0] == '!') {\n            merror(VAR_17, VAR_12);\n            continue;\n        }\n\n        /* COMMENT_4 */\n        VAR_16 = strstr(VAR_5, \" - \");\n        if (!VAR_16) {\n            merror(VAR_17, VAR_12);\n            continue;\n        }\n        *VAR_16 = '\\0';\n        VAR_16 += 3;\n\n        /* COMMENT_5 */\n        strncpy(VAR_8[VAR_7], VAR_15, VAR_9);\n        VAR_8[VAR_7][VAR_9] = '\\0';\n\n        VAR_15 = VAR_16;\n\n        /* COMMENT_6 */\n        VAR_16 = strstr(VAR_16, \" - \");\n        if (!VAR_16) {\n            merror(VAR_17, VAR_12);\n            continue;\n        }\n        *VAR_16 = '\\0';\n        VAR_16 += 3;\n\n        /* COMMENT_7 */\n\n        if (w_ref_parent_folder(VAR_15)) {\n            merror(\"Active response command '%s' vulnerable to directory traversal attack. Ignoring.\", VAR_15);\n            VAR_10[VAR_7][0] = '\\0';\n        } else {\n            /* COMMENT_8 */\n            snprintf(VAR_10[VAR_7], VAR_9,\n                     \"%s/%s\",\n                     VAR_18,\n                     VAR_15);\n            VAR_4 = fopen(VAR_10[VAR_7], \"r\");\n            if (!VAR_4) {\n                if (VAR_19) {\n                    minfo(\"Active response command not present: '%s'. \"\n                            \"Not using it on this system.\",\n                            VAR_10[VAR_7]);\n                }\n\n                VAR_10[VAR_7][0] = '\\0';\n            } else {\n                fclose(VAR_4);\n            }\n        }\n\n        VAR_15 = VAR_16;\n        VAR_16 = strchr(VAR_16, '\\n');\n        if (VAR_16) {\n            *VAR_16 = '\\0';\n        }\n\n        /* COMMENT_9 */\n        VAR_11[VAR_7] = atoi(VAR_15);\n\n        /* COMMENT_10 */\n        VAR_2 = 0;\n        for (VAR_1 = 0; VAR_1 < VAR_7; VAR_1++) {\n            if (strcmp(VAR_8[VAR_1], VAR_8[VAR_7]) == 0) {\n                if (VAR_10[VAR_1][0] == '\\0') {\n                    strncpy(VAR_10[VAR_1], VAR_10[VAR_7], VAR_9);\n                    VAR_10[VAR_1][VAR_9] = '\\0';\n                    VAR_2 = 1;\n                    break;\n                } else if (VAR_10[VAR_7][0] == '\\0') {\n                    VAR_2 = 1;\n                }\n            }\n        }\n\n        if (VAR_2) {\n            VAR_10[VAR_7][0] = '\\0';\n            VAR_8[VAR_7][0] = '\\0';\n            VAR_11[VAR_7] = 0;\n        } else {\n            VAR_7++;\n        }\n    }\n\n    fclose(VAR_3);\n    VAR_19 = 0;\n\n    return (1);\n}",
  "func_graph_path": "wazuh/065b175952c344d00a4af9cc9f5d28e964ce33fd/exec.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -58,10 +58,10 @@\n         *tmp_str = '\\0';\n         tmp_str += 3;\n \n-        // Directory transversal test\n+        // Directory traversal test\n \n         if (w_ref_parent_folder(str_pt)) {\n-            merror(\"Active response command '%s' vulnerable to directory transversal attack. Ignoring.\", str_pt);\n+            merror(\"Active response command '%s' vulnerable to directory traversal attack. Ignoring.\", str_pt);\n             exec_cmd[exec_size][0] = '\\0';\n         } else {\n             /* Write the full command path */",
  "diff_line_info": {
    "deleted_lines": [
      "        // Directory transversal test",
      "            merror(\"Active response command '%s' vulnerable to directory transversal attack. Ignoring.\", str_pt);"
    ],
    "added_lines": [
      "        // Directory traversal test",
      "            merror(\"Active response command '%s' vulnerable to directory traversal attack. Ignoring.\", str_pt);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/wazuh/wazuh/pull/14801",
  "description": {
    "pr_info": {
      "title": "Fix arbitrary code execution flaw in Active Response",
      "number": 14801
    },
    "comment": [
      "|Affected versions|Module|Component|Cause|Credits|\r\n|---|---|---|---|---|\r\n|3.6.1 - 3.13.5, 4.0.0 - 4.2.7, 4.3.0 - 4.3.7|Active Response|Agent & manager|#1217| All credits to Roshan Guragain|\r\n\r\n\r\nThanks to **Roshan Guragain** for reporting the flaw and helping us improve the product!\r\n\r\n## Flaw\r\n\r\nReferences to a parent folder are possible in a custom AR API request:\r\n|Method|Endpoint|Data|\r\n|---|---|---|\r\n|PUT|/active-response|`{\"command\":\"!../../../../../../bin/ls\"}`|\r\n\r\n## Impact\r\n\r\nA manager administrator with RBAC permissions `active-response:command` might execute a program outside the Active Response binary folder (_/var/ossec/active-response/bin_).\r\n\r\n- In versions below 4.2.0, the target command would receive the extra arguments (`extra_args`) as a command-line parameter list.\r\n- In 4.2.0 and higher, the target command receives all data (including the extra arguments) in a JSON string via standard input.\r\n\r\n### Agents from 3.6.1 to 4.1.5\r\n\r\nRunning a custom Active Response with these parameters:\r\n\r\n|Command|Custom|Arguments|\r\n|---|---|---|\r\n|`../../../../root/test.sh`|`true`|`[arg1, arg2, arg3]`|\r\n\r\nThis will cause the agent to run `/root/test.sh` with the following arguments:\r\n```shell\r\n/var/ossec/active-response/bin/../../../../root/test.sh add arg1 arg2 arg3\r\n```\r\n\r\n### Agents from 4.2.0 to 4.3.7\r\n\r\nRunning a custom Active Response with these parameters:\r\n\r\n|Command|Arguments|\r\n|---|---|\r\n|`!../../../../root/test.sh`|`[arg1, arg2, arg3]`|\r\n\r\nThis will cause the agent to run `/root/test.sh` with no extra arguments, but the agent will send the following string via _stdin_:\r\n```shell\r\n{\"version\":1,\"origin\":{\"name\":null,\"module\":\"wazuh-execd\"},\"command\":\"add\",\"parameters\":{\"extra_args\":[\"arg1\",\"arg2\",\"arg3\"],\"alert\":{},\"program\":\"active-response/bin/../../../../root/test.sh\"}}\r\n```\r\n\r\n## Proposed fix\r\n\r\nWe're implementing protection at two levels:\r\n\r\n1. Prevent the agent (wazuh-execd) from running a custom AR outside _active-response/bin_.\r\n2. Filter custom Active Response commands by the API and reject those whose member `command` contains any reference to a parent folder (`../`).\r\n\r\n## Tests\r\n\r\n- [x] Send a custom AR command to Execd containing a reference to the parent folder:\r\n```sh\r\necho -n '{\"version\": 1, \"origin\": {\"name\": null, \"module\": \"framework\"}, \"command\": \"!../../../../../../bin/ls\", \"parameters\": {\"extra_args\": [], \"alert\": {}}}' | nc -w0 -Uu /var/ossec/queue/alerts/execq\r\n```\r\n```\r\n2022/09/05 14:48:51 wazuh-execd[6848] exec.c:163 at GetCommandbyName(): WARNING: Active response command '../../../../../../bin/ls' vulnerable to directory traversal attack. Ignoring.\r\n2022/09/05 14:48:51 wazuh-execd[6848] execd.c:465 at ExecdStart(): ERROR: (1311): Invalid command name '!../../../../../../bin/ls' provided.\r\n```\r\n- [x] Unit tests to check that `GetCommandbyName` rejects custom commands with path traversal.\r\n- [x] The API rejects custom ARs with commands referring to the parent folder:\r\n```sh\r\ncurl -H \"Content-Type: application/json\" -X PUT https://localhost:55000/active-response?agents_list=001 --data '{\"command\":\"!../../../../../../bin/ls\"}'\r\n```\r\n```\r\n{\"title\": \"Bad Request\", \"detail\": \"'!../../../../../../bin/l' is not a 'active_response_command' - 'command'\"}\r\n```",
      "## QA review\r\n\r\n- **Type**: Manual testing.\r\n- **Status**: Approved but proposed improvements  ðŸŸ¡ \r\n- **Testing issue**: https://github.com/wazuh/wazuh-qa/issues/3257\r\n- **Comments**: Everything seems to be working properly. The following issue https://github.com/wazuh/wazuh/issues/14831 has been opened for:\r\n  - Improve consistency between AR socket response and API when entering a custom command. Some commands are accepted in the socket but not through the API.\r\n  - Delete duplicate WARNING message.\r\n\r\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9"
}