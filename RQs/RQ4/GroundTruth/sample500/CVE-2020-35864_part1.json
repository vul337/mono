{
  "cve_id": "CVE-2020-35864",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "google/flatbuffers",
  "commit_msg": "Assertions and read_scalar made unsafe",
  "commit_hash": "77991e92337bb7474c439e1f579648e4e42cb595",
  "git_url": "https://github.com/google/flatbuffers/commit/77991e92337bb7474c439e1f579648e4e42cb595",
  "file_path": "src/idl_gen_rust.cpp",
  "func_name": "GenEnum",
  "func_before": "void GenEnum(const EnumDef &enum_def) {\n    code_.SetValue(\"ENUM_NAME\", Name(enum_def));\n    code_.SetValue(\"BASE_TYPE\", GetEnumTypeForDecl(enum_def.underlying_type));\n    code_.SetValue(\"ENUM_NAME_SNAKE\", MakeSnakeCase(Name(enum_def)));\n    code_.SetValue(\"ENUM_NAME_CAPS\", MakeUpper(MakeSnakeCase(Name(enum_def))));\n    const EnumVal *minv = enum_def.MinValue();\n    const EnumVal *maxv = enum_def.MaxValue();\n    FLATBUFFERS_ASSERT(minv && maxv);\n    code_.SetValue(\"ENUM_MIN_BASE_VALUE\", enum_def.ToString(*minv));\n    code_.SetValue(\"ENUM_MAX_BASE_VALUE\", enum_def.ToString(*maxv));\n\n    if (IsBitFlagsEnum(enum_def)) {\n      // Defer to the convenient and canonical bitflags crate. We declare it in\n      // a module to #allow camel case constants in a smaller scope. This\n      // matches Flatbuffers c-modeled enums where variants are associated\n      // constants but in camel case.\n      code_ += \"#[allow(non_upper_case_globals)]\";\n      code_ += \"mod bitflags_{{ENUM_NAME_SNAKE}} {\";\n      code_ += \"  flatbuffers::bitflags::bitflags! {\";\n      GenComment(enum_def.doc_comment, \"    \");\n      code_ += \"    #[derive(Default)]\";\n      code_ += \"    pub struct {{ENUM_NAME}}: {{BASE_TYPE}} {\";\n      ForAllEnumValues1(enum_def, [&](const EnumVal &ev) {\n        this->GenComment(ev.doc_comment, \"      \");\n        code_ += \"      const {{VARIANT}} = {{VALUE}};\";\n      });\n      code_ += \"    }\";\n      code_ += \"  }\";\n      code_ += \"}\";\n      code_ += \"pub use self::bitflags_{{ENUM_NAME_SNAKE}}::{{ENUM_NAME}};\";\n      code_ += \"\";\n\n      code_.SetValue(\"FROM_BASE\", \"unsafe { Self::from_bits_unchecked(b) }\");\n      code_.SetValue(\"INTO_BASE\", \"self.bits()\");\n    } else {\n      // Normal, c-modelled enums.\n      // Deprecated associated constants;\n      const std::string deprecation_warning =\n          \"#[deprecated(since = \\\"2.0.0\\\", note = \\\"Use associated constants\"\n          \" instead. This will no longer be generated in 2021.\\\")]\";\n      code_ += deprecation_warning;\n      code_ +=\n          \"pub const ENUM_MIN_{{ENUM_NAME_CAPS}}: {{BASE_TYPE}}\"\n          \" = {{ENUM_MIN_BASE_VALUE}};\";\n      code_ += deprecation_warning;\n      code_ +=\n          \"pub const ENUM_MAX_{{ENUM_NAME_CAPS}}: {{BASE_TYPE}}\"\n          \" = {{ENUM_MAX_BASE_VALUE}};\";\n      auto num_fields = NumToString(enum_def.size());\n      code_ += deprecation_warning;\n      code_ += \"#[allow(non_camel_case_types)]\";\n      code_ += \"pub const ENUM_VALUES_{{ENUM_NAME_CAPS}}: [{{ENUM_NAME}}; \" +\n               num_fields + \"] = [\";\n      ForAllEnumValues1(enum_def, [&](const EnumVal &ev) {\n        code_ += \"  \" + GetEnumValue(enum_def, ev) + \",\";\n      });\n      code_ += \"];\";\n      code_ += \"\";\n\n      GenComment(enum_def.doc_comment);\n      // Derive Default to be 0. flatc enforces this when the enum\n      // is put into a struct, though this isn't documented behavior, it is\n      // needed to derive defaults in struct objects.\n      code_ +=\n          \"#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, \"\n          \"Default)]\";\n      code_ += \"#[repr(transparent)]\";\n      code_ += \"pub struct {{ENUM_NAME}}(pub {{BASE_TYPE}});\";\n      code_ += \"#[allow(non_upper_case_globals)]\";\n      code_ += \"impl {{ENUM_NAME}} {\";\n      ForAllEnumValues1(enum_def, [&](const EnumVal &ev) {\n        this->GenComment(ev.doc_comment, \"  \");\n        code_ += \"  pub const {{VARIANT}}: Self = Self({{VALUE}});\";\n      });\n      code_ += \"\";\n      // Generate Associated constants\n      code_ += \"  pub const ENUM_MIN: {{BASE_TYPE}} = {{ENUM_MIN_BASE_VALUE}};\";\n      code_ += \"  pub const ENUM_MAX: {{BASE_TYPE}} = {{ENUM_MAX_BASE_VALUE}};\";\n      code_ += \"  pub const ENUM_VALUES: &'static [Self] = &[\";\n      ForAllEnumValues(enum_def, [&]() { code_ += \"    Self::{{VARIANT}},\"; });\n      code_ += \"  ];\";\n      code_ += \"  /// Returns the variant's name or \\\"\\\" if unknown.\";\n      code_ += \"  pub fn variant_name(self) -> Option<&'static str> {\";\n      code_ += \"    match self {\";\n      ForAllEnumValues(enum_def, [&]() {\n        code_ += \"      Self::{{VARIANT}} => Some(\\\"{{VARIANT}}\\\"),\";\n      });\n      code_ += \"      _ => None,\";\n      code_ += \"    }\";\n      code_ += \"  }\";\n      code_ += \"}\";\n\n      // Generate Debug. Unknown variants are printed like \"<UNKNOWN 42>\".\n      code_ += \"impl std::fmt::Debug for {{ENUM_NAME}} {\";\n      code_ +=\n          \"  fn fmt(&self, f: &mut std::fmt::Formatter) ->\"\n          \" std::fmt::Result {\";\n      code_ += \"    if let Some(name) = self.variant_name() {\";\n      code_ += \"      f.write_str(name)\";\n      code_ += \"    } else {\";\n      code_ += \"      f.write_fmt(format_args!(\\\"<UNKNOWN {:?}>\\\", self.0))\";\n      code_ += \"    }\";\n      code_ += \"  }\";\n      code_ += \"}\";\n\n      code_.SetValue(\"FROM_BASE\", \"Self(b)\");\n      code_.SetValue(\"INTO_BASE\", \"self.0\");\n    }\n\n    // Generate Follow and Push so we can serialize and stuff.\n    code_ += \"impl<'a> flatbuffers::Follow<'a> for {{ENUM_NAME}} {\";\n    code_ += \"  type Inner = Self;\";\n    code_ += \"  #[inline]\";\n    code_ += \"  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {\";\n    code_ +=\n        \"    let b = flatbuffers::read_scalar_at::<{{BASE_TYPE}}>(buf,\"\n        \" loc);\";\n    code_ += \"    {{FROM_BASE}}\";\n    code_ += \"  }\";\n    code_ += \"}\";\n    code_ += \"\";\n    code_ += \"impl flatbuffers::Push for {{ENUM_NAME}} {\";\n    code_ += \"    type Output = {{ENUM_NAME}};\";\n    code_ += \"    #[inline]\";\n    code_ += \"    fn push(&self, dst: &mut [u8], _rest: &[u8]) {\";\n    code_ +=\n        \"        unsafe { flatbuffers::emplace_scalar::<{{BASE_TYPE}}>\"\n        \"(dst, {{INTO_BASE}}); }\";\n    code_ += \"    }\";\n    code_ += \"}\";\n    code_ += \"\";\n    code_ += \"impl flatbuffers::EndianScalar for {{ENUM_NAME}} {\";\n    code_ += \"  #[inline]\";\n    code_ += \"  fn to_little_endian(self) -> Self {\";\n    code_ += \"    let b = {{BASE_TYPE}}::to_le({{INTO_BASE}});\";\n    code_ += \"    {{FROM_BASE}}\";\n    code_ += \"  }\";\n    code_ += \"  #[inline]\";\n    code_ += \"  #[allow(clippy::wrong_self_convention)]\";\n    code_ += \"  fn from_little_endian(self) -> Self {\";\n    code_ += \"    let b = {{BASE_TYPE}}::from_le({{INTO_BASE}});\";\n    code_ += \"    {{FROM_BASE}}\";\n    code_ += \"  }\";\n    code_ += \"}\";\n    code_ += \"\";\n\n    // Generate verifier - deferring to the base type.\n    code_ += \"impl<'a> flatbuffers::Verifiable for {{ENUM_NAME}} {\";\n    code_ += \"  #[inline]\";\n    code_ += \"  fn run_verifier(\";\n    code_ += \"    v: &mut flatbuffers::Verifier, pos: usize\";\n    code_ += \"  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {\";\n    code_ += \"    use self::flatbuffers::Verifiable;\";\n    code_ += \"    {{BASE_TYPE}}::run_verifier(v, pos)\";\n    code_ += \"  }\";\n    code_ += \"}\";\n    code_ += \"\";\n    // Enums are basically integers.\n    code_ += \"impl flatbuffers::SimpleToVerifyInSlice for {{ENUM_NAME}} {}\";\n\n    if (enum_def.is_union) {\n      // Generate typesafe offset(s) for unions\n      code_.SetValue(\"NAME\", Name(enum_def));\n      code_.SetValue(\"UNION_OFFSET_NAME\", Name(enum_def) + \"UnionTableOffset\");\n      code_ += \"pub struct {{UNION_OFFSET_NAME}} {}\";\n      code_ += \"\";\n      if (parser_.opts.generate_object_based_api) { GenUnionObject(enum_def); }\n    }\n  }",
  "abstract_func_before": "void GenEnum(const EnumDef &VAR_0) {\n    VAR_1.SetValue(\"ENUM_NAME\", Name(VAR_0));\n    VAR_1.SetValue(\"BASE_TYPE\", GetEnumTypeForDecl(VAR_0.underlying_type));\n    VAR_1.SetValue(\"ENUM_NAME_SNAKE\", MakeSnakeCase(Name(VAR_0)));\n    VAR_1.SetValue(\"ENUM_NAME_CAPS\", MakeUpper(MakeSnakeCase(Name(VAR_0))));\n    const EnumVal *VAR_2 = VAR_0.MinValue();\n    const EnumVal *VAR_3 = VAR_0.MaxValue();\n    FLATBUFFERS_ASSERT(VAR_2 && VAR_3);\n    VAR_1.SetValue(\"ENUM_MIN_BASE_VALUE\", VAR_0.ToString(*VAR_2));\n    VAR_1.SetValue(\"ENUM_MAX_BASE_VALUE\", VAR_0.ToString(*VAR_3));\n\n    if (IsBitFlagsEnum(VAR_0)) {\n      /* COMMENT_0 */\n      /* COMMENT_1 */\n      /* COMMENT_2 */\n      /* COMMENT_3 */\n      VAR_1 += \"#[allow(non_upper_case_globals)]\";\n      VAR_1 += \"mod bitflags_{{ENUM_NAME_SNAKE}} {\";\n      VAR_1 += \"  flatbuffers::bitflags::bitflags! {\";\n      GenComment(VAR_0.doc_comment, \"    \");\n      VAR_1 += \"    #[derive(Default)]\";\n      VAR_1 += \"    pub struct {{ENUM_NAME}}: {{BASE_TYPE}} {\";\n      ForAllEnumValues1(VAR_0, [&](const EnumVal &VAR_4) {\n        this->GenComment(VAR_4.doc_comment, \"      \");\n        VAR_1 += \"      const {{VARIANT}} = {{VALUE}};\";\n      });\n      VAR_1 += \"    }\";\n      VAR_1 += \"  }\";\n      VAR_1 += \"}\";\n      VAR_1 += \"pub use self::bitflags_{{ENUM_NAME_SNAKE}}::{{ENUM_NAME}};\";\n      VAR_1 += \"\";\n\n      VAR_1.SetValue(\"FROM_BASE\", \"unsafe { Self::from_bits_unchecked(b) }\");\n      VAR_1.SetValue(\"INTO_BASE\", \"self.bits()\");\n    } else {\n      /* COMMENT_4 */\n      /* COMMENT_5 */\n      const std::string VAR_5 =\n          \"#[deprecated(since = \\\"2.0.0\\\", note = \\\"Use associated constants\"\n          \" instead. This will no longer be generated in 2021.\\\")]\";\n      VAR_1 += VAR_5;\n      VAR_1 +=\n          \"pub const ENUM_MIN_{{ENUM_NAME_CAPS}}: {{BASE_TYPE}}\"\n          \" = {{ENUM_MIN_BASE_VALUE}};\";\n      VAR_1 += VAR_5;\n      VAR_1 +=\n          \"pub const ENUM_MAX_{{ENUM_NAME_CAPS}}: {{BASE_TYPE}}\"\n          \" = {{ENUM_MAX_BASE_VALUE}};\";\n      auto VAR_6 = NumToString(VAR_0.size());\n      VAR_1 += VAR_5;\n      VAR_1 += \"#[allow(non_camel_case_types)]\";\n      VAR_1 += \"pub const ENUM_VALUES_{{ENUM_NAME_CAPS}}: [{{ENUM_NAME}}; \" +\n               VAR_6 + \"] = [\";\n      ForAllEnumValues1(VAR_0, [&](const EnumVal &VAR_4) {\n        VAR_1 += \"  \" + GetEnumValue(VAR_0, VAR_4) + \",\";\n      });\n      VAR_1 += \"];\";\n      VAR_1 += \"\";\n\n      GenComment(VAR_0.doc_comment);\n      /* COMMENT_6 */\n      /* COMMENT_7 */\n      /* COMMENT_8 */\n      VAR_1 +=\n          \"#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, \"\n          \"Default)]\";\n      VAR_1 += \"#[repr(transparent)]\";\n      VAR_1 += \"pub struct {{ENUM_NAME}}(pub {{BASE_TYPE}});\";\n      VAR_1 += \"#[allow(non_upper_case_globals)]\";\n      VAR_1 += \"impl {{ENUM_NAME}} {\";\n      ForAllEnumValues1(VAR_0, [&](const EnumVal &VAR_4) {\n        this->GenComment(VAR_4.doc_comment, \"  \");\n        VAR_1 += \"  pub const {{VARIANT}}: Self = Self({{VALUE}});\";\n      });\n      VAR_1 += \"\";\n      /* COMMENT_9 */\n      VAR_1 += \"  pub const ENUM_MIN: {{BASE_TYPE}} = {{ENUM_MIN_BASE_VALUE}};\";\n      VAR_1 += \"  pub const ENUM_MAX: {{BASE_TYPE}} = {{ENUM_MAX_BASE_VALUE}};\";\n      VAR_1 += \"  pub const ENUM_VALUES: &'static [Self] = &[\";\n      ForAllEnumValues(VAR_0, [&]() { VAR_1 += \"    Self::{{VARIANT}},\"; });\n      VAR_1 += \"  ];\";\n      VAR_1 += \"  /// Returns the variant's name or \\\"\\\" if unknown.\";\n      VAR_1 += \"  pub fn variant_name(self) -> Option<&'static str> {\";\n      VAR_1 += \"    match self {\";\n      ForAllEnumValues(VAR_0, [&]() {\n        VAR_1 += \"      Self::{{VARIANT}} => Some(\\\"{{VARIANT}}\\\"),\";\n      });\n      VAR_1 += \"      _ => None,\";\n      VAR_1 += \"    }\";\n      VAR_1 += \"  }\";\n      VAR_1 += \"}\";\n\n      /* COMMENT_10 */\n      VAR_1 += \"impl std::fmt::Debug for {{ENUM_NAME}} {\";\n      VAR_1 +=\n          \"  fn fmt(&self, f: &mut std::fmt::Formatter) ->\"\n          \" std::fmt::Result {\";\n      VAR_1 += \"    if let Some(name) = self.variant_name() {\";\n      VAR_1 += \"      f.write_str(name)\";\n      VAR_1 += \"    } else {\";\n      VAR_1 += \"      f.write_fmt(format_args!(\\\"<UNKNOWN {:?}>\\\", self.0))\";\n      VAR_1 += \"    }\";\n      VAR_1 += \"  }\";\n      VAR_1 += \"}\";\n\n      VAR_1.SetValue(\"FROM_BASE\", \"Self(b)\");\n      VAR_1.SetValue(\"INTO_BASE\", \"self.0\");\n    }\n\n    /* COMMENT_11 */\n    VAR_1 += \"impl<'a> flatbuffers::Follow<'a> for {{ENUM_NAME}} {\";\n    VAR_1 += \"  type Inner = Self;\";\n    VAR_1 += \"  #[inline]\";\n    VAR_1 += \"  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {\";\n    VAR_1 +=\n        \"    let b = flatbuffers::read_scalar_at::<{{BASE_TYPE}}>(buf,\"\n        \" loc);\";\n    VAR_1 += \"    {{FROM_BASE}}\";\n    VAR_1 += \"  }\";\n    VAR_1 += \"}\";\n    VAR_1 += \"\";\n    VAR_1 += \"impl flatbuffers::Push for {{ENUM_NAME}} {\";\n    VAR_1 += \"    type Output = {{ENUM_NAME}};\";\n    VAR_1 += \"    #[inline]\";\n    VAR_1 += \"    fn push(&self, dst: &mut [u8], _rest: &[u8]) {\";\n    VAR_1 +=\n        \"        unsafe { flatbuffers::emplace_scalar::<{{BASE_TYPE}}>\"\n        \"(dst, {{INTO_BASE}}); }\";\n    VAR_1 += \"    }\";\n    VAR_1 += \"}\";\n    VAR_1 += \"\";\n    VAR_1 += \"impl flatbuffers::EndianScalar for {{ENUM_NAME}} {\";\n    VAR_1 += \"  #[inline]\";\n    VAR_1 += \"  fn to_little_endian(self) -> Self {\";\n    VAR_1 += \"    let b = {{BASE_TYPE}}::to_le({{INTO_BASE}});\";\n    VAR_1 += \"    {{FROM_BASE}}\";\n    VAR_1 += \"  }\";\n    VAR_1 += \"  #[inline]\";\n    VAR_1 += \"  #[allow(clippy::wrong_self_convention)]\";\n    VAR_1 += \"  fn from_little_endian(self) -> Self {\";\n    VAR_1 += \"    let b = {{BASE_TYPE}}::from_le({{INTO_BASE}});\";\n    VAR_1 += \"    {{FROM_BASE}}\";\n    VAR_1 += \"  }\";\n    VAR_1 += \"}\";\n    VAR_1 += \"\";\n\n    /* COMMENT_12 */\n    VAR_1 += \"impl<'a> flatbuffers::Verifiable for {{ENUM_NAME}} {\";\n    VAR_1 += \"  #[inline]\";\n    VAR_1 += \"  fn run_verifier(\";\n    VAR_1 += \"    v: &mut flatbuffers::Verifier, pos: usize\";\n    VAR_1 += \"  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {\";\n    VAR_1 += \"    use self::flatbuffers::Verifiable;\";\n    VAR_1 += \"    {{BASE_TYPE}}::run_verifier(v, pos)\";\n    VAR_1 += \"  }\";\n    VAR_1 += \"}\";\n    VAR_1 += \"\";\n    /* COMMENT_13 */\n    VAR_1 += \"impl flatbuffers::SimpleToVerifyInSlice for {{ENUM_NAME}} {}\";\n\n    if (VAR_0.is_union) {\n      /* COMMENT_14 */\n      VAR_1.SetValue(\"NAME\", Name(VAR_0));\n      VAR_1.SetValue(\"UNION_OFFSET_NAME\", Name(VAR_0) + \"UnionTableOffset\");\n      VAR_1 += \"pub struct {{UNION_OFFSET_NAME}} {}\";\n      VAR_1 += \"\";\n      if (VAR_7.opts.generate_object_based_api) { GenUnionObject(VAR_0); }\n    }\n  }",
  "func_graph_path_before": "google/flatbuffers/77991e92337bb7474c439e1f579648e4e42cb595/idl_gen_rust.cpp/vul/before/0.json",
  "func": "void GenEnum(const EnumDef &enum_def) {\n    code_.SetValue(\"ENUM_NAME\", Name(enum_def));\n    code_.SetValue(\"BASE_TYPE\", GetEnumTypeForDecl(enum_def.underlying_type));\n    code_.SetValue(\"ENUM_NAME_SNAKE\", MakeSnakeCase(Name(enum_def)));\n    code_.SetValue(\"ENUM_NAME_CAPS\", MakeUpper(MakeSnakeCase(Name(enum_def))));\n    const EnumVal *minv = enum_def.MinValue();\n    const EnumVal *maxv = enum_def.MaxValue();\n    FLATBUFFERS_ASSERT(minv && maxv);\n    code_.SetValue(\"ENUM_MIN_BASE_VALUE\", enum_def.ToString(*minv));\n    code_.SetValue(\"ENUM_MAX_BASE_VALUE\", enum_def.ToString(*maxv));\n\n    if (IsBitFlagsEnum(enum_def)) {\n      // Defer to the convenient and canonical bitflags crate. We declare it in\n      // a module to #allow camel case constants in a smaller scope. This\n      // matches Flatbuffers c-modeled enums where variants are associated\n      // constants but in camel case.\n      code_ += \"#[allow(non_upper_case_globals)]\";\n      code_ += \"mod bitflags_{{ENUM_NAME_SNAKE}} {\";\n      code_ += \"  flatbuffers::bitflags::bitflags! {\";\n      GenComment(enum_def.doc_comment, \"    \");\n      code_ += \"    #[derive(Default)]\";\n      code_ += \"    pub struct {{ENUM_NAME}}: {{BASE_TYPE}} {\";\n      ForAllEnumValues1(enum_def, [&](const EnumVal &ev) {\n        this->GenComment(ev.doc_comment, \"      \");\n        code_ += \"      const {{VARIANT}} = {{VALUE}};\";\n      });\n      code_ += \"    }\";\n      code_ += \"  }\";\n      code_ += \"}\";\n      code_ += \"pub use self::bitflags_{{ENUM_NAME_SNAKE}}::{{ENUM_NAME}};\";\n      code_ += \"\";\n\n      code_.SetValue(\"FROM_BASE\", \"unsafe { Self::from_bits_unchecked(b) }\");\n      code_.SetValue(\"INTO_BASE\", \"self.bits()\");\n    } else {\n      // Normal, c-modelled enums.\n      // Deprecated associated constants;\n      const std::string deprecation_warning =\n          \"#[deprecated(since = \\\"2.0.0\\\", note = \\\"Use associated constants\"\n          \" instead. This will no longer be generated in 2021.\\\")]\";\n      code_ += deprecation_warning;\n      code_ +=\n          \"pub const ENUM_MIN_{{ENUM_NAME_CAPS}}: {{BASE_TYPE}}\"\n          \" = {{ENUM_MIN_BASE_VALUE}};\";\n      code_ += deprecation_warning;\n      code_ +=\n          \"pub const ENUM_MAX_{{ENUM_NAME_CAPS}}: {{BASE_TYPE}}\"\n          \" = {{ENUM_MAX_BASE_VALUE}};\";\n      auto num_fields = NumToString(enum_def.size());\n      code_ += deprecation_warning;\n      code_ += \"#[allow(non_camel_case_types)]\";\n      code_ += \"pub const ENUM_VALUES_{{ENUM_NAME_CAPS}}: [{{ENUM_NAME}}; \" +\n               num_fields + \"] = [\";\n      ForAllEnumValues1(enum_def, [&](const EnumVal &ev) {\n        code_ += \"  \" + GetEnumValue(enum_def, ev) + \",\";\n      });\n      code_ += \"];\";\n      code_ += \"\";\n\n      GenComment(enum_def.doc_comment);\n      // Derive Default to be 0. flatc enforces this when the enum\n      // is put into a struct, though this isn't documented behavior, it is\n      // needed to derive defaults in struct objects.\n      code_ +=\n          \"#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, \"\n          \"Default)]\";\n      code_ += \"#[repr(transparent)]\";\n      code_ += \"pub struct {{ENUM_NAME}}(pub {{BASE_TYPE}});\";\n      code_ += \"#[allow(non_upper_case_globals)]\";\n      code_ += \"impl {{ENUM_NAME}} {\";\n      ForAllEnumValues1(enum_def, [&](const EnumVal &ev) {\n        this->GenComment(ev.doc_comment, \"  \");\n        code_ += \"  pub const {{VARIANT}}: Self = Self({{VALUE}});\";\n      });\n      code_ += \"\";\n      // Generate Associated constants\n      code_ += \"  pub const ENUM_MIN: {{BASE_TYPE}} = {{ENUM_MIN_BASE_VALUE}};\";\n      code_ += \"  pub const ENUM_MAX: {{BASE_TYPE}} = {{ENUM_MAX_BASE_VALUE}};\";\n      code_ += \"  pub const ENUM_VALUES: &'static [Self] = &[\";\n      ForAllEnumValues(enum_def, [&]() { code_ += \"    Self::{{VARIANT}},\"; });\n      code_ += \"  ];\";\n      code_ += \"  /// Returns the variant's name or \\\"\\\" if unknown.\";\n      code_ += \"  pub fn variant_name(self) -> Option<&'static str> {\";\n      code_ += \"    match self {\";\n      ForAllEnumValues(enum_def, [&]() {\n        code_ += \"      Self::{{VARIANT}} => Some(\\\"{{VARIANT}}\\\"),\";\n      });\n      code_ += \"      _ => None,\";\n      code_ += \"    }\";\n      code_ += \"  }\";\n      code_ += \"}\";\n\n      // Generate Debug. Unknown variants are printed like \"<UNKNOWN 42>\".\n      code_ += \"impl std::fmt::Debug for {{ENUM_NAME}} {\";\n      code_ +=\n          \"  fn fmt(&self, f: &mut std::fmt::Formatter) ->\"\n          \" std::fmt::Result {\";\n      code_ += \"    if let Some(name) = self.variant_name() {\";\n      code_ += \"      f.write_str(name)\";\n      code_ += \"    } else {\";\n      code_ += \"      f.write_fmt(format_args!(\\\"<UNKNOWN {:?}>\\\", self.0))\";\n      code_ += \"    }\";\n      code_ += \"  }\";\n      code_ += \"}\";\n\n      code_.SetValue(\"FROM_BASE\", \"Self(b)\");\n      code_.SetValue(\"INTO_BASE\", \"self.0\");\n    }\n\n    // Generate Follow and Push so we can serialize and stuff.\n    code_ += \"impl<'a> flatbuffers::Follow<'a> for {{ENUM_NAME}} {\";\n    code_ += \"  type Inner = Self;\";\n    code_ += \"  #[inline]\";\n    code_ += \"  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {\";\n    code_ += \"    let b = unsafe {\";\n    code_ += \"      flatbuffers::read_scalar_at::<{{BASE_TYPE}}>(buf, loc)\";\n    code_ += \"    };\";\n    code_ += \"    {{FROM_BASE}}\";\n    code_ += \"  }\";\n    code_ += \"}\";\n    code_ += \"\";\n    code_ += \"impl flatbuffers::Push for {{ENUM_NAME}} {\";\n    code_ += \"    type Output = {{ENUM_NAME}};\";\n    code_ += \"    #[inline]\";\n    code_ += \"    fn push(&self, dst: &mut [u8], _rest: &[u8]) {\";\n    code_ +=\n        \"        unsafe { flatbuffers::emplace_scalar::<{{BASE_TYPE}}>\"\n        \"(dst, {{INTO_BASE}}); }\";\n    code_ += \"    }\";\n    code_ += \"}\";\n    code_ += \"\";\n    code_ += \"impl flatbuffers::EndianScalar for {{ENUM_NAME}} {\";\n    code_ += \"  #[inline]\";\n    code_ += \"  fn to_little_endian(self) -> Self {\";\n    code_ += \"    let b = {{BASE_TYPE}}::to_le({{INTO_BASE}});\";\n    code_ += \"    {{FROM_BASE}}\";\n    code_ += \"  }\";\n    code_ += \"  #[inline]\";\n    code_ += \"  #[allow(clippy::wrong_self_convention)]\";\n    code_ += \"  fn from_little_endian(self) -> Self {\";\n    code_ += \"    let b = {{BASE_TYPE}}::from_le({{INTO_BASE}});\";\n    code_ += \"    {{FROM_BASE}}\";\n    code_ += \"  }\";\n    code_ += \"}\";\n    code_ += \"\";\n\n    // Generate verifier - deferring to the base type.\n    code_ += \"impl<'a> flatbuffers::Verifiable for {{ENUM_NAME}} {\";\n    code_ += \"  #[inline]\";\n    code_ += \"  fn run_verifier(\";\n    code_ += \"    v: &mut flatbuffers::Verifier, pos: usize\";\n    code_ += \"  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {\";\n    code_ += \"    use self::flatbuffers::Verifiable;\";\n    code_ += \"    {{BASE_TYPE}}::run_verifier(v, pos)\";\n    code_ += \"  }\";\n    code_ += \"}\";\n    code_ += \"\";\n    // Enums are basically integers.\n    code_ += \"impl flatbuffers::SimpleToVerifyInSlice for {{ENUM_NAME}} {}\";\n\n    if (enum_def.is_union) {\n      // Generate typesafe offset(s) for unions\n      code_.SetValue(\"NAME\", Name(enum_def));\n      code_.SetValue(\"UNION_OFFSET_NAME\", Name(enum_def) + \"UnionTableOffset\");\n      code_ += \"pub struct {{UNION_OFFSET_NAME}} {}\";\n      code_ += \"\";\n      if (parser_.opts.generate_object_based_api) { GenUnionObject(enum_def); }\n    }\n  }",
  "abstract_func": "void GenEnum(const EnumDef &VAR_0) {\n    VAR_1.SetValue(\"ENUM_NAME\", Name(VAR_0));\n    VAR_1.SetValue(\"BASE_TYPE\", GetEnumTypeForDecl(VAR_0.underlying_type));\n    VAR_1.SetValue(\"ENUM_NAME_SNAKE\", MakeSnakeCase(Name(VAR_0)));\n    VAR_1.SetValue(\"ENUM_NAME_CAPS\", MakeUpper(MakeSnakeCase(Name(VAR_0))));\n    const EnumVal *VAR_2 = VAR_0.MinValue();\n    const EnumVal *VAR_3 = VAR_0.MaxValue();\n    FLATBUFFERS_ASSERT(VAR_2 && VAR_3);\n    VAR_1.SetValue(\"ENUM_MIN_BASE_VALUE\", VAR_0.ToString(*VAR_2));\n    VAR_1.SetValue(\"ENUM_MAX_BASE_VALUE\", VAR_0.ToString(*VAR_3));\n\n    if (IsBitFlagsEnum(VAR_0)) {\n      /* COMMENT_0 */\n      /* COMMENT_1 */\n      /* COMMENT_2 */\n      /* COMMENT_3 */\n      VAR_1 += \"#[allow(non_upper_case_globals)]\";\n      VAR_1 += \"mod bitflags_{{ENUM_NAME_SNAKE}} {\";\n      VAR_1 += \"  flatbuffers::bitflags::bitflags! {\";\n      GenComment(VAR_0.doc_comment, \"    \");\n      VAR_1 += \"    #[derive(Default)]\";\n      VAR_1 += \"    pub struct {{ENUM_NAME}}: {{BASE_TYPE}} {\";\n      ForAllEnumValues1(VAR_0, [&](const EnumVal &VAR_4) {\n        this->GenComment(VAR_4.doc_comment, \"      \");\n        VAR_1 += \"      const {{VARIANT}} = {{VALUE}};\";\n      });\n      VAR_1 += \"    }\";\n      VAR_1 += \"  }\";\n      VAR_1 += \"}\";\n      VAR_1 += \"pub use self::bitflags_{{ENUM_NAME_SNAKE}}::{{ENUM_NAME}};\";\n      VAR_1 += \"\";\n\n      VAR_1.SetValue(\"FROM_BASE\", \"unsafe { Self::from_bits_unchecked(b) }\");\n      VAR_1.SetValue(\"INTO_BASE\", \"self.bits()\");\n    } else {\n      /* COMMENT_4 */\n      /* COMMENT_5 */\n      const std::string VAR_5 =\n          \"#[deprecated(since = \\\"2.0.0\\\", note = \\\"Use associated constants\"\n          \" instead. This will no longer be generated in 2021.\\\")]\";\n      VAR_1 += VAR_5;\n      VAR_1 +=\n          \"pub const ENUM_MIN_{{ENUM_NAME_CAPS}}: {{BASE_TYPE}}\"\n          \" = {{ENUM_MIN_BASE_VALUE}};\";\n      VAR_1 += VAR_5;\n      VAR_1 +=\n          \"pub const ENUM_MAX_{{ENUM_NAME_CAPS}}: {{BASE_TYPE}}\"\n          \" = {{ENUM_MAX_BASE_VALUE}};\";\n      auto VAR_6 = NumToString(VAR_0.size());\n      VAR_1 += VAR_5;\n      VAR_1 += \"#[allow(non_camel_case_types)]\";\n      VAR_1 += \"pub const ENUM_VALUES_{{ENUM_NAME_CAPS}}: [{{ENUM_NAME}}; \" +\n               VAR_6 + \"] = [\";\n      ForAllEnumValues1(VAR_0, [&](const EnumVal &VAR_4) {\n        VAR_1 += \"  \" + GetEnumValue(VAR_0, VAR_4) + \",\";\n      });\n      VAR_1 += \"];\";\n      VAR_1 += \"\";\n\n      GenComment(VAR_0.doc_comment);\n      /* COMMENT_6 */\n      /* COMMENT_7 */\n      /* COMMENT_8 */\n      VAR_1 +=\n          \"#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, \"\n          \"Default)]\";\n      VAR_1 += \"#[repr(transparent)]\";\n      VAR_1 += \"pub struct {{ENUM_NAME}}(pub {{BASE_TYPE}});\";\n      VAR_1 += \"#[allow(non_upper_case_globals)]\";\n      VAR_1 += \"impl {{ENUM_NAME}} {\";\n      ForAllEnumValues1(VAR_0, [&](const EnumVal &VAR_4) {\n        this->GenComment(VAR_4.doc_comment, \"  \");\n        VAR_1 += \"  pub const {{VARIANT}}: Self = Self({{VALUE}});\";\n      });\n      VAR_1 += \"\";\n      /* COMMENT_9 */\n      VAR_1 += \"  pub const ENUM_MIN: {{BASE_TYPE}} = {{ENUM_MIN_BASE_VALUE}};\";\n      VAR_1 += \"  pub const ENUM_MAX: {{BASE_TYPE}} = {{ENUM_MAX_BASE_VALUE}};\";\n      VAR_1 += \"  pub const ENUM_VALUES: &'static [Self] = &[\";\n      ForAllEnumValues(VAR_0, [&]() { VAR_1 += \"    Self::{{VARIANT}},\"; });\n      VAR_1 += \"  ];\";\n      VAR_1 += \"  /// Returns the variant's name or \\\"\\\" if unknown.\";\n      VAR_1 += \"  pub fn variant_name(self) -> Option<&'static str> {\";\n      VAR_1 += \"    match self {\";\n      ForAllEnumValues(VAR_0, [&]() {\n        VAR_1 += \"      Self::{{VARIANT}} => Some(\\\"{{VARIANT}}\\\"),\";\n      });\n      VAR_1 += \"      _ => None,\";\n      VAR_1 += \"    }\";\n      VAR_1 += \"  }\";\n      VAR_1 += \"}\";\n\n      /* COMMENT_10 */\n      VAR_1 += \"impl std::fmt::Debug for {{ENUM_NAME}} {\";\n      VAR_1 +=\n          \"  fn fmt(&self, f: &mut std::fmt::Formatter) ->\"\n          \" std::fmt::Result {\";\n      VAR_1 += \"    if let Some(name) = self.variant_name() {\";\n      VAR_1 += \"      f.write_str(name)\";\n      VAR_1 += \"    } else {\";\n      VAR_1 += \"      f.write_fmt(format_args!(\\\"<UNKNOWN {:?}>\\\", self.0))\";\n      VAR_1 += \"    }\";\n      VAR_1 += \"  }\";\n      VAR_1 += \"}\";\n\n      VAR_1.SetValue(\"FROM_BASE\", \"Self(b)\");\n      VAR_1.SetValue(\"INTO_BASE\", \"self.0\");\n    }\n\n    /* COMMENT_11 */\n    VAR_1 += \"impl<'a> flatbuffers::Follow<'a> for {{ENUM_NAME}} {\";\n    VAR_1 += \"  type Inner = Self;\";\n    VAR_1 += \"  #[inline]\";\n    VAR_1 += \"  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {\";\n    VAR_1 += \"    let b = unsafe {\";\n    VAR_1 += \"      flatbuffers::read_scalar_at::<{{BASE_TYPE}}>(buf, loc)\";\n    VAR_1 += \"    };\";\n    VAR_1 += \"    {{FROM_BASE}}\";\n    VAR_1 += \"  }\";\n    VAR_1 += \"}\";\n    VAR_1 += \"\";\n    VAR_1 += \"impl flatbuffers::Push for {{ENUM_NAME}} {\";\n    VAR_1 += \"    type Output = {{ENUM_NAME}};\";\n    VAR_1 += \"    #[inline]\";\n    VAR_1 += \"    fn push(&self, dst: &mut [u8], _rest: &[u8]) {\";\n    VAR_1 +=\n        \"        unsafe { flatbuffers::emplace_scalar::<{{BASE_TYPE}}>\"\n        \"(dst, {{INTO_BASE}}); }\";\n    VAR_1 += \"    }\";\n    VAR_1 += \"}\";\n    VAR_1 += \"\";\n    VAR_1 += \"impl flatbuffers::EndianScalar for {{ENUM_NAME}} {\";\n    VAR_1 += \"  #[inline]\";\n    VAR_1 += \"  fn to_little_endian(self) -> Self {\";\n    VAR_1 += \"    let b = {{BASE_TYPE}}::to_le({{INTO_BASE}});\";\n    VAR_1 += \"    {{FROM_BASE}}\";\n    VAR_1 += \"  }\";\n    VAR_1 += \"  #[inline]\";\n    VAR_1 += \"  #[allow(clippy::wrong_self_convention)]\";\n    VAR_1 += \"  fn from_little_endian(self) -> Self {\";\n    VAR_1 += \"    let b = {{BASE_TYPE}}::from_le({{INTO_BASE}});\";\n    VAR_1 += \"    {{FROM_BASE}}\";\n    VAR_1 += \"  }\";\n    VAR_1 += \"}\";\n    VAR_1 += \"\";\n\n    /* COMMENT_12 */\n    VAR_1 += \"impl<'a> flatbuffers::Verifiable for {{ENUM_NAME}} {\";\n    VAR_1 += \"  #[inline]\";\n    VAR_1 += \"  fn run_verifier(\";\n    VAR_1 += \"    v: &mut flatbuffers::Verifier, pos: usize\";\n    VAR_1 += \"  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {\";\n    VAR_1 += \"    use self::flatbuffers::Verifiable;\";\n    VAR_1 += \"    {{BASE_TYPE}}::run_verifier(v, pos)\";\n    VAR_1 += \"  }\";\n    VAR_1 += \"}\";\n    VAR_1 += \"\";\n    /* COMMENT_13 */\n    VAR_1 += \"impl flatbuffers::SimpleToVerifyInSlice for {{ENUM_NAME}} {}\";\n\n    if (VAR_0.is_union) {\n      /* COMMENT_14 */\n      VAR_1.SetValue(\"NAME\", Name(VAR_0));\n      VAR_1.SetValue(\"UNION_OFFSET_NAME\", Name(VAR_0) + \"UnionTableOffset\");\n      VAR_1 += \"pub struct {{UNION_OFFSET_NAME}} {}\";\n      VAR_1 += \"\";\n      if (VAR_7.opts.generate_object_based_api) { GenUnionObject(VAR_0); }\n    }\n  }",
  "func_graph_path": "google/flatbuffers/77991e92337bb7474c439e1f579648e4e42cb595/idl_gen_rust.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -112,9 +112,9 @@\n     code_ += \"  type Inner = Self;\";\n     code_ += \"  #[inline]\";\n     code_ += \"  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {\";\n-    code_ +=\n-        \"    let b = flatbuffers::read_scalar_at::<{{BASE_TYPE}}>(buf,\"\n-        \" loc);\";\n+    code_ += \"    let b = unsafe {\";\n+    code_ += \"      flatbuffers::read_scalar_at::<{{BASE_TYPE}}>(buf, loc)\";\n+    code_ += \"    };\";\n     code_ += \"    {{FROM_BASE}}\";\n     code_ += \"  }\";\n     code_ += \"}\";",
  "diff_line_info": {
    "deleted_lines": [
      "    code_ +=",
      "        \"    let b = flatbuffers::read_scalar_at::<{{BASE_TYPE}}>(buf,\"",
      "        \" loc);\";"
    ],
    "added_lines": [
      "    code_ += \"    let b = unsafe {\";",
      "    code_ += \"      flatbuffers::read_scalar_at::<{{BASE_TYPE}}>(buf, loc)\";",
      "    code_ += \"    };\";"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/google/flatbuffers/pull/6588",
  "description": {
    "pr_info": {
      "title": "Mark endian_scalar as unsafe.",
      "number": 6588
    },
    "comment": [
      "Also\r\n- removed the deprecated flexbuffer slice from example\r\n- fixed some cargo warnings\r\n\r\n---\r\n\r\nPTAL @krojew \r\n\r\nThis should fix #5825 \r\n\r\nI didn't add any `// UNSAFE OK` comments since the existing code is considered safe due to previous testing ",
      "What about `read_scalar*`?",
      "Btw, I also considered adding assertions instead of adding `unsafe`. We get a ~10% regression in some cases.\r\n\r\nHEAD\r\n```\r\ntest create_byte_vector_100_naive       ... bench:         719 ns/iter (+/- 56) = 139 MB/s\r\ntest create_byte_vector_100_optimal     ... bench:          24 ns/iter (+/- 3) = 4166 MB/s\r\ntest create_canonical_buffer_then_reset ... bench:         950 ns/iter (+/- 102) = 315 MB/s\r\ntest create_string_10                   ... bench:          26 ns/iter (+/- 3) = 384 MB/s\r\ntest create_string_100                  ... bench:          32 ns/iter (+/- 3) = 3093 MB/s\r\ntest hundred_maps                       ... bench:      60,096 ns/iter (+/- 4,983) = 152 MB/s\r\ntest hundred_maps_pooled                ... bench:      61,406 ns/iter (+/- 6,650) = 148 MB/s\r\ntest push_vec_u64_to_map                ... bench:      29,969 ns/iter (+/- 3,367) = 412 MB/s\r\ntest push_vec_u64_to_map_direct         ... bench:      14,889 ns/iter (+/- 4,667) = 830 MB/s\r\ntest push_vec_u64_to_map_direct_reused  ... bench:      12,101 ns/iter (+/- 936) = 1021 MB/s\r\ntest push_vec_u64_to_map_reused         ... bench:      26,675 ns/iter (+/- 2,637) = 463 MB/s\r\ntest push_vec_with_indirect             ... bench:      20,389 ns/iter (+/- 1,341) = 151 MB/s\r\ntest push_vec_without_indirect          ... bench:      21,637 ns/iter (+/- 2,597) = 426 MB/s\r\ntest read_monsters                      ... bench:     148,441 ns/iter (+/- 19,836) = 118 MB/s\r\ntest serialize_monsters                 ... bench:     168,858 ns/iter (+/- 22,882) = 103 MB/s\r\ntest traverse_canonical_buffer          ... bench:         116 ns/iter (+/- 18) = 2586 MB/s\r\n```\r\n\r\n\r\nWith Assertions\r\n```\r\ntest create_byte_vector_100_naive       ... bench:         858 ns/iter (+/- 78) = 116 MB/s\r\ntest create_byte_vector_100_optimal     ... bench:          28 ns/iter (+/- 4) = 3571 MB/s\r\ntest create_canonical_buffer_then_reset ... bench:       1,038 ns/iter (+/- 124) = 289 MB/s\r\ntest create_string_10                   ... bench:          28 ns/iter (+/- 3) = 357 MB/s\r\ntest create_string_100                  ... bench:          34 ns/iter (+/- 4) = 2911 MB/s\r\ntest hundred_maps                       ... bench:      63,305 ns/iter (+/- 5,542) = 144 MB/s\r\ntest hundred_maps_pooled                ... bench:      63,436 ns/iter (+/- 5,745) = 144 MB/s\r\ntest push_vec_u64_to_map                ... bench:      30,453 ns/iter (+/- 3,207) = 405 MB/s\r\ntest push_vec_u64_to_map_direct         ... bench:      14,934 ns/iter (+/- 952) = 827 MB/s\r\ntest push_vec_u64_to_map_direct_reused  ... bench:      12,369 ns/iter (+/- 1,576) = 999 MB/s\r\ntest push_vec_u64_to_map_reused         ... bench:      27,199 ns/iter (+/- 2,697) = 454 MB/s\r\ntest push_vec_with_indirect             ... bench:      20,701 ns/iter (+/- 1,693) = 149 MB/s\r\ntest push_vec_without_indirect          ... bench:      21,738 ns/iter (+/- 2,212) = 424 MB/s\r\ntest read_monsters                      ... bench:     150,519 ns/iter (+/- 16,903) = 116 MB/s\r\ntest serialize_monsters                 ... bench:     167,720 ns/iter (+/- 14,090) = 104 MB/s\r\ntest traverse_canonical_buffer          ... bench:         112 ns/iter (+/- 11) = 2678 MB/s\r\n```\r\n\r\n",
      "> What about `read_scalar*`?\r\n\r\n@krojew, oops, I should've noticed that",
      "Looks good! We should add resolution info to rust advisory after a release. "
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.6,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.6  \n\nWhile the code change involves making operations unsafe, suggesting potential security implications, the lack of explicit mention of a security issue or CVE lowers the confidence. However, the use of unsafe in Rust often relates to addressing memory or undefined behavior issues, which can be security concerns."
}