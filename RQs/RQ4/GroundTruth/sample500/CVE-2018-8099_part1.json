{
  "cve_id": "CVE-2018-8099",
  "cwe_ids": [
    "CWE-415"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "libgit2",
  "commit_msg": "index: convert `read_entry` to return entry size via an out-param\n\nThe function `read_entry` does not conform to our usual coding style of\nreturning stuff via the out parameter and to use the return value for\nreporting errors. Due to most of our code conforming to that pattern, it\nhas become quite natural for us to actually return `-1` in case there is\nany error, which has also slipped in with commit 5625d86b9 (index:\nsupport index v4, 2016-05-17). As the function returns an `size_t` only,\nthough, the return value is wrapped around, causing the caller of\n`read_tree` to continue with an invalid index entry. Ultimately, this\ncan lead to a double-free.\n\nImprove code and fix the bug by converting the function to return the\nindex entry size via an out parameter and only using the return value to\nindicate errors.\n\nReported-by: Krishna Ram Prakash R <krp@gtux.in>\nReported-by: Vivek Parikh <viv0411.parikh@gmail.com>",
  "commit_hash": "58a6fe94cb851f71214dbefac3f9bffee437d6fe",
  "git_url": "https://github.com/libgit2/libgit2/commit/58a6fe94cb851f71214dbefac3f9bffee437d6fe",
  "file_path": "src/index.c",
  "func_name": "parse_index",
  "func_before": "static int parse_index(git_index *index, const char *buffer, size_t buffer_size)\n{\n\tint error = 0;\n\tunsigned int i;\n\tstruct index_header header = { 0 };\n\tgit_oid checksum_calculated, checksum_expected;\n\tconst char *last = NULL;\n\tconst char *empty = \"\";\n\n#define seek_forward(_increase) { \\\n\tif (_increase >= buffer_size) { \\\n\t\terror = index_error_invalid(\"ran out of data while parsing\"); \\\n\t\tgoto done; } \\\n\tbuffer += _increase; \\\n\tbuffer_size -= _increase;\\\n}\n\n\tif (buffer_size < INDEX_HEADER_SIZE + INDEX_FOOTER_SIZE)\n\t\treturn index_error_invalid(\"insufficient buffer space\");\n\n\t/* Precalculate the SHA1 of the files's contents -- we'll match it to\n\t * the provided SHA1 in the footer */\n\tgit_hash_buf(&checksum_calculated, buffer, buffer_size - INDEX_FOOTER_SIZE);\n\n\t/* Parse header */\n\tif ((error = read_header(&header, buffer)) < 0)\n\t\treturn error;\n\n\tindex->version = header.version;\n\tif (index->version >= INDEX_VERSION_NUMBER_COMP)\n\t\tlast = empty;\n\n\tseek_forward(INDEX_HEADER_SIZE);\n\n\tassert(!index->entries.length);\n\n\tif (index->ignore_case)\n\t\tgit_idxmap_icase_resize((khash_t(idxicase) *) index->entries_map, header.entry_count);\n\telse\n\t\tgit_idxmap_resize(index->entries_map, header.entry_count);\n\n\t/* Parse all the entries */\n\tfor (i = 0; i < header.entry_count && buffer_size > INDEX_FOOTER_SIZE; ++i) {\n\t\tgit_index_entry *entry = NULL;\n\t\tsize_t entry_size = read_entry(&entry, index, buffer, buffer_size, last);\n\n\t\t/* 0 bytes read means an object corruption */\n\t\tif (entry_size == 0) {\n\t\t\terror = index_error_invalid(\"invalid entry\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tif ((error = git_vector_insert(&index->entries, entry)) < 0) {\n\t\t\tindex_entry_free(entry);\n\t\t\tgoto done;\n\t\t}\n\n\t\tINSERT_IN_MAP(index, entry, &error);\n\n\t\tif (error < 0) {\n\t\t\tindex_entry_free(entry);\n\t\t\tgoto done;\n\t\t}\n\t\terror = 0;\n\n\t\tif (index->version >= INDEX_VERSION_NUMBER_COMP)\n\t\t\tlast = entry->path;\n\n\t\tseek_forward(entry_size);\n\t}\n\n\tif (i != header.entry_count) {\n\t\terror = index_error_invalid(\"header entries changed while parsing\");\n\t\tgoto done;\n\t}\n\n\t/* There's still space for some extensions! */\n\twhile (buffer_size > INDEX_FOOTER_SIZE) {\n\t\tsize_t extension_size;\n\n\t\textension_size = read_extension(index, buffer, buffer_size);\n\n\t\t/* see if we have read any bytes from the extension */\n\t\tif (extension_size == 0) {\n\t\t\terror = index_error_invalid(\"extension is truncated\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tseek_forward(extension_size);\n\t}\n\n\tif (buffer_size != INDEX_FOOTER_SIZE) {\n\t\terror = index_error_invalid(\n\t\t\t\"buffer size does not match index footer size\");\n\t\tgoto done;\n\t}\n\n\t/* 160-bit SHA-1 over the content of the index file before this checksum. */\n\tgit_oid_fromraw(&checksum_expected, (const unsigned char *)buffer);\n\n\tif (git_oid__cmp(&checksum_calculated, &checksum_expected) != 0) {\n\t\terror = index_error_invalid(\n\t\t\t\"calculated checksum does not match expected\");\n\t\tgoto done;\n\t}\n\n\tgit_oid_cpy(&index->checksum, &checksum_calculated);\n\n#undef seek_forward\n\n\t/* Entries are stored case-sensitively on disk, so re-sort now if\n\t * in-memory index is supposed to be case-insensitive\n\t */\n\tgit_vector_set_sorted(&index->entries, !index->ignore_case);\n\tgit_vector_sort(&index->entries);\n\ndone:\n\treturn error;\n}",
  "abstract_func_before": "static int parse_index(git_index *VAR_0, const char *VAR_1, size_t VAR_2)\n{\n\tint VAR_3 = 0;\n\tunsigned int VAR_4;\n\tstruct index_header VAR_5 = { 0 };\n\tgit_oid VAR_6, VAR_7;\n\tconst char *VAR_8 = NULL;\n\tconst char *VAR_9 = \"\";\n\n#define seek_forward(VAR_10) { \\\n\tif (_increase >= buffer_size) { \\\n\t\terror = index_error_invalid(\"ran out of data while parsing\"); \\\n\t\tgoto done; } \\\n\tbuffer += _increase; \\\n\tbuffer_size -= _increase;\\\n}\n\n\tif (VAR_2 < VAR_11 + VAR_12)\n\t\treturn index_error_invalid(\"insufficient buffer space\");\n\n\t/* COMMENT_0 */\n                                      \n\tgit_hash_buf(&VAR_6, VAR_1, VAR_2 - VAR_12);\n\n\t/* COMMENT_2 */\n\tif ((VAR_3 = read_header(&VAR_5, VAR_1)) < 0)\n\t\treturn VAR_3;\n\n\tVAR_0->version = VAR_5.version;\n\tif (VAR_0->version >= VAR_13)\n\t\tVAR_8 = VAR_9;\n\n\tseek_forward(VAR_11);\n\n\tassert(!VAR_0->entries.length);\n\n\tif (VAR_0->ignore_case)\n\t\tgit_idxmap_icase_resize((VAR_14(idxicase) *) VAR_0->entries_map, VAR_5.entry_count);\n\telse\n\t\tgit_idxmap_resize(VAR_0->entries_map, VAR_5.entry_count);\n\n\t/* COMMENT_3 */\n\tfor (VAR_4 = 0; VAR_4 < VAR_5.entry_count && VAR_2 > VAR_12; ++VAR_4) {\n\t\tgit_index_entry *VAR_15 = NULL;\n\t\tsize_t VAR_16 = read_entry(&VAR_15, VAR_0, VAR_1, VAR_2, VAR_8);\n\n\t\t/* COMMENT_4 */\n\t\tif (VAR_16 == 0) {\n\t\t\tVAR_3 = index_error_invalid(\"invalid entry\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tif ((VAR_3 = git_vector_insert(&VAR_0->entries, VAR_15)) < 0) {\n\t\t\tindex_entry_free(VAR_15);\n\t\t\tgoto done;\n\t\t}\n\n\t\tINSERT_IN_MAP(VAR_0, VAR_15, &VAR_3);\n\n\t\tif (VAR_3 < 0) {\n\t\t\tindex_entry_free(VAR_15);\n\t\t\tgoto done;\n\t\t}\n\t\tVAR_3 = 0;\n\n\t\tif (VAR_0->version >= VAR_13)\n\t\t\tVAR_8 = VAR_15->path;\n\n\t\tseek_forward(VAR_16);\n\t}\n\n\tif (VAR_4 != VAR_5.entry_count) {\n\t\tVAR_3 = index_error_invalid(\"header entries changed while parsing\");\n\t\tgoto done;\n\t}\n\n\t/* COMMENT_5 */\n\twhile (VAR_2 > VAR_12) {\n\t\tsize_t VAR_17;\n\n\t\tVAR_17 = read_extension(VAR_0, VAR_1, VAR_2);\n\n\t\t/* COMMENT_6 */\n\t\tif (VAR_17 == 0) {\n\t\t\tVAR_3 = index_error_invalid(\"extension is truncated\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tseek_forward(VAR_17);\n\t}\n\n\tif (VAR_2 != VAR_12) {\n\t\tVAR_3 = index_error_invalid(\n\t\t\t\"buffer size does not match index footer size\");\n\t\tgoto done;\n\t}\n\n\t/* COMMENT_7 */\n\tgit_oid_fromraw(&VAR_7, (const unsigned char *)VAR_1);\n\n\tif (git_oid__cmp(&VAR_6, &VAR_7) != 0) {\n\t\tVAR_3 = index_error_invalid(\n\t\t\t\"calculated checksum does not match expected\");\n\t\tgoto done;\n\t}\n\n\tgit_oid_cpy(&VAR_0->checksum, &VAR_6);\n\n#undef seek_forward\n\n\t/* COMMENT_8 */\n                                                      \n    \n\tgit_vector_set_sorted(&VAR_0->entries, !VAR_0->ignore_case);\n\tgit_vector_sort(&VAR_0->entries);\n\ndone:\n\treturn VAR_3;\n}",
  "func_graph_path_before": "libgit2/58a6fe94cb851f71214dbefac3f9bffee437d6fe/index.c/vul/before/0.json",
  "func": "static int parse_index(git_index *index, const char *buffer, size_t buffer_size)\n{\n\tint error = 0;\n\tunsigned int i;\n\tstruct index_header header = { 0 };\n\tgit_oid checksum_calculated, checksum_expected;\n\tconst char *last = NULL;\n\tconst char *empty = \"\";\n\n#define seek_forward(_increase) { \\\n\tif (_increase >= buffer_size) { \\\n\t\terror = index_error_invalid(\"ran out of data while parsing\"); \\\n\t\tgoto done; } \\\n\tbuffer += _increase; \\\n\tbuffer_size -= _increase;\\\n}\n\n\tif (buffer_size < INDEX_HEADER_SIZE + INDEX_FOOTER_SIZE)\n\t\treturn index_error_invalid(\"insufficient buffer space\");\n\n\t/* Precalculate the SHA1 of the files's contents -- we'll match it to\n\t * the provided SHA1 in the footer */\n\tgit_hash_buf(&checksum_calculated, buffer, buffer_size - INDEX_FOOTER_SIZE);\n\n\t/* Parse header */\n\tif ((error = read_header(&header, buffer)) < 0)\n\t\treturn error;\n\n\tindex->version = header.version;\n\tif (index->version >= INDEX_VERSION_NUMBER_COMP)\n\t\tlast = empty;\n\n\tseek_forward(INDEX_HEADER_SIZE);\n\n\tassert(!index->entries.length);\n\n\tif (index->ignore_case)\n\t\tgit_idxmap_icase_resize((khash_t(idxicase) *) index->entries_map, header.entry_count);\n\telse\n\t\tgit_idxmap_resize(index->entries_map, header.entry_count);\n\n\t/* Parse all the entries */\n\tfor (i = 0; i < header.entry_count && buffer_size > INDEX_FOOTER_SIZE; ++i) {\n\t\tgit_index_entry *entry = NULL;\n\t\tsize_t entry_size;\n\n\t\tif ((error = read_entry(&entry, &entry_size, index, buffer, buffer_size, last)) < 0) {\n\t\t\terror = index_error_invalid(\"invalid entry\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tif ((error = git_vector_insert(&index->entries, entry)) < 0) {\n\t\t\tindex_entry_free(entry);\n\t\t\tgoto done;\n\t\t}\n\n\t\tINSERT_IN_MAP(index, entry, &error);\n\n\t\tif (error < 0) {\n\t\t\tindex_entry_free(entry);\n\t\t\tgoto done;\n\t\t}\n\t\terror = 0;\n\n\t\tif (index->version >= INDEX_VERSION_NUMBER_COMP)\n\t\t\tlast = entry->path;\n\n\t\tseek_forward(entry_size);\n\t}\n\n\tif (i != header.entry_count) {\n\t\terror = index_error_invalid(\"header entries changed while parsing\");\n\t\tgoto done;\n\t}\n\n\t/* There's still space for some extensions! */\n\twhile (buffer_size > INDEX_FOOTER_SIZE) {\n\t\tsize_t extension_size;\n\n\t\textension_size = read_extension(index, buffer, buffer_size);\n\n\t\t/* see if we have read any bytes from the extension */\n\t\tif (extension_size == 0) {\n\t\t\terror = index_error_invalid(\"extension is truncated\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tseek_forward(extension_size);\n\t}\n\n\tif (buffer_size != INDEX_FOOTER_SIZE) {\n\t\terror = index_error_invalid(\n\t\t\t\"buffer size does not match index footer size\");\n\t\tgoto done;\n\t}\n\n\t/* 160-bit SHA-1 over the content of the index file before this checksum. */\n\tgit_oid_fromraw(&checksum_expected, (const unsigned char *)buffer);\n\n\tif (git_oid__cmp(&checksum_calculated, &checksum_expected) != 0) {\n\t\terror = index_error_invalid(\n\t\t\t\"calculated checksum does not match expected\");\n\t\tgoto done;\n\t}\n\n\tgit_oid_cpy(&index->checksum, &checksum_calculated);\n\n#undef seek_forward\n\n\t/* Entries are stored case-sensitively on disk, so re-sort now if\n\t * in-memory index is supposed to be case-insensitive\n\t */\n\tgit_vector_set_sorted(&index->entries, !index->ignore_case);\n\tgit_vector_sort(&index->entries);\n\ndone:\n\treturn error;\n}",
  "abstract_func": "static int parse_index(git_index *VAR_0, const char *VAR_1, size_t VAR_2)\n{\n\tint VAR_3 = 0;\n\tunsigned int VAR_4;\n\tstruct index_header VAR_5 = { 0 };\n\tgit_oid VAR_6, VAR_7;\n\tconst char *VAR_8 = NULL;\n\tconst char *VAR_9 = \"\";\n\n#define seek_forward(VAR_10) { \\\n\tif (_increase >= buffer_size) { \\\n\t\terror = index_error_invalid(\"ran out of data while parsing\"); \\\n\t\tgoto done; } \\\n\tbuffer += _increase; \\\n\tbuffer_size -= _increase;\\\n}\n\n\tif (VAR_2 < VAR_11 + VAR_12)\n\t\treturn index_error_invalid(\"insufficient buffer space\");\n\n\t/* COMMENT_0 */\n                                      \n\tgit_hash_buf(&VAR_6, VAR_1, VAR_2 - VAR_12);\n\n\t/* COMMENT_2 */\n\tif ((VAR_3 = read_header(&VAR_5, VAR_1)) < 0)\n\t\treturn VAR_3;\n\n\tVAR_0->version = VAR_5.version;\n\tif (VAR_0->version >= VAR_13)\n\t\tVAR_8 = VAR_9;\n\n\tseek_forward(VAR_11);\n\n\tassert(!VAR_0->entries.length);\n\n\tif (VAR_0->ignore_case)\n\t\tgit_idxmap_icase_resize((VAR_14(idxicase) *) VAR_0->entries_map, VAR_5.entry_count);\n\telse\n\t\tgit_idxmap_resize(VAR_0->entries_map, VAR_5.entry_count);\n\n\t/* COMMENT_3 */\n\tfor (VAR_4 = 0; VAR_4 < VAR_5.entry_count && VAR_2 > VAR_12; ++VAR_4) {\n\t\tgit_index_entry *VAR_15 = NULL;\n\t\tsize_t VAR_16;\n\n\t\tif ((VAR_3 = read_entry(&VAR_15, &VAR_16, VAR_0, VAR_1, VAR_2, VAR_8)) < 0) {\n\t\t\tVAR_3 = index_error_invalid(\"invalid entry\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tif ((VAR_3 = git_vector_insert(&VAR_0->entries, VAR_15)) < 0) {\n\t\t\tindex_entry_free(VAR_15);\n\t\t\tgoto done;\n\t\t}\n\n\t\tINSERT_IN_MAP(VAR_0, VAR_15, &VAR_3);\n\n\t\tif (VAR_3 < 0) {\n\t\t\tindex_entry_free(VAR_15);\n\t\t\tgoto done;\n\t\t}\n\t\tVAR_3 = 0;\n\n\t\tif (VAR_0->version >= VAR_13)\n\t\t\tVAR_8 = VAR_15->path;\n\n\t\tseek_forward(VAR_16);\n\t}\n\n\tif (VAR_4 != VAR_5.entry_count) {\n\t\tVAR_3 = index_error_invalid(\"header entries changed while parsing\");\n\t\tgoto done;\n\t}\n\n\t/* COMMENT_4 */\n\twhile (VAR_2 > VAR_12) {\n\t\tsize_t VAR_17;\n\n\t\tVAR_17 = read_extension(VAR_0, VAR_1, VAR_2);\n\n\t\t/* COMMENT_5 */\n\t\tif (VAR_17 == 0) {\n\t\t\tVAR_3 = index_error_invalid(\"extension is truncated\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tseek_forward(VAR_17);\n\t}\n\n\tif (VAR_2 != VAR_12) {\n\t\tVAR_3 = index_error_invalid(\n\t\t\t\"buffer size does not match index footer size\");\n\t\tgoto done;\n\t}\n\n\t/* COMMENT_6 */\n\tgit_oid_fromraw(&VAR_7, (const unsigned char *)VAR_1);\n\n\tif (git_oid__cmp(&VAR_6, &VAR_7) != 0) {\n\t\tVAR_3 = index_error_invalid(\n\t\t\t\"calculated checksum does not match expected\");\n\t\tgoto done;\n\t}\n\n\tgit_oid_cpy(&VAR_0->checksum, &VAR_6);\n\n#undef seek_forward\n\n\t/* COMMENT_7 */\n                                                      \n    \n\tgit_vector_set_sorted(&VAR_0->entries, !VAR_0->ignore_case);\n\tgit_vector_sort(&VAR_0->entries);\n\ndone:\n\treturn VAR_3;\n}",
  "func_graph_path": "libgit2/58a6fe94cb851f71214dbefac3f9bffee437d6fe/index.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -42,10 +42,9 @@\n \t/* Parse all the entries */\n \tfor (i = 0; i < header.entry_count && buffer_size > INDEX_FOOTER_SIZE; ++i) {\n \t\tgit_index_entry *entry = NULL;\n-\t\tsize_t entry_size = read_entry(&entry, index, buffer, buffer_size, last);\n+\t\tsize_t entry_size;\n \n-\t\t/* 0 bytes read means an object corruption */\n-\t\tif (entry_size == 0) {\n+\t\tif ((error = read_entry(&entry, &entry_size, index, buffer, buffer_size, last)) < 0) {\n \t\t\terror = index_error_invalid(\"invalid entry\");\n \t\t\tgoto done;\n \t\t}",
  "diff_line_info": {
    "deleted_lines": [
      "\t\tsize_t entry_size = read_entry(&entry, index, buffer, buffer_size, last);",
      "\t\t/* 0 bytes read means an object corruption */",
      "\t\tif (entry_size == 0) {"
    ],
    "added_lines": [
      "\t\tsize_t entry_size;",
      "\t\tif ((error = read_entry(&entry, &entry_size, index, buffer, buffer_size, last)) < 0) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libgit2/libgit2/pull/4575",
  "description": {
    "pr_info": {
      "title": "Index parsing fixes",
      "number": 4575
    },
    "comment": [
      "This is the security fix regarding reading of the compressed index entries forward-ported to the master branch."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.98,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.98"
}