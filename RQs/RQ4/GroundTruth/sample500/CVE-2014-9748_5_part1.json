{
  "cve_id": "CVE-2014-9748",
  "cwe_ids": [
    "CWE-362"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "libuv",
  "commit_msg": "win: fix unsavory rwlock fallback implementation\n\nBefore this patch an uv_mutex_t (backed by a critical section) could be\nreleased by a tread different from the thread that acquired it, which is\nnot allowed. This is fixed by using a semaphore instead.\n\nNote that the affected code paths were used on Windows XP and Windows\nServer 2003 only.\n\nThis is a back-port of commits 3eb6764, 1ad6ad7, 9a4fd26, 9823922\n85adf43 and bd1777f from the v1.x branch.\n\nFixes: https://github.com/libuv/libuv/issues/515\nRefs: https://github.com/libuv/libuv/pull/525\nPR-URL: https://github.com/libuv/libuv/pull/903\nReviewed-By: Ben Noordhuis <info@bnoordhuis.nl>\nReviewed-By: Bert Belder <bertbelder@gmail.com>",
  "commit_hash": "d4ff8fd5c175bc825258da3ffb01bd21bd5a6202",
  "git_url": "https://github.com/libuv/libuv/commit/d4ff8fd5c175bc825258da3ffb01bd21bd5a6202",
  "file_path": "src/win/winapi.c",
  "func_name": "uv_winapi_init",
  "func_before": "void uv_winapi_init() {\n  HMODULE ntdll_module;\n  HMODULE kernel32_module;\n\n  ntdll_module = GetModuleHandleA(\"ntdll.dll\");\n  if (ntdll_module == NULL) {\n    uv_fatal_error(GetLastError(), \"GetModuleHandleA\");\n  }\n\n  pRtlNtStatusToDosError = (sRtlNtStatusToDosError) GetProcAddress(\n      ntdll_module,\n      \"RtlNtStatusToDosError\");\n  if (pRtlNtStatusToDosError == NULL) {\n    uv_fatal_error(GetLastError(), \"GetProcAddress\");\n  }\n\n  pNtQueryInformationFile = (sNtQueryInformationFile) GetProcAddress(\n      ntdll_module,\n      \"NtQueryInformationFile\");\n  if (pNtQueryInformationFile == NULL) {\n    uv_fatal_error(GetLastError(), \"GetProcAddress\");\n  }\n\n  pNtDeviceIoControlFile = (sNtDeviceIoControlFile) GetProcAddress(\n      ntdll_module,\n      \"NtDeviceIoControlFile\");\n  if (pNtDeviceIoControlFile == NULL) {\n    uv_fatal_error(GetLastError(), \"GetProcAddress\");\n  }\n\n  pNtSetInformationFile = (sNtSetInformationFile) GetProcAddress(\n      ntdll_module,\n      \"NtSetInformationFile\");\n  if (pNtSetInformationFile == NULL) {\n    uv_fatal_error(GetLastError(), \"GetProcAddress\");\n  }\n\n  pNtQuerySystemInformation = (sNtQuerySystemInformation) GetProcAddress(\n      ntdll_module,\n      \"NtQuerySystemInformation\");\n  if (pNtQuerySystemInformation == NULL) {\n    uv_fatal_error(GetLastError(), \"GetProcAddress\");\n  }\n\n  kernel32_module = GetModuleHandleA(\"kernel32.dll\");\n  if (kernel32_module == NULL) {\n    uv_fatal_error(GetLastError(), \"GetModuleHandleA\");\n  }\n\n  pGetQueuedCompletionStatusEx = (sGetQueuedCompletionStatusEx) GetProcAddress(\n      kernel32_module,\n      \"GetQueuedCompletionStatusEx\");\n\n  pSetFileCompletionNotificationModes = (sSetFileCompletionNotificationModes)\n    GetProcAddress(kernel32_module, \"SetFileCompletionNotificationModes\");\n\n  pCreateSymbolicLinkW = (sCreateSymbolicLinkW)\n    GetProcAddress(kernel32_module, \"CreateSymbolicLinkW\");\n\n  pCancelIoEx = (sCancelIoEx)\n    GetProcAddress(kernel32_module, \"CancelIoEx\");\n\n  pInitializeSRWLock = (sInitializeSRWLock)\n    GetProcAddress(kernel32_module, \"InitializeSRWLock\");\n\n  pAcquireSRWLockShared = (sAcquireSRWLockShared)\n    GetProcAddress(kernel32_module, \"AcquireSRWLockShared\");\n\n  pAcquireSRWLockExclusive = (sAcquireSRWLockExclusive)\n    GetProcAddress(kernel32_module, \"AcquireSRWLockExclusive\");\n\n  pTryAcquireSRWLockShared = (sTryAcquireSRWLockShared)\n    GetProcAddress(kernel32_module, \"TryAcquireSRWLockShared\");\n\n  pTryAcquireSRWLockExclusive = (sTryAcquireSRWLockExclusive)\n    GetProcAddress(kernel32_module, \"TryAcquireSRWLockExclusive\");\n\n  pReleaseSRWLockShared = (sReleaseSRWLockShared)\n    GetProcAddress(kernel32_module, \"ReleaseSRWLockShared\");\n\n  pReleaseSRWLockExclusive = (sReleaseSRWLockExclusive)\n    GetProcAddress(kernel32_module, \"ReleaseSRWLockExclusive\");\n\n  pInitializeConditionVariable = (sInitializeConditionVariable)\n    GetProcAddress(kernel32_module, \"InitializeConditionVariable\");\n\n  pSleepConditionVariableCS = (sSleepConditionVariableCS)\n    GetProcAddress(kernel32_module, \"SleepConditionVariableCS\");\n\n  pSleepConditionVariableSRW = (sSleepConditionVariableSRW)\n    GetProcAddress(kernel32_module, \"SleepConditionVariableSRW\");\n\n  pWakeAllConditionVariable = (sWakeAllConditionVariable)\n    GetProcAddress(kernel32_module, \"WakeAllConditionVariable\");\n\n  pWakeConditionVariable = (sWakeConditionVariable)\n    GetProcAddress(kernel32_module, \"WakeConditionVariable\");\n}",
  "abstract_func_before": "void uv_winapi_init() {\n  HMODULE VAR_0;\n  HMODULE VAR_1;\n\n  VAR_0 = GetModuleHandleA(\"ntdll.dll\");\n  if (VAR_0 == NULL) {\n    uv_fatal_error(GetLastError(), \"GetModuleHandleA\");\n  }\n\n  VAR_2 = (sRtlNtStatusToDosError) GetProcAddress(\n      VAR_0,\n      \"RtlNtStatusToDosError\");\n  if (VAR_2 == NULL) {\n    uv_fatal_error(GetLastError(), \"GetProcAddress\");\n  }\n\n  VAR_3 = (sNtQueryInformationFile) GetProcAddress(\n      VAR_0,\n      \"NtQueryInformationFile\");\n  if (VAR_3 == NULL) {\n    uv_fatal_error(GetLastError(), \"GetProcAddress\");\n  }\n\n  VAR_4 = (sNtDeviceIoControlFile) GetProcAddress(\n      VAR_0,\n      \"NtDeviceIoControlFile\");\n  if (VAR_4 == NULL) {\n    uv_fatal_error(GetLastError(), \"GetProcAddress\");\n  }\n\n  VAR_5 = (sNtSetInformationFile) GetProcAddress(\n      VAR_0,\n      \"NtSetInformationFile\");\n  if (VAR_5 == NULL) {\n    uv_fatal_error(GetLastError(), \"GetProcAddress\");\n  }\n\n  VAR_6 = (sNtQuerySystemInformation) GetProcAddress(\n      VAR_0,\n      \"NtQuerySystemInformation\");\n  if (VAR_6 == NULL) {\n    uv_fatal_error(GetLastError(), \"GetProcAddress\");\n  }\n\n  VAR_1 = GetModuleHandleA(\"kernel32.dll\");\n  if (VAR_1 == NULL) {\n    uv_fatal_error(GetLastError(), \"GetModuleHandleA\");\n  }\n\n  VAR_7 = (sGetQueuedCompletionStatusEx) GetProcAddress(\n      VAR_1,\n      \"GetQueuedCompletionStatusEx\");\n\n  VAR_8 = (sSetFileCompletionNotificationModes)\n    GetProcAddress(VAR_1, \"SetFileCompletionNotificationModes\");\n\n  VAR_9 = (sCreateSymbolicLinkW)\n    GetProcAddress(VAR_1, \"CreateSymbolicLinkW\");\n\n  VAR_10 = (sCancelIoEx)\n    GetProcAddress(VAR_1, \"CancelIoEx\");\n\n  VAR_11 = (sInitializeSRWLock)\n    GetProcAddress(VAR_1, \"InitializeSRWLock\");\n\n  VAR_12 = (sAcquireSRWLockShared)\n    GetProcAddress(VAR_1, \"AcquireSRWLockShared\");\n\n  VAR_13 = (sAcquireSRWLockExclusive)\n    GetProcAddress(VAR_1, \"AcquireSRWLockExclusive\");\n\n  VAR_14 = (sTryAcquireSRWLockShared)\n    GetProcAddress(VAR_1, \"TryAcquireSRWLockShared\");\n\n  VAR_15 = (sTryAcquireSRWLockExclusive)\n    GetProcAddress(VAR_1, \"TryAcquireSRWLockExclusive\");\n\n  VAR_16 = (sReleaseSRWLockShared)\n    GetProcAddress(VAR_1, \"ReleaseSRWLockShared\");\n\n  VAR_17 = (sReleaseSRWLockExclusive)\n    GetProcAddress(VAR_1, \"ReleaseSRWLockExclusive\");\n\n  VAR_18 = (sInitializeConditionVariable)\n    GetProcAddress(VAR_1, \"InitializeConditionVariable\");\n\n  VAR_19 = (sSleepConditionVariableCS)\n    GetProcAddress(VAR_1, \"SleepConditionVariableCS\");\n\n  VAR_20 = (sSleepConditionVariableSRW)\n    GetProcAddress(VAR_1, \"SleepConditionVariableSRW\");\n\n  VAR_21 = (sWakeAllConditionVariable)\n    GetProcAddress(VAR_1, \"WakeAllConditionVariable\");\n\n  VAR_22 = (sWakeConditionVariable)\n    GetProcAddress(VAR_1, \"WakeConditionVariable\");\n}",
  "func_graph_path_before": "libuv/d4ff8fd5c175bc825258da3ffb01bd21bd5a6202/winapi.c/vul/before/0.json",
  "func": "void uv_winapi_init() {\n  HMODULE ntdll_module;\n  HMODULE kernel32_module;\n\n  ntdll_module = GetModuleHandleA(\"ntdll.dll\");\n  if (ntdll_module == NULL) {\n    uv_fatal_error(GetLastError(), \"GetModuleHandleA\");\n  }\n\n  pRtlNtStatusToDosError = (sRtlNtStatusToDosError) GetProcAddress(\n      ntdll_module,\n      \"RtlNtStatusToDosError\");\n  if (pRtlNtStatusToDosError == NULL) {\n    uv_fatal_error(GetLastError(), \"GetProcAddress\");\n  }\n\n  pNtQueryInformationFile = (sNtQueryInformationFile) GetProcAddress(\n      ntdll_module,\n      \"NtQueryInformationFile\");\n  if (pNtQueryInformationFile == NULL) {\n    uv_fatal_error(GetLastError(), \"GetProcAddress\");\n  }\n\n  pNtDeviceIoControlFile = (sNtDeviceIoControlFile) GetProcAddress(\n      ntdll_module,\n      \"NtDeviceIoControlFile\");\n  if (pNtDeviceIoControlFile == NULL) {\n    uv_fatal_error(GetLastError(), \"GetProcAddress\");\n  }\n\n  pNtSetInformationFile = (sNtSetInformationFile) GetProcAddress(\n      ntdll_module,\n      \"NtSetInformationFile\");\n  if (pNtSetInformationFile == NULL) {\n    uv_fatal_error(GetLastError(), \"GetProcAddress\");\n  }\n\n  pNtQuerySystemInformation = (sNtQuerySystemInformation) GetProcAddress(\n      ntdll_module,\n      \"NtQuerySystemInformation\");\n  if (pNtQuerySystemInformation == NULL) {\n    uv_fatal_error(GetLastError(), \"GetProcAddress\");\n  }\n\n  kernel32_module = GetModuleHandleA(\"kernel32.dll\");\n  if (kernel32_module == NULL) {\n    uv_fatal_error(GetLastError(), \"GetModuleHandleA\");\n  }\n\n  pGetQueuedCompletionStatusEx = (sGetQueuedCompletionStatusEx) GetProcAddress(\n      kernel32_module,\n      \"GetQueuedCompletionStatusEx\");\n\n  pSetFileCompletionNotificationModes = (sSetFileCompletionNotificationModes)\n    GetProcAddress(kernel32_module, \"SetFileCompletionNotificationModes\");\n\n  pCreateSymbolicLinkW = (sCreateSymbolicLinkW)\n    GetProcAddress(kernel32_module, \"CreateSymbolicLinkW\");\n\n  pCancelIoEx = (sCancelIoEx)\n    GetProcAddress(kernel32_module, \"CancelIoEx\");\n\n  pInitializeConditionVariable = (sInitializeConditionVariable)\n    GetProcAddress(kernel32_module, \"InitializeConditionVariable\");\n\n  pSleepConditionVariableCS = (sSleepConditionVariableCS)\n    GetProcAddress(kernel32_module, \"SleepConditionVariableCS\");\n\n  pSleepConditionVariableSRW = (sSleepConditionVariableSRW)\n    GetProcAddress(kernel32_module, \"SleepConditionVariableSRW\");\n\n  pWakeAllConditionVariable = (sWakeAllConditionVariable)\n    GetProcAddress(kernel32_module, \"WakeAllConditionVariable\");\n\n  pWakeConditionVariable = (sWakeConditionVariable)\n    GetProcAddress(kernel32_module, \"WakeConditionVariable\");\n}",
  "abstract_func": "void uv_winapi_init() {\n  HMODULE VAR_0;\n  HMODULE VAR_1;\n\n  VAR_0 = GetModuleHandleA(\"ntdll.dll\");\n  if (VAR_0 == NULL) {\n    uv_fatal_error(GetLastError(), \"GetModuleHandleA\");\n  }\n\n  VAR_2 = (sRtlNtStatusToDosError) GetProcAddress(\n      VAR_0,\n      \"RtlNtStatusToDosError\");\n  if (VAR_2 == NULL) {\n    uv_fatal_error(GetLastError(), \"GetProcAddress\");\n  }\n\n  VAR_3 = (sNtQueryInformationFile) GetProcAddress(\n      VAR_0,\n      \"NtQueryInformationFile\");\n  if (VAR_3 == NULL) {\n    uv_fatal_error(GetLastError(), \"GetProcAddress\");\n  }\n\n  VAR_4 = (sNtDeviceIoControlFile) GetProcAddress(\n      VAR_0,\n      \"NtDeviceIoControlFile\");\n  if (VAR_4 == NULL) {\n    uv_fatal_error(GetLastError(), \"GetProcAddress\");\n  }\n\n  VAR_5 = (sNtSetInformationFile) GetProcAddress(\n      VAR_0,\n      \"NtSetInformationFile\");\n  if (VAR_5 == NULL) {\n    uv_fatal_error(GetLastError(), \"GetProcAddress\");\n  }\n\n  VAR_6 = (sNtQuerySystemInformation) GetProcAddress(\n      VAR_0,\n      \"NtQuerySystemInformation\");\n  if (VAR_6 == NULL) {\n    uv_fatal_error(GetLastError(), \"GetProcAddress\");\n  }\n\n  VAR_1 = GetModuleHandleA(\"kernel32.dll\");\n  if (VAR_1 == NULL) {\n    uv_fatal_error(GetLastError(), \"GetModuleHandleA\");\n  }\n\n  VAR_7 = (sGetQueuedCompletionStatusEx) GetProcAddress(\n      VAR_1,\n      \"GetQueuedCompletionStatusEx\");\n\n  VAR_8 = (sSetFileCompletionNotificationModes)\n    GetProcAddress(VAR_1, \"SetFileCompletionNotificationModes\");\n\n  VAR_9 = (sCreateSymbolicLinkW)\n    GetProcAddress(VAR_1, \"CreateSymbolicLinkW\");\n\n  VAR_10 = (sCancelIoEx)\n    GetProcAddress(VAR_1, \"CancelIoEx\");\n\n  VAR_11 = (sInitializeConditionVariable)\n    GetProcAddress(VAR_1, \"InitializeConditionVariable\");\n\n  VAR_12 = (sSleepConditionVariableCS)\n    GetProcAddress(VAR_1, \"SleepConditionVariableCS\");\n\n  VAR_13 = (sSleepConditionVariableSRW)\n    GetProcAddress(VAR_1, \"SleepConditionVariableSRW\");\n\n  VAR_14 = (sWakeAllConditionVariable)\n    GetProcAddress(VAR_1, \"WakeAllConditionVariable\");\n\n  VAR_15 = (sWakeConditionVariable)\n    GetProcAddress(VAR_1, \"WakeConditionVariable\");\n}",
  "func_graph_path": "libuv/d4ff8fd5c175bc825258da3ffb01bd21bd5a6202/winapi.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -60,27 +60,6 @@\n   pCancelIoEx = (sCancelIoEx)\n     GetProcAddress(kernel32_module, \"CancelIoEx\");\n \n-  pInitializeSRWLock = (sInitializeSRWLock)\n-    GetProcAddress(kernel32_module, \"InitializeSRWLock\");\n-\n-  pAcquireSRWLockShared = (sAcquireSRWLockShared)\n-    GetProcAddress(kernel32_module, \"AcquireSRWLockShared\");\n-\n-  pAcquireSRWLockExclusive = (sAcquireSRWLockExclusive)\n-    GetProcAddress(kernel32_module, \"AcquireSRWLockExclusive\");\n-\n-  pTryAcquireSRWLockShared = (sTryAcquireSRWLockShared)\n-    GetProcAddress(kernel32_module, \"TryAcquireSRWLockShared\");\n-\n-  pTryAcquireSRWLockExclusive = (sTryAcquireSRWLockExclusive)\n-    GetProcAddress(kernel32_module, \"TryAcquireSRWLockExclusive\");\n-\n-  pReleaseSRWLockShared = (sReleaseSRWLockShared)\n-    GetProcAddress(kernel32_module, \"ReleaseSRWLockShared\");\n-\n-  pReleaseSRWLockExclusive = (sReleaseSRWLockExclusive)\n-    GetProcAddress(kernel32_module, \"ReleaseSRWLockExclusive\");\n-\n   pInitializeConditionVariable = (sInitializeConditionVariable)\n     GetProcAddress(kernel32_module, \"InitializeConditionVariable\");\n ",
  "diff_line_info": {
    "deleted_lines": [
      "  pInitializeSRWLock = (sInitializeSRWLock)",
      "    GetProcAddress(kernel32_module, \"InitializeSRWLock\");",
      "",
      "  pAcquireSRWLockShared = (sAcquireSRWLockShared)",
      "    GetProcAddress(kernel32_module, \"AcquireSRWLockShared\");",
      "",
      "  pAcquireSRWLockExclusive = (sAcquireSRWLockExclusive)",
      "    GetProcAddress(kernel32_module, \"AcquireSRWLockExclusive\");",
      "",
      "  pTryAcquireSRWLockShared = (sTryAcquireSRWLockShared)",
      "    GetProcAddress(kernel32_module, \"TryAcquireSRWLockShared\");",
      "",
      "  pTryAcquireSRWLockExclusive = (sTryAcquireSRWLockExclusive)",
      "    GetProcAddress(kernel32_module, \"TryAcquireSRWLockExclusive\");",
      "",
      "  pReleaseSRWLockShared = (sReleaseSRWLockShared)",
      "    GetProcAddress(kernel32_module, \"ReleaseSRWLockShared\");",
      "",
      "  pReleaseSRWLockExclusive = (sReleaseSRWLockExclusive)",
      "    GetProcAddress(kernel32_module, \"ReleaseSRWLockExclusive\");",
      ""
    ],
    "added_lines": []
  },
  "is_vul": true,
  "pr_url": "https://github.com/libuv/libuv/pull/903",
  "description": {
    "pr_info": {
      "title": "win: fix unsavory rwlock fallback implementation",
      "number": 903
    },
    "comment": [
      "Before this patch an uv_mutex_t (backed by a critical section) could be\nreleased by a tread different from the thread that acquired it, which is\nnot allowed. This is fixed by using a semaphore instead.\n\nNote that the affected code paths were used on Windows XP and Windows\nServer 2003 only.\n\nThis is a back-port of commits 3eb6764, 1ad6ad7, 9a4fd26, 9823922\n85adf43 and bd1777f from the v1.x branch.\n\nFixes: https://github.com/libuv/libuv/issues/515\nRefs: https://github.com/libuv/libuv/pull/525\n",
      "Windows XP \"CI\"\n![Imgur](http://i.imgur.com/qD71muU.png)\n\nSome tests fail (as thy were before) but the added one passes.\n",
      "Newer Windows CI: https://ci.nodejs.org/view/libuv/job/libuv-test-commit-windows/73/\n",
      "Notes: I had to backport https://github.com/libuv/libuv/pull/535 as well, to make the test pass. The test was also adapted because in 0.10 we returned -1 not real errors.\n\n/cc @bnoordhuis @piscisaureus @rvagg\n",
      "Windows 7 results:\n\n```\n[%  96|+ 182|-   7|T   1|S   0]: thread_mutex\n[%  96|+ 183|-   7|T   1|S   0]: thread_rwlock\n[%  97|+ 184|-   7|T   1|S   0]: thread_rwlock_trylock\n```\n\nAs far as I'm concerned, we are good to go.\n",
      "LGTM at a quick glance.\n",
      "LGTM\n"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.85,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.85"
}