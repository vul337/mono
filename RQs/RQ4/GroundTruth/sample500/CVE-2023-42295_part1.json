{
  "cve_id": "CVE-2023-42295",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "AcademySoftwareFoundation/OpenImageIO",
  "commit_msg": "fix runtime error: signed integer overflow in file src/bmp.imageio/bmpinput.cpp:302\n\nSigned-off-by: zhailiangliang <zhailiangliang@loongson.cn>",
  "commit_hash": "85bb38216c09bcf77739c087753d6b80e21323db",
  "git_url": "https://github.com/AcademySoftwareFoundation/OpenImageIO/commit/85bb38216c09bcf77739c087753d6b80e21323db",
  "file_path": "src/bmp.imageio/bmpinput.cpp",
  "func_name": "BmpInput::read_rle_image",
  "func_before": "bool\nBmpInput::read_rle_image()\n{\n    int rletype = m_dib_header.compression == RLE4_COMPRESSION ? 4 : 8;\n    m_spec.attribute(\"compression\", rletype == 4 ? \"rle4\" : \"rle8\");\n    m_uncompressed.clear();\n    m_uncompressed.resize(m_spec.height * m_spec.width);\n    // Note: the clear+resize zeroes out the buffer\n    bool ok = true;\n    int y = 0, x = 0;\n    while (ok) {\n        // Strutil::print(\"currently at {},{}\\n\", x, y);\n        unsigned char rle_pair[2];\n        if (!ioread(rle_pair, 2)) {\n            ok = false;\n            // Strutil::print(\"hit end of file at {},{}\\n\", x, y);\n            break;\n        }\n        if (y >= m_spec.height) {  // out of y bounds\n            errorfmt(\n                \"BMP might be corrupted, it is referencing an out-of-bounds pixel coordinte ({},{})\",\n                x, y);\n            ok = false;\n            break;\n        }\n        int npixels = rle_pair[0];\n        int value   = rle_pair[1];\n        if (npixels == 0 && value == 0) {\n            // [0,0] is end of line marker\n            x = 0;\n            ++y;\n            // Strutil::print(\"end of line, moving to {},{}\\n\", x, y);\n        } else if (npixels == 0 && value == 1) {\n            // [0,1] is end of bitmap marker\n            // Strutil::print(\"end of bitmap\\n\");\n            break;\n        } else if (npixels == 0 && value == 2) {\n            // [0,2] is a \"delta\" -- two more bytes reposition the\n            // current pixel position that we're reading.\n            unsigned char offset[2];\n            ok &= ioread(offset, 2);\n            x += offset[0];\n            y += offset[1];\n            // Strutil::print(\"offset by {:d},{:d} to {},{}\\n\", offset[0],\n            //                offset[1], x, y);\n        } else if (npixels == 0) {\n            // [0,n>2] is an \"absolute\" run of pixel data.\n            // n is the number of pixel indices that follow, but note\n            // that it pads to word size.\n            npixels    = value;\n            int nbytes = (rletype == 4)\n                             ? round_to_multiple((npixels + 1) / 2, 2)\n                             : round_to_multiple(npixels, 2);\n            // Strutil::print(\"rle of {} pixels at {},{}\\n\", npixels, x, y);\n            unsigned char absolute[256];\n            ok &= ioread(absolute, nbytes);\n            for (int i = 0; i < npixels; ++i, ++x) {\n                if (rletype == 4)\n                    value = (i & 1) ? (absolute[i / 2] & 0x0f)\n                                    : (absolute[i / 2] >> 4);\n                else\n                    value = absolute[i];\n                if (x < m_spec.width)\n                    m_uncompressed[y * m_spec.width + x] = value;\n            }\n        } else {\n            // [n>0,p] is a run of n pixels.\n            // Strutil::print(\"direct read {} pixels at {},{}\\n\", npixels, x, y);\n            for (int i = 0; i < npixels; ++i, ++x) {\n                int v;\n                if (rletype == 4)\n                    v = (i & 1) ? (value & 0x0f) : (value >> 4);\n                else\n                    v = value;\n                if (x < m_spec.width)\n                    m_uncompressed[y * m_spec.width + x] = v;\n            }\n        }\n    }\n    return ok;\n}",
  "abstract_func_before": "bool\nBmpInput::read_rle_image()\n{\n    int VAR_0 = VAR_1.compression == VAR_2 ? 4 : 8;\n    VAR_3.attribute(\"compression\", VAR_0 == 4 ? \"rle4\" : \"rle8\");\n    VAR_4.clear();\n    VAR_4.resize(VAR_3.height * VAR_3.width);\n    /* COMMENT_0 */\n    bool VAR_5 = true;\n    int VAR_6 = 0, VAR_7 = 0;\n    while (VAR_5) {\n        /* COMMENT_1 */\n        unsigned char VAR_8[2];\n        if (!ioread(VAR_8, 2)) {\n            VAR_5 = false;\n            /* COMMENT_2 */\n            break;\n        }\n        if (VAR_6 >= VAR_3.height) {  /* COMMENT_3 */\n            errorfmt(\n                \"BMP might be corrupted, it is referencing an out-of-bounds pixel coordinte ({},{})\",\n                VAR_7, VAR_6);\n            VAR_5 = false;\n            break;\n        }\n        int VAR_9 = VAR_8[0];\n        int VAR_10   = VAR_8[1];\n        if (VAR_9 == 0 && VAR_10 == 0) {\n            /* COMMENT_4 */\n            VAR_7 = 0;\n            ++VAR_6;\n            /* COMMENT_5 */\n        } else if (VAR_9 == 0 && VAR_10 == 1) {\n            /* COMMENT_6 */\n            /* COMMENT_7 */\n            break;\n        } else if (VAR_9 == 0 && VAR_10 == 2) {\n            /* COMMENT_8 */\n            /* COMMENT_9 */\n            unsigned char VAR_11[2];\n            VAR_5 &= ioread(VAR_11, 2);\n            VAR_7 += VAR_11[0];\n            VAR_6 += VAR_11[1];\n            /* COMMENT_10 */\n            /* COMMENT_11 */\n        } else if (VAR_9 == 0) {\n            /* COMMENT_12 */\n            /* COMMENT_13 */\n            /* COMMENT_14 */\n            VAR_9    = VAR_10;\n            int VAR_12 = (VAR_0 == 4)\n                             ? round_to_multiple((VAR_9 + 1) / 2, 2)\n                             : round_to_multiple(VAR_9, 2);\n            /* COMMENT_15 */\n            unsigned char VAR_13[256];\n            VAR_5 &= ioread(VAR_13, VAR_12);\n            for (int VAR_14 = 0; VAR_14 < VAR_9; ++VAR_14, ++VAR_7) {\n                if (VAR_0 == 4)\n                    VAR_10 = (VAR_14 & 1) ? (VAR_13[VAR_14 / 2] & 0x0f)\n                                    : (VAR_13[VAR_14 / 2] >> 4);\n                else\n                    VAR_10 = VAR_13[VAR_14];\n                if (VAR_7 < VAR_3.width)\n                    VAR_4[VAR_6 * VAR_3.width + VAR_7] = VAR_10;\n            }\n        } else {\n            /* COMMENT_16 */\n            /* COMMENT_17 */\n            for (int VAR_14 = 0; VAR_14 < VAR_9; ++VAR_14, ++VAR_7) {\n                int VAR_15;\n                if (VAR_0 == 4)\n                    VAR_15 = (VAR_14 & 1) ? (VAR_10 & 0x0f) : (VAR_10 >> 4);\n                else\n                    VAR_15 = VAR_10;\n                if (VAR_7 < VAR_3.width)\n                    VAR_4[VAR_6 * VAR_3.width + VAR_7] = VAR_15;\n            }\n        }\n    }\n    return VAR_5;\n}",
  "func_graph_path_before": "AcademySoftwareFoundation/OpenImageIO/85bb38216c09bcf77739c087753d6b80e21323db/bmpinput.cpp/vul/before/0.json",
  "func": "bool\nBmpInput::read_rle_image()\n{\n    int rletype = m_dib_header.compression == RLE4_COMPRESSION ? 4 : 8;\n    m_spec.attribute(\"compression\", rletype == 4 ? \"rle4\" : \"rle8\");\n    m_uncompressed.clear();\n    m_uncompressed.resize(m_spec.image_pixels());\n    // Note: the clear+resize zeroes out the buffer\n    bool ok = true;\n    int y = 0, x = 0;\n    while (ok) {\n        // Strutil::print(\"currently at {},{}\\n\", x, y);\n        unsigned char rle_pair[2];\n        if (!ioread(rle_pair, 2)) {\n            ok = false;\n            // Strutil::print(\"hit end of file at {},{}\\n\", x, y);\n            break;\n        }\n        if (y >= m_spec.height) {  // out of y bounds\n            errorfmt(\n                \"BMP might be corrupted, it is referencing an out-of-bounds pixel coordinte ({},{})\",\n                x, y);\n            ok = false;\n            break;\n        }\n        int npixels = rle_pair[0];\n        int value   = rle_pair[1];\n        if (npixels == 0 && value == 0) {\n            // [0,0] is end of line marker\n            x = 0;\n            ++y;\n            // Strutil::print(\"end of line, moving to {},{}\\n\", x, y);\n        } else if (npixels == 0 && value == 1) {\n            // [0,1] is end of bitmap marker\n            // Strutil::print(\"end of bitmap\\n\");\n            break;\n        } else if (npixels == 0 && value == 2) {\n            // [0,2] is a \"delta\" -- two more bytes reposition the\n            // current pixel position that we're reading.\n            unsigned char offset[2];\n            ok &= ioread(offset, 2);\n            x += offset[0];\n            y += offset[1];\n            // Strutil::print(\"offset by {:d},{:d} to {},{}\\n\", offset[0],\n            //                offset[1], x, y);\n        } else if (npixels == 0) {\n            // [0,n>2] is an \"absolute\" run of pixel data.\n            // n is the number of pixel indices that follow, but note\n            // that it pads to word size.\n            npixels    = value;\n            int nbytes = (rletype == 4)\n                             ? round_to_multiple((npixels + 1) / 2, 2)\n                             : round_to_multiple(npixels, 2);\n            // Strutil::print(\"rle of {} pixels at {},{}\\n\", npixels, x, y);\n            unsigned char absolute[256];\n            ok &= ioread(absolute, nbytes);\n            for (int i = 0; i < npixels; ++i, ++x) {\n                if (rletype == 4)\n                    value = (i & 1) ? (absolute[i / 2] & 0x0f)\n                                    : (absolute[i / 2] >> 4);\n                else\n                    value = absolute[i];\n                if (x < m_spec.width)\n                    m_uncompressed[y * m_spec.width + x] = value;\n            }\n        } else {\n            // [n>0,p] is a run of n pixels.\n            // Strutil::print(\"direct read {} pixels at {},{}\\n\", npixels, x, y);\n            for (int i = 0; i < npixels; ++i, ++x) {\n                int v;\n                if (rletype == 4)\n                    v = (i & 1) ? (value & 0x0f) : (value >> 4);\n                else\n                    v = value;\n                if (x < m_spec.width)\n                    m_uncompressed[y * m_spec.width + x] = v;\n            }\n        }\n    }\n    return ok;\n}",
  "abstract_func": "bool\nBmpInput::read_rle_image()\n{\n    int VAR_0 = VAR_1.compression == VAR_2 ? 4 : 8;\n    VAR_3.attribute(\"compression\", VAR_0 == 4 ? \"rle4\" : \"rle8\");\n    VAR_4.clear();\n    VAR_4.resize(VAR_3.image_pixels());\n    /* COMMENT_0 */\n    bool VAR_5 = true;\n    int VAR_6 = 0, VAR_7 = 0;\n    while (VAR_5) {\n        /* COMMENT_1 */\n        unsigned char VAR_8[2];\n        if (!ioread(VAR_8, 2)) {\n            VAR_5 = false;\n            /* COMMENT_2 */\n            break;\n        }\n        if (VAR_6 >= VAR_3.height) {  /* COMMENT_3 */\n            errorfmt(\n                \"BMP might be corrupted, it is referencing an out-of-bounds pixel coordinte ({},{})\",\n                VAR_7, VAR_6);\n            VAR_5 = false;\n            break;\n        }\n        int VAR_9 = VAR_8[0];\n        int VAR_10   = VAR_8[1];\n        if (VAR_9 == 0 && VAR_10 == 0) {\n            /* COMMENT_4 */\n            VAR_7 = 0;\n            ++VAR_6;\n            /* COMMENT_5 */\n        } else if (VAR_9 == 0 && VAR_10 == 1) {\n            /* COMMENT_6 */\n            /* COMMENT_7 */\n            break;\n        } else if (VAR_9 == 0 && VAR_10 == 2) {\n            /* COMMENT_8 */\n            /* COMMENT_9 */\n            unsigned char VAR_11[2];\n            VAR_5 &= ioread(VAR_11, 2);\n            VAR_7 += VAR_11[0];\n            VAR_6 += VAR_11[1];\n            /* COMMENT_10 */\n            /* COMMENT_11 */\n        } else if (VAR_9 == 0) {\n            /* COMMENT_12 */\n            /* COMMENT_13 */\n            /* COMMENT_14 */\n            VAR_9    = VAR_10;\n            int VAR_12 = (VAR_0 == 4)\n                             ? round_to_multiple((VAR_9 + 1) / 2, 2)\n                             : round_to_multiple(VAR_9, 2);\n            /* COMMENT_15 */\n            unsigned char VAR_13[256];\n            VAR_5 &= ioread(VAR_13, VAR_12);\n            for (int VAR_14 = 0; VAR_14 < VAR_9; ++VAR_14, ++VAR_7) {\n                if (VAR_0 == 4)\n                    VAR_10 = (VAR_14 & 1) ? (VAR_13[VAR_14 / 2] & 0x0f)\n                                    : (VAR_13[VAR_14 / 2] >> 4);\n                else\n                    VAR_10 = VAR_13[VAR_14];\n                if (VAR_7 < VAR_3.width)\n                    VAR_4[VAR_6 * VAR_3.width + VAR_7] = VAR_10;\n            }\n        } else {\n            /* COMMENT_16 */\n            /* COMMENT_17 */\n            for (int VAR_14 = 0; VAR_14 < VAR_9; ++VAR_14, ++VAR_7) {\n                int VAR_15;\n                if (VAR_0 == 4)\n                    VAR_15 = (VAR_14 & 1) ? (VAR_10 & 0x0f) : (VAR_10 >> 4);\n                else\n                    VAR_15 = VAR_10;\n                if (VAR_7 < VAR_3.width)\n                    VAR_4[VAR_6 * VAR_3.width + VAR_7] = VAR_15;\n            }\n        }\n    }\n    return VAR_5;\n}",
  "func_graph_path": "AcademySoftwareFoundation/OpenImageIO/85bb38216c09bcf77739c087753d6b80e21323db/bmpinput.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -4,7 +4,7 @@\n     int rletype = m_dib_header.compression == RLE4_COMPRESSION ? 4 : 8;\n     m_spec.attribute(\"compression\", rletype == 4 ? \"rle4\" : \"rle8\");\n     m_uncompressed.clear();\n-    m_uncompressed.resize(m_spec.height * m_spec.width);\n+    m_uncompressed.resize(m_spec.image_pixels());\n     // Note: the clear+resize zeroes out the buffer\n     bool ok = true;\n     int y = 0, x = 0;",
  "diff_line_info": {
    "deleted_lines": [
      "    m_uncompressed.resize(m_spec.height * m_spec.width);"
    ],
    "added_lines": [
      "    m_uncompressed.resize(m_spec.image_pixels());"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/AcademySoftwareFoundation/OpenImageIO/pull/3948",
  "description": {
    "pr_info": {
      "title": "fix runtime error: signed integer overflow in file src/bmp.imageio/bmpinput.cpp:302",
      "number": 3948
    },
    "comment": [
      "## Description\r\n\r\nfix #3947: runtime error: signed integer overflow in file src/bmp.imageio/bmpinput.cpp:302\r\n\r\n## Checklist:\r\n\r\n<!-- Put an 'x' in the boxes as you complete the checklist items -->\r\n\r\n- [Y] I have read the [contribution guidelines](https://github.com/OpenImageIO/oiio/blob/master/CONTRIBUTING.md).\r\n- [Y] My code follows the prevailing code style of this project.\r\n\r\n"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.9  \n\nThe patch addresses a runtime error caused by signed integer overflow, which is a critical bug fix but not a security vulnerability. The code modification ensures proper buffer size calculation, preventing undefined behavior without introducing security features. All information is clear, and the change is consistent with the description."
}