{
  "cve_id": "CVE-2018-5702",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "transmission",
  "commit_msg": "mitigate dns rebinding attacks against daemon",
  "commit_hash": "cf7173df930cfa7ac1b1b0e9027c1deffd0b3c84",
  "git_url": "https://github.com/transmission/transmission/commit/cf7173df930cfa7ac1b1b0e9027c1deffd0b3c84",
  "file_path": "libtransmission/rpc-server.c",
  "func_name": "tr_rpcSetWhitelist",
  "func_before": "void tr_rpcSetWhitelist(tr_rpc_server* server, char const* whitelistStr)\n{\n    void* tmp;\n\n    /* keep the string */\n    tmp = server->whitelistStr;\n    server->whitelistStr = tr_strdup(whitelistStr);\n    tr_free(tmp);\n\n    /* clear out the old whitelist entries */\n    while ((tmp = tr_list_pop_front(&server->whitelist)) != NULL)\n    {\n        tr_free(tmp);\n    }\n\n    /* build the new whitelist entries */\n    for (char const* walk = whitelistStr; walk != NULL && *walk != '\\0';)\n    {\n        char const* delimiters = \" ,;\";\n        size_t const len = strcspn(walk, delimiters);\n        char* token = tr_strndup(walk, len);\n\n        tr_list_append(&server->whitelist, token);\n\n        if (strcspn(token, \"+-\") < len)\n        {\n            tr_logAddNamedInfo(MY_NAME,\n                \"Adding address to whitelist: %s (And it has a '+' or '-'!  Are you using an old ACL by mistake?)\", token);\n        }\n        else\n        {\n            tr_logAddNamedInfo(MY_NAME, \"Adding address to whitelist: %s\", token);\n        }\n\n        walk += len;\n\n        if (*walk == '\\0')\n        {\n            break;\n        }\n\n        ++walk;\n    }\n}",
  "abstract_func_before": "void tr_rpcSetWhitelist(tr_rpc_server* VAR_0, char const* VAR_1)\n{\n    void* VAR_2;\n\n    /* COMMENT_0 */\n    VAR_2 = VAR_0->whitelistStr;\n    VAR_0->whitelistStr = tr_strdup(VAR_1);\n    tr_free(VAR_2);\n\n    /* COMMENT_1 */\n    while ((VAR_2 = tr_list_pop_front(&VAR_0->whitelist)) != NULL)\n    {\n        tr_free(VAR_2);\n    }\n\n    /* COMMENT_2 */\n    for (char const* VAR_3 = VAR_1; VAR_3 != NULL && *VAR_3 != '\\0';)\n    {\n        char const* VAR_4 = \" ,;\";\n        size_t const VAR_5 = strcspn(VAR_3, VAR_4);\n        char* VAR_6 = tr_strndup(VAR_3, VAR_5);\n\n        tr_list_append(&VAR_0->whitelist, VAR_6);\n\n        if (strcspn(VAR_6, \"+-\") < VAR_5)\n        {\n            tr_logAddNamedInfo(VAR_7,\n                \"Adding address to whitelist: %s (And it has a '+' or '-'!  Are you using an old ACL by mistake?)\", VAR_6);\n        }\n        else\n        {\n            tr_logAddNamedInfo(VAR_7, \"Adding address to whitelist: %s\", VAR_6);\n        }\n\n        VAR_3 += VAR_5;\n\n        if (*VAR_3 == '\\0')\n        {\n            break;\n        }\n\n        ++VAR_3;\n    }\n}",
  "func_graph_path_before": "transmission/cf7173df930cfa7ac1b1b0e9027c1deffd0b3c84/rpc-server.c/vul/before/0.json",
  "func": "void tr_rpcSetWhitelist(tr_rpc_server* server, char const* whitelistStr)\n{\n    /* keep the string */\n    char* const tmp = server->whitelistStr;\n    server->whitelistStr = tr_strdup(whitelistStr);\n    tr_free(tmp);\n\n    tr_rpcSetList(whitelistStr, &server->whitelist);\n}",
  "abstract_func": "void tr_rpcSetWhitelist(tr_rpc_server* VAR_0, char const* VAR_1)\n{\n    /* COMMENT_0 */\n    char* const VAR_2 = VAR_0->whitelistStr;\n    VAR_0->whitelistStr = tr_strdup(VAR_1);\n    tr_free(VAR_2);\n\n    tr_rpcSetList(VAR_1, &VAR_0->whitelist);\n}",
  "func_graph_path": "transmission/cf7173df930cfa7ac1b1b0e9027c1deffd0b3c84/rpc-server.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,44 +1,9 @@\n void tr_rpcSetWhitelist(tr_rpc_server* server, char const* whitelistStr)\n {\n-    void* tmp;\n-\n     /* keep the string */\n-    tmp = server->whitelistStr;\n+    char* const tmp = server->whitelistStr;\n     server->whitelistStr = tr_strdup(whitelistStr);\n     tr_free(tmp);\n \n-    /* clear out the old whitelist entries */\n-    while ((tmp = tr_list_pop_front(&server->whitelist)) != NULL)\n-    {\n-        tr_free(tmp);\n-    }\n-\n-    /* build the new whitelist entries */\n-    for (char const* walk = whitelistStr; walk != NULL && *walk != '\\0';)\n-    {\n-        char const* delimiters = \" ,;\";\n-        size_t const len = strcspn(walk, delimiters);\n-        char* token = tr_strndup(walk, len);\n-\n-        tr_list_append(&server->whitelist, token);\n-\n-        if (strcspn(token, \"+-\") < len)\n-        {\n-            tr_logAddNamedInfo(MY_NAME,\n-                \"Adding address to whitelist: %s (And it has a '+' or '-'!  Are you using an old ACL by mistake?)\", token);\n-        }\n-        else\n-        {\n-            tr_logAddNamedInfo(MY_NAME, \"Adding address to whitelist: %s\", token);\n-        }\n-\n-        walk += len;\n-\n-        if (*walk == '\\0')\n-        {\n-            break;\n-        }\n-\n-        ++walk;\n-    }\n+    tr_rpcSetList(whitelistStr, &server->whitelist);\n }",
  "diff_line_info": {
    "deleted_lines": [
      "    void* tmp;",
      "",
      "    tmp = server->whitelistStr;",
      "    /* clear out the old whitelist entries */",
      "    while ((tmp = tr_list_pop_front(&server->whitelist)) != NULL)",
      "    {",
      "        tr_free(tmp);",
      "    }",
      "",
      "    /* build the new whitelist entries */",
      "    for (char const* walk = whitelistStr; walk != NULL && *walk != '\\0';)",
      "    {",
      "        char const* delimiters = \" ,;\";",
      "        size_t const len = strcspn(walk, delimiters);",
      "        char* token = tr_strndup(walk, len);",
      "",
      "        tr_list_append(&server->whitelist, token);",
      "",
      "        if (strcspn(token, \"+-\") < len)",
      "        {",
      "            tr_logAddNamedInfo(MY_NAME,",
      "                \"Adding address to whitelist: %s (And it has a '+' or '-'!  Are you using an old ACL by mistake?)\", token);",
      "        }",
      "        else",
      "        {",
      "            tr_logAddNamedInfo(MY_NAME, \"Adding address to whitelist: %s\", token);",
      "        }",
      "",
      "        walk += len;",
      "",
      "        if (*walk == '\\0')",
      "        {",
      "            break;",
      "        }",
      "",
      "        ++walk;",
      "    }"
    ],
    "added_lines": [
      "    char* const tmp = server->whitelistStr;",
      "    tr_rpcSetList(whitelistStr, &server->whitelist);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/transmission/transmission/pull/468",
  "description": {
    "pr_info": {
      "title": "CVE-2018-5702: Mitigate dns rebinding attacks against daemon",
      "number": 468
    },
    "comment": [
      "_This [issue](https://bugs.chromium.org/p/project-zero/issues/detail?id=1447) was originally reported to the private transmission security list on November 30th 2017_\r\n\r\nTransmission uses a client/server architecture, the user interface is the client and a daemon runs in the background managing the downloading, seeding, etc.\r\n\r\nClients interact with the daemon using JSON RPC requests to a web server listening on port 9091. The daemon will only accept requests from localhost by default, but it's common to configure NAS devices to accept remote clients.\r\n\r\n**Note:** _I regularly encounter users who don't accept that websites can access services on localhost or their intranet. These users understand that services bound to localhost are only accessible to software running on the local machine, and that their browser is running on the local machine - but somehow believe that accessing a website \"transfers\" execution somewhere else. It doesn't work like that, but this is a common source of confusion._\r\n\r\nA sample RPC session looks like this:\r\n\r\n```\r\n$ curl -sI http://localhost:9091/transmission/rpc\r\nHTTP/1.1 409 Conflict\r\nServer: Transmission\r\nX-Transmission-Session-Id: JL641xTn2h53UsN6bVa0kJjRBLA6oX1Ayl06AJwuhHvSgE6H\r\nDate: Wed, 29 Nov 2017 21:37:41 GMT\r\n```\r\n```\r\n$ curl -H 'X-Transmission-Session-Id: JL641xTn2h53UsN6bVa0kJjRBLA6oX1Ayl06AJwuhHvSgE6H'  -d '{\"method\":\"session-set\",\"arguments\":{\"download-dir\":\"/home/user\"}}' -si http://localhost:9091/transmission/rpc\r\nHTTP/1.1 200 OK\r\nServer: Transmission\r\nContent-Type: application/json; charset=UTF-8\r\nDate: Wed, 29 Nov 2017 21:38:57 GMT\r\nContent-Length: 36\r\n\r\n{\"arguments\":{},\"result\":\"success\"}\r\n```\r\n\r\nAs with all HTTP RPC schemes like this, any website can send requests to the daemon listening on localhost with `XMLHttpRequest()`, but the theory is they will be ignored because clients must prove they can read and set a specific header, `X-Transmission-Session-Id`.\r\n\r\nUnfortunately, this design doesn't work because of an attack called \"[DNS rebinding](https://en.wikipedia.org/wiki/DNS_rebinding)\". Any website can simply create a dns name that they are authorized to communicate with, and then make it resolve to localhost.\r\n\r\nThe attack works like this:\r\n\r\n1. A user visits `http://attacker.com`, which has an `<iframe>` to a subdomain the attacker controls.\r\n2. The attacker configures their DNS server to respond alternately with `127.0.0.1` and `123.123.123.123` (an address they control) with a very low TTL.\r\n3. When the browser resolves to `123.123.123.123`, they serve HTML that waits for the DNS entry to expire (or force it to expire by flooding the cache with lookups), then they have permission to read and set headers.\r\n\r\nI have a domain I use for testing dns rebinding called `rbndr.us`, you can use this page to generate hostnames (source code is [here](https://github.com/taviso/rbndr)):\r\n\r\n[https://lock.cmpxchg8b.com/rebinder.html](https://lock.cmpxchg8b.com/rebinder.html)\r\n\r\nHere I want to alternate between `127.0.0.1` and `199.241.29.227`, so I use `7f000001.c7f11de3.rbndr.us`:\r\n\r\n```\r\n$ host 7f000001.c7f11de3.rbndr.us\r\n7f000001.c7f11de3.rbndr.us has address 127.0.0.1\r\n$ host 7f000001.c7f11de3.rbndr.us\r\n7f000001.c7f11de3.rbndr.us has address 199.241.29.227\r\n$ host 7f000001.c7f11de3.rbndr.us\r\n7f000001.c7f11de3.rbndr.us has address 127.0.0.1\r\n```\r\n\r\nHere you can see the resolution alternates between the two addresses I want (note that depending on caching it might take a while to switch, the TTL is set to minimum but some servers round up).\r\n\r\nI just wait for the cached response to expire, and then POST commands to the server.\r\n\r\nExploitation is simple, you could set `script-torrent-done-enabled` and run any command, or set `download-dir` to `/home/user/` and then upload a torrent for `.bashrc`. \r\n\r\nHere is my (simple) demo, it's slow, but could be made very fast:\r\n\r\n[http://lock.cmpxchg8b.com/Asoquu3e.html](http://lock.cmpxchg8b.com/Asoquu3e.html)\r\n\r\nI've verified it works on Chrome and Firefox on Windows and Linux (I tried Fedora and Ubuntu), I expect other platforms and browsers are affected. There are screenshots of how the attack is supposed to look below.\r\n\r\nThis Pull Request mitigates this attack by requiring a host whitelist for requests that cannot be proven to be secure, but it can be disabled if a user does not want security. I think users might not be find it intuitive that servers on `localhost` or their intranet are exposed to the web, but hopefully they will read the warning.\r\n\r\nHere are some screenshots demonstrating the attack:\r\n\r\nBefore the attack begins, the Download directory is set correctly:\r\n![fedora 64-bit-2017-11-29-16-25-19](https://user-images.githubusercontent.com/123814/34840911-5b671e56-f6bb-11e7-8c11-4e37d7a860bf.png) \r\n\r\nHere is how the exploit looks:\r\n![fedora 64-bit-2017-11-29-16-25-27](https://user-images.githubusercontent.com/123814/34840966-8c6cacc8-f6bb-11e7-86a5-5dd1c2423b01.png)\r\n\r\nHere is the exploit running:\r\n![fedora 64-bit-2017-11-29-16-25-48](https://user-images.githubusercontent.com/123814/34841014-a9b3c1fe-f6bb-11e7-934e-0fbdd815f395.png)\r\n\r\nThe attack succeeds:\r\n![fedora 64-bit-2017-11-29-16-30-12](https://user-images.githubusercontent.com/123814/34841025-b4018ed4-f6bb-11e7-8757-818b1f676106.png)\r\n\r\nAnd the result:\r\n![fedora 64-bit-2017-11-29-16-30-26](https://user-images.githubusercontent.com/123814/34841040-bdbc760a-f6bb-11e7-8bf5-3dcaf2aea922.png)\r\n",
      "I naively adapted the patch so it applies to the 2.92 release (attached).\r\n[transmission-fix-dns-rebinding-vuln.patch.txt](https://github.com/transmission/transmission/files/1624431/transmission-fix-dns-rebinding-vuln.patch.txt)\r\n\r\nAs the CI server shows, with these changes the ```quark-test``` fails with ```\r\nexit status: 29```.\r\n",
      "Has a CVE been assigned for this?",
      "I believe I've fixed the quark-test fail, the list wasn't ordered correctly.\r\n\r\n(I broke the merge, but I think it's fixed now)",
      "@woodsb02 No, but I've just requested one and will update when received.",
      "I've updated the 2.92 patch with the latest changes from @taviso. The tests do pass now.\r\n[transmission-fix-dns-rebinding-vuln.patch.txt](https://github.com/transmission/transmission/files/1624507/transmission-fix-dns-rebinding-vuln.patch.txt)\r\n",
      "@taviso the demo works, unless you load it over https. Mixed content. \r\n@EFForg HTTPS Everywhere ftw!;]",
      "@taviso and @lfam thank you.  I've adapted lfam's second 2.92 patch set to the OpenBSD port of transmission, which I maintain.  Testing underway.",
      "Just a naïve question for my own edification - this basically uses `Host` for header checking-based protection instead of relying on `X-Transmission-Session-Id`, because `Host` is a Fetch Standard [forbidden header name](https://fetch.spec.whatwg.org/#forbidden-header-name), and so not vulnerable to the same exploit, is that correct?",
      "@smithfred Yes, correct.",
      "If transmission is configured such that the daemon/web server requires authorization (user ID, password) does this mitigate this attack?",
      "@wfiveash Yes, but be aware that it's possible to guess the credentials, so make them strong.",
      "@jggimi Okay, let us know if you notice any problems.\r\n\r\nRemember I described my adaptation as \"naive\". I only made sure the patch applies and Transmission still works.",
      "In my setup, the settings.json file is re-written each time transmission-daemon is started, based on the command line arguments passed to it.\r\n\r\nCan we please add new command line arguments to transmission-daemon set the rpc-host-whitelist-enabled and rpc-host-whitelist parameters?",
      "cve requested at Mitre.org",
      "CVE-2018-5702",
      "> I've verified it works on Chrome and Firefox on Windows and Linux \r\n\r\nDoes this mean the MacOS version of Transmission isn't vulnerable, or just that you haven't tested it?",
      "@rmbleeker The macOS version is vulnerable if you have enabled [remote access](https://trac.transmissionbt.com/wiki/OSX/DesktopRemote).",
      "@slokhorst only if that is enabled? ",
      "@slokhorst Isn't the same true for linux distributions? Isn't the remote access disabled by default?\r\nI'm currently using Transmission 2.84 on Ubuntu 16.04.",
      "@OznipSlaugh yes\r\n\r\n@yanosh-k I believe remote access is disabled by default in all clients (Qt, GTK+, macOS). I think it's only enabled by default in the daemon (obviously...)\r\n\r\nYou can check if your vulnerable by going to http://localhost:9091/ If you then see the Transmission web interface, you're vulnerable.",
      "But what if the local DNS server supports [DNS Rebinding Protections](https://doc.pfsense.org/index.php/DNS_Rebinding_Protections) and all DNS traffic is forced through the local DNS server with that protection enabled. It seems in such a case that this hack is not applicable.",
      "Has the fix been applied to 2.92 and published to ubuntu repos? If I'm on 2.92 I'm safe, or do I have to wait 2.93?",
      "The [Ubuntu package](https://packages.ubuntu.com/artful/transmission) has not been updated [since 31 July 2017](http://changelogs.ubuntu.com/changelogs/pool/main/t/transmission/transmission_2.92-2ubuntu3/changelog), so it doesn't include this patch. \r\n\r\nI don't know if 2.93 will be released any time soon, there haven't been any Transmission releases for two years.",
      "Ah damn... I'll need to install the ppa I assume. I remember having troubles with that though",
      "You could also email the Ubuntu maintainers.. I'm sure they want to patch this. Maybe they've missed the CVE.",
      "Done, looks like patch has been backported to `2.84-3ubuntu3.1` on ubuntu and the package is already available.",
      "Great work here guys. I'd greatly appreciate it if someone made a follow-up PR to add support for IPv6 localhost address to the implicitly allowed list ;)",
      "@mikedld that's already covered by the bit below \"localhost or ipaddress is always acceptable.\" right?\r\n`tr_addressIsIP(hostname)` should return true for both `127.0.0.1` and `::1`.",
      "@slokhorst Oh, my apologies. For some reason it occured to me that the check allows 127.0.0.1 specifically and not any IP address :( Sorry for the noise.",
      "Thinking of it more, the use of `strcspn` is not ideal there. Given \"Host: [::1]:9091\", it'll return \"[\" as a name to be checked, and this is not a valid IP address. Will fix this myself in a bit."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix;  \n**Confidence:** 1.0"
}