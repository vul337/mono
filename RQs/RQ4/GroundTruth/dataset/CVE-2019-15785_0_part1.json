{
  "cve_id": "CVE-2019-15785",
  "cwe_ids": [
    "CWE-119"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "fontforge",
  "commit_msg": " Warn users before discarding their unsaved scripts (#3852)\n\n* Warn users before discarding their unsaved scripts\r\n\r\nThis closes #3846.",
  "commit_hash": "626f751752875a0ddd74b9e217b6f4828713573c",
  "git_url": "https://github.com/fontforge/fontforge/commit/626f751752875a0ddd74b9e217b6f4828713573c",
  "file_path": "gdraw/gtextfield.c",
  "func_name": "GTextFieldSave",
  "func_before": "static void GTextFieldSave(GTextField *gt,int utf8) {\n    unichar_t *ret;\n    char *cret;\n    FILE *file;\n    unichar_t *pt;\n\n    if ( _ggadget_use_gettext ) {\n\tchar *temp = GWidgetOpenFile8(_(\"Save\"),NULL,\"*.{txt,py}\",NULL,NULL);\n\tret = utf82u_copy(temp);\n\tfree(temp);\n    } else\n\tret = GWidgetSaveAsFile(GStringGetResource(_STR_Save,NULL),NULL,\n\t\ttxt,NULL,NULL);\n\n    if ( ret==NULL )\nreturn;\n    cret = u2def_copy(ret);\n    free(ret);\n    file = fopen(cret,\"w\");\n    if ( file==NULL ) {\n\tif ( _ggadget_use_gettext )\n\t    GWidgetError8(_(\"Could not open file\"), _(\"Could not open %.100s\"),cret);\n\telse\n\t    GWidgetError(errort,error,cret);\n\tfree(cret);\nreturn;\n    }\n    free(cret);\n\n    if ( utf8 ) {\n\tputc(0xef,file);\t\t/* Zero width something or other. Marks this as unicode, utf8 */\n\tputc(0xbb,file);\n\tputc(0xbf,file);\n\tfor ( pt = gt->text ; *pt; ++pt ) {\n\t    if ( *pt<0x80 )\n\t\tputc(*pt,file);\n\t    else if ( *pt<0x800 ) {\n\t\tputc(0xc0 | (*pt>>6), file);\n\t\tputc(0x80 | (*pt&0x3f), file);\n\t    } else if ( *pt>=0xd800 && *pt<0xdc00 && pt[1]>=0xdc00 && pt[1]<0xe000 ) {\n\t\tint u = ((*pt>>6)&0xf)+1, y = ((*pt&3)<<4) | ((pt[1]>>6)&0xf);\n\t\tputc( 0xf0 | (u>>2),file );\n\t\tputc( 0x80 | ((u&3)<<4) | ((*pt>>2)&0xf),file );\n\t\tputc( 0x80 | y,file );\n\t\tputc( 0x80 | (pt[1]&0x3f),file );\n\t    } else {\n\t\tputc( 0xe0 | (*pt>>12),file );\n\t\tputc( 0x80 | ((*pt>>6)&0x3f),file );\n\t\tputc( 0x80 | (*pt&0x3f),file );\n\t    }\n\t}\n    } else {\n\tputc(0xfeff>>8,file);\t\t/* Zero width something or other. Marks this as unicode */\n\tputc(0xfeff&0xff,file);\n\tfor ( pt = gt->text ; *pt; ++pt ) {\n\t    putc(*pt>>8,file);\n\t    putc(*pt&0xff,file);\n\t}\n    }\n    fclose(file);\n}",
  "abstract_func_before": "static void GTextFieldSave(GTextField *VAR_0,int VAR_1) {\n    unichar_t *VAR_2;\n    char *VAR_3;\n    FILE *VAR_4;\n    unichar_t *VAR_5;\n\n    if ( VAR_6 ) {\n\tchar *VAR_7 = GWidgetOpenFile8(_(\"Save\"),NULL,\"*.{txt,py}\",NULL,NULL);\n\tVAR_2 = utf82u_copy(VAR_7);\n\tfree(VAR_7);\n    } else\n\tVAR_2 = GWidgetSaveAsFile(GStringGetResource(VAR_8,NULL),NULL,\n\t\tVAR_9,NULL,NULL);\n\n    if ( VAR_2==NULL )\nreturn;\n    VAR_3 = u2def_copy(VAR_2);\n    free(VAR_2);\n    VAR_4 = fopen(VAR_3,\"w\");\n    if ( VAR_4==NULL ) {\n\tif ( VAR_6 )\n\t    GWidgetError8(_(\"Could not open file\"), _(\"Could not open %.100s\"),VAR_3);\n\telse\n\t    GWidgetError(VAR_10,VAR_11,VAR_3);\n\tfree(VAR_3);\nreturn;\n    }\n    free(VAR_3);\n\n    if ( VAR_1 ) {\n\tputc(0xef,VAR_4);\t\t/* COMMENT_0 */\n\tputc(0xbb,VAR_4);\n\tputc(0xbf,VAR_4);\n\tfor ( VAR_5 = VAR_0->text ; *VAR_5; ++VAR_5 ) {\n\t    if ( *VAR_5<0x80 )\n\t\tputc(*VAR_5,VAR_4);\n\t    else if ( *VAR_5<0x800 ) {\n\t\tputc(0xc0 | (*VAR_5>>6), VAR_4);\n\t\tputc(0x80 | (*VAR_5&0x3f), VAR_4);\n\t    } else if ( *VAR_5>=0xd800 && *VAR_5<0xdc00 && VAR_5[1]>=0xdc00 && VAR_5[1]<0xe000 ) {\n\t\tint VAR_12 = ((*VAR_5>>6)&0xf)+1, VAR_13 = ((*VAR_5&3)<<4) | ((VAR_5[1]>>6)&0xf);\n\t\tputc( 0xf0 | (VAR_12>>2),VAR_4 );\n\t\tputc( 0x80 | ((VAR_12&3)<<4) | ((*VAR_5>>2)&0xf),VAR_4 );\n\t\tputc( 0x80 | VAR_13,VAR_4 );\n\t\tputc( 0x80 | (VAR_5[1]&0x3f),VAR_4 );\n\t    } else {\n\t\tputc( 0xe0 | (*VAR_5>>12),VAR_4 );\n\t\tputc( 0x80 | ((*VAR_5>>6)&0x3f),VAR_4 );\n\t\tputc( 0x80 | (*VAR_5&0x3f),VAR_4 );\n\t    }\n\t}\n    } else {\n\tputc(0xfeff>>8,VAR_4);\t\t/* COMMENT_1 */\n\tputc(0xfeff&0xff,VAR_4);\n\tfor ( VAR_5 = VAR_0->text ; *VAR_5; ++VAR_5 ) {\n\t    putc(*VAR_5>>8,VAR_4);\n\t    putc(*VAR_5&0xff,VAR_4);\n\t}\n    }\n    fclose(VAR_4);\n}",
  "func_graph_path_before": "fontforge/626f751752875a0ddd74b9e217b6f4828713573c/gtextfield.c/vul/before/0.json",
  "func": "static void GTextFieldSave(GTextField *gt,int utf8) {\n    unichar_t *ret;\n    char *cret;\n    FILE *file;\n    unichar_t *pt;\n\n    if ( _ggadget_use_gettext ) {\n\tchar *temp = GWidgetOpenFile8(_(\"Save\"),NULL,\"*.{txt,py}\",NULL,NULL);\n\tret = utf82u_copy(temp);\n\tfree(temp);\n    } else\n\tret = GWidgetSaveAsFile(GStringGetResource(_STR_Save,NULL),NULL,\n\t\ttxt,NULL,NULL);\n\n    if ( ret==NULL )\nreturn;\n    cret = u2def_copy(ret);\n    free(ret);\n    file = fopen(cret,\"w\");\n    if ( file==NULL ) {\n\tif ( _ggadget_use_gettext )\n\t    GWidgetError8(_(\"Could not open file\"), _(\"Could not open %.100s\"),cret);\n\telse\n\t    GWidgetError(errort,error,cret);\n\tfree(cret);\nreturn;\n    }\n    free(cret);\n\n    if ( utf8 ) {\n\tputc(0xef,file);\t\t/* Zero width something or other. Marks this as unicode, utf8 */\n\tputc(0xbb,file);\n\tputc(0xbf,file);\n\tfor ( pt = gt->text ; *pt; ++pt ) {\n\t    if ( *pt<0x80 )\n\t\tputc(*pt,file);\n\t    else if ( *pt<0x800 ) {\n\t\tputc(0xc0 | (*pt>>6), file);\n\t\tputc(0x80 | (*pt&0x3f), file);\n\t    } else if ( *pt>=0xd800 && *pt<0xdc00 && pt[1]>=0xdc00 && pt[1]<0xe000 ) {\n\t\tint u = ((*pt>>6)&0xf)+1, y = ((*pt&3)<<4) | ((pt[1]>>6)&0xf);\n\t\tputc( 0xf0 | (u>>2),file );\n\t\tputc( 0x80 | ((u&3)<<4) | ((*pt>>2)&0xf),file );\n\t\tputc( 0x80 | y,file );\n\t\tputc( 0x80 | (pt[1]&0x3f),file );\n\t    } else {\n\t\tputc( 0xe0 | (*pt>>12),file );\n\t\tputc( 0x80 | ((*pt>>6)&0x3f),file );\n\t\tputc( 0x80 | (*pt&0x3f),file );\n\t    }\n\t}\n    } else {\n\tputc(0xfeff>>8,file);\t\t/* Zero width something or other. Marks this as unicode */\n\tputc(0xfeff&0xff,file);\n\tfor ( pt = gt->text ; *pt; ++pt ) {\n\t    putc(*pt>>8,file);\n\t    putc(*pt&0xff,file);\n\t}\n    }\n    fclose(file);\n    GTextFieldSaved(gt);\n}",
  "abstract_func": "static void GTextFieldSave(GTextField *VAR_0,int VAR_1) {\n    unichar_t *VAR_2;\n    char *VAR_3;\n    FILE *VAR_4;\n    unichar_t *VAR_5;\n\n    if ( VAR_6 ) {\n\tchar *VAR_7 = GWidgetOpenFile8(_(\"Save\"),NULL,\"*.{txt,py}\",NULL,NULL);\n\tVAR_2 = utf82u_copy(VAR_7);\n\tfree(VAR_7);\n    } else\n\tVAR_2 = GWidgetSaveAsFile(GStringGetResource(VAR_8,NULL),NULL,\n\t\tVAR_9,NULL,NULL);\n\n    if ( VAR_2==NULL )\nreturn;\n    VAR_3 = u2def_copy(VAR_2);\n    free(VAR_2);\n    VAR_4 = fopen(VAR_3,\"w\");\n    if ( VAR_4==NULL ) {\n\tif ( VAR_6 )\n\t    GWidgetError8(_(\"Could not open file\"), _(\"Could not open %.100s\"),VAR_3);\n\telse\n\t    GWidgetError(VAR_10,VAR_11,VAR_3);\n\tfree(VAR_3);\nreturn;\n    }\n    free(VAR_3);\n\n    if ( VAR_1 ) {\n\tputc(0xef,VAR_4);\t\t/* COMMENT_0 */\n\tputc(0xbb,VAR_4);\n\tputc(0xbf,VAR_4);\n\tfor ( VAR_5 = VAR_0->text ; *VAR_5; ++VAR_5 ) {\n\t    if ( *VAR_5<0x80 )\n\t\tputc(*VAR_5,VAR_4);\n\t    else if ( *VAR_5<0x800 ) {\n\t\tputc(0xc0 | (*VAR_5>>6), VAR_4);\n\t\tputc(0x80 | (*VAR_5&0x3f), VAR_4);\n\t    } else if ( *VAR_5>=0xd800 && *VAR_5<0xdc00 && VAR_5[1]>=0xdc00 && VAR_5[1]<0xe000 ) {\n\t\tint VAR_12 = ((*VAR_5>>6)&0xf)+1, VAR_13 = ((*VAR_5&3)<<4) | ((VAR_5[1]>>6)&0xf);\n\t\tputc( 0xf0 | (VAR_12>>2),VAR_4 );\n\t\tputc( 0x80 | ((VAR_12&3)<<4) | ((*VAR_5>>2)&0xf),VAR_4 );\n\t\tputc( 0x80 | VAR_13,VAR_4 );\n\t\tputc( 0x80 | (VAR_5[1]&0x3f),VAR_4 );\n\t    } else {\n\t\tputc( 0xe0 | (*VAR_5>>12),VAR_4 );\n\t\tputc( 0x80 | ((*VAR_5>>6)&0x3f),VAR_4 );\n\t\tputc( 0x80 | (*VAR_5&0x3f),VAR_4 );\n\t    }\n\t}\n    } else {\n\tputc(0xfeff>>8,VAR_4);\t\t/* COMMENT_1 */\n\tputc(0xfeff&0xff,VAR_4);\n\tfor ( VAR_5 = VAR_0->text ; *VAR_5; ++VAR_5 ) {\n\t    putc(*VAR_5>>8,VAR_4);\n\t    putc(*VAR_5&0xff,VAR_4);\n\t}\n    }\n    fclose(VAR_4);\n    GTextFieldSaved(VAR_0);\n}",
  "func_graph_path": "fontforge/626f751752875a0ddd74b9e217b6f4828713573c/gtextfield.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -58,4 +58,5 @@\n \t}\n     }\n     fclose(file);\n+    GTextFieldSaved(gt);\n }",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "    GTextFieldSaved(gt);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/fontforge/fontforge/pull/3852",
  "description": {
    "pr_info": {
      "title": " Warn users before discarding their unsaved scripts",
      "number": 3852
    },
    "comment": [
      "This closes #3846.\r\n\r\nI know, I could have written ten scripts or more in the time it took me to do this.\r\n\r\nI hate losing my work. I had a pretty cool FontForge script, and I lost it on accident. I hate that. Yes I could do it again ten times in the time it took me to write this feature, but I'd rather never lose work than have to redo work once.",
      "Some knee-jerk reactions, without looking too closely:\r\n\r\n* Surely there's a way to do this without script hashing\r\n* If we absolutely had to, don't add hashing to gutils, use [glib](https://developer.gnome.org/glib/stable/glib-Data-Checksums.htm)\r\n",
      "Other ways aren't as robust as this, and I definitely need hashing for my WIP SFDRefer branch. I'll look into glib in a half hour. I thought I made sure none of our dependencies could do this, but I may have missed something",
      "Surely you can just set a boolean to flag that there is an unsaved script, I'm still not seeing what the purpose of hashing is.",
      "Because of the way gdraw works and because it's possible to save the script, then change it, then close the dialog. So saving it can't unset the flag and then closing it will set the flag.\r\n\r\nI had to add a new `et_save` event just for this, as well.\r\n\r\nWe need to put our \"script changed\" fn after `GDrawProcessOneEvent`, so that no matter how the window is closed, it will work. We can't put it in `et_close`, that's only for the close button, it won't work if OK/Cancel pressed&mdash;we can't make `SD_Cancel` post the event `et_close`, that causes an infinite loop.",
      "It still sounds like the wrong approach to me. \r\n\r\nLet me clarify your workflow. You're saying that in the 'Execute script' window, you want to warn if there's an unsaved script (saving via a right click->Save in UTF8).\r\n\r\nSupposing you had that `et_save` event (also not sure if this is appropriate, but let's go with this for now).\r\n\r\nWhy can't you just say extend `sd_data` with a dirty flag, which you set whenever the contents of the window changes, and unset whenever `et_save` is received? You can then propagate that as appropriate.",
      "Because after et_save is triggered the contents can change. I can et_save then write something else then close the window.\r\n\r\nIf I have no way of knowing whether or not the contents changed since the last save but before the last close, I either have to (a) always assume they have or (b) always assume they haven't, neither of which is always going to be correct.",
      "> Because after et_save is triggered the contents can change. \r\n\r\nThat's my point. An `et_save` occurs, you clear the flag. You receive an `et_charup` or whatever, changing the window contents. You set the flag again.",
      "No matter what the data type is I think it has to go on the FontView btw. `sd_data` isn't accessible by fontview.c, I think, and it needs it to do the warning when we're closing the window.",
      "Well, I didn't think of et_charup, I was putting the hash (or flag set or w/e) when the window was closed. I guess et_charup should  work :-)",
      "Yeah, I suggested `sd_data` but you can propagate that as needed to the FontView. You'll probably need to look into `et_controlevent`, from a super quick skim.",
      "That event is confusingly named. Do you know its intended purpose? I thought it's maybe for like shift, alt, and ctl keys",
      "Not sure, it's probably something to do with ggagdet interaction, since iirc technically it's the gtextfield that gets the key events.",
      "I'd still prefer hashes. What if they accidentally type something then backspace it?",
      "Maybe that's a rare event, but is it really that rare? To try something after saving, find it doesn't work, then delete it again and close the window?",
      "I'm happy to use libglib (makes it easier to use a stronger hash like SHA256) instead of the 1999 MD5 implementation I vendorized, but I'd like to keep hashes for this feature.",
      "No, I just don't think hashing is required for this. Maybe for something else, but not this.\r\n\r\nIf you backspace, that still counts as the contents changing and you should be able to detect that. Some suggestions for prior work, see how the word list parser in the charview detects that it needs to update the charview, or even the same thing for the metrics window ",
      "But the contents haven't changed. Consider the following flow of events:\r\n\r\n* User opens window\r\n* User types `print(\"H\")` - flag gets set on first char `p` et_charup\r\n* User executes\r\n* User saves - et_save - flag unset\r\n* User changes `print` to `prlint` - flag gets set on char `l` et_charup\r\n* User executes\r\n* User deletes the `l` - flag still set\r\n* Contents unchanged, user closes window\r\n* Erroneous error message about unsaved script",
      "I don't think that matters, it's a heuristic. And that behaviour you just described is how all text editors work. ",
      "I'm sure I could find one that uses hashes :-P\r\n\r\nBesides, most text editors correctly understand \"Undo\" and keep a list of states, so it's more likely in a real text editor you'd undo, not delete the l",
      "In this case using hashes is like throwing a hammer at the problem; it's just plain inefficient when you're already able to track if changes have been made.\r\n\r\n> I'm sure I could find one that uses hashes :-P\r\n\r\nPlease do :) ",
      "*checks Kate, vim, Geany...*\r\n*nope...*\r\n\r\nOK, you win, I'll remove the hashing.",
      "I think this is ready now :-)",
      "Hey Jeremy, sorry, I've had a hard time focusing due to the recent mass shooting in Texas, I unfortunately have the crappy position of being the guy people email whenever 8chan is in the news, even though I haven't had anything to do with it for four years in April. I should be able to get to clear up your other comments in the next few hours, and if not then, then tomorrow.",
      "Bump"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.9\n\n**Explanation:** The commit introduces a warning system to prevent users from losing unsaved work, enhancing user experience without addressing security issues. The code change consistently implements this feature, clearly indicating a non-security fix."
}