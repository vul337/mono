{
  "cve_id": "CVE-2021-42553",
  "cwe_ids": [
    "CWE-120"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "STMicroelectronics/stm32_mw_usb_host",
  "commit_msg": "Fix buffer overflow\n\nIn case the descriptor contains more endpoints than USBH_MAX_NUM_ENDPOINTS the Ep_Desc array and subsequent members of USBH_HandleTypeDef that contains function pointers are overwritten allowing arbitrary code execution.",
  "commit_hash": "15c4631397bb61bcbf0dae7f46ddcad1bd26c86f",
  "git_url": "https://github.com/STMicroelectronics/stm32_mw_usb_host/commit/15c4631397bb61bcbf0dae7f46ddcad1bd26c86f",
  "file_path": "Core/Src/usbh_ctlreq.c",
  "func_name": "USBH_ParseInterfaceDesc",
  "func_before": "static void  USBH_ParseInterfaceDesc(USBH_InterfaceDescTypeDef *if_descriptor,\n                                     uint8_t *buf)\n{\n  if_descriptor->bLength            = *(uint8_t *)(buf + 0);\n  if_descriptor->bDescriptorType    = *(uint8_t *)(buf + 1);\n  if_descriptor->bInterfaceNumber   = *(uint8_t *)(buf + 2);\n  if_descriptor->bAlternateSetting  = *(uint8_t *)(buf + 3);\n  if_descriptor->bNumEndpoints      = *(uint8_t *)(buf + 4);\n  if_descriptor->bInterfaceClass    = *(uint8_t *)(buf + 5);\n  if_descriptor->bInterfaceSubClass = *(uint8_t *)(buf + 6);\n  if_descriptor->bInterfaceProtocol = *(uint8_t *)(buf + 7);\n  if_descriptor->iInterface         = *(uint8_t *)(buf + 8);\n}",
  "abstract_func_before": "static void  USBH_ParseInterfaceDesc(USBH_InterfaceDescTypeDef *VAR_0,\n                                     uint8_t *VAR_1)\n{\n  VAR_0->bLength            = *(uint8_t *)(VAR_1 + 0);\n  VAR_0->bDescriptorType    = *(uint8_t *)(VAR_1 + 1);\n  VAR_0->bInterfaceNumber   = *(uint8_t *)(VAR_1 + 2);\n  VAR_0->bAlternateSetting  = *(uint8_t *)(VAR_1 + 3);\n  VAR_0->bNumEndpoints      = *(uint8_t *)(VAR_1 + 4);\n  VAR_0->bInterfaceClass    = *(uint8_t *)(VAR_1 + 5);\n  VAR_0->bInterfaceSubClass = *(uint8_t *)(VAR_1 + 6);\n  VAR_0->bInterfaceProtocol = *(uint8_t *)(VAR_1 + 7);\n  VAR_0->iInterface         = *(uint8_t *)(VAR_1 + 8);\n}",
  "func_graph_path_before": "STMicroelectronics/stm32_mw_usb_host/15c4631397bb61bcbf0dae7f46ddcad1bd26c86f/usbh_ctlreq.c/vul/before/0.json",
  "func": "static void  USBH_ParseInterfaceDesc(USBH_InterfaceDescTypeDef *if_descriptor,\n                                     uint8_t *buf)\n{\n  if_descriptor->bLength            = *(uint8_t *)(buf + 0);\n  if_descriptor->bDescriptorType    = *(uint8_t *)(buf + 1);\n  if_descriptor->bInterfaceNumber   = *(uint8_t *)(buf + 2);\n  if_descriptor->bAlternateSetting  = *(uint8_t *)(buf + 3);\n  if_descriptor->bNumEndpoints      = MIN(*(uint8_t *)(buf + 4), USBH_MAX_NUM_ENDPOINTS);\n  if_descriptor->bInterfaceClass    = *(uint8_t *)(buf + 5);\n  if_descriptor->bInterfaceSubClass = *(uint8_t *)(buf + 6);\n  if_descriptor->bInterfaceProtocol = *(uint8_t *)(buf + 7);\n  if_descriptor->iInterface         = *(uint8_t *)(buf + 8);\n}",
  "abstract_func": "static void  USBH_ParseInterfaceDesc(USBH_InterfaceDescTypeDef *VAR_0,\n                                     uint8_t *VAR_1)\n{\n  VAR_0->bLength            = *(uint8_t *)(VAR_1 + 0);\n  VAR_0->bDescriptorType    = *(uint8_t *)(VAR_1 + 1);\n  VAR_0->bInterfaceNumber   = *(uint8_t *)(VAR_1 + 2);\n  VAR_0->bAlternateSetting  = *(uint8_t *)(VAR_1 + 3);\n  VAR_0->bNumEndpoints      = MIN(*(uint8_t *)(VAR_1 + 4), VAR_2);\n  VAR_0->bInterfaceClass    = *(uint8_t *)(VAR_1 + 5);\n  VAR_0->bInterfaceSubClass = *(uint8_t *)(VAR_1 + 6);\n  VAR_0->bInterfaceProtocol = *(uint8_t *)(VAR_1 + 7);\n  VAR_0->iInterface         = *(uint8_t *)(VAR_1 + 8);\n}",
  "func_graph_path": "STMicroelectronics/stm32_mw_usb_host/15c4631397bb61bcbf0dae7f46ddcad1bd26c86f/usbh_ctlreq.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,7 @@\n   if_descriptor->bDescriptorType    = *(uint8_t *)(buf + 1);\n   if_descriptor->bInterfaceNumber   = *(uint8_t *)(buf + 2);\n   if_descriptor->bAlternateSetting  = *(uint8_t *)(buf + 3);\n-  if_descriptor->bNumEndpoints      = *(uint8_t *)(buf + 4);\n+  if_descriptor->bNumEndpoints      = MIN(*(uint8_t *)(buf + 4), USBH_MAX_NUM_ENDPOINTS);\n   if_descriptor->bInterfaceClass    = *(uint8_t *)(buf + 5);\n   if_descriptor->bInterfaceSubClass = *(uint8_t *)(buf + 6);\n   if_descriptor->bInterfaceProtocol = *(uint8_t *)(buf + 7);",
  "diff_line_info": {
    "deleted_lines": [
      "  if_descriptor->bNumEndpoints      = *(uint8_t *)(buf + 4);"
    ],
    "added_lines": [
      "  if_descriptor->bNumEndpoints      = MIN(*(uint8_t *)(buf + 4), USBH_MAX_NUM_ENDPOINTS);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/STMicroelectronics/stm32-mw-usb-host/pull/4",
  "description": {
    "pr_info": {
      "title": "Fix buffer overflow",
      "number": 4
    },
    "comment": [
      "In case the descriptor contains more endpoints than USBH_MAX_NUM_ENDPOINTS the Ep_Desc array and subsequent members of USBH_HandleTypeDef that contains function pointers are overwritten allowing arbitrary code execution.\r\n\r\n## IMPORTANT INFORMATION\r\n\r\n### Contributor License Agreement (CLA)\r\n* The Pull Request feature will be considered by STMicroelectronics after the signature of a **Contributor License Agreement (CLA)** by the submitter.\r\n* If you did not sign such agreement, please follow the steps mentioned in the [CONTRIBUTING.md](https://github.com/STMicroelectronics/stm32_mw_usb_host/blob/master/CONTRIBUTING.md) file.\r\n",
      "Hi @Defonceuse,\r\n\r\nThank you for this fix proposal. The point will be forwarded to our development teams. I will get back to you as soon as I have their feedback.\r\n\r\nMay I ask you whether you noticed the point just by reviewing the code or whether you actually experienced a failure due to this implementation? Thank you in advance for your reply.\r\n\r\nWith regards,",
      "Hi @ALABSTM ,\r\nAt the Swiss NCSC (National Cybersecurity Center), we have been contacted by the original reporter in January 2022 to assign a CVE number for this issue. \r\n\r\nWe were unable to get a security contact at your company via other channels, please contact us at vulnerability@ncsc.ch so we can discuss this case. ",
      "Hi @ncsc-ch-vuln-mgmt,\r\n\r\nYour request has been forwarded internally. I will get back to you as soon as I have an answer.\r\n\r\nWith regards,",
      "Hi @ALABSTM,\r\n\r\nSorry for the delay, I overlooked your question.\r\n\r\n> May I ask you whether you noticed the point just by reviewing the code or whether you actually experienced a failure due to this implementation? Thank you in advance for your reply.\r\n\r\nI became aware of the problem when I connected a USB Mass Storage device that has more than USBH_MAX_NUM_ENDPOINTS and an exception handler was immediately triggered.\r\n\r\nI did not review the code as it was treated as third party code. Had it been reviewed the vulnerability would likely become obvious when checking for the coding rule that array indexes must be range-checked before use in case it is received from an external/untrusted source.\r\n\r\nKind regards,",
      "It was missed to merge this important vulnerability fix into recent releases. Please confirm to merge into the upcoming release.",
      "Hi, \r\nAs this vulnerability has been open and publicly documented for a while,and since we did not get feedback from the vendor we have issued a CVE at the finders request CVE-2021-42553 https://www.cve.org/CVERecord?id=CVE-2021-42553",
      "Release v3.5.1 addresses CVE-2021-42553",
      "Hi @Defonceuse,\r\n\r\nReally sorry for this delay.  Your pull-request has just been merged. Thank you very much for your contribution. Looking forward to receiving other ones.\r\n\r\nWith regards,",
      "Hi @ncsc-ch-vuln-mgmt,\r\n\r\nReally sorry for this delay too. Thank you very much for the notification about the CVE identifier creation.\r\n\r\nA `SECURITY.md` file (like [this](https://github.com/STMicroelectronics/STM32CubeC0/blob/main/SECURITY.md) one) will be uploaded into this repository that will provide users with the contact info in case they have detected any vulnerability related to security aspects.\r\n\r\nWith regards,"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}