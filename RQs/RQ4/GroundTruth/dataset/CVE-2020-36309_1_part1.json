{
  "cve_id": "CVE-2020-36309",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "openresty/lua-nginx-module",
  "commit_msg": "bugfix: ensured arguments of APIs mutating uri or request/response headers do not contain unsafe characters.\n\nSigned-off-by: Thibault Charbonnier <thibaultcha@me.com>",
  "commit_hash": "041d7d1c8539f92062c2a79cf18f550542bccc2e",
  "git_url": "https://github.com/openresty/lua-nginx-module/commit/041d7d1c8539f92062c2a79cf18f550542bccc2e",
  "file_path": "src/ngx_http_lua_headers_out.c",
  "func_name": "ngx_http_lua_set_output_header",
  "func_before": "ngx_int_t\nngx_http_lua_set_output_header(ngx_http_request_t *r, ngx_http_lua_ctx_t *ctx,\n    ngx_str_t key, ngx_str_t value, unsigned override)\n{\n    ngx_http_lua_header_val_t         hv;\n    ngx_http_lua_set_header_t        *handlers = ngx_http_lua_set_handlers;\n    ngx_uint_t                        i;\n\n    dd(\"set header value: %.*s\", (int) value.len, value.data);\n\n    key.len = ngx_http_lua_safe_header_value_len(key.data, key.len);\n\n    value.len = ngx_http_lua_safe_header_value_len(value.data, value.len);\n\n    hv.hash = ngx_hash_key_lc(key.data, key.len);\n    hv.key = key;\n\n    hv.offset = 0;\n    hv.no_override = !override;\n    hv.handler = NULL;\n\n    for (i = 0; handlers[i].name.len; i++) {\n        if (hv.key.len != handlers[i].name.len\n            || ngx_strncasecmp(hv.key.data, handlers[i].name.data,\n                               handlers[i].name.len) != 0)\n        {\n            dd(\"hv key comparison: %s <> %s\", handlers[i].name.data,\n               hv.key.data);\n\n            continue;\n        }\n\n        dd(\"Matched handler: %s %s\", handlers[i].name.data, hv.key.data);\n\n        hv.offset = handlers[i].offset;\n        hv.handler = handlers[i].handler;\n\n        if (hv.handler == ngx_http_set_content_type_header) {\n            ctx->mime_set = 1;\n        }\n\n        break;\n    }\n\n    if (handlers[i].name.len == 0 && handlers[i].handler) {\n        hv.offset = handlers[i].offset;\n        hv.handler = handlers[i].handler;\n    }\n\n#if 1\n    if (hv.handler == NULL) {\n        return NGX_ERROR;\n    }\n#endif\n\n    return hv.handler(r, &hv, &value);\n}",
  "abstract_func_before": "ngx_int_t\nngx_http_lua_set_output_header(ngx_http_request_t *VAR_0, ngx_http_lua_ctx_t *VAR_1,\n    ngx_str_t VAR_2, ngx_str_t VAR_3, unsigned VAR_4)\n{\n    ngx_http_lua_header_val_t         VAR_5;\n    ngx_http_lua_set_header_t        *VAR_6 = VAR_7;\n    ngx_uint_t                        VAR_8;\n\n    dd(\"set header value: %.*s\", (int) VAR_3.len, VAR_3.data);\n\n    VAR_2.len = ngx_http_lua_safe_header_value_len(VAR_2.data, VAR_2.len);\n\n    VAR_3.len = ngx_http_lua_safe_header_value_len(VAR_3.data, VAR_3.len);\n\n    VAR_5.hash = ngx_hash_key_lc(VAR_2.data, VAR_2.len);\n    VAR_5.key = VAR_2;\n\n    VAR_5.offset = 0;\n    VAR_5.no_override = !VAR_4;\n    VAR_5.handler = NULL;\n\n    for (VAR_8 = 0; VAR_6[VAR_8].name.len; VAR_8++) {\n        if (VAR_5.key.len != VAR_6[VAR_8].name.len\n            || ngx_strncasecmp(VAR_5.key.data, VAR_6[VAR_8].name.data,\n                               VAR_6[VAR_8].name.len) != 0)\n        {\n            dd(\"hv key comparison: %s <> %s\", VAR_6[VAR_8].name.data,\n               VAR_5.key.data);\n\n            continue;\n        }\n\n        dd(\"Matched handler: %s %s\", VAR_6[VAR_8].name.data, VAR_5.key.data);\n\n        VAR_5.offset = VAR_6[VAR_8].offset;\n        VAR_5.handler = VAR_6[VAR_8].handler;\n\n        if (VAR_5.handler == VAR_9) {\n            VAR_1->mime_set = 1;\n        }\n\n        break;\n    }\n\n    if (VAR_6[VAR_8].name.len == 0 && VAR_6[VAR_8].handler) {\n        VAR_5.offset = VAR_6[VAR_8].offset;\n        VAR_5.handler = VAR_6[VAR_8].handler;\n    }\n\n#if 1\n    if (VAR_5.handler == NULL) {\n        return VAR_10;\n    }\n#endif\n\n    return VAR_5.handler(VAR_0, &VAR_5, &VAR_3);\n}",
  "func_graph_path_before": "openresty/lua-nginx-module/041d7d1c8539f92062c2a79cf18f550542bccc2e/ngx_http_lua_headers_out.c/vul/before/0.json",
  "func": "ngx_int_t\nngx_http_lua_set_output_header(ngx_http_request_t *r, ngx_http_lua_ctx_t *ctx,\n    ngx_str_t key, ngx_str_t value, unsigned override)\n{\n    ngx_http_lua_header_val_t         hv;\n    ngx_http_lua_set_header_t        *handlers = ngx_http_lua_set_handlers;\n    ngx_uint_t                        i;\n\n    dd(\"set header value: %.*s\", (int) value.len, value.data);\n\n    if (ngx_http_lua_check_header_safe(r, key.data, key.len) != NGX_OK\n        || ngx_http_lua_check_header_safe(r, value.data, value.len) != NGX_OK)\n    {\n        return NGX_ERROR;\n    }\n\n    hv.hash = ngx_hash_key_lc(key.data, key.len);\n    hv.key = key;\n\n    hv.offset = 0;\n    hv.no_override = !override;\n    hv.handler = NULL;\n\n    for (i = 0; handlers[i].name.len; i++) {\n        if (hv.key.len != handlers[i].name.len\n            || ngx_strncasecmp(hv.key.data, handlers[i].name.data,\n                               handlers[i].name.len) != 0)\n        {\n            dd(\"hv key comparison: %s <> %s\", handlers[i].name.data,\n               hv.key.data);\n\n            continue;\n        }\n\n        dd(\"Matched handler: %s %s\", handlers[i].name.data, hv.key.data);\n\n        hv.offset = handlers[i].offset;\n        hv.handler = handlers[i].handler;\n\n        if (hv.handler == ngx_http_set_content_type_header) {\n            ctx->mime_set = 1;\n        }\n\n        break;\n    }\n\n    if (handlers[i].name.len == 0 && handlers[i].handler) {\n        hv.offset = handlers[i].offset;\n        hv.handler = handlers[i].handler;\n    }\n\n#if 1\n    if (hv.handler == NULL) {\n        return NGX_ERROR;\n    }\n#endif\n\n    return hv.handler(r, &hv, &value);\n}",
  "abstract_func": "ngx_int_t\nngx_http_lua_set_output_header(ngx_http_request_t *VAR_0, ngx_http_lua_ctx_t *VAR_1,\n    ngx_str_t VAR_2, ngx_str_t VAR_3, unsigned VAR_4)\n{\n    ngx_http_lua_header_val_t         VAR_5;\n    ngx_http_lua_set_header_t        *VAR_6 = VAR_7;\n    ngx_uint_t                        VAR_8;\n\n    dd(\"set header value: %.*s\", (int) VAR_3.len, VAR_3.data);\n\n    if (ngx_http_lua_check_header_safe(VAR_0, VAR_2.data, VAR_2.len) != VAR_9\n        || ngx_http_lua_check_header_safe(VAR_0, VAR_3.data, VAR_3.len) != VAR_9)\n    {\n        return VAR_10;\n    }\n\n    VAR_5.hash = ngx_hash_key_lc(VAR_2.data, VAR_2.len);\n    VAR_5.key = VAR_2;\n\n    VAR_5.offset = 0;\n    VAR_5.no_override = !VAR_4;\n    VAR_5.handler = NULL;\n\n    for (VAR_8 = 0; VAR_6[VAR_8].name.len; VAR_8++) {\n        if (VAR_5.key.len != VAR_6[VAR_8].name.len\n            || ngx_strncasecmp(VAR_5.key.data, VAR_6[VAR_8].name.data,\n                               VAR_6[VAR_8].name.len) != 0)\n        {\n            dd(\"hv key comparison: %s <> %s\", VAR_6[VAR_8].name.data,\n               VAR_5.key.data);\n\n            continue;\n        }\n\n        dd(\"Matched handler: %s %s\", VAR_6[VAR_8].name.data, VAR_5.key.data);\n\n        VAR_5.offset = VAR_6[VAR_8].offset;\n        VAR_5.handler = VAR_6[VAR_8].handler;\n\n        if (VAR_5.handler == VAR_11) {\n            VAR_1->mime_set = 1;\n        }\n\n        break;\n    }\n\n    if (VAR_6[VAR_8].name.len == 0 && VAR_6[VAR_8].handler) {\n        VAR_5.offset = VAR_6[VAR_8].offset;\n        VAR_5.handler = VAR_6[VAR_8].handler;\n    }\n\n#if 1\n    if (VAR_5.handler == NULL) {\n        return VAR_10;\n    }\n#endif\n\n    return VAR_5.handler(VAR_0, &VAR_5, &VAR_3);\n}",
  "func_graph_path": "openresty/lua-nginx-module/041d7d1c8539f92062c2a79cf18f550542bccc2e/ngx_http_lua_headers_out.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -8,9 +8,11 @@\n \n     dd(\"set header value: %.*s\", (int) value.len, value.data);\n \n-    key.len = ngx_http_lua_safe_header_value_len(key.data, key.len);\n-\n-    value.len = ngx_http_lua_safe_header_value_len(value.data, value.len);\n+    if (ngx_http_lua_check_header_safe(r, key.data, key.len) != NGX_OK\n+        || ngx_http_lua_check_header_safe(r, value.data, value.len) != NGX_OK)\n+    {\n+        return NGX_ERROR;\n+    }\n \n     hv.hash = ngx_hash_key_lc(key.data, key.len);\n     hv.key = key;",
  "diff_line_info": {
    "deleted_lines": [
      "    key.len = ngx_http_lua_safe_header_value_len(key.data, key.len);",
      "",
      "    value.len = ngx_http_lua_safe_header_value_len(value.data, value.len);"
    ],
    "added_lines": [
      "    if (ngx_http_lua_check_header_safe(r, key.data, key.len) != NGX_OK",
      "        || ngx_http_lua_check_header_safe(r, value.data, value.len) != NGX_OK)",
      "    {",
      "        return NGX_ERROR;",
      "    }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/openresty/lua-nginx-module/pull/1654",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/openresty/lua-nginx-module/pull/1654: 403 Client Error: Forbidden for url: https://api.github.com/repos/openresty/lua-nginx-module/pulls/1654",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "The patch addresses unsafe characters in HTTP headers, which are security concerns. The code uses specific functions for header validation, indicating a security fix.\n\n**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}