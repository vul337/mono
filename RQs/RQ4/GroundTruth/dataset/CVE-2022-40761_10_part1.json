{
  "cve_id": "CVE-2022-40761",
  "cwe_ids": [
    "CWE-1284"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "Samsung/mTower",
  "commit_msg": "Fixed CVE-2022-40761\n\nSigned-off-by: Taras Drozdovskyi <t.drozdovsky@samsung.com>",
  "commit_hash": "c5f30c70e48786e1aef8c815f35e406a6c4fb3ae",
  "git_url": "https://github.com/Samsung/mTower/commit/c5f30c70e48786e1aef8c815f35e406a6c4fb3ae",
  "file_path": "tee/kernel/tee_ta_manager.c",
  "func_name": "tee_ta_init_session",
  "func_before": "static TEE_Result tee_ta_init_session(TEE_ErrorOrigin *err,\n\t\t\t\tstruct tee_ta_session_head *open_sessions,\n\t\t\t\tconst TEE_UUID *uuid,\n\t\t\t\tstruct tee_ta_session **sess)\n{\n\tTEE_Result res;\n//\tstruct tee_ta_ctx *ctx;\n//  struct tee_ta_session *s = calloc(1, sizeof(struct tee_ta_session));\n  struct tee_ta_session *s = malloc(sizeof(struct tee_ta_session));\n  *err = TEE_ORIGIN_TEE;\n  if (!s)\n    return TEE_ERROR_OUT_OF_MEMORY;\n\n  memset(s,0,sizeof(struct tee_ta_session));\n\n//\n//\ts->cancel_mask = true;\n//\tcondvar_init(&s->refc_cv);\n//\tcondvar_init(&s->lock_cv);\n//\ts->lock_thread = THREAD_ID_INVALID;\n//\ts->ref_count = 1;\n//\n//\n//\t/*\n//\t * We take the global TA mutex here and hold it while doing\n//\t * RPC to load the TA. This big critical section should be broken\n//\t * down into smaller pieces.\n//\t */\n//\n//\n//\tmutex_lock(&tee_ta_mutex);\n\tTAILQ_INSERT_TAIL(open_sessions, s, link);\n\n\t/* Look for already loaded TA */\n//\tctx = tee_ta_context_find(uuid);\n//\tif (ctx) {\n//\t\tres = tee_ta_init_session_with_context(ctx, s);\n//\t\tif (res == TEE_SUCCESS || res != TEE_ERROR_ITEM_NOT_FOUND)\n//\t\t\tgoto out;\n//\t}\n\n\t/* Look for static TA */\n\tres = tee_ta_init_pseudo_ta_session(uuid, s);\n\tif (res == TEE_SUCCESS || res != TEE_ERROR_ITEM_NOT_FOUND)\n\t\tgoto out;\n\n\t/* Look for user TA */\n\tres = tee_ta_init_user_ta_session(uuid, s);\n\nout:\n\tif (res == TEE_SUCCESS) {\n\t\t*sess = s;\n\t} else {\n\t\tTAILQ_REMOVE(open_sessions, s, link);\n\t\tfree(s);\n\t}\n//\tmutex_unlock(&tee_ta_mutex);\n\treturn res;\n}",
  "abstract_func_before": "static TEE_Result tee_ta_init_session(TEE_ErrorOrigin *VAR_0,\n\t\t\t\tstruct tee_ta_session_head *VAR_1,\n\t\t\t\tconst TEE_UUID *VAR_2,\n\t\t\t\tstruct tee_ta_session **VAR_3)\n{\n\tTEE_Result VAR_4;\n/* COMMENT_0 */\n/* COMMENT_1 */\n  struct tee_ta_session *VAR_5 = malloc(sizeof(struct tee_ta_session));\n  *VAR_0 = VAR_6;\n  if (!VAR_5)\n    return VAR_7;\n\n  memset(VAR_5,0,sizeof(struct tee_ta_session));\n\n/* COMMENT_2 */\n/* COMMENT_3 */\n/* COMMENT_4 */\n/* COMMENT_5 */\n/* COMMENT_6 */\n/* COMMENT_7 */\n/* COMMENT_2 */\n/* COMMENT_2 */\n/* COMMENT_8 */\n/* COMMENT_9 */\n/* COMMENT_10 */\n/* COMMENT_11 */\n/* COMMENT_12 */\n/* COMMENT_2 */\n/* COMMENT_2 */\n/* COMMENT_13 */\n\tTAILQ_INSERT_TAIL(VAR_1, VAR_5, VAR_8);\n\n\t/* COMMENT_14 */\n/* COMMENT_15 */\n/* COMMENT_16 */\n/* COMMENT_17 */\n/* COMMENT_18 */\n/* COMMENT_19 */\n/* COMMENT_20 */\n\n\t/* COMMENT_21 */\n\tVAR_4 = tee_ta_init_pseudo_ta_session(VAR_2, VAR_5);\n\tif (VAR_4 == VAR_9 || VAR_4 != VAR_10)\n\t\tgoto out;\n\n\t/* COMMENT_22 */\n\tVAR_4 = tee_ta_init_user_ta_session(VAR_2, VAR_5);\n\nout:\n\tif (VAR_4 == VAR_9) {\n\t\t*VAR_3 = VAR_5;\n\t} else {\n\t\tTAILQ_REMOVE(VAR_1, VAR_5, VAR_8);\n\t\tfree(VAR_5);\n\t}\n/* COMMENT_23 */\n\treturn VAR_4;\n}",
  "func_graph_path_before": "Samsung/mTower/c5f30c70e48786e1aef8c815f35e406a6c4fb3ae/tee_ta_manager.c/vul/before/0.json",
  "func": "static TEE_Result tee_ta_init_session(TEE_ErrorOrigin *err,\n\t\t\t\tstruct tee_ta_session_head *open_sessions,\n\t\t\t\tconst TEE_UUID *uuid,\n\t\t\t\tstruct tee_ta_session **sess)\n{\n\tTEE_Result res;\n//\tstruct tee_ta_ctx *ctx;\n//  struct tee_ta_session *s = calloc(1, sizeof(struct tee_ta_session));\n\n// TEE_Malloc(sizeof(struct pseudo_ta_ctx), TEE_MALLOC_FILL_ZERO);\n//   struct tee_ta_session *s = malloc(sizeof(struct tee_ta_session));\n  struct tee_ta_session *s = TEE_Malloc(sizeof(struct tee_ta_session), TEE_MALLOC_FILL_ZERO);\n  *err = TEE_ORIGIN_TEE;\n  if (!s)\n    return TEE_ERROR_OUT_OF_MEMORY;\n\n  memset(s,0,sizeof(struct tee_ta_session));\n\n//\n//\ts->cancel_mask = true;\n//\tcondvar_init(&s->refc_cv);\n//\tcondvar_init(&s->lock_cv);\n//\ts->lock_thread = THREAD_ID_INVALID;\n//\ts->ref_count = 1;\n//\n//\n//\t/*\n//\t * We take the global TA mutex here and hold it while doing\n//\t * RPC to load the TA. This big critical section should be broken\n//\t * down into smaller pieces.\n//\t */\n//\n//\n//\tmutex_lock(&tee_ta_mutex);\n\tTAILQ_INSERT_TAIL(open_sessions, s, link);\n\n\t/* Look for already loaded TA */\n//\tctx = tee_ta_context_find(uuid);\n//\tif (ctx) {\n//\t\tres = tee_ta_init_session_with_context(ctx, s);\n//\t\tif (res == TEE_SUCCESS || res != TEE_ERROR_ITEM_NOT_FOUND)\n//\t\t\tgoto out;\n//\t}\n\n\t/* Look for static TA */\n\tres = tee_ta_init_pseudo_ta_session(uuid, s);\n\tif (res == TEE_SUCCESS || res != TEE_ERROR_ITEM_NOT_FOUND)\n\t\tgoto out;\n\n\t/* Look for user TA */\n\tres = tee_ta_init_user_ta_session(uuid, s);\n\nout:\n\tif (res == TEE_SUCCESS) {\n\t\t*sess = s;\n\t} else {\n\t\tTAILQ_REMOVE(open_sessions, s, link);\n\t\tfree(s);\n\t}\n//\tmutex_unlock(&tee_ta_mutex);\n\treturn res;\n}",
  "abstract_func": "static TEE_Result tee_ta_init_session(TEE_ErrorOrigin *VAR_0,\n\t\t\t\tstruct tee_ta_session_head *VAR_1,\n\t\t\t\tconst TEE_UUID *VAR_2,\n\t\t\t\tstruct tee_ta_session **VAR_3)\n{\n\tTEE_Result VAR_4;\n/* COMMENT_0 */\n/* COMMENT_1 */\n\n/* COMMENT_2 */\n/* COMMENT_3 */\n  struct tee_ta_session *VAR_5 = TEE_Malloc(sizeof(struct tee_ta_session), VAR_6);\n  *VAR_0 = VAR_7;\n  if (!VAR_5)\n    return VAR_8;\n\n  memset(VAR_5,0,sizeof(struct tee_ta_session));\n\n/* COMMENT_4 */\n/* COMMENT_5 */\n/* COMMENT_6 */\n/* COMMENT_7 */\n/* COMMENT_8 */\n/* COMMENT_9 */\n/* COMMENT_4 */\n/* COMMENT_4 */\n/* COMMENT_10 */\n/* COMMENT_11 */\n/* COMMENT_12 */\n/* COMMENT_13 */\n/* COMMENT_14 */\n/* COMMENT_4 */\n/* COMMENT_4 */\n/* COMMENT_15 */\n\tTAILQ_INSERT_TAIL(VAR_1, VAR_5, VAR_9);\n\n\t/* COMMENT_16 */\n/* COMMENT_17 */\n/* COMMENT_18 */\n/* COMMENT_19 */\n/* COMMENT_20 */\n/* COMMENT_21 */\n/* COMMENT_22 */\n\n\t/* COMMENT_23 */\n\tVAR_4 = tee_ta_init_pseudo_ta_session(VAR_2, VAR_5);\n\tif (VAR_4 == VAR_10 || VAR_4 != VAR_11)\n\t\tgoto out;\n\n\t/* COMMENT_24 */\n\tVAR_4 = tee_ta_init_user_ta_session(VAR_2, VAR_5);\n\nout:\n\tif (VAR_4 == VAR_10) {\n\t\t*VAR_3 = VAR_5;\n\t} else {\n\t\tTAILQ_REMOVE(VAR_1, VAR_5, VAR_9);\n\t\tfree(VAR_5);\n\t}\n/* COMMENT_25 */\n\treturn VAR_4;\n}",
  "func_graph_path": "Samsung/mTower/c5f30c70e48786e1aef8c815f35e406a6c4fb3ae/tee_ta_manager.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,10 @@\n \tTEE_Result res;\n //\tstruct tee_ta_ctx *ctx;\n //  struct tee_ta_session *s = calloc(1, sizeof(struct tee_ta_session));\n-  struct tee_ta_session *s = malloc(sizeof(struct tee_ta_session));\n+\n+// TEE_Malloc(sizeof(struct pseudo_ta_ctx), TEE_MALLOC_FILL_ZERO);\n+//   struct tee_ta_session *s = malloc(sizeof(struct tee_ta_session));\n+  struct tee_ta_session *s = TEE_Malloc(sizeof(struct tee_ta_session), TEE_MALLOC_FILL_ZERO);\n   *err = TEE_ORIGIN_TEE;\n   if (!s)\n     return TEE_ERROR_OUT_OF_MEMORY;",
  "diff_line_info": {
    "deleted_lines": [
      "  struct tee_ta_session *s = malloc(sizeof(struct tee_ta_session));"
    ],
    "added_lines": [
      "",
      "// TEE_Malloc(sizeof(struct pseudo_ta_ctx), TEE_MALLOC_FILL_ZERO);",
      "//   struct tee_ta_session *s = malloc(sizeof(struct tee_ta_session));",
      "  struct tee_ta_session *s = TEE_Malloc(sizeof(struct tee_ta_session), TEE_MALLOC_FILL_ZERO);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/Samsung/mTower/pull/88",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/Samsung/mTower/pull/88: 403 Client Error: Forbidden for url: https://api.github.com/repos/Samsung/mTower/pulls/88",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}