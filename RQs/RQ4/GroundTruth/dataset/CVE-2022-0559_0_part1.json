{
  "cve_id": "CVE-2022-0559",
  "cwe_ids": [
    "CWE-416"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "radareorg/radare2",
  "commit_msg": "Prefer memleak over usaf in io.bank's rbtree bug ##crash\n\n* That's a workaround, proper fix will come later\n* Reproducer: bins/fuzzed/iobank-crash\n* Reported by Akyne Choi via huntr.dev",
  "commit_hash": "b5cb90b28ec71fda3504da04e3cc94a362807f5e",
  "git_url": "https://github.com/radareorg/radare2/commit/b5cb90b28ec71fda3504da04e3cc94a362807f5e",
  "file_path": "libr/io/io_bank.c",
  "func_name": "r_io_bank_map_add_top",
  "func_before": "R_API bool r_io_bank_map_add_top(RIO *io, const ut32 bankid, const ut32 mapid) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tRIOMap *map = r_io_map_get (io, mapid);\n\tr_return_val_if_fail (io && bank && map, false);\n\tRIOMapRef *mapref = _mapref_from_map (map);\n\tif (!mapref) {\n\t\treturn false;\n\t}\n\tRIOSubMap *sm = r_io_submap_new (io, mapref);\n\tif (!sm) {\n\t\tfree (mapref);\n\t\treturn false;\n\t}\n\tRRBNode *entry = _find_entry_submap_node (bank, sm);\n\tif (!entry) {\n\t\t// no intersection with any submap, so just insert\n\t\tif (!r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\t\tfree (sm);\n\t\t\tfree (mapref);\n\t\t\treturn false;\n\t\t}\n\t\tr_list_append (bank->maprefs, mapref);\n\t\treturn true;\n\t}\n\tbank->last_used = NULL;\n\tRIOSubMap *bd = (RIOSubMap *)entry->data;\n\tif (r_io_submap_to (bd) == r_io_submap_to (sm) &&\n\t\tr_io_submap_from (bd) >= r_io_submap_from (sm)) {\n\t\t// _find_entry_submap_node guarantees, that there is no submap\n\t\t// prior to bd in the range of sm, so instead of deleting and inserting\n\t\t// we can just memcpy\n\t\tmemcpy (bd, sm, sizeof (RIOSubMap));\n\t\tfree (sm);\n\t\tr_list_append (bank->maprefs, mapref);\n\t\treturn true;\n\t}\n\tif (r_io_submap_from (bd) < r_io_submap_from (sm) &&\n\t\tr_io_submap_to (sm) < r_io_submap_to (bd)) {\n\t\t// split bd into 2 maps => bd and bdsm\n\t\tRIOSubMap *bdsm = R_NEWCOPY (RIOSubMap, bd);\n\t\tif (!bdsm) {\n\t\t\tfree (sm);\n\t\t\tfree (mapref);\n\t\t\treturn false;\n\t\t}\n\t\tr_io_submap_set_from (bdsm, r_io_submap_to (sm) + 1);\n\t\tr_io_submap_set_to (bd, r_io_submap_from (sm) - 1);\n\t\t// TODO: insert and check return value, before adjusting sm size\n\t\tif (!r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\t\tfree (sm);\n\t\t\tfree (bdsm);\n\t\t\tfree (mapref);\n\t\t\treturn false;\n\t\t}\n\t\tif (!r_crbtree_insert (bank->submaps, bdsm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\t\tr_crbtree_delete (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n\t\t\tfree (sm);\n\t\t\tfree (bdsm);\n\t\t\tfree (mapref);\n\t\t\treturn false;\n\t\t}\n\t\tr_list_append (bank->maprefs, mapref);\n\t\treturn true;\n\t}\n\n\t// guaranteed intersection\n\tif (r_io_submap_from (bd) < r_io_submap_from (sm)) {\n\t\tr_io_submap_set_to (bd, r_io_submap_from (sm) - 1);\n\t\tentry = r_rbnode_next (entry);\n\t}\n\twhile (entry && r_io_submap_to (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {\n\t\t//delete all submaps that are completly included in sm\n\t\tRRBNode *next = r_rbnode_next (entry);\n\t\t// this can be optimized, there is no need to do search here\n\t\tbool a = r_crbtree_delete (bank->submaps, entry->data, _find_sm_by_from_vaddr_cb, NULL);\n\t\tif (!a) {\n\t\t\tbreak;\n\t\t}\n\t\tentry = next;\n\t}\n\tif (entry && r_io_submap_from (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {\n\t\tbd = (RIOSubMap *)entry->data;\n\t\tr_io_submap_set_from (bd, r_io_submap_to (sm) + 1);\n\t}\n\tif (!r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\tfree (sm);\n\t\tfree (mapref);\n\t\treturn false;\n\t}\n\tr_list_append (bank->maprefs, mapref);\n\treturn true;\n}",
  "abstract_func_before": "R_API bool r_io_bank_map_add_top(RIO *VAR_0, const ut32 VAR_1, const ut32 VAR_2) {\n\tRIOBank *VAR_3 = r_io_bank_get (VAR_0, VAR_1);\n\tRIOMap *VAR_4 = r_io_map_get (VAR_0, VAR_2);\n\tr_return_val_if_fail (VAR_0 && VAR_3 && VAR_4, false);\n\tRIOMapRef *VAR_5 = _mapref_from_map (VAR_4);\n\tif (!VAR_5) {\n\t\treturn false;\n\t}\n\tRIOSubMap *VAR_6 = r_io_submap_new (VAR_0, VAR_5);\n\tif (!VAR_6) {\n\t\tfree (VAR_5);\n\t\treturn false;\n\t}\n\tRRBNode *VAR_7 = _find_entry_submap_node (VAR_3, VAR_6);\n\tif (!VAR_7) {\n\t\t/* COMMENT_0 */\n\t\tif (!r_crbtree_insert (VAR_3->submaps, VAR_6, VAR_8, NULL)) {\n\t\t\tfree (VAR_6);\n\t\t\tfree (VAR_5);\n\t\t\treturn false;\n\t\t}\n\t\tr_list_append (VAR_3->maprefs, VAR_5);\n\t\treturn true;\n\t}\n\tVAR_3->last_used = NULL;\n\tRIOSubMap *VAR_9 = (RIOSubMap *)VAR_7->data;\n\tif (r_io_submap_to (VAR_9) == r_io_submap_to (VAR_6) &&\n\t\tr_io_submap_from (VAR_9) >= r_io_submap_from (VAR_6)) {\n\t\t/* COMMENT_1 */\n\t\t/* COMMENT_2 */\n\t\t/* COMMENT_3 */\n\t\tmemcpy (VAR_9, VAR_6, sizeof (RIOSubMap));\n\t\tfree (VAR_6);\n\t\tr_list_append (VAR_3->maprefs, VAR_5);\n\t\treturn true;\n\t}\n\tif (r_io_submap_from (VAR_9) < r_io_submap_from (VAR_6) &&\n\t\tr_io_submap_to (VAR_6) < r_io_submap_to (VAR_9)) {\n\t\t/* COMMENT_4 */\n\t\tRIOSubMap *VAR_10 = R_NEWCOPY (RIOSubMap, VAR_9);\n\t\tif (!VAR_10) {\n\t\t\tfree (VAR_6);\n\t\t\tfree (VAR_5);\n\t\t\treturn false;\n\t\t}\n\t\tr_io_submap_set_from (VAR_10, r_io_submap_to (VAR_6) + 1);\n\t\tr_io_submap_set_to (VAR_9, r_io_submap_from (VAR_6) - 1);\n\t\t/* COMMENT_5 */\n\t\tif (!r_crbtree_insert (VAR_3->submaps, VAR_6, VAR_8, NULL)) {\n\t\t\tfree (VAR_6);\n\t\t\tfree (VAR_10);\n\t\t\tfree (VAR_5);\n\t\t\treturn false;\n\t\t}\n\t\tif (!r_crbtree_insert (VAR_3->submaps, VAR_10, VAR_8, NULL)) {\n\t\t\tr_crbtree_delete (VAR_3->submaps, VAR_6, VAR_8, NULL);\n\t\t\tfree (VAR_6);\n\t\t\tfree (VAR_10);\n\t\t\tfree (VAR_5);\n\t\t\treturn false;\n\t\t}\n\t\tr_list_append (VAR_3->maprefs, VAR_5);\n\t\treturn true;\n\t}\n\n\t/* COMMENT_6 */\n\tif (r_io_submap_from (VAR_9) < r_io_submap_from (VAR_6)) {\n\t\tr_io_submap_set_to (VAR_9, r_io_submap_from (VAR_6) - 1);\n\t\tVAR_7 = r_rbnode_next (VAR_7);\n\t}\n\twhile (VAR_7 && r_io_submap_to (((RIOSubMap *)VAR_7->data)) <= r_io_submap_to (VAR_6)) {\n\t\t/* COMMENT_7 */\n\t\tRRBNode *VAR_11 = r_rbnode_next (VAR_7);\n\t\t/* COMMENT_8 */\n\t\tbool VAR_12 = r_crbtree_delete (VAR_3->submaps, VAR_7->data, VAR_8, NULL);\n\t\tif (!VAR_12) {\n\t\t\tbreak;\n\t\t}\n\t\tVAR_7 = VAR_11;\n\t}\n\tif (VAR_7 && r_io_submap_from (((RIOSubMap *)VAR_7->data)) <= r_io_submap_to (VAR_6)) {\n\t\tVAR_9 = (RIOSubMap *)VAR_7->data;\n\t\tr_io_submap_set_from (VAR_9, r_io_submap_to (VAR_6) + 1);\n\t}\n\tif (!r_crbtree_insert (VAR_3->submaps, VAR_6, VAR_8, NULL)) {\n\t\tfree (VAR_6);\n\t\tfree (VAR_5);\n\t\treturn false;\n\t}\n\tr_list_append (VAR_3->maprefs, VAR_5);\n\treturn true;\n}",
  "func_graph_path_before": null,
  "func": "R_API bool r_io_bank_map_add_top(RIO *io, const ut32 bankid, const ut32 mapid) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tRIOMap *map = r_io_map_get (io, mapid);\n\tr_return_val_if_fail (io && bank && map, false);\n\tRIOMapRef *mapref = _mapref_from_map (map);\n\tif (!mapref) {\n\t\treturn false;\n\t}\n\tRIOSubMap *sm = r_io_submap_new (io, mapref);\n\tif (!sm) {\n\t\tfree (mapref);\n\t\treturn false;\n\t}\n\tRRBNode *entry = _find_entry_submap_node (bank, sm);\n\tif (!entry) {\n\t\t// no intersection with any submap, so just insert\n\t\tif (!r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\t\tfree (sm);\n\t\t\tfree (mapref);\n\t\t\treturn false;\n\t\t}\n\t\tr_list_append (bank->maprefs, mapref);\n\t\treturn true;\n\t}\n\tbank->last_used = NULL;\n\tRIOSubMap *bd = (RIOSubMap *)entry->data;\n\tif (r_io_submap_to (bd) == r_io_submap_to (sm) &&\n\t\tr_io_submap_from (bd) >= r_io_submap_from (sm)) {\n\t\t// _find_entry_submap_node guarantees, that there is no submap\n\t\t// prior to bd in the range of sm, so instead of deleting and inserting\n\t\t// we can just memcpy\n\t\tmemcpy (bd, sm, sizeof (RIOSubMap));\n\t\tfree (sm);\n\t\tr_list_append (bank->maprefs, mapref);\n\t\treturn true;\n\t}\n\tif (r_io_submap_from (bd) < r_io_submap_from (sm) &&\n\t\tr_io_submap_to (sm) < r_io_submap_to (bd)) {\n\t\t// split bd into 2 maps => bd and bdsm\n\t\tRIOSubMap *bdsm = R_NEWCOPY (RIOSubMap, bd);\n\t\tif (!bdsm) {\n\t\t\tfree (sm);\n\t\t\tfree (mapref);\n\t\t\treturn false;\n\t\t}\n\t\tr_io_submap_set_from (bdsm, r_io_submap_to (sm) + 1);\n\t\tr_io_submap_set_to (bd, r_io_submap_from (sm) - 1);\n\t\t// TODO: insert and check return value, before adjusting sm size\n\t\tif (!r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\t\tfree (sm);\n\t\t\tfree (bdsm);\n\t\t\tfree (mapref);\n\t\t\treturn false;\n\t\t}\n\t\tif (!r_crbtree_insert (bank->submaps, bdsm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\t\tr_crbtree_delete (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n\t\t\tfree (sm);\n\t\t\tfree (bdsm);\n\t\t\tfree (mapref);\n\t\t\treturn false;\n\t\t}\n\t\tr_list_append (bank->maprefs, mapref);\n\t\treturn true;\n\t}\n\n\t// guaranteed intersection\n\tif (r_io_submap_from (bd) < r_io_submap_from (sm)) {\n\t\tr_io_submap_set_to (bd, r_io_submap_from (sm) - 1);\n\t\tentry = r_rbnode_next (entry);\n\t}\n\tut64 smto = r_io_submap_to (sm);\n\twhile (entry && r_io_submap_to (((RIOSubMap *)entry->data)) <= smto) {\n\t\t//delete all submaps that are completly included in sm\n\t\tRRBNode *next = r_rbnode_next (entry);\n\t\t// this can be optimized, there is no need to do search here\n\t\t// XXX this is a workaround to avoid an UAF in Reproducer: iobank-crash\n\t\tvoid *smfree = bank->submaps->free;\n\t\tbank->submaps->free = NULL;\n\t\tbool a = r_crbtree_delete (bank->submaps, entry->data, _find_sm_by_from_vaddr_cb, NULL);\n\t\tbank->submaps->free = smfree;\n\t\tif (!a) {\n\t\t\tentry = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tentry = next;\n\t}\n\tif (entry && r_io_submap_from (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {\n\t\tbd = (RIOSubMap *)entry->data;\n\t\tr_io_submap_set_from (bd, r_io_submap_to (sm) + 1);\n\t}\n\tif (!r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\tfree (sm);\n\t\tfree (mapref);\n\t\treturn false;\n\t}\n\tr_list_append (bank->maprefs, mapref);\n\treturn true;\n}",
  "abstract_func": "R_API bool r_io_bank_map_add_top(RIO *VAR_0, const ut32 VAR_1, const ut32 VAR_2) {\n\tRIOBank *VAR_3 = r_io_bank_get (VAR_0, VAR_1);\n\tRIOMap *VAR_4 = r_io_map_get (VAR_0, VAR_2);\n\tr_return_val_if_fail (VAR_0 && VAR_3 && VAR_4, false);\n\tRIOMapRef *VAR_5 = _mapref_from_map (VAR_4);\n\tif (!VAR_5) {\n\t\treturn false;\n\t}\n\tRIOSubMap *VAR_6 = r_io_submap_new (VAR_0, VAR_5);\n\tif (!VAR_6) {\n\t\tfree (VAR_5);\n\t\treturn false;\n\t}\n\tRRBNode *VAR_7 = _find_entry_submap_node (VAR_3, VAR_6);\n\tif (!VAR_7) {\n\t\t/* COMMENT_0 */\n\t\tif (!r_crbtree_insert (VAR_3->submaps, VAR_6, VAR_8, NULL)) {\n\t\t\tfree (VAR_6);\n\t\t\tfree (VAR_5);\n\t\t\treturn false;\n\t\t}\n\t\tr_list_append (VAR_3->maprefs, VAR_5);\n\t\treturn true;\n\t}\n\tVAR_3->last_used = NULL;\n\tRIOSubMap *VAR_9 = (RIOSubMap *)VAR_7->data;\n\tif (r_io_submap_to (VAR_9) == r_io_submap_to (VAR_6) &&\n\t\tr_io_submap_from (VAR_9) >= r_io_submap_from (VAR_6)) {\n\t\t/* COMMENT_1 */\n\t\t/* COMMENT_2 */\n\t\t/* COMMENT_3 */\n\t\tmemcpy (VAR_9, VAR_6, sizeof (RIOSubMap));\n\t\tfree (VAR_6);\n\t\tr_list_append (VAR_3->maprefs, VAR_5);\n\t\treturn true;\n\t}\n\tif (r_io_submap_from (VAR_9) < r_io_submap_from (VAR_6) &&\n\t\tr_io_submap_to (VAR_6) < r_io_submap_to (VAR_9)) {\n\t\t/* COMMENT_4 */\n\t\tRIOSubMap *VAR_10 = R_NEWCOPY (RIOSubMap, VAR_9);\n\t\tif (!VAR_10) {\n\t\t\tfree (VAR_6);\n\t\t\tfree (VAR_5);\n\t\t\treturn false;\n\t\t}\n\t\tr_io_submap_set_from (VAR_10, r_io_submap_to (VAR_6) + 1);\n\t\tr_io_submap_set_to (VAR_9, r_io_submap_from (VAR_6) - 1);\n\t\t/* COMMENT_5 */\n\t\tif (!r_crbtree_insert (VAR_3->submaps, VAR_6, VAR_8, NULL)) {\n\t\t\tfree (VAR_6);\n\t\t\tfree (VAR_10);\n\t\t\tfree (VAR_5);\n\t\t\treturn false;\n\t\t}\n\t\tif (!r_crbtree_insert (VAR_3->submaps, VAR_10, VAR_8, NULL)) {\n\t\t\tr_crbtree_delete (VAR_3->submaps, VAR_6, VAR_8, NULL);\n\t\t\tfree (VAR_6);\n\t\t\tfree (VAR_10);\n\t\t\tfree (VAR_5);\n\t\t\treturn false;\n\t\t}\n\t\tr_list_append (VAR_3->maprefs, VAR_5);\n\t\treturn true;\n\t}\n\n\t/* COMMENT_6 */\n\tif (r_io_submap_from (VAR_9) < r_io_submap_from (VAR_6)) {\n\t\tr_io_submap_set_to (VAR_9, r_io_submap_from (VAR_6) - 1);\n\t\tVAR_7 = r_rbnode_next (VAR_7);\n\t}\n\tut64 VAR_11 = r_io_submap_to (VAR_6);\n\twhile (VAR_7 && r_io_submap_to (((RIOSubMap *)VAR_7->data)) <= VAR_11) {\n\t\t/* COMMENT_7 */\n\t\tRRBNode *VAR_12 = r_rbnode_next (VAR_7);\n\t\t/* COMMENT_8 */\n\t\t/* COMMENT_9 */\n\t\tvoid *VAR_13 = VAR_3->submaps->free;\n\t\tVAR_3->submaps->free = NULL;\n\t\tbool VAR_14 = r_crbtree_delete (VAR_3->submaps, VAR_7->data, VAR_8, NULL);\n\t\tVAR_3->submaps->free = VAR_13;\n\t\tif (!VAR_14) {\n\t\t\tVAR_7 = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tVAR_7 = VAR_12;\n\t}\n\tif (VAR_7 && r_io_submap_from (((RIOSubMap *)VAR_7->data)) <= r_io_submap_to (VAR_6)) {\n\t\tVAR_9 = (RIOSubMap *)VAR_7->data;\n\t\tr_io_submap_set_from (VAR_9, r_io_submap_to (VAR_6) + 1);\n\t}\n\tif (!r_crbtree_insert (VAR_3->submaps, VAR_6, VAR_8, NULL)) {\n\t\tfree (VAR_6);\n\t\tfree (VAR_5);\n\t\treturn false;\n\t}\n\tr_list_append (VAR_3->maprefs, VAR_5);\n\treturn true;\n}",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -68,12 +68,18 @@\n \t\tr_io_submap_set_to (bd, r_io_submap_from (sm) - 1);\n \t\tentry = r_rbnode_next (entry);\n \t}\n-\twhile (entry && r_io_submap_to (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {\n+\tut64 smto = r_io_submap_to (sm);\n+\twhile (entry && r_io_submap_to (((RIOSubMap *)entry->data)) <= smto) {\n \t\t//delete all submaps that are completly included in sm\n \t\tRRBNode *next = r_rbnode_next (entry);\n \t\t// this can be optimized, there is no need to do search here\n+\t\t// XXX this is a workaround to avoid an UAF in Reproducer: iobank-crash\n+\t\tvoid *smfree = bank->submaps->free;\n+\t\tbank->submaps->free = NULL;\n \t\tbool a = r_crbtree_delete (bank->submaps, entry->data, _find_sm_by_from_vaddr_cb, NULL);\n+\t\tbank->submaps->free = smfree;\n \t\tif (!a) {\n+\t\t\tentry = NULL;\n \t\t\tbreak;\n \t\t}\n \t\tentry = next;",
  "diff_line_info": {
    "deleted_lines": [
      "\twhile (entry && r_io_submap_to (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {"
    ],
    "added_lines": [
      "\tut64 smto = r_io_submap_to (sm);",
      "\twhile (entry && r_io_submap_to (((RIOSubMap *)entry->data)) <= smto) {",
      "\t\t// XXX this is a workaround to avoid an UAF in Reproducer: iobank-crash",
      "\t\tvoid *smfree = bank->submaps->free;",
      "\t\tbank->submaps->free = NULL;",
      "\t\tbank->submaps->free = smfree;",
      "\t\t\tentry = NULL;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/radareorg/radare2/pull/19701",
  "description": {
    "pr_info": {
      "title": "Prefer memleak over UAF in io.bank's rbtree bug ##crash",
      "number": 19701
    },
    "comment": [
      "* That's a workaround, proper fix will come later\r\n* Reproducer: bins/fuzzed/iobank-crash\r\n* Reported by Akyne Choi via huntr.dev\r\n\r\n<!-- Please read the contributing guidelines:\r\n* https://github.com/radareorg/radare2/blob/master/DEVELOPERS.md\r\nIn short:\r\n* PR title must be capitalized, concise and use ##tags\r\n* Follow the coding style, add tests and documentation if necessary\r\n-->\r\n\r\n**Checklist**\r\n\r\n- [ ] Closing issues: #issue\r\n- [ ] Mark this if you consider it ready to merge\r\n- [ ] I've added tests (optional)\r\n- [ ] I wrote some lines in the [radare2book](https://github.com/radareorg/radare2book)\r\n\r\n**Description**\r\n\r\n<!-- Explain the **details** to understand the purpose of this contribution, with enough information to help us understand better the changes. -->\r\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95"
}