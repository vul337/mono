{
  "cve_id": "CVE-2019-15903",
  "cwe_ids": [
    "CWE-776",
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "libexpat",
  "commit_msg": "xmlparse.c: Deny internal entities closing the doctype",
  "commit_hash": "c20b758c332d9a13afbbb276d30db1d183a85d43",
  "git_url": "https://github.com/libexpat/libexpat/commit/c20b758c332d9a13afbbb276d30db1d183a85d43",
  "file_path": "expat/lib/xmlparse.c",
  "func_name": "externalParEntProcessor",
  "func_before": "static enum XML_Error PTRCALL\nexternalParEntProcessor(XML_Parser parser, const char *s, const char *end,\n                        const char **nextPtr) {\n  const char *next = s;\n  int tok;\n\n  tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  if (tok <= 0) {\n    if (! parser->m_parsingStatus.finalBuffer && tok != XML_TOK_INVALID) {\n      *nextPtr = s;\n      return XML_ERROR_NONE;\n    }\n    switch (tok) {\n    case XML_TOK_INVALID:\n      return XML_ERROR_INVALID_TOKEN;\n    case XML_TOK_PARTIAL:\n      return XML_ERROR_UNCLOSED_TOKEN;\n    case XML_TOK_PARTIAL_CHAR:\n      return XML_ERROR_PARTIAL_CHAR;\n    case XML_TOK_NONE: /* start == end */\n    default:\n      break;\n    }\n  }\n  /* This would cause the next stage, i.e. doProlog to be passed XML_TOK_BOM.\n     However, when parsing an external subset, doProlog will not accept a BOM\n     as valid, and report a syntax error, so we have to skip the BOM\n  */\n  else if (tok == XML_TOK_BOM) {\n    s = next;\n    tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  }\n\n  parser->m_processor = prologProcessor;\n  return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                  (XML_Bool)! parser->m_parsingStatus.finalBuffer);\n}",
  "abstract_func_before": "static enum XML_Error VAR_0\nexternalParEntProcessor(XML_Parser VAR_1, const char *VAR_2, const char *VAR_3,\n                        const char **VAR_4) {\n  const char *VAR_5 = VAR_2;\n  int VAR_6;\n\n  VAR_6 = XmlPrologTok(VAR_1->m_encoding, VAR_2, VAR_3, &VAR_5);\n  if (VAR_6 <= 0) {\n    if (! VAR_1->m_parsingStatus.finalBuffer && VAR_6 != VAR_7) {\n      *VAR_4 = VAR_2;\n      return VAR_8;\n    }\n    switch (VAR_6) {\n    case VAR_7:\n      return VAR_9;\n    case VAR_10:\n      return VAR_11;\n    case VAR_12:\n      return VAR_13;\n    case VAR_14: /* COMMENT_0 */\n    default:\n      break;\n    }\n  }\n  /* COMMENT_1 */\n                                                                             \n                                                                    \n    \n  else if (VAR_6 == VAR_15) {\n    VAR_2 = VAR_5;\n    VAR_6 = XmlPrologTok(VAR_1->m_encoding, VAR_2, VAR_3, &VAR_5);\n  }\n\n  VAR_1->m_processor = VAR_16;\n  return doProlog(VAR_1, VAR_1->m_encoding, VAR_2, VAR_3, VAR_6, VAR_5, VAR_4,\n                  (XML_Bool)! VAR_1->m_parsingStatus.finalBuffer);\n}",
  "func_graph_path_before": null,
  "func": "static enum XML_Error PTRCALL\nexternalParEntProcessor(XML_Parser parser, const char *s, const char *end,\n                        const char **nextPtr) {\n  const char *next = s;\n  int tok;\n\n  tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  if (tok <= 0) {\n    if (! parser->m_parsingStatus.finalBuffer && tok != XML_TOK_INVALID) {\n      *nextPtr = s;\n      return XML_ERROR_NONE;\n    }\n    switch (tok) {\n    case XML_TOK_INVALID:\n      return XML_ERROR_INVALID_TOKEN;\n    case XML_TOK_PARTIAL:\n      return XML_ERROR_UNCLOSED_TOKEN;\n    case XML_TOK_PARTIAL_CHAR:\n      return XML_ERROR_PARTIAL_CHAR;\n    case XML_TOK_NONE: /* start == end */\n    default:\n      break;\n    }\n  }\n  /* This would cause the next stage, i.e. doProlog to be passed XML_TOK_BOM.\n     However, when parsing an external subset, doProlog will not accept a BOM\n     as valid, and report a syntax error, so we have to skip the BOM\n  */\n  else if (tok == XML_TOK_BOM) {\n    s = next;\n    tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  }\n\n  parser->m_processor = prologProcessor;\n  return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                  (XML_Bool)! parser->m_parsingStatus.finalBuffer, XML_TRUE);\n}",
  "abstract_func": "static enum XML_Error VAR_0\nexternalParEntProcessor(XML_Parser VAR_1, const char *VAR_2, const char *VAR_3,\n                        const char **VAR_4) {\n  const char *VAR_5 = VAR_2;\n  int VAR_6;\n\n  VAR_6 = XmlPrologTok(VAR_1->m_encoding, VAR_2, VAR_3, &VAR_5);\n  if (VAR_6 <= 0) {\n    if (! VAR_1->m_parsingStatus.finalBuffer && VAR_6 != VAR_7) {\n      *VAR_4 = VAR_2;\n      return VAR_8;\n    }\n    switch (VAR_6) {\n    case VAR_7:\n      return VAR_9;\n    case VAR_10:\n      return VAR_11;\n    case VAR_12:\n      return VAR_13;\n    case VAR_14: /* COMMENT_0 */\n    default:\n      break;\n    }\n  }\n  /* COMMENT_1 */\n                                                                             \n                                                                    \n    \n  else if (VAR_6 == VAR_15) {\n    VAR_2 = VAR_5;\n    VAR_6 = XmlPrologTok(VAR_1->m_encoding, VAR_2, VAR_3, &VAR_5);\n  }\n\n  VAR_1->m_processor = VAR_16;\n  return doProlog(VAR_1, VAR_1->m_encoding, VAR_2, VAR_3, VAR_6, VAR_5, VAR_4,\n                  (XML_Bool)! VAR_1->m_parsingStatus.finalBuffer, VAR_17);\n}",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -33,5 +33,5 @@\n \n   parser->m_processor = prologProcessor;\n   return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n-                  (XML_Bool)! parser->m_parsingStatus.finalBuffer);\n+                  (XML_Bool)! parser->m_parsingStatus.finalBuffer, XML_TRUE);\n }",
  "diff_line_info": {
    "deleted_lines": [
      "                  (XML_Bool)! parser->m_parsingStatus.finalBuffer);"
    ],
    "added_lines": [
      "                  (XML_Bool)! parser->m_parsingStatus.finalBuffer, XML_TRUE);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libexpat/libexpat/pull/318",
  "description": {
    "pr_info": {
      "title": "[CVE-2019-15903] Deny internal entities closing the doctype (for #317)",
      "number": 318
    },
    "comment": [
      "Related to #317, work in progress.\r\n\r\nReview wanted!\r\n\r\nCC @yuweol @RMJ10 @DerDakon",
      "Unless someone hits the brakes, I'm aiming to merge at Tuesday 2019-09-03 evening, then requesting a CVE, waiting for the CVE request reply, then making a new release.",
      "That looks eminently sensible to me.  Is there anything else we should be disallowing from internal entities that we currently allow?  I don't think so, but I haven't looked very hard.",
      "Rhodri, thanks for the review!"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9"
}