{
  "cve_id": "CVE-2017-1000209",
  "cwe_ids": [
    "CWE-295"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:N/A:N",
  "cvss_is_v3": false,
  "repo_name": "TakahikoKawasaki/nv-websocket-client",
  "commit_msg": "Verify that certificate is valid for server hostname\n\nWithout this change, the WebSocket library will accept\na trusted certificate issued for domain A when connecting\nto domain B. This could be exploited for Man-in-the-middle\nattacks.\n\nThe underlying issue is that Java considers hostname\nverification to be a part of HTTPS and as such, will\nnot perform it by default.\n\nThis change adds the default HostnameVerifier used\nby Android, which in recent versions is derived from\nOkHttp. Minor changes were made to make it build for\nJava 1.6.\n\nTested with and without a proxy configured.",
  "commit_hash": "feb9c8302757fd279f4cfc99cbcdfb6ee709402d",
  "git_url": "https://github.com/TakahikoKawasaki/nv-websocket-client/commit/feb9c8302757fd279f4cfc99cbcdfb6ee709402d",
  "file_path": "src/main/java/com/neovisionaries/ws/client/SocketConnector.java",
  "func_name": "doConnect",
  "func_before": "private void doConnect() throws WebSocketException\n    {\n        // True if a proxy server is set.\n        boolean proxied = mProxyHandshaker != null;\n\n        try\n        {\n            // Connect to the server (either a proxy or a WebSocket endpoint).\n            mSocket.connect(mAddress.toInetSocketAddress(), mConnectionTimeout);\n        }\n        catch (IOException e)\n        {\n            // Failed to connect the server.\n            String message = String.format(\"Failed to connect to %s'%s': %s\",\n                (proxied ? \"the proxy \" : \"\"), mAddress, e.getMessage());\n\n            // Raise an exception with SOCKET_CONNECT_ERROR.\n            throw new WebSocketException(WebSocketError.SOCKET_CONNECT_ERROR, message, e);\n        }\n\n        // If a proxy server is set.\n        if (proxied)\n        {\n            // Perform handshake with the proxy server.\n            // SSL handshake is performed as necessary, too.\n            handshake();\n        }\n    }",
  "abstract_func_before": "private void doConnect() throws WebSocketException\n    {\n        /* COMMENT_0 */\n        boolean VAR_0 = VAR_1 != null;\n\n        try\n        {\n            /* COMMENT_1 */\n            VAR_2.connect(VAR_3.toInetSocketAddress(), VAR_4);\n        }\n        catch (IOException VAR_5)\n        {\n            /* COMMENT_2 */\n            String VAR_6 = VAR_7.format(\"Failed to connect to %s'%s': %s\",\n                (VAR_0 ? \"the proxy \" : \"\"), VAR_3, VAR_5.getMessage());\n\n            /* COMMENT_3 */\n            throw new WebSocketException(VAR_8.SOCKET_CONNECT_ERROR, VAR_6, VAR_5);\n        }\n\n        /* COMMENT_4 */\n        if (VAR_0)\n        {\n            /* COMMENT_5 */\n            /* COMMENT_6 */\n            handshake();\n        }\n    }",
  "func_graph_path_before": "TakahikoKawasaki/nv-websocket-client/feb9c8302757fd279f4cfc99cbcdfb6ee709402d/SocketConnector.java/vul/before/0.json",
  "func": "private void doConnect() throws WebSocketException\n    {\n        // True if a proxy server is set.\n        boolean proxied = mProxyHandshaker != null;\n\n        try\n        {\n            // Connect to the server (either a proxy or a WebSocket endpoint).\n            mSocket.connect(mAddress.toInetSocketAddress(), mConnectionTimeout);\n            \n            if (mSocket instanceof SSLSocket)\n            {\n                // Verify that the hostname matches the certificate here since\n                // this is not automatically done by the SSLSocket.\n                OkHostnameVerifier hostnameVerifier = OkHostnameVerifier.INSTANCE;\n                \n                SSLSession sslSession = ((SSLSocket) mSocket).getSession();\n            \n                if (!hostnameVerifier.verify(mAddress.getHostname(), sslSession))\n                {\n                    throw new SSLPeerUnverifiedException(\"Hostname does not match certificate (\"\n                            + sslSession.getPeerPrincipal() + \")\");\n                }\n            }\n        }\n        catch (IOException e)\n        {\n            // Failed to connect the server.\n            String message = String.format(\"Failed to connect to %s'%s': %s\",\n                (proxied ? \"the proxy \" : \"\"), mAddress, e.getMessage());\n\n            // Raise an exception with SOCKET_CONNECT_ERROR.\n            throw new WebSocketException(WebSocketError.SOCKET_CONNECT_ERROR, message, e);\n        }\n\n        // If a proxy server is set.\n        if (proxied)\n        {\n            // Perform handshake with the proxy server.\n            // SSL handshake is performed as necessary, too.\n            handshake();\n        }\n    }",
  "abstract_func": "private void doConnect() throws WebSocketException\n    {\n        /* COMMENT_0 */\n        boolean VAR_0 = VAR_1 != null;\n\n        try\n        {\n            /* COMMENT_1 */\n            VAR_2.connect(VAR_3.toInetSocketAddress(), VAR_4);\n            \n            if (VAR_2 instanceof SSLSocket)\n            {\n                /* COMMENT_2 */\n                /* COMMENT_3 */\n                OkHostnameVerifier VAR_5 = VAR_6.INSTANCE;\n                \n                SSLSession VAR_7 = ((SSLSocket) VAR_2).getSession();\n            \n                if (!VAR_5.verify(VAR_3.getHostname(), VAR_7))\n                {\n                    throw new SSLPeerUnverifiedException(\"Hostname does not match certificate (\"\n                            + VAR_7.getPeerPrincipal() + \")\");\n                }\n            }\n        }\n        catch (IOException VAR_8)\n        {\n            /* COMMENT_4 */\n            String VAR_9 = VAR_10.format(\"Failed to connect to %s'%s': %s\",\n                (VAR_0 ? \"the proxy \" : \"\"), VAR_3, VAR_8.getMessage());\n\n            /* COMMENT_5 */\n            throw new WebSocketException(VAR_11.SOCKET_CONNECT_ERROR, VAR_9, VAR_8);\n        }\n\n        /* COMMENT_6 */\n        if (VAR_0)\n        {\n            /* COMMENT_7 */\n            /* COMMENT_8 */\n            handshake();\n        }\n    }",
  "func_graph_path": "TakahikoKawasaki/nv-websocket-client/feb9c8302757fd279f4cfc99cbcdfb6ee709402d/SocketConnector.java/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -7,6 +7,21 @@\n         {\n             // Connect to the server (either a proxy or a WebSocket endpoint).\n             mSocket.connect(mAddress.toInetSocketAddress(), mConnectionTimeout);\n+            \n+            if (mSocket instanceof SSLSocket)\n+            {\n+                // Verify that the hostname matches the certificate here since\n+                // this is not automatically done by the SSLSocket.\n+                OkHostnameVerifier hostnameVerifier = OkHostnameVerifier.INSTANCE;\n+                \n+                SSLSession sslSession = ((SSLSocket) mSocket).getSession();\n+            \n+                if (!hostnameVerifier.verify(mAddress.getHostname(), sslSession))\n+                {\n+                    throw new SSLPeerUnverifiedException(\"Hostname does not match certificate (\"\n+                            + sslSession.getPeerPrincipal() + \")\");\n+                }\n+            }\n         }\n         catch (IOException e)\n         {",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "            ",
      "            if (mSocket instanceof SSLSocket)",
      "            {",
      "                // Verify that the hostname matches the certificate here since",
      "                // this is not automatically done by the SSLSocket.",
      "                OkHostnameVerifier hostnameVerifier = OkHostnameVerifier.INSTANCE;",
      "                ",
      "                SSLSession sslSession = ((SSLSocket) mSocket).getSession();",
      "            ",
      "                if (!hostnameVerifier.verify(mAddress.getHostname(), sslSession))",
      "                {",
      "                    throw new SSLPeerUnverifiedException(\"Hostname does not match certificate (\"",
      "                            + sslSession.getPeerPrincipal() + \")\");",
      "                }",
      "            }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/TakahikoKawasaki/nv-websocket-client/pull/107",
  "description": {
    "pr_info": {
      "title": "Verify that certificate is valid for server hostname",
      "number": 107
    },
    "comment": [
      "Without this change, the WebSocket library will accept\r\na trusted certificate issued for domain A when connecting\r\nto domain B. This could be exploited for Man-in-the-middle\r\nattacks.\r\n\r\nThe underlying issue is that Java considers hostname\r\nverification to be a part of HTTPS and as such, will\r\nnot perform it by default.\r\n\r\nThis change adds the default HostnameVerifier used\r\nby Android, which in recent versions is derived from\r\nOkHttp. Minor changes were made to make it build for\r\nJava 1.6.\r\n\r\nTested with and without a proxy configured.",
      "@TakahikoKawasaki A public test server that can be used to reliably reproduce this issue is available to you upon request.\r\n\r\n**Status with this change:**\r\n- **No proxy:** Working\r\n- **Standard HTTP proxy:** Working (verifies that hostname of the wss:// request matches certificate of the endpoint server)\r\n- **HTTPS proxy:** Untested (likely not working but I was unable to find a suitable proxy to test this with)",
      "@blunden Thank you very much. Apparently, you have much more knowledge about this field than I.",
      "@blunden Released nv-websocket-client version 2.2. `WebSocket.connect()` method throws `HostnameUnverifiedException` (a subclass of `WebSocketException`) when the certificate of the peer does not match the expected hostname. Thank you for your contribution.",
      "@TakahikoKawasaki Thanks for merging it.\r\n\r\nYou will likely need to add hostname verification of the proxy's certificate if it's an HTTPS proxy. Like I said above, I don't have any of those to test with so currently it won't verify the hostname of the proxy, which it really should. It would probably be a simple fix but the ProxyHandshaker or Address would have to be able to return whether the user specified an http or https proxy address. You could then just add an if-statement based on that and a similar hostname verification of mAddress.getHostname() (which I think will be the proxy hostname) inside it. It did not do it myself because I couldn't test it and didn't want to risk breaking it."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}