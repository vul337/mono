{
  "cve_id": "CVE-2017-17479",
  "cwe_ids": [
    "CWE-787",
    "CWE-476"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "uclouvain/openjpeg",
  "commit_msg": "jp2: convert: fix null pointer dereference\n\nTile components in a JP2 image might have null data pointer by defining a\nzero component size (for example using large horizontal or vertical\nsampling periods). This null data pointer leads to null image component\ndata pointer, causing crash when dereferenced without != null check in\nimagetopnm.\n\nAdd != null check.\n\nThis commit addresses #1152 (CVE-2018-18088).",
  "commit_hash": "cab352e249ed3372dd9355c85e837613fff98fa2",
  "git_url": "https://github.com/uclouvain/openjpeg/commit/cab352e249ed3372dd9355c85e837613fff98fa2",
  "file_path": "src/bin/jp2/convert.c",
  "func_name": "imagetopnm",
  "func_before": "int imagetopnm(opj_image_t * image, const char *outfile, int force_split)\n{\n    int *red, *green, *blue, *alpha;\n    int wr, hr, max;\n    int i;\n    unsigned int compno, ncomp;\n    int adjustR, adjustG, adjustB, adjustA;\n    int fails, two, want_gray, has_alpha, triple;\n    int prec, v;\n    FILE *fdest = NULL;\n    const char *tmp = outfile;\n    char *destname;\n\n    alpha = NULL;\n\n    if ((prec = (int)image->comps[0].prec) > 16) {\n        fprintf(stderr, \"%s:%d:imagetopnm\\n\\tprecision %d is larger than 16\"\n                \"\\n\\t: refused.\\n\", __FILE__, __LINE__, prec);\n        return 1;\n    }\n    two = has_alpha = 0;\n    fails = 1;\n    ncomp = image->numcomps;\n\n    while (*tmp) {\n        ++tmp;\n    }\n    tmp -= 2;\n    want_gray = (*tmp == 'g' || *tmp == 'G');\n    ncomp = image->numcomps;\n\n    if (want_gray) {\n        ncomp = 1;\n    }\n\n    if ((force_split == 0) && ncomp >= 2 &&\n            are_comps_similar(image)) {\n        fdest = fopen(outfile, \"wb\");\n\n        if (!fdest) {\n            fprintf(stderr, \"ERROR -> failed to open %s for writing\\n\", outfile);\n            return fails;\n        }\n        two = (prec > 8);\n        triple = (ncomp > 2);\n        wr = (int)image->comps[0].w;\n        hr = (int)image->comps[0].h;\n        max = (1 << prec) - 1;\n        has_alpha = (ncomp == 4 || ncomp == 2);\n\n        red = image->comps[0].data;\n\n        if (triple) {\n            green = image->comps[1].data;\n            blue = image->comps[2].data;\n        } else {\n            green = blue = NULL;\n        }\n\n        if (has_alpha) {\n            const char *tt = (triple ? \"RGB_ALPHA\" : \"GRAYSCALE_ALPHA\");\n\n            fprintf(fdest, \"P7\\n# OpenJPEG-%s\\nWIDTH %d\\nHEIGHT %d\\nDEPTH %u\\n\"\n                    \"MAXVAL %d\\nTUPLTYPE %s\\nENDHDR\\n\", opj_version(),\n                    wr, hr, ncomp, max, tt);\n            alpha = image->comps[ncomp - 1].data;\n            adjustA = (image->comps[ncomp - 1].sgnd ?\n                       1 << (image->comps[ncomp - 1].prec - 1) : 0);\n        } else {\n            fprintf(fdest, \"P6\\n# OpenJPEG-%s\\n%d %d\\n%d\\n\",\n                    opj_version(), wr, hr, max);\n            adjustA = 0;\n        }\n        adjustR = (image->comps[0].sgnd ? 1 << (image->comps[0].prec - 1) : 0);\n\n        if (triple) {\n            adjustG = (image->comps[1].sgnd ? 1 << (image->comps[1].prec - 1) : 0);\n            adjustB = (image->comps[2].sgnd ? 1 << (image->comps[2].prec - 1) : 0);\n        } else {\n            adjustG = adjustB = 0;\n        }\n\n        for (i = 0; i < wr * hr; ++i) {\n            if (two) {\n                v = *red + adjustR;\n                ++red;\n                if (v > 65535) {\n                    v = 65535;\n                } else if (v < 0) {\n                    v = 0;\n                }\n\n                /* netpbm: */\n                fprintf(fdest, \"%c%c\", (unsigned char)(v >> 8), (unsigned char)v);\n\n                if (triple) {\n                    v = *green + adjustG;\n                    ++green;\n                    if (v > 65535) {\n                        v = 65535;\n                    } else if (v < 0) {\n                        v = 0;\n                    }\n\n                    /* netpbm: */\n                    fprintf(fdest, \"%c%c\", (unsigned char)(v >> 8), (unsigned char)v);\n\n                    v =  *blue + adjustB;\n                    ++blue;\n                    if (v > 65535) {\n                        v = 65535;\n                    } else if (v < 0) {\n                        v = 0;\n                    }\n\n                    /* netpbm: */\n                    fprintf(fdest, \"%c%c\", (unsigned char)(v >> 8), (unsigned char)v);\n\n                }/* if(triple) */\n\n                if (has_alpha) {\n                    v = *alpha + adjustA;\n                    ++alpha;\n                    if (v > 65535) {\n                        v = 65535;\n                    } else if (v < 0) {\n                        v = 0;\n                    }\n\n                    /* netpbm: */\n                    fprintf(fdest, \"%c%c\", (unsigned char)(v >> 8), (unsigned char)v);\n                }\n                continue;\n\n            }   /* if(two) */\n\n            /* prec <= 8: */\n            v = *red++;\n            if (v > 255) {\n                v = 255;\n            } else if (v < 0) {\n                v = 0;\n            }\n\n            fprintf(fdest, \"%c\", (unsigned char)v);\n            if (triple) {\n                v = *green++;\n                if (v > 255) {\n                    v = 255;\n                } else if (v < 0) {\n                    v = 0;\n                }\n\n                fprintf(fdest, \"%c\", (unsigned char)v);\n                v = *blue++;\n                if (v > 255) {\n                    v = 255;\n                } else if (v < 0) {\n                    v = 0;\n                }\n\n                fprintf(fdest, \"%c\", (unsigned char)v);\n            }\n            if (has_alpha) {\n                v = *alpha++;\n                if (v > 255) {\n                    v = 255;\n                } else if (v < 0) {\n                    v = 0;\n                }\n\n                fprintf(fdest, \"%c\", (unsigned char)v);\n            }\n        }   /* for(i */\n\n        fclose(fdest);\n        return 0;\n    }\n\n    /* YUV or MONO: */\n\n    if (image->numcomps > ncomp) {\n        fprintf(stderr, \"WARNING -> [PGM file] Only the first component\\n\");\n        fprintf(stderr, \"           is written to the file\\n\");\n    }\n    destname = (char*)malloc(strlen(outfile) + 8);\n    if (destname == NULL) {\n        fprintf(stderr, \"imagetopnm: memory out\\n\");\n        return 1;\n    }\n    for (compno = 0; compno < ncomp; compno++) {\n        if (ncomp > 1) {\n            /*sprintf(destname, \"%d.%s\", compno, outfile);*/\n            const size_t olen = strlen(outfile);\n            const size_t dotpos = olen - 4;\n\n            strncpy(destname, outfile, dotpos);\n            sprintf(destname + dotpos, \"_%u.pgm\", compno);\n        } else {\n            sprintf(destname, \"%s\", outfile);\n        }\n\n        fdest = fopen(destname, \"wb\");\n        if (!fdest) {\n            fprintf(stderr, \"ERROR -> failed to open %s for writing\\n\", destname);\n            free(destname);\n            return 1;\n        }\n        wr = (int)image->comps[compno].w;\n        hr = (int)image->comps[compno].h;\n        prec = (int)image->comps[compno].prec;\n        max = (1 << prec) - 1;\n\n        fprintf(fdest, \"P5\\n#OpenJPEG-%s\\n%d %d\\n%d\\n\",\n                opj_version(), wr, hr, max);\n\n        red = image->comps[compno].data;\n        adjustR =\n            (image->comps[compno].sgnd ? 1 << (image->comps[compno].prec - 1) : 0);\n\n        if (prec > 8) {\n            for (i = 0; i < wr * hr; i++) {\n                v = *red + adjustR;\n                ++red;\n                if (v > 65535) {\n                    v = 65535;\n                } else if (v < 0) {\n                    v = 0;\n                }\n\n                /* netpbm: */\n                fprintf(fdest, \"%c%c\", (unsigned char)(v >> 8), (unsigned char)v);\n\n                if (has_alpha) {\n                    v = *alpha++;\n                    if (v > 65535) {\n                        v = 65535;\n                    } else if (v < 0) {\n                        v = 0;\n                    }\n\n                    /* netpbm: */\n                    fprintf(fdest, \"%c%c\", (unsigned char)(v >> 8), (unsigned char)v);\n                }\n            }/* for(i */\n        } else { /* prec <= 8 */\n            for (i = 0; i < wr * hr; ++i) {\n                v = *red + adjustR;\n                ++red;\n                if (v > 255) {\n                    v = 255;\n                } else if (v < 0) {\n                    v = 0;\n                }\n\n                fprintf(fdest, \"%c\", (unsigned char)v);\n            }\n        }\n        fclose(fdest);\n    } /* for (compno */\n    free(destname);\n\n    return 0;\n}",
  "abstract_func_before": "int imagetopnm(opj_image_t * VAR_0, const char *VAR_1, int VAR_2)\n{\n    int *VAR_3, *VAR_4, *VAR_5, *VAR_6;\n    int VAR_7, VAR_8, VAR_9;\n    int VAR_10;\n    unsigned int VAR_11, VAR_12;\n    int VAR_13, VAR_14, VAR_15, VAR_16;\n    int VAR_17, VAR_18, VAR_19, VAR_20, VAR_21;\n    int VAR_22, VAR_23;\n    FILE *VAR_24 = NULL;\n    const char *VAR_25 = VAR_1;\n    char *VAR_26;\n\n    VAR_6 = NULL;\n\n    if ((VAR_22 = (int)VAR_0->comps[0].prec) > 16) {\n        fprintf(VAR_27, \"%s:%d:imagetopnm\\n\\tprecision %d is larger than 16\"\n                \"\\n\\t: refused.\\n\", VAR_28, VAR_29, VAR_22);\n        return 1;\n    }\n    VAR_18 = VAR_20 = 0;\n    VAR_17 = 1;\n    VAR_12 = VAR_0->numcomps;\n\n    while (*VAR_25) {\n        ++VAR_25;\n    }\n    VAR_25 -= 2;\n    VAR_19 = (*VAR_25 == 'g' || *VAR_25 == 'G');\n    VAR_12 = VAR_0->numcomps;\n\n    if (VAR_19) {\n        VAR_12 = 1;\n    }\n\n    if ((VAR_2 == 0) && VAR_12 >= 2 &&\n            are_comps_similar(VAR_0)) {\n        VAR_24 = fopen(VAR_1, \"wb\");\n\n        if (!VAR_24) {\n            fprintf(VAR_27, \"ERROR -> failed to open %s for writing\\n\", VAR_1);\n            return VAR_17;\n        }\n        VAR_18 = (VAR_22 > 8);\n        VAR_21 = (VAR_12 > 2);\n        VAR_7 = (int)VAR_0->comps[0].w;\n        VAR_8 = (int)VAR_0->comps[0].h;\n        VAR_9 = (1 << VAR_22) - 1;\n        VAR_20 = (VAR_12 == 4 || VAR_12 == 2);\n\n        VAR_3 = VAR_0->comps[0].data;\n\n        if (VAR_21) {\n            VAR_4 = VAR_0->comps[1].data;\n            VAR_5 = VAR_0->comps[2].data;\n        } else {\n            VAR_4 = VAR_5 = NULL;\n        }\n\n        if (VAR_20) {\n            const char *VAR_30 = (VAR_21 ? \"RGB_ALPHA\" : \"GRAYSCALE_ALPHA\");\n\n            fprintf(VAR_24, \"P7\\n# OpenJPEG-%s\\nWIDTH %d\\nHEIGHT %d\\nDEPTH %u\\n\"\n                    \"MAXVAL %d\\nTUPLTYPE %s\\nENDHDR\\n\", opj_version(),\n                    VAR_7, VAR_8, VAR_12, VAR_9, VAR_30);\n            VAR_6 = VAR_0->comps[VAR_12 - 1].data;\n            VAR_16 = (VAR_0->comps[VAR_12 - 1].sgnd ?\n                       1 << (VAR_0->comps[VAR_12 - 1].prec - 1) : 0);\n        } else {\n            fprintf(VAR_24, \"P6\\n# OpenJPEG-%s\\n%d %d\\n%d\\n\",\n                    opj_version(), VAR_7, VAR_8, VAR_9);\n            VAR_16 = 0;\n        }\n        VAR_13 = (VAR_0->comps[0].sgnd ? 1 << (VAR_0->comps[0].prec - 1) : 0);\n\n        if (VAR_21) {\n            VAR_14 = (VAR_0->comps[1].sgnd ? 1 << (VAR_0->comps[1].prec - 1) : 0);\n            VAR_15 = (VAR_0->comps[2].sgnd ? 1 << (VAR_0->comps[2].prec - 1) : 0);\n        } else {\n            VAR_14 = VAR_15 = 0;\n        }\n\n        for (VAR_10 = 0; VAR_10 < VAR_7 * VAR_8; ++VAR_10) {\n            if (VAR_18) {\n                VAR_23 = *VAR_3 + VAR_13;\n                ++VAR_3;\n                if (VAR_23 > 65535) {\n                    VAR_23 = 65535;\n                } else if (VAR_23 < 0) {\n                    VAR_23 = 0;\n                }\n\n                /* COMMENT_0 */\n                fprintf(VAR_24, \"%c%c\", (unsigned char)(VAR_23 >> 8), (unsigned char)VAR_23);\n\n                if (VAR_21) {\n                    VAR_23 = *VAR_4 + VAR_14;\n                    ++VAR_4;\n                    if (VAR_23 > 65535) {\n                        VAR_23 = 65535;\n                    } else if (VAR_23 < 0) {\n                        VAR_23 = 0;\n                    }\n\n                    /* COMMENT_0 */\n                    fprintf(VAR_24, \"%c%c\", (unsigned char)(VAR_23 >> 8), (unsigned char)VAR_23);\n\n                    VAR_23 =  *VAR_5 + VAR_15;\n                    ++VAR_5;\n                    if (VAR_23 > 65535) {\n                        VAR_23 = 65535;\n                    } else if (VAR_23 < 0) {\n                        VAR_23 = 0;\n                    }\n\n                    /* COMMENT_0 */\n                    fprintf(VAR_24, \"%c%c\", (unsigned char)(VAR_23 >> 8), (unsigned char)VAR_23);\n\n                }/* COMMENT_1 */\n\n                if (VAR_20) {\n                    VAR_23 = *VAR_6 + VAR_16;\n                    ++VAR_6;\n                    if (VAR_23 > 65535) {\n                        VAR_23 = 65535;\n                    } else if (VAR_23 < 0) {\n                        VAR_23 = 0;\n                    }\n\n                    /* COMMENT_0 */\n                    fprintf(VAR_24, \"%c%c\", (unsigned char)(VAR_23 >> 8), (unsigned char)VAR_23);\n                }\n                continue;\n\n            }   /* COMMENT_2 */\n\n            /* COMMENT_3 */\n            VAR_23 = *VAR_3++;\n            if (VAR_23 > 255) {\n                VAR_23 = 255;\n            } else if (VAR_23 < 0) {\n                VAR_23 = 0;\n            }\n\n            fprintf(VAR_24, \"%c\", (unsigned char)VAR_23);\n            if (VAR_21) {\n                VAR_23 = *VAR_4++;\n                if (VAR_23 > 255) {\n                    VAR_23 = 255;\n                } else if (VAR_23 < 0) {\n                    VAR_23 = 0;\n                }\n\n                fprintf(VAR_24, \"%c\", (unsigned char)VAR_23);\n                VAR_23 = *VAR_5++;\n                if (VAR_23 > 255) {\n                    VAR_23 = 255;\n                } else if (VAR_23 < 0) {\n                    VAR_23 = 0;\n                }\n\n                fprintf(VAR_24, \"%c\", (unsigned char)VAR_23);\n            }\n            if (VAR_20) {\n                VAR_23 = *VAR_6++;\n                if (VAR_23 > 255) {\n                    VAR_23 = 255;\n                } else if (VAR_23 < 0) {\n                    VAR_23 = 0;\n                }\n\n                fprintf(VAR_24, \"%c\", (unsigned char)VAR_23);\n            }\n        }   /* COMMENT_4 */\n\n        fclose(VAR_24);\n        return 0;\n    }\n\n    /* COMMENT_5 */\n\n    if (VAR_0->numcomps > VAR_12) {\n        fprintf(VAR_27, \"WARNING -> [PGM file] Only the first component\\n\");\n        fprintf(VAR_27, \"           is written to the file\\n\");\n    }\n    VAR_26 = (char*)malloc(strlen(VAR_1) + 8);\n    if (VAR_26 == NULL) {\n        fprintf(VAR_27, \"imagetopnm: memory out\\n\");\n        return 1;\n    }\n    for (VAR_11 = 0; VAR_11 < VAR_12; VAR_11++) {\n        if (VAR_12 > 1) {\n            /* COMMENT_6 */\n            const size_t VAR_31 = strlen(VAR_1);\n            const size_t VAR_32 = VAR_31 - 4;\n\n            strncpy(VAR_26, VAR_1, VAR_32);\n            sprintf(VAR_26 + VAR_32, \"_%u.pgm\", VAR_11);\n        } else {\n            sprintf(VAR_26, \"%s\", VAR_1);\n        }\n\n        VAR_24 = fopen(VAR_26, \"wb\");\n        if (!VAR_24) {\n            fprintf(VAR_27, \"ERROR -> failed to open %s for writing\\n\", VAR_26);\n            free(VAR_26);\n            return 1;\n        }\n        VAR_7 = (int)VAR_0->comps[VAR_11].w;\n        VAR_8 = (int)VAR_0->comps[VAR_11].h;\n        VAR_22 = (int)VAR_0->comps[VAR_11].prec;\n        VAR_9 = (1 << VAR_22) - 1;\n\n        fprintf(VAR_24, \"P5\\n#OpenJPEG-%s\\n%d %d\\n%d\\n\",\n                opj_version(), VAR_7, VAR_8, VAR_9);\n\n        VAR_3 = VAR_0->comps[VAR_11].data;\n        VAR_13 =\n            (VAR_0->comps[VAR_11].sgnd ? 1 << (VAR_0->comps[VAR_11].prec - 1) : 0);\n\n        if (VAR_22 > 8) {\n            for (VAR_10 = 0; VAR_10 < VAR_7 * VAR_8; VAR_10++) {\n                VAR_23 = *VAR_3 + VAR_13;\n                ++VAR_3;\n                if (VAR_23 > 65535) {\n                    VAR_23 = 65535;\n                } else if (VAR_23 < 0) {\n                    VAR_23 = 0;\n                }\n\n                /* COMMENT_0 */\n                fprintf(VAR_24, \"%c%c\", (unsigned char)(VAR_23 >> 8), (unsigned char)VAR_23);\n\n                if (VAR_20) {\n                    VAR_23 = *VAR_6++;\n                    if (VAR_23 > 65535) {\n                        VAR_23 = 65535;\n                    } else if (VAR_23 < 0) {\n                        VAR_23 = 0;\n                    }\n\n                    /* COMMENT_0 */\n                    fprintf(VAR_24, \"%c%c\", (unsigned char)(VAR_23 >> 8), (unsigned char)VAR_23);\n                }\n            }/* COMMENT_4 */\n        } else { /* COMMENT_7 */\n            for (VAR_10 = 0; VAR_10 < VAR_7 * VAR_8; ++VAR_10) {\n                VAR_23 = *VAR_3 + VAR_13;\n                ++VAR_3;\n                if (VAR_23 > 255) {\n                    VAR_23 = 255;\n                } else if (VAR_23 < 0) {\n                    VAR_23 = 0;\n                }\n\n                fprintf(VAR_24, \"%c\", (unsigned char)VAR_23);\n            }\n        }\n        fclose(VAR_24);\n    } /* COMMENT_8 */\n    free(VAR_26);\n\n    return 0;\n}",
  "func_graph_path_before": "uclouvain/openjpeg/cab352e249ed3372dd9355c85e837613fff98fa2/convert.c/vul/before/0.json",
  "func": "int imagetopnm(opj_image_t * image, const char *outfile, int force_split)\n{\n    int *red, *green, *blue, *alpha;\n    int wr, hr, max;\n    int i;\n    unsigned int compno, ncomp;\n    int adjustR, adjustG, adjustB, adjustA;\n    int fails, two, want_gray, has_alpha, triple;\n    int prec, v;\n    FILE *fdest = NULL;\n    const char *tmp = outfile;\n    char *destname;\n\n    alpha = NULL;\n\n    if ((prec = (int)image->comps[0].prec) > 16) {\n        fprintf(stderr, \"%s:%d:imagetopnm\\n\\tprecision %d is larger than 16\"\n                \"\\n\\t: refused.\\n\", __FILE__, __LINE__, prec);\n        return 1;\n    }\n    two = has_alpha = 0;\n    fails = 1;\n    ncomp = image->numcomps;\n\n    while (*tmp) {\n        ++tmp;\n    }\n    tmp -= 2;\n    want_gray = (*tmp == 'g' || *tmp == 'G');\n    ncomp = image->numcomps;\n\n    if (want_gray) {\n        ncomp = 1;\n    }\n\n    if ((force_split == 0) && ncomp >= 2 &&\n            are_comps_similar(image)) {\n        fdest = fopen(outfile, \"wb\");\n\n        if (!fdest) {\n            fprintf(stderr, \"ERROR -> failed to open %s for writing\\n\", outfile);\n            return fails;\n        }\n        two = (prec > 8);\n        triple = (ncomp > 2);\n        wr = (int)image->comps[0].w;\n        hr = (int)image->comps[0].h;\n        max = (1 << prec) - 1;\n        has_alpha = (ncomp == 4 || ncomp == 2);\n\n        red = image->comps[0].data;\n\n        if (triple) {\n            green = image->comps[1].data;\n            blue = image->comps[2].data;\n        } else {\n            green = blue = NULL;\n        }\n\n        if (has_alpha) {\n            const char *tt = (triple ? \"RGB_ALPHA\" : \"GRAYSCALE_ALPHA\");\n\n            fprintf(fdest, \"P7\\n# OpenJPEG-%s\\nWIDTH %d\\nHEIGHT %d\\nDEPTH %u\\n\"\n                    \"MAXVAL %d\\nTUPLTYPE %s\\nENDHDR\\n\", opj_version(),\n                    wr, hr, ncomp, max, tt);\n            alpha = image->comps[ncomp - 1].data;\n            adjustA = (image->comps[ncomp - 1].sgnd ?\n                       1 << (image->comps[ncomp - 1].prec - 1) : 0);\n        } else {\n            fprintf(fdest, \"P6\\n# OpenJPEG-%s\\n%d %d\\n%d\\n\",\n                    opj_version(), wr, hr, max);\n            adjustA = 0;\n        }\n        adjustR = (image->comps[0].sgnd ? 1 << (image->comps[0].prec - 1) : 0);\n\n        if (triple) {\n            adjustG = (image->comps[1].sgnd ? 1 << (image->comps[1].prec - 1) : 0);\n            adjustB = (image->comps[2].sgnd ? 1 << (image->comps[2].prec - 1) : 0);\n        } else {\n            adjustG = adjustB = 0;\n        }\n\n        for (i = 0; i < wr * hr; ++i) {\n            if (two) {\n                v = *red + adjustR;\n                ++red;\n                if (v > 65535) {\n                    v = 65535;\n                } else if (v < 0) {\n                    v = 0;\n                }\n\n                /* netpbm: */\n                fprintf(fdest, \"%c%c\", (unsigned char)(v >> 8), (unsigned char)v);\n\n                if (triple) {\n                    v = *green + adjustG;\n                    ++green;\n                    if (v > 65535) {\n                        v = 65535;\n                    } else if (v < 0) {\n                        v = 0;\n                    }\n\n                    /* netpbm: */\n                    fprintf(fdest, \"%c%c\", (unsigned char)(v >> 8), (unsigned char)v);\n\n                    v =  *blue + adjustB;\n                    ++blue;\n                    if (v > 65535) {\n                        v = 65535;\n                    } else if (v < 0) {\n                        v = 0;\n                    }\n\n                    /* netpbm: */\n                    fprintf(fdest, \"%c%c\", (unsigned char)(v >> 8), (unsigned char)v);\n\n                }/* if(triple) */\n\n                if (has_alpha) {\n                    v = *alpha + adjustA;\n                    ++alpha;\n                    if (v > 65535) {\n                        v = 65535;\n                    } else if (v < 0) {\n                        v = 0;\n                    }\n\n                    /* netpbm: */\n                    fprintf(fdest, \"%c%c\", (unsigned char)(v >> 8), (unsigned char)v);\n                }\n                continue;\n\n            }   /* if(two) */\n\n            /* prec <= 8: */\n            v = *red++;\n            if (v > 255) {\n                v = 255;\n            } else if (v < 0) {\n                v = 0;\n            }\n\n            fprintf(fdest, \"%c\", (unsigned char)v);\n            if (triple) {\n                v = *green++;\n                if (v > 255) {\n                    v = 255;\n                } else if (v < 0) {\n                    v = 0;\n                }\n\n                fprintf(fdest, \"%c\", (unsigned char)v);\n                v = *blue++;\n                if (v > 255) {\n                    v = 255;\n                } else if (v < 0) {\n                    v = 0;\n                }\n\n                fprintf(fdest, \"%c\", (unsigned char)v);\n            }\n            if (has_alpha) {\n                v = *alpha++;\n                if (v > 255) {\n                    v = 255;\n                } else if (v < 0) {\n                    v = 0;\n                }\n\n                fprintf(fdest, \"%c\", (unsigned char)v);\n            }\n        }   /* for(i */\n\n        fclose(fdest);\n        return 0;\n    }\n\n    /* YUV or MONO: */\n\n    if (image->numcomps > ncomp) {\n        fprintf(stderr, \"WARNING -> [PGM file] Only the first component\\n\");\n        fprintf(stderr, \"           is written to the file\\n\");\n    }\n    destname = (char*)malloc(strlen(outfile) + 8);\n    if (destname == NULL) {\n        fprintf(stderr, \"imagetopnm: memory out\\n\");\n        return 1;\n    }\n    for (compno = 0; compno < ncomp; compno++) {\n        if (ncomp > 1) {\n            /*sprintf(destname, \"%d.%s\", compno, outfile);*/\n            const size_t olen = strlen(outfile);\n            const size_t dotpos = olen - 4;\n\n            strncpy(destname, outfile, dotpos);\n            sprintf(destname + dotpos, \"_%u.pgm\", compno);\n        } else {\n            sprintf(destname, \"%s\", outfile);\n        }\n\n        fdest = fopen(destname, \"wb\");\n        if (!fdest) {\n            fprintf(stderr, \"ERROR -> failed to open %s for writing\\n\", destname);\n            free(destname);\n            return 1;\n        }\n        wr = (int)image->comps[compno].w;\n        hr = (int)image->comps[compno].h;\n        prec = (int)image->comps[compno].prec;\n        max = (1 << prec) - 1;\n\n        fprintf(fdest, \"P5\\n#OpenJPEG-%s\\n%d %d\\n%d\\n\",\n                opj_version(), wr, hr, max);\n\n        red = image->comps[compno].data;\n        if (!red) {\n            fclose(fdest);\n            continue;\n        }\n\n        adjustR =\n            (image->comps[compno].sgnd ? 1 << (image->comps[compno].prec - 1) : 0);\n\n        if (prec > 8) {\n            for (i = 0; i < wr * hr; i++) {\n                v = *red + adjustR;\n                ++red;\n                if (v > 65535) {\n                    v = 65535;\n                } else if (v < 0) {\n                    v = 0;\n                }\n\n                /* netpbm: */\n                fprintf(fdest, \"%c%c\", (unsigned char)(v >> 8), (unsigned char)v);\n\n                if (has_alpha) {\n                    v = *alpha++;\n                    if (v > 65535) {\n                        v = 65535;\n                    } else if (v < 0) {\n                        v = 0;\n                    }\n\n                    /* netpbm: */\n                    fprintf(fdest, \"%c%c\", (unsigned char)(v >> 8), (unsigned char)v);\n                }\n            }/* for(i */\n        } else { /* prec <= 8 */\n            for (i = 0; i < wr * hr; ++i) {\n                v = *red + adjustR;\n                ++red;\n                if (v > 255) {\n                    v = 255;\n                } else if (v < 0) {\n                    v = 0;\n                }\n\n                fprintf(fdest, \"%c\", (unsigned char)v);\n            }\n        }\n        fclose(fdest);\n    } /* for (compno */\n    free(destname);\n\n    return 0;\n}",
  "abstract_func": "int imagetopnm(opj_image_t * VAR_0, const char *VAR_1, int VAR_2)\n{\n    int *VAR_3, *VAR_4, *VAR_5, *VAR_6;\n    int VAR_7, VAR_8, VAR_9;\n    int VAR_10;\n    unsigned int VAR_11, VAR_12;\n    int VAR_13, VAR_14, VAR_15, VAR_16;\n    int VAR_17, VAR_18, VAR_19, VAR_20, VAR_21;\n    int VAR_22, VAR_23;\n    FILE *VAR_24 = NULL;\n    const char *VAR_25 = VAR_1;\n    char *VAR_26;\n\n    VAR_6 = NULL;\n\n    if ((VAR_22 = (int)VAR_0->comps[0].prec) > 16) {\n        fprintf(VAR_27, \"%s:%d:imagetopnm\\n\\tprecision %d is larger than 16\"\n                \"\\n\\t: refused.\\n\", VAR_28, VAR_29, VAR_22);\n        return 1;\n    }\n    VAR_18 = VAR_20 = 0;\n    VAR_17 = 1;\n    VAR_12 = VAR_0->numcomps;\n\n    while (*VAR_25) {\n        ++VAR_25;\n    }\n    VAR_25 -= 2;\n    VAR_19 = (*VAR_25 == 'g' || *VAR_25 == 'G');\n    VAR_12 = VAR_0->numcomps;\n\n    if (VAR_19) {\n        VAR_12 = 1;\n    }\n\n    if ((VAR_2 == 0) && VAR_12 >= 2 &&\n            are_comps_similar(VAR_0)) {\n        VAR_24 = fopen(VAR_1, \"wb\");\n\n        if (!VAR_24) {\n            fprintf(VAR_27, \"ERROR -> failed to open %s for writing\\n\", VAR_1);\n            return VAR_17;\n        }\n        VAR_18 = (VAR_22 > 8);\n        VAR_21 = (VAR_12 > 2);\n        VAR_7 = (int)VAR_0->comps[0].w;\n        VAR_8 = (int)VAR_0->comps[0].h;\n        VAR_9 = (1 << VAR_22) - 1;\n        VAR_20 = (VAR_12 == 4 || VAR_12 == 2);\n\n        VAR_3 = VAR_0->comps[0].data;\n\n        if (VAR_21) {\n            VAR_4 = VAR_0->comps[1].data;\n            VAR_5 = VAR_0->comps[2].data;\n        } else {\n            VAR_4 = VAR_5 = NULL;\n        }\n\n        if (VAR_20) {\n            const char *VAR_30 = (VAR_21 ? \"RGB_ALPHA\" : \"GRAYSCALE_ALPHA\");\n\n            fprintf(VAR_24, \"P7\\n# OpenJPEG-%s\\nWIDTH %d\\nHEIGHT %d\\nDEPTH %u\\n\"\n                    \"MAXVAL %d\\nTUPLTYPE %s\\nENDHDR\\n\", opj_version(),\n                    VAR_7, VAR_8, VAR_12, VAR_9, VAR_30);\n            VAR_6 = VAR_0->comps[VAR_12 - 1].data;\n            VAR_16 = (VAR_0->comps[VAR_12 - 1].sgnd ?\n                       1 << (VAR_0->comps[VAR_12 - 1].prec - 1) : 0);\n        } else {\n            fprintf(VAR_24, \"P6\\n# OpenJPEG-%s\\n%d %d\\n%d\\n\",\n                    opj_version(), VAR_7, VAR_8, VAR_9);\n            VAR_16 = 0;\n        }\n        VAR_13 = (VAR_0->comps[0].sgnd ? 1 << (VAR_0->comps[0].prec - 1) : 0);\n\n        if (VAR_21) {\n            VAR_14 = (VAR_0->comps[1].sgnd ? 1 << (VAR_0->comps[1].prec - 1) : 0);\n            VAR_15 = (VAR_0->comps[2].sgnd ? 1 << (VAR_0->comps[2].prec - 1) : 0);\n        } else {\n            VAR_14 = VAR_15 = 0;\n        }\n\n        for (VAR_10 = 0; VAR_10 < VAR_7 * VAR_8; ++VAR_10) {\n            if (VAR_18) {\n                VAR_23 = *VAR_3 + VAR_13;\n                ++VAR_3;\n                if (VAR_23 > 65535) {\n                    VAR_23 = 65535;\n                } else if (VAR_23 < 0) {\n                    VAR_23 = 0;\n                }\n\n                /* COMMENT_0 */\n                fprintf(VAR_24, \"%c%c\", (unsigned char)(VAR_23 >> 8), (unsigned char)VAR_23);\n\n                if (VAR_21) {\n                    VAR_23 = *VAR_4 + VAR_14;\n                    ++VAR_4;\n                    if (VAR_23 > 65535) {\n                        VAR_23 = 65535;\n                    } else if (VAR_23 < 0) {\n                        VAR_23 = 0;\n                    }\n\n                    /* COMMENT_0 */\n                    fprintf(VAR_24, \"%c%c\", (unsigned char)(VAR_23 >> 8), (unsigned char)VAR_23);\n\n                    VAR_23 =  *VAR_5 + VAR_15;\n                    ++VAR_5;\n                    if (VAR_23 > 65535) {\n                        VAR_23 = 65535;\n                    } else if (VAR_23 < 0) {\n                        VAR_23 = 0;\n                    }\n\n                    /* COMMENT_0 */\n                    fprintf(VAR_24, \"%c%c\", (unsigned char)(VAR_23 >> 8), (unsigned char)VAR_23);\n\n                }/* COMMENT_1 */\n\n                if (VAR_20) {\n                    VAR_23 = *VAR_6 + VAR_16;\n                    ++VAR_6;\n                    if (VAR_23 > 65535) {\n                        VAR_23 = 65535;\n                    } else if (VAR_23 < 0) {\n                        VAR_23 = 0;\n                    }\n\n                    /* COMMENT_0 */\n                    fprintf(VAR_24, \"%c%c\", (unsigned char)(VAR_23 >> 8), (unsigned char)VAR_23);\n                }\n                continue;\n\n            }   /* COMMENT_2 */\n\n            /* COMMENT_3 */\n            VAR_23 = *VAR_3++;\n            if (VAR_23 > 255) {\n                VAR_23 = 255;\n            } else if (VAR_23 < 0) {\n                VAR_23 = 0;\n            }\n\n            fprintf(VAR_24, \"%c\", (unsigned char)VAR_23);\n            if (VAR_21) {\n                VAR_23 = *VAR_4++;\n                if (VAR_23 > 255) {\n                    VAR_23 = 255;\n                } else if (VAR_23 < 0) {\n                    VAR_23 = 0;\n                }\n\n                fprintf(VAR_24, \"%c\", (unsigned char)VAR_23);\n                VAR_23 = *VAR_5++;\n                if (VAR_23 > 255) {\n                    VAR_23 = 255;\n                } else if (VAR_23 < 0) {\n                    VAR_23 = 0;\n                }\n\n                fprintf(VAR_24, \"%c\", (unsigned char)VAR_23);\n            }\n            if (VAR_20) {\n                VAR_23 = *VAR_6++;\n                if (VAR_23 > 255) {\n                    VAR_23 = 255;\n                } else if (VAR_23 < 0) {\n                    VAR_23 = 0;\n                }\n\n                fprintf(VAR_24, \"%c\", (unsigned char)VAR_23);\n            }\n        }   /* COMMENT_4 */\n\n        fclose(VAR_24);\n        return 0;\n    }\n\n    /* COMMENT_5 */\n\n    if (VAR_0->numcomps > VAR_12) {\n        fprintf(VAR_27, \"WARNING -> [PGM file] Only the first component\\n\");\n        fprintf(VAR_27, \"           is written to the file\\n\");\n    }\n    VAR_26 = (char*)malloc(strlen(VAR_1) + 8);\n    if (VAR_26 == NULL) {\n        fprintf(VAR_27, \"imagetopnm: memory out\\n\");\n        return 1;\n    }\n    for (VAR_11 = 0; VAR_11 < VAR_12; VAR_11++) {\n        if (VAR_12 > 1) {\n            /* COMMENT_6 */\n            const size_t VAR_31 = strlen(VAR_1);\n            const size_t VAR_32 = VAR_31 - 4;\n\n            strncpy(VAR_26, VAR_1, VAR_32);\n            sprintf(VAR_26 + VAR_32, \"_%u.pgm\", VAR_11);\n        } else {\n            sprintf(VAR_26, \"%s\", VAR_1);\n        }\n\n        VAR_24 = fopen(VAR_26, \"wb\");\n        if (!VAR_24) {\n            fprintf(VAR_27, \"ERROR -> failed to open %s for writing\\n\", VAR_26);\n            free(VAR_26);\n            return 1;\n        }\n        VAR_7 = (int)VAR_0->comps[VAR_11].w;\n        VAR_8 = (int)VAR_0->comps[VAR_11].h;\n        VAR_22 = (int)VAR_0->comps[VAR_11].prec;\n        VAR_9 = (1 << VAR_22) - 1;\n\n        fprintf(VAR_24, \"P5\\n#OpenJPEG-%s\\n%d %d\\n%d\\n\",\n                opj_version(), VAR_7, VAR_8, VAR_9);\n\n        VAR_3 = VAR_0->comps[VAR_11].data;\n        if (!VAR_3) {\n            fclose(VAR_24);\n            continue;\n        }\n\n        VAR_13 =\n            (VAR_0->comps[VAR_11].sgnd ? 1 << (VAR_0->comps[VAR_11].prec - 1) : 0);\n\n        if (VAR_22 > 8) {\n            for (VAR_10 = 0; VAR_10 < VAR_7 * VAR_8; VAR_10++) {\n                VAR_23 = *VAR_3 + VAR_13;\n                ++VAR_3;\n                if (VAR_23 > 65535) {\n                    VAR_23 = 65535;\n                } else if (VAR_23 < 0) {\n                    VAR_23 = 0;\n                }\n\n                /* COMMENT_0 */\n                fprintf(VAR_24, \"%c%c\", (unsigned char)(VAR_23 >> 8), (unsigned char)VAR_23);\n\n                if (VAR_20) {\n                    VAR_23 = *VAR_6++;\n                    if (VAR_23 > 65535) {\n                        VAR_23 = 65535;\n                    } else if (VAR_23 < 0) {\n                        VAR_23 = 0;\n                    }\n\n                    /* COMMENT_0 */\n                    fprintf(VAR_24, \"%c%c\", (unsigned char)(VAR_23 >> 8), (unsigned char)VAR_23);\n                }\n            }/* COMMENT_4 */\n        } else { /* COMMENT_7 */\n            for (VAR_10 = 0; VAR_10 < VAR_7 * VAR_8; ++VAR_10) {\n                VAR_23 = *VAR_3 + VAR_13;\n                ++VAR_3;\n                if (VAR_23 > 255) {\n                    VAR_23 = 255;\n                } else if (VAR_23 < 0) {\n                    VAR_23 = 0;\n                }\n\n                fprintf(VAR_24, \"%c\", (unsigned char)VAR_23);\n            }\n        }\n        fclose(VAR_24);\n    } /* COMMENT_8 */\n    free(VAR_26);\n\n    return 0;\n}",
  "func_graph_path": "uclouvain/openjpeg/cab352e249ed3372dd9355c85e837613fff98fa2/convert.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -215,6 +215,11 @@\n                 opj_version(), wr, hr, max);\n \n         red = image->comps[compno].data;\n+        if (!red) {\n+            fclose(fdest);\n+            continue;\n+        }\n+\n         adjustR =\n             (image->comps[compno].sgnd ? 1 << (image->comps[compno].prec - 1) : 0);\n ",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "        if (!red) {",
      "            fclose(fdest);",
      "            continue;",
      "        }",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/uclouvain/openjpeg/pull/1160",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/uclouvain/openjpeg/pull/1160: 403 Client Error: Forbidden for url: https://api.github.com/repos/uclouvain/openjpeg/pulls/1160",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "The patch addresses a null pointer dereference by adding a check, which fixes a crash vulnerability, confirmed by the associated CVE. \n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0  \n\nStep-by-step explanation:\n1. Commit message indicates a null pointer fix.\n2. Code diff adds a null check to prevent dereference.\n3. Assigned CVE confirms security relevance.\n4. No inconsistencies between message and code changes.\n5. High confidence due to clear alignment and CVE reference.\n\n**Final Output:**  \n**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}