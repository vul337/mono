{
  "cve_id": "CVE-2020-12762",
  "cwe_ids": [
    "CWE-190",
    "CWE-787"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "json-c",
  "commit_msg": "Prevent division by zero in linkhash.\n\nIf a linkhash with a size of zero is created, then modulo operations\nare prone to division by zero operations.\n\nPurely protective measure against bad usage.",
  "commit_hash": "77d935b7ae7871a1940cd827e850e6063044ec45",
  "git_url": "https://github.com/json-c/json-c/commit/77d935b7ae7871a1940cd827e850e6063044ec45",
  "file_path": "linkhash.c",
  "func_name": "lh_table_new",
  "func_before": "struct lh_table *lh_table_new(int size, lh_entry_free_fn *free_fn, lh_hash_fn *hash_fn,\n                              lh_equal_fn *equal_fn)\n{\n\tint i;\n\tstruct lh_table *t;\n\n\tt = (struct lh_table *)calloc(1, sizeof(struct lh_table));\n\tif (!t)\n\t\treturn NULL;\n\n\tt->count = 0;\n\tt->size = size;\n\tt->table = (struct lh_entry *)calloc(size, sizeof(struct lh_entry));\n\tif (!t->table)\n\t{\n\t\tfree(t);\n\t\treturn NULL;\n\t}\n\tt->free_fn = free_fn;\n\tt->hash_fn = hash_fn;\n\tt->equal_fn = equal_fn;\n\tfor (i = 0; i < size; i++)\n\t\tt->table[i].k = LH_EMPTY;\n\treturn t;\n}",
  "abstract_func_before": "struct lh_table *lh_table_new(int VAR_0, lh_entry_free_fn *VAR_1, lh_hash_fn *VAR_2,\n                              lh_equal_fn *VAR_3)\n{\n\tint VAR_4;\n\tstruct lh_table *VAR_5;\n\n\tVAR_5 = (struct lh_table *)calloc(1, sizeof(struct lh_table));\n\tif (!VAR_5)\n\t\treturn NULL;\n\n\tVAR_5->count = 0;\n\tVAR_5->size = VAR_0;\n\tVAR_5->table = (struct lh_entry *)calloc(VAR_0, sizeof(struct lh_entry));\n\tif (!VAR_5->table)\n\t{\n\t\tfree(VAR_5);\n\t\treturn NULL;\n\t}\n\tVAR_5->free_fn = VAR_1;\n\tVAR_5->hash_fn = VAR_2;\n\tVAR_5->equal_fn = VAR_3;\n\tfor (VAR_4 = 0; VAR_4 < VAR_0; VAR_4++)\n\t\tVAR_5->table[VAR_4].k = VAR_6;\n\treturn VAR_5;\n}",
  "func_graph_path_before": "json-c/77d935b7ae7871a1940cd827e850e6063044ec45/linkhash.c/vul/before/0.json",
  "func": "struct lh_table *lh_table_new(int size, lh_entry_free_fn *free_fn, lh_hash_fn *hash_fn,\n                              lh_equal_fn *equal_fn)\n{\n\tint i;\n\tstruct lh_table *t;\n\n\t/* Allocate space for elements to avoid divisions by zero. */\n\tassert(size > 0);\n\tt = (struct lh_table *)calloc(1, sizeof(struct lh_table));\n\tif (!t)\n\t\treturn NULL;\n\n\tt->count = 0;\n\tt->size = size;\n\tt->table = (struct lh_entry *)calloc(size, sizeof(struct lh_entry));\n\tif (!t->table)\n\t{\n\t\tfree(t);\n\t\treturn NULL;\n\t}\n\tt->free_fn = free_fn;\n\tt->hash_fn = hash_fn;\n\tt->equal_fn = equal_fn;\n\tfor (i = 0; i < size; i++)\n\t\tt->table[i].k = LH_EMPTY;\n\treturn t;\n}",
  "abstract_func": "struct lh_table *lh_table_new(int VAR_0, lh_entry_free_fn *VAR_1, lh_hash_fn *VAR_2,\n                              lh_equal_fn *VAR_3)\n{\n\tint VAR_4;\n\tstruct lh_table *VAR_5;\n\n\t/* COMMENT_0 */\n\tassert(VAR_0 > 0);\n\tVAR_5 = (struct lh_table *)calloc(1, sizeof(struct lh_table));\n\tif (!VAR_5)\n\t\treturn NULL;\n\n\tVAR_5->count = 0;\n\tVAR_5->size = VAR_0;\n\tVAR_5->table = (struct lh_entry *)calloc(VAR_0, sizeof(struct lh_entry));\n\tif (!VAR_5->table)\n\t{\n\t\tfree(VAR_5);\n\t\treturn NULL;\n\t}\n\tVAR_5->free_fn = VAR_1;\n\tVAR_5->hash_fn = VAR_2;\n\tVAR_5->equal_fn = VAR_3;\n\tfor (VAR_4 = 0; VAR_4 < VAR_0; VAR_4++)\n\t\tVAR_5->table[VAR_4].k = VAR_6;\n\treturn VAR_5;\n}",
  "func_graph_path": "json-c/77d935b7ae7871a1940cd827e850e6063044ec45/linkhash.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,8 @@\n \tint i;\n \tstruct lh_table *t;\n \n+\t/* Allocate space for elements to avoid divisions by zero. */\n+\tassert(size > 0);\n \tt = (struct lh_table *)calloc(1, sizeof(struct lh_table));\n \tif (!t)\n \t\treturn NULL;",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "\t/* Allocate space for elements to avoid divisions by zero. */",
      "\tassert(size > 0);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/json-c/json-c/pull/592",
  "description": {
    "pr_info": {
      "title": "Prevent out of boundary write on malicious input",
      "number": 592
    },
    "comment": [
      "I have discovered a way to trigger an out of boundary write while parsing a huge json file through a malicious input source. It can be triggered if an attacker has control over the input stream or if a huge load during filesystem operations can be triggered.\r\n\r\nPreparation:\r\n``$ dd if=/dev/zero of=poc.json bs=1 count=1 seek=2147483647``\r\n\r\nCode to exploit:\r\n```\r\n#include <json-c/json_util.h>\r\n#include <unistd.h>\r\nint main() {\r\n  json_object_from_fd(STDIN_FILENO);\r\n  return 0;\r\n}\r\n```\r\n\r\nProof of Concept:\r\n``(dd if=poc.json bs=4096; sleep 1; dd if=test.json bs=10) 2>/dev/null | ./test``\r\n\r\nExplanation:\r\nThe problem manifests itself in printbuf_memappend. On properly crafted values, p->bpos + size + 1 can overflow, which leads to the assumption that p->size is still large enough. In normal circumstances, this does not happen with json_object_from_fd due to its buffer size leading to proper detection. But if the parsed buffer chunk length is not a power of 2 (sleep 1 and bs=10 triggers this in my proof of concept), this overflow can be abused by an attacker to write past the memory boundary of p->buf.\r\n\r\nMy example simply crashes the program eventually. A proper attack can be controled in a way to not crash the system but simply write a few attacker controlled bytes outside the allocated area, allowing more sophisticated attacks against real world programs.",
      "\n[![Coverage Status](https://coveralls.io/builds/30606764/badge)](https://coveralls.io/builds/30606764)\n\nCoverage decreased (-0.2%) to 85.768% when pulling **d07b91014986900a3a75f306d302e13e005e9d67 on stoeckmann:oob** into **8e3d3d55449a358c662e73ce6f539d44c8053e2c on json-c:master**.\n",
      "The changes look good, thanks!"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.85,
  "Bug Filter Response": "The patch prevents a division-by-zero error in the linkhash function by adding an assert statement to ensure the size is greater than zero. This is a fix for a potential programming bug, not a security vulnerability.\n\n**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.85"
}