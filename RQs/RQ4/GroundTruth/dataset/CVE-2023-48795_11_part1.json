{
  "cve_id": "CVE-2023-48795",
  "cwe_ids": [
    "CWE-354"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:H/A:N",
  "cvss_is_v3": true,
  "repo_name": "apache/mina-sshd",
  "commit_msg": "GH-445: OpenSSH \"strict KEX\" protocol extension\n\nImplements the OpenSSH \"strict KEX\" protocol extension.[1] If both\nparties in a an SSH connection announce support for strict KEX in the\ninitial KEX_INIT message, strict KEX is active; otherwise it isn't.\n\nWith strict KEX active, there must be only KEX-related messages during\nthe initial key exchange (no IGNORE or DEBUG messages are allowed), and\nthe KEX_INIT message must be the first one to have been received after\nthe initial version exchange. If these conditions are violated, the\nconnection is terminated.\n\nStrict KEX also resets message sequence numbers to zero after each\nNEW_KEYS message sent or received.\n\n[1] https://github.com/openssh/openssh-portable/blob/master/PROTOCOL",
  "commit_hash": "6b0fd46f64bcb75eeeee31d65f10242660aad7c1",
  "git_url": "https://github.com/apache/mina-sshd/commit/6b0fd46f64bcb75eeeee31d65f10242660aad7c1",
  "file_path": "sshd-core/src/main/java/org/apache/sshd/common/session/helpers/AbstractSession.java",
  "func_name": "setOutputEncoding",
  "func_before": "protected void setOutputEncoding() throws Exception {\n        outCipher = outSettings.getCipher(seqo);\n        outMac = outSettings.getMac();\n        outCompression = outSettings.getCompression();\n        outSettings = null;\n        outCipherSize = outCipher.getCipherBlockSize();\n        outMacSize = outMac != null ? outMac.getBlockSize() : 0;\n        // TODO add support for configurable compression level\n        outCompression.init(Compression.Type.Deflater, -1);\n\n        maxRekeyBlocks.set(determineRekeyBlockLimit(inCipherSize, outCipherSize));\n\n        outBytesCount.set(0L);\n        outPacketsCount.set(0L);\n        outBlocksCount.set(0L);\n\n        lastKeyTimeValue.set(Instant.now());\n        firstKexPacketFollows = null;\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"setOutputEncoding({}): cipher {}; mac {}; compression {}; blocks limit {}\", this, outCipher, outMac,\n                    outCompression, maxRekeyBlocks);\n        }\n    }",
  "abstract_func_before": "protected void setOutputEncoding() throws Exception {\n        VAR_0 = VAR_1.getCipher(VAR_2);\n        VAR_3 = VAR_1.getMac();\n        VAR_4 = VAR_1.getCompression();\n        VAR_1 = null;\n        VAR_5 = VAR_0.getCipherBlockSize();\n        VAR_6 = VAR_3 != null ? VAR_3.getBlockSize() : 0;\n        /* COMMENT_0 */\n        VAR_4.init(VAR_7.Type.Deflater, -1);\n\n        VAR_8.set(determineRekeyBlockLimit(VAR_9, VAR_5));\n\n        VAR_10.set(0L);\n        VAR_11.set(0L);\n        VAR_12.set(0L);\n\n        VAR_13.set(VAR_14.now());\n        VAR_15 = null;\n\n        if (VAR_16.isDebugEnabled()) {\n            VAR_16.debug(\"setOutputEncoding({}): cipher {}; mac {}; compression {}; blocks limit {}\", this, VAR_0, VAR_3,\n                    VAR_4, VAR_8);\n        }\n    }",
  "func_graph_path_before": "apache/mina-sshd/6b0fd46f64bcb75eeeee31d65f10242660aad7c1/AbstractSession.java/vul/before/5.json",
  "func": "protected void setOutputEncoding() throws Exception {\n        if (strictKex) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"setOutputEncoding({}): strict KEX resets output message sequence number from {} to 0\", this, seqo);\n            }\n            seqo = 0;\n        }\n\n        outCipher = outSettings.getCipher(seqo);\n        outMac = outSettings.getMac();\n        outCompression = outSettings.getCompression();\n        outSettings = null;\n        outCipherSize = outCipher.getCipherBlockSize();\n        outMacSize = outMac != null ? outMac.getBlockSize() : 0;\n        // TODO add support for configurable compression level\n        outCompression.init(Compression.Type.Deflater, -1);\n\n        maxRekeyBlocks.set(determineRekeyBlockLimit(inCipherSize, outCipherSize));\n\n        outBytesCount.set(0L);\n        outPacketsCount.set(0L);\n        outBlocksCount.set(0L);\n\n        lastKeyTimeValue.set(Instant.now());\n        firstKexPacketFollows = null;\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"setOutputEncoding({}): cipher {}; mac {}; compression {}; blocks limit {}\", this, outCipher, outMac,\n                    outCompression, maxRekeyBlocks);\n        }\n    }",
  "abstract_func": "protected void setOutputEncoding() throws Exception {\n        if (VAR_0) {\n            if (VAR_1.isDebugEnabled()) {\n                VAR_1.debug(\"setOutputEncoding({}): strict KEX resets output message sequence number from {} to 0\", this, VAR_2);\n            }\n            VAR_2 = 0;\n        }\n\n        VAR_3 = VAR_4.getCipher(VAR_2);\n        VAR_5 = VAR_4.getMac();\n        VAR_6 = VAR_4.getCompression();\n        VAR_4 = null;\n        VAR_7 = VAR_3.getCipherBlockSize();\n        VAR_8 = VAR_5 != null ? VAR_5.getBlockSize() : 0;\n        /* COMMENT_0 */\n        VAR_6.init(VAR_9.Type.Deflater, -1);\n\n        VAR_10.set(determineRekeyBlockLimit(VAR_11, VAR_7));\n\n        VAR_12.set(0L);\n        VAR_13.set(0L);\n        VAR_14.set(0L);\n\n        VAR_15.set(VAR_16.now());\n        VAR_17 = null;\n\n        if (VAR_1.isDebugEnabled()) {\n            VAR_1.debug(\"setOutputEncoding({}): cipher {}; mac {}; compression {}; blocks limit {}\", this, VAR_3, VAR_5,\n                    VAR_6, VAR_10);\n        }\n    }",
  "func_graph_path": "apache/mina-sshd/6b0fd46f64bcb75eeeee31d65f10242660aad7c1/AbstractSession.java/vul/after/5.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,11 @@\n protected void setOutputEncoding() throws Exception {\n+        if (strictKex) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"setOutputEncoding({}): strict KEX resets output message sequence number from {} to 0\", this, seqo);\n+            }\n+            seqo = 0;\n+        }\n+\n         outCipher = outSettings.getCipher(seqo);\n         outMac = outSettings.getMac();\n         outCompression = outSettings.getCompression();",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "        if (strictKex) {",
      "            if (log.isDebugEnabled()) {",
      "                log.debug(\"setOutputEncoding({}): strict KEX resets output message sequence number from {} to 0\", this, seqo);",
      "            }",
      "            seqo = 0;",
      "        }",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/apache/mina-sshd/pull/449",
  "description": {
    "pr_info": {
      "title": "\"Strict KEX\" implementation",
      "number": 449
    },
    "comment": [
      "Alternate proposal to #446 for implementing \"strict KEX\". This is a minimal single-purpose PR for this feature.\r\n\r\n- One commit implementing the functionality in `AbstractSession`.\r\n- One commit adding unit tests to verify sessions are disconnected on spurious messages.\r\n- One commit adding container tests for interoperability testing.\r\n\r\nThe implementation in `AbstractSession` is a bit leaner than the original proposal because it makes use of the already existing `initialKexDone` flag, doesn't use atomic variables where not necessary, and has no optional settings to bother with. But most importantly the issue is not clouded by unrelated changes or spurious reformatting.\r\n\r\nThere are _no_ configuration settings to disable the \"strict KEX\" implementation. \"Strict KEX\" is a hardening of a core SSH protocol; I will not provide knobs to dumb down and make that protocol implementation less secure. If someone absolutely wants to disable this, he or she can subclass the session (for instance ClientSessionImpl) and override doStrictKexProposal() to not do anything.\r\n\r\nThe unit tests in `StrictKexTest` work with all transport back-ends (NIO2, Netty, and Mina).\r\n\r\nThe container tests test an Apache MINA sshd client against an OpenSSH server, using Alpine 20231219/OpenSSH 9.6 for a strick-kex-enabled server, and CentOS 7/OpenSSH 7.4 for one that doesn't have strict KEX. These tests explicitly ensure that communication and re-KEX work with or without \"strict KEX\".\r\n\r\nNote that other container tests in the overall test suite already would fail if strict KEX was implemented wrongly, but I prefer having explicit tests for this.\r\n\r\nThere are no container tests using an OpenSSH client and an Apache MINS sshd server. Besides being somewhat harder to implement, they wouldn't add much value. The KEX sub-protocol is symmetric and is wholly implemented in `AbstractSession`, which is the same for client and server.\r\n\r\nFixes #445.",
      "> The unit tests in StrictKexTest work with all transport back-ends (NIO2, Netty, and Mina).\r\n\r\nOn Linux/MacOS. Somehow not in CI on Windows. `StrictKexTest` consistently fails on Windows/Java 8, and is unstable with Java 11 or 17 on Windows. :-(",
      "> > The unit tests in StrictKexTest work with all transport back-ends (NIO2, Netty, and Mina).\r\n> \r\n> On Linux/MacOS. Somehow not in CI on Windows. `StrictKexTest` consistently fails on Windows/Java 8, and is unstable with Java 11 or 17 on Windows. :-(\r\n\r\nThe test failure on Windows was due to an unrelated bug that exists at least in the NIO2 transport back-end: when a session is terminated due to an exception, the SSH session layer sends a DISCONNECT message and is careful to close the ServerSession only once that message has been sent. But the underlying Nio2Session layer then closes itself immediately all the same. This gives a race -- sometimes, the write completes earlier, but sometimes it doesn't, and then the DISCONNECT message never goes out. Then the client doesn't get the expected disconnection reason code.\r\n\r\nThat minor bug is to fixed in some follow-up change; I don't want to do it here in this PR. (Fixing it properly might not be trivial.) The connection is closed in either case, so I prefer to have less strict assertions in the test instead.\r\n\r\nThis PR is ready for review.",
      "Looks OK to me (have not gone over the tests in details - I trust you checked them). I do feel I need to insist on a `CoreModuleProperties` property that controls this feature. As I have said previously, I am fine with its default being \"enabled\", but I strongly feel we should have it...",
      "> The implementation looks good. I miss a „require“ option, but that’s not a showstopper for me. Exposing the strictkex state to a listener and some counter statistics might be a Seperate topic.\r\n\r\nThanks for the review, I appreciate it. Indeed, exposing more internal state can be done in follow-up changes. This is just about the basic protocol extension.",
      "> Looks OK to me (have not gone over the tests in details - I trust you checked them). I do feel I need to insist on a `CoreModuleProperties` property that controls this feature. As I have said previously, I am fine with its default being \"enabled\", but I strongly feel we should have it...\r\n\r\nI think we should minimize \"kill switches\". They obfuscate the issue permanently (removing the property in the future would be an API-breaking change). In this particular case:\r\n\r\n- This is a fairly important modification of a core sub-protocol in the SSH protocols.\r\n- It is backwards compatible with older implementations that don't know about it.\r\n- It is tested.\r\n- If we did it wrong and people can't use it because it breaks something, they'll just stay on 2.11.0 and we'll have to have a 2.12.1 with a fix.\r\n\r\nFinally, if someone really wants to shut off strict KEX usage, here's one way of doing so:\r\n```\r\nSshClient client = ...;\r\nSessionFactory factory = new NoStrictKexSessionFactory(client);\r\nclient.setSessionFactory(factory);\r\nclient.start();\r\n```\r\nand\r\n```\r\nclass NoStrictKexSessionFactory extends SessionFactory {\r\n    NoStrictKexSessionFactory(ClientFactoryManager client) {\r\n        super(client);\r\n    }\r\n\r\n    @Override\r\n    protected ClientSessionImpl doCreateSession(IoSession ioSession) throws Exception {\r\n        return new NoStrictKexSession(getClient(), ioSession);\r\n    }\r\n}\r\n\r\nclass NoStrictKexSession extends ClientSessionImpl {\r\n\r\n    NoStrictKexSession(ClientFactoryManager client, IoSession ioSession) throws Exception {\r\n        super(client, ioSession);\r\n    }\r\n\r\n    @Override\r\n    protected Map<KexProposalOption, String> doStrictKexProposal(Map<KexProposalOption, String> proposal) {\r\n        return proposal;\r\n    }\r\n}\r\n```\r\n(Or likewise for a `ServerSession`.)\r\n\r\nYes, it's a little bit of code to write, but it's IMO about the right level of difficulty for switching off a security feature. I don't want to make it too easy for users to shoot themselves in the foot by inadvertently switching strict kex off. And yes, a boolean property in `CoreModuleProperties` fits my definition of \"too easy\" in this case.",
      "> I think we should minimize \"kill switches\". They obfuscate the issue permanently (removing the property in the future would be an API-breaking change).\r\n\r\nAFAIK we never removed a switch once there, but we can defer this to a future change (see also below)\r\n\r\n> Finally, if someone really wants to shut off strict KEX usage, here's one way of doing so:\r\n\r\nLet's document this - I recommend adding a section in the [HOTOW(s) document](https://github.com/apache/mina-sshd/blob/master/docs/howto.md)",
      "> AFAIK we never removed a switch once there\r\n\r\nMy point exactly.\r\n\r\nDocumentation added.",
      "I am fine with this - as far as I am concerned you can merge.",
      "Hi team!\r\n@tomaswolf  may I ask what is the ETA for releasing this implementation?\r\nThanks!"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "The patch introduces a new security-hardening feature in the SSH protocol, specifically the \"strict KEX\" extension, which enhances the protocol's security by enforcing stricter key exchange conditions. While it improves security, it isn't a fix for a known vulnerability but rather a proactive feature addition.\n\n**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.95\n\n**Explanation:**\n- The commit and code changes are clear and consistent, implementing a new security feature.\n- It directly enhances core functionality (SSH protocol) without addressing a specific exploit or vulnerability.\n- The context and info clearly indicate it's a feature upgrade with security implications, not a patch for an existing issue."
}