{
  "cve_id": "CVE-2017-13756",
  "cwe_ids": [
    "CWE-835"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "sleuthkit",
  "commit_msg": "Avoid infinite loop in dos_load_ext_table(). (Fixes: #914)\n\nIf dos_load_ext_table() was called with a zero offset, the loop\nwould repeat the exact same conditions ad infinitum.",
  "commit_hash": "5d187980cf2f4d320670f9f3ebf6e08966bd3d35",
  "git_url": "https://github.com/sleuthkit/sleuthkit/commit/5d187980cf2f4d320670f9f3ebf6e08966bd3d35",
  "file_path": "tsk/vs/dos.c",
  "func_name": "dos_load_ext_table",
  "func_before": "static uint8_t\ndos_load_ext_table(TSK_VS_INFO * vs, TSK_DADDR_T sect_cur,\n    TSK_DADDR_T sect_ext_base, int table)\n{\n    dos_sect *sect;\n    char *sect_buf;\n    int i;\n    char *table_str;\n    ssize_t cnt;\n    TSK_DADDR_T max_addr = (vs->img_info->size - vs->offset) / vs->block_size;  // max sector\n\n    if (tsk_verbose)\n        tsk_fprintf(stderr,\n            \"dos_load_ext: Table Sector: %\" PRIuDADDR\n            \", Primary Base Sector: %\" PRIuDADDR \"\\n\", sect_cur,\n            sect_ext_base);\n\n    if ((sect_buf = tsk_malloc(vs->block_size)) == NULL)\n        return 1;\n    sect = (dos_sect *) sect_buf;\n\n    /* Read the partition table sector */\n    cnt = tsk_vs_read_block(vs, sect_cur, sect_buf, vs->block_size);\n    if (cnt != vs->block_size) {\n        if (cnt >= 0) {\n            tsk_error_reset();\n            tsk_error_set_errno(TSK_ERR_VS_READ);\n        }\n        tsk_error_set_errstr2(\"Extended DOS table sector %\" PRIuDADDR,\n            sect_cur);\n        free(sect_buf);\n        return 1;\n    }\n\n    /* Sanity Check */\n    if (tsk_getu16(vs->endian, sect->magic) != DOS_MAGIC) {\n        tsk_error_reset();\n        tsk_error_set_errno(TSK_ERR_VS_MAGIC);\n        tsk_error_set_errstr(\"Extended DOS partition table in sector %\"\n            PRIuDADDR, sect_cur);\n        free(sect_buf);\n        return 1;\n    }\n\n    /* Add an entry of 1 length for the table  to the internal structure */\n    if ((table_str = tsk_malloc(32)) == NULL) {\n        free(sect_buf);\n        return 1;\n    }\n\n    snprintf(table_str, 32, \"Extended Table (#%d)\", table);\n    if (NULL == tsk_vs_part_add(vs, (TSK_DADDR_T) sect_cur,\n            (TSK_DADDR_T) 1, TSK_VS_PART_FLAG_META, table_str, table,\n            -1)) {\n        free(sect_buf);\n        return 1;\n    }\n\n    /* Cycle through the four partitions in the table\n     *\n     * When another extended partition is found, it is processed\n     * inside of the loop\n     */\n    for (i = 0; i < 4; i++) {\n        dos_part *part = &sect->ptable[i];\n\n        /* Get the starting sector and size, we currently\n         * ignore CHS */\n        uint32_t part_start = tsk_getu32(vs->endian, part->start_sec);\n        uint32_t part_size = tsk_getu32(vs->endian, part->size_sec);\n\n        if (tsk_verbose)\n            tsk_fprintf(stderr,\n                \"load_ext: %d:%d    Start: %\" PRIu32 \"   Size: %\"\n                PRIu32 \"  Type: %d\\n\", table, i, part_start, part_size,\n                part->ptype);\n\n        if (part_size == 0)\n            continue;\n\n        /* partitions are addressed differently\n         * in extended partitions */\n        if (dos_is_ext(part->ptype)) {\n\n            /* part start is added to the start of the\n             * first extended partition (the primary\n             * extended partition) */\n\n            if (NULL == tsk_vs_part_add(vs,\n                    (TSK_DADDR_T) (sect_ext_base + part_start),\n                    (TSK_DADDR_T) part_size, TSK_VS_PART_FLAG_META,\n                    dos_get_desc(part->ptype), table, i)) {\n                free(sect_buf);\n                return 1;\n            }\n\n            if (sect_ext_base + part_start > max_addr) {\n                if (tsk_verbose)\n                    tsk_fprintf(stderr,\n                        \"Starting sector %\" PRIuDADDR\n                        \" of extended partition too large for image\\n\",\n                        sect_ext_base + part_start);\n            }\n            /* Process the extended partition */\n            else if (dos_load_ext_table(vs, sect_ext_base + part_start,\n                    sect_ext_base, table + 1)) {\n                free(sect_buf);\n                return 1;\n            }\n        }\n\n        else {\n            /* part_start is added to the start of the\n             * current partition for the actual\n             * starting location */\n\n            // we ignore the max_addr checks on extended partitions...\n\n            if (NULL == tsk_vs_part_add(vs,\n                    (TSK_DADDR_T) (sect_cur + part_start),\n                    (TSK_DADDR_T) part_size, TSK_VS_PART_FLAG_ALLOC,\n                    dos_get_desc(part->ptype), table, i)) {\n                free(sect_buf);\n                return 1;\n            }\n        }\n    }\n\n    free(sect_buf);\n    return 0;\n}",
  "abstract_func_before": "static uint8_t\ndos_load_ext_table(TSK_VS_INFO * VAR_0, TSK_DADDR_T VAR_1,\n    TSK_DADDR_T VAR_2, int VAR_3)\n{\n    dos_sect *VAR_4;\n    char *VAR_5;\n    int VAR_6;\n    char *VAR_7;\n    ssize_t VAR_8;\n    TSK_DADDR_T VAR_9 = (VAR_0->img_info->size - VAR_0->offset) / VAR_0->block_size;  /* COMMENT_0 */\n\n    if (VAR_10)\n        tsk_fprintf(VAR_11,\n            \"dos_load_ext: Table Sector: %\" VAR_12\n            \", Primary Base Sector: %\" VAR_12 \"\\n\", VAR_1,\n            VAR_2);\n\n    if ((VAR_5 = tsk_malloc(VAR_0->block_size)) == NULL)\n        return 1;\n    VAR_4 = (dos_sect *) VAR_5;\n\n    /* COMMENT_1 */\n    VAR_8 = tsk_vs_read_block(VAR_0, VAR_1, VAR_5, VAR_0->block_size);\n    if (VAR_8 != VAR_0->block_size) {\n        if (VAR_8 >= 0) {\n            tsk_error_reset();\n            tsk_error_set_errno(VAR_13);\n        }\n        tsk_error_set_errstr2(\"Extended DOS table sector %\" VAR_12,\n            VAR_1);\n        free(VAR_5);\n        return 1;\n    }\n\n    /* COMMENT_2 */\n    if (tsk_getu16(VAR_0->endian, VAR_4->magic) != VAR_14) {\n        tsk_error_reset();\n        tsk_error_set_errno(VAR_15);\n        tsk_error_set_errstr(\"Extended DOS partition table in sector %\"\n            VAR_12, VAR_1);\n        free(VAR_5);\n        return 1;\n    }\n\n    /* COMMENT_3 */\n    if ((VAR_7 = tsk_malloc(32)) == NULL) {\n        free(VAR_5);\n        return 1;\n    }\n\n    snprintf(VAR_7, 32, \"Extended Table (#%d)\", VAR_3);\n    if (NULL == tsk_vs_part_add(VAR_0, (TSK_DADDR_T) VAR_1,\n            (TSK_DADDR_T) 1, VAR_16, VAR_7, VAR_3,\n            -1)) {\n        free(VAR_5);\n        return 1;\n    }\n\n    /* COMMENT_4 */\n      \n                                                                \n                         \n       \n    for (VAR_6 = 0; VAR_6 < 4; VAR_6++) {\n        dos_part *VAR_17 = &VAR_4->ptable[VAR_6];\n\n        /* COMMENT_9 */\n                        \n        uint32_t VAR_18 = tsk_getu32(VAR_0->endian, VAR_17->start_sec);\n        uint32_t VAR_19 = tsk_getu32(VAR_0->endian, VAR_17->size_sec);\n\n        if (VAR_10)\n            tsk_fprintf(VAR_11,\n                \"load_ext: %d:%d    Start: %\" VAR_20 \"   Size: %\"\n                VAR_20 \"  Type: %d\\n\", VAR_3, VAR_6, VAR_18, VAR_19,\n                VAR_17->ptype);\n\n        if (VAR_19 == 0)\n            continue;\n\n        /* COMMENT_11 */\n                                    \n        if (dos_is_ext(VAR_17->ptype)) {\n\n            /* COMMENT_13 */\n                                                    \n                                     \n\n            if (NULL == tsk_vs_part_add(VAR_0,\n                    (TSK_DADDR_T) (VAR_2 + VAR_18),\n                    (TSK_DADDR_T) VAR_19, VAR_16,\n                    dos_get_desc(VAR_17->ptype), VAR_3, VAR_6)) {\n                free(VAR_5);\n                return 1;\n            }\n\n            if (VAR_2 + VAR_18 > VAR_9) {\n                if (VAR_10)\n                    tsk_fprintf(VAR_11,\n                        \"Starting sector %\" VAR_12\n                        \" of extended partition too large for image\\n\",\n                        VAR_2 + VAR_18);\n            }\n            /* COMMENT_16 */\n            else if (dos_load_ext_table(VAR_0, VAR_2 + VAR_18,\n                    VAR_2, VAR_3 + 1)) {\n                free(VAR_5);\n                return 1;\n            }\n        }\n\n        else {\n            /* COMMENT_17 */\n                                               \n                                   \n\n            /* COMMENT_20 */\n\n            if (NULL == tsk_vs_part_add(VAR_0,\n                    (TSK_DADDR_T) (VAR_1 + VAR_18),\n                    (TSK_DADDR_T) VAR_19, VAR_21,\n                    dos_get_desc(VAR_17->ptype), VAR_3, VAR_6)) {\n                free(VAR_5);\n                return 1;\n            }\n        }\n    }\n\n    free(VAR_5);\n    return 0;\n}",
  "func_graph_path_before": "sleuthkit/5d187980cf2f4d320670f9f3ebf6e08966bd3d35/dos.c/vul/before/0.json",
  "func": "static uint8_t\ndos_load_ext_table(TSK_VS_INFO * vs, TSK_DADDR_T sect_cur,\n    TSK_DADDR_T sect_ext_base, int table)\n{\n    dos_sect *sect;\n    char *sect_buf;\n    int i;\n    char *table_str;\n    ssize_t cnt;\n    TSK_DADDR_T max_addr = (vs->img_info->size - vs->offset) / vs->block_size;  // max sector\n\n    if (tsk_verbose)\n        tsk_fprintf(stderr,\n            \"dos_load_ext: Table Sector: %\" PRIuDADDR\n            \", Primary Base Sector: %\" PRIuDADDR \"\\n\", sect_cur,\n            sect_ext_base);\n\n    if ((sect_buf = tsk_malloc(vs->block_size)) == NULL)\n        return 1;\n    sect = (dos_sect *) sect_buf;\n\n    /* Read the partition table sector */\n    cnt = tsk_vs_read_block(vs, sect_cur, sect_buf, vs->block_size);\n    if (cnt != vs->block_size) {\n        if (cnt >= 0) {\n            tsk_error_reset();\n            tsk_error_set_errno(TSK_ERR_VS_READ);\n        }\n        tsk_error_set_errstr2(\"Extended DOS table sector %\" PRIuDADDR,\n            sect_cur);\n        free(sect_buf);\n        return 1;\n    }\n\n    /* Sanity Check */\n    if (tsk_getu16(vs->endian, sect->magic) != DOS_MAGIC) {\n        tsk_error_reset();\n        tsk_error_set_errno(TSK_ERR_VS_MAGIC);\n        tsk_error_set_errstr(\"Extended DOS partition table in sector %\"\n            PRIuDADDR, sect_cur);\n        free(sect_buf);\n        return 1;\n    }\n\n    /* Add an entry of 1 length for the table  to the internal structure */\n    if ((table_str = tsk_malloc(32)) == NULL) {\n        free(sect_buf);\n        return 1;\n    }\n\n    snprintf(table_str, 32, \"Extended Table (#%d)\", table);\n    if (NULL == tsk_vs_part_add(vs, (TSK_DADDR_T) sect_cur,\n            (TSK_DADDR_T) 1, TSK_VS_PART_FLAG_META, table_str, table,\n            -1)) {\n        free(sect_buf);\n        return 1;\n    }\n\n    /* Cycle through the four partitions in the table\n     *\n     * When another extended partition is found, it is processed\n     * inside of the loop\n     */\n    for (i = 0; i < 4; i++) {\n        dos_part *part = &sect->ptable[i];\n\n        /* Get the starting sector and size, we currently\n         * ignore CHS */\n        uint32_t part_start = tsk_getu32(vs->endian, part->start_sec);\n        uint32_t part_size = tsk_getu32(vs->endian, part->size_sec);\n\n        if (tsk_verbose)\n            tsk_fprintf(stderr,\n                \"load_ext: %d:%d    Start: %\" PRIu32 \"   Size: %\"\n                PRIu32 \"  Type: %d\\n\", table, i, part_start, part_size,\n                part->ptype);\n\n        /* part_start == 0 would cause infinite recursion */\n        if (part_size == 0 || part_start == 0)\n            continue;\n\n        /* partitions are addressed differently\n         * in extended partitions */\n        if (dos_is_ext(part->ptype)) {\n\n            /* part start is added to the start of the\n             * first extended partition (the primary\n             * extended partition) */\n\n            if (NULL == tsk_vs_part_add(vs,\n                    (TSK_DADDR_T) (sect_ext_base + part_start),\n                    (TSK_DADDR_T) part_size, TSK_VS_PART_FLAG_META,\n                    dos_get_desc(part->ptype), table, i)) {\n                free(sect_buf);\n                return 1;\n            }\n\n            if (sect_ext_base + part_start > max_addr) {\n                if (tsk_verbose)\n                    tsk_fprintf(stderr,\n                        \"Starting sector %\" PRIuDADDR\n                        \" of extended partition too large for image\\n\",\n                        sect_ext_base + part_start);\n            }\n            /* Process the extended partition */\n            else if (dos_load_ext_table(vs, sect_ext_base + part_start,\n                    sect_ext_base, table + 1)) {\n                free(sect_buf);\n                return 1;\n            }\n        }\n\n        else {\n            /* part_start is added to the start of the\n             * current partition for the actual\n             * starting location */\n\n            // we ignore the max_addr checks on extended partitions...\n\n            if (NULL == tsk_vs_part_add(vs,\n                    (TSK_DADDR_T) (sect_cur + part_start),\n                    (TSK_DADDR_T) part_size, TSK_VS_PART_FLAG_ALLOC,\n                    dos_get_desc(part->ptype), table, i)) {\n                free(sect_buf);\n                return 1;\n            }\n        }\n    }\n\n    free(sect_buf);\n    return 0;\n}",
  "abstract_func": "static uint8_t\ndos_load_ext_table(TSK_VS_INFO * VAR_0, TSK_DADDR_T VAR_1,\n    TSK_DADDR_T VAR_2, int VAR_3)\n{\n    dos_sect *VAR_4;\n    char *VAR_5;\n    int VAR_6;\n    char *VAR_7;\n    ssize_t VAR_8;\n    TSK_DADDR_T VAR_9 = (VAR_0->img_info->size - VAR_0->offset) / VAR_0->block_size;  /* COMMENT_0 */\n\n    if (VAR_10)\n        tsk_fprintf(VAR_11,\n            \"dos_load_ext: Table Sector: %\" VAR_12\n            \", Primary Base Sector: %\" VAR_12 \"\\n\", VAR_1,\n            VAR_2);\n\n    if ((VAR_5 = tsk_malloc(VAR_0->block_size)) == NULL)\n        return 1;\n    VAR_4 = (dos_sect *) VAR_5;\n\n    /* COMMENT_1 */\n    VAR_8 = tsk_vs_read_block(VAR_0, VAR_1, VAR_5, VAR_0->block_size);\n    if (VAR_8 != VAR_0->block_size) {\n        if (VAR_8 >= 0) {\n            tsk_error_reset();\n            tsk_error_set_errno(VAR_13);\n        }\n        tsk_error_set_errstr2(\"Extended DOS table sector %\" VAR_12,\n            VAR_1);\n        free(VAR_5);\n        return 1;\n    }\n\n    /* COMMENT_2 */\n    if (tsk_getu16(VAR_0->endian, VAR_4->magic) != VAR_14) {\n        tsk_error_reset();\n        tsk_error_set_errno(VAR_15);\n        tsk_error_set_errstr(\"Extended DOS partition table in sector %\"\n            VAR_12, VAR_1);\n        free(VAR_5);\n        return 1;\n    }\n\n    /* COMMENT_3 */\n    if ((VAR_7 = tsk_malloc(32)) == NULL) {\n        free(VAR_5);\n        return 1;\n    }\n\n    snprintf(VAR_7, 32, \"Extended Table (#%d)\", VAR_3);\n    if (NULL == tsk_vs_part_add(VAR_0, (TSK_DADDR_T) VAR_1,\n            (TSK_DADDR_T) 1, VAR_16, VAR_7, VAR_3,\n            -1)) {\n        free(VAR_5);\n        return 1;\n    }\n\n    /* COMMENT_4 */\n      \n                                                                \n                         \n       \n    for (VAR_6 = 0; VAR_6 < 4; VAR_6++) {\n        dos_part *VAR_17 = &VAR_4->ptable[VAR_6];\n\n        /* COMMENT_9 */\n                        \n        uint32_t VAR_18 = tsk_getu32(VAR_0->endian, VAR_17->start_sec);\n        uint32_t VAR_19 = tsk_getu32(VAR_0->endian, VAR_17->size_sec);\n\n        if (VAR_10)\n            tsk_fprintf(VAR_11,\n                \"load_ext: %d:%d    Start: %\" VAR_20 \"   Size: %\"\n                VAR_20 \"  Type: %d\\n\", VAR_3, VAR_6, VAR_18, VAR_19,\n                VAR_17->ptype);\n\n        /* COMMENT_11 */\n        if (VAR_19 == 0 || VAR_18 == 0)\n            continue;\n\n        /* COMMENT_12 */\n                                    \n        if (dos_is_ext(VAR_17->ptype)) {\n\n            /* COMMENT_14 */\n                                                    \n                                     \n\n            if (NULL == tsk_vs_part_add(VAR_0,\n                    (TSK_DADDR_T) (VAR_2 + VAR_18),\n                    (TSK_DADDR_T) VAR_19, VAR_16,\n                    dos_get_desc(VAR_17->ptype), VAR_3, VAR_6)) {\n                free(VAR_5);\n                return 1;\n            }\n\n            if (VAR_2 + VAR_18 > VAR_9) {\n                if (VAR_10)\n                    tsk_fprintf(VAR_11,\n                        \"Starting sector %\" VAR_12\n                        \" of extended partition too large for image\\n\",\n                        VAR_2 + VAR_18);\n            }\n            /* COMMENT_17 */\n            else if (dos_load_ext_table(VAR_0, VAR_2 + VAR_18,\n                    VAR_2, VAR_3 + 1)) {\n                free(VAR_5);\n                return 1;\n            }\n        }\n\n        else {\n            /* COMMENT_18 */\n                                               \n                                   \n\n            /* COMMENT_21 */\n\n            if (NULL == tsk_vs_part_add(VAR_0,\n                    (TSK_DADDR_T) (VAR_1 + VAR_18),\n                    (TSK_DADDR_T) VAR_19, VAR_21,\n                    dos_get_desc(VAR_17->ptype), VAR_3, VAR_6)) {\n                free(VAR_5);\n                return 1;\n            }\n        }\n    }\n\n    free(VAR_5);\n    return 0;\n}",
  "func_graph_path": "sleuthkit/5d187980cf2f4d320670f9f3ebf6e08966bd3d35/dos.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -75,7 +75,8 @@\n                 PRIu32 \"  Type: %d\\n\", table, i, part_start, part_size,\n                 part->ptype);\n \n-        if (part_size == 0)\n+        /* part_start == 0 would cause infinite recursion */\n+        if (part_size == 0 || part_start == 0)\n             continue;\n \n         /* partitions are addressed differently",
  "diff_line_info": {
    "deleted_lines": [
      "        if (part_size == 0)"
    ],
    "added_lines": [
      "        /* part_start == 0 would cause infinite recursion */",
      "        if (part_size == 0 || part_start == 0)"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/sleuthkit/sleuthkit/pull/939",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/sleuthkit/sleuthkit/pull/939: 403 Client Error: Forbidden for url: https://api.github.com/repos/sleuthkit/sleuthkit/pulls/939",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.6,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.6"
}