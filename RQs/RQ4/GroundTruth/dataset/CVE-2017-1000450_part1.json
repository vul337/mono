{
  "cve_id": "CVE-2017-1000450",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "opencv",
  "commit_msg": "Fix out of bounds write",
  "commit_hash": "c58152d94ba878b2d7d76bcac59146312199b9eb",
  "git_url": "https://github.com/opencv/opencv/commit/c58152d94ba878b2d7d76bcac59146312199b9eb",
  "file_path": "modules/imgcodecs/src/grfmt_bmp.cpp",
  "func_name": "BmpDecoder::readData",
  "func_before": "bool  BmpDecoder::readData( Mat& img )\n{\n    uchar* data = img.ptr();\n    int step = validateToInt(img.step);\n    bool color = img.channels() > 1;\n    uchar  gray_palette[256] = {0};\n    bool   result = false;\n    int  src_pitch = ((m_width*(m_bpp != 15 ? m_bpp : 16) + 7)/8 + 3) & -4;\n    int  nch = color ? 3 : 1;\n    int  y, width3 = m_width*nch;\n\n    if( m_offset < 0 || !m_strm.isOpened())\n        return false;\n\n    if( m_origin == IPL_ORIGIN_BL )\n    {\n        data += (m_height - 1)*(size_t)step;\n        step = -step;\n    }\n\n    AutoBuffer<uchar> _src, _bgr;\n    _src.allocate(src_pitch + 32);\n\n    if( !color )\n    {\n        if( m_bpp <= 8 )\n        {\n            CvtPaletteToGray( m_palette, gray_palette, 1 << m_bpp );\n        }\n        _bgr.allocate(m_width*3 + 32);\n    }\n    uchar *src = _src, *bgr = _bgr;\n\n    try\n    {\n        m_strm.setPos( m_offset );\n\n        switch( m_bpp )\n        {\n        /************************* 1 BPP ************************/\n        case 1:\n            for( y = 0; y < m_height; y++, data += step )\n            {\n                m_strm.getBytes( src, src_pitch );\n                FillColorRow1( color ? data : bgr, src, m_width, m_palette );\n                if( !color )\n                    icvCvt_BGR2Gray_8u_C3C1R( bgr, 0, data, 0, cvSize(m_width,1) );\n            }\n            result = true;\n            break;\n\n        /************************* 4 BPP ************************/\n        case 4:\n            if( m_rle_code == BMP_RGB )\n            {\n                for( y = 0; y < m_height; y++, data += step )\n                {\n                    m_strm.getBytes( src, src_pitch );\n                    if( color )\n                        FillColorRow4( data, src, m_width, m_palette );\n                    else\n                        FillGrayRow4( data, src, m_width, gray_palette );\n                }\n                result = true;\n            }\n            else if( m_rle_code == BMP_RLE4 ) // rle4 compression\n            {\n                uchar* line_end = data + width3;\n                y = 0;\n\n                for(;;)\n                {\n                    int code = m_strm.getWord();\n                    int len = code & 255;\n                    code >>= 8;\n                    if( len != 0 ) // encoded mode\n                    {\n                        PaletteEntry clr[2];\n                        uchar gray_clr[2];\n                        int t = 0;\n\n                        clr[0] = m_palette[code >> 4];\n                        clr[1] = m_palette[code & 15];\n                        gray_clr[0] = gray_palette[code >> 4];\n                        gray_clr[1] = gray_palette[code & 15];\n\n                        uchar* end = data + len*nch;\n                        if( end > line_end ) goto decode_rle4_bad;\n                        do\n                        {\n                            if( color )\n                                WRITE_PIX( data, clr[t] );\n                            else\n                                *data = gray_clr[t];\n                            t ^= 1;\n                        }\n                        while( (data += nch) < end );\n                    }\n                    else if( code > 2 ) // absolute mode\n                    {\n                        if( data + code*nch > line_end ) goto decode_rle4_bad;\n                        int sz = (((code + 1)>>1) + 1) & (~1);\n                        CV_Assert((size_t)sz < _src.size());\n                        m_strm.getBytes(src, sz);\n                        if( color )\n                            data = FillColorRow4( data, src, code, m_palette );\n                        else\n                            data = FillGrayRow4( data, src, code, gray_palette );\n                    }\n                    else\n                    {\n                        int x_shift3 = (int)(line_end - data);\n                        int y_shift = m_height - y;\n\n                        if( code == 2 )\n                        {\n                            x_shift3 = m_strm.getByte()*nch;\n                            y_shift = m_strm.getByte();\n                        }\n\n                        len = x_shift3 + ((y_shift * width3) & ((code == 0) - 1));\n\n                        if( color )\n                            data = FillUniColor( data, line_end, step, width3,\n                                                 y, m_height, x_shift3,\n                                                 m_palette[0] );\n                        else\n                            data = FillUniGray( data, line_end, step, width3,\n                                                y, m_height, x_shift3,\n                                                gray_palette[0] );\n\n                        if( y >= m_height )\n                            break;\n                    }\n                }\n\n                result = true;\ndecode_rle4_bad: ;\n            }\n            break;\n\n        /************************* 8 BPP ************************/\n        case 8:\n            if( m_rle_code == BMP_RGB )\n            {\n                for( y = 0; y < m_height; y++, data += step )\n                {\n                    m_strm.getBytes( src, src_pitch );\n                    if( color )\n                        FillColorRow8( data, src, m_width, m_palette );\n                    else\n                        FillGrayRow8( data, src, m_width, gray_palette );\n                }\n                result = true;\n            }\n            else if( m_rle_code == BMP_RLE8 ) // rle8 compression\n            {\n                uchar* line_end = data + width3;\n                int line_end_flag = 0;\n                y = 0;\n\n                for(;;)\n                {\n                    int code = m_strm.getWord();\n                    int len = code & 255;\n                    code >>= 8;\n                    if( len != 0 ) // encoded mode\n                    {\n                        int prev_y = y;\n                        len *= nch;\n\n                        if( data + len > line_end )\n                            goto decode_rle8_bad;\n\n                        if( color )\n                            data = FillUniColor( data, line_end, step, width3,\n                                                 y, m_height, len,\n                                                 m_palette[code] );\n                        else\n                            data = FillUniGray( data, line_end, step, width3,\n                                                y, m_height, len,\n                                                gray_palette[code] );\n\n                        line_end_flag = y - prev_y;\n                    }\n                    else if( code > 2 ) // absolute mode\n                    {\n                        int prev_y = y;\n                        int code3 = code*nch;\n\n                        if( data + code3 > line_end )\n                            goto decode_rle8_bad;\n                        int sz = (code + 1) & (~1);\n                        CV_Assert((size_t)sz < _src.size());\n                        m_strm.getBytes(src, sz);\n                        if( color )\n                            data = FillColorRow8( data, src, code, m_palette );\n                        else\n                            data = FillGrayRow8( data, src, code, gray_palette );\n\n                        line_end_flag = y - prev_y;\n                    }\n                    else\n                    {\n                        int x_shift3 = (int)(line_end - data);\n                        int y_shift = m_height - y;\n\n                        if( code || !line_end_flag || x_shift3 < width3 )\n                        {\n                            if( code == 2 )\n                            {\n                                x_shift3 = m_strm.getByte()*nch;\n                                y_shift = m_strm.getByte();\n                            }\n\n                            x_shift3 += (y_shift * width3) & ((code == 0) - 1);\n\n                            if( y >= m_height )\n                                break;\n\n                            if( color )\n                                data = FillUniColor( data, line_end, step, width3,\n                                                     y, m_height, x_shift3,\n                                                     m_palette[0] );\n                            else\n                                data = FillUniGray( data, line_end, step, width3,\n                                                    y, m_height, x_shift3,\n                                                    gray_palette[0] );\n\n                            if( y >= m_height )\n                                break;\n                        }\n\n                        line_end_flag = 0;\n                        if( y >= m_height )\n                            break;\n                    }\n                }\n\n                result = true;\ndecode_rle8_bad: ;\n            }\n            break;\n        /************************* 15 BPP ************************/\n        case 15:\n            for( y = 0; y < m_height; y++, data += step )\n            {\n                m_strm.getBytes( src, src_pitch );\n                if( !color )\n                    icvCvt_BGR5552Gray_8u_C2C1R( src, 0, data, 0, cvSize(m_width,1) );\n                else\n                    icvCvt_BGR5552BGR_8u_C2C3R( src, 0, data, 0, cvSize(m_width,1) );\n            }\n            result = true;\n            break;\n        /************************* 16 BPP ************************/\n        case 16:\n            for( y = 0; y < m_height; y++, data += step )\n            {\n                m_strm.getBytes( src, src_pitch );\n                if( !color )\n                    icvCvt_BGR5652Gray_8u_C2C1R( src, 0, data, 0, cvSize(m_width,1) );\n                else\n                    icvCvt_BGR5652BGR_8u_C2C3R( src, 0, data, 0, cvSize(m_width,1) );\n            }\n            result = true;\n            break;\n        /************************* 24 BPP ************************/\n        case 24:\n            for( y = 0; y < m_height; y++, data += step )\n            {\n                m_strm.getBytes( src, src_pitch );\n                if(!color)\n                    icvCvt_BGR2Gray_8u_C3C1R( src, 0, data, 0, cvSize(m_width,1) );\n                else\n                    memcpy( data, src, m_width*3 );\n            }\n            result = true;\n            break;\n        /************************* 32 BPP ************************/\n        case 32:\n            for( y = 0; y < m_height; y++, data += step )\n            {\n                m_strm.getBytes( src, src_pitch );\n\n                if( !color )\n                    icvCvt_BGRA2Gray_8u_C4C1R( src, 0, data, 0, cvSize(m_width,1) );\n                else\n                    icvCvt_BGRA2BGR_8u_C4C3R( src, 0, data, 0, cvSize(m_width,1) );\n            }\n            result = true;\n            break;\n        default:\n            CV_ErrorNoReturn(cv::Error::StsError, \"Invalid/unsupported mode\");\n        }\n    }\n    catch(...)\n    {\n        throw;\n    }\n\n    return result;\n}",
  "abstract_func_before": "bool  BmpDecoder::readData( Mat& VAR_0 )\n{\n    uchar* VAR_1 = VAR_0.ptr();\n    int VAR_2 = validateToInt(VAR_0.step);\n    bool VAR_3 = VAR_0.channels() > 1;\n    uchar  VAR_4[256] = {0};\n    bool   VAR_5 = false;\n    int  VAR_6 = ((VAR_7*(VAR_8 != 15 ? VAR_8 : 16) + 7)/8 + 3) & -4;\n    int  VAR_9 = VAR_3 ? 3 : 1;\n    int  VAR_10, VAR_11 = VAR_7*VAR_9;\n\n    if( VAR_12 < 0 || !VAR_13.isOpened())\n        return false;\n\n    if( VAR_14 == VAR_15 )\n    {\n        VAR_1 += (VAR_16 - 1)*(size_t)VAR_2;\n        VAR_2 = -VAR_2;\n    }\n\n    AutoBuffer<uchar> VAR_17, VAR_18;\n    VAR_17.allocate(VAR_6 + 32);\n\n    if( !VAR_3 )\n    {\n        if( VAR_8 <= 8 )\n        {\n            CvtPaletteToGray( VAR_19, VAR_4, 1 << VAR_8 );\n        }\n        VAR_18.allocate(VAR_7*3 + 32);\n    }\n    uchar *VAR_20 = VAR_17, *VAR_21 = VAR_18;\n\n    try\n    {\n        VAR_13.setPos( VAR_12 );\n\n        switch( VAR_8 )\n        {\n        /* COMMENT_0 */\n        case 1:\n            for( VAR_10 = 0; VAR_10 < VAR_16; VAR_10++, VAR_1 += VAR_2 )\n            {\n                VAR_13.getBytes( VAR_20, VAR_6 );\n                FillColorRow1( VAR_3 ? VAR_1 : VAR_21, VAR_20, VAR_7, VAR_19 );\n                if( !VAR_3 )\n                    icvCvt_BGR2Gray_8u_C3C1R( VAR_21, 0, VAR_1, 0, cvSize(VAR_7,1) );\n            }\n            VAR_5 = true;\n            break;\n\n        /* COMMENT_1 */\n        case 4:\n            if( VAR_22 == VAR_23 )\n            {\n                for( VAR_10 = 0; VAR_10 < VAR_16; VAR_10++, VAR_1 += VAR_2 )\n                {\n                    VAR_13.getBytes( VAR_20, VAR_6 );\n                    if( VAR_3 )\n                        FillColorRow4( VAR_1, VAR_20, VAR_7, VAR_19 );\n                    else\n                        FillGrayRow4( VAR_1, VAR_20, VAR_7, VAR_4 );\n                }\n                VAR_5 = true;\n            }\n            else if( VAR_22 == VAR_24 ) /* COMMENT_2 */\n            {\n                uchar* VAR_25 = VAR_1 + VAR_11;\n                VAR_10 = 0;\n\n                for(;;)\n                {\n                    int VAR_26 = VAR_13.getWord();\n                    int VAR_27 = VAR_26 & 255;\n                    VAR_26 >>= 8;\n                    if( VAR_27 != 0 ) /* COMMENT_3 */\n                    {\n                        PaletteEntry VAR_28[2];\n                        uchar VAR_29[2];\n                        int VAR_30 = 0;\n\n                        VAR_28[0] = VAR_19[VAR_26 >> 4];\n                        VAR_28[1] = VAR_19[VAR_26 & 15];\n                        VAR_29[0] = VAR_4[VAR_26 >> 4];\n                        VAR_29[1] = VAR_4[VAR_26 & 15];\n\n                        uchar* VAR_31 = VAR_1 + VAR_27*VAR_9;\n                        if( VAR_31 > VAR_25 ) goto decode_rle4_bad;\n                        do\n                        {\n                            if( VAR_3 )\n                                WRITE_PIX( VAR_1, VAR_28[VAR_30] );\n                            else\n                                *VAR_1 = VAR_29[VAR_30];\n                            VAR_30 ^= 1;\n                        }\n                        while( (VAR_1 += VAR_9) < VAR_31 );\n                    }\n                    else if( VAR_26 > 2 ) /* COMMENT_4 */\n                    {\n                        if( VAR_1 + VAR_26*VAR_9 > VAR_25 ) goto decode_rle4_bad;\n                        int VAR_32 = (((VAR_26 + 1)>>1) + 1) & (~1);\n                        CV_Assert((size_t)VAR_32 < VAR_17.size());\n                        VAR_13.getBytes(VAR_20, VAR_32);\n                        if( VAR_3 )\n                            VAR_1 = FillColorRow4( VAR_1, VAR_20, VAR_26, VAR_19 );\n                        else\n                            VAR_1 = FillGrayRow4( VAR_1, VAR_20, VAR_26, VAR_4 );\n                    }\n                    else\n                    {\n                        int VAR_33 = (int)(VAR_25 - VAR_1);\n                        int VAR_34 = VAR_16 - VAR_10;\n\n                        if( VAR_26 == 2 )\n                        {\n                            VAR_33 = VAR_13.getByte()*VAR_9;\n                            VAR_34 = VAR_13.getByte();\n                        }\n\n                        VAR_27 = VAR_33 + ((VAR_34 * VAR_11) & ((VAR_26 == 0) - 1));\n\n                        if( VAR_3 )\n                            VAR_1 = FillUniColor( VAR_1, VAR_25, VAR_2, VAR_11,\n                                                 VAR_10, VAR_16, VAR_33,\n                                                 VAR_19[0] );\n                        else\n                            VAR_1 = FillUniGray( VAR_1, VAR_25, VAR_2, VAR_11,\n                                                VAR_10, VAR_16, VAR_33,\n                                                VAR_4[0] );\n\n                        if( VAR_10 >= VAR_16 )\n                            break;\n                    }\n                }\n\n                VAR_5 = true;\ndecode_rle4_bad: ;\n            }\n            break;\n\n        /* COMMENT_5 */\n        case 8:\n            if( VAR_22 == VAR_23 )\n            {\n                for( VAR_10 = 0; VAR_10 < VAR_16; VAR_10++, VAR_1 += VAR_2 )\n                {\n                    VAR_13.getBytes( VAR_20, VAR_6 );\n                    if( VAR_3 )\n                        FillColorRow8( VAR_1, VAR_20, VAR_7, VAR_19 );\n                    else\n                        FillGrayRow8( VAR_1, VAR_20, VAR_7, VAR_4 );\n                }\n                VAR_5 = true;\n            }\n            else if( VAR_22 == VAR_35 ) /* COMMENT_6 */\n            {\n                uchar* VAR_25 = VAR_1 + VAR_11;\n                int VAR_36 = 0;\n                VAR_10 = 0;\n\n                for(;;)\n                {\n                    int VAR_26 = VAR_13.getWord();\n                    int VAR_27 = VAR_26 & 255;\n                    VAR_26 >>= 8;\n                    if( VAR_27 != 0 ) /* COMMENT_3 */\n                    {\n                        int VAR_37 = VAR_10;\n                        VAR_27 *= VAR_9;\n\n                        if( VAR_1 + VAR_27 > VAR_25 )\n                            goto decode_rle8_bad;\n\n                        if( VAR_3 )\n                            VAR_1 = FillUniColor( VAR_1, VAR_25, VAR_2, VAR_11,\n                                                 VAR_10, VAR_16, VAR_27,\n                                                 VAR_19[VAR_26] );\n                        else\n                            VAR_1 = FillUniGray( VAR_1, VAR_25, VAR_2, VAR_11,\n                                                VAR_10, VAR_16, VAR_27,\n                                                VAR_4[VAR_26] );\n\n                        VAR_36 = VAR_10 - VAR_37;\n                    }\n                    else if( VAR_26 > 2 ) /* COMMENT_4 */\n                    {\n                        int VAR_37 = VAR_10;\n                        int VAR_38 = VAR_26*VAR_9;\n\n                        if( VAR_1 + VAR_38 > VAR_25 )\n                            goto decode_rle8_bad;\n                        int VAR_32 = (VAR_26 + 1) & (~1);\n                        CV_Assert((size_t)VAR_32 < VAR_17.size());\n                        VAR_13.getBytes(VAR_20, VAR_32);\n                        if( VAR_3 )\n                            VAR_1 = FillColorRow8( VAR_1, VAR_20, VAR_26, VAR_19 );\n                        else\n                            VAR_1 = FillGrayRow8( VAR_1, VAR_20, VAR_26, VAR_4 );\n\n                        VAR_36 = VAR_10 - VAR_37;\n                    }\n                    else\n                    {\n                        int VAR_33 = (int)(VAR_25 - VAR_1);\n                        int VAR_34 = VAR_16 - VAR_10;\n\n                        if( VAR_26 || !VAR_36 || VAR_33 < VAR_11 )\n                        {\n                            if( VAR_26 == 2 )\n                            {\n                                VAR_33 = VAR_13.getByte()*VAR_9;\n                                VAR_34 = VAR_13.getByte();\n                            }\n\n                            VAR_33 += (VAR_34 * VAR_11) & ((VAR_26 == 0) - 1);\n\n                            if( VAR_10 >= VAR_16 )\n                                break;\n\n                            if( VAR_3 )\n                                VAR_1 = FillUniColor( VAR_1, VAR_25, VAR_2, VAR_11,\n                                                     VAR_10, VAR_16, VAR_33,\n                                                     VAR_19[0] );\n                            else\n                                VAR_1 = FillUniGray( VAR_1, VAR_25, VAR_2, VAR_11,\n                                                    VAR_10, VAR_16, VAR_33,\n                                                    VAR_4[0] );\n\n                            if( VAR_10 >= VAR_16 )\n                                break;\n                        }\n\n                        VAR_36 = 0;\n                        if( VAR_10 >= VAR_16 )\n                            break;\n                    }\n                }\n\n                VAR_5 = true;\ndecode_rle8_bad: ;\n            }\n            break;\n        /* COMMENT_7 */\n        case 15:\n            for( VAR_10 = 0; VAR_10 < VAR_16; VAR_10++, VAR_1 += VAR_2 )\n            {\n                VAR_13.getBytes( VAR_20, VAR_6 );\n                if( !VAR_3 )\n                    icvCvt_BGR5552Gray_8u_C2C1R( VAR_20, 0, VAR_1, 0, cvSize(VAR_7,1) );\n                else\n                    icvCvt_BGR5552BGR_8u_C2C3R( VAR_20, 0, VAR_1, 0, cvSize(VAR_7,1) );\n            }\n            VAR_5 = true;\n            break;\n        /* COMMENT_8 */\n        case 16:\n            for( VAR_10 = 0; VAR_10 < VAR_16; VAR_10++, VAR_1 += VAR_2 )\n            {\n                VAR_13.getBytes( VAR_20, VAR_6 );\n                if( !VAR_3 )\n                    icvCvt_BGR5652Gray_8u_C2C1R( VAR_20, 0, VAR_1, 0, cvSize(VAR_7,1) );\n                else\n                    icvCvt_BGR5652BGR_8u_C2C3R( VAR_20, 0, VAR_1, 0, cvSize(VAR_7,1) );\n            }\n            VAR_5 = true;\n            break;\n        /* COMMENT_9 */\n        case 24:\n            for( VAR_10 = 0; VAR_10 < VAR_16; VAR_10++, VAR_1 += VAR_2 )\n            {\n                VAR_13.getBytes( VAR_20, VAR_6 );\n                if(!VAR_3)\n                    icvCvt_BGR2Gray_8u_C3C1R( VAR_20, 0, VAR_1, 0, cvSize(VAR_7,1) );\n                else\n                    memcpy( VAR_1, VAR_20, VAR_7*3 );\n            }\n            VAR_5 = true;\n            break;\n        /* COMMENT_10 */\n        case 32:\n            for( VAR_10 = 0; VAR_10 < VAR_16; VAR_10++, VAR_1 += VAR_2 )\n            {\n                VAR_13.getBytes( VAR_20, VAR_6 );\n\n                if( !VAR_3 )\n                    icvCvt_BGRA2Gray_8u_C4C1R( VAR_20, 0, VAR_1, 0, cvSize(VAR_7,1) );\n                else\n                    icvCvt_BGRA2BGR_8u_C4C3R( VAR_20, 0, VAR_1, 0, cvSize(VAR_7,1) );\n            }\n            VAR_5 = true;\n            break;\n        default:\n            CV_ErrorNoReturn(cv::Error::StsError, \"Invalid/unsupported mode\");\n        }\n    }\n    catch(...)\n    {\n        throw;\n    }\n\n    return VAR_5;\n}",
  "func_graph_path_before": null,
  "func": "bool  BmpDecoder::readData( Mat& img )\n{\n    uchar* data = img.ptr();\n    int step = validateToInt(img.step);\n    bool color = img.channels() > 1;\n    uchar  gray_palette[256] = {0};\n    bool   result = false;\n    int  src_pitch = ((m_width*(m_bpp != 15 ? m_bpp : 16) + 7)/8 + 3) & -4;\n    int  nch = color ? 3 : 1;\n    int  y, width3 = m_width*nch;\n\n    if( m_offset < 0 || !m_strm.isOpened())\n        return false;\n\n    if( m_origin == IPL_ORIGIN_BL )\n    {\n        data += (m_height - 1)*(size_t)step;\n        step = -step;\n    }\n\n    AutoBuffer<uchar> _src, _bgr;\n    _src.allocate(src_pitch + 32);\n\n    if( !color )\n    {\n        if( m_bpp <= 8 )\n        {\n            CvtPaletteToGray( m_palette, gray_palette, 1 << m_bpp );\n        }\n        _bgr.allocate(m_width*3 + 32);\n    }\n    uchar *src = _src, *bgr = _bgr;\n\n    try\n    {\n        m_strm.setPos( m_offset );\n\n        switch( m_bpp )\n        {\n        /************************* 1 BPP ************************/\n        case 1:\n            for( y = 0; y < m_height; y++, data += step )\n            {\n                m_strm.getBytes( src, src_pitch );\n                FillColorRow1( color ? data : bgr, src, m_width, m_palette );\n                if( !color )\n                    icvCvt_BGR2Gray_8u_C3C1R( bgr, 0, data, 0, cvSize(m_width,1) );\n            }\n            result = true;\n            break;\n\n        /************************* 4 BPP ************************/\n        case 4:\n            if( m_rle_code == BMP_RGB )\n            {\n                for( y = 0; y < m_height; y++, data += step )\n                {\n                    m_strm.getBytes( src, src_pitch );\n                    if( color )\n                        FillColorRow4( data, src, m_width, m_palette );\n                    else\n                        FillGrayRow4( data, src, m_width, gray_palette );\n                }\n                result = true;\n            }\n            else if( m_rle_code == BMP_RLE4 ) // rle4 compression\n            {\n                uchar* line_end = data + width3;\n                y = 0;\n\n                for(;;)\n                {\n                    int code = m_strm.getWord();\n                    int len = code & 255;\n                    code >>= 8;\n                    if( len != 0 ) // encoded mode\n                    {\n                        PaletteEntry clr[2];\n                        uchar gray_clr[2];\n                        int t = 0;\n\n                        clr[0] = m_palette[code >> 4];\n                        clr[1] = m_palette[code & 15];\n                        gray_clr[0] = gray_palette[code >> 4];\n                        gray_clr[1] = gray_palette[code & 15];\n\n                        uchar* end = data + len*nch;\n                        if( end > line_end ) goto decode_rle4_bad;\n                        do\n                        {\n                            if( color )\n                                WRITE_PIX( data, clr[t] );\n                            else\n                                *data = gray_clr[t];\n                            t ^= 1;\n                        }\n                        while( (data += nch) < end );\n                    }\n                    else if( code > 2 ) // absolute mode\n                    {\n                        if( data + code*nch > line_end ) goto decode_rle4_bad;\n                        int sz = (((code + 1)>>1) + 1) & (~1);\n                        CV_Assert((size_t)sz < _src.size());\n                        m_strm.getBytes(src, sz);\n                        if( color )\n                            data = FillColorRow4( data, src, code, m_palette );\n                        else\n                            data = FillGrayRow4( data, src, code, gray_palette );\n                    }\n                    else\n                    {\n                        int x_shift3 = (int)(line_end - data);\n                        int y_shift = m_height - y;\n\n                        if( code == 2 )\n                        {\n                            x_shift3 = m_strm.getByte()*nch;\n                            y_shift = m_strm.getByte();\n                        }\n\n                        len = x_shift3 + ((y_shift * width3) & ((code == 0) - 1));\n\n                        if( color )\n                            data = FillUniColor( data, line_end, step, width3,\n                                                 y, m_height, x_shift3,\n                                                 m_palette[0] );\n                        else\n                            data = FillUniGray( data, line_end, step, width3,\n                                                y, m_height, x_shift3,\n                                                gray_palette[0] );\n\n                        if( y >= m_height )\n                            break;\n                    }\n                }\n\n                result = true;\ndecode_rle4_bad: ;\n            }\n            break;\n\n        /************************* 8 BPP ************************/\n        case 8:\n            if( m_rle_code == BMP_RGB )\n            {\n                for( y = 0; y < m_height; y++, data += step )\n                {\n                    m_strm.getBytes( src, src_pitch );\n                    if( color )\n                        FillColorRow8( data, src, m_width, m_palette );\n                    else\n                        FillGrayRow8( data, src, m_width, gray_palette );\n                }\n                result = true;\n            }\n            else if( m_rle_code == BMP_RLE8 ) // rle8 compression\n            {\n                uchar* line_end = data + width3;\n                int line_end_flag = 0;\n                y = 0;\n\n                for(;;)\n                {\n                    int code = m_strm.getWord();\n                    int len = code & 255;\n                    code >>= 8;\n                    if( len != 0 ) // encoded mode\n                    {\n                        int prev_y = y;\n                        len *= nch;\n\n                        if( data + len > line_end )\n                            goto decode_rle8_bad;\n\n                        if( color )\n                            data = FillUniColor( data, line_end, step, width3,\n                                                 y, m_height, len,\n                                                 m_palette[code] );\n                        else\n                            data = FillUniGray( data, line_end, step, width3,\n                                                y, m_height, len,\n                                                gray_palette[code] );\n\n                        line_end_flag = y - prev_y;\n\n                        if( y >= m_height )\n                            break;\n                    }\n                    else if( code > 2 ) // absolute mode\n                    {\n                        int prev_y = y;\n                        int code3 = code*nch;\n\n                        if( data + code3 > line_end )\n                            goto decode_rle8_bad;\n                        int sz = (code + 1) & (~1);\n                        CV_Assert((size_t)sz < _src.size());\n                        m_strm.getBytes(src, sz);\n                        if( color )\n                            data = FillColorRow8( data, src, code, m_palette );\n                        else\n                            data = FillGrayRow8( data, src, code, gray_palette );\n\n                        line_end_flag = y - prev_y;\n                    }\n                    else\n                    {\n                        int x_shift3 = (int)(line_end - data);\n                        int y_shift = m_height - y;\n\n                        if( code || !line_end_flag || x_shift3 < width3 )\n                        {\n                            if( code == 2 )\n                            {\n                                x_shift3 = m_strm.getByte()*nch;\n                                y_shift = m_strm.getByte();\n                            }\n\n                            x_shift3 += (y_shift * width3) & ((code == 0) - 1);\n\n                            if( y >= m_height )\n                                break;\n\n                            if( color )\n                                data = FillUniColor( data, line_end, step, width3,\n                                                     y, m_height, x_shift3,\n                                                     m_palette[0] );\n                            else\n                                data = FillUniGray( data, line_end, step, width3,\n                                                    y, m_height, x_shift3,\n                                                    gray_palette[0] );\n\n                            if( y >= m_height )\n                                break;\n                        }\n\n                        line_end_flag = 0;\n                        if( y >= m_height )\n                            break;\n                    }\n                }\n\n                result = true;\ndecode_rle8_bad: ;\n            }\n            break;\n        /************************* 15 BPP ************************/\n        case 15:\n            for( y = 0; y < m_height; y++, data += step )\n            {\n                m_strm.getBytes( src, src_pitch );\n                if( !color )\n                    icvCvt_BGR5552Gray_8u_C2C1R( src, 0, data, 0, cvSize(m_width,1) );\n                else\n                    icvCvt_BGR5552BGR_8u_C2C3R( src, 0, data, 0, cvSize(m_width,1) );\n            }\n            result = true;\n            break;\n        /************************* 16 BPP ************************/\n        case 16:\n            for( y = 0; y < m_height; y++, data += step )\n            {\n                m_strm.getBytes( src, src_pitch );\n                if( !color )\n                    icvCvt_BGR5652Gray_8u_C2C1R( src, 0, data, 0, cvSize(m_width,1) );\n                else\n                    icvCvt_BGR5652BGR_8u_C2C3R( src, 0, data, 0, cvSize(m_width,1) );\n            }\n            result = true;\n            break;\n        /************************* 24 BPP ************************/\n        case 24:\n            for( y = 0; y < m_height; y++, data += step )\n            {\n                m_strm.getBytes( src, src_pitch );\n                if(!color)\n                    icvCvt_BGR2Gray_8u_C3C1R( src, 0, data, 0, cvSize(m_width,1) );\n                else\n                    memcpy( data, src, m_width*3 );\n            }\n            result = true;\n            break;\n        /************************* 32 BPP ************************/\n        case 32:\n            for( y = 0; y < m_height; y++, data += step )\n            {\n                m_strm.getBytes( src, src_pitch );\n\n                if( !color )\n                    icvCvt_BGRA2Gray_8u_C4C1R( src, 0, data, 0, cvSize(m_width,1) );\n                else\n                    icvCvt_BGRA2BGR_8u_C4C3R( src, 0, data, 0, cvSize(m_width,1) );\n            }\n            result = true;\n            break;\n        default:\n            CV_ErrorNoReturn(cv::Error::StsError, \"Invalid/unsupported mode\");\n        }\n    }\n    catch(...)\n    {\n        throw;\n    }\n\n    return result;\n}",
  "abstract_func": "bool  BmpDecoder::readData( Mat& VAR_0 )\n{\n    uchar* VAR_1 = VAR_0.ptr();\n    int VAR_2 = validateToInt(VAR_0.step);\n    bool VAR_3 = VAR_0.channels() > 1;\n    uchar  VAR_4[256] = {0};\n    bool   VAR_5 = false;\n    int  VAR_6 = ((VAR_7*(VAR_8 != 15 ? VAR_8 : 16) + 7)/8 + 3) & -4;\n    int  VAR_9 = VAR_3 ? 3 : 1;\n    int  VAR_10, VAR_11 = VAR_7*VAR_9;\n\n    if( VAR_12 < 0 || !VAR_13.isOpened())\n        return false;\n\n    if( VAR_14 == VAR_15 )\n    {\n        VAR_1 += (VAR_16 - 1)*(size_t)VAR_2;\n        VAR_2 = -VAR_2;\n    }\n\n    AutoBuffer<uchar> VAR_17, VAR_18;\n    VAR_17.allocate(VAR_6 + 32);\n\n    if( !VAR_3 )\n    {\n        if( VAR_8 <= 8 )\n        {\n            CvtPaletteToGray( VAR_19, VAR_4, 1 << VAR_8 );\n        }\n        VAR_18.allocate(VAR_7*3 + 32);\n    }\n    uchar *VAR_20 = VAR_17, *VAR_21 = VAR_18;\n\n    try\n    {\n        VAR_13.setPos( VAR_12 );\n\n        switch( VAR_8 )\n        {\n        /* COMMENT_0 */\n        case 1:\n            for( VAR_10 = 0; VAR_10 < VAR_16; VAR_10++, VAR_1 += VAR_2 )\n            {\n                VAR_13.getBytes( VAR_20, VAR_6 );\n                FillColorRow1( VAR_3 ? VAR_1 : VAR_21, VAR_20, VAR_7, VAR_19 );\n                if( !VAR_3 )\n                    icvCvt_BGR2Gray_8u_C3C1R( VAR_21, 0, VAR_1, 0, cvSize(VAR_7,1) );\n            }\n            VAR_5 = true;\n            break;\n\n        /* COMMENT_1 */\n        case 4:\n            if( VAR_22 == VAR_23 )\n            {\n                for( VAR_10 = 0; VAR_10 < VAR_16; VAR_10++, VAR_1 += VAR_2 )\n                {\n                    VAR_13.getBytes( VAR_20, VAR_6 );\n                    if( VAR_3 )\n                        FillColorRow4( VAR_1, VAR_20, VAR_7, VAR_19 );\n                    else\n                        FillGrayRow4( VAR_1, VAR_20, VAR_7, VAR_4 );\n                }\n                VAR_5 = true;\n            }\n            else if( VAR_22 == VAR_24 ) /* COMMENT_2 */\n            {\n                uchar* VAR_25 = VAR_1 + VAR_11;\n                VAR_10 = 0;\n\n                for(;;)\n                {\n                    int VAR_26 = VAR_13.getWord();\n                    int VAR_27 = VAR_26 & 255;\n                    VAR_26 >>= 8;\n                    if( VAR_27 != 0 ) /* COMMENT_3 */\n                    {\n                        PaletteEntry VAR_28[2];\n                        uchar VAR_29[2];\n                        int VAR_30 = 0;\n\n                        VAR_28[0] = VAR_19[VAR_26 >> 4];\n                        VAR_28[1] = VAR_19[VAR_26 & 15];\n                        VAR_29[0] = VAR_4[VAR_26 >> 4];\n                        VAR_29[1] = VAR_4[VAR_26 & 15];\n\n                        uchar* VAR_31 = VAR_1 + VAR_27*VAR_9;\n                        if( VAR_31 > VAR_25 ) goto decode_rle4_bad;\n                        do\n                        {\n                            if( VAR_3 )\n                                WRITE_PIX( VAR_1, VAR_28[VAR_30] );\n                            else\n                                *VAR_1 = VAR_29[VAR_30];\n                            VAR_30 ^= 1;\n                        }\n                        while( (VAR_1 += VAR_9) < VAR_31 );\n                    }\n                    else if( VAR_26 > 2 ) /* COMMENT_4 */\n                    {\n                        if( VAR_1 + VAR_26*VAR_9 > VAR_25 ) goto decode_rle4_bad;\n                        int VAR_32 = (((VAR_26 + 1)>>1) + 1) & (~1);\n                        CV_Assert((size_t)VAR_32 < VAR_17.size());\n                        VAR_13.getBytes(VAR_20, VAR_32);\n                        if( VAR_3 )\n                            VAR_1 = FillColorRow4( VAR_1, VAR_20, VAR_26, VAR_19 );\n                        else\n                            VAR_1 = FillGrayRow4( VAR_1, VAR_20, VAR_26, VAR_4 );\n                    }\n                    else\n                    {\n                        int VAR_33 = (int)(VAR_25 - VAR_1);\n                        int VAR_34 = VAR_16 - VAR_10;\n\n                        if( VAR_26 == 2 )\n                        {\n                            VAR_33 = VAR_13.getByte()*VAR_9;\n                            VAR_34 = VAR_13.getByte();\n                        }\n\n                        VAR_27 = VAR_33 + ((VAR_34 * VAR_11) & ((VAR_26 == 0) - 1));\n\n                        if( VAR_3 )\n                            VAR_1 = FillUniColor( VAR_1, VAR_25, VAR_2, VAR_11,\n                                                 VAR_10, VAR_16, VAR_33,\n                                                 VAR_19[0] );\n                        else\n                            VAR_1 = FillUniGray( VAR_1, VAR_25, VAR_2, VAR_11,\n                                                VAR_10, VAR_16, VAR_33,\n                                                VAR_4[0] );\n\n                        if( VAR_10 >= VAR_16 )\n                            break;\n                    }\n                }\n\n                VAR_5 = true;\ndecode_rle4_bad: ;\n            }\n            break;\n\n        /* COMMENT_5 */\n        case 8:\n            if( VAR_22 == VAR_23 )\n            {\n                for( VAR_10 = 0; VAR_10 < VAR_16; VAR_10++, VAR_1 += VAR_2 )\n                {\n                    VAR_13.getBytes( VAR_20, VAR_6 );\n                    if( VAR_3 )\n                        FillColorRow8( VAR_1, VAR_20, VAR_7, VAR_19 );\n                    else\n                        FillGrayRow8( VAR_1, VAR_20, VAR_7, VAR_4 );\n                }\n                VAR_5 = true;\n            }\n            else if( VAR_22 == VAR_35 ) /* COMMENT_6 */\n            {\n                uchar* VAR_25 = VAR_1 + VAR_11;\n                int VAR_36 = 0;\n                VAR_10 = 0;\n\n                for(;;)\n                {\n                    int VAR_26 = VAR_13.getWord();\n                    int VAR_27 = VAR_26 & 255;\n                    VAR_26 >>= 8;\n                    if( VAR_27 != 0 ) /* COMMENT_3 */\n                    {\n                        int VAR_37 = VAR_10;\n                        VAR_27 *= VAR_9;\n\n                        if( VAR_1 + VAR_27 > VAR_25 )\n                            goto decode_rle8_bad;\n\n                        if( VAR_3 )\n                            VAR_1 = FillUniColor( VAR_1, VAR_25, VAR_2, VAR_11,\n                                                 VAR_10, VAR_16, VAR_27,\n                                                 VAR_19[VAR_26] );\n                        else\n                            VAR_1 = FillUniGray( VAR_1, VAR_25, VAR_2, VAR_11,\n                                                VAR_10, VAR_16, VAR_27,\n                                                VAR_4[VAR_26] );\n\n                        VAR_36 = VAR_10 - VAR_37;\n\n                        if( VAR_10 >= VAR_16 )\n                            break;\n                    }\n                    else if( VAR_26 > 2 ) /* COMMENT_4 */\n                    {\n                        int VAR_37 = VAR_10;\n                        int VAR_38 = VAR_26*VAR_9;\n\n                        if( VAR_1 + VAR_38 > VAR_25 )\n                            goto decode_rle8_bad;\n                        int VAR_32 = (VAR_26 + 1) & (~1);\n                        CV_Assert((size_t)VAR_32 < VAR_17.size());\n                        VAR_13.getBytes(VAR_20, VAR_32);\n                        if( VAR_3 )\n                            VAR_1 = FillColorRow8( VAR_1, VAR_20, VAR_26, VAR_19 );\n                        else\n                            VAR_1 = FillGrayRow8( VAR_1, VAR_20, VAR_26, VAR_4 );\n\n                        VAR_36 = VAR_10 - VAR_37;\n                    }\n                    else\n                    {\n                        int VAR_33 = (int)(VAR_25 - VAR_1);\n                        int VAR_34 = VAR_16 - VAR_10;\n\n                        if( VAR_26 || !VAR_36 || VAR_33 < VAR_11 )\n                        {\n                            if( VAR_26 == 2 )\n                            {\n                                VAR_33 = VAR_13.getByte()*VAR_9;\n                                VAR_34 = VAR_13.getByte();\n                            }\n\n                            VAR_33 += (VAR_34 * VAR_11) & ((VAR_26 == 0) - 1);\n\n                            if( VAR_10 >= VAR_16 )\n                                break;\n\n                            if( VAR_3 )\n                                VAR_1 = FillUniColor( VAR_1, VAR_25, VAR_2, VAR_11,\n                                                     VAR_10, VAR_16, VAR_33,\n                                                     VAR_19[0] );\n                            else\n                                VAR_1 = FillUniGray( VAR_1, VAR_25, VAR_2, VAR_11,\n                                                    VAR_10, VAR_16, VAR_33,\n                                                    VAR_4[0] );\n\n                            if( VAR_10 >= VAR_16 )\n                                break;\n                        }\n\n                        VAR_36 = 0;\n                        if( VAR_10 >= VAR_16 )\n                            break;\n                    }\n                }\n\n                VAR_5 = true;\ndecode_rle8_bad: ;\n            }\n            break;\n        /* COMMENT_7 */\n        case 15:\n            for( VAR_10 = 0; VAR_10 < VAR_16; VAR_10++, VAR_1 += VAR_2 )\n            {\n                VAR_13.getBytes( VAR_20, VAR_6 );\n                if( !VAR_3 )\n                    icvCvt_BGR5552Gray_8u_C2C1R( VAR_20, 0, VAR_1, 0, cvSize(VAR_7,1) );\n                else\n                    icvCvt_BGR5552BGR_8u_C2C3R( VAR_20, 0, VAR_1, 0, cvSize(VAR_7,1) );\n            }\n            VAR_5 = true;\n            break;\n        /* COMMENT_8 */\n        case 16:\n            for( VAR_10 = 0; VAR_10 < VAR_16; VAR_10++, VAR_1 += VAR_2 )\n            {\n                VAR_13.getBytes( VAR_20, VAR_6 );\n                if( !VAR_3 )\n                    icvCvt_BGR5652Gray_8u_C2C1R( VAR_20, 0, VAR_1, 0, cvSize(VAR_7,1) );\n                else\n                    icvCvt_BGR5652BGR_8u_C2C3R( VAR_20, 0, VAR_1, 0, cvSize(VAR_7,1) );\n            }\n            VAR_5 = true;\n            break;\n        /* COMMENT_9 */\n        case 24:\n            for( VAR_10 = 0; VAR_10 < VAR_16; VAR_10++, VAR_1 += VAR_2 )\n            {\n                VAR_13.getBytes( VAR_20, VAR_6 );\n                if(!VAR_3)\n                    icvCvt_BGR2Gray_8u_C3C1R( VAR_20, 0, VAR_1, 0, cvSize(VAR_7,1) );\n                else\n                    memcpy( VAR_1, VAR_20, VAR_7*3 );\n            }\n            VAR_5 = true;\n            break;\n        /* COMMENT_10 */\n        case 32:\n            for( VAR_10 = 0; VAR_10 < VAR_16; VAR_10++, VAR_1 += VAR_2 )\n            {\n                VAR_13.getBytes( VAR_20, VAR_6 );\n\n                if( !VAR_3 )\n                    icvCvt_BGRA2Gray_8u_C4C1R( VAR_20, 0, VAR_1, 0, cvSize(VAR_7,1) );\n                else\n                    icvCvt_BGRA2BGR_8u_C4C3R( VAR_20, 0, VAR_1, 0, cvSize(VAR_7,1) );\n            }\n            VAR_5 = true;\n            break;\n        default:\n            CV_ErrorNoReturn(cv::Error::StsError, \"Invalid/unsupported mode\");\n        }\n    }\n    catch(...)\n    {\n        throw;\n    }\n\n    return VAR_5;\n}",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -182,6 +182,9 @@\n                                                 gray_palette[code] );\n \n                         line_end_flag = y - prev_y;\n+\n+                        if( y >= m_height )\n+                            break;\n                     }\n                     else if( code > 2 ) // absolute mode\n                     {",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "",
      "                        if( y >= m_height )",
      "                            break;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/opencv/opencv/pull/9726",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/opencv/opencv/pull/9726: 403 Client Error: Forbidden for url: https://api.github.com/repos/opencv/opencv/pulls/9726",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.99,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.99"
}