{
  "cve_id": "CVE-2020-14398",
  "cwe_ids": [
    "CWE-835"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "LibVNC/libvncserver",
  "commit_msg": "libvncclient: handle half-open TCP connections\n\nWhen a connection is not reset properly at the TCP level (e.g. sudden\npower loss or process crash) the TCP connection becomes half-open and\nread() always returns -1 with errno = EAGAIN while select() always\nreturns 0. This leads to an infinite loop and can be fixed by closing\nthe connection after a certain number of retries (based on a timeout)\nhas been exceeded.",
  "commit_hash": "57433015f856cc12753378254ce4f1c78f5d9c7b",
  "git_url": "https://github.com/LibVNC/libvncserver/commit/57433015f856cc12753378254ce4f1c78f5d9c7b",
  "file_path": "libvncclient/sockets.c",
  "func_name": "ReadFromRFBServer",
  "func_before": "rfbBool\nReadFromRFBServer(rfbClient* client, char *out, unsigned int n)\n{\n#undef DEBUG_READ_EXACT\n#ifdef DEBUG_READ_EXACT\n\tchar* oout=out;\n\tunsigned int nn=n;\n\trfbClientLog(\"ReadFromRFBServer %d bytes\\n\",n);\n#endif\n\n  /* Handle attempts to write to NULL out buffer that might occur\n     when an outside malloc() fails. For instance, memcpy() to NULL\n     results in undefined behaviour and probably memory corruption.*/\n  if(!out)\n    return FALSE;\n\n  if (client->serverPort==-1) {\n    /* vncrec playing */\n    rfbVNCRec* rec = client->vncRec;\n    struct timeval tv;\n\n    if (rec->readTimestamp) {\n      rec->readTimestamp = FALSE;\n      if (!fread(&tv,sizeof(struct timeval),1,rec->file))\n        return FALSE;\n\n      tv.tv_sec = rfbClientSwap32IfLE (tv.tv_sec);\n      tv.tv_usec = rfbClientSwap32IfLE (tv.tv_usec);\n\n      if (rec->tv.tv_sec!=0 && !rec->doNotSleep) {\n        struct timeval diff;\n        diff.tv_sec = tv.tv_sec - rec->tv.tv_sec;\n        diff.tv_usec = tv.tv_usec - rec->tv.tv_usec;\n        if(diff.tv_usec<0) {\n\t  diff.tv_sec--;\n\t  diff.tv_usec+=1000000;\n        }\n#ifndef WIN32\n        sleep (diff.tv_sec);\n        usleep (diff.tv_usec);\n#else\n\tSleep (diff.tv_sec * 1000 + diff.tv_usec/1000);\n#endif\n      }\n\n      rec->tv=tv;\n    }\n    \n    return (fread(out,1,n,rec->file) != n ? FALSE : TRUE);\n  }\n  \n  if (n <= client->buffered) {\n    memcpy(out, client->bufoutptr, n);\n    client->bufoutptr += n;\n    client->buffered -= n;\n#ifdef DEBUG_READ_EXACT\n    goto hexdump;\n#endif\n    return TRUE;\n  }\n\n  memcpy(out, client->bufoutptr, client->buffered);\n\n  out += client->buffered;\n  n -= client->buffered;\n\n  client->bufoutptr = client->buf;\n  client->buffered = 0;\n\n  if (n <= RFB_BUF_SIZE) {\n\n    while (client->buffered < n) {\n      int i;\n      if (client->tlsSession)\n        i = ReadFromTLS(client, client->buf + client->buffered, RFB_BUF_SIZE - client->buffered);\n      else\n#ifdef LIBVNCSERVER_HAVE_SASL\n      if (client->saslconn)\n        i = ReadFromSASL(client, client->buf + client->buffered, RFB_BUF_SIZE - client->buffered);\n      else {\n#endif /* LIBVNCSERVER_HAVE_SASL */\n        i = read(client->sock, client->buf + client->buffered, RFB_BUF_SIZE - client->buffered);\n#ifdef WIN32\n\tif (i < 0) errno=WSAGetLastError();\n#endif\n#ifdef LIBVNCSERVER_HAVE_SASL\n      }\n#endif\n  \n      if (i <= 0) {\n\tif (i < 0) {\n\t  if (errno == EWOULDBLOCK || errno == EAGAIN) {\n\t    /* TODO:\n\t       ProcessXtEvents();\n\t    */\n\t    WaitForMessage(client, 100000);\n\t    i = 0;\n\t  } else {\n\t    rfbClientErr(\"read (%d: %s)\\n\",errno,strerror(errno));\n\t    return FALSE;\n\t  }\n\t} else {\n\t  if (errorMessageOnReadFailure) {\n\t    rfbClientLog(\"VNC server closed connection\\n\");\n\t  }\n\t  return FALSE;\n\t}\n      }\n      client->buffered += i;\n    }\n\n    memcpy(out, client->bufoutptr, n);\n    client->bufoutptr += n;\n    client->buffered -= n;\n\n  } else {\n\n    while (n > 0) {\n      int i;\n      if (client->tlsSession)\n        i = ReadFromTLS(client, out, n);\n      else\n#ifdef LIBVNCSERVER_HAVE_SASL\n      if (client->saslconn)\n        i = ReadFromSASL(client, out, n);\n      else\n#endif\n        i = read(client->sock, out, n);\n\n      if (i <= 0) {\n\tif (i < 0) {\n#ifdef WIN32\n\t  errno=WSAGetLastError();\n#endif\n\t  if (errno == EWOULDBLOCK || errno == EAGAIN) {\n\t    /* TODO:\n\t       ProcessXtEvents();\n\t    */\n\t    WaitForMessage(client, 100000);\n\t    i = 0;\n\t  } else {\n\t    rfbClientErr(\"read (%s)\\n\",strerror(errno));\n\t    return FALSE;\n\t  }\n\t} else {\n\t  if (errorMessageOnReadFailure) {\n\t    rfbClientLog(\"VNC server closed connection\\n\");\n\t  }\n\t  return FALSE;\n\t}\n      }\n      out += i;\n      n -= i;\n    }\n  }\n\n#ifdef DEBUG_READ_EXACT\nhexdump:\n  { unsigned int ii;\n    for(ii=0;ii<nn;ii++)\n      fprintf(stderr,\"%02x \",(unsigned char)oout[ii]);\n    fprintf(stderr,\"\\n\");\n  }\n#endif\n\n  return TRUE;\n}",
  "abstract_func_before": "rfbBool\nReadFromRFBServer(rfbClient* VAR_0, char *VAR_1, unsigned int VAR_2)\n{\n#undef DEBUG_READ_EXACT\n#ifdef VAR_3\n\tchar* VAR_4=VAR_1;\n\tunsigned int VAR_5=VAR_2;\n\trfbClientLog(\"ReadFromRFBServer %d bytes\\n\",VAR_2);\n#endif\n\n  /* COMMENT_0 */\n                                                                   \n                                                                     \n  if(!VAR_1)\n    return FALSE;\n\n  if (VAR_0->serverPort==-1) {\n    /* COMMENT_3 */\n    rfbVNCRec* VAR_6 = VAR_0->vncRec;\n    struct timeval VAR_7;\n\n    if (VAR_6->readTimestamp) {\n      VAR_6->readTimestamp = FALSE;\n      if (!fread(&VAR_7,sizeof(struct timeval),1,VAR_6->file))\n        return FALSE;\n\n      VAR_7.tv_sec = rfbClientSwap32IfLE (VAR_7.tv_sec);\n      VAR_7.tv_usec = rfbClientSwap32IfLE (VAR_7.tv_usec);\n\n      if (VAR_6->tv.tv_sec!=0 && !VAR_6->doNotSleep) {\n        struct timeval VAR_8;\n        VAR_8.tv_sec = VAR_7.tv_sec - VAR_6->tv.tv_sec;\n        VAR_8.tv_usec = VAR_7.tv_usec - VAR_6->tv.tv_usec;\n        if(VAR_8.tv_usec<0) {\n\t  VAR_8.tv_sec--;\n\t  VAR_8.tv_usec+=1000000;\n        }\n#ifndef VAR_9\n        sleep (VAR_8.tv_sec);\n        usleep (VAR_8.tv_usec);\n#else\n\tSleep (VAR_8.tv_sec * 1000 + VAR_8.tv_usec/1000);\n#endif\n      }\n\n      VAR_6->tv=VAR_7;\n    }\n    \n    return (fread(VAR_1,1,VAR_2,VAR_6->file) != VAR_2 ? FALSE : TRUE);\n  }\n  \n  if (VAR_2 <= VAR_0->buffered) {\n    memcpy(VAR_1, VAR_0->bufoutptr, VAR_2);\n    VAR_0->bufoutptr += VAR_2;\n    VAR_0->buffered -= VAR_2;\n#ifdef VAR_3\n    goto hexdump;\n#endif\n    return TRUE;\n  }\n\n  memcpy(VAR_1, VAR_0->bufoutptr, VAR_0->buffered);\n\n  VAR_1 += VAR_0->buffered;\n  VAR_2 -= VAR_0->buffered;\n\n  VAR_0->bufoutptr = VAR_0->buf;\n  VAR_0->buffered = 0;\n\n  if (VAR_2 <= VAR_10) {\n\n    while (VAR_0->buffered < VAR_2) {\n      int VAR_11;\n      if (VAR_0->tlsSession)\n        VAR_11 = ReadFromTLS(VAR_0, VAR_0->buf + VAR_0->buffered, VAR_10 - VAR_0->buffered);\n      else\n#ifdef VAR_12\n      if (VAR_0->saslconn)\n        VAR_11 = ReadFromSASL(VAR_0, VAR_0->buf + VAR_0->buffered, VAR_10 - VAR_0->buffered);\n      else {\n#endif/* COMMENT_4 */\n        i = read(client->sock, client->buf + client->buffered, RFB_BUF_SIZE - client->buffered);\n#ifdef VAR_9\n\tif (VAR_11 < 0) VAR_13=WSAGetLastError();\n#endif\n#ifdef VAR_12\n      }\n#endif\n  \n      if (VAR_11 <= 0) {\n\tif (VAR_11 < 0) {\n\t  if (VAR_13 == VAR_14 || VAR_13 == VAR_15) {\n\t    /* COMMENT_5 */\n                          \n       \n\t    WaitForMessage(VAR_0, 100000);\n\t    VAR_11 = 0;\n\t  } else {\n\t    rfbClientErr(\"read (%d: %s)\\n\",VAR_13,strerror(VAR_13));\n\t    return FALSE;\n\t  }\n\t} else {\n\t  if (VAR_16) {\n\t    rfbClientLog(\"VNC server closed connection\\n\");\n\t  }\n\t  return FALSE;\n\t}\n      }\n      VAR_0->buffered += VAR_11;\n    }\n\n    memcpy(VAR_1, VAR_0->bufoutptr, VAR_2);\n    VAR_0->bufoutptr += VAR_2;\n    VAR_0->buffered -= VAR_2;\n\n  } else {\n\n    while (VAR_2 > 0) {\n      int VAR_11;\n      if (VAR_0->tlsSession)\n        VAR_11 = ReadFromTLS(VAR_0, VAR_1, VAR_2);\n      else\n#ifdef VAR_12\n      if (VAR_0->saslconn)\n        VAR_11 = ReadFromSASL(VAR_0, VAR_1, VAR_2);\n      else\n#endif\n        VAR_11 = read(VAR_0->sock, VAR_1, VAR_2);\n\n      if (VAR_11 <= 0) {\n\tif (VAR_11 < 0) {\n#ifdef VAR_9\n\t  VAR_13=WSAGetLastError();\n#endif\n\t  if (VAR_13 == VAR_14 || VAR_13 == VAR_15) {\n\t    /* COMMENT_8 */\n                          \n       \n\t    WaitForMessage(VAR_0, 100000);\n\t    VAR_11 = 0;\n\t  } else {\n\t    rfbClientErr(\"read (%s)\\n\",strerror(VAR_13));\n\t    return FALSE;\n\t  }\n\t} else {\n\t  if (VAR_16) {\n\t    rfbClientLog(\"VNC server closed connection\\n\");\n\t  }\n\t  return FALSE;\n\t}\n      }\n      VAR_1 += VAR_11;\n      VAR_2 -= VAR_11;\n    }\n  }\n\n#ifdef VAR_3\nhexdump:\n  { unsigned int VAR_17;\n    for(VAR_17=0;VAR_17<VAR_5;VAR_17++)\n      fprintf(VAR_18,\"%02x \",(unsigned char)VAR_4[VAR_17]);\n    fprintf(VAR_18,\"\\n\");\n  }\n#endif\n\n  return TRUE;\n}",
  "func_graph_path_before": "LibVNC/libvncserver/57433015f856cc12753378254ce4f1c78f5d9c7b/sockets.c/vul/before/0.json",
  "func": "rfbBool\nReadFromRFBServer(rfbClient* client, char *out, unsigned int n)\n{\n  const int USECS_WAIT_PER_RETRY = 100000;\n  int retries = 0;\n#undef DEBUG_READ_EXACT\n#ifdef DEBUG_READ_EXACT\n\tchar* oout=out;\n\tunsigned int nn=n;\n\trfbClientLog(\"ReadFromRFBServer %d bytes\\n\",n);\n#endif\n\n  /* Handle attempts to write to NULL out buffer that might occur\n     when an outside malloc() fails. For instance, memcpy() to NULL\n     results in undefined behaviour and probably memory corruption.*/\n  if(!out)\n    return FALSE;\n\n  if (client->serverPort==-1) {\n    /* vncrec playing */\n    rfbVNCRec* rec = client->vncRec;\n    struct timeval tv;\n\n    if (rec->readTimestamp) {\n      rec->readTimestamp = FALSE;\n      if (!fread(&tv,sizeof(struct timeval),1,rec->file))\n        return FALSE;\n\n      tv.tv_sec = rfbClientSwap32IfLE (tv.tv_sec);\n      tv.tv_usec = rfbClientSwap32IfLE (tv.tv_usec);\n\n      if (rec->tv.tv_sec!=0 && !rec->doNotSleep) {\n        struct timeval diff;\n        diff.tv_sec = tv.tv_sec - rec->tv.tv_sec;\n        diff.tv_usec = tv.tv_usec - rec->tv.tv_usec;\n        if(diff.tv_usec<0) {\n\t  diff.tv_sec--;\n\t  diff.tv_usec+=1000000;\n        }\n#ifndef WIN32\n        sleep (diff.tv_sec);\n        usleep (diff.tv_usec);\n#else\n\tSleep (diff.tv_sec * 1000 + diff.tv_usec/1000);\n#endif\n      }\n\n      rec->tv=tv;\n    }\n    \n    return (fread(out,1,n,rec->file) != n ? FALSE : TRUE);\n  }\n  \n  if (n <= client->buffered) {\n    memcpy(out, client->bufoutptr, n);\n    client->bufoutptr += n;\n    client->buffered -= n;\n#ifdef DEBUG_READ_EXACT\n    goto hexdump;\n#endif\n    return TRUE;\n  }\n\n  memcpy(out, client->bufoutptr, client->buffered);\n\n  out += client->buffered;\n  n -= client->buffered;\n\n  client->bufoutptr = client->buf;\n  client->buffered = 0;\n\n  if (n <= RFB_BUF_SIZE) {\n\n    while (client->buffered < n) {\n      int i;\n      if (client->tlsSession)\n        i = ReadFromTLS(client, client->buf + client->buffered, RFB_BUF_SIZE - client->buffered);\n      else\n#ifdef LIBVNCSERVER_HAVE_SASL\n      if (client->saslconn)\n        i = ReadFromSASL(client, client->buf + client->buffered, RFB_BUF_SIZE - client->buffered);\n      else {\n#endif /* LIBVNCSERVER_HAVE_SASL */\n        i = read(client->sock, client->buf + client->buffered, RFB_BUF_SIZE - client->buffered);\n#ifdef WIN32\n\tif (i < 0) errno=WSAGetLastError();\n#endif\n#ifdef LIBVNCSERVER_HAVE_SASL\n      }\n#endif\n  \n      if (i <= 0) {\n\tif (i < 0) {\n\t  if (errno == EWOULDBLOCK || errno == EAGAIN) {\n\t    if (client->readTimeout > 0 &&\n\t\t++retries > (client->readTimeout * 1000 * 1000 / USECS_WAIT_PER_RETRY))\n\t    {\n\t      rfbClientLog(\"Connection timed out\\n\");\n\t      return FALSE;\n\t    }\n\t    /* TODO:\n\t       ProcessXtEvents();\n\t    */\n\t    WaitForMessage(client, USECS_WAIT_PER_RETRY);\n\t    i = 0;\n\t  } else {\n\t    rfbClientErr(\"read (%d: %s)\\n\",errno,strerror(errno));\n\t    return FALSE;\n\t  }\n\t} else {\n\t  if (errorMessageOnReadFailure) {\n\t    rfbClientLog(\"VNC server closed connection\\n\");\n\t  }\n\t  return FALSE;\n\t}\n      }\n      client->buffered += i;\n    }\n\n    memcpy(out, client->bufoutptr, n);\n    client->bufoutptr += n;\n    client->buffered -= n;\n\n  } else {\n\n    while (n > 0) {\n      int i;\n      if (client->tlsSession)\n        i = ReadFromTLS(client, out, n);\n      else\n#ifdef LIBVNCSERVER_HAVE_SASL\n      if (client->saslconn)\n        i = ReadFromSASL(client, out, n);\n      else\n#endif\n        i = read(client->sock, out, n);\n\n      if (i <= 0) {\n\tif (i < 0) {\n#ifdef WIN32\n\t  errno=WSAGetLastError();\n#endif\n\t  if (errno == EWOULDBLOCK || errno == EAGAIN) {\n\t    if (client->readTimeout > 0 &&\n\t\t++retries > (client->readTimeout * 1000 * 1000 / USECS_WAIT_PER_RETRY))\n\t    {\n\t\trfbClientLog(\"Connection timed out\\n\");\n\t\treturn FALSE;\n\t    }\n\t    /* TODO:\n\t       ProcessXtEvents();\n\t    */\n\t    WaitForMessage(client, USECS_WAIT_PER_RETRY);\n\t    i = 0;\n\t  } else {\n\t    rfbClientErr(\"read (%s)\\n\",strerror(errno));\n\t    return FALSE;\n\t  }\n\t} else {\n\t  if (errorMessageOnReadFailure) {\n\t    rfbClientLog(\"VNC server closed connection\\n\");\n\t  }\n\t  return FALSE;\n\t}\n      }\n      out += i;\n      n -= i;\n    }\n  }\n\n#ifdef DEBUG_READ_EXACT\nhexdump:\n  { unsigned int ii;\n    for(ii=0;ii<nn;ii++)\n      fprintf(stderr,\"%02x \",(unsigned char)oout[ii]);\n    fprintf(stderr,\"\\n\");\n  }\n#endif\n\n  return TRUE;\n}",
  "abstract_func": "rfbBool\nReadFromRFBServer(rfbClient* VAR_0, char *VAR_1, unsigned int VAR_2)\n{\n  const int VAR_3 = 100000;\n  int VAR_4 = 0;\n#undef DEBUG_READ_EXACT\n#ifdef VAR_5\n\tchar* VAR_6=VAR_1;\n\tunsigned int VAR_7=VAR_2;\n\trfbClientLog(\"ReadFromRFBServer %d bytes\\n\",VAR_2);\n#endif\n\n  /* COMMENT_0 */\n                                                                   \n                                                                     \n  if(!VAR_1)\n    return FALSE;\n\n  if (VAR_0->serverPort==-1) {\n    /* COMMENT_3 */\n    rfbVNCRec* VAR_8 = VAR_0->vncRec;\n    struct timeval VAR_9;\n\n    if (VAR_8->readTimestamp) {\n      VAR_8->readTimestamp = FALSE;\n      if (!fread(&VAR_9,sizeof(struct timeval),1,VAR_8->file))\n        return FALSE;\n\n      VAR_9.tv_sec = rfbClientSwap32IfLE (VAR_9.tv_sec);\n      VAR_9.tv_usec = rfbClientSwap32IfLE (VAR_9.tv_usec);\n\n      if (VAR_8->tv.tv_sec!=0 && !VAR_8->doNotSleep) {\n        struct timeval VAR_10;\n        VAR_10.tv_sec = VAR_9.tv_sec - VAR_8->tv.tv_sec;\n        VAR_10.tv_usec = VAR_9.tv_usec - VAR_8->tv.tv_usec;\n        if(VAR_10.tv_usec<0) {\n\t  VAR_10.tv_sec--;\n\t  VAR_10.tv_usec+=1000000;\n        }\n#ifndef VAR_11\n        sleep (VAR_10.tv_sec);\n        usleep (VAR_10.tv_usec);\n#else\n\tSleep (VAR_10.tv_sec * 1000 + VAR_10.tv_usec/1000);\n#endif\n      }\n\n      VAR_8->tv=VAR_9;\n    }\n    \n    return (fread(VAR_1,1,VAR_2,VAR_8->file) != VAR_2 ? FALSE : TRUE);\n  }\n  \n  if (VAR_2 <= VAR_0->buffered) {\n    memcpy(VAR_1, VAR_0->bufoutptr, VAR_2);\n    VAR_0->bufoutptr += VAR_2;\n    VAR_0->buffered -= VAR_2;\n#ifdef VAR_5\n    goto hexdump;\n#endif\n    return TRUE;\n  }\n\n  memcpy(VAR_1, VAR_0->bufoutptr, VAR_0->buffered);\n\n  VAR_1 += VAR_0->buffered;\n  VAR_2 -= VAR_0->buffered;\n\n  VAR_0->bufoutptr = VAR_0->buf;\n  VAR_0->buffered = 0;\n\n  if (VAR_2 <= VAR_12) {\n\n    while (VAR_0->buffered < VAR_2) {\n      int VAR_13;\n      if (VAR_0->tlsSession)\n        VAR_13 = ReadFromTLS(VAR_0, VAR_0->buf + VAR_0->buffered, VAR_12 - VAR_0->buffered);\n      else\n#ifdef VAR_14\n      if (VAR_0->saslconn)\n        VAR_13 = ReadFromSASL(VAR_0, VAR_0->buf + VAR_0->buffered, VAR_12 - VAR_0->buffered);\n      else {\n#endif/* COMMENT_4 */\n        i = read(client->sock, client->buf + client->buffered, RFB_BUF_SIZE - client->buffered);\n#ifdef VAR_11\n\tif (VAR_13 < 0) VAR_15=WSAGetLastError();\n#endif\n#ifdef VAR_14\n      }\n#endif\n  \n      if (VAR_13 <= 0) {\n\tif (VAR_13 < 0) {\n\t  if (VAR_15 == VAR_16 || VAR_15 == VAR_17) {\n\t    if (VAR_0->readTimeout > 0 &&\n\t\t++VAR_4 > (VAR_0->readTimeout * 1000 * 1000 / VAR_3))\n\t    {\n\t      rfbClientLog(\"Connection timed out\\n\");\n\t      return FALSE;\n\t    }\n\t    /* COMMENT_5 */\n                          \n       \n\t    WaitForMessage(VAR_0, VAR_3);\n\t    VAR_13 = 0;\n\t  } else {\n\t    rfbClientErr(\"read (%d: %s)\\n\",VAR_15,strerror(VAR_15));\n\t    return FALSE;\n\t  }\n\t} else {\n\t  if (VAR_18) {\n\t    rfbClientLog(\"VNC server closed connection\\n\");\n\t  }\n\t  return FALSE;\n\t}\n      }\n      VAR_0->buffered += VAR_13;\n    }\n\n    memcpy(VAR_1, VAR_0->bufoutptr, VAR_2);\n    VAR_0->bufoutptr += VAR_2;\n    VAR_0->buffered -= VAR_2;\n\n  } else {\n\n    while (VAR_2 > 0) {\n      int VAR_13;\n      if (VAR_0->tlsSession)\n        VAR_13 = ReadFromTLS(VAR_0, VAR_1, VAR_2);\n      else\n#ifdef VAR_14\n      if (VAR_0->saslconn)\n        VAR_13 = ReadFromSASL(VAR_0, VAR_1, VAR_2);\n      else\n#endif\n        VAR_13 = read(VAR_0->sock, VAR_1, VAR_2);\n\n      if (VAR_13 <= 0) {\n\tif (VAR_13 < 0) {\n#ifdef VAR_11\n\t  VAR_15=WSAGetLastError();\n#endif\n\t  if (VAR_15 == VAR_16 || VAR_15 == VAR_17) {\n\t    if (VAR_0->readTimeout > 0 &&\n\t\t++VAR_4 > (VAR_0->readTimeout * 1000 * 1000 / VAR_3))\n\t    {\n\t\trfbClientLog(\"Connection timed out\\n\");\n\t\treturn FALSE;\n\t    }\n\t    /* COMMENT_8 */\n                          \n       \n\t    WaitForMessage(VAR_0, VAR_3);\n\t    VAR_13 = 0;\n\t  } else {\n\t    rfbClientErr(\"read (%s)\\n\",strerror(VAR_15));\n\t    return FALSE;\n\t  }\n\t} else {\n\t  if (VAR_18) {\n\t    rfbClientLog(\"VNC server closed connection\\n\");\n\t  }\n\t  return FALSE;\n\t}\n      }\n      VAR_1 += VAR_13;\n      VAR_2 -= VAR_13;\n    }\n  }\n\n#ifdef VAR_5\nhexdump:\n  { unsigned int VAR_19;\n    for(VAR_19=0;VAR_19<VAR_7;VAR_19++)\n      fprintf(VAR_20,\"%02x \",(unsigned char)VAR_6[VAR_19]);\n    fprintf(VAR_20,\"\\n\");\n  }\n#endif\n\n  return TRUE;\n}",
  "func_graph_path": "LibVNC/libvncserver/57433015f856cc12753378254ce4f1c78f5d9c7b/sockets.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,8 @@\n rfbBool\n ReadFromRFBServer(rfbClient* client, char *out, unsigned int n)\n {\n+  const int USECS_WAIT_PER_RETRY = 100000;\n+  int retries = 0;\n #undef DEBUG_READ_EXACT\n #ifdef DEBUG_READ_EXACT\n \tchar* oout=out;\n@@ -90,10 +92,16 @@\n       if (i <= 0) {\n \tif (i < 0) {\n \t  if (errno == EWOULDBLOCK || errno == EAGAIN) {\n+\t    if (client->readTimeout > 0 &&\n+\t\t++retries > (client->readTimeout * 1000 * 1000 / USECS_WAIT_PER_RETRY))\n+\t    {\n+\t      rfbClientLog(\"Connection timed out\\n\");\n+\t      return FALSE;\n+\t    }\n \t    /* TODO:\n \t       ProcessXtEvents();\n \t    */\n-\t    WaitForMessage(client, 100000);\n+\t    WaitForMessage(client, USECS_WAIT_PER_RETRY);\n \t    i = 0;\n \t  } else {\n \t    rfbClientErr(\"read (%d: %s)\\n\",errno,strerror(errno));\n@@ -133,10 +141,16 @@\n \t  errno=WSAGetLastError();\n #endif\n \t  if (errno == EWOULDBLOCK || errno == EAGAIN) {\n+\t    if (client->readTimeout > 0 &&\n+\t\t++retries > (client->readTimeout * 1000 * 1000 / USECS_WAIT_PER_RETRY))\n+\t    {\n+\t\trfbClientLog(\"Connection timed out\\n\");\n+\t\treturn FALSE;\n+\t    }\n \t    /* TODO:\n \t       ProcessXtEvents();\n \t    */\n-\t    WaitForMessage(client, 100000);\n+\t    WaitForMessage(client, USECS_WAIT_PER_RETRY);\n \t    i = 0;\n \t  } else {\n \t    rfbClientErr(\"read (%s)\\n\",strerror(errno));",
  "diff_line_info": {
    "deleted_lines": [
      "\t    WaitForMessage(client, 100000);",
      "\t    WaitForMessage(client, 100000);"
    ],
    "added_lines": [
      "  const int USECS_WAIT_PER_RETRY = 100000;",
      "  int retries = 0;",
      "\t    if (client->readTimeout > 0 &&",
      "\t\t++retries > (client->readTimeout * 1000 * 1000 / USECS_WAIT_PER_RETRY))",
      "\t    {",
      "\t      rfbClientLog(\"Connection timed out\\n\");",
      "\t      return FALSE;",
      "\t    }",
      "\t    WaitForMessage(client, USECS_WAIT_PER_RETRY);",
      "\t    if (client->readTimeout > 0 &&",
      "\t\t++retries > (client->readTimeout * 1000 * 1000 / USECS_WAIT_PER_RETRY))",
      "\t    {",
      "\t\trfbClientLog(\"Connection timed out\\n\");",
      "\t\treturn FALSE;",
      "\t    }",
      "\t    WaitForMessage(client, USECS_WAIT_PER_RETRY);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/LibVNC/libvncserver/pull/400",
  "description": {
    "pr_info": {
      "title": "libvncclient: handle half-open TCP connections",
      "number": 400
    },
    "comment": [
      "When a connection is not reset properly at the TCP level (e.g. sudden power loss or process crash) the TCP connection becomes half-open and read() always returns -1 with errno = EAGAIN while select() always returns 0. This leads to an infinite loop and can be fixed by closing the connection after a certain number of retries (based on a timeout) has been exceeded.\r\n",
      "(looks like AppVeyor failed because of libpng download error/server timeout and not an actual code issue)"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95"
}