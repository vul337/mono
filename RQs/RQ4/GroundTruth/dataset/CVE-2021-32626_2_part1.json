{
  "cve_id": "CVE-2021-32626",
  "cwe_ids": [
    "CWE-787",
    "CWE-122"
  ],
  "cvss_vector": "AV:N/AC:L/Au:S/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "redis",
  "commit_msg": "Fix invalid memory write on lua stack overflow {CVE-2021-32626}\n\nWhen LUA call our C code, by default, the LUA stack has room for 20\nelements. In most cases, this is more than enough but sometimes it's not\nand the caller must verify the LUA stack size before he pushes elements.\n\nOn 3 places in the code, there was no verification of the LUA stack size.\nOn specific inputs this missing verification could have lead to invalid\nmemory write:\n1. On 'luaReplyToRedisReply', one might return a nested reply that will\n   explode the LUA stack.\n2. On 'redisProtocolToLuaType', the Redis reply might be deep enough\n   to explode the LUA stack (notice that currently there is no such\n   command in Redis that returns such a nested reply, but modules might\n   do it)\n3. On 'ldbRedis', one might give a command with enough arguments to\n   explode the LUA stack (all the arguments will be pushed to the LUA\n   stack)\n\nThis commit is solving all those 3 issues by calling 'lua_checkstack' and\nverify that there is enough room in the LUA stack to push elements. In\ncase 'lua_checkstack' returns an error (there is not enough room in the\nLUA stack and it's not possible to increase the stack), we will do the\nfollowing:\n1. On 'luaReplyToRedisReply', we will return an error to the user.\n2. On 'redisProtocolToLuaType' we will exit with panic (we assume this\n   scenario is rare because it can only happen with a module).\n3. On 'ldbRedis', we return an error.",
  "commit_hash": "666ed7facf4524bf6d19b11b20faa2cf93fdf591",
  "git_url": "https://github.com/redis/redis/commit/666ed7facf4524bf6d19b11b20faa2cf93fdf591",
  "file_path": "src/scripting.c",
  "func_name": "redisProtocolToLuaType_Aggregate",
  "func_before": "char *redisProtocolToLuaType_Aggregate(lua_State *lua, char *reply, int atype) {\n    char *p = strchr(reply+1,'\\r');\n    long long mbulklen;\n    int j = 0;\n\n    string2ll(reply+1,p-reply-1,&mbulklen);\n    if (server.lua_client->resp == 2 || atype == '*') {\n        p += 2;\n        if (mbulklen == -1) {\n            lua_pushboolean(lua,0);\n            return p;\n        }\n        lua_newtable(lua);\n        for (j = 0; j < mbulklen; j++) {\n            lua_pushnumber(lua,j+1);\n            p = redisProtocolToLuaType(lua,p);\n            lua_settable(lua,-3);\n        }\n    } else if (server.lua_client->resp == 3) {\n        /* Here we handle only Set and Map replies in RESP3 mode, since arrays\n         * follow the above RESP2 code path. Note that those are represented\n         * as a table with the \"map\" or \"set\" field populated with the actual\n         * table representing the set or the map type. */\n        p += 2;\n        lua_newtable(lua);\n        lua_pushstring(lua,atype == '%' ? \"map\" : \"set\");\n        lua_newtable(lua);\n        for (j = 0; j < mbulklen; j++) {\n            p = redisProtocolToLuaType(lua,p);\n            if (atype == '%') {\n                p = redisProtocolToLuaType(lua,p);\n            } else {\n                lua_pushboolean(lua,1);\n            }\n            lua_settable(lua,-3);\n        }\n        lua_settable(lua,-3);\n    }\n    return p;\n}",
  "abstract_func_before": "char *redisProtocolToLuaType_Aggregate(lua_State *VAR_0, char *VAR_1, int VAR_2) {\n    char *VAR_3 = strchr(VAR_1+1,'\\r');\n    long long VAR_4;\n    int VAR_5 = 0;\n\n    string2ll(VAR_1+1,VAR_3-VAR_1-1,&VAR_4);\n    if (VAR_6.lua_client->resp == 2 || VAR_2 == '*') {\n        VAR_3 += 2;\n        if (VAR_4 == -1) {\n            lua_pushboolean(VAR_0,0);\n            return VAR_3;\n        }\n        lua_newtable(VAR_0);\n        for (VAR_5 = 0; VAR_5 < VAR_4; VAR_5++) {\n            lua_pushnumber(VAR_0,VAR_5+1);\n            VAR_3 = redisProtocolToLuaType(VAR_0,VAR_3);\n            lua_settable(VAR_0,-3);\n        }\n    } else if (VAR_6.lua_client->resp == 3) {\n        /* COMMENT_0 */\n                                                                            \n                                                                             \n                                                         \n        VAR_3 += 2;\n        lua_newtable(VAR_0);\n        lua_pushstring(VAR_0,VAR_2 == '%' ? \"map\" : \"set\");\n        lua_newtable(VAR_0);\n        for (VAR_5 = 0; VAR_5 < VAR_4; VAR_5++) {\n            VAR_3 = redisProtocolToLuaType(VAR_0,VAR_3);\n            if (VAR_2 == '%') {\n                VAR_3 = redisProtocolToLuaType(VAR_0,VAR_3);\n            } else {\n                lua_pushboolean(VAR_0,1);\n            }\n            lua_settable(VAR_0,-3);\n        }\n        lua_settable(VAR_0,-3);\n    }\n    return VAR_3;\n}",
  "func_graph_path_before": "redis/666ed7facf4524bf6d19b11b20faa2cf93fdf591/scripting.c/vul/before/3.json",
  "func": "char *redisProtocolToLuaType_Aggregate(lua_State *lua, char *reply, int atype) {\n    char *p = strchr(reply+1,'\\r');\n    long long mbulklen;\n    int j = 0;\n\n    string2ll(reply+1,p-reply-1,&mbulklen);\n    if (server.lua_client->resp == 2 || atype == '*') {\n        p += 2;\n        if (mbulklen == -1) {\n            lua_pushboolean(lua,0);\n            return p;\n        }\n        lua_newtable(lua);\n        for (j = 0; j < mbulklen; j++) {\n            lua_pushnumber(lua,j+1);\n            p = redisProtocolToLuaType(lua,p);\n            lua_settable(lua,-3);\n        }\n    } else if (server.lua_client->resp == 3) {\n        /* Here we handle only Set and Map replies in RESP3 mode, since arrays\n         * follow the above RESP2 code path. Note that those are represented\n         * as a table with the \"map\" or \"set\" field populated with the actual\n         * table representing the set or the map type. */\n        p += 2;\n        lua_newtable(lua);\n        lua_pushstring(lua,atype == '%' ? \"map\" : \"set\");\n        lua_newtable(lua);\n        for (j = 0; j < mbulklen; j++) {\n            p = redisProtocolToLuaType(lua,p);\n            if (atype == '%') {\n                p = redisProtocolToLuaType(lua,p);\n            } else {\n                if (!lua_checkstack(lua, 1)) {\n                    /* Notice that here we need to check the stack again because the recursive\n                     * call to redisProtocolToLuaType might have use the room allocated in the stack */\n                    serverPanic(\"lua stack limit reach when parsing redis.call reply\");\n                }\n                lua_pushboolean(lua,1);\n            }\n            lua_settable(lua,-3);\n        }\n        lua_settable(lua,-3);\n    }\n    return p;\n}",
  "abstract_func": "char *redisProtocolToLuaType_Aggregate(lua_State *VAR_0, char *VAR_1, int VAR_2) {\n    char *VAR_3 = strchr(VAR_1+1,'\\r');\n    long long VAR_4;\n    int VAR_5 = 0;\n\n    string2ll(VAR_1+1,VAR_3-VAR_1-1,&VAR_4);\n    if (VAR_6.lua_client->resp == 2 || VAR_2 == '*') {\n        VAR_3 += 2;\n        if (VAR_4 == -1) {\n            lua_pushboolean(VAR_0,0);\n            return VAR_3;\n        }\n        lua_newtable(VAR_0);\n        for (VAR_5 = 0; VAR_5 < VAR_4; VAR_5++) {\n            lua_pushnumber(VAR_0,VAR_5+1);\n            VAR_3 = redisProtocolToLuaType(VAR_0,VAR_3);\n            lua_settable(VAR_0,-3);\n        }\n    } else if (VAR_6.lua_client->resp == 3) {\n        /* COMMENT_0 */\n                                                                            \n                                                                             \n                                                         \n        VAR_3 += 2;\n        lua_newtable(VAR_0);\n        lua_pushstring(VAR_0,VAR_2 == '%' ? \"map\" : \"set\");\n        lua_newtable(VAR_0);\n        for (VAR_5 = 0; VAR_5 < VAR_4; VAR_5++) {\n            VAR_3 = redisProtocolToLuaType(VAR_0,VAR_3);\n            if (VAR_2 == '%') {\n                VAR_3 = redisProtocolToLuaType(VAR_0,VAR_3);\n            } else {\n                if (!lua_checkstack(VAR_0, 1)) {\n                    /* COMMENT_4 */\n                                                                                                       \n                    serverPanic(\"lua stack limit reach when parsing redis.call reply\");\n                }\n                lua_pushboolean(VAR_0,1);\n            }\n            lua_settable(VAR_0,-3);\n        }\n        lua_settable(VAR_0,-3);\n    }\n    return VAR_3;\n}",
  "func_graph_path": "redis/666ed7facf4524bf6d19b11b20faa2cf93fdf591/scripting.c/vul/after/3.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -30,6 +30,11 @@\n             if (atype == '%') {\n                 p = redisProtocolToLuaType(lua,p);\n             } else {\n+                if (!lua_checkstack(lua, 1)) {\n+                    /* Notice that here we need to check the stack again because the recursive\n+                     * call to redisProtocolToLuaType might have use the room allocated in the stack */\n+                    serverPanic(\"lua stack limit reach when parsing redis.call reply\");\n+                }\n                 lua_pushboolean(lua,1);\n             }\n             lua_settable(lua,-3);",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "                if (!lua_checkstack(lua, 1)) {",
      "                    /* Notice that here we need to check the stack again because the recursive",
      "                     * call to redisProtocolToLuaType might have use the room allocated in the stack */",
      "                    serverPanic(\"lua stack limit reach when parsing redis.call reply\");",
      "                }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/redis/redis/pull/9584",
  "description": {
    "pr_info": {
      "title": "Release 6.0.16",
      "number": 9584
    },
    "comment": [
      "Upgrade urgency: SECURITY, contains fixes to security issues.\r\n\r\nSecurity Fixes:\r\n* (CVE-2021-41099) Integer to heap buffer overflow handling certain string\r\n  commands and network payloads, when proto-max-bulk-len is manually configured\r\n  to a non-default, very large value [reported by yiyuaner].\r\n* (CVE-2021-32762) Integer to heap buffer overflow issue in redis-cli and\r\n  redis-sentinel parsing large multi-bulk replies on some older and less common\r\n  platforms [reported by Microsoft Vulnerability Research].\r\n* (CVE-2021-32687) Integer to heap buffer overflow with intsets, when\r\n  set-max-intset-entries is manually configured to a non-default, very large\r\n  value [reported by Pawel Wieczorkiewicz, AWS].\r\n* (CVE-2021-32675) Denial Of Service when processing RESP request payloads with\r\n  a large number of elements on many connections.\r\n* (CVE-2021-32672) Random heap reading issue with Lua Debugger [reported by\r\n  Meir Shpilraien].\r\n* (CVE-2021-32628) Integer to heap buffer overflow handling ziplist-encoded\r\n  data types, when configuring a large, non-default value for\r\n  hash-max-ziplist-entries, hash-max-ziplist-value, zset-max-ziplist-entries\r\n  or zset-max-ziplist-value [reported by sundb].\r\n* (CVE-2021-32627) Integer to heap buffer overflow issue with streams, when\r\n  configuring a non-default, large value for proto-max-bulk-len and\r\n  client-query-buffer-limit [reported by sundb].\r\n* (CVE-2021-32626) Specially crafted Lua scripts may result with Heap buffer\r\n  overflow [reported by Meir Shpilraien].\r\n\r\nOther bug fixes:\r\n* Fix appendfsync to always guarantee fsync before reply, on MacOS and FreeBSD (kqueue) (#9416)\r\n* Fix the wrong mis-detection of sync_file_range system call, affecting performance (#9371)\r\n* Fix replication issues when repl-diskless-load is used (#9280)\r\n",
      "CI failures on MacOS (due to tests being timing sensitive): \r\n```\r\n*** [err]: No write if min-slaves-max-lag is > of the slave lag in tests/integration/replication-2.tcl\r\nExpected 'NOREPLICAS*' to equal or match 'OK'\r\n*** [err]: With min-slaves-to-write: master not writable with lagged slave in tests/integration/replication-4.tcl\r\nExpected 'NOREPLICAS*' to equal or match 'OK'\r\nCleanup: may take some time... OK\r\n```\r\nsolved by #8461 and #8583\r\n\r\nalso, the `build-ubuntu-old` CI got hung (probably no longer supported)",
      "Hi,\r\n [hi_sdsMakeRoomFor](https://github.com/redis/redis/blob/4930d19e70c391750479951022e207e19111eb55/deps/hiredis/sds.c#L196)  in deps/hiredis/sds.c wouldn't c487a9c03f89498976b3b6574df2cac763af16cc commit be applicable for hiredis code as well?\r\n",
      "Pinging @michael-grunder, do you think this fix is relevant for hiredis?"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0\n\n**Step-by-Step Explanation:**\n\n1. **Input Analysis:**  \n   The commit message references \"CVE-2021-32626\" and mentions \"invalid memory write on lua stack overflow.\" The code diff shows modifications adding `lua_checkstack` calls and handling stack overflow errors.\n\n2. **Consistency Check:**  \n   The code changes align with the commit message's description of fixing stack overflow vulnerabilities by adding stack size verification.\n\n3. **Purpose Evaluation:**  \n   The purpose is to prevent heap buffer overflow caused by Lua stack overflows, which is a security issue.\n\n4. **Security Vulnerability Assessment:**  \n   The patch addresses a known security vulnerability (CVE-2021-32626) by adding necessary checks to prevent invalid memory writes, which are critical security fixes.\n\n5. **Confidence Scoring:**  \n   All elements (commit message, code changes, vulnerability description) consistently point to a security fix, with explicit CVE reference and clear purpose. Hence, confidence is high.\n\n**Final Output:**  \n**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}