{
  "cve_id": "CVE-2018-16790",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "mongodb/mongo-c-driver",
  "commit_msg": "Fix for CVE-2018-16790 -- Verify bounds before binary length read.\n\nAs reported here: https://jira.mongodb.org/browse/CDRIVER-2819,\na heap overread occurs due a failure to correctly verify data\nbounds.\n\nIn the original check, len - o returns the data left including the\nsizeof(l) we just read. Instead, the comparison should check\nagainst the data left NOT including the binary int32, i.e. just\nsubtype (byte*) instead of int32 subtype (byte*).\n\nAdded in test for corrupted BSON example.",
  "commit_hash": "0d9a4d98bfdf4acd2c0138d4aaeb4e2e0934bd84",
  "git_url": "https://github.com/mongodb/mongo-c-driver/commit/0d9a4d98bfdf4acd2c0138d4aaeb4e2e0934bd84",
  "file_path": "src/libbson/src/bson/bson-iter.c",
  "func_name": "_bson_iter_next_internal",
  "func_before": "static bool\n_bson_iter_next_internal (bson_iter_t *iter,    /* INOUT */\n                          uint32_t next_keylen, /* IN */\n                          const char **key,     /* OUT */\n                          uint32_t *bson_type,  /* OUT */\n                          bool *unsupported)    /* OUT */\n{\n   const uint8_t *data;\n   uint32_t o;\n   unsigned int len;\n\n   BSON_ASSERT (iter);\n\n   *unsupported = false;\n\n   if (!iter->raw) {\n      *key = NULL;\n      *bson_type = BSON_TYPE_EOD;\n      return false;\n   }\n\n   data = iter->raw;\n   len = iter->len;\n\n   iter->off = iter->next_off;\n   iter->type = iter->off;\n   iter->key = iter->off + 1;\n   iter->d1 = 0;\n   iter->d2 = 0;\n   iter->d3 = 0;\n   iter->d4 = 0;\n\n   if (next_keylen == 0) {\n      /* iterate from start to end of NULL-terminated key string */\n      for (o = iter->key; o < len; o++) {\n         if (!data[o]) {\n            iter->d1 = ++o;\n            goto fill_data_fields;\n         }\n      }\n   } else {\n      o = iter->key + next_keylen + 1;\n      iter->d1 = o;\n      goto fill_data_fields;\n   }\n\n   goto mark_invalid;\n\nfill_data_fields:\n\n   *key = bson_iter_key_unsafe (iter);\n   *bson_type = ITER_TYPE (iter);\n\n   switch (*bson_type) {\n   case BSON_TYPE_DATE_TIME:\n   case BSON_TYPE_DOUBLE:\n   case BSON_TYPE_INT64:\n   case BSON_TYPE_TIMESTAMP:\n      iter->next_off = o + 8;\n      break;\n   case BSON_TYPE_CODE:\n   case BSON_TYPE_SYMBOL:\n   case BSON_TYPE_UTF8: {\n      uint32_t l;\n\n      if ((o + 4) >= len) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      iter->d2 = o + 4;\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);\n\n      if (l > (len - (o + 4))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      iter->next_off = o + 4 + l;\n\n      /*\n       * Make sure the string length includes the NUL byte.\n       */\n      if (BSON_UNLIKELY ((l == 0) || (iter->next_off >= len))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      /*\n       * Make sure the last byte is a NUL byte.\n       */\n      if (BSON_UNLIKELY ((iter->raw + iter->d2)[l - 1] != '\\0')) {\n         iter->err_off = o + 4 + l - 1;\n         goto mark_invalid;\n      }\n   } break;\n   case BSON_TYPE_BINARY: {\n      bson_subtype_t subtype;\n      uint32_t l;\n\n      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      iter->d2 = o + 4;\n      iter->d3 = o + 5;\n\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);\n\n      if (l >= (len - o)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      subtype = *(iter->raw + iter->d2);\n\n      if (subtype == BSON_SUBTYPE_BINARY_DEPRECATED) {\n         int32_t binary_len;\n\n         if (l < 4) {\n            iter->err_off = o;\n            goto mark_invalid;\n         }\n\n         /* subtype 2 has a redundant length header in the data */\n         memcpy (&binary_len, (iter->raw + iter->d3), sizeof (binary_len));\n         binary_len = BSON_UINT32_FROM_LE (binary_len);\n         if (binary_len + 4 != l) {\n            iter->err_off = iter->d3;\n            goto mark_invalid;\n         }\n      }\n\n      iter->next_off = o + 5 + l;\n   } break;\n   case BSON_TYPE_ARRAY:\n   case BSON_TYPE_DOCUMENT: {\n      uint32_t l;\n\n      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);\n\n      if ((l > len) || (l > (len - o))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      iter->next_off = o + l;\n   } break;\n   case BSON_TYPE_OID:\n      iter->next_off = o + 12;\n      break;\n   case BSON_TYPE_BOOL: {\n      char val;\n\n      if (iter->d1 >= len) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      memcpy (&val, iter->raw + iter->d1, 1);\n      if (val != 0x00 && val != 0x01) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      iter->next_off = o + 1;\n   } break;\n   case BSON_TYPE_REGEX: {\n      bool eor = false;\n      bool eoo = false;\n\n      for (; o < len; o++) {\n         if (!data[o]) {\n            iter->d2 = ++o;\n            eor = true;\n            break;\n         }\n      }\n\n      if (!eor) {\n         iter->err_off = iter->next_off;\n         goto mark_invalid;\n      }\n\n      for (; o < len; o++) {\n         if (!data[o]) {\n            eoo = true;\n            break;\n         }\n      }\n\n      if (!eoo) {\n         iter->err_off = iter->next_off;\n         goto mark_invalid;\n      }\n\n      iter->next_off = o + 1;\n   } break;\n   case BSON_TYPE_DBPOINTER: {\n      uint32_t l;\n\n      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      iter->d2 = o + 4;\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);\n\n      /* Check valid string length. l counts '\\0' but not 4 bytes for itself. */\n      if (l == 0 || l > (len - o - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      if (*(iter->raw + o + l + 3)) {\n         /* not null terminated */\n         iter->err_off = o + l + 3;\n         goto mark_invalid;\n      }\n\n      iter->d3 = o + 4 + l;\n      iter->next_off = o + 4 + l + 12;\n   } break;\n   case BSON_TYPE_CODEWSCOPE: {\n      uint32_t l;\n      uint32_t doclen;\n\n      if ((len < 19) || (o >= (len - 14))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      iter->d2 = o + 4;\n      iter->d3 = o + 8;\n\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);\n\n      if ((l < 14) || (l >= (len - o))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      iter->next_off = o + l;\n\n      if (iter->next_off >= len) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      memcpy (&l, iter->raw + iter->d2, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);\n\n      if (l == 0 || l >= (len - o - 4 - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      if ((o + 4 + 4 + l + 4) >= iter->next_off) {\n         iter->err_off = o + 4;\n         goto mark_invalid;\n      }\n\n      iter->d4 = o + 4 + 4 + l;\n      memcpy (&doclen, iter->raw + iter->d4, sizeof (doclen));\n      doclen = BSON_UINT32_FROM_LE (doclen);\n\n      if ((o + 4 + 4 + l + doclen) != iter->next_off) {\n         iter->err_off = o + 4 + 4 + l;\n         goto mark_invalid;\n      }\n   } break;\n   case BSON_TYPE_INT32:\n      iter->next_off = o + 4;\n      break;\n   case BSON_TYPE_DECIMAL128:\n      iter->next_off = o + 16;\n      break;\n   case BSON_TYPE_MAXKEY:\n   case BSON_TYPE_MINKEY:\n   case BSON_TYPE_NULL:\n   case BSON_TYPE_UNDEFINED:\n      iter->next_off = o;\n      break;\n   default:\n      *unsupported = true;\n   /* FALL THROUGH */\n   case BSON_TYPE_EOD:\n      iter->err_off = o;\n      goto mark_invalid;\n   }\n\n   /*\n    * Check to see if any of the field locations would overflow the\n    * current BSON buffer. If so, set the error location to the offset\n    * of where the field starts.\n    */\n   if (iter->next_off >= len) {\n      iter->err_off = o;\n      goto mark_invalid;\n   }\n\n   iter->err_off = 0;\n\n   return true;\n\nmark_invalid:\n   iter->raw = NULL;\n   iter->len = 0;\n   iter->next_off = 0;\n\n   return false;\n}",
  "abstract_func_before": "static bool\n_bson_iter_next_internal (bson_iter_t *VAR_0,    /* COMMENT_0 */\n                          uint32_t VAR_1, /* COMMENT_1 */\n                          const char **VAR_2,     /* COMMENT_2 */\n                          uint32_t *VAR_3,  /* COMMENT_2 */\n                          bool *VAR_4)    /* COMMENT_2 */\n{\n   const uint8_t *VAR_5;\n   uint32_t VAR_6;\n   unsigned int VAR_7;\n\n   BSON_ASSERT (VAR_0);\n\n   *VAR_4 = false;\n\n   if (!VAR_0->raw) {\n      *VAR_2 = NULL;\n      *VAR_3 = VAR_8;\n      return false;\n   }\n\n   VAR_5 = VAR_0->raw;\n   VAR_7 = VAR_0->len;\n\n   VAR_0->off = VAR_0->next_off;\n   VAR_0->type = VAR_0->off;\n   VAR_0->key = VAR_0->off + 1;\n   VAR_0->d1 = 0;\n   VAR_0->d2 = 0;\n   VAR_0->d3 = 0;\n   VAR_0->d4 = 0;\n\n   if (VAR_1 == 0) {\n      /* COMMENT_3 */\n      for (VAR_6 = VAR_0->key; VAR_6 < VAR_7; VAR_6++) {\n         if (!VAR_5[VAR_6]) {\n            VAR_0->d1 = ++VAR_6;\n            goto fill_data_fields;\n         }\n      }\n   } else {\n      VAR_6 = VAR_0->key + VAR_1 + 1;\n      VAR_0->d1 = VAR_6;\n      goto fill_data_fields;\n   }\n\n   goto mark_invalid;\n\nfill_data_fields:\n\n   *VAR_2 = bson_iter_key_unsafe (VAR_0);\n   *VAR_3 = ITER_TYPE (VAR_0);\n\n   switch (*VAR_3) {\n   case VAR_9:\n   case VAR_10:\n   case VAR_11:\n   case VAR_12:\n      VAR_0->next_off = VAR_6 + 8;\n      break;\n   case VAR_13:\n   case VAR_14:\n   case VAR_15: {\n      uint32_t VAR_16;\n\n      if ((VAR_6 + 4) >= VAR_7) {\n         VAR_0->err_off = VAR_6;\n         goto mark_invalid;\n      }\n\n      VAR_0->d2 = VAR_6 + 4;\n      memcpy (&VAR_16, VAR_0->raw + VAR_0->d1, sizeof (VAR_16));\n      VAR_16 = BSON_UINT32_FROM_LE (VAR_16);\n\n      if (VAR_16 > (VAR_7 - (VAR_6 + 4))) {\n         VAR_0->err_off = VAR_6;\n         goto mark_invalid;\n      }\n\n      VAR_0->next_off = VAR_6 + 4 + VAR_16;\n\n      /* COMMENT_4 */\n                                                           \n         \n      if (BSON_UNLIKELY ((VAR_16 == 0) || (VAR_0->next_off >= VAR_7))) {\n         VAR_0->err_off = VAR_6;\n         goto mark_invalid;\n      }\n\n      /* COMMENT_7 */\n                                               \n         \n      if (BSON_UNLIKELY ((VAR_0->raw + VAR_0->d2)[VAR_16 - 1] != '\\0')) {\n         VAR_0->err_off = VAR_6 + 4 + VAR_16 - 1;\n         goto mark_invalid;\n      }\n   } break;\n   case VAR_17: {\n      bson_subtype_t VAR_18;\n      uint32_t VAR_16;\n\n      if (VAR_6 >= (VAR_7 - 4)) {\n         VAR_0->err_off = VAR_6;\n         goto mark_invalid;\n      }\n\n      VAR_0->d2 = VAR_6 + 4;\n      VAR_0->d3 = VAR_6 + 5;\n\n      memcpy (&VAR_16, VAR_0->raw + VAR_0->d1, sizeof (VAR_16));\n      VAR_16 = BSON_UINT32_FROM_LE (VAR_16);\n\n      if (VAR_16 >= (VAR_7 - VAR_6)) {\n         VAR_0->err_off = VAR_6;\n         goto mark_invalid;\n      }\n\n      VAR_18 = *(VAR_0->raw + VAR_0->d2);\n\n      if (VAR_18 == VAR_19) {\n         int32_t VAR_20;\n\n         if (VAR_16 < 4) {\n            VAR_0->err_off = VAR_6;\n            goto mark_invalid;\n         }\n\n         /* COMMENT_10 */\n         memcpy (&VAR_20, (VAR_0->raw + VAR_0->d3), sizeof (VAR_20));\n         VAR_20 = BSON_UINT32_FROM_LE (VAR_20);\n         if (VAR_20 + 4 != VAR_16) {\n            VAR_0->err_off = VAR_0->d3;\n            goto mark_invalid;\n         }\n      }\n\n      VAR_0->next_off = VAR_6 + 5 + VAR_16;\n   } break;\n   case VAR_21:\n   case VAR_22: {\n      uint32_t VAR_16;\n\n      if (VAR_6 >= (VAR_7 - 4)) {\n         VAR_0->err_off = VAR_6;\n         goto mark_invalid;\n      }\n\n      memcpy (&VAR_16, VAR_0->raw + VAR_0->d1, sizeof (VAR_16));\n      VAR_16 = BSON_UINT32_FROM_LE (VAR_16);\n\n      if ((VAR_16 > VAR_7) || (VAR_16 > (VAR_7 - VAR_6))) {\n         VAR_0->err_off = VAR_6;\n         goto mark_invalid;\n      }\n\n      VAR_0->next_off = VAR_6 + VAR_16;\n   } break;\n   case VAR_23:\n      VAR_0->next_off = VAR_6 + 12;\n      break;\n   case VAR_24: {\n      char VAR_25;\n\n      if (VAR_0->d1 >= VAR_7) {\n         VAR_0->err_off = VAR_6;\n         goto mark_invalid;\n      }\n\n      memcpy (&VAR_25, VAR_0->raw + VAR_0->d1, 1);\n      if (VAR_25 != 0x00 && VAR_25 != 0x01) {\n         VAR_0->err_off = VAR_6;\n         goto mark_invalid;\n      }\n\n      VAR_0->next_off = VAR_6 + 1;\n   } break;\n   case VAR_26: {\n      bool VAR_27 = false;\n      bool VAR_28 = false;\n\n      for (; VAR_6 < VAR_7; VAR_6++) {\n         if (!VAR_5[VAR_6]) {\n            VAR_0->d2 = ++VAR_6;\n            VAR_27 = true;\n            break;\n         }\n      }\n\n      if (!VAR_27) {\n         VAR_0->err_off = VAR_0->next_off;\n         goto mark_invalid;\n      }\n\n      for (; VAR_6 < VAR_7; VAR_6++) {\n         if (!VAR_5[VAR_6]) {\n            VAR_28 = true;\n            break;\n         }\n      }\n\n      if (!VAR_28) {\n         VAR_0->err_off = VAR_0->next_off;\n         goto mark_invalid;\n      }\n\n      VAR_0->next_off = VAR_6 + 1;\n   } break;\n   case VAR_29: {\n      uint32_t VAR_16;\n\n      if (VAR_6 >= (VAR_7 - 4)) {\n         VAR_0->err_off = VAR_6;\n         goto mark_invalid;\n      }\n\n      VAR_0->d2 = VAR_6 + 4;\n      memcpy (&VAR_16, VAR_0->raw + VAR_0->d1, sizeof (VAR_16));\n      VAR_16 = BSON_UINT32_FROM_LE (VAR_16);\n\n      /* COMMENT_11 */\n      if (VAR_16 == 0 || VAR_16 > (VAR_7 - VAR_6 - 4)) {\n         VAR_0->err_off = VAR_6;\n         goto mark_invalid;\n      }\n\n      if (*(VAR_0->raw + VAR_6 + VAR_16 + 3)) {\n         /* COMMENT_12 */\n         VAR_0->err_off = VAR_6 + VAR_16 + 3;\n         goto mark_invalid;\n      }\n\n      VAR_0->d3 = VAR_6 + 4 + VAR_16;\n      VAR_0->next_off = VAR_6 + 4 + VAR_16 + 12;\n   } break;\n   case VAR_30: {\n      uint32_t VAR_16;\n      uint32_t VAR_31;\n\n      if ((VAR_7 < 19) || (VAR_6 >= (VAR_7 - 14))) {\n         VAR_0->err_off = VAR_6;\n         goto mark_invalid;\n      }\n\n      VAR_0->d2 = VAR_6 + 4;\n      VAR_0->d3 = VAR_6 + 8;\n\n      memcpy (&VAR_16, VAR_0->raw + VAR_0->d1, sizeof (VAR_16));\n      VAR_16 = BSON_UINT32_FROM_LE (VAR_16);\n\n      if ((VAR_16 < 14) || (VAR_16 >= (VAR_7 - VAR_6))) {\n         VAR_0->err_off = VAR_6;\n         goto mark_invalid;\n      }\n\n      VAR_0->next_off = VAR_6 + VAR_16;\n\n      if (VAR_0->next_off >= VAR_7) {\n         VAR_0->err_off = VAR_6;\n         goto mark_invalid;\n      }\n\n      memcpy (&VAR_16, VAR_0->raw + VAR_0->d2, sizeof (VAR_16));\n      VAR_16 = BSON_UINT32_FROM_LE (VAR_16);\n\n      if (VAR_16 == 0 || VAR_16 >= (VAR_7 - VAR_6 - 4 - 4)) {\n         VAR_0->err_off = VAR_6;\n         goto mark_invalid;\n      }\n\n      if ((VAR_6 + 4 + 4 + VAR_16 + 4) >= VAR_0->next_off) {\n         VAR_0->err_off = VAR_6 + 4;\n         goto mark_invalid;\n      }\n\n      VAR_0->d4 = VAR_6 + 4 + 4 + VAR_16;\n      memcpy (&VAR_31, VAR_0->raw + VAR_0->d4, sizeof (VAR_31));\n      VAR_31 = BSON_UINT32_FROM_LE (VAR_31);\n\n      if ((VAR_6 + 4 + 4 + VAR_16 + VAR_31) != VAR_0->next_off) {\n         VAR_0->err_off = VAR_6 + 4 + 4 + VAR_16;\n         goto mark_invalid;\n      }\n   } break;\n   case VAR_32:\n      VAR_0->next_off = VAR_6 + 4;\n      break;\n   case VAR_33:\n      VAR_0->next_off = VAR_6 + 16;\n      break;\n   case VAR_34:\n   case VAR_35:\n   case VAR_36:\n   case VAR_37:\n      VAR_0->next_off = VAR_6;\n      break;\n   default:\n      *VAR_4 = true;\n   /* COMMENT_13 */\n   case VAR_8:\n      VAR_0->err_off = VAR_6;\n      goto mark_invalid;\n   }\n\n   /* COMMENT_14 */\n                                                                   \n                                                                      \n                                \n      \n   if (VAR_0->next_off >= VAR_7) {\n      VAR_0->err_off = VAR_6;\n      goto mark_invalid;\n   }\n\n   VAR_0->err_off = 0;\n\n   return true;\n\nmark_invalid:\n   VAR_0->raw = NULL;\n   VAR_0->len = 0;\n   VAR_0->next_off = 0;\n\n   return false;\n}",
  "func_graph_path_before": "mongodb/mongo-c-driver/0d9a4d98bfdf4acd2c0138d4aaeb4e2e0934bd84/bson-iter.c/vul/before/0.json",
  "func": "static bool\n_bson_iter_next_internal (bson_iter_t *iter,    /* INOUT */\n                          uint32_t next_keylen, /* IN */\n                          const char **key,     /* OUT */\n                          uint32_t *bson_type,  /* OUT */\n                          bool *unsupported)    /* OUT */\n{\n   const uint8_t *data;\n   uint32_t o;\n   unsigned int len;\n\n   BSON_ASSERT (iter);\n\n   *unsupported = false;\n\n   if (!iter->raw) {\n      *key = NULL;\n      *bson_type = BSON_TYPE_EOD;\n      return false;\n   }\n\n   data = iter->raw;\n   len = iter->len;\n\n   iter->off = iter->next_off;\n   iter->type = iter->off;\n   iter->key = iter->off + 1;\n   iter->d1 = 0;\n   iter->d2 = 0;\n   iter->d3 = 0;\n   iter->d4 = 0;\n\n   if (next_keylen == 0) {\n      /* iterate from start to end of NULL-terminated key string */\n      for (o = iter->key; o < len; o++) {\n         if (!data[o]) {\n            iter->d1 = ++o;\n            goto fill_data_fields;\n         }\n      }\n   } else {\n      o = iter->key + next_keylen + 1;\n      iter->d1 = o;\n      goto fill_data_fields;\n   }\n\n   goto mark_invalid;\n\nfill_data_fields:\n\n   *key = bson_iter_key_unsafe (iter);\n   *bson_type = ITER_TYPE (iter);\n\n   switch (*bson_type) {\n   case BSON_TYPE_DATE_TIME:\n   case BSON_TYPE_DOUBLE:\n   case BSON_TYPE_INT64:\n   case BSON_TYPE_TIMESTAMP:\n      iter->next_off = o + 8;\n      break;\n   case BSON_TYPE_CODE:\n   case BSON_TYPE_SYMBOL:\n   case BSON_TYPE_UTF8: {\n      uint32_t l;\n\n      if ((o + 4) >= len) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      iter->d2 = o + 4;\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);\n\n      if (l > (len - (o + 4))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      iter->next_off = o + 4 + l;\n\n      /*\n       * Make sure the string length includes the NUL byte.\n       */\n      if (BSON_UNLIKELY ((l == 0) || (iter->next_off >= len))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      /*\n       * Make sure the last byte is a NUL byte.\n       */\n      if (BSON_UNLIKELY ((iter->raw + iter->d2)[l - 1] != '\\0')) {\n         iter->err_off = o + 4 + l - 1;\n         goto mark_invalid;\n      }\n   } break;\n   case BSON_TYPE_BINARY: {\n      bson_subtype_t subtype;\n      uint32_t l;\n\n      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      iter->d2 = o + 4;\n      iter->d3 = o + 5;\n\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);\n\n      if (l >= (len - o - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      subtype = *(iter->raw + iter->d2);\n\n      if (subtype == BSON_SUBTYPE_BINARY_DEPRECATED) {\n         int32_t binary_len;\n\n         if (l < 4) {\n            iter->err_off = o;\n            goto mark_invalid;\n         }\n\n         /* subtype 2 has a redundant length header in the data */\n         memcpy (&binary_len, (iter->raw + iter->d3), sizeof (binary_len));\n         binary_len = BSON_UINT32_FROM_LE (binary_len);\n         if (binary_len + 4 != l) {\n            iter->err_off = iter->d3;\n            goto mark_invalid;\n         }\n      }\n\n      iter->next_off = o + 5 + l;\n   } break;\n   case BSON_TYPE_ARRAY:\n   case BSON_TYPE_DOCUMENT: {\n      uint32_t l;\n\n      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);\n\n      if ((l > len) || (l > (len - o))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      iter->next_off = o + l;\n   } break;\n   case BSON_TYPE_OID:\n      iter->next_off = o + 12;\n      break;\n   case BSON_TYPE_BOOL: {\n      char val;\n\n      if (iter->d1 >= len) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      memcpy (&val, iter->raw + iter->d1, 1);\n      if (val != 0x00 && val != 0x01) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      iter->next_off = o + 1;\n   } break;\n   case BSON_TYPE_REGEX: {\n      bool eor = false;\n      bool eoo = false;\n\n      for (; o < len; o++) {\n         if (!data[o]) {\n            iter->d2 = ++o;\n            eor = true;\n            break;\n         }\n      }\n\n      if (!eor) {\n         iter->err_off = iter->next_off;\n         goto mark_invalid;\n      }\n\n      for (; o < len; o++) {\n         if (!data[o]) {\n            eoo = true;\n            break;\n         }\n      }\n\n      if (!eoo) {\n         iter->err_off = iter->next_off;\n         goto mark_invalid;\n      }\n\n      iter->next_off = o + 1;\n   } break;\n   case BSON_TYPE_DBPOINTER: {\n      uint32_t l;\n\n      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      iter->d2 = o + 4;\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);\n\n      /* Check valid string length. l counts '\\0' but not 4 bytes for itself. */\n      if (l == 0 || l > (len - o - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      if (*(iter->raw + o + l + 3)) {\n         /* not null terminated */\n         iter->err_off = o + l + 3;\n         goto mark_invalid;\n      }\n\n      iter->d3 = o + 4 + l;\n      iter->next_off = o + 4 + l + 12;\n   } break;\n   case BSON_TYPE_CODEWSCOPE: {\n      uint32_t l;\n      uint32_t doclen;\n\n      if ((len < 19) || (o >= (len - 14))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      iter->d2 = o + 4;\n      iter->d3 = o + 8;\n\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);\n\n      if ((l < 14) || (l >= (len - o))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      iter->next_off = o + l;\n\n      if (iter->next_off >= len) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      memcpy (&l, iter->raw + iter->d2, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);\n\n      if (l == 0 || l >= (len - o - 4 - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      if ((o + 4 + 4 + l + 4) >= iter->next_off) {\n         iter->err_off = o + 4;\n         goto mark_invalid;\n      }\n\n      iter->d4 = o + 4 + 4 + l;\n      memcpy (&doclen, iter->raw + iter->d4, sizeof (doclen));\n      doclen = BSON_UINT32_FROM_LE (doclen);\n\n      if ((o + 4 + 4 + l + doclen) != iter->next_off) {\n         iter->err_off = o + 4 + 4 + l;\n         goto mark_invalid;\n      }\n   } break;\n   case BSON_TYPE_INT32:\n      iter->next_off = o + 4;\n      break;\n   case BSON_TYPE_DECIMAL128:\n      iter->next_off = o + 16;\n      break;\n   case BSON_TYPE_MAXKEY:\n   case BSON_TYPE_MINKEY:\n   case BSON_TYPE_NULL:\n   case BSON_TYPE_UNDEFINED:\n      iter->next_off = o;\n      break;\n   default:\n      *unsupported = true;\n   /* FALL THROUGH */\n   case BSON_TYPE_EOD:\n      iter->err_off = o;\n      goto mark_invalid;\n   }\n\n   /*\n    * Check to see if any of the field locations would overflow the\n    * current BSON buffer. If so, set the error location to the offset\n    * of where the field starts.\n    */\n   if (iter->next_off >= len) {\n      iter->err_off = o;\n      goto mark_invalid;\n   }\n\n   iter->err_off = 0;\n\n   return true;\n\nmark_invalid:\n   iter->raw = NULL;\n   iter->len = 0;\n   iter->next_off = 0;\n\n   return false;\n}",
  "abstract_func": "static bool\n_bson_iter_next_internal (bson_iter_t *VAR_0,    /* COMMENT_0 */\n                          uint32_t VAR_1, /* COMMENT_1 */\n                          const char **VAR_2,     /* COMMENT_2 */\n                          uint32_t *VAR_3,  /* COMMENT_2 */\n                          bool *VAR_4)    /* COMMENT_2 */\n{\n   const uint8_t *VAR_5;\n   uint32_t VAR_6;\n   unsigned int VAR_7;\n\n   BSON_ASSERT (VAR_0);\n\n   *VAR_4 = false;\n\n   if (!VAR_0->raw) {\n      *VAR_2 = NULL;\n      *VAR_3 = VAR_8;\n      return false;\n   }\n\n   VAR_5 = VAR_0->raw;\n   VAR_7 = VAR_0->len;\n\n   VAR_0->off = VAR_0->next_off;\n   VAR_0->type = VAR_0->off;\n   VAR_0->key = VAR_0->off + 1;\n   VAR_0->d1 = 0;\n   VAR_0->d2 = 0;\n   VAR_0->d3 = 0;\n   VAR_0->d4 = 0;\n\n   if (VAR_1 == 0) {\n      /* COMMENT_3 */\n      for (VAR_6 = VAR_0->key; VAR_6 < VAR_7; VAR_6++) {\n         if (!VAR_5[VAR_6]) {\n            VAR_0->d1 = ++VAR_6;\n            goto fill_data_fields;\n         }\n      }\n   } else {\n      VAR_6 = VAR_0->key + VAR_1 + 1;\n      VAR_0->d1 = VAR_6;\n      goto fill_data_fields;\n   }\n\n   goto mark_invalid;\n\nfill_data_fields:\n\n   *VAR_2 = bson_iter_key_unsafe (VAR_0);\n   *VAR_3 = ITER_TYPE (VAR_0);\n\n   switch (*VAR_3) {\n   case VAR_9:\n   case VAR_10:\n   case VAR_11:\n   case VAR_12:\n      VAR_0->next_off = VAR_6 + 8;\n      break;\n   case VAR_13:\n   case VAR_14:\n   case VAR_15: {\n      uint32_t VAR_16;\n\n      if ((VAR_6 + 4) >= VAR_7) {\n         VAR_0->err_off = VAR_6;\n         goto mark_invalid;\n      }\n\n      VAR_0->d2 = VAR_6 + 4;\n      memcpy (&VAR_16, VAR_0->raw + VAR_0->d1, sizeof (VAR_16));\n      VAR_16 = BSON_UINT32_FROM_LE (VAR_16);\n\n      if (VAR_16 > (VAR_7 - (VAR_6 + 4))) {\n         VAR_0->err_off = VAR_6;\n         goto mark_invalid;\n      }\n\n      VAR_0->next_off = VAR_6 + 4 + VAR_16;\n\n      /* COMMENT_4 */\n                                                           \n         \n      if (BSON_UNLIKELY ((VAR_16 == 0) || (VAR_0->next_off >= VAR_7))) {\n         VAR_0->err_off = VAR_6;\n         goto mark_invalid;\n      }\n\n      /* COMMENT_7 */\n                                               \n         \n      if (BSON_UNLIKELY ((VAR_0->raw + VAR_0->d2)[VAR_16 - 1] != '\\0')) {\n         VAR_0->err_off = VAR_6 + 4 + VAR_16 - 1;\n         goto mark_invalid;\n      }\n   } break;\n   case VAR_17: {\n      bson_subtype_t VAR_18;\n      uint32_t VAR_16;\n\n      if (VAR_6 >= (VAR_7 - 4)) {\n         VAR_0->err_off = VAR_6;\n         goto mark_invalid;\n      }\n\n      VAR_0->d2 = VAR_6 + 4;\n      VAR_0->d3 = VAR_6 + 5;\n\n      memcpy (&VAR_16, VAR_0->raw + VAR_0->d1, sizeof (VAR_16));\n      VAR_16 = BSON_UINT32_FROM_LE (VAR_16);\n\n      if (VAR_16 >= (VAR_7 - VAR_6 - 4)) {\n         VAR_0->err_off = VAR_6;\n         goto mark_invalid;\n      }\n\n      VAR_18 = *(VAR_0->raw + VAR_0->d2);\n\n      if (VAR_18 == VAR_19) {\n         int32_t VAR_20;\n\n         if (VAR_16 < 4) {\n            VAR_0->err_off = VAR_6;\n            goto mark_invalid;\n         }\n\n         /* COMMENT_10 */\n         memcpy (&VAR_20, (VAR_0->raw + VAR_0->d3), sizeof (VAR_20));\n         VAR_20 = BSON_UINT32_FROM_LE (VAR_20);\n         if (VAR_20 + 4 != VAR_16) {\n            VAR_0->err_off = VAR_0->d3;\n            goto mark_invalid;\n         }\n      }\n\n      VAR_0->next_off = VAR_6 + 5 + VAR_16;\n   } break;\n   case VAR_21:\n   case VAR_22: {\n      uint32_t VAR_16;\n\n      if (VAR_6 >= (VAR_7 - 4)) {\n         VAR_0->err_off = VAR_6;\n         goto mark_invalid;\n      }\n\n      memcpy (&VAR_16, VAR_0->raw + VAR_0->d1, sizeof (VAR_16));\n      VAR_16 = BSON_UINT32_FROM_LE (VAR_16);\n\n      if ((VAR_16 > VAR_7) || (VAR_16 > (VAR_7 - VAR_6))) {\n         VAR_0->err_off = VAR_6;\n         goto mark_invalid;\n      }\n\n      VAR_0->next_off = VAR_6 + VAR_16;\n   } break;\n   case VAR_23:\n      VAR_0->next_off = VAR_6 + 12;\n      break;\n   case VAR_24: {\n      char VAR_25;\n\n      if (VAR_0->d1 >= VAR_7) {\n         VAR_0->err_off = VAR_6;\n         goto mark_invalid;\n      }\n\n      memcpy (&VAR_25, VAR_0->raw + VAR_0->d1, 1);\n      if (VAR_25 != 0x00 && VAR_25 != 0x01) {\n         VAR_0->err_off = VAR_6;\n         goto mark_invalid;\n      }\n\n      VAR_0->next_off = VAR_6 + 1;\n   } break;\n   case VAR_26: {\n      bool VAR_27 = false;\n      bool VAR_28 = false;\n\n      for (; VAR_6 < VAR_7; VAR_6++) {\n         if (!VAR_5[VAR_6]) {\n            VAR_0->d2 = ++VAR_6;\n            VAR_27 = true;\n            break;\n         }\n      }\n\n      if (!VAR_27) {\n         VAR_0->err_off = VAR_0->next_off;\n         goto mark_invalid;\n      }\n\n      for (; VAR_6 < VAR_7; VAR_6++) {\n         if (!VAR_5[VAR_6]) {\n            VAR_28 = true;\n            break;\n         }\n      }\n\n      if (!VAR_28) {\n         VAR_0->err_off = VAR_0->next_off;\n         goto mark_invalid;\n      }\n\n      VAR_0->next_off = VAR_6 + 1;\n   } break;\n   case VAR_29: {\n      uint32_t VAR_16;\n\n      if (VAR_6 >= (VAR_7 - 4)) {\n         VAR_0->err_off = VAR_6;\n         goto mark_invalid;\n      }\n\n      VAR_0->d2 = VAR_6 + 4;\n      memcpy (&VAR_16, VAR_0->raw + VAR_0->d1, sizeof (VAR_16));\n      VAR_16 = BSON_UINT32_FROM_LE (VAR_16);\n\n      /* COMMENT_11 */\n      if (VAR_16 == 0 || VAR_16 > (VAR_7 - VAR_6 - 4)) {\n         VAR_0->err_off = VAR_6;\n         goto mark_invalid;\n      }\n\n      if (*(VAR_0->raw + VAR_6 + VAR_16 + 3)) {\n         /* COMMENT_12 */\n         VAR_0->err_off = VAR_6 + VAR_16 + 3;\n         goto mark_invalid;\n      }\n\n      VAR_0->d3 = VAR_6 + 4 + VAR_16;\n      VAR_0->next_off = VAR_6 + 4 + VAR_16 + 12;\n   } break;\n   case VAR_30: {\n      uint32_t VAR_16;\n      uint32_t VAR_31;\n\n      if ((VAR_7 < 19) || (VAR_6 >= (VAR_7 - 14))) {\n         VAR_0->err_off = VAR_6;\n         goto mark_invalid;\n      }\n\n      VAR_0->d2 = VAR_6 + 4;\n      VAR_0->d3 = VAR_6 + 8;\n\n      memcpy (&VAR_16, VAR_0->raw + VAR_0->d1, sizeof (VAR_16));\n      VAR_16 = BSON_UINT32_FROM_LE (VAR_16);\n\n      if ((VAR_16 < 14) || (VAR_16 >= (VAR_7 - VAR_6))) {\n         VAR_0->err_off = VAR_6;\n         goto mark_invalid;\n      }\n\n      VAR_0->next_off = VAR_6 + VAR_16;\n\n      if (VAR_0->next_off >= VAR_7) {\n         VAR_0->err_off = VAR_6;\n         goto mark_invalid;\n      }\n\n      memcpy (&VAR_16, VAR_0->raw + VAR_0->d2, sizeof (VAR_16));\n      VAR_16 = BSON_UINT32_FROM_LE (VAR_16);\n\n      if (VAR_16 == 0 || VAR_16 >= (VAR_7 - VAR_6 - 4 - 4)) {\n         VAR_0->err_off = VAR_6;\n         goto mark_invalid;\n      }\n\n      if ((VAR_6 + 4 + 4 + VAR_16 + 4) >= VAR_0->next_off) {\n         VAR_0->err_off = VAR_6 + 4;\n         goto mark_invalid;\n      }\n\n      VAR_0->d4 = VAR_6 + 4 + 4 + VAR_16;\n      memcpy (&VAR_31, VAR_0->raw + VAR_0->d4, sizeof (VAR_31));\n      VAR_31 = BSON_UINT32_FROM_LE (VAR_31);\n\n      if ((VAR_6 + 4 + 4 + VAR_16 + VAR_31) != VAR_0->next_off) {\n         VAR_0->err_off = VAR_6 + 4 + 4 + VAR_16;\n         goto mark_invalid;\n      }\n   } break;\n   case VAR_32:\n      VAR_0->next_off = VAR_6 + 4;\n      break;\n   case VAR_33:\n      VAR_0->next_off = VAR_6 + 16;\n      break;\n   case VAR_34:\n   case VAR_35:\n   case VAR_36:\n   case VAR_37:\n      VAR_0->next_off = VAR_6;\n      break;\n   default:\n      *VAR_4 = true;\n   /* COMMENT_13 */\n   case VAR_8:\n      VAR_0->err_off = VAR_6;\n      goto mark_invalid;\n   }\n\n   /* COMMENT_14 */\n                                                                   \n                                                                      \n                                \n      \n   if (VAR_0->next_off >= VAR_7) {\n      VAR_0->err_off = VAR_6;\n      goto mark_invalid;\n   }\n\n   VAR_0->err_off = 0;\n\n   return true;\n\nmark_invalid:\n   VAR_0->raw = NULL;\n   VAR_0->len = 0;\n   VAR_0->next_off = 0;\n\n   return false;\n}",
  "func_graph_path": "mongodb/mongo-c-driver/0d9a4d98bfdf4acd2c0138d4aaeb4e2e0934bd84/bson-iter.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -110,7 +110,7 @@\n       memcpy (&l, iter->raw + iter->d1, sizeof (l));\n       l = BSON_UINT32_FROM_LE (l);\n \n-      if (l >= (len - o)) {\n+      if (l >= (len - o - 4)) {\n          iter->err_off = o;\n          goto mark_invalid;\n       }",
  "diff_line_info": {
    "deleted_lines": [
      "      if (l >= (len - o)) {"
    ],
    "added_lines": [
      "      if (l >= (len - o - 4)) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/mongodb/mongo-c-driver/pull/537",
  "description": {
    "pr_info": {
      "title": "Fix for CVE-2018-16790 -- Verify bounds before binary length read.",
      "number": 537
    },
    "comment": [
      "As reported here: https://jira.mongodb.org/browse/CDRIVER-2819,\r\na heap overread occurs due a failure to correctly verify data\r\nbounds.\r\n\r\nIn the original check, len - o returns the data left including the\r\nsizeof(l) we just read. Instead, the comparison should check\r\nagainst the data left NOT including the binary int32, i.e. just\r\nsubtype (byte*) instead of int32 subtype (byte*).",
      "Terrific, thank you. Would you please add the corrupt BSON data as a file in src/libbson/tests/binary and add a test like this one?:\r\n\r\nhttps://github.com/mongodb/mongo-c-driver/blob/b3bdc57c2009eb918857bd9657bb8bf953a6840b/src/libbson/tests/test-bson.c#L1247",
      "Yep, I'll see if I can get that integrated next week.",
      "Added corrupt BSON example. Let me know if that wasn't what you were looking for.",
      "Thanks very much!"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "The patch clearly addresses a security issue by fixing a heap overread vulnerability through bounds checking.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}