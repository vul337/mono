{
  "cve_id": "CVE-2021-36369",
  "cwe_ids": [
    "CWE-287"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N",
  "cvss_is_v3": true,
  "repo_name": "mkj/dropbear",
  "commit_msg": "fixed trivial auth detection for pubkeys",
  "commit_hash": "318109125e747f0bc256a6d94d5756030ea2f5a0",
  "git_url": "https://github.com/mkj/dropbear/commit/318109125e747f0bc256a6d94d5756030ea2f5a0",
  "file_path": "cli-authpubkey.c",
  "func_name": "cli_auth_pubkey",
  "func_before": "int cli_auth_pubkey() {\n\tenum signature_type sigtype = DROPBEAR_SIGNATURE_NONE;\n\tTRACE((\"enter cli_auth_pubkey\"))\n\n#if DROPBEAR_CLI_AGENTFWD\n\tif (!cli_opts.agent_keys_loaded) {\n\t\t/* get the list of available keys from the agent */\n\t\tcli_load_agent_keys(cli_opts.privkeys);\n\t\tcli_opts.agent_keys_loaded = 1;\n\t\tTRACE((\"cli_auth_pubkey: agent keys loaded\"))\n\t}\n#endif\n\n\t/* iterate through privkeys to remove ones not allowed in server-sig-algs */\n \twhile (cli_opts.privkeys->first) {\n\t\tsign_key * key = (sign_key*)cli_opts.privkeys->first->item;\n\t\tif (cli_ses.server_sig_algs) {\n#if DROPBEAR_RSA\n\t\t\tif (key->type == DROPBEAR_SIGNKEY_RSA) {\n#if DROPBEAR_RSA_SHA256\n\t\t\t\tif (buf_has_algo(cli_ses.server_sig_algs, SSH_SIGNATURE_RSA_SHA256) \n\t\t\t\t\t\t== DROPBEAR_SUCCESS) {\n\t\t\t\t\tsigtype = DROPBEAR_SIGNATURE_RSA_SHA256;\n\t\t\t\t\tTRACE((\"server-sig-algs allows rsa sha256\"))\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#endif /* DROPBEAR_RSA_SHA256 */\n#if DROPBEAR_RSA_SHA1\n\t\t\t\tif (buf_has_algo(cli_ses.server_sig_algs, SSH_SIGNKEY_RSA)\n\t\t\t\t\t\t== DROPBEAR_SUCCESS) {\n\t\t\t\t\tsigtype = DROPBEAR_SIGNATURE_RSA_SHA1;\n\t\t\t\t\tTRACE((\"server-sig-algs allows rsa sha1\"))\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#endif /* DROPBEAR_RSA_SHA256 */\n\t\t\t} else\n#endif /* DROPBEAR_RSA */\n\t\t\t{\n\t\t\t\t/* Not RSA */\n\t\t\t\tconst char *name = NULL;\n\t\t\t\tsigtype = signature_type_from_signkey(key->type);\n\t\t\t\tname = signature_name_from_type(sigtype, NULL);\n\t\t\t\tif (buf_has_algo(cli_ses.server_sig_algs, name)\n\t\t\t\t\t\t== DROPBEAR_SUCCESS) {\n\t\t\t\t\tTRACE((\"server-sig-algs allows %s\", name))\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* No match, skip this key */\n\t\t\tTRACE((\"server-sig-algs no match keytype %d, skipping\", key->type))\n\t\t\tkey = list_remove(cli_opts.privkeys->first);\n\t\t\tsign_key_free(key); \n\t\t\tcontinue;\n\t\t} else {\n\t\t\t/* Server didn't provide a server-sig-algs list, we'll \n\t\t\t   assume all except rsa-sha256 are OK. */\n#if DROPBEAR_RSA\n\t\t\tif (key->type == DROPBEAR_SIGNKEY_RSA) {\n#if DROPBEAR_RSA_SHA1\n\t\t\t\tsigtype = DROPBEAR_SIGNATURE_RSA_SHA1;\n\t\t\t\tTRACE((\"no server-sig-algs, using rsa sha1\"))\n\t\t\t\tbreak;\n#else\n\t\t\t\t/* only support rsa-sha256, skip this key */\n\t\t\t\tTRACE((\"no server-sig-algs, skipping rsa sha256\"))\n\t\t\t\tkey = list_remove(cli_opts.privkeys->first);\n\t\t\t\tsign_key_free(key); \n\t\t\t\tcontinue;\n#endif\n\t\t\t} /* key->type == DROPBEAR_SIGNKEY_RSA */\n#endif /* DROPBEAR_RSA */\n\t\t\tsigtype = signature_type_from_signkey(key->type);\n\t\t\tTRACE((\"no server-sig-algs, using key\"))\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (cli_opts.privkeys->first) {\n\t\tsign_key * key = (sign_key*)cli_opts.privkeys->first->item;\n\t\t/* Send a trial request */\n\t\tsend_msg_userauth_pubkey(key, sigtype, 0);\n\t\tcli_ses.lastprivkey = key;\n\t\tcli_ses.is_trivial_auth = 0;\n\t\tTRACE((\"leave cli_auth_pubkey-success\"))\n\t\treturn 1;\n\t} else {\n\t\t/* no more keys left */\n\t\tTRACE((\"leave cli_auth_pubkey-failure\"))\n\t\treturn 0;\n\t}\n}",
  "abstract_func_before": "int cli_auth_pubkey() {\n\tenum signature_type VAR_0 = VAR_1;\n\tTRACE((\"enter cli_auth_pubkey\"))\n\n#if VAR_2\n\tif (!VAR_3.agent_keys_loaded) {\n\t\t/* COMMENT_0 */\n\t\tcli_load_agent_keys(VAR_3.privkeys);\n\t\tVAR_3.agent_keys_loaded = 1;\n\t\tTRACE((\"cli_auth_pubkey: agent keys loaded\"))\n\t}\n#endif\n\n\t/* COMMENT_1 */\n \twhile (VAR_3.privkeys->first) {\n\t\tsign_key * VAR_4 = (sign_key*)VAR_3.privkeys->first->item;\n\t\tif (VAR_5.server_sig_algs) {\n#if VAR_6\n\t\t\tif (VAR_4->type == VAR_7) {\n#if VAR_8\n\t\t\t\tif (buf_has_algo(VAR_5.server_sig_algs, VAR_9) \n\t\t\t\t\t\t== VAR_10) {\n\t\t\t\t\tVAR_0 = VAR_11;\n\t\t\t\t\tTRACE((\"server-sig-algs allows rsa sha256\"))\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#endif /* COMMENT_2 */\n#if VAR_12\n\t\t\t\tif (buf_has_algo(VAR_5.server_sig_algs, VAR_13)\n\t\t\t\t\t\t== VAR_10) {\n\t\t\t\t\tVAR_0 = VAR_14;\n\t\t\t\t\tTRACE((\"server-sig-algs allows rsa sha1\"))\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#endif /* COMMENT_2 */\n\t\t\t} else\n#endif /* COMMENT_3 */\n\t\t\t{\n\t\t\t\t/* COMMENT_4 */\n\t\t\t\tconst char *VAR_15 = NULL;\n\t\t\t\tVAR_0 = signature_type_from_signkey(VAR_4->type);\n\t\t\t\tVAR_15 = signature_name_from_type(VAR_0, NULL);\n\t\t\t\tif (buf_has_algo(VAR_5.server_sig_algs, VAR_15)\n\t\t\t\t\t\t== VAR_10) {\n\t\t\t\t\tTRACE((\"server-sig-algs allows %s\", VAR_15))\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* COMMENT_5 */\n\t\t\tTRACE((\"server-sig-algs no match keytype %d, skipping\", VAR_4->type))\n\t\t\tVAR_4 = list_remove(VAR_3.privkeys->first);\n\t\t\tsign_key_free(VAR_4); \n\t\t\tcontinue;\n\t\t} else {\n\t\t\t/* COMMENT_6 */\n                                             \n#if VAR_6\n\t\t\tif (VAR_4->type == VAR_7) {\n#if VAR_12\n\t\t\t\tVAR_0 = VAR_14;\n\t\t\t\tTRACE((\"no server-sig-algs, using rsa sha1\"))\n\t\t\t\tbreak;\n#else\n\t\t\t\t/* COMMENT_8 */\n\t\t\t\tTRACE((\"no server-sig-algs, skipping rsa sha256\"))\n\t\t\t\tVAR_4 = list_remove(VAR_3.privkeys->first);\n\t\t\t\tsign_key_free(VAR_4); \n\t\t\t\tcontinue;\n#endif\n\t\t\t} /* COMMENT_9 */\n#endif /* COMMENT_3 */\n\t\t\tVAR_0 = signature_type_from_signkey(VAR_4->type);\n\t\t\tTRACE((\"no server-sig-algs, using key\"))\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (VAR_3.privkeys->first) {\n\t\tsign_key * VAR_4 = (sign_key*)VAR_3.privkeys->first->item;\n\t\t/* COMMENT_10 */\n\t\tsend_msg_userauth_pubkey(VAR_4, VAR_0, 0);\n\t\tVAR_5.lastprivkey = VAR_4;\n\t\tVAR_5.is_trivial_auth = 0;\n\t\tTRACE((\"leave cli_auth_pubkey-success\"))\n\t\treturn 1;\n\t} else {\n\t\t/* COMMENT_11 */\n\t\tTRACE((\"leave cli_auth_pubkey-failure\"))\n\t\treturn 0;\n\t}\n}",
  "func_graph_path_before": "mkj/dropbear/318109125e747f0bc256a6d94d5756030ea2f5a0/cli-authpubkey.c/vul/before/1.json",
  "func": "int cli_auth_pubkey() {\n\tenum signature_type sigtype = DROPBEAR_SIGNATURE_NONE;\n\tTRACE((\"enter cli_auth_pubkey\"))\n\n#if DROPBEAR_CLI_AGENTFWD\n\tif (!cli_opts.agent_keys_loaded) {\n\t\t/* get the list of available keys from the agent */\n\t\tcli_load_agent_keys(cli_opts.privkeys);\n\t\tcli_opts.agent_keys_loaded = 1;\n\t\tTRACE((\"cli_auth_pubkey: agent keys loaded\"))\n\t}\n#endif\n\n\t/* iterate through privkeys to remove ones not allowed in server-sig-algs */\n \twhile (cli_opts.privkeys->first) {\n\t\tsign_key * key = (sign_key*)cli_opts.privkeys->first->item;\n\t\tif (cli_ses.server_sig_algs) {\n#if DROPBEAR_RSA\n\t\t\tif (key->type == DROPBEAR_SIGNKEY_RSA) {\n#if DROPBEAR_RSA_SHA256\n\t\t\t\tif (buf_has_algo(cli_ses.server_sig_algs, SSH_SIGNATURE_RSA_SHA256) \n\t\t\t\t\t\t== DROPBEAR_SUCCESS) {\n\t\t\t\t\tsigtype = DROPBEAR_SIGNATURE_RSA_SHA256;\n\t\t\t\t\tTRACE((\"server-sig-algs allows rsa sha256\"))\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#endif /* DROPBEAR_RSA_SHA256 */\n#if DROPBEAR_RSA_SHA1\n\t\t\t\tif (buf_has_algo(cli_ses.server_sig_algs, SSH_SIGNKEY_RSA)\n\t\t\t\t\t\t== DROPBEAR_SUCCESS) {\n\t\t\t\t\tsigtype = DROPBEAR_SIGNATURE_RSA_SHA1;\n\t\t\t\t\tTRACE((\"server-sig-algs allows rsa sha1\"))\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#endif /* DROPBEAR_RSA_SHA256 */\n\t\t\t} else\n#endif /* DROPBEAR_RSA */\n\t\t\t{\n\t\t\t\t/* Not RSA */\n\t\t\t\tconst char *name = NULL;\n\t\t\t\tsigtype = signature_type_from_signkey(key->type);\n\t\t\t\tname = signature_name_from_type(sigtype, NULL);\n\t\t\t\tif (buf_has_algo(cli_ses.server_sig_algs, name)\n\t\t\t\t\t\t== DROPBEAR_SUCCESS) {\n\t\t\t\t\tTRACE((\"server-sig-algs allows %s\", name))\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* No match, skip this key */\n\t\t\tTRACE((\"server-sig-algs no match keytype %d, skipping\", key->type))\n\t\t\tkey = list_remove(cli_opts.privkeys->first);\n\t\t\tsign_key_free(key); \n\t\t\tcontinue;\n\t\t} else {\n\t\t\t/* Server didn't provide a server-sig-algs list, we'll \n\t\t\t   assume all except rsa-sha256 are OK. */\n#if DROPBEAR_RSA\n\t\t\tif (key->type == DROPBEAR_SIGNKEY_RSA) {\n#if DROPBEAR_RSA_SHA1\n\t\t\t\tsigtype = DROPBEAR_SIGNATURE_RSA_SHA1;\n\t\t\t\tTRACE((\"no server-sig-algs, using rsa sha1\"))\n\t\t\t\tbreak;\n#else\n\t\t\t\t/* only support rsa-sha256, skip this key */\n\t\t\t\tTRACE((\"no server-sig-algs, skipping rsa sha256\"))\n\t\t\t\tkey = list_remove(cli_opts.privkeys->first);\n\t\t\t\tsign_key_free(key); \n\t\t\t\tcontinue;\n#endif\n\t\t\t} /* key->type == DROPBEAR_SIGNKEY_RSA */\n#endif /* DROPBEAR_RSA */\n\t\t\tsigtype = signature_type_from_signkey(key->type);\n\t\t\tTRACE((\"no server-sig-algs, using key\"))\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (cli_opts.privkeys->first) {\n\t\tsign_key * key = (sign_key*)cli_opts.privkeys->first->item;\n\t\t/* Send a trial request */\n\t\tsend_msg_userauth_pubkey(key, sigtype, 0);\n\t\tcli_ses.lastprivkey = key;\n\t\tTRACE((\"leave cli_auth_pubkey-success\"))\n\t\treturn 1;\n\t} else {\n\t\t/* no more keys left */\n\t\tTRACE((\"leave cli_auth_pubkey-failure\"))\n\t\treturn 0;\n\t}\n}",
  "abstract_func": "int cli_auth_pubkey() {\n\tenum signature_type VAR_0 = VAR_1;\n\tTRACE((\"enter cli_auth_pubkey\"))\n\n#if VAR_2\n\tif (!VAR_3.agent_keys_loaded) {\n\t\t/* COMMENT_0 */\n\t\tcli_load_agent_keys(VAR_3.privkeys);\n\t\tVAR_3.agent_keys_loaded = 1;\n\t\tTRACE((\"cli_auth_pubkey: agent keys loaded\"))\n\t}\n#endif\n\n\t/* COMMENT_1 */\n \twhile (VAR_3.privkeys->first) {\n\t\tsign_key * VAR_4 = (sign_key*)VAR_3.privkeys->first->item;\n\t\tif (VAR_5.server_sig_algs) {\n#if VAR_6\n\t\t\tif (VAR_4->type == VAR_7) {\n#if VAR_8\n\t\t\t\tif (buf_has_algo(VAR_5.server_sig_algs, VAR_9) \n\t\t\t\t\t\t== VAR_10) {\n\t\t\t\t\tVAR_0 = VAR_11;\n\t\t\t\t\tTRACE((\"server-sig-algs allows rsa sha256\"))\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#endif /* COMMENT_2 */\n#if VAR_12\n\t\t\t\tif (buf_has_algo(VAR_5.server_sig_algs, VAR_13)\n\t\t\t\t\t\t== VAR_10) {\n\t\t\t\t\tVAR_0 = VAR_14;\n\t\t\t\t\tTRACE((\"server-sig-algs allows rsa sha1\"))\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#endif /* COMMENT_2 */\n\t\t\t} else\n#endif /* COMMENT_3 */\n\t\t\t{\n\t\t\t\t/* COMMENT_4 */\n\t\t\t\tconst char *VAR_15 = NULL;\n\t\t\t\tVAR_0 = signature_type_from_signkey(VAR_4->type);\n\t\t\t\tVAR_15 = signature_name_from_type(VAR_0, NULL);\n\t\t\t\tif (buf_has_algo(VAR_5.server_sig_algs, VAR_15)\n\t\t\t\t\t\t== VAR_10) {\n\t\t\t\t\tTRACE((\"server-sig-algs allows %s\", VAR_15))\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* COMMENT_5 */\n\t\t\tTRACE((\"server-sig-algs no match keytype %d, skipping\", VAR_4->type))\n\t\t\tVAR_4 = list_remove(VAR_3.privkeys->first);\n\t\t\tsign_key_free(VAR_4); \n\t\t\tcontinue;\n\t\t} else {\n\t\t\t/* COMMENT_6 */\n                                             \n#if VAR_6\n\t\t\tif (VAR_4->type == VAR_7) {\n#if VAR_12\n\t\t\t\tVAR_0 = VAR_14;\n\t\t\t\tTRACE((\"no server-sig-algs, using rsa sha1\"))\n\t\t\t\tbreak;\n#else\n\t\t\t\t/* COMMENT_8 */\n\t\t\t\tTRACE((\"no server-sig-algs, skipping rsa sha256\"))\n\t\t\t\tVAR_4 = list_remove(VAR_3.privkeys->first);\n\t\t\t\tsign_key_free(VAR_4); \n\t\t\t\tcontinue;\n#endif\n\t\t\t} /* COMMENT_9 */\n#endif /* COMMENT_3 */\n\t\t\tVAR_0 = signature_type_from_signkey(VAR_4->type);\n\t\t\tTRACE((\"no server-sig-algs, using key\"))\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (VAR_3.privkeys->first) {\n\t\tsign_key * VAR_4 = (sign_key*)VAR_3.privkeys->first->item;\n\t\t/* COMMENT_10 */\n\t\tsend_msg_userauth_pubkey(VAR_4, VAR_0, 0);\n\t\tVAR_5.lastprivkey = VAR_4;\n\t\tTRACE((\"leave cli_auth_pubkey-success\"))\n\t\treturn 1;\n\t} else {\n\t\t/* COMMENT_11 */\n\t\tTRACE((\"leave cli_auth_pubkey-failure\"))\n\t\treturn 0;\n\t}\n}",
  "func_graph_path": "mkj/dropbear/318109125e747f0bc256a6d94d5756030ea2f5a0/cli-authpubkey.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -81,7 +81,6 @@\n \t\t/* Send a trial request */\n \t\tsend_msg_userauth_pubkey(key, sigtype, 0);\n \t\tcli_ses.lastprivkey = key;\n-\t\tcli_ses.is_trivial_auth = 0;\n \t\tTRACE((\"leave cli_auth_pubkey-success\"))\n \t\treturn 1;\n \t} else {",
  "diff_line_info": {
    "deleted_lines": [
      "\t\tcli_ses.is_trivial_auth = 0;"
    ],
    "added_lines": []
  },
  "is_vul": true,
  "pr_url": "https://github.com/mkj/dropbear/pull/128",
  "description": {
    "pr_info": {
      "title": "added option to disable trivial auth methods",
      "number": 128
    },
    "comment": [
      "I have added an option ``-o ExitOnTrivialAuth=yes`` to disable trivial authentications as discussed in our mails",
      "I have renamed to argument to ``-o DisableTrivialAuth=yes`` to match OpenSSH's parameter",
      "Would you merge this pull request, because we are planning to create a CVE and I think this should be mitigated before we publish a full disclosure. ",
      "Hello, we are planning to release information about trivial succes authentication. Do you need help with merging the pull requests and creating the new release?"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95  \nThe patch addresses an authentication-related issue by modifying how trivial authentications are handled, which suggests it is a security fix."
}