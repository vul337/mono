{
  "cve_id": "CVE-2023-1672",
  "cwe_ids": [
    "CWE-362"
  ],
  "cvss_vector": "CVSS:3.1/AV:A/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:N",
  "cvss_is_v3": true,
  "repo_name": "latchset/tang",
  "commit_msg": "Fix race condition when creating/rotating keys (#123)\n\nWhen we create/rotate keys using either the tangd-keygen and\r\ntangd-rotate-keys helpers, there is a small window between the\r\nkeys being created and then the proper ownership permissions being\r\nset. This also happens when there are no keys and tang creates a\r\npair of keys itself.\r\n\r\nIn certain situations, such as the keys directory having wide open\r\npermissions, a user with local access could exploit this race\r\ncondition and read the keys before they are set to more restrictive\r\npermissions.\r\n\r\nTo prevent this issue, we now set the default umask to 0337 before\r\ncreating the files, so that they are already created with restrictive\r\npermissions; afterwards, we set the proper ownership as usual.\r\n\r\nIssue reported by Brian McDermott of CENSUS labs.\r\n\r\nFixes CVE-2023-1672\r\n\r\n\r\nReviewed-by: Sergio Arroutbi <sarroutb@redhat.com>\r\nSigned-off-by: Sergio Correia <scorreia@redhat.com>",
  "commit_hash": "8dbbed10870378f1b2c3cf3df2ea7edca7617096",
  "git_url": "https://github.com/latchset/tang/commit/8dbbed10870378f1b2c3cf3df2ea7edca7617096",
  "file_path": "src/keys.c",
  "func_name": "create_new_keys",
  "func_before": "static int\ncreate_new_keys(const char* jwkdir)\n{\n    const char* alg[] = {\"ES512\", \"ECMR\", NULL};\n    char path[PATH_MAX];\n    for (int i = 0; alg[i] != NULL; i++) {\n        json_auto_t* jwk = jwk_generate(alg[i]);\n        if (!jwk) {\n            return 0;\n        }\n        __attribute__ ((__cleanup__(cleanup_str))) char* thp = jwk_thumbprint(jwk, DEFAULT_THP_HASH);\n        if (!thp) {\n            return 0;\n        }\n        if (snprintf(path, PATH_MAX, \"%s/%s.jwk\", jwkdir, thp) < 0) {\n            fprintf(stderr, \"Unable to prepare variable with file full path (%s)\\n\", thp);\n            return 0;\n        }\n        path[sizeof(path) - 1] = '\\0';\n        if (json_dump_file(jwk, path, 0) == -1) {\n            fprintf(stderr, \"Error saving JWK to file (%s)\\n\", path);\n            return 0;\n        }\n\n        /* Set 0440 permission for the new key. */\n        if (chmod(path, S_IRUSR | S_IRGRP) == -1) {\n            fprintf(stderr, \"Unable to set permissions for JWK file (%s)\\n\", path);\n            return 0;\n        }\n    }\n    return 1;\n}",
  "abstract_func_before": "static int\ncreate_new_keys(const char* VAR_0)\n{\n    const char* VAR_1[] = {\"ES512\", \"ECMR\", NULL};\n    char VAR_2[VAR_3];\n    for (int VAR_4 = 0; VAR_1[VAR_4] != NULL; VAR_4++) {\n        json_auto_t* VAR_5 = jwk_generate(VAR_1[VAR_4]);\n        if (!VAR_5) {\n            return 0;\n        }\n        __attribute__ ((__cleanup__(VAR_6))) char* VAR_7 = jwk_thumbprint(VAR_5, VAR_8);\n        if (!VAR_7) {\n            return 0;\n        }\n        if (snprintf(VAR_2, VAR_3, \"%s/%s.jwk\", VAR_0, VAR_7) < 0) {\n            fprintf(VAR_9, \"Unable to prepare variable with file full path (%s)\\n\", VAR_7);\n            return 0;\n        }\n        VAR_2[sizeof(VAR_2) - 1] = '\\0';\n        if (json_dump_file(VAR_5, VAR_2, 0) == -1) {\n            fprintf(VAR_9, \"Error saving JWK to file (%s)\\n\", VAR_2);\n            return 0;\n        }\n\n        /* COMMENT_0 */\n        if (chmod(VAR_2, VAR_10 | VAR_11) == -1) {\n            fprintf(VAR_9, \"Unable to set permissions for JWK file (%s)\\n\", VAR_2);\n            return 0;\n        }\n    }\n    return 1;\n}",
  "func_graph_path_before": "latchset/tang/8dbbed10870378f1b2c3cf3df2ea7edca7617096/keys.c/vul/before/0.json",
  "func": "static int\ncreate_new_keys(const char* jwkdir)\n{\n    const char* alg[] = {\"ES512\", \"ECMR\", NULL};\n    char path[PATH_MAX];\n\n    /* Set default umask for file creation. */\n    umask(0337);\n    for (int i = 0; alg[i] != NULL; i++) {\n        json_auto_t* jwk = jwk_generate(alg[i]);\n        if (!jwk) {\n            return 0;\n        }\n        __attribute__ ((__cleanup__(cleanup_str))) char* thp = jwk_thumbprint(jwk, DEFAULT_THP_HASH);\n        if (!thp) {\n            return 0;\n        }\n        if (snprintf(path, PATH_MAX, \"%s/%s.jwk\", jwkdir, thp) < 0) {\n            fprintf(stderr, \"Unable to prepare variable with file full path (%s)\\n\", thp);\n            return 0;\n        }\n        path[sizeof(path) - 1] = '\\0';\n        if (json_dump_file(jwk, path, 0) == -1) {\n            fprintf(stderr, \"Error saving JWK to file (%s)\\n\", path);\n            return 0;\n        }\n\n        /* Set 0440 permission for the new key. */\n        if (chmod(path, S_IRUSR | S_IRGRP) == -1) {\n            fprintf(stderr, \"Unable to set permissions for JWK file (%s)\\n\", path);\n            return 0;\n        }\n    }\n    return 1;\n}",
  "abstract_func": "static int\ncreate_new_keys(const char* VAR_0)\n{\n    const char* VAR_1[] = {\"ES512\", \"ECMR\", NULL};\n    char VAR_2[VAR_3];\n\n    /* COMMENT_0 */\n    umask(0337);\n    for (int VAR_4 = 0; VAR_1[VAR_4] != NULL; VAR_4++) {\n        json_auto_t* VAR_5 = jwk_generate(VAR_1[VAR_4]);\n        if (!VAR_5) {\n            return 0;\n        }\n        __attribute__ ((__cleanup__(VAR_6))) char* VAR_7 = jwk_thumbprint(VAR_5, VAR_8);\n        if (!VAR_7) {\n            return 0;\n        }\n        if (snprintf(VAR_2, VAR_3, \"%s/%s.jwk\", VAR_0, VAR_7) < 0) {\n            fprintf(VAR_9, \"Unable to prepare variable with file full path (%s)\\n\", VAR_7);\n            return 0;\n        }\n        VAR_2[sizeof(VAR_2) - 1] = '\\0';\n        if (json_dump_file(VAR_5, VAR_2, 0) == -1) {\n            fprintf(VAR_9, \"Error saving JWK to file (%s)\\n\", VAR_2);\n            return 0;\n        }\n\n        /* COMMENT_1 */\n        if (chmod(VAR_2, VAR_10 | VAR_11) == -1) {\n            fprintf(VAR_9, \"Unable to set permissions for JWK file (%s)\\n\", VAR_2);\n            return 0;\n        }\n    }\n    return 1;\n}",
  "func_graph_path": "latchset/tang/8dbbed10870378f1b2c3cf3df2ea7edca7617096/keys.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -3,6 +3,9 @@\n {\n     const char* alg[] = {\"ES512\", \"ECMR\", NULL};\n     char path[PATH_MAX];\n+\n+    /* Set default umask for file creation. */\n+    umask(0337);\n     for (int i = 0; alg[i] != NULL; i++) {\n         json_auto_t* jwk = jwk_generate(alg[i]);\n         if (!jwk) {",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "",
      "    /* Set default umask for file creation. */",
      "    umask(0337);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/latchset/tang/pull/123",
  "description": {
    "pr_info": {
      "title": "Fix race condition when creating/rotating keys",
      "number": 123
    },
    "comment": [
      "When we create/rotate keys using either the tangd-keygen and tangd-rotate-keys helpers, there is a small window between the keys being created and then the proper ownership permissions being set. This also happens when there are no keys and tang creates a pair of keys itself.\r\n\r\nIn certain situations, such as the keys directory having wide open permissions, a user with local access could exploit this race condition and read the keys before they are set to more restrictive permissions.\r\n\r\nTo prevent this issue, we now set the default umask to 0337 before creating the files, so that they are already created with restrictive permissions; afterwards, we set the proper ownership as usual.\r\n\r\nIssue reported by Brian McDermott of CENSUS labs.\r\n\r\nFixes CVE-2023-1672\r\n\r\n\r\nReviewed-by: Sergio Arroutbi <sarroutb@redhat.com>",
      "Thanks Sergio, having tested this patch, I can confirm it fixed the issue"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95  \n\nThe patch clearly addresses a security issue by fixing a race condition, which is confirmed by the CVE reference and the code modification that sets restrictive permissions."
}