{
  "cve_id": "CVE-2021-35939",
  "cwe_ids": [
    "CWE-59"
  ],
  "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "rpm-software-management/rpm",
  "commit_msg": "Validate intermediate symlinks during installation, CVE-2021-35939\n\nWhenever directory changes during unpacking, walk the entire tree from\nstarting from / and validate any symlinks crossed, fail the install\non invalid links.\n\nThis is the first of step of many towards securing our file operations\nagainst local tamperers and besides plugging that one CVE, paves the way\nfor the next step by adding the necessary directory fd tracking.\nThis also bumps the rpm OS requirements to a whole new level by requiring\nthe *at() family of calls from POSIX-1.2008.\n\nThis necessarily does a whole lot of huffing and puffing we previously\ndid not do. It should be possible to cache secure (ie root-owned)\ndirectory structures to avoid validating everything a million times\nbut for now, just keeping things simple.",
  "commit_hash": "96ec957e281220f8e137a2d5eb23b83a6377d556",
  "git_url": "https://github.com/rpm-software-management/rpm/commit/96ec957e281220f8e137a2d5eb23b83a6377d556",
  "file_path": "lib/fsm.c",
  "func_name": "fsmMkdirs",
  "func_before": "static int fsmMkdirs(rpmfiles files, rpmfs fs, rpmPlugins plugins)\n{\n    DNLI_t dnli = dnlInitIterator(files, fs, 0);\n    struct stat sb;\n    const char *dpath;\n    int rc = 0;\n    int i;\n    size_t ldnlen = 0;\n    const char * ldn = NULL;\n\n    while ((dpath = dnlNextIterator(dnli)) != NULL) {\n\tsize_t dnlen = strlen(dpath);\n\tchar * te, dn[dnlen+1];\n\n\tif (dnlen <= 1)\n\t    continue;\n\n\tif (dnlen == ldnlen && rstreq(dpath, ldn))\n\t    continue;\n\n\t/* Copy as we need to modify the string */\n\t(void) stpcpy(dn, dpath);\n\n\t/* Assume '/' directory exists, \"mkdir -p\" for others if non-existent */\n\tfor (i = 1, te = dn + 1; *te != '\\0'; te++, i++) {\n\t    if (*te != '/')\n\t\tcontinue;\n\n\t    /* Already validated? */\n\t    if (i < ldnlen &&\n\t\t(ldn[i] == '/' || ldn[i] == '\\0') && rstreqn(dn, ldn, i))\n\t\tcontinue;\n\n\t    /* Validate next component of path. */\n\t    *te = '\\0';\n\t    rc = fsmStat(dn, 1, &sb); /* lstat */\n\t    *te = '/';\n\n\t    /* Directory already exists? */\n\t    if (rc == 0 && S_ISDIR(sb.st_mode)) {\n\t\tcontinue;\n\t    } else if (rc == RPMERR_ENOENT) {\n\t\t*te = '\\0';\n\t\tmode_t mode = S_IFDIR | (_dirPerms & 07777);\n\t\trpmFsmOp op = (FA_CREATE|FAF_UNOWNED);\n\n\t\t/* Run fsm file pre hook for all plugins */\n\t\trc = rpmpluginsCallFsmFilePre(plugins, NULL, dn, mode, op);\n\n\t\tif (!rc)\n\t\t    rc = fsmMkdir(dn, mode);\n\n\t\tif (!rc) {\n\t\t    rc = rpmpluginsCallFsmFilePrepare(plugins, NULL, dn, dn,\n\t\t\t\t\t\t      mode, op);\n\t\t}\n\n\t\t/* Run fsm file post hook for all plugins */\n\t\trpmpluginsCallFsmFilePost(plugins, NULL, dn, mode, op, rc);\n\n\t\tif (!rc) {\n\t\t    rpmlog(RPMLOG_DEBUG,\n\t\t\t    \"%s directory created with perms %04o\\n\",\n\t\t\t    dn, (unsigned)(mode & 07777));\n\t\t}\n\t\t*te = '/';\n\t    }\n\t    if (rc)\n\t\tbreak;\n\t}\n\tif (rc) break;\n\n\t/* Save last validated path. */\n\tldn = dpath;\n\tldnlen = dnlen;\n    }\n    dnlFreeIterator(dnli);\n\n    return rc;\n}",
  "abstract_func_before": "static int fsmMkdirs(rpmfiles VAR_0, rpmfs VAR_1, rpmPlugins VAR_2)\n{\n    DNLI_t VAR_3 = dnlInitIterator(VAR_0, VAR_1, 0);\n    struct stat VAR_4;\n    const char *VAR_5;\n    int VAR_6 = 0;\n    int VAR_7;\n    size_t VAR_8 = 0;\n    const char * VAR_9 = NULL;\n\n    while ((VAR_5 = dnlNextIterator(VAR_3)) != NULL) {\n\tsize_t VAR_10 = strlen(VAR_5);\n\tchar * VAR_11, VAR_12[VAR_10+1];\n\n\tif (VAR_10 <= 1)\n\t    continue;\n\n\tif (VAR_10 == VAR_8 && rstreq(VAR_5, VAR_9))\n\t    continue;\n\n\t/* COMMENT_0 */\n\t(void) stpcpy(VAR_12, VAR_5);\n\n\t/* COMMENT_1 */\n\tfor (VAR_7 = 1, VAR_11 = VAR_12 + 1; *VAR_11 != '\\0'; VAR_11++, VAR_7++) {\n\t    if (*VAR_11 != '/')\n\t\tcontinue;\n\n\t    /* COMMENT_2 */\n\t    if (VAR_7 < VAR_8 &&\n\t\t(VAR_9[VAR_7] == '/' || VAR_9[VAR_7] == '\\0') && rstreqn(VAR_12, VAR_9, VAR_7))\n\t\tcontinue;\n\n\t    /* COMMENT_3 */\n\t    *VAR_11 = '\\0';\n\t    VAR_6 = fsmStat(VAR_12, 1, &VAR_4); /* COMMENT_4 */\n\t    *VAR_11 = '/';\n\n\t    /* COMMENT_5 */\n\t    if (VAR_6 == 0 && S_ISDIR(VAR_4.st_mode)) {\n\t\tcontinue;\n\t    } else if (VAR_6 == VAR_13) {\n\t\t*VAR_11 = '\\0';\n\t\tmode_t VAR_14 = VAR_15 | (VAR_16 & 07777);\n\t\trpmFsmOp VAR_17 = (VAR_18|VAR_19);\n\n\t\t/* COMMENT_6 */\n\t\tVAR_6 = rpmpluginsCallFsmFilePre(VAR_2, NULL, VAR_12, VAR_14, VAR_17);\n\n\t\tif (!VAR_6)\n\t\t    VAR_6 = fsmMkdir(VAR_12, VAR_14);\n\n\t\tif (!VAR_6) {\n\t\t    VAR_6 = rpmpluginsCallFsmFilePrepare(VAR_2, NULL, VAR_12, VAR_12,\n\t\t\t\t\t\t      VAR_14, VAR_17);\n\t\t}\n\n\t\t/* COMMENT_7 */\n\t\trpmpluginsCallFsmFilePost(VAR_2, NULL, VAR_12, VAR_14, VAR_17, VAR_6);\n\n\t\tif (!VAR_6) {\n\t\t    rpmlog(VAR_20,\n\t\t\t    \"%s directory created with perms %04o\\n\",\n\t\t\t    VAR_12, (unsigned)(VAR_14 & 07777));\n\t\t}\n\t\t*VAR_11 = '/';\n\t    }\n\t    if (VAR_6)\n\t\tbreak;\n\t}\n\tif (VAR_6) break;\n\n\t/* COMMENT_8 */\n\tVAR_9 = VAR_5;\n\tVAR_8 = VAR_10;\n    }\n    dnlFreeIterator(VAR_3);\n\n    return VAR_6;\n}",
  "func_graph_path_before": "rpm-software-management/rpm/96ec957e281220f8e137a2d5eb23b83a6377d556/fsm.c/vul/before/1.json",
  "func": "static int fsmMkdirs(rpmfiles files, rpmfs fs, rpmPlugins plugins)\n{\n    DNLI_t dnli = dnlInitIterator(files, fs, 0);\n    struct stat sb;\n    const char *dpath;\n    int rc = 0;\n    int i;\n    size_t ldnlen = 0;\n    const char * ldn = NULL;\n\n    while ((dpath = dnlNextIterator(dnli)) != NULL) {\n\tsize_t dnlen = strlen(dpath);\n\tchar * te, dn[dnlen+1];\n\n\tif (dnlen <= 1)\n\t    continue;\n\n\tif (dnlen == ldnlen && rstreq(dpath, ldn))\n\t    continue;\n\n\t/* Copy as we need to modify the string */\n\t(void) stpcpy(dn, dpath);\n\n\t/* Assume '/' directory exists, \"mkdir -p\" for others if non-existent */\n\tfor (i = 1, te = dn + 1; *te != '\\0'; te++, i++) {\n\t    if (*te != '/')\n\t\tcontinue;\n\n\t    /* Already validated? */\n\t    if (i < ldnlen &&\n\t\t(ldn[i] == '/' || ldn[i] == '\\0') && rstreqn(dn, ldn, i))\n\t\tcontinue;\n\n\t    /* Validate next component of path. */\n\t    *te = '\\0';\n\t    rc = fsmStat(dn, 1, &sb); /* lstat */\n\t    *te = '/';\n\n\t    /* Directory already exists? */\n\t    if (rc == 0 && S_ISDIR(sb.st_mode)) {\n\t\tcontinue;\n\t    } else if (rc == RPMERR_ENOENT) {\n\t\t*te = '\\0';\n\t\tmode_t mode = S_IFDIR | (_dirPerms & 07777);\n\t\trpmFsmOp op = (FA_CREATE|FAF_UNOWNED);\n\n\t\t/* Run fsm file pre hook for all plugins */\n\t\trc = rpmpluginsCallFsmFilePre(plugins, NULL, dn, mode, op);\n\n\t\tif (!rc)\n\t\t    rc = fsmMkdir(-1, dn, mode);\n\n\t\tif (!rc) {\n\t\t    rc = rpmpluginsCallFsmFilePrepare(plugins, NULL, dn, dn,\n\t\t\t\t\t\t      mode, op);\n\t\t}\n\n\t\t/* Run fsm file post hook for all plugins */\n\t\trpmpluginsCallFsmFilePost(plugins, NULL, dn, mode, op, rc);\n\n\t\tif (!rc) {\n\t\t    rpmlog(RPMLOG_DEBUG,\n\t\t\t    \"%s directory created with perms %04o\\n\",\n\t\t\t    dn, (unsigned)(mode & 07777));\n\t\t}\n\t\t*te = '/';\n\t    }\n\t    if (rc)\n\t\tbreak;\n\t}\n\tif (rc) break;\n\n\t/* Save last validated path. */\n\tldn = dpath;\n\tldnlen = dnlen;\n    }\n    dnlFreeIterator(dnli);\n\n    return rc;\n}",
  "abstract_func": "static int fsmMkdirs(rpmfiles VAR_0, rpmfs VAR_1, rpmPlugins VAR_2)\n{\n    DNLI_t VAR_3 = dnlInitIterator(VAR_0, VAR_1, 0);\n    struct stat VAR_4;\n    const char *VAR_5;\n    int VAR_6 = 0;\n    int VAR_7;\n    size_t VAR_8 = 0;\n    const char * VAR_9 = NULL;\n\n    while ((VAR_5 = dnlNextIterator(VAR_3)) != NULL) {\n\tsize_t VAR_10 = strlen(VAR_5);\n\tchar * VAR_11, VAR_12[VAR_10+1];\n\n\tif (VAR_10 <= 1)\n\t    continue;\n\n\tif (VAR_10 == VAR_8 && rstreq(VAR_5, VAR_9))\n\t    continue;\n\n\t/* COMMENT_0 */\n\t(void) stpcpy(VAR_12, VAR_5);\n\n\t/* COMMENT_1 */\n\tfor (VAR_7 = 1, VAR_11 = VAR_12 + 1; *VAR_11 != '\\0'; VAR_11++, VAR_7++) {\n\t    if (*VAR_11 != '/')\n\t\tcontinue;\n\n\t    /* COMMENT_2 */\n\t    if (VAR_7 < VAR_8 &&\n\t\t(VAR_9[VAR_7] == '/' || VAR_9[VAR_7] == '\\0') && rstreqn(VAR_12, VAR_9, VAR_7))\n\t\tcontinue;\n\n\t    /* COMMENT_3 */\n\t    *VAR_11 = '\\0';\n\t    VAR_6 = fsmStat(VAR_12, 1, &VAR_4); /* COMMENT_4 */\n\t    *VAR_11 = '/';\n\n\t    /* COMMENT_5 */\n\t    if (VAR_6 == 0 && S_ISDIR(VAR_4.st_mode)) {\n\t\tcontinue;\n\t    } else if (VAR_6 == VAR_13) {\n\t\t*VAR_11 = '\\0';\n\t\tmode_t VAR_14 = VAR_15 | (VAR_16 & 07777);\n\t\trpmFsmOp VAR_17 = (VAR_18|VAR_19);\n\n\t\t/* COMMENT_6 */\n\t\tVAR_6 = rpmpluginsCallFsmFilePre(VAR_2, NULL, VAR_12, VAR_14, VAR_17);\n\n\t\tif (!VAR_6)\n\t\t    VAR_6 = fsmMkdir(-1, VAR_12, VAR_14);\n\n\t\tif (!VAR_6) {\n\t\t    VAR_6 = rpmpluginsCallFsmFilePrepare(VAR_2, NULL, VAR_12, VAR_12,\n\t\t\t\t\t\t      VAR_14, VAR_17);\n\t\t}\n\n\t\t/* COMMENT_7 */\n\t\trpmpluginsCallFsmFilePost(VAR_2, NULL, VAR_12, VAR_14, VAR_17, VAR_6);\n\n\t\tif (!VAR_6) {\n\t\t    rpmlog(VAR_20,\n\t\t\t    \"%s directory created with perms %04o\\n\",\n\t\t\t    VAR_12, (unsigned)(VAR_14 & 07777));\n\t\t}\n\t\t*VAR_11 = '/';\n\t    }\n\t    if (VAR_6)\n\t\tbreak;\n\t}\n\tif (VAR_6) break;\n\n\t/* COMMENT_8 */\n\tVAR_9 = VAR_5;\n\tVAR_8 = VAR_10;\n    }\n    dnlFreeIterator(VAR_3);\n\n    return VAR_6;\n}",
  "func_graph_path": "rpm-software-management/rpm/96ec957e281220f8e137a2d5eb23b83a6377d556/fsm.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -48,7 +48,7 @@\n \t\trc = rpmpluginsCallFsmFilePre(plugins, NULL, dn, mode, op);\n \n \t\tif (!rc)\n-\t\t    rc = fsmMkdir(dn, mode);\n+\t\t    rc = fsmMkdir(-1, dn, mode);\n \n \t\tif (!rc) {\n \t\t    rc = rpmpluginsCallFsmFilePrepare(plugins, NULL, dn, dn,",
  "diff_line_info": {
    "deleted_lines": [
      "\t\t    rc = fsmMkdir(dn, mode);"
    ],
    "added_lines": [
      "\t\t    rc = fsmMkdir(-1, dn, mode);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/rpm-software-management/rpm/pull/1919",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/rpm-software-management/rpm/pull/1919: 403 Client Error: Forbidden for url: https://api.github.com/repos/rpm-software-management/rpm/pulls/1919",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}