{
  "cve_id": "CVE-2016-6129",
  "cwe_ids": [
    "CWE-20"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "libtom/libtomcrypt",
  "commit_msg": "rsa_verify_hash: fix possible bleichenbacher signature attack",
  "commit_hash": "5eb9743410ce4657e9d54fef26a2ee31a1b5dd0",
  "git_url": "https://github.com/libtom/libtomcrypt/commit/5eb9743410ce4657e9d54fef26a2ee31a1b5dd09",
  "file_path": "src/pk/rsa/rsa_verify_hash.c",
  "func_name": "rsa_verify_hash_ex",
  "func_before": "int rsa_verify_hash_ex(const unsigned char *sig,      unsigned long siglen,\n                       const unsigned char *hash,     unsigned long hashlen,\n                             int            padding,\n                             int            hash_idx, unsigned long saltlen,\n                             int           *stat,     rsa_key      *key)\n{\n  unsigned long modulus_bitlen, modulus_bytelen, x;\n  int           err;\n  unsigned char *tmpbuf;\n\n  LTC_ARGCHK(hash  != NULL);\n  LTC_ARGCHK(sig   != NULL);\n  LTC_ARGCHK(stat  != NULL);\n  LTC_ARGCHK(key   != NULL);\n\n  /* default to invalid */\n  *stat = 0;\n\n  /* valid padding? */\n\n  if ((padding != LTC_PKCS_1_V1_5) &&\n      (padding != LTC_PKCS_1_PSS)) {\n    return CRYPT_PK_INVALID_PADDING;\n  }\n\n  if (padding == LTC_PKCS_1_PSS) {\n    /* valid hash ? */\n    if ((err = hash_is_valid(hash_idx)) != CRYPT_OK) {\n       return err;\n    }\n  }\n\n  /* get modulus len in bits */\n  modulus_bitlen = mp_count_bits( (key->N));\n\n  /* outlen must be at least the size of the modulus */\n  modulus_bytelen = mp_unsigned_bin_size( (key->N));\n  if (modulus_bytelen != siglen) {\n     return CRYPT_INVALID_PACKET;\n  }\n\n  /* allocate temp buffer for decoded sig */\n  tmpbuf = XMALLOC(siglen);\n  if (tmpbuf == NULL) {\n     return CRYPT_MEM;\n  }\n\n  /* RSA decode it  */\n  x = siglen;\n  if ((err = ltc_mp.rsa_me(sig, siglen, tmpbuf, &x, PK_PUBLIC, key)) != CRYPT_OK) {\n     XFREE(tmpbuf);\n     return err;\n  }\n\n  /* make sure the output is the right size */\n  if (x != siglen) {\n     XFREE(tmpbuf);\n     return CRYPT_INVALID_PACKET;\n  }\n\n  if (padding == LTC_PKCS_1_PSS) {\n    /* PSS decode and verify it */\n\n    if(modulus_bitlen%8 == 1){\n      err = pkcs_1_pss_decode(hash, hashlen, tmpbuf+1, x-1, saltlen, hash_idx, modulus_bitlen, stat);\n    }\n    else{\n      err = pkcs_1_pss_decode(hash, hashlen, tmpbuf, x, saltlen, hash_idx, modulus_bitlen, stat);\n    }\n\n  } else {\n    /* PKCS #1 v1.5 decode it */\n    unsigned char *out;\n    unsigned long outlen, loid[16];\n    int           decoded;\n    ltc_asn1_list digestinfo[2], siginfo[2];\n\n    /* not all hashes have OIDs... so sad */\n    if (hash_descriptor[hash_idx].OIDlen == 0) {\n       err = CRYPT_INVALID_ARG;\n       goto bail_2;\n    }\n\n    /* allocate temp buffer for decoded hash */\n    outlen = ((modulus_bitlen >> 3) + (modulus_bitlen & 7 ? 1 : 0)) - 3;\n    out    = XMALLOC(outlen);\n    if (out == NULL) {\n      err = CRYPT_MEM;\n      goto bail_2;\n    }\n\n    if ((err = pkcs_1_v1_5_decode(tmpbuf, x, LTC_PKCS_1_EMSA, modulus_bitlen, out, &outlen, &decoded)) != CRYPT_OK) {\n      XFREE(out);\n      goto bail_2;\n    }\n\n    /* now we must decode out[0...outlen-1] using ASN.1, test the OID and then test the hash */\n    /* construct the SEQUENCE\n      SEQUENCE {\n         SEQUENCE {hashoid OID\n                   blah    NULL\n         }\n         hash    OCTET STRING\n      }\n   */\n    LTC_SET_ASN1(digestinfo, 0, LTC_ASN1_OBJECT_IDENTIFIER, loid, sizeof(loid)/sizeof(loid[0]));\n    LTC_SET_ASN1(digestinfo, 1, LTC_ASN1_NULL,              NULL,                          0);\n    LTC_SET_ASN1(siginfo,    0, LTC_ASN1_SEQUENCE,          digestinfo,                    2);\n    LTC_SET_ASN1(siginfo,    1, LTC_ASN1_OCTET_STRING,      tmpbuf,                        siglen);\n\n    if ((err = der_decode_sequence(out, outlen, siginfo, 2)) != CRYPT_OK) {\n       XFREE(out);\n       goto bail_2;\n    }\n\n    /* test OID */\n    if ((digestinfo[0].size == hash_descriptor[hash_idx].OIDlen) &&\n        (XMEMCMP(digestinfo[0].data, hash_descriptor[hash_idx].OID, sizeof(unsigned long) * hash_descriptor[hash_idx].OIDlen) == 0) &&\n        (siginfo[1].size == hashlen) &&\n        (XMEMCMP(siginfo[1].data, hash, hashlen) == 0)) {\n       *stat = 1;\n    }\n\n#ifdef LTC_CLEAN_STACK\n    zeromem(out, outlen);\n#endif\n    XFREE(out);\n  }\n\nbail_2:\n#ifdef LTC_CLEAN_STACK\n  zeromem(tmpbuf, siglen);\n#endif\n  XFREE(tmpbuf);\n  return err;\n}",
  "abstract_func_before": "int rsa_verify_hash_ex(const unsigned char *VAR_0,      unsigned long VAR_1,\n                       const unsigned char *VAR_2,     unsigned long VAR_3,\n                             int            VAR_4,\n                             int            VAR_5, unsigned long VAR_6,\n                             int           *VAR_7,     rsa_key      *VAR_8)\n{\n  unsigned long VAR_9, VAR_10, VAR_11;\n  int           VAR_12;\n  unsigned char *VAR_13;\n\n  LTC_ARGCHK(VAR_2  != NULL);\n  LTC_ARGCHK(VAR_0   != NULL);\n  LTC_ARGCHK(VAR_7  != NULL);\n  LTC_ARGCHK(VAR_8   != NULL);\n\n  /* COMMENT_0 */\n  *VAR_7 = 0;\n\n  /* COMMENT_1 */\n\n  if ((VAR_4 != VAR_14) &&\n      (VAR_4 != VAR_15)) {\n    return VAR_16;\n  }\n\n  if (VAR_4 == VAR_15) {\n    /* COMMENT_2 */\n    if ((VAR_12 = hash_is_valid(VAR_5)) != VAR_17) {\n       return VAR_12;\n    }\n  }\n\n  /* COMMENT_3 */\n  VAR_9 = mp_count_bits( (VAR_8->N));\n\n  /* COMMENT_4 */\n  VAR_10 = mp_unsigned_bin_size( (VAR_8->N));\n  if (VAR_10 != VAR_1) {\n     return VAR_18;\n  }\n\n  /* COMMENT_5 */\n  VAR_13 = XMALLOC(VAR_1);\n  if (VAR_13 == NULL) {\n     return VAR_19;\n  }\n\n  /* COMMENT_6 */\n  VAR_11 = VAR_1;\n  if ((VAR_12 = VAR_20.rsa_me(VAR_0, VAR_1, VAR_13, &VAR_11, VAR_21, VAR_8)) != VAR_17) {\n     XFREE(VAR_13);\n     return VAR_12;\n  }\n\n  /* COMMENT_7 */\n  if (VAR_11 != VAR_1) {\n     XFREE(VAR_13);\n     return VAR_18;\n  }\n\n  if (VAR_4 == VAR_15) {\n    /* COMMENT_8 */\n\n    if(VAR_9%8 == 1){\n      VAR_12 = pkcs_1_pss_decode(VAR_2, VAR_3, VAR_13+1, VAR_11-1, VAR_6, VAR_5, VAR_9, VAR_7);\n    }\n    else{\n      VAR_12 = pkcs_1_pss_decode(VAR_2, VAR_3, VAR_13, VAR_11, VAR_6, VAR_5, VAR_9, VAR_7);\n    }\n\n  } else {\n    /* COMMENT_9 */\n    unsigned char *VAR_22;\n    unsigned long VAR_23, VAR_24[16];\n    int           VAR_25;\n    ltc_asn1_list VAR_26[2], VAR_27[2];\n\n    /* COMMENT_10 */\n    if (VAR_28[VAR_5].OIDlen == 0) {\n       VAR_12 = VAR_29;\n       goto bail_2;\n    }\n\n    /* COMMENT_11 */\n    VAR_23 = ((VAR_9 >> 3) + (VAR_9 & 7 ? 1 : 0)) - 3;\n    VAR_22    = XMALLOC(VAR_23);\n    if (VAR_22 == NULL) {\n      VAR_12 = VAR_19;\n      goto bail_2;\n    }\n\n    if ((VAR_12 = pkcs_1_v1_5_decode(VAR_13, VAR_11, VAR_30, VAR_9, VAR_22, &VAR_23, &VAR_25)) != VAR_17) {\n      XFREE(VAR_22);\n      goto bail_2;\n    }\n\n    /* COMMENT_12 */\n    /* COMMENT_13 */\n                \n                              \n                               \n          \n                             \n       \n     \n    LTC_SET_ASN1(VAR_26, 0, VAR_31, VAR_24, sizeof(loid)/sizeof(loid[0]));\n    LTC_SET_ASN1(VAR_26, 1, VAR_32,              NULL,                          0);\n    LTC_SET_ASN1(VAR_27,    0, VAR_33,          VAR_26,                    2);\n    LTC_SET_ASN1(VAR_27,    1, VAR_34,      VAR_13,                        VAR_1);\n\n    if ((VAR_12 = der_decode_sequence(VAR_22, VAR_23, VAR_27, 2)) != VAR_17) {\n       XFREE(VAR_22);\n       goto bail_2;\n    }\n\n    /* COMMENT_21 */\n    if ((VAR_26[0].size == VAR_28[VAR_5].OIDlen) &&\n        (XMEMCMP(VAR_26[0].data, VAR_28[VAR_5].OID, sizeof(unsigned long) * VAR_28[VAR_5].OIDlen) == 0) &&\n        (VAR_27[1].size == VAR_3) &&\n        (XMEMCMP(VAR_27[1].data, VAR_2, VAR_3) == 0)) {\n       *VAR_7 = 1;\n    }\n\n#ifdef VAR_35\n    zeromem(VAR_22, VAR_23);\n#endif\n    XFREE(VAR_22);\n  }\n\nbail_2:\n#ifdef VAR_35\n  zeromem(VAR_13, VAR_1);\n#endif\n  XFREE(VAR_13);\n  return VAR_12;\n}",
  "func_graph_path_before": "libtom/libtomcrypt/5eb9743410ce4657e9d54fef26a2ee31a1b5dd0/rsa_verify_hash.c/vul/before/0.json",
  "func": "int rsa_verify_hash_ex(const unsigned char *sig,      unsigned long siglen,\n                       const unsigned char *hash,     unsigned long hashlen,\n                             int            padding,\n                             int            hash_idx, unsigned long saltlen,\n                             int           *stat,     rsa_key      *key)\n{\n  unsigned long modulus_bitlen, modulus_bytelen, x;\n  int           err;\n  unsigned char *tmpbuf;\n\n  LTC_ARGCHK(hash  != NULL);\n  LTC_ARGCHK(sig   != NULL);\n  LTC_ARGCHK(stat  != NULL);\n  LTC_ARGCHK(key   != NULL);\n\n  /* default to invalid */\n  *stat = 0;\n\n  /* valid padding? */\n\n  if ((padding != LTC_PKCS_1_V1_5) &&\n      (padding != LTC_PKCS_1_PSS)) {\n    return CRYPT_PK_INVALID_PADDING;\n  }\n\n  if (padding == LTC_PKCS_1_PSS) {\n    /* valid hash ? */\n    if ((err = hash_is_valid(hash_idx)) != CRYPT_OK) {\n       return err;\n    }\n  }\n\n  /* get modulus len in bits */\n  modulus_bitlen = mp_count_bits( (key->N));\n\n  /* outlen must be at least the size of the modulus */\n  modulus_bytelen = mp_unsigned_bin_size( (key->N));\n  if (modulus_bytelen != siglen) {\n     return CRYPT_INVALID_PACKET;\n  }\n\n  /* allocate temp buffer for decoded sig */\n  tmpbuf = XMALLOC(siglen);\n  if (tmpbuf == NULL) {\n     return CRYPT_MEM;\n  }\n\n  /* RSA decode it  */\n  x = siglen;\n  if ((err = ltc_mp.rsa_me(sig, siglen, tmpbuf, &x, PK_PUBLIC, key)) != CRYPT_OK) {\n     XFREE(tmpbuf);\n     return err;\n  }\n\n  /* make sure the output is the right size */\n  if (x != siglen) {\n     XFREE(tmpbuf);\n     return CRYPT_INVALID_PACKET;\n  }\n\n  if (padding == LTC_PKCS_1_PSS) {\n    /* PSS decode and verify it */\n\n    if(modulus_bitlen%8 == 1){\n      err = pkcs_1_pss_decode(hash, hashlen, tmpbuf+1, x-1, saltlen, hash_idx, modulus_bitlen, stat);\n    }\n    else{\n      err = pkcs_1_pss_decode(hash, hashlen, tmpbuf, x, saltlen, hash_idx, modulus_bitlen, stat);\n    }\n\n  } else {\n    /* PKCS #1 v1.5 decode it */\n    unsigned char *out;\n    unsigned long outlen, loid[16], reallen;\n    int           decoded;\n    ltc_asn1_list digestinfo[2], siginfo[2];\n\n    /* not all hashes have OIDs... so sad */\n    if (hash_descriptor[hash_idx].OIDlen == 0) {\n       err = CRYPT_INVALID_ARG;\n       goto bail_2;\n    }\n\n    /* allocate temp buffer for decoded hash */\n    outlen = ((modulus_bitlen >> 3) + (modulus_bitlen & 7 ? 1 : 0)) - 3;\n    out    = XMALLOC(outlen);\n    if (out == NULL) {\n      err = CRYPT_MEM;\n      goto bail_2;\n    }\n\n    if ((err = pkcs_1_v1_5_decode(tmpbuf, x, LTC_PKCS_1_EMSA, modulus_bitlen, out, &outlen, &decoded)) != CRYPT_OK) {\n      XFREE(out);\n      goto bail_2;\n    }\n\n    /* now we must decode out[0...outlen-1] using ASN.1, test the OID and then test the hash */\n    /* construct the SEQUENCE\n      SEQUENCE {\n         SEQUENCE {hashoid OID\n                   blah    NULL\n         }\n         hash    OCTET STRING\n      }\n   */\n    LTC_SET_ASN1(digestinfo, 0, LTC_ASN1_OBJECT_IDENTIFIER, loid, sizeof(loid)/sizeof(loid[0]));\n    LTC_SET_ASN1(digestinfo, 1, LTC_ASN1_NULL,              NULL,                          0);\n    LTC_SET_ASN1(siginfo,    0, LTC_ASN1_SEQUENCE,          digestinfo,                    2);\n    LTC_SET_ASN1(siginfo,    1, LTC_ASN1_OCTET_STRING,      tmpbuf,                        siglen);\n\n    if ((err = der_decode_sequence(out, outlen, siginfo, 2)) != CRYPT_OK) {\n       XFREE(out);\n       goto bail_2;\n    }\n\n    if ((err = der_length_sequence(siginfo, 2, &reallen)) != CRYPT_OK) {\n       XFREE(out);\n       goto bail_2;\n    }\n\n    /* test OID */\n    if ((reallen == outlen) &&\n        (digestinfo[0].size == hash_descriptor[hash_idx].OIDlen) &&\n        (XMEMCMP(digestinfo[0].data, hash_descriptor[hash_idx].OID, sizeof(unsigned long) * hash_descriptor[hash_idx].OIDlen) == 0) &&\n        (siginfo[1].size == hashlen) &&\n        (XMEMCMP(siginfo[1].data, hash, hashlen) == 0)) {\n       *stat = 1;\n    }\n\n#ifdef LTC_CLEAN_STACK\n    zeromem(out, outlen);\n#endif\n    XFREE(out);\n  }\n\nbail_2:\n#ifdef LTC_CLEAN_STACK\n  zeromem(tmpbuf, siglen);\n#endif\n  XFREE(tmpbuf);\n  return err;\n}",
  "abstract_func": "int rsa_verify_hash_ex(const unsigned char *VAR_0,      unsigned long VAR_1,\n                       const unsigned char *VAR_2,     unsigned long VAR_3,\n                             int            VAR_4,\n                             int            VAR_5, unsigned long VAR_6,\n                             int           *VAR_7,     rsa_key      *VAR_8)\n{\n  unsigned long VAR_9, VAR_10, VAR_11;\n  int           VAR_12;\n  unsigned char *VAR_13;\n\n  LTC_ARGCHK(VAR_2  != NULL);\n  LTC_ARGCHK(VAR_0   != NULL);\n  LTC_ARGCHK(VAR_7  != NULL);\n  LTC_ARGCHK(VAR_8   != NULL);\n\n  /* COMMENT_0 */\n  *VAR_7 = 0;\n\n  /* COMMENT_1 */\n\n  if ((VAR_4 != VAR_14) &&\n      (VAR_4 != VAR_15)) {\n    return VAR_16;\n  }\n\n  if (VAR_4 == VAR_15) {\n    /* COMMENT_2 */\n    if ((VAR_12 = hash_is_valid(VAR_5)) != VAR_17) {\n       return VAR_12;\n    }\n  }\n\n  /* COMMENT_3 */\n  VAR_9 = mp_count_bits( (VAR_8->N));\n\n  /* COMMENT_4 */\n  VAR_10 = mp_unsigned_bin_size( (VAR_8->N));\n  if (VAR_10 != VAR_1) {\n     return VAR_18;\n  }\n\n  /* COMMENT_5 */\n  VAR_13 = XMALLOC(VAR_1);\n  if (VAR_13 == NULL) {\n     return VAR_19;\n  }\n\n  /* COMMENT_6 */\n  VAR_11 = VAR_1;\n  if ((VAR_12 = VAR_20.rsa_me(VAR_0, VAR_1, VAR_13, &VAR_11, VAR_21, VAR_8)) != VAR_17) {\n     XFREE(VAR_13);\n     return VAR_12;\n  }\n\n  /* COMMENT_7 */\n  if (VAR_11 != VAR_1) {\n     XFREE(VAR_13);\n     return VAR_18;\n  }\n\n  if (VAR_4 == VAR_15) {\n    /* COMMENT_8 */\n\n    if(VAR_9%8 == 1){\n      VAR_12 = pkcs_1_pss_decode(VAR_2, VAR_3, VAR_13+1, VAR_11-1, VAR_6, VAR_5, VAR_9, VAR_7);\n    }\n    else{\n      VAR_12 = pkcs_1_pss_decode(VAR_2, VAR_3, VAR_13, VAR_11, VAR_6, VAR_5, VAR_9, VAR_7);\n    }\n\n  } else {\n    /* COMMENT_9 */\n    unsigned char *VAR_22;\n    unsigned long VAR_23, VAR_24[16], VAR_25;\n    int           VAR_26;\n    ltc_asn1_list VAR_27[2], VAR_28[2];\n\n    /* COMMENT_10 */\n    if (VAR_29[VAR_5].OIDlen == 0) {\n       VAR_12 = VAR_30;\n       goto bail_2;\n    }\n\n    /* COMMENT_11 */\n    VAR_23 = ((VAR_9 >> 3) + (VAR_9 & 7 ? 1 : 0)) - 3;\n    VAR_22    = XMALLOC(VAR_23);\n    if (VAR_22 == NULL) {\n      VAR_12 = VAR_19;\n      goto bail_2;\n    }\n\n    if ((VAR_12 = pkcs_1_v1_5_decode(VAR_13, VAR_11, VAR_31, VAR_9, VAR_22, &VAR_23, &VAR_26)) != VAR_17) {\n      XFREE(VAR_22);\n      goto bail_2;\n    }\n\n    /* COMMENT_12 */\n    /* COMMENT_13 */\n                \n                              \n                               \n          \n                             \n       \n     \n    LTC_SET_ASN1(VAR_27, 0, VAR_32, VAR_24, sizeof(loid)/sizeof(loid[0]));\n    LTC_SET_ASN1(VAR_27, 1, VAR_33,              NULL,                          0);\n    LTC_SET_ASN1(VAR_28,    0, VAR_34,          VAR_27,                    2);\n    LTC_SET_ASN1(VAR_28,    1, VAR_35,      VAR_13,                        VAR_1);\n\n    if ((VAR_12 = der_decode_sequence(VAR_22, VAR_23, VAR_28, 2)) != VAR_17) {\n       XFREE(VAR_22);\n       goto bail_2;\n    }\n\n    if ((VAR_12 = der_length_sequence(VAR_28, 2, &VAR_25)) != VAR_17) {\n       XFREE(VAR_22);\n       goto bail_2;\n    }\n\n    /* COMMENT_21 */\n    if ((VAR_25 == VAR_23) &&\n        (VAR_27[0].size == VAR_29[VAR_5].OIDlen) &&\n        (XMEMCMP(VAR_27[0].data, VAR_29[VAR_5].OID, sizeof(unsigned long) * VAR_29[VAR_5].OIDlen) == 0) &&\n        (VAR_28[1].size == VAR_3) &&\n        (XMEMCMP(VAR_28[1].data, VAR_2, VAR_3) == 0)) {\n       *VAR_7 = 1;\n    }\n\n#ifdef VAR_36\n    zeromem(VAR_22, VAR_23);\n#endif\n    XFREE(VAR_22);\n  }\n\nbail_2:\n#ifdef VAR_36\n  zeromem(VAR_13, VAR_1);\n#endif\n  XFREE(VAR_13);\n  return VAR_12;\n}",
  "func_graph_path": "libtom/libtomcrypt/5eb9743410ce4657e9d54fef26a2ee31a1b5dd0/rsa_verify_hash.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -71,7 +71,7 @@\n   } else {\n     /* PKCS #1 v1.5 decode it */\n     unsigned char *out;\n-    unsigned long outlen, loid[16];\n+    unsigned long outlen, loid[16], reallen;\n     int           decoded;\n     ltc_asn1_list digestinfo[2], siginfo[2];\n \n@@ -113,8 +113,14 @@\n        goto bail_2;\n     }\n \n+    if ((err = der_length_sequence(siginfo, 2, &reallen)) != CRYPT_OK) {\n+       XFREE(out);\n+       goto bail_2;\n+    }\n+\n     /* test OID */\n-    if ((digestinfo[0].size == hash_descriptor[hash_idx].OIDlen) &&\n+    if ((reallen == outlen) &&\n+        (digestinfo[0].size == hash_descriptor[hash_idx].OIDlen) &&\n         (XMEMCMP(digestinfo[0].data, hash_descriptor[hash_idx].OID, sizeof(unsigned long) * hash_descriptor[hash_idx].OIDlen) == 0) &&\n         (siginfo[1].size == hashlen) &&\n         (XMEMCMP(siginfo[1].data, hash, hashlen) == 0)) {",
  "diff_line_info": {
    "deleted_lines": [
      "    unsigned long outlen, loid[16];",
      "    if ((digestinfo[0].size == hash_descriptor[hash_idx].OIDlen) &&"
    ],
    "added_lines": [
      "    unsigned long outlen, loid[16], reallen;",
      "    if ((err = der_length_sequence(siginfo, 2, &reallen)) != CRYPT_OK) {",
      "       XFREE(out);",
      "       goto bail_2;",
      "    }",
      "",
      "    if ((reallen == outlen) &&",
      "        (digestinfo[0].size == hash_descriptor[hash_idx].OIDlen) &&"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libtom/libtomcrypt/pull/48",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/libtom/libtomcrypt/pull/48: 403 Client Error: Forbidden for url: https://api.github.com/repos/libtom/libtomcrypt/pulls/48",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95"
}