{
  "cve_id": "CVE-2021-34335",
  "cwe_ids": [
    "CWE-369"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "Exiv2/exiv2",
  "commit_msg": "Defensive coding to avoid 0x80000000/0xFFFFFFFF FPE.",
  "commit_hash": "2d8d44e47b1500030e5b249bffbaf1e80aa74815",
  "git_url": "https://github.com/Exiv2/exiv2/commit/2d8d44e47b1500030e5b249bffbaf1e80aa74815",
  "file_path": "include/exiv2/value.hpp",
  "func_name": "ValueType<URational>::toLong",
  "func_before": "inline long ValueType<URational>::toLong(long n) const\n    {\n        ok_ = (value_.at(n).second != 0 && value_.at(n).first < LARGE_INT);\n        if (!ok_) return 0;\n        return value_.at(n).first / value_.at(n).second;\n    }",
  "abstract_func_before": "inline long ValueType<URational>::toLong(long VAR_0) const\n    {\n        VAR_1 = (VAR_2.at(VAR_0).second != 0 && VAR_2.at(VAR_0).first < VAR_3);\n        if (!VAR_1) return 0;\n        return VAR_2.at(VAR_0).first / VAR_2.at(VAR_0).second;\n    }",
  "func_graph_path_before": "Exiv2/exiv2/2d8d44e47b1500030e5b249bffbaf1e80aa74815/value.hpp/vul/before/0.json",
  "func": "inline long ValueType<URational>::toLong(long n) const\n    {\n        ok_ = (value_.at(n).second > 0 && value_.at(n).first < LARGE_INT);\n        if (!ok_) return 0;\n        return value_.at(n).first / value_.at(n).second;\n    }",
  "abstract_func": "inline long ValueType<URational>::toLong(long VAR_0) const\n    {\n        VAR_1 = (VAR_2.at(VAR_0).second > 0 && VAR_2.at(VAR_0).first < VAR_3);\n        if (!VAR_1) return 0;\n        return VAR_2.at(VAR_0).first / VAR_2.at(VAR_0).second;\n    }",
  "func_graph_path": "Exiv2/exiv2/2d8d44e47b1500030e5b249bffbaf1e80aa74815/value.hpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n inline long ValueType<URational>::toLong(long n) const\n     {\n-        ok_ = (value_.at(n).second != 0 && value_.at(n).first < LARGE_INT);\n+        ok_ = (value_.at(n).second > 0 && value_.at(n).first < LARGE_INT);\n         if (!ok_) return 0;\n         return value_.at(n).first / value_.at(n).second;\n     }",
  "diff_line_info": {
    "deleted_lines": [
      "        ok_ = (value_.at(n).second != 0 && value_.at(n).first < LARGE_INT);"
    ],
    "added_lines": [
      "        ok_ = (value_.at(n).second > 0 && value_.at(n).first < LARGE_INT);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/Exiv2/exiv2/pull/1750",
  "description": {
    "pr_info": {
      "title": "Avoid integer divide by zero",
      "number": 1750
    },
    "comment": [
      "The main change here is to fix an integer divide by zero in [`src/minoltamn_int.cpp`](https://github.com/Exiv2/exiv2/blob/ab58026cff0e5edebc026261e9dc4b7db05b802d/src/minoltamn_int.cpp#L2176).\r\n\r\nI also added some defensive coding to avoid the FPE that could be caused by `0x80000000/0xFFFFFFFF`: rather than checking that the denominator is not zero, check that the denominator is greater than zero. I doubt that we are ever deliberately using negative denominators, so I think it should be a safe change.",
      "This is the CodeQL query that I used to search for integer divide operations:\r\n\r\n```\r\nimport cpp\r\nimport semmle.code.cpp.rangeanalysis.SimpleRangeAnalysis\r\n\r\nfrom DivExpr div, Expr rhs\r\nwhere\r\n  rhs = div.getRightOperand() and\r\n  div.getType() instanceof IntegralType and\r\n  not (lowerBound(rhs) > 0 or upperBound(rhs) < 0) and\r\n  not rhs instanceof SizeofOperator and\r\n  exists(rhs.getLocation().getFile().getRelativePath())\r\nselect rhs, rhs.getType()\r\n```"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "The patch addresses a potential division by zero error, which can lead to program crashes or undefined behavior. The change involves updating the condition to check if the denominator is positive, preventing such issues. This is a security fix as it mitigates a potential exploit.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9"
}