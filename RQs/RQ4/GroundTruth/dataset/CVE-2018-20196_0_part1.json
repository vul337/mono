{
  "cve_id": "CVE-2018-20196",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "knik0/faad2",
  "commit_msg": "sbr_fbt: sbr->M should not exceed MAX_M\n\nsbr->M is set by derived_frequency_table() from user-passed input\nwithout checking for > MAX_M.\n\nThis leads to out-of-bounds accesses later, crashes and potential\nsecurity relevant issues. It should be considered a fatal error for\nthe SBR block.\n\nreturn error code if sbr->M > MAX_M.\n\nalso, in some cases sbr_extension_data() ignores the return value of\ncalc_sbr_tables, probably assuming that sbr is always valid. It should\nalmost certainly not do that.\n\nfixes #19 (CVE-2018-20196).",
  "commit_hash": "6aeeaa1af0caf986daf22852a97f7c13c5edd879",
  "git_url": "https://github.com/knik0/faad2/commit/6aeeaa1af0caf986daf22852a97f7c13c5edd879",
  "file_path": "libfaad/sbr_syntax.c",
  "func_name": "sbr_extension_data",
  "func_before": "uint8_t sbr_extension_data(bitfile *ld, sbr_info *sbr, uint16_t cnt,\n                           uint8_t psResetFlag)\n{\n    uint8_t result = 0;\n    uint16_t num_align_bits = 0;\n    uint16_t num_sbr_bits1 = (uint16_t)faad_get_processed_bits(ld);\n    uint16_t num_sbr_bits2;\n\n    uint8_t saved_start_freq, saved_samplerate_mode;\n    uint8_t saved_stop_freq, saved_freq_scale;\n    uint8_t saved_alter_scale, saved_xover_band;\n\n#if (defined(PS_DEC) || defined(DRM_PS))\n    if (psResetFlag)\n        sbr->psResetFlag = psResetFlag;\n#endif\n\n#ifdef DRM\n    if (!sbr->Is_DRM_SBR)\n#endif\n    {\n        uint8_t bs_extension_type = (uint8_t)faad_getbits(ld, 4\n            DEBUGVAR(1,198,\"sbr_bitstream(): bs_extension_type\"));\n\n        if (bs_extension_type == EXT_SBR_DATA_CRC)\n        {\n            sbr->bs_sbr_crc_bits = (uint16_t)faad_getbits(ld, 10\n                DEBUGVAR(1,199,\"sbr_bitstream(): bs_sbr_crc_bits\"));\n        }\n    }\n\n    /* save old header values, in case the new ones are corrupted */\n    saved_start_freq = sbr->bs_start_freq;\n    saved_samplerate_mode = sbr->bs_samplerate_mode;\n    saved_stop_freq = sbr->bs_stop_freq;\n    saved_freq_scale = sbr->bs_freq_scale;\n    saved_alter_scale = sbr->bs_alter_scale;\n    saved_xover_band = sbr->bs_xover_band;\n\n    sbr->bs_header_flag = faad_get1bit(ld\n        DEBUGVAR(1,200,\"sbr_bitstream(): bs_header_flag\"));\n\n    if (sbr->bs_header_flag)\n        sbr_header(ld, sbr);\n\n    /* Reset? */\n    sbr_reset(sbr);\n\n    /* first frame should have a header */\n    //if (!(sbr->frame == 0 && sbr->bs_header_flag == 0))\n    if (sbr->header_count != 0)\n    {\n        if (sbr->Reset || (sbr->bs_header_flag && sbr->just_seeked))\n        {\n            uint8_t rt = calc_sbr_tables(sbr, sbr->bs_start_freq, sbr->bs_stop_freq,\n                sbr->bs_samplerate_mode, sbr->bs_freq_scale,\n                sbr->bs_alter_scale, sbr->bs_xover_band);\n\n            /* if an error occured with the new header values revert to the old ones */\n            if (rt > 0)\n            {\n                calc_sbr_tables(sbr, saved_start_freq, saved_stop_freq,\n                    saved_samplerate_mode, saved_freq_scale,\n                    saved_alter_scale, saved_xover_band);\n            }\n        }\n\n        if (result == 0)\n        {\n            result = sbr_data(ld, sbr);\n\n            /* sbr_data() returning an error means that there was an error in\n               envelope_time_border_vector().\n               In this case the old time border vector is saved and all the previous\n               data normally read after sbr_grid() is saved.\n            */\n            /* to be on the safe side, calculate old sbr tables in case of error */\n            if ((result > 0) &&\n                (sbr->Reset || (sbr->bs_header_flag && sbr->just_seeked)))\n            {\n                calc_sbr_tables(sbr, saved_start_freq, saved_stop_freq,\n                    saved_samplerate_mode, saved_freq_scale,\n                    saved_alter_scale, saved_xover_band);          \n            }\n\n            /* we should be able to safely set result to 0 now, */\n            /* but practise indicates this doesn't work well */\n        }\n    } else {\n        result = 1;\n    }\n\n    num_sbr_bits2 = (uint16_t)faad_get_processed_bits(ld) - num_sbr_bits1;\n\n    /* check if we read more bits then were available for sbr */\n    if (8*cnt < num_sbr_bits2)\n    {\n        faad_resetbits(ld, num_sbr_bits1 + 8*cnt);\n        num_sbr_bits2 = 8*cnt;\n\n#ifdef PS_DEC\n        /* turn off PS for the unfortunate case that we randomly read some\n         * PS data that looks correct */\n        sbr->ps_used = 0;\n#endif\n\n        /* Make sure it doesn't decode SBR in this frame, or we'll get glitches */\n        return 1;\n    }\n\n#ifdef DRM\n    if (!sbr->Is_DRM_SBR)\n#endif\n    {       \n        /* -4 does not apply, bs_extension_type is re-read in this function */\n        num_align_bits = 8*cnt /*- 4*/ - num_sbr_bits2;\n\n        while (num_align_bits > 7)\n        {\n            faad_getbits(ld, 8\n                DEBUGVAR(1,999,\"sbr_bitstream(): num_align_bits\"));\n            num_align_bits -= 8;\n        }\n        faad_getbits(ld, num_align_bits\n            DEBUGVAR(1,999,\"sbr_bitstream(): num_align_bits\"));\n    }\n\n    return result;\n}",
  "abstract_func_before": "uint8_t sbr_extension_data(bitfile *VAR_0, sbr_info *VAR_1, uint16_t VAR_2,\n                           uint8_t VAR_3)\n{\n    uint8_t VAR_4 = 0;\n    uint16_t VAR_5 = 0;\n    uint16_t VAR_6 = (uint16_t)faad_get_processed_bits(VAR_0);\n    uint16_t VAR_7;\n\n    uint8_t VAR_8, VAR_9;\n    uint8_t VAR_10, VAR_11;\n    uint8_t VAR_12, VAR_13;\n\n#if (defined(VAR_14) || defined(VAR_15))\n    if (VAR_3)\n        VAR_1->psResetFlag = VAR_3;\n#endif\n\n#ifdef VAR_16\n    if (!VAR_1->Is_DRM_SBR)\n#endif\n    {\n        uint8_t VAR_17 = (uint8_t)faad_getbits(VAR_0, 4\n            DEBUGVAR(1,198,\"sbr_bitstream(): bs_extension_type\"));\n\n        if (VAR_17 == VAR_18)\n        {\n            VAR_1->bs_sbr_crc_bits = (uint16_t)faad_getbits(VAR_0, 10\n                DEBUGVAR(1,199,\"sbr_bitstream(): bs_sbr_crc_bits\"));\n        }\n    }\n\n    /* COMMENT_0 */\n    VAR_8 = VAR_1->bs_start_freq;\n    VAR_9 = VAR_1->bs_samplerate_mode;\n    VAR_10 = VAR_1->bs_stop_freq;\n    VAR_11 = VAR_1->bs_freq_scale;\n    VAR_12 = VAR_1->bs_alter_scale;\n    VAR_13 = VAR_1->bs_xover_band;\n\n    VAR_1->bs_header_flag = faad_get1bit(VAR_0\n        DEBUGVAR(1,200,\"sbr_bitstream(): bs_header_flag\"));\n\n    if (VAR_1->bs_header_flag)\n        sbr_header(VAR_0, VAR_1);\n\n    /* COMMENT_1 */\n    sbr_reset(VAR_1);\n\n    /* COMMENT_2 */\n    /* COMMENT_3 */\n    if (VAR_1->header_count != 0)\n    {\n        if (VAR_1->Reset || (VAR_1->bs_header_flag && VAR_1->just_seeked))\n        {\n            uint8_t VAR_19 = calc_sbr_tables(VAR_1, VAR_1->bs_start_freq, VAR_1->bs_stop_freq,\n                VAR_1->bs_samplerate_mode, VAR_1->bs_freq_scale,\n                VAR_1->bs_alter_scale, VAR_1->bs_xover_band);\n\n            /* COMMENT_4 */\n            if (VAR_19 > 0)\n            {\n                calc_sbr_tables(VAR_1, VAR_8, VAR_10,\n                    VAR_9, VAR_11,\n                    VAR_12, VAR_13);\n            }\n        }\n\n        if (VAR_4 == 0)\n        {\n            VAR_4 = sbr_data(VAR_0, VAR_1);\n\n            /* COMMENT_5 */\n                                             \n                                                                                    \n                                                            \n              \n            /* COMMENT_10 */\n            if ((VAR_4 > 0) &&\n                (VAR_1->Reset || (VAR_1->bs_header_flag && VAR_1->just_seeked)))\n            {\n                calc_sbr_tables(VAR_1, VAR_8, VAR_10,\n                    VAR_9, VAR_11,\n                    VAR_12, VAR_13);          \n            }\n\n            /* COMMENT_11 */\n            /* COMMENT_12 */\n        }\n    } else {\n        VAR_4 = 1;\n    }\n\n    VAR_7 = (uint16_t)faad_get_processed_bits(VAR_0) - VAR_6;\n\n    /* COMMENT_13 */\n    if (8*VAR_2 < VAR_7)\n    {\n        faad_resetbits(VAR_0, VAR_6 + 8*VAR_2);\n        VAR_7 = 8*VAR_2;\n\n#ifdef VAR_14\n        /* COMMENT_14 */\n                                        \n        VAR_1->ps_used = 0;\n#endif\n\n        /* COMMENT_16 */\n        return 1;\n    }\n\n#ifdef VAR_16\n    if (!VAR_1->Is_DRM_SBR)\n#endif\n    {       \n        /* COMMENT_17 */\n        VAR_5 = 8*VAR_2 /* COMMENT_18 */ - VAR_7;\n\n        while (VAR_5 > 7)\n        {\n            faad_getbits(VAR_0, 8\n                DEBUGVAR(1,999,\"sbr_bitstream(): num_align_bits\"));\n            VAR_5 -= 8;\n        }\n        faad_getbits(VAR_0, VAR_5\n            DEBUGVAR(1,999,\"sbr_bitstream(): num_align_bits\"));\n    }\n\n    return VAR_4;\n}",
  "func_graph_path_before": "knik0/faad2/6aeeaa1af0caf986daf22852a97f7c13c5edd879/sbr_syntax.c/vul/before/0.json",
  "func": "uint8_t sbr_extension_data(bitfile *ld, sbr_info *sbr, uint16_t cnt,\n                           uint8_t psResetFlag)\n{\n    uint8_t result = 0;\n    uint16_t num_align_bits = 0;\n    uint16_t num_sbr_bits1 = (uint16_t)faad_get_processed_bits(ld);\n    uint16_t num_sbr_bits2;\n\n    uint8_t saved_start_freq, saved_samplerate_mode;\n    uint8_t saved_stop_freq, saved_freq_scale;\n    uint8_t saved_alter_scale, saved_xover_band;\n\n#if (defined(PS_DEC) || defined(DRM_PS))\n    if (psResetFlag)\n        sbr->psResetFlag = psResetFlag;\n#endif\n\n#ifdef DRM\n    if (!sbr->Is_DRM_SBR)\n#endif\n    {\n        uint8_t bs_extension_type = (uint8_t)faad_getbits(ld, 4\n            DEBUGVAR(1,198,\"sbr_bitstream(): bs_extension_type\"));\n\n        if (bs_extension_type == EXT_SBR_DATA_CRC)\n        {\n            sbr->bs_sbr_crc_bits = (uint16_t)faad_getbits(ld, 10\n                DEBUGVAR(1,199,\"sbr_bitstream(): bs_sbr_crc_bits\"));\n        }\n    }\n\n    /* save old header values, in case the new ones are corrupted */\n    saved_start_freq = sbr->bs_start_freq;\n    saved_samplerate_mode = sbr->bs_samplerate_mode;\n    saved_stop_freq = sbr->bs_stop_freq;\n    saved_freq_scale = sbr->bs_freq_scale;\n    saved_alter_scale = sbr->bs_alter_scale;\n    saved_xover_band = sbr->bs_xover_band;\n\n    sbr->bs_header_flag = faad_get1bit(ld\n        DEBUGVAR(1,200,\"sbr_bitstream(): bs_header_flag\"));\n\n    if (sbr->bs_header_flag)\n        sbr_header(ld, sbr);\n\n    /* Reset? */\n    sbr_reset(sbr);\n\n    /* first frame should have a header */\n    //if (!(sbr->frame == 0 && sbr->bs_header_flag == 0))\n    if (sbr->header_count != 0)\n    {\n        if (sbr->Reset || (sbr->bs_header_flag && sbr->just_seeked))\n        {\n            uint8_t rt = calc_sbr_tables(sbr, sbr->bs_start_freq, sbr->bs_stop_freq,\n                sbr->bs_samplerate_mode, sbr->bs_freq_scale,\n                sbr->bs_alter_scale, sbr->bs_xover_band);\n\n            /* if an error occured with the new header values revert to the old ones */\n            if (rt > 0)\n            {\n                result += calc_sbr_tables(sbr, saved_start_freq, saved_stop_freq,\n                    saved_samplerate_mode, saved_freq_scale,\n                    saved_alter_scale, saved_xover_band);\n            }\n        }\n\n        if (result == 0)\n        {\n            result = sbr_data(ld, sbr);\n\n            /* sbr_data() returning an error means that there was an error in\n               envelope_time_border_vector().\n               In this case the old time border vector is saved and all the previous\n               data normally read after sbr_grid() is saved.\n            */\n            /* to be on the safe side, calculate old sbr tables in case of error */\n            if ((result > 0) &&\n                (sbr->Reset || (sbr->bs_header_flag && sbr->just_seeked)))\n            {\n                result += calc_sbr_tables(sbr, saved_start_freq, saved_stop_freq,\n                    saved_samplerate_mode, saved_freq_scale,\n                    saved_alter_scale, saved_xover_band);          \n            }\n\n            /* we should be able to safely set result to 0 now, */\n            /* but practise indicates this doesn't work well */\n        }\n    } else {\n        result = 1;\n    }\n\n    num_sbr_bits2 = (uint16_t)faad_get_processed_bits(ld) - num_sbr_bits1;\n\n    /* check if we read more bits then were available for sbr */\n    if (8*cnt < num_sbr_bits2)\n    {\n        faad_resetbits(ld, num_sbr_bits1 + 8*cnt);\n        num_sbr_bits2 = 8*cnt;\n\n#ifdef PS_DEC\n        /* turn off PS for the unfortunate case that we randomly read some\n         * PS data that looks correct */\n        sbr->ps_used = 0;\n#endif\n\n        /* Make sure it doesn't decode SBR in this frame, or we'll get glitches */\n        return 1;\n    }\n\n#ifdef DRM\n    if (!sbr->Is_DRM_SBR)\n#endif\n    {       \n        /* -4 does not apply, bs_extension_type is re-read in this function */\n        num_align_bits = 8*cnt /*- 4*/ - num_sbr_bits2;\n\n        while (num_align_bits > 7)\n        {\n            faad_getbits(ld, 8\n                DEBUGVAR(1,999,\"sbr_bitstream(): num_align_bits\"));\n            num_align_bits -= 8;\n        }\n        faad_getbits(ld, num_align_bits\n            DEBUGVAR(1,999,\"sbr_bitstream(): num_align_bits\"));\n    }\n\n    return result;\n}",
  "abstract_func": "uint8_t sbr_extension_data(bitfile *VAR_0, sbr_info *VAR_1, uint16_t VAR_2,\n                           uint8_t VAR_3)\n{\n    uint8_t VAR_4 = 0;\n    uint16_t VAR_5 = 0;\n    uint16_t VAR_6 = (uint16_t)faad_get_processed_bits(VAR_0);\n    uint16_t VAR_7;\n\n    uint8_t VAR_8, VAR_9;\n    uint8_t VAR_10, VAR_11;\n    uint8_t VAR_12, VAR_13;\n\n#if (defined(VAR_14) || defined(VAR_15))\n    if (VAR_3)\n        VAR_1->psResetFlag = VAR_3;\n#endif\n\n#ifdef VAR_16\n    if (!VAR_1->Is_DRM_SBR)\n#endif\n    {\n        uint8_t VAR_17 = (uint8_t)faad_getbits(VAR_0, 4\n            DEBUGVAR(1,198,\"sbr_bitstream(): bs_extension_type\"));\n\n        if (VAR_17 == VAR_18)\n        {\n            VAR_1->bs_sbr_crc_bits = (uint16_t)faad_getbits(VAR_0, 10\n                DEBUGVAR(1,199,\"sbr_bitstream(): bs_sbr_crc_bits\"));\n        }\n    }\n\n    /* COMMENT_0 */\n    VAR_8 = VAR_1->bs_start_freq;\n    VAR_9 = VAR_1->bs_samplerate_mode;\n    VAR_10 = VAR_1->bs_stop_freq;\n    VAR_11 = VAR_1->bs_freq_scale;\n    VAR_12 = VAR_1->bs_alter_scale;\n    VAR_13 = VAR_1->bs_xover_band;\n\n    VAR_1->bs_header_flag = faad_get1bit(VAR_0\n        DEBUGVAR(1,200,\"sbr_bitstream(): bs_header_flag\"));\n\n    if (VAR_1->bs_header_flag)\n        sbr_header(VAR_0, VAR_1);\n\n    /* COMMENT_1 */\n    sbr_reset(VAR_1);\n\n    /* COMMENT_2 */\n    /* COMMENT_3 */\n    if (VAR_1->header_count != 0)\n    {\n        if (VAR_1->Reset || (VAR_1->bs_header_flag && VAR_1->just_seeked))\n        {\n            uint8_t VAR_19 = calc_sbr_tables(VAR_1, VAR_1->bs_start_freq, VAR_1->bs_stop_freq,\n                VAR_1->bs_samplerate_mode, VAR_1->bs_freq_scale,\n                VAR_1->bs_alter_scale, VAR_1->bs_xover_band);\n\n            /* COMMENT_4 */\n            if (VAR_19 > 0)\n            {\n                VAR_4 += calc_sbr_tables(VAR_1, VAR_8, VAR_10,\n                    VAR_9, VAR_11,\n                    VAR_12, VAR_13);\n            }\n        }\n\n        if (VAR_4 == 0)\n        {\n            VAR_4 = sbr_data(VAR_0, VAR_1);\n\n            /* COMMENT_5 */\n                                             \n                                                                                    \n                                                            \n              \n            /* COMMENT_10 */\n            if ((VAR_4 > 0) &&\n                (VAR_1->Reset || (VAR_1->bs_header_flag && VAR_1->just_seeked)))\n            {\n                VAR_4 += calc_sbr_tables(VAR_1, VAR_8, VAR_10,\n                    VAR_9, VAR_11,\n                    VAR_12, VAR_13);          \n            }\n\n            /* COMMENT_11 */\n            /* COMMENT_12 */\n        }\n    } else {\n        VAR_4 = 1;\n    }\n\n    VAR_7 = (uint16_t)faad_get_processed_bits(VAR_0) - VAR_6;\n\n    /* COMMENT_13 */\n    if (8*VAR_2 < VAR_7)\n    {\n        faad_resetbits(VAR_0, VAR_6 + 8*VAR_2);\n        VAR_7 = 8*VAR_2;\n\n#ifdef VAR_14\n        /* COMMENT_14 */\n                                        \n        VAR_1->ps_used = 0;\n#endif\n\n        /* COMMENT_16 */\n        return 1;\n    }\n\n#ifdef VAR_16\n    if (!VAR_1->Is_DRM_SBR)\n#endif\n    {       \n        /* COMMENT_17 */\n        VAR_5 = 8*VAR_2 /* COMMENT_18 */ - VAR_7;\n\n        while (VAR_5 > 7)\n        {\n            faad_getbits(VAR_0, 8\n                DEBUGVAR(1,999,\"sbr_bitstream(): num_align_bits\"));\n            VAR_5 -= 8;\n        }\n        faad_getbits(VAR_0, VAR_5\n            DEBUGVAR(1,999,\"sbr_bitstream(): num_align_bits\"));\n    }\n\n    return VAR_4;\n}",
  "func_graph_path": "knik0/faad2/6aeeaa1af0caf986daf22852a97f7c13c5edd879/sbr_syntax.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -59,7 +59,7 @@\n             /* if an error occured with the new header values revert to the old ones */\n             if (rt > 0)\n             {\n-                calc_sbr_tables(sbr, saved_start_freq, saved_stop_freq,\n+                result += calc_sbr_tables(sbr, saved_start_freq, saved_stop_freq,\n                     saved_samplerate_mode, saved_freq_scale,\n                     saved_alter_scale, saved_xover_band);\n             }\n@@ -78,7 +78,7 @@\n             if ((result > 0) &&\n                 (sbr->Reset || (sbr->bs_header_flag && sbr->just_seeked)))\n             {\n-                calc_sbr_tables(sbr, saved_start_freq, saved_stop_freq,\n+                result += calc_sbr_tables(sbr, saved_start_freq, saved_stop_freq,\n                     saved_samplerate_mode, saved_freq_scale,\n                     saved_alter_scale, saved_xover_band);          \n             }",
  "diff_line_info": {
    "deleted_lines": [
      "                calc_sbr_tables(sbr, saved_start_freq, saved_stop_freq,",
      "                calc_sbr_tables(sbr, saved_start_freq, saved_stop_freq,"
    ],
    "added_lines": [
      "                result += calc_sbr_tables(sbr, saved_start_freq, saved_stop_freq,",
      "                result += calc_sbr_tables(sbr, saved_start_freq, saved_stop_freq,"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/knik0/faad2/pull/36",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/knik0/faad2/pull/36: 403 Client Error: Forbidden for url: https://api.github.com/repos/knik0/faad2/pulls/36",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95  \n\n**Explanation:**  \nThe commit message explicitly addresses a security vulnerability related to out-of-bounds accesses, referencing CVE-2018-20196. The code changes enforce bounds checking and error handling, confirming the security fix."
}