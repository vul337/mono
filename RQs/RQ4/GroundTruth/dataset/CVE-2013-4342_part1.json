{
  "cve_id": "CVE-2013-4342",
  "cwe_ids": [
    "CWE-264"
  ],
  "cvss_vector": "AV:N/AC:H/Au:N/C:C/I:C/A:C",
  "cvss_is_v3": false,
  "repo_name": "xinetd-org/xinetd",
  "commit_msg": "CVE-2013-4342: xinetd: ignores user and group directives for TCPMUX services\n\nOriginally reported to Debian in 2005 <http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=324678> and rediscovered <https://bugzilla.redhat.com/show_bug.cgi?id=1006100>, xinetd would execute TCPMUX services without dropping privilege to match the service configuration allowing the service to run with same privilege as the xinetd process (root).",
  "commit_hash": "91e2401a219121eae15244a6b25d2e79c1af5864",
  "git_url": "https://github.com/xinetd-org/xinetd/commit/91e2401a219121eae15244a6b25d2e79c1af5864",
  "file_path": "xinetd/builtins.c",
  "func_name": "tcpmux_handler",
  "func_before": "static void tcpmux_handler( const struct server *serp )\n{\n   char      svc_name[ BUFFER_SIZE ] ;\n   int       cc ;\n   int       descriptor = SERVER_FD( serp ) ;\n   const     struct service *svc = SERVER_SERVICE( serp ) ;\n   unsigned  u;\n   struct    service *sp = NULL;\n   struct    server server, *nserp;\n   struct    service_config *scp = NULL;\n\n   close_all_svc_descriptors();\n\n   /*  Read in the name of the service in the format \"svc_name\\r\\n\".\n    *\n    *  XXX: should loop on partial reads (could probably use Sread() if\n    *  it wasn't thrown out of xinetd source code a few revisions back).\n    */\n   do\n   {\n      cc = read( descriptor, svc_name, sizeof( svc_name ) ) ;\n   } while (cc == -1 && errno == EINTR);\n\n   if ( cc <= 0 )\n   {\n      msg(LOG_ERR, \"tcpmux_handler\", \"read failed\");\n      exit(0);\n   }\n\n   if ( ( cc <= 2 ) ||\n        ( ( svc_name[cc - 1] != '\\n' ) || ( svc_name[cc - 2] != '\\r' ) ) )\n   {\n      if ( debug.on )\n         msg(LOG_DEBUG, \"tcpmux_handler\", \"Invalid service name format.\");\n      \n      exit(0);\n   }\n\n   svc_name[cc - 2] = '\\0';  /*  Remove \\r\\n for compare */\n\n   if ( debug.on )\n   {\n      msg(LOG_DEBUG, \"tcpmux_handler\", \"Input (%d bytes) %s as service name.\",\n          cc, svc_name);\n   }\n\n   /*  Search the services for the a match on name.\n    */\n\n   for ( u = 0 ; u < pset_count( SERVICES( ps ) ) ; u++ )\n   {\n      sp = SP( pset_pointer( SERVICES( ps ), u ) ) ;\n\n      if ( strcasecmp( svc_name, SC_NAME( SVC_CONF( sp ) ) ) == 0 )\n      {\n         /*  Found the pointer. Validate its type.\n          */\n         scp = SVC_CONF( sp );\n\n         if ( ! SVC_IS_MUXCLIENT( sp ) && ! SVC_IS_MUXPLUSCLIENT( sp ) )\n         {\n            if ( debug.on )\n            {\n               msg(LOG_DEBUG, \"tcpmux_handler\", \"Non-tcpmux service name: %s.\",\n                   svc_name);\n            }\n            continue;\n         }\n\n         /*  Send the accept string if we're a PLUS (+) client.\n          */\n\n         if ( SVC_IS_MUXPLUSCLIENT( sp ) )\n         {\n            if ( Swrite( descriptor, TCPMUX_ACK, sizeof( TCPMUX_ACK ) ) !=\n                 sizeof( TCPMUX_ACK ) )\n            {\n                msg(LOG_ERR, \"tcpmux_handler\", \"Ack write failed for %s.\",\n\t\t    svc_name);\n                exit(0);\n            }\n         }\n         break;  /*  Time to get on with the service */\n      }\n      continue;  /*  Keep looking */\n   }\n\n   if ( u >= pset_count( SERVICES( ps ) ) )\n   {\n      if ( debug.on )\n      {\n         msg(LOG_DEBUG, \"tcpmux_handler\", \"Service name %s not found.\",\n             svc_name);\n      }\n\n      /*  If a service was not found, we should say so. */\n      if ( Swrite( descriptor, TCPMUX_NOT_FOUND, sizeof( TCPMUX_NOT_FOUND ) ) !=\n           sizeof ( TCPMUX_NOT_FOUND ) )\n      {\n         msg(LOG_ERR, \"tcpmux_handler\", \"Not found write failed for %s.\",\n             svc_name);\n         exit(0);\n      }\n       \n      /*  Flush and exit, nothing to do */\n      Sflush( descriptor );\n      Sclose( descriptor );\n      exit(0);\n   }\n\n   if( SVC_WAITS( svc ) ) /* Service forks, so close it */\n      Sclose(descriptor);\n\n   server.svr_sp = sp;\n   server.svr_conn = SERVER_CONNECTION(serp);\n   nserp = server_alloc(&server);\n   if( SC_IS_INTERNAL( scp ) ) {\n      SC_INTERNAL(scp, nserp);\n   } else {\n      exec_server(nserp);\n   }\n}",
  "abstract_func_before": "static void tcpmux_handler( const struct server *VAR_0 )\n{\n   char      VAR_1[ VAR_2 ] ;\n   int       VAR_3 ;\n   int       VAR_4 = SERVER_FD( VAR_0 ) ;\n   const     struct service *VAR_5 = SERVER_SERVICE( VAR_0 ) ;\n   unsigned  VAR_6;\n   struct    service *VAR_7 = NULL;\n   struct    server server, *VAR_8;\n   struct    service_config *VAR_9 = NULL;\n\n   close_all_svc_descriptors();\n\n   /* COMMENT_0 */\n     \n                                                                       \n                                                                        \n      \n   do\n   {\n      VAR_3 = read( VAR_4, VAR_1, sizeof( VAR_1 ) ) ;\n   } while (VAR_3 == -1 && VAR_10 == VAR_11);\n\n   if ( VAR_3 <= 0 )\n   {\n      msg(VAR_12, \"tcpmux_handler\", \"read failed\");\n      exit(0);\n   }\n\n   if ( ( VAR_3 <= 2 ) ||\n        ( ( VAR_1[VAR_3 - 1] != '\\n' ) || ( VAR_1[VAR_3 - 2] != '\\r' ) ) )\n   {\n      if ( VAR_13.on )\n         msg(VAR_14, \"tcpmux_handler\", \"Invalid service name format.\");\n      \n      exit(0);\n   }\n\n   VAR_1[VAR_3 - 2] = '\\0';  /* COMMENT_5 */\n\n   if ( VAR_13.on )\n   {\n      msg(VAR_14, \"tcpmux_handler\", \"Input (%d bytes) %s as service name.\",\n          VAR_3, VAR_1);\n   }\n\n   /* COMMENT_6 */\n      \n\n   for ( VAR_6 = 0 ; VAR_6 < pset_count( SERVICES( VAR_15 ) ) ; VAR_6++ )\n   {\n      VAR_7 = SP( pset_pointer( SERVICES( VAR_15 ), VAR_6 ) ) ;\n\n      if ( strcasecmp( VAR_1, SC_NAME( SVC_CONF( VAR_7 ) ) ) == 0 )\n      {\n         /* COMMENT_8 */\n            \n         VAR_9 = SVC_CONF( VAR_7 );\n\n         if ( ! SVC_IS_MUXCLIENT( VAR_7 ) && ! SVC_IS_MUXPLUSCLIENT( VAR_7 ) )\n         {\n            if ( VAR_13.on )\n            {\n               msg(VAR_14, \"tcpmux_handler\", \"Non-tcpmux service name: %s.\",\n                   VAR_1);\n            }\n            continue;\n         }\n\n         /* COMMENT_10 */\n            \n\n         if ( SVC_IS_MUXPLUSCLIENT( VAR_7 ) )\n         {\n            if ( Swrite( VAR_4, VAR_16, sizeof( VAR_16 ) ) !=\n                 sizeof( VAR_16 ) )\n            {\n                msg(VAR_12, \"tcpmux_handler\", \"Ack write failed for %s.\",\n\t\t    VAR_1);\n                exit(0);\n            }\n         }\n         break;  /* COMMENT_12 */\n      }\n      continue;  /* COMMENT_13 */\n   }\n\n   if ( VAR_6 >= pset_count( SERVICES( VAR_15 ) ) )\n   {\n      if ( VAR_13.on )\n      {\n         msg(VAR_14, \"tcpmux_handler\", \"Service name %s not found.\",\n             VAR_1);\n      }\n\n      /* COMMENT_14 */\n      if ( Swrite( VAR_4, VAR_17, sizeof( VAR_17 ) ) !=\n           sizeof ( VAR_17 ) )\n      {\n         msg(VAR_12, \"tcpmux_handler\", \"Not found write failed for %s.\",\n             VAR_1);\n         exit(0);\n      }\n       \n      /* COMMENT_15 */\n      Sflush( VAR_4 );\n      Sclose( VAR_4 );\n      exit(0);\n   }\n\n   if( SVC_WAITS( VAR_5 ) ) /* COMMENT_16 */\n      Sclose(VAR_4);\n\n   server.svr_sp = VAR_7;\n   server.svr_conn = SERVER_CONNECTION(VAR_0);\n   VAR_8 = server_alloc(&server);\n   if( SC_IS_INTERNAL( VAR_9 ) ) {\n      SC_INTERNAL(VAR_9, VAR_8);\n   } else {\n      exec_server(VAR_8);\n   }\n}",
  "func_graph_path_before": "xinetd-org/xinetd/91e2401a219121eae15244a6b25d2e79c1af5864/builtins.c/vul/before/0.json",
  "func": "static void tcpmux_handler( const struct server *serp )\n{\n   char      svc_name[ BUFFER_SIZE ] ;\n   int       cc ;\n   int       descriptor = SERVER_FD( serp ) ;\n   const     struct service *svc = SERVER_SERVICE( serp ) ;\n   unsigned  u;\n   struct    service *sp = NULL;\n   struct    server server, *nserp;\n   struct    service_config *scp = NULL;\n\n   close_all_svc_descriptors();\n\n   /*  Read in the name of the service in the format \"svc_name\\r\\n\".\n    *\n    *  XXX: should loop on partial reads (could probably use Sread() if\n    *  it wasn't thrown out of xinetd source code a few revisions back).\n    */\n   do\n   {\n      cc = read( descriptor, svc_name, sizeof( svc_name ) ) ;\n   } while (cc == -1 && errno == EINTR);\n\n   if ( cc <= 0 )\n   {\n      msg(LOG_ERR, \"tcpmux_handler\", \"read failed\");\n      exit(0);\n   }\n\n   if ( ( cc <= 2 ) ||\n        ( ( svc_name[cc - 1] != '\\n' ) || ( svc_name[cc - 2] != '\\r' ) ) )\n   {\n      if ( debug.on )\n         msg(LOG_DEBUG, \"tcpmux_handler\", \"Invalid service name format.\");\n      \n      exit(0);\n   }\n\n   svc_name[cc - 2] = '\\0';  /*  Remove \\r\\n for compare */\n\n   if ( debug.on )\n   {\n      msg(LOG_DEBUG, \"tcpmux_handler\", \"Input (%d bytes) %s as service name.\",\n          cc, svc_name);\n   }\n\n   /*  Search the services for the a match on name.\n    */\n\n   for ( u = 0 ; u < pset_count( SERVICES( ps ) ) ; u++ )\n   {\n      sp = SP( pset_pointer( SERVICES( ps ), u ) ) ;\n\n      if ( strcasecmp( svc_name, SC_NAME( SVC_CONF( sp ) ) ) == 0 )\n      {\n         /*  Found the pointer. Validate its type.\n          */\n         scp = SVC_CONF( sp );\n\n         if ( ! SVC_IS_MUXCLIENT( sp ) && ! SVC_IS_MUXPLUSCLIENT( sp ) )\n         {\n            if ( debug.on )\n            {\n               msg(LOG_DEBUG, \"tcpmux_handler\", \"Non-tcpmux service name: %s.\",\n                   svc_name);\n            }\n            continue;\n         }\n\n         /*  Send the accept string if we're a PLUS (+) client.\n          */\n\n         if ( SVC_IS_MUXPLUSCLIENT( sp ) )\n         {\n            if ( Swrite( descriptor, TCPMUX_ACK, sizeof( TCPMUX_ACK ) ) !=\n                 sizeof( TCPMUX_ACK ) )\n            {\n                msg(LOG_ERR, \"tcpmux_handler\", \"Ack write failed for %s.\",\n\t\t    svc_name);\n                exit(0);\n            }\n         }\n         break;  /*  Time to get on with the service */\n      }\n      continue;  /*  Keep looking */\n   }\n\n   if ( u >= pset_count( SERVICES( ps ) ) )\n   {\n      if ( debug.on )\n      {\n         msg(LOG_DEBUG, \"tcpmux_handler\", \"Service name %s not found.\",\n             svc_name);\n      }\n\n      /*  If a service was not found, we should say so. */\n      if ( Swrite( descriptor, TCPMUX_NOT_FOUND, sizeof( TCPMUX_NOT_FOUND ) ) !=\n           sizeof ( TCPMUX_NOT_FOUND ) )\n      {\n         msg(LOG_ERR, \"tcpmux_handler\", \"Not found write failed for %s.\",\n             svc_name);\n         exit(0);\n      }\n       \n      /*  Flush and exit, nothing to do */\n      Sflush( descriptor );\n      Sclose( descriptor );\n      exit(0);\n   }\n\n   if( SVC_WAITS( svc ) ) /* Service forks, so close it */\n      Sclose(descriptor);\n\n   server.svr_sp = sp;\n   server.svr_conn = SERVER_CONNECTION(serp);\n   nserp = server_alloc(&server);\n   if( SC_IS_INTERNAL( scp ) ) {\n      SC_INTERNAL(scp, nserp);\n   } else {\n      child_process(nserp);\n   }\n}",
  "abstract_func": "static void tcpmux_handler( const struct server *VAR_0 )\n{\n   char      VAR_1[ VAR_2 ] ;\n   int       VAR_3 ;\n   int       VAR_4 = SERVER_FD( VAR_0 ) ;\n   const     struct service *VAR_5 = SERVER_SERVICE( VAR_0 ) ;\n   unsigned  VAR_6;\n   struct    service *VAR_7 = NULL;\n   struct    server server, *VAR_8;\n   struct    service_config *VAR_9 = NULL;\n\n   close_all_svc_descriptors();\n\n   /* COMMENT_0 */\n     \n                                                                       \n                                                                        \n      \n   do\n   {\n      VAR_3 = read( VAR_4, VAR_1, sizeof( VAR_1 ) ) ;\n   } while (VAR_3 == -1 && VAR_10 == VAR_11);\n\n   if ( VAR_3 <= 0 )\n   {\n      msg(VAR_12, \"tcpmux_handler\", \"read failed\");\n      exit(0);\n   }\n\n   if ( ( VAR_3 <= 2 ) ||\n        ( ( VAR_1[VAR_3 - 1] != '\\n' ) || ( VAR_1[VAR_3 - 2] != '\\r' ) ) )\n   {\n      if ( VAR_13.on )\n         msg(VAR_14, \"tcpmux_handler\", \"Invalid service name format.\");\n      \n      exit(0);\n   }\n\n   VAR_1[VAR_3 - 2] = '\\0';  /* COMMENT_5 */\n\n   if ( VAR_13.on )\n   {\n      msg(VAR_14, \"tcpmux_handler\", \"Input (%d bytes) %s as service name.\",\n          VAR_3, VAR_1);\n   }\n\n   /* COMMENT_6 */\n      \n\n   for ( VAR_6 = 0 ; VAR_6 < pset_count( SERVICES( VAR_15 ) ) ; VAR_6++ )\n   {\n      VAR_7 = SP( pset_pointer( SERVICES( VAR_15 ), VAR_6 ) ) ;\n\n      if ( strcasecmp( VAR_1, SC_NAME( SVC_CONF( VAR_7 ) ) ) == 0 )\n      {\n         /* COMMENT_8 */\n            \n         VAR_9 = SVC_CONF( VAR_7 );\n\n         if ( ! SVC_IS_MUXCLIENT( VAR_7 ) && ! SVC_IS_MUXPLUSCLIENT( VAR_7 ) )\n         {\n            if ( VAR_13.on )\n            {\n               msg(VAR_14, \"tcpmux_handler\", \"Non-tcpmux service name: %s.\",\n                   VAR_1);\n            }\n            continue;\n         }\n\n         /* COMMENT_10 */\n            \n\n         if ( SVC_IS_MUXPLUSCLIENT( VAR_7 ) )\n         {\n            if ( Swrite( VAR_4, VAR_16, sizeof( VAR_16 ) ) !=\n                 sizeof( VAR_16 ) )\n            {\n                msg(VAR_12, \"tcpmux_handler\", \"Ack write failed for %s.\",\n\t\t    VAR_1);\n                exit(0);\n            }\n         }\n         break;  /* COMMENT_12 */\n      }\n      continue;  /* COMMENT_13 */\n   }\n\n   if ( VAR_6 >= pset_count( SERVICES( VAR_15 ) ) )\n   {\n      if ( VAR_13.on )\n      {\n         msg(VAR_14, \"tcpmux_handler\", \"Service name %s not found.\",\n             VAR_1);\n      }\n\n      /* COMMENT_14 */\n      if ( Swrite( VAR_4, VAR_17, sizeof( VAR_17 ) ) !=\n           sizeof ( VAR_17 ) )\n      {\n         msg(VAR_12, \"tcpmux_handler\", \"Not found write failed for %s.\",\n             VAR_1);\n         exit(0);\n      }\n       \n      /* COMMENT_15 */\n      Sflush( VAR_4 );\n      Sclose( VAR_4 );\n      exit(0);\n   }\n\n   if( SVC_WAITS( VAR_5 ) ) /* COMMENT_16 */\n      Sclose(VAR_4);\n\n   server.svr_sp = VAR_7;\n   server.svr_conn = SERVER_CONNECTION(VAR_0);\n   VAR_8 = server_alloc(&server);\n   if( SC_IS_INTERNAL( VAR_9 ) ) {\n      SC_INTERNAL(VAR_9, VAR_8);\n   } else {\n      child_process(VAR_8);\n   }\n}",
  "func_graph_path": "xinetd-org/xinetd/91e2401a219121eae15244a6b25d2e79c1af5864/builtins.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -117,6 +117,6 @@\n    if( SC_IS_INTERNAL( scp ) ) {\n       SC_INTERNAL(scp, nserp);\n    } else {\n-      exec_server(nserp);\n+      child_process(nserp);\n    }\n }",
  "diff_line_info": {
    "deleted_lines": [
      "      exec_server(nserp);"
    ],
    "added_lines": [
      "      child_process(nserp);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/xinetd-org/xinetd/pull/10",
  "description": {
    "pr_info": {
      "title": "CVE-2013-4342: xinetd ignores user and group directives for TCPMUX services",
      "number": 10
    },
    "comment": [
      "Originally reported to Debian in 2005 http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=324678 and rediscovered https://bugzilla.redhat.com/show_bug.cgi?id=1006100, xinetd would execute configured TCPMUX services without dropping privilege to match the service configuration allowing the service to run with same privilege as the xinetd process (root).\n",
      "Does SUSE Linux Enterprise Server 10 SP2 is affected by the vulnerability?\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}