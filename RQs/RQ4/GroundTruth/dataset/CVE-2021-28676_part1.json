{
  "cve_id": "CVE-2021-28676",
  "cwe_ids": [
    "CWE-835"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "python-pillow/Pillow",
  "commit_msg": "Fix FLI DOS -- CVE-2021-28676\n\n* FliDecode did not properly check that the block advance was\n  non-zero, potentally leading to an infinite loop on load.\n* This dates to the PIL Fork\n* Found with oss-fuzz",
  "commit_hash": "bb6c11fb889e6c11b0ee122b828132ee763b5856",
  "git_url": "https://github.com/python-pillow/Pillow/commit/bb6c11fb889e6c11b0ee122b828132ee763b5856",
  "file_path": "src/libImaging/FliDecode.c",
  "func_name": "ImagingFliDecode",
  "func_before": "int\nImagingFliDecode(Imaging im, ImagingCodecState state, UINT8 *buf, Py_ssize_t bytes) {\n    UINT8 *ptr;\n    int framesize;\n    int c, chunks, advance;\n    int l, lines;\n    int i, j, x = 0, y, ymax;\n\n    /* If not even the chunk size is present, we'd better leave */\n\n    if (bytes < 4) {\n        return 0;\n    }\n\n    /* We don't decode anything unless we have a full chunk in the\n       input buffer */\n\n    ptr = buf;\n\n    framesize = I32(ptr);\n    if (framesize < I32(ptr)) {\n        return 0;\n    }\n\n    /* Make sure this is a frame chunk.  The Python driver takes\n       case of other chunk types. */\n\n    if (bytes < 8) {\n        state->errcode = IMAGING_CODEC_OVERRUN;\n        return -1;\n    }\n    if (I16(ptr + 4) != 0xF1FA) {\n        state->errcode = IMAGING_CODEC_UNKNOWN;\n        return -1;\n    }\n\n    chunks = I16(ptr + 6);\n    ptr += 16;\n    bytes -= 16;\n\n    /* Process subchunks */\n    for (c = 0; c < chunks; c++) {\n        UINT8 *data;\n        if (bytes < 10) {\n            state->errcode = IMAGING_CODEC_OVERRUN;\n            return -1;\n        }\n        data = ptr + 6;\n        switch (I16(ptr + 4)) {\n            case 4:\n            case 11:\n                /* FLI COLOR chunk */\n                break; /* ignored; handled by Python code */\n            case 7:\n                /* FLI SS2 chunk (word delta) */\n                /* OOB ok, we've got 4 bytes min on entry */\n                lines = I16(data);\n                data += 2;\n                for (l = y = 0; l < lines && y < state->ysize; l++, y++) {\n                    UINT8 *local_buf = (UINT8 *)im->image[y];\n                    int p, packets;\n                    ERR_IF_DATA_OOB(2)\n                    packets = I16(data);\n                    data += 2;\n                    while (packets & 0x8000) {\n                        /* flag word */\n                        if (packets & 0x4000) {\n                            y += 65536 - packets; /* skip lines */\n                            if (y >= state->ysize) {\n                                state->errcode = IMAGING_CODEC_OVERRUN;\n                                return -1;\n                            }\n                            local_buf = (UINT8 *)im->image[y];\n                        } else {\n                            /* store last byte (used if line width is odd) */\n                            local_buf[state->xsize - 1] = (UINT8)packets;\n                        }\n                        ERR_IF_DATA_OOB(2)\n                        packets = I16(data);\n                        data += 2;\n                    }\n                    for (p = x = 0; p < packets; p++) {\n                        ERR_IF_DATA_OOB(2)\n                        x += data[0]; /* pixel skip */\n                        if (data[1] >= 128) {\n                            ERR_IF_DATA_OOB(4)\n                            i = 256 - data[1]; /* run */\n                            if (x + i + i > state->xsize) {\n                                break;\n                            }\n                            for (j = 0; j < i; j++) {\n                                local_buf[x++] = data[2];\n                                local_buf[x++] = data[3];\n                            }\n                            data += 2 + 2;\n                        } else {\n                            i = 2 * (int)data[1]; /* chunk */\n                            if (x + i > state->xsize) {\n                                break;\n                            }\n                            ERR_IF_DATA_OOB(2 + i)\n                            memcpy(local_buf + x, data + 2, i);\n                            data += 2 + i;\n                            x += i;\n                        }\n                    }\n                    if (p < packets) {\n                        break; /* didn't process all packets */\n                    }\n                }\n                if (l < lines) {\n                    /* didn't process all lines */\n                    state->errcode = IMAGING_CODEC_OVERRUN;\n                    return -1;\n                }\n                break;\n            case 12:\n                /* FLI LC chunk (byte delta) */\n                /* OOB Check ok, we have 4 bytes min here */\n                y = I16(data);\n                ymax = y + I16(data + 2);\n                data += 4;\n                for (; y < ymax && y < state->ysize; y++) {\n                    UINT8 *out = (UINT8 *)im->image[y];\n                    ERR_IF_DATA_OOB(1)\n                    int p, packets = *data++;\n                    for (p = x = 0; p < packets; p++, x += i) {\n                        ERR_IF_DATA_OOB(2)\n                        x += data[0]; /* skip pixels */\n                        if (data[1] & 0x80) {\n                            i = 256 - data[1]; /* run */\n                            if (x + i > state->xsize) {\n                                break;\n                            }\n                            ERR_IF_DATA_OOB(3)\n                            memset(out + x, data[2], i);\n                            data += 3;\n                        } else {\n                            i = data[1]; /* chunk */\n                            if (x + i > state->xsize) {\n                                break;\n                            }\n                            ERR_IF_DATA_OOB(2 + i)\n                            memcpy(out + x, data + 2, i);\n                            data += i + 2;\n                        }\n                    }\n                    if (p < packets) {\n                        break; /* didn't process all packets */\n                    }\n                }\n                if (y < ymax) {\n                    /* didn't process all lines */\n                    state->errcode = IMAGING_CODEC_OVERRUN;\n                    return -1;\n                }\n                break;\n            case 13:\n                /* FLI BLACK chunk */\n                for (y = 0; y < state->ysize; y++) {\n                    memset(im->image[y], 0, state->xsize);\n                }\n                break;\n            case 15:\n                /* FLI BRUN chunk */\n                /* OOB, ok, we've got 4 bytes min on entry */\n                for (y = 0; y < state->ysize; y++) {\n                    UINT8 *out = (UINT8 *)im->image[y];\n                    data += 1; /* ignore packetcount byte */\n                    for (x = 0; x < state->xsize; x += i) {\n                        ERR_IF_DATA_OOB(2)\n                        if (data[0] & 0x80) {\n                            i = 256 - data[0];\n                            if (x + i > state->xsize) {\n                                break; /* safety first */\n                            }\n                            ERR_IF_DATA_OOB(i + 1)\n                            memcpy(out + x, data + 1, i);\n                            data += i + 1;\n                        } else {\n                            i = data[0];\n                            if (x + i > state->xsize) {\n                                break; /* safety first */\n                            }\n                            memset(out + x, data[1], i);\n                            data += 2;\n                        }\n                    }\n                    if (x != state->xsize) {\n                        /* didn't unpack whole line */\n                        state->errcode = IMAGING_CODEC_OVERRUN;\n                        return -1;\n                    }\n                }\n                break;\n            case 16:\n                /* COPY chunk */\n                if (state->xsize > bytes / state->ysize) {\n                    /* not enough data for frame */\n                    return ptr - buf; /* bytes consumed */\n                }\n                for (y = 0; y < state->ysize; y++) {\n                    UINT8 *local_buf = (UINT8 *)im->image[y];\n                    memcpy(local_buf, data, state->xsize);\n                    data += state->xsize;\n                }\n                break;\n            case 18:\n                /* PSTAMP chunk */\n                break; /* ignored */\n            default:\n                /* unknown chunk */\n                /* printf(\"unknown FLI/FLC chunk: %d\\n\", I16(ptr+4)); */\n                state->errcode = IMAGING_CODEC_UNKNOWN;\n                return -1;\n        }\n        advance = I32(ptr);\n        if (advance < 0 || advance > bytes) {\n            state->errcode = IMAGING_CODEC_OVERRUN;\n            return -1;\n        }\n        ptr += advance;\n        bytes -= advance;\n    }\n\n    return -1; /* end of frame */\n}",
  "abstract_func_before": "int\nImagingFliDecode(Imaging VAR_0, ImagingCodecState VAR_1, UINT8 *VAR_2, Py_ssize_t VAR_3) {\n    UINT8 *VAR_4;\n    int VAR_5;\n    int VAR_6, VAR_7, VAR_8;\n    int VAR_9, VAR_10;\n    int VAR_11, VAR_12, VAR_13 = 0, VAR_14, VAR_15;\n\n    /* COMMENT_0 */\n\n    if (VAR_3 < 4) {\n        return 0;\n    }\n\n    /* COMMENT_1 */\n                      \n\n    VAR_4 = VAR_2;\n\n    VAR_5 = I32(VAR_4);\n    if (VAR_5 < I32(VAR_4)) {\n        return 0;\n    }\n\n    /* COMMENT_3 */\n                                    \n\n    if (VAR_3 < 8) {\n        VAR_1->errcode = VAR_16;\n        return -1;\n    }\n    if (I16(VAR_4 + 4) != 0xF1FA) {\n        VAR_1->errcode = VAR_17;\n        return -1;\n    }\n\n    VAR_7 = I16(VAR_4 + 6);\n    VAR_4 += 16;\n    VAR_3 -= 16;\n\n    /* COMMENT_5 */\n    for (VAR_6 = 0; VAR_6 < VAR_7; VAR_6++) {\n        UINT8 *VAR_18;\n        if (VAR_3 < 10) {\n            VAR_1->errcode = VAR_16;\n            return -1;\n        }\n        VAR_18 = VAR_4 + 6;\n        switch (I16(VAR_4 + 4)) {\n            case 4:\n            case 11:\n                /* COMMENT_6 */\n                break; /* COMMENT_7 */\n            case 7:\n                /* COMMENT_8 */\n                /* COMMENT_9 */\n                VAR_10 = I16(VAR_18);\n                VAR_18 += 2;\n                for (VAR_9 = VAR_14 = 0; VAR_9 < VAR_10 && VAR_14 < VAR_1->ysize; VAR_9++, VAR_14++) {\n                    UINT8 *VAR_19 = (UINT8 *)VAR_0->image[VAR_14];\n                    int VAR_20, VAR_21;\n                    ERR_IF_DATA_OOB(2)\n                    VAR_21 = I16(VAR_18);\n                    VAR_18 += 2;\n                    while (VAR_21 & 0x8000) {\n                        /* COMMENT_10 */\n                        if (VAR_21 & 0x4000) {\n                            VAR_14 += 65536 - VAR_21; /* COMMENT_11 */\n                            if (VAR_14 >= VAR_1->ysize) {\n                                VAR_1->errcode = VAR_16;\n                                return -1;\n                            }\n                            VAR_19 = (UINT8 *)VAR_0->image[VAR_14];\n                        } else {\n                            /* COMMENT_12 */\n                            VAR_19[VAR_1->xsize - 1] = (UINT8)VAR_21;\n                        }\n                        ERR_IF_DATA_OOB(2)\n                        VAR_21 = I16(VAR_18);\n                        VAR_18 += 2;\n                    }\n                    for (VAR_20 = VAR_13 = 0; VAR_20 < VAR_21; VAR_20++) {\n                        ERR_IF_DATA_OOB(2)\n                        VAR_13 += VAR_18[0]; /* COMMENT_13 */\n                        if (VAR_18[1] >= 128) {\n                            ERR_IF_DATA_OOB(4)\n                            VAR_11 = 256 - VAR_18[1]; /* COMMENT_14 */\n                            if (VAR_13 + VAR_11 + VAR_11 > VAR_1->xsize) {\n                                break;\n                            }\n                            for (VAR_12 = 0; VAR_12 < VAR_11; VAR_12++) {\n                                VAR_19[VAR_13++] = VAR_18[2];\n                                VAR_19[VAR_13++] = VAR_18[3];\n                            }\n                            VAR_18 += 2 + 2;\n                        } else {\n                            VAR_11 = 2 * (int)VAR_18[1]; /* COMMENT_15 */\n                            if (VAR_13 + VAR_11 > VAR_1->xsize) {\n                                break;\n                            }\n                            ERR_IF_DATA_OOB(2 + VAR_11)\n                            memcpy(VAR_19 + VAR_13, VAR_18 + 2, VAR_11);\n                            VAR_18 += 2 + VAR_11;\n                            VAR_13 += VAR_11;\n                        }\n                    }\n                    if (VAR_20 < VAR_21) {\n                        break; /* COMMENT_16 */\n                    }\n                }\n                if (VAR_9 < VAR_10) {\n                    /* COMMENT_17 */\n                    VAR_1->errcode = VAR_16;\n                    return -1;\n                }\n                break;\n            case 12:\n                /* COMMENT_18 */\n                /* COMMENT_19 */\n                VAR_14 = I16(VAR_18);\n                VAR_15 = VAR_14 + I16(VAR_18 + 2);\n                VAR_18 += 4;\n                for (; VAR_14 < VAR_15 && VAR_14 < VAR_1->ysize; VAR_14++) {\n                    UINT8 *VAR_22 = (UINT8 *)VAR_0->image[VAR_14];\n                    ERR_IF_DATA_OOB(1)\n                    int VAR_20, VAR_21 = *VAR_18++;\n                    for (VAR_20 = VAR_13 = 0; VAR_20 < VAR_21; VAR_20++, VAR_13 += VAR_11) {\n                        ERR_IF_DATA_OOB(2)\n                        VAR_13 += VAR_18[0]; /* COMMENT_20 */\n                        if (VAR_18[1] & 0x80) {\n                            VAR_11 = 256 - VAR_18[1]; /* COMMENT_14 */\n                            if (VAR_13 + VAR_11 > VAR_1->xsize) {\n                                break;\n                            }\n                            ERR_IF_DATA_OOB(3)\n                            memset(VAR_22 + VAR_13, VAR_18[2], VAR_11);\n                            VAR_18 += 3;\n                        } else {\n                            VAR_11 = VAR_18[1]; /* COMMENT_15 */\n                            if (VAR_13 + VAR_11 > VAR_1->xsize) {\n                                break;\n                            }\n                            ERR_IF_DATA_OOB(2 + VAR_11)\n                            memcpy(VAR_22 + VAR_13, VAR_18 + 2, VAR_11);\n                            VAR_18 += VAR_11 + 2;\n                        }\n                    }\n                    if (VAR_20 < VAR_21) {\n                        break; /* COMMENT_16 */\n                    }\n                }\n                if (VAR_14 < VAR_15) {\n                    /* COMMENT_17 */\n                    VAR_1->errcode = VAR_16;\n                    return -1;\n                }\n                break;\n            case 13:\n                /* COMMENT_21 */\n                for (VAR_14 = 0; VAR_14 < VAR_1->ysize; VAR_14++) {\n                    memset(VAR_0->image[VAR_14], 0, VAR_1->xsize);\n                }\n                break;\n            case 15:\n                /* COMMENT_22 */\n                /* COMMENT_23 */\n                for (VAR_14 = 0; VAR_14 < VAR_1->ysize; VAR_14++) {\n                    UINT8 *VAR_22 = (UINT8 *)VAR_0->image[VAR_14];\n                    VAR_18 += 1; /* COMMENT_24 */\n                    for (VAR_13 = 0; VAR_13 < VAR_1->xsize; VAR_13 += VAR_11) {\n                        ERR_IF_DATA_OOB(2)\n                        if (VAR_18[0] & 0x80) {\n                            VAR_11 = 256 - VAR_18[0];\n                            if (VAR_13 + VAR_11 > VAR_1->xsize) {\n                                break; /* COMMENT_25 */\n                            }\n                            ERR_IF_DATA_OOB(VAR_11 + 1)\n                            memcpy(VAR_22 + VAR_13, VAR_18 + 1, VAR_11);\n                            VAR_18 += VAR_11 + 1;\n                        } else {\n                            VAR_11 = VAR_18[0];\n                            if (VAR_13 + VAR_11 > VAR_1->xsize) {\n                                break; /* COMMENT_25 */\n                            }\n                            memset(VAR_22 + VAR_13, VAR_18[1], VAR_11);\n                            VAR_18 += 2;\n                        }\n                    }\n                    if (VAR_13 != VAR_1->xsize) {\n                        /* COMMENT_26 */\n                        VAR_1->errcode = VAR_16;\n                        return -1;\n                    }\n                }\n                break;\n            case 16:\n                /* COMMENT_27 */\n                if (VAR_1->xsize > VAR_3 / VAR_1->ysize) {\n                    /* COMMENT_28 */\n                    return VAR_4 - VAR_2; /* COMMENT_29 */\n                }\n                for (VAR_14 = 0; VAR_14 < VAR_1->ysize; VAR_14++) {\n                    UINT8 *VAR_19 = (UINT8 *)VAR_0->image[VAR_14];\n                    memcpy(VAR_19, VAR_18, VAR_1->xsize);\n                    VAR_18 += VAR_1->xsize;\n                }\n                break;\n            case 18:\n                /* COMMENT_30 */\n                break; /* COMMENT_31 */\n            default:\n                /* COMMENT_32 */\n                /* COMMENT_33 */\n                VAR_1->errcode = VAR_17;\n                return -1;\n        }\n        VAR_8 = I32(VAR_4);\n        if (VAR_8 < 0 || VAR_8 > VAR_3) {\n            VAR_1->errcode = VAR_16;\n            return -1;\n        }\n        VAR_4 += VAR_8;\n        VAR_3 -= VAR_8;\n    }\n\n    return -1; /* COMMENT_34 */\n}",
  "func_graph_path_before": "python-pillow/Pillow/bb6c11fb889e6c11b0ee122b828132ee763b5856/FliDecode.c/vul/before/0.json",
  "func": "int\nImagingFliDecode(Imaging im, ImagingCodecState state, UINT8 *buf, Py_ssize_t bytes) {\n    UINT8 *ptr;\n    int framesize;\n    int c, chunks, advance;\n    int l, lines;\n    int i, j, x = 0, y, ymax;\n\n    /* If not even the chunk size is present, we'd better leave */\n\n    if (bytes < 4) {\n        return 0;\n    }\n\n    /* We don't decode anything unless we have a full chunk in the\n       input buffer */\n\n    ptr = buf;\n\n    framesize = I32(ptr);\n    if (framesize < I32(ptr)) {\n        return 0;\n    }\n\n    /* Make sure this is a frame chunk.  The Python driver takes\n       case of other chunk types. */\n\n    if (bytes < 8) {\n        state->errcode = IMAGING_CODEC_OVERRUN;\n        return -1;\n    }\n    if (I16(ptr + 4) != 0xF1FA) {\n        state->errcode = IMAGING_CODEC_UNKNOWN;\n        return -1;\n    }\n\n    chunks = I16(ptr + 6);\n    ptr += 16;\n    bytes -= 16;\n\n    /* Process subchunks */\n    for (c = 0; c < chunks; c++) {\n        UINT8 *data;\n        if (bytes < 10) {\n            state->errcode = IMAGING_CODEC_OVERRUN;\n            return -1;\n        }\n        data = ptr + 6;\n        switch (I16(ptr + 4)) {\n            case 4:\n            case 11:\n                /* FLI COLOR chunk */\n                break; /* ignored; handled by Python code */\n            case 7:\n                /* FLI SS2 chunk (word delta) */\n                /* OOB ok, we've got 4 bytes min on entry */\n                lines = I16(data);\n                data += 2;\n                for (l = y = 0; l < lines && y < state->ysize; l++, y++) {\n                    UINT8 *local_buf = (UINT8 *)im->image[y];\n                    int p, packets;\n                    ERR_IF_DATA_OOB(2)\n                    packets = I16(data);\n                    data += 2;\n                    while (packets & 0x8000) {\n                        /* flag word */\n                        if (packets & 0x4000) {\n                            y += 65536 - packets; /* skip lines */\n                            if (y >= state->ysize) {\n                                state->errcode = IMAGING_CODEC_OVERRUN;\n                                return -1;\n                            }\n                            local_buf = (UINT8 *)im->image[y];\n                        } else {\n                            /* store last byte (used if line width is odd) */\n                            local_buf[state->xsize - 1] = (UINT8)packets;\n                        }\n                        ERR_IF_DATA_OOB(2)\n                        packets = I16(data);\n                        data += 2;\n                    }\n                    for (p = x = 0; p < packets; p++) {\n                        ERR_IF_DATA_OOB(2)\n                        x += data[0]; /* pixel skip */\n                        if (data[1] >= 128) {\n                            ERR_IF_DATA_OOB(4)\n                            i = 256 - data[1]; /* run */\n                            if (x + i + i > state->xsize) {\n                                break;\n                            }\n                            for (j = 0; j < i; j++) {\n                                local_buf[x++] = data[2];\n                                local_buf[x++] = data[3];\n                            }\n                            data += 2 + 2;\n                        } else {\n                            i = 2 * (int)data[1]; /* chunk */\n                            if (x + i > state->xsize) {\n                                break;\n                            }\n                            ERR_IF_DATA_OOB(2 + i)\n                            memcpy(local_buf + x, data + 2, i);\n                            data += 2 + i;\n                            x += i;\n                        }\n                    }\n                    if (p < packets) {\n                        break; /* didn't process all packets */\n                    }\n                }\n                if (l < lines) {\n                    /* didn't process all lines */\n                    state->errcode = IMAGING_CODEC_OVERRUN;\n                    return -1;\n                }\n                break;\n            case 12:\n                /* FLI LC chunk (byte delta) */\n                /* OOB Check ok, we have 4 bytes min here */\n                y = I16(data);\n                ymax = y + I16(data + 2);\n                data += 4;\n                for (; y < ymax && y < state->ysize; y++) {\n                    UINT8 *out = (UINT8 *)im->image[y];\n                    ERR_IF_DATA_OOB(1)\n                    int p, packets = *data++;\n                    for (p = x = 0; p < packets; p++, x += i) {\n                        ERR_IF_DATA_OOB(2)\n                        x += data[0]; /* skip pixels */\n                        if (data[1] & 0x80) {\n                            i = 256 - data[1]; /* run */\n                            if (x + i > state->xsize) {\n                                break;\n                            }\n                            ERR_IF_DATA_OOB(3)\n                            memset(out + x, data[2], i);\n                            data += 3;\n                        } else {\n                            i = data[1]; /* chunk */\n                            if (x + i > state->xsize) {\n                                break;\n                            }\n                            ERR_IF_DATA_OOB(2 + i)\n                            memcpy(out + x, data + 2, i);\n                            data += i + 2;\n                        }\n                    }\n                    if (p < packets) {\n                        break; /* didn't process all packets */\n                    }\n                }\n                if (y < ymax) {\n                    /* didn't process all lines */\n                    state->errcode = IMAGING_CODEC_OVERRUN;\n                    return -1;\n                }\n                break;\n            case 13:\n                /* FLI BLACK chunk */\n                for (y = 0; y < state->ysize; y++) {\n                    memset(im->image[y], 0, state->xsize);\n                }\n                break;\n            case 15:\n                /* FLI BRUN chunk */\n                /* OOB, ok, we've got 4 bytes min on entry */\n                for (y = 0; y < state->ysize; y++) {\n                    UINT8 *out = (UINT8 *)im->image[y];\n                    data += 1; /* ignore packetcount byte */\n                    for (x = 0; x < state->xsize; x += i) {\n                        ERR_IF_DATA_OOB(2)\n                        if (data[0] & 0x80) {\n                            i = 256 - data[0];\n                            if (x + i > state->xsize) {\n                                break; /* safety first */\n                            }\n                            ERR_IF_DATA_OOB(i + 1)\n                            memcpy(out + x, data + 1, i);\n                            data += i + 1;\n                        } else {\n                            i = data[0];\n                            if (x + i > state->xsize) {\n                                break; /* safety first */\n                            }\n                            memset(out + x, data[1], i);\n                            data += 2;\n                        }\n                    }\n                    if (x != state->xsize) {\n                        /* didn't unpack whole line */\n                        state->errcode = IMAGING_CODEC_OVERRUN;\n                        return -1;\n                    }\n                }\n                break;\n            case 16:\n                /* COPY chunk */\n                if (state->xsize > bytes / state->ysize) {\n                    /* not enough data for frame */\n                    return ptr - buf; /* bytes consumed */\n                }\n                for (y = 0; y < state->ysize; y++) {\n                    UINT8 *local_buf = (UINT8 *)im->image[y];\n                    memcpy(local_buf, data, state->xsize);\n                    data += state->xsize;\n                }\n                break;\n            case 18:\n                /* PSTAMP chunk */\n                break; /* ignored */\n            default:\n                /* unknown chunk */\n                /* printf(\"unknown FLI/FLC chunk: %d\\n\", I16(ptr+4)); */\n                state->errcode = IMAGING_CODEC_UNKNOWN;\n                return -1;\n        }\n        advance = I32(ptr);\n        if (advance == 0 ) {\n            // If there's no advance, we're in in infinite loop\n            state->errcode = IMAGING_CODEC_BROKEN;\n            return -1;\n        }\n        if (advance < 0 || advance > bytes) {\n            state->errcode = IMAGING_CODEC_OVERRUN;\n            return -1;\n        }\n        ptr += advance;\n        bytes -= advance;\n    }\n\n    return -1; /* end of frame */\n}",
  "abstract_func": "int\nImagingFliDecode(Imaging VAR_0, ImagingCodecState VAR_1, UINT8 *VAR_2, Py_ssize_t VAR_3) {\n    UINT8 *VAR_4;\n    int VAR_5;\n    int VAR_6, VAR_7, VAR_8;\n    int VAR_9, VAR_10;\n    int VAR_11, VAR_12, VAR_13 = 0, VAR_14, VAR_15;\n\n    /* COMMENT_0 */\n\n    if (VAR_3 < 4) {\n        return 0;\n    }\n\n    /* COMMENT_1 */\n                      \n\n    VAR_4 = VAR_2;\n\n    VAR_5 = I32(VAR_4);\n    if (VAR_5 < I32(VAR_4)) {\n        return 0;\n    }\n\n    /* COMMENT_3 */\n                                    \n\n    if (VAR_3 < 8) {\n        VAR_1->errcode = VAR_16;\n        return -1;\n    }\n    if (I16(VAR_4 + 4) != 0xF1FA) {\n        VAR_1->errcode = VAR_17;\n        return -1;\n    }\n\n    VAR_7 = I16(VAR_4 + 6);\n    VAR_4 += 16;\n    VAR_3 -= 16;\n\n    /* COMMENT_5 */\n    for (VAR_6 = 0; VAR_6 < VAR_7; VAR_6++) {\n        UINT8 *VAR_18;\n        if (VAR_3 < 10) {\n            VAR_1->errcode = VAR_16;\n            return -1;\n        }\n        VAR_18 = VAR_4 + 6;\n        switch (I16(VAR_4 + 4)) {\n            case 4:\n            case 11:\n                /* COMMENT_6 */\n                break; /* COMMENT_7 */\n            case 7:\n                /* COMMENT_8 */\n                /* COMMENT_9 */\n                VAR_10 = I16(VAR_18);\n                VAR_18 += 2;\n                for (VAR_9 = VAR_14 = 0; VAR_9 < VAR_10 && VAR_14 < VAR_1->ysize; VAR_9++, VAR_14++) {\n                    UINT8 *VAR_19 = (UINT8 *)VAR_0->image[VAR_14];\n                    int VAR_20, VAR_21;\n                    ERR_IF_DATA_OOB(2)\n                    VAR_21 = I16(VAR_18);\n                    VAR_18 += 2;\n                    while (VAR_21 & 0x8000) {\n                        /* COMMENT_10 */\n                        if (VAR_21 & 0x4000) {\n                            VAR_14 += 65536 - VAR_21; /* COMMENT_11 */\n                            if (VAR_14 >= VAR_1->ysize) {\n                                VAR_1->errcode = VAR_16;\n                                return -1;\n                            }\n                            VAR_19 = (UINT8 *)VAR_0->image[VAR_14];\n                        } else {\n                            /* COMMENT_12 */\n                            VAR_19[VAR_1->xsize - 1] = (UINT8)VAR_21;\n                        }\n                        ERR_IF_DATA_OOB(2)\n                        VAR_21 = I16(VAR_18);\n                        VAR_18 += 2;\n                    }\n                    for (VAR_20 = VAR_13 = 0; VAR_20 < VAR_21; VAR_20++) {\n                        ERR_IF_DATA_OOB(2)\n                        VAR_13 += VAR_18[0]; /* COMMENT_13 */\n                        if (VAR_18[1] >= 128) {\n                            ERR_IF_DATA_OOB(4)\n                            VAR_11 = 256 - VAR_18[1]; /* COMMENT_14 */\n                            if (VAR_13 + VAR_11 + VAR_11 > VAR_1->xsize) {\n                                break;\n                            }\n                            for (VAR_12 = 0; VAR_12 < VAR_11; VAR_12++) {\n                                VAR_19[VAR_13++] = VAR_18[2];\n                                VAR_19[VAR_13++] = VAR_18[3];\n                            }\n                            VAR_18 += 2 + 2;\n                        } else {\n                            VAR_11 = 2 * (int)VAR_18[1]; /* COMMENT_15 */\n                            if (VAR_13 + VAR_11 > VAR_1->xsize) {\n                                break;\n                            }\n                            ERR_IF_DATA_OOB(2 + VAR_11)\n                            memcpy(VAR_19 + VAR_13, VAR_18 + 2, VAR_11);\n                            VAR_18 += 2 + VAR_11;\n                            VAR_13 += VAR_11;\n                        }\n                    }\n                    if (VAR_20 < VAR_21) {\n                        break; /* COMMENT_16 */\n                    }\n                }\n                if (VAR_9 < VAR_10) {\n                    /* COMMENT_17 */\n                    VAR_1->errcode = VAR_16;\n                    return -1;\n                }\n                break;\n            case 12:\n                /* COMMENT_18 */\n                /* COMMENT_19 */\n                VAR_14 = I16(VAR_18);\n                VAR_15 = VAR_14 + I16(VAR_18 + 2);\n                VAR_18 += 4;\n                for (; VAR_14 < VAR_15 && VAR_14 < VAR_1->ysize; VAR_14++) {\n                    UINT8 *VAR_22 = (UINT8 *)VAR_0->image[VAR_14];\n                    ERR_IF_DATA_OOB(1)\n                    int VAR_20, VAR_21 = *VAR_18++;\n                    for (VAR_20 = VAR_13 = 0; VAR_20 < VAR_21; VAR_20++, VAR_13 += VAR_11) {\n                        ERR_IF_DATA_OOB(2)\n                        VAR_13 += VAR_18[0]; /* COMMENT_20 */\n                        if (VAR_18[1] & 0x80) {\n                            VAR_11 = 256 - VAR_18[1]; /* COMMENT_14 */\n                            if (VAR_13 + VAR_11 > VAR_1->xsize) {\n                                break;\n                            }\n                            ERR_IF_DATA_OOB(3)\n                            memset(VAR_22 + VAR_13, VAR_18[2], VAR_11);\n                            VAR_18 += 3;\n                        } else {\n                            VAR_11 = VAR_18[1]; /* COMMENT_15 */\n                            if (VAR_13 + VAR_11 > VAR_1->xsize) {\n                                break;\n                            }\n                            ERR_IF_DATA_OOB(2 + VAR_11)\n                            memcpy(VAR_22 + VAR_13, VAR_18 + 2, VAR_11);\n                            VAR_18 += VAR_11 + 2;\n                        }\n                    }\n                    if (VAR_20 < VAR_21) {\n                        break; /* COMMENT_16 */\n                    }\n                }\n                if (VAR_14 < VAR_15) {\n                    /* COMMENT_17 */\n                    VAR_1->errcode = VAR_16;\n                    return -1;\n                }\n                break;\n            case 13:\n                /* COMMENT_21 */\n                for (VAR_14 = 0; VAR_14 < VAR_1->ysize; VAR_14++) {\n                    memset(VAR_0->image[VAR_14], 0, VAR_1->xsize);\n                }\n                break;\n            case 15:\n                /* COMMENT_22 */\n                /* COMMENT_23 */\n                for (VAR_14 = 0; VAR_14 < VAR_1->ysize; VAR_14++) {\n                    UINT8 *VAR_22 = (UINT8 *)VAR_0->image[VAR_14];\n                    VAR_18 += 1; /* COMMENT_24 */\n                    for (VAR_13 = 0; VAR_13 < VAR_1->xsize; VAR_13 += VAR_11) {\n                        ERR_IF_DATA_OOB(2)\n                        if (VAR_18[0] & 0x80) {\n                            VAR_11 = 256 - VAR_18[0];\n                            if (VAR_13 + VAR_11 > VAR_1->xsize) {\n                                break; /* COMMENT_25 */\n                            }\n                            ERR_IF_DATA_OOB(VAR_11 + 1)\n                            memcpy(VAR_22 + VAR_13, VAR_18 + 1, VAR_11);\n                            VAR_18 += VAR_11 + 1;\n                        } else {\n                            VAR_11 = VAR_18[0];\n                            if (VAR_13 + VAR_11 > VAR_1->xsize) {\n                                break; /* COMMENT_25 */\n                            }\n                            memset(VAR_22 + VAR_13, VAR_18[1], VAR_11);\n                            VAR_18 += 2;\n                        }\n                    }\n                    if (VAR_13 != VAR_1->xsize) {\n                        /* COMMENT_26 */\n                        VAR_1->errcode = VAR_16;\n                        return -1;\n                    }\n                }\n                break;\n            case 16:\n                /* COMMENT_27 */\n                if (VAR_1->xsize > VAR_3 / VAR_1->ysize) {\n                    /* COMMENT_28 */\n                    return VAR_4 - VAR_2; /* COMMENT_29 */\n                }\n                for (VAR_14 = 0; VAR_14 < VAR_1->ysize; VAR_14++) {\n                    UINT8 *VAR_19 = (UINT8 *)VAR_0->image[VAR_14];\n                    memcpy(VAR_19, VAR_18, VAR_1->xsize);\n                    VAR_18 += VAR_1->xsize;\n                }\n                break;\n            case 18:\n                /* COMMENT_30 */\n                break; /* COMMENT_31 */\n            default:\n                /* COMMENT_32 */\n                /* COMMENT_33 */\n                VAR_1->errcode = VAR_17;\n                return -1;\n        }\n        VAR_8 = I32(VAR_4);\n        if (VAR_8 == 0 ) {\n            /* COMMENT_34 */\n            VAR_1->errcode = VAR_23;\n            return -1;\n        }\n        if (VAR_8 < 0 || VAR_8 > VAR_3) {\n            VAR_1->errcode = VAR_16;\n            return -1;\n        }\n        VAR_4 += VAR_8;\n        VAR_3 -= VAR_8;\n    }\n\n    return -1; /* COMMENT_35 */\n}",
  "func_graph_path": "python-pillow/Pillow/bb6c11fb889e6c11b0ee122b828132ee763b5856/FliDecode.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -215,6 +215,11 @@\n                 return -1;\n         }\n         advance = I32(ptr);\n+        if (advance == 0 ) {\n+            // If there's no advance, we're in in infinite loop\n+            state->errcode = IMAGING_CODEC_BROKEN;\n+            return -1;\n+        }\n         if (advance < 0 || advance > bytes) {\n             state->errcode = IMAGING_CODEC_OVERRUN;\n             return -1;",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "        if (advance == 0 ) {",
      "            // If there's no advance, we're in in infinite loop",
      "            state->errcode = IMAGING_CODEC_BROKEN;",
      "            return -1;",
      "        }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/python-pillow/Pillow/pull/5377",
  "description": {
    "pr_info": {
      "title": "Security fixes for 8.2.0",
      "number": 5377
    },
    "comment": [
      "See commits and release notes for details.\r\n\r\n(Plus reorder release notes to roughly alphabetical, nothing requiring promoting to the top.)",
      "@wiredfool There are 3 fails (in addition to xfails) on the valgrind workflow, is this good to merge or do we want to check those first? ",
      "I know these patches are good, and I'm not too worried because they're 3 separate images in the fuzz_images test, which is mainly ensuring that the fuzzer runs under test (but not as fuzzing). ",
      "Thanks, proceeding with the release! ",
      "Hi, the CVEs mentioned in commits and release notes will be reported to Mitre?\r\nThanks.",
      "They have been, yes. Go to https://pillow.readthedocs.io/en/stable/releasenotes/8.2.0.html#security to see links to the reports.",
      "Why are there 2 CVEs assigned for \"Fix OOB read in Jpeg2KDecode?\" Could someone please explain? @hugovk @radarhere @wiredfool ",
      "One each for:\r\n\r\n* CVE-2021-25287: \"There is an out-of-bounds read in J2kDecode, in j2ku_graya_la.\"\r\n\r\n* CVE-2021-25288: \"There is an out-of-bounds read in J2kDecode, in j2ku_gray_i.\"\r\n\r\n---\r\n\r\nThe CVEs from https://pillow.readthedocs.io/en/stable/releasenotes/8.2.0.html#security at MITRE ([example](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-25288)) are still showing as reserved:\r\n\r\n> ** RESERVED ** This candidate has been reserved by an organization or individual that will use it when announcing a new security problem. When the candidate has been publicized, the details for this candidate will be provided.\r\n\r\nDo we or Tidelift need to do anything to publicise them?",
      "https://cve.mitre.org/cve/researcher_reservation_guidelines#researcher_reservation_guidelines#12\r\n> 12. Notify the CVE Team that the vulnerability has been made public using the CVE Request web form, and selecting \"Notify CVE about a Publication.\"\r\n\r\nI've submitted https://cveform.mitre.org/ accordingly.",
      "There were 2 cves assigned for 2 fuzzier test cases that looked very similar before I got to fixing it.  Once the fix was done, there was one bug that could hit any multiband mode but the fuzzier only found these two.  ",
      "I received an e-mail response, and the CVEs should now be public."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}