{
  "cve_id": "CVE-2022-32546",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "ImageMagick",
  "commit_msg": "Fixes #4985: 4e+26 is outside the range of representable values of type 'unsigned long' at coders/pcl.c:299 (#4986)\n\n* fix Division by zero in XMenuWidget() of MagickCore/widget.c\r\n\r\n* Fix memory leak in AnimateImageCommand() of MagickWand/animate.c and DisplayImageCommand() of MagickWand/display.c\r\n\r\n* fix Division by zero in ReadEnhMetaFile() of coders/emf.c\r\n\r\n* Resolve conflicts\r\n\r\n* fix issue: outside the range of representable values of type 'unsigned char' at coders/psd.c:1025\r\n\r\n* fix error: 4e+26 is outside the range of representable values of type 'unsigned long' at coders/pcl.c:299\r\n\r\nCo-authored-by: zhailiangliang <zhailiangliang@loongson.cn>",
  "commit_hash": "f221ea0fa3171f0f4fdf74ac9d81b203b9534c23",
  "git_url": "https://github.com/ImageMagick/ImageMagick/commit/f221ea0fa3171f0f4fdf74ac9d81b203b9534c23",
  "file_path": "coders/pcl.c",
  "func_name": "ReadPCLImage",
  "func_before": "static Image *ReadPCLImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define CropBox  \"CropBox\"\n#define DeviceCMYK  \"DeviceCMYK\"\n#define MediaBox  \"MediaBox\"\n#define RenderPCLText  \"  Rendering PCL...  \"\n\n  char\n    command[MagickPathExtent],\n    *density,\n    filename[MagickPathExtent],\n    geometry[MagickPathExtent],\n    *options,\n    input_filename[MagickPathExtent];\n\n  const DelegateInfo\n    *delegate_info;\n\n  Image\n    *image,\n    *next_image;\n\n  ImageInfo\n    *read_info;\n\n  MagickBooleanType\n    cmyk,\n    status;\n\n  PointInfo\n    delta;\n\n  RectangleInfo\n    bounding_box,\n    page;\n\n  char\n    *p;\n\n  ssize_t\n    c;\n\n  SegmentInfo\n    bounds;\n\n  size_t\n    height,\n    width;\n\n  ssize_t\n    count;\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  /*\n    Open image file.\n  */\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  status=AcquireUniqueSymbolicLink(image_info->filename,input_filename);\n  if (status == MagickFalse)\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n        image_info->filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Set the page density.\n  */\n  delta.x=DefaultResolution;\n  delta.y=DefaultResolution;\n  if ((image->resolution.x == 0.0) || (image->resolution.y == 0.0))\n    {\n      GeometryInfo\n        geometry_info;\n\n      MagickStatusType\n        flags;\n\n      flags=ParseGeometry(PSDensityGeometry,&geometry_info);\n      if ((flags & RhoValue) != 0)\n        image->resolution.x=geometry_info.rho;\n      image->resolution.y=image->resolution.x;\n      if ((flags & SigmaValue) != 0)\n        image->resolution.y=geometry_info.sigma;\n    }\n  /*\n    Determine page geometry from the PCL media box.\n  */\n  cmyk=image->colorspace == CMYKColorspace ? MagickTrue : MagickFalse;\n  count=0;\n  (void) memset(&bounding_box,0,sizeof(bounding_box));\n  (void) memset(&bounds,0,sizeof(bounds));\n  (void) memset(&page,0,sizeof(page));\n  (void) memset(command,0,sizeof(command));\n  p=command;\n  for (c=ReadBlobByte(image); c != EOF; c=ReadBlobByte(image))\n  {\n    if (image_info->page != (char *) NULL)\n      continue;\n    /*\n      Note PCL elements.\n    */\n    *p++=(char) c;\n    if ((c != (int) '/') && (c != '\\n') &&\n        ((size_t) (p-command) < (MagickPathExtent-1)))\n      continue;\n    *p='\\0';\n    p=command;\n    /*\n      Is this a CMYK document?\n    */\n    if (LocaleNCompare(DeviceCMYK,command,strlen(DeviceCMYK)) == 0)\n      cmyk=MagickTrue;\n    if (LocaleNCompare(CropBox,command,strlen(CropBox)) == 0)\n      {\n        /*\n          Note region defined by crop box.\n        */\n        count=(ssize_t) sscanf(command,\"CropBox [%lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        if (count != 4)\n          count=(ssize_t) sscanf(command,\"CropBox[%lf %lf %lf %lf\",\n            &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n      }\n    if (LocaleNCompare(MediaBox,command,strlen(MediaBox)) == 0)\n      {\n        /*\n          Note region defined by media box.\n        */\n        count=(ssize_t) sscanf(command,\"MediaBox [%lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        if (count != 4)\n          count=(ssize_t) sscanf(command,\"MediaBox[%lf %lf %lf %lf\",\n            &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n      }\n    if (count != 4)\n      continue;\n    /*\n      Set PCL render geometry.\n    */\n    width=(size_t) floor(bounds.x2-bounds.x1+0.5);\n    height=(size_t) floor(bounds.y2-bounds.y1+0.5);\n    if (width > page.width)\n      page.width=width;\n    if (height > page.height)\n      page.height=height;\n  }\n  (void) CloseBlob(image);\n  /*\n    Render PCL with the GhostPCL delegate.\n  */\n  if ((page.width == 0) || (page.height == 0))\n    (void) ParseAbsoluteGeometry(PSPageGeometry,&page);\n  if (image_info->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(image_info->page,&page);\n  (void) FormatLocaleString(geometry,MagickPathExtent,\"%.20gx%.20g\",(double)\n    page.width,(double) page.height);\n  if (image_info->monochrome != MagickFalse)\n    delegate_info=GetDelegateInfo(\"pcl:mono\",(char *) NULL,exception);\n  else\n     if (cmyk != MagickFalse)\n       delegate_info=GetDelegateInfo(\"pcl:cmyk\",(char *) NULL,exception);\n     else\n       delegate_info=GetDelegateInfo(\"pcl:color\",(char *) NULL,exception);\n  if (delegate_info == (const DelegateInfo *) NULL)\n    {\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  if ((page.width == 0) || (page.height == 0))\n    (void) ParseAbsoluteGeometry(PSPageGeometry,&page);\n  if (image_info->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(image_info->page,&page);\n  density=AcquireString(\"\");\n  options=AcquireString(\"\");\n  (void) FormatLocaleString(density,MagickPathExtent,\"%gx%g\",\n    image->resolution.x,image->resolution.y);\n  if (image_info->ping != MagickFalse)\n    (void) FormatLocaleString(density,MagickPathExtent,\"2.0x2.0\");\n  page.width=(size_t) floor(page.width*image->resolution.x/delta.x+0.5);\n  page.height=(size_t) floor(page.height*image->resolution.y/delta.y+0.5);\n  (void) FormatLocaleString(options,MagickPathExtent,\"-g%.20gx%.20g \",(double)\n    page.width,(double) page.height);\n  image=DestroyImage(image);\n  read_info=CloneImageInfo(image_info);\n  *read_info->magick='\\0';\n  if (read_info->number_scenes != 0)\n    {\n      if (read_info->number_scenes != 1)\n        (void) FormatLocaleString(options,MagickPathExtent,\"-dLastPage=%.20g\",\n          (double) (read_info->scene+read_info->number_scenes));\n      else\n        (void) FormatLocaleString(options,MagickPathExtent,\n          \"-dFirstPage=%.20g -dLastPage=%.20g\",(double) read_info->scene+1,\n          (double) (read_info->scene+read_info->number_scenes));\n      read_info->number_scenes=0;\n      if (read_info->scenes != (char *) NULL)\n        *read_info->scenes='\\0';\n    }\n  (void) CopyMagickString(filename,read_info->filename,MagickPathExtent);\n  (void) AcquireUniqueFilename(read_info->filename);\n  (void) FormatLocaleString(command,MagickPathExtent,\n    GetDelegateCommands(delegate_info),\n    read_info->antialias != MagickFalse ? 4 : 1,\n    read_info->antialias != MagickFalse ? 4 : 1,density,options,\n    read_info->filename,input_filename);\n  options=DestroyString(options);\n  density=DestroyString(density);\n  status=ExternalDelegateCommand(MagickFalse,read_info->verbose,command,\n    (char *) NULL,exception) != 0 ? MagickTrue : MagickFalse;\n  image=ReadImage(read_info,exception);\n  (void) RelinquishUniqueFileResource(read_info->filename);\n  (void) RelinquishUniqueFileResource(input_filename);\n  read_info=DestroyImageInfo(read_info);\n  if (image == (Image *) NULL)\n    ThrowReaderException(DelegateError,\"PCLDelegateFailed\");\n  if (LocaleCompare(image->magick,\"BMP\") == 0)\n    {\n      Image\n        *cmyk_image;\n\n      cmyk_image=ConsolidateCMYKImages(image,exception);\n      if (cmyk_image != (Image *) NULL)\n        {\n          image=DestroyImageList(image);\n          image=cmyk_image;\n        }\n    }\n  do\n  {\n    (void) CopyMagickString(image->filename,filename,MagickPathExtent);\n    image->page=page;\n    if (image_info->ping != MagickFalse)\n      {\n        image->magick_columns*=image->resolution.x/2.0;\n        image->magick_rows*=image->resolution.y/2.0;\n        image->columns*=image->resolution.x/2.0;\n        image->rows*=image->resolution.y/2.0;\n      }\n    next_image=SyncNextImageInList(image);\n    if (next_image != (Image *) NULL)\n      image=next_image;\n  } while (next_image != (Image *) NULL);\n  return(GetFirstImageInList(image));\n}",
  "abstract_func_before": "static Image *ReadPCLImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)\n{\n#define VAR_2  \"CropBox\"\n#define VAR_3  \"DeviceCMYK\"\n#define VAR_4  \"MediaBox\"\n#define VAR_5  \"  Rendering PCL...  \"\n\n  char\n    VAR_6[VAR_7],\n    *VAR_8,\n    VAR_9[VAR_7],\n    VAR_10[VAR_7],\n    *VAR_11,\n    VAR_12[VAR_7];\n\n  const DelegateInfo\n    *VAR_13;\n\n  Image\n    *VAR_14,\n    *VAR_15;\n\n  ImageInfo\n    *VAR_16;\n\n  MagickBooleanType\n    VAR_17,\n    VAR_18;\n\n  PointInfo\n    VAR_19;\n\n  RectangleInfo\n    VAR_20,\n    VAR_21;\n\n  char\n    *VAR_22;\n\n  ssize_t\n    VAR_23;\n\n  SegmentInfo\n    VAR_24;\n\n  size_t\n    VAR_25,\n    VAR_26;\n\n  ssize_t\n    VAR_27;\n\n  assert(VAR_0 != (const ImageInfo *) NULL);\n  assert(VAR_0->signature == VAR_28);\n  if (VAR_0->debug != VAR_29)\n    (void) LogMagickEvent(VAR_30,GetMagickModule(),\"%s\",\n      VAR_0->filename);\n  assert(VAR_1 != (ExceptionInfo *) NULL);\n  assert(VAR_1->signature == VAR_28);\n  /* COMMENT_0 */\n                    \n    \n  VAR_14=AcquireImage(VAR_0,VAR_1);\n  VAR_18=OpenBlob(VAR_0,VAR_14,VAR_31,VAR_1);\n  if (VAR_18 == VAR_29)\n    {\n      VAR_14=DestroyImageList(VAR_14);\n      return((Image *) NULL);\n    }\n  VAR_18=AcquireUniqueSymbolicLink(VAR_0->filename,VAR_12);\n  if (VAR_18 == VAR_29)\n    {\n      ThrowFileException(VAR_1,VAR_32,\"UnableToCreateTemporaryFile\",\n        VAR_0->filename);\n      VAR_14=DestroyImageList(VAR_14);\n      return((Image *) NULL);\n    }\n  /* COMMENT_3 */\n                         \n    \n  VAR_19.x=VAR_33;\n  VAR_19.y=VAR_33;\n  if ((VAR_14->resolution.x == 0.0) || (VAR_14->resolution.y == 0.0))\n    {\n      GeometryInfo\n        VAR_34;\n\n      MagickStatusType\n        VAR_35;\n\n      VAR_35=ParseGeometry(VAR_36,&VAR_34);\n      if ((VAR_35 & VAR_37) != 0)\n        VAR_14->resolution.x=VAR_34.rho;\n      VAR_14->resolution.y=VAR_14->resolution.x;\n      if ((VAR_35 & VAR_38) != 0)\n        VAR_14->resolution.y=VAR_34.sigma;\n    }\n  /* COMMENT_6 */\n                                                   \n    \n  VAR_17=VAR_14->colorspace == VAR_39 ? VAR_40 : VAR_29;\n  VAR_27=0;\n  (void) memset(&VAR_20,0,sizeof(VAR_20));\n  (void) memset(&VAR_24,0,sizeof(VAR_24));\n  (void) memset(&VAR_21,0,sizeof(VAR_21));\n  (void) memset(VAR_6,0,sizeof(VAR_6));\n  VAR_22=VAR_6;\n  for (VAR_23=ReadBlobByte(VAR_14); VAR_23 != VAR_41; VAR_23=ReadBlobByte(VAR_14))\n  {\n    if (VAR_0->page != (char *) NULL)\n      continue;\n    /* COMMENT_9 */\n                        \n      \n    *VAR_22++=(char) VAR_23;\n    if ((VAR_23 != (int) '/') && (VAR_23 != '\\n') &&\n        ((size_t) (VAR_22-VAR_6) < (VAR_7-1)))\n      continue;\n    *VAR_22='\\0';\n    VAR_22=VAR_6;\n    /* COMMENT_12 */\n                              \n      \n    if (LocaleNCompare(VAR_3,VAR_6,strlen(VAR_3)) == 0)\n      VAR_17=VAR_40;\n    if (LocaleNCompare(VAR_2,VAR_6,strlen(VAR_2)) == 0)\n      {\n        /* COMMENT_15 */\n                                          \n          \n        VAR_27=(ssize_t) sscanf(VAR_6,\"CropBox [%lf %lf %lf %lf\",\n          &VAR_24.x1,&VAR_24.y1,&VAR_24.x2,&VAR_24.y2);\n        if (VAR_27 != 4)\n          VAR_27=(ssize_t) sscanf(VAR_6,\"CropBox[%lf %lf %lf %lf\",\n            &VAR_24.x1,&VAR_24.y1,&VAR_24.x2,&VAR_24.y2);\n      }\n    if (LocaleNCompare(VAR_4,VAR_6,strlen(VAR_4)) == 0)\n      {\n        /* COMMENT_18 */\n                                           \n          \n        VAR_27=(ssize_t) sscanf(VAR_6,\"MediaBox [%lf %lf %lf %lf\",\n          &VAR_24.x1,&VAR_24.y1,&VAR_24.x2,&VAR_24.y2);\n        if (VAR_27 != 4)\n          VAR_27=(ssize_t) sscanf(VAR_6,\"MediaBox[%lf %lf %lf %lf\",\n            &VAR_24.x1,&VAR_24.y1,&VAR_24.x2,&VAR_24.y2);\n      }\n    if (VAR_27 != 4)\n      continue;\n    /* COMMENT_21 */\n                              \n      \n    VAR_26=(size_t) floor(VAR_24.x2-VAR_24.x1+0.5);\n    VAR_25=(size_t) floor(VAR_24.y2-VAR_24.y1+0.5);\n    if (VAR_26 > VAR_21.width)\n      VAR_21.width=VAR_26;\n    if (VAR_25 > VAR_21.height)\n      VAR_21.height=VAR_25;\n  }\n  (void) CloseBlob(VAR_14);\n  /* COMMENT_24 */\n                                          \n    \n  if ((VAR_21.width == 0) || (VAR_21.height == 0))\n    (void) ParseAbsoluteGeometry(VAR_42,&VAR_21);\n  if (VAR_0->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(VAR_0->page,&VAR_21);\n  (void) FormatLocaleString(VAR_10,VAR_7,\"%.20gx%.20g\",(double)\n    VAR_21.width,(double) VAR_21.height);\n  if (VAR_0->monochrome != VAR_29)\n    VAR_13=GetDelegateInfo(\"pcl:mono\",(char *) NULL,VAR_1);\n  else\n     if (VAR_17 != VAR_29)\n       VAR_13=GetDelegateInfo(\"pcl:cmyk\",(char *) NULL,VAR_1);\n     else\n       VAR_13=GetDelegateInfo(\"pcl:color\",(char *) NULL,VAR_1);\n  if (VAR_13 == (const DelegateInfo *) NULL)\n    {\n      VAR_14=DestroyImage(VAR_14);\n      return((Image *) NULL);\n    }\n  if ((VAR_21.width == 0) || (VAR_21.height == 0))\n    (void) ParseAbsoluteGeometry(VAR_42,&VAR_21);\n  if (VAR_0->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(VAR_0->page,&VAR_21);\n  VAR_8=AcquireString(\"\");\n  VAR_11=AcquireString(\"\");\n  (void) FormatLocaleString(VAR_8,VAR_7,\"%gx%g\",\n    VAR_14->resolution.x,VAR_14->resolution.y);\n  if (VAR_0->ping != VAR_29)\n    (void) FormatLocaleString(VAR_8,VAR_7,\"2.0x2.0\");\n  VAR_21.width=(size_t) floor(VAR_21.width*VAR_14->resolution.x/VAR_19.x+0.5);\n  VAR_21.height=(size_t) floor(VAR_21.height*VAR_14->resolution.y/VAR_19.y+0.5);\n  (void) FormatLocaleString(VAR_11,VAR_7,\"-g%.20gx%.20g \",(double)\n    VAR_21.width,(double) VAR_21.height);\n  VAR_14=DestroyImage(VAR_14);\n  VAR_16=CloneImageInfo(VAR_0);\n  *VAR_16->magick='\\0';\n  if (VAR_16->number_scenes != 0)\n    {\n      if (VAR_16->number_scenes != 1)\n        (void) FormatLocaleString(VAR_11,VAR_7,\"-dLastPage=%.20g\",\n          (double) (VAR_16->scene+VAR_16->number_scenes));\n      else\n        (void) FormatLocaleString(VAR_11,VAR_7,\n          \"-dFirstPage=%.20g -dLastPage=%.20g\",(double) VAR_16->scene+1,\n          (double) (VAR_16->scene+VAR_16->number_scenes));\n      VAR_16->number_scenes=0;\n      if (VAR_16->scenes != (char *) NULL)\n        *VAR_16->scenes='\\0';\n    }\n  (void) CopyMagickString(VAR_9,VAR_16->filename,VAR_7);\n  (void) AcquireUniqueFilename(VAR_16->filename);\n  (void) FormatLocaleString(VAR_6,VAR_7,\n    GetDelegateCommands(VAR_13),\n    VAR_16->antialias != VAR_29 ? 4 : 1,\n    VAR_16->antialias != VAR_29 ? 4 : 1,VAR_8,VAR_11,\n    VAR_16->filename,VAR_12);\n  VAR_11=DestroyString(VAR_11);\n  VAR_8=DestroyString(VAR_8);\n  VAR_18=ExternalDelegateCommand(VAR_29,VAR_16->verbose,VAR_6,\n    (char *) NULL,VAR_1) != 0 ? VAR_40 : VAR_29;\n  VAR_14=ReadImage(VAR_16,VAR_1);\n  (void) RelinquishUniqueFileResource(VAR_16->filename);\n  (void) RelinquishUniqueFileResource(VAR_12);\n  VAR_16=DestroyImageInfo(VAR_16);\n  if (VAR_14 == (Image *) NULL)\n    ThrowReaderException(VAR_43,\"PCLDelegateFailed\");\n  if (LocaleCompare(VAR_14->magick,\"BMP\") == 0)\n    {\n      Image\n        *VAR_44;\n\n      VAR_44=ConsolidateCMYKImages(VAR_14,VAR_1);\n      if (VAR_44 != (Image *) NULL)\n        {\n          VAR_14=DestroyImageList(VAR_14);\n          VAR_14=VAR_44;\n        }\n    }\n  do\n  {\n    (void) CopyMagickString(VAR_14->filename,VAR_9,VAR_7);\n    VAR_14->page=VAR_21;\n    if (VAR_0->ping != VAR_29)\n      {\n        VAR_14->magick_columns*=VAR_14->resolution.x/2.0;\n        VAR_14->magick_rows*=VAR_14->resolution.y/2.0;\n        VAR_14->columns*=VAR_14->resolution.x/2.0;\n        VAR_14->rows*=VAR_14->resolution.y/2.0;\n      }\n    VAR_15=SyncNextImageInList(VAR_14);\n    if (VAR_15 != (Image *) NULL)\n      VAR_14=VAR_15;\n  } while (VAR_15 != (Image *) NULL);\n  return(GetFirstImageInList(VAR_14));\n}",
  "func_graph_path_before": "ImageMagick/f221ea0fa3171f0f4fdf74ac9d81b203b9534c23/pcl.c/vul/before/0.json",
  "func": "static Image *ReadPCLImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define CropBox  \"CropBox\"\n#define DeviceCMYK  \"DeviceCMYK\"\n#define MediaBox  \"MediaBox\"\n#define RenderPCLText  \"  Rendering PCL...  \"\n\n  char\n    command[MagickPathExtent],\n    *density,\n    filename[MagickPathExtent],\n    geometry[MagickPathExtent],\n    *options,\n    input_filename[MagickPathExtent];\n\n  const DelegateInfo\n    *delegate_info;\n\n  Image\n    *image,\n    *next_image;\n\n  ImageInfo\n    *read_info;\n\n  MagickBooleanType\n    cmyk,\n    status;\n\n  PointInfo\n    delta;\n\n  RectangleInfo\n    bounding_box,\n    page;\n\n  char\n    *p;\n\n  ssize_t\n    c;\n\n  SegmentInfo\n    bounds;\n\n  size_t\n    height,\n    width;\n\n  ssize_t\n    count;\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  /*\n    Open image file.\n  */\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  status=AcquireUniqueSymbolicLink(image_info->filename,input_filename);\n  if (status == MagickFalse)\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n        image_info->filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Set the page density.\n  */\n  delta.x=DefaultResolution;\n  delta.y=DefaultResolution;\n  if ((image->resolution.x == 0.0) || (image->resolution.y == 0.0))\n    {\n      GeometryInfo\n        geometry_info;\n\n      MagickStatusType\n        flags;\n\n      flags=ParseGeometry(PSDensityGeometry,&geometry_info);\n      if ((flags & RhoValue) != 0)\n        image->resolution.x=geometry_info.rho;\n      image->resolution.y=image->resolution.x;\n      if ((flags & SigmaValue) != 0)\n        image->resolution.y=geometry_info.sigma;\n    }\n  /*\n    Determine page geometry from the PCL media box.\n  */\n  cmyk=image->colorspace == CMYKColorspace ? MagickTrue : MagickFalse;\n  count=0;\n  (void) memset(&bounding_box,0,sizeof(bounding_box));\n  (void) memset(&bounds,0,sizeof(bounds));\n  (void) memset(&page,0,sizeof(page));\n  (void) memset(command,0,sizeof(command));\n  p=command;\n  for (c=ReadBlobByte(image); c != EOF; c=ReadBlobByte(image))\n  {\n    if (image_info->page != (char *) NULL)\n      continue;\n    /*\n      Note PCL elements.\n    */\n    *p++=(char) c;\n    if ((c != (int) '/') && (c != '\\n') &&\n        ((size_t) (p-command) < (MagickPathExtent-1)))\n      continue;\n    *p='\\0';\n    p=command;\n    /*\n      Is this a CMYK document?\n    */\n    if (LocaleNCompare(DeviceCMYK,command,strlen(DeviceCMYK)) == 0)\n      cmyk=MagickTrue;\n    if (LocaleNCompare(CropBox,command,strlen(CropBox)) == 0)\n      {\n        /*\n          Note region defined by crop box.\n        */\n        count=(ssize_t) sscanf(command,\"CropBox [%lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        if (count != 4)\n          count=(ssize_t) sscanf(command,\"CropBox[%lf %lf %lf %lf\",\n            &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n      }\n    if (LocaleNCompare(MediaBox,command,strlen(MediaBox)) == 0)\n      {\n        /*\n          Note region defined by media box.\n        */\n        count=(ssize_t) sscanf(command,\"MediaBox [%lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        if (count != 4)\n          count=(ssize_t) sscanf(command,\"MediaBox[%lf %lf %lf %lf\",\n            &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n      }\n    if (count != 4)\n      continue;\n    /*\n      Set PCL render geometry.\n    */\n    width=(size_t)CastDoubleToLong(floor(bounds.x2-bounds.x1+0.5));\n    height=(size_t)CastDoubleToLong(floor(bounds.y2-bounds.y1+0.5));\n    if (width > page.width)\n      page.width=width;\n    if (height > page.height)\n      page.height=height;\n  }\n  (void) CloseBlob(image);\n  /*\n    Render PCL with the GhostPCL delegate.\n  */\n  if ((page.width == 0) || (page.height == 0))\n    (void) ParseAbsoluteGeometry(PSPageGeometry,&page);\n  if (image_info->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(image_info->page,&page);\n  (void) FormatLocaleString(geometry,MagickPathExtent,\"%.20gx%.20g\",(double)\n    page.width,(double) page.height);\n  if (image_info->monochrome != MagickFalse)\n    delegate_info=GetDelegateInfo(\"pcl:mono\",(char *) NULL,exception);\n  else\n     if (cmyk != MagickFalse)\n       delegate_info=GetDelegateInfo(\"pcl:cmyk\",(char *) NULL,exception);\n     else\n       delegate_info=GetDelegateInfo(\"pcl:color\",(char *) NULL,exception);\n  if (delegate_info == (const DelegateInfo *) NULL)\n    {\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  if ((page.width == 0) || (page.height == 0))\n    (void) ParseAbsoluteGeometry(PSPageGeometry,&page);\n  if (image_info->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(image_info->page,&page);\n  density=AcquireString(\"\");\n  options=AcquireString(\"\");\n  (void) FormatLocaleString(density,MagickPathExtent,\"%gx%g\",\n    image->resolution.x,image->resolution.y);\n  if (image_info->ping != MagickFalse)\n    (void) FormatLocaleString(density,MagickPathExtent,\"2.0x2.0\");\n  page.width=(size_t) floor(page.width*image->resolution.x/delta.x+0.5);\n  page.height=(size_t) floor(page.height*image->resolution.y/delta.y+0.5);\n  (void) FormatLocaleString(options,MagickPathExtent,\"-g%.20gx%.20g \",(double)\n    page.width,(double) page.height);\n  image=DestroyImage(image);\n  read_info=CloneImageInfo(image_info);\n  *read_info->magick='\\0';\n  if (read_info->number_scenes != 0)\n    {\n      if (read_info->number_scenes != 1)\n        (void) FormatLocaleString(options,MagickPathExtent,\"-dLastPage=%.20g\",\n          (double) (read_info->scene+read_info->number_scenes));\n      else\n        (void) FormatLocaleString(options,MagickPathExtent,\n          \"-dFirstPage=%.20g -dLastPage=%.20g\",(double) read_info->scene+1,\n          (double) (read_info->scene+read_info->number_scenes));\n      read_info->number_scenes=0;\n      if (read_info->scenes != (char *) NULL)\n        *read_info->scenes='\\0';\n    }\n  (void) CopyMagickString(filename,read_info->filename,MagickPathExtent);\n  (void) AcquireUniqueFilename(read_info->filename);\n  (void) FormatLocaleString(command,MagickPathExtent,\n    GetDelegateCommands(delegate_info),\n    read_info->antialias != MagickFalse ? 4 : 1,\n    read_info->antialias != MagickFalse ? 4 : 1,density,options,\n    read_info->filename,input_filename);\n  options=DestroyString(options);\n  density=DestroyString(density);\n  status=ExternalDelegateCommand(MagickFalse,read_info->verbose,command,\n    (char *) NULL,exception) != 0 ? MagickTrue : MagickFalse;\n  image=ReadImage(read_info,exception);\n  (void) RelinquishUniqueFileResource(read_info->filename);\n  (void) RelinquishUniqueFileResource(input_filename);\n  read_info=DestroyImageInfo(read_info);\n  if (image == (Image *) NULL)\n    ThrowReaderException(DelegateError,\"PCLDelegateFailed\");\n  if (LocaleCompare(image->magick,\"BMP\") == 0)\n    {\n      Image\n        *cmyk_image;\n\n      cmyk_image=ConsolidateCMYKImages(image,exception);\n      if (cmyk_image != (Image *) NULL)\n        {\n          image=DestroyImageList(image);\n          image=cmyk_image;\n        }\n    }\n  do\n  {\n    (void) CopyMagickString(image->filename,filename,MagickPathExtent);\n    image->page=page;\n    if (image_info->ping != MagickFalse)\n      {\n        image->magick_columns*=image->resolution.x/2.0;\n        image->magick_rows*=image->resolution.y/2.0;\n        image->columns*=image->resolution.x/2.0;\n        image->rows*=image->resolution.y/2.0;\n      }\n    next_image=SyncNextImageInList(image);\n    if (next_image != (Image *) NULL)\n      image=next_image;\n  } while (next_image != (Image *) NULL);\n  return(GetFirstImageInList(image));\n}",
  "abstract_func": "static Image *ReadPCLImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)\n{\n#define VAR_2  \"CropBox\"\n#define VAR_3  \"DeviceCMYK\"\n#define VAR_4  \"MediaBox\"\n#define VAR_5  \"  Rendering PCL...  \"\n\n  char\n    VAR_6[VAR_7],\n    *VAR_8,\n    VAR_9[VAR_7],\n    VAR_10[VAR_7],\n    *VAR_11,\n    VAR_12[VAR_7];\n\n  const DelegateInfo\n    *VAR_13;\n\n  Image\n    *VAR_14,\n    *VAR_15;\n\n  ImageInfo\n    *VAR_16;\n\n  MagickBooleanType\n    VAR_17,\n    VAR_18;\n\n  PointInfo\n    VAR_19;\n\n  RectangleInfo\n    VAR_20,\n    VAR_21;\n\n  char\n    *VAR_22;\n\n  ssize_t\n    VAR_23;\n\n  SegmentInfo\n    VAR_24;\n\n  size_t\n    VAR_25,\n    VAR_26;\n\n  ssize_t\n    VAR_27;\n\n  assert(VAR_0 != (const ImageInfo *) NULL);\n  assert(VAR_0->signature == VAR_28);\n  if (VAR_0->debug != VAR_29)\n    (void) LogMagickEvent(VAR_30,GetMagickModule(),\"%s\",\n      VAR_0->filename);\n  assert(VAR_1 != (ExceptionInfo *) NULL);\n  assert(VAR_1->signature == VAR_28);\n  /* COMMENT_0 */\n                    \n    \n  VAR_14=AcquireImage(VAR_0,VAR_1);\n  VAR_18=OpenBlob(VAR_0,VAR_14,VAR_31,VAR_1);\n  if (VAR_18 == VAR_29)\n    {\n      VAR_14=DestroyImageList(VAR_14);\n      return((Image *) NULL);\n    }\n  VAR_18=AcquireUniqueSymbolicLink(VAR_0->filename,VAR_12);\n  if (VAR_18 == VAR_29)\n    {\n      ThrowFileException(VAR_1,VAR_32,\"UnableToCreateTemporaryFile\",\n        VAR_0->filename);\n      VAR_14=DestroyImageList(VAR_14);\n      return((Image *) NULL);\n    }\n  /* COMMENT_3 */\n                         \n    \n  VAR_19.x=VAR_33;\n  VAR_19.y=VAR_33;\n  if ((VAR_14->resolution.x == 0.0) || (VAR_14->resolution.y == 0.0))\n    {\n      GeometryInfo\n        VAR_34;\n\n      MagickStatusType\n        VAR_35;\n\n      VAR_35=ParseGeometry(VAR_36,&VAR_34);\n      if ((VAR_35 & VAR_37) != 0)\n        VAR_14->resolution.x=VAR_34.rho;\n      VAR_14->resolution.y=VAR_14->resolution.x;\n      if ((VAR_35 & VAR_38) != 0)\n        VAR_14->resolution.y=VAR_34.sigma;\n    }\n  /* COMMENT_6 */\n                                                   \n    \n  VAR_17=VAR_14->colorspace == VAR_39 ? VAR_40 : VAR_29;\n  VAR_27=0;\n  (void) memset(&VAR_20,0,sizeof(VAR_20));\n  (void) memset(&VAR_24,0,sizeof(VAR_24));\n  (void) memset(&VAR_21,0,sizeof(VAR_21));\n  (void) memset(VAR_6,0,sizeof(VAR_6));\n  VAR_22=VAR_6;\n  for (VAR_23=ReadBlobByte(VAR_14); VAR_23 != VAR_41; VAR_23=ReadBlobByte(VAR_14))\n  {\n    if (VAR_0->page != (char *) NULL)\n      continue;\n    /* COMMENT_9 */\n                        \n      \n    *VAR_22++=(char) VAR_23;\n    if ((VAR_23 != (int) '/') && (VAR_23 != '\\n') &&\n        ((size_t) (VAR_22-VAR_6) < (VAR_7-1)))\n      continue;\n    *VAR_22='\\0';\n    VAR_22=VAR_6;\n    /* COMMENT_12 */\n                              \n      \n    if (LocaleNCompare(VAR_3,VAR_6,strlen(VAR_3)) == 0)\n      VAR_17=VAR_40;\n    if (LocaleNCompare(VAR_2,VAR_6,strlen(VAR_2)) == 0)\n      {\n        /* COMMENT_15 */\n                                          \n          \n        VAR_27=(ssize_t) sscanf(VAR_6,\"CropBox [%lf %lf %lf %lf\",\n          &VAR_24.x1,&VAR_24.y1,&VAR_24.x2,&VAR_24.y2);\n        if (VAR_27 != 4)\n          VAR_27=(ssize_t) sscanf(VAR_6,\"CropBox[%lf %lf %lf %lf\",\n            &VAR_24.x1,&VAR_24.y1,&VAR_24.x2,&VAR_24.y2);\n      }\n    if (LocaleNCompare(VAR_4,VAR_6,strlen(VAR_4)) == 0)\n      {\n        /* COMMENT_18 */\n                                           \n          \n        VAR_27=(ssize_t) sscanf(VAR_6,\"MediaBox [%lf %lf %lf %lf\",\n          &VAR_24.x1,&VAR_24.y1,&VAR_24.x2,&VAR_24.y2);\n        if (VAR_27 != 4)\n          VAR_27=(ssize_t) sscanf(VAR_6,\"MediaBox[%lf %lf %lf %lf\",\n            &VAR_24.x1,&VAR_24.y1,&VAR_24.x2,&VAR_24.y2);\n      }\n    if (VAR_27 != 4)\n      continue;\n    /* COMMENT_21 */\n                              \n      \n    VAR_26=(size_t)CastDoubleToLong(floor(VAR_24.x2-VAR_24.x1+0.5));\n    VAR_25=(size_t)CastDoubleToLong(floor(VAR_24.y2-VAR_24.y1+0.5));\n    if (VAR_26 > VAR_21.width)\n      VAR_21.width=VAR_26;\n    if (VAR_25 > VAR_21.height)\n      VAR_21.height=VAR_25;\n  }\n  (void) CloseBlob(VAR_14);\n  /* COMMENT_24 */\n                                          \n    \n  if ((VAR_21.width == 0) || (VAR_21.height == 0))\n    (void) ParseAbsoluteGeometry(VAR_42,&VAR_21);\n  if (VAR_0->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(VAR_0->page,&VAR_21);\n  (void) FormatLocaleString(VAR_10,VAR_7,\"%.20gx%.20g\",(double)\n    VAR_21.width,(double) VAR_21.height);\n  if (VAR_0->monochrome != VAR_29)\n    VAR_13=GetDelegateInfo(\"pcl:mono\",(char *) NULL,VAR_1);\n  else\n     if (VAR_17 != VAR_29)\n       VAR_13=GetDelegateInfo(\"pcl:cmyk\",(char *) NULL,VAR_1);\n     else\n       VAR_13=GetDelegateInfo(\"pcl:color\",(char *) NULL,VAR_1);\n  if (VAR_13 == (const DelegateInfo *) NULL)\n    {\n      VAR_14=DestroyImage(VAR_14);\n      return((Image *) NULL);\n    }\n  if ((VAR_21.width == 0) || (VAR_21.height == 0))\n    (void) ParseAbsoluteGeometry(VAR_42,&VAR_21);\n  if (VAR_0->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(VAR_0->page,&VAR_21);\n  VAR_8=AcquireString(\"\");\n  VAR_11=AcquireString(\"\");\n  (void) FormatLocaleString(VAR_8,VAR_7,\"%gx%g\",\n    VAR_14->resolution.x,VAR_14->resolution.y);\n  if (VAR_0->ping != VAR_29)\n    (void) FormatLocaleString(VAR_8,VAR_7,\"2.0x2.0\");\n  VAR_21.width=(size_t) floor(VAR_21.width*VAR_14->resolution.x/VAR_19.x+0.5);\n  VAR_21.height=(size_t) floor(VAR_21.height*VAR_14->resolution.y/VAR_19.y+0.5);\n  (void) FormatLocaleString(VAR_11,VAR_7,\"-g%.20gx%.20g \",(double)\n    VAR_21.width,(double) VAR_21.height);\n  VAR_14=DestroyImage(VAR_14);\n  VAR_16=CloneImageInfo(VAR_0);\n  *VAR_16->magick='\\0';\n  if (VAR_16->number_scenes != 0)\n    {\n      if (VAR_16->number_scenes != 1)\n        (void) FormatLocaleString(VAR_11,VAR_7,\"-dLastPage=%.20g\",\n          (double) (VAR_16->scene+VAR_16->number_scenes));\n      else\n        (void) FormatLocaleString(VAR_11,VAR_7,\n          \"-dFirstPage=%.20g -dLastPage=%.20g\",(double) VAR_16->scene+1,\n          (double) (VAR_16->scene+VAR_16->number_scenes));\n      VAR_16->number_scenes=0;\n      if (VAR_16->scenes != (char *) NULL)\n        *VAR_16->scenes='\\0';\n    }\n  (void) CopyMagickString(VAR_9,VAR_16->filename,VAR_7);\n  (void) AcquireUniqueFilename(VAR_16->filename);\n  (void) FormatLocaleString(VAR_6,VAR_7,\n    GetDelegateCommands(VAR_13),\n    VAR_16->antialias != VAR_29 ? 4 : 1,\n    VAR_16->antialias != VAR_29 ? 4 : 1,VAR_8,VAR_11,\n    VAR_16->filename,VAR_12);\n  VAR_11=DestroyString(VAR_11);\n  VAR_8=DestroyString(VAR_8);\n  VAR_18=ExternalDelegateCommand(VAR_29,VAR_16->verbose,VAR_6,\n    (char *) NULL,VAR_1) != 0 ? VAR_40 : VAR_29;\n  VAR_14=ReadImage(VAR_16,VAR_1);\n  (void) RelinquishUniqueFileResource(VAR_16->filename);\n  (void) RelinquishUniqueFileResource(VAR_12);\n  VAR_16=DestroyImageInfo(VAR_16);\n  if (VAR_14 == (Image *) NULL)\n    ThrowReaderException(VAR_43,\"PCLDelegateFailed\");\n  if (LocaleCompare(VAR_14->magick,\"BMP\") == 0)\n    {\n      Image\n        *VAR_44;\n\n      VAR_44=ConsolidateCMYKImages(VAR_14,VAR_1);\n      if (VAR_44 != (Image *) NULL)\n        {\n          VAR_14=DestroyImageList(VAR_14);\n          VAR_14=VAR_44;\n        }\n    }\n  do\n  {\n    (void) CopyMagickString(VAR_14->filename,VAR_9,VAR_7);\n    VAR_14->page=VAR_21;\n    if (VAR_0->ping != VAR_29)\n      {\n        VAR_14->magick_columns*=VAR_14->resolution.x/2.0;\n        VAR_14->magick_rows*=VAR_14->resolution.y/2.0;\n        VAR_14->columns*=VAR_14->resolution.x/2.0;\n        VAR_14->rows*=VAR_14->resolution.y/2.0;\n      }\n    VAR_15=SyncNextImageInList(VAR_14);\n    if (VAR_15 != (Image *) NULL)\n      VAR_14=VAR_15;\n  } while (VAR_15 != (Image *) NULL);\n  return(GetFirstImageInList(VAR_14));\n}",
  "func_graph_path": "ImageMagick/f221ea0fa3171f0f4fdf74ac9d81b203b9534c23/pcl.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -150,8 +150,8 @@\n     /*\n       Set PCL render geometry.\n     */\n-    width=(size_t) floor(bounds.x2-bounds.x1+0.5);\n-    height=(size_t) floor(bounds.y2-bounds.y1+0.5);\n+    width=(size_t)CastDoubleToLong(floor(bounds.x2-bounds.x1+0.5));\n+    height=(size_t)CastDoubleToLong(floor(bounds.y2-bounds.y1+0.5));\n     if (width > page.width)\n       page.width=width;\n     if (height > page.height)",
  "diff_line_info": {
    "deleted_lines": [
      "    width=(size_t) floor(bounds.x2-bounds.x1+0.5);",
      "    height=(size_t) floor(bounds.y2-bounds.y1+0.5);"
    ],
    "added_lines": [
      "    width=(size_t)CastDoubleToLong(floor(bounds.x2-bounds.x1+0.5));",
      "    height=(size_t)CastDoubleToLong(floor(bounds.y2-bounds.y1+0.5));"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/ImageMagick/ImageMagick/pull/4986",
  "description": {
    "pr_info": {
      "title": "Fixes #4985: 4e+26 is outside the range of representable values of type 'unsigned long' at coders/pcl.c:299",
      "number": 4986
    },
    "comment": [
      "### Prerequisites\r\n\r\n- [Y] I have written a descriptive pull-request title\r\n- [Y] I have verified that there are no overlapping [pull-requests](https://github.com/ImageMagick/ImageMagick/pulls) open\r\n- [Y] I have verified that I am following the existing coding patterns and practices as demonstrated in the repository.\r\n\r\n### Description\r\nFixes #4985: 4e+26 is outside the range of representable values of type 'unsigned long' at coders/pcl.c:299"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.8  \n\nThe changes address issues like division by zero and overflow, which can lead to security vulnerabilities, though without explicit CVE references, the confidence is moderate."
}