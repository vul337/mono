{
  "cve_id": "CVE-2022-26181",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "dropbox/lepton",
  "commit_msg": "Fix wild free.\n\n`huffdata` is initially allocated using `aligned_dealloc` but can be\nreplaced with `data2` which is allocated using `custom_calloc`.\nThis can cause a wild free when `aligned_dealloc(huffdata)` is called.\nFix by replacing allocation sites with aligned_alloc.\n\nNoticed and fixed a similar problem with `hdrdata`.",
  "commit_hash": "4e591ffd0127ac064c4749e523458a923b29cc75",
  "git_url": "https://github.com/dropbox/lepton/commit/4e591ffd0127ac064c4749e523458a923b29cc75",
  "file_path": "src/lepton/bitops.hh",
  "func_name": "write",
  "func_before": "void write( unsigned int val, int nbits )\n    {\n\n        int nbits2 = nbits;\n        unsigned int val2 = val;\n        dev_assert(nbits <= 64);\n        if ( __builtin_expect(cbyte2 > ( dsize - 16 ), false) ) {\n            if (bound_reached()) {\n                return;\n            }\n            if (adds < 4096 * 1024) {\n                adds <<= 1;\n            }\n            int new_size = dsize + adds;\n            unsigned char * tmp = (unsigned char*)custom_malloc(new_size);\n            if ( tmp == NULL ) {\n                error = true;\n                custom_exit(ExitCode::MALLOCED_NULL);\n                return;\n            }\n            memset(tmp + dsize, 0, adds);\n            memcpy(tmp, data2, dsize);\n            custom_free(data2);\n            data2 = tmp;\n            dsize = new_size;\n        }\n\n        // write data\n        if ( nbits2 >= cbit2 ) {\n\n            buf |= MBITS64(val2, nbits2, (nbits2-cbit2));\n            nbits2 -= cbit2;\n            cbit2 = 0;\n            flush_no_pad();\n        }\n        if ( nbits2 > 0 ) {\n            uint64_t tmp = (RBITS64(val2, nbits2));\n            if (__builtin_expect(cbit2 < nbits2, 0)) {\n                cbit2 = 0;\n            } else {\n                tmp <<= cbit2 - nbits2;\n                buf |= tmp;\n                cbit2 -= nbits2;\n            }\n        }\n\n\n\n    }",
  "abstract_func_before": "void write( unsigned int VAR_0, int VAR_1 )\n    {\n\n        int VAR_2 = VAR_1;\n        unsigned int VAR_3 = VAR_0;\n        dev_assert(VAR_1 <= 64);\n        if ( __builtin_expect(VAR_4 > ( VAR_5 - 16 ), false) ) {\n            if (bound_reached()) {\n                return;\n            }\n            if (VAR_6 < 4096 * 1024) {\n                VAR_6 <<= 1;\n            }\n            int VAR_7 = VAR_5 + VAR_6;\n            unsigned char * VAR_8 = (unsigned char*)custom_malloc(VAR_7);\n            if ( VAR_8 == NULL ) {\n                VAR_9 = true;\n                custom_exit(ExitCode::MALLOCED_NULL);\n                return;\n            }\n            memset(VAR_8 + VAR_5, 0, VAR_6);\n            memcpy(VAR_8, VAR_10, VAR_5);\n            custom_free(VAR_10);\n            VAR_10 = VAR_8;\n            VAR_5 = VAR_7;\n        }\n\n        /* COMMENT_0 */\n        if ( VAR_2 >= VAR_11 ) {\n\n            VAR_12 |= MBITS64(VAR_3, VAR_2, (VAR_2-VAR_11));\n            VAR_2 -= VAR_11;\n            VAR_11 = 0;\n            flush_no_pad();\n        }\n        if ( VAR_2 > 0 ) {\n            uint64_t VAR_8 = (RBITS64(VAR_3, VAR_2));\n            if (__builtin_expect(VAR_11 < VAR_2, 0)) {\n                VAR_11 = 0;\n            } else {\n                VAR_8 <<= VAR_11 - VAR_2;\n                VAR_12 |= VAR_8;\n                VAR_11 -= VAR_2;\n            }\n        }\n\n\n\n    }",
  "func_graph_path_before": "dropbox/lepton/4e591ffd0127ac064c4749e523458a923b29cc75/bitops.hh/vul/before/0.json",
  "func": "void write( unsigned int val, int nbits )\n    {\n\n        int nbits2 = nbits;\n        unsigned int val2 = val;\n        dev_assert(nbits <= 64);\n        if ( __builtin_expect(cbyte2 > ( dsize - 16 ), false) ) {\n            if (bound_reached()) {\n                return;\n            }\n            if (adds < 4096 * 1024) {\n                adds <<= 1;\n            }\n            int new_size = dsize + adds;\n            unsigned char * tmp = aligned_alloc(new_size);\n            if ( tmp == NULL ) {\n                error = true;\n                custom_exit(ExitCode::MALLOCED_NULL);\n                return;\n            }\n            memset(tmp + dsize, 0, adds);\n            memcpy(tmp, data2, dsize);\n            aligned_dealloc(data2);\n            data2 = tmp;\n            dsize = new_size;\n        }\n\n        // write data\n        if ( nbits2 >= cbit2 ) {\n\n            buf |= MBITS64(val2, nbits2, (nbits2-cbit2));\n            nbits2 -= cbit2;\n            cbit2 = 0;\n            flush_no_pad();\n        }\n        if ( nbits2 > 0 ) {\n            uint64_t tmp = (RBITS64(val2, nbits2));\n            if (__builtin_expect(cbit2 < nbits2, 0)) {\n                cbit2 = 0;\n            } else {\n                tmp <<= cbit2 - nbits2;\n                buf |= tmp;\n                cbit2 -= nbits2;\n            }\n        }\n\n\n\n    }",
  "abstract_func": "void write( unsigned int VAR_0, int VAR_1 )\n    {\n\n        int VAR_2 = VAR_1;\n        unsigned int VAR_3 = VAR_0;\n        dev_assert(VAR_1 <= 64);\n        if ( __builtin_expect(VAR_4 > ( VAR_5 - 16 ), false) ) {\n            if (bound_reached()) {\n                return;\n            }\n            if (VAR_6 < 4096 * 1024) {\n                VAR_6 <<= 1;\n            }\n            int VAR_7 = VAR_5 + VAR_6;\n            unsigned char * VAR_8 = aligned_alloc(VAR_7);\n            if ( VAR_8 == NULL ) {\n                VAR_9 = true;\n                custom_exit(ExitCode::MALLOCED_NULL);\n                return;\n            }\n            memset(VAR_8 + VAR_5, 0, VAR_6);\n            memcpy(VAR_8, VAR_10, VAR_5);\n            aligned_dealloc(VAR_10);\n            VAR_10 = VAR_8;\n            VAR_5 = VAR_7;\n        }\n\n        /* COMMENT_0 */\n        if ( VAR_2 >= VAR_11 ) {\n\n            VAR_12 |= MBITS64(VAR_3, VAR_2, (VAR_2-VAR_11));\n            VAR_2 -= VAR_11;\n            VAR_11 = 0;\n            flush_no_pad();\n        }\n        if ( VAR_2 > 0 ) {\n            uint64_t VAR_8 = (RBITS64(VAR_3, VAR_2));\n            if (__builtin_expect(VAR_11 < VAR_2, 0)) {\n                VAR_11 = 0;\n            } else {\n                VAR_8 <<= VAR_11 - VAR_2;\n                VAR_12 |= VAR_8;\n                VAR_11 -= VAR_2;\n            }\n        }\n\n\n\n    }",
  "func_graph_path": "dropbox/lepton/4e591ffd0127ac064c4749e523458a923b29cc75/bitops.hh/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -12,7 +12,7 @@\n                 adds <<= 1;\n             }\n             int new_size = dsize + adds;\n-            unsigned char * tmp = (unsigned char*)custom_malloc(new_size);\n+            unsigned char * tmp = aligned_alloc(new_size);\n             if ( tmp == NULL ) {\n                 error = true;\n                 custom_exit(ExitCode::MALLOCED_NULL);\n@@ -20,7 +20,7 @@\n             }\n             memset(tmp + dsize, 0, adds);\n             memcpy(tmp, data2, dsize);\n-            custom_free(data2);\n+            aligned_dealloc(data2);\n             data2 = tmp;\n             dsize = new_size;\n         }",
  "diff_line_info": {
    "deleted_lines": [
      "            unsigned char * tmp = (unsigned char*)custom_malloc(new_size);",
      "            custom_free(data2);"
    ],
    "added_lines": [
      "            unsigned char * tmp = aligned_alloc(new_size);",
      "            aligned_dealloc(data2);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/dropbox/lepton/pull/155",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/dropbox/lepton/pull/155: 403 Client Error: Forbidden for url: https://api.github.com/repos/dropbox/lepton/pulls/155",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95"
}