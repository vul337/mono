{
  "cve_id": "CVE-2023-42459",
  "cwe_ids": [
    "CWE-415",
    "CWE-416",
    "CWE-590"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "eProsima/Fast-DDS",
  "commit_msg": "Refs #16784. Fix issue.\n\nSigned-off-by: Miguel Company <MiguelCompany@eprosima.com>",
  "commit_hash": "6fdbe790fe814c8799860bf896742bae58b7bf35",
  "git_url": "https://github.com/eProsima/Fast-DDS/commit/6fdbe790fe814c8799860bf896742bae58b7bf35",
  "file_path": "src/cpp/rtps/messages/MessageReceiver.cpp",
  "func_name": "MessageReceiver::proc_Submsg_Data",
  "func_before": "bool MessageReceiver::proc_Submsg_Data(\n        CDRMessage_t* msg,\n        SubmessageHeader_t* smh,\n        EntityId_t& writerID) const\n{\n    eprosima::shared_lock<eprosima::shared_mutex> guard(mtx_);\n\n    //READ and PROCESS\n    if (smh->submessageLength < RTPSMESSAGE_DATA_MIN_LENGTH)\n    {\n        EPROSIMA_LOG_INFO(RTPS_MSG_IN, IDSTRING \"Too short submessage received, ignoring\");\n        return false;\n    }\n    //Fill flags bool values\n    bool endiannessFlag = (smh->flags & BIT(0)) != 0;\n    bool inlineQosFlag = (smh->flags & BIT(1)) != 0;\n    bool dataFlag = (smh->flags & BIT(2)) != 0;\n    bool keyFlag = (smh->flags & BIT(3)) != 0;\n    if (keyFlag && dataFlag)\n    {\n        EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Message received with Data and Key Flag set, ignoring\");\n        return false;\n    }\n\n    //Assign message endianness\n    if (endiannessFlag)\n    {\n        msg->msg_endian = LITTLEEND;\n    }\n    else\n    {\n        msg->msg_endian = BIGEND;\n    }\n\n    //Extra flags don't matter now. Avoid those bytes\n    msg->pos += 2;\n\n    bool valid = true;\n    int16_t octetsToInlineQos = 0;\n    valid &= CDRMessage::readInt16(msg, &octetsToInlineQos); //it should be 16 in this implementation\n\n    //reader and writer ID\n    RTPSReader* first_reader = nullptr;\n    EntityId_t readerID;\n    valid &= CDRMessage::readEntityId(msg, &readerID);\n\n    //WE KNOW THE READER THAT THE MESSAGE IS DIRECTED TO SO WE LOOK FOR IT:\n    if (!willAReaderAcceptMsgDirectedTo(readerID, first_reader))\n    {\n        return false;\n    }\n\n    //FOUND THE READER.\n    //We ask the reader for a cachechange to store the information.\n    CacheChange_t ch;\n    ch.kind = ALIVE;\n    ch.writerGUID.guidPrefix = source_guid_prefix_;\n    valid &= CDRMessage::readEntityId(msg, &ch.writerGUID.entityId);\n\n    writerID = ch.writerGUID.entityId;\n\n    //Get sequence number\n    valid &= CDRMessage::readSequenceNumber(msg, &ch.sequenceNumber);\n\n    if (!valid)\n    {\n        return false;\n    }\n\n    if (ch.sequenceNumber <= SequenceNumber_t())\n    {\n        EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Invalid message received, bad sequence Number\");\n        return false;\n    }\n\n    //Jump ahead if more parameters are before inlineQos (not in this version, maybe if further minor versions.)\n    if (octetsToInlineQos > RTPSMESSAGE_OCTETSTOINLINEQOS_DATASUBMSG)\n    {\n        msg->pos += (octetsToInlineQos - RTPSMESSAGE_OCTETSTOINLINEQOS_DATASUBMSG);\n        if (msg->pos > msg->length)\n        {\n            EPROSIMA_LOG_WARNING(RTPS_MSG_IN,\n                    IDSTRING \"Invalid jump through msg, msg->pos \" << msg->pos << \" > msg->length \" << msg->length);\n            return false;\n        }\n    }\n\n    uint32_t inlineQosSize = 0;\n\n    if (inlineQosFlag)\n    {\n        if (!ParameterList::updateCacheChangeFromInlineQos(ch, msg, inlineQosSize))\n        {\n            EPROSIMA_LOG_INFO(RTPS_MSG_IN, IDSTRING \"SubMessage Data ERROR, Inline Qos ParameterList error\");\n            return false;\n        }\n        ch.inline_qos.data = &msg->buffer[msg->pos - inlineQosSize];\n        ch.inline_qos.max_size = inlineQosSize;\n        ch.inline_qos.length = inlineQosSize;\n        ch.inline_qos.encapsulation = endiannessFlag ? PL_CDR_LE : PL_CDR_BE;\n        ch.inline_qos.pos = 0;\n    }\n\n    if (dataFlag || keyFlag)\n    {\n        uint32_t payload_size;\n        payload_size = smh->submessageLength -\n                (RTPSMESSAGE_DATA_EXTRA_INLINEQOS_SIZE + octetsToInlineQos + inlineQosSize);\n\n        if (dataFlag)\n        {\n            uint32_t next_pos = msg->pos + payload_size;\n            if (msg->length >= next_pos && payload_size > 0)\n            {\n                ch.serializedPayload.data = &msg->buffer[msg->pos];\n                ch.serializedPayload.length = payload_size;\n                ch.serializedPayload.max_size = payload_size;\n                msg->pos = next_pos;\n            }\n            else\n            {\n                EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Serialized Payload value invalid or larger than maximum allowed size\"\n                        \"(\" << payload_size << \"/\" << (msg->length - msg->pos) << \")\");\n                return false;\n            }\n        }\n        else if (keyFlag)\n        {\n            if (payload_size <= 0)\n            {\n                EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Serialized Payload value invalid (\" << payload_size << \")\");\n                return false;\n            }\n\n            if (payload_size <= PARAMETER_KEY_HASH_LENGTH)\n            {\n                memcpy(ch.instanceHandle.value, &msg->buffer[msg->pos], payload_size);\n            }\n            else\n            {\n                EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Ignoring Serialized Payload for too large key-only data (\" <<\n                        payload_size << \")\");\n            }\n            msg->pos += payload_size;\n        }\n    }\n\n    // Set sourcetimestamp\n    if (have_timestamp_)\n    {\n        ch.sourceTimestamp = timestamp_;\n    }\n\n    EPROSIMA_LOG_INFO(RTPS_MSG_IN, IDSTRING \"from Writer \" << ch.writerGUID << \"; possible RTPSReader entities: \" <<\n            associated_readers_.size());\n\n    //Look for the correct reader to add the change\n    process_data_message_function_(readerID, ch);\n\n    IPayloadPool* payload_pool = ch.payload_owner();\n    if (payload_pool)\n    {\n        payload_pool->release_payload(ch);\n    }\n\n    //TODO(Ricardo) If an exception is thrown (ex, by fastcdr), these lines are not executed -> segmentation fault\n    ch.serializedPayload.data = nullptr;\n    ch.inline_qos.data = nullptr;\n\n    EPROSIMA_LOG_INFO(RTPS_MSG_IN, IDSTRING \"Sub Message DATA processed\");\n    return true;\n}",
  "abstract_func_before": "bool MessageReceiver::proc_Submsg_Data(\n        CDRMessage_t* VAR_0,\n        SubmessageHeader_t* VAR_1,\n        EntityId_t& VAR_2) const\n{\n    eprosima::shared_lock<eprosima::shared_mutex> guard(mtx_);\n\n    /* COMMENT_0 */\n    if (VAR_1->submessageLength < VAR_3)\n    {\n        EPROSIMA_LOG_INFO(VAR_4, VAR_5 \"Too short submessage received, ignoring\");\n        return false;\n    }\n    /* COMMENT_1 */\n    bool VAR_6 = (VAR_1->flags & BIT(0)) != 0;\n    bool VAR_7 = (VAR_1->flags & BIT(1)) != 0;\n    bool VAR_8 = (VAR_1->flags & BIT(2)) != 0;\n    bool VAR_9 = (VAR_1->flags & BIT(3)) != 0;\n    if (VAR_9 && VAR_8)\n    {\n        EPROSIMA_LOG_WARNING(VAR_4, VAR_5 \"Message received with Data and Key Flag set, ignoring\");\n        return false;\n    }\n\n    /* COMMENT_2 */\n    if (VAR_6)\n    {\n        VAR_0->msg_endian = VAR_10;\n    }\n    else\n    {\n        VAR_0->msg_endian = VAR_11;\n    }\n\n    /* COMMENT_3 */\n    VAR_0->pos += 2;\n\n    bool VAR_12 = true;\n    int16_t VAR_13 = 0;\n    VAR_12 &= CDRMessage::readInt16(VAR_0, &VAR_13); /* COMMENT_4 */\n\n    /* COMMENT_5 */\n    RTPSReader* VAR_14 = nullptr;\n    EntityId_t VAR_15;\n    VAR_12 &= CDRMessage::readEntityId(VAR_0, &VAR_15);\n\n    /* COMMENT_6 */\n    if (!willAReaderAcceptMsgDirectedTo(VAR_15, VAR_14))\n    {\n        return false;\n    }\n\n    /* COMMENT_7 */\n    /* COMMENT_8 */\n    CacheChange_t VAR_16;\n    VAR_16.kind = VAR_17;\n    VAR_16.writerGUID.guidPrefix = VAR_18;\n    VAR_12 &= CDRMessage::readEntityId(VAR_0, &VAR_16.writerGUID.entityId);\n\n    VAR_2 = VAR_16.writerGUID.entityId;\n\n    /* COMMENT_9 */\n    VAR_12 &= CDRMessage::readSequenceNumber(VAR_0, &VAR_16.sequenceNumber);\n\n    if (!VAR_12)\n    {\n        return false;\n    }\n\n    if (VAR_16.sequenceNumber <= SequenceNumber_t())\n    {\n        EPROSIMA_LOG_WARNING(VAR_4, VAR_5 \"Invalid message received, bad sequence Number\");\n        return false;\n    }\n\n    /* COMMENT_10 */\n    if (VAR_13 > VAR_19)\n    {\n        VAR_0->pos += (VAR_13 - VAR_19);\n        if (VAR_0->pos > VAR_0->length)\n        {\n            EPROSIMA_LOG_WARNING(VAR_4,\n                    VAR_5 \"Invalid jump through msg, msg->pos \" << VAR_0->pos << \" > msg->length \" << VAR_0->length);\n            return false;\n        }\n    }\n\n    uint32_t VAR_20 = 0;\n\n    if (VAR_7)\n    {\n        if (!ParameterList::updateCacheChangeFromInlineQos(VAR_16, VAR_0, VAR_20))\n        {\n            EPROSIMA_LOG_INFO(VAR_4, VAR_5 \"SubMessage Data ERROR, Inline Qos ParameterList error\");\n            return false;\n        }\n        VAR_16.inline_qos.data = &VAR_0->buffer[VAR_0->pos - VAR_20];\n        VAR_16.inline_qos.max_size = VAR_20;\n        VAR_16.inline_qos.length = VAR_20;\n        VAR_16.inline_qos.encapsulation = VAR_6 ? VAR_21 : VAR_22;\n        VAR_16.inline_qos.pos = 0;\n    }\n\n    if (VAR_8 || VAR_9)\n    {\n        uint32_t VAR_23;\n        VAR_23 = VAR_1->submessageLength -\n                (VAR_24 + VAR_13 + VAR_20);\n\n        if (VAR_8)\n        {\n            uint32_t VAR_25 = VAR_0->pos + VAR_23;\n            if (VAR_0->length >= VAR_25 && VAR_23 > 0)\n            {\n                VAR_16.serializedPayload.data = &VAR_0->buffer[VAR_0->pos];\n                VAR_16.serializedPayload.length = VAR_23;\n                VAR_16.serializedPayload.max_size = VAR_23;\n                VAR_0->pos = VAR_25;\n            }\n            else\n            {\n                EPROSIMA_LOG_WARNING(VAR_4, VAR_5 \"Serialized Payload value invalid or larger than maximum allowed size\"\n                        \"(\" << VAR_23 << \"/\" << (VAR_0->length - VAR_0->pos) << \")\");\n                return false;\n            }\n        }\n        else if (VAR_9)\n        {\n            if (VAR_23 <= 0)\n            {\n                EPROSIMA_LOG_WARNING(VAR_4, VAR_5 \"Serialized Payload value invalid (\" << VAR_23 << \")\");\n                return false;\n            }\n\n            if (VAR_23 <= VAR_26)\n            {\n                memcpy(VAR_16.instanceHandle.value, &VAR_0->buffer[VAR_0->pos], VAR_23);\n            }\n            else\n            {\n                EPROSIMA_LOG_WARNING(VAR_4, VAR_5 \"Ignoring Serialized Payload for too large key-only data (\" <<\n                        VAR_23 << \")\");\n            }\n            VAR_0->pos += VAR_23;\n        }\n    }\n\n    /* COMMENT_11 */\n    if (VAR_27)\n    {\n        VAR_16.sourceTimestamp = VAR_28;\n    }\n\n    EPROSIMA_LOG_INFO(VAR_4, VAR_5 \"from Writer \" << VAR_16.writerGUID << \"; possible RTPSReader entities: \" <<\n            VAR_29.size());\n\n    /* COMMENT_12 */\n    process_data_message_function_(VAR_15, VAR_16);\n\n    IPayloadPool* VAR_30 = VAR_16.payload_owner();\n    if (VAR_30)\n    {\n        VAR_30->release_payload(VAR_16);\n    }\n\n    /* COMMENT_13 */\n    VAR_16.serializedPayload.data = nullptr;\n    VAR_16.inline_qos.data = nullptr;\n\n    EPROSIMA_LOG_INFO(VAR_4, VAR_5 \"Sub Message DATA processed\");\n    return true;\n}",
  "func_graph_path_before": "eProsima/Fast-DDS/6fdbe790fe814c8799860bf896742bae58b7bf35/MessageReceiver.cpp/vul/before/0.json",
  "func": "bool MessageReceiver::proc_Submsg_Data(\n        CDRMessage_t* msg,\n        SubmessageHeader_t* smh,\n        EntityId_t& writerID) const\n{\n    eprosima::shared_lock<eprosima::shared_mutex> guard(mtx_);\n\n    //READ and PROCESS\n    if (smh->submessageLength < RTPSMESSAGE_DATA_MIN_LENGTH)\n    {\n        EPROSIMA_LOG_INFO(RTPS_MSG_IN, IDSTRING \"Too short submessage received, ignoring\");\n        return false;\n    }\n    //Fill flags bool values\n    bool endiannessFlag = (smh->flags & BIT(0)) != 0;\n    bool inlineQosFlag = (smh->flags & BIT(1)) != 0;\n    bool dataFlag = (smh->flags & BIT(2)) != 0;\n    bool keyFlag = (smh->flags & BIT(3)) != 0;\n    if (keyFlag && dataFlag)\n    {\n        EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Message received with Data and Key Flag set, ignoring\");\n        return false;\n    }\n\n    //Assign message endianness\n    if (endiannessFlag)\n    {\n        msg->msg_endian = LITTLEEND;\n    }\n    else\n    {\n        msg->msg_endian = BIGEND;\n    }\n\n    //Extra flags don't matter now. Avoid those bytes\n    msg->pos += 2;\n\n    bool valid = true;\n    int16_t octetsToInlineQos = 0;\n    valid &= CDRMessage::readInt16(msg, &octetsToInlineQos); //it should be 16 in this implementation\n\n    //reader and writer ID\n    RTPSReader* first_reader = nullptr;\n    EntityId_t readerID;\n    valid &= CDRMessage::readEntityId(msg, &readerID);\n\n    //WE KNOW THE READER THAT THE MESSAGE IS DIRECTED TO SO WE LOOK FOR IT:\n    if (!willAReaderAcceptMsgDirectedTo(readerID, first_reader))\n    {\n        return false;\n    }\n\n    //FOUND THE READER.\n    //We ask the reader for a cachechange to store the information.\n    CacheChange_t ch;\n    ch.kind = ALIVE;\n    ch.writerGUID.guidPrefix = source_guid_prefix_;\n    valid &= CDRMessage::readEntityId(msg, &ch.writerGUID.entityId);\n\n    writerID = ch.writerGUID.entityId;\n\n    //Get sequence number\n    valid &= CDRMessage::readSequenceNumber(msg, &ch.sequenceNumber);\n\n    if (!valid)\n    {\n        return false;\n    }\n\n    if (ch.sequenceNumber <= SequenceNumber_t())\n    {\n        EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Invalid message received, bad sequence Number\");\n        return false;\n    }\n\n    //Jump ahead if more parameters are before inlineQos (not in this version, maybe if further minor versions.)\n    if (octetsToInlineQos > RTPSMESSAGE_OCTETSTOINLINEQOS_DATASUBMSG)\n    {\n        msg->pos += (octetsToInlineQos - RTPSMESSAGE_OCTETSTOINLINEQOS_DATASUBMSG);\n        if (msg->pos > msg->length)\n        {\n            EPROSIMA_LOG_WARNING(RTPS_MSG_IN,\n                    IDSTRING \"Invalid jump through msg, msg->pos \" << msg->pos << \" > msg->length \" << msg->length);\n            return false;\n        }\n    }\n\n    uint32_t inlineQosSize = 0;\n\n    if (inlineQosFlag)\n    {\n        if (!ParameterList::updateCacheChangeFromInlineQos(ch, msg, inlineQosSize))\n        {\n            EPROSIMA_LOG_INFO(RTPS_MSG_IN, IDSTRING \"SubMessage Data ERROR, Inline Qos ParameterList error\");\n            return false;\n        }\n        ch.inline_qos.data = &msg->buffer[msg->pos - inlineQosSize];\n        ch.inline_qos.max_size = inlineQosSize;\n        ch.inline_qos.length = inlineQosSize;\n        ch.inline_qos.encapsulation = endiannessFlag ? PL_CDR_LE : PL_CDR_BE;\n        ch.inline_qos.pos = 0;\n    }\n\n    if (dataFlag || keyFlag)\n    {\n        uint32_t payload_size;\n        payload_size = smh->submessageLength -\n                (RTPSMESSAGE_DATA_EXTRA_INLINEQOS_SIZE + octetsToInlineQos + inlineQosSize);\n\n        if (dataFlag)\n        {\n            uint32_t next_pos = msg->pos + payload_size;\n            if (msg->length >= next_pos && payload_size > 0)\n            {\n                ch.serializedPayload.data = &msg->buffer[msg->pos];\n                ch.serializedPayload.length = payload_size;\n                ch.serializedPayload.max_size = payload_size;\n                msg->pos = next_pos;\n            }\n            else\n            {\n                EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Serialized Payload value invalid or larger than maximum allowed size\"\n                        \"(\" << payload_size << \"/\" << (msg->length - msg->pos) << \")\");\n                ch.serializedPayload.data = nullptr;\n                ch.inline_qos.data = nullptr;\n                return false;\n            }\n        }\n        else if (keyFlag)\n        {\n            if (payload_size <= 0)\n            {\n                EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Serialized Payload value invalid (\" << payload_size << \")\");\n                ch.serializedPayload.data = nullptr;\n                ch.inline_qos.data = nullptr;\n                return false;\n            }\n\n            if (payload_size <= PARAMETER_KEY_HASH_LENGTH)\n            {\n                memcpy(ch.instanceHandle.value, &msg->buffer[msg->pos], payload_size);\n            }\n            else\n            {\n                EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Ignoring Serialized Payload for too large key-only data (\" <<\n                        payload_size << \")\");\n            }\n            msg->pos += payload_size;\n        }\n    }\n\n    // Set sourcetimestamp\n    if (have_timestamp_)\n    {\n        ch.sourceTimestamp = timestamp_;\n    }\n\n    EPROSIMA_LOG_INFO(RTPS_MSG_IN, IDSTRING \"from Writer \" << ch.writerGUID << \"; possible RTPSReader entities: \" <<\n            associated_readers_.size());\n\n    //Look for the correct reader to add the change\n    process_data_message_function_(readerID, ch);\n\n    IPayloadPool* payload_pool = ch.payload_owner();\n    if (payload_pool)\n    {\n        payload_pool->release_payload(ch);\n    }\n\n    //TODO(Ricardo) If an exception is thrown (ex, by fastcdr), these lines are not executed -> segmentation fault\n    ch.serializedPayload.data = nullptr;\n    ch.inline_qos.data = nullptr;\n\n    EPROSIMA_LOG_INFO(RTPS_MSG_IN, IDSTRING \"Sub Message DATA processed\");\n    return true;\n}",
  "abstract_func": "bool MessageReceiver::proc_Submsg_Data(\n        CDRMessage_t* VAR_0,\n        SubmessageHeader_t* VAR_1,\n        EntityId_t& VAR_2) const\n{\n    eprosima::shared_lock<eprosima::shared_mutex> guard(mtx_);\n\n    /* COMMENT_0 */\n    if (VAR_1->submessageLength < VAR_3)\n    {\n        EPROSIMA_LOG_INFO(VAR_4, VAR_5 \"Too short submessage received, ignoring\");\n        return false;\n    }\n    /* COMMENT_1 */\n    bool VAR_6 = (VAR_1->flags & BIT(0)) != 0;\n    bool VAR_7 = (VAR_1->flags & BIT(1)) != 0;\n    bool VAR_8 = (VAR_1->flags & BIT(2)) != 0;\n    bool VAR_9 = (VAR_1->flags & BIT(3)) != 0;\n    if (VAR_9 && VAR_8)\n    {\n        EPROSIMA_LOG_WARNING(VAR_4, VAR_5 \"Message received with Data and Key Flag set, ignoring\");\n        return false;\n    }\n\n    /* COMMENT_2 */\n    if (VAR_6)\n    {\n        VAR_0->msg_endian = VAR_10;\n    }\n    else\n    {\n        VAR_0->msg_endian = VAR_11;\n    }\n\n    /* COMMENT_3 */\n    VAR_0->pos += 2;\n\n    bool VAR_12 = true;\n    int16_t VAR_13 = 0;\n    VAR_12 &= CDRMessage::readInt16(VAR_0, &VAR_13); /* COMMENT_4 */\n\n    /* COMMENT_5 */\n    RTPSReader* VAR_14 = nullptr;\n    EntityId_t VAR_15;\n    VAR_12 &= CDRMessage::readEntityId(VAR_0, &VAR_15);\n\n    /* COMMENT_6 */\n    if (!willAReaderAcceptMsgDirectedTo(VAR_15, VAR_14))\n    {\n        return false;\n    }\n\n    /* COMMENT_7 */\n    /* COMMENT_8 */\n    CacheChange_t VAR_16;\n    VAR_16.kind = VAR_17;\n    VAR_16.writerGUID.guidPrefix = VAR_18;\n    VAR_12 &= CDRMessage::readEntityId(VAR_0, &VAR_16.writerGUID.entityId);\n\n    VAR_2 = VAR_16.writerGUID.entityId;\n\n    /* COMMENT_9 */\n    VAR_12 &= CDRMessage::readSequenceNumber(VAR_0, &VAR_16.sequenceNumber);\n\n    if (!VAR_12)\n    {\n        return false;\n    }\n\n    if (VAR_16.sequenceNumber <= SequenceNumber_t())\n    {\n        EPROSIMA_LOG_WARNING(VAR_4, VAR_5 \"Invalid message received, bad sequence Number\");\n        return false;\n    }\n\n    /* COMMENT_10 */\n    if (VAR_13 > VAR_19)\n    {\n        VAR_0->pos += (VAR_13 - VAR_19);\n        if (VAR_0->pos > VAR_0->length)\n        {\n            EPROSIMA_LOG_WARNING(VAR_4,\n                    VAR_5 \"Invalid jump through msg, msg->pos \" << VAR_0->pos << \" > msg->length \" << VAR_0->length);\n            return false;\n        }\n    }\n\n    uint32_t VAR_20 = 0;\n\n    if (VAR_7)\n    {\n        if (!ParameterList::updateCacheChangeFromInlineQos(VAR_16, VAR_0, VAR_20))\n        {\n            EPROSIMA_LOG_INFO(VAR_4, VAR_5 \"SubMessage Data ERROR, Inline Qos ParameterList error\");\n            return false;\n        }\n        VAR_16.inline_qos.data = &VAR_0->buffer[VAR_0->pos - VAR_20];\n        VAR_16.inline_qos.max_size = VAR_20;\n        VAR_16.inline_qos.length = VAR_20;\n        VAR_16.inline_qos.encapsulation = VAR_6 ? VAR_21 : VAR_22;\n        VAR_16.inline_qos.pos = 0;\n    }\n\n    if (VAR_8 || VAR_9)\n    {\n        uint32_t VAR_23;\n        VAR_23 = VAR_1->submessageLength -\n                (VAR_24 + VAR_13 + VAR_20);\n\n        if (VAR_8)\n        {\n            uint32_t VAR_25 = VAR_0->pos + VAR_23;\n            if (VAR_0->length >= VAR_25 && VAR_23 > 0)\n            {\n                VAR_16.serializedPayload.data = &VAR_0->buffer[VAR_0->pos];\n                VAR_16.serializedPayload.length = VAR_23;\n                VAR_16.serializedPayload.max_size = VAR_23;\n                VAR_0->pos = VAR_25;\n            }\n            else\n            {\n                EPROSIMA_LOG_WARNING(VAR_4, VAR_5 \"Serialized Payload value invalid or larger than maximum allowed size\"\n                        \"(\" << VAR_23 << \"/\" << (VAR_0->length - VAR_0->pos) << \")\");\n                VAR_16.serializedPayload.data = nullptr;\n                VAR_16.inline_qos.data = nullptr;\n                return false;\n            }\n        }\n        else if (VAR_9)\n        {\n            if (VAR_23 <= 0)\n            {\n                EPROSIMA_LOG_WARNING(VAR_4, VAR_5 \"Serialized Payload value invalid (\" << VAR_23 << \")\");\n                VAR_16.serializedPayload.data = nullptr;\n                VAR_16.inline_qos.data = nullptr;\n                return false;\n            }\n\n            if (VAR_23 <= VAR_26)\n            {\n                memcpy(VAR_16.instanceHandle.value, &VAR_0->buffer[VAR_0->pos], VAR_23);\n            }\n            else\n            {\n                EPROSIMA_LOG_WARNING(VAR_4, VAR_5 \"Ignoring Serialized Payload for too large key-only data (\" <<\n                        VAR_23 << \")\");\n            }\n            VAR_0->pos += VAR_23;\n        }\n    }\n\n    /* COMMENT_11 */\n    if (VAR_27)\n    {\n        VAR_16.sourceTimestamp = VAR_28;\n    }\n\n    EPROSIMA_LOG_INFO(VAR_4, VAR_5 \"from Writer \" << VAR_16.writerGUID << \"; possible RTPSReader entities: \" <<\n            VAR_29.size());\n\n    /* COMMENT_12 */\n    process_data_message_function_(VAR_15, VAR_16);\n\n    IPayloadPool* VAR_30 = VAR_16.payload_owner();\n    if (VAR_30)\n    {\n        VAR_30->release_payload(VAR_16);\n    }\n\n    /* COMMENT_13 */\n    VAR_16.serializedPayload.data = nullptr;\n    VAR_16.inline_qos.data = nullptr;\n\n    EPROSIMA_LOG_INFO(VAR_4, VAR_5 \"Sub Message DATA processed\");\n    return true;\n}",
  "func_graph_path": "eProsima/Fast-DDS/6fdbe790fe814c8799860bf896742bae58b7bf35/MessageReceiver.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -121,6 +121,8 @@\n             {\n                 EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Serialized Payload value invalid or larger than maximum allowed size\"\n                         \"(\" << payload_size << \"/\" << (msg->length - msg->pos) << \")\");\n+                ch.serializedPayload.data = nullptr;\n+                ch.inline_qos.data = nullptr;\n                 return false;\n             }\n         }\n@@ -129,6 +131,8 @@\n             if (payload_size <= 0)\n             {\n                 EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Serialized Payload value invalid (\" << payload_size << \")\");\n+                ch.serializedPayload.data = nullptr;\n+                ch.inline_qos.data = nullptr;\n                 return false;\n             }\n ",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "                ch.serializedPayload.data = nullptr;",
      "                ch.inline_qos.data = nullptr;",
      "                ch.serializedPayload.data = nullptr;",
      "                ch.inline_qos.data = nullptr;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/eProsima/Fast-DDS/pull/3824",
  "description": {
    "pr_info": {
      "title": "[19416] Fix bad-free when receiving malformed DATA submessage",
      "number": 3824
    },
    "comment": [
      "<!-- Provide a general summary of your changes in the Title above -->\r\n\r\n<!--\r\n    If this PR is still a Work in Progress [WIP], please open it as DRAFT.\r\n    Please consider if any label should be added to this PR.\r\n    If no code has been changed, please add `skip-ci` label.\r\n    If opening the PR as Draft, please consider adding `no-test` label to only build the code but not run CI.\r\n    If documentation PR is still pending, please add `doc-pending` label.\r\n-->\r\n\r\n## Description\r\n<!--\r\n    Describe changes in detail.\r\n    If several features/bug fixes are included with these changes, please consider opening separated pull requests.\r\n-->\r\n\r\nThis PR:\r\n- Adds a custom transport that enables injecting arbitrary RTPS datagrams\r\n- Adds a black-box test that reads RTPS datagrams from binary files and injects them using the new transport\r\n- Adds a regression datagram for #3207 \r\n- Fixes #3207 \r\n\r\n<!--\r\n    In case of bug fixes, please provide the list of supported branches where this fix should be also merged.\r\n    Please uncomment following line, adjusting the corresponding target branches for the backport.\r\n-->\r\n@Mergifyio backport 2.11.x 2.10.x 2.6.x\r\n\r\n<!-- If an issue is already opened, please uncomment next line with the corresponding issue number. -->\r\n<!-- Fixes #(issue) -->\r\n\r\n<!-- In case the changes are built over a previous pull request, please uncomment next line. -->\r\n<!-- This PR depends on #(PR) and must be merged after that one. -->\r\n\r\n## Contributor Checklist\r\n- [x] Commit messages follow the project guidelines. <!-- External contributors should sign the DCO. Fast DDS developers must also refer to the internal Redmine task. -->\r\n- [x] The code follows the style guidelines of this project. <!-- Please refer to the [Quality Declaration](https://github.com/eProsima/Fast-DDS/blob/master/QUALITY.md#linters-and-static-analysis-4v) for more information. -->\r\n- [x] Tests that thoroughly check the new feature have been added/Regression tests checking the bug and its fix have been added; the added tests pass locally <!-- Blackbox tests checking the new functionality are required. Changes that add/modify public API must include unit tests covering all possible cases. In case that no tests are provided, please justify why. -->\r\n- **N/A** Any new/modified methods have been properly documented using Doxygen. <!-- Even internal classes, and private methods and members should be documented, not only the public API. -->\r\n- [x] Changes are ABI compatible. <!-- Bug fixes should be ABI compatible if possible so a backport to previous affected releases can be made. -->\r\n- [x] Changes are API compatible. <!-- Public API must not be broken within the same major release. -->\r\n- **N/A** New feature has been added to the `versions.md` file (if applicable).\r\n- **N/A** New feature has been documented/Current behavior is correctly described in the documentation. <!-- Please uncomment following line with the corresponding PR to the documentation project: -->\r\n    <!-- Related documentation PR: eProsima/Fast-DDS-docs# (PR) -->\r\n- [x] Applicable backports have been included in the description.\r\n\r\n\r\n## Reviewer Checklist\r\n- [x] The PR has a milestone assigned.\r\n- [x] Check contributor checklist is correct.\r\n- [x] Check CI results: changes do not issue any warning.\r\n- [x] Check CI results: failing tests are unrelated with the changes.\r\n",
      "@richiprosima Please test this",
      "@richiprosima Please test mac ",
      "@richiprosima Please test this",
      "@richiprosima please test this",
      "@Mergifyio backport 2.11.x 2.10.x 2.6.x",
      "> backport 2.11.x 2.10.x 2.6.x\n\n#### âœ… Backports have been created\n\n<details>\n\n* [#3860 [19416] Fix bad-free when receiving malformed DATA submessage (backport #3824)](https://github.com/eProsima/Fast-DDS/pull/3860) has been created for branch `2.11.x`\n* [#3861 [19416] Fix bad-free when receiving malformed DATA submessage (backport #3824)](https://github.com/eProsima/Fast-DDS/pull/3861) has been created for branch `2.10.x`\n* [#3862 [19416] Fix bad-free when receiving malformed DATA submessage (backport #3824)](https://github.com/eProsima/Fast-DDS/pull/3862) has been created for branch `2.6.x` but encountered conflicts\n\n</details>\n\n\n<!---\nDO NOT EDIT\n-*- Mergify Payload -*-\n{\"command\": \"backport 2.11.x 2.10.x 2.6.x\", \"conclusion\": \"success\", \"action_is_running\": true}\n-*- Mergify Payload End -*-\n-->"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.7,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.7  \n\nThe code changes address data validation issues, likely fixing a bug, but lack explicit security-related terms."
}