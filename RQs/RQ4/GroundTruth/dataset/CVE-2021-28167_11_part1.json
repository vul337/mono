{
  "cve_id": "CVE-2021-28167",
  "cwe_ids": [
    "CWE-909"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "eclipse-openj9/openj9",
  "commit_msg": "Correctly load/initialize classes when using ConstantPool\n\n- do not load classes in the \"ifLoaded\" calls\n- never intitialize classes in the natives\n- do not update the constant pool when querying from the natives\n\nFixes: #12016\n\n[ci skip]\n\nSigned-off-by: Graham Chapman <graham_chapman@ca.ibm.com>",
  "commit_hash": "840f3af31a5b8d2d395d9367c826ed756e380fb9",
  "git_url": "https://github.com/eclipse-openj9/openj9/commit/840f3af31a5b8d2d395d9367c826ed756e380fb9",
  "file_path": "runtime/vm/resolvesupport.cpp",
  "func_name": "resolveMethodHandleRefInto",
  "func_before": "j9object_t   \nresolveMethodHandleRefInto(J9VMThread *vmThread, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags, J9RAMMethodHandleRef *ramCPEntry) {\n\tJ9ROMMethodHandleRef *romMethodHandleRef;\n\tU_32 fieldOrMethodIndex;\n\tJ9ROMMethodRef *cpItem;\n\tJ9Class *definingClass;\n\tJ9ROMNameAndSignature* nameAndSig;\n\tj9object_t methodHandle = NULL;\n\tbool jitCompileTimeResolve = J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_JIT_COMPILE_TIME);\n\tbool canRunJavaCode = !jitCompileTimeResolve && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_REDEFINE_CLASS);\n\tbool throwException = canRunJavaCode && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);\n\n\t/* Check if already resolved */\n\tif (ramCPEntry->methodHandle != NULL) {\n\t\treturn ramCPEntry->methodHandle;\n\t}\n\n\t/* Return NULL if not allowed to run java code */\n\tif (!canRunJavaCode) {\n\t\treturn NULL;\n\t}\n\n\t/* Use normal field/method resolution to validate whether we can see the method/field to\n\t * get a MethodHandle on it and ensure that appropriate exceptions are thrown.\n\t * MethodHandle.invoke{Exact,Generic} is a special case as resolution can't succeed.\n\t */\n\n\tromMethodHandleRef = ((J9ROMMethodHandleRef *) &(J9_ROM_CP_FROM_CP(ramCP)[cpIndex]));\n\tfieldOrMethodIndex = romMethodHandleRef->methodOrFieldRefIndex;\n\n\t/* Shift the handleTypeAndCpType to remove the cpType */\n\tswitch(romMethodHandleRef->handleTypeAndCpType >> J9DescriptionCpTypeShift) {\n\t/* Instance Fields */\n\tcase MH_REF_GETFIELD:\n\tcase MH_REF_PUTFIELD:\n\t\tif (resolveInstanceFieldRef(vmThread, NULL, ramCP, fieldOrMethodIndex, resolveFlags, NULL) == -1) {\n\t\t\t/* field resolution failed - exception should be set */\n\t\t\tgoto _done;\n\t\t}\n\t\tbreak;\n\t/* Static Fields */\n\tcase MH_REF_GETSTATIC:\n\tcase MH_REF_PUTSTATIC:\n\t\tif (resolveStaticFieldRef(vmThread, NULL, ramCP, fieldOrMethodIndex, resolveFlags, NULL) == NULL) {\n\t\t\t/* field resolution failed - exception should be set */\n\t\t\tgoto _done;\n\t\t}\n\t\tbreak;\n\n\tcase MH_REF_INVOKEVIRTUAL:\n\t\t/* InvokeVirtual */\n\t{\n\t\t/*\n\t\t * Given that MethodHandle invokeExact() & invoke() are @PolymorphicSignature methods,\n\t\t * skip method/signature checking to enable MethodHandle invocation only when the resolved class is MethodHandle\n\t\t * and the corresponding method is invokeExact() or invoke().\n\t\t */\n\t\tJ9ROMMethodRef *romMethodRef = (J9ROMMethodRef *) &((J9_ROM_CP_FROM_CP(ramCP))[fieldOrMethodIndex]);\n\t\tJ9Class *resolvedClass = NULL;\n\n\t\tresolvedClass = resolveClassRef(vmThread, ramCP, romMethodRef->classRefCPIndex, resolveFlags);\n\t\tif (NULL == resolvedClass) {\n\t\t\tgoto _done;\n\t\t}\n\n\t\t/* Assumes that if this is MethodHandle, the class was successfully resolved but the method was not */\n\t\tif (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(vmThread->javaVM)) {\n\t\t\t/* This is MethodHandle - confirm name is either invokeExact or invoke */\n\t\t\tJ9ROMNameAndSignature* nameAndSig = J9ROMMETHODREF_NAMEANDSIGNATURE(romMethodRef);\n\t\t\tJ9UTF8 *nameUTF = J9ROMNAMEANDSIGNATURE_NAME(nameAndSig);\n\t\t\tif (J9UTF8_LITERAL_EQUALS(J9UTF8_DATA(nameUTF), J9UTF8_LENGTH(nameUTF), \"invokeExact\")\n\t\t\t|| J9UTF8_LITERAL_EQUALS(J9UTF8_DATA(nameUTF), J9UTF8_LENGTH(nameUTF), \"invoke\")\n\t\t\t) {\n\t\t\t\t/* valid - must be resolvable */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (resolveVirtualMethodRef(vmThread, ramCP, fieldOrMethodIndex, resolveFlags, NULL) == 0) {\n\t\t\t/* private methods don't end up in the vtable - we need to determine if invokeSpecial is\n\t\t\t * appropriate here.\n\t\t\t */\n\t\t\tJ9RAMSpecialMethodRef ramSpecialMethodRef;\n\n\t\t\t/* Clear the exception and let the resolveSpecialMethodRef set an exception if necessary */\n\t\t\tVM_VMHelpers::clearException(vmThread);\n\t\t\t\n\t\t\tmemset(&ramSpecialMethodRef, 0, sizeof(J9RAMSpecialMethodRef));\n\t\t\tif (resolveSpecialMethodRefInto(vmThread, ramCP, fieldOrMethodIndex, resolveFlags, &ramSpecialMethodRef) == NULL) {\n\t\t\t\t/* Only the class and {Name, Signature} are used by the java code so it is safe to use the fake specialMethodRef */\n\t\t\t\tgoto _done;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase MH_REF_INVOKESTATIC:\n\t\t/* InvokeStatic */\n\t\tif (resolveStaticMethodRef(vmThread, ramCP, fieldOrMethodIndex, resolveFlags) == NULL) {\n\t\t\tgoto _done;\n\t\t}\n\t\tbreak;\n\tcase MH_REF_INVOKESPECIAL:\n\tcase MH_REF_NEWINVOKESPECIAL:\n\t\t/* InvokeSpecial */\n\t\tif (resolveSpecialMethodRef(vmThread, ramCP, fieldOrMethodIndex, resolveFlags) == NULL) {\n\t\t\t/* Note: this can't find any polymorphic signature versions MethodHandle.invoke{Exact, Generic} */\n\t\t\tgoto _done;\n\t\t}\n\t\tbreak;\n\tcase MH_REF_INVOKEINTERFACE:\n\t\t/* InvokeInterface */\n\t\tif (resolveInterfaceMethodRef(vmThread, ramCP, fieldOrMethodIndex, resolveFlags) == NULL) {\n\t\t\tgoto _done;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* cpItem will be either a field or a method ref - they both have the same shape so\n\t * we can pretend it is always a methodref\n\t */\n\tcpItem = (J9ROMMethodRef *) &(J9_ROM_CP_FROM_CP(ramCP)[fieldOrMethodIndex]);\n\tdefiningClass = ((J9RAMClassRef *) &(ramCP[cpItem->classRefCPIndex]))->value;\n\tif (definingClass == NULL) {\n\t\tif (throwException) {\n\t\t\tsetCurrentExceptionUTF(vmThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n\t\t}\n\t\tgoto _done;\n\t}\n\tnameAndSig = J9ROMMETHODREF_NAMEANDSIGNATURE(cpItem);\n\n\tsendResolveMethodHandle(vmThread, cpIndex, ramCP, definingClass, nameAndSig);\n\tmethodHandle = (j9object_t) vmThread->returnValue;\n\n\t/* check if an exception is already pending */\n\tif (threadEventsPending(vmThread)) {\n\t\t/* Already a pending exception */\n\t\tmethodHandle = NULL;\n\t} else if (methodHandle == NULL) {\n\t\tif (throwException) {\n\t\t\tsetCurrentExceptionUTF(vmThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n\t\t}\n\t}\n\n\t/* Only write the value in if its not null */\n\tif (NULL != methodHandle) {\n\t\tmethodHandle = vmThread->javaVM->memoryManagerFunctions->j9gc_objaccess_asConstantPoolObject(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvmThread, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmethodHandle, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tJ9_GC_ALLOCATE_OBJECT_TENURED | J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE | J9_GC_ALLOCATE_OBJECT_HASHED);\n\t\tif (NULL == methodHandle) {\n\t\t\tif (throwException) {\n\t\t\t\tsetHeapOutOfMemoryError(vmThread);\n\t\t\t}\n\t\t} else {\n\t\t\tj9object_t *methodHandleObjectP = &ramCPEntry->methodHandle;\n\t\t\t/* Overwriting NULL with an immortal pointer, so no exception can occur */\n\t\t\tJ9STATIC_OBJECT_STORE(vmThread,  J9_CLASS_FROM_CP(ramCP), methodHandleObjectP, methodHandle);\n\t\t}\n\t}\n\n_done:\n\n\treturn methodHandle;\n}",
  "abstract_func_before": "j9object_t   \nresolveMethodHandleRefInto(J9VMThread *VAR_0, J9ConstantPool *VAR_1, UDATA VAR_2, UDATA VAR_3, J9RAMMethodHandleRef *VAR_4) {\n\tJ9ROMMethodHandleRef *VAR_5;\n\tU_32 VAR_6;\n\tJ9ROMMethodRef *VAR_7;\n\tJ9Class *VAR_8;\n\tJ9ROMNameAndSignature* VAR_9;\n\tj9object_t VAR_10 = NULL;\n\tbool VAR_11 = J9_ARE_ANY_BITS_SET(VAR_3, VAR_12);\n\tbool VAR_13 = !VAR_11 && J9_ARE_NO_BITS_SET(VAR_3, VAR_14);\n\tbool VAR_15 = VAR_13 && J9_ARE_NO_BITS_SET(VAR_3, VAR_16);\n\n\t/* COMMENT_0 */\n\tif (VAR_4->methodHandle != NULL) {\n\t\treturn VAR_4->methodHandle;\n\t}\n\n\t/* COMMENT_1 */\n\tif (!VAR_13) {\n\t\treturn NULL;\n\t}\n\n\t/* COMMENT_2 */\n                                                                               \n                                                                                     \n    \n\n\tVAR_5 = ((J9ROMMethodHandleRef *) &(J9_ROM_CP_FROM_CP(VAR_1)[VAR_2]));\n\tVAR_6 = VAR_5->methodOrFieldRefIndex;\n\n\t/* COMMENT_6 */\n\tswitch(VAR_5->handleTypeAndCpType >> VAR_17) {\n\t/* COMMENT_7 */\n\tcase VAR_18:\n\tcase VAR_19:\n\t\tif (resolveInstanceFieldRef(VAR_0, NULL, VAR_1, VAR_6, VAR_3, NULL) == -1) {\n\t\t\t/* COMMENT_8 */\n\t\t\tgoto _done;\n\t\t}\n\t\tbreak;\n\t/* COMMENT_9 */\n\tcase VAR_20:\n\tcase VAR_21:\n\t\tif (resolveStaticFieldRef(VAR_0, NULL, VAR_1, VAR_6, VAR_3, NULL) == NULL) {\n\t\t\t/* COMMENT_8 */\n\t\t\tgoto _done;\n\t\t}\n\t\tbreak;\n\n\tcase VAR_22:\n\t\t/* COMMENT_10 */\n\t{\n\t\t/* COMMENT_11 */\n                                                                                        \n                                                                                                                  \n                                                               \n     \n\t\tJ9ROMMethodRef *VAR_23 = (J9ROMMethodRef *) &((J9_ROM_CP_FROM_CP(VAR_1))[VAR_6]);\n\t\tJ9Class *VAR_24 = NULL;\n\n\t\tVAR_24 = resolveClassRef(VAR_0, VAR_1, VAR_23->classRefCPIndex, VAR_3);\n\t\tif (NULL == VAR_24) {\n\t\t\tgoto _done;\n\t\t}\n\n\t\t/* COMMENT_16 */\n\t\tif (VAR_24 == J9VMJAVALANGINVOKEMETHODHANDLE(VAR_0->javaVM)) {\n\t\t\t/* COMMENT_17 */\n\t\t\tJ9ROMNameAndSignature* VAR_9 = J9ROMMETHODREF_NAMEANDSIGNATURE(VAR_23);\n\t\t\tJ9UTF8 *VAR_25 = J9ROMNAMEANDSIGNATURE_NAME(VAR_9);\n\t\t\tif (J9UTF8_LITERAL_EQUALS(J9UTF8_DATA(VAR_25), J9UTF8_LENGTH(VAR_25), \"invokeExact\")\n\t\t\t|| J9UTF8_LITERAL_EQUALS(J9UTF8_DATA(VAR_25), J9UTF8_LENGTH(VAR_25), \"invoke\")\n\t\t\t) {\n\t\t\t\t/* COMMENT_18 */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (resolveVirtualMethodRef(VAR_0, VAR_1, VAR_6, VAR_3, NULL) == 0) {\n\t\t\t/* COMMENT_19 */\n                       \n      \n\t\t\tJ9RAMSpecialMethodRef VAR_26;\n\n\t\t\t/* COMMENT_22 */\n\t\t\tVM_VMHelpers::clearException(VAR_0);\n\t\t\t\n\t\t\tmemset(&VAR_26, 0, sizeof(J9RAMSpecialMethodRef));\n\t\t\tif (resolveSpecialMethodRefInto(VAR_0, VAR_1, VAR_6, VAR_3, &VAR_26) == NULL) {\n\t\t\t\t/* COMMENT_23 */\n\t\t\t\tgoto _done;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase VAR_27:\n\t\t/* COMMENT_24 */\n\t\tif (resolveStaticMethodRef(VAR_0, VAR_1, VAR_6, VAR_3) == NULL) {\n\t\t\tgoto _done;\n\t\t}\n\t\tbreak;\n\tcase VAR_28:\n\tcase VAR_29:\n\t\t/* COMMENT_25 */\n\t\tif (resolveSpecialMethodRef(VAR_0, VAR_1, VAR_6, VAR_3) == NULL) {\n\t\t\t/* COMMENT_26 */\n\t\t\tgoto _done;\n\t\t}\n\t\tbreak;\n\tcase VAR_30:\n\t\t/* COMMENT_27 */\n\t\tif (resolveInterfaceMethodRef(VAR_0, VAR_1, VAR_6, VAR_3) == NULL) {\n\t\t\tgoto _done;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* COMMENT_28 */\n                                           \n    \n\tVAR_7 = (J9ROMMethodRef *) &(J9_ROM_CP_FROM_CP(VAR_1)[VAR_6]);\n\tVAR_8 = ((J9RAMClassRef *) &(VAR_1[VAR_7->classRefCPIndex]))->value;\n\tif (VAR_8 == NULL) {\n\t\tif (VAR_15) {\n\t\t\tsetCurrentExceptionUTF(VAR_0, VAR_31, NULL);\n\t\t}\n\t\tgoto _done;\n\t}\n\tVAR_9 = J9ROMMETHODREF_NAMEANDSIGNATURE(VAR_7);\n\n\tsendResolveMethodHandle(VAR_0, VAR_2, VAR_1, VAR_8, VAR_9);\n\tVAR_10 = (j9object_t) VAR_0->returnValue;\n\n\t/* COMMENT_31 */\n\tif (threadEventsPending(VAR_0)) {\n\t\t/* COMMENT_32 */\n\t\tVAR_10 = NULL;\n\t} else if (VAR_10 == NULL) {\n\t\tif (VAR_15) {\n\t\t\tsetCurrentExceptionUTF(VAR_0, VAR_31, NULL);\n\t\t}\n\t}\n\n\t/* COMMENT_33 */\n\tif (NULL != VAR_10) {\n\t\tVAR_10 = VAR_0->javaVM->memoryManagerFunctions->j9gc_objaccess_asConstantPoolObject(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tVAR_0, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tVAR_10, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tVAR_32 | VAR_33 | VAR_34);\n\t\tif (NULL == VAR_10) {\n\t\t\tif (VAR_15) {\n\t\t\t\tsetHeapOutOfMemoryError(VAR_0);\n\t\t\t}\n\t\t} else {\n\t\t\tj9object_t *VAR_35 = &VAR_4->methodHandle;\n\t\t\t/* COMMENT_34 */\n\t\t\tJ9STATIC_OBJECT_STORE(VAR_0,  J9_CLASS_FROM_CP(VAR_1), VAR_35, VAR_10);\n\t\t}\n\t}\n\n_done:\n\n\treturn VAR_10;\n}",
  "func_graph_path_before": "eclipse-openj9/openj9/840f3af31a5b8d2d395d9367c826ed756e380fb9/resolvesupport.cpp/vul/before/3.json",
  "func": "j9object_t   \nresolveMethodHandleRefInto(J9VMThread *vmThread, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags, J9RAMMethodHandleRef *ramCPEntry) {\n\tJ9ROMMethodHandleRef *romMethodHandleRef;\n\tU_32 fieldOrMethodIndex;\n\tJ9ROMMethodRef *cpItem;\n\tJ9Class *definingClass;\n\tJ9ROMNameAndSignature* nameAndSig;\n\tj9object_t methodHandle = NULL;\n\tbool jitCompileTimeResolve = J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_JIT_COMPILE_TIME);\n\tbool canRunJavaCode = !jitCompileTimeResolve && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_REDEFINE_CLASS);\n\tbool throwException = canRunJavaCode && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);\n\n\t/* Check if already resolved */\n\tif (ramCPEntry->methodHandle != NULL) {\n\t\treturn ramCPEntry->methodHandle;\n\t}\n\n\t/* Return NULL if not allowed to run java code */\n\tif (!canRunJavaCode) {\n\t\treturn NULL;\n\t}\n\n\t/* Use normal field/method resolution to validate whether we can see the method/field to\n\t * get a MethodHandle on it and ensure that appropriate exceptions are thrown.\n\t * MethodHandle.invoke{Exact,Generic} is a special case as resolution can't succeed.\n\t */\n\n\tromMethodHandleRef = ((J9ROMMethodHandleRef *) &(J9_ROM_CP_FROM_CP(ramCP)[cpIndex]));\n\tfieldOrMethodIndex = romMethodHandleRef->methodOrFieldRefIndex;\n\n\t/* Shift the handleTypeAndCpType to remove the cpType */\n\tswitch(romMethodHandleRef->handleTypeAndCpType >> J9DescriptionCpTypeShift) {\n\t/* Instance Fields */\n\tcase MH_REF_GETFIELD:\n\tcase MH_REF_PUTFIELD:\n\t\tif (resolveInstanceFieldRef(vmThread, NULL, ramCP, fieldOrMethodIndex, resolveFlags, NULL) == -1) {\n\t\t\t/* field resolution failed - exception should be set */\n\t\t\tgoto _done;\n\t\t}\n\t\tbreak;\n\t/* Static Fields */\n\tcase MH_REF_GETSTATIC:\n\tcase MH_REF_PUTSTATIC:\n\t\tif (resolveStaticFieldRefInto(vmThread, NULL, ramCP, fieldOrMethodIndex, resolveFlags, NULL, NULL) == NULL) {\n\t\t\t/* field resolution failed - exception should be set */\n\t\t\tgoto _done;\n\t\t}\n\t\tbreak;\n\n\tcase MH_REF_INVOKEVIRTUAL:\n\t\t/* InvokeVirtual */\n\t{\n\t\t/*\n\t\t * Given that MethodHandle invokeExact() & invoke() are @PolymorphicSignature methods,\n\t\t * skip method/signature checking to enable MethodHandle invocation only when the resolved class is MethodHandle\n\t\t * and the corresponding method is invokeExact() or invoke().\n\t\t */\n\t\tJ9ROMMethodRef *romMethodRef = (J9ROMMethodRef *) &((J9_ROM_CP_FROM_CP(ramCP))[fieldOrMethodIndex]);\n\t\tJ9Class *resolvedClass = NULL;\n\n\t\tresolvedClass = resolveClassRef(vmThread, ramCP, romMethodRef->classRefCPIndex, resolveFlags);\n\t\tif (NULL == resolvedClass) {\n\t\t\tgoto _done;\n\t\t}\n\n\t\t/* Assumes that if this is MethodHandle, the class was successfully resolved but the method was not */\n\t\tif (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(vmThread->javaVM)) {\n\t\t\t/* This is MethodHandle - confirm name is either invokeExact or invoke */\n\t\t\tJ9ROMNameAndSignature* nameAndSig = J9ROMMETHODREF_NAMEANDSIGNATURE(romMethodRef);\n\t\t\tJ9UTF8 *nameUTF = J9ROMNAMEANDSIGNATURE_NAME(nameAndSig);\n\t\t\tif (J9UTF8_LITERAL_EQUALS(J9UTF8_DATA(nameUTF), J9UTF8_LENGTH(nameUTF), \"invokeExact\")\n\t\t\t|| J9UTF8_LITERAL_EQUALS(J9UTF8_DATA(nameUTF), J9UTF8_LENGTH(nameUTF), \"invoke\")\n\t\t\t) {\n\t\t\t\t/* valid - must be resolvable */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (resolveVirtualMethodRef(vmThread, ramCP, fieldOrMethodIndex, resolveFlags, NULL) == 0) {\n\t\t\t/* private methods don't end up in the vtable - we need to determine if invokeSpecial is\n\t\t\t * appropriate here.\n\t\t\t */\n\t\t\tJ9RAMSpecialMethodRef ramSpecialMethodRef;\n\n\t\t\t/* Clear the exception and let the resolveSpecialMethodRef set an exception if necessary */\n\t\t\tVM_VMHelpers::clearException(vmThread);\n\t\t\t\n\t\t\tmemset(&ramSpecialMethodRef, 0, sizeof(J9RAMSpecialMethodRef));\n\t\t\tif (resolveSpecialMethodRefInto(vmThread, ramCP, fieldOrMethodIndex, resolveFlags, &ramSpecialMethodRef) == NULL) {\n\t\t\t\t/* Only the class and {Name, Signature} are used by the java code so it is safe to use the fake specialMethodRef */\n\t\t\t\tgoto _done;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase MH_REF_INVOKESTATIC:\n\t\t/* InvokeStatic */\n\t\tif (resolveStaticMethodRefInto(vmThread, ramCP, fieldOrMethodIndex, resolveFlags, NULL) == NULL) {\n\t\t\tgoto _done;\n\t\t}\n\t\tbreak;\n\tcase MH_REF_INVOKESPECIAL:\n\tcase MH_REF_NEWINVOKESPECIAL:\n\t\t/* InvokeSpecial */\n\t\tif (resolveSpecialMethodRef(vmThread, ramCP, fieldOrMethodIndex, resolveFlags) == NULL) {\n\t\t\t/* Note: this can't find any polymorphic signature versions MethodHandle.invoke{Exact, Generic} */\n\t\t\tgoto _done;\n\t\t}\n\t\tbreak;\n\tcase MH_REF_INVOKEINTERFACE:\n\t\t/* InvokeInterface */\n\t\tif (resolveInterfaceMethodRef(vmThread, ramCP, fieldOrMethodIndex, resolveFlags) == NULL) {\n\t\t\tgoto _done;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* cpItem will be either a field or a method ref - they both have the same shape so\n\t * we can pretend it is always a methodref\n\t */\n\tcpItem = (J9ROMMethodRef *) &(J9_ROM_CP_FROM_CP(ramCP)[fieldOrMethodIndex]);\n\tdefiningClass = ((J9RAMClassRef *) &(ramCP[cpItem->classRefCPIndex]))->value;\n\tif (definingClass == NULL) {\n\t\tif (throwException) {\n\t\t\tsetCurrentExceptionUTF(vmThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n\t\t}\n\t\tgoto _done;\n\t}\n\tnameAndSig = J9ROMMETHODREF_NAMEANDSIGNATURE(cpItem);\n\n\tsendResolveMethodHandle(vmThread, cpIndex, ramCP, definingClass, nameAndSig);\n\tmethodHandle = (j9object_t) vmThread->returnValue;\n\n\t/* check if an exception is already pending */\n\tif (threadEventsPending(vmThread)) {\n\t\t/* Already a pending exception */\n\t\tmethodHandle = NULL;\n\t} else if (methodHandle == NULL) {\n\t\tif (throwException) {\n\t\t\tsetCurrentExceptionUTF(vmThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n\t\t}\n\t}\n\n\t/* Only write the value in if its not null */\n\tif (NULL != methodHandle) {\n\t\tmethodHandle = vmThread->javaVM->memoryManagerFunctions->j9gc_objaccess_asConstantPoolObject(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvmThread, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmethodHandle, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tJ9_GC_ALLOCATE_OBJECT_TENURED | J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE | J9_GC_ALLOCATE_OBJECT_HASHED);\n\t\tif (NULL == methodHandle) {\n\t\t\tif (throwException) {\n\t\t\t\tsetHeapOutOfMemoryError(vmThread);\n\t\t\t}\n\t\t} else if ((NULL != ramCPEntry) && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\n\t\t\tj9object_t *methodHandleObjectP = &ramCPEntry->methodHandle;\n\t\t\t/* Overwriting NULL with an immortal pointer, so no exception can occur */\n\t\t\tJ9STATIC_OBJECT_STORE(vmThread,  J9_CLASS_FROM_CP(ramCP), methodHandleObjectP, methodHandle);\n\t\t}\n\t}\n\n_done:\n\n\treturn methodHandle;\n}",
  "abstract_func": "j9object_t   \nresolveMethodHandleRefInto(J9VMThread *VAR_0, J9ConstantPool *VAR_1, UDATA VAR_2, UDATA VAR_3, J9RAMMethodHandleRef *VAR_4) {\n\tJ9ROMMethodHandleRef *VAR_5;\n\tU_32 VAR_6;\n\tJ9ROMMethodRef *VAR_7;\n\tJ9Class *VAR_8;\n\tJ9ROMNameAndSignature* VAR_9;\n\tj9object_t VAR_10 = NULL;\n\tbool VAR_11 = J9_ARE_ANY_BITS_SET(VAR_3, VAR_12);\n\tbool VAR_13 = !VAR_11 && J9_ARE_NO_BITS_SET(VAR_3, VAR_14);\n\tbool VAR_15 = VAR_13 && J9_ARE_NO_BITS_SET(VAR_3, VAR_16);\n\n\t/* COMMENT_0 */\n\tif (VAR_4->methodHandle != NULL) {\n\t\treturn VAR_4->methodHandle;\n\t}\n\n\t/* COMMENT_1 */\n\tif (!VAR_13) {\n\t\treturn NULL;\n\t}\n\n\t/* COMMENT_2 */\n                                                                               \n                                                                                     \n    \n\n\tVAR_5 = ((J9ROMMethodHandleRef *) &(J9_ROM_CP_FROM_CP(VAR_1)[VAR_2]));\n\tVAR_6 = VAR_5->methodOrFieldRefIndex;\n\n\t/* COMMENT_6 */\n\tswitch(VAR_5->handleTypeAndCpType >> VAR_17) {\n\t/* COMMENT_7 */\n\tcase VAR_18:\n\tcase VAR_19:\n\t\tif (resolveInstanceFieldRef(VAR_0, NULL, VAR_1, VAR_6, VAR_3, NULL) == -1) {\n\t\t\t/* COMMENT_8 */\n\t\t\tgoto _done;\n\t\t}\n\t\tbreak;\n\t/* COMMENT_9 */\n\tcase VAR_20:\n\tcase VAR_21:\n\t\tif (resolveStaticFieldRefInto(VAR_0, NULL, VAR_1, VAR_6, VAR_3, NULL, NULL) == NULL) {\n\t\t\t/* COMMENT_8 */\n\t\t\tgoto _done;\n\t\t}\n\t\tbreak;\n\n\tcase VAR_22:\n\t\t/* COMMENT_10 */\n\t{\n\t\t/* COMMENT_11 */\n                                                                                        \n                                                                                                                  \n                                                               \n     \n\t\tJ9ROMMethodRef *VAR_23 = (J9ROMMethodRef *) &((J9_ROM_CP_FROM_CP(VAR_1))[VAR_6]);\n\t\tJ9Class *VAR_24 = NULL;\n\n\t\tVAR_24 = resolveClassRef(VAR_0, VAR_1, VAR_23->classRefCPIndex, VAR_3);\n\t\tif (NULL == VAR_24) {\n\t\t\tgoto _done;\n\t\t}\n\n\t\t/* COMMENT_16 */\n\t\tif (VAR_24 == J9VMJAVALANGINVOKEMETHODHANDLE(VAR_0->javaVM)) {\n\t\t\t/* COMMENT_17 */\n\t\t\tJ9ROMNameAndSignature* VAR_9 = J9ROMMETHODREF_NAMEANDSIGNATURE(VAR_23);\n\t\t\tJ9UTF8 *VAR_25 = J9ROMNAMEANDSIGNATURE_NAME(VAR_9);\n\t\t\tif (J9UTF8_LITERAL_EQUALS(J9UTF8_DATA(VAR_25), J9UTF8_LENGTH(VAR_25), \"invokeExact\")\n\t\t\t|| J9UTF8_LITERAL_EQUALS(J9UTF8_DATA(VAR_25), J9UTF8_LENGTH(VAR_25), \"invoke\")\n\t\t\t) {\n\t\t\t\t/* COMMENT_18 */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (resolveVirtualMethodRef(VAR_0, VAR_1, VAR_6, VAR_3, NULL) == 0) {\n\t\t\t/* COMMENT_19 */\n                       \n      \n\t\t\tJ9RAMSpecialMethodRef VAR_26;\n\n\t\t\t/* COMMENT_22 */\n\t\t\tVM_VMHelpers::clearException(VAR_0);\n\t\t\t\n\t\t\tmemset(&VAR_26, 0, sizeof(J9RAMSpecialMethodRef));\n\t\t\tif (resolveSpecialMethodRefInto(VAR_0, VAR_1, VAR_6, VAR_3, &VAR_26) == NULL) {\n\t\t\t\t/* COMMENT_23 */\n\t\t\t\tgoto _done;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase VAR_27:\n\t\t/* COMMENT_24 */\n\t\tif (resolveStaticMethodRefInto(VAR_0, VAR_1, VAR_6, VAR_3, NULL) == NULL) {\n\t\t\tgoto _done;\n\t\t}\n\t\tbreak;\n\tcase VAR_28:\n\tcase VAR_29:\n\t\t/* COMMENT_25 */\n\t\tif (resolveSpecialMethodRef(VAR_0, VAR_1, VAR_6, VAR_3) == NULL) {\n\t\t\t/* COMMENT_26 */\n\t\t\tgoto _done;\n\t\t}\n\t\tbreak;\n\tcase VAR_30:\n\t\t/* COMMENT_27 */\n\t\tif (resolveInterfaceMethodRef(VAR_0, VAR_1, VAR_6, VAR_3) == NULL) {\n\t\t\tgoto _done;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* COMMENT_28 */\n                                           \n    \n\tVAR_7 = (J9ROMMethodRef *) &(J9_ROM_CP_FROM_CP(VAR_1)[VAR_6]);\n\tVAR_8 = ((J9RAMClassRef *) &(VAR_1[VAR_7->classRefCPIndex]))->value;\n\tif (VAR_8 == NULL) {\n\t\tif (VAR_15) {\n\t\t\tsetCurrentExceptionUTF(VAR_0, VAR_31, NULL);\n\t\t}\n\t\tgoto _done;\n\t}\n\tVAR_9 = J9ROMMETHODREF_NAMEANDSIGNATURE(VAR_7);\n\n\tsendResolveMethodHandle(VAR_0, VAR_2, VAR_1, VAR_8, VAR_9);\n\tVAR_10 = (j9object_t) VAR_0->returnValue;\n\n\t/* COMMENT_31 */\n\tif (threadEventsPending(VAR_0)) {\n\t\t/* COMMENT_32 */\n\t\tVAR_10 = NULL;\n\t} else if (VAR_10 == NULL) {\n\t\tif (VAR_15) {\n\t\t\tsetCurrentExceptionUTF(VAR_0, VAR_31, NULL);\n\t\t}\n\t}\n\n\t/* COMMENT_33 */\n\tif (NULL != VAR_10) {\n\t\tVAR_10 = VAR_0->javaVM->memoryManagerFunctions->j9gc_objaccess_asConstantPoolObject(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tVAR_0, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tVAR_10, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tVAR_32 | VAR_33 | VAR_34);\n\t\tif (NULL == VAR_10) {\n\t\t\tif (VAR_15) {\n\t\t\t\tsetHeapOutOfMemoryError(VAR_0);\n\t\t\t}\n\t\t} else if ((NULL != VAR_4) && J9_ARE_NO_BITS_SET(VAR_3, VAR_35)) {\n\t\t\tj9object_t *VAR_36 = &VAR_4->methodHandle;\n\t\t\t/* COMMENT_34 */\n\t\t\tJ9STATIC_OBJECT_STORE(VAR_0,  J9_CLASS_FROM_CP(VAR_1), VAR_36, VAR_10);\n\t\t}\n\t}\n\n_done:\n\n\treturn VAR_10;\n}",
  "func_graph_path": "eclipse-openj9/openj9/840f3af31a5b8d2d395d9367c826ed756e380fb9/resolvesupport.cpp/vul/after/3.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -41,7 +41,7 @@\n \t/* Static Fields */\n \tcase MH_REF_GETSTATIC:\n \tcase MH_REF_PUTSTATIC:\n-\t\tif (resolveStaticFieldRef(vmThread, NULL, ramCP, fieldOrMethodIndex, resolveFlags, NULL) == NULL) {\n+\t\tif (resolveStaticFieldRefInto(vmThread, NULL, ramCP, fieldOrMethodIndex, resolveFlags, NULL, NULL) == NULL) {\n \t\t\t/* field resolution failed - exception should be set */\n \t\t\tgoto _done;\n \t\t}\n@@ -95,7 +95,7 @@\n \t}\n \tcase MH_REF_INVOKESTATIC:\n \t\t/* InvokeStatic */\n-\t\tif (resolveStaticMethodRef(vmThread, ramCP, fieldOrMethodIndex, resolveFlags) == NULL) {\n+\t\tif (resolveStaticMethodRefInto(vmThread, ramCP, fieldOrMethodIndex, resolveFlags, NULL) == NULL) {\n \t\t\tgoto _done;\n \t\t}\n \t\tbreak;\n@@ -151,7 +151,7 @@\n \t\t\tif (throwException) {\n \t\t\t\tsetHeapOutOfMemoryError(vmThread);\n \t\t\t}\n-\t\t} else {\n+\t\t} else if ((NULL != ramCPEntry) && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\n \t\t\tj9object_t *methodHandleObjectP = &ramCPEntry->methodHandle;\n \t\t\t/* Overwriting NULL with an immortal pointer, so no exception can occur */\n \t\t\tJ9STATIC_OBJECT_STORE(vmThread,  J9_CLASS_FROM_CP(ramCP), methodHandleObjectP, methodHandle);",
  "diff_line_info": {
    "deleted_lines": [
      "\t\tif (resolveStaticFieldRef(vmThread, NULL, ramCP, fieldOrMethodIndex, resolveFlags, NULL) == NULL) {",
      "\t\tif (resolveStaticMethodRef(vmThread, ramCP, fieldOrMethodIndex, resolveFlags) == NULL) {",
      "\t\t} else {"
    ],
    "added_lines": [
      "\t\tif (resolveStaticFieldRefInto(vmThread, NULL, ramCP, fieldOrMethodIndex, resolveFlags, NULL, NULL) == NULL) {",
      "\t\tif (resolveStaticMethodRefInto(vmThread, ramCP, fieldOrMethodIndex, resolveFlags, NULL) == NULL) {",
      "\t\t} else if ((NULL != ramCPEntry) && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/eclipse-openj9/openj9/pull/12148",
  "description": {
    "pr_info": {
      "title": "Correctly load/initialize classes when using ConstantPool",
      "number": 12148
    },
    "comment": [
      "- do not load classes in the \"ifLoaded\" calls\r\n- never intitialize classes in the natives\r\n- do not update the constant pool when querying from the natives\r\n\r\nFixes: #12016\r\n\r\n[ci skip]\r\n\r\nSigned-off-by: Graham Chapman <graham_chapman@ca.ibm.com>",
      "jenkins test sanity,extended zlinux jdk11",
      "jenkins compile win jdk8",
      "@gacholio can you please open another PR for the 0.26 stream",
      "https://github.com/eclipse/openj9/pull/12164"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.9"
}