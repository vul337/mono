{
  "cve_id": "CVE-2017-0152",
  "cwe_ids": [
    "CWE-119"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:C/I:C/A:C",
  "cvss_is_v3": false,
  "repo_name": "chakra-core/ChakraCore",
  "commit_msg": "[CVE-2017-0152] MSFT: 10592731 : Issue with Function name capturing in param scope\n\nIn a function expression with name, where the name is captured in one\nof the param scope functions, if there is a function or var declaration\nwith the same name as the function expression name we were marking the\nfunction expression name as shadowed. In non-eval case this causes\nissue because the name symbol won't get added to the body. This change is to\nfix it in such a way if the name is captured in the param scope then we\nsplit the param and body scope such that the name symbol is added to the\nparam scope not body scope.",
  "commit_hash": "9da019424601325a6e95e6be0fa03d7d21d0b517",
  "git_url": "https://github.com/chakra-core/ChakraCore/commit/9da019424601325a6e95e6be0fa03d7d21d0b517",
  "file_path": "lib/Runtime/ByteCode/ByteCodeEmitter.cpp",
  "func_name": "ByteCodeGenerator::EmitOneFunction",
  "func_before": "void ByteCodeGenerator::EmitOneFunction(ParseNode *pnode)\n{\n    Assert(pnode && (pnode->nop == knopProg || pnode->nop == knopFncDecl));\n    FuncInfo *funcInfo = pnode->sxFnc.funcInfo;\n    Assert(funcInfo != nullptr);\n\n    if (funcInfo->IsFakeGlobalFunction(this->flags))\n    {\n        return;\n    }\n\n    Js::ParseableFunctionInfo* deferParseFunction = funcInfo->byteCodeFunction;\n    deferParseFunction->SetGrfscr(deferParseFunction->GetGrfscr() | (this->flags & ~fscrDeferredFncExpression));\n    deferParseFunction->SetSourceInfo(this->GetCurrentSourceIndex(),\n        funcInfo->root,\n        !!(this->flags & fscrEvalCode),\n        ((this->flags & fscrDynamicCode) && !(this->flags & fscrEvalCode)));\n\n    deferParseFunction->SetInParamsCount(funcInfo->inArgsCount);\n    if (pnode->sxFnc.HasDefaultArguments())\n    {\n        deferParseFunction->SetReportedInParamsCount(pnode->sxFnc.firstDefaultArg + 1);\n    }\n    else\n    {\n        deferParseFunction->SetReportedInParamsCount(funcInfo->inArgsCount);\n    }\n\n    if (funcInfo->root->sxFnc.pnodeBody == nullptr)\n    {\n        if (!PHASE_OFF1(Js::SkipNestedDeferredPhase))\n        {\n            deferParseFunction->BuildDeferredStubs(funcInfo->root);\n        }\n        Assert(!deferParseFunction->IsFunctionBody() || deferParseFunction->GetFunctionBody()->GetByteCode() != nullptr);\n        return;\n    }\n\n    Js::FunctionBody* byteCodeFunction = funcInfo->GetParsedFunctionBody();\n    // We've now done a full parse of this function, so we no longer need to remember the extents\n    // and attributes of the top-level nested functions. (The above code has run for all of those,\n    // so they have pointers to the stub sub-trees they need.)\n    byteCodeFunction->SetDeferredStubs(nullptr);\n\n    try\n    {\n        if (!funcInfo->IsGlobalFunction())\n        {\n            // Note: Do not set the stack nested func flag if the function has been redeferred and recompiled.\n            // In that case the flag already has the value we want.\n            if (CanStackNestedFunc(funcInfo, true) && byteCodeFunction->GetCompileCount() == 0)\n            {\n#if DBG\n                byteCodeFunction->SetCanDoStackNestedFunc();\n#endif\n                if (funcInfo->root->sxFnc.astSize <= PnFnc::MaxStackClosureAST)\n                {\n                    byteCodeFunction->SetStackNestedFunc(true);\n                }\n            }\n        }\n\n        if (byteCodeFunction->DoStackNestedFunc())\n        {\n            uint nestedCount = byteCodeFunction->GetNestedCount();\n            for (uint i = 0; i < nestedCount; i++)\n            {\n                Js::FunctionProxy * nested = byteCodeFunction->GetNestedFunctionProxy(i);\n                if (nested->IsFunctionBody())\n                {\n                    nested->GetFunctionBody()->SetStackNestedFuncParent(byteCodeFunction->GetFunctionInfo());\n                }\n            }\n        }\n\n        if (byteCodeFunction->GetByteCode() != nullptr)\n        {\n            // Previously compiled function nested within a re-deferred and re-compiled function.\n            return;\n        }\n\n        // Bug : 301517\n        // In the debug mode the hasOnlyThis optimization needs to be disabled, since user can break in this function\n        // and do operation on 'this' and its property, which may not be defined yet.\n        if (funcInfo->root->sxFnc.HasOnlyThisStmts() && !IsInDebugMode())\n        {\n            byteCodeFunction->SetHasOnlyThisStmts(true);\n        }\n\n        if (byteCodeFunction->IsInlineApplyDisabled() || this->scriptContext->GetConfig()->IsNoNative())\n        {\n            if ((pnode->nop == knopFncDecl) && (funcInfo->GetHasHeapArguments()) && (!funcInfo->GetCallsEval()) && ApplyEnclosesArgs(pnode, this))\n            {\n                bool applyEnclosesArgs = true;\n                for (ParseNode* pnodeVar = funcInfo->root->sxFnc.pnodeVars; pnodeVar; pnodeVar = pnodeVar->sxVar.pnodeNext)\n                {\n                    Symbol* sym = pnodeVar->sxVar.sym;\n                    if (sym->GetSymbolType() == STVariable && !sym->GetIsArguments())\n                    {\n                        applyEnclosesArgs = false;\n                        break;\n                    }\n                }\n                auto constAndLetCheck = [](ParseNode *pnodeBlock, bool *applyEnclosesArgs)\n                {\n                    if (*applyEnclosesArgs)\n                    {\n                        for (auto lexvar = pnodeBlock->sxBlock.pnodeLexVars; lexvar; lexvar = lexvar->sxVar.pnodeNext)\n                        {\n                            Symbol* sym = lexvar->sxVar.sym;\n                            if (sym->GetSymbolType() == STVariable && !sym->GetIsArguments())\n                            {\n                                *applyEnclosesArgs = false;\n                                break;\n                            }\n                        }\n                    }\n                };\n                constAndLetCheck(funcInfo->root->sxFnc.pnodeScopes, &applyEnclosesArgs);\n                constAndLetCheck(funcInfo->root->sxFnc.pnodeBodyScope, &applyEnclosesArgs);\n                funcInfo->SetApplyEnclosesArgs(applyEnclosesArgs);\n            }\n        }\n\n        InitScopeSlotArray(funcInfo);\n        FinalizeRegisters(funcInfo, byteCodeFunction);\n        DebugOnly(Js::RegSlot firstTmpReg = funcInfo->varRegsCount);\n\n        // Reserve temp registers for the inner scopes. We prefer temps because the JIT will then renumber them\n        // and see different lifetimes. (Note that debug mode requires permanent registers. See FinalizeRegisters.)\n        uint innerScopeCount = funcInfo->InnerScopeCount();\n        if (!this->IsInDebugMode())\n        {\n            byteCodeFunction->SetInnerScopeCount(innerScopeCount);\n            if (innerScopeCount)\n            {\n                funcInfo->SetFirstInnerScopeReg(funcInfo->AcquireTmpRegister());\n                for (uint i = 1; i < innerScopeCount; i++)\n                {\n                    funcInfo->AcquireTmpRegister();\n                }\n            }\n        }\n\n        funcInfo->inlineCacheMap = Anew(alloc, FuncInfo::InlineCacheMap,\n            alloc,\n            funcInfo->RegCount() // Pass the actual register count. // TODO: Check if we can reduce this count\n            );\n        funcInfo->rootObjectLoadInlineCacheMap = Anew(alloc, FuncInfo::RootObjectInlineCacheIdMap,\n            alloc,\n            10);\n        funcInfo->rootObjectLoadMethodInlineCacheMap = Anew(alloc, FuncInfo::RootObjectInlineCacheIdMap,\n            alloc,\n            10);\n        funcInfo->rootObjectStoreInlineCacheMap = Anew(alloc, FuncInfo::RootObjectInlineCacheIdMap,\n            alloc,\n            10);\n        funcInfo->referencedPropertyIdToMapIndex = Anew(alloc, FuncInfo::RootObjectInlineCacheIdMap,\n            alloc,\n            10);\n\n        byteCodeFunction->AllocateLiteralRegexArray();\n        m_callSiteId = 0;\n        m_writer.Begin(byteCodeFunction, alloc, this->DoJitLoopBodies(funcInfo), funcInfo->hasLoop, this->IsInDebugMode());\n        this->PushFuncInfo(_u(\"EmitOneFunction\"), funcInfo);\n\n        this->inPrologue = true;\n\n        // Class constructors do not have a [[call]] slot but we don't implement a generic way to express this.\n        // What we do is emit a check for the new flag here. If we don't have CallFlags_New set, the opcode will throw.\n        // We need to do this before emitting 'this' since the base class constructor will try to construct a new object.\n        if (funcInfo->IsClassConstructor())\n        {\n            m_writer.Empty(Js::OpCode::ChkNewCallFlag);\n        }\n\n        Scope* currentScope = funcInfo->GetCurrentChildScope();\n        Scope* paramScope = funcInfo->GetParamScope();\n        Scope* bodyScope = funcInfo->GetBodyScope();\n\n        // For now, emit all constant loads at top of function (should instead put in closest dominator of uses).\n        LoadAllConstants(funcInfo);\n        HomeArguments(funcInfo);\n\n        if (!currentScope->GetCanMergeWithBodyScope())\n        {\n            byteCodeFunction->SetParamAndBodyScopeNotMerged();\n\n            // Pop the body scope before emitting the default args\n            PopScope();\n            Assert(this->GetCurrentScope() == paramScope);\n        }\n\n        if (funcInfo->root->sxFnc.pnodeRest != nullptr)\n        {\n            byteCodeFunction->SetHasRestParameter();\n        }\n\n        if (funcInfo->thisScopeSlot != Js::Constants::NoRegister && !(funcInfo->IsLambda() || (funcInfo->IsGlobalFunction() && this->flags & fscrEval)))\n        {\n            EmitInitCapturedThis(funcInfo, funcInfo->bodyScope);\n        }\n\n        // Any function with a super reference or an eval call inside a method or a constructor needs to load super,\n        if ((funcInfo->HasSuperReference() || (funcInfo->GetCallsEval() && (funcInfo->root->sxFnc.IsMethod() || funcInfo->root->sxFnc.IsConstructor())))\n            // unless we are already inside the 'global' scope inside an eval (in which case 'ScopedLdHomeObj' is emitted at every 'super' reference).\n            && !((GetFlags() & fscrEval) && funcInfo->IsGlobalFunction()))\n        {\n            if (funcInfo->IsLambda())\n            {\n                Scope *scope;\n                Js::PropertyId envIndex = -1;\n                GetEnclosingNonLambdaScope(funcInfo, scope, envIndex);\n\n                FuncInfo* parent = scope->GetFunc();\n\n                if (!parent->IsGlobalFunction())\n                {\n                    // lambda in non-global scope (eval and non-eval)\n                    EmitInternalScopedSlotLoad(funcInfo, scope, envIndex, parent->superScopeSlot, funcInfo->superRegister);\n                    if (funcInfo->superCtorRegister != Js::Constants::NoRegister)\n                    {\n                        EmitInternalScopedSlotLoad(funcInfo, scope, envIndex, parent->superCtorScopeSlot, funcInfo->superCtorRegister);\n                    }\n                }\n                else if (!(GetFlags() & fscrEval))\n                {\n                    // lambda in non-eval global scope\n                    m_writer.Reg1(Js::OpCode::LdUndef, funcInfo->superRegister);\n                }\n                // lambda in eval global scope: ScopedLdHomeObj will handle error throwing\n            }\n            else\n            {\n                m_writer.Reg1(Js::OpCode::LdHomeObj, funcInfo->superRegister);\n\n                if (funcInfo->superCtorRegister != Js::Constants::NoRegister) // super() is allowed only in derived class constructors\n                {\n                    m_writer.Reg1(Js::OpCode::LdFuncObj, funcInfo->superCtorRegister);\n                }\n\n                if (!funcInfo->IsGlobalFunction())\n                {\n                    if (bodyScope->GetIsObject() && bodyScope->GetLocation() != Js::Constants::NoRegister)\n                    {\n                        // Stash the super reference in case something inside the eval or lambda references it.\n                        uint cacheId = funcInfo->FindOrAddInlineCacheId(bodyScope->GetLocation(), Js::PropertyIds::_superReferenceSymbol, false, true);\n                        m_writer.ElementP(Js::OpCode::InitLocalFld, funcInfo->superRegister, cacheId);\n                        if (funcInfo->superCtorRegister != Js::Constants::NoRegister)\n                        {\n                            cacheId = funcInfo->FindOrAddInlineCacheId(bodyScope->GetLocation(), Js::PropertyIds::_superCtorReferenceSymbol, false, true);\n                            m_writer.ElementP(Js::OpCode::InitLocalFld, funcInfo->superCtorRegister, cacheId);\n                        }\n                    }\n                    else if (funcInfo->superScopeSlot == Js::Constants::NoProperty || funcInfo->superCtorScopeSlot == Js::Constants::NoProperty)\n                    {\n                        // While the diag locals walker will pick up super from scoped slots or an activation object,\n                        // it will not pick it up when it is only in a register.\n                        byteCodeFunction->InsertSymbolToRegSlotList(funcInfo->superRegister, Js::PropertyIds::_superReferenceSymbol, funcInfo->varRegsCount);\n                        if (funcInfo->superCtorRegister != Js::Constants::NoRegister)\n                        {\n                            byteCodeFunction->InsertSymbolToRegSlotList(funcInfo->superCtorRegister, Js::PropertyIds::_superCtorReferenceSymbol, funcInfo->varRegsCount);\n                        }\n                    }\n                }\n            }\n        }\n\n        if (funcInfo->newTargetScopeSlot != Js::Constants::NoRegister && !funcInfo->IsGlobalFunction())\n        {\n            EmitInitCapturedNewTarget(funcInfo, bodyScope);\n        }\n\n        // We don't want to load super if we are already in an eval. ScopedLdHomeObj will take care of loading super in that case.\n        if (!(GetFlags() & fscrEval) && !bodyScope->GetIsObject())\n        {\n            if (funcInfo->superScopeSlot != Js::Constants::NoRegister)\n            {\n                this->EmitInternalScopedSlotStore(funcInfo, funcInfo->superScopeSlot, funcInfo->superRegister);\n            }\n\n            if (funcInfo->superCtorScopeSlot != Js::Constants::NoRegister)\n            {\n                this->EmitInternalScopedSlotStore(funcInfo, funcInfo->superCtorScopeSlot, funcInfo->superCtorRegister);\n            }\n        }\n\n        if (funcInfo->IsGlobalFunction())\n        {\n            EnsureNoRedeclarations(pnode->sxFnc.pnodeScopes, funcInfo);\n        }\n\n        ::BeginEmitBlock(pnode->sxFnc.pnodeScopes, this, funcInfo);\n\n        DefineLabels(funcInfo);\n\n        if (pnode->sxFnc.HasNonSimpleParameterList())\n        {\n            this->InitBlockScopedNonTemps(funcInfo->root->sxFnc.pnodeScopes, funcInfo);\n\n            EmitDefaultArgs(funcInfo, pnode);\n\n            if (!currentScope->GetCanMergeWithBodyScope())\n            {\n                Assert(this->GetCurrentScope() == paramScope);\n                // Push the body scope\n                PushScope(bodyScope);\n\n                funcInfo->SetCurrentChildScope(bodyScope);\n\n                // Mark the beginning of the body scope so that new scope slots can be created.\n                this->Writer()->Empty(Js::OpCode::BeginBodyScope);\n            }\n        }\n\n        InitSpecialScopeSlots(funcInfo);\n\n        // Emit all scope-wide function definitions before emitting function bodies\n        // so that calls may reference functions they precede lexically.\n        // Note, global eval scope is a fake local scope and is handled as if it were\n        // a lexical block instead of a true global scope, so do not define the functions\n        // here. They will be defined during BeginEmitBlock.\n        if (!(funcInfo->IsGlobalFunction() && this->IsEvalWithNoParentScopeInfo()))\n        {\n            // This only handles function declarations, which param scope cannot have any.\n            DefineFunctions(funcInfo);\n        }\n\n        DefineUserVars(funcInfo);\n\n        if (pnode->sxFnc.HasNonSimpleParameterList())\n        {\n            this->InitBlockScopedNonTemps(funcInfo->root->sxFnc.pnodeBodyScope, funcInfo);\n        }\n        else\n        {\n            this->InitBlockScopedNonTemps(funcInfo->root->sxFnc.pnodeScopes, funcInfo);\n        }\n\n        if (!pnode->sxFnc.HasNonSimpleParameterList() && funcInfo->GetHasArguments() && !NeedScopeObjectForArguments(funcInfo, pnode))\n        {\n            // If we didn't create a scope object and didn't have default args, we still need to transfer the formals to their slots.\n            MapFormalsWithoutRest(pnode, [&](ParseNode *pnodeArg) { EmitPropStore(pnodeArg->sxVar.sym->GetLocation(), pnodeArg->sxVar.sym, pnodeArg->sxVar.pid, funcInfo); });\n        }\n\n        // Rest needs to trigger use before declaration until all default args have been processed.\n        if (pnode->sxFnc.pnodeRest != nullptr)\n        {\n            pnode->sxFnc.pnodeRest->sxVar.sym->SetNeedDeclaration(false);\n        }\n\n        if (paramScope && !paramScope->GetCanMergeWithBodyScope())\n        {\n            // Emit bytecode to copy the initial values from param names to their corresponding body bindings.\n            // We have to do this after the rest param is marked as false for need declaration.\n            paramScope->ForEachSymbol([&](Symbol* param) {\n                Symbol* varSym = funcInfo->GetBodyScope()->FindLocalSymbol(param->GetName());\n                Assert(varSym || pnode->sxFnc.pnodeName->sxVar.sym == param);\n                Assert(param->GetIsArguments() || param->IsInSlot(funcInfo));\n                if (param->GetIsArguments() && !funcInfo->GetHasArguments())\n                {\n                    // Do not copy the arguments to the body if it is not used\n                }\n                else if (varSym && varSym->GetSymbolType() == STVariable && (varSym->IsInSlot(funcInfo) || varSym->GetLocation() != Js::Constants::NoRegister))\n                {\n                    // Simulating EmitPropLoad here. We can't directly call the method as we have to use the param scope specifically.\n                    // Walking the scope chain is not possible at this time.\n                    Js::RegSlot tempReg = funcInfo->AcquireTmpRegister();\n                    Js::PropertyId slot = param->EnsureScopeSlot(funcInfo);\n                    Js::ProfileId profileId = funcInfo->FindOrAddSlotProfileId(paramScope, slot);\n                    Js::OpCode op = paramScope->GetIsObject() ? Js::OpCode::LdParamObjSlot : Js::OpCode::LdParamSlot;\n                    slot = slot + (paramScope->GetIsObject() ? 0 : Js::ScopeSlots::FirstSlotIndex);\n\n                    this->m_writer.SlotI1(op, tempReg, slot, profileId);\n\n                    if (ShouldTrackDebuggerMetadata() && !varSym->GetIsArguments() && !varSym->IsInSlot(funcInfo))\n                    {\n                        byteCodeFunction->InsertSymbolToRegSlotList(varSym->GetName(), varSym->GetLocation(), funcInfo->varRegsCount);\n                    }\n\n                    this->EmitPropStore(tempReg, varSym, varSym->GetPid(), funcInfo);\n                    funcInfo->ReleaseTmpRegister(tempReg);\n                }\n            });\n\n            // In split scope as the body has a separate closure we have to copy the value of this and other special slots\n            // from param scope to the body scope\n            auto copySpecialSymbolsToBody = [this, funcInfo, paramScope] (Js::PropertyId src, Js::PropertyId dest)\n            {\n                if (dest != Js::Constants::NoProperty)\n                {\n                    Js::RegSlot tempReg = funcInfo->AcquireTmpRegister();\n                    Js::PropertyId slot = src;\n                    Js::ProfileId profileId = funcInfo->FindOrAddSlotProfileId(paramScope, slot);\n                    Js::OpCode op = paramScope->GetIsObject() ? Js::OpCode::LdParamObjSlot : Js::OpCode::LdParamSlot;\n                    slot = slot + (paramScope->GetIsObject() ? 0 : Js::ScopeSlots::FirstSlotIndex);\n\n                    this->m_writer.SlotI1(op, tempReg, slot, profileId);\n\n                    op = funcInfo->bodyScope->GetIsObject() ? Js::OpCode::StLocalObjSlot : Js::OpCode::StLocalSlot;\n                    slot = dest + (funcInfo->bodyScope->GetIsObject() ? 0 : Js::ScopeSlots::FirstSlotIndex);\n                    this->m_writer.SlotI1(op, tempReg, slot);\n                    funcInfo->ReleaseTmpRegister(tempReg);\n                }\n            };\n            copySpecialSymbolsToBody(funcInfo->innerThisScopeSlot, funcInfo->thisScopeSlot);\n            copySpecialSymbolsToBody(funcInfo->innerSuperScopeSlot, funcInfo->superScopeSlot);\n            copySpecialSymbolsToBody(funcInfo->innerSuperCtorScopeSlot, funcInfo->superCtorScopeSlot);\n            copySpecialSymbolsToBody(funcInfo->innerNewTargetScopeSlot, funcInfo->newTargetScopeSlot);\n        }\n\n        if (pnode->sxFnc.pnodeBodyScope != nullptr)\n        {\n            ::BeginEmitBlock(pnode->sxFnc.pnodeBodyScope, this, funcInfo);\n        }\n\n        this->inPrologue = false;\n\n        if (funcInfo->IsGlobalFunction())\n        {\n            EmitGlobalBody(funcInfo);\n        }\n        else\n        {\n            EmitFunctionBody(funcInfo);\n        }\n\n        if (pnode->sxFnc.pnodeBodyScope != nullptr)\n        {\n            ::EndEmitBlock(pnode->sxFnc.pnodeBodyScope, this, funcInfo);\n        }\n        ::EndEmitBlock(pnode->sxFnc.pnodeScopes, this, funcInfo);\n\n        if (!this->IsInDebugMode())\n        {\n            // Release the temp registers that we reserved for inner scopes above.\n            if (innerScopeCount)\n            {\n                Js::RegSlot tmpReg = funcInfo->FirstInnerScopeReg() + innerScopeCount - 1;\n                for (uint i = 0; i < innerScopeCount; i++)\n                {\n                    funcInfo->ReleaseTmpRegister(tmpReg);\n                    tmpReg--;\n                }\n            }\n        }\n\n        Assert(funcInfo->firstTmpReg == firstTmpReg);\n        Assert(funcInfo->curTmpReg == firstTmpReg);\n        Assert(byteCodeFunction->GetFirstTmpReg() == firstTmpReg + byteCodeFunction->GetConstantCount());\n\n        byteCodeFunction->CheckAndSetVarCount(funcInfo->varRegsCount);\n        byteCodeFunction->CheckAndSetOutParamMaxDepth(funcInfo->outArgsMaxDepth);\n        byteCodeFunction->SetForInLoopDepth(funcInfo->GetMaxForInLoopLevel());\n\n        // Do a uint32 add just to verify that we haven't overflowed the reg slot type.\n        UInt32Math::Add(funcInfo->varRegsCount, funcInfo->constRegsCount);\n\n#if DBG_DUMP\n        if (PHASE_STATS1(Js::ByteCodePhase))\n        {\n            Output::Print(_u(\" BCode: %-10d, Aux: %-10d, AuxC: %-10d Total: %-10d,  %s\\n\"),\n                m_writer.ByteCodeDataSize(),\n                m_writer.AuxiliaryDataSize(),\n                m_writer.AuxiliaryContextDataSize(),\n                m_writer.ByteCodeDataSize() + m_writer.AuxiliaryDataSize() + m_writer.AuxiliaryContextDataSize(),\n                funcInfo->name);\n\n            this->scriptContext->byteCodeDataSize += m_writer.ByteCodeDataSize();\n            this->scriptContext->byteCodeAuxiliaryDataSize += m_writer.AuxiliaryDataSize();\n            this->scriptContext->byteCodeAuxiliaryContextDataSize += m_writer.AuxiliaryContextDataSize();\n        }\n#endif\n\n        this->MapCacheIdsToPropertyIds(funcInfo);\n        this->MapReferencedPropertyIds(funcInfo);\n\n        Assert(this->TopFuncInfo() == funcInfo);\n        PopFuncInfo(_u(\"EmitOneFunction\"));\n        m_writer.SetCallSiteCount(m_callSiteId);\n#ifdef LOG_BYTECODE_AST_RATIO\n        m_writer.End(funcInfo->root->sxFnc.astSize, this->maxAstSize);\n#else\n        m_writer.End();\n#endif\n    }\n    catch (...)\n    {\n        // Failed to generate byte-code for this function body (likely OOM or stack overflow). Notify the function body so that\n        // it can revert intermediate state changes that may have taken place during byte code generation before the failure.\n        byteCodeFunction->ResetByteCodeGenState();\n        m_writer.Reset();\n        throw;\n    }\n\n#ifdef PERF_HINT\n    if (PHASE_TRACE1(Js::PerfHintPhase) && !byteCodeFunction->GetIsGlobalFunc())\n    {\n        if (byteCodeFunction->GetHasTry())\n        {\n            WritePerfHint(PerfHints::HasTryBlock_Verbose, byteCodeFunction);\n        }\n\n        if (funcInfo->GetCallsEval())\n        {\n            WritePerfHint(PerfHints::CallsEval_Verbose, byteCodeFunction);\n        }\n        else if (funcInfo->GetChildCallsEval())\n        {\n            WritePerfHint(PerfHints::ChildCallsEval, byteCodeFunction);\n        }\n    }\n#endif\n\n\n    byteCodeFunction->SetInitialDefaultEntryPoint();\n    byteCodeFunction->SetCompileCount(UInt32Math::Add(byteCodeFunction->GetCompileCount(), 1));\n\n#ifdef ENABLE_DEBUG_CONFIG_OPTIONS\n    if (byteCodeFunction->IsInDebugMode() != scriptContext->IsScriptContextInDebugMode()) // debug mode mismatch\n    {\n        if (m_utf8SourceInfo->GetIsLibraryCode())\n        {\n            Assert(!byteCodeFunction->IsInDebugMode()); // Library script byteCode is never in debug mode\n        }\n        else\n        {\n            Js::Throw::FatalInternalError();\n        }\n    }\n#endif\n\n#if DBG_DUMP\n    if (PHASE_DUMP(Js::ByteCodePhase, funcInfo->byteCodeFunction) && Js::Configuration::Global.flags.Verbose)\n    {\n        pnode->Dump();\n    }\n    if (this->Trace() || PHASE_DUMP(Js::ByteCodePhase, funcInfo->byteCodeFunction))\n    {\n        Js::ByteCodeDumper::Dump(byteCodeFunction);\n    }\n    if (PHASE_DUMP(Js::DebuggerScopePhase, funcInfo->byteCodeFunction))\n    {\n        byteCodeFunction->DumpScopes();\n    }\n#endif\n#if ENABLE_NATIVE_CODEGEN\n    if ((!PHASE_OFF(Js::BackEndPhase, funcInfo->byteCodeFunction))\n        && !this->forceNoNative\n        && !this->scriptContext->GetConfig()->IsNoNative())\n    {\n        GenerateFunction(this->scriptContext->GetNativeCodeGenerator(), byteCodeFunction);\n    }\n#endif\n}",
  "abstract_func_before": "void ByteCodeGenerator::EmitOneFunction(ParseNode *VAR_0)\n{\n    Assert(VAR_0 && (VAR_0->nop == VAR_1 || VAR_0->nop == VAR_2));\n    FuncInfo *VAR_3 = VAR_0->sxFnc.funcInfo;\n    Assert(VAR_3 != nullptr);\n\n    if (VAR_3->IsFakeGlobalFunction(this->flags))\n    {\n        return;\n    }\n\n    Js::ParseableFunctionInfo* VAR_4 = VAR_3->byteCodeFunction;\n    VAR_4->SetGrfscr(VAR_4->GetGrfscr() | (this->flags & ~VAR_5));\n    VAR_4->SetSourceInfo(this->GetCurrentSourceIndex(),\n        VAR_3->root,\n        !!(this->flags & VAR_6),\n        ((this->flags & VAR_7) && !(this->flags & VAR_6)));\n\n    VAR_4->SetInParamsCount(VAR_3->inArgsCount);\n    if (VAR_0->sxFnc.HasDefaultArguments())\n    {\n        VAR_4->SetReportedInParamsCount(VAR_0->sxFnc.firstDefaultArg + 1);\n    }\n    else\n    {\n        VAR_4->SetReportedInParamsCount(VAR_3->inArgsCount);\n    }\n\n    if (VAR_3->root->sxFnc.pnodeBody == nullptr)\n    {\n        if (!PHASE_OFF1(Js::SkipNestedDeferredPhase))\n        {\n            VAR_4->BuildDeferredStubs(VAR_3->root);\n        }\n        Assert(!VAR_4->IsFunctionBody() || VAR_4->GetFunctionBody()->GetByteCode() != nullptr);\n        return;\n    }\n\n    Js::FunctionBody* VAR_8 = VAR_3->GetParsedFunctionBody();\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n    VAR_8->SetDeferredStubs(nullptr);\n\n    try\n    {\n        if (!VAR_3->IsGlobalFunction())\n        {\n            /* COMMENT_3 */\n            /* COMMENT_4 */\n            if (CanStackNestedFunc(VAR_3, true) && VAR_8->GetCompileCount() == 0)\n            {\n#if VAR_9\n                VAR_8->SetCanDoStackNestedFunc();\n#endif\n                if (VAR_3->root->sxFnc.astSize <= PnFnc::MaxStackClosureAST)\n                {\n                    VAR_8->SetStackNestedFunc(true);\n                }\n            }\n        }\n\n        if (VAR_8->DoStackNestedFunc())\n        {\n            uint VAR_10 = VAR_8->GetNestedCount();\n            for (uint VAR_11 = 0; VAR_11 < VAR_10; VAR_11++)\n            {\n                Js::FunctionProxy * VAR_12 = VAR_8->GetNestedFunctionProxy(VAR_11);\n                if (VAR_12->IsFunctionBody())\n                {\n                    VAR_12->GetFunctionBody()->SetStackNestedFuncParent(VAR_8->GetFunctionInfo());\n                }\n            }\n        }\n\n        if (VAR_8->GetByteCode() != nullptr)\n        {\n            /* COMMENT_5 */\n            return;\n        }\n\n        /* COMMENT_6 */\n        /* COMMENT_7 */\n        /* COMMENT_8 */\n        if (VAR_3->root->sxFnc.HasOnlyThisStmts() && !IsInDebugMode())\n        {\n            VAR_8->SetHasOnlyThisStmts(true);\n        }\n\n        if (VAR_8->IsInlineApplyDisabled() || this->scriptContext->GetConfig()->IsNoNative())\n        {\n            if ((VAR_0->nop == VAR_2) && (VAR_3->GetHasHeapArguments()) && (!VAR_3->GetCallsEval()) && ApplyEnclosesArgs(VAR_0, this))\n            {\n                bool VAR_13 = true;\n                for (ParseNode* VAR_14 = VAR_3->root->sxFnc.pnodeVars; VAR_14; VAR_14 = VAR_14->sxVar.pnodeNext)\n                {\n                    Symbol* VAR_15 = VAR_14->sxVar.sym;\n                    if (VAR_15->GetSymbolType() == VAR_16 && !VAR_15->GetIsArguments())\n                    {\n                        VAR_13 = false;\n                        break;\n                    }\n                }\n                auto VAR_17 = [](ParseNode *VAR_18, bool *VAR_13)\n                {\n                    if (*VAR_13)\n                    {\n                        for (auto VAR_19 = VAR_18->sxBlock.pnodeLexVars; VAR_19; VAR_19 = VAR_19->sxVar.pnodeNext)\n                        {\n                            Symbol* VAR_15 = VAR_19->sxVar.sym;\n                            if (VAR_15->GetSymbolType() == VAR_16 && !VAR_15->GetIsArguments())\n                            {\n                                *VAR_13 = false;\n                                break;\n                            }\n                        }\n                    }\n                };\n                VAR_17(VAR_3->root->sxFnc.pnodeScopes, &VAR_13);\n                VAR_17(VAR_3->root->sxFnc.pnodeBodyScope, &VAR_13);\n                VAR_3->SetApplyEnclosesArgs(VAR_13);\n            }\n        }\n\n        InitScopeSlotArray(VAR_3);\n        FinalizeRegisters(VAR_3, VAR_8);\n        DebugOnly(Js::RegSlot VAR_20 = VAR_3->varRegsCount);\n\n        /* COMMENT_9 */\n        /* COMMENT_10 */\n        uint VAR_21 = VAR_3->InnerScopeCount();\n        if (!this->IsInDebugMode())\n        {\n            VAR_8->SetInnerScopeCount(VAR_21);\n            if (VAR_21)\n            {\n                VAR_3->SetFirstInnerScopeReg(VAR_3->AcquireTmpRegister());\n                for (uint VAR_11 = 1; VAR_11 < VAR_21; VAR_11++)\n                {\n                    VAR_3->AcquireTmpRegister();\n                }\n            }\n        }\n\n        VAR_3->inlineCacheMap = Anew(VAR_22, FuncInfo::InlineCacheMap,\n            VAR_22,\n            VAR_3->RegCount() /* COMMENT_11 */\n            );\n        VAR_3->rootObjectLoadInlineCacheMap = Anew(VAR_22, FuncInfo::RootObjectInlineCacheIdMap,\n            VAR_22,\n            10);\n        VAR_3->rootObjectLoadMethodInlineCacheMap = Anew(VAR_22, FuncInfo::RootObjectInlineCacheIdMap,\n            VAR_22,\n            10);\n        VAR_3->rootObjectStoreInlineCacheMap = Anew(VAR_22, FuncInfo::RootObjectInlineCacheIdMap,\n            VAR_22,\n            10);\n        VAR_3->referencedPropertyIdToMapIndex = Anew(VAR_22, FuncInfo::RootObjectInlineCacheIdMap,\n            VAR_22,\n            10);\n\n        VAR_8->AllocateLiteralRegexArray();\n        VAR_23 = 0;\n        VAR_24.Begin(VAR_8, VAR_22, this->DoJitLoopBodies(VAR_3), VAR_3->hasLoop, this->IsInDebugMode());\n        this->PushFuncInfo(_u(\"EmitOneFunction\"), VAR_3);\n\n        this->inPrologue = true;\n\n        /* COMMENT_12 */\n        /* COMMENT_13 */\n        /* COMMENT_14 */\n        if (VAR_3->IsClassConstructor())\n        {\n            VAR_24.Empty(Js::OpCode::ChkNewCallFlag);\n        }\n\n        Scope* VAR_25 = VAR_3->GetCurrentChildScope();\n        Scope* VAR_26 = VAR_3->GetParamScope();\n        Scope* VAR_27 = VAR_3->GetBodyScope();\n\n        /* COMMENT_15 */\n        LoadAllConstants(VAR_3);\n        HomeArguments(VAR_3);\n\n        if (!VAR_25->GetCanMergeWithBodyScope())\n        {\n            VAR_8->SetParamAndBodyScopeNotMerged();\n\n            /* COMMENT_16 */\n            PopScope();\n            Assert(this->GetCurrentScope() == VAR_26);\n        }\n\n        if (VAR_3->root->sxFnc.pnodeRest != nullptr)\n        {\n            VAR_8->SetHasRestParameter();\n        }\n\n        if (VAR_3->thisScopeSlot != Js::Constants::NoRegister && !(VAR_3->IsLambda() || (VAR_3->IsGlobalFunction() && this->flags & VAR_28)))\n        {\n            EmitInitCapturedThis(VAR_3, VAR_3->bodyScope);\n        }\n\n        /* COMMENT_17 */\n        if ((VAR_3->HasSuperReference() || (VAR_3->GetCallsEval() && (VAR_3->root->sxFnc.IsMethod() || VAR_3->root->sxFnc.IsConstructor())))\n            /* COMMENT_18 */\n            && !((GetFlags() & VAR_28) && VAR_3->IsGlobalFunction()))\n        {\n            if (VAR_3->IsLambda())\n            {\n                Scope *VAR_29;\n                Js::PropertyId VAR_30 = -1;\n                GetEnclosingNonLambdaScope(VAR_3, VAR_29, VAR_30);\n\n                FuncInfo* VAR_31 = VAR_29->GetFunc();\n\n                if (!VAR_31->IsGlobalFunction())\n                {\n                    /* COMMENT_19 */\n                    EmitInternalScopedSlotLoad(VAR_3, VAR_29, VAR_30, VAR_31->superScopeSlot, VAR_3->superRegister);\n                    if (VAR_3->superCtorRegister != Js::Constants::NoRegister)\n                    {\n                        EmitInternalScopedSlotLoad(VAR_3, VAR_29, VAR_30, VAR_31->superCtorScopeSlot, VAR_3->superCtorRegister);\n                    }\n                }\n                else if (!(GetFlags() & VAR_28))\n                {\n                    /* COMMENT_20 */\n                    VAR_24.Reg1(Js::OpCode::LdUndef, VAR_3->superRegister);\n                }\n                /* COMMENT_21 */\n            }\n            else\n            {\n                VAR_24.Reg1(Js::OpCode::LdHomeObj, VAR_3->superRegister);\n\n                if (VAR_3->superCtorRegister != Js::Constants::NoRegister) /* COMMENT_22 */\n                {\n                    VAR_24.Reg1(Js::OpCode::LdFuncObj, VAR_3->superCtorRegister);\n                }\n\n                if (!VAR_3->IsGlobalFunction())\n                {\n                    if (VAR_27->GetIsObject() && VAR_27->GetLocation() != Js::Constants::NoRegister)\n                    {\n                        /* COMMENT_23 */\n                        uint VAR_32 = VAR_3->FindOrAddInlineCacheId(VAR_27->GetLocation(), Js::PropertyIds::_superReferenceSymbol, false, true);\n                        VAR_24.ElementP(Js::OpCode::InitLocalFld, VAR_3->superRegister, VAR_32);\n                        if (VAR_3->superCtorRegister != Js::Constants::NoRegister)\n                        {\n                            VAR_32 = VAR_3->FindOrAddInlineCacheId(VAR_27->GetLocation(), Js::PropertyIds::_superCtorReferenceSymbol, false, true);\n                            VAR_24.ElementP(Js::OpCode::InitLocalFld, VAR_3->superCtorRegister, VAR_32);\n                        }\n                    }\n                    else if (VAR_3->superScopeSlot == Js::Constants::NoProperty || VAR_3->superCtorScopeSlot == Js::Constants::NoProperty)\n                    {\n                        /* COMMENT_24 */\n                        /* COMMENT_25 */\n                        VAR_8->InsertSymbolToRegSlotList(VAR_3->superRegister, Js::PropertyIds::_superReferenceSymbol, VAR_3->varRegsCount);\n                        if (VAR_3->superCtorRegister != Js::Constants::NoRegister)\n                        {\n                            VAR_8->InsertSymbolToRegSlotList(VAR_3->superCtorRegister, Js::PropertyIds::_superCtorReferenceSymbol, VAR_3->varRegsCount);\n                        }\n                    }\n                }\n            }\n        }\n\n        if (VAR_3->newTargetScopeSlot != Js::Constants::NoRegister && !VAR_3->IsGlobalFunction())\n        {\n            EmitInitCapturedNewTarget(VAR_3, VAR_27);\n        }\n\n        /* COMMENT_26 */\n        if (!(GetFlags() & VAR_28) && !VAR_27->GetIsObject())\n        {\n            if (VAR_3->superScopeSlot != Js::Constants::NoRegister)\n            {\n                this->EmitInternalScopedSlotStore(VAR_3, VAR_3->superScopeSlot, VAR_3->superRegister);\n            }\n\n            if (VAR_3->superCtorScopeSlot != Js::Constants::NoRegister)\n            {\n                this->EmitInternalScopedSlotStore(VAR_3, VAR_3->superCtorScopeSlot, VAR_3->superCtorRegister);\n            }\n        }\n\n        if (VAR_3->IsGlobalFunction())\n        {\n            EnsureNoRedeclarations(VAR_0->sxFnc.pnodeScopes, VAR_3);\n        }\n\n        ::BeginEmitBlock(VAR_0->sxFnc.pnodeScopes, this, VAR_3);\n\n        DefineLabels(VAR_3);\n\n        if (VAR_0->sxFnc.HasNonSimpleParameterList())\n        {\n            this->InitBlockScopedNonTemps(VAR_3->root->sxFnc.pnodeScopes, VAR_3);\n\n            EmitDefaultArgs(VAR_3, VAR_0);\n\n            if (!VAR_25->GetCanMergeWithBodyScope())\n            {\n                Assert(this->GetCurrentScope() == VAR_26);\n                /* COMMENT_27 */\n                PushScope(VAR_27);\n\n                VAR_3->SetCurrentChildScope(VAR_27);\n\n                /* COMMENT_28 */\n                this->Writer()->Empty(Js::OpCode::BeginBodyScope);\n            }\n        }\n\n        InitSpecialScopeSlots(VAR_3);\n\n        /* COMMENT_29 */\n        /* COMMENT_30 */\n        /* COMMENT_31 */\n        /* COMMENT_32 */\n        /* COMMENT_33 */\n        if (!(VAR_3->IsGlobalFunction() && this->IsEvalWithNoParentScopeInfo()))\n        {\n            /* COMMENT_34 */\n            DefineFunctions(VAR_3);\n        }\n\n        DefineUserVars(VAR_3);\n\n        if (VAR_0->sxFnc.HasNonSimpleParameterList())\n        {\n            this->InitBlockScopedNonTemps(VAR_3->root->sxFnc.pnodeBodyScope, VAR_3);\n        }\n        else\n        {\n            this->InitBlockScopedNonTemps(VAR_3->root->sxFnc.pnodeScopes, VAR_3);\n        }\n\n        if (!VAR_0->sxFnc.HasNonSimpleParameterList() && VAR_3->GetHasArguments() && !NeedScopeObjectForArguments(VAR_3, VAR_0))\n        {\n            /* COMMENT_35 */\n            MapFormalsWithoutRest(VAR_0, [&](ParseNode *VAR_33) { EmitPropStore(VAR_33->sxVar.sym->GetLocation(), VAR_33->sxVar.sym, VAR_33->sxVar.pid, VAR_3); });\n        }\n\n        /* COMMENT_36 */\n        if (VAR_0->sxFnc.pnodeRest != nullptr)\n        {\n            VAR_0->sxFnc.pnodeRest->sxVar.sym->SetNeedDeclaration(false);\n        }\n\n        if (VAR_26 && !VAR_26->GetCanMergeWithBodyScope())\n        {\n            /* COMMENT_37 */\n            /* COMMENT_38 */\n            VAR_26->ForEachSymbol([&](Symbol* VAR_34) {\n                Symbol* VAR_35 = VAR_3->GetBodyScope()->FindLocalSymbol(VAR_34->GetName());\n                Assert(VAR_35 || VAR_0->sxFnc.pnodeName->sxVar.sym == VAR_34);\n                Assert(VAR_34->GetIsArguments() || VAR_34->IsInSlot(VAR_3));\n                if (VAR_34->GetIsArguments() && !VAR_3->GetHasArguments())\n                {\n                    /* COMMENT_39 */\n                }\n                else if (VAR_35 && VAR_35->GetSymbolType() == VAR_16 && (VAR_35->IsInSlot(VAR_3) || VAR_35->GetLocation() != Js::Constants::NoRegister))\n                {\n                    /* COMMENT_40 */\n                    /* COMMENT_41 */\n                    Js::RegSlot VAR_36 = VAR_3->AcquireTmpRegister();\n                    Js::PropertyId VAR_37 = VAR_34->EnsureScopeSlot(VAR_3);\n                    Js::ProfileId VAR_38 = VAR_3->FindOrAddSlotProfileId(VAR_26, VAR_37);\n                    Js::OpCode VAR_39 = VAR_26->GetIsObject() ? Js::OpCode::LdParamObjSlot : Js::OpCode::LdParamSlot;\n                    VAR_37 = VAR_37 + (VAR_26->GetIsObject() ? 0 : Js::ScopeSlots::FirstSlotIndex);\n\n                    this->m_writer.SlotI1(VAR_39, VAR_36, VAR_37, VAR_38);\n\n                    if (ShouldTrackDebuggerMetadata() && !VAR_35->GetIsArguments() && !VAR_35->IsInSlot(VAR_3))\n                    {\n                        VAR_8->InsertSymbolToRegSlotList(VAR_35->GetName(), VAR_35->GetLocation(), VAR_3->varRegsCount);\n                    }\n\n                    this->EmitPropStore(VAR_36, VAR_35, VAR_35->GetPid(), VAR_3);\n                    VAR_3->ReleaseTmpRegister(VAR_36);\n                }\n            });\n\n            /* COMMENT_42 */\n            /* COMMENT_43 */\n            auto VAR_40 = [this, VAR_3, VAR_26] (Js::PropertyId VAR_41, Js::PropertyId VAR_42)\n            {\n                if (VAR_42 != Js::Constants::NoProperty)\n                {\n                    Js::RegSlot VAR_36 = VAR_3->AcquireTmpRegister();\n                    Js::PropertyId VAR_37 = VAR_41;\n                    Js::ProfileId VAR_38 = VAR_3->FindOrAddSlotProfileId(VAR_26, VAR_37);\n                    Js::OpCode VAR_39 = VAR_26->GetIsObject() ? Js::OpCode::LdParamObjSlot : Js::OpCode::LdParamSlot;\n                    VAR_37 = VAR_37 + (VAR_26->GetIsObject() ? 0 : Js::ScopeSlots::FirstSlotIndex);\n\n                    this->m_writer.SlotI1(VAR_39, VAR_36, VAR_37, VAR_38);\n\n                    VAR_39 = VAR_3->bodyScope->GetIsObject() ? Js::OpCode::StLocalObjSlot : Js::OpCode::StLocalSlot;\n                    VAR_37 = VAR_42 + (VAR_3->bodyScope->GetIsObject() ? 0 : Js::ScopeSlots::FirstSlotIndex);\n                    this->m_writer.SlotI1(VAR_39, VAR_36, VAR_37);\n                    VAR_3->ReleaseTmpRegister(VAR_36);\n                }\n            };\n            VAR_40(VAR_3->innerThisScopeSlot, VAR_3->thisScopeSlot);\n            VAR_40(VAR_3->innerSuperScopeSlot, VAR_3->superScopeSlot);\n            VAR_40(VAR_3->innerSuperCtorScopeSlot, VAR_3->superCtorScopeSlot);\n            VAR_40(VAR_3->innerNewTargetScopeSlot, VAR_3->newTargetScopeSlot);\n        }\n\n        if (VAR_0->sxFnc.pnodeBodyScope != nullptr)\n        {\n            ::BeginEmitBlock(VAR_0->sxFnc.pnodeBodyScope, this, VAR_3);\n        }\n\n        this->inPrologue = false;\n\n        if (VAR_3->IsGlobalFunction())\n        {\n            EmitGlobalBody(VAR_3);\n        }\n        else\n        {\n            EmitFunctionBody(VAR_3);\n        }\n\n        if (VAR_0->sxFnc.pnodeBodyScope != nullptr)\n        {\n            ::EndEmitBlock(VAR_0->sxFnc.pnodeBodyScope, this, VAR_3);\n        }\n        ::EndEmitBlock(VAR_0->sxFnc.pnodeScopes, this, VAR_3);\n\n        if (!this->IsInDebugMode())\n        {\n            /* COMMENT_44 */\n            if (VAR_21)\n            {\n                Js::RegSlot VAR_43 = VAR_3->FirstInnerScopeReg() + VAR_21 - 1;\n                for (uint VAR_11 = 0; VAR_11 < VAR_21; VAR_11++)\n                {\n                    VAR_3->ReleaseTmpRegister(VAR_43);\n                    VAR_43--;\n                }\n            }\n        }\n\n        Assert(VAR_3->firstTmpReg == VAR_20);\n        Assert(VAR_3->curTmpReg == VAR_20);\n        Assert(VAR_8->GetFirstTmpReg() == VAR_20 + VAR_8->GetConstantCount());\n\n        VAR_8->CheckAndSetVarCount(VAR_3->varRegsCount);\n        VAR_8->CheckAndSetOutParamMaxDepth(VAR_3->outArgsMaxDepth);\n        VAR_8->SetForInLoopDepth(VAR_3->GetMaxForInLoopLevel());\n\n        /* COMMENT_45 */\n        UInt32Math::Add(VAR_3->varRegsCount, VAR_3->constRegsCount);\n\n#if VAR_44\n        if (PHASE_STATS1(Js::ByteCodePhase))\n        {\n            Output::Print(_u(\" BCode: %-10d, Aux: %-10d, AuxC: %-10d Total: %-10d,  %s\\n\"),\n                VAR_24.ByteCodeDataSize(),\n                VAR_24.AuxiliaryDataSize(),\n                VAR_24.AuxiliaryContextDataSize(),\n                VAR_24.ByteCodeDataSize() + VAR_24.AuxiliaryDataSize() + VAR_24.AuxiliaryContextDataSize(),\n                VAR_3->name);\n\n            this->scriptContext->byteCodeDataSize += VAR_24.ByteCodeDataSize();\n            this->scriptContext->byteCodeAuxiliaryDataSize += VAR_24.AuxiliaryDataSize();\n            this->scriptContext->byteCodeAuxiliaryContextDataSize += VAR_24.AuxiliaryContextDataSize();\n        }\n#endif\n\n        this->MapCacheIdsToPropertyIds(VAR_3);\n        this->MapReferencedPropertyIds(VAR_3);\n\n        Assert(this->TopFuncInfo() == VAR_3);\n        PopFuncInfo(_u(\"EmitOneFunction\"));\n        VAR_24.SetCallSiteCount(VAR_23);\n#ifdef VAR_45\n        VAR_24.End(VAR_3->root->sxFnc.astSize, this->maxAstSize);\n#else\n        VAR_24.End();\n#endif\n    }\n    catch (...)\n    {\n        /* COMMENT_46 */\n        /* COMMENT_47 */\n        VAR_8->ResetByteCodeGenState();\n        VAR_24.Reset();\n        throw;\n    }\n\n#ifdef VAR_46\n    if (PHASE_TRACE1(Js::PerfHintPhase) && !VAR_8->GetIsGlobalFunc())\n    {\n        if (VAR_8->GetHasTry())\n        {\n            WritePerfHint(PerfHints::HasTryBlock_Verbose, VAR_8);\n        }\n\n        if (VAR_3->GetCallsEval())\n        {\n            WritePerfHint(PerfHints::CallsEval_Verbose, VAR_8);\n        }\n        else if (VAR_3->GetChildCallsEval())\n        {\n            WritePerfHint(PerfHints::ChildCallsEval, VAR_8);\n        }\n    }\n#endif\n\n\n    VAR_8->SetInitialDefaultEntryPoint();\n    VAR_8->SetCompileCount(UInt32Math::Add(VAR_8->GetCompileCount(), 1));\n\n#ifdef VAR_47\n    if (VAR_8->IsInDebugMode() != VAR_48->IsScriptContextInDebugMode()) /* COMMENT_48 */\n    {\n        if (VAR_49->GetIsLibraryCode())\n        {\n            Assert(!VAR_8->IsInDebugMode()); /* COMMENT_49 */\n        }\n        else\n        {\n            Js::Throw::FatalInternalError();\n        }\n    }\n#endif\n\n#if VAR_44\n    if (PHASE_DUMP(Js::ByteCodePhase, VAR_3->byteCodeFunction) && Js::Configuration::Global.flags.Verbose)\n    {\n        VAR_0->Dump();\n    }\n    if (this->Trace() || PHASE_DUMP(Js::ByteCodePhase, VAR_3->byteCodeFunction))\n    {\n        Js::ByteCodeDumper::Dump(VAR_8);\n    }\n    if (PHASE_DUMP(Js::DebuggerScopePhase, VAR_3->byteCodeFunction))\n    {\n        VAR_8->DumpScopes();\n    }\n#endif\n#if VAR_50\n    if ((!PHASE_OFF(Js::BackEndPhase, VAR_3->byteCodeFunction))\n        && !this->forceNoNative\n        && !this->scriptContext->GetConfig()->IsNoNative())\n    {\n        GenerateFunction(this->scriptContext->GetNativeCodeGenerator(), VAR_8);\n    }\n#endif\n}",
  "func_graph_path_before": null,
  "func": "void ByteCodeGenerator::EmitOneFunction(ParseNode *pnode)\n{\n    Assert(pnode && (pnode->nop == knopProg || pnode->nop == knopFncDecl));\n    FuncInfo *funcInfo = pnode->sxFnc.funcInfo;\n    Assert(funcInfo != nullptr);\n\n    if (funcInfo->IsFakeGlobalFunction(this->flags))\n    {\n        return;\n    }\n\n    Js::ParseableFunctionInfo* deferParseFunction = funcInfo->byteCodeFunction;\n    deferParseFunction->SetGrfscr(deferParseFunction->GetGrfscr() | (this->flags & ~fscrDeferredFncExpression));\n    deferParseFunction->SetSourceInfo(this->GetCurrentSourceIndex(),\n        funcInfo->root,\n        !!(this->flags & fscrEvalCode),\n        ((this->flags & fscrDynamicCode) && !(this->flags & fscrEvalCode)));\n\n    deferParseFunction->SetInParamsCount(funcInfo->inArgsCount);\n    if (pnode->sxFnc.HasDefaultArguments())\n    {\n        deferParseFunction->SetReportedInParamsCount(pnode->sxFnc.firstDefaultArg + 1);\n    }\n    else\n    {\n        deferParseFunction->SetReportedInParamsCount(funcInfo->inArgsCount);\n    }\n\n    if (funcInfo->root->sxFnc.pnodeBody == nullptr)\n    {\n        if (!PHASE_OFF1(Js::SkipNestedDeferredPhase))\n        {\n            deferParseFunction->BuildDeferredStubs(funcInfo->root);\n        }\n        Assert(!deferParseFunction->IsFunctionBody() || deferParseFunction->GetFunctionBody()->GetByteCode() != nullptr);\n        return;\n    }\n\n    Js::FunctionBody* byteCodeFunction = funcInfo->GetParsedFunctionBody();\n    // We've now done a full parse of this function, so we no longer need to remember the extents\n    // and attributes of the top-level nested functions. (The above code has run for all of those,\n    // so they have pointers to the stub sub-trees they need.)\n    byteCodeFunction->SetDeferredStubs(nullptr);\n\n    try\n    {\n        if (!funcInfo->IsGlobalFunction())\n        {\n            // Note: Do not set the stack nested func flag if the function has been redeferred and recompiled.\n            // In that case the flag already has the value we want.\n            if (CanStackNestedFunc(funcInfo, true) && byteCodeFunction->GetCompileCount() == 0)\n            {\n#if DBG\n                byteCodeFunction->SetCanDoStackNestedFunc();\n#endif\n                if (funcInfo->root->sxFnc.astSize <= PnFnc::MaxStackClosureAST)\n                {\n                    byteCodeFunction->SetStackNestedFunc(true);\n                }\n            }\n        }\n\n        if (byteCodeFunction->DoStackNestedFunc())\n        {\n            uint nestedCount = byteCodeFunction->GetNestedCount();\n            for (uint i = 0; i < nestedCount; i++)\n            {\n                Js::FunctionProxy * nested = byteCodeFunction->GetNestedFunctionProxy(i);\n                if (nested->IsFunctionBody())\n                {\n                    nested->GetFunctionBody()->SetStackNestedFuncParent(byteCodeFunction->GetFunctionInfo());\n                }\n            }\n        }\n\n        if (byteCodeFunction->GetByteCode() != nullptr)\n        {\n            // Previously compiled function nested within a re-deferred and re-compiled function.\n            return;\n        }\n\n        // Bug : 301517\n        // In the debug mode the hasOnlyThis optimization needs to be disabled, since user can break in this function\n        // and do operation on 'this' and its property, which may not be defined yet.\n        if (funcInfo->root->sxFnc.HasOnlyThisStmts() && !IsInDebugMode())\n        {\n            byteCodeFunction->SetHasOnlyThisStmts(true);\n        }\n\n        if (byteCodeFunction->IsInlineApplyDisabled() || this->scriptContext->GetConfig()->IsNoNative())\n        {\n            if ((pnode->nop == knopFncDecl) && (funcInfo->GetHasHeapArguments()) && (!funcInfo->GetCallsEval()) && ApplyEnclosesArgs(pnode, this))\n            {\n                bool applyEnclosesArgs = true;\n                for (ParseNode* pnodeVar = funcInfo->root->sxFnc.pnodeVars; pnodeVar; pnodeVar = pnodeVar->sxVar.pnodeNext)\n                {\n                    Symbol* sym = pnodeVar->sxVar.sym;\n                    if (sym->GetSymbolType() == STVariable && !sym->GetIsArguments())\n                    {\n                        applyEnclosesArgs = false;\n                        break;\n                    }\n                }\n                auto constAndLetCheck = [](ParseNode *pnodeBlock, bool *applyEnclosesArgs)\n                {\n                    if (*applyEnclosesArgs)\n                    {\n                        for (auto lexvar = pnodeBlock->sxBlock.pnodeLexVars; lexvar; lexvar = lexvar->sxVar.pnodeNext)\n                        {\n                            Symbol* sym = lexvar->sxVar.sym;\n                            if (sym->GetSymbolType() == STVariable && !sym->GetIsArguments())\n                            {\n                                *applyEnclosesArgs = false;\n                                break;\n                            }\n                        }\n                    }\n                };\n                constAndLetCheck(funcInfo->root->sxFnc.pnodeScopes, &applyEnclosesArgs);\n                constAndLetCheck(funcInfo->root->sxFnc.pnodeBodyScope, &applyEnclosesArgs);\n                funcInfo->SetApplyEnclosesArgs(applyEnclosesArgs);\n            }\n        }\n\n        InitScopeSlotArray(funcInfo);\n        FinalizeRegisters(funcInfo, byteCodeFunction);\n        DebugOnly(Js::RegSlot firstTmpReg = funcInfo->varRegsCount);\n\n        // Reserve temp registers for the inner scopes. We prefer temps because the JIT will then renumber them\n        // and see different lifetimes. (Note that debug mode requires permanent registers. See FinalizeRegisters.)\n        uint innerScopeCount = funcInfo->InnerScopeCount();\n        if (!this->IsInDebugMode())\n        {\n            byteCodeFunction->SetInnerScopeCount(innerScopeCount);\n            if (innerScopeCount)\n            {\n                funcInfo->SetFirstInnerScopeReg(funcInfo->AcquireTmpRegister());\n                for (uint i = 1; i < innerScopeCount; i++)\n                {\n                    funcInfo->AcquireTmpRegister();\n                }\n            }\n        }\n\n        funcInfo->inlineCacheMap = Anew(alloc, FuncInfo::InlineCacheMap,\n            alloc,\n            funcInfo->RegCount() // Pass the actual register count. // TODO: Check if we can reduce this count\n            );\n        funcInfo->rootObjectLoadInlineCacheMap = Anew(alloc, FuncInfo::RootObjectInlineCacheIdMap,\n            alloc,\n            10);\n        funcInfo->rootObjectLoadMethodInlineCacheMap = Anew(alloc, FuncInfo::RootObjectInlineCacheIdMap,\n            alloc,\n            10);\n        funcInfo->rootObjectStoreInlineCacheMap = Anew(alloc, FuncInfo::RootObjectInlineCacheIdMap,\n            alloc,\n            10);\n        funcInfo->referencedPropertyIdToMapIndex = Anew(alloc, FuncInfo::RootObjectInlineCacheIdMap,\n            alloc,\n            10);\n\n        byteCodeFunction->AllocateLiteralRegexArray();\n        m_callSiteId = 0;\n        m_writer.Begin(byteCodeFunction, alloc, this->DoJitLoopBodies(funcInfo), funcInfo->hasLoop, this->IsInDebugMode());\n        this->PushFuncInfo(_u(\"EmitOneFunction\"), funcInfo);\n\n        this->inPrologue = true;\n\n        // Class constructors do not have a [[call]] slot but we don't implement a generic way to express this.\n        // What we do is emit a check for the new flag here. If we don't have CallFlags_New set, the opcode will throw.\n        // We need to do this before emitting 'this' since the base class constructor will try to construct a new object.\n        if (funcInfo->IsClassConstructor())\n        {\n            m_writer.Empty(Js::OpCode::ChkNewCallFlag);\n        }\n\n        Scope* currentScope = funcInfo->GetCurrentChildScope();\n        Scope* paramScope = funcInfo->GetParamScope();\n        Scope* bodyScope = funcInfo->GetBodyScope();\n\n        // For now, emit all constant loads at top of function (should instead put in closest dominator of uses).\n        LoadAllConstants(funcInfo);\n        HomeArguments(funcInfo);\n\n        if (!currentScope->GetCanMergeWithBodyScope())\n        {\n            byteCodeFunction->SetParamAndBodyScopeNotMerged();\n\n            // Pop the body scope before emitting the default args\n            PopScope();\n            Assert(this->GetCurrentScope() == paramScope);\n        }\n\n        if (funcInfo->root->sxFnc.pnodeRest != nullptr)\n        {\n            byteCodeFunction->SetHasRestParameter();\n        }\n\n        if (funcInfo->thisScopeSlot != Js::Constants::NoRegister && !(funcInfo->IsLambda() || (funcInfo->IsGlobalFunction() && this->flags & fscrEval)))\n        {\n            EmitInitCapturedThis(funcInfo, funcInfo->bodyScope);\n        }\n\n        // Any function with a super reference or an eval call inside a method or a constructor needs to load super,\n        if ((funcInfo->HasSuperReference() || (funcInfo->GetCallsEval() && (funcInfo->root->sxFnc.IsMethod() || funcInfo->root->sxFnc.IsConstructor())))\n            // unless we are already inside the 'global' scope inside an eval (in which case 'ScopedLdHomeObj' is emitted at every 'super' reference).\n            && !((GetFlags() & fscrEval) && funcInfo->IsGlobalFunction()))\n        {\n            if (funcInfo->IsLambda())\n            {\n                Scope *scope;\n                Js::PropertyId envIndex = -1;\n                GetEnclosingNonLambdaScope(funcInfo, scope, envIndex);\n\n                FuncInfo* parent = scope->GetFunc();\n\n                if (!parent->IsGlobalFunction())\n                {\n                    // lambda in non-global scope (eval and non-eval)\n                    EmitInternalScopedSlotLoad(funcInfo, scope, envIndex, parent->superScopeSlot, funcInfo->superRegister);\n                    if (funcInfo->superCtorRegister != Js::Constants::NoRegister)\n                    {\n                        EmitInternalScopedSlotLoad(funcInfo, scope, envIndex, parent->superCtorScopeSlot, funcInfo->superCtorRegister);\n                    }\n                }\n                else if (!(GetFlags() & fscrEval))\n                {\n                    // lambda in non-eval global scope\n                    m_writer.Reg1(Js::OpCode::LdUndef, funcInfo->superRegister);\n                }\n                // lambda in eval global scope: ScopedLdHomeObj will handle error throwing\n            }\n            else\n            {\n                m_writer.Reg1(Js::OpCode::LdHomeObj, funcInfo->superRegister);\n\n                if (funcInfo->superCtorRegister != Js::Constants::NoRegister) // super() is allowed only in derived class constructors\n                {\n                    m_writer.Reg1(Js::OpCode::LdFuncObj, funcInfo->superCtorRegister);\n                }\n\n                if (!funcInfo->IsGlobalFunction())\n                {\n                    if (bodyScope->GetIsObject() && bodyScope->GetLocation() != Js::Constants::NoRegister)\n                    {\n                        // Stash the super reference in case something inside the eval or lambda references it.\n                        uint cacheId = funcInfo->FindOrAddInlineCacheId(bodyScope->GetLocation(), Js::PropertyIds::_superReferenceSymbol, false, true);\n                        m_writer.ElementP(Js::OpCode::InitLocalFld, funcInfo->superRegister, cacheId);\n                        if (funcInfo->superCtorRegister != Js::Constants::NoRegister)\n                        {\n                            cacheId = funcInfo->FindOrAddInlineCacheId(bodyScope->GetLocation(), Js::PropertyIds::_superCtorReferenceSymbol, false, true);\n                            m_writer.ElementP(Js::OpCode::InitLocalFld, funcInfo->superCtorRegister, cacheId);\n                        }\n                    }\n                    else if (funcInfo->superScopeSlot == Js::Constants::NoProperty || funcInfo->superCtorScopeSlot == Js::Constants::NoProperty)\n                    {\n                        // While the diag locals walker will pick up super from scoped slots or an activation object,\n                        // it will not pick it up when it is only in a register.\n                        byteCodeFunction->InsertSymbolToRegSlotList(funcInfo->superRegister, Js::PropertyIds::_superReferenceSymbol, funcInfo->varRegsCount);\n                        if (funcInfo->superCtorRegister != Js::Constants::NoRegister)\n                        {\n                            byteCodeFunction->InsertSymbolToRegSlotList(funcInfo->superCtorRegister, Js::PropertyIds::_superCtorReferenceSymbol, funcInfo->varRegsCount);\n                        }\n                    }\n                }\n            }\n        }\n\n        if (funcInfo->newTargetScopeSlot != Js::Constants::NoRegister && !funcInfo->IsGlobalFunction())\n        {\n            EmitInitCapturedNewTarget(funcInfo, bodyScope);\n        }\n\n        // We don't want to load super if we are already in an eval. ScopedLdHomeObj will take care of loading super in that case.\n        if (!(GetFlags() & fscrEval) && !bodyScope->GetIsObject())\n        {\n            if (funcInfo->superScopeSlot != Js::Constants::NoRegister)\n            {\n                this->EmitInternalScopedSlotStore(funcInfo, funcInfo->superScopeSlot, funcInfo->superRegister);\n            }\n\n            if (funcInfo->superCtorScopeSlot != Js::Constants::NoRegister)\n            {\n                this->EmitInternalScopedSlotStore(funcInfo, funcInfo->superCtorScopeSlot, funcInfo->superCtorRegister);\n            }\n        }\n\n        if (funcInfo->IsGlobalFunction())\n        {\n            EnsureNoRedeclarations(pnode->sxFnc.pnodeScopes, funcInfo);\n        }\n\n        ::BeginEmitBlock(pnode->sxFnc.pnodeScopes, this, funcInfo);\n\n        DefineLabels(funcInfo);\n\n        if (pnode->sxFnc.HasNonSimpleParameterList())\n        {\n            this->InitBlockScopedNonTemps(funcInfo->root->sxFnc.pnodeScopes, funcInfo);\n\n            EmitDefaultArgs(funcInfo, pnode);\n\n            if (!currentScope->GetCanMergeWithBodyScope())\n            {\n                Assert(this->GetCurrentScope() == paramScope);\n                // Push the body scope\n                PushScope(bodyScope);\n\n                funcInfo->SetCurrentChildScope(bodyScope);\n\n                // Mark the beginning of the body scope so that new scope slots can be created.\n                this->Writer()->Empty(Js::OpCode::BeginBodyScope);\n            }\n        }\n\n        InitSpecialScopeSlots(funcInfo);\n\n        // Emit all scope-wide function definitions before emitting function bodies\n        // so that calls may reference functions they precede lexically.\n        // Note, global eval scope is a fake local scope and is handled as if it were\n        // a lexical block instead of a true global scope, so do not define the functions\n        // here. They will be defined during BeginEmitBlock.\n        if (!(funcInfo->IsGlobalFunction() && this->IsEvalWithNoParentScopeInfo()))\n        {\n            // This only handles function declarations, which param scope cannot have any.\n            DefineFunctions(funcInfo);\n        }\n\n        DefineUserVars(funcInfo);\n\n        if (pnode->sxFnc.HasNonSimpleParameterList())\n        {\n            this->InitBlockScopedNonTemps(funcInfo->root->sxFnc.pnodeBodyScope, funcInfo);\n        }\n        else\n        {\n            this->InitBlockScopedNonTemps(funcInfo->root->sxFnc.pnodeScopes, funcInfo);\n        }\n\n        if (!pnode->sxFnc.HasNonSimpleParameterList() && funcInfo->GetHasArguments() && !NeedScopeObjectForArguments(funcInfo, pnode))\n        {\n            // If we didn't create a scope object and didn't have default args, we still need to transfer the formals to their slots.\n            MapFormalsWithoutRest(pnode, [&](ParseNode *pnodeArg) { EmitPropStore(pnodeArg->sxVar.sym->GetLocation(), pnodeArg->sxVar.sym, pnodeArg->sxVar.pid, funcInfo); });\n        }\n\n        // Rest needs to trigger use before declaration until all default args have been processed.\n        if (pnode->sxFnc.pnodeRest != nullptr)\n        {\n            pnode->sxFnc.pnodeRest->sxVar.sym->SetNeedDeclaration(false);\n        }\n\n        if (paramScope && !paramScope->GetCanMergeWithBodyScope())\n        {\n            // Emit bytecode to copy the initial values from param names to their corresponding body bindings.\n            // We have to do this after the rest param is marked as false for need declaration.\n            Symbol* funcSym = funcInfo->root->sxFnc.GetFuncSymbol();\n            paramScope->ForEachSymbol([&](Symbol* param) {\n                Symbol* varSym = funcInfo->GetBodyScope()->FindLocalSymbol(param->GetName());\n                Assert(varSym || pnode->sxFnc.pnodeName->sxVar.sym == param);\n                Assert(param->GetIsArguments() || param->IsInSlot(funcInfo));\n                if (param->GetIsArguments() && !funcInfo->GetHasArguments())\n                {\n                    // Do not copy the arguments to the body if it is not used\n                }\n                else if ((funcSym == nullptr || funcSym != param)    // Do not copy the symbol over to body as the function expression symbol\n                                                                     // is expected to stay inside the function expression scope\n                    && (varSym && varSym->GetSymbolType() == STVariable && (varSym->IsInSlot(funcInfo) || varSym->GetLocation() != Js::Constants::NoRegister)))\n                {\n                    // Simulating EmitPropLoad here. We can't directly call the method as we have to use the param scope specifically.\n                    // Walking the scope chain is not possible at this time.\n                    Js::RegSlot tempReg = funcInfo->AcquireTmpRegister();\n                    Js::PropertyId slot = param->EnsureScopeSlot(funcInfo);\n                    Js::ProfileId profileId = funcInfo->FindOrAddSlotProfileId(paramScope, slot);\n                    Js::OpCode op = paramScope->GetIsObject() ? Js::OpCode::LdParamObjSlot : Js::OpCode::LdParamSlot;\n                    slot = slot + (paramScope->GetIsObject() ? 0 : Js::ScopeSlots::FirstSlotIndex);\n\n                    this->m_writer.SlotI1(op, tempReg, slot, profileId);\n\n                    if (ShouldTrackDebuggerMetadata() && !varSym->GetIsArguments() && !varSym->IsInSlot(funcInfo))\n                    {\n                        byteCodeFunction->InsertSymbolToRegSlotList(varSym->GetName(), varSym->GetLocation(), funcInfo->varRegsCount);\n                    }\n\n                    this->EmitPropStore(tempReg, varSym, varSym->GetPid(), funcInfo);\n                    funcInfo->ReleaseTmpRegister(tempReg);\n                }\n            });\n\n            // In split scope as the body has a separate closure we have to copy the value of this and other special slots\n            // from param scope to the body scope\n            auto copySpecialSymbolsToBody = [this, funcInfo, paramScope] (Js::PropertyId src, Js::PropertyId dest)\n            {\n                if (dest != Js::Constants::NoProperty)\n                {\n                    Js::RegSlot tempReg = funcInfo->AcquireTmpRegister();\n                    Js::PropertyId slot = src;\n                    Js::ProfileId profileId = funcInfo->FindOrAddSlotProfileId(paramScope, slot);\n                    Js::OpCode op = paramScope->GetIsObject() ? Js::OpCode::LdParamObjSlot : Js::OpCode::LdParamSlot;\n                    slot = slot + (paramScope->GetIsObject() ? 0 : Js::ScopeSlots::FirstSlotIndex);\n\n                    this->m_writer.SlotI1(op, tempReg, slot, profileId);\n\n                    op = funcInfo->bodyScope->GetIsObject() ? Js::OpCode::StLocalObjSlot : Js::OpCode::StLocalSlot;\n                    slot = dest + (funcInfo->bodyScope->GetIsObject() ? 0 : Js::ScopeSlots::FirstSlotIndex);\n                    this->m_writer.SlotI1(op, tempReg, slot);\n                    funcInfo->ReleaseTmpRegister(tempReg);\n                }\n            };\n            copySpecialSymbolsToBody(funcInfo->innerThisScopeSlot, funcInfo->thisScopeSlot);\n            copySpecialSymbolsToBody(funcInfo->innerSuperScopeSlot, funcInfo->superScopeSlot);\n            copySpecialSymbolsToBody(funcInfo->innerSuperCtorScopeSlot, funcInfo->superCtorScopeSlot);\n            copySpecialSymbolsToBody(funcInfo->innerNewTargetScopeSlot, funcInfo->newTargetScopeSlot);\n        }\n\n        if (pnode->sxFnc.pnodeBodyScope != nullptr)\n        {\n            ::BeginEmitBlock(pnode->sxFnc.pnodeBodyScope, this, funcInfo);\n        }\n\n        this->inPrologue = false;\n\n        if (funcInfo->IsGlobalFunction())\n        {\n            EmitGlobalBody(funcInfo);\n        }\n        else\n        {\n            EmitFunctionBody(funcInfo);\n        }\n\n        if (pnode->sxFnc.pnodeBodyScope != nullptr)\n        {\n            ::EndEmitBlock(pnode->sxFnc.pnodeBodyScope, this, funcInfo);\n        }\n        ::EndEmitBlock(pnode->sxFnc.pnodeScopes, this, funcInfo);\n\n        if (!this->IsInDebugMode())\n        {\n            // Release the temp registers that we reserved for inner scopes above.\n            if (innerScopeCount)\n            {\n                Js::RegSlot tmpReg = funcInfo->FirstInnerScopeReg() + innerScopeCount - 1;\n                for (uint i = 0; i < innerScopeCount; i++)\n                {\n                    funcInfo->ReleaseTmpRegister(tmpReg);\n                    tmpReg--;\n                }\n            }\n        }\n\n        Assert(funcInfo->firstTmpReg == firstTmpReg);\n        Assert(funcInfo->curTmpReg == firstTmpReg);\n        Assert(byteCodeFunction->GetFirstTmpReg() == firstTmpReg + byteCodeFunction->GetConstantCount());\n\n        byteCodeFunction->CheckAndSetVarCount(funcInfo->varRegsCount);\n        byteCodeFunction->CheckAndSetOutParamMaxDepth(funcInfo->outArgsMaxDepth);\n        byteCodeFunction->SetForInLoopDepth(funcInfo->GetMaxForInLoopLevel());\n\n        // Do a uint32 add just to verify that we haven't overflowed the reg slot type.\n        UInt32Math::Add(funcInfo->varRegsCount, funcInfo->constRegsCount);\n\n#if DBG_DUMP\n        if (PHASE_STATS1(Js::ByteCodePhase))\n        {\n            Output::Print(_u(\" BCode: %-10d, Aux: %-10d, AuxC: %-10d Total: %-10d,  %s\\n\"),\n                m_writer.ByteCodeDataSize(),\n                m_writer.AuxiliaryDataSize(),\n                m_writer.AuxiliaryContextDataSize(),\n                m_writer.ByteCodeDataSize() + m_writer.AuxiliaryDataSize() + m_writer.AuxiliaryContextDataSize(),\n                funcInfo->name);\n\n            this->scriptContext->byteCodeDataSize += m_writer.ByteCodeDataSize();\n            this->scriptContext->byteCodeAuxiliaryDataSize += m_writer.AuxiliaryDataSize();\n            this->scriptContext->byteCodeAuxiliaryContextDataSize += m_writer.AuxiliaryContextDataSize();\n        }\n#endif\n\n        this->MapCacheIdsToPropertyIds(funcInfo);\n        this->MapReferencedPropertyIds(funcInfo);\n\n        Assert(this->TopFuncInfo() == funcInfo);\n        PopFuncInfo(_u(\"EmitOneFunction\"));\n        m_writer.SetCallSiteCount(m_callSiteId);\n#ifdef LOG_BYTECODE_AST_RATIO\n        m_writer.End(funcInfo->root->sxFnc.astSize, this->maxAstSize);\n#else\n        m_writer.End();\n#endif\n    }\n    catch (...)\n    {\n        // Failed to generate byte-code for this function body (likely OOM or stack overflow). Notify the function body so that\n        // it can revert intermediate state changes that may have taken place during byte code generation before the failure.\n        byteCodeFunction->ResetByteCodeGenState();\n        m_writer.Reset();\n        throw;\n    }\n\n#ifdef PERF_HINT\n    if (PHASE_TRACE1(Js::PerfHintPhase) && !byteCodeFunction->GetIsGlobalFunc())\n    {\n        if (byteCodeFunction->GetHasTry())\n        {\n            WritePerfHint(PerfHints::HasTryBlock_Verbose, byteCodeFunction);\n        }\n\n        if (funcInfo->GetCallsEval())\n        {\n            WritePerfHint(PerfHints::CallsEval_Verbose, byteCodeFunction);\n        }\n        else if (funcInfo->GetChildCallsEval())\n        {\n            WritePerfHint(PerfHints::ChildCallsEval, byteCodeFunction);\n        }\n    }\n#endif\n\n\n    byteCodeFunction->SetInitialDefaultEntryPoint();\n    byteCodeFunction->SetCompileCount(UInt32Math::Add(byteCodeFunction->GetCompileCount(), 1));\n\n#ifdef ENABLE_DEBUG_CONFIG_OPTIONS\n    if (byteCodeFunction->IsInDebugMode() != scriptContext->IsScriptContextInDebugMode()) // debug mode mismatch\n    {\n        if (m_utf8SourceInfo->GetIsLibraryCode())\n        {\n            Assert(!byteCodeFunction->IsInDebugMode()); // Library script byteCode is never in debug mode\n        }\n        else\n        {\n            Js::Throw::FatalInternalError();\n        }\n    }\n#endif\n\n#if DBG_DUMP\n    if (PHASE_DUMP(Js::ByteCodePhase, funcInfo->byteCodeFunction) && Js::Configuration::Global.flags.Verbose)\n    {\n        pnode->Dump();\n    }\n    if (this->Trace() || PHASE_DUMP(Js::ByteCodePhase, funcInfo->byteCodeFunction))\n    {\n        Js::ByteCodeDumper::Dump(byteCodeFunction);\n    }\n    if (PHASE_DUMP(Js::DebuggerScopePhase, funcInfo->byteCodeFunction))\n    {\n        byteCodeFunction->DumpScopes();\n    }\n#endif\n#if ENABLE_NATIVE_CODEGEN\n    if ((!PHASE_OFF(Js::BackEndPhase, funcInfo->byteCodeFunction))\n        && !this->forceNoNative\n        && !this->scriptContext->GetConfig()->IsNoNative())\n    {\n        GenerateFunction(this->scriptContext->GetNativeCodeGenerator(), byteCodeFunction);\n    }\n#endif\n}",
  "abstract_func": "void ByteCodeGenerator::EmitOneFunction(ParseNode *VAR_0)\n{\n    Assert(VAR_0 && (VAR_0->nop == VAR_1 || VAR_0->nop == VAR_2));\n    FuncInfo *VAR_3 = VAR_0->sxFnc.funcInfo;\n    Assert(VAR_3 != nullptr);\n\n    if (VAR_3->IsFakeGlobalFunction(this->flags))\n    {\n        return;\n    }\n\n    Js::ParseableFunctionInfo* VAR_4 = VAR_3->byteCodeFunction;\n    VAR_4->SetGrfscr(VAR_4->GetGrfscr() | (this->flags & ~VAR_5));\n    VAR_4->SetSourceInfo(this->GetCurrentSourceIndex(),\n        VAR_3->root,\n        !!(this->flags & VAR_6),\n        ((this->flags & VAR_7) && !(this->flags & VAR_6)));\n\n    VAR_4->SetInParamsCount(VAR_3->inArgsCount);\n    if (VAR_0->sxFnc.HasDefaultArguments())\n    {\n        VAR_4->SetReportedInParamsCount(VAR_0->sxFnc.firstDefaultArg + 1);\n    }\n    else\n    {\n        VAR_4->SetReportedInParamsCount(VAR_3->inArgsCount);\n    }\n\n    if (VAR_3->root->sxFnc.pnodeBody == nullptr)\n    {\n        if (!PHASE_OFF1(Js::SkipNestedDeferredPhase))\n        {\n            VAR_4->BuildDeferredStubs(VAR_3->root);\n        }\n        Assert(!VAR_4->IsFunctionBody() || VAR_4->GetFunctionBody()->GetByteCode() != nullptr);\n        return;\n    }\n\n    Js::FunctionBody* VAR_8 = VAR_3->GetParsedFunctionBody();\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n    VAR_8->SetDeferredStubs(nullptr);\n\n    try\n    {\n        if (!VAR_3->IsGlobalFunction())\n        {\n            /* COMMENT_3 */\n            /* COMMENT_4 */\n            if (CanStackNestedFunc(VAR_3, true) && VAR_8->GetCompileCount() == 0)\n            {\n#if VAR_9\n                VAR_8->SetCanDoStackNestedFunc();\n#endif\n                if (VAR_3->root->sxFnc.astSize <= PnFnc::MaxStackClosureAST)\n                {\n                    VAR_8->SetStackNestedFunc(true);\n                }\n            }\n        }\n\n        if (VAR_8->DoStackNestedFunc())\n        {\n            uint VAR_10 = VAR_8->GetNestedCount();\n            for (uint VAR_11 = 0; VAR_11 < VAR_10; VAR_11++)\n            {\n                Js::FunctionProxy * VAR_12 = VAR_8->GetNestedFunctionProxy(VAR_11);\n                if (VAR_12->IsFunctionBody())\n                {\n                    VAR_12->GetFunctionBody()->SetStackNestedFuncParent(VAR_8->GetFunctionInfo());\n                }\n            }\n        }\n\n        if (VAR_8->GetByteCode() != nullptr)\n        {\n            /* COMMENT_5 */\n            return;\n        }\n\n        /* COMMENT_6 */\n        /* COMMENT_7 */\n        /* COMMENT_8 */\n        if (VAR_3->root->sxFnc.HasOnlyThisStmts() && !IsInDebugMode())\n        {\n            VAR_8->SetHasOnlyThisStmts(true);\n        }\n\n        if (VAR_8->IsInlineApplyDisabled() || this->scriptContext->GetConfig()->IsNoNative())\n        {\n            if ((VAR_0->nop == VAR_2) && (VAR_3->GetHasHeapArguments()) && (!VAR_3->GetCallsEval()) && ApplyEnclosesArgs(VAR_0, this))\n            {\n                bool VAR_13 = true;\n                for (ParseNode* VAR_14 = VAR_3->root->sxFnc.pnodeVars; VAR_14; VAR_14 = VAR_14->sxVar.pnodeNext)\n                {\n                    Symbol* VAR_15 = VAR_14->sxVar.sym;\n                    if (VAR_15->GetSymbolType() == VAR_16 && !VAR_15->GetIsArguments())\n                    {\n                        VAR_13 = false;\n                        break;\n                    }\n                }\n                auto VAR_17 = [](ParseNode *VAR_18, bool *VAR_13)\n                {\n                    if (*VAR_13)\n                    {\n                        for (auto VAR_19 = VAR_18->sxBlock.pnodeLexVars; VAR_19; VAR_19 = VAR_19->sxVar.pnodeNext)\n                        {\n                            Symbol* VAR_15 = VAR_19->sxVar.sym;\n                            if (VAR_15->GetSymbolType() == VAR_16 && !VAR_15->GetIsArguments())\n                            {\n                                *VAR_13 = false;\n                                break;\n                            }\n                        }\n                    }\n                };\n                VAR_17(VAR_3->root->sxFnc.pnodeScopes, &VAR_13);\n                VAR_17(VAR_3->root->sxFnc.pnodeBodyScope, &VAR_13);\n                VAR_3->SetApplyEnclosesArgs(VAR_13);\n            }\n        }\n\n        InitScopeSlotArray(VAR_3);\n        FinalizeRegisters(VAR_3, VAR_8);\n        DebugOnly(Js::RegSlot VAR_20 = VAR_3->varRegsCount);\n\n        /* COMMENT_9 */\n        /* COMMENT_10 */\n        uint VAR_21 = VAR_3->InnerScopeCount();\n        if (!this->IsInDebugMode())\n        {\n            VAR_8->SetInnerScopeCount(VAR_21);\n            if (VAR_21)\n            {\n                VAR_3->SetFirstInnerScopeReg(VAR_3->AcquireTmpRegister());\n                for (uint VAR_11 = 1; VAR_11 < VAR_21; VAR_11++)\n                {\n                    VAR_3->AcquireTmpRegister();\n                }\n            }\n        }\n\n        VAR_3->inlineCacheMap = Anew(VAR_22, FuncInfo::InlineCacheMap,\n            VAR_22,\n            VAR_3->RegCount() /* COMMENT_11 */\n            );\n        VAR_3->rootObjectLoadInlineCacheMap = Anew(VAR_22, FuncInfo::RootObjectInlineCacheIdMap,\n            VAR_22,\n            10);\n        VAR_3->rootObjectLoadMethodInlineCacheMap = Anew(VAR_22, FuncInfo::RootObjectInlineCacheIdMap,\n            VAR_22,\n            10);\n        VAR_3->rootObjectStoreInlineCacheMap = Anew(VAR_22, FuncInfo::RootObjectInlineCacheIdMap,\n            VAR_22,\n            10);\n        VAR_3->referencedPropertyIdToMapIndex = Anew(VAR_22, FuncInfo::RootObjectInlineCacheIdMap,\n            VAR_22,\n            10);\n\n        VAR_8->AllocateLiteralRegexArray();\n        VAR_23 = 0;\n        VAR_24.Begin(VAR_8, VAR_22, this->DoJitLoopBodies(VAR_3), VAR_3->hasLoop, this->IsInDebugMode());\n        this->PushFuncInfo(_u(\"EmitOneFunction\"), VAR_3);\n\n        this->inPrologue = true;\n\n        /* COMMENT_12 */\n        /* COMMENT_13 */\n        /* COMMENT_14 */\n        if (VAR_3->IsClassConstructor())\n        {\n            VAR_24.Empty(Js::OpCode::ChkNewCallFlag);\n        }\n\n        Scope* VAR_25 = VAR_3->GetCurrentChildScope();\n        Scope* VAR_26 = VAR_3->GetParamScope();\n        Scope* VAR_27 = VAR_3->GetBodyScope();\n\n        /* COMMENT_15 */\n        LoadAllConstants(VAR_3);\n        HomeArguments(VAR_3);\n\n        if (!VAR_25->GetCanMergeWithBodyScope())\n        {\n            VAR_8->SetParamAndBodyScopeNotMerged();\n\n            /* COMMENT_16 */\n            PopScope();\n            Assert(this->GetCurrentScope() == VAR_26);\n        }\n\n        if (VAR_3->root->sxFnc.pnodeRest != nullptr)\n        {\n            VAR_8->SetHasRestParameter();\n        }\n\n        if (VAR_3->thisScopeSlot != Js::Constants::NoRegister && !(VAR_3->IsLambda() || (VAR_3->IsGlobalFunction() && this->flags & VAR_28)))\n        {\n            EmitInitCapturedThis(VAR_3, VAR_3->bodyScope);\n        }\n\n        /* COMMENT_17 */\n        if ((VAR_3->HasSuperReference() || (VAR_3->GetCallsEval() && (VAR_3->root->sxFnc.IsMethod() || VAR_3->root->sxFnc.IsConstructor())))\n            /* COMMENT_18 */\n            && !((GetFlags() & VAR_28) && VAR_3->IsGlobalFunction()))\n        {\n            if (VAR_3->IsLambda())\n            {\n                Scope *VAR_29;\n                Js::PropertyId VAR_30 = -1;\n                GetEnclosingNonLambdaScope(VAR_3, VAR_29, VAR_30);\n\n                FuncInfo* VAR_31 = VAR_29->GetFunc();\n\n                if (!VAR_31->IsGlobalFunction())\n                {\n                    /* COMMENT_19 */\n                    EmitInternalScopedSlotLoad(VAR_3, VAR_29, VAR_30, VAR_31->superScopeSlot, VAR_3->superRegister);\n                    if (VAR_3->superCtorRegister != Js::Constants::NoRegister)\n                    {\n                        EmitInternalScopedSlotLoad(VAR_3, VAR_29, VAR_30, VAR_31->superCtorScopeSlot, VAR_3->superCtorRegister);\n                    }\n                }\n                else if (!(GetFlags() & VAR_28))\n                {\n                    /* COMMENT_20 */\n                    VAR_24.Reg1(Js::OpCode::LdUndef, VAR_3->superRegister);\n                }\n                /* COMMENT_21 */\n            }\n            else\n            {\n                VAR_24.Reg1(Js::OpCode::LdHomeObj, VAR_3->superRegister);\n\n                if (VAR_3->superCtorRegister != Js::Constants::NoRegister) /* COMMENT_22 */\n                {\n                    VAR_24.Reg1(Js::OpCode::LdFuncObj, VAR_3->superCtorRegister);\n                }\n\n                if (!VAR_3->IsGlobalFunction())\n                {\n                    if (VAR_27->GetIsObject() && VAR_27->GetLocation() != Js::Constants::NoRegister)\n                    {\n                        /* COMMENT_23 */\n                        uint VAR_32 = VAR_3->FindOrAddInlineCacheId(VAR_27->GetLocation(), Js::PropertyIds::_superReferenceSymbol, false, true);\n                        VAR_24.ElementP(Js::OpCode::InitLocalFld, VAR_3->superRegister, VAR_32);\n                        if (VAR_3->superCtorRegister != Js::Constants::NoRegister)\n                        {\n                            VAR_32 = VAR_3->FindOrAddInlineCacheId(VAR_27->GetLocation(), Js::PropertyIds::_superCtorReferenceSymbol, false, true);\n                            VAR_24.ElementP(Js::OpCode::InitLocalFld, VAR_3->superCtorRegister, VAR_32);\n                        }\n                    }\n                    else if (VAR_3->superScopeSlot == Js::Constants::NoProperty || VAR_3->superCtorScopeSlot == Js::Constants::NoProperty)\n                    {\n                        /* COMMENT_24 */\n                        /* COMMENT_25 */\n                        VAR_8->InsertSymbolToRegSlotList(VAR_3->superRegister, Js::PropertyIds::_superReferenceSymbol, VAR_3->varRegsCount);\n                        if (VAR_3->superCtorRegister != Js::Constants::NoRegister)\n                        {\n                            VAR_8->InsertSymbolToRegSlotList(VAR_3->superCtorRegister, Js::PropertyIds::_superCtorReferenceSymbol, VAR_3->varRegsCount);\n                        }\n                    }\n                }\n            }\n        }\n\n        if (VAR_3->newTargetScopeSlot != Js::Constants::NoRegister && !VAR_3->IsGlobalFunction())\n        {\n            EmitInitCapturedNewTarget(VAR_3, VAR_27);\n        }\n\n        /* COMMENT_26 */\n        if (!(GetFlags() & VAR_28) && !VAR_27->GetIsObject())\n        {\n            if (VAR_3->superScopeSlot != Js::Constants::NoRegister)\n            {\n                this->EmitInternalScopedSlotStore(VAR_3, VAR_3->superScopeSlot, VAR_3->superRegister);\n            }\n\n            if (VAR_3->superCtorScopeSlot != Js::Constants::NoRegister)\n            {\n                this->EmitInternalScopedSlotStore(VAR_3, VAR_3->superCtorScopeSlot, VAR_3->superCtorRegister);\n            }\n        }\n\n        if (VAR_3->IsGlobalFunction())\n        {\n            EnsureNoRedeclarations(VAR_0->sxFnc.pnodeScopes, VAR_3);\n        }\n\n        ::BeginEmitBlock(VAR_0->sxFnc.pnodeScopes, this, VAR_3);\n\n        DefineLabels(VAR_3);\n\n        if (VAR_0->sxFnc.HasNonSimpleParameterList())\n        {\n            this->InitBlockScopedNonTemps(VAR_3->root->sxFnc.pnodeScopes, VAR_3);\n\n            EmitDefaultArgs(VAR_3, VAR_0);\n\n            if (!VAR_25->GetCanMergeWithBodyScope())\n            {\n                Assert(this->GetCurrentScope() == VAR_26);\n                /* COMMENT_27 */\n                PushScope(VAR_27);\n\n                VAR_3->SetCurrentChildScope(VAR_27);\n\n                /* COMMENT_28 */\n                this->Writer()->Empty(Js::OpCode::BeginBodyScope);\n            }\n        }\n\n        InitSpecialScopeSlots(VAR_3);\n\n        /* COMMENT_29 */\n        /* COMMENT_30 */\n        /* COMMENT_31 */\n        /* COMMENT_32 */\n        /* COMMENT_33 */\n        if (!(VAR_3->IsGlobalFunction() && this->IsEvalWithNoParentScopeInfo()))\n        {\n            /* COMMENT_34 */\n            DefineFunctions(VAR_3);\n        }\n\n        DefineUserVars(VAR_3);\n\n        if (VAR_0->sxFnc.HasNonSimpleParameterList())\n        {\n            this->InitBlockScopedNonTemps(VAR_3->root->sxFnc.pnodeBodyScope, VAR_3);\n        }\n        else\n        {\n            this->InitBlockScopedNonTemps(VAR_3->root->sxFnc.pnodeScopes, VAR_3);\n        }\n\n        if (!VAR_0->sxFnc.HasNonSimpleParameterList() && VAR_3->GetHasArguments() && !NeedScopeObjectForArguments(VAR_3, VAR_0))\n        {\n            /* COMMENT_35 */\n            MapFormalsWithoutRest(VAR_0, [&](ParseNode *VAR_33) { EmitPropStore(VAR_33->sxVar.sym->GetLocation(), VAR_33->sxVar.sym, VAR_33->sxVar.pid, VAR_3); });\n        }\n\n        /* COMMENT_36 */\n        if (VAR_0->sxFnc.pnodeRest != nullptr)\n        {\n            VAR_0->sxFnc.pnodeRest->sxVar.sym->SetNeedDeclaration(false);\n        }\n\n        if (VAR_26 && !VAR_26->GetCanMergeWithBodyScope())\n        {\n            /* COMMENT_37 */\n            /* COMMENT_38 */\n            Symbol* VAR_34 = VAR_3->root->sxFnc.GetFuncSymbol();\n            VAR_26->ForEachSymbol([&](Symbol* VAR_35) {\n                Symbol* VAR_36 = VAR_3->GetBodyScope()->FindLocalSymbol(VAR_35->GetName());\n                Assert(VAR_36 || VAR_0->sxFnc.pnodeName->sxVar.sym == VAR_35);\n                Assert(VAR_35->GetIsArguments() || VAR_35->IsInSlot(VAR_3));\n                if (VAR_35->GetIsArguments() && !VAR_3->GetHasArguments())\n                {\n                    /* COMMENT_39 */\n                }\n                else if ((VAR_34 == nullptr || VAR_34 != VAR_35)    /* COMMENT_40 */\n                                                                     /* COMMENT_41 */\n                    && (VAR_36 && VAR_36->GetSymbolType() == VAR_16 && (VAR_36->IsInSlot(VAR_3) || VAR_36->GetLocation() != Js::Constants::NoRegister)))\n                {\n                    /* COMMENT_42 */\n                    /* COMMENT_43 */\n                    Js::RegSlot VAR_37 = VAR_3->AcquireTmpRegister();\n                    Js::PropertyId VAR_38 = VAR_35->EnsureScopeSlot(VAR_3);\n                    Js::ProfileId VAR_39 = VAR_3->FindOrAddSlotProfileId(VAR_26, VAR_38);\n                    Js::OpCode VAR_40 = VAR_26->GetIsObject() ? Js::OpCode::LdParamObjSlot : Js::OpCode::LdParamSlot;\n                    VAR_38 = VAR_38 + (VAR_26->GetIsObject() ? 0 : Js::ScopeSlots::FirstSlotIndex);\n\n                    this->m_writer.SlotI1(VAR_40, VAR_37, VAR_38, VAR_39);\n\n                    if (ShouldTrackDebuggerMetadata() && !VAR_36->GetIsArguments() && !VAR_36->IsInSlot(VAR_3))\n                    {\n                        VAR_8->InsertSymbolToRegSlotList(VAR_36->GetName(), VAR_36->GetLocation(), VAR_3->varRegsCount);\n                    }\n\n                    this->EmitPropStore(VAR_37, VAR_36, VAR_36->GetPid(), VAR_3);\n                    VAR_3->ReleaseTmpRegister(VAR_37);\n                }\n            });\n\n            /* COMMENT_44 */\n            /* COMMENT_45 */\n            auto VAR_41 = [this, VAR_3, VAR_26] (Js::PropertyId VAR_42, Js::PropertyId VAR_43)\n            {\n                if (VAR_43 != Js::Constants::NoProperty)\n                {\n                    Js::RegSlot VAR_37 = VAR_3->AcquireTmpRegister();\n                    Js::PropertyId VAR_38 = VAR_42;\n                    Js::ProfileId VAR_39 = VAR_3->FindOrAddSlotProfileId(VAR_26, VAR_38);\n                    Js::OpCode VAR_40 = VAR_26->GetIsObject() ? Js::OpCode::LdParamObjSlot : Js::OpCode::LdParamSlot;\n                    VAR_38 = VAR_38 + (VAR_26->GetIsObject() ? 0 : Js::ScopeSlots::FirstSlotIndex);\n\n                    this->m_writer.SlotI1(VAR_40, VAR_37, VAR_38, VAR_39);\n\n                    VAR_40 = VAR_3->bodyScope->GetIsObject() ? Js::OpCode::StLocalObjSlot : Js::OpCode::StLocalSlot;\n                    VAR_38 = VAR_43 + (VAR_3->bodyScope->GetIsObject() ? 0 : Js::ScopeSlots::FirstSlotIndex);\n                    this->m_writer.SlotI1(VAR_40, VAR_37, VAR_38);\n                    VAR_3->ReleaseTmpRegister(VAR_37);\n                }\n            };\n            VAR_41(VAR_3->innerThisScopeSlot, VAR_3->thisScopeSlot);\n            VAR_41(VAR_3->innerSuperScopeSlot, VAR_3->superScopeSlot);\n            VAR_41(VAR_3->innerSuperCtorScopeSlot, VAR_3->superCtorScopeSlot);\n            VAR_41(VAR_3->innerNewTargetScopeSlot, VAR_3->newTargetScopeSlot);\n        }\n\n        if (VAR_0->sxFnc.pnodeBodyScope != nullptr)\n        {\n            ::BeginEmitBlock(VAR_0->sxFnc.pnodeBodyScope, this, VAR_3);\n        }\n\n        this->inPrologue = false;\n\n        if (VAR_3->IsGlobalFunction())\n        {\n            EmitGlobalBody(VAR_3);\n        }\n        else\n        {\n            EmitFunctionBody(VAR_3);\n        }\n\n        if (VAR_0->sxFnc.pnodeBodyScope != nullptr)\n        {\n            ::EndEmitBlock(VAR_0->sxFnc.pnodeBodyScope, this, VAR_3);\n        }\n        ::EndEmitBlock(VAR_0->sxFnc.pnodeScopes, this, VAR_3);\n\n        if (!this->IsInDebugMode())\n        {\n            /* COMMENT_46 */\n            if (VAR_21)\n            {\n                Js::RegSlot VAR_44 = VAR_3->FirstInnerScopeReg() + VAR_21 - 1;\n                for (uint VAR_11 = 0; VAR_11 < VAR_21; VAR_11++)\n                {\n                    VAR_3->ReleaseTmpRegister(VAR_44);\n                    VAR_44--;\n                }\n            }\n        }\n\n        Assert(VAR_3->firstTmpReg == VAR_20);\n        Assert(VAR_3->curTmpReg == VAR_20);\n        Assert(VAR_8->GetFirstTmpReg() == VAR_20 + VAR_8->GetConstantCount());\n\n        VAR_8->CheckAndSetVarCount(VAR_3->varRegsCount);\n        VAR_8->CheckAndSetOutParamMaxDepth(VAR_3->outArgsMaxDepth);\n        VAR_8->SetForInLoopDepth(VAR_3->GetMaxForInLoopLevel());\n\n        /* COMMENT_47 */\n        UInt32Math::Add(VAR_3->varRegsCount, VAR_3->constRegsCount);\n\n#if VAR_45\n        if (PHASE_STATS1(Js::ByteCodePhase))\n        {\n            Output::Print(_u(\" BCode: %-10d, Aux: %-10d, AuxC: %-10d Total: %-10d,  %s\\n\"),\n                VAR_24.ByteCodeDataSize(),\n                VAR_24.AuxiliaryDataSize(),\n                VAR_24.AuxiliaryContextDataSize(),\n                VAR_24.ByteCodeDataSize() + VAR_24.AuxiliaryDataSize() + VAR_24.AuxiliaryContextDataSize(),\n                VAR_3->name);\n\n            this->scriptContext->byteCodeDataSize += VAR_24.ByteCodeDataSize();\n            this->scriptContext->byteCodeAuxiliaryDataSize += VAR_24.AuxiliaryDataSize();\n            this->scriptContext->byteCodeAuxiliaryContextDataSize += VAR_24.AuxiliaryContextDataSize();\n        }\n#endif\n\n        this->MapCacheIdsToPropertyIds(VAR_3);\n        this->MapReferencedPropertyIds(VAR_3);\n\n        Assert(this->TopFuncInfo() == VAR_3);\n        PopFuncInfo(_u(\"EmitOneFunction\"));\n        VAR_24.SetCallSiteCount(VAR_23);\n#ifdef VAR_46\n        VAR_24.End(VAR_3->root->sxFnc.astSize, this->maxAstSize);\n#else\n        VAR_24.End();\n#endif\n    }\n    catch (...)\n    {\n        /* COMMENT_48 */\n        /* COMMENT_49 */\n        VAR_8->ResetByteCodeGenState();\n        VAR_24.Reset();\n        throw;\n    }\n\n#ifdef VAR_47\n    if (PHASE_TRACE1(Js::PerfHintPhase) && !VAR_8->GetIsGlobalFunc())\n    {\n        if (VAR_8->GetHasTry())\n        {\n            WritePerfHint(PerfHints::HasTryBlock_Verbose, VAR_8);\n        }\n\n        if (VAR_3->GetCallsEval())\n        {\n            WritePerfHint(PerfHints::CallsEval_Verbose, VAR_8);\n        }\n        else if (VAR_3->GetChildCallsEval())\n        {\n            WritePerfHint(PerfHints::ChildCallsEval, VAR_8);\n        }\n    }\n#endif\n\n\n    VAR_8->SetInitialDefaultEntryPoint();\n    VAR_8->SetCompileCount(UInt32Math::Add(VAR_8->GetCompileCount(), 1));\n\n#ifdef VAR_48\n    if (VAR_8->IsInDebugMode() != VAR_49->IsScriptContextInDebugMode()) /* COMMENT_50 */\n    {\n        if (VAR_50->GetIsLibraryCode())\n        {\n            Assert(!VAR_8->IsInDebugMode()); /* COMMENT_51 */\n        }\n        else\n        {\n            Js::Throw::FatalInternalError();\n        }\n    }\n#endif\n\n#if VAR_45\n    if (PHASE_DUMP(Js::ByteCodePhase, VAR_3->byteCodeFunction) && Js::Configuration::Global.flags.Verbose)\n    {\n        VAR_0->Dump();\n    }\n    if (this->Trace() || PHASE_DUMP(Js::ByteCodePhase, VAR_3->byteCodeFunction))\n    {\n        Js::ByteCodeDumper::Dump(VAR_8);\n    }\n    if (PHASE_DUMP(Js::DebuggerScopePhase, VAR_3->byteCodeFunction))\n    {\n        VAR_8->DumpScopes();\n    }\n#endif\n#if VAR_51\n    if ((!PHASE_OFF(Js::BackEndPhase, VAR_3->byteCodeFunction))\n        && !this->forceNoNative\n        && !this->scriptContext->GetConfig()->IsNoNative())\n    {\n        GenerateFunction(this->scriptContext->GetNativeCodeGenerator(), VAR_8);\n    }\n#endif\n}",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -353,6 +353,7 @@\n         {\n             // Emit bytecode to copy the initial values from param names to their corresponding body bindings.\n             // We have to do this after the rest param is marked as false for need declaration.\n+            Symbol* funcSym = funcInfo->root->sxFnc.GetFuncSymbol();\n             paramScope->ForEachSymbol([&](Symbol* param) {\n                 Symbol* varSym = funcInfo->GetBodyScope()->FindLocalSymbol(param->GetName());\n                 Assert(varSym || pnode->sxFnc.pnodeName->sxVar.sym == param);\n@@ -361,7 +362,9 @@\n                 {\n                     // Do not copy the arguments to the body if it is not used\n                 }\n-                else if (varSym && varSym->GetSymbolType() == STVariable && (varSym->IsInSlot(funcInfo) || varSym->GetLocation() != Js::Constants::NoRegister))\n+                else if ((funcSym == nullptr || funcSym != param)    // Do not copy the symbol over to body as the function expression symbol\n+                                                                     // is expected to stay inside the function expression scope\n+                    && (varSym && varSym->GetSymbolType() == STVariable && (varSym->IsInSlot(funcInfo) || varSym->GetLocation() != Js::Constants::NoRegister)))\n                 {\n                     // Simulating EmitPropLoad here. We can't directly call the method as we have to use the param scope specifically.\n                     // Walking the scope chain is not possible at this time.",
  "diff_line_info": {
    "deleted_lines": [
      "                else if (varSym && varSym->GetSymbolType() == STVariable && (varSym->IsInSlot(funcInfo) || varSym->GetLocation() != Js::Constants::NoRegister))"
    ],
    "added_lines": [
      "            Symbol* funcSym = funcInfo->root->sxFnc.GetFuncSymbol();",
      "                else if ((funcSym == nullptr || funcSym != param)    // Do not copy the symbol over to body as the function expression symbol",
      "                                                                     // is expected to stay inside the function expression scope",
      "                    && (varSym && varSym->GetSymbolType() == STVariable && (varSym->IsInSlot(funcInfo) || varSym->GetLocation() != Js::Constants::NoRegister)))"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/chakra-core/ChakraCore/pull/2697",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/chakra-core/ChakraCore/pull/2697: 403 Client Error: Forbidden for url: https://api.github.com/repos/chakra-core/ChakraCore/pulls/2697",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9  \n\nThe patch explicitly references a CVE identifier and addresses a function name capture issue that could lead to security risks, aligning with known vulnerabilities. The code changes target core logic related to function scopes, which is critical for security."
}