{
  "cve_id": "CVE-2018-1000877",
  "cwe_ids": [
    "CWE-415"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "libarchive",
  "commit_msg": "Avoid a double-free when a window size of 0 is specified\n\nnew_size can be 0 with a malicious or corrupted RAR archive.\n\nrealloc(area, 0) is equivalent to free(area), so the region would\nbe free()d here and the free()d again in the cleanup function.\n\nFound with a setup running AFL, afl-rb, and qsym.",
  "commit_hash": "021efa522ad729ff0f5806c4ce53e4a6cc1daa31",
  "git_url": "https://github.com/libarchive/libarchive/commit/021efa522ad729ff0f5806c4ce53e4a6cc1daa31",
  "file_path": "libarchive/archive_read_support_format_rar.c",
  "func_name": "parse_codes",
  "func_before": "static int\nparse_codes(struct archive_read *a)\n{\n  int i, j, val, n, r;\n  unsigned char bitlengths[MAX_SYMBOLS], zerocount, ppmd_flags;\n  unsigned int maxorder;\n  struct huffman_code precode;\n  struct rar *rar = (struct rar *)(a->format->data);\n  struct rar_br *br = &(rar->br);\n\n  free_codes(a);\n\n  /* Skip to the next byte */\n  rar_br_consume_unalined_bits(br);\n\n  /* PPMd block flag */\n  if (!rar_br_read_ahead(a, br, 1))\n    goto truncated_data;\n  if ((rar->is_ppmd_block = rar_br_bits(br, 1)) != 0)\n  {\n    rar_br_consume(br, 1);\n    if (!rar_br_read_ahead(a, br, 7))\n      goto truncated_data;\n    ppmd_flags = rar_br_bits(br, 7);\n    rar_br_consume(br, 7);\n\n    /* Memory is allocated in MB */\n    if (ppmd_flags & 0x20)\n    {\n      if (!rar_br_read_ahead(a, br, 8))\n        goto truncated_data;\n      rar->dictionary_size = (rar_br_bits(br, 8) + 1) << 20;\n      rar_br_consume(br, 8);\n    }\n\n    if (ppmd_flags & 0x40)\n    {\n      if (!rar_br_read_ahead(a, br, 8))\n        goto truncated_data;\n      rar->ppmd_escape = rar->ppmd7_context.InitEsc = rar_br_bits(br, 8);\n      rar_br_consume(br, 8);\n    }\n    else\n      rar->ppmd_escape = 2;\n\n    if (ppmd_flags & 0x20)\n    {\n      maxorder = (ppmd_flags & 0x1F) + 1;\n      if(maxorder > 16)\n        maxorder = 16 + (maxorder - 16) * 3;\n\n      if (maxorder == 1)\n      {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \"Truncated RAR file data\");\n        return (ARCHIVE_FATAL);\n      }\n\n      /* Make sure ppmd7_contest is freed before Ppmd7_Construct\n       * because reading a broken file cause this abnormal sequence. */\n      __archive_ppmd7_functions.Ppmd7_Free(&rar->ppmd7_context);\n\n      rar->bytein.a = a;\n      rar->bytein.Read = &ppmd_read;\n      __archive_ppmd7_functions.PpmdRAR_RangeDec_CreateVTable(&rar->range_dec);\n      rar->range_dec.Stream = &rar->bytein;\n      __archive_ppmd7_functions.Ppmd7_Construct(&rar->ppmd7_context);\n\n      if (rar->dictionary_size == 0) {\n\t      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \"Invalid zero dictionary size\");\n\t      return (ARCHIVE_FATAL);\n      }\n\n      if (!__archive_ppmd7_functions.Ppmd7_Alloc(&rar->ppmd7_context,\n        rar->dictionary_size))\n      {\n        archive_set_error(&a->archive, ENOMEM,\n                          \"Out of memory\");\n        return (ARCHIVE_FATAL);\n      }\n      if (!__archive_ppmd7_functions.PpmdRAR_RangeDec_Init(&rar->range_dec))\n      {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \"Unable to initialize PPMd range decoder\");\n        return (ARCHIVE_FATAL);\n      }\n      __archive_ppmd7_functions.Ppmd7_Init(&rar->ppmd7_context, maxorder);\n      rar->ppmd_valid = 1;\n    }\n    else\n    {\n      if (!rar->ppmd_valid) {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \"Invalid PPMd sequence\");\n        return (ARCHIVE_FATAL);\n      }\n      if (!__archive_ppmd7_functions.PpmdRAR_RangeDec_Init(&rar->range_dec))\n      {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \"Unable to initialize PPMd range decoder\");\n        return (ARCHIVE_FATAL);\n      }\n    }\n  }\n  else\n  {\n    rar_br_consume(br, 1);\n\n    /* Keep existing table flag */\n    if (!rar_br_read_ahead(a, br, 1))\n      goto truncated_data;\n    if (!rar_br_bits(br, 1))\n      memset(rar->lengthtable, 0, sizeof(rar->lengthtable));\n    rar_br_consume(br, 1);\n\n    memset(&bitlengths, 0, sizeof(bitlengths));\n    for (i = 0; i < MAX_SYMBOLS;)\n    {\n      if (!rar_br_read_ahead(a, br, 4))\n        goto truncated_data;\n      bitlengths[i++] = rar_br_bits(br, 4);\n      rar_br_consume(br, 4);\n      if (bitlengths[i-1] == 0xF)\n      {\n        if (!rar_br_read_ahead(a, br, 4))\n          goto truncated_data;\n        zerocount = rar_br_bits(br, 4);\n        rar_br_consume(br, 4);\n        if (zerocount)\n        {\n          i--;\n          for (j = 0; j < zerocount + 2 && i < MAX_SYMBOLS; j++)\n            bitlengths[i++] = 0;\n        }\n      }\n    }\n\n    memset(&precode, 0, sizeof(precode));\n    r = create_code(a, &precode, bitlengths, MAX_SYMBOLS, MAX_SYMBOL_LENGTH);\n    if (r != ARCHIVE_OK) {\n      free(precode.tree);\n      free(precode.table);\n      return (r);\n    }\n\n    for (i = 0; i < HUFFMAN_TABLE_SIZE;)\n    {\n      if ((val = read_next_symbol(a, &precode)) < 0) {\n        free(precode.tree);\n        free(precode.table);\n        return (ARCHIVE_FATAL);\n      }\n      if (val < 16)\n      {\n        rar->lengthtable[i] = (rar->lengthtable[i] + val) & 0xF;\n        i++;\n      }\n      else if (val < 18)\n      {\n        if (i == 0)\n        {\n          free(precode.tree);\n          free(precode.table);\n          archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                            \"Internal error extracting RAR file.\");\n          return (ARCHIVE_FATAL);\n        }\n\n        if(val == 16) {\n          if (!rar_br_read_ahead(a, br, 3)) {\n            free(precode.tree);\n            free(precode.table);\n            goto truncated_data;\n          }\n          n = rar_br_bits(br, 3) + 3;\n          rar_br_consume(br, 3);\n        } else {\n          if (!rar_br_read_ahead(a, br, 7)) {\n            free(precode.tree);\n            free(precode.table);\n            goto truncated_data;\n          }\n          n = rar_br_bits(br, 7) + 11;\n          rar_br_consume(br, 7);\n        }\n\n        for (j = 0; j < n && i < HUFFMAN_TABLE_SIZE; j++)\n        {\n          rar->lengthtable[i] = rar->lengthtable[i-1];\n          i++;\n        }\n      }\n      else\n      {\n        if(val == 18) {\n          if (!rar_br_read_ahead(a, br, 3)) {\n            free(precode.tree);\n            free(precode.table);\n            goto truncated_data;\n          }\n          n = rar_br_bits(br, 3) + 3;\n          rar_br_consume(br, 3);\n        } else {\n          if (!rar_br_read_ahead(a, br, 7)) {\n            free(precode.tree);\n            free(precode.table);\n            goto truncated_data;\n          }\n          n = rar_br_bits(br, 7) + 11;\n          rar_br_consume(br, 7);\n        }\n\n        for(j = 0; j < n && i < HUFFMAN_TABLE_SIZE; j++)\n          rar->lengthtable[i++] = 0;\n      }\n    }\n    free(precode.tree);\n    free(precode.table);\n\n    r = create_code(a, &rar->maincode, &rar->lengthtable[0], MAINCODE_SIZE,\n                MAX_SYMBOL_LENGTH);\n    if (r != ARCHIVE_OK)\n      return (r);\n    r = create_code(a, &rar->offsetcode, &rar->lengthtable[MAINCODE_SIZE],\n                OFFSETCODE_SIZE, MAX_SYMBOL_LENGTH);\n    if (r != ARCHIVE_OK)\n      return (r);\n    r = create_code(a, &rar->lowoffsetcode,\n                &rar->lengthtable[MAINCODE_SIZE + OFFSETCODE_SIZE],\n                LOWOFFSETCODE_SIZE, MAX_SYMBOL_LENGTH);\n    if (r != ARCHIVE_OK)\n      return (r);\n    r = create_code(a, &rar->lengthcode,\n                &rar->lengthtable[MAINCODE_SIZE + OFFSETCODE_SIZE +\n                LOWOFFSETCODE_SIZE], LENGTHCODE_SIZE, MAX_SYMBOL_LENGTH);\n    if (r != ARCHIVE_OK)\n      return (r);\n  }\n\n  if (!rar->dictionary_size || !rar->lzss.window)\n  {\n    /* Seems as though dictionary sizes are not used. Even so, minimize\n     * memory usage as much as possible.\n     */\n    void *new_window;\n    unsigned int new_size;\n\n    if (rar->unp_size >= DICTIONARY_MAX_SIZE)\n      new_size = DICTIONARY_MAX_SIZE;\n    else\n      new_size = rar_fls((unsigned int)rar->unp_size) << 1;\n    new_window = realloc(rar->lzss.window, new_size);\n    if (new_window == NULL) {\n      archive_set_error(&a->archive, ENOMEM,\n                        \"Unable to allocate memory for uncompressed data.\");\n      return (ARCHIVE_FATAL);\n    }\n    rar->lzss.window = (unsigned char *)new_window;\n    rar->dictionary_size = new_size;\n    memset(rar->lzss.window, 0, rar->dictionary_size);\n    rar->lzss.mask = rar->dictionary_size - 1;\n  }\n\n  rar->start_new_table = 0;\n  return (ARCHIVE_OK);\ntruncated_data:\n  archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                    \"Truncated RAR file data\");\n  rar->valid = 0;\n  return (ARCHIVE_FATAL);\n}",
  "abstract_func_before": "static int\nparse_codes(struct archive_read *VAR_0)\n{\n  int VAR_1, VAR_2, VAR_3, VAR_4, VAR_5;\n  unsigned char VAR_6[VAR_7], VAR_8, VAR_9;\n  unsigned int VAR_10;\n  struct huffman_code VAR_11;\n  struct rar *rar = (struct rar *)(VAR_0->format->data);\n  struct rar_br *VAR_12 = &(rar->br);\n\n  free_codes(VAR_0);\n\n  /* COMMENT_0 */\n  rar_br_consume_unalined_bits(VAR_12);\n\n  /* COMMENT_1 */\n  if (!rar_br_read_ahead(VAR_0, VAR_12, 1))\n    goto truncated_data;\n  if ((rar->is_ppmd_block = rar_br_bits(VAR_12, 1)) != 0)\n  {\n    rar_br_consume(VAR_12, 1);\n    if (!rar_br_read_ahead(VAR_0, VAR_12, 7))\n      goto truncated_data;\n    VAR_9 = rar_br_bits(VAR_12, 7);\n    rar_br_consume(VAR_12, 7);\n\n    /* COMMENT_2 */\n    if (VAR_9 & 0x20)\n    {\n      if (!rar_br_read_ahead(VAR_0, VAR_12, 8))\n        goto truncated_data;\n      rar->dictionary_size = (rar_br_bits(VAR_12, 8) + 1) << 20;\n      rar_br_consume(VAR_12, 8);\n    }\n\n    if (VAR_9 & 0x40)\n    {\n      if (!rar_br_read_ahead(VAR_0, VAR_12, 8))\n        goto truncated_data;\n      rar->ppmd_escape = rar->ppmd7_context.InitEsc = rar_br_bits(VAR_12, 8);\n      rar_br_consume(VAR_12, 8);\n    }\n    else\n      rar->ppmd_escape = 2;\n\n    if (VAR_9 & 0x20)\n    {\n      VAR_10 = (VAR_9 & 0x1F) + 1;\n      if(VAR_10 > 16)\n        VAR_10 = 16 + (VAR_10 - 16) * 3;\n\n      if (VAR_10 == 1)\n      {\n        archive_set_error(&VAR_0->archive, VAR_13,\n                          \"Truncated RAR file data\");\n        return (VAR_14);\n      }\n\n      /* COMMENT_3 */\n                                                                       \n      VAR_15.Ppmd7_Free(&rar->ppmd7_context);\n\n      rar->bytein.a = VAR_0;\n      rar->bytein.Read = &VAR_16;\n      VAR_15.PpmdRAR_RangeDec_CreateVTable(&rar->range_dec);\n      rar->range_dec.Stream = &rar->bytein;\n      VAR_15.Ppmd7_Construct(&rar->ppmd7_context);\n\n      if (rar->dictionary_size == 0) {\n\t      archive_set_error(&VAR_0->archive, VAR_13,\n                          \"Invalid zero dictionary size\");\n\t      return (VAR_14);\n      }\n\n      if (!VAR_15.Ppmd7_Alloc(&rar->ppmd7_context,\n        rar->dictionary_size))\n      {\n        archive_set_error(&VAR_0->archive, VAR_17,\n                          \"Out of memory\");\n        return (VAR_14);\n      }\n      if (!VAR_15.PpmdRAR_RangeDec_Init(&rar->range_dec))\n      {\n        archive_set_error(&VAR_0->archive, VAR_13,\n                          \"Unable to initialize PPMd range decoder\");\n        return (VAR_14);\n      }\n      VAR_15.Ppmd7_Init(&rar->ppmd7_context, VAR_10);\n      rar->ppmd_valid = 1;\n    }\n    else\n    {\n      if (!rar->ppmd_valid) {\n        archive_set_error(&VAR_0->archive, VAR_13,\n                          \"Invalid PPMd sequence\");\n        return (VAR_14);\n      }\n      if (!VAR_15.PpmdRAR_RangeDec_Init(&rar->range_dec))\n      {\n        archive_set_error(&VAR_0->archive, VAR_13,\n                          \"Unable to initialize PPMd range decoder\");\n        return (VAR_14);\n      }\n    }\n  }\n  else\n  {\n    rar_br_consume(VAR_12, 1);\n\n    /* COMMENT_5 */\n    if (!rar_br_read_ahead(VAR_0, VAR_12, 1))\n      goto truncated_data;\n    if (!rar_br_bits(VAR_12, 1))\n      memset(rar->lengthtable, 0, sizeof(rar->lengthtable));\n    rar_br_consume(VAR_12, 1);\n\n    memset(&VAR_6, 0, sizeof(VAR_6));\n    for (VAR_1 = 0; VAR_1 < VAR_7;)\n    {\n      if (!rar_br_read_ahead(VAR_0, VAR_12, 4))\n        goto truncated_data;\n      VAR_6[VAR_1++] = rar_br_bits(VAR_12, 4);\n      rar_br_consume(VAR_12, 4);\n      if (VAR_6[VAR_1-1] == 0xF)\n      {\n        if (!rar_br_read_ahead(VAR_0, VAR_12, 4))\n          goto truncated_data;\n        VAR_8 = rar_br_bits(VAR_12, 4);\n        rar_br_consume(VAR_12, 4);\n        if (VAR_8)\n        {\n          VAR_1--;\n          for (VAR_2 = 0; VAR_2 < VAR_8 + 2 && VAR_1 < VAR_7; VAR_2++)\n            VAR_6[VAR_1++] = 0;\n        }\n      }\n    }\n\n    memset(&VAR_11, 0, sizeof(VAR_11));\n    VAR_5 = create_code(VAR_0, &VAR_11, VAR_6, VAR_7, VAR_18);\n    if (VAR_5 != VAR_19) {\n      free(VAR_11.tree);\n      free(VAR_11.table);\n      return (VAR_5);\n    }\n\n    for (VAR_1 = 0; VAR_1 < VAR_20;)\n    {\n      if ((VAR_3 = read_next_symbol(VAR_0, &VAR_11)) < 0) {\n        free(VAR_11.tree);\n        free(VAR_11.table);\n        return (VAR_14);\n      }\n      if (VAR_3 < 16)\n      {\n        rar->lengthtable[VAR_1] = (rar->lengthtable[VAR_1] + VAR_3) & 0xF;\n        VAR_1++;\n      }\n      else if (VAR_3 < 18)\n      {\n        if (VAR_1 == 0)\n        {\n          free(VAR_11.tree);\n          free(VAR_11.table);\n          archive_set_error(&VAR_0->archive, VAR_13,\n                            \"Internal error extracting RAR file.\");\n          return (VAR_14);\n        }\n\n        if(VAR_3 == 16) {\n          if (!rar_br_read_ahead(VAR_0, VAR_12, 3)) {\n            free(VAR_11.tree);\n            free(VAR_11.table);\n            goto truncated_data;\n          }\n          VAR_4 = rar_br_bits(VAR_12, 3) + 3;\n          rar_br_consume(VAR_12, 3);\n        } else {\n          if (!rar_br_read_ahead(VAR_0, VAR_12, 7)) {\n            free(VAR_11.tree);\n            free(VAR_11.table);\n            goto truncated_data;\n          }\n          VAR_4 = rar_br_bits(VAR_12, 7) + 11;\n          rar_br_consume(VAR_12, 7);\n        }\n\n        for (VAR_2 = 0; VAR_2 < VAR_4 && VAR_1 < VAR_20; VAR_2++)\n        {\n          rar->lengthtable[VAR_1] = rar->lengthtable[VAR_1-1];\n          VAR_1++;\n        }\n      }\n      else\n      {\n        if(VAR_3 == 18) {\n          if (!rar_br_read_ahead(VAR_0, VAR_12, 3)) {\n            free(VAR_11.tree);\n            free(VAR_11.table);\n            goto truncated_data;\n          }\n          VAR_4 = rar_br_bits(VAR_12, 3) + 3;\n          rar_br_consume(VAR_12, 3);\n        } else {\n          if (!rar_br_read_ahead(VAR_0, VAR_12, 7)) {\n            free(VAR_11.tree);\n            free(VAR_11.table);\n            goto truncated_data;\n          }\n          VAR_4 = rar_br_bits(VAR_12, 7) + 11;\n          rar_br_consume(VAR_12, 7);\n        }\n\n        for(VAR_2 = 0; VAR_2 < VAR_4 && VAR_1 < VAR_20; VAR_2++)\n          rar->lengthtable[VAR_1++] = 0;\n      }\n    }\n    free(VAR_11.tree);\n    free(VAR_11.table);\n\n    VAR_5 = create_code(VAR_0, &rar->maincode, &rar->lengthtable[0], VAR_21,\n                VAR_18);\n    if (VAR_5 != VAR_19)\n      return (VAR_5);\n    VAR_5 = create_code(VAR_0, &rar->offsetcode, &rar->lengthtable[VAR_21],\n                VAR_22, VAR_18);\n    if (VAR_5 != VAR_19)\n      return (VAR_5);\n    VAR_5 = create_code(VAR_0, &rar->lowoffsetcode,\n                &rar->lengthtable[VAR_21 + VAR_22],\n                VAR_23, VAR_18);\n    if (VAR_5 != VAR_19)\n      return (VAR_5);\n    VAR_5 = create_code(VAR_0, &rar->lengthcode,\n                &rar->lengthtable[VAR_21 + VAR_22 +\n                VAR_23], VAR_24, VAR_18);\n    if (VAR_5 != VAR_19)\n      return (VAR_5);\n  }\n\n  if (!rar->dictionary_size || !rar->lzss.window)\n  {\n    /* COMMENT_6 */\n                                        \n       \n    void *VAR_25;\n    unsigned int VAR_26;\n\n    if (rar->unp_size >= VAR_27)\n      VAR_26 = VAR_27;\n    else\n      VAR_26 = rar_fls((unsigned int)rar->unp_size) << 1;\n    VAR_25 = realloc(rar->lzss.window, VAR_26);\n    if (VAR_25 == NULL) {\n      archive_set_error(&VAR_0->archive, VAR_17,\n                        \"Unable to allocate memory for uncompressed data.\");\n      return (VAR_14);\n    }\n    rar->lzss.window = (unsigned char *)VAR_25;\n    rar->dictionary_size = VAR_26;\n    memset(rar->lzss.window, 0, rar->dictionary_size);\n    rar->lzss.mask = rar->dictionary_size - 1;\n  }\n\n  rar->start_new_table = 0;\n  return (VAR_19);\ntruncated_data:\n  archive_set_error(&VAR_0->archive, VAR_13,\n                    \"Truncated RAR file data\");\n  rar->valid = 0;\n  return (VAR_14);\n}",
  "func_graph_path_before": "libarchive/021efa522ad729ff0f5806c4ce53e4a6cc1daa31/archive_read_support_format_rar.c/vul/before/0.json",
  "func": "static int\nparse_codes(struct archive_read *a)\n{\n  int i, j, val, n, r;\n  unsigned char bitlengths[MAX_SYMBOLS], zerocount, ppmd_flags;\n  unsigned int maxorder;\n  struct huffman_code precode;\n  struct rar *rar = (struct rar *)(a->format->data);\n  struct rar_br *br = &(rar->br);\n\n  free_codes(a);\n\n  /* Skip to the next byte */\n  rar_br_consume_unalined_bits(br);\n\n  /* PPMd block flag */\n  if (!rar_br_read_ahead(a, br, 1))\n    goto truncated_data;\n  if ((rar->is_ppmd_block = rar_br_bits(br, 1)) != 0)\n  {\n    rar_br_consume(br, 1);\n    if (!rar_br_read_ahead(a, br, 7))\n      goto truncated_data;\n    ppmd_flags = rar_br_bits(br, 7);\n    rar_br_consume(br, 7);\n\n    /* Memory is allocated in MB */\n    if (ppmd_flags & 0x20)\n    {\n      if (!rar_br_read_ahead(a, br, 8))\n        goto truncated_data;\n      rar->dictionary_size = (rar_br_bits(br, 8) + 1) << 20;\n      rar_br_consume(br, 8);\n    }\n\n    if (ppmd_flags & 0x40)\n    {\n      if (!rar_br_read_ahead(a, br, 8))\n        goto truncated_data;\n      rar->ppmd_escape = rar->ppmd7_context.InitEsc = rar_br_bits(br, 8);\n      rar_br_consume(br, 8);\n    }\n    else\n      rar->ppmd_escape = 2;\n\n    if (ppmd_flags & 0x20)\n    {\n      maxorder = (ppmd_flags & 0x1F) + 1;\n      if(maxorder > 16)\n        maxorder = 16 + (maxorder - 16) * 3;\n\n      if (maxorder == 1)\n      {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \"Truncated RAR file data\");\n        return (ARCHIVE_FATAL);\n      }\n\n      /* Make sure ppmd7_contest is freed before Ppmd7_Construct\n       * because reading a broken file cause this abnormal sequence. */\n      __archive_ppmd7_functions.Ppmd7_Free(&rar->ppmd7_context);\n\n      rar->bytein.a = a;\n      rar->bytein.Read = &ppmd_read;\n      __archive_ppmd7_functions.PpmdRAR_RangeDec_CreateVTable(&rar->range_dec);\n      rar->range_dec.Stream = &rar->bytein;\n      __archive_ppmd7_functions.Ppmd7_Construct(&rar->ppmd7_context);\n\n      if (rar->dictionary_size == 0) {\n\t      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \"Invalid zero dictionary size\");\n\t      return (ARCHIVE_FATAL);\n      }\n\n      if (!__archive_ppmd7_functions.Ppmd7_Alloc(&rar->ppmd7_context,\n        rar->dictionary_size))\n      {\n        archive_set_error(&a->archive, ENOMEM,\n                          \"Out of memory\");\n        return (ARCHIVE_FATAL);\n      }\n      if (!__archive_ppmd7_functions.PpmdRAR_RangeDec_Init(&rar->range_dec))\n      {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \"Unable to initialize PPMd range decoder\");\n        return (ARCHIVE_FATAL);\n      }\n      __archive_ppmd7_functions.Ppmd7_Init(&rar->ppmd7_context, maxorder);\n      rar->ppmd_valid = 1;\n    }\n    else\n    {\n      if (!rar->ppmd_valid) {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \"Invalid PPMd sequence\");\n        return (ARCHIVE_FATAL);\n      }\n      if (!__archive_ppmd7_functions.PpmdRAR_RangeDec_Init(&rar->range_dec))\n      {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \"Unable to initialize PPMd range decoder\");\n        return (ARCHIVE_FATAL);\n      }\n    }\n  }\n  else\n  {\n    rar_br_consume(br, 1);\n\n    /* Keep existing table flag */\n    if (!rar_br_read_ahead(a, br, 1))\n      goto truncated_data;\n    if (!rar_br_bits(br, 1))\n      memset(rar->lengthtable, 0, sizeof(rar->lengthtable));\n    rar_br_consume(br, 1);\n\n    memset(&bitlengths, 0, sizeof(bitlengths));\n    for (i = 0; i < MAX_SYMBOLS;)\n    {\n      if (!rar_br_read_ahead(a, br, 4))\n        goto truncated_data;\n      bitlengths[i++] = rar_br_bits(br, 4);\n      rar_br_consume(br, 4);\n      if (bitlengths[i-1] == 0xF)\n      {\n        if (!rar_br_read_ahead(a, br, 4))\n          goto truncated_data;\n        zerocount = rar_br_bits(br, 4);\n        rar_br_consume(br, 4);\n        if (zerocount)\n        {\n          i--;\n          for (j = 0; j < zerocount + 2 && i < MAX_SYMBOLS; j++)\n            bitlengths[i++] = 0;\n        }\n      }\n    }\n\n    memset(&precode, 0, sizeof(precode));\n    r = create_code(a, &precode, bitlengths, MAX_SYMBOLS, MAX_SYMBOL_LENGTH);\n    if (r != ARCHIVE_OK) {\n      free(precode.tree);\n      free(precode.table);\n      return (r);\n    }\n\n    for (i = 0; i < HUFFMAN_TABLE_SIZE;)\n    {\n      if ((val = read_next_symbol(a, &precode)) < 0) {\n        free(precode.tree);\n        free(precode.table);\n        return (ARCHIVE_FATAL);\n      }\n      if (val < 16)\n      {\n        rar->lengthtable[i] = (rar->lengthtable[i] + val) & 0xF;\n        i++;\n      }\n      else if (val < 18)\n      {\n        if (i == 0)\n        {\n          free(precode.tree);\n          free(precode.table);\n          archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                            \"Internal error extracting RAR file.\");\n          return (ARCHIVE_FATAL);\n        }\n\n        if(val == 16) {\n          if (!rar_br_read_ahead(a, br, 3)) {\n            free(precode.tree);\n            free(precode.table);\n            goto truncated_data;\n          }\n          n = rar_br_bits(br, 3) + 3;\n          rar_br_consume(br, 3);\n        } else {\n          if (!rar_br_read_ahead(a, br, 7)) {\n            free(precode.tree);\n            free(precode.table);\n            goto truncated_data;\n          }\n          n = rar_br_bits(br, 7) + 11;\n          rar_br_consume(br, 7);\n        }\n\n        for (j = 0; j < n && i < HUFFMAN_TABLE_SIZE; j++)\n        {\n          rar->lengthtable[i] = rar->lengthtable[i-1];\n          i++;\n        }\n      }\n      else\n      {\n        if(val == 18) {\n          if (!rar_br_read_ahead(a, br, 3)) {\n            free(precode.tree);\n            free(precode.table);\n            goto truncated_data;\n          }\n          n = rar_br_bits(br, 3) + 3;\n          rar_br_consume(br, 3);\n        } else {\n          if (!rar_br_read_ahead(a, br, 7)) {\n            free(precode.tree);\n            free(precode.table);\n            goto truncated_data;\n          }\n          n = rar_br_bits(br, 7) + 11;\n          rar_br_consume(br, 7);\n        }\n\n        for(j = 0; j < n && i < HUFFMAN_TABLE_SIZE; j++)\n          rar->lengthtable[i++] = 0;\n      }\n    }\n    free(precode.tree);\n    free(precode.table);\n\n    r = create_code(a, &rar->maincode, &rar->lengthtable[0], MAINCODE_SIZE,\n                MAX_SYMBOL_LENGTH);\n    if (r != ARCHIVE_OK)\n      return (r);\n    r = create_code(a, &rar->offsetcode, &rar->lengthtable[MAINCODE_SIZE],\n                OFFSETCODE_SIZE, MAX_SYMBOL_LENGTH);\n    if (r != ARCHIVE_OK)\n      return (r);\n    r = create_code(a, &rar->lowoffsetcode,\n                &rar->lengthtable[MAINCODE_SIZE + OFFSETCODE_SIZE],\n                LOWOFFSETCODE_SIZE, MAX_SYMBOL_LENGTH);\n    if (r != ARCHIVE_OK)\n      return (r);\n    r = create_code(a, &rar->lengthcode,\n                &rar->lengthtable[MAINCODE_SIZE + OFFSETCODE_SIZE +\n                LOWOFFSETCODE_SIZE], LENGTHCODE_SIZE, MAX_SYMBOL_LENGTH);\n    if (r != ARCHIVE_OK)\n      return (r);\n  }\n\n  if (!rar->dictionary_size || !rar->lzss.window)\n  {\n    /* Seems as though dictionary sizes are not used. Even so, minimize\n     * memory usage as much as possible.\n     */\n    void *new_window;\n    unsigned int new_size;\n\n    if (rar->unp_size >= DICTIONARY_MAX_SIZE)\n      new_size = DICTIONARY_MAX_SIZE;\n    else\n      new_size = rar_fls((unsigned int)rar->unp_size) << 1;\n    if (new_size == 0) {\n      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                        \"Zero window size is invalid.\");\n      return (ARCHIVE_FATAL);\n    }\n    new_window = realloc(rar->lzss.window, new_size);\n    if (new_window == NULL) {\n      archive_set_error(&a->archive, ENOMEM,\n                        \"Unable to allocate memory for uncompressed data.\");\n      return (ARCHIVE_FATAL);\n    }\n    rar->lzss.window = (unsigned char *)new_window;\n    rar->dictionary_size = new_size;\n    memset(rar->lzss.window, 0, rar->dictionary_size);\n    rar->lzss.mask = rar->dictionary_size - 1;\n  }\n\n  rar->start_new_table = 0;\n  return (ARCHIVE_OK);\ntruncated_data:\n  archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                    \"Truncated RAR file data\");\n  rar->valid = 0;\n  return (ARCHIVE_FATAL);\n}",
  "abstract_func": "static int\nparse_codes(struct archive_read *VAR_0)\n{\n  int VAR_1, VAR_2, VAR_3, VAR_4, VAR_5;\n  unsigned char VAR_6[VAR_7], VAR_8, VAR_9;\n  unsigned int VAR_10;\n  struct huffman_code VAR_11;\n  struct rar *rar = (struct rar *)(VAR_0->format->data);\n  struct rar_br *VAR_12 = &(rar->br);\n\n  free_codes(VAR_0);\n\n  /* COMMENT_0 */\n  rar_br_consume_unalined_bits(VAR_12);\n\n  /* COMMENT_1 */\n  if (!rar_br_read_ahead(VAR_0, VAR_12, 1))\n    goto truncated_data;\n  if ((rar->is_ppmd_block = rar_br_bits(VAR_12, 1)) != 0)\n  {\n    rar_br_consume(VAR_12, 1);\n    if (!rar_br_read_ahead(VAR_0, VAR_12, 7))\n      goto truncated_data;\n    VAR_9 = rar_br_bits(VAR_12, 7);\n    rar_br_consume(VAR_12, 7);\n\n    /* COMMENT_2 */\n    if (VAR_9 & 0x20)\n    {\n      if (!rar_br_read_ahead(VAR_0, VAR_12, 8))\n        goto truncated_data;\n      rar->dictionary_size = (rar_br_bits(VAR_12, 8) + 1) << 20;\n      rar_br_consume(VAR_12, 8);\n    }\n\n    if (VAR_9 & 0x40)\n    {\n      if (!rar_br_read_ahead(VAR_0, VAR_12, 8))\n        goto truncated_data;\n      rar->ppmd_escape = rar->ppmd7_context.InitEsc = rar_br_bits(VAR_12, 8);\n      rar_br_consume(VAR_12, 8);\n    }\n    else\n      rar->ppmd_escape = 2;\n\n    if (VAR_9 & 0x20)\n    {\n      VAR_10 = (VAR_9 & 0x1F) + 1;\n      if(VAR_10 > 16)\n        VAR_10 = 16 + (VAR_10 - 16) * 3;\n\n      if (VAR_10 == 1)\n      {\n        archive_set_error(&VAR_0->archive, VAR_13,\n                          \"Truncated RAR file data\");\n        return (VAR_14);\n      }\n\n      /* COMMENT_3 */\n                                                                       \n      VAR_15.Ppmd7_Free(&rar->ppmd7_context);\n\n      rar->bytein.a = VAR_0;\n      rar->bytein.Read = &VAR_16;\n      VAR_15.PpmdRAR_RangeDec_CreateVTable(&rar->range_dec);\n      rar->range_dec.Stream = &rar->bytein;\n      VAR_15.Ppmd7_Construct(&rar->ppmd7_context);\n\n      if (rar->dictionary_size == 0) {\n\t      archive_set_error(&VAR_0->archive, VAR_13,\n                          \"Invalid zero dictionary size\");\n\t      return (VAR_14);\n      }\n\n      if (!VAR_15.Ppmd7_Alloc(&rar->ppmd7_context,\n        rar->dictionary_size))\n      {\n        archive_set_error(&VAR_0->archive, VAR_17,\n                          \"Out of memory\");\n        return (VAR_14);\n      }\n      if (!VAR_15.PpmdRAR_RangeDec_Init(&rar->range_dec))\n      {\n        archive_set_error(&VAR_0->archive, VAR_13,\n                          \"Unable to initialize PPMd range decoder\");\n        return (VAR_14);\n      }\n      VAR_15.Ppmd7_Init(&rar->ppmd7_context, VAR_10);\n      rar->ppmd_valid = 1;\n    }\n    else\n    {\n      if (!rar->ppmd_valid) {\n        archive_set_error(&VAR_0->archive, VAR_13,\n                          \"Invalid PPMd sequence\");\n        return (VAR_14);\n      }\n      if (!VAR_15.PpmdRAR_RangeDec_Init(&rar->range_dec))\n      {\n        archive_set_error(&VAR_0->archive, VAR_13,\n                          \"Unable to initialize PPMd range decoder\");\n        return (VAR_14);\n      }\n    }\n  }\n  else\n  {\n    rar_br_consume(VAR_12, 1);\n\n    /* COMMENT_5 */\n    if (!rar_br_read_ahead(VAR_0, VAR_12, 1))\n      goto truncated_data;\n    if (!rar_br_bits(VAR_12, 1))\n      memset(rar->lengthtable, 0, sizeof(rar->lengthtable));\n    rar_br_consume(VAR_12, 1);\n\n    memset(&VAR_6, 0, sizeof(VAR_6));\n    for (VAR_1 = 0; VAR_1 < VAR_7;)\n    {\n      if (!rar_br_read_ahead(VAR_0, VAR_12, 4))\n        goto truncated_data;\n      VAR_6[VAR_1++] = rar_br_bits(VAR_12, 4);\n      rar_br_consume(VAR_12, 4);\n      if (VAR_6[VAR_1-1] == 0xF)\n      {\n        if (!rar_br_read_ahead(VAR_0, VAR_12, 4))\n          goto truncated_data;\n        VAR_8 = rar_br_bits(VAR_12, 4);\n        rar_br_consume(VAR_12, 4);\n        if (VAR_8)\n        {\n          VAR_1--;\n          for (VAR_2 = 0; VAR_2 < VAR_8 + 2 && VAR_1 < VAR_7; VAR_2++)\n            VAR_6[VAR_1++] = 0;\n        }\n      }\n    }\n\n    memset(&VAR_11, 0, sizeof(VAR_11));\n    VAR_5 = create_code(VAR_0, &VAR_11, VAR_6, VAR_7, VAR_18);\n    if (VAR_5 != VAR_19) {\n      free(VAR_11.tree);\n      free(VAR_11.table);\n      return (VAR_5);\n    }\n\n    for (VAR_1 = 0; VAR_1 < VAR_20;)\n    {\n      if ((VAR_3 = read_next_symbol(VAR_0, &VAR_11)) < 0) {\n        free(VAR_11.tree);\n        free(VAR_11.table);\n        return (VAR_14);\n      }\n      if (VAR_3 < 16)\n      {\n        rar->lengthtable[VAR_1] = (rar->lengthtable[VAR_1] + VAR_3) & 0xF;\n        VAR_1++;\n      }\n      else if (VAR_3 < 18)\n      {\n        if (VAR_1 == 0)\n        {\n          free(VAR_11.tree);\n          free(VAR_11.table);\n          archive_set_error(&VAR_0->archive, VAR_13,\n                            \"Internal error extracting RAR file.\");\n          return (VAR_14);\n        }\n\n        if(VAR_3 == 16) {\n          if (!rar_br_read_ahead(VAR_0, VAR_12, 3)) {\n            free(VAR_11.tree);\n            free(VAR_11.table);\n            goto truncated_data;\n          }\n          VAR_4 = rar_br_bits(VAR_12, 3) + 3;\n          rar_br_consume(VAR_12, 3);\n        } else {\n          if (!rar_br_read_ahead(VAR_0, VAR_12, 7)) {\n            free(VAR_11.tree);\n            free(VAR_11.table);\n            goto truncated_data;\n          }\n          VAR_4 = rar_br_bits(VAR_12, 7) + 11;\n          rar_br_consume(VAR_12, 7);\n        }\n\n        for (VAR_2 = 0; VAR_2 < VAR_4 && VAR_1 < VAR_20; VAR_2++)\n        {\n          rar->lengthtable[VAR_1] = rar->lengthtable[VAR_1-1];\n          VAR_1++;\n        }\n      }\n      else\n      {\n        if(VAR_3 == 18) {\n          if (!rar_br_read_ahead(VAR_0, VAR_12, 3)) {\n            free(VAR_11.tree);\n            free(VAR_11.table);\n            goto truncated_data;\n          }\n          VAR_4 = rar_br_bits(VAR_12, 3) + 3;\n          rar_br_consume(VAR_12, 3);\n        } else {\n          if (!rar_br_read_ahead(VAR_0, VAR_12, 7)) {\n            free(VAR_11.tree);\n            free(VAR_11.table);\n            goto truncated_data;\n          }\n          VAR_4 = rar_br_bits(VAR_12, 7) + 11;\n          rar_br_consume(VAR_12, 7);\n        }\n\n        for(VAR_2 = 0; VAR_2 < VAR_4 && VAR_1 < VAR_20; VAR_2++)\n          rar->lengthtable[VAR_1++] = 0;\n      }\n    }\n    free(VAR_11.tree);\n    free(VAR_11.table);\n\n    VAR_5 = create_code(VAR_0, &rar->maincode, &rar->lengthtable[0], VAR_21,\n                VAR_18);\n    if (VAR_5 != VAR_19)\n      return (VAR_5);\n    VAR_5 = create_code(VAR_0, &rar->offsetcode, &rar->lengthtable[VAR_21],\n                VAR_22, VAR_18);\n    if (VAR_5 != VAR_19)\n      return (VAR_5);\n    VAR_5 = create_code(VAR_0, &rar->lowoffsetcode,\n                &rar->lengthtable[VAR_21 + VAR_22],\n                VAR_23, VAR_18);\n    if (VAR_5 != VAR_19)\n      return (VAR_5);\n    VAR_5 = create_code(VAR_0, &rar->lengthcode,\n                &rar->lengthtable[VAR_21 + VAR_22 +\n                VAR_23], VAR_24, VAR_18);\n    if (VAR_5 != VAR_19)\n      return (VAR_5);\n  }\n\n  if (!rar->dictionary_size || !rar->lzss.window)\n  {\n    /* COMMENT_6 */\n                                        \n       \n    void *VAR_25;\n    unsigned int VAR_26;\n\n    if (rar->unp_size >= VAR_27)\n      VAR_26 = VAR_27;\n    else\n      VAR_26 = rar_fls((unsigned int)rar->unp_size) << 1;\n    if (VAR_26 == 0) {\n      archive_set_error(&VAR_0->archive, VAR_13,\n                        \"Zero window size is invalid.\");\n      return (VAR_14);\n    }\n    VAR_25 = realloc(rar->lzss.window, VAR_26);\n    if (VAR_25 == NULL) {\n      archive_set_error(&VAR_0->archive, VAR_17,\n                        \"Unable to allocate memory for uncompressed data.\");\n      return (VAR_14);\n    }\n    rar->lzss.window = (unsigned char *)VAR_25;\n    rar->dictionary_size = VAR_26;\n    memset(rar->lzss.window, 0, rar->dictionary_size);\n    rar->lzss.mask = rar->dictionary_size - 1;\n  }\n\n  rar->start_new_table = 0;\n  return (VAR_19);\ntruncated_data:\n  archive_set_error(&VAR_0->archive, VAR_13,\n                    \"Truncated RAR file data\");\n  rar->valid = 0;\n  return (VAR_14);\n}",
  "func_graph_path": "libarchive/021efa522ad729ff0f5806c4ce53e4a6cc1daa31/archive_read_support_format_rar.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -250,6 +250,11 @@\n       new_size = DICTIONARY_MAX_SIZE;\n     else\n       new_size = rar_fls((unsigned int)rar->unp_size) << 1;\n+    if (new_size == 0) {\n+      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n+                        \"Zero window size is invalid.\");\n+      return (ARCHIVE_FATAL);\n+    }\n     new_window = realloc(rar->lzss.window, new_size);\n     if (new_window == NULL) {\n       archive_set_error(&a->archive, ENOMEM,",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "    if (new_size == 0) {",
      "      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,",
      "                        \"Zero window size is invalid.\");",
      "      return (ARCHIVE_FATAL);",
      "    }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libarchive/libarchive/pull/1105",
  "description": {
    "pr_info": {
      "title": "Fix various crash, memory corruption and infinite loop conditions",
      "number": 1105
    },
    "comment": [
      "I have found some hangs, crashes and memory corruption issues in libarchive.\r\n\r\nTwo are in the RAR decoder. The first (patch 1) is a double-free via a `realloc(area, 0)`. This leads to a crash.\r\n\r\nThe second (patch 2) is memory corruption which seems to arise in ppmd7 decoding. The code can be made to read and write to a previously freed ppmd buffer by tricking the read-ahead code around multi-part archives. (This can be done even with a single archive file.) My gut feeling is that someone more skilled than I could cause arbitrary code execution with this, but I cannot say for certain.\r\n\r\nThere is a crash in ACL parsing for tar archives (patch 3). This is a simple NULL dereference leading to a crash.\r\n\r\nThe last of this batch is a quasi-infinite loop in the warc code (patch 4), where data isn't consumed after being written out, so a large Content-Length can be used to consume almost limitless time and space, leading to a DoS condition.\r\n\r\nThese were found with a combination of AFL, afl-rb and qsym.",
      "There are some test cases at https://bugs.launchpad.net/ubuntu/+source/libarchive/+bug/1794909\r\n\r\n",
      "I have requested CVEs for these issues through the Distributed Weakness Filing project.",
      "In case someone else is looking for the CVEs, it looks like the assignments are :\r\n- CVE-2018-1000877 for https://github.com/libarchive/libarchive/commit/021efa522ad729ff0f5806c4ce53e4a6cc1daa31\r\n- CVE-2018-1000878 for https://github.com/libarchive/libarchive/commit/bfcfe6f04ed20db2504db8a254d1f40a1d84eb28\r\n- CVE-2018-1000879 for https://github.com/libarchive/libarchive/commit/15bf44fd2c1ad0e3fd87048b3fcc90c4dcff1175\r\n- CVE-2018-1000880 for https://github.com/libarchive/libarchive/commit/9c84b7426660c09c18cc349f6d70b5f8168b5680"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95"
}