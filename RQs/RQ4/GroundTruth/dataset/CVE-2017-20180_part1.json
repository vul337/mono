{
  "cve_id": "CVE-2017-20180",
  "cwe_ids": [
    "CWE-345"
  ],
  "cvss_vector": "AV:A/AC:L/Au:S/C:N/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "Zerocoin/libzerocoin",
  "commit_msg": "Patch serial # exploit.\n\nThe serial # range needs to be checked or else the serial number is able to be incremented to a value that will create a valid proof, thus allowing multiple spends of a single mint.",
  "commit_hash": "ce103a09ec079d0a0ed95475992348bed6e860de",
  "git_url": "https://github.com/Zerocoin/libzerocoin/commit/ce103a09ec079d0a0ed95475992348bed6e860de",
  "file_path": "CoinSpend.cpp",
  "func_name": "CoinSpend::CoinSpend",
  "func_before": "CoinSpend::CoinSpend(const Params* p, const PrivateCoin& coin,\n                     Accumulator& a, const AccumulatorWitness& witness, const SpendMetaData& m):\n\tparams(p),\n\tdenomination(coin.getPublicCoin().getDenomination()),\n\tcoinSerialNumber((coin.getSerialNumber())),\n\taccumulatorPoK(&p->accumulatorParams),\n\tserialNumberSoK(p),\n\tcommitmentPoK(&p->serialNumberSoKCommitmentGroup, &p->accumulatorParams.accumulatorPoKCommitmentGroup) {\n\n\t// Sanity check: let's verify that the Witness is valid with respect to\n\t// the coin and Accumulator provided.\n\tif (!(witness.VerifyWitness(a, coin.getPublicCoin()))) {\n\t\tthrow ZerocoinException(\"Accumulator witness does not verify\");\n\t}\n\n\t// 1: Generate two separate commitments to the public coin (C), each under\n\t// a different set of public parameters. We do this because the RSA accumulator\n\t// has specific requirements for the commitment parameters that are not\n\t// compatible with the group we use for the serial number proof.\n\t// Specifically, our serial number proof requires the order of the commitment group\n\t// to be the same as the modulus of the upper group. The Accumulator proof requires a\n\t// group with a significantly larger order.\n\tconst Commitment fullCommitmentToCoinUnderSerialParams(&p->serialNumberSoKCommitmentGroup, coin.getPublicCoin().getValue());\n\tthis->serialCommitmentToCoinValue = fullCommitmentToCoinUnderSerialParams.getCommitmentValue();\n\n\tconst Commitment fullCommitmentToCoinUnderAccParams(&p->accumulatorParams.accumulatorPoKCommitmentGroup, coin.getPublicCoin().getValue());\n\tthis->accCommitmentToCoinValue = fullCommitmentToCoinUnderAccParams.getCommitmentValue();\n\n\t// 2. Generate a ZK proof that the two commitments contain the same public coin.\n\tthis->commitmentPoK = CommitmentProofOfKnowledge(&p->serialNumberSoKCommitmentGroup, &p->accumulatorParams.accumulatorPoKCommitmentGroup, fullCommitmentToCoinUnderSerialParams, fullCommitmentToCoinUnderAccParams);\n\n\t// Now generate the two core ZK proofs:\n\t// 3. Proves that the committed public coin is in the Accumulator (PoK of \"witness\")\n\tthis->accumulatorPoK = AccumulatorProofOfKnowledge(&p->accumulatorParams, fullCommitmentToCoinUnderAccParams, witness, a);\n\n\t// 4. Proves that the coin is correct w.r.t. serial number and hidden coin secret\n\t// (This proof is bound to the coin 'metadata', i.e., transaction hash)\n\tthis->serialNumberSoK = SerialNumberSignatureOfKnowledge(p, coin, fullCommitmentToCoinUnderSerialParams, signatureHash(m));\n}",
  "abstract_func_before": "CoinSpend::CoinSpend(const Params* VAR_0, const PrivateCoin& VAR_1,\n                     Accumulator& VAR_2, const AccumulatorWitness& VAR_3, const SpendMetaData& VAR_4):\n\tparams(VAR_0),\n\tdenomination(VAR_1.getPublicCoin().getDenomination()),\n\tcoinSerialNumber((VAR_1.getSerialNumber())),\n\taccumulatorPoK(&VAR_0->accumulatorParams),\n\tserialNumberSoK(VAR_0),\n\tcommitmentPoK(&VAR_0->serialNumberSoKCommitmentGroup, &VAR_0->accumulatorParams.accumulatorPoKCommitmentGroup) {\n\n\t/* COMMENT_0 */\n\t/* COMMENT_1 */\n\tif (!(VAR_3.VerifyWitness(VAR_2, VAR_1.getPublicCoin()))) {\n\t\tthrow ZerocoinException(\"Accumulator witness does not verify\");\n\t}\n\n\t/* COMMENT_2 */\n\t/* COMMENT_3 */\n\t/* COMMENT_4 */\n\t/* COMMENT_5 */\n\t/* COMMENT_6 */\n\t/* COMMENT_7 */\n\t/* COMMENT_8 */\n\tconst Commitment VAR_5(&VAR_0->serialNumberSoKCommitmentGroup, VAR_1.getPublicCoin().getValue());\n\tthis->serialCommitmentToCoinValue = VAR_5.getCommitmentValue();\n\n\tconst Commitment VAR_6(&VAR_0->accumulatorParams.accumulatorPoKCommitmentGroup, VAR_1.getPublicCoin().getValue());\n\tthis->accCommitmentToCoinValue = VAR_6.getCommitmentValue();\n\n\t/* COMMENT_9 */\n\tthis->commitmentPoK = CommitmentProofOfKnowledge(&VAR_0->serialNumberSoKCommitmentGroup, &VAR_0->accumulatorParams.accumulatorPoKCommitmentGroup, VAR_5, VAR_6);\n\n\t/* COMMENT_10 */\n\t/* COMMENT_11 */\n\tthis->accumulatorPoK = AccumulatorProofOfKnowledge(&VAR_0->accumulatorParams, VAR_6, VAR_3, VAR_2);\n\n\t/* COMMENT_12 */\n\t/* COMMENT_13 */\n\tthis->serialNumberSoK = SerialNumberSignatureOfKnowledge(VAR_0, VAR_1, VAR_5, signatureHash(VAR_4));\n}",
  "func_graph_path_before": "Zerocoin/libzerocoin/ce103a09ec079d0a0ed95475992348bed6e860de/CoinSpend.cpp/vul/before/0.json",
  "func": "CoinSpend::CoinSpend(const Params* p, const PrivateCoin& coin,\n                     Accumulator& a, const AccumulatorWitness& witness, const SpendMetaData& m):\n\tparams(p),\n\tdenomination(coin.getPublicCoin().getDenomination()),\n\tcoinSerialNumber((coin.getSerialNumber())),\n\taccumulatorPoK(&p->accumulatorParams),\n\tserialNumberSoK(p),\n\tcommitmentPoK(&p->serialNumberSoKCommitmentGroup, &p->accumulatorParams.accumulatorPoKCommitmentGroup) {\n\n\t// Sanity check: let's verify that the Witness is valid with respect to\n\t// the coin and Accumulator provided.\n\tif (!(witness.VerifyWitness(a, coin.getPublicCoin()))) {\n\t\tthrow ZerocoinException(\"Accumulator witness does not verify\");\n\t}\n\n\t// The serial # needs to be within the specified range our else it can be incremented by the modulus and create another valid proof\n\tif (!HasValidSerial()) {\n\t\tthrow ZerocoinException(\"Invalid serial # range\");\n\t}\n\n\t// 1: Generate two separate commitments to the public coin (C), each under\n\t// a different set of public parameters. We do this because the RSA accumulator\n\t// has specific requirements for the commitment parameters that are not\n\t// compatible with the group we use for the serial number proof.\n\t// Specifically, our serial number proof requires the order of the commitment group\n\t// to be the same as the modulus of the upper group. The Accumulator proof requires a\n\t// group with a significantly larger order.\n\tconst Commitment fullCommitmentToCoinUnderSerialParams(&p->serialNumberSoKCommitmentGroup, coin.getPublicCoin().getValue());\n\tthis->serialCommitmentToCoinValue = fullCommitmentToCoinUnderSerialParams.getCommitmentValue();\n\n\tconst Commitment fullCommitmentToCoinUnderAccParams(&p->accumulatorParams.accumulatorPoKCommitmentGroup, coin.getPublicCoin().getValue());\n\tthis->accCommitmentToCoinValue = fullCommitmentToCoinUnderAccParams.getCommitmentValue();\n\n\t// 2. Generate a ZK proof that the two commitments contain the same public coin.\n\tthis->commitmentPoK = CommitmentProofOfKnowledge(&p->serialNumberSoKCommitmentGroup, &p->accumulatorParams.accumulatorPoKCommitmentGroup, fullCommitmentToCoinUnderSerialParams, fullCommitmentToCoinUnderAccParams);\n\n\t// Now generate the two core ZK proofs:\n\t// 3. Proves that the committed public coin is in the Accumulator (PoK of \"witness\")\n\tthis->accumulatorPoK = AccumulatorProofOfKnowledge(&p->accumulatorParams, fullCommitmentToCoinUnderAccParams, witness, a);\n\n\t// 4. Proves that the coin is correct w.r.t. serial number and hidden coin secret\n\t// (This proof is bound to the coin 'metadata', i.e., transaction hash)\n\tthis->serialNumberSoK = SerialNumberSignatureOfKnowledge(p, coin, fullCommitmentToCoinUnderSerialParams, signatureHash(m));\n}",
  "abstract_func": "CoinSpend::CoinSpend(const Params* VAR_0, const PrivateCoin& VAR_1,\n                     Accumulator& VAR_2, const AccumulatorWitness& VAR_3, const SpendMetaData& VAR_4):\n\tparams(VAR_0),\n\tdenomination(VAR_1.getPublicCoin().getDenomination()),\n\tcoinSerialNumber((VAR_1.getSerialNumber())),\n\taccumulatorPoK(&VAR_0->accumulatorParams),\n\tserialNumberSoK(VAR_0),\n\tcommitmentPoK(&VAR_0->serialNumberSoKCommitmentGroup, &VAR_0->accumulatorParams.accumulatorPoKCommitmentGroup) {\n\n\t/* COMMENT_0 */\n\t/* COMMENT_1 */\n\tif (!(VAR_3.VerifyWitness(VAR_2, VAR_1.getPublicCoin()))) {\n\t\tthrow ZerocoinException(\"Accumulator witness does not verify\");\n\t}\n\n\t/* COMMENT_2 */\n\tif (!HasValidSerial()) {\n\t\tthrow ZerocoinException(\"Invalid serial # range\");\n\t}\n\n\t/* COMMENT_3 */\n\t/* COMMENT_4 */\n\t/* COMMENT_5 */\n\t/* COMMENT_6 */\n\t/* COMMENT_7 */\n\t/* COMMENT_8 */\n\t/* COMMENT_9 */\n\tconst Commitment VAR_5(&VAR_0->serialNumberSoKCommitmentGroup, VAR_1.getPublicCoin().getValue());\n\tthis->serialCommitmentToCoinValue = VAR_5.getCommitmentValue();\n\n\tconst Commitment VAR_6(&VAR_0->accumulatorParams.accumulatorPoKCommitmentGroup, VAR_1.getPublicCoin().getValue());\n\tthis->accCommitmentToCoinValue = VAR_6.getCommitmentValue();\n\n\t/* COMMENT_10 */\n\tthis->commitmentPoK = CommitmentProofOfKnowledge(&VAR_0->serialNumberSoKCommitmentGroup, &VAR_0->accumulatorParams.accumulatorPoKCommitmentGroup, VAR_5, VAR_6);\n\n\t/* COMMENT_11 */\n\t/* COMMENT_12 */\n\tthis->accumulatorPoK = AccumulatorProofOfKnowledge(&VAR_0->accumulatorParams, VAR_6, VAR_3, VAR_2);\n\n\t/* COMMENT_13 */\n\t/* COMMENT_14 */\n\tthis->serialNumberSoK = SerialNumberSignatureOfKnowledge(VAR_0, VAR_1, VAR_5, signatureHash(VAR_4));\n}",
  "func_graph_path": "Zerocoin/libzerocoin/ce103a09ec079d0a0ed95475992348bed6e860de/CoinSpend.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -11,6 +11,11 @@\n \t// the coin and Accumulator provided.\n \tif (!(witness.VerifyWitness(a, coin.getPublicCoin()))) {\n \t\tthrow ZerocoinException(\"Accumulator witness does not verify\");\n+\t}\n+\n+\t// The serial # needs to be within the specified range our else it can be incremented by the modulus and create another valid proof\n+\tif (!HasValidSerial()) {\n+\t\tthrow ZerocoinException(\"Invalid serial # range\");\n \t}\n \n \t// 1: Generate two separate commitments to the public coin (C), each under",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "\t}",
      "",
      "\t// The serial # needs to be within the specified range our else it can be incremented by the modulus and create another valid proof",
      "\tif (!HasValidSerial()) {",
      "\t\tthrow ZerocoinException(\"Invalid serial # range\");"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/Zerocoin/libzerocoin/pull/16",
  "description": {
    "pr_info": {
      "title": "Patch serial numbers ",
      "number": 16
    },
    "comment": [
      "The serial # range needs to be checked or else the serial number is able to be incremented to a value that will create a valid proof, thus allowing multiple spends of a single mint."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}