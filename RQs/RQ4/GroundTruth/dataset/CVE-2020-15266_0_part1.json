{
  "cve_id": "CVE-2020-15266",
  "cwe_ids": [
    "CWE-119"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "tensorflow",
  "commit_msg": "Fix segmentation fault in tf.image.crop_and_resize when boxes is inf or nan\n\nThis fix tries to address the issue raised in 42129 where segmentation fault\nhappened in tf.image.crop_and_resize when boxes is inf or nan.\n\nThis fix adds the check to make sure boxes is not inf or nan (isfinite)\n\nThis fix fixes 42129.\n\nSigned-off-by: Yong Tang <yong.tang.github@outlook.com>",
  "commit_hash": "3ade2efec2e90c6237de32a19680caaa3ebc2845",
  "git_url": "https://github.com/tensorflow/tensorflow/commit/3ade2efec2e90c6237de32a19680caaa3ebc2845",
  "file_path": "tensorflow/core/kernels/image/crop_and_resize_op.cc",
  "func_name": "ParseAndCheckBoxSizes",
  "func_before": "static inline Status ParseAndCheckBoxSizes(const Tensor& boxes,\n                                           const Tensor& box_index,\n                                           int* num_boxes) {\n  if (boxes.NumElements() == 0 && box_index.NumElements() == 0) {\n    *num_boxes = 0;\n    return Status::OK();\n  }\n  // The shape of 'boxes' is [num_boxes, 4].\n  if (boxes.dims() != 2) {\n    return errors::InvalidArgument(\"boxes must be 2-D\",\n                                   boxes.shape().DebugString());\n  }\n  *num_boxes = boxes.dim_size(0);\n  if (boxes.dim_size(1) != 4) {\n    return errors::InvalidArgument(\"boxes must have 4 columns\");\n  }\n  // The shape of 'box_index' is [num_boxes].\n  if (box_index.dims() != 1) {\n    return errors::InvalidArgument(\"box_index must be 1-D\",\n                                   box_index.shape().DebugString());\n  }\n  if (box_index.dim_size(0) != *num_boxes) {\n    return errors::InvalidArgument(\"box_index has incompatible shape\");\n  }\n  return Status::OK();\n}",
  "abstract_func_before": "static inline Status ParseAndCheckBoxSizes(const Tensor& VAR_0,\n                                           const Tensor& VAR_1,\n                                           int* VAR_2) {\n  if (VAR_0.NumElements() == 0 && VAR_1.NumElements() == 0) {\n    *VAR_2 = 0;\n    return Status::OK();\n  }\n  /* COMMENT_0 */\n  if (VAR_0.dims() != 2) {\n    return errors::InvalidArgument(\"boxes must be 2-D\",\n                                   VAR_0.shape().DebugString());\n  }\n  *VAR_2 = VAR_0.dim_size(0);\n  if (VAR_0.dim_size(1) != 4) {\n    return errors::InvalidArgument(\"boxes must have 4 columns\");\n  }\n  /* COMMENT_1 */\n  if (VAR_1.dims() != 1) {\n    return errors::InvalidArgument(\"box_index must be 1-D\",\n                                   VAR_1.shape().DebugString());\n  }\n  if (VAR_1.dim_size(0) != *VAR_2) {\n    return errors::InvalidArgument(\"box_index has incompatible shape\");\n  }\n  return Status::OK();\n}",
  "func_graph_path_before": "tensorflow/3ade2efec2e90c6237de32a19680caaa3ebc2845/crop_and_resize_op.cc/vul/before/1.json",
  "func": "static inline Status ParseAndCheckBoxSizes(const Tensor& boxes,\n                                           const Tensor& box_index,\n                                           int* num_boxes) {\n  if (boxes.NumElements() == 0 && box_index.NumElements() == 0) {\n    *num_boxes = 0;\n    return Status::OK();\n  }\n  // The shape of 'boxes' is [num_boxes, 4].\n  if (boxes.dims() != 2) {\n    return errors::InvalidArgument(\"boxes must be 2-D\",\n                                   boxes.shape().DebugString());\n  }\n  *num_boxes = boxes.dim_size(0);\n  if (boxes.dim_size(1) != 4) {\n    return errors::InvalidArgument(\"boxes must have 4 columns\");\n  }\n  for (int64 i = 0; i < *num_boxes; i++) {\n    for (int64 j = 0; j < 4; j++) {\n      if (!isfinite(boxes.tensor<float, 2>()(i, j))) {\n        return errors::InvalidArgument(\n            \"boxes values must be finite, received boxes[\", i, \"]: \",\n            boxes.tensor<float, 2>()(i, 0), \", \",\n            boxes.tensor<float, 2>()(i, 1), \", \",\n            boxes.tensor<float, 2>()(i, 2), \", \",\n            boxes.tensor<float, 2>()(i, 3));\n      }\n    }\n  }\n  // The shape of 'box_index' is [num_boxes].\n  if (box_index.dims() != 1) {\n    return errors::InvalidArgument(\"box_index must be 1-D\",\n                                   box_index.shape().DebugString());\n  }\n  if (box_index.dim_size(0) != *num_boxes) {\n    return errors::InvalidArgument(\"box_index has incompatible shape\");\n  }\n  return Status::OK();\n}",
  "abstract_func": "static inline Status ParseAndCheckBoxSizes(const Tensor& VAR_0,\n                                           const Tensor& VAR_1,\n                                           int* VAR_2) {\n  if (VAR_0.NumElements() == 0 && VAR_1.NumElements() == 0) {\n    *VAR_2 = 0;\n    return Status::OK();\n  }\n  /* COMMENT_0 */\n  if (VAR_0.dims() != 2) {\n    return errors::InvalidArgument(\"boxes must be 2-D\",\n                                   VAR_0.shape().DebugString());\n  }\n  *VAR_2 = VAR_0.dim_size(0);\n  if (VAR_0.dim_size(1) != 4) {\n    return errors::InvalidArgument(\"boxes must have 4 columns\");\n  }\n  for (int64 VAR_3 = 0; VAR_3 < *VAR_2; VAR_3++) {\n    for (int64 VAR_4 = 0; VAR_4 < 4; VAR_4++) {\n      if (!isfinite(VAR_0.tensor<float, 2>()(VAR_3, VAR_4))) {\n        return errors::InvalidArgument(\n            \"boxes values must be finite, received boxes[\", VAR_3, \"]: \",\n            VAR_0.tensor<float, 2>()(VAR_3, 0), \", \",\n            VAR_0.tensor<float, 2>()(VAR_3, 1), \", \",\n            VAR_0.tensor<float, 2>()(VAR_3, 2), \", \",\n            VAR_0.tensor<float, 2>()(VAR_3, 3));\n      }\n    }\n  }\n  /* COMMENT_1 */\n  if (VAR_1.dims() != 1) {\n    return errors::InvalidArgument(\"box_index must be 1-D\",\n                                   VAR_1.shape().DebugString());\n  }\n  if (VAR_1.dim_size(0) != *VAR_2) {\n    return errors::InvalidArgument(\"box_index has incompatible shape\");\n  }\n  return Status::OK();\n}",
  "func_graph_path": "tensorflow/3ade2efec2e90c6237de32a19680caaa3ebc2845/crop_and_resize_op.cc/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -14,6 +14,18 @@\n   if (boxes.dim_size(1) != 4) {\n     return errors::InvalidArgument(\"boxes must have 4 columns\");\n   }\n+  for (int64 i = 0; i < *num_boxes; i++) {\n+    for (int64 j = 0; j < 4; j++) {\n+      if (!isfinite(boxes.tensor<float, 2>()(i, j))) {\n+        return errors::InvalidArgument(\n+            \"boxes values must be finite, received boxes[\", i, \"]: \",\n+            boxes.tensor<float, 2>()(i, 0), \", \",\n+            boxes.tensor<float, 2>()(i, 1), \", \",\n+            boxes.tensor<float, 2>()(i, 2), \", \",\n+            boxes.tensor<float, 2>()(i, 3));\n+      }\n+    }\n+  }\n   // The shape of 'box_index' is [num_boxes].\n   if (box_index.dims() != 1) {\n     return errors::InvalidArgument(\"box_index must be 1-D\",",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "  for (int64 i = 0; i < *num_boxes; i++) {",
      "    for (int64 j = 0; j < 4; j++) {",
      "      if (!isfinite(boxes.tensor<float, 2>()(i, j))) {",
      "        return errors::InvalidArgument(",
      "            \"boxes values must be finite, received boxes[\", i, \"]: \",",
      "            boxes.tensor<float, 2>()(i, 0), \", \",",
      "            boxes.tensor<float, 2>()(i, 1), \", \",",
      "            boxes.tensor<float, 2>()(i, 2), \", \",",
      "            boxes.tensor<float, 2>()(i, 3));",
      "      }",
      "    }",
      "  }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/tensorflow/tensorflow/pull/42143",
  "description": {
    "pr_info": {
      "title": "Fix segmentation fault in tf.image.crop_and_resize when boxes is inf or nan",
      "number": 42143
    },
    "comment": [
      "This fix tries to address the issue raised in #42129 where segmentation fault\r\nhappened in tf.image.crop_and_resize when boxes is inf or nan.\r\n\r\nThis fix adds the check to make sure boxes is not inf or nan (isfinite)\r\n\r\nThis fix fixes #42129.\r\n\r\nSigned-off-by: Yong Tang <yong.tang.github@outlook.com>",
      "@yongtang Can you please resolve conflicts? Thanks!",
      "@yongtang, Any update on this PR? Please. Thanks!",
      "Due to the way GPU/CPU pipeline works in the kernel, it looks like to do a nan check on GPU is not exactly straightforward. That was causing the GPU test failure.\r\n\r\nLet me take another look and see how to resolve this issue.",
      "@yongtang  Can you please check @sanjoy's comments and keep us posted ? Thanks!",
      "The test added by the PR does not fail in CUDA if I remove the C++ check that causes the segfaults",
      "I think I got this fully fixed internally. Running a full suite of tests and sending for review tomorrow."
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.95\n\nThe patch addresses a bug causing a segmentation fault due to invalid input values, which is a non-security issue in the core functionality. The code modifications ensure input validation, preventing crashes but not fixing a security vulnerability. The confidence is high because all aspects are well-aligned and clear."
}