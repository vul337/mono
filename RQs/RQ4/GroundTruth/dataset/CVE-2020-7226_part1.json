{
  "cve_id": "CVE-2020-7226",
  "cwe_ids": [
    "CWE-770"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "vt-middleware/cryptacular",
  "commit_msg": "Define new ciphertext header format.\n\nNew format does not allocate any memory until HMAC check passes, which\nguards against untrusted input. All encryption components have been\nupdated to use the new header, while preserving backward compatibility\nto decrypt messages encrypted with the old format. The decoding process\nfor the old header has been hardened to impose reasonable limits on header\nfields: nonce sizes up to 255 bytes, key names up to 500 bytes.\n\nFixes #52.",
  "commit_hash": "8c6c7528f1e24c6b71f3e36db0cb8a697256ce25",
  "git_url": "https://github.com/vt-middleware/cryptacular/commit/8c6c7528f1e24c6b71f3e36db0cb8a697256ce25",
  "file_path": "src/main/java/org/cryptacular/bean/AbstractBlockCipherBean.java",
  "func_name": "process",
  "func_before": "@Override\n  protected void process(\n    final CiphertextHeader header,\n    final boolean mode,\n    final InputStream input,\n    final OutputStream output)\n  {\n    final BlockCipherAdapter cipher = newCipher(header, mode);\n    final int outSize = cipher.getOutputSize(StreamUtil.CHUNK_SIZE);\n    final byte[] outBuf = new byte[outSize > StreamUtil.CHUNK_SIZE ? outSize : StreamUtil.CHUNK_SIZE];\n    StreamUtil.pipeAll(\n      input,\n      output,\n      (in, inOff, len, out) -> {\n        final int n = cipher.processBytes(in, inOff, len, outBuf, 0);\n        out.write(outBuf, 0, n);\n      });\n\n    final int n = cipher.doFinal(outBuf, 0);\n    try {\n      output.write(outBuf, 0, n);\n    } catch (IOException e) {\n      throw new StreamException(e);\n    }\n  }",
  "abstract_func_before": "@Override\n  protected void process(\n    final CiphertextHeader VAR_0,\n    final boolean VAR_1,\n    final InputStream VAR_2,\n    final OutputStream VAR_3)\n  {\n    final BlockCipherAdapter VAR_4 = newCipher(VAR_0, VAR_1);\n    final int VAR_5 = VAR_4.getOutputSize(VAR_6.CHUNK_SIZE);\n    final byte[] VAR_7 = new byte[VAR_5 > VAR_6.CHUNK_SIZE ? VAR_5 : VAR_6.CHUNK_SIZE];\n    VAR_6.pipeAll(\n      VAR_2,\n      VAR_3,\n      (VAR_8, VAR_9, VAR_10, VAR_11) -> {\n        final int VAR_12 = VAR_4.processBytes(VAR_8, VAR_9, VAR_10, VAR_7, 0);\n        VAR_11.write(VAR_7, 0, VAR_12);\n      });\n\n    final int VAR_12 = VAR_4.doFinal(VAR_7, 0);\n    try {\n      VAR_3.write(VAR_7, 0, VAR_12);\n    } catch (IOException VAR_13) {\n      throw new StreamException(VAR_13);\n    }\n  }",
  "func_graph_path_before": "vt-middleware/cryptacular/8c6c7528f1e24c6b71f3e36db0cb8a697256ce25/AbstractBlockCipherBean.java/vul/before/0.json",
  "func": "@Override\n  protected void process(\n    final CiphertextHeader header,\n    final boolean mode,\n    final InputStream input,\n    final OutputStream output)\n  {\n    final BlockCipherAdapter cipher = newCipher(header, mode);\n    final int outSize = cipher.getOutputSize(StreamUtil.CHUNK_SIZE);\n    final byte[] outBuf = new byte[Math.max(outSize, StreamUtil.CHUNK_SIZE)];\n    StreamUtil.pipeAll(\n      input,\n      output,\n      (in, inOff, len, out) -> {\n        final int n = cipher.processBytes(in, inOff, len, outBuf, 0);\n        out.write(outBuf, 0, n);\n      });\n\n    final int n = cipher.doFinal(outBuf, 0);\n    try {\n      output.write(outBuf, 0, n);\n    } catch (IOException e) {\n      throw new StreamException(e);\n    }\n  }",
  "abstract_func": "@Override\n  protected void process(\n    final CiphertextHeader VAR_0,\n    final boolean VAR_1,\n    final InputStream VAR_2,\n    final OutputStream VAR_3)\n  {\n    final BlockCipherAdapter VAR_4 = newCipher(VAR_0, VAR_1);\n    final int VAR_5 = VAR_4.getOutputSize(VAR_6.CHUNK_SIZE);\n    final byte[] VAR_7 = new byte[VAR_8.max(VAR_5, VAR_6.CHUNK_SIZE)];\n    VAR_6.pipeAll(\n      VAR_2,\n      VAR_3,\n      (VAR_9, VAR_10, VAR_11, VAR_12) -> {\n        final int VAR_13 = VAR_4.processBytes(VAR_9, VAR_10, VAR_11, VAR_7, 0);\n        VAR_12.write(VAR_7, 0, VAR_13);\n      });\n\n    final int VAR_13 = VAR_4.doFinal(VAR_7, 0);\n    try {\n      VAR_3.write(VAR_7, 0, VAR_13);\n    } catch (IOException VAR_14) {\n      throw new StreamException(VAR_14);\n    }\n  }",
  "func_graph_path": "vt-middleware/cryptacular/8c6c7528f1e24c6b71f3e36db0cb8a697256ce25/AbstractBlockCipherBean.java/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -7,7 +7,7 @@\n   {\n     final BlockCipherAdapter cipher = newCipher(header, mode);\n     final int outSize = cipher.getOutputSize(StreamUtil.CHUNK_SIZE);\n-    final byte[] outBuf = new byte[outSize > StreamUtil.CHUNK_SIZE ? outSize : StreamUtil.CHUNK_SIZE];\n+    final byte[] outBuf = new byte[Math.max(outSize, StreamUtil.CHUNK_SIZE)];\n     StreamUtil.pipeAll(\n       input,\n       output,",
  "diff_line_info": {
    "deleted_lines": [
      "    final byte[] outBuf = new byte[outSize > StreamUtil.CHUNK_SIZE ? outSize : StreamUtil.CHUNK_SIZE];"
    ],
    "added_lines": [
      "    final byte[] outBuf = new byte[Math.max(outSize, StreamUtil.CHUNK_SIZE)];"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/vt-middleware/cryptacular/pull/53",
  "description": {
    "pr_info": {
      "title": "Define new ciphertext header format.",
      "number": 53
    },
    "comment": [
      "New format does not allocate any memory until HMAC check passes, which\r\nguards against untrusted input. All encryption components have been\r\nupdated to use the new header, while preserving backward compatibility\r\nto decrypt messages encrypted with the old format. The decoding process\r\nfor the old header has been hardened to impose reasonable limits on header\r\nfields: nonce sizes up to 255 bytes, key names up to 500 bytes.\r\n\r\nFixes #52."
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.7,
  "Bug Filter Response": "Final Classification: Defect Remediation & Feature Upgrades; Confidence: 0.7\n\n**Step-by-Step Explanation:**\n\n1. **Input Analysis:** The commit message discusses changes to the ciphertext header format to improve security by guarding against untrusted input. The code diff modifies an array allocation using Math.max(), which simplifies the code without obvious security implications.\n\n2. **Consistency Check:** While the commit message emphasizes security improvements, the code change is a refactor, indicating a possible mismatch between description and implementation.\n\n3. **Purpose Evaluation:** The code change refines memory allocation logic for encryption, enhancing functionality without directly addressing a security vulnerability.\n\n4. **Security Assessment:** Although the commit message mentions security features, the code doesn't implement a security fix but rather optimizes for better handling of encryption, suggesting a non-security purpose.\n\n5. **Classification:** As it's a code improvement for core functionality, it falls under 'Defect Remediation & Feature Upgrades.'\n\n6. **Confidence Scoring:** 0.7 due to the mismatch between the security-focused message and the refactor-focused code, indicating possible ambiguity."
}