{
  "cve_id": "CVE-2016-4425",
  "cwe_ids": [
    "CWE-20"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "akheron/jansson",
  "commit_msg": "Fix for issue #282\n\nThe fix limits recursion depths when parsing arrays and objects.\nThe limit is configurable via the `JSON_PARSER_MAX_DEPTH` setting\nwithin `jansson_config.h` and is set by default to 2048.\n\nUpdate the RFC conformance document to note the limit; the RFC\nallows limits to be set by the implementation so nothing has\nactually changed w.r.t. conformance state.\n\nReported by Gustavo Grieco.",
  "commit_hash": "64ce0ad3731ebd77e02897b07920eadd0e2cc318",
  "git_url": "https://github.com/akheron/jansson/commit/64ce0ad3731ebd77e02897b07920eadd0e2cc318",
  "file_path": "src/load.c",
  "func_name": "parse_value",
  "func_before": "static json_t *parse_value(lex_t *lex, size_t flags, json_error_t *error)\n{\n    json_t *json;\n\n    switch(lex->token) {\n        case TOKEN_STRING: {\n            const char *value = lex->value.string.val;\n            size_t len = lex->value.string.len;\n\n            if(!(flags & JSON_ALLOW_NUL)) {\n                if(memchr(value, '\\0', len)) {\n                    error_set(error, lex, \"\\\\u0000 is not allowed without JSON_ALLOW_NUL\");\n                    return NULL;\n                }\n            }\n\n            json = jsonp_stringn_nocheck_own(value, len);\n            if(json) {\n                lex->value.string.val = NULL;\n                lex->value.string.len = 0;\n            }\n            break;\n        }\n\n        case TOKEN_INTEGER: {\n            json = json_integer(lex->value.integer);\n            break;\n        }\n\n        case TOKEN_REAL: {\n            json = json_real(lex->value.real);\n            break;\n        }\n\n        case TOKEN_TRUE:\n            json = json_true();\n            break;\n\n        case TOKEN_FALSE:\n            json = json_false();\n            break;\n\n        case TOKEN_NULL:\n            json = json_null();\n            break;\n\n        case '{':\n            json = parse_object(lex, flags, error);\n            break;\n\n        case '[':\n            json = parse_array(lex, flags, error);\n            break;\n\n        case TOKEN_INVALID:\n            error_set(error, lex, \"invalid token\");\n            return NULL;\n\n        default:\n            error_set(error, lex, \"unexpected token\");\n            return NULL;\n    }\n\n    if(!json)\n        return NULL;\n\n    return json;\n}",
  "abstract_func_before": "static json_t *parse_value(lex_t *VAR_0, size_t VAR_1, json_error_t *VAR_2)\n{\n    json_t *VAR_3;\n\n    switch(VAR_0->token) {\n        case VAR_4: {\n            const char *VAR_5 = VAR_0->value.string.val;\n            size_t VAR_6 = VAR_0->value.string.len;\n\n            if(!(VAR_1 & VAR_7)) {\n                if(memchr(VAR_5, '\\0', VAR_6)) {\n                    error_set(VAR_2, VAR_0, \"\\\\u0000 is not allowed without JSON_ALLOW_NUL\");\n                    return NULL;\n                }\n            }\n\n            VAR_3 = jsonp_stringn_nocheck_own(VAR_5, VAR_6);\n            if(VAR_3) {\n                VAR_0->value.string.val = NULL;\n                VAR_0->value.string.len = 0;\n            }\n            break;\n        }\n\n        case VAR_8: {\n            VAR_3 = json_integer(VAR_0->value.integer);\n            break;\n        }\n\n        case VAR_9: {\n            VAR_3 = json_real(VAR_0->value.real);\n            break;\n        }\n\n        case VAR_10:\n            VAR_3 = json_true();\n            break;\n\n        case VAR_11:\n            VAR_3 = json_false();\n            break;\n\n        case VAR_12:\n            VAR_3 = json_null();\n            break;\n\n        case '{':\n            VAR_3 = parse_object(VAR_0, VAR_1, VAR_2);\n            break;\n\n        case '[':\n            VAR_3 = parse_array(VAR_0, VAR_1, VAR_2);\n            break;\n\n        case VAR_13:\n            error_set(VAR_2, VAR_0, \"invalid token\");\n            return NULL;\n\n        default:\n            error_set(VAR_2, VAR_0, \"unexpected token\");\n            return NULL;\n    }\n\n    if(!VAR_3)\n        return NULL;\n\n    return VAR_3;\n}",
  "func_graph_path_before": "akheron/jansson/64ce0ad3731ebd77e02897b07920eadd0e2cc318/load.c/vul/before/1.json",
  "func": "static json_t *parse_value(lex_t *lex, size_t flags, json_error_t *error)\n{\n    json_t *json;\n\n    lex->depth++;\n    if(lex->depth > JSON_PARSER_MAX_DEPTH) {\n        error_set(error, lex, \"maximum parsing depth reached\");\n        return NULL;\n    }\n\n    switch(lex->token) {\n        case TOKEN_STRING: {\n            const char *value = lex->value.string.val;\n            size_t len = lex->value.string.len;\n\n            if(!(flags & JSON_ALLOW_NUL)) {\n                if(memchr(value, '\\0', len)) {\n                    error_set(error, lex, \"\\\\u0000 is not allowed without JSON_ALLOW_NUL\");\n                    return NULL;\n                }\n            }\n\n            json = jsonp_stringn_nocheck_own(value, len);\n            if(json) {\n                lex->value.string.val = NULL;\n                lex->value.string.len = 0;\n            }\n            break;\n        }\n\n        case TOKEN_INTEGER: {\n            json = json_integer(lex->value.integer);\n            break;\n        }\n\n        case TOKEN_REAL: {\n            json = json_real(lex->value.real);\n            break;\n        }\n\n        case TOKEN_TRUE:\n            json = json_true();\n            break;\n\n        case TOKEN_FALSE:\n            json = json_false();\n            break;\n\n        case TOKEN_NULL:\n            json = json_null();\n            break;\n\n        case '{':\n            json = parse_object(lex, flags, error);\n            break;\n\n        case '[':\n            json = parse_array(lex, flags, error);\n            break;\n\n        case TOKEN_INVALID:\n            error_set(error, lex, \"invalid token\");\n            return NULL;\n\n        default:\n            error_set(error, lex, \"unexpected token\");\n            return NULL;\n    }\n\n    if(!json)\n        return NULL;\n\n    lex->depth--;\n    return json;\n}",
  "abstract_func": "static json_t *parse_value(lex_t *VAR_0, size_t VAR_1, json_error_t *VAR_2)\n{\n    json_t *VAR_3;\n\n    VAR_0->depth++;\n    if(VAR_0->depth > VAR_4) {\n        error_set(VAR_2, VAR_0, \"maximum parsing depth reached\");\n        return NULL;\n    }\n\n    switch(VAR_0->token) {\n        case VAR_5: {\n            const char *VAR_6 = VAR_0->value.string.val;\n            size_t VAR_7 = VAR_0->value.string.len;\n\n            if(!(VAR_1 & VAR_8)) {\n                if(memchr(VAR_6, '\\0', VAR_7)) {\n                    error_set(VAR_2, VAR_0, \"\\\\u0000 is not allowed without JSON_ALLOW_NUL\");\n                    return NULL;\n                }\n            }\n\n            VAR_3 = jsonp_stringn_nocheck_own(VAR_6, VAR_7);\n            if(VAR_3) {\n                VAR_0->value.string.val = NULL;\n                VAR_0->value.string.len = 0;\n            }\n            break;\n        }\n\n        case VAR_9: {\n            VAR_3 = json_integer(VAR_0->value.integer);\n            break;\n        }\n\n        case VAR_10: {\n            VAR_3 = json_real(VAR_0->value.real);\n            break;\n        }\n\n        case VAR_11:\n            VAR_3 = json_true();\n            break;\n\n        case VAR_12:\n            VAR_3 = json_false();\n            break;\n\n        case VAR_13:\n            VAR_3 = json_null();\n            break;\n\n        case '{':\n            VAR_3 = parse_object(VAR_0, VAR_1, VAR_2);\n            break;\n\n        case '[':\n            VAR_3 = parse_array(VAR_0, VAR_1, VAR_2);\n            break;\n\n        case VAR_14:\n            error_set(VAR_2, VAR_0, \"invalid token\");\n            return NULL;\n\n        default:\n            error_set(VAR_2, VAR_0, \"unexpected token\");\n            return NULL;\n    }\n\n    if(!VAR_3)\n        return NULL;\n\n    VAR_0->depth--;\n    return VAR_3;\n}",
  "func_graph_path": "akheron/jansson/64ce0ad3731ebd77e02897b07920eadd0e2cc318/load.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,12 @@\n static json_t *parse_value(lex_t *lex, size_t flags, json_error_t *error)\n {\n     json_t *json;\n+\n+    lex->depth++;\n+    if(lex->depth > JSON_PARSER_MAX_DEPTH) {\n+        error_set(error, lex, \"maximum parsing depth reached\");\n+        return NULL;\n+    }\n \n     switch(lex->token) {\n         case TOKEN_STRING: {\n@@ -64,5 +70,6 @@\n     if(!json)\n         return NULL;\n \n+    lex->depth--;\n     return json;\n }",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "",
      "    lex->depth++;",
      "    if(lex->depth > JSON_PARSER_MAX_DEPTH) {",
      "        error_set(error, lex, \"maximum parsing depth reached\");",
      "        return NULL;",
      "    }",
      "    lex->depth--;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/akheron/jansson/pull/284",
  "description": {
    "pr_info": {
      "title": "Fix for issue #282",
      "number": 284
    },
    "comment": [
      "This is a squashed version of the original fixes in pull request #283. No other changes were made.\n",
      "[![Coverage Status](https://coveralls.io/builds/6025269/badge)](https://coveralls.io/builds/6025269)\n\nCoverage remained the same at 90.254% when pulling **64ce0ad3731ebd77e02897b07920eadd0e2cc318 on dev-zzo:issue-282** into **087ed94c452ecade26447c14605cd419e970cfd2 on akheron:master**.\n",
      "Merged, thanks a lot!\n",
      "Was happy to help.\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "Final Classification: Security Vulnerability Fix; Confidence: 0.9"
}