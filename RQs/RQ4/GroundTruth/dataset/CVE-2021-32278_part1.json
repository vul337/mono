{
  "cve_id": "CVE-2021-32278",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "knik0/faad2",
  "commit_msg": "Check return value of ltp_data.\n\nFixes #62.",
  "commit_hash": "e19a5e491354e0e4664d02b796dacee28fb2521e",
  "git_url": "https://github.com/knik0/faad2/commit/e19a5e491354e0e4664d02b796dacee28fb2521e",
  "file_path": "libfaad/syntax.c",
  "func_name": "ics_info",
  "func_before": "static uint8_t ics_info(NeAACDecStruct *hDecoder, ic_stream *ics, bitfile *ld,\n                        uint8_t common_window)\n{\n    uint8_t retval = 0;\n    uint8_t ics_reserved_bit;\n\n    ics_reserved_bit = faad_get1bit(ld\n        DEBUGVAR(1,43,\"ics_info(): ics_reserved_bit\"));\n    if (ics_reserved_bit != 0)\n        return 32;\n    ics->window_sequence = (uint8_t)faad_getbits(ld, 2\n        DEBUGVAR(1,44,\"ics_info(): window_sequence\"));\n    ics->window_shape = faad_get1bit(ld\n        DEBUGVAR(1,45,\"ics_info(): window_shape\"));\n\n#ifdef LD_DEC\n    /* No block switching in LD */\n    if ((hDecoder->object_type == LD) && (ics->window_sequence != ONLY_LONG_SEQUENCE))\n        return 32;\n#endif\n\n    if (ics->window_sequence == EIGHT_SHORT_SEQUENCE)\n    {\n        ics->max_sfb = (uint8_t)faad_getbits(ld, 4\n            DEBUGVAR(1,46,\"ics_info(): max_sfb (short)\"));\n        ics->scale_factor_grouping = (uint8_t)faad_getbits(ld, 7\n            DEBUGVAR(1,47,\"ics_info(): scale_factor_grouping\"));\n    } else {\n        ics->max_sfb = (uint8_t)faad_getbits(ld, 6\n            DEBUGVAR(1,48,\"ics_info(): max_sfb (long)\"));\n    }\n\n    /* get the grouping information */\n    if ((retval = window_grouping_info(hDecoder, ics)) > 0)\n        return retval;\n\n\n    /* should be an error */\n    /* check the range of max_sfb */\n    if (ics->max_sfb > ics->num_swb)\n        return 16;\n\n    if (ics->window_sequence != EIGHT_SHORT_SEQUENCE)\n    {\n        if ((ics->predictor_data_present = faad_get1bit(ld\n            DEBUGVAR(1,49,\"ics_info(): predictor_data_present\"))) & 1)\n        {\n            if (hDecoder->object_type == MAIN) /* MPEG2 style AAC predictor */\n            {\n                uint8_t sfb;\n\n                uint8_t limit = min(ics->max_sfb, max_pred_sfb(hDecoder->sf_index));\n#ifdef MAIN_DEC\n                ics->pred.limit = limit;\n#endif\n\n                if ((\n#ifdef MAIN_DEC\n                    ics->pred.predictor_reset =\n#endif\n                    faad_get1bit(ld DEBUGVAR(1,53,\"ics_info(): pred.predictor_reset\"))) & 1)\n                {\n#ifdef MAIN_DEC\n                    ics->pred.predictor_reset_group_number =\n#endif\n                        (uint8_t)faad_getbits(ld, 5 DEBUGVAR(1,54,\"ics_info(): pred.predictor_reset_group_number\"));\n                }\n\n                for (sfb = 0; sfb < limit; sfb++)\n                {\n#ifdef MAIN_DEC\n                    ics->pred.prediction_used[sfb] =\n#endif\n                        faad_get1bit(ld DEBUGVAR(1,55,\"ics_info(): pred.prediction_used\"));\n                }\n            }\n#ifdef LTP_DEC\n            else { /* Long Term Prediction */\n                if (hDecoder->object_type < ER_OBJECT_START)\n                {\n                    if ((ics->ltp.data_present = faad_get1bit(ld\n                        DEBUGVAR(1,50,\"ics_info(): ltp.data_present\"))) & 1)\n                    {\n                        if ((retval = ltp_data(hDecoder, ics, &(ics->ltp), ld)) > 0)\n                        {\n                            return retval;\n                        }\n                    }\n                    if (common_window)\n                    {\n                        if ((ics->ltp2.data_present = faad_get1bit(ld\n                            DEBUGVAR(1,51,\"ics_info(): ltp2.data_present\"))) & 1)\n                        {\n                            if ((retval = ltp_data(hDecoder, ics, &(ics->ltp2), ld)) > 0)\n                            {\n                                return retval;\n                            }\n                        }\n                    }\n                }\n#ifdef ERROR_RESILIENCE\n                if (!common_window && (hDecoder->object_type >= ER_OBJECT_START))\n                {\n                    if ((ics->ltp.data_present = faad_get1bit(ld\n                        DEBUGVAR(1,50,\"ics_info(): ltp.data_present\"))) & 1)\n                    {\n                        ltp_data(hDecoder, ics, &(ics->ltp), ld);\n                    }\n                }\n#endif\n            }\n#endif\n        }\n    }\n\n    return retval;\n}",
  "abstract_func_before": "static uint8_t ics_info(NeAACDecStruct *VAR_0, ic_stream *VAR_1, bitfile *VAR_2,\n                        uint8_t VAR_3)\n{\n    uint8_t VAR_4 = 0;\n    uint8_t VAR_5;\n\n    VAR_5 = faad_get1bit(VAR_2\n        DEBUGVAR(1,43,\"ics_info(): ics_reserved_bit\"));\n    if (VAR_5 != 0)\n        return 32;\n    VAR_1->window_sequence = (uint8_t)faad_getbits(VAR_2, 2\n        DEBUGVAR(1,44,\"ics_info(): window_sequence\"));\n    VAR_1->window_shape = faad_get1bit(VAR_2\n        DEBUGVAR(1,45,\"ics_info(): window_shape\"));\n\n#ifdef VAR_6\n    /* COMMENT_0 */\n    if ((VAR_0->object_type == VAR_7) && (VAR_1->window_sequence != VAR_8))\n        return 32;\n#endif\n\n    if (VAR_1->window_sequence == VAR_9)\n    {\n        VAR_1->max_sfb = (uint8_t)faad_getbits(VAR_2, 4\n            DEBUGVAR(1,46,\"ics_info(): max_sfb (short)\"));\n        VAR_1->scale_factor_grouping = (uint8_t)faad_getbits(VAR_2, 7\n            DEBUGVAR(1,47,\"ics_info(): scale_factor_grouping\"));\n    } else {\n        VAR_1->max_sfb = (uint8_t)faad_getbits(VAR_2, 6\n            DEBUGVAR(1,48,\"ics_info(): max_sfb (long)\"));\n    }\n\n    /* COMMENT_1 */\n    if ((VAR_4 = window_grouping_info(VAR_0, VAR_1)) > 0)\n        return VAR_4;\n\n\n    /* COMMENT_2 */\n    /* COMMENT_3 */\n    if (VAR_1->max_sfb > VAR_1->num_swb)\n        return 16;\n\n    if (VAR_1->window_sequence != VAR_9)\n    {\n        if ((VAR_1->predictor_data_present = faad_get1bit(VAR_2\n            DEBUGVAR(1,49,\"ics_info(): predictor_data_present\"))) & 1)\n        {\n            if (VAR_0->object_type == VAR_10) /* COMMENT_4 */\n            {\n                uint8_t VAR_11;\n\n                uint8_t VAR_12 = min(VAR_1->max_sfb, max_pred_sfb(VAR_0->sf_index));\n#ifdef VAR_13\n                VAR_1->pred.limit = VAR_12;\n#endif\n\n                if ((\n#ifdef VAR_13\n                    VAR_1->pred.predictor_reset =\n#endif\n                    faad_get1bit(VAR_2 DEBUGVAR(1,53,\"ics_info(): pred.predictor_reset\"))) & 1)\n                {\n#ifdef VAR_13\n                    VAR_1->pred.predictor_reset_group_number =\n#endif\n                        (uint8_t)faad_getbits(VAR_2, 5 DEBUGVAR(1,54,\"ics_info(): pred.predictor_reset_group_number\"));\n                }\n\n                for (VAR_11 = 0; VAR_11 < VAR_12; VAR_11++)\n                {\n#ifdef VAR_13\n                    VAR_1->pred.prediction_used[VAR_11] =\n#endif\n                        faad_get1bit(VAR_2 DEBUGVAR(1,55,\"ics_info(): pred.prediction_used\"));\n                }\n            }\n#ifdef VAR_14\n            else { /* COMMENT_5 */\n                if (VAR_0->object_type < VAR_15)\n                {\n                    if ((VAR_1->ltp.data_present = faad_get1bit(VAR_2\n                        DEBUGVAR(1,50,\"ics_info(): ltp.data_present\"))) & 1)\n                    {\n                        if ((VAR_4 = ltp_data(VAR_0, VAR_1, &(VAR_1->ltp), VAR_2)) > 0)\n                        {\n                            return VAR_4;\n                        }\n                    }\n                    if (VAR_3)\n                    {\n                        if ((VAR_1->ltp2.data_present = faad_get1bit(VAR_2\n                            DEBUGVAR(1,51,\"ics_info(): ltp2.data_present\"))) & 1)\n                        {\n                            if ((VAR_4 = ltp_data(VAR_0, VAR_1, &(VAR_1->ltp2), VAR_2)) > 0)\n                            {\n                                return VAR_4;\n                            }\n                        }\n                    }\n                }\n#ifdef VAR_16\n                if (!VAR_3 && (VAR_0->object_type >= VAR_15))\n                {\n                    if ((VAR_1->ltp.data_present = faad_get1bit(VAR_2\n                        DEBUGVAR(1,50,\"ics_info(): ltp.data_present\"))) & 1)\n                    {\n                        ltp_data(VAR_0, VAR_1, &(VAR_1->ltp), VAR_2);\n                    }\n                }\n#endif\n            }\n#endif\n        }\n    }\n\n    return VAR_4;\n}",
  "func_graph_path_before": "knik0/faad2/e19a5e491354e0e4664d02b796dacee28fb2521e/syntax.c/vul/before/0.json",
  "func": "static uint8_t ics_info(NeAACDecStruct *hDecoder, ic_stream *ics, bitfile *ld,\n                        uint8_t common_window)\n{\n    uint8_t retval = 0;\n    uint8_t ics_reserved_bit;\n\n    ics_reserved_bit = faad_get1bit(ld\n        DEBUGVAR(1,43,\"ics_info(): ics_reserved_bit\"));\n    if (ics_reserved_bit != 0)\n        return 32;\n    ics->window_sequence = (uint8_t)faad_getbits(ld, 2\n        DEBUGVAR(1,44,\"ics_info(): window_sequence\"));\n    ics->window_shape = faad_get1bit(ld\n        DEBUGVAR(1,45,\"ics_info(): window_shape\"));\n\n#ifdef LD_DEC\n    /* No block switching in LD */\n    if ((hDecoder->object_type == LD) && (ics->window_sequence != ONLY_LONG_SEQUENCE))\n        return 32;\n#endif\n\n    if (ics->window_sequence == EIGHT_SHORT_SEQUENCE)\n    {\n        ics->max_sfb = (uint8_t)faad_getbits(ld, 4\n            DEBUGVAR(1,46,\"ics_info(): max_sfb (short)\"));\n        ics->scale_factor_grouping = (uint8_t)faad_getbits(ld, 7\n            DEBUGVAR(1,47,\"ics_info(): scale_factor_grouping\"));\n    } else {\n        ics->max_sfb = (uint8_t)faad_getbits(ld, 6\n            DEBUGVAR(1,48,\"ics_info(): max_sfb (long)\"));\n    }\n\n    /* get the grouping information */\n    if ((retval = window_grouping_info(hDecoder, ics)) > 0)\n        return retval;\n\n\n    /* should be an error */\n    /* check the range of max_sfb */\n    if (ics->max_sfb > ics->num_swb)\n        return 16;\n\n    if (ics->window_sequence != EIGHT_SHORT_SEQUENCE)\n    {\n        if ((ics->predictor_data_present = faad_get1bit(ld\n            DEBUGVAR(1,49,\"ics_info(): predictor_data_present\"))) & 1)\n        {\n            if (hDecoder->object_type == MAIN) /* MPEG2 style AAC predictor */\n            {\n                uint8_t sfb;\n\n                uint8_t limit = min(ics->max_sfb, max_pred_sfb(hDecoder->sf_index));\n#ifdef MAIN_DEC\n                ics->pred.limit = limit;\n#endif\n\n                if ((\n#ifdef MAIN_DEC\n                    ics->pred.predictor_reset =\n#endif\n                    faad_get1bit(ld DEBUGVAR(1,53,\"ics_info(): pred.predictor_reset\"))) & 1)\n                {\n#ifdef MAIN_DEC\n                    ics->pred.predictor_reset_group_number =\n#endif\n                        (uint8_t)faad_getbits(ld, 5 DEBUGVAR(1,54,\"ics_info(): pred.predictor_reset_group_number\"));\n                }\n\n                for (sfb = 0; sfb < limit; sfb++)\n                {\n#ifdef MAIN_DEC\n                    ics->pred.prediction_used[sfb] =\n#endif\n                        faad_get1bit(ld DEBUGVAR(1,55,\"ics_info(): pred.prediction_used\"));\n                }\n            }\n#ifdef LTP_DEC\n            else { /* Long Term Prediction */\n                if (hDecoder->object_type < ER_OBJECT_START)\n                {\n                    if ((ics->ltp.data_present = faad_get1bit(ld\n                        DEBUGVAR(1,50,\"ics_info(): ltp.data_present\"))) & 1)\n                    {\n                        if ((retval = ltp_data(hDecoder, ics, &(ics->ltp), ld)) > 0)\n                        {\n                            return retval;\n                        }\n                    }\n                    if (common_window)\n                    {\n                        if ((ics->ltp2.data_present = faad_get1bit(ld\n                            DEBUGVAR(1,51,\"ics_info(): ltp2.data_present\"))) & 1)\n                        {\n                            if ((retval = ltp_data(hDecoder, ics, &(ics->ltp2), ld)) > 0)\n                            {\n                                return retval;\n                            }\n                        }\n                    }\n                }\n#ifdef ERROR_RESILIENCE\n                if (!common_window && (hDecoder->object_type >= ER_OBJECT_START))\n                {\n                    if ((ics->ltp.data_present = faad_get1bit(ld\n                        DEBUGVAR(1,50,\"ics_info(): ltp.data_present\"))) & 1)\n                    {\n                        if ((retval = ltp_data(hDecoder, ics, &(ics->ltp), ld)) > 0)\n                        {\n                            return retval;\n                        }\n                    }\n                }\n#endif\n            }\n#endif\n        }\n    }\n\n    return retval;\n}",
  "abstract_func": "static uint8_t ics_info(NeAACDecStruct *VAR_0, ic_stream *VAR_1, bitfile *VAR_2,\n                        uint8_t VAR_3)\n{\n    uint8_t VAR_4 = 0;\n    uint8_t VAR_5;\n\n    VAR_5 = faad_get1bit(VAR_2\n        DEBUGVAR(1,43,\"ics_info(): ics_reserved_bit\"));\n    if (VAR_5 != 0)\n        return 32;\n    VAR_1->window_sequence = (uint8_t)faad_getbits(VAR_2, 2\n        DEBUGVAR(1,44,\"ics_info(): window_sequence\"));\n    VAR_1->window_shape = faad_get1bit(VAR_2\n        DEBUGVAR(1,45,\"ics_info(): window_shape\"));\n\n#ifdef VAR_6\n    /* COMMENT_0 */\n    if ((VAR_0->object_type == VAR_7) && (VAR_1->window_sequence != VAR_8))\n        return 32;\n#endif\n\n    if (VAR_1->window_sequence == VAR_9)\n    {\n        VAR_1->max_sfb = (uint8_t)faad_getbits(VAR_2, 4\n            DEBUGVAR(1,46,\"ics_info(): max_sfb (short)\"));\n        VAR_1->scale_factor_grouping = (uint8_t)faad_getbits(VAR_2, 7\n            DEBUGVAR(1,47,\"ics_info(): scale_factor_grouping\"));\n    } else {\n        VAR_1->max_sfb = (uint8_t)faad_getbits(VAR_2, 6\n            DEBUGVAR(1,48,\"ics_info(): max_sfb (long)\"));\n    }\n\n    /* COMMENT_1 */\n    if ((VAR_4 = window_grouping_info(VAR_0, VAR_1)) > 0)\n        return VAR_4;\n\n\n    /* COMMENT_2 */\n    /* COMMENT_3 */\n    if (VAR_1->max_sfb > VAR_1->num_swb)\n        return 16;\n\n    if (VAR_1->window_sequence != VAR_9)\n    {\n        if ((VAR_1->predictor_data_present = faad_get1bit(VAR_2\n            DEBUGVAR(1,49,\"ics_info(): predictor_data_present\"))) & 1)\n        {\n            if (VAR_0->object_type == VAR_10) /* COMMENT_4 */\n            {\n                uint8_t VAR_11;\n\n                uint8_t VAR_12 = min(VAR_1->max_sfb, max_pred_sfb(VAR_0->sf_index));\n#ifdef VAR_13\n                VAR_1->pred.limit = VAR_12;\n#endif\n\n                if ((\n#ifdef VAR_13\n                    VAR_1->pred.predictor_reset =\n#endif\n                    faad_get1bit(VAR_2 DEBUGVAR(1,53,\"ics_info(): pred.predictor_reset\"))) & 1)\n                {\n#ifdef VAR_13\n                    VAR_1->pred.predictor_reset_group_number =\n#endif\n                        (uint8_t)faad_getbits(VAR_2, 5 DEBUGVAR(1,54,\"ics_info(): pred.predictor_reset_group_number\"));\n                }\n\n                for (VAR_11 = 0; VAR_11 < VAR_12; VAR_11++)\n                {\n#ifdef VAR_13\n                    VAR_1->pred.prediction_used[VAR_11] =\n#endif\n                        faad_get1bit(VAR_2 DEBUGVAR(1,55,\"ics_info(): pred.prediction_used\"));\n                }\n            }\n#ifdef VAR_14\n            else { /* COMMENT_5 */\n                if (VAR_0->object_type < VAR_15)\n                {\n                    if ((VAR_1->ltp.data_present = faad_get1bit(VAR_2\n                        DEBUGVAR(1,50,\"ics_info(): ltp.data_present\"))) & 1)\n                    {\n                        if ((VAR_4 = ltp_data(VAR_0, VAR_1, &(VAR_1->ltp), VAR_2)) > 0)\n                        {\n                            return VAR_4;\n                        }\n                    }\n                    if (VAR_3)\n                    {\n                        if ((VAR_1->ltp2.data_present = faad_get1bit(VAR_2\n                            DEBUGVAR(1,51,\"ics_info(): ltp2.data_present\"))) & 1)\n                        {\n                            if ((VAR_4 = ltp_data(VAR_0, VAR_1, &(VAR_1->ltp2), VAR_2)) > 0)\n                            {\n                                return VAR_4;\n                            }\n                        }\n                    }\n                }\n#ifdef VAR_16\n                if (!VAR_3 && (VAR_0->object_type >= VAR_15))\n                {\n                    if ((VAR_1->ltp.data_present = faad_get1bit(VAR_2\n                        DEBUGVAR(1,50,\"ics_info(): ltp.data_present\"))) & 1)\n                    {\n                        if ((VAR_4 = ltp_data(VAR_0, VAR_1, &(VAR_1->ltp), VAR_2)) > 0)\n                        {\n                            return VAR_4;\n                        }\n                    }\n                }\n#endif\n            }\n#endif\n        }\n    }\n\n    return VAR_4;\n}",
  "func_graph_path": "knik0/faad2/e19a5e491354e0e4664d02b796dacee28fb2521e/syntax.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -104,7 +104,10 @@\n                     if ((ics->ltp.data_present = faad_get1bit(ld\n                         DEBUGVAR(1,50,\"ics_info(): ltp.data_present\"))) & 1)\n                     {\n-                        ltp_data(hDecoder, ics, &(ics->ltp), ld);\n+                        if ((retval = ltp_data(hDecoder, ics, &(ics->ltp), ld)) > 0)\n+                        {\n+                            return retval;\n+                        }\n                     }\n                 }\n #endif",
  "diff_line_info": {
    "deleted_lines": [
      "                        ltp_data(hDecoder, ics, &(ics->ltp), ld);"
    ],
    "added_lines": [
      "                        if ((retval = ltp_data(hDecoder, ics, &(ics->ltp), ld)) > 0)",
      "                        {",
      "                            return retval;",
      "                        }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/knik0/faad2/pull/63",
  "description": {
    "pr_info": {
      "title": "Fix various issues",
      "number": 63
    },
    "comment": [
      "I tried to fix some of the outstanding issues. Please test and double check if you have time.",
      "Wow, thanks!\r\n\r\n~~Could you please elaborate which \"outstanding issues\" exactly each commit addresses?~~",
      "Never mind, I should have read the commit messages!",
      "I don't have a chance to test all your changes, but they look all reasonable to me. I'll apply them in good faith, thank you very much! ",
      "Since you seem to be knowledgeable of the code and the data format, could you probably have a look at https://github.com/knik0/faad2/commit/466b01d504d7e45f1e9169ac90b3e34ab94aed14 and the linked issues at the mixx bug tracker, please? ",
      "Do you happen to have any more fixes in the line? I'd like to tag the current state as a new release anytime soon but don't want to get in the way if you have more to apply. ",
      "See #65. There is no rush on it though. It sounds like it #64 is more important to get out in the wild since it fixes a regression."
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.7,
  "Bug Filter Response": "**Final Output:**\n**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.7"
}