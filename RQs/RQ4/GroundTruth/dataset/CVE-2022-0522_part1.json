{
  "cve_id": "CVE-2022-0522",
  "cwe_ids": [
    "CWE-119"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "radareorg/radare2",
  "commit_msg": "Fix negative index in anal.arm64.cs ##crash\n\n* Reported by Cen Zhang via huntr.dev",
  "commit_hash": "d17a7bdf166108a29a27cd89bf454f9fa6c050d6",
  "git_url": "https://github.com/radareorg/radare2/commit/d17a7bdf166108a29a27cd89bf454f9fa6c050d6",
  "file_path": "libr/anal/p/anal_arm_cs.c",
  "func_name": "vector64_dst_append",
  "func_before": "static void vector64_dst_append(RStrBuf *sb, csh *handle, cs_insn *insn, int n, int i) {\n\tcs_arm64_op op = INSOP64 (n);\n\n\tif (op.vector_index != -1) {\n\t\ti = op.vector_index;\n\t}\n#if CS_API_MAJOR == 4\n\tconst bool isvessas = (op.vess || op.vas);\n#else\n\tconst bool isvessas = op.vas;\n#endif\n\tif (isvessas && i != -1) {\n\t\tint size = vector_size (&op);\n\t\tint shift = i * size;\n\t\tchar *regc = \"l\";\n\t\tsize_t s = sizeof (bitmask_by_width) / sizeof (*bitmask_by_width);\n\t\tsize_t index = size > 0? (size - 1) % s: 0;\n\t\tif (index >= BITMASK_BY_WIDTH_COUNT) {\n\t\t\tindex = 0;\n\t\t}\n\t\tut64 mask = bitmask_by_width[index];\n\t\tif (shift >= 64) {\n\t\t\tshift -= 64;\n\t\t\tregc = \"h\";\n\t\t}\n\n\t\tif (shift > 0 && shift < 64) {\n\t\t\tr_strbuf_appendf (sb, \"%d,SWAP,0x%\"PFMT64x\",&,<<,%s%s,0x%\"PFMT64x\",&,|,%s%s\",\n\t\t\t\tshift, mask, REG64 (n), regc, VEC64_MASK (shift, size), REG64 (n), regc);\n\t\t} else {\n\t\t\tint dimsize = size % 64;\n\t\t\tr_strbuf_appendf (sb, \"0x%\"PFMT64x\",&,%s%s,0x%\"PFMT64x\",&,|,%s%s\",\n\t\t\t\tmask, REG64 (n), regc, VEC64_MASK (shift, dimsize), REG64 (n), regc);\n\t\t}\n\t} else {\n\t\tr_strbuf_appendf (sb, \"%s\", REG64 (n));\n\t}\n}",
  "abstract_func_before": "static void vector64_dst_append(RStrBuf *VAR_0, csh *VAR_1, cs_insn *VAR_2, int VAR_3, int VAR_4) {\n\tcs_arm64_op VAR_5 = INSOP64 (VAR_3);\n\n\tif (VAR_5.vector_index != -1) {\n\t\tVAR_4 = VAR_5.vector_index;\n\t}\n#if VAR_6 == 4\n\tconst bool VAR_7 = (VAR_5.vess || VAR_5.vas);\n#else\n\tconst bool VAR_7 = VAR_5.vas;\n#endif\n\tif (VAR_7 && VAR_4 != -1) {\n\t\tint VAR_8 = vector_size (&VAR_5);\n\t\tint VAR_9 = VAR_4 * VAR_8;\n\t\tchar *VAR_10 = \"l\";\n\t\tsize_t VAR_11 = sizeof (bitmask_by_width) / sizeof (*bitmask_by_width);\n\t\tsize_t VAR_12 = VAR_8 > 0? (VAR_8 - 1) % VAR_11: 0;\n\t\tif (VAR_12 >= VAR_13) {\n\t\t\tVAR_12 = 0;\n\t\t}\n\t\tut64 VAR_14 = bitmask_by_width[VAR_12];\n\t\tif (VAR_9 >= 64) {\n\t\t\tVAR_9 -= 64;\n\t\t\tVAR_10 = \"h\";\n\t\t}\n\n\t\tif (VAR_9 > 0 && VAR_9 < 64) {\n\t\t\tr_strbuf_appendf (VAR_0, \"%d,SWAP,0x%\"VAR_15\",&,<<,%s%s,0x%\"VAR_15\",&,|,%s%s\",\n\t\t\t\tVAR_9, VAR_14, REG64 (VAR_3), VAR_10, VEC64_MASK (VAR_9, VAR_8), REG64 (VAR_3), VAR_10);\n\t\t} else {\n\t\t\tint VAR_16 = VAR_8 % 64;\n\t\t\tr_strbuf_appendf (VAR_0, \"0x%\"VAR_15\",&,%s%s,0x%\"VAR_15\",&,|,%s%s\",\n\t\t\t\tVAR_14, REG64 (VAR_3), VAR_10, VEC64_MASK (VAR_9, VAR_16), REG64 (VAR_3), VAR_10);\n\t\t}\n\t} else {\n\t\tr_strbuf_appendf (VAR_0, \"%s\", REG64 (VAR_3));\n\t}\n}",
  "func_graph_path_before": "radareorg/radare2/d17a7bdf166108a29a27cd89bf454f9fa6c050d6/anal_arm_cs.c/vul/before/0.json",
  "func": "static void vector64_dst_append(RStrBuf *sb, csh *handle, cs_insn *insn, int n, int i) {\n\tcs_arm64_op op = INSOP64 (n);\n\n\tif (op.vector_index != -1) {\n\t\ti = op.vector_index;\n\t}\n#if CS_API_MAJOR == 4\n\tconst bool isvessas = (op.vess || op.vas);\n#else\n\tconst bool isvessas = op.vas;\n#endif\n\tif (isvessas && i != -1) {\n\t\tint size = vector_size (&op);\n\t\tint shift = i * size;\n\t\tchar *regc = \"l\";\n\t\tsize_t s = sizeof (bitmask_by_width) / sizeof (*bitmask_by_width);\n\t\tsize_t index = size > 0? (size - 1) % s: 0;\n\t\tif (index >= BITMASK_BY_WIDTH_COUNT) {\n\t\t\tindex = 0;\n\t\t}\n\t\tut64 mask = bitmask_by_width[index];\n\t\tif (shift >= 64) {\n\t\t\tshift -= 64;\n\t\t\tregc = \"h\";\n\t\t}\n\t\tif (shift > 0 && shift < 64) {\n\t\t\tr_strbuf_appendf (sb, \"%d,SWAP,0x%\"PFMT64x\",&,<<,%s%s,0x%\"PFMT64x\",&,|,%s%s\",\n\t\t\t\tshift, mask, REG64 (n), regc, VEC64_MASK (shift, size), REG64 (n), regc);\n\t\t} else {\n\t\t\tint dimsize = size % 64;\n\t\t\tr_strbuf_appendf (sb, \"0x%\"PFMT64x\",&,%s%s,0x%\"PFMT64x\",&,|,%s%s\",\n\t\t\t\tmask, REG64 (n), regc, VEC64_MASK (shift, dimsize), REG64 (n), regc);\n\t\t}\n\t} else {\n\t\tr_strbuf_appendf (sb, \"%s\", REG64 (n));\n\t}\n}",
  "abstract_func": "static void vector64_dst_append(RStrBuf *VAR_0, csh *VAR_1, cs_insn *VAR_2, int VAR_3, int VAR_4) {\n\tcs_arm64_op VAR_5 = INSOP64 (VAR_3);\n\n\tif (VAR_5.vector_index != -1) {\n\t\tVAR_4 = VAR_5.vector_index;\n\t}\n#if VAR_6 == 4\n\tconst bool VAR_7 = (VAR_5.vess || VAR_5.vas);\n#else\n\tconst bool VAR_7 = VAR_5.vas;\n#endif\n\tif (VAR_7 && VAR_4 != -1) {\n\t\tint VAR_8 = vector_size (&VAR_5);\n\t\tint VAR_9 = VAR_4 * VAR_8;\n\t\tchar *VAR_10 = \"l\";\n\t\tsize_t VAR_11 = sizeof (bitmask_by_width) / sizeof (*bitmask_by_width);\n\t\tsize_t VAR_12 = VAR_8 > 0? (VAR_8 - 1) % VAR_11: 0;\n\t\tif (VAR_12 >= VAR_13) {\n\t\t\tVAR_12 = 0;\n\t\t}\n\t\tut64 VAR_14 = bitmask_by_width[VAR_12];\n\t\tif (VAR_9 >= 64) {\n\t\t\tVAR_9 -= 64;\n\t\t\tVAR_10 = \"h\";\n\t\t}\n\t\tif (VAR_9 > 0 && VAR_9 < 64) {\n\t\t\tr_strbuf_appendf (VAR_0, \"%d,SWAP,0x%\"VAR_15\",&,<<,%s%s,0x%\"VAR_15\",&,|,%s%s\",\n\t\t\t\tVAR_9, VAR_14, REG64 (VAR_3), VAR_10, VEC64_MASK (VAR_9, VAR_8), REG64 (VAR_3), VAR_10);\n\t\t} else {\n\t\t\tint VAR_16 = VAR_8 % 64;\n\t\t\tr_strbuf_appendf (VAR_0, \"0x%\"VAR_15\",&,%s%s,0x%\"VAR_15\",&,|,%s%s\",\n\t\t\t\tVAR_14, REG64 (VAR_3), VAR_10, VEC64_MASK (VAR_9, VAR_16), REG64 (VAR_3), VAR_10);\n\t\t}\n\t} else {\n\t\tr_strbuf_appendf (VAR_0, \"%s\", REG64 (VAR_3));\n\t}\n}",
  "func_graph_path": "radareorg/radare2/d17a7bdf166108a29a27cd89bf454f9fa6c050d6/anal_arm_cs.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -23,7 +23,6 @@\n \t\t\tshift -= 64;\n \t\t\tregc = \"h\";\n \t\t}\n-\n \t\tif (shift > 0 && shift < 64) {\n \t\t\tr_strbuf_appendf (sb, \"%d,SWAP,0x%\"PFMT64x\",&,<<,%s%s,0x%\"PFMT64x\",&,|,%s%s\",\n \t\t\t\tshift, mask, REG64 (n), regc, VEC64_MASK (shift, size), REG64 (n), regc);",
  "diff_line_info": {
    "deleted_lines": [
      ""
    ],
    "added_lines": []
  },
  "is_vul": true,
  "pr_url": "https://github.com/radareorg/radare2/pull/19669",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/radareorg/radare2/pull/19669: 403 Client Error: Forbidden for url: https://api.github.com/repos/radareorg/radare2/pulls/19669",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "The patch addresses a crash caused by a negative index, which could lead to a security vulnerability. The code changes fix the handling of the shift value to prevent this issue.\n\n**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.9"
}