{
  "cve_id": "CVE-2021-32847",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:C/C:H/I:N/A:N",
  "cvss_is_v3": true,
  "repo_name": "moby/hyperkit",
  "commit_msg": "Fix assertion turned into assignment\n\nThe qassertion is supposed to check the value but the typo makes it\nan assignment. Hence it is always true,\n\nSigned-off-by: Frederic Dalleau <frederic.dalleau@docker.com>",
  "commit_hash": "cf60095a4d8c3cb2e182a14415467afd356e982f",
  "git_url": "https://github.com/moby/hyperkit/commit/cf60095a4d8c3cb2e182a14415467afd356e982f",
  "file_path": "src/lib/pci_virtio_block.c",
  "func_name": "pci_vtblk_proc",
  "func_before": "static void\npci_vtblk_proc(struct pci_vtblk_softc *sc, struct vqueue_info *vq)\n{\n\tstruct virtio_blk_hdr *vbh;\n\tstruct virtio_blk_discard_write_zeroes *vbdiscard;\n\tstruct pci_vtblk_ioreq *io;\n\tint i, n;\n\tint err;\n\tssize_t iolen;\n\tint expectro, type;\n\tstruct iovec iov[BLOCKIF_IOV_MAX + 2];\n\tuint16_t idx, flags[BLOCKIF_IOV_MAX + 2];\n\n\tn = vq_getchain(vq, &idx, iov, BLOCKIF_IOV_MAX + 2, flags);\n\n\t/*\n\t * The first descriptor will be the read-only fixed header,\n\t * and the last is for status (hence +2 above and below).\n\t * The remaining iov's are the actual data I/O vectors.\n\t *\n\t * XXX - note - this fails on crash dump, which does a\n\t * VIRTIO_BLK_T_FLUSH with a zero transfer length\n\t */\n\tassert(n >= 2 && n <= BLOCKIF_IOV_MAX + 2);\n\n\tio = &sc->vbsc_ios[idx];\n\tassert((flags[0] & VRING_DESC_F_WRITE) == 0);\n\tassert(iov[0].iov_len == sizeof(struct virtio_blk_hdr));\n\tvbh = iov[0].iov_base;\n\tmemcpy(&io->io_req.br_iov, &iov[1],\n\t       sizeof(struct iovec) * ((size_t)n - 2));\n\tio->io_req.br_iovcnt = n - 2;\n\tio->io_req.br_offset = (off_t)(vbh->vbh_sector * DEV_BSIZE);\n\tio->io_status = iov[--n].iov_base;\n\tassert(iov[n].iov_len == 1);\n\tassert(flags[n] & VRING_DESC_F_WRITE);\n\n\t/*\n\t * XXX\n\t * The guest should not be setting the BARRIER flag because\n\t * we don't advertise the capability.\n\t */\n\ttype = vbh->vbh_type & ~VBH_FLAG_BARRIER;\n\texpectro = (type == VBH_OP_WRITE) || (type == VBH_OP_DISCARD);\n\tiolen = 0;\n\tfor (i = 1; i < n; i++) {\n\t\t/*\n\t\t * - write/discard op implies read-only descriptor,\n\t\t * - read/ident op implies write-only descriptor,\n\t\t * therefore test the inverse of the descriptor bit\n\t\t * to the op.\n\t\t */\n\t\tassert(((flags[i] & VRING_DESC_F_WRITE) == 0) == expectro);\n\t\tiolen += iov[i].iov_len;\n\t}\n\tio->io_req.br_resid = iolen;\n\n\tDPRINTF((\"virtio-block: %s op, %zd bytes, %d segs\\n\\r\",\n\t\t print_vbh_op(type), iolen, i - 1));\n\n\tswitch (type) {\n\tcase VBH_OP_READ:\n\t\terr = blockif_read(sc->bc, &io->io_req);\n\t\tbreak;\n\tcase VBH_OP_WRITE:\n\t\terr = blockif_write(sc->bc, &io->io_req);\n\t\tbreak;\n\tcase VBH_OP_DISCARD:\n\t\t/* We currently limit the discard to one segment in the initial negotiation\n\t\t   so expect exactly one correctly-sized payload descriptor. */\n\t\tassert(iov[1].iov_len = sizeof(struct virtio_blk_discard_write_zeroes));\n\t\tassert(n == 2);\n\t\tvbdiscard = iov[1].iov_base;\n\t\tio->io_req.br_offset = (off_t) vbdiscard->sector * DEV_BSIZE;\n\t\tio->io_req.br_resid = vbdiscard->num_sectors * DEV_BSIZE;\n\t\terr = blockif_delete(sc->bc, &io->io_req);\n\t\tbreak;\n\tcase VBH_OP_FLUSH:\n\tcase VBH_OP_FLUSH_OUT:\n\t\terr = blockif_flush(sc->bc, &io->io_req);\n\t\tbreak;\n\tcase VBH_OP_IDENT:\n\t\t/* Assume a single buffer */\n\t\t/* S/n equal to buffer is not zero-terminated. */\n\t\tmemset(iov[1].iov_base, 0, iov[1].iov_len);\n\t\tstrncpy(iov[1].iov_base, sc->vbsc_ident,\n\t\t    MIN(iov[1].iov_len, sizeof(sc->vbsc_ident)));\n\t\t/* xhyve: FIXME */\n\t\tpci_vtblk_done_locked(&io->io_req, 0);\n\t\treturn;\n\tdefault:\n\t\t/* xhyve: FIXME */\n\t\tpci_vtblk_done_locked(&io->io_req, EOPNOTSUPP);\n\t\treturn;\n\t}\n\tassert(err == 0);\n}",
  "abstract_func_before": "static void\npci_vtblk_proc(struct pci_vtblk_softc *VAR_0, struct vqueue_info *VAR_1)\n{\n\tstruct virtio_blk_hdr *VAR_2;\n\tstruct virtio_blk_discard_write_zeroes *VAR_3;\n\tstruct pci_vtblk_ioreq *VAR_4;\n\tint VAR_5, VAR_6;\n\tint VAR_7;\n\tssize_t VAR_8;\n\tint VAR_9, VAR_10;\n\tstruct iovec VAR_11[VAR_12 + 2];\n\tuint16_t VAR_13, VAR_14[VAR_12 + 2];\n\n\tVAR_6 = vq_getchain(VAR_1, &VAR_13, VAR_11, VAR_12 + 2, VAR_14);\n\n\t/* COMMENT_0 */\n                                                            \n                                                          \n                                                        \n   \n                                                       \n                                                  \n    \n\tassert(VAR_6 >= 2 && VAR_6 <= VAR_12 + 2);\n\n\tVAR_4 = &VAR_0->vbsc_ios[VAR_13];\n\tassert((VAR_14[0] & VAR_15) == 0);\n\tassert(VAR_11[0].iov_len == sizeof(struct virtio_blk_hdr));\n\tVAR_2 = VAR_11[0].iov_base;\n\tmemcpy(&VAR_4->io_req.br_iov, &VAR_11[1],\n\t       sizeof(struct iovec) * ((size_t)VAR_6 - 2));\n\tVAR_4->io_req.br_iovcnt = VAR_6 - 2;\n\tVAR_4->io_req.br_offset = (VAR_16)(VAR_2->vbh_sector * VAR_17);\n\tVAR_4->io_status = VAR_11[--VAR_6].iov_base;\n\tassert(VAR_11[VAR_6].iov_len == 1);\n\tassert(VAR_14[VAR_6] & VAR_15);\n\n\t/* COMMENT_8 */\n       \n                                                            \n                                      \n    \n\tVAR_10 = VAR_2->vbh_type & ~VAR_18;\n\tVAR_9 = (VAR_10 == VAR_19) || (VAR_10 == VAR_20);\n\tVAR_8 = 0;\n\tfor (VAR_5 = 1; VAR_5 < VAR_6; VAR_5++) {\n\t\t/* COMMENT_13 */\n                                                     \n                                                   \n                                                     \n               \n     \n\t\tassert(((VAR_14[VAR_5] & VAR_15) == 0) == VAR_9);\n\t\tVAR_8 += VAR_11[VAR_5].iov_len;\n\t}\n\tVAR_4->io_req.br_resid = VAR_8;\n\n\tDPRINTF((\"virtio-block: %s op, %zd bytes, %d segs\\n\\r\",\n\t\t print_vbh_op(VAR_10), VAR_8, VAR_5 - 1));\n\n\tswitch (VAR_10) {\n\tcase VAR_21:\n\t\tVAR_7 = blockif_read(VAR_0->bc, &VAR_4->io_req);\n\t\tbreak;\n\tcase VAR_19:\n\t\tVAR_7 = blockif_write(VAR_0->bc, &VAR_4->io_req);\n\t\tbreak;\n\tcase VAR_20:\n\t\t/* COMMENT_19 */\n                                                                 \n\t\tassert(VAR_11[1].iov_len = sizeof(struct virtio_blk_discard_write_zeroes));\n\t\tassert(VAR_6 == 2);\n\t\tVAR_3 = VAR_11[1].iov_base;\n\t\tVAR_4->io_req.br_offset = (off_t) VAR_3->sector * VAR_17;\n\t\tVAR_4->io_req.br_resid = VAR_3->num_sectors * VAR_17;\n\t\tVAR_7 = blockif_delete(VAR_0->bc, &VAR_4->io_req);\n\t\tbreak;\n\tcase VAR_22:\n\tcase VAR_23:\n\t\tVAR_7 = blockif_flush(VAR_0->bc, &VAR_4->io_req);\n\t\tbreak;\n\tcase VAR_24:\n\t\t/* COMMENT_21 */\n\t\t/* COMMENT_22 */\n\t\tmemset(VAR_11[1].iov_base, 0, VAR_11[1].iov_len);\n\t\tstrncpy(VAR_11[1].iov_base, VAR_0->vbsc_ident,\n\t\t    MIN(VAR_11[1].iov_len, sizeof(VAR_0->vbsc_ident)));\n\t\t/* COMMENT_23 */\n\t\tpci_vtblk_done_locked(&VAR_4->io_req, 0);\n\t\treturn;\n\tdefault:\n\t\t/* COMMENT_23 */\n\t\tpci_vtblk_done_locked(&VAR_4->io_req, VAR_25);\n\t\treturn;\n\t}\n\tassert(VAR_7 == 0);\n}",
  "func_graph_path_before": "moby/hyperkit/cf60095a4d8c3cb2e182a14415467afd356e982f/pci_virtio_block.c/vul/before/0.json",
  "func": "static void\npci_vtblk_proc(struct pci_vtblk_softc *sc, struct vqueue_info *vq)\n{\n\tstruct virtio_blk_hdr *vbh;\n\tstruct virtio_blk_discard_write_zeroes *vbdiscard;\n\tstruct pci_vtblk_ioreq *io;\n\tint i, n;\n\tint err;\n\tssize_t iolen;\n\tint expectro, type;\n\tstruct iovec iov[BLOCKIF_IOV_MAX + 2];\n\tuint16_t idx, flags[BLOCKIF_IOV_MAX + 2];\n\n\tn = vq_getchain(vq, &idx, iov, BLOCKIF_IOV_MAX + 2, flags);\n\n\t/*\n\t * The first descriptor will be the read-only fixed header,\n\t * and the last is for status (hence +2 above and below).\n\t * The remaining iov's are the actual data I/O vectors.\n\t *\n\t * XXX - note - this fails on crash dump, which does a\n\t * VIRTIO_BLK_T_FLUSH with a zero transfer length\n\t */\n\tassert(n >= 2 && n <= BLOCKIF_IOV_MAX + 2);\n\n\tio = &sc->vbsc_ios[idx];\n\tassert((flags[0] & VRING_DESC_F_WRITE) == 0);\n\tassert(iov[0].iov_len == sizeof(struct virtio_blk_hdr));\n\tvbh = iov[0].iov_base;\n\tmemcpy(&io->io_req.br_iov, &iov[1],\n\t       sizeof(struct iovec) * ((size_t)n - 2));\n\tio->io_req.br_iovcnt = n - 2;\n\tio->io_req.br_offset = (off_t)(vbh->vbh_sector * DEV_BSIZE);\n\tio->io_status = iov[--n].iov_base;\n\tassert(iov[n].iov_len == 1);\n\tassert(flags[n] & VRING_DESC_F_WRITE);\n\n\t/*\n\t * XXX\n\t * The guest should not be setting the BARRIER flag because\n\t * we don't advertise the capability.\n\t */\n\ttype = vbh->vbh_type & ~VBH_FLAG_BARRIER;\n\texpectro = (type == VBH_OP_WRITE) || (type == VBH_OP_DISCARD);\n\tiolen = 0;\n\tfor (i = 1; i < n; i++) {\n\t\t/*\n\t\t * - write/discard op implies read-only descriptor,\n\t\t * - read/ident op implies write-only descriptor,\n\t\t * therefore test the inverse of the descriptor bit\n\t\t * to the op.\n\t\t */\n\t\tassert(((flags[i] & VRING_DESC_F_WRITE) == 0) == expectro);\n\t\tiolen += iov[i].iov_len;\n\t}\n\tio->io_req.br_resid = iolen;\n\n\tDPRINTF((\"virtio-block: %s op, %zd bytes, %d segs\\n\\r\",\n\t\t print_vbh_op(type), iolen, i - 1));\n\n\tswitch (type) {\n\tcase VBH_OP_READ:\n\t\terr = blockif_read(sc->bc, &io->io_req);\n\t\tbreak;\n\tcase VBH_OP_WRITE:\n\t\terr = blockif_write(sc->bc, &io->io_req);\n\t\tbreak;\n\tcase VBH_OP_DISCARD:\n\t\t/* We currently limit the discard to one segment in the initial negotiation\n\t\t   so expect exactly one correctly-sized payload descriptor. */\n\t\tassert(iov[1].iov_len == sizeof(struct virtio_blk_discard_write_zeroes));\n\t\tassert(n == 2);\n\t\tvbdiscard = iov[1].iov_base;\n\t\tio->io_req.br_offset = (off_t) vbdiscard->sector * DEV_BSIZE;\n\t\tio->io_req.br_resid = vbdiscard->num_sectors * DEV_BSIZE;\n\t\terr = blockif_delete(sc->bc, &io->io_req);\n\t\tbreak;\n\tcase VBH_OP_FLUSH:\n\tcase VBH_OP_FLUSH_OUT:\n\t\terr = blockif_flush(sc->bc, &io->io_req);\n\t\tbreak;\n\tcase VBH_OP_IDENT:\n\t\t/* Assume a single buffer */\n\t\t/* S/n equal to buffer is not zero-terminated. */\n\t\tmemset(iov[1].iov_base, 0, iov[1].iov_len);\n\t\tstrncpy(iov[1].iov_base, sc->vbsc_ident,\n\t\t    MIN(iov[1].iov_len, sizeof(sc->vbsc_ident)));\n\t\t/* xhyve: FIXME */\n\t\tpci_vtblk_done_locked(&io->io_req, 0);\n\t\treturn;\n\tdefault:\n\t\t/* xhyve: FIXME */\n\t\tpci_vtblk_done_locked(&io->io_req, EOPNOTSUPP);\n\t\treturn;\n\t}\n\tassert(err == 0);\n}",
  "abstract_func": "static void\npci_vtblk_proc(struct pci_vtblk_softc *VAR_0, struct vqueue_info *VAR_1)\n{\n\tstruct virtio_blk_hdr *VAR_2;\n\tstruct virtio_blk_discard_write_zeroes *VAR_3;\n\tstruct pci_vtblk_ioreq *VAR_4;\n\tint VAR_5, VAR_6;\n\tint VAR_7;\n\tssize_t VAR_8;\n\tint VAR_9, VAR_10;\n\tstruct iovec VAR_11[VAR_12 + 2];\n\tuint16_t VAR_13, VAR_14[VAR_12 + 2];\n\n\tVAR_6 = vq_getchain(VAR_1, &VAR_13, VAR_11, VAR_12 + 2, VAR_14);\n\n\t/* COMMENT_0 */\n                                                            \n                                                          \n                                                        \n   \n                                                       \n                                                  \n    \n\tassert(VAR_6 >= 2 && VAR_6 <= VAR_12 + 2);\n\n\tVAR_4 = &VAR_0->vbsc_ios[VAR_13];\n\tassert((VAR_14[0] & VAR_15) == 0);\n\tassert(VAR_11[0].iov_len == sizeof(struct virtio_blk_hdr));\n\tVAR_2 = VAR_11[0].iov_base;\n\tmemcpy(&VAR_4->io_req.br_iov, &VAR_11[1],\n\t       sizeof(struct iovec) * ((size_t)VAR_6 - 2));\n\tVAR_4->io_req.br_iovcnt = VAR_6 - 2;\n\tVAR_4->io_req.br_offset = (VAR_16)(VAR_2->vbh_sector * VAR_17);\n\tVAR_4->io_status = VAR_11[--VAR_6].iov_base;\n\tassert(VAR_11[VAR_6].iov_len == 1);\n\tassert(VAR_14[VAR_6] & VAR_15);\n\n\t/* COMMENT_8 */\n       \n                                                            \n                                      \n    \n\tVAR_10 = VAR_2->vbh_type & ~VAR_18;\n\tVAR_9 = (VAR_10 == VAR_19) || (VAR_10 == VAR_20);\n\tVAR_8 = 0;\n\tfor (VAR_5 = 1; VAR_5 < VAR_6; VAR_5++) {\n\t\t/* COMMENT_13 */\n                                                     \n                                                   \n                                                     \n               \n     \n\t\tassert(((VAR_14[VAR_5] & VAR_15) == 0) == VAR_9);\n\t\tVAR_8 += VAR_11[VAR_5].iov_len;\n\t}\n\tVAR_4->io_req.br_resid = VAR_8;\n\n\tDPRINTF((\"virtio-block: %s op, %zd bytes, %d segs\\n\\r\",\n\t\t print_vbh_op(VAR_10), VAR_8, VAR_5 - 1));\n\n\tswitch (VAR_10) {\n\tcase VAR_21:\n\t\tVAR_7 = blockif_read(VAR_0->bc, &VAR_4->io_req);\n\t\tbreak;\n\tcase VAR_19:\n\t\tVAR_7 = blockif_write(VAR_0->bc, &VAR_4->io_req);\n\t\tbreak;\n\tcase VAR_20:\n\t\t/* COMMENT_19 */\n                                                                 \n\t\tassert(VAR_11[1].iov_len == sizeof(struct virtio_blk_discard_write_zeroes));\n\t\tassert(VAR_6 == 2);\n\t\tVAR_3 = VAR_11[1].iov_base;\n\t\tVAR_4->io_req.br_offset = (off_t) VAR_3->sector * VAR_17;\n\t\tVAR_4->io_req.br_resid = VAR_3->num_sectors * VAR_17;\n\t\tVAR_7 = blockif_delete(VAR_0->bc, &VAR_4->io_req);\n\t\tbreak;\n\tcase VAR_22:\n\tcase VAR_23:\n\t\tVAR_7 = blockif_flush(VAR_0->bc, &VAR_4->io_req);\n\t\tbreak;\n\tcase VAR_24:\n\t\t/* COMMENT_21 */\n\t\t/* COMMENT_22 */\n\t\tmemset(VAR_11[1].iov_base, 0, VAR_11[1].iov_len);\n\t\tstrncpy(VAR_11[1].iov_base, VAR_0->vbsc_ident,\n\t\t    MIN(VAR_11[1].iov_len, sizeof(VAR_0->vbsc_ident)));\n\t\t/* COMMENT_23 */\n\t\tpci_vtblk_done_locked(&VAR_4->io_req, 0);\n\t\treturn;\n\tdefault:\n\t\t/* COMMENT_23 */\n\t\tpci_vtblk_done_locked(&VAR_4->io_req, VAR_25);\n\t\treturn;\n\t}\n\tassert(VAR_7 == 0);\n}",
  "func_graph_path": "moby/hyperkit/cf60095a4d8c3cb2e182a14415467afd356e982f/pci_virtio_block.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -68,7 +68,7 @@\n \tcase VBH_OP_DISCARD:\n \t\t/* We currently limit the discard to one segment in the initial negotiation\n \t\t   so expect exactly one correctly-sized payload descriptor. */\n-\t\tassert(iov[1].iov_len = sizeof(struct virtio_blk_discard_write_zeroes));\n+\t\tassert(iov[1].iov_len == sizeof(struct virtio_blk_discard_write_zeroes));\n \t\tassert(n == 2);\n \t\tvbdiscard = iov[1].iov_base;\n \t\tio->io_req.br_offset = (off_t) vbdiscard->sector * DEV_BSIZE;",
  "diff_line_info": {
    "deleted_lines": [
      "\t\tassert(iov[1].iov_len = sizeof(struct virtio_blk_discard_write_zeroes));"
    ],
    "added_lines": [
      "\t\tassert(iov[1].iov_len == sizeof(struct virtio_blk_discard_write_zeroes));"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/moby/hyperkit/pull/318",
  "description": {
    "pr_info": {
      "title": "Fix assertion turned into assignment",
      "number": 318
    },
    "comment": [
      "The assertion is supposed to check the value, but the typo makes it\r\nan assignment. Hence it is always true.\r\n\r\nFixes GHSL-2021-058"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}