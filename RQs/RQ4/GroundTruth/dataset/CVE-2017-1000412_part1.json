{
  "cve_id": "CVE-2017-1000412",
  "cwe_ids": [
    "CWE-200"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:N/A:N",
  "cvss_is_v3": false,
  "repo_name": "OP-TEE/optee_os",
  "commit_msg": "ltc: remove LTC_LINARO_FIX_RSAWITHOUTCRT\n\nLTC_LINARO_FIX_RSAWITHOUTCRT is used to handle the case where the CRT\noptimized algorithm cannot be used because the optimized parameters are\nmissing. In the official LibTomCrypt tree, there is an official fix for\nthis.\n\nPlease see commits (official LibTomCrypt tree):\n    01f184540232 (\"harden RSA CRT by implementing the proposed\n                   countermeasure from ch. 1.3 of [1]\")\n    a6e89d58d4fb (\"RSA in CRT optimization parameters are empty\")\n    2bb3f0246f65 (\"RSA in case CRT optimization parameters are not\n                   populated\")\n\nThose patches were brought into OP-TEE with this patch\n    a50cb361d9e5 (\"ltc: sync from official develop branch\")\n\nAnd therefore there is no need to keep the LTC_LINARO_FIX_RSAWITHOUTCRT\nany longer, hence this patch removes the flag and the code related to\nthat particular flag.\n\nSigned-off-by: Joakim Bech <joakim.bech@linaro.org>\nReviewed-by: Jerome Forissier <jerome.forissier@linaro.org>\nReviewed-by: Jens Wiklander <jens.wiklander@linaro.org>\nAcked-by: Etienne Carriere <etienne.carriere@linaro.org>\nTested-by: Jerome Forissier <jerome.forissier@linaro.org> (HiKey, GP)\nTested-by: Etienne Carriere <etienne.carriere@linaro.org> (b2260, GP)",
  "commit_hash": "c53ec7708e6f97fabc4a532a48d6099f1202d913",
  "git_url": "https://github.com/OP-TEE/optee_os/commit/c53ec7708e6f97fabc4a532a48d6099f1202d913",
  "file_path": "core/lib/libtomcrypt/src/pk/rsa/rsa_exptmod.c",
  "func_name": "rsa_exptmod",
  "func_before": "int rsa_exptmod(const unsigned char *in,   unsigned long inlen,\n                      unsigned char *out,  unsigned long *outlen, int which,\n                      rsa_key *key)\n{\n   void         *tmp, *tmpa, *tmpb;\n#ifdef LTC_RSA_BLINDING\n   void        *rnd, *rndi /* inverse of rnd */;\n#endif\n   unsigned long x;\n   int           err, no_crt;\n\n   LTC_ARGCHK(in     != NULL);\n   LTC_ARGCHK(out    != NULL);\n   LTC_ARGCHK(outlen != NULL);\n   LTC_ARGCHK(key    != NULL);\n  \n   /* is the key of the right type for the operation? */\n   if (which == PK_PRIVATE && (key->type != PK_PRIVATE)) {\n      return CRYPT_PK_NOT_PRIVATE;\n   }\n\n   /* must be a private or public operation */\n   if (which != PK_PRIVATE && which != PK_PUBLIC) {\n      return CRYPT_PK_INVALID_TYPE;\n   }\n\n   /* init and copy into tmp */\n   if ((err = mp_init_multi(&tmp, &tmpa, &tmpb,\n#ifdef LTC_RSA_BLINDING\n                                               &rnd, &rndi,\n#endif /* LTC_RSA_BLINDING */\n                                                           NULL)) != CRYPT_OK)\n        { return err; }\n   if ((err = mp_read_unsigned_bin(tmp, (unsigned char *)in, (int)inlen)) != CRYPT_OK)\n        { goto error; }\n\n   /* sanity check on the input */\n   if (mp_cmp(key->N, tmp) == LTC_MP_LT) {\n      err = CRYPT_PK_INVALID_SIZE;\n      goto error;\n   }\n\n   /* are we using the private exponent and is the key optimized? */\n#ifdef LTC_LINARO_FIX_RSAWITHOUTCRT\n   if ((which == PK_PRIVATE) && (key->dP == NULL)) {\n      /*\n       * Fix when CRT optimization parameters are not there\n       * In such a case, we directly use the private key\n       */\n      LTC_ARGCHK(key->dQ == NULL);\n      LTC_ARGCHK(key->qP == NULL);\n      LTC_ARGCHK(key->p  == NULL);\n      LTC_ARGCHK(key->q  == NULL);\n      /* exptmod it */\n      if ((err = mp_exptmod(tmp, key->d, key->N, tmp)) != CRYPT_OK)                                { goto error; }\n   } else\n#endif\n   if (which == PK_PRIVATE) {\n#ifdef LTC_RSA_BLINDING\n      /* do blinding */\n      err = mp_rand(rnd, mp_get_digit_count(key->N));\n      if (err != CRYPT_OK) {\n             goto error;\n      }\n\n      /* rndi = 1/rnd mod N */\n      err = mp_invmod(rnd, key->N, rndi);\n      if (err != CRYPT_OK) {\n             goto error;\n      }\n\n      /* rnd = rnd^e */\n      err = mp_exptmod( rnd, key->e, key->N, rnd);\n      if (err != CRYPT_OK) {\n             goto error;\n      }\n\n      /* tmp = tmp*rnd mod N */\n      err = mp_mulmod( tmp, rnd, key->N, tmp);\n      if (err != CRYPT_OK) {\n             goto error;\n      }\n#endif /* LTC_RSA_BLINDING */\n\n      no_crt = (key->dP == NULL) || (mp_get_digit_count(key->dP) == 0);\n\n      if (no_crt) {\n         /*\n          * In case CRT optimization parameters are not provided,\n          * the private key is directly used to exptmod it\n          */\n         if ((err = mp_exptmod(tmp, key->d, key->N, tmp)) != CRYPT_OK)                              { goto error; }\n      } else {\n         /* tmpa = tmp^dP mod p */\n         if ((err = mp_exptmod(tmp, key->dP, key->p, tmpa)) != CRYPT_OK)                            { goto error; }\n\n         /* tmpb = tmp^dQ mod q */\n         if ((err = mp_exptmod(tmp, key->dQ, key->q, tmpb)) != CRYPT_OK)                            { goto error; }\n\n         /* tmp = (tmpa - tmpb) * qInv (mod p) */\n         if ((err = mp_sub(tmpa, tmpb, tmp)) != CRYPT_OK)                                           { goto error; }\n         if ((err = mp_mulmod(tmp, key->qP, key->p, tmp)) != CRYPT_OK)                              { goto error; }\n\n         /* tmp = tmpb + q * tmp */\n         if ((err = mp_mul(tmp, key->q, tmp)) != CRYPT_OK)                                          { goto error; }\n         if ((err = mp_add(tmp, tmpb, tmp)) != CRYPT_OK)                                            { goto error; }\n      }\n\n      #ifdef LTC_RSA_BLINDING\n      /* unblind */\n      err = mp_mulmod( tmp, rndi, key->N, tmp);\n      if (err != CRYPT_OK) {\n             goto error;\n      }\n      #endif\n\n      #ifdef LTC_RSA_CRT_HARDENING\n      if (!no_crt) {\n         if ((err = mp_exptmod(tmp, key->e, key->N, tmpa)) != CRYPT_OK)                              { goto error; }\n         if ((err = mp_read_unsigned_bin(tmpb, (unsigned char *)in, (int)inlen)) != CRYPT_OK)        { goto error; }\n         if (mp_cmp(tmpa, tmpb) != LTC_MP_EQ)                                     { err = CRYPT_ERROR; goto error; }\n      }\n      #endif\n   } else {\n      /* exptmod it */\n      if ((err = mp_exptmod(tmp, key->e, key->N, tmp)) != CRYPT_OK)                                { goto error; }\n   }\n\n   /* read it back */\n   x = (unsigned long)mp_unsigned_bin_size(key->N);\n   if (x > *outlen) {\n      *outlen = x;\n      err = CRYPT_BUFFER_OVERFLOW;\n      goto error;\n   }\n\n   /* this should never happen ... */\n   if (mp_unsigned_bin_size(tmp) > mp_unsigned_bin_size(key->N)) {\n      err = CRYPT_ERROR;\n      goto error;\n   }\n   *outlen = x;\n\n   /* convert it */\n   zeromem(out, x);\n   if ((err = mp_to_unsigned_bin(tmp, out+(x-mp_unsigned_bin_size(tmp)))) != CRYPT_OK)               { goto error; }\n\n   /* clean up and return */\n   err = CRYPT_OK;\nerror:\n   mp_clear_multi(\n#ifdef LTC_RSA_BLINDING\n                  rndi, rnd,\n#endif /* LTC_RSA_BLINDING */\n                             tmpb, tmpa, tmp, NULL);\n   return err;\n}",
  "abstract_func_before": "int rsa_exptmod(const unsigned char *VAR_0,   unsigned long VAR_1,\n                      unsigned char *VAR_2,  unsigned long *VAR_3, int VAR_4,\n                      rsa_key *VAR_5)\n{\n   void         *VAR_6, *VAR_7, *VAR_8;\n#ifdef VAR_9\n   void        *VAR_10, *VAR_11 /* COMMENT_0 */;\n#endif\n   unsigned long VAR_12;\n   int           VAR_13, VAR_14;\n\n   LTC_ARGCHK(VAR_0     != NULL);\n   LTC_ARGCHK(VAR_2    != NULL);\n   LTC_ARGCHK(VAR_3 != NULL);\n   LTC_ARGCHK(VAR_5    != NULL);\n  \n   /* COMMENT_1 */\n   if (VAR_4 == VAR_15 && (VAR_5->type != VAR_15)) {\n      return VAR_16;\n   }\n\n   /* COMMENT_2 */\n   if (VAR_4 != VAR_15 && VAR_4 != VAR_17) {\n      return VAR_18;\n   }\n\n   /* COMMENT_3 */\n   if ((VAR_13 = mp_init_multi(&VAR_6, &VAR_7, &VAR_8,\n#ifdef VAR_9\n                                               &VAR_10, &VAR_11,\n#endif /* COMMENT_4 */\n                                                           NULL)) != VAR_19)\n        { return VAR_13; }\n   if ((VAR_13 = mp_read_unsigned_bin(VAR_6, (unsigned char *)VAR_0, (int)VAR_1)) != VAR_19)\n        { goto error; }\n\n   /* COMMENT_5 */\n   if (mp_cmp(VAR_5->N, VAR_6) == VAR_20) {\n      VAR_13 = VAR_21;\n      goto error;\n   }\n\n   /* COMMENT_6 */\n#ifdef VAR_22\n   if ((VAR_4 == VAR_15) && (VAR_5->dP == NULL)) {\n      /* COMMENT_7 */\n                                                           \n                                                        \n         \n      LTC_ARGCHK(VAR_5->dQ == NULL);\n      LTC_ARGCHK(VAR_5->qP == NULL);\n      LTC_ARGCHK(VAR_5->p  == NULL);\n      LTC_ARGCHK(VAR_5->q  == NULL);\n      /* COMMENT_11 */\n      if ((VAR_13 = mp_exptmod(VAR_6, VAR_5->d, VAR_5->N, VAR_6)) != VAR_19)                                { goto error; }\n   } else\n#endif\n   if (VAR_4 == VAR_15) {\n#ifdef VAR_9\n      /* COMMENT_12 */\n      VAR_13 = mp_rand(VAR_10, mp_get_digit_count(VAR_5->N));\n      if (VAR_13 != VAR_19) {\n             goto error;\n      }\n\n      /* COMMENT_13 */\n      VAR_13 = mp_invmod(VAR_10, VAR_5->N, VAR_11);\n      if (VAR_13 != VAR_19) {\n             goto error;\n      }\n\n      /* COMMENT_14 */\n      VAR_13 = mp_exptmod( VAR_10, VAR_5->e, VAR_5->N, VAR_10);\n      if (VAR_13 != VAR_19) {\n             goto error;\n      }\n\n      /* COMMENT_15 */\n      VAR_13 = mp_mulmod( VAR_6, VAR_10, VAR_5->N, VAR_6);\n      if (VAR_13 != VAR_19) {\n             goto error;\n      }\n#endif /* COMMENT_4 */\n\n      VAR_14 = (VAR_5->dP == NULL) || (mp_get_digit_count(VAR_5->dP) == 0);\n\n      if (VAR_14) {\n         /* COMMENT_16 */\n                                                                 \n                                                          \n            \n         if ((VAR_13 = mp_exptmod(VAR_6, VAR_5->d, VAR_5->N, VAR_6)) != VAR_19)                              { goto error; }\n      } else {\n         /* COMMENT_20 */\n         if ((VAR_13 = mp_exptmod(VAR_6, VAR_5->dP, VAR_5->p, VAR_7)) != VAR_19)                            { goto error; }\n\n         /* COMMENT_21 */\n         if ((VAR_13 = mp_exptmod(VAR_6, VAR_5->dQ, VAR_5->q, VAR_8)) != VAR_19)                            { goto error; }\n\n         /* COMMENT_22 */\n         if ((VAR_13 = mp_sub(VAR_7, VAR_8, VAR_6)) != VAR_19)                                           { goto error; }\n         if ((VAR_13 = mp_mulmod(VAR_6, VAR_5->qP, VAR_5->p, VAR_6)) != VAR_19)                              { goto error; }\n\n         /* COMMENT_23 */\n         if ((VAR_13 = mp_mul(VAR_6, VAR_5->q, VAR_6)) != VAR_19)                                          { goto error; }\n         if ((VAR_13 = mp_add(VAR_6, VAR_8, VAR_6)) != VAR_19)                                            { goto error; }\n      }\n\n      #ifdef VAR_9\n      /* COMMENT_24 */\n      VAR_13 = mp_mulmod( VAR_6, VAR_11, VAR_5->N, VAR_6);\n      if (VAR_13 != VAR_19) {\n             goto error;\n      }\n      #endif\n\n      #ifdef VAR_23\n      if (!VAR_14) {\n         if ((VAR_13 = mp_exptmod(VAR_6, VAR_5->e, VAR_5->N, VAR_7)) != VAR_19)                              { goto error; }\n         if ((VAR_13 = mp_read_unsigned_bin(VAR_8, (unsigned char *)VAR_0, (int)VAR_1)) != VAR_19)        { goto error; }\n         if (mp_cmp(VAR_7, VAR_8) != VAR_24)                                     { VAR_13 = VAR_25; goto error; }\n      }\n      #endif\n   } else {\n      /* COMMENT_11 */\n      if ((VAR_13 = mp_exptmod(VAR_6, VAR_5->e, VAR_5->N, VAR_6)) != VAR_19)                                { goto error; }\n   }\n\n   /* COMMENT_25 */\n   VAR_12 = (unsigned long)mp_unsigned_bin_size(VAR_5->N);\n   if (VAR_12 > *VAR_3) {\n      *VAR_3 = VAR_12;\n      VAR_13 = VAR_26;\n      goto error;\n   }\n\n   /* COMMENT_26 */\n   if (mp_unsigned_bin_size(VAR_6) > mp_unsigned_bin_size(VAR_5->N)) {\n      VAR_13 = VAR_25;\n      goto error;\n   }\n   *VAR_3 = VAR_12;\n\n   /* COMMENT_27 */\n   zeromem(VAR_2, VAR_12);\n   if ((VAR_13 = mp_to_unsigned_bin(VAR_6, VAR_2+(VAR_12-mp_unsigned_bin_size(VAR_6)))) != VAR_19)               { goto error; }\n\n   /* COMMENT_28 */\n   VAR_13 = VAR_19;\nVAR_27:\n   VAR_28(\n#ifdef VAR_9\n                  VAR_11, VAR_10,\n#endif /* COMMENT_4 */\n                             VAR_8, VAR_7, VAR_6, NULL);\n   return VAR_13;\n}",
  "func_graph_path_before": "OP-TEE/optee_os/c53ec7708e6f97fabc4a532a48d6099f1202d913/rsa_exptmod.c/vul/before/0.json",
  "func": "int rsa_exptmod(const unsigned char *in,   unsigned long inlen,\n                      unsigned char *out,  unsigned long *outlen, int which,\n                      rsa_key *key)\n{\n   void         *tmp, *tmpa, *tmpb;\n#ifdef LTC_RSA_BLINDING\n   void        *rnd, *rndi /* inverse of rnd */;\n#endif\n   unsigned long x;\n   int           err, no_crt;\n\n   LTC_ARGCHK(in     != NULL);\n   LTC_ARGCHK(out    != NULL);\n   LTC_ARGCHK(outlen != NULL);\n   LTC_ARGCHK(key    != NULL);\n  \n   /* is the key of the right type for the operation? */\n   if (which == PK_PRIVATE && (key->type != PK_PRIVATE)) {\n      return CRYPT_PK_NOT_PRIVATE;\n   }\n\n   /* must be a private or public operation */\n   if (which != PK_PRIVATE && which != PK_PUBLIC) {\n      return CRYPT_PK_INVALID_TYPE;\n   }\n\n   /* init and copy into tmp */\n   if ((err = mp_init_multi(&tmp, &tmpa, &tmpb,\n#ifdef LTC_RSA_BLINDING\n                                               &rnd, &rndi,\n#endif /* LTC_RSA_BLINDING */\n                                                           NULL)) != CRYPT_OK)\n        { return err; }\n   if ((err = mp_read_unsigned_bin(tmp, (unsigned char *)in, (int)inlen)) != CRYPT_OK)\n        { goto error; }\n\n   /* sanity check on the input */\n   if (mp_cmp(key->N, tmp) == LTC_MP_LT) {\n      err = CRYPT_PK_INVALID_SIZE;\n      goto error;\n   }\n\n   if (which == PK_PRIVATE) {\n#ifdef LTC_RSA_BLINDING\n      /* do blinding */\n      err = mp_rand(rnd, mp_get_digit_count(key->N));\n      if (err != CRYPT_OK) {\n             goto error;\n      }\n\n      /* rndi = 1/rnd mod N */\n      err = mp_invmod(rnd, key->N, rndi);\n      if (err != CRYPT_OK) {\n             goto error;\n      }\n\n      /* rnd = rnd^e */\n      err = mp_exptmod( rnd, key->e, key->N, rnd);\n      if (err != CRYPT_OK) {\n             goto error;\n      }\n\n      /* tmp = tmp*rnd mod N */\n      err = mp_mulmod( tmp, rnd, key->N, tmp);\n      if (err != CRYPT_OK) {\n             goto error;\n      }\n#endif /* LTC_RSA_BLINDING */\n\n      no_crt = (key->dP == NULL) || (mp_get_digit_count(key->dP) == 0);\n\n      if (no_crt) {\n         /*\n          * In case CRT optimization parameters are not provided,\n          * the private key is directly used to exptmod it\n          */\n         if ((err = mp_exptmod(tmp, key->d, key->N, tmp)) != CRYPT_OK)                              { goto error; }\n      } else {\n         /* tmpa = tmp^dP mod p */\n         if ((err = mp_exptmod(tmp, key->dP, key->p, tmpa)) != CRYPT_OK)                            { goto error; }\n\n         /* tmpb = tmp^dQ mod q */\n         if ((err = mp_exptmod(tmp, key->dQ, key->q, tmpb)) != CRYPT_OK)                            { goto error; }\n\n         /* tmp = (tmpa - tmpb) * qInv (mod p) */\n         if ((err = mp_sub(tmpa, tmpb, tmp)) != CRYPT_OK)                                           { goto error; }\n         if ((err = mp_mulmod(tmp, key->qP, key->p, tmp)) != CRYPT_OK)                              { goto error; }\n\n         /* tmp = tmpb + q * tmp */\n         if ((err = mp_mul(tmp, key->q, tmp)) != CRYPT_OK)                                          { goto error; }\n         if ((err = mp_add(tmp, tmpb, tmp)) != CRYPT_OK)                                            { goto error; }\n      }\n\n      #ifdef LTC_RSA_BLINDING\n      /* unblind */\n      err = mp_mulmod( tmp, rndi, key->N, tmp);\n      if (err != CRYPT_OK) {\n             goto error;\n      }\n      #endif\n\n      #ifdef LTC_RSA_CRT_HARDENING\n      if (!no_crt) {\n         if ((err = mp_exptmod(tmp, key->e, key->N, tmpa)) != CRYPT_OK)                              { goto error; }\n         if ((err = mp_read_unsigned_bin(tmpb, (unsigned char *)in, (int)inlen)) != CRYPT_OK)        { goto error; }\n         if (mp_cmp(tmpa, tmpb) != LTC_MP_EQ)                                     { err = CRYPT_ERROR; goto error; }\n      }\n      #endif\n   } else {\n      /* exptmod it */\n      if ((err = mp_exptmod(tmp, key->e, key->N, tmp)) != CRYPT_OK)                                { goto error; }\n   }\n\n   /* read it back */\n   x = (unsigned long)mp_unsigned_bin_size(key->N);\n   if (x > *outlen) {\n      *outlen = x;\n      err = CRYPT_BUFFER_OVERFLOW;\n      goto error;\n   }\n\n   /* this should never happen ... */\n   if (mp_unsigned_bin_size(tmp) > mp_unsigned_bin_size(key->N)) {\n      err = CRYPT_ERROR;\n      goto error;\n   }\n   *outlen = x;\n\n   /* convert it */\n   zeromem(out, x);\n   if ((err = mp_to_unsigned_bin(tmp, out+(x-mp_unsigned_bin_size(tmp)))) != CRYPT_OK)               { goto error; }\n\n   /* clean up and return */\n   err = CRYPT_OK;\nerror:\n   mp_clear_multi(\n#ifdef LTC_RSA_BLINDING\n                  rndi, rnd,\n#endif /* LTC_RSA_BLINDING */\n                             tmpb, tmpa, tmp, NULL);\n   return err;\n}",
  "abstract_func": "int rsa_exptmod(const unsigned char *VAR_0,   unsigned long VAR_1,\n                      unsigned char *VAR_2,  unsigned long *VAR_3, int VAR_4,\n                      rsa_key *VAR_5)\n{\n   void         *VAR_6, *VAR_7, *VAR_8;\n#ifdef VAR_9\n   void        *VAR_10, *VAR_11 /* COMMENT_0 */;\n#endif\n   unsigned long VAR_12;\n   int           VAR_13, VAR_14;\n\n   LTC_ARGCHK(VAR_0     != NULL);\n   LTC_ARGCHK(VAR_2    != NULL);\n   LTC_ARGCHK(VAR_3 != NULL);\n   LTC_ARGCHK(VAR_5    != NULL);\n  \n   /* COMMENT_1 */\n   if (VAR_4 == VAR_15 && (VAR_5->type != VAR_15)) {\n      return VAR_16;\n   }\n\n   /* COMMENT_2 */\n   if (VAR_4 != VAR_15 && VAR_4 != VAR_17) {\n      return VAR_18;\n   }\n\n   /* COMMENT_3 */\n   if ((VAR_13 = mp_init_multi(&VAR_6, &VAR_7, &VAR_8,\n#ifdef VAR_9\n                                               &VAR_10, &VAR_11,\n#endif /* COMMENT_4 */\n                                                           NULL)) != VAR_19)\n        { return VAR_13; }\n   if ((VAR_13 = mp_read_unsigned_bin(VAR_6, (unsigned char *)VAR_0, (int)VAR_1)) != VAR_19)\n        { goto error; }\n\n   /* COMMENT_5 */\n   if (mp_cmp(VAR_5->N, VAR_6) == VAR_20) {\n      VAR_13 = VAR_21;\n      goto error;\n   }\n\n   if (VAR_4 == VAR_15) {\n#ifdef VAR_9\n      /* COMMENT_6 */\n      VAR_13 = mp_rand(VAR_10, mp_get_digit_count(VAR_5->N));\n      if (VAR_13 != VAR_19) {\n             goto error;\n      }\n\n      /* COMMENT_7 */\n      VAR_13 = mp_invmod(VAR_10, VAR_5->N, VAR_11);\n      if (VAR_13 != VAR_19) {\n             goto error;\n      }\n\n      /* COMMENT_8 */\n      VAR_13 = mp_exptmod( VAR_10, VAR_5->e, VAR_5->N, VAR_10);\n      if (VAR_13 != VAR_19) {\n             goto error;\n      }\n\n      /* COMMENT_9 */\n      VAR_13 = mp_mulmod( VAR_6, VAR_10, VAR_5->N, VAR_6);\n      if (VAR_13 != VAR_19) {\n             goto error;\n      }\n#endif /* COMMENT_4 */\n\n      VAR_14 = (VAR_5->dP == NULL) || (mp_get_digit_count(VAR_5->dP) == 0);\n\n      if (VAR_14) {\n         /* COMMENT_10 */\n                                                                 \n                                                          \n            \n         if ((VAR_13 = mp_exptmod(VAR_6, VAR_5->d, VAR_5->N, VAR_6)) != VAR_19)                              { goto error; }\n      } else {\n         /* COMMENT_14 */\n         if ((VAR_13 = mp_exptmod(VAR_6, VAR_5->dP, VAR_5->p, VAR_7)) != VAR_19)                            { goto error; }\n\n         /* COMMENT_15 */\n         if ((VAR_13 = mp_exptmod(VAR_6, VAR_5->dQ, VAR_5->q, VAR_8)) != VAR_19)                            { goto error; }\n\n         /* COMMENT_16 */\n         if ((VAR_13 = mp_sub(VAR_7, VAR_8, VAR_6)) != VAR_19)                                           { goto error; }\n         if ((VAR_13 = mp_mulmod(VAR_6, VAR_5->qP, VAR_5->p, VAR_6)) != VAR_19)                              { goto error; }\n\n         /* COMMENT_17 */\n         if ((VAR_13 = mp_mul(VAR_6, VAR_5->q, VAR_6)) != VAR_19)                                          { goto error; }\n         if ((VAR_13 = mp_add(VAR_6, VAR_8, VAR_6)) != VAR_19)                                            { goto error; }\n      }\n\n      #ifdef VAR_9\n      /* COMMENT_18 */\n      VAR_13 = mp_mulmod( VAR_6, VAR_11, VAR_5->N, VAR_6);\n      if (VAR_13 != VAR_19) {\n             goto error;\n      }\n      #endif\n\n      #ifdef VAR_22\n      if (!VAR_14) {\n         if ((VAR_13 = mp_exptmod(VAR_6, VAR_5->e, VAR_5->N, VAR_7)) != VAR_19)                              { goto error; }\n         if ((VAR_13 = mp_read_unsigned_bin(VAR_8, (unsigned char *)VAR_0, (int)VAR_1)) != VAR_19)        { goto error; }\n         if (mp_cmp(VAR_7, VAR_8) != VAR_23)                                     { VAR_13 = VAR_24; goto error; }\n      }\n      #endif\n   } else {\n      /* COMMENT_19 */\n      if ((VAR_13 = mp_exptmod(VAR_6, VAR_5->e, VAR_5->N, VAR_6)) != VAR_19)                                { goto error; }\n   }\n\n   /* COMMENT_20 */\n   VAR_12 = (unsigned long)mp_unsigned_bin_size(VAR_5->N);\n   if (VAR_12 > *VAR_3) {\n      *VAR_3 = VAR_12;\n      VAR_13 = VAR_25;\n      goto error;\n   }\n\n   /* COMMENT_21 */\n   if (mp_unsigned_bin_size(VAR_6) > mp_unsigned_bin_size(VAR_5->N)) {\n      VAR_13 = VAR_24;\n      goto error;\n   }\n   *VAR_3 = VAR_12;\n\n   /* COMMENT_22 */\n   zeromem(VAR_2, VAR_12);\n   if ((VAR_13 = mp_to_unsigned_bin(VAR_6, VAR_2+(VAR_12-mp_unsigned_bin_size(VAR_6)))) != VAR_19)               { goto error; }\n\n   /* COMMENT_23 */\n   VAR_13 = VAR_19;\nVAR_26:\n   VAR_27(\n#ifdef VAR_9\n                  VAR_11, VAR_10,\n#endif /* COMMENT_4 */\n                             VAR_8, VAR_7, VAR_6, NULL);\n   return VAR_13;\n}",
  "func_graph_path": "OP-TEE/optee_os/c53ec7708e6f97fabc4a532a48d6099f1202d913/rsa_exptmod.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -40,21 +40,6 @@\n       goto error;\n    }\n \n-   /* are we using the private exponent and is the key optimized? */\n-#ifdef LTC_LINARO_FIX_RSAWITHOUTCRT\n-   if ((which == PK_PRIVATE) && (key->dP == NULL)) {\n-      /*\n-       * Fix when CRT optimization parameters are not there\n-       * In such a case, we directly use the private key\n-       */\n-      LTC_ARGCHK(key->dQ == NULL);\n-      LTC_ARGCHK(key->qP == NULL);\n-      LTC_ARGCHK(key->p  == NULL);\n-      LTC_ARGCHK(key->q  == NULL);\n-      /* exptmod it */\n-      if ((err = mp_exptmod(tmp, key->d, key->N, tmp)) != CRYPT_OK)                                { goto error; }\n-   } else\n-#endif\n    if (which == PK_PRIVATE) {\n #ifdef LTC_RSA_BLINDING\n       /* do blinding */",
  "diff_line_info": {
    "deleted_lines": [
      "   /* are we using the private exponent and is the key optimized? */",
      "#ifdef LTC_LINARO_FIX_RSAWITHOUTCRT",
      "   if ((which == PK_PRIVATE) && (key->dP == NULL)) {",
      "      /*",
      "       * Fix when CRT optimization parameters are not there",
      "       * In such a case, we directly use the private key",
      "       */",
      "      LTC_ARGCHK(key->dQ == NULL);",
      "      LTC_ARGCHK(key->qP == NULL);",
      "      LTC_ARGCHK(key->p  == NULL);",
      "      LTC_ARGCHK(key->q  == NULL);",
      "      /* exptmod it */",
      "      if ((err = mp_exptmod(tmp, key->d, key->N, tmp)) != CRYPT_OK)                                { goto error; }",
      "   } else",
      "#endif"
    ],
    "added_lines": []
  },
  "is_vul": true,
  "pr_url": "https://github.com/OP-TEE/optee_os/pull/1610",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/OP-TEE/optee_os/pull/1610: 403 Client Error: Forbidden for url: https://api.github.com/repos/OP-TEE/optee_os/pulls/1610",
  "Bug Filter": "Supporting & Non-Core Improvements",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "The commit involves removing a workaround for RSA handling, now handled by upstream. It's a code cleanup, not a direct security fix.\n\n**Final Classification:** Supporting & Non-Core Improvements; **Confidence:** 0.8"
}