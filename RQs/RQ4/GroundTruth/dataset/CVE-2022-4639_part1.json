{
  "cve_id": "CVE-2022-4639",
  "cwe_ids": [
    "CWE-134"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "yrutschle/sslh",
  "commit_msg": "fix possible format string exploit if packet dumping enabled\n\nSigned-off-by: Toni Uhlig <matzeton@googlemail.com>",
  "commit_hash": "b19f8a6046b080e4c2e28354a58556bb26040c6f",
  "git_url": "https://github.com/yrutschle/sslh/commit/b19f8a6046b080e4c2e28354a58556bb26040c6f",
  "file_path": "probe.c",
  "func_name": "hexdump",
  "func_before": "void hexdump(msg_info msg_info, const char *mem, unsigned int len)\n{\n    unsigned int i, j;\n    char str[10 + HEXDUMP_COLS * 4 + 2];\n    int c = 0; /* index in str */\n\n    for(i = 0; i < len + ((len % HEXDUMP_COLS) ? (HEXDUMP_COLS - len % HEXDUMP_COLS) : 0); i++)\n    {\n        /* print offset */\n        if(i % HEXDUMP_COLS == 0)\n            c += sprintf(&str[c], \"0x%06x: \", i);\n\n        /* print hex data */\n        if(i < len)\n            c += sprintf(&str[c], \"%02x \", 0xFF & mem[i]);\n        else /* end of block, just aligning for ASCII dump */\n            c+= sprintf(&str[c], \"   \");\n\n        /* print ASCII dump */\n        if(i % HEXDUMP_COLS == (HEXDUMP_COLS - 1)) {\n            for(j = i - (HEXDUMP_COLS - 1); j <= i; j++) {\n                if(j >= len) /* end of block, not really printing */\n                    str[c++] = ' ';\n                else if(isprint(mem[j])) /* printable char */\n                    str[c++] = 0xFF & mem[j];\n                else /* other char */\n                    str[c++] = '.';\n            }\n            str[c++] = '\\n';\n            str[c++] = 0;\n            print_message(msg_info, str);\n            c = 0;\n        }\n    }\n}",
  "abstract_func_before": "void hexdump(msg_info msg_info, const char *VAR_0, unsigned int VAR_1)\n{\n    unsigned int VAR_2, VAR_3;\n    char VAR_4[10 + VAR_5 * 4 + 2];\n    int VAR_6 = 0; /* COMMENT_0 */\n\n    for(VAR_2 = 0; VAR_2 < VAR_1 + ((VAR_1 % VAR_5) ? (VAR_5 - VAR_1 % VAR_5) : 0); VAR_2++)\n    {\n        /* COMMENT_1 */\n        if(VAR_2 % VAR_5 == 0)\n            VAR_6 += sprintf(&VAR_4[VAR_6], \"0x%06x: \", VAR_2);\n\n        /* COMMENT_2 */\n        if(VAR_2 < VAR_1)\n            VAR_6 += sprintf(&VAR_4[VAR_6], \"%02x \", 0xFF & VAR_0[VAR_2]);\n        else /* COMMENT_3 */\n            VAR_6+= sprintf(&VAR_4[VAR_6], \"   \");\n\n        /* COMMENT_4 */\n        if(VAR_2 % VAR_5 == (VAR_5 - 1)) {\n            for(VAR_3 = VAR_2 - (VAR_5 - 1); VAR_3 <= VAR_2; VAR_3++) {\n                if(VAR_3 >= VAR_1) /* COMMENT_5 */\n                    VAR_4[VAR_6++] = ' ';\n                else if(isprint(VAR_0[VAR_3])) /* COMMENT_6 */\n                    VAR_4[VAR_6++] = 0xFF & VAR_0[VAR_3];\n                else /* COMMENT_7 */\n                    VAR_4[VAR_6++] = '.';\n            }\n            VAR_4[VAR_6++] = '\\n';\n            VAR_4[VAR_6++] = 0;\n            print_message(msg_info, VAR_4);\n            VAR_6 = 0;\n        }\n    }\n}",
  "func_graph_path_before": "yrutschle/sslh/b19f8a6046b080e4c2e28354a58556bb26040c6f/probe.c/vul/before/0.json",
  "func": "void hexdump(msg_info msg_info, const char *mem, unsigned int len)\n{\n    unsigned int i, j;\n    char str[10 + HEXDUMP_COLS * 4 + 2];\n    int c = 0; /* index in str */\n\n    for(i = 0; i < len + ((len % HEXDUMP_COLS) ? (HEXDUMP_COLS - len % HEXDUMP_COLS) : 0); i++)\n    {\n        /* print offset */\n        if(i % HEXDUMP_COLS == 0)\n            c += sprintf(&str[c], \"0x%06x: \", i);\n\n        /* print hex data */\n        if(i < len)\n            c += sprintf(&str[c], \"%02x \", 0xFF & mem[i]);\n        else /* end of block, just aligning for ASCII dump */\n            c+= sprintf(&str[c], \"   \");\n\n        /* print ASCII dump */\n        if(i % HEXDUMP_COLS == (HEXDUMP_COLS - 1)) {\n            for(j = i - (HEXDUMP_COLS - 1); j <= i; j++) {\n                if(j >= len) /* end of block, not really printing */\n                    str[c++] = ' ';\n                else if(isprint(mem[j])) /* printable char */\n                    str[c++] = 0xFF & mem[j];\n                else /* other char */\n                    str[c++] = '.';\n            }\n            str[c++] = '\\n';\n            str[c++] = 0;\n            print_message(msg_info, \"%s\", str);\n            c = 0;\n        }\n    }\n}",
  "abstract_func": "void hexdump(msg_info msg_info, const char *VAR_0, unsigned int VAR_1)\n{\n    unsigned int VAR_2, VAR_3;\n    char VAR_4[10 + VAR_5 * 4 + 2];\n    int VAR_6 = 0; /* COMMENT_0 */\n\n    for(VAR_2 = 0; VAR_2 < VAR_1 + ((VAR_1 % VAR_5) ? (VAR_5 - VAR_1 % VAR_5) : 0); VAR_2++)\n    {\n        /* COMMENT_1 */\n        if(VAR_2 % VAR_5 == 0)\n            VAR_6 += sprintf(&VAR_4[VAR_6], \"0x%06x: \", VAR_2);\n\n        /* COMMENT_2 */\n        if(VAR_2 < VAR_1)\n            VAR_6 += sprintf(&VAR_4[VAR_6], \"%02x \", 0xFF & VAR_0[VAR_2]);\n        else /* COMMENT_3 */\n            VAR_6+= sprintf(&VAR_4[VAR_6], \"   \");\n\n        /* COMMENT_4 */\n        if(VAR_2 % VAR_5 == (VAR_5 - 1)) {\n            for(VAR_3 = VAR_2 - (VAR_5 - 1); VAR_3 <= VAR_2; VAR_3++) {\n                if(VAR_3 >= VAR_1) /* COMMENT_5 */\n                    VAR_4[VAR_6++] = ' ';\n                else if(isprint(VAR_0[VAR_3])) /* COMMENT_6 */\n                    VAR_4[VAR_6++] = 0xFF & VAR_0[VAR_3];\n                else /* COMMENT_7 */\n                    VAR_4[VAR_6++] = '.';\n            }\n            VAR_4[VAR_6++] = '\\n';\n            VAR_4[VAR_6++] = 0;\n            print_message(msg_info, \"%s\", VAR_4);\n            VAR_6 = 0;\n        }\n    }\n}",
  "func_graph_path": "yrutschle/sslh/b19f8a6046b080e4c2e28354a58556bb26040c6f/probe.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -28,7 +28,7 @@\n             }\n             str[c++] = '\\n';\n             str[c++] = 0;\n-            print_message(msg_info, str);\n+            print_message(msg_info, \"%s\", str);\n             c = 0;\n         }\n     }",
  "diff_line_info": {
    "deleted_lines": [
      "            print_message(msg_info, str);"
    ],
    "added_lines": [
      "            print_message(msg_info, \"%s\", str);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/yrutschle/sslh/pull/353",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/yrutschle/sslh/pull/353: 403 Client Error: Forbidden for url: https://api.github.com/repos/yrutschle/sslh/pulls/353",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0\n\nThe patch clearly addresses a security vulnerability by fixing a potential format string exploit, with the code changes aligning perfectly with the commit message and vulnerability description."
}