{
  "cve_id": "CVE-2023-33657",
  "cwe_ids": [
    "CWE-416"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "nanomq",
  "commit_msg": "* FIX [security] avoid data racing by clone retain msg",
  "commit_hash": "5f57ef45ccfd0f47d815eb62f5f2a619ba7d0633",
  "git_url": "https://github.com/nanomq/nanomq/commit/5f57ef45ccfd0f47d815eb62f5f2a619ba7d0633",
  "file_path": "nanomq/apps/broker.c",
  "func_name": "server_cb",
  "func_before": "void\nserver_cb(void *arg)\n{\n\tnano_work     *work = arg;\n\tnng_msg       *msg  = NULL;\n\tnng_msg       *smsg = NULL;\n\tint            rv;\n\n\tmqtt_msg_info *msg_info;\n\n\tswitch (work->state) {\n\tcase INIT:\n\t\t// log_debug(\"INIT ^^^^^^^^ ctx [%d] ^^^^^^^^ \\n\", work->ctx.id);\n\t\twork->state = RECV;\n\t\tif (work->proto == PROTO_MQTT_BROKER) {\n\t\t\tlog_debug(\"INIT ^^^^^^^^ ctx [%d] ^^^^^^^^ \\n\", work->ctx.id);\n\t\t\tnng_ctx_recv(work->ctx, work->aio);\n\t\t} else {\n\t\t\tlog_debug(\"INIT ^^^^^^^^ extra ctx [%d] ^^^^^^^^ \\n\", work->extra_ctx.id);\n\t\t\tnng_ctx_recv(work->extra_ctx, work->aio);\n\t\t}\n\t\tbreak;\n\tcase RECV:\n\t\tlog_debug(\"RECV  ^^^^ ctx%d ^^^^\\n\", work->ctx.id);\n\t\tif ((rv = nng_aio_result(work->aio)) != 0) {\n\t\t\tlog_warn(\"RECV nng aio result error: %d\", rv);\n\t\t\twork->state = RECV;\n\t\t\tif (work->proto == PROTO_MQTT_BROKER) {\n\t\t\t\tnng_ctx_recv(work->ctx, work->aio);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tlog_info(\"bridge connection closed with reason %d\\n\", rv);\n\t\t\t\tif (rv != NNG_ECONNSHUT) {\n\t\t\t\t\tnng_ctx_recv(work->extra_ctx, work->aio);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ((msg = nng_aio_get_msg(work->aio)) == NULL) {\n\t\t\tnng_fatal(\"RECV NULL MSG\", rv);\n\t\t}\n\t\tif (work->proto == PROTO_MQTT_BRIDGE) {\n\t\t\tuint8_t type;\n\t\t\ttype = nng_msg_get_type(msg);\n\t\t\tif (type == CMD_CONNACK) {\n\t\t\t\tlog_info(\"bridge client is connected!\");\n\t\t\t} else if (type != CMD_PUBLISH) {\n\t\t\t\t// only accept publish/CONNACK/DISCONNECT\n\t\t\t\t// msg from upstream\n\t\t\t\twork->state = RECV;\n\t\t\t\tnng_msg_free(msg);\n\t\t\t\tnng_ctx_recv(work->extra_ctx, work->aio);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t// clone conn_param every single time\n\t\t\t\tconn_param_clone(nng_msg_get_conn_param(msg));\n\t\t\t}\n\t\t} else if (work->proto == PROTO_HTTP_SERVER ||\n\t\t    work->proto == PROTO_AWS_BRIDGE) {\n\t\t\tnng_msg *decode_msg = NULL;\n\t\t\tif (decode_common_mqtt_msg(&decode_msg, msg) != 0 ||\n\t\t\t    nng_msg_get_type(decode_msg) != CMD_PUBLISH) {\n\t\t\t\tconn_param_free(nng_msg_get_conn_param(decode_msg));\n\t\t\t\twork->state = RECV;\n\t\t\t\tnng_ctx_recv(work->extra_ctx, work->aio);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmsg = decode_msg;\n\t\t\tnng_msg_set_cmd_type(msg, CMD_PUBLISH);\n\t\t\t// alloc conn_param every single time\n\t\t}\n\t\twork->msg       = msg;\n\t\twork->pid       = nng_msg_get_pipe(work->msg);\n\t\twork->cparam    = nng_msg_get_conn_param(work->msg);\n\t\twork->proto_ver = conn_param_get_protover(work->cparam);\n\t\twork->flag      = nng_msg_cmd_type(msg);\n\n\t\tif (work->flag == CMD_SUBSCRIBE) {\n\t\t\tsmsg = work->msg;\n\t\t\twork->msg_ret = NULL;\n\n\t\t\tif ((work->sub_pkt = nng_alloc(\n\t\t\t         sizeof(packet_subscribe))) == NULL)\n\t\t\t\tlog_error(\"nng_alloc\");\n\t\t\tmemset(work->sub_pkt, '\\0', sizeof(packet_subscribe));\n\n\t\t\tif ((rv = decode_sub_msg(work)) != 0 ||\n\t\t\t    (rv = sub_ctx_handle(work)) != 0) {\n\t\t\t\twork->code = rv;\n\t\t\t\tlog_error(\"sub_handler: [%d]\", rv);\n\t\t\t}\n\n\t\t\t// TODO not all codes needs to close the pipe\n\t\t\tif (work->code != SUCCESS) {\n\t\t\t\tif (work->msg_ret)\n\t\t\t\t\tcvector_free(work->msg_ret);\n\t\t\t\tif (work->sub_pkt)\n\t\t\t\t\tsub_pkt_free(work->sub_pkt);\n\t\t\t\t// free conn_param due to clone in protocol layer\n\t\t\t\tconn_param_free(work->cparam);\n\n\t\t\t\twork->state = CLOSE;\n\t\t\t\tnng_aio_finish(work->aio, 0);\n\t\t\t\t// TODO break or return?\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// TODO Error handling\n\t\t\tif (0 != (rv = encode_suback_msg(smsg, work)))\n\t\t\t\tlog_error(\"error in encode suback: [%d]\", rv);\n\n\t\t\tsub_pkt_free(work->sub_pkt);\n\t\t\t// handle retain (Retain flag handled in npipe)\n\t\t\twork->msg = NULL;\n\t\t\tif (work->msg_ret) {\n\t\t\t\tlog_debug(\"retain msg [%p] size [%ld] \\n\",\n\t\t\t\t    work->msg_ret,\n\t\t\t\t    cvector_size(work->msg_ret));\n\t\t\t\tfor (int i = 0;\n\t\t\t\t     i < cvector_size(work->msg_ret) &&\n\t\t\t\t     check_msg_exp(work->msg_ret[i],\n\t\t\t\t         nng_mqtt_msg_get_publish_property(\n\t\t\t\t             work->msg_ret[i]));\n\t\t\t\t     i++) {\n\t\t\t\t\tnng_msg *m = work->msg_ret[i];\n\t\t\t\t\tif (!work->config->sqlite.enable) {\n\t\t\t\t\t\t// Unnecessary to clone msg if\n\t\t\t\t\t\t// alloced from sqlite db\n\t\t\t\t\t\tnng_msg_clone(m);\n\t\t\t\t\t}\n\t\t\t\t\twork->msg = m;\n\t\t\t\t\tnng_aio_set_msg(work->aio, work->msg);\n\t\t\t\t\tnng_aio_set_prov_data(work->aio, &work->pid.id);\n\t\t\t\t\tnng_ctx_send(work->ctx, work->aio);\n\t\t\t\t}\n\t\t\t\tcvector_free(work->msg_ret);\n\t\t\t}\n\t\t\tnng_msg_set_cmd_type(smsg, CMD_SUBACK);\n\t\t\tnng_aio_set_prov_data(work->aio, &work->pid.id);\n\t\t\tnng_aio_set_msg(work->aio, smsg);\n\t\t\twork->msg   = NULL;\n\t\t\twork->state = SEND;\n\t\t\tnng_ctx_send(work->ctx, work->aio);\n\t\t\tsmsg = NULL;\n\t\t\tnng_aio_finish(work->aio, 0);\n\t\t\t// free conn_param in SEND state\n\t\t\tbreak;\n\t\t} else if (work->flag == CMD_UNSUBSCRIBE) {\n\t\t\tsmsg = work->msg;\n\t\t\tif ((work->unsub_pkt = nng_alloc(\n\t\t\t         sizeof(packet_unsubscribe))) == NULL)\n\t\t\t\tlog_error(\"nng_alloc\");\n\n\t\t\tif ((rv = decode_unsub_msg(work)) != 0 ||\n\t\t\t    (rv = unsub_ctx_handle(work)) != 0) {\n\t\t\t\tlog_error(\"unsub_handler [%d]\", rv);\n\t\t\t}\n\n\t\t\tif (0 != (rv = encode_unsuback_msg(smsg, work)))\n\t\t\t\tlog_error(\"in unsuback [%d]\", rv);\n\n\t\t\t// free unsub_pkt\n\t\t\tunsub_pkt_free(work->unsub_pkt);\n\t\t\tnng_aio_set_prov_data(work->aio, &work->pid.id);\n\t\t\tnng_aio_set_msg(work->aio, work->msg);\n\t\t\twork->msg   = NULL;\n\t\t\twork->state = SEND;\n\t\t\tnng_ctx_send(work->ctx, work->aio);\n\t\t\tsmsg = NULL;\n\t\t\tnng_aio_finish(work->aio, 0);\n\t\t\t//free conn_param in SEND state\n\t\t\tbreak;\n\t\t} else if (work->flag == CMD_PUBLISH) {\n\t\t\t// Set V4/V5 flag for publish msg\n\t\t\tif (work->proto_ver == 5) {\n\t\t\t\tnng_msg_set_cmd_type(msg, CMD_PUBLISH_V5);\n\t\t\t} else {\n\t\t\t\tnng_msg_set_cmd_type(msg, CMD_PUBLISH);\n\t\t\t}\n\t\t\twork->code = handle_pub(\n\t\t\t    work, work->pipe_ct, work->proto_ver, false);\n\t\t\tif (work->proto == PROTO_HTTP_SERVER ||\n\t\t\t    work->proto == PROTO_AWS_BRIDGE) {\n\t\t\t\tnng_msg *rep_msg;\n\t\t\t\t// TODO carry code with msg\n\t\t\t\tnng_msg_alloc(&rep_msg, 0);\n\t\t\t\tnng_aio_set_msg(work->aio, rep_msg);\n\t\t\t\tif (work->code == SUCCESS)\n\t\t\t\t\twork->state = WAIT;\n\t\t\t\telse\n\t\t\t\t\twork->state = SEND;\n\t\t\t\tnng_ctx_send(work->extra_ctx, work->aio);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (work->code != SUCCESS) {\n\t\t\t\t//what if extra ctx brings a wrong msg?\n\t\t\t\tif (work->proto != PROTO_MQTT_BROKER) {\n\t\t\t\t\twork->state = SEND;\n\t\t\t\t\tnng_aio_finish(work->aio, 0);\n\t\t\t\t\t// break or return?\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\twork->state = CLOSE;\n\t\t\t\tfree_pub_packet(work->pub_packet);\n\t\t\t\twork->pub_packet = NULL;\n\t\t\t\tcvector_free(work->pipe_ct->msg_infos);\n\t\t\t\t// free conn_param due to clone in protocol layer\n\t\t\t\tconn_param_free(work->cparam);\n\t\t\t\tnng_aio_finish(work->aio, 0);\n\t\t\t\t// break or return?\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (work->flag == CMD_CONNACK) {\n\t\t\tuint8_t *body        = nng_msg_body(work->msg);\n\t\t\tuint8_t  reason_code = *(body + 1);\n\t\t\tif (work->proto == PROTO_MQTT_BROKER) {\n\t\t\t\t// Return CONNACK to clients of broker\n\t\t\t\tnng_aio_set_prov_data(work->aio, &work->pid.id);\n\t\t\t\t// clone for sending connect event notification\n\t\t\t\tnng_msg_clone(work->msg);\n\t\t\t\tnng_aio_set_msg(work->aio, work->msg);\n\t\t\t\tnng_ctx_send(work->ctx, work->aio);\n\t\t\t}\n\t\t\tsmsg = nano_msg_notify_connect(work->cparam, reason_code);\n\t\t\twebhook_entry(work, reason_code);\n\t\t\t// Set V4/V5 flag for publish notify msg\n\t\t\tnng_msg_set_cmd_type(smsg, CMD_PUBLISH);\n\t\t\twork->flag = CMD_PUBLISH;\n\t\t\tnng_msg_free(work->msg);\n\t\t\twork->msg = smsg;\n\t\t\thandle_pub(work, work->pipe_ct,\n\t\t\t    MQTT_PROTOCOL_VERSION_v311, true);\n\t\t\t// remember to free conn_param in WAIT \n\t\t\t// due to clone in protocol layer\n\t\t} else if (work->flag == CMD_DISCONNECT_EV) {\n\t\t\t// Now v4 as default/send V5 notify msg?\n\t\t\twebhook_entry(work, 0);\n\t\t\tnng_msg_set_cmd_type(msg, CMD_PUBLISH);\n\t\t\twork->flag = CMD_PUBLISH;\n\t\t\thandle_pub(work, work->pipe_ct,\n\t\t\t    MQTT_PROTOCOL_VERSION_v311, true);\n\t\t\t// TODO set reason code\n\t\t\t// uint8_t *payload = nng_msg_payload_ptr(work->msg);\n\t\t\t// uint8_t reason_code = *(payload+16);\n\t\t\t// free client ctx\n\t\t\tif (dbhash_check_id(work->pid.id)) {\n\t\t\t\tdestroy_sub_client(work->pid.id, work->db);\n\t\t\t}\n\t\t\tif (conn_param_get_will_flag(work->cparam) == 0 ||\n\t\t\t    !conn_param_get_will_topic(work->cparam) ||\n\t\t\t    !conn_param_get_will_msg(work->cparam)) {\n\t\t\t\t// no will msg - free the cp\n\t\t\t\tconn_param_free(work->cparam);\n\t\t\t} else {\n\t\t\t\t// set to END to send will msg\n\t\t\t\t// TBD: relay last will msg for bridging client?\n\t\t\t\twork->state = END;\n\t\t\t\t// leave cp for will msg\n\t\t\t\tnng_aio_finish(work->aio, 0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\twork->state = WAIT;\n\t\tnng_aio_finish(work->aio, 0);\n\t\tbreak;\n\tcase WAIT:\n\t\t// do not access to cparam\n\t\tlog_debug(\"WAIT ^^^^ ctx%d ^^^^\", work->ctx.id);\n\t\tif (nng_msg_get_type(work->msg) == CMD_PUBLISH) {\n\t\t\tif ((rv = nng_aio_result(work->aio)) != 0) {\n\t\t\t\tlog_error(\"WAIT nng aio result error: %d\", rv);\n\t\t\t\tnng_fatal(\"WAIT nng_ctx_recv/send\", rv);\n\t\t\t}\n\t\t\tsmsg      = work->msg; // reuse the same msg\n\t\t\tcvector(mqtt_msg_info) msg_infos;\n\t\t\tmsg_infos = work->pipe_ct->msg_infos;\n\n\t\t\tlog_trace(\"total pipes: %ld\", cvector_size(msg_infos));\n\t\t\tif (cvector_size(msg_infos))\n\t\t\t\tif (encode_pub_message(smsg, work, PUBLISH))\n\t\t\t\t\tfor (int i = 0; i < cvector_size(msg_infos) && rv== 0; ++i) {\n\t\t\t\t\t\tmsg_info = &msg_infos[i];\n\t\t\t\t\t\tnng_msg_clone(smsg);\n\t\t\t\t\t\twork->pid.id = msg_info->pipe;\n\t\t\t\t\t\tnng_aio_set_prov_data(work->aio, &work->pid.id);\n\t\t\t\t\t\twork->msg = smsg;\n\t\t\t\t\t\tnng_aio_set_msg(work->aio, work->msg);\n\t\t\t\t\t\tnng_ctx_send(work->ctx, work->aio);\n\t\t\t\t\t}\n\t\t\twork->msg = smsg;\n\n\t\t\t// bridge logic first\n\t\t\tif (work->config->bridge_mode) {\n\t\t\t\tbridge_handler(work);\n#if defined(SUPP_AWS_BRIDGE)\n\t\t\t\taws_bridge_forward(work);\n#endif\n\t\t\t}\n\t\t\t//check webhook & rule engine\n\t\t\tconf_web_hook *hook_conf   = &(work->config->web_hook);\n\t\t\tuint8_t rule_opt = RULE_ENG_OFF;\n#if defined(SUPP_RULE_ENGINE)\n\t\t\trule_opt = work->config->rule_eng.option;\n#endif\n\t\t\tif (hook_conf->enable || rule_opt != RULE_ENG_OFF) {\n\t\t\t\twork->state = SEND;\n\t\t\t\tnng_aio_finish(work->aio, 0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnng_msg_free(work->msg);\n\t\t\tsmsg = NULL;\n\t\t\twork->msg = NULL;\n\t\t\t// free conn_param due to clone in protocol layer\n\t\t\tconn_param_free(work->cparam);\n\t\t\tfree_pub_packet(work->pub_packet);\n\t\t\twork->pub_packet = NULL;\n\t\t\tcvector_free(msg_infos);\n\t\t\twork->pipe_ct->msg_infos = NULL;\n\t\t\tinit_pipe_content(work->pipe_ct);\n\t\t\twork->state = RECV;\n\t\t\tif (work->proto != PROTO_MQTT_BROKER) {\n\t\t\t\tnng_ctx_recv(work->extra_ctx, work->aio);\n\t\t\t} else {\n\t\t\t\tnng_ctx_recv(work->ctx, work->aio);\n\t\t\t}\n\t\t} else if (nng_msg_cmd_type(work->msg) == CMD_PUBACK ||\n\t\t    nng_msg_cmd_type(work->msg) == CMD_PUBREL ||\n\t\t    nng_msg_cmd_type(work->msg) == CMD_PUBCOMP) {\n\t\t\tnng_msg_free(work->msg);\n\t\t\twork->msg   = NULL;\n\t\t\twork->state = RECV;\n\t\t\tnng_ctx_recv(work->ctx, work->aio);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tlog_debug(\"broker has nothing to do\");\n\t\t\tif (work->msg != NULL)\n\t\t\t\tnng_msg_free(work->msg);\n\t\t\twork->msg   = NULL;\n\t\t\twork->state = RECV;\n\t\t\tnng_ctx_recv(work->ctx, work->aio);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SEND:\n\t\tlog_debug(\"SEND ^^^^ ctx%d ^^^^\", work->ctx.id);\n#if defined(SUPP_RULE_ENGINE)\n\t\tif (work->flag == CMD_PUBLISH && work->config->rule_eng.option != RULE_ENG_OFF) {\n\t\t\trule_engine_insert_sql(work);\n\t\t}\n#endif\n\t\t// webhook here\n\t\twebhook_entry(work, 0);\n\n\t\tif (NULL != work->msg) {\n\t\t\tnng_msg_free(work->msg);\n\t\t\twork->msg = NULL;\n\t\t}\n\t\tif ((rv = nng_aio_result(work->aio)) != 0) {\n\t\t\tnng_fatal(\"SEND nng_ctx_send\", rv);\n\t\t}\n\t\tif (work->pub_packet != NULL) {\n\t\t\tfree_pub_packet(work->pub_packet);\n\t\t\twork->pub_packet = NULL;\n\t\t}\n\t\tif (work->pipe_ct->msg_infos != NULL) {\n\t\t\tcvector_free(work->pipe_ct->msg_infos);\n\t\t\twork->pipe_ct->msg_infos = NULL;\n\t\t\tinit_pipe_content(work->pipe_ct);\n\t\t}\n\t\t// free conn_param due to clone in protocol layer\n\t\tconn_param_free(work->cparam);\n\t\twork->state = RECV;\n\t\twork->flag  = 0;\n\t\tif (work->proto == PROTO_MQTT_BROKER) {\n\t\t\tnng_ctx_recv(work->ctx, work->aio);\n\t\t} else{\n\t\t\tnng_ctx_recv(work->extra_ctx, work->aio);\n\t\t}\n\t\tbreak;\n\tcase END:\n\t\tlog_debug(\"END ^^^^ ctx%d ^^^^ \", work->ctx.id);\n\t\tif (nng_msg_get_type(work->msg) == CMD_PUBLISH) {\n\t\t\tif ((rv = nng_aio_result(work->aio)) != 0) {\n\t\t\t\tlog_error(\"WAIT nng aio result error: %d\", rv);\n\t\t\t\tnng_fatal(\"WAIT nng_ctx_recv/send\", rv);\n\t\t\t}\n\t\t\tsmsg      = work->msg; // reuse the same msg\n\t\t\twork->msg = NULL;\n\n\t\t\tcvector(mqtt_msg_info) msg_infos;\n\t\t\tmsg_infos = work->pipe_ct->msg_infos;\n\n\t\t\tlog_debug(\"total pipes: %ld\", cvector_size(msg_infos));\n\t\t\t//TODO encode abstract msg only\n\t\t\tif (cvector_size(msg_infos))\n\t\t\t\tif (encode_pub_message(smsg, work, PUBLISH))\n\t\t\t\t\tfor (int i=0; i<cvector_size(msg_infos); ++i) {\n\t\t\t\t\t\tmsg_info = &msg_infos[i];\n\t\t\t\t\t\tnng_msg_clone(smsg);\n\t\t\t\t\t\twork->pid.id = msg_info->pipe;\n\t\t\t\t\t\tnng_aio_set_prov_data(work->aio, &work->pid.id);\n\t\t\t\t\t\twork->msg = smsg;\n\t\t\t\t\t\tnng_aio_set_msg(work->aio, work->msg);\n\t\t\t\t\t\tnng_ctx_send(work->ctx, work->aio);\n\t\t\t\t\t}\n\t\t\twebhook_entry(work, 0);\n\t\t\tnng_msg_free(smsg);\n\t\t\tsmsg = NULL;\n\t\t\twork->msg = NULL;\n\t\t\tfree_pub_packet(work->pub_packet);\n\t\t\twork->pub_packet = NULL;\n\t\t\tcvector_free(work->pipe_ct->msg_infos);\n\t\t\twork->pipe_ct->msg_infos = NULL;\n\t\t\tinit_pipe_content(work->pipe_ct);\n\n\t\t\t// processing will msg\n\t\t\tif (conn_param_get_will_flag(work->cparam) &&\n\t\t\t    (msg = nano_pubmsg_composer(&msg,\n\t\t\t         conn_param_get_will_retain(work->cparam),\n\t\t\t         conn_param_get_will_qos(work->cparam),\n\t\t\t         (mqtt_string *) conn_param_get_will_msg(\n\t\t\t             work->cparam),\n\t\t\t         (mqtt_string *) conn_param_get_will_topic(\n\t\t\t             work->cparam),\n\t\t\t         conn_param_get_protover(work->cparam),\n\t\t\t         nng_clock())) != NULL) {\n\t\t\t\twork->msg = msg;\n\t\t\t\twork->flag = CMD_PUBLISH;\n\t\t\t\t// Set V4/V5 flag for publish msg\n\t\t\t\tif (conn_param_get_protover(work->cparam) == 5) {\n\t\t\t\t\tproperty *will_property =\n\t\t\t\t\t    conn_param_get_will_property(\n\t\t\t\t\t        work->cparam);\n\t\t\t\t\tnng_msg_set_cmd_type(\n\t\t\t\t\t    msg, CMD_PUBLISH_V5);\n\t\t\t\t\thandle_pub(work, work->pipe_ct,\n\t\t\t\t\t    MQTT_PROTOCOL_VERSION_v5, false);\n\t\t\t\t\twork->pub_packet->var_header.publish\n\t\t\t\t\t    .properties = property_pub_by_will(\n\t\t\t\t\t    will_property);\n\t\t\t\t\twork->pub_packet->var_header.publish\n\t\t\t\t\t    .prop_len = get_properties_len(\n\t\t\t\t\t    work->pub_packet->var_header\n\t\t\t\t\t        .publish.properties);\n\t\t\t\t} else {\n\t\t\t\t\tnng_msg_set_cmd_type(msg, CMD_PUBLISH);\n\t\t\t\t\thandle_pub(work, work->pipe_ct,\n\t\t\t\t\t    MQTT_PROTOCOL_VERSION_v311, false);\n\t\t\t\t}\n\t\t\t\twork->state = WAIT;\n\t\t\t\tnng_aio_finish(work->aio, 0);\n\t\t\t} else {\n\t\t\t\t// free Conn_param once more in case invalid last-will msg\n\t\t\t\tconn_param_free(work->cparam);\n\t\t\t\tif (work->msg != NULL)\n\t\t\t\t\tnng_msg_free(work->msg);\n\t\t\t\twork->msg = NULL;\n\t\t\t\twork->state = RECV;\n\t\t\t\tif (work->proto == PROTO_MQTT_BROKER) {\n\t\t\t\t\tnng_ctx_recv(work->ctx, work->aio);\n\t\t\t\t} else {\n\t\t\t\t\tnng_ctx_recv(work->extra_ctx, work->aio);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconn_param_free(work->cparam);\n\t\tbreak;\n\tcase CLOSE:\n\t\tlog_debug(\" CLOSE ^^^^ ctx%d ^^^^\", work->ctx.id);\n\t\tsmsg = nano_dismsg_composer(work->code, NULL, NULL, NULL);\n\t\tnng_msg_free(work->msg);\n\t\twork->msg = smsg;\n\t\t// compose a disconnect msg\n\t\tnng_aio_set_prov_data(work->aio, &work->pid.id);\n\t\t// clone for sending connect event notification\n\t\tnng_aio_set_msg(work->aio, work->msg);\n\t\tnng_ctx_send(work->ctx, work->aio); // send connack\n\n\t\t// clear reason code\n\t\twork->code = SUCCESS;\n\t\twork->state = RECV;\n\t\tnng_ctx_recv(work->ctx, work->aio);\n\t\tbreak;\n\tdefault:\n\t\tnng_fatal(\"bad state!\", NNG_ESTATE);\n\t\tbreak;\n\t}\n}",
  "abstract_func_before": "void\nserver_cb(void *VAR_0)\n{\n\tnano_work     *VAR_1 = VAR_0;\n\tnng_msg       *VAR_2  = NULL;\n\tnng_msg       *VAR_3 = NULL;\n\tint            VAR_4;\n\n\tmqtt_msg_info *VAR_5;\n\n\tswitch (VAR_1->state) {\n\tcase VAR_6:\n\t\t/* COMMENT_0 */\n\t\tVAR_1->state = VAR_7;\n\t\tif (VAR_1->proto == VAR_8) {\n\t\t\tlog_debug(\"INIT ^^^^^^^^ ctx [%d] ^^^^^^^^ \\n\", VAR_1->ctx.id);\n\t\t\tnng_ctx_recv(VAR_1->ctx, VAR_1->aio);\n\t\t} else {\n\t\t\tlog_debug(\"INIT ^^^^^^^^ extra ctx [%d] ^^^^^^^^ \\n\", VAR_1->extra_ctx.id);\n\t\t\tnng_ctx_recv(VAR_1->extra_ctx, VAR_1->aio);\n\t\t}\n\t\tbreak;\n\tcase VAR_7:\n\t\tlog_debug(\"RECV  ^^^^ ctx%d ^^^^\\n\", VAR_1->ctx.id);\n\t\tif ((VAR_4 = nng_aio_result(VAR_1->aio)) != 0) {\n\t\t\tlog_warn(\"RECV nng aio result error: %d\", VAR_4);\n\t\t\tVAR_1->state = VAR_7;\n\t\t\tif (VAR_1->proto == VAR_8) {\n\t\t\t\tnng_ctx_recv(VAR_1->ctx, VAR_1->aio);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tlog_info(\"bridge connection closed with reason %d\\n\", VAR_4);\n\t\t\t\tif (VAR_4 != VAR_9) {\n\t\t\t\t\tnng_ctx_recv(VAR_1->extra_ctx, VAR_1->aio);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ((VAR_2 = nng_aio_get_msg(VAR_1->aio)) == NULL) {\n\t\t\tnng_fatal(\"RECV NULL MSG\", VAR_4);\n\t\t}\n\t\tif (VAR_1->proto == VAR_10) {\n\t\t\tuint8_t VAR_11;\n\t\t\tVAR_11 = nng_msg_get_type(VAR_2);\n\t\t\tif (VAR_11 == VAR_12) {\n\t\t\t\tlog_info(\"bridge client is connected!\");\n\t\t\t} else if (VAR_11 != VAR_13) {\n\t\t\t\t/* COMMENT_1 */\n\t\t\t\t/* COMMENT_2 */\n\t\t\t\tVAR_1->state = VAR_7;\n\t\t\t\tnng_msg_free(VAR_2);\n\t\t\t\tnng_ctx_recv(VAR_1->extra_ctx, VAR_1->aio);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t/* COMMENT_3 */\n\t\t\t\tconn_param_clone(nng_msg_get_conn_param(VAR_2));\n\t\t\t}\n\t\t} else if (VAR_1->proto == VAR_14 ||\n\t\t    VAR_1->proto == VAR_15) {\n\t\t\tnng_msg *VAR_16 = NULL;\n\t\t\tif (decode_common_mqtt_msg(&VAR_16, VAR_2) != 0 ||\n\t\t\t    nng_msg_get_type(VAR_16) != VAR_13) {\n\t\t\t\tconn_param_free(nng_msg_get_conn_param(VAR_16));\n\t\t\t\tVAR_1->state = VAR_7;\n\t\t\t\tnng_ctx_recv(VAR_1->extra_ctx, VAR_1->aio);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tVAR_2 = VAR_16;\n\t\t\tnng_msg_set_cmd_type(VAR_2, VAR_13);\n\t\t\t/* COMMENT_4 */\n\t\t}\n\t\tVAR_1->msg       = VAR_2;\n\t\tVAR_1->pid       = nng_msg_get_pipe(VAR_1->msg);\n\t\tVAR_1->cparam    = nng_msg_get_conn_param(VAR_1->msg);\n\t\tVAR_1->proto_ver = conn_param_get_protover(VAR_1->cparam);\n\t\tVAR_1->flag      = nng_msg_cmd_type(VAR_2);\n\n\t\tif (VAR_1->flag == VAR_17) {\n\t\t\tVAR_3 = VAR_1->msg;\n\t\t\tVAR_1->msg_ret = NULL;\n\n\t\t\tif ((VAR_1->sub_pkt = nng_alloc(\n\t\t\t         sizeof(VAR_18))) == NULL)\n\t\t\t\tlog_error(\"nng_alloc\");\n\t\t\tmemset(VAR_1->sub_pkt, '\\0', sizeof(VAR_18));\n\n\t\t\tif ((VAR_4 = decode_sub_msg(VAR_1)) != 0 ||\n\t\t\t    (VAR_4 = sub_ctx_handle(VAR_1)) != 0) {\n\t\t\t\tVAR_1->code = VAR_4;\n\t\t\t\tlog_error(\"sub_handler: [%d]\", VAR_4);\n\t\t\t}\n\n\t\t\t/* COMMENT_5 */\n\t\t\tif (VAR_1->code != VAR_19) {\n\t\t\t\tif (VAR_1->msg_ret)\n\t\t\t\t\tcvector_free(VAR_1->msg_ret);\n\t\t\t\tif (VAR_1->sub_pkt)\n\t\t\t\t\tsub_pkt_free(VAR_1->sub_pkt);\n\t\t\t\t/* COMMENT_6 */\n\t\t\t\tconn_param_free(VAR_1->cparam);\n\n\t\t\t\tVAR_1->state = VAR_20;\n\t\t\t\tnng_aio_finish(VAR_1->aio, 0);\n\t\t\t\t/* COMMENT_7 */\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* COMMENT_8 */\n\t\t\tif (0 != (VAR_4 = encode_suback_msg(VAR_3, VAR_1)))\n\t\t\t\tlog_error(\"error in encode suback: [%d]\", VAR_4);\n\n\t\t\tsub_pkt_free(VAR_1->sub_pkt);\n\t\t\t/* COMMENT_9 */\n\t\t\tVAR_1->msg = NULL;\n\t\t\tif (VAR_1->msg_ret) {\n\t\t\t\tlog_debug(\"retain msg [%p] size [%ld] \\n\",\n\t\t\t\t    VAR_1->msg_ret,\n\t\t\t\t    cvector_size(VAR_1->msg_ret));\n\t\t\t\tfor (int VAR_21 = 0;\n\t\t\t\t     VAR_21 < cvector_size(VAR_1->msg_ret) &&\n\t\t\t\t     check_msg_exp(VAR_1->msg_ret[VAR_21],\n\t\t\t\t         nng_mqtt_msg_get_publish_property(\n\t\t\t\t             VAR_1->msg_ret[VAR_21]));\n\t\t\t\t     VAR_21++) {\n\t\t\t\t\tnng_msg *VAR_22 = VAR_1->msg_ret[VAR_21];\n\t\t\t\t\tif (!VAR_1->config->sqlite.enable) {\n\t\t\t\t\t\t/* COMMENT_10 */\n\t\t\t\t\t\t/* COMMENT_11 */\n\t\t\t\t\t\tnng_msg_clone(VAR_22);\n\t\t\t\t\t}\n\t\t\t\t\tVAR_1->msg = VAR_22;\n\t\t\t\t\tnng_aio_set_msg(VAR_1->aio, VAR_1->msg);\n\t\t\t\t\tnng_aio_set_prov_data(VAR_1->aio, &VAR_1->pid.id);\n\t\t\t\t\tnng_ctx_send(VAR_1->ctx, VAR_1->aio);\n\t\t\t\t}\n\t\t\t\tcvector_free(VAR_1->msg_ret);\n\t\t\t}\n\t\t\tnng_msg_set_cmd_type(VAR_3, VAR_23);\n\t\t\tnng_aio_set_prov_data(VAR_1->aio, &VAR_1->pid.id);\n\t\t\tnng_aio_set_msg(VAR_1->aio, VAR_3);\n\t\t\tVAR_1->msg   = NULL;\n\t\t\tVAR_1->state = VAR_24;\n\t\t\tnng_ctx_send(VAR_1->ctx, VAR_1->aio);\n\t\t\tVAR_3 = NULL;\n\t\t\tnng_aio_finish(VAR_1->aio, 0);\n\t\t\t/* COMMENT_12 */\n\t\t\tbreak;\n\t\t} else if (VAR_1->flag == VAR_25) {\n\t\t\tVAR_3 = VAR_1->msg;\n\t\t\tif ((VAR_1->unsub_pkt = nng_alloc(\n\t\t\t         sizeof(VAR_26))) == NULL)\n\t\t\t\tlog_error(\"nng_alloc\");\n\n\t\t\tif ((VAR_4 = decode_unsub_msg(VAR_1)) != 0 ||\n\t\t\t    (VAR_4 = unsub_ctx_handle(VAR_1)) != 0) {\n\t\t\t\tlog_error(\"unsub_handler [%d]\", VAR_4);\n\t\t\t}\n\n\t\t\tif (0 != (VAR_4 = encode_unsuback_msg(VAR_3, VAR_1)))\n\t\t\t\tlog_error(\"in unsuback [%d]\", VAR_4);\n\n\t\t\t/* COMMENT_13 */\n\t\t\tunsub_pkt_free(VAR_1->unsub_pkt);\n\t\t\tnng_aio_set_prov_data(VAR_1->aio, &VAR_1->pid.id);\n\t\t\tnng_aio_set_msg(VAR_1->aio, VAR_1->msg);\n\t\t\tVAR_1->msg   = NULL;\n\t\t\tVAR_1->state = VAR_24;\n\t\t\tnng_ctx_send(VAR_1->ctx, VAR_1->aio);\n\t\t\tVAR_3 = NULL;\n\t\t\tnng_aio_finish(VAR_1->aio, 0);\n\t\t\t/* COMMENT_14 */\n\t\t\tbreak;\n\t\t} else if (VAR_1->flag == VAR_13) {\n\t\t\t/* COMMENT_15 */\n\t\t\tif (VAR_1->proto_ver == 5) {\n\t\t\t\tnng_msg_set_cmd_type(VAR_2, VAR_27);\n\t\t\t} else {\n\t\t\t\tnng_msg_set_cmd_type(VAR_2, VAR_13);\n\t\t\t}\n\t\t\tVAR_1->code = handle_pub(\n\t\t\t    VAR_1, VAR_1->pipe_ct, VAR_1->proto_ver, false);\n\t\t\tif (VAR_1->proto == VAR_14 ||\n\t\t\t    VAR_1->proto == VAR_15) {\n\t\t\t\tnng_msg *VAR_28;\n\t\t\t\t/* COMMENT_16 */\n\t\t\t\tnng_msg_alloc(&VAR_28, 0);\n\t\t\t\tnng_aio_set_msg(VAR_1->aio, VAR_28);\n\t\t\t\tif (VAR_1->code == VAR_19)\n\t\t\t\t\tVAR_1->state = VAR_29;\n\t\t\t\telse\n\t\t\t\t\tVAR_1->state = VAR_24;\n\t\t\t\tnng_ctx_send(VAR_1->extra_ctx, VAR_1->aio);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (VAR_1->code != VAR_19) {\n\t\t\t\t/* COMMENT_17 */\n\t\t\t\tif (VAR_1->proto != VAR_8) {\n\t\t\t\t\tVAR_1->state = VAR_24;\n\t\t\t\t\tnng_aio_finish(VAR_1->aio, 0);\n\t\t\t\t\t/* COMMENT_18 */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tVAR_1->state = VAR_20;\n\t\t\t\tfree_pub_packet(VAR_1->pub_packet);\n\t\t\t\tVAR_1->pub_packet = NULL;\n\t\t\t\tcvector_free(VAR_1->pipe_ct->msg_infos);\n\t\t\t\t/* COMMENT_6 */\n\t\t\t\tconn_param_free(VAR_1->cparam);\n\t\t\t\tnng_aio_finish(VAR_1->aio, 0);\n\t\t\t\t/* COMMENT_18 */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (VAR_1->flag == VAR_12) {\n\t\t\tuint8_t *VAR_30        = nng_msg_body(VAR_1->msg);\n\t\t\tuint8_t  VAR_31 = *(VAR_30 + 1);\n\t\t\tif (VAR_1->proto == VAR_8) {\n\t\t\t\t/* COMMENT_19 */\n\t\t\t\tnng_aio_set_prov_data(VAR_1->aio, &VAR_1->pid.id);\n\t\t\t\t/* COMMENT_20 */\n\t\t\t\tnng_msg_clone(VAR_1->msg);\n\t\t\t\tnng_aio_set_msg(VAR_1->aio, VAR_1->msg);\n\t\t\t\tnng_ctx_send(VAR_1->ctx, VAR_1->aio);\n\t\t\t}\n\t\t\tVAR_3 = nano_msg_notify_connect(VAR_1->cparam, VAR_31);\n\t\t\twebhook_entry(VAR_1, VAR_31);\n\t\t\t/* COMMENT_21 */\n\t\t\tnng_msg_set_cmd_type(VAR_3, VAR_13);\n\t\t\tVAR_1->flag = VAR_13;\n\t\t\tnng_msg_free(VAR_1->msg);\n\t\t\tVAR_1->msg = VAR_3;\n\t\t\thandle_pub(VAR_1, VAR_1->pipe_ct,\n\t\t\t    VAR_32, true);\n\t\t\t/* COMMENT_22 */\n\t\t\t/* COMMENT_23 */\n\t\t} else if (VAR_1->flag == VAR_33) {\n\t\t\t/* COMMENT_24 */\n\t\t\twebhook_entry(VAR_1, 0);\n\t\t\tnng_msg_set_cmd_type(VAR_2, VAR_13);\n\t\t\tVAR_1->flag = VAR_13;\n\t\t\thandle_pub(VAR_1, VAR_1->pipe_ct,\n\t\t\t    VAR_32, true);\n\t\t\t/* COMMENT_25 */\n\t\t\t/* COMMENT_26 */\n\t\t\t/* COMMENT_27 */\n\t\t\t/* COMMENT_28 */\n\t\t\tif (dbhash_check_id(VAR_1->pid.id)) {\n\t\t\t\tdestroy_sub_client(VAR_1->pid.id, VAR_1->db);\n\t\t\t}\n\t\t\tif (conn_param_get_will_flag(VAR_1->cparam) == 0 ||\n\t\t\t    !conn_param_get_will_topic(VAR_1->cparam) ||\n\t\t\t    !conn_param_get_will_msg(VAR_1->cparam)) {\n\t\t\t\t/* COMMENT_29 */\n\t\t\t\tconn_param_free(VAR_1->cparam);\n\t\t\t} else {\n\t\t\t\t/* COMMENT_30 */\n\t\t\t\t/* COMMENT_31 */\n\t\t\t\tVAR_1->state = VAR_34;\n\t\t\t\t/* COMMENT_32 */\n\t\t\t\tnng_aio_finish(VAR_1->aio, 0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tVAR_1->state = VAR_29;\n\t\tnng_aio_finish(VAR_1->aio, 0);\n\t\tbreak;\n\tcase VAR_29:\n\t\t/* COMMENT_33 */\n\t\tlog_debug(\"WAIT ^^^^ ctx%d ^^^^\", VAR_1->ctx.id);\n\t\tif (nng_msg_get_type(VAR_1->msg) == VAR_13) {\n\t\t\tif ((VAR_4 = nng_aio_result(VAR_1->aio)) != 0) {\n\t\t\t\tlog_error(\"WAIT nng aio result error: %d\", VAR_4);\n\t\t\t\tnng_fatal(\"WAIT nng_ctx_recv/send\", VAR_4);\n\t\t\t}\n\t\t\tVAR_3      = VAR_1->msg; /* COMMENT_34 */\n\t\t\tVAR_35(mqtt_msg_info) VAR_36;\n\t\t\tVAR_36 = VAR_1->pipe_ct->msg_infos;\n\n\t\t\tlog_trace(\"total pipes: %ld\", cvector_size(VAR_36));\n\t\t\tif (cvector_size(VAR_36))\n\t\t\t\tif (encode_pub_message(VAR_3, VAR_1, VAR_37))\n\t\t\t\t\tfor (int VAR_21 = 0; VAR_21 < cvector_size(VAR_36) && VAR_4== 0; ++VAR_21) {\n\t\t\t\t\t\tVAR_5 = &VAR_36[VAR_21];\n\t\t\t\t\t\tnng_msg_clone(VAR_3);\n\t\t\t\t\t\tVAR_1->pid.id = VAR_5->pipe;\n\t\t\t\t\t\tnng_aio_set_prov_data(VAR_1->aio, &VAR_1->pid.id);\n\t\t\t\t\t\tVAR_1->msg = VAR_3;\n\t\t\t\t\t\tnng_aio_set_msg(VAR_1->aio, VAR_1->msg);\n\t\t\t\t\t\tnng_ctx_send(VAR_1->ctx, VAR_1->aio);\n\t\t\t\t\t}\n\t\t\tVAR_1->msg = VAR_3;\n\n\t\t\t/* COMMENT_35 */\n\t\t\tif (VAR_1->config->bridge_mode) {\n\t\t\t\tbridge_handler(VAR_1);\n#if defined(VAR_38)\n\t\t\t\taws_bridge_forward(VAR_1);\n#endif\n\t\t\t}\n\t\t\t/* COMMENT_36 */\n\t\t\tconf_web_hook *VAR_39   = &(VAR_1->config->web_hook);\n\t\t\tuint8_t VAR_40 = VAR_41;\n#if defined(VAR_42)\n\t\t\tVAR_40 = VAR_1->config->rule_eng.option;\n#endif\n\t\t\tif (VAR_39->enable || VAR_40 != VAR_41) {\n\t\t\t\tVAR_1->state = VAR_24;\n\t\t\t\tnng_aio_finish(VAR_1->aio, 0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnng_msg_free(VAR_1->msg);\n\t\t\tVAR_3 = NULL;\n\t\t\tVAR_1->msg = NULL;\n\t\t\t/* COMMENT_6 */\n\t\t\tconn_param_free(VAR_1->cparam);\n\t\t\tfree_pub_packet(VAR_1->pub_packet);\n\t\t\tVAR_1->pub_packet = NULL;\n\t\t\tcvector_free(VAR_36);\n\t\t\tVAR_1->pipe_ct->msg_infos = NULL;\n\t\t\tinit_pipe_content(VAR_1->pipe_ct);\n\t\t\tVAR_1->state = VAR_7;\n\t\t\tif (VAR_1->proto != VAR_8) {\n\t\t\t\tnng_ctx_recv(VAR_1->extra_ctx, VAR_1->aio);\n\t\t\t} else {\n\t\t\t\tnng_ctx_recv(VAR_1->ctx, VAR_1->aio);\n\t\t\t}\n\t\t} else if (nng_msg_cmd_type(VAR_1->msg) == VAR_43 ||\n\t\t    nng_msg_cmd_type(VAR_1->msg) == VAR_44 ||\n\t\t    nng_msg_cmd_type(VAR_1->msg) == VAR_45) {\n\t\t\tnng_msg_free(VAR_1->msg);\n\t\t\tVAR_1->msg   = NULL;\n\t\t\tVAR_1->state = VAR_7;\n\t\t\tnng_ctx_recv(VAR_1->ctx, VAR_1->aio);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tlog_debug(\"broker has nothing to do\");\n\t\t\tif (VAR_1->msg != NULL)\n\t\t\t\tnng_msg_free(VAR_1->msg);\n\t\t\tVAR_1->msg   = NULL;\n\t\t\tVAR_1->state = VAR_7;\n\t\t\tnng_ctx_recv(VAR_1->ctx, VAR_1->aio);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase VAR_24:\n\t\tlog_debug(\"SEND ^^^^ ctx%d ^^^^\", VAR_1->ctx.id);\n#if defined(VAR_42)\n\t\tif (VAR_1->flag == VAR_13 && VAR_1->config->rule_eng.option != VAR_41) {\n\t\t\trule_engine_insert_sql(VAR_1);\n\t\t}\n#endif\n\t\t/* COMMENT_37 */\n\t\twebhook_entry(VAR_1, 0);\n\n\t\tif (NULL != VAR_1->msg) {\n\t\t\tnng_msg_free(VAR_1->msg);\n\t\t\tVAR_1->msg = NULL;\n\t\t}\n\t\tif ((VAR_4 = nng_aio_result(VAR_1->aio)) != 0) {\n\t\t\tnng_fatal(\"SEND nng_ctx_send\", VAR_4);\n\t\t}\n\t\tif (VAR_1->pub_packet != NULL) {\n\t\t\tfree_pub_packet(VAR_1->pub_packet);\n\t\t\tVAR_1->pub_packet = NULL;\n\t\t}\n\t\tif (VAR_1->pipe_ct->msg_infos != NULL) {\n\t\t\tcvector_free(VAR_1->pipe_ct->msg_infos);\n\t\t\tVAR_1->pipe_ct->msg_infos = NULL;\n\t\t\tinit_pipe_content(VAR_1->pipe_ct);\n\t\t}\n\t\t/* COMMENT_6 */\n\t\tconn_param_free(VAR_1->cparam);\n\t\tVAR_1->state = VAR_7;\n\t\tVAR_1->flag  = 0;\n\t\tif (VAR_1->proto == VAR_8) {\n\t\t\tnng_ctx_recv(VAR_1->ctx, VAR_1->aio);\n\t\t} else{\n\t\t\tnng_ctx_recv(VAR_1->extra_ctx, VAR_1->aio);\n\t\t}\n\t\tbreak;\n\tcase VAR_34:\n\t\tlog_debug(\"END ^^^^ ctx%d ^^^^ \", VAR_1->ctx.id);\n\t\tif (nng_msg_get_type(VAR_1->msg) == VAR_13) {\n\t\t\tif ((VAR_4 = nng_aio_result(VAR_1->aio)) != 0) {\n\t\t\t\tlog_error(\"WAIT nng aio result error: %d\", VAR_4);\n\t\t\t\tnng_fatal(\"WAIT nng_ctx_recv/send\", VAR_4);\n\t\t\t}\n\t\t\tVAR_3      = VAR_1->msg; /* COMMENT_34 */\n\t\t\tVAR_1->msg = NULL;\n\n\t\t\tVAR_35(mqtt_msg_info) VAR_36;\n\t\t\tVAR_36 = VAR_1->pipe_ct->msg_infos;\n\n\t\t\tlog_debug(\"total pipes: %ld\", cvector_size(VAR_36));\n\t\t\t/* COMMENT_38 */\n\t\t\tif (cvector_size(VAR_36))\n\t\t\t\tif (encode_pub_message(VAR_3, VAR_1, VAR_37))\n\t\t\t\t\tfor (int VAR_21=0; VAR_21<cvector_size(VAR_36); ++VAR_21) {\n\t\t\t\t\t\tVAR_5 = &VAR_36[VAR_21];\n\t\t\t\t\t\tnng_msg_clone(VAR_3);\n\t\t\t\t\t\tVAR_1->pid.id = VAR_5->pipe;\n\t\t\t\t\t\tnng_aio_set_prov_data(VAR_1->aio, &VAR_1->pid.id);\n\t\t\t\t\t\tVAR_1->msg = VAR_3;\n\t\t\t\t\t\tnng_aio_set_msg(VAR_1->aio, VAR_1->msg);\n\t\t\t\t\t\tnng_ctx_send(VAR_1->ctx, VAR_1->aio);\n\t\t\t\t\t}\n\t\t\twebhook_entry(VAR_1, 0);\n\t\t\tnng_msg_free(VAR_3);\n\t\t\tVAR_3 = NULL;\n\t\t\tVAR_1->msg = NULL;\n\t\t\tfree_pub_packet(VAR_1->pub_packet);\n\t\t\tVAR_1->pub_packet = NULL;\n\t\t\tcvector_free(VAR_1->pipe_ct->msg_infos);\n\t\t\tVAR_1->pipe_ct->msg_infos = NULL;\n\t\t\tinit_pipe_content(VAR_1->pipe_ct);\n\n\t\t\t/* COMMENT_39 */\n\t\t\tif (conn_param_get_will_flag(VAR_1->cparam) &&\n\t\t\t    (VAR_2 = nano_pubmsg_composer(&VAR_2,\n\t\t\t         conn_param_get_will_retain(VAR_1->cparam),\n\t\t\t         conn_param_get_will_qos(VAR_1->cparam),\n\t\t\t         (mqtt_string *) conn_param_get_will_msg(\n\t\t\t             VAR_1->cparam),\n\t\t\t         (mqtt_string *) conn_param_get_will_topic(\n\t\t\t             VAR_1->cparam),\n\t\t\t         conn_param_get_protover(VAR_1->cparam),\n\t\t\t         nng_clock())) != NULL) {\n\t\t\t\tVAR_1->msg = VAR_2;\n\t\t\t\tVAR_1->flag = VAR_13;\n\t\t\t\t/* COMMENT_15 */\n\t\t\t\tif (conn_param_get_protover(VAR_1->cparam) == 5) {\n\t\t\t\t\tproperty *VAR_46 =\n\t\t\t\t\t    conn_param_get_will_property(\n\t\t\t\t\t        VAR_1->cparam);\n\t\t\t\t\tnng_msg_set_cmd_type(\n\t\t\t\t\t    VAR_2, VAR_27);\n\t\t\t\t\thandle_pub(VAR_1, VAR_1->pipe_ct,\n\t\t\t\t\t    VAR_47, false);\n\t\t\t\t\tVAR_1->pub_packet->var_header.publish\n\t\t\t\t\t    .properties = property_pub_by_will(\n\t\t\t\t\t    VAR_46);\n\t\t\t\t\tVAR_1->pub_packet->var_header.publish\n\t\t\t\t\t    .prop_len = get_properties_len(\n\t\t\t\t\t    VAR_1->pub_packet->var_header\n\t\t\t\t\t        .publish.properties);\n\t\t\t\t} else {\n\t\t\t\t\tnng_msg_set_cmd_type(VAR_2, VAR_13);\n\t\t\t\t\thandle_pub(VAR_1, VAR_1->pipe_ct,\n\t\t\t\t\t    VAR_32, false);\n\t\t\t\t}\n\t\t\t\tVAR_1->state = VAR_29;\n\t\t\t\tnng_aio_finish(VAR_1->aio, 0);\n\t\t\t} else {\n\t\t\t\t/* COMMENT_40 */\n\t\t\t\tconn_param_free(VAR_1->cparam);\n\t\t\t\tif (VAR_1->msg != NULL)\n\t\t\t\t\tnng_msg_free(VAR_1->msg);\n\t\t\t\tVAR_1->msg = NULL;\n\t\t\t\tVAR_1->state = VAR_7;\n\t\t\t\tif (VAR_1->proto == VAR_8) {\n\t\t\t\t\tnng_ctx_recv(VAR_1->ctx, VAR_1->aio);\n\t\t\t\t} else {\n\t\t\t\t\tnng_ctx_recv(VAR_1->extra_ctx, VAR_1->aio);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconn_param_free(VAR_1->cparam);\n\t\tbreak;\n\tcase VAR_20:\n\t\tlog_debug(\" CLOSE ^^^^ ctx%d ^^^^\", VAR_1->ctx.id);\n\t\tVAR_3 = nano_dismsg_composer(VAR_1->code, NULL, NULL, NULL);\n\t\tnng_msg_free(VAR_1->msg);\n\t\tVAR_1->msg = VAR_3;\n\t\t/* COMMENT_41 */\n\t\tnng_aio_set_prov_data(VAR_1->aio, &VAR_1->pid.id);\n\t\t/* COMMENT_20 */\n\t\tnng_aio_set_msg(VAR_1->aio, VAR_1->msg);\n\t\tnng_ctx_send(VAR_1->ctx, VAR_1->aio); /* COMMENT_42 */\n\n\t\t/* COMMENT_43 */\n\t\tVAR_1->code = VAR_19;\n\t\tVAR_1->state = VAR_7;\n\t\tnng_ctx_recv(VAR_1->ctx, VAR_1->aio);\n\t\tbreak;\n\tdefault:\n\t\tnng_fatal(\"bad state!\", VAR_48);\n\t\tbreak;\n\t}\n}",
  "func_graph_path_before": "nanomq/5f57ef45ccfd0f47d815eb62f5f2a619ba7d0633/broker.c/vul/before/0.json",
  "func": "void\nserver_cb(void *arg)\n{\n\tnano_work     *work = arg;\n\tnng_msg       *msg  = NULL;\n\tnng_msg       *smsg = NULL;\n\tint            rv;\n\n\tmqtt_msg_info *msg_info;\n\n\tswitch (work->state) {\n\tcase INIT:\n\t\t// log_debug(\"INIT ^^^^^^^^ ctx [%d] ^^^^^^^^ \\n\", work->ctx.id);\n\t\twork->state = RECV;\n\t\tif (work->proto == PROTO_MQTT_BROKER) {\n\t\t\tlog_debug(\"INIT ^^^^^^^^ ctx [%d] ^^^^^^^^ \\n\", work->ctx.id);\n\t\t\tnng_ctx_recv(work->ctx, work->aio);\n\t\t} else {\n\t\t\tlog_debug(\"INIT ^^^^^^^^ extra ctx [%d] ^^^^^^^^ \\n\", work->extra_ctx.id);\n\t\t\tnng_ctx_recv(work->extra_ctx, work->aio);\n\t\t}\n\t\tbreak;\n\tcase RECV:\n\t\tlog_debug(\"RECV  ^^^^ ctx%d ^^^^\\n\", work->ctx.id);\n\t\tif ((rv = nng_aio_result(work->aio)) != 0) {\n\t\t\tlog_warn(\"RECV nng aio result error: %d\", rv);\n\t\t\twork->state = RECV;\n\t\t\tif (work->proto == PROTO_MQTT_BROKER) {\n\t\t\t\tnng_ctx_recv(work->ctx, work->aio);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tlog_info(\"bridge connection closed with reason %d\\n\", rv);\n\t\t\t\tif (rv != NNG_ECONNSHUT) {\n\t\t\t\t\tnng_ctx_recv(work->extra_ctx, work->aio);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ((msg = nng_aio_get_msg(work->aio)) == NULL) {\n\t\t\tnng_fatal(\"RECV NULL MSG\", rv);\n\t\t}\n\t\tif (work->proto == PROTO_MQTT_BRIDGE) {\n\t\t\tuint8_t type;\n\t\t\ttype = nng_msg_get_type(msg);\n\t\t\tif (type == CMD_CONNACK) {\n\t\t\t\tlog_info(\"bridge client is connected!\");\n\t\t\t} else if (type != CMD_PUBLISH) {\n\t\t\t\t// only accept publish/CONNACK/DISCONNECT\n\t\t\t\t// msg from upstream\n\t\t\t\twork->state = RECV;\n\t\t\t\tnng_msg_free(msg);\n\t\t\t\tnng_ctx_recv(work->extra_ctx, work->aio);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t// clone conn_param every single time\n\t\t\t\tconn_param_clone(nng_msg_get_conn_param(msg));\n\t\t\t}\n\t\t} else if (work->proto == PROTO_HTTP_SERVER ||\n\t\t    work->proto == PROTO_AWS_BRIDGE) {\n\t\t\tnng_msg *decode_msg = NULL;\n\t\t\tif (decode_common_mqtt_msg(&decode_msg, msg) != 0 ||\n\t\t\t    nng_msg_get_type(decode_msg) != CMD_PUBLISH) {\n\t\t\t\tconn_param_free(nng_msg_get_conn_param(decode_msg));\n\t\t\t\twork->state = RECV;\n\t\t\t\tnng_ctx_recv(work->extra_ctx, work->aio);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmsg = decode_msg;\n\t\t\tnng_msg_set_cmd_type(msg, CMD_PUBLISH);\n\t\t\t// alloc conn_param every single time\n\t\t}\n\t\twork->msg       = msg;\n\t\twork->pid       = nng_msg_get_pipe(work->msg);\n\t\twork->cparam    = nng_msg_get_conn_param(work->msg);\n\t\twork->proto_ver = conn_param_get_protover(work->cparam);\n\t\twork->flag      = nng_msg_cmd_type(msg);\n\n\t\tif (work->flag == CMD_SUBSCRIBE) {\n\t\t\tsmsg = work->msg;\n\t\t\twork->msg_ret = NULL;\n\n\t\t\tif ((work->sub_pkt = nng_alloc(\n\t\t\t         sizeof(packet_subscribe))) == NULL)\n\t\t\t\tlog_error(\"nng_alloc\");\n\t\t\tmemset(work->sub_pkt, '\\0', sizeof(packet_subscribe));\n\n\t\t\tif ((rv = decode_sub_msg(work)) != 0 ||\n\t\t\t    (rv = sub_ctx_handle(work)) != 0) {\n\t\t\t\twork->code = rv;\n\t\t\t\tlog_error(\"sub_handler: [%d]\", rv);\n\t\t\t}\n\n\t\t\t// TODO not all codes needs to close the pipe\n\t\t\tif (work->code != SUCCESS) {\n\t\t\t\tif (work->msg_ret)\n\t\t\t\t\tcvector_free(work->msg_ret);\n\t\t\t\tif (work->sub_pkt)\n\t\t\t\t\tsub_pkt_free(work->sub_pkt);\n\t\t\t\t// free conn_param due to clone in protocol layer\n\t\t\t\tconn_param_free(work->cparam);\n\n\t\t\t\twork->state = CLOSE;\n\t\t\t\tnng_aio_finish(work->aio, 0);\n\t\t\t\t// TODO break or return?\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// TODO Error handling\n\t\t\tif (0 != (rv = encode_suback_msg(smsg, work)))\n\t\t\t\tlog_error(\"error in encode suback: [%d]\", rv);\n\n\t\t\tsub_pkt_free(work->sub_pkt);\n\t\t\t// handle retain (Retain flag handled in npipe)\n\t\t\twork->msg = NULL;\n\t\t\tif (work->msg_ret) {\n\t\t\t\tlog_debug(\"retain msg [%p] size [%ld] \\n\",\n\t\t\t\t    work->msg_ret,\n\t\t\t\t    cvector_size(work->msg_ret));\n\t\t\t\tfor (int i = 0;\n\t\t\t\t     i < cvector_size(work->msg_ret) &&\n\t\t\t\t     check_msg_exp(work->msg_ret[i],\n\t\t\t\t         nng_mqtt_msg_get_publish_property(\n\t\t\t\t             work->msg_ret[i]));\n\t\t\t\t     i++) {\n\t\t\t\t\tnng_msg *m = work->msg_ret[i];\n\t\t\t\t\tif (!work->config->sqlite.enable) {\n\t\t\t\t\t\t// Unnecessary to clone msg if\n\t\t\t\t\t\t// alloced from sqlite db\n\t\t\t\t\t\tnng_msg_clone(m);\n\t\t\t\t\t}\n\t\t\t\t\twork->msg = m;\n\t\t\t\t\tnng_aio_set_msg(work->aio, work->msg);\n\t\t\t\t\tnng_aio_set_prov_data(work->aio, &work->pid.id);\n\t\t\t\t\tnng_ctx_send(work->ctx, work->aio);\n\t\t\t\t\tnng_msg_free(m);\n\t\t\t\t}\n\t\t\t\tcvector_free(work->msg_ret);\n\t\t\t}\n\t\t\tnng_msg_set_cmd_type(smsg, CMD_SUBACK);\n\t\t\tnng_aio_set_prov_data(work->aio, &work->pid.id);\n\t\t\tnng_aio_set_msg(work->aio, smsg);\n\t\t\twork->msg   = NULL;\n\t\t\twork->state = SEND;\n\t\t\tnng_ctx_send(work->ctx, work->aio);\n\t\t\tsmsg = NULL;\n\t\t\tnng_aio_finish(work->aio, 0);\n\t\t\t// free conn_param in SEND state\n\t\t\tbreak;\n\t\t} else if (work->flag == CMD_UNSUBSCRIBE) {\n\t\t\tsmsg = work->msg;\n\t\t\tif ((work->unsub_pkt = nng_alloc(\n\t\t\t         sizeof(packet_unsubscribe))) == NULL)\n\t\t\t\tlog_error(\"nng_alloc\");\n\n\t\t\tif ((rv = decode_unsub_msg(work)) != 0 ||\n\t\t\t    (rv = unsub_ctx_handle(work)) != 0) {\n\t\t\t\tlog_error(\"unsub_handler [%d]\", rv);\n\t\t\t}\n\n\t\t\tif (0 != (rv = encode_unsuback_msg(smsg, work)))\n\t\t\t\tlog_error(\"in unsuback [%d]\", rv);\n\n\t\t\t// free unsub_pkt\n\t\t\tunsub_pkt_free(work->unsub_pkt);\n\t\t\tnng_aio_set_prov_data(work->aio, &work->pid.id);\n\t\t\tnng_aio_set_msg(work->aio, work->msg);\n\t\t\twork->msg   = NULL;\n\t\t\twork->state = SEND;\n\t\t\tnng_ctx_send(work->ctx, work->aio);\n\t\t\tsmsg = NULL;\n\t\t\tnng_aio_finish(work->aio, 0);\n\t\t\t//free conn_param in SEND state\n\t\t\tbreak;\n\t\t} else if (work->flag == CMD_PUBLISH) {\n\t\t\t// Set V4/V5 flag for publish msg\n\t\t\tif (work->proto_ver == 5) {\n\t\t\t\tnng_msg_set_cmd_type(msg, CMD_PUBLISH_V5);\n\t\t\t} else {\n\t\t\t\tnng_msg_set_cmd_type(msg, CMD_PUBLISH);\n\t\t\t}\n\t\t\twork->code = handle_pub(\n\t\t\t    work, work->pipe_ct, work->proto_ver, false);\n\t\t\tif (work->proto == PROTO_HTTP_SERVER ||\n\t\t\t    work->proto == PROTO_AWS_BRIDGE) {\n\t\t\t\tnng_msg *rep_msg;\n\t\t\t\t// TODO carry code with msg\n\t\t\t\tnng_msg_alloc(&rep_msg, 0);\n\t\t\t\tnng_aio_set_msg(work->aio, rep_msg);\n\t\t\t\tif (work->code == SUCCESS)\n\t\t\t\t\twork->state = WAIT;\n\t\t\t\telse\n\t\t\t\t\twork->state = SEND;\n\t\t\t\tnng_ctx_send(work->extra_ctx, work->aio);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (work->code != SUCCESS) {\n\t\t\t\t//what if extra ctx brings a wrong msg?\n\t\t\t\tif (work->proto != PROTO_MQTT_BROKER) {\n\t\t\t\t\twork->state = SEND;\n\t\t\t\t\tnng_aio_finish(work->aio, 0);\n\t\t\t\t\t// break or return?\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\twork->state = CLOSE;\n\t\t\t\tfree_pub_packet(work->pub_packet);\n\t\t\t\twork->pub_packet = NULL;\n\t\t\t\tcvector_free(work->pipe_ct->msg_infos);\n\t\t\t\t// free conn_param due to clone in protocol layer\n\t\t\t\tconn_param_free(work->cparam);\n\t\t\t\tnng_aio_finish(work->aio, 0);\n\t\t\t\t// break or return?\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (work->flag == CMD_CONNACK) {\n\t\t\tuint8_t *body        = nng_msg_body(work->msg);\n\t\t\tuint8_t  reason_code = *(body + 1);\n\t\t\tif (work->proto == PROTO_MQTT_BROKER) {\n\t\t\t\t// Return CONNACK to clients of broker\n\t\t\t\tnng_aio_set_prov_data(work->aio, &work->pid.id);\n\t\t\t\t// clone for sending connect event notification\n\t\t\t\tnng_msg_clone(work->msg);\n\t\t\t\tnng_aio_set_msg(work->aio, work->msg);\n\t\t\t\tnng_ctx_send(work->ctx, work->aio);\n\t\t\t}\n\t\t\tsmsg = nano_msg_notify_connect(work->cparam, reason_code);\n\t\t\twebhook_entry(work, reason_code);\n\t\t\t// Set V4/V5 flag for publish notify msg\n\t\t\tnng_msg_set_cmd_type(smsg, CMD_PUBLISH);\n\t\t\twork->flag = CMD_PUBLISH;\n\t\t\tnng_msg_free(work->msg);\n\t\t\twork->msg = smsg;\n\t\t\thandle_pub(work, work->pipe_ct,\n\t\t\t    MQTT_PROTOCOL_VERSION_v311, true);\n\t\t\t// remember to free conn_param in WAIT \n\t\t\t// due to clone in protocol layer\n\t\t} else if (work->flag == CMD_DISCONNECT_EV) {\n\t\t\t// Now v4 as default/send V5 notify msg?\n\t\t\twebhook_entry(work, 0);\n\t\t\tnng_msg_set_cmd_type(msg, CMD_PUBLISH);\n\t\t\twork->flag = CMD_PUBLISH;\n\t\t\thandle_pub(work, work->pipe_ct,\n\t\t\t    MQTT_PROTOCOL_VERSION_v311, true);\n\t\t\t// TODO set reason code\n\t\t\t// uint8_t *payload = nng_msg_payload_ptr(work->msg);\n\t\t\t// uint8_t reason_code = *(payload+16);\n\t\t\t// free client ctx\n\t\t\tif (dbhash_check_id(work->pid.id)) {\n\t\t\t\tdestroy_sub_client(work->pid.id, work->db);\n\t\t\t}\n\t\t\tif (conn_param_get_will_flag(work->cparam) == 0 ||\n\t\t\t    !conn_param_get_will_topic(work->cparam) ||\n\t\t\t    !conn_param_get_will_msg(work->cparam)) {\n\t\t\t\t// no will msg - free the cp\n\t\t\t\tconn_param_free(work->cparam);\n\t\t\t} else {\n\t\t\t\t// set to END to send will msg\n\t\t\t\t// TBD: relay last will msg for bridging client?\n\t\t\t\twork->state = END;\n\t\t\t\t// leave cp for will msg\n\t\t\t\tnng_aio_finish(work->aio, 0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\twork->state = WAIT;\n\t\tnng_aio_finish(work->aio, 0);\n\t\tbreak;\n\tcase WAIT:\n\t\t// do not access to cparam\n\t\tlog_debug(\"WAIT ^^^^ ctx%d ^^^^\", work->ctx.id);\n\t\tif (nng_msg_get_type(work->msg) == CMD_PUBLISH) {\n\t\t\tif ((rv = nng_aio_result(work->aio)) != 0) {\n\t\t\t\tlog_error(\"WAIT nng aio result error: %d\", rv);\n\t\t\t\tnng_fatal(\"WAIT nng_ctx_recv/send\", rv);\n\t\t\t}\n\t\t\tsmsg      = work->msg; // reuse the same msg\n\t\t\tcvector(mqtt_msg_info) msg_infos;\n\t\t\tmsg_infos = work->pipe_ct->msg_infos;\n\n\t\t\tlog_trace(\"total pipes: %ld\", cvector_size(msg_infos));\n\t\t\tif (cvector_size(msg_infos))\n\t\t\t\tif (encode_pub_message(smsg, work, PUBLISH))\n\t\t\t\t\tfor (int i = 0; i < cvector_size(msg_infos) && rv== 0; ++i) {\n\t\t\t\t\t\tmsg_info = &msg_infos[i];\n\t\t\t\t\t\tnng_msg_clone(smsg);\n\t\t\t\t\t\twork->pid.id = msg_info->pipe;\n\t\t\t\t\t\tnng_aio_set_prov_data(work->aio, &work->pid.id);\n\t\t\t\t\t\twork->msg = smsg;\n\t\t\t\t\t\tnng_aio_set_msg(work->aio, work->msg);\n\t\t\t\t\t\tnng_ctx_send(work->ctx, work->aio);\n\t\t\t\t\t}\n\t\t\twork->msg = smsg;\n\n\t\t\t// bridge logic first\n\t\t\tif (work->config->bridge_mode) {\n\t\t\t\tbridge_handler(work);\n#if defined(SUPP_AWS_BRIDGE)\n\t\t\t\taws_bridge_forward(work);\n#endif\n\t\t\t}\n\t\t\t//check webhook & rule engine\n\t\t\tconf_web_hook *hook_conf   = &(work->config->web_hook);\n\t\t\tuint8_t rule_opt = RULE_ENG_OFF;\n#if defined(SUPP_RULE_ENGINE)\n\t\t\trule_opt = work->config->rule_eng.option;\n#endif\n\t\t\tif (hook_conf->enable || rule_opt != RULE_ENG_OFF) {\n\t\t\t\twork->state = SEND;\n\t\t\t\tnng_aio_finish(work->aio, 0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnng_msg_free(work->msg);\n\t\t\tsmsg = NULL;\n\t\t\twork->msg = NULL;\n\t\t\t// free conn_param due to clone in protocol layer\n\t\t\tconn_param_free(work->cparam);\n\t\t\tfree_pub_packet(work->pub_packet);\n\t\t\twork->pub_packet = NULL;\n\t\t\tcvector_free(msg_infos);\n\t\t\twork->pipe_ct->msg_infos = NULL;\n\t\t\tinit_pipe_content(work->pipe_ct);\n\t\t\twork->state = RECV;\n\t\t\tif (work->proto != PROTO_MQTT_BROKER) {\n\t\t\t\tnng_ctx_recv(work->extra_ctx, work->aio);\n\t\t\t} else {\n\t\t\t\tnng_ctx_recv(work->ctx, work->aio);\n\t\t\t}\n\t\t} else if (nng_msg_cmd_type(work->msg) == CMD_PUBACK ||\n\t\t    nng_msg_cmd_type(work->msg) == CMD_PUBREL ||\n\t\t    nng_msg_cmd_type(work->msg) == CMD_PUBCOMP) {\n\t\t\tnng_msg_free(work->msg);\n\t\t\twork->msg   = NULL;\n\t\t\twork->state = RECV;\n\t\t\tnng_ctx_recv(work->ctx, work->aio);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tlog_debug(\"broker has nothing to do\");\n\t\t\tif (work->msg != NULL)\n\t\t\t\tnng_msg_free(work->msg);\n\t\t\twork->msg   = NULL;\n\t\t\twork->state = RECV;\n\t\t\tnng_ctx_recv(work->ctx, work->aio);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SEND:\n\t\tlog_debug(\"SEND ^^^^ ctx%d ^^^^\", work->ctx.id);\n#if defined(SUPP_RULE_ENGINE)\n\t\tif (work->flag == CMD_PUBLISH && work->config->rule_eng.option != RULE_ENG_OFF) {\n\t\t\trule_engine_insert_sql(work);\n\t\t}\n#endif\n\t\t// webhook here\n\t\twebhook_entry(work, 0);\n\n\t\tif (NULL != work->msg) {\n\t\t\tnng_msg_free(work->msg);\n\t\t\twork->msg = NULL;\n\t\t}\n\t\tif ((rv = nng_aio_result(work->aio)) != 0) {\n\t\t\tnng_fatal(\"SEND nng_ctx_send\", rv);\n\t\t}\n\t\tif (work->pub_packet != NULL) {\n\t\t\tfree_pub_packet(work->pub_packet);\n\t\t\twork->pub_packet = NULL;\n\t\t}\n\t\tif (work->pipe_ct->msg_infos != NULL) {\n\t\t\tcvector_free(work->pipe_ct->msg_infos);\n\t\t\twork->pipe_ct->msg_infos = NULL;\n\t\t\tinit_pipe_content(work->pipe_ct);\n\t\t}\n\t\t// free conn_param due to clone in protocol layer\n\t\tconn_param_free(work->cparam);\n\t\twork->state = RECV;\n\t\twork->flag  = 0;\n\t\tif (work->proto == PROTO_MQTT_BROKER) {\n\t\t\tnng_ctx_recv(work->ctx, work->aio);\n\t\t} else{\n\t\t\tnng_ctx_recv(work->extra_ctx, work->aio);\n\t\t}\n\t\tbreak;\n\tcase END:\n\t\tlog_debug(\"END ^^^^ ctx%d ^^^^ \", work->ctx.id);\n\t\tif (nng_msg_get_type(work->msg) == CMD_PUBLISH) {\n\t\t\tif ((rv = nng_aio_result(work->aio)) != 0) {\n\t\t\t\tlog_error(\"WAIT nng aio result error: %d\", rv);\n\t\t\t\tnng_fatal(\"WAIT nng_ctx_recv/send\", rv);\n\t\t\t}\n\t\t\tsmsg      = work->msg; // reuse the same msg\n\t\t\twork->msg = NULL;\n\n\t\t\tcvector(mqtt_msg_info) msg_infos;\n\t\t\tmsg_infos = work->pipe_ct->msg_infos;\n\n\t\t\tlog_debug(\"total pipes: %ld\", cvector_size(msg_infos));\n\t\t\t//TODO encode abstract msg only\n\t\t\tif (cvector_size(msg_infos))\n\t\t\t\tif (encode_pub_message(smsg, work, PUBLISH))\n\t\t\t\t\tfor (int i=0; i<cvector_size(msg_infos); ++i) {\n\t\t\t\t\t\tmsg_info = &msg_infos[i];\n\t\t\t\t\t\tnng_msg_clone(smsg);\n\t\t\t\t\t\twork->pid.id = msg_info->pipe;\n\t\t\t\t\t\tnng_aio_set_prov_data(work->aio, &work->pid.id);\n\t\t\t\t\t\twork->msg = smsg;\n\t\t\t\t\t\tnng_aio_set_msg(work->aio, work->msg);\n\t\t\t\t\t\tnng_ctx_send(work->ctx, work->aio);\n\t\t\t\t\t}\n\t\t\twebhook_entry(work, 0);\n\t\t\tnng_msg_free(smsg);\n\t\t\tsmsg = NULL;\n\t\t\twork->msg = NULL;\n\t\t\tfree_pub_packet(work->pub_packet);\n\t\t\twork->pub_packet = NULL;\n\t\t\tcvector_free(work->pipe_ct->msg_infos);\n\t\t\twork->pipe_ct->msg_infos = NULL;\n\t\t\tinit_pipe_content(work->pipe_ct);\n\n\t\t\t// processing will msg\n\t\t\tif (conn_param_get_will_flag(work->cparam) &&\n\t\t\t    (msg = nano_pubmsg_composer(&msg,\n\t\t\t         conn_param_get_will_retain(work->cparam),\n\t\t\t         conn_param_get_will_qos(work->cparam),\n\t\t\t         (mqtt_string *) conn_param_get_will_msg(\n\t\t\t             work->cparam),\n\t\t\t         (mqtt_string *) conn_param_get_will_topic(\n\t\t\t             work->cparam),\n\t\t\t         conn_param_get_protover(work->cparam),\n\t\t\t         nng_clock())) != NULL) {\n\t\t\t\twork->msg = msg;\n\t\t\t\twork->flag = CMD_PUBLISH;\n\t\t\t\t// Set V4/V5 flag for publish msg\n\t\t\t\tif (conn_param_get_protover(work->cparam) == 5) {\n\t\t\t\t\tproperty *will_property =\n\t\t\t\t\t    conn_param_get_will_property(\n\t\t\t\t\t        work->cparam);\n\t\t\t\t\tnng_msg_set_cmd_type(\n\t\t\t\t\t    msg, CMD_PUBLISH_V5);\n\t\t\t\t\thandle_pub(work, work->pipe_ct,\n\t\t\t\t\t    MQTT_PROTOCOL_VERSION_v5, false);\n\t\t\t\t\twork->pub_packet->var_header.publish\n\t\t\t\t\t    .properties = property_pub_by_will(\n\t\t\t\t\t    will_property);\n\t\t\t\t\twork->pub_packet->var_header.publish\n\t\t\t\t\t    .prop_len = get_properties_len(\n\t\t\t\t\t    work->pub_packet->var_header\n\t\t\t\t\t        .publish.properties);\n\t\t\t\t} else {\n\t\t\t\t\tnng_msg_set_cmd_type(msg, CMD_PUBLISH);\n\t\t\t\t\thandle_pub(work, work->pipe_ct,\n\t\t\t\t\t    MQTT_PROTOCOL_VERSION_v311, false);\n\t\t\t\t}\n\t\t\t\twork->state = WAIT;\n\t\t\t\tnng_aio_finish(work->aio, 0);\n\t\t\t} else {\n\t\t\t\t// free Conn_param once more in case invalid last-will msg\n\t\t\t\tconn_param_free(work->cparam);\n\t\t\t\tif (work->msg != NULL)\n\t\t\t\t\tnng_msg_free(work->msg);\n\t\t\t\twork->msg = NULL;\n\t\t\t\twork->state = RECV;\n\t\t\t\tif (work->proto == PROTO_MQTT_BROKER) {\n\t\t\t\t\tnng_ctx_recv(work->ctx, work->aio);\n\t\t\t\t} else {\n\t\t\t\t\tnng_ctx_recv(work->extra_ctx, work->aio);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconn_param_free(work->cparam);\n\t\tbreak;\n\tcase CLOSE:\n\t\tlog_debug(\" CLOSE ^^^^ ctx%d ^^^^\", work->ctx.id);\n\t\tsmsg = nano_dismsg_composer(work->code, NULL, NULL, NULL);\n\t\tnng_msg_free(work->msg);\n\t\twork->msg = smsg;\n\t\t// compose a disconnect msg\n\t\tnng_aio_set_prov_data(work->aio, &work->pid.id);\n\t\t// clone for sending connect event notification\n\t\tnng_aio_set_msg(work->aio, work->msg);\n\t\tnng_ctx_send(work->ctx, work->aio); // send connack\n\n\t\t// clear reason code\n\t\twork->code = SUCCESS;\n\t\twork->state = RECV;\n\t\tnng_ctx_recv(work->ctx, work->aio);\n\t\tbreak;\n\tdefault:\n\t\tnng_fatal(\"bad state!\", NNG_ESTATE);\n\t\tbreak;\n\t}\n}",
  "abstract_func": "void\nserver_cb(void *VAR_0)\n{\n\tnano_work     *VAR_1 = VAR_0;\n\tnng_msg       *VAR_2  = NULL;\n\tnng_msg       *VAR_3 = NULL;\n\tint            VAR_4;\n\n\tmqtt_msg_info *VAR_5;\n\n\tswitch (VAR_1->state) {\n\tcase VAR_6:\n\t\t/* COMMENT_0 */\n\t\tVAR_1->state = VAR_7;\n\t\tif (VAR_1->proto == VAR_8) {\n\t\t\tlog_debug(\"INIT ^^^^^^^^ ctx [%d] ^^^^^^^^ \\n\", VAR_1->ctx.id);\n\t\t\tnng_ctx_recv(VAR_1->ctx, VAR_1->aio);\n\t\t} else {\n\t\t\tlog_debug(\"INIT ^^^^^^^^ extra ctx [%d] ^^^^^^^^ \\n\", VAR_1->extra_ctx.id);\n\t\t\tnng_ctx_recv(VAR_1->extra_ctx, VAR_1->aio);\n\t\t}\n\t\tbreak;\n\tcase VAR_7:\n\t\tlog_debug(\"RECV  ^^^^ ctx%d ^^^^\\n\", VAR_1->ctx.id);\n\t\tif ((VAR_4 = nng_aio_result(VAR_1->aio)) != 0) {\n\t\t\tlog_warn(\"RECV nng aio result error: %d\", VAR_4);\n\t\t\tVAR_1->state = VAR_7;\n\t\t\tif (VAR_1->proto == VAR_8) {\n\t\t\t\tnng_ctx_recv(VAR_1->ctx, VAR_1->aio);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tlog_info(\"bridge connection closed with reason %d\\n\", VAR_4);\n\t\t\t\tif (VAR_4 != VAR_9) {\n\t\t\t\t\tnng_ctx_recv(VAR_1->extra_ctx, VAR_1->aio);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ((VAR_2 = nng_aio_get_msg(VAR_1->aio)) == NULL) {\n\t\t\tnng_fatal(\"RECV NULL MSG\", VAR_4);\n\t\t}\n\t\tif (VAR_1->proto == VAR_10) {\n\t\t\tuint8_t VAR_11;\n\t\t\tVAR_11 = nng_msg_get_type(VAR_2);\n\t\t\tif (VAR_11 == VAR_12) {\n\t\t\t\tlog_info(\"bridge client is connected!\");\n\t\t\t} else if (VAR_11 != VAR_13) {\n\t\t\t\t/* COMMENT_1 */\n\t\t\t\t/* COMMENT_2 */\n\t\t\t\tVAR_1->state = VAR_7;\n\t\t\t\tnng_msg_free(VAR_2);\n\t\t\t\tnng_ctx_recv(VAR_1->extra_ctx, VAR_1->aio);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t/* COMMENT_3 */\n\t\t\t\tconn_param_clone(nng_msg_get_conn_param(VAR_2));\n\t\t\t}\n\t\t} else if (VAR_1->proto == VAR_14 ||\n\t\t    VAR_1->proto == VAR_15) {\n\t\t\tnng_msg *VAR_16 = NULL;\n\t\t\tif (decode_common_mqtt_msg(&VAR_16, VAR_2) != 0 ||\n\t\t\t    nng_msg_get_type(VAR_16) != VAR_13) {\n\t\t\t\tconn_param_free(nng_msg_get_conn_param(VAR_16));\n\t\t\t\tVAR_1->state = VAR_7;\n\t\t\t\tnng_ctx_recv(VAR_1->extra_ctx, VAR_1->aio);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tVAR_2 = VAR_16;\n\t\t\tnng_msg_set_cmd_type(VAR_2, VAR_13);\n\t\t\t/* COMMENT_4 */\n\t\t}\n\t\tVAR_1->msg       = VAR_2;\n\t\tVAR_1->pid       = nng_msg_get_pipe(VAR_1->msg);\n\t\tVAR_1->cparam    = nng_msg_get_conn_param(VAR_1->msg);\n\t\tVAR_1->proto_ver = conn_param_get_protover(VAR_1->cparam);\n\t\tVAR_1->flag      = nng_msg_cmd_type(VAR_2);\n\n\t\tif (VAR_1->flag == VAR_17) {\n\t\t\tVAR_3 = VAR_1->msg;\n\t\t\tVAR_1->msg_ret = NULL;\n\n\t\t\tif ((VAR_1->sub_pkt = nng_alloc(\n\t\t\t         sizeof(VAR_18))) == NULL)\n\t\t\t\tlog_error(\"nng_alloc\");\n\t\t\tmemset(VAR_1->sub_pkt, '\\0', sizeof(VAR_18));\n\n\t\t\tif ((VAR_4 = decode_sub_msg(VAR_1)) != 0 ||\n\t\t\t    (VAR_4 = sub_ctx_handle(VAR_1)) != 0) {\n\t\t\t\tVAR_1->code = VAR_4;\n\t\t\t\tlog_error(\"sub_handler: [%d]\", VAR_4);\n\t\t\t}\n\n\t\t\t/* COMMENT_5 */\n\t\t\tif (VAR_1->code != VAR_19) {\n\t\t\t\tif (VAR_1->msg_ret)\n\t\t\t\t\tcvector_free(VAR_1->msg_ret);\n\t\t\t\tif (VAR_1->sub_pkt)\n\t\t\t\t\tsub_pkt_free(VAR_1->sub_pkt);\n\t\t\t\t/* COMMENT_6 */\n\t\t\t\tconn_param_free(VAR_1->cparam);\n\n\t\t\t\tVAR_1->state = VAR_20;\n\t\t\t\tnng_aio_finish(VAR_1->aio, 0);\n\t\t\t\t/* COMMENT_7 */\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* COMMENT_8 */\n\t\t\tif (0 != (VAR_4 = encode_suback_msg(VAR_3, VAR_1)))\n\t\t\t\tlog_error(\"error in encode suback: [%d]\", VAR_4);\n\n\t\t\tsub_pkt_free(VAR_1->sub_pkt);\n\t\t\t/* COMMENT_9 */\n\t\t\tVAR_1->msg = NULL;\n\t\t\tif (VAR_1->msg_ret) {\n\t\t\t\tlog_debug(\"retain msg [%p] size [%ld] \\n\",\n\t\t\t\t    VAR_1->msg_ret,\n\t\t\t\t    cvector_size(VAR_1->msg_ret));\n\t\t\t\tfor (int VAR_21 = 0;\n\t\t\t\t     VAR_21 < cvector_size(VAR_1->msg_ret) &&\n\t\t\t\t     check_msg_exp(VAR_1->msg_ret[VAR_21],\n\t\t\t\t         nng_mqtt_msg_get_publish_property(\n\t\t\t\t             VAR_1->msg_ret[VAR_21]));\n\t\t\t\t     VAR_21++) {\n\t\t\t\t\tnng_msg *VAR_22 = VAR_1->msg_ret[VAR_21];\n\t\t\t\t\tif (!VAR_1->config->sqlite.enable) {\n\t\t\t\t\t\t/* COMMENT_10 */\n\t\t\t\t\t\t/* COMMENT_11 */\n\t\t\t\t\t\tnng_msg_clone(VAR_22);\n\t\t\t\t\t}\n\t\t\t\t\tVAR_1->msg = VAR_22;\n\t\t\t\t\tnng_aio_set_msg(VAR_1->aio, VAR_1->msg);\n\t\t\t\t\tnng_aio_set_prov_data(VAR_1->aio, &VAR_1->pid.id);\n\t\t\t\t\tnng_ctx_send(VAR_1->ctx, VAR_1->aio);\n\t\t\t\t\tnng_msg_free(VAR_22);\n\t\t\t\t}\n\t\t\t\tcvector_free(VAR_1->msg_ret);\n\t\t\t}\n\t\t\tnng_msg_set_cmd_type(VAR_3, VAR_23);\n\t\t\tnng_aio_set_prov_data(VAR_1->aio, &VAR_1->pid.id);\n\t\t\tnng_aio_set_msg(VAR_1->aio, VAR_3);\n\t\t\tVAR_1->msg   = NULL;\n\t\t\tVAR_1->state = VAR_24;\n\t\t\tnng_ctx_send(VAR_1->ctx, VAR_1->aio);\n\t\t\tVAR_3 = NULL;\n\t\t\tnng_aio_finish(VAR_1->aio, 0);\n\t\t\t/* COMMENT_12 */\n\t\t\tbreak;\n\t\t} else if (VAR_1->flag == VAR_25) {\n\t\t\tVAR_3 = VAR_1->msg;\n\t\t\tif ((VAR_1->unsub_pkt = nng_alloc(\n\t\t\t         sizeof(VAR_26))) == NULL)\n\t\t\t\tlog_error(\"nng_alloc\");\n\n\t\t\tif ((VAR_4 = decode_unsub_msg(VAR_1)) != 0 ||\n\t\t\t    (VAR_4 = unsub_ctx_handle(VAR_1)) != 0) {\n\t\t\t\tlog_error(\"unsub_handler [%d]\", VAR_4);\n\t\t\t}\n\n\t\t\tif (0 != (VAR_4 = encode_unsuback_msg(VAR_3, VAR_1)))\n\t\t\t\tlog_error(\"in unsuback [%d]\", VAR_4);\n\n\t\t\t/* COMMENT_13 */\n\t\t\tunsub_pkt_free(VAR_1->unsub_pkt);\n\t\t\tnng_aio_set_prov_data(VAR_1->aio, &VAR_1->pid.id);\n\t\t\tnng_aio_set_msg(VAR_1->aio, VAR_1->msg);\n\t\t\tVAR_1->msg   = NULL;\n\t\t\tVAR_1->state = VAR_24;\n\t\t\tnng_ctx_send(VAR_1->ctx, VAR_1->aio);\n\t\t\tVAR_3 = NULL;\n\t\t\tnng_aio_finish(VAR_1->aio, 0);\n\t\t\t/* COMMENT_14 */\n\t\t\tbreak;\n\t\t} else if (VAR_1->flag == VAR_13) {\n\t\t\t/* COMMENT_15 */\n\t\t\tif (VAR_1->proto_ver == 5) {\n\t\t\t\tnng_msg_set_cmd_type(VAR_2, VAR_27);\n\t\t\t} else {\n\t\t\t\tnng_msg_set_cmd_type(VAR_2, VAR_13);\n\t\t\t}\n\t\t\tVAR_1->code = handle_pub(\n\t\t\t    VAR_1, VAR_1->pipe_ct, VAR_1->proto_ver, false);\n\t\t\tif (VAR_1->proto == VAR_14 ||\n\t\t\t    VAR_1->proto == VAR_15) {\n\t\t\t\tnng_msg *VAR_28;\n\t\t\t\t/* COMMENT_16 */\n\t\t\t\tnng_msg_alloc(&VAR_28, 0);\n\t\t\t\tnng_aio_set_msg(VAR_1->aio, VAR_28);\n\t\t\t\tif (VAR_1->code == VAR_19)\n\t\t\t\t\tVAR_1->state = VAR_29;\n\t\t\t\telse\n\t\t\t\t\tVAR_1->state = VAR_24;\n\t\t\t\tnng_ctx_send(VAR_1->extra_ctx, VAR_1->aio);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (VAR_1->code != VAR_19) {\n\t\t\t\t/* COMMENT_17 */\n\t\t\t\tif (VAR_1->proto != VAR_8) {\n\t\t\t\t\tVAR_1->state = VAR_24;\n\t\t\t\t\tnng_aio_finish(VAR_1->aio, 0);\n\t\t\t\t\t/* COMMENT_18 */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tVAR_1->state = VAR_20;\n\t\t\t\tfree_pub_packet(VAR_1->pub_packet);\n\t\t\t\tVAR_1->pub_packet = NULL;\n\t\t\t\tcvector_free(VAR_1->pipe_ct->msg_infos);\n\t\t\t\t/* COMMENT_6 */\n\t\t\t\tconn_param_free(VAR_1->cparam);\n\t\t\t\tnng_aio_finish(VAR_1->aio, 0);\n\t\t\t\t/* COMMENT_18 */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (VAR_1->flag == VAR_12) {\n\t\t\tuint8_t *VAR_30        = nng_msg_body(VAR_1->msg);\n\t\t\tuint8_t  VAR_31 = *(VAR_30 + 1);\n\t\t\tif (VAR_1->proto == VAR_8) {\n\t\t\t\t/* COMMENT_19 */\n\t\t\t\tnng_aio_set_prov_data(VAR_1->aio, &VAR_1->pid.id);\n\t\t\t\t/* COMMENT_20 */\n\t\t\t\tnng_msg_clone(VAR_1->msg);\n\t\t\t\tnng_aio_set_msg(VAR_1->aio, VAR_1->msg);\n\t\t\t\tnng_ctx_send(VAR_1->ctx, VAR_1->aio);\n\t\t\t}\n\t\t\tVAR_3 = nano_msg_notify_connect(VAR_1->cparam, VAR_31);\n\t\t\twebhook_entry(VAR_1, VAR_31);\n\t\t\t/* COMMENT_21 */\n\t\t\tnng_msg_set_cmd_type(VAR_3, VAR_13);\n\t\t\tVAR_1->flag = VAR_13;\n\t\t\tnng_msg_free(VAR_1->msg);\n\t\t\tVAR_1->msg = VAR_3;\n\t\t\thandle_pub(VAR_1, VAR_1->pipe_ct,\n\t\t\t    VAR_32, true);\n\t\t\t/* COMMENT_22 */\n\t\t\t/* COMMENT_23 */\n\t\t} else if (VAR_1->flag == VAR_33) {\n\t\t\t/* COMMENT_24 */\n\t\t\twebhook_entry(VAR_1, 0);\n\t\t\tnng_msg_set_cmd_type(VAR_2, VAR_13);\n\t\t\tVAR_1->flag = VAR_13;\n\t\t\thandle_pub(VAR_1, VAR_1->pipe_ct,\n\t\t\t    VAR_32, true);\n\t\t\t/* COMMENT_25 */\n\t\t\t/* COMMENT_26 */\n\t\t\t/* COMMENT_27 */\n\t\t\t/* COMMENT_28 */\n\t\t\tif (dbhash_check_id(VAR_1->pid.id)) {\n\t\t\t\tdestroy_sub_client(VAR_1->pid.id, VAR_1->db);\n\t\t\t}\n\t\t\tif (conn_param_get_will_flag(VAR_1->cparam) == 0 ||\n\t\t\t    !conn_param_get_will_topic(VAR_1->cparam) ||\n\t\t\t    !conn_param_get_will_msg(VAR_1->cparam)) {\n\t\t\t\t/* COMMENT_29 */\n\t\t\t\tconn_param_free(VAR_1->cparam);\n\t\t\t} else {\n\t\t\t\t/* COMMENT_30 */\n\t\t\t\t/* COMMENT_31 */\n\t\t\t\tVAR_1->state = VAR_34;\n\t\t\t\t/* COMMENT_32 */\n\t\t\t\tnng_aio_finish(VAR_1->aio, 0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tVAR_1->state = VAR_29;\n\t\tnng_aio_finish(VAR_1->aio, 0);\n\t\tbreak;\n\tcase VAR_29:\n\t\t/* COMMENT_33 */\n\t\tlog_debug(\"WAIT ^^^^ ctx%d ^^^^\", VAR_1->ctx.id);\n\t\tif (nng_msg_get_type(VAR_1->msg) == VAR_13) {\n\t\t\tif ((VAR_4 = nng_aio_result(VAR_1->aio)) != 0) {\n\t\t\t\tlog_error(\"WAIT nng aio result error: %d\", VAR_4);\n\t\t\t\tnng_fatal(\"WAIT nng_ctx_recv/send\", VAR_4);\n\t\t\t}\n\t\t\tVAR_3      = VAR_1->msg; /* COMMENT_34 */\n\t\t\tVAR_35(mqtt_msg_info) VAR_36;\n\t\t\tVAR_36 = VAR_1->pipe_ct->msg_infos;\n\n\t\t\tlog_trace(\"total pipes: %ld\", cvector_size(VAR_36));\n\t\t\tif (cvector_size(VAR_36))\n\t\t\t\tif (encode_pub_message(VAR_3, VAR_1, VAR_37))\n\t\t\t\t\tfor (int VAR_21 = 0; VAR_21 < cvector_size(VAR_36) && VAR_4== 0; ++VAR_21) {\n\t\t\t\t\t\tVAR_5 = &VAR_36[VAR_21];\n\t\t\t\t\t\tnng_msg_clone(VAR_3);\n\t\t\t\t\t\tVAR_1->pid.id = VAR_5->pipe;\n\t\t\t\t\t\tnng_aio_set_prov_data(VAR_1->aio, &VAR_1->pid.id);\n\t\t\t\t\t\tVAR_1->msg = VAR_3;\n\t\t\t\t\t\tnng_aio_set_msg(VAR_1->aio, VAR_1->msg);\n\t\t\t\t\t\tnng_ctx_send(VAR_1->ctx, VAR_1->aio);\n\t\t\t\t\t}\n\t\t\tVAR_1->msg = VAR_3;\n\n\t\t\t/* COMMENT_35 */\n\t\t\tif (VAR_1->config->bridge_mode) {\n\t\t\t\tbridge_handler(VAR_1);\n#if defined(VAR_38)\n\t\t\t\taws_bridge_forward(VAR_1);\n#endif\n\t\t\t}\n\t\t\t/* COMMENT_36 */\n\t\t\tconf_web_hook *VAR_39   = &(VAR_1->config->web_hook);\n\t\t\tuint8_t VAR_40 = VAR_41;\n#if defined(VAR_42)\n\t\t\tVAR_40 = VAR_1->config->rule_eng.option;\n#endif\n\t\t\tif (VAR_39->enable || VAR_40 != VAR_41) {\n\t\t\t\tVAR_1->state = VAR_24;\n\t\t\t\tnng_aio_finish(VAR_1->aio, 0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnng_msg_free(VAR_1->msg);\n\t\t\tVAR_3 = NULL;\n\t\t\tVAR_1->msg = NULL;\n\t\t\t/* COMMENT_6 */\n\t\t\tconn_param_free(VAR_1->cparam);\n\t\t\tfree_pub_packet(VAR_1->pub_packet);\n\t\t\tVAR_1->pub_packet = NULL;\n\t\t\tcvector_free(VAR_36);\n\t\t\tVAR_1->pipe_ct->msg_infos = NULL;\n\t\t\tinit_pipe_content(VAR_1->pipe_ct);\n\t\t\tVAR_1->state = VAR_7;\n\t\t\tif (VAR_1->proto != VAR_8) {\n\t\t\t\tnng_ctx_recv(VAR_1->extra_ctx, VAR_1->aio);\n\t\t\t} else {\n\t\t\t\tnng_ctx_recv(VAR_1->ctx, VAR_1->aio);\n\t\t\t}\n\t\t} else if (nng_msg_cmd_type(VAR_1->msg) == VAR_43 ||\n\t\t    nng_msg_cmd_type(VAR_1->msg) == VAR_44 ||\n\t\t    nng_msg_cmd_type(VAR_1->msg) == VAR_45) {\n\t\t\tnng_msg_free(VAR_1->msg);\n\t\t\tVAR_1->msg   = NULL;\n\t\t\tVAR_1->state = VAR_7;\n\t\t\tnng_ctx_recv(VAR_1->ctx, VAR_1->aio);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tlog_debug(\"broker has nothing to do\");\n\t\t\tif (VAR_1->msg != NULL)\n\t\t\t\tnng_msg_free(VAR_1->msg);\n\t\t\tVAR_1->msg   = NULL;\n\t\t\tVAR_1->state = VAR_7;\n\t\t\tnng_ctx_recv(VAR_1->ctx, VAR_1->aio);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase VAR_24:\n\t\tlog_debug(\"SEND ^^^^ ctx%d ^^^^\", VAR_1->ctx.id);\n#if defined(VAR_42)\n\t\tif (VAR_1->flag == VAR_13 && VAR_1->config->rule_eng.option != VAR_41) {\n\t\t\trule_engine_insert_sql(VAR_1);\n\t\t}\n#endif\n\t\t/* COMMENT_37 */\n\t\twebhook_entry(VAR_1, 0);\n\n\t\tif (NULL != VAR_1->msg) {\n\t\t\tnng_msg_free(VAR_1->msg);\n\t\t\tVAR_1->msg = NULL;\n\t\t}\n\t\tif ((VAR_4 = nng_aio_result(VAR_1->aio)) != 0) {\n\t\t\tnng_fatal(\"SEND nng_ctx_send\", VAR_4);\n\t\t}\n\t\tif (VAR_1->pub_packet != NULL) {\n\t\t\tfree_pub_packet(VAR_1->pub_packet);\n\t\t\tVAR_1->pub_packet = NULL;\n\t\t}\n\t\tif (VAR_1->pipe_ct->msg_infos != NULL) {\n\t\t\tcvector_free(VAR_1->pipe_ct->msg_infos);\n\t\t\tVAR_1->pipe_ct->msg_infos = NULL;\n\t\t\tinit_pipe_content(VAR_1->pipe_ct);\n\t\t}\n\t\t/* COMMENT_6 */\n\t\tconn_param_free(VAR_1->cparam);\n\t\tVAR_1->state = VAR_7;\n\t\tVAR_1->flag  = 0;\n\t\tif (VAR_1->proto == VAR_8) {\n\t\t\tnng_ctx_recv(VAR_1->ctx, VAR_1->aio);\n\t\t} else{\n\t\t\tnng_ctx_recv(VAR_1->extra_ctx, VAR_1->aio);\n\t\t}\n\t\tbreak;\n\tcase VAR_34:\n\t\tlog_debug(\"END ^^^^ ctx%d ^^^^ \", VAR_1->ctx.id);\n\t\tif (nng_msg_get_type(VAR_1->msg) == VAR_13) {\n\t\t\tif ((VAR_4 = nng_aio_result(VAR_1->aio)) != 0) {\n\t\t\t\tlog_error(\"WAIT nng aio result error: %d\", VAR_4);\n\t\t\t\tnng_fatal(\"WAIT nng_ctx_recv/send\", VAR_4);\n\t\t\t}\n\t\t\tVAR_3      = VAR_1->msg; /* COMMENT_34 */\n\t\t\tVAR_1->msg = NULL;\n\n\t\t\tVAR_35(mqtt_msg_info) VAR_36;\n\t\t\tVAR_36 = VAR_1->pipe_ct->msg_infos;\n\n\t\t\tlog_debug(\"total pipes: %ld\", cvector_size(VAR_36));\n\t\t\t/* COMMENT_38 */\n\t\t\tif (cvector_size(VAR_36))\n\t\t\t\tif (encode_pub_message(VAR_3, VAR_1, VAR_37))\n\t\t\t\t\tfor (int VAR_21=0; VAR_21<cvector_size(VAR_36); ++VAR_21) {\n\t\t\t\t\t\tVAR_5 = &VAR_36[VAR_21];\n\t\t\t\t\t\tnng_msg_clone(VAR_3);\n\t\t\t\t\t\tVAR_1->pid.id = VAR_5->pipe;\n\t\t\t\t\t\tnng_aio_set_prov_data(VAR_1->aio, &VAR_1->pid.id);\n\t\t\t\t\t\tVAR_1->msg = VAR_3;\n\t\t\t\t\t\tnng_aio_set_msg(VAR_1->aio, VAR_1->msg);\n\t\t\t\t\t\tnng_ctx_send(VAR_1->ctx, VAR_1->aio);\n\t\t\t\t\t}\n\t\t\twebhook_entry(VAR_1, 0);\n\t\t\tnng_msg_free(VAR_3);\n\t\t\tVAR_3 = NULL;\n\t\t\tVAR_1->msg = NULL;\n\t\t\tfree_pub_packet(VAR_1->pub_packet);\n\t\t\tVAR_1->pub_packet = NULL;\n\t\t\tcvector_free(VAR_1->pipe_ct->msg_infos);\n\t\t\tVAR_1->pipe_ct->msg_infos = NULL;\n\t\t\tinit_pipe_content(VAR_1->pipe_ct);\n\n\t\t\t/* COMMENT_39 */\n\t\t\tif (conn_param_get_will_flag(VAR_1->cparam) &&\n\t\t\t    (VAR_2 = nano_pubmsg_composer(&VAR_2,\n\t\t\t         conn_param_get_will_retain(VAR_1->cparam),\n\t\t\t         conn_param_get_will_qos(VAR_1->cparam),\n\t\t\t         (mqtt_string *) conn_param_get_will_msg(\n\t\t\t             VAR_1->cparam),\n\t\t\t         (mqtt_string *) conn_param_get_will_topic(\n\t\t\t             VAR_1->cparam),\n\t\t\t         conn_param_get_protover(VAR_1->cparam),\n\t\t\t         nng_clock())) != NULL) {\n\t\t\t\tVAR_1->msg = VAR_2;\n\t\t\t\tVAR_1->flag = VAR_13;\n\t\t\t\t/* COMMENT_15 */\n\t\t\t\tif (conn_param_get_protover(VAR_1->cparam) == 5) {\n\t\t\t\t\tproperty *VAR_46 =\n\t\t\t\t\t    conn_param_get_will_property(\n\t\t\t\t\t        VAR_1->cparam);\n\t\t\t\t\tnng_msg_set_cmd_type(\n\t\t\t\t\t    VAR_2, VAR_27);\n\t\t\t\t\thandle_pub(VAR_1, VAR_1->pipe_ct,\n\t\t\t\t\t    VAR_47, false);\n\t\t\t\t\tVAR_1->pub_packet->var_header.publish\n\t\t\t\t\t    .properties = property_pub_by_will(\n\t\t\t\t\t    VAR_46);\n\t\t\t\t\tVAR_1->pub_packet->var_header.publish\n\t\t\t\t\t    .prop_len = get_properties_len(\n\t\t\t\t\t    VAR_1->pub_packet->var_header\n\t\t\t\t\t        .publish.properties);\n\t\t\t\t} else {\n\t\t\t\t\tnng_msg_set_cmd_type(VAR_2, VAR_13);\n\t\t\t\t\thandle_pub(VAR_1, VAR_1->pipe_ct,\n\t\t\t\t\t    VAR_32, false);\n\t\t\t\t}\n\t\t\t\tVAR_1->state = VAR_29;\n\t\t\t\tnng_aio_finish(VAR_1->aio, 0);\n\t\t\t} else {\n\t\t\t\t/* COMMENT_40 */\n\t\t\t\tconn_param_free(VAR_1->cparam);\n\t\t\t\tif (VAR_1->msg != NULL)\n\t\t\t\t\tnng_msg_free(VAR_1->msg);\n\t\t\t\tVAR_1->msg = NULL;\n\t\t\t\tVAR_1->state = VAR_7;\n\t\t\t\tif (VAR_1->proto == VAR_8) {\n\t\t\t\t\tnng_ctx_recv(VAR_1->ctx, VAR_1->aio);\n\t\t\t\t} else {\n\t\t\t\t\tnng_ctx_recv(VAR_1->extra_ctx, VAR_1->aio);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconn_param_free(VAR_1->cparam);\n\t\tbreak;\n\tcase VAR_20:\n\t\tlog_debug(\" CLOSE ^^^^ ctx%d ^^^^\", VAR_1->ctx.id);\n\t\tVAR_3 = nano_dismsg_composer(VAR_1->code, NULL, NULL, NULL);\n\t\tnng_msg_free(VAR_1->msg);\n\t\tVAR_1->msg = VAR_3;\n\t\t/* COMMENT_41 */\n\t\tnng_aio_set_prov_data(VAR_1->aio, &VAR_1->pid.id);\n\t\t/* COMMENT_20 */\n\t\tnng_aio_set_msg(VAR_1->aio, VAR_1->msg);\n\t\tnng_ctx_send(VAR_1->ctx, VAR_1->aio); /* COMMENT_42 */\n\n\t\t/* COMMENT_43 */\n\t\tVAR_1->code = VAR_19;\n\t\tVAR_1->state = VAR_7;\n\t\tnng_ctx_recv(VAR_1->ctx, VAR_1->aio);\n\t\tbreak;\n\tdefault:\n\t\tnng_fatal(\"bad state!\", VAR_48);\n\t\tbreak;\n\t}\n}",
  "func_graph_path": "nanomq/5f57ef45ccfd0f47d815eb62f5f2a619ba7d0633/broker.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -132,6 +132,7 @@\n \t\t\t\t\tnng_aio_set_msg(work->aio, work->msg);\n \t\t\t\t\tnng_aio_set_prov_data(work->aio, &work->pid.id);\n \t\t\t\t\tnng_ctx_send(work->ctx, work->aio);\n+\t\t\t\t\tnng_msg_free(m);\n \t\t\t\t}\n \t\t\t\tcvector_free(work->msg_ret);\n \t\t\t}",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "\t\t\t\t\tnng_msg_free(m);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/nanomq/nanomq/pull/1187",
  "description": {
    "pr_info": {
      "title": "Fix data racing on retain msg",
      "number": 1187
    },
    "comment": [
      "This is a rarely triggered issue, hardly seen in real business scenario"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "The commit addresses a data race condition, which is a security issue. The code modification prevents a potential exploit by correctly freeing a message.\n\n**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95"
}