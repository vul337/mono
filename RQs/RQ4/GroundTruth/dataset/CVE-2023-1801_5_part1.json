{
  "cve_id": "CVE-2023-1801",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "the-tcpdump-group/tcpdump",
  "commit_msg": "Have a common routine for converting dates and times to strings.\n\nHave a routine that takes a buffer, a strftime format, and a struct tm *\nas arguments, and:\n\n* checks whether the struct tm * is null and, if so, returns a string\nindicating that the date and time couldn't be converted;\n\n* otherwise, passes it to strftime(), along with the buffer and the\nformat argument and, if strftime() returns 0, meaning the string didn't\nfit into the buffer and thus that the buffer's contents are undefined,\nreturns a string indicating that the date and time didn't fit into the\nbuffer;\n\n* otherwise, returns a pointer to the buffer.\n\nCall that routine instead of directly calling strftime() in printers;\nthat prevents printing a buffer with undefined data if the buffer isn't\nbig enough for the string.\n\nAlso, when generating file names using an strftime format, check the\nreturn value of strftime() to make sure the buffer didn't overflow.",
  "commit_hash": "7578e1c04ee280dda50c4c2813e7d55f539c6501",
  "git_url": "https://github.com/the-tcpdump-group/tcpdump/commit/7578e1c04ee280dda50c4c2813e7d55f539c6501",
  "file_path": "smbutil.c",
  "func_name": "smb_fdata1",
  "func_before": "static const u_char *\nsmb_fdata1(netdissect_options *ndo,\n           const u_char *buf, const char *fmt, const u_char *maxbuf,\n           int unicodestr)\n{\n    int reverse = 0;\n    const char *attrib_fmt = \"READONLY|HIDDEN|SYSTEM|VOLUME|DIR|ARCHIVE|\";\n    char strbuf[MAX_UNISTR_SIZE+1];\n\n    while (*fmt && buf<maxbuf) {\n\tswitch (*fmt) {\n\tcase 'a':\n\t    write_bits(ndo, GET_U_1(buf), attrib_fmt);\n\t    buf++;\n\t    fmt++;\n\t    break;\n\n\tcase 'A':\n\t    write_bits(ndo, GET_LE_U_2(buf), attrib_fmt);\n\t    buf += 2;\n\t    fmt++;\n\t    break;\n\n\tcase '{':\n\t  {\n\t    char bitfmt[128];\n\t    char *p;\n\t    u_int l;\n\n\t    p = strchr(++fmt, '}');\n\t    l = ND_BYTES_BETWEEN(p, fmt);\n\n\t    if (l > sizeof(bitfmt) - 1)\n\t\tl = sizeof(bitfmt)-1;\n\n\t    strncpy(bitfmt, fmt, l);\n\t    bitfmt[l] = '\\0';\n\t    fmt = p + 1;\n\t    write_bits(ndo, GET_U_1(buf), bitfmt);\n\t    buf++;\n\t    break;\n\t  }\n\n\tcase 'P':\n\t  {\n\t    int l = atoi(fmt + 1);\n\t    ND_TCHECK_LEN(buf, l);\n\t    buf += l;\n\t    fmt++;\n\t    while (ND_ASCII_ISDIGIT(*fmt))\n\t\tfmt++;\n\t    break;\n\t  }\n\tcase 'r':\n\t    reverse = !reverse;\n\t    fmt++;\n\t    break;\n\tcase 'b':\n\t  {\n\t    unsigned int x;\n\t    x = GET_U_1(buf);\n\t    ND_PRINT(\"%u (0x%x)\", x, x);\n\t    buf += 1;\n\t    fmt++;\n\t    break;\n\t  }\n\tcase 'd':\n\t  {\n\t    int x;\n\t    x = reverse ? GET_BE_S_2(buf) :\n\t\t\t  GET_LE_S_2(buf);\n\t    ND_PRINT(\"%d (0x%x)\", x, x);\n\t    buf += 2;\n\t    fmt++;\n\t    break;\n\t  }\n\tcase 'D':\n\t  {\n\t    int x;\n\t    x = reverse ? GET_BE_S_4(buf) :\n\t\t\t  GET_LE_S_4(buf);\n\t    ND_PRINT(\"%d (0x%x)\", x, x);\n\t    buf += 4;\n\t    fmt++;\n\t    break;\n\t  }\n\tcase 'L':\n\t  {\n\t    uint64_t x;\n\t    x = reverse ? GET_BE_U_8(buf) :\n\t\t\t  GET_LE_U_8(buf);\n\t    ND_PRINT(\"%\" PRIu64 \" (0x%\" PRIx64 \")\", x, x);\n\t    buf += 8;\n\t    fmt++;\n\t    break;\n\t  }\n\tcase 'u':\n\t  {\n\t    unsigned int x;\n\t    x = reverse ? GET_BE_U_2(buf) :\n\t\t\t  GET_LE_U_2(buf);\n\t    ND_PRINT(\"%u (0x%x)\", x, x);\n\t    buf += 2;\n\t    fmt++;\n\t    break;\n\t  }\n\tcase 'U':\n\t  {\n\t    unsigned int x;\n\t    x = reverse ? GET_BE_U_4(buf) :\n\t\t\t  GET_LE_U_4(buf);\n\t    ND_PRINT(\"%u (0x%x)\", x, x);\n\t    buf += 4;\n\t    fmt++;\n\t    break;\n\t  }\n\tcase 'M':\n\t  {\n\t    /* Weird mixed-endian length values in 64-bit locks */\n\t    uint32_t x1, x2;\n\t    uint64_t x;\n\t    ND_TCHECK_8(buf);\n\t    x1 = reverse ? GET_BE_U_4(buf) :\n\t\t\t   GET_LE_U_4(buf);\n\t    x2 = reverse ? GET_BE_U_4(buf + 4) :\n\t\t\t   GET_LE_U_4(buf + 4);\n\t    x = (((uint64_t)x1) << 32) | x2;\n\t    ND_PRINT(\"%\" PRIu64 \" (0x%\" PRIx64 \")\", x, x);\n\t    buf += 8;\n\t    fmt++;\n\t    break;\n\t  }\n\tcase 'B':\n\t  {\n\t    unsigned int x;\n\t    x = GET_U_1(buf);\n\t    ND_PRINT(\"0x%X\", x);\n\t    buf += 1;\n\t    fmt++;\n\t    break;\n\t  }\n\tcase 'w':\n\t  {\n\t    unsigned int x;\n\t    x = reverse ? GET_BE_U_2(buf) :\n\t\t\t  GET_LE_U_2(buf);\n\t    ND_PRINT(\"0x%X\", x);\n\t    buf += 2;\n\t    fmt++;\n\t    break;\n\t  }\n\tcase 'W':\n\t  {\n\t    unsigned int x;\n\t    x = reverse ? GET_BE_U_4(buf) :\n\t\t\t  GET_LE_U_4(buf);\n\t    ND_PRINT(\"0x%X\", x);\n\t    buf += 4;\n\t    fmt++;\n\t    break;\n\t  }\n\tcase 'l':\n\t  {\n\t    fmt++;\n\t    switch (*fmt) {\n\n\t    case 'b':\n\t\tstringlen = GET_U_1(buf);\n\t\tstringlen_is_set = 1;\n\t\tND_PRINT(\"%u\", stringlen);\n\t\tbuf += 1;\n\t\tbreak;\n\n\t    case 'd':\n\t    case 'u':\n\t\tstringlen = reverse ? GET_BE_U_2(buf) :\n\t\t\t\t      GET_LE_U_2(buf);\n\t\tstringlen_is_set = 1;\n\t\tND_PRINT(\"%u\", stringlen);\n\t\tbuf += 2;\n\t\tbreak;\n\n\t    case 'D':\n\t    case 'U':\n\t\tstringlen = reverse ? GET_BE_U_4(buf) :\n\t\t\t\t      GET_LE_U_4(buf);\n\t\tstringlen_is_set = 1;\n\t\tND_PRINT(\"%u\", stringlen);\n\t\tbuf += 4;\n\t\tbreak;\n\t    }\n\t    fmt++;\n\t    break;\n\t  }\n\tcase 'S':\n\tcase 'R':\t/* like 'S', but always ASCII */\n\t  {\n\t    /*XXX unistr() */\n\t    buf = unistr(ndo, &strbuf, buf, 0, 1, (*fmt == 'R') ? 0 : unicodestr);\n\t    ND_PRINT(\"%s\", strbuf);\n\t    if (buf == NULL)\n\t\tgoto trunc;\n\t    fmt++;\n\t    break;\n\t  }\n\tcase 'Z':\n\tcase 'Y':\t/* like 'Z', but always ASCII */\n\t  {\n\t    if (GET_U_1(buf) != 4 && GET_U_1(buf) != 2) {\n\t\tND_PRINT(\"Error! ASCIIZ buffer of type %u\", GET_U_1(buf));\n\t\treturn maxbuf;\t/* give up */\n\t    }\n\t    buf = unistr(ndo, &strbuf, buf + 1, 0, 1, (*fmt == 'Y') ? 0 : unicodestr);\n\t    ND_PRINT(\"%s\", strbuf);\n\t    if (buf == NULL)\n\t\tgoto trunc;\n\t    fmt++;\n\t    break;\n\t  }\n\tcase 's':\n\t  {\n\t    int l = atoi(fmt + 1);\n\t    ND_TCHECK_LEN(buf, l);\n\t    ND_PRINT(\"%-*.*s\", l, l, buf);\n\t    buf += l;\n\t    fmt++;\n\t    while (ND_ASCII_ISDIGIT(*fmt))\n\t\tfmt++;\n\t    break;\n\t  }\n\tcase 'c':\n\t  {\n            if (!stringlen_is_set) {\n                ND_PRINT(\"{stringlen not set}\");\n                goto trunc;\n            }\n\t    ND_TCHECK_LEN(buf, stringlen);\n\t    ND_PRINT(\"%-*.*s\", (int)stringlen, (int)stringlen, buf);\n\t    buf += stringlen;\n\t    fmt++;\n\t    while (ND_ASCII_ISDIGIT(*fmt))\n\t\tfmt++;\n\t    break;\n\t  }\n\tcase 'C':\n\t  {\n            if (!stringlen_is_set) {\n                ND_PRINT(\"{stringlen not set}\");\n                goto trunc;\n            }\n\t    buf = unistr(ndo, &strbuf, buf, stringlen, 0, unicodestr);\n\t    ND_PRINT(\"%s\", strbuf);\n\t    if (buf == NULL)\n\t\tgoto trunc;\n\t    fmt++;\n\t    break;\n\t  }\n\tcase 'h':\n\t  {\n\t    int l = atoi(fmt + 1);\n\t    ND_TCHECK_LEN(buf, l);\n\t    while (l--) {\n\t\tND_PRINT(\"%02x\", GET_U_1(buf));\n\t\tbuf++;\n\t    }\n\t    fmt++;\n\t    while (ND_ASCII_ISDIGIT(*fmt))\n\t\tfmt++;\n\t    break;\n\t  }\n\tcase 'n':\n\t  {\n\t    int t = atoi(fmt+1);\n\t    char nbuf[255];\n\t    int name_type;\n\t    int len;\n\n\t    switch (t) {\n\t    case 1:\n\t\tname_type = name_extract(ndo, startbuf, ND_BYTES_BETWEEN(buf, startbuf),\n\t\t    maxbuf, nbuf);\n\t\tif (name_type < 0)\n\t\t    goto trunc;\n\t\tlen = name_len(ndo, buf, maxbuf);\n\t\tif (len < 0)\n\t\t    goto trunc;\n\t\tbuf += len;\n\t\tND_PRINT(\"%-15.15s NameType=0x%02X (%s)\", nbuf, name_type,\n\t\t    name_type_str(name_type));\n\t\tbreak;\n\t    case 2:\n\t\tname_type = GET_U_1(buf + 15);\n\t\tND_PRINT(\"%-15.15s NameType=0x%02X (%s)\", buf, name_type,\n\t\t    name_type_str(name_type));\n\t\tbuf += 16;\n\t\tbreak;\n\t    }\n\t    fmt++;\n\t    while (ND_ASCII_ISDIGIT(*fmt))\n\t\tfmt++;\n\t    break;\n\t  }\n\tcase 'T':\n\t  {\n\t    time_t t;\n\t    struct tm *lt;\n\t    const char *tstring;\n\t    char buffer[sizeof(\"Www Mmm dd hh:mm:ss yyyyy\\n\")];\n\t    uint32_t x;\n\n\t    switch (atoi(fmt + 1)) {\n\t    case 1:\n\t\tx = GET_LE_U_4(buf);\n\t\tif (x == 0 || x == 0xFFFFFFFF)\n\t\t    t = 0;\n\t\telse\n\t\t    t = make_unix_date(ndo, buf);\n\t\tbuf += 4;\n\t\tbreak;\n\t    case 2:\n\t\tx = GET_LE_U_4(buf);\n\t\tif (x == 0 || x == 0xFFFFFFFF)\n\t\t    t = 0;\n\t\telse\n\t\t    t = make_unix_date2(ndo, buf);\n\t\tbuf += 4;\n\t\tbreak;\n\t    case 3:\n\t\tND_TCHECK_8(buf);\n\t\tt = interpret_long_date(ndo, buf);\n\t\tbuf += 8;\n\t\tbreak;\n\t    default:\n\t\tt = 0;\n\t\tbreak;\n\t    }\n\t    if (t != 0) {\n\t\tlt = localtime(&t);\n\t\tif (lt != NULL) {\n\t\t    strftime(buffer, sizeof(buffer), \"%a %b %e %T %Y%n\", lt);\n\t\t    tstring = buffer;\n\t\t}\n\t\telse\n\t\t    tstring = \"(Can't convert time)\\n\";\n\t    } else\n\t\ttstring = \"NULL\\n\";\n\t    ND_PRINT(\"%s\", tstring);\n\t    fmt++;\n\t    while (ND_ASCII_ISDIGIT(*fmt))\n\t\tfmt++;\n\t    break;\n\t  }\n\tdefault:\n\t    ND_PRINT(\"%c\", *fmt);\n\t    fmt++;\n\t    break;\n\t}\n    }\n\n    if (buf >= maxbuf && *fmt)\n\tND_PRINT(\"END OF BUFFER\\n\");\n\n    return(buf);\n\ntrunc:\n    nd_print_trunc(ndo);\n    return(NULL);\n}",
  "abstract_func_before": "static const u_char *\nsmb_fdata1(netdissect_options *VAR_0,\n           const u_char *VAR_1, const char *VAR_2, const u_char *VAR_3,\n           int VAR_4)\n{\n    int VAR_5 = 0;\n    const char *VAR_6 = \"READONLY|HIDDEN|SYSTEM|VOLUME|DIR|ARCHIVE|\";\n    char VAR_7[VAR_8+1];\n\n    while (*VAR_2 && VAR_1<VAR_3) {\n\tswitch (*VAR_2) {\n\tcase 'a':\n\t    write_bits(VAR_0, GET_U_1(VAR_1), VAR_6);\n\t    VAR_1++;\n\t    VAR_2++;\n\t    break;\n\n\tcase 'A':\n\t    write_bits(VAR_0, GET_LE_U_2(VAR_1), VAR_6);\n\t    VAR_1 += 2;\n\t    VAR_2++;\n\t    break;\n\n\tcase '{':\n\t  {\n\t    char VAR_9[128];\n\t    char *VAR_10;\n\t    u_int VAR_11;\n\n\t    VAR_10 = strchr(++VAR_2, '}');\n\t    VAR_11 = ND_BYTES_BETWEEN(VAR_10, VAR_2);\n\n\t    if (VAR_11 > sizeof(VAR_9) - 1)\n\t\tVAR_11 = sizeof(VAR_9)-1;\n\n\t    strncpy(VAR_9, VAR_2, VAR_11);\n\t    VAR_9[VAR_11] = '\\0';\n\t    VAR_2 = VAR_10 + 1;\n\t    write_bits(VAR_0, GET_U_1(VAR_1), VAR_9);\n\t    VAR_1++;\n\t    break;\n\t  }\n\n\tcase 'P':\n\t  {\n\t    int VAR_11 = atoi(VAR_2 + 1);\n\t    ND_TCHECK_LEN(VAR_1, VAR_11);\n\t    VAR_1 += VAR_11;\n\t    VAR_2++;\n\t    while (ND_ASCII_ISDIGIT(*VAR_2))\n\t\tVAR_2++;\n\t    break;\n\t  }\n\tcase 'r':\n\t    VAR_5 = !VAR_5;\n\t    VAR_2++;\n\t    break;\n\tcase 'b':\n\t  {\n\t    unsigned int VAR_12;\n\t    VAR_12 = GET_U_1(VAR_1);\n\t    ND_PRINT(\"%u (0x%x)\", VAR_12, VAR_12);\n\t    VAR_1 += 1;\n\t    VAR_2++;\n\t    break;\n\t  }\n\tcase 'd':\n\t  {\n\t    int VAR_12;\n\t    VAR_12 = VAR_5 ? GET_BE_S_2(VAR_1) :\n\t\t\t  GET_LE_S_2(VAR_1);\n\t    ND_PRINT(\"%d (0x%x)\", VAR_12, VAR_12);\n\t    VAR_1 += 2;\n\t    VAR_2++;\n\t    break;\n\t  }\n\tcase 'D':\n\t  {\n\t    int VAR_12;\n\t    VAR_12 = VAR_5 ? GET_BE_S_4(VAR_1) :\n\t\t\t  GET_LE_S_4(VAR_1);\n\t    ND_PRINT(\"%d (0x%x)\", VAR_12, VAR_12);\n\t    VAR_1 += 4;\n\t    VAR_2++;\n\t    break;\n\t  }\n\tcase 'L':\n\t  {\n\t    uint64_t VAR_12;\n\t    VAR_12 = VAR_5 ? GET_BE_U_8(VAR_1) :\n\t\t\t  GET_LE_U_8(VAR_1);\n\t    ND_PRINT(\"%\" VAR_13 \" (0x%\" VAR_14 \")\", VAR_12, VAR_12);\n\t    VAR_1 += 8;\n\t    VAR_2++;\n\t    break;\n\t  }\n\tcase 'u':\n\t  {\n\t    unsigned int VAR_12;\n\t    VAR_12 = VAR_5 ? GET_BE_U_2(VAR_1) :\n\t\t\t  GET_LE_U_2(VAR_1);\n\t    ND_PRINT(\"%u (0x%x)\", VAR_12, VAR_12);\n\t    VAR_1 += 2;\n\t    VAR_2++;\n\t    break;\n\t  }\n\tcase 'U':\n\t  {\n\t    unsigned int VAR_12;\n\t    VAR_12 = VAR_5 ? GET_BE_U_4(VAR_1) :\n\t\t\t  GET_LE_U_4(VAR_1);\n\t    ND_PRINT(\"%u (0x%x)\", VAR_12, VAR_12);\n\t    VAR_1 += 4;\n\t    VAR_2++;\n\t    break;\n\t  }\n\tcase 'M':\n\t  {\n\t    /* COMMENT_0 */\n\t    uint32_t VAR_15, VAR_16;\n\t    uint64_t VAR_12;\n\t    ND_TCHECK_8(VAR_1);\n\t    VAR_15 = VAR_5 ? GET_BE_U_4(VAR_1) :\n\t\t\t   GET_LE_U_4(VAR_1);\n\t    VAR_16 = VAR_5 ? GET_BE_U_4(VAR_1 + 4) :\n\t\t\t   GET_LE_U_4(VAR_1 + 4);\n\t    VAR_12 = (((uint64_t)VAR_15) << 32) | VAR_16;\n\t    ND_PRINT(\"%\" VAR_13 \" (0x%\" VAR_14 \")\", VAR_12, VAR_12);\n\t    VAR_1 += 8;\n\t    VAR_2++;\n\t    break;\n\t  }\n\tcase 'B':\n\t  {\n\t    unsigned int VAR_12;\n\t    VAR_12 = GET_U_1(VAR_1);\n\t    ND_PRINT(\"0x%X\", VAR_12);\n\t    VAR_1 += 1;\n\t    VAR_2++;\n\t    break;\n\t  }\n\tcase 'w':\n\t  {\n\t    unsigned int VAR_12;\n\t    VAR_12 = VAR_5 ? GET_BE_U_2(VAR_1) :\n\t\t\t  GET_LE_U_2(VAR_1);\n\t    ND_PRINT(\"0x%X\", VAR_12);\n\t    VAR_1 += 2;\n\t    VAR_2++;\n\t    break;\n\t  }\n\tcase 'W':\n\t  {\n\t    unsigned int VAR_12;\n\t    VAR_12 = VAR_5 ? GET_BE_U_4(VAR_1) :\n\t\t\t  GET_LE_U_4(VAR_1);\n\t    ND_PRINT(\"0x%X\", VAR_12);\n\t    VAR_1 += 4;\n\t    VAR_2++;\n\t    break;\n\t  }\n\tcase 'l':\n\t  {\n\t    VAR_2++;\n\t    switch (*VAR_2) {\n\n\t    case 'b':\n\t\tVAR_17 = GET_U_1(VAR_1);\n\t\tVAR_18 = 1;\n\t\tND_PRINT(\"%u\", VAR_17);\n\t\tVAR_1 += 1;\n\t\tbreak;\n\n\t    case 'd':\n\t    case 'u':\n\t\tVAR_17 = VAR_5 ? GET_BE_U_2(VAR_1) :\n\t\t\t\t      GET_LE_U_2(VAR_1);\n\t\tVAR_18 = 1;\n\t\tND_PRINT(\"%u\", VAR_17);\n\t\tVAR_1 += 2;\n\t\tbreak;\n\n\t    case 'D':\n\t    case 'U':\n\t\tVAR_17 = VAR_5 ? GET_BE_U_4(VAR_1) :\n\t\t\t\t      GET_LE_U_4(VAR_1);\n\t\tVAR_18 = 1;\n\t\tND_PRINT(\"%u\", VAR_17);\n\t\tVAR_1 += 4;\n\t\tbreak;\n\t    }\n\t    VAR_2++;\n\t    break;\n\t  }\n\tcase 'S':\n\tcase 'R':\t/* COMMENT_1 */\n\t  {\n\t    /* COMMENT_2 */\n\t    VAR_1 = unistr(VAR_0, &VAR_7, VAR_1, 0, 1, (*VAR_2 == 'R') ? 0 : VAR_4);\n\t    ND_PRINT(\"%s\", VAR_7);\n\t    if (VAR_1 == NULL)\n\t\tgoto trunc;\n\t    VAR_2++;\n\t    break;\n\t  }\n\tcase 'Z':\n\tcase 'Y':\t/* COMMENT_3 */\n\t  {\n\t    if (GET_U_1(VAR_1) != 4 && GET_U_1(VAR_1) != 2) {\n\t\tND_PRINT(\"Error! ASCIIZ buffer of type %u\", GET_U_1(VAR_1));\n\t\treturn VAR_3;\t/* COMMENT_4 */\n\t    }\n\t    VAR_1 = unistr(VAR_0, &VAR_7, VAR_1 + 1, 0, 1, (*VAR_2 == 'Y') ? 0 : VAR_4);\n\t    ND_PRINT(\"%s\", VAR_7);\n\t    if (VAR_1 == NULL)\n\t\tgoto trunc;\n\t    VAR_2++;\n\t    break;\n\t  }\n\tcase 's':\n\t  {\n\t    int VAR_11 = atoi(VAR_2 + 1);\n\t    ND_TCHECK_LEN(VAR_1, VAR_11);\n\t    ND_PRINT(\"%-*.*s\", VAR_11, VAR_11, VAR_1);\n\t    VAR_1 += VAR_11;\n\t    VAR_2++;\n\t    while (ND_ASCII_ISDIGIT(*VAR_2))\n\t\tVAR_2++;\n\t    break;\n\t  }\n\tcase 'c':\n\t  {\n            if (!VAR_18) {\n                ND_PRINT(\"{stringlen not set}\");\n                goto trunc;\n            }\n\t    ND_TCHECK_LEN(VAR_1, VAR_17);\n\t    ND_PRINT(\"%-*.*s\", (int)VAR_17, (int)VAR_17, VAR_1);\n\t    VAR_1 += VAR_17;\n\t    VAR_2++;\n\t    while (ND_ASCII_ISDIGIT(*VAR_2))\n\t\tVAR_2++;\n\t    break;\n\t  }\n\tcase 'C':\n\t  {\n            if (!VAR_18) {\n                ND_PRINT(\"{stringlen not set}\");\n                goto trunc;\n            }\n\t    VAR_1 = unistr(VAR_0, &VAR_7, VAR_1, VAR_17, 0, VAR_4);\n\t    ND_PRINT(\"%s\", VAR_7);\n\t    if (VAR_1 == NULL)\n\t\tgoto trunc;\n\t    VAR_2++;\n\t    break;\n\t  }\n\tcase 'h':\n\t  {\n\t    int VAR_11 = atoi(VAR_2 + 1);\n\t    ND_TCHECK_LEN(VAR_1, VAR_11);\n\t    while (VAR_11--) {\n\t\tND_PRINT(\"%02x\", GET_U_1(VAR_1));\n\t\tVAR_1++;\n\t    }\n\t    VAR_2++;\n\t    while (ND_ASCII_ISDIGIT(*VAR_2))\n\t\tVAR_2++;\n\t    break;\n\t  }\n\tcase 'n':\n\t  {\n\t    int VAR_19 = atoi(VAR_2+1);\n\t    char VAR_20[255];\n\t    int VAR_21;\n\t    int VAR_22;\n\n\t    switch (VAR_19) {\n\t    case 1:\n\t\tVAR_21 = name_extract(VAR_0, VAR_23, ND_BYTES_BETWEEN(VAR_1, VAR_23),\n\t\t    VAR_3, VAR_20);\n\t\tif (VAR_21 < 0)\n\t\t    goto trunc;\n\t\tVAR_22 = name_len(VAR_0, VAR_1, VAR_3);\n\t\tif (VAR_22 < 0)\n\t\t    goto trunc;\n\t\tVAR_1 += VAR_22;\n\t\tND_PRINT(\"%-15.15s NameType=0x%02X (%s)\", VAR_20, VAR_21,\n\t\t    name_type_str(VAR_21));\n\t\tbreak;\n\t    case 2:\n\t\tVAR_21 = GET_U_1(VAR_1 + 15);\n\t\tND_PRINT(\"%-15.15s NameType=0x%02X (%s)\", VAR_1, VAR_21,\n\t\t    name_type_str(VAR_21));\n\t\tVAR_1 += 16;\n\t\tbreak;\n\t    }\n\t    VAR_2++;\n\t    while (ND_ASCII_ISDIGIT(*VAR_2))\n\t\tVAR_2++;\n\t    break;\n\t  }\n\tcase 'T':\n\t  {\n\t    time_t VAR_19;\n\t    struct tm *VAR_24;\n\t    const char *VAR_25;\n\t    char VAR_26[sizeof(\"Www Mmm dd hh:mm:ss yyyyy\\n\")];\n\t    uint32_t VAR_12;\n\n\t    switch (atoi(VAR_2 + 1)) {\n\t    case 1:\n\t\tVAR_12 = GET_LE_U_4(VAR_1);\n\t\tif (VAR_12 == 0 || VAR_12 == 0xFFFFFFFF)\n\t\t    VAR_19 = 0;\n\t\telse\n\t\t    VAR_19 = make_unix_date(VAR_0, VAR_1);\n\t\tVAR_1 += 4;\n\t\tbreak;\n\t    case 2:\n\t\tVAR_12 = GET_LE_U_4(VAR_1);\n\t\tif (VAR_12 == 0 || VAR_12 == 0xFFFFFFFF)\n\t\t    VAR_19 = 0;\n\t\telse\n\t\t    VAR_19 = make_unix_date2(VAR_0, VAR_1);\n\t\tVAR_1 += 4;\n\t\tbreak;\n\t    case 3:\n\t\tND_TCHECK_8(VAR_1);\n\t\tVAR_19 = interpret_long_date(VAR_0, VAR_1);\n\t\tVAR_1 += 8;\n\t\tbreak;\n\t    default:\n\t\tVAR_19 = 0;\n\t\tbreak;\n\t    }\n\t    if (VAR_19 != 0) {\n\t\tVAR_24 = localtime(&VAR_19);\n\t\tif (VAR_24 != NULL) {\n\t\t    strftime(VAR_26, sizeof(VAR_26), \"%a %b %e %T %Y%n\", VAR_24);\n\t\t    VAR_25 = VAR_26;\n\t\t}\n\t\telse\n\t\t    VAR_25 = \"(Can't convert time)\\n\";\n\t    } else\n\t\tVAR_25 = \"NULL\\n\";\n\t    ND_PRINT(\"%s\", VAR_25);\n\t    VAR_2++;\n\t    while (ND_ASCII_ISDIGIT(*VAR_2))\n\t\tVAR_2++;\n\t    break;\n\t  }\n\tdefault:\n\t    ND_PRINT(\"%c\", *VAR_2);\n\t    VAR_2++;\n\t    break;\n\t}\n    }\n\n    if (VAR_1 >= VAR_3 && *VAR_2)\n\tND_PRINT(\"END OF BUFFER\\n\");\n\n    return(VAR_1);\n\ntrunc:\n    nd_print_trunc(VAR_0);\n    return(NULL);\n}",
  "func_graph_path_before": "the-tcpdump-group/tcpdump/7578e1c04ee280dda50c4c2813e7d55f539c6501/smbutil.c/vul/before/0.json",
  "func": "static const u_char *\nsmb_fdata1(netdissect_options *ndo,\n           const u_char *buf, const char *fmt, const u_char *maxbuf,\n           int unicodestr)\n{\n    int reverse = 0;\n    const char *attrib_fmt = \"READONLY|HIDDEN|SYSTEM|VOLUME|DIR|ARCHIVE|\";\n    char strbuf[MAX_UNISTR_SIZE+1];\n\n    while (*fmt && buf<maxbuf) {\n\tswitch (*fmt) {\n\tcase 'a':\n\t    write_bits(ndo, GET_U_1(buf), attrib_fmt);\n\t    buf++;\n\t    fmt++;\n\t    break;\n\n\tcase 'A':\n\t    write_bits(ndo, GET_LE_U_2(buf), attrib_fmt);\n\t    buf += 2;\n\t    fmt++;\n\t    break;\n\n\tcase '{':\n\t  {\n\t    char bitfmt[128];\n\t    char *p;\n\t    u_int l;\n\n\t    p = strchr(++fmt, '}');\n\t    l = ND_BYTES_BETWEEN(p, fmt);\n\n\t    if (l > sizeof(bitfmt) - 1)\n\t\tl = sizeof(bitfmt)-1;\n\n\t    strncpy(bitfmt, fmt, l);\n\t    bitfmt[l] = '\\0';\n\t    fmt = p + 1;\n\t    write_bits(ndo, GET_U_1(buf), bitfmt);\n\t    buf++;\n\t    break;\n\t  }\n\n\tcase 'P':\n\t  {\n\t    int l = atoi(fmt + 1);\n\t    ND_TCHECK_LEN(buf, l);\n\t    buf += l;\n\t    fmt++;\n\t    while (ND_ASCII_ISDIGIT(*fmt))\n\t\tfmt++;\n\t    break;\n\t  }\n\tcase 'r':\n\t    reverse = !reverse;\n\t    fmt++;\n\t    break;\n\tcase 'b':\n\t  {\n\t    unsigned int x;\n\t    x = GET_U_1(buf);\n\t    ND_PRINT(\"%u (0x%x)\", x, x);\n\t    buf += 1;\n\t    fmt++;\n\t    break;\n\t  }\n\tcase 'd':\n\t  {\n\t    int x;\n\t    x = reverse ? GET_BE_S_2(buf) :\n\t\t\t  GET_LE_S_2(buf);\n\t    ND_PRINT(\"%d (0x%x)\", x, x);\n\t    buf += 2;\n\t    fmt++;\n\t    break;\n\t  }\n\tcase 'D':\n\t  {\n\t    int x;\n\t    x = reverse ? GET_BE_S_4(buf) :\n\t\t\t  GET_LE_S_4(buf);\n\t    ND_PRINT(\"%d (0x%x)\", x, x);\n\t    buf += 4;\n\t    fmt++;\n\t    break;\n\t  }\n\tcase 'L':\n\t  {\n\t    uint64_t x;\n\t    x = reverse ? GET_BE_U_8(buf) :\n\t\t\t  GET_LE_U_8(buf);\n\t    ND_PRINT(\"%\" PRIu64 \" (0x%\" PRIx64 \")\", x, x);\n\t    buf += 8;\n\t    fmt++;\n\t    break;\n\t  }\n\tcase 'u':\n\t  {\n\t    unsigned int x;\n\t    x = reverse ? GET_BE_U_2(buf) :\n\t\t\t  GET_LE_U_2(buf);\n\t    ND_PRINT(\"%u (0x%x)\", x, x);\n\t    buf += 2;\n\t    fmt++;\n\t    break;\n\t  }\n\tcase 'U':\n\t  {\n\t    unsigned int x;\n\t    x = reverse ? GET_BE_U_4(buf) :\n\t\t\t  GET_LE_U_4(buf);\n\t    ND_PRINT(\"%u (0x%x)\", x, x);\n\t    buf += 4;\n\t    fmt++;\n\t    break;\n\t  }\n\tcase 'M':\n\t  {\n\t    /* Weird mixed-endian length values in 64-bit locks */\n\t    uint32_t x1, x2;\n\t    uint64_t x;\n\t    ND_TCHECK_8(buf);\n\t    x1 = reverse ? GET_BE_U_4(buf) :\n\t\t\t   GET_LE_U_4(buf);\n\t    x2 = reverse ? GET_BE_U_4(buf + 4) :\n\t\t\t   GET_LE_U_4(buf + 4);\n\t    x = (((uint64_t)x1) << 32) | x2;\n\t    ND_PRINT(\"%\" PRIu64 \" (0x%\" PRIx64 \")\", x, x);\n\t    buf += 8;\n\t    fmt++;\n\t    break;\n\t  }\n\tcase 'B':\n\t  {\n\t    unsigned int x;\n\t    x = GET_U_1(buf);\n\t    ND_PRINT(\"0x%X\", x);\n\t    buf += 1;\n\t    fmt++;\n\t    break;\n\t  }\n\tcase 'w':\n\t  {\n\t    unsigned int x;\n\t    x = reverse ? GET_BE_U_2(buf) :\n\t\t\t  GET_LE_U_2(buf);\n\t    ND_PRINT(\"0x%X\", x);\n\t    buf += 2;\n\t    fmt++;\n\t    break;\n\t  }\n\tcase 'W':\n\t  {\n\t    unsigned int x;\n\t    x = reverse ? GET_BE_U_4(buf) :\n\t\t\t  GET_LE_U_4(buf);\n\t    ND_PRINT(\"0x%X\", x);\n\t    buf += 4;\n\t    fmt++;\n\t    break;\n\t  }\n\tcase 'l':\n\t  {\n\t    fmt++;\n\t    switch (*fmt) {\n\n\t    case 'b':\n\t\tstringlen = GET_U_1(buf);\n\t\tstringlen_is_set = 1;\n\t\tND_PRINT(\"%u\", stringlen);\n\t\tbuf += 1;\n\t\tbreak;\n\n\t    case 'd':\n\t    case 'u':\n\t\tstringlen = reverse ? GET_BE_U_2(buf) :\n\t\t\t\t      GET_LE_U_2(buf);\n\t\tstringlen_is_set = 1;\n\t\tND_PRINT(\"%u\", stringlen);\n\t\tbuf += 2;\n\t\tbreak;\n\n\t    case 'D':\n\t    case 'U':\n\t\tstringlen = reverse ? GET_BE_U_4(buf) :\n\t\t\t\t      GET_LE_U_4(buf);\n\t\tstringlen_is_set = 1;\n\t\tND_PRINT(\"%u\", stringlen);\n\t\tbuf += 4;\n\t\tbreak;\n\t    }\n\t    fmt++;\n\t    break;\n\t  }\n\tcase 'S':\n\tcase 'R':\t/* like 'S', but always ASCII */\n\t  {\n\t    /*XXX unistr() */\n\t    buf = unistr(ndo, &strbuf, buf, 0, 1, (*fmt == 'R') ? 0 : unicodestr);\n\t    ND_PRINT(\"%s\", strbuf);\n\t    if (buf == NULL)\n\t\tgoto trunc;\n\t    fmt++;\n\t    break;\n\t  }\n\tcase 'Z':\n\tcase 'Y':\t/* like 'Z', but always ASCII */\n\t  {\n\t    if (GET_U_1(buf) != 4 && GET_U_1(buf) != 2) {\n\t\tND_PRINT(\"Error! ASCIIZ buffer of type %u\", GET_U_1(buf));\n\t\treturn maxbuf;\t/* give up */\n\t    }\n\t    buf = unistr(ndo, &strbuf, buf + 1, 0, 1, (*fmt == 'Y') ? 0 : unicodestr);\n\t    ND_PRINT(\"%s\", strbuf);\n\t    if (buf == NULL)\n\t\tgoto trunc;\n\t    fmt++;\n\t    break;\n\t  }\n\tcase 's':\n\t  {\n\t    int l = atoi(fmt + 1);\n\t    ND_TCHECK_LEN(buf, l);\n\t    ND_PRINT(\"%-*.*s\", l, l, buf);\n\t    buf += l;\n\t    fmt++;\n\t    while (ND_ASCII_ISDIGIT(*fmt))\n\t\tfmt++;\n\t    break;\n\t  }\n\tcase 'c':\n\t  {\n            if (!stringlen_is_set) {\n                ND_PRINT(\"{stringlen not set}\");\n                goto trunc;\n            }\n\t    ND_TCHECK_LEN(buf, stringlen);\n\t    ND_PRINT(\"%-*.*s\", (int)stringlen, (int)stringlen, buf);\n\t    buf += stringlen;\n\t    fmt++;\n\t    while (ND_ASCII_ISDIGIT(*fmt))\n\t\tfmt++;\n\t    break;\n\t  }\n\tcase 'C':\n\t  {\n            if (!stringlen_is_set) {\n                ND_PRINT(\"{stringlen not set}\");\n                goto trunc;\n            }\n\t    buf = unistr(ndo, &strbuf, buf, stringlen, 0, unicodestr);\n\t    ND_PRINT(\"%s\", strbuf);\n\t    if (buf == NULL)\n\t\tgoto trunc;\n\t    fmt++;\n\t    break;\n\t  }\n\tcase 'h':\n\t  {\n\t    int l = atoi(fmt + 1);\n\t    ND_TCHECK_LEN(buf, l);\n\t    while (l--) {\n\t\tND_PRINT(\"%02x\", GET_U_1(buf));\n\t\tbuf++;\n\t    }\n\t    fmt++;\n\t    while (ND_ASCII_ISDIGIT(*fmt))\n\t\tfmt++;\n\t    break;\n\t  }\n\tcase 'n':\n\t  {\n\t    int t = atoi(fmt+1);\n\t    char nbuf[255];\n\t    int name_type;\n\t    int len;\n\n\t    switch (t) {\n\t    case 1:\n\t\tname_type = name_extract(ndo, startbuf, ND_BYTES_BETWEEN(buf, startbuf),\n\t\t    maxbuf, nbuf);\n\t\tif (name_type < 0)\n\t\t    goto trunc;\n\t\tlen = name_len(ndo, buf, maxbuf);\n\t\tif (len < 0)\n\t\t    goto trunc;\n\t\tbuf += len;\n\t\tND_PRINT(\"%-15.15s NameType=0x%02X (%s)\", nbuf, name_type,\n\t\t    name_type_str(name_type));\n\t\tbreak;\n\t    case 2:\n\t\tname_type = GET_U_1(buf + 15);\n\t\tND_PRINT(\"%-15.15s NameType=0x%02X (%s)\", buf, name_type,\n\t\t    name_type_str(name_type));\n\t\tbuf += 16;\n\t\tbreak;\n\t    }\n\t    fmt++;\n\t    while (ND_ASCII_ISDIGIT(*fmt))\n\t\tfmt++;\n\t    break;\n\t  }\n\tcase 'T':\n\t  {\n\t    time_t t;\n\t    const char *tstring;\n\t    char buffer[sizeof(\"Www Mmm dd hh:mm:ss yyyyy\")];\n\t    uint32_t x;\n\n\t    switch (atoi(fmt + 1)) {\n\t    case 1:\n\t\tx = GET_LE_U_4(buf);\n\t\tif (x == 0 || x == 0xFFFFFFFF)\n\t\t    t = 0;\n\t\telse\n\t\t    t = make_unix_date(ndo, buf);\n\t\tbuf += 4;\n\t\tbreak;\n\t    case 2:\n\t\tx = GET_LE_U_4(buf);\n\t\tif (x == 0 || x == 0xFFFFFFFF)\n\t\t    t = 0;\n\t\telse\n\t\t    t = make_unix_date2(ndo, buf);\n\t\tbuf += 4;\n\t\tbreak;\n\t    case 3:\n\t\tND_TCHECK_8(buf);\n\t\tt = interpret_long_date(ndo, buf);\n\t\tbuf += 8;\n\t\tbreak;\n\t    default:\n\t\tt = 0;\n\t\tbreak;\n\t    }\n\t    if (t != 0) {\n\t\t    tstring = nd_format_time(buffer, sizeof(buffer), \"%a %b %e %T %Y\",\n\t\t    localtime(&t));\n\t    } else\n\t\ttstring = \"NULL\";\n\t    ND_PRINT(\"%s\\n\", tstring);\n\t    fmt++;\n\t    while (ND_ASCII_ISDIGIT(*fmt))\n\t\tfmt++;\n\t    break;\n\t  }\n\tdefault:\n\t    ND_PRINT(\"%c\", *fmt);\n\t    fmt++;\n\t    break;\n\t}\n    }\n\n    if (buf >= maxbuf && *fmt)\n\tND_PRINT(\"END OF BUFFER\\n\");\n\n    return(buf);\n\ntrunc:\n    nd_print_trunc(ndo);\n    return(NULL);\n}",
  "abstract_func": "static const u_char *\nsmb_fdata1(netdissect_options *VAR_0,\n           const u_char *VAR_1, const char *VAR_2, const u_char *VAR_3,\n           int VAR_4)\n{\n    int VAR_5 = 0;\n    const char *VAR_6 = \"READONLY|HIDDEN|SYSTEM|VOLUME|DIR|ARCHIVE|\";\n    char VAR_7[VAR_8+1];\n\n    while (*VAR_2 && VAR_1<VAR_3) {\n\tswitch (*VAR_2) {\n\tcase 'a':\n\t    write_bits(VAR_0, GET_U_1(VAR_1), VAR_6);\n\t    VAR_1++;\n\t    VAR_2++;\n\t    break;\n\n\tcase 'A':\n\t    write_bits(VAR_0, GET_LE_U_2(VAR_1), VAR_6);\n\t    VAR_1 += 2;\n\t    VAR_2++;\n\t    break;\n\n\tcase '{':\n\t  {\n\t    char VAR_9[128];\n\t    char *VAR_10;\n\t    u_int VAR_11;\n\n\t    VAR_10 = strchr(++VAR_2, '}');\n\t    VAR_11 = ND_BYTES_BETWEEN(VAR_10, VAR_2);\n\n\t    if (VAR_11 > sizeof(VAR_9) - 1)\n\t\tVAR_11 = sizeof(VAR_9)-1;\n\n\t    strncpy(VAR_9, VAR_2, VAR_11);\n\t    VAR_9[VAR_11] = '\\0';\n\t    VAR_2 = VAR_10 + 1;\n\t    write_bits(VAR_0, GET_U_1(VAR_1), VAR_9);\n\t    VAR_1++;\n\t    break;\n\t  }\n\n\tcase 'P':\n\t  {\n\t    int VAR_11 = atoi(VAR_2 + 1);\n\t    ND_TCHECK_LEN(VAR_1, VAR_11);\n\t    VAR_1 += VAR_11;\n\t    VAR_2++;\n\t    while (ND_ASCII_ISDIGIT(*VAR_2))\n\t\tVAR_2++;\n\t    break;\n\t  }\n\tcase 'r':\n\t    VAR_5 = !VAR_5;\n\t    VAR_2++;\n\t    break;\n\tcase 'b':\n\t  {\n\t    unsigned int VAR_12;\n\t    VAR_12 = GET_U_1(VAR_1);\n\t    ND_PRINT(\"%u (0x%x)\", VAR_12, VAR_12);\n\t    VAR_1 += 1;\n\t    VAR_2++;\n\t    break;\n\t  }\n\tcase 'd':\n\t  {\n\t    int VAR_12;\n\t    VAR_12 = VAR_5 ? GET_BE_S_2(VAR_1) :\n\t\t\t  GET_LE_S_2(VAR_1);\n\t    ND_PRINT(\"%d (0x%x)\", VAR_12, VAR_12);\n\t    VAR_1 += 2;\n\t    VAR_2++;\n\t    break;\n\t  }\n\tcase 'D':\n\t  {\n\t    int VAR_12;\n\t    VAR_12 = VAR_5 ? GET_BE_S_4(VAR_1) :\n\t\t\t  GET_LE_S_4(VAR_1);\n\t    ND_PRINT(\"%d (0x%x)\", VAR_12, VAR_12);\n\t    VAR_1 += 4;\n\t    VAR_2++;\n\t    break;\n\t  }\n\tcase 'L':\n\t  {\n\t    uint64_t VAR_12;\n\t    VAR_12 = VAR_5 ? GET_BE_U_8(VAR_1) :\n\t\t\t  GET_LE_U_8(VAR_1);\n\t    ND_PRINT(\"%\" VAR_13 \" (0x%\" VAR_14 \")\", VAR_12, VAR_12);\n\t    VAR_1 += 8;\n\t    VAR_2++;\n\t    break;\n\t  }\n\tcase 'u':\n\t  {\n\t    unsigned int VAR_12;\n\t    VAR_12 = VAR_5 ? GET_BE_U_2(VAR_1) :\n\t\t\t  GET_LE_U_2(VAR_1);\n\t    ND_PRINT(\"%u (0x%x)\", VAR_12, VAR_12);\n\t    VAR_1 += 2;\n\t    VAR_2++;\n\t    break;\n\t  }\n\tcase 'U':\n\t  {\n\t    unsigned int VAR_12;\n\t    VAR_12 = VAR_5 ? GET_BE_U_4(VAR_1) :\n\t\t\t  GET_LE_U_4(VAR_1);\n\t    ND_PRINT(\"%u (0x%x)\", VAR_12, VAR_12);\n\t    VAR_1 += 4;\n\t    VAR_2++;\n\t    break;\n\t  }\n\tcase 'M':\n\t  {\n\t    /* COMMENT_0 */\n\t    uint32_t VAR_15, VAR_16;\n\t    uint64_t VAR_12;\n\t    ND_TCHECK_8(VAR_1);\n\t    VAR_15 = VAR_5 ? GET_BE_U_4(VAR_1) :\n\t\t\t   GET_LE_U_4(VAR_1);\n\t    VAR_16 = VAR_5 ? GET_BE_U_4(VAR_1 + 4) :\n\t\t\t   GET_LE_U_4(VAR_1 + 4);\n\t    VAR_12 = (((uint64_t)VAR_15) << 32) | VAR_16;\n\t    ND_PRINT(\"%\" VAR_13 \" (0x%\" VAR_14 \")\", VAR_12, VAR_12);\n\t    VAR_1 += 8;\n\t    VAR_2++;\n\t    break;\n\t  }\n\tcase 'B':\n\t  {\n\t    unsigned int VAR_12;\n\t    VAR_12 = GET_U_1(VAR_1);\n\t    ND_PRINT(\"0x%X\", VAR_12);\n\t    VAR_1 += 1;\n\t    VAR_2++;\n\t    break;\n\t  }\n\tcase 'w':\n\t  {\n\t    unsigned int VAR_12;\n\t    VAR_12 = VAR_5 ? GET_BE_U_2(VAR_1) :\n\t\t\t  GET_LE_U_2(VAR_1);\n\t    ND_PRINT(\"0x%X\", VAR_12);\n\t    VAR_1 += 2;\n\t    VAR_2++;\n\t    break;\n\t  }\n\tcase 'W':\n\t  {\n\t    unsigned int VAR_12;\n\t    VAR_12 = VAR_5 ? GET_BE_U_4(VAR_1) :\n\t\t\t  GET_LE_U_4(VAR_1);\n\t    ND_PRINT(\"0x%X\", VAR_12);\n\t    VAR_1 += 4;\n\t    VAR_2++;\n\t    break;\n\t  }\n\tcase 'l':\n\t  {\n\t    VAR_2++;\n\t    switch (*VAR_2) {\n\n\t    case 'b':\n\t\tVAR_17 = GET_U_1(VAR_1);\n\t\tVAR_18 = 1;\n\t\tND_PRINT(\"%u\", VAR_17);\n\t\tVAR_1 += 1;\n\t\tbreak;\n\n\t    case 'd':\n\t    case 'u':\n\t\tVAR_17 = VAR_5 ? GET_BE_U_2(VAR_1) :\n\t\t\t\t      GET_LE_U_2(VAR_1);\n\t\tVAR_18 = 1;\n\t\tND_PRINT(\"%u\", VAR_17);\n\t\tVAR_1 += 2;\n\t\tbreak;\n\n\t    case 'D':\n\t    case 'U':\n\t\tVAR_17 = VAR_5 ? GET_BE_U_4(VAR_1) :\n\t\t\t\t      GET_LE_U_4(VAR_1);\n\t\tVAR_18 = 1;\n\t\tND_PRINT(\"%u\", VAR_17);\n\t\tVAR_1 += 4;\n\t\tbreak;\n\t    }\n\t    VAR_2++;\n\t    break;\n\t  }\n\tcase 'S':\n\tcase 'R':\t/* COMMENT_1 */\n\t  {\n\t    /* COMMENT_2 */\n\t    VAR_1 = unistr(VAR_0, &VAR_7, VAR_1, 0, 1, (*VAR_2 == 'R') ? 0 : VAR_4);\n\t    ND_PRINT(\"%s\", VAR_7);\n\t    if (VAR_1 == NULL)\n\t\tgoto trunc;\n\t    VAR_2++;\n\t    break;\n\t  }\n\tcase 'Z':\n\tcase 'Y':\t/* COMMENT_3 */\n\t  {\n\t    if (GET_U_1(VAR_1) != 4 && GET_U_1(VAR_1) != 2) {\n\t\tND_PRINT(\"Error! ASCIIZ buffer of type %u\", GET_U_1(VAR_1));\n\t\treturn VAR_3;\t/* COMMENT_4 */\n\t    }\n\t    VAR_1 = unistr(VAR_0, &VAR_7, VAR_1 + 1, 0, 1, (*VAR_2 == 'Y') ? 0 : VAR_4);\n\t    ND_PRINT(\"%s\", VAR_7);\n\t    if (VAR_1 == NULL)\n\t\tgoto trunc;\n\t    VAR_2++;\n\t    break;\n\t  }\n\tcase 's':\n\t  {\n\t    int VAR_11 = atoi(VAR_2 + 1);\n\t    ND_TCHECK_LEN(VAR_1, VAR_11);\n\t    ND_PRINT(\"%-*.*s\", VAR_11, VAR_11, VAR_1);\n\t    VAR_1 += VAR_11;\n\t    VAR_2++;\n\t    while (ND_ASCII_ISDIGIT(*VAR_2))\n\t\tVAR_2++;\n\t    break;\n\t  }\n\tcase 'c':\n\t  {\n            if (!VAR_18) {\n                ND_PRINT(\"{stringlen not set}\");\n                goto trunc;\n            }\n\t    ND_TCHECK_LEN(VAR_1, VAR_17);\n\t    ND_PRINT(\"%-*.*s\", (int)VAR_17, (int)VAR_17, VAR_1);\n\t    VAR_1 += VAR_17;\n\t    VAR_2++;\n\t    while (ND_ASCII_ISDIGIT(*VAR_2))\n\t\tVAR_2++;\n\t    break;\n\t  }\n\tcase 'C':\n\t  {\n            if (!VAR_18) {\n                ND_PRINT(\"{stringlen not set}\");\n                goto trunc;\n            }\n\t    VAR_1 = unistr(VAR_0, &VAR_7, VAR_1, VAR_17, 0, VAR_4);\n\t    ND_PRINT(\"%s\", VAR_7);\n\t    if (VAR_1 == NULL)\n\t\tgoto trunc;\n\t    VAR_2++;\n\t    break;\n\t  }\n\tcase 'h':\n\t  {\n\t    int VAR_11 = atoi(VAR_2 + 1);\n\t    ND_TCHECK_LEN(VAR_1, VAR_11);\n\t    while (VAR_11--) {\n\t\tND_PRINT(\"%02x\", GET_U_1(VAR_1));\n\t\tVAR_1++;\n\t    }\n\t    VAR_2++;\n\t    while (ND_ASCII_ISDIGIT(*VAR_2))\n\t\tVAR_2++;\n\t    break;\n\t  }\n\tcase 'n':\n\t  {\n\t    int VAR_19 = atoi(VAR_2+1);\n\t    char VAR_20[255];\n\t    int VAR_21;\n\t    int VAR_22;\n\n\t    switch (VAR_19) {\n\t    case 1:\n\t\tVAR_21 = name_extract(VAR_0, VAR_23, ND_BYTES_BETWEEN(VAR_1, VAR_23),\n\t\t    VAR_3, VAR_20);\n\t\tif (VAR_21 < 0)\n\t\t    goto trunc;\n\t\tVAR_22 = name_len(VAR_0, VAR_1, VAR_3);\n\t\tif (VAR_22 < 0)\n\t\t    goto trunc;\n\t\tVAR_1 += VAR_22;\n\t\tND_PRINT(\"%-15.15s NameType=0x%02X (%s)\", VAR_20, VAR_21,\n\t\t    name_type_str(VAR_21));\n\t\tbreak;\n\t    case 2:\n\t\tVAR_21 = GET_U_1(VAR_1 + 15);\n\t\tND_PRINT(\"%-15.15s NameType=0x%02X (%s)\", VAR_1, VAR_21,\n\t\t    name_type_str(VAR_21));\n\t\tVAR_1 += 16;\n\t\tbreak;\n\t    }\n\t    VAR_2++;\n\t    while (ND_ASCII_ISDIGIT(*VAR_2))\n\t\tVAR_2++;\n\t    break;\n\t  }\n\tcase 'T':\n\t  {\n\t    time_t VAR_19;\n\t    const char *VAR_24;\n\t    char VAR_25[sizeof(\"Www Mmm dd hh:mm:ss yyyyy\")];\n\t    uint32_t VAR_12;\n\n\t    switch (atoi(VAR_2 + 1)) {\n\t    case 1:\n\t\tVAR_12 = GET_LE_U_4(VAR_1);\n\t\tif (VAR_12 == 0 || VAR_12 == 0xFFFFFFFF)\n\t\t    VAR_19 = 0;\n\t\telse\n\t\t    VAR_19 = make_unix_date(VAR_0, VAR_1);\n\t\tVAR_1 += 4;\n\t\tbreak;\n\t    case 2:\n\t\tVAR_12 = GET_LE_U_4(VAR_1);\n\t\tif (VAR_12 == 0 || VAR_12 == 0xFFFFFFFF)\n\t\t    VAR_19 = 0;\n\t\telse\n\t\t    VAR_19 = make_unix_date2(VAR_0, VAR_1);\n\t\tVAR_1 += 4;\n\t\tbreak;\n\t    case 3:\n\t\tND_TCHECK_8(VAR_1);\n\t\tVAR_19 = interpret_long_date(VAR_0, VAR_1);\n\t\tVAR_1 += 8;\n\t\tbreak;\n\t    default:\n\t\tVAR_19 = 0;\n\t\tbreak;\n\t    }\n\t    if (VAR_19 != 0) {\n\t\t    VAR_24 = nd_format_time(VAR_25, sizeof(VAR_25), \"%a %b %e %T %Y\",\n\t\t    localtime(&VAR_19));\n\t    } else\n\t\tVAR_24 = \"NULL\";\n\t    ND_PRINT(\"%s\\n\", VAR_24);\n\t    VAR_2++;\n\t    while (ND_ASCII_ISDIGIT(*VAR_2))\n\t\tVAR_2++;\n\t    break;\n\t  }\n\tdefault:\n\t    ND_PRINT(\"%c\", *VAR_2);\n\t    VAR_2++;\n\t    break;\n\t}\n    }\n\n    if (VAR_1 >= VAR_3 && *VAR_2)\n\tND_PRINT(\"END OF BUFFER\\n\");\n\n    return(VAR_1);\n\ntrunc:\n    nd_print_trunc(VAR_0);\n    return(NULL);\n}",
  "func_graph_path": "the-tcpdump-group/tcpdump/7578e1c04ee280dda50c4c2813e7d55f539c6501/smbutil.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -303,9 +303,8 @@\n \tcase 'T':\n \t  {\n \t    time_t t;\n-\t    struct tm *lt;\n \t    const char *tstring;\n-\t    char buffer[sizeof(\"Www Mmm dd hh:mm:ss yyyyy\\n\")];\n+\t    char buffer[sizeof(\"Www Mmm dd hh:mm:ss yyyyy\")];\n \t    uint32_t x;\n \n \t    switch (atoi(fmt + 1)) {\n@@ -335,16 +334,11 @@\n \t\tbreak;\n \t    }\n \t    if (t != 0) {\n-\t\tlt = localtime(&t);\n-\t\tif (lt != NULL) {\n-\t\t    strftime(buffer, sizeof(buffer), \"%a %b %e %T %Y%n\", lt);\n-\t\t    tstring = buffer;\n-\t\t}\n-\t\telse\n-\t\t    tstring = \"(Can't convert time)\\n\";\n+\t\t    tstring = nd_format_time(buffer, sizeof(buffer), \"%a %b %e %T %Y\",\n+\t\t    localtime(&t));\n \t    } else\n-\t\ttstring = \"NULL\\n\";\n-\t    ND_PRINT(\"%s\", tstring);\n+\t\ttstring = \"NULL\";\n+\t    ND_PRINT(\"%s\\n\", tstring);\n \t    fmt++;\n \t    while (ND_ASCII_ISDIGIT(*fmt))\n \t\tfmt++;",
  "diff_line_info": {
    "deleted_lines": [
      "\t    struct tm *lt;",
      "\t    char buffer[sizeof(\"Www Mmm dd hh:mm:ss yyyyy\\n\")];",
      "\t\tlt = localtime(&t);",
      "\t\tif (lt != NULL) {",
      "\t\t    strftime(buffer, sizeof(buffer), \"%a %b %e %T %Y%n\", lt);",
      "\t\t    tstring = buffer;",
      "\t\t}",
      "\t\telse",
      "\t\t    tstring = \"(Can't convert time)\\n\";",
      "\t\ttstring = \"NULL\\n\";",
      "\t    ND_PRINT(\"%s\", tstring);"
    ],
    "added_lines": [
      "\t    char buffer[sizeof(\"Www Mmm dd hh:mm:ss yyyyy\")];",
      "\t\t    tstring = nd_format_time(buffer, sizeof(buffer), \"%a %b %e %T %Y\",",
      "\t\t    localtime(&t));",
      "\t\ttstring = \"NULL\";",
      "\t    ND_PRINT(\"%s\\n\", tstring);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/the-tcpdump-group/tcpdump/pull/1032",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/the-tcpdump-group/tcpdump/pull/1032: 403 Client Error: Forbidden for url: https://api.github.com/repos/the-tcpdump-group/tcpdump/pulls/1032",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95  \n\nThe patch addresses a buffer overflow issue related to strftime usage, preventing undefined data from being printed, which is a security concern. The code changes align with the commit message's intent to handle date/time conversion safely."
}