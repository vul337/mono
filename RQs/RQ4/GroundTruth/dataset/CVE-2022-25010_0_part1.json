{
  "cve_id": "CVE-2022-25010",
  "cwe_ids": [
    "CWE-732"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "stepmania",
  "commit_msg": "Remove access to the root FS from lua\n\nOn linux / is mounted to /rootfs in RageFile, which allows access to the\n_whole_ filesystem from lua. This means themes and mod files can\nre-write user data and extract files via USB profiles.\n\n/rootfs was only added for internal use by the alsa, oss and memory card\ndrivers, so it can be easily replaced with direct fstream file access.",
  "commit_hash": "8490d181c2d301ccca0dc6ee52f25bbadb567a9a",
  "git_url": "https://github.com/stepmania/stepmania/commit/8490d181c2d301ccca0dc6ee52f25bbadb567a9a",
  "file_path": "src/arch/MemoryCard/MemoryCardDriverThreaded_Linux.cpp",
  "func_name": "MemoryCardDriverThreaded_Linux::GetUSBStorageDevices",
  "func_before": "void MemoryCardDriverThreaded_Linux::GetUSBStorageDevices( vector<UsbStorageDevice>& vDevicesOut )\n{\n\tLOG->Trace( \"GetUSBStorageDevices\" );\n\t\n\tvDevicesOut.clear();\n\n\t{\n\t\tvector<RString> asDevices;\n\t\tRString sBlockDevicePath = \"/sys/block/\";\n\t\tGetFileList( sBlockDevicePath, asDevices );\n\n\t\tfor( unsigned i = 0; i < asDevices.size(); ++i )\n\t\t{\n\t\t\tconst RString &sDevice = asDevices[i];\n\t\t\tif( sDevice == \".\" || sDevice == \"..\" )\n\t\t\t\tcontinue;\n\n\t\t\tUsbStorageDevice usbd;\n\n\t\t\tRString sPath = sBlockDevicePath + sDevice + \"/\";\n\t\t\tusbd.sSysPath = sPath;\n\n\t\t\t/* Ignore non-removable devices. */\n\t\t\tRString sBuf;\n\t\t\tif( !ReadFile( sPath + \"removable\", sBuf ) )\n\t\t\t\tcontinue; // already warned\n\t\t\tif( atoi(sBuf) != 1 )\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * The kernel isn't exposing all of /sys atomically, so we end up missing\n\t\t\t * the partition due to it not being shown yet.  It won't show up until the\n\t\t\t * kernel has scanned the partition table, which can take a variable amount\n\t\t\t * of time, sometimes over a second.  Watch for the \"queue\" sysfs directory,\n\t\t\t * which is created after this, to tell when partition directories are created.\n\t\t\t */\n\t\t\tRageTimer WaitUntil;\n\t\t\tWaitUntil += 5;\n\t\t\tRString sQueueFilePath = usbd.sSysPath + \"queue\";\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tif( WaitUntil.Ago() >= 0 )\n\t\t\t\t{\n\t\t\t\t\tLOG->Warn( \"Timed out waiting for %s\", sQueueFilePath.c_str() );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif( access(usbd.sSysPath, F_OK) == -1 )\n\t\t\t\t{\n\t\t\t\t\tLOG->Warn( \"Block directory %s went away while we were waiting for %s\",\n\t\t\t\t\t\t\tusbd.sSysPath.c_str(), sQueueFilePath.c_str() );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif( access(sQueueFilePath, F_OK) != -1 )\n\t\t\t\t\tbreak;\n\n\t\t\t\tusleep(10000);\n\t\t\t}\n\n\t\t\t/* Wait for udev to finish handling device node creation */\n\t\t\tExecuteCommand( \"udevadm settle\" );\n\n\t\t\t/* If the first partition device exists, eg. /sys/block/uba/uba1, use it. */\n\t\t\tif( access(usbd.sSysPath + sDevice + \"1\", F_OK) != -1 )\n\t\t\t{\n\t\t\t\tLOG->Trace(\"OK\");\n\t\t\t\tusbd.sDevice = \"/dev/\" + sDevice + \"1\";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tLOG->Trace(\"error %s\", strerror(errno));\n\t\t\t\tusbd.sDevice = \"/dev/\" + sDevice;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * sPath/device should be a symlink to the actual device.  For USB\n\t\t\t * devices, it looks like this:\n\t\t\t *\n\t\t\t * device -> ../../devices/pci0000:00/0000:00:02.1/usb2/2-1/2-1:1.0\n\t\t\t *\n\t\t\t * \"2-1\" is \"bus-port\".\n\t\t\t */\n\t\t\tchar szLink[256];\n\t\t\tint iRet = readlink( sPath + \"device\", szLink, sizeof(szLink) );\n\t\t\tif( iRet == -1 )\n\t\t\t{\n\t\t\t\tLOG->Warn( \"readlink(\\\"%s\\\"): %s\", (sPath + \"device\").c_str(), strerror(errno) );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * The full path looks like\n\t\t\t\t *\n\t\t\t\t *   ../../devices/pci0000:00/0000:00:02.1/usb2/2-2/2-2.1/2-2.1:1.0\n\t\t\t\t *\n\t\t\t\t * In newer kernels, it looks like:\n\t\t\t\t *\n\t\t\t\t * ../../../3-2.1:1.0\n\t\t\t\t *\n\t\t\t\t * Each path element refers to a new hop in the chain.\n\t\t\t\t *  \"usb2\" = second USB host\n\t\t\t\t *  2-            second USB host,\n\t\t\t\t *   -2           port 1 on the host,\n\t\t\t\t *     .1         port 1 on an attached hub\n\t\t\t\t *       .2       ... port 2 on the next hub ...\n\t\t\t\t * \n\t\t\t\t * We want the bus number and the port of the last hop.  The level is\n\t\t\t\t * the number of hops.\n\t\t\t\t */\n\t\t\t\tszLink[iRet] = 0;\n\t\t\t\tvector<RString> asBits;\n\t\t\t\tsplit( szLink, \"/\", asBits );\n\n\t\t\t\tRString sHostPort = asBits[asBits.size()-1];\n\t\t\t\tif( !sHostPort.empty() )\n\t\t\t\t{\n\t\t\t\t\t/* Strip off the endpoint information after the colon. */\n\t\t\t\t\tsize_t pos = sHostPort.find(':');\n\t\t\t\t\tif( pos != string::npos )\n\t\t\t\t\t\tsHostPort.erase( pos );\n\t\t\t\t\t\n\t\t\t\t\t/* sHostPort is eg. 2-2.1. */\n\t\t\t\t\tsHostPort.Replace( \"-\", \".\" );\n\t\t\t\t\tasBits.clear();\n\t\t\t\t\tsplit( sHostPort, \".\", asBits );\n\t\t\t\t\tif( asBits.size() > 1 )\n\t\t\t\t\t{\n\t\t\t\t\t\tusbd.iBus = atoi( asBits[0] );\n\t\t\t\t\t\tusbd.iPort = atoi( asBits[asBits.size()-1] );\n\t\t\t\t\t\tusbd.iLevel = asBits.size() - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif( ReadFile( sPath + \"device/../idVendor\", sBuf ) )\n\t\t\t\tsscanf( sBuf, \"%x\", &usbd.idVendor );\n\n\t\t\tif( ReadFile( sPath + \"device/../idProduct\", sBuf ) )\n\t\t\t\tsscanf( sBuf, \"%x\", &usbd.idProduct );\n\n\t\t\tif( ReadFile( sPath + \"device/../serial\", sBuf ) )\n\t\t\t{\n\t\t\t\tusbd.sSerial = sBuf;\n\t\t\t\tTrimRight( usbd.sSerial );\n\t\t\t}\n\t\t\tif( ReadFile( sPath + \"device/../product\", sBuf ) )\n\t\t\t{\n\t\t\t\tusbd.sProduct = sBuf;\n\t\t\t\tTrimRight( usbd.sProduct );\n\t\t\t}\n\t\t\tif( ReadFile( sPath + \"device/../manufacturer\", sBuf ) )\n\t\t\t{\n\t\t\t\tusbd.sVendor = sBuf;\n\t\t\t\tTrimRight( usbd.sVendor );\n\t\t\t}\n\n\t\t\tvDevicesOut.push_back( usbd );\n\t\t}\n\t}\n\n\t{\n\t\t// Find where each device is mounted. Output looks like:\n\t\t\n\t\t// /dev/sda1               /mnt/flash1             auto    noauto,owner 0 0\n\t\t// /dev/sdb1               /mnt/flash2             auto    noauto,owner 0 0\n\t\t// /dev/sdc1               /mnt/flash3             auto    noauto,owner 0 0\n\t\t\n\t\tRString fn = \"/rootfs/etc/fstab\";\n\t\tRageFile f;\n\t\tif( !f.Open(fn) )\n\t\t{\n\t\t\tLOG->Warn( \"can't open '%s': %s\", fn.c_str(), f.GetError().c_str() );\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tRString sLine;\n\t\twhile( !f.AtEOF() )\n\t\t{\n\t\t\tswitch( f.GetLine(sLine) )\n\t\t\t{\n\t\t\tcase 0: continue; /* eof */\n\t\t\tcase -1:\n\t\t\t\tLOG->Warn( \"error reading '%s': %s\", fn.c_str(), f.GetError().c_str() );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tchar szScsiDevice[1024];\n\t\t\tchar szMountPoint[1024];\n\t\t\tint iRet = sscanf( sLine, \"%s %s\", szScsiDevice, szMountPoint );\n\t\t\tif( iRet != 2 || szScsiDevice[0] == '#')\n\t\t\t\tcontinue;\t// don't process this line\n\n\t\t\t/* Get the real kernel device name, which should match\n\t\t\t * the name from /sys/block, by following symlinks in\n\t\t\t * /dev.  This allows us to specify persistent names in\n\t\t\t * /etc/fstab using things like /dev/device/by-path. */\n\t\t\tchar szUnderlyingDevice[PATH_MAX];\n\t\t\tif( realpath(szScsiDevice, szUnderlyingDevice) == nullptr )\n\t\t\t{\n\t\t\t\t// \"No such file or directory\" is understandable\n\t\t\t\tif (errno != ENOENT)\n\t\t\t\t\tLOG->Warn( \"realpath(\\\"%s\\\"): %s\", szScsiDevice, strerror(errno) );\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tRString sMountPoint = szMountPoint;\n\t\t\tTrimLeft( sMountPoint );\n\t\t\tTrimRight( sMountPoint );\n\n\t\t\t// search for the mountpoint corresponding to the device\n\t\t\tfor( unsigned i=0; i<vDevicesOut.size(); i++ )\n\t\t\t{\n\t\t\t\tUsbStorageDevice& usbd = vDevicesOut[i];\n\t\t\t\tif( usbd.sDevice == szUnderlyingDevice )\t// found our match\n\t\t\t\t{\n\t\t\t\t\t// Use the device entry from fstab so the mount command works\n\t\t\t\t\tusbd.sDevice = szScsiDevice;\n\t\t\t\t\tusbd.sOsMountDir = sMountPoint;\n\t\t\t\t\tbreak;\t// stop looking for a match\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor( unsigned i=0; i<vDevicesOut.size(); i++ )\n\t{\n\t\tUsbStorageDevice& usbd = vDevicesOut[i];\n\t\tLOG->Trace( \"    sDevice: %s, iBus: %d, iLevel: %d, iPort: %d, id: %04X:%04X, Vendor: '%s', Product: '%s', sSerial: \\\"%s\\\", sOsMountDir: %s\",\n\t\t\t\tusbd.sDevice.c_str(), usbd.iBus, usbd.iLevel, usbd.iPort, usbd.idVendor, usbd.idProduct, usbd.sVendor.c_str(),\n\t\t\t\tusbd.sProduct.c_str(), usbd.sSerial.c_str(), usbd.sOsMountDir.c_str() );\n\t}\n\t\n\t/* Remove any devices that we couldn't find a mountpoint for. */\n\tfor( unsigned i=0; i<vDevicesOut.size(); i++ )\n\t{\n\t\tUsbStorageDevice& usbd = vDevicesOut[i];\n\t\tif( usbd.sOsMountDir.empty() )\n\t\t{\n\t\t\tLOG->Trace( \"Ignoring %s (couldn't find in /etc/fstab)\", usbd.sDevice.c_str() );\n\t\t\t\n\t\t\tvDevicesOut.erase( vDevicesOut.begin()+i );\n\t\t\t--i;\n\t\t}\n\t}\n\t\n\tLOG->Trace( \"Done with GetUSBStorageDevices\" );\n}",
  "abstract_func_before": "void MemoryCardDriverThreaded_Linux::GetUSBStorageDevices( vector<UsbStorageDevice>& VAR_0 )\n{\n\tVAR_1->Trace( \"GetUSBStorageDevices\" );\n\t\n\tVAR_0.clear();\n\n\t{\n\t\tvector<RString> VAR_2;\n\t\tRString VAR_3 = \"/sys/block/\";\n\t\tGetFileList( VAR_3, VAR_2 );\n\n\t\tfor( unsigned VAR_4 = 0; VAR_4 < VAR_2.size(); ++VAR_4 )\n\t\t{\n\t\t\tconst RString &VAR_5 = VAR_2[VAR_4];\n\t\t\tif( VAR_5 == \".\" || VAR_5 == \"..\" )\n\t\t\t\tcontinue;\n\n\t\t\tUsbStorageDevice VAR_6;\n\n\t\t\tRString VAR_7 = VAR_3 + VAR_5 + \"/\";\n\t\t\tVAR_6.sSysPath = VAR_7;\n\n\t\t\t/* COMMENT_0 */\n\t\t\tRString VAR_8;\n\t\t\tif( !ReadFile( VAR_7 + \"removable\", VAR_8 ) )\n\t\t\t\tcontinue; /* COMMENT_1 */\n\t\t\tif( atoi(VAR_8) != 1 )\n\t\t\t\tcontinue;\n\n\t\t\t/* COMMENT_2 */\n                                                                            \n                                                                              \n                                                                              \n                                                                               \n                                                                                  \n      \n\t\t\tRageTimer VAR_9;\n\t\t\tVAR_9 += 5;\n\t\t\tRString VAR_10 = VAR_6.sSysPath + \"queue\";\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tif( VAR_9.Ago() >= 0 )\n\t\t\t\t{\n\t\t\t\t\tVAR_1->Warn( \"Timed out waiting for %s\", VAR_10.c_str() );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif( access(VAR_6.sSysPath, VAR_11) == -1 )\n\t\t\t\t{\n\t\t\t\t\tVAR_1->Warn( \"Block directory %s went away while we were waiting for %s\",\n\t\t\t\t\t\t\tVAR_6.sSysPath.c_str(), VAR_10.c_str() );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif( access(VAR_10, VAR_11) != -1 )\n\t\t\t\t\tbreak;\n\n\t\t\t\tusleep(10000);\n\t\t\t}\n\n\t\t\t/* COMMENT_9 */\n\t\t\tExecuteCommand( \"udevadm settle\" );\n\n\t\t\t/* COMMENT_10 */\n\t\t\tif( access(VAR_6.sSysPath + VAR_5 + \"1\", VAR_11) != -1 )\n\t\t\t{\n\t\t\t\tVAR_1->Trace(\"OK\");\n\t\t\t\tVAR_6.sDevice = \"/dev/\" + VAR_5 + \"1\";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tVAR_1->Trace(\"error %s\", strerror(VAR_12));\n\t\t\t\tVAR_6.sDevice = \"/dev/\" + VAR_5;\n\t\t\t}\n\n\t\t\t/* COMMENT_11 */\n                                                                     \n                                  \n     \n                                                                      \n     \n                          \n      \n\t\t\tchar VAR_13[256];\n\t\t\tint VAR_14 = readlink( VAR_7 + \"device\", VAR_13, sizeof(VAR_13) );\n\t\t\tif( VAR_14 == -1 )\n\t\t\t{\n\t\t\t\tVAR_1->Warn( \"readlink(\\\"%s\\\"): %s\", (VAR_7 + \"device\").c_str(), strerror(VAR_12) );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* COMMENT_18 */\n                               \n      \n                                                                       \n      \n                                       \n      \n                         \n      \n                                                          \n                                \n                                      \n                                         \n                                               \n                                                    \n       \n                                                                         \n                          \n       \n\t\t\t\tVAR_13[VAR_14] = 0;\n\t\t\t\tvector<RString> VAR_15;\n\t\t\t\tsplit( VAR_13, \"/\", VAR_15 );\n\n\t\t\t\tRString VAR_16 = VAR_15[VAR_15.size()-1];\n\t\t\t\tif( !VAR_16.empty() )\n\t\t\t\t{\n\t\t\t\t\t/* COMMENT_34 */\n\t\t\t\t\tsize_t VAR_17 = VAR_16.find(':');\n\t\t\t\t\tif( VAR_17 != string::npos )\n\t\t\t\t\t\tVAR_16.erase( VAR_17 );\n\t\t\t\t\t\n\t\t\t\t\t/* COMMENT_35 */\n\t\t\t\t\tVAR_16.Replace( \"-\", \".\" );\n\t\t\t\t\tVAR_15.clear();\n\t\t\t\t\tsplit( VAR_16, \".\", VAR_15 );\n\t\t\t\t\tif( VAR_15.size() > 1 )\n\t\t\t\t\t{\n\t\t\t\t\t\tVAR_6.iBus = atoi( VAR_15[0] );\n\t\t\t\t\t\tVAR_6.iPort = atoi( VAR_15[VAR_15.size()-1] );\n\t\t\t\t\t\tVAR_6.iLevel = VAR_15.size() - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif( ReadFile( VAR_7 + \"device/../idVendor\", VAR_8 ) )\n\t\t\t\tsscanf( VAR_8, \"%x\", &VAR_6.idVendor );\n\n\t\t\tif( ReadFile( VAR_7 + \"device/../idProduct\", VAR_8 ) )\n\t\t\t\tsscanf( VAR_8, \"%x\", &VAR_6.idProduct );\n\n\t\t\tif( ReadFile( VAR_7 + \"device/../serial\", VAR_8 ) )\n\t\t\t{\n\t\t\t\tVAR_6.sSerial = VAR_8;\n\t\t\t\tTrimRight( VAR_6.sSerial );\n\t\t\t}\n\t\t\tif( ReadFile( VAR_7 + \"device/../product\", VAR_8 ) )\n\t\t\t{\n\t\t\t\tVAR_6.sProduct = VAR_8;\n\t\t\t\tTrimRight( VAR_6.sProduct );\n\t\t\t}\n\t\t\tif( ReadFile( VAR_7 + \"device/../manufacturer\", VAR_8 ) )\n\t\t\t{\n\t\t\t\tVAR_6.sVendor = VAR_8;\n\t\t\t\tTrimRight( VAR_6.sVendor );\n\t\t\t}\n\n\t\t\tVAR_0.push_back( VAR_6 );\n\t\t}\n\t}\n\n\t{\n\t\t/* COMMENT_36 */\n\t\t\n\t\t/* COMMENT_37 */\n\t\t/* COMMENT_38 */\n\t\t/* COMMENT_39 */\n\t\t\n\t\tRString VAR_18 = \"/rootfs/etc/fstab\";\n\t\tRageFile VAR_19;\n\t\tif( !VAR_19.Open(VAR_18) )\n\t\t{\n\t\t\tVAR_1->Warn( \"can't open '%s': %s\", VAR_18.c_str(), VAR_19.GetError().c_str() );\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tRString VAR_20;\n\t\twhile( !VAR_19.AtEOF() )\n\t\t{\n\t\t\tswitch( VAR_19.GetLine(VAR_20) )\n\t\t\t{\n\t\t\tcase 0: continue; /* COMMENT_40 */\n\t\t\tcase -1:\n\t\t\t\tVAR_1->Warn( \"error reading '%s': %s\", VAR_18.c_str(), VAR_19.GetError().c_str() );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tchar VAR_21[1024];\n\t\t\tchar VAR_22[1024];\n\t\t\tint VAR_14 = sscanf( VAR_20, \"%s %s\", VAR_21, VAR_22 );\n\t\t\tif( VAR_14 != 2 || VAR_21[0] == '#')\n\t\t\t\tcontinue;\t/* COMMENT_41 */\n\n\t\t\t/* COMMENT_42 */\n                                                        \n                                                          \n                                                          \n\t\t\tchar VAR_23[VAR_24];\n\t\t\tif( realpath(VAR_21, VAR_23) == nullptr )\n\t\t\t{\n\t\t\t\t/* COMMENT_46 */\n\t\t\t\tif (VAR_12 != VAR_25)\n\t\t\t\t\tVAR_1->Warn( \"realpath(\\\"%s\\\"): %s\", VAR_21, strerror(VAR_12) );\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tRString VAR_26 = VAR_22;\n\t\t\tTrimLeft( VAR_26 );\n\t\t\tTrimRight( VAR_26 );\n\n\t\t\t/* COMMENT_47 */\n\t\t\tfor( unsigned VAR_4=0; VAR_4<VAR_0.size(); VAR_4++ )\n\t\t\t{\n\t\t\t\tUsbStorageDevice& VAR_6 = VAR_0[VAR_4];\n\t\t\t\tif( VAR_6.sDevice == VAR_23 )\t/* COMMENT_48 */\n\t\t\t\t{\n\t\t\t\t\t/* COMMENT_49 */\n\t\t\t\t\tVAR_6.sDevice = VAR_21;\n\t\t\t\t\tVAR_6.sOsMountDir = VAR_26;\n\t\t\t\t\tbreak;\t/* COMMENT_50 */\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor( unsigned VAR_4=0; VAR_4<VAR_0.size(); VAR_4++ )\n\t{\n\t\tUsbStorageDevice& VAR_6 = VAR_0[VAR_4];\n\t\tVAR_1->Trace( \"    sDevice: %s, iBus: %d, iLevel: %d, iPort: %d, id: %04X:%04X, Vendor: '%s', Product: '%s', sSerial: \\\"%s\\\", sOsMountDir: %s\",\n\t\t\t\tVAR_6.sDevice.c_str(), VAR_6.iBus, VAR_6.iLevel, VAR_6.iPort, VAR_6.idVendor, VAR_6.idProduct, VAR_6.sVendor.c_str(),\n\t\t\t\tVAR_6.sProduct.c_str(), VAR_6.sSerial.c_str(), VAR_6.sOsMountDir.c_str() );\n\t}\n\t\n\t/* COMMENT_51 */\n\tfor( unsigned VAR_4=0; VAR_4<VAR_0.size(); VAR_4++ )\n\t{\n\t\tUsbStorageDevice& VAR_6 = VAR_0[VAR_4];\n\t\tif( VAR_6.sOsMountDir.empty() )\n\t\t{\n\t\t\tVAR_1->Trace( \"Ignoring %s (couldn't find in /etc/fstab)\", VAR_6.sDevice.c_str() );\n\t\t\t\n\t\t\tVAR_0.erase( VAR_0.begin()+VAR_4 );\n\t\t\t--VAR_4;\n\t\t}\n\t}\n\t\n\tVAR_1->Trace( \"Done with GetUSBStorageDevices\" );\n}",
  "func_graph_path_before": "stepmania/8490d181c2d301ccca0dc6ee52f25bbadb567a9a/MemoryCardDriverThreaded_Linux.cpp/vul/before/0.json",
  "func": "void MemoryCardDriverThreaded_Linux::GetUSBStorageDevices( vector<UsbStorageDevice>& vDevicesOut )\n{\n\tLOG->Trace( \"GetUSBStorageDevices\" );\n\t\n\tvDevicesOut.clear();\n\n\t{\n\t\tvector<RString> asDevices;\n\t\tRString sBlockDevicePath = \"/sys/block/\";\n\t\tGetFileList( sBlockDevicePath, asDevices );\n\n\t\tfor( unsigned i = 0; i < asDevices.size(); ++i )\n\t\t{\n\t\t\tconst RString &sDevice = asDevices[i];\n\t\t\tif( sDevice == \".\" || sDevice == \"..\" )\n\t\t\t\tcontinue;\n\n\t\t\tUsbStorageDevice usbd;\n\n\t\t\tRString sPath = sBlockDevicePath + sDevice + \"/\";\n\t\t\tusbd.sSysPath = sPath;\n\n\t\t\t/* Ignore non-removable devices. */\n\t\t\tRString sBuf;\n\t\t\tif( !ReadFile( sPath + \"removable\", sBuf ) )\n\t\t\t\tcontinue; // already warned\n\t\t\tif( atoi(sBuf) != 1 )\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * The kernel isn't exposing all of /sys atomically, so we end up missing\n\t\t\t * the partition due to it not being shown yet.  It won't show up until the\n\t\t\t * kernel has scanned the partition table, which can take a variable amount\n\t\t\t * of time, sometimes over a second.  Watch for the \"queue\" sysfs directory,\n\t\t\t * which is created after this, to tell when partition directories are created.\n\t\t\t */\n\t\t\tRageTimer WaitUntil;\n\t\t\tWaitUntil += 5;\n\t\t\tRString sQueueFilePath = usbd.sSysPath + \"queue\";\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tif( WaitUntil.Ago() >= 0 )\n\t\t\t\t{\n\t\t\t\t\tLOG->Warn( \"Timed out waiting for %s\", sQueueFilePath.c_str() );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif( access(usbd.sSysPath, F_OK) == -1 )\n\t\t\t\t{\n\t\t\t\t\tLOG->Warn( \"Block directory %s went away while we were waiting for %s\",\n\t\t\t\t\t\t\tusbd.sSysPath.c_str(), sQueueFilePath.c_str() );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif( access(sQueueFilePath, F_OK) != -1 )\n\t\t\t\t\tbreak;\n\n\t\t\t\tusleep(10000);\n\t\t\t}\n\n\t\t\t/* Wait for udev to finish handling device node creation */\n\t\t\tExecuteCommand( \"udevadm settle\" );\n\n\t\t\t/* If the first partition device exists, eg. /sys/block/uba/uba1, use it. */\n\t\t\tif( access(usbd.sSysPath + sDevice + \"1\", F_OK) != -1 )\n\t\t\t{\n\t\t\t\tLOG->Trace(\"OK\");\n\t\t\t\tusbd.sDevice = \"/dev/\" + sDevice + \"1\";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tLOG->Trace(\"error %s\", strerror(errno));\n\t\t\t\tusbd.sDevice = \"/dev/\" + sDevice;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * sPath/device should be a symlink to the actual device.  For USB\n\t\t\t * devices, it looks like this:\n\t\t\t *\n\t\t\t * device -> ../../devices/pci0000:00/0000:00:02.1/usb2/2-1/2-1:1.0\n\t\t\t *\n\t\t\t * \"2-1\" is \"bus-port\".\n\t\t\t */\n\t\t\tchar szLink[256];\n\t\t\tint iRet = readlink( sPath + \"device\", szLink, sizeof(szLink) );\n\t\t\tif( iRet == -1 )\n\t\t\t{\n\t\t\t\tLOG->Warn( \"readlink(\\\"%s\\\"): %s\", (sPath + \"device\").c_str(), strerror(errno) );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * The full path looks like\n\t\t\t\t *\n\t\t\t\t *   ../../devices/pci0000:00/0000:00:02.1/usb2/2-2/2-2.1/2-2.1:1.0\n\t\t\t\t *\n\t\t\t\t * In newer kernels, it looks like:\n\t\t\t\t *\n\t\t\t\t * ../../../3-2.1:1.0\n\t\t\t\t *\n\t\t\t\t * Each path element refers to a new hop in the chain.\n\t\t\t\t *  \"usb2\" = second USB host\n\t\t\t\t *  2-            second USB host,\n\t\t\t\t *   -2           port 1 on the host,\n\t\t\t\t *     .1         port 1 on an attached hub\n\t\t\t\t *       .2       ... port 2 on the next hub ...\n\t\t\t\t * \n\t\t\t\t * We want the bus number and the port of the last hop.  The level is\n\t\t\t\t * the number of hops.\n\t\t\t\t */\n\t\t\t\tszLink[iRet] = 0;\n\t\t\t\tvector<RString> asBits;\n\t\t\t\tsplit( szLink, \"/\", asBits );\n\n\t\t\t\tRString sHostPort = asBits[asBits.size()-1];\n\t\t\t\tif( !sHostPort.empty() )\n\t\t\t\t{\n\t\t\t\t\t/* Strip off the endpoint information after the colon. */\n\t\t\t\t\tsize_t pos = sHostPort.find(':');\n\t\t\t\t\tif( pos != string::npos )\n\t\t\t\t\t\tsHostPort.erase( pos );\n\t\t\t\t\t\n\t\t\t\t\t/* sHostPort is eg. 2-2.1. */\n\t\t\t\t\tsHostPort.Replace( \"-\", \".\" );\n\t\t\t\t\tasBits.clear();\n\t\t\t\t\tsplit( sHostPort, \".\", asBits );\n\t\t\t\t\tif( asBits.size() > 1 )\n\t\t\t\t\t{\n\t\t\t\t\t\tusbd.iBus = atoi( asBits[0] );\n\t\t\t\t\t\tusbd.iPort = atoi( asBits[asBits.size()-1] );\n\t\t\t\t\t\tusbd.iLevel = asBits.size() - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif( ReadFile( sPath + \"device/../idVendor\", sBuf ) )\n\t\t\t\tsscanf( sBuf, \"%x\", &usbd.idVendor );\n\n\t\t\tif( ReadFile( sPath + \"device/../idProduct\", sBuf ) )\n\t\t\t\tsscanf( sBuf, \"%x\", &usbd.idProduct );\n\n\t\t\tif( ReadFile( sPath + \"device/../serial\", sBuf ) )\n\t\t\t{\n\t\t\t\tusbd.sSerial = sBuf;\n\t\t\t\tTrimRight( usbd.sSerial );\n\t\t\t}\n\t\t\tif( ReadFile( sPath + \"device/../product\", sBuf ) )\n\t\t\t{\n\t\t\t\tusbd.sProduct = sBuf;\n\t\t\t\tTrimRight( usbd.sProduct );\n\t\t\t}\n\t\t\tif( ReadFile( sPath + \"device/../manufacturer\", sBuf ) )\n\t\t\t{\n\t\t\t\tusbd.sVendor = sBuf;\n\t\t\t\tTrimRight( usbd.sVendor );\n\t\t\t}\n\n\t\t\tvDevicesOut.push_back( usbd );\n\t\t}\n\t}\n\n\t{\n\t\t// Find where each device is mounted. Output looks like:\n\t\t\n\t\t// /dev/sda1               /mnt/flash1             auto    noauto,owner 0 0\n\t\t// /dev/sdb1               /mnt/flash2             auto    noauto,owner 0 0\n\t\t// /dev/sdc1               /mnt/flash3             auto    noauto,owner 0 0\n\n\t\tstd::ifstream f(\"/etc/fstab\");\n\t\tif (f.fail())\n\t\t{\n\t\t\tLOG->Warn( \"can't open '/etc/fstab': %s\", strerror(errno) );\n\t\t\treturn;\n\t\t}\n\n\t\tstd::string line;\n\t\twhile( !f.eof() )\n\t\t{\n\t\t\tstd::getline(f, line);\n\t\t\tif (f.eof())\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (f.fail())\n\t\t\t{\n\t\t\t\tLOG->Warn( \"error reading '/etc/fstab': %s\", strerror(errno) );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tchar szScsiDevice[1024];\n\t\t\tchar szMountPoint[1024];\n\t\t\tint iRet = sscanf( line.c_str(), \"%s %s\", szScsiDevice, szMountPoint );\n\t\t\tif( iRet != 2 || szScsiDevice[0] == '#')\n\t\t\t\tcontinue;\t// don't process this line\n\n\t\t\t/* Get the real kernel device name, which should match\n\t\t\t * the name from /sys/block, by following symlinks in\n\t\t\t * /dev.  This allows us to specify persistent names in\n\t\t\t * /etc/fstab using things like /dev/device/by-path. */\n\t\t\tchar szUnderlyingDevice[PATH_MAX];\n\t\t\tif( realpath(szScsiDevice, szUnderlyingDevice) == nullptr )\n\t\t\t{\n\t\t\t\t// \"No such file or directory\" is understandable\n\t\t\t\tif (errno != ENOENT)\n\t\t\t\t\tLOG->Warn( \"realpath(\\\"%s\\\"): %s\", szScsiDevice, strerror(errno) );\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tRString sMountPoint = szMountPoint;\n\t\t\tTrimLeft( sMountPoint );\n\t\t\tTrimRight( sMountPoint );\n\n\t\t\t// search for the mountpoint corresponding to the device\n\t\t\tfor( unsigned i=0; i<vDevicesOut.size(); i++ )\n\t\t\t{\n\t\t\t\tUsbStorageDevice& usbd = vDevicesOut[i];\n\t\t\t\tif( usbd.sDevice == szUnderlyingDevice )\t// found our match\n\t\t\t\t{\n\t\t\t\t\t// Use the device entry from fstab so the mount command works\n\t\t\t\t\tusbd.sDevice = szScsiDevice;\n\t\t\t\t\tusbd.sOsMountDir = sMountPoint;\n\t\t\t\t\tbreak;\t// stop looking for a match\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor( unsigned i=0; i<vDevicesOut.size(); i++ )\n\t{\n\t\tUsbStorageDevice& usbd = vDevicesOut[i];\n\t\tLOG->Trace( \"    sDevice: %s, iBus: %d, iLevel: %d, iPort: %d, id: %04X:%04X, Vendor: '%s', Product: '%s', sSerial: \\\"%s\\\", sOsMountDir: %s\",\n\t\t\t\tusbd.sDevice.c_str(), usbd.iBus, usbd.iLevel, usbd.iPort, usbd.idVendor, usbd.idProduct, usbd.sVendor.c_str(),\n\t\t\t\tusbd.sProduct.c_str(), usbd.sSerial.c_str(), usbd.sOsMountDir.c_str() );\n\t}\n\t\n\t/* Remove any devices that we couldn't find a mountpoint for. */\n\tfor( unsigned i=0; i<vDevicesOut.size(); i++ )\n\t{\n\t\tUsbStorageDevice& usbd = vDevicesOut[i];\n\t\tif( usbd.sOsMountDir.empty() )\n\t\t{\n\t\t\tLOG->Trace( \"Ignoring %s (couldn't find in /etc/fstab)\", usbd.sDevice.c_str() );\n\t\t\t\n\t\t\tvDevicesOut.erase( vDevicesOut.begin()+i );\n\t\t\t--i;\n\t\t}\n\t}\n\t\n\tLOG->Trace( \"Done with GetUSBStorageDevices\" );\n}",
  "abstract_func": "void MemoryCardDriverThreaded_Linux::GetUSBStorageDevices( vector<UsbStorageDevice>& VAR_0 )\n{\n\tVAR_1->Trace( \"GetUSBStorageDevices\" );\n\t\n\tVAR_0.clear();\n\n\t{\n\t\tvector<RString> VAR_2;\n\t\tRString VAR_3 = \"/sys/block/\";\n\t\tGetFileList( VAR_3, VAR_2 );\n\n\t\tfor( unsigned VAR_4 = 0; VAR_4 < VAR_2.size(); ++VAR_4 )\n\t\t{\n\t\t\tconst RString &VAR_5 = VAR_2[VAR_4];\n\t\t\tif( VAR_5 == \".\" || VAR_5 == \"..\" )\n\t\t\t\tcontinue;\n\n\t\t\tUsbStorageDevice VAR_6;\n\n\t\t\tRString VAR_7 = VAR_3 + VAR_5 + \"/\";\n\t\t\tVAR_6.sSysPath = VAR_7;\n\n\t\t\t/* COMMENT_0 */\n\t\t\tRString VAR_8;\n\t\t\tif( !ReadFile( VAR_7 + \"removable\", VAR_8 ) )\n\t\t\t\tcontinue; /* COMMENT_1 */\n\t\t\tif( atoi(VAR_8) != 1 )\n\t\t\t\tcontinue;\n\n\t\t\t/* COMMENT_2 */\n                                                                            \n                                                                              \n                                                                              \n                                                                               \n                                                                                  \n      \n\t\t\tRageTimer VAR_9;\n\t\t\tVAR_9 += 5;\n\t\t\tRString VAR_10 = VAR_6.sSysPath + \"queue\";\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tif( VAR_9.Ago() >= 0 )\n\t\t\t\t{\n\t\t\t\t\tVAR_1->Warn( \"Timed out waiting for %s\", VAR_10.c_str() );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif( access(VAR_6.sSysPath, VAR_11) == -1 )\n\t\t\t\t{\n\t\t\t\t\tVAR_1->Warn( \"Block directory %s went away while we were waiting for %s\",\n\t\t\t\t\t\t\tVAR_6.sSysPath.c_str(), VAR_10.c_str() );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif( access(VAR_10, VAR_11) != -1 )\n\t\t\t\t\tbreak;\n\n\t\t\t\tusleep(10000);\n\t\t\t}\n\n\t\t\t/* COMMENT_9 */\n\t\t\tExecuteCommand( \"udevadm settle\" );\n\n\t\t\t/* COMMENT_10 */\n\t\t\tif( access(VAR_6.sSysPath + VAR_5 + \"1\", VAR_11) != -1 )\n\t\t\t{\n\t\t\t\tVAR_1->Trace(\"OK\");\n\t\t\t\tVAR_6.sDevice = \"/dev/\" + VAR_5 + \"1\";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tVAR_1->Trace(\"error %s\", strerror(VAR_12));\n\t\t\t\tVAR_6.sDevice = \"/dev/\" + VAR_5;\n\t\t\t}\n\n\t\t\t/* COMMENT_11 */\n                                                                     \n                                  \n     \n                                                                      \n     \n                          \n      \n\t\t\tchar VAR_13[256];\n\t\t\tint VAR_14 = readlink( VAR_7 + \"device\", VAR_13, sizeof(VAR_13) );\n\t\t\tif( VAR_14 == -1 )\n\t\t\t{\n\t\t\t\tVAR_1->Warn( \"readlink(\\\"%s\\\"): %s\", (VAR_7 + \"device\").c_str(), strerror(VAR_12) );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* COMMENT_18 */\n                               \n      \n                                                                       \n      \n                                       \n      \n                         \n      \n                                                          \n                                \n                                      \n                                         \n                                               \n                                                    \n       \n                                                                         \n                          \n       \n\t\t\t\tVAR_13[VAR_14] = 0;\n\t\t\t\tvector<RString> VAR_15;\n\t\t\t\tsplit( VAR_13, \"/\", VAR_15 );\n\n\t\t\t\tRString VAR_16 = VAR_15[VAR_15.size()-1];\n\t\t\t\tif( !VAR_16.empty() )\n\t\t\t\t{\n\t\t\t\t\t/* COMMENT_34 */\n\t\t\t\t\tsize_t VAR_17 = VAR_16.find(':');\n\t\t\t\t\tif( VAR_17 != string::npos )\n\t\t\t\t\t\tVAR_16.erase( VAR_17 );\n\t\t\t\t\t\n\t\t\t\t\t/* COMMENT_35 */\n\t\t\t\t\tVAR_16.Replace( \"-\", \".\" );\n\t\t\t\t\tVAR_15.clear();\n\t\t\t\t\tsplit( VAR_16, \".\", VAR_15 );\n\t\t\t\t\tif( VAR_15.size() > 1 )\n\t\t\t\t\t{\n\t\t\t\t\t\tVAR_6.iBus = atoi( VAR_15[0] );\n\t\t\t\t\t\tVAR_6.iPort = atoi( VAR_15[VAR_15.size()-1] );\n\t\t\t\t\t\tVAR_6.iLevel = VAR_15.size() - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif( ReadFile( VAR_7 + \"device/../idVendor\", VAR_8 ) )\n\t\t\t\tsscanf( VAR_8, \"%x\", &VAR_6.idVendor );\n\n\t\t\tif( ReadFile( VAR_7 + \"device/../idProduct\", VAR_8 ) )\n\t\t\t\tsscanf( VAR_8, \"%x\", &VAR_6.idProduct );\n\n\t\t\tif( ReadFile( VAR_7 + \"device/../serial\", VAR_8 ) )\n\t\t\t{\n\t\t\t\tVAR_6.sSerial = VAR_8;\n\t\t\t\tTrimRight( VAR_6.sSerial );\n\t\t\t}\n\t\t\tif( ReadFile( VAR_7 + \"device/../product\", VAR_8 ) )\n\t\t\t{\n\t\t\t\tVAR_6.sProduct = VAR_8;\n\t\t\t\tTrimRight( VAR_6.sProduct );\n\t\t\t}\n\t\t\tif( ReadFile( VAR_7 + \"device/../manufacturer\", VAR_8 ) )\n\t\t\t{\n\t\t\t\tVAR_6.sVendor = VAR_8;\n\t\t\t\tTrimRight( VAR_6.sVendor );\n\t\t\t}\n\n\t\t\tVAR_0.push_back( VAR_6 );\n\t\t}\n\t}\n\n\t{\n\t\t/* COMMENT_36 */\n\t\t\n\t\t/* COMMENT_37 */\n\t\t/* COMMENT_38 */\n\t\t/* COMMENT_39 */\n\n\t\tstd::ifstream VAR_18(\"/etc/fstab\");\n\t\tif (VAR_18.fail())\n\t\t{\n\t\t\tVAR_1->Warn( \"can't open '/etc/fstab': %s\", strerror(VAR_12) );\n\t\t\treturn;\n\t\t}\n\n\t\tstd::string VAR_19;\n\t\twhile( !VAR_18.eof() )\n\t\t{\n\t\t\tstd::getline(VAR_18, VAR_19);\n\t\t\tif (VAR_18.eof())\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (VAR_18.fail())\n\t\t\t{\n\t\t\t\tVAR_1->Warn( \"error reading '/etc/fstab': %s\", strerror(VAR_12) );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tchar VAR_20[1024];\n\t\t\tchar VAR_21[1024];\n\t\t\tint VAR_14 = sscanf( VAR_19.c_str(), \"%s %s\", VAR_20, VAR_21 );\n\t\t\tif( VAR_14 != 2 || VAR_20[0] == '#')\n\t\t\t\tcontinue;\t/* COMMENT_40 */\n\n\t\t\t/* COMMENT_41 */\n                                                        \n                                                          \n                                                          \n\t\t\tchar VAR_22[VAR_23];\n\t\t\tif( realpath(VAR_20, VAR_22) == nullptr )\n\t\t\t{\n\t\t\t\t/* COMMENT_45 */\n\t\t\t\tif (VAR_12 != VAR_24)\n\t\t\t\t\tVAR_1->Warn( \"realpath(\\\"%s\\\"): %s\", VAR_20, strerror(VAR_12) );\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tRString VAR_25 = VAR_21;\n\t\t\tTrimLeft( VAR_25 );\n\t\t\tTrimRight( VAR_25 );\n\n\t\t\t/* COMMENT_46 */\n\t\t\tfor( unsigned VAR_4=0; VAR_4<VAR_0.size(); VAR_4++ )\n\t\t\t{\n\t\t\t\tUsbStorageDevice& VAR_6 = VAR_0[VAR_4];\n\t\t\t\tif( VAR_6.sDevice == VAR_22 )\t/* COMMENT_47 */\n\t\t\t\t{\n\t\t\t\t\t/* COMMENT_48 */\n\t\t\t\t\tVAR_6.sDevice = VAR_20;\n\t\t\t\t\tVAR_6.sOsMountDir = VAR_25;\n\t\t\t\t\tbreak;\t/* COMMENT_49 */\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor( unsigned VAR_4=0; VAR_4<VAR_0.size(); VAR_4++ )\n\t{\n\t\tUsbStorageDevice& VAR_6 = VAR_0[VAR_4];\n\t\tVAR_1->Trace( \"    sDevice: %s, iBus: %d, iLevel: %d, iPort: %d, id: %04X:%04X, Vendor: '%s', Product: '%s', sSerial: \\\"%s\\\", sOsMountDir: %s\",\n\t\t\t\tVAR_6.sDevice.c_str(), VAR_6.iBus, VAR_6.iLevel, VAR_6.iPort, VAR_6.idVendor, VAR_6.idProduct, VAR_6.sVendor.c_str(),\n\t\t\t\tVAR_6.sProduct.c_str(), VAR_6.sSerial.c_str(), VAR_6.sOsMountDir.c_str() );\n\t}\n\t\n\t/* COMMENT_50 */\n\tfor( unsigned VAR_4=0; VAR_4<VAR_0.size(); VAR_4++ )\n\t{\n\t\tUsbStorageDevice& VAR_6 = VAR_0[VAR_4];\n\t\tif( VAR_6.sOsMountDir.empty() )\n\t\t{\n\t\t\tVAR_1->Trace( \"Ignoring %s (couldn't find in /etc/fstab)\", VAR_6.sDevice.c_str() );\n\t\t\t\n\t\t\tVAR_0.erase( VAR_0.begin()+VAR_4 );\n\t\t\t--VAR_4;\n\t\t}\n\t}\n\t\n\tVAR_1->Trace( \"Done with GetUSBStorageDevices\" );\n}",
  "func_graph_path": "stepmania/8490d181c2d301ccca0dc6ee52f25bbadb567a9a/MemoryCardDriverThreaded_Linux.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -165,29 +165,31 @@\n \t\t// /dev/sda1               /mnt/flash1             auto    noauto,owner 0 0\n \t\t// /dev/sdb1               /mnt/flash2             auto    noauto,owner 0 0\n \t\t// /dev/sdc1               /mnt/flash3             auto    noauto,owner 0 0\n-\t\t\n-\t\tRString fn = \"/rootfs/etc/fstab\";\n-\t\tRageFile f;\n-\t\tif( !f.Open(fn) )\n-\t\t{\n-\t\t\tLOG->Warn( \"can't open '%s': %s\", fn.c_str(), f.GetError().c_str() );\n+\n+\t\tstd::ifstream f(\"/etc/fstab\");\n+\t\tif (f.fail())\n+\t\t{\n+\t\t\tLOG->Warn( \"can't open '/etc/fstab': %s\", strerror(errno) );\n \t\t\treturn;\n \t\t}\n-\t\t\n-\t\tRString sLine;\n-\t\twhile( !f.AtEOF() )\n-\t\t{\n-\t\t\tswitch( f.GetLine(sLine) )\n-\t\t\t{\n-\t\t\tcase 0: continue; /* eof */\n-\t\t\tcase -1:\n-\t\t\t\tLOG->Warn( \"error reading '%s': %s\", fn.c_str(), f.GetError().c_str() );\n+\n+\t\tstd::string line;\n+\t\twhile( !f.eof() )\n+\t\t{\n+\t\t\tstd::getline(f, line);\n+\t\t\tif (f.eof())\n+\t\t\t{\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\telse if (f.fail())\n+\t\t\t{\n+\t\t\t\tLOG->Warn( \"error reading '/etc/fstab': %s\", strerror(errno) );\n \t\t\t\treturn;\n \t\t\t}\n \n \t\t\tchar szScsiDevice[1024];\n \t\t\tchar szMountPoint[1024];\n-\t\t\tint iRet = sscanf( sLine, \"%s %s\", szScsiDevice, szMountPoint );\n+\t\t\tint iRet = sscanf( line.c_str(), \"%s %s\", szScsiDevice, szMountPoint );\n \t\t\tif( iRet != 2 || szScsiDevice[0] == '#')\n \t\t\t\tcontinue;\t// don't process this line\n ",
  "diff_line_info": {
    "deleted_lines": [
      "\t\t",
      "\t\tRString fn = \"/rootfs/etc/fstab\";",
      "\t\tRageFile f;",
      "\t\tif( !f.Open(fn) )",
      "\t\t{",
      "\t\t\tLOG->Warn( \"can't open '%s': %s\", fn.c_str(), f.GetError().c_str() );",
      "\t\t",
      "\t\tRString sLine;",
      "\t\twhile( !f.AtEOF() )",
      "\t\t{",
      "\t\t\tswitch( f.GetLine(sLine) )",
      "\t\t\t{",
      "\t\t\tcase 0: continue; /* eof */",
      "\t\t\tcase -1:",
      "\t\t\t\tLOG->Warn( \"error reading '%s': %s\", fn.c_str(), f.GetError().c_str() );",
      "\t\t\tint iRet = sscanf( sLine, \"%s %s\", szScsiDevice, szMountPoint );"
    ],
    "added_lines": [
      "",
      "\t\tstd::ifstream f(\"/etc/fstab\");",
      "\t\tif (f.fail())",
      "\t\t{",
      "\t\t\tLOG->Warn( \"can't open '/etc/fstab': %s\", strerror(errno) );",
      "",
      "\t\tstd::string line;",
      "\t\twhile( !f.eof() )",
      "\t\t{",
      "\t\t\tstd::getline(f, line);",
      "\t\t\tif (f.eof())",
      "\t\t\t{",
      "\t\t\t\tcontinue;",
      "\t\t\t}",
      "\t\t\telse if (f.fail())",
      "\t\t\t{",
      "\t\t\t\tLOG->Warn( \"error reading '/etc/fstab': %s\", strerror(errno) );",
      "\t\t\tint iRet = sscanf( line.c_str(), \"%s %s\", szScsiDevice, szMountPoint );"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/stepmania/stepmania/pull/2184",
  "description": {
    "pr_info": {
      "title": "Remove access to the root FS from lua",
      "number": 2184
    },
    "comment": [
      "On linux `/` is mounted to `/rootfs` in RageFile, which allows access to the _whole_ filesystem from lua. This means themes and mod files can re-write user data and extract files via USB profiles.\r\n    \r\n`/rootfs` was only added for internal use by the alsa, oss and memory card drivers, so it can be easily replaced with direct fstream file access.\r\n",
      "Good spot, this behaviour hasn't been needed in a very very long time. Will also port to OF, thanks for reporting!"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95\n\nThe commit message clearly addresses a security issue by removing unauthorized access to the root filesystem from Lua scripts. The code change directly remedies this by replacing the use of /rootfs with direct file access, which fixes a vulnerability. The consistency between the commit message and code changes supports this classification."
}