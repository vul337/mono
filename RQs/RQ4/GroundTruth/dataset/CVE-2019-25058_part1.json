{
  "cve_id": "CVE-2019-25058",
  "cwe_ids": [
    "CWE-863"
  ],
  "cvss_vector": "AV:L/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "USBGuard/usbguard",
  "commit_msg": "dbus: Add missing checks for authorization using Polkit",
  "commit_hash": "df5f01c6ed0c20d269f7239901d21883cc871bbb",
  "git_url": "https://github.com/USBGuard/usbguard/commit/df5f01c6ed0c20d269f7239901d21883cc871bbb",
  "file_path": "src/DBus/DBusBridge.cpp",
  "func_name": "DBusBridge::handleRootMethodCall",
  "func_before": "void DBusBridge::handleRootMethodCall(const std::string& method_name, GVariant* parameters, GDBusMethodInvocation* invocation)\n  {\n    if (method_name == \"getParameter\") {\n      const char* name_cstr = nullptr;\n      g_variant_get(parameters, \"(&s)\", &name_cstr);\n      std::string name(name_cstr);\n      auto value = getParameter(name);\n      g_dbus_method_invocation_return_value(invocation, g_variant_new(\"(s)\", value.c_str()));\n      return;\n    }\n\n    if (method_name == \"setParameter\") {\n      const char* name_cstr = nullptr;\n      const char* value_cstr = nullptr;\n      g_variant_get(parameters, \"(&s&s)\", &name_cstr, &value_cstr);\n      const std::string name(name_cstr);\n      const std::string value(value_cstr);\n      auto previous_value = setParameter(name, value);\n      g_dbus_method_invocation_return_value(invocation, g_variant_new(\"(s)\", previous_value.c_str()));\n      return;\n    }\n\n    g_dbus_method_invocation_return_error(invocation, G_DBUS_ERROR,\n      G_DBUS_ERROR_UNKNOWN_METHOD, \"Unknown method interface\");\n    return;\n  }",
  "abstract_func_before": "void DBusBridge::handleRootMethodCall(const std::string& VAR_0, GVariant* VAR_1, GDBusMethodInvocation* VAR_2)\n  {\n    if (VAR_0 == \"getParameter\") {\n      const char* VAR_3 = nullptr;\n      g_variant_get(VAR_1, \"(&s)\", &VAR_3);\n      std::string name(name_cstr);\n      auto VAR_4 = getParameter(VAR_5);\n      g_dbus_method_invocation_return_value(VAR_2, g_variant_new(\"(s)\", VAR_4.c_str()));\n      return;\n    }\n\n    if (VAR_0 == \"setParameter\") {\n      const char* name_cstr = nullptr;\n      const char* VAR_6 = nullptr;\n      g_variant_get(VAR_1, \"(&s&s)\", &name_cstr, &VAR_6);\n      const std::string name(name_cstr);\n      const std::string value(value_cstr);\n      auto VAR_7 = setParameter(VAR_5, VAR_4);\n      g_dbus_method_invocation_return_value(VAR_2, g_variant_new(\"(s)\", VAR_7.c_str()));\n      return;\n    }\n\n    g_dbus_method_invocation_return_error(VAR_2, VAR_8,\n      VAR_9, \"Unknown method interface\");\n    return;\n  }",
  "func_graph_path_before": "USBGuard/usbguard/df5f01c6ed0c20d269f7239901d21883cc871bbb/DBusBridge.cpp/vul/before/0.json",
  "func": "void DBusBridge::handleRootMethodCall(const std::string& method_name, GVariant* parameters, GDBusMethodInvocation* invocation)\n  {\n    if (method_name == \"getParameter\") {\n      if (! isAuthorizedByPolkit(invocation)) {\n        return;\n      }\n\n      const char* name_cstr = nullptr;\n      g_variant_get(parameters, \"(&s)\", &name_cstr);\n      std::string name(name_cstr);\n      auto value = getParameter(name);\n      g_dbus_method_invocation_return_value(invocation, g_variant_new(\"(s)\", value.c_str()));\n      return;\n    }\n\n    if (method_name == \"setParameter\") {\n      if (! isAuthorizedByPolkit(invocation)) {\n        return;\n      }\n\n      const char* name_cstr = nullptr;\n      const char* value_cstr = nullptr;\n      g_variant_get(parameters, \"(&s&s)\", &name_cstr, &value_cstr);\n      const std::string name(name_cstr);\n      const std::string value(value_cstr);\n      auto previous_value = setParameter(name, value);\n      g_dbus_method_invocation_return_value(invocation, g_variant_new(\"(s)\", previous_value.c_str()));\n      return;\n    }\n\n    g_dbus_method_invocation_return_error(invocation, G_DBUS_ERROR,\n      G_DBUS_ERROR_UNKNOWN_METHOD, \"Unknown method interface\");\n    return;\n  }",
  "abstract_func": "void DBusBridge::handleRootMethodCall(const std::string& VAR_0, GVariant* VAR_1, GDBusMethodInvocation* VAR_2)\n  {\n    if (VAR_0 == \"getParameter\") {\n      if (! isAuthorizedByPolkit(VAR_2)) {\n        return;\n      }\n\n      const char* VAR_3 = nullptr;\n      g_variant_get(VAR_1, \"(&s)\", &VAR_3);\n      std::string name(name_cstr);\n      auto VAR_4 = getParameter(VAR_5);\n      g_dbus_method_invocation_return_value(VAR_2, g_variant_new(\"(s)\", VAR_4.c_str()));\n      return;\n    }\n\n    if (VAR_0 == \"setParameter\") {\n      if (! isAuthorizedByPolkit(VAR_2)) {\n        return;\n      }\n\n      const char* name_cstr = nullptr;\n      const char* VAR_6 = nullptr;\n      g_variant_get(VAR_1, \"(&s&s)\", &name_cstr, &VAR_6);\n      const std::string name(name_cstr);\n      const std::string value(value_cstr);\n      auto VAR_7 = setParameter(VAR_5, VAR_4);\n      g_dbus_method_invocation_return_value(VAR_2, g_variant_new(\"(s)\", VAR_7.c_str()));\n      return;\n    }\n\n    g_dbus_method_invocation_return_error(VAR_2, VAR_8,\n      VAR_9, \"Unknown method interface\");\n    return;\n  }",
  "func_graph_path": "USBGuard/usbguard/df5f01c6ed0c20d269f7239901d21883cc871bbb/DBusBridge.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,10 @@\n void DBusBridge::handleRootMethodCall(const std::string& method_name, GVariant* parameters, GDBusMethodInvocation* invocation)\n   {\n     if (method_name == \"getParameter\") {\n+      if (! isAuthorizedByPolkit(invocation)) {\n+        return;\n+      }\n+\n       const char* name_cstr = nullptr;\n       g_variant_get(parameters, \"(&s)\", &name_cstr);\n       std::string name(name_cstr);\n@@ -10,6 +14,10 @@\n     }\n \n     if (method_name == \"setParameter\") {\n+      if (! isAuthorizedByPolkit(invocation)) {\n+        return;\n+      }\n+\n       const char* name_cstr = nullptr;\n       const char* value_cstr = nullptr;\n       g_variant_get(parameters, \"(&s&s)\", &name_cstr, &value_cstr);",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "      if (! isAuthorizedByPolkit(invocation)) {",
      "        return;",
      "      }",
      "",
      "      if (! isAuthorizedByPolkit(invocation)) {",
      "        return;",
      "      }",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/USBGuard/usbguard/pull/531",
  "description": {
    "pr_info": {
      "title": "[CVE-2019-25058] Fix unauthorized access via D-Bus (fixes #273, fixes #403)",
      "number": 531
    },
    "comment": [
      "Fixes #273\r\nFixes #403\r\n\r\n- Fix `.policy` file:\r\n  - Replace unsupported value `auth_self_keep_session` by `auth_self_keep` to fix the Polkit parse error so that Polkit stops ignoring the USBGuard `.policy` file.\r\n  - Drop actions/methods from the policy that no longer exist.\r\n  - Add actions/methods to the policy file that have been missing.\r\n- Make `usbguard-dbus` call out to Polkit for authorization so that the policies from the `.policy` file are actually respected.\r\n- Add CI to protect against policy file parse error regressions.\r\n\r\nCC @radosroka @Cropi ",
      "I don't have any objections."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9  \n\nThe patch adds authorization checks using Polkit, addressing a vulnerability where methods were callable without proper authorization. The code changes and commit message align with security improvements."
}