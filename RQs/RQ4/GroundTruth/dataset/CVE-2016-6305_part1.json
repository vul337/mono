{
  "cve_id": "CVE-2016-6305",
  "cwe_ids": [
    "CWE-20"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "openssl",
  "commit_msg": "Fix a hang with SSL_peek()\n\nIf while calling SSL_peek() we read an empty record then we go into an\ninfinite loop, continually trying to read data from the empty record and\nnever making any progress. This could be exploited by a malicious peer in\na Denial Of Service attack.\n\nCVE-2016-6305\n\nGitHub Issue #1563\n\nReviewed-by: Rich Salz <rsalz@openssl.org>",
  "commit_hash": "63658103d4441924f8dbfc517b99bb54758a98b9",
  "git_url": "https://github.com/openssl/openssl/commit/63658103d4441924f8dbfc517b99bb54758a98b9",
  "file_path": "ssl/record/rec_layer_s3.c",
  "func_name": "ssl3_read_bytes",
  "func_before": "int ssl3_read_bytes(SSL *s, int type, int *recvd_type, unsigned char *buf,\n                    int len, int peek)\n{\n    int al, i, j, ret;\n    unsigned int n, curr_rec, num_recs, read_bytes;\n    SSL3_RECORD *rr;\n    SSL3_BUFFER *rbuf;\n    void (*cb) (const SSL *ssl, int type2, int val) = NULL;\n\n    rbuf = &s->rlayer.rbuf;\n\n    if (!SSL3_BUFFER_is_initialised(rbuf)) {\n        /* Not initialized yet */\n        if (!ssl3_setup_read_buffer(s))\n            return (-1);\n    }\n\n    if ((type && (type != SSL3_RT_APPLICATION_DATA)\n         && (type != SSL3_RT_HANDSHAKE)) || (peek\n                                             && (type !=\n                                                 SSL3_RT_APPLICATION_DATA))) {\n        SSLerr(SSL_F_SSL3_READ_BYTES, ERR_R_INTERNAL_ERROR);\n        return -1;\n    }\n\n    if ((type == SSL3_RT_HANDSHAKE) && (s->rlayer.handshake_fragment_len > 0))\n        /* (partially) satisfy request from storage */\n    {\n        unsigned char *src = s->rlayer.handshake_fragment;\n        unsigned char *dst = buf;\n        unsigned int k;\n\n        /* peek == 0 */\n        n = 0;\n        while ((len > 0) && (s->rlayer.handshake_fragment_len > 0)) {\n            *dst++ = *src++;\n            len--;\n            s->rlayer.handshake_fragment_len--;\n            n++;\n        }\n        /* move any remaining fragment bytes: */\n        for (k = 0; k < s->rlayer.handshake_fragment_len; k++)\n            s->rlayer.handshake_fragment[k] = *src++;\n\n        if (recvd_type != NULL)\n            *recvd_type = SSL3_RT_HANDSHAKE;\n\n        return n;\n    }\n\n    /*\n     * Now s->rlayer.handshake_fragment_len == 0 if type == SSL3_RT_HANDSHAKE.\n     */\n\n    if (!ossl_statem_get_in_handshake(s) && SSL_in_init(s)) {\n        /* type == SSL3_RT_APPLICATION_DATA */\n        i = s->handshake_func(s);\n        if (i < 0)\n            return (i);\n        if (i == 0) {\n            SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_SSL_HANDSHAKE_FAILURE);\n            return (-1);\n        }\n    }\n start:\n    s->rwstate = SSL_NOTHING;\n\n    /*-\n     * For each record 'i' up to |num_recs]\n     * rr[i].type     - is the type of record\n     * rr[i].data,    - data\n     * rr[i].off,     - offset into 'data' for next read\n     * rr[i].length,  - number of bytes.\n     */\n    rr = s->rlayer.rrec;\n    num_recs = RECORD_LAYER_get_numrpipes(&s->rlayer);\n\n    do {\n        /* get new records if necessary */\n        if (num_recs == 0) {\n            ret = ssl3_get_record(s);\n            if (ret <= 0)\n                return (ret);\n            num_recs = RECORD_LAYER_get_numrpipes(&s->rlayer);\n            if (num_recs == 0) {\n                /* Shouldn't happen */\n                al = SSL_AD_INTERNAL_ERROR;\n                SSLerr(SSL_F_SSL3_READ_BYTES, ERR_R_INTERNAL_ERROR);\n                goto f_err;\n            }\n        }\n        /* Skip over any records we have already read */\n        for (curr_rec = 0;\n             curr_rec < num_recs && SSL3_RECORD_is_read(&rr[curr_rec]);\n             curr_rec++) ;\n        if (curr_rec == num_recs) {\n            RECORD_LAYER_set_numrpipes(&s->rlayer, 0);\n            num_recs = 0;\n            curr_rec = 0;\n        }\n    } while (num_recs == 0);\n    rr = &rr[curr_rec];\n\n    /*\n     * Reset the count of consecutive warning alerts if we've got a non-empty\n     * record that isn't an alert.\n     */\n    if (SSL3_RECORD_get_type(rr) != SSL3_RT_ALERT\n            && SSL3_RECORD_get_length(rr) != 0)\n        s->rlayer.alert_count = 0;\n\n    /* we now have a packet which can be read and processed */\n\n    if (s->s3->change_cipher_spec /* set when we receive ChangeCipherSpec,\n                                   * reset by ssl3_get_finished */\n        && (SSL3_RECORD_get_type(rr) != SSL3_RT_HANDSHAKE)) {\n        al = SSL_AD_UNEXPECTED_MESSAGE;\n        SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_DATA_BETWEEN_CCS_AND_FINISHED);\n        goto f_err;\n    }\n\n    /*\n     * If the other end has shut down, throw anything we read away (even in\n     * 'peek' mode)\n     */\n    if (s->shutdown & SSL_RECEIVED_SHUTDOWN) {\n        SSL3_RECORD_set_length(rr, 0);\n        s->rwstate = SSL_NOTHING;\n        return (0);\n    }\n\n    if (type == SSL3_RECORD_get_type(rr)\n        || (SSL3_RECORD_get_type(rr) == SSL3_RT_CHANGE_CIPHER_SPEC\n            && type == SSL3_RT_HANDSHAKE && recvd_type != NULL)) {\n        /*\n         * SSL3_RT_APPLICATION_DATA or\n         * SSL3_RT_HANDSHAKE or\n         * SSL3_RT_CHANGE_CIPHER_SPEC\n         */\n        /*\n         * make sure that we are not getting application data when we are\n         * doing a handshake for the first time\n         */\n        if (SSL_in_init(s) && (type == SSL3_RT_APPLICATION_DATA) &&\n            (s->enc_read_ctx == NULL)) {\n            al = SSL_AD_UNEXPECTED_MESSAGE;\n            SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_APP_DATA_IN_HANDSHAKE);\n            goto f_err;\n        }\n\n        if (type == SSL3_RT_HANDSHAKE\n            && SSL3_RECORD_get_type(rr) == SSL3_RT_CHANGE_CIPHER_SPEC\n            && s->rlayer.handshake_fragment_len > 0) {\n            al = SSL_AD_UNEXPECTED_MESSAGE;\n            SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_CCS_RECEIVED_EARLY);\n            goto f_err;\n        }\n\n        if (recvd_type != NULL)\n            *recvd_type = SSL3_RECORD_get_type(rr);\n\n        if (len <= 0)\n            return (len);\n\n        read_bytes = 0;\n        do {\n            if ((unsigned int)len - read_bytes > SSL3_RECORD_get_length(rr))\n                n = SSL3_RECORD_get_length(rr);\n            else\n                n = (unsigned int)len - read_bytes;\n\n            memcpy(buf, &(rr->data[rr->off]), n);\n            buf += n;\n            if (!peek) {\n                SSL3_RECORD_sub_length(rr, n);\n                SSL3_RECORD_add_off(rr, n);\n                if (SSL3_RECORD_get_length(rr) == 0) {\n                    s->rlayer.rstate = SSL_ST_READ_HEADER;\n                    SSL3_RECORD_set_off(rr, 0);\n                    SSL3_RECORD_set_read(rr);\n                }\n            }\n            if (SSL3_RECORD_get_length(rr) == 0\n                || (peek && n == SSL3_RECORD_get_length(rr))) {\n                curr_rec++;\n                rr++;\n            }\n            read_bytes += n;\n        } while (type == SSL3_RT_APPLICATION_DATA && curr_rec < num_recs\n                 && read_bytes < (unsigned int)len);\n        if (read_bytes == 0) {\n            /* We must have read empty records. Get more data */\n            goto start;\n        }\n        if (!peek && curr_rec == num_recs\n            && (s->mode & SSL_MODE_RELEASE_BUFFERS)\n            && SSL3_BUFFER_get_left(rbuf) == 0)\n            ssl3_release_read_buffer(s);\n        return read_bytes;\n    }\n\n    /*\n     * If we get here, then type != rr->type; if we have a handshake message,\n     * then it was unexpected (Hello Request or Client Hello) or invalid (we\n     * were actually expecting a CCS).\n     */\n\n    /*\n     * Lets just double check that we've not got an SSLv2 record\n     */\n    if (rr->rec_version == SSL2_VERSION) {\n        /*\n         * Should never happen. ssl3_get_record() should only give us an SSLv2\n         * record back if this is the first packet and we are looking for an\n         * initial ClientHello. Therefore |type| should always be equal to\n         * |rr->type|. If not then something has gone horribly wrong\n         */\n        al = SSL_AD_INTERNAL_ERROR;\n        SSLerr(SSL_F_SSL3_READ_BYTES, ERR_R_INTERNAL_ERROR);\n        goto f_err;\n    }\n\n    if (s->method->version == TLS_ANY_VERSION\n        && (s->server || rr->type != SSL3_RT_ALERT)) {\n        /*\n         * If we've got this far and still haven't decided on what version\n         * we're using then this must be a client side alert we're dealing with\n         * (we don't allow heartbeats yet). We shouldn't be receiving anything\n         * other than a ClientHello if we are a server.\n         */\n        s->version = rr->rec_version;\n        al = SSL_AD_UNEXPECTED_MESSAGE;\n        SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_UNEXPECTED_MESSAGE);\n        goto f_err;\n    }\n\n    /*\n     * In case of record types for which we have 'fragment' storage, fill\n     * that so that we can process the data at a fixed place.\n     */\n    {\n        unsigned int dest_maxlen = 0;\n        unsigned char *dest = NULL;\n        unsigned int *dest_len = NULL;\n\n        if (SSL3_RECORD_get_type(rr) == SSL3_RT_HANDSHAKE) {\n            dest_maxlen = sizeof s->rlayer.handshake_fragment;\n            dest = s->rlayer.handshake_fragment;\n            dest_len = &s->rlayer.handshake_fragment_len;\n        } else if (SSL3_RECORD_get_type(rr) == SSL3_RT_ALERT) {\n            dest_maxlen = sizeof s->rlayer.alert_fragment;\n            dest = s->rlayer.alert_fragment;\n            dest_len = &s->rlayer.alert_fragment_len;\n        }\n\n        if (dest_maxlen > 0) {\n            n = dest_maxlen - *dest_len; /* available space in 'dest' */\n            if (SSL3_RECORD_get_length(rr) < n)\n                n = SSL3_RECORD_get_length(rr); /* available bytes */\n\n            /* now move 'n' bytes: */\n            while (n-- > 0) {\n                dest[(*dest_len)++] =\n                    SSL3_RECORD_get_data(rr)[SSL3_RECORD_get_off(rr)];\n                SSL3_RECORD_add_off(rr, 1);\n                SSL3_RECORD_add_length(rr, -1);\n            }\n\n            if (*dest_len < dest_maxlen) {\n                SSL3_RECORD_set_read(rr);\n                goto start;     /* fragment was too small */\n            }\n        }\n    }\n\n    /*-\n     * s->rlayer.handshake_fragment_len == 4  iff  rr->type == SSL3_RT_HANDSHAKE;\n     * s->rlayer.alert_fragment_len == 2      iff  rr->type == SSL3_RT_ALERT.\n     * (Possibly rr is 'empty' now, i.e. rr->length may be 0.)\n     */\n\n    /* If we are a client, check for an incoming 'Hello Request': */\n    if ((!s->server) &&\n        (s->rlayer.handshake_fragment_len >= 4) &&\n        (s->rlayer.handshake_fragment[0] == SSL3_MT_HELLO_REQUEST) &&\n        (s->session != NULL) && (s->session->cipher != NULL)) {\n        s->rlayer.handshake_fragment_len = 0;\n\n        if ((s->rlayer.handshake_fragment[1] != 0) ||\n            (s->rlayer.handshake_fragment[2] != 0) ||\n            (s->rlayer.handshake_fragment[3] != 0)) {\n            al = SSL_AD_DECODE_ERROR;\n            SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_BAD_HELLO_REQUEST);\n            goto f_err;\n        }\n\n        if (s->msg_callback)\n            s->msg_callback(0, s->version, SSL3_RT_HANDSHAKE,\n                            s->rlayer.handshake_fragment, 4, s,\n                            s->msg_callback_arg);\n\n        if (SSL_is_init_finished(s) &&\n            !(s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS) &&\n            !s->s3->renegotiate) {\n            ssl3_renegotiate(s);\n            if (ssl3_renegotiate_check(s)) {\n                i = s->handshake_func(s);\n                if (i < 0)\n                    return (i);\n                if (i == 0) {\n                    SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_SSL_HANDSHAKE_FAILURE);\n                    return (-1);\n                }\n\n                if (!(s->mode & SSL_MODE_AUTO_RETRY)) {\n                    if (SSL3_BUFFER_get_left(rbuf) == 0) {\n                        /* no read-ahead left? */\n                        BIO *bio;\n                        /*\n                         * In the case where we try to read application data,\n                         * but we trigger an SSL handshake, we return -1 with\n                         * the retry option set.  Otherwise renegotiation may\n                         * cause nasty problems in the blocking world\n                         */\n                        s->rwstate = SSL_READING;\n                        bio = SSL_get_rbio(s);\n                        BIO_clear_retry_flags(bio);\n                        BIO_set_retry_read(bio);\n                        return (-1);\n                    }\n                }\n            }\n        }\n        /*\n         * we either finished a handshake or ignored the request, now try\n         * again to obtain the (application) data we were asked for\n         */\n        goto start;\n    }\n    /*\n     * If we are a server and get a client hello when renegotiation isn't\n     * allowed send back a no renegotiation alert and carry on. WARNING:\n     * experimental code, needs reviewing (steve)\n     */\n    if (s->server &&\n        SSL_is_init_finished(s) &&\n        !s->s3->send_connection_binding &&\n        (s->version > SSL3_VERSION) &&\n        (s->rlayer.handshake_fragment_len >= 4) &&\n        (s->rlayer.handshake_fragment[0] == SSL3_MT_CLIENT_HELLO) &&\n        (s->session != NULL) && (s->session->cipher != NULL) &&\n        !(s->ctx->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION)) {\n        SSL3_RECORD_set_length(rr, 0);\n        SSL3_RECORD_set_read(rr);\n        ssl3_send_alert(s, SSL3_AL_WARNING, SSL_AD_NO_RENEGOTIATION);\n        goto start;\n    }\n    if (s->rlayer.alert_fragment_len >= 2) {\n        int alert_level = s->rlayer.alert_fragment[0];\n        int alert_descr = s->rlayer.alert_fragment[1];\n\n        s->rlayer.alert_fragment_len = 0;\n\n        if (s->msg_callback)\n            s->msg_callback(0, s->version, SSL3_RT_ALERT,\n                            s->rlayer.alert_fragment, 2, s,\n                            s->msg_callback_arg);\n\n        if (s->info_callback != NULL)\n            cb = s->info_callback;\n        else if (s->ctx->info_callback != NULL)\n            cb = s->ctx->info_callback;\n\n        if (cb != NULL) {\n            j = (alert_level << 8) | alert_descr;\n            cb(s, SSL_CB_READ_ALERT, j);\n        }\n\n        if (alert_level == SSL3_AL_WARNING) {\n            s->s3->warn_alert = alert_descr;\n            SSL3_RECORD_set_read(rr);\n\n            s->rlayer.alert_count++;\n            if (s->rlayer.alert_count == MAX_WARN_ALERT_COUNT) {\n                al = SSL_AD_UNEXPECTED_MESSAGE;\n                SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_TOO_MANY_WARN_ALERTS);\n                goto f_err;\n            }\n\n            if (alert_descr == SSL_AD_CLOSE_NOTIFY) {\n                s->shutdown |= SSL_RECEIVED_SHUTDOWN;\n                return (0);\n            }\n            /*\n             * This is a warning but we receive it if we requested\n             * renegotiation and the peer denied it. Terminate with a fatal\n             * alert because if application tried to renegotiate it\n             * presumably had a good reason and expects it to succeed. In\n             * future we might have a renegotiation where we don't care if\n             * the peer refused it where we carry on.\n             */\n            else if (alert_descr == SSL_AD_NO_RENEGOTIATION) {\n                al = SSL_AD_HANDSHAKE_FAILURE;\n                SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_NO_RENEGOTIATION);\n                goto f_err;\n            }\n#ifdef SSL_AD_MISSING_SRP_USERNAME\n            else if (alert_descr == SSL_AD_MISSING_SRP_USERNAME)\n                return (0);\n#endif\n        } else if (alert_level == SSL3_AL_FATAL) {\n            char tmp[16];\n\n            s->rwstate = SSL_NOTHING;\n            s->s3->fatal_alert = alert_descr;\n            SSLerr(SSL_F_SSL3_READ_BYTES, SSL_AD_REASON_OFFSET + alert_descr);\n            BIO_snprintf(tmp, sizeof tmp, \"%d\", alert_descr);\n            ERR_add_error_data(2, \"SSL alert number \", tmp);\n            s->shutdown |= SSL_RECEIVED_SHUTDOWN;\n            SSL3_RECORD_set_read(rr);\n            SSL_CTX_remove_session(s->session_ctx, s->session);\n            return (0);\n        } else {\n            al = SSL_AD_ILLEGAL_PARAMETER;\n            SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_UNKNOWN_ALERT_TYPE);\n            goto f_err;\n        }\n\n        goto start;\n    }\n\n    if (s->shutdown & SSL_SENT_SHUTDOWN) { /* but we have not received a\n                                            * shutdown */\n        s->rwstate = SSL_NOTHING;\n        SSL3_RECORD_set_length(rr, 0);\n        SSL3_RECORD_set_read(rr);\n        return (0);\n    }\n\n    if (SSL3_RECORD_get_type(rr) == SSL3_RT_CHANGE_CIPHER_SPEC) {\n        al = SSL_AD_UNEXPECTED_MESSAGE;\n        SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_CCS_RECEIVED_EARLY);\n        goto f_err;\n    }\n\n    /*\n     * Unexpected handshake message (Client Hello, or protocol violation)\n     */\n    if ((s->rlayer.handshake_fragment_len >= 4)\n        && !ossl_statem_get_in_handshake(s)) {\n        if (SSL_is_init_finished(s) &&\n            !(s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS)) {\n            ossl_statem_set_in_init(s, 1);\n            s->renegotiate = 1;\n            s->new_session = 1;\n        }\n        i = s->handshake_func(s);\n        if (i < 0)\n            return (i);\n        if (i == 0) {\n            SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_SSL_HANDSHAKE_FAILURE);\n            return (-1);\n        }\n\n        if (!(s->mode & SSL_MODE_AUTO_RETRY)) {\n            if (SSL3_BUFFER_get_left(rbuf) == 0) {\n                /* no read-ahead left? */\n                BIO *bio;\n                /*\n                 * In the case where we try to read application data, but we\n                 * trigger an SSL handshake, we return -1 with the retry\n                 * option set.  Otherwise renegotiation may cause nasty\n                 * problems in the blocking world\n                 */\n                s->rwstate = SSL_READING;\n                bio = SSL_get_rbio(s);\n                BIO_clear_retry_flags(bio);\n                BIO_set_retry_read(bio);\n                return (-1);\n            }\n        }\n        goto start;\n    }\n\n    switch (SSL3_RECORD_get_type(rr)) {\n    default:\n        /*\n         * TLS up to v1.1 just ignores unknown message types: TLS v1.2 give\n         * an unexpected message alert.\n         */\n        if (s->version >= TLS1_VERSION && s->version <= TLS1_1_VERSION) {\n            SSL3_RECORD_set_length(rr, 0);\n            SSL3_RECORD_set_read(rr);\n            goto start;\n        }\n        al = SSL_AD_UNEXPECTED_MESSAGE;\n        SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_UNEXPECTED_RECORD);\n        goto f_err;\n    case SSL3_RT_CHANGE_CIPHER_SPEC:\n    case SSL3_RT_ALERT:\n    case SSL3_RT_HANDSHAKE:\n        /*\n         * we already handled all of these, with the possible exception of\n         * SSL3_RT_HANDSHAKE when ossl_statem_get_in_handshake(s) is true, but\n         * that should not happen when type != rr->type\n         */\n        al = SSL_AD_UNEXPECTED_MESSAGE;\n        SSLerr(SSL_F_SSL3_READ_BYTES, ERR_R_INTERNAL_ERROR);\n        goto f_err;\n    case SSL3_RT_APPLICATION_DATA:\n        /*\n         * At this point, we were expecting handshake data, but have\n         * application data.  If the library was running inside ssl3_read()\n         * (i.e. in_read_app_data is set) and it makes sense to read\n         * application data at this point (session renegotiation not yet\n         * started), we will indulge it.\n         */\n        if (ossl_statem_app_data_allowed(s)) {\n            s->s3->in_read_app_data = 2;\n            return (-1);\n        } else {\n            al = SSL_AD_UNEXPECTED_MESSAGE;\n            SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_UNEXPECTED_RECORD);\n            goto f_err;\n        }\n    }\n    /* not reached */\n\n f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n    return (-1);\n}",
  "abstract_func_before": "int ssl3_read_bytes(SSL *VAR_0, int VAR_1, int *VAR_2, unsigned char *VAR_3,\n                    int VAR_4, int VAR_5)\n{\n    int VAR_6, VAR_7, VAR_8, VAR_9;\n    unsigned int VAR_10, VAR_11, VAR_12, VAR_13;\n    SSL3_RECORD *VAR_14;\n    SSL3_BUFFER *VAR_15;\n    void (*VAR_16) (const SSL *VAR_17, int VAR_18, int VAR_19) = NULL;\n\n    VAR_15 = &VAR_0->rlayer.rbuf;\n\n    if (!SSL3_BUFFER_is_initialised(VAR_15)) {\n        /* COMMENT_0 */\n        if (!ssl3_setup_read_buffer(VAR_0))\n            return (-1);\n    }\n\n    if ((VAR_1 && (VAR_1 != VAR_20)\n         && (VAR_1 != VAR_21)) || (VAR_5\n                                             && (VAR_1 !=\n                                                 VAR_20))) {\n        SSLerr(VAR_22, VAR_23);\n        return -1;\n    }\n\n    if ((VAR_1 == VAR_21) && (VAR_0->rlayer.handshake_fragment_len > 0))\n        /* COMMENT_1 */\n    {\n        unsigned char *VAR_24 = VAR_0->rlayer.handshake_fragment;\n        unsigned char *VAR_25 = VAR_3;\n        unsigned int VAR_26;\n\n        /* COMMENT_2 */\n        VAR_10 = 0;\n        while ((VAR_4 > 0) && (VAR_0->rlayer.handshake_fragment_len > 0)) {\n            *VAR_25++ = *VAR_24++;\n            VAR_4--;\n            VAR_0->rlayer.handshake_fragment_len--;\n            VAR_10++;\n        }\n        /* COMMENT_3 */\n        for (VAR_26 = 0; VAR_26 < VAR_0->rlayer.handshake_fragment_len; VAR_26++)\n            VAR_0->rlayer.handshake_fragment[VAR_26] = *VAR_24++;\n\n        if (VAR_2 != NULL)\n            *VAR_2 = VAR_21;\n\n        return VAR_10;\n    }\n\n    /* COMMENT_4 */\n                                                                              \n       \n\n    if (!ossl_statem_get_in_handshake(VAR_0) && SSL_in_init(VAR_0)) {\n        /* COMMENT_7 */\n        VAR_7 = VAR_0->handshake_func(VAR_0);\n        if (VAR_7 < 0)\n            return (VAR_7);\n        if (VAR_7 == 0) {\n            SSLerr(VAR_22, VAR_27);\n            return (-1);\n        }\n    }\n start:\n    VAR_0->rwstate = VAR_28;\n\n    /* COMMENT_8 */\n                                           \n                                             \n                            \n                                                        \n                                        \n       \n    VAR_14 = VAR_0->rlayer.rrec;\n    VAR_12 = RECORD_LAYER_get_numrpipes(&VAR_0->rlayer);\n\n    do {\n        /* COMMENT_15 */\n        if (VAR_12 == 0) {\n            VAR_9 = ssl3_get_record(VAR_0);\n            if (VAR_9 <= 0)\n                return (VAR_9);\n            VAR_12 = RECORD_LAYER_get_numrpipes(&VAR_0->rlayer);\n            if (VAR_12 == 0) {\n                /* COMMENT_16 */\n                VAR_6 = VAR_29;\n                SSLerr(VAR_22, VAR_23);\n                goto f_err;\n            }\n        }\n        /* COMMENT_17 */\n        for (VAR_11 = 0;\n             VAR_11 < VAR_12 && SSL3_RECORD_is_read(&VAR_14[VAR_11]);\n             VAR_11++) ;\n        if (VAR_11 == VAR_12) {\n            RECORD_LAYER_set_numrpipes(&VAR_0->rlayer, 0);\n            VAR_12 = 0;\n            VAR_11 = 0;\n        }\n    } while (VAR_12 == 0);\n    VAR_14 = &VAR_14[VAR_11];\n\n    /* COMMENT_18 */\n                                                                             \n                                  \n       \n    if (SSL3_RECORD_get_type(VAR_14) != VAR_30\n            && SSL3_RECORD_get_length(VAR_14) != 0)\n        VAR_0->rlayer.alert_count = 0;\n\n    /* COMMENT_22 */\n\n    if (VAR_0->s3->change_cipher_spec /* COMMENT_23 */\n                                                                  \n        && (SSL3_RECORD_get_type(VAR_14) != VAR_21)) {\n        VAR_6 = VAR_31;\n        SSLerr(VAR_22, VAR_32);\n        goto f_err;\n    }\n\n    /* COMMENT_25 */\n                                                                           \n                   \n       \n    if (VAR_0->shutdown & VAR_33) {\n        SSL3_RECORD_set_length(VAR_14, 0);\n        VAR_0->rwstate = VAR_28;\n        return (0);\n    }\n\n    if (VAR_1 == SSL3_RECORD_get_type(VAR_14)\n        || (SSL3_RECORD_get_type(VAR_14) == VAR_34\n            && VAR_1 == VAR_21 && VAR_2 != NULL)) {\n        /* COMMENT_29 */\n                                      \n                               \n                                     \n           \n        /* COMMENT_34 */\n                                                                         \n                                               \n           \n        if (SSL_in_init(VAR_0) && (VAR_1 == VAR_20) &&\n            (VAR_0->enc_read_ctx == NULL)) {\n            VAR_6 = VAR_31;\n            SSLerr(VAR_22, VAR_35);\n            goto f_err;\n        }\n\n        if (VAR_1 == VAR_21\n            && SSL3_RECORD_get_type(VAR_14) == VAR_34\n            && VAR_0->rlayer.handshake_fragment_len > 0) {\n            VAR_6 = VAR_31;\n            SSLerr(VAR_22, VAR_36);\n            goto f_err;\n        }\n\n        if (VAR_2 != NULL)\n            *VAR_2 = SSL3_RECORD_get_type(VAR_14);\n\n        if (VAR_4 <= 0)\n            return (VAR_4);\n\n        VAR_13 = 0;\n        do {\n            if ((unsigned int)VAR_4 - VAR_13 > SSL3_RECORD_get_length(VAR_14))\n                VAR_10 = SSL3_RECORD_get_length(VAR_14);\n            else\n                VAR_10 = (unsigned int)VAR_4 - VAR_13;\n\n            memcpy(VAR_3, &(VAR_14->data[VAR_14->off]), VAR_10);\n            VAR_3 += VAR_10;\n            if (!VAR_5) {\n                SSL3_RECORD_sub_length(VAR_14, VAR_10);\n                SSL3_RECORD_add_off(VAR_14, VAR_10);\n                if (SSL3_RECORD_get_length(VAR_14) == 0) {\n                    VAR_0->rlayer.rstate = VAR_37;\n                    SSL3_RECORD_set_off(VAR_14, 0);\n                    SSL3_RECORD_set_read(VAR_14);\n                }\n            }\n            if (SSL3_RECORD_get_length(VAR_14) == 0\n                || (VAR_5 && VAR_10 == SSL3_RECORD_get_length(VAR_14))) {\n                VAR_11++;\n                VAR_14++;\n            }\n            VAR_13 += VAR_10;\n        } while (VAR_1 == VAR_20 && VAR_11 < VAR_12\n                 && VAR_13 < (unsigned int)VAR_4);\n        if (VAR_13 == 0) {\n            /* COMMENT_38 */\n            goto start;\n        }\n        if (!VAR_5 && VAR_11 == VAR_12\n            && (VAR_0->mode & VAR_38)\n            && SSL3_BUFFER_get_left(VAR_15) == 0)\n            ssl3_release_read_buffer(VAR_0);\n        return VAR_13;\n    }\n\n    /* COMMENT_39 */\n                                                                             \n                                                                            \n                                      \n       \n\n    /* COMMENT_44 */\n                                                                \n       \n    if (VAR_14->rec_version == VAR_39) {\n        /* COMMENT_47 */\n                                                                              \n                                                                            \n                                                                          \n                                                                    \n           \n        VAR_6 = VAR_29;\n        SSLerr(VAR_22, VAR_23);\n        goto f_err;\n    }\n\n    if (VAR_0->method->version == VAR_40\n        && (VAR_0->server || VAR_14->type != VAR_30)) {\n        /* COMMENT_53 */\n                                                                          \n                                                                               \n                                                                              \n                                                       \n           \n        VAR_0->version = VAR_14->rec_version;\n        VAR_6 = VAR_31;\n        SSLerr(VAR_22, VAR_41);\n        goto f_err;\n    }\n\n    /* COMMENT_59 */\n                                                                         \n                                                             \n       \n    {\n        unsigned int VAR_42 = 0;\n        unsigned char *VAR_43 = NULL;\n        unsigned int *VAR_44 = NULL;\n\n        if (SSL3_RECORD_get_type(VAR_14) == VAR_21) {\n            VAR_42 = sizeof VAR_0->rlayer.handshake_fragment;\n            VAR_43 = VAR_0->rlayer.handshake_fragment;\n            VAR_44 = &VAR_0->rlayer.handshake_fragment_len;\n        } else if (SSL3_RECORD_get_type(VAR_14) == VAR_30) {\n            VAR_42 = sizeof VAR_0->rlayer.alert_fragment;\n            VAR_43 = VAR_0->rlayer.alert_fragment;\n            VAR_44 = &VAR_0->rlayer.alert_fragment_len;\n        }\n\n        if (VAR_42 > 0) {\n            VAR_10 = VAR_42 - *VAR_44; /* COMMENT_63 */\n            if (SSL3_RECORD_get_length(VAR_14) < VAR_10)\n                VAR_10 = SSL3_RECORD_get_length(VAR_14); /* COMMENT_64 */\n\n            /* COMMENT_65 */\n            while (VAR_10-- > 0) {\n                VAR_43[(*VAR_44)++] =\n                    SSL3_RECORD_get_data(VAR_14)[SSL3_RECORD_get_off(VAR_14)];\n                SSL3_RECORD_add_off(VAR_14, 1);\n                SSL3_RECORD_add_length(VAR_14, -1);\n            }\n\n            if (*VAR_44 < VAR_42) {\n                SSL3_RECORD_set_read(VAR_14);\n                goto start;     /* COMMENT_66 */\n            }\n        }\n    }\n\n    /* COMMENT_67 */\n                                                                                 \n                                                                             \n                                                              \n       \n\n    /* COMMENT_72 */\n    if ((!VAR_0->server) &&\n        (VAR_0->rlayer.handshake_fragment_len >= 4) &&\n        (VAR_0->rlayer.handshake_fragment[0] == VAR_45) &&\n        (VAR_0->session != NULL) && (VAR_0->session->cipher != NULL)) {\n        VAR_0->rlayer.handshake_fragment_len = 0;\n\n        if ((VAR_0->rlayer.handshake_fragment[1] != 0) ||\n            (VAR_0->rlayer.handshake_fragment[2] != 0) ||\n            (VAR_0->rlayer.handshake_fragment[3] != 0)) {\n            VAR_6 = VAR_46;\n            SSLerr(VAR_22, VAR_47);\n            goto f_err;\n        }\n\n        if (VAR_0->msg_callback)\n            VAR_0->msg_callback(0, VAR_0->version, VAR_21,\n                            VAR_0->rlayer.handshake_fragment, 4, VAR_0,\n                            VAR_0->msg_callback_arg);\n\n        if (SSL_is_init_finished(VAR_0) &&\n            !(VAR_0->s3->flags & VAR_48) &&\n            !VAR_0->s3->renegotiate) {\n            ssl3_renegotiate(VAR_0);\n            if (ssl3_renegotiate_check(VAR_0)) {\n                VAR_7 = VAR_0->handshake_func(VAR_0);\n                if (VAR_7 < 0)\n                    return (VAR_7);\n                if (VAR_7 == 0) {\n                    SSLerr(VAR_22, VAR_27);\n                    return (-1);\n                }\n\n                if (!(VAR_0->mode & VAR_49)) {\n                    if (SSL3_BUFFER_get_left(VAR_15) == 0) {\n                        /* COMMENT_73 */\n                        BIO *VAR_50;\n                        /* COMMENT_74 */\n                                                                             \n                                                                             \n                                                                             \n                                                                     \n                           \n                        VAR_0->rwstate = VAR_51;\n                        VAR_50 = SSL_get_rbio(VAR_0);\n                        BIO_clear_retry_flags(VAR_50);\n                        BIO_set_retry_read(VAR_50);\n                        return (-1);\n                    }\n                }\n            }\n        }\n        /* COMMENT_80 */\n                                                                         \n                                                                   \n           \n        goto start;\n    }\n    /* COMMENT_84 */\n                                                                         \n                                                                        \n                                                 \n       \n    if (VAR_0->server &&\n        SSL_is_init_finished(VAR_0) &&\n        !VAR_0->s3->send_connection_binding &&\n        (VAR_0->version > VAR_52) &&\n        (VAR_0->rlayer.handshake_fragment_len >= 4) &&\n        (VAR_0->rlayer.handshake_fragment[0] == VAR_53) &&\n        (VAR_0->session != NULL) && (VAR_0->session->cipher != NULL) &&\n        !(VAR_0->ctx->options & VAR_54)) {\n        SSL3_RECORD_set_length(VAR_14, 0);\n        SSL3_RECORD_set_read(VAR_14);\n        ssl3_send_alert(VAR_0, VAR_55, VAR_56);\n        goto start;\n    }\n    if (VAR_0->rlayer.alert_fragment_len >= 2) {\n        int VAR_57 = VAR_0->rlayer.alert_fragment[0];\n        int VAR_58 = VAR_0->rlayer.alert_fragment[1];\n\n        VAR_0->rlayer.alert_fragment_len = 0;\n\n        if (VAR_0->msg_callback)\n            VAR_0->msg_callback(0, VAR_0->version, VAR_30,\n                            VAR_0->rlayer.alert_fragment, 2, VAR_0,\n                            VAR_0->msg_callback_arg);\n\n        if (VAR_0->info_callback != NULL)\n            VAR_16 = VAR_0->info_callback;\n        else if (VAR_0->ctx->info_callback != NULL)\n            VAR_16 = VAR_0->ctx->info_callback;\n\n        if (VAR_16 != NULL) {\n            VAR_8 = (VAR_57 << 8) | VAR_58;\n            VAR_16(VAR_0, VAR_59, VAR_8);\n        }\n\n        if (VAR_57 == VAR_55) {\n            VAR_0->s3->warn_alert = VAR_58;\n            SSL3_RECORD_set_read(VAR_14);\n\n            VAR_0->rlayer.alert_count++;\n            if (VAR_0->rlayer.alert_count == VAR_60) {\n                VAR_6 = VAR_31;\n                SSLerr(VAR_22, VAR_61);\n                goto f_err;\n            }\n\n            if (VAR_58 == VAR_62) {\n                VAR_0->shutdown |= VAR_33;\n                return (0);\n            }\n            /* COMMENT_89 */\n                                                                  \n                                                                           \n                                                                   \n                                                                         \n                                                                          \n                                                     \n               \n            else if (VAR_58 == VAR_56) {\n                VAR_6 = VAR_63;\n                SSLerr(VAR_22, VAR_64);\n                goto f_err;\n            }\n#ifdef VAR_65\n            else if (alert_descr == VAR_65)\n                return (0);\n#endif\n        } else if (VAR_57 == VAR_66) {\n            char VAR_67[16];\n\n            VAR_0->rwstate = VAR_28;\n            VAR_0->s3->fatal_alert = alert_descr;\n            SSLerr(VAR_22, VAR_68 + alert_descr);\n            BIO_snprintf(VAR_67, sizeof VAR_67, \"%d\", alert_descr);\n            ERR_add_error_data(2, \"SSL alert number \", VAR_67);\n            VAR_0->shutdown |= VAR_33;\n            SSL3_RECORD_set_read(VAR_14);\n            SSL_CTX_remove_session(VAR_0->session_ctx, VAR_0->session);\n            return (0);\n        } else {\n            VAR_6 = VAR_69;\n            SSLerr(VAR_22, VAR_70);\n            goto f_err;\n        }\n\n        goto start;\n    }\n\n    if (VAR_0->shutdown & VAR_71) { /* COMMENT_97 */\n                                                         \n        VAR_0->rwstate = VAR_28;\n        SSL3_RECORD_set_length(VAR_14, 0);\n        SSL3_RECORD_set_read(VAR_14);\n        return (0);\n    }\n\n    if (SSL3_RECORD_get_type(VAR_14) == VAR_34) {\n        VAR_6 = VAR_31;\n        SSLerr(VAR_22, VAR_36);\n        goto f_err;\n    }\n\n    /* COMMENT_99 */\n                                                                         \n       \n    if ((VAR_0->rlayer.handshake_fragment_len >= 4)\n        && !ossl_statem_get_in_handshake(VAR_0)) {\n        if (SSL_is_init_finished(VAR_0) &&\n            !(VAR_0->s3->flags & VAR_48)) {\n            ossl_statem_set_in_init(VAR_0, 1);\n            VAR_0->renegotiate = 1;\n            VAR_0->new_session = 1;\n        }\n        VAR_7 = VAR_0->handshake_func(VAR_0);\n        if (VAR_7 < 0)\n            return (VAR_7);\n        if (VAR_7 == 0) {\n            SSLerr(VAR_22, VAR_27);\n            return (-1);\n        }\n\n        if (!(VAR_0->mode & VAR_49)) {\n            if (SSL3_BUFFER_get_left(VAR_15) == 0) {\n                /* COMMENT_73 */\n                BIO *VAR_50;\n                /* COMMENT_102 */\n                                                                            \n                                                                        \n                                                                       \n                                                 \n                   \n                VAR_0->rwstate = VAR_51;\n                VAR_50 = SSL_get_rbio(VAR_0);\n                BIO_clear_retry_flags(VAR_50);\n                BIO_set_retry_read(VAR_50);\n                return (-1);\n            }\n        }\n        goto start;\n    }\n\n    switch (SSL3_RECORD_get_type(VAR_14)) {\n    default:\n        /* COMMENT_108 */\n                                                                           \n                                       \n           \n        if (VAR_0->version >= VAR_72 && VAR_0->version <= VAR_73) {\n            SSL3_RECORD_set_length(VAR_14, 0);\n            SSL3_RECORD_set_read(VAR_14);\n            goto start;\n        }\n        VAR_6 = VAR_31;\n        SSLerr(VAR_22, VAR_74);\n        goto f_err;\n    case VAR_34:\n    case VAR_30:\n    case VAR_21:\n        /* COMMENT_112 */\n                                                                          \n                                                                              \n                                                       \n           \n        VAR_6 = VAR_31;\n        SSLerr(VAR_22, VAR_23);\n        goto f_err;\n    case VAR_20:\n        /* COMMENT_117 */\n                                                                    \n                                                                           \n                                                                    \n                                                                        \n                                        \n           \n        if (ossl_statem_app_data_allowed(VAR_0)) {\n            VAR_0->s3->in_read_app_data = 2;\n            return (-1);\n        } else {\n            VAR_6 = VAR_31;\n            SSLerr(VAR_22, VAR_74);\n            goto f_err;\n        }\n    }\n    /* COMMENT_124 */\n\n f_err:\n    ssl3_send_alert(VAR_0, VAR_66, VAR_6);\n    return (-1);\n}",
  "func_graph_path_before": "openssl/63658103d4441924f8dbfc517b99bb54758a98b9/rec_layer_s3.c/vul/before/0.json",
  "func": "int ssl3_read_bytes(SSL *s, int type, int *recvd_type, unsigned char *buf,\n                    int len, int peek)\n{\n    int al, i, j, ret;\n    unsigned int n, curr_rec, num_recs, read_bytes;\n    SSL3_RECORD *rr;\n    SSL3_BUFFER *rbuf;\n    void (*cb) (const SSL *ssl, int type2, int val) = NULL;\n\n    rbuf = &s->rlayer.rbuf;\n\n    if (!SSL3_BUFFER_is_initialised(rbuf)) {\n        /* Not initialized yet */\n        if (!ssl3_setup_read_buffer(s))\n            return (-1);\n    }\n\n    if ((type && (type != SSL3_RT_APPLICATION_DATA)\n         && (type != SSL3_RT_HANDSHAKE)) || (peek\n                                             && (type !=\n                                                 SSL3_RT_APPLICATION_DATA))) {\n        SSLerr(SSL_F_SSL3_READ_BYTES, ERR_R_INTERNAL_ERROR);\n        return -1;\n    }\n\n    if ((type == SSL3_RT_HANDSHAKE) && (s->rlayer.handshake_fragment_len > 0))\n        /* (partially) satisfy request from storage */\n    {\n        unsigned char *src = s->rlayer.handshake_fragment;\n        unsigned char *dst = buf;\n        unsigned int k;\n\n        /* peek == 0 */\n        n = 0;\n        while ((len > 0) && (s->rlayer.handshake_fragment_len > 0)) {\n            *dst++ = *src++;\n            len--;\n            s->rlayer.handshake_fragment_len--;\n            n++;\n        }\n        /* move any remaining fragment bytes: */\n        for (k = 0; k < s->rlayer.handshake_fragment_len; k++)\n            s->rlayer.handshake_fragment[k] = *src++;\n\n        if (recvd_type != NULL)\n            *recvd_type = SSL3_RT_HANDSHAKE;\n\n        return n;\n    }\n\n    /*\n     * Now s->rlayer.handshake_fragment_len == 0 if type == SSL3_RT_HANDSHAKE.\n     */\n\n    if (!ossl_statem_get_in_handshake(s) && SSL_in_init(s)) {\n        /* type == SSL3_RT_APPLICATION_DATA */\n        i = s->handshake_func(s);\n        if (i < 0)\n            return (i);\n        if (i == 0) {\n            SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_SSL_HANDSHAKE_FAILURE);\n            return (-1);\n        }\n    }\n start:\n    s->rwstate = SSL_NOTHING;\n\n    /*-\n     * For each record 'i' up to |num_recs]\n     * rr[i].type     - is the type of record\n     * rr[i].data,    - data\n     * rr[i].off,     - offset into 'data' for next read\n     * rr[i].length,  - number of bytes.\n     */\n    rr = s->rlayer.rrec;\n    num_recs = RECORD_LAYER_get_numrpipes(&s->rlayer);\n\n    do {\n        /* get new records if necessary */\n        if (num_recs == 0) {\n            ret = ssl3_get_record(s);\n            if (ret <= 0)\n                return (ret);\n            num_recs = RECORD_LAYER_get_numrpipes(&s->rlayer);\n            if (num_recs == 0) {\n                /* Shouldn't happen */\n                al = SSL_AD_INTERNAL_ERROR;\n                SSLerr(SSL_F_SSL3_READ_BYTES, ERR_R_INTERNAL_ERROR);\n                goto f_err;\n            }\n        }\n        /* Skip over any records we have already read */\n        for (curr_rec = 0;\n             curr_rec < num_recs && SSL3_RECORD_is_read(&rr[curr_rec]);\n             curr_rec++) ;\n        if (curr_rec == num_recs) {\n            RECORD_LAYER_set_numrpipes(&s->rlayer, 0);\n            num_recs = 0;\n            curr_rec = 0;\n        }\n    } while (num_recs == 0);\n    rr = &rr[curr_rec];\n\n    /*\n     * Reset the count of consecutive warning alerts if we've got a non-empty\n     * record that isn't an alert.\n     */\n    if (SSL3_RECORD_get_type(rr) != SSL3_RT_ALERT\n            && SSL3_RECORD_get_length(rr) != 0)\n        s->rlayer.alert_count = 0;\n\n    /* we now have a packet which can be read and processed */\n\n    if (s->s3->change_cipher_spec /* set when we receive ChangeCipherSpec,\n                                   * reset by ssl3_get_finished */\n        && (SSL3_RECORD_get_type(rr) != SSL3_RT_HANDSHAKE)) {\n        al = SSL_AD_UNEXPECTED_MESSAGE;\n        SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_DATA_BETWEEN_CCS_AND_FINISHED);\n        goto f_err;\n    }\n\n    /*\n     * If the other end has shut down, throw anything we read away (even in\n     * 'peek' mode)\n     */\n    if (s->shutdown & SSL_RECEIVED_SHUTDOWN) {\n        SSL3_RECORD_set_length(rr, 0);\n        s->rwstate = SSL_NOTHING;\n        return (0);\n    }\n\n    if (type == SSL3_RECORD_get_type(rr)\n        || (SSL3_RECORD_get_type(rr) == SSL3_RT_CHANGE_CIPHER_SPEC\n            && type == SSL3_RT_HANDSHAKE && recvd_type != NULL)) {\n        /*\n         * SSL3_RT_APPLICATION_DATA or\n         * SSL3_RT_HANDSHAKE or\n         * SSL3_RT_CHANGE_CIPHER_SPEC\n         */\n        /*\n         * make sure that we are not getting application data when we are\n         * doing a handshake for the first time\n         */\n        if (SSL_in_init(s) && (type == SSL3_RT_APPLICATION_DATA) &&\n            (s->enc_read_ctx == NULL)) {\n            al = SSL_AD_UNEXPECTED_MESSAGE;\n            SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_APP_DATA_IN_HANDSHAKE);\n            goto f_err;\n        }\n\n        if (type == SSL3_RT_HANDSHAKE\n            && SSL3_RECORD_get_type(rr) == SSL3_RT_CHANGE_CIPHER_SPEC\n            && s->rlayer.handshake_fragment_len > 0) {\n            al = SSL_AD_UNEXPECTED_MESSAGE;\n            SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_CCS_RECEIVED_EARLY);\n            goto f_err;\n        }\n\n        if (recvd_type != NULL)\n            *recvd_type = SSL3_RECORD_get_type(rr);\n\n        if (len <= 0)\n            return (len);\n\n        read_bytes = 0;\n        do {\n            if ((unsigned int)len - read_bytes > SSL3_RECORD_get_length(rr))\n                n = SSL3_RECORD_get_length(rr);\n            else\n                n = (unsigned int)len - read_bytes;\n\n            memcpy(buf, &(rr->data[rr->off]), n);\n            buf += n;\n            if (peek) {\n                /* Mark any zero length record as consumed CVE-2016-6305 */\n                if (SSL3_RECORD_get_length(rr) == 0)\n                    SSL3_RECORD_set_read(rr);\n            } else {\n                SSL3_RECORD_sub_length(rr, n);\n                SSL3_RECORD_add_off(rr, n);\n                if (SSL3_RECORD_get_length(rr) == 0) {\n                    s->rlayer.rstate = SSL_ST_READ_HEADER;\n                    SSL3_RECORD_set_off(rr, 0);\n                    SSL3_RECORD_set_read(rr);\n                }\n            }\n            if (SSL3_RECORD_get_length(rr) == 0\n                || (peek && n == SSL3_RECORD_get_length(rr))) {\n                curr_rec++;\n                rr++;\n            }\n            read_bytes += n;\n        } while (type == SSL3_RT_APPLICATION_DATA && curr_rec < num_recs\n                 && read_bytes < (unsigned int)len);\n        if (read_bytes == 0) {\n            /* We must have read empty records. Get more data */\n            goto start;\n        }\n        if (!peek && curr_rec == num_recs\n            && (s->mode & SSL_MODE_RELEASE_BUFFERS)\n            && SSL3_BUFFER_get_left(rbuf) == 0)\n            ssl3_release_read_buffer(s);\n        return read_bytes;\n    }\n\n    /*\n     * If we get here, then type != rr->type; if we have a handshake message,\n     * then it was unexpected (Hello Request or Client Hello) or invalid (we\n     * were actually expecting a CCS).\n     */\n\n    /*\n     * Lets just double check that we've not got an SSLv2 record\n     */\n    if (rr->rec_version == SSL2_VERSION) {\n        /*\n         * Should never happen. ssl3_get_record() should only give us an SSLv2\n         * record back if this is the first packet and we are looking for an\n         * initial ClientHello. Therefore |type| should always be equal to\n         * |rr->type|. If not then something has gone horribly wrong\n         */\n        al = SSL_AD_INTERNAL_ERROR;\n        SSLerr(SSL_F_SSL3_READ_BYTES, ERR_R_INTERNAL_ERROR);\n        goto f_err;\n    }\n\n    if (s->method->version == TLS_ANY_VERSION\n        && (s->server || rr->type != SSL3_RT_ALERT)) {\n        /*\n         * If we've got this far and still haven't decided on what version\n         * we're using then this must be a client side alert we're dealing with\n         * (we don't allow heartbeats yet). We shouldn't be receiving anything\n         * other than a ClientHello if we are a server.\n         */\n        s->version = rr->rec_version;\n        al = SSL_AD_UNEXPECTED_MESSAGE;\n        SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_UNEXPECTED_MESSAGE);\n        goto f_err;\n    }\n\n    /*\n     * In case of record types for which we have 'fragment' storage, fill\n     * that so that we can process the data at a fixed place.\n     */\n    {\n        unsigned int dest_maxlen = 0;\n        unsigned char *dest = NULL;\n        unsigned int *dest_len = NULL;\n\n        if (SSL3_RECORD_get_type(rr) == SSL3_RT_HANDSHAKE) {\n            dest_maxlen = sizeof s->rlayer.handshake_fragment;\n            dest = s->rlayer.handshake_fragment;\n            dest_len = &s->rlayer.handshake_fragment_len;\n        } else if (SSL3_RECORD_get_type(rr) == SSL3_RT_ALERT) {\n            dest_maxlen = sizeof s->rlayer.alert_fragment;\n            dest = s->rlayer.alert_fragment;\n            dest_len = &s->rlayer.alert_fragment_len;\n        }\n\n        if (dest_maxlen > 0) {\n            n = dest_maxlen - *dest_len; /* available space in 'dest' */\n            if (SSL3_RECORD_get_length(rr) < n)\n                n = SSL3_RECORD_get_length(rr); /* available bytes */\n\n            /* now move 'n' bytes: */\n            while (n-- > 0) {\n                dest[(*dest_len)++] =\n                    SSL3_RECORD_get_data(rr)[SSL3_RECORD_get_off(rr)];\n                SSL3_RECORD_add_off(rr, 1);\n                SSL3_RECORD_add_length(rr, -1);\n            }\n\n            if (*dest_len < dest_maxlen) {\n                SSL3_RECORD_set_read(rr);\n                goto start;     /* fragment was too small */\n            }\n        }\n    }\n\n    /*-\n     * s->rlayer.handshake_fragment_len == 4  iff  rr->type == SSL3_RT_HANDSHAKE;\n     * s->rlayer.alert_fragment_len == 2      iff  rr->type == SSL3_RT_ALERT.\n     * (Possibly rr is 'empty' now, i.e. rr->length may be 0.)\n     */\n\n    /* If we are a client, check for an incoming 'Hello Request': */\n    if ((!s->server) &&\n        (s->rlayer.handshake_fragment_len >= 4) &&\n        (s->rlayer.handshake_fragment[0] == SSL3_MT_HELLO_REQUEST) &&\n        (s->session != NULL) && (s->session->cipher != NULL)) {\n        s->rlayer.handshake_fragment_len = 0;\n\n        if ((s->rlayer.handshake_fragment[1] != 0) ||\n            (s->rlayer.handshake_fragment[2] != 0) ||\n            (s->rlayer.handshake_fragment[3] != 0)) {\n            al = SSL_AD_DECODE_ERROR;\n            SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_BAD_HELLO_REQUEST);\n            goto f_err;\n        }\n\n        if (s->msg_callback)\n            s->msg_callback(0, s->version, SSL3_RT_HANDSHAKE,\n                            s->rlayer.handshake_fragment, 4, s,\n                            s->msg_callback_arg);\n\n        if (SSL_is_init_finished(s) &&\n            !(s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS) &&\n            !s->s3->renegotiate) {\n            ssl3_renegotiate(s);\n            if (ssl3_renegotiate_check(s)) {\n                i = s->handshake_func(s);\n                if (i < 0)\n                    return (i);\n                if (i == 0) {\n                    SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_SSL_HANDSHAKE_FAILURE);\n                    return (-1);\n                }\n\n                if (!(s->mode & SSL_MODE_AUTO_RETRY)) {\n                    if (SSL3_BUFFER_get_left(rbuf) == 0) {\n                        /* no read-ahead left? */\n                        BIO *bio;\n                        /*\n                         * In the case where we try to read application data,\n                         * but we trigger an SSL handshake, we return -1 with\n                         * the retry option set.  Otherwise renegotiation may\n                         * cause nasty problems in the blocking world\n                         */\n                        s->rwstate = SSL_READING;\n                        bio = SSL_get_rbio(s);\n                        BIO_clear_retry_flags(bio);\n                        BIO_set_retry_read(bio);\n                        return (-1);\n                    }\n                }\n            }\n        }\n        /*\n         * we either finished a handshake or ignored the request, now try\n         * again to obtain the (application) data we were asked for\n         */\n        goto start;\n    }\n    /*\n     * If we are a server and get a client hello when renegotiation isn't\n     * allowed send back a no renegotiation alert and carry on. WARNING:\n     * experimental code, needs reviewing (steve)\n     */\n    if (s->server &&\n        SSL_is_init_finished(s) &&\n        !s->s3->send_connection_binding &&\n        (s->version > SSL3_VERSION) &&\n        (s->rlayer.handshake_fragment_len >= 4) &&\n        (s->rlayer.handshake_fragment[0] == SSL3_MT_CLIENT_HELLO) &&\n        (s->session != NULL) && (s->session->cipher != NULL) &&\n        !(s->ctx->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION)) {\n        SSL3_RECORD_set_length(rr, 0);\n        SSL3_RECORD_set_read(rr);\n        ssl3_send_alert(s, SSL3_AL_WARNING, SSL_AD_NO_RENEGOTIATION);\n        goto start;\n    }\n    if (s->rlayer.alert_fragment_len >= 2) {\n        int alert_level = s->rlayer.alert_fragment[0];\n        int alert_descr = s->rlayer.alert_fragment[1];\n\n        s->rlayer.alert_fragment_len = 0;\n\n        if (s->msg_callback)\n            s->msg_callback(0, s->version, SSL3_RT_ALERT,\n                            s->rlayer.alert_fragment, 2, s,\n                            s->msg_callback_arg);\n\n        if (s->info_callback != NULL)\n            cb = s->info_callback;\n        else if (s->ctx->info_callback != NULL)\n            cb = s->ctx->info_callback;\n\n        if (cb != NULL) {\n            j = (alert_level << 8) | alert_descr;\n            cb(s, SSL_CB_READ_ALERT, j);\n        }\n\n        if (alert_level == SSL3_AL_WARNING) {\n            s->s3->warn_alert = alert_descr;\n            SSL3_RECORD_set_read(rr);\n\n            s->rlayer.alert_count++;\n            if (s->rlayer.alert_count == MAX_WARN_ALERT_COUNT) {\n                al = SSL_AD_UNEXPECTED_MESSAGE;\n                SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_TOO_MANY_WARN_ALERTS);\n                goto f_err;\n            }\n\n            if (alert_descr == SSL_AD_CLOSE_NOTIFY) {\n                s->shutdown |= SSL_RECEIVED_SHUTDOWN;\n                return (0);\n            }\n            /*\n             * This is a warning but we receive it if we requested\n             * renegotiation and the peer denied it. Terminate with a fatal\n             * alert because if application tried to renegotiate it\n             * presumably had a good reason and expects it to succeed. In\n             * future we might have a renegotiation where we don't care if\n             * the peer refused it where we carry on.\n             */\n            else if (alert_descr == SSL_AD_NO_RENEGOTIATION) {\n                al = SSL_AD_HANDSHAKE_FAILURE;\n                SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_NO_RENEGOTIATION);\n                goto f_err;\n            }\n#ifdef SSL_AD_MISSING_SRP_USERNAME\n            else if (alert_descr == SSL_AD_MISSING_SRP_USERNAME)\n                return (0);\n#endif\n        } else if (alert_level == SSL3_AL_FATAL) {\n            char tmp[16];\n\n            s->rwstate = SSL_NOTHING;\n            s->s3->fatal_alert = alert_descr;\n            SSLerr(SSL_F_SSL3_READ_BYTES, SSL_AD_REASON_OFFSET + alert_descr);\n            BIO_snprintf(tmp, sizeof tmp, \"%d\", alert_descr);\n            ERR_add_error_data(2, \"SSL alert number \", tmp);\n            s->shutdown |= SSL_RECEIVED_SHUTDOWN;\n            SSL3_RECORD_set_read(rr);\n            SSL_CTX_remove_session(s->session_ctx, s->session);\n            return (0);\n        } else {\n            al = SSL_AD_ILLEGAL_PARAMETER;\n            SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_UNKNOWN_ALERT_TYPE);\n            goto f_err;\n        }\n\n        goto start;\n    }\n\n    if (s->shutdown & SSL_SENT_SHUTDOWN) { /* but we have not received a\n                                            * shutdown */\n        s->rwstate = SSL_NOTHING;\n        SSL3_RECORD_set_length(rr, 0);\n        SSL3_RECORD_set_read(rr);\n        return (0);\n    }\n\n    if (SSL3_RECORD_get_type(rr) == SSL3_RT_CHANGE_CIPHER_SPEC) {\n        al = SSL_AD_UNEXPECTED_MESSAGE;\n        SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_CCS_RECEIVED_EARLY);\n        goto f_err;\n    }\n\n    /*\n     * Unexpected handshake message (Client Hello, or protocol violation)\n     */\n    if ((s->rlayer.handshake_fragment_len >= 4)\n        && !ossl_statem_get_in_handshake(s)) {\n        if (SSL_is_init_finished(s) &&\n            !(s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS)) {\n            ossl_statem_set_in_init(s, 1);\n            s->renegotiate = 1;\n            s->new_session = 1;\n        }\n        i = s->handshake_func(s);\n        if (i < 0)\n            return (i);\n        if (i == 0) {\n            SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_SSL_HANDSHAKE_FAILURE);\n            return (-1);\n        }\n\n        if (!(s->mode & SSL_MODE_AUTO_RETRY)) {\n            if (SSL3_BUFFER_get_left(rbuf) == 0) {\n                /* no read-ahead left? */\n                BIO *bio;\n                /*\n                 * In the case where we try to read application data, but we\n                 * trigger an SSL handshake, we return -1 with the retry\n                 * option set.  Otherwise renegotiation may cause nasty\n                 * problems in the blocking world\n                 */\n                s->rwstate = SSL_READING;\n                bio = SSL_get_rbio(s);\n                BIO_clear_retry_flags(bio);\n                BIO_set_retry_read(bio);\n                return (-1);\n            }\n        }\n        goto start;\n    }\n\n    switch (SSL3_RECORD_get_type(rr)) {\n    default:\n        /*\n         * TLS up to v1.1 just ignores unknown message types: TLS v1.2 give\n         * an unexpected message alert.\n         */\n        if (s->version >= TLS1_VERSION && s->version <= TLS1_1_VERSION) {\n            SSL3_RECORD_set_length(rr, 0);\n            SSL3_RECORD_set_read(rr);\n            goto start;\n        }\n        al = SSL_AD_UNEXPECTED_MESSAGE;\n        SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_UNEXPECTED_RECORD);\n        goto f_err;\n    case SSL3_RT_CHANGE_CIPHER_SPEC:\n    case SSL3_RT_ALERT:\n    case SSL3_RT_HANDSHAKE:\n        /*\n         * we already handled all of these, with the possible exception of\n         * SSL3_RT_HANDSHAKE when ossl_statem_get_in_handshake(s) is true, but\n         * that should not happen when type != rr->type\n         */\n        al = SSL_AD_UNEXPECTED_MESSAGE;\n        SSLerr(SSL_F_SSL3_READ_BYTES, ERR_R_INTERNAL_ERROR);\n        goto f_err;\n    case SSL3_RT_APPLICATION_DATA:\n        /*\n         * At this point, we were expecting handshake data, but have\n         * application data.  If the library was running inside ssl3_read()\n         * (i.e. in_read_app_data is set) and it makes sense to read\n         * application data at this point (session renegotiation not yet\n         * started), we will indulge it.\n         */\n        if (ossl_statem_app_data_allowed(s)) {\n            s->s3->in_read_app_data = 2;\n            return (-1);\n        } else {\n            al = SSL_AD_UNEXPECTED_MESSAGE;\n            SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_UNEXPECTED_RECORD);\n            goto f_err;\n        }\n    }\n    /* not reached */\n\n f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n    return (-1);\n}",
  "abstract_func": "int ssl3_read_bytes(SSL *VAR_0, int VAR_1, int *VAR_2, unsigned char *VAR_3,\n                    int VAR_4, int VAR_5)\n{\n    int VAR_6, VAR_7, VAR_8, VAR_9;\n    unsigned int VAR_10, VAR_11, VAR_12, VAR_13;\n    SSL3_RECORD *VAR_14;\n    SSL3_BUFFER *VAR_15;\n    void (*VAR_16) (const SSL *VAR_17, int VAR_18, int VAR_19) = NULL;\n\n    VAR_15 = &VAR_0->rlayer.rbuf;\n\n    if (!SSL3_BUFFER_is_initialised(VAR_15)) {\n        /* COMMENT_0 */\n        if (!ssl3_setup_read_buffer(VAR_0))\n            return (-1);\n    }\n\n    if ((VAR_1 && (VAR_1 != VAR_20)\n         && (VAR_1 != VAR_21)) || (VAR_5\n                                             && (VAR_1 !=\n                                                 VAR_20))) {\n        SSLerr(VAR_22, VAR_23);\n        return -1;\n    }\n\n    if ((VAR_1 == VAR_21) && (VAR_0->rlayer.handshake_fragment_len > 0))\n        /* COMMENT_1 */\n    {\n        unsigned char *VAR_24 = VAR_0->rlayer.handshake_fragment;\n        unsigned char *VAR_25 = VAR_3;\n        unsigned int VAR_26;\n\n        /* COMMENT_2 */\n        VAR_10 = 0;\n        while ((VAR_4 > 0) && (VAR_0->rlayer.handshake_fragment_len > 0)) {\n            *VAR_25++ = *VAR_24++;\n            VAR_4--;\n            VAR_0->rlayer.handshake_fragment_len--;\n            VAR_10++;\n        }\n        /* COMMENT_3 */\n        for (VAR_26 = 0; VAR_26 < VAR_0->rlayer.handshake_fragment_len; VAR_26++)\n            VAR_0->rlayer.handshake_fragment[VAR_26] = *VAR_24++;\n\n        if (VAR_2 != NULL)\n            *VAR_2 = VAR_21;\n\n        return VAR_10;\n    }\n\n    /* COMMENT_4 */\n                                                                              \n       \n\n    if (!ossl_statem_get_in_handshake(VAR_0) && SSL_in_init(VAR_0)) {\n        /* COMMENT_7 */\n        VAR_7 = VAR_0->handshake_func(VAR_0);\n        if (VAR_7 < 0)\n            return (VAR_7);\n        if (VAR_7 == 0) {\n            SSLerr(VAR_22, VAR_27);\n            return (-1);\n        }\n    }\n start:\n    VAR_0->rwstate = VAR_28;\n\n    /* COMMENT_8 */\n                                           \n                                             \n                            \n                                                        \n                                        \n       \n    VAR_14 = VAR_0->rlayer.rrec;\n    VAR_12 = RECORD_LAYER_get_numrpipes(&VAR_0->rlayer);\n\n    do {\n        /* COMMENT_15 */\n        if (VAR_12 == 0) {\n            VAR_9 = ssl3_get_record(VAR_0);\n            if (VAR_9 <= 0)\n                return (VAR_9);\n            VAR_12 = RECORD_LAYER_get_numrpipes(&VAR_0->rlayer);\n            if (VAR_12 == 0) {\n                /* COMMENT_16 */\n                VAR_6 = VAR_29;\n                SSLerr(VAR_22, VAR_23);\n                goto f_err;\n            }\n        }\n        /* COMMENT_17 */\n        for (VAR_11 = 0;\n             VAR_11 < VAR_12 && SSL3_RECORD_is_read(&VAR_14[VAR_11]);\n             VAR_11++) ;\n        if (VAR_11 == VAR_12) {\n            RECORD_LAYER_set_numrpipes(&VAR_0->rlayer, 0);\n            VAR_12 = 0;\n            VAR_11 = 0;\n        }\n    } while (VAR_12 == 0);\n    VAR_14 = &VAR_14[VAR_11];\n\n    /* COMMENT_18 */\n                                                                             \n                                  \n       \n    if (SSL3_RECORD_get_type(VAR_14) != VAR_30\n            && SSL3_RECORD_get_length(VAR_14) != 0)\n        VAR_0->rlayer.alert_count = 0;\n\n    /* COMMENT_22 */\n\n    if (VAR_0->s3->change_cipher_spec /* COMMENT_23 */\n                                                                  \n        && (SSL3_RECORD_get_type(VAR_14) != VAR_21)) {\n        VAR_6 = VAR_31;\n        SSLerr(VAR_22, VAR_32);\n        goto f_err;\n    }\n\n    /* COMMENT_25 */\n                                                                           \n                   \n       \n    if (VAR_0->shutdown & VAR_33) {\n        SSL3_RECORD_set_length(VAR_14, 0);\n        VAR_0->rwstate = VAR_28;\n        return (0);\n    }\n\n    if (VAR_1 == SSL3_RECORD_get_type(VAR_14)\n        || (SSL3_RECORD_get_type(VAR_14) == VAR_34\n            && VAR_1 == VAR_21 && VAR_2 != NULL)) {\n        /* COMMENT_29 */\n                                      \n                               \n                                     \n           \n        /* COMMENT_34 */\n                                                                         \n                                               \n           \n        if (SSL_in_init(VAR_0) && (VAR_1 == VAR_20) &&\n            (VAR_0->enc_read_ctx == NULL)) {\n            VAR_6 = VAR_31;\n            SSLerr(VAR_22, VAR_35);\n            goto f_err;\n        }\n\n        if (VAR_1 == VAR_21\n            && SSL3_RECORD_get_type(VAR_14) == VAR_34\n            && VAR_0->rlayer.handshake_fragment_len > 0) {\n            VAR_6 = VAR_31;\n            SSLerr(VAR_22, VAR_36);\n            goto f_err;\n        }\n\n        if (VAR_2 != NULL)\n            *VAR_2 = SSL3_RECORD_get_type(VAR_14);\n\n        if (VAR_4 <= 0)\n            return (VAR_4);\n\n        VAR_13 = 0;\n        do {\n            if ((unsigned int)VAR_4 - VAR_13 > SSL3_RECORD_get_length(VAR_14))\n                VAR_10 = SSL3_RECORD_get_length(VAR_14);\n            else\n                VAR_10 = (unsigned int)VAR_4 - VAR_13;\n\n            memcpy(VAR_3, &(VAR_14->data[VAR_14->off]), VAR_10);\n            VAR_3 += VAR_10;\n            if (VAR_5) {\n                /* COMMENT_38 */\n                if (SSL3_RECORD_get_length(VAR_14) == 0)\n                    SSL3_RECORD_set_read(VAR_14);\n            } else {\n                SSL3_RECORD_sub_length(VAR_14, VAR_10);\n                SSL3_RECORD_add_off(VAR_14, VAR_10);\n                if (SSL3_RECORD_get_length(VAR_14) == 0) {\n                    VAR_0->rlayer.rstate = VAR_37;\n                    SSL3_RECORD_set_off(VAR_14, 0);\n                    SSL3_RECORD_set_read(VAR_14);\n                }\n            }\n            if (SSL3_RECORD_get_length(VAR_14) == 0\n                || (VAR_5 && VAR_10 == SSL3_RECORD_get_length(VAR_14))) {\n                VAR_11++;\n                VAR_14++;\n            }\n            VAR_13 += VAR_10;\n        } while (VAR_1 == VAR_20 && VAR_11 < VAR_12\n                 && VAR_13 < (unsigned int)VAR_4);\n        if (VAR_13 == 0) {\n            /* COMMENT_39 */\n            goto start;\n        }\n        if (!VAR_5 && VAR_11 == VAR_12\n            && (VAR_0->mode & VAR_38)\n            && SSL3_BUFFER_get_left(VAR_15) == 0)\n            ssl3_release_read_buffer(VAR_0);\n        return VAR_13;\n    }\n\n    /* COMMENT_40 */\n                                                                             \n                                                                            \n                                      \n       \n\n    /* COMMENT_45 */\n                                                                \n       \n    if (VAR_14->rec_version == VAR_39) {\n        /* COMMENT_48 */\n                                                                              \n                                                                            \n                                                                          \n                                                                    \n           \n        VAR_6 = VAR_29;\n        SSLerr(VAR_22, VAR_23);\n        goto f_err;\n    }\n\n    if (VAR_0->method->version == VAR_40\n        && (VAR_0->server || VAR_14->type != VAR_30)) {\n        /* COMMENT_54 */\n                                                                          \n                                                                               \n                                                                              \n                                                       \n           \n        VAR_0->version = VAR_14->rec_version;\n        VAR_6 = VAR_31;\n        SSLerr(VAR_22, VAR_41);\n        goto f_err;\n    }\n\n    /* COMMENT_60 */\n                                                                         \n                                                             \n       \n    {\n        unsigned int VAR_42 = 0;\n        unsigned char *VAR_43 = NULL;\n        unsigned int *VAR_44 = NULL;\n\n        if (SSL3_RECORD_get_type(VAR_14) == VAR_21) {\n            VAR_42 = sizeof VAR_0->rlayer.handshake_fragment;\n            VAR_43 = VAR_0->rlayer.handshake_fragment;\n            VAR_44 = &VAR_0->rlayer.handshake_fragment_len;\n        } else if (SSL3_RECORD_get_type(VAR_14) == VAR_30) {\n            VAR_42 = sizeof VAR_0->rlayer.alert_fragment;\n            VAR_43 = VAR_0->rlayer.alert_fragment;\n            VAR_44 = &VAR_0->rlayer.alert_fragment_len;\n        }\n\n        if (VAR_42 > 0) {\n            VAR_10 = VAR_42 - *VAR_44; /* COMMENT_64 */\n            if (SSL3_RECORD_get_length(VAR_14) < VAR_10)\n                VAR_10 = SSL3_RECORD_get_length(VAR_14); /* COMMENT_65 */\n\n            /* COMMENT_66 */\n            while (VAR_10-- > 0) {\n                VAR_43[(*VAR_44)++] =\n                    SSL3_RECORD_get_data(VAR_14)[SSL3_RECORD_get_off(VAR_14)];\n                SSL3_RECORD_add_off(VAR_14, 1);\n                SSL3_RECORD_add_length(VAR_14, -1);\n            }\n\n            if (*VAR_44 < VAR_42) {\n                SSL3_RECORD_set_read(VAR_14);\n                goto start;     /* COMMENT_67 */\n            }\n        }\n    }\n\n    /* COMMENT_68 */\n                                                                                 \n                                                                             \n                                                              \n       \n\n    /* COMMENT_73 */\n    if ((!VAR_0->server) &&\n        (VAR_0->rlayer.handshake_fragment_len >= 4) &&\n        (VAR_0->rlayer.handshake_fragment[0] == VAR_45) &&\n        (VAR_0->session != NULL) && (VAR_0->session->cipher != NULL)) {\n        VAR_0->rlayer.handshake_fragment_len = 0;\n\n        if ((VAR_0->rlayer.handshake_fragment[1] != 0) ||\n            (VAR_0->rlayer.handshake_fragment[2] != 0) ||\n            (VAR_0->rlayer.handshake_fragment[3] != 0)) {\n            VAR_6 = VAR_46;\n            SSLerr(VAR_22, VAR_47);\n            goto f_err;\n        }\n\n        if (VAR_0->msg_callback)\n            VAR_0->msg_callback(0, VAR_0->version, VAR_21,\n                            VAR_0->rlayer.handshake_fragment, 4, VAR_0,\n                            VAR_0->msg_callback_arg);\n\n        if (SSL_is_init_finished(VAR_0) &&\n            !(VAR_0->s3->flags & VAR_48) &&\n            !VAR_0->s3->renegotiate) {\n            ssl3_renegotiate(VAR_0);\n            if (ssl3_renegotiate_check(VAR_0)) {\n                VAR_7 = VAR_0->handshake_func(VAR_0);\n                if (VAR_7 < 0)\n                    return (VAR_7);\n                if (VAR_7 == 0) {\n                    SSLerr(VAR_22, VAR_27);\n                    return (-1);\n                }\n\n                if (!(VAR_0->mode & VAR_49)) {\n                    if (SSL3_BUFFER_get_left(VAR_15) == 0) {\n                        /* COMMENT_74 */\n                        BIO *VAR_50;\n                        /* COMMENT_75 */\n                                                                             \n                                                                             \n                                                                             \n                                                                     \n                           \n                        VAR_0->rwstate = VAR_51;\n                        VAR_50 = SSL_get_rbio(VAR_0);\n                        BIO_clear_retry_flags(VAR_50);\n                        BIO_set_retry_read(VAR_50);\n                        return (-1);\n                    }\n                }\n            }\n        }\n        /* COMMENT_81 */\n                                                                         \n                                                                   \n           \n        goto start;\n    }\n    /* COMMENT_85 */\n                                                                         \n                                                                        \n                                                 \n       \n    if (VAR_0->server &&\n        SSL_is_init_finished(VAR_0) &&\n        !VAR_0->s3->send_connection_binding &&\n        (VAR_0->version > VAR_52) &&\n        (VAR_0->rlayer.handshake_fragment_len >= 4) &&\n        (VAR_0->rlayer.handshake_fragment[0] == VAR_53) &&\n        (VAR_0->session != NULL) && (VAR_0->session->cipher != NULL) &&\n        !(VAR_0->ctx->options & VAR_54)) {\n        SSL3_RECORD_set_length(VAR_14, 0);\n        SSL3_RECORD_set_read(VAR_14);\n        ssl3_send_alert(VAR_0, VAR_55, VAR_56);\n        goto start;\n    }\n    if (VAR_0->rlayer.alert_fragment_len >= 2) {\n        int VAR_57 = VAR_0->rlayer.alert_fragment[0];\n        int VAR_58 = VAR_0->rlayer.alert_fragment[1];\n\n        VAR_0->rlayer.alert_fragment_len = 0;\n\n        if (VAR_0->msg_callback)\n            VAR_0->msg_callback(0, VAR_0->version, VAR_30,\n                            VAR_0->rlayer.alert_fragment, 2, VAR_0,\n                            VAR_0->msg_callback_arg);\n\n        if (VAR_0->info_callback != NULL)\n            VAR_16 = VAR_0->info_callback;\n        else if (VAR_0->ctx->info_callback != NULL)\n            VAR_16 = VAR_0->ctx->info_callback;\n\n        if (VAR_16 != NULL) {\n            VAR_8 = (VAR_57 << 8) | VAR_58;\n            VAR_16(VAR_0, VAR_59, VAR_8);\n        }\n\n        if (VAR_57 == VAR_55) {\n            VAR_0->s3->warn_alert = VAR_58;\n            SSL3_RECORD_set_read(VAR_14);\n\n            VAR_0->rlayer.alert_count++;\n            if (VAR_0->rlayer.alert_count == VAR_60) {\n                VAR_6 = VAR_31;\n                SSLerr(VAR_22, VAR_61);\n                goto f_err;\n            }\n\n            if (VAR_58 == VAR_62) {\n                VAR_0->shutdown |= VAR_33;\n                return (0);\n            }\n            /* COMMENT_90 */\n                                                                  \n                                                                           \n                                                                   \n                                                                         \n                                                                          \n                                                     \n               \n            else if (VAR_58 == VAR_56) {\n                VAR_6 = VAR_63;\n                SSLerr(VAR_22, VAR_64);\n                goto f_err;\n            }\n#ifdef VAR_65\n            else if (alert_descr == VAR_65)\n                return (0);\n#endif\n        } else if (VAR_57 == VAR_66) {\n            char VAR_67[16];\n\n            VAR_0->rwstate = VAR_28;\n            VAR_0->s3->fatal_alert = alert_descr;\n            SSLerr(VAR_22, VAR_68 + alert_descr);\n            BIO_snprintf(VAR_67, sizeof VAR_67, \"%d\", alert_descr);\n            ERR_add_error_data(2, \"SSL alert number \", VAR_67);\n            VAR_0->shutdown |= VAR_33;\n            SSL3_RECORD_set_read(VAR_14);\n            SSL_CTX_remove_session(VAR_0->session_ctx, VAR_0->session);\n            return (0);\n        } else {\n            VAR_6 = VAR_69;\n            SSLerr(VAR_22, VAR_70);\n            goto f_err;\n        }\n\n        goto start;\n    }\n\n    if (VAR_0->shutdown & VAR_71) { /* COMMENT_98 */\n                                                         \n        VAR_0->rwstate = VAR_28;\n        SSL3_RECORD_set_length(VAR_14, 0);\n        SSL3_RECORD_set_read(VAR_14);\n        return (0);\n    }\n\n    if (SSL3_RECORD_get_type(VAR_14) == VAR_34) {\n        VAR_6 = VAR_31;\n        SSLerr(VAR_22, VAR_36);\n        goto f_err;\n    }\n\n    /* COMMENT_100 */\n                                                                         \n       \n    if ((VAR_0->rlayer.handshake_fragment_len >= 4)\n        && !ossl_statem_get_in_handshake(VAR_0)) {\n        if (SSL_is_init_finished(VAR_0) &&\n            !(VAR_0->s3->flags & VAR_48)) {\n            ossl_statem_set_in_init(VAR_0, 1);\n            VAR_0->renegotiate = 1;\n            VAR_0->new_session = 1;\n        }\n        VAR_7 = VAR_0->handshake_func(VAR_0);\n        if (VAR_7 < 0)\n            return (VAR_7);\n        if (VAR_7 == 0) {\n            SSLerr(VAR_22, VAR_27);\n            return (-1);\n        }\n\n        if (!(VAR_0->mode & VAR_49)) {\n            if (SSL3_BUFFER_get_left(VAR_15) == 0) {\n                /* COMMENT_74 */\n                BIO *VAR_50;\n                /* COMMENT_103 */\n                                                                            \n                                                                        \n                                                                       \n                                                 \n                   \n                VAR_0->rwstate = VAR_51;\n                VAR_50 = SSL_get_rbio(VAR_0);\n                BIO_clear_retry_flags(VAR_50);\n                BIO_set_retry_read(VAR_50);\n                return (-1);\n            }\n        }\n        goto start;\n    }\n\n    switch (SSL3_RECORD_get_type(VAR_14)) {\n    default:\n        /* COMMENT_109 */\n                                                                           \n                                       \n           \n        if (VAR_0->version >= VAR_72 && VAR_0->version <= VAR_73) {\n            SSL3_RECORD_set_length(VAR_14, 0);\n            SSL3_RECORD_set_read(VAR_14);\n            goto start;\n        }\n        VAR_6 = VAR_31;\n        SSLerr(VAR_22, VAR_74);\n        goto f_err;\n    case VAR_34:\n    case VAR_30:\n    case VAR_21:\n        /* COMMENT_113 */\n                                                                          \n                                                                              \n                                                       \n           \n        VAR_6 = VAR_31;\n        SSLerr(VAR_22, VAR_23);\n        goto f_err;\n    case VAR_20:\n        /* COMMENT_118 */\n                                                                    \n                                                                           \n                                                                    \n                                                                        \n                                        \n           \n        if (ossl_statem_app_data_allowed(VAR_0)) {\n            VAR_0->s3->in_read_app_data = 2;\n            return (-1);\n        } else {\n            VAR_6 = VAR_31;\n            SSLerr(VAR_22, VAR_74);\n            goto f_err;\n        }\n    }\n    /* COMMENT_125 */\n\n f_err:\n    ssl3_send_alert(VAR_0, VAR_66, VAR_6);\n    return (-1);\n}",
  "func_graph_path": "openssl/63658103d4441924f8dbfc517b99bb54758a98b9/rec_layer_s3.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -171,7 +171,11 @@\n \n             memcpy(buf, &(rr->data[rr->off]), n);\n             buf += n;\n-            if (!peek) {\n+            if (peek) {\n+                /* Mark any zero length record as consumed CVE-2016-6305 */\n+                if (SSL3_RECORD_get_length(rr) == 0)\n+                    SSL3_RECORD_set_read(rr);\n+            } else {\n                 SSL3_RECORD_sub_length(rr, n);\n                 SSL3_RECORD_add_off(rr, n);\n                 if (SSL3_RECORD_get_length(rr) == 0) {",
  "diff_line_info": {
    "deleted_lines": [
      "            if (!peek) {"
    ],
    "added_lines": [
      "            if (peek) {",
      "                /* Mark any zero length record as consumed CVE-2016-6305 */",
      "                if (SSL3_RECORD_get_length(rr) == 0)",
      "                    SSL3_RECORD_set_read(rr);",
      "            } else {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/EktapopaT/openssl/pull/1",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/EktapopaT/openssl/pull/1: 403 Client Error: Forbidden for url: https://api.github.com/repos/EktapopaT/openssl/pulls/1",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Step-by-Step Explanation:**\n\n1. **Identify Key Terms:**\n   - \"Fix\", \"hang\", \"SSL_peek\", \"malicious peer\", \"Denial Of Service (DoS)\", \"CVE-2016-6305\".\n   - These terms suggest a security issue being addressed.\n\n2. **Consistency Check:**\n   - The commit message refers to fixing an infinite loop in SSL_peek related to empty records. The code diff shows modifications to handle zero-length records, which aligns with the description.\n\n3. **Purpose Evaluation:**\n   - The code changes prevent an infinite loop in SSL_peek, which directly addresses a bug causing a security risk.\n\n4. **Security Vulnerability Assessment:**\n   - The patch references a CVE (CVE-2016-6305), indicating a known security issue. The fix prevents a DoS attack, which is a security concern.\n\n5. **Confidence Scoring:**\n   - Clear evidence of a security fix with explicit CVE reference and aligned code changes. High confidence.\n\n**Final Classification: Security Vulnerability Fix; Confidence: 1.0**"
}