{
  "cve_id": "CVE-2021-20218",
  "cwe_ids": [
    "CWE-22"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "fabric8io/kubernetes-client",
  "commit_msg": "fix: CVE-2021-20218 vulnerable to a path traversal",
  "commit_hash": "325d67cc80b73f049a5d0cea4917c1f2709a8d86",
  "git_url": "https://github.com/fabric8io/kubernetes-client/commit/325d67cc80b73f049a5d0cea4917c1f2709a8d86",
  "file_path": "kubernetes-client/src/main/java/io/fabric8/kubernetes/client/dsl/internal/core/v1/PodOperationsImpl.java",
  "func_name": "copyDir",
  "func_before": "private void copyDir(String source, File target) throws Exception {\n    //Let's wrap the code to a runnable inner class to avoid NoClassDef on Option classes.\n    try {\n    new Runnable() {\n      public void  run() {\n        File destination = target;\n        if (!destination.isDirectory() && !destination.mkdirs())\n\n        {\n          throw KubernetesClientException.launderThrowable(new IOException(\"Failed to create directory: \" + destination));\n        }\n        try (\n          InputStream is = readTar(source);\n          org.apache.commons.compress.archivers.tar.TarArchiveInputStream tis = new org.apache.commons.compress.archivers.tar.TarArchiveInputStream(is))\n\n        {\n          for (org.apache.commons.compress.archivers.ArchiveEntry entry = tis.getNextTarEntry(); entry != null; entry = tis.getNextEntry()) {\n            if (tis.canReadEntryData(entry)) {\n              File f = new File(destination, entry.getName());\n              if (entry.isDirectory()) {\n                if (!f.isDirectory() && !f.mkdirs()) {\n                  throw new IOException(\"Failed to create directory: \" + f);\n                }\n              } else {\n                File parent = f.getParentFile();\n                if (!parent.isDirectory() && !parent.mkdirs()) {\n                  throw new IOException(\"Failed to create directory: \" + f);\n                }\n                try (OutputStream fs = new FileOutputStream(f)) {\n                  System.out.println(\"Writing: \" + f.getCanonicalPath());\n                  BlockingInputStreamPumper pumper = new BlockingInputStreamPumper(tis, new Callback<byte[]>() {\n                    @Override\n                    public void call(byte[] input) {\n                      try {\n                        fs.write(input);\n                      } catch (IOException e) {\n                        throw KubernetesClientException.launderThrowable(e);\n                      }\n                    }\n                  }, () -> {\n                    try {\n                      fs.close();\n                    } catch (IOException e) {\n                      throw KubernetesClientException.launderThrowable(e);\n                    }\n                  });\n                  pumper.run();\n                }\n              }\n            }\n          }\n        } catch (Exception e) {\n          throw KubernetesClientException.launderThrowable(e);\n        }\n      }\n    }.run();\n     } catch (NoClassDefFoundError e) {\n      throw new KubernetesClientException(\"TarArchiveInputStream class is provided by commons-codec, an optional dependency. To use the read/copy functionality you must explicitly add this dependency to the classpath.\");\n    }\n  }",
  "abstract_func_before": "private void copyDir(String VAR_0, File VAR_1) throws Exception {\n    /* COMMENT_0 */\n    try {\n    new Runnable() {\n      public void  run() {\n        File VAR_2 = VAR_1;\n        if (!VAR_2.isDirectory() && !VAR_2.mkdirs())\n\n        {\n          throw VAR_3.launderThrowable(new IOException(\"Failed to create directory: \" + VAR_2));\n        }\n        try (\n          InputStream VAR_4 = readTar(VAR_0);\n          org.apache.commons.compress.archivers.tar.TarArchiveInputStream VAR_5 = new org.apache.commons.compress.archivers.tar.TarArchiveInputStream(VAR_4))\n\n        {\n          for (org.apache.commons.compress.archivers.ArchiveEntry VAR_6 = VAR_5.getNextTarEntry(); VAR_6 != null; VAR_6 = VAR_5.getNextEntry()) {\n            if (VAR_5.canReadEntryData(VAR_6)) {\n              File VAR_7 = new File(VAR_2, VAR_6.getName());\n              if (VAR_6.isDirectory()) {\n                if (!VAR_7.isDirectory() && !VAR_7.mkdirs()) {\n                  throw new IOException(\"Failed to create directory: \" + VAR_7);\n                }\n              } else {\n                File VAR_8 = VAR_7.getParentFile();\n                if (!VAR_8.isDirectory() && !VAR_8.mkdirs()) {\n                  throw new IOException(\"Failed to create directory: \" + VAR_7);\n                }\n                try (OutputStream VAR_9 = new FileOutputStream(VAR_7)) {\n                  VAR_10.out.println(\"Writing: \" + VAR_7.getCanonicalPath());\n                  BlockingInputStreamPumper VAR_11 = new BlockingInputStreamPumper(VAR_5, new Callback<byte[]>() {\n                    @Override\n                    public void call(byte[] VAR_12) {\n                      try {\n                        VAR_9.write(VAR_12);\n                      } catch (IOException VAR_13) {\n                        throw VAR_3.launderThrowable(VAR_13);\n                      }\n                    }\n                  }, () -> {\n                    try {\n                      VAR_9.close();\n                    } catch (IOException VAR_13) {\n                      throw VAR_3.launderThrowable(VAR_13);\n                    }\n                  });\n                  VAR_11.run();\n                }\n              }\n            }\n          }\n        } catch (Exception VAR_13) {\n          throw VAR_3.launderThrowable(VAR_13);\n        }\n      }\n    }.run();\n     } catch (NoClassDefFoundError VAR_13) {\n      throw new KubernetesClientException(\"TarArchiveInputStream class is provided by commons-codec, an optional dependency. To use the read/copy functionality you must explicitly add this dependency to the classpath.\");\n    }\n  }",
  "func_graph_path_before": "fabric8io/kubernetes-client/325d67cc80b73f049a5d0cea4917c1f2709a8d86/PodOperationsImpl.java/vul/before/0.json",
  "func": "private void copyDir(String source, File target) throws Exception {\n    //Let's wrap the code to a runnable inner class to avoid NoClassDef on Option classes.\n    try {\n    new Runnable() {\n      public void  run() {\n        File destination = target;\n        if (!destination.isDirectory() && !destination.mkdirs())\n\n        {\n          throw KubernetesClientException.launderThrowable(new IOException(\"Failed to create directory: \" + destination));\n        }\n        try (\n          InputStream is = readTar(source);\n          org.apache.commons.compress.archivers.tar.TarArchiveInputStream tis = new org.apache.commons.compress.archivers.tar.TarArchiveInputStream(is))\n\n        {\n          for (org.apache.commons.compress.archivers.ArchiveEntry entry = tis.getNextTarEntry(); entry != null; entry = tis.getNextEntry()) {\n            if (tis.canReadEntryData(entry)) {\n              final String normalizedEntryName = FilenameUtils.normalize(entry.getName());\n              if (normalizedEntryName == null){\n                throw new IOException(\"Tar entry '\" + entry.getName() + \"' has an invalid name\");\n              }\n              File f = new File(destination, normalizedEntryName);\n              if (entry.isDirectory()) {\n                if (!f.isDirectory() && !f.mkdirs()) {\n                  throw new IOException(\"Failed to create directory: \" + f);\n                }\n              } else {\n                File parent = f.getParentFile();\n                if (!parent.isDirectory() && !parent.mkdirs()) {\n                  throw new IOException(\"Failed to create directory: \" + f);\n                }\n                try (OutputStream fs = new FileOutputStream(f)) {\n                  System.out.println(\"Writing: \" + f.getCanonicalPath());\n                  BlockingInputStreamPumper pumper = new BlockingInputStreamPumper(tis, new Callback<byte[]>() {\n                    @Override\n                    public void call(byte[] input) {\n                      try {\n                        fs.write(input);\n                      } catch (IOException e) {\n                        throw KubernetesClientException.launderThrowable(e);\n                      }\n                    }\n                  }, () -> {\n                    try {\n                      fs.close();\n                    } catch (IOException e) {\n                      throw KubernetesClientException.launderThrowable(e);\n                    }\n                  });\n                  pumper.run();\n                }\n              }\n            }\n          }\n        } catch (Exception e) {\n          throw KubernetesClientException.launderThrowable(e);\n        }\n      }\n    }.run();\n     } catch (NoClassDefFoundError e) {\n      throw new KubernetesClientException(\"TarArchiveInputStream class is provided by commons-codec, an optional dependency. To use the read/copy functionality you must explicitly add this dependency to the classpath.\");\n    }\n  }",
  "abstract_func": "private void copyDir(String VAR_0, File VAR_1) throws Exception {\n    /* COMMENT_0 */\n    try {\n    new Runnable() {\n      public void  run() {\n        File VAR_2 = VAR_1;\n        if (!VAR_2.isDirectory() && !VAR_2.mkdirs())\n\n        {\n          throw VAR_3.launderThrowable(new IOException(\"Failed to create directory: \" + VAR_2));\n        }\n        try (\n          InputStream VAR_4 = readTar(VAR_0);\n          org.apache.commons.compress.archivers.tar.TarArchiveInputStream VAR_5 = new org.apache.commons.compress.archivers.tar.TarArchiveInputStream(VAR_4))\n\n        {\n          for (org.apache.commons.compress.archivers.ArchiveEntry VAR_6 = VAR_5.getNextTarEntry(); VAR_6 != null; VAR_6 = VAR_5.getNextEntry()) {\n            if (VAR_5.canReadEntryData(VAR_6)) {\n              final String VAR_7 = VAR_8.normalize(VAR_6.getName());\n              if (VAR_7 == null){\n                throw new IOException(\"Tar entry '\" + VAR_6.getName() + \"' has an invalid name\");\n              }\n              File VAR_9 = new File(VAR_2, VAR_7);\n              if (VAR_6.isDirectory()) {\n                if (!VAR_9.isDirectory() && !VAR_9.mkdirs()) {\n                  throw new IOException(\"Failed to create directory: \" + VAR_9);\n                }\n              } else {\n                File VAR_10 = VAR_9.getParentFile();\n                if (!VAR_10.isDirectory() && !VAR_10.mkdirs()) {\n                  throw new IOException(\"Failed to create directory: \" + VAR_9);\n                }\n                try (OutputStream VAR_11 = new FileOutputStream(VAR_9)) {\n                  VAR_12.out.println(\"Writing: \" + VAR_9.getCanonicalPath());\n                  BlockingInputStreamPumper VAR_13 = new BlockingInputStreamPumper(VAR_5, new Callback<byte[]>() {\n                    @Override\n                    public void call(byte[] VAR_14) {\n                      try {\n                        VAR_11.write(VAR_14);\n                      } catch (IOException VAR_15) {\n                        throw VAR_3.launderThrowable(VAR_15);\n                      }\n                    }\n                  }, () -> {\n                    try {\n                      VAR_11.close();\n                    } catch (IOException VAR_15) {\n                      throw VAR_3.launderThrowable(VAR_15);\n                    }\n                  });\n                  VAR_13.run();\n                }\n              }\n            }\n          }\n        } catch (Exception VAR_15) {\n          throw VAR_3.launderThrowable(VAR_15);\n        }\n      }\n    }.run();\n     } catch (NoClassDefFoundError VAR_15) {\n      throw new KubernetesClientException(\"TarArchiveInputStream class is provided by commons-codec, an optional dependency. To use the read/copy functionality you must explicitly add this dependency to the classpath.\");\n    }\n  }",
  "func_graph_path": "fabric8io/kubernetes-client/325d67cc80b73f049a5d0cea4917c1f2709a8d86/PodOperationsImpl.java/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -16,7 +16,11 @@\n         {\n           for (org.apache.commons.compress.archivers.ArchiveEntry entry = tis.getNextTarEntry(); entry != null; entry = tis.getNextEntry()) {\n             if (tis.canReadEntryData(entry)) {\n-              File f = new File(destination, entry.getName());\n+              final String normalizedEntryName = FilenameUtils.normalize(entry.getName());\n+              if (normalizedEntryName == null){\n+                throw new IOException(\"Tar entry '\" + entry.getName() + \"' has an invalid name\");\n+              }\n+              File f = new File(destination, normalizedEntryName);\n               if (entry.isDirectory()) {\n                 if (!f.isDirectory() && !f.mkdirs()) {\n                   throw new IOException(\"Failed to create directory: \" + f);",
  "diff_line_info": {
    "deleted_lines": [
      "              File f = new File(destination, entry.getName());"
    ],
    "added_lines": [
      "              final String normalizedEntryName = FilenameUtils.normalize(entry.getName());",
      "              if (normalizedEntryName == null){",
      "                throw new IOException(\"Tar entry '\" + entry.getName() + \"' has an invalid name\");",
      "              }",
      "              File f = new File(destination, normalizedEntryName);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/fabric8io/kubernetes-client/pull/2782",
  "description": {
    "pr_info": {
      "title": "fix: CVE-2021-20218 vulnerable to a path traversal",
      "number": 2782
    },
    "comment": [
      "## Description\r\n\r\nProvided fix and tests for path traversal vulnerability.\r\n\r\n_Added a partial copy of Apache Commons IO FilenameUtils to avoid adding any dependency, especially considering the fix might be back-ported to very early versions (>=v4.2.0)._\r\n_The package for this copied classes (`io.fabric8.kubernetes.client.lib`) has been decided to avoid OSGi issues regarding exported and imported modules_\r\n\r\nRelates to:\r\n- #2715 \r\n- https://github.com/fabric8io/kubernetes-client/commit/6f7b79f21a9f37c557b7b37d0378cac37b6e1d6e\r\n- #2752\r\n\r\n## Type of change\r\n<!---\r\nWhat types of changes does your code introduce? Put an `x` in all the boxes that apply\r\n-->\r\n - [x] Bug fix (non-breaking change which fixes an issue)\r\n - [ ] Feature (non-breaking change which adds functionality)\r\n - [ ] Breaking change (fix or feature that would cause existing functionality to change\r\n - [ ] Chore (non-breaking change which doesn't affect codebase;\r\n   test, version modification, documentation, etc.)\r\n\r\n## Checklist\r\n - [x] Code contributed by me aligns with current project license: [Apache 2.0](https://www.apache.org/licenses/LICENSE-2.0)\r\n - [x] I Added [CHANGELOG](../CHANGELOG.md) entry regarding this change\r\n - [x] I have implemented unit tests to cover my changes\r\n - [ ] I have added/updated the [javadocs](https://www.javadoc.io/doc/io.fabric8/kubernetes-client/latest/index.html) and other [documentation](https://github.com/fabric8io/kubernetes-client/blob/master/doc/CHEATSHEET.md) accordingly\r\n - [ ] No new bugs, code smells, etc. in [SonarCloud](https://sonarcloud.io/dashboard?id=fabric8io_kubernetes-client) report\r\n - [ ] I tested my code in Kubernetes\r\n - [ ] I tested my code in OpenShift\r\n\r\n<!--\r\nIntegration tests (https://github.com/fabric8io/kubernetes-client/tree/master/kubernetes-itests)\r\nPlease check integration tests and provide/improve tests if applicable.\r\n\r\nOpen your PR in Draft mode and verify all of the applicable Checklist items before marking your pull request as ready for review\r\n-->\r\n",
      "Can one of the admins verify this patch?",
      "n.b. K8s E2E tests won't pass in this version because the GH action is not compatible with the newly provided environment by GitHub (Ubuntu 20.04 as opposed to Ubuntu 18.04)\r\n\r\nSame for Sonar task:\r\n```\r\nThe version of Java (1.8.0_282) you have used to run this analysis is deprecated and we stopped accepting it. Please update to at least Java 11.\r\n```"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Step-by-Step Explanation:**\n\n1. **Input Analysis:**\n   - The commit message mentions fixing a CVE related to a path traversal vulnerability.\n   - The vulnerability description details the addition of a fix and tests for this issue, involving modification of file handling to prevent path traversal.\n   - The code diff shows changes in the `copyDir` function where file names are now normalized before creating new files, preventing invalid names.\n\n2. **Consistency Check:**\n   - The code modifications directly address the vulnerability described, ensuring that file names are validated before use.\n\n3. **Purpose Evaluation:**\n   - The changes prevent path traversal attacks by normalizing file names, a critical security measure.\n\n4. **Security Vulnerability Assessment:**\n   - Addresses a known CVE, involves input validation to prevent attacks, clearly a security fix.\n\n5. **Confidence Scoring:**\n   - High confidence due to precise alignment of commit details, description, and code changes.\n\n**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}