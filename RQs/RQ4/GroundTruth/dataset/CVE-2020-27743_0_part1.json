{
  "cve_id": "CVE-2020-27743",
  "cwe_ids": [
    "CWE-330"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "kravietz/pam_tacplus",
  "commit_msg": "pam_tacplus.c: Fallback to using PID as task ID\n\nIf there is a failure obtaining a random task ID for the session\naccounting request then fallback to using the PID, as this is unique\nfor the lifetime of the PAM application and therefore session.",
  "commit_hash": "bceaab0cd51a09b88f40f19da799ac7390264bf8",
  "git_url": "https://github.com/kravietz/pam_tacplus/commit/bceaab0cd51a09b88f40f19da799ac7390264bf8",
  "file_path": "pam_tacplus.c",
  "func_name": "pam_sm_open_session",
  "func_before": "PAM_EXTERN\nint pam_sm_open_session(pam_handle_t *pamh, int UNUSED(flags), int argc,\n                        const char **argv) {\n\n/* Task ID has no need to be cryptographically strong so we don't\n * check for failures of the RAND functions. If they fail then we are\n * as well sending the accounting request regardless of whether any value\n * was written to task_id.\n */\n#if defined(HAVE_OPENSSL_RAND_H) && defined(HAVE_LIBCRYPTO)\n# if defined(HAVE_RAND_BYTES)\n\tRAND_bytes((unsigned char *) &task_id, sizeof(task_id));\n# else\n\tRAND_pseudo_bytes((unsigned char *) &task_id, sizeof(task_id));\n# endif\n#else\n\ttask_id=(short int) magic();\n#endif\n\n\treturn _pam_account(pamh, argc, argv, TAC_PLUS_ACCT_FLAG_START, NULL);\n}",
  "abstract_func_before": "PAM_EXTERN\nVAR_0 pam_sm_open_session(pam_handle_t *VAR_1, int UNUSED(flags), int VAR_2,\n                        const char **VAR_3) {\n\n/* COMMENT_0 */\n                                                                     \n                                                                         \n                          \n   \n#if defined(VAR_4) && defined(VAR_5)\n# if defined(VAR_6)\n\tRAND_bytes((unsigned char *) &VAR_7, sizeof(VAR_7));\n# else\n\tRAND_pseudo_bytes((unsigned char *) &VAR_7, sizeof(VAR_7));\n# endif\n#else\n\tVAR_7=(short int) magic();\n#endif\n\n\treturn _pam_account(VAR_1, VAR_2, VAR_3, VAR_8, NULL);\n}",
  "func_graph_path_before": null,
  "func": "PAM_EXTERN\nint pam_sm_open_session(pam_handle_t *pamh, int UNUSED(flags), int argc,\n                        const char **argv) {\n\n/* Task ID has no need to be cryptographically strong so we don't\n * check for failures of the RAND functions. If we fail to get an ID we\n * fallback to using our PID (in _pam_send_account).\n */\n#if defined(HAVE_OPENSSL_RAND_H) && defined(HAVE_LIBCRYPTO)\n# if defined(HAVE_RAND_BYTES)\n\tRAND_bytes((unsigned char *) &task_id, sizeof(task_id));\n# else\n\tRAND_pseudo_bytes((unsigned char *) &task_id, sizeof(task_id));\n# endif\n#else\n\ttask_id=(short int) magic();\n#endif\n\n\tif (task_id == 0)\n\t\tsyslog(LOG_INFO, \"%s: failed to generate random task ID, \"\n\t\t\t\t\"falling back to PID\", __FUNCTION__);\n\n\treturn _pam_account(pamh, argc, argv, TAC_PLUS_ACCT_FLAG_START, NULL);\n}",
  "abstract_func": "PAM_EXTERN\nVAR_0 pam_sm_open_session(pam_handle_t *VAR_1, int UNUSED(flags), int VAR_2,\n                        const char **VAR_3) {\n\n/* COMMENT_0 */\n                                                                       \n                                                    \n   \n#if defined(VAR_4) && defined(VAR_5)\n# if defined(VAR_6)\n\tRAND_bytes((unsigned char *) &VAR_7, sizeof(VAR_7));\n# else\n\tRAND_pseudo_bytes((unsigned char *) &VAR_7, sizeof(VAR_7));\n# endif\n#else\n\tVAR_7=(short int) magic();\n#endif\n\n\tif (VAR_7 == 0)\n\t\tsyslog(VAR_8, \"%s: failed to generate random task ID, \"\n\t\t\t\t\"falling back to PID\", VAR_9);\n\n\treturn _pam_account(VAR_1, VAR_2, VAR_3, VAR_10, NULL);\n}",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -3,9 +3,8 @@\n                         const char **argv) {\n \n /* Task ID has no need to be cryptographically strong so we don't\n- * check for failures of the RAND functions. If they fail then we are\n- * as well sending the accounting request regardless of whether any value\n- * was written to task_id.\n+ * check for failures of the RAND functions. If we fail to get an ID we\n+ * fallback to using our PID (in _pam_send_account).\n  */\n #if defined(HAVE_OPENSSL_RAND_H) && defined(HAVE_LIBCRYPTO)\n # if defined(HAVE_RAND_BYTES)\n@@ -17,5 +16,9 @@\n \ttask_id=(short int) magic();\n #endif\n \n+\tif (task_id == 0)\n+\t\tsyslog(LOG_INFO, \"%s: failed to generate random task ID, \"\n+\t\t\t\t\"falling back to PID\", __FUNCTION__);\n+\n \treturn _pam_account(pamh, argc, argv, TAC_PLUS_ACCT_FLAG_START, NULL);\n }",
  "diff_line_info": {
    "deleted_lines": [
      " * check for failures of the RAND functions. If they fail then we are",
      " * as well sending the accounting request regardless of whether any value",
      " * was written to task_id."
    ],
    "added_lines": [
      " * check for failures of the RAND functions. If we fail to get an ID we",
      " * fallback to using our PID (in _pam_send_account).",
      "\tif (task_id == 0)",
      "\t\tsyslog(LOG_INFO, \"%s: failed to generate random task ID, \"",
      "\t\t\t\t\"falling back to PID\", __FUNCTION__);",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/kravietz/pam_tacplus/pull/163",
  "description": {
    "pr_info": {
      "title": "Check for failure of OpenSSL RAND_[pseudo_]bytes",
      "number": 163
    },
    "comment": [
      "Discovered by @gollub.\r\n\r\nmagic.c: check for failure of RAND_[pseudo_]bytes\r\n\r\nWhen magic() is implemented via libcrypto's RAND_bytes or\r\nRAND_pseudo_bytes we should check for a failure and abort to\r\nensure we don't use a predictable session_id.\r\n\r\nThis prevents (further) weakening* of the TACACS+ protocol\r\n\"encryption\" since session_id is an input to the algorithm.\r\n\r\n*by modern standards TACACS+ is deemed \"obfuscated\" - RFC 8907.\r\n\r\npam_tacplus.c: Fallback to using PID as task ID\r\n\r\nIf there is a failure obtaining a random task ID for the session\r\naccounting request then fallback to using the PID, as this is unique\r\nfor the lifetime of the PAM application and therefore session.",
      "LGTM",
      "I have requested allocation of a CVE ID from MITRE.",
      "Thanks, when we have CVE we can bump version and publish a new release.",
      "CVE-2020-27743 was assigned for this issue.",
      "Can you review/edit https://github.com/kravietz/pam_tacplus/security/advisories/GHSA-rp3p-jm35-jv76",
      "Thanks all for progressing this while I was AFK.",
      "@kravietz, @deastoe looking the commit history of the project it looks that the issue only is introduced after 6fac2504657b8d98fcd627d60ebdbffcf0253b81 in v1.5.0-beta.1. If this is correct maybe in GHSA-rp3p-jm35-jv76 that could be added to the 'affected versions' constraints.",
      "@carnil , that's correct. Updated the advisory: \"after v1.5.0, before v1.6.1\"",
      "@gollub: Thanks!",
      "@carnil, @gollub, I believe this also affects v1.4.1: https://github.com/kravietz/pam_tacplus/blob/8dddbec2940f99fa4867d6b6a92d8ba10206915e/libtac/lib/header.c#L93\r\nI will update the advisory.\r\n\r\nIn fact, it looks like v1.4.1 also does not check for a failure of getrandom(). This was fixed in v1.5.1 (d5ea51ff6a9b74bdc8a9ea7e6758d520f9b9a9fa)",
      "> In fact, it looks like v1.4.1 also does not check for a failure of getrandom().\r\n\r\nHowever in 1.4.1 getrandom() is only used when not built with libcrypto, and 1.4.1 cannot be built out-of-the-box _without_ libcrypto."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95"
}