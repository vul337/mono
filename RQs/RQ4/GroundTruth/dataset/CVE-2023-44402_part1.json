{
  "cve_id": "CVE-2023-44402",
  "cwe_ids": [
    "CWE-345"
  ],
  "cvss_vector": "CVSS:3.1/AV:L/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "electron",
  "commit_msg": "fix: ensure app load is limited to real asar files when appropriate",
  "commit_hash": "342cf186d98eee64a68382bc74382b2e6745eb61",
  "git_url": "https://github.com/electron/electron/commit/342cf186d98eee64a68382bc74382b2e6745eb61",
  "file_path": "shell/common/node_bindings.cc",
  "func_name": "NodeBindings::CreateEnvironment",
  "func_before": "std::shared_ptr<node::Environment> NodeBindings::CreateEnvironment(\n    v8::Handle<v8::Context> context,\n    node::MultiIsolatePlatform* platform,\n    std::vector<std::string> args,\n    std::vector<std::string> exec_args,\n    absl::optional<base::RepeatingCallback<void()>> on_app_code_ready) {\n  // Feed node the path to initialization script.\n  std::string process_type;\n  switch (browser_env_) {\n    case BrowserEnvironment::kBrowser:\n      process_type = \"browser\";\n      break;\n    case BrowserEnvironment::kRenderer:\n      process_type = \"renderer\";\n      break;\n    case BrowserEnvironment::kWorker:\n      process_type = \"worker\";\n      break;\n    case BrowserEnvironment::kUtility:\n      process_type = \"utility\";\n      break;\n  }\n\n  v8::Isolate* isolate = context->GetIsolate();\n  gin_helper::Dictionary global(isolate, context->Global());\n\n  if (browser_env_ == BrowserEnvironment::kBrowser) {\n    const std::vector<std::string> search_paths = {\"app.asar\", \"app\",\n                                                   \"default_app.asar\"};\n    const std::vector<std::string> app_asar_search_paths = {\"app.asar\"};\n    context->Global()->SetPrivate(\n        context,\n        v8::Private::ForApi(\n            isolate,\n            gin::ConvertToV8(isolate, \"appSearchPaths\").As<v8::String>()),\n        gin::ConvertToV8(isolate,\n                         electron::fuses::IsOnlyLoadAppFromAsarEnabled()\n                             ? app_asar_search_paths\n                             : search_paths));\n  }\n\n  base::FilePath resources_path = GetResourcesPath();\n  std::string init_script = \"electron/js2c/\" + process_type + \"_init\";\n\n  args.insert(args.begin() + 1, init_script);\n\n  auto* isolate_data = node::CreateIsolateData(isolate, uv_loop_, platform);\n  context->SetAlignedPointerInEmbedderData(kElectronContextEmbedderDataIndex,\n                                           static_cast<void*>(isolate_data));\n\n  node::Environment* env;\n  uint64_t flags = node::EnvironmentFlags::kDefaultFlags |\n                   node::EnvironmentFlags::kHideConsoleWindows |\n                   node::EnvironmentFlags::kNoGlobalSearchPaths |\n                   node::EnvironmentFlags::kNoRegisterESMLoader;\n\n  if (browser_env_ == BrowserEnvironment::kRenderer ||\n      browser_env_ == BrowserEnvironment::kWorker) {\n    // Only one ESM loader can be registered per isolate -\n    // in renderer processes this should be blink. We need to tell Node.js\n    // not to register its handler (overriding blinks) in non-browser processes.\n    // We also avoid overriding globals like setImmediate, clearImmediate\n    // queueMicrotask etc during the bootstrap phase of Node.js\n    // for processes that already have these defined by DOM.\n    // Check //third_party/electron_node/lib/internal/bootstrap/node.js\n    // for the list of overrides on globalThis.\n    flags |= node::EnvironmentFlags::kNoBrowserGlobals |\n             node::EnvironmentFlags::kNoCreateInspector;\n  }\n\n  if (!electron::fuses::IsNodeCliInspectEnabled()) {\n    // If --inspect and friends are disabled we also shouldn't listen for\n    // SIGUSR1\n    flags |= node::EnvironmentFlags::kNoStartDebugSignalHandler;\n  }\n\n  {\n    v8::TryCatch try_catch(isolate);\n    env = node::CreateEnvironment(\n        static_cast<node::IsolateData*>(isolate_data), context, args, exec_args,\n        static_cast<node::EnvironmentFlags::Flags>(flags));\n\n    if (try_catch.HasCaught()) {\n      std::string err_msg =\n          \"Failed to initialize node environment in process: \" + process_type;\n      v8::Local<v8::Message> message = try_catch.Message();\n      std::string msg;\n      if (!message.IsEmpty() &&\n          gin::ConvertFromV8(isolate, message->Get(), &msg))\n        err_msg += \" , with error: \" + msg;\n      LOG(ERROR) << err_msg;\n    }\n  }\n\n  DCHECK(env);\n\n  node::IsolateSettings is;\n\n  // Use a custom fatal error callback to allow us to add\n  // crash message and location to CrashReports.\n  is.fatal_error_callback = V8FatalErrorCallback;\n\n  // We don't want to abort either in the renderer or browser processes.\n  // We already listen for uncaught exceptions and handle them there.\n  // For utility process we expect the process to behave as standard\n  // Node.js runtime and abort the process with appropriate exit\n  // code depending on a handler being set for `uncaughtException` event.\n  if (browser_env_ != BrowserEnvironment::kUtility) {\n    is.should_abort_on_uncaught_exception_callback = [](v8::Isolate*) {\n      return false;\n    };\n  }\n\n  // Use a custom callback here to allow us to leverage Blink's logic in the\n  // renderer process.\n  is.allow_wasm_code_generation_callback = AllowWasmCodeGenerationCallback;\n  is.flags |= node::IsolateSettingsFlags::\n      ALLOW_MODIFY_CODE_GENERATION_FROM_STRINGS_CALLBACK;\n  is.modify_code_generation_from_strings_callback =\n      ModifyCodeGenerationFromStrings;\n\n  if (browser_env_ == BrowserEnvironment::kBrowser ||\n      browser_env_ == BrowserEnvironment::kUtility) {\n    // Node.js requires that microtask checkpoints be explicitly invoked.\n    is.policy = v8::MicrotasksPolicy::kExplicit;\n  } else {\n    // Blink expects the microtasks policy to be kScoped, but Node.js expects it\n    // to be kExplicit. In the renderer, there can be many contexts within the\n    // same isolate, so we don't want to change the existing policy here, which\n    // could be either kExplicit or kScoped depending on whether we're executing\n    // from within a Node.js or a Blink entrypoint. Instead, the policy is\n    // toggled to kExplicit when entering Node.js through UvRunOnce.\n    is.policy = context->GetIsolate()->GetMicrotasksPolicy();\n\n    // We do not want to use Node.js' message listener as it interferes with\n    // Blink's.\n    is.flags &= ~node::IsolateSettingsFlags::MESSAGE_LISTENER_WITH_ERROR_LEVEL;\n\n    // Isolate message listeners are additive (you can add multiple), so instead\n    // we add an extra one here to ensure that the async hook stack is properly\n    // cleared when errors are thrown.\n    context->GetIsolate()->AddMessageListenerWithErrorLevel(\n        ErrorMessageListener, v8::Isolate::kMessageError);\n\n    // We do not want to use the promise rejection callback that Node.js uses,\n    // because it does not send PromiseRejectionEvents to the global script\n    // context. We need to use the one Blink already provides.\n    is.flags |=\n        node::IsolateSettingsFlags::SHOULD_NOT_SET_PROMISE_REJECTION_CALLBACK;\n\n    // We do not want to use the stack trace callback that Node.js uses,\n    // because it relies on Node.js being aware of the current Context and\n    // that's not always the case. We need to use the one Blink already\n    // provides.\n    is.flags |=\n        node::IsolateSettingsFlags::SHOULD_NOT_SET_PREPARE_STACK_TRACE_CALLBACK;\n  }\n\n  node::SetIsolateUpForNode(context->GetIsolate(), is);\n  context->GetIsolate()->SetHostImportModuleDynamicallyCallback(\n      HostImportModuleDynamically);\n  context->GetIsolate()->SetHostInitializeImportMetaObjectCallback(\n      HostInitializeImportMetaObject);\n\n  gin_helper::Dictionary process(context->GetIsolate(), env->process_object());\n  process.SetReadOnly(\"type\", process_type);\n  process.Set(\"resourcesPath\", resources_path);\n  // The path to helper app.\n  base::FilePath helper_exec_path;\n  base::PathService::Get(content::CHILD_PROCESS_EXE, &helper_exec_path);\n  process.Set(\"helperExecPath\", helper_exec_path);\n\n  if (browser_env_ == BrowserEnvironment::kBrowser ||\n      browser_env_ == BrowserEnvironment::kRenderer) {\n    if (on_app_code_ready) {\n      process.SetMethod(\"appCodeLoaded\", std::move(*on_app_code_ready));\n    } else {\n      process.SetMethod(\"appCodeLoaded\",\n                        base::BindRepeating(&NodeBindings::SetAppCodeLoaded,\n                                            base::Unretained(this)));\n    }\n  }\n\n  auto env_deleter = [isolate, isolate_data,\n                      context = v8::Global<v8::Context>{isolate, context}](\n                         node::Environment* nenv) mutable {\n    // When `isolate_data` was created above, a pointer to it was kept\n    // in context's embedder_data[kElectronContextEmbedderDataIndex].\n    // Since we're about to free `isolate_data`, clear that entry\n    v8::HandleScope handle_scope{isolate};\n    context.Get(isolate)->SetAlignedPointerInEmbedderData(\n        kElectronContextEmbedderDataIndex, nullptr);\n    context.Reset();\n\n    node::FreeEnvironment(nenv);\n    node::FreeIsolateData(isolate_data);\n  };\n\n  return {env, std::move(env_deleter)};\n}",
  "abstract_func_before": "std::shared_ptr<node::Environment> NodeBindings::CreateEnvironment(\n    v8::Handle<v8::Context> VAR_0,\n    node::MultiIsolatePlatform* VAR_1,\n    std::vector<std::string> VAR_2,\n    std::vector<std::string> VAR_3,\n    absl::optional<base::RepeatingCallback<void()>> VAR_4) {\n  /* COMMENT_0 */\n  std::string VAR_5;\n  switch (VAR_6) {\n    case BrowserEnvironment::kBrowser:\n      VAR_5 = \"browser\";\n      break;\n    case BrowserEnvironment::kRenderer:\n      VAR_5 = \"renderer\";\n      break;\n    case BrowserEnvironment::kWorker:\n      VAR_5 = \"worker\";\n      break;\n    case BrowserEnvironment::kUtility:\n      VAR_5 = \"utility\";\n      break;\n  }\n\n  v8::Isolate* VAR_7 = VAR_0->GetIsolate();\n  gin_helper::Dictionary VAR_8(VAR_7, VAR_0->Global());\n\n  if (VAR_6 == BrowserEnvironment::kBrowser) {\n    const std::vector<std::string> VAR_9 = {\"app.asar\", \"app\",\n                                                   \"default_app.asar\"};\n    const std::vector<std::string> VAR_10 = {\"app.asar\"};\n    VAR_0->Global()->SetPrivate(\n        VAR_0,\n        v8::Private::ForApi(\n            VAR_7,\n            gin::ConvertToV8(VAR_7, \"appSearchPaths\").As<v8::String>()),\n        gin::ConvertToV8(VAR_7,\n                         electron::fuses::IsOnlyLoadAppFromAsarEnabled()\n                             ? VAR_10\n                             : VAR_9));\n  }\n\n  base::FilePath VAR_11 = GetResourcesPath();\n  std::string VAR_12 = \"electron/js2c/\" + VAR_5 + \"_init\";\n\n  VAR_2.insert(VAR_2.begin() + 1, VAR_12);\n\n  auto* VAR_13 = node::CreateIsolateData(VAR_7, VAR_14, VAR_1);\n  VAR_0->SetAlignedPointerInEmbedderData(VAR_15,\n                                           VAR_16<void*>(VAR_13));\n\n  node::Environment* VAR_17;\n  uint64_t VAR_18 = node::EnvironmentFlags::kDefaultFlags |\n                   node::EnvironmentFlags::kHideConsoleWindows |\n                   node::EnvironmentFlags::kNoGlobalSearchPaths |\n                   node::EnvironmentFlags::kNoRegisterESMLoader;\n\n  if (VAR_6 == BrowserEnvironment::kRenderer ||\n      VAR_6 == BrowserEnvironment::kWorker) {\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n    /* COMMENT_3 */\n    /* COMMENT_4 */\n    /* COMMENT_5 */\n    /* COMMENT_6 */\n    /* COMMENT_7 */\n    /* COMMENT_8 */\n    VAR_18 |= node::EnvironmentFlags::kNoBrowserGlobals |\n             node::EnvironmentFlags::kNoCreateInspector;\n  }\n\n  if (!electron::fuses::IsNodeCliInspectEnabled()) {\n    /* COMMENT_9 */\n    /* COMMENT_10 */\n    VAR_18 |= node::EnvironmentFlags::kNoStartDebugSignalHandler;\n  }\n\n  {\n    v8::TryCatch try_catch(isolate);\n    VAR_17 = node::CreateEnvironment(\n        VAR_16<node::IsolateData*>(VAR_13), VAR_0, VAR_2, VAR_3,\n        VAR_16<node::EnvironmentFlags::Flags>(VAR_18));\n\n    if (VAR_19.HasCaught()) {\n      std::string VAR_20 =\n          \"Failed to initialize node environment in process: \" + VAR_5;\n      v8::Local<v8::Message> VAR_21 = VAR_19.Message();\n      std::string VAR_22;\n      if (!VAR_21.IsEmpty() &&\n          gin::ConvertFromV8(isolate, VAR_21->Get(), &VAR_22))\n        VAR_20 += \" , with error: \" + VAR_22;\n      LOG(VAR_23) << VAR_20;\n    }\n  }\n\n  DCHECK(VAR_17);\n\n  node::IsolateSettings VAR_24;\n\n  /* COMMENT_11 */\n  /* COMMENT_12 */\n  VAR_24.fatal_error_callback = VAR_25;\n\n  /* COMMENT_13 */\n  /* COMMENT_14 */\n  /* COMMENT_15 */\n  /* COMMENT_16 */\n  /* COMMENT_17 */\n  if (VAR_6 != BrowserEnvironment::kUtility) {\n    VAR_24.should_abort_on_uncaught_exception_callback = [](v8::Isolate*) {\n      return false;\n    };\n  }\n\n  /* COMMENT_18 */\n  /* COMMENT_19 */\n  VAR_24.allow_wasm_code_generation_callback = VAR_26;\n  VAR_24.flags |= node::IsolateSettingsFlags::\n      ALLOW_MODIFY_CODE_GENERATION_FROM_STRINGS_CALLBACK;\n  VAR_24.modify_code_generation_from_strings_callback =\n      VAR_27;\n\n  if (VAR_6 == BrowserEnvironment::kBrowser ||\n      VAR_6 == BrowserEnvironment::kUtility) {\n    /* COMMENT_20 */\n    VAR_24.policy = v8::MicrotasksPolicy::kExplicit;\n  } else {\n    /* COMMENT_21 */\n    /* COMMENT_22 */\n    /* COMMENT_23 */\n    /* COMMENT_24 */\n    /* COMMENT_25 */\n    /* COMMENT_26 */\n    VAR_24.policy = VAR_0->GetIsolate()->GetMicrotasksPolicy();\n\n    /* COMMENT_27 */\n    /* COMMENT_28 */\n    VAR_24.flags &= ~node::IsolateSettingsFlags::MESSAGE_LISTENER_WITH_ERROR_LEVEL;\n\n    /* COMMENT_29 */\n    /* COMMENT_30 */\n    /* COMMENT_31 */\n    VAR_0->GetIsolate()->AddMessageListenerWithErrorLevel(\n        VAR_28, v8::Isolate::kMessageError);\n\n    /* COMMENT_32 */\n    /* COMMENT_33 */\n    /* COMMENT_34 */\n    VAR_24.flags |=\n        node::IsolateSettingsFlags::SHOULD_NOT_SET_PROMISE_REJECTION_CALLBACK;\n\n    /* COMMENT_35 */\n    /* COMMENT_36 */\n    /* COMMENT_37 */\n    /* COMMENT_38 */\n    VAR_24.flags |=\n        node::IsolateSettingsFlags::SHOULD_NOT_SET_PREPARE_STACK_TRACE_CALLBACK;\n  }\n\n  node::SetIsolateUpForNode(VAR_0->GetIsolate(), VAR_24);\n  VAR_0->GetIsolate()->SetHostImportModuleDynamicallyCallback(\n      VAR_29);\n  VAR_0->GetIsolate()->SetHostInitializeImportMetaObjectCallback(\n      VAR_30);\n\n  gin_helper::Dictionary VAR_31(VAR_0->GetIsolate(), VAR_17->process_object());\n  VAR_31.SetReadOnly(\"type\", VAR_5);\n  VAR_31.Set(\"resourcesPath\", VAR_11);\n  /* COMMENT_39 */\n  base::FilePath VAR_32;\n  base::PathService::Get(content::CHILD_PROCESS_EXE, &VAR_32);\n  VAR_31.Set(\"helperExecPath\", VAR_32);\n\n  if (VAR_6 == BrowserEnvironment::kBrowser ||\n      VAR_6 == BrowserEnvironment::kRenderer) {\n    if (VAR_4) {\n      VAR_31.SetMethod(\"appCodeLoaded\", std::move(*VAR_4));\n    } else {\n      VAR_31.SetMethod(\"appCodeLoaded\",\n                        base::BindRepeating(&NodeBindings::SetAppCodeLoaded,\n                                            base::Unretained(this)));\n    }\n  }\n\n  auto VAR_33 = [isolate, VAR_13,\n                      VAR_0 = v8::Global<v8::Context>{isolate, VAR_0}](\n                         node::Environment* VAR_34) mutable {\n    /* COMMENT_40 */\n    /* COMMENT_41 */\n    /* COMMENT_42 */\n    v8::HandleScope VAR_35{isolate};\n    VAR_0.Get(isolate)->SetAlignedPointerInEmbedderData(\n        VAR_15, nullptr);\n    VAR_0.Reset();\n\n    node::FreeEnvironment(VAR_34);\n    node::FreeIsolateData(VAR_13);\n  };\n\n  return {VAR_17, std::move(VAR_33)};\n}",
  "func_graph_path_before": "electron/342cf186d98eee64a68382bc74382b2e6745eb61/node_bindings.cc/vul/before/0.json",
  "func": "std::shared_ptr<node::Environment> NodeBindings::CreateEnvironment(\n    v8::Handle<v8::Context> context,\n    node::MultiIsolatePlatform* platform,\n    std::vector<std::string> args,\n    std::vector<std::string> exec_args,\n    absl::optional<base::RepeatingCallback<void()>> on_app_code_ready) {\n  // Feed node the path to initialization script.\n  std::string process_type;\n  switch (browser_env_) {\n    case BrowserEnvironment::kBrowser:\n      process_type = \"browser\";\n      break;\n    case BrowserEnvironment::kRenderer:\n      process_type = \"renderer\";\n      break;\n    case BrowserEnvironment::kWorker:\n      process_type = \"worker\";\n      break;\n    case BrowserEnvironment::kUtility:\n      process_type = \"utility\";\n      break;\n  }\n\n  v8::Isolate* isolate = context->GetIsolate();\n  gin_helper::Dictionary global(isolate, context->Global());\n\n  if (browser_env_ == BrowserEnvironment::kBrowser) {\n    const std::vector<std::string> search_paths = {\"app.asar\", \"app\",\n                                                   \"default_app.asar\"};\n    const std::vector<std::string> app_asar_search_paths = {\"app.asar\"};\n    context->Global()->SetPrivate(\n        context,\n        v8::Private::ForApi(\n            isolate,\n            gin::ConvertToV8(isolate, \"appSearchPaths\").As<v8::String>()),\n        gin::ConvertToV8(isolate,\n                         electron::fuses::IsOnlyLoadAppFromAsarEnabled()\n                             ? app_asar_search_paths\n                             : search_paths));\n    context->Global()->SetPrivate(\n        context,\n        v8::Private::ForApi(\n            isolate, gin::ConvertToV8(isolate, \"appSearchPathsOnlyLoadASAR\")\n                         .As<v8::String>()),\n        gin::ConvertToV8(isolate,\n                         electron::fuses::IsOnlyLoadAppFromAsarEnabled()));\n  }\n\n  base::FilePath resources_path = GetResourcesPath();\n  std::string init_script = \"electron/js2c/\" + process_type + \"_init\";\n\n  args.insert(args.begin() + 1, init_script);\n\n  auto* isolate_data = node::CreateIsolateData(isolate, uv_loop_, platform);\n  context->SetAlignedPointerInEmbedderData(kElectronContextEmbedderDataIndex,\n                                           static_cast<void*>(isolate_data));\n\n  node::Environment* env;\n  uint64_t flags = node::EnvironmentFlags::kDefaultFlags |\n                   node::EnvironmentFlags::kHideConsoleWindows |\n                   node::EnvironmentFlags::kNoGlobalSearchPaths |\n                   node::EnvironmentFlags::kNoRegisterESMLoader;\n\n  if (browser_env_ == BrowserEnvironment::kRenderer ||\n      browser_env_ == BrowserEnvironment::kWorker) {\n    // Only one ESM loader can be registered per isolate -\n    // in renderer processes this should be blink. We need to tell Node.js\n    // not to register its handler (overriding blinks) in non-browser processes.\n    // We also avoid overriding globals like setImmediate, clearImmediate\n    // queueMicrotask etc during the bootstrap phase of Node.js\n    // for processes that already have these defined by DOM.\n    // Check //third_party/electron_node/lib/internal/bootstrap/node.js\n    // for the list of overrides on globalThis.\n    flags |= node::EnvironmentFlags::kNoBrowserGlobals |\n             node::EnvironmentFlags::kNoCreateInspector;\n  }\n\n  if (!electron::fuses::IsNodeCliInspectEnabled()) {\n    // If --inspect and friends are disabled we also shouldn't listen for\n    // SIGUSR1\n    flags |= node::EnvironmentFlags::kNoStartDebugSignalHandler;\n  }\n\n  {\n    v8::TryCatch try_catch(isolate);\n    env = node::CreateEnvironment(\n        static_cast<node::IsolateData*>(isolate_data), context, args, exec_args,\n        static_cast<node::EnvironmentFlags::Flags>(flags));\n\n    if (try_catch.HasCaught()) {\n      std::string err_msg =\n          \"Failed to initialize node environment in process: \" + process_type;\n      v8::Local<v8::Message> message = try_catch.Message();\n      std::string msg;\n      if (!message.IsEmpty() &&\n          gin::ConvertFromV8(isolate, message->Get(), &msg))\n        err_msg += \" , with error: \" + msg;\n      LOG(ERROR) << err_msg;\n    }\n  }\n\n  DCHECK(env);\n\n  node::IsolateSettings is;\n\n  // Use a custom fatal error callback to allow us to add\n  // crash message and location to CrashReports.\n  is.fatal_error_callback = V8FatalErrorCallback;\n\n  // We don't want to abort either in the renderer or browser processes.\n  // We already listen for uncaught exceptions and handle them there.\n  // For utility process we expect the process to behave as standard\n  // Node.js runtime and abort the process with appropriate exit\n  // code depending on a handler being set for `uncaughtException` event.\n  if (browser_env_ != BrowserEnvironment::kUtility) {\n    is.should_abort_on_uncaught_exception_callback = [](v8::Isolate*) {\n      return false;\n    };\n  }\n\n  // Use a custom callback here to allow us to leverage Blink's logic in the\n  // renderer process.\n  is.allow_wasm_code_generation_callback = AllowWasmCodeGenerationCallback;\n  is.flags |= node::IsolateSettingsFlags::\n      ALLOW_MODIFY_CODE_GENERATION_FROM_STRINGS_CALLBACK;\n  is.modify_code_generation_from_strings_callback =\n      ModifyCodeGenerationFromStrings;\n\n  if (browser_env_ == BrowserEnvironment::kBrowser ||\n      browser_env_ == BrowserEnvironment::kUtility) {\n    // Node.js requires that microtask checkpoints be explicitly invoked.\n    is.policy = v8::MicrotasksPolicy::kExplicit;\n  } else {\n    // Blink expects the microtasks policy to be kScoped, but Node.js expects it\n    // to be kExplicit. In the renderer, there can be many contexts within the\n    // same isolate, so we don't want to change the existing policy here, which\n    // could be either kExplicit or kScoped depending on whether we're executing\n    // from within a Node.js or a Blink entrypoint. Instead, the policy is\n    // toggled to kExplicit when entering Node.js through UvRunOnce.\n    is.policy = context->GetIsolate()->GetMicrotasksPolicy();\n\n    // We do not want to use Node.js' message listener as it interferes with\n    // Blink's.\n    is.flags &= ~node::IsolateSettingsFlags::MESSAGE_LISTENER_WITH_ERROR_LEVEL;\n\n    // Isolate message listeners are additive (you can add multiple), so instead\n    // we add an extra one here to ensure that the async hook stack is properly\n    // cleared when errors are thrown.\n    context->GetIsolate()->AddMessageListenerWithErrorLevel(\n        ErrorMessageListener, v8::Isolate::kMessageError);\n\n    // We do not want to use the promise rejection callback that Node.js uses,\n    // because it does not send PromiseRejectionEvents to the global script\n    // context. We need to use the one Blink already provides.\n    is.flags |=\n        node::IsolateSettingsFlags::SHOULD_NOT_SET_PROMISE_REJECTION_CALLBACK;\n\n    // We do not want to use the stack trace callback that Node.js uses,\n    // because it relies on Node.js being aware of the current Context and\n    // that's not always the case. We need to use the one Blink already\n    // provides.\n    is.flags |=\n        node::IsolateSettingsFlags::SHOULD_NOT_SET_PREPARE_STACK_TRACE_CALLBACK;\n  }\n\n  node::SetIsolateUpForNode(context->GetIsolate(), is);\n  context->GetIsolate()->SetHostImportModuleDynamicallyCallback(\n      HostImportModuleDynamically);\n  context->GetIsolate()->SetHostInitializeImportMetaObjectCallback(\n      HostInitializeImportMetaObject);\n\n  gin_helper::Dictionary process(context->GetIsolate(), env->process_object());\n  process.SetReadOnly(\"type\", process_type);\n  process.Set(\"resourcesPath\", resources_path);\n  // The path to helper app.\n  base::FilePath helper_exec_path;\n  base::PathService::Get(content::CHILD_PROCESS_EXE, &helper_exec_path);\n  process.Set(\"helperExecPath\", helper_exec_path);\n\n  if (browser_env_ == BrowserEnvironment::kBrowser ||\n      browser_env_ == BrowserEnvironment::kRenderer) {\n    if (on_app_code_ready) {\n      process.SetMethod(\"appCodeLoaded\", std::move(*on_app_code_ready));\n    } else {\n      process.SetMethod(\"appCodeLoaded\",\n                        base::BindRepeating(&NodeBindings::SetAppCodeLoaded,\n                                            base::Unretained(this)));\n    }\n  }\n\n  auto env_deleter = [isolate, isolate_data,\n                      context = v8::Global<v8::Context>{isolate, context}](\n                         node::Environment* nenv) mutable {\n    // When `isolate_data` was created above, a pointer to it was kept\n    // in context's embedder_data[kElectronContextEmbedderDataIndex].\n    // Since we're about to free `isolate_data`, clear that entry\n    v8::HandleScope handle_scope{isolate};\n    context.Get(isolate)->SetAlignedPointerInEmbedderData(\n        kElectronContextEmbedderDataIndex, nullptr);\n    context.Reset();\n\n    node::FreeEnvironment(nenv);\n    node::FreeIsolateData(isolate_data);\n  };\n\n  return {env, std::move(env_deleter)};\n}",
  "abstract_func": "std::shared_ptr<node::Environment> NodeBindings::CreateEnvironment(\n    v8::Handle<v8::Context> VAR_0,\n    node::MultiIsolatePlatform* VAR_1,\n    std::vector<std::string> VAR_2,\n    std::vector<std::string> VAR_3,\n    absl::optional<base::RepeatingCallback<void()>> VAR_4) {\n  /* COMMENT_0 */\n  std::string VAR_5;\n  switch (VAR_6) {\n    case BrowserEnvironment::kBrowser:\n      VAR_5 = \"browser\";\n      break;\n    case BrowserEnvironment::kRenderer:\n      VAR_5 = \"renderer\";\n      break;\n    case BrowserEnvironment::kWorker:\n      VAR_5 = \"worker\";\n      break;\n    case BrowserEnvironment::kUtility:\n      VAR_5 = \"utility\";\n      break;\n  }\n\n  v8::Isolate* VAR_7 = VAR_0->GetIsolate();\n  gin_helper::Dictionary VAR_8(VAR_7, VAR_0->Global());\n\n  if (VAR_6 == BrowserEnvironment::kBrowser) {\n    const std::vector<std::string> VAR_9 = {\"app.asar\", \"app\",\n                                                   \"default_app.asar\"};\n    const std::vector<std::string> VAR_10 = {\"app.asar\"};\n    VAR_0->Global()->SetPrivate(\n        VAR_0,\n        v8::Private::ForApi(\n            VAR_7,\n            gin::ConvertToV8(VAR_7, \"appSearchPaths\").As<v8::String>()),\n        gin::ConvertToV8(VAR_7,\n                         electron::fuses::IsOnlyLoadAppFromAsarEnabled()\n                             ? VAR_10\n                             : VAR_9));\n    VAR_0->Global()->SetPrivate(\n        VAR_0,\n        v8::Private::ForApi(\n            VAR_7, gin::ConvertToV8(VAR_7, \"appSearchPathsOnlyLoadASAR\")\n                         .As<v8::String>()),\n        gin::ConvertToV8(VAR_7,\n                         electron::fuses::IsOnlyLoadAppFromAsarEnabled()));\n  }\n\n  base::FilePath VAR_11 = GetResourcesPath();\n  std::string VAR_12 = \"electron/js2c/\" + VAR_5 + \"_init\";\n\n  VAR_2.insert(VAR_2.begin() + 1, VAR_12);\n\n  auto* VAR_13 = node::CreateIsolateData(VAR_7, VAR_14, VAR_1);\n  VAR_0->SetAlignedPointerInEmbedderData(VAR_15,\n                                           VAR_16<void*>(VAR_13));\n\n  node::Environment* VAR_17;\n  uint64_t VAR_18 = node::EnvironmentFlags::kDefaultFlags |\n                   node::EnvironmentFlags::kHideConsoleWindows |\n                   node::EnvironmentFlags::kNoGlobalSearchPaths |\n                   node::EnvironmentFlags::kNoRegisterESMLoader;\n\n  if (VAR_6 == BrowserEnvironment::kRenderer ||\n      VAR_6 == BrowserEnvironment::kWorker) {\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n    /* COMMENT_3 */\n    /* COMMENT_4 */\n    /* COMMENT_5 */\n    /* COMMENT_6 */\n    /* COMMENT_7 */\n    /* COMMENT_8 */\n    VAR_18 |= node::EnvironmentFlags::kNoBrowserGlobals |\n             node::EnvironmentFlags::kNoCreateInspector;\n  }\n\n  if (!electron::fuses::IsNodeCliInspectEnabled()) {\n    /* COMMENT_9 */\n    /* COMMENT_10 */\n    VAR_18 |= node::EnvironmentFlags::kNoStartDebugSignalHandler;\n  }\n\n  {\n    v8::TryCatch try_catch(isolate);\n    VAR_17 = node::CreateEnvironment(\n        VAR_16<node::IsolateData*>(VAR_13), VAR_0, VAR_2, VAR_3,\n        VAR_16<node::EnvironmentFlags::Flags>(VAR_18));\n\n    if (VAR_19.HasCaught()) {\n      std::string VAR_20 =\n          \"Failed to initialize node environment in process: \" + VAR_5;\n      v8::Local<v8::Message> VAR_21 = VAR_19.Message();\n      std::string VAR_22;\n      if (!VAR_21.IsEmpty() &&\n          gin::ConvertFromV8(isolate, VAR_21->Get(), &VAR_22))\n        VAR_20 += \" , with error: \" + VAR_22;\n      LOG(VAR_23) << VAR_20;\n    }\n  }\n\n  DCHECK(VAR_17);\n\n  node::IsolateSettings VAR_24;\n\n  /* COMMENT_11 */\n  /* COMMENT_12 */\n  VAR_24.fatal_error_callback = VAR_25;\n\n  /* COMMENT_13 */\n  /* COMMENT_14 */\n  /* COMMENT_15 */\n  /* COMMENT_16 */\n  /* COMMENT_17 */\n  if (VAR_6 != BrowserEnvironment::kUtility) {\n    VAR_24.should_abort_on_uncaught_exception_callback = [](v8::Isolate*) {\n      return false;\n    };\n  }\n\n  /* COMMENT_18 */\n  /* COMMENT_19 */\n  VAR_24.allow_wasm_code_generation_callback = VAR_26;\n  VAR_24.flags |= node::IsolateSettingsFlags::\n      ALLOW_MODIFY_CODE_GENERATION_FROM_STRINGS_CALLBACK;\n  VAR_24.modify_code_generation_from_strings_callback =\n      VAR_27;\n\n  if (VAR_6 == BrowserEnvironment::kBrowser ||\n      VAR_6 == BrowserEnvironment::kUtility) {\n    /* COMMENT_20 */\n    VAR_24.policy = v8::MicrotasksPolicy::kExplicit;\n  } else {\n    /* COMMENT_21 */\n    /* COMMENT_22 */\n    /* COMMENT_23 */\n    /* COMMENT_24 */\n    /* COMMENT_25 */\n    /* COMMENT_26 */\n    VAR_24.policy = VAR_0->GetIsolate()->GetMicrotasksPolicy();\n\n    /* COMMENT_27 */\n    /* COMMENT_28 */\n    VAR_24.flags &= ~node::IsolateSettingsFlags::MESSAGE_LISTENER_WITH_ERROR_LEVEL;\n\n    /* COMMENT_29 */\n    /* COMMENT_30 */\n    /* COMMENT_31 */\n    VAR_0->GetIsolate()->AddMessageListenerWithErrorLevel(\n        VAR_28, v8::Isolate::kMessageError);\n\n    /* COMMENT_32 */\n    /* COMMENT_33 */\n    /* COMMENT_34 */\n    VAR_24.flags |=\n        node::IsolateSettingsFlags::SHOULD_NOT_SET_PROMISE_REJECTION_CALLBACK;\n\n    /* COMMENT_35 */\n    /* COMMENT_36 */\n    /* COMMENT_37 */\n    /* COMMENT_38 */\n    VAR_24.flags |=\n        node::IsolateSettingsFlags::SHOULD_NOT_SET_PREPARE_STACK_TRACE_CALLBACK;\n  }\n\n  node::SetIsolateUpForNode(VAR_0->GetIsolate(), VAR_24);\n  VAR_0->GetIsolate()->SetHostImportModuleDynamicallyCallback(\n      VAR_29);\n  VAR_0->GetIsolate()->SetHostInitializeImportMetaObjectCallback(\n      VAR_30);\n\n  gin_helper::Dictionary VAR_31(VAR_0->GetIsolate(), VAR_17->process_object());\n  VAR_31.SetReadOnly(\"type\", VAR_5);\n  VAR_31.Set(\"resourcesPath\", VAR_11);\n  /* COMMENT_39 */\n  base::FilePath VAR_32;\n  base::PathService::Get(content::CHILD_PROCESS_EXE, &VAR_32);\n  VAR_31.Set(\"helperExecPath\", VAR_32);\n\n  if (VAR_6 == BrowserEnvironment::kBrowser ||\n      VAR_6 == BrowserEnvironment::kRenderer) {\n    if (VAR_4) {\n      VAR_31.SetMethod(\"appCodeLoaded\", std::move(*VAR_4));\n    } else {\n      VAR_31.SetMethod(\"appCodeLoaded\",\n                        base::BindRepeating(&NodeBindings::SetAppCodeLoaded,\n                                            base::Unretained(this)));\n    }\n  }\n\n  auto VAR_33 = [isolate, VAR_13,\n                      VAR_0 = v8::Global<v8::Context>{isolate, VAR_0}](\n                         node::Environment* VAR_34) mutable {\n    /* COMMENT_40 */\n    /* COMMENT_41 */\n    /* COMMENT_42 */\n    v8::HandleScope VAR_35{isolate};\n    VAR_0.Get(isolate)->SetAlignedPointerInEmbedderData(\n        VAR_15, nullptr);\n    VAR_0.Reset();\n\n    node::FreeEnvironment(VAR_34);\n    node::FreeIsolateData(VAR_13);\n  };\n\n  return {VAR_17, std::move(VAR_33)};\n}",
  "func_graph_path": "electron/342cf186d98eee64a68382bc74382b2e6745eb61/node_bindings.cc/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -37,6 +37,13 @@\n                          electron::fuses::IsOnlyLoadAppFromAsarEnabled()\n                              ? app_asar_search_paths\n                              : search_paths));\n+    context->Global()->SetPrivate(\n+        context,\n+        v8::Private::ForApi(\n+            isolate, gin::ConvertToV8(isolate, \"appSearchPathsOnlyLoadASAR\")\n+                         .As<v8::String>()),\n+        gin::ConvertToV8(isolate,\n+                         electron::fuses::IsOnlyLoadAppFromAsarEnabled()));\n   }\n \n   base::FilePath resources_path = GetResourcesPath();",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "    context->Global()->SetPrivate(",
      "        context,",
      "        v8::Private::ForApi(",
      "            isolate, gin::ConvertToV8(isolate, \"appSearchPathsOnlyLoadASAR\")",
      "                         .As<v8::String>()),",
      "        gin::ConvertToV8(isolate,",
      "                         electron::fuses::IsOnlyLoadAppFromAsarEnabled()));"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/electron/electron/pull/39788",
  "description": {
    "pr_info": {
      "title": "fix: ensure app load is limited to real asar files when appropriate",
      "number": 39788
    },
    "comment": [
      "Just because something exists in a `*.asar` path doesn't mean it's actually an asar file.\r\n\r\nNotes: no-notes",
      "**No Release Notes**",
      "I have automatically backported this PR to \"27-x-y\",     please check out #39807",
      "I have automatically backported this PR to \"26-x-y\",     please check out #39808",
      "I have automatically backported this PR to \"25-x-y\",     please check out #39809",
      "I have automatically backported this PR to \"24-x-y\",     please check out #39810",
      "I have automatically backported this PR to \"22-x-y\",     please check out #39811",
      "Hi @MarshallOfSound! It seems like this PR wasn't backported to `23.x.y`.\r\n\r\nIn https://github.com/advisories/GHSA-7m48-wc93-9g85, we can see that it should have been published as `23.3.14`, but that version doesn't exist 🤔 "
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.9"
}