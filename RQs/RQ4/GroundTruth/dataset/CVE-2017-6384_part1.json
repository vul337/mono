{
  "cve_id": "CVE-2017-6384",
  "cwe_ids": [
    "CWE-772"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:C",
  "cvss_is_v3": false,
  "repo_name": "atheme",
  "commit_msg": "saslserv/main: free sasl_sourceinfo_t after use",
  "commit_hash": "a80355d2971f6453ef9c6c9507e8f0d16e55dd0f",
  "git_url": "https://github.com/atheme/atheme/commit/a80355d2971f6453ef9c6c9507e8f0d16e55dd0f",
  "file_path": "modules/saslserv/main.c",
  "func_name": "login_user",
  "func_before": "static myuser_t *login_user(sasl_session_t *p)\n{\n\tmyuser_t *source_mu, *target_mu;\n\thook_user_login_check_t req;\n\n\t/* source_mu is the user whose credentials we verified (\"authentication id\") */\n\t/* target_mu is the user who will be ultimately logged in (\"authorization id\") */\n\n\tsource_mu = myuser_find_by_nick(p->username);\n\tif(source_mu == NULL)\n\t\treturn NULL;\n\n\treq.si = sasl_sourceinfo_create(p);\n\treq.mu = source_mu;\n\treq.allowed = true;\n\thook_call_user_can_login(&req);\n\tif (!req.allowed)\n\t{\n\t\tsasl_logcommand(p, source_mu, CMDLOG_LOGIN, \"failed LOGIN to \\2%s\\2 (denied by hook)\", entity(source_mu)->name);\n\t\treturn NULL;\n\t}\n\n\tif(p->authzid && *p->authzid)\n\t{\n\t\ttarget_mu = myuser_find_by_nick(p->authzid);\n\t\tif(target_mu == NULL)\n\t\t\treturn NULL;\n\t}\n\telse\n\t{\n\t\ttarget_mu = source_mu;\n\t\tif(p->authzid != NULL)\n\t\t\tfree(p->authzid);\n\t\tp->authzid = sstrdup(p->username);\n\t}\n\n\tif(metadata_find(source_mu, \"private:freeze:freezer\"))\n\t{\n\t\tsasl_logcommand(p, source_mu, CMDLOG_LOGIN, \"failed LOGIN to \\2%s\\2 (frozen)\", entity(source_mu)->name);\n\t\treturn NULL;\n\t}\n\n\tif(target_mu != source_mu)\n\t{\n\t\tif(!may_impersonate(source_mu, target_mu))\n\t\t{\n\t\t\tsasl_logcommand(p, source_mu, CMDLOG_LOGIN, \"denied IMPERSONATE by \\2%s\\2 to \\2%s\\2\", entity(source_mu)->name, entity(target_mu)->name);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tsasl_logcommand(p, source_mu, CMDLOG_LOGIN, \"allowed IMPERSONATE by \\2%s\\2 to \\2%s\\2\", entity(source_mu)->name, entity(target_mu)->name);\n\n\t\treq.mu = target_mu;\n\t\treq.allowed = true;\n\t\thook_call_user_can_login(&req);\n\t\tif (!req.allowed)\n\t\t{\n\t\t\tsasl_logcommand(p, source_mu, CMDLOG_LOGIN, \"failed LOGIN to \\2%s\\2 (denied by hook)\", entity(target_mu)->name);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif(metadata_find(target_mu, \"private:freeze:freezer\"))\n\t\t{\n\t\t\tsasl_logcommand(p, target_mu, CMDLOG_LOGIN, \"failed LOGIN to \\2%s\\2 (frozen)\", entity(target_mu)->name);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif(MOWGLI_LIST_LENGTH(&target_mu->logins) >= me.maxlogins)\n\t{\n\t\tsasl_logcommand(p, target_mu, CMDLOG_LOGIN, \"failed LOGIN to \\2%s\\2 (too many logins)\", entity(target_mu)->name);\n\t\treturn NULL;\n\t}\n\n\t/* Log it with the full n!u@h later */\n\tp->flags |= ASASL_NEED_LOG;\n\n\t/* We just did SASL authentication for a user.  With IRCds which do not\n\t * have unique UIDs for users, we will likely be expecting the login\n\t * data to be bursted.  As a result, we should give the core a heads'\n\t * up that this is going to happen so that hooks will be properly\n\t * fired...\n\t */\n\tif(ircd->flags & IRCD_SASL_USE_PUID)\n\t{\n\t\ttarget_mu->flags &= ~MU_NOBURSTLOGIN;\n\t\ttarget_mu->flags |= MU_PENDINGLOGIN;\n\t}\n\n\treturn target_mu;\n}",
  "abstract_func_before": "static myuser_t *login_user(sasl_session_t *VAR_0)\n{\n\tmyuser_t *VAR_1, *VAR_2;\n\thook_user_login_check_t VAR_3;\n\n\t/* COMMENT_0 */\n\t/* COMMENT_1 */\n\n\tVAR_1 = myuser_find_by_nick(VAR_0->username);\n\tif(VAR_1 == NULL)\n\t\treturn NULL;\n\n\tVAR_3.si = sasl_sourceinfo_create(VAR_0);\n\tVAR_3.mu = VAR_1;\n\tVAR_3.allowed = true;\n\thook_call_user_can_login(&VAR_3);\n\tif (!VAR_3.allowed)\n\t{\n\t\tsasl_logcommand(VAR_0, VAR_1, VAR_4, \"failed LOGIN to \\2%s\\2 (denied by hook)\", entity(VAR_1)->name);\n\t\treturn NULL;\n\t}\n\n\tif(VAR_0->authzid && *VAR_0->authzid)\n\t{\n\t\tVAR_2 = myuser_find_by_nick(VAR_0->authzid);\n\t\tif(VAR_2 == NULL)\n\t\t\treturn NULL;\n\t}\n\telse\n\t{\n\t\tVAR_2 = VAR_1;\n\t\tif(VAR_0->authzid != NULL)\n\t\t\tfree(VAR_0->authzid);\n\t\tVAR_0->authzid = sstrdup(VAR_0->username);\n\t}\n\n\tif(metadata_find(VAR_1, \"private:freeze:freezer\"))\n\t{\n\t\tsasl_logcommand(VAR_0, VAR_1, VAR_4, \"failed LOGIN to \\2%s\\2 (frozen)\", entity(VAR_1)->name);\n\t\treturn NULL;\n\t}\n\n\tif(VAR_2 != VAR_1)\n\t{\n\t\tif(!may_impersonate(VAR_1, VAR_2))\n\t\t{\n\t\t\tsasl_logcommand(VAR_0, VAR_1, VAR_4, \"denied IMPERSONATE by \\2%s\\2 to \\2%s\\2\", entity(VAR_1)->name, entity(VAR_2)->name);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tsasl_logcommand(VAR_0, VAR_1, VAR_4, \"allowed IMPERSONATE by \\2%s\\2 to \\2%s\\2\", entity(VAR_1)->name, entity(VAR_2)->name);\n\n\t\tVAR_3.mu = VAR_2;\n\t\tVAR_3.allowed = true;\n\t\thook_call_user_can_login(&VAR_3);\n\t\tif (!VAR_3.allowed)\n\t\t{\n\t\t\tsasl_logcommand(VAR_0, VAR_1, VAR_4, \"failed LOGIN to \\2%s\\2 (denied by hook)\", entity(VAR_2)->name);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif(metadata_find(VAR_2, \"private:freeze:freezer\"))\n\t\t{\n\t\t\tsasl_logcommand(VAR_0, VAR_2, VAR_4, \"failed LOGIN to \\2%s\\2 (frozen)\", entity(VAR_2)->name);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif(MOWGLI_LIST_LENGTH(&VAR_2->logins) >= VAR_5.maxlogins)\n\t{\n\t\tsasl_logcommand(VAR_0, VAR_2, VAR_4, \"failed LOGIN to \\2%s\\2 (too many logins)\", entity(VAR_2)->name);\n\t\treturn NULL;\n\t}\n\n\t/* COMMENT_2 */\n\tVAR_0->flags |= VAR_6;\n\n\t/* COMMENT_3 */\n                                                                     \n                                                                      \n                                                                  \n            \n    \n\tif(VAR_7->flags & VAR_8)\n\t{\n\t\tVAR_2->flags &= ~VAR_9;\n\t\tVAR_2->flags |= VAR_10;\n\t}\n\n\treturn VAR_2;\n}",
  "func_graph_path_before": "atheme/a80355d2971f6453ef9c6c9507e8f0d16e55dd0f/main.c/vul/before/0.json",
  "func": "static myuser_t *login_user(sasl_session_t *p)\n{\n\tmyuser_t *source_mu, *target_mu;\n\thook_user_login_check_t req;\n\n\t/* source_mu is the user whose credentials we verified (\"authentication id\") */\n\t/* target_mu is the user who will be ultimately logged in (\"authorization id\") */\n\n\tsource_mu = myuser_find_by_nick(p->username);\n\tif(source_mu == NULL)\n\t\treturn NULL;\n\n\treq.si = sasl_sourceinfo_create(p);\n\treq.mu = source_mu;\n\treq.allowed = true;\n\thook_call_user_can_login(&req);\n\tobject_unref(req.si);\n\tif (!req.allowed)\n\t{\n\t\tsasl_logcommand(p, source_mu, CMDLOG_LOGIN, \"failed LOGIN to \\2%s\\2 (denied by hook)\", entity(source_mu)->name);\n\t\treturn NULL;\n\t}\n\n\tif(p->authzid && *p->authzid)\n\t{\n\t\ttarget_mu = myuser_find_by_nick(p->authzid);\n\t\tif(target_mu == NULL)\n\t\t\treturn NULL;\n\t}\n\telse\n\t{\n\t\ttarget_mu = source_mu;\n\t\tif(p->authzid != NULL)\n\t\t\tfree(p->authzid);\n\t\tp->authzid = sstrdup(p->username);\n\t}\n\n\tif(metadata_find(source_mu, \"private:freeze:freezer\"))\n\t{\n\t\tsasl_logcommand(p, source_mu, CMDLOG_LOGIN, \"failed LOGIN to \\2%s\\2 (frozen)\", entity(source_mu)->name);\n\t\treturn NULL;\n\t}\n\n\tif(target_mu != source_mu)\n\t{\n\t\tif(!may_impersonate(source_mu, target_mu))\n\t\t{\n\t\t\tsasl_logcommand(p, source_mu, CMDLOG_LOGIN, \"denied IMPERSONATE by \\2%s\\2 to \\2%s\\2\", entity(source_mu)->name, entity(target_mu)->name);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tsasl_logcommand(p, source_mu, CMDLOG_LOGIN, \"allowed IMPERSONATE by \\2%s\\2 to \\2%s\\2\", entity(source_mu)->name, entity(target_mu)->name);\n\n\t\treq.mu = target_mu;\n\t\treq.allowed = true;\n\t\thook_call_user_can_login(&req);\n\t\tif (!req.allowed)\n\t\t{\n\t\t\tsasl_logcommand(p, source_mu, CMDLOG_LOGIN, \"failed LOGIN to \\2%s\\2 (denied by hook)\", entity(target_mu)->name);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif(metadata_find(target_mu, \"private:freeze:freezer\"))\n\t\t{\n\t\t\tsasl_logcommand(p, target_mu, CMDLOG_LOGIN, \"failed LOGIN to \\2%s\\2 (frozen)\", entity(target_mu)->name);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif(MOWGLI_LIST_LENGTH(&target_mu->logins) >= me.maxlogins)\n\t{\n\t\tsasl_logcommand(p, target_mu, CMDLOG_LOGIN, \"failed LOGIN to \\2%s\\2 (too many logins)\", entity(target_mu)->name);\n\t\treturn NULL;\n\t}\n\n\t/* Log it with the full n!u@h later */\n\tp->flags |= ASASL_NEED_LOG;\n\n\t/* We just did SASL authentication for a user.  With IRCds which do not\n\t * have unique UIDs for users, we will likely be expecting the login\n\t * data to be bursted.  As a result, we should give the core a heads'\n\t * up that this is going to happen so that hooks will be properly\n\t * fired...\n\t */\n\tif(ircd->flags & IRCD_SASL_USE_PUID)\n\t{\n\t\ttarget_mu->flags &= ~MU_NOBURSTLOGIN;\n\t\ttarget_mu->flags |= MU_PENDINGLOGIN;\n\t}\n\n\treturn target_mu;\n}",
  "abstract_func": "static myuser_t *login_user(sasl_session_t *VAR_0)\n{\n\tmyuser_t *VAR_1, *VAR_2;\n\thook_user_login_check_t VAR_3;\n\n\t/* COMMENT_0 */\n\t/* COMMENT_1 */\n\n\tVAR_1 = myuser_find_by_nick(VAR_0->username);\n\tif(VAR_1 == NULL)\n\t\treturn NULL;\n\n\tVAR_3.si = sasl_sourceinfo_create(VAR_0);\n\tVAR_3.mu = VAR_1;\n\tVAR_3.allowed = true;\n\thook_call_user_can_login(&VAR_3);\n\tobject_unref(VAR_3.si);\n\tif (!VAR_3.allowed)\n\t{\n\t\tsasl_logcommand(VAR_0, VAR_1, VAR_4, \"failed LOGIN to \\2%s\\2 (denied by hook)\", entity(VAR_1)->name);\n\t\treturn NULL;\n\t}\n\n\tif(VAR_0->authzid && *VAR_0->authzid)\n\t{\n\t\tVAR_2 = myuser_find_by_nick(VAR_0->authzid);\n\t\tif(VAR_2 == NULL)\n\t\t\treturn NULL;\n\t}\n\telse\n\t{\n\t\tVAR_2 = VAR_1;\n\t\tif(VAR_0->authzid != NULL)\n\t\t\tfree(VAR_0->authzid);\n\t\tVAR_0->authzid = sstrdup(VAR_0->username);\n\t}\n\n\tif(metadata_find(VAR_1, \"private:freeze:freezer\"))\n\t{\n\t\tsasl_logcommand(VAR_0, VAR_1, VAR_4, \"failed LOGIN to \\2%s\\2 (frozen)\", entity(VAR_1)->name);\n\t\treturn NULL;\n\t}\n\n\tif(VAR_2 != VAR_1)\n\t{\n\t\tif(!may_impersonate(VAR_1, VAR_2))\n\t\t{\n\t\t\tsasl_logcommand(VAR_0, VAR_1, VAR_4, \"denied IMPERSONATE by \\2%s\\2 to \\2%s\\2\", entity(VAR_1)->name, entity(VAR_2)->name);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tsasl_logcommand(VAR_0, VAR_1, VAR_4, \"allowed IMPERSONATE by \\2%s\\2 to \\2%s\\2\", entity(VAR_1)->name, entity(VAR_2)->name);\n\n\t\tVAR_3.mu = VAR_2;\n\t\tVAR_3.allowed = true;\n\t\thook_call_user_can_login(&VAR_3);\n\t\tif (!VAR_3.allowed)\n\t\t{\n\t\t\tsasl_logcommand(VAR_0, VAR_1, VAR_4, \"failed LOGIN to \\2%s\\2 (denied by hook)\", entity(VAR_2)->name);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif(metadata_find(VAR_2, \"private:freeze:freezer\"))\n\t\t{\n\t\t\tsasl_logcommand(VAR_0, VAR_2, VAR_4, \"failed LOGIN to \\2%s\\2 (frozen)\", entity(VAR_2)->name);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif(MOWGLI_LIST_LENGTH(&VAR_2->logins) >= VAR_5.maxlogins)\n\t{\n\t\tsasl_logcommand(VAR_0, VAR_2, VAR_4, \"failed LOGIN to \\2%s\\2 (too many logins)\", entity(VAR_2)->name);\n\t\treturn NULL;\n\t}\n\n\t/* COMMENT_2 */\n\tVAR_0->flags |= VAR_6;\n\n\t/* COMMENT_3 */\n                                                                     \n                                                                      \n                                                                  \n            \n    \n\tif(VAR_7->flags & VAR_8)\n\t{\n\t\tVAR_2->flags &= ~VAR_9;\n\t\tVAR_2->flags |= VAR_10;\n\t}\n\n\treturn VAR_2;\n}",
  "func_graph_path": "atheme/a80355d2971f6453ef9c6c9507e8f0d16e55dd0f/main.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -14,6 +14,7 @@\n \treq.mu = source_mu;\n \treq.allowed = true;\n \thook_call_user_can_login(&req);\n+\tobject_unref(req.si);\n \tif (!req.allowed)\n \t{\n \t\tsasl_logcommand(p, source_mu, CMDLOG_LOGIN, \"failed LOGIN to \\2%s\\2 (denied by hook)\", entity(source_mu)->name);",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "\tobject_unref(req.si);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/atheme/atheme/pull/539",
  "description": {
    "pr_info": {
      "title": "CVE-2017-6384: saslserv/main: free sasl_sourceinfo_t after use",
      "number": 539
    },
    "comment": [
      "```\r\n==9829== 136 bytes in 1 blocks are definitely lost in loss record 440 of 447\r\n==9829==    at 0x4C2CA40: calloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\r\n==9829==    by 0x52C109A: smalloc (memory.c:35)\r\n==9829==    by 0xC487B92: sasl_sourceinfo_create (main.c:274)\r\n==9829==    by 0xC4887F0: login_user (main.c:605)\r\n==9829==    by 0xC4887F0: sasl_packet.constprop.6 (main.c:467)\r\n==9829==    by 0xC488E6B: sasl_input (main.c:347)\r\n==9829==    by 0x52BE5AD: hook_call_event (hook.c:192)\r\n==9829==    by 0x6FDED40: m_encap.part.15 (ts6-generic.c:1304)\r\n==9829==    by 0x71E3CDA: irc_parse (parse.c:176)\r\n==9829==    by 0x52C31FD: irc_recvq_handler (packet.c:55)\r\n==9829==    by 0x52BB010: recvq_put (datastream.c:266)\r\n==9829==    by 0x5081762: mowgli_epoll_eventloop_select (epoll_pollops.c:188)\r\n==9829==    by 0x50823A3: mowgli_simple_eventloop_timeout_once (null_pollops.c:57)\r\n```",
      "was a CVE requested for this yet?",
      "Requested, yes",
      "On 2017-02-08 01:41:19, mniip wrote:\n> Requested, yes\n\ncan you let us know here when the CVE is issue?\n\nthanks!\n",
      "@mniip, @anarcat any news heard about the CVE assignment?",
      "@carnil didn't find or hear anything about this myself.",
      "Sorry, I got somewhat busy with life. Per amdj's advice I'll rerequest now."
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.9"
}