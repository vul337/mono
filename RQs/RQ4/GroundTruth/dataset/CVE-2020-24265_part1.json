{
  "cve_id": "CVE-2020-24265",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "appneta/tcpreplay",
  "commit_msg": "Bug #616 add checks for datalen for DLT_JUNIPER_ETHER\n\nAlso did some fixes to Juniper Ethernet protocols to fix some bugs\nand support various types of Juniper Ethernet protocol types. Used\nWireshark sources to figure out all the different packet types that\nJuniper uses.\n\nUnable to test all types because of lack of JNPER DLT pcaps.\n\nAlso applied a fix for DLT_RAW to prevent similar issues.",
  "commit_hash": "8323a7fe1e47d562ebf384aa99633e3df74a01c4",
  "git_url": "https://github.com/appneta/tcpreplay/commit/8323a7fe1e47d562ebf384aa99633e3df74a01c4",
  "file_path": "src/common/get.c",
  "func_name": "get_l2protocol",
  "func_before": "uint16_t\nget_l2protocol(const u_char *pktdata, const uint32_t datalen, const int datalink)\n{\n    uint16_t eth_hdr_offset = 0;\n\n    if (!pktdata || !datalen) {\n        errx(-1, \"invalid l2 parameters: pktdata=0x%p len=%d\",\n                pktdata, datalen);\n        return 0;\n    }\n\n    switch (datalink) {\n    case DLT_RAW:\n        if ((pktdata[0] >> 4) == 4)\n            return ETHERTYPE_IP;\n        else if ((pktdata[0] >> 4) == 6)\n            return ETHERTYPE_IP6;\n        break;\n\n    case DLT_JUNIPER_ETHER:\n        if (datalen < 5)\n            return 0;\n\n        if (memcmp(pktdata, \"MGC\", 3))\n            warnx(\"No Magic Number found: %s (0x%x)\",\n                 pcap_datalink_val_to_description(datalink), datalink);\n\n        if ((pktdata[3] & 0x80) == 0x80) {\n            eth_hdr_offset = ntohs(*((uint16_t*)&pktdata[4]));\n            eth_hdr_offset += 6;\n        } else {\n            eth_hdr_offset = 4; /* no header extensions */\n        }\n        /* fallthrough */\n    case DLT_EN10MB:\n        if ((size_t)datalen >= (sizeof(eth_hdr_t) + eth_hdr_offset)) {\n            eth_hdr_t *eth_hdr = (eth_hdr_t *)(pktdata + eth_hdr_offset);\n            uint16_t ether_type = ntohs(eth_hdr->ether_type);\n            uint16_t l2_len = sizeof(*eth_hdr) + eth_hdr_offset;\n            while (ether_type == ETHERTYPE_VLAN) {\n                if (datalen < l2_len + sizeof(vlan_hdr_t))\n                     return 0;\n\n                 vlan_hdr_t *vlan_hdr = (vlan_hdr_t*)(pktdata + l2_len);\n                 ether_type = ntohs(vlan_hdr->vlan_tpid);\n                 l2_len += sizeof(vlan_hdr_t);\n            }\n\n            return ether_type; /* yes, return it in host byte order */\n        }\n        break;\n\n    case DLT_PPP_SERIAL:\n        if ((size_t)datalen >= sizeof(struct tcpr_pppserial_hdr)) {\n            struct tcpr_pppserial_hdr *ppp = (struct tcpr_pppserial_hdr *)pktdata;\n            if (ntohs(ppp->protocol) == 0x0021)\n                return htons(ETHERTYPE_IP);\n            else\n                return ppp->protocol;\n        }\n        break;\n\n    case DLT_C_HDLC:\n        if ((size_t)datalen >= sizeof(hdlc_hdr_t)) {\n            hdlc_hdr_t *hdlc_hdr = (hdlc_hdr_t *)pktdata;\n            return hdlc_hdr->protocol;\n        }\n        break;\n\n    case DLT_LINUX_SLL:\n        if ((size_t)datalen >= sizeof(sll_hdr_t)) {\n            sll_hdr_t *sll_hdr = (sll_hdr_t *)pktdata;\n            return sll_hdr->sll_protocol;\n        }\n        break;\n\n    default:\n        errx(-1, \"Unable to process unsupported DLT type: %s (0x%x)\", \n             pcap_datalink_val_to_description(datalink), datalink);\n\n    }\n\n    return 0;\n\n}",
  "abstract_func_before": "uint16_t\nget_l2protocol(const u_char *VAR_0, const uint32_t VAR_1, const int VAR_2)\n{\n    uint16_t VAR_3 = 0;\n\n    if (!VAR_0 || !VAR_1) {\n        errx(-1, \"invalid l2 parameters: pktdata=0x%p len=%d\",\n                VAR_0, VAR_1);\n        return 0;\n    }\n\n    switch (VAR_2) {\n    case VAR_4:\n        if ((VAR_0[0] >> 4) == 4)\n            return VAR_5;\n        else if ((VAR_0[0] >> 4) == 6)\n            return VAR_6;\n        break;\n\n    case VAR_7:\n        if (VAR_1 < 5)\n            return 0;\n\n        if (memcmp(VAR_0, \"MGC\", 3))\n            warnx(\"No Magic Number found: %s (0x%x)\",\n                 pcap_datalink_val_to_description(VAR_2), VAR_2);\n\n        if ((VAR_0[3] & 0x80) == 0x80) {\n            VAR_3 = ntohs(*((uint16_t*)&VAR_0[4]));\n            VAR_3 += 6;\n        } else {\n            VAR_3 = 4; /* COMMENT_0 */\n        }\n        /* COMMENT_1 */\n    case VAR_8:\n        if ((size_t)VAR_1 >= (sizeof(VAR_9) + VAR_3)) {\n            eth_hdr_t *VAR_10 = (eth_hdr_t *)(VAR_0 + VAR_3);\n            uint16_t VAR_11 = ntohs(VAR_10->ether_type);\n            uint16_t VAR_12 = sizeof(*VAR_10) + VAR_3;\n            while (VAR_11 == VAR_13) {\n                if (VAR_1 < VAR_12 + sizeof(VAR_14))\n                     return 0;\n\n                 vlan_hdr_t *VAR_15 = (vlan_hdr_t*)(VAR_0 + VAR_12);\n                 VAR_11 = ntohs(VAR_15->vlan_tpid);\n                 VAR_12 += sizeof(vlan_hdr_t);\n            }\n\n            return VAR_11; /* COMMENT_2 */\n        }\n        break;\n\n    case VAR_16:\n        if ((size_t)VAR_1 >= sizeof(struct tcpr_pppserial_hdr)) {\n            struct tcpr_pppserial_hdr *VAR_17 = (struct tcpr_pppserial_hdr *)VAR_0;\n            if (ntohs(VAR_17->protocol) == 0x0021)\n                return htons(VAR_5);\n            else\n                return VAR_17->protocol;\n        }\n        break;\n\n    case VAR_18:\n        if ((size_t)VAR_1 >= sizeof(VAR_19)) {\n            hdlc_hdr_t *VAR_20 = (hdlc_hdr_t *)VAR_0;\n            return VAR_20->protocol;\n        }\n        break;\n\n    case VAR_21:\n        if ((size_t)VAR_1 >= sizeof(VAR_22)) {\n            sll_hdr_t *VAR_23 = (sll_hdr_t *)VAR_0;\n            return VAR_23->sll_protocol;\n        }\n        break;\n\n    default:\n        errx(-1, \"Unable to process unsupported DLT type: %s (0x%x)\", \n             pcap_datalink_val_to_description(VAR_2), VAR_2);\n\n    }\n\n    return 0;\n\n}",
  "func_graph_path_before": "appneta/tcpreplay/8323a7fe1e47d562ebf384aa99633e3df74a01c4/get.c/vul/before/0.json",
  "func": "uint16_t\nget_l2protocol(const u_char *pktdata, const uint32_t datalen, const int datalink)\n{\n    uint16_t eth_hdr_offset = 0;\n\n    if (!pktdata || !datalen) {\n        errx(-1, \"invalid l2 parameters: pktdata=0x%p len=%d\",\n                pktdata, datalen);\n        return 0;\n    }\n\n    switch (datalink) {\n    case DLT_RAW:\n        if (datalen < 1)\n            return 0;\n        if ((pktdata[0] >> 4) == 4)\n            return ETHERTYPE_IP;\n        else if ((pktdata[0] >> 4) == 6)\n            return ETHERTYPE_IP6;\n        break;\n\n    case DLT_JUNIPER_ETHER:\n        if (datalen < 4)\n            return 0;\n\n        if (memcmp(pktdata, JUNIPER_PCAP_MAGIC, 3)) {\n            warnx(\"No Magic Number found during protocol lookup: %s (0x%x)\",\n                 pcap_datalink_val_to_description(datalink), datalink);\n            return 0;\n        }\n\n        if ((pktdata[3] & JUNIPER_FLAG_EXT) == JUNIPER_FLAG_EXT) {\n            if (datalen < 6)\n                return 0;  /* datalen too short */\n\n            eth_hdr_offset = ntohs(*((uint16_t*)&pktdata[4]));\n            eth_hdr_offset += 6; /* MGC + flags + ext_total_len */\n        } else {\n            eth_hdr_offset = 4; /* MGC + flags (no header extensions) */\n        }\n        if ((pktdata[3] & JUNIPER_FLAG_NO_L2) == JUNIPER_FLAG_NO_L2) {\n             /* no L2 header present - eth_hdr_offset is actually IP offset */\n            uint32_t ip_hdr_offset = eth_hdr_offset;\n            if (datalen < ip_hdr_offset + 1)\n                return 0;\n            if ((pktdata[ip_hdr_offset] >> 4) == 4)\n                return ETHERTYPE_IP;\n            else if ((pktdata[ip_hdr_offset] >> 4) == 6)\n                return ETHERTYPE_IP6;\n            else\n                return 0;\n        }\n        /* fall through */\n    case DLT_EN10MB:\n        if ((size_t)datalen >= (sizeof(eth_hdr_t) + eth_hdr_offset)) {\n            eth_hdr_t *eth_hdr = (eth_hdr_t *)(pktdata + eth_hdr_offset);\n            uint16_t ether_type = ntohs(eth_hdr->ether_type);\n            uint16_t l2_len = sizeof(*eth_hdr) + eth_hdr_offset;\n            while (ether_type == ETHERTYPE_VLAN) {\n                if (datalen < l2_len + sizeof(vlan_hdr_t))\n                     return 0;\n\n                 vlan_hdr_t *vlan_hdr = (vlan_hdr_t*)(pktdata + l2_len);\n                 ether_type = ntohs(vlan_hdr->vlan_tpid);\n                 l2_len += sizeof(vlan_hdr_t);\n            }\n\n            return ether_type; /* yes, return it in host byte order */\n        }\n        break;\n\n    case DLT_PPP_SERIAL:\n        if ((size_t)datalen >= sizeof(struct tcpr_pppserial_hdr)) {\n            struct tcpr_pppserial_hdr *ppp = (struct tcpr_pppserial_hdr *)pktdata;\n            if (ntohs(ppp->protocol) == 0x0021)\n                return htons(ETHERTYPE_IP);\n            else\n                return ppp->protocol;\n        }\n        break;\n\n    case DLT_C_HDLC:\n        if ((size_t)datalen >= sizeof(hdlc_hdr_t)) {\n            hdlc_hdr_t *hdlc_hdr = (hdlc_hdr_t *)pktdata;\n            return hdlc_hdr->protocol;\n        }\n        break;\n\n    case DLT_LINUX_SLL:\n        if ((size_t)datalen >= sizeof(sll_hdr_t)) {\n            sll_hdr_t *sll_hdr = (sll_hdr_t *)pktdata;\n            return sll_hdr->sll_protocol;\n        }\n        break;\n\n    default:\n        errx(-1, \"Unable to process unsupported DLT type: %s (0x%x)\", \n             pcap_datalink_val_to_description(datalink), datalink);\n\n    }\n\n    return 0;\n}",
  "abstract_func": "uint16_t\nget_l2protocol(const u_char *VAR_0, const uint32_t VAR_1, const int VAR_2)\n{\n    uint16_t VAR_3 = 0;\n\n    if (!VAR_0 || !VAR_1) {\n        errx(-1, \"invalid l2 parameters: pktdata=0x%p len=%d\",\n                VAR_0, VAR_1);\n        return 0;\n    }\n\n    switch (VAR_2) {\n    case VAR_4:\n        if (VAR_1 < 1)\n            return 0;\n        if ((VAR_0[0] >> 4) == 4)\n            return VAR_5;\n        else if ((VAR_0[0] >> 4) == 6)\n            return VAR_6;\n        break;\n\n    case VAR_7:\n        if (VAR_1 < 4)\n            return 0;\n\n        if (memcmp(VAR_0, VAR_8, 3)) {\n            warnx(\"No Magic Number found during protocol lookup: %s (0x%x)\",\n                 pcap_datalink_val_to_description(VAR_2), VAR_2);\n            return 0;\n        }\n\n        if ((VAR_0[3] & VAR_9) == VAR_9) {\n            if (VAR_1 < 6)\n                return 0;  /* COMMENT_0 */\n\n            VAR_3 = ntohs(*((uint16_t*)&VAR_0[4]));\n            VAR_3 += 6; /* COMMENT_1 */\n        } else {\n            VAR_3 = 4; /* COMMENT_2 */\n        }\n        if ((VAR_0[3] & VAR_10) == VAR_10) {\n             /* COMMENT_3 */\n            uint32_t VAR_11 = VAR_3;\n            if (VAR_1 < VAR_11 + 1)\n                return 0;\n            if ((VAR_0[VAR_11] >> 4) == 4)\n                return VAR_5;\n            else if ((VAR_0[VAR_11] >> 4) == 6)\n                return VAR_6;\n            else\n                return 0;\n        }\n        /* COMMENT_4 */\n    case VAR_12:\n        if ((size_t)VAR_1 >= (sizeof(VAR_13) + VAR_3)) {\n            eth_hdr_t *VAR_14 = (eth_hdr_t *)(VAR_0 + VAR_3);\n            uint16_t VAR_15 = ntohs(VAR_14->ether_type);\n            uint16_t VAR_16 = sizeof(*VAR_14) + VAR_3;\n            while (VAR_15 == VAR_17) {\n                if (VAR_1 < VAR_16 + sizeof(VAR_18))\n                     return 0;\n\n                 vlan_hdr_t *VAR_19 = (vlan_hdr_t*)(VAR_0 + VAR_16);\n                 VAR_15 = ntohs(VAR_19->vlan_tpid);\n                 VAR_16 += sizeof(vlan_hdr_t);\n            }\n\n            return VAR_15; /* COMMENT_5 */\n        }\n        break;\n\n    case VAR_20:\n        if ((size_t)VAR_1 >= sizeof(struct tcpr_pppserial_hdr)) {\n            struct tcpr_pppserial_hdr *VAR_21 = (struct tcpr_pppserial_hdr *)VAR_0;\n            if (ntohs(VAR_21->protocol) == 0x0021)\n                return htons(VAR_5);\n            else\n                return VAR_21->protocol;\n        }\n        break;\n\n    case VAR_22:\n        if ((size_t)VAR_1 >= sizeof(VAR_23)) {\n            hdlc_hdr_t *VAR_24 = (hdlc_hdr_t *)VAR_0;\n            return VAR_24->protocol;\n        }\n        break;\n\n    case VAR_25:\n        if ((size_t)VAR_1 >= sizeof(VAR_26)) {\n            sll_hdr_t *VAR_27 = (sll_hdr_t *)VAR_0;\n            return VAR_27->sll_protocol;\n        }\n        break;\n\n    default:\n        errx(-1, \"Unable to process unsupported DLT type: %s (0x%x)\", \n             pcap_datalink_val_to_description(VAR_2), VAR_2);\n\n    }\n\n    return 0;\n}",
  "func_graph_path": "appneta/tcpreplay/8323a7fe1e47d562ebf384aa99633e3df74a01c4/get.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -11,6 +11,8 @@\n \n     switch (datalink) {\n     case DLT_RAW:\n+        if (datalen < 1)\n+            return 0;\n         if ((pktdata[0] >> 4) == 4)\n             return ETHERTYPE_IP;\n         else if ((pktdata[0] >> 4) == 6)\n@@ -18,20 +20,37 @@\n         break;\n \n     case DLT_JUNIPER_ETHER:\n-        if (datalen < 5)\n+        if (datalen < 4)\n             return 0;\n \n-        if (memcmp(pktdata, \"MGC\", 3))\n-            warnx(\"No Magic Number found: %s (0x%x)\",\n+        if (memcmp(pktdata, JUNIPER_PCAP_MAGIC, 3)) {\n+            warnx(\"No Magic Number found during protocol lookup: %s (0x%x)\",\n                  pcap_datalink_val_to_description(datalink), datalink);\n+            return 0;\n+        }\n \n-        if ((pktdata[3] & 0x80) == 0x80) {\n+        if ((pktdata[3] & JUNIPER_FLAG_EXT) == JUNIPER_FLAG_EXT) {\n+            if (datalen < 6)\n+                return 0;  /* datalen too short */\n+\n             eth_hdr_offset = ntohs(*((uint16_t*)&pktdata[4]));\n-            eth_hdr_offset += 6;\n+            eth_hdr_offset += 6; /* MGC + flags + ext_total_len */\n         } else {\n-            eth_hdr_offset = 4; /* no header extensions */\n+            eth_hdr_offset = 4; /* MGC + flags (no header extensions) */\n         }\n-        /* fallthrough */\n+        if ((pktdata[3] & JUNIPER_FLAG_NO_L2) == JUNIPER_FLAG_NO_L2) {\n+             /* no L2 header present - eth_hdr_offset is actually IP offset */\n+            uint32_t ip_hdr_offset = eth_hdr_offset;\n+            if (datalen < ip_hdr_offset + 1)\n+                return 0;\n+            if ((pktdata[ip_hdr_offset] >> 4) == 4)\n+                return ETHERTYPE_IP;\n+            else if ((pktdata[ip_hdr_offset] >> 4) == 6)\n+                return ETHERTYPE_IP6;\n+            else\n+                return 0;\n+        }\n+        /* fall through */\n     case DLT_EN10MB:\n         if ((size_t)datalen >= (sizeof(eth_hdr_t) + eth_hdr_offset)) {\n             eth_hdr_t *eth_hdr = (eth_hdr_t *)(pktdata + eth_hdr_offset);\n@@ -81,5 +100,4 @@\n     }\n \n     return 0;\n-\n }",
  "diff_line_info": {
    "deleted_lines": [
      "        if (datalen < 5)",
      "        if (memcmp(pktdata, \"MGC\", 3))",
      "            warnx(\"No Magic Number found: %s (0x%x)\",",
      "        if ((pktdata[3] & 0x80) == 0x80) {",
      "            eth_hdr_offset += 6;",
      "            eth_hdr_offset = 4; /* no header extensions */",
      "        /* fallthrough */",
      ""
    ],
    "added_lines": [
      "        if (datalen < 1)",
      "            return 0;",
      "        if (datalen < 4)",
      "        if (memcmp(pktdata, JUNIPER_PCAP_MAGIC, 3)) {",
      "            warnx(\"No Magic Number found during protocol lookup: %s (0x%x)\",",
      "            return 0;",
      "        }",
      "        if ((pktdata[3] & JUNIPER_FLAG_EXT) == JUNIPER_FLAG_EXT) {",
      "            if (datalen < 6)",
      "                return 0;  /* datalen too short */",
      "",
      "            eth_hdr_offset += 6; /* MGC + flags + ext_total_len */",
      "            eth_hdr_offset = 4; /* MGC + flags (no header extensions) */",
      "        if ((pktdata[3] & JUNIPER_FLAG_NO_L2) == JUNIPER_FLAG_NO_L2) {",
      "             /* no L2 header present - eth_hdr_offset is actually IP offset */",
      "            uint32_t ip_hdr_offset = eth_hdr_offset;",
      "            if (datalen < ip_hdr_offset + 1)",
      "                return 0;",
      "            if ((pktdata[ip_hdr_offset] >> 4) == 4)",
      "                return ETHERTYPE_IP;",
      "            else if ((pktdata[ip_hdr_offset] >> 4) == 6)",
      "                return ETHERTYPE_IP6;",
      "            else",
      "                return 0;",
      "        }",
      "        /* fall through */"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/appneta/tcpreplay/pull/637",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/appneta/tcpreplay/pull/637: 403 Client Error: Forbidden for url: https://api.github.com/repos/appneta/tcpreplay/pulls/637",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.85,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.85\n\nStep-by-step explanation:\n\n1. **Input Analysis:** The commit message and vulnerability description discuss bug fixes for Juniper Ethernet protocols and adding datalen checks. The code diff implements these checks in the `get_l2protocol` function, enhancing input validation and handling.\n\n2. **Consistency Check:** The commit message accurately reflects the code changes, which focus on processing Juniper Ethernet and RAW packets correctly.\n\n3. **Purpose Evaluation:** The changes are aimed at fixing protocol parsing issues and improving support, which affects core functionality rather than security.\n\n4. **Security Assessment:** While the fixes prevent issues like incorrect parsing, they don't explicitly address security vulnerabilities. There's no mention of CVE or known security risks.\n\n5. **Classification:** The fix addresses core business logic issues, fitting under Defect Remediation & Feature Upgrades.\n\n6. **Confidence Scoring:** High confidence (0.85) because the changes improve functionality, though the lack of explicit security mentions lowers the confidence slightly.\n\n**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.85"
}