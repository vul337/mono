{
  "cve_id": "CVE-2023-31438",
  "cwe_ids": [
    "CWE-354"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N",
  "cvss_is_v3": true,
  "repo_name": "systemd",
  "commit_msg": "journalctl: verify sealed log epochs are continuous\n\nCurrently empty epochs are not sealed. This allows an attacker to truncate\na sealed log and continue it without any problems showing when verifying the\nlog.\n\nThis partially addresses CVE-2023-31438. One way to extend this change to\naddress CVE-2023-31438 completely, would be to verify that there is exactly\none seal per epoch (and not sealing when the epoch has not ended yet).\n\nthe change also adds a journal-file flag: HEADER_COMPATIBLE_SEALED_CONTINUOUS\nthis flag indicates that a journal file is sealed continuously and decides whether\nany missing crypto epochs should trigger a warning or an error.",
  "commit_hash": "8d7b0958cdb505047e5a66029468b8d12b8a7add",
  "git_url": "https://github.com/systemd/systemd/commit/8d7b0958cdb505047e5a66029468b8d12b8a7add",
  "file_path": "src/libsystemd/sd-journal/journal-file.c",
  "func_name": "journal_file_init_header",
  "func_before": "static int journal_file_init_header(\n                JournalFile *f,\n                JournalFileFlags file_flags,\n                JournalFile *template) {\n\n        bool seal = false;\n        ssize_t k;\n        int r;\n\n        assert(f);\n\n#if HAVE_GCRYPT\n        /* Try to load the FSPRG state, and if we can't, then just don't do sealing */\n        seal = FLAGS_SET(file_flags, JOURNAL_SEAL) && journal_file_fss_load(f) >= 0;\n#endif\n\n        Header h = {\n                .header_size = htole64(ALIGN64(sizeof(h))),\n                .incompatible_flags = htole32(\n                                FLAGS_SET(file_flags, JOURNAL_COMPRESS) * COMPRESSION_TO_HEADER_INCOMPATIBLE_FLAG(compression_requested()) |\n                                keyed_hash_requested() * HEADER_INCOMPATIBLE_KEYED_HASH |\n                                compact_mode_requested() * HEADER_INCOMPATIBLE_COMPACT),\n                .compatible_flags = htole32(\n                                (seal * HEADER_COMPATIBLE_SEALED) |\n                                HEADER_COMPATIBLE_TAIL_ENTRY_BOOT_ID),\n        };\n\n        assert_cc(sizeof(h.signature) == sizeof(HEADER_SIGNATURE));\n        memcpy(h.signature, HEADER_SIGNATURE, sizeof(HEADER_SIGNATURE));\n\n        r = sd_id128_randomize(&h.file_id);\n        if (r < 0)\n                return r;\n\n        r = sd_id128_get_machine(&h.machine_id);\n        if (r < 0 && !ERRNO_IS_MACHINE_ID_UNSET(r))\n                return r; /* If we have no valid machine ID (test environment?), let's simply leave the\n                           * machine ID field all zeroes. */\n\n        if (template) {\n                h.seqnum_id = template->header->seqnum_id;\n                h.tail_entry_seqnum = template->header->tail_entry_seqnum;\n        } else\n                h.seqnum_id = h.file_id;\n\n        k = pwrite(f->fd, &h, sizeof(h), 0);\n        if (k < 0)\n                return -errno;\n        if (k != sizeof(h))\n                return -EIO;\n\n        return 0;\n}",
  "abstract_func_before": "static int journal_file_init_header(\n                JournalFile *VAR_0,\n                JournalFileFlags VAR_1,\n                JournalFile *VAR_2) {\n\n        bool VAR_3 = false;\n        ssize_t VAR_4;\n        int VAR_5;\n\n        assert(VAR_0);\n\n#if VAR_6\n        /* COMMENT_0 */\n        VAR_3 = FLAGS_SET(VAR_1, VAR_7) && journal_file_fss_load(VAR_0) >= 0;\n#endif\n\n        Header VAR_8 = {\n                .header_size = htole64(ALIGN64(sizeof(VAR_8))),\n                .incompatible_flags = htole32(\n                                FLAGS_SET(VAR_1, VAR_9) * COMPRESSION_TO_HEADER_INCOMPATIBLE_FLAG(compression_requested()) |\n                                keyed_hash_requested() * VAR_10 |\n                                compact_mode_requested() * VAR_11),\n                .compatible_flags = htole32(\n                                (VAR_3 * VAR_12) |\n                                VAR_13),\n        };\n\n        assert_cc(sizeof(VAR_8.signature) == sizeof(VAR_14));\n        memcpy(VAR_8.signature, VAR_14, sizeof(VAR_14));\n\n        VAR_5 = sd_id128_randomize(&VAR_8.file_id);\n        if (VAR_5 < 0)\n                return VAR_5;\n\n        VAR_5 = sd_id128_get_machine(&VAR_8.machine_id);\n        if (VAR_5 < 0 && !ERRNO_IS_MACHINE_ID_UNSET(VAR_5))\n                return VAR_5; /* COMMENT_1 */\n                                                            \n\n        if (VAR_2) {\n                VAR_8.seqnum_id = VAR_2->header->seqnum_id;\n                VAR_8.tail_entry_seqnum = VAR_2->header->tail_entry_seqnum;\n        } else\n                VAR_8.seqnum_id = VAR_8.file_id;\n\n        VAR_4 = pwrite(VAR_0->fd, &VAR_8, sizeof(VAR_8), 0);\n        if (VAR_4 < 0)\n                return -VAR_15;\n        if (VAR_4 != sizeof(VAR_8))\n                return -VAR_16;\n\n        return 0;\n}",
  "func_graph_path_before": "systemd/8d7b0958cdb505047e5a66029468b8d12b8a7add/journal-file.c/vul/before/0.json",
  "func": "static int journal_file_init_header(\n                JournalFile *f,\n                JournalFileFlags file_flags,\n                JournalFile *template) {\n\n        bool seal = false;\n        ssize_t k;\n        int r;\n\n        assert(f);\n\n#if HAVE_GCRYPT\n        /* Try to load the FSPRG state, and if we can't, then just don't do sealing */\n        seal = FLAGS_SET(file_flags, JOURNAL_SEAL) && journal_file_fss_load(f) >= 0;\n#endif\n\n        Header h = {\n                .header_size = htole64(ALIGN64(sizeof(h))),\n                .incompatible_flags = htole32(\n                                FLAGS_SET(file_flags, JOURNAL_COMPRESS) * COMPRESSION_TO_HEADER_INCOMPATIBLE_FLAG(compression_requested()) |\n                                keyed_hash_requested() * HEADER_INCOMPATIBLE_KEYED_HASH |\n                                compact_mode_requested() * HEADER_INCOMPATIBLE_COMPACT),\n                .compatible_flags = htole32(\n                                (seal * (HEADER_COMPATIBLE_SEALED | HEADER_COMPATIBLE_SEALED_CONTINUOUS) ) |\n                                HEADER_COMPATIBLE_TAIL_ENTRY_BOOT_ID),\n        };\n\n        assert_cc(sizeof(h.signature) == sizeof(HEADER_SIGNATURE));\n        memcpy(h.signature, HEADER_SIGNATURE, sizeof(HEADER_SIGNATURE));\n\n        r = sd_id128_randomize(&h.file_id);\n        if (r < 0)\n                return r;\n\n        r = sd_id128_get_machine(&h.machine_id);\n        if (r < 0 && !ERRNO_IS_MACHINE_ID_UNSET(r))\n                return r; /* If we have no valid machine ID (test environment?), let's simply leave the\n                           * machine ID field all zeroes. */\n\n        if (template) {\n                h.seqnum_id = template->header->seqnum_id;\n                h.tail_entry_seqnum = template->header->tail_entry_seqnum;\n        } else\n                h.seqnum_id = h.file_id;\n\n        k = pwrite(f->fd, &h, sizeof(h), 0);\n        if (k < 0)\n                return -errno;\n        if (k != sizeof(h))\n                return -EIO;\n\n        return 0;\n}",
  "abstract_func": "static int journal_file_init_header(\n                JournalFile *VAR_0,\n                JournalFileFlags VAR_1,\n                JournalFile *VAR_2) {\n\n        bool VAR_3 = false;\n        ssize_t VAR_4;\n        int VAR_5;\n\n        assert(VAR_0);\n\n#if VAR_6\n        /* COMMENT_0 */\n        VAR_3 = FLAGS_SET(VAR_1, VAR_7) && journal_file_fss_load(VAR_0) >= 0;\n#endif\n\n        Header VAR_8 = {\n                .header_size = htole64(ALIGN64(sizeof(VAR_8))),\n                .incompatible_flags = htole32(\n                                FLAGS_SET(VAR_1, VAR_9) * COMPRESSION_TO_HEADER_INCOMPATIBLE_FLAG(compression_requested()) |\n                                keyed_hash_requested() * VAR_10 |\n                                compact_mode_requested() * VAR_11),\n                .compatible_flags = htole32(\n                                (VAR_3 * (VAR_12 | VAR_13) ) |\n                                VAR_14),\n        };\n\n        assert_cc(sizeof(VAR_8.signature) == sizeof(VAR_15));\n        memcpy(VAR_8.signature, VAR_15, sizeof(VAR_15));\n\n        VAR_5 = sd_id128_randomize(&VAR_8.file_id);\n        if (VAR_5 < 0)\n                return VAR_5;\n\n        VAR_5 = sd_id128_get_machine(&VAR_8.machine_id);\n        if (VAR_5 < 0 && !ERRNO_IS_MACHINE_ID_UNSET(VAR_5))\n                return VAR_5; /* COMMENT_1 */\n                                                            \n\n        if (VAR_2) {\n                VAR_8.seqnum_id = VAR_2->header->seqnum_id;\n                VAR_8.tail_entry_seqnum = VAR_2->header->tail_entry_seqnum;\n        } else\n                VAR_8.seqnum_id = VAR_8.file_id;\n\n        VAR_4 = pwrite(VAR_0->fd, &VAR_8, sizeof(VAR_8), 0);\n        if (VAR_4 < 0)\n                return -VAR_16;\n        if (VAR_4 != sizeof(VAR_8))\n                return -VAR_17;\n\n        return 0;\n}",
  "func_graph_path": "systemd/8d7b0958cdb505047e5a66029468b8d12b8a7add/journal-file.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -21,7 +21,7 @@\n                                 keyed_hash_requested() * HEADER_INCOMPATIBLE_KEYED_HASH |\n                                 compact_mode_requested() * HEADER_INCOMPATIBLE_COMPACT),\n                 .compatible_flags = htole32(\n-                                (seal * HEADER_COMPATIBLE_SEALED) |\n+                                (seal * (HEADER_COMPATIBLE_SEALED | HEADER_COMPATIBLE_SEALED_CONTINUOUS) ) |\n                                 HEADER_COMPATIBLE_TAIL_ENTRY_BOOT_ID),\n         };\n ",
  "diff_line_info": {
    "deleted_lines": [
      "                                (seal * HEADER_COMPATIBLE_SEALED) |"
    ],
    "added_lines": [
      "                                (seal * (HEADER_COMPATIBLE_SEALED | HEADER_COMPATIBLE_SEALED_CONTINUOUS) ) |"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/systemd/systemd/pull/28886",
  "description": {
    "pr_info": {
      "title": "journalctl: verify sealed log epochs are continuous",
      "number": 28886
    },
    "comment": [
      "Currently empty epochs are not sealed. This allows an attacker to truncate a sealed log and continue it without any problems showing when verifying the log.\r\n\r\nThis partially addresses CVE-2023-31438. One way to extend this change to address CVE-2023-31438 completely, would be to verify that there is exactly one seal per epoch (and not sealing when the epoch has not ended yet). I didn't remove the premature sealing, as it is implemented purposefully although I don't understand the purpose.\r\nSee https://github.com/kastel-security/Journald/blob/main/journald-publication.pdf for more background.\r\n\r\nThis change adjusts what journald writes into a log file but is compatible in the sense that old `journalctl` versions will successfully verify new journals, but the new `journalctl --verify` will refuse to accept a journal created with old journald if there are gaps in the sealed epochs.\r\n\r\nSee also #28433\n\n<!-- devel-freezer = {\"comment-id\":\"1801865051\",\"freezing-tag\":\"v255-rc1\"} -->",
      "looks good, but i am a bit concerned about the compat with this, see comment above",
      "Good idea. I added a draft version of a `SEALED_CONTINOUS`-flag to change the error message to a warning. Thinking more closely about it: We cannot guarantee completeness for old journal files regardless of whether the epochs are continuous or not, due to the fact that journald seals an epoch prematurely when closed. Because that allows an attacker to drop the second seal, when the epoch actually ended, and claim the premature seal is the only correct one.\r\n\r\nSo I think we should drop premature sealing and then this should be the behavior:\r\nWhen not `SEALED_CONTINOUS` we should issue a warning, that we cannot guarantee consistency, unconditionally. (And for the rest of the verification, fall back to verifying the more loose constraint).\r\n\r\nWould you be fine with dropping premature sealing, that is this block:\r\nhttps://github.com/systemd/systemd/blob/1ffa5cfb38b3d30d269259c531300fc629816ea9/src/journal/managed-journal-file.c#L395\r\nor can you tell my why it is needed?",
      "I've gone ahead and removed the premature sealing. The only remaining gap is now between rotated journal files.",
      "Please rebase and squash commits.",
      "So @yuwata you do not want to do a final review and merge this, but we let it sit again until someone else picks it up?",
      "lgtm. just some minor things.",
      "An -rc1 tag has been created and a release is being prepared, so please note that PRs introducing new features and APIs will be held back until the new version has been released.\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Step1: Input Analysis**  \n- Commit Message: References a security issue (CVE-2023-31438), mentions sealing log epochs to prevent attacks.\n- Code Diff: Adds a flag `HEADER_COMPATIBLE_SEALED_CONTINUOUS` in header initialization.\n- Vulnerability Description: Details a security flaw allowing log truncation and mentions partial fix for CVE-2023-31438.\n\n**Step2: Consistency Check**  \n- Changes are described as addressing the vulnerability; code adds a flag indicating continuous sealing. Consistent.\n\n**Step3: Purpose Evaluation**  \n- Patch modifies log file header to enforce continuous sealing, preventing attackers from exploiting unsealed epochs.\n\n**Step4: Security Vulnerability Assessment**  \n- Directly addresses a CVE, modifies core logic to fix an exploit.\n\n**Step5: Non-Security Classification**  \n- Not applicable; it's a security fix.\n\n**Step6: Confidence Scoring**  \n- High confidence as the code changes align with the security context, and the commit message clearly references a CVE.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}