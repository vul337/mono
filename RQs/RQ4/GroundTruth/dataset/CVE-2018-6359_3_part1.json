{
  "cve_id": "CVE-2018-6359",
  "cwe_ids": [
    "CWE-416"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "libming",
  "commit_msg": "Use OpCode instead of directly accessing actions\n\nInstead of directly accessing the actions array without checks\nfor the value of n (which may lead to heap buffer overflow etc,\nsee #83 or #105), use the dedicated OpCode function.",
  "commit_hash": "9c53bf8e165c3a74e20f4c93b4ab6c05fe67f187",
  "git_url": "https://github.com/libming/libming/commit/9c53bf8e165c3a74e20f4c93b4ab6c05fe67f187",
  "file_path": "util/decompile.c",
  "func_name": "decompileCALLFUNCTION",
  "func_before": "static int\ndecompileCALLFUNCTION(int n, SWF_ACTION *actions, int maxn)\n{\n\tstruct SWF_ACTIONPUSHPARAM *meth, *nparam;\n\n\tSanityCheck(SWF_CALLMETHOD,\n\t\tn > 0 && actions[n-1].SWF_ACTIONRECORD.ActionCode == SWFACTION_PUSH,\n\t\t\"CALLMETHOD not preceeded by PUSH\")\n\n\tmeth=pop();\n\tnparam=pop();\n\tif (nparam->p.Integer>25)\n\t{\n\t\tINDENT\n\t\tprintln(\"// Problem getting function arguments (%d ignored) below:\",\n\t\t\tnparam->p.Integer);\n\t\tnparam->p.Integer=0;\n\t}\n\tpush(newVar_N(\"\",\"\",getName(meth),\"(\", nparam->p.Integer,\")\"));\n\tif (OpCode(actions, n+1, maxn) == SWFACTION_POP)\n\t{\n\t\t/* call function and throw away any result */\n\t\tINDENT\n\t\tputs(getName(pop()));\n\t\tprintln(\";\" );\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
  "abstract_func_before": "static int\ndecompileCALLFUNCTION(int VAR_0, SWF_ACTION *VAR_1, int VAR_2)\n{\n\tstruct SWF_ACTIONPUSHPARAM *VAR_3, *VAR_4;\n\n\tSanityCheck(VAR_5,\n\t\tVAR_0 > 0 && VAR_1[VAR_0-1].SWF_ACTIONRECORD.ActionCode == VAR_6,\n\t\t\"CALLMETHOD not preceeded by PUSH\")\n\n\tVAR_3=pop();\n\tVAR_4=pop();\n\tif (VAR_4->p.Integer>25)\n\t{\n\t\tINDENT\n\t\tVAR_7(\"// Problem getting function arguments (%d ignored) below:\",\n\t\t\tVAR_4->p.Integer);\n\t\tVAR_4->p.Integer=0;\n\t}\n\tpush(newVar_N(\"\",\"\",getName(VAR_3),\"(\", VAR_4->p.Integer,\")\"));\n\tif (OpCode(VAR_1, VAR_0+1, VAR_2) == VAR_8)\n\t{\n\t\t/* COMMENT_0 */\n\t\tINDENT\n\t\tputs(getName(pop()));\n\t\tVAR_7(\";\" );\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
  "func_graph_path_before": "libming/9c53bf8e165c3a74e20f4c93b4ab6c05fe67f187/decompile.c/vul/before/4.json",
  "func": "static int\ndecompileCALLFUNCTION(int n, SWF_ACTION *actions, int maxn)\n{\n\tstruct SWF_ACTIONPUSHPARAM *meth, *nparam;\n\n\tSanityCheck(SWF_CALLMETHOD, OpCode(actions, n-1, maxn) == SWFACTION_PUSH,\n\t\t\"CALLMETHOD not preceeded by PUSH\")\n\n\tmeth=pop();\n\tnparam=pop();\n\tif (nparam->p.Integer>25)\n\t{\n\t\tINDENT\n\t\tprintln(\"// Problem getting function arguments (%d ignored) below:\",\n\t\t\tnparam->p.Integer);\n\t\tnparam->p.Integer=0;\n\t}\n\tpush(newVar_N(\"\",\"\",getName(meth),\"(\", nparam->p.Integer,\")\"));\n\tif (OpCode(actions, n+1, maxn) == SWFACTION_POP)\n\t{\n\t\t/* call function and throw away any result */\n\t\tINDENT\n\t\tputs(getName(pop()));\n\t\tprintln(\";\" );\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
  "abstract_func": "static int\ndecompileCALLFUNCTION(int VAR_0, SWF_ACTION *VAR_1, int VAR_2)\n{\n\tstruct SWF_ACTIONPUSHPARAM *VAR_3, *VAR_4;\n\n\tSanityCheck(VAR_5, OpCode(VAR_1, VAR_0-1, VAR_2) == VAR_6,\n\t\t\"CALLMETHOD not preceeded by PUSH\")\n\n\tVAR_3=pop();\n\tVAR_4=pop();\n\tif (VAR_4->p.Integer>25)\n\t{\n\t\tINDENT\n\t\tVAR_7(\"// Problem getting function arguments (%d ignored) below:\",\n\t\t\tVAR_4->p.Integer);\n\t\tVAR_4->p.Integer=0;\n\t}\n\tpush(newVar_N(\"\",\"\",getName(VAR_3),\"(\", VAR_4->p.Integer,\")\"));\n\tif (OpCode(VAR_1, VAR_0+1, VAR_2) == VAR_8)\n\t{\n\t\t/* COMMENT_0 */\n\t\tINDENT\n\t\tputs(getName(pop()));\n\t\tVAR_7(\";\" );\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
  "func_graph_path": "libming/9c53bf8e165c3a74e20f4c93b4ab6c05fe67f187/decompile.c/vul/after/4.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -3,8 +3,7 @@\n {\n \tstruct SWF_ACTIONPUSHPARAM *meth, *nparam;\n \n-\tSanityCheck(SWF_CALLMETHOD,\n-\t\tn > 0 && actions[n-1].SWF_ACTIONRECORD.ActionCode == SWFACTION_PUSH,\n+\tSanityCheck(SWF_CALLMETHOD, OpCode(actions, n-1, maxn) == SWFACTION_PUSH,\n \t\t\"CALLMETHOD not preceeded by PUSH\")\n \n \tmeth=pop();",
  "diff_line_info": {
    "deleted_lines": [
      "\tSanityCheck(SWF_CALLMETHOD,",
      "\t\tn > 0 && actions[n-1].SWF_ACTIONRECORD.ActionCode == SWFACTION_PUSH,"
    ],
    "added_lines": [
      "\tSanityCheck(SWF_CALLMETHOD, OpCode(actions, n-1, maxn) == SWFACTION_PUSH,"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libming/libming/pull/108",
  "description": {
    "pr_info": {
      "title": "Use OpCode instead of directly accessing actions",
      "number": 108
    },
    "comment": [
      "Instead of directly accessing the actions array without checks for the value of n (which may lead to heap buffer overflow etc, see #83 or #105), use the dedicated OpCode function.\r\n\r\nThis PR fixes #105 (CVE-2018-6359).",
      "Confirmed, and merged. Thanks.\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95  \n\nThe patch addresses a heap buffer overflow vulnerability (CVE-2018-6359) by safely accessing the actions array using OpCode, thereby preventing security risks."
}