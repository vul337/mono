{
  "cve_id": "CVE-2020-10019",
  "cwe_ids": [
    "CWE-120"
  ],
  "cvss_vector": "AV:L/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "zephyrproject-rtos/zephyr",
  "commit_msg": "usb: dfu: check requested length (wLength) during DFU_UPLOAD\n\nDuring DFU_UPLOAD, the host could requests more data\nas stated in wTransferSize. Limit upload length to the\nsize of the request buffer (USB_REQUEST_BUFFER_SIZE).\n\nSigned-off-by: Johann Fischer <j.fischer@phytec.de>",
  "commit_hash": "8183a87931538650f09c00d8d51fbc2236600646",
  "git_url": "https://github.com/zephyrproject-rtos/zephyr/commit/8183a87931538650f09c00d8d51fbc2236600646",
  "file_path": "subsys/usb/class/usb_dfu.c",
  "func_name": "dfu_class_handle_req",
  "func_before": "static int dfu_class_handle_req(struct usb_setup_packet *pSetup,\n\t\ts32_t *data_len, u8_t **data)\n{\n\tint ret;\n\tu32_t len, bytes_left;\n\n\tswitch (pSetup->bRequest) {\n\tcase DFU_GETSTATUS:\n\t\tLOG_DBG(\"DFU_GETSTATUS: status %d, state %d\",\n\t\t\tdfu_data.status, dfu_data.state);\n\n\t\tif (dfu_data.state == dfuMANIFEST_SYNC) {\n\t\t\tdfu_data.state = dfuIDLE;\n\t\t}\n\n\t\t/* bStatus */\n\t\t(*data)[0] = dfu_data.status;\n\t\t/* bwPollTimeout */\n\t\tsys_put_le16(dfu_data.bwPollTimeout, &(*data)[1]);\n\t\t(*data)[3] = 0U;\n\t\t/* bState */\n\t\t(*data)[4] = dfu_data.state;\n\t\t/* iString */\n\t\t(*data)[5] = 0U;\n\t\t*data_len = 6;\n\t\tbreak;\n\n\tcase DFU_GETSTATE:\n\t\tLOG_DBG(\"DFU_GETSTATE\");\n\t\t(*data)[0] = dfu_data.state;\n\t\t*data_len = 1;\n\t\tbreak;\n\n\tcase DFU_ABORT:\n\t\tLOG_DBG(\"DFU_ABORT\");\n\n\t\tif (dfu_check_app_state()) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdfu_reset_counters();\n\t\tdfu_data.state = dfuIDLE;\n\t\tdfu_data.status = statusOK;\n\t\tbreak;\n\n\tcase DFU_CLRSTATUS:\n\t\tLOG_DBG(\"DFU_CLRSTATUS\");\n\n\t\tif (dfu_check_app_state()) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdfu_data.state = dfuIDLE;\n\t\tdfu_data.status = statusOK;\n\t\tbreak;\n\n\tcase DFU_DNLOAD:\n\t\tLOG_DBG(\"DFU_DNLOAD block %d, len %d, state %d\",\n\t\t\tpSetup->wValue, pSetup->wLength, dfu_data.state);\n\n\t\tif (dfu_check_app_state()) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tswitch (dfu_data.state) {\n\t\tcase dfuIDLE:\n\t\t\tLOG_DBG(\"DFU_DNLOAD start\");\n\t\t\tdfu_reset_counters();\n\t\t\tk_poll_signal_reset(&dfu_signal);\n\n\t\t\tif (dfu_data.flash_area_id !=\n\t\t\t    DT_FLASH_AREA_IMAGE_1_ID) {\n\t\t\t\tdfu_data.status = errWRITE;\n\t\t\t\tdfu_data.state = dfuERROR;\n\t\t\t\tLOG_ERR(\"This area can not be overwritten\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdfu_data.state = dfuDNBUSY;\n\t\t\tdfu_data_worker.worker_state = dfuIDLE;\n\t\t\tdfu_data_worker.worker_len  = pSetup->wLength;\n\t\t\tmemcpy(dfu_data_worker.buf, *data, pSetup->wLength);\n\t\t\tk_work_submit(&dfu_work);\n\t\t\tbreak;\n\t\tcase dfuDNLOAD_IDLE:\n\t\t\tdfu_data.state = dfuDNBUSY;\n\t\t\tdfu_data_worker.worker_state = dfuDNLOAD_IDLE;\n\t\t\tdfu_data_worker.worker_len  = pSetup->wLength;\n\t\t\tif (dfu_data_worker.worker_len == 0U) {\n\t\t\t\tdfu_data.state = dfuMANIFEST_SYNC;\n\t\t\t\tk_poll_signal_raise(&dfu_signal, 0);\n\t\t\t}\n\n\t\t\tmemcpy(dfu_data_worker.buf, *data, pSetup->wLength);\n\t\t\tk_work_submit(&dfu_work);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLOG_ERR(\"DFU_DNLOAD wrong state %d\", dfu_data.state);\n\t\t\tdfu_data.state = dfuERROR;\n\t\t\tdfu_data.status = errUNKNOWN;\n\t\t\tdfu_reset_counters();\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase DFU_UPLOAD:\n\t\tLOG_DBG(\"DFU_UPLOAD block %d, len %d, state %d\",\n\t\t\tpSetup->wValue, pSetup->wLength, dfu_data.state);\n\n\t\tif (dfu_check_app_state()) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tswitch (dfu_data.state) {\n\t\tcase dfuIDLE:\n\t\t\tdfu_reset_counters();\n\t\t\tLOG_DBG(\"DFU_UPLOAD start\");\n\t\tcase dfuUPLOAD_IDLE:\n\t\t\tif (!pSetup->wLength ||\n\t\t\t    dfu_data.block_nr != pSetup->wValue) {\n\t\t\t\tLOG_DBG(\"DFU_UPLOAD block %d, expected %d, \"\n\t\t\t\t\t\"len %d\", pSetup->wValue,\n\t\t\t\t\tdfu_data.block_nr, pSetup->wLength);\n\t\t\t\tdfu_data.state = dfuERROR;\n\t\t\t\tdfu_data.status = errUNKNOWN;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Upload in progress */\n\t\t\tbytes_left = dfu_data.flash_upload_size -\n\t\t\t\t     dfu_data.bytes_sent;\n\t\t\tif (bytes_left < pSetup->wLength) {\n\t\t\t\tlen = bytes_left;\n\t\t\t} else {\n\t\t\t\tlen = pSetup->wLength;\n\t\t\t}\n\n\t\t\tif (len) {\n\t\t\t\tconst struct flash_area *fa;\n\n\t\t\t\tret = flash_area_open(dfu_data.flash_area_id,\n\t\t\t\t\t\t      &fa);\n\t\t\t\tif (ret) {\n\t\t\t\t\tdfu_data.state = dfuERROR;\n\t\t\t\t\tdfu_data.status = errFILE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tret = flash_area_read(fa, dfu_data.bytes_sent,\n\t\t\t\t\t\t      *data, len);\n\t\t\t\tflash_area_close(fa);\n\t\t\t\tif (ret) {\n\t\t\t\t\tdfu_data.state = dfuERROR;\n\t\t\t\t\tdfu_data.status = errFILE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t*data_len = len;\n\n\t\t\tdfu_data.bytes_sent += len;\n\t\t\tdfu_data.block_nr++;\n\n\t\t\tif (dfu_data.bytes_sent == dfu_data.flash_upload_size &&\n\t\t\t    len < pSetup->wLength) {\n\t\t\t\t/* Upload completed when a\n\t\t\t\t * short packet is received\n\t\t\t\t */\n\t\t\t\t*data_len = 0;\n\t\t\t\tdfu_data.state = dfuIDLE;\n\t\t\t} else\n\t\t\t\tdfu_data.state = dfuUPLOAD_IDLE;\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLOG_ERR(\"DFU_UPLOAD wrong state %d\", dfu_data.state);\n\t\t\tdfu_data.state = dfuERROR;\n\t\t\tdfu_data.status = errUNKNOWN;\n\t\t\tdfu_reset_counters();\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase DFU_DETACH:\n\t\tLOG_DBG(\"DFU_DETACH timeout %d, state %d\",\n\t\t\tpSetup->wValue, dfu_data.state);\n\n\t\tif (dfu_data.state != appIDLE) {\n\t\t\tdfu_data.state = appIDLE;\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/* Move to appDETACH state */\n\t\tdfu_data.state = appDETACH;\n\n\t\t/* We should start a timer here but in order to\n\t\t * keep things simple and do not increase the size\n\t\t * we rely on the host to get us out of the appATTACHED\n\t\t * state if needed.\n\t\t */\n\n\t\t/* Set the DFU mode descriptors to be used after reset */\n\t\tdfu_config.usb_device_description = (u8_t *) &dfu_mode_desc;\n\t\tif (usb_set_config(dfu_config.usb_device_description) != 0) {\n\t\t\tLOG_ERR(\"usb_set_config failed in DFU_DETACH\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tLOG_WRN(\"DFU UNKNOWN STATE: %d\", pSetup->bRequest);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
  "abstract_func_before": "static int dfu_class_handle_req(struct usb_setup_packet *VAR_0,\n\t\ts32_t *VAR_1, u8_t **VAR_2)\n{\n\tint VAR_3;\n\tu32_t VAR_4, VAR_5;\n\n\tswitch (VAR_0->bRequest) {\n\tcase VAR_6:\n\t\tLOG_DBG(\"DFU_GETSTATUS: status %d, state %d\",\n\t\t\tVAR_7.status, VAR_7.state);\n\n\t\tif (VAR_7.state == VAR_8) {\n\t\t\tVAR_7.state = VAR_9;\n\t\t}\n\n\t\t/* COMMENT_0 */\n\t\t(*VAR_2)[0] = VAR_7.status;\n\t\t/* COMMENT_1 */\n\t\tsys_put_le16(VAR_7.bwPollTimeout, &(*VAR_2)[1]);\n\t\t(*VAR_2)[3] = 0U;\n\t\t/* COMMENT_2 */\n\t\t(*VAR_2)[4] = VAR_7.state;\n\t\t/* COMMENT_3 */\n\t\t(*VAR_2)[5] = 0U;\n\t\t*VAR_1 = 6;\n\t\tbreak;\n\n\tcase VAR_10:\n\t\tLOG_DBG(\"DFU_GETSTATE\");\n\t\t(*VAR_2)[0] = VAR_7.state;\n\t\t*VAR_1 = 1;\n\t\tbreak;\n\n\tcase VAR_11:\n\t\tLOG_DBG(\"DFU_ABORT\");\n\n\t\tif (dfu_check_app_state()) {\n\t\t\treturn -VAR_12;\n\t\t}\n\n\t\tdfu_reset_counters();\n\t\tVAR_7.state = VAR_9;\n\t\tVAR_7.status = VAR_13;\n\t\tbreak;\n\n\tcase VAR_14:\n\t\tLOG_DBG(\"DFU_CLRSTATUS\");\n\n\t\tif (dfu_check_app_state()) {\n\t\t\treturn -VAR_12;\n\t\t}\n\n\t\tVAR_7.state = VAR_9;\n\t\tVAR_7.status = VAR_13;\n\t\tbreak;\n\n\tcase VAR_15:\n\t\tLOG_DBG(\"DFU_DNLOAD block %d, len %d, state %d\",\n\t\t\tVAR_0->wValue, VAR_0->wLength, VAR_7.state);\n\n\t\tif (dfu_check_app_state()) {\n\t\t\treturn -VAR_12;\n\t\t}\n\n\t\tswitch (VAR_7.state) {\n\t\tcase VAR_9:\n\t\t\tLOG_DBG(\"DFU_DNLOAD start\");\n\t\t\tdfu_reset_counters();\n\t\t\tk_poll_signal_reset(&VAR_16);\n\n\t\t\tif (VAR_7.flash_area_id !=\n\t\t\t    VAR_17) {\n\t\t\t\tVAR_7.status = VAR_18;\n\t\t\t\tVAR_7.state = VAR_19;\n\t\t\t\tLOG_ERR(\"This area can not be overwritten\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tVAR_7.state = VAR_20;\n\t\t\tVAR_21.worker_state = VAR_9;\n\t\t\tVAR_21.worker_len  = VAR_0->wLength;\n\t\t\tmemcpy(VAR_21.buf, *VAR_2, VAR_0->wLength);\n\t\t\tk_work_submit(&VAR_22);\n\t\t\tbreak;\n\t\tcase VAR_23:\n\t\t\tVAR_7.state = VAR_20;\n\t\t\tVAR_21.worker_state = VAR_23;\n\t\t\tVAR_21.worker_len  = VAR_0->wLength;\n\t\t\tif (VAR_21.worker_len == 0U) {\n\t\t\t\tVAR_7.state = VAR_8;\n\t\t\t\tk_poll_signal_raise(&VAR_16, 0);\n\t\t\t}\n\n\t\t\tmemcpy(VAR_21.buf, *VAR_2, VAR_0->wLength);\n\t\t\tk_work_submit(&VAR_22);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLOG_ERR(\"DFU_DNLOAD wrong state %d\", VAR_7.state);\n\t\t\tVAR_7.state = VAR_19;\n\t\t\tVAR_7.status = VAR_24;\n\t\t\tdfu_reset_counters();\n\t\t\treturn -VAR_12;\n\t\t}\n\t\tbreak;\n\tcase VAR_25:\n\t\tLOG_DBG(\"DFU_UPLOAD block %d, len %d, state %d\",\n\t\t\tVAR_0->wValue, VAR_0->wLength, VAR_7.state);\n\n\t\tif (dfu_check_app_state()) {\n\t\t\treturn -VAR_12;\n\t\t}\n\n\t\tswitch (VAR_7.state) {\n\t\tcase VAR_9:\n\t\t\tdfu_reset_counters();\n\t\t\tLOG_DBG(\"DFU_UPLOAD start\");\n\t\tcase VAR_26:\n\t\t\tif (!VAR_0->wLength ||\n\t\t\t    VAR_7.block_nr != VAR_0->wValue) {\n\t\t\t\tLOG_DBG(\"DFU_UPLOAD block %d, expected %d, \"\n\t\t\t\t\t\"len %d\", VAR_0->wValue,\n\t\t\t\t\tVAR_7.block_nr, VAR_0->wLength);\n\t\t\t\tVAR_7.state = VAR_19;\n\t\t\t\tVAR_7.status = VAR_24;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* COMMENT_4 */\n\t\t\tVAR_5 = VAR_7.flash_upload_size -\n\t\t\t\t     VAR_7.bytes_sent;\n\t\t\tif (VAR_5 < VAR_0->wLength) {\n\t\t\t\tVAR_4 = VAR_5;\n\t\t\t} else {\n\t\t\t\tVAR_4 = VAR_0->wLength;\n\t\t\t}\n\n\t\t\tif (VAR_4) {\n\t\t\t\tconst struct flash_area *VAR_27;\n\n\t\t\t\tVAR_3 = flash_area_open(VAR_7.flash_area_id,\n\t\t\t\t\t\t      &VAR_27);\n\t\t\t\tif (VAR_3) {\n\t\t\t\t\tVAR_7.state = VAR_19;\n\t\t\t\t\tVAR_7.status = VAR_28;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tVAR_3 = flash_area_read(VAR_27, VAR_7.bytes_sent,\n\t\t\t\t\t\t      *VAR_2, VAR_4);\n\t\t\t\tflash_area_close(VAR_27);\n\t\t\t\tif (VAR_3) {\n\t\t\t\t\tVAR_7.state = VAR_19;\n\t\t\t\t\tVAR_7.status = VAR_28;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t*VAR_1 = VAR_4;\n\n\t\t\tVAR_7.bytes_sent += VAR_4;\n\t\t\tVAR_7.block_nr++;\n\n\t\t\tif (VAR_7.bytes_sent == VAR_7.flash_upload_size &&\n\t\t\t    VAR_4 < VAR_0->wLength) {\n\t\t\t\t/* COMMENT_5 */\n                               \n       \n\t\t\t\t*VAR_1 = 0;\n\t\t\t\tVAR_7.state = VAR_9;\n\t\t\t} else\n\t\t\t\tVAR_7.state = VAR_26;\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLOG_ERR(\"DFU_UPLOAD wrong state %d\", VAR_7.state);\n\t\t\tVAR_7.state = VAR_19;\n\t\t\tVAR_7.status = VAR_24;\n\t\t\tdfu_reset_counters();\n\t\t\treturn -VAR_12;\n\t\t}\n\t\tbreak;\n\tcase VAR_29:\n\t\tLOG_DBG(\"DFU_DETACH timeout %d, state %d\",\n\t\t\tVAR_0->wValue, VAR_7.state);\n\n\t\tif (VAR_7.state != VAR_30) {\n\t\t\tVAR_7.state = VAR_30;\n\t\t\treturn -VAR_12;\n\t\t}\n\t\t/* COMMENT_8 */\n\t\tVAR_7.state = VAR_31;\n\n\t\t/* COMMENT_9 */\n                                                    \n                                                         \n                     \n     \n\n\t\t/* COMMENT_14 */\n\t\tVAR_32.usb_device_description = (u8_t *) &VAR_33;\n\t\tif (usb_set_config(VAR_32.usb_device_description) != 0) {\n\t\t\tLOG_ERR(\"usb_set_config failed in DFU_DETACH\");\n\t\t\treturn -VAR_34;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tLOG_WRN(\"DFU UNKNOWN STATE: %d\", VAR_0->bRequest);\n\t\treturn -VAR_12;\n\t}\n\n\treturn 0;\n}",
  "func_graph_path_before": "zephyrproject-rtos/zephyr/8183a87931538650f09c00d8d51fbc2236600646/usb_dfu.c/vul/before/0.json",
  "func": "static int dfu_class_handle_req(struct usb_setup_packet *pSetup,\n\t\ts32_t *data_len, u8_t **data)\n{\n\tint ret;\n\tu32_t len, bytes_left;\n\n\tswitch (pSetup->bRequest) {\n\tcase DFU_GETSTATUS:\n\t\tLOG_DBG(\"DFU_GETSTATUS: status %d, state %d\",\n\t\t\tdfu_data.status, dfu_data.state);\n\n\t\tif (dfu_data.state == dfuMANIFEST_SYNC) {\n\t\t\tdfu_data.state = dfuIDLE;\n\t\t}\n\n\t\t/* bStatus */\n\t\t(*data)[0] = dfu_data.status;\n\t\t/* bwPollTimeout */\n\t\tsys_put_le16(dfu_data.bwPollTimeout, &(*data)[1]);\n\t\t(*data)[3] = 0U;\n\t\t/* bState */\n\t\t(*data)[4] = dfu_data.state;\n\t\t/* iString */\n\t\t(*data)[5] = 0U;\n\t\t*data_len = 6;\n\t\tbreak;\n\n\tcase DFU_GETSTATE:\n\t\tLOG_DBG(\"DFU_GETSTATE\");\n\t\t(*data)[0] = dfu_data.state;\n\t\t*data_len = 1;\n\t\tbreak;\n\n\tcase DFU_ABORT:\n\t\tLOG_DBG(\"DFU_ABORT\");\n\n\t\tif (dfu_check_app_state()) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdfu_reset_counters();\n\t\tdfu_data.state = dfuIDLE;\n\t\tdfu_data.status = statusOK;\n\t\tbreak;\n\n\tcase DFU_CLRSTATUS:\n\t\tLOG_DBG(\"DFU_CLRSTATUS\");\n\n\t\tif (dfu_check_app_state()) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdfu_data.state = dfuIDLE;\n\t\tdfu_data.status = statusOK;\n\t\tbreak;\n\n\tcase DFU_DNLOAD:\n\t\tLOG_DBG(\"DFU_DNLOAD block %d, len %d, state %d\",\n\t\t\tpSetup->wValue, pSetup->wLength, dfu_data.state);\n\n\t\tif (dfu_check_app_state()) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tswitch (dfu_data.state) {\n\t\tcase dfuIDLE:\n\t\t\tLOG_DBG(\"DFU_DNLOAD start\");\n\t\t\tdfu_reset_counters();\n\t\t\tk_poll_signal_reset(&dfu_signal);\n\n\t\t\tif (dfu_data.flash_area_id !=\n\t\t\t    DT_FLASH_AREA_IMAGE_1_ID) {\n\t\t\t\tdfu_data.status = errWRITE;\n\t\t\t\tdfu_data.state = dfuERROR;\n\t\t\t\tLOG_ERR(\"This area can not be overwritten\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdfu_data.state = dfuDNBUSY;\n\t\t\tdfu_data_worker.worker_state = dfuIDLE;\n\t\t\tdfu_data_worker.worker_len  = pSetup->wLength;\n\t\t\tmemcpy(dfu_data_worker.buf, *data, pSetup->wLength);\n\t\t\tk_work_submit(&dfu_work);\n\t\t\tbreak;\n\t\tcase dfuDNLOAD_IDLE:\n\t\t\tdfu_data.state = dfuDNBUSY;\n\t\t\tdfu_data_worker.worker_state = dfuDNLOAD_IDLE;\n\t\t\tdfu_data_worker.worker_len  = pSetup->wLength;\n\t\t\tif (dfu_data_worker.worker_len == 0U) {\n\t\t\t\tdfu_data.state = dfuMANIFEST_SYNC;\n\t\t\t\tk_poll_signal_raise(&dfu_signal, 0);\n\t\t\t}\n\n\t\t\tmemcpy(dfu_data_worker.buf, *data, pSetup->wLength);\n\t\t\tk_work_submit(&dfu_work);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLOG_ERR(\"DFU_DNLOAD wrong state %d\", dfu_data.state);\n\t\t\tdfu_data.state = dfuERROR;\n\t\t\tdfu_data.status = errUNKNOWN;\n\t\t\tdfu_reset_counters();\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase DFU_UPLOAD:\n\t\tLOG_DBG(\"DFU_UPLOAD block %d, len %d, state %d\",\n\t\t\tpSetup->wValue, pSetup->wLength, dfu_data.state);\n\n\t\tif (dfu_check_app_state()) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tswitch (dfu_data.state) {\n\t\tcase dfuIDLE:\n\t\t\tdfu_reset_counters();\n\t\t\tLOG_DBG(\"DFU_UPLOAD start\");\n\t\tcase dfuUPLOAD_IDLE:\n\t\t\tif (!pSetup->wLength ||\n\t\t\t    dfu_data.block_nr != pSetup->wValue) {\n\t\t\t\tLOG_DBG(\"DFU_UPLOAD block %d, expected %d, \"\n\t\t\t\t\t\"len %d\", pSetup->wValue,\n\t\t\t\t\tdfu_data.block_nr, pSetup->wLength);\n\t\t\t\tdfu_data.state = dfuERROR;\n\t\t\t\tdfu_data.status = errUNKNOWN;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Upload in progress */\n\t\t\tbytes_left = dfu_data.flash_upload_size -\n\t\t\t\t     dfu_data.bytes_sent;\n\t\t\tif (bytes_left < pSetup->wLength) {\n\t\t\t\tlen = bytes_left;\n\t\t\t} else {\n\t\t\t\tlen = pSetup->wLength;\n\t\t\t}\n\n\t\t\tif (len > USB_DFU_MAX_XFER_SIZE) {\n\t\t\t\t/*\n\t\t\t\t * The host could requests more data as stated\n\t\t\t\t * in wTransferSize. Limit upload length to the\n\t\t\t\t * size of the request-buffer.\n\t\t\t\t */\n\t\t\t\tlen = USB_DFU_MAX_XFER_SIZE;\n\t\t\t}\n\n\t\t\tif (len) {\n\t\t\t\tconst struct flash_area *fa;\n\n\t\t\t\tret = flash_area_open(dfu_data.flash_area_id,\n\t\t\t\t\t\t      &fa);\n\t\t\t\tif (ret) {\n\t\t\t\t\tdfu_data.state = dfuERROR;\n\t\t\t\t\tdfu_data.status = errFILE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tret = flash_area_read(fa, dfu_data.bytes_sent,\n\t\t\t\t\t\t      *data, len);\n\t\t\t\tflash_area_close(fa);\n\t\t\t\tif (ret) {\n\t\t\t\t\tdfu_data.state = dfuERROR;\n\t\t\t\t\tdfu_data.status = errFILE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t*data_len = len;\n\n\t\t\tdfu_data.bytes_sent += len;\n\t\t\tdfu_data.block_nr++;\n\n\t\t\tif (dfu_data.bytes_sent == dfu_data.flash_upload_size &&\n\t\t\t    len < pSetup->wLength) {\n\t\t\t\t/* Upload completed when a\n\t\t\t\t * short packet is received\n\t\t\t\t */\n\t\t\t\t*data_len = 0;\n\t\t\t\tdfu_data.state = dfuIDLE;\n\t\t\t} else\n\t\t\t\tdfu_data.state = dfuUPLOAD_IDLE;\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLOG_ERR(\"DFU_UPLOAD wrong state %d\", dfu_data.state);\n\t\t\tdfu_data.state = dfuERROR;\n\t\t\tdfu_data.status = errUNKNOWN;\n\t\t\tdfu_reset_counters();\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase DFU_DETACH:\n\t\tLOG_DBG(\"DFU_DETACH timeout %d, state %d\",\n\t\t\tpSetup->wValue, dfu_data.state);\n\n\t\tif (dfu_data.state != appIDLE) {\n\t\t\tdfu_data.state = appIDLE;\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/* Move to appDETACH state */\n\t\tdfu_data.state = appDETACH;\n\n\t\t/* We should start a timer here but in order to\n\t\t * keep things simple and do not increase the size\n\t\t * we rely on the host to get us out of the appATTACHED\n\t\t * state if needed.\n\t\t */\n\n\t\t/* Set the DFU mode descriptors to be used after reset */\n\t\tdfu_config.usb_device_description = (u8_t *) &dfu_mode_desc;\n\t\tif (usb_set_config(dfu_config.usb_device_description) != 0) {\n\t\t\tLOG_ERR(\"usb_set_config failed in DFU_DETACH\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tLOG_WRN(\"DFU UNKNOWN STATE: %d\", pSetup->bRequest);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
  "abstract_func": "static int dfu_class_handle_req(struct usb_setup_packet *VAR_0,\n\t\ts32_t *VAR_1, u8_t **VAR_2)\n{\n\tint VAR_3;\n\tu32_t VAR_4, VAR_5;\n\n\tswitch (VAR_0->bRequest) {\n\tcase VAR_6:\n\t\tLOG_DBG(\"DFU_GETSTATUS: status %d, state %d\",\n\t\t\tVAR_7.status, VAR_7.state);\n\n\t\tif (VAR_7.state == VAR_8) {\n\t\t\tVAR_7.state = VAR_9;\n\t\t}\n\n\t\t/* COMMENT_0 */\n\t\t(*VAR_2)[0] = VAR_7.status;\n\t\t/* COMMENT_1 */\n\t\tsys_put_le16(VAR_7.bwPollTimeout, &(*VAR_2)[1]);\n\t\t(*VAR_2)[3] = 0U;\n\t\t/* COMMENT_2 */\n\t\t(*VAR_2)[4] = VAR_7.state;\n\t\t/* COMMENT_3 */\n\t\t(*VAR_2)[5] = 0U;\n\t\t*VAR_1 = 6;\n\t\tbreak;\n\n\tcase VAR_10:\n\t\tLOG_DBG(\"DFU_GETSTATE\");\n\t\t(*VAR_2)[0] = VAR_7.state;\n\t\t*VAR_1 = 1;\n\t\tbreak;\n\n\tcase VAR_11:\n\t\tLOG_DBG(\"DFU_ABORT\");\n\n\t\tif (dfu_check_app_state()) {\n\t\t\treturn -VAR_12;\n\t\t}\n\n\t\tdfu_reset_counters();\n\t\tVAR_7.state = VAR_9;\n\t\tVAR_7.status = VAR_13;\n\t\tbreak;\n\n\tcase VAR_14:\n\t\tLOG_DBG(\"DFU_CLRSTATUS\");\n\n\t\tif (dfu_check_app_state()) {\n\t\t\treturn -VAR_12;\n\t\t}\n\n\t\tVAR_7.state = VAR_9;\n\t\tVAR_7.status = VAR_13;\n\t\tbreak;\n\n\tcase VAR_15:\n\t\tLOG_DBG(\"DFU_DNLOAD block %d, len %d, state %d\",\n\t\t\tVAR_0->wValue, VAR_0->wLength, VAR_7.state);\n\n\t\tif (dfu_check_app_state()) {\n\t\t\treturn -VAR_12;\n\t\t}\n\n\t\tswitch (VAR_7.state) {\n\t\tcase VAR_9:\n\t\t\tLOG_DBG(\"DFU_DNLOAD start\");\n\t\t\tdfu_reset_counters();\n\t\t\tk_poll_signal_reset(&VAR_16);\n\n\t\t\tif (VAR_7.flash_area_id !=\n\t\t\t    VAR_17) {\n\t\t\t\tVAR_7.status = VAR_18;\n\t\t\t\tVAR_7.state = VAR_19;\n\t\t\t\tLOG_ERR(\"This area can not be overwritten\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tVAR_7.state = VAR_20;\n\t\t\tVAR_21.worker_state = VAR_9;\n\t\t\tVAR_21.worker_len  = VAR_0->wLength;\n\t\t\tmemcpy(VAR_21.buf, *VAR_2, VAR_0->wLength);\n\t\t\tk_work_submit(&VAR_22);\n\t\t\tbreak;\n\t\tcase VAR_23:\n\t\t\tVAR_7.state = VAR_20;\n\t\t\tVAR_21.worker_state = VAR_23;\n\t\t\tVAR_21.worker_len  = VAR_0->wLength;\n\t\t\tif (VAR_21.worker_len == 0U) {\n\t\t\t\tVAR_7.state = VAR_8;\n\t\t\t\tk_poll_signal_raise(&VAR_16, 0);\n\t\t\t}\n\n\t\t\tmemcpy(VAR_21.buf, *VAR_2, VAR_0->wLength);\n\t\t\tk_work_submit(&VAR_22);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLOG_ERR(\"DFU_DNLOAD wrong state %d\", VAR_7.state);\n\t\t\tVAR_7.state = VAR_19;\n\t\t\tVAR_7.status = VAR_24;\n\t\t\tdfu_reset_counters();\n\t\t\treturn -VAR_12;\n\t\t}\n\t\tbreak;\n\tcase VAR_25:\n\t\tLOG_DBG(\"DFU_UPLOAD block %d, len %d, state %d\",\n\t\t\tVAR_0->wValue, VAR_0->wLength, VAR_7.state);\n\n\t\tif (dfu_check_app_state()) {\n\t\t\treturn -VAR_12;\n\t\t}\n\n\t\tswitch (VAR_7.state) {\n\t\tcase VAR_9:\n\t\t\tdfu_reset_counters();\n\t\t\tLOG_DBG(\"DFU_UPLOAD start\");\n\t\tcase VAR_26:\n\t\t\tif (!VAR_0->wLength ||\n\t\t\t    VAR_7.block_nr != VAR_0->wValue) {\n\t\t\t\tLOG_DBG(\"DFU_UPLOAD block %d, expected %d, \"\n\t\t\t\t\t\"len %d\", VAR_0->wValue,\n\t\t\t\t\tVAR_7.block_nr, VAR_0->wLength);\n\t\t\t\tVAR_7.state = VAR_19;\n\t\t\t\tVAR_7.status = VAR_24;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* COMMENT_4 */\n\t\t\tVAR_5 = VAR_7.flash_upload_size -\n\t\t\t\t     VAR_7.bytes_sent;\n\t\t\tif (VAR_5 < VAR_0->wLength) {\n\t\t\t\tVAR_4 = VAR_5;\n\t\t\t} else {\n\t\t\t\tVAR_4 = VAR_0->wLength;\n\t\t\t}\n\n\t\t\tif (VAR_4 > VAR_27) {\n\t\t\t\t/* COMMENT_5 */\n                                                  \n                                                   \n                                  \n       \n\t\t\t\tVAR_4 = VAR_27;\n\t\t\t}\n\n\t\t\tif (VAR_4) {\n\t\t\t\tconst struct flash_area *VAR_28;\n\n\t\t\t\tVAR_3 = flash_area_open(VAR_7.flash_area_id,\n\t\t\t\t\t\t      &VAR_28);\n\t\t\t\tif (VAR_3) {\n\t\t\t\t\tVAR_7.state = VAR_19;\n\t\t\t\t\tVAR_7.status = VAR_29;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tVAR_3 = flash_area_read(VAR_28, VAR_7.bytes_sent,\n\t\t\t\t\t\t      *VAR_2, VAR_4);\n\t\t\t\tflash_area_close(VAR_28);\n\t\t\t\tif (VAR_3) {\n\t\t\t\t\tVAR_7.state = VAR_19;\n\t\t\t\t\tVAR_7.status = VAR_29;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t*VAR_1 = VAR_4;\n\n\t\t\tVAR_7.bytes_sent += VAR_4;\n\t\t\tVAR_7.block_nr++;\n\n\t\t\tif (VAR_7.bytes_sent == VAR_7.flash_upload_size &&\n\t\t\t    VAR_4 < VAR_0->wLength) {\n\t\t\t\t/* COMMENT_10 */\n                               \n       \n\t\t\t\t*VAR_1 = 0;\n\t\t\t\tVAR_7.state = VAR_9;\n\t\t\t} else\n\t\t\t\tVAR_7.state = VAR_26;\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLOG_ERR(\"DFU_UPLOAD wrong state %d\", VAR_7.state);\n\t\t\tVAR_7.state = VAR_19;\n\t\t\tVAR_7.status = VAR_24;\n\t\t\tdfu_reset_counters();\n\t\t\treturn -VAR_12;\n\t\t}\n\t\tbreak;\n\tcase VAR_30:\n\t\tLOG_DBG(\"DFU_DETACH timeout %d, state %d\",\n\t\t\tVAR_0->wValue, VAR_7.state);\n\n\t\tif (VAR_7.state != VAR_31) {\n\t\t\tVAR_7.state = VAR_31;\n\t\t\treturn -VAR_12;\n\t\t}\n\t\t/* COMMENT_13 */\n\t\tVAR_7.state = VAR_32;\n\n\t\t/* COMMENT_14 */\n                                                    \n                                                         \n                     \n     \n\n\t\t/* COMMENT_19 */\n\t\tVAR_33.usb_device_description = (u8_t *) &VAR_34;\n\t\tif (usb_set_config(VAR_33.usb_device_description) != 0) {\n\t\t\tLOG_ERR(\"usb_set_config failed in DFU_DETACH\");\n\t\t\treturn -VAR_35;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tLOG_WRN(\"DFU UNKNOWN STATE: %d\", VAR_0->bRequest);\n\t\treturn -VAR_12;\n\t}\n\n\treturn 0;\n}",
  "func_graph_path": "zephyrproject-rtos/zephyr/8183a87931538650f09c00d8d51fbc2236600646/usb_dfu.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -132,6 +132,15 @@\n \t\t\t\tlen = bytes_left;\n \t\t\t} else {\n \t\t\t\tlen = pSetup->wLength;\n+\t\t\t}\n+\n+\t\t\tif (len > USB_DFU_MAX_XFER_SIZE) {\n+\t\t\t\t/*\n+\t\t\t\t * The host could requests more data as stated\n+\t\t\t\t * in wTransferSize. Limit upload length to the\n+\t\t\t\t * size of the request-buffer.\n+\t\t\t\t */\n+\t\t\t\tlen = USB_DFU_MAX_XFER_SIZE;\n \t\t\t}\n \n \t\t\tif (len) {",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "\t\t\t}",
      "",
      "\t\t\tif (len > USB_DFU_MAX_XFER_SIZE) {",
      "\t\t\t\t/*",
      "\t\t\t\t * The host could requests more data as stated",
      "\t\t\t\t * in wTransferSize. Limit upload length to the",
      "\t\t\t\t * size of the request-buffer.",
      "\t\t\t\t */",
      "\t\t\t\tlen = USB_DFU_MAX_XFER_SIZE;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/zephyrproject-rtos/zephyr/pull/23190",
  "description": {
    "pr_info": {
      "title": "usb: dfu: check requested length (wLength) during DFU_UPLOAD",
      "number": 23190
    },
    "comment": [
      "During DFU_UPLOAD, the host could requests more data\r\nas stated in wTransferSize. Limit upload length to the\r\nsize of the request buffer (USB_REQUEST_BUFFER_SIZE)."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix;  \n**Confidence:** 0.95"
}