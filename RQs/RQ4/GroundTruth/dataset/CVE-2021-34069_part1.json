{
  "cve_id": "CVE-2021-34069",
  "cwe_ids": [
    "CWE-369"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "justdan96/tsMuxer",
  "commit_msg": "[bug] Division by 0\n\nEarly return when mh.group1_samplerate (Sample rate of first substream) is 0, to avoid division by 0 error.\r\n\r\nSolves issue #417 .",
  "commit_hash": "7b616604693387bc501b20f7c89944cb3534e001",
  "git_url": "https://github.com/justdan96/tsMuxer/commit/7b616604693387bc501b20f7c89944cb3534e001",
  "file_path": "tsMuxer/ac3Codec.cpp",
  "func_name": "AC3Codec::decodeDtsHdFrame",
  "func_before": "bool AC3Codec::decodeDtsHdFrame(uint8_t* buffer, uint8_t* end)\n{\n    if (end - buffer < 21)\n        return false;\n    int ratebits = 0;\n    BitStreamReader reader;\n    reader.setBuffer(buffer + 4, end);\n    if (reader.getBits(24) != HD_SYNC_WORLD) /* Sync words */\n        return false;\n    mh.stream_type = reader.getBits(8);\n\n    mh.subType = MLPHeaderInfo::stUnknown;\n    if (mh.stream_type == 0xbb)\n    {\n        mh.subType = MLPHeaderInfo::stMLP;\n        mh.group1_bits = mlp_quants[reader.getBits(4)];\n        mh.group2_bits = mlp_quants[reader.getBits(4)];\n        ratebits = reader.getBits(4);\n        mh.group1_samplerate = mlp_samplerate(ratebits);\n        mh.group2_samplerate = mlp_samplerate(reader.getBits(4));\n        reader.skipBits(11);\n        mh.channels_mlp = reader.getBits(5);\n        mh.channels = mlp_channels[mh.channels_mlp];\n    }\n    else if (mh.stream_type == 0xba)\n    {\n        mh.subType = MLPHeaderInfo::stTRUEHD;\n        mh.group1_bits = 24;  // TODO: Is this information actually conveyed anywhere?\n        mh.group2_bits = 0;\n        ratebits = reader.getBits(4);\n        mh.group1_samplerate = mlp_samplerate(ratebits);\n        mh.group2_samplerate = 0;\n        reader.skipBits(8);\n        mh.channels_thd_stream1 = reader.getBits(5);\n        reader.skipBits(2);\n        mh.channels_thd_stream2 = reader.getBits(13);\n\n        if (mh.channels_thd_stream2)\n            mh.channels = truehd_channels(mh.channels_thd_stream2);\n        else\n            mh.channels = truehd_channels(mh.channels_thd_stream1);\n    }\n    else\n        return false;\n\n    mh.access_unit_size = 40 << (ratebits & 7);\n    mh.access_unit_size_pow2 = 64 << (ratebits & 7);\n    mh.frame_duration_nano = mh.access_unit_size * 1000000000ll / mh.group1_samplerate;\n\n    reader.skipBits(32);\n    reader.skipBits(16);\n\n    mh.is_vbr = reader.getBit();\n    mh.peak_bitrate = (reader.getBits(15) * mh.group1_samplerate + 8) >> 4;\n    mh.num_substreams = reader.getBits(4);\n    // for (int i = 0; i < 11; ++i)\n    //\treader.skipBits(8);\n    // reader.skipBits(4);\n    // skip_bits_long(gb, 4 + 11 * 8);\n    return true;\n}",
  "abstract_func_before": "bool AC3Codec::decodeDtsHdFrame(uint8_t* VAR_0, uint8_t* VAR_1)\n{\n    if (VAR_1 - VAR_0 < 21)\n        return false;\n    int VAR_2 = 0;\n    BitStreamReader VAR_3;\n    VAR_3.setBuffer(VAR_0 + 4, VAR_1);\n    if (VAR_3.getBits(24) != VAR_4) /* COMMENT_0 */\n        return false;\n    VAR_5.stream_type = VAR_3.getBits(8);\n\n    VAR_5.subType = MLPHeaderInfo::stUnknown;\n    if (VAR_5.stream_type == 0xbb)\n    {\n        VAR_5.subType = MLPHeaderInfo::stMLP;\n        VAR_5.group1_bits = VAR_6[VAR_3.getBits(4)];\n        VAR_5.group2_bits = VAR_6[VAR_3.getBits(4)];\n        VAR_2 = VAR_3.getBits(4);\n        VAR_5.group1_samplerate = mlp_samplerate(VAR_2);\n        VAR_5.group2_samplerate = mlp_samplerate(VAR_3.getBits(4));\n        VAR_3.skipBits(11);\n        VAR_5.channels_mlp = VAR_3.getBits(5);\n        VAR_5.channels = VAR_7[VAR_5.channels_mlp];\n    }\n    else if (VAR_5.stream_type == 0xba)\n    {\n        VAR_5.subType = MLPHeaderInfo::stTRUEHD;\n        VAR_5.group1_bits = 24;  /* COMMENT_1 */\n        VAR_5.group2_bits = 0;\n        VAR_2 = VAR_3.getBits(4);\n        VAR_5.group1_samplerate = mlp_samplerate(VAR_2);\n        VAR_5.group2_samplerate = 0;\n        VAR_3.skipBits(8);\n        VAR_5.channels_thd_stream1 = VAR_3.getBits(5);\n        VAR_3.skipBits(2);\n        VAR_5.channels_thd_stream2 = VAR_3.getBits(13);\n\n        if (VAR_5.channels_thd_stream2)\n            VAR_5.channels = truehd_channels(VAR_5.channels_thd_stream2);\n        else\n            VAR_5.channels = truehd_channels(VAR_5.channels_thd_stream1);\n    }\n    else\n        return false;\n\n    VAR_5.access_unit_size = 40 << (VAR_2 & 7);\n    VAR_5.access_unit_size_pow2 = 64 << (VAR_2 & 7);\n    VAR_5.frame_duration_nano = VAR_5.access_unit_size * 1000000000ll / VAR_5.group1_samplerate;\n\n    VAR_3.skipBits(32);\n    VAR_3.skipBits(16);\n\n    VAR_5.is_vbr = VAR_3.getBit();\n    VAR_5.peak_bitrate = (VAR_3.getBits(15) * VAR_5.group1_samplerate + 8) >> 4;\n    VAR_5.num_substreams = VAR_3.getBits(4);\n    /* COMMENT_2 */\n    /* COMMENT_3 */\n    /* COMMENT_4 */\n    /* COMMENT_5 */\n    return true;\n}",
  "func_graph_path_before": "justdan96/tsMuxer/7b616604693387bc501b20f7c89944cb3534e001/ac3Codec.cpp/vul/before/0.json",
  "func": "bool AC3Codec::decodeDtsHdFrame(uint8_t* buffer, uint8_t* end)\n{\n    if (end - buffer < 21)\n        return false;\n    int ratebits = 0;\n    BitStreamReader reader;\n    reader.setBuffer(buffer + 4, end);\n    if (reader.getBits(24) != HD_SYNC_WORLD) /* Sync words */\n        return false;\n    mh.stream_type = reader.getBits(8);\n\n    mh.subType = MLPHeaderInfo::stUnknown;\n    if (mh.stream_type == 0xbb)\n    {\n        mh.subType = MLPHeaderInfo::stMLP;\n        mh.group1_bits = mlp_quants[reader.getBits(4)];\n        mh.group2_bits = mlp_quants[reader.getBits(4)];\n        ratebits = reader.getBits(4);\n        mh.group1_samplerate = mlp_samplerate(ratebits);\n        if (mh.group1_samplerate == 0)\n            return false;\n        mh.group2_samplerate = mlp_samplerate(reader.getBits(4));\n        reader.skipBits(11);\n        mh.channels_mlp = reader.getBits(5);\n        mh.channels = mlp_channels[mh.channels_mlp];\n    }\n    else if (mh.stream_type == 0xba)\n    {\n        mh.subType = MLPHeaderInfo::stTRUEHD;\n        mh.group1_bits = 24;  // TODO: Is this information actually conveyed anywhere?\n        mh.group2_bits = 0;\n        ratebits = reader.getBits(4);\n        mh.group1_samplerate = mlp_samplerate(ratebits);\n        if (mh.group1_samplerate == 0)\n            return false;\n        mh.group2_samplerate = 0;\n        reader.skipBits(8);\n        mh.channels_thd_stream1 = reader.getBits(5);\n        reader.skipBits(2);\n        mh.channels_thd_stream2 = reader.getBits(13);\n\n        if (mh.channels_thd_stream2)\n            mh.channels = truehd_channels(mh.channels_thd_stream2);\n        else\n            mh.channels = truehd_channels(mh.channels_thd_stream1);\n    }\n    else\n        return false;\n\n    mh.access_unit_size = 40 << (ratebits & 7);\n    mh.access_unit_size_pow2 = 64 << (ratebits & 7);\n    mh.frame_duration_nano = mh.access_unit_size * 1000000000ll / mh.group1_samplerate;\n\n    reader.skipBits(32);\n    reader.skipBits(16);\n\n    mh.is_vbr = reader.getBit();\n    mh.peak_bitrate = (reader.getBits(15) * mh.group1_samplerate + 8) >> 4;\n    mh.num_substreams = reader.getBits(4);\n    // for (int i = 0; i < 11; ++i)\n    //\treader.skipBits(8);\n    // reader.skipBits(4);\n    // skip_bits_long(gb, 4 + 11 * 8);\n    return true;\n}",
  "abstract_func": "bool AC3Codec::decodeDtsHdFrame(uint8_t* VAR_0, uint8_t* VAR_1)\n{\n    if (VAR_1 - VAR_0 < 21)\n        return false;\n    int VAR_2 = 0;\n    BitStreamReader VAR_3;\n    VAR_3.setBuffer(VAR_0 + 4, VAR_1);\n    if (VAR_3.getBits(24) != VAR_4) /* COMMENT_0 */\n        return false;\n    VAR_5.stream_type = VAR_3.getBits(8);\n\n    VAR_5.subType = MLPHeaderInfo::stUnknown;\n    if (VAR_5.stream_type == 0xbb)\n    {\n        VAR_5.subType = MLPHeaderInfo::stMLP;\n        VAR_5.group1_bits = VAR_6[VAR_3.getBits(4)];\n        VAR_5.group2_bits = VAR_6[VAR_3.getBits(4)];\n        VAR_2 = VAR_3.getBits(4);\n        VAR_5.group1_samplerate = mlp_samplerate(VAR_2);\n        if (VAR_5.group1_samplerate == 0)\n            return false;\n        VAR_5.group2_samplerate = mlp_samplerate(VAR_3.getBits(4));\n        VAR_3.skipBits(11);\n        VAR_5.channels_mlp = VAR_3.getBits(5);\n        VAR_5.channels = VAR_7[VAR_5.channels_mlp];\n    }\n    else if (VAR_5.stream_type == 0xba)\n    {\n        VAR_5.subType = MLPHeaderInfo::stTRUEHD;\n        VAR_5.group1_bits = 24;  /* COMMENT_1 */\n        VAR_5.group2_bits = 0;\n        VAR_2 = VAR_3.getBits(4);\n        VAR_5.group1_samplerate = mlp_samplerate(VAR_2);\n        if (VAR_5.group1_samplerate == 0)\n            return false;\n        VAR_5.group2_samplerate = 0;\n        VAR_3.skipBits(8);\n        VAR_5.channels_thd_stream1 = VAR_3.getBits(5);\n        VAR_3.skipBits(2);\n        VAR_5.channels_thd_stream2 = VAR_3.getBits(13);\n\n        if (VAR_5.channels_thd_stream2)\n            VAR_5.channels = truehd_channels(VAR_5.channels_thd_stream2);\n        else\n            VAR_5.channels = truehd_channels(VAR_5.channels_thd_stream1);\n    }\n    else\n        return false;\n\n    VAR_5.access_unit_size = 40 << (VAR_2 & 7);\n    VAR_5.access_unit_size_pow2 = 64 << (VAR_2 & 7);\n    VAR_5.frame_duration_nano = VAR_5.access_unit_size * 1000000000ll / VAR_5.group1_samplerate;\n\n    VAR_3.skipBits(32);\n    VAR_3.skipBits(16);\n\n    VAR_5.is_vbr = VAR_3.getBit();\n    VAR_5.peak_bitrate = (VAR_3.getBits(15) * VAR_5.group1_samplerate + 8) >> 4;\n    VAR_5.num_substreams = VAR_3.getBits(4);\n    /* COMMENT_2 */\n    /* COMMENT_3 */\n    /* COMMENT_4 */\n    /* COMMENT_5 */\n    return true;\n}",
  "func_graph_path": "justdan96/tsMuxer/7b616604693387bc501b20f7c89944cb3534e001/ac3Codec.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -17,6 +17,8 @@\n         mh.group2_bits = mlp_quants[reader.getBits(4)];\n         ratebits = reader.getBits(4);\n         mh.group1_samplerate = mlp_samplerate(ratebits);\n+        if (mh.group1_samplerate == 0)\n+            return false;\n         mh.group2_samplerate = mlp_samplerate(reader.getBits(4));\n         reader.skipBits(11);\n         mh.channels_mlp = reader.getBits(5);\n@@ -29,6 +31,8 @@\n         mh.group2_bits = 0;\n         ratebits = reader.getBits(4);\n         mh.group1_samplerate = mlp_samplerate(ratebits);\n+        if (mh.group1_samplerate == 0)\n+            return false;\n         mh.group2_samplerate = 0;\n         reader.skipBits(8);\n         mh.channels_thd_stream1 = reader.getBits(5);",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "        if (mh.group1_samplerate == 0)",
      "            return false;",
      "        if (mh.group1_samplerate == 0)",
      "            return false;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/justdan96/tsMuxer/pull/421",
  "description": {
    "pr_info": {
      "title": "[bug] Division by 0",
      "number": 421
    },
    "comment": [
      "Early return when `mh.group1_samplerate` (Sample rate of first substream) is 0, to avoid division by 0 error.\r\n\r\nSolves issues #417 and #428.",
      "Are there any knock-on effects to the early return?",
      "@justdan96 there shouldn't be: if the read sample rate is zero, then it means that the stream is not a MPL and the MPL parsing should be aborted."
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades;  \n**Confidence:** 0.9\n\n**Step-by-Step Explanation:**\n\n1. **Input Analysis:** The commit message and vulnerability description address a division by zero error, fixed by adding checks and returning early.\n\n2. **Consistency Check:** The code changes match the description, adding the necessary checks.\n\n3. **Purpose Evaluation:** The fix directly addresses a software bug preventing a crash, not a security issue.\n\n4. **Security Assessment:** Not a security fix as it prevents a crash, not an exploit.\n\n5. **Classification:** Non-security, classified under defect remediation.\n\n6. **Confidence Score:** High due to clear alignment of changes and description.\n\n**Final Output:**  \n**Final Classification:** Defect Remediation & Feature Upgrades;  \n**Confidence:** 0.9"
}