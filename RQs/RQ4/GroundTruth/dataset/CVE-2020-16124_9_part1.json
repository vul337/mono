{
  "cve_id": "CVE-2020-16124",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "ros/ros_comm",
  "commit_msg": "Trap for overly large input to XmlRPCPP which could cause problems with int <-> size_t conversions.\n\n - In XmlRpcClient, XmlRpcServerConnection and XmlRpcSocket, recognize when incoming or outgoing data is too large, generate an error and discard the data when practical.\n - Use the safe strtol() rather than atoi() to decode an incoming content-length header, and generate an error if the length is invalid or too large.\n - In XmlRpcUtil, prevent attempts to parse overly large XML input.\n - Add tests where they can reasonably be inserted into existing test routines.\n\nAlthough this fix could be cleaner the update is written to make the update ABI compatible.\n\nThis fix addresses CVE-2020-16124 / Integer overflow in ros_comm.\n\nSigned-off-by: Sid Faber <sid.faber@canonical.com>",
  "commit_hash": "3dd308911d7294bc6cff12f626b8467fe1555423",
  "git_url": "https://github.com/ros/ros_comm/commit/3dd308911d7294bc6cff12f626b8467fe1555423",
  "file_path": "utilities/xmlrpcpp/src/XmlRpcServerConnection.cpp",
  "func_name": "XmlRpcServerConnection::readHeader",
  "func_before": "bool\nXmlRpcServerConnection::readHeader()\n{\n  // Read available data\n  bool eof;\n  if ( ! XmlRpcSocket::nbRead(this->getfd(), _header, &eof)) {\n    // Its only an error if we already have read some data\n    if (_header.length() > 0)\n      XmlRpcUtil::error(\"XmlRpcServerConnection::readHeader: error while reading header (%s).\",XmlRpcSocket::getErrorMsg().c_str());\n    return false;\n  }\n\n  XmlRpcUtil::log(4, \"XmlRpcServerConnection::readHeader: read %d bytes.\", _header.length());\n  char *hp = (char*)_header.c_str();  // Start of header\n  char *ep = hp + _header.length();   // End of string\n  char *bp = 0;                       // Start of body\n  char *lp = 0;                       // Start of content-length value\n  char *kp = 0;                       // Start of connection value\n\n  for (char *cp = hp; (bp == 0) && (cp < ep); ++cp) {\n\tif ((ep - cp > 16) && (strncasecmp(cp, \"Content-length: \", 16) == 0))\n\t  lp = cp + 16;\n\telse if ((ep - cp > 12) && (strncasecmp(cp, \"Connection: \", 12) == 0))\n\t  kp = cp + 12;\n\telse if ((ep - cp > 4) && (strncmp(cp, \"\\r\\n\\r\\n\", 4) == 0))\n\t  bp = cp + 4;\n\telse if ((ep - cp > 2) && (strncmp(cp, \"\\n\\n\", 2) == 0))\n\t  bp = cp + 2;\n  }\n\n  // If we haven't gotten the entire header yet, return (keep reading)\n  if (bp == 0) {\n    // EOF in the middle of a request is an error, otherwise its ok\n    if (eof) {\n      XmlRpcUtil::log(4, \"XmlRpcServerConnection::readHeader: EOF\");\n      if (_header.length() > 0)\n        XmlRpcUtil::error(\"XmlRpcServerConnection::readHeader: EOF while reading header\");\n      return false;   // Either way we close the connection\n    }\n    \n    return true;  // Keep reading\n  }\n\n  // Decode content length\n  if (lp == 0) {\n    XmlRpcUtil::error(\"XmlRpcServerConnection::readHeader: No Content-length specified\");\n    return false;   // We could try to figure it out by parsing as we read, but for now...\n  }\n\n  _contentLength = atoi(lp);\n  if (_contentLength <= 0) {\n    XmlRpcUtil::error(\"XmlRpcServerConnection::readHeader: Invalid Content-length specified (%d).\", _contentLength);\n    return false;\n  }\n  \t\n  XmlRpcUtil::log(3, \"XmlRpcServerConnection::readHeader: specified content length is %d.\", _contentLength);\n\n  // Otherwise copy non-header data to request buffer and set state to read request.\n  _request = bp;\n\n  // Parse out any interesting bits from the header (HTTP version, connection)\n  _keepAlive = true;\n  if (_header.find(\"HTTP/1.0\") != std::string::npos) {\n    if (kp == 0 || strncasecmp(kp, \"keep-alive\", 10) != 0)\n      _keepAlive = false;           // Default for HTTP 1.0 is to close the connection\n  } else {\n    if (kp != 0 && strncasecmp(kp, \"close\", 5) == 0)\n      _keepAlive = false;\n  }\n  XmlRpcUtil::log(3, \"KeepAlive: %d\", _keepAlive);\n\n\n  _header = \"\"; \n  _connectionState = READ_REQUEST;\n  return true;    // Continue monitoring this source\n}",
  "abstract_func_before": "bool\nXmlRpcServerConnection::readHeader()\n{\n  /* COMMENT_0 */\n  bool VAR_0;\n  if ( ! XmlRpcSocket::nbRead(this->getfd(), VAR_1, &VAR_0)) {\n    /* COMMENT_1 */\n    if (VAR_1.length() > 0)\n      XmlRpcUtil::error(\"XmlRpcServerConnection::readHeader: error while reading header (%s).\",XmlRpcSocket::getErrorMsg().c_str());\n    return false;\n  }\n\n  XmlRpcUtil::log(4, \"XmlRpcServerConnection::readHeader: read %d bytes.\", VAR_1.length());\n  char *VAR_2 = (char*)VAR_1.c_str();  /* COMMENT_2 */\n  char *VAR_3 = VAR_2 + VAR_1.length();   /* COMMENT_3 */\n  char *VAR_4 = 0;                       /* COMMENT_4 */\n  char *VAR_5 = 0;                       /* COMMENT_5 */\n  char *VAR_6 = 0;                       /* COMMENT_6 */\n\n  for (char *VAR_7 = VAR_2; (VAR_4 == 0) && (VAR_7 < VAR_3); ++VAR_7) {\n\tif ((VAR_3 - VAR_7 > 16) && (strncasecmp(VAR_7, \"Content-length: \", 16) == 0))\n\t  VAR_5 = VAR_7 + 16;\n\telse if ((VAR_3 - VAR_7 > 12) && (strncasecmp(VAR_7, \"Connection: \", 12) == 0))\n\t  VAR_6 = VAR_7 + 12;\n\telse if ((VAR_3 - VAR_7 > 4) && (strncmp(VAR_7, \"\\r\\n\\r\\n\", 4) == 0))\n\t  VAR_4 = VAR_7 + 4;\n\telse if ((VAR_3 - VAR_7 > 2) && (strncmp(VAR_7, \"\\n\\n\", 2) == 0))\n\t  VAR_4 = VAR_7 + 2;\n  }\n\n  /* COMMENT_7 */\n  if (VAR_4 == 0) {\n    /* COMMENT_8 */\n    if (VAR_0) {\n      XmlRpcUtil::log(4, \"XmlRpcServerConnection::readHeader: EOF\");\n      if (VAR_1.length() > 0)\n        XmlRpcUtil::error(\"XmlRpcServerConnection::readHeader: EOF while reading header\");\n      return false;   /* COMMENT_9 */\n    }\n    \n    return true;  /* COMMENT_10 */\n  }\n\n  /* COMMENT_11 */\n  if (VAR_5 == 0) {\n    XmlRpcUtil::error(\"XmlRpcServerConnection::readHeader: No Content-length specified\");\n    return false;   /* COMMENT_12 */\n  }\n\n  VAR_8 = atoi(VAR_5);\n  if (VAR_8 <= 0) {\n    XmlRpcUtil::error(\"XmlRpcServerConnection::readHeader: Invalid Content-length specified (%d).\", VAR_8);\n    return false;\n  }\n  \t\n  XmlRpcUtil::log(3, \"XmlRpcServerConnection::readHeader: specified content length is %d.\", VAR_8);\n\n  /* COMMENT_13 */\n  VAR_9 = VAR_4;\n\n  /* COMMENT_14 */\n  VAR_10 = true;\n  if (VAR_1.find(\"HTTP/1.0\") != std::string::npos) {\n    if (VAR_6 == 0 || strncasecmp(VAR_6, \"keep-alive\", 10) != 0)\n      VAR_10 = false;           /* COMMENT_15 */\n  } else {\n    if (VAR_6 != 0 && strncasecmp(VAR_6, \"close\", 5) == 0)\n      VAR_10 = false;\n  }\n  XmlRpcUtil::log(3, \"KeepAlive: %d\", VAR_10);\n\n\n  VAR_1 = \"\"; \n  VAR_11 = VAR_12;\n  return true;    /* COMMENT_16 */\n}",
  "func_graph_path_before": "ros/ros_comm/3dd308911d7294bc6cff12f626b8467fe1555423/XmlRpcServerConnection.cpp/vul/before/1.json",
  "func": "bool\nXmlRpcServerConnection::readHeader()\n{\n  // Read available data\n  bool eof;\n  if ( ! XmlRpcSocket::nbRead(this->getfd(), _header, &eof)) {\n    // Its only an error if we already have read some data\n    if (_header.length() > 0)\n      XmlRpcUtil::error(\"XmlRpcServerConnection::readHeader: error while reading header (%s).\",XmlRpcSocket::getErrorMsg().c_str());\n    return false;\n  }\n\n  XmlRpcUtil::log(4, \"XmlRpcServerConnection::readHeader: read %d bytes.\", _header.length());\n  char *hp = (char*)_header.c_str();  // Start of header\n  char *ep = hp + _header.length();   // End of string\n  char *bp = 0;                       // Start of body\n  char *lp = 0;                       // Start of content-length value\n  char *kp = 0;                       // Start of connection value\n\n  for (char *cp = hp; (bp == 0) && (cp < ep); ++cp) {\n\tif ((ep - cp > 16) && (strncasecmp(cp, \"Content-length: \", 16) == 0))\n\t  lp = cp + 16;\n\telse if ((ep - cp > 12) && (strncasecmp(cp, \"Connection: \", 12) == 0))\n\t  kp = cp + 12;\n\telse if ((ep - cp > 4) && (strncmp(cp, \"\\r\\n\\r\\n\", 4) == 0))\n\t  bp = cp + 4;\n\telse if ((ep - cp > 2) && (strncmp(cp, \"\\n\\n\", 2) == 0))\n\t  bp = cp + 2;\n  }\n\n  // If we haven't gotten the entire header yet, return (keep reading)\n  if (bp == 0) {\n    // EOF in the middle of a request is an error, otherwise its ok\n    if (eof) {\n      XmlRpcUtil::log(4, \"XmlRpcServerConnection::readHeader: EOF\");\n      if (_header.length() > 0)\n        XmlRpcUtil::error(\"XmlRpcServerConnection::readHeader: EOF while reading header\");\n      return false;   // Either way we close the connection\n    }\n    \n    return true;  // Keep reading\n  }\n\n  // Decode content length\n  if (lp == 0) {\n    XmlRpcUtil::error(\"XmlRpcServerConnection::readHeader: No Content-length specified\");\n    return false;   // We could try to figure it out by parsing as we read, but for now...\n  }\n\n  // avoid overly large or improperly formatted content-length\n  long int clength = 0;\n  clength = strtol(lp, nullptr, 10);\n  if ((clength < 0) || (clength > __INT_MAX__)) {\n    XmlRpcUtil::error(\"XmlRpcServerConnection::readHeader: Invalid Content-length specified.\");\n    return false;\n  }\n  _contentLength = int(clength);\n  \t\n  XmlRpcUtil::log(3, \"XmlRpcServerConnection::readHeader: specified content length is %d.\", _contentLength);\n\n  // Otherwise copy non-header data to request buffer and set state to read request.\n  _request = bp;\n\n  // Parse out any interesting bits from the header (HTTP version, connection)\n  _keepAlive = true;\n  if (_header.find(\"HTTP/1.0\") != std::string::npos) {\n    if (kp == 0 || strncasecmp(kp, \"keep-alive\", 10) != 0)\n      _keepAlive = false;           // Default for HTTP 1.0 is to close the connection\n  } else {\n    if (kp != 0 && strncasecmp(kp, \"close\", 5) == 0)\n      _keepAlive = false;\n  }\n  XmlRpcUtil::log(3, \"KeepAlive: %d\", _keepAlive);\n\n\n  _header = \"\"; \n  _connectionState = READ_REQUEST;\n  return true;    // Continue monitoring this source\n}",
  "abstract_func": "bool\nXmlRpcServerConnection::readHeader()\n{\n  /* COMMENT_0 */\n  bool VAR_0;\n  if ( ! XmlRpcSocket::nbRead(this->getfd(), VAR_1, &VAR_0)) {\n    /* COMMENT_1 */\n    if (VAR_1.length() > 0)\n      XmlRpcUtil::error(\"XmlRpcServerConnection::readHeader: error while reading header (%s).\",XmlRpcSocket::getErrorMsg().c_str());\n    return false;\n  }\n\n  XmlRpcUtil::log(4, \"XmlRpcServerConnection::readHeader: read %d bytes.\", VAR_1.length());\n  char *VAR_2 = (char*)VAR_1.c_str();  /* COMMENT_2 */\n  char *VAR_3 = VAR_2 + VAR_1.length();   /* COMMENT_3 */\n  char *VAR_4 = 0;                       /* COMMENT_4 */\n  char *VAR_5 = 0;                       /* COMMENT_5 */\n  char *VAR_6 = 0;                       /* COMMENT_6 */\n\n  for (char *VAR_7 = VAR_2; (VAR_4 == 0) && (VAR_7 < VAR_3); ++VAR_7) {\n\tif ((VAR_3 - VAR_7 > 16) && (strncasecmp(VAR_7, \"Content-length: \", 16) == 0))\n\t  VAR_5 = VAR_7 + 16;\n\telse if ((VAR_3 - VAR_7 > 12) && (strncasecmp(VAR_7, \"Connection: \", 12) == 0))\n\t  VAR_6 = VAR_7 + 12;\n\telse if ((VAR_3 - VAR_7 > 4) && (strncmp(VAR_7, \"\\r\\n\\r\\n\", 4) == 0))\n\t  VAR_4 = VAR_7 + 4;\n\telse if ((VAR_3 - VAR_7 > 2) && (strncmp(VAR_7, \"\\n\\n\", 2) == 0))\n\t  VAR_4 = VAR_7 + 2;\n  }\n\n  /* COMMENT_7 */\n  if (VAR_4 == 0) {\n    /* COMMENT_8 */\n    if (VAR_0) {\n      XmlRpcUtil::log(4, \"XmlRpcServerConnection::readHeader: EOF\");\n      if (VAR_1.length() > 0)\n        XmlRpcUtil::error(\"XmlRpcServerConnection::readHeader: EOF while reading header\");\n      return false;   /* COMMENT_9 */\n    }\n    \n    return true;  /* COMMENT_10 */\n  }\n\n  /* COMMENT_11 */\n  if (VAR_5 == 0) {\n    XmlRpcUtil::error(\"XmlRpcServerConnection::readHeader: No Content-length specified\");\n    return false;   /* COMMENT_12 */\n  }\n\n  /* COMMENT_13 */\n  long int VAR_8 = 0;\n  VAR_8 = strtol(VAR_5, nullptr, 10);\n  if ((VAR_8 < 0) || (VAR_8 > VAR_9)) {\n    XmlRpcUtil::error(\"XmlRpcServerConnection::readHeader: Invalid Content-length specified.\");\n    return false;\n  }\n  VAR_10 = int(VAR_8);\n  \t\n  XmlRpcUtil::log(3, \"XmlRpcServerConnection::readHeader: specified content length is %d.\", VAR_10);\n\n  /* COMMENT_14 */\n  VAR_11 = VAR_4;\n\n  /* COMMENT_15 */\n  VAR_12 = true;\n  if (VAR_1.find(\"HTTP/1.0\") != std::string::npos) {\n    if (VAR_6 == 0 || strncasecmp(VAR_6, \"keep-alive\", 10) != 0)\n      VAR_12 = false;           /* COMMENT_16 */\n  } else {\n    if (VAR_6 != 0 && strncasecmp(VAR_6, \"close\", 5) == 0)\n      VAR_12 = false;\n  }\n  XmlRpcUtil::log(3, \"KeepAlive: %d\", VAR_12);\n\n\n  VAR_1 = \"\"; \n  VAR_13 = VAR_14;\n  return true;    /* COMMENT_17 */\n}",
  "func_graph_path": "ros/ros_comm/3dd308911d7294bc6cff12f626b8467fe1555423/XmlRpcServerConnection.cpp/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -47,11 +47,14 @@\n     return false;   // We could try to figure it out by parsing as we read, but for now...\n   }\n \n-  _contentLength = atoi(lp);\n-  if (_contentLength <= 0) {\n-    XmlRpcUtil::error(\"XmlRpcServerConnection::readHeader: Invalid Content-length specified (%d).\", _contentLength);\n+  // avoid overly large or improperly formatted content-length\n+  long int clength = 0;\n+  clength = strtol(lp, nullptr, 10);\n+  if ((clength < 0) || (clength > __INT_MAX__)) {\n+    XmlRpcUtil::error(\"XmlRpcServerConnection::readHeader: Invalid Content-length specified.\");\n     return false;\n   }\n+  _contentLength = int(clength);\n   \t\n   XmlRpcUtil::log(3, \"XmlRpcServerConnection::readHeader: specified content length is %d.\", _contentLength);\n ",
  "diff_line_info": {
    "deleted_lines": [
      "  _contentLength = atoi(lp);",
      "  if (_contentLength <= 0) {",
      "    XmlRpcUtil::error(\"XmlRpcServerConnection::readHeader: Invalid Content-length specified (%d).\", _contentLength);"
    ],
    "added_lines": [
      "  // avoid overly large or improperly formatted content-length",
      "  long int clength = 0;",
      "  clength = strtol(lp, nullptr, 10);",
      "  if ((clength < 0) || (clength > __INT_MAX__)) {",
      "    XmlRpcUtil::error(\"XmlRpcServerConnection::readHeader: Invalid Content-length specified.\");",
      "  _contentLength = int(clength);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/ros/ros_comm/pull/2065",
  "description": {
    "pr_info": {
      "title": "Trap for overly large input to XmlRPCPP",
      "number": 2065
    },
    "comment": [
      "Oversize input to XmlRPCPP could cause problems with int <-> size_t conversions.\r\n\r\n - Recognize when incoming or outgoing data is too large, generate an error and discard the data when practical.\r\n - Use the safe strtol() rather than atoi() to decode an incoming content-length header and generate an error if the length is invalid or too large.\r\n - Prevent attempts to parse overly large XML input.\r\n - Add tests where they can reasonably be inserted into existing test routines.\r\n\r\nAlthough this fix could be cleaner the update is written to make the update ABI compatible.\r\n\r\nThis fix addresses CVE-2020-16124 / Integer overflow in ros_comm.\r\n\r\nSigned-off-by: Sid Faber <sid.faber@canonical.com>",
      "> Atm CI is failing for two tests though.\r\n\r\n@dirk-thomas, thanks for the review. The overrun tests I added are causing memory allocation failures--they work on my local machine but I assume the CI tests don't expect to be handling 2Gb input values. Any suggestions on how best to handle, is it advisable to remove the overrun tests?",
      "> Any suggestions on how best to handle, is it advisable to remove the overrun tests?\r\n\r\nCan the code be written in a way that it fails gracefully if that much memory isn't available? Maybe marking the test as skipped.",
      "Debian Buster only has Googletest 1.8.1 which doesn't have `GTEST_SKIP`.\r\n\r\nThe `readResponse_oversize` test still fails in CI.",
      "I removed GTEST_SKIP, printed an error message but otherwise let the test succeed. Also I removed one test that was causing problems. The test_client routines for readResponse still run when objects are finalized; since the test object could be in an unpredictable state I couldn't find a good way to ignore the results.",
      "> I removed GTEST_SKIP, printed an error message but otherwise let the test succeed.\r\n\r\nThat sounds like a good fall backback behavior. Can you make this conditional based on if `GTEST_SKIP` is available? If it is use it to give better feedback, otherwise fall back to the error message / succeed.",
      "@dirk-thomas, I added the conditional statement in one of the tests but had to rip another one out--the Ubuntu tests started running long and got killed causing the whole module to fail. I think this is as good as I can get it unless you have any ideas on how to safely & consistently write tests for huge input strings.",
      "Sounds good to me. Thanks for the patch and for iterating on it."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}