{
  "cve_id": "CVE-2020-9308",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "libarchive",
  "commit_msg": "RAR5 reader: reject files that declare invalid header flags\n\nOne of the fields in RAR5's base block structure is the size of the\nheader. Some invalid files declare a 0 header size setting, which can\nconfuse the unpacker. Minimum header size for RAR5 base blocks is 7\nbytes (4 bytes for CRC, and 3 bytes for the rest), so block size of 0\nbytes should be rejected at header parsing stage.\n\nThe fix adds an error condition if header size of 0 bytes is detected.\nIn this case, the unpacker will not attempt to unpack the file, as the\nheader is corrupted.\n\nThe commit also adds OSSFuzz #20459 sample to test further regressions\nin this area.",
  "commit_hash": "94821008d6eea81e315c5881cdf739202961040a",
  "git_url": "https://github.com/libarchive/libarchive/commit/94821008d6eea81e315c5881cdf739202961040a",
  "file_path": "libarchive/archive_read_support_format_rar5.c",
  "func_name": "process_base_block",
  "func_before": "static int process_base_block(struct archive_read* a,\n    struct archive_entry* entry)\n{\n\tstruct rar5* rar = get_context(a);\n\tuint32_t hdr_crc, computed_crc;\n\tsize_t raw_hdr_size = 0, hdr_size_len, hdr_size;\n\tsize_t header_id = 0;\n\tsize_t header_flags = 0;\n\tconst uint8_t* p;\n\tint ret;\n\n\tenum HEADER_TYPE {\n\t\tHEAD_MARK    = 0x00, HEAD_MAIN  = 0x01, HEAD_FILE   = 0x02,\n\t\tHEAD_SERVICE = 0x03, HEAD_CRYPT = 0x04, HEAD_ENDARC = 0x05,\n\t\tHEAD_UNKNOWN = 0xff,\n\t};\n\n\t/* Skip any unprocessed data for this file. */\n\tret = skip_unprocessed_bytes(a);\n\tif(ret != ARCHIVE_OK)\n\t\treturn ret;\n\n\t/* Read the expected CRC32 checksum. */\n\tif(!read_u32(a, &hdr_crc)) {\n\t\treturn ARCHIVE_EOF;\n\t}\n\n\t/* Read header size. */\n\tif(!read_var_sized(a, &raw_hdr_size, &hdr_size_len)) {\n\t\treturn ARCHIVE_EOF;\n\t}\n\n\t/* Sanity check, maximum header size for RAR5 is 2MB. */\n\tif(raw_hdr_size > (2 * 1024 * 1024)) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Base block header is too large\");\n\n\t\treturn ARCHIVE_FATAL;\n\t}\n\n\thdr_size = raw_hdr_size + hdr_size_len;\n\n\t/* Read the whole header data into memory, maximum memory use here is\n\t * 2MB. */\n\tif(!read_ahead(a, hdr_size, &p)) {\n\t\treturn ARCHIVE_EOF;\n\t}\n\n\t/* Verify the CRC32 of the header data. */\n\tcomputed_crc = (uint32_t) crc32(0, p, (int) hdr_size);\n\tif(computed_crc != hdr_crc) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Header CRC error\");\n\n\t\treturn ARCHIVE_FATAL;\n\t}\n\n\t/* If the checksum is OK, we proceed with parsing. */\n\tif(ARCHIVE_OK != consume(a, hdr_size_len)) {\n\t\treturn ARCHIVE_EOF;\n\t}\n\n\tif(!read_var_sized(a, &header_id, NULL))\n\t\treturn ARCHIVE_EOF;\n\n\tif(!read_var_sized(a, &header_flags, NULL))\n\t\treturn ARCHIVE_EOF;\n\n\trar->generic.split_after = (header_flags & HFL_SPLIT_AFTER) > 0;\n\trar->generic.split_before = (header_flags & HFL_SPLIT_BEFORE) > 0;\n\trar->generic.size = (int)hdr_size;\n\trar->generic.last_header_id = (int)header_id;\n\trar->main.endarc = 0;\n\n\t/* Those are possible header ids in RARv5. */\n\tswitch(header_id) {\n\t\tcase HEAD_MAIN:\n\t\t\tret = process_head_main(a, rar, entry, header_flags);\n\n\t\t\t/* Main header doesn't have any files in it, so it's\n\t\t\t * pointless to return to the caller. Retry to next\n\t\t\t * header, which should be HEAD_FILE/HEAD_SERVICE. */\n\t\t\tif(ret == ARCHIVE_OK)\n\t\t\t\treturn ARCHIVE_RETRY;\n\n\t\t\treturn ret;\n\t\tcase HEAD_SERVICE:\n\t\t\tret = process_head_service(a, rar, entry, header_flags);\n\t\t\treturn ret;\n\t\tcase HEAD_FILE:\n\t\t\tret = process_head_file(a, rar, entry, header_flags);\n\t\t\treturn ret;\n\t\tcase HEAD_CRYPT:\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Encryption is not supported\");\n\t\t\treturn ARCHIVE_FATAL;\n\t\tcase HEAD_ENDARC:\n\t\t\trar->main.endarc = 1;\n\n\t\t\t/* After encountering an end of file marker, we need\n\t\t\t * to take into consideration if this archive is\n\t\t\t * continued in another file (i.e. is it part01.rar:\n\t\t\t * is there a part02.rar?) */\n\t\t\tif(rar->main.volume) {\n\t\t\t\t/* In case there is part02.rar, position the\n\t\t\t\t * read pointer in a proper place, so we can\n\t\t\t\t * resume parsing. */\n\t\t\t\tret = scan_for_signature(a);\n\t\t\t\tif(ret == ARCHIVE_FATAL) {\n\t\t\t\t\treturn ARCHIVE_EOF;\n\t\t\t\t} else {\n\t\t\t\t\tif(rar->vol.expected_vol_no ==\n\t\t\t\t\t    UINT_MAX) {\n\t\t\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t\t\t    \"Header error\");\n\t\t\t\t\t\t\treturn ARCHIVE_FATAL;\n\t\t\t\t\t}\n\n\t\t\t\t\trar->vol.expected_vol_no =\n\t\t\t\t\t    rar->main.vol_no + 1;\n\t\t\t\t\treturn ARCHIVE_OK;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn ARCHIVE_EOF;\n\t\t\t}\n\t\tcase HEAD_MARK:\n\t\t\treturn ARCHIVE_EOF;\n\t\tdefault:\n\t\t\tif((header_flags & HFL_SKIP_IF_UNKNOWN) == 0) {\n\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Header type error\");\n\t\t\t\treturn ARCHIVE_FATAL;\n\t\t\t} else {\n\t\t\t\t/* If the block is marked as 'skip if unknown',\n\t\t\t\t * do as the flag says: skip the block\n\t\t\t\t * instead on failing on it. */\n\t\t\t\treturn ARCHIVE_RETRY;\n\t\t\t}\n\t}\n\n#if !defined WIN32\n\t// Not reached.\n\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_PROGRAMMER,\n\t    \"Internal unpacker error\");\n\treturn ARCHIVE_FATAL;\n#endif\n}",
  "abstract_func_before": "static int process_base_block(struct archive_read* VAR_0,\n    struct archive_entry* VAR_1)\n{\n\tstruct rar5* VAR_2 = get_context(VAR_0);\n\tuint32_t VAR_3, VAR_4;\n\tsize_t VAR_5 = 0, VAR_6, VAR_7;\n\tsize_t VAR_8 = 0;\n\tsize_t VAR_9 = 0;\n\tconst uint8_t* VAR_10;\n\tint VAR_11;\n\n\tenum HEADER_TYPE {\n\t\tVAR_12    = 0x00, VAR_13  = 0x01, VAR_14   = 0x02,\n\t\tVAR_15 = 0x03, VAR_16 = 0x04, VAR_17 = 0x05,\n\t\tVAR_18 = 0xff,\n\t};\n\n\t/* COMMENT_0 */\n\tVAR_11 = skip_unprocessed_bytes(VAR_0);\n\tif(VAR_11 != VAR_19)\n\t\treturn VAR_11;\n\n\t/* COMMENT_1 */\n\tif(!read_u32(VAR_0, &VAR_3)) {\n\t\treturn VAR_20;\n\t}\n\n\t/* COMMENT_2 */\n\tif(!read_var_sized(VAR_0, &VAR_5, &VAR_6)) {\n\t\treturn VAR_20;\n\t}\n\n\t/* COMMENT_3 */\n\tif(VAR_5 > (2 * 1024 * 1024)) {\n\t\tarchive_set_error(&VAR_0->archive, VAR_21,\n\t\t    \"Base block header is too large\");\n\n\t\treturn VAR_22;\n\t}\n\n\tVAR_7 = VAR_5 + VAR_6;\n\n\t/* COMMENT_4 */\n           \n\tif(!read_ahead(VAR_0, VAR_7, &VAR_10)) {\n\t\treturn VAR_20;\n\t}\n\n\t/* COMMENT_6 */\n\tVAR_4 = (uint32_t) crc32(0, VAR_10, (int) VAR_7);\n\tif(VAR_4 != VAR_3) {\n\t\tarchive_set_error(&VAR_0->archive, VAR_21,\n\t\t    \"Header CRC error\");\n\n\t\treturn VAR_22;\n\t}\n\n\t/* COMMENT_7 */\n\tif(VAR_19 != consume(VAR_0, VAR_6)) {\n\t\treturn VAR_20;\n\t}\n\n\tif(!read_var_sized(VAR_0, &VAR_8, NULL))\n\t\treturn VAR_20;\n\n\tif(!read_var_sized(VAR_0, &VAR_9, NULL))\n\t\treturn VAR_20;\n\n\tVAR_2->generic.split_after = (VAR_9 & VAR_23) > 0;\n\tVAR_2->generic.split_before = (VAR_9 & VAR_24) > 0;\n\tVAR_2->generic.size = (int)VAR_7;\n\tVAR_2->generic.last_header_id = (int)VAR_8;\n\tVAR_2->main.endarc = 0;\n\n\t/* COMMENT_8 */\n\tswitch(VAR_8) {\n\t\tcase VAR_13:\n\t\t\tVAR_11 = process_head_main(VAR_0, VAR_2, VAR_1, VAR_9);\n\n\t\t\t/* COMMENT_9 */\n                                                      \n                                                        \n\t\t\tif(VAR_11 == VAR_19)\n\t\t\t\treturn VAR_25;\n\n\t\t\treturn VAR_11;\n\t\tcase VAR_15:\n\t\t\tVAR_11 = process_head_service(VAR_0, VAR_2, VAR_1, VAR_9);\n\t\t\treturn VAR_11;\n\t\tcase VAR_14:\n\t\t\tVAR_11 = process_head_file(VAR_0, VAR_2, VAR_1, VAR_9);\n\t\t\treturn VAR_11;\n\t\tcase VAR_16:\n\t\t\tarchive_set_error(&VAR_0->archive,\n\t\t\t    VAR_21,\n\t\t\t    \"Encryption is not supported\");\n\t\t\treturn VAR_22;\n\t\tcase VAR_17:\n\t\t\tVAR_2->main.endarc = 1;\n\n\t\t\t/* COMMENT_12 */\n                                                   \n                                                       \n                                \n\t\t\tif(VAR_2->main.volume) {\n\t\t\t\t/* COMMENT_16 */\n                                                \n                         \n\t\t\t\tVAR_11 = scan_for_signature(VAR_0);\n\t\t\t\tif(VAR_11 == VAR_22) {\n\t\t\t\t\treturn VAR_20;\n\t\t\t\t} else {\n\t\t\t\t\tif(VAR_2->vol.expected_vol_no ==\n\t\t\t\t\t    VAR_26) {\n\t\t\t\t\t\tarchive_set_error(&VAR_0->archive,\n\t\t\t\t\t\t    VAR_21,\n\t\t\t\t\t\t    \"Header error\");\n\t\t\t\t\t\t\treturn VAR_22;\n\t\t\t\t\t}\n\n\t\t\t\t\tVAR_2->vol.expected_vol_no =\n\t\t\t\t\t    VAR_2->main.vol_no + 1;\n\t\t\t\t\treturn VAR_19;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn VAR_20;\n\t\t\t}\n\t\tcase VAR_12:\n\t\t\treturn VAR_20;\n\t\tdefault:\n\t\t\tif((VAR_9 & VAR_27) == 0) {\n\t\t\t\tarchive_set_error(&VAR_0->archive,\n\t\t\t\t    VAR_21,\n\t\t\t\t    \"Header type error\");\n\t\t\t\treturn VAR_22;\n\t\t\t} else {\n\t\t\t\t/* COMMENT_19 */\n                                          \n                                   \n\t\t\t\treturn VAR_25;\n\t\t\t}\n\t}\n\n#if !defined VAR_28\n\t/* COMMENT_22 */\n\tarchive_set_error(&VAR_0->archive, VAR_29,\n\t    \"Internal unpacker error\");\n\treturn VAR_22;\n#endif\n}",
  "func_graph_path_before": "libarchive/94821008d6eea81e315c5881cdf739202961040a/archive_read_support_format_rar5.c/vul/before/0.json",
  "func": "static int process_base_block(struct archive_read* a,\n    struct archive_entry* entry)\n{\n\tconst size_t SMALLEST_RAR5_BLOCK_SIZE = 3;\n\n\tstruct rar5* rar = get_context(a);\n\tuint32_t hdr_crc, computed_crc;\n\tsize_t raw_hdr_size = 0, hdr_size_len, hdr_size;\n\tsize_t header_id = 0;\n\tsize_t header_flags = 0;\n\tconst uint8_t* p;\n\tint ret;\n\n\tenum HEADER_TYPE {\n\t\tHEAD_MARK    = 0x00, HEAD_MAIN  = 0x01, HEAD_FILE   = 0x02,\n\t\tHEAD_SERVICE = 0x03, HEAD_CRYPT = 0x04, HEAD_ENDARC = 0x05,\n\t\tHEAD_UNKNOWN = 0xff,\n\t};\n\n\t/* Skip any unprocessed data for this file. */\n\tret = skip_unprocessed_bytes(a);\n\tif(ret != ARCHIVE_OK)\n\t\treturn ret;\n\n\t/* Read the expected CRC32 checksum. */\n\tif(!read_u32(a, &hdr_crc)) {\n\t\treturn ARCHIVE_EOF;\n\t}\n\n\t/* Read header size. */\n\tif(!read_var_sized(a, &raw_hdr_size, &hdr_size_len)) {\n\t\treturn ARCHIVE_EOF;\n\t}\n\n\thdr_size = raw_hdr_size + hdr_size_len;\n\n\t/* Sanity check, maximum header size for RAR5 is 2MB. */\n\tif(hdr_size > (2 * 1024 * 1024)) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Base block header is too large\");\n\n\t\treturn ARCHIVE_FATAL;\n\t}\n\n\t/* Additional sanity checks to weed out invalid files. */\n\tif(raw_hdr_size == 0 || hdr_size_len == 0 ||\n\t\thdr_size < SMALLEST_RAR5_BLOCK_SIZE)\n\t{\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Too small block encountered (%ld bytes)\",\n\t\t    raw_hdr_size);\n\n\t\treturn ARCHIVE_FATAL;\n\t}\n\n\t/* Read the whole header data into memory, maximum memory use here is\n\t * 2MB. */\n\tif(!read_ahead(a, hdr_size, &p)) {\n\t\treturn ARCHIVE_EOF;\n\t}\n\n\t/* Verify the CRC32 of the header data. */\n\tcomputed_crc = (uint32_t) crc32(0, p, (int) hdr_size);\n\tif(computed_crc != hdr_crc) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Header CRC error\");\n\n\t\treturn ARCHIVE_FATAL;\n\t}\n\n\t/* If the checksum is OK, we proceed with parsing. */\n\tif(ARCHIVE_OK != consume(a, hdr_size_len)) {\n\t\treturn ARCHIVE_EOF;\n\t}\n\n\tif(!read_var_sized(a, &header_id, NULL))\n\t\treturn ARCHIVE_EOF;\n\n\tif(!read_var_sized(a, &header_flags, NULL))\n\t\treturn ARCHIVE_EOF;\n\n\trar->generic.split_after = (header_flags & HFL_SPLIT_AFTER) > 0;\n\trar->generic.split_before = (header_flags & HFL_SPLIT_BEFORE) > 0;\n\trar->generic.size = (int)hdr_size;\n\trar->generic.last_header_id = (int)header_id;\n\trar->main.endarc = 0;\n\n\t/* Those are possible header ids in RARv5. */\n\tswitch(header_id) {\n\t\tcase HEAD_MAIN:\n\t\t\tret = process_head_main(a, rar, entry, header_flags);\n\n\t\t\t/* Main header doesn't have any files in it, so it's\n\t\t\t * pointless to return to the caller. Retry to next\n\t\t\t * header, which should be HEAD_FILE/HEAD_SERVICE. */\n\t\t\tif(ret == ARCHIVE_OK)\n\t\t\t\treturn ARCHIVE_RETRY;\n\n\t\t\treturn ret;\n\t\tcase HEAD_SERVICE:\n\t\t\tret = process_head_service(a, rar, entry, header_flags);\n\t\t\treturn ret;\n\t\tcase HEAD_FILE:\n\t\t\tret = process_head_file(a, rar, entry, header_flags);\n\t\t\treturn ret;\n\t\tcase HEAD_CRYPT:\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Encryption is not supported\");\n\t\t\treturn ARCHIVE_FATAL;\n\t\tcase HEAD_ENDARC:\n\t\t\trar->main.endarc = 1;\n\n\t\t\t/* After encountering an end of file marker, we need\n\t\t\t * to take into consideration if this archive is\n\t\t\t * continued in another file (i.e. is it part01.rar:\n\t\t\t * is there a part02.rar?) */\n\t\t\tif(rar->main.volume) {\n\t\t\t\t/* In case there is part02.rar, position the\n\t\t\t\t * read pointer in a proper place, so we can\n\t\t\t\t * resume parsing. */\n\t\t\t\tret = scan_for_signature(a);\n\t\t\t\tif(ret == ARCHIVE_FATAL) {\n\t\t\t\t\treturn ARCHIVE_EOF;\n\t\t\t\t} else {\n\t\t\t\t\tif(rar->vol.expected_vol_no ==\n\t\t\t\t\t    UINT_MAX) {\n\t\t\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t\t\t    \"Header error\");\n\t\t\t\t\t\t\treturn ARCHIVE_FATAL;\n\t\t\t\t\t}\n\n\t\t\t\t\trar->vol.expected_vol_no =\n\t\t\t\t\t    rar->main.vol_no + 1;\n\t\t\t\t\treturn ARCHIVE_OK;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn ARCHIVE_EOF;\n\t\t\t}\n\t\tcase HEAD_MARK:\n\t\t\treturn ARCHIVE_EOF;\n\t\tdefault:\n\t\t\tif((header_flags & HFL_SKIP_IF_UNKNOWN) == 0) {\n\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Header type error\");\n\t\t\t\treturn ARCHIVE_FATAL;\n\t\t\t} else {\n\t\t\t\t/* If the block is marked as 'skip if unknown',\n\t\t\t\t * do as the flag says: skip the block\n\t\t\t\t * instead on failing on it. */\n\t\t\t\treturn ARCHIVE_RETRY;\n\t\t\t}\n\t}\n\n#if !defined WIN32\n\t// Not reached.\n\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_PROGRAMMER,\n\t    \"Internal unpacker error\");\n\treturn ARCHIVE_FATAL;\n#endif\n}",
  "abstract_func": "static int process_base_block(struct archive_read* VAR_0,\n    struct archive_entry* VAR_1)\n{\n\tconst size_t VAR_2 = 3;\n\n\tstruct rar5* VAR_3 = get_context(VAR_0);\n\tuint32_t VAR_4, VAR_5;\n\tsize_t VAR_6 = 0, VAR_7, VAR_8;\n\tsize_t VAR_9 = 0;\n\tsize_t VAR_10 = 0;\n\tconst uint8_t* VAR_11;\n\tint VAR_12;\n\n\tenum HEADER_TYPE {\n\t\tVAR_13    = 0x00, VAR_14  = 0x01, VAR_15   = 0x02,\n\t\tVAR_16 = 0x03, VAR_17 = 0x04, VAR_18 = 0x05,\n\t\tVAR_19 = 0xff,\n\t};\n\n\t/* COMMENT_0 */\n\tVAR_12 = skip_unprocessed_bytes(VAR_0);\n\tif(VAR_12 != VAR_20)\n\t\treturn VAR_12;\n\n\t/* COMMENT_1 */\n\tif(!read_u32(VAR_0, &VAR_4)) {\n\t\treturn VAR_21;\n\t}\n\n\t/* COMMENT_2 */\n\tif(!read_var_sized(VAR_0, &VAR_6, &VAR_7)) {\n\t\treturn VAR_21;\n\t}\n\n\tVAR_8 = VAR_6 + VAR_7;\n\n\t/* COMMENT_3 */\n\tif(VAR_8 > (2 * 1024 * 1024)) {\n\t\tarchive_set_error(&VAR_0->archive, VAR_22,\n\t\t    \"Base block header is too large\");\n\n\t\treturn VAR_23;\n\t}\n\n\t/* COMMENT_4 */\n\tif(VAR_6 == 0 || VAR_7 == 0 ||\n\t\tVAR_8 < VAR_2)\n\t{\n\t\tarchive_set_error(&VAR_0->archive, VAR_22,\n\t\t    \"Too small block encountered (%ld bytes)\",\n\t\t    VAR_6);\n\n\t\treturn VAR_23;\n\t}\n\n\t/* COMMENT_5 */\n           \n\tif(!read_ahead(VAR_0, VAR_8, &VAR_11)) {\n\t\treturn VAR_21;\n\t}\n\n\t/* COMMENT_7 */\n\tVAR_5 = (uint32_t) crc32(0, VAR_11, (int) VAR_8);\n\tif(VAR_5 != VAR_4) {\n\t\tarchive_set_error(&VAR_0->archive, VAR_22,\n\t\t    \"Header CRC error\");\n\n\t\treturn VAR_23;\n\t}\n\n\t/* COMMENT_8 */\n\tif(VAR_20 != consume(VAR_0, VAR_7)) {\n\t\treturn VAR_21;\n\t}\n\n\tif(!read_var_sized(VAR_0, &VAR_9, NULL))\n\t\treturn VAR_21;\n\n\tif(!read_var_sized(VAR_0, &VAR_10, NULL))\n\t\treturn VAR_21;\n\n\tVAR_3->generic.split_after = (VAR_10 & VAR_24) > 0;\n\tVAR_3->generic.split_before = (VAR_10 & VAR_25) > 0;\n\tVAR_3->generic.size = (int)VAR_8;\n\tVAR_3->generic.last_header_id = (int)VAR_9;\n\tVAR_3->main.endarc = 0;\n\n\t/* COMMENT_9 */\n\tswitch(VAR_9) {\n\t\tcase VAR_14:\n\t\t\tVAR_12 = process_head_main(VAR_0, VAR_3, VAR_1, VAR_10);\n\n\t\t\t/* COMMENT_10 */\n                                                      \n                                                        \n\t\t\tif(VAR_12 == VAR_20)\n\t\t\t\treturn VAR_26;\n\n\t\t\treturn VAR_12;\n\t\tcase VAR_16:\n\t\t\tVAR_12 = process_head_service(VAR_0, VAR_3, VAR_1, VAR_10);\n\t\t\treturn VAR_12;\n\t\tcase VAR_15:\n\t\t\tVAR_12 = process_head_file(VAR_0, VAR_3, VAR_1, VAR_10);\n\t\t\treturn VAR_12;\n\t\tcase VAR_17:\n\t\t\tarchive_set_error(&VAR_0->archive,\n\t\t\t    VAR_22,\n\t\t\t    \"Encryption is not supported\");\n\t\t\treturn VAR_23;\n\t\tcase VAR_18:\n\t\t\tVAR_3->main.endarc = 1;\n\n\t\t\t/* COMMENT_13 */\n                                                   \n                                                       \n                                \n\t\t\tif(VAR_3->main.volume) {\n\t\t\t\t/* COMMENT_17 */\n                                                \n                         \n\t\t\t\tVAR_12 = scan_for_signature(VAR_0);\n\t\t\t\tif(VAR_12 == VAR_23) {\n\t\t\t\t\treturn VAR_21;\n\t\t\t\t} else {\n\t\t\t\t\tif(VAR_3->vol.expected_vol_no ==\n\t\t\t\t\t    VAR_27) {\n\t\t\t\t\t\tarchive_set_error(&VAR_0->archive,\n\t\t\t\t\t\t    VAR_22,\n\t\t\t\t\t\t    \"Header error\");\n\t\t\t\t\t\t\treturn VAR_23;\n\t\t\t\t\t}\n\n\t\t\t\t\tVAR_3->vol.expected_vol_no =\n\t\t\t\t\t    VAR_3->main.vol_no + 1;\n\t\t\t\t\treturn VAR_20;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn VAR_21;\n\t\t\t}\n\t\tcase VAR_13:\n\t\t\treturn VAR_21;\n\t\tdefault:\n\t\t\tif((VAR_10 & VAR_28) == 0) {\n\t\t\t\tarchive_set_error(&VAR_0->archive,\n\t\t\t\t    VAR_22,\n\t\t\t\t    \"Header type error\");\n\t\t\t\treturn VAR_23;\n\t\t\t} else {\n\t\t\t\t/* COMMENT_20 */\n                                          \n                                   \n\t\t\t\treturn VAR_26;\n\t\t\t}\n\t}\n\n#if !defined VAR_29\n\t/* COMMENT_23 */\n\tarchive_set_error(&VAR_0->archive, VAR_30,\n\t    \"Internal unpacker error\");\n\treturn VAR_23;\n#endif\n}",
  "func_graph_path": "libarchive/94821008d6eea81e315c5881cdf739202961040a/archive_read_support_format_rar5.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,8 @@\n static int process_base_block(struct archive_read* a,\n     struct archive_entry* entry)\n {\n+\tconst size_t SMALLEST_RAR5_BLOCK_SIZE = 3;\n+\n \tstruct rar5* rar = get_context(a);\n \tuint32_t hdr_crc, computed_crc;\n \tsize_t raw_hdr_size = 0, hdr_size_len, hdr_size;\n@@ -30,15 +32,26 @@\n \t\treturn ARCHIVE_EOF;\n \t}\n \n+\thdr_size = raw_hdr_size + hdr_size_len;\n+\n \t/* Sanity check, maximum header size for RAR5 is 2MB. */\n-\tif(raw_hdr_size > (2 * 1024 * 1024)) {\n+\tif(hdr_size > (2 * 1024 * 1024)) {\n \t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n \t\t    \"Base block header is too large\");\n \n \t\treturn ARCHIVE_FATAL;\n \t}\n \n-\thdr_size = raw_hdr_size + hdr_size_len;\n+\t/* Additional sanity checks to weed out invalid files. */\n+\tif(raw_hdr_size == 0 || hdr_size_len == 0 ||\n+\t\thdr_size < SMALLEST_RAR5_BLOCK_SIZE)\n+\t{\n+\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n+\t\t    \"Too small block encountered (%ld bytes)\",\n+\t\t    raw_hdr_size);\n+\n+\t\treturn ARCHIVE_FATAL;\n+\t}\n \n \t/* Read the whole header data into memory, maximum memory use here is\n \t * 2MB. */",
  "diff_line_info": {
    "deleted_lines": [
      "\tif(raw_hdr_size > (2 * 1024 * 1024)) {",
      "\thdr_size = raw_hdr_size + hdr_size_len;"
    ],
    "added_lines": [
      "\tconst size_t SMALLEST_RAR5_BLOCK_SIZE = 3;",
      "",
      "\thdr_size = raw_hdr_size + hdr_size_len;",
      "",
      "\tif(hdr_size > (2 * 1024 * 1024)) {",
      "\t/* Additional sanity checks to weed out invalid files. */",
      "\tif(raw_hdr_size == 0 || hdr_size_len == 0 ||",
      "\t\thdr_size < SMALLEST_RAR5_BLOCK_SIZE)",
      "\t{",
      "\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,",
      "\t\t    \"Too small block encountered (%ld bytes)\",",
      "\t\t    raw_hdr_size);",
      "",
      "\t\treturn ARCHIVE_FATAL;",
      "\t}"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libarchive/libarchive/pull/1326",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/libarchive/libarchive/pull/1326: 403 Client Error: Forbidden for url: https://api.github.com/repos/libarchive/libarchive/pulls/1326",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Step1: Input Analysis**  \nThe commit message discusses rejecting files with invalid header flags in RAR5, specifically when the header size is 0. The code diff adds checks for a minimum header size and includes testing with OSSFuzz.\n\n**Step2: Consistency Check**  \nThe description and code changes align well. They both introduce checks for header validation and add test cases.\n\n**Step3: Purpose Evaluation**  \nThe patch aims to prevent processing corrupted RAR5 files by adding error conditions, which directly addresses a security concern.\n\n**Step4: Security Vulnerability Assessment**  \nThe changes fix an issue where invalid files could confuse the unpacker, preventing potential exploitation.\n\n**Step5: Non-Security Classification**  \nNot applicable, as it's a security fix.\n\n**Step6: Confidence Scoring**  \nConfidence is high (0.9) due to clear alignment between commit message, vulnerability description, and code changes.\n\n**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.9"
}