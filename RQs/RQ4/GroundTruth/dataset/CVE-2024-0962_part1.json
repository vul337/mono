{
  "cve_id": "CVE-2024-0962",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "obgm/libcoap",
  "commit_msg": "coap_oscore.c: Fix parsing OSCORE configuration information",
  "commit_hash": "bf6a303883bde40cf96b960c8574cddd89e71701",
  "git_url": "https://github.com/obgm/libcoap/commit/bf6a303883bde40cf96b960c8574cddd89e71701",
  "file_path": "src/coap_oscore.c",
  "func_name": "get_split_entry",
  "func_before": "static int\nget_split_entry(const char **start,\n                size_t size,\n                coap_str_const_t *keyword,\n                oscore_value_t *value) {\n  const char *begin = *start;\n  const char *end;\n  const char *split;\n  size_t i;\n\nretry:\n  end = memchr(begin, '\\n', size);\n  if (end == NULL)\n    return 0;\n\n  /* Track beginning of next line */\n  *start = end + 1;\n  if (end > begin && end[-1] == '\\r')\n    end--;\n\n  if (begin[0] == '#' || (end - begin) == 0) {\n    /* Skip comment / blank line */\n    size -= end - begin + 1;\n    begin = *start;\n    goto retry;\n  }\n\n  /* Get in the keyword */\n  split = memchr(begin, ',', end - begin);\n  if (split == NULL)\n    goto bad_entry;\n\n  keyword->s = (const uint8_t *)begin;\n  keyword->length = split - begin;\n\n  begin = split + 1;\n  if ((end - begin) == 0)\n    goto bad_entry;\n  /* Get in the encoding */\n  split = memchr(begin, ',', end - begin);\n  if (split == NULL)\n    goto bad_entry;\n\n  for (i = 0; oscore_encoding[i].name.s; i++) {\n    coap_str_const_t temp = { split - begin, (const uint8_t *)begin };\n\n    if (coap_string_equal(&temp, &oscore_encoding[i].name)) {\n      value->encoding = oscore_encoding[i].encoding;\n      value->encoding_name = (const char *)oscore_encoding[i].name.s;\n      break;\n    }\n  }\n  if (oscore_encoding[i].name.s == NULL)\n    goto bad_entry;\n\n  begin = split + 1;\n  if ((end - begin) == 0)\n    goto bad_entry;\n  /* Get in the keyword's value */\n  if (begin[0] == '\"') {\n    split = memchr(&begin[1], '\"', end - split - 1);\n    if (split == NULL)\n      goto bad_entry;\n    end = split;\n    begin++;\n  }\n  switch (value->encoding) {\n  case COAP_ENC_ASCII:\n    value->u.value_bin =\n        coap_new_bin_const((const uint8_t *)begin, end - begin);\n    break;\n  case COAP_ENC_HEX:\n    /* Parse the hex into binary */\n    value->u.value_bin = parse_hex_bin(begin, end);\n    if (value->u.value_bin == NULL)\n      goto bad_entry;\n    break;\n  case COAP_ENC_INTEGER:\n    value->u.value_int = atoi(begin);\n    break;\n  case COAP_ENC_TEXT:\n    value->u.value_str.s = (const uint8_t *)begin;\n    value->u.value_str.length = end - begin;\n    break;\n  case COAP_ENC_BOOL:\n    if (memcmp(\"true\", begin, end - begin) == 0)\n      value->u.value_int = 1;\n    else if (memcmp(\"false\", begin, end - begin) == 0)\n      value->u.value_int = 0;\n    else\n      goto bad_entry;\n    break;\n  case COAP_ENC_LAST:\n  default:\n    goto bad_entry;\n  }\n  return 1;\n\nbad_entry:\n  coap_log_warn(\"oscore_conf: Unrecognized configuration entry '%.*s'\\n\",\n                (int)(end - begin),\n                begin);\n  return 0;\n}",
  "abstract_func_before": "static int\nget_split_entry(const char **VAR_0,\n                size_t VAR_1,\n                coap_str_const_t *VAR_2,\n                oscore_value_t *VAR_3) {\n  const char *VAR_4 = *VAR_0;\n  const char *VAR_5;\n  const char *VAR_6;\n  size_t VAR_7;\n\nretry:\n  VAR_5 = memchr(VAR_4, '\\n', VAR_1);\n  if (VAR_5 == NULL)\n    return 0;\n\n  /* COMMENT_0 */\n  *VAR_0 = VAR_5 + 1;\n  if (VAR_5 > VAR_4 && VAR_5[-1] == '\\r')\n    VAR_5--;\n\n  if (VAR_4[0] == '#' || (VAR_5 - VAR_4) == 0) {\n    /* COMMENT_1 */\n    VAR_1 -= VAR_5 - VAR_4 + 1;\n    VAR_4 = *VAR_0;\n    goto retry;\n  }\n\n  /* COMMENT_2 */\n  VAR_6 = memchr(VAR_4, ',', VAR_5 - VAR_4);\n  if (VAR_6 == NULL)\n    goto bad_entry;\n\n  VAR_2->s = (const uint8_t *)VAR_4;\n  VAR_2->length = VAR_6 - VAR_4;\n\n  VAR_4 = VAR_6 + 1;\n  if ((VAR_5 - VAR_4) == 0)\n    goto bad_entry;\n  /* COMMENT_3 */\n  VAR_6 = memchr(VAR_4, ',', VAR_5 - VAR_4);\n  if (VAR_6 == NULL)\n    goto bad_entry;\n\n  for (VAR_7 = 0; VAR_8[VAR_7].name.s; VAR_7++) {\n    coap_str_const_t VAR_9 = { VAR_6 - VAR_4, (const uint8_t *)VAR_4 };\n\n    if (coap_string_equal(&VAR_9, &VAR_8[VAR_7].name)) {\n      VAR_3->encoding = VAR_8[VAR_7].encoding;\n      VAR_3->encoding_name = (const char *)VAR_8[VAR_7].name.s;\n      break;\n    }\n  }\n  if (VAR_8[VAR_7].name.s == NULL)\n    goto bad_entry;\n\n  VAR_4 = VAR_6 + 1;\n  if ((VAR_5 - VAR_4) == 0)\n    goto bad_entry;\n  /* COMMENT_4 */\n  if (VAR_4[0] == '\"') {\n    VAR_6 = memchr(&VAR_4[1], '\"', VAR_5 - VAR_6 - 1);\n    if (VAR_6 == NULL)\n      goto bad_entry;\n    VAR_5 = VAR_6;\n    VAR_4++;\n  }\n  switch (VAR_3->encoding) {\n  case VAR_10:\n    VAR_3->u.value_bin =\n        coap_new_bin_const((const uint8_t *)VAR_4, VAR_5 - VAR_4);\n    break;\n  case VAR_11:\n    /* COMMENT_5 */\n    VAR_3->u.value_bin = parse_hex_bin(VAR_4, VAR_5);\n    if (VAR_3->u.value_bin == NULL)\n      goto bad_entry;\n    break;\n  case VAR_12:\n    VAR_3->u.value_int = atoi(VAR_4);\n    break;\n  case VAR_13:\n    VAR_3->u.value_str.s = (const uint8_t *)VAR_4;\n    VAR_3->u.value_str.length = VAR_5 - VAR_4;\n    break;\n  case VAR_14:\n    if (memcmp(\"true\", VAR_4, VAR_5 - VAR_4) == 0)\n      VAR_3->u.value_int = 1;\n    else if (memcmp(\"false\", VAR_4, VAR_5 - VAR_4) == 0)\n      VAR_3->u.value_int = 0;\n    else\n      goto bad_entry;\n    break;\n  case VAR_15:\n  default:\n    goto bad_entry;\n  }\n  return 1;\n\nbad_entry:\n  coap_log_warn(\"oscore_conf: Unrecognized configuration entry '%.*s'\\n\",\n                (int)(VAR_5 - VAR_4),\n                VAR_4);\n  return 0;\n}",
  "func_graph_path_before": "obgm/libcoap/bf6a303883bde40cf96b960c8574cddd89e71701/coap_oscore.c/vul/before/0.json",
  "func": "static int\nget_split_entry(const char **start,\n                size_t size,\n                coap_str_const_t *keyword,\n                oscore_value_t *value) {\n  const char *begin = *start;\n  const char *end;\n  const char *kend;\n  const char *split;\n  size_t i;\n\nretry:\n  kend = end = memchr(begin, '\\n', size);\n  if (end == NULL)\n    return 0;\n\n  /* Track beginning of next line */\n  *start = end + 1;\n  if (end > begin && end[-1] == '\\r')\n    end--;\n\n  if (begin[0] == '#' || (end - begin) == 0) {\n    /* Skip comment / blank line */\n    size -= kend - begin + 1;\n    begin = *start;\n    goto retry;\n  }\n\n  /* Get in the keyword */\n  split = memchr(begin, ',', end - begin);\n  if (split == NULL)\n    goto bad_entry;\n\n  keyword->s = (const uint8_t *)begin;\n  keyword->length = split - begin;\n\n  begin = split + 1;\n  if ((end - begin) == 0)\n    goto bad_entry;\n  /* Get in the encoding */\n  split = memchr(begin, ',', end - begin);\n  if (split == NULL)\n    goto bad_entry;\n\n  for (i = 0; oscore_encoding[i].name.s; i++) {\n    coap_str_const_t temp = { split - begin, (const uint8_t *)begin };\n\n    if (coap_string_equal(&temp, &oscore_encoding[i].name)) {\n      value->encoding = oscore_encoding[i].encoding;\n      value->encoding_name = (const char *)oscore_encoding[i].name.s;\n      break;\n    }\n  }\n  if (oscore_encoding[i].name.s == NULL)\n    goto bad_entry;\n\n  begin = split + 1;\n  if ((end - begin) == 0)\n    goto bad_entry;\n  /* Get in the keyword's value */\n  if (begin[0] == '\"') {\n    split = memchr(&begin[1], '\"', end - split - 1);\n    if (split == NULL)\n      goto bad_entry;\n    end = split;\n    begin++;\n  }\n  switch (value->encoding) {\n  case COAP_ENC_ASCII:\n    value->u.value_bin =\n        coap_new_bin_const((const uint8_t *)begin, end - begin);\n    break;\n  case COAP_ENC_HEX:\n    /* Parse the hex into binary */\n    value->u.value_bin = parse_hex_bin(begin, end);\n    if (value->u.value_bin == NULL)\n      goto bad_entry;\n    break;\n  case COAP_ENC_INTEGER:\n    value->u.value_int = atoi(begin);\n    break;\n  case COAP_ENC_TEXT:\n    value->u.value_str.s = (const uint8_t *)begin;\n    value->u.value_str.length = end - begin;\n    break;\n  case COAP_ENC_BOOL:\n    if (memcmp(\"true\", begin, end - begin) == 0)\n      value->u.value_int = 1;\n    else if (memcmp(\"false\", begin, end - begin) == 0)\n      value->u.value_int = 0;\n    else\n      goto bad_entry;\n    break;\n  case COAP_ENC_LAST:\n  default:\n    goto bad_entry;\n  }\n  return 1;\n\nbad_entry:\n  coap_log_warn(\"oscore_conf: Unrecognized configuration entry '%.*s'\\n\",\n                (int)(end - begin),\n                begin);\n  return 0;\n}",
  "abstract_func": "static int\nget_split_entry(const char **VAR_0,\n                size_t VAR_1,\n                coap_str_const_t *VAR_2,\n                oscore_value_t *VAR_3) {\n  const char *VAR_4 = *VAR_0;\n  const char *VAR_5;\n  const char *VAR_6;\n  const char *VAR_7;\n  size_t VAR_8;\n\nretry:\n  VAR_6 = VAR_5 = memchr(VAR_4, '\\n', VAR_1);\n  if (VAR_5 == NULL)\n    return 0;\n\n  /* COMMENT_0 */\n  *VAR_0 = VAR_5 + 1;\n  if (VAR_5 > VAR_4 && VAR_5[-1] == '\\r')\n    VAR_5--;\n\n  if (VAR_4[0] == '#' || (VAR_5 - VAR_4) == 0) {\n    /* COMMENT_1 */\n    VAR_1 -= VAR_6 - VAR_4 + 1;\n    VAR_4 = *VAR_0;\n    goto retry;\n  }\n\n  /* COMMENT_2 */\n  VAR_7 = memchr(VAR_4, ',', VAR_5 - VAR_4);\n  if (VAR_7 == NULL)\n    goto bad_entry;\n\n  VAR_2->s = (const uint8_t *)VAR_4;\n  VAR_2->length = VAR_7 - VAR_4;\n\n  VAR_4 = VAR_7 + 1;\n  if ((VAR_5 - VAR_4) == 0)\n    goto bad_entry;\n  /* COMMENT_3 */\n  VAR_7 = memchr(VAR_4, ',', VAR_5 - VAR_4);\n  if (VAR_7 == NULL)\n    goto bad_entry;\n\n  for (VAR_8 = 0; VAR_9[VAR_8].name.s; VAR_8++) {\n    coap_str_const_t VAR_10 = { VAR_7 - VAR_4, (const uint8_t *)VAR_4 };\n\n    if (coap_string_equal(&VAR_10, &VAR_9[VAR_8].name)) {\n      VAR_3->encoding = VAR_9[VAR_8].encoding;\n      VAR_3->encoding_name = (const char *)VAR_9[VAR_8].name.s;\n      break;\n    }\n  }\n  if (VAR_9[VAR_8].name.s == NULL)\n    goto bad_entry;\n\n  VAR_4 = VAR_7 + 1;\n  if ((VAR_5 - VAR_4) == 0)\n    goto bad_entry;\n  /* COMMENT_4 */\n  if (VAR_4[0] == '\"') {\n    VAR_7 = memchr(&VAR_4[1], '\"', VAR_5 - VAR_7 - 1);\n    if (VAR_7 == NULL)\n      goto bad_entry;\n    VAR_5 = VAR_7;\n    VAR_4++;\n  }\n  switch (VAR_3->encoding) {\n  case VAR_11:\n    VAR_3->u.value_bin =\n        coap_new_bin_const((const uint8_t *)VAR_4, VAR_5 - VAR_4);\n    break;\n  case VAR_12:\n    /* COMMENT_5 */\n    VAR_3->u.value_bin = parse_hex_bin(VAR_4, VAR_5);\n    if (VAR_3->u.value_bin == NULL)\n      goto bad_entry;\n    break;\n  case VAR_13:\n    VAR_3->u.value_int = atoi(VAR_4);\n    break;\n  case VAR_14:\n    VAR_3->u.value_str.s = (const uint8_t *)VAR_4;\n    VAR_3->u.value_str.length = VAR_5 - VAR_4;\n    break;\n  case VAR_15:\n    if (memcmp(\"true\", VAR_4, VAR_5 - VAR_4) == 0)\n      VAR_3->u.value_int = 1;\n    else if (memcmp(\"false\", VAR_4, VAR_5 - VAR_4) == 0)\n      VAR_3->u.value_int = 0;\n    else\n      goto bad_entry;\n    break;\n  case VAR_16:\n  default:\n    goto bad_entry;\n  }\n  return 1;\n\nbad_entry:\n  coap_log_warn(\"oscore_conf: Unrecognized configuration entry '%.*s'\\n\",\n                (int)(VAR_5 - VAR_4),\n                VAR_4);\n  return 0;\n}",
  "func_graph_path": "obgm/libcoap/bf6a303883bde40cf96b960c8574cddd89e71701/coap_oscore.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -5,11 +5,12 @@\n                 oscore_value_t *value) {\n   const char *begin = *start;\n   const char *end;\n+  const char *kend;\n   const char *split;\n   size_t i;\n \n retry:\n-  end = memchr(begin, '\\n', size);\n+  kend = end = memchr(begin, '\\n', size);\n   if (end == NULL)\n     return 0;\n \n@@ -20,7 +21,7 @@\n \n   if (begin[0] == '#' || (end - begin) == 0) {\n     /* Skip comment / blank line */\n-    size -= end - begin + 1;\n+    size -= kend - begin + 1;\n     begin = *start;\n     goto retry;\n   }",
  "diff_line_info": {
    "deleted_lines": [
      "  end = memchr(begin, '\\n', size);",
      "    size -= end - begin + 1;"
    ],
    "added_lines": [
      "  const char *kend;",
      "  kend = end = memchr(begin, '\\n', size);",
      "    size -= kend - begin + 1;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/obgm/libcoap/pull/1311",
  "description": {
    "pr_info": {
      "title": "coap_oscore.c: Fix parsing OSCORE configuration information",
      "number": 1311
    },
    "comment": [
      "Handles comments in the OSCORE configuration that is in DOS format.\r\n\r\nFixes #1310.",
      "Thanks for your work, it's working fine.\r\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.6,
  "Bug Filter Response": "Final Classification: Security Vulnerability Fix  \nConfidence: 0.6  \n\n**Explanation:**  \nWhile the commit message doesn't explicitly state it's a security fix, the code changes related to parsing configuration comments suggest potential security implications, such as preventing improper data processing. However, without explicit security terms, the classification is less certain, hence the lower confidence score."
}