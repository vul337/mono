{
  "cve_id": "CVE-2018-25021",
  "cwe_ids": [
    "CWE-404"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "TokTok/c-toxcore",
  "commit_msg": "Fix memleak in tcp server by wiping priority queues on deletion",
  "commit_hash": "5beb00c93d3adb5c23149535624d27c67bc146ea",
  "git_url": "https://github.com/TokTok/c-toxcore/commit/5beb00c93d3adb5c23149535624d27c67bc146ea",
  "file_path": "toxcore/TCP_server.c",
  "func_name": "add_accepted",
  "func_before": "static int add_accepted(TCP_Server *tcp_server, const Mono_Time *mono_time, const TCP_Secure_Connection *con)\n{\n    int index = get_TCP_connection_index(tcp_server, con->public_key);\n\n    if (index != -1) { /* If an old connection to the same public key exists, kill it. */\n        kill_accepted(tcp_server, index);\n        index = -1;\n    }\n\n    if (tcp_server->size_accepted_connections == tcp_server->num_accepted_connections) {\n        if (realloc_connection(tcp_server, tcp_server->size_accepted_connections + 4) == -1) {\n            return -1;\n        }\n\n        index = tcp_server->num_accepted_connections;\n    } else {\n        uint32_t i;\n\n        for (i = tcp_server->size_accepted_connections; i != 0; --i) {\n            if (tcp_server->accepted_connection_array[i - 1].status == TCP_STATUS_NO_STATUS) {\n                index = i - 1;\n                break;\n            }\n        }\n    }\n\n    if (index == -1) {\n        fprintf(stderr, \"FAIL index is -1\\n\");\n        return -1;\n    }\n\n    if (!bs_list_add(&tcp_server->accepted_key_list, con->public_key, index)) {\n        return -1;\n    }\n\n    memcpy(&tcp_server->accepted_connection_array[index], con, sizeof(TCP_Secure_Connection));\n    tcp_server->accepted_connection_array[index].status = TCP_STATUS_CONFIRMED;\n    ++tcp_server->num_accepted_connections;\n    tcp_server->accepted_connection_array[index].identifier = ++tcp_server->counter;\n    tcp_server->accepted_connection_array[index].last_pinged = mono_time_get(mono_time);\n    tcp_server->accepted_connection_array[index].ping_id = 0;\n\n    return index;\n}",
  "abstract_func_before": "static int add_accepted(TCP_Server *VAR_0, const Mono_Time *VAR_1, const TCP_Secure_Connection *VAR_2)\n{\n    int VAR_3 = get_TCP_connection_index(VAR_0, VAR_2->public_key);\n\n    if (VAR_3 != -1) { /* COMMENT_0 */\n        kill_accepted(VAR_0, VAR_3);\n        VAR_3 = -1;\n    }\n\n    if (VAR_0->size_accepted_connections == VAR_0->num_accepted_connections) {\n        if (realloc_connection(VAR_0, VAR_0->size_accepted_connections + 4) == -1) {\n            return -1;\n        }\n\n        VAR_3 = VAR_0->num_accepted_connections;\n    } else {\n        uint32_t VAR_4;\n\n        for (VAR_4 = VAR_0->size_accepted_connections; VAR_4 != 0; --VAR_4) {\n            if (VAR_0->accepted_connection_array[VAR_4 - 1].status == VAR_5) {\n                VAR_3 = VAR_4 - 1;\n                break;\n            }\n        }\n    }\n\n    if (VAR_3 == -1) {\n        fprintf(VAR_6, \"FAIL index is -1\\n\");\n        return -1;\n    }\n\n    if (!bs_list_add(&VAR_0->accepted_key_list, VAR_2->public_key, VAR_3)) {\n        return -1;\n    }\n\n    memcpy(&VAR_0->accepted_connection_array[VAR_3], VAR_2, sizeof(TCP_Secure_Connection));\n    VAR_0->accepted_connection_array[VAR_3].status = VAR_7;\n    ++VAR_0->num_accepted_connections;\n    VAR_0->accepted_connection_array[VAR_3].identifier = ++VAR_0->counter;\n    VAR_0->accepted_connection_array[VAR_3].last_pinged = mono_time_get(VAR_1);\n    VAR_0->accepted_connection_array[VAR_3].ping_id = 0;\n\n    return VAR_3;\n}",
  "func_graph_path_before": "TokTok/c-toxcore/5beb00c93d3adb5c23149535624d27c67bc146ea/TCP_server.c/vul/before/1.json",
  "func": "static int add_accepted(TCP_Server *tcp_server, const Mono_Time *mono_time, TCP_Secure_Connection *con)\n{\n    int index = get_TCP_connection_index(tcp_server, con->public_key);\n\n    if (index != -1) { /* If an old connection to the same public key exists, kill it. */\n        kill_accepted(tcp_server, index);\n        index = -1;\n    }\n\n    if (tcp_server->size_accepted_connections == tcp_server->num_accepted_connections) {\n        if (alloc_new_connections(tcp_server, 4) == -1) {\n            return -1;\n        }\n\n        index = tcp_server->num_accepted_connections;\n    } else {\n        uint32_t i;\n\n        for (i = tcp_server->size_accepted_connections; i != 0; --i) {\n            if (tcp_server->accepted_connection_array[i - 1].status == TCP_STATUS_NO_STATUS) {\n                index = i - 1;\n                break;\n            }\n        }\n    }\n\n    if (index == -1) {\n        fprintf(stderr, \"FAIL index is -1\\n\");\n        return -1;\n    }\n\n    if (!bs_list_add(&tcp_server->accepted_key_list, con->public_key, index)) {\n        return -1;\n    }\n\n    move_secure_connection(&tcp_server->accepted_connection_array[index], con);\n\n    tcp_server->accepted_connection_array[index].status = TCP_STATUS_CONFIRMED;\n    ++tcp_server->num_accepted_connections;\n    tcp_server->accepted_connection_array[index].identifier = ++tcp_server->counter;\n    tcp_server->accepted_connection_array[index].last_pinged = mono_time_get(mono_time);\n    tcp_server->accepted_connection_array[index].ping_id = 0;\n\n    return index;\n}",
  "abstract_func": "static int add_accepted(TCP_Server *VAR_0, const Mono_Time *VAR_1, TCP_Secure_Connection *VAR_2)\n{\n    int VAR_3 = get_TCP_connection_index(VAR_0, VAR_2->public_key);\n\n    if (VAR_3 != -1) { /* COMMENT_0 */\n        kill_accepted(VAR_0, VAR_3);\n        VAR_3 = -1;\n    }\n\n    if (VAR_0->size_accepted_connections == VAR_0->num_accepted_connections) {\n        if (alloc_new_connections(VAR_0, 4) == -1) {\n            return -1;\n        }\n\n        VAR_3 = VAR_0->num_accepted_connections;\n    } else {\n        uint32_t VAR_4;\n\n        for (VAR_4 = VAR_0->size_accepted_connections; VAR_4 != 0; --VAR_4) {\n            if (VAR_0->accepted_connection_array[VAR_4 - 1].status == VAR_5) {\n                VAR_3 = VAR_4 - 1;\n                break;\n            }\n        }\n    }\n\n    if (VAR_3 == -1) {\n        fprintf(VAR_6, \"FAIL index is -1\\n\");\n        return -1;\n    }\n\n    if (!bs_list_add(&VAR_0->accepted_key_list, VAR_2->public_key, VAR_3)) {\n        return -1;\n    }\n\n    move_secure_connection(&VAR_0->accepted_connection_array[VAR_3], VAR_2);\n\n    VAR_0->accepted_connection_array[VAR_3].status = VAR_7;\n    ++VAR_0->num_accepted_connections;\n    VAR_0->accepted_connection_array[VAR_3].identifier = ++VAR_0->counter;\n    VAR_0->accepted_connection_array[VAR_3].last_pinged = mono_time_get(VAR_1);\n    VAR_0->accepted_connection_array[VAR_3].ping_id = 0;\n\n    return VAR_3;\n}",
  "func_graph_path": "TokTok/c-toxcore/5beb00c93d3adb5c23149535624d27c67bc146ea/TCP_server.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-static int add_accepted(TCP_Server *tcp_server, const Mono_Time *mono_time, const TCP_Secure_Connection *con)\n+static int add_accepted(TCP_Server *tcp_server, const Mono_Time *mono_time, TCP_Secure_Connection *con)\n {\n     int index = get_TCP_connection_index(tcp_server, con->public_key);\n \n@@ -8,7 +8,7 @@\n     }\n \n     if (tcp_server->size_accepted_connections == tcp_server->num_accepted_connections) {\n-        if (realloc_connection(tcp_server, tcp_server->size_accepted_connections + 4) == -1) {\n+        if (alloc_new_connections(tcp_server, 4) == -1) {\n             return -1;\n         }\n \n@@ -33,7 +33,8 @@\n         return -1;\n     }\n \n-    memcpy(&tcp_server->accepted_connection_array[index], con, sizeof(TCP_Secure_Connection));\n+    move_secure_connection(&tcp_server->accepted_connection_array[index], con);\n+\n     tcp_server->accepted_connection_array[index].status = TCP_STATUS_CONFIRMED;\n     ++tcp_server->num_accepted_connections;\n     tcp_server->accepted_connection_array[index].identifier = ++tcp_server->counter;",
  "diff_line_info": {
    "deleted_lines": [
      "static int add_accepted(TCP_Server *tcp_server, const Mono_Time *mono_time, const TCP_Secure_Connection *con)",
      "        if (realloc_connection(tcp_server, tcp_server->size_accepted_connections + 4) == -1) {",
      "    memcpy(&tcp_server->accepted_connection_array[index], con, sizeof(TCP_Secure_Connection));"
    ],
    "added_lines": [
      "static int add_accepted(TCP_Server *tcp_server, const Mono_Time *mono_time, TCP_Secure_Connection *con)",
      "        if (alloc_new_connections(tcp_server, 4) == -1) {",
      "    move_secure_connection(&tcp_server->accepted_connection_array[index], con);",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/TokTok/c-toxcore/pull/1216",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/TokTok/c-toxcore/pull/1216: 403 Client Error: Forbidden for url: https://api.github.com/repos/TokTok/c-toxcore/pulls/1216",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.7,
  "Bug Filter Response": "The patch addresses a memory leak in the TCP server, which improves resource management but doesn't fix a security vulnerability. The changes correct a functional bug, aligning with defect remediation.\n\n**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.7"
}