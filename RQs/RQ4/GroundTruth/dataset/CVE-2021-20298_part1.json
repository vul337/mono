{
  "cve_id": "CVE-2021-20298",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "AcademySoftwareFoundation/openexr",
  "commit_msg": "reduce B44 _tmpBufferSize (was allocating two bytes per byte) (#843)\n\nSigned-off-by: Peter Hillman <peterh@wetafx.co.nz>",
  "commit_hash": "85fd638ae0d5fa132434f4cbf32590261c1dba97",
  "git_url": "https://github.com/AcademySoftwareFoundation/openexr/commit/85fd638ae0d5fa132434f4cbf32590261c1dba97",
  "file_path": "OpenEXR/IlmImf/ImfB44Compressor.cpp",
  "func_name": "B44Compressor::B44Compressor",
  "func_before": "B44Compressor::B44Compressor\n    (const Header &hdr,\n     size_t maxScanLineSize,\n     size_t numScanLines,\n     bool optFlatFields)\n:\n    Compressor (hdr),\n    _maxScanLineSize (maxScanLineSize),\n    _optFlatFields (optFlatFields),\n    _format (XDR),\n    _numScanLines (numScanLines),\n    _tmpBuffer (0),\n    _outBuffer (0),\n    _numChans (0),\n    _channels (hdr.channels()),\n    _channelData (0)\n{\n    // TODO: Remove this when we can change the ABI\n    (void)_maxScanLineSize;\n    //\n    // Allocate buffers for compressed an uncompressed pixel data,\n    // allocate a set of ChannelData structs to help speed up the\n    // compress() and uncompress() functions, below, and determine\n    // if uncompressed pixel data should be in native or Xdr format.\n    //\n\n    _tmpBuffer = new unsigned short\n        [checkArraySize (uiMult (maxScanLineSize, numScanLines),\n                         sizeof (unsigned short))];\n\n    const ChannelList &channels = header().channels();\n    int numHalfChans = 0;\n\n    for (ChannelList::ConstIterator c = channels.begin();\n\t c != channels.end();\n\t ++c)\n    {\n\tassert (pixelTypeSize (c.channel().type) % pixelTypeSize (HALF) == 0);\n\t++_numChans;\n\n\tif (c.channel().type == HALF)\n\t    ++numHalfChans;\n    }\n\n    //\n    // Compressed data may be larger than the input data\n    //\n\n    size_t padding = 12 * numHalfChans * (numScanLines + 3) / 4;\n\n    _outBuffer = new char\n        [uiAdd (uiMult (maxScanLineSize, numScanLines), padding)];\n\n    _channelData = new ChannelData[_numChans];\n\n    int i = 0;\n\n    for (ChannelList::ConstIterator c = channels.begin();\n\t c != channels.end();\n\t ++c, ++i)\n    {\n\t_channelData[i].ys = c.channel().ySampling;\n\t_channelData[i].type = c.channel().type;\n\t_channelData[i].pLinear = c.channel().pLinear;\n\t_channelData[i].size =\n\t    pixelTypeSize (c.channel().type) / pixelTypeSize (HALF);\n    }\n\n    const Box2i &dataWindow = hdr.dataWindow();\n\n    _minX = dataWindow.min.x;\n    _maxX = dataWindow.max.x;\n    _maxY = dataWindow.max.y;\n\n    //\n    // We can support uncompressed data in the machine's native\n    // format only if all image channels are of type HALF.\n    //\n\n    assert (sizeof (unsigned short) == pixelTypeSize (HALF));\n\n    if (_numChans == numHalfChans)\n\t_format = NATIVE;\n}",
  "abstract_func_before": "B44Compressor::B44Compressor\n    (const Header &VAR_0,\n     size_t VAR_1,\n     size_t VAR_2,\n     bool VAR_3)\n:\n    Compressor (VAR_0),\n    _maxScanLineSize (VAR_1),\n    _optFlatFields (VAR_3),\n    _format (VAR_4),\n    _numScanLines (VAR_2),\n    _tmpBuffer (0),\n    _outBuffer (0),\n    _numChans (0),\n    _channels (VAR_0.channels()),\n    _channelData (0)\n{\n    /* COMMENT_0 */\n    (void)VAR_5;\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n    /* COMMENT_3 */\n    /* COMMENT_4 */\n    /* COMMENT_5 */\n    /* COMMENT_1 */\n\n    VAR_6 = new unsigned short\n        [checkArraySize (uiMult (VAR_1, VAR_2),\n                         sizeof (unsigned short))];\n\n    const ChannelList &VAR_7 = header().channels();\n    int VAR_8 = 0;\n\n    for (ChannelList::ConstIterator VAR_9 = VAR_7.begin();\n\t VAR_9 != VAR_7.end();\n\t ++VAR_9)\n    {\n\tassert (pixelTypeSize (VAR_9.channel().type) % pixelTypeSize (VAR_10) == 0);\n\t++VAR_11;\n\n\tif (VAR_9.channel().type == VAR_10)\n\t    ++VAR_8;\n    }\n\n    /* COMMENT_1 */\n    /* COMMENT_6 */\n    /* COMMENT_1 */\n\n    size_t VAR_12 = 12 * VAR_8 * (VAR_2 + 3) / 4;\n\n    VAR_13 = new char\n        [uiAdd (uiMult (VAR_1, VAR_2), VAR_12)];\n\n    VAR_14 = new ChannelData[VAR_11];\n\n    int VAR_15 = 0;\n\n    for (ChannelList::ConstIterator VAR_9 = VAR_7.begin();\n\t VAR_9 != VAR_7.end();\n\t ++VAR_9, ++VAR_15)\n    {\n\tVAR_14[VAR_15].ys = VAR_9.channel().ySampling;\n\tVAR_14[VAR_15].type = VAR_9.channel().type;\n\tVAR_14[VAR_15].pLinear = VAR_9.channel().pLinear;\n\tVAR_14[VAR_15].size =\n\t    pixelTypeSize (VAR_9.channel().type) / pixelTypeSize (VAR_10);\n    }\n\n    const Box2i &VAR_16 = VAR_0.dataWindow();\n\n    VAR_17 = VAR_16.min.x;\n    VAR_18 = VAR_16.max.x;\n    VAR_19 = VAR_16.max.y;\n\n    /* COMMENT_1 */\n    /* COMMENT_7 */\n    /* COMMENT_8 */\n    /* COMMENT_1 */\n\n    assert (sizeof (unsigned short) == pixelTypeSize (VAR_10));\n\n    if (VAR_11 == VAR_8)\n\tVAR_20 = VAR_21;\n}",
  "func_graph_path_before": "AcademySoftwareFoundation/openexr/85fd638ae0d5fa132434f4cbf32590261c1dba97/ImfB44Compressor.cpp/vul/before/0.json",
  "func": "B44Compressor::B44Compressor\n    (const Header &hdr,\n     size_t maxScanLineSize,\n     size_t numScanLines,\n     bool optFlatFields)\n:\n    Compressor (hdr),\n    _maxScanLineSize (maxScanLineSize),\n    _optFlatFields (optFlatFields),\n    _format (XDR),\n    _numScanLines (numScanLines),\n    _tmpBuffer (0),\n    _outBuffer (0),\n    _numChans (0),\n    _channels (hdr.channels()),\n    _channelData (0)\n{\n    // TODO: Remove this when we can change the ABI\n    (void)_maxScanLineSize;\n    //\n    // Allocate buffers for compressed an uncompressed pixel data,\n    // allocate a set of ChannelData structs to help speed up the\n    // compress() and uncompress() functions, below, and determine\n    // if uncompressed pixel data should be in native or Xdr format.\n    //\n\n    _tmpBuffer = new unsigned short\n        [checkArraySize (uiMult (maxScanLineSize / sizeof(unsigned short), numScanLines),\n                         sizeof (unsigned short))];\n\n    const ChannelList &channels = header().channels();\n    int numHalfChans = 0;\n\n    for (ChannelList::ConstIterator c = channels.begin();\n\t c != channels.end();\n\t ++c)\n    {\n\tassert (pixelTypeSize (c.channel().type) % pixelTypeSize (HALF) == 0);\n\t++_numChans;\n\n\tif (c.channel().type == HALF)\n\t    ++numHalfChans;\n    }\n\n    //\n    // Compressed data may be larger than the input data\n    //\n\n    size_t padding = 12 * numHalfChans * (numScanLines + 3) / 4;\n\n    _outBuffer = new char\n        [uiAdd (uiMult (maxScanLineSize, numScanLines), padding)];\n\n    _channelData = new ChannelData[_numChans];\n\n    int i = 0;\n\n    for (ChannelList::ConstIterator c = channels.begin();\n\t c != channels.end();\n\t ++c, ++i)\n    {\n\t_channelData[i].ys = c.channel().ySampling;\n\t_channelData[i].type = c.channel().type;\n\t_channelData[i].pLinear = c.channel().pLinear;\n\t_channelData[i].size =\n\t    pixelTypeSize (c.channel().type) / pixelTypeSize (HALF);\n    }\n\n    const Box2i &dataWindow = hdr.dataWindow();\n\n    _minX = dataWindow.min.x;\n    _maxX = dataWindow.max.x;\n    _maxY = dataWindow.max.y;\n\n    //\n    // We can support uncompressed data in the machine's native\n    // format only if all image channels are of type HALF.\n    //\n\n    assert (sizeof (unsigned short) == pixelTypeSize (HALF));\n\n    if (_numChans == numHalfChans)\n\t_format = NATIVE;\n}",
  "abstract_func": "B44Compressor::B44Compressor\n    (const Header &VAR_0,\n     size_t VAR_1,\n     size_t VAR_2,\n     bool VAR_3)\n:\n    Compressor (VAR_0),\n    _maxScanLineSize (VAR_1),\n    _optFlatFields (VAR_3),\n    _format (VAR_4),\n    _numScanLines (VAR_2),\n    _tmpBuffer (0),\n    _outBuffer (0),\n    _numChans (0),\n    _channels (VAR_0.channels()),\n    _channelData (0)\n{\n    /* COMMENT_0 */\n    (void)VAR_5;\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n    /* COMMENT_3 */\n    /* COMMENT_4 */\n    /* COMMENT_5 */\n    /* COMMENT_1 */\n\n    VAR_6 = new unsigned short\n        [checkArraySize (uiMult (VAR_1 / sizeof(unsigned short), VAR_2),\n                         sizeof (unsigned short))];\n\n    const ChannelList &VAR_7 = header().channels();\n    int VAR_8 = 0;\n\n    for (ChannelList::ConstIterator VAR_9 = VAR_7.begin();\n\t VAR_9 != VAR_7.end();\n\t ++VAR_9)\n    {\n\tassert (pixelTypeSize (VAR_9.channel().type) % pixelTypeSize (VAR_10) == 0);\n\t++VAR_11;\n\n\tif (VAR_9.channel().type == VAR_10)\n\t    ++VAR_8;\n    }\n\n    /* COMMENT_1 */\n    /* COMMENT_6 */\n    /* COMMENT_1 */\n\n    size_t VAR_12 = 12 * VAR_8 * (VAR_2 + 3) / 4;\n\n    VAR_13 = new char\n        [uiAdd (uiMult (VAR_1, VAR_2), VAR_12)];\n\n    VAR_14 = new ChannelData[VAR_11];\n\n    int VAR_15 = 0;\n\n    for (ChannelList::ConstIterator VAR_9 = VAR_7.begin();\n\t VAR_9 != VAR_7.end();\n\t ++VAR_9, ++VAR_15)\n    {\n\tVAR_14[VAR_15].ys = VAR_9.channel().ySampling;\n\tVAR_14[VAR_15].type = VAR_9.channel().type;\n\tVAR_14[VAR_15].pLinear = VAR_9.channel().pLinear;\n\tVAR_14[VAR_15].size =\n\t    pixelTypeSize (VAR_9.channel().type) / pixelTypeSize (VAR_10);\n    }\n\n    const Box2i &VAR_16 = VAR_0.dataWindow();\n\n    VAR_17 = VAR_16.min.x;\n    VAR_18 = VAR_16.max.x;\n    VAR_19 = VAR_16.max.y;\n\n    /* COMMENT_1 */\n    /* COMMENT_7 */\n    /* COMMENT_8 */\n    /* COMMENT_1 */\n\n    assert (sizeof (unsigned short) == pixelTypeSize (VAR_10));\n\n    if (VAR_11 == VAR_8)\n\tVAR_20 = VAR_21;\n}",
  "func_graph_path": "AcademySoftwareFoundation/openexr/85fd638ae0d5fa132434f4cbf32590261c1dba97/ImfB44Compressor.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -25,7 +25,7 @@\n     //\n \n     _tmpBuffer = new unsigned short\n-        [checkArraySize (uiMult (maxScanLineSize, numScanLines),\n+        [checkArraySize (uiMult (maxScanLineSize / sizeof(unsigned short), numScanLines),\n                          sizeof (unsigned short))];\n \n     const ChannelList &channels = header().channels();",
  "diff_line_info": {
    "deleted_lines": [
      "        [checkArraySize (uiMult (maxScanLineSize, numScanLines),"
    ],
    "added_lines": [
      "        [checkArraySize (uiMult (maxScanLineSize / sizeof(unsigned short), numScanLines),"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/AcademySoftwareFoundation/openexr/pull/843",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/AcademySoftwareFoundation/openexr/pull/843: 403 Client Error: Forbidden for url: https://api.github.com/repos/AcademySoftwareFoundation/openexr/pulls/843",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.9"
}