{
  "cve_id": "CVE-2014-7203",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "zeromq/libzmq",
  "commit_msg": "Problem: curve messages can be replayed\n\nSolution: ensure message short nonces are strictly increasing and validate them",
  "commit_hash": "0900a489213d74feb86fc0b343308fe7884a2a3c",
  "git_url": "https://github.com/zeromq/libzmq/commit/0900a489213d74feb86fc0b343308fe7884a2a3c",
  "file_path": "src/curve_client.cpp",
  "func_name": "zmq::curve_client_t::process_ready",
  "func_before": "int zmq::curve_client_t::process_ready (\n        const uint8_t *msg_data, size_t msg_size)\n{\n    if (msg_size < 30) {\n        errno = EPROTO;\n        return -1;\n    }\n\n    const size_t clen = (msg_size - 14) + crypto_box_BOXZEROBYTES;\n\n    uint8_t ready_nonce [crypto_box_NONCEBYTES];\n    uint8_t ready_plaintext [crypto_box_ZEROBYTES + 256];\n    uint8_t ready_box [crypto_box_BOXZEROBYTES + 16 + 256];\n\n    memset (ready_box, 0, crypto_box_BOXZEROBYTES);\n    memcpy (ready_box + crypto_box_BOXZEROBYTES,\n            msg_data + 14, clen - crypto_box_BOXZEROBYTES);\n\n    memcpy (ready_nonce, \"CurveZMQREADY---\", 16);\n    memcpy (ready_nonce + 16, msg_data + 6, 8);\n\n    int rc = crypto_box_open_afternm (ready_plaintext, ready_box,\n                                      clen, ready_nonce, cn_precom);\n\n    if (rc != 0) {\n        errno = EPROTO;\n        return -1;\n    }\n\n    rc = parse_metadata (ready_plaintext + crypto_box_ZEROBYTES,\n                         clen - crypto_box_ZEROBYTES);\n    if (rc == 0)\n        state = connected;\n\n    return rc;\n}",
  "abstract_func_before": "int zmq::curve_client_t::process_ready (\n        const uint8_t *VAR_0, size_t VAR_1)\n{\n    if (VAR_1 < 30) {\n        VAR_2 = VAR_3;\n        return -1;\n    }\n\n    const size_t VAR_4 = (VAR_1 - 14) + VAR_5;\n\n    uint8_t VAR_6 [VAR_7];\n    uint8_t VAR_8 [VAR_9 + 256];\n    uint8_t VAR_10 [VAR_5 + 16 + 256];\n\n    memset (VAR_10, 0, VAR_5);\n    memcpy (VAR_10 + VAR_5,\n            VAR_0 + 14, VAR_4 - VAR_5);\n\n    memcpy (VAR_6, \"CurveZMQREADY---\", 16);\n    memcpy (VAR_6 + 16, VAR_0 + 6, 8);\n\n    int VAR_11 = crypto_box_open_afternm (VAR_8, VAR_10,\n                                      VAR_4, VAR_6, VAR_12);\n\n    if (VAR_11 != 0) {\n        VAR_2 = VAR_3;\n        return -1;\n    }\n\n    VAR_11 = parse_metadata (VAR_8 + VAR_9,\n                         VAR_4 - VAR_9);\n    if (VAR_11 == 0)\n        VAR_13 = VAR_14;\n\n    return VAR_11;\n}",
  "func_graph_path_before": "zeromq/libzmq/0900a489213d74feb86fc0b343308fe7884a2a3c/curve_client.cpp/vul/before/4.json",
  "func": "int zmq::curve_client_t::process_ready (\n        const uint8_t *msg_data, size_t msg_size)\n{\n    if (msg_size < 30) {\n        errno = EPROTO;\n        return -1;\n    }\n\n    const size_t clen = (msg_size - 14) + crypto_box_BOXZEROBYTES;\n\n    uint8_t ready_nonce [crypto_box_NONCEBYTES];\n    uint8_t ready_plaintext [crypto_box_ZEROBYTES + 256];\n    uint8_t ready_box [crypto_box_BOXZEROBYTES + 16 + 256];\n\n    memset (ready_box, 0, crypto_box_BOXZEROBYTES);\n    memcpy (ready_box + crypto_box_BOXZEROBYTES,\n            msg_data + 14, clen - crypto_box_BOXZEROBYTES);\n\n    memcpy (ready_nonce, \"CurveZMQREADY---\", 16);\n    memcpy (ready_nonce + 16, msg_data + 6, 8);\n    cn_peer_nonce = get_uint64(msg_data + 6);\n\n    int rc = crypto_box_open_afternm (ready_plaintext, ready_box,\n                                      clen, ready_nonce, cn_precom);\n\n    if (rc != 0) {\n        errno = EPROTO;\n        return -1;\n    }\n\n    rc = parse_metadata (ready_plaintext + crypto_box_ZEROBYTES,\n                         clen - crypto_box_ZEROBYTES);\n    if (rc == 0)\n        state = connected;\n\n    return rc;\n}",
  "abstract_func": "int zmq::curve_client_t::process_ready (\n        const uint8_t *VAR_0, size_t VAR_1)\n{\n    if (VAR_1 < 30) {\n        VAR_2 = VAR_3;\n        return -1;\n    }\n\n    const size_t VAR_4 = (VAR_1 - 14) + VAR_5;\n\n    uint8_t VAR_6 [VAR_7];\n    uint8_t VAR_8 [VAR_9 + 256];\n    uint8_t VAR_10 [VAR_5 + 16 + 256];\n\n    memset (VAR_10, 0, VAR_5);\n    memcpy (VAR_10 + VAR_5,\n            VAR_0 + 14, VAR_4 - VAR_5);\n\n    memcpy (VAR_6, \"CurveZMQREADY---\", 16);\n    memcpy (VAR_6 + 16, VAR_0 + 6, 8);\n    VAR_11 = get_uint64(VAR_0 + 6);\n\n    int VAR_12 = crypto_box_open_afternm (VAR_8, VAR_10,\n                                      VAR_4, VAR_6, VAR_13);\n\n    if (VAR_12 != 0) {\n        VAR_2 = VAR_3;\n        return -1;\n    }\n\n    VAR_12 = parse_metadata (VAR_8 + VAR_9,\n                         VAR_4 - VAR_9);\n    if (VAR_12 == 0)\n        VAR_14 = VAR_15;\n\n    return VAR_12;\n}",
  "func_graph_path": "zeromq/libzmq/0900a489213d74feb86fc0b343308fe7884a2a3c/curve_client.cpp/vul/after/4.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -18,6 +18,7 @@\n \n     memcpy (ready_nonce, \"CurveZMQREADY---\", 16);\n     memcpy (ready_nonce + 16, msg_data + 6, 8);\n+    cn_peer_nonce = get_uint64(msg_data + 6);\n \n     int rc = crypto_box_open_afternm (ready_plaintext, ready_box,\n                                       clen, ready_nonce, cn_precom);",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "    cn_peer_nonce = get_uint64(msg_data + 6);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/zeromq/libzmq/pull/1189",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/zeromq/libzmq/pull/1189: 403 Client Error: Forbidden for url: https://api.github.com/repos/zeromq/libzmq/pulls/1189",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.9"
}