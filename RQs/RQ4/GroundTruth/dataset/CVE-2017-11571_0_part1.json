{
  "cve_id": "CVE-2017-11571",
  "cwe_ids": [
    "CWE-119"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "fontforge",
  "commit_msg": "parsettf.c: Fix buffer overflow condition when reading CFF top dictionary\n\nCloses #3087",
  "commit_hash": "5a0c6522682b0788fc478dd159dd6168cb5fa38b",
  "git_url": "https://github.com/fontforge/fontforge/commit/5a0c6522682b0788fc478dd159dd6168cb5fa38b",
  "file_path": "fontforge/parsettf.c",
  "func_name": "readcffthing",
  "func_before": "static int readcffthing(FILE *ttf,int *_ival,real *dval,int *operand,struct ttfinfo *info) {\n    char buffer[50], *pt;\n    int ch, ival;\n\n    ch = getc(ttf);\n    if ( ch==12 ) {\n\t*operand = (12<<8) | getc(ttf);\nreturn( 3 );\n    } else if ( ch<=21 ) {\n\t*operand = ch;\nreturn( 3 );\n    } else if ( ch==30 ) {\n\t/* fixed format doesn't exist in dict data but does in type2 strings */\n\tpt = buffer;\n\tdo {\n\t    ch = getc(ttf);\n\t    if ( pt<buffer+44 || (ch&0xf)==0xf || (ch&0xf0)==0xf0 ) {\n\t\tpt = addnibble(pt,ch>>4);\n\t\tpt = addnibble(pt,ch&0xf);\n\t    }\n\t} while ( pt[-1]!='\\0' );\n\t*dval = strtod(buffer,NULL);\nreturn( 2 );\n    } else if ( ch>=32 && ch<=246 ) {\n\t*_ival = ch-139;\nreturn( 1 );\n    } else if ( ch>=247 && ch<=250 ) {\n\t*_ival = ((ch-247)<<8) + getc(ttf)+108;\nreturn( 1 );\n    } else if ( ch>=251 && ch<=254 ) {\n\t*_ival = -((ch-251)<<8) - getc(ttf)-108;\nreturn( 1 );\n    } else if ( ch==28 ) {\n\tival = getc(ttf)<<8;\n\t*_ival = (short) (ival | getc(ttf));\nreturn( 1 );\n    } else if ( ch==29 ) {\n\t/* 4 byte integers exist in dict data but not in type2 strings */\n\tival = getc(ttf)<<24;\n\tival = ival | getc(ttf)<<16;\n\tival = ival | getc(ttf)<<8;\n\t*_ival = (int) (ival | getc(ttf));\nreturn( 1 );\n    }\n    LogError(_(\"Unexpected value in dictionary %d\\n\"), ch );\n    info->bad_cff = true;\n    *_ival = 0;\nreturn( 0 );\n}",
  "abstract_func_before": "static int readcffthing(FILE *VAR_0,int *VAR_1,real *VAR_2,int *VAR_3,struct ttfinfo *VAR_4) {\n    char VAR_5[50], *VAR_6;\n    int VAR_7, VAR_8;\n\n    VAR_7 = getc(VAR_0);\n    if ( VAR_7==12 ) {\n\t*VAR_3 = (12<<8) | getc(VAR_0);\nreturn( 3 );\n    } else if ( VAR_7<=21 ) {\n\t*VAR_3 = VAR_7;\nreturn( 3 );\n    } else if ( VAR_7==30 ) {\n\t/* COMMENT_0 */\n\tVAR_6 = VAR_5;\n\tdo {\n\t    VAR_7 = getc(VAR_0);\n\t    if ( VAR_6<VAR_5+44 || (VAR_7&0xf)==0xf || (VAR_7&0xf0)==0xf0 ) {\n\t\tVAR_6 = addnibble(VAR_6,VAR_7>>4);\n\t\tVAR_6 = addnibble(VAR_6,VAR_7&0xf);\n\t    }\n\t} while ( VAR_6[-1]!='\\0' );\n\t*VAR_2 = strtod(VAR_5,NULL);\nreturn( 2 );\n    } else if ( VAR_7>=32 && VAR_7<=246 ) {\n\t*VAR_1 = VAR_7-139;\nreturn( 1 );\n    } else if ( VAR_7>=247 && VAR_7<=250 ) {\n\t*VAR_1 = ((VAR_7-247)<<8) + getc(VAR_0)+108;\nreturn( 1 );\n    } else if ( VAR_7>=251 && VAR_7<=254 ) {\n\t*VAR_1 = -((VAR_7-251)<<8) - getc(VAR_0)-108;\nreturn( 1 );\n    } else if ( VAR_7==28 ) {\n\tVAR_8 = getc(VAR_0)<<8;\n\t*VAR_1 = (short) (VAR_8 | getc(VAR_0));\nreturn( 1 );\n    } else if ( VAR_7==29 ) {\n\t/* COMMENT_1 */\n\tVAR_8 = getc(VAR_0)<<24;\n\tVAR_8 = VAR_8 | getc(VAR_0)<<16;\n\tVAR_8 = VAR_8 | getc(VAR_0)<<8;\n\t*VAR_1 = (int) (VAR_8 | getc(VAR_0));\nreturn( 1 );\n    }\n    LogError(_(\"Unexpected value in dictionary %d\\n\"), VAR_7 );\n    VAR_4->bad_cff = true;\n    *VAR_1 = 0;\nreturn( 0 );\n}",
  "func_graph_path_before": "fontforge/5a0c6522682b0788fc478dd159dd6168cb5fa38b/parsettf.c/vul/before/1.json",
  "func": "static int readcffthing(FILE *ttf,int *_ival,real *dval,int *operand,struct ttfinfo *info) {\n    char buffer[50], *pt;\n    int ch, ival;\n\n    ch = getc(ttf);\n    if ( ch==12 ) {\n\t*operand = (12<<8) | getc(ttf);\nreturn( 3 );\n    } else if ( ch<=21 ) {\n\t*operand = ch;\nreturn( 3 );\n    } else if ( ch==30 ) {\n\t/* fixed format doesn't exist in dict data but does in type2 strings */\n\tpt = buffer;\n\tdo {\n\t    ch = getc(ttf);\n\t\t// Space for at least 2 bytes is required\n\t\tif ((pt-buffer) > (sizeof(buffer) - 2)) {\n\t\t\t// The buffer is completely full; null-terminate truncate it\n\t\t\tif ((pt-buffer) == sizeof(buffer)) {\n\t\t\t\tpt--;\n\t\t\t}\n\t\t\t*pt++ = '\\0';\n\t\t\tbreak;\n\t\t}\n\t    if ( pt<buffer+44 || (ch&0xf)==0xf || (ch&0xf0)==0xf0 ) {\n\t\tpt = addnibble(pt,ch>>4);\n\t\tpt = addnibble(pt,ch&0xf);\n\t    }\n\t} while ( pt[-1]!='\\0' );\n\t*dval = strtod(buffer,NULL);\nreturn( 2 );\n    } else if ( ch>=32 && ch<=246 ) {\n\t*_ival = ch-139;\nreturn( 1 );\n    } else if ( ch>=247 && ch<=250 ) {\n\t*_ival = ((ch-247)<<8) + getc(ttf)+108;\nreturn( 1 );\n    } else if ( ch>=251 && ch<=254 ) {\n\t*_ival = -((ch-251)<<8) - getc(ttf)-108;\nreturn( 1 );\n    } else if ( ch==28 ) {\n\tival = getc(ttf)<<8;\n\t*_ival = (short) (ival | getc(ttf));\nreturn( 1 );\n    } else if ( ch==29 ) {\n\t/* 4 byte integers exist in dict data but not in type2 strings */\n\tival = getc(ttf)<<24;\n\tival = ival | getc(ttf)<<16;\n\tival = ival | getc(ttf)<<8;\n\t*_ival = (int) (ival | getc(ttf));\nreturn( 1 );\n    }\n    LogError(_(\"Unexpected value in dictionary %d\\n\"), ch );\n    info->bad_cff = true;\n    *_ival = 0;\nreturn( 0 );\n}",
  "abstract_func": "static int readcffthing(FILE *VAR_0,int *VAR_1,real *VAR_2,int *VAR_3,struct ttfinfo *VAR_4) {\n    char VAR_5[50], *VAR_6;\n    int VAR_7, VAR_8;\n\n    VAR_7 = getc(VAR_0);\n    if ( VAR_7==12 ) {\n\t*VAR_3 = (12<<8) | getc(VAR_0);\nreturn( 3 );\n    } else if ( VAR_7<=21 ) {\n\t*VAR_3 = VAR_7;\nreturn( 3 );\n    } else if ( VAR_7==30 ) {\n\t/* COMMENT_0 */\n\tVAR_6 = VAR_5;\n\tdo {\n\t    VAR_7 = getc(VAR_0);\n\t\t/* COMMENT_1 */\n\t\tif ((VAR_6-VAR_5) > (sizeof(VAR_5) - 2)) {\n\t\t\t/* COMMENT_2 */\n\t\t\tif ((VAR_6-VAR_5) == sizeof(VAR_5)) {\n\t\t\t\tVAR_6--;\n\t\t\t}\n\t\t\t*VAR_6++ = '\\0';\n\t\t\tbreak;\n\t\t}\n\t    if ( VAR_6<VAR_5+44 || (VAR_7&0xf)==0xf || (VAR_7&0xf0)==0xf0 ) {\n\t\tVAR_6 = addnibble(VAR_6,VAR_7>>4);\n\t\tVAR_6 = addnibble(VAR_6,VAR_7&0xf);\n\t    }\n\t} while ( VAR_6[-1]!='\\0' );\n\t*VAR_2 = strtod(VAR_5,NULL);\nreturn( 2 );\n    } else if ( VAR_7>=32 && VAR_7<=246 ) {\n\t*VAR_1 = VAR_7-139;\nreturn( 1 );\n    } else if ( VAR_7>=247 && VAR_7<=250 ) {\n\t*VAR_1 = ((VAR_7-247)<<8) + getc(VAR_0)+108;\nreturn( 1 );\n    } else if ( VAR_7>=251 && VAR_7<=254 ) {\n\t*VAR_1 = -((VAR_7-251)<<8) - getc(VAR_0)-108;\nreturn( 1 );\n    } else if ( VAR_7==28 ) {\n\tVAR_8 = getc(VAR_0)<<8;\n\t*VAR_1 = (short) (VAR_8 | getc(VAR_0));\nreturn( 1 );\n    } else if ( VAR_7==29 ) {\n\t/* COMMENT_3 */\n\tVAR_8 = getc(VAR_0)<<24;\n\tVAR_8 = VAR_8 | getc(VAR_0)<<16;\n\tVAR_8 = VAR_8 | getc(VAR_0)<<8;\n\t*VAR_1 = (int) (VAR_8 | getc(VAR_0));\nreturn( 1 );\n    }\n    LogError(_(\"Unexpected value in dictionary %d\\n\"), VAR_7 );\n    VAR_4->bad_cff = true;\n    *VAR_1 = 0;\nreturn( 0 );\n}",
  "func_graph_path": "fontforge/5a0c6522682b0788fc478dd159dd6168cb5fa38b/parsettf.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -14,6 +14,15 @@\n \tpt = buffer;\n \tdo {\n \t    ch = getc(ttf);\n+\t\t// Space for at least 2 bytes is required\n+\t\tif ((pt-buffer) > (sizeof(buffer) - 2)) {\n+\t\t\t// The buffer is completely full; null-terminate truncate it\n+\t\t\tif ((pt-buffer) == sizeof(buffer)) {\n+\t\t\t\tpt--;\n+\t\t\t}\n+\t\t\t*pt++ = '\\0';\n+\t\t\tbreak;\n+\t\t}\n \t    if ( pt<buffer+44 || (ch&0xf)==0xf || (ch&0xf0)==0xf0 ) {\n \t\tpt = addnibble(pt,ch>>4);\n \t\tpt = addnibble(pt,ch&0xf);",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "\t\t// Space for at least 2 bytes is required",
      "\t\tif ((pt-buffer) > (sizeof(buffer) - 2)) {",
      "\t\t\t// The buffer is completely full; null-terminate truncate it",
      "\t\t\tif ((pt-buffer) == sizeof(buffer)) {",
      "\t\t\t\tpt--;",
      "\t\t\t}",
      "\t\t\t*pt++ = '\\0';",
      "\t\t\tbreak;",
      "\t\t}"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/fontforge/fontforge/pull/3124",
  "description": {
    "pr_info": {
      "title": "Fix a few cves",
      "number": 3124
    },
    "comment": [
      "So the long and the short of it is that FontForge was not designed with security in mind. I would not be surprised at all if a simple permutation on the test cases resulted in another buffer overflow/out of bounds read/etc. There's just too many cases to cover.\r\n\r\nAnyway, this fixes most of the *specific* test cases as listed in #3123. I've avoided #3097 and #3098 which involves changing the codegen around the unicode library. For any other issue in that list where there isn't a specific commit, it's probably been fixed as a side effect of one of the other commits.",
      "Just in time. I'm cutting a release tomorrow. I'll review as soon as I get a chance.\r\n",
      "I made one inline comment/query. It otherwise looks fine.\r\n",
      "All good.\r\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "The patch addresses a buffer overflow, a security issue, by adding checks to prevent overflow conditions.\n\n**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}