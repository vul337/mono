{
  "cve_id": "CVE-2022-34300",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "syoyo/tinyexr",
  "commit_msg": "Fix out of bounds access in DecodePixelData\n\nFixes #167",
  "commit_hash": "9c602a37b3d3a1d98d473cda32b88f8014344990",
  "git_url": "https://github.com/syoyo/tinyexr/commit/9c602a37b3d3a1d98d473cda32b88f8014344990",
  "file_path": "tinyexr.h",
  "func_name": "DecodePixelData",
  "func_before": "static bool DecodePixelData(/* out */ unsigned char **out_images,\n                            const int *requested_pixel_types,\n                            const unsigned char *data_ptr, size_t data_len,\n                            int compression_type, int line_order, int width,\n                            int height, int x_stride, int y, int line_no,\n                            int num_lines, size_t pixel_data_size,\n                            size_t num_attributes,\n                            const EXRAttribute *attributes, size_t num_channels,\n                            const EXRChannelInfo *channels,\n                            const std::vector<size_t> &channel_offset_list) {\n  if (compression_type == TINYEXR_COMPRESSIONTYPE_PIZ) {  // PIZ\n#if TINYEXR_USE_PIZ\n    if ((width == 0) || (num_lines == 0) || (pixel_data_size == 0)) {\n      // Invalid input #90\n      return false;\n    }\n\n    // Allocate original data size.\n    std::vector<unsigned char> outBuf(static_cast<size_t>(\n        static_cast<size_t>(width * num_lines) * pixel_data_size));\n    size_t tmpBufLen = outBuf.size();\n\n    bool ret = tinyexr::DecompressPiz(\n        reinterpret_cast<unsigned char *>(&outBuf.at(0)), data_ptr, tmpBufLen,\n        data_len, static_cast<int>(num_channels), channels, width, num_lines);\n\n    if (!ret) {\n      return false;\n    }\n\n    // For PIZ_COMPRESSION:\n    //   pixel sample data for channel 0 for scanline 0\n    //   pixel sample data for channel 1 for scanline 0\n    //   pixel sample data for channel ... for scanline 0\n    //   pixel sample data for channel n for scanline 0\n    //   pixel sample data for channel 0 for scanline 1\n    //   pixel sample data for channel 1 for scanline 1\n    //   pixel sample data for channel ... for scanline 1\n    //   pixel sample data for channel n for scanline 1\n    //   ...\n    for (size_t c = 0; c < static_cast<size_t>(num_channels); c++) {\n      if (channels[c].pixel_type == TINYEXR_PIXELTYPE_HALF) {\n        for (size_t v = 0; v < static_cast<size_t>(num_lines); v++) {\n          const unsigned short *line_ptr = reinterpret_cast<unsigned short *>(\n              &outBuf.at(v * pixel_data_size * static_cast<size_t>(width) +\n                         channel_offset_list[c] * static_cast<size_t>(width)));\n          for (size_t u = 0; u < static_cast<size_t>(width); u++) {\n            FP16 hf;\n\n            // hf.u = line_ptr[u];\n            // use `cpy` to avoid unaligned memory access when compiler's\n            // optimization is on.\n            tinyexr::cpy2(&(hf.u), line_ptr + u);\n\n            tinyexr::swap2(reinterpret_cast<unsigned short *>(&hf.u));\n\n            if (requested_pixel_types[c] == TINYEXR_PIXELTYPE_HALF) {\n              unsigned short *image =\n                  reinterpret_cast<unsigned short **>(out_images)[c];\n              if (line_order == 0) {\n                image += (static_cast<size_t>(line_no) + v) *\n                             static_cast<size_t>(x_stride) +\n                         u;\n              } else {\n                image += static_cast<size_t>(\n                             (height - 1 - (line_no + static_cast<int>(v)))) *\n                             static_cast<size_t>(x_stride) +\n                         u;\n              }\n              *image = hf.u;\n            } else {  // HALF -> FLOAT\n              FP32 f32 = half_to_float(hf);\n              float *image = reinterpret_cast<float **>(out_images)[c];\n              size_t offset = 0;\n              if (line_order == 0) {\n                offset = (static_cast<size_t>(line_no) + v) *\n                             static_cast<size_t>(x_stride) +\n                         u;\n              } else {\n                offset = static_cast<size_t>(\n                             (height - 1 - (line_no + static_cast<int>(v)))) *\n                             static_cast<size_t>(x_stride) +\n                         u;\n              }\n              image += offset;\n              *image = f32.f;\n            }\n          }\n        }\n      } else if (channels[c].pixel_type == TINYEXR_PIXELTYPE_UINT) {\n        assert(requested_pixel_types[c] == TINYEXR_PIXELTYPE_UINT);\n\n        for (size_t v = 0; v < static_cast<size_t>(num_lines); v++) {\n          const unsigned int *line_ptr = reinterpret_cast<unsigned int *>(\n              &outBuf.at(v * pixel_data_size * static_cast<size_t>(width) +\n                         channel_offset_list[c] * static_cast<size_t>(width)));\n          for (size_t u = 0; u < static_cast<size_t>(width); u++) {\n            unsigned int val;\n            // val = line_ptr[u];\n            tinyexr::cpy4(&val, line_ptr + u);\n\n            tinyexr::swap4(&val);\n\n            unsigned int *image =\n                reinterpret_cast<unsigned int **>(out_images)[c];\n            if (line_order == 0) {\n              image += (static_cast<size_t>(line_no) + v) *\n                           static_cast<size_t>(x_stride) +\n                       u;\n            } else {\n              image += static_cast<size_t>(\n                           (height - 1 - (line_no + static_cast<int>(v)))) *\n                           static_cast<size_t>(x_stride) +\n                       u;\n            }\n            *image = val;\n          }\n        }\n      } else if (channels[c].pixel_type == TINYEXR_PIXELTYPE_FLOAT) {\n        assert(requested_pixel_types[c] == TINYEXR_PIXELTYPE_FLOAT);\n        for (size_t v = 0; v < static_cast<size_t>(num_lines); v++) {\n          const float *line_ptr = reinterpret_cast<float *>(&outBuf.at(\n              v * pixel_data_size * static_cast<size_t>(x_stride) +\n              channel_offset_list[c] * static_cast<size_t>(x_stride)));\n          for (size_t u = 0; u < static_cast<size_t>(width); u++) {\n            float val;\n            // val = line_ptr[u];\n            tinyexr::cpy4(&val, line_ptr + u);\n\n            tinyexr::swap4(reinterpret_cast<unsigned int *>(&val));\n\n            float *image = reinterpret_cast<float **>(out_images)[c];\n            if (line_order == 0) {\n              image += (static_cast<size_t>(line_no) + v) *\n                           static_cast<size_t>(x_stride) +\n                       u;\n            } else {\n              image += static_cast<size_t>(\n                           (height - 1 - (line_no + static_cast<int>(v)))) *\n                           static_cast<size_t>(x_stride) +\n                       u;\n            }\n            *image = val;\n          }\n        }\n      } else {\n        assert(0);\n      }\n    }\n#else\n    assert(0 && \"PIZ is enabled in this build\");\n    return false;\n#endif\n\n  } else if (compression_type == TINYEXR_COMPRESSIONTYPE_ZIPS ||\n             compression_type == TINYEXR_COMPRESSIONTYPE_ZIP) {\n    // Allocate original data size.\n    std::vector<unsigned char> outBuf(static_cast<size_t>(width) *\n                                      static_cast<size_t>(num_lines) *\n                                      pixel_data_size);\n\n    unsigned long dstLen = static_cast<unsigned long>(outBuf.size());\n    assert(dstLen > 0);\n    if (!tinyexr::DecompressZip(\n            reinterpret_cast<unsigned char *>(&outBuf.at(0)), &dstLen, data_ptr,\n            static_cast<unsigned long>(data_len))) {\n      return false;\n    }\n\n    // For ZIP_COMPRESSION:\n    //   pixel sample data for channel 0 for scanline 0\n    //   pixel sample data for channel 1 for scanline 0\n    //   pixel sample data for channel ... for scanline 0\n    //   pixel sample data for channel n for scanline 0\n    //   pixel sample data for channel 0 for scanline 1\n    //   pixel sample data for channel 1 for scanline 1\n    //   pixel sample data for channel ... for scanline 1\n    //   pixel sample data for channel n for scanline 1\n    //   ...\n    for (size_t c = 0; c < static_cast<size_t>(num_channels); c++) {\n      if (channels[c].pixel_type == TINYEXR_PIXELTYPE_HALF) {\n        for (size_t v = 0; v < static_cast<size_t>(num_lines); v++) {\n          const unsigned short *line_ptr = reinterpret_cast<unsigned short *>(\n              &outBuf.at(v * static_cast<size_t>(pixel_data_size) *\n                             static_cast<size_t>(width) +\n                         channel_offset_list[c] * static_cast<size_t>(width)));\n          for (size_t u = 0; u < static_cast<size_t>(width); u++) {\n            tinyexr::FP16 hf;\n\n            // hf.u = line_ptr[u];\n            tinyexr::cpy2(&(hf.u), line_ptr + u);\n\n            tinyexr::swap2(reinterpret_cast<unsigned short *>(&hf.u));\n\n            if (requested_pixel_types[c] == TINYEXR_PIXELTYPE_HALF) {\n              unsigned short *image =\n                  reinterpret_cast<unsigned short **>(out_images)[c];\n              if (line_order == 0) {\n                image += (static_cast<size_t>(line_no) + v) *\n                             static_cast<size_t>(x_stride) +\n                         u;\n              } else {\n                image += (static_cast<size_t>(height) - 1U -\n                          (static_cast<size_t>(line_no) + v)) *\n                             static_cast<size_t>(x_stride) +\n                         u;\n              }\n              *image = hf.u;\n            } else {  // HALF -> FLOAT\n              tinyexr::FP32 f32 = half_to_float(hf);\n              float *image = reinterpret_cast<float **>(out_images)[c];\n              size_t offset = 0;\n              if (line_order == 0) {\n                offset = (static_cast<size_t>(line_no) + v) *\n                             static_cast<size_t>(x_stride) +\n                         u;\n              } else {\n                offset = (static_cast<size_t>(height) - 1U -\n                          (static_cast<size_t>(line_no) + v)) *\n                             static_cast<size_t>(x_stride) +\n                         u;\n              }\n              image += offset;\n\n              *image = f32.f;\n            }\n          }\n        }\n      } else if (channels[c].pixel_type == TINYEXR_PIXELTYPE_UINT) {\n        assert(requested_pixel_types[c] == TINYEXR_PIXELTYPE_UINT);\n\n        for (size_t v = 0; v < static_cast<size_t>(num_lines); v++) {\n          const unsigned int *line_ptr = reinterpret_cast<unsigned int *>(\n              &outBuf.at(v * pixel_data_size * static_cast<size_t>(width) +\n                         channel_offset_list[c] * static_cast<size_t>(width)));\n          for (size_t u = 0; u < static_cast<size_t>(width); u++) {\n            unsigned int val;\n            // val = line_ptr[u];\n            tinyexr::cpy4(&val, line_ptr + u);\n\n            tinyexr::swap4(&val);\n\n            unsigned int *image =\n                reinterpret_cast<unsigned int **>(out_images)[c];\n            if (line_order == 0) {\n              image += (static_cast<size_t>(line_no) + v) *\n                           static_cast<size_t>(x_stride) +\n                       u;\n            } else {\n              image += (static_cast<size_t>(height) - 1U -\n                        (static_cast<size_t>(line_no) + v)) *\n                           static_cast<size_t>(x_stride) +\n                       u;\n            }\n            *image = val;\n          }\n        }\n      } else if (channels[c].pixel_type == TINYEXR_PIXELTYPE_FLOAT) {\n        assert(requested_pixel_types[c] == TINYEXR_PIXELTYPE_FLOAT);\n        for (size_t v = 0; v < static_cast<size_t>(num_lines); v++) {\n          const float *line_ptr = reinterpret_cast<float *>(\n              &outBuf.at(v * pixel_data_size * static_cast<size_t>(width) +\n                         channel_offset_list[c] * static_cast<size_t>(width)));\n          for (size_t u = 0; u < static_cast<size_t>(width); u++) {\n            float val;\n            // val = line_ptr[u];\n            tinyexr::cpy4(&val, line_ptr + u);\n\n            tinyexr::swap4(reinterpret_cast<unsigned int *>(&val));\n\n            float *image = reinterpret_cast<float **>(out_images)[c];\n            if (line_order == 0) {\n              image += (static_cast<size_t>(line_no) + v) *\n                           static_cast<size_t>(x_stride) +\n                       u;\n            } else {\n              image += (static_cast<size_t>(height) - 1U -\n                        (static_cast<size_t>(line_no) + v)) *\n                           static_cast<size_t>(x_stride) +\n                       u;\n            }\n            *image = val;\n          }\n        }\n      } else {\n        assert(0);\n        return false;\n      }\n    }\n  } else if (compression_type == TINYEXR_COMPRESSIONTYPE_RLE) {\n    // Allocate original data size.\n    std::vector<unsigned char> outBuf(static_cast<size_t>(width) *\n                                      static_cast<size_t>(num_lines) *\n                                      pixel_data_size);\n\n    unsigned long dstLen = static_cast<unsigned long>(outBuf.size());\n    if (dstLen == 0) {\n      return false;\n    }\n\n    if (!tinyexr::DecompressRle(\n            reinterpret_cast<unsigned char *>(&outBuf.at(0)), dstLen, data_ptr,\n            static_cast<unsigned long>(data_len))) {\n      return false;\n    }\n\n    // For RLE_COMPRESSION:\n    //   pixel sample data for channel 0 for scanline 0\n    //   pixel sample data for channel 1 for scanline 0\n    //   pixel sample data for channel ... for scanline 0\n    //   pixel sample data for channel n for scanline 0\n    //   pixel sample data for channel 0 for scanline 1\n    //   pixel sample data for channel 1 for scanline 1\n    //   pixel sample data for channel ... for scanline 1\n    //   pixel sample data for channel n for scanline 1\n    //   ...\n    for (size_t c = 0; c < static_cast<size_t>(num_channels); c++) {\n      if (channels[c].pixel_type == TINYEXR_PIXELTYPE_HALF) {\n        for (size_t v = 0; v < static_cast<size_t>(num_lines); v++) {\n          const unsigned short *line_ptr = reinterpret_cast<unsigned short *>(\n              &outBuf.at(v * static_cast<size_t>(pixel_data_size) *\n                             static_cast<size_t>(width) +\n                         channel_offset_list[c] * static_cast<size_t>(width)));\n          for (size_t u = 0; u < static_cast<size_t>(width); u++) {\n            tinyexr::FP16 hf;\n\n            // hf.u = line_ptr[u];\n            tinyexr::cpy2(&(hf.u), line_ptr + u);\n\n            tinyexr::swap2(reinterpret_cast<unsigned short *>(&hf.u));\n\n            if (requested_pixel_types[c] == TINYEXR_PIXELTYPE_HALF) {\n              unsigned short *image =\n                  reinterpret_cast<unsigned short **>(out_images)[c];\n              if (line_order == 0) {\n                image += (static_cast<size_t>(line_no) + v) *\n                             static_cast<size_t>(x_stride) +\n                         u;\n              } else {\n                image += (static_cast<size_t>(height) - 1U -\n                          (static_cast<size_t>(line_no) + v)) *\n                             static_cast<size_t>(x_stride) +\n                         u;\n              }\n              *image = hf.u;\n            } else {  // HALF -> FLOAT\n              tinyexr::FP32 f32 = half_to_float(hf);\n              float *image = reinterpret_cast<float **>(out_images)[c];\n              if (line_order == 0) {\n                image += (static_cast<size_t>(line_no) + v) *\n                             static_cast<size_t>(x_stride) +\n                         u;\n              } else {\n                image += (static_cast<size_t>(height) - 1U -\n                          (static_cast<size_t>(line_no) + v)) *\n                             static_cast<size_t>(x_stride) +\n                         u;\n              }\n              *image = f32.f;\n            }\n          }\n        }\n      } else if (channels[c].pixel_type == TINYEXR_PIXELTYPE_UINT) {\n        assert(requested_pixel_types[c] == TINYEXR_PIXELTYPE_UINT);\n\n        for (size_t v = 0; v < static_cast<size_t>(num_lines); v++) {\n          const unsigned int *line_ptr = reinterpret_cast<unsigned int *>(\n              &outBuf.at(v * pixel_data_size * static_cast<size_t>(width) +\n                         channel_offset_list[c] * static_cast<size_t>(width)));\n          for (size_t u = 0; u < static_cast<size_t>(width); u++) {\n            unsigned int val;\n            // val = line_ptr[u];\n            tinyexr::cpy4(&val, line_ptr + u);\n\n            tinyexr::swap4(&val);\n\n            unsigned int *image =\n                reinterpret_cast<unsigned int **>(out_images)[c];\n            if (line_order == 0) {\n              image += (static_cast<size_t>(line_no) + v) *\n                           static_cast<size_t>(x_stride) +\n                       u;\n            } else {\n              image += (static_cast<size_t>(height) - 1U -\n                        (static_cast<size_t>(line_no) + v)) *\n                           static_cast<size_t>(x_stride) +\n                       u;\n            }\n            *image = val;\n          }\n        }\n      } else if (channels[c].pixel_type == TINYEXR_PIXELTYPE_FLOAT) {\n        assert(requested_pixel_types[c] == TINYEXR_PIXELTYPE_FLOAT);\n        for (size_t v = 0; v < static_cast<size_t>(num_lines); v++) {\n          const float *line_ptr = reinterpret_cast<float *>(\n              &outBuf.at(v * pixel_data_size * static_cast<size_t>(width) +\n                         channel_offset_list[c] * static_cast<size_t>(width)));\n          for (size_t u = 0; u < static_cast<size_t>(width); u++) {\n            float val;\n            // val = line_ptr[u];\n            tinyexr::cpy4(&val, line_ptr + u);\n\n            tinyexr::swap4(reinterpret_cast<unsigned int *>(&val));\n\n            float *image = reinterpret_cast<float **>(out_images)[c];\n            if (line_order == 0) {\n              image += (static_cast<size_t>(line_no) + v) *\n                           static_cast<size_t>(x_stride) +\n                       u;\n            } else {\n              image += (static_cast<size_t>(height) - 1U -\n                        (static_cast<size_t>(line_no) + v)) *\n                           static_cast<size_t>(x_stride) +\n                       u;\n            }\n            *image = val;\n          }\n        }\n      } else {\n        assert(0);\n        return false;\n      }\n    }\n  } else if (compression_type == TINYEXR_COMPRESSIONTYPE_ZFP) {\n#if TINYEXR_USE_ZFP\n    tinyexr::ZFPCompressionParam zfp_compression_param;\n    std::string e;\n    if (!tinyexr::FindZFPCompressionParam(&zfp_compression_param, attributes,\n                                          int(num_attributes), &e)) {\n      // This code path should not be reachable.\n      assert(0);\n      return false;\n    }\n\n    // Allocate original data size.\n    std::vector<unsigned char> outBuf(static_cast<size_t>(width) *\n                                      static_cast<size_t>(num_lines) *\n                                      pixel_data_size);\n\n    unsigned long dstLen = outBuf.size();\n    assert(dstLen > 0);\n    tinyexr::DecompressZfp(reinterpret_cast<float *>(&outBuf.at(0)), width,\n                           num_lines, num_channels, data_ptr,\n                           static_cast<unsigned long>(data_len),\n                           zfp_compression_param);\n\n    // For ZFP_COMPRESSION:\n    //   pixel sample data for channel 0 for scanline 0\n    //   pixel sample data for channel 1 for scanline 0\n    //   pixel sample data for channel ... for scanline 0\n    //   pixel sample data for channel n for scanline 0\n    //   pixel sample data for channel 0 for scanline 1\n    //   pixel sample data for channel 1 for scanline 1\n    //   pixel sample data for channel ... for scanline 1\n    //   pixel sample data for channel n for scanline 1\n    //   ...\n    for (size_t c = 0; c < static_cast<size_t>(num_channels); c++) {\n      assert(channels[c].pixel_type == TINYEXR_PIXELTYPE_FLOAT);\n      if (channels[c].pixel_type == TINYEXR_PIXELTYPE_FLOAT) {\n        assert(requested_pixel_types[c] == TINYEXR_PIXELTYPE_FLOAT);\n        for (size_t v = 0; v < static_cast<size_t>(num_lines); v++) {\n          const float *line_ptr = reinterpret_cast<float *>(\n              &outBuf.at(v * pixel_data_size * static_cast<size_t>(width) +\n                         channel_offset_list[c] * static_cast<size_t>(width)));\n          for (size_t u = 0; u < static_cast<size_t>(width); u++) {\n            float val;\n            tinyexr::cpy4(&val, line_ptr + u);\n\n            tinyexr::swap4(reinterpret_cast<unsigned int *>(&val));\n\n            float *image = reinterpret_cast<float **>(out_images)[c];\n            if (line_order == 0) {\n              image += (static_cast<size_t>(line_no) + v) *\n                           static_cast<size_t>(x_stride) +\n                       u;\n            } else {\n              image += (static_cast<size_t>(height) - 1U -\n                        (static_cast<size_t>(line_no) + v)) *\n                           static_cast<size_t>(x_stride) +\n                       u;\n            }\n            *image = val;\n          }\n        }\n      } else {\n        assert(0);\n        return false;\n      }\n    }\n#else\n    (void)attributes;\n    (void)num_attributes;\n    (void)num_channels;\n    assert(0);\n    return false;\n#endif\n  } else if (compression_type == TINYEXR_COMPRESSIONTYPE_NONE) {\n    for (size_t c = 0; c < num_channels; c++) {\n      for (size_t v = 0; v < static_cast<size_t>(num_lines); v++) {\n        if (channels[c].pixel_type == TINYEXR_PIXELTYPE_HALF) {\n          const unsigned short *line_ptr =\n              reinterpret_cast<const unsigned short *>(\n                  data_ptr + v * pixel_data_size * size_t(width) +\n                  channel_offset_list[c] * static_cast<size_t>(width));\n\n          if (requested_pixel_types[c] == TINYEXR_PIXELTYPE_HALF) {\n            unsigned short *outLine =\n                reinterpret_cast<unsigned short *>(out_images[c]);\n            if (line_order == 0) {\n              outLine += (size_t(y) + v) * size_t(x_stride);\n            } else {\n              outLine +=\n                  (size_t(height) - 1 - (size_t(y) + v)) * size_t(x_stride);\n            }\n\n            for (int u = 0; u < width; u++) {\n              tinyexr::FP16 hf;\n\n              // hf.u = line_ptr[u];\n              tinyexr::cpy2(&(hf.u), line_ptr + u);\n\n              tinyexr::swap2(reinterpret_cast<unsigned short *>(&hf.u));\n\n              outLine[u] = hf.u;\n            }\n          } else if (requested_pixel_types[c] == TINYEXR_PIXELTYPE_FLOAT) {\n            float *outLine = reinterpret_cast<float *>(out_images[c]);\n            if (line_order == 0) {\n              outLine += (size_t(y) + v) * size_t(x_stride);\n            } else {\n              outLine +=\n                  (size_t(height) - 1 - (size_t(y) + v)) * size_t(x_stride);\n            }\n\n            if (reinterpret_cast<const unsigned char *>(line_ptr + width) >\n                (data_ptr + data_len)) {\n              // Insufficient data size\n              return false;\n            }\n\n            for (int u = 0; u < width; u++) {\n              tinyexr::FP16 hf;\n\n              // address may not be aliged. use byte-wise copy for safety.#76\n              // hf.u = line_ptr[u];\n              tinyexr::cpy2(&(hf.u), line_ptr + u);\n\n              tinyexr::swap2(reinterpret_cast<unsigned short *>(&hf.u));\n\n              tinyexr::FP32 f32 = half_to_float(hf);\n\n              outLine[u] = f32.f;\n            }\n          } else {\n            assert(0);\n            return false;\n          }\n        } else if (channels[c].pixel_type == TINYEXR_PIXELTYPE_FLOAT) {\n          const float *line_ptr = reinterpret_cast<const float *>(\n              data_ptr + v * pixel_data_size * size_t(width) +\n              channel_offset_list[c] * static_cast<size_t>(width));\n\n          float *outLine = reinterpret_cast<float *>(out_images[c]);\n          if (line_order == 0) {\n            outLine += (size_t(y) + v) * size_t(x_stride);\n          } else {\n            outLine +=\n                (size_t(height) - 1 - (size_t(y) + v)) * size_t(x_stride);\n          }\n\n          if (reinterpret_cast<const unsigned char *>(line_ptr + width) >\n              (data_ptr + data_len)) {\n            // Insufficient data size\n            return false;\n          }\n\n          for (int u = 0; u < width; u++) {\n            float val;\n            tinyexr::cpy4(&val, line_ptr + u);\n\n            tinyexr::swap4(reinterpret_cast<unsigned int *>(&val));\n\n            outLine[u] = val;\n          }\n        } else if (channels[c].pixel_type == TINYEXR_PIXELTYPE_UINT) {\n          const unsigned int *line_ptr = reinterpret_cast<const unsigned int *>(\n              data_ptr + v * pixel_data_size * size_t(width) +\n              channel_offset_list[c] * static_cast<size_t>(width));\n\n          unsigned int *outLine =\n              reinterpret_cast<unsigned int *>(out_images[c]);\n          if (line_order == 0) {\n            outLine += (size_t(y) + v) * size_t(x_stride);\n          } else {\n            outLine +=\n                (size_t(height) - 1 - (size_t(y) + v)) * size_t(x_stride);\n          }\n\n          for (int u = 0; u < width; u++) {\n            if (reinterpret_cast<const unsigned char *>(line_ptr + u) >=\n                (data_ptr + data_len)) {\n              // Corrupsed data?\n              return false;\n            }\n\n            unsigned int val;\n            tinyexr::cpy4(&val, line_ptr + u);\n\n            tinyexr::swap4(reinterpret_cast<unsigned int *>(&val));\n\n            outLine[u] = val;\n          }\n        }\n      }\n    }\n  }\n\n  return true;\n}",
  "abstract_func_before": "static bool DecodePixelData(/* COMMENT_0 */ unsigned char **VAR_0,\n                            const int *VAR_1,\n                            const unsigned char *VAR_2, size_t VAR_3,\n                            int VAR_4, int VAR_5, int VAR_6,\n                            int VAR_7, int VAR_8, int VAR_9, int VAR_10,\n                            int VAR_11, size_t VAR_12,\n                            size_t VAR_13,\n                            const EXRAttribute *VAR_14, size_t VAR_15,\n                            const EXRChannelInfo *VAR_16,\n                            const std::vector<size_t> &VAR_17) {\n  if (VAR_4 == VAR_18) {  /* COMMENT_1 */\n#if VAR_19\n    if ((VAR_6 == 0) || (VAR_11 == 0) || (VAR_12 == 0)) {\n      /* COMMENT_2 */\n      return false;\n    }\n\n    /* COMMENT_3 */\n    std::vector<unsigned char> VAR_20(VAR_21<size_t>(\n        VAR_21<size_t>(VAR_6 * VAR_11) * VAR_12));\n    size_t VAR_22 = VAR_20.size();\n\n    bool VAR_23 = tinyexr::DecompressPiz(\n        VAR_24<unsigned char *>(&VAR_20.at(0)), VAR_2, VAR_22,\n        VAR_3, VAR_21<int>(VAR_15), VAR_16, VAR_6, VAR_11);\n\n    if (!VAR_23) {\n      return false;\n    }\n\n    /* COMMENT_4 */\n    /* COMMENT_5 */\n    /* COMMENT_6 */\n    /* COMMENT_7 */\n    /* COMMENT_8 */\n    /* COMMENT_9 */\n    /* COMMENT_10 */\n    /* COMMENT_11 */\n    /* COMMENT_12 */\n    /* COMMENT_13 */\n    for (size_t VAR_25 = 0; VAR_25 < VAR_21<size_t>(VAR_15); VAR_25++) {\n      if (VAR_16[VAR_25].pixel_type == VAR_26) {\n        for (size_t VAR_27 = 0; VAR_27 < VAR_21<size_t>(VAR_11); VAR_27++) {\n          const unsigned short *VAR_28 = VAR_24<unsigned short *>(\n              &VAR_20.at(VAR_27 * VAR_12 * VAR_21<size_t>(VAR_6) +\n                         VAR_17[VAR_25] * VAR_21<size_t>(VAR_6)));\n          for (size_t VAR_29 = 0; VAR_29 < VAR_21<size_t>(VAR_6); VAR_29++) {\n            FP16 VAR_30;\n\n            /* COMMENT_14 */\n            /* COMMENT_15 */\n            /* COMMENT_16 */\n            tinyexr::cpy2(&(VAR_30.u), VAR_28 + VAR_29);\n\n            tinyexr::swap2(VAR_24<unsigned short *>(&VAR_30.u));\n\n            if (VAR_1[VAR_25] == VAR_26) {\n              unsigned short *VAR_31 =\n                  VAR_24<unsigned short **>(VAR_0)[VAR_25];\n              if (VAR_5 == 0) {\n                VAR_31 += (VAR_21<size_t>(VAR_10) + VAR_27) *\n                             VAR_21<size_t>(VAR_8) +\n                         VAR_29;\n              } else {\n                VAR_31 += VAR_21<size_t>(\n                             (VAR_7 - 1 - (VAR_10 + VAR_21<int>(VAR_27)))) *\n                             VAR_21<size_t>(VAR_8) +\n                         VAR_29;\n              }\n              *VAR_31 = VAR_30.u;\n            } else {  /* COMMENT_17 */\n              FP32 VAR_32 = half_to_float(VAR_30);\n              float *VAR_31 = VAR_24<float **>(VAR_0)[VAR_25];\n              size_t VAR_33 = 0;\n              if (VAR_5 == 0) {\n                VAR_33 = (VAR_21<size_t>(VAR_10) + VAR_27) *\n                             VAR_21<size_t>(VAR_8) +\n                         VAR_29;\n              } else {\n                VAR_33 = VAR_21<size_t>(\n                             (VAR_7 - 1 - (VAR_10 + VAR_21<int>(VAR_27)))) *\n                             VAR_21<size_t>(VAR_8) +\n                         VAR_29;\n              }\n              VAR_31 += VAR_33;\n              *VAR_31 = VAR_32.f;\n            }\n          }\n        }\n      } else if (VAR_16[VAR_25].pixel_type == VAR_34) {\n        assert(VAR_1[VAR_25] == VAR_34);\n\n        for (size_t VAR_27 = 0; VAR_27 < VAR_21<size_t>(VAR_11); VAR_27++) {\n          const unsigned int *VAR_28 = VAR_24<unsigned int *>(\n              &VAR_20.at(VAR_27 * VAR_12 * VAR_21<size_t>(VAR_6) +\n                         VAR_17[VAR_25] * VAR_21<size_t>(VAR_6)));\n          for (size_t VAR_29 = 0; VAR_29 < VAR_21<size_t>(VAR_6); VAR_29++) {\n            unsigned int VAR_35;\n            /* COMMENT_18 */\n            tinyexr::cpy4(&VAR_35, VAR_28 + VAR_29);\n\n            tinyexr::swap4(&VAR_35);\n\n            unsigned int *VAR_31 =\n                VAR_24<unsigned int **>(VAR_0)[VAR_25];\n            if (VAR_5 == 0) {\n              VAR_31 += (VAR_21<size_t>(VAR_10) + VAR_27) *\n                           VAR_21<size_t>(VAR_8) +\n                       VAR_29;\n            } else {\n              VAR_31 += VAR_21<size_t>(\n                           (VAR_7 - 1 - (VAR_10 + VAR_21<int>(VAR_27)))) *\n                           VAR_21<size_t>(VAR_8) +\n                       VAR_29;\n            }\n            *VAR_31 = VAR_35;\n          }\n        }\n      } else if (VAR_16[VAR_25].pixel_type == VAR_36) {\n        assert(VAR_1[VAR_25] == VAR_36);\n        for (size_t VAR_27 = 0; VAR_27 < VAR_21<size_t>(VAR_11); VAR_27++) {\n          const float *VAR_28 = VAR_24<float *>(&VAR_20.at(\n              VAR_27 * VAR_12 * VAR_21<size_t>(VAR_8) +\n              VAR_17[VAR_25] * VAR_21<size_t>(VAR_8)));\n          for (size_t VAR_29 = 0; VAR_29 < VAR_21<size_t>(VAR_6); VAR_29++) {\n            float VAR_35;\n            /* COMMENT_18 */\n            tinyexr::cpy4(&VAR_35, VAR_28 + VAR_29);\n\n            tinyexr::swap4(VAR_24<unsigned int *>(&VAR_35));\n\n            float *VAR_31 = VAR_24<float **>(VAR_0)[VAR_25];\n            if (VAR_5 == 0) {\n              VAR_31 += (VAR_21<size_t>(VAR_10) + VAR_27) *\n                           VAR_21<size_t>(VAR_8) +\n                       VAR_29;\n            } else {\n              VAR_31 += VAR_21<size_t>(\n                           (VAR_7 - 1 - (VAR_10 + VAR_21<int>(VAR_27)))) *\n                           VAR_21<size_t>(VAR_8) +\n                       VAR_29;\n            }\n            *VAR_31 = VAR_35;\n          }\n        }\n      } else {\n        assert(0);\n      }\n    }\n#else\n    assert(0 && \"PIZ is enabled in this build\");\n    return false;\n#endif\n\n  } else if (VAR_4 == VAR_37 ||\n             VAR_4 == VAR_38) {\n    /* COMMENT_3 */\n    std::vector<unsigned char> VAR_20(VAR_21<size_t>(VAR_6) *\n                                      VAR_21<size_t>(VAR_11) *\n                                      VAR_12);\n\n    unsigned long VAR_39 = VAR_21<unsigned long>(VAR_20.size());\n    assert(VAR_39 > 0);\n    if (!tinyexr::DecompressZip(\n            VAR_24<unsigned char *>(&VAR_20.at(0)), &VAR_39, VAR_2,\n            VAR_21<unsigned long>(VAR_3))) {\n      return false;\n    }\n\n    /* COMMENT_19 */\n    /* COMMENT_5 */\n    /* COMMENT_6 */\n    /* COMMENT_7 */\n    /* COMMENT_8 */\n    /* COMMENT_9 */\n    /* COMMENT_10 */\n    /* COMMENT_11 */\n    /* COMMENT_12 */\n    /* COMMENT_13 */\n    for (size_t VAR_25 = 0; VAR_25 < VAR_21<size_t>(VAR_15); VAR_25++) {\n      if (VAR_16[VAR_25].pixel_type == VAR_26) {\n        for (size_t VAR_27 = 0; VAR_27 < VAR_21<size_t>(VAR_11); VAR_27++) {\n          const unsigned short *VAR_28 = VAR_24<unsigned short *>(\n              &VAR_20.at(VAR_27 * VAR_21<size_t>(VAR_12) *\n                             VAR_21<size_t>(VAR_6) +\n                         VAR_17[VAR_25] * VAR_21<size_t>(VAR_6)));\n          for (size_t VAR_29 = 0; VAR_29 < VAR_21<size_t>(VAR_6); VAR_29++) {\n            tinyexr::FP16 VAR_30;\n\n            /* COMMENT_14 */\n            tinyexr::cpy2(&(VAR_30.u), VAR_28 + VAR_29);\n\n            tinyexr::swap2(VAR_24<unsigned short *>(&VAR_30.u));\n\n            if (VAR_1[VAR_25] == VAR_26) {\n              unsigned short *VAR_31 =\n                  VAR_24<unsigned short **>(VAR_0)[VAR_25];\n              if (VAR_5 == 0) {\n                VAR_31 += (VAR_21<size_t>(VAR_10) + VAR_27) *\n                             VAR_21<size_t>(VAR_8) +\n                         VAR_29;\n              } else {\n                VAR_31 += (VAR_21<size_t>(VAR_7) - 1U -\n                          (VAR_21<size_t>(VAR_10) + VAR_27)) *\n                             VAR_21<size_t>(VAR_8) +\n                         VAR_29;\n              }\n              *VAR_31 = VAR_30.u;\n            } else {  /* COMMENT_17 */\n              tinyexr::FP32 VAR_32 = half_to_float(VAR_30);\n              float *VAR_31 = VAR_24<float **>(VAR_0)[VAR_25];\n              size_t VAR_33 = 0;\n              if (VAR_5 == 0) {\n                VAR_33 = (VAR_21<size_t>(VAR_10) + VAR_27) *\n                             VAR_21<size_t>(VAR_8) +\n                         VAR_29;\n              } else {\n                VAR_33 = (VAR_21<size_t>(VAR_7) - 1U -\n                          (VAR_21<size_t>(VAR_10) + VAR_27)) *\n                             VAR_21<size_t>(VAR_8) +\n                         VAR_29;\n              }\n              VAR_31 += VAR_33;\n\n              *VAR_31 = VAR_32.f;\n            }\n          }\n        }\n      } else if (VAR_16[VAR_25].pixel_type == VAR_34) {\n        assert(VAR_1[VAR_25] == VAR_34);\n\n        for (size_t VAR_27 = 0; VAR_27 < VAR_21<size_t>(VAR_11); VAR_27++) {\n          const unsigned int *VAR_28 = VAR_24<unsigned int *>(\n              &VAR_20.at(VAR_27 * VAR_12 * VAR_21<size_t>(VAR_6) +\n                         VAR_17[VAR_25] * VAR_21<size_t>(VAR_6)));\n          for (size_t VAR_29 = 0; VAR_29 < VAR_21<size_t>(VAR_6); VAR_29++) {\n            unsigned int VAR_35;\n            /* COMMENT_18 */\n            tinyexr::cpy4(&VAR_35, VAR_28 + VAR_29);\n\n            tinyexr::swap4(&VAR_35);\n\n            unsigned int *VAR_31 =\n                VAR_24<unsigned int **>(VAR_0)[VAR_25];\n            if (VAR_5 == 0) {\n              VAR_31 += (VAR_21<size_t>(VAR_10) + VAR_27) *\n                           VAR_21<size_t>(VAR_8) +\n                       VAR_29;\n            } else {\n              VAR_31 += (VAR_21<size_t>(VAR_7) - 1U -\n                        (VAR_21<size_t>(VAR_10) + VAR_27)) *\n                           VAR_21<size_t>(VAR_8) +\n                       VAR_29;\n            }\n            *VAR_31 = VAR_35;\n          }\n        }\n      } else if (VAR_16[VAR_25].pixel_type == VAR_36) {\n        assert(VAR_1[VAR_25] == VAR_36);\n        for (size_t VAR_27 = 0; VAR_27 < VAR_21<size_t>(VAR_11); VAR_27++) {\n          const float *VAR_28 = VAR_24<float *>(\n              &VAR_20.at(VAR_27 * VAR_12 * VAR_21<size_t>(VAR_6) +\n                         VAR_17[VAR_25] * VAR_21<size_t>(VAR_6)));\n          for (size_t VAR_29 = 0; VAR_29 < VAR_21<size_t>(VAR_6); VAR_29++) {\n            float VAR_35;\n            /* COMMENT_18 */\n            tinyexr::cpy4(&VAR_35, VAR_28 + VAR_29);\n\n            tinyexr::swap4(VAR_24<unsigned int *>(&VAR_35));\n\n            float *VAR_31 = VAR_24<float **>(VAR_0)[VAR_25];\n            if (VAR_5 == 0) {\n              VAR_31 += (VAR_21<size_t>(VAR_10) + VAR_27) *\n                           VAR_21<size_t>(VAR_8) +\n                       VAR_29;\n            } else {\n              VAR_31 += (VAR_21<size_t>(VAR_7) - 1U -\n                        (VAR_21<size_t>(VAR_10) + VAR_27)) *\n                           VAR_21<size_t>(VAR_8) +\n                       VAR_29;\n            }\n            *VAR_31 = VAR_35;\n          }\n        }\n      } else {\n        assert(0);\n        return false;\n      }\n    }\n  } else if (VAR_4 == VAR_40) {\n    /* COMMENT_3 */\n    std::vector<unsigned char> VAR_20(VAR_21<size_t>(VAR_6) *\n                                      VAR_21<size_t>(VAR_11) *\n                                      VAR_12);\n\n    unsigned long VAR_39 = VAR_21<unsigned long>(VAR_20.size());\n    if (VAR_39 == 0) {\n      return false;\n    }\n\n    if (!tinyexr::DecompressRle(\n            VAR_24<unsigned char *>(&VAR_20.at(0)), VAR_39, VAR_2,\n            VAR_21<unsigned long>(VAR_3))) {\n      return false;\n    }\n\n    /* COMMENT_20 */\n    /* COMMENT_5 */\n    /* COMMENT_6 */\n    /* COMMENT_7 */\n    /* COMMENT_8 */\n    /* COMMENT_9 */\n    /* COMMENT_10 */\n    /* COMMENT_11 */\n    /* COMMENT_12 */\n    /* COMMENT_13 */\n    for (size_t VAR_25 = 0; VAR_25 < VAR_21<size_t>(VAR_15); VAR_25++) {\n      if (VAR_16[VAR_25].pixel_type == VAR_26) {\n        for (size_t VAR_27 = 0; VAR_27 < VAR_21<size_t>(VAR_11); VAR_27++) {\n          const unsigned short *VAR_28 = VAR_24<unsigned short *>(\n              &VAR_20.at(VAR_27 * VAR_21<size_t>(VAR_12) *\n                             VAR_21<size_t>(VAR_6) +\n                         VAR_17[VAR_25] * VAR_21<size_t>(VAR_6)));\n          for (size_t VAR_29 = 0; VAR_29 < VAR_21<size_t>(VAR_6); VAR_29++) {\n            tinyexr::FP16 VAR_30;\n\n            /* COMMENT_14 */\n            tinyexr::cpy2(&(VAR_30.u), VAR_28 + VAR_29);\n\n            tinyexr::swap2(VAR_24<unsigned short *>(&VAR_30.u));\n\n            if (VAR_1[VAR_25] == VAR_26) {\n              unsigned short *VAR_31 =\n                  VAR_24<unsigned short **>(VAR_0)[VAR_25];\n              if (VAR_5 == 0) {\n                VAR_31 += (VAR_21<size_t>(VAR_10) + VAR_27) *\n                             VAR_21<size_t>(VAR_8) +\n                         VAR_29;\n              } else {\n                VAR_31 += (VAR_21<size_t>(VAR_7) - 1U -\n                          (VAR_21<size_t>(VAR_10) + VAR_27)) *\n                             VAR_21<size_t>(VAR_8) +\n                         VAR_29;\n              }\n              *VAR_31 = VAR_30.u;\n            } else {  /* COMMENT_17 */\n              tinyexr::FP32 VAR_32 = half_to_float(VAR_30);\n              float *VAR_31 = VAR_24<float **>(VAR_0)[VAR_25];\n              if (VAR_5 == 0) {\n                VAR_31 += (VAR_21<size_t>(VAR_10) + VAR_27) *\n                             VAR_21<size_t>(VAR_8) +\n                         VAR_29;\n              } else {\n                VAR_31 += (VAR_21<size_t>(VAR_7) - 1U -\n                          (VAR_21<size_t>(VAR_10) + VAR_27)) *\n                             VAR_21<size_t>(VAR_8) +\n                         VAR_29;\n              }\n              *VAR_31 = VAR_32.f;\n            }\n          }\n        }\n      } else if (VAR_16[VAR_25].pixel_type == VAR_34) {\n        assert(VAR_1[VAR_25] == VAR_34);\n\n        for (size_t VAR_27 = 0; VAR_27 < VAR_21<size_t>(VAR_11); VAR_27++) {\n          const unsigned int *VAR_28 = VAR_24<unsigned int *>(\n              &VAR_20.at(VAR_27 * VAR_12 * VAR_21<size_t>(VAR_6) +\n                         VAR_17[VAR_25] * VAR_21<size_t>(VAR_6)));\n          for (size_t VAR_29 = 0; VAR_29 < VAR_21<size_t>(VAR_6); VAR_29++) {\n            unsigned int VAR_35;\n            /* COMMENT_18 */\n            tinyexr::cpy4(&VAR_35, VAR_28 + VAR_29);\n\n            tinyexr::swap4(&VAR_35);\n\n            unsigned int *VAR_31 =\n                VAR_24<unsigned int **>(VAR_0)[VAR_25];\n            if (VAR_5 == 0) {\n              VAR_31 += (VAR_21<size_t>(VAR_10) + VAR_27) *\n                           VAR_21<size_t>(VAR_8) +\n                       VAR_29;\n            } else {\n              VAR_31 += (VAR_21<size_t>(VAR_7) - 1U -\n                        (VAR_21<size_t>(VAR_10) + VAR_27)) *\n                           VAR_21<size_t>(VAR_8) +\n                       VAR_29;\n            }\n            *VAR_31 = VAR_35;\n          }\n        }\n      } else if (VAR_16[VAR_25].pixel_type == VAR_36) {\n        assert(VAR_1[VAR_25] == VAR_36);\n        for (size_t VAR_27 = 0; VAR_27 < VAR_21<size_t>(VAR_11); VAR_27++) {\n          const float *VAR_28 = VAR_24<float *>(\n              &VAR_20.at(VAR_27 * VAR_12 * VAR_21<size_t>(VAR_6) +\n                         VAR_17[VAR_25] * VAR_21<size_t>(VAR_6)));\n          for (size_t VAR_29 = 0; VAR_29 < VAR_21<size_t>(VAR_6); VAR_29++) {\n            float VAR_35;\n            /* COMMENT_18 */\n            tinyexr::cpy4(&VAR_35, VAR_28 + VAR_29);\n\n            tinyexr::swap4(VAR_24<unsigned int *>(&VAR_35));\n\n            float *VAR_31 = VAR_24<float **>(VAR_0)[VAR_25];\n            if (VAR_5 == 0) {\n              VAR_31 += (VAR_21<size_t>(VAR_10) + VAR_27) *\n                           VAR_21<size_t>(VAR_8) +\n                       VAR_29;\n            } else {\n              VAR_31 += (VAR_21<size_t>(VAR_7) - 1U -\n                        (VAR_21<size_t>(VAR_10) + VAR_27)) *\n                           VAR_21<size_t>(VAR_8) +\n                       VAR_29;\n            }\n            *VAR_31 = VAR_35;\n          }\n        }\n      } else {\n        assert(0);\n        return false;\n      }\n    }\n  } else if (VAR_4 == VAR_41) {\n#if VAR_42\n    tinyexr::ZFPCompressionParam VAR_43;\n    std::string VAR_44;\n    if (!tinyexr::FindZFPCompressionParam(&VAR_43, VAR_14,\n                                          int(VAR_13), &VAR_44)) {\n      /* COMMENT_21 */\n      assert(0);\n      return false;\n    }\n\n    /* COMMENT_3 */\n    std::vector<unsigned char> VAR_20(VAR_21<size_t>(VAR_6) *\n                                      VAR_21<size_t>(VAR_11) *\n                                      VAR_12);\n\n    unsigned long VAR_39 = VAR_20.size();\n    assert(VAR_39 > 0);\n    tinyexr::DecompressZfp(VAR_24<float *>(&VAR_20.at(0)), VAR_6,\n                           VAR_11, VAR_15, VAR_2,\n                           VAR_21<unsigned long>(VAR_3),\n                           VAR_43);\n\n    /* COMMENT_22 */\n    /* COMMENT_5 */\n    /* COMMENT_6 */\n    /* COMMENT_7 */\n    /* COMMENT_8 */\n    /* COMMENT_9 */\n    /* COMMENT_10 */\n    /* COMMENT_11 */\n    /* COMMENT_12 */\n    /* COMMENT_13 */\n    for (size_t VAR_25 = 0; VAR_25 < VAR_21<size_t>(VAR_15); VAR_25++) {\n      assert(VAR_16[VAR_25].pixel_type == VAR_36);\n      if (VAR_16[VAR_25].pixel_type == VAR_36) {\n        assert(VAR_1[VAR_25] == VAR_36);\n        for (size_t VAR_27 = 0; VAR_27 < VAR_21<size_t>(VAR_11); VAR_27++) {\n          const float *VAR_28 = VAR_24<float *>(\n              &VAR_20.at(VAR_27 * VAR_12 * VAR_21<size_t>(VAR_6) +\n                         VAR_17[VAR_25] * VAR_21<size_t>(VAR_6)));\n          for (size_t VAR_29 = 0; VAR_29 < VAR_21<size_t>(VAR_6); VAR_29++) {\n            float VAR_35;\n            tinyexr::cpy4(&VAR_35, VAR_28 + VAR_29);\n\n            tinyexr::swap4(VAR_24<unsigned int *>(&VAR_35));\n\n            float *VAR_31 = VAR_24<float **>(VAR_0)[VAR_25];\n            if (VAR_5 == 0) {\n              VAR_31 += (VAR_21<size_t>(VAR_10) + VAR_27) *\n                           VAR_21<size_t>(VAR_8) +\n                       VAR_29;\n            } else {\n              VAR_31 += (VAR_21<size_t>(VAR_7) - 1U -\n                        (VAR_21<size_t>(VAR_10) + VAR_27)) *\n                           VAR_21<size_t>(VAR_8) +\n                       VAR_29;\n            }\n            *VAR_31 = VAR_35;\n          }\n        }\n      } else {\n        assert(0);\n        return false;\n      }\n    }\n#else\n    (void)VAR_14;\n    (void)VAR_13;\n    (void)VAR_15;\n    assert(0);\n    return false;\n#endif\n  } else if (VAR_4 == VAR_45) {\n    for (size_t VAR_25 = 0; VAR_25 < VAR_15; VAR_25++) {\n      for (size_t VAR_27 = 0; VAR_27 < VAR_21<size_t>(VAR_11); VAR_27++) {\n        if (VAR_16[VAR_25].pixel_type == VAR_26) {\n          const unsigned short *VAR_28 =\n              VAR_24<const unsigned short *>(\n                  VAR_2 + VAR_27 * VAR_12 * size_t(VAR_6) +\n                  VAR_17[VAR_25] * VAR_21<size_t>(VAR_6));\n\n          if (VAR_1[VAR_25] == VAR_26) {\n            unsigned short *VAR_46 =\n                VAR_24<unsigned short *>(VAR_0[VAR_25]);\n            if (VAR_5 == 0) {\n              VAR_46 += (size_t(VAR_9) + VAR_27) * size_t(VAR_8);\n            } else {\n              VAR_46 +=\n                  (size_t(VAR_7) - 1 - (size_t(VAR_9) + VAR_27)) * size_t(VAR_8);\n            }\n\n            for (int VAR_29 = 0; VAR_29 < VAR_6; VAR_29++) {\n              tinyexr::FP16 VAR_30;\n\n              /* COMMENT_14 */\n              tinyexr::cpy2(&(VAR_30.u), VAR_28 + VAR_29);\n\n              tinyexr::swap2(VAR_24<unsigned short *>(&VAR_30.u));\n\n              VAR_46[VAR_29] = VAR_30.u;\n            }\n          } else if (VAR_1[VAR_25] == VAR_36) {\n            float *VAR_46 = VAR_24<float *>(VAR_0[VAR_25]);\n            if (VAR_5 == 0) {\n              VAR_46 += (size_t(VAR_9) + VAR_27) * size_t(VAR_8);\n            } else {\n              VAR_46 +=\n                  (size_t(VAR_7) - 1 - (size_t(VAR_9) + VAR_27)) * size_t(VAR_8);\n            }\n\n            if (VAR_24<const unsigned char *>(VAR_28 + VAR_6) >\n                (VAR_2 + VAR_3)) {\n              /* COMMENT_23 */\n              return false;\n            }\n\n            for (int VAR_29 = 0; VAR_29 < VAR_6; VAR_29++) {\n              tinyexr::FP16 VAR_30;\n\n              /* COMMENT_24 */\n              /* COMMENT_14 */\n              tinyexr::cpy2(&(VAR_30.u), VAR_28 + VAR_29);\n\n              tinyexr::swap2(VAR_24<unsigned short *>(&VAR_30.u));\n\n              tinyexr::FP32 VAR_32 = half_to_float(VAR_30);\n\n              VAR_46[VAR_29] = VAR_32.f;\n            }\n          } else {\n            assert(0);\n            return false;\n          }\n        } else if (VAR_16[VAR_25].pixel_type == VAR_36) {\n          const float *VAR_28 = VAR_24<const float *>(\n              VAR_2 + VAR_27 * VAR_12 * size_t(VAR_6) +\n              VAR_17[VAR_25] * VAR_21<size_t>(VAR_6));\n\n          float *VAR_46 = VAR_24<float *>(VAR_0[VAR_25]);\n          if (VAR_5 == 0) {\n            VAR_46 += (size_t(VAR_9) + VAR_27) * size_t(VAR_8);\n          } else {\n            VAR_46 +=\n                (size_t(VAR_7) - 1 - (size_t(VAR_9) + VAR_27)) * size_t(VAR_8);\n          }\n\n          if (VAR_24<const unsigned char *>(VAR_28 + VAR_6) >\n              (VAR_2 + VAR_3)) {\n            /* COMMENT_23 */\n            return false;\n          }\n\n          for (int VAR_29 = 0; VAR_29 < VAR_6; VAR_29++) {\n            float VAR_35;\n            tinyexr::cpy4(&VAR_35, VAR_28 + VAR_29);\n\n            tinyexr::swap4(VAR_24<unsigned int *>(&VAR_35));\n\n            VAR_46[VAR_29] = VAR_35;\n          }\n        } else if (VAR_16[VAR_25].pixel_type == VAR_34) {\n          const unsigned int *VAR_28 = VAR_24<const unsigned int *>(\n              VAR_2 + VAR_27 * VAR_12 * size_t(VAR_6) +\n              VAR_17[VAR_25] * VAR_21<size_t>(VAR_6));\n\n          unsigned int *VAR_46 =\n              VAR_24<unsigned int *>(VAR_0[VAR_25]);\n          if (VAR_5 == 0) {\n            VAR_46 += (size_t(VAR_9) + VAR_27) * size_t(VAR_8);\n          } else {\n            VAR_46 +=\n                (size_t(VAR_7) - 1 - (size_t(VAR_9) + VAR_27)) * size_t(VAR_8);\n          }\n\n          for (int VAR_29 = 0; VAR_29 < VAR_6; VAR_29++) {\n            if (VAR_24<const unsigned char *>(VAR_28 + VAR_29) >=\n                (VAR_2 + VAR_3)) {\n              /* COMMENT_25 */\n              return false;\n            }\n\n            unsigned int VAR_35;\n            tinyexr::cpy4(&VAR_35, VAR_28 + VAR_29);\n\n            tinyexr::swap4(VAR_24<unsigned int *>(&VAR_35));\n\n            VAR_46[VAR_29] = VAR_35;\n          }\n        }\n      }\n    }\n  }\n\n  return true;\n}",
  "func_graph_path_before": "syoyo/tinyexr/9c602a37b3d3a1d98d473cda32b88f8014344990/tinyexr.h/vul/before/0.json",
  "func": "static bool DecodePixelData(/* out */ unsigned char **out_images,\n                            const int *requested_pixel_types,\n                            const unsigned char *data_ptr, size_t data_len,\n                            int compression_type, int line_order, int width,\n                            int height, int x_stride, int y, int line_no,\n                            int num_lines, size_t pixel_data_size,\n                            size_t num_attributes,\n                            const EXRAttribute *attributes, size_t num_channels,\n                            const EXRChannelInfo *channels,\n                            const std::vector<size_t> &channel_offset_list) {\n  if (compression_type == TINYEXR_COMPRESSIONTYPE_PIZ) {  // PIZ\n#if TINYEXR_USE_PIZ\n    if ((width == 0) || (num_lines == 0) || (pixel_data_size == 0)) {\n      // Invalid input #90\n      return false;\n    }\n\n    // Allocate original data size.\n    std::vector<unsigned char> outBuf(static_cast<size_t>(\n        static_cast<size_t>(width * num_lines) * pixel_data_size));\n    size_t tmpBufLen = outBuf.size();\n\n    bool ret = tinyexr::DecompressPiz(\n        reinterpret_cast<unsigned char *>(&outBuf.at(0)), data_ptr, tmpBufLen,\n        data_len, static_cast<int>(num_channels), channels, width, num_lines);\n\n    if (!ret) {\n      return false;\n    }\n\n    // For PIZ_COMPRESSION:\n    //   pixel sample data for channel 0 for scanline 0\n    //   pixel sample data for channel 1 for scanline 0\n    //   pixel sample data for channel ... for scanline 0\n    //   pixel sample data for channel n for scanline 0\n    //   pixel sample data for channel 0 for scanline 1\n    //   pixel sample data for channel 1 for scanline 1\n    //   pixel sample data for channel ... for scanline 1\n    //   pixel sample data for channel n for scanline 1\n    //   ...\n    for (size_t c = 0; c < static_cast<size_t>(num_channels); c++) {\n      if (channels[c].pixel_type == TINYEXR_PIXELTYPE_HALF) {\n        for (size_t v = 0; v < static_cast<size_t>(num_lines); v++) {\n          const unsigned short *line_ptr = reinterpret_cast<unsigned short *>(\n              &outBuf.at(v * pixel_data_size * static_cast<size_t>(width) +\n                         channel_offset_list[c] * static_cast<size_t>(width)));\n          for (size_t u = 0; u < static_cast<size_t>(width); u++) {\n            FP16 hf;\n\n            // hf.u = line_ptr[u];\n            // use `cpy` to avoid unaligned memory access when compiler's\n            // optimization is on.\n            tinyexr::cpy2(&(hf.u), line_ptr + u);\n\n            tinyexr::swap2(reinterpret_cast<unsigned short *>(&hf.u));\n\n            if (requested_pixel_types[c] == TINYEXR_PIXELTYPE_HALF) {\n              unsigned short *image =\n                  reinterpret_cast<unsigned short **>(out_images)[c];\n              if (line_order == 0) {\n                image += (static_cast<size_t>(line_no) + v) *\n                             static_cast<size_t>(x_stride) +\n                         u;\n              } else {\n                image += static_cast<size_t>(\n                             (height - 1 - (line_no + static_cast<int>(v)))) *\n                             static_cast<size_t>(x_stride) +\n                         u;\n              }\n              *image = hf.u;\n            } else {  // HALF -> FLOAT\n              FP32 f32 = half_to_float(hf);\n              float *image = reinterpret_cast<float **>(out_images)[c];\n              size_t offset = 0;\n              if (line_order == 0) {\n                offset = (static_cast<size_t>(line_no) + v) *\n                             static_cast<size_t>(x_stride) +\n                         u;\n              } else {\n                offset = static_cast<size_t>(\n                             (height - 1 - (line_no + static_cast<int>(v)))) *\n                             static_cast<size_t>(x_stride) +\n                         u;\n              }\n              image += offset;\n              *image = f32.f;\n            }\n          }\n        }\n      } else if (channels[c].pixel_type == TINYEXR_PIXELTYPE_UINT) {\n        assert(requested_pixel_types[c] == TINYEXR_PIXELTYPE_UINT);\n\n        for (size_t v = 0; v < static_cast<size_t>(num_lines); v++) {\n          const unsigned int *line_ptr = reinterpret_cast<unsigned int *>(\n              &outBuf.at(v * pixel_data_size * static_cast<size_t>(width) +\n                         channel_offset_list[c] * static_cast<size_t>(width)));\n          for (size_t u = 0; u < static_cast<size_t>(width); u++) {\n            unsigned int val;\n            // val = line_ptr[u];\n            tinyexr::cpy4(&val, line_ptr + u);\n\n            tinyexr::swap4(&val);\n\n            unsigned int *image =\n                reinterpret_cast<unsigned int **>(out_images)[c];\n            if (line_order == 0) {\n              image += (static_cast<size_t>(line_no) + v) *\n                           static_cast<size_t>(x_stride) +\n                       u;\n            } else {\n              image += static_cast<size_t>(\n                           (height - 1 - (line_no + static_cast<int>(v)))) *\n                           static_cast<size_t>(x_stride) +\n                       u;\n            }\n            *image = val;\n          }\n        }\n      } else if (channels[c].pixel_type == TINYEXR_PIXELTYPE_FLOAT) {\n        assert(requested_pixel_types[c] == TINYEXR_PIXELTYPE_FLOAT);\n        for (size_t v = 0; v < static_cast<size_t>(num_lines); v++) {\n          const float *line_ptr = reinterpret_cast<float *>(&outBuf.at(\n              v * pixel_data_size * static_cast<size_t>(width) +\n              channel_offset_list[c] * static_cast<size_t>(width)));\n          for (size_t u = 0; u < static_cast<size_t>(width); u++) {\n            float val;\n            // val = line_ptr[u];\n            tinyexr::cpy4(&val, line_ptr + u);\n\n            tinyexr::swap4(reinterpret_cast<unsigned int *>(&val));\n\n            float *image = reinterpret_cast<float **>(out_images)[c];\n            if (line_order == 0) {\n              image += (static_cast<size_t>(line_no) + v) *\n                           static_cast<size_t>(x_stride) +\n                       u;\n            } else {\n              image += static_cast<size_t>(\n                           (height - 1 - (line_no + static_cast<int>(v)))) *\n                           static_cast<size_t>(x_stride) +\n                       u;\n            }\n            *image = val;\n          }\n        }\n      } else {\n        assert(0);\n      }\n    }\n#else\n    assert(0 && \"PIZ is enabled in this build\");\n    return false;\n#endif\n\n  } else if (compression_type == TINYEXR_COMPRESSIONTYPE_ZIPS ||\n             compression_type == TINYEXR_COMPRESSIONTYPE_ZIP) {\n    // Allocate original data size.\n    std::vector<unsigned char> outBuf(static_cast<size_t>(width) *\n                                      static_cast<size_t>(num_lines) *\n                                      pixel_data_size);\n\n    unsigned long dstLen = static_cast<unsigned long>(outBuf.size());\n    assert(dstLen > 0);\n    if (!tinyexr::DecompressZip(\n            reinterpret_cast<unsigned char *>(&outBuf.at(0)), &dstLen, data_ptr,\n            static_cast<unsigned long>(data_len))) {\n      return false;\n    }\n\n    // For ZIP_COMPRESSION:\n    //   pixel sample data for channel 0 for scanline 0\n    //   pixel sample data for channel 1 for scanline 0\n    //   pixel sample data for channel ... for scanline 0\n    //   pixel sample data for channel n for scanline 0\n    //   pixel sample data for channel 0 for scanline 1\n    //   pixel sample data for channel 1 for scanline 1\n    //   pixel sample data for channel ... for scanline 1\n    //   pixel sample data for channel n for scanline 1\n    //   ...\n    for (size_t c = 0; c < static_cast<size_t>(num_channels); c++) {\n      if (channels[c].pixel_type == TINYEXR_PIXELTYPE_HALF) {\n        for (size_t v = 0; v < static_cast<size_t>(num_lines); v++) {\n          const unsigned short *line_ptr = reinterpret_cast<unsigned short *>(\n              &outBuf.at(v * static_cast<size_t>(pixel_data_size) *\n                             static_cast<size_t>(width) +\n                         channel_offset_list[c] * static_cast<size_t>(width)));\n          for (size_t u = 0; u < static_cast<size_t>(width); u++) {\n            tinyexr::FP16 hf;\n\n            // hf.u = line_ptr[u];\n            tinyexr::cpy2(&(hf.u), line_ptr + u);\n\n            tinyexr::swap2(reinterpret_cast<unsigned short *>(&hf.u));\n\n            if (requested_pixel_types[c] == TINYEXR_PIXELTYPE_HALF) {\n              unsigned short *image =\n                  reinterpret_cast<unsigned short **>(out_images)[c];\n              if (line_order == 0) {\n                image += (static_cast<size_t>(line_no) + v) *\n                             static_cast<size_t>(x_stride) +\n                         u;\n              } else {\n                image += (static_cast<size_t>(height) - 1U -\n                          (static_cast<size_t>(line_no) + v)) *\n                             static_cast<size_t>(x_stride) +\n                         u;\n              }\n              *image = hf.u;\n            } else {  // HALF -> FLOAT\n              tinyexr::FP32 f32 = half_to_float(hf);\n              float *image = reinterpret_cast<float **>(out_images)[c];\n              size_t offset = 0;\n              if (line_order == 0) {\n                offset = (static_cast<size_t>(line_no) + v) *\n                             static_cast<size_t>(x_stride) +\n                         u;\n              } else {\n                offset = (static_cast<size_t>(height) - 1U -\n                          (static_cast<size_t>(line_no) + v)) *\n                             static_cast<size_t>(x_stride) +\n                         u;\n              }\n              image += offset;\n\n              *image = f32.f;\n            }\n          }\n        }\n      } else if (channels[c].pixel_type == TINYEXR_PIXELTYPE_UINT) {\n        assert(requested_pixel_types[c] == TINYEXR_PIXELTYPE_UINT);\n\n        for (size_t v = 0; v < static_cast<size_t>(num_lines); v++) {\n          const unsigned int *line_ptr = reinterpret_cast<unsigned int *>(\n              &outBuf.at(v * pixel_data_size * static_cast<size_t>(width) +\n                         channel_offset_list[c] * static_cast<size_t>(width)));\n          for (size_t u = 0; u < static_cast<size_t>(width); u++) {\n            unsigned int val;\n            // val = line_ptr[u];\n            tinyexr::cpy4(&val, line_ptr + u);\n\n            tinyexr::swap4(&val);\n\n            unsigned int *image =\n                reinterpret_cast<unsigned int **>(out_images)[c];\n            if (line_order == 0) {\n              image += (static_cast<size_t>(line_no) + v) *\n                           static_cast<size_t>(x_stride) +\n                       u;\n            } else {\n              image += (static_cast<size_t>(height) - 1U -\n                        (static_cast<size_t>(line_no) + v)) *\n                           static_cast<size_t>(x_stride) +\n                       u;\n            }\n            *image = val;\n          }\n        }\n      } else if (channels[c].pixel_type == TINYEXR_PIXELTYPE_FLOAT) {\n        assert(requested_pixel_types[c] == TINYEXR_PIXELTYPE_FLOAT);\n        for (size_t v = 0; v < static_cast<size_t>(num_lines); v++) {\n          const float *line_ptr = reinterpret_cast<float *>(\n              &outBuf.at(v * pixel_data_size * static_cast<size_t>(width) +\n                         channel_offset_list[c] * static_cast<size_t>(width)));\n          for (size_t u = 0; u < static_cast<size_t>(width); u++) {\n            float val;\n            // val = line_ptr[u];\n            tinyexr::cpy4(&val, line_ptr + u);\n\n            tinyexr::swap4(reinterpret_cast<unsigned int *>(&val));\n\n            float *image = reinterpret_cast<float **>(out_images)[c];\n            if (line_order == 0) {\n              image += (static_cast<size_t>(line_no) + v) *\n                           static_cast<size_t>(x_stride) +\n                       u;\n            } else {\n              image += (static_cast<size_t>(height) - 1U -\n                        (static_cast<size_t>(line_no) + v)) *\n                           static_cast<size_t>(x_stride) +\n                       u;\n            }\n            *image = val;\n          }\n        }\n      } else {\n        assert(0);\n        return false;\n      }\n    }\n  } else if (compression_type == TINYEXR_COMPRESSIONTYPE_RLE) {\n    // Allocate original data size.\n    std::vector<unsigned char> outBuf(static_cast<size_t>(width) *\n                                      static_cast<size_t>(num_lines) *\n                                      pixel_data_size);\n\n    unsigned long dstLen = static_cast<unsigned long>(outBuf.size());\n    if (dstLen == 0) {\n      return false;\n    }\n\n    if (!tinyexr::DecompressRle(\n            reinterpret_cast<unsigned char *>(&outBuf.at(0)), dstLen, data_ptr,\n            static_cast<unsigned long>(data_len))) {\n      return false;\n    }\n\n    // For RLE_COMPRESSION:\n    //   pixel sample data for channel 0 for scanline 0\n    //   pixel sample data for channel 1 for scanline 0\n    //   pixel sample data for channel ... for scanline 0\n    //   pixel sample data for channel n for scanline 0\n    //   pixel sample data for channel 0 for scanline 1\n    //   pixel sample data for channel 1 for scanline 1\n    //   pixel sample data for channel ... for scanline 1\n    //   pixel sample data for channel n for scanline 1\n    //   ...\n    for (size_t c = 0; c < static_cast<size_t>(num_channels); c++) {\n      if (channels[c].pixel_type == TINYEXR_PIXELTYPE_HALF) {\n        for (size_t v = 0; v < static_cast<size_t>(num_lines); v++) {\n          const unsigned short *line_ptr = reinterpret_cast<unsigned short *>(\n              &outBuf.at(v * static_cast<size_t>(pixel_data_size) *\n                             static_cast<size_t>(width) +\n                         channel_offset_list[c] * static_cast<size_t>(width)));\n          for (size_t u = 0; u < static_cast<size_t>(width); u++) {\n            tinyexr::FP16 hf;\n\n            // hf.u = line_ptr[u];\n            tinyexr::cpy2(&(hf.u), line_ptr + u);\n\n            tinyexr::swap2(reinterpret_cast<unsigned short *>(&hf.u));\n\n            if (requested_pixel_types[c] == TINYEXR_PIXELTYPE_HALF) {\n              unsigned short *image =\n                  reinterpret_cast<unsigned short **>(out_images)[c];\n              if (line_order == 0) {\n                image += (static_cast<size_t>(line_no) + v) *\n                             static_cast<size_t>(x_stride) +\n                         u;\n              } else {\n                image += (static_cast<size_t>(height) - 1U -\n                          (static_cast<size_t>(line_no) + v)) *\n                             static_cast<size_t>(x_stride) +\n                         u;\n              }\n              *image = hf.u;\n            } else {  // HALF -> FLOAT\n              tinyexr::FP32 f32 = half_to_float(hf);\n              float *image = reinterpret_cast<float **>(out_images)[c];\n              if (line_order == 0) {\n                image += (static_cast<size_t>(line_no) + v) *\n                             static_cast<size_t>(x_stride) +\n                         u;\n              } else {\n                image += (static_cast<size_t>(height) - 1U -\n                          (static_cast<size_t>(line_no) + v)) *\n                             static_cast<size_t>(x_stride) +\n                         u;\n              }\n              *image = f32.f;\n            }\n          }\n        }\n      } else if (channels[c].pixel_type == TINYEXR_PIXELTYPE_UINT) {\n        assert(requested_pixel_types[c] == TINYEXR_PIXELTYPE_UINT);\n\n        for (size_t v = 0; v < static_cast<size_t>(num_lines); v++) {\n          const unsigned int *line_ptr = reinterpret_cast<unsigned int *>(\n              &outBuf.at(v * pixel_data_size * static_cast<size_t>(width) +\n                         channel_offset_list[c] * static_cast<size_t>(width)));\n          for (size_t u = 0; u < static_cast<size_t>(width); u++) {\n            unsigned int val;\n            // val = line_ptr[u];\n            tinyexr::cpy4(&val, line_ptr + u);\n\n            tinyexr::swap4(&val);\n\n            unsigned int *image =\n                reinterpret_cast<unsigned int **>(out_images)[c];\n            if (line_order == 0) {\n              image += (static_cast<size_t>(line_no) + v) *\n                           static_cast<size_t>(x_stride) +\n                       u;\n            } else {\n              image += (static_cast<size_t>(height) - 1U -\n                        (static_cast<size_t>(line_no) + v)) *\n                           static_cast<size_t>(x_stride) +\n                       u;\n            }\n            *image = val;\n          }\n        }\n      } else if (channels[c].pixel_type == TINYEXR_PIXELTYPE_FLOAT) {\n        assert(requested_pixel_types[c] == TINYEXR_PIXELTYPE_FLOAT);\n        for (size_t v = 0; v < static_cast<size_t>(num_lines); v++) {\n          const float *line_ptr = reinterpret_cast<float *>(\n              &outBuf.at(v * pixel_data_size * static_cast<size_t>(width) +\n                         channel_offset_list[c] * static_cast<size_t>(width)));\n          for (size_t u = 0; u < static_cast<size_t>(width); u++) {\n            float val;\n            // val = line_ptr[u];\n            tinyexr::cpy4(&val, line_ptr + u);\n\n            tinyexr::swap4(reinterpret_cast<unsigned int *>(&val));\n\n            float *image = reinterpret_cast<float **>(out_images)[c];\n            if (line_order == 0) {\n              image += (static_cast<size_t>(line_no) + v) *\n                           static_cast<size_t>(x_stride) +\n                       u;\n            } else {\n              image += (static_cast<size_t>(height) - 1U -\n                        (static_cast<size_t>(line_no) + v)) *\n                           static_cast<size_t>(x_stride) +\n                       u;\n            }\n            *image = val;\n          }\n        }\n      } else {\n        assert(0);\n        return false;\n      }\n    }\n  } else if (compression_type == TINYEXR_COMPRESSIONTYPE_ZFP) {\n#if TINYEXR_USE_ZFP\n    tinyexr::ZFPCompressionParam zfp_compression_param;\n    std::string e;\n    if (!tinyexr::FindZFPCompressionParam(&zfp_compression_param, attributes,\n                                          int(num_attributes), &e)) {\n      // This code path should not be reachable.\n      assert(0);\n      return false;\n    }\n\n    // Allocate original data size.\n    std::vector<unsigned char> outBuf(static_cast<size_t>(width) *\n                                      static_cast<size_t>(num_lines) *\n                                      pixel_data_size);\n\n    unsigned long dstLen = outBuf.size();\n    assert(dstLen > 0);\n    tinyexr::DecompressZfp(reinterpret_cast<float *>(&outBuf.at(0)), width,\n                           num_lines, num_channels, data_ptr,\n                           static_cast<unsigned long>(data_len),\n                           zfp_compression_param);\n\n    // For ZFP_COMPRESSION:\n    //   pixel sample data for channel 0 for scanline 0\n    //   pixel sample data for channel 1 for scanline 0\n    //   pixel sample data for channel ... for scanline 0\n    //   pixel sample data for channel n for scanline 0\n    //   pixel sample data for channel 0 for scanline 1\n    //   pixel sample data for channel 1 for scanline 1\n    //   pixel sample data for channel ... for scanline 1\n    //   pixel sample data for channel n for scanline 1\n    //   ...\n    for (size_t c = 0; c < static_cast<size_t>(num_channels); c++) {\n      assert(channels[c].pixel_type == TINYEXR_PIXELTYPE_FLOAT);\n      if (channels[c].pixel_type == TINYEXR_PIXELTYPE_FLOAT) {\n        assert(requested_pixel_types[c] == TINYEXR_PIXELTYPE_FLOAT);\n        for (size_t v = 0; v < static_cast<size_t>(num_lines); v++) {\n          const float *line_ptr = reinterpret_cast<float *>(\n              &outBuf.at(v * pixel_data_size * static_cast<size_t>(width) +\n                         channel_offset_list[c] * static_cast<size_t>(width)));\n          for (size_t u = 0; u < static_cast<size_t>(width); u++) {\n            float val;\n            tinyexr::cpy4(&val, line_ptr + u);\n\n            tinyexr::swap4(reinterpret_cast<unsigned int *>(&val));\n\n            float *image = reinterpret_cast<float **>(out_images)[c];\n            if (line_order == 0) {\n              image += (static_cast<size_t>(line_no) + v) *\n                           static_cast<size_t>(x_stride) +\n                       u;\n            } else {\n              image += (static_cast<size_t>(height) - 1U -\n                        (static_cast<size_t>(line_no) + v)) *\n                           static_cast<size_t>(x_stride) +\n                       u;\n            }\n            *image = val;\n          }\n        }\n      } else {\n        assert(0);\n        return false;\n      }\n    }\n#else\n    (void)attributes;\n    (void)num_attributes;\n    (void)num_channels;\n    assert(0);\n    return false;\n#endif\n  } else if (compression_type == TINYEXR_COMPRESSIONTYPE_NONE) {\n    for (size_t c = 0; c < num_channels; c++) {\n      for (size_t v = 0; v < static_cast<size_t>(num_lines); v++) {\n        if (channels[c].pixel_type == TINYEXR_PIXELTYPE_HALF) {\n          const unsigned short *line_ptr =\n              reinterpret_cast<const unsigned short *>(\n                  data_ptr + v * pixel_data_size * size_t(width) +\n                  channel_offset_list[c] * static_cast<size_t>(width));\n\n          if (requested_pixel_types[c] == TINYEXR_PIXELTYPE_HALF) {\n            unsigned short *outLine =\n                reinterpret_cast<unsigned short *>(out_images[c]);\n            if (line_order == 0) {\n              outLine += (size_t(y) + v) * size_t(x_stride);\n            } else {\n              outLine +=\n                  (size_t(height) - 1 - (size_t(y) + v)) * size_t(x_stride);\n            }\n\n            for (int u = 0; u < width; u++) {\n              tinyexr::FP16 hf;\n\n              // hf.u = line_ptr[u];\n              tinyexr::cpy2(&(hf.u), line_ptr + u);\n\n              tinyexr::swap2(reinterpret_cast<unsigned short *>(&hf.u));\n\n              outLine[u] = hf.u;\n            }\n          } else if (requested_pixel_types[c] == TINYEXR_PIXELTYPE_FLOAT) {\n            float *outLine = reinterpret_cast<float *>(out_images[c]);\n            if (line_order == 0) {\n              outLine += (size_t(y) + v) * size_t(x_stride);\n            } else {\n              outLine +=\n                  (size_t(height) - 1 - (size_t(y) + v)) * size_t(x_stride);\n            }\n\n            if (reinterpret_cast<const unsigned char *>(line_ptr + width) >\n                (data_ptr + data_len)) {\n              // Insufficient data size\n              return false;\n            }\n\n            for (int u = 0; u < width; u++) {\n              tinyexr::FP16 hf;\n\n              // address may not be aliged. use byte-wise copy for safety.#76\n              // hf.u = line_ptr[u];\n              tinyexr::cpy2(&(hf.u), line_ptr + u);\n\n              tinyexr::swap2(reinterpret_cast<unsigned short *>(&hf.u));\n\n              tinyexr::FP32 f32 = half_to_float(hf);\n\n              outLine[u] = f32.f;\n            }\n          } else {\n            assert(0);\n            return false;\n          }\n        } else if (channels[c].pixel_type == TINYEXR_PIXELTYPE_FLOAT) {\n          const float *line_ptr = reinterpret_cast<const float *>(\n              data_ptr + v * pixel_data_size * size_t(width) +\n              channel_offset_list[c] * static_cast<size_t>(width));\n\n          float *outLine = reinterpret_cast<float *>(out_images[c]);\n          if (line_order == 0) {\n            outLine += (size_t(y) + v) * size_t(x_stride);\n          } else {\n            outLine +=\n                (size_t(height) - 1 - (size_t(y) + v)) * size_t(x_stride);\n          }\n\n          if (reinterpret_cast<const unsigned char *>(line_ptr + width) >\n              (data_ptr + data_len)) {\n            // Insufficient data size\n            return false;\n          }\n\n          for (int u = 0; u < width; u++) {\n            float val;\n            tinyexr::cpy4(&val, line_ptr + u);\n\n            tinyexr::swap4(reinterpret_cast<unsigned int *>(&val));\n\n            outLine[u] = val;\n          }\n        } else if (channels[c].pixel_type == TINYEXR_PIXELTYPE_UINT) {\n          const unsigned int *line_ptr = reinterpret_cast<const unsigned int *>(\n              data_ptr + v * pixel_data_size * size_t(width) +\n              channel_offset_list[c] * static_cast<size_t>(width));\n\n          unsigned int *outLine =\n              reinterpret_cast<unsigned int *>(out_images[c]);\n          if (line_order == 0) {\n            outLine += (size_t(y) + v) * size_t(x_stride);\n          } else {\n            outLine +=\n                (size_t(height) - 1 - (size_t(y) + v)) * size_t(x_stride);\n          }\n\n          for (int u = 0; u < width; u++) {\n            if (reinterpret_cast<const unsigned char *>(line_ptr + u) >=\n                (data_ptr + data_len)) {\n              // Corrupsed data?\n              return false;\n            }\n\n            unsigned int val;\n            tinyexr::cpy4(&val, line_ptr + u);\n\n            tinyexr::swap4(reinterpret_cast<unsigned int *>(&val));\n\n            outLine[u] = val;\n          }\n        }\n      }\n    }\n  }\n\n  return true;\n}",
  "abstract_func": "static bool DecodePixelData(/* COMMENT_0 */ unsigned char **VAR_0,\n                            const int *VAR_1,\n                            const unsigned char *VAR_2, size_t VAR_3,\n                            int VAR_4, int VAR_5, int VAR_6,\n                            int VAR_7, int VAR_8, int VAR_9, int VAR_10,\n                            int VAR_11, size_t VAR_12,\n                            size_t VAR_13,\n                            const EXRAttribute *VAR_14, size_t VAR_15,\n                            const EXRChannelInfo *VAR_16,\n                            const std::vector<size_t> &VAR_17) {\n  if (VAR_4 == VAR_18) {  /* COMMENT_1 */\n#if VAR_19\n    if ((VAR_6 == 0) || (VAR_11 == 0) || (VAR_12 == 0)) {\n      /* COMMENT_2 */\n      return false;\n    }\n\n    /* COMMENT_3 */\n    std::vector<unsigned char> VAR_20(VAR_21<size_t>(\n        VAR_21<size_t>(VAR_6 * VAR_11) * VAR_12));\n    size_t VAR_22 = VAR_20.size();\n\n    bool VAR_23 = tinyexr::DecompressPiz(\n        VAR_24<unsigned char *>(&VAR_20.at(0)), VAR_2, VAR_22,\n        VAR_3, VAR_21<int>(VAR_15), VAR_16, VAR_6, VAR_11);\n\n    if (!VAR_23) {\n      return false;\n    }\n\n    /* COMMENT_4 */\n    /* COMMENT_5 */\n    /* COMMENT_6 */\n    /* COMMENT_7 */\n    /* COMMENT_8 */\n    /* COMMENT_9 */\n    /* COMMENT_10 */\n    /* COMMENT_11 */\n    /* COMMENT_12 */\n    /* COMMENT_13 */\n    for (size_t VAR_25 = 0; VAR_25 < VAR_21<size_t>(VAR_15); VAR_25++) {\n      if (VAR_16[VAR_25].pixel_type == VAR_26) {\n        for (size_t VAR_27 = 0; VAR_27 < VAR_21<size_t>(VAR_11); VAR_27++) {\n          const unsigned short *VAR_28 = VAR_24<unsigned short *>(\n              &VAR_20.at(VAR_27 * VAR_12 * VAR_21<size_t>(VAR_6) +\n                         VAR_17[VAR_25] * VAR_21<size_t>(VAR_6)));\n          for (size_t VAR_29 = 0; VAR_29 < VAR_21<size_t>(VAR_6); VAR_29++) {\n            FP16 VAR_30;\n\n            /* COMMENT_14 */\n            /* COMMENT_15 */\n            /* COMMENT_16 */\n            tinyexr::cpy2(&(VAR_30.u), VAR_28 + VAR_29);\n\n            tinyexr::swap2(VAR_24<unsigned short *>(&VAR_30.u));\n\n            if (VAR_1[VAR_25] == VAR_26) {\n              unsigned short *VAR_31 =\n                  VAR_24<unsigned short **>(VAR_0)[VAR_25];\n              if (VAR_5 == 0) {\n                VAR_31 += (VAR_21<size_t>(VAR_10) + VAR_27) *\n                             VAR_21<size_t>(VAR_8) +\n                         VAR_29;\n              } else {\n                VAR_31 += VAR_21<size_t>(\n                             (VAR_7 - 1 - (VAR_10 + VAR_21<int>(VAR_27)))) *\n                             VAR_21<size_t>(VAR_8) +\n                         VAR_29;\n              }\n              *VAR_31 = VAR_30.u;\n            } else {  /* COMMENT_17 */\n              FP32 VAR_32 = half_to_float(VAR_30);\n              float *VAR_31 = VAR_24<float **>(VAR_0)[VAR_25];\n              size_t VAR_33 = 0;\n              if (VAR_5 == 0) {\n                VAR_33 = (VAR_21<size_t>(VAR_10) + VAR_27) *\n                             VAR_21<size_t>(VAR_8) +\n                         VAR_29;\n              } else {\n                VAR_33 = VAR_21<size_t>(\n                             (VAR_7 - 1 - (VAR_10 + VAR_21<int>(VAR_27)))) *\n                             VAR_21<size_t>(VAR_8) +\n                         VAR_29;\n              }\n              VAR_31 += VAR_33;\n              *VAR_31 = VAR_32.f;\n            }\n          }\n        }\n      } else if (VAR_16[VAR_25].pixel_type == VAR_34) {\n        assert(VAR_1[VAR_25] == VAR_34);\n\n        for (size_t VAR_27 = 0; VAR_27 < VAR_21<size_t>(VAR_11); VAR_27++) {\n          const unsigned int *VAR_28 = VAR_24<unsigned int *>(\n              &VAR_20.at(VAR_27 * VAR_12 * VAR_21<size_t>(VAR_6) +\n                         VAR_17[VAR_25] * VAR_21<size_t>(VAR_6)));\n          for (size_t VAR_29 = 0; VAR_29 < VAR_21<size_t>(VAR_6); VAR_29++) {\n            unsigned int VAR_35;\n            /* COMMENT_18 */\n            tinyexr::cpy4(&VAR_35, VAR_28 + VAR_29);\n\n            tinyexr::swap4(&VAR_35);\n\n            unsigned int *VAR_31 =\n                VAR_24<unsigned int **>(VAR_0)[VAR_25];\n            if (VAR_5 == 0) {\n              VAR_31 += (VAR_21<size_t>(VAR_10) + VAR_27) *\n                           VAR_21<size_t>(VAR_8) +\n                       VAR_29;\n            } else {\n              VAR_31 += VAR_21<size_t>(\n                           (VAR_7 - 1 - (VAR_10 + VAR_21<int>(VAR_27)))) *\n                           VAR_21<size_t>(VAR_8) +\n                       VAR_29;\n            }\n            *VAR_31 = VAR_35;\n          }\n        }\n      } else if (VAR_16[VAR_25].pixel_type == VAR_36) {\n        assert(VAR_1[VAR_25] == VAR_36);\n        for (size_t VAR_27 = 0; VAR_27 < VAR_21<size_t>(VAR_11); VAR_27++) {\n          const float *VAR_28 = VAR_24<float *>(&VAR_20.at(\n              VAR_27 * VAR_12 * VAR_21<size_t>(VAR_6) +\n              VAR_17[VAR_25] * VAR_21<size_t>(VAR_6)));\n          for (size_t VAR_29 = 0; VAR_29 < VAR_21<size_t>(VAR_6); VAR_29++) {\n            float VAR_35;\n            /* COMMENT_18 */\n            tinyexr::cpy4(&VAR_35, VAR_28 + VAR_29);\n\n            tinyexr::swap4(VAR_24<unsigned int *>(&VAR_35));\n\n            float *VAR_31 = VAR_24<float **>(VAR_0)[VAR_25];\n            if (VAR_5 == 0) {\n              VAR_31 += (VAR_21<size_t>(VAR_10) + VAR_27) *\n                           VAR_21<size_t>(VAR_8) +\n                       VAR_29;\n            } else {\n              VAR_31 += VAR_21<size_t>(\n                           (VAR_7 - 1 - (VAR_10 + VAR_21<int>(VAR_27)))) *\n                           VAR_21<size_t>(VAR_8) +\n                       VAR_29;\n            }\n            *VAR_31 = VAR_35;\n          }\n        }\n      } else {\n        assert(0);\n      }\n    }\n#else\n    assert(0 && \"PIZ is enabled in this build\");\n    return false;\n#endif\n\n  } else if (VAR_4 == VAR_37 ||\n             VAR_4 == VAR_38) {\n    /* COMMENT_3 */\n    std::vector<unsigned char> VAR_20(VAR_21<size_t>(VAR_6) *\n                                      VAR_21<size_t>(VAR_11) *\n                                      VAR_12);\n\n    unsigned long VAR_39 = VAR_21<unsigned long>(VAR_20.size());\n    assert(VAR_39 > 0);\n    if (!tinyexr::DecompressZip(\n            VAR_24<unsigned char *>(&VAR_20.at(0)), &VAR_39, VAR_2,\n            VAR_21<unsigned long>(VAR_3))) {\n      return false;\n    }\n\n    /* COMMENT_19 */\n    /* COMMENT_5 */\n    /* COMMENT_6 */\n    /* COMMENT_7 */\n    /* COMMENT_8 */\n    /* COMMENT_9 */\n    /* COMMENT_10 */\n    /* COMMENT_11 */\n    /* COMMENT_12 */\n    /* COMMENT_13 */\n    for (size_t VAR_25 = 0; VAR_25 < VAR_21<size_t>(VAR_15); VAR_25++) {\n      if (VAR_16[VAR_25].pixel_type == VAR_26) {\n        for (size_t VAR_27 = 0; VAR_27 < VAR_21<size_t>(VAR_11); VAR_27++) {\n          const unsigned short *VAR_28 = VAR_24<unsigned short *>(\n              &VAR_20.at(VAR_27 * VAR_21<size_t>(VAR_12) *\n                             VAR_21<size_t>(VAR_6) +\n                         VAR_17[VAR_25] * VAR_21<size_t>(VAR_6)));\n          for (size_t VAR_29 = 0; VAR_29 < VAR_21<size_t>(VAR_6); VAR_29++) {\n            tinyexr::FP16 VAR_30;\n\n            /* COMMENT_14 */\n            tinyexr::cpy2(&(VAR_30.u), VAR_28 + VAR_29);\n\n            tinyexr::swap2(VAR_24<unsigned short *>(&VAR_30.u));\n\n            if (VAR_1[VAR_25] == VAR_26) {\n              unsigned short *VAR_31 =\n                  VAR_24<unsigned short **>(VAR_0)[VAR_25];\n              if (VAR_5 == 0) {\n                VAR_31 += (VAR_21<size_t>(VAR_10) + VAR_27) *\n                             VAR_21<size_t>(VAR_8) +\n                         VAR_29;\n              } else {\n                VAR_31 += (VAR_21<size_t>(VAR_7) - 1U -\n                          (VAR_21<size_t>(VAR_10) + VAR_27)) *\n                             VAR_21<size_t>(VAR_8) +\n                         VAR_29;\n              }\n              *VAR_31 = VAR_30.u;\n            } else {  /* COMMENT_17 */\n              tinyexr::FP32 VAR_32 = half_to_float(VAR_30);\n              float *VAR_31 = VAR_24<float **>(VAR_0)[VAR_25];\n              size_t VAR_33 = 0;\n              if (VAR_5 == 0) {\n                VAR_33 = (VAR_21<size_t>(VAR_10) + VAR_27) *\n                             VAR_21<size_t>(VAR_8) +\n                         VAR_29;\n              } else {\n                VAR_33 = (VAR_21<size_t>(VAR_7) - 1U -\n                          (VAR_21<size_t>(VAR_10) + VAR_27)) *\n                             VAR_21<size_t>(VAR_8) +\n                         VAR_29;\n              }\n              VAR_31 += VAR_33;\n\n              *VAR_31 = VAR_32.f;\n            }\n          }\n        }\n      } else if (VAR_16[VAR_25].pixel_type == VAR_34) {\n        assert(VAR_1[VAR_25] == VAR_34);\n\n        for (size_t VAR_27 = 0; VAR_27 < VAR_21<size_t>(VAR_11); VAR_27++) {\n          const unsigned int *VAR_28 = VAR_24<unsigned int *>(\n              &VAR_20.at(VAR_27 * VAR_12 * VAR_21<size_t>(VAR_6) +\n                         VAR_17[VAR_25] * VAR_21<size_t>(VAR_6)));\n          for (size_t VAR_29 = 0; VAR_29 < VAR_21<size_t>(VAR_6); VAR_29++) {\n            unsigned int VAR_35;\n            /* COMMENT_18 */\n            tinyexr::cpy4(&VAR_35, VAR_28 + VAR_29);\n\n            tinyexr::swap4(&VAR_35);\n\n            unsigned int *VAR_31 =\n                VAR_24<unsigned int **>(VAR_0)[VAR_25];\n            if (VAR_5 == 0) {\n              VAR_31 += (VAR_21<size_t>(VAR_10) + VAR_27) *\n                           VAR_21<size_t>(VAR_8) +\n                       VAR_29;\n            } else {\n              VAR_31 += (VAR_21<size_t>(VAR_7) - 1U -\n                        (VAR_21<size_t>(VAR_10) + VAR_27)) *\n                           VAR_21<size_t>(VAR_8) +\n                       VAR_29;\n            }\n            *VAR_31 = VAR_35;\n          }\n        }\n      } else if (VAR_16[VAR_25].pixel_type == VAR_36) {\n        assert(VAR_1[VAR_25] == VAR_36);\n        for (size_t VAR_27 = 0; VAR_27 < VAR_21<size_t>(VAR_11); VAR_27++) {\n          const float *VAR_28 = VAR_24<float *>(\n              &VAR_20.at(VAR_27 * VAR_12 * VAR_21<size_t>(VAR_6) +\n                         VAR_17[VAR_25] * VAR_21<size_t>(VAR_6)));\n          for (size_t VAR_29 = 0; VAR_29 < VAR_21<size_t>(VAR_6); VAR_29++) {\n            float VAR_35;\n            /* COMMENT_18 */\n            tinyexr::cpy4(&VAR_35, VAR_28 + VAR_29);\n\n            tinyexr::swap4(VAR_24<unsigned int *>(&VAR_35));\n\n            float *VAR_31 = VAR_24<float **>(VAR_0)[VAR_25];\n            if (VAR_5 == 0) {\n              VAR_31 += (VAR_21<size_t>(VAR_10) + VAR_27) *\n                           VAR_21<size_t>(VAR_8) +\n                       VAR_29;\n            } else {\n              VAR_31 += (VAR_21<size_t>(VAR_7) - 1U -\n                        (VAR_21<size_t>(VAR_10) + VAR_27)) *\n                           VAR_21<size_t>(VAR_8) +\n                       VAR_29;\n            }\n            *VAR_31 = VAR_35;\n          }\n        }\n      } else {\n        assert(0);\n        return false;\n      }\n    }\n  } else if (VAR_4 == VAR_40) {\n    /* COMMENT_3 */\n    std::vector<unsigned char> VAR_20(VAR_21<size_t>(VAR_6) *\n                                      VAR_21<size_t>(VAR_11) *\n                                      VAR_12);\n\n    unsigned long VAR_39 = VAR_21<unsigned long>(VAR_20.size());\n    if (VAR_39 == 0) {\n      return false;\n    }\n\n    if (!tinyexr::DecompressRle(\n            VAR_24<unsigned char *>(&VAR_20.at(0)), VAR_39, VAR_2,\n            VAR_21<unsigned long>(VAR_3))) {\n      return false;\n    }\n\n    /* COMMENT_20 */\n    /* COMMENT_5 */\n    /* COMMENT_6 */\n    /* COMMENT_7 */\n    /* COMMENT_8 */\n    /* COMMENT_9 */\n    /* COMMENT_10 */\n    /* COMMENT_11 */\n    /* COMMENT_12 */\n    /* COMMENT_13 */\n    for (size_t VAR_25 = 0; VAR_25 < VAR_21<size_t>(VAR_15); VAR_25++) {\n      if (VAR_16[VAR_25].pixel_type == VAR_26) {\n        for (size_t VAR_27 = 0; VAR_27 < VAR_21<size_t>(VAR_11); VAR_27++) {\n          const unsigned short *VAR_28 = VAR_24<unsigned short *>(\n              &VAR_20.at(VAR_27 * VAR_21<size_t>(VAR_12) *\n                             VAR_21<size_t>(VAR_6) +\n                         VAR_17[VAR_25] * VAR_21<size_t>(VAR_6)));\n          for (size_t VAR_29 = 0; VAR_29 < VAR_21<size_t>(VAR_6); VAR_29++) {\n            tinyexr::FP16 VAR_30;\n\n            /* COMMENT_14 */\n            tinyexr::cpy2(&(VAR_30.u), VAR_28 + VAR_29);\n\n            tinyexr::swap2(VAR_24<unsigned short *>(&VAR_30.u));\n\n            if (VAR_1[VAR_25] == VAR_26) {\n              unsigned short *VAR_31 =\n                  VAR_24<unsigned short **>(VAR_0)[VAR_25];\n              if (VAR_5 == 0) {\n                VAR_31 += (VAR_21<size_t>(VAR_10) + VAR_27) *\n                             VAR_21<size_t>(VAR_8) +\n                         VAR_29;\n              } else {\n                VAR_31 += (VAR_21<size_t>(VAR_7) - 1U -\n                          (VAR_21<size_t>(VAR_10) + VAR_27)) *\n                             VAR_21<size_t>(VAR_8) +\n                         VAR_29;\n              }\n              *VAR_31 = VAR_30.u;\n            } else {  /* COMMENT_17 */\n              tinyexr::FP32 VAR_32 = half_to_float(VAR_30);\n              float *VAR_31 = VAR_24<float **>(VAR_0)[VAR_25];\n              if (VAR_5 == 0) {\n                VAR_31 += (VAR_21<size_t>(VAR_10) + VAR_27) *\n                             VAR_21<size_t>(VAR_8) +\n                         VAR_29;\n              } else {\n                VAR_31 += (VAR_21<size_t>(VAR_7) - 1U -\n                          (VAR_21<size_t>(VAR_10) + VAR_27)) *\n                             VAR_21<size_t>(VAR_8) +\n                         VAR_29;\n              }\n              *VAR_31 = VAR_32.f;\n            }\n          }\n        }\n      } else if (VAR_16[VAR_25].pixel_type == VAR_34) {\n        assert(VAR_1[VAR_25] == VAR_34);\n\n        for (size_t VAR_27 = 0; VAR_27 < VAR_21<size_t>(VAR_11); VAR_27++) {\n          const unsigned int *VAR_28 = VAR_24<unsigned int *>(\n              &VAR_20.at(VAR_27 * VAR_12 * VAR_21<size_t>(VAR_6) +\n                         VAR_17[VAR_25] * VAR_21<size_t>(VAR_6)));\n          for (size_t VAR_29 = 0; VAR_29 < VAR_21<size_t>(VAR_6); VAR_29++) {\n            unsigned int VAR_35;\n            /* COMMENT_18 */\n            tinyexr::cpy4(&VAR_35, VAR_28 + VAR_29);\n\n            tinyexr::swap4(&VAR_35);\n\n            unsigned int *VAR_31 =\n                VAR_24<unsigned int **>(VAR_0)[VAR_25];\n            if (VAR_5 == 0) {\n              VAR_31 += (VAR_21<size_t>(VAR_10) + VAR_27) *\n                           VAR_21<size_t>(VAR_8) +\n                       VAR_29;\n            } else {\n              VAR_31 += (VAR_21<size_t>(VAR_7) - 1U -\n                        (VAR_21<size_t>(VAR_10) + VAR_27)) *\n                           VAR_21<size_t>(VAR_8) +\n                       VAR_29;\n            }\n            *VAR_31 = VAR_35;\n          }\n        }\n      } else if (VAR_16[VAR_25].pixel_type == VAR_36) {\n        assert(VAR_1[VAR_25] == VAR_36);\n        for (size_t VAR_27 = 0; VAR_27 < VAR_21<size_t>(VAR_11); VAR_27++) {\n          const float *VAR_28 = VAR_24<float *>(\n              &VAR_20.at(VAR_27 * VAR_12 * VAR_21<size_t>(VAR_6) +\n                         VAR_17[VAR_25] * VAR_21<size_t>(VAR_6)));\n          for (size_t VAR_29 = 0; VAR_29 < VAR_21<size_t>(VAR_6); VAR_29++) {\n            float VAR_35;\n            /* COMMENT_18 */\n            tinyexr::cpy4(&VAR_35, VAR_28 + VAR_29);\n\n            tinyexr::swap4(VAR_24<unsigned int *>(&VAR_35));\n\n            float *VAR_31 = VAR_24<float **>(VAR_0)[VAR_25];\n            if (VAR_5 == 0) {\n              VAR_31 += (VAR_21<size_t>(VAR_10) + VAR_27) *\n                           VAR_21<size_t>(VAR_8) +\n                       VAR_29;\n            } else {\n              VAR_31 += (VAR_21<size_t>(VAR_7) - 1U -\n                        (VAR_21<size_t>(VAR_10) + VAR_27)) *\n                           VAR_21<size_t>(VAR_8) +\n                       VAR_29;\n            }\n            *VAR_31 = VAR_35;\n          }\n        }\n      } else {\n        assert(0);\n        return false;\n      }\n    }\n  } else if (VAR_4 == VAR_41) {\n#if VAR_42\n    tinyexr::ZFPCompressionParam VAR_43;\n    std::string VAR_44;\n    if (!tinyexr::FindZFPCompressionParam(&VAR_43, VAR_14,\n                                          int(VAR_13), &VAR_44)) {\n      /* COMMENT_21 */\n      assert(0);\n      return false;\n    }\n\n    /* COMMENT_3 */\n    std::vector<unsigned char> VAR_20(VAR_21<size_t>(VAR_6) *\n                                      VAR_21<size_t>(VAR_11) *\n                                      VAR_12);\n\n    unsigned long VAR_39 = VAR_20.size();\n    assert(VAR_39 > 0);\n    tinyexr::DecompressZfp(VAR_24<float *>(&VAR_20.at(0)), VAR_6,\n                           VAR_11, VAR_15, VAR_2,\n                           VAR_21<unsigned long>(VAR_3),\n                           VAR_43);\n\n    /* COMMENT_22 */\n    /* COMMENT_5 */\n    /* COMMENT_6 */\n    /* COMMENT_7 */\n    /* COMMENT_8 */\n    /* COMMENT_9 */\n    /* COMMENT_10 */\n    /* COMMENT_11 */\n    /* COMMENT_12 */\n    /* COMMENT_13 */\n    for (size_t VAR_25 = 0; VAR_25 < VAR_21<size_t>(VAR_15); VAR_25++) {\n      assert(VAR_16[VAR_25].pixel_type == VAR_36);\n      if (VAR_16[VAR_25].pixel_type == VAR_36) {\n        assert(VAR_1[VAR_25] == VAR_36);\n        for (size_t VAR_27 = 0; VAR_27 < VAR_21<size_t>(VAR_11); VAR_27++) {\n          const float *VAR_28 = VAR_24<float *>(\n              &VAR_20.at(VAR_27 * VAR_12 * VAR_21<size_t>(VAR_6) +\n                         VAR_17[VAR_25] * VAR_21<size_t>(VAR_6)));\n          for (size_t VAR_29 = 0; VAR_29 < VAR_21<size_t>(VAR_6); VAR_29++) {\n            float VAR_35;\n            tinyexr::cpy4(&VAR_35, VAR_28 + VAR_29);\n\n            tinyexr::swap4(VAR_24<unsigned int *>(&VAR_35));\n\n            float *VAR_31 = VAR_24<float **>(VAR_0)[VAR_25];\n            if (VAR_5 == 0) {\n              VAR_31 += (VAR_21<size_t>(VAR_10) + VAR_27) *\n                           VAR_21<size_t>(VAR_8) +\n                       VAR_29;\n            } else {\n              VAR_31 += (VAR_21<size_t>(VAR_7) - 1U -\n                        (VAR_21<size_t>(VAR_10) + VAR_27)) *\n                           VAR_21<size_t>(VAR_8) +\n                       VAR_29;\n            }\n            *VAR_31 = VAR_35;\n          }\n        }\n      } else {\n        assert(0);\n        return false;\n      }\n    }\n#else\n    (void)VAR_14;\n    (void)VAR_13;\n    (void)VAR_15;\n    assert(0);\n    return false;\n#endif\n  } else if (VAR_4 == VAR_45) {\n    for (size_t VAR_25 = 0; VAR_25 < VAR_15; VAR_25++) {\n      for (size_t VAR_27 = 0; VAR_27 < VAR_21<size_t>(VAR_11); VAR_27++) {\n        if (VAR_16[VAR_25].pixel_type == VAR_26) {\n          const unsigned short *VAR_28 =\n              VAR_24<const unsigned short *>(\n                  VAR_2 + VAR_27 * VAR_12 * size_t(VAR_6) +\n                  VAR_17[VAR_25] * VAR_21<size_t>(VAR_6));\n\n          if (VAR_1[VAR_25] == VAR_26) {\n            unsigned short *VAR_46 =\n                VAR_24<unsigned short *>(VAR_0[VAR_25]);\n            if (VAR_5 == 0) {\n              VAR_46 += (size_t(VAR_9) + VAR_27) * size_t(VAR_8);\n            } else {\n              VAR_46 +=\n                  (size_t(VAR_7) - 1 - (size_t(VAR_9) + VAR_27)) * size_t(VAR_8);\n            }\n\n            for (int VAR_29 = 0; VAR_29 < VAR_6; VAR_29++) {\n              tinyexr::FP16 VAR_30;\n\n              /* COMMENT_14 */\n              tinyexr::cpy2(&(VAR_30.u), VAR_28 + VAR_29);\n\n              tinyexr::swap2(VAR_24<unsigned short *>(&VAR_30.u));\n\n              VAR_46[VAR_29] = VAR_30.u;\n            }\n          } else if (VAR_1[VAR_25] == VAR_36) {\n            float *VAR_46 = VAR_24<float *>(VAR_0[VAR_25]);\n            if (VAR_5 == 0) {\n              VAR_46 += (size_t(VAR_9) + VAR_27) * size_t(VAR_8);\n            } else {\n              VAR_46 +=\n                  (size_t(VAR_7) - 1 - (size_t(VAR_9) + VAR_27)) * size_t(VAR_8);\n            }\n\n            if (VAR_24<const unsigned char *>(VAR_28 + VAR_6) >\n                (VAR_2 + VAR_3)) {\n              /* COMMENT_23 */\n              return false;\n            }\n\n            for (int VAR_29 = 0; VAR_29 < VAR_6; VAR_29++) {\n              tinyexr::FP16 VAR_30;\n\n              /* COMMENT_24 */\n              /* COMMENT_14 */\n              tinyexr::cpy2(&(VAR_30.u), VAR_28 + VAR_29);\n\n              tinyexr::swap2(VAR_24<unsigned short *>(&VAR_30.u));\n\n              tinyexr::FP32 VAR_32 = half_to_float(VAR_30);\n\n              VAR_46[VAR_29] = VAR_32.f;\n            }\n          } else {\n            assert(0);\n            return false;\n          }\n        } else if (VAR_16[VAR_25].pixel_type == VAR_36) {\n          const float *VAR_28 = VAR_24<const float *>(\n              VAR_2 + VAR_27 * VAR_12 * size_t(VAR_6) +\n              VAR_17[VAR_25] * VAR_21<size_t>(VAR_6));\n\n          float *VAR_46 = VAR_24<float *>(VAR_0[VAR_25]);\n          if (VAR_5 == 0) {\n            VAR_46 += (size_t(VAR_9) + VAR_27) * size_t(VAR_8);\n          } else {\n            VAR_46 +=\n                (size_t(VAR_7) - 1 - (size_t(VAR_9) + VAR_27)) * size_t(VAR_8);\n          }\n\n          if (VAR_24<const unsigned char *>(VAR_28 + VAR_6) >\n              (VAR_2 + VAR_3)) {\n            /* COMMENT_23 */\n            return false;\n          }\n\n          for (int VAR_29 = 0; VAR_29 < VAR_6; VAR_29++) {\n            float VAR_35;\n            tinyexr::cpy4(&VAR_35, VAR_28 + VAR_29);\n\n            tinyexr::swap4(VAR_24<unsigned int *>(&VAR_35));\n\n            VAR_46[VAR_29] = VAR_35;\n          }\n        } else if (VAR_16[VAR_25].pixel_type == VAR_34) {\n          const unsigned int *VAR_28 = VAR_24<const unsigned int *>(\n              VAR_2 + VAR_27 * VAR_12 * size_t(VAR_6) +\n              VAR_17[VAR_25] * VAR_21<size_t>(VAR_6));\n\n          unsigned int *VAR_46 =\n              VAR_24<unsigned int *>(VAR_0[VAR_25]);\n          if (VAR_5 == 0) {\n            VAR_46 += (size_t(VAR_9) + VAR_27) * size_t(VAR_8);\n          } else {\n            VAR_46 +=\n                (size_t(VAR_7) - 1 - (size_t(VAR_9) + VAR_27)) * size_t(VAR_8);\n          }\n\n          for (int VAR_29 = 0; VAR_29 < VAR_6; VAR_29++) {\n            if (VAR_24<const unsigned char *>(VAR_28 + VAR_29) >=\n                (VAR_2 + VAR_3)) {\n              /* COMMENT_25 */\n              return false;\n            }\n\n            unsigned int VAR_35;\n            tinyexr::cpy4(&VAR_35, VAR_28 + VAR_29);\n\n            tinyexr::swap4(VAR_24<unsigned int *>(&VAR_35));\n\n            VAR_46[VAR_29] = VAR_35;\n          }\n        }\n      }\n    }\n  }\n\n  return true;\n}",
  "func_graph_path": "syoyo/tinyexr/9c602a37b3d3a1d98d473cda32b88f8014344990/tinyexr.h/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -120,8 +120,8 @@\n         assert(requested_pixel_types[c] == TINYEXR_PIXELTYPE_FLOAT);\n         for (size_t v = 0; v < static_cast<size_t>(num_lines); v++) {\n           const float *line_ptr = reinterpret_cast<float *>(&outBuf.at(\n-              v * pixel_data_size * static_cast<size_t>(x_stride) +\n-              channel_offset_list[c] * static_cast<size_t>(x_stride)));\n+              v * pixel_data_size * static_cast<size_t>(width) +\n+              channel_offset_list[c] * static_cast<size_t>(width)));\n           for (size_t u = 0; u < static_cast<size_t>(width); u++) {\n             float val;\n             // val = line_ptr[u];",
  "diff_line_info": {
    "deleted_lines": [
      "              v * pixel_data_size * static_cast<size_t>(x_stride) +",
      "              channel_offset_list[c] * static_cast<size_t>(x_stride)));"
    ],
    "added_lines": [
      "              v * pixel_data_size * static_cast<size_t>(width) +",
      "              channel_offset_list[c] * static_cast<size_t>(width)));"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/syoyo/tinyexr/pull/175",
  "description": {
    "pr_info": {
      "title": "Fix out of bounds access in DecodePixelData",
      "number": 175
    },
    "comment": [
      "I assumed that `line_ptr` is supposed to be calculated using `width`, not `x_stride`, as it is done for all other pixel types.\r\nTested with the proof-of-concept from #167 and fixes said issue.\r\n",
      "@roehling Super awesome! Thanks! Confirmed the PR fiexes OOB segfault for poc file attached in #167 so merged!"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0  \n\n**Reasoning:**\nThe commit specifically fixes an out-of-bounds access issue in DecodePixelData, which is a security vulnerability. The code changes correct the calculation of `line_ptr`, which had contained an incorrect index leading to potential memory corruption or unauthorized access. The presence of a clear security issue and the direct resolution in the code confirms it as a security fix."
}