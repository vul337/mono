{
  "cve_id": "CVE-2022-22892",
  "cwe_ids": [
    "CWE-617"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "jerryscript-project/jerryscript",
  "commit_msg": "Fix arrow function this binding resolving if environment record is present\n\nThis patch fixes #4872 and fixes #4876.\n\nJerryScript-DCO-1.0-Signed-off-by: Robert Fancsik robert.fancsik@h-lab.eu",
  "commit_hash": "c6aab480c1e2d968871028aec53c85ac5566b34a",
  "git_url": "https://github.com/jerryscript-project/jerryscript/commit/c6aab480c1e2d968871028aec53c85ac5566b34a",
  "file_path": "jerry-core/vm/vm.c",
  "func_name": "vm_super_call",
  "func_before": "static void\nvm_super_call (vm_frame_ctx_t *frame_ctx_p) /**< frame context */\n{\n  JERRY_ASSERT (frame_ctx_p->call_operation == VM_EXEC_SUPER_CALL);\n  JERRY_ASSERT (frame_ctx_p->byte_code_p[0] == CBC_EXT_OPCODE);\n\n  const uint8_t *byte_code_p = frame_ctx_p->byte_code_p + 3;\n  uint8_t opcode = byte_code_p[-2];\n  uint32_t arguments_list_len;\n\n  bool spread_arguments = opcode >= CBC_EXT_SPREAD_SUPER_CALL;\n\n  ecma_collection_t *collection_p = NULL;\n  ecma_value_t *arguments_p;\n\n  if (spread_arguments)\n  {\n    ecma_value_t collection = *(--frame_ctx_p->stack_top_p);\n    collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, collection);\n    arguments_p = collection_p->buffer_p;\n    arguments_list_len = collection_p->item_count;\n  }\n  else\n  {\n    arguments_list_len = byte_code_p[-1];\n    arguments_p = frame_ctx_p->stack_top_p;\n  }\n\n  ecma_value_t func_value = *(--frame_ctx_p->stack_top_p);\n  ecma_value_t completion_value;\n\n  ecma_environment_record_t *environment_record_p = ecma_op_get_environment_record (frame_ctx_p->lex_env_p);\n\n  if (!ecma_is_constructor (func_value))\n  {\n    completion_value = ecma_raise_type_error (ECMA_ERR_VALUE_FOR_CLASS_HERITAGE_IS_NOT_A_CONSTRUCTOR);\n  }\n  else\n  {\n    ecma_object_t *func_obj_p = ecma_get_object_from_value (func_value);\n    completion_value =\n      ecma_op_function_construct (func_obj_p, JERRY_CONTEXT (current_new_target_p), arguments_p, arguments_list_len);\n\n    if (!ECMA_IS_VALUE_ERROR (completion_value) && ecma_op_this_binding_is_initialized (environment_record_p))\n    {\n      ecma_free_value (completion_value);\n      completion_value = ecma_raise_reference_error (ECMA_ERR_SUPER_CONSTRUCTOR_MAY_ONLY_BE_CALLED_ONCE);\n    }\n  }\n\n  /* Free registers. */\n  for (uint32_t i = 0; i < arguments_list_len; i++)\n  {\n    ecma_fast_free_value (arguments_p[i]);\n  }\n\n  if (collection_p != NULL)\n  {\n    ecma_collection_destroy (collection_p);\n  }\n\n  if (ecma_is_value_object (completion_value))\n  {\n    ecma_op_bind_this_value (environment_record_p, completion_value);\n    frame_ctx_p->this_binding = completion_value;\n\n    ecma_value_t fields_value = opfunc_init_class_fields (vm_get_class_function (frame_ctx_p), completion_value);\n\n    if (ECMA_IS_VALUE_ERROR (fields_value))\n    {\n      ecma_free_value (completion_value);\n      completion_value = ECMA_VALUE_ERROR;\n    }\n  }\n\n  ecma_free_value (func_value);\n\n  if (JERRY_UNLIKELY (ECMA_IS_VALUE_ERROR (completion_value)))\n  {\n#if JERRY_DEBUGGER\n    JERRY_CONTEXT (debugger_exception_byte_code_p) = frame_ctx_p->byte_code_p;\n#endif /* JERRY_DEBUGGER */\n    frame_ctx_p->byte_code_p = (uint8_t *) vm_error_byte_code_p;\n  }\n  else\n  {\n    frame_ctx_p->byte_code_p = byte_code_p;\n    uint32_t opcode_data = vm_decode_table[(CBC_END + 1) + opcode];\n\n    if (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)))\n    {\n      ecma_fast_free_value (completion_value);\n    }\n    else if (opcode_data & VM_OC_PUT_STACK)\n    {\n      *frame_ctx_p->stack_top_p++ = completion_value;\n    }\n    else\n    {\n      ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, 0));\n      VM_GET_REGISTERS (frame_ctx_p)[0] = completion_value;\n    }\n  }\n}",
  "abstract_func_before": "static void\nvm_super_call (vm_frame_ctx_t *VAR_0) /* COMMENT_0 */\n{\n  JERRY_ASSERT (VAR_0->call_operation == VAR_1);\n  JERRY_ASSERT (VAR_0->byte_code_p[0] == VAR_2);\n\n  const uint8_t *VAR_3 = VAR_0->byte_code_p + 3;\n  uint8_t VAR_4 = VAR_3[-2];\n  uint32_t VAR_5;\n\n  bool VAR_6 = VAR_4 >= VAR_7;\n\n  ecma_collection_t *VAR_8 = NULL;\n  ecma_value_t *VAR_9;\n\n  if (VAR_6)\n  {\n    ecma_value_t VAR_10 = *(--VAR_0->stack_top_p);\n    VAR_8 = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, VAR_10);\n    VAR_9 = VAR_8->buffer_p;\n    VAR_5 = VAR_8->item_count;\n  }\n  else\n  {\n    VAR_5 = VAR_3[-1];\n    VAR_9 = VAR_0->stack_top_p;\n  }\n\n  ecma_value_t VAR_11 = *(--VAR_0->stack_top_p);\n  ecma_value_t VAR_12;\n\n  ecma_environment_record_t *VAR_13 = ecma_op_get_environment_record (VAR_0->lex_env_p);\n\n  if (!ecma_is_constructor (VAR_11))\n  {\n    VAR_12 = ecma_raise_type_error (VAR_14);\n  }\n  else\n  {\n    ecma_object_t *VAR_15 = ecma_get_object_from_value (VAR_11);\n    VAR_12 =\n      ecma_op_function_construct (VAR_15, JERRY_CONTEXT (VAR_16), VAR_9, VAR_5);\n\n    if (!ECMA_IS_VALUE_ERROR (VAR_12) && ecma_op_this_binding_is_initialized (VAR_13))\n    {\n      ecma_free_value (VAR_12);\n      VAR_12 = ecma_raise_reference_error (VAR_17);\n    }\n  }\n\n  /* COMMENT_1 */\n  for (uint32_t VAR_18 = 0; VAR_18 < VAR_5; VAR_18++)\n  {\n    ecma_fast_free_value (VAR_9[VAR_18]);\n  }\n\n  if (VAR_8 != NULL)\n  {\n    ecma_collection_destroy (VAR_8);\n  }\n\n  if (ecma_is_value_object (VAR_12))\n  {\n    ecma_op_bind_this_value (VAR_13, VAR_12);\n    VAR_0->this_binding = VAR_12;\n\n    ecma_value_t VAR_19 = opfunc_init_class_fields (vm_get_class_function (VAR_0), VAR_12);\n\n    if (ECMA_IS_VALUE_ERROR (VAR_19))\n    {\n      ecma_free_value (VAR_12);\n      VAR_12 = VAR_20;\n    }\n  }\n\n  ecma_free_value (VAR_11);\n\n  if (JERRY_UNLIKELY (ECMA_IS_VALUE_ERROR (VAR_12)))\n  {\n#if VAR_21\n    JERRY_CONTEXT (VAR_22) = VAR_0->byte_code_p;\n#endif /* COMMENT_2 */\n    VAR_0->byte_code_p = (uint8_t *) VAR_23;\n  }\n  else\n  {\n    VAR_0->byte_code_p = VAR_3;\n    uint32_t VAR_24 = VAR_25[(VAR_26 + 1) + VAR_4];\n\n    if (!(VAR_24 & (VAR_27 | VAR_28)))\n    {\n      ecma_fast_free_value (VAR_12);\n    }\n    else if (VAR_24 & VAR_27)\n    {\n      *VAR_0->stack_top_p++ = VAR_12;\n    }\n    else\n    {\n      ecma_fast_free_value (VM_GET_REGISTER (VAR_0, 0));\n      VM_GET_REGISTERS (VAR_0)[0] = VAR_12;\n    }\n  }\n}",
  "func_graph_path_before": "jerryscript-project/jerryscript/c6aab480c1e2d968871028aec53c85ac5566b34a/vm.c/vul/before/0.json",
  "func": "static void\nvm_super_call (vm_frame_ctx_t *frame_ctx_p) /**< frame context */\n{\n  JERRY_ASSERT (frame_ctx_p->call_operation == VM_EXEC_SUPER_CALL);\n  JERRY_ASSERT (frame_ctx_p->byte_code_p[0] == CBC_EXT_OPCODE);\n\n  const uint8_t *byte_code_p = frame_ctx_p->byte_code_p + 3;\n  uint8_t opcode = byte_code_p[-2];\n  uint32_t arguments_list_len;\n\n  bool spread_arguments = opcode >= CBC_EXT_SPREAD_SUPER_CALL;\n\n  ecma_collection_t *collection_p = NULL;\n  ecma_value_t *arguments_p;\n\n  if (spread_arguments)\n  {\n    ecma_value_t collection = *(--frame_ctx_p->stack_top_p);\n    collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, collection);\n    arguments_p = collection_p->buffer_p;\n    arguments_list_len = collection_p->item_count;\n  }\n  else\n  {\n    arguments_list_len = byte_code_p[-1];\n    arguments_p = frame_ctx_p->stack_top_p;\n  }\n\n  ecma_value_t func_value = *(--frame_ctx_p->stack_top_p);\n  ecma_value_t completion_value;\n\n  ecma_environment_record_t *environment_record_p = ecma_op_get_environment_record (frame_ctx_p->lex_env_p);\n  JERRY_ASSERT (environment_record_p);\n\n  if (!ecma_is_constructor (func_value))\n  {\n    completion_value = ecma_raise_type_error (ECMA_ERR_VALUE_FOR_CLASS_HERITAGE_IS_NOT_A_CONSTRUCTOR);\n  }\n  else\n  {\n    ecma_object_t *func_obj_p = ecma_get_object_from_value (func_value);\n    completion_value =\n      ecma_op_function_construct (func_obj_p, JERRY_CONTEXT (current_new_target_p), arguments_p, arguments_list_len);\n\n    if (!ECMA_IS_VALUE_ERROR (completion_value) && ecma_op_this_binding_is_initialized (environment_record_p))\n    {\n      ecma_free_value (completion_value);\n      completion_value = ecma_raise_reference_error (ECMA_ERR_SUPER_CONSTRUCTOR_MAY_ONLY_BE_CALLED_ONCE);\n    }\n  }\n\n  /* Free registers. */\n  for (uint32_t i = 0; i < arguments_list_len; i++)\n  {\n    ecma_fast_free_value (arguments_p[i]);\n  }\n\n  if (collection_p != NULL)\n  {\n    ecma_collection_destroy (collection_p);\n  }\n\n  if (ecma_is_value_object (completion_value))\n  {\n    ecma_op_bind_this_value (environment_record_p, completion_value);\n    frame_ctx_p->this_binding = completion_value;\n\n    ecma_value_t fields_value = opfunc_init_class_fields (vm_get_class_function (frame_ctx_p), completion_value);\n\n    if (ECMA_IS_VALUE_ERROR (fields_value))\n    {\n      ecma_free_value (completion_value);\n      completion_value = ECMA_VALUE_ERROR;\n    }\n  }\n\n  ecma_free_value (func_value);\n\n  if (JERRY_UNLIKELY (ECMA_IS_VALUE_ERROR (completion_value)))\n  {\n#if JERRY_DEBUGGER\n    JERRY_CONTEXT (debugger_exception_byte_code_p) = frame_ctx_p->byte_code_p;\n#endif /* JERRY_DEBUGGER */\n    frame_ctx_p->byte_code_p = (uint8_t *) vm_error_byte_code_p;\n  }\n  else\n  {\n    frame_ctx_p->byte_code_p = byte_code_p;\n    uint32_t opcode_data = vm_decode_table[(CBC_END + 1) + opcode];\n\n    if (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)))\n    {\n      ecma_fast_free_value (completion_value);\n    }\n    else if (opcode_data & VM_OC_PUT_STACK)\n    {\n      *frame_ctx_p->stack_top_p++ = completion_value;\n    }\n    else\n    {\n      ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, 0));\n      VM_GET_REGISTERS (frame_ctx_p)[0] = completion_value;\n    }\n  }\n}",
  "abstract_func": "static void\nvm_super_call (vm_frame_ctx_t *VAR_0) /* COMMENT_0 */\n{\n  JERRY_ASSERT (VAR_0->call_operation == VAR_1);\n  JERRY_ASSERT (VAR_0->byte_code_p[0] == VAR_2);\n\n  const uint8_t *VAR_3 = VAR_0->byte_code_p + 3;\n  uint8_t VAR_4 = VAR_3[-2];\n  uint32_t VAR_5;\n\n  bool VAR_6 = VAR_4 >= VAR_7;\n\n  ecma_collection_t *VAR_8 = NULL;\n  ecma_value_t *VAR_9;\n\n  if (VAR_6)\n  {\n    ecma_value_t VAR_10 = *(--VAR_0->stack_top_p);\n    VAR_8 = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, VAR_10);\n    VAR_9 = VAR_8->buffer_p;\n    VAR_5 = VAR_8->item_count;\n  }\n  else\n  {\n    VAR_5 = VAR_3[-1];\n    VAR_9 = VAR_0->stack_top_p;\n  }\n\n  ecma_value_t VAR_11 = *(--VAR_0->stack_top_p);\n  ecma_value_t VAR_12;\n\n  ecma_environment_record_t *VAR_13 = ecma_op_get_environment_record (VAR_0->lex_env_p);\n  JERRY_ASSERT (VAR_13);\n\n  if (!ecma_is_constructor (VAR_11))\n  {\n    VAR_12 = ecma_raise_type_error (VAR_14);\n  }\n  else\n  {\n    ecma_object_t *VAR_15 = ecma_get_object_from_value (VAR_11);\n    VAR_12 =\n      ecma_op_function_construct (VAR_15, JERRY_CONTEXT (VAR_16), VAR_9, VAR_5);\n\n    if (!ECMA_IS_VALUE_ERROR (VAR_12) && ecma_op_this_binding_is_initialized (VAR_13))\n    {\n      ecma_free_value (VAR_12);\n      VAR_12 = ecma_raise_reference_error (VAR_17);\n    }\n  }\n\n  /* COMMENT_1 */\n  for (uint32_t VAR_18 = 0; VAR_18 < VAR_5; VAR_18++)\n  {\n    ecma_fast_free_value (VAR_9[VAR_18]);\n  }\n\n  if (VAR_8 != NULL)\n  {\n    ecma_collection_destroy (VAR_8);\n  }\n\n  if (ecma_is_value_object (VAR_12))\n  {\n    ecma_op_bind_this_value (VAR_13, VAR_12);\n    VAR_0->this_binding = VAR_12;\n\n    ecma_value_t VAR_19 = opfunc_init_class_fields (vm_get_class_function (VAR_0), VAR_12);\n\n    if (ECMA_IS_VALUE_ERROR (VAR_19))\n    {\n      ecma_free_value (VAR_12);\n      VAR_12 = VAR_20;\n    }\n  }\n\n  ecma_free_value (VAR_11);\n\n  if (JERRY_UNLIKELY (ECMA_IS_VALUE_ERROR (VAR_12)))\n  {\n#if VAR_21\n    JERRY_CONTEXT (VAR_22) = VAR_0->byte_code_p;\n#endif /* COMMENT_2 */\n    VAR_0->byte_code_p = (uint8_t *) VAR_23;\n  }\n  else\n  {\n    VAR_0->byte_code_p = VAR_3;\n    uint32_t VAR_24 = VAR_25[(VAR_26 + 1) + VAR_4];\n\n    if (!(VAR_24 & (VAR_27 | VAR_28)))\n    {\n      ecma_fast_free_value (VAR_12);\n    }\n    else if (VAR_24 & VAR_27)\n    {\n      *VAR_0->stack_top_p++ = VAR_12;\n    }\n    else\n    {\n      ecma_fast_free_value (VM_GET_REGISTER (VAR_0, 0));\n      VM_GET_REGISTERS (VAR_0)[0] = VAR_12;\n    }\n  }\n}",
  "func_graph_path": "jerryscript-project/jerryscript/c6aab480c1e2d968871028aec53c85ac5566b34a/vm.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -30,6 +30,7 @@\n   ecma_value_t completion_value;\n \n   ecma_environment_record_t *environment_record_p = ecma_op_get_environment_record (frame_ctx_p->lex_env_p);\n+  JERRY_ASSERT (environment_record_p);\n \n   if (!ecma_is_constructor (func_value))\n   {",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "  JERRY_ASSERT (environment_record_p);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/jerryscript-project/jerryscript/pull/4878",
  "description": {
    "pr_info": {
      "title": "Fix arrow function this binding resolving if environment record is present",
      "number": 4878
    },
    "comment": [
      "This patch fixes #4872 and fixes #4876.\r\n\r\nJerryScript-DCO-1.0-Signed-off-by: Robert Fancsik robert.fancsik@h-lab.eu"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades;  \n**Confidence:** 0.9"
}