{
  "cve_id": "CVE-2018-16391",
  "cwe_ids": [
    "CWE-415",
    "CWE-119"
  ],
  "cvss_vector": "AV:L/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "OpenSC",
  "commit_msg": "fixed out of bounds writes\n\nThanks to Eric Sesterhenn from X41 D-SEC GmbH\nfor reporting the problems.",
  "commit_hash": "360e95d45ac4123255a4c796db96337f332160ad",
  "git_url": "https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad",
  "file_path": "src/libopensc/card-epass2003.c",
  "func_name": "epass2003_sm_unwrap_apdu",
  "func_before": "static int\nepass2003_sm_unwrap_apdu(struct sc_card *card, struct sc_apdu *sm, struct sc_apdu *plain)\n{\n\tint r;\n\tsize_t len = 0;\n\tepass2003_exdata *exdata = NULL;\n\n\tif (!card->drv_data) \n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\texdata = (epass2003_exdata *)card->drv_data;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tr = sc_check_sw(card, sm->sw1, sm->sw2);\n\tif (r == SC_SUCCESS) {\n\t\tif (exdata->sm) {\n\t\t\tif (0 != decrypt_response(card, sm->resp, sm->resplen, plain->resp, &len))\n\t\t\t\treturn SC_ERROR_CARD_CMD_FAILED;\n\t\t}\n\t\telse {\n\t\t\tmemcpy(plain->resp, sm->resp, sm->resplen);\n\t\t\tlen = sm->resplen;\n\t\t}\n\t}\n\n\tplain->resplen = len;\n\tplain->sw1 = sm->sw1;\n\tplain->sw2 = sm->sw2;\n\n\tsc_log(card->ctx,\n\t       \"unwrapped APDU: resplen %\"SC_FORMAT_LEN_SIZE_T\"u, SW %02X%02X\",\n\t       plain->resplen, plain->sw1, plain->sw2);\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}",
  "abstract_func_before": "static int\nepass2003_sm_unwrap_apdu(struct sc_card *VAR_0, struct sc_apdu *VAR_1, struct sc_apdu *VAR_2)\n{\n\tint VAR_3;\n\tsize_t VAR_4 = 0;\n\tepass2003_exdata *VAR_5 = NULL;\n\n\tif (!VAR_0->drv_data) \n\t\treturn VAR_6;\n\n\tVAR_5 = (epass2003_exdata *)VAR_0->drv_data;\n\n\tLOG_FUNC_CALLED(VAR_0->ctx);\n\n\tVAR_3 = sc_check_sw(VAR_0, VAR_1->sw1, VAR_1->sw2);\n\tif (VAR_3 == VAR_7) {\n\t\tif (VAR_5->sm) {\n\t\t\tif (0 != decrypt_response(VAR_0, VAR_1->resp, VAR_1->resplen, VAR_2->resp, &VAR_4))\n\t\t\t\treturn VAR_8;\n\t\t}\n\t\telse {\n\t\t\tmemcpy(VAR_2->resp, VAR_1->resp, VAR_1->resplen);\n\t\t\tVAR_4 = VAR_1->resplen;\n\t\t}\n\t}\n\n\tVAR_2->resplen = VAR_4;\n\tVAR_2->sw1 = VAR_1->sw1;\n\tVAR_2->sw2 = VAR_1->sw2;\n\n\tsc_log(VAR_0->ctx,\n\t       \"unwrapped APDU: resplen %\"VAR_9\"u, SW %02X%02X\",\n\t       VAR_2->resplen, VAR_2->sw1, VAR_2->sw2);\n\tLOG_FUNC_RETURN(VAR_0->ctx, VAR_7);\n}",
  "func_graph_path_before": "OpenSC/360e95d45ac4123255a4c796db96337f332160ad/card-epass2003.c/vul/before/1.json",
  "func": "static int\nepass2003_sm_unwrap_apdu(struct sc_card *card, struct sc_apdu *sm, struct sc_apdu *plain)\n{\n\tint r;\n\tsize_t len = 0;\n\tepass2003_exdata *exdata = NULL;\n\n\tif (!card->drv_data) \n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\texdata = (epass2003_exdata *)card->drv_data;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tr = sc_check_sw(card, sm->sw1, sm->sw2);\n\tif (r == SC_SUCCESS) {\n\t\tif (exdata->sm) {\n\t\t\tlen = plain->resplen;\n\t\t\tif (0 != decrypt_response(card, sm->resp, sm->resplen, plain->resp, &len))\n\t\t\t\treturn SC_ERROR_CARD_CMD_FAILED;\n\t\t}\n\t\telse {\n\t\t\tmemcpy(plain->resp, sm->resp, sm->resplen);\n\t\t\tlen = sm->resplen;\n\t\t}\n\t}\n\n\tplain->resplen = len;\n\tplain->sw1 = sm->sw1;\n\tplain->sw2 = sm->sw2;\n\n\tsc_log(card->ctx,\n\t       \"unwrapped APDU: resplen %\"SC_FORMAT_LEN_SIZE_T\"u, SW %02X%02X\",\n\t       plain->resplen, plain->sw1, plain->sw2);\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}",
  "abstract_func": "static int\nepass2003_sm_unwrap_apdu(struct sc_card *VAR_0, struct sc_apdu *VAR_1, struct sc_apdu *VAR_2)\n{\n\tint VAR_3;\n\tsize_t VAR_4 = 0;\n\tepass2003_exdata *VAR_5 = NULL;\n\n\tif (!VAR_0->drv_data) \n\t\treturn VAR_6;\n\n\tVAR_5 = (epass2003_exdata *)VAR_0->drv_data;\n\n\tLOG_FUNC_CALLED(VAR_0->ctx);\n\n\tVAR_3 = sc_check_sw(VAR_0, VAR_1->sw1, VAR_1->sw2);\n\tif (VAR_3 == VAR_7) {\n\t\tif (VAR_5->sm) {\n\t\t\tVAR_4 = VAR_2->resplen;\n\t\t\tif (0 != decrypt_response(VAR_0, VAR_1->resp, VAR_1->resplen, VAR_2->resp, &VAR_4))\n\t\t\t\treturn VAR_8;\n\t\t}\n\t\telse {\n\t\t\tmemcpy(VAR_2->resp, VAR_1->resp, VAR_1->resplen);\n\t\t\tVAR_4 = VAR_1->resplen;\n\t\t}\n\t}\n\n\tVAR_2->resplen = VAR_4;\n\tVAR_2->sw1 = VAR_1->sw1;\n\tVAR_2->sw2 = VAR_1->sw2;\n\n\tsc_log(VAR_0->ctx,\n\t       \"unwrapped APDU: resplen %\"VAR_9\"u, SW %02X%02X\",\n\t       VAR_2->resplen, VAR_2->sw1, VAR_2->sw2);\n\tLOG_FUNC_RETURN(VAR_0->ctx, VAR_7);\n}",
  "func_graph_path": "OpenSC/360e95d45ac4123255a4c796db96337f332160ad/card-epass2003.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -15,6 +15,7 @@\n \tr = sc_check_sw(card, sm->sw1, sm->sw2);\n \tif (r == SC_SUCCESS) {\n \t\tif (exdata->sm) {\n+\t\t\tlen = plain->resplen;\n \t\t\tif (0 != decrypt_response(card, sm->resp, sm->resplen, plain->resp, &len))\n \t\t\t\treturn SC_ERROR_CARD_CMD_FAILED;\n \t\t}",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "\t\t\tlen = plain->resplen;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/OpenSC/OpenSC/pull/1447",
  "description": {
    "pr_info": {
      "title": "Security issues identified by fuzzing",
      "number": 1447
    },
    "comment": [
      "This PR merges changes addressing issues identified by fuzzing OpenSC driver by Eric Sesterhenn. The separate commits are authored mostly by @frankmorgner, @dengert, Eric and me.\r\n\r\nFor more information, see the blog post:\r\n\r\nhttps://www.x41-dsec.de/lab/blog/smartcards/\r\n\r\nThe changes were tested to ensure they still work for the cards we have, but testing with more cards would be always appreciated.\r\n\r\n##### Checklist\r\n<!-- Remove items that do not apply. For completed items, change [ ] to [x]. -->\r\n- [X] PKCS#11 module is tested\r\n- [ ] Windows minidriver is tested\r\n- [ ] macOS tokend is tested\r\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95  \nThe patch addresses an out-of-bounds write vulnerability identified through fuzzing, aligning with the code changes that fix buffer handling. High confidence due to clear indicators of a security fix."
}