{
  "cve_id": "CVE-2023-44487",
  "cwe_ids": [
    "CWE-400"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "envoyproxy/envoy",
  "commit_msg": "Limit the number of HTTP requests processed from a connection in I/O cycle\n\nSigned-off-by: Yan Avlasov <yavlasov@google.com>\n\nSigned-off-by: Ryan Northey <ryan@synca.io>",
  "commit_hash": "cf687ac66b60f14a71e2a7e552943f138922a71d",
  "git_url": "https://github.com/envoyproxy/envoy/commit/cf687ac66b60f14a71e2a7e552943f138922a71d",
  "file_path": "source/common/http/conn_manager_impl.cc",
  "func_name": "ConnectionManagerImpl::initializeReadFilterCallbacks",
  "func_before": "void ConnectionManagerImpl::initializeReadFilterCallbacks(Network::ReadFilterCallbacks& callbacks) {\n  read_callbacks_ = &callbacks;\n  dispatcher_ = &callbacks.connection().dispatcher();\n\n  stats_.named_.downstream_cx_total_.inc();\n  stats_.named_.downstream_cx_active_.inc();\n  if (read_callbacks_->connection().ssl()) {\n    stats_.named_.downstream_cx_ssl_total_.inc();\n    stats_.named_.downstream_cx_ssl_active_.inc();\n  }\n\n  read_callbacks_->connection().addConnectionCallbacks(*this);\n\n  if (config_.addProxyProtocolConnectionState() &&\n      !read_callbacks_->connection()\n           .streamInfo()\n           .filterState()\n           ->hasData<Network::ProxyProtocolFilterState>(Network::ProxyProtocolFilterState::key())) {\n    read_callbacks_->connection().streamInfo().filterState()->setData(\n        Network::ProxyProtocolFilterState::key(),\n        std::make_unique<Network::ProxyProtocolFilterState>(Network::ProxyProtocolData{\n            read_callbacks_->connection().connectionInfoProvider().remoteAddress(),\n            read_callbacks_->connection().connectionInfoProvider().localAddress()}),\n        StreamInfo::FilterState::StateType::ReadOnly,\n        StreamInfo::FilterState::LifeSpan::Connection);\n  }\n\n  if (config_.idleTimeout()) {\n    connection_idle_timer_ =\n        dispatcher_->createScaledTimer(Event::ScaledTimerType::HttpDownstreamIdleConnectionTimeout,\n                                       [this]() -> void { onIdleTimeout(); });\n    connection_idle_timer_->enableTimer(config_.idleTimeout().value());\n  }\n\n  if (config_.maxConnectionDuration()) {\n    connection_duration_timer_ =\n        dispatcher_->createTimer([this]() -> void { onConnectionDurationTimeout(); });\n    connection_duration_timer_->enableTimer(config_.maxConnectionDuration().value());\n  }\n\n  read_callbacks_->connection().setDelayedCloseTimeout(config_.delayedCloseTimeout());\n\n  read_callbacks_->connection().setConnectionStats(\n      {stats_.named_.downstream_cx_rx_bytes_total_, stats_.named_.downstream_cx_rx_bytes_buffered_,\n       stats_.named_.downstream_cx_tx_bytes_total_, stats_.named_.downstream_cx_tx_bytes_buffered_,\n       nullptr, &stats_.named_.downstream_cx_delayed_close_timeout_});\n}",
  "abstract_func_before": "void ConnectionManagerImpl::initializeReadFilterCallbacks(Network::ReadFilterCallbacks& VAR_0) {\n  VAR_1 = &VAR_0;\n  VAR_2 = &VAR_0.connection().dispatcher();\n\n  VAR_3.named_.downstream_cx_total_.inc();\n  VAR_3.named_.downstream_cx_active_.inc();\n  if (VAR_1->connection().ssl()) {\n    VAR_3.named_.downstream_cx_ssl_total_.inc();\n    VAR_3.named_.downstream_cx_ssl_active_.inc();\n  }\n\n  VAR_1->connection().addConnectionCallbacks(*this);\n\n  if (VAR_4.addProxyProtocolConnectionState() &&\n      !VAR_1->connection()\n           .streamInfo()\n           .filterState()\n           ->hasData<Network::ProxyProtocolFilterState>(Network::ProxyProtocolFilterState::key())) {\n    VAR_1->connection().streamInfo().filterState()->setData(\n        Network::ProxyProtocolFilterState::key(),\n        std::VAR_5<Network::ProxyProtocolFilterState>(Network::ProxyProtocolData{\n            VAR_1->connection().connectionInfoProvider().remoteAddress(),\n            VAR_1->connection().connectionInfoProvider().localAddress()}),\n        StreamInfo::FilterState::StateType::ReadOnly,\n        StreamInfo::FilterState::LifeSpan::Connection);\n  }\n\n  if (VAR_4.idleTimeout()) {\n    VAR_6 =\n        VAR_2->createScaledTimer(Event::ScaledTimerType::HttpDownstreamIdleConnectionTimeout,\n                                       [this]() -> void { onIdleTimeout(); });\n    VAR_6->enableTimer(VAR_4.idleTimeout().value());\n  }\n\n  if (VAR_4.maxConnectionDuration()) {\n    VAR_7 =\n        VAR_2->createTimer([this]() -> void { onConnectionDurationTimeout(); });\n    VAR_7->enableTimer(VAR_4.maxConnectionDuration().value());\n  }\n\n  VAR_1->connection().setDelayedCloseTimeout(VAR_4.delayedCloseTimeout());\n\n  VAR_1->connection().setConnectionStats(\n      {VAR_3.named_.downstream_cx_rx_bytes_total_, VAR_3.named_.downstream_cx_rx_bytes_buffered_,\n       VAR_3.named_.downstream_cx_tx_bytes_total_, VAR_3.named_.downstream_cx_tx_bytes_buffered_,\n       nullptr, &VAR_3.named_.downstream_cx_delayed_close_timeout_});\n}",
  "func_graph_path_before": "envoyproxy/envoy/cf687ac66b60f14a71e2a7e552943f138922a71d/conn_manager_impl.cc/vul/before/5.json",
  "func": "void ConnectionManagerImpl::initializeReadFilterCallbacks(Network::ReadFilterCallbacks& callbacks) {\n  read_callbacks_ = &callbacks;\n  dispatcher_ = &callbacks.connection().dispatcher();\n  if (max_requests_during_dispatch_ != UINT32_MAX) {\n    deferred_request_processing_callback_ =\n        dispatcher_->createSchedulableCallback([this]() -> void { onDeferredRequestProcessing(); });\n  }\n\n  stats_.named_.downstream_cx_total_.inc();\n  stats_.named_.downstream_cx_active_.inc();\n  if (read_callbacks_->connection().ssl()) {\n    stats_.named_.downstream_cx_ssl_total_.inc();\n    stats_.named_.downstream_cx_ssl_active_.inc();\n  }\n\n  read_callbacks_->connection().addConnectionCallbacks(*this);\n\n  if (config_.addProxyProtocolConnectionState() &&\n      !read_callbacks_->connection()\n           .streamInfo()\n           .filterState()\n           ->hasData<Network::ProxyProtocolFilterState>(Network::ProxyProtocolFilterState::key())) {\n    read_callbacks_->connection().streamInfo().filterState()->setData(\n        Network::ProxyProtocolFilterState::key(),\n        std::make_unique<Network::ProxyProtocolFilterState>(Network::ProxyProtocolData{\n            read_callbacks_->connection().connectionInfoProvider().remoteAddress(),\n            read_callbacks_->connection().connectionInfoProvider().localAddress()}),\n        StreamInfo::FilterState::StateType::ReadOnly,\n        StreamInfo::FilterState::LifeSpan::Connection);\n  }\n\n  if (config_.idleTimeout()) {\n    connection_idle_timer_ =\n        dispatcher_->createScaledTimer(Event::ScaledTimerType::HttpDownstreamIdleConnectionTimeout,\n                                       [this]() -> void { onIdleTimeout(); });\n    connection_idle_timer_->enableTimer(config_.idleTimeout().value());\n  }\n\n  if (config_.maxConnectionDuration()) {\n    connection_duration_timer_ =\n        dispatcher_->createTimer([this]() -> void { onConnectionDurationTimeout(); });\n    connection_duration_timer_->enableTimer(config_.maxConnectionDuration().value());\n  }\n\n  read_callbacks_->connection().setDelayedCloseTimeout(config_.delayedCloseTimeout());\n\n  read_callbacks_->connection().setConnectionStats(\n      {stats_.named_.downstream_cx_rx_bytes_total_, stats_.named_.downstream_cx_rx_bytes_buffered_,\n       stats_.named_.downstream_cx_tx_bytes_total_, stats_.named_.downstream_cx_tx_bytes_buffered_,\n       nullptr, &stats_.named_.downstream_cx_delayed_close_timeout_});\n}",
  "abstract_func": "void ConnectionManagerImpl::initializeReadFilterCallbacks(Network::ReadFilterCallbacks& VAR_0) {\n  VAR_1 = &VAR_0;\n  VAR_2 = &VAR_0.connection().dispatcher();\n  if (VAR_3 != VAR_4) {\n    VAR_5 =\n        VAR_2->createSchedulableCallback([this]() -> void { onDeferredRequestProcessing(); });\n  }\n\n  VAR_6.named_.downstream_cx_total_.inc();\n  VAR_6.named_.downstream_cx_active_.inc();\n  if (VAR_1->connection().ssl()) {\n    VAR_6.named_.downstream_cx_ssl_total_.inc();\n    VAR_6.named_.downstream_cx_ssl_active_.inc();\n  }\n\n  VAR_1->connection().addConnectionCallbacks(*this);\n\n  if (VAR_7.addProxyProtocolConnectionState() &&\n      !VAR_1->connection()\n           .streamInfo()\n           .filterState()\n           ->hasData<Network::ProxyProtocolFilterState>(Network::ProxyProtocolFilterState::key())) {\n    VAR_1->connection().streamInfo().filterState()->setData(\n        Network::ProxyProtocolFilterState::key(),\n        std::VAR_8<Network::ProxyProtocolFilterState>(Network::ProxyProtocolData{\n            VAR_1->connection().connectionInfoProvider().remoteAddress(),\n            VAR_1->connection().connectionInfoProvider().localAddress()}),\n        StreamInfo::FilterState::StateType::ReadOnly,\n        StreamInfo::FilterState::LifeSpan::Connection);\n  }\n\n  if (VAR_7.idleTimeout()) {\n    VAR_9 =\n        VAR_2->createScaledTimer(Event::ScaledTimerType::HttpDownstreamIdleConnectionTimeout,\n                                       [this]() -> void { onIdleTimeout(); });\n    VAR_9->enableTimer(VAR_7.idleTimeout().value());\n  }\n\n  if (VAR_7.maxConnectionDuration()) {\n    VAR_10 =\n        VAR_2->createTimer([this]() -> void { onConnectionDurationTimeout(); });\n    VAR_10->enableTimer(VAR_7.maxConnectionDuration().value());\n  }\n\n  VAR_1->connection().setDelayedCloseTimeout(VAR_7.delayedCloseTimeout());\n\n  VAR_1->connection().setConnectionStats(\n      {VAR_6.named_.downstream_cx_rx_bytes_total_, VAR_6.named_.downstream_cx_rx_bytes_buffered_,\n       VAR_6.named_.downstream_cx_tx_bytes_total_, VAR_6.named_.downstream_cx_tx_bytes_buffered_,\n       nullptr, &VAR_6.named_.downstream_cx_delayed_close_timeout_});\n}",
  "func_graph_path": "envoyproxy/envoy/cf687ac66b60f14a71e2a7e552943f138922a71d/conn_manager_impl.cc/vul/after/5.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,10 @@\n void ConnectionManagerImpl::initializeReadFilterCallbacks(Network::ReadFilterCallbacks& callbacks) {\n   read_callbacks_ = &callbacks;\n   dispatcher_ = &callbacks.connection().dispatcher();\n+  if (max_requests_during_dispatch_ != UINT32_MAX) {\n+    deferred_request_processing_callback_ =\n+        dispatcher_->createSchedulableCallback([this]() -> void { onDeferredRequestProcessing(); });\n+  }\n \n   stats_.named_.downstream_cx_total_.inc();\n   stats_.named_.downstream_cx_active_.inc();",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "  if (max_requests_during_dispatch_ != UINT32_MAX) {",
      "    deferred_request_processing_callback_ =",
      "        dispatcher_->createSchedulableCallback([this]() -> void { onDeferredRequestProcessing(); });",
      "  }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/envoyproxy/envoy/pull/30055",
  "description": {
    "pr_info": {
      "title": "http: Fix CVE CVE-2023-44487",
      "number": 30055
    },
    "comment": [
      "<!--\r\n!!!ATTENTION!!!\r\n\r\nIf you are fixing *any* crash or *any* potential security issue, *do not*\r\nopen a pull request in this repo. Please report the issue via emailing\r\nenvoy-security@googlegroups.com where the issue will be triaged appropriately.\r\nThank you in advance for helping to keep Envoy secure.\r\n\r\n!!!ATTENTION!!!\r\n\r\nFor an explanation of how to fill out the fields, please see the relevant section\r\nin [PULL_REQUESTS.md](https://github.com/envoyproxy/envoy/blob/main/PULL_REQUESTS.md)\r\n-->\r\n\r\nCommit Message:\r\nAdditional Description:\r\nRisk Level:\r\nTesting:\r\nDocs Changes:\r\nRelease Notes:\r\nPlatform Specific Features:\r\n[Optional Runtime guard:]\r\n[Optional Fixes #Issue]\r\n[Optional Fixes commit #PR or SHA]\r\n[Optional Deprecated:]\r\n[Optional [API Considerations](https://github.com/envoyproxy/envoy/blob/main/api/review_checklist.md):]\r\n",
      "CC @envoyproxy/runtime-guard-changes: FYI only for changes made to `(source/common/runtime/runtime_features.cc)`.\n\n\n<details>\n\t<summary>:cat:</summary>\n\nCaused by: https://github.com/envoyproxy/envoy/pull/30055 was opened by phlax.\n\nsee: [more](https://github.com/envoyproxy/envoy/pull/30055), [trace](https://prod.repokitteh.app/traces/ui/envoyproxy/envoy/ae59df20-6764-11ee-8d82-8654fbd73ccb).\n</details>",
      "should we document the stats in `docs/root/configuration/http/http_conn_man/stats.rst`? I need to blame to find this commit to get more sense on `http.downstream_rq_too_many_premature_resets`",
      "Hi,\r\n\r\nI'm trying to analyze the impact from our users perspective what these new parameters are introducing for them.\r\n\r\n`overload.premature_reset_min_stream_lifetime_seconds` and `overload.premature_reset_total_stream_count` as I understood are for identifying that rapid reset attack is happening. Or if not the actual attack then some misbehavior of client. [Rapid reset](https://github.com/envoyproxy/envoy/security/advisories/GHSA-jhv4-f7mr-xx76)\r\n\r\nAnd `http.max_requests_per_io_cycle` is to help serving requests that are not related to the attack.\r\n\r\nBut in practice what does this mean:\r\n - If we set http.max_requests_per_io_cycle to 1 than Envoy will switch between TCP sockets after it processes 1 request in each?\r\n - Is this switch expected to be costly CPU wise?\r\n - how does Envoy work without setting these parameters? \r\n\r\nAlso I couldn't find definition in your repo on what I/O cycle means for you. Can you please explain?\r\n\r\nThanks in advance!"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.9"
}