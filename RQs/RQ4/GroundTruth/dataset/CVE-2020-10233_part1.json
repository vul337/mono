{
  "cve_id": "CVE-2020-10233",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "sleuthkit",
  "commit_msg": "Correct guarding conditional to account for array\n\nCorrect the guard to account for the size of the array of updates, as sizeof(nfts_upd) is always 2 bytes, regardless of how many updates there actually are.\n\nFixes #1829",
  "commit_hash": "0c7d5e7333aeb61dace51750b56fcaad55a6359b",
  "git_url": "https://github.com/sleuthkit/sleuthkit/commit/0c7d5e7333aeb61dace51750b56fcaad55a6359b",
  "file_path": "tsk/fs/ntfs.c",
  "func_name": "ntfs_dinode_lookup",
  "func_before": "TSK_RETVAL_ENUM\nntfs_dinode_lookup(NTFS_INFO * a_ntfs, char *a_buf, TSK_INUM_T a_mftnum)\n{\n    TSK_OFF_T mftaddr_b, mftaddr2_b, offset;\n    size_t mftaddr_len = 0;\n    int i;\n    TSK_FS_INFO *fs = (TSK_FS_INFO *) & a_ntfs->fs_info;\n    TSK_FS_ATTR_RUN *data_run;\n    ntfs_upd *upd;\n    uint16_t sig_seq;\n    ntfs_mft *mft;\n\n\n    /* sanity checks */\n    if (!a_buf) {\n        tsk_error_reset();\n        tsk_error_set_errno(TSK_ERR_FS_ARG);\n        tsk_error_set_errstr(\"mft_lookup: null mft buffer\");\n        return TSK_ERR;\n    }\n\n    if (a_mftnum < fs->first_inum) {\n        tsk_error_reset();\n        tsk_error_set_errno(TSK_ERR_FS_ARG);\n        tsk_error_set_errstr(\"mft_lookup: inode number is too small (%\"\n            PRIuINUM \")\", a_mftnum);\n        return TSK_ERR;\n    }\n\n    /* Because this code reads teh actual MFT, we need to make sure we\n     * decrement the last_inum because the last value is a special value\n     * for the ORPHANS directory */\n    if (a_mftnum > fs->last_inum - 1) {\n        tsk_error_reset();\n        tsk_error_set_errno(TSK_ERR_FS_ARG);\n        tsk_error_set_errstr(\"mft_lookup: inode number is too large (%\"\n            PRIuINUM \")\", a_mftnum);\n        return TSK_ERR;\n    }\n\n\n    if (tsk_verbose)\n        tsk_fprintf(stderr,\n            \"ntfs_dinode_lookup: Processing MFT %\" PRIuINUM \"\\n\",\n            a_mftnum);\n\n    /* If mft_data (the cached $Data attribute of $MFT) is not there yet,\n     * then we have not started to load $MFT yet.  In that case, we will\n     * 'cheat' and calculate where it goes.  This should only be for\n     * $MFT itself, in which case the calculation is easy\n     */\n    if (!a_ntfs->mft_data) {\n\n        /* This is just a random check with the assumption being that\n         * we don't want to just do a guess calculation for a very large\n         * MFT entry\n         */\n        if (a_mftnum > NTFS_LAST_DEFAULT_INO) {\n            tsk_error_reset();\n            tsk_error_set_errno(TSK_ERR_FS_ARG);\n            tsk_error_set_errstr\n                (\"Error trying to load a high MFT entry when the MFT itself has not been loaded (%\"\n                PRIuINUM \")\", a_mftnum);\n            return TSK_ERR;\n        }\n\n        mftaddr_b = a_ntfs->root_mft_addr + a_mftnum * a_ntfs->mft_rsize_b;\n        mftaddr2_b = 0;\n    }\n    else {\n        /* The MFT may not be in consecutive clusters, so we need to use its\n         * data attribute run list to find out what address to read\n         *\n         * This is why we cached it\n         */\n\n        // will be set to the address of the MFT entry\n        mftaddr_b = mftaddr2_b = 0;\n\n        /* The byte offset within the $Data stream */\n        offset = a_mftnum * a_ntfs->mft_rsize_b;\n\n        /* NOTE: data_run values are in clusters\n         *\n         * cycle through the runs in $Data and identify which\n         * has the MFT entry that we want\n         */\n        for (data_run = a_ntfs->mft_data->nrd.run;\n            data_run != NULL; data_run = data_run->next) {\n\n            /* Test for possible overflows / error conditions */\n            if ((offset < 0) || (data_run->len >= (TSK_DADDR_T)(LLONG_MAX / a_ntfs->csize_b))){\n                tsk_error_reset();\n                tsk_error_set_errno(TSK_ERR_FS_INODE_COR);\n                tsk_error_set_errstr\n                (\"ntfs_dinode_lookup: Overflow when calculating run length\");\n                return TSK_COR;\n            }\n\n            /* The length of this specific run */\n            TSK_OFF_T run_len = data_run->len * a_ntfs->csize_b;\n\n            /* Is our MFT entry is in this run somewhere ? */\n            if (offset < run_len) {\n\n                if (tsk_verbose)\n                    tsk_fprintf(stderr,\n                        \"ntfs_dinode_lookup: Found in offset: %\"\n                        PRIuDADDR \"  size: %\" PRIuDADDR \" at offset: %\"\n\t\t\t\t\t\tPRIdOFF \"\\n\", data_run->addr, data_run->len,\n                        offset);\n\n                /* special case where the MFT entry crosses\n                 * a run (only happens when cluster size is 512-bytes\n                 * and there are an odd number of clusters in the run)\n                 */\n                if (run_len < offset + a_ntfs->mft_rsize_b) {\n\n                    if (tsk_verbose)\n                        tsk_fprintf(stderr,\n                            \"ntfs_dinode_lookup: Entry crosses run border\\n\");\n\n                    if (data_run->next == NULL) {\n                        tsk_error_reset();\n                        tsk_error_set_errno(TSK_ERR_FS_INODE_COR);\n                        tsk_error_set_errstr\n                            (\"mft_lookup: MFT entry crosses a cluster and there are no more clusters!\");\n                        return TSK_COR;\n                    }\n\n                    /* Assign address where the remainder of the entry is */\n                    mftaddr2_b = data_run->next->addr * a_ntfs->csize_b;\n                    /* this should always be 512, but just in case */\n                    mftaddr_len = (size_t) (run_len - offset);\n                }\n\n                /* Assign address of where the MFT entry starts */\n                mftaddr_b = data_run->addr * a_ntfs->csize_b + offset;\n                if (tsk_verbose)\n                    tsk_fprintf(stderr,\n                        \"ntfs_dinode_lookup: Entry address at: %\"\n\t\t\t\t\t\tPRIdOFF \"\\n\", mftaddr_b);\n                break;\n            }\n\n            /* decrement the offset we are looking for */\n            offset -= run_len;\n        }\n\n        /* Did we find it? */\n        if (!mftaddr_b) {\n            tsk_error_reset();\n            tsk_error_set_errno(TSK_ERR_FS_INODE_NUM);\n            tsk_error_set_errstr(\"mft_lookup: Error finding MFT entry %\"\n                PRIuINUM \" in $MFT\", a_mftnum);\n            return TSK_ERR;\n        }\n    }\n\n\n    /* can we do just one read or do we need multiple? */\n    if (mftaddr2_b) {\n        ssize_t cnt;\n        /* read the first part into mft */\n        cnt = tsk_fs_read(&a_ntfs->fs_info, mftaddr_b, a_buf, mftaddr_len);\n        if (cnt != (ssize_t)mftaddr_len) {\n            if (cnt >= 0) {\n                tsk_error_reset();\n                tsk_error_set_errno(TSK_ERR_FS_READ);\n            }\n            tsk_error_set_errstr2\n                (\"ntfs_dinode_lookup: Error reading MFT Entry (part 1) at %\"\n\t\t\t\t\tPRIdOFF, mftaddr_b);\n            return TSK_ERR;\n        }\n\n        /* read the second part into mft */\n        cnt = tsk_fs_read\n            (&a_ntfs->fs_info, mftaddr2_b,\n            (char *) ((uintptr_t) a_buf + (uintptr_t) mftaddr_len),\n            a_ntfs->mft_rsize_b - mftaddr_len);\n        if (cnt != (ssize_t)(a_ntfs->mft_rsize_b - mftaddr_len)) {\n            if (cnt >= 0) {\n                tsk_error_reset();\n                tsk_error_set_errno(TSK_ERR_FS_READ);\n            }\n            tsk_error_set_errstr2\n                (\"ntfs_dinode_lookup: Error reading MFT Entry (part 2) at %\"\n\t\t\t\t\tPRIdOFF, mftaddr2_b);\n            return TSK_ERR;\n        }\n    }\n    else {\n        ssize_t cnt;\n        /* read the raw entry into mft */\n        cnt =\n            tsk_fs_read(&a_ntfs->fs_info, mftaddr_b, a_buf,\n            a_ntfs->mft_rsize_b);\n        if (cnt != a_ntfs->mft_rsize_b) {\n            if (cnt >= 0) {\n                tsk_error_reset();\n                tsk_error_set_errno(TSK_ERR_FS_READ);\n            }\n            tsk_error_set_errstr2\n                (\"ntfs_dinode_lookup: Error reading MFT Entry at %\"\n\t\t\t\t\tPRIdOFF, mftaddr_b);\n            return TSK_ERR;\n        }\n    }\n\n    /* Sanity Check */\n#if 0\n    /* This is no longer applied because it caused too many problems\n     * with images that had 0 and 1 etc. as values.  Testing shows that\n     * even Windows XP doesn't care if entries have an invalid entry, so\n     * this is no longer checked.  The update sequence check should find\n     * corrupt entries\n     * */\n    if ((tsk_getu32(fs->endian, mft->magic) != NTFS_MFT_MAGIC)\n        && (tsk_getu32(fs->endian, mft->magic) != NTFS_MFT_MAGIC_BAAD)\n        && (tsk_getu32(fs->endian, mft->magic) != NTFS_MFT_MAGIC_ZERO)) {\n        tsk_error_set_errno(TSK_ERR_FS_INODE_COR);\n        tsk_error_set_errstr(\"entry %d has an invalid MFT magic: %x\",\n            mftnum, tsk_getu32(fs->endian, mft->magic));\n        return 1;\n    }\n#endif\n    /* The MFT entries have error and integrity checks in them\n     * called update sequences.  They must be checked and removed\n     * so that later functions can process the data as normal.\n     * They are located in the last 2 bytes of each 512-bytes of data.\n     *\n     * We first verify that the the 2-byte value is a give value and\n     * then replace it with what should be there\n     */\n    /* sanity check so we don't run over in the next loop */\n    mft = (ntfs_mft *) a_buf;\n    if ((tsk_getu16(fs->endian, mft->upd_cnt) > 0) &&\n        (((uint32_t) (tsk_getu16(fs->endian,\n                        mft->upd_cnt) - 1) * NTFS_UPDATE_SEQ_STRIDE) >\n            a_ntfs->mft_rsize_b)) {\n        tsk_error_reset();\n        tsk_error_set_errno(TSK_ERR_FS_INODE_COR);\n        tsk_error_set_errstr\n            (\"dinode_lookup: More Update Sequence Entries than MFT size\");\n        return TSK_COR;\n    }\n    if (tsk_getu16(fs->endian, mft->upd_off) + sizeof(ntfs_upd) > a_ntfs->mft_rsize_b) {\n        tsk_error_reset();\n        tsk_error_set_errno(TSK_ERR_FS_INODE_COR);\n        tsk_error_set_errstr\n            (\"dinode_lookup: Update sequence would read past MFT size\");\n        return TSK_COR;\n    }\n\n    /* Apply the update sequence structure template */\n    upd =\n        (ntfs_upd *) ((uintptr_t) a_buf + tsk_getu16(fs->endian,\n            mft->upd_off));\n    /* Get the sequence value that each 16-bit value should be */\n    sig_seq = tsk_getu16(fs->endian, upd->upd_val);\n    /* cycle through each sector */\n    for (i = 1; i < tsk_getu16(fs->endian, mft->upd_cnt); i++) {\n        uint8_t *new_val, *old_val;\n        /* The offset into the buffer of the value to analyze */\n        size_t offset = i * NTFS_UPDATE_SEQ_STRIDE - 2;\n\n        /* Check that there is room in the buffer to read the current sequence value */\n        if (offset + 2 > a_ntfs->mft_rsize_b) {\n            tsk_error_reset();\n            tsk_error_set_errno(TSK_ERR_FS_INODE_COR);\n            tsk_error_set_errstr\n            (\"dinode_lookup: Ran out of data while parsing update sequence values\");\n            return TSK_COR;\n        }\n\n        /* get the current sequence value */\n        uint16_t cur_seq =\n            tsk_getu16(fs->endian, (uintptr_t) a_buf + offset);\n        if (cur_seq != sig_seq) {\n            /* get the replacement value */\n            uint16_t cur_repl =\n                tsk_getu16(fs->endian, &upd->upd_seq + (i - 1) * 2);\n            tsk_error_reset();\n            tsk_error_set_errno(TSK_ERR_FS_GENFS);\n\n            tsk_error_set_errstr\n                (\"Incorrect update sequence value in MFT entry\\nSignature Value: 0x%\"\n                PRIx16 \" Actual Value: 0x%\" PRIx16\n                \" Replacement Value: 0x%\" PRIx16\n                \"\\nThis is typically because of a corrupted entry\",\n                sig_seq, cur_seq, cur_repl);\n            return TSK_COR;\n        }\n\n        new_val = &upd->upd_seq + (i - 1) * 2;\n        old_val = (uint8_t *) ((uintptr_t) a_buf + offset);\n        /*\n           if (tsk_verbose)\n           tsk_fprintf(stderr,\n           \"ntfs_dinode_lookup: upd_seq %i   Replacing: %.4\"\n           PRIx16 \"   With: %.4\" PRIx16 \"\\n\", i,\n           tsk_getu16(fs->endian, old_val), tsk_getu16(fs->endian,\n           new_val));\n         */\n        *old_val++ = *new_val++;\n        *old_val = *new_val;\n    }\n\n    return TSK_OK;\n}",
  "abstract_func_before": "TSK_RETVAL_ENUM\nntfs_dinode_lookup(NTFS_INFO * VAR_0, char *VAR_1, TSK_INUM_T VAR_2)\n{\n    TSK_OFF_T VAR_3, VAR_4, VAR_5;\n    size_t VAR_6 = 0;\n    int VAR_7;\n    TSK_FS_INFO *VAR_8 = (TSK_FS_INFO *) & VAR_0->fs_info;\n    TSK_FS_ATTR_RUN *VAR_9;\n    ntfs_upd *VAR_10;\n    uint16_t VAR_11;\n    ntfs_mft *VAR_12;\n\n\n    /* COMMENT_0 */\n    if (!VAR_1) {\n        tsk_error_reset();\n        tsk_error_set_errno(VAR_13);\n        tsk_error_set_errstr(\"mft_lookup: null mft buffer\");\n        return VAR_14;\n    }\n\n    if (VAR_2 < VAR_8->first_inum) {\n        tsk_error_reset();\n        tsk_error_set_errno(VAR_13);\n        tsk_error_set_errstr(\"mft_lookup: inode number is too small (%\"\n            VAR_15 \")\", VAR_2);\n        return VAR_14;\n    }\n\n    /* COMMENT_1 */\n                                                                        \n                                   \n    if (VAR_2 > VAR_8->last_inum - 1) {\n        tsk_error_reset();\n        tsk_error_set_errno(VAR_13);\n        tsk_error_set_errstr(\"mft_lookup: inode number is too large (%\"\n            VAR_15 \")\", VAR_2);\n        return VAR_14;\n    }\n\n\n    if (VAR_16)\n        tsk_fprintf(VAR_17,\n            \"ntfs_dinode_lookup: Processing MFT %\" VAR_15 \"\\n\",\n            VAR_2);\n\n    /* COMMENT_4 */\n                                                                        \n                                                                    \n                                                         \n       \n    if (!VAR_0->mft_data) {\n\n        /* COMMENT_9 */\n                                                                        \n                    \n           \n        if (VAR_2 > VAR_18) {\n            tsk_error_reset();\n            tsk_error_set_errno(VAR_13);\n            tsk_error_set_errstr\n                (\"Error trying to load a high MFT entry when the MFT itself has not been loaded (%\"\n                VAR_15 \")\", VAR_2);\n            return VAR_14;\n        }\n\n        VAR_3 = VAR_0->root_mft_addr + VAR_2 * VAR_0->mft_rsize_b;\n        VAR_4 = 0;\n    }\n    else {\n        /* COMMENT_13 */\n                                                                   \n          \n                                   \n           \n\n        /* COMMENT_18 */\n        VAR_3 = VAR_4 = 0;\n\n        /* COMMENT_19 */\n        VAR_5 = VAR_2 * VAR_0->mft_rsize_b;\n\n        /* COMMENT_20 */\n          \n                                                             \n                                         \n           \n        for (VAR_9 = VAR_0->mft_data->nrd.run;\n            VAR_9 != NULL; VAR_9 = VAR_9->next) {\n\n            /* COMMENT_25 */\n            if ((VAR_5 < 0) || (VAR_9->len >= (VAR_19)(VAR_20 / VAR_0->csize_b))){\n                tsk_error_reset();\n                tsk_error_set_errno(VAR_21);\n                tsk_error_set_errstr\n                (\"ntfs_dinode_lookup: Overflow when calculating run length\");\n                return VAR_22;\n            }\n\n            /* COMMENT_26 */\n            TSK_OFF_T VAR_23 = VAR_9->len * VAR_0->csize_b;\n\n            /* COMMENT_27 */\n            if (VAR_5 < VAR_23) {\n\n                if (VAR_16)\n                    tsk_fprintf(VAR_17,\n                        \"ntfs_dinode_lookup: Found in offset: %\"\n                        VAR_24 \"  size: %\" VAR_24 \" at offset: %\"\n\t\t\t\t\t\tVAR_25 \"\\n\", VAR_9->addr, VAR_9->len,\n                        VAR_5);\n\n                /* COMMENT_28 */\n                                                                     \n                                                                      \n                   \n                if (VAR_23 < VAR_5 + VAR_0->mft_rsize_b) {\n\n                    if (VAR_16)\n                        tsk_fprintf(VAR_17,\n                            \"ntfs_dinode_lookup: Entry crosses run border\\n\");\n\n                    if (VAR_9->next == NULL) {\n                        tsk_error_reset();\n                        tsk_error_set_errno(VAR_21);\n                        tsk_error_set_errstr\n                            (\"mft_lookup: MFT entry crosses a cluster and there are no more clusters!\");\n                        return VAR_22;\n                    }\n\n                    /* COMMENT_32 */\n                    VAR_4 = VAR_9->next->addr * VAR_0->csize_b;\n                    /* COMMENT_33 */\n                    VAR_6 = (size_t) (VAR_23 - VAR_5);\n                }\n\n                /* COMMENT_34 */\n                VAR_3 = VAR_9->addr * VAR_0->csize_b + VAR_5;\n                if (VAR_16)\n                    tsk_fprintf(VAR_17,\n                        \"ntfs_dinode_lookup: Entry address at: %\"\n\t\t\t\t\t\tVAR_25 \"\\n\", VAR_3);\n                break;\n            }\n\n            /* COMMENT_35 */\n            VAR_5 -= VAR_23;\n        }\n\n        /* COMMENT_36 */\n        if (!VAR_3) {\n            tsk_error_reset();\n            tsk_error_set_errno(VAR_26);\n            tsk_error_set_errstr(\"mft_lookup: Error finding MFT entry %\"\n                VAR_15 \" in $MFT\", VAR_2);\n            return VAR_14;\n        }\n    }\n\n\n    /* COMMENT_37 */\n    if (VAR_4) {\n        ssize_t VAR_27;\n        /* COMMENT_38 */\n        VAR_27 = tsk_fs_read(&VAR_0->fs_info, VAR_3, VAR_1, VAR_6);\n        if (VAR_27 != (ssize_t)VAR_6) {\n            if (VAR_27 >= 0) {\n                tsk_error_reset();\n                tsk_error_set_errno(VAR_28);\n            }\n            tsk_error_set_errstr2\n                (\"ntfs_dinode_lookup: Error reading MFT Entry (part 1) at %\"\n\t\t\t\t\tVAR_25, VAR_3);\n            return VAR_14;\n        }\n\n        /* COMMENT_39 */\n        VAR_27 = tsk_fs_read\n            (&VAR_0->fs_info, VAR_4,\n            (char *) ((uintptr_t) VAR_1 + (uintptr_t) VAR_6),\n            VAR_0->mft_rsize_b - VAR_6);\n        if (VAR_27 != (ssize_t)(VAR_0->mft_rsize_b - VAR_6)) {\n            if (VAR_27 >= 0) {\n                tsk_error_reset();\n                tsk_error_set_errno(VAR_28);\n            }\n            tsk_error_set_errstr2\n                (\"ntfs_dinode_lookup: Error reading MFT Entry (part 2) at %\"\n\t\t\t\t\tVAR_25, VAR_4);\n            return VAR_14;\n        }\n    }\n    else {\n        ssize_t VAR_27;\n        /* COMMENT_40 */\n        VAR_27 =\n            tsk_fs_read(&VAR_0->fs_info, VAR_3, VAR_1,\n            VAR_0->mft_rsize_b);\n        if (VAR_27 != VAR_0->mft_rsize_b) {\n            if (VAR_27 >= 0) {\n                tsk_error_reset();\n                tsk_error_set_errno(VAR_28);\n            }\n            tsk_error_set_errstr2\n                (\"ntfs_dinode_lookup: Error reading MFT Entry at %\"\n\t\t\t\t\tVAR_25, VAR_3);\n            return VAR_14;\n        }\n    }\n\n    /* COMMENT_41 */\n#if 0\n    /* COMMENT_42 */\n                                                                       \n                                                                        \n                                                                        \n                      \n         \n    if ((tsk_getu32(VAR_8->endian, VAR_12->magic) != VAR_29)\n        && (tsk_getu32(VAR_8->endian, VAR_12->magic) != VAR_30)\n        && (tsk_getu32(VAR_8->endian, VAR_12->magic) != VAR_31)) {\n        tsk_error_set_errno(VAR_21);\n        tsk_error_set_errstr(\"entry %d has an invalid MFT magic: %x\",\n            VAR_32, tsk_getu32(VAR_8->endian, VAR_12->magic));\n        return 1;\n    }\n#endif\n    /* COMMENT_48 */\n                                                                 \n                                                              \n                                                                      \n      \n                                                                    \n                                                \n       \n    /* COMMENT_56 */\n    VAR_12 = (ntfs_mft *) VAR_1;\n    if ((tsk_getu16(VAR_8->endian, VAR_12->upd_cnt) > 0) &&\n        (((uint32_t) (tsk_getu16(VAR_8->endian,\n                        VAR_12->upd_cnt) - 1) * VAR_33) >\n            VAR_0->mft_rsize_b)) {\n        tsk_error_reset();\n        tsk_error_set_errno(VAR_21);\n        tsk_error_set_errstr\n            (\"dinode_lookup: More Update Sequence Entries than MFT size\");\n        return VAR_22;\n    }\n    if (tsk_getu16(VAR_8->endian, VAR_12->upd_off) + sizeof(ntfs_upd) > VAR_0->mft_rsize_b) {\n        tsk_error_reset();\n        tsk_error_set_errno(VAR_21);\n        tsk_error_set_errstr\n            (\"dinode_lookup: Update sequence would read past MFT size\");\n        return VAR_22;\n    }\n\n    /* COMMENT_57 */\n    VAR_10 =\n        (ntfs_upd *) ((uintptr_t) VAR_1 + tsk_getu16(VAR_8->endian,\n            VAR_12->upd_off));\n    /* COMMENT_58 */\n    VAR_11 = tsk_getu16(VAR_8->endian, VAR_10->upd_val);\n    /* COMMENT_59 */\n    for (VAR_7 = 1; VAR_7 < tsk_getu16(VAR_8->endian, VAR_12->upd_cnt); VAR_7++) {\n        uint8_t *VAR_34, *VAR_35;\n        /* COMMENT_60 */\n        size_t VAR_5 = VAR_7 * VAR_33 - 2;\n\n        /* COMMENT_61 */\n        if (VAR_5 + 2 > VAR_0->mft_rsize_b) {\n            tsk_error_reset();\n            tsk_error_set_errno(VAR_21);\n            tsk_error_set_errstr\n            (\"dinode_lookup: Ran out of data while parsing update sequence values\");\n            return VAR_22;\n        }\n\n        /* COMMENT_62 */\n        uint16_t VAR_36 =\n            tsk_getu16(VAR_8->endian, (uintptr_t) VAR_1 + VAR_5);\n        if (VAR_36 != VAR_11) {\n            /* COMMENT_63 */\n            uint16_t VAR_37 =\n                tsk_getu16(VAR_8->endian, &VAR_10->upd_seq + (VAR_7 - 1) * 2);\n            tsk_error_reset();\n            tsk_error_set_errno(VAR_38);\n\n            tsk_error_set_errstr\n                (\"Incorrect update sequence value in MFT entry\\nSignature Value: 0x%\"\n                VAR_39 \" Actual Value: 0x%\" VAR_39\n                \" Replacement Value: 0x%\" VAR_39\n                \"\\nThis is typically because of a corrupted entry\",\n                VAR_11, VAR_36, VAR_37);\n            return VAR_22;\n        }\n\n        VAR_34 = &VAR_10->upd_seq + (VAR_7 - 1) * 2;\n        VAR_35 = (uint8_t *) ((uintptr_t) VAR_1 + VAR_5);\n        /* COMMENT_64 */\n                           \n                              \n                                                            \n                                                \n                                                                  \n                     \n           \n        *VAR_35++ = *VAR_34++;\n        *VAR_35 = *VAR_34;\n    }\n\n    return VAR_40;\n}",
  "func_graph_path_before": "sleuthkit/0c7d5e7333aeb61dace51750b56fcaad55a6359b/ntfs.c/vul/before/0.json",
  "func": "TSK_RETVAL_ENUM\nntfs_dinode_lookup(NTFS_INFO * a_ntfs, char *a_buf, TSK_INUM_T a_mftnum)\n{\n    TSK_OFF_T mftaddr_b, mftaddr2_b, offset;\n    size_t mftaddr_len = 0;\n    int i;\n    TSK_FS_INFO *fs = (TSK_FS_INFO *) & a_ntfs->fs_info;\n    TSK_FS_ATTR_RUN *data_run;\n    ntfs_upd *upd;\n    uint16_t sig_seq;\n    ntfs_mft *mft;\n\n\n    /* sanity checks */\n    if (!a_buf) {\n        tsk_error_reset();\n        tsk_error_set_errno(TSK_ERR_FS_ARG);\n        tsk_error_set_errstr(\"mft_lookup: null mft buffer\");\n        return TSK_ERR;\n    }\n\n    if (a_mftnum < fs->first_inum) {\n        tsk_error_reset();\n        tsk_error_set_errno(TSK_ERR_FS_ARG);\n        tsk_error_set_errstr(\"mft_lookup: inode number is too small (%\"\n            PRIuINUM \")\", a_mftnum);\n        return TSK_ERR;\n    }\n\n    /* Because this code reads teh actual MFT, we need to make sure we\n     * decrement the last_inum because the last value is a special value\n     * for the ORPHANS directory */\n    if (a_mftnum > fs->last_inum - 1) {\n        tsk_error_reset();\n        tsk_error_set_errno(TSK_ERR_FS_ARG);\n        tsk_error_set_errstr(\"mft_lookup: inode number is too large (%\"\n            PRIuINUM \")\", a_mftnum);\n        return TSK_ERR;\n    }\n\n\n    if (tsk_verbose)\n        tsk_fprintf(stderr,\n            \"ntfs_dinode_lookup: Processing MFT %\" PRIuINUM \"\\n\",\n            a_mftnum);\n\n    /* If mft_data (the cached $Data attribute of $MFT) is not there yet,\n     * then we have not started to load $MFT yet.  In that case, we will\n     * 'cheat' and calculate where it goes.  This should only be for\n     * $MFT itself, in which case the calculation is easy\n     */\n    if (!a_ntfs->mft_data) {\n\n        /* This is just a random check with the assumption being that\n         * we don't want to just do a guess calculation for a very large\n         * MFT entry\n         */\n        if (a_mftnum > NTFS_LAST_DEFAULT_INO) {\n            tsk_error_reset();\n            tsk_error_set_errno(TSK_ERR_FS_ARG);\n            tsk_error_set_errstr\n                (\"Error trying to load a high MFT entry when the MFT itself has not been loaded (%\"\n                PRIuINUM \")\", a_mftnum);\n            return TSK_ERR;\n        }\n\n        mftaddr_b = a_ntfs->root_mft_addr + a_mftnum * a_ntfs->mft_rsize_b;\n        mftaddr2_b = 0;\n    }\n    else {\n        /* The MFT may not be in consecutive clusters, so we need to use its\n         * data attribute run list to find out what address to read\n         *\n         * This is why we cached it\n         */\n\n        // will be set to the address of the MFT entry\n        mftaddr_b = mftaddr2_b = 0;\n\n        /* The byte offset within the $Data stream */\n        offset = a_mftnum * a_ntfs->mft_rsize_b;\n\n        /* NOTE: data_run values are in clusters\n         *\n         * cycle through the runs in $Data and identify which\n         * has the MFT entry that we want\n         */\n        for (data_run = a_ntfs->mft_data->nrd.run;\n            data_run != NULL; data_run = data_run->next) {\n\n            /* Test for possible overflows / error conditions */\n            if ((offset < 0) || (data_run->len >= (TSK_DADDR_T)(LLONG_MAX / a_ntfs->csize_b))){\n                tsk_error_reset();\n                tsk_error_set_errno(TSK_ERR_FS_INODE_COR);\n                tsk_error_set_errstr\n                (\"ntfs_dinode_lookup: Overflow when calculating run length\");\n                return TSK_COR;\n            }\n\n            /* The length of this specific run */\n            TSK_OFF_T run_len = data_run->len * a_ntfs->csize_b;\n\n            /* Is our MFT entry is in this run somewhere ? */\n            if (offset < run_len) {\n\n                if (tsk_verbose)\n                    tsk_fprintf(stderr,\n                        \"ntfs_dinode_lookup: Found in offset: %\"\n                        PRIuDADDR \"  size: %\" PRIuDADDR \" at offset: %\"\n\t\t\t\t\t\tPRIdOFF \"\\n\", data_run->addr, data_run->len,\n                        offset);\n\n                /* special case where the MFT entry crosses\n                 * a run (only happens when cluster size is 512-bytes\n                 * and there are an odd number of clusters in the run)\n                 */\n                if (run_len < offset + a_ntfs->mft_rsize_b) {\n\n                    if (tsk_verbose)\n                        tsk_fprintf(stderr,\n                            \"ntfs_dinode_lookup: Entry crosses run border\\n\");\n\n                    if (data_run->next == NULL) {\n                        tsk_error_reset();\n                        tsk_error_set_errno(TSK_ERR_FS_INODE_COR);\n                        tsk_error_set_errstr\n                            (\"mft_lookup: MFT entry crosses a cluster and there are no more clusters!\");\n                        return TSK_COR;\n                    }\n\n                    /* Assign address where the remainder of the entry is */\n                    mftaddr2_b = data_run->next->addr * a_ntfs->csize_b;\n                    /* this should always be 512, but just in case */\n                    mftaddr_len = (size_t) (run_len - offset);\n                }\n\n                /* Assign address of where the MFT entry starts */\n                mftaddr_b = data_run->addr * a_ntfs->csize_b + offset;\n                if (tsk_verbose)\n                    tsk_fprintf(stderr,\n                        \"ntfs_dinode_lookup: Entry address at: %\"\n\t\t\t\t\t\tPRIdOFF \"\\n\", mftaddr_b);\n                break;\n            }\n\n            /* decrement the offset we are looking for */\n            offset -= run_len;\n        }\n\n        /* Did we find it? */\n        if (!mftaddr_b) {\n            tsk_error_reset();\n            tsk_error_set_errno(TSK_ERR_FS_INODE_NUM);\n            tsk_error_set_errstr(\"mft_lookup: Error finding MFT entry %\"\n                PRIuINUM \" in $MFT\", a_mftnum);\n            return TSK_ERR;\n        }\n    }\n\n\n    /* can we do just one read or do we need multiple? */\n    if (mftaddr2_b) {\n        ssize_t cnt;\n        /* read the first part into mft */\n        cnt = tsk_fs_read(&a_ntfs->fs_info, mftaddr_b, a_buf, mftaddr_len);\n        if (cnt != (ssize_t)mftaddr_len) {\n            if (cnt >= 0) {\n                tsk_error_reset();\n                tsk_error_set_errno(TSK_ERR_FS_READ);\n            }\n            tsk_error_set_errstr2\n                (\"ntfs_dinode_lookup: Error reading MFT Entry (part 1) at %\"\n\t\t\t\t\tPRIdOFF, mftaddr_b);\n            return TSK_ERR;\n        }\n\n        /* read the second part into mft */\n        cnt = tsk_fs_read\n            (&a_ntfs->fs_info, mftaddr2_b,\n            (char *) ((uintptr_t) a_buf + (uintptr_t) mftaddr_len),\n            a_ntfs->mft_rsize_b - mftaddr_len);\n        if (cnt != (ssize_t)(a_ntfs->mft_rsize_b - mftaddr_len)) {\n            if (cnt >= 0) {\n                tsk_error_reset();\n                tsk_error_set_errno(TSK_ERR_FS_READ);\n            }\n            tsk_error_set_errstr2\n                (\"ntfs_dinode_lookup: Error reading MFT Entry (part 2) at %\"\n\t\t\t\t\tPRIdOFF, mftaddr2_b);\n            return TSK_ERR;\n        }\n    }\n    else {\n        ssize_t cnt;\n        /* read the raw entry into mft */\n        cnt =\n            tsk_fs_read(&a_ntfs->fs_info, mftaddr_b, a_buf,\n            a_ntfs->mft_rsize_b);\n        if (cnt != a_ntfs->mft_rsize_b) {\n            if (cnt >= 0) {\n                tsk_error_reset();\n                tsk_error_set_errno(TSK_ERR_FS_READ);\n            }\n            tsk_error_set_errstr2\n                (\"ntfs_dinode_lookup: Error reading MFT Entry at %\"\n\t\t\t\t\tPRIdOFF, mftaddr_b);\n            return TSK_ERR;\n        }\n    }\n\n    /* Sanity Check */\n#if 0\n    /* This is no longer applied because it caused too many problems\n     * with images that had 0 and 1 etc. as values.  Testing shows that\n     * even Windows XP doesn't care if entries have an invalid entry, so\n     * this is no longer checked.  The update sequence check should find\n     * corrupt entries\n     * */\n    if ((tsk_getu32(fs->endian, mft->magic) != NTFS_MFT_MAGIC)\n        && (tsk_getu32(fs->endian, mft->magic) != NTFS_MFT_MAGIC_BAAD)\n        && (tsk_getu32(fs->endian, mft->magic) != NTFS_MFT_MAGIC_ZERO)) {\n        tsk_error_set_errno(TSK_ERR_FS_INODE_COR);\n        tsk_error_set_errstr(\"entry %d has an invalid MFT magic: %x\",\n            mftnum, tsk_getu32(fs->endian, mft->magic));\n        return 1;\n    }\n#endif\n    /* The MFT entries have error and integrity checks in them\n     * called update sequences.  They must be checked and removed\n     * so that later functions can process the data as normal.\n     * They are located in the last 2 bytes of each 512-bytes of data.\n     *\n     * We first verify that the the 2-byte value is a give value and\n     * then replace it with what should be there\n     */\n    /* sanity check so we don't run over in the next loop */\n    mft = (ntfs_mft *) a_buf;\n    if ((tsk_getu16(fs->endian, mft->upd_cnt) > 0) &&\n        (((uint32_t) (tsk_getu16(fs->endian,\n                        mft->upd_cnt) - 1) * NTFS_UPDATE_SEQ_STRIDE) >\n            a_ntfs->mft_rsize_b)) {\n        tsk_error_reset();\n        tsk_error_set_errno(TSK_ERR_FS_INODE_COR);\n        tsk_error_set_errstr\n            (\"dinode_lookup: More Update Sequence Entries than MFT size\");\n        return TSK_COR;\n    }\n    if (tsk_getu16(fs->endian, mft->upd_off) + \n            sizeof(ntfs_upd) + \n            2*(tsk_getu16(fs->endian, mft->upd_cnt) - 1) > a_ntfs->mft_rsize_b) {\n        tsk_error_reset();\n        tsk_error_set_errno(TSK_ERR_FS_INODE_COR);\n        tsk_error_set_errstr\n            (\"dinode_lookup: Update sequence would read past MFT size\");\n        return TSK_COR;\n    }\n\n    /* Apply the update sequence structure template */\n    upd =\n        (ntfs_upd *) ((uintptr_t) a_buf + tsk_getu16(fs->endian,\n            mft->upd_off));\n    /* Get the sequence value that each 16-bit value should be */\n    sig_seq = tsk_getu16(fs->endian, upd->upd_val);\n    /* cycle through each sector */\n    for (i = 1; i < tsk_getu16(fs->endian, mft->upd_cnt); i++) {\n        uint8_t *new_val, *old_val;\n        /* The offset into the buffer of the value to analyze */\n        size_t offset = i * NTFS_UPDATE_SEQ_STRIDE - 2;\n\n        /* Check that there is room in the buffer to read the current sequence value */\n        if (offset + 2 > a_ntfs->mft_rsize_b) {\n            tsk_error_reset();\n            tsk_error_set_errno(TSK_ERR_FS_INODE_COR);\n            tsk_error_set_errstr\n            (\"dinode_lookup: Ran out of data while parsing update sequence values\");\n            return TSK_COR;\n        }\n\n        /* get the current sequence value */\n        uint16_t cur_seq =\n            tsk_getu16(fs->endian, (uintptr_t) a_buf + offset);\n        if (cur_seq != sig_seq) {\n            /* get the replacement value */\n            uint16_t cur_repl =\n                tsk_getu16(fs->endian, &upd->upd_seq + (i - 1) * 2);\n            tsk_error_reset();\n            tsk_error_set_errno(TSK_ERR_FS_GENFS);\n\n            tsk_error_set_errstr\n                (\"Incorrect update sequence value in MFT entry\\nSignature Value: 0x%\"\n                PRIx16 \" Actual Value: 0x%\" PRIx16\n                \" Replacement Value: 0x%\" PRIx16\n                \"\\nThis is typically because of a corrupted entry\",\n                sig_seq, cur_seq, cur_repl);\n            return TSK_COR;\n        }\n\n        new_val = &upd->upd_seq + (i - 1) * 2;\n        old_val = (uint8_t *) ((uintptr_t) a_buf + offset);\n        /*\n           if (tsk_verbose)\n           tsk_fprintf(stderr,\n           \"ntfs_dinode_lookup: upd_seq %i   Replacing: %.4\"\n           PRIx16 \"   With: %.4\" PRIx16 \"\\n\", i,\n           tsk_getu16(fs->endian, old_val), tsk_getu16(fs->endian,\n           new_val));\n         */\n        *old_val++ = *new_val++;\n        *old_val = *new_val;\n    }\n\n    return TSK_OK;\n}",
  "abstract_func": "TSK_RETVAL_ENUM\nntfs_dinode_lookup(NTFS_INFO * VAR_0, char *VAR_1, TSK_INUM_T VAR_2)\n{\n    TSK_OFF_T VAR_3, VAR_4, VAR_5;\n    size_t VAR_6 = 0;\n    int VAR_7;\n    TSK_FS_INFO *VAR_8 = (TSK_FS_INFO *) & VAR_0->fs_info;\n    TSK_FS_ATTR_RUN *VAR_9;\n    ntfs_upd *VAR_10;\n    uint16_t VAR_11;\n    ntfs_mft *VAR_12;\n\n\n    /* COMMENT_0 */\n    if (!VAR_1) {\n        tsk_error_reset();\n        tsk_error_set_errno(VAR_13);\n        tsk_error_set_errstr(\"mft_lookup: null mft buffer\");\n        return VAR_14;\n    }\n\n    if (VAR_2 < VAR_8->first_inum) {\n        tsk_error_reset();\n        tsk_error_set_errno(VAR_13);\n        tsk_error_set_errstr(\"mft_lookup: inode number is too small (%\"\n            VAR_15 \")\", VAR_2);\n        return VAR_14;\n    }\n\n    /* COMMENT_1 */\n                                                                        \n                                   \n    if (VAR_2 > VAR_8->last_inum - 1) {\n        tsk_error_reset();\n        tsk_error_set_errno(VAR_13);\n        tsk_error_set_errstr(\"mft_lookup: inode number is too large (%\"\n            VAR_15 \")\", VAR_2);\n        return VAR_14;\n    }\n\n\n    if (VAR_16)\n        tsk_fprintf(VAR_17,\n            \"ntfs_dinode_lookup: Processing MFT %\" VAR_15 \"\\n\",\n            VAR_2);\n\n    /* COMMENT_4 */\n                                                                        \n                                                                    \n                                                         \n       \n    if (!VAR_0->mft_data) {\n\n        /* COMMENT_9 */\n                                                                        \n                    \n           \n        if (VAR_2 > VAR_18) {\n            tsk_error_reset();\n            tsk_error_set_errno(VAR_13);\n            tsk_error_set_errstr\n                (\"Error trying to load a high MFT entry when the MFT itself has not been loaded (%\"\n                VAR_15 \")\", VAR_2);\n            return VAR_14;\n        }\n\n        VAR_3 = VAR_0->root_mft_addr + VAR_2 * VAR_0->mft_rsize_b;\n        VAR_4 = 0;\n    }\n    else {\n        /* COMMENT_13 */\n                                                                   \n          \n                                   \n           \n\n        /* COMMENT_18 */\n        VAR_3 = VAR_4 = 0;\n\n        /* COMMENT_19 */\n        VAR_5 = VAR_2 * VAR_0->mft_rsize_b;\n\n        /* COMMENT_20 */\n          \n                                                             \n                                         \n           \n        for (VAR_9 = VAR_0->mft_data->nrd.run;\n            VAR_9 != NULL; VAR_9 = VAR_9->next) {\n\n            /* COMMENT_25 */\n            if ((VAR_5 < 0) || (VAR_9->len >= (VAR_19)(VAR_20 / VAR_0->csize_b))){\n                tsk_error_reset();\n                tsk_error_set_errno(VAR_21);\n                tsk_error_set_errstr\n                (\"ntfs_dinode_lookup: Overflow when calculating run length\");\n                return VAR_22;\n            }\n\n            /* COMMENT_26 */\n            TSK_OFF_T VAR_23 = VAR_9->len * VAR_0->csize_b;\n\n            /* COMMENT_27 */\n            if (VAR_5 < VAR_23) {\n\n                if (VAR_16)\n                    tsk_fprintf(VAR_17,\n                        \"ntfs_dinode_lookup: Found in offset: %\"\n                        VAR_24 \"  size: %\" VAR_24 \" at offset: %\"\n\t\t\t\t\t\tVAR_25 \"\\n\", VAR_9->addr, VAR_9->len,\n                        VAR_5);\n\n                /* COMMENT_28 */\n                                                                     \n                                                                      \n                   \n                if (VAR_23 < VAR_5 + VAR_0->mft_rsize_b) {\n\n                    if (VAR_16)\n                        tsk_fprintf(VAR_17,\n                            \"ntfs_dinode_lookup: Entry crosses run border\\n\");\n\n                    if (VAR_9->next == NULL) {\n                        tsk_error_reset();\n                        tsk_error_set_errno(VAR_21);\n                        tsk_error_set_errstr\n                            (\"mft_lookup: MFT entry crosses a cluster and there are no more clusters!\");\n                        return VAR_22;\n                    }\n\n                    /* COMMENT_32 */\n                    VAR_4 = VAR_9->next->addr * VAR_0->csize_b;\n                    /* COMMENT_33 */\n                    VAR_6 = (size_t) (VAR_23 - VAR_5);\n                }\n\n                /* COMMENT_34 */\n                VAR_3 = VAR_9->addr * VAR_0->csize_b + VAR_5;\n                if (VAR_16)\n                    tsk_fprintf(VAR_17,\n                        \"ntfs_dinode_lookup: Entry address at: %\"\n\t\t\t\t\t\tVAR_25 \"\\n\", VAR_3);\n                break;\n            }\n\n            /* COMMENT_35 */\n            VAR_5 -= VAR_23;\n        }\n\n        /* COMMENT_36 */\n        if (!VAR_3) {\n            tsk_error_reset();\n            tsk_error_set_errno(VAR_26);\n            tsk_error_set_errstr(\"mft_lookup: Error finding MFT entry %\"\n                VAR_15 \" in $MFT\", VAR_2);\n            return VAR_14;\n        }\n    }\n\n\n    /* COMMENT_37 */\n    if (VAR_4) {\n        ssize_t VAR_27;\n        /* COMMENT_38 */\n        VAR_27 = tsk_fs_read(&VAR_0->fs_info, VAR_3, VAR_1, VAR_6);\n        if (VAR_27 != (ssize_t)VAR_6) {\n            if (VAR_27 >= 0) {\n                tsk_error_reset();\n                tsk_error_set_errno(VAR_28);\n            }\n            tsk_error_set_errstr2\n                (\"ntfs_dinode_lookup: Error reading MFT Entry (part 1) at %\"\n\t\t\t\t\tVAR_25, VAR_3);\n            return VAR_14;\n        }\n\n        /* COMMENT_39 */\n        VAR_27 = tsk_fs_read\n            (&VAR_0->fs_info, VAR_4,\n            (char *) ((uintptr_t) VAR_1 + (uintptr_t) VAR_6),\n            VAR_0->mft_rsize_b - VAR_6);\n        if (VAR_27 != (ssize_t)(VAR_0->mft_rsize_b - VAR_6)) {\n            if (VAR_27 >= 0) {\n                tsk_error_reset();\n                tsk_error_set_errno(VAR_28);\n            }\n            tsk_error_set_errstr2\n                (\"ntfs_dinode_lookup: Error reading MFT Entry (part 2) at %\"\n\t\t\t\t\tVAR_25, VAR_4);\n            return VAR_14;\n        }\n    }\n    else {\n        ssize_t VAR_27;\n        /* COMMENT_40 */\n        VAR_27 =\n            tsk_fs_read(&VAR_0->fs_info, VAR_3, VAR_1,\n            VAR_0->mft_rsize_b);\n        if (VAR_27 != VAR_0->mft_rsize_b) {\n            if (VAR_27 >= 0) {\n                tsk_error_reset();\n                tsk_error_set_errno(VAR_28);\n            }\n            tsk_error_set_errstr2\n                (\"ntfs_dinode_lookup: Error reading MFT Entry at %\"\n\t\t\t\t\tVAR_25, VAR_3);\n            return VAR_14;\n        }\n    }\n\n    /* COMMENT_41 */\n#if 0\n    /* COMMENT_42 */\n                                                                       \n                                                                        \n                                                                        \n                      \n         \n    if ((tsk_getu32(VAR_8->endian, VAR_12->magic) != VAR_29)\n        && (tsk_getu32(VAR_8->endian, VAR_12->magic) != VAR_30)\n        && (tsk_getu32(VAR_8->endian, VAR_12->magic) != VAR_31)) {\n        tsk_error_set_errno(VAR_21);\n        tsk_error_set_errstr(\"entry %d has an invalid MFT magic: %x\",\n            VAR_32, tsk_getu32(VAR_8->endian, VAR_12->magic));\n        return 1;\n    }\n#endif\n    /* COMMENT_48 */\n                                                                 \n                                                              \n                                                                      \n      \n                                                                    \n                                                \n       \n    /* COMMENT_56 */\n    VAR_12 = (ntfs_mft *) VAR_1;\n    if ((tsk_getu16(VAR_8->endian, VAR_12->upd_cnt) > 0) &&\n        (((uint32_t) (tsk_getu16(VAR_8->endian,\n                        VAR_12->upd_cnt) - 1) * VAR_33) >\n            VAR_0->mft_rsize_b)) {\n        tsk_error_reset();\n        tsk_error_set_errno(VAR_21);\n        tsk_error_set_errstr\n            (\"dinode_lookup: More Update Sequence Entries than MFT size\");\n        return VAR_22;\n    }\n    if (tsk_getu16(VAR_8->endian, VAR_12->upd_off) + \n            sizeof(ntfs_upd) + \n            2*(tsk_getu16(VAR_8->endian, VAR_12->upd_cnt) - 1) > VAR_0->mft_rsize_b) {\n        tsk_error_reset();\n        tsk_error_set_errno(VAR_21);\n        tsk_error_set_errstr\n            (\"dinode_lookup: Update sequence would read past MFT size\");\n        return VAR_22;\n    }\n\n    /* COMMENT_57 */\n    VAR_10 =\n        (ntfs_upd *) ((uintptr_t) VAR_1 + tsk_getu16(VAR_8->endian,\n            VAR_12->upd_off));\n    /* COMMENT_58 */\n    VAR_11 = tsk_getu16(VAR_8->endian, VAR_10->upd_val);\n    /* COMMENT_59 */\n    for (VAR_7 = 1; VAR_7 < tsk_getu16(VAR_8->endian, VAR_12->upd_cnt); VAR_7++) {\n        uint8_t *VAR_34, *VAR_35;\n        /* COMMENT_60 */\n        size_t VAR_5 = VAR_7 * VAR_33 - 2;\n\n        /* COMMENT_61 */\n        if (VAR_5 + 2 > VAR_0->mft_rsize_b) {\n            tsk_error_reset();\n            tsk_error_set_errno(VAR_21);\n            tsk_error_set_errstr\n            (\"dinode_lookup: Ran out of data while parsing update sequence values\");\n            return VAR_22;\n        }\n\n        /* COMMENT_62 */\n        uint16_t VAR_36 =\n            tsk_getu16(VAR_8->endian, (uintptr_t) VAR_1 + VAR_5);\n        if (VAR_36 != VAR_11) {\n            /* COMMENT_63 */\n            uint16_t VAR_37 =\n                tsk_getu16(VAR_8->endian, &VAR_10->upd_seq + (VAR_7 - 1) * 2);\n            tsk_error_reset();\n            tsk_error_set_errno(VAR_38);\n\n            tsk_error_set_errstr\n                (\"Incorrect update sequence value in MFT entry\\nSignature Value: 0x%\"\n                VAR_39 \" Actual Value: 0x%\" VAR_39\n                \" Replacement Value: 0x%\" VAR_39\n                \"\\nThis is typically because of a corrupted entry\",\n                VAR_11, VAR_36, VAR_37);\n            return VAR_22;\n        }\n\n        VAR_34 = &VAR_10->upd_seq + (VAR_7 - 1) * 2;\n        VAR_35 = (uint8_t *) ((uintptr_t) VAR_1 + VAR_5);\n        /* COMMENT_64 */\n                           \n                              \n                                                            \n                                                \n                                                                  \n                     \n           \n        *VAR_35++ = *VAR_34++;\n        *VAR_35 = *VAR_34;\n    }\n\n    return VAR_40;\n}",
  "func_graph_path": "sleuthkit/0c7d5e7333aeb61dace51750b56fcaad55a6359b/ntfs.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -245,7 +245,9 @@\n             (\"dinode_lookup: More Update Sequence Entries than MFT size\");\n         return TSK_COR;\n     }\n-    if (tsk_getu16(fs->endian, mft->upd_off) + sizeof(ntfs_upd) > a_ntfs->mft_rsize_b) {\n+    if (tsk_getu16(fs->endian, mft->upd_off) + \n+            sizeof(ntfs_upd) + \n+            2*(tsk_getu16(fs->endian, mft->upd_cnt) - 1) > a_ntfs->mft_rsize_b) {\n         tsk_error_reset();\n         tsk_error_set_errno(TSK_ERR_FS_INODE_COR);\n         tsk_error_set_errstr",
  "diff_line_info": {
    "deleted_lines": [
      "    if (tsk_getu16(fs->endian, mft->upd_off) + sizeof(ntfs_upd) > a_ntfs->mft_rsize_b) {"
    ],
    "added_lines": [
      "    if (tsk_getu16(fs->endian, mft->upd_off) + ",
      "            sizeof(ntfs_upd) + ",
      "            2*(tsk_getu16(fs->endian, mft->upd_cnt) - 1) > a_ntfs->mft_rsize_b) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/sleuthkit/sleuthkit/pull/1837",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/sleuthkit/sleuthkit/pull/1837: 403 Client Error: Forbidden for url: https://api.github.com/repos/sleuthkit/sleuthkit/pulls/1837",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.9  \n\nThe patch corrects a condition that could lead to incorrect array size calculations, potentially resulting in buffer overflows or incorrect data access. While not explicitly stated, the fix addresses a core logic issue that qualifies as a security vulnerability. The confidence is high due to the context of the code change."
}