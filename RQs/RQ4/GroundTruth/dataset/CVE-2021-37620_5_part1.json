{
  "cve_id": "CVE-2021-37620",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "Exiv2/exiv2",
  "commit_msg": "Safer std::vector indexing.",
  "commit_hash": "76e313745e813f80e8910aceb2210af3ad8cf897",
  "git_url": "https://github.com/Exiv2/exiv2/commit/76e313745e813f80e8910aceb2210af3ad8cf897",
  "file_path": "src/actions.cpp",
  "func_name": "renameFile",
  "func_before": "int renameFile(std::string& newPath, const struct tm* tm)\n    {\n        std::string path = newPath;\n        std::string format = Params::instance().format_;\n        Util::replace(format, \":basename:\",   Util::basename(path, true));\n        Util::replace(format, \":dirname:\",    Util::basename(Util::dirname(path)));\n        Util::replace(format, \":parentname:\", Util::basename(Util::dirname(Util::dirname(path))));\n\n        const size_t max = 1024;\n        char basename[max];\n        std::memset(basename, 0x0, max);\n        if (strftime(basename, max, format.c_str(), tm) == 0) {\n            std::cerr << _(\"Filename format yields empty filename for the file\") << \" \"\n                      << path << \"\\n\";\n            return 1;\n        }\n        newPath =   Util::dirname(path) + EXV_SEPARATOR_STR\n                  + basename + Util::suffix(path);\n        if (   Util::dirname(newPath)  == Util::dirname(path)\n            && Util::basename(newPath) == Util::basename(path)) {\n            if (Params::instance().verbose_) {\n                std::cout << _(\"This file already has the correct name\") << std::endl;\n            }\n            return -1;\n        }\n\n        bool go = true;\n        int seq = 1;\n        std::string s;\n        Params::FileExistsPolicy fileExistsPolicy\n            = Params::instance().fileExistsPolicy_;\n        while (go) {\n            if (Exiv2::fileExists(newPath)) {\n                switch (fileExistsPolicy) {\n                case Params::overwritePolicy:\n                    go = false;\n                    break;\n                case Params::renamePolicy:\n                    newPath = Util::dirname(path)\n                        + EXV_SEPARATOR_STR + basename\n                        + \"_\" + Exiv2::toString(seq++)\n                        + Util::suffix(path);\n                    break;\n                case Params::askPolicy:\n                    std::cout << Params::instance().progname()\n                              << \": \" << _(\"File\") << \" `\" << newPath\n                              << \"' \" << _(\"exists. [O]verwrite, [r]ename or [s]kip?\")\n                              << \" \";\n                    std::cin >> s;\n                    switch (s[0]) {\n                    case 'o':\n                    case 'O':\n                        go = false;\n                        break;\n                    case 'r':\n                    case 'R':\n                        fileExistsPolicy = Params::renamePolicy;\n                        newPath = Util::dirname(path)\n                            + EXV_SEPARATOR_STR + basename\n                            + \"_\" + Exiv2::toString(seq++)\n                            + Util::suffix(path);\n                        break;\n                    default: // skip\n                        return -1;\n                        break;\n                    }\n                }\n            }\n            else {\n                go = false;\n            }\n        }\n\n        if (Params::instance().verbose_) {\n            std::cout << _(\"Renaming file to\") << \" \" << newPath;\n            if (Params::instance().timestamp_) {\n                std::cout << \", \" << _(\"updating timestamp\");\n            }\n            std::cout << std::endl;\n        }\n\n        // Workaround for MinGW rename which does not overwrite existing files\n        remove(newPath.c_str());\n        if (std::rename(path.c_str(), newPath.c_str()) == -1) {\n            std::cerr << Params::instance().progname()\n                      << \": \" << _(\"Failed to rename\") << \" \"\n                      << path << \" \" << _(\"to\") << \" \" << newPath << \": \"\n                      << Exiv2::strError() << \"\\n\";\n            return 1;\n        }\n\n        return 0;\n    }",
  "abstract_func_before": "int renameFile(std::string& VAR_0, const struct tm* tm)\n    {\n        std::string VAR_1 = VAR_0;\n        std::string VAR_2 = Params::instance().format_;\n        Util::replace(VAR_2, \":basename:\",   Util::basename(VAR_1, true));\n        Util::replace(VAR_2, \":dirname:\",    Util::basename(Util::dirname(VAR_1)));\n        Util::replace(VAR_2, \":parentname:\", Util::basename(Util::dirname(Util::dirname(VAR_1))));\n\n        const size_t VAR_3 = 1024;\n        char VAR_4[VAR_3];\n        std::memset(VAR_4, 0x0, VAR_3);\n        if (strftime(VAR_4, VAR_3, VAR_2.c_str(), tm) == 0) {\n            std::cerr << _(\"Filename format yields empty filename for the file\") << \" \"\n                      << VAR_1 << \"\\n\";\n            return 1;\n        }\n        VAR_0 =   Util::dirname(VAR_1) + VAR_5\n                  + VAR_4 + Util::suffix(VAR_1);\n        if (   Util::dirname(VAR_0)  == Util::dirname(VAR_1)\n            && Util::basename(VAR_0) == Util::basename(VAR_1)) {\n            if (Params::instance().verbose_) {\n                std::cout << _(\"This file already has the correct name\") << std::endl;\n            }\n            return -1;\n        }\n\n        bool VAR_6 = true;\n        int VAR_7 = 1;\n        std::string VAR_8;\n        Params::FileExistsPolicy VAR_9\n            = Params::instance().fileExistsPolicy_;\n        while (VAR_6) {\n            if (Exiv2::fileExists(VAR_0)) {\n                switch (VAR_9) {\n                case Params::overwritePolicy:\n                    VAR_6 = false;\n                    break;\n                case Params::renamePolicy:\n                    VAR_0 = Util::dirname(VAR_1)\n                        + VAR_5 + VAR_4\n                        + \"_\" + Exiv2::toString(VAR_7++)\n                        + Util::suffix(VAR_1);\n                    break;\n                case Params::askPolicy:\n                    std::cout << Params::instance().progname()\n                              << \": \" << _(\"File\") << \" `\" << VAR_0\n                              << \"' \" << _(\"exists. [O]verwrite, [r]ename or [s]kip?\")\n                              << \" \";\n                    std::cin >> VAR_8;\n                    switch (VAR_8[0]) {\n                    case 'o':\n                    case 'O':\n                        VAR_6 = false;\n                        break;\n                    case 'r':\n                    case 'R':\n                        VAR_9 = Params::renamePolicy;\n                        VAR_0 = Util::dirname(VAR_1)\n                            + VAR_5 + VAR_4\n                            + \"_\" + Exiv2::toString(VAR_7++)\n                            + Util::suffix(VAR_1);\n                        break;\n                    default: /* COMMENT_0 */\n                        return -1;\n                        break;\n                    }\n                }\n            }\n            else {\n                VAR_6 = false;\n            }\n        }\n\n        if (Params::instance().verbose_) {\n            std::cout << _(\"Renaming file to\") << \" \" << VAR_0;\n            if (Params::instance().timestamp_) {\n                std::cout << \", \" << _(\"updating timestamp\");\n            }\n            std::cout << std::endl;\n        }\n\n        /* COMMENT_1 */\n        remove(VAR_0.c_str());\n        if (std::rename(VAR_1.c_str(), VAR_0.c_str()) == -1) {\n            std::cerr << Params::instance().progname()\n                      << \": \" << _(\"Failed to rename\") << \" \"\n                      << VAR_1 << \" \" << _(\"to\") << \" \" << VAR_0 << \": \"\n                      << Exiv2::strError() << \"\\n\";\n            return 1;\n        }\n\n        return 0;\n    }",
  "func_graph_path_before": "Exiv2/exiv2/76e313745e813f80e8910aceb2210af3ad8cf897/actions.cpp/vul/before/0.json",
  "func": "int renameFile(std::string& newPath, const struct tm* tm)\n    {\n        std::string path = newPath;\n        std::string format = Params::instance().format_;\n        Util::replace(format, \":basename:\",   Util::basename(path, true));\n        Util::replace(format, \":dirname:\",    Util::basename(Util::dirname(path)));\n        Util::replace(format, \":parentname:\", Util::basename(Util::dirname(Util::dirname(path))));\n\n        const size_t max = 1024;\n        char basename[max];\n        std::memset(basename, 0x0, max);\n        if (strftime(basename, max, format.c_str(), tm) == 0) {\n            std::cerr << _(\"Filename format yields empty filename for the file\") << \" \"\n                      << path << \"\\n\";\n            return 1;\n        }\n        newPath =   Util::dirname(path) + EXV_SEPARATOR_STR\n                  + basename + Util::suffix(path);\n        if (   Util::dirname(newPath)  == Util::dirname(path)\n            && Util::basename(newPath) == Util::basename(path)) {\n            if (Params::instance().verbose_) {\n                std::cout << _(\"This file already has the correct name\") << std::endl;\n            }\n            return -1;\n        }\n\n        bool go = true;\n        int seq = 1;\n        std::string s;\n        Params::FileExistsPolicy fileExistsPolicy\n            = Params::instance().fileExistsPolicy_;\n        while (go) {\n            if (Exiv2::fileExists(newPath)) {\n                switch (fileExistsPolicy) {\n                case Params::overwritePolicy:\n                    go = false;\n                    break;\n                case Params::renamePolicy:\n                    newPath = Util::dirname(path)\n                        + EXV_SEPARATOR_STR + basename\n                        + \"_\" + Exiv2::toString(seq++)\n                        + Util::suffix(path);\n                    break;\n                case Params::askPolicy:\n                    std::cout << Params::instance().progname()\n                              << \": \" << _(\"File\") << \" `\" << newPath\n                              << \"' \" << _(\"exists. [O]verwrite, [r]ename or [s]kip?\")\n                              << \" \";\n                    std::cin >> s;\n                    switch (s.at(0)) {\n                    case 'o':\n                    case 'O':\n                        go = false;\n                        break;\n                    case 'r':\n                    case 'R':\n                        fileExistsPolicy = Params::renamePolicy;\n                        newPath = Util::dirname(path)\n                            + EXV_SEPARATOR_STR + basename\n                            + \"_\" + Exiv2::toString(seq++)\n                            + Util::suffix(path);\n                        break;\n                    default: // skip\n                        return -1;\n                        break;\n                    }\n                }\n            }\n            else {\n                go = false;\n            }\n        }\n\n        if (Params::instance().verbose_) {\n            std::cout << _(\"Renaming file to\") << \" \" << newPath;\n            if (Params::instance().timestamp_) {\n                std::cout << \", \" << _(\"updating timestamp\");\n            }\n            std::cout << std::endl;\n        }\n\n        // Workaround for MinGW rename which does not overwrite existing files\n        remove(newPath.c_str());\n        if (std::rename(path.c_str(), newPath.c_str()) == -1) {\n            std::cerr << Params::instance().progname()\n                      << \": \" << _(\"Failed to rename\") << \" \"\n                      << path << \" \" << _(\"to\") << \" \" << newPath << \": \"\n                      << Exiv2::strError() << \"\\n\";\n            return 1;\n        }\n\n        return 0;\n    }",
  "abstract_func": "int renameFile(std::string& VAR_0, const struct tm* tm)\n    {\n        std::string VAR_1 = VAR_0;\n        std::string VAR_2 = Params::instance().format_;\n        Util::replace(VAR_2, \":basename:\",   Util::basename(VAR_1, true));\n        Util::replace(VAR_2, \":dirname:\",    Util::basename(Util::dirname(VAR_1)));\n        Util::replace(VAR_2, \":parentname:\", Util::basename(Util::dirname(Util::dirname(VAR_1))));\n\n        const size_t VAR_3 = 1024;\n        char VAR_4[VAR_3];\n        std::memset(VAR_4, 0x0, VAR_3);\n        if (strftime(VAR_4, VAR_3, VAR_2.c_str(), tm) == 0) {\n            std::cerr << _(\"Filename format yields empty filename for the file\") << \" \"\n                      << VAR_1 << \"\\n\";\n            return 1;\n        }\n        VAR_0 =   Util::dirname(VAR_1) + VAR_5\n                  + VAR_4 + Util::suffix(VAR_1);\n        if (   Util::dirname(VAR_0)  == Util::dirname(VAR_1)\n            && Util::basename(VAR_0) == Util::basename(VAR_1)) {\n            if (Params::instance().verbose_) {\n                std::cout << _(\"This file already has the correct name\") << std::endl;\n            }\n            return -1;\n        }\n\n        bool VAR_6 = true;\n        int VAR_7 = 1;\n        std::string VAR_8;\n        Params::FileExistsPolicy VAR_9\n            = Params::instance().fileExistsPolicy_;\n        while (VAR_6) {\n            if (Exiv2::fileExists(VAR_0)) {\n                switch (VAR_9) {\n                case Params::overwritePolicy:\n                    VAR_6 = false;\n                    break;\n                case Params::renamePolicy:\n                    VAR_0 = Util::dirname(VAR_1)\n                        + VAR_5 + VAR_4\n                        + \"_\" + Exiv2::toString(VAR_7++)\n                        + Util::suffix(VAR_1);\n                    break;\n                case Params::askPolicy:\n                    std::cout << Params::instance().progname()\n                              << \": \" << _(\"File\") << \" `\" << VAR_0\n                              << \"' \" << _(\"exists. [O]verwrite, [r]ename or [s]kip?\")\n                              << \" \";\n                    std::cin >> VAR_8;\n                    switch (VAR_8.at(0)) {\n                    case 'o':\n                    case 'O':\n                        VAR_6 = false;\n                        break;\n                    case 'r':\n                    case 'R':\n                        VAR_9 = Params::renamePolicy;\n                        VAR_0 = Util::dirname(VAR_1)\n                            + VAR_5 + VAR_4\n                            + \"_\" + Exiv2::toString(VAR_7++)\n                            + Util::suffix(VAR_1);\n                        break;\n                    default: /* COMMENT_0 */\n                        return -1;\n                        break;\n                    }\n                }\n            }\n            else {\n                VAR_6 = false;\n            }\n        }\n\n        if (Params::instance().verbose_) {\n            std::cout << _(\"Renaming file to\") << \" \" << VAR_0;\n            if (Params::instance().timestamp_) {\n                std::cout << \", \" << _(\"updating timestamp\");\n            }\n            std::cout << std::endl;\n        }\n\n        /* COMMENT_1 */\n        remove(VAR_0.c_str());\n        if (std::rename(VAR_1.c_str(), VAR_0.c_str()) == -1) {\n            std::cerr << Params::instance().progname()\n                      << \": \" << _(\"Failed to rename\") << \" \"\n                      << VAR_1 << \" \" << _(\"to\") << \" \" << VAR_0 << \": \"\n                      << Exiv2::strError() << \"\\n\";\n            return 1;\n        }\n\n        return 0;\n    }",
  "func_graph_path": "Exiv2/exiv2/76e313745e813f80e8910aceb2210af3ad8cf897/actions.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -47,7 +47,7 @@\n                               << \"' \" << _(\"exists. [O]verwrite, [r]ename or [s]kip?\")\n                               << \" \";\n                     std::cin >> s;\n-                    switch (s[0]) {\n+                    switch (s.at(0)) {\n                     case 'o':\n                     case 'O':\n                         go = false;",
  "diff_line_info": {
    "deleted_lines": [
      "                    switch (s[0]) {"
    ],
    "added_lines": [
      "                    switch (s.at(0)) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/sridharb1/exiv2/pull/4",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/sridharb1/exiv2/pull/4: 403 Client Error: Forbidden for url: https://api.github.com/repos/sridharb1/exiv2/pulls/4",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.8"
}