{
  "cve_id": "CVE-2019-16754",
  "cwe_ids": [
    "CWE-476"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "RIOT-OS/RIOT",
  "commit_msg": "asymcute: don't make the assumption that req->arg is non-NULL\n\nThis fixes a denial of service where an attacker would be able to cause\na NULL pointer dereference by sending a spoofed packet. This attack only\nrequires knowledge about pending message ids.",
  "commit_hash": "30e4823e946949befe74ef94bc48fe43958c28a6",
  "git_url": "https://github.com/RIOT-OS/RIOT/commit/30e4823e946949befe74ef94bc48fe43958c28a6",
  "file_path": "sys/net/application_layer/asymcute/asymcute.c",
  "func_name": "_on_regack",
  "func_before": "static void _on_regack(asymcute_con_t *con, const uint8_t *data, size_t len)\n{\n    mutex_lock(&con->lock);\n    asymcute_req_t *req = _req_preprocess(con, len, MINLEN_REGACK,\n                                          data, IDPOS_REGACK);\n    if (req == NULL) {\n        mutex_unlock(&con->lock);\n        return;\n    }\n\n    /* check return code */\n    unsigned ret = ASYMCUTE_REJECTED;\n    if (data[6] == MQTTSN_ACCEPTED) {\n        /* finish the registration by applying the topic id */\n        asymcute_topic_t *topic = (asymcute_topic_t *)req->arg;\n        topic->id = byteorder_bebuftohs(&data[2]);\n        topic->con = con;\n        ret = ASYMCUTE_REGISTERED;\n    }\n\n    /* finally notify the user and free the request */\n    mutex_unlock(&req->lock);\n    mutex_unlock(&con->lock);\n    con->user_cb(req, ret);\n}",
  "abstract_func_before": "static void _on_regack(asymcute_con_t *VAR_0, const uint8_t *VAR_1, size_t VAR_2)\n{\n    mutex_lock(&VAR_0->lock);\n    asymcute_req_t *VAR_3 = _req_preprocess(VAR_0, VAR_2, VAR_4,\n                                          VAR_1, VAR_5);\n    if (VAR_3 == NULL) {\n        mutex_unlock(&VAR_0->lock);\n        return;\n    }\n\n    /* COMMENT_0 */\n    unsigned VAR_6 = VAR_7;\n    if (VAR_1[6] == VAR_8) {\n        /* COMMENT_1 */\n        asymcute_topic_t *VAR_9 = (asymcute_topic_t *)VAR_3->arg;\n        VAR_9->id = byteorder_bebuftohs(&VAR_1[2]);\n        VAR_9->con = VAR_0;\n        VAR_6 = VAR_10;\n    }\n\n    /* COMMENT_2 */\n    mutex_unlock(&VAR_3->lock);\n    mutex_unlock(&VAR_0->lock);\n    VAR_0->user_cb(VAR_3, VAR_6);\n}",
  "func_graph_path_before": "RIOT-OS/RIOT/30e4823e946949befe74ef94bc48fe43958c28a6/asymcute.c/vul/before/3.json",
  "func": "static void _on_regack(asymcute_con_t *con, const uint8_t *data, size_t len)\n{\n    mutex_lock(&con->lock);\n    asymcute_req_t *req = _req_preprocess(con, len, MINLEN_REGACK,\n                                          data, IDPOS_REGACK);\n    if (req == NULL) {\n        mutex_unlock(&con->lock);\n        return;\n    }\n\n    /* check return code */\n    unsigned ret = ASYMCUTE_REJECTED;\n    if (data[6] == MQTTSN_ACCEPTED) {\n        /* finish the registration by applying the topic id */\n        asymcute_topic_t *topic = (asymcute_topic_t *)req->arg;\n        if (topic == NULL) {\n            return;\n        }\n\n        topic->id = byteorder_bebuftohs(&data[2]);\n        topic->con = con;\n        ret = ASYMCUTE_REGISTERED;\n    }\n\n    /* finally notify the user and free the request */\n    mutex_unlock(&req->lock);\n    mutex_unlock(&con->lock);\n    con->user_cb(req, ret);\n}",
  "abstract_func": "static void _on_regack(asymcute_con_t *VAR_0, const uint8_t *VAR_1, size_t VAR_2)\n{\n    mutex_lock(&VAR_0->lock);\n    asymcute_req_t *VAR_3 = _req_preprocess(VAR_0, VAR_2, VAR_4,\n                                          VAR_1, VAR_5);\n    if (VAR_3 == NULL) {\n        mutex_unlock(&VAR_0->lock);\n        return;\n    }\n\n    /* COMMENT_0 */\n    unsigned VAR_6 = VAR_7;\n    if (VAR_1[6] == VAR_8) {\n        /* COMMENT_1 */\n        asymcute_topic_t *VAR_9 = (asymcute_topic_t *)VAR_3->arg;\n        if (VAR_9 == NULL) {\n            return;\n        }\n\n        VAR_9->id = byteorder_bebuftohs(&VAR_1[2]);\n        VAR_9->con = VAR_0;\n        VAR_6 = VAR_10;\n    }\n\n    /* COMMENT_2 */\n    mutex_unlock(&VAR_3->lock);\n    mutex_unlock(&VAR_0->lock);\n    VAR_0->user_cb(VAR_3, VAR_6);\n}",
  "func_graph_path": "RIOT-OS/RIOT/30e4823e946949befe74ef94bc48fe43958c28a6/asymcute.c/vul/after/3.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -13,6 +13,10 @@\n     if (data[6] == MQTTSN_ACCEPTED) {\n         /* finish the registration by applying the topic id */\n         asymcute_topic_t *topic = (asymcute_topic_t *)req->arg;\n+        if (topic == NULL) {\n+            return;\n+        }\n+\n         topic->id = byteorder_bebuftohs(&data[2]);\n         topic->con = con;\n         ret = ASYMCUTE_REGISTERED;",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "        if (topic == NULL) {",
      "            return;",
      "        }",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/RIOT-OS/RIOT/pull/12293",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/RIOT-OS/RIOT/pull/12293: 403 Client Error: Forbidden for url: https://api.github.com/repos/RIOT-OS/RIOT/pulls/12293",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}