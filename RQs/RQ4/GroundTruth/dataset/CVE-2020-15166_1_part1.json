{
  "cve_id": "CVE-2020-15166",
  "cwe_ids": [
    "CWE-400"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "zeromq/libzmq",
  "commit_msg": "problem: zeromq connects peer before handshake is completed\n\nSolution: delay connecting the peer pipe until the handshake is completed",
  "commit_hash": "e7f0090b161ce6344f6bd35009816a925c070b09",
  "git_url": "https://github.com/zeromq/libzmq/commit/e7f0090b161ce6344f6bd35009816a925c070b09",
  "file_path": "src/session_base.cpp",
  "func_name": "zmq::session_base_t::process_attach",
  "func_before": "void zmq::session_base_t::process_attach (i_engine *engine_)\n{\n    zmq_assert (engine_ != NULL);\n\n    //  Create the pipe if it does not exist yet.\n    if (!_pipe && !is_terminating ()) {\n        object_t *parents[2] = {this, _socket};\n        pipe_t *pipes[2] = {NULL, NULL};\n\n        const bool conflate = get_effective_conflate_option (options);\n\n        int hwms[2] = {conflate ? -1 : options.rcvhwm,\n                       conflate ? -1 : options.sndhwm};\n        bool conflates[2] = {conflate, conflate};\n        const int rc = pipepair (parents, pipes, hwms, conflates);\n        errno_assert (rc == 0);\n\n        //  Plug the local end of the pipe.\n        pipes[0]->set_event_sink (this);\n\n        //  Remember the local end of the pipe.\n        zmq_assert (!_pipe);\n        _pipe = pipes[0];\n\n        //  The endpoints strings are not set on bind, set them here so that\n        //  events can use them.\n        pipes[0]->set_endpoint_pair (engine_->get_endpoint ());\n        pipes[1]->set_endpoint_pair (engine_->get_endpoint ());\n\n        //  Ask socket to plug into the remote end of the pipe.\n        send_bind (_socket, pipes[1]);\n    }\n\n    //  Plug in the engine.\n    zmq_assert (!_engine);\n    _engine = engine_;\n    _engine->plug (_io_thread, this);\n}",
  "abstract_func_before": "void zmq::session_base_t::process_attach (i_engine *VAR_0)\n{\n    zmq_assert (VAR_0 != NULL);\n\n    /* COMMENT_0 */\n    if (!VAR_1 && !is_terminating ()) {\n        object_t *VAR_2[2] = {this, VAR_3};\n        pipe_t *VAR_4[2] = {NULL, NULL};\n\n        const bool VAR_5 = get_effective_conflate_option (VAR_6);\n\n        int VAR_7[2] = {VAR_5 ? -1 : VAR_6.rcvhwm,\n                       VAR_5 ? -1 : VAR_6.sndhwm};\n        bool VAR_8[2] = {VAR_5, VAR_5};\n        const int VAR_9 = pipepair (VAR_2, VAR_4, VAR_7, VAR_8);\n        errno_assert (VAR_9 == 0);\n\n        /* COMMENT_1 */\n        VAR_4[0]->set_event_sink (this);\n\n        /* COMMENT_2 */\n        zmq_assert (!VAR_1);\n        VAR_1 = VAR_4[0];\n\n        /* COMMENT_3 */\n        /* COMMENT_4 */\n        VAR_4[0]->set_endpoint_pair (VAR_0->get_endpoint ());\n        VAR_4[1]->set_endpoint_pair (VAR_0->get_endpoint ());\n\n        /* COMMENT_5 */\n        send_bind (VAR_3, VAR_4[1]);\n    }\n\n    /* COMMENT_6 */\n    zmq_assert (!VAR_10);\n    VAR_10 = VAR_0;\n    VAR_10->plug (VAR_11, this);\n}",
  "func_graph_path_before": "zeromq/libzmq/e7f0090b161ce6344f6bd35009816a925c070b09/session_base.cpp/vul/before/0.json",
  "func": "void zmq::session_base_t::process_attach (i_engine *engine_)\n{\n    zmq_assert (engine_ != NULL);\n    zmq_assert (!_engine);\n    _engine = engine_;\n\n    if (!engine_->has_handshake_stage ())\n        engine_ready ();\n\n    //  Plug in the engine.\n    _engine->plug (_io_thread, this);\n}",
  "abstract_func": "void zmq::session_base_t::process_attach (i_engine *VAR_0)\n{\n    zmq_assert (VAR_0 != NULL);\n    zmq_assert (!VAR_1);\n    VAR_1 = VAR_0;\n\n    if (!VAR_0->has_handshake_stage ())\n        engine_ready ();\n\n    /* COMMENT_0 */\n    VAR_1->plug (VAR_2, this);\n}",
  "func_graph_path": "zeromq/libzmq/e7f0090b161ce6344f6bd35009816a925c070b09/session_base.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,38 +1,12 @@\n void zmq::session_base_t::process_attach (i_engine *engine_)\n {\n     zmq_assert (engine_ != NULL);\n+    zmq_assert (!_engine);\n+    _engine = engine_;\n \n-    //  Create the pipe if it does not exist yet.\n-    if (!_pipe && !is_terminating ()) {\n-        object_t *parents[2] = {this, _socket};\n-        pipe_t *pipes[2] = {NULL, NULL};\n-\n-        const bool conflate = get_effective_conflate_option (options);\n-\n-        int hwms[2] = {conflate ? -1 : options.rcvhwm,\n-                       conflate ? -1 : options.sndhwm};\n-        bool conflates[2] = {conflate, conflate};\n-        const int rc = pipepair (parents, pipes, hwms, conflates);\n-        errno_assert (rc == 0);\n-\n-        //  Plug the local end of the pipe.\n-        pipes[0]->set_event_sink (this);\n-\n-        //  Remember the local end of the pipe.\n-        zmq_assert (!_pipe);\n-        _pipe = pipes[0];\n-\n-        //  The endpoints strings are not set on bind, set them here so that\n-        //  events can use them.\n-        pipes[0]->set_endpoint_pair (engine_->get_endpoint ());\n-        pipes[1]->set_endpoint_pair (engine_->get_endpoint ());\n-\n-        //  Ask socket to plug into the remote end of the pipe.\n-        send_bind (_socket, pipes[1]);\n-    }\n+    if (!engine_->has_handshake_stage ())\n+        engine_ready ();\n \n     //  Plug in the engine.\n-    zmq_assert (!_engine);\n-    _engine = engine_;\n     _engine->plug (_io_thread, this);\n }",
  "diff_line_info": {
    "deleted_lines": [
      "    //  Create the pipe if it does not exist yet.",
      "    if (!_pipe && !is_terminating ()) {",
      "        object_t *parents[2] = {this, _socket};",
      "        pipe_t *pipes[2] = {NULL, NULL};",
      "",
      "        const bool conflate = get_effective_conflate_option (options);",
      "",
      "        int hwms[2] = {conflate ? -1 : options.rcvhwm,",
      "                       conflate ? -1 : options.sndhwm};",
      "        bool conflates[2] = {conflate, conflate};",
      "        const int rc = pipepair (parents, pipes, hwms, conflates);",
      "        errno_assert (rc == 0);",
      "",
      "        //  Plug the local end of the pipe.",
      "        pipes[0]->set_event_sink (this);",
      "",
      "        //  Remember the local end of the pipe.",
      "        zmq_assert (!_pipe);",
      "        _pipe = pipes[0];",
      "",
      "        //  The endpoints strings are not set on bind, set them here so that",
      "        //  events can use them.",
      "        pipes[0]->set_endpoint_pair (engine_->get_endpoint ());",
      "        pipes[1]->set_endpoint_pair (engine_->get_endpoint ());",
      "",
      "        //  Ask socket to plug into the remote end of the pipe.",
      "        send_bind (_socket, pipes[1]);",
      "    }",
      "    zmq_assert (!_engine);",
      "    _engine = engine_;"
    ],
    "added_lines": [
      "    zmq_assert (!_engine);",
      "    _engine = engine_;",
      "    if (!engine_->has_handshake_stage ())",
      "        engine_ready ();"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/zeromq/libzmq/pull/3913",
  "description": {
    "pr_info": {
      "title": "problem: zeromq connects peer before handshake is complete",
      "number": 3913
    },
    "comment": [
      "Solution: delay connecting the peer pipe until the handshake is complete",
      "@bluca PR is ready ",
      "Thanks!"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.85,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.85"
}