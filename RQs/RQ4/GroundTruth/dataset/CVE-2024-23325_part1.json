{
  "cve_id": "CVE-2024-23325",
  "cwe_ids": [
    "CWE-755"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "envoyproxy/envoy",
  "commit_msg": "Fix crash when proxy protocol receives an address type that isn't\nsupported by the operating system\n\nFix [CVE-2024-23325](https://github.com/envoyproxy/envoy/security/advisories/GHSA-5m7c-mrwr-pm26)\n\nSigned-off-by: Greg Greenway <ggreenway@apple.com>\nSigned-off-by: Ryan Northey <ryan@synca.io>",
  "commit_hash": "bacd3107455b8d387889467725eb72aa0d5b5237",
  "git_url": "https://github.com/envoyproxy/envoy/commit/bacd3107455b8d387889467725eb72aa0d5b5237",
  "file_path": "source/extensions/filters/listener/proxy_protocol/proxy_protocol.cc",
  "func_name": "Filter::parseV2Header",
  "func_before": "bool Filter::parseV2Header(const char* buf) {\n  const int ver_cmd = buf[PROXY_PROTO_V2_SIGNATURE_LEN];\n  uint8_t upper_byte = buf[PROXY_PROTO_V2_HEADER_LEN - 2];\n  uint8_t lower_byte = buf[PROXY_PROTO_V2_HEADER_LEN - 1];\n  size_t hdr_addr_len = (upper_byte << 8) + lower_byte;\n\n  if ((ver_cmd & 0xf) == PROXY_PROTO_V2_LOCAL) {\n    // This is locally-initiated, e.g. health-check, and should not override remote address.\n    // According to the spec, this address length should be zero for local connection.\n    proxy_protocol_header_.emplace(WireHeader{PROXY_PROTO_V2_HEADER_LEN, hdr_addr_len, 0, 0});\n    return true;\n  }\n\n  // Only do connections on behalf of another user, not internally-driven health-checks. If\n  // its not on behalf of someone, or its not AF_INET{6} / STREAM/DGRAM, ignore and\n  // use the real-remote info\n  if ((ver_cmd & 0xf) == PROXY_PROTO_V2_ONBEHALF_OF) {\n    uint8_t proto_family = buf[PROXY_PROTO_V2_SIGNATURE_LEN + 1];\n    if (((proto_family & 0x0f) == PROXY_PROTO_V2_TRANSPORT_STREAM) ||\n        ((proto_family & 0x0f) == PROXY_PROTO_V2_TRANSPORT_DGRAM)) {\n      if (((proto_family & 0xf0) >> 4) == PROXY_PROTO_V2_AF_INET) {\n        PACKED_STRUCT(struct pp_ipv4_addr {\n          uint32_t src_addr;\n          uint32_t dst_addr;\n          uint16_t src_port;\n          uint16_t dst_port;\n        });\n        const pp_ipv4_addr* v4;\n        v4 = reinterpret_cast<const pp_ipv4_addr*>(&buf[PROXY_PROTO_V2_HEADER_LEN]);\n        sockaddr_in ra4, la4;\n        memset(&ra4, 0, sizeof(ra4));\n        memset(&la4, 0, sizeof(la4));\n        ra4.sin_family = AF_INET;\n        ra4.sin_port = v4->src_port;\n        ra4.sin_addr.s_addr = v4->src_addr;\n\n        la4.sin_family = AF_INET;\n        la4.sin_port = v4->dst_port;\n        la4.sin_addr.s_addr = v4->dst_addr;\n        proxy_protocol_header_.emplace(\n            WireHeader{PROXY_PROTO_V2_HEADER_LEN, hdr_addr_len, PROXY_PROTO_V2_ADDR_LEN_INET,\n                       hdr_addr_len - PROXY_PROTO_V2_ADDR_LEN_INET, Network::Address::IpVersion::v4,\n                       std::make_shared<Network::Address::Ipv4Instance>(&ra4),\n                       std::make_shared<Network::Address::Ipv4Instance>(&la4)});\n        return true;\n      } else if (((proto_family & 0xf0) >> 4) == PROXY_PROTO_V2_AF_INET6) {\n        PACKED_STRUCT(struct pp_ipv6_addr {\n          uint8_t src_addr[16];\n          uint8_t dst_addr[16];\n          uint16_t src_port;\n          uint16_t dst_port;\n        });\n        const pp_ipv6_addr* v6;\n        v6 = reinterpret_cast<const pp_ipv6_addr*>(&buf[PROXY_PROTO_V2_HEADER_LEN]);\n        sockaddr_in6 ra6, la6;\n        memset(&ra6, 0, sizeof(ra6));\n        memset(&la6, 0, sizeof(la6));\n        ra6.sin6_family = AF_INET6;\n        ra6.sin6_port = v6->src_port;\n        safeMemcpy(&(ra6.sin6_addr.s6_addr), &(v6->src_addr));\n\n        la6.sin6_family = AF_INET6;\n        la6.sin6_port = v6->dst_port;\n        safeMemcpy(&(la6.sin6_addr.s6_addr), &(v6->dst_addr));\n\n        proxy_protocol_header_.emplace(WireHeader{\n            PROXY_PROTO_V2_HEADER_LEN, hdr_addr_len, PROXY_PROTO_V2_ADDR_LEN_INET6,\n            hdr_addr_len - PROXY_PROTO_V2_ADDR_LEN_INET6, Network::Address::IpVersion::v6,\n            std::make_shared<Network::Address::Ipv6Instance>(ra6),\n            std::make_shared<Network::Address::Ipv6Instance>(la6)});\n        return true;\n      }\n    }\n  }\n  ENVOY_LOG(debug, \"Unsupported command or address family or transport\");\n  return false;\n}",
  "abstract_func_before": "bool Filter::parseV2Header(const char* VAR_0) {\n  const int VAR_1 = VAR_0[VAR_2];\n  uint8_t VAR_3 = VAR_0[VAR_4 - 2];\n  uint8_t VAR_5 = VAR_0[VAR_4 - 1];\n  size_t VAR_6 = (VAR_3 << 8) + VAR_5;\n\n  if ((VAR_1 & 0xf) == VAR_7) {\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n    VAR_8.emplace(WireHeader{VAR_4, VAR_6, 0, 0});\n    return true;\n  }\n\n  /* COMMENT_2 */\n  /* COMMENT_3 */\n  /* COMMENT_4 */\n  if ((VAR_1 & 0xf) == VAR_9) {\n    uint8_t VAR_10 = VAR_0[VAR_2 + 1];\n    if (((VAR_10 & 0x0f) == VAR_11) ||\n        ((VAR_10 & 0x0f) == VAR_12)) {\n      if (((VAR_10 & 0xf0) >> 4) == VAR_13) {\n        PACKED_STRUCT(struct pp_ipv4_addr {\n          uint32_t src_addr;\n          uint32_t dst_addr;\n          uint16_t src_port;\n          uint16_t dst_port;\n        });\n        const pp_ipv4_addr* VAR_14;\n        VAR_14 = VAR_15<const pp_ipv4_addr*>(&VAR_0[VAR_4]);\n        sockaddr_in VAR_16, VAR_17;\n        memset(&VAR_16, 0, sizeof(VAR_16));\n        memset(&VAR_17, 0, sizeof(VAR_17));\n        VAR_16.sin_family = VAR_18;\n        VAR_16.sin_port = VAR_14->src_port;\n        VAR_16.sin_addr.s_addr = VAR_14->src_addr;\n\n        VAR_17.sin_family = VAR_18;\n        VAR_17.sin_port = VAR_14->dst_port;\n        VAR_17.sin_addr.s_addr = VAR_14->dst_addr;\n        VAR_8.emplace(\n            WireHeader{VAR_4, VAR_6, VAR_19,\n                       VAR_6 - VAR_19, Network::Address::IpVersion::v4,\n                       std::VAR_20<Network::Address::Ipv4Instance>(&VAR_16),\n                       std::VAR_20<Network::Address::Ipv4Instance>(&VAR_17)});\n        return true;\n      } else if (((VAR_10 & 0xf0) >> 4) == VAR_21) {\n        PACKED_STRUCT(struct pp_ipv6_addr {\n          uint8_t src_addr[16];\n          uint8_t dst_addr[16];\n          uint16_t src_port;\n          uint16_t dst_port;\n        });\n        const pp_ipv6_addr* VAR_22;\n        VAR_22 = VAR_15<const pp_ipv6_addr*>(&VAR_0[VAR_4]);\n        sockaddr_in6 VAR_23, VAR_24;\n        memset(&VAR_23, 0, sizeof(VAR_23));\n        memset(&VAR_24, 0, sizeof(VAR_24));\n        VAR_23.sin6_family = VAR_25;\n        VAR_23.sin6_port = VAR_22->src_port;\n        safeMemcpy(&(VAR_23.sin6_addr.s6_addr), &(VAR_22->src_addr));\n\n        VAR_24.sin6_family = VAR_25;\n        VAR_24.sin6_port = VAR_22->dst_port;\n        safeMemcpy(&(VAR_24.sin6_addr.s6_addr), &(VAR_22->dst_addr));\n\n        VAR_8.emplace(WireHeader{\n            VAR_4, VAR_6, VAR_26,\n            VAR_6 - VAR_26, Network::Address::IpVersion::v6,\n            std::VAR_20<Network::Address::Ipv6Instance>(VAR_23),\n            std::VAR_20<Network::Address::Ipv6Instance>(VAR_24)});\n        return true;\n      }\n    }\n  }\n  ENVOY_LOG(VAR_27, \"Unsupported command or address family or transport\");\n  return false;\n}",
  "func_graph_path_before": "envoyproxy/envoy/bacd3107455b8d387889467725eb72aa0d5b5237/proxy_protocol.cc/vul/before/0.json",
  "func": "bool Filter::parseV2Header(const char* buf) {\n  const int ver_cmd = buf[PROXY_PROTO_V2_SIGNATURE_LEN];\n  uint8_t upper_byte = buf[PROXY_PROTO_V2_HEADER_LEN - 2];\n  uint8_t lower_byte = buf[PROXY_PROTO_V2_HEADER_LEN - 1];\n  size_t hdr_addr_len = (upper_byte << 8) + lower_byte;\n\n  if ((ver_cmd & 0xf) == PROXY_PROTO_V2_LOCAL) {\n    // This is locally-initiated, e.g. health-check, and should not override remote address.\n    // According to the spec, this address length should be zero for local connection.\n    proxy_protocol_header_.emplace(WireHeader{PROXY_PROTO_V2_HEADER_LEN, hdr_addr_len, 0, 0});\n    return true;\n  }\n\n  // Only do connections on behalf of another user, not internally-driven health-checks. If\n  // its not on behalf of someone, or its not AF_INET{6} / STREAM/DGRAM, ignore and\n  // use the real-remote info\n  if ((ver_cmd & 0xf) == PROXY_PROTO_V2_ONBEHALF_OF) {\n    uint8_t proto_family = buf[PROXY_PROTO_V2_SIGNATURE_LEN + 1];\n    if (((proto_family & 0x0f) == PROXY_PROTO_V2_TRANSPORT_STREAM) ||\n        ((proto_family & 0x0f) == PROXY_PROTO_V2_TRANSPORT_DGRAM)) {\n      if (((proto_family & 0xf0) >> 4) == PROXY_PROTO_V2_AF_INET) {\n        PACKED_STRUCT(struct pp_ipv4_addr {\n          uint32_t src_addr;\n          uint32_t dst_addr;\n          uint16_t src_port;\n          uint16_t dst_port;\n        });\n        const pp_ipv4_addr* v4;\n        v4 = reinterpret_cast<const pp_ipv4_addr*>(&buf[PROXY_PROTO_V2_HEADER_LEN]);\n        sockaddr_in ra4, la4;\n        memset(&ra4, 0, sizeof(ra4));\n        memset(&la4, 0, sizeof(la4));\n        ra4.sin_family = AF_INET;\n        ra4.sin_port = v4->src_port;\n        ra4.sin_addr.s_addr = v4->src_addr;\n\n        la4.sin_family = AF_INET;\n        la4.sin_port = v4->dst_port;\n        la4.sin_addr.s_addr = v4->dst_addr;\n\n        TRY_NEEDS_AUDIT_ADDRESS {\n          // TODO(ggreenway): make this work without requiring operating system support for an\n          // address family.\n          proxy_protocol_header_.emplace(WireHeader{\n              PROXY_PROTO_V2_HEADER_LEN, hdr_addr_len, PROXY_PROTO_V2_ADDR_LEN_INET,\n              hdr_addr_len - PROXY_PROTO_V2_ADDR_LEN_INET, Network::Address::IpVersion::v4,\n              std::make_shared<Network::Address::Ipv4Instance>(&ra4),\n              std::make_shared<Network::Address::Ipv4Instance>(&la4)});\n        }\n        END_TRY CATCH(const EnvoyException& e, {\n          ENVOY_LOG(debug, \"Proxy protocol failure: {}\", e.what());\n          return false;\n        });\n\n        return true;\n      } else if (((proto_family & 0xf0) >> 4) == PROXY_PROTO_V2_AF_INET6) {\n        PACKED_STRUCT(struct pp_ipv6_addr {\n          uint8_t src_addr[16];\n          uint8_t dst_addr[16];\n          uint16_t src_port;\n          uint16_t dst_port;\n        });\n        const pp_ipv6_addr* v6;\n        v6 = reinterpret_cast<const pp_ipv6_addr*>(&buf[PROXY_PROTO_V2_HEADER_LEN]);\n        sockaddr_in6 ra6, la6;\n        memset(&ra6, 0, sizeof(ra6));\n        memset(&la6, 0, sizeof(la6));\n        ra6.sin6_family = AF_INET6;\n        ra6.sin6_port = v6->src_port;\n        safeMemcpy(&(ra6.sin6_addr.s6_addr), &(v6->src_addr));\n\n        la6.sin6_family = AF_INET6;\n        la6.sin6_port = v6->dst_port;\n        safeMemcpy(&(la6.sin6_addr.s6_addr), &(v6->dst_addr));\n\n        TRY_NEEDS_AUDIT_ADDRESS {\n          proxy_protocol_header_.emplace(WireHeader{\n              PROXY_PROTO_V2_HEADER_LEN, hdr_addr_len, PROXY_PROTO_V2_ADDR_LEN_INET6,\n              hdr_addr_len - PROXY_PROTO_V2_ADDR_LEN_INET6, Network::Address::IpVersion::v6,\n              std::make_shared<Network::Address::Ipv6Instance>(ra6),\n              std::make_shared<Network::Address::Ipv6Instance>(la6)});\n        }\n        END_TRY CATCH(const EnvoyException& e, {\n          // TODO(ggreenway): make this work without requiring operating system support for an\n          // address family.\n          ENVOY_LOG(debug, \"Proxy protocol failure: {}\", e.what());\n          return false;\n        });\n        return true;\n      }",
  "abstract_func": "bool Filter::parseV2Header(const char* VAR_0) {\n  const int VAR_1 = VAR_0[VAR_2];\n  uint8_t VAR_3 = VAR_0[VAR_4 - 2];\n  uint8_t VAR_5 = VAR_0[VAR_4 - 1];\n  size_t VAR_6 = (VAR_3 << 8) + VAR_5;\n\n  if ((VAR_1 & 0xf) == VAR_7) {\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n    VAR_8.emplace(WireHeader{VAR_4, VAR_6, 0, 0});\n    return true;\n  }\n\n  /* COMMENT_2 */\n  /* COMMENT_3 */\n  /* COMMENT_4 */\n  if ((VAR_1 & 0xf) == VAR_9) {\n    uint8_t VAR_10 = VAR_0[VAR_2 + 1];\n    if (((VAR_10 & 0x0f) == VAR_11) ||\n        ((VAR_10 & 0x0f) == VAR_12)) {\n      if (((VAR_10 & 0xf0) >> 4) == VAR_13) {\n        PACKED_STRUCT(struct pp_ipv4_addr {\n          uint32_t src_addr;\n          uint32_t dst_addr;\n          uint16_t src_port;\n          uint16_t dst_port;\n        });\n        const pp_ipv4_addr* VAR_14;\n        VAR_14 = VAR_15<const pp_ipv4_addr*>(&VAR_0[VAR_4]);\n        sockaddr_in VAR_16, VAR_17;\n        memset(&VAR_16, 0, sizeof(VAR_16));\n        memset(&VAR_17, 0, sizeof(VAR_17));\n        VAR_16.sin_family = VAR_18;\n        VAR_16.sin_port = VAR_14->src_port;\n        VAR_16.sin_addr.s_addr = VAR_14->src_addr;\n\n        VAR_17.sin_family = VAR_18;\n        VAR_17.sin_port = VAR_14->dst_port;\n        VAR_17.sin_addr.s_addr = VAR_14->dst_addr;\n\n        TRY_NEEDS_AUDIT_ADDRESS {\n          /* COMMENT_5 */\n          /* COMMENT_6 */\n          VAR_8.emplace(WireHeader{\n              VAR_4, VAR_6, VAR_19,\n              VAR_6 - VAR_19, Network::Address::IpVersion::v4,\n              std::VAR_20<Network::Address::Ipv4Instance>(&VAR_16),\n              std::VAR_20<Network::Address::Ipv4Instance>(&VAR_17)});\n        }\n        END_TRY VAR_21(const EnvoyException& VAR_22, {\n          ENVOY_LOG(VAR_23, \"Proxy protocol failure: {}\", VAR_22.what());\n          return false;\n        });\n\n        return true;\n      } else if (((VAR_10 & 0xf0) >> 4) == VAR_24) {\n        PACKED_STRUCT(struct pp_ipv6_addr {\n          uint8_t src_addr[16];\n          uint8_t dst_addr[16];\n          uint16_t src_port;\n          uint16_t dst_port;\n        });\n        const pp_ipv6_addr* VAR_25;\n        VAR_25 = VAR_15<const pp_ipv6_addr*>(&VAR_0[VAR_4]);\n        sockaddr_in6 VAR_26, VAR_27;\n        memset(&VAR_26, 0, sizeof(VAR_26));\n        memset(&VAR_27, 0, sizeof(VAR_27));\n        VAR_26.sin6_family = VAR_28;\n        VAR_26.sin6_port = VAR_25->src_port;\n        safeMemcpy(&(VAR_26.sin6_addr.s6_addr), &(VAR_25->src_addr));\n\n        VAR_27.sin6_family = VAR_28;\n        VAR_27.sin6_port = VAR_25->dst_port;\n        safeMemcpy(&(VAR_27.sin6_addr.s6_addr), &(VAR_25->dst_addr));\n\n        TRY_NEEDS_AUDIT_ADDRESS {\n          VAR_8.emplace(WireHeader{\n              VAR_4, VAR_6, VAR_29,\n              VAR_6 - VAR_29, Network::Address::IpVersion::v6,\n              std::VAR_20<Network::Address::Ipv6Instance>(VAR_26),\n              std::VAR_20<Network::Address::Ipv6Instance>(VAR_27)});\n        }\n        END_TRY VAR_21(const EnvoyException& VAR_22, {\n          /* COMMENT_5 */\n          /* COMMENT_6 */\n          ENVOY_LOG(VAR_23, \"Proxy protocol failure: {}\", VAR_22.what());\n          return false;\n        });\n        return true;\n      }",
  "func_graph_path": "envoyproxy/envoy/bacd3107455b8d387889467725eb72aa0d5b5237/proxy_protocol.cc/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -37,11 +37,21 @@\n         la4.sin_family = AF_INET;\n         la4.sin_port = v4->dst_port;\n         la4.sin_addr.s_addr = v4->dst_addr;\n-        proxy_protocol_header_.emplace(\n-            WireHeader{PROXY_PROTO_V2_HEADER_LEN, hdr_addr_len, PROXY_PROTO_V2_ADDR_LEN_INET,\n-                       hdr_addr_len - PROXY_PROTO_V2_ADDR_LEN_INET, Network::Address::IpVersion::v4,\n-                       std::make_shared<Network::Address::Ipv4Instance>(&ra4),\n-                       std::make_shared<Network::Address::Ipv4Instance>(&la4)});\n+\n+        TRY_NEEDS_AUDIT_ADDRESS {\n+          // TODO(ggreenway): make this work without requiring operating system support for an\n+          // address family.\n+          proxy_protocol_header_.emplace(WireHeader{\n+              PROXY_PROTO_V2_HEADER_LEN, hdr_addr_len, PROXY_PROTO_V2_ADDR_LEN_INET,\n+              hdr_addr_len - PROXY_PROTO_V2_ADDR_LEN_INET, Network::Address::IpVersion::v4,\n+              std::make_shared<Network::Address::Ipv4Instance>(&ra4),\n+              std::make_shared<Network::Address::Ipv4Instance>(&la4)});\n+        }\n+        END_TRY CATCH(const EnvoyException& e, {\n+          ENVOY_LOG(debug, \"Proxy protocol failure: {}\", e.what());\n+          return false;\n+        });\n+\n         return true;\n       } else if (((proto_family & 0xf0) >> 4) == PROXY_PROTO_V2_AF_INET6) {\n         PACKED_STRUCT(struct pp_ipv6_addr {\n@@ -63,15 +73,18 @@\n         la6.sin6_port = v6->dst_port;\n         safeMemcpy(&(la6.sin6_addr.s6_addr), &(v6->dst_addr));\n \n-        proxy_protocol_header_.emplace(WireHeader{\n-            PROXY_PROTO_V2_HEADER_LEN, hdr_addr_len, PROXY_PROTO_V2_ADDR_LEN_INET6,\n-            hdr_addr_len - PROXY_PROTO_V2_ADDR_LEN_INET6, Network::Address::IpVersion::v6,\n-            std::make_shared<Network::Address::Ipv6Instance>(ra6),\n-            std::make_shared<Network::Address::Ipv6Instance>(la6)});\n+        TRY_NEEDS_AUDIT_ADDRESS {\n+          proxy_protocol_header_.emplace(WireHeader{\n+              PROXY_PROTO_V2_HEADER_LEN, hdr_addr_len, PROXY_PROTO_V2_ADDR_LEN_INET6,\n+              hdr_addr_len - PROXY_PROTO_V2_ADDR_LEN_INET6, Network::Address::IpVersion::v6,\n+              std::make_shared<Network::Address::Ipv6Instance>(ra6),\n+              std::make_shared<Network::Address::Ipv6Instance>(la6)});\n+        }\n+        END_TRY CATCH(const EnvoyException& e, {\n+          // TODO(ggreenway): make this work without requiring operating system support for an\n+          // address family.\n+          ENVOY_LOG(debug, \"Proxy protocol failure: {}\", e.what());\n+          return false;\n+        });\n         return true;\n       }\n-    }\n-  }\n-  ENVOY_LOG(debug, \"Unsupported command or address family or transport\");\n-  return false;\n-}",
  "diff_line_info": {
    "deleted_lines": [
      "        proxy_protocol_header_.emplace(",
      "            WireHeader{PROXY_PROTO_V2_HEADER_LEN, hdr_addr_len, PROXY_PROTO_V2_ADDR_LEN_INET,",
      "                       hdr_addr_len - PROXY_PROTO_V2_ADDR_LEN_INET, Network::Address::IpVersion::v4,",
      "                       std::make_shared<Network::Address::Ipv4Instance>(&ra4),",
      "                       std::make_shared<Network::Address::Ipv4Instance>(&la4)});",
      "        proxy_protocol_header_.emplace(WireHeader{",
      "            PROXY_PROTO_V2_HEADER_LEN, hdr_addr_len, PROXY_PROTO_V2_ADDR_LEN_INET6,",
      "            hdr_addr_len - PROXY_PROTO_V2_ADDR_LEN_INET6, Network::Address::IpVersion::v6,",
      "            std::make_shared<Network::Address::Ipv6Instance>(ra6),",
      "            std::make_shared<Network::Address::Ipv6Instance>(la6)});",
      "    }",
      "  }",
      "  ENVOY_LOG(debug, \"Unsupported command or address family or transport\");",
      "  return false;",
      "}"
    ],
    "added_lines": [
      "",
      "        TRY_NEEDS_AUDIT_ADDRESS {",
      "          // TODO(ggreenway): make this work without requiring operating system support for an",
      "          // address family.",
      "          proxy_protocol_header_.emplace(WireHeader{",
      "              PROXY_PROTO_V2_HEADER_LEN, hdr_addr_len, PROXY_PROTO_V2_ADDR_LEN_INET,",
      "              hdr_addr_len - PROXY_PROTO_V2_ADDR_LEN_INET, Network::Address::IpVersion::v4,",
      "              std::make_shared<Network::Address::Ipv4Instance>(&ra4),",
      "              std::make_shared<Network::Address::Ipv4Instance>(&la4)});",
      "        }",
      "        END_TRY CATCH(const EnvoyException& e, {",
      "          ENVOY_LOG(debug, \"Proxy protocol failure: {}\", e.what());",
      "          return false;",
      "        });",
      "",
      "        TRY_NEEDS_AUDIT_ADDRESS {",
      "          proxy_protocol_header_.emplace(WireHeader{",
      "              PROXY_PROTO_V2_HEADER_LEN, hdr_addr_len, PROXY_PROTO_V2_ADDR_LEN_INET6,",
      "              hdr_addr_len - PROXY_PROTO_V2_ADDR_LEN_INET6, Network::Address::IpVersion::v6,",
      "              std::make_shared<Network::Address::Ipv6Instance>(ra6),",
      "              std::make_shared<Network::Address::Ipv6Instance>(la6)});",
      "        }",
      "        END_TRY CATCH(const EnvoyException& e, {",
      "          // TODO(ggreenway): make this work without requiring operating system support for an",
      "          // address family.",
      "          ENVOY_LOG(debug, \"Proxy protocol failure: {}\", e.what());",
      "          return false;",
      "        });"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/envoyproxy/envoy/pull/32300",
  "description": {
    "pr_info": {
      "title": "repo: Assorted CVE fixes (IMPORTANT!)",
      "number": 32300
    },
    "comment": [
      "Fix crash from AWS NLB healthchecks when proxy protocol is enabled\r\nFix: [CVE-2024-23327](https://github.com/envoyproxy/envoy/security/advisories/GHSA-4h5x-x9vh-m29j)\r\n\r\nCache RE object in uri template matcher. \r\nFix [CVE-2024-23323](https://github.com/envoyproxy/envoy/security/advisories/GHSA-x278-4w4x-r7ch)\r\n\r\nFix crash when idle and request per try timeouts occur within backoff interval\r\nFix [CVE-2024-23322](https://github.com/envoyproxy/envoy/security/advisories/GHSA-6p83-mfmh-qv38)\r\n\r\nFix crash when proxy protocol receives an address type that isn't supported by the operating system\r\nFix [CVE-2024-23325](https://github.com/envoyproxy/envoy/security/advisories/GHSA-5m7c-mrwr-pm26)\r\n\r\nProxy protocol: sanitise non utf8 chars in TLVs\r\nFix [CVE-2024-23324](https://github.com/envoyproxy/envoy/security/advisories/GHSA-gq3v-vvhj-96j6)\r\n",
      "CC @envoyproxy/coverage-shephards: FYI only for changes made to `(test/per_file_coverage.sh)`.\nenvoyproxy/coverage-shephards assignee is @RyanTheOptimist\n\n\n<details>\n\t<summary>:cat:</summary>\n\nCaused by: https://github.com/envoyproxy/envoy/pull/32300 was opened by phlax.\n\nsee: [more](https://github.com/envoyproxy/envoy/pull/32300), [trace](https://prod.repokitteh.app/traces/ui/envoyproxy/envoy/53df9610-c75a-11ee-99e2-8c29c907fa82).\n</details>",
      "> Can we update the PR description to link to the CVEs that this addresses?\r\n\r\ni think we have been here before 8/\r\n\r\nthis PR will be rebased, the commits contain the linked CVEs\r\n\r\nthis is what needs checking @RyanTheOptimist if you could look through that would be appreciated",
      "> > Can we update the PR description to link to the CVEs that this addresses?\r\n> \r\n> i think we have been here before 8/\r\n> \r\n> this PR will be rebased, the commits contain the linked CVEs\r\n> \r\n> this is what needs checking @RyanTheOptimist if you could look through that would be appreciated\r\n\r\nyes, i agree that the code changes look good. It would still be good to copy the links to the CVEs into the PR description so that when we see the commit in git history it has the relevant context.",
      "i already have to copy this information to each commit on each branch - ie 20+ and also to the release summaries\r\n\r\ngiven that the information is there **and needs to be checked** ill leave any further copypasta as an exercise for the reader",
      "I do not believe that \"Assorted CVE fixes (IMPORTANT!)\" meeds the requirements of a PR description from CONTRIBUTING.md. Feel free to get a second opinion from another maintainer.\r\n\r\n```\r\n* Your PR description should have details on what the PR does. If it fixes an existing issue it\r\n  should end with \"Fixes #XXX\".\r\n```",
      "comment updated",
      "I believe [the commit](https://github.com/envoyproxy/envoy/pull/32300/commits/f1cd344edb2775eef8b9d456c76e4a249f1bac8f) to sanitize the proxy protocol values seems wrong. The [sanitizeUtf8String](https://github.com/envoyproxy/envoy/blob/6231a648424d6ae5209d5346960e825a216f95fa/source/common/protobuf/yaml_utility.cc#L341) function used modifies the bytes in a non-recoverable way, but the actual value isn't always meant to be a valid utf8 string. I believe the [proxy protocol spec](https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt) allows for this.\r\n\r\nMaterially, Google's private service connect (PSC) feature encodes a TLV value as a binary encoded int64. With this commit there's no way to recover the original value in most cases. Example value bytes that should be a valid PSC id\r\n`00 22 6b cf 0a 00 00 02` (decodes to `9688686178336770`)\r\n\r\nI think either using set_bytes within `ProtobufWkt::Value` (which doesn't seem to exist today) or escaping the bad bytes in a reverseable way would be necessary.",
      "I think this happened because Envoy is using a protobuf string for both moving data around internally, and sending protobufs flattened over the network. I agree this is an unintended change in behavior. I'm not sure what the best way to fix this is. Can you open an issue for this @fedya-at-db ?",
      "Thanks, I filed an issue [here](https://github.com/envoyproxy/envoy/issues/32718)."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "The patch addresses a crash when an unsupported address type is received, referencing a CVE, indicating a security fix.\n\n**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.9\n\n```json\n{\n  \"classification\": \"Security Vulnerability Fix\",\n  \"confidence\": 0.9\n}\n```"
}