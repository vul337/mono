{
  "cve_id": "CVE-2020-26272",
  "cwe_ids": [
    "CWE-668"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "electron",
  "commit_msg": "fix: restrict sendToFrame to same-process frames by default (#26875)",
  "commit_hash": "07a1c2a3e5845901f7e2eda9506695be58edc73c",
  "git_url": "https://github.com/electron/electron/commit/07a1c2a3e5845901f7e2eda9506695be58edc73c",
  "file_path": "shell/common/gin_helper/event_emitter.cc",
  "func_name": "CreateNativeEvent",
  "func_before": "v8::Local<v8::Object> CreateNativeEvent(\n    v8::Isolate* isolate,\n    v8::Local<v8::Object> sender,\n    content::RenderFrameHost* frame,\n    electron::mojom::ElectronBrowser::MessageSyncCallback callback) {\n  v8::Local<v8::Object> event;\n  if (frame && callback) {\n    gin::Handle<Event> native_event = Event::Create(isolate);\n    native_event->SetCallback(std::move(callback));\n    event = v8::Local<v8::Object>::Cast(native_event.ToV8());\n  } else {\n    // No need to create native event if we do not need to send reply.\n    event = CreateEvent(isolate);\n  }\n\n  Dictionary dict(isolate, event);\n  dict.Set(\"sender\", sender);\n  // Should always set frameId even when callback is null.\n  if (frame)\n    dict.Set(\"frameId\", frame->GetRoutingID());\n  return event;\n}",
  "abstract_func_before": "v8::Local<v8::Object> CreateNativeEvent(\n    v8::Isolate* VAR_0,\n    v8::Local<v8::Object> VAR_1,\n    content::RenderFrameHost* VAR_2,\n    electron::mojom::ElectronBrowser::MessageSyncCallback VAR_3) {\n  v8::Local<v8::Object> VAR_4;\n  if (VAR_2 && VAR_3) {\n    gin::Handle<Event> VAR_5 = Event::Create(VAR_0);\n    VAR_5->SetCallback(std::move(VAR_3));\n    VAR_4 = v8::Local<v8::Object>::Cast(VAR_5.ToV8());\n  } else {\n    /* COMMENT_0 */\n    VAR_4 = CreateEvent(VAR_0);\n  }\n\n  Dictionary dict(isolate, event);\n  VAR_6.Set(\"sender\", VAR_1);\n  /* COMMENT_1 */\n  if (VAR_2)\n    VAR_6.Set(\"frameId\", VAR_2->GetRoutingID());\n  return event;\n}",
  "func_graph_path_before": "electron/07a1c2a3e5845901f7e2eda9506695be58edc73c/event_emitter.cc/vul/before/0.json",
  "func": "v8::Local<v8::Object> CreateNativeEvent(\n    v8::Isolate* isolate,\n    v8::Local<v8::Object> sender,\n    content::RenderFrameHost* frame,\n    electron::mojom::ElectronBrowser::MessageSyncCallback callback) {\n  v8::Local<v8::Object> event;\n  if (frame && callback) {\n    gin::Handle<Event> native_event = Event::Create(isolate);\n    native_event->SetCallback(std::move(callback));\n    event = v8::Local<v8::Object>::Cast(native_event.ToV8());\n  } else {\n    // No need to create native event if we do not need to send reply.\n    event = CreateEvent(isolate);\n  }\n\n  Dictionary dict(isolate, event);\n  dict.Set(\"sender\", sender);\n  // Should always set frameId even when callback is null.\n  if (frame) {\n    dict.Set(\"frameId\", frame->GetRoutingID());\n    dict.Set(\"processId\", frame->GetProcess()->GetID());\n  }\n  return event;\n}",
  "abstract_func": "v8::Local<v8::Object> CreateNativeEvent(\n    v8::Isolate* VAR_0,\n    v8::Local<v8::Object> VAR_1,\n    content::RenderFrameHost* VAR_2,\n    electron::mojom::ElectronBrowser::MessageSyncCallback VAR_3) {\n  v8::Local<v8::Object> VAR_4;\n  if (VAR_2 && VAR_3) {\n    gin::Handle<Event> VAR_5 = Event::Create(VAR_0);\n    VAR_5->SetCallback(std::move(VAR_3));\n    VAR_4 = v8::Local<v8::Object>::Cast(VAR_5.ToV8());\n  } else {\n    /* COMMENT_0 */\n    VAR_4 = CreateEvent(VAR_0);\n  }\n\n  Dictionary dict(isolate, event);\n  VAR_6.Set(\"sender\", VAR_1);\n  /* COMMENT_1 */\n  if (VAR_2) {\n    VAR_6.Set(\"frameId\", VAR_2->GetRoutingID());\n    VAR_6.Set(\"processId\", VAR_2->GetProcess()->GetID());\n  }\n  return event;\n}",
  "func_graph_path": "electron/07a1c2a3e5845901f7e2eda9506695be58edc73c/event_emitter.cc/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -16,7 +16,9 @@\n   Dictionary dict(isolate, event);\n   dict.Set(\"sender\", sender);\n   // Should always set frameId even when callback is null.\n-  if (frame)\n+  if (frame) {\n     dict.Set(\"frameId\", frame->GetRoutingID());\n+    dict.Set(\"processId\", frame->GetProcess()->GetID());\n+  }\n   return event;\n }",
  "diff_line_info": {
    "deleted_lines": [
      "  if (frame)"
    ],
    "added_lines": [
      "  if (frame) {",
      "    dict.Set(\"processId\", frame->GetProcess()->GetID());",
      "  }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/electron/electron/pull/26875",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/electron/electron/pull/26875: 403 Client Error: Forbidden for url: https://api.github.com/repos/electron/electron/pulls/26875",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0\n\n**Step-by-Step Explanation:**\n\n1. **Commit Analysis**: The commit message clearly states it's a fix, focusing on restricting IPC to same-process frames, indicating a security concern.\n2. **Vulnerability Link**: The issue caused replies not to deliver, which could be exploited. The fix involves stricter IPC controls by adding processId checks.\n3. **Code Change Insight**: The addition of processId ensures that IPC messages are only sent to the correct process, reducing exploit risk.\n4. **Alignment Check**: The code changes match the described fix, and there are no conflicting details.\n\nThis comprehensive analysis confirms the patch addresses a security vulnerability, thus classified as a \"Security Vulnerability Fix\" with high confidence."
}