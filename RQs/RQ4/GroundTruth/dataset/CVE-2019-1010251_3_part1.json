{
  "cve_id": "CVE-2019-1010251",
  "cwe_ids": [
    "CWE-20"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "OISF/suricata",
  "commit_msg": "proto/detect: workaround dns misdetected as dcerpc\n\nThe DCERPC UDP detection would misfire on DNS with transaction\nID 0x0400. This would happen as the protocol detection engine\ngives preference to pattern based detection over probing parsers for\nperformance reasons.\n\nThis hack/workaround fixes this specific case by still running the\nprobing parser if DCERPC has been detected on UDP. The probing\nparser result will take precedence.\n\nBug #2736.",
  "commit_hash": "8357ef3f8ffc7d99ef6571350724160de356158b",
  "git_url": "https://github.com/OISF/suricata/commit/8357ef3f8ffc7d99ef6571350724160de356158b",
  "file_path": "src/app-layer-detect-proto.c",
  "func_name": "AppLayerProtoDetectGetProto",
  "func_before": "AppProto AppLayerProtoDetectGetProto(AppLayerProtoDetectThreadCtx *tctx,\n                                     Flow *f,\n                                     uint8_t *buf, uint32_t buflen,\n                                     uint8_t ipproto, uint8_t direction)\n{\n    SCEnter();\n    SCLogDebug(\"buflen %u for %s direction\", buflen,\n            (direction & STREAM_TOSERVER) ? \"toserver\" : \"toclient\");\n\n    AppProto alproto = ALPROTO_UNKNOWN;\n\n    if (!FLOW_IS_PM_DONE(f, direction)) {\n        AppProto pm_results[ALPROTO_MAX];\n        uint16_t pm_matches = AppLayerProtoDetectPMGetProto(tctx, f,\n                                                   buf, buflen,\n                                                   direction,\n                                                   ipproto,\n                                                   pm_results);\n        if (pm_matches > 0) {\n            alproto = pm_results[0];\n            goto end;\n        }\n    }\n\n    if (!FLOW_IS_PP_DONE(f, direction)) {\n        alproto = AppLayerProtoDetectPPGetProto(f, buf, buflen,\n                                                ipproto, direction);\n        if (alproto != ALPROTO_UNKNOWN)\n            goto end;\n    }\n\n    /* Look if flow can be found in expectation list */\n    if (!FLOW_IS_PE_DONE(f, direction)) {\n        alproto = AppLayerProtoDetectPEGetProto(f, ipproto, direction);\n    }\n\n end:\n    SCReturnUInt(alproto);\n}",
  "abstract_func_before": "AppProto AppLayerProtoDetectGetProto(AppLayerProtoDetectThreadCtx *VAR_0,\n                                     Flow *VAR_1,\n                                     uint8_t *VAR_2, uint32_t VAR_3,\n                                     uint8_t VAR_4, uint8_t VAR_5)\n{\n    SCEnter();\n    SCLogDebug(\"buflen %u for %s direction\", VAR_3,\n            (VAR_5 & VAR_6) ? \"toserver\" : \"toclient\");\n\n    AppProto VAR_7 = VAR_8;\n\n    if (!FLOW_IS_PM_DONE(VAR_1, VAR_5)) {\n        AppProto VAR_9[VAR_10];\n        uint16_t VAR_11 = AppLayerProtoDetectPMGetProto(VAR_0, VAR_1,\n                                                   VAR_2, VAR_3,\n                                                   VAR_5,\n                                                   VAR_4,\n                                                   VAR_9);\n        if (VAR_11 > 0) {\n            VAR_7 = VAR_9[0];\n            goto end;\n        }\n    }\n\n    if (!FLOW_IS_PP_DONE(VAR_1, VAR_5)) {\n        VAR_7 = AppLayerProtoDetectPPGetProto(VAR_1, VAR_2, VAR_3,\n                                                VAR_4, VAR_5);\n        if (VAR_7 != VAR_8)\n            goto end;\n    }\n\n    /* COMMENT_0 */\n    if (!FLOW_IS_PE_DONE(VAR_1, VAR_5)) {\n        VAR_7 = AppLayerProtoDetectPEGetProto(VAR_1, VAR_4, VAR_5);\n    }\n\n end:\n    SCReturnUInt(VAR_7);\n}",
  "func_graph_path_before": "OISF/suricata/8357ef3f8ffc7d99ef6571350724160de356158b/app-layer-detect-proto.c/vul/before/0.json",
  "func": "AppProto AppLayerProtoDetectGetProto(AppLayerProtoDetectThreadCtx *tctx,\n                                     Flow *f,\n                                     uint8_t *buf, uint32_t buflen,\n                                     uint8_t ipproto, uint8_t direction)\n{\n    SCEnter();\n    SCLogDebug(\"buflen %u for %s direction\", buflen,\n            (direction & STREAM_TOSERVER) ? \"toserver\" : \"toclient\");\n\n    AppProto alproto = ALPROTO_UNKNOWN;\n    AppProto pm_alproto = ALPROTO_UNKNOWN;\n\n    if (!FLOW_IS_PM_DONE(f, direction)) {\n        AppProto pm_results[ALPROTO_MAX];\n        uint16_t pm_matches = AppLayerProtoDetectPMGetProto(tctx, f,\n                                                   buf, buflen,\n                                                   direction,\n                                                   ipproto,\n                                                   pm_results);\n        if (pm_matches > 0) {\n            alproto = pm_results[0];\n\n            /* HACK: if detected protocol is dcerpc/udp, we run PP as well\n             * to avoid misdetecting DNS as DCERPC. */\n            if (!(ipproto == IPPROTO_UDP && alproto == ALPROTO_DCERPC))\n                goto end;\n\n            pm_alproto = alproto;\n\n            /* fall through */\n        }\n    }\n\n    if (!FLOW_IS_PP_DONE(f, direction)) {\n        alproto = AppLayerProtoDetectPPGetProto(f, buf, buflen,\n                                                ipproto, direction);\n        if (alproto != ALPROTO_UNKNOWN)\n            goto end;\n    }\n\n    /* Look if flow can be found in expectation list */\n    if (!FLOW_IS_PE_DONE(f, direction)) {\n        alproto = AppLayerProtoDetectPEGetProto(f, ipproto, direction);\n    }\n\n end:\n    if (alproto == ALPROTO_UNKNOWN)\n        alproto = pm_alproto;\n\n    SCReturnUInt(alproto);\n}",
  "abstract_func": "AppProto AppLayerProtoDetectGetProto(AppLayerProtoDetectThreadCtx *VAR_0,\n                                     Flow *VAR_1,\n                                     uint8_t *VAR_2, uint32_t VAR_3,\n                                     uint8_t VAR_4, uint8_t VAR_5)\n{\n    SCEnter();\n    SCLogDebug(\"buflen %u for %s direction\", VAR_3,\n            (VAR_5 & VAR_6) ? \"toserver\" : \"toclient\");\n\n    AppProto VAR_7 = VAR_8;\n    AppProto VAR_9 = VAR_8;\n\n    if (!FLOW_IS_PM_DONE(VAR_1, VAR_5)) {\n        AppProto VAR_10[VAR_11];\n        uint16_t VAR_12 = AppLayerProtoDetectPMGetProto(VAR_0, VAR_1,\n                                                   VAR_2, VAR_3,\n                                                   VAR_5,\n                                                   VAR_4,\n                                                   VAR_10);\n        if (VAR_12 > 0) {\n            VAR_7 = VAR_10[0];\n\n            /* COMMENT_0 */\n                                                      \n            if (!(VAR_4 == VAR_13 && VAR_7 == VAR_14))\n                goto end;\n\n            VAR_9 = VAR_7;\n\n            /* COMMENT_2 */\n        }\n    }\n\n    if (!FLOW_IS_PP_DONE(VAR_1, VAR_5)) {\n        VAR_7 = AppLayerProtoDetectPPGetProto(VAR_1, VAR_2, VAR_3,\n                                                VAR_4, VAR_5);\n        if (VAR_7 != VAR_8)\n            goto end;\n    }\n\n    /* COMMENT_3 */\n    if (!FLOW_IS_PE_DONE(VAR_1, VAR_5)) {\n        VAR_7 = AppLayerProtoDetectPEGetProto(VAR_1, VAR_4, VAR_5);\n    }\n\n end:\n    if (VAR_7 == VAR_8)\n        VAR_7 = VAR_9;\n\n    SCReturnUInt(VAR_7);\n}",
  "func_graph_path": "OISF/suricata/8357ef3f8ffc7d99ef6571350724160de356158b/app-layer-detect-proto.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -8,6 +8,7 @@\n             (direction & STREAM_TOSERVER) ? \"toserver\" : \"toclient\");\n \n     AppProto alproto = ALPROTO_UNKNOWN;\n+    AppProto pm_alproto = ALPROTO_UNKNOWN;\n \n     if (!FLOW_IS_PM_DONE(f, direction)) {\n         AppProto pm_results[ALPROTO_MAX];\n@@ -18,7 +19,15 @@\n                                                    pm_results);\n         if (pm_matches > 0) {\n             alproto = pm_results[0];\n-            goto end;\n+\n+            /* HACK: if detected protocol is dcerpc/udp, we run PP as well\n+             * to avoid misdetecting DNS as DCERPC. */\n+            if (!(ipproto == IPPROTO_UDP && alproto == ALPROTO_DCERPC))\n+                goto end;\n+\n+            pm_alproto = alproto;\n+\n+            /* fall through */\n         }\n     }\n \n@@ -35,5 +44,8 @@\n     }\n \n  end:\n+    if (alproto == ALPROTO_UNKNOWN)\n+        alproto = pm_alproto;\n+\n     SCReturnUInt(alproto);\n }",
  "diff_line_info": {
    "deleted_lines": [
      "            goto end;"
    ],
    "added_lines": [
      "    AppProto pm_alproto = ALPROTO_UNKNOWN;",
      "",
      "            /* HACK: if detected protocol is dcerpc/udp, we run PP as well",
      "             * to avoid misdetecting DNS as DCERPC. */",
      "            if (!(ipproto == IPPROTO_UDP && alproto == ALPROTO_DCERPC))",
      "                goto end;",
      "",
      "            pm_alproto = alproto;",
      "",
      "            /* fall through */",
      "    if (alproto == ALPROTO_UNKNOWN)",
      "        alproto = pm_alproto;",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/OISF/suricata/pull/3590",
  "description": {
    "pr_info": {
      "title": "Next/20181218/v8",
      "number": 3590
    },
    "comment": [
      "Describe changes:\r\n- as #3589, but make IPv6 decoder a bit more strict\r\n\r\n[PRScript](https://redmine.openinfosecfoundation.org/projects/suricata/wiki/PRscript) output (if applicable):\r\nN/A\r\n"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.9"
}