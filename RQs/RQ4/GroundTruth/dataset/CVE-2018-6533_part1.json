{
  "cve_id": "CVE-2018-6533",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "AV:L/AC:L/Au:N/C:C/I:C/A:C",
  "cvss_is_v3": false,
  "repo_name": "Icinga/icinga2",
  "commit_msg": "Remove need for RunAsUser/Group\n\nThey are now read form the sysconfig file which is owned by root",
  "commit_hash": "c8c193a9d825acc6c6da8fc33688971d01c7fbd7",
  "git_url": "https://github.com/Icinga/icinga2/commit/c8c193a9d825acc6c6da8fc33688971d01c7fbd7",
  "file_path": "icinga-app/icinga.cpp",
  "func_name": "Main",
  "func_before": "static int Main()\n{\n\tint argc = Application::GetArgC();\n\tchar **argv = Application::GetArgV();\n\n\tbool autocomplete = false;\n\tint autoindex = 0;\n\n\tif (argc >= 4 && strcmp(argv[1], \"--autocomplete\") == 0) {\n\t\tautocomplete = true;\n\n\t\ttry {\n\t\t\tautoindex = Convert::ToLong(argv[2]);\n\t\t} catch (const std::invalid_argument&) {\n\t\t\tLog(LogCritical, \"icinga-app\")\n\t\t\t\t<< \"Invalid index for --autocomplete: \" << argv[2];\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\n\t\targc -= 3;\n\t\targv += 3;\n\t}\n\n\tApplication::SetStartTime(Utility::GetTime());\n\n\t/* Set thread title. */\n\tUtility::SetThreadName(\"Main Thread\", false);\n\n\t/* Install exception handlers to make debugging easier. */\n\tApplication::InstallExceptionHandlers();\n\n#ifdef _WIN32\n\tbool builtinPaths = true;\n\n\tString binaryPrefix = Utility::GetIcingaInstallPath();\n\tString dataPrefix = Utility::GetIcingaDataPath();\n\n\tif (!binaryPrefix.IsEmpty() && !dataPrefix.IsEmpty()) {\n\t\tApplication::DeclarePrefixDir(binaryPrefix);\n\t\tApplication::DeclareSysconfDir(dataPrefix + \"\\\\etc\");\n\t\tApplication::DeclareRunDir(dataPrefix + \"\\\\var\\\\run\");\n\t\tApplication::DeclareLocalStateDir(dataPrefix + \"\\\\var\");\n\t\tApplication::DeclarePkgDataDir(binaryPrefix + \"\\\\share\\\\icinga2\");\n\t\tApplication::DeclareIncludeConfDir(binaryPrefix + \"\\\\share\\\\icinga2\\\\include\");\n\t} else {\n\t\tLog(LogWarning, \"icinga-app\", \"Registry key could not be read. Falling back to built-in paths.\");\n\n#endif /* _WIN32 */\n\t\tApplication::DeclarePrefixDir(ICINGA_PREFIX);\n\t\tApplication::DeclareSysconfDir(ICINGA_SYSCONFDIR);\n\t\tApplication::DeclareRunDir(ICINGA_RUNDIR);\n\t\tApplication::DeclareLocalStateDir(ICINGA_LOCALSTATEDIR);\n\t\tApplication::DeclarePkgDataDir(ICINGA_PKGDATADIR);\n\t\tApplication::DeclareIncludeConfDir(ICINGA_INCLUDECONFDIR);\n#ifdef _WIN32\n\t}\n#endif /* _WIN32 */\n\n\tApplication::DeclareZonesDir(Application::GetSysconfDir() + \"/icinga2/zones.d\");\n\tApplication::DeclareRunAsUser(ICINGA_USER);\n\tApplication::DeclareRunAsGroup(ICINGA_GROUP);\n#ifdef __linux__\n\tApplication::DeclareRLimitFiles(Application::GetDefaultRLimitFiles());\n\tApplication::DeclareRLimitProcesses(Application::GetDefaultRLimitProcesses());\n\tApplication::DeclareRLimitStack(Application::GetDefaultRLimitStack());\n#endif /* __linux__ */\n\tApplication::DeclareConcurrency(std::thread::hardware_concurrency());\n\tApplication::DeclareMaxConcurrentChecks(Application::GetDefaultMaxConcurrentChecks());\n\n\tScriptGlobal::Set(\"AttachDebugger\", false);\n\n\tScriptGlobal::Set(\"PlatformKernel\", Utility::GetPlatformKernel());\n\tScriptGlobal::Set(\"PlatformKernelVersion\", Utility::GetPlatformKernelVersion());\n\tScriptGlobal::Set(\"PlatformName\", Utility::GetPlatformName());\n\tScriptGlobal::Set(\"PlatformVersion\", Utility::GetPlatformVersion());\n\tScriptGlobal::Set(\"PlatformArchitecture\", Utility::GetPlatformArchitecture());\n\n\tScriptGlobal::Set(\"BuildHostName\", ICINGA_BUILD_HOST_NAME);\n\tScriptGlobal::Set(\"BuildCompilerName\", ICINGA_BUILD_COMPILER_NAME);\n\tScriptGlobal::Set(\"BuildCompilerVersion\", ICINGA_BUILD_COMPILER_VERSION);\n\n\tString initconfig = Application::GetSysconfDir() + \"/icinga2/init.conf\";\n\n\tif (Utility::PathExists(initconfig)) {\n\t\tstd::unique_ptr<Expression> expression;\n\t\ttry {\n\t\t\texpression = ConfigCompiler::CompileFile(initconfig);\n\n\t\t\tScriptFrame frame(true);\n\t\t\texpression->Evaluate(frame);\n\t\t} catch (const std::exception& ex) {\n\t\t\tLog(LogCritical, \"config\", DiagnosticInformation(ex));\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t}\n\n\tif (!autocomplete)\n\t\tApplication::SetResourceLimits();\n\n\tLogSeverity logLevel = Logger::GetConsoleLogSeverity();\n\tLogger::SetConsoleLogSeverity(LogWarning);\n\n\tpo::options_description visibleDesc(\"Global options\");\n\n\tvisibleDesc.add_options()\n\t\t(\"help,h\", \"show this help message\")\n\t\t(\"version,V\", \"show version information\")\n#ifndef _WIN32\n\t\t(\"color\", \"use VT100 color codes even when stdout is not a terminal\")\n#endif /* _WIN32 */\n\t\t(\"define,D\", po::value<std::vector<std::string> >(), \"define a constant\")\n\t\t(\"include,I\", po::value<std::vector<std::string> >(), \"add include search directory\")\n\t\t(\"log-level,x\", po::value<std::string>(), \"specify the log level for the console log.\\n\"\n\t\t\t\"The valid value is either debug, notice, information (default), warning, or critical\")\n\t\t(\"script-debugger,X\", \"whether to enable the script debugger\");\n\n\tpo::options_description hiddenDesc(\"Hidden options\");\n\n\thiddenDesc.add_options()\n\t\t(\"no-stack-rlimit\", \"used internally, do not specify manually\")\n\t\t(\"arg\", po::value<std::vector<std::string> >(), \"positional argument\");\n\n\tpo::positional_options_description positionalDesc;\n\tpositionalDesc.add(\"arg\", -1);\n\n\tString cmdname;\n\tCLICommand::Ptr command;\n\tpo::variables_map vm;\n\n\ttry {\n\t\tCLICommand::ParseCommand(argc, argv, visibleDesc, hiddenDesc, positionalDesc,\n\t\t\tvm, cmdname, command, autocomplete);\n\t} catch (const std::exception& ex) {\n\t\tLog(LogCritical, \"icinga-app\")\n\t\t\t<< \"Error while parsing command-line options: \" << ex.what();\n\t\treturn EXIT_FAILURE;\n\t}\n\n#ifdef _WIN32\n\tchar username[UNLEN + 1];\n\tDWORD usernameLen = UNLEN + 1;\n\tGetUserName(username, &usernameLen);\n\n\tstd::ifstream userFile;\n\tuserFile.open(Application::GetSysconfDir() + \"/icinga2/user\");\n\n\tif (userFile && command && !Application::IsProcessElevated()) {\n\t\tstd::string userLine;\n\t\tif (std::getline(userFile, userLine)) {\n\t\t\tuserFile.close();\n\n\t\t\tstd::vector<std::string> strs;\n\t\t\tboost::split(strs, userLine, boost::is_any_of(\"\\\\\"));\n\n\t\t\tif (username != strs[1] && command->GetImpersonationLevel() == ImpersonationLevel::ImpersonateIcinga\n\t\t\t\t|| command->GetImpersonationLevel() == ImpersonationLevel::ImpersonateRoot) {\n\t\t\t\tTCHAR szPath[MAX_PATH];\n\n\t\t\t\tif (GetModuleFileName(nullptr, szPath, ARRAYSIZE(szPath))) {\n\t\t\t\t\tSHELLEXECUTEINFO sei = { sizeof(sei) };\n\t\t\t\t\tsei.lpVerb = _T(\"runas\");\n\t\t\t\t\tsei.lpFile = \"cmd.exe\";\n\t\t\t\t\tsei.fMask = SEE_MASK_NOCLOSEPROCESS | SEE_MASK_NOASYNC | SEE_MASK_FLAG_NO_UI;\n\t\t\t\t\tsei.nShow = SW_SHOW;\n\n\t\t\t\t\tstd::stringstream parameters;\n\n\t\t\t\t\tparameters << \"/C \" << \"\\\"\" << szPath << \"\\\"\" << \" \";\n\n\t\t\t\t\tfor (int i = 1; i < argc; i++) {\n\t\t\t\t\t\tif (i != 1)\n\t\t\t\t\t\t\tparameters << \" \";\n\t\t\t\t\t\tparameters << argv[i];\n\t\t\t\t\t}\n\n\t\t\t\t\tparameters << \" & SET exitcode=%errorlevel%\";\n\t\t\t\t\tparameters << \" & pause\";\n\t\t\t\t\tparameters << \" & EXIT /B %exitcode%\";\n\n\t\t\t\t\tstd::string str = parameters.str();\n\t\t\t\t\tLPCSTR cstr = str.c_str();\n\n\t\t\t\t\tsei.lpParameters = cstr;\n\n\t\t\t\t\tif (!ShellExecuteEx(&sei)) {\n\t\t\t\t\t\tDWORD dwError = GetLastError();\n\t\t\t\t\t\tif (dwError == ERROR_CANCELLED)\n\t\t\t\t\t\t\tApplication::Exit(0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tWaitForSingleObject(sei.hProcess, INFINITE);\n\n\t\t\t\t\t\tDWORD exitCode;\n\t\t\t\t\t\tGetExitCodeProcess(sei.hProcess, &exitCode);\n\n\t\t\t\t\t\tCloseHandle(sei.hProcess);\n\n\t\t\t\t\t\tApplication::Exit(exitCode);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tuserFile.close();\n\t\t}\n\t}\n#endif /* _WIN32 */\n\n#ifndef _WIN32\n\tif (vm.count(\"color\")) {\n\t\tConsole::SetType(std::cout, Console_VT100);\n\t\tConsole::SetType(std::cerr, Console_VT100);\n\t}\n#endif /* _WIN32 */\n\n\tif (vm.count(\"define\")) {\n\t\tfor (const String& define : vm[\"define\"].as<std::vector<std::string> >()) {\n\t\t\tString key, value;\n\t\t\tsize_t pos = define.FindFirstOf('=');\n\t\t\tif (pos != String::NPos) {\n\t\t\t\tkey = define.SubStr(0, pos);\n\t\t\t\tvalue = define.SubStr(pos + 1);\n\t\t\t} else {\n\t\t\t\tkey = define;\n\t\t\t\tvalue = \"1\";\n\t\t\t}\n\t\t\tScriptGlobal::Set(key, value);\n\t\t}\n\t}\n\n\tif (vm.count(\"script-debugger\"))\n\t\tApplication::SetScriptDebuggerEnabled(true);\n\n\tApplication::DeclareStatePath(Application::GetLocalStateDir() + \"/lib/icinga2/icinga2.state\");\n\tApplication::DeclareModAttrPath(Application::GetLocalStateDir() + \"/lib/icinga2/modified-attributes.conf\");\n\tApplication::DeclareObjectsPath(Application::GetLocalStateDir() + \"/cache/icinga2/icinga2.debug\");\n\tApplication::DeclareVarsPath(Application::GetLocalStateDir() + \"/cache/icinga2/icinga2.vars\");\n\tApplication::DeclarePidPath(Application::GetRunDir() + \"/icinga2/icinga2.pid\");\n\n\tConfigCompiler::AddIncludeSearchDir(Application::GetIncludeConfDir());\n\n\tif (!autocomplete && vm.count(\"include\")) {\n\t\tfor (const String& includePath : vm[\"include\"].as<std::vector<std::string> >()) {\n\t\t\tConfigCompiler::AddIncludeSearchDir(includePath);\n\t\t}\n\t}\n\n\tif (!autocomplete) {\n\t\tLogger::SetConsoleLogSeverity(logLevel);\n\n\t\tif (vm.count(\"log-level\")) {\n\t\t\tString severity = vm[\"log-level\"].as<std::string>();\n\n\t\t\tLogSeverity logLevel = LogInformation;\n\t\t\ttry {\n\t\t\t\tlogLevel = Logger::StringToSeverity(severity);\n\t\t\t} catch (std::exception&) {\n\t\t\t\t/* Inform user and exit */\n\t\t\t\tLog(LogCritical, \"icinga-app\", \"Invalid log level set. Default is 'information'.\");\n\t\t\t\treturn EXIT_FAILURE;\n\t\t\t}\n\n\t\t\tLogger::SetConsoleLogSeverity(logLevel);\n\t\t}\n\n\t\tif (!command || vm.count(\"help\") || vm.count(\"version\")) {\n\t\t\tString appName;\n\n\t\t\ttry {\n\t\t\t\tappName = Utility::BaseName(Application::GetArgV()[0]);\n\t\t\t} catch (const std::bad_alloc&) {\n\t\t\t\tLog(LogCritical, \"icinga-app\", \"Allocation failed.\");\n\t\t\t\treturn EXIT_FAILURE;\n\t\t\t}\n\n\t\t\tif (appName.GetLength() > 3 && appName.SubStr(0, 3) == \"lt-\")\n\t\t\t\tappName = appName.SubStr(3, appName.GetLength() - 3);\n\n\t\t\tstd::cout << appName << \" \" << \"- The Icinga 2 network monitoring daemon (version: \"\n\t\t\t\t<< ConsoleColorTag(vm.count(\"version\") ? Console_ForegroundRed : Console_Normal)\n\t\t\t\t<< Application::GetAppVersion()\n#ifdef I2_DEBUG\n\t\t\t\t<< \"; debug\"\n#endif /* I2_DEBUG */\n\t\t\t\t<< ConsoleColorTag(Console_Normal)\n\t\t\t\t<< \")\" << std::endl << std::endl;\n\n\t\t\tif ((!command || vm.count(\"help\")) && !vm.count(\"version\")) {\n\t\t\t\tstd::cout << \"Usage:\" << std::endl\n\t\t\t\t\t<< \"  \" << Utility::BaseName(argv[0]) << \" \";\n\n\t\t\t\tif (cmdname.IsEmpty())\n\t\t\t\t\tstd::cout << \"<command>\";\n\t\t\t\telse\n\t\t\t\t\tstd::cout << cmdname;\n\n\t\t\t\tstd::cout << \" [<arguments>]\" << std::endl;\n\n\t\t\t\tif (command) {\n\t\t\t\t\tstd::cout << std::endl\n\t\t\t\t\t\t<< command->GetDescription() << std::endl;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (vm.count(\"version\")) {\n\t\t\t\tstd::cout << \"Copyright (c) 2012-2018 Icinga Development Team (https://www.icinga.com/)\" << std::endl\n\t\t\t\t\t<< \"License GPLv2+: GNU GPL version 2 or later <http://gnu.org/licenses/gpl2.html>\" << std::endl\n\t\t\t\t\t<< \"This is free software: you are free to change and redistribute it.\" << std::endl\n\t\t\t\t\t<< \"There is NO WARRANTY, to the extent permitted by law.\";\n\t\t\t}\n\n\t\t\tstd::cout << std::endl;\n\n\t\t\tif (vm.count(\"version\")) {\n\t\t\t\tstd::cout << std::endl;\n\n\t\t\t\tApplication::DisplayInfoMessage(std::cout, true);\n\n\t\t\t\treturn EXIT_SUCCESS;\n\t\t\t}\n\t\t}\n\n\t\tif (!command || vm.count(\"help\")) {\n\t\t\tif (!command)\n\t\t\t\tCLICommand::ShowCommands(argc, argv, nullptr);\n\n\t\t\tstd::cout << visibleDesc << std::endl\n\t\t\t\t<< \"Report bugs at <https://github.com/Icinga/icinga2>\" << std::endl\n\t\t\t\t<< \"Icinga home page: <https://www.icinga.com/>\" << std::endl;\n\t\t\treturn EXIT_SUCCESS;\n\t\t}\n\t}\n\n\tint rc = 1;\n\n\tif (autocomplete) {\n\t\tCLICommand::ShowCommands(argc, argv, &visibleDesc, &hiddenDesc,\n\t\t\t&GlobalArgumentCompletion, true, autoindex);\n\t\trc = 0;\n\t} else if (command) {\n\t\tLogger::DisableTimestamp(true);\n#ifndef _WIN32\n\t\tif (command->GetImpersonationLevel() == ImpersonateRoot) {\n\t\t\tif (getuid() != 0) {\n\t\t\t\tLog(LogCritical, \"cli\", \"This command must be run as root.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else if (command && command->GetImpersonationLevel() == ImpersonateIcinga) {\n\t\t\tString group = Application::GetRunAsGroup();\n\t\t\tString user = Application::GetRunAsUser();\n\n\t\t\terrno = 0;\n\t\t\tstruct group *gr = getgrnam(group.CStr());\n\n\t\t\tif (!gr) {\n\t\t\t\tif (errno == 0) {\n\t\t\t\t\tLog(LogCritical, \"cli\")\n\t\t\t\t\t\t<< \"Invalid group specified: \" << group;\n\t\t\t\t\treturn EXIT_FAILURE;\n\t\t\t\t} else {\n\t\t\t\t\tLog(LogCritical, \"cli\")\n\t\t\t\t\t\t<< \"getgrnam() failed with error code \" << errno << \", \\\"\" << Utility::FormatErrorNumber(errno) << \"\\\"\";\n\t\t\t\t\treturn EXIT_FAILURE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (getgid() != gr->gr_gid) {\n\t\t\t\tif (!vm.count(\"reload-internal\") && setgroups(0, nullptr) < 0) {\n\t\t\t\t\tLog(LogCritical, \"cli\")\n\t\t\t\t\t\t<< \"setgroups() failed with error code \" << errno << \", \\\"\" << Utility::FormatErrorNumber(errno) << \"\\\"\";\n\t\t\t\t\tLog(LogCritical, \"cli\")\n\t\t\t\t\t\t<< \"Please re-run this command as a privileged user or using the \\\"\" << user << \"\\\" account.\";\n\t\t\t\t\treturn EXIT_FAILURE;\n\t\t\t\t}\n\n\t\t\t\tif (setgid(gr->gr_gid) < 0) {\n\t\t\t\t\tLog(LogCritical, \"cli\")\n\t\t\t\t\t\t<< \"setgid() failed with error code \" << errno << \", \\\"\" << Utility::FormatErrorNumber(errno) << \"\\\"\";\n\t\t\t\t\treturn EXIT_FAILURE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\terrno = 0;\n\t\t\tstruct passwd *pw = getpwnam(user.CStr());\n\n\t\t\tif (!pw) {\n\t\t\t\tif (errno == 0) {\n\t\t\t\t\tLog(LogCritical, \"cli\")\n\t\t\t\t\t\t<< \"Invalid user specified: \" << user;\n\t\t\t\t\treturn EXIT_FAILURE;\n\t\t\t\t} else {\n\t\t\t\t\tLog(LogCritical, \"cli\")\n\t\t\t\t\t\t<< \"getpwnam() failed with error code \" << errno << \", \\\"\" << Utility::FormatErrorNumber(errno) << \"\\\"\";\n\t\t\t\t\treturn EXIT_FAILURE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// also activate the additional groups the configured user is member of\n\t\t\tif (getuid() != pw->pw_uid) {\n\t\t\t\tif (!vm.count(\"reload-internal\") && initgroups(user.CStr(), pw->pw_gid) < 0) {\n\t\t\t\t\tLog(LogCritical, \"cli\")\n\t\t\t\t\t\t<< \"initgroups() failed with error code \" << errno << \", \\\"\" << Utility::FormatErrorNumber(errno) << \"\\\"\";\n\t\t\t\t\tLog(LogCritical, \"cli\")\n\t\t\t\t\t\t<< \"Please re-run this command as a privileged user or using the \\\"\" << user << \"\\\" account.\";\n\t\t\t\t\treturn EXIT_FAILURE;\n\t\t\t\t}\n\n\t\t\t\tif (setuid(pw->pw_uid) < 0) {\n\t\t\t\t\tLog(LogCritical, \"cli\")\n\t\t\t\t\t\t<< \"setuid() failed with error code \" << errno << \", \\\"\" << Utility::FormatErrorNumber(errno) << \"\\\"\";\n\t\t\t\t\tLog(LogCritical, \"cli\")\n\t\t\t\t\t\t<< \"Please re-run this command as a privileged user or using the \\\"\" << user << \"\\\" account.\";\n\t\t\t\t\treturn EXIT_FAILURE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tProcess::InitializeSpawnHelper();\n#endif /* _WIN32 */\n\n\t\tstd::vector<std::string> args;\n\t\tif (vm.count(\"arg\"))\n\t\t\targs = vm[\"arg\"].as<std::vector<std::string> >();\n\n\t\tif (static_cast<int>(args.size()) < command->GetMinArguments()) {\n\t\t\tLog(LogCritical, \"cli\")\n\t\t\t\t<< \"Too few arguments. Command needs at least \" << command->GetMinArguments()\n\t\t\t\t<< \" argument\" << (command->GetMinArguments() != 1 ? \"s\" : \"\") << \".\";\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\n\t\tif (command->GetMaxArguments() >= 0 && static_cast<int>(args.size()) > command->GetMaxArguments()) {\n\t\t\tLog(LogCritical, \"cli\")\n\t\t\t\t<< \"Too many arguments. At most \" << command->GetMaxArguments()\n\t\t\t\t<< \" argument\" << (command->GetMaxArguments() != 1 ? \"s\" : \"\") << \" may be specified.\";\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\n\t\trc = command->Run(vm, args);\n\t}\n\n\treturn rc;\n}",
  "abstract_func_before": "static int Main()\n{\n\tint VAR_0 = Application::GetArgC();\n\tchar **VAR_1 = Application::GetArgV();\n\n\tbool VAR_2 = false;\n\tint VAR_3 = 0;\n\n\tif (VAR_0 >= 4 && strcmp(VAR_1[1], \"--autocomplete\") == 0) {\n\t\tVAR_2 = true;\n\n\t\ttry {\n\t\t\tVAR_3 = Convert::ToLong(VAR_1[2]);\n\t\t} catch (const std::invalid_argument&) {\n\t\t\tLog(VAR_4, \"icinga-app\")\n\t\t\t\t<< \"Invalid index for --autocomplete: \" << VAR_1[2];\n\t\t\treturn VAR_5;\n\t\t}\n\n\t\tVAR_0 -= 3;\n\t\tVAR_1 += 3;\n\t}\n\n\tApplication::SetStartTime(Utility::GetTime());\n\n\t/* COMMENT_0 */\n\tUtility::SetThreadName(\"Main Thread\", false);\n\n\t/* COMMENT_1 */\n\tApplication::InstallExceptionHandlers();\n\n#ifdef VAR_6\n\tbool VAR_7 = true;\n\n\tString VAR_8 = Utility::GetIcingaInstallPath();\n\tString VAR_9 = Utility::GetIcingaDataPath();\n\n\tif (!VAR_8.IsEmpty() && !VAR_9.IsEmpty()) {\n\t\tApplication::DeclarePrefixDir(VAR_8);\n\t\tApplication::DeclareSysconfDir(VAR_9 + \"\\\\etc\");\n\t\tApplication::DeclareRunDir(VAR_9 + \"\\\\var\\\\run\");\n\t\tApplication::DeclareLocalStateDir(VAR_9 + \"\\\\var\");\n\t\tApplication::DeclarePkgDataDir(VAR_8 + \"\\\\share\\\\icinga2\");\n\t\tApplication::DeclareIncludeConfDir(VAR_8 + \"\\\\share\\\\icinga2\\\\include\");\n\t} else {\n\t\tLog(VAR_10, \"icinga-app\", \"Registry key could not be read. Falling back to built-in paths.\");\n\n#endif/* COMMENT_2 */\n\t\tApplication::DeclarePrefixDir(ICINGA_PREFIX);\n\t\tApplication::DeclareSysconfDir(VAR_11);\n\t\tApplication::DeclareRunDir(VAR_12);\n\t\tApplication::DeclareLocalStateDir(VAR_13);\n\t\tApplication::DeclarePkgDataDir(VAR_14);\n\t\tApplication::DeclareIncludeConfDir(VAR_15);\n#ifdef VAR_6\n\t}\n#endif /* COMMENT_3 */\n\n\tApplication::DeclareZonesDir(Application::GetSysconfDir() + \"/icinga2/zones.d\");\n\tApplication::DeclareRunAsUser(VAR_16);\n\tApplication::DeclareRunAsGroup(VAR_17);\n#ifdef VAR_18\n\tApplication::DeclareRLimitFiles(Application::GetDefaultRLimitFiles());\n\tApplication::DeclareRLimitProcesses(Application::GetDefaultRLimitProcesses());\n\tApplication::DeclareRLimitStack(Application::GetDefaultRLimitStack());\n#endif /* COMMENT_4 */\n\tApplication::DeclareConcurrency(std::thread::hardware_concurrency());\n\tApplication::DeclareMaxConcurrentChecks(Application::GetDefaultMaxConcurrentChecks());\n\n\tScriptGlobal::Set(\"AttachDebugger\", false);\n\n\tScriptGlobal::Set(\"PlatformKernel\", Utility::GetPlatformKernel());\n\tScriptGlobal::Set(\"PlatformKernelVersion\", Utility::GetPlatformKernelVersion());\n\tScriptGlobal::Set(\"PlatformName\", Utility::GetPlatformName());\n\tScriptGlobal::Set(\"PlatformVersion\", Utility::GetPlatformVersion());\n\tScriptGlobal::Set(\"PlatformArchitecture\", Utility::GetPlatformArchitecture());\n\n\tScriptGlobal::Set(\"BuildHostName\", VAR_19);\n\tScriptGlobal::Set(\"BuildCompilerName\", VAR_20);\n\tScriptGlobal::Set(\"BuildCompilerVersion\", VAR_21);\n\n\tString VAR_22 = Application::GetSysconfDir() + \"/icinga2/init.conf\";\n\n\tif (Utility::PathExists(VAR_22)) {\n\t\tstd::unique_ptr<Expression> VAR_23;\n\t\ttry {\n\t\t\tVAR_23 = ConfigCompiler::CompileFile(VAR_22);\n\n\t\t\tScriptFrame VAR_24(true);\n\t\t\tVAR_23->Evaluate(VAR_24);\n\t\t} catch (const std::exception& VAR_25) {\n\t\t\tLog(VAR_4, \"config\", DiagnosticInformation(VAR_25));\n\t\t\treturn VAR_5;\n\t\t}\n\t}\n\n\tif (!VAR_2)\n\t\tApplication::SetResourceLimits();\n\n\tLogSeverity VAR_26 = Logger::GetConsoleLogSeverity();\n\tLogger::SetConsoleLogSeverity(VAR_10);\n\n\tpo::options_description VAR_27(\"Global options\");\n\n\tVAR_27.add_options()\n\t\t(\"help,h\", \"show this help message\")\n\t\t(\"version,V\", \"show version information\")\n#ifndef VAR_6\n\t\t(\"color\", \"use VT100 color codes even when stdout is not a terminal\")\n#endif /* COMMENT_3 */\n\t\t(\"define,D\", po::VAR_28<std::vector<std::string> >(), \"define a constant\")\n\t\t(\"include,I\", po::VAR_28<std::vector<std::string> >(), \"add include search directory\")\n\t\t(\"log-level,x\", po::VAR_28<std::string>(), \"specify the log level for the console log.\\n\"\n\t\t\t\"The valid value is either debug, notice, information (default), warning, or critical\")\n\t\t(\"script-debugger,X\", \"whether to enable the script debugger\");\n\n\tpo::options_description VAR_29(\"Hidden options\");\n\n\tVAR_29.add_options()\n\t\t(\"no-stack-rlimit\", \"used internally, do not specify manually\")\n\t\t(\"arg\", po::VAR_28<std::vector<std::string> >(), \"positional argument\");\n\n\tpo::positional_options_description VAR_30;\n\tVAR_30.add(\"arg\", -1);\n\n\tString VAR_31;\n\tCLICommand::Ptr VAR_32;\n\tpo::variables_map VAR_33;\n\n\ttry {\n\t\tCLICommand::ParseCommand(VAR_0, VAR_1, VAR_27, VAR_29, VAR_30,\n\t\t\tVAR_33, VAR_31, VAR_32, VAR_2);\n\t} catch (const std::exception& VAR_25) {\n\t\tLog(VAR_4, \"icinga-app\")\n\t\t\t<< \"Error while parsing command-line options: \" << VAR_25.what();\n\t\treturn VAR_5;\n\t}\n\n#ifdef VAR_6\n\tchar VAR_34[VAR_35 + 1];\n\tDWORD VAR_36 = VAR_35 + 1;\n\tGetUserName(VAR_34, &VAR_36);\n\n\tstd::ifstream VAR_37;\n\tVAR_37.open(Application::GetSysconfDir() + \"/icinga2/user\");\n\n\tif (VAR_37 && VAR_32 && !Application::IsProcessElevated()) {\n\t\tstd::string VAR_38;\n\t\tif (std::getline(VAR_37, VAR_38)) {\n\t\t\tVAR_37.close();\n\n\t\t\tstd::vector<std::string> VAR_39;\n\t\t\tboost::split(VAR_39, VAR_38, boost::is_any_of(\"\\\\\"));\n\n\t\t\tif (VAR_34 != VAR_39[1] && VAR_32->GetImpersonationLevel() == ImpersonationLevel::ImpersonateIcinga\n\t\t\t\t|| VAR_32->GetImpersonationLevel() == ImpersonationLevel::ImpersonateRoot) {\n\t\t\t\tTCHAR VAR_40[VAR_41];\n\n\t\t\t\tif (GetModuleFileName(nullptr, VAR_40, ARRAYSIZE(VAR_40))) {\n\t\t\t\t\tSHELLEXECUTEINFO VAR_42 = { sizeof(VAR_42) };\n\t\t\t\t\tVAR_42.lpVerb = _T(\"runas\");\n\t\t\t\t\tVAR_42.lpFile = \"cmd.exe\";\n\t\t\t\t\tVAR_42.fMask = VAR_43 | VAR_44 | VAR_45;\n\t\t\t\t\tVAR_42.nShow = VAR_46;\n\n\t\t\t\t\tstd::stringstream VAR_47;\n\n\t\t\t\t\tVAR_47 << \"/C \" << \"\\\"\" << VAR_40 << \"\\\"\" << \" \";\n\n\t\t\t\t\tfor (int VAR_48 = 1; VAR_48 < VAR_0; VAR_48++) {\n\t\t\t\t\t\tif (VAR_48 != 1)\n\t\t\t\t\t\t\tVAR_47 << \" \";\n\t\t\t\t\t\tVAR_47 << VAR_1[VAR_48];\n\t\t\t\t\t}\n\n\t\t\t\t\tVAR_47 << \" & SET exitcode=%errorlevel%\";\n\t\t\t\t\tVAR_47 << \" & pause\";\n\t\t\t\t\tVAR_47 << \" & EXIT /B %exitcode%\";\n\n\t\t\t\t\tstd::string VAR_49 = VAR_47.str();\n\t\t\t\t\tLPCSTR VAR_50 = VAR_49.c_str();\n\n\t\t\t\t\tVAR_42.lpParameters = VAR_50;\n\n\t\t\t\t\tif (!ShellExecuteEx(&VAR_42)) {\n\t\t\t\t\t\tDWORD VAR_51 = GetLastError();\n\t\t\t\t\t\tif (VAR_51 == VAR_52)\n\t\t\t\t\t\t\tApplication::Exit(0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tWaitForSingleObject(VAR_42.hProcess, VAR_53);\n\n\t\t\t\t\t\tDWORD VAR_54;\n\t\t\t\t\t\tGetExitCodeProcess(VAR_42.hProcess, &VAR_54);\n\n\t\t\t\t\t\tCloseHandle(VAR_42.hProcess);\n\n\t\t\t\t\t\tApplication::Exit(VAR_54);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tVAR_37.close();\n\t\t}\n\t}\n#endif /* COMMENT_3 */\n\n#ifndef VAR_6\n\tif (VAR_33.count(\"color\")) {\n\t\tConsole::SetType(std::cout, VAR_55);\n\t\tConsole::SetType(std::cerr, VAR_55);\n\t}\n#endif /* COMMENT_3 */\n\n\tif (VAR_33.count(\"define\")) {\n\t\tfor (const String& VAR_56 : VAR_33[\"define\"].as<std::vector<std::string> >()) {\n\t\t\tString VAR_57, VAR_28;\n\t\t\tsize_t VAR_58 = VAR_56.FindFirstOf('=');\n\t\t\tif (VAR_58 != String::NPos) {\n\t\t\t\tVAR_57 = VAR_56.SubStr(0, VAR_58);\n\t\t\t\tVAR_28 = VAR_56.SubStr(VAR_58 + 1);\n\t\t\t} else {\n\t\t\t\tVAR_57 = VAR_56;\n\t\t\t\tVAR_28 = \"1\";\n\t\t\t}\n\t\t\tScriptGlobal::Set(VAR_57, VAR_28);\n\t\t}\n\t}\n\n\tif (VAR_33.count(\"script-debugger\"))\n\t\tApplication::SetScriptDebuggerEnabled(true);\n\n\tApplication::DeclareStatePath(Application::GetLocalStateDir() + \"/lib/icinga2/icinga2.state\");\n\tApplication::DeclareModAttrPath(Application::GetLocalStateDir() + \"/lib/icinga2/modified-attributes.conf\");\n\tApplication::DeclareObjectsPath(Application::GetLocalStateDir() + \"/cache/icinga2/icinga2.debug\");\n\tApplication::DeclareVarsPath(Application::GetLocalStateDir() + \"/cache/icinga2/icinga2.vars\");\n\tApplication::DeclarePidPath(Application::GetRunDir() + \"/icinga2/icinga2.pid\");\n\n\tConfigCompiler::AddIncludeSearchDir(Application::GetIncludeConfDir());\n\n\tif (!VAR_2 && VAR_33.count(\"include\")) {\n\t\tfor (const String& VAR_59 : VAR_33[\"include\"].as<std::vector<std::string> >()) {\n\t\t\tConfigCompiler::AddIncludeSearchDir(VAR_59);\n\t\t}\n\t}\n\n\tif (!VAR_2) {\n\t\tLogger::SetConsoleLogSeverity(VAR_26);\n\n\t\tif (VAR_33.count(\"log-level\")) {\n\t\t\tString VAR_60 = VAR_33[\"log-level\"].as<std::string>();\n\n\t\t\tLogSeverity VAR_26 = VAR_61;\n\t\t\ttry {\n\t\t\t\tVAR_26 = Logger::StringToSeverity(VAR_60);\n\t\t\t} catch (std::exception&) {\n\t\t\t\t/* COMMENT_5 */\n\t\t\t\tLog(VAR_4, \"icinga-app\", \"Invalid log level set. Default is 'information'.\");\n\t\t\t\treturn VAR_5;\n\t\t\t}\n\n\t\t\tLogger::SetConsoleLogSeverity(VAR_26);\n\t\t}\n\n\t\tif (!VAR_32 || VAR_33.count(\"help\") || VAR_33.count(\"version\")) {\n\t\t\tString VAR_62;\n\n\t\t\ttry {\n\t\t\t\tVAR_62 = Utility::BaseName(Application::GetArgV()[0]);\n\t\t\t} catch (const std::bad_alloc&) {\n\t\t\t\tLog(VAR_4, \"icinga-app\", \"Allocation failed.\");\n\t\t\t\treturn VAR_5;\n\t\t\t}\n\n\t\t\tif (VAR_62.GetLength() > 3 && VAR_62.SubStr(0, 3) == \"lt-\")\n\t\t\t\tVAR_62 = VAR_62.SubStr(3, VAR_62.GetLength() - 3);\n\n\t\t\tstd::cout << VAR_62 << \" \" << \"- The Icinga 2 network monitoring daemon (version: \"\n\t\t\t\t<< ConsoleColorTag(VAR_33.count(\"version\") ? VAR_63 : VAR_64)\n\t\t\t\t<< Application::GetAppVersion()\n#ifdef VAR_65\n\t\t\t\t<< \"; debug\"\n#endif /* COMMENT_6 */\n\t\t\t\t<< ConsoleColorTag(VAR_64)\n\t\t\t\t<< \")\" << std::endl << std::endl;\n\n\t\t\tif ((!VAR_32 || VAR_33.count(\"help\")) && !VAR_33.count(\"version\")) {\n\t\t\t\tstd::cout << \"Usage:\" << std::endl\n\t\t\t\t\t<< \"  \" << Utility::BaseName(VAR_1[0]) << \" \";\n\n\t\t\t\tif (VAR_31.IsEmpty())\n\t\t\t\t\tstd::cout << \"<command>\";\n\t\t\t\telse\n\t\t\t\t\tstd::cout << VAR_31;\n\n\t\t\t\tstd::cout << \" [<arguments>]\" << std::endl;\n\n\t\t\t\tif (VAR_32) {\n\t\t\t\t\tstd::cout << std::endl\n\t\t\t\t\t\t<< VAR_32->GetDescription() << std::endl;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (VAR_33.count(\"version\")) {\n\t\t\t\tstd::cout << \"Copyright (c) 2012-2018 Icinga Development Team (https://www.icinga.com/)\" << std::endl\n\t\t\t\t\t<< \"License GPLv2+: GNU GPL version 2 or later <http://gnu.org/licenses/gpl2.html>\" << std::endl\n\t\t\t\t\t<< \"This is free software: you are free to change and redistribute it.\" << std::endl\n\t\t\t\t\t<< \"There is NO WARRANTY, to the extent permitted by law.\";\n\t\t\t}\n\n\t\t\tstd::cout << std::endl;\n\n\t\t\tif (VAR_33.count(\"version\")) {\n\t\t\t\tstd::cout << std::endl;\n\n\t\t\t\tApplication::DisplayInfoMessage(std::cout, true);\n\n\t\t\t\treturn VAR_66;\n\t\t\t}\n\t\t}\n\n\t\tif (!VAR_32 || VAR_33.count(\"help\")) {\n\t\t\tif (!VAR_32)\n\t\t\t\tCLICommand::ShowCommands(VAR_0, VAR_1, nullptr);\n\n\t\t\tstd::cout << VAR_27 << std::endl\n\t\t\t\t<< \"Report bugs at <https://github.com/Icinga/icinga2>\" << std::endl\n\t\t\t\t<< \"Icinga home page: <https://www.icinga.com/>\" << std::endl;\n\t\t\treturn VAR_66;\n\t\t}\n\t}\n\n\tint VAR_67 = 1;\n\n\tif (VAR_2) {\n\t\tCLICommand::ShowCommands(VAR_0, VAR_1, &VAR_27, &VAR_29,\n\t\t\t&VAR_68, true, VAR_3);\n\t\tVAR_67 = 0;\n\t} else if (VAR_32) {\n\t\tLogger::DisableTimestamp(true);\n#ifndef VAR_6\n\t\tif (VAR_32->GetImpersonationLevel() == VAR_69) {\n\t\t\tif (getuid() != 0) {\n\t\t\t\tLog(VAR_4, \"cli\", \"This command must be run as root.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else if (VAR_32 && VAR_32->GetImpersonationLevel() == VAR_70) {\n\t\t\tString VAR_71 = Application::GetRunAsGroup();\n\t\t\tString VAR_72 = Application::GetRunAsUser();\n\n\t\t\tVAR_73 = 0;\n\t\t\tstruct group *VAR_74 = getgrnam(group.CStr());\n\n\t\t\tif (!VAR_74) {\n\t\t\t\tif (VAR_73 == 0) {\n\t\t\t\t\tLog(VAR_4, \"cli\")\n\t\t\t\t\t\t<< \"Invalid group specified: \" << group;\n\t\t\t\t\treturn VAR_5;\n\t\t\t\t} else {\n\t\t\t\t\tLog(VAR_4, \"cli\")\n\t\t\t\t\t\t<< \"getgrnam() failed with error code \" << VAR_73 << \", \\\"\" << Utility::FormatErrorNumber(VAR_73) << \"\\\"\";\n\t\t\t\t\treturn VAR_5;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (getgid() != VAR_74->gr_gid) {\n\t\t\t\tif (!VAR_33.count(\"reload-internal\") && setgroups(0, nullptr) < 0) {\n\t\t\t\t\tLog(VAR_4, \"cli\")\n\t\t\t\t\t\t<< \"setgroups() failed with error code \" << VAR_73 << \", \\\"\" << Utility::FormatErrorNumber(VAR_73) << \"\\\"\";\n\t\t\t\t\tLog(VAR_4, \"cli\")\n\t\t\t\t\t\t<< \"Please re-run this command as a privileged user or using the \\\"\" << VAR_72 << \"\\\" account.\";\n\t\t\t\t\treturn VAR_5;\n\t\t\t\t}\n\n\t\t\t\tif (setgid(VAR_74->gr_gid) < 0) {\n\t\t\t\t\tLog(VAR_4, \"cli\")\n\t\t\t\t\t\t<< \"setgid() failed with error code \" << VAR_73 << \", \\\"\" << Utility::FormatErrorNumber(VAR_73) << \"\\\"\";\n\t\t\t\t\treturn VAR_5;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tVAR_73 = 0;\n\t\t\tstruct passwd *VAR_75 = getpwnam(VAR_72.CStr());\n\n\t\t\tif (!VAR_75) {\n\t\t\t\tif (VAR_73 == 0) {\n\t\t\t\t\tLog(VAR_4, \"cli\")\n\t\t\t\t\t\t<< \"Invalid user specified: \" << VAR_72;\n\t\t\t\t\treturn VAR_5;\n\t\t\t\t} else {\n\t\t\t\t\tLog(VAR_4, \"cli\")\n\t\t\t\t\t\t<< \"getpwnam() failed with error code \" << VAR_73 << \", \\\"\" << Utility::FormatErrorNumber(VAR_73) << \"\\\"\";\n\t\t\t\t\treturn VAR_5;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* COMMENT_7 */\n\t\t\tif (getuid() != VAR_75->pw_uid) {\n\t\t\t\tif (!VAR_33.count(\"reload-internal\") && initgroups(VAR_72.CStr(), VAR_75->pw_gid) < 0) {\n\t\t\t\t\tLog(VAR_4, \"cli\")\n\t\t\t\t\t\t<< \"initgroups() failed with error code \" << VAR_73 << \", \\\"\" << Utility::FormatErrorNumber(VAR_73) << \"\\\"\";\n\t\t\t\t\tLog(VAR_4, \"cli\")\n\t\t\t\t\t\t<< \"Please re-run this command as a privileged user or using the \\\"\" << VAR_72 << \"\\\" account.\";\n\t\t\t\t\treturn VAR_5;\n\t\t\t\t}\n\n\t\t\t\tif (setuid(VAR_75->pw_uid) < 0) {\n\t\t\t\t\tLog(VAR_4, \"cli\")\n\t\t\t\t\t\t<< \"setuid() failed with error code \" << VAR_73 << \", \\\"\" << Utility::FormatErrorNumber(VAR_73) << \"\\\"\";\n\t\t\t\t\tLog(VAR_4, \"cli\")\n\t\t\t\t\t\t<< \"Please re-run this command as a privileged user or using the \\\"\" << VAR_72 << \"\\\" account.\";\n\t\t\t\t\treturn VAR_5;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tProcess::InitializeSpawnHelper();\n#endif /* COMMENT_3 */\n\n\t\tstd::vector<std::string> VAR_76;\n\t\tif (VAR_33.count(\"arg\"))\n\t\t\tVAR_76 = VAR_33[\"arg\"].as<std::vector<std::string> >();\n\n\t\tif (VAR_77<int>(VAR_76.size()) < VAR_32->GetMinArguments()) {\n\t\t\tLog(VAR_4, \"cli\")\n\t\t\t\t<< \"Too few arguments. Command needs at least \" << VAR_32->GetMinArguments()\n\t\t\t\t<< \" argument\" << (VAR_32->GetMinArguments() != 1 ? \"s\" : \"\") << \".\";\n\t\t\treturn VAR_5;\n\t\t}\n\n\t\tif (VAR_32->GetMaxArguments() >= 0 && VAR_77<int>(VAR_76.size()) > VAR_32->GetMaxArguments()) {\n\t\t\tLog(VAR_4, \"cli\")\n\t\t\t\t<< \"Too many arguments. At most \" << VAR_32->GetMaxArguments()\n\t\t\t\t<< \" argument\" << (VAR_32->GetMaxArguments() != 1 ? \"s\" : \"\") << \" may be specified.\";\n\t\t\treturn VAR_5;\n\t\t}\n\n\t\tVAR_67 = VAR_32->Run(VAR_33, VAR_76);\n\t}\n\n\treturn VAR_67;\n}",
  "func_graph_path_before": "Icinga/icinga2/c8c193a9d825acc6c6da8fc33688971d01c7fbd7/icinga.cpp/vul/before/0.json",
  "func": "static int Main()\n{\n\tint argc = Application::GetArgC();\n\tchar **argv = Application::GetArgV();\n\n\tbool autocomplete = false;\n\tint autoindex = 0;\n\n\tif (argc >= 4 && strcmp(argv[1], \"--autocomplete\") == 0) {\n\t\tautocomplete = true;\n\n\t\ttry {\n\t\t\tautoindex = Convert::ToLong(argv[2]);\n\t\t} catch (const std::invalid_argument&) {\n\t\t\tLog(LogCritical, \"icinga-app\")\n\t\t\t\t<< \"Invalid index for --autocomplete: \" << argv[2];\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\n\t\targc -= 3;\n\t\targv += 3;\n\t}\n\n\tApplication::SetStartTime(Utility::GetTime());\n\n\t/* Set thread title. */\n\tUtility::SetThreadName(\"Main Thread\", false);\n\n\t/* Install exception handlers to make debugging easier. */\n\tApplication::InstallExceptionHandlers();\n\n#ifdef _WIN32\n\tbool builtinPaths = true;\n\n\tString binaryPrefix = Utility::GetIcingaInstallPath();\n\tString dataPrefix = Utility::GetIcingaDataPath();\n\n\tif (!binaryPrefix.IsEmpty() && !dataPrefix.IsEmpty()) {\n\t\tApplication::DeclarePrefixDir(binaryPrefix);\n\t\tApplication::DeclareSysconfDir(dataPrefix + \"\\\\etc\");\n\t\tApplication::DeclareRunDir(dataPrefix + \"\\\\var\\\\run\");\n\t\tApplication::DeclareLocalStateDir(dataPrefix + \"\\\\var\");\n\t\tApplication::DeclarePkgDataDir(binaryPrefix + \"\\\\share\\\\icinga2\");\n\t\tApplication::DeclareIncludeConfDir(binaryPrefix + \"\\\\share\\\\icinga2\\\\include\");\n\t} else {\n\t\tLog(LogWarning, \"icinga-app\", \"Registry key could not be read. Falling back to built-in paths.\");\n\n#endif /* _WIN32 */\n\t\tApplication::DeclarePrefixDir(ICINGA_PREFIX);\n\t\tApplication::DeclareSysconfigFile(ICINGA_SYSCONFIGFILE);\n\t\tApplication::DeclareSysconfDir(ICINGA_SYSCONFDIR);\n\t\tApplication::DeclareRunDir(ICINGA_RUNDIR);\n\t\tApplication::DeclareLocalStateDir(ICINGA_LOCALSTATEDIR);\n\t\tApplication::DeclarePkgDataDir(ICINGA_PKGDATADIR);\n\t\tApplication::DeclareIncludeConfDir(ICINGA_INCLUDECONFDIR);\n#ifdef _WIN32\n\t}\n#endif /* _WIN32 */\n\n\tApplication::DeclareZonesDir(Application::GetSysconfDir() + \"/icinga2/zones.d\");\n\n\tString icinga_user = Utility::GetFromSysconfig(\"ICINGA2_USER\");\n\tif (icinga_user.IsEmpty())\n\t\ticinga_user = ICINGA_USER;\n\n\tString icinga_group = Utility::GetFromSysconfig(\"ICINGA2_GROUP\");\n\tif (icinga_group.IsEmpty())\n\t\ticinga_group = ICINGA_GROUP;\n\n\tApplication::DeclareRunAsUser(icinga_user);\n\tApplication::DeclareRunAsGroup(icinga_group);\n#ifdef __linux__\n\tApplication::DeclareRLimitFiles(Application::GetDefaultRLimitFiles());\n\tApplication::DeclareRLimitProcesses(Application::GetDefaultRLimitProcesses());\n\tApplication::DeclareRLimitStack(Application::GetDefaultRLimitStack());\n#endif /* __linux__ */\n\tApplication::DeclareConcurrency(std::thread::hardware_concurrency());\n\tApplication::DeclareMaxConcurrentChecks(Application::GetDefaultMaxConcurrentChecks());\n\n\tScriptGlobal::Set(\"AttachDebugger\", false);\n\n\tScriptGlobal::Set(\"PlatformKernel\", Utility::GetPlatformKernel());\n\tScriptGlobal::Set(\"PlatformKernelVersion\", Utility::GetPlatformKernelVersion());\n\tScriptGlobal::Set(\"PlatformName\", Utility::GetPlatformName());\n\tScriptGlobal::Set(\"PlatformVersion\", Utility::GetPlatformVersion());\n\tScriptGlobal::Set(\"PlatformArchitecture\", Utility::GetPlatformArchitecture());\n\n\tScriptGlobal::Set(\"BuildHostName\", ICINGA_BUILD_HOST_NAME);\n\tScriptGlobal::Set(\"BuildCompilerName\", ICINGA_BUILD_COMPILER_NAME);\n\tScriptGlobal::Set(\"BuildCompilerVersion\", ICINGA_BUILD_COMPILER_VERSION);\n\n\tString initconfig = Application::GetSysconfDir() + \"/icinga2/init.conf\";\n\n\tif (Utility::PathExists(initconfig)) {\n\t\tstd::unique_ptr<Expression> expression;\n\t\ttry {\n\t\t\texpression = ConfigCompiler::CompileFile(initconfig);\n\n\t\t\tScriptFrame frame(true);\n\t\t\texpression->Evaluate(frame);\n\t\t} catch (const std::exception& ex) {\n\t\t\tLog(LogCritical, \"config\", DiagnosticInformation(ex));\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t}\n\n\tif (!autocomplete)\n\t\tApplication::SetResourceLimits();\n\n\tLogSeverity logLevel = Logger::GetConsoleLogSeverity();\n\tLogger::SetConsoleLogSeverity(LogWarning);\n\n\tpo::options_description visibleDesc(\"Global options\");\n\n\tvisibleDesc.add_options()\n\t\t(\"help,h\", \"show this help message\")\n\t\t(\"version,V\", \"show version information\")\n#ifndef _WIN32\n\t\t(\"color\", \"use VT100 color codes even when stdout is not a terminal\")\n#endif /* _WIN32 */\n\t\t(\"define,D\", po::value<std::vector<std::string> >(), \"define a constant\")\n\t\t(\"include,I\", po::value<std::vector<std::string> >(), \"add include search directory\")\n\t\t(\"log-level,x\", po::value<std::string>(), \"specify the log level for the console log.\\n\"\n\t\t\t\"The valid value is either debug, notice, information (default), warning, or critical\")\n\t\t(\"script-debugger,X\", \"whether to enable the script debugger\");\n\n\tpo::options_description hiddenDesc(\"Hidden options\");\n\n\thiddenDesc.add_options()\n\t\t(\"no-stack-rlimit\", \"used internally, do not specify manually\")\n\t\t(\"arg\", po::value<std::vector<std::string> >(), \"positional argument\");\n\n\tpo::positional_options_description positionalDesc;\n\tpositionalDesc.add(\"arg\", -1);\n\n\tString cmdname;\n\tCLICommand::Ptr command;\n\tpo::variables_map vm;\n\n\ttry {\n\t\tCLICommand::ParseCommand(argc, argv, visibleDesc, hiddenDesc, positionalDesc,\n\t\t\tvm, cmdname, command, autocomplete);\n\t} catch (const std::exception& ex) {\n\t\tLog(LogCritical, \"icinga-app\")\n\t\t\t<< \"Error while parsing command-line options: \" << ex.what();\n\t\treturn EXIT_FAILURE;\n\t}\n\n#ifdef _WIN32\n\tchar username[UNLEN + 1];\n\tDWORD usernameLen = UNLEN + 1;\n\tGetUserName(username, &usernameLen);\n\n\tstd::ifstream userFile;\n\tuserFile.open(Application::GetSysconfDir() + \"/icinga2/user\");\n\n\tif (userFile && command && !Application::IsProcessElevated()) {\n\t\tstd::string userLine;\n\t\tif (std::getline(userFile, userLine)) {\n\t\t\tuserFile.close();\n\n\t\t\tstd::vector<std::string> strs;\n\t\t\tboost::split(strs, userLine, boost::is_any_of(\"\\\\\"));\n\n\t\t\tif (username != strs[1] && command->GetImpersonationLevel() == ImpersonationLevel::ImpersonateIcinga\n\t\t\t\t|| command->GetImpersonationLevel() == ImpersonationLevel::ImpersonateRoot) {\n\t\t\t\tTCHAR szPath[MAX_PATH];\n\n\t\t\t\tif (GetModuleFileName(nullptr, szPath, ARRAYSIZE(szPath))) {\n\t\t\t\t\tSHELLEXECUTEINFO sei = { sizeof(sei) };\n\t\t\t\t\tsei.lpVerb = _T(\"runas\");\n\t\t\t\t\tsei.lpFile = \"cmd.exe\";\n\t\t\t\t\tsei.fMask = SEE_MASK_NOCLOSEPROCESS | SEE_MASK_NOASYNC | SEE_MASK_FLAG_NO_UI;\n\t\t\t\t\tsei.nShow = SW_SHOW;\n\n\t\t\t\t\tstd::stringstream parameters;\n\n\t\t\t\t\tparameters << \"/C \" << \"\\\"\" << szPath << \"\\\"\" << \" \";\n\n\t\t\t\t\tfor (int i = 1; i < argc; i++) {\n\t\t\t\t\t\tif (i != 1)\n\t\t\t\t\t\t\tparameters << \" \";\n\t\t\t\t\t\tparameters << argv[i];\n\t\t\t\t\t}\n\n\t\t\t\t\tparameters << \" & SET exitcode=%errorlevel%\";\n\t\t\t\t\tparameters << \" & pause\";\n\t\t\t\t\tparameters << \" & EXIT /B %exitcode%\";\n\n\t\t\t\t\tstd::string str = parameters.str();\n\t\t\t\t\tLPCSTR cstr = str.c_str();\n\n\t\t\t\t\tsei.lpParameters = cstr;\n\n\t\t\t\t\tif (!ShellExecuteEx(&sei)) {\n\t\t\t\t\t\tDWORD dwError = GetLastError();\n\t\t\t\t\t\tif (dwError == ERROR_CANCELLED)\n\t\t\t\t\t\t\tApplication::Exit(0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tWaitForSingleObject(sei.hProcess, INFINITE);\n\n\t\t\t\t\t\tDWORD exitCode;\n\t\t\t\t\t\tGetExitCodeProcess(sei.hProcess, &exitCode);\n\n\t\t\t\t\t\tCloseHandle(sei.hProcess);\n\n\t\t\t\t\t\tApplication::Exit(exitCode);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tuserFile.close();\n\t\t}\n\t}\n#endif /* _WIN32 */\n\n#ifndef _WIN32\n\tif (vm.count(\"color\")) {\n\t\tConsole::SetType(std::cout, Console_VT100);\n\t\tConsole::SetType(std::cerr, Console_VT100);\n\t}\n#endif /* _WIN32 */\n\n\tif (vm.count(\"define\")) {\n\t\tfor (const String& define : vm[\"define\"].as<std::vector<std::string> >()) {\n\t\t\tString key, value;\n\t\t\tsize_t pos = define.FindFirstOf('=');\n\t\t\tif (pos != String::NPos) {\n\t\t\t\tkey = define.SubStr(0, pos);\n\t\t\t\tvalue = define.SubStr(pos + 1);\n\t\t\t} else {\n\t\t\t\tkey = define;\n\t\t\t\tvalue = \"1\";\n\t\t\t}\n\t\t\tScriptGlobal::Set(key, value);\n\t\t}\n\t}\n\n\tif (vm.count(\"script-debugger\"))\n\t\tApplication::SetScriptDebuggerEnabled(true);\n\n\tApplication::DeclareStatePath(Application::GetLocalStateDir() + \"/lib/icinga2/icinga2.state\");\n\tApplication::DeclareModAttrPath(Application::GetLocalStateDir() + \"/lib/icinga2/modified-attributes.conf\");\n\tApplication::DeclareObjectsPath(Application::GetLocalStateDir() + \"/cache/icinga2/icinga2.debug\");\n\tApplication::DeclareVarsPath(Application::GetLocalStateDir() + \"/cache/icinga2/icinga2.vars\");\n\tApplication::DeclarePidPath(Application::GetRunDir() + \"/icinga2/icinga2.pid\");\n\n\tConfigCompiler::AddIncludeSearchDir(Application::GetIncludeConfDir());\n\n\tif (!autocomplete && vm.count(\"include\")) {\n\t\tfor (const String& includePath : vm[\"include\"].as<std::vector<std::string> >()) {\n\t\t\tConfigCompiler::AddIncludeSearchDir(includePath);\n\t\t}\n\t}\n\n\tif (!autocomplete) {\n\t\tLogger::SetConsoleLogSeverity(logLevel);\n\n\t\tif (vm.count(\"log-level\")) {\n\t\t\tString severity = vm[\"log-level\"].as<std::string>();\n\n\t\t\tLogSeverity logLevel = LogInformation;\n\t\t\ttry {\n\t\t\t\tlogLevel = Logger::StringToSeverity(severity);\n\t\t\t} catch (std::exception&) {\n\t\t\t\t/* Inform user and exit */\n\t\t\t\tLog(LogCritical, \"icinga-app\", \"Invalid log level set. Default is 'information'.\");\n\t\t\t\treturn EXIT_FAILURE;\n\t\t\t}\n\n\t\t\tLogger::SetConsoleLogSeverity(logLevel);\n\t\t}\n\n\t\tif (!command || vm.count(\"help\") || vm.count(\"version\")) {\n\t\t\tString appName;\n\n\t\t\ttry {\n\t\t\t\tappName = Utility::BaseName(Application::GetArgV()[0]);\n\t\t\t} catch (const std::bad_alloc&) {\n\t\t\t\tLog(LogCritical, \"icinga-app\", \"Allocation failed.\");\n\t\t\t\treturn EXIT_FAILURE;\n\t\t\t}\n\n\t\t\tif (appName.GetLength() > 3 && appName.SubStr(0, 3) == \"lt-\")\n\t\t\t\tappName = appName.SubStr(3, appName.GetLength() - 3);\n\n\t\t\tstd::cout << appName << \" \" << \"- The Icinga 2 network monitoring daemon (version: \"\n\t\t\t\t<< ConsoleColorTag(vm.count(\"version\") ? Console_ForegroundRed : Console_Normal)\n\t\t\t\t<< Application::GetAppVersion()\n#ifdef I2_DEBUG\n\t\t\t\t<< \"; debug\"\n#endif /* I2_DEBUG */\n\t\t\t\t<< ConsoleColorTag(Console_Normal)\n\t\t\t\t<< \")\" << std::endl << std::endl;\n\n\t\t\tif ((!command || vm.count(\"help\")) && !vm.count(\"version\")) {\n\t\t\t\tstd::cout << \"Usage:\" << std::endl\n\t\t\t\t\t<< \"  \" << Utility::BaseName(argv[0]) << \" \";\n\n\t\t\t\tif (cmdname.IsEmpty())\n\t\t\t\t\tstd::cout << \"<command>\";\n\t\t\t\telse\n\t\t\t\t\tstd::cout << cmdname;\n\n\t\t\t\tstd::cout << \" [<arguments>]\" << std::endl;\n\n\t\t\t\tif (command) {\n\t\t\t\t\tstd::cout << std::endl\n\t\t\t\t\t\t<< command->GetDescription() << std::endl;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (vm.count(\"version\")) {\n\t\t\t\tstd::cout << \"Copyright (c) 2012-2018 Icinga Development Team (https://www.icinga.com/)\" << std::endl\n\t\t\t\t\t<< \"License GPLv2+: GNU GPL version 2 or later <http://gnu.org/licenses/gpl2.html>\" << std::endl\n\t\t\t\t\t<< \"This is free software: you are free to change and redistribute it.\" << std::endl\n\t\t\t\t\t<< \"There is NO WARRANTY, to the extent permitted by law.\";\n\t\t\t}\n\n\t\t\tstd::cout << std::endl;\n\n\t\t\tif (vm.count(\"version\")) {\n\t\t\t\tstd::cout << std::endl;\n\n\t\t\t\tApplication::DisplayInfoMessage(std::cout, true);\n\n\t\t\t\treturn EXIT_SUCCESS;\n\t\t\t}\n\t\t}\n\n\t\tif (!command || vm.count(\"help\")) {\n\t\t\tif (!command)\n\t\t\t\tCLICommand::ShowCommands(argc, argv, nullptr);\n\n\t\t\tstd::cout << visibleDesc << std::endl\n\t\t\t\t<< \"Report bugs at <https://github.com/Icinga/icinga2>\" << std::endl\n\t\t\t\t<< \"Icinga home page: <https://www.icinga.com/>\" << std::endl;\n\t\t\treturn EXIT_SUCCESS;\n\t\t}\n\t}\n\n\tint rc = 1;\n\n\tif (autocomplete) {\n\t\tCLICommand::ShowCommands(argc, argv, &visibleDesc, &hiddenDesc,\n\t\t\t&GlobalArgumentCompletion, true, autoindex);\n\t\trc = 0;\n\t} else if (command) {\n\t\tLogger::DisableTimestamp(true);\n#ifndef _WIN32\n\t\tif (command->GetImpersonationLevel() == ImpersonateRoot) {\n\t\t\tif (getuid() != 0) {\n\t\t\t\tLog(LogCritical, \"cli\", \"This command must be run as root.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else if (command && command->GetImpersonationLevel() == ImpersonateIcinga) {\n\t\t\tString group = Application::GetRunAsGroup();\n\t\t\tString user = Application::GetRunAsUser();\n\n\t\t\terrno = 0;\n\t\t\tstruct group *gr = getgrnam(group.CStr());\n\n\t\t\tif (!gr) {\n\t\t\t\tif (errno == 0) {\n\t\t\t\t\tLog(LogCritical, \"cli\")\n\t\t\t\t\t\t<< \"Invalid group specified: \" << group;\n\t\t\t\t\treturn EXIT_FAILURE;\n\t\t\t\t} else {\n\t\t\t\t\tLog(LogCritical, \"cli\")\n\t\t\t\t\t\t<< \"getgrnam() failed with error code \" << errno << \", \\\"\" << Utility::FormatErrorNumber(errno) << \"\\\"\";\n\t\t\t\t\treturn EXIT_FAILURE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (getgid() != gr->gr_gid) {\n\t\t\t\tif (!vm.count(\"reload-internal\") && setgroups(0, nullptr) < 0) {\n\t\t\t\t\tLog(LogCritical, \"cli\")\n\t\t\t\t\t\t<< \"setgroups() failed with error code \" << errno << \", \\\"\" << Utility::FormatErrorNumber(errno) << \"\\\"\";\n\t\t\t\t\tLog(LogCritical, \"cli\")\n\t\t\t\t\t\t<< \"Please re-run this command as a privileged user or using the \\\"\" << user << \"\\\" account.\";\n\t\t\t\t\treturn EXIT_FAILURE;\n\t\t\t\t}\n\n\t\t\t\tif (setgid(gr->gr_gid) < 0) {\n\t\t\t\t\tLog(LogCritical, \"cli\")\n\t\t\t\t\t\t<< \"setgid() failed with error code \" << errno << \", \\\"\" << Utility::FormatErrorNumber(errno) << \"\\\"\";\n\t\t\t\t\treturn EXIT_FAILURE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\terrno = 0;\n\t\t\tstruct passwd *pw = getpwnam(user.CStr());\n\n\t\t\tif (!pw) {\n\t\t\t\tif (errno == 0) {\n\t\t\t\t\tLog(LogCritical, \"cli\")\n\t\t\t\t\t\t<< \"Invalid user specified: \" << user;\n\t\t\t\t\treturn EXIT_FAILURE;\n\t\t\t\t} else {\n\t\t\t\t\tLog(LogCritical, \"cli\")\n\t\t\t\t\t\t<< \"getpwnam() failed with error code \" << errno << \", \\\"\" << Utility::FormatErrorNumber(errno) << \"\\\"\";\n\t\t\t\t\treturn EXIT_FAILURE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// also activate the additional groups the configured user is member of\n\t\t\tif (getuid() != pw->pw_uid) {\n\t\t\t\tif (!vm.count(\"reload-internal\") && initgroups(user.CStr(), pw->pw_gid) < 0) {\n\t\t\t\t\tLog(LogCritical, \"cli\")\n\t\t\t\t\t\t<< \"initgroups() failed with error code \" << errno << \", \\\"\" << Utility::FormatErrorNumber(errno) << \"\\\"\";\n\t\t\t\t\tLog(LogCritical, \"cli\")\n\t\t\t\t\t\t<< \"Please re-run this command as a privileged user or using the \\\"\" << user << \"\\\" account.\";\n\t\t\t\t\treturn EXIT_FAILURE;\n\t\t\t\t}\n\n\t\t\t\tif (setuid(pw->pw_uid) < 0) {\n\t\t\t\t\tLog(LogCritical, \"cli\")\n\t\t\t\t\t\t<< \"setuid() failed with error code \" << errno << \", \\\"\" << Utility::FormatErrorNumber(errno) << \"\\\"\";\n\t\t\t\t\tLog(LogCritical, \"cli\")\n\t\t\t\t\t\t<< \"Please re-run this command as a privileged user or using the \\\"\" << user << \"\\\" account.\";\n\t\t\t\t\treturn EXIT_FAILURE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tProcess::InitializeSpawnHelper();\n#endif /* _WIN32 */\n\n\t\tstd::vector<std::string> args;\n\t\tif (vm.count(\"arg\"))\n\t\t\targs = vm[\"arg\"].as<std::vector<std::string> >();\n\n\t\tif (static_cast<int>(args.size()) < command->GetMinArguments()) {\n\t\t\tLog(LogCritical, \"cli\")\n\t\t\t\t<< \"Too few arguments. Command needs at least \" << command->GetMinArguments()\n\t\t\t\t<< \" argument\" << (command->GetMinArguments() != 1 ? \"s\" : \"\") << \".\";\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\n\t\tif (command->GetMaxArguments() >= 0 && static_cast<int>(args.size()) > command->GetMaxArguments()) {\n\t\t\tLog(LogCritical, \"cli\")\n\t\t\t\t<< \"Too many arguments. At most \" << command->GetMaxArguments()\n\t\t\t\t<< \" argument\" << (command->GetMaxArguments() != 1 ? \"s\" : \"\") << \" may be specified.\";\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\n\t\trc = command->Run(vm, args);\n\t}\n\n\treturn rc;\n}",
  "abstract_func": "static int Main()\n{\n\tint VAR_0 = Application::GetArgC();\n\tchar **VAR_1 = Application::GetArgV();\n\n\tbool VAR_2 = false;\n\tint VAR_3 = 0;\n\n\tif (VAR_0 >= 4 && strcmp(VAR_1[1], \"--autocomplete\") == 0) {\n\t\tVAR_2 = true;\n\n\t\ttry {\n\t\t\tVAR_3 = Convert::ToLong(VAR_1[2]);\n\t\t} catch (const std::invalid_argument&) {\n\t\t\tLog(VAR_4, \"icinga-app\")\n\t\t\t\t<< \"Invalid index for --autocomplete: \" << VAR_1[2];\n\t\t\treturn VAR_5;\n\t\t}\n\n\t\tVAR_0 -= 3;\n\t\tVAR_1 += 3;\n\t}\n\n\tApplication::SetStartTime(Utility::GetTime());\n\n\t/* COMMENT_0 */\n\tUtility::SetThreadName(\"Main Thread\", false);\n\n\t/* COMMENT_1 */\n\tApplication::InstallExceptionHandlers();\n\n#ifdef VAR_6\n\tbool VAR_7 = true;\n\n\tString VAR_8 = Utility::GetIcingaInstallPath();\n\tString VAR_9 = Utility::GetIcingaDataPath();\n\n\tif (!VAR_8.IsEmpty() && !VAR_9.IsEmpty()) {\n\t\tApplication::DeclarePrefixDir(VAR_8);\n\t\tApplication::DeclareSysconfDir(VAR_9 + \"\\\\etc\");\n\t\tApplication::DeclareRunDir(VAR_9 + \"\\\\var\\\\run\");\n\t\tApplication::DeclareLocalStateDir(VAR_9 + \"\\\\var\");\n\t\tApplication::DeclarePkgDataDir(VAR_8 + \"\\\\share\\\\icinga2\");\n\t\tApplication::DeclareIncludeConfDir(VAR_8 + \"\\\\share\\\\icinga2\\\\include\");\n\t} else {\n\t\tLog(VAR_10, \"icinga-app\", \"Registry key could not be read. Falling back to built-in paths.\");\n\n#endif/* COMMENT_2 */\n\t\tApplication::DeclarePrefixDir(ICINGA_PREFIX);\n\t\tApplication::DeclareSysconfigFile(VAR_11);\n\t\tApplication::DeclareSysconfDir(VAR_12);\n\t\tApplication::DeclareRunDir(VAR_13);\n\t\tApplication::DeclareLocalStateDir(VAR_14);\n\t\tApplication::DeclarePkgDataDir(VAR_15);\n\t\tApplication::DeclareIncludeConfDir(VAR_16);\n#ifdef VAR_6\n\t}\n#endif /* COMMENT_3 */\n\n\tApplication::DeclareZonesDir(Application::GetSysconfDir() + \"/icinga2/zones.d\");\n\n\tString VAR_17 = Utility::GetFromSysconfig(\"ICINGA2_USER\");\n\tif (VAR_17.IsEmpty())\n\t\tVAR_17 = VAR_18;\n\n\tString VAR_19 = Utility::GetFromSysconfig(\"ICINGA2_GROUP\");\n\tif (VAR_19.IsEmpty())\n\t\tVAR_19 = VAR_20;\n\n\tApplication::DeclareRunAsUser(VAR_17);\n\tApplication::DeclareRunAsGroup(VAR_19);\n#ifdef VAR_21\n\tApplication::DeclareRLimitFiles(Application::GetDefaultRLimitFiles());\n\tApplication::DeclareRLimitProcesses(Application::GetDefaultRLimitProcesses());\n\tApplication::DeclareRLimitStack(Application::GetDefaultRLimitStack());\n#endif /* COMMENT_4 */\n\tApplication::DeclareConcurrency(std::thread::hardware_concurrency());\n\tApplication::DeclareMaxConcurrentChecks(Application::GetDefaultMaxConcurrentChecks());\n\n\tScriptGlobal::Set(\"AttachDebugger\", false);\n\n\tScriptGlobal::Set(\"PlatformKernel\", Utility::GetPlatformKernel());\n\tScriptGlobal::Set(\"PlatformKernelVersion\", Utility::GetPlatformKernelVersion());\n\tScriptGlobal::Set(\"PlatformName\", Utility::GetPlatformName());\n\tScriptGlobal::Set(\"PlatformVersion\", Utility::GetPlatformVersion());\n\tScriptGlobal::Set(\"PlatformArchitecture\", Utility::GetPlatformArchitecture());\n\n\tScriptGlobal::Set(\"BuildHostName\", VAR_22);\n\tScriptGlobal::Set(\"BuildCompilerName\", VAR_23);\n\tScriptGlobal::Set(\"BuildCompilerVersion\", VAR_24);\n\n\tString VAR_25 = Application::GetSysconfDir() + \"/icinga2/init.conf\";\n\n\tif (Utility::PathExists(VAR_25)) {\n\t\tstd::unique_ptr<Expression> VAR_26;\n\t\ttry {\n\t\t\tVAR_26 = ConfigCompiler::CompileFile(VAR_25);\n\n\t\t\tScriptFrame VAR_27(true);\n\t\t\tVAR_26->Evaluate(VAR_27);\n\t\t} catch (const std::exception& VAR_28) {\n\t\t\tLog(VAR_4, \"config\", DiagnosticInformation(VAR_28));\n\t\t\treturn VAR_5;\n\t\t}\n\t}\n\n\tif (!VAR_2)\n\t\tApplication::SetResourceLimits();\n\n\tLogSeverity VAR_29 = Logger::GetConsoleLogSeverity();\n\tLogger::SetConsoleLogSeverity(VAR_10);\n\n\tpo::options_description VAR_30(\"Global options\");\n\n\tVAR_30.add_options()\n\t\t(\"help,h\", \"show this help message\")\n\t\t(\"version,V\", \"show version information\")\n#ifndef VAR_6\n\t\t(\"color\", \"use VT100 color codes even when stdout is not a terminal\")\n#endif /* COMMENT_3 */\n\t\t(\"define,D\", po::VAR_31<std::vector<std::string> >(), \"define a constant\")\n\t\t(\"include,I\", po::VAR_31<std::vector<std::string> >(), \"add include search directory\")\n\t\t(\"log-level,x\", po::VAR_31<std::string>(), \"specify the log level for the console log.\\n\"\n\t\t\t\"The valid value is either debug, notice, information (default), warning, or critical\")\n\t\t(\"script-debugger,X\", \"whether to enable the script debugger\");\n\n\tpo::options_description VAR_32(\"Hidden options\");\n\n\tVAR_32.add_options()\n\t\t(\"no-stack-rlimit\", \"used internally, do not specify manually\")\n\t\t(\"arg\", po::VAR_31<std::vector<std::string> >(), \"positional argument\");\n\n\tpo::positional_options_description VAR_33;\n\tVAR_33.add(\"arg\", -1);\n\n\tString VAR_34;\n\tCLICommand::Ptr VAR_35;\n\tpo::variables_map VAR_36;\n\n\ttry {\n\t\tCLICommand::ParseCommand(VAR_0, VAR_1, VAR_30, VAR_32, VAR_33,\n\t\t\tVAR_36, VAR_34, VAR_35, VAR_2);\n\t} catch (const std::exception& VAR_28) {\n\t\tLog(VAR_4, \"icinga-app\")\n\t\t\t<< \"Error while parsing command-line options: \" << VAR_28.what();\n\t\treturn VAR_5;\n\t}\n\n#ifdef VAR_6\n\tchar VAR_37[VAR_38 + 1];\n\tDWORD VAR_39 = VAR_38 + 1;\n\tGetUserName(VAR_37, &VAR_39);\n\n\tstd::ifstream VAR_40;\n\tVAR_40.open(Application::GetSysconfDir() + \"/icinga2/user\");\n\n\tif (VAR_40 && VAR_35 && !Application::IsProcessElevated()) {\n\t\tstd::string VAR_41;\n\t\tif (std::getline(VAR_40, VAR_41)) {\n\t\t\tVAR_40.close();\n\n\t\t\tstd::vector<std::string> VAR_42;\n\t\t\tboost::split(VAR_42, VAR_41, boost::is_any_of(\"\\\\\"));\n\n\t\t\tif (VAR_37 != VAR_42[1] && VAR_35->GetImpersonationLevel() == ImpersonationLevel::ImpersonateIcinga\n\t\t\t\t|| VAR_35->GetImpersonationLevel() == ImpersonationLevel::ImpersonateRoot) {\n\t\t\t\tTCHAR VAR_43[VAR_44];\n\n\t\t\t\tif (GetModuleFileName(nullptr, VAR_43, ARRAYSIZE(VAR_43))) {\n\t\t\t\t\tSHELLEXECUTEINFO VAR_45 = { sizeof(VAR_45) };\n\t\t\t\t\tVAR_45.lpVerb = _T(\"runas\");\n\t\t\t\t\tVAR_45.lpFile = \"cmd.exe\";\n\t\t\t\t\tVAR_45.fMask = VAR_46 | VAR_47 | VAR_48;\n\t\t\t\t\tVAR_45.nShow = VAR_49;\n\n\t\t\t\t\tstd::stringstream VAR_50;\n\n\t\t\t\t\tVAR_50 << \"/C \" << \"\\\"\" << VAR_43 << \"\\\"\" << \" \";\n\n\t\t\t\t\tfor (int VAR_51 = 1; VAR_51 < VAR_0; VAR_51++) {\n\t\t\t\t\t\tif (VAR_51 != 1)\n\t\t\t\t\t\t\tVAR_50 << \" \";\n\t\t\t\t\t\tVAR_50 << VAR_1[VAR_51];\n\t\t\t\t\t}\n\n\t\t\t\t\tVAR_50 << \" & SET exitcode=%errorlevel%\";\n\t\t\t\t\tVAR_50 << \" & pause\";\n\t\t\t\t\tVAR_50 << \" & EXIT /B %exitcode%\";\n\n\t\t\t\t\tstd::string VAR_52 = VAR_50.str();\n\t\t\t\t\tLPCSTR VAR_53 = VAR_52.c_str();\n\n\t\t\t\t\tVAR_45.lpParameters = VAR_53;\n\n\t\t\t\t\tif (!ShellExecuteEx(&VAR_45)) {\n\t\t\t\t\t\tDWORD VAR_54 = GetLastError();\n\t\t\t\t\t\tif (VAR_54 == VAR_55)\n\t\t\t\t\t\t\tApplication::Exit(0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tWaitForSingleObject(VAR_45.hProcess, VAR_56);\n\n\t\t\t\t\t\tDWORD VAR_57;\n\t\t\t\t\t\tGetExitCodeProcess(VAR_45.hProcess, &VAR_57);\n\n\t\t\t\t\t\tCloseHandle(VAR_45.hProcess);\n\n\t\t\t\t\t\tApplication::Exit(VAR_57);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tVAR_40.close();\n\t\t}\n\t}\n#endif /* COMMENT_3 */\n\n#ifndef VAR_6\n\tif (VAR_36.count(\"color\")) {\n\t\tConsole::SetType(std::cout, VAR_58);\n\t\tConsole::SetType(std::cerr, VAR_58);\n\t}\n#endif /* COMMENT_3 */\n\n\tif (VAR_36.count(\"define\")) {\n\t\tfor (const String& VAR_59 : VAR_36[\"define\"].as<std::vector<std::string> >()) {\n\t\t\tString VAR_60, VAR_31;\n\t\t\tsize_t VAR_61 = VAR_59.FindFirstOf('=');\n\t\t\tif (VAR_61 != String::NPos) {\n\t\t\t\tVAR_60 = VAR_59.SubStr(0, VAR_61);\n\t\t\t\tVAR_31 = VAR_59.SubStr(VAR_61 + 1);\n\t\t\t} else {\n\t\t\t\tVAR_60 = VAR_59;\n\t\t\t\tVAR_31 = \"1\";\n\t\t\t}\n\t\t\tScriptGlobal::Set(VAR_60, VAR_31);\n\t\t}\n\t}\n\n\tif (VAR_36.count(\"script-debugger\"))\n\t\tApplication::SetScriptDebuggerEnabled(true);\n\n\tApplication::DeclareStatePath(Application::GetLocalStateDir() + \"/lib/icinga2/icinga2.state\");\n\tApplication::DeclareModAttrPath(Application::GetLocalStateDir() + \"/lib/icinga2/modified-attributes.conf\");\n\tApplication::DeclareObjectsPath(Application::GetLocalStateDir() + \"/cache/icinga2/icinga2.debug\");\n\tApplication::DeclareVarsPath(Application::GetLocalStateDir() + \"/cache/icinga2/icinga2.vars\");\n\tApplication::DeclarePidPath(Application::GetRunDir() + \"/icinga2/icinga2.pid\");\n\n\tConfigCompiler::AddIncludeSearchDir(Application::GetIncludeConfDir());\n\n\tif (!VAR_2 && VAR_36.count(\"include\")) {\n\t\tfor (const String& VAR_62 : VAR_36[\"include\"].as<std::vector<std::string> >()) {\n\t\t\tConfigCompiler::AddIncludeSearchDir(VAR_62);\n\t\t}\n\t}\n\n\tif (!VAR_2) {\n\t\tLogger::SetConsoleLogSeverity(VAR_29);\n\n\t\tif (VAR_36.count(\"log-level\")) {\n\t\t\tString VAR_63 = VAR_36[\"log-level\"].as<std::string>();\n\n\t\t\tLogSeverity VAR_29 = VAR_64;\n\t\t\ttry {\n\t\t\t\tVAR_29 = Logger::StringToSeverity(VAR_63);\n\t\t\t} catch (std::exception&) {\n\t\t\t\t/* COMMENT_5 */\n\t\t\t\tLog(VAR_4, \"icinga-app\", \"Invalid log level set. Default is 'information'.\");\n\t\t\t\treturn VAR_5;\n\t\t\t}\n\n\t\t\tLogger::SetConsoleLogSeverity(VAR_29);\n\t\t}\n\n\t\tif (!VAR_35 || VAR_36.count(\"help\") || VAR_36.count(\"version\")) {\n\t\t\tString VAR_65;\n\n\t\t\ttry {\n\t\t\t\tVAR_65 = Utility::BaseName(Application::GetArgV()[0]);\n\t\t\t} catch (const std::bad_alloc&) {\n\t\t\t\tLog(VAR_4, \"icinga-app\", \"Allocation failed.\");\n\t\t\t\treturn VAR_5;\n\t\t\t}\n\n\t\t\tif (VAR_65.GetLength() > 3 && VAR_65.SubStr(0, 3) == \"lt-\")\n\t\t\t\tVAR_65 = VAR_65.SubStr(3, VAR_65.GetLength() - 3);\n\n\t\t\tstd::cout << VAR_65 << \" \" << \"- The Icinga 2 network monitoring daemon (version: \"\n\t\t\t\t<< ConsoleColorTag(VAR_36.count(\"version\") ? VAR_66 : VAR_67)\n\t\t\t\t<< Application::GetAppVersion()\n#ifdef VAR_68\n\t\t\t\t<< \"; debug\"\n#endif /* COMMENT_6 */\n\t\t\t\t<< ConsoleColorTag(VAR_67)\n\t\t\t\t<< \")\" << std::endl << std::endl;\n\n\t\t\tif ((!VAR_35 || VAR_36.count(\"help\")) && !VAR_36.count(\"version\")) {\n\t\t\t\tstd::cout << \"Usage:\" << std::endl\n\t\t\t\t\t<< \"  \" << Utility::BaseName(VAR_1[0]) << \" \";\n\n\t\t\t\tif (VAR_34.IsEmpty())\n\t\t\t\t\tstd::cout << \"<command>\";\n\t\t\t\telse\n\t\t\t\t\tstd::cout << VAR_34;\n\n\t\t\t\tstd::cout << \" [<arguments>]\" << std::endl;\n\n\t\t\t\tif (VAR_35) {\n\t\t\t\t\tstd::cout << std::endl\n\t\t\t\t\t\t<< VAR_35->GetDescription() << std::endl;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (VAR_36.count(\"version\")) {\n\t\t\t\tstd::cout << \"Copyright (c) 2012-2018 Icinga Development Team (https://www.icinga.com/)\" << std::endl\n\t\t\t\t\t<< \"License GPLv2+: GNU GPL version 2 or later <http://gnu.org/licenses/gpl2.html>\" << std::endl\n\t\t\t\t\t<< \"This is free software: you are free to change and redistribute it.\" << std::endl\n\t\t\t\t\t<< \"There is NO WARRANTY, to the extent permitted by law.\";\n\t\t\t}\n\n\t\t\tstd::cout << std::endl;\n\n\t\t\tif (VAR_36.count(\"version\")) {\n\t\t\t\tstd::cout << std::endl;\n\n\t\t\t\tApplication::DisplayInfoMessage(std::cout, true);\n\n\t\t\t\treturn VAR_69;\n\t\t\t}\n\t\t}\n\n\t\tif (!VAR_35 || VAR_36.count(\"help\")) {\n\t\t\tif (!VAR_35)\n\t\t\t\tCLICommand::ShowCommands(VAR_0, VAR_1, nullptr);\n\n\t\t\tstd::cout << VAR_30 << std::endl\n\t\t\t\t<< \"Report bugs at <https://github.com/Icinga/icinga2>\" << std::endl\n\t\t\t\t<< \"Icinga home page: <https://www.icinga.com/>\" << std::endl;\n\t\t\treturn VAR_69;\n\t\t}\n\t}\n\n\tint VAR_70 = 1;\n\n\tif (VAR_2) {\n\t\tCLICommand::ShowCommands(VAR_0, VAR_1, &VAR_30, &VAR_32,\n\t\t\t&VAR_71, true, VAR_3);\n\t\tVAR_70 = 0;\n\t} else if (VAR_35) {\n\t\tLogger::DisableTimestamp(true);\n#ifndef VAR_6\n\t\tif (VAR_35->GetImpersonationLevel() == VAR_72) {\n\t\t\tif (getuid() != 0) {\n\t\t\t\tLog(VAR_4, \"cli\", \"This command must be run as root.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else if (VAR_35 && VAR_35->GetImpersonationLevel() == VAR_73) {\n\t\t\tString VAR_74 = Application::GetRunAsGroup();\n\t\t\tString VAR_75 = Application::GetRunAsUser();\n\n\t\t\tVAR_76 = 0;\n\t\t\tstruct group *VAR_77 = getgrnam(group.CStr());\n\n\t\t\tif (!VAR_77) {\n\t\t\t\tif (VAR_76 == 0) {\n\t\t\t\t\tLog(VAR_4, \"cli\")\n\t\t\t\t\t\t<< \"Invalid group specified: \" << group;\n\t\t\t\t\treturn VAR_5;\n\t\t\t\t} else {\n\t\t\t\t\tLog(VAR_4, \"cli\")\n\t\t\t\t\t\t<< \"getgrnam() failed with error code \" << VAR_76 << \", \\\"\" << Utility::FormatErrorNumber(VAR_76) << \"\\\"\";\n\t\t\t\t\treturn VAR_5;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (getgid() != VAR_77->gr_gid) {\n\t\t\t\tif (!VAR_36.count(\"reload-internal\") && setgroups(0, nullptr) < 0) {\n\t\t\t\t\tLog(VAR_4, \"cli\")\n\t\t\t\t\t\t<< \"setgroups() failed with error code \" << VAR_76 << \", \\\"\" << Utility::FormatErrorNumber(VAR_76) << \"\\\"\";\n\t\t\t\t\tLog(VAR_4, \"cli\")\n\t\t\t\t\t\t<< \"Please re-run this command as a privileged user or using the \\\"\" << VAR_75 << \"\\\" account.\";\n\t\t\t\t\treturn VAR_5;\n\t\t\t\t}\n\n\t\t\t\tif (setgid(VAR_77->gr_gid) < 0) {\n\t\t\t\t\tLog(VAR_4, \"cli\")\n\t\t\t\t\t\t<< \"setgid() failed with error code \" << VAR_76 << \", \\\"\" << Utility::FormatErrorNumber(VAR_76) << \"\\\"\";\n\t\t\t\t\treturn VAR_5;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tVAR_76 = 0;\n\t\t\tstruct passwd *VAR_78 = getpwnam(VAR_75.CStr());\n\n\t\t\tif (!VAR_78) {\n\t\t\t\tif (VAR_76 == 0) {\n\t\t\t\t\tLog(VAR_4, \"cli\")\n\t\t\t\t\t\t<< \"Invalid user specified: \" << VAR_75;\n\t\t\t\t\treturn VAR_5;\n\t\t\t\t} else {\n\t\t\t\t\tLog(VAR_4, \"cli\")\n\t\t\t\t\t\t<< \"getpwnam() failed with error code \" << VAR_76 << \", \\\"\" << Utility::FormatErrorNumber(VAR_76) << \"\\\"\";\n\t\t\t\t\treturn VAR_5;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* COMMENT_7 */\n\t\t\tif (getuid() != VAR_78->pw_uid) {\n\t\t\t\tif (!VAR_36.count(\"reload-internal\") && initgroups(VAR_75.CStr(), VAR_78->pw_gid) < 0) {\n\t\t\t\t\tLog(VAR_4, \"cli\")\n\t\t\t\t\t\t<< \"initgroups() failed with error code \" << VAR_76 << \", \\\"\" << Utility::FormatErrorNumber(VAR_76) << \"\\\"\";\n\t\t\t\t\tLog(VAR_4, \"cli\")\n\t\t\t\t\t\t<< \"Please re-run this command as a privileged user or using the \\\"\" << VAR_75 << \"\\\" account.\";\n\t\t\t\t\treturn VAR_5;\n\t\t\t\t}\n\n\t\t\t\tif (setuid(VAR_78->pw_uid) < 0) {\n\t\t\t\t\tLog(VAR_4, \"cli\")\n\t\t\t\t\t\t<< \"setuid() failed with error code \" << VAR_76 << \", \\\"\" << Utility::FormatErrorNumber(VAR_76) << \"\\\"\";\n\t\t\t\t\tLog(VAR_4, \"cli\")\n\t\t\t\t\t\t<< \"Please re-run this command as a privileged user or using the \\\"\" << VAR_75 << \"\\\" account.\";\n\t\t\t\t\treturn VAR_5;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tProcess::InitializeSpawnHelper();\n#endif /* COMMENT_3 */\n\n\t\tstd::vector<std::string> VAR_79;\n\t\tif (VAR_36.count(\"arg\"))\n\t\t\tVAR_79 = VAR_36[\"arg\"].as<std::vector<std::string> >();\n\n\t\tif (VAR_80<int>(VAR_79.size()) < VAR_35->GetMinArguments()) {\n\t\t\tLog(VAR_4, \"cli\")\n\t\t\t\t<< \"Too few arguments. Command needs at least \" << VAR_35->GetMinArguments()\n\t\t\t\t<< \" argument\" << (VAR_35->GetMinArguments() != 1 ? \"s\" : \"\") << \".\";\n\t\t\treturn VAR_5;\n\t\t}\n\n\t\tif (VAR_35->GetMaxArguments() >= 0 && VAR_80<int>(VAR_79.size()) > VAR_35->GetMaxArguments()) {\n\t\t\tLog(VAR_4, \"cli\")\n\t\t\t\t<< \"Too many arguments. At most \" << VAR_35->GetMaxArguments()\n\t\t\t\t<< \" argument\" << (VAR_35->GetMaxArguments() != 1 ? \"s\" : \"\") << \" may be specified.\";\n\t\t\treturn VAR_5;\n\t\t}\n\n\t\tVAR_70 = VAR_35->Run(VAR_36, VAR_79);\n\t}\n\n\treturn VAR_70;\n}",
  "func_graph_path": "Icinga/icinga2/c8c193a9d825acc6c6da8fc33688971d01c7fbd7/icinga.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -47,6 +47,7 @@\n \n #endif /* _WIN32 */\n \t\tApplication::DeclarePrefixDir(ICINGA_PREFIX);\n+\t\tApplication::DeclareSysconfigFile(ICINGA_SYSCONFIGFILE);\n \t\tApplication::DeclareSysconfDir(ICINGA_SYSCONFDIR);\n \t\tApplication::DeclareRunDir(ICINGA_RUNDIR);\n \t\tApplication::DeclareLocalStateDir(ICINGA_LOCALSTATEDIR);\n@@ -57,8 +58,17 @@\n #endif /* _WIN32 */\n \n \tApplication::DeclareZonesDir(Application::GetSysconfDir() + \"/icinga2/zones.d\");\n-\tApplication::DeclareRunAsUser(ICINGA_USER);\n-\tApplication::DeclareRunAsGroup(ICINGA_GROUP);\n+\n+\tString icinga_user = Utility::GetFromSysconfig(\"ICINGA2_USER\");\n+\tif (icinga_user.IsEmpty())\n+\t\ticinga_user = ICINGA_USER;\n+\n+\tString icinga_group = Utility::GetFromSysconfig(\"ICINGA2_GROUP\");\n+\tif (icinga_group.IsEmpty())\n+\t\ticinga_group = ICINGA_GROUP;\n+\n+\tApplication::DeclareRunAsUser(icinga_user);\n+\tApplication::DeclareRunAsGroup(icinga_group);\n #ifdef __linux__\n \tApplication::DeclareRLimitFiles(Application::GetDefaultRLimitFiles());\n \tApplication::DeclareRLimitProcesses(Application::GetDefaultRLimitProcesses());",
  "diff_line_info": {
    "deleted_lines": [
      "\tApplication::DeclareRunAsUser(ICINGA_USER);",
      "\tApplication::DeclareRunAsGroup(ICINGA_GROUP);"
    ],
    "added_lines": [
      "\t\tApplication::DeclareSysconfigFile(ICINGA_SYSCONFIGFILE);",
      "",
      "\tString icinga_user = Utility::GetFromSysconfig(\"ICINGA2_USER\");",
      "\tif (icinga_user.IsEmpty())",
      "\t\ticinga_user = ICINGA_USER;",
      "",
      "\tString icinga_group = Utility::GetFromSysconfig(\"ICINGA2_GROUP\");",
      "\tif (icinga_group.IsEmpty())",
      "\t\ticinga_group = ICINGA_GROUP;",
      "",
      "\tApplication::DeclareRunAsUser(icinga_user);",
      "\tApplication::DeclareRunAsGroup(icinga_group);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/Icinga/icinga2/pull/5850",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/Icinga/icinga2/pull/5850: 403 Client Error: Forbidden for url: https://api.github.com/repos/Icinga/icinga2/pulls/5850",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.8"
}