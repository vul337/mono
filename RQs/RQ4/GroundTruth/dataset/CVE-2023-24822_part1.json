{
  "cve_id": "CVE-2023-24822",
  "cwe_ids": [
    "CWE-476"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "RIOT-OS/RIOT",
  "commit_msg": "gnrc_sixlowpan_iphc: fix null pointer dereference in _iphc_encode()",
  "commit_hash": "639c04325de4ceb9d444955f4927bfae95843a39",
  "git_url": "https://github.com/RIOT-OS/RIOT/commit/639c04325de4ceb9d444955f4927bfae95843a39",
  "file_path": "sys/net/gnrc/network_layer/sixlowpan/iphc/gnrc_sixlowpan_iphc.c",
  "func_name": "_iphc_encode",
  "func_before": "static gnrc_pktsnip_t *_iphc_encode(gnrc_pktsnip_t *pkt,\n                                    const gnrc_netif_hdr_t *netif_hdr,\n                                    gnrc_netif_t *iface)\n{\n    assert(pkt != NULL);\n    uint8_t *iphc_hdr;\n    gnrc_pktsnip_t *dispatch, *ptr = pkt->next;\n    size_t dispatch_size = 0;\n    uint16_t inline_pos = 0;\n    uint8_t nh;\n\n    dispatch = NULL;    /* use dispatch as temporary pointer for prev */\n    /* determine maximum dispatch size and write protect all headers until\n     * then because they will be removed */\n    while ((ptr != NULL) && _compressible(ptr)) {\n        gnrc_pktsnip_t *tmp = gnrc_pktbuf_start_write(ptr);\n\n        if (tmp == NULL) {\n            DEBUG(\"6lo iphc: unable to write protect compressible header\\n\");\n            return NULL;\n        }\n        ptr = tmp;\n        if (dispatch == NULL) {\n            /* pkt was already write protected in gnrc_sixlowpan.c:_send so\n             * we shouldn't do it again */\n            pkt->next = ptr;    /* reset original packet */\n        }\n        else {\n            dispatch->next = ptr;\n        }\n        if (ptr->type == GNRC_NETTYPE_UNDEF) {\n            /* most likely UDP for now so use that (XXX: extend if extension\n             * headers make problems) */\n            dispatch_size += sizeof(udp_hdr_t);\n            break;  /* nothing special after UDP so quit even if more UNDEF\n                     * come */\n        }\n        else {\n            dispatch_size += ptr->size;\n        }\n        dispatch = ptr; /* use dispatch as temporary point for prev */\n        ptr = ptr->next;\n    }\n    /* there should be at least one compressible header in `pkt`, otherwise this\n     * function should not be called */\n    assert(dispatch_size > 0);\n    dispatch = gnrc_pktbuf_add(NULL, NULL, dispatch_size + 1,\n                               GNRC_NETTYPE_SIXLOWPAN);\n\n    if (dispatch == NULL) {\n        DEBUG(\"6lo iphc: error allocating dispatch space\\n\");\n        return NULL;\n    }\n\n    iphc_hdr = dispatch->data;\n    inline_pos = _iphc_ipv6_encode(pkt, netif_hdr, iface, iphc_hdr);\n\n    if (inline_pos == 0) {\n        DEBUG(\"6lo iphc: error encoding IPv6 header\\n\");\n        gnrc_pktbuf_release(dispatch);\n        return NULL;\n    }\n\n    nh = ((ipv6_hdr_t *)pkt->next->data)->nh;\n#ifdef MODULE_GNRC_SIXLOWPAN_IPHC_NHC\n    while (_compressible_nh(nh)) {\n        ssize_t local_pos = 0;\n        switch (nh) {\n            case PROTNUM_UDP:\n                local_pos = _nhc_udp_encode_snip(pkt, &iphc_hdr[inline_pos]);\n                /* abort loop on next iteration */\n                nh = PROTNUM_RESERVED;\n                break;\n            case PROTNUM_IPV6: {    /* encapsulated IPv6 header */\n                local_pos = _nhc_ipv6_encode_snip(pkt, netif_hdr, iface,\n                                                  &iphc_hdr[inline_pos], &nh);\n                break;\n            }\n            case PROTNUM_IPV6_EXT_HOPOPT:\n            case PROTNUM_IPV6_EXT_RH:\n            case PROTNUM_IPV6_EXT_FRAG:\n            case PROTNUM_IPV6_EXT_DST:\n            case PROTNUM_IPV6_EXT_MOB:\n                local_pos = _nhc_ipv6_ext_encode_snip(pkt,\n                                                      &iphc_hdr[inline_pos],\n                                                      &nh);\n                if (local_pos == 0) {\n                    /* abort loop, extension header is not compressible as\n                     * length field is too large value */\n                    nh = PROTNUM_RESERVED;\n                }\n                break;\n            default:\n                /* abort loop on next iteration */\n                nh = PROTNUM_RESERVED;\n                break;\n        }\n        if (local_pos < 0) {\n            DEBUG(\"6lo iphc: error on compressing next header\\n\");\n            gnrc_pktbuf_release(dispatch);\n            return NULL;\n        }\n        inline_pos += local_pos;\n    }\n#endif\n\n    /* shrink dispatch allocation to final size */\n    /* NOTE: Since this only shrinks the data nothing bad SHOULD happen ;-) */\n    gnrc_pktbuf_realloc_data(dispatch, (size_t)inline_pos);\n\n    /* remove IPv6 header */\n    pkt = gnrc_pktbuf_remove_snip(pkt, pkt->next);\n\n    /* insert dispatch into packet */\n    dispatch->next = pkt->next;\n    pkt->next = dispatch;\n    return pkt;\n}",
  "abstract_func_before": "static gnrc_pktsnip_t *_iphc_encode(gnrc_pktsnip_t *VAR_0,\n                                    const gnrc_netif_hdr_t *VAR_1,\n                                    gnrc_netif_t *VAR_2)\n{\n    assert(VAR_0 != NULL);\n    uint8_t *VAR_3;\n    gnrc_pktsnip_t *VAR_4, *VAR_5 = VAR_0->next;\n    size_t VAR_6 = 0;\n    uint16_t VAR_7 = 0;\n    uint8_t VAR_8;\n\n    VAR_4 = NULL;    /* COMMENT_0 */\n    /* COMMENT_1 */\n                                           \n    while ((VAR_5 != NULL) && _compressible(VAR_5)) {\n        gnrc_pktsnip_t *VAR_9 = gnrc_pktbuf_start_write(VAR_5);\n\n        if (VAR_9 == NULL) {\n            DEBUG(\"6lo iphc: unable to write protect compressible header\\n\");\n            return NULL;\n        }\n        VAR_5 = VAR_9;\n        if (VAR_4 == NULL) {\n            /* COMMENT_3 */\n                                          \n            VAR_0->next = VAR_5;    /* COMMENT_5 */\n        }\n        else {\n            VAR_4->next = VAR_5;\n        }\n        if (VAR_5->type == VAR_10) {\n            /* COMMENT_6 */\n                                        \n            VAR_6 += sizeof(VAR_11);\n            break;  /* COMMENT_8 */\n                              \n        }\n        else {\n            VAR_6 += VAR_5->size;\n        }\n        VAR_4 = VAR_5; /* COMMENT_10 */\n        VAR_5 = VAR_5->next;\n    }\n    /* COMMENT_11 */\n                                       \n    assert(VAR_6 > 0);\n    VAR_4 = gnrc_pktbuf_add(NULL, NULL, VAR_6 + 1,\n                               VAR_12);\n\n    if (VAR_4 == NULL) {\n        DEBUG(\"6lo iphc: error allocating dispatch space\\n\");\n        return NULL;\n    }\n\n    VAR_3 = VAR_4->data;\n    VAR_7 = _iphc_ipv6_encode(VAR_0, VAR_1, VAR_2, VAR_3);\n\n    if (VAR_7 == 0) {\n        DEBUG(\"6lo iphc: error encoding IPv6 header\\n\");\n        gnrc_pktbuf_release(VAR_4);\n        return NULL;\n    }\n\n    VAR_8 = ((ipv6_hdr_t *)VAR_0->next->data)->nh;\n#ifdef VAR_13\n    while (_compressible_nh(VAR_8)) {\n        ssize_t VAR_14 = 0;\n        switch (VAR_8) {\n            case VAR_15:\n                VAR_14 = _nhc_udp_encode_snip(VAR_0, &VAR_3[VAR_7]);\n                /* COMMENT_13 */\n                VAR_8 = VAR_16;\n                break;\n            case VAR_17: {    /* COMMENT_14 */\n                VAR_14 = _nhc_ipv6_encode_snip(VAR_0, VAR_1, VAR_2,\n                                                  &VAR_3[VAR_7], &VAR_8);\n                break;\n            }\n            case VAR_18:\n            case VAR_19:\n            case VAR_20:\n            case VAR_21:\n            case VAR_22:\n                VAR_14 = _nhc_ipv6_ext_encode_snip(VAR_0,\n                                                      &VAR_3[VAR_7],\n                                                      &VAR_8);\n                if (VAR_14 == 0) {\n                    /* COMMENT_15 */\n                                                         \n                    VAR_8 = VAR_16;\n                }\n                break;\n            default:\n                /* COMMENT_13 */\n                VAR_8 = VAR_16;\n                break;\n        }\n        if (VAR_14 < 0) {\n            DEBUG(\"6lo iphc: error on compressing next header\\n\");\n            gnrc_pktbuf_release(VAR_4);\n            return NULL;\n        }\n        VAR_7 += VAR_14;\n    }\n#endif\n\n    /* COMMENT_17 */\n    /* COMMENT_18 */\n    gnrc_pktbuf_realloc_data(VAR_4, (size_t)VAR_7);\n\n    /* COMMENT_19 */\n    VAR_0 = gnrc_pktbuf_remove_snip(VAR_0, VAR_0->next);\n\n    /* COMMENT_20 */\n    VAR_4->next = VAR_0->next;\n    VAR_0->next = VAR_4;\n    return VAR_0;\n}",
  "func_graph_path_before": "RIOT-OS/RIOT/639c04325de4ceb9d444955f4927bfae95843a39/gnrc_sixlowpan_iphc.c/vul/before/0.json",
  "func": "static gnrc_pktsnip_t *_iphc_encode(gnrc_pktsnip_t *pkt,\n                                    const gnrc_netif_hdr_t *netif_hdr,\n                                    gnrc_netif_t *iface)\n{\n    assert(pkt != NULL);\n    uint8_t *iphc_hdr;\n    gnrc_pktsnip_t *dispatch, *ptr = pkt->next;\n    size_t dispatch_size = 0;\n    uint16_t inline_pos = 0;\n    uint8_t nh;\n\n    dispatch = NULL;    /* use dispatch as temporary pointer for prev */\n    /* determine maximum dispatch size and write protect all headers until\n     * then because they will be removed */\n    while ((ptr != NULL) && _compressible(ptr)) {\n        gnrc_pktsnip_t *tmp = gnrc_pktbuf_start_write(ptr);\n\n        if (tmp == NULL) {\n            DEBUG(\"6lo iphc: unable to write protect compressible header\\n\");\n            return NULL;\n        }\n        ptr = tmp;\n        if (dispatch == NULL) {\n            /* pkt was already write protected in gnrc_sixlowpan.c:_send so\n             * we shouldn't do it again */\n            pkt->next = ptr;    /* reset original packet */\n        }\n        else {\n            dispatch->next = ptr;\n        }\n        if (ptr->type == GNRC_NETTYPE_UNDEF) {\n            /* most likely UDP for now so use that (XXX: extend if extension\n             * headers make problems) */\n            dispatch_size += sizeof(udp_hdr_t);\n            break;  /* nothing special after UDP so quit even if more UNDEF\n                     * come */\n        }\n        else {\n            dispatch_size += ptr->size;\n        }\n        dispatch = ptr; /* use dispatch as temporary point for prev */\n        ptr = ptr->next;\n    }\n    /* there should be at least one compressible header in `pkt`, otherwise this\n     * function should not be called */\n    assert(dispatch_size > 0);\n    dispatch = gnrc_pktbuf_add(NULL, NULL, dispatch_size + 1,\n                               GNRC_NETTYPE_SIXLOWPAN);\n\n    if (dispatch == NULL) {\n        DEBUG(\"6lo iphc: error allocating dispatch space\\n\");\n        return NULL;\n    }\n\n    iphc_hdr = dispatch->data;\n    inline_pos = _iphc_ipv6_encode(pkt, netif_hdr, iface, iphc_hdr);\n\n    if (inline_pos == 0) {\n        DEBUG(\"6lo iphc: error encoding IPv6 header\\n\");\n        gnrc_pktbuf_release(dispatch);\n        return NULL;\n    }\n\n    nh = ((ipv6_hdr_t *)pkt->next->data)->nh;\n#ifdef MODULE_GNRC_SIXLOWPAN_IPHC_NHC\n    while (_compressible_nh(nh)) {\n        ssize_t local_pos = 0;\n        if (pkt->next->next == NULL) {\n            DEBUG(\"6lo iphc: packet next header missing data\");\n            gnrc_pktbuf_release(dispatch);\n            return NULL;\n        }\n        switch (nh) {\n            case PROTNUM_UDP:\n                local_pos = _nhc_udp_encode_snip(pkt, &iphc_hdr[inline_pos]);\n                /* abort loop on next iteration */\n                nh = PROTNUM_RESERVED;\n                break;\n            case PROTNUM_IPV6: {    /* encapsulated IPv6 header */\n                local_pos = _nhc_ipv6_encode_snip(pkt, netif_hdr, iface,\n                                                  &iphc_hdr[inline_pos], &nh);\n                break;\n            }\n            case PROTNUM_IPV6_EXT_HOPOPT:\n            case PROTNUM_IPV6_EXT_RH:\n            case PROTNUM_IPV6_EXT_FRAG:\n            case PROTNUM_IPV6_EXT_DST:\n            case PROTNUM_IPV6_EXT_MOB:\n                local_pos = _nhc_ipv6_ext_encode_snip(pkt,\n                                                      &iphc_hdr[inline_pos],\n                                                      &nh);\n                if (local_pos == 0) {\n                    /* abort loop, extension header is not compressible as\n                     * length field is too large value */\n                    nh = PROTNUM_RESERVED;\n                }\n                break;\n            default:\n                /* abort loop on next iteration */\n                nh = PROTNUM_RESERVED;\n                break;\n        }\n        if (local_pos < 0) {\n            DEBUG(\"6lo iphc: error on compressing next header\\n\");\n            gnrc_pktbuf_release(dispatch);\n            return NULL;\n        }\n        inline_pos += local_pos;\n    }\n#endif\n\n    /* shrink dispatch allocation to final size */\n    /* NOTE: Since this only shrinks the data nothing bad SHOULD happen ;-) */\n    gnrc_pktbuf_realloc_data(dispatch, (size_t)inline_pos);\n\n    /* remove IPv6 header */\n    pkt = gnrc_pktbuf_remove_snip(pkt, pkt->next);\n\n    /* insert dispatch into packet */\n    dispatch->next = pkt->next;\n    pkt->next = dispatch;\n    return pkt;\n}",
  "abstract_func": "static gnrc_pktsnip_t *_iphc_encode(gnrc_pktsnip_t *VAR_0,\n                                    const gnrc_netif_hdr_t *VAR_1,\n                                    gnrc_netif_t *VAR_2)\n{\n    assert(VAR_0 != NULL);\n    uint8_t *VAR_3;\n    gnrc_pktsnip_t *VAR_4, *VAR_5 = VAR_0->next;\n    size_t VAR_6 = 0;\n    uint16_t VAR_7 = 0;\n    uint8_t VAR_8;\n\n    VAR_4 = NULL;    /* COMMENT_0 */\n    /* COMMENT_1 */\n                                           \n    while ((VAR_5 != NULL) && _compressible(VAR_5)) {\n        gnrc_pktsnip_t *VAR_9 = gnrc_pktbuf_start_write(VAR_5);\n\n        if (VAR_9 == NULL) {\n            DEBUG(\"6lo iphc: unable to write protect compressible header\\n\");\n            return NULL;\n        }\n        VAR_5 = VAR_9;\n        if (VAR_4 == NULL) {\n            /* COMMENT_3 */\n                                          \n            VAR_0->next = VAR_5;    /* COMMENT_5 */\n        }\n        else {\n            VAR_4->next = VAR_5;\n        }\n        if (VAR_5->type == VAR_10) {\n            /* COMMENT_6 */\n                                        \n            VAR_6 += sizeof(VAR_11);\n            break;  /* COMMENT_8 */\n                              \n        }\n        else {\n            VAR_6 += VAR_5->size;\n        }\n        VAR_4 = VAR_5; /* COMMENT_10 */\n        VAR_5 = VAR_5->next;\n    }\n    /* COMMENT_11 */\n                                       \n    assert(VAR_6 > 0);\n    VAR_4 = gnrc_pktbuf_add(NULL, NULL, VAR_6 + 1,\n                               VAR_12);\n\n    if (VAR_4 == NULL) {\n        DEBUG(\"6lo iphc: error allocating dispatch space\\n\");\n        return NULL;\n    }\n\n    VAR_3 = VAR_4->data;\n    VAR_7 = _iphc_ipv6_encode(VAR_0, VAR_1, VAR_2, VAR_3);\n\n    if (VAR_7 == 0) {\n        DEBUG(\"6lo iphc: error encoding IPv6 header\\n\");\n        gnrc_pktbuf_release(VAR_4);\n        return NULL;\n    }\n\n    VAR_8 = ((ipv6_hdr_t *)VAR_0->next->data)->nh;\n#ifdef VAR_13\n    while (_compressible_nh(VAR_8)) {\n        ssize_t VAR_14 = 0;\n        if (VAR_0->next->next == NULL) {\n            DEBUG(\"6lo iphc: packet next header missing data\");\n            gnrc_pktbuf_release(VAR_4);\n            return NULL;\n        }\n        switch (VAR_8) {\n            case VAR_15:\n                VAR_14 = _nhc_udp_encode_snip(VAR_0, &VAR_3[VAR_7]);\n                /* COMMENT_13 */\n                VAR_8 = VAR_16;\n                break;\n            case VAR_17: {    /* COMMENT_14 */\n                VAR_14 = _nhc_ipv6_encode_snip(VAR_0, VAR_1, VAR_2,\n                                                  &VAR_3[VAR_7], &VAR_8);\n                break;\n            }\n            case VAR_18:\n            case VAR_19:\n            case VAR_20:\n            case VAR_21:\n            case VAR_22:\n                VAR_14 = _nhc_ipv6_ext_encode_snip(VAR_0,\n                                                      &VAR_3[VAR_7],\n                                                      &VAR_8);\n                if (VAR_14 == 0) {\n                    /* COMMENT_15 */\n                                                         \n                    VAR_8 = VAR_16;\n                }\n                break;\n            default:\n                /* COMMENT_13 */\n                VAR_8 = VAR_16;\n                break;\n        }\n        if (VAR_14 < 0) {\n            DEBUG(\"6lo iphc: error on compressing next header\\n\");\n            gnrc_pktbuf_release(VAR_4);\n            return NULL;\n        }\n        VAR_7 += VAR_14;\n    }\n#endif\n\n    /* COMMENT_17 */\n    /* COMMENT_18 */\n    gnrc_pktbuf_realloc_data(VAR_4, (size_t)VAR_7);\n\n    /* COMMENT_19 */\n    VAR_0 = gnrc_pktbuf_remove_snip(VAR_0, VAR_0->next);\n\n    /* COMMENT_20 */\n    VAR_4->next = VAR_0->next;\n    VAR_0->next = VAR_4;\n    return VAR_0;\n}",
  "func_graph_path": "RIOT-OS/RIOT/639c04325de4ceb9d444955f4927bfae95843a39/gnrc_sixlowpan_iphc.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -65,6 +65,11 @@\n #ifdef MODULE_GNRC_SIXLOWPAN_IPHC_NHC\n     while (_compressible_nh(nh)) {\n         ssize_t local_pos = 0;\n+        if (pkt->next->next == NULL) {\n+            DEBUG(\"6lo iphc: packet next header missing data\");\n+            gnrc_pktbuf_release(dispatch);\n+            return NULL;\n+        }\n         switch (nh) {\n             case PROTNUM_UDP:\n                 local_pos = _nhc_udp_encode_snip(pkt, &iphc_hdr[inline_pos]);",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "        if (pkt->next->next == NULL) {",
      "            DEBUG(\"6lo iphc: packet next header missing data\");",
      "            gnrc_pktbuf_release(dispatch);",
      "            return NULL;",
      "        }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/RIOT-OS/RIOT/pull/18817",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/RIOT-OS/RIOT/pull/18817: 403 Client Error: Forbidden for url: https://api.github.com/repos/RIOT-OS/RIOT/pulls/18817",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.85,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.85"
}