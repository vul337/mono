{
  "cve_id": "CVE-2019-12098",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "heimdal",
  "commit_msg": "CVE-2019-12098: krb5: always confirm PA-PKINIT-KX for anon PKINIT\n\nRFC8062 Section 7 requires verification of the PA-PKINIT-KX key excahnge\nwhen anonymous PKINIT is used.  Failure to do so can permit an active\nattacker to become a man-in-the-middle.\n\nIntroduced by a1ef548600c5bb51cf52a9a9ea12676506ede19f.  First tagged\nrelease Heimdal 1.4.0.\n\nCVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:L/A:N (4.8)\n\nChange-Id: I6cc1c0c24985936468af08693839ac6c3edda133\nSigned-off-by: Jeffrey Altman <jaltman@auristor.com>\nApproved-by: Jeffrey Altman <jaltman@auritor.com>\n(cherry picked from commit 38c797e1ae9b9c8f99ae4aa2e73957679031fd2b)",
  "commit_hash": "2f7f3d9960aa6ea21358bdf3687cee5149aa35cf",
  "git_url": "https://github.com/heimdal/heimdal/commit/2f7f3d9960aa6ea21358bdf3687cee5149aa35cf",
  "file_path": "lib/krb5/init_creds_pw.c",
  "func_name": "krb5_init_creds_step",
  "func_before": "KRB5_LIB_CALL\nkrb5_init_creds_step(krb5_context context,\n\t\t     krb5_init_creds_context ctx,\n\t\t     krb5_data *in,\n\t\t     krb5_data *out,\n\t\t     krb5_krbhst_info *hostinfo,\n\t\t     unsigned int *flags)\n{\n    krb5_error_code ret;\n    size_t len = 0;\n    size_t size;\n    AS_REQ req2;\n\n    krb5_data_zero(out);\n\n    if (ctx->as_req.req_body.cname == NULL) {\n\tret = init_as_req(context, ctx->flags, &ctx->cred,\n\t\t\t  ctx->addrs, ctx->etypes, &ctx->as_req);\n\tif (ret) {\n\t    free_init_creds_ctx(context, ctx);\n\t    return ret;\n\t}\n    }\n\n#define MAX_PA_COUNTER 10\n    if (ctx->pa_counter > MAX_PA_COUNTER) {\n\tkrb5_set_error_message(context, KRB5_GET_IN_TKT_LOOP,\n\t\t\t       N_(\"Looping %d times while getting \"\n\t\t\t\t  \"initial credentials\", \"\"),\n\t\t\t       ctx->pa_counter);\n\treturn KRB5_GET_IN_TKT_LOOP;\n    }\n    ctx->pa_counter++;\n\n    _krb5_debug(context, 5, \"krb5_get_init_creds: loop %d\", ctx->pa_counter);\n\n    /* Lets process the input packet */\n    if (in && in->length) {\n\tkrb5_kdc_rep rep;\n\n\tmemset(&rep, 0, sizeof(rep));\n\n\t_krb5_debug(context, 5, \"krb5_get_init_creds: processing input\");\n\n\tret = decode_AS_REP(in->data, in->length, &rep.kdc_rep, &size);\n\tif (ret == 0) {\n\t    unsigned eflags = EXTRACT_TICKET_AS_REQ | EXTRACT_TICKET_TIMESYNC;\n\t    krb5_data data;\n\n\t    /*\n\t     * Unwrap AS-REP\n\t     */\n\t    ASN1_MALLOC_ENCODE(Ticket, data.data, data.length,\n\t\t\t       &rep.kdc_rep.ticket, &size, ret);\n\t    if (ret)\n\t\tgoto out;\n\t    heim_assert(data.length == size, \"ASN.1 internal error\");\n\n\t    ret = fast_unwrap_as_rep(context, ctx->nonce, &data,\n\t\t\t\t     &ctx->fast_state, &rep.kdc_rep);\n\t    krb5_data_free(&data);\n\t    if (ret)\n\t\tgoto out;\n\n\t    /*\n\t     * Now check and extract the ticket\n\t     */\n\n\t    if (ctx->flags.canonicalize) {\n\t\teflags |= EXTRACT_TICKET_ALLOW_SERVER_MISMATCH;\n\t\teflags |= EXTRACT_TICKET_MATCH_REALM;\n\t    }\n\t    if (ctx->ic_flags & KRB5_INIT_CREDS_NO_C_CANON_CHECK)\n\t\teflags |= EXTRACT_TICKET_ALLOW_CNAME_MISMATCH;\n\n\t    ret = process_pa_data_to_key(context, ctx, &ctx->cred,\n\t\t\t\t\t &ctx->as_req, &rep.kdc_rep,\n\t\t\t\t\t hostinfo, &ctx->fast_state.reply_key);\n\t    if (ret) {\n\t\tfree_AS_REP(&rep.kdc_rep);\n\t\tgoto out;\n\t    }\n\n\t    _krb5_debug(context, 5, \"krb5_get_init_creds: extracting ticket\");\n\n\t    ret = _krb5_extract_ticket(context,\n\t\t\t\t       &rep,\n\t\t\t\t       &ctx->cred,\n\t\t\t\t       ctx->fast_state.reply_key,\n\t\t\t\t       NULL,\n\t\t\t\t       KRB5_KU_AS_REP_ENC_PART,\n\t\t\t\t       NULL,\n\t\t\t\t       ctx->nonce,\n\t\t\t\t       eflags,\n\t\t\t\t       &ctx->req_buffer,\n\t\t\t\t       NULL,\n\t\t\t\t       NULL);\n\t    if (ret == 0)\n\t\tret = copy_EncKDCRepPart(&rep.enc_part, &ctx->enc_part);\n\n\t    krb5_free_keyblock(context, ctx->fast_state.reply_key);\n\t    ctx->fast_state.reply_key = NULL;\n\t    *flags = 0;\n\n\t    free_AS_REP(&rep.kdc_rep);\n\t    free_EncASRepPart(&rep.enc_part);\n\n\t    return ret;\n\n\t} else {\n\t    /* let's try to parse it as a KRB-ERROR */\n\n\t    _krb5_debug(context, 5, \"krb5_get_init_creds: got an error\");\n\n\t    free_KRB_ERROR(&ctx->error);\n\n\t    ret = krb5_rd_error(context, in, &ctx->error);\n\t    if(ret && in->length && ((char*)in->data)[0] == 4)\n\t\tret = KRB5KRB_AP_ERR_V4_REPLY;\n\t    if (ret) {\n\t\t_krb5_debug(context, 5, \"krb5_get_init_creds: failed to read error\");\n\t\tgoto out;\n\t    }\n\n\t    /*\n\t     * Unwrap KRB-ERROR\n\t     */\n\t    ret = fast_unwrap_error(context, &ctx->fast_state, &ctx->error);\n\t    if (ret)\n\t\tgoto out;\n\n\t    /*\n\t     *\n\t     */\n\n\t    ret = krb5_error_from_rd_error(context, &ctx->error, &ctx->cred);\n\n\t    _krb5_debug(context, 5, \"krb5_get_init_creds: KRB-ERROR %d\", ret);\n\n\t    /*\n\t     * If no preauth was set and KDC requires it, give it one\n\t     * more try.\n\t     */\n\n\t    if (ret == KRB5KDC_ERR_PREAUTH_REQUIRED) {\n\n\t        free_METHOD_DATA(&ctx->md);\n\t        memset(&ctx->md, 0, sizeof(ctx->md));\n\n\t\tif (ctx->error.e_data) {\n\t\t    ret = decode_METHOD_DATA(ctx->error.e_data->data,\n\t\t\t\t\t     ctx->error.e_data->length,\n\t\t\t\t\t     &ctx->md,\n\t\t\t\t\t     NULL);\n\t\t    if (ret)\n\t\t\tkrb5_set_error_message(context, ret,\n\t\t\t\t\t       N_(\"Failed to decode METHOD-DATA\", \"\"));\n\t\t} else {\n\t\t    krb5_set_error_message(context, ret,\n\t\t\t\t\t   N_(\"Preauth required but no preauth \"\n\t\t\t\t\t      \"options send by KDC\", \"\"));\n\t\t}\n\t    } else if (ret == KRB5KRB_AP_ERR_SKEW && context->kdc_sec_offset == 0) {\n\t\t/*\n\t\t * Try adapt to timeskrew when we are using pre-auth, and\n\t\t * if there was a time skew, try again.\n\t\t */\n\t\tkrb5_set_real_time(context, ctx->error.stime, -1);\n\t\tif (context->kdc_sec_offset)\n\t\t    ret = 0;\n\n\t\t_krb5_debug(context, 10, \"init_creds: err skew updateing kdc offset to %d\",\n\t\t\t    context->kdc_sec_offset);\n\n\t\tctx->used_pa_types = 0;\n\n\t    } else if (ret == KRB5_KDC_ERR_WRONG_REALM && ctx->flags.canonicalize) {\n\t        /* client referal to a new realm */\n\n\t\tif (ctx->error.crealm == NULL) {\n\t\t    krb5_set_error_message(context, ret,\n\t\t\t\t\t   N_(\"Got a client referral, not but no realm\", \"\"));\n\t\t    goto out;\n\t\t}\n\t\t_krb5_debug(context, 5,\n\t\t\t    \"krb5_get_init_creds: got referal to realm %s\",\n\t\t\t    *ctx->error.crealm);\n\n\t\tret = krb5_principal_set_realm(context,\n\t\t\t\t\t       ctx->cred.client,\n\t\t\t\t\t       *ctx->error.crealm);\n\t\tif (ret)\n\t\t    goto out;\n\n\t\tif (krb5_principal_is_krbtgt(context, ctx->cred.server)) {\n\t\t    ret = krb5_init_creds_set_service(context, ctx, NULL);\n\t\t    if (ret)\n\t\t\tgoto out;\n\t\t}\n\n\t\tfree_AS_REQ(&ctx->as_req);\n\t\tmemset(&ctx->as_req, 0, sizeof(ctx->as_req));\n\n\t\tctx->used_pa_types = 0;\n\t    } else if (ret == KRB5KDC_ERR_KEY_EXP && ctx->runflags.change_password == 0 && ctx->prompter) {\n\t\tchar buf2[1024];\n\n\t\tctx->runflags.change_password = 1;\n\n\t\tctx->prompter(context, ctx->prompter_data, NULL, N_(\"Password has expired\", \"\"), 0, NULL);\n\n\n\t\t/* try to avoid recursion */\n\t\tif (ctx->in_tkt_service != NULL && strcmp(ctx->in_tkt_service, \"kadmin/changepw\") == 0)\n\t\t    goto out;\n\n                /* don't try to change password where then where none */\n                if (ctx->prompter == NULL)\n                    goto out;\n\n\t\tret = change_password(context,\n\t\t\t\t      ctx->cred.client,\n\t\t\t\t      ctx->password,\n\t\t\t\t      buf2,\n\t\t\t\t      sizeof(buf2),\n\t\t\t\t      ctx->prompter,\n\t\t\t\t      ctx->prompter_data,\n\t\t\t\t      NULL);\n\t\tif (ret)\n\t\t    goto out;\n\n\t\tkrb5_init_creds_set_password(context, ctx, buf2);\n\n \t\tctx->used_pa_types = 0;\n\t\tret = 0;\n\n \t    } else if (ret == KRB5KDC_ERR_PREAUTH_FAILED) {\n \n \t\tif (ctx->fast_state.flags & KRB5_FAST_DISABLED)\n \t\t    goto out;\n \t\tif (ctx->fast_state.flags & (KRB5_FAST_REQUIRED | KRB5_FAST_EXPECTED))\n \t\t    goto out;\n \n \t\t_krb5_debug(context, 10, \"preauth failed with FAST, \"\n\t\t\t    \"and told by KD or user, trying w/o FAST\");\n \n \t\tctx->fast_state.flags |= KRB5_FAST_DISABLED;\n \t\tctx->used_pa_types = 0;\n\t\tret = 0;\n\t    }\n\t    if (ret)\n\t\tgoto out;\n\t}\n    }\n\n    if (ctx->as_req.req_body.cname == NULL) {\n\tret = init_as_req(context, ctx->flags, &ctx->cred,\n\t\t\t  ctx->addrs, ctx->etypes, &ctx->as_req);\n\tif (ret) {\n\t    free_init_creds_ctx(context, ctx);\n\t    return ret;\n\t}\n    }\n\n    if (ctx->as_req.padata) {\n\tfree_METHOD_DATA(ctx->as_req.padata);\n\tfree(ctx->as_req.padata);\n\tctx->as_req.padata = NULL;\n    }\n\n    /* Set a new nonce. */\n    ctx->as_req.req_body.nonce = ctx->nonce;\n\n    /* fill_in_md_data */\n    ret = process_pa_data_to_md(context, &ctx->cred, &ctx->as_req, ctx,\n\t\t\t\t&ctx->md, &ctx->as_req.padata,\n\t\t\t\tctx->prompter, ctx->prompter_data);\n    if (ret)\n\tgoto out;\n\n    /*\n     * Wrap with FAST\n     */\n    copy_AS_REQ(&ctx->as_req, &req2);\n\n    ret = fast_wrap_req(context, &ctx->fast_state, &req2);\n    if (ret) {\n\tfree_AS_REQ(&req2);\n\tgoto out;\n    }\n\n    krb5_data_free(&ctx->req_buffer);\n\n    ASN1_MALLOC_ENCODE(AS_REQ,\n\t\t       ctx->req_buffer.data, ctx->req_buffer.length,\n\t\t       &req2, &len, ret);\n    free_AS_REQ(&req2);\n    if (ret)\n\tgoto out;\n    if(len != ctx->req_buffer.length)\n\tkrb5_abortx(context, \"internal error in ASN.1 encoder\");\n\n    out->data = ctx->req_buffer.data;\n    out->length = ctx->req_buffer.length;\n\n    *flags = KRB5_INIT_CREDS_STEP_FLAG_CONTINUE;\n\n    return 0;\n out:\n    return ret;\n}",
  "abstract_func_before": "KRB5_LIB_CALL\nkrb5_init_creds_step(krb5_context VAR_0,\n\t\t     krb5_init_creds_context VAR_1,\n\t\t     krb5_data *VAR_2,\n\t\t     krb5_data *VAR_3,\n\t\t     krb5_krbhst_info *VAR_4,\n\t\t     unsigned int *VAR_5)\n{\n    krb5_error_code VAR_6;\n    size_t VAR_7 = 0;\n    size_t VAR_8;\n    AS_REQ VAR_9;\n\n    krb5_data_zero(VAR_3);\n\n    if (VAR_1->as_req.req_body.cname == NULL) {\n\tVAR_6 = init_as_req(VAR_0, VAR_1->flags, &VAR_1->cred,\n\t\t\t  VAR_1->addrs, VAR_1->etypes, &VAR_1->as_req);\n\tif (VAR_6) {\n\t    free_init_creds_ctx(VAR_0, VAR_1);\n\t    return VAR_6;\n\t}\n    }\n\n#define VAR_10 10\n    if (VAR_1->pa_counter > VAR_10) {\n\tkrb5_set_error_message(VAR_0, VAR_11,\n\t\t\t       N_(\"Looping %d times while getting \"\n\t\t\t\t  \"initial credentials\", \"\"),\n\t\t\t       VAR_1->pa_counter);\n\treturn VAR_11;\n    }\n    VAR_1->pa_counter++;\n\n    _krb5_debug(VAR_0, 5, \"krb5_get_init_creds: loop %d\", VAR_1->pa_counter);\n\n    /* COMMENT_0 */\n    if (VAR_2 && VAR_2->length) {\n\tkrb5_kdc_rep VAR_12;\n\n\tmemset(&VAR_12, 0, sizeof(VAR_12));\n\n\t_krb5_debug(VAR_0, 5, \"krb5_get_init_creds: processing input\");\n\n\tVAR_6 = decode_AS_REP(VAR_2->data, VAR_2->length, &VAR_12.kdc_rep, &VAR_8);\n\tif (VAR_6 == 0) {\n\t    unsigned VAR_13 = VAR_14 | VAR_15;\n\t    krb5_data VAR_16;\n\n\t    /* COMMENT_1 */\n                     \n        \n\t    ASN1_MALLOC_ENCODE(VAR_17, VAR_16.data, VAR_16.length,\n\t\t\t       &VAR_12.kdc_rep.ticket, &VAR_8, VAR_6);\n\t    if (VAR_6)\n\t\tgoto out;\n\t    heim_assert(VAR_16.length == VAR_8, \"ASN.1 internal error\");\n\n\t    VAR_6 = fast_unwrap_as_rep(VAR_0, VAR_1->nonce, &VAR_16,\n\t\t\t\t     &VAR_1->fast_state, &VAR_12.kdc_rep);\n\t    krb5_data_free(&VAR_16);\n\t    if (VAR_6)\n\t\tgoto out;\n\n\t    /* COMMENT_4 */\n                                        \n        \n\n\t    if (VAR_1->flags.canonicalize) {\n\t\tVAR_13 |= VAR_18;\n\t\tVAR_13 |= VAR_19;\n\t    }\n\t    if (VAR_1->ic_flags & VAR_20)\n\t\tVAR_13 |= VAR_21;\n\n\t    VAR_6 = process_pa_data_to_key(VAR_0, VAR_1, &VAR_1->cred,\n\t\t\t\t\t &VAR_1->as_req, &VAR_12.kdc_rep,\n\t\t\t\t\t VAR_4, &VAR_1->fast_state.reply_key);\n\t    if (VAR_6) {\n\t\tfree_AS_REP(&VAR_12.kdc_rep);\n\t\tgoto out;\n\t    }\n\n\t    _krb5_debug(VAR_0, 5, \"krb5_get_init_creds: extracting ticket\");\n\n\t    VAR_6 = _krb5_extract_ticket(VAR_0,\n\t\t\t\t       &VAR_12,\n\t\t\t\t       &VAR_1->cred,\n\t\t\t\t       VAR_1->fast_state.reply_key,\n\t\t\t\t       NULL,\n\t\t\t\t       VAR_22,\n\t\t\t\t       NULL,\n\t\t\t\t       VAR_1->nonce,\n\t\t\t\t       VAR_13,\n\t\t\t\t       &VAR_1->req_buffer,\n\t\t\t\t       NULL,\n\t\t\t\t       NULL);\n\t    if (VAR_6 == 0)\n\t\tVAR_6 = copy_EncKDCRepPart(&VAR_12.enc_part, &VAR_1->enc_part);\n\n\t    krb5_free_keyblock(VAR_0, VAR_1->fast_state.reply_key);\n\t    VAR_1->fast_state.reply_key = NULL;\n\t    *VAR_5 = 0;\n\n\t    free_AS_REP(&VAR_12.kdc_rep);\n\t    free_EncASRepPart(&VAR_12.enc_part);\n\n\t    return VAR_6;\n\n\t} else {\n\t    /* COMMENT_7 */\n\n\t    _krb5_debug(VAR_0, 5, \"krb5_get_init_creds: got an error\");\n\n\t    free_KRB_ERROR(&VAR_1->error);\n\n\t    VAR_6 = krb5_rd_error(VAR_0, VAR_2, &VAR_1->error);\n\t    if(VAR_6 && VAR_2->length && ((char*)VAR_2->data)[0] == 4)\n\t\tVAR_6 = VAR_23;\n\t    if (VAR_6) {\n\t\t_krb5_debug(VAR_0, 5, \"krb5_get_init_creds: failed to read error\");\n\t\tgoto out;\n\t    }\n\n\t    /* COMMENT_8 */\n                        \n        \n\t    VAR_6 = fast_unwrap_error(VAR_0, &VAR_1->fast_state, &VAR_1->error);\n\t    if (VAR_6)\n\t\tgoto out;\n\n\t    /* COMMENT_11 */\n       \n        \n\n\t    VAR_6 = krb5_error_from_rd_error(VAR_0, &VAR_1->error, &VAR_1->cred);\n\n\t    _krb5_debug(VAR_0, 5, \"krb5_get_init_creds: KRB-ERROR %d\", VAR_6);\n\n\t    /* COMMENT_14 */\n                                                              \n                 \n        \n\n\t    if (VAR_6 == VAR_24) {\n\n\t        free_METHOD_DATA(&VAR_1->md);\n\t        memset(&VAR_1->md, 0, sizeof(VAR_1->md));\n\n\t\tif (VAR_1->error.e_data) {\n\t\t    VAR_6 = decode_METHOD_DATA(VAR_1->error.e_data->data,\n\t\t\t\t\t     VAR_1->error.e_data->length,\n\t\t\t\t\t     &VAR_1->md,\n\t\t\t\t\t     NULL);\n\t\t    if (VAR_6)\n\t\t\tkrb5_set_error_message(VAR_0, VAR_6,\n\t\t\t\t\t       N_(\"Failed to decode METHOD-DATA\", \"\"));\n\t\t} else {\n\t\t    krb5_set_error_message(VAR_0, VAR_6,\n\t\t\t\t\t   N_(\"Preauth required but no preauth \"\n\t\t\t\t\t      \"options send by KDC\", \"\"));\n\t\t}\n\t    } else if (VAR_6 == VAR_25 && VAR_0->kdc_sec_offset == 0) {\n\t\t/* COMMENT_18 */\n                                                           \n                                         \n     \n\t\tkrb5_set_real_time(VAR_0, VAR_1->error.stime, -1);\n\t\tif (VAR_0->kdc_sec_offset)\n\t\t    VAR_6 = 0;\n\n\t\t_krb5_debug(VAR_0, 10, \"init_creds: err skew updateing kdc offset to %d\",\n\t\t\t    VAR_0->kdc_sec_offset);\n\n\t\tVAR_1->used_pa_types = 0;\n\n\t    } else if (VAR_6 == VAR_26 && VAR_1->flags.canonicalize) {\n\t        /* COMMENT_22 */\n\n\t\tif (VAR_1->error.crealm == NULL) {\n\t\t    krb5_set_error_message(VAR_0, VAR_6,\n\t\t\t\t\t   N_(\"Got a client referral, not but no realm\", \"\"));\n\t\t    goto out;\n\t\t}\n\t\t_krb5_debug(VAR_0, 5,\n\t\t\t    \"krb5_get_init_creds: got referal to realm %s\",\n\t\t\t    *VAR_1->error.crealm);\n\n\t\tVAR_6 = krb5_principal_set_realm(VAR_0,\n\t\t\t\t\t       VAR_1->cred.client,\n\t\t\t\t\t       *VAR_1->error.crealm);\n\t\tif (VAR_6)\n\t\t    goto out;\n\n\t\tif (krb5_principal_is_krbtgt(VAR_0, VAR_1->cred.server)) {\n\t\t    VAR_6 = krb5_init_creds_set_service(VAR_0, VAR_1, NULL);\n\t\t    if (VAR_6)\n\t\t\tgoto out;\n\t\t}\n\n\t\tfree_AS_REQ(&VAR_1->as_req);\n\t\tmemset(&VAR_1->as_req, 0, sizeof(VAR_1->as_req));\n\n\t\tVAR_1->used_pa_types = 0;\n\t    } else if (VAR_6 == VAR_27 && VAR_1->runflags.change_password == 0 && VAR_1->prompter) {\n\t\tchar VAR_28[1024];\n\n\t\tVAR_1->runflags.change_password = 1;\n\n\t\tVAR_1->prompter(VAR_0, VAR_1->prompter_data, NULL, N_(\"Password has expired\", \"\"), 0, NULL);\n\n\n\t\t/* COMMENT_23 */\n\t\tif (VAR_1->in_tkt_service != NULL && strcmp(VAR_1->in_tkt_service, \"kadmin/changepw\") == 0)\n\t\t    goto out;\n\n                /* COMMENT_24 */\n                if (VAR_1->prompter == NULL)\n                    goto out;\n\n\t\tVAR_6 = change_password(VAR_0,\n\t\t\t\t      VAR_1->cred.client,\n\t\t\t\t      VAR_1->password,\n\t\t\t\t      VAR_28,\n\t\t\t\t      sizeof(VAR_28),\n\t\t\t\t      VAR_1->prompter,\n\t\t\t\t      VAR_1->prompter_data,\n\t\t\t\t      NULL);\n\t\tif (VAR_6)\n\t\t    goto out;\n\n\t\tkrb5_init_creds_set_password(VAR_0, VAR_1, VAR_28);\n\n \t\tVAR_1->used_pa_types = 0;\n\t\tVAR_6 = 0;\n\n \t    } else if (VAR_6 == VAR_29) {\n \n \t\tif (VAR_1->fast_state.flags & VAR_30)\n \t\t    goto out;\n \t\tif (VAR_1->fast_state.flags & (VAR_31 | VAR_32))\n \t\t    goto out;\n \n \t\t_krb5_debug(VAR_0, 10, \"preauth failed with FAST, \"\n\t\t\t    \"and told by KD or user, trying w/o FAST\");\n \n \t\tVAR_1->fast_state.flags |= VAR_30;\n \t\tVAR_1->used_pa_types = 0;\n\t\tVAR_6 = 0;\n\t    }\n\t    if (VAR_6)\n\t\tgoto out;\n\t}\n    }\n\n    if (VAR_1->as_req.req_body.cname == NULL) {\n\tVAR_6 = init_as_req(VAR_0, VAR_1->flags, &VAR_1->cred,\n\t\t\t  VAR_1->addrs, VAR_1->etypes, &VAR_1->as_req);\n\tif (VAR_6) {\n\t    free_init_creds_ctx(VAR_0, VAR_1);\n\t    return VAR_6;\n\t}\n    }\n\n    if (VAR_1->as_req.padata) {\n\tfree_METHOD_DATA(VAR_1->as_req.padata);\n\tfree(VAR_1->as_req.padata);\n\tVAR_1->as_req.padata = NULL;\n    }\n\n    /* COMMENT_25 */\n    VAR_1->as_req.req_body.nonce = VAR_1->nonce;\n\n    /* COMMENT_26 */\n    VAR_6 = process_pa_data_to_md(VAR_0, &VAR_1->cred, &VAR_1->as_req, VAR_1,\n\t\t\t\t&VAR_1->md, &VAR_1->as_req.padata,\n\t\t\t\tVAR_1->prompter, VAR_1->prompter_data);\n    if (VAR_6)\n\tgoto out;\n\n    /* COMMENT_27 */\n                     \n       \n    copy_AS_REQ(&VAR_1->as_req, &VAR_9);\n\n    VAR_6 = fast_wrap_req(VAR_0, &VAR_1->fast_state, &VAR_9);\n    if (VAR_6) {\n\tfree_AS_REQ(&VAR_9);\n\tgoto out;\n    }\n\n    krb5_data_free(&VAR_1->req_buffer);\n\n    ASN1_MALLOC_ENCODE(AS_REQ,\n\t\t       VAR_1->req_buffer.data, VAR_1->req_buffer.length,\n\t\t       &VAR_9, &VAR_7, VAR_6);\n    free_AS_REQ(&VAR_9);\n    if (VAR_6)\n\tgoto out;\n    if(VAR_7 != VAR_1->req_buffer.length)\n\tkrb5_abortx(VAR_0, \"internal error in ASN.1 encoder\");\n\n    VAR_3->data = VAR_1->req_buffer.data;\n    VAR_3->length = VAR_1->req_buffer.length;\n\n    *VAR_5 = VAR_33;\n\n    return 0;\n out:\n    return VAR_6;\n}",
  "func_graph_path_before": "heimdal/2f7f3d9960aa6ea21358bdf3687cee5149aa35cf/init_creds_pw.c/vul/before/0.json",
  "func": "KRB5_LIB_CALL\nkrb5_init_creds_step(krb5_context context,\n\t\t     krb5_init_creds_context ctx,\n\t\t     krb5_data *in,\n\t\t     krb5_data *out,\n\t\t     krb5_krbhst_info *hostinfo,\n\t\t     unsigned int *flags)\n{\n    krb5_error_code ret;\n    size_t len = 0;\n    size_t size;\n    AS_REQ req2;\n\n    krb5_data_zero(out);\n\n    if (ctx->as_req.req_body.cname == NULL) {\n\tret = init_as_req(context, ctx->flags, &ctx->cred,\n\t\t\t  ctx->addrs, ctx->etypes, &ctx->as_req);\n\tif (ret) {\n\t    free_init_creds_ctx(context, ctx);\n\t    return ret;\n\t}\n    }\n\n#define MAX_PA_COUNTER 10\n    if (ctx->pa_counter > MAX_PA_COUNTER) {\n\tkrb5_set_error_message(context, KRB5_GET_IN_TKT_LOOP,\n\t\t\t       N_(\"Looping %d times while getting \"\n\t\t\t\t  \"initial credentials\", \"\"),\n\t\t\t       ctx->pa_counter);\n\treturn KRB5_GET_IN_TKT_LOOP;\n    }\n    ctx->pa_counter++;\n\n    _krb5_debug(context, 5, \"krb5_get_init_creds: loop %d\", ctx->pa_counter);\n\n    /* Lets process the input packet */\n    if (in && in->length) {\n\tkrb5_kdc_rep rep;\n\n\tmemset(&rep, 0, sizeof(rep));\n\n\t_krb5_debug(context, 5, \"krb5_get_init_creds: processing input\");\n\n\tret = decode_AS_REP(in->data, in->length, &rep.kdc_rep, &size);\n\tif (ret == 0) {\n\t    unsigned eflags = EXTRACT_TICKET_AS_REQ | EXTRACT_TICKET_TIMESYNC;\n\t    krb5_data data;\n\n\t    /*\n\t     * Unwrap AS-REP\n\t     */\n\t    ASN1_MALLOC_ENCODE(Ticket, data.data, data.length,\n\t\t\t       &rep.kdc_rep.ticket, &size, ret);\n\t    if (ret)\n\t\tgoto out;\n\t    heim_assert(data.length == size, \"ASN.1 internal error\");\n\n\t    ret = fast_unwrap_as_rep(context, ctx->nonce, &data,\n\t\t\t\t     &ctx->fast_state, &rep.kdc_rep);\n\t    krb5_data_free(&data);\n\t    if (ret)\n\t\tgoto out;\n\n\t    /*\n\t     * Now check and extract the ticket\n\t     */\n\n\t    if (ctx->flags.canonicalize) {\n\t\teflags |= EXTRACT_TICKET_ALLOW_SERVER_MISMATCH;\n\t\teflags |= EXTRACT_TICKET_MATCH_REALM;\n\t    }\n\t    if (ctx->ic_flags & KRB5_INIT_CREDS_NO_C_CANON_CHECK)\n\t\teflags |= EXTRACT_TICKET_ALLOW_CNAME_MISMATCH;\n\n\t    ret = process_pa_data_to_key(context, ctx, &ctx->cred,\n\t\t\t\t\t &ctx->as_req, &rep.kdc_rep,\n\t\t\t\t\t hostinfo, &ctx->fast_state.reply_key);\n\t    if (ret) {\n\t\tfree_AS_REP(&rep.kdc_rep);\n\t\tgoto out;\n\t    }\n\n\t    _krb5_debug(context, 5, \"krb5_get_init_creds: extracting ticket\");\n\n\t    ret = _krb5_extract_ticket(context,\n\t\t\t\t       &rep,\n\t\t\t\t       &ctx->cred,\n\t\t\t\t       ctx->fast_state.reply_key,\n\t\t\t\t       NULL,\n\t\t\t\t       KRB5_KU_AS_REP_ENC_PART,\n\t\t\t\t       NULL,\n\t\t\t\t       ctx->nonce,\n\t\t\t\t       eflags,\n\t\t\t\t       &ctx->req_buffer,\n\t\t\t\t       NULL,\n\t\t\t\t       NULL);\n\t    if (ret == 0 && ctx->pk_init_ctx) {\n\t\tPA_DATA *pa_pkinit_kx;\n\t\tint idx = 0;\n\n\t\tpa_pkinit_kx =\n\t\t    krb5_find_padata(rep.kdc_rep.padata->val,\n\t\t\t\t     rep.kdc_rep.padata->len,\n\t\t\t\t     KRB5_PADATA_PKINIT_KX,\n\t\t\t\t     &idx);\n\n\t\tret = _krb5_pk_kx_confirm(context, ctx->pk_init_ctx,\n\t\t\t\t\t  ctx->fast_state.reply_key,\n\t\t\t\t\t  &ctx->cred.session,\n\t\t\t\t\t  pa_pkinit_kx);\n\t\tif (ret)\n\t\t    krb5_set_error_message(context, ret,\n\t\t\t\t\t   N_(\"Failed to confirm PA-PKINIT-KX\", \"\"));\n\t\telse if (pa_pkinit_kx != NULL)\n\t\t    ctx->ic_flags |= KRB5_INIT_CREDS_PKINIT_KX_VALID;\n\t    }\n\t    if (ret == 0)\n\t\tret = copy_EncKDCRepPart(&rep.enc_part, &ctx->enc_part);\n\n\t    krb5_free_keyblock(context, ctx->fast_state.reply_key);\n\t    ctx->fast_state.reply_key = NULL;\n\t    *flags = 0;\n\n\t    free_AS_REP(&rep.kdc_rep);\n\t    free_EncASRepPart(&rep.enc_part);\n\n\t    return ret;\n\n\t} else {\n\t    /* let's try to parse it as a KRB-ERROR */\n\n\t    _krb5_debug(context, 5, \"krb5_get_init_creds: got an error\");\n\n\t    free_KRB_ERROR(&ctx->error);\n\n\t    ret = krb5_rd_error(context, in, &ctx->error);\n\t    if(ret && in->length && ((char*)in->data)[0] == 4)\n\t\tret = KRB5KRB_AP_ERR_V4_REPLY;\n\t    if (ret) {\n\t\t_krb5_debug(context, 5, \"krb5_get_init_creds: failed to read error\");\n\t\tgoto out;\n\t    }\n\n\t    /*\n\t     * Unwrap KRB-ERROR\n\t     */\n\t    ret = fast_unwrap_error(context, &ctx->fast_state, &ctx->error);\n\t    if (ret)\n\t\tgoto out;\n\n\t    /*\n\t     *\n\t     */\n\n\t    ret = krb5_error_from_rd_error(context, &ctx->error, &ctx->cred);\n\n\t    _krb5_debug(context, 5, \"krb5_get_init_creds: KRB-ERROR %d\", ret);\n\n\t    /*\n\t     * If no preauth was set and KDC requires it, give it one\n\t     * more try.\n\t     */\n\n\t    if (ret == KRB5KDC_ERR_PREAUTH_REQUIRED) {\n\n\t        free_METHOD_DATA(&ctx->md);\n\t        memset(&ctx->md, 0, sizeof(ctx->md));\n\n\t\tif (ctx->error.e_data) {\n\t\t    ret = decode_METHOD_DATA(ctx->error.e_data->data,\n\t\t\t\t\t     ctx->error.e_data->length,\n\t\t\t\t\t     &ctx->md,\n\t\t\t\t\t     NULL);\n\t\t    if (ret)\n\t\t\tkrb5_set_error_message(context, ret,\n\t\t\t\t\t       N_(\"Failed to decode METHOD-DATA\", \"\"));\n\t\t} else {\n\t\t    krb5_set_error_message(context, ret,\n\t\t\t\t\t   N_(\"Preauth required but no preauth \"\n\t\t\t\t\t      \"options send by KDC\", \"\"));\n\t\t}\n\t    } else if (ret == KRB5KRB_AP_ERR_SKEW && context->kdc_sec_offset == 0) {\n\t\t/*\n\t\t * Try adapt to timeskrew when we are using pre-auth, and\n\t\t * if there was a time skew, try again.\n\t\t */\n\t\tkrb5_set_real_time(context, ctx->error.stime, -1);\n\t\tif (context->kdc_sec_offset)\n\t\t    ret = 0;\n\n\t\t_krb5_debug(context, 10, \"init_creds: err skew updateing kdc offset to %d\",\n\t\t\t    context->kdc_sec_offset);\n\n\t\tctx->used_pa_types = 0;\n\n\t    } else if (ret == KRB5_KDC_ERR_WRONG_REALM && ctx->flags.canonicalize) {\n\t        /* client referal to a new realm */\n\n\t\tif (ctx->error.crealm == NULL) {\n\t\t    krb5_set_error_message(context, ret,\n\t\t\t\t\t   N_(\"Got a client referral, not but no realm\", \"\"));\n\t\t    goto out;\n\t\t}\n\t\t_krb5_debug(context, 5,\n\t\t\t    \"krb5_get_init_creds: got referal to realm %s\",\n\t\t\t    *ctx->error.crealm);\n\n\t\tret = krb5_principal_set_realm(context,\n\t\t\t\t\t       ctx->cred.client,\n\t\t\t\t\t       *ctx->error.crealm);\n\t\tif (ret)\n\t\t    goto out;\n\n\t\tif (krb5_principal_is_krbtgt(context, ctx->cred.server)) {\n\t\t    ret = krb5_init_creds_set_service(context, ctx, NULL);\n\t\t    if (ret)\n\t\t\tgoto out;\n\t\t}\n\n\t\tfree_AS_REQ(&ctx->as_req);\n\t\tmemset(&ctx->as_req, 0, sizeof(ctx->as_req));\n\n\t\tctx->used_pa_types = 0;\n\t    } else if (ret == KRB5KDC_ERR_KEY_EXP && ctx->runflags.change_password == 0 && ctx->prompter) {\n\t\tchar buf2[1024];\n\n\t\tctx->runflags.change_password = 1;\n\n\t\tctx->prompter(context, ctx->prompter_data, NULL, N_(\"Password has expired\", \"\"), 0, NULL);\n\n\n\t\t/* try to avoid recursion */\n\t\tif (ctx->in_tkt_service != NULL && strcmp(ctx->in_tkt_service, \"kadmin/changepw\") == 0)\n\t\t    goto out;\n\n                /* don't try to change password where then where none */\n                if (ctx->prompter == NULL)\n                    goto out;\n\n\t\tret = change_password(context,\n\t\t\t\t      ctx->cred.client,\n\t\t\t\t      ctx->password,\n\t\t\t\t      buf2,\n\t\t\t\t      sizeof(buf2),\n\t\t\t\t      ctx->prompter,\n\t\t\t\t      ctx->prompter_data,\n\t\t\t\t      NULL);\n\t\tif (ret)\n\t\t    goto out;\n\n\t\tkrb5_init_creds_set_password(context, ctx, buf2);\n\n \t\tctx->used_pa_types = 0;\n\t\tret = 0;\n\n \t    } else if (ret == KRB5KDC_ERR_PREAUTH_FAILED) {\n \n \t\tif (ctx->fast_state.flags & KRB5_FAST_DISABLED)\n \t\t    goto out;\n \t\tif (ctx->fast_state.flags & (KRB5_FAST_REQUIRED | KRB5_FAST_EXPECTED))\n \t\t    goto out;\n \n \t\t_krb5_debug(context, 10, \"preauth failed with FAST, \"\n\t\t\t    \"and told by KD or user, trying w/o FAST\");\n \n \t\tctx->fast_state.flags |= KRB5_FAST_DISABLED;\n \t\tctx->used_pa_types = 0;\n\t\tret = 0;\n\t    }\n\t    if (ret)\n\t\tgoto out;\n\t}\n    }\n\n    if (ctx->as_req.req_body.cname == NULL) {\n\tret = init_as_req(context, ctx->flags, &ctx->cred,\n\t\t\t  ctx->addrs, ctx->etypes, &ctx->as_req);\n\tif (ret) {\n\t    free_init_creds_ctx(context, ctx);\n\t    return ret;\n\t}\n    }\n\n    if (ctx->as_req.padata) {\n\tfree_METHOD_DATA(ctx->as_req.padata);\n\tfree(ctx->as_req.padata);\n\tctx->as_req.padata = NULL;\n    }\n\n    /* Set a new nonce. */\n    ctx->as_req.req_body.nonce = ctx->nonce;\n\n    /* fill_in_md_data */\n    ret = process_pa_data_to_md(context, &ctx->cred, &ctx->as_req, ctx,\n\t\t\t\t&ctx->md, &ctx->as_req.padata,\n\t\t\t\tctx->prompter, ctx->prompter_data);\n    if (ret)\n\tgoto out;\n\n    /*\n     * Wrap with FAST\n     */\n    copy_AS_REQ(&ctx->as_req, &req2);\n\n    ret = fast_wrap_req(context, &ctx->fast_state, &req2);\n    if (ret) {\n\tfree_AS_REQ(&req2);\n\tgoto out;\n    }\n\n    krb5_data_free(&ctx->req_buffer);\n\n    ASN1_MALLOC_ENCODE(AS_REQ,\n\t\t       ctx->req_buffer.data, ctx->req_buffer.length,\n\t\t       &req2, &len, ret);\n    free_AS_REQ(&req2);\n    if (ret)\n\tgoto out;\n    if(len != ctx->req_buffer.length)\n\tkrb5_abortx(context, \"internal error in ASN.1 encoder\");\n\n    out->data = ctx->req_buffer.data;\n    out->length = ctx->req_buffer.length;\n\n    *flags = KRB5_INIT_CREDS_STEP_FLAG_CONTINUE;\n\n    return 0;\n out:\n    return ret;\n}",
  "abstract_func": "KRB5_LIB_CALL\nkrb5_init_creds_step(krb5_context VAR_0,\n\t\t     krb5_init_creds_context VAR_1,\n\t\t     krb5_data *VAR_2,\n\t\t     krb5_data *VAR_3,\n\t\t     krb5_krbhst_info *VAR_4,\n\t\t     unsigned int *VAR_5)\n{\n    krb5_error_code VAR_6;\n    size_t VAR_7 = 0;\n    size_t VAR_8;\n    AS_REQ VAR_9;\n\n    krb5_data_zero(VAR_3);\n\n    if (VAR_1->as_req.req_body.cname == NULL) {\n\tVAR_6 = init_as_req(VAR_0, VAR_1->flags, &VAR_1->cred,\n\t\t\t  VAR_1->addrs, VAR_1->etypes, &VAR_1->as_req);\n\tif (VAR_6) {\n\t    free_init_creds_ctx(VAR_0, VAR_1);\n\t    return VAR_6;\n\t}\n    }\n\n#define VAR_10 10\n    if (VAR_1->pa_counter > VAR_10) {\n\tkrb5_set_error_message(VAR_0, VAR_11,\n\t\t\t       N_(\"Looping %d times while getting \"\n\t\t\t\t  \"initial credentials\", \"\"),\n\t\t\t       VAR_1->pa_counter);\n\treturn VAR_11;\n    }\n    VAR_1->pa_counter++;\n\n    _krb5_debug(VAR_0, 5, \"krb5_get_init_creds: loop %d\", VAR_1->pa_counter);\n\n    /* COMMENT_0 */\n    if (VAR_2 && VAR_2->length) {\n\tkrb5_kdc_rep VAR_12;\n\n\tmemset(&VAR_12, 0, sizeof(VAR_12));\n\n\t_krb5_debug(VAR_0, 5, \"krb5_get_init_creds: processing input\");\n\n\tVAR_6 = decode_AS_REP(VAR_2->data, VAR_2->length, &VAR_12.kdc_rep, &VAR_8);\n\tif (VAR_6 == 0) {\n\t    unsigned VAR_13 = VAR_14 | VAR_15;\n\t    krb5_data VAR_16;\n\n\t    /* COMMENT_1 */\n                     \n        \n\t    ASN1_MALLOC_ENCODE(VAR_17, VAR_16.data, VAR_16.length,\n\t\t\t       &VAR_12.kdc_rep.ticket, &VAR_8, VAR_6);\n\t    if (VAR_6)\n\t\tgoto out;\n\t    heim_assert(VAR_16.length == VAR_8, \"ASN.1 internal error\");\n\n\t    VAR_6 = fast_unwrap_as_rep(VAR_0, VAR_1->nonce, &VAR_16,\n\t\t\t\t     &VAR_1->fast_state, &VAR_12.kdc_rep);\n\t    krb5_data_free(&VAR_16);\n\t    if (VAR_6)\n\t\tgoto out;\n\n\t    /* COMMENT_4 */\n                                        \n        \n\n\t    if (VAR_1->flags.canonicalize) {\n\t\tVAR_13 |= VAR_18;\n\t\tVAR_13 |= VAR_19;\n\t    }\n\t    if (VAR_1->ic_flags & VAR_20)\n\t\tVAR_13 |= VAR_21;\n\n\t    VAR_6 = process_pa_data_to_key(VAR_0, VAR_1, &VAR_1->cred,\n\t\t\t\t\t &VAR_1->as_req, &VAR_12.kdc_rep,\n\t\t\t\t\t VAR_4, &VAR_1->fast_state.reply_key);\n\t    if (VAR_6) {\n\t\tfree_AS_REP(&VAR_12.kdc_rep);\n\t\tgoto out;\n\t    }\n\n\t    _krb5_debug(VAR_0, 5, \"krb5_get_init_creds: extracting ticket\");\n\n\t    VAR_6 = _krb5_extract_ticket(VAR_0,\n\t\t\t\t       &VAR_12,\n\t\t\t\t       &VAR_1->cred,\n\t\t\t\t       VAR_1->fast_state.reply_key,\n\t\t\t\t       NULL,\n\t\t\t\t       VAR_22,\n\t\t\t\t       NULL,\n\t\t\t\t       VAR_1->nonce,\n\t\t\t\t       VAR_13,\n\t\t\t\t       &VAR_1->req_buffer,\n\t\t\t\t       NULL,\n\t\t\t\t       NULL);\n\t    if (VAR_6 == 0 && VAR_1->pk_init_ctx) {\n\t\tPA_DATA *VAR_23;\n\t\tint VAR_24 = 0;\n\n\t\tVAR_23 =\n\t\t    krb5_find_padata(VAR_12.kdc_rep.padata->val,\n\t\t\t\t     VAR_12.kdc_rep.padata->len,\n\t\t\t\t     VAR_25,\n\t\t\t\t     &VAR_24);\n\n\t\tVAR_6 = _krb5_pk_kx_confirm(VAR_0, VAR_1->pk_init_ctx,\n\t\t\t\t\t  VAR_1->fast_state.reply_key,\n\t\t\t\t\t  &VAR_1->cred.session,\n\t\t\t\t\t  VAR_23);\n\t\tif (VAR_6)\n\t\t    krb5_set_error_message(VAR_0, VAR_6,\n\t\t\t\t\t   N_(\"Failed to confirm PA-PKINIT-KX\", \"\"));\n\t\telse if (VAR_23 != NULL)\n\t\t    VAR_1->ic_flags |= VAR_26;\n\t    }\n\t    if (VAR_6 == 0)\n\t\tVAR_6 = copy_EncKDCRepPart(&VAR_12.enc_part, &VAR_1->enc_part);\n\n\t    krb5_free_keyblock(VAR_0, VAR_1->fast_state.reply_key);\n\t    VAR_1->fast_state.reply_key = NULL;\n\t    *VAR_5 = 0;\n\n\t    free_AS_REP(&VAR_12.kdc_rep);\n\t    free_EncASRepPart(&VAR_12.enc_part);\n\n\t    return VAR_6;\n\n\t} else {\n\t    /* COMMENT_7 */\n\n\t    _krb5_debug(VAR_0, 5, \"krb5_get_init_creds: got an error\");\n\n\t    free_KRB_ERROR(&VAR_1->error);\n\n\t    VAR_6 = krb5_rd_error(VAR_0, VAR_2, &VAR_1->error);\n\t    if(VAR_6 && VAR_2->length && ((char*)VAR_2->data)[0] == 4)\n\t\tVAR_6 = VAR_27;\n\t    if (VAR_6) {\n\t\t_krb5_debug(VAR_0, 5, \"krb5_get_init_creds: failed to read error\");\n\t\tgoto out;\n\t    }\n\n\t    /* COMMENT_8 */\n                        \n        \n\t    VAR_6 = fast_unwrap_error(VAR_0, &VAR_1->fast_state, &VAR_1->error);\n\t    if (VAR_6)\n\t\tgoto out;\n\n\t    /* COMMENT_11 */\n       \n        \n\n\t    VAR_6 = krb5_error_from_rd_error(VAR_0, &VAR_1->error, &VAR_1->cred);\n\n\t    _krb5_debug(VAR_0, 5, \"krb5_get_init_creds: KRB-ERROR %d\", VAR_6);\n\n\t    /* COMMENT_14 */\n                                                              \n                 \n        \n\n\t    if (VAR_6 == VAR_28) {\n\n\t        free_METHOD_DATA(&VAR_1->md);\n\t        memset(&VAR_1->md, 0, sizeof(VAR_1->md));\n\n\t\tif (VAR_1->error.e_data) {\n\t\t    VAR_6 = decode_METHOD_DATA(VAR_1->error.e_data->data,\n\t\t\t\t\t     VAR_1->error.e_data->length,\n\t\t\t\t\t     &VAR_1->md,\n\t\t\t\t\t     NULL);\n\t\t    if (VAR_6)\n\t\t\tkrb5_set_error_message(VAR_0, VAR_6,\n\t\t\t\t\t       N_(\"Failed to decode METHOD-DATA\", \"\"));\n\t\t} else {\n\t\t    krb5_set_error_message(VAR_0, VAR_6,\n\t\t\t\t\t   N_(\"Preauth required but no preauth \"\n\t\t\t\t\t      \"options send by KDC\", \"\"));\n\t\t}\n\t    } else if (VAR_6 == VAR_29 && VAR_0->kdc_sec_offset == 0) {\n\t\t/* COMMENT_18 */\n                                                           \n                                         \n     \n\t\tkrb5_set_real_time(VAR_0, VAR_1->error.stime, -1);\n\t\tif (VAR_0->kdc_sec_offset)\n\t\t    VAR_6 = 0;\n\n\t\t_krb5_debug(VAR_0, 10, \"init_creds: err skew updateing kdc offset to %d\",\n\t\t\t    VAR_0->kdc_sec_offset);\n\n\t\tVAR_1->used_pa_types = 0;\n\n\t    } else if (VAR_6 == VAR_30 && VAR_1->flags.canonicalize) {\n\t        /* COMMENT_22 */\n\n\t\tif (VAR_1->error.crealm == NULL) {\n\t\t    krb5_set_error_message(VAR_0, VAR_6,\n\t\t\t\t\t   N_(\"Got a client referral, not but no realm\", \"\"));\n\t\t    goto out;\n\t\t}\n\t\t_krb5_debug(VAR_0, 5,\n\t\t\t    \"krb5_get_init_creds: got referal to realm %s\",\n\t\t\t    *VAR_1->error.crealm);\n\n\t\tVAR_6 = krb5_principal_set_realm(VAR_0,\n\t\t\t\t\t       VAR_1->cred.client,\n\t\t\t\t\t       *VAR_1->error.crealm);\n\t\tif (VAR_6)\n\t\t    goto out;\n\n\t\tif (krb5_principal_is_krbtgt(VAR_0, VAR_1->cred.server)) {\n\t\t    VAR_6 = krb5_init_creds_set_service(VAR_0, VAR_1, NULL);\n\t\t    if (VAR_6)\n\t\t\tgoto out;\n\t\t}\n\n\t\tfree_AS_REQ(&VAR_1->as_req);\n\t\tmemset(&VAR_1->as_req, 0, sizeof(VAR_1->as_req));\n\n\t\tVAR_1->used_pa_types = 0;\n\t    } else if (VAR_6 == VAR_31 && VAR_1->runflags.change_password == 0 && VAR_1->prompter) {\n\t\tchar VAR_32[1024];\n\n\t\tVAR_1->runflags.change_password = 1;\n\n\t\tVAR_1->prompter(VAR_0, VAR_1->prompter_data, NULL, N_(\"Password has expired\", \"\"), 0, NULL);\n\n\n\t\t/* COMMENT_23 */\n\t\tif (VAR_1->in_tkt_service != NULL && strcmp(VAR_1->in_tkt_service, \"kadmin/changepw\") == 0)\n\t\t    goto out;\n\n                /* COMMENT_24 */\n                if (VAR_1->prompter == NULL)\n                    goto out;\n\n\t\tVAR_6 = change_password(VAR_0,\n\t\t\t\t      VAR_1->cred.client,\n\t\t\t\t      VAR_1->password,\n\t\t\t\t      VAR_32,\n\t\t\t\t      sizeof(VAR_32),\n\t\t\t\t      VAR_1->prompter,\n\t\t\t\t      VAR_1->prompter_data,\n\t\t\t\t      NULL);\n\t\tif (VAR_6)\n\t\t    goto out;\n\n\t\tkrb5_init_creds_set_password(VAR_0, VAR_1, VAR_32);\n\n \t\tVAR_1->used_pa_types = 0;\n\t\tVAR_6 = 0;\n\n \t    } else if (VAR_6 == VAR_33) {\n \n \t\tif (VAR_1->fast_state.flags & VAR_34)\n \t\t    goto out;\n \t\tif (VAR_1->fast_state.flags & (VAR_35 | VAR_36))\n \t\t    goto out;\n \n \t\t_krb5_debug(VAR_0, 10, \"preauth failed with FAST, \"\n\t\t\t    \"and told by KD or user, trying w/o FAST\");\n \n \t\tVAR_1->fast_state.flags |= VAR_34;\n \t\tVAR_1->used_pa_types = 0;\n\t\tVAR_6 = 0;\n\t    }\n\t    if (VAR_6)\n\t\tgoto out;\n\t}\n    }\n\n    if (VAR_1->as_req.req_body.cname == NULL) {\n\tVAR_6 = init_as_req(VAR_0, VAR_1->flags, &VAR_1->cred,\n\t\t\t  VAR_1->addrs, VAR_1->etypes, &VAR_1->as_req);\n\tif (VAR_6) {\n\t    free_init_creds_ctx(VAR_0, VAR_1);\n\t    return VAR_6;\n\t}\n    }\n\n    if (VAR_1->as_req.padata) {\n\tfree_METHOD_DATA(VAR_1->as_req.padata);\n\tfree(VAR_1->as_req.padata);\n\tVAR_1->as_req.padata = NULL;\n    }\n\n    /* COMMENT_25 */\n    VAR_1->as_req.req_body.nonce = VAR_1->nonce;\n\n    /* COMMENT_26 */\n    VAR_6 = process_pa_data_to_md(VAR_0, &VAR_1->cred, &VAR_1->as_req, VAR_1,\n\t\t\t\t&VAR_1->md, &VAR_1->as_req.padata,\n\t\t\t\tVAR_1->prompter, VAR_1->prompter_data);\n    if (VAR_6)\n\tgoto out;\n\n    /* COMMENT_27 */\n                     \n       \n    copy_AS_REQ(&VAR_1->as_req, &VAR_9);\n\n    VAR_6 = fast_wrap_req(VAR_0, &VAR_1->fast_state, &VAR_9);\n    if (VAR_6) {\n\tfree_AS_REQ(&VAR_9);\n\tgoto out;\n    }\n\n    krb5_data_free(&VAR_1->req_buffer);\n\n    ASN1_MALLOC_ENCODE(AS_REQ,\n\t\t       VAR_1->req_buffer.data, VAR_1->req_buffer.length,\n\t\t       &VAR_9, &VAR_7, VAR_6);\n    free_AS_REQ(&VAR_9);\n    if (VAR_6)\n\tgoto out;\n    if(VAR_7 != VAR_1->req_buffer.length)\n\tkrb5_abortx(VAR_0, \"internal error in ASN.1 encoder\");\n\n    VAR_3->data = VAR_1->req_buffer.data;\n    VAR_3->length = VAR_1->req_buffer.length;\n\n    *VAR_5 = VAR_37;\n\n    return 0;\n out:\n    return VAR_6;\n}",
  "func_graph_path": "heimdal/2f7f3d9960aa6ea21358bdf3687cee5149aa35cf/init_creds_pw.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -95,6 +95,26 @@\n \t\t\t\t       &ctx->req_buffer,\n \t\t\t\t       NULL,\n \t\t\t\t       NULL);\n+\t    if (ret == 0 && ctx->pk_init_ctx) {\n+\t\tPA_DATA *pa_pkinit_kx;\n+\t\tint idx = 0;\n+\n+\t\tpa_pkinit_kx =\n+\t\t    krb5_find_padata(rep.kdc_rep.padata->val,\n+\t\t\t\t     rep.kdc_rep.padata->len,\n+\t\t\t\t     KRB5_PADATA_PKINIT_KX,\n+\t\t\t\t     &idx);\n+\n+\t\tret = _krb5_pk_kx_confirm(context, ctx->pk_init_ctx,\n+\t\t\t\t\t  ctx->fast_state.reply_key,\n+\t\t\t\t\t  &ctx->cred.session,\n+\t\t\t\t\t  pa_pkinit_kx);\n+\t\tif (ret)\n+\t\t    krb5_set_error_message(context, ret,\n+\t\t\t\t\t   N_(\"Failed to confirm PA-PKINIT-KX\", \"\"));\n+\t\telse if (pa_pkinit_kx != NULL)\n+\t\t    ctx->ic_flags |= KRB5_INIT_CREDS_PKINIT_KX_VALID;\n+\t    }\n \t    if (ret == 0)\n \t\tret = copy_EncKDCRepPart(&rep.enc_part, &ctx->enc_part);\n ",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "\t    if (ret == 0 && ctx->pk_init_ctx) {",
      "\t\tPA_DATA *pa_pkinit_kx;",
      "\t\tint idx = 0;",
      "",
      "\t\tpa_pkinit_kx =",
      "\t\t    krb5_find_padata(rep.kdc_rep.padata->val,",
      "\t\t\t\t     rep.kdc_rep.padata->len,",
      "\t\t\t\t     KRB5_PADATA_PKINIT_KX,",
      "\t\t\t\t     &idx);",
      "",
      "\t\tret = _krb5_pk_kx_confirm(context, ctx->pk_init_ctx,",
      "\t\t\t\t\t  ctx->fast_state.reply_key,",
      "\t\t\t\t\t  &ctx->cred.session,",
      "\t\t\t\t\t  pa_pkinit_kx);",
      "\t\tif (ret)",
      "\t\t    krb5_set_error_message(context, ret,",
      "\t\t\t\t\t   N_(\"Failed to confirm PA-PKINIT-KX\", \"\"));",
      "\t\telse if (pa_pkinit_kx != NULL)",
      "\t\t    ctx->ic_flags |= KRB5_INIT_CREDS_PKINIT_KX_VALID;",
      "\t    }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/heimdal/heimdal/pull/1222",
  "description": {
    "pr_info": {
      "title": "Contents of 7.8.1 release",
      "number": 1222
    },
    "comment": [
      "I pushed e4fa0dbc76f..1b4565a29fc to `heimdal-7-1-branch`.  Those and the ones from the `heimdal-7.8.0` tag to the new HEAD are all included here.\r\n\r\nThe commits that had already been in the `heimdal-7-1-branch` were a6cf94577c0..e4fa0dbc76f:\r\n\r\ne4fa0dbc76f roken: do not override system network address functions\r\n28daf24eb3e kdc: Check generate_pac() return code\r\nf6b0433bab7 lib/krb5: krb5_pac_parse mem leak if pac_header_size failure\r\n5e2e89b1b55 lib/krb5: fix _krb5_get_int64 on 32-bit systems\r\n3c9019d6781 kuser/kinit:  NO_AFS unused-but-set-variable\r\n6fa4d051905 lib/ipc: set but unused 'kr' variables\r\n4cd3926e14e kdc: avoid re-encoding KDC-REQ-BODY\r\n\r\nand the new commits are:\r\n\r\n1b4565a29fc Bump version to 7.8.1\r\n191d1d48a11 Update NEWS for 7.8.1 release\r\n61198c52323 GHA: Enable fallback hcrypto backend for OS X build\r\n3e7bfff54b4 GHA: Disable AFS support for Linux\r\n74647686661 GHA: Use newer Linux runners\r\nf8c3a03893d cf: Deal with clang-format not being available\r\nf136efa7c59 hcrypto: Don't test rc2 nor rc4 (OS X)\r\ncd4f7c91809 kinit: Fix build error\r\nd60d2eacc40 kadm5: Added kadm_log_init_recover\r\nd2faa389600 ipropd_slave: open hdb around kadm5_log_init in case recovery needed\r\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "The commit addresses a known security vulnerability (CVE-2019-12098) by enforcing the validation of the PA-PKINIT-KX key exchange, preventing potential man-in-the-middle attacks. The code changes directly implement these security measures.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}