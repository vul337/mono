{
  "cve_id": "CVE-2019-16869",
  "cwe_ids": [
    "CWE-444"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "netty",
  "commit_msg": "Correctly handle whitespaces in HTTP header names as defined by RFC7230#section-3.2.4 (#9585)\n\nMotivation:\r\n\r\nWhen parsing HTTP headers special care needs to be taken when a whitespace is detected in the header name.\r\n\r\nModifications:\r\n\r\n- Ignore whitespace when decoding response (just like before)\r\n- Throw exception when whitespace is detected during parsing\r\n- Add unit tests\r\n\r\nResult:\r\n\r\nFixes https://github.com/netty/netty/issues/9571",
  "commit_hash": "39cafcb05c99f2aa9fce7e6597664c9ed6a63a95",
  "git_url": "https://github.com/netty/netty/commit/39cafcb05c99f2aa9fce7e6597664c9ed6a63a95",
  "file_path": "codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java",
  "func_name": "splitHeader",
  "func_before": "private void splitHeader(AppendableCharSequence sb) {\n        final int length = sb.length();\n        int nameStart;\n        int nameEnd;\n        int colonEnd;\n        int valueStart;\n        int valueEnd;\n\n        nameStart = findNonWhitespace(sb, 0);\n        for (nameEnd = nameStart; nameEnd < length; nameEnd ++) {\n            char ch = sb.charAtUnsafe(nameEnd);\n            if (ch == ':' || Character.isWhitespace(ch)) {\n                break;\n            }\n        }\n\n        for (colonEnd = nameEnd; colonEnd < length; colonEnd ++) {\n            if (sb.charAtUnsafe(colonEnd) == ':') {\n                colonEnd ++;\n                break;\n            }\n        }\n\n        name = sb.subStringUnsafe(nameStart, nameEnd);\n        valueStart = findNonWhitespace(sb, colonEnd);\n        if (valueStart == length) {\n            value = EMPTY_VALUE;\n        } else {\n            valueEnd = findEndOfString(sb);\n            value = sb.subStringUnsafe(valueStart, valueEnd);\n        }\n    }",
  "abstract_func_before": "private void splitHeader(AppendableCharSequence VAR_0) {\n        final int VAR_1 = VAR_0.length();\n        int VAR_2;\n        int VAR_3;\n        int VAR_4;\n        int VAR_5;\n        int VAR_6;\n\n        VAR_2 = findNonWhitespace(VAR_0, 0);\n        for (VAR_3 = VAR_2; VAR_3 < VAR_1; VAR_3 ++) {\n            char VAR_7 = VAR_0.charAtUnsafe(VAR_3);\n            if (VAR_7 == ':' || VAR_8.isWhitespace(VAR_7)) {\n                break;\n            }\n        }\n\n        for (VAR_4 = VAR_3; VAR_4 < VAR_1; VAR_4 ++) {\n            if (VAR_0.charAtUnsafe(VAR_4) == ':') {\n                VAR_4 ++;\n                break;\n            }\n        }\n\n        VAR_9 = VAR_0.subStringUnsafe(VAR_2, VAR_3);\n        VAR_5 = findNonWhitespace(VAR_0, VAR_4);\n        if (VAR_5 == VAR_1) {\n            VAR_10 = VAR_11;\n        } else {\n            VAR_6 = findEndOfString(VAR_0);\n            VAR_10 = VAR_0.subStringUnsafe(VAR_5, VAR_6);\n        }\n    }",
  "func_graph_path_before": "netty/39cafcb05c99f2aa9fce7e6597664c9ed6a63a95/HttpObjectDecoder.java/vul/before/0.json",
  "func": "private void splitHeader(AppendableCharSequence sb) {\n        final int length = sb.length();\n        int nameStart;\n        int nameEnd;\n        int colonEnd;\n        int valueStart;\n        int valueEnd;\n\n        nameStart = findNonWhitespace(sb, 0);\n        for (nameEnd = nameStart; nameEnd < length; nameEnd ++) {\n            char ch = sb.charAtUnsafe(nameEnd);\n            // https://tools.ietf.org/html/rfc7230#section-3.2.4\n            //\n            // No whitespace is allowed between the header field-name and colon. In\n            // the past, differences in the handling of such whitespace have led to\n            // security vulnerabilities in request routing and response handling. A\n            // server MUST reject any received request message that contains\n            // whitespace between a header field-name and colon with a response code\n            // of 400 (Bad Request). A proxy MUST remove any such whitespace from a\n            // response message before forwarding the message downstream.\n            if (ch == ':' ||\n                    // In case of decoding a request we will just continue processing and header validation\n                    // is done in the DefaultHttpHeaders implementation.\n                    //\n                    // In the case of decoding a response we will \"skip\" the whitespace.\n                    (!isDecodingRequest() && Character.isWhitespace(ch))) {\n                break;\n            }\n        }\n\n        for (colonEnd = nameEnd; colonEnd < length; colonEnd ++) {\n            if (sb.charAtUnsafe(colonEnd) == ':') {\n                colonEnd ++;\n                break;\n            }\n        }\n\n        name = sb.subStringUnsafe(nameStart, nameEnd);\n        valueStart = findNonWhitespace(sb, colonEnd);\n        if (valueStart == length) {\n            value = EMPTY_VALUE;\n        } else {\n            valueEnd = findEndOfString(sb);\n            value = sb.subStringUnsafe(valueStart, valueEnd);\n        }\n    }",
  "abstract_func": "private void splitHeader(AppendableCharSequence VAR_0) {\n        final int VAR_1 = VAR_0.length();\n        int VAR_2;\n        int VAR_3;\n        int VAR_4;\n        int VAR_5;\n        int VAR_6;\n\n        VAR_2 = findNonWhitespace(VAR_0, 0);\n        for (VAR_3 = VAR_2; VAR_3 < VAR_1; VAR_3 ++) {\n            char VAR_7 = VAR_0.charAtUnsafe(VAR_3);\n            /* COMMENT_0 */\n            /* COMMENT_1 */\n            /* COMMENT_2 */\n            /* COMMENT_3 */\n            /* COMMENT_4 */\n            /* COMMENT_5 */\n            /* COMMENT_6 */\n            /* COMMENT_7 */\n            /* COMMENT_8 */\n            if (VAR_7 == ':' ||\n                    /* COMMENT_9 */\n                    /* COMMENT_10 */\n                    /* COMMENT_1 */\n                    /* COMMENT_11 */\n                    (!isDecodingRequest() && VAR_8.isWhitespace(VAR_7))) {\n                break;\n            }\n        }\n\n        for (VAR_4 = VAR_3; VAR_4 < VAR_1; VAR_4 ++) {\n            if (VAR_0.charAtUnsafe(VAR_4) == ':') {\n                VAR_4 ++;\n                break;\n            }\n        }\n\n        VAR_9 = VAR_0.subStringUnsafe(VAR_2, VAR_3);\n        VAR_5 = findNonWhitespace(VAR_0, VAR_4);\n        if (VAR_5 == VAR_1) {\n            VAR_10 = VAR_11;\n        } else {\n            VAR_6 = findEndOfString(VAR_0);\n            VAR_10 = VAR_0.subStringUnsafe(VAR_5, VAR_6);\n        }\n    }",
  "func_graph_path": "netty/39cafcb05c99f2aa9fce7e6597664c9ed6a63a95/HttpObjectDecoder.java/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -9,7 +9,21 @@\n         nameStart = findNonWhitespace(sb, 0);\n         for (nameEnd = nameStart; nameEnd < length; nameEnd ++) {\n             char ch = sb.charAtUnsafe(nameEnd);\n-            if (ch == ':' || Character.isWhitespace(ch)) {\n+            // https://tools.ietf.org/html/rfc7230#section-3.2.4\n+            //\n+            // No whitespace is allowed between the header field-name and colon. In\n+            // the past, differences in the handling of such whitespace have led to\n+            // security vulnerabilities in request routing and response handling. A\n+            // server MUST reject any received request message that contains\n+            // whitespace between a header field-name and colon with a response code\n+            // of 400 (Bad Request). A proxy MUST remove any such whitespace from a\n+            // response message before forwarding the message downstream.\n+            if (ch == ':' ||\n+                    // In case of decoding a request we will just continue processing and header validation\n+                    // is done in the DefaultHttpHeaders implementation.\n+                    //\n+                    // In the case of decoding a response we will \"skip\" the whitespace.\n+                    (!isDecodingRequest() && Character.isWhitespace(ch))) {\n                 break;\n             }\n         }",
  "diff_line_info": {
    "deleted_lines": [
      "            if (ch == ':' || Character.isWhitespace(ch)) {"
    ],
    "added_lines": [
      "            // https://tools.ietf.org/html/rfc7230#section-3.2.4",
      "            //",
      "            // No whitespace is allowed between the header field-name and colon. In",
      "            // the past, differences in the handling of such whitespace have led to",
      "            // security vulnerabilities in request routing and response handling. A",
      "            // server MUST reject any received request message that contains",
      "            // whitespace between a header field-name and colon with a response code",
      "            // of 400 (Bad Request). A proxy MUST remove any such whitespace from a",
      "            // response message before forwarding the message downstream.",
      "            if (ch == ':' ||",
      "                    // In case of decoding a request we will just continue processing and header validation",
      "                    // is done in the DefaultHttpHeaders implementation.",
      "                    //",
      "                    // In the case of decoding a response we will \"skip\" the whitespace.",
      "                    (!isDecodingRequest() && Character.isWhitespace(ch))) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/netty/netty/pull/9585",
  "description": {
    "pr_info": {
      "title": "Correctly handle whitespaces in HTTP header names as defined by RFC72…",
      "number": 9585
    },
    "comment": [
      "…30#section-3.2.4\r\n\r\nMotivation:\r\n\r\nWhen parsing HTTP headers special care needs to be taken when a whitespace is detected in the header name.\r\n\r\nModifications:\r\n\r\n- Ignore whitespace when decoding response (just like before)\r\n- Throw exception when whitespace is detected during parsing\r\n- Add unit tests\r\n\r\nResult:\r\n\r\nFixes https://github.com/netty/netty/issues/9571",
      "@netty-bot test this please "
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}