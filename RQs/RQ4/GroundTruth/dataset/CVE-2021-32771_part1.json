{
  "cve_id": "CVE-2021-32771",
  "cwe_ids": [
    "CWE-120"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "contiki-ng",
  "commit_msg": "Check RPL Target prefix length and buffer boundary.",
  "commit_hash": "587ae59956e00316fd44fd7072ac3a6a07b4b20f",
  "git_url": "https://github.com/contiki-ng/contiki-ng/commit/587ae59956e00316fd44fd7072ac3a6a07b4b20f",
  "file_path": "os/net/routing/rpl-classic/rpl-icmp6.c",
  "func_name": "dao_input_nonstoring",
  "func_before": "static void\ndao_input_nonstoring(void)\n{\n#if RPL_WITH_NON_STORING\n  uip_ipaddr_t dao_sender_addr;\n  uip_ipaddr_t dao_parent_addr;\n  rpl_dag_t *dag;\n  rpl_instance_t *instance;\n  unsigned char *buffer;\n  uint16_t sequence;\n  uint8_t instance_id;\n  uint8_t lifetime;\n  uint8_t prefixlen;\n  uint8_t flags;\n  uint8_t subopt_type;\n  uip_ipaddr_t prefix;\n  uint8_t buffer_length;\n  int pos;\n  int len;\n  int i;\n\n  /* Destination Advertisement Object */\n  LOG_INFO(\"Received a DAO from \");\n  LOG_INFO_6ADDR(&UIP_IP_BUF->srcipaddr);\n  LOG_INFO_(\"\\n\");\n\n  prefixlen = 0;\n\n  uip_ipaddr_copy(&dao_sender_addr, &UIP_IP_BUF->srcipaddr);\n  memset(&dao_parent_addr, 0, 16);\n\n  buffer = UIP_ICMP_PAYLOAD;\n  buffer_length = uip_len - uip_l3_icmp_hdr_len;\n\n  pos = 0;\n  instance_id = buffer[pos++];\n  instance = rpl_get_instance(instance_id);\n  lifetime = instance->default_lifetime;\n\n  flags = buffer[pos++];\n  /* reserved */\n  pos++;\n  sequence = buffer[pos++];\n\n  dag = instance->current_dag;\n  /* Is the DAG ID present? */\n  if(flags & RPL_DAO_D_FLAG) {\n    if(memcmp(&dag->dag_id, &buffer[pos], sizeof(dag->dag_id))) {\n      LOG_INFO(\"Ignoring a DAO for a DAG different from ours\\n\");\n      return;\n    }\n    pos += 16;\n  }\n\n  /* Check if there are any RPL options present. */\n  for(i = pos; i < buffer_length; i += len) {\n    subopt_type = buffer[i];\n    if(subopt_type == RPL_OPTION_PAD1) {\n      len = 1;\n    } else {\n      /* The option consists of a two-byte header and a payload. */\n      len = 2 + buffer[i + 1];\n    }\n\n    switch(subopt_type) {\n      case RPL_OPTION_TARGET:\n        /* Handle the target option. */\n        prefixlen = buffer[i + 3];\n        memset(&prefix, 0, sizeof(prefix));\n        memcpy(&prefix, buffer + i + 4, (prefixlen + 7) / CHAR_BIT);\n        break;\n      case RPL_OPTION_TRANSIT:\n        /* The path sequence and control are ignored. */\n        /*      pathcontrol = buffer[i + 3];\n                pathsequence = buffer[i + 4];*/\n        lifetime = buffer[i + 5];\n        if(len >= 20) {\n          memcpy(&dao_parent_addr, buffer + i + 6, 16);\n        }\n        break;\n    }\n  }\n\n  LOG_INFO(\"DAO lifetime: %u, prefix length: %u prefix: \",\n         (unsigned)lifetime, (unsigned)prefixlen);\n  LOG_INFO_6ADDR(&prefix);\n  LOG_INFO_(\", parent: \");\n  LOG_INFO_6ADDR(&dao_parent_addr);\n  LOG_INFO_(\"\\n\");\n\n  if(lifetime == RPL_ZERO_LIFETIME) {\n    LOG_DBG(\"No-Path DAO received\\n\");\n    uip_sr_expire_parent(dag, &prefix, &dao_parent_addr);\n  } else {\n    if(uip_sr_update_node(dag, &prefix, &dao_parent_addr, RPL_LIFETIME(instance, lifetime)) == NULL) {\n      LOG_WARN(\"DAO failed to add link prefix: \");\n      LOG_WARN_6ADDR(&prefix);\n      LOG_WARN_(\", parent: \");\n      LOG_WARN_6ADDR(&dao_parent_addr);\n      LOG_WARN_(\"\\n\");\n      return;\n    }\n  }\n\n  if(flags & RPL_DAO_K_FLAG) {\n    LOG_DBG(\"Sending DAO ACK\\n\");\n    uipbuf_clear();\n    dao_ack_output(instance, &dao_sender_addr, sequence,\n                   RPL_DAO_ACK_UNCONDITIONAL_ACCEPT);\n  }\n#endif /* RPL_WITH_NON_STORING */\n}",
  "abstract_func_before": "static void\ndao_input_nonstoring(void)\n{\n#if VAR_0\n  uip_ipaddr_t VAR_1;\n  uip_ipaddr_t VAR_2;\n  rpl_dag_t *VAR_3;\n  rpl_instance_t *VAR_4;\n  unsigned char *VAR_5;\n  uint16_t VAR_6;\n  uint8_t VAR_7;\n  uint8_t VAR_8;\n  uint8_t VAR_9;\n  uint8_t VAR_10;\n  uint8_t VAR_11;\n  uip_ipaddr_t VAR_12;\n  uint8_t VAR_13;\n  int VAR_14;\n  int VAR_15;\n  int VAR_16;\n\n  /* COMMENT_0 */\n  LOG_INFO(\"Received a DAO from \");\n  LOG_INFO_6ADDR(&VAR_17->srcipaddr);\n  LOG_INFO_(\"\\n\");\n\n  VAR_9 = 0;\n\n  uip_ipaddr_copy(&VAR_1, &VAR_17->srcipaddr);\n  memset(&VAR_2, 0, 16);\n\n  VAR_5 = VAR_18;\n  VAR_13 = VAR_19 - VAR_20;\n\n  VAR_14 = 0;\n  VAR_7 = VAR_5[VAR_14++];\n  VAR_4 = rpl_get_instance(VAR_7);\n  VAR_8 = VAR_4->default_lifetime;\n\n  VAR_10 = VAR_5[VAR_14++];\n  /* COMMENT_1 */\n  VAR_14++;\n  VAR_6 = VAR_5[VAR_14++];\n\n  VAR_3 = VAR_4->current_dag;\n  /* COMMENT_2 */\n  if(VAR_10 & VAR_21) {\n    if(memcmp(&VAR_3->dag_id, &VAR_5[VAR_14], sizeof(VAR_3->dag_id))) {\n      LOG_INFO(\"Ignoring a DAO for a DAG different from ours\\n\");\n      return;\n    }\n    VAR_14 += 16;\n  }\n\n  /* COMMENT_3 */\n  for(VAR_16 = VAR_14; VAR_16 < VAR_13; VAR_16 += VAR_15) {\n    VAR_11 = VAR_5[VAR_16];\n    if(VAR_11 == VAR_22) {\n      VAR_15 = 1;\n    } else {\n      /* COMMENT_4 */\n      VAR_15 = 2 + VAR_5[VAR_16 + 1];\n    }\n\n    switch(VAR_11) {\n      case VAR_23:\n        /* COMMENT_5 */\n        VAR_9 = VAR_5[VAR_16 + 3];\n        memset(&VAR_12, 0, sizeof(VAR_12));\n        memcpy(&VAR_12, VAR_5 + VAR_16 + 4, (VAR_9 + 7) / VAR_24);\n        break;\n      case VAR_25:\n        /* COMMENT_6 */\n        /* COMMENT_7 */\n                                               \n        VAR_8 = VAR_5[VAR_16 + 5];\n        if(VAR_15 >= 20) {\n          memcpy(&VAR_2, VAR_5 + VAR_16 + 6, 16);\n        }\n        break;\n    }\n  }\n\n  LOG_INFO(\"DAO lifetime: %u, prefix length: %u prefix: \",\n         (unsigned)VAR_8, (unsigned)VAR_9);\n  LOG_INFO_6ADDR(&VAR_12);\n  LOG_INFO_(\", parent: \");\n  LOG_INFO_6ADDR(&VAR_2);\n  LOG_INFO_(\"\\n\");\n\n  if(VAR_8 == VAR_26) {\n    LOG_DBG(\"No-Path DAO received\\n\");\n    uip_sr_expire_parent(VAR_3, &VAR_12, &VAR_2);\n  } else {\n    if(uip_sr_update_node(VAR_3, &VAR_12, &VAR_2, RPL_LIFETIME(VAR_4, VAR_8)) == NULL) {\n      LOG_WARN(\"DAO failed to add link prefix: \");\n      LOG_WARN_6ADDR(&VAR_12);\n      LOG_WARN_(\", parent: \");\n      LOG_WARN_6ADDR(&VAR_2);\n      LOG_WARN_(\"\\n\");\n      return;\n    }\n  }\n\n  if(VAR_10 & VAR_27) {\n    LOG_DBG(\"Sending DAO ACK\\n\");\n    uipbuf_clear();\n    dao_ack_output(VAR_4, &VAR_1, VAR_6,\n                   VAR_28);\n  }\n#endif /* COMMENT_9 */\n}",
  "func_graph_path_before": "contiki-ng/587ae59956e00316fd44fd7072ac3a6a07b4b20f/rpl-icmp6.c/vul/before/0.json",
  "func": "static void\ndao_input_nonstoring(void)\n{\n#if RPL_WITH_NON_STORING\n  uip_ipaddr_t dao_sender_addr;\n  uip_ipaddr_t dao_parent_addr;\n  rpl_dag_t *dag;\n  rpl_instance_t *instance;\n  unsigned char *buffer;\n  uint16_t sequence;\n  uint8_t instance_id;\n  uint8_t lifetime;\n  uint8_t prefixlen;\n  uint8_t flags;\n  uint8_t subopt_type;\n  uip_ipaddr_t prefix;\n  uint8_t buffer_length;\n  int pos;\n  int len;\n  int i;\n\n  /* Destination Advertisement Object */\n  LOG_INFO(\"Received a DAO from \");\n  LOG_INFO_6ADDR(&UIP_IP_BUF->srcipaddr);\n  LOG_INFO_(\"\\n\");\n\n  prefixlen = 0;\n\n  uip_ipaddr_copy(&dao_sender_addr, &UIP_IP_BUF->srcipaddr);\n  memset(&dao_parent_addr, 0, 16);\n\n  buffer = UIP_ICMP_PAYLOAD;\n  buffer_length = uip_len - uip_l3_icmp_hdr_len;\n\n  pos = 0;\n  instance_id = buffer[pos++];\n  instance = rpl_get_instance(instance_id);\n  lifetime = instance->default_lifetime;\n\n  flags = buffer[pos++];\n  /* reserved */\n  pos++;\n  sequence = buffer[pos++];\n\n  dag = instance->current_dag;\n  /* Is the DAG ID present? */\n  if(flags & RPL_DAO_D_FLAG) {\n    if(memcmp(&dag->dag_id, &buffer[pos], sizeof(dag->dag_id))) {\n      LOG_INFO(\"Ignoring a DAO for a DAG different from ours\\n\");\n      return;\n    }\n    pos += 16;\n  }\n\n  /* Check if there are any RPL options present. */\n  for(i = pos; i < buffer_length; i += len) {\n    subopt_type = buffer[i];\n    if(subopt_type == RPL_OPTION_PAD1) {\n      len = 1;\n    } else {\n      /* The option consists of a two-byte header and a payload. */\n      len = 2 + buffer[i + 1];\n    }\n\n    switch(subopt_type) {\n      case RPL_OPTION_TARGET:\n        /* Handle the target option. */\n        prefixlen = buffer[i + 3];\n        if(prefixlen == 0) {\n          /* Ignore option targets with a prefix length of 0. */\n          break;\n        }\n        if(prefixlen > 128) {\n          LOG_ERR(\"Too large target prefix length %d\\n\", prefixlen);\n          return;\n        }\n        if(i + 4 + ((prefixlen + 7) / CHAR_BIT) > buffer_length) {\n          LOG_ERR(\"Insufficient space to copy RPL Target of %d bits\\n\",\n                  prefixlen);\n          return;\n        }\n        memset(&prefix, 0, sizeof(prefix));\n        memcpy(&prefix, buffer + i + 4, (prefixlen + 7) / CHAR_BIT);\n        break;\n      case RPL_OPTION_TRANSIT:\n        /* The path sequence and control are ignored. */\n        /*      pathcontrol = buffer[i + 3];\n                pathsequence = buffer[i + 4];*/\n        lifetime = buffer[i + 5];\n        if(len >= 20) {\n          memcpy(&dao_parent_addr, buffer + i + 6, 16);\n        }\n        break;\n    }\n  }\n\n  LOG_INFO(\"DAO lifetime: %u, prefix length: %u prefix: \",\n         (unsigned)lifetime, (unsigned)prefixlen);\n  LOG_INFO_6ADDR(&prefix);\n  LOG_INFO_(\", parent: \");\n  LOG_INFO_6ADDR(&dao_parent_addr);\n  LOG_INFO_(\"\\n\");\n\n  if(lifetime == RPL_ZERO_LIFETIME) {\n    LOG_DBG(\"No-Path DAO received\\n\");\n    uip_sr_expire_parent(dag, &prefix, &dao_parent_addr);\n  } else {\n    if(uip_sr_update_node(dag, &prefix, &dao_parent_addr, RPL_LIFETIME(instance, lifetime)) == NULL) {\n      LOG_WARN(\"DAO failed to add link prefix: \");\n      LOG_WARN_6ADDR(&prefix);\n      LOG_WARN_(\", parent: \");\n      LOG_WARN_6ADDR(&dao_parent_addr);\n      LOG_WARN_(\"\\n\");\n      return;\n    }\n  }\n\n  if(flags & RPL_DAO_K_FLAG) {\n    LOG_DBG(\"Sending DAO ACK\\n\");\n    uipbuf_clear();\n    dao_ack_output(instance, &dao_sender_addr, sequence,\n                   RPL_DAO_ACK_UNCONDITIONAL_ACCEPT);\n  }\n#endif /* RPL_WITH_NON_STORING */\n}",
  "abstract_func": "static void\ndao_input_nonstoring(void)\n{\n#if VAR_0\n  uip_ipaddr_t VAR_1;\n  uip_ipaddr_t VAR_2;\n  rpl_dag_t *VAR_3;\n  rpl_instance_t *VAR_4;\n  unsigned char *VAR_5;\n  uint16_t VAR_6;\n  uint8_t VAR_7;\n  uint8_t VAR_8;\n  uint8_t VAR_9;\n  uint8_t VAR_10;\n  uint8_t VAR_11;\n  uip_ipaddr_t VAR_12;\n  uint8_t VAR_13;\n  int VAR_14;\n  int VAR_15;\n  int VAR_16;\n\n  /* COMMENT_0 */\n  LOG_INFO(\"Received a DAO from \");\n  LOG_INFO_6ADDR(&VAR_17->srcipaddr);\n  LOG_INFO_(\"\\n\");\n\n  VAR_9 = 0;\n\n  uip_ipaddr_copy(&VAR_1, &VAR_17->srcipaddr);\n  memset(&VAR_2, 0, 16);\n\n  VAR_5 = VAR_18;\n  VAR_13 = VAR_19 - VAR_20;\n\n  VAR_14 = 0;\n  VAR_7 = VAR_5[VAR_14++];\n  VAR_4 = rpl_get_instance(VAR_7);\n  VAR_8 = VAR_4->default_lifetime;\n\n  VAR_10 = VAR_5[VAR_14++];\n  /* COMMENT_1 */\n  VAR_14++;\n  VAR_6 = VAR_5[VAR_14++];\n\n  VAR_3 = VAR_4->current_dag;\n  /* COMMENT_2 */\n  if(VAR_10 & VAR_21) {\n    if(memcmp(&VAR_3->dag_id, &VAR_5[VAR_14], sizeof(VAR_3->dag_id))) {\n      LOG_INFO(\"Ignoring a DAO for a DAG different from ours\\n\");\n      return;\n    }\n    VAR_14 += 16;\n  }\n\n  /* COMMENT_3 */\n  for(VAR_16 = VAR_14; VAR_16 < VAR_13; VAR_16 += VAR_15) {\n    VAR_11 = VAR_5[VAR_16];\n    if(VAR_11 == VAR_22) {\n      VAR_15 = 1;\n    } else {\n      /* COMMENT_4 */\n      VAR_15 = 2 + VAR_5[VAR_16 + 1];\n    }\n\n    switch(VAR_11) {\n      case VAR_23:\n        /* COMMENT_5 */\n        VAR_9 = VAR_5[VAR_16 + 3];\n        if(VAR_9 == 0) {\n          /* COMMENT_6 */\n          break;\n        }\n        if(VAR_9 > 128) {\n          LOG_ERR(\"Too large target prefix length %d\\n\", VAR_9);\n          return;\n        }\n        if(VAR_16 + 4 + ((VAR_9 + 7) / VAR_24) > VAR_13) {\n          LOG_ERR(\"Insufficient space to copy RPL Target of %d bits\\n\",\n                  VAR_9);\n          return;\n        }\n        memset(&VAR_12, 0, sizeof(VAR_12));\n        memcpy(&VAR_12, VAR_5 + VAR_16 + 4, (VAR_9 + 7) / VAR_24);\n        break;\n      case VAR_25:\n        /* COMMENT_7 */\n        /* COMMENT_8 */\n                                               \n        VAR_8 = VAR_5[VAR_16 + 5];\n        if(VAR_15 >= 20) {\n          memcpy(&VAR_2, VAR_5 + VAR_16 + 6, 16);\n        }\n        break;\n    }\n  }\n\n  LOG_INFO(\"DAO lifetime: %u, prefix length: %u prefix: \",\n         (unsigned)VAR_8, (unsigned)VAR_9);\n  LOG_INFO_6ADDR(&VAR_12);\n  LOG_INFO_(\", parent: \");\n  LOG_INFO_6ADDR(&VAR_2);\n  LOG_INFO_(\"\\n\");\n\n  if(VAR_8 == VAR_26) {\n    LOG_DBG(\"No-Path DAO received\\n\");\n    uip_sr_expire_parent(VAR_3, &VAR_12, &VAR_2);\n  } else {\n    if(uip_sr_update_node(VAR_3, &VAR_12, &VAR_2, RPL_LIFETIME(VAR_4, VAR_8)) == NULL) {\n      LOG_WARN(\"DAO failed to add link prefix: \");\n      LOG_WARN_6ADDR(&VAR_12);\n      LOG_WARN_(\", parent: \");\n      LOG_WARN_6ADDR(&VAR_2);\n      LOG_WARN_(\"\\n\");\n      return;\n    }\n  }\n\n  if(VAR_10 & VAR_27) {\n    LOG_DBG(\"Sending DAO ACK\\n\");\n    uipbuf_clear();\n    dao_ack_output(VAR_4, &VAR_1, VAR_6,\n                   VAR_28);\n  }\n#endif /* COMMENT_10 */\n}",
  "func_graph_path": "contiki-ng/587ae59956e00316fd44fd7072ac3a6a07b4b20f/rpl-icmp6.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -66,6 +66,19 @@\n       case RPL_OPTION_TARGET:\n         /* Handle the target option. */\n         prefixlen = buffer[i + 3];\n+        if(prefixlen == 0) {\n+          /* Ignore option targets with a prefix length of 0. */\n+          break;\n+        }\n+        if(prefixlen > 128) {\n+          LOG_ERR(\"Too large target prefix length %d\\n\", prefixlen);\n+          return;\n+        }\n+        if(i + 4 + ((prefixlen + 7) / CHAR_BIT) > buffer_length) {\n+          LOG_ERR(\"Insufficient space to copy RPL Target of %d bits\\n\",\n+                  prefixlen);\n+          return;\n+        }\n         memset(&prefix, 0, sizeof(prefix));\n         memcpy(&prefix, buffer + i + 4, (prefixlen + 7) / CHAR_BIT);\n         break;",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "        if(prefixlen == 0) {",
      "          /* Ignore option targets with a prefix length of 0. */",
      "          break;",
      "        }",
      "        if(prefixlen > 128) {",
      "          LOG_ERR(\"Too large target prefix length %d\\n\", prefixlen);",
      "          return;",
      "        }",
      "        if(i + 4 + ((prefixlen + 7) / CHAR_BIT) > buffer_length) {",
      "          LOG_ERR(\"Insufficient space to copy RPL Target of %d bits\\n\",",
      "                  prefixlen);",
      "          return;",
      "        }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/contiki-ng/contiki-ng/pull/1615",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/contiki-ng/contiki-ng/pull/1615: 403 Client Error: Forbidden for url: https://api.github.com/repos/contiki-ng/contiki-ng/pulls/1615",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0\n\nThe patch addresses a security issue by adding checks for invalid prefix lengths and buffer boundaries, which prevents potential buffer overflow attacks. The code changes align perfectly with the described vulnerability, making this a clear security fix with high confidence."
}