{
  "cve_id": "CVE-2022-36042",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "rizinorg/rizin",
  "commit_msg": "Fix oob write in dyldcache\n\nWhen the individual n_slide_infos were too high, the sum would overflow\nand too few entries would be allocated.",
  "commit_hash": "556ca2f9eef01ec0f4a76d1fbacfcf3a87a44810",
  "git_url": "https://github.com/rizinorg/rizin/commit/556ca2f9eef01ec0f4a76d1fbacfcf3a87a44810",
  "file_path": "librz/bin/format/mach0/dyldcache.c",
  "func_name": "get_rebase_infos",
  "func_before": "static RzDyldRebaseInfos *get_rebase_infos(RzDyldCache *cache) {\n\tRzDyldRebaseInfos *result = RZ_NEW0(RzDyldRebaseInfos);\n\tif (!result) {\n\t\treturn NULL;\n\t}\n\n\tif (!cache->hdr->slideInfoOffset || !cache->hdr->slideInfoSize) {\n\t\tut32 total_slide_infos = 0;\n\t\tut32 n_slide_infos[MAX_N_HDR];\n\n\t\tut32 i;\n\t\tfor (i = 0; i < cache->n_hdr && i < MAX_N_HDR; i++) {\n\t\t\tut64 hdr_offset = cache->hdr_offset[i];\n\t\t\tif (!rz_buf_read_le32_at(cache->buf, 0x13c + hdr_offset, &n_slide_infos[i])) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\ttotal_slide_infos += n_slide_infos[i];\n\t\t}\n\n\t\tif (!total_slide_infos) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tRzDyldRebaseInfosEntry *infos = RZ_NEWS0(RzDyldRebaseInfosEntry, total_slide_infos);\n\t\tif (!infos) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tut32 k = 0;\n\t\tfor (i = 0; i < cache->n_hdr && i < MAX_N_HDR; i++) {\n\t\t\tut64 hdr_offset = cache->hdr_offset[i];\n\t\t\tif (!n_slide_infos[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tut32 sio;\n\t\t\tif (!rz_buf_read_le32_at(cache->buf, 0x138 + hdr_offset, &sio)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tut64 slide_infos_offset = sio;\n\t\t\tif (!slide_infos_offset) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tslide_infos_offset += hdr_offset;\n\n\t\t\tut32 j;\n\t\t\tRzDyldRebaseInfo *prev_info = NULL;\n\t\t\tfor (j = 0; j < n_slide_infos[i]; j++) {\n\t\t\t\tut64 offset = slide_infos_offset + j * sizeof(cache_mapping_slide);\n\t\t\t\tcache_mapping_slide entry;\n\t\t\t\tif (rz_buf_fread_at(cache->buf, offset, (ut8 *)&entry, \"6lii\", 1) != sizeof(cache_mapping_slide)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (entry.slideInfoOffset && entry.slideInfoSize) {\n\t\t\t\t\tinfos[k].start = entry.fileOffset + hdr_offset;\n\t\t\t\t\tinfos[k].end = infos[k].start + entry.size;\n\t\t\t\t\tut64 slide = prev_info ? prev_info->slide : UT64_MAX;\n\t\t\t\t\tinfos[k].info = get_rebase_info(cache, entry.slideInfoOffset + hdr_offset, entry.slideInfoSize, entry.fileOffset + hdr_offset, slide);\n\t\t\t\t\tprev_info = infos[k].info;\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!k) {\n\t\t\tfree(infos);\n\t\t\tgoto beach;\n\t\t}\n\n\t\tif (k < total_slide_infos) {\n\t\t\tRzDyldRebaseInfosEntry *pruned_infos = RZ_NEWS0(RzDyldRebaseInfosEntry, k);\n\t\t\tif (!pruned_infos) {\n\t\t\t\tfree(infos);\n\t\t\t\tgoto beach;\n\t\t\t}\n\n\t\t\tmemcpy(pruned_infos, infos, sizeof(RzDyldRebaseInfosEntry) * k);\n\t\t\tfree(infos);\n\t\t\tinfos = pruned_infos;\n\t\t}\n\n\t\tresult->entries = infos;\n\t\tresult->length = k;\n\t\treturn result;\n\t}\n\n\tif (cache->hdr->mappingCount > 1) {\n\t\tRzDyldRebaseInfosEntry *infos = RZ_NEWS0(RzDyldRebaseInfosEntry, 1);\n\t\tif (!infos) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tinfos[0].start = cache->maps[1].fileOffset;\n\t\tinfos[0].end = infos[0].start + cache->maps[1].size;\n\t\tinfos[0].info = get_rebase_info(cache, cache->hdr->slideInfoOffset, cache->hdr->slideInfoSize, infos[0].start, UT64_MAX);\n\n\t\tresult->entries = infos;\n\t\tresult->length = 1;\n\t\treturn result;\n\t}\n\nbeach:\n\tfree(result);\n\treturn NULL;\n}",
  "abstract_func_before": "static RzDyldRebaseInfos *get_rebase_infos(RzDyldCache *VAR_0) {\n\tRzDyldRebaseInfos *VAR_1 = RZ_NEW0(RzDyldRebaseInfos);\n\tif (!VAR_1) {\n\t\treturn NULL;\n\t}\n\n\tif (!VAR_0->hdr->slideInfoOffset || !VAR_0->hdr->slideInfoSize) {\n\t\tut32 VAR_2 = 0;\n\t\tut32 VAR_3[VAR_4];\n\n\t\tut32 VAR_5;\n\t\tfor (VAR_5 = 0; VAR_5 < VAR_0->n_hdr && VAR_5 < VAR_4; VAR_5++) {\n\t\t\tut64 VAR_6 = VAR_0->hdr_offset[VAR_5];\n\t\t\tif (!rz_buf_read_le32_at(VAR_0->buf, 0x13c + VAR_6, &VAR_3[VAR_5])) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tVAR_2 += VAR_3[VAR_5];\n\t\t}\n\n\t\tif (!VAR_2) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tRzDyldRebaseInfosEntry *VAR_7 = RZ_NEWS0(RzDyldRebaseInfosEntry, VAR_2);\n\t\tif (!VAR_7) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tut32 VAR_8 = 0;\n\t\tfor (VAR_5 = 0; VAR_5 < VAR_0->n_hdr && VAR_5 < VAR_4; VAR_5++) {\n\t\t\tut64 VAR_6 = VAR_0->hdr_offset[VAR_5];\n\t\t\tif (!VAR_3[VAR_5]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tut32 VAR_9;\n\t\t\tif (!rz_buf_read_le32_at(VAR_0->buf, 0x138 + VAR_6, &VAR_9)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tut64 VAR_10 = VAR_9;\n\t\t\tif (!VAR_10) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tVAR_10 += VAR_6;\n\n\t\t\tut32 VAR_11;\n\t\t\tRzDyldRebaseInfo *VAR_12 = NULL;\n\t\t\tfor (VAR_11 = 0; VAR_11 < VAR_3[VAR_5]; VAR_11++) {\n\t\t\t\tut64 VAR_13 = VAR_10 + VAR_11 * sizeof(VAR_14);\n\t\t\t\tcache_mapping_slide VAR_15;\n\t\t\t\tif (rz_buf_fread_at(VAR_0->buf, VAR_13, (ut8 *)&VAR_15, \"6lii\", 1) != sizeof(cache_mapping_slide)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (VAR_15.slideInfoOffset && VAR_15.slideInfoSize) {\n\t\t\t\t\tVAR_7[VAR_8].start = VAR_15.fileOffset + VAR_6;\n\t\t\t\t\tVAR_7[VAR_8].end = VAR_7[VAR_8].start + VAR_15.size;\n\t\t\t\t\tut64 VAR_16 = VAR_12 ? VAR_12->slide : VAR_17;\n\t\t\t\t\tVAR_7[VAR_8].info = get_rebase_info(VAR_0, VAR_15.slideInfoOffset + VAR_6, VAR_15.slideInfoSize, VAR_15.fileOffset + VAR_6, VAR_16);\n\t\t\t\t\tVAR_12 = VAR_7[VAR_8].info;\n\t\t\t\t\tVAR_8++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!VAR_8) {\n\t\t\tfree(VAR_7);\n\t\t\tgoto beach;\n\t\t}\n\n\t\tif (VAR_8 < VAR_2) {\n\t\t\tRzDyldRebaseInfosEntry *VAR_18 = RZ_NEWS0(RzDyldRebaseInfosEntry, VAR_8);\n\t\t\tif (!VAR_18) {\n\t\t\t\tfree(VAR_7);\n\t\t\t\tgoto beach;\n\t\t\t}\n\n\t\t\tmemcpy(VAR_18, VAR_7, sizeof(RzDyldRebaseInfosEntry) * VAR_8);\n\t\t\tfree(VAR_7);\n\t\t\tVAR_7 = VAR_18;\n\t\t}\n\n\t\tVAR_1->entries = VAR_7;\n\t\tVAR_1->length = VAR_8;\n\t\treturn VAR_1;\n\t}\n\n\tif (VAR_0->hdr->mappingCount > 1) {\n\t\tRzDyldRebaseInfosEntry *VAR_7 = RZ_NEWS0(RzDyldRebaseInfosEntry, 1);\n\t\tif (!VAR_7) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tVAR_7[0].start = VAR_0->maps[1].fileOffset;\n\t\tVAR_7[0].end = VAR_7[0].start + VAR_0->maps[1].size;\n\t\tVAR_7[0].info = get_rebase_info(VAR_0, VAR_0->hdr->slideInfoOffset, VAR_0->hdr->slideInfoSize, VAR_7[0].start, VAR_17);\n\n\t\tVAR_1->entries = VAR_7;\n\t\tVAR_1->length = 1;\n\t\treturn VAR_1;\n\t}\n\nbeach:\n\tfree(VAR_1);\n\treturn NULL;\n}",
  "func_graph_path_before": "rizinorg/rizin/556ca2f9eef01ec0f4a76d1fbacfcf3a87a44810/dyldcache.c/vul/before/0.json",
  "func": "static RzDyldRebaseInfos *get_rebase_infos(RzDyldCache *cache) {\n\tRzDyldRebaseInfos *result = RZ_NEW0(RzDyldRebaseInfos);\n\tif (!result) {\n\t\treturn NULL;\n\t}\n\n\tif (!cache->hdr->slideInfoOffset || !cache->hdr->slideInfoSize) {\n\t\tsize_t total_slide_infos = 0;\n\t\tut32 n_slide_infos[MAX_N_HDR];\n\n\t\tut32 i;\n\t\tfor (i = 0; i < cache->n_hdr && i < MAX_N_HDR; i++) {\n\t\t\tut64 hdr_offset = cache->hdr_offset[i];\n\t\t\tif (!rz_buf_read_le32_at(cache->buf, 0x13c + hdr_offset, &n_slide_infos[i])) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tut32 total = total_slide_infos + n_slide_infos[i];\n\t\t\tif (total < total_slide_infos) {\n\t\t\t\t// overflow\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\ttotal_slide_infos = total;\n\t\t}\n\n\t\tif (!total_slide_infos) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tRzDyldRebaseInfosEntry *infos = RZ_NEWS0(RzDyldRebaseInfosEntry, total_slide_infos);\n\t\tif (!infos) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tut32 k = 0;\n\t\tfor (i = 0; i < cache->n_hdr && i < MAX_N_HDR; i++) {\n\t\t\tut64 hdr_offset = cache->hdr_offset[i];\n\t\t\tif (!n_slide_infos[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tut32 sio;\n\t\t\tif (!rz_buf_read_le32_at(cache->buf, 0x138 + hdr_offset, &sio)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tut64 slide_infos_offset = sio;\n\t\t\tif (!slide_infos_offset) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tslide_infos_offset += hdr_offset;\n\n\t\t\tut32 j;\n\t\t\tRzDyldRebaseInfo *prev_info = NULL;\n\t\t\tfor (j = 0; j < n_slide_infos[i]; j++) {\n\t\t\t\tut64 offset = slide_infos_offset + j * sizeof(cache_mapping_slide);\n\t\t\t\tcache_mapping_slide entry;\n\t\t\t\tif (rz_buf_fread_at(cache->buf, offset, (ut8 *)&entry, \"6lii\", 1) != sizeof(cache_mapping_slide)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (entry.slideInfoOffset && entry.slideInfoSize) {\n\t\t\t\t\tinfos[k].start = entry.fileOffset + hdr_offset;\n\t\t\t\t\tinfos[k].end = infos[k].start + entry.size;\n\t\t\t\t\tut64 slide = prev_info ? prev_info->slide : UT64_MAX;\n\t\t\t\t\tinfos[k].info = get_rebase_info(cache, entry.slideInfoOffset + hdr_offset, entry.slideInfoSize, entry.fileOffset + hdr_offset, slide);\n\t\t\t\t\tprev_info = infos[k].info;\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!k) {\n\t\t\tfree(infos);\n\t\t\tgoto beach;\n\t\t}\n\n\t\tif (k < total_slide_infos) {\n\t\t\tRzDyldRebaseInfosEntry *pruned_infos = RZ_NEWS0(RzDyldRebaseInfosEntry, k);\n\t\t\tif (!pruned_infos) {\n\t\t\t\tfree(infos);\n\t\t\t\tgoto beach;\n\t\t\t}\n\n\t\t\tmemcpy(pruned_infos, infos, sizeof(RzDyldRebaseInfosEntry) * k);\n\t\t\tfree(infos);\n\t\t\tinfos = pruned_infos;\n\t\t}\n\n\t\tresult->entries = infos;\n\t\tresult->length = k;\n\t\treturn result;\n\t}\n\n\tif (cache->hdr->mappingCount > 1) {\n\t\tRzDyldRebaseInfosEntry *infos = RZ_NEWS0(RzDyldRebaseInfosEntry, 1);\n\t\tif (!infos) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tinfos[0].start = cache->maps[1].fileOffset;\n\t\tinfos[0].end = infos[0].start + cache->maps[1].size;\n\t\tinfos[0].info = get_rebase_info(cache, cache->hdr->slideInfoOffset, cache->hdr->slideInfoSize, infos[0].start, UT64_MAX);\n\n\t\tresult->entries = infos;\n\t\tresult->length = 1;\n\t\treturn result;\n\t}\n\nbeach:\n\tfree(result);\n\treturn NULL;\n}",
  "abstract_func": "static RzDyldRebaseInfos *get_rebase_infos(RzDyldCache *VAR_0) {\n\tRzDyldRebaseInfos *VAR_1 = RZ_NEW0(RzDyldRebaseInfos);\n\tif (!VAR_1) {\n\t\treturn NULL;\n\t}\n\n\tif (!VAR_0->hdr->slideInfoOffset || !VAR_0->hdr->slideInfoSize) {\n\t\tsize_t VAR_2 = 0;\n\t\tut32 VAR_3[VAR_4];\n\n\t\tut32 VAR_5;\n\t\tfor (VAR_5 = 0; VAR_5 < VAR_0->n_hdr && VAR_5 < VAR_4; VAR_5++) {\n\t\t\tut64 VAR_6 = VAR_0->hdr_offset[VAR_5];\n\t\t\tif (!rz_buf_read_le32_at(VAR_0->buf, 0x13c + VAR_6, &VAR_3[VAR_5])) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tut32 VAR_7 = VAR_2 + VAR_3[VAR_5];\n\t\t\tif (VAR_7 < VAR_2) {\n\t\t\t\t/* COMMENT_0 */\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tVAR_2 = VAR_7;\n\t\t}\n\n\t\tif (!VAR_2) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tRzDyldRebaseInfosEntry *VAR_8 = RZ_NEWS0(RzDyldRebaseInfosEntry, VAR_2);\n\t\tif (!VAR_8) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tut32 VAR_9 = 0;\n\t\tfor (VAR_5 = 0; VAR_5 < VAR_0->n_hdr && VAR_5 < VAR_4; VAR_5++) {\n\t\t\tut64 VAR_6 = VAR_0->hdr_offset[VAR_5];\n\t\t\tif (!VAR_3[VAR_5]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tut32 VAR_10;\n\t\t\tif (!rz_buf_read_le32_at(VAR_0->buf, 0x138 + VAR_6, &VAR_10)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tut64 VAR_11 = VAR_10;\n\t\t\tif (!VAR_11) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tVAR_11 += VAR_6;\n\n\t\t\tut32 VAR_12;\n\t\t\tRzDyldRebaseInfo *VAR_13 = NULL;\n\t\t\tfor (VAR_12 = 0; VAR_12 < VAR_3[VAR_5]; VAR_12++) {\n\t\t\t\tut64 VAR_14 = VAR_11 + VAR_12 * sizeof(VAR_15);\n\t\t\t\tcache_mapping_slide VAR_16;\n\t\t\t\tif (rz_buf_fread_at(VAR_0->buf, VAR_14, (ut8 *)&VAR_16, \"6lii\", 1) != sizeof(cache_mapping_slide)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (VAR_16.slideInfoOffset && VAR_16.slideInfoSize) {\n\t\t\t\t\tVAR_8[VAR_9].start = VAR_16.fileOffset + VAR_6;\n\t\t\t\t\tVAR_8[VAR_9].end = VAR_8[VAR_9].start + VAR_16.size;\n\t\t\t\t\tut64 VAR_17 = VAR_13 ? VAR_13->slide : VAR_18;\n\t\t\t\t\tVAR_8[VAR_9].info = get_rebase_info(VAR_0, VAR_16.slideInfoOffset + VAR_6, VAR_16.slideInfoSize, VAR_16.fileOffset + VAR_6, VAR_17);\n\t\t\t\t\tVAR_13 = VAR_8[VAR_9].info;\n\t\t\t\t\tVAR_9++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!VAR_9) {\n\t\t\tfree(VAR_8);\n\t\t\tgoto beach;\n\t\t}\n\n\t\tif (VAR_9 < VAR_2) {\n\t\t\tRzDyldRebaseInfosEntry *VAR_19 = RZ_NEWS0(RzDyldRebaseInfosEntry, VAR_9);\n\t\t\tif (!VAR_19) {\n\t\t\t\tfree(VAR_8);\n\t\t\t\tgoto beach;\n\t\t\t}\n\n\t\t\tmemcpy(VAR_19, VAR_8, sizeof(RzDyldRebaseInfosEntry) * VAR_9);\n\t\t\tfree(VAR_8);\n\t\t\tVAR_8 = VAR_19;\n\t\t}\n\n\t\tVAR_1->entries = VAR_8;\n\t\tVAR_1->length = VAR_9;\n\t\treturn VAR_1;\n\t}\n\n\tif (VAR_0->hdr->mappingCount > 1) {\n\t\tRzDyldRebaseInfosEntry *VAR_8 = RZ_NEWS0(RzDyldRebaseInfosEntry, 1);\n\t\tif (!VAR_8) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tVAR_8[0].start = VAR_0->maps[1].fileOffset;\n\t\tVAR_8[0].end = VAR_8[0].start + VAR_0->maps[1].size;\n\t\tVAR_8[0].info = get_rebase_info(VAR_0, VAR_0->hdr->slideInfoOffset, VAR_0->hdr->slideInfoSize, VAR_8[0].start, VAR_18);\n\n\t\tVAR_1->entries = VAR_8;\n\t\tVAR_1->length = 1;\n\t\treturn VAR_1;\n\t}\n\nbeach:\n\tfree(VAR_1);\n\treturn NULL;\n}",
  "func_graph_path": "rizinorg/rizin/556ca2f9eef01ec0f4a76d1fbacfcf3a87a44810/dyldcache.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,7 @@\n \t}\n \n \tif (!cache->hdr->slideInfoOffset || !cache->hdr->slideInfoSize) {\n-\t\tut32 total_slide_infos = 0;\n+\t\tsize_t total_slide_infos = 0;\n \t\tut32 n_slide_infos[MAX_N_HDR];\n \n \t\tut32 i;\n@@ -14,7 +14,12 @@\n \t\t\tif (!rz_buf_read_le32_at(cache->buf, 0x13c + hdr_offset, &n_slide_infos[i])) {\n \t\t\t\tgoto beach;\n \t\t\t}\n-\t\t\ttotal_slide_infos += n_slide_infos[i];\n+\t\t\tut32 total = total_slide_infos + n_slide_infos[i];\n+\t\t\tif (total < total_slide_infos) {\n+\t\t\t\t// overflow\n+\t\t\t\tgoto beach;\n+\t\t\t}\n+\t\t\ttotal_slide_infos = total;\n \t\t}\n \n \t\tif (!total_slide_infos) {",
  "diff_line_info": {
    "deleted_lines": [
      "\t\tut32 total_slide_infos = 0;",
      "\t\t\ttotal_slide_infos += n_slide_infos[i];"
    ],
    "added_lines": [
      "\t\tsize_t total_slide_infos = 0;",
      "\t\t\tut32 total = total_slide_infos + n_slide_infos[i];",
      "\t\t\tif (total < total_slide_infos) {",
      "\t\t\t\t// overflow",
      "\t\t\t\tgoto beach;",
      "\t\t\t}",
      "\t\t\ttotal_slide_infos = total;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/rizinorg/rizin/pull/2930",
  "description": {
    "pr_info": {
      "title": "Fix vulnerabilities on several components",
      "number": 2930
    },
    "comment": [
      "# DO NOT SQUASH\r\n\r\n**Your checklist for this pull request**\r\n- [ ] I've read the [guidelines for contributing](https://github.com/rizinorg/rizin/blob/master/DEVELOPERS.md) to this repository\r\n- [ ] I made sure to follow the project's [coding style](https://github.com/rizinorg/rizin/blob/master/DEVELOPERS.md#code-style)\r\n- [ ] I've documented or updated the documentation of every function and struct this PR changes. If not so I've explained why.\r\n- [ ] I've added tests that prove my fix is effective or that my feature works (if possible)\r\n- [ ] I've updated the [rizin book](https://github.com/rizinorg/book) with the relevant information (if needed)\r\n\r\n**Detailed description**\r\n\r\n<!-- Explain the **details** for making this change. Is a new feature implemented? What existing problem does the pull request solve? How does the pull request solve these issues? Please provide enough information so that others can review your pull request. -->\r\n\r\n...\r\n\r\n**Test plan**\r\n\r\n<!-- What steps should the reviewer take to test your pull request? Demonstrate the code is solid. Example: The exact commands you ran and their output, screenshots/videos. This is your time to re-check that everything works and that you covered all the edge cases -->\r\n\r\n...\r\n\r\n**Closing issues**\r\n\r\n<!-- put \"closes #XXXX\" in your comment to auto-close the issue that your PR fixes (if any). -->\r\n\r\n...\r\n",
      "To be cherry-picked for 0.4.1"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9"
}