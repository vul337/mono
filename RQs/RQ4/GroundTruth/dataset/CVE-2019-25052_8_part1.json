{
  "cve_id": "CVE-2019-25052",
  "cwe_ids": [
    "CWE-327"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "OP-TEE/optee_os",
  "commit_msg": "cryp: prevent direct calls to update and final functions\n\nWith inconsistent or malformed data it has been possible to call\n\"update\" and \"final\" crypto functions directly. Using a fuzzer tool [1]\nwe have seen that this results in asserts, i.e., a crash that\npotentially could leak sensitive information.\n\nBy setting the state (initialized) in the crypto context (i.e., the\ntee_cryp_state) at the end of all syscall_*_init functions and then add\na check of the state at the beginning of all update and final functions,\n  we prevent direct entrance to the \"update\" and \"final\" functions.\n\n[1] https://github.com/MartijnB/optee_fuzzer\n\nFixes: OP-TEE-2019-0021\n\nSigned-off-by: Joakim Bech <joakim.bech@linaro.org>\nReported-by: Martijn Bogaard <bogaard@riscure.com>\nAcked-by: Jerome Forissier <jerome.forissier@linaro.org>\nReviewed-by: Jens Wiklander <jens.wiklander@linaro.org>",
  "commit_hash": "34a08bec755670ea0490cb53bbc68058cafc69b6",
  "git_url": "https://github.com/OP-TEE/optee_os/commit/34a08bec755670ea0490cb53bbc68058cafc69b6",
  "file_path": "core/tee/tee_svc_cryp.c",
  "func_name": "syscall_hash_init",
  "func_before": "TEE_Result syscall_hash_init(unsigned long state,\n\t\t\t     const void *iv __maybe_unused,\n\t\t\t     size_t iv_len __maybe_unused)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tswitch (TEE_ALG_GET_CLASS(cs->algo)) {\n\tcase TEE_OPERATION_DIGEST:\n\t\tres = crypto_hash_init(cs->ctx, cs->algo);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\t{\n\t\t\tstruct tee_obj *o;\n\t\t\tstruct tee_cryp_obj_secret *key;\n\n\t\t\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  cs->key1, &o);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t\tif ((o->info.handleFlags &\n\t\t\t     TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t\t\tkey = (struct tee_cryp_obj_secret *)o->attr;\n\t\t\tres = crypto_mac_init(cs->ctx, cs->algo,\n\t\t\t\t\t      (void *)(key + 1), key->key_size);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\treturn TEE_SUCCESS;\n}",
  "abstract_func_before": "TEE_Result syscall_hash_init(unsigned long VAR_0,\n\t\t\t     const void *VAR_1 VAR_2,\n\t\t\t     size_t VAR_3 VAR_2)\n{\n\tTEE_Result VAR_4;\n\tstruct tee_cryp_state *VAR_5;\n\tstruct tee_ta_session *VAR_6;\n\n\tVAR_4 = tee_ta_get_current_session(&VAR_6);\n\tif (VAR_4 != VAR_7)\n\t\treturn VAR_4;\n\n\tVAR_4 = tee_svc_cryp_get_state(VAR_6, tee_svc_uref_to_vaddr(VAR_0), &VAR_5);\n\tif (VAR_4 != VAR_7)\n\t\treturn VAR_4;\n\n\tswitch (TEE_ALG_GET_CLASS(VAR_5->algo)) {\n\tcase VAR_8:\n\t\tVAR_4 = crypto_hash_init(VAR_5->ctx, VAR_5->algo);\n\t\tif (VAR_4 != VAR_7)\n\t\t\treturn VAR_4;\n\t\tbreak;\n\tcase VAR_9:\n\t\t{\n\t\t\tstruct tee_obj *VAR_10;\n\t\t\tstruct tee_cryp_obj_secret *VAR_11;\n\n\t\t\tVAR_4 = tee_obj_get(to_user_ta_ctx(VAR_6->ctx),\n\t\t\t\t\t  VAR_5->key1, &VAR_10);\n\t\t\tif (VAR_4 != VAR_7)\n\t\t\t\treturn VAR_4;\n\t\t\tif ((VAR_10->info.handleFlags &\n\t\t\t     VAR_12) == 0)\n\t\t\t\treturn VAR_13;\n\n\t\t\tVAR_11 = (struct tee_cryp_obj_secret *)VAR_10->attr;\n\t\t\tVAR_4 = crypto_mac_init(VAR_5->ctx, VAR_5->algo,\n\t\t\t\t\t      (void *)(VAR_11 + 1), VAR_11->key_size);\n\t\t\tif (VAR_4 != VAR_7)\n\t\t\t\treturn VAR_4;\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\treturn VAR_13;\n\t}\n\n\treturn VAR_7;\n}",
  "func_graph_path_before": null,
  "func": "TEE_Result syscall_hash_init(unsigned long state,\n\t\t\t     const void *iv __maybe_unused,\n\t\t\t     size_t iv_len __maybe_unused)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tswitch (TEE_ALG_GET_CLASS(cs->algo)) {\n\tcase TEE_OPERATION_DIGEST:\n\t\tres = crypto_hash_init(cs->ctx, cs->algo);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\t{\n\t\t\tstruct tee_obj *o;\n\t\t\tstruct tee_cryp_obj_secret *key;\n\n\t\t\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  cs->key1, &o);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t\tif ((o->info.handleFlags &\n\t\t\t     TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t\t\tkey = (struct tee_cryp_obj_secret *)o->attr;\n\t\t\tres = crypto_mac_init(cs->ctx, cs->algo,\n\t\t\t\t\t      (void *)(key + 1), key->key_size);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\tcs->state = CRYP_STATE_INITIALIZED;\n\n\treturn TEE_SUCCESS;\n}",
  "abstract_func": "TEE_Result syscall_hash_init(unsigned long VAR_0,\n\t\t\t     const void *VAR_1 VAR_2,\n\t\t\t     size_t VAR_3 VAR_2)\n{\n\tTEE_Result VAR_4;\n\tstruct tee_cryp_state *VAR_5;\n\tstruct tee_ta_session *VAR_6;\n\n\tVAR_4 = tee_ta_get_current_session(&VAR_6);\n\tif (VAR_4 != VAR_7)\n\t\treturn VAR_4;\n\n\tVAR_4 = tee_svc_cryp_get_state(VAR_6, tee_svc_uref_to_vaddr(VAR_0), &VAR_5);\n\tif (VAR_4 != VAR_7)\n\t\treturn VAR_4;\n\n\tswitch (TEE_ALG_GET_CLASS(VAR_5->algo)) {\n\tcase VAR_8:\n\t\tVAR_4 = crypto_hash_init(VAR_5->ctx, VAR_5->algo);\n\t\tif (VAR_4 != VAR_7)\n\t\t\treturn VAR_4;\n\t\tbreak;\n\tcase VAR_9:\n\t\t{\n\t\t\tstruct tee_obj *VAR_10;\n\t\t\tstruct tee_cryp_obj_secret *VAR_11;\n\n\t\t\tVAR_4 = tee_obj_get(to_user_ta_ctx(VAR_6->ctx),\n\t\t\t\t\t  VAR_5->key1, &VAR_10);\n\t\t\tif (VAR_4 != VAR_7)\n\t\t\t\treturn VAR_4;\n\t\t\tif ((VAR_10->info.handleFlags &\n\t\t\t     VAR_12) == 0)\n\t\t\t\treturn VAR_13;\n\n\t\t\tVAR_11 = (struct tee_cryp_obj_secret *)VAR_10->attr;\n\t\t\tVAR_4 = crypto_mac_init(VAR_5->ctx, VAR_5->algo,\n\t\t\t\t\t      (void *)(VAR_11 + 1), VAR_11->key_size);\n\t\t\tif (VAR_4 != VAR_7)\n\t\t\t\treturn VAR_4;\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\treturn VAR_13;\n\t}\n\n\tVAR_5->state = VAR_14;\n\n\treturn VAR_7;\n}",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -44,5 +44,7 @@\n \t\treturn TEE_ERROR_BAD_PARAMETERS;\n \t}\n \n+\tcs->state = CRYP_STATE_INITIALIZED;\n+\n \treturn TEE_SUCCESS;\n }",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "\tcs->state = CRYP_STATE_INITIALIZED;",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/OP-TEE/optee_os/pull/3316",
  "description": {
    "pr_info": {
      "title": "Riscure fuzzer vuln",
      "number": 3316
    },
    "comment": [
      "Fixes for potential security issues found by Riscure's fuzzer tool.\r\n\r\nI've tested this in QEMU v7, no regressions seen.\r\n```bash\r\n24105 subtests of which 0 failed\r\n96 test cases of which 0 failed\r\n0 test cases were skipped\r\nTEE test application done!\r\n```",
      "Squashed, rebased and tag(s) applied (should be) ready for merge! Thanks!"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "The commit message addresses a security issue by preventing unauthorized calls to critical crypto functions, which could lead to system crashes and information leaks. The code diff shows the necessary state checks were added to core functions. This aligns with a security fix.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}