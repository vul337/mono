{
  "cve_id": "CVE-2022-41882",
  "cwe_ids": [
    "CWE-94"
  ],
  "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "nextcloud/desktop",
  "commit_msg": "edit locally requires a valid token\n\ncheck on server that the token received during a request to open a local\nfile is indeed a valid one\n\nSigned-off-by: Matthieu Gallien <matthieu.gallien@nextcloud.com>",
  "commit_hash": "f9949ee0de1b8a42412f528dc1f64e080eb44316",
  "git_url": "https://github.com/nextcloud/desktop/commit/f9949ee0de1b8a42412f528dc1f64e080eb44316",
  "file_path": "src/gui/folderman.cpp",
  "func_name": "FolderMan::editFileLocally",
  "func_before": "void FolderMan::editFileLocally(const QString &accountDisplayName, const QString &relPath)\n{\n    const auto showError = [this](const OCC::AccountStatePtr accountState, const QString &errorMessage, const QString &subject) {\n        if (accountState && accountState->account()) {\n            const auto foundFolder = std::find_if(std::cbegin(map()), std::cend(map()), [accountState](const auto &folder) {\n                return accountState->account()->davUrl() == folder->remoteUrl();\n            });\n\n            if (foundFolder != std::cend(map())) {\n                (*foundFolder)->syncEngine().addErrorToGui(SyncFileItem::SoftError, errorMessage, subject);\n            }\n        }\n\n        // to make sure the error is not missed, show a message box in addition\n        const auto messageBox = new QMessageBox;\n        messageBox->setAttribute(Qt::WA_DeleteOnClose);\n        messageBox->setText(errorMessage);\n        messageBox->setInformativeText(subject);\n        messageBox->setIcon(QMessageBox::Warning);\n        messageBox->addButton(QMessageBox::StandardButton::Ok);\n        messageBox->show();\n        messageBox->activateWindow();\n        messageBox->raise();\n    };\n\n    const auto accountFound = AccountManager::instance()->account(accountDisplayName);\n\n    if (!accountFound) {\n        qCWarning(lcFolderMan) << \"Could not find an account \" << accountDisplayName << \" to edit file \" << relPath << \" locally.\";\n        showError(accountFound, tr(\"Could not find an account for local editing\"), accountDisplayName);\n        return;\n    }\n\n    const auto foundFiles = findFileInLocalFolders(relPath, accountFound->account());\n\n    if (foundFiles.isEmpty()) {\n        for (const auto &folder : map()) {\n            bool result = false;\n            const auto excludedThroughSelectiveSync = folder->journalDb()->getSelectiveSyncList(SyncJournalDb::SelectiveSyncBlackList, &result);\n            for (const auto &excludedPath : excludedThroughSelectiveSync) {\n                if (relPath.startsWith(excludedPath)) {\n                    showError(accountFound, tr(\"Could not find a file for local editing. Make sure it is not excluded via selective sync.\"), relPath);\n                    return;\n                }\n            }\n        }\n\n        showError(accountFound, tr(\"Could not find a file for local editing. Make sure its path is valid and it is synced locally.\"), relPath);\n        return;\n    }\n\n    const auto localFilePath = foundFiles.first();\n    const auto folderForFile = folderForPath(localFilePath);\n\n    if (!folderForFile) {\n        showError(accountFound, tr(\"Could not find a folder to sync.\"), relPath);\n        return;\n    }\n    \n    const auto relPathSplit = relPath.split(QLatin1Char('/'));\n    if (relPathSplit.size() > 0) {\n        Systray::instance()->createEditFileLocallyLoadingDialog(relPathSplit.last());\n    } else {\n        showError(accountFound, tr(\"Could not find a file for local editing. Make sure its path is valid and it is synced locally.\"), relPath);\n        return;\n    }\n    folderForFile->startSync();\n    _localFileEditingSyncFinishedConnections.insert(localFilePath, QObject::connect(folderForFile, &Folder::syncFinished, this,\n        [this, localFilePath](const OCC::SyncResult &result) {\n        Q_UNUSED(result);\n        const auto foundConnectionIt = _localFileEditingSyncFinishedConnections.find(localFilePath);\n        if (foundConnectionIt != std::end(_localFileEditingSyncFinishedConnections) && foundConnectionIt.value()) {\n            QObject::disconnect(foundConnectionIt.value());\n            _localFileEditingSyncFinishedConnections.erase(foundConnectionIt);\n        }\n        // In case the VFS mode is enabled and a file is not yet hydrated, we must call QDesktopServices::openUrl\n        // from a separate thread, or, there will be a freeze. To avoid searching for a specific folder and checking\n        // if the VFS is enabled - we just always call it from a separate thread.\n        QtConcurrent::run([localFilePath]() {\n            QDesktopServices::openUrl(QUrl::fromLocalFile(localFilePath));\n            Systray::instance()->destroyEditFileLocallyLoadingDialog();\n        });\n    }));\n}",
  "abstract_func_before": "void FolderMan::editFileLocally(const QString &VAR_0, const QString &VAR_1)\n{\n    const auto VAR_2 = [this](const OCC::AccountStatePtr VAR_3, const QString &VAR_4, const QString &VAR_5) {\n        if (VAR_3 && VAR_3->account()) {\n            const auto VAR_6 = std::find_if(std::cbegin(map()), std::cend(map()), [VAR_3](const auto &VAR_7) {\n                return VAR_3->account()->davUrl() == VAR_7->remoteUrl();\n            });\n\n            if (VAR_6 != std::cend(map())) {\n                (*VAR_6)->syncEngine().addErrorToGui(SyncFileItem::SoftError, VAR_4, VAR_5);\n            }\n        }\n\n        /* COMMENT_0 */\n        const auto VAR_8 = new QMessageBox;\n        VAR_8->setAttribute(Qt::WA_DeleteOnClose);\n        VAR_8->setText(VAR_4);\n        VAR_8->setInformativeText(VAR_5);\n        VAR_8->setIcon(QMessageBox::Warning);\n        VAR_8->addButton(QMessageBox::StandardButton::Ok);\n        VAR_8->show();\n        VAR_8->activateWindow();\n        VAR_8->raise();\n    };\n\n    const auto VAR_9 = AccountManager::instance()->account(VAR_0);\n\n    if (!VAR_9) {\n        qCWarning(VAR_10) << \"Could not find an account \" << VAR_0 << \" to edit file \" << VAR_1 << \" locally.\";\n        VAR_2(VAR_9, tr(\"Could not find an account for local editing\"), VAR_0);\n        return;\n    }\n\n    const auto VAR_11 = findFileInLocalFolders(VAR_1, VAR_9->account());\n\n    if (VAR_11.isEmpty()) {\n        for (const auto &VAR_7 : map()) {\n            bool VAR_12 = false;\n            const auto VAR_13 = VAR_7->journalDb()->getSelectiveSyncList(SyncJournalDb::SelectiveSyncBlackList, &VAR_12);\n            for (const auto &VAR_14 : VAR_13) {\n                if (VAR_1.startsWith(VAR_14)) {\n                    VAR_2(VAR_9, tr(\"Could not find a file for local editing. Make sure it is not excluded via selective sync.\"), VAR_1);\n                    return;\n                }\n            }\n        }\n\n        VAR_2(VAR_9, tr(\"Could not find a file for local editing. Make sure its path is valid and it is synced locally.\"), VAR_1);\n        return;\n    }\n\n    const auto VAR_15 = VAR_11.first();\n    const auto VAR_16 = folderForPath(VAR_15);\n\n    if (!VAR_16) {\n        VAR_2(VAR_9, tr(\"Could not find a folder to sync.\"), VAR_1);\n        return;\n    }\n    \n    const auto VAR_17 = VAR_1.split(QLatin1Char('/'));\n    if (VAR_17.size() > 0) {\n        Systray::instance()->createEditFileLocallyLoadingDialog(VAR_17.last());\n    } else {\n        VAR_2(VAR_9, tr(\"Could not find a file for local editing. Make sure its path is valid and it is synced locally.\"), VAR_1);\n        return;\n    }\n    VAR_16->startSync();\n    VAR_18.insert(VAR_15, QObject::connect(VAR_16, &Folder::syncFinished, this,\n        [this, VAR_15](const OCC::SyncResult &VAR_12) {\n        Q_UNUSED(VAR_12);\n        const auto VAR_19 = VAR_18.find(VAR_15);\n        if (VAR_19 != std::end(VAR_18) && VAR_19.value()) {\n            QObject::disconnect(VAR_19.value());\n            VAR_18.erase(VAR_19);\n        }\n        /* COMMENT_1 */\n        /* COMMENT_2 */\n        /* COMMENT_3 */\n        QtConcurrent::run([VAR_15]() {\n            QDesktopServices::openUrl(QUrl::fromLocalFile(VAR_15));\n            Systray::instance()->destroyEditFileLocallyLoadingDialog();\n        });\n    }));\n}",
  "func_graph_path_before": "nextcloud/desktop/f9949ee0de1b8a42412f528dc1f64e080eb44316/folderman.cpp/vul/before/0.json",
  "func": "void FolderMan::editFileLocally(const QString &accountDisplayName, const QString &relPath, const QString &token)\n{\n    const auto showError = [this](const OCC::AccountStatePtr accountState, const QString &errorMessage, const QString &subject) {\n        if (accountState && accountState->account()) {\n            const auto foundFolder = std::find_if(std::cbegin(map()), std::cend(map()), [accountState](const auto &folder) {\n                return accountState->account()->davUrl() == folder->remoteUrl();\n            });\n\n            if (foundFolder != std::cend(map())) {\n                (*foundFolder)->syncEngine().addErrorToGui(SyncFileItem::SoftError, errorMessage, subject);\n            }\n        }\n\n        // to make sure the error is not missed, show a message box in addition\n        const auto messageBox = new QMessageBox;\n        messageBox->setAttribute(Qt::WA_DeleteOnClose);\n        messageBox->setText(errorMessage);\n        messageBox->setInformativeText(subject);\n        messageBox->setIcon(QMessageBox::Warning);\n        messageBox->addButton(QMessageBox::StandardButton::Ok);\n        messageBox->show();\n        messageBox->activateWindow();\n        messageBox->raise();\n    };\n\n    if (token.isEmpty()) {\n        qCWarning(lcFolderMan) << \"Edit locally request is missing a valid token. Impossible to open the file.\";\n        showError({}, tr(\"Edit locally request is not valid. Opening the file is forbidden.\"), accountDisplayName);\n        return;\n    }\n\n    const auto accountFound = AccountManager::instance()->account(accountDisplayName);\n\n    if (!accountFound) {\n        qCWarning(lcFolderMan) << \"Could not find an account \" << accountDisplayName << \" to edit file \" << relPath << \" locally.\";\n        showError(accountFound, tr(\"Could not find an account for local editing\"), accountDisplayName);\n        return;\n    }\n\n    const auto foundFiles = findFileInLocalFolders(relPath, accountFound->account());\n\n    if (foundFiles.isEmpty()) {\n        for (const auto &folder : map()) {\n            bool result = false;\n            const auto excludedThroughSelectiveSync = folder->journalDb()->getSelectiveSyncList(SyncJournalDb::SelectiveSyncBlackList, &result);\n            for (const auto &excludedPath : excludedThroughSelectiveSync) {\n                if (relPath.startsWith(excludedPath)) {\n                    showError(accountFound, tr(\"Could not find a file for local editing. Make sure it is not excluded via selective sync.\"), relPath);\n                    return;\n                }\n            }\n        }\n\n        showError(accountFound, tr(\"Could not find a file for local editing. Make sure its path is valid and it is synced locally.\"), relPath);\n        return;\n    }\n\n    const auto localFilePath = foundFiles.first();\n    const auto folderForFile = folderForPath(localFilePath);\n\n    if (!folderForFile) {\n        showError(accountFound, tr(\"Could not find a folder to sync.\"), relPath);\n        return;\n    }\n    \n    const auto relPathSplit = relPath.split(QLatin1Char('/'));\n    if (relPathSplit.size() > 0) {\n        Systray::instance()->createEditFileLocallyLoadingDialog(relPathSplit.last());\n    } else {\n        showError(accountFound, tr(\"Could not find a file for local editing. Make sure its path is valid and it is synced locally.\"), relPath);\n        return;\n    }\n\n    const auto checkTokenForEditLocally = new SimpleApiJob(accountFound->account(), QStringLiteral(\"/ocs/v2.php/apps/files/api/v1/openlocaleditor/%1\").arg(token));\n    checkTokenForEditLocally->setVerb(SimpleApiJob::Verb::Post);\n    checkTokenForEditLocally->setBody(QByteArray{\"path=/\"}.append(relPath.toUtf8()));\n    connect(checkTokenForEditLocally, &SimpleApiJob::resultReceived, checkTokenForEditLocally, [this, folderForFile, localFilePath, showError, accountFound, relPath] (int statusCode) {\n        constexpr auto HTTP_OK_CODE = 200;\n        if (statusCode != HTTP_OK_CODE) {\n            Systray::instance()->destroyEditFileLocallyLoadingDialog();\n            showError(accountFound, tr(\"Could not validate the request to open a file from server.\"), relPath);\n            qCInfo(lcFolderMan()) << \"token check result\" << statusCode;\n            return;\n        }\n\n        folderForFile->startSync();\n        _localFileEditingSyncFinishedConnections.insert(localFilePath, QObject::connect(folderForFile, &Folder::syncFinished, this,\n                                                                                        [this, localFilePath](const OCC::SyncResult &result) {\n                                                                                            Q_UNUSED(result);\n                                                                                            const auto foundConnectionIt = _localFileEditingSyncFinishedConnections.find(localFilePath);\n                                                                                            if (foundConnectionIt != std::end(_localFileEditingSyncFinishedConnections) && foundConnectionIt.value()) {\n                                                                                                QObject::disconnect(foundConnectionIt.value());\n                                                                                                _localFileEditingSyncFinishedConnections.erase(foundConnectionIt);\n                                                                                            }\n                                                                                            // In case the VFS mode is enabled and a file is not yet hydrated, we must call QDesktopServices::openUrl\n                                                                                            // from a separate thread, or, there will be a freeze. To avoid searching for a specific folder and checking\n                                                                                            // if the VFS is enabled - we just always call it from a separate thread.\n                                                                                            QtConcurrent::run([localFilePath]() {\n                                                                                                QDesktopServices::openUrl(QUrl::fromLocalFile(localFilePath));\n                                                                                                Systray::instance()->destroyEditFileLocallyLoadingDialog();\n                                                                                            });\n                                                                                        }));\n    });\n    checkTokenForEditLocally->start();\n}",
  "abstract_func": "void FolderMan::editFileLocally(const QString &VAR_0, const QString &VAR_1, const QString &VAR_2)\n{\n    const auto VAR_3 = [this](const OCC::AccountStatePtr VAR_4, const QString &VAR_5, const QString &VAR_6) {\n        if (VAR_4 && VAR_4->account()) {\n            const auto VAR_7 = std::find_if(std::cbegin(map()), std::cend(map()), [VAR_4](const auto &VAR_8) {\n                return VAR_4->account()->davUrl() == VAR_8->remoteUrl();\n            });\n\n            if (VAR_7 != std::cend(map())) {\n                (*VAR_7)->syncEngine().addErrorToGui(SyncFileItem::SoftError, VAR_5, VAR_6);\n            }\n        }\n\n        /* COMMENT_0 */\n        const auto VAR_9 = new QMessageBox;\n        VAR_9->setAttribute(Qt::WA_DeleteOnClose);\n        VAR_9->setText(VAR_5);\n        VAR_9->setInformativeText(VAR_6);\n        VAR_9->setIcon(QMessageBox::Warning);\n        VAR_9->addButton(QMessageBox::StandardButton::Ok);\n        VAR_9->show();\n        VAR_9->activateWindow();\n        VAR_9->raise();\n    };\n\n    if (VAR_2.isEmpty()) {\n        qCWarning(VAR_10) << \"Edit locally request is missing a valid token. Impossible to open the file.\";\n        VAR_3({}, tr(\"Edit locally request is not valid. Opening the file is forbidden.\"), VAR_0);\n        return;\n    }\n\n    const auto VAR_11 = AccountManager::instance()->account(VAR_0);\n\n    if (!VAR_11) {\n        qCWarning(VAR_10) << \"Could not find an account \" << VAR_0 << \" to edit file \" << VAR_1 << \" locally.\";\n        VAR_3(VAR_11, tr(\"Could not find an account for local editing\"), VAR_0);\n        return;\n    }\n\n    const auto VAR_12 = findFileInLocalFolders(VAR_1, VAR_11->account());\n\n    if (VAR_12.isEmpty()) {\n        for (const auto &VAR_8 : map()) {\n            bool VAR_13 = false;\n            const auto VAR_14 = VAR_8->journalDb()->getSelectiveSyncList(SyncJournalDb::SelectiveSyncBlackList, &VAR_13);\n            for (const auto &VAR_15 : VAR_14) {\n                if (VAR_1.startsWith(VAR_15)) {\n                    VAR_3(VAR_11, tr(\"Could not find a file for local editing. Make sure it is not excluded via selective sync.\"), VAR_1);\n                    return;\n                }\n            }\n        }\n\n        VAR_3(VAR_11, tr(\"Could not find a file for local editing. Make sure its path is valid and it is synced locally.\"), VAR_1);\n        return;\n    }\n\n    const auto VAR_16 = VAR_12.first();\n    const auto VAR_17 = folderForPath(VAR_16);\n\n    if (!VAR_17) {\n        VAR_3(VAR_11, tr(\"Could not find a folder to sync.\"), VAR_1);\n        return;\n    }\n    \n    const auto VAR_18 = VAR_1.split(QLatin1Char('/'));\n    if (VAR_18.size() > 0) {\n        Systray::instance()->createEditFileLocallyLoadingDialog(VAR_18.last());\n    } else {\n        VAR_3(VAR_11, tr(\"Could not find a file for local editing. Make sure its path is valid and it is synced locally.\"), VAR_1);\n        return;\n    }\n\n    const auto VAR_19 = new SimpleApiJob(VAR_11->account(), QStringLiteral(\"/ocs/v2.php/apps/files/api/v1/openlocaleditor/%1\").arg(VAR_2));\n    VAR_19->setVerb(SimpleApiJob::Verb::Post);\n    VAR_19->setBody(QByteArray{\"path=/\"}.append(VAR_1.toUtf8()));\n    connect(VAR_19, &SimpleApiJob::resultReceived, VAR_19, [this, VAR_17, VAR_16, VAR_3, VAR_11, VAR_1] (int VAR_20) {\n        constexpr auto VAR_21 = 200;\n        if (VAR_20 != VAR_21) {\n            Systray::instance()->destroyEditFileLocallyLoadingDialog();\n            VAR_3(VAR_11, tr(\"Could not validate the request to open a file from server.\"), VAR_1);\n            qCInfo(VAR_10()) << \"token check result\" << VAR_20;\n            return;\n        }\n\n        VAR_17->startSync();\n        VAR_22.insert(VAR_16, QObject::connect(VAR_17, &Folder::syncFinished, this,\n                                                                                        [this, VAR_16](const OCC::SyncResult &VAR_13) {\n                                                                                            Q_UNUSED(VAR_13);\n                                                                                            const auto VAR_23 = VAR_22.find(VAR_16);\n                                                                                            if (VAR_23 != std::end(VAR_22) && VAR_23.value()) {\n                                                                                                QObject::disconnect(VAR_23.value());\n                                                                                                VAR_22.erase(VAR_23);\n                                                                                            }\n                                                                                            /* COMMENT_1 */\n                                                                                            /* COMMENT_2 */\n                                                                                            /* COMMENT_3 */\n                                                                                            QtConcurrent::run([VAR_16]() {\n                                                                                                QDesktopServices::openUrl(QUrl::fromLocalFile(VAR_16));\n                                                                                                Systray::instance()->destroyEditFileLocallyLoadingDialog();\n                                                                                            });\n                                                                                        }));\n    });\n    VAR_19->start();\n}",
  "func_graph_path": "nextcloud/desktop/f9949ee0de1b8a42412f528dc1f64e080eb44316/folderman.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-void FolderMan::editFileLocally(const QString &accountDisplayName, const QString &relPath)\n+void FolderMan::editFileLocally(const QString &accountDisplayName, const QString &relPath, const QString &token)\n {\n     const auto showError = [this](const OCC::AccountStatePtr accountState, const QString &errorMessage, const QString &subject) {\n         if (accountState && accountState->account()) {\n@@ -22,6 +22,12 @@\n         messageBox->activateWindow();\n         messageBox->raise();\n     };\n+\n+    if (token.isEmpty()) {\n+        qCWarning(lcFolderMan) << \"Edit locally request is missing a valid token. Impossible to open the file.\";\n+        showError({}, tr(\"Edit locally request is not valid. Opening the file is forbidden.\"), accountDisplayName);\n+        return;\n+    }\n \n     const auto accountFound = AccountManager::instance()->account(accountDisplayName);\n \n@@ -64,21 +70,36 @@\n         showError(accountFound, tr(\"Could not find a file for local editing. Make sure its path is valid and it is synced locally.\"), relPath);\n         return;\n     }\n-    folderForFile->startSync();\n-    _localFileEditingSyncFinishedConnections.insert(localFilePath, QObject::connect(folderForFile, &Folder::syncFinished, this,\n-        [this, localFilePath](const OCC::SyncResult &result) {\n-        Q_UNUSED(result);\n-        const auto foundConnectionIt = _localFileEditingSyncFinishedConnections.find(localFilePath);\n-        if (foundConnectionIt != std::end(_localFileEditingSyncFinishedConnections) && foundConnectionIt.value()) {\n-            QObject::disconnect(foundConnectionIt.value());\n-            _localFileEditingSyncFinishedConnections.erase(foundConnectionIt);\n+\n+    const auto checkTokenForEditLocally = new SimpleApiJob(accountFound->account(), QStringLiteral(\"/ocs/v2.php/apps/files/api/v1/openlocaleditor/%1\").arg(token));\n+    checkTokenForEditLocally->setVerb(SimpleApiJob::Verb::Post);\n+    checkTokenForEditLocally->setBody(QByteArray{\"path=/\"}.append(relPath.toUtf8()));\n+    connect(checkTokenForEditLocally, &SimpleApiJob::resultReceived, checkTokenForEditLocally, [this, folderForFile, localFilePath, showError, accountFound, relPath] (int statusCode) {\n+        constexpr auto HTTP_OK_CODE = 200;\n+        if (statusCode != HTTP_OK_CODE) {\n+            Systray::instance()->destroyEditFileLocallyLoadingDialog();\n+            showError(accountFound, tr(\"Could not validate the request to open a file from server.\"), relPath);\n+            qCInfo(lcFolderMan()) << \"token check result\" << statusCode;\n+            return;\n         }\n-        // In case the VFS mode is enabled and a file is not yet hydrated, we must call QDesktopServices::openUrl\n-        // from a separate thread, or, there will be a freeze. To avoid searching for a specific folder and checking\n-        // if the VFS is enabled - we just always call it from a separate thread.\n-        QtConcurrent::run([localFilePath]() {\n-            QDesktopServices::openUrl(QUrl::fromLocalFile(localFilePath));\n-            Systray::instance()->destroyEditFileLocallyLoadingDialog();\n-        });\n-    }));\n+\n+        folderForFile->startSync();\n+        _localFileEditingSyncFinishedConnections.insert(localFilePath, QObject::connect(folderForFile, &Folder::syncFinished, this,\n+                                                                                        [this, localFilePath](const OCC::SyncResult &result) {\n+                                                                                            Q_UNUSED(result);\n+                                                                                            const auto foundConnectionIt = _localFileEditingSyncFinishedConnections.find(localFilePath);\n+                                                                                            if (foundConnectionIt != std::end(_localFileEditingSyncFinishedConnections) && foundConnectionIt.value()) {\n+                                                                                                QObject::disconnect(foundConnectionIt.value());\n+                                                                                                _localFileEditingSyncFinishedConnections.erase(foundConnectionIt);\n+                                                                                            }\n+                                                                                            // In case the VFS mode is enabled and a file is not yet hydrated, we must call QDesktopServices::openUrl\n+                                                                                            // from a separate thread, or, there will be a freeze. To avoid searching for a specific folder and checking\n+                                                                                            // if the VFS is enabled - we just always call it from a separate thread.\n+                                                                                            QtConcurrent::run([localFilePath]() {\n+                                                                                                QDesktopServices::openUrl(QUrl::fromLocalFile(localFilePath));\n+                                                                                                Systray::instance()->destroyEditFileLocallyLoadingDialog();\n+                                                                                            });\n+                                                                                        }));\n+    });\n+    checkTokenForEditLocally->start();\n }",
  "diff_line_info": {
    "deleted_lines": [
      "void FolderMan::editFileLocally(const QString &accountDisplayName, const QString &relPath)",
      "    folderForFile->startSync();",
      "    _localFileEditingSyncFinishedConnections.insert(localFilePath, QObject::connect(folderForFile, &Folder::syncFinished, this,",
      "        [this, localFilePath](const OCC::SyncResult &result) {",
      "        Q_UNUSED(result);",
      "        const auto foundConnectionIt = _localFileEditingSyncFinishedConnections.find(localFilePath);",
      "        if (foundConnectionIt != std::end(_localFileEditingSyncFinishedConnections) && foundConnectionIt.value()) {",
      "            QObject::disconnect(foundConnectionIt.value());",
      "            _localFileEditingSyncFinishedConnections.erase(foundConnectionIt);",
      "        // In case the VFS mode is enabled and a file is not yet hydrated, we must call QDesktopServices::openUrl",
      "        // from a separate thread, or, there will be a freeze. To avoid searching for a specific folder and checking",
      "        // if the VFS is enabled - we just always call it from a separate thread.",
      "        QtConcurrent::run([localFilePath]() {",
      "            QDesktopServices::openUrl(QUrl::fromLocalFile(localFilePath));",
      "            Systray::instance()->destroyEditFileLocallyLoadingDialog();",
      "        });",
      "    }));"
    ],
    "added_lines": [
      "void FolderMan::editFileLocally(const QString &accountDisplayName, const QString &relPath, const QString &token)",
      "",
      "    if (token.isEmpty()) {",
      "        qCWarning(lcFolderMan) << \"Edit locally request is missing a valid token. Impossible to open the file.\";",
      "        showError({}, tr(\"Edit locally request is not valid. Opening the file is forbidden.\"), accountDisplayName);",
      "        return;",
      "    }",
      "",
      "    const auto checkTokenForEditLocally = new SimpleApiJob(accountFound->account(), QStringLiteral(\"/ocs/v2.php/apps/files/api/v1/openlocaleditor/%1\").arg(token));",
      "    checkTokenForEditLocally->setVerb(SimpleApiJob::Verb::Post);",
      "    checkTokenForEditLocally->setBody(QByteArray{\"path=/\"}.append(relPath.toUtf8()));",
      "    connect(checkTokenForEditLocally, &SimpleApiJob::resultReceived, checkTokenForEditLocally, [this, folderForFile, localFilePath, showError, accountFound, relPath] (int statusCode) {",
      "        constexpr auto HTTP_OK_CODE = 200;",
      "        if (statusCode != HTTP_OK_CODE) {",
      "            Systray::instance()->destroyEditFileLocallyLoadingDialog();",
      "            showError(accountFound, tr(\"Could not validate the request to open a file from server.\"), relPath);",
      "            qCInfo(lcFolderMan()) << \"token check result\" << statusCode;",
      "            return;",
      "",
      "        folderForFile->startSync();",
      "        _localFileEditingSyncFinishedConnections.insert(localFilePath, QObject::connect(folderForFile, &Folder::syncFinished, this,",
      "                                                                                        [this, localFilePath](const OCC::SyncResult &result) {",
      "                                                                                            Q_UNUSED(result);",
      "                                                                                            const auto foundConnectionIt = _localFileEditingSyncFinishedConnections.find(localFilePath);",
      "                                                                                            if (foundConnectionIt != std::end(_localFileEditingSyncFinishedConnections) && foundConnectionIt.value()) {",
      "                                                                                                QObject::disconnect(foundConnectionIt.value());",
      "                                                                                                _localFileEditingSyncFinishedConnections.erase(foundConnectionIt);",
      "                                                                                            }",
      "                                                                                            // In case the VFS mode is enabled and a file is not yet hydrated, we must call QDesktopServices::openUrl",
      "                                                                                            // from a separate thread, or, there will be a freeze. To avoid searching for a specific folder and checking",
      "                                                                                            // if the VFS is enabled - we just always call it from a separate thread.",
      "                                                                                            QtConcurrent::run([localFilePath]() {",
      "                                                                                                QDesktopServices::openUrl(QUrl::fromLocalFile(localFilePath));",
      "                                                                                                Systray::instance()->destroyEditFileLocallyLoadingDialog();",
      "                                                                                            });",
      "                                                                                        }));",
      "    });",
      "    checkTokenForEditLocally->start();"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/nextcloud/desktop/pull/5039",
  "description": {
    "pr_info": {
      "title": "Bugfix/check token for edit locally requests",
      "number": 5039
    },
    "comment": [
      "<!-- \r\nThanks for opening a pull request on the Nextcloud desktop client.\r\n\r\nInstead of a Contributor License Agreement (CLA) we use a Developer Certificate of Origin (DCO).\r\nhttps://en.wikipedia.org/wiki/Developer_Certificate_of_Origin\r\n\r\nTo accept that DCO, please make sure that you add a line like\r\nSigned-off-by: Random Developer <random@developer.example.org>\r\nat the end of each commit message.\r\n\r\nThis Signed-off-by trailer can be added automatically by git if you pass --signoff or -s to git commit.\r\nSee also:\r\nhttps://git-scm.com/docs/git-commit#Documentation/git-commit.txt---no-signoff\r\n-->\r\n",
      "@mgallien Please do not forget clean-up the history",
      "AppImage file: [nextcloud-PR-5039-f9949ee0de1b8a42412f528dc1f64e080eb44316-x86_64.AppImage](https://github.com/nextcloud-desktop-bot/ci-builds/releases/download/PR-5039/nextcloud-PR-5039-f9949ee0de1b8a42412f528dc1f64e080eb44316-x86_64.AppImage) <br/><br/>To test this change/fix you can simply download above AppImage file and test it. <br/><br/>Please make sure to quit your existing Nextcloud app and backup your data. ",
      "SonarCloud Quality Gate failed.&nbsp; &nbsp; [![Quality Gate failed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/failed-16px.png 'Quality Gate failed')](https://sonarcloud.io/dashboard?id=nextcloud_desktop&pullRequest=5039)\n\n[![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=nextcloud_desktop&pullRequest=5039&resolved=false&types=BUG) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=nextcloud_desktop&pullRequest=5039&resolved=false&types=BUG) [0 Bugs](https://sonarcloud.io/project/issues?id=nextcloud_desktop&pullRequest=5039&resolved=false&types=BUG)  \n[![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=nextcloud_desktop&pullRequest=5039&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=nextcloud_desktop&pullRequest=5039&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=nextcloud_desktop&pullRequest=5039&resolved=false&types=VULNERABILITY)  \n[![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=nextcloud_desktop&pullRequest=5039&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=nextcloud_desktop&pullRequest=5039&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=nextcloud_desktop&pullRequest=5039&resolved=false&types=SECURITY_HOTSPOT)  \n[![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=nextcloud_desktop&pullRequest=5039&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=nextcloud_desktop&pullRequest=5039&resolved=false&types=CODE_SMELL) [9 Code Smells](https://sonarcloud.io/project/issues?id=nextcloud_desktop&pullRequest=5039&resolved=false&types=CODE_SMELL)\n\n[![46.2%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/40-16px.png '46.2%')](https://sonarcloud.io/component_measures?id=nextcloud_desktop&pullRequest=5039&metric=new_coverage&view=list) [46.2% Coverage](https://sonarcloud.io/component_measures?id=nextcloud_desktop&pullRequest=5039&metric=new_coverage&view=list)  \n[![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=nextcloud_desktop&pullRequest=5039&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=nextcloud_desktop&pullRequest=5039&metric=new_duplicated_lines_density&view=list)\n\n",
      "# [Codecov](https://codecov.io/gh/nextcloud/desktop/pull/5039?src=pr&el=h1&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=nextcloud) Report\n> Merging [#5039](https://codecov.io/gh/nextcloud/desktop/pull/5039?src=pr&el=desc&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=nextcloud) (f9949ee) into [master](https://codecov.io/gh/nextcloud/desktop/commit/bde2f90de914e43bbb72a2103828112468326af9?el=desc&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=nextcloud) (bde2f90) will **increase** coverage by `0.03%`.\n> The diff coverage is `64.91%`.\n\n<details><summary>Additional details and impacted files</summary>\n\n\n```diff\n@@            Coverage Diff             @@\n##           master    #5039      +/-   ##\n==========================================\n+ Coverage   57.34%   57.37%   +0.03%     \n==========================================\n  Files         138      138              \n  Lines       17391    17418      +27     \n==========================================\n+ Hits         9972     9993      +21     \n- Misses       7419     7425       +6     \n```\n\n\n\n| [Impacted Files](https://codecov.io/gh/nextcloud/desktop/pull/5039?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=nextcloud) | Coverage Δ | |\n|---|---|---|\n| [src/libsync/networkjobs.h](https://codecov.io/gh/nextcloud/desktop/pull/5039/diff?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=nextcloud#diff-c3JjL2xpYnN5bmMvbmV0d29ya2pvYnMuaA==) | `4.76% <50.00%> (-0.24%)` | :arrow_down: |\n| [src/libsync/networkjobs.cpp](https://codecov.io/gh/nextcloud/desktop/pull/5039/diff?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=nextcloud#diff-c3JjL2xpYnN5bmMvbmV0d29ya2pvYnMuY3Bw) | `50.28% <65.45%> (+0.28%)` | :arrow_up: |\n| [src/libsync/discovery.cpp](https://codecov.io/gh/nextcloud/desktop/pull/5039/diff?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=nextcloud#diff-c3JjL2xpYnN5bmMvZGlzY292ZXJ5LmNwcA==) | `84.05% <0.00%> (+0.28%)` | :arrow_up: |\n| [src/libsync/propagateremotemkdir.cpp](https://codecov.io/gh/nextcloud/desktop/pull/5039/diff?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=nextcloud#diff-c3JjL2xpYnN5bmMvcHJvcGFnYXRlcmVtb3RlbWtkaXIuY3Bw) | `65.73% <0.00%> (+0.69%)` | :arrow_up: |\n| [src/libsync/propagatorjobs.cpp](https://codecov.io/gh/nextcloud/desktop/pull/5039/diff?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=nextcloud#diff-c3JjL2xpYnN5bmMvcHJvcGFnYXRvcmpvYnMuY3Bw) | `73.23% <0.00%> (+1.40%)` | :arrow_up: |\n\n</details>",
      "/backport to stable-3.6"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}