{
  "cve_id": "CVE-2021-20302",
  "cwe_ids": [
    "CWE-20"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:C",
  "cvss_is_v3": false,
  "repo_name": "AcademySoftwareFoundation/openexr",
  "commit_msg": "add exrcheck binary and function in IlmImfUtil\n\nSigned-off-by: Peter Hillman <peterh@wetafx.co.nz>",
  "commit_hash": "f044caeed5c0f1566d804f37cbddb2d5ccfd75ea",
  "git_url": "https://github.com/AcademySoftwareFoundation/openexr/commit/f044caeed5c0f1566d804f37cbddb2d5ccfd75ea",
  "file_path": "OpenEXR/IlmImf/ImfDeepScanLineInputFile.cpp",
  "func_name": "LineBufferTask::execute",
  "func_before": "void\nLineBufferTask::execute ()\n{\n    try\n    {\n        //\n        // Uncompress the data, if necessary\n        //\n\n        if (_lineBuffer->uncompressedData == 0)\n        {\n            Int64 uncompressedSize = 0;\n            int maxY = min (_lineBuffer->maxY, _ifd->maxY);\n\n            for (int i = _lineBuffer->minY - _ifd->minY;\n                 i <= maxY - _ifd->minY;\n                 ++i)\n            {\n                uncompressedSize += (int) _ifd->bytesPerLine[i];\n            }\n\n            //\n            // Create the compressor everytime when we want to use it,\n            // because we don't know maxBytesPerLine beforehand.\n            // (TODO) optimize this. don't do this every time.\n            //\n\n            if (_lineBuffer->compressor != 0)\n                delete _lineBuffer->compressor;\n            Int64 maxBytesPerLine = 0;\n            for (int i = _lineBuffer->minY - _ifd->minY;\n                 i <= maxY - _ifd->minY;\n                 ++i)\n            {\n                if (_ifd->bytesPerLine[i] > maxBytesPerLine)\n                    maxBytesPerLine = _ifd->bytesPerLine[i];\n            }\n            _lineBuffer->compressor = newCompressor(_ifd->header.compression(),\n                                                    maxBytesPerLine,\n                                                    _ifd->header);\n\n            if (_lineBuffer->compressor &&\n                _lineBuffer->packedDataSize < uncompressedSize)\n            {\n                _lineBuffer->format = _lineBuffer->compressor->format();\n\n                _lineBuffer->packedDataSize = _lineBuffer->compressor->uncompress\n                    (_lineBuffer->buffer, _lineBuffer->packedDataSize,\n                     _lineBuffer->minY, _lineBuffer->uncompressedData);\n            }\n            else\n            {\n                //\n                // If the line is uncompressed, it's in XDR format,\n                // regardless of the compressor's output format.\n                //\n\n                _lineBuffer->format = Compressor::XDR;\n                _lineBuffer->uncompressedData = _lineBuffer->buffer;\n            }\n        }\n\n        int yStart, yStop, dy;\n\n        if (_ifd->lineOrder == INCREASING_Y)\n        {\n            yStart = _scanLineMin;\n            yStop = _scanLineMax + 1;\n            dy = 1;\n        }\n        else\n        {\n            yStart = _scanLineMax;\n            yStop = _scanLineMin - 1;\n            dy = -1;\n        }\n\n        for (int y = yStart; y != yStop; y += dy)\n        {\n            //\n            // Convert one scan line's worth of pixel data back\n            // from the machine-independent representation, and\n            // store the result in the frame buffer.\n            //\n\n            const char *readPtr = _lineBuffer->uncompressedData +\n                                  _ifd->offsetInLineBuffer[y - _ifd->minY];\n\n            //\n            // Iterate over all image channels.\n            //\n\n            for (unsigned int i = 0; i < _ifd->slices.size(); ++i)\n            {\n                //\n                // Test if scan line y of this channel contains any data\n                // (the scan line contains data only if y % ySampling == 0).\n                //\n\n                InSliceInfo &slice = *_ifd->slices[i];\n\n                if (modp (y, slice.ySampling) != 0)\n                    continue;\n\n                //\n                // Find the x coordinates of the leftmost and rightmost\n                // sampled pixels (i.e. pixels within the data window\n                // for which x % xSampling == 0).\n                //\n\n                //\n                // Fill the frame buffer with pixel data.\n                //\n\n                if (slice.skip)\n                {\n                    //\n                    // The file contains data for this channel, but\n                    // the frame buffer contains no slice for this channel.\n                    //\n\n                    skipChannel (readPtr, slice.typeInFile,\n                                 _ifd->lineSampleCount[y - _ifd->minY]);\n                }\n                else\n                {\n                    //\n                    // The frame buffer contains a slice for this channel.\n                    //\n\n                    int width = (_ifd->maxX - _ifd->minX + 1);\n\n                    copyIntoDeepFrameBuffer (readPtr, slice.base,\n                                             (char*) (&_ifd->sampleCount[0][0]\n                                                      - _ifd->minX\n                                                      - _ifd->minY * width),\n                                             sizeof(unsigned int) * 1,\n                                             sizeof(unsigned int) * width,\n                                             y, _ifd->minX, _ifd->maxX,\n                                             0, 0,\n                                             0, 0,\n                                             slice.sampleStride, \n                                             slice.xPointerStride,\n                                             slice.yPointerStride,\n                                             slice.fill,\n                                             slice.fillValue, _lineBuffer->format,\n                                             slice.typeInFrameBuffer,\n                                             slice.typeInFile);\n                }\n            }\n        }\n    }\n    catch (std::exception &e)\n    {\n        if (!_lineBuffer->hasException)\n        {\n            _lineBuffer->exception = e.what();\n            _lineBuffer->hasException = true;\n        }\n    }\n    catch (...)\n    {\n        if (!_lineBuffer->hasException)\n        {\n            _lineBuffer->exception = \"unrecognized exception\";\n            _lineBuffer->hasException = true;\n        }\n    }\n}",
  "abstract_func_before": "void\nLineBufferTask::execute ()\n{\n    try\n    {\n        /* COMMENT_0 */\n        /* COMMENT_1 */\n        /* COMMENT_0 */\n\n        if (VAR_0->uncompressedData == 0)\n        {\n            Int64 VAR_1 = 0;\n            int VAR_2 = min (VAR_0->maxY, VAR_3->maxY);\n\n            for (int VAR_4 = VAR_0->minY - VAR_3->minY;\n                 VAR_4 <= VAR_2 - VAR_3->minY;\n                 ++VAR_4)\n            {\n                VAR_1 += (int) VAR_3->bytesPerLine[VAR_4];\n            }\n\n            /* COMMENT_0 */\n            /* COMMENT_2 */\n            /* COMMENT_3 */\n            /* COMMENT_4 */\n            /* COMMENT_0 */\n\n            if (VAR_0->compressor != 0)\n                delete VAR_0->compressor;\n            Int64 VAR_5 = 0;\n            for (int VAR_4 = VAR_0->minY - VAR_3->minY;\n                 VAR_4 <= VAR_2 - VAR_3->minY;\n                 ++VAR_4)\n            {\n                if (VAR_3->bytesPerLine[VAR_4] > VAR_5)\n                    VAR_5 = VAR_3->bytesPerLine[VAR_4];\n            }\n            VAR_0->compressor = newCompressor(VAR_3->header.compression(),\n                                                    VAR_5,\n                                                    VAR_3->header);\n\n            if (VAR_0->compressor &&\n                VAR_0->packedDataSize < VAR_1)\n            {\n                VAR_0->format = VAR_0->compressor->format();\n\n                VAR_0->packedDataSize = VAR_0->compressor->uncompress\n                    (VAR_0->buffer, VAR_0->packedDataSize,\n                     VAR_0->minY, VAR_0->uncompressedData);\n            }\n            else\n            {\n                /* COMMENT_0 */\n                /* COMMENT_5 */\n                /* COMMENT_6 */\n                /* COMMENT_0 */\n\n                VAR_0->format = Compressor::XDR;\n                VAR_0->uncompressedData = VAR_0->buffer;\n            }\n        }\n\n        int VAR_6, VAR_7, VAR_8;\n\n        if (VAR_3->lineOrder == VAR_9)\n        {\n            VAR_6 = VAR_10;\n            VAR_7 = VAR_11 + 1;\n            VAR_8 = 1;\n        }\n        else\n        {\n            VAR_6 = VAR_11;\n            VAR_7 = VAR_10 - 1;\n            VAR_8 = -1;\n        }\n\n        for (int VAR_12 = VAR_6; VAR_12 != VAR_7; VAR_12 += VAR_8)\n        {\n            /* COMMENT_0 */\n            /* COMMENT_7 */\n            /* COMMENT_8 */\n            /* COMMENT_9 */\n            /* COMMENT_0 */\n\n            const char *VAR_13 = VAR_0->uncompressedData +\n                                  VAR_3->offsetInLineBuffer[VAR_12 - VAR_3->minY];\n\n            /* COMMENT_0 */\n            /* COMMENT_10 */\n            /* COMMENT_0 */\n\n            for (unsigned int VAR_4 = 0; VAR_4 < VAR_3->slices.size(); ++VAR_4)\n            {\n                /* COMMENT_0 */\n                /* COMMENT_11 */\n                /* COMMENT_12 */\n                /* COMMENT_0 */\n\n                InSliceInfo &VAR_14 = *VAR_3->slices[VAR_4];\n\n                if (modp (VAR_12, VAR_14.ySampling) != 0)\n                    continue;\n\n                /* COMMENT_0 */\n                /* COMMENT_13 */\n                /* COMMENT_14 */\n                /* COMMENT_15 */\n                /* COMMENT_0 */\n\n                /* COMMENT_0 */\n                /* COMMENT_16 */\n                /* COMMENT_0 */\n\n                if (VAR_14.skip)\n                {\n                    /* COMMENT_0 */\n                    /* COMMENT_17 */\n                    /* COMMENT_18 */\n                    /* COMMENT_0 */\n\n                    skipChannel (VAR_13, VAR_14.typeInFile,\n                                 VAR_3->lineSampleCount[VAR_12 - VAR_3->minY]);\n                }\n                else\n                {\n                    /* COMMENT_0 */\n                    /* COMMENT_19 */\n                    /* COMMENT_0 */\n\n                    int VAR_15 = (VAR_3->maxX - VAR_3->minX + 1);\n\n                    copyIntoDeepFrameBuffer (VAR_13, VAR_14.base,\n                                             (char*) (&VAR_3->sampleCount[0][0]\n                                                      - VAR_3->minX\n                                                      - VAR_3->minY * VAR_15),\n                                             sizeof(unsigned int) * 1,\n                                             sizeof(unsigned int) * VAR_15,\n                                             VAR_12, VAR_3->minX, VAR_3->maxX,\n                                             0, 0,\n                                             0, 0,\n                                             VAR_14.sampleStride, \n                                             VAR_14.xPointerStride,\n                                             VAR_14.yPointerStride,\n                                             VAR_14.fill,\n                                             VAR_14.fillValue, VAR_0->format,\n                                             VAR_14.typeInFrameBuffer,\n                                             VAR_14.typeInFile);\n                }\n            }\n        }\n    }\n    catch (std::exception &VAR_16)\n    {\n        if (!VAR_0->hasException)\n        {\n            VAR_0->exception = VAR_16.what();\n            VAR_0->hasException = true;\n        }\n    }\n    catch (...)\n    {\n        if (!VAR_0->hasException)\n        {\n            VAR_0->exception = \"unrecognized exception\";\n            VAR_0->hasException = true;\n        }\n    }\n}",
  "func_graph_path_before": null,
  "func": "void\nLineBufferTask::execute ()\n{\n    try\n    {\n        //\n        // Uncompress the data, if necessary\n        //\n\n        if (_lineBuffer->uncompressedData == 0)\n        {\n            Int64 uncompressedSize = 0;\n            int maxY = min (_lineBuffer->maxY, _ifd->maxY);\n\n            for (int i = _lineBuffer->minY - _ifd->minY;\n                 i <= maxY - _ifd->minY;\n                 ++i)\n            {\n                uncompressedSize += (int) _ifd->bytesPerLine[i];\n            }\n\n            //\n            // Create the compressor everytime when we want to use it,\n            // because we don't know maxBytesPerLine beforehand.\n            // (TODO) optimize this. don't do this every time.\n            //\n\n            if (_lineBuffer->compressor != 0)\n                delete _lineBuffer->compressor;\n            Int64 maxBytesPerLine = 0;\n            for (int i = _lineBuffer->minY - _ifd->minY;\n                 i <= maxY - _ifd->minY;\n                 ++i)\n            {\n                if (_ifd->bytesPerLine[i] > maxBytesPerLine)\n                    maxBytesPerLine = _ifd->bytesPerLine[i];\n            }\n            _lineBuffer->compressor = newCompressor(_ifd->header.compression(),\n                                                    maxBytesPerLine,\n                                                    _ifd->header);\n\n            if (_lineBuffer->compressor &&\n                _lineBuffer->packedDataSize < uncompressedSize)\n            {\n                _lineBuffer->format = _lineBuffer->compressor->format();\n\n                _lineBuffer->packedDataSize = _lineBuffer->compressor->uncompress\n                    (_lineBuffer->buffer, _lineBuffer->packedDataSize,\n                     _lineBuffer->minY, _lineBuffer->uncompressedData);\n            }\n            else\n            {\n                //\n                // If the line is uncompressed, it's in XDR format,\n                // regardless of the compressor's output format.\n                //\n\n                _lineBuffer->format = Compressor::XDR;\n                _lineBuffer->uncompressedData = _lineBuffer->buffer;\n            }\n        }\n\n        int yStart, yStop, dy;\n\n        if (_ifd->lineOrder == INCREASING_Y)\n        {\n            yStart = _scanLineMin;\n            yStop = _scanLineMax + 1;\n            dy = 1;\n        }\n        else\n        {\n            yStart = _scanLineMax;\n            yStop = _scanLineMin - 1;\n            dy = -1;\n        }\n\n        for (int y = yStart; y != yStop; y += dy)\n        {\n            //\n            // Convert one scan line's worth of pixel data back\n            // from the machine-independent representation, and\n            // store the result in the frame buffer.\n            //\n\n            const char *readPtr = _lineBuffer->uncompressedData +\n                                  _ifd->offsetInLineBuffer[y - _ifd->minY];\n\n            //\n            // Iterate over all image channels.\n            //\n\n            for (unsigned int i = 0; i < _ifd->slices.size(); ++i)\n            {\n                //\n                // Test if scan line y of this channel contains any data\n                // (the scan line contains data only if y % ySampling == 0).\n                //\n\n                InSliceInfo &slice = *_ifd->slices[i];\n\n                if (modp (y, slice.ySampling) != 0)\n                    continue;\n\n                //\n                // Find the x coordinates of the leftmost and rightmost\n                // sampled pixels (i.e. pixels within the data window\n                // for which x % xSampling == 0).\n                //\n\n                //\n                // Fill the frame buffer with pixel data.\n                //\n\n                if (slice.skip)\n                {\n                    //\n                    // The file contains data for this channel, but\n                    // the frame buffer contains no slice for this channel.\n                    //\n\n                    skipChannel (readPtr, slice.typeInFile,\n                                 _ifd->lineSampleCount[y - _ifd->minY]);\n                }\n                else\n                {\n                    //\n                    // The frame buffer contains a slice for this channel.\n                    //\n\n                    int width = (_ifd->maxX - _ifd->minX + 1);\n\n                    ptrdiff_t base = reinterpret_cast<ptrdiff_t>(&_ifd->sampleCount[0][0]);\n                    base -= sizeof(unsigned int)*_ifd->minX;\n                    base -= sizeof(unsigned int)*static_cast<ptrdiff_t>(_ifd->minY) * static_cast<ptrdiff_t>(width);\n\n                    copyIntoDeepFrameBuffer (readPtr, slice.base,\n                                             reinterpret_cast<char*>(base),\n                                             sizeof(unsigned int) * 1,\n                                             sizeof(unsigned int) * width,\n                                             y, _ifd->minX, _ifd->maxX,\n                                             0, 0,\n                                             0, 0,\n                                             slice.sampleStride, \n                                             slice.xPointerStride,\n                                             slice.yPointerStride,\n                                             slice.fill,\n                                             slice.fillValue, _lineBuffer->format,\n                                             slice.typeInFrameBuffer,\n                                             slice.typeInFile);\n                }\n            }\n        }\n    }\n    catch (std::exception &e)\n    {\n        if (!_lineBuffer->hasException)\n        {\n            _lineBuffer->exception = e.what();\n            _lineBuffer->hasException = true;\n        }\n    }\n    catch (...)\n    {\n        if (!_lineBuffer->hasException)\n        {\n            _lineBuffer->exception = \"unrecognized exception\";\n            _lineBuffer->hasException = true;\n        }\n    }\n}",
  "abstract_func": "void\nLineBufferTask::execute ()\n{\n    try\n    {\n        /* COMMENT_0 */\n        /* COMMENT_1 */\n        /* COMMENT_0 */\n\n        if (VAR_0->uncompressedData == 0)\n        {\n            Int64 VAR_1 = 0;\n            int VAR_2 = min (VAR_0->maxY, VAR_3->maxY);\n\n            for (int VAR_4 = VAR_0->minY - VAR_3->minY;\n                 VAR_4 <= VAR_2 - VAR_3->minY;\n                 ++VAR_4)\n            {\n                VAR_1 += (int) VAR_3->bytesPerLine[VAR_4];\n            }\n\n            /* COMMENT_0 */\n            /* COMMENT_2 */\n            /* COMMENT_3 */\n            /* COMMENT_4 */\n            /* COMMENT_0 */\n\n            if (VAR_0->compressor != 0)\n                delete VAR_0->compressor;\n            Int64 VAR_5 = 0;\n            for (int VAR_4 = VAR_0->minY - VAR_3->minY;\n                 VAR_4 <= VAR_2 - VAR_3->minY;\n                 ++VAR_4)\n            {\n                if (VAR_3->bytesPerLine[VAR_4] > VAR_5)\n                    VAR_5 = VAR_3->bytesPerLine[VAR_4];\n            }\n            VAR_0->compressor = newCompressor(VAR_3->header.compression(),\n                                                    VAR_5,\n                                                    VAR_3->header);\n\n            if (VAR_0->compressor &&\n                VAR_0->packedDataSize < VAR_1)\n            {\n                VAR_0->format = VAR_0->compressor->format();\n\n                VAR_0->packedDataSize = VAR_0->compressor->uncompress\n                    (VAR_0->buffer, VAR_0->packedDataSize,\n                     VAR_0->minY, VAR_0->uncompressedData);\n            }\n            else\n            {\n                /* COMMENT_0 */\n                /* COMMENT_5 */\n                /* COMMENT_6 */\n                /* COMMENT_0 */\n\n                VAR_0->format = Compressor::XDR;\n                VAR_0->uncompressedData = VAR_0->buffer;\n            }\n        }\n\n        int VAR_6, VAR_7, VAR_8;\n\n        if (VAR_3->lineOrder == VAR_9)\n        {\n            VAR_6 = VAR_10;\n            VAR_7 = VAR_11 + 1;\n            VAR_8 = 1;\n        }\n        else\n        {\n            VAR_6 = VAR_11;\n            VAR_7 = VAR_10 - 1;\n            VAR_8 = -1;\n        }\n\n        for (int VAR_12 = VAR_6; VAR_12 != VAR_7; VAR_12 += VAR_8)\n        {\n            /* COMMENT_0 */\n            /* COMMENT_7 */\n            /* COMMENT_8 */\n            /* COMMENT_9 */\n            /* COMMENT_0 */\n\n            const char *VAR_13 = VAR_0->uncompressedData +\n                                  VAR_3->offsetInLineBuffer[VAR_12 - VAR_3->minY];\n\n            /* COMMENT_0 */\n            /* COMMENT_10 */\n            /* COMMENT_0 */\n\n            for (unsigned int VAR_4 = 0; VAR_4 < VAR_3->slices.size(); ++VAR_4)\n            {\n                /* COMMENT_0 */\n                /* COMMENT_11 */\n                /* COMMENT_12 */\n                /* COMMENT_0 */\n\n                InSliceInfo &VAR_14 = *VAR_3->slices[VAR_4];\n\n                if (modp (VAR_12, VAR_14.ySampling) != 0)\n                    continue;\n\n                /* COMMENT_0 */\n                /* COMMENT_13 */\n                /* COMMENT_14 */\n                /* COMMENT_15 */\n                /* COMMENT_0 */\n\n                /* COMMENT_0 */\n                /* COMMENT_16 */\n                /* COMMENT_0 */\n\n                if (VAR_14.skip)\n                {\n                    /* COMMENT_0 */\n                    /* COMMENT_17 */\n                    /* COMMENT_18 */\n                    /* COMMENT_0 */\n\n                    skipChannel (VAR_13, VAR_14.typeInFile,\n                                 VAR_3->lineSampleCount[VAR_12 - VAR_3->minY]);\n                }\n                else\n                {\n                    /* COMMENT_0 */\n                    /* COMMENT_19 */\n                    /* COMMENT_0 */\n\n                    int VAR_15 = (VAR_3->maxX - VAR_3->minX + 1);\n\n                    ptrdiff_t VAR_16 = VAR_17<ptrdiff_t>(&VAR_3->sampleCount[0][0]);\n                    VAR_16 -= sizeof(unsigned int)*VAR_3->minX;\n                    VAR_16 -= sizeof(unsigned int)*VAR_18<ptrdiff_t>(VAR_3->minY) * VAR_18<ptrdiff_t>(VAR_15);\n\n                    copyIntoDeepFrameBuffer (VAR_13, VAR_14.base,\n                                             VAR_17<char*>(VAR_16),\n                                             sizeof(unsigned int) * 1,\n                                             sizeof(unsigned int) * VAR_15,\n                                             VAR_12, VAR_3->minX, VAR_3->maxX,\n                                             0, 0,\n                                             0, 0,\n                                             VAR_14.sampleStride, \n                                             VAR_14.xPointerStride,\n                                             VAR_14.yPointerStride,\n                                             VAR_14.fill,\n                                             VAR_14.fillValue, VAR_0->format,\n                                             VAR_14.typeInFrameBuffer,\n                                             VAR_14.typeInFile);\n                }\n            }\n        }\n    }\n    catch (std::exception &VAR_19)\n    {\n        if (!VAR_0->hasException)\n        {\n            VAR_0->exception = VAR_19.what();\n            VAR_0->hasException = true;\n        }\n    }\n    catch (...)\n    {\n        if (!VAR_0->hasException)\n        {\n            VAR_0->exception = \"unrecognized exception\";\n            VAR_0->hasException = true;\n        }\n    }\n}",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -130,10 +130,12 @@\n \n                     int width = (_ifd->maxX - _ifd->minX + 1);\n \n+                    ptrdiff_t base = reinterpret_cast<ptrdiff_t>(&_ifd->sampleCount[0][0]);\n+                    base -= sizeof(unsigned int)*_ifd->minX;\n+                    base -= sizeof(unsigned int)*static_cast<ptrdiff_t>(_ifd->minY) * static_cast<ptrdiff_t>(width);\n+\n                     copyIntoDeepFrameBuffer (readPtr, slice.base,\n-                                             (char*) (&_ifd->sampleCount[0][0]\n-                                                      - _ifd->minX\n-                                                      - _ifd->minY * width),\n+                                             reinterpret_cast<char*>(base),\n                                              sizeof(unsigned int) * 1,\n                                              sizeof(unsigned int) * width,\n                                              y, _ifd->minX, _ifd->maxX,",
  "diff_line_info": {
    "deleted_lines": [
      "                                             (char*) (&_ifd->sampleCount[0][0]",
      "                                                      - _ifd->minX",
      "                                                      - _ifd->minY * width),"
    ],
    "added_lines": [
      "                    ptrdiff_t base = reinterpret_cast<ptrdiff_t>(&_ifd->sampleCount[0][0]);",
      "                    base -= sizeof(unsigned int)*_ifd->minX;",
      "                    base -= sizeof(unsigned int)*static_cast<ptrdiff_t>(_ifd->minY) * static_cast<ptrdiff_t>(width);",
      "",
      "                                             reinterpret_cast<char*>(base),"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/AcademySoftwareFoundation/openexr/pull/842",
  "description": {
    "pr_info": {
      "title": "add exrcheck utility and hooks for fuzz testing",
      "number": 842
    },
    "comment": [
      "This adds an `exrcheck` binary (not installed by default) that can be used to check for bad files, as well as looking for issues in the OpenEXR library. This wraps a new API call in IlmImfUtil: checkOpenEXRFile()\r\n\r\nA hook to call this function with the [oss-fuzz](https://github.com/google/oss-fuzz) project has also been added in IlmImfFuzzTest. This file is to be compiled by that project\r\n\r\nOpenEXR's internal fuzz tests could also be adapted to use checkOpenEXRFile instead of their own function. This would allow for more exhaustive testing.\r\n\r\nA few other additions to the API:\r\n\r\n- For this to work efficiently, missing functionality is added to open (single part) DeepScanLineInputFiles via a stream interface. This was the only API missing that functionality\r\n- MultiPartInputFile::flushPartCache method is required to switch between part readers (Tiled files can be read either as TiledInputPart or InputPart. flushPartCache must be called to change the reader type within the same object)\r\n\r\nOther bugfixes to address issues found while testing against the 'Damaged' file list that were required to properly test `exrcheck`:\r\n\r\n- DeepScanLineInputFile had a 32 bit integer overflow accessing the sample count table with very large values of dataWindow.min.x\r\n- InputFile could crash when reading tiled files as scanlines in 'readPixels' if 'setFrameBuffer' was called with an empty frame buffer\r\n- Single part non-image files would not be detected in the TiledInputFile. Attempting to read anything which isn't a tiled regular image with this call now throws an exception. This should also address https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=25892 and https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=25894"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.9\n\nThe patch addresses integer overflow and crash issues, which are security concerns, and includes testing enhancements for security testing. The code changes directly fix these vulnerabilities."
}