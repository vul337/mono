{
  "cve_id": "CVE-2021-21417",
  "cwe_ids": [
    "CWE-416"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "FluidSynth/fluidsynth",
  "commit_msg": "Update fluid_sffile.c",
  "commit_hash": "6673a5f73c0484f8462b4b33860d2b1c68c24684",
  "git_url": "https://github.com/FluidSynth/fluidsynth/commit/6673a5f73c0484f8462b4b33860d2b1c68c24684",
  "file_path": "src/sfloader/fluid_sffile.c",
  "func_name": "load_igen",
  "func_before": "static int load_igen(SFData *sf, int size)\n{\n    fluid_list_t *p, *p2, *p3, *dup, **hz = NULL, *start_of_zone_list;\n    SFZone *z;\n    SFGen *g;\n    SFGenAmount genval;\n    unsigned short genid;\n    int level, skip, drop, gzone, discarded;\n\n    p = sf->inst;\n\n    while(p)\n    {\n        /* traverse through all instruments */\n        gzone = FALSE;\n        discarded = FALSE;\n        start_of_zone_list = p2 = ((SFInst *)(p->data))->zone;\n\n        if(p2)\n        {\n            hz = &p2;\n        }\n\n        while(p2)\n        {\n            /* traverse this instrument's zones */\n            level = 0;\n            z = (SFZone *)(p2->data);\n            p3 = z->gen;\n\n            while(p3)\n            {\n                /* load zone's generators */\n                dup = NULL;\n                skip = FALSE;\n                drop = FALSE;\n\n                if((size -= SF_GEN_SIZE) < 0)\n                {\n                    FLUID_LOG(FLUID_ERR, \"IGEN chunk size mismatch\");\n                    return FALSE;\n                }\n\n                READW(sf, genid);\n\n                if(genid == Gen_KeyRange)\n                {\n                    /* nothing precedes */\n                    if(level == 0)\n                    {\n                        level = 1;\n                        READB(sf, genval.range.lo);\n                        READB(sf, genval.range.hi);\n                    }\n                    else\n                    {\n                        skip = TRUE;\n                    }\n                }\n                else if(genid == Gen_VelRange)\n                {\n                    /* only KeyRange precedes */\n                    if(level <= 1)\n                    {\n                        level = 2;\n                        READB(sf, genval.range.lo);\n                        READB(sf, genval.range.hi);\n                    }\n                    else\n                    {\n                        skip = TRUE;\n                    }\n                }\n                else if(genid == Gen_SampleId)\n                {\n                    /* sample is last gen */\n                    level = 3;\n                    READW(sf, genval.uword);\n                    ((SFZone *)(p2->data))->instsamp = FLUID_INT_TO_POINTER(genval.uword + 1);\n                    break; /* break out of generator loop */\n                }\n                else\n                {\n                    level = 2;\n\n                    if(valid_inst_genid(genid))\n                    {\n                        /* gen valid? */\n                        READW(sf, genval.sword);\n                        dup = find_gen_by_id(genid, z->gen);\n                    }\n                    else\n                    {\n                        skip = TRUE;\n                    }\n                }\n\n                if(!skip)\n                {\n                    if(!dup)\n                    {\n                        /* if gen ! dup alloc new */\n                        if((g = FLUID_NEW(SFGen)) == NULL)\n                        {\n                            FLUID_LOG(FLUID_ERR, \"Out of memory\");\n                            return FALSE;\n                        }\n\n                        p3->data = g;\n                        g->id = genid;\n                    }\n                    else\n                    {\n                        g = (SFGen *)(dup->data);\n                        drop = TRUE;\n                    }\n\n                    g->amount = genval;\n                }\n                else\n                {\n                    /* skip this generator */\n                    discarded = TRUE;\n                    drop = TRUE;\n                    FSKIPW(sf);\n                }\n\n                if(!drop)\n                {\n                    p3 = fluid_list_next(p3);    /* next gen */\n                }\n                else\n                {\n                    SLADVREM(z->gen, p3);\n                }\n\n            } /* generator loop */\n\n            if(level == 3)\n            {\n                SLADVREM(z->gen, p3);    /* zone has sample? */\n            }\n            else\n            {\n                /* its a global zone */\n                if(!gzone)\n                {\n                    gzone = TRUE;\n\n                    /* if global zone is not 1st zone, relocate */\n                    if(*hz != p2)\n                    {\n                        void *save = p2->data;\n                        FLUID_LOG(FLUID_WARN, \"Instrument '%s': Global zone is not first zone\",\n                                  ((SFPreset *)(p->data))->name);\n                        SLADVREM(*hz, p2);\n                        *hz = fluid_list_prepend(*hz, save);\n                        continue;\n                    }\n                }\n                else\n                {\n                    SFZone * izone = fluid_list_get(p2);\n                    /* previous global zone exists, discard */\n                    FLUID_LOG(FLUID_WARN, \"Instrument '%s': Discarding invalid global zone\",\n                              ((SFInst *)(p->data))->name);\n                    *hz = fluid_list_remove(start_of_zone_list, izone);\n                    delete_zone(izone);\n                }\n            }\n\n            while(p3)\n            {\n                /* Kill any zones following a sample */\n                discarded = TRUE;\n\n                if((size -= SF_GEN_SIZE) < 0)\n                {\n                    FLUID_LOG(FLUID_ERR, \"Instrument generator chunk size mismatch\");\n                    return FALSE;\n                }\n\n                FSKIP(sf, SF_GEN_SIZE);\n                SLADVREM(z->gen, p3);\n            }\n\n            p2 = fluid_list_next(p2); /* next zone */\n        }\n\n        if(discarded)\n        {\n            FLUID_LOG(FLUID_WARN,\n                      \"Instrument '%s': Some invalid generators were discarded\",\n                      ((SFInst *)(p->data))->name);\n        }\n\n        p = fluid_list_next(p);\n    }\n\n    /* for those non-terminal record cases, grr! */\n    if(size == 0)\n    {\n        return TRUE;\n    }\n\n    size -= SF_GEN_SIZE;\n\n    if(size != 0)\n    {\n        FLUID_LOG(FLUID_ERR, \"IGEN chunk size mismatch\");\n        return FALSE;\n    }\n\n    FSKIP(sf, SF_GEN_SIZE); /* terminal gen */\n\n    return TRUE;\n}",
  "abstract_func_before": "static int load_igen(SFData *VAR_0, int VAR_1)\n{\n    fluid_list_t *VAR_2, *VAR_3, *VAR_4, *VAR_5, **VAR_6 = NULL, *VAR_7;\n    SFZone *VAR_8;\n    SFGen *VAR_9;\n    SFGenAmount VAR_10;\n    unsigned short VAR_11;\n    int VAR_12, VAR_13, VAR_14, VAR_15, VAR_16;\n\n    VAR_2 = VAR_0->inst;\n\n    while(VAR_2)\n    {\n        /* COMMENT_0 */\n        VAR_15 = FALSE;\n        VAR_16 = FALSE;\n        VAR_7 = VAR_3 = ((SFInst *)(VAR_2->data))->zone;\n\n        if(VAR_3)\n        {\n            VAR_6 = &VAR_3;\n        }\n\n        while(VAR_3)\n        {\n            /* COMMENT_1 */\n            VAR_12 = 0;\n            VAR_8 = (SFZone *)(VAR_3->data);\n            VAR_4 = VAR_8->gen;\n\n            while(VAR_4)\n            {\n                /* COMMENT_2 */\n                VAR_5 = NULL;\n                VAR_13 = FALSE;\n                VAR_14 = FALSE;\n\n                if((VAR_1 -= VAR_17) < 0)\n                {\n                    FLUID_LOG(VAR_18, \"IGEN chunk size mismatch\");\n                    return FALSE;\n                }\n\n                READW(VAR_0, VAR_11);\n\n                if(VAR_11 == VAR_19)\n                {\n                    /* COMMENT_3 */\n                    if(VAR_12 == 0)\n                    {\n                        VAR_12 = 1;\n                        READB(VAR_0, VAR_10.range.lo);\n                        READB(VAR_0, VAR_10.range.hi);\n                    }\n                    else\n                    {\n                        VAR_13 = TRUE;\n                    }\n                }\n                else if(VAR_11 == VAR_20)\n                {\n                    /* COMMENT_4 */\n                    if(VAR_12 <= 1)\n                    {\n                        VAR_12 = 2;\n                        READB(VAR_0, VAR_10.range.lo);\n                        READB(VAR_0, VAR_10.range.hi);\n                    }\n                    else\n                    {\n                        VAR_13 = TRUE;\n                    }\n                }\n                else if(VAR_11 == VAR_21)\n                {\n                    /* COMMENT_5 */\n                    VAR_12 = 3;\n                    READW(VAR_0, VAR_10.uword);\n                    ((SFZone *)(VAR_3->data))->instsamp = FLUID_INT_TO_POINTER(VAR_10.uword + 1);\n                    break; /* COMMENT_6 */\n                }\n                else\n                {\n                    VAR_12 = 2;\n\n                    if(valid_inst_genid(VAR_11))\n                    {\n                        /* COMMENT_7 */\n                        READW(VAR_0, VAR_10.sword);\n                        VAR_5 = find_gen_by_id(VAR_11, VAR_8->gen);\n                    }\n                    else\n                    {\n                        VAR_13 = TRUE;\n                    }\n                }\n\n                if(!VAR_13)\n                {\n                    if(!VAR_5)\n                    {\n                        /* COMMENT_8 */\n                        if((VAR_9 = FLUID_NEW(SFGen)) == NULL)\n                        {\n                            FLUID_LOG(VAR_18, \"Out of memory\");\n                            return FALSE;\n                        }\n\n                        VAR_4->data = VAR_9;\n                        VAR_9->id = VAR_11;\n                    }\n                    else\n                    {\n                        VAR_9 = (SFGen *)(VAR_5->data);\n                        VAR_14 = TRUE;\n                    }\n\n                    VAR_9->amount = VAR_10;\n                }\n                else\n                {\n                    /* COMMENT_9 */\n                    VAR_16 = TRUE;\n                    VAR_14 = TRUE;\n                    FSKIPW(VAR_0);\n                }\n\n                if(!VAR_14)\n                {\n                    VAR_4 = fluid_list_next(VAR_4);    /* COMMENT_10 */\n                }\n                else\n                {\n                    SLADVREM(VAR_8->gen, VAR_4);\n                }\n\n            } /* COMMENT_11 */\n\n            if(VAR_12 == 3)\n            {\n                SLADVREM(VAR_8->gen, VAR_4);    /* COMMENT_12 */\n            }\n            else\n            {\n                /* COMMENT_13 */\n                if(!VAR_15)\n                {\n                    VAR_15 = TRUE;\n\n                    /* COMMENT_14 */\n                    if(*VAR_6 != VAR_3)\n                    {\n                        void *VAR_22 = VAR_3->data;\n                        FLUID_LOG(VAR_23, \"Instrument '%s': Global zone is not first zone\",\n                                  ((SFPreset *)(VAR_2->data))->name);\n                        SLADVREM(*VAR_6, VAR_3);\n                        *VAR_6 = fluid_list_prepend(*VAR_6, VAR_22);\n                        continue;\n                    }\n                }\n                else\n                {\n                    SFZone * VAR_24 = fluid_list_get(VAR_3);\n                    /* COMMENT_15 */\n                    FLUID_LOG(VAR_23, \"Instrument '%s': Discarding invalid global zone\",\n                              ((SFInst *)(VAR_2->data))->name);\n                    *VAR_6 = fluid_list_remove(VAR_7, VAR_24);\n                    delete_zone(VAR_24);\n                }\n            }\n\n            while(VAR_4)\n            {\n                /* COMMENT_16 */\n                VAR_16 = TRUE;\n\n                if((VAR_1 -= VAR_17) < 0)\n                {\n                    FLUID_LOG(VAR_18, \"Instrument generator chunk size mismatch\");\n                    return FALSE;\n                }\n\n                FSKIP(VAR_0, VAR_17);\n                SLADVREM(VAR_8->gen, VAR_4);\n            }\n\n            VAR_3 = fluid_list_next(VAR_3); /* COMMENT_17 */\n        }\n\n        if(VAR_16)\n        {\n            FLUID_LOG(VAR_23,\n                      \"Instrument '%s': Some invalid generators were discarded\",\n                      ((SFInst *)(VAR_2->data))->name);\n        }\n\n        VAR_2 = fluid_list_next(VAR_2);\n    }\n\n    /* COMMENT_18 */\n    if(VAR_1 == 0)\n    {\n        return TRUE;\n    }\n\n    VAR_1 -= VAR_17;\n\n    if(VAR_1 != 0)\n    {\n        FLUID_LOG(VAR_18, \"IGEN chunk size mismatch\");\n        return FALSE;\n    }\n\n    FSKIP(VAR_0, VAR_17); /* COMMENT_19 */\n\n    return TRUE;\n}",
  "func_graph_path_before": "FluidSynth/fluidsynth/6673a5f73c0484f8462b4b33860d2b1c68c24684/fluid_sffile.c/vul/before/0.json",
  "func": "static int load_igen(SFData *sf, int size)\n{\n    fluid_list_t *p, *p2, *p3, *dup, **hz = NULL, *start_of_zone_list;\n    SFZone *z;\n    SFGen *g;\n    SFGenAmount genval;\n    unsigned short genid;\n    int level, skip, drop, gzone, discarded;\n\n    p = sf->inst;\n\n    while(p)\n    {\n        /* traverse through all instruments */\n        gzone = FALSE;\n        discarded = FALSE;\n        start_of_zone_list = p2 = ((SFInst *)(p->data))->zone;\n\n        if(p2)\n        {\n            hz = &p2;\n        }\n\n        while(p2)\n        {\n            /* traverse this instrument's zones */\n            level = 0;\n            z = (SFZone *)(p2->data);\n            p3 = z->gen;\n\n            while(p3)\n            {\n                /* load zone's generators */\n                dup = NULL;\n                skip = FALSE;\n                drop = FALSE;\n\n                if((size -= SF_GEN_SIZE) < 0)\n                {\n                    FLUID_LOG(FLUID_ERR, \"IGEN chunk size mismatch\");\n                    return FALSE;\n                }\n\n                READW(sf, genid);\n\n                if(genid == Gen_KeyRange)\n                {\n                    /* nothing precedes */\n                    if(level == 0)\n                    {\n                        level = 1;\n                        READB(sf, genval.range.lo);\n                        READB(sf, genval.range.hi);\n                    }\n                    else\n                    {\n                        skip = TRUE;\n                    }\n                }\n                else if(genid == Gen_VelRange)\n                {\n                    /* only KeyRange precedes */\n                    if(level <= 1)\n                    {\n                        level = 2;\n                        READB(sf, genval.range.lo);\n                        READB(sf, genval.range.hi);\n                    }\n                    else\n                    {\n                        skip = TRUE;\n                    }\n                }\n                else if(genid == Gen_SampleId)\n                {\n                    /* sample is last gen */\n                    level = 3;\n                    READW(sf, genval.uword);\n                    ((SFZone *)(p2->data))->instsamp = FLUID_INT_TO_POINTER(genval.uword + 1);\n                    break; /* break out of generator loop */\n                }\n                else\n                {\n                    level = 2;\n\n                    if(valid_inst_genid(genid))\n                    {\n                        /* gen valid? */\n                        READW(sf, genval.sword);\n                        dup = find_gen_by_id(genid, z->gen);\n                    }\n                    else\n                    {\n                        skip = TRUE;\n                    }\n                }\n\n                if(!skip)\n                {\n                    if(!dup)\n                    {\n                        /* if gen ! dup alloc new */\n                        if((g = FLUID_NEW(SFGen)) == NULL)\n                        {\n                            FLUID_LOG(FLUID_ERR, \"Out of memory\");\n                            return FALSE;\n                        }\n\n                        p3->data = g;\n                        g->id = genid;\n                    }\n                    else\n                    {\n                        g = (SFGen *)(dup->data);\n                        drop = TRUE;\n                    }\n\n                    g->amount = genval;\n                }\n                else\n                {\n                    /* skip this generator */\n                    discarded = TRUE;\n                    drop = TRUE;\n                    FSKIPW(sf);\n                }\n\n                if(!drop)\n                {\n                    p3 = fluid_list_next(p3);    /* next gen */\n                }\n                else\n                {\n                    SLADVREM(z->gen, p3);\n                }\n\n            } /* generator loop */\n\n            if(level == 3)\n            {\n                SLADVREM(z->gen, p3);    /* zone has sample? */\n            }\n            else\n            {\n                /* its a global zone */\n                if(!gzone)\n                {\n                    gzone = TRUE;\n\n                    /* if global zone is not 1st zone, relocate */\n                    if(*hz != p2)\n                    {\n                        void *save = p2->data;\n                        FLUID_LOG(FLUID_WARN, \"Instrument '%s': Global zone is not first zone\",\n                                  ((SFPreset *)(p->data))->name);\n                        SLADVREM(*hz, p2);\n                        *hz = fluid_list_prepend(*hz, save);\n                        continue;\n                    }\n                }\n                else\n                {\n                    p2 = fluid_list_next(p2); /* advance to next zone before deleting the current list element */\n                    /* previous global zone exists, discard */\n                    FLUID_LOG(FLUID_WARN, \"Instrument '%s': Discarding invalid global zone\",\n                              ((SFInst *)(p->data))->name);\n                    fluid_list_remove(start_of_zone_list, z);\n                    delete_zone(z);\n                    continue;\n                }\n            }\n\n            while(p3)\n            {\n                /* Kill any zones following a sample */\n                discarded = TRUE;\n\n                if((size -= SF_GEN_SIZE) < 0)\n                {\n                    FLUID_LOG(FLUID_ERR, \"Instrument generator chunk size mismatch\");\n                    return FALSE;\n                }\n\n                FSKIP(sf, SF_GEN_SIZE);\n                SLADVREM(z->gen, p3);\n            }\n\n            p2 = fluid_list_next(p2); /* next zone */\n        }\n\n        if(discarded)\n        {\n            FLUID_LOG(FLUID_WARN,\n                      \"Instrument '%s': Some invalid generators were discarded\",\n                      ((SFInst *)(p->data))->name);\n        }\n\n        p = fluid_list_next(p);\n    }\n\n    /* for those non-terminal record cases, grr! */\n    if(size == 0)\n    {\n        return TRUE;\n    }\n\n    size -= SF_GEN_SIZE;\n\n    if(size != 0)\n    {\n        FLUID_LOG(FLUID_ERR, \"IGEN chunk size mismatch\");\n        return FALSE;\n    }\n\n    FSKIP(sf, SF_GEN_SIZE); /* terminal gen */\n\n    return TRUE;\n}",
  "abstract_func": "static int load_igen(SFData *VAR_0, int VAR_1)\n{\n    fluid_list_t *VAR_2, *VAR_3, *VAR_4, *VAR_5, **VAR_6 = NULL, *VAR_7;\n    SFZone *VAR_8;\n    SFGen *VAR_9;\n    SFGenAmount VAR_10;\n    unsigned short VAR_11;\n    int VAR_12, VAR_13, VAR_14, VAR_15, VAR_16;\n\n    VAR_2 = VAR_0->inst;\n\n    while(VAR_2)\n    {\n        /* COMMENT_0 */\n        VAR_15 = FALSE;\n        VAR_16 = FALSE;\n        VAR_7 = VAR_3 = ((SFInst *)(VAR_2->data))->zone;\n\n        if(VAR_3)\n        {\n            VAR_6 = &VAR_3;\n        }\n\n        while(VAR_3)\n        {\n            /* COMMENT_1 */\n            VAR_12 = 0;\n            VAR_8 = (SFZone *)(VAR_3->data);\n            VAR_4 = VAR_8->gen;\n\n            while(VAR_4)\n            {\n                /* COMMENT_2 */\n                VAR_5 = NULL;\n                VAR_13 = FALSE;\n                VAR_14 = FALSE;\n\n                if((VAR_1 -= VAR_17) < 0)\n                {\n                    FLUID_LOG(VAR_18, \"IGEN chunk size mismatch\");\n                    return FALSE;\n                }\n\n                READW(VAR_0, VAR_11);\n\n                if(VAR_11 == VAR_19)\n                {\n                    /* COMMENT_3 */\n                    if(VAR_12 == 0)\n                    {\n                        VAR_12 = 1;\n                        READB(VAR_0, VAR_10.range.lo);\n                        READB(VAR_0, VAR_10.range.hi);\n                    }\n                    else\n                    {\n                        VAR_13 = TRUE;\n                    }\n                }\n                else if(VAR_11 == VAR_20)\n                {\n                    /* COMMENT_4 */\n                    if(VAR_12 <= 1)\n                    {\n                        VAR_12 = 2;\n                        READB(VAR_0, VAR_10.range.lo);\n                        READB(VAR_0, VAR_10.range.hi);\n                    }\n                    else\n                    {\n                        VAR_13 = TRUE;\n                    }\n                }\n                else if(VAR_11 == VAR_21)\n                {\n                    /* COMMENT_5 */\n                    VAR_12 = 3;\n                    READW(VAR_0, VAR_10.uword);\n                    ((SFZone *)(VAR_3->data))->instsamp = FLUID_INT_TO_POINTER(VAR_10.uword + 1);\n                    break; /* COMMENT_6 */\n                }\n                else\n                {\n                    VAR_12 = 2;\n\n                    if(valid_inst_genid(VAR_11))\n                    {\n                        /* COMMENT_7 */\n                        READW(VAR_0, VAR_10.sword);\n                        VAR_5 = find_gen_by_id(VAR_11, VAR_8->gen);\n                    }\n                    else\n                    {\n                        VAR_13 = TRUE;\n                    }\n                }\n\n                if(!VAR_13)\n                {\n                    if(!VAR_5)\n                    {\n                        /* COMMENT_8 */\n                        if((VAR_9 = FLUID_NEW(SFGen)) == NULL)\n                        {\n                            FLUID_LOG(VAR_18, \"Out of memory\");\n                            return FALSE;\n                        }\n\n                        VAR_4->data = VAR_9;\n                        VAR_9->id = VAR_11;\n                    }\n                    else\n                    {\n                        VAR_9 = (SFGen *)(VAR_5->data);\n                        VAR_14 = TRUE;\n                    }\n\n                    VAR_9->amount = VAR_10;\n                }\n                else\n                {\n                    /* COMMENT_9 */\n                    VAR_16 = TRUE;\n                    VAR_14 = TRUE;\n                    FSKIPW(VAR_0);\n                }\n\n                if(!VAR_14)\n                {\n                    VAR_4 = fluid_list_next(VAR_4);    /* COMMENT_10 */\n                }\n                else\n                {\n                    SLADVREM(VAR_8->gen, VAR_4);\n                }\n\n            } /* COMMENT_11 */\n\n            if(VAR_12 == 3)\n            {\n                SLADVREM(VAR_8->gen, VAR_4);    /* COMMENT_12 */\n            }\n            else\n            {\n                /* COMMENT_13 */\n                if(!VAR_15)\n                {\n                    VAR_15 = TRUE;\n\n                    /* COMMENT_14 */\n                    if(*VAR_6 != VAR_3)\n                    {\n                        void *VAR_22 = VAR_3->data;\n                        FLUID_LOG(VAR_23, \"Instrument '%s': Global zone is not first zone\",\n                                  ((SFPreset *)(VAR_2->data))->name);\n                        SLADVREM(*VAR_6, VAR_3);\n                        *VAR_6 = fluid_list_prepend(*VAR_6, VAR_22);\n                        continue;\n                    }\n                }\n                else\n                {\n                    VAR_3 = fluid_list_next(VAR_3); /* COMMENT_15 */\n                    /* COMMENT_16 */\n                    FLUID_LOG(VAR_23, \"Instrument '%s': Discarding invalid global zone\",\n                              ((SFInst *)(VAR_2->data))->name);\n                    fluid_list_remove(VAR_7, VAR_8);\n                    delete_zone(VAR_8);\n                    continue;\n                }\n            }\n\n            while(VAR_4)\n            {\n                /* COMMENT_17 */\n                VAR_16 = TRUE;\n\n                if((VAR_1 -= VAR_17) < 0)\n                {\n                    FLUID_LOG(VAR_18, \"Instrument generator chunk size mismatch\");\n                    return FALSE;\n                }\n\n                FSKIP(VAR_0, VAR_17);\n                SLADVREM(VAR_8->gen, VAR_4);\n            }\n\n            VAR_3 = fluid_list_next(VAR_3); /* COMMENT_18 */\n        }\n\n        if(VAR_16)\n        {\n            FLUID_LOG(VAR_23,\n                      \"Instrument '%s': Some invalid generators were discarded\",\n                      ((SFInst *)(VAR_2->data))->name);\n        }\n\n        VAR_2 = fluid_list_next(VAR_2);\n    }\n\n    /* COMMENT_19 */\n    if(VAR_1 == 0)\n    {\n        return TRUE;\n    }\n\n    VAR_1 -= VAR_17;\n\n    if(VAR_1 != 0)\n    {\n        FLUID_LOG(VAR_18, \"IGEN chunk size mismatch\");\n        return FALSE;\n    }\n\n    FSKIP(VAR_0, VAR_17); /* COMMENT_20 */\n\n    return TRUE;\n}",
  "func_graph_path": "FluidSynth/fluidsynth/6673a5f73c0484f8462b4b33860d2b1c68c24684/fluid_sffile.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -160,12 +160,13 @@\n                 }\n                 else\n                 {\n-                    SFZone * izone = fluid_list_get(p2);\n+                    p2 = fluid_list_next(p2); /* advance to next zone before deleting the current list element */\n                     /* previous global zone exists, discard */\n                     FLUID_LOG(FLUID_WARN, \"Instrument '%s': Discarding invalid global zone\",\n                               ((SFInst *)(p->data))->name);\n-                    *hz = fluid_list_remove(start_of_zone_list, izone);\n-                    delete_zone(izone);\n+                    fluid_list_remove(start_of_zone_list, z);\n+                    delete_zone(z);\n+                    continue;\n                 }\n             }\n ",
  "diff_line_info": {
    "deleted_lines": [
      "                    SFZone * izone = fluid_list_get(p2);",
      "                    *hz = fluid_list_remove(start_of_zone_list, izone);",
      "                    delete_zone(izone);"
    ],
    "added_lines": [
      "                    p2 = fluid_list_next(p2); /* advance to next zone before deleting the current list element */",
      "                    fluid_list_remove(start_of_zone_list, z);",
      "                    delete_zone(z);",
      "                    continue;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/FluidSynth/fluidsynth/pull/810",
  "description": {
    "pr_info": {
      "title": "Invalid generators were not removed from zone list",
      "number": 810
    },
    "comment": [
      "`fluid_list_remove()` should receive the beginning of a list, so it can adjust the predecessor of the element to be removed. Otherwise, the element would remain in the list, which in this case led to a use-after-free afterwards.\r\n\r\nResolves #808",
      "@veritas501 You may give it a test.",
      "Okay. It seems that the old bug has been fixed. I'm still testing if there are more bugs. @derselbst ",
      "I must admit I don't understand why this fixes the bug. `*hz` is a pointer to the first element in the zone list. So at the start it's effectively identical to the new `start_of_zone_list`. And `*hz` only gets changed if we encounter a global zone that is not first in list. In this case, the global zone moved to be first in that list and `*hz` is updated accordingly. So doing a `fluid_list_remove` on `*hz` should have the same effect as on the new `start_of_zone_list` pointer, shouldn't it?  ",
      "> *hz is a pointer to the first element in the zone list.\r\n\r\nNo, `hz` is a pointer to pointer. `*hz` is (usually) equal to `p2`. So, it would have been like putting\r\n `fluid_list_remove(p2, p2->data);`",
      "Ah, of course! Hm... then I have a hard time understanding the purpose of `hz` in the first place, and when it gets updated. I guess I need more time going through this again. That code reads a little like it's been deliberately obfuscated :-) I once had the impression that I understand what's going on, but that was a long time ago... \r\n\r\n",
      "The purpose of `hz` is not quite clear to me as well. It could be a leftover when they passed `hz` to a separate function that removed the zone:\r\n\r\nhttps://github.com/FluidSynth/fluidsynth/blob/62e375c71c815ca12f859b8722db5dff12f0c897/fluidsynth/src/sfloader/fluid_defsfont.c#L2443\r\n\r\nThe core logic around it already exists since \"Initial Revision\", so I'm a bit cautious to touch it. It would probably be a good idea to write a bunch of test cases, before changing it.",
      "Looking into `load_pgen()` some more, I think the logic behind that `hz` pointer is completely broken... and not just in the place where this PR introduces a fix. It's purpose is to be able to move a global zones that is not the first zone in a preset to the beginning of the zone list. But as `*hz` points to the local `p2` variable (i.e. the current entry in the zone list), the `preset->zone` list is not updated correctly.",
      "I don't see how the global zone relocation code will ever have run. As far as I understand it, the following check will always be false, because `*hz` and `p2` point to the same memory location:\r\nhttps://github.com/FluidSynth/fluidsynth/blob/b8fb6c81e1ca27c0bba2f6a0168832214f91d497/src/sfloader/fluid_sffile.c#L1517\r\n\r\nAnd looking back through the history of this code, I arrive at the initial commit which has the same behaviour. So I guess we could either remove the relocation code altogether, or fix try to fix it.",
      "> It's purpose is to be able to move a global zones that is not the first zone in a preset to the beginning of the zone list.\r\n\r\nYes, I also had the feeling it has to do with moving around zones. I also don't see how `(*hz != p2)` can ever evaluate to true.\r\n\r\n> And looking back through the history of this code, I arrive at the initial commit which has the same behaviour\r\n\r\nI arrived at iiwusynth: https://cvs.savannah.nongnu.org/viewvc/iiwusynth/iiwusynth/src/iiwu_defsfont.c?revision=1.1&view=markup\r\n\r\nWe could ask Peter, I'm sure he will remeber what he did 19 years ago :D\r\n\r\n> So I guess we could either remove the relocation code altogether, or fix try to fix it.\r\n\r\nI think we should fix it. Ideally by creating test cases. But this will take time. I would prefer to merge this and release 2.1.8 afterwards (even if it's not perfectly correct).",
      "Yes, or like that :-) That should do it, at least until we cleanup this code properly.",
      "Great! Then I will complete this tomorrow, to give @veritas501  the chance to report back."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9  \n\nThe patch addresses a use-after-free vulnerability by correcting how elements are removed from a list. The change ensures proper handling of list elements, fixing a security issue. The context and code changes clearly indicate this is a security fix."
}