{
  "cve_id": "CVE-2023-32732",
  "cwe_ids": [
    "CWE-440"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
  "cvss_is_v3": true,
  "repo_name": "grpc",
  "commit_msg": "[http] Dont drop connections on metadata limit exceeded",
  "commit_hash": "6a7850ef4f042ac26559854266dddc79bfbc75b2",
  "git_url": "https://github.com/grpc/grpc/commit/6a7850ef4f042ac26559854266dddc79bfbc75b2",
  "file_path": "src/core/ext/transport/chttp2/transport/parsing.cc",
  "func_name": "parse_frame_slice",
  "func_before": "static grpc_error_handle parse_frame_slice(grpc_chttp2_transport* t,\n                                           const grpc_slice& slice,\n                                           int is_last) {\n  grpc_chttp2_stream* s = t->incoming_stream;\n  if (grpc_http_trace.enabled()) {\n    gpr_log(GPR_DEBUG,\n            \"INCOMING[%p;%p]: Parse %\" PRIdPTR \"b %sframe fragment with %s\", t,\n            s, GRPC_SLICE_LENGTH(slice), is_last ? \"last \" : \"\",\n            t->parser.name);\n  }\n  grpc_error_handle err =\n      t->parser.parser(t->parser.user_data, t, s, slice, is_last);\n  intptr_t unused;\n  if (GPR_LIKELY(err.ok())) {\n    return err;\n  }\n  if (grpc_http_trace.enabled()) {\n    gpr_log(GPR_ERROR, \"INCOMING[%p;%p]: Parse failed with %s\", t, s,\n            err.ToString().c_str());\n  }\n  if (grpc_error_get_int(err, grpc_core::StatusIntProperty::kStreamId,\n                         &unused)) {\n    grpc_chttp2_parsing_become_skip_parser(t);\n    if (s) {\n      s->forced_close_error = err;\n      grpc_chttp2_add_rst_stream_to_next_write(t, t->incoming_stream_id,\n                                               GRPC_HTTP2_PROTOCOL_ERROR,\n                                               &s->stats.outgoing);\n    }\n  }\n  return err;\n}",
  "abstract_func_before": "static grpc_error_handle parse_frame_slice(grpc_chttp2_transport* VAR_0,\n                                           const grpc_slice& VAR_1,\n                                           int VAR_2) {\n  grpc_chttp2_stream* VAR_3 = VAR_0->incoming_stream;\n  if (VAR_4.enabled()) {\n    gpr_log(VAR_5,\n            \"INCOMING[%p;%p]: Parse %\" VAR_6 \"b %sframe fragment with %s\", VAR_0,\n            VAR_3, GRPC_SLICE_LENGTH(VAR_1), VAR_2 ? \"last \" : \"\",\n            VAR_0->parser.name);\n  }\n  grpc_error_handle VAR_7 =\n      VAR_0->parser.parser(VAR_0->parser.user_data, VAR_0, VAR_3, VAR_1, VAR_2);\n  intptr_t VAR_8;\n  if (GPR_LIKELY(VAR_7.ok())) {\n    return VAR_7;\n  }\n  if (VAR_4.enabled()) {\n    gpr_log(VAR_9, \"INCOMING[%p;%p]: Parse failed with %s\", VAR_0, VAR_3,\n            VAR_7.ToString().c_str());\n  }\n  if (grpc_error_get_int(VAR_7, grpc_core::StatusIntProperty::kStreamId,\n                         &VAR_8)) {\n    grpc_chttp2_parsing_become_skip_parser(VAR_0);\n    if (VAR_3) {\n      VAR_3->forced_close_error = VAR_7;\n      grpc_chttp2_add_rst_stream_to_next_write(VAR_0, VAR_0->incoming_stream_id,\n                                               VAR_10,\n                                               &VAR_3->stats.outgoing);\n    }\n  }\n  return VAR_7;\n}",
  "func_graph_path_before": "grpc/6a7850ef4f042ac26559854266dddc79bfbc75b2/parsing.cc/vul/before/0.json",
  "func": "static grpc_error_handle parse_frame_slice(grpc_chttp2_transport* t,\n                                           const grpc_slice& slice,\n                                           int is_last) {\n  grpc_chttp2_stream* s = t->incoming_stream;\n  if (grpc_http_trace.enabled()) {\n    gpr_log(GPR_DEBUG,\n            \"INCOMING[%p;%p]: Parse %\" PRIdPTR \"b %sframe fragment with %s\", t,\n            s, GRPC_SLICE_LENGTH(slice), is_last ? \"last \" : \"\",\n            t->parser.name);\n  }\n  grpc_error_handle err =\n      t->parser.parser(t->parser.user_data, t, s, slice, is_last);\n  intptr_t unused;\n  if (GPR_LIKELY(err.ok())) {\n    return err;\n  }\n  if (grpc_http_trace.enabled()) {\n    gpr_log(GPR_ERROR, \"INCOMING[%p;%p]: Parse failed with %s\", t, s,\n            err.ToString().c_str());\n  }\n  if (grpc_error_get_int(err, grpc_core::StatusIntProperty::kStreamId,\n                         &unused)) {\n    grpc_chttp2_parsing_become_skip_parser(t);\n    if (s) {\n      grpc_chttp2_cancel_stream(t, s, std::exchange(err, absl::OkStatus()));\n    }\n  }\n  return err;\n}",
  "abstract_func": "static grpc_error_handle parse_frame_slice(grpc_chttp2_transport* VAR_0,\n                                           const grpc_slice& VAR_1,\n                                           int VAR_2) {\n  grpc_chttp2_stream* VAR_3 = VAR_0->incoming_stream;\n  if (VAR_4.enabled()) {\n    gpr_log(VAR_5,\n            \"INCOMING[%p;%p]: Parse %\" VAR_6 \"b %sframe fragment with %s\", VAR_0,\n            VAR_3, GRPC_SLICE_LENGTH(VAR_1), VAR_2 ? \"last \" : \"\",\n            VAR_0->parser.name);\n  }\n  grpc_error_handle VAR_7 =\n      VAR_0->parser.parser(VAR_0->parser.user_data, VAR_0, VAR_3, VAR_1, VAR_2);\n  intptr_t VAR_8;\n  if (GPR_LIKELY(VAR_7.ok())) {\n    return VAR_7;\n  }\n  if (VAR_4.enabled()) {\n    gpr_log(VAR_9, \"INCOMING[%p;%p]: Parse failed with %s\", VAR_0, VAR_3,\n            VAR_7.ToString().c_str());\n  }\n  if (grpc_error_get_int(VAR_7, grpc_core::StatusIntProperty::kStreamId,\n                         &VAR_8)) {\n    grpc_chttp2_parsing_become_skip_parser(VAR_0);\n    if (VAR_3) {\n      grpc_chttp2_cancel_stream(VAR_0, VAR_3, std::exchange(VAR_7, absl::OkStatus()));\n    }\n  }\n  return VAR_7;\n}",
  "func_graph_path": "grpc/6a7850ef4f042ac26559854266dddc79bfbc75b2/parsing.cc/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -22,10 +22,7 @@\n                          &unused)) {\n     grpc_chttp2_parsing_become_skip_parser(t);\n     if (s) {\n-      s->forced_close_error = err;\n-      grpc_chttp2_add_rst_stream_to_next_write(t, t->incoming_stream_id,\n-                                               GRPC_HTTP2_PROTOCOL_ERROR,\n-                                               &s->stats.outgoing);\n+      grpc_chttp2_cancel_stream(t, s, std::exchange(err, absl::OkStatus()));\n     }\n   }\n   return err;",
  "diff_line_info": {
    "deleted_lines": [
      "      s->forced_close_error = err;",
      "      grpc_chttp2_add_rst_stream_to_next_write(t, t->incoming_stream_id,",
      "                                               GRPC_HTTP2_PROTOCOL_ERROR,",
      "                                               &s->stats.outgoing);"
    ],
    "added_lines": [
      "      grpc_chttp2_cancel_stream(t, s, std::exchange(err, absl::OkStatus()));"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/grpc/grpc/pull/32309",
  "description": {
    "pr_info": {
      "title": "[http2] Dont drop connections on metadata limit exceeded",
      "number": 32309
    },
    "comment": [
      "If we get an error on a stream, all we need to do is cancel that stream.\r\nIf instead we get an error not associated with a stream, we should close the transport.\r\n\r\nCurrent behavior was to just close the transport always, and this was a bad bug.\r\n\r\n<!--\r\n\r\nIf you know who should review your pull request, please assign it to that\r\nperson, otherwise the pull request would get assigned randomly.\r\n\r\nIf your pull request is for a specific language, please add the appropriate\r\nlang label.\r\n\r\n-->\r\n\r\n",
      "@ctiller Hi.  \r\nI want to know if this PR can fix CVE-2023-32732/CVE-2023-32731?",
      "If CVE-2023-32732/CVE-2023-32731 can be fixed by this PR, I would like to know which commit introduced this issue.",
      "Folks coming here for CVE-2023-32731: An error was made in the original CVE text; this change introduced the bug.\r\nThe fix is at https://github.com/grpc/grpc/pull/33005.\r\n\r\nWe're in the process of updating the CVE text.",
      "Thanks! Is CVE-2023-32732 also fixed by #33005?",
      "One more question, does this PR #32309 introduce CVE-2023-32731 and CVE-2023-32732?",
      "Correct on both.",
      "Okay. Thanks!",
      "@ctiller Sorry, but I'm a little confused. \r\nhttps://nvd.nist.gov/vuln/detail/CVE-2023-32732 says:\r\n\"\"\"\r\nWe recommend upgrading beyond the commit in  https://github.com/grpc/grpc/pull/32309\r\n\"\"\"\r\nBut looking at the above comments, it seems that PR#32309 is not a fix, instead, it's the cause of CVE-2023-32732.\r\n\r\nWhich one is correct?"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.9"
}