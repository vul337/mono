{
  "cve_id": "CVE-2021-37616",
  "cwe_ids": [
    "CWE-476"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "Exiv2/exiv2",
  "commit_msg": "Check that findKey didn't return end().",
  "commit_hash": "3ac426b2c04004422c290425259082281e090116",
  "git_url": "https://github.com/Exiv2/exiv2/commit/3ac426b2c04004422c290425259082281e090116",
  "file_path": "src/convert.cpp",
  "func_name": "Converter::cnvExifDate",
  "func_before": "void Converter::cnvExifDate(const char* from, const char* to)\n    {\n        Exiv2::ExifData::iterator pos = exifData_->findKey(ExifKey(from));\n        if (pos == exifData_->end()) return;\n        if (!prepareXmpTarget(to)) return;\n        int year=0, month=0, day=0, hour=0, min=0, sec=0;\n        std::string subsec;\n        char buf[30];\n\n        if (std::string(from) != \"Exif.GPSInfo.GPSTimeStamp\") {\n            std::string value = pos->toString();\n            if (!pos->value().ok()) {\n#ifndef SUPPRESS_WARNINGS\n                EXV_WARNING << \"Failed to convert \" << from << \" to \" << to << \"\\n\";\n#endif\n                return;\n            }\n            if (sscanf(value.c_str(), \"%d:%d:%d %d:%d:%d\", &year, &month, &day, &hour, &min, &sec) != 6) {\n#ifndef SUPPRESS_WARNINGS\n                EXV_WARNING << \"Failed to convert \" << from << \" to \" << to\n                            << \", unable to parse '\" << value << \"'\\n\";\n#endif\n                return;\n            }\n        }\n        else { // \"Exif.GPSInfo.GPSTimeStamp\"\n\n            bool ok = true;\n            if (pos->count() != 3) ok = false;\n            if (ok) {\n                for (int i = 0; i < 3; ++i) {\n                    if (pos->toRational(i).second == 0) {\n                        ok = false;\n                        break;\n                    }\n                }\n            }\n            if (!ok) {\n#ifndef SUPPRESS_WARNINGS\n                EXV_WARNING << \"Failed to convert \" << from << \" to \" << to << \"\\n\";\n#endif\n                return;\n            }\n\n            double dhour = pos->toFloat(0);\n            double dmin = pos->toFloat(1);\n            // Hack: Need Value::toDouble\n            Rational r = pos->toRational(2);\n            double dsec = static_cast<double>(r.first)/r.second;\n\n            if (!pos->value().ok()) {\n#ifndef SUPPRESS_WARNINGS\n                EXV_WARNING << \"Failed to convert \" << from << \" to \" << to << \"\\n\";\n#endif\n                return;\n            }\n\n            dsec = dhour * 3600.0 + dmin * 60.0 + dsec;\n\n            hour = static_cast<int>(dsec / 3600.0);\n            dsec -= hour * 3600;\n            min = static_cast<int>(dsec / 60.0);\n            dsec -= min * 60;\n            sec = static_cast<int>(dsec);\n            dsec -= sec;\n\n            snprintf(buf, sizeof(buf), \"%.9f\", dsec);\n            buf[sizeof(buf) - 1] = 0;\n            buf[1] = '.'; // some locales use ','\n            subsec = buf + 1;\n\n            Exiv2::ExifData::iterator datePos = exifData_->findKey(ExifKey(\"Exif.GPSInfo.GPSDateStamp\"));\n            if (datePos == exifData_->end()) {\n                datePos = exifData_->findKey(ExifKey(\"Exif.Photo.DateTimeOriginal\"));\n            }\n            if (datePos == exifData_->end()) {\n                datePos = exifData_->findKey(ExifKey(\"Exif.Photo.DateTimeDigitized\"));\n            }\n            if (datePos == exifData_->end()) {\n#ifndef SUPPRESS_WARNINGS\n                EXV_WARNING << \"Failed to convert \" << from << \" to \" << to << \"\\n\";\n#endif\n                return;\n            }\n            std::string value = datePos->toString();\n            if (sscanf(value.c_str(), \"%d:%d:%d\", &year, &month, &day) != 3) {\n#ifndef SUPPRESS_WARNINGS\n                EXV_WARNING << \"Failed to convert \" << from << \" to \" << to\n                            << \", unable to parse '\" << value << \"'\\n\";\n#endif\n                return;\n            }\n        }\n\n        const char* subsecTag = 0;\n        if (std::string(from) == \"Exif.Image.DateTime\") {\n            subsecTag = \"Exif.Photo.SubSecTime\";\n        }\n        else if (std::string(from) == \"Exif.Photo.DateTimeOriginal\") {\n            subsecTag = \"Exif.Photo.SubSecTimeOriginal\";\n        }\n        else if (std::string(from) == \"Exif.Photo.DateTimeDigitized\") {\n            subsecTag = \"Exif.Photo.SubSecTimeDigitized\";\n        }\n\n        if (subsecTag) {\n            ExifData::iterator subsec_pos = exifData_->findKey(ExifKey(subsecTag));\n            if (   subsec_pos != exifData_->end()\n                && subsec_pos->typeId() == asciiString) {\n                std::string ss = subsec_pos->toString();\n                if (!ss.empty()) {\n                    bool ok = false;\n                    stringTo<long>(ss, ok);\n                    if (ok) subsec = std::string(\".\") + ss;\n                }\n            }\n            if (erase_) exifData_->erase(subsec_pos);\n        }\n\n        if (subsec.size() > 10) subsec = subsec.substr(0, 10);\n        snprintf(buf, sizeof(buf), \"%4d-%02d-%02dT%02d:%02d:%02d%s\",\n                 year, month, day, hour, min, sec, subsec.c_str());\n        buf[sizeof(buf) - 1] = 0;\n\n        (*xmpData_)[to] = buf;\n        if (erase_) exifData_->erase(pos);\n    }",
  "abstract_func_before": "void Converter::cnvExifDate(const char* VAR_0, const char* VAR_1)\n    {\n        Exiv2::ExifData::iterator VAR_2 = VAR_3->findKey(ExifKey(VAR_0));\n        if (VAR_2 == VAR_3->end()) return;\n        if (!prepareXmpTarget(VAR_1)) return;\n        int VAR_4=0, VAR_5=0, VAR_6=0, VAR_7=0, VAR_8=0, VAR_9=0;\n        std::string VAR_10;\n        char VAR_11[30];\n\n        if (std::string(VAR_0) != \"Exif.GPSInfo.GPSTimeStamp\") {\n            std::string VAR_12 = VAR_2->toString();\n            if (!VAR_2->value().ok()) {\n#ifndef VAR_13\n                VAR_14 << \"Failed to convert \" << VAR_0 << \" to \" << VAR_1 << \"\\n\";\n#endif\n                return;\n            }\n            if (sscanf(VAR_12.c_str(), \"%d:%d:%d %d:%d:%d\", &VAR_4, &VAR_5, &VAR_6, &VAR_7, &VAR_8, &VAR_9) != 6) {\n#ifndef VAR_13\n                VAR_14 << \"Failed to convert \" << VAR_0 << \" to \" << VAR_1\n                            << \", unable to parse '\" << VAR_12 << \"'\\n\";\n#endif\n                return;\n            }\n        }\n        else { /* COMMENT_0 */\n\n            bool VAR_15 = true;\n            if (VAR_2->count() != 3) VAR_15 = false;\n            if (VAR_15) {\n                for (int VAR_16 = 0; VAR_16 < 3; ++VAR_16) {\n                    if (VAR_2->toRational(VAR_16).second == 0) {\n                        VAR_15 = false;\n                        break;\n                    }\n                }\n            }\n            if (!VAR_15) {\n#ifndef VAR_13\n                VAR_14 << \"Failed to convert \" << VAR_0 << \" to \" << VAR_1 << \"\\n\";\n#endif\n                return;\n            }\n\n            double VAR_17 = VAR_2->toFloat(0);\n            double VAR_18 = VAR_2->toFloat(1);\n            /* COMMENT_1 */\n            Rational VAR_19 = VAR_2->toRational(2);\n            double VAR_20 = VAR_21<double>(VAR_19.first)/VAR_19.second;\n\n            if (!VAR_2->value().ok()) {\n#ifndef VAR_13\n                VAR_14 << \"Failed to convert \" << VAR_0 << \" to \" << VAR_1 << \"\\n\";\n#endif\n                return;\n            }\n\n            VAR_20 = VAR_17 * 3600.0 + VAR_18 * 60.0 + VAR_20;\n\n            VAR_7 = VAR_21<int>(VAR_20 / 3600.0);\n            VAR_20 -= VAR_7 * 3600;\n            VAR_8 = VAR_21<int>(VAR_20 / 60.0);\n            VAR_20 -= VAR_8 * 60;\n            VAR_9 = VAR_21<int>(VAR_20);\n            VAR_20 -= VAR_9;\n\n            snprintf(VAR_11, sizeof(VAR_11), \"%.9f\", VAR_20);\n            VAR_11[sizeof(VAR_11) - 1] = 0;\n            VAR_11[1] = '.'; /* COMMENT_2 */\n            VAR_10 = VAR_11 + 1;\n\n            Exiv2::ExifData::iterator VAR_22 = VAR_3->findKey(ExifKey(\"Exif.GPSInfo.GPSDateStamp\"));\n            if (VAR_22 == VAR_3->end()) {\n                VAR_22 = VAR_3->findKey(ExifKey(\"Exif.Photo.DateTimeOriginal\"));\n            }\n            if (VAR_22 == VAR_3->end()) {\n                VAR_22 = VAR_3->findKey(ExifKey(\"Exif.Photo.DateTimeDigitized\"));\n            }\n            if (VAR_22 == VAR_3->end()) {\n#ifndef VAR_13\n                VAR_14 << \"Failed to convert \" << VAR_0 << \" to \" << VAR_1 << \"\\n\";\n#endif\n                return;\n            }\n            std::string VAR_12 = VAR_22->toString();\n            if (sscanf(VAR_12.c_str(), \"%d:%d:%d\", &VAR_4, &VAR_5, &VAR_6) != 3) {\n#ifndef VAR_13\n                VAR_14 << \"Failed to convert \" << VAR_0 << \" to \" << VAR_1\n                            << \", unable to parse '\" << VAR_12 << \"'\\n\";\n#endif\n                return;\n            }\n        }\n\n        const char* VAR_23 = 0;\n        if (std::string(VAR_0) == \"Exif.Image.DateTime\") {\n            VAR_23 = \"Exif.Photo.SubSecTime\";\n        }\n        else if (std::string(VAR_0) == \"Exif.Photo.DateTimeOriginal\") {\n            VAR_23 = \"Exif.Photo.SubSecTimeOriginal\";\n        }\n        else if (std::string(VAR_0) == \"Exif.Photo.DateTimeDigitized\") {\n            VAR_23 = \"Exif.Photo.SubSecTimeDigitized\";\n        }\n\n        if (VAR_23) {\n            ExifData::iterator VAR_24 = VAR_3->findKey(ExifKey(VAR_23));\n            if (   VAR_24 != VAR_3->end()\n                && VAR_24->typeId() == VAR_25) {\n                std::string VAR_26 = VAR_24->toString();\n                if (!VAR_26.empty()) {\n                    bool VAR_15 = false;\n                    VAR_27<long>(VAR_26, VAR_15);\n                    if (VAR_15) VAR_10 = std::string(\".\") + VAR_26;\n                }\n            }\n            if (VAR_28) VAR_3->erase(VAR_24);\n        }\n\n        if (VAR_10.size() > 10) VAR_10 = VAR_10.substr(0, 10);\n        snprintf(VAR_11, sizeof(VAR_11), \"%4d-%02d-%02dT%02d:%02d:%02d%s\",\n                 VAR_4, VAR_5, VAR_6, VAR_7, VAR_8, VAR_9, VAR_10.c_str());\n        VAR_11[sizeof(VAR_11) - 1] = 0;\n\n        (*VAR_29)[VAR_1] = VAR_11;\n        if (VAR_28) VAR_3->erase(VAR_2);\n    }",
  "func_graph_path_before": "Exiv2/exiv2/3ac426b2c04004422c290425259082281e090116/convert.cpp/vul/before/0.json",
  "func": "void Converter::cnvExifDate(const char* from, const char* to)\n    {\n        Exiv2::ExifData::iterator pos = exifData_->findKey(ExifKey(from));\n        if (pos == exifData_->end()) return;\n        if (!prepareXmpTarget(to)) return;\n        int year=0, month=0, day=0, hour=0, min=0, sec=0;\n        std::string subsec;\n        char buf[30];\n\n        if (std::string(from) != \"Exif.GPSInfo.GPSTimeStamp\") {\n            std::string value = pos->toString();\n            if (!pos->value().ok()) {\n#ifndef SUPPRESS_WARNINGS\n                EXV_WARNING << \"Failed to convert \" << from << \" to \" << to << \"\\n\";\n#endif\n                return;\n            }\n            if (sscanf(value.c_str(), \"%d:%d:%d %d:%d:%d\", &year, &month, &day, &hour, &min, &sec) != 6) {\n#ifndef SUPPRESS_WARNINGS\n                EXV_WARNING << \"Failed to convert \" << from << \" to \" << to\n                            << \", unable to parse '\" << value << \"'\\n\";\n#endif\n                return;\n            }\n        }\n        else { // \"Exif.GPSInfo.GPSTimeStamp\"\n\n            bool ok = true;\n            if (pos->count() != 3) ok = false;\n            if (ok) {\n                for (int i = 0; i < 3; ++i) {\n                    if (pos->toRational(i).second == 0) {\n                        ok = false;\n                        break;\n                    }\n                }\n            }\n            if (!ok) {\n#ifndef SUPPRESS_WARNINGS\n                EXV_WARNING << \"Failed to convert \" << from << \" to \" << to << \"\\n\";\n#endif\n                return;\n            }\n\n            double dhour = pos->toFloat(0);\n            double dmin = pos->toFloat(1);\n            // Hack: Need Value::toDouble\n            Rational r = pos->toRational(2);\n            double dsec = static_cast<double>(r.first)/r.second;\n\n            if (!pos->value().ok()) {\n#ifndef SUPPRESS_WARNINGS\n                EXV_WARNING << \"Failed to convert \" << from << \" to \" << to << \"\\n\";\n#endif\n                return;\n            }\n\n            dsec = dhour * 3600.0 + dmin * 60.0 + dsec;\n\n            hour = static_cast<int>(dsec / 3600.0);\n            dsec -= hour * 3600;\n            min = static_cast<int>(dsec / 60.0);\n            dsec -= min * 60;\n            sec = static_cast<int>(dsec);\n            dsec -= sec;\n\n            snprintf(buf, sizeof(buf), \"%.9f\", dsec);\n            buf[sizeof(buf) - 1] = 0;\n            buf[1] = '.'; // some locales use ','\n            subsec = buf + 1;\n\n            Exiv2::ExifData::iterator datePos = exifData_->findKey(ExifKey(\"Exif.GPSInfo.GPSDateStamp\"));\n            if (datePos == exifData_->end()) {\n                datePos = exifData_->findKey(ExifKey(\"Exif.Photo.DateTimeOriginal\"));\n            }\n            if (datePos == exifData_->end()) {\n                datePos = exifData_->findKey(ExifKey(\"Exif.Photo.DateTimeDigitized\"));\n            }\n            if (datePos == exifData_->end()) {\n#ifndef SUPPRESS_WARNINGS\n                EXV_WARNING << \"Failed to convert \" << from << \" to \" << to << \"\\n\";\n#endif\n                return;\n            }\n            std::string value = datePos->toString();\n            if (sscanf(value.c_str(), \"%d:%d:%d\", &year, &month, &day) != 3) {\n#ifndef SUPPRESS_WARNINGS\n                EXV_WARNING << \"Failed to convert \" << from << \" to \" << to\n                            << \", unable to parse '\" << value << \"'\\n\";\n#endif\n                return;\n            }\n        }\n\n        const char* subsecTag = 0;\n        if (std::string(from) == \"Exif.Image.DateTime\") {\n            subsecTag = \"Exif.Photo.SubSecTime\";\n        }\n        else if (std::string(from) == \"Exif.Photo.DateTimeOriginal\") {\n            subsecTag = \"Exif.Photo.SubSecTimeOriginal\";\n        }\n        else if (std::string(from) == \"Exif.Photo.DateTimeDigitized\") {\n            subsecTag = \"Exif.Photo.SubSecTimeDigitized\";\n        }\n\n        if (subsecTag) {\n            ExifData::iterator subsec_pos = exifData_->findKey(ExifKey(subsecTag));\n            if (subsec_pos != exifData_->end()) {\n                if (subsec_pos->typeId() == asciiString) {\n                    std::string ss = subsec_pos->toString();\n                    if (!ss.empty()) {\n                        bool ok = false;\n                        stringTo<long>(ss, ok);\n                        if (ok) subsec = std::string(\".\") + ss;\n                    }\n                }\n                if (erase_) exifData_->erase(subsec_pos);\n            }\n        }\n\n        if (subsec.size() > 10) subsec = subsec.substr(0, 10);\n        snprintf(buf, sizeof(buf), \"%4d-%02d-%02dT%02d:%02d:%02d%s\",\n                 year, month, day, hour, min, sec, subsec.c_str());\n        buf[sizeof(buf) - 1] = 0;\n\n        (*xmpData_)[to] = buf;\n        if (erase_) exifData_->erase(pos);\n    }",
  "abstract_func": "void Converter::cnvExifDate(const char* VAR_0, const char* VAR_1)\n    {\n        Exiv2::ExifData::iterator VAR_2 = VAR_3->findKey(ExifKey(VAR_0));\n        if (VAR_2 == VAR_3->end()) return;\n        if (!prepareXmpTarget(VAR_1)) return;\n        int VAR_4=0, VAR_5=0, VAR_6=0, VAR_7=0, VAR_8=0, VAR_9=0;\n        std::string VAR_10;\n        char VAR_11[30];\n\n        if (std::string(VAR_0) != \"Exif.GPSInfo.GPSTimeStamp\") {\n            std::string VAR_12 = VAR_2->toString();\n            if (!VAR_2->value().ok()) {\n#ifndef VAR_13\n                VAR_14 << \"Failed to convert \" << VAR_0 << \" to \" << VAR_1 << \"\\n\";\n#endif\n                return;\n            }\n            if (sscanf(VAR_12.c_str(), \"%d:%d:%d %d:%d:%d\", &VAR_4, &VAR_5, &VAR_6, &VAR_7, &VAR_8, &VAR_9) != 6) {\n#ifndef VAR_13\n                VAR_14 << \"Failed to convert \" << VAR_0 << \" to \" << VAR_1\n                            << \", unable to parse '\" << VAR_12 << \"'\\n\";\n#endif\n                return;\n            }\n        }\n        else { /* COMMENT_0 */\n\n            bool VAR_15 = true;\n            if (VAR_2->count() != 3) VAR_15 = false;\n            if (VAR_15) {\n                for (int VAR_16 = 0; VAR_16 < 3; ++VAR_16) {\n                    if (VAR_2->toRational(VAR_16).second == 0) {\n                        VAR_15 = false;\n                        break;\n                    }\n                }\n            }\n            if (!VAR_15) {\n#ifndef VAR_13\n                VAR_14 << \"Failed to convert \" << VAR_0 << \" to \" << VAR_1 << \"\\n\";\n#endif\n                return;\n            }\n\n            double VAR_17 = VAR_2->toFloat(0);\n            double VAR_18 = VAR_2->toFloat(1);\n            /* COMMENT_1 */\n            Rational VAR_19 = VAR_2->toRational(2);\n            double VAR_20 = VAR_21<double>(VAR_19.first)/VAR_19.second;\n\n            if (!VAR_2->value().ok()) {\n#ifndef VAR_13\n                VAR_14 << \"Failed to convert \" << VAR_0 << \" to \" << VAR_1 << \"\\n\";\n#endif\n                return;\n            }\n\n            VAR_20 = VAR_17 * 3600.0 + VAR_18 * 60.0 + VAR_20;\n\n            VAR_7 = VAR_21<int>(VAR_20 / 3600.0);\n            VAR_20 -= VAR_7 * 3600;\n            VAR_8 = VAR_21<int>(VAR_20 / 60.0);\n            VAR_20 -= VAR_8 * 60;\n            VAR_9 = VAR_21<int>(VAR_20);\n            VAR_20 -= VAR_9;\n\n            snprintf(VAR_11, sizeof(VAR_11), \"%.9f\", VAR_20);\n            VAR_11[sizeof(VAR_11) - 1] = 0;\n            VAR_11[1] = '.'; /* COMMENT_2 */\n            VAR_10 = VAR_11 + 1;\n\n            Exiv2::ExifData::iterator VAR_22 = VAR_3->findKey(ExifKey(\"Exif.GPSInfo.GPSDateStamp\"));\n            if (VAR_22 == VAR_3->end()) {\n                VAR_22 = VAR_3->findKey(ExifKey(\"Exif.Photo.DateTimeOriginal\"));\n            }\n            if (VAR_22 == VAR_3->end()) {\n                VAR_22 = VAR_3->findKey(ExifKey(\"Exif.Photo.DateTimeDigitized\"));\n            }\n            if (VAR_22 == VAR_3->end()) {\n#ifndef VAR_13\n                VAR_14 << \"Failed to convert \" << VAR_0 << \" to \" << VAR_1 << \"\\n\";\n#endif\n                return;\n            }\n            std::string VAR_12 = VAR_22->toString();\n            if (sscanf(VAR_12.c_str(), \"%d:%d:%d\", &VAR_4, &VAR_5, &VAR_6) != 3) {\n#ifndef VAR_13\n                VAR_14 << \"Failed to convert \" << VAR_0 << \" to \" << VAR_1\n                            << \", unable to parse '\" << VAR_12 << \"'\\n\";\n#endif\n                return;\n            }\n        }\n\n        const char* VAR_23 = 0;\n        if (std::string(VAR_0) == \"Exif.Image.DateTime\") {\n            VAR_23 = \"Exif.Photo.SubSecTime\";\n        }\n        else if (std::string(VAR_0) == \"Exif.Photo.DateTimeOriginal\") {\n            VAR_23 = \"Exif.Photo.SubSecTimeOriginal\";\n        }\n        else if (std::string(VAR_0) == \"Exif.Photo.DateTimeDigitized\") {\n            VAR_23 = \"Exif.Photo.SubSecTimeDigitized\";\n        }\n\n        if (VAR_23) {\n            ExifData::iterator VAR_24 = VAR_3->findKey(ExifKey(VAR_23));\n            if (VAR_24 != VAR_3->end()) {\n                if (VAR_24->typeId() == VAR_25) {\n                    std::string VAR_26 = VAR_24->toString();\n                    if (!VAR_26.empty()) {\n                        bool VAR_15 = false;\n                        VAR_27<long>(VAR_26, VAR_15);\n                        if (VAR_15) VAR_10 = std::string(\".\") + VAR_26;\n                    }\n                }\n                if (VAR_28) VAR_3->erase(VAR_24);\n            }\n        }\n\n        if (VAR_10.size() > 10) VAR_10 = VAR_10.substr(0, 10);\n        snprintf(VAR_11, sizeof(VAR_11), \"%4d-%02d-%02dT%02d:%02d:%02d%s\",\n                 VAR_4, VAR_5, VAR_6, VAR_7, VAR_8, VAR_9, VAR_10.c_str());\n        VAR_11[sizeof(VAR_11) - 1] = 0;\n\n        (*VAR_29)[VAR_1] = VAR_11;\n        if (VAR_28) VAR_3->erase(VAR_2);\n    }",
  "func_graph_path": "Exiv2/exiv2/3ac426b2c04004422c290425259082281e090116/convert.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -105,16 +105,17 @@\n \n         if (subsecTag) {\n             ExifData::iterator subsec_pos = exifData_->findKey(ExifKey(subsecTag));\n-            if (   subsec_pos != exifData_->end()\n-                && subsec_pos->typeId() == asciiString) {\n-                std::string ss = subsec_pos->toString();\n-                if (!ss.empty()) {\n-                    bool ok = false;\n-                    stringTo<long>(ss, ok);\n-                    if (ok) subsec = std::string(\".\") + ss;\n+            if (subsec_pos != exifData_->end()) {\n+                if (subsec_pos->typeId() == asciiString) {\n+                    std::string ss = subsec_pos->toString();\n+                    if (!ss.empty()) {\n+                        bool ok = false;\n+                        stringTo<long>(ss, ok);\n+                        if (ok) subsec = std::string(\".\") + ss;\n+                    }\n                 }\n+                if (erase_) exifData_->erase(subsec_pos);\n             }\n-            if (erase_) exifData_->erase(subsec_pos);\n         }\n \n         if (subsec.size() > 10) subsec = subsec.substr(0, 10);",
  "diff_line_info": {
    "deleted_lines": [
      "            if (   subsec_pos != exifData_->end()",
      "                && subsec_pos->typeId() == asciiString) {",
      "                std::string ss = subsec_pos->toString();",
      "                if (!ss.empty()) {",
      "                    bool ok = false;",
      "                    stringTo<long>(ss, ok);",
      "                    if (ok) subsec = std::string(\".\") + ss;",
      "            if (erase_) exifData_->erase(subsec_pos);"
    ],
    "added_lines": [
      "            if (subsec_pos != exifData_->end()) {",
      "                if (subsec_pos->typeId() == asciiString) {",
      "                    std::string ss = subsec_pos->toString();",
      "                    if (!ss.empty()) {",
      "                        bool ok = false;",
      "                        stringTo<long>(ss, ok);",
      "                        if (ok) subsec = std::string(\".\") + ss;",
      "                    }",
      "                if (erase_) exifData_->erase(subsec_pos);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/sridharb1/exiv2/pull/4",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/sridharb1/exiv2/pull/4: 403 Client Error: Forbidden for url: https://api.github.com/repos/sridharb1/exiv2/pulls/4",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades;  \n**Confidence:** 0.9"
}