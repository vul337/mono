{
  "cve_id": "CVE-2021-3521",
  "cwe_ids": [
    "CWE-347"
  ],
  "cvss_vector": "CVSS:3.1/AV:L/AC:H/PR:N/UI:R/S:U/C:N/I:H/A:N",
  "cvss_is_v3": true,
  "repo_name": "rpm-software-management/rpm",
  "commit_msg": "Validate and require subkey binding signatures on PGP public keys\n\nAll subkeys must be followed by a binding signature by the primary key\nas per the OpenPGP RFC, enforce the presence and validity in the parser.\n\nThe implementation is as kludgey as they come to work around our\nsimple-minded parser structure without touching API, to maximise\nbackportability. Store all the raw packets internally as we decode them\nto be able to access previous elements at will, needed to validate ordering\nand access the actual data. Add testcases for manipulated keys whose\nimport previously would succeed.\n\nDepends on the two previous commits:\n7b399fcb8f52566e6f3b4327197a85facd08db91 and\n236b802a4aa48711823a191d1b7f753c82a89ec5\n\nFixes CVE-2021-3521.",
  "commit_hash": "bd36c5dc9fb6d90c46fbfed8c2d67516fc571ec8",
  "git_url": "https://github.com/rpm-software-management/rpm/commit/bd36c5dc9fb6d90c46fbfed8c2d67516fc571ec8",
  "file_path": "rpmio/rpmpgp.c",
  "func_name": "pgpPrtParams",
  "func_before": "int pgpPrtParams(const uint8_t * pkts, size_t pktlen, unsigned int pkttype,\n\t\t pgpDigParams * ret)\n{\n    const uint8_t *p = pkts;\n    const uint8_t *pend = pkts + pktlen;\n    pgpDigParams digp = NULL;\n    struct pgpPkt pkt;\n    int rc = -1; /* assume failure */\n\n    while (p < pend) {\n\tif (decodePkt(p, (pend - p), &pkt))\n\t    break;\n\n\tif (digp == NULL) {\n\t    if (pkttype && pkt.tag != pkttype) {\n\t\tbreak;\n\t    } else {\n\t\tdigp = pgpDigParamsNew(pkt.tag);\n\t    }\n\t}\n\n\tif (pgpPrtPkt(&pkt, digp))\n\t    break;\n\n\tp += (pkt.body - pkt.head) + pkt.blen;\n\tif (pkttype == PGPTAG_SIGNATURE)\n\t    break;\n    }\n\n    rc = (digp && (p == pend)) ? 0 : -1;\n\n    if (ret && rc == 0) {\n\t*ret = digp;\n    } else {\n\tpgpDigParamsFree(digp);\n    }\n    return rc;\n}",
  "abstract_func_before": "int pgpPrtParams(const uint8_t * VAR_0, size_t VAR_1, unsigned int VAR_2,\n\t\t pgpDigParams * VAR_3)\n{\n    const uint8_t *VAR_4 = VAR_0;\n    const uint8_t *VAR_5 = VAR_0 + VAR_1;\n    pgpDigParams VAR_6 = NULL;\n    struct pgpPkt VAR_7;\n    int VAR_8 = -1; /* COMMENT_0 */\n\n    while (VAR_4 < VAR_5) {\n\tif (decodePkt(VAR_4, (VAR_5 - VAR_4), &VAR_7))\n\t    break;\n\n\tif (VAR_6 == NULL) {\n\t    if (VAR_2 && VAR_7.tag != VAR_2) {\n\t\tbreak;\n\t    } else {\n\t\tVAR_6 = pgpDigParamsNew(VAR_7.tag);\n\t    }\n\t}\n\n\tif (pgpPrtPkt(&VAR_7, VAR_6))\n\t    break;\n\n\tVAR_4 += (VAR_7.body - VAR_7.head) + VAR_7.blen;\n\tif (VAR_2 == VAR_9)\n\t    break;\n    }\n\n    VAR_8 = (VAR_6 && (VAR_4 == VAR_5)) ? 0 : -1;\n\n    if (VAR_3 && VAR_8 == 0) {\n\t*VAR_3 = VAR_6;\n    } else {\n\tpgpDigParamsFree(VAR_6);\n    }\n    return VAR_8;\n}",
  "func_graph_path_before": "rpm-software-management/rpm/bd36c5dc9fb6d90c46fbfed8c2d67516fc571ec8/rpmpgp.c/vul/before/0.json",
  "func": "int pgpPrtParams(const uint8_t * pkts, size_t pktlen, unsigned int pkttype,\n\t\t pgpDigParams * ret)\n{\n    const uint8_t *p = pkts;\n    const uint8_t *pend = pkts + pktlen;\n    pgpDigParams digp = NULL;\n    pgpDigParams selfsig = NULL;\n    int i = 0;\n    int alloced = 16; /* plenty for normal cases */\n    struct pgpPkt *all = xmalloc(alloced * sizeof(*all));\n    int rc = -1; /* assume failure */\n    int expect = 0;\n    int prevtag = 0;\n\n    while (p < pend) {\n\tstruct pgpPkt *pkt = &all[i];\n\tif (decodePkt(p, (pend - p), pkt))\n\t    break;\n\n\tif (digp == NULL) {\n\t    if (pkttype && pkt->tag != pkttype) {\n\t\tbreak;\n\t    } else {\n\t\tdigp = pgpDigParamsNew(pkt->tag);\n\t    }\n\t}\n\n\tif (expect) {\n\t    if (pkt->tag != expect)\n\t\tbreak;\n\t    selfsig = pgpDigParamsNew(pkt->tag);\n\t}\n\n\tif (pgpPrtPkt(pkt, selfsig ? selfsig : digp))\n\t    break;\n\n\tif (selfsig) {\n\t    /* subkeys must be followed by binding signature */\n\t    if (prevtag == PGPTAG_PUBLIC_SUBKEY) {\n\t\tif (selfsig->sigtype != PGPSIGTYPE_SUBKEY_BINDING)\n\t\t    break;\n\t    }\n\n\t    int xx = pgpVerifySelf(digp, selfsig, all, i);\n\n\t    selfsig = pgpDigParamsFree(selfsig);\n\t    if (xx)\n\t\tbreak;\n\t    expect = 0;\n\t}\n\n\tif (pkt->tag == PGPTAG_PUBLIC_SUBKEY)\n\t    expect = PGPTAG_SIGNATURE;\n\tprevtag = pkt->tag;\n\n\ti++;\n\tp += (pkt->body - pkt->head) + pkt->blen;\n\tif (pkttype == PGPTAG_SIGNATURE)\n\t    break;\n\n\tif (alloced <= i) {\n\t    alloced *= 2;\n\t    all = xrealloc(all, alloced * sizeof(*all));\n\t}\n    }\n\n    rc = (digp && (p == pend) && expect == 0) ? 0 : -1;\n\n    free(all);\n    if (ret && rc == 0) {\n\t*ret = digp;\n    } else {\n\tpgpDigParamsFree(digp);\n    }\n    return rc;\n}",
  "abstract_func": "int pgpPrtParams(const uint8_t * VAR_0, size_t VAR_1, unsigned int VAR_2,\n\t\t pgpDigParams * VAR_3)\n{\n    const uint8_t *VAR_4 = VAR_0;\n    const uint8_t *VAR_5 = VAR_0 + VAR_1;\n    pgpDigParams VAR_6 = NULL;\n    pgpDigParams VAR_7 = NULL;\n    int VAR_8 = 0;\n    int VAR_9 = 16; /* COMMENT_0 */\n    struct pgpPkt *VAR_10 = xmalloc(VAR_9 * sizeof(*VAR_10));\n    int VAR_11 = -1; /* COMMENT_1 */\n    int VAR_12 = 0;\n    int VAR_13 = 0;\n\n    while (VAR_4 < VAR_5) {\n\tstruct pgpPkt *VAR_14 = &VAR_10[VAR_8];\n\tif (decodePkt(VAR_4, (VAR_5 - VAR_4), VAR_14))\n\t    break;\n\n\tif (VAR_6 == NULL) {\n\t    if (VAR_2 && VAR_14->tag != VAR_2) {\n\t\tbreak;\n\t    } else {\n\t\tVAR_6 = pgpDigParamsNew(VAR_14->tag);\n\t    }\n\t}\n\n\tif (VAR_12) {\n\t    if (VAR_14->tag != VAR_12)\n\t\tbreak;\n\t    VAR_7 = pgpDigParamsNew(VAR_14->tag);\n\t}\n\n\tif (pgpPrtPkt(VAR_14, VAR_7 ? VAR_7 : VAR_6))\n\t    break;\n\n\tif (VAR_7) {\n\t    /* COMMENT_2 */\n\t    if (VAR_13 == VAR_15) {\n\t\tif (VAR_7->sigtype != VAR_16)\n\t\t    break;\n\t    }\n\n\t    int VAR_17 = pgpVerifySelf(VAR_6, VAR_7, VAR_10, VAR_8);\n\n\t    VAR_7 = pgpDigParamsFree(VAR_7);\n\t    if (VAR_17)\n\t\tbreak;\n\t    VAR_12 = 0;\n\t}\n\n\tif (VAR_14->tag == VAR_15)\n\t    VAR_12 = VAR_18;\n\tVAR_13 = VAR_14->tag;\n\n\tVAR_8++;\n\tVAR_4 += (VAR_14->body - VAR_14->head) + VAR_14->blen;\n\tif (VAR_2 == VAR_18)\n\t    break;\n\n\tif (VAR_9 <= VAR_8) {\n\t    VAR_9 *= 2;\n\t    VAR_10 = xrealloc(VAR_10, VAR_9 * sizeof(*VAR_10));\n\t}\n    }\n\n    VAR_11 = (VAR_6 && (VAR_4 == VAR_5) && VAR_12 == 0) ? 0 : -1;\n\n    free(VAR_10);\n    if (VAR_3 && VAR_11 == 0) {\n\t*VAR_3 = VAR_6;\n    } else {\n\tpgpDigParamsFree(VAR_6);\n    }\n    return VAR_11;\n}",
  "func_graph_path": "rpm-software-management/rpm/bd36c5dc9fb6d90c46fbfed8c2d67516fc571ec8/rpmpgp.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -4,31 +4,69 @@\n     const uint8_t *p = pkts;\n     const uint8_t *pend = pkts + pktlen;\n     pgpDigParams digp = NULL;\n-    struct pgpPkt pkt;\n+    pgpDigParams selfsig = NULL;\n+    int i = 0;\n+    int alloced = 16; /* plenty for normal cases */\n+    struct pgpPkt *all = xmalloc(alloced * sizeof(*all));\n     int rc = -1; /* assume failure */\n+    int expect = 0;\n+    int prevtag = 0;\n \n     while (p < pend) {\n-\tif (decodePkt(p, (pend - p), &pkt))\n+\tstruct pgpPkt *pkt = &all[i];\n+\tif (decodePkt(p, (pend - p), pkt))\n \t    break;\n \n \tif (digp == NULL) {\n-\t    if (pkttype && pkt.tag != pkttype) {\n+\t    if (pkttype && pkt->tag != pkttype) {\n \t\tbreak;\n \t    } else {\n-\t\tdigp = pgpDigParamsNew(pkt.tag);\n+\t\tdigp = pgpDigParamsNew(pkt->tag);\n \t    }\n \t}\n \n-\tif (pgpPrtPkt(&pkt, digp))\n+\tif (expect) {\n+\t    if (pkt->tag != expect)\n+\t\tbreak;\n+\t    selfsig = pgpDigParamsNew(pkt->tag);\n+\t}\n+\n+\tif (pgpPrtPkt(pkt, selfsig ? selfsig : digp))\n \t    break;\n \n-\tp += (pkt.body - pkt.head) + pkt.blen;\n+\tif (selfsig) {\n+\t    /* subkeys must be followed by binding signature */\n+\t    if (prevtag == PGPTAG_PUBLIC_SUBKEY) {\n+\t\tif (selfsig->sigtype != PGPSIGTYPE_SUBKEY_BINDING)\n+\t\t    break;\n+\t    }\n+\n+\t    int xx = pgpVerifySelf(digp, selfsig, all, i);\n+\n+\t    selfsig = pgpDigParamsFree(selfsig);\n+\t    if (xx)\n+\t\tbreak;\n+\t    expect = 0;\n+\t}\n+\n+\tif (pkt->tag == PGPTAG_PUBLIC_SUBKEY)\n+\t    expect = PGPTAG_SIGNATURE;\n+\tprevtag = pkt->tag;\n+\n+\ti++;\n+\tp += (pkt->body - pkt->head) + pkt->blen;\n \tif (pkttype == PGPTAG_SIGNATURE)\n \t    break;\n+\n+\tif (alloced <= i) {\n+\t    alloced *= 2;\n+\t    all = xrealloc(all, alloced * sizeof(*all));\n+\t}\n     }\n \n-    rc = (digp && (p == pend)) ? 0 : -1;\n+    rc = (digp && (p == pend) && expect == 0) ? 0 : -1;\n \n+    free(all);\n     if (ret && rc == 0) {\n \t*ret = digp;\n     } else {",
  "diff_line_info": {
    "deleted_lines": [
      "    struct pgpPkt pkt;",
      "\tif (decodePkt(p, (pend - p), &pkt))",
      "\t    if (pkttype && pkt.tag != pkttype) {",
      "\t\tdigp = pgpDigParamsNew(pkt.tag);",
      "\tif (pgpPrtPkt(&pkt, digp))",
      "\tp += (pkt.body - pkt.head) + pkt.blen;",
      "    rc = (digp && (p == pend)) ? 0 : -1;"
    ],
    "added_lines": [
      "    pgpDigParams selfsig = NULL;",
      "    int i = 0;",
      "    int alloced = 16; /* plenty for normal cases */",
      "    struct pgpPkt *all = xmalloc(alloced * sizeof(*all));",
      "    int expect = 0;",
      "    int prevtag = 0;",
      "\tstruct pgpPkt *pkt = &all[i];",
      "\tif (decodePkt(p, (pend - p), pkt))",
      "\t    if (pkttype && pkt->tag != pkttype) {",
      "\t\tdigp = pgpDigParamsNew(pkt->tag);",
      "\tif (expect) {",
      "\t    if (pkt->tag != expect)",
      "\t\tbreak;",
      "\t    selfsig = pgpDigParamsNew(pkt->tag);",
      "\t}",
      "",
      "\tif (pgpPrtPkt(pkt, selfsig ? selfsig : digp))",
      "\tif (selfsig) {",
      "\t    /* subkeys must be followed by binding signature */",
      "\t    if (prevtag == PGPTAG_PUBLIC_SUBKEY) {",
      "\t\tif (selfsig->sigtype != PGPSIGTYPE_SUBKEY_BINDING)",
      "\t\t    break;",
      "\t    }",
      "",
      "\t    int xx = pgpVerifySelf(digp, selfsig, all, i);",
      "",
      "\t    selfsig = pgpDigParamsFree(selfsig);",
      "\t    if (xx)",
      "\t\tbreak;",
      "\t    expect = 0;",
      "\t}",
      "",
      "\tif (pkt->tag == PGPTAG_PUBLIC_SUBKEY)",
      "\t    expect = PGPTAG_SIGNATURE;",
      "\tprevtag = pkt->tag;",
      "",
      "\ti++;",
      "\tp += (pkt->body - pkt->head) + pkt->blen;",
      "",
      "\tif (alloced <= i) {",
      "\t    alloced *= 2;",
      "\t    all = xrealloc(all, alloced * sizeof(*all));",
      "\t}",
      "    rc = (digp && (p == pend) && expect == 0) ? 0 : -1;",
      "    free(all);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/rpm-software-management/rpm/pull/1795",
  "description": {
    "pr_info": {
      "title": "Validate and require subkey binding signatures on PGP public keys",
      "number": 1795
    },
    "comment": [
      "All subkeys must be followed by a binding signature by the primary key as per the OpenPGP RFC, enforce the presence and validity in the parser.\r\n    \r\nThe implementation is as kludgey as they come to work around our simple-minded parser structure without touching API, to maximise backportability. Store all the raw packets internally as we decode them to be able to access previous elements at will, needed to validate ordering and access the actual data. Add testcases for manipulated keys whose import previously would succeed.\r\n\r\nDepends on the two previous commits:\r\n55d5811a10d5a4c5d965373f5841280a5f43d7ef and d2fcd5380fe3390e695a016727a695829a0a3610\r\n",
      "Hi @DemiMarie,\r\n\r\nI followed  `https://access.redhat.com/articles/3359321` to generate keys. But after this fix, I'm unable to import the keys.\r\n\r\n```\r\nroot [ ~ ]# rpm --import foo.key \r\nerror: foo.key: key 1 import failed.\r\n\r\nroot [ ~ ]# rpm -qi rpm\r\nName        : rpm\r\nVersion     : 4.16.1.3\r\nRelease     : 12.ph4\r\nArchitecture: x86_64\r\nInstall Date: Tue Sep 13 16:57:51 2022\r\n```\r\n\r\nCan you please assist me on generating the keys properly?\r\n\r\nHere are my patches where I back ported this CVE fix to 4.16.x\r\n\r\nhttps://github.com/vmware/photon/blob/4.0/SPECS/rpm/CVE-2021-3521-1.patch\r\nhttps://github.com/vmware/photon/blob/4.0/SPECS/rpm/CVE-2021-3521-2.patch\r\nhttps://github.com/vmware/photon/blob/4.0/SPECS/rpm/CVE-2021-3521-3.patch",
      "@sshedi GnuPG always generates subkey binding signatures by default.",
      "@sshedi you will also need to backport daeddb01de50c53b98eae75e11234132ae63538a",
      "But why the import failure? I saw some other discussions https://github.com/rpm-software-management/rpm/issues/1977\r\n\r\nHow can I generate gpg keys with sha512 algo?\r\n\r\nI tried this:\r\n```\r\n$ cat .gnupg/gpg.conf \r\npersonal-digest-preferences SHA512\r\ncert-digest-algo SHA512\r\ndefault-preference-list SHA512 SHA384 SHA256 SHA224 AES256 AES192 AES CAST5 ZLIB BZIP2 ZIP Uncompressed\r\n```\r\nbut still I'm getting import failure. ",
      "A closed PR is hardly a place for assistance requests of any kind. Please open a [discussion](https://github.com/rpm-software-management/rpm/discussions) on the subject.",
      "Sorry about that @pmatilai.\r\nWe can continue here https://github.com/rpm-software-management/rpm/discussions/2186"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95"
}