{
  "cve_id": "CVE-2021-29338",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "uclouvain/openjpeg",
  "commit_msg": "Fix integer overflow in num_images\n\nIncludes the fix for CVE-2021-29338\nCredit to @kaniini based on #1346\nFixes #1338",
  "commit_hash": "f0727df07c4d944d7d1c5002451cfbc9545d3288",
  "git_url": "https://github.com/uclouvain/openjpeg/commit/f0727df07c4d944d7d1c5002451cfbc9545d3288",
  "file_path": "src/bin/jp2/opj_dump.c",
  "func_name": "main",
  "func_before": "int main(int argc, char *argv[])\n{\n    FILE *fout = NULL;\n\n    opj_dparameters_t parameters;           /* Decompression parameters */\n    opj_image_t* image = NULL;                  /* Image structure */\n    opj_codec_t* l_codec = NULL;                /* Handle to a decompressor */\n    opj_stream_t *l_stream = NULL;              /* Stream */\n    opj_codestream_info_v2_t* cstr_info = NULL;\n    opj_codestream_index_t* cstr_index = NULL;\n\n    OPJ_INT32 num_images, imageno;\n    img_fol_t img_fol;\n    dircnt_t *dirptr = NULL;\n\n    /* Set decoding parameters to default values */\n    opj_set_default_decoder_parameters(&parameters);\n\n    /* Initialize img_fol */\n    memset(&img_fol, 0, sizeof(img_fol_t));\n    img_fol.flag = OPJ_IMG_INFO | OPJ_J2K_MH_INFO | OPJ_J2K_MH_IND;\n\n    /* Parse input and get user encoding parameters */\n    if (parse_cmdline_decoder(argc, argv, &parameters, &img_fol) == 1) {\n        if (img_fol.imgdirpath) {\n            free(img_fol.imgdirpath);\n        }\n\n        return EXIT_FAILURE;\n    }\n\n    /* Initialize reading of directory */\n    if (img_fol.set_imgdir == 1) {\n        int it_image;\n        num_images = get_num_images(img_fol.imgdirpath);\n\n        dirptr = (dircnt_t*)malloc(sizeof(dircnt_t));\n        if (!dirptr) {\n            return EXIT_FAILURE;\n        }\n        dirptr->filename_buf = (char*)malloc((size_t)num_images * OPJ_PATH_LEN * sizeof(\n                char)); /* Stores at max 10 image file names*/\n        if (!dirptr->filename_buf) {\n            free(dirptr);\n            return EXIT_FAILURE;\n        }\n        dirptr->filename = (char**) malloc((size_t)num_images * sizeof(char*));\n\n        if (!dirptr->filename) {\n            goto fails;\n        }\n\n        for (it_image = 0; it_image < num_images; it_image++) {\n            dirptr->filename[it_image] = dirptr->filename_buf + it_image * OPJ_PATH_LEN;\n        }\n\n        if (load_images(dirptr, img_fol.imgdirpath) == 1) {\n            goto fails;\n        }\n\n        if (num_images == 0) {\n            fprintf(stdout, \"Folder is empty\\n\");\n            goto fails;\n        }\n    } else {\n        num_images = 1;\n    }\n\n    /* Try to open for writing the output file if necessary */\n    if (parameters.outfile[0] != 0) {\n        fout = fopen(parameters.outfile, \"w\");\n        if (!fout) {\n            fprintf(stderr, \"ERROR -> failed to open %s for writing\\n\", parameters.outfile);\n            goto fails;\n        }\n    } else {\n        fout = stdout;\n    }\n\n    /* Read the header of each image one by one */\n    for (imageno = 0; imageno < num_images ; imageno++) {\n\n        fprintf(stderr, \"\\n\");\n\n        if (img_fol.set_imgdir == 1) {\n            if (get_next_file(imageno, dirptr, &img_fol, &parameters)) {\n                fprintf(stderr, \"skipping file...\\n\");\n                continue;\n            }\n        }\n\n        /* Read the input file and put it in memory */\n        /* ---------------------------------------- */\n\n        l_stream = opj_stream_create_default_file_stream(parameters.infile, 1);\n        if (!l_stream) {\n            fprintf(stderr, \"ERROR -> failed to create the stream from the file %s\\n\",\n                    parameters.infile);\n            goto fails;\n        }\n\n        /* Read the JPEG2000 stream */\n        /* ------------------------ */\n\n        switch (parameters.decod_format) {\n        case J2K_CFMT: { /* JPEG-2000 codestream */\n            /* Get a decoder handle */\n            l_codec = opj_create_decompress(OPJ_CODEC_J2K);\n            break;\n        }\n        case JP2_CFMT: { /* JPEG 2000 compressed image data */\n            /* Get a decoder handle */\n            l_codec = opj_create_decompress(OPJ_CODEC_JP2);\n            break;\n        }\n        case JPT_CFMT: { /* JPEG 2000, JPIP */\n            /* Get a decoder handle */\n            l_codec = opj_create_decompress(OPJ_CODEC_JPT);\n            break;\n        }\n        default:\n            fprintf(stderr, \"skipping file..\\n\");\n            opj_stream_destroy(l_stream);\n            continue;\n        }\n\n        /* catch events using our callbacks and give a local context */\n        opj_set_info_handler(l_codec, info_callback, 00);\n        opj_set_warning_handler(l_codec, warning_callback, 00);\n        opj_set_error_handler(l_codec, error_callback, 00);\n\n        parameters.flags |= OPJ_DPARAMETERS_DUMP_FLAG;\n\n        /* Setup the decoder decoding parameters using user parameters */\n        if (!opj_setup_decoder(l_codec, &parameters)) {\n            fprintf(stderr, \"ERROR -> opj_dump: failed to setup the decoder\\n\");\n            opj_stream_destroy(l_stream);\n            opj_destroy_codec(l_codec);\n            fclose(fout);\n            goto fails;\n        }\n\n        /* Read the main header of the codestream and if necessary the JP2 boxes*/\n        if (! opj_read_header(l_stream, l_codec, &image)) {\n            fprintf(stderr, \"ERROR -> opj_dump: failed to read the header\\n\");\n            opj_stream_destroy(l_stream);\n            opj_destroy_codec(l_codec);\n            opj_image_destroy(image);\n            fclose(fout);\n            goto fails;\n        }\n\n        opj_dump_codec(l_codec, img_fol.flag, fout);\n\n        cstr_info = opj_get_cstr_info(l_codec);\n\n        cstr_index = opj_get_cstr_index(l_codec);\n\n        /* close the byte stream */\n        opj_stream_destroy(l_stream);\n\n        /* free remaining structures */\n        if (l_codec) {\n            opj_destroy_codec(l_codec);\n        }\n\n        /* destroy the image header */\n        opj_image_destroy(image);\n\n        /* destroy the codestream index */\n        opj_destroy_cstr_index(&cstr_index);\n\n        /* destroy the codestream info */\n        opj_destroy_cstr_info(&cstr_info);\n\n    }\n\n    /* Close the output file */\n    fclose(fout);\n\n    return EXIT_SUCCESS;\n\nfails:\n    if (dirptr) {\n        if (dirptr->filename) {\n            free(dirptr->filename);\n        }\n        if (dirptr->filename_buf) {\n            free(dirptr->filename_buf);\n        }\n        free(dirptr);\n    }\n    return EXIT_FAILURE;\n}",
  "abstract_func_before": "int main(int VAR_0, char *VAR_1[])\n{\n    FILE *VAR_2 = NULL;\n\n    opj_dparameters_t VAR_3;           /* COMMENT_0 */\n    opj_image_t* VAR_4 = NULL;                  /* COMMENT_1 */\n    opj_codec_t* VAR_5 = NULL;                /* COMMENT_2 */\n    opj_stream_t *VAR_6 = NULL;              /* COMMENT_3 */\n    opj_codestream_info_v2_t* VAR_7 = NULL;\n    opj_codestream_index_t* VAR_8 = NULL;\n\n    OPJ_INT32 VAR_9, VAR_10;\n    img_fol_t VAR_11;\n    dircnt_t *VAR_12 = NULL;\n\n    /* COMMENT_4 */\n    opj_set_default_decoder_parameters(&VAR_3);\n\n    /* COMMENT_5 */\n    memset(&VAR_11, 0, sizeof(img_fol_t));\n    VAR_11.flag = VAR_13 | VAR_14 | VAR_15;\n\n    /* COMMENT_6 */\n    if (parse_cmdline_decoder(VAR_0, VAR_1, &VAR_3, &VAR_11) == 1) {\n        if (VAR_11.imgdirpath) {\n            free(VAR_11.imgdirpath);\n        }\n\n        return VAR_16;\n    }\n\n    /* COMMENT_7 */\n    if (VAR_11.set_imgdir == 1) {\n        int VAR_17;\n        VAR_9 = get_num_images(VAR_11.imgdirpath);\n\n        VAR_12 = (dircnt_t*)malloc(sizeof(dircnt_t));\n        if (!VAR_12) {\n            return VAR_16;\n        }\n        VAR_12->filename_buf = (char*)malloc((size_t)VAR_9 * VAR_18 * sizeof(\n                char)); /* COMMENT_8 */\n        if (!VAR_12->filename_buf) {\n            free(VAR_12);\n            return VAR_16;\n        }\n        VAR_12->filename = (char**) malloc((size_t)VAR_9 * sizeof(char*));\n\n        if (!VAR_12->filename) {\n            goto fails;\n        }\n\n        for (VAR_17 = 0; VAR_17 < VAR_9; VAR_17++) {\n            VAR_12->filename[VAR_17] = VAR_12->filename_buf + VAR_17 * VAR_18;\n        }\n\n        if (load_images(VAR_12, VAR_11.imgdirpath) == 1) {\n            goto fails;\n        }\n\n        if (VAR_9 == 0) {\n            fprintf(VAR_19, \"Folder is empty\\n\");\n            goto fails;\n        }\n    } else {\n        VAR_9 = 1;\n    }\n\n    /* COMMENT_9 */\n    if (VAR_3.outfile[0] != 0) {\n        VAR_2 = fopen(VAR_3.outfile, \"w\");\n        if (!VAR_2) {\n            fprintf(VAR_20, \"ERROR -> failed to open %s for writing\\n\", VAR_3.outfile);\n            goto fails;\n        }\n    } else {\n        VAR_2 = VAR_19;\n    }\n\n    /* COMMENT_10 */\n    for (VAR_10 = 0; VAR_10 < VAR_9 ; VAR_10++) {\n\n        fprintf(VAR_20, \"\\n\");\n\n        if (VAR_11.set_imgdir == 1) {\n            if (get_next_file(VAR_10, VAR_12, &VAR_11, &VAR_3)) {\n                fprintf(VAR_20, \"skipping file...\\n\");\n                continue;\n            }\n        }\n\n        /* COMMENT_11 */\n        /* COMMENT_12 */\n\n        VAR_6 = opj_stream_create_default_file_stream(VAR_3.infile, 1);\n        if (!VAR_6) {\n            fprintf(VAR_20, \"ERROR -> failed to create the stream from the file %s\\n\",\n                    VAR_3.infile);\n            goto fails;\n        }\n\n        /* COMMENT_13 */\n        /* COMMENT_14 */\n\n        switch (VAR_3.decod_format) {\n        case VAR_21: { /* COMMENT_15 */\n            /* COMMENT_16 */\n            VAR_5 = opj_create_decompress(VAR_22);\n            break;\n        }\n        case VAR_23: { /* COMMENT_17 */\n            /* COMMENT_16 */\n            VAR_5 = opj_create_decompress(VAR_24);\n            break;\n        }\n        case VAR_25: { /* COMMENT_18 */\n            /* COMMENT_16 */\n            VAR_5 = opj_create_decompress(VAR_26);\n            break;\n        }\n        default:\n            fprintf(VAR_20, \"skipping file..\\n\");\n            opj_stream_destroy(VAR_6);\n            continue;\n        }\n\n        /* COMMENT_19 */\n        opj_set_info_handler(VAR_5, VAR_27, 00);\n        opj_set_warning_handler(VAR_5, VAR_28, 00);\n        opj_set_error_handler(VAR_5, VAR_29, 00);\n\n        VAR_3.flags |= VAR_30;\n\n        /* COMMENT_20 */\n        if (!opj_setup_decoder(VAR_5, &VAR_3)) {\n            fprintf(VAR_20, \"ERROR -> opj_dump: failed to setup the decoder\\n\");\n            opj_stream_destroy(VAR_6);\n            opj_destroy_codec(VAR_5);\n            fclose(VAR_2);\n            goto fails;\n        }\n\n        /* COMMENT_21 */\n        if (! opj_read_header(VAR_6, VAR_5, &VAR_4)) {\n            fprintf(VAR_20, \"ERROR -> opj_dump: failed to read the header\\n\");\n            opj_stream_destroy(VAR_6);\n            opj_destroy_codec(VAR_5);\n            opj_image_destroy(VAR_4);\n            fclose(VAR_2);\n            goto fails;\n        }\n\n        opj_dump_codec(VAR_5, VAR_11.flag, VAR_2);\n\n        VAR_7 = opj_get_cstr_info(VAR_5);\n\n        VAR_8 = opj_get_cstr_index(VAR_5);\n\n        /* COMMENT_22 */\n        opj_stream_destroy(VAR_6);\n\n        /* COMMENT_23 */\n        if (VAR_5) {\n            opj_destroy_codec(VAR_5);\n        }\n\n        /* COMMENT_24 */\n        opj_image_destroy(VAR_4);\n\n        /* COMMENT_25 */\n        opj_destroy_cstr_index(&VAR_8);\n\n        /* COMMENT_26 */\n        opj_destroy_cstr_info(&VAR_7);\n\n    }\n\n    /* COMMENT_27 */\n    fclose(VAR_2);\n\n    return VAR_31;\n\nfails:\n    if (VAR_12) {\n        if (VAR_12->filename) {\n            free(VAR_12->filename);\n        }\n        if (VAR_12->filename_buf) {\n            free(VAR_12->filename_buf);\n        }\n        free(VAR_12);\n    }\n    return VAR_16;\n}",
  "func_graph_path_before": "uclouvain/openjpeg/f0727df07c4d944d7d1c5002451cfbc9545d3288/opj_dump.c/vul/before/0.json",
  "func": "int main(int argc, char *argv[])\n{\n    FILE *fout = NULL;\n\n    opj_dparameters_t parameters;           /* Decompression parameters */\n    opj_image_t* image = NULL;                  /* Image structure */\n    opj_codec_t* l_codec = NULL;                /* Handle to a decompressor */\n    opj_stream_t *l_stream = NULL;              /* Stream */\n    opj_codestream_info_v2_t* cstr_info = NULL;\n    opj_codestream_index_t* cstr_index = NULL;\n\n    OPJ_INT32 num_images, imageno;\n    img_fol_t img_fol;\n    dircnt_t *dirptr = NULL;\n\n    /* Set decoding parameters to default values */\n    opj_set_default_decoder_parameters(&parameters);\n\n    /* Initialize img_fol */\n    memset(&img_fol, 0, sizeof(img_fol_t));\n    img_fol.flag = OPJ_IMG_INFO | OPJ_J2K_MH_INFO | OPJ_J2K_MH_IND;\n\n    /* Parse input and get user encoding parameters */\n    if (parse_cmdline_decoder(argc, argv, &parameters, &img_fol) == 1) {\n        if (img_fol.imgdirpath) {\n            free(img_fol.imgdirpath);\n        }\n\n        return EXIT_FAILURE;\n    }\n\n    /* Initialize reading of directory */\n    if (img_fol.set_imgdir == 1) {\n        int it_image;\n        num_images = get_num_images(img_fol.imgdirpath);\n\n        dirptr = (dircnt_t*)malloc(sizeof(dircnt_t));\n        if (!dirptr) {\n            return EXIT_FAILURE;\n        }\n        /* Stores at max 10 image file names*/\n        dirptr->filename_buf = (char*) calloc((size_t) num_images,\n                                              OPJ_PATH_LEN * sizeof(char));\n        if (!dirptr->filename_buf) {\n            free(dirptr);\n            return EXIT_FAILURE;\n        }\n        dirptr->filename = (char**) calloc((size_t) num_images, sizeof(char*));\n\n        if (!dirptr->filename) {\n            goto fails;\n        }\n\n        for (it_image = 0; it_image < num_images; it_image++) {\n            dirptr->filename[it_image] = dirptr->filename_buf + it_image * OPJ_PATH_LEN;\n        }\n\n        if (load_images(dirptr, img_fol.imgdirpath) == 1) {\n            goto fails;\n        }\n\n        if (num_images == 0) {\n            fprintf(stdout, \"Folder is empty\\n\");\n            goto fails;\n        }\n    } else {\n        num_images = 1;\n    }\n\n    /* Try to open for writing the output file if necessary */\n    if (parameters.outfile[0] != 0) {\n        fout = fopen(parameters.outfile, \"w\");\n        if (!fout) {\n            fprintf(stderr, \"ERROR -> failed to open %s for writing\\n\", parameters.outfile);\n            goto fails;\n        }\n    } else {\n        fout = stdout;\n    }\n\n    /* Read the header of each image one by one */\n    for (imageno = 0; imageno < num_images ; imageno++) {\n\n        fprintf(stderr, \"\\n\");\n\n        if (img_fol.set_imgdir == 1) {\n            if (get_next_file(imageno, dirptr, &img_fol, &parameters)) {\n                fprintf(stderr, \"skipping file...\\n\");\n                continue;\n            }\n        }\n\n        /* Read the input file and put it in memory */\n        /* ---------------------------------------- */\n\n        l_stream = opj_stream_create_default_file_stream(parameters.infile, 1);\n        if (!l_stream) {\n            fprintf(stderr, \"ERROR -> failed to create the stream from the file %s\\n\",\n                    parameters.infile);\n            goto fails;\n        }\n\n        /* Read the JPEG2000 stream */\n        /* ------------------------ */\n\n        switch (parameters.decod_format) {\n        case J2K_CFMT: { /* JPEG-2000 codestream */\n            /* Get a decoder handle */\n            l_codec = opj_create_decompress(OPJ_CODEC_J2K);\n            break;\n        }\n        case JP2_CFMT: { /* JPEG 2000 compressed image data */\n            /* Get a decoder handle */\n            l_codec = opj_create_decompress(OPJ_CODEC_JP2);\n            break;\n        }\n        case JPT_CFMT: { /* JPEG 2000, JPIP */\n            /* Get a decoder handle */\n            l_codec = opj_create_decompress(OPJ_CODEC_JPT);\n            break;\n        }\n        default:\n            fprintf(stderr, \"skipping file..\\n\");\n            opj_stream_destroy(l_stream);\n            continue;\n        }\n\n        /* catch events using our callbacks and give a local context */\n        opj_set_info_handler(l_codec, info_callback, 00);\n        opj_set_warning_handler(l_codec, warning_callback, 00);\n        opj_set_error_handler(l_codec, error_callback, 00);\n\n        parameters.flags |= OPJ_DPARAMETERS_DUMP_FLAG;\n\n        /* Setup the decoder decoding parameters using user parameters */\n        if (!opj_setup_decoder(l_codec, &parameters)) {\n            fprintf(stderr, \"ERROR -> opj_dump: failed to setup the decoder\\n\");\n            opj_stream_destroy(l_stream);\n            opj_destroy_codec(l_codec);\n            fclose(fout);\n            goto fails;\n        }\n\n        /* Read the main header of the codestream and if necessary the JP2 boxes*/\n        if (! opj_read_header(l_stream, l_codec, &image)) {\n            fprintf(stderr, \"ERROR -> opj_dump: failed to read the header\\n\");\n            opj_stream_destroy(l_stream);\n            opj_destroy_codec(l_codec);\n            opj_image_destroy(image);\n            fclose(fout);\n            goto fails;\n        }\n\n        opj_dump_codec(l_codec, img_fol.flag, fout);\n\n        cstr_info = opj_get_cstr_info(l_codec);\n\n        cstr_index = opj_get_cstr_index(l_codec);\n\n        /* close the byte stream */\n        opj_stream_destroy(l_stream);\n\n        /* free remaining structures */\n        if (l_codec) {\n            opj_destroy_codec(l_codec);\n        }\n\n        /* destroy the image header */\n        opj_image_destroy(image);\n\n        /* destroy the codestream index */\n        opj_destroy_cstr_index(&cstr_index);\n\n        /* destroy the codestream info */\n        opj_destroy_cstr_info(&cstr_info);\n\n    }\n\n    /* Close the output file */\n    fclose(fout);\n\n    return EXIT_SUCCESS;\n\nfails:\n    if (dirptr) {\n        if (dirptr->filename) {\n            free(dirptr->filename);\n        }\n        if (dirptr->filename_buf) {\n            free(dirptr->filename_buf);\n        }\n        free(dirptr);\n    }\n    return EXIT_FAILURE;\n}",
  "abstract_func": "int main(int VAR_0, char *VAR_1[])\n{\n    FILE *VAR_2 = NULL;\n\n    opj_dparameters_t VAR_3;           /* COMMENT_0 */\n    opj_image_t* VAR_4 = NULL;                  /* COMMENT_1 */\n    opj_codec_t* VAR_5 = NULL;                /* COMMENT_2 */\n    opj_stream_t *VAR_6 = NULL;              /* COMMENT_3 */\n    opj_codestream_info_v2_t* VAR_7 = NULL;\n    opj_codestream_index_t* VAR_8 = NULL;\n\n    OPJ_INT32 VAR_9, VAR_10;\n    img_fol_t VAR_11;\n    dircnt_t *VAR_12 = NULL;\n\n    /* COMMENT_4 */\n    opj_set_default_decoder_parameters(&VAR_3);\n\n    /* COMMENT_5 */\n    memset(&VAR_11, 0, sizeof(img_fol_t));\n    VAR_11.flag = VAR_13 | VAR_14 | VAR_15;\n\n    /* COMMENT_6 */\n    if (parse_cmdline_decoder(VAR_0, VAR_1, &VAR_3, &VAR_11) == 1) {\n        if (VAR_11.imgdirpath) {\n            free(VAR_11.imgdirpath);\n        }\n\n        return VAR_16;\n    }\n\n    /* COMMENT_7 */\n    if (VAR_11.set_imgdir == 1) {\n        int VAR_17;\n        VAR_9 = get_num_images(VAR_11.imgdirpath);\n\n        VAR_12 = (dircnt_t*)malloc(sizeof(dircnt_t));\n        if (!VAR_12) {\n            return VAR_16;\n        }\n        /* COMMENT_8 */\n        VAR_12->filename_buf = (char*) calloc((size_t) VAR_9,\n                                              VAR_18 * sizeof(char));\n        if (!VAR_12->filename_buf) {\n            free(VAR_12);\n            return VAR_16;\n        }\n        VAR_12->filename = (char**) calloc((size_t) VAR_9, sizeof(char*));\n\n        if (!VAR_12->filename) {\n            goto fails;\n        }\n\n        for (VAR_17 = 0; VAR_17 < VAR_9; VAR_17++) {\n            VAR_12->filename[VAR_17] = VAR_12->filename_buf + VAR_17 * VAR_18;\n        }\n\n        if (load_images(VAR_12, VAR_11.imgdirpath) == 1) {\n            goto fails;\n        }\n\n        if (VAR_9 == 0) {\n            fprintf(VAR_19, \"Folder is empty\\n\");\n            goto fails;\n        }\n    } else {\n        VAR_9 = 1;\n    }\n\n    /* COMMENT_9 */\n    if (VAR_3.outfile[0] != 0) {\n        VAR_2 = fopen(VAR_3.outfile, \"w\");\n        if (!VAR_2) {\n            fprintf(VAR_20, \"ERROR -> failed to open %s for writing\\n\", VAR_3.outfile);\n            goto fails;\n        }\n    } else {\n        VAR_2 = VAR_19;\n    }\n\n    /* COMMENT_10 */\n    for (VAR_10 = 0; VAR_10 < VAR_9 ; VAR_10++) {\n\n        fprintf(VAR_20, \"\\n\");\n\n        if (VAR_11.set_imgdir == 1) {\n            if (get_next_file(VAR_10, VAR_12, &VAR_11, &VAR_3)) {\n                fprintf(VAR_20, \"skipping file...\\n\");\n                continue;\n            }\n        }\n\n        /* COMMENT_11 */\n        /* COMMENT_12 */\n\n        VAR_6 = opj_stream_create_default_file_stream(VAR_3.infile, 1);\n        if (!VAR_6) {\n            fprintf(VAR_20, \"ERROR -> failed to create the stream from the file %s\\n\",\n                    VAR_3.infile);\n            goto fails;\n        }\n\n        /* COMMENT_13 */\n        /* COMMENT_14 */\n\n        switch (VAR_3.decod_format) {\n        case VAR_21: { /* COMMENT_15 */\n            /* COMMENT_16 */\n            VAR_5 = opj_create_decompress(VAR_22);\n            break;\n        }\n        case VAR_23: { /* COMMENT_17 */\n            /* COMMENT_16 */\n            VAR_5 = opj_create_decompress(VAR_24);\n            break;\n        }\n        case VAR_25: { /* COMMENT_18 */\n            /* COMMENT_16 */\n            VAR_5 = opj_create_decompress(VAR_26);\n            break;\n        }\n        default:\n            fprintf(VAR_20, \"skipping file..\\n\");\n            opj_stream_destroy(VAR_6);\n            continue;\n        }\n\n        /* COMMENT_19 */\n        opj_set_info_handler(VAR_5, VAR_27, 00);\n        opj_set_warning_handler(VAR_5, VAR_28, 00);\n        opj_set_error_handler(VAR_5, VAR_29, 00);\n\n        VAR_3.flags |= VAR_30;\n\n        /* COMMENT_20 */\n        if (!opj_setup_decoder(VAR_5, &VAR_3)) {\n            fprintf(VAR_20, \"ERROR -> opj_dump: failed to setup the decoder\\n\");\n            opj_stream_destroy(VAR_6);\n            opj_destroy_codec(VAR_5);\n            fclose(VAR_2);\n            goto fails;\n        }\n\n        /* COMMENT_21 */\n        if (! opj_read_header(VAR_6, VAR_5, &VAR_4)) {\n            fprintf(VAR_20, \"ERROR -> opj_dump: failed to read the header\\n\");\n            opj_stream_destroy(VAR_6);\n            opj_destroy_codec(VAR_5);\n            opj_image_destroy(VAR_4);\n            fclose(VAR_2);\n            goto fails;\n        }\n\n        opj_dump_codec(VAR_5, VAR_11.flag, VAR_2);\n\n        VAR_7 = opj_get_cstr_info(VAR_5);\n\n        VAR_8 = opj_get_cstr_index(VAR_5);\n\n        /* COMMENT_22 */\n        opj_stream_destroy(VAR_6);\n\n        /* COMMENT_23 */\n        if (VAR_5) {\n            opj_destroy_codec(VAR_5);\n        }\n\n        /* COMMENT_24 */\n        opj_image_destroy(VAR_4);\n\n        /* COMMENT_25 */\n        opj_destroy_cstr_index(&VAR_8);\n\n        /* COMMENT_26 */\n        opj_destroy_cstr_info(&VAR_7);\n\n    }\n\n    /* COMMENT_27 */\n    fclose(VAR_2);\n\n    return VAR_31;\n\nfails:\n    if (VAR_12) {\n        if (VAR_12->filename) {\n            free(VAR_12->filename);\n        }\n        if (VAR_12->filename_buf) {\n            free(VAR_12->filename_buf);\n        }\n        free(VAR_12);\n    }\n    return VAR_16;\n}",
  "func_graph_path": "uclouvain/openjpeg/f0727df07c4d944d7d1c5002451cfbc9545d3288/opj_dump.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -38,13 +38,14 @@\n         if (!dirptr) {\n             return EXIT_FAILURE;\n         }\n-        dirptr->filename_buf = (char*)malloc((size_t)num_images * OPJ_PATH_LEN * sizeof(\n-                char)); /* Stores at max 10 image file names*/\n+        /* Stores at max 10 image file names*/\n+        dirptr->filename_buf = (char*) calloc((size_t) num_images,\n+                                              OPJ_PATH_LEN * sizeof(char));\n         if (!dirptr->filename_buf) {\n             free(dirptr);\n             return EXIT_FAILURE;\n         }\n-        dirptr->filename = (char**) malloc((size_t)num_images * sizeof(char*));\n+        dirptr->filename = (char**) calloc((size_t) num_images, sizeof(char*));\n \n         if (!dirptr->filename) {\n             goto fails;",
  "diff_line_info": {
    "deleted_lines": [
      "        dirptr->filename_buf = (char*)malloc((size_t)num_images * OPJ_PATH_LEN * sizeof(",
      "                char)); /* Stores at max 10 image file names*/",
      "        dirptr->filename = (char**) malloc((size_t)num_images * sizeof(char*));"
    ],
    "added_lines": [
      "        /* Stores at max 10 image file names*/",
      "        dirptr->filename_buf = (char*) calloc((size_t) num_images,",
      "                                              OPJ_PATH_LEN * sizeof(char));",
      "        dirptr->filename = (char**) calloc((size_t) num_images, sizeof(char*));"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/uclouvain/openjpeg/pull/1395",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/uclouvain/openjpeg/pull/1395: 403 Client Error: Forbidden for url: https://api.github.com/repos/uclouvain/openjpeg/pulls/1395",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}