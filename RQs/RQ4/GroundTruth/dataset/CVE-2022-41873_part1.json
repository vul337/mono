{
  "cve_id": "CVE-2022-41873",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "CVSS:3.1/AV:A/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N",
  "cvss_is_v3": true,
  "repo_name": "contiki-ng",
  "commit_msg": "Fix l2cap_channels OOB in get_channel_for_cid\n\nWhile the bounds check is performed on `l2cap_channel_count`, only the lower byte is checked due to the uint8_t data type. Afterwards, the expression for `i` is re-calculated without the explicit data type, which means without truncation into 8 bits. Instead, the full 16-bit value is used as the channel index. This pointer will point out-of-bounds of the channel array.\r\n\r\nThis leads to a large 16 out-of-bounds channel id to be used as an index into the array for large CID inputs.\r\n\r\nSample value: 0xff41 -> 0xff41 - 0x41 = 0xff00 == 0x00 (as uint8_t)\r\n\r\nThis results in out-of-bounds memory to be interpreted as a channel object, and this memory to potentially be corrupted in the following call to `input_l2cap_frame_flow_channel`, which fills the out-of-bounds memory (the supposed channel object) with user-supplied data.\r\n\r\nThe fix here is to re-use the `i` variable as an index, which was used to perform the bounds check, and is truncated to 8 bits.\r\n\r\nAs a side note, due to the unsignedness of the data type `uint8_t i`, the check `i >= 0` is always true. Instead, a signed data type such as `int16_t` could be used to make the check take effect.",
  "commit_hash": "f28ca563e3882d4719d56f3bcd50a4e74edfa0ea",
  "git_url": "https://github.com/contiki-ng/contiki-ng/commit/f28ca563e3882d4719d56f3bcd50a4e74edfa0ea",
  "file_path": "os/net/mac/ble/ble-l2cap.c",
  "func_name": "get_channel_for_cid",
  "func_before": "static l2cap_channel_t *\nget_channel_for_cid(uint16_t own_cid)\n{\n  uint8_t i = own_cid - L2CAP_FLOW_CHANNEL;\n  if(i >= 0 && i < l2cap_channel_count) {\n    return &l2cap_channels[own_cid - L2CAP_FLOW_CHANNEL];\n  } else {\n    return NULL;\n  }\n}",
  "abstract_func_before": "static l2cap_channel_t *\nget_channel_for_cid(uint16_t VAR_0)\n{\n  uint8_t VAR_1 = VAR_0 - VAR_2;\n  if(VAR_1 >= 0 && VAR_1 < VAR_3) {\n    return &VAR_4[VAR_0 - VAR_2];\n  } else {\n    return NULL;\n  }\n}",
  "func_graph_path_before": "contiki-ng/f28ca563e3882d4719d56f3bcd50a4e74edfa0ea/ble-l2cap.c/vul/before/0.json",
  "func": "static l2cap_channel_t *\nget_channel_for_cid(uint16_t own_cid)\n{\n  int16_t i = own_cid - L2CAP_FLOW_CHANNEL;\n  if(i >= 0 && i < l2cap_channel_count) {\n    return &l2cap_channels[i];\n  } else {\n    return NULL;\n  }\n}",
  "abstract_func": "static l2cap_channel_t *\nget_channel_for_cid(uint16_t VAR_0)\n{\n  int16_t VAR_1 = VAR_0 - VAR_2;\n  if(VAR_1 >= 0 && VAR_1 < VAR_3) {\n    return &VAR_4[VAR_1];\n  } else {\n    return NULL;\n  }\n}",
  "func_graph_path": "contiki-ng/f28ca563e3882d4719d56f3bcd50a4e74edfa0ea/ble-l2cap.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,9 +1,9 @@\n static l2cap_channel_t *\n get_channel_for_cid(uint16_t own_cid)\n {\n-  uint8_t i = own_cid - L2CAP_FLOW_CHANNEL;\n+  int16_t i = own_cid - L2CAP_FLOW_CHANNEL;\n   if(i >= 0 && i < l2cap_channel_count) {\n-    return &l2cap_channels[own_cid - L2CAP_FLOW_CHANNEL];\n+    return &l2cap_channels[i];\n   } else {\n     return NULL;\n   }",
  "diff_line_info": {
    "deleted_lines": [
      "  uint8_t i = own_cid - L2CAP_FLOW_CHANNEL;",
      "    return &l2cap_channels[own_cid - L2CAP_FLOW_CHANNEL];"
    ],
    "added_lines": [
      "  int16_t i = own_cid - L2CAP_FLOW_CHANNEL;",
      "    return &l2cap_channels[i];"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/contiki-ng/contiki-ng/pull/2081",
  "description": {
    "pr_info": {
      "title": "Fix l2cap_channels OOB in get_channel_for_cid",
      "number": 2081
    },
    "comment": [
      "While the bounds check is performed on `l2cap_channel_count`, only the lower byte is checked due to the uint8_t data type. Afterwards, the expression for `i` is re-calculated without the explicit data type, which means without truncation into 8 bits. Instead, the full 16-bit value is used as the channel index. This pointer will point out-of-bounds of the channel array.\r\n\r\nThis leads to a large 16 out-of-bounds channel id to be used as an index into the array for large CID inputs.\r\n\r\nSample value: 0xff41 -> 0xff41 - 0x41 = 0xff00 == 0x00 (as uint8_t)\r\n\r\nThis results in out-of-bounds memory to be interpreted as a channel object, and this memory to potentially be corrupted in the following call to `input_l2cap_frame_flow_channel`, which fills the out-of-bounds memory (the supposed channel object) with user-supplied data.\r\n\r\nThe fix here is to re-use the `i` variable as an index, which was used to perform the bounds check, and is truncated to 8 bits.\r\n\r\nAs a side note, due to the unsignedness of the data type `uint8_t i`, the check `i >= 0` is always true. Instead, a signed data type such as `int16_t` could be used to make the check take effect."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "The patch addresses an out-of-bounds memory access vulnerability in the `get_channel_for_cid` function, which is critical for security. By changing the index variable to a signed type and correctly using the truncated value, it prevents buffer overflow.\n\n**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0\n\nFinal Classification: Security Vulnerability Fix; Confidence: 1.0\n\n**Final Output:**  \n**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}