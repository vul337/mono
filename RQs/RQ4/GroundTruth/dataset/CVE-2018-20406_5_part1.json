{
  "cve_id": "CVE-2018-20406",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "python/cpython",
  "commit_msg": "closes bpo-34656: Avoid relying on signed overflow in _pickle memos. (GH-9261)",
  "commit_hash": "a4ae828ee416a66d8c7bf5ee71d653c2cc6a26dd",
  "git_url": "https://github.com/python/cpython/commit/a4ae828ee416a66d8c7bf5ee71d653c2cc6a26dd",
  "file_path": "Modules/_pickle.c",
  "func_name": "_pickle_PicklerMemoProxy_copy_impl",
  "func_before": "static PyObject *\n_pickle_PicklerMemoProxy_copy_impl(PicklerMemoProxyObject *self)\n/*[clinic end generated code: output=bb83a919d29225ef input=b73043485ac30b36]*/\n{\n    Py_ssize_t i;\n    PyMemoTable *memo;\n    PyObject *new_memo = PyDict_New();\n    if (new_memo == NULL)\n        return NULL;\n\n    memo = self->pickler->memo;\n    for (i = 0; i < memo->mt_allocated; ++i) {\n        PyMemoEntry entry = memo->mt_table[i];\n        if (entry.me_key != NULL) {\n            int status;\n            PyObject *key, *value;\n\n            key = PyLong_FromVoidPtr(entry.me_key);\n            value = Py_BuildValue(\"nO\", entry.me_value, entry.me_key);\n\n            if (key == NULL || value == NULL) {\n                Py_XDECREF(key);\n                Py_XDECREF(value);\n                goto error;\n            }\n            status = PyDict_SetItem(new_memo, key, value);\n            Py_DECREF(key);\n            Py_DECREF(value);\n            if (status < 0)\n                goto error;\n        }\n    }\n    return new_memo;\n\n  error:\n    Py_XDECREF(new_memo);\n    return NULL;\n}",
  "abstract_func_before": "static PyObject *\n_pickle_PicklerMemoProxy_copy_impl(PicklerMemoProxyObject *VAR_0)\n/* COMMENT_0 */\n{\n    Py_ssize_t VAR_1;\n    PyMemoTable *VAR_2;\n    PyObject *VAR_3 = PyDict_New();\n    if (VAR_3 == NULL)\n        return NULL;\n\n    VAR_2 = VAR_0->pickler->memo;\n    for (VAR_1 = 0; VAR_1 < VAR_2->mt_allocated; ++VAR_1) {\n        PyMemoEntry VAR_4 = VAR_2->mt_table[VAR_1];\n        if (VAR_4.me_key != NULL) {\n            int VAR_5;\n            PyObject *VAR_6, *VAR_7;\n\n            VAR_6 = PyLong_FromVoidPtr(VAR_4.me_key);\n            VAR_7 = Py_BuildValue(\"nO\", VAR_4.me_value, VAR_4.me_key);\n\n            if (VAR_6 == NULL || VAR_7 == NULL) {\n                Py_XDECREF(VAR_6);\n                Py_XDECREF(VAR_7);\n                goto error;\n            }\n            VAR_5 = PyDict_SetItem(VAR_3, VAR_6, VAR_7);\n            Py_DECREF(VAR_6);\n            Py_DECREF(VAR_7);\n            if (VAR_5 < 0)\n                goto error;\n        }\n    }\n    return VAR_3;\n\n  error:\n    Py_XDECREF(VAR_3);\n    return NULL;\n}",
  "func_graph_path_before": "python/cpython/a4ae828ee416a66d8c7bf5ee71d653c2cc6a26dd/_pickle.c/vul/before/6.json",
  "func": "static PyObject *\n_pickle_PicklerMemoProxy_copy_impl(PicklerMemoProxyObject *self)\n/*[clinic end generated code: output=bb83a919d29225ef input=b73043485ac30b36]*/\n{\n    PyMemoTable *memo;\n    PyObject *new_memo = PyDict_New();\n    if (new_memo == NULL)\n        return NULL;\n\n    memo = self->pickler->memo;\n    for (size_t i = 0; i < memo->mt_allocated; ++i) {\n        PyMemoEntry entry = memo->mt_table[i];\n        if (entry.me_key != NULL) {\n            int status;\n            PyObject *key, *value;\n\n            key = PyLong_FromVoidPtr(entry.me_key);\n            value = Py_BuildValue(\"nO\", entry.me_value, entry.me_key);\n\n            if (key == NULL || value == NULL) {\n                Py_XDECREF(key);\n                Py_XDECREF(value);\n                goto error;\n            }\n            status = PyDict_SetItem(new_memo, key, value);\n            Py_DECREF(key);\n            Py_DECREF(value);\n            if (status < 0)\n                goto error;\n        }\n    }\n    return new_memo;\n\n  error:\n    Py_XDECREF(new_memo);\n    return NULL;\n}",
  "abstract_func": "static PyObject *\n_pickle_PicklerMemoProxy_copy_impl(PicklerMemoProxyObject *VAR_0)\n/* COMMENT_0 */\n{\n    PyMemoTable *VAR_1;\n    PyObject *VAR_2 = PyDict_New();\n    if (VAR_2 == NULL)\n        return NULL;\n\n    VAR_1 = VAR_0->pickler->memo;\n    for (size_t VAR_3 = 0; VAR_3 < VAR_1->mt_allocated; ++VAR_3) {\n        PyMemoEntry VAR_4 = VAR_1->mt_table[VAR_3];\n        if (VAR_4.me_key != NULL) {\n            int VAR_5;\n            PyObject *VAR_6, *VAR_7;\n\n            VAR_6 = PyLong_FromVoidPtr(VAR_4.me_key);\n            VAR_7 = Py_BuildValue(\"nO\", VAR_4.me_value, VAR_4.me_key);\n\n            if (VAR_6 == NULL || VAR_7 == NULL) {\n                Py_XDECREF(VAR_6);\n                Py_XDECREF(VAR_7);\n                goto error;\n            }\n            VAR_5 = PyDict_SetItem(VAR_2, VAR_6, VAR_7);\n            Py_DECREF(VAR_6);\n            Py_DECREF(VAR_7);\n            if (VAR_5 < 0)\n                goto error;\n        }\n    }\n    return VAR_2;\n\n  error:\n    Py_XDECREF(VAR_2);\n    return NULL;\n}",
  "func_graph_path": "python/cpython/a4ae828ee416a66d8c7bf5ee71d653c2cc6a26dd/_pickle.c/vul/after/6.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -2,14 +2,13 @@\n _pickle_PicklerMemoProxy_copy_impl(PicklerMemoProxyObject *self)\n /*[clinic end generated code: output=bb83a919d29225ef input=b73043485ac30b36]*/\n {\n-    Py_ssize_t i;\n     PyMemoTable *memo;\n     PyObject *new_memo = PyDict_New();\n     if (new_memo == NULL)\n         return NULL;\n \n     memo = self->pickler->memo;\n-    for (i = 0; i < memo->mt_allocated; ++i) {\n+    for (size_t i = 0; i < memo->mt_allocated; ++i) {\n         PyMemoEntry entry = memo->mt_table[i];\n         if (entry.me_key != NULL) {\n             int status;",
  "diff_line_info": {
    "deleted_lines": [
      "    Py_ssize_t i;",
      "    for (i = 0; i < memo->mt_allocated; ++i) {"
    ],
    "added_lines": [
      "    for (size_t i = 0; i < memo->mt_allocated; ++i) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/python/cpython/pull/9261",
  "description": {
    "pr_info": {
      "title": "bpo-34656: Avoid relying on signed overflow in _pickle memos.",
      "number": 9261
    },
    "comment": [
      "<!--\r\nThanks for your contribution!\r\nPlease read this comment in its entirety. It's quite important.\r\n\r\n# Pull Request title\r\n\r\nIt should be in the following format:\r\n\r\n```\r\nbpo-NNNN: Summary of the changes made\r\n```\r\n\r\nWhere: bpo-NNNN refers to the issue number in the https://bugs.python.org.\r\n\r\nMost PRs will require an issue number. Trivial changes, like fixing a typo, do not need an issue.\r\n\r\n# Backport Pull Request title\r\n\r\nIf this is a backport PR (PR made against branches other than `master`),\r\nplease ensure that the PR title is in the following format:\r\n\r\n```\r\n[X.Y] <title from the original PR> (GH-NNNN)\r\n```\r\n\r\nWhere: [X.Y] is the branch name, e.g. [3.6].\r\n\r\nGH-NNNN refers to the PR number from `master`.\r\n\r\n-->\r\n\n\n<!-- issue-number: [bpo-1621](https://www.bugs.python.org/issue1621) -->\nhttps://bugs.python.org/issue1621\n<!-- /issue-number -->\n",
      "Thanks @benjaminp for the PR üåÆüéâ.. I'm working now to backport this PR to: 3.6, 3.7.\nüêçüçí‚õèü§ñ ",
      "[GH-9465](https://github.com/python/cpython/pull/9465) is a backport of this pull request to the [3.7 branch](https://github.com/python/cpython/tree/3.7).",
      "[GH-9466](https://github.com/python/cpython/pull/9466) is a backport of this pull request to the [3.6 branch](https://github.com/python/cpython/tree/3.6)."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.65,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.65"
}