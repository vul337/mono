{
  "cve_id": "CVE-2016-6172",
  "cwe_ids": [
    "CWE-400"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:C",
  "cvss_is_v3": false,
  "repo_name": "PowerDNS/pdns",
  "commit_msg": "Add limits to the size of received {A,I}XFR, in megabytes\n\nThis prevents memory exhaustion in case the master is sending a\nvery large amount of data in an update.",
  "commit_hash": "db8f9152168acf5d548d4f256789eae783e01667",
  "git_url": "https://github.com/PowerDNS/pdns/commit/db8f9152168acf5d548d4f256789eae783e01667",
  "file_path": "pdns/ixfr.cc",
  "func_name": "getIXFRDeltas",
  "func_before": "vector<pair<vector<DNSRecord>, vector<DNSRecord> > > getIXFRDeltas(const ComboAddress& master, const DNSName& zone, const DNSRecord& oursr, \n                                                                   const TSIGTriplet& tt, const ComboAddress* laddr)\n{\n  vector<pair<vector<DNSRecord>, vector<DNSRecord> > >  ret;\n  vector<uint8_t> packet;\n  DNSPacketWriter pw(packet, zone, QType::IXFR);\n  pw.getHeader()->qr=0;\n  pw.getHeader()->rd=0;\n  pw.getHeader()->id=dns_random(0xffff);\n  pw.startRecord(zone, QType::SOA, 0, QClass::IN, DNSResourceRecord::AUTHORITY);\n  oursr.d_content->toPacket(pw);\n\n  pw.commit();\n  if(!tt.algo.empty()) {\n    TSIGHashEnum the;\n    getTSIGHashEnum(tt.algo, the);\n    TSIGRecordContent trc;\n    try {\n      trc.d_algoName = getTSIGAlgoName(the);\n    } catch(PDNSException& pe) {\n      throw std::runtime_error(\"TSIG algorithm '\"+tt.algo.toString()+\"' is unknown.\");\n    }\n    trc.d_time = time((time_t*)NULL);\n    trc.d_fudge = 300;\n    trc.d_origID=ntohs(pw.getHeader()->id);\n    trc.d_eRcode=0;\n    addTSIG(pw, &trc, tt.name, tt.secret, \"\", false);\n  }\n  uint16_t len=htons(packet.size());\n  string msg((const char*)&len, 2);\n  msg.append((const char*)&packet[0], packet.size());\n\n  Socket s(master.sin4.sin_family, SOCK_STREAM);\n  //  cout<<\"going to connect\"<<endl;\n  if(laddr)\n    s.bind(*laddr);\n  s.connect(master);\n  //  cout<<\"Connected\"<<endl;\n  s.writen(msg);\n\n  // CURRENT MASTER SOA\n  // REPEAT:\n  //   SOA WHERE THIS DELTA STARTS\n  //   RECORDS TO REMOVE\n  //   SOA WHERE THIS DELTA GOES\n  //   RECORDS TO ADD\n  // CURRENT MASTER SOA \n  shared_ptr<SOARecordContent> masterSOA;\n  vector<DNSRecord> records;\n  for(;;) {\n    if(s.read((char*)&len, 2)!=2)\n      break;\n    len=ntohs(len);\n    //    cout<<\"Got chunk of \"<<len<<\" bytes\"<<endl;\n    if(!len)\n      break;\n    char reply[len]; \n    readn2(s.getHandle(), reply, len);\n    MOADNSParser mdp(string(reply, len));\n    if(mdp.d_header.rcode) \n      throw std::runtime_error(\"Got an error trying to IXFR zone '\"+zone.toString()+\"' from master '\"+master.toStringWithPort()+\"': \"+RCode::to_s(mdp.d_header.rcode));\n\n    //    cout<<\"Got a response, rcode: \"<<mdp.d_header.rcode<<\", got \"<<mdp.d_answers.size()<<\" answers\"<<endl;\n    for(auto& r: mdp.d_answers) {\n      if(r.first.d_type == QType::TSIG) \n        continue;\n      //      cout<<r.first.d_name<< \" \" <<r.first.d_content->getZoneRepresentation()<<endl;\n      r.first.d_name = r.first.d_name.makeRelative(zone);\n      records.push_back(r.first);\n      if(r.first.d_type == QType::SOA) {\n\tauto sr = getRR<SOARecordContent>(r.first);\n\tif(sr) {\n\t  if(!masterSOA) {\n\t    if(sr->d_st.serial == std::dynamic_pointer_cast<SOARecordContent>(oursr.d_content)->d_st.serial) { // we are up to date\n\t      goto done;\n\t    }\n\t    masterSOA=sr;\n\t  }\n\t  else if(sr->d_st.serial == masterSOA->d_st.serial)\n\t    goto done;\n\t}\n      }\n    }\n  }\n  //  cout<<\"Got \"<<records.size()<<\" records\"<<endl;\n done:;\n  for(unsigned int pos = 1;pos < records.size();) {\n    auto sr = getRR<SOARecordContent>(records[pos]);\n    vector<DNSRecord> remove, add;\n    if(!sr) { // this is an actual AXFR!\n      return {{remove, records}};\n    }\n    if(sr->d_st.serial == masterSOA->d_st.serial)\n      break;\n    \n\n    remove.push_back(records[pos]); // this adds the SOA\n    for(pos++; pos < records.size() && records[pos].d_type != QType::SOA; ++pos) {\n      remove.push_back(records[pos]);\n    }\n    sr = getRR<SOARecordContent>(records[pos]);\n\n    add.push_back(records[pos]); // this adds the new SOA\n    for(pos++; pos < records.size() && records[pos].d_type != QType::SOA; ++pos)  {\n      add.push_back(records[pos]);\n    }\n    ret.push_back(make_pair(remove,add));\n  }\n  return ret;\n}",
  "abstract_func_before": "vector<pair<vector<DNSRecord>, vector<DNSRecord> > > getIXFRDeltas(const ComboAddress& VAR_0, const DNSName& VAR_1, const DNSRecord& VAR_2, \n                                                                   const TSIGTriplet& VAR_3, const ComboAddress* VAR_4)\n{\n  vector<pair<vector<DNSRecord>, vector<DNSRecord> > >  VAR_5;\n  vector<uint8_t> VAR_6;\n  DNSPacketWriter pw(packet, zone, QType::IXFR);\n  VAR_7.getHeader()->qr=0;\n  VAR_7.getHeader()->rd=0;\n  VAR_7.getHeader()->id=dns_random(0xffff);\n  VAR_7.startRecord(zone, QType::SOA, 0, QClass::IN, DNSResourceRecord::AUTHORITY);\n  VAR_2.d_content->toPacket(VAR_7);\n\n  VAR_7.commit();\n  if(!VAR_3.algo.empty()) {\n    TSIGHashEnum VAR_8;\n    getTSIGHashEnum(VAR_3.algo, VAR_8);\n    TSIGRecordContent VAR_9;\n    try {\n      VAR_9.d_algoName = getTSIGAlgoName(VAR_8);\n    } catch(PDNSException& VAR_10) {\n      throw std::runtime_error(\"TSIG algorithm '\"+VAR_3.algo.toString()+\"' is unknown.\");\n    }\n    VAR_9.d_time = time((time_t*)NULL);\n    VAR_9.d_fudge = 300;\n    VAR_9.d_origID=ntohs(VAR_7.getHeader()->id);\n    VAR_9.d_eRcode=0;\n    addTSIG(VAR_7, &VAR_9, VAR_3.name, VAR_3.secret, \"\", false);\n  }\n  uint16_t VAR_11=htons(packet.size());\n  string VAR_12((const char*)&VAR_11, 2);\n  VAR_12.append((const char*)&packet[0], packet.size());\n\n  Socket VAR_13(VAR_0.sin4.sin_family, VAR_14);\n  /* COMMENT_0 */\n  if(VAR_4)\n    VAR_13.bind(*VAR_4);\n  VAR_13.connect(VAR_0);\n  /* COMMENT_1 */\n  VAR_13.writen(VAR_12);\n\n  /* COMMENT_2 */\n  /* COMMENT_3 */\n  /* COMMENT_4 */\n  /* COMMENT_5 */\n  /* COMMENT_6 */\n  /* COMMENT_7 */\n  /* COMMENT_8 */\n  shared_ptr<SOARecordContent> VAR_15;\n  vector<DNSRecord> VAR_16;\n  for(;;) {\n    if(VAR_13.read((char*)&VAR_11, 2)!=2)\n      break;\n    VAR_11=ntohs(VAR_11);\n    /* COMMENT_9 */\n    if(!VAR_11)\n      break;\n    char VAR_17[VAR_11]; \n    readn2(VAR_13.getHandle(), VAR_17, VAR_11);\n    MOADNSParser mdp(string(reply, len));\n    if(VAR_18.d_header.rcode) \n      throw std::runtime_error(\"Got an error trying to IXFR zone '\"+zone.toString()+\"' from master '\"+VAR_0.toStringWithPort()+\"': \"+RCode::to_s(VAR_18.d_header.rcode));\n\n    /* COMMENT_10 */\n    for(auto& VAR_19: VAR_18.d_answers) {\n      if(VAR_19.first.d_type == QType::TSIG) \n        continue;\n      /* COMMENT_11 */\n      VAR_19.first.d_name = VAR_19.first.d_name.makeRelative(zone);\n      VAR_16.push_back(VAR_19.first);\n      if(VAR_19.first.d_type == QType::SOA) {\n\tauto VAR_20 = VAR_21<SOARecordContent>(VAR_19.first);\n\tif(VAR_20) {\n\t  if(!VAR_15) {\n\t    if(VAR_20->d_st.serial == std::VAR_22<SOARecordContent>(VAR_2.d_content)->d_st.serial) { /* COMMENT_12 */\n\t      goto done;\n\t    }\n\t    VAR_15=VAR_20;\n\t  }\n\t  else if(VAR_20->d_st.serial == VAR_15->d_st.serial)\n\t    goto done;\n\t}\n      }\n    }\n  }\n  /* COMMENT_13 */\n done:;\n  for(unsigned int VAR_23 = 1;VAR_23 < VAR_16.size();) {\n    auto VAR_20 = VAR_21<SOARecordContent>(VAR_16[VAR_23]);\n    vector<DNSRecord> VAR_24, VAR_25;\n    if(!VAR_20) { /* COMMENT_14 */\n      return {{VAR_24, VAR_16}};\n    }\n    if(VAR_20->d_st.serial == VAR_15->d_st.serial)\n      break;\n    \n\n    VAR_24.push_back(VAR_16[VAR_23]); /* COMMENT_15 */\n    for(VAR_23++; VAR_23 < VAR_16.size() && VAR_16[VAR_23].d_type != QType::SOA; ++VAR_23) {\n      VAR_24.push_back(VAR_16[VAR_23]);\n    }\n    VAR_20 = VAR_21<SOARecordContent>(VAR_16[VAR_23]);\n\n    VAR_25.push_back(VAR_16[VAR_23]); /* COMMENT_16 */\n    for(VAR_23++; VAR_23 < VAR_16.size() && VAR_16[VAR_23].d_type != QType::SOA; ++VAR_23)  {\n      VAR_25.push_back(VAR_16[VAR_23]);\n    }\n    VAR_5.push_back(make_pair(VAR_24,VAR_25));\n  }\n  return VAR_5;\n}",
  "func_graph_path_before": "PowerDNS/pdns/db8f9152168acf5d548d4f256789eae783e01667/ixfr.cc/vul/before/0.json",
  "func": "vector<pair<vector<DNSRecord>, vector<DNSRecord> > > getIXFRDeltas(const ComboAddress& master, const DNSName& zone, const DNSRecord& oursr, \n                                                                   const TSIGTriplet& tt, const ComboAddress* laddr, size_t maxReceivedBytes)\n{\n  vector<pair<vector<DNSRecord>, vector<DNSRecord> > >  ret;\n  vector<uint8_t> packet;\n  DNSPacketWriter pw(packet, zone, QType::IXFR);\n  pw.getHeader()->qr=0;\n  pw.getHeader()->rd=0;\n  pw.getHeader()->id=dns_random(0xffff);\n  pw.startRecord(zone, QType::SOA, 0, QClass::IN, DNSResourceRecord::AUTHORITY);\n  oursr.d_content->toPacket(pw);\n\n  pw.commit();\n  if(!tt.algo.empty()) {\n    TSIGHashEnum the;\n    getTSIGHashEnum(tt.algo, the);\n    TSIGRecordContent trc;\n    try {\n      trc.d_algoName = getTSIGAlgoName(the);\n    } catch(PDNSException& pe) {\n      throw std::runtime_error(\"TSIG algorithm '\"+tt.algo.toString()+\"' is unknown.\");\n    }\n    trc.d_time = time((time_t*)NULL);\n    trc.d_fudge = 300;\n    trc.d_origID=ntohs(pw.getHeader()->id);\n    trc.d_eRcode=0;\n    addTSIG(pw, &trc, tt.name, tt.secret, \"\", false);\n  }\n  uint16_t len=htons(packet.size());\n  string msg((const char*)&len, 2);\n  msg.append((const char*)&packet[0], packet.size());\n\n  Socket s(master.sin4.sin_family, SOCK_STREAM);\n  //  cout<<\"going to connect\"<<endl;\n  if(laddr)\n    s.bind(*laddr);\n  s.connect(master);\n  //  cout<<\"Connected\"<<endl;\n  s.writen(msg);\n\n  // CURRENT MASTER SOA\n  // REPEAT:\n  //   SOA WHERE THIS DELTA STARTS\n  //   RECORDS TO REMOVE\n  //   SOA WHERE THIS DELTA GOES\n  //   RECORDS TO ADD\n  // CURRENT MASTER SOA \n  shared_ptr<SOARecordContent> masterSOA;\n  vector<DNSRecord> records;\n  size_t receivedBytes = 0;\n  for(;;) {\n    if(s.read((char*)&len, 2)!=2)\n      break;\n    len=ntohs(len);\n    //    cout<<\"Got chunk of \"<<len<<\" bytes\"<<endl;\n    if(!len)\n      break;\n\n    if (maxReceivedBytes > 0 && (maxReceivedBytes - receivedBytes) < (size_t) len)\n      throw std::runtime_error(\"Reached the maximum number of received bytes in an IXFR delta for zone '\"+zone.toString()+\"' from master '\"+master.toStringWithPort());\n\n    char reply[len]; \n    readn2(s.getHandle(), reply, len);\n    receivedBytes += len;\n    MOADNSParser mdp(string(reply, len));\n    if(mdp.d_header.rcode) \n      throw std::runtime_error(\"Got an error trying to IXFR zone '\"+zone.toString()+\"' from master '\"+master.toStringWithPort()+\"': \"+RCode::to_s(mdp.d_header.rcode));\n\n    //    cout<<\"Got a response, rcode: \"<<mdp.d_header.rcode<<\", got \"<<mdp.d_answers.size()<<\" answers\"<<endl;\n    for(auto& r: mdp.d_answers) {\n      if(r.first.d_type == QType::TSIG) \n        continue;\n      //      cout<<r.first.d_name<< \" \" <<r.first.d_content->getZoneRepresentation()<<endl;\n      r.first.d_name = r.first.d_name.makeRelative(zone);\n      records.push_back(r.first);\n      if(r.first.d_type == QType::SOA) {\n\tauto sr = getRR<SOARecordContent>(r.first);\n\tif(sr) {\n\t  if(!masterSOA) {\n\t    if(sr->d_st.serial == std::dynamic_pointer_cast<SOARecordContent>(oursr.d_content)->d_st.serial) { // we are up to date\n\t      goto done;\n\t    }\n\t    masterSOA=sr;\n\t  }\n\t  else if(sr->d_st.serial == masterSOA->d_st.serial)\n\t    goto done;\n\t}\n      }\n    }\n  }\n  //  cout<<\"Got \"<<records.size()<<\" records\"<<endl;\n done:;\n  for(unsigned int pos = 1;pos < records.size();) {\n    auto sr = getRR<SOARecordContent>(records[pos]);\n    vector<DNSRecord> remove, add;\n    if(!sr) { // this is an actual AXFR!\n      return {{remove, records}};\n    }\n    if(sr->d_st.serial == masterSOA->d_st.serial)\n      break;\n    \n\n    remove.push_back(records[pos]); // this adds the SOA\n    for(pos++; pos < records.size() && records[pos].d_type != QType::SOA; ++pos) {\n      remove.push_back(records[pos]);\n    }\n    sr = getRR<SOARecordContent>(records[pos]);\n\n    add.push_back(records[pos]); // this adds the new SOA\n    for(pos++; pos < records.size() && records[pos].d_type != QType::SOA; ++pos)  {\n      add.push_back(records[pos]);\n    }\n    ret.push_back(make_pair(remove,add));\n  }\n  return ret;\n}",
  "abstract_func": "vector<pair<vector<DNSRecord>, vector<DNSRecord> > > getIXFRDeltas(const ComboAddress& VAR_0, const DNSName& VAR_1, const DNSRecord& VAR_2, \n                                                                   const TSIGTriplet& VAR_3, const ComboAddress* VAR_4, size_t VAR_5)\n{\n  vector<pair<vector<DNSRecord>, vector<DNSRecord> > >  VAR_6;\n  vector<uint8_t> VAR_7;\n  DNSPacketWriter pw(packet, zone, QType::IXFR);\n  VAR_8.getHeader()->qr=0;\n  VAR_8.getHeader()->rd=0;\n  VAR_8.getHeader()->id=dns_random(0xffff);\n  VAR_8.startRecord(zone, QType::SOA, 0, QClass::IN, DNSResourceRecord::AUTHORITY);\n  VAR_2.d_content->toPacket(VAR_8);\n\n  VAR_8.commit();\n  if(!VAR_3.algo.empty()) {\n    TSIGHashEnum VAR_9;\n    getTSIGHashEnum(VAR_3.algo, VAR_9);\n    TSIGRecordContent VAR_10;\n    try {\n      VAR_10.d_algoName = getTSIGAlgoName(VAR_9);\n    } catch(PDNSException& VAR_11) {\n      throw std::runtime_error(\"TSIG algorithm '\"+VAR_3.algo.toString()+\"' is unknown.\");\n    }\n    VAR_10.d_time = time((time_t*)NULL);\n    VAR_10.d_fudge = 300;\n    VAR_10.d_origID=ntohs(VAR_8.getHeader()->id);\n    VAR_10.d_eRcode=0;\n    addTSIG(VAR_8, &VAR_10, VAR_3.name, VAR_3.secret, \"\", false);\n  }\n  uint16_t VAR_12=htons(packet.size());\n  string VAR_13((const char*)&VAR_12, 2);\n  VAR_13.append((const char*)&packet[0], packet.size());\n\n  Socket VAR_14(VAR_0.sin4.sin_family, VAR_15);\n  /* COMMENT_0 */\n  if(VAR_4)\n    VAR_14.bind(*VAR_4);\n  VAR_14.connect(VAR_0);\n  /* COMMENT_1 */\n  VAR_14.writen(VAR_13);\n\n  /* COMMENT_2 */\n  /* COMMENT_3 */\n  /* COMMENT_4 */\n  /* COMMENT_5 */\n  /* COMMENT_6 */\n  /* COMMENT_7 */\n  /* COMMENT_8 */\n  shared_ptr<SOARecordContent> VAR_16;\n  vector<DNSRecord> VAR_17;\n  size_t VAR_18 = 0;\n  for(;;) {\n    if(VAR_14.read((char*)&VAR_12, 2)!=2)\n      break;\n    VAR_12=ntohs(VAR_12);\n    /* COMMENT_9 */\n    if(!VAR_12)\n      break;\n\n    if (VAR_5 > 0 && (VAR_5 - VAR_18) < (size_t) VAR_12)\n      throw std::runtime_error(\"Reached the maximum number of received bytes in an IXFR delta for zone '\"+zone.toString()+\"' from master '\"+VAR_0.toStringWithPort());\n\n    char VAR_19[VAR_12]; \n    readn2(VAR_14.getHandle(), VAR_19, VAR_12);\n    VAR_18 += VAR_12;\n    MOADNSParser mdp(string(reply, len));\n    if(VAR_20.d_header.rcode) \n      throw std::runtime_error(\"Got an error trying to IXFR zone '\"+zone.toString()+\"' from master '\"+VAR_0.toStringWithPort()+\"': \"+RCode::to_s(VAR_20.d_header.rcode));\n\n    /* COMMENT_10 */\n    for(auto& VAR_21: VAR_20.d_answers) {\n      if(VAR_21.first.d_type == QType::TSIG) \n        continue;\n      /* COMMENT_11 */\n      VAR_21.first.d_name = VAR_21.first.d_name.makeRelative(zone);\n      VAR_17.push_back(VAR_21.first);\n      if(VAR_21.first.d_type == QType::SOA) {\n\tauto VAR_22 = VAR_23<SOARecordContent>(VAR_21.first);\n\tif(VAR_22) {\n\t  if(!VAR_16) {\n\t    if(VAR_22->d_st.serial == std::VAR_24<SOARecordContent>(VAR_2.d_content)->d_st.serial) { /* COMMENT_12 */\n\t      goto done;\n\t    }\n\t    VAR_16=VAR_22;\n\t  }\n\t  else if(VAR_22->d_st.serial == VAR_16->d_st.serial)\n\t    goto done;\n\t}\n      }\n    }\n  }\n  /* COMMENT_13 */\n done:;\n  for(unsigned int VAR_25 = 1;VAR_25 < VAR_17.size();) {\n    auto VAR_22 = VAR_23<SOARecordContent>(VAR_17[VAR_25]);\n    vector<DNSRecord> VAR_26, VAR_27;\n    if(!VAR_22) { /* COMMENT_14 */\n      return {{VAR_26, VAR_17}};\n    }\n    if(VAR_22->d_st.serial == VAR_16->d_st.serial)\n      break;\n    \n\n    VAR_26.push_back(VAR_17[VAR_25]); /* COMMENT_15 */\n    for(VAR_25++; VAR_25 < VAR_17.size() && VAR_17[VAR_25].d_type != QType::SOA; ++VAR_25) {\n      VAR_26.push_back(VAR_17[VAR_25]);\n    }\n    VAR_22 = VAR_23<SOARecordContent>(VAR_17[VAR_25]);\n\n    VAR_27.push_back(VAR_17[VAR_25]); /* COMMENT_16 */\n    for(VAR_25++; VAR_25 < VAR_17.size() && VAR_17[VAR_25].d_type != QType::SOA; ++VAR_25)  {\n      VAR_27.push_back(VAR_17[VAR_25]);\n    }\n    VAR_6.push_back(make_pair(VAR_26,VAR_27));\n  }\n  return VAR_6;\n}",
  "func_graph_path": "PowerDNS/pdns/db8f9152168acf5d548d4f256789eae783e01667/ixfr.cc/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,5 @@\n vector<pair<vector<DNSRecord>, vector<DNSRecord> > > getIXFRDeltas(const ComboAddress& master, const DNSName& zone, const DNSRecord& oursr, \n-                                                                   const TSIGTriplet& tt, const ComboAddress* laddr)\n+                                                                   const TSIGTriplet& tt, const ComboAddress* laddr, size_t maxReceivedBytes)\n {\n   vector<pair<vector<DNSRecord>, vector<DNSRecord> > >  ret;\n   vector<uint8_t> packet;\n@@ -47,6 +47,7 @@\n   // CURRENT MASTER SOA \n   shared_ptr<SOARecordContent> masterSOA;\n   vector<DNSRecord> records;\n+  size_t receivedBytes = 0;\n   for(;;) {\n     if(s.read((char*)&len, 2)!=2)\n       break;\n@@ -54,8 +55,13 @@\n     //    cout<<\"Got chunk of \"<<len<<\" bytes\"<<endl;\n     if(!len)\n       break;\n+\n+    if (maxReceivedBytes > 0 && (maxReceivedBytes - receivedBytes) < (size_t) len)\n+      throw std::runtime_error(\"Reached the maximum number of received bytes in an IXFR delta for zone '\"+zone.toString()+\"' from master '\"+master.toStringWithPort());\n+\n     char reply[len]; \n     readn2(s.getHandle(), reply, len);\n+    receivedBytes += len;\n     MOADNSParser mdp(string(reply, len));\n     if(mdp.d_header.rcode) \n       throw std::runtime_error(\"Got an error trying to IXFR zone '\"+zone.toString()+\"' from master '\"+master.toStringWithPort()+\"': \"+RCode::to_s(mdp.d_header.rcode));",
  "diff_line_info": {
    "deleted_lines": [
      "                                                                   const TSIGTriplet& tt, const ComboAddress* laddr)"
    ],
    "added_lines": [
      "                                                                   const TSIGTriplet& tt, const ComboAddress* laddr, size_t maxReceivedBytes)",
      "  size_t receivedBytes = 0;",
      "",
      "    if (maxReceivedBytes > 0 && (maxReceivedBytes - receivedBytes) < (size_t) len)",
      "      throw std::runtime_error(\"Reached the maximum number of received bytes in an IXFR delta for zone '\"+zone.toString()+\"' from master '\"+master.toStringWithPort());",
      "",
      "    receivedBytes += len;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/PowerDNS/pdns/pull/4133",
  "description": {
    "pr_info": {
      "title": "Add limits to the size of received {A,I}XFR, in megabytes",
      "number": 4133
    },
    "comment": [
      "This prevents memory exhaustion in case the master is sending a\nvery large amount of data in an update.\n",
      "LGTM from a quick glance.\n",
      "Fixes #4128 for master.\n",
      "This is ready for merge if you ask me.\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9"
}