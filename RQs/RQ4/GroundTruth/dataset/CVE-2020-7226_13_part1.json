{
  "cve_id": "CVE-2020-7226",
  "cwe_ids": [
    "CWE-770"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "vt-middleware/cryptacular",
  "commit_msg": "Define new ciphertext header format.\n\nNew format does not allocate any memory until HMAC check passes, which\nguards against untrusted input. All encryption components have been\nupdated to use the new header, while preserving backward compatibility\nto decrypt messages encrypted with the old format. The decoding process\nfor the old header has been hardened to impose reasonable limits on header\nfields: nonce sizes up to 255 bytes, key names up to 500 bytes.\n\nFixes #52.",
  "commit_hash": "8c6c7528f1e24c6b71f3e36db0cb8a697256ce25",
  "git_url": "https://github.com/vt-middleware/cryptacular/commit/8c6c7528f1e24c6b71f3e36db0cb8a697256ce25",
  "file_path": "src/main/java/org/cryptacular/CiphertextHeader.java",
  "func_name": "decode",
  "func_before": "public static CiphertextHeader decode(final InputStream input) throws EncodingException, StreamException\n  {\n    final int length = ByteUtil.readInt(input);\n    if (length < 0) {\n      throw new EncodingException(\"Invalid ciphertext header length: \" + length);\n    }\n\n    final byte[] nonce;\n    int nonceLen = 0;\n    try {\n      nonceLen = ByteUtil.readInt(input);\n      nonce = new byte[nonceLen];\n      input.read(nonce);\n    } catch (ArrayIndexOutOfBoundsException e) {\n      throw new EncodingException(\"Invalid nonce length: \" + nonceLen);\n    } catch (IOException e) {\n      throw new StreamException(e);\n    }\n\n    String keyName = null;\n    if (length > nonce.length + 8) {\n      final byte[] b;\n      int keyLen = 0;\n      try {\n        keyLen = ByteUtil.readInt(input);\n        b = new byte[keyLen];\n        input.read(b);\n      } catch (ArrayIndexOutOfBoundsException e) {\n        throw new EncodingException(\"Invalid key length: \" + keyLen);\n      } catch (IOException e) {\n        throw new StreamException(e);\n      }\n      keyName = new String(b);\n    }\n\n    return new CiphertextHeader(nonce, keyName);\n  }",
  "abstract_func_before": "public static CiphertextHeader decode(final InputStream VAR_0) throws EncodingException, StreamException\n  {\n    final int VAR_1 = VAR_2.readInt(VAR_0);\n    if (VAR_1 < 0) {\n      throw new EncodingException(\"Invalid ciphertext header length: \" + VAR_1);\n    }\n\n    final byte[] VAR_3;\n    int VAR_4 = 0;\n    try {\n      VAR_4 = VAR_2.readInt(VAR_0);\n      VAR_3 = new byte[VAR_4];\n      VAR_0.read(VAR_3);\n    } catch (ArrayIndexOutOfBoundsException VAR_5) {\n      throw new EncodingException(\"Invalid nonce length: \" + VAR_4);\n    } catch (IOException VAR_5) {\n      throw new StreamException(VAR_5);\n    }\n\n    String VAR_6 = null;\n    if (VAR_1 > VAR_3.length + 8) {\n      final byte[] VAR_7;\n      int VAR_8 = 0;\n      try {\n        VAR_8 = VAR_2.readInt(VAR_0);\n        VAR_7 = new byte[VAR_8];\n        VAR_0.read(VAR_7);\n      } catch (ArrayIndexOutOfBoundsException VAR_5) {\n        throw new EncodingException(\"Invalid key length: \" + VAR_8);\n      } catch (IOException VAR_5) {\n        throw new StreamException(VAR_5);\n      }\n      VAR_6 = new String(VAR_7);\n    }\n\n    return new CiphertextHeader(VAR_3, VAR_6);\n  }",
  "func_graph_path_before": "vt-middleware/cryptacular/8c6c7528f1e24c6b71f3e36db0cb8a697256ce25/CiphertextHeader.java/vul/before/0.json",
  "func": "public static CiphertextHeader decode(final InputStream input) throws EncodingException, StreamException\n  {\n    final int length = ByteUtil.readInt(input);\n    if (length < 0) {\n      throw new EncodingException(\"Bad ciphertext header\");\n    }\n\n    final byte[] nonce;\n    int nonceLen = 0;\n    try {\n      nonceLen = ByteUtil.readInt(input);\n      if (nonceLen > MAX_NONCE_LEN) {\n        throw new EncodingException(\"Bad ciphertext header: maximum nonce size exceeded\");\n      }\n      nonce = new byte[nonceLen];\n      input.read(nonce);\n    } catch (ArrayIndexOutOfBoundsException e) {\n      throw new EncodingException(\"Bad ciphertext header\");\n    } catch (IOException e) {\n      throw new StreamException(e);\n    }\n\n    String keyName = null;\n    if (length > nonce.length + 8) {\n      final byte[] b;\n      int keyLen = 0;\n      try {\n        keyLen = ByteUtil.readInt(input);\n        if (keyLen > MAX_KEYNAME_LEN) {\n          throw new EncodingException(\"Bad ciphertext header: maximum key length exceeded\");\n        }\n        b = new byte[keyLen];\n        input.read(b);\n      } catch (ArrayIndexOutOfBoundsException e) {\n        throw new EncodingException(\"Bad ciphertext header\");\n      } catch (IOException e) {\n        throw new StreamException(e);\n      }\n      keyName = new String(b);\n    }\n\n    return new CiphertextHeader(nonce, keyName);\n  }",
  "abstract_func": "public static CiphertextHeader decode(final InputStream VAR_0) throws EncodingException, StreamException\n  {\n    final int VAR_1 = VAR_2.readInt(VAR_0);\n    if (VAR_1 < 0) {\n      throw new EncodingException(\"Bad ciphertext header\");\n    }\n\n    final byte[] VAR_3;\n    int VAR_4 = 0;\n    try {\n      VAR_4 = VAR_2.readInt(VAR_0);\n      if (VAR_4 > VAR_5) {\n        throw new EncodingException(\"Bad ciphertext header: maximum nonce size exceeded\");\n      }\n      VAR_3 = new byte[VAR_4];\n      VAR_0.read(VAR_3);\n    } catch (ArrayIndexOutOfBoundsException VAR_6) {\n      throw new EncodingException(\"Bad ciphertext header\");\n    } catch (IOException VAR_6) {\n      throw new StreamException(VAR_6);\n    }\n\n    String VAR_7 = null;\n    if (VAR_1 > VAR_3.length + 8) {\n      final byte[] VAR_8;\n      int VAR_9 = 0;\n      try {\n        VAR_9 = VAR_2.readInt(VAR_0);\n        if (VAR_9 > VAR_10) {\n          throw new EncodingException(\"Bad ciphertext header: maximum key length exceeded\");\n        }\n        VAR_8 = new byte[VAR_9];\n        VAR_0.read(VAR_8);\n      } catch (ArrayIndexOutOfBoundsException VAR_6) {\n        throw new EncodingException(\"Bad ciphertext header\");\n      } catch (IOException VAR_6) {\n        throw new StreamException(VAR_6);\n      }\n      VAR_7 = new String(VAR_8);\n    }\n\n    return new CiphertextHeader(VAR_3, VAR_7);\n  }",
  "func_graph_path": "vt-middleware/cryptacular/8c6c7528f1e24c6b71f3e36db0cb8a697256ce25/CiphertextHeader.java/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -2,17 +2,20 @@\n   {\n     final int length = ByteUtil.readInt(input);\n     if (length < 0) {\n-      throw new EncodingException(\"Invalid ciphertext header length: \" + length);\n+      throw new EncodingException(\"Bad ciphertext header\");\n     }\n \n     final byte[] nonce;\n     int nonceLen = 0;\n     try {\n       nonceLen = ByteUtil.readInt(input);\n+      if (nonceLen > MAX_NONCE_LEN) {\n+        throw new EncodingException(\"Bad ciphertext header: maximum nonce size exceeded\");\n+      }\n       nonce = new byte[nonceLen];\n       input.read(nonce);\n     } catch (ArrayIndexOutOfBoundsException e) {\n-      throw new EncodingException(\"Invalid nonce length: \" + nonceLen);\n+      throw new EncodingException(\"Bad ciphertext header\");\n     } catch (IOException e) {\n       throw new StreamException(e);\n     }\n@@ -23,10 +26,13 @@\n       int keyLen = 0;\n       try {\n         keyLen = ByteUtil.readInt(input);\n+        if (keyLen > MAX_KEYNAME_LEN) {\n+          throw new EncodingException(\"Bad ciphertext header: maximum key length exceeded\");\n+        }\n         b = new byte[keyLen];\n         input.read(b);\n       } catch (ArrayIndexOutOfBoundsException e) {\n-        throw new EncodingException(\"Invalid key length: \" + keyLen);\n+        throw new EncodingException(\"Bad ciphertext header\");\n       } catch (IOException e) {\n         throw new StreamException(e);\n       }",
  "diff_line_info": {
    "deleted_lines": [
      "      throw new EncodingException(\"Invalid ciphertext header length: \" + length);",
      "      throw new EncodingException(\"Invalid nonce length: \" + nonceLen);",
      "        throw new EncodingException(\"Invalid key length: \" + keyLen);"
    ],
    "added_lines": [
      "      throw new EncodingException(\"Bad ciphertext header\");",
      "      if (nonceLen > MAX_NONCE_LEN) {",
      "        throw new EncodingException(\"Bad ciphertext header: maximum nonce size exceeded\");",
      "      }",
      "      throw new EncodingException(\"Bad ciphertext header\");",
      "        if (keyLen > MAX_KEYNAME_LEN) {",
      "          throw new EncodingException(\"Bad ciphertext header: maximum key length exceeded\");",
      "        }",
      "        throw new EncodingException(\"Bad ciphertext header\");"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/vt-middleware/cryptacular/pull/53",
  "description": {
    "pr_info": {
      "title": "Define new ciphertext header format.",
      "number": 53
    },
    "comment": [
      "New format does not allocate any memory until HMAC check passes, which\r\nguards against untrusted input. All encryption components have been\r\nupdated to use the new header, while preserving backward compatibility\r\nto decrypt messages encrypted with the old format. The decoding process\r\nfor the old header has been hardened to impose reasonable limits on header\r\nfields: nonce sizes up to 255 bytes, key names up to 500 bytes.\r\n\r\nFixes #52."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0\n\n**Confidence Explanation:** The commit addresses input validation issues by enforcing limits on header fields, preventing potential buffer overflows and enhancing security against untrusted input. The clarity and consistency between the commit message, vulnerability description, and code changes confirm it's a security fix."
}