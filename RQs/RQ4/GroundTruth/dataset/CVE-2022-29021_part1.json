{
  "cve_id": "CVE-2022-29021",
  "cwe_ids": [
    "CWE-120"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "openrazer",
  "commit_msg": "Fix oob memcpy in matrix_custom_frame methods\n\nAdjust row_length if it exeeds the arguments array",
  "commit_hash": "7e8a04feb378a679f1bcdcae079a5100cc45663b",
  "git_url": "https://github.com/openrazer/openrazer/commit/7e8a04feb378a679f1bcdcae079a5100cc45663b",
  "file_path": "driver/razerchromacommon.c",
  "func_name": "razer_chroma_standard_matrix_set_custom_frame",
  "func_before": "struct razer_report razer_chroma_standard_matrix_set_custom_frame(unsigned char row_index, unsigned char start_col, unsigned char stop_col, unsigned char *rgb_data)\n{\n    size_t row_length = (size_t) (((stop_col + 1) - start_col) * 3);\n    struct razer_report report = get_razer_report(0x03, 0x0B, 0x46); // In theory should be able to leave data size at max as we have start/stop\n\n    // printk(KERN_ALERT \"razerkbd: Row ID: %d, Start: %d, Stop: %d, row length: %d\\n\", row_index, start_col, stop_col, (unsigned char)row_length);\n\n    report.arguments[0] = 0xFF; // Frame ID\n    report.arguments[1] = row_index;\n    report.arguments[2] = start_col;\n    report.arguments[3] = stop_col;\n    memcpy(&report.arguments[4], rgb_data, row_length);\n\n    return report;\n}",
  "abstract_func_before": "struct razer_report razer_chroma_standard_matrix_set_custom_frame(unsigned char VAR_0, unsigned char VAR_1, unsigned char VAR_2, unsigned char *VAR_3)\n{\n    size_t VAR_4 = (size_t) (((VAR_2 + 1) - VAR_1) * 3);\n    struct razer_report VAR_5 = get_razer_report(0x03, 0x0B, 0x46); /* COMMENT_0 */\n\n    /* COMMENT_1 */\n\n    VAR_5.arguments[0] = 0xFF; /* COMMENT_2 */\n    VAR_5.arguments[1] = VAR_0;\n    VAR_5.arguments[2] = VAR_1;\n    VAR_5.arguments[3] = VAR_2;\n    memcpy(&VAR_5.arguments[4], VAR_3, VAR_4);\n\n    return VAR_5;\n}",
  "func_graph_path_before": "openrazer/7e8a04feb378a679f1bcdcae079a5100cc45663b/razerchromacommon.c/vul/before/0.json",
  "func": "struct razer_report razer_chroma_standard_matrix_set_custom_frame(unsigned char row_index, unsigned char start_col, unsigned char stop_col, unsigned char *rgb_data)\n{\n    const size_t start_arg_offset = 4;\n    struct razer_report report = {0};\n    size_t row_length = (size_t) (((stop_col + 1) - start_col) * 3);\n\n    if (row_length > sizeof(report.arguments) - start_arg_offset) {\n        printk(KERN_ALERT \"razerchroma: RGB data too long\\n\");\n        row_length = sizeof(report.arguments) - start_arg_offset;\n    }\n\n    report = get_razer_report(0x03, 0x0B, 0x46); // In theory should be able to leave data size at max as we have start/stop\n\n    // printk(KERN_ALERT \"razerkbd: Row ID: %d, Start: %d, Stop: %d, row length: %d\\n\", row_index, start_col, stop_col, (unsigned char)row_length);\n\n    report.arguments[0] = 0xFF; // Frame ID\n    report.arguments[1] = row_index;\n    report.arguments[2] = start_col;\n    report.arguments[3] = stop_col;\n    memcpy(&report.arguments[4], rgb_data, row_length);\n\n    return report;\n}",
  "abstract_func": "struct razer_report razer_chroma_standard_matrix_set_custom_frame(unsigned char VAR_0, unsigned char VAR_1, unsigned char VAR_2, unsigned char *VAR_3)\n{\n    const size_t VAR_4 = 4;\n    struct razer_report VAR_5 = {0};\n    size_t VAR_6 = (size_t) (((VAR_2 + 1) - VAR_1) * 3);\n\n    if (VAR_6 > sizeof(VAR_5.arguments) - VAR_4) {\n        printk(KERN_ALERT \"razerchroma: RGB data too long\\n\");\n        VAR_6 = sizeof(VAR_5.arguments) - VAR_4;\n    }\n\n    VAR_5 = get_razer_report(0x03, 0x0B, 0x46); /* COMMENT_0 */\n\n    /* COMMENT_1 */\n\n    VAR_5.arguments[0] = 0xFF; /* COMMENT_2 */\n    VAR_5.arguments[1] = VAR_0;\n    VAR_5.arguments[2] = VAR_1;\n    VAR_5.arguments[3] = VAR_2;\n    memcpy(&VAR_5.arguments[4], VAR_3, VAR_6);\n\n    return VAR_5;\n}",
  "func_graph_path": "openrazer/7e8a04feb378a679f1bcdcae079a5100cc45663b/razerchromacommon.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,15 @@\n struct razer_report razer_chroma_standard_matrix_set_custom_frame(unsigned char row_index, unsigned char start_col, unsigned char stop_col, unsigned char *rgb_data)\n {\n+    const size_t start_arg_offset = 4;\n+    struct razer_report report = {0};\n     size_t row_length = (size_t) (((stop_col + 1) - start_col) * 3);\n-    struct razer_report report = get_razer_report(0x03, 0x0B, 0x46); // In theory should be able to leave data size at max as we have start/stop\n+\n+    if (row_length > sizeof(report.arguments) - start_arg_offset) {\n+        printk(KERN_ALERT \"razerchroma: RGB data too long\\n\");\n+        row_length = sizeof(report.arguments) - start_arg_offset;\n+    }\n+\n+    report = get_razer_report(0x03, 0x0B, 0x46); // In theory should be able to leave data size at max as we have start/stop\n \n     // printk(KERN_ALERT \"razerkbd: Row ID: %d, Start: %d, Stop: %d, row length: %d\\n\", row_index, start_col, stop_col, (unsigned char)row_length);\n ",
  "diff_line_info": {
    "deleted_lines": [
      "    struct razer_report report = get_razer_report(0x03, 0x0B, 0x46); // In theory should be able to leave data size at max as we have start/stop"
    ],
    "added_lines": [
      "    const size_t start_arg_offset = 4;",
      "    struct razer_report report = {0};",
      "",
      "    if (row_length > sizeof(report.arguments) - start_arg_offset) {",
      "        printk(KERN_ALERT \"razerchroma: RGB data too long\\n\");",
      "        row_length = sizeof(report.arguments) - start_arg_offset;",
      "    }",
      "",
      "    report = get_razer_report(0x03, 0x0B, 0x46); // In theory should be able to leave data size at max as we have start/stop"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/openrazer/openrazer/pull/1790",
  "description": {
    "pr_info": {
      "title": "Fix oob memcpy matrix custom frame",
      "number": 1790
    },
    "comment": [
      "This PR fixes the OOB memcpy in the matrix_custom_frame for all 3 drivers (kbd, mouse, accessory)."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95"
}