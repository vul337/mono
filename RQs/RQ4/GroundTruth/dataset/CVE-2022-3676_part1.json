{
  "cve_id": "CVE-2022-3676",
  "cwe_ids": [
    "CWE-843"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N",
  "cvss_is_v3": true,
  "repo_name": "eclipse/omr",
  "commit_msg": "Stop devirtualizing interface calls in preexistence\n\nPreviously, it was possible for the JIT to devirtualize an interface\ncall, and for execution to reach the call (whether inlined or not) with\na receiver that is not an instance of the class expected by the\nimplementing method. The callee could then access fields of the receiver\nas though it were of the expected type.\n\nThe conditionals added in this commit still allow (on their own) for an\ninterface call to be devirtualized when preexistence has already proven\nthat the receiver is an instance of some particular class that\nimplements the expected interface. However, preexistence currently fails\nto devirtualize in that situation. It passes the class to\nTR_PersistentCHTable::findSingleInterfaceImplementer(), which needs the\ninterface. This can be improved in the future by having preexistence\ntreat the call in the same way as a non-interface call, but with the\nadded requirement that the devirtualized callee must be public.",
  "commit_hash": "f5ab765943c192e25ac8ea8d341f88e6ed9f90d2",
  "git_url": "https://github.com/eclipse/omr/commit/f5ab765943c192e25ac8ea8d341f88e6ed9f90d2",
  "file_path": "compiler/optimizer/LocalOpts.cpp",
  "func_name": "TR_InvariantArgumentPreexistence::processIndirectCall",
  "func_before": "void TR_InvariantArgumentPreexistence::processIndirectCall(TR::Node *node, TR::TreeTop *treeTop, vcount_t visitCount)\n   {\n#ifdef J9_PROJECT_SPECIFIC\n\n   if (trace())\n      traceMsg(comp(), \"PREX:      [%p] %s %s\\n\", node, node->getOpCode().getName(), node->getSymbolReference()->getName(comp()->getDebug()));\n\n   if (!node->getSymbol()->castToMethodSymbol()->firstArgumentIsReceiver())\n      {\n      if (trace())\n         traceMsg(comp(), \"PREX:        - First arg is not receiver\\n\");\n      return;\n      }\n\n   //\n   // Step 1: Analyze\n   //\n\n   // Decision variables\n   //\n   bool  isInterface             = false;\n   ParmInfo           tmpInfo;  tmpInfo.clear();\n   ParmInfo           *receiverInfo = &tmpInfo;\n   TR::Symbol          *receiverSymbol = NULL;\n   bool               receiverFromParm = false;\n   int32_t            receiverParmOrdinal = -1;\n   ParmInfo *existingInfo = NULL;\n   TR::MethodSymbol   *methodSymbol   = node->getSymbol()->castToMethodSymbol();\n\n   TR_ResolvedMethod *resolvedMethod = methodSymbol->getResolvedMethodSymbol()? methodSymbol->getResolvedMethodSymbol()->getResolvedMethod() : NULL;\n   if (!resolvedMethod)\n      {\n      if (methodSymbol->isInterface())\n         {\n         isInterface = true;\n         }\n      else\n         {\n         if (trace())\n            traceMsg(comp(), \"PREX:        - Unresolved\\n\");\n         return;\n         }\n      }\n\n   TR::Node *receiver = node->getChild(node->getFirstArgumentIndex());\n   if (receiver->getOpCode().isLoadDirect())\n      {\n      existingInfo = getSuitableParmInfo(receiver);\n      if (!existingInfo)\n         {\n         if (trace())\n            traceMsg(comp(), \"PREX:        - No parm info for receiver\\n\");\n         return;\n         }\n\n      receiverInfo = existingInfo;\n      receiverFromParm = true;\n\n      receiverSymbol = receiver->getSymbolReference()->getSymbol();\n      receiverParmOrdinal = receiverSymbol->getParmSymbol()->getOrdinal();\n      if (methodSymbol->isVirtual() || methodSymbol->isInterface())\n         {\n         if (node->getSymbolReference() == getSymRefTab()->findObjectNewInstanceImplSymbol())\n            {\n            // Let's not get fancy with these guys\n            // They are the java/lang/Object.newInstancePrototype special methods\n            if (trace())\n               traceMsg(comp(), \"PREX:        - newInstancePrototype\\n\");\n            return;\n            }\n\n         if (trace())\n            traceMsg(comp(), \"PREX:        Receiver is %p incoming Parm %d parmInfo %p\\n\", receiver, receiverParmOrdinal, existingInfo);\n         }\n      }\n\n   // Bonus goodies for known objects\n   //\n   if (receiver->getSymbolReference()\n       && receiver->getSymbolReference()->hasKnownObjectIndex()\n       && !comp()->isOutOfProcessCompilation()\n      )\n      {\n      if (trace())\n         traceMsg(comp(), \"PREX:          Receiver is obj%d\\n\", receiver->getSymbolReference()->getKnownObjectIndex());\n\n      receiverInfo->setKnownObjectIndex(receiver->getSymbolReference()->getKnownObjectIndex());\n      receiverInfo->setClassIsFixed();\n\n      // Also set the class info\n      //\n      TR::KnownObjectTable *knot = comp()->getKnownObjectTable();\n\n         {\n         TR::ClassTableCriticalSection setClass(comp()->fe());\n         receiverInfo->setClass(TR::Compiler->cls.objectClass(comp(), knot->getPointer(receiver->getSymbolReference()->getKnownObjectIndex())));\n         }\n      }\n\n   // Quit if class is not compatible with the method\n   if (resolvedMethod && receiverInfo->getClass() && !classIsCompatibleWithMethod(receiverInfo->getClass(), resolvedMethod))\n      return;\n\n   //\n   // Step 2: Transform\n   //\n\n   if (methodSymbol->isComputed())\n      {\n#ifdef J9_PROJECT_SPECIFIC\n      if (methodSymbol->getRecognizedMethod() == TR::java_lang_invoke_MethodHandle_invokeExact && receiverInfo->hasKnownObjectIndex())\n         specializeInvokeExactSymbol(node, receiverInfo->getKnownObjectIndex(), comp(), this);\n\n      // The method is a specialized thunk archetype, no further improvement is needed.\n      // Keeping running subsequent code may result in a crash because `offset` on the symref is not valid.\n      if (node->getSymbol()->castToMethodSymbol()->getMethod()->isArchetypeSpecimen())\n         return;\n#endif\n      }\n   else if (!isInterface && receiverInfo->classIsFixed())\n      {\n      devirtualizeVirtualCall(node, treeTop, receiverInfo->getClass());\n      }\n   else if (!isInterface && receiverInfo->classIsCurrentlyFinal()\n            && comp()->ilGenRequest().details().supportsInvalidation())\n      {\n      TR_PersistentClassInfo* classInfo = comp()->getPersistentInfo()->getPersistentCHTable()->findClassInfoAfterLocking(receiverInfo->getClass(), comp());\n      bool canDevirtualize = true;\n\n      if (comp()->getMethodHotness() == warm\n          && classInfo\n          && classInfo->getNumPrexAssumptions() > comp()->getOptions()->getMaxNumPrexAssumptions())\n         canDevirtualize = false;\n\n      if (canDevirtualize && devirtualizeVirtualCall(node, treeTop, receiverInfo->getClass()))\n         {\n         if (trace())\n            traceMsg(comp(), \"devirtualize with assumption\\n\");\n         // improve receiverInfo\n         receiverInfo->setClassIsFixed();\n         // For the outer most method, we have to carry the information of fixed type to inliner,\n         // such that it can be propagated to deeper frames.\n         // The receiver type is current final, which means it's the most concrete type atm. If\n         // the receiver is from parm of the jitted method, this property applies to all call\n         // sites to this method in this compilation. Thus, it is safe to set fixed type on the\n         // parm of this method.\n         //\n         if (_isOutermostMethod && receiverFromParm)\n            {\n            receiverSymbol->getParmSymbol()->setFixedType(receiverInfo->getClass());\n            }\n         // Improve the prex arg for inlined method\n         else if (receiverFromParm && comp()->getCurrentInlinedCallArgInfo())\n            {\n            TR_PrexArgInfo *argInfo = comp()->getCurrentInlinedCallArgInfo();\n            TR_PrexArgument *arg = argInfo->get(receiverParmOrdinal);\n            if (arg && !(arg->classIsFixed() && arg->getClass()))\n               {\n               arg->setClassIsFixed(receiverInfo->getClass());\n               }\n            }\n         TR_ASSERT(receiverInfo->getClass(), \"Currently final classes must have a valid class pointer\");\n         bool inc = comp()->getCHTable()->recompileOnClassExtend(comp(), receiverInfo->getClass());\n         if (classInfo && inc) classInfo->incNumPrexAssumptions();\n         }\n      }\n   else if (receiverFromParm)\n      {\n      // If the method being called is currently not overridden, we can register\n      // a recomp action on the method-override event for this method\n      //\n      if (!isInterface && !resolvedMethod->virtualMethodIsOverridden() && !resolvedMethod->isAbstract())\n         {\n         // if the number of recompile assumptions on this particular\n         // class has exceeded a threshold, don't do prex anymore for this class\n         //\n         bool addAssumptions = false;\n         TR_PersistentMethodInfo *callInfo = NULL;\n\n         if (comp()->ilGenRequest().details().supportsInvalidation())\n            {\n            addAssumptions = true;\n            if ((comp()->getMethodHotness() == warm) &&\n               (callInfo = TR_PersistentMethodInfo::get(resolvedMethod)) &&\n               callInfo->getNumPrexAssumptions() > comp()->getOptions()->getMaxNumPrexAssumptions())\n               addAssumptions = false;\n            }\n\n         if (addAssumptions &&\n               performTransformation(comp(), \"%sdevirtualizing invoke [%p] on preexistent argument %d [%p]\\n\", optDetailString(), node, receiverParmOrdinal, receiverSymbol))\n            {\n            if (trace())\n               traceMsg(comp(), \"secs devirtualizing invoke on preexistent argument %d in %s\\n\", receiverParmOrdinal, comp()->signature());\n\n            node->devirtualizeCall(treeTop);\n            bool inc = comp()->getCHTable()->recompileOnMethodOverride(comp(), resolvedMethod);\n            if (callInfo && inc) callInfo->incNumPrexAssumptions();\n            }\n         }\n      else if (receiverInfo->getClass())\n         {\n#ifdef J9_PROJECT_SPECIFIC\n         TR::ClassTableCriticalSection processIndirectCall(comp()->fe());\n         TR::SymbolReference *symRef = node->getSymbolReference();\n         TR_PersistentCHTable * chTable = comp()->getPersistentInfo()->getPersistentCHTable();\n         TR::MethodSymbol *methSymbol = node->getSymbol()->getMethodSymbol();\n         if (methSymbol->isInterface() || methodSymbol)\n            {\n            TR_ResolvedMethod * method = NULL;\n            bool newMethod = true;\n            // There is the risk of invaliding a method repeatedly due to class hierarchy extensions\n            // In the following avoid devirtualization based on single implementor if the method has\n            // been invalidated once\n            //\n            TR::Recompilation *recompInfo = comp()->getRecompilationInfo();\n            if (recompInfo && recompInfo->getMethodInfo()->getNumberOfInvalidations() >= 1 && !chTable->findSingleConcreteSubClass(receiverInfo->getClass(), comp()))\n               {\n               // will exit without performing any transformation\n               //fprintf(stderr, \"will not perform devirt\\n\");\n               }\n            else if (methSymbol->isInterface())\n               {\n               if (comp()->getPersistentInfo()->getRuntimeAssumptionTable()->getAssumptionCount(RuntimeAssumptionOnClassExtend) < 100000)\n                  method = chTable->findSingleInterfaceImplementer(receiverInfo->getClass(), node->getSymbolReference()->getCPIndex(), node->getSymbolReference()->getOwningMethod(comp()), comp());\n               //if (method)\n               //   fprintf(stderr, \"%s assumptios=%d\\n\", comp()->signature(), comp()->getPersistentInfo()->getRuntimeAssumptionTable()->getAssumptionCount(RuntimeAssumptionOnClassExtend));\n               }\n            else\n               {\n               if (resolvedMethod->isAbstract())\n                  method = chTable->findSingleAbstractImplementer(receiverInfo->getClass(), symRef->getOffset(), node->getSymbolReference()->getOwningMethod(comp()), comp());\n               else if (!chTable->isOverriddenInThisHierarchy(resolvedMethod, receiverInfo->getClass(), symRef->getOffset(), comp()))\n                  {\n                  method = symRef->getOwningMethod(comp())->getResolvedVirtualMethod(comp(), receiverInfo->getClass(), symRef->getOffset());\n                  newMethod = false;\n                  }\n               }\n\n            if (method && !method->virtualMethodIsOverridden())\n               {\n               TR_PersistentClassInfo *classInfo = comp()->getPersistentInfo()->getPersistentCHTable()->findClassInfoAfterLocking(receiverInfo->getClass(), comp());\n\n               // if the number of recompile assumptions on this particular\n               // class has exceeded a threshold, don't do prex anymore for this class\n               //\n               bool addAssumptions = false;\n\n               if (comp()->ilGenRequest().details().supportsInvalidation())\n                  {\n                  addAssumptions = true;\n                  if ((comp()->getMethodHotness() == warm) &&\n                        classInfo &&\n                        classInfo->getNumPrexAssumptions() > comp()->getOptions()->getMaxNumPrexAssumptions())\n                     addAssumptions = false;\n\n                  // check the subclasses as well\n                  if (classInfo && addAssumptions)\n                     {\n                     TR_ScratchList<TR_PersistentClassInfo> subClasses(trMemory());\n                     TR_ClassQueries::collectAllSubClasses(classInfo, &subClasses, comp());\n                     ListIterator<TR_PersistentClassInfo> subClassesIt(&subClasses);\n                     for (TR_PersistentClassInfo *subClassInfo = subClassesIt.getFirst(); subClassInfo; subClassInfo = subClassesIt.getNext())\n                        {\n                        if (subClassInfo->getNumPrexAssumptions() > comp()->getOptions()->getMaxNumPrexAssumptions())\n                           {\n                           addAssumptions = false;\n                           break;\n                           }\n                        }\n                     }\n                  }\n\n               if (addAssumptions &&\n                   performTransformation(comp(), \"%sspecialize and devirtualize invoke [%p] based on only a single implementation for call on parameter %d [%p]\\n\", optDetailString(), node, receiverParmOrdinal, receiverSymbol))\n                  {\n                  if (newMethod || !method->isSameMethod(resolvedMethod))\n                     {\n                     TR::SymbolReference *newSymRef =\n                      getSymRefTab()->findOrCreateMethodSymbol\n                                   (symRef->getOwningMethodIndex(), -1, method, TR::MethodSymbol::Virtual);\n                     newSymRef->copyAliasSets(symRef, getSymRefTab());\n\n                     int32_t offset = -1;\n                     if (methSymbol->isInterface())\n                        offset = node->getSymbolReference()->getOwningMethod(comp())->getResolvedInterfaceMethodOffset(method->containingClass(), node->getSymbolReference()->getCPIndex());\n                     else\n                        offset = symRef->getOffset();\n\n                     newSymRef->setOffset(offset);\n                     node->setSymbolReference(newSymRef);\n                     }\n\n                  node->devirtualizeCall(treeTop);\n                  if (treeTop->getNode()->getOpCodeValue() == TR::ResolveCHK)\n                     TR::Node::recreate(treeTop->getNode(), TR::treetop);\n                  else if (treeTop->getNode()->getOpCodeValue() == TR::ResolveAndNULLCHK)\n                     TR::Node::recreate(treeTop->getNode(), TR::NULLCHK);\n\n                  bool doInc = comp()->getCHTable()->recompileOnNewClassExtend(comp(), receiverInfo->getClass());\n\n                  if (classInfo)\n                     {\n                     classInfo->setShouldNotBeNewlyExtended(comp()->getCompThreadID());\n                     if (doInc) classInfo->incNumPrexAssumptions();\n                     TR_ScratchList<TR_PersistentClassInfo> subClasses(trMemory());\n                     TR_ClassQueries::collectAllSubClasses(classInfo, &subClasses, comp());\n                     ListIterator<TR_PersistentClassInfo> subClassesIt(&subClasses);\n                     for (TR_PersistentClassInfo *subClassInfo = subClassesIt.getFirst(); subClassInfo; subClassInfo = subClassesIt.getNext())\n                        {\n                        TR_OpaqueClassBlock *subClass = (TR_OpaqueClassBlock *) subClassInfo->getClassId();\n                        subClassInfo->setShouldNotBeNewlyExtended(comp()->getCompThreadID());\n                        if (comp()->getCHTable()->recompileOnNewClassExtend(comp(), subClass))\n                           subClassInfo->incNumPrexAssumptions();\n                        }\n                     }\n\n\n                  //comp()->getCHTable()->recompileOnMethodOverride(comp(), method);\n                  _success = true;\n                  }\n               else\n                  {\n                  return;\n                  }\n               }\n            else\n               {\n               return;\n               }\n            }\n#endif\n         }\n      }\n\n\n   if (comp()->isPeekingMethod() && receiverInfo->getClass() && !isInterface)\n      {\n      TR::SymbolReference *symRef = node->getSymbolReference();\n      int32_t offset = symRef->getOffset();\n      //printf(\"Node %p arg %d\\n\", node, receiverParmOrdinal);\n      //printf(\"Method is %s\\n\", resolvedMethod->signature(trMemory()));\n      //fflush(stdout);\n\n      TR_ResolvedMethod *originalResolvedMethod = resolvedMethod;\n      TR_OpaqueClassBlock *originalClazz = originalResolvedMethod->containingClass();\n      bool canRefine = true;\n      if (originalClazz != receiverInfo->getClass())\n         {\n         TR_YesNoMaybe isInstance = fe()->isInstanceOf(originalClazz, receiverInfo->getClass(), true);\n         if (isInstance == TR_yes)\n            canRefine = false;\n\n         isInstance = fe()->isInstanceOf(receiverInfo->getClass(), originalClazz, true);\n         if (isInstance == TR_no)\n            canRefine = false;\n         }\n\n      TR_ResolvedMethod *resolvedMethod = NULL;\n      if (canRefine)\n         resolvedMethod = symRef->getOwningMethod(comp())->getResolvedVirtualMethod(comp(), receiverInfo->getClass(), offset);\n\n      if (resolvedMethod)\n         {\n         if (!originalResolvedMethod || !resolvedMethod->isSameMethod(originalResolvedMethod))\n            {\n            TR::SymbolReference * newSymRef =\n          _peekingSymRefTab->findOrCreateMethodSymbol(\n                             symRef->getOwningMethodIndex(), -1, resolvedMethod, TR::MethodSymbol::Virtual);\n            newSymRef->copyAliasSets(symRef, _peekingSymRefTab);\n            newSymRef->setOffset(offset);\n            node->setSymbolReference(newSymRef);\n            }\n         }\n      }\n#endif\n   }",
  "abstract_func_before": "void TR_InvariantArgumentPreexistence::processIndirectCall(TR::Node *VAR_0, TR::TreeTop *VAR_1, vcount_t VAR_2)\n   {\n#ifdef VAR_3\n\n   if (trace())\n      traceMsg(comp(), \"PREX:      [%p] %s %s\\n\", VAR_0, VAR_0->getOpCode().getName(), VAR_0->getSymbolReference()->getName(comp()->getDebug()));\n\n   if (!VAR_0->getSymbol()->castToMethodSymbol()->firstArgumentIsReceiver())\n      {\n      if (trace())\n         traceMsg(comp(), \"PREX:        - First arg is not receiver\\n\");\n      return;\n      }\n\n   /* COMMENT_0 */\n   /* COMMENT_1 */\n   /* COMMENT_0 */\n\n   /* COMMENT_2 */\n   /* COMMENT_0 */\n   bool  VAR_4             = false;\n   ParmInfo           VAR_5;  VAR_5.clear();\n   ParmInfo           *VAR_6 = &VAR_5;\n   TR::Symbol          *VAR_7 = NULL;\n   bool               VAR_8 = false;\n   int32_t            VAR_9 = -1;\n   ParmInfo *VAR_10 = NULL;\n   TR::MethodSymbol   *VAR_11   = VAR_0->getSymbol()->castToMethodSymbol();\n\n   TR_ResolvedMethod *VAR_12 = VAR_11->getResolvedMethodSymbol()? VAR_11->getResolvedMethodSymbol()->getResolvedMethod() : NULL;\n   if (!VAR_12)\n      {\n      if (VAR_11->isInterface())\n         {\n         VAR_4 = true;\n         }\n      else\n         {\n         if (trace())\n            traceMsg(comp(), \"PREX:        - Unresolved\\n\");\n         return;\n         }\n      }\n\n   TR::Node *VAR_13 = VAR_0->getChild(VAR_0->getFirstArgumentIndex());\n   if (VAR_13->getOpCode().isLoadDirect())\n      {\n      VAR_10 = getSuitableParmInfo(VAR_13);\n      if (!VAR_10)\n         {\n         if (trace())\n            traceMsg(comp(), \"PREX:        - No parm info for receiver\\n\");\n         return;\n         }\n\n      VAR_6 = VAR_10;\n      VAR_8 = true;\n\n      VAR_7 = VAR_13->getSymbolReference()->getSymbol();\n      VAR_9 = VAR_7->getParmSymbol()->getOrdinal();\n      if (VAR_11->isVirtual() || VAR_11->isInterface())\n         {\n         if (VAR_0->getSymbolReference() == getSymRefTab()->findObjectNewInstanceImplSymbol())\n            {\n            /* COMMENT_3 */\n            /* COMMENT_4 */\n            if (trace())\n               traceMsg(comp(), \"PREX:        - newInstancePrototype\\n\");\n            return;\n            }\n\n         if (trace())\n            traceMsg(comp(), \"PREX:        Receiver is %p incoming Parm %d parmInfo %p\\n\", VAR_13, VAR_9, VAR_10);\n         }\n      }\n\n   /* COMMENT_5 */\n   /* COMMENT_0 */\n   if (VAR_13->getSymbolReference()\n       && VAR_13->getSymbolReference()->hasKnownObjectIndex()\n       && !comp()->isOutOfProcessCompilation()\n      )\n      {\n      if (trace())\n         traceMsg(comp(), \"PREX:          Receiver is obj%d\\n\", VAR_13->getSymbolReference()->getKnownObjectIndex());\n\n      VAR_6->setKnownObjectIndex(VAR_13->getSymbolReference()->getKnownObjectIndex());\n      VAR_6->setClassIsFixed();\n\n      /* COMMENT_6 */\n      /* COMMENT_0 */\n      TR::KnownObjectTable *VAR_14 = comp()->getKnownObjectTable();\n\n         {\n         TR::ClassTableCriticalSection setClass(comp()->fe());\n         VAR_6->setClass(TR::Compiler->cls.objectClass(comp(), VAR_14->getPointer(VAR_13->getSymbolReference()->getKnownObjectIndex())));\n         }\n      }\n\n   /* COMMENT_7 */\n   if (VAR_12 && VAR_6->getClass() && !classIsCompatibleWithMethod(VAR_6->getClass(), VAR_12))\n      return;\n\n   /* COMMENT_0 */\n   /* COMMENT_8 */\n   /* COMMENT_0 */\n\n   if (VAR_11->isComputed())\n      {\n#ifdef VAR_3\n      if (VAR_11->getRecognizedMethod() == TR::java_lang_invoke_MethodHandle_invokeExact && VAR_6->hasKnownObjectIndex())\n         specializeInvokeExactSymbol(VAR_0, VAR_6->getKnownObjectIndex(), comp(), this);\n\n      /* COMMENT_9 */\n      /* COMMENT_10 */\n      if (VAR_0->getSymbol()->castToMethodSymbol()->getMethod()->isArchetypeSpecimen())\n         return;\n#endif\n      }\n   else if (!VAR_4 && VAR_6->classIsFixed())\n      {\n      devirtualizeVirtualCall(VAR_0, VAR_1, VAR_6->getClass());\n      }\n   else if (!VAR_4 && VAR_6->classIsCurrentlyFinal()\n            && comp()->ilGenRequest().details().supportsInvalidation())\n      {\n      TR_PersistentClassInfo* VAR_15 = comp()->getPersistentInfo()->getPersistentCHTable()->findClassInfoAfterLocking(VAR_6->getClass(), comp());\n      bool VAR_16 = true;\n\n      if (comp()->getMethodHotness() == VAR_17\n          && VAR_15\n          && VAR_15->getNumPrexAssumptions() > comp()->getOptions()->getMaxNumPrexAssumptions())\n         VAR_16 = false;\n\n      if (VAR_16 && devirtualizeVirtualCall(VAR_0, VAR_1, VAR_6->getClass()))\n         {\n         if (trace())\n            traceMsg(comp(), \"devirtualize with assumption\\n\");\n         /* COMMENT_11 */\n         VAR_6->setClassIsFixed();\n         /* COMMENT_12 */\n         /* COMMENT_13 */\n         /* COMMENT_14 */\n         /* COMMENT_15 */\n         /* COMMENT_16 */\n         /* COMMENT_17 */\n         /* COMMENT_0 */\n         if (VAR_18 && VAR_8)\n            {\n            VAR_7->getParmSymbol()->setFixedType(VAR_6->getClass());\n            }\n         /* COMMENT_18 */\n         else if (VAR_8 && comp()->getCurrentInlinedCallArgInfo())\n            {\n            TR_PrexArgInfo *VAR_19 = comp()->getCurrentInlinedCallArgInfo();\n            TR_PrexArgument *VAR_20 = VAR_19->get(VAR_9);\n            if (VAR_20 && !(VAR_20->classIsFixed() && VAR_20->getClass()))\n               {\n               VAR_20->setClassIsFixed(VAR_6->getClass());\n               }\n            }\n         TR_ASSERT(VAR_6->getClass(), \"Currently final classes must have a valid class pointer\");\n         bool VAR_21 = comp()->getCHTable()->recompileOnClassExtend(comp(), VAR_6->getClass());\n         if (VAR_15 && VAR_21) VAR_15->incNumPrexAssumptions();\n         }\n      }\n   else if (VAR_8)\n      {\n      /* COMMENT_19 */\n      /* COMMENT_20 */\n      /* COMMENT_0 */\n      if (!VAR_4 && !VAR_12->virtualMethodIsOverridden() && !VAR_12->isAbstract())\n         {\n         /* COMMENT_21 */\n         /* COMMENT_22 */\n         /* COMMENT_0 */\n         bool VAR_22 = false;\n         TR_PersistentMethodInfo *VAR_23 = NULL;\n\n         if (comp()->ilGenRequest().details().supportsInvalidation())\n            {\n            VAR_22 = true;\n            if ((comp()->getMethodHotness() == VAR_17) &&\n               (VAR_23 = TR_PersistentMethodInfo::get(resolvedMethod)) &&\n               VAR_23->getNumPrexAssumptions() > comp()->getOptions()->getMaxNumPrexAssumptions())\n               VAR_22 = false;\n            }\n\n         if (VAR_22 &&\n               performTransformation(comp(), \"%sdevirtualizing invoke [%p] on preexistent argument %d [%p]\\n\", optDetailString(), VAR_0, VAR_9, VAR_7))\n            {\n            if (trace())\n               traceMsg(comp(), \"secs devirtualizing invoke on preexistent argument %d in %s\\n\", VAR_9, comp()->signature());\n\n            VAR_0->devirtualizeCall(VAR_1);\n            bool VAR_21 = comp()->getCHTable()->recompileOnMethodOverride(comp(), resolvedMethod);\n            if (VAR_23 && VAR_21) VAR_23->incNumPrexAssumptions();\n            }\n         }\n      else if (VAR_6->getClass())\n         {\n#ifdef VAR_3\n         TR::ClassTableCriticalSection processIndirectCall(comp()->fe());\n         TR::SymbolReference *VAR_24 = VAR_0->getSymbolReference();\n         TR_PersistentCHTable * VAR_25 = comp()->getPersistentInfo()->getPersistentCHTable();\n         TR::MethodSymbol *VAR_26 = VAR_0->getSymbol()->getMethodSymbol();\n         if (VAR_26->isInterface() || VAR_11)\n            {\n            TR_ResolvedMethod * VAR_27 = NULL;\n            bool VAR_28 = true;\n            /* COMMENT_23 */\n            /* COMMENT_24 */\n            /* COMMENT_25 */\n            /* COMMENT_0 */\n            TR::Recompilation *VAR_29 = comp()->getRecompilationInfo();\n            if (VAR_29 && VAR_29->getMethodInfo()->getNumberOfInvalidations() >= 1 && !VAR_25->findSingleConcreteSubClass(VAR_6->getClass(), comp()))\n               {\n               /* COMMENT_26 */\n               /* COMMENT_27 */\n               }\n            else if (VAR_26->isInterface())\n               {\n               if (comp()->getPersistentInfo()->getRuntimeAssumptionTable()->getAssumptionCount(VAR_30) < 100000)\n                  VAR_27 = VAR_25->findSingleInterfaceImplementer(VAR_6->getClass(), VAR_0->getSymbolReference()->getCPIndex(), VAR_0->getSymbolReference()->getOwningMethod(comp()), comp());\n               /* COMMENT_28 */\n               /* COMMENT_29 */\n               }\n            else\n               {\n               if (resolvedMethod->isAbstract())\n                  VAR_27 = VAR_25->findSingleAbstractImplementer(VAR_6->getClass(), VAR_24->getOffset(), VAR_0->getSymbolReference()->getOwningMethod(comp()), comp());\n               else if (!VAR_25->isOverriddenInThisHierarchy(resolvedMethod, VAR_6->getClass(), VAR_24->getOffset(), comp()))\n                  {\n                  VAR_27 = VAR_24->getOwningMethod(comp())->getResolvedVirtualMethod(comp(), VAR_6->getClass(), VAR_24->getOffset());\n                  VAR_28 = false;\n                  }\n               }\n\n            if (VAR_27 && !VAR_27->virtualMethodIsOverridden())\n               {\n               TR_PersistentClassInfo *VAR_15 = comp()->getPersistentInfo()->getPersistentCHTable()->findClassInfoAfterLocking(VAR_6->getClass(), comp());\n\n               /* COMMENT_21 */\n               /* COMMENT_22 */\n               /* COMMENT_0 */\n               bool VAR_22 = false;\n\n               if (comp()->ilGenRequest().details().supportsInvalidation())\n                  {\n                  VAR_22 = true;\n                  if ((comp()->getMethodHotness() == VAR_17) &&\n                        VAR_15 &&\n                        VAR_15->getNumPrexAssumptions() > comp()->getOptions()->getMaxNumPrexAssumptions())\n                     VAR_22 = false;\n\n                  /* COMMENT_30 */\n                  if (VAR_15 && VAR_22)\n                     {\n                     TR_ScratchList<TR_PersistentClassInfo> subClasses(trMemory());\n                     TR_ClassQueries::collectAllSubClasses(VAR_15, &VAR_31, comp());\n                     ListIterator<TR_PersistentClassInfo> VAR_32(&VAR_31);\n                     for (TR_PersistentClassInfo *VAR_33 = VAR_32.getFirst(); VAR_33; VAR_33 = VAR_32.getNext())\n                        {\n                        if (VAR_33->getNumPrexAssumptions() > comp()->getOptions()->getMaxNumPrexAssumptions())\n                           {\n                           VAR_22 = false;\n                           break;\n                           }\n                        }\n                     }\n                  }\n\n               if (VAR_22 &&\n                   performTransformation(comp(), \"%sspecialize and devirtualize invoke [%p] based on only a single implementation for call on parameter %d [%p]\\n\", optDetailString(), VAR_0, VAR_9, VAR_7))\n                  {\n                  if (VAR_28 || !VAR_27->isSameMethod(resolvedMethod))\n                     {\n                     TR::SymbolReference *VAR_34 =\n                      getSymRefTab()->findOrCreateMethodSymbol\n                                   (VAR_24->getOwningMethodIndex(), -1, VAR_27, TR::MethodSymbol::Virtual);\n                     VAR_34->copyAliasSets(VAR_24, getSymRefTab());\n\n                     int32_t VAR_35 = -1;\n                     if (VAR_26->isInterface())\n                        VAR_35 = VAR_0->getSymbolReference()->getOwningMethod(comp())->getResolvedInterfaceMethodOffset(VAR_27->containingClass(), VAR_0->getSymbolReference()->getCPIndex());\n                     else\n                        VAR_35 = VAR_24->getOffset();\n\n                     VAR_34->setOffset(VAR_35);\n                     VAR_0->setSymbolReference(VAR_34);\n                     }\n\n                  VAR_0->devirtualizeCall(VAR_1);\n                  if (VAR_1->getNode()->getOpCodeValue() == TR::ResolveCHK)\n                     TR::Node::recreate(VAR_1->getNode(), TR::treetop);\n                  else if (VAR_1->getNode()->getOpCodeValue() == TR::ResolveAndNULLCHK)\n                     TR::Node::recreate(VAR_1->getNode(), TR::NULLCHK);\n\n                  bool VAR_36 = comp()->getCHTable()->recompileOnNewClassExtend(comp(), VAR_6->getClass());\n\n                  if (VAR_15)\n                     {\n                     VAR_15->setShouldNotBeNewlyExtended(comp()->getCompThreadID());\n                     if (VAR_36) VAR_15->incNumPrexAssumptions();\n                     TR_ScratchList<TR_PersistentClassInfo> subClasses(trMemory());\n                     TR_ClassQueries::collectAllSubClasses(VAR_15, &VAR_31, comp());\n                     ListIterator<TR_PersistentClassInfo> VAR_32(&VAR_31);\n                     for (TR_PersistentClassInfo *VAR_33 = VAR_32.getFirst(); VAR_33; VAR_33 = VAR_32.getNext())\n                        {\n                        TR_OpaqueClassBlock *VAR_37 = (TR_OpaqueClassBlock *) VAR_33->getClassId();\n                        VAR_33->setShouldNotBeNewlyExtended(comp()->getCompThreadID());\n                        if (comp()->getCHTable()->recompileOnNewClassExtend(comp(), VAR_37))\n                           VAR_33->incNumPrexAssumptions();\n                        }\n                     }\n\n\n                  /* COMMENT_31 */\n                  VAR_38 = true;\n                  }\n               else\n                  {\n                  return;\n                  }\n               }\n            else\n               {\n               return;\n               }\n            }\n#endif\n         }\n      }\n\n\n   if (comp()->isPeekingMethod() && VAR_6->getClass() && !VAR_4)\n      {\n      TR::SymbolReference *VAR_24 = VAR_0->getSymbolReference();\n      int32_t VAR_35 = VAR_24->getOffset();\n      /* COMMENT_32 */\n      /* COMMENT_33 */\n      /* COMMENT_34 */\n\n      TR_ResolvedMethod *VAR_39 = resolvedMethod;\n      TR_OpaqueClassBlock *VAR_40 = VAR_39->containingClass();\n      bool VAR_41 = true;\n      if (VAR_40 != VAR_6->getClass())\n         {\n         TR_YesNoMaybe VAR_42 = fe()->isInstanceOf(VAR_40, VAR_6->getClass(), true);\n         if (VAR_42 == VAR_43)\n            VAR_41 = false;\n\n         VAR_42 = fe()->isInstanceOf(VAR_6->getClass(), VAR_40, true);\n         if (VAR_42 == VAR_44)\n            VAR_41 = false;\n         }\n\n      TR_ResolvedMethod *resolvedMethod = NULL;\n      if (VAR_41)\n         resolvedMethod = VAR_24->getOwningMethod(comp())->getResolvedVirtualMethod(comp(), VAR_6->getClass(), VAR_35);\n\n      if (resolvedMethod)\n         {\n         if (!VAR_39 || !resolvedMethod->isSameMethod(VAR_39))\n            {\n            TR::SymbolReference * VAR_34 =\n          VAR_45->findOrCreateMethodSymbol(\n                             VAR_24->getOwningMethodIndex(), -1, resolvedMethod, TR::MethodSymbol::Virtual);\n            VAR_34->copyAliasSets(VAR_24, VAR_45);\n            VAR_34->setOffset(VAR_35);\n            VAR_0->setSymbolReference(VAR_34);\n            }\n         }\n      }\n#endif\n   }",
  "func_graph_path_before": "eclipse/omr/f5ab765943c192e25ac8ea8d341f88e6ed9f90d2/LocalOpts.cpp/vul/before/0.json",
  "func": "void TR_InvariantArgumentPreexistence::processIndirectCall(TR::Node *node, TR::TreeTop *treeTop, vcount_t visitCount)\n   {\n#ifdef J9_PROJECT_SPECIFIC\n\n   if (trace())\n      traceMsg(comp(), \"PREX:      [%p] %s %s\\n\", node, node->getOpCode().getName(), node->getSymbolReference()->getName(comp()->getDebug()));\n\n   if (!node->getSymbol()->castToMethodSymbol()->firstArgumentIsReceiver())\n      {\n      if (trace())\n         traceMsg(comp(), \"PREX:        - First arg is not receiver\\n\");\n      return;\n      }\n\n   //\n   // Step 1: Analyze\n   //\n\n   // Decision variables\n   //\n   bool  isInterface             = false;\n   ParmInfo           tmpInfo;  tmpInfo.clear();\n   ParmInfo           *receiverInfo = &tmpInfo;\n   TR::Symbol          *receiverSymbol = NULL;\n   bool               receiverFromParm = false;\n   int32_t            receiverParmOrdinal = -1;\n   ParmInfo *existingInfo = NULL;\n   TR::MethodSymbol   *methodSymbol   = node->getSymbol()->castToMethodSymbol();\n\n   TR_ResolvedMethod *resolvedMethod = methodSymbol->getResolvedMethodSymbol()? methodSymbol->getResolvedMethodSymbol()->getResolvedMethod() : NULL;\n   if (!resolvedMethod)\n      {\n      if (methodSymbol->isInterface())\n         {\n         isInterface = true;\n         }\n      else\n         {\n         if (trace())\n            traceMsg(comp(), \"PREX:        - Unresolved\\n\");\n         return;\n         }\n      }\n\n   TR::Node *receiver = node->getChild(node->getFirstArgumentIndex());\n   if (receiver->getOpCode().isLoadDirect())\n      {\n      existingInfo = getSuitableParmInfo(receiver);\n      if (!existingInfo)\n         {\n         if (trace())\n            traceMsg(comp(), \"PREX:        - No parm info for receiver\\n\");\n         return;\n         }\n\n      receiverInfo = existingInfo;\n      receiverFromParm = true;\n\n      receiverSymbol = receiver->getSymbolReference()->getSymbol();\n      receiverParmOrdinal = receiverSymbol->getParmSymbol()->getOrdinal();\n      if (methodSymbol->isVirtual() || methodSymbol->isInterface())\n         {\n         if (node->getSymbolReference() == getSymRefTab()->findObjectNewInstanceImplSymbol())\n            {\n            // Let's not get fancy with these guys\n            // They are the java/lang/Object.newInstancePrototype special methods\n            if (trace())\n               traceMsg(comp(), \"PREX:        - newInstancePrototype\\n\");\n            return;\n            }\n\n         if (trace())\n            traceMsg(comp(), \"PREX:        Receiver is %p incoming Parm %d parmInfo %p\\n\", receiver, receiverParmOrdinal, existingInfo);\n         }\n      }\n\n   // Bonus goodies for known objects\n   //\n   if (receiver->getSymbolReference()\n       && receiver->getSymbolReference()->hasKnownObjectIndex()\n       && !comp()->isOutOfProcessCompilation()\n      )\n      {\n      if (trace())\n         traceMsg(comp(), \"PREX:          Receiver is obj%d\\n\", receiver->getSymbolReference()->getKnownObjectIndex());\n\n      receiverInfo->setKnownObjectIndex(receiver->getSymbolReference()->getKnownObjectIndex());\n      receiverInfo->setClassIsFixed();\n\n      // Also set the class info\n      //\n      TR::KnownObjectTable *knot = comp()->getKnownObjectTable();\n\n         {\n         TR::ClassTableCriticalSection setClass(comp()->fe());\n         receiverInfo->setClass(TR::Compiler->cls.objectClass(comp(), knot->getPointer(receiver->getSymbolReference()->getKnownObjectIndex())));\n         }\n      }\n\n   // Quit if class is not compatible with the method\n   if (resolvedMethod && receiverInfo->getClass() && !classIsCompatibleWithMethod(receiverInfo->getClass(), resolvedMethod))\n      {\n      if (trace())\n         traceMsg(comp(), \"PREX:        - Receiver type incompatible with method \\n\");\n\n      return;\n      }\n\n   TR::MethodSymbol *methSymbol = node->getSymbol()->getMethodSymbol();\n   if (methSymbol->isInterface())\n      {\n      // Interface type signatures can't be trusted most places in bytecode, so\n      // only transform interface calls when we have a class bound for the\n      // receiver.\n      TR_OpaqueClassBlock *klass = receiverInfo->getClass();\n      if (klass == NULL || TR::Compiler->cls.isInterfaceClass(comp(), klass))\n         {\n         if (trace())\n            {\n            traceMsg(\n               comp(),\n               \"PREX:        - No class type bound for interface call receiver\\n\");\n            }\n\n         return;\n         }\n\n      TR_ResolvedMethod *caller = node->getSymbolReference()->getOwningMethod(comp());\n      TR::Method *callee = methSymbol->getMethod();\n      bool aotOk = true;\n      TR_OpaqueClassBlock *iface = fe()->getClassFromSignature(\n         callee->classNameChars(), callee->classNameLength(), caller, aotOk);\n\n      if (iface == NULL)\n         {\n         if (trace())\n            {\n            traceMsg(\n               comp(),\n               \"PREX:        - Failed to identify interface for interface call\\n\");\n            }\n\n         return;\n         }\n\n      if (fe()->isInstanceOf(klass, iface, true, true, true) != TR_yes)\n         {\n         if (trace())\n            {\n            traceMsg(\n               comp(),\n               \"PREX:        - Insufficient class type bound for interface call receiver\\n\");\n            }\n\n         return;\n         }\n      }\n\n   //\n   // Step 2: Transform\n   //\n\n   if (methodSymbol->isComputed())\n      {\n#ifdef J9_PROJECT_SPECIFIC\n      if (methodSymbol->getRecognizedMethod() == TR::java_lang_invoke_MethodHandle_invokeExact && receiverInfo->hasKnownObjectIndex())\n         specializeInvokeExactSymbol(node, receiverInfo->getKnownObjectIndex(), comp(), this);\n\n      // The method is a specialized thunk archetype, no further improvement is needed.\n      // Keeping running subsequent code may result in a crash because `offset` on the symref is not valid.\n      if (node->getSymbol()->castToMethodSymbol()->getMethod()->isArchetypeSpecimen())\n         return;\n#endif\n      }\n   else if (!isInterface && receiverInfo->classIsFixed())\n      {\n      devirtualizeVirtualCall(node, treeTop, receiverInfo->getClass());\n      }\n   else if (!isInterface && receiverInfo->classIsCurrentlyFinal()\n            && comp()->ilGenRequest().details().supportsInvalidation())\n      {\n      TR_PersistentClassInfo* classInfo = comp()->getPersistentInfo()->getPersistentCHTable()->findClassInfoAfterLocking(receiverInfo->getClass(), comp());\n      bool canDevirtualize = true;\n\n      if (comp()->getMethodHotness() == warm\n          && classInfo\n          && classInfo->getNumPrexAssumptions() > comp()->getOptions()->getMaxNumPrexAssumptions())\n         canDevirtualize = false;\n\n      if (canDevirtualize && devirtualizeVirtualCall(node, treeTop, receiverInfo->getClass()))\n         {\n         if (trace())\n            traceMsg(comp(), \"devirtualize with assumption\\n\");\n         // improve receiverInfo\n         receiverInfo->setClassIsFixed();\n         // For the outer most method, we have to carry the information of fixed type to inliner,\n         // such that it can be propagated to deeper frames.\n         // The receiver type is current final, which means it's the most concrete type atm. If\n         // the receiver is from parm of the jitted method, this property applies to all call\n         // sites to this method in this compilation. Thus, it is safe to set fixed type on the\n         // parm of this method.\n         //\n         if (_isOutermostMethod && receiverFromParm)\n            {\n            receiverSymbol->getParmSymbol()->setFixedType(receiverInfo->getClass());\n            }\n         // Improve the prex arg for inlined method\n         else if (receiverFromParm && comp()->getCurrentInlinedCallArgInfo())\n            {\n            TR_PrexArgInfo *argInfo = comp()->getCurrentInlinedCallArgInfo();\n            TR_PrexArgument *arg = argInfo->get(receiverParmOrdinal);\n            if (arg && !(arg->classIsFixed() && arg->getClass()))\n               {\n               arg->setClassIsFixed(receiverInfo->getClass());\n               }\n            }\n         TR_ASSERT(receiverInfo->getClass(), \"Currently final classes must have a valid class pointer\");\n         bool inc = comp()->getCHTable()->recompileOnClassExtend(comp(), receiverInfo->getClass());\n         if (classInfo && inc) classInfo->incNumPrexAssumptions();\n         }\n      }\n   else if (receiverFromParm)\n      {\n      // If the method being called is currently not overridden, we can register\n      // a recomp action on the method-override event for this method\n      //\n      if (!isInterface && !resolvedMethod->virtualMethodIsOverridden() && !resolvedMethod->isAbstract())\n         {\n         // if the number of recompile assumptions on this particular\n         // class has exceeded a threshold, don't do prex anymore for this class\n         //\n         bool addAssumptions = false;\n         TR_PersistentMethodInfo *callInfo = NULL;\n\n         if (comp()->ilGenRequest().details().supportsInvalidation())\n            {\n            addAssumptions = true;\n            if ((comp()->getMethodHotness() == warm) &&\n               (callInfo = TR_PersistentMethodInfo::get(resolvedMethod)) &&\n               callInfo->getNumPrexAssumptions() > comp()->getOptions()->getMaxNumPrexAssumptions())\n               addAssumptions = false;\n            }\n\n         if (addAssumptions &&\n               performTransformation(comp(), \"%sdevirtualizing invoke [%p] on preexistent argument %d [%p]\\n\", optDetailString(), node, receiverParmOrdinal, receiverSymbol))\n            {\n            if (trace())\n               traceMsg(comp(), \"secs devirtualizing invoke on preexistent argument %d in %s\\n\", receiverParmOrdinal, comp()->signature());\n\n            node->devirtualizeCall(treeTop);\n            bool inc = comp()->getCHTable()->recompileOnMethodOverride(comp(), resolvedMethod);\n            if (callInfo && inc) callInfo->incNumPrexAssumptions();\n            }\n         }\n      else if (receiverInfo->getClass())\n         {\n#ifdef J9_PROJECT_SPECIFIC\n         TR::ClassTableCriticalSection processIndirectCall(comp()->fe());\n         TR::SymbolReference *symRef = node->getSymbolReference();\n         TR_PersistentCHTable * chTable = comp()->getPersistentInfo()->getPersistentCHTable();\n         if (methSymbol->isInterface() || methodSymbol)\n            {\n            TR_ResolvedMethod * method = NULL;\n            bool newMethod = true;\n            // There is the risk of invaliding a method repeatedly due to class hierarchy extensions\n            // In the following avoid devirtualization based on single implementor if the method has\n            // been invalidated once\n            //\n            TR::Recompilation *recompInfo = comp()->getRecompilationInfo();\n            if (recompInfo && recompInfo->getMethodInfo()->getNumberOfInvalidations() >= 1 && !chTable->findSingleConcreteSubClass(receiverInfo->getClass(), comp()))\n               {\n               // will exit without performing any transformation\n               //fprintf(stderr, \"will not perform devirt\\n\");\n               }\n            else if (methSymbol->isInterface())\n               {\n               if (comp()->getPersistentInfo()->getRuntimeAssumptionTable()->getAssumptionCount(RuntimeAssumptionOnClassExtend) < 100000)\n                  method = chTable->findSingleInterfaceImplementer(receiverInfo->getClass(), node->getSymbolReference()->getCPIndex(), node->getSymbolReference()->getOwningMethod(comp()), comp());\n               if (method == NULL)\n                  {\n                  if (trace())\n                     {\n                     traceMsg(\n                        comp(),\n                        \"PREX:        - Failed to find interface callee\\n\");\n                     }\n                  return;\n                  }\n               }\n            else\n               {\n               if (resolvedMethod->isAbstract())\n                  method = chTable->findSingleAbstractImplementer(receiverInfo->getClass(), symRef->getOffset(), node->getSymbolReference()->getOwningMethod(comp()), comp());\n               else if (!chTable->isOverriddenInThisHierarchy(resolvedMethod, receiverInfo->getClass(), symRef->getOffset(), comp()))\n                  {\n                  method = symRef->getOwningMethod(comp())->getResolvedVirtualMethod(comp(), receiverInfo->getClass(), symRef->getOffset());\n                  newMethod = false;\n                  }\n               }\n\n            if (method && !method->virtualMethodIsOverridden())\n               {\n               TR_PersistentClassInfo *classInfo = comp()->getPersistentInfo()->getPersistentCHTable()->findClassInfoAfterLocking(receiverInfo->getClass(), comp());\n\n               // if the number of recompile assumptions on this particular\n               // class has exceeded a threshold, don't do prex anymore for this class\n               //\n               bool addAssumptions = false;\n\n               if (comp()->ilGenRequest().details().supportsInvalidation())\n                  {\n                  addAssumptions = true;\n                  if ((comp()->getMethodHotness() == warm) &&\n                        classInfo &&\n                        classInfo->getNumPrexAssumptions() > comp()->getOptions()->getMaxNumPrexAssumptions())\n                     addAssumptions = false;\n\n                  // check the subclasses as well\n                  if (classInfo && addAssumptions)\n                     {\n                     TR_ScratchList<TR_PersistentClassInfo> subClasses(trMemory());\n                     TR_ClassQueries::collectAllSubClasses(classInfo, &subClasses, comp());\n                     ListIterator<TR_PersistentClassInfo> subClassesIt(&subClasses);\n                     for (TR_PersistentClassInfo *subClassInfo = subClassesIt.getFirst(); subClassInfo; subClassInfo = subClassesIt.getNext())\n                        {\n                        if (subClassInfo->getNumPrexAssumptions() > comp()->getOptions()->getMaxNumPrexAssumptions())\n                           {\n                           addAssumptions = false;\n                           break;\n                           }\n                        }\n                     }\n                  }\n\n               if (addAssumptions &&\n                   performTransformation(comp(), \"%sspecialize and devirtualize invoke [%p] based on only a single implementation for call on parameter %d [%p]\\n\", optDetailString(), node, receiverParmOrdinal, receiverSymbol))\n                  {\n                  if (newMethod || !method->isSameMethod(resolvedMethod))\n                     {\n                     TR::SymbolReference *newSymRef =\n                      getSymRefTab()->findOrCreateMethodSymbol\n                                   (symRef->getOwningMethodIndex(), -1, method, TR::MethodSymbol::Virtual);\n                     newSymRef->copyAliasSets(symRef, getSymRefTab());\n\n                     int32_t offset = -1;\n                     if (methSymbol->isInterface())\n                        offset = node->getSymbolReference()->getOwningMethod(comp())->getResolvedInterfaceMethodOffset(method->containingClass(), node->getSymbolReference()->getCPIndex());\n                     else\n                        offset = symRef->getOffset();\n\n                     newSymRef->setOffset(offset);\n                     node->setSymbolReference(newSymRef);\n                     }\n\n                  node->devirtualizeCall(treeTop);\n                  if (treeTop->getNode()->getOpCodeValue() == TR::ResolveCHK)\n                     TR::Node::recreate(treeTop->getNode(), TR::treetop);\n                  else if (treeTop->getNode()->getOpCodeValue() == TR::ResolveAndNULLCHK)\n                     TR::Node::recreate(treeTop->getNode(), TR::NULLCHK);\n\n                  bool doInc = comp()->getCHTable()->recompileOnNewClassExtend(comp(), receiverInfo->getClass());\n\n                  if (classInfo)\n                     {\n                     classInfo->setShouldNotBeNewlyExtended(comp()->getCompThreadID());\n                     if (doInc) classInfo->incNumPrexAssumptions();\n                     TR_ScratchList<TR_PersistentClassInfo> subClasses(trMemory());\n                     TR_ClassQueries::collectAllSubClasses(classInfo, &subClasses, comp());\n                     ListIterator<TR_PersistentClassInfo> subClassesIt(&subClasses);\n                     for (TR_PersistentClassInfo *subClassInfo = subClassesIt.getFirst(); subClassInfo; subClassInfo = subClassesIt.getNext())\n                        {\n                        TR_OpaqueClassBlock *subClass = (TR_OpaqueClassBlock *) subClassInfo->getClassId();\n                        subClassInfo->setShouldNotBeNewlyExtended(comp()->getCompThreadID());\n                        if (comp()->getCHTable()->recompileOnNewClassExtend(comp(), subClass))\n                           subClassInfo->incNumPrexAssumptions();\n                        }\n                     }\n\n\n                  //comp()->getCHTable()->recompileOnMethodOverride(comp(), method);\n                  _success = true;\n                  }\n               else\n                  {\n                  return;\n                  }\n               }\n            else\n               {\n               return;\n               }\n            }\n#endif\n         }\n      }\n\n\n   if (comp()->isPeekingMethod() && receiverInfo->getClass() && !isInterface)\n      {\n      TR::SymbolReference *symRef = node->getSymbolReference();\n      int32_t offset = symRef->getOffset();\n      //printf(\"Node %p arg %d\\n\", node, receiverParmOrdinal);\n      //printf(\"Method is %s\\n\", resolvedMethod->signature(trMemory()));\n      //fflush(stdout);\n\n      TR_ResolvedMethod *originalResolvedMethod = resolvedMethod;\n      TR_OpaqueClassBlock *originalClazz = originalResolvedMethod->containingClass();\n      bool canRefine = true;\n      if (originalClazz != receiverInfo->getClass())\n         {\n         TR_YesNoMaybe isInstance = fe()->isInstanceOf(originalClazz, receiverInfo->getClass(), true);\n         if (isInstance == TR_yes)\n            canRefine = false;\n\n         isInstance = fe()->isInstanceOf(receiverInfo->getClass(), originalClazz, true);\n         if (isInstance == TR_no)\n            canRefine = false;\n         }\n\n      TR_ResolvedMethod *resolvedMethod = NULL;\n      if (canRefine)\n         resolvedMethod = symRef->getOwningMethod(comp())->getResolvedVirtualMethod(comp(), receiverInfo->getClass(), offset);\n\n      if (resolvedMethod)\n         {\n         if (!originalResolvedMethod || !resolvedMethod->isSameMethod(originalResolvedMethod))\n            {\n            TR::SymbolReference * newSymRef =\n          _peekingSymRefTab->findOrCreateMethodSymbol(\n                             symRef->getOwningMethodIndex(), -1, resolvedMethod, TR::MethodSymbol::Virtual);\n            newSymRef->copyAliasSets(symRef, _peekingSymRefTab);\n            newSymRef->setOffset(offset);\n            node->setSymbolReference(newSymRef);\n            }\n         }\n      }\n#endif\n   }",
  "abstract_func": "void TR_InvariantArgumentPreexistence::processIndirectCall(TR::Node *VAR_0, TR::TreeTop *VAR_1, vcount_t VAR_2)\n   {\n#ifdef VAR_3\n\n   if (trace())\n      traceMsg(comp(), \"PREX:      [%p] %s %s\\n\", VAR_0, VAR_0->getOpCode().getName(), VAR_0->getSymbolReference()->getName(comp()->getDebug()));\n\n   if (!VAR_0->getSymbol()->castToMethodSymbol()->firstArgumentIsReceiver())\n      {\n      if (trace())\n         traceMsg(comp(), \"PREX:        - First arg is not receiver\\n\");\n      return;\n      }\n\n   /* COMMENT_0 */\n   /* COMMENT_1 */\n   /* COMMENT_0 */\n\n   /* COMMENT_2 */\n   /* COMMENT_0 */\n   bool  VAR_4             = false;\n   ParmInfo           VAR_5;  VAR_5.clear();\n   ParmInfo           *VAR_6 = &VAR_5;\n   TR::Symbol          *VAR_7 = NULL;\n   bool               VAR_8 = false;\n   int32_t            VAR_9 = -1;\n   ParmInfo *VAR_10 = NULL;\n   TR::MethodSymbol   *VAR_11   = VAR_0->getSymbol()->castToMethodSymbol();\n\n   TR_ResolvedMethod *VAR_12 = VAR_11->getResolvedMethodSymbol()? VAR_11->getResolvedMethodSymbol()->getResolvedMethod() : NULL;\n   if (!VAR_12)\n      {\n      if (VAR_11->isInterface())\n         {\n         VAR_4 = true;\n         }\n      else\n         {\n         if (trace())\n            traceMsg(comp(), \"PREX:        - Unresolved\\n\");\n         return;\n         }\n      }\n\n   TR::Node *VAR_13 = VAR_0->getChild(VAR_0->getFirstArgumentIndex());\n   if (VAR_13->getOpCode().isLoadDirect())\n      {\n      VAR_10 = getSuitableParmInfo(VAR_13);\n      if (!VAR_10)\n         {\n         if (trace())\n            traceMsg(comp(), \"PREX:        - No parm info for receiver\\n\");\n         return;\n         }\n\n      VAR_6 = VAR_10;\n      VAR_8 = true;\n\n      VAR_7 = VAR_13->getSymbolReference()->getSymbol();\n      VAR_9 = VAR_7->getParmSymbol()->getOrdinal();\n      if (VAR_11->isVirtual() || VAR_11->isInterface())\n         {\n         if (VAR_0->getSymbolReference() == getSymRefTab()->findObjectNewInstanceImplSymbol())\n            {\n            /* COMMENT_3 */\n            /* COMMENT_4 */\n            if (trace())\n               traceMsg(comp(), \"PREX:        - newInstancePrototype\\n\");\n            return;\n            }\n\n         if (trace())\n            traceMsg(comp(), \"PREX:        Receiver is %p incoming Parm %d parmInfo %p\\n\", VAR_13, VAR_9, VAR_10);\n         }\n      }\n\n   /* COMMENT_5 */\n   /* COMMENT_0 */\n   if (VAR_13->getSymbolReference()\n       && VAR_13->getSymbolReference()->hasKnownObjectIndex()\n       && !comp()->isOutOfProcessCompilation()\n      )\n      {\n      if (trace())\n         traceMsg(comp(), \"PREX:          Receiver is obj%d\\n\", VAR_13->getSymbolReference()->getKnownObjectIndex());\n\n      VAR_6->setKnownObjectIndex(VAR_13->getSymbolReference()->getKnownObjectIndex());\n      VAR_6->setClassIsFixed();\n\n      /* COMMENT_6 */\n      /* COMMENT_0 */\n      TR::KnownObjectTable *VAR_14 = comp()->getKnownObjectTable();\n\n         {\n         TR::ClassTableCriticalSection setClass(comp()->fe());\n         VAR_6->setClass(TR::Compiler->cls.objectClass(comp(), VAR_14->getPointer(VAR_13->getSymbolReference()->getKnownObjectIndex())));\n         }\n      }\n\n   /* COMMENT_7 */\n   if (VAR_12 && VAR_6->getClass() && !classIsCompatibleWithMethod(VAR_6->getClass(), VAR_12))\n      {\n      if (trace())\n         traceMsg(comp(), \"PREX:        - Receiver type incompatible with method \\n\");\n\n      return;\n      }\n\n   TR::MethodSymbol *VAR_15 = VAR_0->getSymbol()->getMethodSymbol();\n   if (VAR_15->isInterface())\n      {\n      /* COMMENT_8 */\n      /* COMMENT_9 */\n      /* COMMENT_10 */\n      TR_OpaqueClassBlock *VAR_16 = VAR_6->getClass();\n      if (VAR_16 == NULL || TR::Compiler->cls.isInterfaceClass(comp(), VAR_16))\n         {\n         if (trace())\n            {\n            traceMsg(\n               comp(),\n               \"PREX:        - No class type bound for interface call receiver\\n\");\n            }\n\n         return;\n         }\n\n      TR_ResolvedMethod *VAR_17 = VAR_0->getSymbolReference()->getOwningMethod(comp());\n      TR::Method *VAR_18 = VAR_15->getMethod();\n      bool VAR_19 = true;\n      TR_OpaqueClassBlock *VAR_20 = fe()->getClassFromSignature(\n         VAR_18->classNameChars(), VAR_18->classNameLength(), VAR_17, VAR_19);\n\n      if (VAR_20 == NULL)\n         {\n         if (trace())\n            {\n            traceMsg(\n               comp(),\n               \"PREX:        - Failed to identify interface for interface call\\n\");\n            }\n\n         return;\n         }\n\n      if (fe()->isInstanceOf(VAR_16, VAR_20, true, true, true) != VAR_21)\n         {\n         if (trace())\n            {\n            traceMsg(\n               comp(),\n               \"PREX:        - Insufficient class type bound for interface call receiver\\n\");\n            }\n\n         return;\n         }\n      }\n\n   /* COMMENT_0 */\n   /* COMMENT_11 */\n   /* COMMENT_0 */\n\n   if (VAR_11->isComputed())\n      {\n#ifdef VAR_3\n      if (VAR_11->getRecognizedMethod() == TR::java_lang_invoke_MethodHandle_invokeExact && VAR_6->hasKnownObjectIndex())\n         specializeInvokeExactSymbol(VAR_0, VAR_6->getKnownObjectIndex(), comp(), this);\n\n      /* COMMENT_12 */\n      /* COMMENT_13 */\n      if (VAR_0->getSymbol()->castToMethodSymbol()->getMethod()->isArchetypeSpecimen())\n         return;\n#endif\n      }\n   else if (!VAR_4 && VAR_6->classIsFixed())\n      {\n      devirtualizeVirtualCall(VAR_0, VAR_1, VAR_6->getClass());\n      }\n   else if (!VAR_4 && VAR_6->classIsCurrentlyFinal()\n            && comp()->ilGenRequest().details().supportsInvalidation())\n      {\n      TR_PersistentClassInfo* VAR_22 = comp()->getPersistentInfo()->getPersistentCHTable()->findClassInfoAfterLocking(VAR_6->getClass(), comp());\n      bool VAR_23 = true;\n\n      if (comp()->getMethodHotness() == VAR_24\n          && VAR_22\n          && VAR_22->getNumPrexAssumptions() > comp()->getOptions()->getMaxNumPrexAssumptions())\n         VAR_23 = false;\n\n      if (VAR_23 && devirtualizeVirtualCall(VAR_0, VAR_1, VAR_6->getClass()))\n         {\n         if (trace())\n            traceMsg(comp(), \"devirtualize with assumption\\n\");\n         /* COMMENT_14 */\n         VAR_6->setClassIsFixed();\n         /* COMMENT_15 */\n         /* COMMENT_16 */\n         /* COMMENT_17 */\n         /* COMMENT_18 */\n         /* COMMENT_19 */\n         /* COMMENT_20 */\n         /* COMMENT_0 */\n         if (VAR_25 && VAR_8)\n            {\n            VAR_7->getParmSymbol()->setFixedType(VAR_6->getClass());\n            }\n         /* COMMENT_21 */\n         else if (VAR_8 && comp()->getCurrentInlinedCallArgInfo())\n            {\n            TR_PrexArgInfo *VAR_26 = comp()->getCurrentInlinedCallArgInfo();\n            TR_PrexArgument *VAR_27 = VAR_26->get(VAR_9);\n            if (VAR_27 && !(VAR_27->classIsFixed() && VAR_27->getClass()))\n               {\n               VAR_27->setClassIsFixed(VAR_6->getClass());\n               }\n            }\n         TR_ASSERT(VAR_6->getClass(), \"Currently final classes must have a valid class pointer\");\n         bool VAR_28 = comp()->getCHTable()->recompileOnClassExtend(comp(), VAR_6->getClass());\n         if (VAR_22 && VAR_28) VAR_22->incNumPrexAssumptions();\n         }\n      }\n   else if (VAR_8)\n      {\n      /* COMMENT_22 */\n      /* COMMENT_23 */\n      /* COMMENT_0 */\n      if (!VAR_4 && !VAR_12->virtualMethodIsOverridden() && !VAR_12->isAbstract())\n         {\n         /* COMMENT_24 */\n         /* COMMENT_25 */\n         /* COMMENT_0 */\n         bool VAR_29 = false;\n         TR_PersistentMethodInfo *VAR_30 = NULL;\n\n         if (comp()->ilGenRequest().details().supportsInvalidation())\n            {\n            VAR_29 = true;\n            if ((comp()->getMethodHotness() == VAR_24) &&\n               (VAR_30 = TR_PersistentMethodInfo::get(resolvedMethod)) &&\n               VAR_30->getNumPrexAssumptions() > comp()->getOptions()->getMaxNumPrexAssumptions())\n               VAR_29 = false;\n            }\n\n         if (VAR_29 &&\n               performTransformation(comp(), \"%sdevirtualizing invoke [%p] on preexistent argument %d [%p]\\n\", optDetailString(), VAR_0, VAR_9, VAR_7))\n            {\n            if (trace())\n               traceMsg(comp(), \"secs devirtualizing invoke on preexistent argument %d in %s\\n\", VAR_9, comp()->signature());\n\n            VAR_0->devirtualizeCall(VAR_1);\n            bool VAR_28 = comp()->getCHTable()->recompileOnMethodOverride(comp(), resolvedMethod);\n            if (VAR_30 && VAR_28) VAR_30->incNumPrexAssumptions();\n            }\n         }\n      else if (VAR_6->getClass())\n         {\n#ifdef VAR_3\n         TR::ClassTableCriticalSection processIndirectCall(comp()->fe());\n         TR::SymbolReference *VAR_31 = VAR_0->getSymbolReference();\n         TR_PersistentCHTable * VAR_32 = comp()->getPersistentInfo()->getPersistentCHTable();\n         if (VAR_15->isInterface() || VAR_11)\n            {\n            TR_ResolvedMethod * VAR_33 = NULL;\n            bool VAR_34 = true;\n            /* COMMENT_26 */\n            /* COMMENT_27 */\n            /* COMMENT_28 */\n            /* COMMENT_0 */\n            TR::Recompilation *VAR_35 = comp()->getRecompilationInfo();\n            if (VAR_35 && VAR_35->getMethodInfo()->getNumberOfInvalidations() >= 1 && !VAR_32->findSingleConcreteSubClass(VAR_6->getClass(), comp()))\n               {\n               /* COMMENT_29 */\n               /* COMMENT_30 */\n               }\n            else if (VAR_15->isInterface())\n               {\n               if (comp()->getPersistentInfo()->getRuntimeAssumptionTable()->getAssumptionCount(VAR_36) < 100000)\n                  VAR_33 = VAR_32->findSingleInterfaceImplementer(VAR_6->getClass(), VAR_0->getSymbolReference()->getCPIndex(), VAR_0->getSymbolReference()->getOwningMethod(comp()), comp());\n               if (VAR_33 == NULL)\n                  {\n                  if (trace())\n                     {\n                     traceMsg(\n                        comp(),\n                        \"PREX:        - Failed to find interface callee\\n\");\n                     }\n                  return;\n                  }\n               }\n            else\n               {\n               if (resolvedMethod->isAbstract())\n                  VAR_33 = VAR_32->findSingleAbstractImplementer(VAR_6->getClass(), VAR_31->getOffset(), VAR_0->getSymbolReference()->getOwningMethod(comp()), comp());\n               else if (!VAR_32->isOverriddenInThisHierarchy(resolvedMethod, VAR_6->getClass(), VAR_31->getOffset(), comp()))\n                  {\n                  VAR_33 = VAR_31->getOwningMethod(comp())->getResolvedVirtualMethod(comp(), VAR_6->getClass(), VAR_31->getOffset());\n                  VAR_34 = false;\n                  }\n               }\n\n            if (VAR_33 && !VAR_33->virtualMethodIsOverridden())\n               {\n               TR_PersistentClassInfo *VAR_22 = comp()->getPersistentInfo()->getPersistentCHTable()->findClassInfoAfterLocking(VAR_6->getClass(), comp());\n\n               /* COMMENT_24 */\n               /* COMMENT_25 */\n               /* COMMENT_0 */\n               bool VAR_29 = false;\n\n               if (comp()->ilGenRequest().details().supportsInvalidation())\n                  {\n                  VAR_29 = true;\n                  if ((comp()->getMethodHotness() == VAR_24) &&\n                        VAR_22 &&\n                        VAR_22->getNumPrexAssumptions() > comp()->getOptions()->getMaxNumPrexAssumptions())\n                     VAR_29 = false;\n\n                  /* COMMENT_31 */\n                  if (VAR_22 && VAR_29)\n                     {\n                     TR_ScratchList<TR_PersistentClassInfo> subClasses(trMemory());\n                     TR_ClassQueries::collectAllSubClasses(VAR_22, &VAR_37, comp());\n                     ListIterator<TR_PersistentClassInfo> VAR_38(&VAR_37);\n                     for (TR_PersistentClassInfo *VAR_39 = VAR_38.getFirst(); VAR_39; VAR_39 = VAR_38.getNext())\n                        {\n                        if (VAR_39->getNumPrexAssumptions() > comp()->getOptions()->getMaxNumPrexAssumptions())\n                           {\n                           VAR_29 = false;\n                           break;\n                           }\n                        }\n                     }\n                  }\n\n               if (VAR_29 &&\n                   performTransformation(comp(), \"%sspecialize and devirtualize invoke [%p] based on only a single implementation for call on parameter %d [%p]\\n\", optDetailString(), VAR_0, VAR_9, VAR_7))\n                  {\n                  if (VAR_34 || !VAR_33->isSameMethod(resolvedMethod))\n                     {\n                     TR::SymbolReference *VAR_40 =\n                      getSymRefTab()->findOrCreateMethodSymbol\n                                   (VAR_31->getOwningMethodIndex(), -1, VAR_33, TR::MethodSymbol::Virtual);\n                     VAR_40->copyAliasSets(VAR_31, getSymRefTab());\n\n                     int32_t VAR_41 = -1;\n                     if (VAR_15->isInterface())\n                        VAR_41 = VAR_0->getSymbolReference()->getOwningMethod(comp())->getResolvedInterfaceMethodOffset(VAR_33->containingClass(), VAR_0->getSymbolReference()->getCPIndex());\n                     else\n                        VAR_41 = VAR_31->getOffset();\n\n                     VAR_40->setOffset(VAR_41);\n                     VAR_0->setSymbolReference(VAR_40);\n                     }\n\n                  VAR_0->devirtualizeCall(VAR_1);\n                  if (VAR_1->getNode()->getOpCodeValue() == TR::ResolveCHK)\n                     TR::Node::recreate(VAR_1->getNode(), TR::treetop);\n                  else if (VAR_1->getNode()->getOpCodeValue() == TR::ResolveAndNULLCHK)\n                     TR::Node::recreate(VAR_1->getNode(), TR::NULLCHK);\n\n                  bool VAR_42 = comp()->getCHTable()->recompileOnNewClassExtend(comp(), VAR_6->getClass());\n\n                  if (VAR_22)\n                     {\n                     VAR_22->setShouldNotBeNewlyExtended(comp()->getCompThreadID());\n                     if (VAR_42) VAR_22->incNumPrexAssumptions();\n                     TR_ScratchList<TR_PersistentClassInfo> subClasses(trMemory());\n                     TR_ClassQueries::collectAllSubClasses(VAR_22, &VAR_37, comp());\n                     ListIterator<TR_PersistentClassInfo> VAR_38(&VAR_37);\n                     for (TR_PersistentClassInfo *VAR_39 = VAR_38.getFirst(); VAR_39; VAR_39 = VAR_38.getNext())\n                        {\n                        TR_OpaqueClassBlock *VAR_43 = (TR_OpaqueClassBlock *) VAR_39->getClassId();\n                        VAR_39->setShouldNotBeNewlyExtended(comp()->getCompThreadID());\n                        if (comp()->getCHTable()->recompileOnNewClassExtend(comp(), VAR_43))\n                           VAR_39->incNumPrexAssumptions();\n                        }\n                     }\n\n\n                  /* COMMENT_32 */\n                  VAR_44 = true;\n                  }\n               else\n                  {\n                  return;\n                  }\n               }\n            else\n               {\n               return;\n               }\n            }\n#endif\n         }\n      }\n\n\n   if (comp()->isPeekingMethod() && VAR_6->getClass() && !VAR_4)\n      {\n      TR::SymbolReference *VAR_31 = VAR_0->getSymbolReference();\n      int32_t VAR_41 = VAR_31->getOffset();\n      /* COMMENT_33 */\n      /* COMMENT_34 */\n      /* COMMENT_35 */\n\n      TR_ResolvedMethod *VAR_45 = resolvedMethod;\n      TR_OpaqueClassBlock *VAR_46 = VAR_45->containingClass();\n      bool VAR_47 = true;\n      if (VAR_46 != VAR_6->getClass())\n         {\n         TR_YesNoMaybe VAR_48 = fe()->isInstanceOf(VAR_46, VAR_6->getClass(), true);\n         if (VAR_48 == VAR_21)\n            VAR_47 = false;\n\n         VAR_48 = fe()->isInstanceOf(VAR_6->getClass(), VAR_46, true);\n         if (VAR_48 == VAR_49)\n            VAR_47 = false;\n         }\n\n      TR_ResolvedMethod *resolvedMethod = NULL;\n      if (VAR_47)\n         resolvedMethod = VAR_31->getOwningMethod(comp())->getResolvedVirtualMethod(comp(), VAR_6->getClass(), VAR_41);\n\n      if (resolvedMethod)\n         {\n         if (!VAR_45 || !resolvedMethod->isSameMethod(VAR_45))\n            {\n            TR::SymbolReference * VAR_40 =\n          VAR_50->findOrCreateMethodSymbol(\n                             VAR_31->getOwningMethodIndex(), -1, resolvedMethod, TR::MethodSymbol::Virtual);\n            VAR_40->copyAliasSets(VAR_31, VAR_50);\n            VAR_40->setOffset(VAR_41);\n            VAR_0->setSymbolReference(VAR_40);\n            }\n         }\n      }\n#endif\n   }",
  "func_graph_path": "eclipse/omr/f5ab765943c192e25ac8ea8d341f88e6ed9f90d2/LocalOpts.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -99,7 +99,62 @@\n \n    // Quit if class is not compatible with the method\n    if (resolvedMethod && receiverInfo->getClass() && !classIsCompatibleWithMethod(receiverInfo->getClass(), resolvedMethod))\n+      {\n+      if (trace())\n+         traceMsg(comp(), \"PREX:        - Receiver type incompatible with method \\n\");\n+\n       return;\n+      }\n+\n+   TR::MethodSymbol *methSymbol = node->getSymbol()->getMethodSymbol();\n+   if (methSymbol->isInterface())\n+      {\n+      // Interface type signatures can't be trusted most places in bytecode, so\n+      // only transform interface calls when we have a class bound for the\n+      // receiver.\n+      TR_OpaqueClassBlock *klass = receiverInfo->getClass();\n+      if (klass == NULL || TR::Compiler->cls.isInterfaceClass(comp(), klass))\n+         {\n+         if (trace())\n+            {\n+            traceMsg(\n+               comp(),\n+               \"PREX:        - No class type bound for interface call receiver\\n\");\n+            }\n+\n+         return;\n+         }\n+\n+      TR_ResolvedMethod *caller = node->getSymbolReference()->getOwningMethod(comp());\n+      TR::Method *callee = methSymbol->getMethod();\n+      bool aotOk = true;\n+      TR_OpaqueClassBlock *iface = fe()->getClassFromSignature(\n+         callee->classNameChars(), callee->classNameLength(), caller, aotOk);\n+\n+      if (iface == NULL)\n+         {\n+         if (trace())\n+            {\n+            traceMsg(\n+               comp(),\n+               \"PREX:        - Failed to identify interface for interface call\\n\");\n+            }\n+\n+         return;\n+         }\n+\n+      if (fe()->isInstanceOf(klass, iface, true, true, true) != TR_yes)\n+         {\n+         if (trace())\n+            {\n+            traceMsg(\n+               comp(),\n+               \"PREX:        - Insufficient class type bound for interface call receiver\\n\");\n+            }\n+\n+         return;\n+         }\n+      }\n \n    //\n    // Step 2: Transform\n@@ -203,7 +258,6 @@\n          TR::ClassTableCriticalSection processIndirectCall(comp()->fe());\n          TR::SymbolReference *symRef = node->getSymbolReference();\n          TR_PersistentCHTable * chTable = comp()->getPersistentInfo()->getPersistentCHTable();\n-         TR::MethodSymbol *methSymbol = node->getSymbol()->getMethodSymbol();\n          if (methSymbol->isInterface() || methodSymbol)\n             {\n             TR_ResolvedMethod * method = NULL;\n@@ -222,8 +276,16 @@\n                {\n                if (comp()->getPersistentInfo()->getRuntimeAssumptionTable()->getAssumptionCount(RuntimeAssumptionOnClassExtend) < 100000)\n                   method = chTable->findSingleInterfaceImplementer(receiverInfo->getClass(), node->getSymbolReference()->getCPIndex(), node->getSymbolReference()->getOwningMethod(comp()), comp());\n-               //if (method)\n-               //   fprintf(stderr, \"%s assumptios=%d\\n\", comp()->signature(), comp()->getPersistentInfo()->getRuntimeAssumptionTable()->getAssumptionCount(RuntimeAssumptionOnClassExtend));\n+               if (method == NULL)\n+                  {\n+                  if (trace())\n+                     {\n+                     traceMsg(\n+                        comp(),\n+                        \"PREX:        - Failed to find interface callee\\n\");\n+                     }\n+                  return;\n+                  }\n                }\n             else\n                {",
  "diff_line_info": {
    "deleted_lines": [
      "         TR::MethodSymbol *methSymbol = node->getSymbol()->getMethodSymbol();",
      "               //if (method)",
      "               //   fprintf(stderr, \"%s assumptios=%d\\n\", comp()->signature(), comp()->getPersistentInfo()->getRuntimeAssumptionTable()->getAssumptionCount(RuntimeAssumptionOnClassExtend));"
    ],
    "added_lines": [
      "      {",
      "      if (trace())",
      "         traceMsg(comp(), \"PREX:        - Receiver type incompatible with method \\n\");",
      "",
      "      }",
      "",
      "   TR::MethodSymbol *methSymbol = node->getSymbol()->getMethodSymbol();",
      "   if (methSymbol->isInterface())",
      "      {",
      "      // Interface type signatures can't be trusted most places in bytecode, so",
      "      // only transform interface calls when we have a class bound for the",
      "      // receiver.",
      "      TR_OpaqueClassBlock *klass = receiverInfo->getClass();",
      "      if (klass == NULL || TR::Compiler->cls.isInterfaceClass(comp(), klass))",
      "         {",
      "         if (trace())",
      "            {",
      "            traceMsg(",
      "               comp(),",
      "               \"PREX:        - No class type bound for interface call receiver\\n\");",
      "            }",
      "",
      "         return;",
      "         }",
      "",
      "      TR_ResolvedMethod *caller = node->getSymbolReference()->getOwningMethod(comp());",
      "      TR::Method *callee = methSymbol->getMethod();",
      "      bool aotOk = true;",
      "      TR_OpaqueClassBlock *iface = fe()->getClassFromSignature(",
      "         callee->classNameChars(), callee->classNameLength(), caller, aotOk);",
      "",
      "      if (iface == NULL)",
      "         {",
      "         if (trace())",
      "            {",
      "            traceMsg(",
      "               comp(),",
      "               \"PREX:        - Failed to identify interface for interface call\\n\");",
      "            }",
      "",
      "         return;",
      "         }",
      "",
      "      if (fe()->isInstanceOf(klass, iface, true, true, true) != TR_yes)",
      "         {",
      "         if (trace())",
      "            {",
      "            traceMsg(",
      "               comp(),",
      "               \"PREX:        - Insufficient class type bound for interface call receiver\\n\");",
      "            }",
      "",
      "         return;",
      "         }",
      "      }",
      "               if (method == NULL)",
      "                  {",
      "                  if (trace())",
      "                     {",
      "                     traceMsg(",
      "                        comp(),",
      "                        \"PREX:        - Failed to find interface callee\\n\");",
      "                     }",
      "                  return;",
      "                  }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/eclipse-omr/omr/pull/6773",
  "description": {
    "pr_info": {
      "title": "Stop devirtualizing interface calls in preexistence",
      "number": 6773
    },
    "comment": [
      "Previously, it was possible for the JIT to devirtualize an interface call, and for execution to reach the call (whether inlined or not) with a receiver that is not an instance of the class expected by the implementing method. The callee could then access fields of the receiver as though it were of the expected type.\r\n\r\nThe conditionals added in this commit still allow (on their own) for an interface call to be devirtualized when preexistence has already proven that the receiver is an instance of some particular class that implements the expected interface. However, preexistence currently fails to devirtualize in that situation. It passes the class to `TR_PersistentCHTable::findSingleInterfaceImplementer()`, which needs the interface. This can be improved in the future by having preexistence treat the call in the same way as a non-interface call, but with the added requirement that the devirtualized callee must be public.",
      "Jenkins build all",
      "Checks have passed except for known infra issues. The changes are quite safe in that we simply avoid optimizing in some cases where we cannot rely on signatures. Merging."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95"
}