{
  "cve_id": "CVE-2023-38851",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "libxls",
  "commit_msg": "Fix buffer overflows when parsing style records\n\nCloses #124, #126.\n\nAccording to https://download.microsoft.com/download/5/0/1/501ED102-E53F-4CE0-AA6B-B0F93629DDC6/Office/Excel97-2007BinaryFileFormat(xls)Specification.pdf\na \"STYLE: Style Information (293h)\" record might be 4 or 3+ bytes\nlong, depending on the first word.\n\nWe need to check that we've read enough bytes for the whole\nrecord, so\n- first we check that we have a word at least,\n- then we check the subtype of the record.\n- If it is a built-in style, then it has 4 bytes, so we check that.\n- Otherwise the length of the name is in byte 3, so the whole record\n  is 3 + buf[3] bytes long. So we need at least three bytes before we\n  check the length in byte 3. Then we check if we have 3 + buf[3]\n  bytes.",
  "commit_hash": "c009fa87fc775f8cc63e85d2018223143cb200e6",
  "git_url": "https://github.com/libxls/libxls/commit/c009fa87fc775f8cc63e85d2018223143cb200e6",
  "file_path": "src/xls.c",
  "func_name": "xls_isRecordTooSmall",
  "func_before": "int xls_isRecordTooSmall(xlsWorkBook *pWB, BOF *bof1) {\n    switch (bof1->id) {\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            return (bof1->size < 2 * sizeof(WORD));\n        case XLS_RECORD_CODEPAGE:\n            return (bof1->size < sizeof(WORD));\n\t\tcase XLS_RECORD_WINDOW1:\n            return (bof1->size < sizeof(WIND1));\n        case XLS_RECORD_SST:\n            return (bof1->size < offsetof(SST, strings));\n        case XLS_RECORD_BOUNDSHEET:\n            return (bof1->size < offsetof(BOUNDSHEET, name));\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n                return (bof1->size < sizeof(XF5));\n            }\n            return (bof1->size < sizeof(XF8));\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n            return (bof1->size < offsetof(FONT, name));\n        case XLS_RECORD_FORMAT:\n            return (bof1->size < offsetof(FORMAT, value));\n\t\tcase XLS_RECORD_1904:\n            return (bof1->size < sizeof(BYTE));\n        default:\n            break;\n    }\n    return 0;\n}",
  "abstract_func_before": "int xls_isRecordTooSmall(xlsWorkBook *VAR_0, BOF *VAR_1) {\n    switch (VAR_1->id) {\n        case VAR_2:\t/* COMMENT_0 */\n            return (VAR_1->size < 2 * sizeof(VAR_3));\n        case VAR_4:\n            return (VAR_1->size < sizeof(VAR_3));\n\t\tcase VAR_5:\n            return (VAR_1->size < sizeof(VAR_6));\n        case VAR_7:\n            return (VAR_1->size < offsetof(VAR_8, VAR_9));\n        case VAR_10:\n            return (VAR_1->size < offsetof(VAR_11, VAR_12));\n        case VAR_13:\n\t\t\tif(VAR_0->is5ver) {\n                return (VAR_1->size < sizeof(VAR_14));\n            }\n            return (VAR_1->size < sizeof(VAR_15));\n        case VAR_16:\n        case VAR_17:\n            return (VAR_1->size < offsetof(VAR_18, VAR_12));\n        case VAR_19:\n            return (VAR_1->size < offsetof(VAR_20, VAR_21));\n\t\tcase VAR_22:\n            return (VAR_1->size < sizeof(VAR_23));\n        default:\n            break;\n    }\n    return 0;\n}",
  "func_graph_path_before": "libxls/c009fa87fc775f8cc63e85d2018223143cb200e6/xls.c/vul/before/0.json",
  "func": "int xls_isRecordTooSmall(xlsWorkBook *pWB, BOF *bof1, const BYTE* buf) {\n    switch (bof1->id) {\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            return (bof1->size < 2 * sizeof(WORD));\n        case XLS_RECORD_CODEPAGE:\n            return (bof1->size < sizeof(WORD));\n\t\tcase XLS_RECORD_WINDOW1:\n            return (bof1->size < sizeof(WIND1));\n        case XLS_RECORD_SST:\n            return (bof1->size < offsetof(SST, strings));\n        case XLS_RECORD_BOUNDSHEET:\n            return (bof1->size < offsetof(BOUNDSHEET, name));\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n                return (bof1->size < sizeof(XF5));\n            }\n            return (bof1->size < sizeof(XF8));\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n            return (bof1->size < offsetof(FONT, name));\n        case XLS_RECORD_FORMAT:\n            return (bof1->size < offsetof(FORMAT, value));\n        case XLS_RECORD_STYLE:\n            {\n                struct {\n                    unsigned short idx;\n                    unsigned char ident;\n                    unsigned char lvl;\n                } *styl;\n                styl = (void *)buf;\n                if(bof1->size < 2) {\n                    return 1;\n                }\n                if(styl->idx & 0x8000) {\n                    return bof1->size < 4;\n                } else {\n                    if(bof1->size < 3) return 1;\n                    return bof1->size < 3 + styl->ident;\n                }\n            }\n\t\tcase XLS_RECORD_1904:\n            return (bof1->size < sizeof(BYTE));\n        default:\n            break;\n    }\n    return 0;\n}",
  "abstract_func": "int xls_isRecordTooSmall(xlsWorkBook *VAR_0, BOF *VAR_1, const BYTE* VAR_2) {\n    switch (VAR_1->id) {\n        case VAR_3:\t/* COMMENT_0 */\n            return (VAR_1->size < 2 * sizeof(VAR_4));\n        case VAR_5:\n            return (VAR_1->size < sizeof(VAR_4));\n\t\tcase VAR_6:\n            return (VAR_1->size < sizeof(VAR_7));\n        case VAR_8:\n            return (VAR_1->size < offsetof(VAR_9, VAR_10));\n        case VAR_11:\n            return (VAR_1->size < offsetof(VAR_12, VAR_13));\n        case VAR_14:\n\t\t\tif(VAR_0->is5ver) {\n                return (VAR_1->size < sizeof(VAR_15));\n            }\n            return (VAR_1->size < sizeof(VAR_16));\n        case VAR_17:\n        case VAR_18:\n            return (VAR_1->size < offsetof(VAR_19, VAR_13));\n        case VAR_20:\n            return (VAR_1->size < offsetof(VAR_21, VAR_22));\n        case VAR_23:\n            {\n                struct {\n                    unsigned short idx;\n                    unsigned char ident;\n                    unsigned char lvl;\n                } *VAR_24;\n                VAR_24 = (void *)VAR_2;\n                if(VAR_1->size < 2) {\n                    return 1;\n                }\n                if(VAR_24->idx & 0x8000) {\n                    return VAR_1->size < 4;\n                } else {\n                    if(VAR_1->size < 3) return 1;\n                    return VAR_1->size < 3 + VAR_24->ident;\n                }\n            }\n\t\tcase VAR_25:\n            return (VAR_1->size < sizeof(BYTE));\n        default:\n            break;\n    }\n    return 0;\n}",
  "func_graph_path": "libxls/c009fa87fc775f8cc63e85d2018223143cb200e6/xls.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-int xls_isRecordTooSmall(xlsWorkBook *pWB, BOF *bof1) {\n+int xls_isRecordTooSmall(xlsWorkBook *pWB, BOF *bof1, const BYTE* buf) {\n     switch (bof1->id) {\n         case XLS_RECORD_BOF:\t// BIFF5-8\n             return (bof1->size < 2 * sizeof(WORD));\n@@ -20,6 +20,24 @@\n             return (bof1->size < offsetof(FONT, name));\n         case XLS_RECORD_FORMAT:\n             return (bof1->size < offsetof(FORMAT, value));\n+        case XLS_RECORD_STYLE:\n+            {\n+                struct {\n+                    unsigned short idx;\n+                    unsigned char ident;\n+                    unsigned char lvl;\n+                } *styl;\n+                styl = (void *)buf;\n+                if(bof1->size < 2) {\n+                    return 1;\n+                }\n+                if(styl->idx & 0x8000) {\n+                    return bof1->size < 4;\n+                } else {\n+                    if(bof1->size < 3) return 1;\n+                    return bof1->size < 3 + styl->ident;\n+                }\n+            }\n \t\tcase XLS_RECORD_1904:\n             return (bof1->size < sizeof(BYTE));\n         default:",
  "diff_line_info": {
    "deleted_lines": [
      "int xls_isRecordTooSmall(xlsWorkBook *pWB, BOF *bof1) {"
    ],
    "added_lines": [
      "int xls_isRecordTooSmall(xlsWorkBook *pWB, BOF *bof1, const BYTE* buf) {",
      "        case XLS_RECORD_STYLE:",
      "            {",
      "                struct {",
      "                    unsigned short idx;",
      "                    unsigned char ident;",
      "                    unsigned char lvl;",
      "                } *styl;",
      "                styl = (void *)buf;",
      "                if(bof1->size < 2) {",
      "                    return 1;",
      "                }",
      "                if(styl->idx & 0x8000) {",
      "                    return bof1->size < 4;",
      "                } else {",
      "                    if(bof1->size < 3) return 1;",
      "                    return bof1->size < 3 + styl->ident;",
      "                }",
      "            }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libxls/libxls/pull/129",
  "description": {
    "pr_info": {
      "title": "Fix buffer overflows when parsing style records",
      "number": 129
    },
    "comment": [
      "Closes #124, #126.\r\n\r\nAccording to https://download.microsoft.com/download/5/0/1/501ED102-E53F-4CE0-AA6B-B0F93629DDC6/Office/Excel97-2007BinaryFileFormat(xls)Specification.pdf a \"STYLE: Style Information (293h)\" record might be 4 or 3+ bytes long, depending on the first word.\r\n\r\nWe need to check that we've read enough bytes for the whole record, so\r\n- first we check that we have a word at least,\r\n- then we check the subtype of the record.\r\n- If it is a built-in style, then it has 4 bytes, so we check that.\r\n- Otherwise the length of the name is in byte 3, so the whole record is 3 + buf[3] bytes long. So we need at least three bytes before we check the length in byte 3. Then we check if we have 3 + buf[3] bytes.\r\n\r\nThis bug also caused the buffer overflows in xlstools.c, the stack traces in #124 clearly show this. The functions in xlstools.c were called with the wrong arguments, i.e. the argument denoting the buffer length was wrong and the real buffer length was shorter.",
      "Perfect, thanks!!",
      "> Closes #124, #126.\r\n\r\nNote, you need to specify the trigger for both issues, so #126 didn't automatically close when this was merged. "
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}