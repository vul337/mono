{
  "cve_id": "CVE-2018-12264",
  "cwe_ids": [
    "CWE-190",
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "Exiv2/exiv2",
  "commit_msg": "Fix addition overflows in range checks in LoaderTiff::getData\n\nSeveral checks for extracted values performed no overflow checks on the\naddition. They can be tricked into passing, albeit the individual summands are\ntoo large.\n=> use Safe::add() which now aborts when an overflow occurs\nThis fixes #366",
  "commit_hash": "fe70939f54476e99046245ca69ff27012401f759",
  "git_url": "https://github.com/Exiv2/exiv2/commit/fe70939f54476e99046245ca69ff27012401f759",
  "file_path": "src/preview.cpp",
  "func_name": "LoaderTiff::getData",
  "func_before": "DataBuf LoaderTiff::getData() const\n    {\n        const ExifData &exifData = image_.exifData();\n\n        ExifData preview;\n\n        // copy tags\n        for (ExifData::const_iterator pos = exifData.begin(); pos != exifData.end(); ++pos) {\n            if (pos->groupName() == group_) {\n                /*\n                   Write only the necessary TIFF image tags\n                   tags that especially could cause problems are:\n                   \"NewSubfileType\" - the result is no longer a thumbnail, it is a standalone image\n                   \"Orientation\" - this tag typically appears only in the \"Image\" group. Deleting it ensures\n                                   consistent result for all previews, including JPEG\n                */\n                uint16_t tag = pos->tag();\n                if (tag != 0x00fe && tag != 0x00ff && Internal::isTiffImageTag(tag, Internal::ifd0Id)) {\n                    preview.add(ExifKey(tag, \"Image\"), &pos->value());\n                }\n            }\n        }\n\n        Value &dataValue = const_cast<Value&>(preview[\"Exif.Image.\" + offsetTag_].value());\n\n        if (dataValue.sizeDataArea() == 0) {\n            // image data are not available via exifData, read them from image_.io()\n            BasicIo &io = image_.io();\n\n            if (io.open() != 0) {\n                throw Error(kerDataSourceOpenFailed, io.path(), strError());\n            }\n            IoCloser closer(io);\n\n            const Exiv2::byte* base = io.mmap();\n\n            const Value &sizes = preview[\"Exif.Image.\" + sizeTag_].value();\n\n            if (sizes.count() == dataValue.count()) {\n                if (sizes.count() == 1) {\n                    // this saves one copying of the buffer\n                    uint32_t offset = dataValue.toLong(0);\n                    uint32_t size = sizes.toLong(0);\n                    if (offset + size <= static_cast<uint32_t>(io.size()))\n                        dataValue.setDataArea(base + offset, size);\n                }\n                else {\n                    // FIXME: the buffer is probably copied twice, it should be optimized\n                    DataBuf buf(size_);\n                    uint32_t idxBuf = 0;\n                    for (int i = 0; i < sizes.count(); i++) {\n                        uint32_t offset = dataValue.toLong(i);\n                        uint32_t size = sizes.toLong(i);\n                        enforce(idxBuf + size < size_, kerCorruptedMetadata);\n                        if (size!=0 && offset + size <= static_cast<uint32_t>(io.size()))\n                            memcpy(&buf.pData_[idxBuf], base + offset, size);\n                        idxBuf += size;\n                    }\n                    dataValue.setDataArea(buf.pData_, buf.size_);\n                }\n            }\n        }\n\n        // Fix compression value in the CR2 IFD2 image\n        if (0 == strcmp(group_, \"Image2\") && image_.mimeType() == \"image/x-canon-cr2\") {\n            preview[\"Exif.Image.Compression\"] = uint16_t(1);\n        }\n\n        // write new image\n        MemIo mio;\n        IptcData emptyIptc;\n        XmpData  emptyXmp;\n        TiffParser::encode(mio, 0, 0, Exiv2::littleEndian, preview, emptyIptc, emptyXmp);\n        return DataBuf(mio.mmap(), (long) mio.size());\n    }",
  "abstract_func_before": "DataBuf LoaderTiff::getData() const\n    {\n        const ExifData &VAR_0 = VAR_1.exifData();\n\n        ExifData VAR_2;\n\n        /* COMMENT_0 */\n        for (ExifData::const_iterator VAR_3 = VAR_0.begin(); VAR_3 != VAR_0.end(); ++VAR_3) {\n            if (VAR_3->groupName() == VAR_4) {\n                /* COMMENT_1 */\n                                                           \n                                                                 \n                                                                                                   \n                                                                                                            \n                                                                                     \n                  \n                uint16_t VAR_5 = VAR_3->tag();\n                if (VAR_5 != 0x00fe && VAR_5 != 0x00ff && Internal::isTiffImageTag(VAR_5, Internal::ifd0Id)) {\n                    VAR_2.add(ExifKey(VAR_5, \"Image\"), &VAR_3->value());\n                }\n            }\n        }\n\n        Value &VAR_6 = VAR_7<Value&>(VAR_2[\"Exif.Image.\" + VAR_8].value());\n\n        if (VAR_6.sizeDataArea() == 0) {\n            /* COMMENT_8 */\n            BasicIo &VAR_9 = VAR_1.io();\n\n            if (VAR_9.open() != 0) {\n                throw Error(VAR_10, VAR_9.path(), strError());\n            }\n            IoCloser closer(io);\n\n            const Exiv2::byte* VAR_11 = io.mmap();\n\n            const Value &VAR_12 = VAR_2[\"Exif.Image.\" + VAR_13].value();\n\n            if (VAR_12.count() == VAR_6.count()) {\n                if (VAR_12.count() == 1) {\n                    /* COMMENT_9 */\n                    uint32_t VAR_14 = VAR_6.toLong(0);\n                    uint32_t VAR_15 = VAR_12.toLong(0);\n                    if (VAR_14 + VAR_15 <= VAR_16<uint32_t>(io.size()))\n                        VAR_6.setDataArea(VAR_11 + VAR_14, VAR_15);\n                }\n                else {\n                    /* COMMENT_10 */\n                    DataBuf buf(size_);\n                    uint32_t VAR_17 = 0;\n                    for (int VAR_18 = 0; VAR_18 < VAR_12.count(); VAR_18++) {\n                        uint32_t VAR_14 = VAR_6.toLong(VAR_18);\n                        uint32_t VAR_15 = VAR_12.toLong(VAR_18);\n                        enforce(VAR_17 + VAR_15 < size_, VAR_19);\n                        if (VAR_15!=0 && VAR_14 + VAR_15 <= VAR_16<uint32_t>(io.size()))\n                            memcpy(&VAR_20.pData_[VAR_17], VAR_11 + VAR_14, VAR_15);\n                        VAR_17 += VAR_15;\n                    }\n                    VAR_6.setDataArea(VAR_20.pData_, VAR_20.size_);\n                }\n            }\n        }\n\n        /* COMMENT_11 */\n        if (0 == strcmp(VAR_4, \"Image2\") && VAR_1.mimeType() == \"image/x-canon-cr2\") {\n            VAR_2[\"Exif.Image.Compression\"] = uint16_t(1);\n        }\n\n        /* COMMENT_12 */\n        MemIo VAR_21;\n        IptcData VAR_22;\n        XmpData  VAR_23;\n        TiffParser::encode(VAR_21, 0, 0, Exiv2::littleEndian, VAR_2, VAR_22, VAR_23);\n        return DataBuf(VAR_21.mmap(), (long) VAR_21.size());\n    }",
  "func_graph_path_before": "Exiv2/exiv2/fe70939f54476e99046245ca69ff27012401f759/preview.cpp/vul/before/0.json",
  "func": "DataBuf LoaderTiff::getData() const\n    {\n        const ExifData &exifData = image_.exifData();\n\n        ExifData preview;\n\n        // copy tags\n        for (ExifData::const_iterator pos = exifData.begin(); pos != exifData.end(); ++pos) {\n            if (pos->groupName() == group_) {\n                /*\n                   Write only the necessary TIFF image tags\n                   tags that especially could cause problems are:\n                   \"NewSubfileType\" - the result is no longer a thumbnail, it is a standalone image\n                   \"Orientation\" - this tag typically appears only in the \"Image\" group. Deleting it ensures\n                                   consistent result for all previews, including JPEG\n                */\n                uint16_t tag = pos->tag();\n                if (tag != 0x00fe && tag != 0x00ff && Internal::isTiffImageTag(tag, Internal::ifd0Id)) {\n                    preview.add(ExifKey(tag, \"Image\"), &pos->value());\n                }\n            }\n        }\n\n        Value &dataValue = const_cast<Value&>(preview[\"Exif.Image.\" + offsetTag_].value());\n\n        if (dataValue.sizeDataArea() == 0) {\n            // image data are not available via exifData, read them from image_.io()\n            BasicIo &io = image_.io();\n\n            if (io.open() != 0) {\n                throw Error(kerDataSourceOpenFailed, io.path(), strError());\n            }\n            IoCloser closer(io);\n\n            const Exiv2::byte* base = io.mmap();\n\n            const Value &sizes = preview[\"Exif.Image.\" + sizeTag_].value();\n\n            if (sizes.count() == dataValue.count()) {\n                if (sizes.count() == 1) {\n                    // this saves one copying of the buffer\n                    uint32_t offset = dataValue.toLong(0);\n                    uint32_t size = sizes.toLong(0);\n                    if (Safe::add(offset, size) <= static_cast<uint32_t>(io.size()))\n                        dataValue.setDataArea(base + offset, size);\n                }\n                else {\n                    // FIXME: the buffer is probably copied twice, it should be optimized\n                    DataBuf buf(size_);\n                    uint32_t idxBuf = 0;\n                    for (int i = 0; i < sizes.count(); i++) {\n                        uint32_t offset = dataValue.toLong(i);\n                        uint32_t size = sizes.toLong(i);\n                        enforce(Safe::add(idxBuf, size) < size_, kerCorruptedMetadata);\n                        if (size!=0 && Safe::add(offset, size) <= static_cast<uint32_t>(io.size()))\n                            memcpy(&buf.pData_[idxBuf], base + offset, size);\n                        idxBuf += size;\n                    }\n                    dataValue.setDataArea(buf.pData_, buf.size_);\n                }\n            }\n        }\n\n        // Fix compression value in the CR2 IFD2 image\n        if (0 == strcmp(group_, \"Image2\") && image_.mimeType() == \"image/x-canon-cr2\") {\n            preview[\"Exif.Image.Compression\"] = uint16_t(1);\n        }\n\n        // write new image\n        MemIo mio;\n        IptcData emptyIptc;\n        XmpData  emptyXmp;\n        TiffParser::encode(mio, 0, 0, Exiv2::littleEndian, preview, emptyIptc, emptyXmp);\n        return DataBuf(mio.mmap(), (long) mio.size());\n    }",
  "abstract_func": "DataBuf LoaderTiff::getData() const\n    {\n        const ExifData &VAR_0 = VAR_1.exifData();\n\n        ExifData VAR_2;\n\n        /* COMMENT_0 */\n        for (ExifData::const_iterator VAR_3 = VAR_0.begin(); VAR_3 != VAR_0.end(); ++VAR_3) {\n            if (VAR_3->groupName() == VAR_4) {\n                /* COMMENT_1 */\n                                                           \n                                                                 \n                                                                                                   \n                                                                                                            \n                                                                                     \n                  \n                uint16_t VAR_5 = VAR_3->tag();\n                if (VAR_5 != 0x00fe && VAR_5 != 0x00ff && Internal::isTiffImageTag(VAR_5, Internal::ifd0Id)) {\n                    VAR_2.add(ExifKey(VAR_5, \"Image\"), &VAR_3->value());\n                }\n            }\n        }\n\n        Value &VAR_6 = VAR_7<Value&>(VAR_2[\"Exif.Image.\" + VAR_8].value());\n\n        if (VAR_6.sizeDataArea() == 0) {\n            /* COMMENT_8 */\n            BasicIo &VAR_9 = VAR_1.io();\n\n            if (VAR_9.open() != 0) {\n                throw Error(VAR_10, VAR_9.path(), strError());\n            }\n            IoCloser closer(io);\n\n            const Exiv2::byte* VAR_11 = io.mmap();\n\n            const Value &VAR_12 = VAR_2[\"Exif.Image.\" + VAR_13].value();\n\n            if (VAR_12.count() == VAR_6.count()) {\n                if (VAR_12.count() == 1) {\n                    /* COMMENT_9 */\n                    uint32_t VAR_14 = VAR_6.toLong(0);\n                    uint32_t VAR_15 = VAR_12.toLong(0);\n                    if (Safe::add(VAR_14, VAR_15) <= VAR_16<uint32_t>(io.size()))\n                        VAR_6.setDataArea(VAR_11 + VAR_14, VAR_15);\n                }\n                else {\n                    /* COMMENT_10 */\n                    DataBuf buf(size_);\n                    uint32_t VAR_17 = 0;\n                    for (int VAR_18 = 0; VAR_18 < VAR_12.count(); VAR_18++) {\n                        uint32_t VAR_14 = VAR_6.toLong(VAR_18);\n                        uint32_t VAR_15 = VAR_12.toLong(VAR_18);\n                        enforce(Safe::add(VAR_17, VAR_15) < size_, VAR_19);\n                        if (VAR_15!=0 && Safe::add(VAR_14, VAR_15) <= VAR_16<uint32_t>(io.size()))\n                            memcpy(&VAR_20.pData_[VAR_17], VAR_11 + VAR_14, VAR_15);\n                        VAR_17 += VAR_15;\n                    }\n                    VAR_6.setDataArea(VAR_20.pData_, VAR_20.size_);\n                }\n            }\n        }\n\n        /* COMMENT_11 */\n        if (0 == strcmp(VAR_4, \"Image2\") && VAR_1.mimeType() == \"image/x-canon-cr2\") {\n            VAR_2[\"Exif.Image.Compression\"] = uint16_t(1);\n        }\n\n        /* COMMENT_12 */\n        MemIo VAR_21;\n        IptcData VAR_22;\n        XmpData  VAR_23;\n        TiffParser::encode(VAR_21, 0, 0, Exiv2::littleEndian, VAR_2, VAR_22, VAR_23);\n        return DataBuf(VAR_21.mmap(), (long) VAR_21.size());\n    }",
  "func_graph_path": "Exiv2/exiv2/fe70939f54476e99046245ca69ff27012401f759/preview.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -41,7 +41,7 @@\n                     // this saves one copying of the buffer\n                     uint32_t offset = dataValue.toLong(0);\n                     uint32_t size = sizes.toLong(0);\n-                    if (offset + size <= static_cast<uint32_t>(io.size()))\n+                    if (Safe::add(offset, size) <= static_cast<uint32_t>(io.size()))\n                         dataValue.setDataArea(base + offset, size);\n                 }\n                 else {\n@@ -51,8 +51,8 @@\n                     for (int i = 0; i < sizes.count(); i++) {\n                         uint32_t offset = dataValue.toLong(i);\n                         uint32_t size = sizes.toLong(i);\n-                        enforce(idxBuf + size < size_, kerCorruptedMetadata);\n-                        if (size!=0 && offset + size <= static_cast<uint32_t>(io.size()))\n+                        enforce(Safe::add(idxBuf, size) < size_, kerCorruptedMetadata);\n+                        if (size!=0 && Safe::add(offset, size) <= static_cast<uint32_t>(io.size()))\n                             memcpy(&buf.pData_[idxBuf], base + offset, size);\n                         idxBuf += size;\n                     }",
  "diff_line_info": {
    "deleted_lines": [
      "                    if (offset + size <= static_cast<uint32_t>(io.size()))",
      "                        enforce(idxBuf + size < size_, kerCorruptedMetadata);",
      "                        if (size!=0 && offset + size <= static_cast<uint32_t>(io.size()))"
    ],
    "added_lines": [
      "                    if (Safe::add(offset, size) <= static_cast<uint32_t>(io.size()))",
      "                        enforce(Safe::add(idxBuf, size) < size_, kerCorruptedMetadata);",
      "                        if (size!=0 && Safe::add(offset, size) <= static_cast<uint32_t>(io.size()))"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/Exiv2/exiv2/pull/368",
  "description": {
    "pr_info": {
      "title": "Fix #365 and #366",
      "number": 368
    },
    "comment": [
      "Both issues are caused by integer overflows circumventing range checks that were put in place to prevent bad things from happening. I have found the two places where additions would overflow and inserted a `Safe::add` (in `LoaderTiff::getData` and `LoaderExifJpeg::LoaderExifJpeg`, in the former there were a few more problematic cases, so I replaced them too).\r\n\r\nUnfortunately, this would result in in `abort()` being called, since `std::overflow_error` is not caught by the extract action. I have therefore wrapped the `main()` of exiv2 in a try ... catch to catch all uncaught exceptions and just report them thereby terminating gracefully.\r\n\r\nTo make this PR a little too big, I have removed two useless casts in `preview.cpp` that annoyed me with warnings during compilation."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}