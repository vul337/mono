{
  "cve_id": "CVE-2018-9165",
  "cwe_ids": [
    "CWE-476"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "libming",
  "commit_msg": "Fix heap-buffer-overflow in getString\n\ngetString is allocating a 4-bytes buffer to store an 'R' and an\n8-bit number.\n\nt=malloc(4); /* Rdd */\nsprintf(t,\"R%d\", act->p.RegisterNumber );\nreturn t;\n\nSince up to three digits can be required to store the 8-bit\nnumber, the buffer has to be 5 bytes long.\n\nIn this commit we also fix the PUSH_DOUBLE case by dynamically\ncomputing the required buffer size.\n\nThis commit fixes #116 (CVE-2018-7867).",
  "commit_hash": "eea2a55a0aa339d47e65c1c8e60068cf3cc20393",
  "git_url": "https://github.com/libming/libming/commit/eea2a55a0aa339d47e65c1c8e60068cf3cc20393",
  "file_path": "util/decompile.c",
  "func_name": "getName",
  "func_before": "static char *\ngetName(struct SWF_ACTIONPUSHPARAM *act)\n{\n\tchar *t;\n\n\tswitch( act->Type ) \t\n\t{\n\tcase PUSH_STRING: /* STRING */\n\t\tif (!act->p.String) /* Not a NULL string */\n\t\t{\n\t\t        SWF_warn(\"WARNING: Call to getName with NULL string.\\n\");\n\t\t        break;\n\t\t}\n\t\telse if (strlen(act->p.String)) /* Not a zero length string */\n\t\t{\n\t\t        t=malloc(strlen(act->p.String)+3);\n\t\t        strcpyext(t,act->p.String);\n\t\t        return t;\n\t\t}\n\t\telse\n\t\t{\n\t\t        char *return_string = \"this\";\n\t                t=malloc(strlen(return_string)+1); /* string length + \\0 */\n\t                strcpyext(t,return_string);\n\t\t\treturn t;\n\t\t}\n#if 0\n\t  case 4: /* REGISTER */\n                t=malloc(4); /* Rdd */\n  \t\tsprintf(t,\"R%d\", act->p.RegisterNumber );\n  \t\treturn t;\n#endif\n\tcase PUSH_CONSTANT: /* CONSTANT8 */\n\t\tif (act->p.Constant8 > poolcounter)\n\t\t{\n\t\t        SWF_warn(\"WARNING: retrieving constants not present in the pool.\\n\");\n\t\t        break;\n\t\t}\n\t\tt=malloc(strlenext(pool[act->p.Constant8])+1);\n\t\tstrcpyext(t,pool[act->p.Constant8]);\n\t\tif(strlen(t)) /* Not a zero length string */\n\t\t\treturn t;\n\t\telse\n\t\t{\n\t\t\tt=realloc(t,6);\n\t\t\treturn strcpy(t,\"this\");\n\t\t}\n\tcase PUSH_CONSTANT16: /* CONSTANT16 */\n\t\tif (act->p.Constant16 > poolcounter)\n\t\t{\n\t\t        SWF_warn(\"WARNING: retrieving constants not present in the pool.\\n\");\n\t\t        break;\n\t\t}\n\t\tt=malloc(strlenext(pool[act->p.Constant16])+1);\n\t\tstrcpyext(t,pool[act->p.Constant16]);\n\t\tif(strlen(t)) /* Not a zero length string */\n\t\t\treturn t;\n\t\telse\n\t\t{\n\t\t\tt=realloc(t,6);\n\t\t\treturn strcpy(t,\"this\");\n\t\t}\n\tdefault: \n\t\treturn getString(act);\n\t}\n\n\tt = malloc(sizeof(char));\n\tstrcpyext(t,\"\");\n\n\treturn t;\n}",
  "abstract_func_before": "static char *\ngetName(struct SWF_ACTIONPUSHPARAM *VAR_0)\n{\n\tchar *VAR_1;\n\n\tswitch( VAR_0->Type ) \t\n\t{\n\tcase VAR_2: /* COMMENT_0 */\n\t\tif (!VAR_0->p.String) /* COMMENT_1 */\n\t\t{\n\t\t        SWF_warn(\"WARNING: Call to getName with NULL string.\\n\");\n\t\t        break;\n\t\t}\n\t\telse if (strlen(VAR_0->p.String)) /* COMMENT_2 */\n\t\t{\n\t\t        VAR_1=malloc(strlen(VAR_0->p.String)+3);\n\t\t        strcpyext(VAR_1,VAR_0->p.String);\n\t\t        return VAR_1;\n\t\t}\n\t\telse\n\t\t{\n\t\t        char *VAR_3 = \"this\";\n\t                VAR_1=malloc(strlen(VAR_3)+1); /* COMMENT_3 */\n\t                strcpyext(VAR_1,VAR_3);\n\t\t\treturn VAR_1;\n\t\t}\n#if 0\n\t  case 4: /* COMMENT_4 */\n                VAR_1=malloc(4); /* COMMENT_5 */\n  \t\tsprintf(VAR_1,\"R%d\", VAR_0->p.RegisterNumber );\n  \t\treturn VAR_1;\n#endif\n\tcase VAR_4: /* COMMENT_6 */\n\t\tif (VAR_0->p.Constant8 > VAR_5)\n\t\t{\n\t\t        SWF_warn(\"WARNING: retrieving constants not present in the pool.\\n\");\n\t\t        break;\n\t\t}\n\t\tVAR_1=malloc(strlenext(VAR_6[VAR_0->p.Constant8])+1);\n\t\tstrcpyext(VAR_1,VAR_6[VAR_0->p.Constant8]);\n\t\tif(strlen(VAR_1)) /* COMMENT_2 */\n\t\t\treturn VAR_1;\n\t\telse\n\t\t{\n\t\t\tVAR_1=realloc(VAR_1,6);\n\t\t\treturn strcpy(VAR_1,\"this\");\n\t\t}\n\tcase VAR_7: /* COMMENT_7 */\n\t\tif (VAR_0->p.Constant16 > VAR_5)\n\t\t{\n\t\t        SWF_warn(\"WARNING: retrieving constants not present in the pool.\\n\");\n\t\t        break;\n\t\t}\n\t\tVAR_1=malloc(strlenext(VAR_6[VAR_0->p.Constant16])+1);\n\t\tstrcpyext(VAR_1,VAR_6[VAR_0->p.Constant16]);\n\t\tif(strlen(VAR_1)) /* COMMENT_2 */\n\t\t\treturn VAR_1;\n\t\telse\n\t\t{\n\t\t\tVAR_1=realloc(VAR_1,6);\n\t\t\treturn strcpy(VAR_1,\"this\");\n\t\t}\n\tdefault: \n\t\treturn getString(VAR_0);\n\t}\n\n\tVAR_1 = malloc(sizeof(char));\n\tstrcpyext(VAR_1,\"\");\n\n\treturn VAR_1;\n}",
  "func_graph_path_before": "libming/eea2a55a0aa339d47e65c1c8e60068cf3cc20393/decompile.c/vul/before/0.json",
  "func": "static char *\ngetName(struct SWF_ACTIONPUSHPARAM *act)\n{\n\tchar *t;\n\n\tswitch( act->Type ) \t\n\t{\n\tcase PUSH_STRING: /* STRING */\n\t\tif (!act->p.String) /* Not a NULL string */\n\t\t{\n\t\t        SWF_warn(\"WARNING: Call to getName with NULL string.\\n\");\n\t\t        break;\n\t\t}\n\t\telse if (strlen(act->p.String)) /* Not a zero length string */\n\t\t{\n\t\t        t=malloc(strlen(act->p.String)+3);\n\t\t        strcpyext(t,act->p.String);\n\t\t        return t;\n\t\t}\n\t\telse\n\t\t{\n\t\t        char *return_string = \"this\";\n\t                t=malloc(strlen(return_string)+1); /* string length + \\0 */\n\t                strcpyext(t,return_string);\n\t\t\treturn t;\n\t\t}\n#if 0\n\t  case 4: /* REGISTER */\n\t\tt=malloc(5); /* Rddd */\n  \t\tsprintf(t,\"R%d\", act->p.RegisterNumber );\n  \t\treturn t;\n#endif\n\tcase PUSH_CONSTANT: /* CONSTANT8 */\n\t\tif (act->p.Constant8 > poolcounter)\n\t\t{\n\t\t        SWF_warn(\"WARNING: retrieving constants not present in the pool.\\n\");\n\t\t        break;\n\t\t}\n\t\tt=malloc(strlenext(pool[act->p.Constant8])+1);\n\t\tstrcpyext(t,pool[act->p.Constant8]);\n\t\tif(strlen(t)) /* Not a zero length string */\n\t\t\treturn t;\n\t\telse\n\t\t{\n\t\t\tt=realloc(t,6);\n\t\t\treturn strcpy(t,\"this\");\n\t\t}\n\tcase PUSH_CONSTANT16: /* CONSTANT16 */\n\t\tif (act->p.Constant16 > poolcounter)\n\t\t{\n\t\t        SWF_warn(\"WARNING: retrieving constants not present in the pool.\\n\");\n\t\t        break;\n\t\t}\n\t\tt=malloc(strlenext(pool[act->p.Constant16])+1);\n\t\tstrcpyext(t,pool[act->p.Constant16]);\n\t\tif(strlen(t)) /* Not a zero length string */\n\t\t\treturn t;\n\t\telse\n\t\t{\n\t\t\tt=realloc(t,6);\n\t\t\treturn strcpy(t,\"this\");\n\t\t}\n\tdefault: \n\t\treturn getString(act);\n\t}\n\n\tt = malloc(sizeof(char));\n\tstrcpyext(t,\"\");\n\n\treturn t;\n}",
  "abstract_func": "static char *\ngetName(struct SWF_ACTIONPUSHPARAM *VAR_0)\n{\n\tchar *VAR_1;\n\n\tswitch( VAR_0->Type ) \t\n\t{\n\tcase VAR_2: /* COMMENT_0 */\n\t\tif (!VAR_0->p.String) /* COMMENT_1 */\n\t\t{\n\t\t        SWF_warn(\"WARNING: Call to getName with NULL string.\\n\");\n\t\t        break;\n\t\t}\n\t\telse if (strlen(VAR_0->p.String)) /* COMMENT_2 */\n\t\t{\n\t\t        VAR_1=malloc(strlen(VAR_0->p.String)+3);\n\t\t        strcpyext(VAR_1,VAR_0->p.String);\n\t\t        return VAR_1;\n\t\t}\n\t\telse\n\t\t{\n\t\t        char *VAR_3 = \"this\";\n\t                VAR_1=malloc(strlen(VAR_3)+1); /* COMMENT_3 */\n\t                strcpyext(VAR_1,VAR_3);\n\t\t\treturn VAR_1;\n\t\t}\n#if 0\n\t  case 4: /* COMMENT_4 */\n\t\tVAR_1=malloc(5); /* COMMENT_5 */\n  \t\tsprintf(VAR_1,\"R%d\", VAR_0->p.RegisterNumber );\n  \t\treturn VAR_1;\n#endif\n\tcase VAR_4: /* COMMENT_6 */\n\t\tif (VAR_0->p.Constant8 > VAR_5)\n\t\t{\n\t\t        SWF_warn(\"WARNING: retrieving constants not present in the pool.\\n\");\n\t\t        break;\n\t\t}\n\t\tVAR_1=malloc(strlenext(VAR_6[VAR_0->p.Constant8])+1);\n\t\tstrcpyext(VAR_1,VAR_6[VAR_0->p.Constant8]);\n\t\tif(strlen(VAR_1)) /* COMMENT_2 */\n\t\t\treturn VAR_1;\n\t\telse\n\t\t{\n\t\t\tVAR_1=realloc(VAR_1,6);\n\t\t\treturn strcpy(VAR_1,\"this\");\n\t\t}\n\tcase VAR_7: /* COMMENT_7 */\n\t\tif (VAR_0->p.Constant16 > VAR_5)\n\t\t{\n\t\t        SWF_warn(\"WARNING: retrieving constants not present in the pool.\\n\");\n\t\t        break;\n\t\t}\n\t\tVAR_1=malloc(strlenext(VAR_6[VAR_0->p.Constant16])+1);\n\t\tstrcpyext(VAR_1,VAR_6[VAR_0->p.Constant16]);\n\t\tif(strlen(VAR_1)) /* COMMENT_2 */\n\t\t\treturn VAR_1;\n\t\telse\n\t\t{\n\t\t\tVAR_1=realloc(VAR_1,6);\n\t\t\treturn strcpy(VAR_1,\"this\");\n\t\t}\n\tdefault: \n\t\treturn getString(VAR_0);\n\t}\n\n\tVAR_1 = malloc(sizeof(char));\n\tstrcpyext(VAR_1,\"\");\n\n\treturn VAR_1;\n}",
  "func_graph_path": "libming/eea2a55a0aa339d47e65c1c8e60068cf3cc20393/decompile.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -26,7 +26,7 @@\n \t\t}\n #if 0\n \t  case 4: /* REGISTER */\n-                t=malloc(4); /* Rdd */\n+\t\tt=malloc(5); /* Rddd */\n   \t\tsprintf(t,\"R%d\", act->p.RegisterNumber );\n   \t\treturn t;\n #endif",
  "diff_line_info": {
    "deleted_lines": [
      "                t=malloc(4); /* Rdd */"
    ],
    "added_lines": [
      "\t\tt=malloc(5); /* Rddd */"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libming/libming/pull/127",
  "description": {
    "pr_info": {
      "title": "Fix null pointer dereference in getName/getString",
      "number": 127
    },
    "comment": [
      "Whenever `getString` or `getName` are called with an act such that `act->p.String` is a NULL pointer, a NULL pointer dereference might happen (`strlen(act->p.string)` is called).\r\n\r\nIn this commit we add checks at the beginning of the `PUSH_STRING` block so that a warning is displayed and an empty string is returned in this case.\r\n\r\nThis PR (partially) fixes #121. In fact I am still working on another patch which would involve patching `pushdup` to do deep copies instead of shallow copies, but before I will have to analyze the specification in order to be able to clearly state which interpretation is the right one.",
      "I have just added another commit addressing #116.",
      "snprintf returns number of characters that would have been printed\nout _excluding_ the terminating NULL so I think you'll want to\nincrement the return of it by 1 before assigning to \"needed_length\"\n",
      "Thanks Sandro for the feedback. I have pushed an updated patch which also handles the case where `snprintf` would return negative `needed_length` (error code). Not sure in which circumstances this might happen, but better check it.",
      "I have just pushed the changes to `pushdup`. See commit message for more information. This PR now fully adresses #121 and #116.",
      "Oh well, wait, looks like something is still going wrong.\r\n\r\nI'm going to push an updated version of this PR soon.",
      "It should be fine now. There is a fairly high amount of changes, so even if I already tested everything, a careful review would be nice.\r\n\r\nThanks !",
      "Any chance you could look at re-introducing the now-broken\n\"make gen\" rule under test/ directory ?\n\nThe rule is still present in test/Makefile.inc but that Makefile\nis not included by test/Makefile.am. The \"make gen\" rule is\nreferenced by test/README and Makefile.inc itself has some\ninteresting comments/documentation.\n\nI'm thinking it could be useful to test all the changes you\nare doing in the decompiler.\n",
      "While I indeed think writing unit tests would be a very important step towards more stability in libming, this is most likely not something that I can do as part of my Debian LTS duties, and I don't have much spare time currently...\r\n\r\nIs there any bug report on this build system issue ? If I can get a precise description of the problem, I'll maybe check if can do something.",
      "But anyways, this is not something I'd do in this PR.",
      "Ok thanks, tests postponed",
      "Thanks !"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}