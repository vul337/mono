{
  "cve_id": "CVE-2021-46879",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "fluent/fluent-bit",
  "commit_msg": "flb_pack: fix OSS-Fuzz issue 5076752961110016\n\nSigned-off-by: davkor <david@adalogics.com>",
  "commit_hash": "75f0e0e5f7267682674029820524d22460f498b0",
  "git_url": "https://github.com/fluent/fluent-bit/commit/75f0e0e5f7267682674029820524d22460f498b0",
  "file_path": "src/flb_pack_gelf.c",
  "func_name": "flb_msgpack_to_gelf",
  "func_before": "flb_sds_t flb_msgpack_to_gelf(flb_sds_t *s, msgpack_object *o,\n                              struct flb_time *tm,\n                              struct flb_gelf_fields *fields)\n{\n    int i;\n    int loop;\n    flb_sds_t tmp;\n\n    int host_key_found = FLB_FALSE;\n    int timestamp_key_found = FLB_FALSE;\n    int level_key_found = FLB_FALSE;\n    int short_message_key_found = FLB_FALSE;\n    int full_message_key_found = FLB_FALSE;\n\n    char *host_key = NULL;\n    char *timestamp_key = NULL;\n    char *level_key = NULL;\n    char *short_message_key = NULL;\n    char *full_message_key = NULL;\n\n    int host_key_len = 0;\n    int timestamp_key_len = false;\n    int level_key_len = 0;\n    int short_message_key_len = 0;\n    int full_message_key_len = 0;\n\n    if (s == NULL || o == NULL) {\n        return NULL;\n    }\n\n    /* Make sure the incoming object is a map */\n    if (o->type != MSGPACK_OBJECT_MAP) {\n        return NULL;\n    }\n\n    if (fields != NULL && fields->host_key != NULL) {\n        host_key = fields->host_key;\n        host_key_len = flb_sds_len(fields->host_key);\n    }\n    else {\n        host_key = \"host\";\n        host_key_len = 4;\n    }\n\n    if (fields != NULL && fields->timestamp_key != NULL) {\n        timestamp_key = fields->timestamp_key;\n        timestamp_key_len = flb_sds_len(fields->timestamp_key);\n    }\n    else {\n        timestamp_key = \"timestamp\";\n        timestamp_key_len = 9;\n    }\n\n    if (fields != NULL && fields->level_key != NULL) {\n        level_key = fields->level_key;\n        level_key_len = flb_sds_len(fields->level_key);\n    }\n    else {\n        level_key = \"level\";\n        level_key_len = 5;\n    }\n\n    if (fields != NULL && fields->short_message_key != NULL) {\n        short_message_key = fields->short_message_key;\n        short_message_key_len = flb_sds_len(fields->short_message_key);\n    }\n    else {\n        short_message_key = \"short_message\";\n        short_message_key_len = 13;\n    }\n\n    if (fields != NULL && fields->full_message_key != NULL) {\n        full_message_key = fields->full_message_key;\n        full_message_key_len = flb_sds_len(fields->full_message_key);\n    }\n    else {\n        full_message_key = \"full_message\";\n        full_message_key_len = 12;\n    }\n\n    tmp = flb_sds_cat(*s, \"{\\\"version\\\":\\\"1.1\\\"\", 16);\n    if (tmp == NULL) {\n        return NULL;\n    }\n    *s = tmp;\n\n    loop = o->via.map.size;\n    if (loop != 0) {\n        msgpack_object_kv *p = o->via.map.ptr;\n\n        for (i = 0; i < loop; i++) {\n            const char *key = NULL;\n            int key_len;\n            const char *val = NULL;\n            int val_len = 0;\n            int quote = FLB_FALSE;\n            int custom_key = FLB_FALSE;\n\n            msgpack_object *k = &p[i].key;\n            msgpack_object *v = &p[i].val;\n            msgpack_object vtmp; // used when converting level value from string to int\n\n            if (k->type != MSGPACK_OBJECT_BIN && k->type != MSGPACK_OBJECT_STR) {\n                continue;\n            }\n\n            if (k->type == MSGPACK_OBJECT_STR) {\n                key = k->via.str.ptr;\n                key_len = k->via.str.size;\n            }\n            else {\n                key = k->via.bin.ptr;\n                key_len = k->via.bin.size;\n            }\n\n            if ((key_len == host_key_len) &&\n                !strncmp(key, host_key, host_key_len)) {\n                if (host_key_found == FLB_TRUE) {\n                    continue;\n                }\n                host_key_found = FLB_TRUE;\n                key = \"host\";\n                key_len = 4;\n            }\n            else if ((key_len == short_message_key_len) &&\n                     !strncmp(key, short_message_key, short_message_key_len)) {\n                if (short_message_key_found == FLB_TRUE) {\n                    continue;\n                }\n                short_message_key_found = FLB_TRUE;\n                key = \"short_message\";\n                key_len = 13;\n            }\n            else if ((key_len == timestamp_key_len) &&\n                     !strncmp(key, timestamp_key, timestamp_key_len)) {\n                if (timestamp_key_found == FLB_TRUE) {\n                    continue;\n                }\n                timestamp_key_found = FLB_TRUE;\n                key = \"timestamp\";\n                key_len = 9;\n            }\n            else if ((key_len == level_key_len) &&\n                     !strncmp(key, level_key, level_key_len )) {\n                if (level_key_found == FLB_TRUE) {\n                    continue;\n                }\n                level_key_found = FLB_TRUE;\n                key = \"level\";\n                key_len = 5;\n                if (v->type == MSGPACK_OBJECT_POSITIVE_INTEGER) {\n                    if ( v->via.u64 > 7 ) {\n                        flb_warn(\"[flb_msgpack_to_gelf] level is %\" PRIu64 \", \"\n                                  \"but should be in 0..7 or a syslog keyword\", v->via.u64);\n                    }\n                }\n                else if (v->type == MSGPACK_OBJECT_STR) {\n                    val     = v->via.str.ptr;\n                    val_len = v->via.str.size;\n                    if (val_len == 1 && val[0] >= '0' && val[0] <= '7') {\n                        v = &vtmp;\n                        v->type = MSGPACK_OBJECT_POSITIVE_INTEGER;\n                        v->via.u64 = (uint64_t)(val[0] - '0');\n                    }\n                    else {\n                        int n;\n                        char* allowed_levels[] = {\n                            \"emerg\", \"alert\", \"crit\", \"err\",\n                            \"warning\", \"notice\", \"info\", \"debug\",\n                            NULL\n                        };\n                        for (n = 0; allowed_levels[n] != NULL; ++n) {\n                            if (val_len == strlen(allowed_levels[n]) &&\n                                !strncasecmp(val, allowed_levels[n], val_len)) {\n                                v = &vtmp;\n                                v->type = MSGPACK_OBJECT_POSITIVE_INTEGER;\n                                v->via.u64 = (uint64_t)n;\n                                break;\n                            }\n                        }\n                        if (allowed_levels[n] == NULL) {\n                            flb_warn(\"[flb_msgpack_to_gelf] level is '%.*s', \"\n                                      \"but should be in 0..7 or a syslog keyword\", val_len, val);\n                        }\n                    }\n                }\n                else {\n                    flb_error(\"[flb_msgpack_to_gelf] level must be a non-negative integer or a string\");\n                    return NULL;\n                }\n            }\n            else if ((key_len == full_message_key_len) &&\n                     !strncmp(key, full_message_key, full_message_key_len)) {\n                if (full_message_key_found == FLB_TRUE) {\n                    continue;\n                }\n                full_message_key_found = FLB_TRUE;\n                key = \"full_message\";\n                key_len = 12;\n            }\n            else if ((key_len == 2)  && !strncmp(key, \"id\", 2)) {\n                /* _id key not allowed */\n                continue;\n            }\n            else {\n                custom_key = FLB_TRUE;\n            }\n\n            if (v->type == MSGPACK_OBJECT_MAP) {\n                char *prefix = NULL;\n                int prefix_len = 0;\n\n                prefix_len = key_len + 1;\n                prefix = flb_calloc(1, prefix_len + 1);\n                if (prefix == NULL) {\n                    return NULL;\n                }\n\n                prefix[0] = '_';\n                strncpy(prefix + 1, key, key_len);\n                prefix[prefix_len] = '\\0';\n\n                tmp = flb_msgpack_gelf_flatten(s, v,\n                                               prefix, prefix_len, FLB_FALSE);\n                if (tmp == NULL) {\n                    flb_free(prefix);\n                    return NULL;\n                }\n                *s = tmp;\n                flb_free(prefix);\n\n            }\n            else if (v->type == MSGPACK_OBJECT_ARRAY) {\n                if (custom_key == FLB_TRUE) {\n                    tmp = flb_msgpack_gelf_key(s, FLB_FALSE, \"_\", 1, FLB_FALSE,\n                                             key, key_len);\n                }\n                else {\n                    tmp = flb_msgpack_gelf_key(s, FLB_FALSE, NULL, 0, FLB_FALSE,\n                                             key, key_len);\n                }\n                if (tmp == NULL) {\n                    return NULL;\n                }\n                *s = tmp;\n\n                tmp = flb_msgpack_gelf_flatten(s, v, NULL, 0, FLB_FALSE);\n                if (tmp == NULL) {\n                    return NULL;\n                }\n                *s = tmp;\n            }\n            else {\n                char temp[48] = {0};\n                if (v->type == MSGPACK_OBJECT_NIL) {\n                    val = \"null\";\n                    val_len = 4;\n                    continue;\n                }\n                else if (v->type == MSGPACK_OBJECT_BOOLEAN) {\n                    quote   = FLB_TRUE;\n                    val = v->via.boolean ? \"true\" : \"false\";\n                    val_len = v->via.boolean ? 4 : 5;\n                }\n                else if (v->type == MSGPACK_OBJECT_POSITIVE_INTEGER) {\n                    val = temp;\n                    val_len = snprintf(temp, sizeof(temp) - 1,\n                                       \"%\" PRIu64, v->via.u64);\n                    /*\n                     * Check if the value length is larger than our string.\n                     * this is needed to avoid stack-based overflows.\n                     */\n                    if (val_len > sizeof(temp)) {\n                        return NULL;\n                    }\n                }\n                else if (v->type == MSGPACK_OBJECT_NEGATIVE_INTEGER) {\n                    val = temp;\n                    val_len = snprintf(temp, sizeof(temp) - 1,\n                                       \"%\" PRId64, v->via.i64);\n                    /*\n                     * Check if the value length is larger than our string.\n                     * this is needed to avoid stack-based overflows.\n                     */\n                    if (val_len > sizeof(temp)) {\n                        return NULL;\n                    }\n                }\n                else if (v->type == MSGPACK_OBJECT_FLOAT) {\n                    val = temp;\n                    val_len = snprintf(temp, sizeof(temp) - 1,\n                                       \"%f\", v->via.f64);\n                    /*\n                     * Check if the value length is larger than our string.\n                     * this is needed to avoid stack-based overflows.\n                     */\n                    if (val_len > sizeof(temp)) {\n                        return NULL;\n                    }\n                }\n                else if (v->type == MSGPACK_OBJECT_STR) {\n                    /* String value */\n                    quote   = FLB_TRUE;\n                    val     = v->via.str.ptr;\n                    val_len = v->via.str.size;\n                }\n                else if (v->type == MSGPACK_OBJECT_BIN) {\n                    /* Bin value */\n                    quote   = FLB_TRUE;\n                    val     = v->via.bin.ptr;\n                    val_len = v->via.bin.size;\n                }\n                else if (v->type == MSGPACK_OBJECT_EXT) {\n                    quote   = FLB_TRUE;\n                    val     = o->via.ext.ptr;\n                    val_len = o->via.ext.size;\n                }\n\n                if (!val || !key) {\n                  continue;\n                }\n\n                if (custom_key == FLB_TRUE) {\n                    tmp = flb_msgpack_gelf_key(s, FLB_FALSE, \"_\", 1, FLB_FALSE,\n                                             key, key_len);\n                }\n                else {\n                    tmp = flb_msgpack_gelf_key(s, FLB_FALSE, NULL, 0, FLB_FALSE,\n                                             key, key_len);\n                }\n                if (tmp == NULL) {\n                    return NULL;\n                }\n                *s = tmp;\n\n                if (v->type == MSGPACK_OBJECT_EXT) {\n                    tmp = flb_msgpack_gelf_value_ext(s, quote, val, val_len);\n                }\n                else {\n                    tmp = flb_msgpack_gelf_value(s, quote, val, val_len);\n                }\n                if (tmp == NULL) {\n                    return NULL;\n                }\n                *s = tmp;\n            }\n        }\n    }\n\n    if (timestamp_key_found == FLB_FALSE && tm != NULL) {\n        tmp = flb_msgpack_gelf_key(s, FLB_FALSE, NULL, 0, FLB_FALSE,\n                                   \"timestamp\", 9);\n        if (tmp == NULL) {\n            return NULL;\n        }\n        *s = tmp;\n\n        tmp = flb_sds_printf(s, \"%\" PRIu32\".%lu\",\n                             tm->tm.tv_sec, tm->tm.tv_nsec / 1000000);\n        if (tmp == NULL) {\n            return NULL;\n        }\n        *s = tmp;\n    }\n\n    if (short_message_key_found == FLB_FALSE) {\n        flb_error(\"[flb_msgpack_to_gelf] missing short_message key\");\n        return NULL;\n    }\n\n    tmp = flb_sds_cat(*s, \"}\", 1);\n    if (tmp == NULL) {\n        return NULL;\n    }\n    *s = tmp;\n\n    return *s;\n}",
  "abstract_func_before": "flb_sds_t flb_msgpack_to_gelf(flb_sds_t *VAR_0, msgpack_object *VAR_1,\n                              struct flb_time *VAR_2,\n                              struct flb_gelf_fields *VAR_3)\n{\n    int VAR_4;\n    int VAR_5;\n    flb_sds_t VAR_6;\n\n    int VAR_7 = VAR_8;\n    int VAR_9 = VAR_8;\n    int VAR_10 = VAR_8;\n    int VAR_11 = VAR_8;\n    int VAR_12 = VAR_8;\n\n    char *VAR_13 = NULL;\n    char *VAR_14 = NULL;\n    char *VAR_15 = NULL;\n    char *VAR_16 = NULL;\n    char *VAR_17 = NULL;\n\n    int VAR_18 = 0;\n    int VAR_19 = false;\n    int VAR_20 = 0;\n    int VAR_21 = 0;\n    int VAR_22 = 0;\n\n    if (VAR_0 == NULL || VAR_1 == NULL) {\n        return NULL;\n    }\n\n    /* COMMENT_0 */\n    if (VAR_1->type != VAR_23) {\n        return NULL;\n    }\n\n    if (VAR_3 != NULL && VAR_3->host_key != NULL) {\n        VAR_13 = VAR_3->host_key;\n        VAR_18 = flb_sds_len(VAR_3->host_key);\n    }\n    else {\n        VAR_13 = \"host\";\n        VAR_18 = 4;\n    }\n\n    if (VAR_3 != NULL && VAR_3->timestamp_key != NULL) {\n        VAR_14 = VAR_3->timestamp_key;\n        VAR_19 = flb_sds_len(VAR_3->timestamp_key);\n    }\n    else {\n        VAR_14 = \"timestamp\";\n        VAR_19 = 9;\n    }\n\n    if (VAR_3 != NULL && VAR_3->level_key != NULL) {\n        VAR_15 = VAR_3->level_key;\n        VAR_20 = flb_sds_len(VAR_3->level_key);\n    }\n    else {\n        VAR_15 = \"level\";\n        VAR_20 = 5;\n    }\n\n    if (VAR_3 != NULL && VAR_3->short_message_key != NULL) {\n        VAR_16 = VAR_3->short_message_key;\n        VAR_21 = flb_sds_len(VAR_3->short_message_key);\n    }\n    else {\n        VAR_16 = \"short_message\";\n        VAR_21 = 13;\n    }\n\n    if (VAR_3 != NULL && VAR_3->full_message_key != NULL) {\n        VAR_17 = VAR_3->full_message_key;\n        VAR_22 = flb_sds_len(VAR_3->full_message_key);\n    }\n    else {\n        VAR_17 = \"full_message\";\n        VAR_22 = 12;\n    }\n\n    VAR_6 = flb_sds_cat(*VAR_0, \"{\\\"version\\\":\\\"1.1\\\"\", 16);\n    if (VAR_6 == NULL) {\n        return NULL;\n    }\n    *VAR_0 = VAR_6;\n\n    VAR_5 = VAR_1->via.map.size;\n    if (VAR_5 != 0) {\n        msgpack_object_kv *VAR_24 = VAR_1->via.map.ptr;\n\n        for (VAR_4 = 0; VAR_4 < VAR_5; VAR_4++) {\n            const char *VAR_25 = NULL;\n            int VAR_26;\n            const char *VAR_27 = NULL;\n            int VAR_28 = 0;\n            int VAR_29 = VAR_8;\n            int VAR_30 = VAR_8;\n\n            msgpack_object *VAR_31 = &VAR_24[VAR_4].key;\n            msgpack_object *VAR_32 = &VAR_24[VAR_4].val;\n            msgpack_object VAR_33; /* COMMENT_1 */\n\n            if (VAR_31->type != VAR_34 && VAR_31->type != VAR_35) {\n                continue;\n            }\n\n            if (VAR_31->type == VAR_35) {\n                VAR_25 = VAR_31->via.str.ptr;\n                VAR_26 = VAR_31->via.str.size;\n            }\n            else {\n                VAR_25 = VAR_31->via.bin.ptr;\n                VAR_26 = VAR_31->via.bin.size;\n            }\n\n            if ((VAR_26 == VAR_18) &&\n                !strncmp(VAR_25, VAR_13, VAR_18)) {\n                if (VAR_7 == VAR_36) {\n                    continue;\n                }\n                VAR_7 = VAR_36;\n                VAR_25 = \"host\";\n                VAR_26 = 4;\n            }\n            else if ((VAR_26 == VAR_21) &&\n                     !strncmp(VAR_25, VAR_16, VAR_21)) {\n                if (VAR_11 == VAR_36) {\n                    continue;\n                }\n                VAR_11 = VAR_36;\n                VAR_25 = \"short_message\";\n                VAR_26 = 13;\n            }\n            else if ((VAR_26 == VAR_19) &&\n                     !strncmp(VAR_25, VAR_14, VAR_19)) {\n                if (VAR_9 == VAR_36) {\n                    continue;\n                }\n                VAR_9 = VAR_36;\n                VAR_25 = \"timestamp\";\n                VAR_26 = 9;\n            }\n            else if ((VAR_26 == VAR_20) &&\n                     !strncmp(VAR_25, VAR_15, VAR_20 )) {\n                if (VAR_10 == VAR_36) {\n                    continue;\n                }\n                VAR_10 = VAR_36;\n                VAR_25 = \"level\";\n                VAR_26 = 5;\n                if (VAR_32->type == VAR_37) {\n                    if ( VAR_32->via.u64 > 7 ) {\n                        flb_warn(\"[flb_msgpack_to_gelf] level is %\" VAR_38 \", \"\n                                  \"but should be in 0..7 or a syslog keyword\", VAR_32->via.u64);\n                    }\n                }\n                else if (VAR_32->type == VAR_35) {\n                    VAR_27     = VAR_32->via.str.ptr;\n                    VAR_28 = VAR_32->via.str.size;\n                    if (VAR_28 == 1 && VAR_27[0] >= '0' && VAR_27[0] <= '7') {\n                        VAR_32 = &VAR_33;\n                        VAR_32->type = VAR_37;\n                        VAR_32->via.u64 = (uint64_t)(VAR_27[0] - '0');\n                    }\n                    else {\n                        int VAR_39;\n                        char* VAR_40[] = {\n                            \"emerg\", \"alert\", \"crit\", \"err\",\n                            \"warning\", \"notice\", \"info\", \"debug\",\n                            NULL\n                        };\n                        for (VAR_39 = 0; VAR_40[VAR_39] != NULL; ++VAR_39) {\n                            if (VAR_28 == strlen(VAR_40[VAR_39]) &&\n                                !strncasecmp(VAR_27, VAR_40[VAR_39], VAR_28)) {\n                                VAR_32 = &VAR_33;\n                                VAR_32->type = VAR_37;\n                                VAR_32->via.u64 = (uint64_t)VAR_39;\n                                break;\n                            }\n                        }\n                        if (VAR_40[VAR_39] == NULL) {\n                            flb_warn(\"[flb_msgpack_to_gelf] level is '%.*s', \"\n                                      \"but should be in 0..7 or a syslog keyword\", VAR_28, VAR_27);\n                        }\n                    }\n                }\n                else {\n                    flb_error(\"[flb_msgpack_to_gelf] level must be a non-negative integer or a string\");\n                    return NULL;\n                }\n            }\n            else if ((VAR_26 == VAR_22) &&\n                     !strncmp(VAR_25, VAR_17, VAR_22)) {\n                if (VAR_12 == VAR_36) {\n                    continue;\n                }\n                VAR_12 = VAR_36;\n                VAR_25 = \"full_message\";\n                VAR_26 = 12;\n            }\n            else if ((VAR_26 == 2)  && !strncmp(VAR_25, \"id\", 2)) {\n                /* COMMENT_2 */\n                continue;\n            }\n            else {\n                VAR_30 = VAR_36;\n            }\n\n            if (VAR_32->type == VAR_23) {\n                char *VAR_41 = NULL;\n                int VAR_42 = 0;\n\n                VAR_42 = VAR_26 + 1;\n                VAR_41 = flb_calloc(1, VAR_42 + 1);\n                if (VAR_41 == NULL) {\n                    return NULL;\n                }\n\n                VAR_41[0] = '_';\n                strncpy(VAR_41 + 1, VAR_25, VAR_26);\n                VAR_41[VAR_42] = '\\0';\n\n                VAR_6 = flb_msgpack_gelf_flatten(VAR_0, VAR_32,\n                                               VAR_41, VAR_42, VAR_8);\n                if (VAR_6 == NULL) {\n                    flb_free(VAR_41);\n                    return NULL;\n                }\n                *VAR_0 = VAR_6;\n                flb_free(VAR_41);\n\n            }\n            else if (VAR_32->type == VAR_43) {\n                if (VAR_30 == VAR_36) {\n                    VAR_6 = flb_msgpack_gelf_key(VAR_0, VAR_8, \"_\", 1, VAR_8,\n                                             VAR_25, VAR_26);\n                }\n                else {\n                    VAR_6 = flb_msgpack_gelf_key(VAR_0, VAR_8, NULL, 0, VAR_8,\n                                             VAR_25, VAR_26);\n                }\n                if (VAR_6 == NULL) {\n                    return NULL;\n                }\n                *VAR_0 = VAR_6;\n\n                VAR_6 = flb_msgpack_gelf_flatten(VAR_0, VAR_32, NULL, 0, VAR_8);\n                if (VAR_6 == NULL) {\n                    return NULL;\n                }\n                *VAR_0 = VAR_6;\n            }\n            else {\n                char VAR_44[48] = {0};\n                if (VAR_32->type == VAR_45) {\n                    VAR_27 = \"null\";\n                    VAR_28 = 4;\n                    continue;\n                }\n                else if (VAR_32->type == VAR_46) {\n                    VAR_29   = VAR_36;\n                    VAR_27 = VAR_32->via.boolean ? \"true\" : \"false\";\n                    VAR_28 = VAR_32->via.boolean ? 4 : 5;\n                }\n                else if (VAR_32->type == VAR_37) {\n                    VAR_27 = VAR_44;\n                    VAR_28 = snprintf(VAR_44, sizeof(VAR_44) - 1,\n                                       \"%\" VAR_38, VAR_32->via.u64);\n                    /* COMMENT_3 */\n                                                                           \n                                                                     \n                       \n                    if (VAR_28 > sizeof(VAR_44)) {\n                        return NULL;\n                    }\n                }\n                else if (VAR_32->type == VAR_47) {\n                    VAR_27 = VAR_44;\n                    VAR_28 = snprintf(VAR_44, sizeof(VAR_44) - 1,\n                                       \"%\" VAR_48, VAR_32->via.i64);\n                    /* COMMENT_7 */\n                                                                           \n                                                                     \n                       \n                    if (VAR_28 > sizeof(VAR_44)) {\n                        return NULL;\n                    }\n                }\n                else if (VAR_32->type == VAR_49) {\n                    VAR_27 = VAR_44;\n                    VAR_28 = snprintf(VAR_44, sizeof(VAR_44) - 1,\n                                       \"%f\", VAR_32->via.f64);\n                    /* COMMENT_11 */\n                                                                           \n                                                                     \n                       \n                    if (VAR_28 > sizeof(VAR_44)) {\n                        return NULL;\n                    }\n                }\n                else if (VAR_32->type == VAR_35) {\n                    /* COMMENT_15 */\n                    VAR_29   = VAR_36;\n                    VAR_27     = VAR_32->via.str.ptr;\n                    VAR_28 = VAR_32->via.str.size;\n                }\n                else if (VAR_32->type == VAR_34) {\n                    /* COMMENT_16 */\n                    VAR_29   = VAR_36;\n                    VAR_27     = VAR_32->via.bin.ptr;\n                    VAR_28 = VAR_32->via.bin.size;\n                }\n                else if (VAR_32->type == VAR_50) {\n                    VAR_29   = VAR_36;\n                    VAR_27     = VAR_1->via.ext.ptr;\n                    VAR_28 = VAR_1->via.ext.size;\n                }\n\n                if (!VAR_27 || !VAR_25) {\n                  continue;\n                }\n\n                if (VAR_30 == VAR_36) {\n                    VAR_6 = flb_msgpack_gelf_key(VAR_0, VAR_8, \"_\", 1, VAR_8,\n                                             VAR_25, VAR_26);\n                }\n                else {\n                    VAR_6 = flb_msgpack_gelf_key(VAR_0, VAR_8, NULL, 0, VAR_8,\n                                             VAR_25, VAR_26);\n                }\n                if (VAR_6 == NULL) {\n                    return NULL;\n                }\n                *VAR_0 = VAR_6;\n\n                if (VAR_32->type == VAR_50) {\n                    VAR_6 = flb_msgpack_gelf_value_ext(VAR_0, VAR_29, VAR_27, VAR_28);\n                }\n                else {\n                    VAR_6 = flb_msgpack_gelf_value(VAR_0, VAR_29, VAR_27, VAR_28);\n                }\n                if (VAR_6 == NULL) {\n                    return NULL;\n                }\n                *VAR_0 = VAR_6;\n            }\n        }\n    }\n\n    if (VAR_9 == VAR_8 && VAR_2 != NULL) {\n        VAR_6 = flb_msgpack_gelf_key(VAR_0, VAR_8, NULL, 0, VAR_8,\n                                   \"timestamp\", 9);\n        if (VAR_6 == NULL) {\n            return NULL;\n        }\n        *VAR_0 = VAR_6;\n\n        VAR_6 = flb_sds_printf(VAR_0, \"%\" VAR_51\".%lu\",\n                             VAR_2->tm.tv_sec, VAR_2->tm.tv_nsec / 1000000);\n        if (VAR_6 == NULL) {\n            return NULL;\n        }\n        *VAR_0 = VAR_6;\n    }\n\n    if (VAR_11 == VAR_8) {\n        flb_error(\"[flb_msgpack_to_gelf] missing short_message key\");\n        return NULL;\n    }\n\n    VAR_6 = flb_sds_cat(*VAR_0, \"}\", 1);\n    if (VAR_6 == NULL) {\n        return NULL;\n    }\n    *VAR_0 = VAR_6;\n\n    return *VAR_0;\n}",
  "func_graph_path_before": "fluent/fluent-bit/75f0e0e5f7267682674029820524d22460f498b0/flb_pack_gelf.c/vul/before/0.json",
  "func": "flb_sds_t flb_msgpack_to_gelf(flb_sds_t *s, msgpack_object *o,\n                              struct flb_time *tm,\n                              struct flb_gelf_fields *fields)\n{\n    int i;\n    int loop;\n    flb_sds_t tmp;\n\n    int host_key_found = FLB_FALSE;\n    int timestamp_key_found = FLB_FALSE;\n    int level_key_found = FLB_FALSE;\n    int short_message_key_found = FLB_FALSE;\n    int full_message_key_found = FLB_FALSE;\n\n    char *host_key = NULL;\n    char *timestamp_key = NULL;\n    char *level_key = NULL;\n    char *short_message_key = NULL;\n    char *full_message_key = NULL;\n\n    int host_key_len = 0;\n    int timestamp_key_len = false;\n    int level_key_len = 0;\n    int short_message_key_len = 0;\n    int full_message_key_len = 0;\n\n    if (s == NULL || o == NULL) {\n        return NULL;\n    }\n\n    /* Make sure the incoming object is a map */\n    if (o->type != MSGPACK_OBJECT_MAP) {\n        return NULL;\n    }\n\n    if (fields != NULL && fields->host_key != NULL) {\n        host_key = fields->host_key;\n        host_key_len = flb_sds_len(fields->host_key);\n    }\n    else {\n        host_key = \"host\";\n        host_key_len = 4;\n    }\n\n    if (fields != NULL && fields->timestamp_key != NULL) {\n        timestamp_key = fields->timestamp_key;\n        timestamp_key_len = flb_sds_len(fields->timestamp_key);\n    }\n    else {\n        timestamp_key = \"timestamp\";\n        timestamp_key_len = 9;\n    }\n\n    if (fields != NULL && fields->level_key != NULL) {\n        level_key = fields->level_key;\n        level_key_len = flb_sds_len(fields->level_key);\n    }\n    else {\n        level_key = \"level\";\n        level_key_len = 5;\n    }\n\n    if (fields != NULL && fields->short_message_key != NULL) {\n        short_message_key = fields->short_message_key;\n        short_message_key_len = flb_sds_len(fields->short_message_key);\n    }\n    else {\n        short_message_key = \"short_message\";\n        short_message_key_len = 13;\n    }\n\n    if (fields != NULL && fields->full_message_key != NULL) {\n        full_message_key = fields->full_message_key;\n        full_message_key_len = flb_sds_len(fields->full_message_key);\n    }\n    else {\n        full_message_key = \"full_message\";\n        full_message_key_len = 12;\n    }\n\n    tmp = flb_sds_cat(*s, \"{\\\"version\\\":\\\"1.1\\\"\", 16);\n    if (tmp == NULL) {\n        return NULL;\n    }\n    *s = tmp;\n\n    loop = o->via.map.size;\n    if (loop != 0) {\n        msgpack_object_kv *p = o->via.map.ptr;\n\n        for (i = 0; i < loop; i++) {\n            const char *key = NULL;\n            int key_len;\n            const char *val = NULL;\n            int val_len = 0;\n            int quote = FLB_FALSE;\n            int custom_key = FLB_FALSE;\n\n            msgpack_object *k = &p[i].key;\n            msgpack_object *v = &p[i].val;\n            msgpack_object vtmp; // used when converting level value from string to int\n\n            if (k->type != MSGPACK_OBJECT_BIN && k->type != MSGPACK_OBJECT_STR) {\n                continue;\n            }\n\n            if (k->type == MSGPACK_OBJECT_STR) {\n                key = k->via.str.ptr;\n                key_len = k->via.str.size;\n            }\n            else {\n                key = k->via.bin.ptr;\n                key_len = k->via.bin.size;\n            }\n\n            if ((key_len == host_key_len) &&\n                !strncmp(key, host_key, host_key_len)) {\n                if (host_key_found == FLB_TRUE) {\n                    continue;\n                }\n                host_key_found = FLB_TRUE;\n                key = \"host\";\n                key_len = 4;\n            }\n            else if ((key_len == short_message_key_len) &&\n                     !strncmp(key, short_message_key, short_message_key_len)) {\n                if (short_message_key_found == FLB_TRUE) {\n                    continue;\n                }\n                short_message_key_found = FLB_TRUE;\n                key = \"short_message\";\n                key_len = 13;\n            }\n            else if ((key_len == timestamp_key_len) &&\n                     !strncmp(key, timestamp_key, timestamp_key_len)) {\n                if (timestamp_key_found == FLB_TRUE) {\n                    continue;\n                }\n                timestamp_key_found = FLB_TRUE;\n                key = \"timestamp\";\n                key_len = 9;\n            }\n            else if ((key_len == level_key_len) &&\n                     !strncmp(key, level_key, level_key_len )) {\n                if (level_key_found == FLB_TRUE) {\n                    continue;\n                }\n                level_key_found = FLB_TRUE;\n                key = \"level\";\n                key_len = 5;\n                if (v->type == MSGPACK_OBJECT_POSITIVE_INTEGER) {\n                    if ( v->via.u64 > 7 ) {\n                        flb_warn(\"[flb_msgpack_to_gelf] level is %\" PRIu64 \", \"\n                                  \"but should be in 0..7 or a syslog keyword\", v->via.u64);\n                    }\n                }\n                else if (v->type == MSGPACK_OBJECT_STR) {\n                    val     = v->via.str.ptr;\n                    val_len = v->via.str.size;\n                    if (val_len == 1 && val[0] >= '0' && val[0] <= '7') {\n                        v = &vtmp;\n                        v->type = MSGPACK_OBJECT_POSITIVE_INTEGER;\n                        v->via.u64 = (uint64_t)(val[0] - '0');\n                    }\n                    else {\n                        int n;\n                        char* allowed_levels[] = {\n                            \"emerg\", \"alert\", \"crit\", \"err\",\n                            \"warning\", \"notice\", \"info\", \"debug\",\n                            NULL\n                        };\n                        for (n = 0; allowed_levels[n] != NULL; ++n) {\n                            if (val_len == strlen(allowed_levels[n]) &&\n                                !strncasecmp(val, allowed_levels[n], val_len)) {\n                                v = &vtmp;\n                                v->type = MSGPACK_OBJECT_POSITIVE_INTEGER;\n                                v->via.u64 = (uint64_t)n;\n                                break;\n                            }\n                        }\n                        if (allowed_levels[n] == NULL) {\n                            flb_warn(\"[flb_msgpack_to_gelf] level is '%.*s', \"\n                                      \"but should be in 0..7 or a syslog keyword\", val_len, val);\n                        }\n                    }\n                }\n                else {\n                    flb_error(\"[flb_msgpack_to_gelf] level must be a non-negative integer or a string\");\n                    return NULL;\n                }\n            }\n            else if ((key_len == full_message_key_len) &&\n                     !strncmp(key, full_message_key, full_message_key_len)) {\n                if (full_message_key_found == FLB_TRUE) {\n                    continue;\n                }\n                full_message_key_found = FLB_TRUE;\n                key = \"full_message\";\n                key_len = 12;\n            }\n            else if ((key_len == 2)  && !strncmp(key, \"id\", 2)) {\n                /* _id key not allowed */\n                continue;\n            }\n            else {\n                custom_key = FLB_TRUE;\n            }\n\n            if (v->type == MSGPACK_OBJECT_MAP) {\n                char *prefix = NULL;\n                int prefix_len = 0;\n\n                prefix_len = key_len + 1;\n                prefix = flb_calloc(1, prefix_len + 1);\n                if (prefix == NULL) {\n                    return NULL;\n                }\n\n                prefix[0] = '_';\n                strncpy(prefix + 1, key, key_len);\n                prefix[prefix_len] = '\\0';\n\n                tmp = flb_msgpack_gelf_flatten(s, v,\n                                               prefix, prefix_len, FLB_FALSE);\n                if (tmp == NULL) {\n                    flb_free(prefix);\n                    return NULL;\n                }\n                *s = tmp;\n                flb_free(prefix);\n\n            }\n            else if (v->type == MSGPACK_OBJECT_ARRAY) {\n                if (custom_key == FLB_TRUE) {\n                    tmp = flb_msgpack_gelf_key(s, FLB_FALSE, \"_\", 1, FLB_FALSE,\n                                             key, key_len);\n                }\n                else {\n                    tmp = flb_msgpack_gelf_key(s, FLB_FALSE, NULL, 0, FLB_FALSE,\n                                             key, key_len);\n                }\n                if (tmp == NULL) {\n                    return NULL;\n                }\n                *s = tmp;\n\n                tmp = flb_msgpack_gelf_flatten(s, v, NULL, 0, FLB_FALSE);\n                if (tmp == NULL) {\n                    return NULL;\n                }\n                *s = tmp;\n            }\n            else {\n                char temp[48] = {0};\n                if (v->type == MSGPACK_OBJECT_NIL) {\n                    val = \"null\";\n                    val_len = 4;\n                    continue;\n                }\n                else if (v->type == MSGPACK_OBJECT_BOOLEAN) {\n                    quote   = FLB_TRUE;\n                    val = v->via.boolean ? \"true\" : \"false\";\n                    val_len = v->via.boolean ? 4 : 5;\n                }\n                else if (v->type == MSGPACK_OBJECT_POSITIVE_INTEGER) {\n                    val = temp;\n                    val_len = snprintf(temp, sizeof(temp) - 1,\n                                       \"%\" PRIu64, v->via.u64);\n                    /*\n                     * Check if the value length is larger than our string.\n                     * this is needed to avoid stack-based overflows.\n                     */\n                    if (val_len > sizeof(temp)) {\n                        return NULL;\n                    }\n                }\n                else if (v->type == MSGPACK_OBJECT_NEGATIVE_INTEGER) {\n                    val = temp;\n                    val_len = snprintf(temp, sizeof(temp) - 1,\n                                       \"%\" PRId64, v->via.i64);\n                    /*\n                     * Check if the value length is larger than our string.\n                     * this is needed to avoid stack-based overflows.\n                     */\n                    if (val_len > sizeof(temp)) {\n                        return NULL;\n                    }\n                }\n                else if (v->type == MSGPACK_OBJECT_FLOAT) {\n                    val = temp;\n                    val_len = snprintf(temp, sizeof(temp) - 1,\n                                       \"%f\", v->via.f64);\n                    /*\n                     * Check if the value length is larger than our string.\n                     * this is needed to avoid stack-based overflows.\n                     */\n                    if (val_len > sizeof(temp)) {\n                        return NULL;\n                    }\n                }\n                else if (v->type == MSGPACK_OBJECT_STR) {\n                    /* String value */\n                    quote   = FLB_TRUE;\n                    val     = v->via.str.ptr;\n                    val_len = v->via.str.size;\n                }\n                else if (v->type == MSGPACK_OBJECT_BIN) {\n                    /* Bin value */\n                    quote   = FLB_TRUE;\n                    val     = v->via.bin.ptr;\n                    val_len = v->via.bin.size;\n                }\n                else if (v->type == MSGPACK_OBJECT_EXT) {\n                    quote   = FLB_TRUE;\n                    val     = v->via.ext.ptr;\n                    val_len = v->via.ext.size;\n                }\n\n                if (!val || !key) {\n                  continue;\n                }\n\n                if (custom_key == FLB_TRUE) {\n                    tmp = flb_msgpack_gelf_key(s, FLB_FALSE, \"_\", 1, FLB_FALSE,\n                                             key, key_len);\n                }\n                else {\n                    tmp = flb_msgpack_gelf_key(s, FLB_FALSE, NULL, 0, FLB_FALSE,\n                                             key, key_len);\n                }\n                if (tmp == NULL) {\n                    return NULL;\n                }\n                *s = tmp;\n\n                if (v->type == MSGPACK_OBJECT_EXT) {\n                    tmp = flb_msgpack_gelf_value_ext(s, quote, val, val_len);\n                }\n                else {\n                    tmp = flb_msgpack_gelf_value(s, quote, val, val_len);\n                }\n                if (tmp == NULL) {\n                    return NULL;\n                }\n                *s = tmp;\n            }\n        }\n    }\n\n    if (timestamp_key_found == FLB_FALSE && tm != NULL) {\n        tmp = flb_msgpack_gelf_key(s, FLB_FALSE, NULL, 0, FLB_FALSE,\n                                   \"timestamp\", 9);\n        if (tmp == NULL) {\n            return NULL;\n        }\n        *s = tmp;\n\n        tmp = flb_sds_printf(s, \"%\" PRIu32\".%lu\",\n                             tm->tm.tv_sec, tm->tm.tv_nsec / 1000000);\n        if (tmp == NULL) {\n            return NULL;\n        }\n        *s = tmp;\n    }\n\n    if (short_message_key_found == FLB_FALSE) {\n        flb_error(\"[flb_msgpack_to_gelf] missing short_message key\");\n        return NULL;\n    }\n\n    tmp = flb_sds_cat(*s, \"}\", 1);\n    if (tmp == NULL) {\n        return NULL;\n    }\n    *s = tmp;\n\n    return *s;\n}",
  "abstract_func": "flb_sds_t flb_msgpack_to_gelf(flb_sds_t *VAR_0, msgpack_object *VAR_1,\n                              struct flb_time *VAR_2,\n                              struct flb_gelf_fields *VAR_3)\n{\n    int VAR_4;\n    int VAR_5;\n    flb_sds_t VAR_6;\n\n    int VAR_7 = VAR_8;\n    int VAR_9 = VAR_8;\n    int VAR_10 = VAR_8;\n    int VAR_11 = VAR_8;\n    int VAR_12 = VAR_8;\n\n    char *VAR_13 = NULL;\n    char *VAR_14 = NULL;\n    char *VAR_15 = NULL;\n    char *VAR_16 = NULL;\n    char *VAR_17 = NULL;\n\n    int VAR_18 = 0;\n    int VAR_19 = false;\n    int VAR_20 = 0;\n    int VAR_21 = 0;\n    int VAR_22 = 0;\n\n    if (VAR_0 == NULL || VAR_1 == NULL) {\n        return NULL;\n    }\n\n    /* COMMENT_0 */\n    if (VAR_1->type != VAR_23) {\n        return NULL;\n    }\n\n    if (VAR_3 != NULL && VAR_3->host_key != NULL) {\n        VAR_13 = VAR_3->host_key;\n        VAR_18 = flb_sds_len(VAR_3->host_key);\n    }\n    else {\n        VAR_13 = \"host\";\n        VAR_18 = 4;\n    }\n\n    if (VAR_3 != NULL && VAR_3->timestamp_key != NULL) {\n        VAR_14 = VAR_3->timestamp_key;\n        VAR_19 = flb_sds_len(VAR_3->timestamp_key);\n    }\n    else {\n        VAR_14 = \"timestamp\";\n        VAR_19 = 9;\n    }\n\n    if (VAR_3 != NULL && VAR_3->level_key != NULL) {\n        VAR_15 = VAR_3->level_key;\n        VAR_20 = flb_sds_len(VAR_3->level_key);\n    }\n    else {\n        VAR_15 = \"level\";\n        VAR_20 = 5;\n    }\n\n    if (VAR_3 != NULL && VAR_3->short_message_key != NULL) {\n        VAR_16 = VAR_3->short_message_key;\n        VAR_21 = flb_sds_len(VAR_3->short_message_key);\n    }\n    else {\n        VAR_16 = \"short_message\";\n        VAR_21 = 13;\n    }\n\n    if (VAR_3 != NULL && VAR_3->full_message_key != NULL) {\n        VAR_17 = VAR_3->full_message_key;\n        VAR_22 = flb_sds_len(VAR_3->full_message_key);\n    }\n    else {\n        VAR_17 = \"full_message\";\n        VAR_22 = 12;\n    }\n\n    VAR_6 = flb_sds_cat(*VAR_0, \"{\\\"version\\\":\\\"1.1\\\"\", 16);\n    if (VAR_6 == NULL) {\n        return NULL;\n    }\n    *VAR_0 = VAR_6;\n\n    VAR_5 = VAR_1->via.map.size;\n    if (VAR_5 != 0) {\n        msgpack_object_kv *VAR_24 = VAR_1->via.map.ptr;\n\n        for (VAR_4 = 0; VAR_4 < VAR_5; VAR_4++) {\n            const char *VAR_25 = NULL;\n            int VAR_26;\n            const char *VAR_27 = NULL;\n            int VAR_28 = 0;\n            int VAR_29 = VAR_8;\n            int VAR_30 = VAR_8;\n\n            msgpack_object *VAR_31 = &VAR_24[VAR_4].key;\n            msgpack_object *VAR_32 = &VAR_24[VAR_4].val;\n            msgpack_object VAR_33; /* COMMENT_1 */\n\n            if (VAR_31->type != VAR_34 && VAR_31->type != VAR_35) {\n                continue;\n            }\n\n            if (VAR_31->type == VAR_35) {\n                VAR_25 = VAR_31->via.str.ptr;\n                VAR_26 = VAR_31->via.str.size;\n            }\n            else {\n                VAR_25 = VAR_31->via.bin.ptr;\n                VAR_26 = VAR_31->via.bin.size;\n            }\n\n            if ((VAR_26 == VAR_18) &&\n                !strncmp(VAR_25, VAR_13, VAR_18)) {\n                if (VAR_7 == VAR_36) {\n                    continue;\n                }\n                VAR_7 = VAR_36;\n                VAR_25 = \"host\";\n                VAR_26 = 4;\n            }\n            else if ((VAR_26 == VAR_21) &&\n                     !strncmp(VAR_25, VAR_16, VAR_21)) {\n                if (VAR_11 == VAR_36) {\n                    continue;\n                }\n                VAR_11 = VAR_36;\n                VAR_25 = \"short_message\";\n                VAR_26 = 13;\n            }\n            else if ((VAR_26 == VAR_19) &&\n                     !strncmp(VAR_25, VAR_14, VAR_19)) {\n                if (VAR_9 == VAR_36) {\n                    continue;\n                }\n                VAR_9 = VAR_36;\n                VAR_25 = \"timestamp\";\n                VAR_26 = 9;\n            }\n            else if ((VAR_26 == VAR_20) &&\n                     !strncmp(VAR_25, VAR_15, VAR_20 )) {\n                if (VAR_10 == VAR_36) {\n                    continue;\n                }\n                VAR_10 = VAR_36;\n                VAR_25 = \"level\";\n                VAR_26 = 5;\n                if (VAR_32->type == VAR_37) {\n                    if ( VAR_32->via.u64 > 7 ) {\n                        flb_warn(\"[flb_msgpack_to_gelf] level is %\" VAR_38 \", \"\n                                  \"but should be in 0..7 or a syslog keyword\", VAR_32->via.u64);\n                    }\n                }\n                else if (VAR_32->type == VAR_35) {\n                    VAR_27     = VAR_32->via.str.ptr;\n                    VAR_28 = VAR_32->via.str.size;\n                    if (VAR_28 == 1 && VAR_27[0] >= '0' && VAR_27[0] <= '7') {\n                        VAR_32 = &VAR_33;\n                        VAR_32->type = VAR_37;\n                        VAR_32->via.u64 = (uint64_t)(VAR_27[0] - '0');\n                    }\n                    else {\n                        int VAR_39;\n                        char* VAR_40[] = {\n                            \"emerg\", \"alert\", \"crit\", \"err\",\n                            \"warning\", \"notice\", \"info\", \"debug\",\n                            NULL\n                        };\n                        for (VAR_39 = 0; VAR_40[VAR_39] != NULL; ++VAR_39) {\n                            if (VAR_28 == strlen(VAR_40[VAR_39]) &&\n                                !strncasecmp(VAR_27, VAR_40[VAR_39], VAR_28)) {\n                                VAR_32 = &VAR_33;\n                                VAR_32->type = VAR_37;\n                                VAR_32->via.u64 = (uint64_t)VAR_39;\n                                break;\n                            }\n                        }\n                        if (VAR_40[VAR_39] == NULL) {\n                            flb_warn(\"[flb_msgpack_to_gelf] level is '%.*s', \"\n                                      \"but should be in 0..7 or a syslog keyword\", VAR_28, VAR_27);\n                        }\n                    }\n                }\n                else {\n                    flb_error(\"[flb_msgpack_to_gelf] level must be a non-negative integer or a string\");\n                    return NULL;\n                }\n            }\n            else if ((VAR_26 == VAR_22) &&\n                     !strncmp(VAR_25, VAR_17, VAR_22)) {\n                if (VAR_12 == VAR_36) {\n                    continue;\n                }\n                VAR_12 = VAR_36;\n                VAR_25 = \"full_message\";\n                VAR_26 = 12;\n            }\n            else if ((VAR_26 == 2)  && !strncmp(VAR_25, \"id\", 2)) {\n                /* COMMENT_2 */\n                continue;\n            }\n            else {\n                VAR_30 = VAR_36;\n            }\n\n            if (VAR_32->type == VAR_23) {\n                char *VAR_41 = NULL;\n                int VAR_42 = 0;\n\n                VAR_42 = VAR_26 + 1;\n                VAR_41 = flb_calloc(1, VAR_42 + 1);\n                if (VAR_41 == NULL) {\n                    return NULL;\n                }\n\n                VAR_41[0] = '_';\n                strncpy(VAR_41 + 1, VAR_25, VAR_26);\n                VAR_41[VAR_42] = '\\0';\n\n                VAR_6 = flb_msgpack_gelf_flatten(VAR_0, VAR_32,\n                                               VAR_41, VAR_42, VAR_8);\n                if (VAR_6 == NULL) {\n                    flb_free(VAR_41);\n                    return NULL;\n                }\n                *VAR_0 = VAR_6;\n                flb_free(VAR_41);\n\n            }\n            else if (VAR_32->type == VAR_43) {\n                if (VAR_30 == VAR_36) {\n                    VAR_6 = flb_msgpack_gelf_key(VAR_0, VAR_8, \"_\", 1, VAR_8,\n                                             VAR_25, VAR_26);\n                }\n                else {\n                    VAR_6 = flb_msgpack_gelf_key(VAR_0, VAR_8, NULL, 0, VAR_8,\n                                             VAR_25, VAR_26);\n                }\n                if (VAR_6 == NULL) {\n                    return NULL;\n                }\n                *VAR_0 = VAR_6;\n\n                VAR_6 = flb_msgpack_gelf_flatten(VAR_0, VAR_32, NULL, 0, VAR_8);\n                if (VAR_6 == NULL) {\n                    return NULL;\n                }\n                *VAR_0 = VAR_6;\n            }\n            else {\n                char VAR_44[48] = {0};\n                if (VAR_32->type == VAR_45) {\n                    VAR_27 = \"null\";\n                    VAR_28 = 4;\n                    continue;\n                }\n                else if (VAR_32->type == VAR_46) {\n                    VAR_29   = VAR_36;\n                    VAR_27 = VAR_32->via.boolean ? \"true\" : \"false\";\n                    VAR_28 = VAR_32->via.boolean ? 4 : 5;\n                }\n                else if (VAR_32->type == VAR_37) {\n                    VAR_27 = VAR_44;\n                    VAR_28 = snprintf(VAR_44, sizeof(VAR_44) - 1,\n                                       \"%\" VAR_38, VAR_32->via.u64);\n                    /* COMMENT_3 */\n                                                                           \n                                                                     \n                       \n                    if (VAR_28 > sizeof(VAR_44)) {\n                        return NULL;\n                    }\n                }\n                else if (VAR_32->type == VAR_47) {\n                    VAR_27 = VAR_44;\n                    VAR_28 = snprintf(VAR_44, sizeof(VAR_44) - 1,\n                                       \"%\" VAR_48, VAR_32->via.i64);\n                    /* COMMENT_7 */\n                                                                           \n                                                                     \n                       \n                    if (VAR_28 > sizeof(VAR_44)) {\n                        return NULL;\n                    }\n                }\n                else if (VAR_32->type == VAR_49) {\n                    VAR_27 = VAR_44;\n                    VAR_28 = snprintf(VAR_44, sizeof(VAR_44) - 1,\n                                       \"%f\", VAR_32->via.f64);\n                    /* COMMENT_11 */\n                                                                           \n                                                                     \n                       \n                    if (VAR_28 > sizeof(VAR_44)) {\n                        return NULL;\n                    }\n                }\n                else if (VAR_32->type == VAR_35) {\n                    /* COMMENT_15 */\n                    VAR_29   = VAR_36;\n                    VAR_27     = VAR_32->via.str.ptr;\n                    VAR_28 = VAR_32->via.str.size;\n                }\n                else if (VAR_32->type == VAR_34) {\n                    /* COMMENT_16 */\n                    VAR_29   = VAR_36;\n                    VAR_27     = VAR_32->via.bin.ptr;\n                    VAR_28 = VAR_32->via.bin.size;\n                }\n                else if (VAR_32->type == VAR_50) {\n                    VAR_29   = VAR_36;\n                    VAR_27     = VAR_32->via.ext.ptr;\n                    VAR_28 = VAR_32->via.ext.size;\n                }\n\n                if (!VAR_27 || !VAR_25) {\n                  continue;\n                }\n\n                if (VAR_30 == VAR_36) {\n                    VAR_6 = flb_msgpack_gelf_key(VAR_0, VAR_8, \"_\", 1, VAR_8,\n                                             VAR_25, VAR_26);\n                }\n                else {\n                    VAR_6 = flb_msgpack_gelf_key(VAR_0, VAR_8, NULL, 0, VAR_8,\n                                             VAR_25, VAR_26);\n                }\n                if (VAR_6 == NULL) {\n                    return NULL;\n                }\n                *VAR_0 = VAR_6;\n\n                if (VAR_32->type == VAR_50) {\n                    VAR_6 = flb_msgpack_gelf_value_ext(VAR_0, VAR_29, VAR_27, VAR_28);\n                }\n                else {\n                    VAR_6 = flb_msgpack_gelf_value(VAR_0, VAR_29, VAR_27, VAR_28);\n                }\n                if (VAR_6 == NULL) {\n                    return NULL;\n                }\n                *VAR_0 = VAR_6;\n            }\n        }\n    }\n\n    if (VAR_9 == VAR_8 && VAR_2 != NULL) {\n        VAR_6 = flb_msgpack_gelf_key(VAR_0, VAR_8, NULL, 0, VAR_8,\n                                   \"timestamp\", 9);\n        if (VAR_6 == NULL) {\n            return NULL;\n        }\n        *VAR_0 = VAR_6;\n\n        VAR_6 = flb_sds_printf(VAR_0, \"%\" VAR_51\".%lu\",\n                             VAR_2->tm.tv_sec, VAR_2->tm.tv_nsec / 1000000);\n        if (VAR_6 == NULL) {\n            return NULL;\n        }\n        *VAR_0 = VAR_6;\n    }\n\n    if (VAR_11 == VAR_8) {\n        flb_error(\"[flb_msgpack_to_gelf] missing short_message key\");\n        return NULL;\n    }\n\n    VAR_6 = flb_sds_cat(*VAR_0, \"}\", 1);\n    if (VAR_6 == NULL) {\n        return NULL;\n    }\n    *VAR_0 = VAR_6;\n\n    return *VAR_0;\n}",
  "func_graph_path": "fluent/fluent-bit/75f0e0e5f7267682674029820524d22460f498b0/flb_pack_gelf.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -312,8 +312,8 @@\n                 }\n                 else if (v->type == MSGPACK_OBJECT_EXT) {\n                     quote   = FLB_TRUE;\n-                    val     = o->via.ext.ptr;\n-                    val_len = o->via.ext.size;\n+                    val     = v->via.ext.ptr;\n+                    val_len = v->via.ext.size;\n                 }\n \n                 if (!val || !key) {",
  "diff_line_info": {
    "deleted_lines": [
      "                    val     = o->via.ext.ptr;",
      "                    val_len = o->via.ext.size;"
    ],
    "added_lines": [
      "                    val     = v->via.ext.ptr;",
      "                    val_len = v->via.ext.size;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/fluent/fluent-bit/pull/3100",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/fluent/fluent-bit/pull/3100: 403 Client Error: Forbidden for url: https://api.github.com/repos/fluent/fluent-bit/pulls/3100",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95"
}