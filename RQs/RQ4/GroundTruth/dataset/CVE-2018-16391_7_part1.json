{
  "cve_id": "CVE-2018-16391",
  "cwe_ids": [
    "CWE-415",
    "CWE-119"
  ],
  "cvss_vector": "AV:L/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "OpenSC",
  "commit_msg": "fixed out of bounds writes\n\nThanks to Eric Sesterhenn from X41 D-SEC GmbH\nfor reporting the problems.",
  "commit_hash": "360e95d45ac4123255a4c796db96337f332160ad",
  "git_url": "https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad",
  "file_path": "src/libopensc/pkcs15-esteid.c",
  "func_name": "sc_pkcs15emu_esteid_init",
  "func_before": "static int\nsc_pkcs15emu_esteid_init (sc_pkcs15_card_t * p15card)\n{\n\tsc_card_t *card = p15card->card;\n\tunsigned char buff[128];\n\tint r, i;\n\tsize_t field_length = 0, modulus_length = 0;\n\tsc_path_t tmppath;\n\n\tset_string (&p15card->tokeninfo->label, \"ID-kaart\");\n\tset_string (&p15card->tokeninfo->manufacturer_id, \"AS Sertifitseerimiskeskus\");\n\n\t/* Select application directory */\n\tsc_format_path (\"3f00eeee5044\", &tmppath);\n\tr = sc_select_file (card, &tmppath, NULL);\n\tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"select esteid PD failed\");\n\n\t/* read the serial (document number) */\n\tr = sc_read_record (card, SC_ESTEID_PD_DOCUMENT_NR, buff, sizeof(buff), SC_RECORD_BY_REC_NR);\n\tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"read document number failed\");\n\tbuff[r] = '\\0';\n\tset_string (&p15card->tokeninfo->serial_number, (const char *) buff);\n\n\tp15card->tokeninfo->flags = SC_PKCS15_TOKEN_PRN_GENERATION\n\t\t\t\t  | SC_PKCS15_TOKEN_EID_COMPLIANT\n\t\t\t\t  | SC_PKCS15_TOKEN_READONLY;\n\n\t/* add certificates */\n\tfor (i = 0; i < 2; i++) {\n\t\tstatic const char *esteid_cert_names[2] = {\n\t\t\t\"Isikutuvastus\",\n\t\t\t\"Allkirjastamine\"};\n\t\tstatic char const *esteid_cert_paths[2] = {\n\t\t\t\"3f00eeeeaace\",\n\t\t\t\"3f00eeeeddce\"};\n\t\tstatic int esteid_cert_ids[2] = {1, 2};\n\n\t\tstruct sc_pkcs15_cert_info cert_info;\n\t\tstruct sc_pkcs15_object cert_obj;\n\n\t\tmemset(&cert_info, 0, sizeof(cert_info));\n\t\tmemset(&cert_obj, 0, sizeof(cert_obj));\n\n\t\tcert_info.id.value[0] = esteid_cert_ids[i];\n\t\tcert_info.id.len = 1;\n\t\tsc_format_path(esteid_cert_paths[i], &cert_info.path);\n\t\tstrlcpy(cert_obj.label, esteid_cert_names[i], sizeof(cert_obj.label));\n\t\tr = sc_pkcs15emu_add_x509_cert(p15card, &cert_obj, &cert_info);\n\t\tif (r < 0)\n\t\t\treturn SC_ERROR_INTERNAL;\n\t\tif (i == 0) {\n\t\t\tsc_pkcs15_cert_t *cert = NULL;\n\t\t\tr = sc_pkcs15_read_certificate(p15card, &cert_info, &cert);\n\t\t\tif (r < 0)\n\t\t\t\treturn SC_ERROR_INTERNAL;\n\t\t\tif (cert->key->algorithm == SC_ALGORITHM_EC)\n\t\t\t\tfield_length = cert->key->u.ec.params.field_length;\n\t\t\telse\n\t\t\t\tmodulus_length = cert->key->u.rsa.modulus.len * 8;\n\t\t\tif (r == SC_SUCCESS) {\n\t\t\t\tstatic const struct sc_object_id cn_oid = {{ 2, 5, 4, 3, -1 }};\n\t\t\t\tu8 *cn_name = NULL;\n\t\t\t\tsize_t cn_len = 0;\n\t\t\t\tsc_pkcs15_get_name_from_dn(card->ctx, cert->subject,\n\t\t\t\t\tcert->subject_len, &cn_oid, &cn_name, &cn_len);\n\t\t\t\tif (cn_len > 0) {\n\t\t\t\t\tchar *token_name = malloc(cn_len+1);\n\t\t\t\t\tif (token_name) {\n\t\t\t\t\t\tmemcpy(token_name, cn_name, cn_len);\n\t\t\t\t\t\ttoken_name[cn_len] = '\\0';\n\t\t\t\t\t\tset_string(&p15card->tokeninfo->label, (const char*)token_name);\n\t\t\t\t\t\tfree(token_name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree(cn_name);\n\t\t\t\tsc_pkcs15_free_certificate(cert);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* the file with key pin info (tries left) */\n\tsc_format_path (\"3f000016\", &tmppath);\n\tr = sc_select_file (card, &tmppath, NULL);\n\tif (r < 0)\n\t\treturn SC_ERROR_INTERNAL;\n\n\t/* add pins */\n\tfor (i = 0; i < 3; i++) {\n\t\tunsigned char tries_left;\n\t\tstatic const char *esteid_pin_names[3] = {\n\t\t\t\"PIN1\",\n\t\t\t\"PIN2\",\n\t\t\t\"PUK\" };\n\t\t\t\n\t\tstatic const int esteid_pin_min[3] = {4, 5, 8};\n\t\tstatic const int esteid_pin_ref[3] = {1, 2, 0};\n\t\tstatic const int esteid_pin_authid[3] = {1, 2, 3};\n\t\tstatic const int esteid_pin_flags[3] = {0, 0, SC_PKCS15_PIN_FLAG_UNBLOCKING_PIN};\n\t\t\n\t\tstruct sc_pkcs15_auth_info pin_info;\n\t\tstruct sc_pkcs15_object pin_obj;\n\n\t\tmemset(&pin_info, 0, sizeof(pin_info));\n\t\tmemset(&pin_obj, 0, sizeof(pin_obj));\n\n\t\t/* read the number of tries left for the PIN */\n\t\tr = sc_read_record (card, i + 1, buff, sizeof(buff), SC_RECORD_BY_REC_NR);\n\t\tif (r < 0)\n\t\t\treturn SC_ERROR_INTERNAL;\n\t\ttries_left = buff[5];\n\n\t\tpin_info.auth_id.len = 1;\n\t\tpin_info.auth_id.value[0] = esteid_pin_authid[i];\n\t\tpin_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;\n\t\tpin_info.attrs.pin.reference = esteid_pin_ref[i];\n\t\tpin_info.attrs.pin.flags = esteid_pin_flags[i];\n\t\tpin_info.attrs.pin.type = SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;\n\t\tpin_info.attrs.pin.min_length = esteid_pin_min[i];\n\t\tpin_info.attrs.pin.stored_length = 12;\n\t\tpin_info.attrs.pin.max_length = 12;\n\t\tpin_info.attrs.pin.pad_char = '\\0';\n\t\tpin_info.tries_left = (int)tries_left;\n\t\tpin_info.max_tries = 3;\n\n\t\tstrlcpy(pin_obj.label, esteid_pin_names[i], sizeof(pin_obj.label));\n\t\tpin_obj.flags = esteid_pin_flags[i];\n\n\t\t/* Link normal PINs with PUK */\n\t\tif (i < 2) {\n\t\t\tpin_obj.auth_id.len = 1;\n\t\t\tpin_obj.auth_id.value[0] = 3;\n\t\t}\n\n\t\tr = sc_pkcs15emu_add_pin_obj(p15card, &pin_obj, &pin_info);\n\t\tif (r < 0)\n\t\t\treturn SC_ERROR_INTERNAL;\n\t}\n\n\t/* add private keys */\n\tfor (i = 0; i < 2; i++) {\n\t\tstatic int prkey_pin[2] = {1, 2};\n\n\t\tstatic const char *prkey_name[2] = {\n\t\t\t\"Isikutuvastus\",\n\t\t\t\"Allkirjastamine\"};\n\n\t\tstruct sc_pkcs15_prkey_info prkey_info;\n\t\tstruct sc_pkcs15_object prkey_obj;\n\n\t\tmemset(&prkey_info, 0, sizeof(prkey_info));\n\t\tmemset(&prkey_obj, 0, sizeof(prkey_obj));\n\n\t\tprkey_info.id.len = 1;\n\t\tprkey_info.id.value[0] = prkey_pin[i];\n\t\tprkey_info.native = 1;\n\t\tprkey_info.key_reference = i + 1;\n\t\tprkey_info.field_length = field_length;\n\t\tprkey_info.modulus_length = modulus_length;\n\t\tif (i == 1)\n\t\t\tprkey_info.usage = SC_PKCS15_PRKEY_USAGE_NONREPUDIATION;\n\t\telse if(field_length > 0) // ECC has sign and derive usage\n\t\t\tprkey_info.usage = SC_PKCS15_PRKEY_USAGE_SIGN | SC_PKCS15_PRKEY_USAGE_DERIVE;\n\t\telse\n\t\t\tprkey_info.usage = SC_PKCS15_PRKEY_USAGE_SIGN | SC_PKCS15_PRKEY_USAGE_ENCRYPT | SC_PKCS15_PRKEY_USAGE_DECRYPT;\n\n\t\tstrlcpy(prkey_obj.label, prkey_name[i], sizeof(prkey_obj.label));\n\t\tprkey_obj.auth_id.len = 1;\n\t\tprkey_obj.auth_id.value[0] = prkey_pin[i];\n\t\tprkey_obj.user_consent = 0;\n\t\tprkey_obj.flags = SC_PKCS15_CO_FLAG_PRIVATE;\n\n\t\tif(field_length > 0)\n\t\t\tr = sc_pkcs15emu_add_ec_prkey(p15card, &prkey_obj, &prkey_info);\n\t\telse\n\t\t\tr = sc_pkcs15emu_add_rsa_prkey(p15card, &prkey_obj, &prkey_info);\n\t\tif (r < 0)\n\t\t\treturn SC_ERROR_INTERNAL;\n\t}\n\n\treturn SC_SUCCESS;\n}",
  "abstract_func_before": "static int\nsc_pkcs15emu_esteid_init (sc_pkcs15_card_t * VAR_0)\n{\n\tsc_card_t *VAR_1 = VAR_0->card;\n\tunsigned char VAR_2[128];\n\tint VAR_3, VAR_4;\n\tsize_t VAR_5 = 0, VAR_6 = 0;\n\tsc_path_t VAR_7;\n\n\tset_string (&VAR_0->tokeninfo->label, \"ID-kaart\");\n\tset_string (&VAR_0->tokeninfo->manufacturer_id, \"AS Sertifitseerimiskeskus\");\n\n\t/* COMMENT_0 */\n\tsc_format_path (\"3f00eeee5044\", &VAR_7);\n\tVAR_3 = sc_select_file (VAR_1, &VAR_7, NULL);\n\tSC_TEST_RET(VAR_1->ctx, VAR_8, VAR_3, \"select esteid PD failed\");\n\n\t/* COMMENT_1 */\n\tVAR_3 = sc_read_record (VAR_1, VAR_9, VAR_2, sizeof(VAR_2), VAR_10);\n\tSC_TEST_RET(VAR_1->ctx, VAR_8, VAR_3, \"read document number failed\");\n\tVAR_2[VAR_3] = '\\0';\n\tset_string (&VAR_0->tokeninfo->serial_number, (const char *) VAR_2);\n\n\tVAR_0->tokeninfo->flags = VAR_11\n\t\t\t\t  | VAR_12\n\t\t\t\t  | VAR_13;\n\n\t/* COMMENT_2 */\n\tfor (VAR_4 = 0; VAR_4 < 2; VAR_4++) {\n\t\tstatic const char *VAR_14[2] = {\n\t\t\t\"Isikutuvastus\",\n\t\t\t\"Allkirjastamine\"};\n\t\tstatic char const *VAR_15[2] = {\n\t\t\t\"3f00eeeeaace\",\n\t\t\t\"3f00eeeeddce\"};\n\t\tstatic int VAR_16[2] = {1, 2};\n\n\t\tstruct sc_pkcs15_cert_info VAR_17;\n\t\tstruct sc_pkcs15_object VAR_18;\n\n\t\tmemset(&VAR_17, 0, sizeof(VAR_17));\n\t\tmemset(&VAR_18, 0, sizeof(VAR_18));\n\n\t\tVAR_17.id.value[0] = VAR_16[VAR_4];\n\t\tVAR_17.id.len = 1;\n\t\tsc_format_path(VAR_15[VAR_4], &VAR_17.path);\n\t\tstrlcpy(VAR_18.label, VAR_14[VAR_4], sizeof(VAR_18.label));\n\t\tVAR_3 = sc_pkcs15emu_add_x509_cert(VAR_0, &VAR_18, &VAR_17);\n\t\tif (VAR_3 < 0)\n\t\t\treturn VAR_19;\n\t\tif (VAR_4 == 0) {\n\t\t\tsc_pkcs15_cert_t *VAR_20 = NULL;\n\t\t\tVAR_3 = sc_pkcs15_read_certificate(VAR_0, &VAR_17, &VAR_20);\n\t\t\tif (VAR_3 < 0)\n\t\t\t\treturn VAR_19;\n\t\t\tif (VAR_20->key->algorithm == VAR_21)\n\t\t\t\tVAR_5 = VAR_20->key->u.ec.params.field_length;\n\t\t\telse\n\t\t\t\tVAR_6 = VAR_20->key->u.rsa.modulus.len * 8;\n\t\t\tif (VAR_3 == VAR_22) {\n\t\t\t\tstatic const struct sc_object_id VAR_23 = {{ 2, 5, 4, 3, -1 }};\n\t\t\t\tu8 *VAR_24 = NULL;\n\t\t\t\tsize_t VAR_25 = 0;\n\t\t\t\tsc_pkcs15_get_name_from_dn(VAR_1->ctx, VAR_20->subject,\n\t\t\t\t\tVAR_20->subject_len, &VAR_23, &VAR_24, &VAR_25);\n\t\t\t\tif (VAR_25 > 0) {\n\t\t\t\t\tchar *VAR_26 = malloc(VAR_25+1);\n\t\t\t\t\tif (VAR_26) {\n\t\t\t\t\t\tmemcpy(VAR_26, VAR_24, VAR_25);\n\t\t\t\t\t\tVAR_26[VAR_25] = '\\0';\n\t\t\t\t\t\tset_string(&VAR_0->tokeninfo->label, (const char*)VAR_26);\n\t\t\t\t\t\tfree(VAR_26);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree(VAR_24);\n\t\t\t\tsc_pkcs15_free_certificate(VAR_20);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* COMMENT_3 */\n\tsc_format_path (\"3f000016\", &VAR_7);\n\tVAR_3 = sc_select_file (VAR_1, &VAR_7, NULL);\n\tif (VAR_3 < 0)\n\t\treturn VAR_19;\n\n\t/* COMMENT_4 */\n\tfor (VAR_4 = 0; VAR_4 < 3; VAR_4++) {\n\t\tunsigned char VAR_27;\n\t\tstatic const char *VAR_28[3] = {\n\t\t\t\"PIN1\",\n\t\t\t\"PIN2\",\n\t\t\t\"PUK\" };\n\t\t\t\n\t\tstatic const int VAR_29[3] = {4, 5, 8};\n\t\tstatic const int VAR_30[3] = {1, 2, 0};\n\t\tstatic const int VAR_31[3] = {1, 2, 3};\n\t\tstatic const int VAR_32[3] = {0, 0, VAR_33};\n\t\t\n\t\tstruct sc_pkcs15_auth_info VAR_34;\n\t\tstruct sc_pkcs15_object VAR_35;\n\n\t\tmemset(&VAR_34, 0, sizeof(VAR_34));\n\t\tmemset(&VAR_35, 0, sizeof(VAR_35));\n\n\t\t/* COMMENT_5 */\n\t\tVAR_3 = sc_read_record (VAR_1, VAR_4 + 1, VAR_2, sizeof(VAR_2), VAR_10);\n\t\tif (VAR_3 < 0)\n\t\t\treturn VAR_19;\n\t\tVAR_27 = VAR_2[5];\n\n\t\tVAR_34.auth_id.len = 1;\n\t\tVAR_34.auth_id.value[0] = VAR_31[VAR_4];\n\t\tVAR_34.auth_type = VAR_36;\n\t\tVAR_34.attrs.pin.reference = VAR_30[VAR_4];\n\t\tVAR_34.attrs.pin.flags = VAR_32[VAR_4];\n\t\tVAR_34.attrs.pin.type = VAR_37;\n\t\tVAR_34.attrs.pin.min_length = VAR_29[VAR_4];\n\t\tVAR_34.attrs.pin.stored_length = 12;\n\t\tVAR_34.attrs.pin.max_length = 12;\n\t\tVAR_34.attrs.pin.pad_char = '\\0';\n\t\tVAR_34.tries_left = (int)VAR_27;\n\t\tVAR_34.max_tries = 3;\n\n\t\tstrlcpy(VAR_35.label, VAR_28[VAR_4], sizeof(VAR_35.label));\n\t\tVAR_35.flags = VAR_32[VAR_4];\n\n\t\t/* COMMENT_6 */\n\t\tif (VAR_4 < 2) {\n\t\t\tVAR_35.auth_id.len = 1;\n\t\t\tVAR_35.auth_id.value[0] = 3;\n\t\t}\n\n\t\tVAR_3 = sc_pkcs15emu_add_pin_obj(VAR_0, &VAR_35, &VAR_34);\n\t\tif (VAR_3 < 0)\n\t\t\treturn VAR_19;\n\t}\n\n\t/* COMMENT_7 */\n\tfor (VAR_4 = 0; VAR_4 < 2; VAR_4++) {\n\t\tstatic int VAR_38[2] = {1, 2};\n\n\t\tstatic const char *VAR_39[2] = {\n\t\t\t\"Isikutuvastus\",\n\t\t\t\"Allkirjastamine\"};\n\n\t\tstruct sc_pkcs15_prkey_info VAR_40;\n\t\tstruct sc_pkcs15_object VAR_41;\n\n\t\tmemset(&VAR_40, 0, sizeof(VAR_40));\n\t\tmemset(&VAR_41, 0, sizeof(VAR_41));\n\n\t\tVAR_40.id.len = 1;\n\t\tVAR_40.id.value[0] = VAR_38[VAR_4];\n\t\tVAR_40.native = 1;\n\t\tVAR_40.key_reference = VAR_4 + 1;\n\t\tVAR_40.field_length = VAR_5;\n\t\tVAR_40.modulus_length = VAR_6;\n\t\tif (VAR_4 == 1)\n\t\t\tVAR_40.usage = VAR_42;\n\t\telse if(VAR_5 > 0) /* COMMENT_8 */\n\t\t\tVAR_40.usage = VAR_43 | VAR_44;\n\t\telse\n\t\t\tVAR_40.usage = VAR_43 | VAR_45 | VAR_46;\n\n\t\tstrlcpy(VAR_41.label, VAR_39[VAR_4], sizeof(VAR_41.label));\n\t\tVAR_41.auth_id.len = 1;\n\t\tVAR_41.auth_id.value[0] = VAR_38[VAR_4];\n\t\tVAR_41.user_consent = 0;\n\t\tVAR_41.flags = VAR_47;\n\n\t\tif(VAR_5 > 0)\n\t\t\tVAR_3 = sc_pkcs15emu_add_ec_prkey(VAR_0, &VAR_41, &VAR_40);\n\t\telse\n\t\t\tVAR_3 = sc_pkcs15emu_add_rsa_prkey(VAR_0, &VAR_41, &VAR_40);\n\t\tif (VAR_3 < 0)\n\t\t\treturn VAR_19;\n\t}\n\n\treturn VAR_22;\n}",
  "func_graph_path_before": "OpenSC/360e95d45ac4123255a4c796db96337f332160ad/pkcs15-esteid.c/vul/before/0.json",
  "func": "static int\nsc_pkcs15emu_esteid_init (sc_pkcs15_card_t * p15card)\n{\n\tsc_card_t *card = p15card->card;\n\tunsigned char buff[128];\n\tint r, i;\n\tsize_t field_length = 0, modulus_length = 0;\n\tsc_path_t tmppath;\n\n\tset_string (&p15card->tokeninfo->label, \"ID-kaart\");\n\tset_string (&p15card->tokeninfo->manufacturer_id, \"AS Sertifitseerimiskeskus\");\n\n\t/* Select application directory */\n\tsc_format_path (\"3f00eeee5044\", &tmppath);\n\tr = sc_select_file (card, &tmppath, NULL);\n\tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"select esteid PD failed\");\n\n\t/* read the serial (document number) */\n\tr = sc_read_record (card, SC_ESTEID_PD_DOCUMENT_NR, buff, sizeof(buff), SC_RECORD_BY_REC_NR);\n\tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"read document number failed\");\n\tbuff[MIN((size_t) r, (sizeof buff)-1)] = '\\0';\n\tset_string (&p15card->tokeninfo->serial_number, (const char *) buff);\n\n\tp15card->tokeninfo->flags = SC_PKCS15_TOKEN_PRN_GENERATION\n\t\t\t\t  | SC_PKCS15_TOKEN_EID_COMPLIANT\n\t\t\t\t  | SC_PKCS15_TOKEN_READONLY;\n\n\t/* add certificates */\n\tfor (i = 0; i < 2; i++) {\n\t\tstatic const char *esteid_cert_names[2] = {\n\t\t\t\"Isikutuvastus\",\n\t\t\t\"Allkirjastamine\"};\n\t\tstatic char const *esteid_cert_paths[2] = {\n\t\t\t\"3f00eeeeaace\",\n\t\t\t\"3f00eeeeddce\"};\n\t\tstatic int esteid_cert_ids[2] = {1, 2};\n\n\t\tstruct sc_pkcs15_cert_info cert_info;\n\t\tstruct sc_pkcs15_object cert_obj;\n\n\t\tmemset(&cert_info, 0, sizeof(cert_info));\n\t\tmemset(&cert_obj, 0, sizeof(cert_obj));\n\n\t\tcert_info.id.value[0] = esteid_cert_ids[i];\n\t\tcert_info.id.len = 1;\n\t\tsc_format_path(esteid_cert_paths[i], &cert_info.path);\n\t\tstrlcpy(cert_obj.label, esteid_cert_names[i], sizeof(cert_obj.label));\n\t\tr = sc_pkcs15emu_add_x509_cert(p15card, &cert_obj, &cert_info);\n\t\tif (r < 0)\n\t\t\treturn SC_ERROR_INTERNAL;\n\t\tif (i == 0) {\n\t\t\tsc_pkcs15_cert_t *cert = NULL;\n\t\t\tr = sc_pkcs15_read_certificate(p15card, &cert_info, &cert);\n\t\t\tif (r < 0)\n\t\t\t\treturn SC_ERROR_INTERNAL;\n\t\t\tif (cert->key->algorithm == SC_ALGORITHM_EC)\n\t\t\t\tfield_length = cert->key->u.ec.params.field_length;\n\t\t\telse\n\t\t\t\tmodulus_length = cert->key->u.rsa.modulus.len * 8;\n\t\t\tif (r == SC_SUCCESS) {\n\t\t\t\tstatic const struct sc_object_id cn_oid = {{ 2, 5, 4, 3, -1 }};\n\t\t\t\tu8 *cn_name = NULL;\n\t\t\t\tsize_t cn_len = 0;\n\t\t\t\tsc_pkcs15_get_name_from_dn(card->ctx, cert->subject,\n\t\t\t\t\tcert->subject_len, &cn_oid, &cn_name, &cn_len);\n\t\t\t\tif (cn_len > 0) {\n\t\t\t\t\tchar *token_name = malloc(cn_len+1);\n\t\t\t\t\tif (token_name) {\n\t\t\t\t\t\tmemcpy(token_name, cn_name, cn_len);\n\t\t\t\t\t\ttoken_name[cn_len] = '\\0';\n\t\t\t\t\t\tset_string(&p15card->tokeninfo->label, (const char*)token_name);\n\t\t\t\t\t\tfree(token_name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree(cn_name);\n\t\t\t\tsc_pkcs15_free_certificate(cert);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* the file with key pin info (tries left) */\n\tsc_format_path (\"3f000016\", &tmppath);\n\tr = sc_select_file (card, &tmppath, NULL);\n\tif (r < 0)\n\t\treturn SC_ERROR_INTERNAL;\n\n\t/* add pins */\n\tfor (i = 0; i < 3; i++) {\n\t\tunsigned char tries_left;\n\t\tstatic const char *esteid_pin_names[3] = {\n\t\t\t\"PIN1\",\n\t\t\t\"PIN2\",\n\t\t\t\"PUK\" };\n\t\t\t\n\t\tstatic const int esteid_pin_min[3] = {4, 5, 8};\n\t\tstatic const int esteid_pin_ref[3] = {1, 2, 0};\n\t\tstatic const int esteid_pin_authid[3] = {1, 2, 3};\n\t\tstatic const int esteid_pin_flags[3] = {0, 0, SC_PKCS15_PIN_FLAG_UNBLOCKING_PIN};\n\t\t\n\t\tstruct sc_pkcs15_auth_info pin_info;\n\t\tstruct sc_pkcs15_object pin_obj;\n\n\t\tmemset(&pin_info, 0, sizeof(pin_info));\n\t\tmemset(&pin_obj, 0, sizeof(pin_obj));\n\n\t\t/* read the number of tries left for the PIN */\n\t\tr = sc_read_record (card, i + 1, buff, sizeof(buff), SC_RECORD_BY_REC_NR);\n\t\tif (r < 0)\n\t\t\treturn SC_ERROR_INTERNAL;\n\t\ttries_left = buff[5];\n\n\t\tpin_info.auth_id.len = 1;\n\t\tpin_info.auth_id.value[0] = esteid_pin_authid[i];\n\t\tpin_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;\n\t\tpin_info.attrs.pin.reference = esteid_pin_ref[i];\n\t\tpin_info.attrs.pin.flags = esteid_pin_flags[i];\n\t\tpin_info.attrs.pin.type = SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;\n\t\tpin_info.attrs.pin.min_length = esteid_pin_min[i];\n\t\tpin_info.attrs.pin.stored_length = 12;\n\t\tpin_info.attrs.pin.max_length = 12;\n\t\tpin_info.attrs.pin.pad_char = '\\0';\n\t\tpin_info.tries_left = (int)tries_left;\n\t\tpin_info.max_tries = 3;\n\n\t\tstrlcpy(pin_obj.label, esteid_pin_names[i], sizeof(pin_obj.label));\n\t\tpin_obj.flags = esteid_pin_flags[i];\n\n\t\t/* Link normal PINs with PUK */\n\t\tif (i < 2) {\n\t\t\tpin_obj.auth_id.len = 1;\n\t\t\tpin_obj.auth_id.value[0] = 3;\n\t\t}\n\n\t\tr = sc_pkcs15emu_add_pin_obj(p15card, &pin_obj, &pin_info);\n\t\tif (r < 0)\n\t\t\treturn SC_ERROR_INTERNAL;\n\t}\n\n\t/* add private keys */\n\tfor (i = 0; i < 2; i++) {\n\t\tstatic int prkey_pin[2] = {1, 2};\n\n\t\tstatic const char *prkey_name[2] = {\n\t\t\t\"Isikutuvastus\",\n\t\t\t\"Allkirjastamine\"};\n\n\t\tstruct sc_pkcs15_prkey_info prkey_info;\n\t\tstruct sc_pkcs15_object prkey_obj;\n\n\t\tmemset(&prkey_info, 0, sizeof(prkey_info));\n\t\tmemset(&prkey_obj, 0, sizeof(prkey_obj));\n\n\t\tprkey_info.id.len = 1;\n\t\tprkey_info.id.value[0] = prkey_pin[i];\n\t\tprkey_info.native = 1;\n\t\tprkey_info.key_reference = i + 1;\n\t\tprkey_info.field_length = field_length;\n\t\tprkey_info.modulus_length = modulus_length;\n\t\tif (i == 1)\n\t\t\tprkey_info.usage = SC_PKCS15_PRKEY_USAGE_NONREPUDIATION;\n\t\telse if(field_length > 0) // ECC has sign and derive usage\n\t\t\tprkey_info.usage = SC_PKCS15_PRKEY_USAGE_SIGN | SC_PKCS15_PRKEY_USAGE_DERIVE;\n\t\telse\n\t\t\tprkey_info.usage = SC_PKCS15_PRKEY_USAGE_SIGN | SC_PKCS15_PRKEY_USAGE_ENCRYPT | SC_PKCS15_PRKEY_USAGE_DECRYPT;\n\n\t\tstrlcpy(prkey_obj.label, prkey_name[i], sizeof(prkey_obj.label));\n\t\tprkey_obj.auth_id.len = 1;\n\t\tprkey_obj.auth_id.value[0] = prkey_pin[i];\n\t\tprkey_obj.user_consent = 0;\n\t\tprkey_obj.flags = SC_PKCS15_CO_FLAG_PRIVATE;\n\n\t\tif(field_length > 0)\n\t\t\tr = sc_pkcs15emu_add_ec_prkey(p15card, &prkey_obj, &prkey_info);\n\t\telse\n\t\t\tr = sc_pkcs15emu_add_rsa_prkey(p15card, &prkey_obj, &prkey_info);\n\t\tif (r < 0)\n\t\t\treturn SC_ERROR_INTERNAL;\n\t}\n\n\treturn SC_SUCCESS;\n}",
  "abstract_func": "static int\nsc_pkcs15emu_esteid_init (sc_pkcs15_card_t * VAR_0)\n{\n\tsc_card_t *VAR_1 = VAR_0->card;\n\tunsigned char VAR_2[128];\n\tint VAR_3, VAR_4;\n\tsize_t VAR_5 = 0, VAR_6 = 0;\n\tsc_path_t VAR_7;\n\n\tset_string (&VAR_0->tokeninfo->label, \"ID-kaart\");\n\tset_string (&VAR_0->tokeninfo->manufacturer_id, \"AS Sertifitseerimiskeskus\");\n\n\t/* COMMENT_0 */\n\tsc_format_path (\"3f00eeee5044\", &VAR_7);\n\tVAR_3 = sc_select_file (VAR_1, &VAR_7, NULL);\n\tSC_TEST_RET(VAR_1->ctx, VAR_8, VAR_3, \"select esteid PD failed\");\n\n\t/* COMMENT_1 */\n\tVAR_3 = sc_read_record (VAR_1, VAR_9, VAR_2, sizeof(VAR_2), VAR_10);\n\tSC_TEST_RET(VAR_1->ctx, VAR_8, VAR_3, \"read document number failed\");\n\tVAR_2[MIN((size_t) VAR_3, (sizeof VAR_2)-1)] = '\\0';\n\tset_string (&VAR_0->tokeninfo->serial_number, (const char *) VAR_2);\n\n\tVAR_0->tokeninfo->flags = VAR_11\n\t\t\t\t  | VAR_12\n\t\t\t\t  | VAR_13;\n\n\t/* COMMENT_2 */\n\tfor (VAR_4 = 0; VAR_4 < 2; VAR_4++) {\n\t\tstatic const char *VAR_14[2] = {\n\t\t\t\"Isikutuvastus\",\n\t\t\t\"Allkirjastamine\"};\n\t\tstatic char const *VAR_15[2] = {\n\t\t\t\"3f00eeeeaace\",\n\t\t\t\"3f00eeeeddce\"};\n\t\tstatic int VAR_16[2] = {1, 2};\n\n\t\tstruct sc_pkcs15_cert_info VAR_17;\n\t\tstruct sc_pkcs15_object VAR_18;\n\n\t\tmemset(&VAR_17, 0, sizeof(VAR_17));\n\t\tmemset(&VAR_18, 0, sizeof(VAR_18));\n\n\t\tVAR_17.id.value[0] = VAR_16[VAR_4];\n\t\tVAR_17.id.len = 1;\n\t\tsc_format_path(VAR_15[VAR_4], &VAR_17.path);\n\t\tstrlcpy(VAR_18.label, VAR_14[VAR_4], sizeof(VAR_18.label));\n\t\tVAR_3 = sc_pkcs15emu_add_x509_cert(VAR_0, &VAR_18, &VAR_17);\n\t\tif (VAR_3 < 0)\n\t\t\treturn VAR_19;\n\t\tif (VAR_4 == 0) {\n\t\t\tsc_pkcs15_cert_t *VAR_20 = NULL;\n\t\t\tVAR_3 = sc_pkcs15_read_certificate(VAR_0, &VAR_17, &VAR_20);\n\t\t\tif (VAR_3 < 0)\n\t\t\t\treturn VAR_19;\n\t\t\tif (VAR_20->key->algorithm == VAR_21)\n\t\t\t\tVAR_5 = VAR_20->key->u.ec.params.field_length;\n\t\t\telse\n\t\t\t\tVAR_6 = VAR_20->key->u.rsa.modulus.len * 8;\n\t\t\tif (VAR_3 == VAR_22) {\n\t\t\t\tstatic const struct sc_object_id VAR_23 = {{ 2, 5, 4, 3, -1 }};\n\t\t\t\tu8 *VAR_24 = NULL;\n\t\t\t\tsize_t VAR_25 = 0;\n\t\t\t\tsc_pkcs15_get_name_from_dn(VAR_1->ctx, VAR_20->subject,\n\t\t\t\t\tVAR_20->subject_len, &VAR_23, &VAR_24, &VAR_25);\n\t\t\t\tif (VAR_25 > 0) {\n\t\t\t\t\tchar *VAR_26 = malloc(VAR_25+1);\n\t\t\t\t\tif (VAR_26) {\n\t\t\t\t\t\tmemcpy(VAR_26, VAR_24, VAR_25);\n\t\t\t\t\t\tVAR_26[VAR_25] = '\\0';\n\t\t\t\t\t\tset_string(&VAR_0->tokeninfo->label, (const char*)VAR_26);\n\t\t\t\t\t\tfree(VAR_26);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree(VAR_24);\n\t\t\t\tsc_pkcs15_free_certificate(VAR_20);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* COMMENT_3 */\n\tsc_format_path (\"3f000016\", &VAR_7);\n\tVAR_3 = sc_select_file (VAR_1, &VAR_7, NULL);\n\tif (VAR_3 < 0)\n\t\treturn VAR_19;\n\n\t/* COMMENT_4 */\n\tfor (VAR_4 = 0; VAR_4 < 3; VAR_4++) {\n\t\tunsigned char VAR_27;\n\t\tstatic const char *VAR_28[3] = {\n\t\t\t\"PIN1\",\n\t\t\t\"PIN2\",\n\t\t\t\"PUK\" };\n\t\t\t\n\t\tstatic const int VAR_29[3] = {4, 5, 8};\n\t\tstatic const int VAR_30[3] = {1, 2, 0};\n\t\tstatic const int VAR_31[3] = {1, 2, 3};\n\t\tstatic const int VAR_32[3] = {0, 0, VAR_33};\n\t\t\n\t\tstruct sc_pkcs15_auth_info VAR_34;\n\t\tstruct sc_pkcs15_object VAR_35;\n\n\t\tmemset(&VAR_34, 0, sizeof(VAR_34));\n\t\tmemset(&VAR_35, 0, sizeof(VAR_35));\n\n\t\t/* COMMENT_5 */\n\t\tVAR_3 = sc_read_record (VAR_1, VAR_4 + 1, VAR_2, sizeof(VAR_2), VAR_10);\n\t\tif (VAR_3 < 0)\n\t\t\treturn VAR_19;\n\t\tVAR_27 = VAR_2[5];\n\n\t\tVAR_34.auth_id.len = 1;\n\t\tVAR_34.auth_id.value[0] = VAR_31[VAR_4];\n\t\tVAR_34.auth_type = VAR_36;\n\t\tVAR_34.attrs.pin.reference = VAR_30[VAR_4];\n\t\tVAR_34.attrs.pin.flags = VAR_32[VAR_4];\n\t\tVAR_34.attrs.pin.type = VAR_37;\n\t\tVAR_34.attrs.pin.min_length = VAR_29[VAR_4];\n\t\tVAR_34.attrs.pin.stored_length = 12;\n\t\tVAR_34.attrs.pin.max_length = 12;\n\t\tVAR_34.attrs.pin.pad_char = '\\0';\n\t\tVAR_34.tries_left = (int)VAR_27;\n\t\tVAR_34.max_tries = 3;\n\n\t\tstrlcpy(VAR_35.label, VAR_28[VAR_4], sizeof(VAR_35.label));\n\t\tVAR_35.flags = VAR_32[VAR_4];\n\n\t\t/* COMMENT_6 */\n\t\tif (VAR_4 < 2) {\n\t\t\tVAR_35.auth_id.len = 1;\n\t\t\tVAR_35.auth_id.value[0] = 3;\n\t\t}\n\n\t\tVAR_3 = sc_pkcs15emu_add_pin_obj(VAR_0, &VAR_35, &VAR_34);\n\t\tif (VAR_3 < 0)\n\t\t\treturn VAR_19;\n\t}\n\n\t/* COMMENT_7 */\n\tfor (VAR_4 = 0; VAR_4 < 2; VAR_4++) {\n\t\tstatic int VAR_38[2] = {1, 2};\n\n\t\tstatic const char *VAR_39[2] = {\n\t\t\t\"Isikutuvastus\",\n\t\t\t\"Allkirjastamine\"};\n\n\t\tstruct sc_pkcs15_prkey_info VAR_40;\n\t\tstruct sc_pkcs15_object VAR_41;\n\n\t\tmemset(&VAR_40, 0, sizeof(VAR_40));\n\t\tmemset(&VAR_41, 0, sizeof(VAR_41));\n\n\t\tVAR_40.id.len = 1;\n\t\tVAR_40.id.value[0] = VAR_38[VAR_4];\n\t\tVAR_40.native = 1;\n\t\tVAR_40.key_reference = VAR_4 + 1;\n\t\tVAR_40.field_length = VAR_5;\n\t\tVAR_40.modulus_length = VAR_6;\n\t\tif (VAR_4 == 1)\n\t\t\tVAR_40.usage = VAR_42;\n\t\telse if(VAR_5 > 0) /* COMMENT_8 */\n\t\t\tVAR_40.usage = VAR_43 | VAR_44;\n\t\telse\n\t\t\tVAR_40.usage = VAR_43 | VAR_45 | VAR_46;\n\n\t\tstrlcpy(VAR_41.label, VAR_39[VAR_4], sizeof(VAR_41.label));\n\t\tVAR_41.auth_id.len = 1;\n\t\tVAR_41.auth_id.value[0] = VAR_38[VAR_4];\n\t\tVAR_41.user_consent = 0;\n\t\tVAR_41.flags = VAR_47;\n\n\t\tif(VAR_5 > 0)\n\t\t\tVAR_3 = sc_pkcs15emu_add_ec_prkey(VAR_0, &VAR_41, &VAR_40);\n\t\telse\n\t\t\tVAR_3 = sc_pkcs15emu_add_rsa_prkey(VAR_0, &VAR_41, &VAR_40);\n\t\tif (VAR_3 < 0)\n\t\t\treturn VAR_19;\n\t}\n\n\treturn VAR_22;\n}",
  "func_graph_path": "OpenSC/360e95d45ac4123255a4c796db96337f332160ad/pkcs15-esteid.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -18,7 +18,7 @@\n \t/* read the serial (document number) */\n \tr = sc_read_record (card, SC_ESTEID_PD_DOCUMENT_NR, buff, sizeof(buff), SC_RECORD_BY_REC_NR);\n \tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"read document number failed\");\n-\tbuff[r] = '\\0';\n+\tbuff[MIN((size_t) r, (sizeof buff)-1)] = '\\0';\n \tset_string (&p15card->tokeninfo->serial_number, (const char *) buff);\n \n \tp15card->tokeninfo->flags = SC_PKCS15_TOKEN_PRN_GENERATION",
  "diff_line_info": {
    "deleted_lines": [
      "\tbuff[r] = '\\0';"
    ],
    "added_lines": [
      "\tbuff[MIN((size_t) r, (sizeof buff)-1)] = '\\0';"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/OpenSC/OpenSC/pull/1447",
  "description": {
    "pr_info": {
      "title": "Security issues identified by fuzzing",
      "number": 1447
    },
    "comment": [
      "This PR merges changes addressing issues identified by fuzzing OpenSC driver by Eric Sesterhenn. The separate commits are authored mostly by @frankmorgner, @dengert, Eric and me.\r\n\r\nFor more information, see the blog post:\r\n\r\nhttps://www.x41-dsec.de/lab/blog/smartcards/\r\n\r\nThe changes were tested to ensure they still work for the cards we have, but testing with more cards would be always appreciated.\r\n\r\n##### Checklist\r\n<!-- Remove items that do not apply. For completed items, change [ ] to [x]. -->\r\n- [X] PKCS#11 module is tested\r\n- [ ] Windows minidriver is tested\r\n- [ ] macOS tokend is tested\r\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}