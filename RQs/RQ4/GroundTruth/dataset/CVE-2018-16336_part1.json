{
  "cve_id": "CVE-2018-16336",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "Exiv2/exiv2",
  "commit_msg": "Add overflow & overread checks to PngChunk::parseTXTChunk()\n\nThis function was creating a lot of new pointers and strings without\nproperly checking the array bounds. This commit adds several calls\nto enforce(), making sure that the pointers stay within bounds.\nStrings are now created using the helper function\nstring_from_unterminated() to prevent overreads in the constructor of\nstd::string.\n\nThis fixes #400",
  "commit_hash": "35b3e596edacd2437c2c5d3dd2b5c9502626163d",
  "git_url": "https://github.com/Exiv2/exiv2/commit/35b3e596edacd2437c2c5d3dd2b5c9502626163d",
  "file_path": "src/pngchunk_int.cpp",
  "func_name": "PngChunk::parseTXTChunk",
  "func_before": "DataBuf PngChunk::parseTXTChunk(const DataBuf& data,\n                                    int            keysize,\n                                    TxtChunkType   type)\n    {\n        DataBuf arr;\n\n        if(type == zTXt_Chunk)\n        {\n            // Extract a deflate compressed Latin-1 text chunk\n\n            // we get the compression method after the key\n            const byte* compressionMethod = data.pData_ + keysize + 1;\n            if ( *compressionMethod != 0x00 )\n            {\n                // then it isn't zlib compressed and we are sunk\n#ifdef DEBUG\n                std::cerr << \"Exiv2::PngChunk::parseTXTChunk: Non-standard zTXt compression method.\\n\";\n#endif\n                throw Error(kerFailedToReadImageData);\n            }\n\n            // compressed string after the compression technique spec\n            const byte* compressedText      = data.pData_ + keysize + 2;\n            unsigned int compressedTextSize = data.size_  - keysize - 2;\n\n            zlibUncompress(compressedText, compressedTextSize, arr);\n        }\n        else if(type == tEXt_Chunk)\n        {\n            // Extract a non-compressed Latin-1 text chunk\n\n            // the text comes after the key, but isn't null terminated\n            const byte* text = data.pData_ + keysize + 1;\n            long textsize    = data.size_  - keysize - 1;\n\n            arr = DataBuf(text, textsize);\n        }\n        else if(type == iTXt_Chunk)\n        {\n            const int nullSeparators = std::count(&data.pData_[keysize+3], &data.pData_[data.size_], '\\0');\n            enforce(nullSeparators >= 2, Exiv2::kerCorruptedMetadata);\n\n            // Extract a deflate compressed or uncompressed UTF-8 text chunk\n\n            // we get the compression flag after the key\n            const byte compressionFlag   = data.pData_[keysize + 1];\n            // we get the compression method after the compression flag\n            const byte compressionMethod = data.pData_[keysize + 2];\n\n            enforce(compressionFlag == 0x00 || compressionFlag == 0x01, Exiv2::kerCorruptedMetadata);\n            enforce(compressionMethod == 0x00, Exiv2::kerCorruptedMetadata);\n\n            // language description string after the compression technique spec\n            std::string languageText((const char*)(data.pData_ + keysize + 3));\n            unsigned int languageTextSize = static_cast<unsigned int>(languageText.size());\n            // translated keyword string after the language description\n            std::string translatedKeyText((const char*)(data.pData_ + keysize + 3 + languageTextSize +1));\n            unsigned int translatedKeyTextSize = static_cast<unsigned int>(translatedKeyText.size());\n\n            if ( compressionFlag == 0x00 )\n            {\n                // then it's an uncompressed iTXt chunk\n#ifdef DEBUG\n                std::cout << \"Exiv2::PngChunk::parseTXTChunk: We found an uncompressed iTXt field\\n\";\n#endif\n\n                // the text comes after the translated keyword, but isn't null terminated\n                const byte* text = data.pData_ + keysize + 3 + languageTextSize + 1 + translatedKeyTextSize + 1;\n                long textsize    = data.size_ - (keysize + 3 + languageTextSize + 1 + translatedKeyTextSize + 1);\n\n                arr.alloc(textsize);\n                arr = DataBuf(text, textsize);\n            }\n            else if ( compressionFlag == 0x01 && compressionMethod == 0x00 )\n            {\n                // then it's a zlib compressed iTXt chunk\n#ifdef DEBUG\n                std::cout << \"Exiv2::PngChunk::parseTXTChunk: We found a zlib compressed iTXt field\\n\";\n#endif\n\n                // the compressed text comes after the translated keyword, but isn't null terminated\n                const byte* compressedText = data.pData_ + keysize + 3 + languageTextSize + 1 + translatedKeyTextSize + 1;\n                long compressedTextSize    = data.size_ - (keysize + 3 + languageTextSize + 1 + translatedKeyTextSize + 1);\n\n                zlibUncompress(compressedText, compressedTextSize, arr);\n            }\n            else\n            {\n                // then it isn't zlib compressed and we are sunk\n#ifdef DEBUG\n                std::cerr << \"Exiv2::PngChunk::parseTXTChunk: Non-standard iTXt compression method.\\n\";\n#endif\n                throw Error(kerFailedToReadImageData);\n            }\n        }\n        else\n        {\n#ifdef DEBUG\n            std::cerr << \"Exiv2::PngChunk::parseTXTChunk: We found a field, not expected though\\n\";\n#endif\n            throw Error(kerFailedToReadImageData);\n        }\n\n        return arr;\n\n    }",
  "abstract_func_before": "DataBuf PngChunk::parseTXTChunk(const DataBuf& VAR_0,\n                                    int            VAR_1,\n                                    TxtChunkType   VAR_2)\n    {\n        DataBuf VAR_3;\n\n        if(VAR_2 == VAR_4)\n        {\n            /* COMMENT_0 */\n\n            /* COMMENT_1 */\n            const byte* VAR_5 = VAR_0.pData_ + VAR_1 + 1;\n            if ( *VAR_5 != 0x00 )\n            {\n                /* COMMENT_2 */\n#ifdef VAR_6\n                std::cerr << \"Exiv2::PngChunk::parseTXTChunk: Non-standard zTXt compression method.\\n\";\n#endif\n                throw Error(VAR_7);\n            }\n\n            /* COMMENT_3 */\n            const byte* VAR_8      = VAR_0.pData_ + VAR_1 + 2;\n            unsigned int VAR_9 = VAR_0.size_  - VAR_1 - 2;\n\n            zlibUncompress(VAR_8, VAR_9, VAR_3);\n        }\n        else if(VAR_2 == VAR_10)\n        {\n            /* COMMENT_4 */\n\n            /* COMMENT_5 */\n            const byte* VAR_11 = VAR_0.pData_ + VAR_1 + 1;\n            long VAR_12    = VAR_0.size_  - VAR_1 - 1;\n\n            VAR_3 = DataBuf(VAR_11, VAR_12);\n        }\n        else if(VAR_2 == VAR_13)\n        {\n            const int VAR_14 = std::count(&VAR_0.pData_[VAR_1+3], &VAR_0.pData_[VAR_0.size_], '\\0');\n            enforce(VAR_14 >= 2, Exiv2::kerCorruptedMetadata);\n\n            /* COMMENT_6 */\n\n            /* COMMENT_7 */\n            const byte VAR_15   = VAR_0.pData_[VAR_1 + 1];\n            /* COMMENT_8 */\n            const byte VAR_5 = VAR_0.pData_[VAR_1 + 2];\n\n            enforce(VAR_15 == 0x00 || VAR_15 == 0x01, Exiv2::kerCorruptedMetadata);\n            enforce(VAR_5 == 0x00, Exiv2::kerCorruptedMetadata);\n\n            /* COMMENT_9 */\n            std::string VAR_16((const char*)(VAR_0.pData_ + VAR_1 + 3));\n            unsigned int VAR_17 = VAR_18<unsigned int>(VAR_16.size());\n            /* COMMENT_10 */\n            std::string VAR_19((const char*)(VAR_0.pData_ + VAR_1 + 3 + VAR_17 +1));\n            unsigned int VAR_20 = VAR_18<unsigned int>(VAR_19.size());\n\n            if ( VAR_15 == 0x00 )\n            {\n                /* COMMENT_11 */\n#ifdef VAR_6\n                std::cout << \"Exiv2::PngChunk::parseTXTChunk: We found an uncompressed iTXt field\\n\";\n#endif\n\n                /* COMMENT_12 */\n                const byte* VAR_11 = VAR_0.pData_ + VAR_1 + 3 + VAR_17 + 1 + VAR_20 + 1;\n                long VAR_12    = VAR_0.size_ - (VAR_1 + 3 + VAR_17 + 1 + VAR_20 + 1);\n\n                VAR_3.alloc(VAR_12);\n                VAR_3 = DataBuf(VAR_11, VAR_12);\n            }\n            else if ( VAR_15 == 0x01 && VAR_5 == 0x00 )\n            {\n                /* COMMENT_13 */\n#ifdef VAR_6\n                std::cout << \"Exiv2::PngChunk::parseTXTChunk: We found a zlib compressed iTXt field\\n\";\n#endif\n\n                /* COMMENT_14 */\n                const byte* VAR_8 = VAR_0.pData_ + VAR_1 + 3 + VAR_17 + 1 + VAR_20 + 1;\n                long VAR_9    = VAR_0.size_ - (VAR_1 + 3 + VAR_17 + 1 + VAR_20 + 1);\n\n                zlibUncompress(VAR_8, VAR_9, VAR_3);\n            }\n            else\n            {\n                /* COMMENT_2 */\n#ifdef VAR_6\n                std::cerr << \"Exiv2::PngChunk::parseTXTChunk: Non-standard iTXt compression method.\\n\";\n#endif\n                throw Error(VAR_7);\n            }\n        }\n        else\n        {\n#ifdef VAR_6\n            std::cerr << \"Exiv2::PngChunk::parseTXTChunk: We found a field, not expected though\\n\";\n#endif\n            throw Error(VAR_7);\n        }\n\n        return VAR_3;\n\n    }",
  "func_graph_path_before": "Exiv2/exiv2/35b3e596edacd2437c2c5d3dd2b5c9502626163d/pngchunk_int.cpp/vul/before/0.json",
  "func": "DataBuf PngChunk::parseTXTChunk(const DataBuf& data,\n                                    int            keysize,\n                                    TxtChunkType   type)\n    {\n        DataBuf arr;\n\n        if(type == zTXt_Chunk)\n        {\n            enforce(data.size_ >= Safe::add(keysize, 2), Exiv2::kerCorruptedMetadata);\n\n            // Extract a deflate compressed Latin-1 text chunk\n\n            // we get the compression method after the key\n            const byte* compressionMethod = data.pData_ + keysize + 1;\n            if ( *compressionMethod != 0x00 )\n            {\n                // then it isn't zlib compressed and we are sunk\n#ifdef DEBUG\n                std::cerr << \"Exiv2::PngChunk::parseTXTChunk: Non-standard zTXt compression method.\\n\";\n#endif\n                throw Error(kerFailedToReadImageData);\n            }\n\n            // compressed string after the compression technique spec\n            const byte* compressedText      = data.pData_ + keysize + 2;\n            unsigned int compressedTextSize = data.size_  - keysize - 2;\n            enforce(compressedTextSize < data.size_, kerCorruptedMetadata);\n\n            zlibUncompress(compressedText, compressedTextSize, arr);\n        }\n        else if(type == tEXt_Chunk)\n        {\n            enforce(data.size_ >= Safe::add(keysize, 1), Exiv2::kerCorruptedMetadata);\n            // Extract a non-compressed Latin-1 text chunk\n\n            // the text comes after the key, but isn't null terminated\n            const byte* text = data.pData_ + keysize + 1;\n            long textsize    = data.size_  - keysize - 1;\n\n            arr = DataBuf(text, textsize);\n        }\n        else if(type == iTXt_Chunk)\n        {\n            enforce(data.size_ >= Safe::add(keysize, 3), Exiv2::kerCorruptedMetadata);\n            const int nullSeparators = std::count(&data.pData_[keysize+3], &data.pData_[data.size_], '\\0');\n            enforce(nullSeparators >= 2, Exiv2::kerCorruptedMetadata);\n\n            // Extract a deflate compressed or uncompressed UTF-8 text chunk\n\n            // we get the compression flag after the key\n            const byte compressionFlag   = data.pData_[keysize + 1];\n            // we get the compression method after the compression flag\n            const byte compressionMethod = data.pData_[keysize + 2];\n\n            enforce(compressionFlag == 0x00 || compressionFlag == 0x01, Exiv2::kerCorruptedMetadata);\n            enforce(compressionMethod == 0x00, Exiv2::kerCorruptedMetadata);\n\n            // language description string after the compression technique spec\n            const size_t languageTextMaxSize = data.size_ - keysize - 3;\n            std::string languageText =\n                string_from_unterminated((const char*)(data.pData_ + Safe::add(keysize, 3)), languageTextMaxSize);\n            const unsigned int languageTextSize = static_cast<unsigned int>(languageText.size());\n\n            enforce(data.size_ >= Safe::add(static_cast<unsigned int>(Safe::add(keysize, 4)), languageTextSize),\n                    Exiv2::kerCorruptedMetadata);\n            // translated keyword string after the language description\n            std::string translatedKeyText =\n                string_from_unterminated((const char*)(data.pData_ + keysize + 3 + languageTextSize + 1),\n                                         data.size_ - (keysize + 3 + languageTextSize + 1));\n            const unsigned int translatedKeyTextSize = static_cast<unsigned int>(translatedKeyText.size());\n\n            if ((compressionFlag == 0x00) || (compressionFlag == 0x01 && compressionMethod == 0x00)) {\n                enforce(Safe::add(static_cast<unsigned int>(keysize + 3 + languageTextSize + 1),\n                                  Safe::add(translatedKeyTextSize, 1u)) <= data.size_,\n                        Exiv2::kerCorruptedMetadata);\n\n                const byte* text = data.pData_ + keysize + 3 + languageTextSize + 1 + translatedKeyTextSize + 1;\n                const long textsize = data.size_ - (keysize + 3 + languageTextSize + 1 + translatedKeyTextSize + 1);\n\n                if (compressionFlag == 0x00) {\n                    // then it's an uncompressed iTXt chunk\n#ifdef DEBUG\n                    std::cout << \"Exiv2::PngChunk::parseTXTChunk: We found an uncompressed iTXt field\\n\";\n#endif\n\n                    arr.alloc(textsize);\n                    arr = DataBuf(text, textsize);\n                } else if (compressionFlag == 0x01 && compressionMethod == 0x00) {\n                    // then it's a zlib compressed iTXt chunk\n#ifdef DEBUG\n                    std::cout << \"Exiv2::PngChunk::parseTXTChunk: We found a zlib compressed iTXt field\\n\";\n#endif\n\n                    // the compressed text comes after the translated keyword, but isn't null terminated\n                    zlibUncompress(text, textsize, arr);\n                }\n            } else {\n                // then it isn't zlib compressed and we are sunk\n#ifdef DEBUG\n                std::cerr << \"Exiv2::PngChunk::parseTXTChunk: Non-standard iTXt compression method.\\n\";\n#endif\n                throw Error(kerFailedToReadImageData);\n            }\n        }\n        else\n        {\n#ifdef DEBUG\n            std::cerr << \"Exiv2::PngChunk::parseTXTChunk: We found a field, not expected though\\n\";\n#endif\n            throw Error(kerFailedToReadImageData);\n        }\n\n        return arr;\n\n    }",
  "abstract_func": "DataBuf PngChunk::parseTXTChunk(const DataBuf& VAR_0,\n                                    int            VAR_1,\n                                    TxtChunkType   VAR_2)\n    {\n        DataBuf VAR_3;\n\n        if(VAR_2 == VAR_4)\n        {\n            enforce(VAR_0.size_ >= Safe::add(VAR_1, 2), Exiv2::kerCorruptedMetadata);\n\n            /* COMMENT_0 */\n\n            /* COMMENT_1 */\n            const byte* VAR_5 = VAR_0.pData_ + VAR_1 + 1;\n            if ( *VAR_5 != 0x00 )\n            {\n                /* COMMENT_2 */\n#ifdef VAR_6\n                std::cerr << \"Exiv2::PngChunk::parseTXTChunk: Non-standard zTXt compression method.\\n\";\n#endif\n                throw Error(VAR_7);\n            }\n\n            /* COMMENT_3 */\n            const byte* VAR_8      = VAR_0.pData_ + VAR_1 + 2;\n            unsigned int VAR_9 = VAR_0.size_  - VAR_1 - 2;\n            enforce(VAR_9 < VAR_0.size_, VAR_10);\n\n            zlibUncompress(VAR_8, VAR_9, VAR_3);\n        }\n        else if(VAR_2 == VAR_11)\n        {\n            enforce(VAR_0.size_ >= Safe::add(VAR_1, 1), Exiv2::kerCorruptedMetadata);\n            /* COMMENT_4 */\n\n            /* COMMENT_5 */\n            const byte* VAR_12 = VAR_0.pData_ + VAR_1 + 1;\n            long VAR_13    = VAR_0.size_  - VAR_1 - 1;\n\n            VAR_3 = DataBuf(VAR_12, VAR_13);\n        }\n        else if(VAR_2 == VAR_14)\n        {\n            enforce(VAR_0.size_ >= Safe::add(VAR_1, 3), Exiv2::kerCorruptedMetadata);\n            const int VAR_15 = std::count(&VAR_0.pData_[VAR_1+3], &VAR_0.pData_[VAR_0.size_], '\\0');\n            enforce(VAR_15 >= 2, Exiv2::kerCorruptedMetadata);\n\n            /* COMMENT_6 */\n\n            /* COMMENT_7 */\n            const byte VAR_16   = VAR_0.pData_[VAR_1 + 1];\n            /* COMMENT_8 */\n            const byte VAR_5 = VAR_0.pData_[VAR_1 + 2];\n\n            enforce(VAR_16 == 0x00 || VAR_16 == 0x01, Exiv2::kerCorruptedMetadata);\n            enforce(VAR_5 == 0x00, Exiv2::kerCorruptedMetadata);\n\n            /* COMMENT_9 */\n            const size_t VAR_17 = VAR_0.size_ - VAR_1 - 3;\n            std::string VAR_18 =\n                string_from_unterminated((const char*)(VAR_0.pData_ + Safe::add(VAR_1, 3)), VAR_17);\n            const unsigned int VAR_19 = VAR_20<unsigned int>(VAR_18.size());\n\n            enforce(VAR_0.size_ >= Safe::add(VAR_20<unsigned int>(Safe::add(VAR_1, 4)), VAR_19),\n                    Exiv2::kerCorruptedMetadata);\n            /* COMMENT_10 */\n            std::string VAR_21 =\n                string_from_unterminated((const char*)(VAR_0.pData_ + VAR_1 + 3 + VAR_19 + 1),\n                                         VAR_0.size_ - (VAR_1 + 3 + VAR_19 + 1));\n            const unsigned int VAR_22 = VAR_20<unsigned int>(VAR_21.size());\n\n            if ((VAR_16 == 0x00) || (VAR_16 == 0x01 && VAR_5 == 0x00)) {\n                enforce(Safe::add(VAR_20<unsigned int>(VAR_1 + 3 + VAR_19 + 1),\n                                  Safe::add(VAR_22, 1u)) <= VAR_0.size_,\n                        Exiv2::kerCorruptedMetadata);\n\n                const byte* VAR_12 = VAR_0.pData_ + VAR_1 + 3 + VAR_19 + 1 + VAR_22 + 1;\n                const long VAR_13 = VAR_0.size_ - (VAR_1 + 3 + VAR_19 + 1 + VAR_22 + 1);\n\n                if (VAR_16 == 0x00) {\n                    /* COMMENT_11 */\n#ifdef VAR_6\n                    std::cout << \"Exiv2::PngChunk::parseTXTChunk: We found an uncompressed iTXt field\\n\";\n#endif\n\n                    VAR_3.alloc(VAR_13);\n                    VAR_3 = DataBuf(VAR_12, VAR_13);\n                } else if (VAR_16 == 0x01 && VAR_5 == 0x00) {\n                    /* COMMENT_12 */\n#ifdef VAR_6\n                    std::cout << \"Exiv2::PngChunk::parseTXTChunk: We found a zlib compressed iTXt field\\n\";\n#endif\n\n                    /* COMMENT_13 */\n                    zlibUncompress(VAR_12, VAR_13, VAR_3);\n                }\n            } else {\n                /* COMMENT_2 */\n#ifdef VAR_6\n                std::cerr << \"Exiv2::PngChunk::parseTXTChunk: Non-standard iTXt compression method.\\n\";\n#endif\n                throw Error(VAR_7);\n            }\n        }\n        else\n        {\n#ifdef VAR_6\n            std::cerr << \"Exiv2::PngChunk::parseTXTChunk: We found a field, not expected though\\n\";\n#endif\n            throw Error(VAR_7);\n        }\n\n        return VAR_3;\n\n    }",
  "func_graph_path": "Exiv2/exiv2/35b3e596edacd2437c2c5d3dd2b5c9502626163d/pngchunk_int.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -6,6 +6,8 @@\n \n         if(type == zTXt_Chunk)\n         {\n+            enforce(data.size_ >= Safe::add(keysize, 2), Exiv2::kerCorruptedMetadata);\n+\n             // Extract a deflate compressed Latin-1 text chunk\n \n             // we get the compression method after the key\n@@ -22,11 +24,13 @@\n             // compressed string after the compression technique spec\n             const byte* compressedText      = data.pData_ + keysize + 2;\n             unsigned int compressedTextSize = data.size_  - keysize - 2;\n+            enforce(compressedTextSize < data.size_, kerCorruptedMetadata);\n \n             zlibUncompress(compressedText, compressedTextSize, arr);\n         }\n         else if(type == tEXt_Chunk)\n         {\n+            enforce(data.size_ >= Safe::add(keysize, 1), Exiv2::kerCorruptedMetadata);\n             // Extract a non-compressed Latin-1 text chunk\n \n             // the text comes after the key, but isn't null terminated\n@@ -37,6 +41,7 @@\n         }\n         else if(type == iTXt_Chunk)\n         {\n+            enforce(data.size_ >= Safe::add(keysize, 3), Exiv2::kerCorruptedMetadata);\n             const int nullSeparators = std::count(&data.pData_[keysize+3], &data.pData_[data.size_], '\\0');\n             enforce(nullSeparators >= 2, Exiv2::kerCorruptedMetadata);\n \n@@ -51,41 +56,45 @@\n             enforce(compressionMethod == 0x00, Exiv2::kerCorruptedMetadata);\n \n             // language description string after the compression technique spec\n-            std::string languageText((const char*)(data.pData_ + keysize + 3));\n-            unsigned int languageTextSize = static_cast<unsigned int>(languageText.size());\n+            const size_t languageTextMaxSize = data.size_ - keysize - 3;\n+            std::string languageText =\n+                string_from_unterminated((const char*)(data.pData_ + Safe::add(keysize, 3)), languageTextMaxSize);\n+            const unsigned int languageTextSize = static_cast<unsigned int>(languageText.size());\n+\n+            enforce(data.size_ >= Safe::add(static_cast<unsigned int>(Safe::add(keysize, 4)), languageTextSize),\n+                    Exiv2::kerCorruptedMetadata);\n             // translated keyword string after the language description\n-            std::string translatedKeyText((const char*)(data.pData_ + keysize + 3 + languageTextSize +1));\n-            unsigned int translatedKeyTextSize = static_cast<unsigned int>(translatedKeyText.size());\n+            std::string translatedKeyText =\n+                string_from_unterminated((const char*)(data.pData_ + keysize + 3 + languageTextSize + 1),\n+                                         data.size_ - (keysize + 3 + languageTextSize + 1));\n+            const unsigned int translatedKeyTextSize = static_cast<unsigned int>(translatedKeyText.size());\n \n-            if ( compressionFlag == 0x00 )\n-            {\n-                // then it's an uncompressed iTXt chunk\n+            if ((compressionFlag == 0x00) || (compressionFlag == 0x01 && compressionMethod == 0x00)) {\n+                enforce(Safe::add(static_cast<unsigned int>(keysize + 3 + languageTextSize + 1),\n+                                  Safe::add(translatedKeyTextSize, 1u)) <= data.size_,\n+                        Exiv2::kerCorruptedMetadata);\n+\n+                const byte* text = data.pData_ + keysize + 3 + languageTextSize + 1 + translatedKeyTextSize + 1;\n+                const long textsize = data.size_ - (keysize + 3 + languageTextSize + 1 + translatedKeyTextSize + 1);\n+\n+                if (compressionFlag == 0x00) {\n+                    // then it's an uncompressed iTXt chunk\n #ifdef DEBUG\n-                std::cout << \"Exiv2::PngChunk::parseTXTChunk: We found an uncompressed iTXt field\\n\";\n+                    std::cout << \"Exiv2::PngChunk::parseTXTChunk: We found an uncompressed iTXt field\\n\";\n #endif\n \n-                // the text comes after the translated keyword, but isn't null terminated\n-                const byte* text = data.pData_ + keysize + 3 + languageTextSize + 1 + translatedKeyTextSize + 1;\n-                long textsize    = data.size_ - (keysize + 3 + languageTextSize + 1 + translatedKeyTextSize + 1);\n-\n-                arr.alloc(textsize);\n-                arr = DataBuf(text, textsize);\n-            }\n-            else if ( compressionFlag == 0x01 && compressionMethod == 0x00 )\n-            {\n-                // then it's a zlib compressed iTXt chunk\n+                    arr.alloc(textsize);\n+                    arr = DataBuf(text, textsize);\n+                } else if (compressionFlag == 0x01 && compressionMethod == 0x00) {\n+                    // then it's a zlib compressed iTXt chunk\n #ifdef DEBUG\n-                std::cout << \"Exiv2::PngChunk::parseTXTChunk: We found a zlib compressed iTXt field\\n\";\n+                    std::cout << \"Exiv2::PngChunk::parseTXTChunk: We found a zlib compressed iTXt field\\n\";\n #endif\n \n-                // the compressed text comes after the translated keyword, but isn't null terminated\n-                const byte* compressedText = data.pData_ + keysize + 3 + languageTextSize + 1 + translatedKeyTextSize + 1;\n-                long compressedTextSize    = data.size_ - (keysize + 3 + languageTextSize + 1 + translatedKeyTextSize + 1);\n-\n-                zlibUncompress(compressedText, compressedTextSize, arr);\n-            }\n-            else\n-            {\n+                    // the compressed text comes after the translated keyword, but isn't null terminated\n+                    zlibUncompress(text, textsize, arr);\n+                }\n+            } else {\n                 // then it isn't zlib compressed and we are sunk\n #ifdef DEBUG\n                 std::cerr << \"Exiv2::PngChunk::parseTXTChunk: Non-standard iTXt compression method.\\n\";",
  "diff_line_info": {
    "deleted_lines": [
      "            std::string languageText((const char*)(data.pData_ + keysize + 3));",
      "            unsigned int languageTextSize = static_cast<unsigned int>(languageText.size());",
      "            std::string translatedKeyText((const char*)(data.pData_ + keysize + 3 + languageTextSize +1));",
      "            unsigned int translatedKeyTextSize = static_cast<unsigned int>(translatedKeyText.size());",
      "            if ( compressionFlag == 0x00 )",
      "            {",
      "                // then it's an uncompressed iTXt chunk",
      "                std::cout << \"Exiv2::PngChunk::parseTXTChunk: We found an uncompressed iTXt field\\n\";",
      "                // the text comes after the translated keyword, but isn't null terminated",
      "                const byte* text = data.pData_ + keysize + 3 + languageTextSize + 1 + translatedKeyTextSize + 1;",
      "                long textsize    = data.size_ - (keysize + 3 + languageTextSize + 1 + translatedKeyTextSize + 1);",
      "",
      "                arr.alloc(textsize);",
      "                arr = DataBuf(text, textsize);",
      "            }",
      "            else if ( compressionFlag == 0x01 && compressionMethod == 0x00 )",
      "            {",
      "                // then it's a zlib compressed iTXt chunk",
      "                std::cout << \"Exiv2::PngChunk::parseTXTChunk: We found a zlib compressed iTXt field\\n\";",
      "                // the compressed text comes after the translated keyword, but isn't null terminated",
      "                const byte* compressedText = data.pData_ + keysize + 3 + languageTextSize + 1 + translatedKeyTextSize + 1;",
      "                long compressedTextSize    = data.size_ - (keysize + 3 + languageTextSize + 1 + translatedKeyTextSize + 1);",
      "",
      "                zlibUncompress(compressedText, compressedTextSize, arr);",
      "            }",
      "            else",
      "            {"
    ],
    "added_lines": [
      "            enforce(data.size_ >= Safe::add(keysize, 2), Exiv2::kerCorruptedMetadata);",
      "",
      "            enforce(compressedTextSize < data.size_, kerCorruptedMetadata);",
      "            enforce(data.size_ >= Safe::add(keysize, 1), Exiv2::kerCorruptedMetadata);",
      "            enforce(data.size_ >= Safe::add(keysize, 3), Exiv2::kerCorruptedMetadata);",
      "            const size_t languageTextMaxSize = data.size_ - keysize - 3;",
      "            std::string languageText =",
      "                string_from_unterminated((const char*)(data.pData_ + Safe::add(keysize, 3)), languageTextMaxSize);",
      "            const unsigned int languageTextSize = static_cast<unsigned int>(languageText.size());",
      "",
      "            enforce(data.size_ >= Safe::add(static_cast<unsigned int>(Safe::add(keysize, 4)), languageTextSize),",
      "                    Exiv2::kerCorruptedMetadata);",
      "            std::string translatedKeyText =",
      "                string_from_unterminated((const char*)(data.pData_ + keysize + 3 + languageTextSize + 1),",
      "                                         data.size_ - (keysize + 3 + languageTextSize + 1));",
      "            const unsigned int translatedKeyTextSize = static_cast<unsigned int>(translatedKeyText.size());",
      "            if ((compressionFlag == 0x00) || (compressionFlag == 0x01 && compressionMethod == 0x00)) {",
      "                enforce(Safe::add(static_cast<unsigned int>(keysize + 3 + languageTextSize + 1),",
      "                                  Safe::add(translatedKeyTextSize, 1u)) <= data.size_,",
      "                        Exiv2::kerCorruptedMetadata);",
      "",
      "                const byte* text = data.pData_ + keysize + 3 + languageTextSize + 1 + translatedKeyTextSize + 1;",
      "                const long textsize = data.size_ - (keysize + 3 + languageTextSize + 1 + translatedKeyTextSize + 1);",
      "",
      "                if (compressionFlag == 0x00) {",
      "                    // then it's an uncompressed iTXt chunk",
      "                    std::cout << \"Exiv2::PngChunk::parseTXTChunk: We found an uncompressed iTXt field\\n\";",
      "                    arr.alloc(textsize);",
      "                    arr = DataBuf(text, textsize);",
      "                } else if (compressionFlag == 0x01 && compressionMethod == 0x00) {",
      "                    // then it's a zlib compressed iTXt chunk",
      "                    std::cout << \"Exiv2::PngChunk::parseTXTChunk: We found a zlib compressed iTXt field\\n\";",
      "                    // the compressed text comes after the translated keyword, but isn't null terminated",
      "                    zlibUncompress(text, textsize, arr);",
      "                }",
      "            } else {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/Exiv2/exiv2/pull/407",
  "description": {
    "pr_info": {
      "title": "Fix issue #400",
      "number": 407
    },
    "comment": [
      "The reproducers from #400 were triggering buffer overreads due to the function `PngChunk::parseTXTChunk()` not properly checking whether the extracted string lengths are correct. This PR fixes these issues and also adds a bunch of additional checks against potential overflows.",
      "# [Codecov](https://codecov.io/gh/Exiv2/exiv2/pull/407?src=pr&el=h1) Report\n> Merging [#407](https://codecov.io/gh/Exiv2/exiv2/pull/407?src=pr&el=desc) into [master](https://codecov.io/gh/Exiv2/exiv2/commit/2540981aae263236b39f5a59fbe189c4fbb33731?src=pr&el=desc) will **increase** coverage by `0.01%`.\n> The diff coverage is `100%`.\n\n[![Impacted file tree graph](https://codecov.io/gh/Exiv2/exiv2/pull/407/graphs/tree.svg?width=650&token=O9G7Iswx26&height=150&src=pr)](https://codecov.io/gh/Exiv2/exiv2/pull/407?src=pr&el=tree)\n\n```diff\n@@            Coverage Diff             @@\n##           master     #407      +/-   ##\n==========================================\n+ Coverage   53.92%   53.94%   +0.01%     \n==========================================\n  Files         173      173              \n  Lines       26635    26643       +8     \n==========================================\n+ Hits        14364    14372       +8     \n  Misses      12271    12271\n```\n\n\n| [Impacted Files](https://codecov.io/gh/Exiv2/exiv2/pull/407?src=pr&el=tree) | Coverage Δ | |\n|---|---|---|\n| [src/helper\\_functions.cpp](https://codecov.io/gh/Exiv2/exiv2/pull/407/diff?src=pr&el=tree#diff-c3JjL2hlbHBlcl9mdW5jdGlvbnMuY3Bw) | `100% <100%> (ø)` | :arrow_up: |\n| [src/pngchunk\\_int.cpp](https://codecov.io/gh/Exiv2/exiv2/pull/407/diff?src=pr&el=tree#diff-c3JjL3BuZ2NodW5rX2ludC5jcHA=) | `85.08% <100%> (+0.56%)` | :arrow_up: |\n\n------\n\n[Continue to review full report at Codecov](https://codecov.io/gh/Exiv2/exiv2/pull/407?src=pr&el=continue).\n> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)\n> `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`\n> Powered by [Codecov](https://codecov.io/gh/Exiv2/exiv2/pull/407?src=pr&el=footer). Last update [2540981...dadd1d1](https://codecov.io/gh/Exiv2/exiv2/pull/407?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "The patch introduces several enforce() calls and uses string_from_unterminated() to prevent buffer overreads and overflow, fixing the reported CVE. \n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0  \n\nThe changes align perfectly with addressing buffer overflow and overread security issues."
}