{
  "cve_id": "CVE-2018-14046",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "Exiv2/exiv2",
  "commit_msg": "[webp] Enforce minimum read size in decodeChunks\n\nThe size parameter is only checked for upper bounds, but not for lower.\nIf it is too small, then created dataBuf will be too small and overflow in one\nof the subsequent memcpy() calls.\n\nThis fixes #378 / CVE-2018-14046",
  "commit_hash": "81b6d36c90ed36a1c878171f0794f632f2ee5a78",
  "git_url": "https://github.com/Exiv2/exiv2/commit/81b6d36c90ed36a1c878171f0794f632f2ee5a78",
  "file_path": "src/webpimage.cpp",
  "func_name": "WebPImage::decodeChunks",
  "func_before": "void WebPImage::decodeChunks(uint64_t filesize)\n    {\n        DataBuf   chunkId(5);\n        byte      size_buff[WEBP_TAG_SIZE];\n        bool      has_canvas_data = false;\n\n#ifdef DEBUG\n        std::cout << \"Reading metadata\" << std::endl;\n#endif\n\n        chunkId.pData_[4] = '\\0' ;\n        while ( !io_->eof() && (uint64_t) io_->tell() < filesize) {\n            io_->read(chunkId.pData_, WEBP_TAG_SIZE);\n            io_->read(size_buff, WEBP_TAG_SIZE);\n            const uint32_t size = Exiv2::getULong(size_buff, littleEndian);\n            enforce(size <= (filesize - io_->tell()), Exiv2::kerCorruptedMetadata);\n\n            DataBuf payload(size);\n\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8X) && !has_canvas_data) {\n                has_canvas_data = true;\n                byte size_buf[WEBP_TAG_SIZE];\n\n                io_->read(payload.pData_, payload.size_);\n\n                // Fetch width\n                memcpy(&size_buf, &payload.pData_[4], 3);\n                size_buf[3] = 0;\n                pixelWidth_ = Exiv2::getULong(size_buf, littleEndian) + 1;\n\n                // Fetch height\n                memcpy(&size_buf, &payload.pData_[7], 3);\n                size_buf[3] = 0;\n                pixelHeight_ = Exiv2::getULong(size_buf, littleEndian) + 1;\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8) && !has_canvas_data) {\n                has_canvas_data = true;\n                io_->read(payload.pData_, payload.size_);\n                byte size_buf[WEBP_TAG_SIZE];\n\n                // Fetch width\"\"\n                memcpy(&size_buf, &payload.pData_[6], 2);\n                size_buf[2] = 0;\n                size_buf[3] = 0;\n                pixelWidth_ = Exiv2::getULong(size_buf, littleEndian) & 0x3fff;\n\n                // Fetch height\n                memcpy(&size_buf, &payload.pData_[8], 2);\n                size_buf[2] = 0;\n                size_buf[3] = 0;\n                pixelHeight_ = Exiv2::getULong(size_buf, littleEndian) & 0x3fff;\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8L) && !has_canvas_data) {\n                has_canvas_data = true;\n                byte size_buf_w[2];\n                byte size_buf_h[3];\n\n                io_->read(payload.pData_, payload.size_);\n\n                // Fetch width\n                memcpy(&size_buf_w, &payload.pData_[1], 2);\n                size_buf_w[1] &= 0x3F;\n                pixelWidth_ = Exiv2::getUShort(size_buf_w, littleEndian) + 1;\n\n                // Fetch height\n                memcpy(&size_buf_h, &payload.pData_[2], 3);\n                size_buf_h[0] = ((size_buf_h[0] >> 6) & 0x3) | ((size_buf_h[1]  & 0x3F) << 0x2);\n                size_buf_h[1] = ((size_buf_h[1] >> 6) & 0x3) | ((size_buf_h[2] & 0xF) << 0x2);\n                pixelHeight_ = Exiv2::getUShort(size_buf_h, littleEndian) + 1;\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_ANMF) && !has_canvas_data) {\n                has_canvas_data = true;\n                byte size_buf[WEBP_TAG_SIZE];\n\n                io_->read(payload.pData_, payload.size_);\n\n                // Fetch width\n                memcpy(&size_buf, &payload.pData_[6], 3);\n                size_buf[3] = 0;\n                pixelWidth_ = Exiv2::getULong(size_buf, littleEndian) + 1;\n\n                // Fetch height\n                memcpy(&size_buf, &payload.pData_[9], 3);\n                size_buf[3] = 0;\n                pixelHeight_ = Exiv2::getULong(size_buf, littleEndian) + 1;\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_ICCP)) {\n                io_->read(payload.pData_, payload.size_);\n                this->setIccProfile(payload);\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_EXIF)) {\n                io_->read(payload.pData_, payload.size_);\n\n                byte  size_buff[2];\n                byte  exifLongHeader[]   = { 0xFF, 0x01, 0xFF, 0xE1 };\n                byte  exifShortHeader[]  = { 0x45, 0x78, 0x69, 0x66, 0x00, 0x00 };\n                byte  exifTiffLEHeader[] = { 0x49, 0x49, 0x2A };       // \"MM*\"\n                byte  exifTiffBEHeader[] = { 0x4D, 0x4D, 0x00, 0x2A }; // \"II\\0*\"\n                byte* rawExifData = NULL;\n                long  offset = 0;\n                bool  s_header = false;\n                bool  le_header = false;\n                bool  be_header = false;\n                long  pos = -1;\n\n                pos = getHeaderOffset (payload.pData_, payload.size_, (byte*)&exifLongHeader, 4);\n                if (pos == -1) {\n                    pos = getHeaderOffset (payload.pData_, payload.size_, (byte*)&exifLongHeader, 6);\n                    if (pos != -1) {\n                        s_header = true;\n                    }\n                }\n                if (pos == -1) {\n                    pos = getHeaderOffset (payload.pData_, payload.size_, (byte*)&exifTiffLEHeader, 3);\n                    if (pos != -1) {\n                        le_header = true;\n                    }\n                }\n                if (pos == -1) {\n                    pos = getHeaderOffset (payload.pData_, payload.size_, (byte*)&exifTiffBEHeader, 4);\n                    if (pos != -1) {\n                        be_header = true;\n                    }\n                }\n\n                if (s_header) {\n                    offset += 6;\n                }\n                if (be_header || le_header) {\n                    offset += 12;\n                }\n\n                const long size = payload.size_ + offset;\n                rawExifData = (byte*)malloc(size);\n\n                if (s_header) {\n                    us2Data(size_buff, (uint16_t) (size - 6), bigEndian);\n                    memcpy(rawExifData, (char*)&exifLongHeader, 4);\n                    memcpy(rawExifData + 4, (char*)&size_buff, 2);\n                }\n\n                if (be_header || le_header) {\n                    us2Data(size_buff, (uint16_t) (size - 6), bigEndian);\n                    memcpy(rawExifData, (char*)&exifLongHeader, 4);\n                    memcpy(rawExifData + 4, (char*)&size_buff, 2);\n                    memcpy(rawExifData + 6, (char*)&exifShortHeader, 6);\n                }\n\n                memcpy(rawExifData + offset, payload.pData_, payload.size_);\n\n#ifdef DEBUG\n                std::cout << \"Display Hex Dump [size:\" << (unsigned long)size << \"]\" << std::endl;\n                std::cout << Internal::binaryToHex(rawExifData, size);\n#endif\n\n                if (pos != -1) {\n                    XmpData  xmpData;\n                    ByteOrder bo = ExifParser::decode(exifData_,\n                                                      payload.pData_ + pos,\n                                                      payload.size_ - pos);\n                    setByteOrder(bo);\n                }\n                else\n                {\n#ifndef SUPPRESS_WARNINGS\n                    EXV_WARNING << \"Failed to decode Exif metadata.\" << std::endl;\n#endif\n                    exifData_.clear();\n                }\n\n                if (rawExifData) free(rawExifData);\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_XMP)) {\n                io_->read(payload.pData_, payload.size_);\n                xmpPacket_.assign(reinterpret_cast<char*>(payload.pData_), payload.size_);\n                if (xmpPacket_.size() > 0 && XmpParser::decode(xmpData_, xmpPacket_)) {\n#ifndef SUPPRESS_WARNINGS\n                    EXV_WARNING << \"Failed to decode XMP metadata.\" << std::endl;\n#endif\n                } else {\n#ifdef DEBUG\n                    std::cout << \"Display Hex Dump [size:\" << (unsigned long)payload.size_ << \"]\" << std::endl;\n                    std::cout << Internal::binaryToHex(payload.pData_, payload.size_);\n#endif\n                }\n            } else {\n                io_->seek(size, BasicIo::cur);\n            }\n\n            if ( io_->tell() % 2 ) io_->seek(+1, BasicIo::cur);\n        }\n    }",
  "abstract_func_before": "void WebPImage::decodeChunks(uint64_t VAR_0)\n    {\n        DataBuf   VAR_1(5);\n        byte      VAR_2[VAR_3];\n        bool      VAR_4 = false;\n\n#ifdef VAR_5\n        std::cout << \"Reading metadata\" << std::endl;\n#endif\n\n        VAR_1.pData_[4] = '\\0' ;\n        while ( !VAR_6->eof() && (uint64_t) VAR_6->tell() < VAR_0) {\n            VAR_6->read(VAR_1.pData_, VAR_3);\n            VAR_6->read(VAR_2, VAR_3);\n            const uint32_t VAR_7 = Exiv2::getULong(VAR_2, VAR_8);\n            enforce(VAR_7 <= (VAR_0 - VAR_6->tell()), Exiv2::kerCorruptedMetadata);\n\n            DataBuf payload(size);\n\n            if (equalsWebPTag(VAR_1, VAR_9) && !VAR_4) {\n                VAR_4 = true;\n                byte VAR_10[VAR_3];\n\n                VAR_6->read(VAR_11.pData_, VAR_11.size_);\n\n                /* COMMENT_0 */\n                memcpy(&VAR_10, &VAR_11.pData_[4], 3);\n                VAR_10[3] = 0;\n                VAR_12 = Exiv2::getULong(VAR_10, VAR_8) + 1;\n\n                /* COMMENT_1 */\n                memcpy(&VAR_10, &VAR_11.pData_[7], 3);\n                VAR_10[3] = 0;\n                VAR_13 = Exiv2::getULong(VAR_10, VAR_8) + 1;\n            } else if (equalsWebPTag(VAR_1, VAR_14) && !VAR_4) {\n                VAR_4 = true;\n                VAR_6->read(VAR_11.pData_, VAR_11.size_);\n                byte VAR_10[VAR_3];\n\n                /* COMMENT_2 */\n                memcpy(&VAR_10, &VAR_11.pData_[6], 2);\n                VAR_10[2] = 0;\n                VAR_10[3] = 0;\n                VAR_12 = Exiv2::getULong(VAR_10, VAR_8) & 0x3fff;\n\n                /* COMMENT_1 */\n                memcpy(&VAR_10, &VAR_11.pData_[8], 2);\n                VAR_10[2] = 0;\n                VAR_10[3] = 0;\n                VAR_13 = Exiv2::getULong(VAR_10, VAR_8) & 0x3fff;\n            } else if (equalsWebPTag(VAR_1, VAR_15) && !VAR_4) {\n                VAR_4 = true;\n                byte VAR_16[2];\n                byte VAR_17[3];\n\n                VAR_6->read(VAR_11.pData_, VAR_11.size_);\n\n                /* COMMENT_0 */\n                memcpy(&VAR_16, &VAR_11.pData_[1], 2);\n                VAR_16[1] &= 0x3F;\n                VAR_12 = Exiv2::getUShort(VAR_16, VAR_8) + 1;\n\n                /* COMMENT_1 */\n                memcpy(&VAR_17, &VAR_11.pData_[2], 3);\n                VAR_17[0] = ((VAR_17[0] >> 6) & 0x3) | ((VAR_17[1]  & 0x3F) << 0x2);\n                VAR_17[1] = ((VAR_17[1] >> 6) & 0x3) | ((VAR_17[2] & 0xF) << 0x2);\n                VAR_13 = Exiv2::getUShort(VAR_17, VAR_8) + 1;\n            } else if (equalsWebPTag(VAR_1, VAR_18) && !VAR_4) {\n                VAR_4 = true;\n                byte VAR_10[VAR_3];\n\n                VAR_6->read(VAR_11.pData_, VAR_11.size_);\n\n                /* COMMENT_0 */\n                memcpy(&VAR_10, &VAR_11.pData_[6], 3);\n                VAR_10[3] = 0;\n                VAR_12 = Exiv2::getULong(VAR_10, VAR_8) + 1;\n\n                /* COMMENT_1 */\n                memcpy(&VAR_10, &VAR_11.pData_[9], 3);\n                VAR_10[3] = 0;\n                VAR_13 = Exiv2::getULong(VAR_10, VAR_8) + 1;\n            } else if (equalsWebPTag(VAR_1, VAR_19)) {\n                VAR_6->read(VAR_11.pData_, VAR_11.size_);\n                this->setIccProfile(VAR_11);\n            } else if (equalsWebPTag(VAR_1, VAR_20)) {\n                VAR_6->read(VAR_11.pData_, VAR_11.size_);\n\n                byte  VAR_2[2];\n                byte  VAR_21[]   = { 0xFF, 0x01, 0xFF, 0xE1 };\n                byte  VAR_22[]  = { 0x45, 0x78, 0x69, 0x66, 0x00, 0x00 };\n                byte  VAR_23[] = { 0x49, 0x49, 0x2A };       /* COMMENT_3 */\n                byte  VAR_24[] = { 0x4D, 0x4D, 0x00, 0x2A }; /* COMMENT_4 */\n                byte* VAR_25 = NULL;\n                long  VAR_26 = 0;\n                bool  VAR_27 = false;\n                bool  VAR_28 = false;\n                bool  VAR_29 = false;\n                long  VAR_30 = -1;\n\n                VAR_30 = getHeaderOffset (VAR_11.pData_, VAR_11.size_, (byte*)&VAR_21, 4);\n                if (VAR_30 == -1) {\n                    VAR_30 = getHeaderOffset (VAR_11.pData_, VAR_11.size_, (byte*)&VAR_21, 6);\n                    if (VAR_30 != -1) {\n                        VAR_27 = true;\n                    }\n                }\n                if (VAR_30 == -1) {\n                    VAR_30 = getHeaderOffset (VAR_11.pData_, VAR_11.size_, (byte*)&VAR_23, 3);\n                    if (VAR_30 != -1) {\n                        VAR_28 = true;\n                    }\n                }\n                if (VAR_30 == -1) {\n                    VAR_30 = getHeaderOffset (VAR_11.pData_, VAR_11.size_, (byte*)&VAR_24, 4);\n                    if (VAR_30 != -1) {\n                        VAR_29 = true;\n                    }\n                }\n\n                if (VAR_27) {\n                    VAR_26 += 6;\n                }\n                if (VAR_29 || VAR_28) {\n                    VAR_26 += 12;\n                }\n\n                const long size = VAR_11.size_ + VAR_26;\n                VAR_25 = (byte*)malloc(size);\n\n                if (VAR_27) {\n                    us2Data(VAR_2, (uint16_t) (size - 6), VAR_31);\n                    memcpy(VAR_25, (char*)&VAR_21, 4);\n                    memcpy(VAR_25 + 4, (char*)&VAR_2, 2);\n                }\n\n                if (VAR_29 || VAR_28) {\n                    us2Data(VAR_2, (uint16_t) (size - 6), VAR_31);\n                    memcpy(VAR_25, (char*)&VAR_21, 4);\n                    memcpy(VAR_25 + 4, (char*)&VAR_2, 2);\n                    memcpy(VAR_25 + 6, (char*)&VAR_22, 6);\n                }\n\n                memcpy(VAR_25 + VAR_26, VAR_11.pData_, VAR_11.size_);\n\n#ifdef VAR_5\n                std::cout << \"Display Hex Dump [size:\" << (unsigned long)size << \"]\" << std::endl;\n                std::cout << Internal::binaryToHex(VAR_25, size);\n#endif\n\n                if (VAR_30 != -1) {\n                    XmpData  VAR_32;\n                    ByteOrder VAR_33 = ExifParser::decode(VAR_34,\n                                                      VAR_11.pData_ + VAR_30,\n                                                      VAR_11.size_ - VAR_30);\n                    setByteOrder(VAR_33);\n                }\n                else\n                {\n#ifndef VAR_35\n                    VAR_36 << \"Failed to decode Exif metadata.\" << std::endl;\n#endif\n                    VAR_34.clear();\n                }\n\n                if (VAR_25) free(VAR_25);\n            } else if (equalsWebPTag(VAR_1, VAR_37)) {\n                VAR_6->read(VAR_11.pData_, VAR_11.size_);\n                VAR_38.assign(VAR_39<char*>(VAR_11.pData_), VAR_11.size_);\n                if (VAR_38.size() > 0 && XmpParser::decode(VAR_40, VAR_38)) {\n#ifndef VAR_35\n                    VAR_36 << \"Failed to decode XMP metadata.\" << std::endl;\n#endif\n                } else {\n#ifdef VAR_5\n                    std::cout << \"Display Hex Dump [size:\" << (unsigned long)VAR_11.size_ << \"]\" << std::endl;\n                    std::cout << Internal::binaryToHex(VAR_11.pData_, VAR_11.size_);\n#endif\n                }\n            } else {\n                VAR_6->seek(size, BasicIo::cur);\n            }\n\n            if ( VAR_6->tell() % 2 ) VAR_6->seek(+1, BasicIo::cur);\n        }\n    }",
  "func_graph_path_before": "Exiv2/exiv2/81b6d36c90ed36a1c878171f0794f632f2ee5a78/webpimage.cpp/vul/before/0.json",
  "func": "void WebPImage::decodeChunks(uint64_t filesize)\n    {\n        DataBuf   chunkId(5);\n        byte      size_buff[WEBP_TAG_SIZE];\n        bool      has_canvas_data = false;\n\n#ifdef DEBUG\n        std::cout << \"Reading metadata\" << std::endl;\n#endif\n\n        chunkId.pData_[4] = '\\0' ;\n        while ( !io_->eof() && (uint64_t) io_->tell() < filesize) {\n            io_->read(chunkId.pData_, WEBP_TAG_SIZE);\n            io_->read(size_buff, WEBP_TAG_SIZE);\n            const uint32_t size = Exiv2::getULong(size_buff, littleEndian);\n            enforce(size <= (filesize - io_->tell()), Exiv2::kerCorruptedMetadata);\n\n            DataBuf payload(size);\n\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8X) && !has_canvas_data) {\n                enforce(size >= 10, Exiv2::kerCorruptedMetadata);\n\n                has_canvas_data = true;\n                byte size_buf[WEBP_TAG_SIZE];\n\n                io_->read(payload.pData_, payload.size_);\n\n                // Fetch width\n                memcpy(&size_buf, &payload.pData_[4], 3);\n                size_buf[3] = 0;\n                pixelWidth_ = Exiv2::getULong(size_buf, littleEndian) + 1;\n\n                // Fetch height\n                memcpy(&size_buf, &payload.pData_[7], 3);\n                size_buf[3] = 0;\n                pixelHeight_ = Exiv2::getULong(size_buf, littleEndian) + 1;\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8) && !has_canvas_data) {\n                enforce(size >= 10, Exiv2::kerCorruptedMetadata);\n\n                has_canvas_data = true;\n                io_->read(payload.pData_, payload.size_);\n                byte size_buf[WEBP_TAG_SIZE];\n\n                // Fetch width\"\"\n                memcpy(&size_buf, &payload.pData_[6], 2);\n                size_buf[2] = 0;\n                size_buf[3] = 0;\n                pixelWidth_ = Exiv2::getULong(size_buf, littleEndian) & 0x3fff;\n\n                // Fetch height\n                memcpy(&size_buf, &payload.pData_[8], 2);\n                size_buf[2] = 0;\n                size_buf[3] = 0;\n                pixelHeight_ = Exiv2::getULong(size_buf, littleEndian) & 0x3fff;\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8L) && !has_canvas_data) {\n                enforce(size >= 5, Exiv2::kerCorruptedMetadata);\n\n                has_canvas_data = true;\n                byte size_buf_w[2];\n                byte size_buf_h[3];\n\n                io_->read(payload.pData_, payload.size_);\n\n                // Fetch width\n                memcpy(&size_buf_w, &payload.pData_[1], 2);\n                size_buf_w[1] &= 0x3F;\n                pixelWidth_ = Exiv2::getUShort(size_buf_w, littleEndian) + 1;\n\n                // Fetch height\n                memcpy(&size_buf_h, &payload.pData_[2], 3);\n                size_buf_h[0] = ((size_buf_h[0] >> 6) & 0x3) | ((size_buf_h[1]  & 0x3F) << 0x2);\n                size_buf_h[1] = ((size_buf_h[1] >> 6) & 0x3) | ((size_buf_h[2] & 0xF) << 0x2);\n                pixelHeight_ = Exiv2::getUShort(size_buf_h, littleEndian) + 1;\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_ANMF) && !has_canvas_data) {\n                enforce(size >= 12, Exiv2::kerCorruptedMetadata);\n\n                has_canvas_data = true;\n                byte size_buf[WEBP_TAG_SIZE];\n\n                io_->read(payload.pData_, payload.size_);\n\n                // Fetch width\n                memcpy(&size_buf, &payload.pData_[6], 3);\n                size_buf[3] = 0;\n                pixelWidth_ = Exiv2::getULong(size_buf, littleEndian) + 1;\n\n                // Fetch height\n                memcpy(&size_buf, &payload.pData_[9], 3);\n                size_buf[3] = 0;\n                pixelHeight_ = Exiv2::getULong(size_buf, littleEndian) + 1;\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_ICCP)) {\n                io_->read(payload.pData_, payload.size_);\n                this->setIccProfile(payload);\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_EXIF)) {\n                io_->read(payload.pData_, payload.size_);\n\n                byte  size_buff[2];\n                byte  exifLongHeader[]   = { 0xFF, 0x01, 0xFF, 0xE1 };\n                byte  exifShortHeader[]  = { 0x45, 0x78, 0x69, 0x66, 0x00, 0x00 };\n                byte  exifTiffLEHeader[] = { 0x49, 0x49, 0x2A };       // \"MM*\"\n                byte  exifTiffBEHeader[] = { 0x4D, 0x4D, 0x00, 0x2A }; // \"II\\0*\"\n                byte* rawExifData = NULL;\n                long  offset = 0;\n                bool  s_header = false;\n                bool  le_header = false;\n                bool  be_header = false;\n                long  pos = -1;\n\n                pos = getHeaderOffset (payload.pData_, payload.size_, (byte*)&exifLongHeader, 4);\n                if (pos == -1) {\n                    pos = getHeaderOffset (payload.pData_, payload.size_, (byte*)&exifLongHeader, 6);\n                    if (pos != -1) {\n                        s_header = true;\n                    }\n                }\n                if (pos == -1) {\n                    pos = getHeaderOffset (payload.pData_, payload.size_, (byte*)&exifTiffLEHeader, 3);\n                    if (pos != -1) {\n                        le_header = true;\n                    }\n                }\n                if (pos == -1) {\n                    pos = getHeaderOffset (payload.pData_, payload.size_, (byte*)&exifTiffBEHeader, 4);\n                    if (pos != -1) {\n                        be_header = true;\n                    }\n                }\n\n                if (s_header) {\n                    offset += 6;\n                }\n                if (be_header || le_header) {\n                    offset += 12;\n                }\n\n                const long size = payload.size_ + offset;\n                rawExifData = (byte*)malloc(size);\n\n                if (s_header) {\n                    us2Data(size_buff, (uint16_t) (size - 6), bigEndian);\n                    memcpy(rawExifData, (char*)&exifLongHeader, 4);\n                    memcpy(rawExifData + 4, (char*)&size_buff, 2);\n                }\n\n                if (be_header || le_header) {\n                    us2Data(size_buff, (uint16_t) (size - 6), bigEndian);\n                    memcpy(rawExifData, (char*)&exifLongHeader, 4);\n                    memcpy(rawExifData + 4, (char*)&size_buff, 2);\n                    memcpy(rawExifData + 6, (char*)&exifShortHeader, 6);\n                }\n\n                memcpy(rawExifData + offset, payload.pData_, payload.size_);\n\n#ifdef DEBUG\n                std::cout << \"Display Hex Dump [size:\" << (unsigned long)size << \"]\" << std::endl;\n                std::cout << Internal::binaryToHex(rawExifData, size);\n#endif\n\n                if (pos != -1) {\n                    XmpData  xmpData;\n                    ByteOrder bo = ExifParser::decode(exifData_,\n                                                      payload.pData_ + pos,\n                                                      payload.size_ - pos);\n                    setByteOrder(bo);\n                }\n                else\n                {\n#ifndef SUPPRESS_WARNINGS\n                    EXV_WARNING << \"Failed to decode Exif metadata.\" << std::endl;\n#endif\n                    exifData_.clear();\n                }\n\n                if (rawExifData) free(rawExifData);\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_XMP)) {\n                io_->read(payload.pData_, payload.size_);\n                xmpPacket_.assign(reinterpret_cast<char*>(payload.pData_), payload.size_);\n                if (xmpPacket_.size() > 0 && XmpParser::decode(xmpData_, xmpPacket_)) {\n#ifndef SUPPRESS_WARNINGS\n                    EXV_WARNING << \"Failed to decode XMP metadata.\" << std::endl;\n#endif\n                } else {\n#ifdef DEBUG\n                    std::cout << \"Display Hex Dump [size:\" << (unsigned long)payload.size_ << \"]\" << std::endl;\n                    std::cout << Internal::binaryToHex(payload.pData_, payload.size_);\n#endif\n                }\n            } else {\n                io_->seek(size, BasicIo::cur);\n            }\n\n            if ( io_->tell() % 2 ) io_->seek(+1, BasicIo::cur);\n        }\n    }",
  "abstract_func": "void WebPImage::decodeChunks(uint64_t VAR_0)\n    {\n        DataBuf   VAR_1(5);\n        byte      VAR_2[VAR_3];\n        bool      VAR_4 = false;\n\n#ifdef VAR_5\n        std::cout << \"Reading metadata\" << std::endl;\n#endif\n\n        VAR_1.pData_[4] = '\\0' ;\n        while ( !VAR_6->eof() && (uint64_t) VAR_6->tell() < VAR_0) {\n            VAR_6->read(VAR_1.pData_, VAR_3);\n            VAR_6->read(VAR_2, VAR_3);\n            const uint32_t VAR_7 = Exiv2::getULong(VAR_2, VAR_8);\n            enforce(VAR_7 <= (VAR_0 - VAR_6->tell()), Exiv2::kerCorruptedMetadata);\n\n            DataBuf payload(size);\n\n            if (equalsWebPTag(VAR_1, VAR_9) && !VAR_4) {\n                enforce(size >= 10, Exiv2::kerCorruptedMetadata);\n\n                VAR_4 = true;\n                byte VAR_10[VAR_3];\n\n                VAR_6->read(VAR_11.pData_, VAR_11.size_);\n\n                /* COMMENT_0 */\n                memcpy(&VAR_10, &VAR_11.pData_[4], 3);\n                VAR_10[3] = 0;\n                VAR_12 = Exiv2::getULong(VAR_10, VAR_8) + 1;\n\n                /* COMMENT_1 */\n                memcpy(&VAR_10, &VAR_11.pData_[7], 3);\n                VAR_10[3] = 0;\n                VAR_13 = Exiv2::getULong(VAR_10, VAR_8) + 1;\n            } else if (equalsWebPTag(VAR_1, VAR_14) && !VAR_4) {\n                enforce(size >= 10, Exiv2::kerCorruptedMetadata);\n\n                VAR_4 = true;\n                VAR_6->read(VAR_11.pData_, VAR_11.size_);\n                byte VAR_10[VAR_3];\n\n                /* COMMENT_2 */\n                memcpy(&VAR_10, &VAR_11.pData_[6], 2);\n                VAR_10[2] = 0;\n                VAR_10[3] = 0;\n                VAR_12 = Exiv2::getULong(VAR_10, VAR_8) & 0x3fff;\n\n                /* COMMENT_1 */\n                memcpy(&VAR_10, &VAR_11.pData_[8], 2);\n                VAR_10[2] = 0;\n                VAR_10[3] = 0;\n                VAR_13 = Exiv2::getULong(VAR_10, VAR_8) & 0x3fff;\n            } else if (equalsWebPTag(VAR_1, VAR_15) && !VAR_4) {\n                enforce(size >= 5, Exiv2::kerCorruptedMetadata);\n\n                VAR_4 = true;\n                byte VAR_16[2];\n                byte VAR_17[3];\n\n                VAR_6->read(VAR_11.pData_, VAR_11.size_);\n\n                /* COMMENT_0 */\n                memcpy(&VAR_16, &VAR_11.pData_[1], 2);\n                VAR_16[1] &= 0x3F;\n                VAR_12 = Exiv2::getUShort(VAR_16, VAR_8) + 1;\n\n                /* COMMENT_1 */\n                memcpy(&VAR_17, &VAR_11.pData_[2], 3);\n                VAR_17[0] = ((VAR_17[0] >> 6) & 0x3) | ((VAR_17[1]  & 0x3F) << 0x2);\n                VAR_17[1] = ((VAR_17[1] >> 6) & 0x3) | ((VAR_17[2] & 0xF) << 0x2);\n                VAR_13 = Exiv2::getUShort(VAR_17, VAR_8) + 1;\n            } else if (equalsWebPTag(VAR_1, VAR_18) && !VAR_4) {\n                enforce(size >= 12, Exiv2::kerCorruptedMetadata);\n\n                VAR_4 = true;\n                byte VAR_10[VAR_3];\n\n                VAR_6->read(VAR_11.pData_, VAR_11.size_);\n\n                /* COMMENT_0 */\n                memcpy(&VAR_10, &VAR_11.pData_[6], 3);\n                VAR_10[3] = 0;\n                VAR_12 = Exiv2::getULong(VAR_10, VAR_8) + 1;\n\n                /* COMMENT_1 */\n                memcpy(&VAR_10, &VAR_11.pData_[9], 3);\n                VAR_10[3] = 0;\n                VAR_13 = Exiv2::getULong(VAR_10, VAR_8) + 1;\n            } else if (equalsWebPTag(VAR_1, VAR_19)) {\n                VAR_6->read(VAR_11.pData_, VAR_11.size_);\n                this->setIccProfile(VAR_11);\n            } else if (equalsWebPTag(VAR_1, VAR_20)) {\n                VAR_6->read(VAR_11.pData_, VAR_11.size_);\n\n                byte  VAR_2[2];\n                byte  VAR_21[]   = { 0xFF, 0x01, 0xFF, 0xE1 };\n                byte  VAR_22[]  = { 0x45, 0x78, 0x69, 0x66, 0x00, 0x00 };\n                byte  VAR_23[] = { 0x49, 0x49, 0x2A };       /* COMMENT_3 */\n                byte  VAR_24[] = { 0x4D, 0x4D, 0x00, 0x2A }; /* COMMENT_4 */\n                byte* VAR_25 = NULL;\n                long  VAR_26 = 0;\n                bool  VAR_27 = false;\n                bool  VAR_28 = false;\n                bool  VAR_29 = false;\n                long  VAR_30 = -1;\n\n                VAR_30 = getHeaderOffset (VAR_11.pData_, VAR_11.size_, (byte*)&VAR_21, 4);\n                if (VAR_30 == -1) {\n                    VAR_30 = getHeaderOffset (VAR_11.pData_, VAR_11.size_, (byte*)&VAR_21, 6);\n                    if (VAR_30 != -1) {\n                        VAR_27 = true;\n                    }\n                }\n                if (VAR_30 == -1) {\n                    VAR_30 = getHeaderOffset (VAR_11.pData_, VAR_11.size_, (byte*)&VAR_23, 3);\n                    if (VAR_30 != -1) {\n                        VAR_28 = true;\n                    }\n                }\n                if (VAR_30 == -1) {\n                    VAR_30 = getHeaderOffset (VAR_11.pData_, VAR_11.size_, (byte*)&VAR_24, 4);\n                    if (VAR_30 != -1) {\n                        VAR_29 = true;\n                    }\n                }\n\n                if (VAR_27) {\n                    VAR_26 += 6;\n                }\n                if (VAR_29 || VAR_28) {\n                    VAR_26 += 12;\n                }\n\n                const long size = VAR_11.size_ + VAR_26;\n                VAR_25 = (byte*)malloc(size);\n\n                if (VAR_27) {\n                    us2Data(VAR_2, (uint16_t) (size - 6), VAR_31);\n                    memcpy(VAR_25, (char*)&VAR_21, 4);\n                    memcpy(VAR_25 + 4, (char*)&VAR_2, 2);\n                }\n\n                if (VAR_29 || VAR_28) {\n                    us2Data(VAR_2, (uint16_t) (size - 6), VAR_31);\n                    memcpy(VAR_25, (char*)&VAR_21, 4);\n                    memcpy(VAR_25 + 4, (char*)&VAR_2, 2);\n                    memcpy(VAR_25 + 6, (char*)&VAR_22, 6);\n                }\n\n                memcpy(VAR_25 + VAR_26, VAR_11.pData_, VAR_11.size_);\n\n#ifdef VAR_5\n                std::cout << \"Display Hex Dump [size:\" << (unsigned long)size << \"]\" << std::endl;\n                std::cout << Internal::binaryToHex(VAR_25, size);\n#endif\n\n                if (VAR_30 != -1) {\n                    XmpData  VAR_32;\n                    ByteOrder VAR_33 = ExifParser::decode(VAR_34,\n                                                      VAR_11.pData_ + VAR_30,\n                                                      VAR_11.size_ - VAR_30);\n                    setByteOrder(VAR_33);\n                }\n                else\n                {\n#ifndef VAR_35\n                    VAR_36 << \"Failed to decode Exif metadata.\" << std::endl;\n#endif\n                    VAR_34.clear();\n                }\n\n                if (VAR_25) free(VAR_25);\n            } else if (equalsWebPTag(VAR_1, VAR_37)) {\n                VAR_6->read(VAR_11.pData_, VAR_11.size_);\n                VAR_38.assign(VAR_39<char*>(VAR_11.pData_), VAR_11.size_);\n                if (VAR_38.size() > 0 && XmpParser::decode(VAR_40, VAR_38)) {\n#ifndef VAR_35\n                    VAR_36 << \"Failed to decode XMP metadata.\" << std::endl;\n#endif\n                } else {\n#ifdef VAR_5\n                    std::cout << \"Display Hex Dump [size:\" << (unsigned long)VAR_11.size_ << \"]\" << std::endl;\n                    std::cout << Internal::binaryToHex(VAR_11.pData_, VAR_11.size_);\n#endif\n                }\n            } else {\n                VAR_6->seek(size, BasicIo::cur);\n            }\n\n            if ( VAR_6->tell() % 2 ) VAR_6->seek(+1, BasicIo::cur);\n        }\n    }",
  "func_graph_path": "Exiv2/exiv2/81b6d36c90ed36a1c878171f0794f632f2ee5a78/webpimage.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -18,6 +18,8 @@\n             DataBuf payload(size);\n \n             if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8X) && !has_canvas_data) {\n+                enforce(size >= 10, Exiv2::kerCorruptedMetadata);\n+\n                 has_canvas_data = true;\n                 byte size_buf[WEBP_TAG_SIZE];\n \n@@ -33,6 +35,8 @@\n                 size_buf[3] = 0;\n                 pixelHeight_ = Exiv2::getULong(size_buf, littleEndian) + 1;\n             } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8) && !has_canvas_data) {\n+                enforce(size >= 10, Exiv2::kerCorruptedMetadata);\n+\n                 has_canvas_data = true;\n                 io_->read(payload.pData_, payload.size_);\n                 byte size_buf[WEBP_TAG_SIZE];\n@@ -49,6 +53,8 @@\n                 size_buf[3] = 0;\n                 pixelHeight_ = Exiv2::getULong(size_buf, littleEndian) & 0x3fff;\n             } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8L) && !has_canvas_data) {\n+                enforce(size >= 5, Exiv2::kerCorruptedMetadata);\n+\n                 has_canvas_data = true;\n                 byte size_buf_w[2];\n                 byte size_buf_h[3];\n@@ -66,6 +72,8 @@\n                 size_buf_h[1] = ((size_buf_h[1] >> 6) & 0x3) | ((size_buf_h[2] & 0xF) << 0x2);\n                 pixelHeight_ = Exiv2::getUShort(size_buf_h, littleEndian) + 1;\n             } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_ANMF) && !has_canvas_data) {\n+                enforce(size >= 12, Exiv2::kerCorruptedMetadata);\n+\n                 has_canvas_data = true;\n                 byte size_buf[WEBP_TAG_SIZE];\n ",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "                enforce(size >= 10, Exiv2::kerCorruptedMetadata);",
      "",
      "                enforce(size >= 10, Exiv2::kerCorruptedMetadata);",
      "",
      "                enforce(size >= 5, Exiv2::kerCorruptedMetadata);",
      "",
      "                enforce(size >= 12, Exiv2::kerCorruptedMetadata);",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/Exiv2/exiv2/pull/379",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/Exiv2/exiv2/pull/379: 403 Client Error: Forbidden for url: https://api.github.com/repos/Exiv2/exiv2/pulls/379",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "The patch addresses a security vulnerability by enforcing minimum buffer sizes to prevent overflow, as indicated by the CVE reference and the code changes. \n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}