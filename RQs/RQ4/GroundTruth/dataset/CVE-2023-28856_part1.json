{
  "cve_id": "CVE-2023-28856",
  "cwe_ids": [
    "CWE-617"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "redis",
  "commit_msg": "fix hincrbyfloat not to create a key if the new value is invalid (#11149)\n\nCheck the validity of the value before performing the create operation,\r\nprevents new data from being generated even if the request fails to execute.\r\n\r\nCo-authored-by: Oran Agra <oran@redislabs.com>\r\nCo-authored-by: chendianqiang <chendianqiang@meituan.com>\r\nCo-authored-by: Binbin <binloveplay1314@qq.com>",
  "commit_hash": "bc7fe41e5857a0854d524e2a63a028e9394d2a5c",
  "git_url": "https://github.com/redis/redis/commit/bc7fe41e5857a0854d524e2a63a028e9394d2a5c",
  "file_path": "src/t_hash.c",
  "func_name": "hincrbyfloatCommand",
  "func_before": "void hincrbyfloatCommand(client *c) {\n    long double value, incr;\n    long long ll;\n    robj *o;\n    sds new;\n    unsigned char *vstr;\n    unsigned int vlen;\n\n    if (getLongDoubleFromObjectOrReply(c,c->argv[3],&incr,NULL) != C_OK) return;\n    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;\n    if (hashTypeGetValue(o,c->argv[2]->ptr,&vstr,&vlen,&ll) == C_OK) {\n        if (vstr) {\n            if (string2ld((char*)vstr,vlen,&value) == 0) {\n                addReplyError(c,\"hash value is not a float\");\n                return;\n            }\n        } else {\n            value = (long double)ll;\n        }\n    } else {\n        value = 0;\n    }\n\n    value += incr;\n    if (isnan(value) || isinf(value)) {\n        addReplyError(c,\"increment would produce NaN or Infinity\");\n        return;\n    }\n\n    char buf[MAX_LONG_DOUBLE_CHARS];\n    int len = ld2string(buf,sizeof(buf),value,LD_STR_HUMAN);\n    new = sdsnewlen(buf,len);\n    hashTypeSet(o,c->argv[2]->ptr,new,HASH_SET_TAKE_VALUE);\n    addReplyBulkCBuffer(c,buf,len);\n    signalModifiedKey(c,c->db,c->argv[1]);\n    notifyKeyspaceEvent(NOTIFY_HASH,\"hincrbyfloat\",c->argv[1],c->db->id);\n    server.dirty++;\n\n    /* Always replicate HINCRBYFLOAT as an HSET command with the final value\n     * in order to make sure that differences in float precision or formatting\n     * will not create differences in replicas or after an AOF restart. */\n    robj *newobj;\n    newobj = createRawStringObject(buf,len);\n    rewriteClientCommandArgument(c,0,shared.hset);\n    rewriteClientCommandArgument(c,3,newobj);\n    decrRefCount(newobj);\n}",
  "abstract_func_before": "void hincrbyfloatCommand(client *VAR_0) {\n    long double VAR_1, VAR_2;\n    long long VAR_3;\n    robj *VAR_4;\n    sds VAR_5;\n    unsigned char *VAR_6;\n    unsigned int VAR_7;\n\n    if (getLongDoubleFromObjectOrReply(VAR_0,VAR_0->argv[3],&VAR_2,NULL) != VAR_8) return;\n    if ((VAR_4 = hashTypeLookupWriteOrCreate(VAR_0,VAR_0->argv[1])) == NULL) return;\n    if (hashTypeGetValue(VAR_4,VAR_0->argv[2]->ptr,&VAR_6,&VAR_7,&VAR_3) == VAR_8) {\n        if (VAR_6) {\n            if (string2ld((char*)VAR_6,VAR_7,&VAR_1) == 0) {\n                addReplyError(VAR_0,\"hash value is not a float\");\n                return;\n            }\n        } else {\n            VAR_1 = (long double)VAR_3;\n        }\n    } else {\n        VAR_1 = 0;\n    }\n\n    VAR_1 += VAR_2;\n    if (isnan(VAR_1) || isinf(VAR_1)) {\n        addReplyError(VAR_0,\"increment would produce NaN or Infinity\");\n        return;\n    }\n\n    char VAR_9[VAR_10];\n    int VAR_11 = ld2string(VAR_9,sizeof(VAR_9),VAR_1,VAR_12);\n    VAR_5 = sdsnewlen(VAR_9,VAR_11);\n    hashTypeSet(VAR_4,VAR_0->argv[2]->ptr,VAR_5,VAR_13);\n    addReplyBulkCBuffer(VAR_0,VAR_9,VAR_11);\n    signalModifiedKey(VAR_0,VAR_0->db,VAR_0->argv[1]);\n    notifyKeyspaceEvent(VAR_14,\"hincrbyfloat\",VAR_0->argv[1],VAR_0->db->id);\n    VAR_15.dirty++;\n\n    /* COMMENT_0 */\n                                                                              \n                                                                          \n    robj *VAR_16;\n    VAR_16 = createRawStringObject(VAR_9,VAR_11);\n    rewriteClientCommandArgument(VAR_0,0,VAR_17.hset);\n    rewriteClientCommandArgument(VAR_0,3,VAR_16);\n    decrRefCount(VAR_16);\n}",
  "func_graph_path_before": "redis/bc7fe41e5857a0854d524e2a63a028e9394d2a5c/t_hash.c/vul/before/0.json",
  "func": "void hincrbyfloatCommand(client *c) {\n    long double value, incr;\n    long long ll;\n    robj *o;\n    sds new;\n    unsigned char *vstr;\n    unsigned int vlen;\n\n    if (getLongDoubleFromObjectOrReply(c,c->argv[3],&incr,NULL) != C_OK) return;\n    if (isnan(incr) || isinf(incr)) {\n        addReplyError(c,\"value is NaN or Infinity\");\n        return;\n    }\n    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;\n    if (hashTypeGetValue(o,c->argv[2]->ptr,&vstr,&vlen,&ll) == C_OK) {\n        if (vstr) {\n            if (string2ld((char*)vstr,vlen,&value) == 0) {\n                addReplyError(c,\"hash value is not a float\");\n                return;\n            }\n        } else {\n            value = (long double)ll;\n        }\n    } else {\n        value = 0;\n    }\n\n    value += incr;\n    if (isnan(value) || isinf(value)) {\n        addReplyError(c,\"increment would produce NaN or Infinity\");\n        return;\n    }\n\n    char buf[MAX_LONG_DOUBLE_CHARS];\n    int len = ld2string(buf,sizeof(buf),value,LD_STR_HUMAN);\n    new = sdsnewlen(buf,len);\n    hashTypeSet(o,c->argv[2]->ptr,new,HASH_SET_TAKE_VALUE);\n    addReplyBulkCBuffer(c,buf,len);\n    signalModifiedKey(c,c->db,c->argv[1]);\n    notifyKeyspaceEvent(NOTIFY_HASH,\"hincrbyfloat\",c->argv[1],c->db->id);\n    server.dirty++;\n\n    /* Always replicate HINCRBYFLOAT as an HSET command with the final value\n     * in order to make sure that differences in float precision or formatting\n     * will not create differences in replicas or after an AOF restart. */\n    robj *newobj;\n    newobj = createRawStringObject(buf,len);\n    rewriteClientCommandArgument(c,0,shared.hset);\n    rewriteClientCommandArgument(c,3,newobj);\n    decrRefCount(newobj);\n}",
  "abstract_func": "void hincrbyfloatCommand(client *VAR_0) {\n    long double VAR_1, VAR_2;\n    long long VAR_3;\n    robj *VAR_4;\n    sds VAR_5;\n    unsigned char *VAR_6;\n    unsigned int VAR_7;\n\n    if (getLongDoubleFromObjectOrReply(VAR_0,VAR_0->argv[3],&VAR_2,NULL) != VAR_8) return;\n    if (isnan(VAR_2) || isinf(VAR_2)) {\n        addReplyError(VAR_0,\"value is NaN or Infinity\");\n        return;\n    }\n    if ((VAR_4 = hashTypeLookupWriteOrCreate(VAR_0,VAR_0->argv[1])) == NULL) return;\n    if (hashTypeGetValue(VAR_4,VAR_0->argv[2]->ptr,&VAR_6,&VAR_7,&VAR_3) == VAR_8) {\n        if (VAR_6) {\n            if (string2ld((char*)VAR_6,VAR_7,&VAR_1) == 0) {\n                addReplyError(VAR_0,\"hash value is not a float\");\n                return;\n            }\n        } else {\n            VAR_1 = (long double)VAR_3;\n        }\n    } else {\n        VAR_1 = 0;\n    }\n\n    VAR_1 += VAR_2;\n    if (isnan(VAR_1) || isinf(VAR_1)) {\n        addReplyError(VAR_0,\"increment would produce NaN or Infinity\");\n        return;\n    }\n\n    char VAR_9[VAR_10];\n    int VAR_11 = ld2string(VAR_9,sizeof(VAR_9),VAR_1,VAR_12);\n    VAR_5 = sdsnewlen(VAR_9,VAR_11);\n    hashTypeSet(VAR_4,VAR_0->argv[2]->ptr,VAR_5,VAR_13);\n    addReplyBulkCBuffer(VAR_0,VAR_9,VAR_11);\n    signalModifiedKey(VAR_0,VAR_0->db,VAR_0->argv[1]);\n    notifyKeyspaceEvent(VAR_14,\"hincrbyfloat\",VAR_0->argv[1],VAR_0->db->id);\n    VAR_15.dirty++;\n\n    /* COMMENT_0 */\n                                                                              \n                                                                          \n    robj *VAR_16;\n    VAR_16 = createRawStringObject(VAR_9,VAR_11);\n    rewriteClientCommandArgument(VAR_0,0,VAR_17.hset);\n    rewriteClientCommandArgument(VAR_0,3,VAR_16);\n    decrRefCount(VAR_16);\n}",
  "func_graph_path": "redis/bc7fe41e5857a0854d524e2a63a028e9394d2a5c/t_hash.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -7,6 +7,10 @@\n     unsigned int vlen;\n \n     if (getLongDoubleFromObjectOrReply(c,c->argv[3],&incr,NULL) != C_OK) return;\n+    if (isnan(incr) || isinf(incr)) {\n+        addReplyError(c,\"value is NaN or Infinity\");\n+        return;\n+    }\n     if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;\n     if (hashTypeGetValue(o,c->argv[2]->ptr,&vstr,&vlen,&ll) == C_OK) {\n         if (vstr) {",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "    if (isnan(incr) || isinf(incr)) {",
      "        addReplyError(c,\"value is NaN or Infinity\");",
      "        return;",
      "    }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/redis/redis/pull/11149",
  "description": {
    "pr_info": {
      "title": "fix hincrbyfloat not to create a key if the new value is invalid",
      "number": 11149
    },
    "comment": [
      "Check the validity of the value before performing the create operation, prevents new data from being generated even if the request fails to execute.",
      "indeed. a detailed comment would help. @chendq8 please update.\r\nlooking at the test, i realize you found a bug in which a command can fail (return an error), but it could happen after already performing a medication to the database.\r\n\r\nhowever, i don't think i like the way to fixed it (changing hashTypeLookupWriteOrCreate to it's components).\r\nhow about just copying the `isnan` and `isinf` to the top?\r\ni.e. if the input isn't Inf or NaN, then adding 0 won't change it to be one of them.\r\nor in other words, the first check will check the input, and the second one will only be relevant if the key already exists.\r\n\r\nit does mean that we'll affect the error, e.g. cases that in the past would result with WRONGTYPE, will now be rejected with the NaN/Inf error, but i don't think that's an issue.",
      "> indeed. a detailed comment would help. @chendq8 please update. looking at the test, i realize you found a bug in which a command can fail (return an error), but it could happen after already performing a medication to the database.\r\n> \r\n> however, i don't think i like the way to fixed it (changing hashTypeLookupWriteOrCreate to it's components). how about just copying the `isnan` and `isinf` to the top? i.e. if the input isn't Inf or NaN, then adding 0 won't change it to be one of them. or in other words, the first check will check the input, and the second one will only be relevant if the key already exists.\r\n> \r\n> it does mean that we'll affect the error, e.g. cases that in the past would result with WRONGTYPE, will now be rejected with the NaN/Inf error, but i don't think that's an issue.\r\n\r\nThe implementation mode has been modified."
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.9"
}