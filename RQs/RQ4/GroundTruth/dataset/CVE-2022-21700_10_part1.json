{
  "cve_id": "CVE-2022-21700",
  "cwe_ids": [
    "CWE-400"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "micronaut-projects/micronaut-core",
  "commit_msg": "Use ConversionContext constants where possible instead of class (#2356)\n\nChanges\r\n-------\r\n * Added ArgumentConversionContext constants in ConversionContext\r\n * Replaced Argument.of and use of argument classes with\r\nConversionContext constants where possible\r\n * Added getFirst method in ConvertibleMultiValues that accepts\r\nArgumentConversionContent parameter\r\n\r\nPartially addresses issue #2355",
  "commit_hash": "b8ec32c311689667c69ae7d9f9c3b3a8abc96fe3",
  "git_url": "https://github.com/micronaut-projects/micronaut-core/commit/b8ec32c311689667c69ae7d9f9c3b3a8abc96fe3",
  "file_path": "http-server/src/main/java/io/micronaut/http/server/cors/CorsFilter.java",
  "func_name": "handleRequest",
  "func_before": "protected Optional<MutableHttpResponse<?>> handleRequest(HttpRequest request) {\n        HttpHeaders headers = request.getHeaders();\n        Optional<String> originHeader = headers.getOrigin();\n        if (originHeader.isPresent()) {\n\n            String requestOrigin = originHeader.get();\n            boolean preflight = CorsUtil.isPreflightRequest(request);\n\n            Optional<CorsOriginConfiguration> optionalConfig = getConfiguration(requestOrigin);\n\n            if (optionalConfig.isPresent()) {\n                CorsOriginConfiguration config = optionalConfig.get();\n\n                HttpMethod requestMethod = request.getMethod();\n\n                List<HttpMethod> allowedMethods = config.getAllowedMethods();\n\n                if (!isAnyMethod(allowedMethods)) {\n                    HttpMethod methodToMatch = preflight ? headers.getFirst(ACCESS_CONTROL_REQUEST_METHOD, HttpMethod.class).orElse(requestMethod) : requestMethod;\n                    if (allowedMethods.stream().noneMatch(method -> method.equals(methodToMatch))) {\n                        return Optional.of(HttpResponse.status(HttpStatus.FORBIDDEN));\n                    }\n                }\n\n                if (preflight) {\n                    Optional<List<String>> accessControlHeaders = headers.get(ACCESS_CONTROL_REQUEST_HEADERS, Argument.listOf(String.class));\n\n                    List<String> allowedHeaders = config.getAllowedHeaders();\n\n                    if (!isAny(allowedHeaders) && accessControlHeaders.isPresent()) {\n                        if (!accessControlHeaders.get().stream()\n                            .allMatch(header -> allowedHeaders.stream()\n                                .anyMatch(allowedHeader -> allowedHeader.equals(header.trim())))) {\n                            return Optional.of(HttpResponse.status(HttpStatus.FORBIDDEN));\n                        }\n                    }\n\n                    MutableHttpResponse<Object> ok = HttpResponse.ok();\n                    handleResponse(request, ok);\n                    return Optional.of(ok);\n                }\n            }\n        }\n\n        return Optional.empty();\n    }",
  "abstract_func_before": "protected Optional<MutableHttpResponse<?>> handleRequest(HttpRequest VAR_0) {\n        HttpHeaders VAR_1 = VAR_0.getHeaders();\n        Optional<String> VAR_2 = VAR_1.getOrigin();\n        if (VAR_2.isPresent()) {\n\n            String VAR_3 = VAR_2.get();\n            boolean VAR_4 = VAR_5.isPreflightRequest(VAR_0);\n\n            Optional<CorsOriginConfiguration> VAR_6 = getConfiguration(VAR_3);\n\n            if (VAR_6.isPresent()) {\n                CorsOriginConfiguration VAR_7 = VAR_6.get();\n\n                HttpMethod VAR_8 = VAR_0.getMethod();\n\n                List<HttpMethod> VAR_9 = VAR_7.getAllowedMethods();\n\n                if (!isAnyMethod(VAR_9)) {\n                    HttpMethod VAR_10 = VAR_4 ? VAR_1.getFirst(VAR_11, HttpMethod.class).orElse(VAR_8) : VAR_8;\n                    if (VAR_9.stream().noneMatch(VAR_12 -> VAR_12.equals(VAR_10))) {\n                        return VAR_13.of(VAR_14.status(VAR_15.FORBIDDEN));\n                    }\n                }\n\n                if (VAR_4) {\n                    Optional<List<String>> VAR_16 = VAR_1.get(VAR_17, VAR_18.listOf(String.class));\n\n                    List<String> VAR_19 = VAR_7.getAllowedHeaders();\n\n                    if (!isAny(VAR_19) && VAR_16.isPresent()) {\n                        if (!VAR_16.get().stream()\n                            .allMatch(VAR_20 -> VAR_19.stream()\n                                .anyMatch(VAR_21 -> VAR_21.equals(VAR_20.trim())))) {\n                            return VAR_13.of(VAR_14.status(VAR_15.FORBIDDEN));\n                        }\n                    }\n\n                    MutableHttpResponse<Object> VAR_22 = VAR_14.ok();\n                    handleResponse(VAR_0, VAR_22);\n                    return VAR_13.of(VAR_22);\n                }\n            }\n        }\n\n        return VAR_13.empty();\n    }",
  "func_graph_path_before": "micronaut-projects/micronaut-core/b8ec32c311689667c69ae7d9f9c3b3a8abc96fe3/CorsFilter.java/vul/before/0.json",
  "func": "protected Optional<MutableHttpResponse<?>> handleRequest(HttpRequest request) {\n        HttpHeaders headers = request.getHeaders();\n        Optional<String> originHeader = headers.getOrigin();\n        if (originHeader.isPresent()) {\n\n            String requestOrigin = originHeader.get();\n            boolean preflight = CorsUtil.isPreflightRequest(request);\n\n            Optional<CorsOriginConfiguration> optionalConfig = getConfiguration(requestOrigin);\n\n            if (optionalConfig.isPresent()) {\n                CorsOriginConfiguration config = optionalConfig.get();\n\n                HttpMethod requestMethod = request.getMethod();\n\n                List<HttpMethod> allowedMethods = config.getAllowedMethods();\n\n                if (!isAnyMethod(allowedMethods)) {\n                    HttpMethod methodToMatch = preflight ? headers.getFirst(ACCESS_CONTROL_REQUEST_METHOD, CONVERSION_CONTEXT_HTTP_METHOD).orElse(requestMethod) : requestMethod;\n                    if (allowedMethods.stream().noneMatch(method -> method.equals(methodToMatch))) {\n                        return Optional.of(HttpResponse.status(HttpStatus.FORBIDDEN));\n                    }\n                }\n\n                if (preflight) {\n                    Optional<List<String>> accessControlHeaders = headers.get(ACCESS_CONTROL_REQUEST_HEADERS, ConversionContext.LIST_OF_STRING);\n\n                    List<String> allowedHeaders = config.getAllowedHeaders();\n\n                    if (!isAny(allowedHeaders) && accessControlHeaders.isPresent()) {\n                        if (!accessControlHeaders.get().stream()\n                            .allMatch(header -> allowedHeaders.stream()\n                                .anyMatch(allowedHeader -> allowedHeader.equals(header.trim())))) {\n                            return Optional.of(HttpResponse.status(HttpStatus.FORBIDDEN));\n                        }\n                    }\n\n                    MutableHttpResponse<Object> ok = HttpResponse.ok();\n                    handleResponse(request, ok);\n                    return Optional.of(ok);\n                }\n            }\n        }\n\n        return Optional.empty();\n    }",
  "abstract_func": "protected Optional<MutableHttpResponse<?>> handleRequest(HttpRequest VAR_0) {\n        HttpHeaders VAR_1 = VAR_0.getHeaders();\n        Optional<String> VAR_2 = VAR_1.getOrigin();\n        if (VAR_2.isPresent()) {\n\n            String VAR_3 = VAR_2.get();\n            boolean VAR_4 = VAR_5.isPreflightRequest(VAR_0);\n\n            Optional<CorsOriginConfiguration> VAR_6 = getConfiguration(VAR_3);\n\n            if (VAR_6.isPresent()) {\n                CorsOriginConfiguration VAR_7 = VAR_6.get();\n\n                HttpMethod VAR_8 = VAR_0.getMethod();\n\n                List<HttpMethod> VAR_9 = VAR_7.getAllowedMethods();\n\n                if (!isAnyMethod(VAR_9)) {\n                    HttpMethod VAR_10 = VAR_4 ? VAR_1.getFirst(VAR_11, VAR_12).orElse(VAR_8) : VAR_8;\n                    if (VAR_9.stream().noneMatch(VAR_13 -> VAR_13.equals(VAR_10))) {\n                        return VAR_14.of(VAR_15.status(VAR_16.FORBIDDEN));\n                    }\n                }\n\n                if (VAR_4) {\n                    Optional<List<String>> VAR_17 = VAR_1.get(VAR_18, VAR_19.LIST_OF_STRING);\n\n                    List<String> VAR_20 = VAR_7.getAllowedHeaders();\n\n                    if (!isAny(VAR_20) && VAR_17.isPresent()) {\n                        if (!VAR_17.get().stream()\n                            .allMatch(VAR_21 -> VAR_20.stream()\n                                .anyMatch(VAR_22 -> VAR_22.equals(VAR_21.trim())))) {\n                            return VAR_14.of(VAR_15.status(VAR_16.FORBIDDEN));\n                        }\n                    }\n\n                    MutableHttpResponse<Object> VAR_23 = VAR_15.ok();\n                    handleResponse(VAR_0, VAR_23);\n                    return VAR_14.of(VAR_23);\n                }\n            }\n        }\n\n        return VAR_14.empty();\n    }",
  "func_graph_path": "micronaut-projects/micronaut-core/b8ec32c311689667c69ae7d9f9c3b3a8abc96fe3/CorsFilter.java/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -16,14 +16,14 @@\n                 List<HttpMethod> allowedMethods = config.getAllowedMethods();\n \n                 if (!isAnyMethod(allowedMethods)) {\n-                    HttpMethod methodToMatch = preflight ? headers.getFirst(ACCESS_CONTROL_REQUEST_METHOD, HttpMethod.class).orElse(requestMethod) : requestMethod;\n+                    HttpMethod methodToMatch = preflight ? headers.getFirst(ACCESS_CONTROL_REQUEST_METHOD, CONVERSION_CONTEXT_HTTP_METHOD).orElse(requestMethod) : requestMethod;\n                     if (allowedMethods.stream().noneMatch(method -> method.equals(methodToMatch))) {\n                         return Optional.of(HttpResponse.status(HttpStatus.FORBIDDEN));\n                     }\n                 }\n \n                 if (preflight) {\n-                    Optional<List<String>> accessControlHeaders = headers.get(ACCESS_CONTROL_REQUEST_HEADERS, Argument.listOf(String.class));\n+                    Optional<List<String>> accessControlHeaders = headers.get(ACCESS_CONTROL_REQUEST_HEADERS, ConversionContext.LIST_OF_STRING);\n \n                     List<String> allowedHeaders = config.getAllowedHeaders();\n ",
  "diff_line_info": {
    "deleted_lines": [
      "                    HttpMethod methodToMatch = preflight ? headers.getFirst(ACCESS_CONTROL_REQUEST_METHOD, HttpMethod.class).orElse(requestMethod) : requestMethod;",
      "                    Optional<List<String>> accessControlHeaders = headers.get(ACCESS_CONTROL_REQUEST_HEADERS, Argument.listOf(String.class));"
    ],
    "added_lines": [
      "                    HttpMethod methodToMatch = preflight ? headers.getFirst(ACCESS_CONTROL_REQUEST_METHOD, CONVERSION_CONTEXT_HTTP_METHOD).orElse(requestMethod) : requestMethod;",
      "                    Optional<List<String>> accessControlHeaders = headers.get(ACCESS_CONTROL_REQUEST_HEADERS, ConversionContext.LIST_OF_STRING);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/micronaut-projects/micronaut-core/pull/2356",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/micronaut-projects/micronaut-core/pull/2356: 403 Client Error: Forbidden for url: https://api.github.com/repos/micronaut-projects/micronaut-core/pulls/2356",
  "Bug Filter": "Supporting & Non-Core Improvements",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Supporting & Non-Core Improvements; **Confidence:** 1.0"
}