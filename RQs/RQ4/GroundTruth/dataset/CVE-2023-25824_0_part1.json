{
  "cve_id": "CVE-2023-25824",
  "cwe_ids": [
    "CWE-835"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "airtower-luna/mod_gnutls",
  "commit_msg": "Fix loop in blocking read on transport timeout\n\nThe loop was cased by an incorrect errno if the transport read in\nmgs_transport_read() fails with an APR TIMEUP status, as happens when\nmod_reqtimeout limits are exceeded. Setting the transport errno to\nEGAIN meant that a blocking read would be retried endlessly, setting\nETIMEDOUT instead makes the read fail as it should.\n\nThe bug was introduced in commit 92cb0cca41af946055307e373b6ab6d76d34f356,\nfirst release to include it was 0.9.0.\n\nMany thanks to Félix Arreola Rodríguez for the detailed analysis [1]\non the Debian bug tracker!\n\n[1] https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=942737#25",
  "commit_hash": "d7eec4e598158ab6a98bf505354e84352f9715ec",
  "git_url": "https://github.com/airtower-luna/mod_gnutls/commit/d7eec4e598158ab6a98bf505354e84352f9715ec",
  "file_path": "src/gnutls_io.c",
  "func_name": "gnutls_io_input_read",
  "func_before": "static apr_status_t gnutls_io_input_read(mgs_handle_t * ctxt,\n        char *buf, apr_size_t * len)\n{\n    apr_size_t wanted = *len;\n    apr_size_t bytes = 0;\n\n    *len = 0;\n\n    /* If we have something leftover from last time, try that first. */\n    if ((bytes = char_buffer_read(&ctxt->input_cbuf, buf, wanted))) {\n        *len = bytes;\n        if (ctxt->input_mode == AP_MODE_SPECULATIVE) {\n            /* We want to rollback this read. */\n            if (ctxt->input_cbuf.length > 0) {\n                ctxt->input_cbuf.value -= bytes;\n                ctxt->input_cbuf.length += bytes;\n            } else {\n                char_buffer_write(&ctxt->input_cbuf, buf,\n                        (int) bytes);\n            }\n            return APR_SUCCESS;\n        }\n        /* This could probably be *len == wanted, but be safe from stray\n         * photons.\n         */\n        if (*len >= wanted) {\n            return APR_SUCCESS;\n        }\n        if (ctxt->input_mode == AP_MODE_GETLINE) {\n            if (memchr(buf, APR_ASCII_LF, *len)) {\n                return APR_SUCCESS;\n            }\n        } else {\n            /* Down to a nonblock pattern as we have some data already\n             */\n            ctxt->input_block = APR_NONBLOCK_READ;\n        }\n    }\n\n    if (ctxt->session == NULL) {\n        ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, ctxt->c,\n                      \"%s: GnuTLS session is NULL!\", __func__);\n        return APR_EGENERAL;\n    }\n\n    while (1)\n    {\n        /* Note: The pull function sets ctxt->input_rc */\n        int rc = gnutls_record_recv(ctxt->session,\n                                    buf + bytes, wanted - bytes);\n\n        if (rc > 0) {\n            *len += rc;\n            if (ctxt->input_mode == AP_MODE_SPECULATIVE) {\n                /* We want to rollback this read. */\n                char_buffer_write(&ctxt->input_cbuf, buf,\n                                  *len);\n            }\n            return ctxt->input_rc;\n        } else if (rc == 0) {\n            /* EOF, return code depends on whether we still have data\n             * to return. */\n            if (*len > 0) {\n                ctxt->input_rc = APR_SUCCESS;\n            } else {\n                ctxt->input_rc = APR_EOF;\n            }\n            break;\n        } else { /* (rc < 0) */\n\n            if (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN)\n            {\n                ap_log_cerror(APLOG_MARK, APLOG_TRACE2, ctxt->input_rc, ctxt->c,\n                              \"%s: looping recv after '%s' (%d)\",\n                              __func__, gnutls_strerror(rc), rc);\n                /* For a blocking read, loop and try again\n                 * immediately. Otherwise just notify the caller. */\n                if (ctxt->input_block != APR_NONBLOCK_READ)\n                    continue;\n                else\n                    ctxt->input_rc =\n                        (rc == GNUTLS_E_AGAIN ? APR_EAGAIN : APR_EINTR);\n            } else if (rc == GNUTLS_E_REHANDSHAKE) {\n                /* A client has asked for a new Hankshake. Currently, we don't do it */\n                ap_log_cerror(APLOG_MARK, APLOG_DEBUG,\n                        ctxt->input_rc,\n                        ctxt->c,\n                        \"GnuTLS: Error reading data. Client Requested a New Handshake.\"\n                        \" (%d) '%s'\", rc,\n                        gnutls_strerror(rc));\n            } else if (rc == GNUTLS_E_WARNING_ALERT_RECEIVED) {\n                rc = gnutls_alert_get(ctxt->session);\n                ap_log_cerror(APLOG_MARK, APLOG_DEBUG,\n                        ctxt->input_rc,\n                        ctxt->c,\n                        \"GnuTLS: Warning Alert From Client: \"\n                        \" (%d) '%s'\", rc,\n                        gnutls_alert_get_name(rc));\n            } else if (rc == GNUTLS_E_FATAL_ALERT_RECEIVED) {\n                rc = gnutls_alert_get(ctxt->session);\n                ap_log_cerror(APLOG_MARK, APLOG_DEBUG,\n                        ctxt->input_rc,\n                        ctxt->c,\n                        \"GnuTLS: Fatal Alert From Client: \"\n                        \"(%d) '%s'\", rc,\n                        gnutls_alert_get_name(rc));\n                ctxt->input_rc = APR_EGENERAL;\n                break;\n            } else {\n                /* Some Other Error. Report it. Die. */\n                if (gnutls_error_is_fatal(rc)) {\n                    ap_log_cerror(\n                        APLOG_MARK, APLOG_DEBUG,\n                        ctxt->input_rc,\n                        ctxt->c,\n                        \"GnuTLS: Error reading data. (%d) '%s'\",\n                        rc, gnutls_strerror(rc));\n                } else if (*len > 0) {\n                    ctxt->input_rc = APR_SUCCESS;\n                    break;\n                }\n            }\n\n            if (ctxt->input_rc == APR_SUCCESS) {\n                ap_log_cerror(APLOG_MARK, APLOG_INFO, ctxt->input_rc, ctxt->c,\n                              \"%s: GnuTLS error: %s (%d)\",\n                              __func__, gnutls_strerror(rc), rc);\n                ctxt->input_rc = APR_EGENERAL;\n            }\n            break;\n        }\n    }\n    return ctxt->input_rc;\n}",
  "abstract_func_before": "static apr_status_t gnutls_io_input_read(mgs_handle_t * VAR_0,\n        char *VAR_1, apr_size_t * VAR_2)\n{\n    apr_size_t VAR_3 = *VAR_2;\n    apr_size_t VAR_4 = 0;\n\n    *VAR_2 = 0;\n\n    /* COMMENT_0 */\n    if ((VAR_4 = char_buffer_read(&VAR_0->input_cbuf, VAR_1, VAR_3))) {\n        *VAR_2 = VAR_4;\n        if (VAR_0->input_mode == VAR_5) {\n            /* COMMENT_1 */\n            if (VAR_0->input_cbuf.length > 0) {\n                VAR_0->input_cbuf.value -= VAR_4;\n                VAR_0->input_cbuf.length += VAR_4;\n            } else {\n                char_buffer_write(&VAR_0->input_cbuf, VAR_1,\n                        (int) VAR_4);\n            }\n            return VAR_6;\n        }\n        /* COMMENT_2 */\n                   \n           \n        if (*VAR_2 >= VAR_3) {\n            return VAR_6;\n        }\n        if (VAR_0->input_mode == VAR_7) {\n            if (memchr(VAR_1, VAR_8, *VAR_2)) {\n                return VAR_6;\n            }\n        } else {\n            /* COMMENT_5 */\n               \n            VAR_0->input_block = VAR_9;\n        }\n    }\n\n    if (VAR_0->session == NULL) {\n        ap_log_cerror(VAR_10, VAR_11, 0, VAR_0->c,\n                      \"%s: GnuTLS session is NULL!\", VAR_12);\n        return VAR_13;\n    }\n\n    while (1)\n    {\n        /* COMMENT_7 */\n        int VAR_14 = gnutls_record_recv(VAR_0->session,\n                                    VAR_1 + VAR_4, VAR_3 - VAR_4);\n\n        if (VAR_14 > 0) {\n            *VAR_2 += VAR_14;\n            if (VAR_0->input_mode == VAR_5) {\n                /* COMMENT_1 */\n                char_buffer_write(&VAR_0->input_cbuf, VAR_1,\n                                  *VAR_2);\n            }\n            return VAR_0->input_rc;\n        } else if (VAR_14 == 0) {\n            /* COMMENT_8 */\n                            \n            if (*VAR_2 > 0) {\n                VAR_0->input_rc = VAR_6;\n            } else {\n                VAR_0->input_rc = VAR_15;\n            }\n            break;\n        } else { /* COMMENT_10 */\n\n            if (VAR_14 == VAR_16 || VAR_14 == VAR_17)\n            {\n                ap_log_cerror(VAR_10, VAR_18, VAR_0->input_rc, VAR_0->c,\n                              \"%s: looping recv after '%s' (%d)\",\n                              VAR_12, gnutls_strerror(VAR_14), VAR_14);\n                /* COMMENT_11 */\n                                                                    \n                if (VAR_0->input_block != VAR_9)\n                    continue;\n                else\n                    VAR_0->input_rc =\n                        (VAR_14 == VAR_17 ? VAR_19 : VAR_20);\n            } else if (VAR_14 == VAR_21) {\n                /* COMMENT_13 */\n                ap_log_cerror(VAR_10, VAR_22,\n                        VAR_0->input_rc,\n                        VAR_0->c,\n                        \"GnuTLS: Error reading data. Client Requested a New Handshake.\"\n                        \" (%d) '%s'\", VAR_14,\n                        gnutls_strerror(VAR_14));\n            } else if (VAR_14 == VAR_23) {\n                VAR_14 = gnutls_alert_get(VAR_0->session);\n                ap_log_cerror(VAR_10, VAR_22,\n                        VAR_0->input_rc,\n                        VAR_0->c,\n                        \"GnuTLS: Warning Alert From Client: \"\n                        \" (%d) '%s'\", VAR_14,\n                        gnutls_alert_get_name(VAR_14));\n            } else if (VAR_14 == VAR_24) {\n                VAR_14 = gnutls_alert_get(VAR_0->session);\n                ap_log_cerror(VAR_10, VAR_22,\n                        VAR_0->input_rc,\n                        VAR_0->c,\n                        \"GnuTLS: Fatal Alert From Client: \"\n                        \"(%d) '%s'\", VAR_14,\n                        gnutls_alert_get_name(VAR_14));\n                VAR_0->input_rc = VAR_13;\n                break;\n            } else {\n                /* COMMENT_14 */\n                if (gnutls_error_is_fatal(VAR_14)) {\n                    ap_log_cerror(\n                        VAR_10, VAR_22,\n                        VAR_0->input_rc,\n                        VAR_0->c,\n                        \"GnuTLS: Error reading data. (%d) '%s'\",\n                        VAR_14, gnutls_strerror(VAR_14));\n                } else if (*VAR_2 > 0) {\n                    VAR_0->input_rc = VAR_6;\n                    break;\n                }\n            }\n\n            if (VAR_0->input_rc == VAR_6) {\n                ap_log_cerror(VAR_10, VAR_11, VAR_0->input_rc, VAR_0->c,\n                              \"%s: GnuTLS error: %s (%d)\",\n                              VAR_12, gnutls_strerror(VAR_14), VAR_14);\n                VAR_0->input_rc = VAR_13;\n            }\n            break;\n        }\n    }\n    return VAR_0->input_rc;\n}",
  "func_graph_path_before": "airtower-luna/mod_gnutls/d7eec4e598158ab6a98bf505354e84352f9715ec/gnutls_io.c/vul/before/1.json",
  "func": "static apr_status_t gnutls_io_input_read(mgs_handle_t * ctxt,\n        char *buf, apr_size_t * len)\n{\n    apr_size_t wanted = *len;\n    apr_size_t bytes = 0;\n\n    *len = 0;\n\n    /* If we have something leftover from last time, try that first. */\n    if ((bytes = char_buffer_read(&ctxt->input_cbuf, buf, wanted))) {\n        *len = bytes;\n        if (ctxt->input_mode == AP_MODE_SPECULATIVE) {\n            /* We want to rollback this read. */\n            if (ctxt->input_cbuf.length > 0) {\n                ctxt->input_cbuf.value -= bytes;\n                ctxt->input_cbuf.length += bytes;\n            } else {\n                char_buffer_write(&ctxt->input_cbuf, buf,\n                        (int) bytes);\n            }\n            return APR_SUCCESS;\n        }\n        /* This could probably be *len == wanted, but be safe from stray\n         * photons.\n         */\n        if (*len >= wanted) {\n            return APR_SUCCESS;\n        }\n        if (ctxt->input_mode == AP_MODE_GETLINE) {\n            if (memchr(buf, APR_ASCII_LF, *len)) {\n                return APR_SUCCESS;\n            }\n        } else {\n            /* Down to a nonblock pattern as we have some data already\n             */\n            ctxt->input_block = APR_NONBLOCK_READ;\n        }\n    }\n\n    if (ctxt->session == NULL) {\n        ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, ctxt->c,\n                      \"%s: GnuTLS session is NULL!\", __func__);\n        return APR_EGENERAL;\n    }\n\n    while (1)\n    {\n        /* Note: The pull function sets ctxt->input_rc */\n        int rc = gnutls_record_recv(ctxt->session,\n                                    buf + bytes, wanted - bytes);\n\n        if (rc > 0) {\n            *len += rc;\n            if (ctxt->input_mode == AP_MODE_SPECULATIVE) {\n                /* We want to rollback this read. */\n                char_buffer_write(&ctxt->input_cbuf, buf,\n                                  *len);\n            }\n            return ctxt->input_rc;\n        } else if (rc == 0) {\n            /* EOF, return code depends on whether we still have data\n             * to return. */\n            if (*len > 0) {\n                ctxt->input_rc = APR_SUCCESS;\n            } else {\n                ctxt->input_rc = APR_EOF;\n            }\n            break;\n        } else { /* (rc < 0) */\n\n            if (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN)\n            {\n                ap_log_cerror(APLOG_MARK, APLOG_TRACE2, ctxt->input_rc, ctxt->c,\n                              \"%s: looping recv after '%s' (%d)\",\n                              __func__, gnutls_strerror(rc), rc);\n                /* For a blocking read, loop and try again\n                 * immediately. Otherwise just notify the caller. */\n                if (ctxt->input_block != APR_NONBLOCK_READ)\n                    continue;\n                else\n                    ctxt->input_rc =\n                        (rc == GNUTLS_E_AGAIN ? APR_EAGAIN : APR_EINTR);\n            } else if (rc == GNUTLS_E_REHANDSHAKE) {\n                /* A client has asked for a new Hankshake. Currently, we don't do it */\n                ap_log_cerror(APLOG_MARK, APLOG_DEBUG,\n                        ctxt->input_rc,\n                        ctxt->c,\n                        \"GnuTLS: Error reading data. Client Requested a New Handshake.\"\n                        \" (%d) '%s'\", rc,\n                        gnutls_strerror(rc));\n            } else if (rc == GNUTLS_E_WARNING_ALERT_RECEIVED) {\n                rc = gnutls_alert_get(ctxt->session);\n                ap_log_cerror(APLOG_MARK, APLOG_DEBUG,\n                        ctxt->input_rc,\n                        ctxt->c,\n                        \"GnuTLS: Warning Alert From Client: \"\n                        \" (%d) '%s'\", rc,\n                        gnutls_alert_get_name(rc));\n            } else if (rc == GNUTLS_E_FATAL_ALERT_RECEIVED) {\n                rc = gnutls_alert_get(ctxt->session);\n                ap_log_cerror(APLOG_MARK, APLOG_DEBUG,\n                        ctxt->input_rc,\n                        ctxt->c,\n                        \"GnuTLS: Fatal Alert From Client: \"\n                        \"(%d) '%s'\", rc,\n                        gnutls_alert_get_name(rc));\n                ctxt->input_rc = APR_EGENERAL;\n                break;\n            } else if (rc == GNUTLS_E_PULL_ERROR\n                       && APR_STATUS_IS_TIMEUP(ctxt->input_rc)) {\n                ap_log_cerror(\n                    APLOG_MARK, APLOG_TRACE2, ctxt->input_rc, ctxt->c,\n                    \"%s: transport read timed out\", __func__);\n            } else {\n                /* Some Other Error. Report it. Die. */\n                if (gnutls_error_is_fatal(rc)) {\n                    ap_log_cerror(\n                        APLOG_MARK, APLOG_DEBUG,\n                        ctxt->input_rc,\n                        ctxt->c,\n                        \"GnuTLS: Error reading data. (%d) '%s'\",\n                        rc, gnutls_strerror(rc));\n                } else if (*len > 0) {\n                    ctxt->input_rc = APR_SUCCESS;\n                    break;\n                }\n            }\n\n            if (ctxt->input_rc == APR_SUCCESS) {\n                ap_log_cerror(APLOG_MARK, APLOG_INFO, ctxt->input_rc, ctxt->c,\n                              \"%s: GnuTLS error: %s (%d)\",\n                              __func__, gnutls_strerror(rc), rc);\n                ctxt->input_rc = APR_EGENERAL;\n            }\n            break;\n        }\n    }\n    return ctxt->input_rc;\n}",
  "abstract_func": "static apr_status_t gnutls_io_input_read(mgs_handle_t * VAR_0,\n        char *VAR_1, apr_size_t * VAR_2)\n{\n    apr_size_t VAR_3 = *VAR_2;\n    apr_size_t VAR_4 = 0;\n\n    *VAR_2 = 0;\n\n    /* COMMENT_0 */\n    if ((VAR_4 = char_buffer_read(&VAR_0->input_cbuf, VAR_1, VAR_3))) {\n        *VAR_2 = VAR_4;\n        if (VAR_0->input_mode == VAR_5) {\n            /* COMMENT_1 */\n            if (VAR_0->input_cbuf.length > 0) {\n                VAR_0->input_cbuf.value -= VAR_4;\n                VAR_0->input_cbuf.length += VAR_4;\n            } else {\n                char_buffer_write(&VAR_0->input_cbuf, VAR_1,\n                        (int) VAR_4);\n            }\n            return VAR_6;\n        }\n        /* COMMENT_2 */\n                   \n           \n        if (*VAR_2 >= VAR_3) {\n            return VAR_6;\n        }\n        if (VAR_0->input_mode == VAR_7) {\n            if (memchr(VAR_1, VAR_8, *VAR_2)) {\n                return VAR_6;\n            }\n        } else {\n            /* COMMENT_5 */\n               \n            VAR_0->input_block = VAR_9;\n        }\n    }\n\n    if (VAR_0->session == NULL) {\n        ap_log_cerror(VAR_10, VAR_11, 0, VAR_0->c,\n                      \"%s: GnuTLS session is NULL!\", VAR_12);\n        return VAR_13;\n    }\n\n    while (1)\n    {\n        /* COMMENT_7 */\n        int VAR_14 = gnutls_record_recv(VAR_0->session,\n                                    VAR_1 + VAR_4, VAR_3 - VAR_4);\n\n        if (VAR_14 > 0) {\n            *VAR_2 += VAR_14;\n            if (VAR_0->input_mode == VAR_5) {\n                /* COMMENT_1 */\n                char_buffer_write(&VAR_0->input_cbuf, VAR_1,\n                                  *VAR_2);\n            }\n            return VAR_0->input_rc;\n        } else if (VAR_14 == 0) {\n            /* COMMENT_8 */\n                            \n            if (*VAR_2 > 0) {\n                VAR_0->input_rc = VAR_6;\n            } else {\n                VAR_0->input_rc = VAR_15;\n            }\n            break;\n        } else { /* COMMENT_10 */\n\n            if (VAR_14 == VAR_16 || VAR_14 == VAR_17)\n            {\n                ap_log_cerror(VAR_10, VAR_18, VAR_0->input_rc, VAR_0->c,\n                              \"%s: looping recv after '%s' (%d)\",\n                              VAR_12, gnutls_strerror(VAR_14), VAR_14);\n                /* COMMENT_11 */\n                                                                    \n                if (VAR_0->input_block != VAR_9)\n                    continue;\n                else\n                    VAR_0->input_rc =\n                        (VAR_14 == VAR_17 ? VAR_19 : VAR_20);\n            } else if (VAR_14 == VAR_21) {\n                /* COMMENT_13 */\n                ap_log_cerror(VAR_10, VAR_22,\n                        VAR_0->input_rc,\n                        VAR_0->c,\n                        \"GnuTLS: Error reading data. Client Requested a New Handshake.\"\n                        \" (%d) '%s'\", VAR_14,\n                        gnutls_strerror(VAR_14));\n            } else if (VAR_14 == VAR_23) {\n                VAR_14 = gnutls_alert_get(VAR_0->session);\n                ap_log_cerror(VAR_10, VAR_22,\n                        VAR_0->input_rc,\n                        VAR_0->c,\n                        \"GnuTLS: Warning Alert From Client: \"\n                        \" (%d) '%s'\", VAR_14,\n                        gnutls_alert_get_name(VAR_14));\n            } else if (VAR_14 == VAR_24) {\n                VAR_14 = gnutls_alert_get(VAR_0->session);\n                ap_log_cerror(VAR_10, VAR_22,\n                        VAR_0->input_rc,\n                        VAR_0->c,\n                        \"GnuTLS: Fatal Alert From Client: \"\n                        \"(%d) '%s'\", VAR_14,\n                        gnutls_alert_get_name(VAR_14));\n                VAR_0->input_rc = VAR_13;\n                break;\n            } else if (VAR_14 == VAR_25\n                       && APR_STATUS_IS_TIMEUP(VAR_0->input_rc)) {\n                ap_log_cerror(\n                    VAR_10, VAR_18, VAR_0->input_rc, VAR_0->c,\n                    \"%s: transport read timed out\", VAR_12);\n            } else {\n                /* COMMENT_14 */\n                if (gnutls_error_is_fatal(VAR_14)) {\n                    ap_log_cerror(\n                        VAR_10, VAR_22,\n                        VAR_0->input_rc,\n                        VAR_0->c,\n                        \"GnuTLS: Error reading data. (%d) '%s'\",\n                        VAR_14, gnutls_strerror(VAR_14));\n                } else if (*VAR_2 > 0) {\n                    VAR_0->input_rc = VAR_6;\n                    break;\n                }\n            }\n\n            if (VAR_0->input_rc == VAR_6) {\n                ap_log_cerror(VAR_10, VAR_11, VAR_0->input_rc, VAR_0->c,\n                              \"%s: GnuTLS error: %s (%d)\",\n                              VAR_12, gnutls_strerror(VAR_14), VAR_14);\n                VAR_0->input_rc = VAR_13;\n            }\n            break;\n        }\n    }\n    return VAR_0->input_rc;\n}",
  "func_graph_path": "airtower-luna/mod_gnutls/d7eec4e598158ab6a98bf505354e84352f9715ec/gnutls_io.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -106,6 +106,11 @@\n                         gnutls_alert_get_name(rc));\n                 ctxt->input_rc = APR_EGENERAL;\n                 break;\n+            } else if (rc == GNUTLS_E_PULL_ERROR\n+                       && APR_STATUS_IS_TIMEUP(ctxt->input_rc)) {\n+                ap_log_cerror(\n+                    APLOG_MARK, APLOG_TRACE2, ctxt->input_rc, ctxt->c,\n+                    \"%s: transport read timed out\", __func__);\n             } else {\n                 /* Some Other Error. Report it. Die. */\n                 if (gnutls_error_is_fatal(rc)) {",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "            } else if (rc == GNUTLS_E_PULL_ERROR",
      "                       && APR_STATUS_IS_TIMEUP(ctxt->input_rc)) {",
      "                ap_log_cerror(",
      "                    APLOG_MARK, APLOG_TRACE2, ctxt->input_rc, ctxt->c,",
      "                    \"%s: transport read timed out\", __func__);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/airtower-luna/mod_gnutls/pull/15",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/airtower-luna/mod_gnutls/pull/15: 403 Client Error: Forbidden for url: https://api.github.com/repos/airtower-luna/mod_gnutls/pulls/15",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "Final Classification: Security Vulnerability Fix; Confidence: 0.9\n\n**Step-by-Step Explanation:**\n\n1. **Input Analysis:** The commit and vulnerability description explain an infinite loop caused by incorrect error handling, leading to resource exhaustion—a clear security issue.\n\n2. **Consistency Check:** The code changes fix the error condition, aligning with the described issue.\n\n3. **Purpose Evaluation:** The patch modifies core logic to fix a bug that could cause denial of service, indicating a security concern.\n\n4. **Security Assessment:** The fix addresses an exploit leading to resource exhaustion, fitting as a security vulnerability.\n\n5. **Confidence Score:** High confidence (0.9) due to clear symptoms and fix, though lacking a CVE reference.\n\n**Final Classification:** Security Vulnerability Fix; Confidence: 0.9"
}