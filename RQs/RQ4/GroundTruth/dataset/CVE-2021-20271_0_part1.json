{
  "cve_id": "CVE-2021-20271",
  "cwe_ids": [
    "CWE-345"
  ],
  "cvss_vector": "AV:N/AC:H/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "rpm-software-management/rpm",
  "commit_msg": "Be much more careful about copying data from the signature header\n\nOnly look for known tags, and ensure correct type and size where known\nbefore copying over. Bump the old arbitrary 16k count limit to 16M limit\nthough, it's not inconceivable that a package could have that many files.\nWhile at it, ensure none of these tags exist in the main header,\nwhich would confuse us greatly.\n\nThis is optimized for backporting ease, upstream can remove redundancies\nand further improve checking later.\n\nReported and initial patches by Demi Marie Obenour.\n\nFixes: RhBug:1935049, RhBug:1933867, RhBug:1935035, RhBug:1934125, ...\n\nFixes: CVE-2021-3421, CVE-2021-20271",
  "commit_hash": "d6a86b5e69e46cc283b1e06c92343319beb42e21",
  "git_url": "https://github.com/rpm-software-management/rpm/commit/d6a86b5e69e46cc283b1e06c92343319beb42e21",
  "file_path": "lib/package.c",
  "func_name": "rpmReadPackageFile",
  "func_before": "rpmRC rpmReadPackageFile(rpmts ts, FD_t fd, const char * fn, Header * hdrp)\n{\n    char *msg = NULL;\n    Header h = NULL;\n    Header sigh = NULL;\n    hdrblob blob = NULL;\n    hdrblob sigblob = NULL;\n    rpmVSFlags vsflags = rpmtsVSFlags(ts) | RPMVSF_NEEDPAYLOAD;\n    rpmKeyring keyring = rpmtsGetKeyring(ts, 1);\n    struct rpmvs_s *vs = rpmvsCreate(0, vsflags, keyring);\n    struct pkgdata_s pkgdata = {\n\t.msgfunc = loghdrmsg,\n\t.fn = fn ? fn : Fdescr(fd),\n\t.msg = NULL,\n\t.rc = RPMRC_OK,\n    };\n\n    /* XXX: lots of 3rd party software relies on the behavior */\n    if (hdrp)\n\t*hdrp = NULL;\n\n    rpmRC rc = rpmpkgRead(vs, fd, &sigblob, &blob, &msg);\n    if (rc)\n\tgoto exit;\n\n    /* Actually all verify discovered signatures and digests */\n    rc = RPMRC_FAIL;\n    if (!rpmvsVerify(vs, RPMSIG_VERIFIABLE_TYPE, handleHdrVS, &pkgdata)) {\n\t/* Finally import the headers and do whatever required retrofits etc */\n\tif (hdrp) {\n\t    if (hdrblobImport(sigblob, 0, &sigh, &msg))\n\t\tgoto exit;\n\t    if (hdrblobImport(blob, 0, &h, &msg))\n\t\tgoto exit;\n\n\t    /* Append (and remap) signature tags to the metadata. */\n\t    headerMergeLegacySigs(h, sigh);\n\t    applyRetrofits(h);\n\n\t    /* Bump reference count for return. */\n\t    *hdrp = headerLink(h);\n\t}\n\trc = RPMRC_OK;\n    }\n\n    /* If there was a \"substatus\" (NOKEY in practise), return that instead */\n    if (rc == RPMRC_OK && pkgdata.rc)\n\trc = pkgdata.rc;\n\nexit:\n    if (rc && msg)\n\trpmlog(RPMLOG_ERR, \"%s: %s\\n\", Fdescr(fd), msg);\n    hdrblobFree(sigblob);\n    hdrblobFree(blob);\n    headerFree(sigh);\n    headerFree(h);\n    rpmKeyringFree(keyring);\n    rpmvsFree(vs);\n    free(msg);\n\n    return rc;\n}",
  "abstract_func_before": "rpmRC rpmReadPackageFile(rpmts VAR_0, FD_t VAR_1, const char * VAR_2, Header * VAR_3)\n{\n    char *VAR_4 = NULL;\n    Header VAR_5 = NULL;\n    Header VAR_6 = NULL;\n    hdrblob VAR_7 = NULL;\n    hdrblob VAR_8 = NULL;\n    rpmVSFlags VAR_9 = rpmtsVSFlags(VAR_0) | VAR_10;\n    rpmKeyring VAR_11 = rpmtsGetKeyring(VAR_0, 1);\n    struct rpmvs_s *VAR_12 = rpmvsCreate(0, VAR_9, VAR_11);\n    struct pkgdata_s VAR_13 = {\n\t.msgfunc = VAR_14,\n\t.fn = VAR_2 ? VAR_2 : Fdescr(VAR_1),\n\t.msg = NULL,\n\t.rc = VAR_15,\n    };\n\n    /* COMMENT_0 */\n    if (VAR_3)\n\t*VAR_3 = NULL;\n\n    rpmRC VAR_16 = rpmpkgRead(VAR_12, VAR_1, &VAR_8, &VAR_7, &VAR_4);\n    if (VAR_16)\n\tgoto exit;\n\n    /* COMMENT_1 */\n    VAR_16 = VAR_17;\n    if (!rpmvsVerify(VAR_12, VAR_18, VAR_19, &VAR_13)) {\n\t/* COMMENT_2 */\n\tif (VAR_3) {\n\t    if (hdrblobImport(VAR_8, 0, &VAR_6, &VAR_4))\n\t\tgoto exit;\n\t    if (hdrblobImport(VAR_7, 0, &VAR_5, &VAR_4))\n\t\tgoto exit;\n\n\t    /* COMMENT_3 */\n\t    headerMergeLegacySigs(VAR_5, VAR_6);\n\t    applyRetrofits(VAR_5);\n\n\t    /* COMMENT_4 */\n\t    *VAR_3 = headerLink(VAR_5);\n\t}\n\tVAR_16 = VAR_15;\n    }\n\n    /* COMMENT_5 */\n    if (VAR_16 == VAR_15 && VAR_13.rc)\n\tVAR_16 = VAR_13.rc;\n\nexit:\n    if (VAR_16 && VAR_4)\n\trpmlog(VAR_20, \"%s: %s\\n\", Fdescr(VAR_1), VAR_4);\n    hdrblobFree(VAR_8);\n    hdrblobFree(VAR_7);\n    headerFree(VAR_6);\n    headerFree(VAR_5);\n    rpmKeyringFree(VAR_11);\n    rpmvsFree(VAR_12);\n    free(VAR_4);\n\n    return VAR_16;\n}",
  "func_graph_path_before": "rpm-software-management/rpm/d6a86b5e69e46cc283b1e06c92343319beb42e21/package.c/vul/before/1.json",
  "func": "rpmRC rpmReadPackageFile(rpmts ts, FD_t fd, const char * fn, Header * hdrp)\n{\n    char *msg = NULL;\n    Header h = NULL;\n    Header sigh = NULL;\n    hdrblob blob = NULL;\n    hdrblob sigblob = NULL;\n    rpmVSFlags vsflags = rpmtsVSFlags(ts) | RPMVSF_NEEDPAYLOAD;\n    rpmKeyring keyring = rpmtsGetKeyring(ts, 1);\n    struct rpmvs_s *vs = rpmvsCreate(0, vsflags, keyring);\n    struct pkgdata_s pkgdata = {\n\t.msgfunc = loghdrmsg,\n\t.fn = fn ? fn : Fdescr(fd),\n\t.msg = NULL,\n\t.rc = RPMRC_OK,\n    };\n\n    /* XXX: lots of 3rd party software relies on the behavior */\n    if (hdrp)\n\t*hdrp = NULL;\n\n    rpmRC rc = rpmpkgRead(vs, fd, &sigblob, &blob, &msg);\n    if (rc)\n\tgoto exit;\n\n    /* Actually all verify discovered signatures and digests */\n    rc = RPMRC_FAIL;\n    if (!rpmvsVerify(vs, RPMSIG_VERIFIABLE_TYPE, handleHdrVS, &pkgdata)) {\n\t/* Finally import the headers and do whatever required retrofits etc */\n\tif (hdrp) {\n\t    if (hdrblobImport(sigblob, 0, &sigh, &msg))\n\t\tgoto exit;\n\t    if (hdrblobImport(blob, 0, &h, &msg))\n\t\tgoto exit;\n\n\t    /* Append (and remap) signature tags to the metadata. */\n\t    if (headerMergeLegacySigs(h, sigh, &msg))\n\t\tgoto exit;\n\t    applyRetrofits(h);\n\n\t    /* Bump reference count for return. */\n\t    *hdrp = headerLink(h);\n\t}\n\trc = RPMRC_OK;\n    }\n\n    /* If there was a \"substatus\" (NOKEY in practise), return that instead */\n    if (rc == RPMRC_OK && pkgdata.rc)\n\trc = pkgdata.rc;\n\nexit:\n    if (rc && msg)\n\trpmlog(RPMLOG_ERR, \"%s: %s\\n\", Fdescr(fd), msg);\n    hdrblobFree(sigblob);\n    hdrblobFree(blob);\n    headerFree(sigh);\n    headerFree(h);\n    rpmKeyringFree(keyring);\n    rpmvsFree(vs);\n    free(msg);\n\n    return rc;\n}",
  "abstract_func": "rpmRC rpmReadPackageFile(rpmts VAR_0, FD_t VAR_1, const char * VAR_2, Header * VAR_3)\n{\n    char *VAR_4 = NULL;\n    Header VAR_5 = NULL;\n    Header VAR_6 = NULL;\n    hdrblob VAR_7 = NULL;\n    hdrblob VAR_8 = NULL;\n    rpmVSFlags VAR_9 = rpmtsVSFlags(VAR_0) | VAR_10;\n    rpmKeyring VAR_11 = rpmtsGetKeyring(VAR_0, 1);\n    struct rpmvs_s *VAR_12 = rpmvsCreate(0, VAR_9, VAR_11);\n    struct pkgdata_s VAR_13 = {\n\t.msgfunc = VAR_14,\n\t.fn = VAR_2 ? VAR_2 : Fdescr(VAR_1),\n\t.msg = NULL,\n\t.rc = VAR_15,\n    };\n\n    /* COMMENT_0 */\n    if (VAR_3)\n\t*VAR_3 = NULL;\n\n    rpmRC VAR_16 = rpmpkgRead(VAR_12, VAR_1, &VAR_8, &VAR_7, &VAR_4);\n    if (VAR_16)\n\tgoto exit;\n\n    /* COMMENT_1 */\n    VAR_16 = VAR_17;\n    if (!rpmvsVerify(VAR_12, VAR_18, VAR_19, &VAR_13)) {\n\t/* COMMENT_2 */\n\tif (VAR_3) {\n\t    if (hdrblobImport(VAR_8, 0, &VAR_6, &VAR_4))\n\t\tgoto exit;\n\t    if (hdrblobImport(VAR_7, 0, &VAR_5, &VAR_4))\n\t\tgoto exit;\n\n\t    /* COMMENT_3 */\n\t    if (headerMergeLegacySigs(VAR_5, VAR_6, &VAR_4))\n\t\tgoto exit;\n\t    applyRetrofits(VAR_5);\n\n\t    /* COMMENT_4 */\n\t    *VAR_3 = headerLink(VAR_5);\n\t}\n\tVAR_16 = VAR_15;\n    }\n\n    /* COMMENT_5 */\n    if (VAR_16 == VAR_15 && VAR_13.rc)\n\tVAR_16 = VAR_13.rc;\n\nexit:\n    if (VAR_16 && VAR_4)\n\trpmlog(VAR_20, \"%s: %s\\n\", Fdescr(VAR_1), VAR_4);\n    hdrblobFree(VAR_8);\n    hdrblobFree(VAR_7);\n    headerFree(VAR_6);\n    headerFree(VAR_5);\n    rpmKeyringFree(VAR_11);\n    rpmvsFree(VAR_12);\n    free(VAR_4);\n\n    return VAR_16;\n}",
  "func_graph_path": "rpm-software-management/rpm/d6a86b5e69e46cc283b1e06c92343319beb42e21/package.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -34,7 +34,8 @@\n \t\tgoto exit;\n \n \t    /* Append (and remap) signature tags to the metadata. */\n-\t    headerMergeLegacySigs(h, sigh);\n+\t    if (headerMergeLegacySigs(h, sigh, &msg))\n+\t\tgoto exit;\n \t    applyRetrofits(h);\n \n \t    /* Bump reference count for return. */",
  "diff_line_info": {
    "deleted_lines": [
      "\t    headerMergeLegacySigs(h, sigh);"
    ],
    "added_lines": [
      "\t    if (headerMergeLegacySigs(h, sigh, &msg))",
      "\t\tgoto exit;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/rpm-software-management/rpm/pull/1577",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/rpm-software-management/rpm/pull/1577: 403 Client Error: Forbidden for url: https://api.github.com/repos/rpm-software-management/rpm/pulls/1577",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}