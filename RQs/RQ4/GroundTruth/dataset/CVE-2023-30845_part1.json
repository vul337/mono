{
  "cve_id": "CVE-2023-30845",
  "cwe_ids": [
    "CWE-287"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "GoogleCloudPlatform/esp-v2",
  "commit_msg": "Add back in HTTP method override in service control filter (#802)\n\nThis is NOT used by ESPv2, but it is needed for CAG temporarily. We can remove once their rollout is complete.\r\n\r\nSigned-off-by: Teju Nareddy <nareddyt@google.com>",
  "commit_hash": "e98061ee4527a564506ba4e814c0ecf324dc2c6f",
  "git_url": "https://github.com/GoogleCloudPlatform/esp-v2/commit/e98061ee4527a564506ba4e814c0ecf324dc2c6f",
  "file_path": "src/envoy/http/service_control/filter.cc",
  "func_name": "ServiceControlFilter::decodeHeaders",
  "func_before": "Envoy::Http::FilterHeadersStatus ServiceControlFilter::decodeHeaders(\n    Envoy::Http::RequestHeaderMap& headers, bool) {\n  ENVOY_LOG(debug, \"Called ServiceControl Filter : {}\", __func__);\n\n  if (!headers.Method()) {\n    rejectRequest(Envoy::Http::Code::BadRequest,\n                  \"No method in request headers.\",\n                  utils::generateRcDetails(utils::kRcDetailFilterServiceControl,\n                                           utils::kRcDetailErrorTypeBadRequest,\n                                           utils::kRcDetailErrorMissingMethod));\n    return Envoy::Http::FilterHeadersStatus::StopIteration;\n  } else if (!headers.Path()) {\n    rejectRequest(Envoy::Http::Code::BadRequest, \"No path in request headers.\",\n                  utils::generateRcDetails(utils::kRcDetailFilterServiceControl,\n                                           utils::kRcDetailErrorTypeBadRequest,\n                                           utils::kRcDetailErrorMissingPath));\n    return Envoy::Http::FilterHeadersStatus::StopIteration;\n  }\n\n  // Make sure route is calculated\n  auto route = decoder_callbacks_->route();\n\n  // This shouldn't happen as the catch-all route match should catch all\n  // the undefined requests.\n  if (route == nullptr) {\n    return Envoy::Http::FilterHeadersStatus::Continue;\n  }\n\n  handler_ = factory_.createHandler(headers, decoder_callbacks_, stats_);\n  handler_->fillFilterState(*decoder_callbacks_->streamInfo().filterState());\n  state_ = Calling;\n  stopped_ = false;\n\n  Envoy::Tracing::Span& parent_span = decoder_callbacks_->activeSpan();\n\n  handler_->callCheck(headers, parent_span, *this);\n\n  // If success happens synchronously, continue now.\n  if (state_ == Complete) {\n    return Envoy::Http::FilterHeadersStatus::Continue;\n  }\n\n  // Stop for now. If an async request is made, it will continue in onCheckDone.\n  ENVOY_LOG(debug, \"Called ServiceControl filter : Stop\");\n  stopped_ = true;\n  return Envoy::Http::FilterHeadersStatus::StopIteration;\n}",
  "abstract_func_before": "Envoy::Http::FilterHeadersStatus ServiceControlFilter::decodeHeaders(\n    Envoy::Http::RequestHeaderMap& VAR_0, bool) {\n  ENVOY_LOG(VAR_1, \"Called ServiceControl Filter : {}\", VAR_2);\n\n  if (!VAR_0.Method()) {\n    rejectRequest(Envoy::Http::Code::BadRequest,\n                  \"No method in request headers.\",\n                  utils::generateRcDetails(utils::kRcDetailFilterServiceControl,\n                                           utils::kRcDetailErrorTypeBadRequest,\n                                           utils::kRcDetailErrorMissingMethod));\n    return Envoy::Http::FilterHeadersStatus::StopIteration;\n  } else if (!VAR_0.Path()) {\n    rejectRequest(Envoy::Http::Code::BadRequest, \"No path in request headers.\",\n                  utils::generateRcDetails(utils::kRcDetailFilterServiceControl,\n                                           utils::kRcDetailErrorTypeBadRequest,\n                                           utils::kRcDetailErrorMissingPath));\n    return Envoy::Http::FilterHeadersStatus::StopIteration;\n  }\n\n  /* COMMENT_0 */\n  auto VAR_3 = VAR_4->route();\n\n  /* COMMENT_1 */\n  /* COMMENT_2 */\n  if (VAR_3 == nullptr) {\n    return Envoy::Http::FilterHeadersStatus::Continue;\n  }\n\n  VAR_5 = VAR_6.createHandler(VAR_0, VAR_4, VAR_7);\n  VAR_5->fillFilterState(*VAR_4->streamInfo().filterState());\n  VAR_8 = VAR_9;\n  VAR_10 = false;\n\n  Envoy::Tracing::Span& VAR_11 = VAR_4->activeSpan();\n\n  VAR_5->callCheck(VAR_0, VAR_11, *this);\n\n  /* COMMENT_3 */\n  if (VAR_8 == VAR_12) {\n    return Envoy::Http::FilterHeadersStatus::Continue;\n  }\n\n  /* COMMENT_4 */\n  ENVOY_LOG(VAR_1, \"Called ServiceControl filter : Stop\");\n  VAR_10 = true;\n  return Envoy::Http::FilterHeadersStatus::StopIteration;\n}",
  "func_graph_path_before": "GoogleCloudPlatform/esp-v2/e98061ee4527a564506ba4e814c0ecf324dc2c6f/filter.cc/vul/before/0.json",
  "func": "Envoy::Http::FilterHeadersStatus ServiceControlFilter::decodeHeaders(\n    Envoy::Http::RequestHeaderMap& headers, bool) {\n  ENVOY_LOG(debug, \"Called ServiceControl Filter : {}\", __func__);\n\n  if (!headers.Method()) {\n    rejectRequest(Envoy::Http::Code::BadRequest,\n                  \"No method in request headers.\",\n                  utils::generateRcDetails(utils::kRcDetailFilterServiceControl,\n                                           utils::kRcDetailErrorTypeBadRequest,\n                                           utils::kRcDetailErrorMissingMethod));\n    return Envoy::Http::FilterHeadersStatus::StopIteration;\n  } else if (!headers.Path()) {\n    rejectRequest(Envoy::Http::Code::BadRequest, \"No path in request headers.\",\n                  utils::generateRcDetails(utils::kRcDetailFilterServiceControl,\n                                           utils::kRcDetailErrorTypeBadRequest,\n                                           utils::kRcDetailErrorMissingPath));\n    return Envoy::Http::FilterHeadersStatus::StopIteration;\n  }\n\n  // TODO(b/273531500): Temporary until CAG rollout is complete.\n  if (utils::handleHttpMethodOverride(headers)) {\n    // Update later filters that the HTTP method has changed by clearing the\n    // route cache.\n    ENVOY_LOG(debug, \"HTTP method override occurred, recalculating route\");\n    decoder_callbacks_->downstreamCallbacks()->clearRouteCache();\n  }\n\n  // Make sure route is calculated\n  auto route = decoder_callbacks_->route();\n\n  // This shouldn't happen as the catch-all route match should catch all\n  // the undefined requests.\n  if (route == nullptr) {\n    return Envoy::Http::FilterHeadersStatus::Continue;\n  }\n\n  handler_ = factory_.createHandler(headers, decoder_callbacks_, stats_);\n  handler_->fillFilterState(*decoder_callbacks_->streamInfo().filterState());\n  state_ = Calling;\n  stopped_ = false;\n\n  Envoy::Tracing::Span& parent_span = decoder_callbacks_->activeSpan();\n\n  handler_->callCheck(headers, parent_span, *this);\n\n  // If success happens synchronously, continue now.\n  if (state_ == Complete) {\n    return Envoy::Http::FilterHeadersStatus::Continue;\n  }\n\n  // Stop for now. If an async request is made, it will continue in onCheckDone.\n  ENVOY_LOG(debug, \"Called ServiceControl filter : Stop\");\n  stopped_ = true;\n  return Envoy::Http::FilterHeadersStatus::StopIteration;\n}",
  "abstract_func": "Envoy::Http::FilterHeadersStatus ServiceControlFilter::decodeHeaders(\n    Envoy::Http::RequestHeaderMap& VAR_0, bool) {\n  ENVOY_LOG(VAR_1, \"Called ServiceControl Filter : {}\", VAR_2);\n\n  if (!VAR_0.Method()) {\n    rejectRequest(Envoy::Http::Code::BadRequest,\n                  \"No method in request headers.\",\n                  utils::generateRcDetails(utils::kRcDetailFilterServiceControl,\n                                           utils::kRcDetailErrorTypeBadRequest,\n                                           utils::kRcDetailErrorMissingMethod));\n    return Envoy::Http::FilterHeadersStatus::StopIteration;\n  } else if (!VAR_0.Path()) {\n    rejectRequest(Envoy::Http::Code::BadRequest, \"No path in request headers.\",\n                  utils::generateRcDetails(utils::kRcDetailFilterServiceControl,\n                                           utils::kRcDetailErrorTypeBadRequest,\n                                           utils::kRcDetailErrorMissingPath));\n    return Envoy::Http::FilterHeadersStatus::StopIteration;\n  }\n\n  /* COMMENT_0 */\n  if (utils::handleHttpMethodOverride(VAR_0)) {\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n    ENVOY_LOG(VAR_1, \"HTTP method override occurred, recalculating route\");\n    VAR_3->downstreamCallbacks()->clearRouteCache();\n  }\n\n  /* COMMENT_3 */\n  auto VAR_4 = VAR_3->route();\n\n  /* COMMENT_4 */\n  /* COMMENT_5 */\n  if (VAR_4 == nullptr) {\n    return Envoy::Http::FilterHeadersStatus::Continue;\n  }\n\n  VAR_5 = VAR_6.createHandler(VAR_0, VAR_3, VAR_7);\n  VAR_5->fillFilterState(*VAR_3->streamInfo().filterState());\n  VAR_8 = VAR_9;\n  VAR_10 = false;\n\n  Envoy::Tracing::Span& VAR_11 = VAR_3->activeSpan();\n\n  VAR_5->callCheck(VAR_0, VAR_11, *this);\n\n  /* COMMENT_6 */\n  if (VAR_8 == VAR_12) {\n    return Envoy::Http::FilterHeadersStatus::Continue;\n  }\n\n  /* COMMENT_7 */\n  ENVOY_LOG(VAR_1, \"Called ServiceControl filter : Stop\");\n  VAR_10 = true;\n  return Envoy::Http::FilterHeadersStatus::StopIteration;\n}",
  "func_graph_path": "GoogleCloudPlatform/esp-v2/e98061ee4527a564506ba4e814c0ecf324dc2c6f/filter.cc/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -15,6 +15,14 @@\n                                            utils::kRcDetailErrorTypeBadRequest,\n                                            utils::kRcDetailErrorMissingPath));\n     return Envoy::Http::FilterHeadersStatus::StopIteration;\n+  }\n+\n+  // TODO(b/273531500): Temporary until CAG rollout is complete.\n+  if (utils::handleHttpMethodOverride(headers)) {\n+    // Update later filters that the HTTP method has changed by clearing the\n+    // route cache.\n+    ENVOY_LOG(debug, \"HTTP method override occurred, recalculating route\");\n+    decoder_callbacks_->downstreamCallbacks()->clearRouteCache();\n   }\n \n   // Make sure route is calculated",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "  }",
      "",
      "  // TODO(b/273531500): Temporary until CAG rollout is complete.",
      "  if (utils::handleHttpMethodOverride(headers)) {",
      "    // Update later filters that the HTTP method has changed by clearing the",
      "    // route cache.",
      "    ENVOY_LOG(debug, \"HTTP method override occurred, recalculating route\");",
      "    decoder_callbacks_->downstreamCallbacks()->clearRouteCache();"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/GoogleCloudPlatform/esp-v2/pull/802",
  "description": {
    "pr_info": {
      "title": "Add back in HTTP method override in service control filter",
      "number": 802
    },
    "comment": [
      "Removed by https://github.com/GoogleCloudPlatform/esp-v2/pull/801, adding back in the change to service control filter.\r\n\r\nThis is NOT used by ESPv2, but it is needed for CAG temporarily. We can remove once their rollout is complete.",
      "[APPROVALNOTIFIER] This PR is **APPROVED**\n\nThis pull-request has been approved by: *<a href=\"https://github.com/GoogleCloudPlatform/esp-v2/pull/802#\" title=\"Author self-approved\">nareddyt</a>*, *<a href=\"https://github.com/GoogleCloudPlatform/esp-v2/pull/802#pullrequestreview-1361489230\" title=\"Approved\">shuoyang2016</a>*\n\nThe full list of commands accepted by this bot can be found [here](https://oss.gprow.dev/command-help?repo=GoogleCloudPlatform%2Fesp-v2).\n\nThe pull request process is described [here](https://git.k8s.io/community/contributors/guide/owners.md#the-code-review-process)\n\n<details >\nNeeds approval from an approver in each of these files:\n\n- ~~[OWNERS](https://github.com/GoogleCloudPlatform/esp-v2/blob/master/OWNERS)~~ [nareddyt,shuoyang2016]\n\nApprovers can indicate their approval by writing `/approve` in a comment\nApprovers can cancel approval by writing `/approve cancel` in a comment\n</details>\n<!-- META={\"approvers\":[]} -->",
      "/retest"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 1.0  \n\nStep-by-step Explanation:\n\n1. The commit message and vulnerability description both mention reintroducing an HTTP method override feature for temporary use by CAG.\n2. The code diff shows adding logic to handle this override, impacting core functionality.\n3. There's no mention of security issues or fixes, indicating it's a feature reintroduction, not a security patch.\n4. The change fits the category of 'Defect Remediation & Feature Upgrades' as it's modifying core business logic for a specific use case.\n5. High confidence due to consistent and clear information."
}