{
  "cve_id": "CVE-2019-25052",
  "cwe_ids": [
    "CWE-327"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "OP-TEE/optee_os",
  "commit_msg": "cryp: prevent direct calls to update and final functions\n\nWith inconsistent or malformed data it has been possible to call\n\"update\" and \"final\" crypto functions directly. Using a fuzzer tool [1]\nwe have seen that this results in asserts, i.e., a crash that\npotentially could leak sensitive information.\n\nBy setting the state (initialized) in the crypto context (i.e., the\ntee_cryp_state) at the end of all syscall_*_init functions and then add\na check of the state at the beginning of all update and final functions,\n  we prevent direct entrance to the \"update\" and \"final\" functions.\n\n[1] https://github.com/MartijnB/optee_fuzzer\n\nFixes: OP-TEE-2019-0021\n\nSigned-off-by: Joakim Bech <joakim.bech@linaro.org>\nReported-by: Martijn Bogaard <bogaard@riscure.com>\nAcked-by: Jerome Forissier <jerome.forissier@linaro.org>\nReviewed-by: Jens Wiklander <jens.wiklander@linaro.org>",
  "commit_hash": "34a08bec755670ea0490cb53bbc68058cafc69b6",
  "git_url": "https://github.com/OP-TEE/optee_os/commit/34a08bec755670ea0490cb53bbc68058cafc69b6",
  "file_path": "core/tee/tee_svc_cryp.c",
  "func_name": "syscall_cryp_state_alloc",
  "func_before": "TEE_Result syscall_cryp_state_alloc(unsigned long algo, unsigned long mode,\n\t\t\tunsigned long key1, unsigned long key2,\n\t\t\tuint32_t *state)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o1 = NULL;\n\tstruct tee_obj *o2 = NULL;\n\tstruct user_ta_ctx *utc;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tutc = to_user_ta_ctx(sess->ctx);\n\n\tif (key1 != 0) {\n\t\tres = tee_obj_get(utc, tee_svc_uref_to_vaddr(key1), &o1);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tif (o1->busy)\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\tres = tee_svc_cryp_check_key_type(o1, algo, mode);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\tif (key2 != 0) {\n\t\tres = tee_obj_get(utc, tee_svc_uref_to_vaddr(key2), &o2);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tif (o2->busy)\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\tres = tee_svc_cryp_check_key_type(o2, algo, mode);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\n\tcs = calloc(1, sizeof(struct tee_cryp_state));\n\tif (!cs)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tTAILQ_INSERT_TAIL(&utc->cryp_states, cs, link);\n\tcs->algo = algo;\n\tcs->mode = mode;\n\n\tswitch (TEE_ALG_GET_CLASS(algo)) {\n\tcase TEE_OPERATION_EXTENSION:\n#ifdef CFG_CRYPTO_RSASSA_NA1\n\t\tif (algo == TEE_ALG_RSASSA_PKCS1_V1_5)\n\t\t\tgoto rsassa_na1;\n#endif\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t\tbreak;\n\tcase TEE_OPERATION_CIPHER:\n\t\tif ((algo == TEE_ALG_AES_XTS && (key1 == 0 || key2 == 0)) ||\n\t\t    (algo != TEE_ALG_AES_XTS && (key1 == 0 || key2 != 0))) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t} else {\n\t\t\tres = crypto_cipher_alloc_ctx(&cs->ctx, algo);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase TEE_OPERATION_AE:\n\t\tif (key1 == 0 || key2 != 0) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t} else {\n\t\t\tres = crypto_authenc_alloc_ctx(&cs->ctx, algo);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\tif (key1 == 0 || key2 != 0) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t} else {\n\t\t\tres = crypto_mac_alloc_ctx(&cs->ctx, algo);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase TEE_OPERATION_DIGEST:\n\t\tif (key1 != 0 || key2 != 0) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t} else {\n\t\t\tres = crypto_hash_alloc_ctx(&cs->ctx, algo);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase TEE_OPERATION_ASYMMETRIC_CIPHER:\n\tcase TEE_OPERATION_ASYMMETRIC_SIGNATURE:\nrsassa_na1: __maybe_unused\n\t\tif (key1 == 0 || key2 != 0)\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tbreak;\n\tcase TEE_OPERATION_KEY_DERIVATION:\n\t\tif (key1 == 0 || key2 != 0)\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tbreak;\n\tdefault:\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t\tbreak;\n\t}\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_svc_copy_kaddr_to_uref(state, cs);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\t/* Register keys */\n\tif (o1 != NULL) {\n\t\to1->busy = true;\n\t\tcs->key1 = (vaddr_t)o1;\n\t}\n\tif (o2 != NULL) {\n\t\to2->busy = true;\n\t\tcs->key2 = (vaddr_t)o2;\n\t}\n\nout:\n\tif (res != TEE_SUCCESS)\n\t\tcryp_state_free(utc, cs);\n\treturn res;\n}",
  "abstract_func_before": "TEE_Result syscall_cryp_state_alloc(unsigned long VAR_0, unsigned long VAR_1,\n\t\t\tunsigned long VAR_2, unsigned long VAR_3,\n\t\t\tuint32_t *VAR_4)\n{\n\tTEE_Result VAR_5;\n\tstruct tee_cryp_state *VAR_6;\n\tstruct tee_ta_session *VAR_7;\n\tstruct tee_obj *VAR_8 = NULL;\n\tstruct tee_obj *VAR_9 = NULL;\n\tstruct user_ta_ctx *VAR_10;\n\n\tVAR_5 = tee_ta_get_current_session(&VAR_7);\n\tif (VAR_5 != VAR_11)\n\t\treturn VAR_5;\n\tVAR_10 = to_user_ta_ctx(VAR_7->ctx);\n\n\tif (VAR_2 != 0) {\n\t\tVAR_5 = tee_obj_get(VAR_10, tee_svc_uref_to_vaddr(VAR_2), &VAR_8);\n\t\tif (VAR_5 != VAR_11)\n\t\t\treturn VAR_5;\n\t\tif (VAR_8->busy)\n\t\t\treturn VAR_12;\n\t\tVAR_5 = tee_svc_cryp_check_key_type(VAR_8, VAR_0, VAR_1);\n\t\tif (VAR_5 != VAR_11)\n\t\t\treturn VAR_5;\n\t}\n\tif (VAR_3 != 0) {\n\t\tVAR_5 = tee_obj_get(VAR_10, tee_svc_uref_to_vaddr(VAR_3), &VAR_9);\n\t\tif (VAR_5 != VAR_11)\n\t\t\treturn VAR_5;\n\t\tif (VAR_9->busy)\n\t\t\treturn VAR_12;\n\t\tVAR_5 = tee_svc_cryp_check_key_type(VAR_9, VAR_0, VAR_1);\n\t\tif (VAR_5 != VAR_11)\n\t\t\treturn VAR_5;\n\t}\n\n\tVAR_6 = calloc(1, sizeof(struct tee_cryp_state));\n\tif (!VAR_6)\n\t\treturn VAR_13;\n\tTAILQ_INSERT_TAIL(&VAR_10->cryp_states, VAR_6, VAR_14);\n\tVAR_6->algo = VAR_0;\n\tVAR_6->mode = VAR_1;\n\n\tswitch (TEE_ALG_GET_CLASS(VAR_0)) {\n\tcase VAR_15:\n#ifdef VAR_16\n\t\tif (VAR_0 == VAR_17)\n\t\t\tgoto rsassa_na1;\n#endif\n\t\tVAR_5 = VAR_18;\n\t\tbreak;\n\tcase VAR_19:\n\t\tif ((VAR_0 == VAR_20 && (VAR_2 == 0 || VAR_3 == 0)) ||\n\t\t    (VAR_0 != VAR_20 && (VAR_2 == 0 || VAR_3 != 0))) {\n\t\t\tVAR_5 = VAR_12;\n\t\t} else {\n\t\t\tVAR_5 = crypto_cipher_alloc_ctx(&VAR_6->ctx, VAR_0);\n\t\t\tif (VAR_5 != VAR_11)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase VAR_21:\n\t\tif (VAR_2 == 0 || VAR_3 != 0) {\n\t\t\tVAR_5 = VAR_12;\n\t\t} else {\n\t\t\tVAR_5 = crypto_authenc_alloc_ctx(&VAR_6->ctx, VAR_0);\n\t\t\tif (VAR_5 != VAR_11)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase VAR_22:\n\t\tif (VAR_2 == 0 || VAR_3 != 0) {\n\t\t\tVAR_5 = VAR_12;\n\t\t} else {\n\t\t\tVAR_5 = crypto_mac_alloc_ctx(&VAR_6->ctx, VAR_0);\n\t\t\tif (VAR_5 != VAR_11)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase VAR_23:\n\t\tif (VAR_2 != 0 || VAR_3 != 0) {\n\t\t\tVAR_5 = VAR_12;\n\t\t} else {\n\t\t\tVAR_5 = crypto_hash_alloc_ctx(&VAR_6->ctx, VAR_0);\n\t\t\tif (VAR_5 != VAR_11)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase VAR_24:\n\tcase VAR_25:\nrsassa_na1: VAR_26\n\t\tif (VAR_2 == 0 || VAR_3 != 0)\n\t\t\tVAR_5 = VAR_12;\n\t\tbreak;\n\tcase VAR_27:\n\t\tif (VAR_2 == 0 || VAR_3 != 0)\n\t\t\tVAR_5 = VAR_12;\n\t\tbreak;\n\tdefault:\n\t\tVAR_5 = VAR_18;\n\t\tbreak;\n\t}\n\tif (VAR_5 != VAR_11)\n\t\tgoto out;\n\n\tVAR_5 = tee_svc_copy_kaddr_to_uref(VAR_4, VAR_6);\n\tif (VAR_5 != VAR_11)\n\t\tgoto out;\n\n\t/* COMMENT_0 */\n\tif (VAR_8 != NULL) {\n\t\tVAR_8->busy = true;\n\t\tVAR_6->key1 = (vaddr_t)VAR_8;\n\t}\n\tif (VAR_9 != NULL) {\n\t\tVAR_9->busy = true;\n\t\tVAR_6->key2 = (vaddr_t)VAR_9;\n\t}\n\nout:\n\tif (VAR_5 != VAR_11)\n\t\tcryp_state_free(VAR_10, VAR_6);\n\treturn VAR_5;\n}",
  "func_graph_path_before": "OP-TEE/optee_os/34a08bec755670ea0490cb53bbc68058cafc69b6/tee_svc_cryp.c/vul/before/11.json",
  "func": "TEE_Result syscall_cryp_state_alloc(unsigned long algo, unsigned long mode,\n\t\t\tunsigned long key1, unsigned long key2,\n\t\t\tuint32_t *state)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o1 = NULL;\n\tstruct tee_obj *o2 = NULL;\n\tstruct user_ta_ctx *utc;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tutc = to_user_ta_ctx(sess->ctx);\n\n\tif (key1 != 0) {\n\t\tres = tee_obj_get(utc, tee_svc_uref_to_vaddr(key1), &o1);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tif (o1->busy)\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\tres = tee_svc_cryp_check_key_type(o1, algo, mode);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\tif (key2 != 0) {\n\t\tres = tee_obj_get(utc, tee_svc_uref_to_vaddr(key2), &o2);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tif (o2->busy)\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\tres = tee_svc_cryp_check_key_type(o2, algo, mode);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\n\tcs = calloc(1, sizeof(struct tee_cryp_state));\n\tif (!cs)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tTAILQ_INSERT_TAIL(&utc->cryp_states, cs, link);\n\tcs->algo = algo;\n\tcs->mode = mode;\n\tcs->state = CRYP_STATE_UNINITIALIZED;\n\n\tswitch (TEE_ALG_GET_CLASS(algo)) {\n\tcase TEE_OPERATION_EXTENSION:\n#ifdef CFG_CRYPTO_RSASSA_NA1\n\t\tif (algo == TEE_ALG_RSASSA_PKCS1_V1_5)\n\t\t\tgoto rsassa_na1;\n#endif\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t\tbreak;\n\tcase TEE_OPERATION_CIPHER:\n\t\tif ((algo == TEE_ALG_AES_XTS && (key1 == 0 || key2 == 0)) ||\n\t\t    (algo != TEE_ALG_AES_XTS && (key1 == 0 || key2 != 0))) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t} else {\n\t\t\tres = crypto_cipher_alloc_ctx(&cs->ctx, algo);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase TEE_OPERATION_AE:\n\t\tif (key1 == 0 || key2 != 0) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t} else {\n\t\t\tres = crypto_authenc_alloc_ctx(&cs->ctx, algo);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\tif (key1 == 0 || key2 != 0) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t} else {\n\t\t\tres = crypto_mac_alloc_ctx(&cs->ctx, algo);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase TEE_OPERATION_DIGEST:\n\t\tif (key1 != 0 || key2 != 0) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t} else {\n\t\t\tres = crypto_hash_alloc_ctx(&cs->ctx, algo);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase TEE_OPERATION_ASYMMETRIC_CIPHER:\n\tcase TEE_OPERATION_ASYMMETRIC_SIGNATURE:\nrsassa_na1: __maybe_unused\n\t\tif (key1 == 0 || key2 != 0)\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tbreak;\n\tcase TEE_OPERATION_KEY_DERIVATION:\n\t\tif (key1 == 0 || key2 != 0)\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tbreak;\n\tdefault:\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t\tbreak;\n\t}\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_svc_copy_kaddr_to_uref(state, cs);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\t/* Register keys */\n\tif (o1 != NULL) {\n\t\to1->busy = true;\n\t\tcs->key1 = (vaddr_t)o1;\n\t}\n\tif (o2 != NULL) {\n\t\to2->busy = true;\n\t\tcs->key2 = (vaddr_t)o2;\n\t}\n\nout:\n\tif (res != TEE_SUCCESS)\n\t\tcryp_state_free(utc, cs);\n\treturn res;\n}",
  "abstract_func": "TEE_Result syscall_cryp_state_alloc(unsigned long VAR_0, unsigned long VAR_1,\n\t\t\tunsigned long VAR_2, unsigned long VAR_3,\n\t\t\tuint32_t *VAR_4)\n{\n\tTEE_Result VAR_5;\n\tstruct tee_cryp_state *VAR_6;\n\tstruct tee_ta_session *VAR_7;\n\tstruct tee_obj *VAR_8 = NULL;\n\tstruct tee_obj *VAR_9 = NULL;\n\tstruct user_ta_ctx *VAR_10;\n\n\tVAR_5 = tee_ta_get_current_session(&VAR_7);\n\tif (VAR_5 != VAR_11)\n\t\treturn VAR_5;\n\tVAR_10 = to_user_ta_ctx(VAR_7->ctx);\n\n\tif (VAR_2 != 0) {\n\t\tVAR_5 = tee_obj_get(VAR_10, tee_svc_uref_to_vaddr(VAR_2), &VAR_8);\n\t\tif (VAR_5 != VAR_11)\n\t\t\treturn VAR_5;\n\t\tif (VAR_8->busy)\n\t\t\treturn VAR_12;\n\t\tVAR_5 = tee_svc_cryp_check_key_type(VAR_8, VAR_0, VAR_1);\n\t\tif (VAR_5 != VAR_11)\n\t\t\treturn VAR_5;\n\t}\n\tif (VAR_3 != 0) {\n\t\tVAR_5 = tee_obj_get(VAR_10, tee_svc_uref_to_vaddr(VAR_3), &VAR_9);\n\t\tif (VAR_5 != VAR_11)\n\t\t\treturn VAR_5;\n\t\tif (VAR_9->busy)\n\t\t\treturn VAR_12;\n\t\tVAR_5 = tee_svc_cryp_check_key_type(VAR_9, VAR_0, VAR_1);\n\t\tif (VAR_5 != VAR_11)\n\t\t\treturn VAR_5;\n\t}\n\n\tVAR_6 = calloc(1, sizeof(struct tee_cryp_state));\n\tif (!VAR_6)\n\t\treturn VAR_13;\n\tTAILQ_INSERT_TAIL(&VAR_10->cryp_states, VAR_6, VAR_14);\n\tVAR_6->algo = VAR_0;\n\tVAR_6->mode = VAR_1;\n\tVAR_6->state = VAR_15;\n\n\tswitch (TEE_ALG_GET_CLASS(VAR_0)) {\n\tcase VAR_16:\n#ifdef VAR_17\n\t\tif (VAR_0 == VAR_18)\n\t\t\tgoto rsassa_na1;\n#endif\n\t\tVAR_5 = VAR_19;\n\t\tbreak;\n\tcase VAR_20:\n\t\tif ((VAR_0 == VAR_21 && (VAR_2 == 0 || VAR_3 == 0)) ||\n\t\t    (VAR_0 != VAR_21 && (VAR_2 == 0 || VAR_3 != 0))) {\n\t\t\tVAR_5 = VAR_12;\n\t\t} else {\n\t\t\tVAR_5 = crypto_cipher_alloc_ctx(&VAR_6->ctx, VAR_0);\n\t\t\tif (VAR_5 != VAR_11)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase VAR_22:\n\t\tif (VAR_2 == 0 || VAR_3 != 0) {\n\t\t\tVAR_5 = VAR_12;\n\t\t} else {\n\t\t\tVAR_5 = crypto_authenc_alloc_ctx(&VAR_6->ctx, VAR_0);\n\t\t\tif (VAR_5 != VAR_11)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase VAR_23:\n\t\tif (VAR_2 == 0 || VAR_3 != 0) {\n\t\t\tVAR_5 = VAR_12;\n\t\t} else {\n\t\t\tVAR_5 = crypto_mac_alloc_ctx(&VAR_6->ctx, VAR_0);\n\t\t\tif (VAR_5 != VAR_11)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase VAR_24:\n\t\tif (VAR_2 != 0 || VAR_3 != 0) {\n\t\t\tVAR_5 = VAR_12;\n\t\t} else {\n\t\t\tVAR_5 = crypto_hash_alloc_ctx(&VAR_6->ctx, VAR_0);\n\t\t\tif (VAR_5 != VAR_11)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase VAR_25:\n\tcase VAR_26:\nrsassa_na1: VAR_27\n\t\tif (VAR_2 == 0 || VAR_3 != 0)\n\t\t\tVAR_5 = VAR_12;\n\t\tbreak;\n\tcase VAR_28:\n\t\tif (VAR_2 == 0 || VAR_3 != 0)\n\t\t\tVAR_5 = VAR_12;\n\t\tbreak;\n\tdefault:\n\t\tVAR_5 = VAR_19;\n\t\tbreak;\n\t}\n\tif (VAR_5 != VAR_11)\n\t\tgoto out;\n\n\tVAR_5 = tee_svc_copy_kaddr_to_uref(VAR_4, VAR_6);\n\tif (VAR_5 != VAR_11)\n\t\tgoto out;\n\n\t/* COMMENT_0 */\n\tif (VAR_8 != NULL) {\n\t\tVAR_8->busy = true;\n\t\tVAR_6->key1 = (vaddr_t)VAR_8;\n\t}\n\tif (VAR_9 != NULL) {\n\t\tVAR_9->busy = true;\n\t\tVAR_6->key2 = (vaddr_t)VAR_9;\n\t}\n\nout:\n\tif (VAR_5 != VAR_11)\n\t\tcryp_state_free(VAR_10, VAR_6);\n\treturn VAR_5;\n}",
  "func_graph_path": "OP-TEE/optee_os/34a08bec755670ea0490cb53bbc68058cafc69b6/tee_svc_cryp.c/vul/after/11.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -41,6 +41,7 @@\n \tTAILQ_INSERT_TAIL(&utc->cryp_states, cs, link);\n \tcs->algo = algo;\n \tcs->mode = mode;\n+\tcs->state = CRYP_STATE_UNINITIALIZED;\n \n \tswitch (TEE_ALG_GET_CLASS(algo)) {\n \tcase TEE_OPERATION_EXTENSION:",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "\tcs->state = CRYP_STATE_UNINITIALIZED;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/OP-TEE/optee_os/pull/3316",
  "description": {
    "pr_info": {
      "title": "Riscure fuzzer vuln",
      "number": 3316
    },
    "comment": [
      "Fixes for potential security issues found by Riscure's fuzzer tool.\r\n\r\nI've tested this in QEMU v7, no regressions seen.\r\n```bash\r\n24105 subtests of which 0 failed\r\n96 test cases of which 0 failed\r\n0 test cases were skipped\r\nTEE test application done!\r\n```",
      "Squashed, rebased and tag(s) applied (should be) ready for merge! Thanks!"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0  \n\nThe patch directly addresses a security issue identified by a fuzzer, preventing unauthorized function calls that could lead to crashes and sensitive information leaks. The code changes are consistent with the commit message, and there's a specific vulnerability reference, indicating a high confidence in this classification."
}