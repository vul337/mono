{
  "cve_id": "CVE-2022-40138",
  "cwe_ids": [
    "CWE-681"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "facebook/hermes",
  "commit_msg": "Re-sync with internal repository (#822)\n\nCo-authored-by: Facebook Community Bot <6422482+facebook-github-bot@users.noreply.github.com>",
  "commit_hash": "6aa825e480d48127b480b08d13adf70033237097",
  "git_url": "https://github.com/facebook/hermes/commit/6aa825e480d48127b480b08d13adf70033237097",
  "file_path": "lib/VM/Debugger/Debugger.cpp",
  "func_name": "Debugger::resolveBreakpointLocation",
  "func_before": "bool Debugger::resolveBreakpointLocation(Breakpoint &breakpoint) const {\n  using fhd::kInvalidLocation;\n  assert(!breakpoint.isResolved() && \"breakpoint already resolved\");\n\n  OptValue<hbc::DebugSearchResult> locationOpt{};\n\n#ifndef HERMESVM_LEAN\n  // If we could have lazy code blocks, compile them before we try to resolve.\n  // Eagerly compile code blocks that may contain the location.\n  // This is done using a search in which we enumerate all CodeBlocks in the\n  // runtime module, and we visit any code blocks which are lazy and check\n  // their ASTs to see if the breakpoint location is in them.\n  // Note that this works because we have the start and end locations\n  // exactly when a CodeBlock is lazy, because that's only when the AST exists.\n  // If it is, we compile the CodeBlock and start over,\n  // skipping any CodeBlocks we've seen before.\n  GCScope gcScope{runtime_};\n  for (auto &runtimeModule : runtime_.getRuntimeModules()) {\n    llvh::DenseSet<CodeBlock *> visited{};\n    std::vector<CodeBlock *> toVisit{};\n    for (uint32_t i = 0, e = runtimeModule.getNumCodeBlocks(); i < e; ++i) {\n      GCScopeMarkerRAII marker{gcScope};\n      // Use getCodeBlock to ensure they get initialized (but not compiled).\n      toVisit.push_back(runtimeModule.getCodeBlockMayAllocate(i));\n    }\n\n    while (!toVisit.empty()) {\n      GCScopeMarkerRAII marker{gcScope};\n      CodeBlock *codeBlock = toVisit.back();\n      toVisit.pop_back();\n\n      if (!codeBlock || !codeBlock->isLazy()) {\n        // When looking for a lazy code block to expand,\n        // there's no point looking at the non-lazy ones.\n        continue;\n      }\n\n      if (visited.count(codeBlock) > 0) {\n        // We've already been here.\n        continue;\n      }\n\n      visited.insert(codeBlock);\n      auto start = codeBlock->getLazyFunctionStartLoc();\n      auto end = codeBlock->getLazyFunctionEndLoc();\n\n      const auto &request = breakpoint.requestedLocation;\n      if ((start.line < request.line && request.line < end.line) ||\n          ((start.line == request.line || request.line == end.line) &&\n           (start.col <= request.column && request.column <= end.col))) {\n        // The code block probably contains the breakpoint we want to set.\n        // First, we compile it.\n        codeBlock->lazyCompile(runtime_);\n\n        // We've found the codeBlock at this level and expanded it,\n        // so there's no point continuing the search.\n        // Abandon the current toVisit queue and repopulate it.\n        toVisit.clear();\n\n        // Compiling the function will add more functions to the runtimeModule.\n        // Re-add them all so we can continue the search.\n        for (uint32_t i = 0, e = runtimeModule.getNumCodeBlocks(); i < e; ++i) {\n          GCScopeMarkerRAII marker2{gcScope};\n          // Use getCodeBlock to ensure they get initialized (but not compiled).\n          toVisit.push_back(runtimeModule.getCodeBlockMayAllocate(i));\n        }\n      }\n    }\n  }\n#endif\n\n  // Iterate backwards through runtime modules, under the assumption that\n  // modules at the end of the list were added more recently, and are more\n  // likely to match the user's intention.\n  // Specifically, this will check any user source before runtime modules loaded\n  // by the VM.\n  for (auto it = runtime_.getRuntimeModules().rbegin();\n       it != runtime_.getRuntimeModules().rend();\n       ++it) {\n    auto &runtimeModule = *it;\n    GCScope gcScope{runtime_};\n\n    if (!runtimeModule.isInitialized()) {\n      // Uninitialized module.\n      continue;\n    }\n    if (!runtimeModule.getBytecode()->getDebugInfo()) {\n      // No debug info in this module, keep going.\n      continue;\n    }\n\n    const auto *debugInfo = runtimeModule.getBytecode()->getDebugInfo();\n    const auto &fileRegions = debugInfo->viewFiles();\n    if (fileRegions.empty()) {\n      continue;\n    }\n\n    uint32_t resolvedFileId = kInvalidLocation;\n    std::string resolvedFileName{};\n\n    if (!breakpoint.requestedLocation.fileName.empty()) {\n      for (const auto &region : fileRegions) {\n        std::string storage =\n            getFileNameAsUTF8(runtime_, &runtimeModule, region.filenameId);\n        llvh::StringRef storageRef{storage};\n        if (storageRef.consume_back(breakpoint.requestedLocation.fileName)) {\n          resolvedFileId = region.filenameId;\n          resolvedFileName = std::move(storage);\n          break;\n        }\n      }\n    } else if (breakpoint.requestedLocation.fileId != kInvalidLocation) {\n      for (const auto &region : fileRegions) {\n        // We don't yet have a convincing story for debugging CommonJS, so for\n        // now just assert that we're still living in the one-file-per-RM world.\n        // TODO(T84976604): Properly handle setting breakpoints when there are\n        // multiple JS files per HBC file.\n        assert(\n            region.filenameId == 0 && \"Unexpected multiple filenames per RM\");\n        if (resolveScriptId(&runtimeModule, region.filenameId) ==\n            breakpoint.requestedLocation.fileId) {\n          resolvedFileId = region.filenameId;\n          resolvedFileName =\n              getFileNameAsUTF8(runtime_, &runtimeModule, resolvedFileId);\n          break;\n        }\n      }\n    } else {\n      // No requested file, just pick the first one.\n      resolvedFileId = fileRegions.front().filenameId;\n      resolvedFileName =\n          getFileNameAsUTF8(runtime_, &runtimeModule, resolvedFileId);\n    }\n\n    if (resolvedFileId == kInvalidLocation) {\n      // Unable to find the file here.\n      continue;\n    }\n\n    locationOpt = debugInfo->getAddressForLocation(\n        resolvedFileId,\n        breakpoint.requestedLocation.line,\n        breakpoint.requestedLocation.column == kInvalidLocation\n            ? llvh::None\n            : OptValue<uint32_t>{breakpoint.requestedLocation.column});\n\n    if (locationOpt.hasValue()) {\n      breakpoint.codeBlock =\n          runtimeModule.getCodeBlockMayAllocate(locationOpt->functionIndex);\n      breakpoint.offset = locationOpt->bytecodeOffset;\n\n      SourceLocation resolvedLocation;\n      resolvedLocation.line = locationOpt->line;\n      resolvedLocation.column = locationOpt->column;\n      resolvedLocation.fileId = resolveScriptId(&runtimeModule, resolvedFileId);\n      resolvedLocation.fileName = std::move(resolvedFileName);\n      breakpoint.resolvedLocation = resolvedLocation;\n      return true;\n    }\n  }\n\n  return false;\n}",
  "abstract_func_before": "bool Debugger::resolveBreakpointLocation(Breakpoint &VAR_0) const {\n  using fhd::kInvalidLocation;\n  assert(!VAR_0.isResolved() && \"breakpoint already resolved\");\n\n  OptValue<hbc::DebugSearchResult> VAR_1{};\n\n#ifndef VAR_2\n  /* COMMENT_0 */\n  /* COMMENT_1 */\n  /* COMMENT_2 */\n  /* COMMENT_3 */\n  /* COMMENT_4 */\n  /* COMMENT_5 */\n  /* COMMENT_6 */\n  /* COMMENT_7 */\n  /* COMMENT_8 */\n  GCScope VAR_3{VAR_4};\n  for (auto &VAR_5 : VAR_4.getRuntimeModules()) {\n    llvh::DenseSet<CodeBlock *> VAR_6{};\n    std::vector<CodeBlock *> VAR_7{};\n    for (uint32_t VAR_8 = 0, VAR_9 = VAR_5.getNumCodeBlocks(); VAR_8 < VAR_9; ++VAR_8) {\n      GCScopeMarkerRAII VAR_10{VAR_3};\n      /* COMMENT_9 */\n      VAR_7.push_back(VAR_5.getCodeBlockMayAllocate(VAR_8));\n    }\n\n    while (!VAR_7.empty()) {\n      GCScopeMarkerRAII VAR_10{VAR_3};\n      CodeBlock *VAR_11 = VAR_7.back();\n      VAR_7.pop_back();\n\n      if (!VAR_11 || !VAR_11->isLazy()) {\n        /* COMMENT_10 */\n        /* COMMENT_11 */\n        continue;\n      }\n\n      if (VAR_6.count(VAR_11) > 0) {\n        /* COMMENT_12 */\n        continue;\n      }\n\n      VAR_6.insert(VAR_11);\n      auto VAR_12 = VAR_11->getLazyFunctionStartLoc();\n      auto VAR_13 = VAR_11->getLazyFunctionEndLoc();\n\n      const auto &VAR_14 = VAR_0.requestedLocation;\n      if ((VAR_12.line < VAR_14.line && VAR_14.line < VAR_13.line) ||\n          ((VAR_12.line == VAR_14.line || VAR_14.line == VAR_13.line) &&\n           (VAR_12.col <= VAR_14.column && VAR_14.column <= VAR_13.col))) {\n        /* COMMENT_13 */\n        /* COMMENT_14 */\n        VAR_11->lazyCompile(VAR_4);\n\n        /* COMMENT_15 */\n        /* COMMENT_16 */\n        /* COMMENT_17 */\n        VAR_7.clear();\n\n        /* COMMENT_18 */\n        /* COMMENT_19 */\n        for (uint32_t VAR_8 = 0, VAR_9 = VAR_5.getNumCodeBlocks(); VAR_8 < VAR_9; ++VAR_8) {\n          GCScopeMarkerRAII VAR_15{VAR_3};\n          /* COMMENT_9 */\n          VAR_7.push_back(VAR_5.getCodeBlockMayAllocate(VAR_8));\n        }\n      }\n    }\n  }\n#endif\n\n  /* COMMENT_20 */\n  /* COMMENT_21 */\n  /* COMMENT_22 */\n  /* COMMENT_23 */\n  /* COMMENT_24 */\n  for (auto VAR_16 = VAR_4.getRuntimeModules().rbegin();\n       VAR_16 != VAR_4.getRuntimeModules().rend();\n       ++VAR_16) {\n    auto &VAR_5 = *VAR_16;\n    GCScope VAR_3{VAR_4};\n\n    if (!VAR_5.isInitialized()) {\n      /* COMMENT_25 */\n      continue;\n    }\n    if (!VAR_5.getBytecode()->getDebugInfo()) {\n      /* COMMENT_26 */\n      continue;\n    }\n\n    const auto *VAR_17 = VAR_5.getBytecode()->getDebugInfo();\n    const auto &VAR_18 = VAR_17->viewFiles();\n    if (VAR_18.empty()) {\n      continue;\n    }\n\n    uint32_t VAR_19 = VAR_20;\n    std::string VAR_21{};\n\n    if (!VAR_0.requestedLocation.fileName.empty()) {\n      for (const auto &VAR_22 : VAR_18) {\n        std::string VAR_23 =\n            getFileNameAsUTF8(VAR_4, &VAR_5, VAR_22.filenameId);\n        llvh::StringRef VAR_24{VAR_23};\n        if (VAR_24.consume_back(VAR_0.requestedLocation.fileName)) {\n          VAR_19 = VAR_22.filenameId;\n          VAR_21 = std::move(VAR_23);\n          break;\n        }\n      }\n    } else if (VAR_0.requestedLocation.fileId != VAR_20) {\n      for (const auto &VAR_22 : VAR_18) {\n        /* COMMENT_27 */\n        /* COMMENT_28 */\n        /* COMMENT_29 */\n        /* COMMENT_30 */\n        assert(\n            VAR_22.filenameId == 0 && \"Unexpected multiple filenames per RM\");\n        if (resolveScriptId(&VAR_5, VAR_22.filenameId) ==\n            VAR_0.requestedLocation.fileId) {\n          VAR_19 = VAR_22.filenameId;\n          VAR_21 =\n              getFileNameAsUTF8(VAR_4, &VAR_5, VAR_19);\n          break;\n        }\n      }\n    } else {\n      /* COMMENT_31 */\n      VAR_19 = VAR_18.front().filenameId;\n      VAR_21 =\n          getFileNameAsUTF8(VAR_4, &VAR_5, VAR_19);\n    }\n\n    if (VAR_19 == VAR_20) {\n      /* COMMENT_32 */\n      continue;\n    }\n\n    VAR_1 = VAR_17->getAddressForLocation(\n        VAR_19,\n        VAR_0.requestedLocation.line,\n        VAR_0.requestedLocation.column == VAR_20\n            ? llvh::None\n            : OptValue<uint32_t>{VAR_0.requestedLocation.column});\n\n    if (VAR_1.hasValue()) {\n      VAR_0.codeBlock =\n          VAR_5.getCodeBlockMayAllocate(VAR_1->functionIndex);\n      VAR_0.offset = VAR_1->bytecodeOffset;\n\n      SourceLocation VAR_25;\n      VAR_25.line = VAR_1->line;\n      VAR_25.column = VAR_1->column;\n      VAR_25.fileId = resolveScriptId(&VAR_5, VAR_19);\n      VAR_25.fileName = std::move(VAR_21);\n      VAR_0.resolvedLocation = VAR_25;\n      return true;\n    }\n  }\n\n  return false;\n}",
  "func_graph_path_before": "facebook/hermes/6aa825e480d48127b480b08d13adf70033237097/Debugger.cpp/vul/before/0.json",
  "func": "bool Debugger::resolveBreakpointLocation(Breakpoint &breakpoint) const {\n  using fhd::kInvalidLocation;\n  assert(!breakpoint.isResolved() && \"breakpoint already resolved\");\n\n  OptValue<hbc::DebugSearchResult> locationOpt{};\n\n#ifndef HERMESVM_LEAN\n  // If we could have lazy code blocks, compile them before we try to resolve.\n  // Eagerly compile code blocks that may contain the location.\n  // This is done using a search in which we enumerate all CodeBlocks in the\n  // runtime module, and we visit any code blocks which are lazy and check\n  // their ASTs to see if the breakpoint location is in them.\n  // Note that this works because we have the start and end locations\n  // exactly when a CodeBlock is lazy, because that's only when the AST exists.\n  // If it is, we compile the CodeBlock and start over,\n  // skipping any CodeBlocks we've seen before.\n  GCScope gcScope{runtime_};\n  for (auto &runtimeModule : runtime_.getRuntimeModules()) {\n    llvh::DenseSet<CodeBlock *> visited{};\n    std::vector<CodeBlock *> toVisit{};\n    for (uint32_t i = 0, e = runtimeModule.getNumCodeBlocks(); i < e; ++i) {\n      GCScopeMarkerRAII marker{gcScope};\n      // Use getCodeBlock to ensure they get initialized (but not compiled).\n      toVisit.push_back(runtimeModule.getCodeBlockMayAllocate(i));\n    }\n\n    while (!toVisit.empty()) {\n      GCScopeMarkerRAII marker{gcScope};\n      CodeBlock *codeBlock = toVisit.back();\n      toVisit.pop_back();\n\n      if (!codeBlock || !codeBlock->isLazy()) {\n        // When looking for a lazy code block to expand,\n        // there's no point looking at the non-lazy ones.\n        continue;\n      }\n\n      if (visited.count(codeBlock) > 0) {\n        // We've already been here.\n        continue;\n      }\n\n      visited.insert(codeBlock);\n      auto start = codeBlock->getLazyFunctionStartLoc();\n      auto end = codeBlock->getLazyFunctionEndLoc();\n\n      const auto &request = breakpoint.requestedLocation;\n      if ((start.line < request.line && request.line < end.line) ||\n          ((start.line == request.line || request.line == end.line) &&\n           (start.col <= request.column && request.column <= end.col))) {\n        // The code block probably contains the breakpoint we want to set.\n        // First, we compile it.\n        if (LLVM_UNLIKELY(\n                codeBlock->lazyCompile(runtime_) ==\n                ExecutionStatus::EXCEPTION)) {\n          // TODO: how to better handle this?\n          runtime_.clearThrownValue();\n        }\n\n        // We've found the codeBlock at this level and expanded it,\n        // so there's no point continuing the search.\n        // Abandon the current toVisit queue and repopulate it.\n        toVisit.clear();\n\n        // Compiling the function will add more functions to the runtimeModule.\n        // Re-add them all so we can continue the search.\n        for (uint32_t i = 0, e = runtimeModule.getNumCodeBlocks(); i < e; ++i) {\n          GCScopeMarkerRAII marker2{gcScope};\n          // Use getCodeBlock to ensure they get initialized (but not compiled).\n          toVisit.push_back(runtimeModule.getCodeBlockMayAllocate(i));\n        }\n      }\n    }\n  }\n#endif\n\n  // Iterate backwards through runtime modules, under the assumption that\n  // modules at the end of the list were added more recently, and are more\n  // likely to match the user's intention.\n  // Specifically, this will check any user source before runtime modules loaded\n  // by the VM.\n  for (auto it = runtime_.getRuntimeModules().rbegin();\n       it != runtime_.getRuntimeModules().rend();\n       ++it) {\n    auto &runtimeModule = *it;\n    GCScope gcScope{runtime_};\n\n    if (!runtimeModule.isInitialized()) {\n      // Uninitialized module.\n      continue;\n    }\n    if (!runtimeModule.getBytecode()->getDebugInfo()) {\n      // No debug info in this module, keep going.\n      continue;\n    }\n\n    const auto *debugInfo = runtimeModule.getBytecode()->getDebugInfo();\n    const auto &fileRegions = debugInfo->viewFiles();\n    if (fileRegions.empty()) {\n      continue;\n    }\n\n    uint32_t resolvedFileId = kInvalidLocation;\n    std::string resolvedFileName{};\n\n    if (!breakpoint.requestedLocation.fileName.empty()) {\n      for (const auto &region : fileRegions) {\n        std::string storage =\n            getFileNameAsUTF8(runtime_, &runtimeModule, region.filenameId);\n        llvh::StringRef storageRef{storage};\n        if (storageRef.consume_back(breakpoint.requestedLocation.fileName)) {\n          resolvedFileId = region.filenameId;\n          resolvedFileName = std::move(storage);\n          break;\n        }\n      }\n    } else if (breakpoint.requestedLocation.fileId != kInvalidLocation) {\n      for (const auto &region : fileRegions) {\n        // We don't yet have a convincing story for debugging CommonJS, so for\n        // now just assert that we're still living in the one-file-per-RM world.\n        // TODO(T84976604): Properly handle setting breakpoints when there are\n        // multiple JS files per HBC file.\n        assert(\n            region.filenameId == 0 && \"Unexpected multiple filenames per RM\");\n        if (resolveScriptId(&runtimeModule, region.filenameId) ==\n            breakpoint.requestedLocation.fileId) {\n          resolvedFileId = region.filenameId;\n          resolvedFileName =\n              getFileNameAsUTF8(runtime_, &runtimeModule, resolvedFileId);\n          break;\n        }\n      }\n    } else {\n      // No requested file, just pick the first one.\n      resolvedFileId = fileRegions.front().filenameId;\n      resolvedFileName =\n          getFileNameAsUTF8(runtime_, &runtimeModule, resolvedFileId);\n    }\n\n    if (resolvedFileId == kInvalidLocation) {\n      // Unable to find the file here.\n      continue;\n    }\n\n    locationOpt = debugInfo->getAddressForLocation(\n        resolvedFileId,\n        breakpoint.requestedLocation.line,\n        breakpoint.requestedLocation.column == kInvalidLocation\n            ? llvh::None\n            : OptValue<uint32_t>{breakpoint.requestedLocation.column});\n\n    if (locationOpt.hasValue()) {\n      breakpoint.codeBlock =\n          runtimeModule.getCodeBlockMayAllocate(locationOpt->functionIndex);\n      breakpoint.offset = locationOpt->bytecodeOffset;\n\n      SourceLocation resolvedLocation;\n      resolvedLocation.line = locationOpt->line;\n      resolvedLocation.column = locationOpt->column;\n      resolvedLocation.fileId = resolveScriptId(&runtimeModule, resolvedFileId);\n      resolvedLocation.fileName = std::move(resolvedFileName);\n      breakpoint.resolvedLocation = resolvedLocation;\n      return true;\n    }\n  }\n\n  return false;\n}",
  "abstract_func": "bool Debugger::resolveBreakpointLocation(Breakpoint &VAR_0) const {\n  using fhd::kInvalidLocation;\n  assert(!VAR_0.isResolved() && \"breakpoint already resolved\");\n\n  OptValue<hbc::DebugSearchResult> VAR_1{};\n\n#ifndef VAR_2\n  /* COMMENT_0 */\n  /* COMMENT_1 */\n  /* COMMENT_2 */\n  /* COMMENT_3 */\n  /* COMMENT_4 */\n  /* COMMENT_5 */\n  /* COMMENT_6 */\n  /* COMMENT_7 */\n  /* COMMENT_8 */\n  GCScope VAR_3{VAR_4};\n  for (auto &VAR_5 : VAR_4.getRuntimeModules()) {\n    llvh::DenseSet<CodeBlock *> VAR_6{};\n    std::vector<CodeBlock *> VAR_7{};\n    for (uint32_t VAR_8 = 0, VAR_9 = VAR_5.getNumCodeBlocks(); VAR_8 < VAR_9; ++VAR_8) {\n      GCScopeMarkerRAII VAR_10{VAR_3};\n      /* COMMENT_9 */\n      VAR_7.push_back(VAR_5.getCodeBlockMayAllocate(VAR_8));\n    }\n\n    while (!VAR_7.empty()) {\n      GCScopeMarkerRAII VAR_10{VAR_3};\n      CodeBlock *VAR_11 = VAR_7.back();\n      VAR_7.pop_back();\n\n      if (!VAR_11 || !VAR_11->isLazy()) {\n        /* COMMENT_10 */\n        /* COMMENT_11 */\n        continue;\n      }\n\n      if (VAR_6.count(VAR_11) > 0) {\n        /* COMMENT_12 */\n        continue;\n      }\n\n      VAR_6.insert(VAR_11);\n      auto VAR_12 = VAR_11->getLazyFunctionStartLoc();\n      auto VAR_13 = VAR_11->getLazyFunctionEndLoc();\n\n      const auto &VAR_14 = VAR_0.requestedLocation;\n      if ((VAR_12.line < VAR_14.line && VAR_14.line < VAR_13.line) ||\n          ((VAR_12.line == VAR_14.line || VAR_14.line == VAR_13.line) &&\n           (VAR_12.col <= VAR_14.column && VAR_14.column <= VAR_13.col))) {\n        /* COMMENT_13 */\n        /* COMMENT_14 */\n        if (LLVM_UNLIKELY(\n                VAR_11->lazyCompile(VAR_4) ==\n                ExecutionStatus::EXCEPTION)) {\n          /* COMMENT_15 */\n          VAR_4.clearThrownValue();\n        }\n\n        /* COMMENT_16 */\n        /* COMMENT_17 */\n        /* COMMENT_18 */\n        VAR_7.clear();\n\n        /* COMMENT_19 */\n        /* COMMENT_20 */\n        for (uint32_t VAR_8 = 0, VAR_9 = VAR_5.getNumCodeBlocks(); VAR_8 < VAR_9; ++VAR_8) {\n          GCScopeMarkerRAII VAR_15{VAR_3};\n          /* COMMENT_9 */\n          VAR_7.push_back(VAR_5.getCodeBlockMayAllocate(VAR_8));\n        }\n      }\n    }\n  }\n#endif\n\n  /* COMMENT_21 */\n  /* COMMENT_22 */\n  /* COMMENT_23 */\n  /* COMMENT_24 */\n  /* COMMENT_25 */\n  for (auto VAR_16 = VAR_4.getRuntimeModules().rbegin();\n       VAR_16 != VAR_4.getRuntimeModules().rend();\n       ++VAR_16) {\n    auto &VAR_5 = *VAR_16;\n    GCScope VAR_3{VAR_4};\n\n    if (!VAR_5.isInitialized()) {\n      /* COMMENT_26 */\n      continue;\n    }\n    if (!VAR_5.getBytecode()->getDebugInfo()) {\n      /* COMMENT_27 */\n      continue;\n    }\n\n    const auto *VAR_17 = VAR_5.getBytecode()->getDebugInfo();\n    const auto &VAR_18 = VAR_17->viewFiles();\n    if (VAR_18.empty()) {\n      continue;\n    }\n\n    uint32_t VAR_19 = VAR_20;\n    std::string VAR_21{};\n\n    if (!VAR_0.requestedLocation.fileName.empty()) {\n      for (const auto &VAR_22 : VAR_18) {\n        std::string VAR_23 =\n            getFileNameAsUTF8(VAR_4, &VAR_5, VAR_22.filenameId);\n        llvh::StringRef VAR_24{VAR_23};\n        if (VAR_24.consume_back(VAR_0.requestedLocation.fileName)) {\n          VAR_19 = VAR_22.filenameId;\n          VAR_21 = std::move(VAR_23);\n          break;\n        }\n      }\n    } else if (VAR_0.requestedLocation.fileId != VAR_20) {\n      for (const auto &VAR_22 : VAR_18) {\n        /* COMMENT_28 */\n        /* COMMENT_29 */\n        /* COMMENT_30 */\n        /* COMMENT_31 */\n        assert(\n            VAR_22.filenameId == 0 && \"Unexpected multiple filenames per RM\");\n        if (resolveScriptId(&VAR_5, VAR_22.filenameId) ==\n            VAR_0.requestedLocation.fileId) {\n          VAR_19 = VAR_22.filenameId;\n          VAR_21 =\n              getFileNameAsUTF8(VAR_4, &VAR_5, VAR_19);\n          break;\n        }\n      }\n    } else {\n      /* COMMENT_32 */\n      VAR_19 = VAR_18.front().filenameId;\n      VAR_21 =\n          getFileNameAsUTF8(VAR_4, &VAR_5, VAR_19);\n    }\n\n    if (VAR_19 == VAR_20) {\n      /* COMMENT_33 */\n      continue;\n    }\n\n    VAR_1 = VAR_17->getAddressForLocation(\n        VAR_19,\n        VAR_0.requestedLocation.line,\n        VAR_0.requestedLocation.column == VAR_20\n            ? llvh::None\n            : OptValue<uint32_t>{VAR_0.requestedLocation.column});\n\n    if (VAR_1.hasValue()) {\n      VAR_0.codeBlock =\n          VAR_5.getCodeBlockMayAllocate(VAR_1->functionIndex);\n      VAR_0.offset = VAR_1->bytecodeOffset;\n\n      SourceLocation VAR_25;\n      VAR_25.line = VAR_1->line;\n      VAR_25.column = VAR_1->column;\n      VAR_25.fileId = resolveScriptId(&VAR_5, VAR_19);\n      VAR_25.fileName = std::move(VAR_21);\n      VAR_0.resolvedLocation = VAR_25;\n      return true;\n    }\n  }\n\n  return false;\n}",
  "func_graph_path": "facebook/hermes/6aa825e480d48127b480b08d13adf70033237097/Debugger.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -50,7 +50,12 @@\n            (start.col <= request.column && request.column <= end.col))) {\n         // The code block probably contains the breakpoint we want to set.\n         // First, we compile it.\n-        codeBlock->lazyCompile(runtime_);\n+        if (LLVM_UNLIKELY(\n+                codeBlock->lazyCompile(runtime_) ==\n+                ExecutionStatus::EXCEPTION)) {\n+          // TODO: how to better handle this?\n+          runtime_.clearThrownValue();\n+        }\n \n         // We've found the codeBlock at this level and expanded it,\n         // so there's no point continuing the search.",
  "diff_line_info": {
    "deleted_lines": [
      "        codeBlock->lazyCompile(runtime_);"
    ],
    "added_lines": [
      "        if (LLVM_UNLIKELY(",
      "                codeBlock->lazyCompile(runtime_) ==",
      "                ExecutionStatus::EXCEPTION)) {",
      "          // TODO: how to better handle this?",
      "          runtime_.clearThrownValue();",
      "        }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/facebook/hermes/pull/822",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/facebook/hermes/pull/822: 403 Client Error: Forbidden for url: https://api.github.com/repos/facebook/hermes/pulls/822",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.85,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.85"
}