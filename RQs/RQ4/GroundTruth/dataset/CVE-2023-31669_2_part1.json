{
  "cve_id": "CVE-2023-31669",
  "cwe_ids": [
    "CWE-116"
  ],
  "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "WebAssembly/wabt",
  "commit_msg": "Improve lexing and parsing of invalid annotations (again)\n\nThis adds a bounds-check to WastLexer::GetText to handle the case when\nthe offset is earlier than token_start (e.g. because GetStringToken\nfound a newline in the string and reset token_start to point at it).\n\nAlso revises GetIdToken -> GetIdChars to stop skipping the initial char\nin an annotation delimiter, which is an idchar+ but not an id token.\n\nAlso fixes the WastParser to handle EOF when reading for the end of an\nannotation, both for code metadata annotations and other kinds.\nPreviously this produced an infinite loop (but only with\n--enable-annotations).\n\nFixes #2165",
  "commit_hash": "44491a4b0fdb2d2bd87a151fd169da3343954edd",
  "git_url": "https://github.com/WebAssembly/wabt/commit/44491a4b0fdb2d2bd87a151fd169da3343954edd",
  "file_path": "src/wast-lexer.cc",
  "func_name": "WastLexer::GetText",
  "func_before": "std::string_view WastLexer::GetText(size_t offset) {\n  return std::string_view(token_start_ + offset,\n                          (cursor_ - token_start_) - offset);\n}",
  "abstract_func_before": "std::string_view WastLexer::GetText(size_t VAR_0) {\n  return std::string_view(VAR_1 + VAR_0,\n                          (VAR_2 - VAR_1) - VAR_0);\n}",
  "func_graph_path_before": "WebAssembly/wabt/44491a4b0fdb2d2bd87a151fd169da3343954edd/wast-lexer.cc/vul/before/1.json",
  "func": "std::string_view WastLexer::GetText(size_t offset) {\n  // Bounds checks are necessary because token_start may have been moved\n  // (e.g. if GetStringToken found a newline and reset token_start to\n  // point at it).\n\n  if (token_start_ + offset >= buffer_end_)\n    return {};\n\n  if (cursor_ <= token_start_ + offset)\n    return {};\n\n  return std::string_view(token_start_ + offset,\n                          (cursor_ - token_start_) - offset);\n}",
  "abstract_func": "std::string_view WastLexer::GetText(size_t VAR_0) {\n  /* COMMENT_0 */\n  /* COMMENT_1 */\n  /* COMMENT_2 */\n\n  if (VAR_1 + VAR_0 >= VAR_2)\n    return {};\n\n  if (VAR_3 <= VAR_1 + VAR_0)\n    return {};\n\n  return std::string_view(VAR_1 + VAR_0,\n                          (VAR_3 - VAR_1) - VAR_0);\n}",
  "func_graph_path": "WebAssembly/wabt/44491a4b0fdb2d2bd87a151fd169da3343954edd/wast-lexer.cc/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,14 @@\n std::string_view WastLexer::GetText(size_t offset) {\n+  // Bounds checks are necessary because token_start may have been moved\n+  // (e.g. if GetStringToken found a newline and reset token_start to\n+  // point at it).\n+\n+  if (token_start_ + offset >= buffer_end_)\n+    return {};\n+\n+  if (cursor_ <= token_start_ + offset)\n+    return {};\n+\n   return std::string_view(token_start_ + offset,\n                           (cursor_ - token_start_) - offset);\n }",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "  // Bounds checks are necessary because token_start may have been moved",
      "  // (e.g. if GetStringToken found a newline and reset token_start to",
      "  // point at it).",
      "",
      "  if (token_start_ + offset >= buffer_end_)",
      "    return {};",
      "",
      "  if (cursor_ <= token_start_ + offset)",
      "    return {};",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/WebAssembly/wabt/pull/2166",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/WebAssembly/wabt/pull/2166: 403 Client Error: Forbidden for url: https://api.github.com/repos/WebAssembly/wabt/pulls/2166",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.9  \n\nThe patch addresses bugs in the lexing and parsing of invalid annotations by adding bounds checks and fixing infinite loops. While it improves the code's robustness, it doesn't explicitly fix a security vulnerability. The bounds checks are crucial but fall under bug fixes rather than security issues without an exploit context."
}