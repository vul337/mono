{
  "cve_id": "CVE-2023-40032",
  "cwe_ids": [
    "CWE-476"
  ],
  "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "libvips",
  "commit_msg": "svgload: fix null-pointer dereference (#3604)\n\n`g_utf8_find_next_char()` might return NULL when called with a\r\nnon-NULL second argument, indicating that the end of the string\r\nhas been reached.",
  "commit_hash": "e091d65835966ef56d53a4105a7362cafdb1582b",
  "git_url": "https://github.com/libvips/libvips/commit/e091d65835966ef56d53a4105a7362cafdb1582b",
  "file_path": "libvips/foreign/svgload.c",
  "func_name": "vips_utf8_strcasestr",
  "func_before": "static const char *\nvips_utf8_strcasestr( const char *haystack_start, const char *needle_start, \n\tint len_bytes )\n{\n        int needle_len = g_utf8_strlen( needle_start, -1 );\n        int needle_len_bytes = strlen( needle_start );\n\n\tconst char *haystack;\n\n\tfor( haystack = haystack_start; \n\t\thaystack - haystack_start <= len_bytes - needle_len_bytes; \n\t\thaystack = g_utf8_find_next_char( haystack, NULL ) ) {\n                const char *needle_char;\n                const char *haystack_char;\n\t\tint i;\n\n                haystack_char = haystack;\n                needle_char = needle_start;\n                for( i = 0; i < needle_len; i++ ) {\n\t\t\t/* Haystack isn't necessarily null-terminated and\n\t\t\t * might end half-way through a utf-8 character, so we\n\t\t\t * need to be careful not to run off the end.\n\t\t\t */\n                        gunichar a = \n\t\t\t\tg_utf8_get_char_validated( haystack_char, \n\t\t\t\t\thaystack_start + len_bytes - haystack );\n                        gunichar b = \n\t\t\t\tg_utf8_get_char_validated( needle_char, -1 );\n\n                        /* Invalid utf8? \n\t\t\t *\n\t\t\t * gunichar is a uint32, so we can't compare < 0, we \n\t\t\t * have to look for -1 and -2 (the two possible error \n\t\t\t * values).\n                         */\n                        if( a == (gunichar) -1 ||\n\t\t\t\ta == (gunichar) -2 ||\n\t\t\t\tb == (gunichar) -1 ||\n\t\t\t\tb == (gunichar) -2 )\n                                return( NULL );\n\n                        /* End of haystack. There can't be a complete needle\n                         * anywhere.\n                         */\n                        if( a == (gunichar) 0 )\n                                return( NULL );\n\n                        /* Mismatch.\n                         */\n                        if( g_unichar_tolower( a ) != g_unichar_tolower( b ) )\n                                break;\n\n                        haystack_char = \n\t\t\t\tg_utf8_find_next_char( haystack_char, \n\t\t\t\t\thaystack_start + len_bytes );\n                        needle_char = \n\t\t\t\tg_utf8_find_next_char( needle_char, NULL );\n                }\n\n                if( i == needle_len )\n\t\t\t/* Walked the whole of needle, so we must have found a \n\t\t\t * complete match.\n\t\t\t */\n                        return( haystack );\n        }\n\n        /* Walked the whole of haystack without finding a match.\n         */\n        return( NULL );\n}",
  "abstract_func_before": "static const char *\nvips_utf8_strcasestr( const char *VAR_0, const char *VAR_1, \n\tint VAR_2 )\n{\n        int VAR_3 = g_utf8_strlen( VAR_1, -1 );\n        int VAR_4 = strlen( VAR_1 );\n\n\tconst char *VAR_5;\n\n\tfor( VAR_5 = VAR_0; \n\t\tVAR_5 - VAR_0 <= VAR_2 - VAR_4; \n\t\tVAR_5 = g_utf8_find_next_char( VAR_5, NULL ) ) {\n                const char *VAR_6;\n                const char *VAR_7;\n\t\tint VAR_8;\n\n                VAR_7 = VAR_5;\n                VAR_6 = VAR_1;\n                for( VAR_8 = 0; VAR_8 < VAR_3; VAR_8++ ) {\n\t\t\t/* COMMENT_0 */\n                                                         \n                                                \n      \n                        gunichar VAR_9 = \n\t\t\t\tg_utf8_get_char_validated( VAR_7, \n\t\t\t\t\tVAR_0 + VAR_2 - VAR_5 );\n                        gunichar VAR_10 = \n\t\t\t\tg_utf8_get_char_validated( VAR_6, -1 );\n\n                        /* COMMENT_4 */\n     \n                                                        \n                                                         \n              \n                           \n                        if( VAR_9 == (gunichar) -1 ||\n\t\t\t\tVAR_9 == (gunichar) -2 ||\n\t\t\t\tVAR_10 == (gunichar) -1 ||\n\t\t\t\tVAR_10 == (gunichar) -2 )\n                                return( NULL );\n\n                        /* COMMENT_10 */\n                                    \n                           \n                        if( VAR_9 == (gunichar) 0 )\n                                return( NULL );\n\n                        /* COMMENT_13 */\n                           \n                        if( g_unichar_tolower( VAR_9 ) != g_unichar_tolower( VAR_10 ) )\n                                break;\n\n                        VAR_7 = \n\t\t\t\tg_utf8_find_next_char( VAR_7, \n\t\t\t\t\tVAR_0 + VAR_2 );\n                        VAR_6 = \n\t\t\t\tg_utf8_find_next_char( VAR_6, NULL );\n                }\n\n                if( VAR_8 == VAR_3 )\n\t\t\t/* COMMENT_15 */\n                     \n      \n                        return( VAR_5 );\n        }\n\n        /* COMMENT_18 */\n           \n        return( NULL );\n}",
  "func_graph_path_before": "libvips/e091d65835966ef56d53a4105a7362cafdb1582b/svgload.c/vul/before/0.json",
  "func": "static const char *\nvips_utf8_strcasestr( const char *haystack_start, const char *needle_start, \n\tint len_bytes )\n{\n        int needle_len = g_utf8_strlen( needle_start, -1 );\n        int needle_len_bytes = strlen( needle_start );\n\n\tconst char *haystack;\n\n\tfor( haystack = haystack_start; \n\t\thaystack - haystack_start <= len_bytes - needle_len_bytes; \n\t\thaystack = g_utf8_find_next_char( haystack, NULL ) ) {\n                const char *needle_char;\n                const char *haystack_char;\n\t\tint i;\n\n                haystack_char = haystack;\n                needle_char = needle_start;\n                for( i = 0; i < needle_len; i++ ) {\n\t\t\t/* Haystack isn't necessarily null-terminated and\n\t\t\t * might end half-way through a utf-8 character, so we\n\t\t\t * need to be careful not to run off the end.\n\t\t\t */\n                        gunichar a = \n\t\t\t\tg_utf8_get_char_validated( haystack_char, \n\t\t\t\t\thaystack_start + len_bytes - haystack );\n                        gunichar b = \n\t\t\t\tg_utf8_get_char_validated( needle_char, -1 );\n\n                        /* Invalid utf8? \n\t\t\t *\n\t\t\t * gunichar is a uint32, so we can't compare < 0, we \n\t\t\t * have to look for -1 and -2 (the two possible error \n\t\t\t * values).\n                         */\n                        if( a == (gunichar) -1 ||\n\t\t\t\ta == (gunichar) -2 ||\n\t\t\t\tb == (gunichar) -1 ||\n\t\t\t\tb == (gunichar) -2 )\n                                return( NULL );\n\n                        /* Disallow codepoint U+0000 as it's a nul byte.\n                         * This is redundant with GLib >= 2.63.0, see:\n                         * https://gitlab.gnome.org/GNOME/glib/-/merge_requests/967\n                         */\n#if !GLIB_CHECK_VERSION( 2, 63, 0 )\n                        if( a == (gunichar) 0 )\n                                return( NULL );\n#endif\n\n                        /* Mismatch.\n                         */\n                        if( g_unichar_tolower( a ) != g_unichar_tolower( b ) )\n                                break;\n\n                        haystack_char = \n\t\t\t\tg_utf8_find_next_char( haystack_char, \n\t\t\t\t\thaystack_start + len_bytes );\n\n                        /* End of haystack. There can't be a complete needle\n                         * anywhere.\n                         */\n                        if( haystack_char == NULL )\n                                return( NULL );\n\n                        /* needle_char will never be NULL.\n                         */\n                        needle_char = \n\t\t\t\tg_utf8_find_next_char( needle_char, NULL );\n                }\n\n                if( i == needle_len )\n\t\t\t/* Walked the whole of needle, so we must have found a \n\t\t\t * complete match.\n\t\t\t */\n                        return( haystack );\n        }\n\n        /* Walked the whole of haystack without finding a match.\n         */\n        return( NULL );\n}",
  "abstract_func": "static const char *\nvips_utf8_strcasestr( const char *VAR_0, const char *VAR_1, \n\tint VAR_2 )\n{\n        int VAR_3 = g_utf8_strlen( VAR_1, -1 );\n        int VAR_4 = strlen( VAR_1 );\n\n\tconst char *VAR_5;\n\n\tfor( VAR_5 = VAR_0; \n\t\tVAR_5 - VAR_0 <= VAR_2 - VAR_4; \n\t\tVAR_5 = g_utf8_find_next_char( VAR_5, NULL ) ) {\n                const char *VAR_6;\n                const char *VAR_7;\n\t\tint VAR_8;\n\n                VAR_7 = VAR_5;\n                VAR_6 = VAR_1;\n                for( VAR_8 = 0; VAR_8 < VAR_3; VAR_8++ ) {\n\t\t\t/* COMMENT_0 */\n                                                         \n                                                \n      \n                        gunichar VAR_9 = \n\t\t\t\tg_utf8_get_char_validated( VAR_7, \n\t\t\t\t\tVAR_0 + VAR_2 - VAR_5 );\n                        gunichar VAR_10 = \n\t\t\t\tg_utf8_get_char_validated( VAR_6, -1 );\n\n                        /* COMMENT_4 */\n     \n                                                        \n                                                         \n              \n                           \n                        if( VAR_9 == (gunichar) -1 ||\n\t\t\t\tVAR_9 == (gunichar) -2 ||\n\t\t\t\tVAR_10 == (gunichar) -1 ||\n\t\t\t\tVAR_10 == (gunichar) -2 )\n                                return( NULL );\n\n                        /* COMMENT_10 */\n                                                                      \n                                                                                   \n                           \n#if !GLIB_CHECK_VERSION( 2, 63, 0 )\n                        if( VAR_9 == (gunichar) 0 )\n                                return( NULL );\n#endif\n\n                        /* COMMENT_14 */\n                           \n                        if( g_unichar_tolower( VAR_9 ) != g_unichar_tolower( VAR_10 ) )\n                                break;\n\n                        VAR_7 = \n\t\t\t\tg_utf8_find_next_char( VAR_7, \n\t\t\t\t\tVAR_0 + VAR_2 );\n\n                        /* COMMENT_16 */\n                                    \n                           \n                        if( VAR_7 == NULL )\n                                return( NULL );\n\n                        /* COMMENT_19 */\n                           \n                        VAR_6 = \n\t\t\t\tg_utf8_find_next_char( VAR_6, NULL );\n                }\n\n                if( VAR_8 == VAR_3 )\n\t\t\t/* COMMENT_21 */\n                     \n      \n                        return( VAR_5 );\n        }\n\n        /* COMMENT_24 */\n           \n        return( NULL );\n}",
  "func_graph_path": "libvips/e091d65835966ef56d53a4105a7362cafdb1582b/svgload.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -39,11 +39,14 @@\n \t\t\t\tb == (gunichar) -2 )\n                                 return( NULL );\n \n-                        /* End of haystack. There can't be a complete needle\n-                         * anywhere.\n+                        /* Disallow codepoint U+0000 as it's a nul byte.\n+                         * This is redundant with GLib >= 2.63.0, see:\n+                         * https://gitlab.gnome.org/GNOME/glib/-/merge_requests/967\n                          */\n+#if !GLIB_CHECK_VERSION( 2, 63, 0 )\n                         if( a == (gunichar) 0 )\n                                 return( NULL );\n+#endif\n \n                         /* Mismatch.\n                          */\n@@ -53,6 +56,15 @@\n                         haystack_char = \n \t\t\t\tg_utf8_find_next_char( haystack_char, \n \t\t\t\t\thaystack_start + len_bytes );\n+\n+                        /* End of haystack. There can't be a complete needle\n+                         * anywhere.\n+                         */\n+                        if( haystack_char == NULL )\n+                                return( NULL );\n+\n+                        /* needle_char will never be NULL.\n+                         */\n                         needle_char = \n \t\t\t\tg_utf8_find_next_char( needle_char, NULL );\n                 }",
  "diff_line_info": {
    "deleted_lines": [
      "                        /* End of haystack. There can't be a complete needle",
      "                         * anywhere."
    ],
    "added_lines": [
      "                        /* Disallow codepoint U+0000 as it's a nul byte.",
      "                         * This is redundant with GLib >= 2.63.0, see:",
      "                         * https://gitlab.gnome.org/GNOME/glib/-/merge_requests/967",
      "#if !GLIB_CHECK_VERSION( 2, 63, 0 )",
      "#endif",
      "",
      "                        /* End of haystack. There can't be a complete needle",
      "                         * anywhere.",
      "                         */",
      "                        if( haystack_char == NULL )",
      "                                return( NULL );",
      "",
      "                        /* needle_char will never be NULL.",
      "                         */"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libvips/libvips/pull/3604",
  "description": {
    "pr_info": {
      "title": "svgload: fix null-pointer dereference",
      "number": 3604
    },
    "comment": [
      "`g_utf8_find_next_char()` might return NULL when called with a non-NULL second argument, indicating that the end of the string has been reached.\r\n\r\nTargets the 8.14 branch."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix;  \n**Confidence:** 0.9  \nThe patch addresses a null-pointer dereference issue which could lead to a crash."
}