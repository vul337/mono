{
  "cve_id": "CVE-2019-15134",
  "cwe_ids": [
    "CWE-401"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:C",
  "cvss_is_v3": false,
  "repo_name": "RIOT-OS/RIOT",
  "commit_msg": "gnrc_tcp: Fix memory leak",
  "commit_hash": "c6df2064aff1ffb4015d4cedbaefb8850cb50aa8",
  "git_url": "https://github.com/RIOT-OS/RIOT/commit/c6df2064aff1ffb4015d4cedbaefb8850cb50aa8",
  "file_path": "sys/net/gnrc/transport_layer/tcp/gnrc_tcp_eventloop.c",
  "func_name": "_receive",
  "func_before": "static int _receive(gnrc_pktsnip_t *pkt)\n{\n    /* NOTE: In receiving direction: pkt = payload, payload->next = tcp, tcp->next = nw */\n    uint16_t ctl = 0;\n    uint16_t src = 0;\n    uint16_t dst = 0;\n    uint8_t hdr_size = 0;\n    uint8_t syn = 0;\n    gnrc_pktsnip_t *ip = NULL;\n    gnrc_pktsnip_t *reset = NULL;\n    gnrc_tcp_tcb_t *tcb = NULL;\n    tcp_hdr_t *hdr;\n\n    /* Get write access to the TCP header */\n    gnrc_pktsnip_t *tcp = gnrc_pktbuf_start_write(pkt);\n    if (tcp == NULL) {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : can't write to packet\\n\");\n        gnrc_pktbuf_release(pkt);\n        return -EACCES;\n    }\n    pkt = tcp;\n\n#ifdef MODULE_GNRC_IPV6\n    /* Get IPv6 header, discard packet if doesn't contain an ip header */\n    LL_SEARCH_SCALAR(pkt, ip, type, GNRC_NETTYPE_IPV6);\n    if (ip == NULL) {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : pkt contains no IP Header\\n\");\n        gnrc_pktbuf_release(pkt);\n        return 0;\n    }\n#endif\n\n    /* Get TCP header */\n    LL_SEARCH_SCALAR(pkt, tcp, type, GNRC_NETTYPE_TCP);\n    if (tcp == NULL) {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : pkt contains no TCP Header\\n\");\n        gnrc_pktbuf_release(pkt);\n        return 0;\n    }\n\n    /* Extract control bits, src and dst ports and check if SYN is set (not SYN+ACK) */\n    hdr = (tcp_hdr_t *)tcp->data;\n    ctl = byteorder_ntohs(hdr->off_ctl);\n    src = byteorder_ntohs(hdr->src_port);\n    dst = byteorder_ntohs(hdr->dst_port);\n    syn = ((ctl & MSK_SYN_ACK) == MSK_SYN);\n\n    /* Validate offset */\n    if (GET_OFFSET(ctl) < TCP_HDR_OFFSET_MIN) {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : unexpected Offset Value\\n\");\n        gnrc_pktbuf_release(pkt);\n        return -ERANGE;\n    }\n\n    /* Calculate TCP header size */\n    hdr_size = GET_OFFSET(ctl) * 4;\n\n    /* Mark TCP header if it contains any payload */\n    if ((pkt->type == GNRC_NETTYPE_TCP) && (pkt->size != hdr_size)) {\n        tcp = gnrc_pktbuf_mark(pkt, hdr_size, GNRC_NETTYPE_TCP);\n        if (tcp == NULL) {\n            DEBUG(\"gnrc_tcp_eventloop.c : _receive() : Header marking failed\\n\");\n            gnrc_pktbuf_release(pkt);\n            return -ENOMSG;\n        }\n        pkt->type = GNRC_NETTYPE_UNDEF;\n    }\n\n    /* Validate checksum */\n    if (byteorder_ntohs(hdr->checksum) != _pkt_calc_csum(tcp, ip, pkt)) {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : Invalid checksum\\n\");\n        gnrc_pktbuf_release(pkt);\n        return -EINVAL;\n    }\n\n    /* Find TCB to for this packet */\n    mutex_lock(&_list_tcb_lock);\n    tcb = _list_tcb_head;\n    while (tcb) {\n#ifdef MODULE_GNRC_IPV6\n        /* Check if current TCB is fitting for the incomming packet */\n        if (ip->type == GNRC_NETTYPE_IPV6 && tcb->address_family == AF_INET6) {\n            /* If SYN is set, a connection is listening on that port ... */\n            ipv6_addr_t *tmp_addr = NULL;\n            if (syn && tcb->local_port == dst && tcb->state == FSM_STATE_LISTEN) {\n                /* ... and local addr is unspec or pre configured */\n                tmp_addr = &((ipv6_hdr_t *)ip->data)->dst;\n                if (ipv6_addr_equal((ipv6_addr_t *) tcb->local_addr, (ipv6_addr_t *) tmp_addr) ||\n                    ipv6_addr_is_unspecified((ipv6_addr_t *) tcb->local_addr)) {\n                    break;\n                }\n            }\n\n            /* If SYN is not set and the ports match ... */\n            if (!syn && tcb->local_port == dst && tcb->peer_port == src) {\n                /* .. and the IPv6 addresses match */\n                tmp_addr = &((ipv6_hdr_t * )ip->data)->src;\n                if (ipv6_addr_equal((ipv6_addr_t *) tcb->peer_addr, (ipv6_addr_t *) tmp_addr)) {\n                    break;\n                }\n            }\n        }\n#else\n        /* Supress compiler warnings if TCP is build without network layer */\n        (void) syn;\n        (void) src;\n        (void) dst;\n#endif\n        tcb = tcb->next;\n    }\n    mutex_unlock(&_list_tcb_lock);\n\n    /* Call FSM with event RCVD_PKT if a fitting TCB was found */\n    if (tcb != NULL) {\n        _fsm(tcb, FSM_EVENT_RCVD_PKT, pkt, NULL, 0);\n    }\n    /* No fitting TCB has been found. Respond with reset */\n    else {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : Can't find fitting tcb\\n\");\n        if ((ctl & MSK_RST) != MSK_RST) {\n            _pkt_build_reset_from_pkt(&reset, pkt);\n            gnrc_netapi_send(gnrc_tcp_pid, reset);\n        }\n        return -ENOTCONN;\n    }\n    gnrc_pktbuf_release(pkt);\n    return 0;\n}",
  "abstract_func_before": "static int _receive(gnrc_pktsnip_t *VAR_0)\n{\n    /* COMMENT_0 */\n    uint16_t VAR_1 = 0;\n    uint16_t VAR_2 = 0;\n    uint16_t VAR_3 = 0;\n    uint8_t VAR_4 = 0;\n    uint8_t VAR_5 = 0;\n    gnrc_pktsnip_t *VAR_6 = NULL;\n    gnrc_pktsnip_t *VAR_7 = NULL;\n    gnrc_tcp_tcb_t *VAR_8 = NULL;\n    tcp_hdr_t *VAR_9;\n\n    /* COMMENT_1 */\n    gnrc_pktsnip_t *VAR_10 = gnrc_pktbuf_start_write(VAR_0);\n    if (VAR_10 == NULL) {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : can't write to packet\\n\");\n        gnrc_pktbuf_release(VAR_0);\n        return -VAR_11;\n    }\n    VAR_0 = VAR_10;\n\n#ifdef VAR_12\n    /* COMMENT_2 */\n    LL_SEARCH_SCALAR(VAR_0, VAR_6, VAR_13, VAR_14);\n    if (VAR_6 == NULL) {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : pkt contains no IP Header\\n\");\n        gnrc_pktbuf_release(VAR_0);\n        return 0;\n    }\n#endif\n\n    /* COMMENT_3 */\n    LL_SEARCH_SCALAR(VAR_0, VAR_10, VAR_13, VAR_15);\n    if (VAR_10 == NULL) {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : pkt contains no TCP Header\\n\");\n        gnrc_pktbuf_release(VAR_0);\n        return 0;\n    }\n\n    /* COMMENT_4 */\n    VAR_9 = (tcp_hdr_t *)VAR_10->data;\n    VAR_1 = byteorder_ntohs(VAR_9->off_ctl);\n    VAR_2 = byteorder_ntohs(VAR_9->src_port);\n    VAR_3 = byteorder_ntohs(VAR_9->dst_port);\n    VAR_5 = ((VAR_1 & VAR_16) == VAR_17);\n\n    /* COMMENT_5 */\n    if (GET_OFFSET(VAR_1) < VAR_18) {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : unexpected Offset Value\\n\");\n        gnrc_pktbuf_release(VAR_0);\n        return -VAR_19;\n    }\n\n    /* COMMENT_6 */\n    VAR_4 = GET_OFFSET(VAR_1) * 4;\n\n    /* COMMENT_7 */\n    if ((VAR_0->type == VAR_15) && (VAR_0->size != VAR_4)) {\n        VAR_10 = gnrc_pktbuf_mark(VAR_0, VAR_4, VAR_15);\n        if (VAR_10 == NULL) {\n            DEBUG(\"gnrc_tcp_eventloop.c : _receive() : Header marking failed\\n\");\n            gnrc_pktbuf_release(VAR_0);\n            return -VAR_20;\n        }\n        VAR_0->type = VAR_21;\n    }\n\n    /* COMMENT_8 */\n    if (byteorder_ntohs(VAR_9->checksum) != _pkt_calc_csum(VAR_10, VAR_6, VAR_0)) {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : Invalid checksum\\n\");\n        gnrc_pktbuf_release(VAR_0);\n        return -VAR_22;\n    }\n\n    /* COMMENT_9 */\n    mutex_lock(&VAR_23);\n    VAR_8 = VAR_24;\n    while (VAR_8) {\n#ifdef VAR_12\n        /* COMMENT_10 */\n        if (VAR_6->type == VAR_14 && VAR_8->address_family == VAR_25) {\n            /* COMMENT_11 */\n            ipv6_addr_t *VAR_26 = NULL;\n            if (VAR_5 && VAR_8->local_port == VAR_3 && VAR_8->state == VAR_27) {\n                /* COMMENT_12 */\n                VAR_26 = &((ipv6_hdr_t *)VAR_6->data)->dst;\n                if (ipv6_addr_equal((ipv6_addr_t *) VAR_8->local_addr, (ipv6_addr_t *) VAR_26) ||\n                    ipv6_addr_is_unspecified((ipv6_addr_t *) VAR_8->local_addr)) {\n                    break;\n                }\n            }\n\n            /* COMMENT_13 */\n            if (!VAR_5 && VAR_8->local_port == VAR_3 && VAR_8->peer_port == VAR_2) {\n                /* COMMENT_14 */\n                VAR_26 = &((ipv6_hdr_t * )VAR_6->data)->src;\n                if (ipv6_addr_equal((ipv6_addr_t *) VAR_8->peer_addr, (ipv6_addr_t *) VAR_26)) {\n                    break;\n                }\n            }\n        }\n#else\n        /* COMMENT_15 */\n        (void) VAR_5;\n        (void) VAR_2;\n        (void) VAR_3;\n#endif\n        VAR_8 = VAR_8->next;\n    }\n    mutex_unlock(&VAR_23);\n\n    /* COMMENT_16 */\n    if (VAR_8 != NULL) {\n        _fsm(VAR_8, VAR_28, VAR_0, NULL, 0);\n    }\n    /* COMMENT_17 */\n    else {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : Can't find fitting tcb\\n\");\n        if ((VAR_1 & VAR_29) != VAR_29) {\n            _pkt_build_reset_from_pkt(&VAR_7, VAR_0);\n            gnrc_netapi_send(VAR_30, VAR_7);\n        }\n        return -VAR_31;\n    }\n    gnrc_pktbuf_release(VAR_0);\n    return 0;\n}",
  "func_graph_path_before": "RIOT-OS/RIOT/c6df2064aff1ffb4015d4cedbaefb8850cb50aa8/gnrc_tcp_eventloop.c/vul/before/0.json",
  "func": "static int _receive(gnrc_pktsnip_t *pkt)\n{\n    /* NOTE: In receiving direction: pkt = payload, payload->next = tcp, tcp->next = nw */\n    uint16_t ctl = 0;\n    uint16_t src = 0;\n    uint16_t dst = 0;\n    uint8_t hdr_size = 0;\n    uint8_t syn = 0;\n    gnrc_pktsnip_t *ip = NULL;\n    gnrc_pktsnip_t *reset = NULL;\n    gnrc_tcp_tcb_t *tcb = NULL;\n    tcp_hdr_t *hdr;\n\n    /* Get write access to the TCP header */\n    gnrc_pktsnip_t *tcp = gnrc_pktbuf_start_write(pkt);\n    if (tcp == NULL) {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : can't write to packet\\n\");\n        gnrc_pktbuf_release(pkt);\n        return -EACCES;\n    }\n    pkt = tcp;\n\n#ifdef MODULE_GNRC_IPV6\n    /* Get IPv6 header, discard packet if doesn't contain an ip header */\n    LL_SEARCH_SCALAR(pkt, ip, type, GNRC_NETTYPE_IPV6);\n    if (ip == NULL) {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : pkt contains no IP Header\\n\");\n        gnrc_pktbuf_release(pkt);\n        return 0;\n    }\n#endif\n\n    /* Get TCP header */\n    LL_SEARCH_SCALAR(pkt, tcp, type, GNRC_NETTYPE_TCP);\n    if (tcp == NULL) {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : pkt contains no TCP Header\\n\");\n        gnrc_pktbuf_release(pkt);\n        return 0;\n    }\n\n    /* Extract control bits, src and dst ports and check if SYN is set (not SYN+ACK) */\n    hdr = (tcp_hdr_t *)tcp->data;\n    ctl = byteorder_ntohs(hdr->off_ctl);\n    src = byteorder_ntohs(hdr->src_port);\n    dst = byteorder_ntohs(hdr->dst_port);\n    syn = ((ctl & MSK_SYN_ACK) == MSK_SYN);\n\n    /* Validate offset */\n    if (GET_OFFSET(ctl) < TCP_HDR_OFFSET_MIN) {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : unexpected Offset Value\\n\");\n        gnrc_pktbuf_release(pkt);\n        return -ERANGE;\n    }\n\n    /* Calculate TCP header size */\n    hdr_size = GET_OFFSET(ctl) * 4;\n\n    /* Mark TCP header if it contains any payload */\n    if ((pkt->type == GNRC_NETTYPE_TCP) && (pkt->size != hdr_size)) {\n        tcp = gnrc_pktbuf_mark(pkt, hdr_size, GNRC_NETTYPE_TCP);\n        if (tcp == NULL) {\n            DEBUG(\"gnrc_tcp_eventloop.c : _receive() : Header marking failed\\n\");\n            gnrc_pktbuf_release(pkt);\n            return -ENOMSG;\n        }\n        pkt->type = GNRC_NETTYPE_UNDEF;\n    }\n\n    /* Validate checksum */\n    if (byteorder_ntohs(hdr->checksum) != _pkt_calc_csum(tcp, ip, pkt)) {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : Invalid checksum\\n\");\n        gnrc_pktbuf_release(pkt);\n        return -EINVAL;\n    }\n\n    /* Find TCB to for this packet */\n    mutex_lock(&_list_tcb_lock);\n    tcb = _list_tcb_head;\n    while (tcb) {\n#ifdef MODULE_GNRC_IPV6\n        /* Check if current TCB is fitting for the incomming packet */\n        if (ip->type == GNRC_NETTYPE_IPV6 && tcb->address_family == AF_INET6) {\n            /* If SYN is set, a connection is listening on that port ... */\n            ipv6_addr_t *tmp_addr = NULL;\n            if (syn && tcb->local_port == dst && tcb->state == FSM_STATE_LISTEN) {\n                /* ... and local addr is unspec or pre configured */\n                tmp_addr = &((ipv6_hdr_t *)ip->data)->dst;\n                if (ipv6_addr_equal((ipv6_addr_t *) tcb->local_addr, (ipv6_addr_t *) tmp_addr) ||\n                    ipv6_addr_is_unspecified((ipv6_addr_t *) tcb->local_addr)) {\n                    break;\n                }\n            }\n\n            /* If SYN is not set and the ports match ... */\n            if (!syn && tcb->local_port == dst && tcb->peer_port == src) {\n                /* .. and the IPv6 addresses match */\n                tmp_addr = &((ipv6_hdr_t * )ip->data)->src;\n                if (ipv6_addr_equal((ipv6_addr_t *) tcb->peer_addr, (ipv6_addr_t *) tmp_addr)) {\n                    break;\n                }\n            }\n        }\n#else\n        /* Supress compiler warnings if TCP is build without network layer */\n        (void) syn;\n        (void) src;\n        (void) dst;\n#endif\n        tcb = tcb->next;\n    }\n    mutex_unlock(&_list_tcb_lock);\n\n    /* Call FSM with event RCVD_PKT if a fitting TCB was found */\n    if (tcb != NULL) {\n        _fsm(tcb, FSM_EVENT_RCVD_PKT, pkt, NULL, 0);\n    }\n    /* No fitting TCB has been found. Respond with reset */\n    else {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : Can't find fitting tcb\\n\");\n        if ((ctl & MSK_RST) != MSK_RST) {\n            _pkt_build_reset_from_pkt(&reset, pkt);\n            gnrc_netapi_send(gnrc_tcp_pid, reset);\n        }\n        gnrc_pktbuf_release(pkt);\n        return -ENOTCONN;\n    }\n    gnrc_pktbuf_release(pkt);\n    return 0;\n}",
  "abstract_func": "static int _receive(gnrc_pktsnip_t *VAR_0)\n{\n    /* COMMENT_0 */\n    uint16_t VAR_1 = 0;\n    uint16_t VAR_2 = 0;\n    uint16_t VAR_3 = 0;\n    uint8_t VAR_4 = 0;\n    uint8_t VAR_5 = 0;\n    gnrc_pktsnip_t *VAR_6 = NULL;\n    gnrc_pktsnip_t *VAR_7 = NULL;\n    gnrc_tcp_tcb_t *VAR_8 = NULL;\n    tcp_hdr_t *VAR_9;\n\n    /* COMMENT_1 */\n    gnrc_pktsnip_t *VAR_10 = gnrc_pktbuf_start_write(VAR_0);\n    if (VAR_10 == NULL) {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : can't write to packet\\n\");\n        gnrc_pktbuf_release(VAR_0);\n        return -VAR_11;\n    }\n    VAR_0 = VAR_10;\n\n#ifdef VAR_12\n    /* COMMENT_2 */\n    LL_SEARCH_SCALAR(VAR_0, VAR_6, VAR_13, VAR_14);\n    if (VAR_6 == NULL) {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : pkt contains no IP Header\\n\");\n        gnrc_pktbuf_release(VAR_0);\n        return 0;\n    }\n#endif\n\n    /* COMMENT_3 */\n    LL_SEARCH_SCALAR(VAR_0, VAR_10, VAR_13, VAR_15);\n    if (VAR_10 == NULL) {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : pkt contains no TCP Header\\n\");\n        gnrc_pktbuf_release(VAR_0);\n        return 0;\n    }\n\n    /* COMMENT_4 */\n    VAR_9 = (tcp_hdr_t *)VAR_10->data;\n    VAR_1 = byteorder_ntohs(VAR_9->off_ctl);\n    VAR_2 = byteorder_ntohs(VAR_9->src_port);\n    VAR_3 = byteorder_ntohs(VAR_9->dst_port);\n    VAR_5 = ((VAR_1 & VAR_16) == VAR_17);\n\n    /* COMMENT_5 */\n    if (GET_OFFSET(VAR_1) < VAR_18) {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : unexpected Offset Value\\n\");\n        gnrc_pktbuf_release(VAR_0);\n        return -VAR_19;\n    }\n\n    /* COMMENT_6 */\n    VAR_4 = GET_OFFSET(VAR_1) * 4;\n\n    /* COMMENT_7 */\n    if ((VAR_0->type == VAR_15) && (VAR_0->size != VAR_4)) {\n        VAR_10 = gnrc_pktbuf_mark(VAR_0, VAR_4, VAR_15);\n        if (VAR_10 == NULL) {\n            DEBUG(\"gnrc_tcp_eventloop.c : _receive() : Header marking failed\\n\");\n            gnrc_pktbuf_release(VAR_0);\n            return -VAR_20;\n        }\n        VAR_0->type = VAR_21;\n    }\n\n    /* COMMENT_8 */\n    if (byteorder_ntohs(VAR_9->checksum) != _pkt_calc_csum(VAR_10, VAR_6, VAR_0)) {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : Invalid checksum\\n\");\n        gnrc_pktbuf_release(VAR_0);\n        return -VAR_22;\n    }\n\n    /* COMMENT_9 */\n    mutex_lock(&VAR_23);\n    VAR_8 = VAR_24;\n    while (VAR_8) {\n#ifdef VAR_12\n        /* COMMENT_10 */\n        if (VAR_6->type == VAR_14 && VAR_8->address_family == VAR_25) {\n            /* COMMENT_11 */\n            ipv6_addr_t *VAR_26 = NULL;\n            if (VAR_5 && VAR_8->local_port == VAR_3 && VAR_8->state == VAR_27) {\n                /* COMMENT_12 */\n                VAR_26 = &((ipv6_hdr_t *)VAR_6->data)->dst;\n                if (ipv6_addr_equal((ipv6_addr_t *) VAR_8->local_addr, (ipv6_addr_t *) VAR_26) ||\n                    ipv6_addr_is_unspecified((ipv6_addr_t *) VAR_8->local_addr)) {\n                    break;\n                }\n            }\n\n            /* COMMENT_13 */\n            if (!VAR_5 && VAR_8->local_port == VAR_3 && VAR_8->peer_port == VAR_2) {\n                /* COMMENT_14 */\n                VAR_26 = &((ipv6_hdr_t * )VAR_6->data)->src;\n                if (ipv6_addr_equal((ipv6_addr_t *) VAR_8->peer_addr, (ipv6_addr_t *) VAR_26)) {\n                    break;\n                }\n            }\n        }\n#else\n        /* COMMENT_15 */\n        (void) VAR_5;\n        (void) VAR_2;\n        (void) VAR_3;\n#endif\n        VAR_8 = VAR_8->next;\n    }\n    mutex_unlock(&VAR_23);\n\n    /* COMMENT_16 */\n    if (VAR_8 != NULL) {\n        _fsm(VAR_8, VAR_28, VAR_0, NULL, 0);\n    }\n    /* COMMENT_17 */\n    else {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : Can't find fitting tcb\\n\");\n        if ((VAR_1 & VAR_29) != VAR_29) {\n            _pkt_build_reset_from_pkt(&VAR_7, VAR_0);\n            gnrc_netapi_send(VAR_30, VAR_7);\n        }\n        gnrc_pktbuf_release(VAR_0);\n        return -VAR_31;\n    }\n    gnrc_pktbuf_release(VAR_0);\n    return 0;\n}",
  "func_graph_path": "RIOT-OS/RIOT/c6df2064aff1ffb4015d4cedbaefb8850cb50aa8/gnrc_tcp_eventloop.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -121,6 +121,7 @@\n             _pkt_build_reset_from_pkt(&reset, pkt);\n             gnrc_netapi_send(gnrc_tcp_pid, reset);\n         }\n+        gnrc_pktbuf_release(pkt);\n         return -ENOTCONN;\n     }\n     gnrc_pktbuf_release(pkt);",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "        gnrc_pktbuf_release(pkt);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/RIOT-OS/RIOT/pull/12001",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/RIOT-OS/RIOT/pull/12001: 403 Client Error: Forbidden for url: https://api.github.com/repos/RIOT-OS/RIOT/pulls/12001",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "The commit addresses a memory leak in the `gnrc_tcp` module, specifically handling packets during a faulty TCP handshake. The fix involves releasing the packet buffer to prevent memory exhaustion, which is critical for security as it mitigates a potential DOS attack. \n\n**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}