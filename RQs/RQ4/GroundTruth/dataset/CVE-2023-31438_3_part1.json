{
  "cve_id": "CVE-2023-31438",
  "cwe_ids": [
    "CWE-354"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N",
  "cvss_is_v3": true,
  "repo_name": "systemd",
  "commit_msg": "journalctl: verify sealed log epochs are continuous\n\nCurrently empty epochs are not sealed. This allows an attacker to truncate\na sealed log and continue it without any problems showing when verifying the\nlog.\n\nThis partially addresses CVE-2023-31438. One way to extend this change to\naddress CVE-2023-31438 completely, would be to verify that there is exactly\none seal per epoch (and not sealing when the epoch has not ended yet).\n\nthe change also adds a journal-file flag: HEADER_COMPATIBLE_SEALED_CONTINUOUS\nthis flag indicates that a journal file is sealed continuously and decides whether\nany missing crypto epochs should trigger a warning or an error.",
  "commit_hash": "8d7b0958cdb505047e5a66029468b8d12b8a7add",
  "git_url": "https://github.com/systemd/systemd/commit/8d7b0958cdb505047e5a66029468b8d12b8a7add",
  "file_path": "src/libsystemd/sd-journal/journal-file.c",
  "func_name": "journal_file_print_header",
  "func_before": "void journal_file_print_header(JournalFile *f) {\n        struct stat st;\n\n        assert(f);\n        assert(f->header);\n\n        printf(\"File path: %s\\n\"\n               \"File ID: %s\\n\"\n               \"Machine ID: %s\\n\"\n               \"Boot ID: %s\\n\"\n               \"Sequential number ID: %s\\n\"\n               \"State: %s\\n\"\n               \"Compatible flags:%s%s%s\\n\"\n               \"Incompatible flags:%s%s%s%s%s%s\\n\"\n               \"Header size: %\"PRIu64\"\\n\"\n               \"Arena size: %\"PRIu64\"\\n\"\n               \"Data hash table size: %\"PRIu64\"\\n\"\n               \"Field hash table size: %\"PRIu64\"\\n\"\n               \"Rotate suggested: %s\\n\"\n               \"Head sequential number: %\"PRIu64\" (%\"PRIx64\")\\n\"\n               \"Tail sequential number: %\"PRIu64\" (%\"PRIx64\")\\n\"\n               \"Head realtime timestamp: %s (%\"PRIx64\")\\n\"\n               \"Tail realtime timestamp: %s (%\"PRIx64\")\\n\"\n               \"Tail monotonic timestamp: %s (%\"PRIx64\")\\n\"\n               \"Objects: %\"PRIu64\"\\n\"\n               \"Entry objects: %\"PRIu64\"\\n\",\n               f->path,\n               SD_ID128_TO_STRING(f->header->file_id),\n               SD_ID128_TO_STRING(f->header->machine_id),\n               SD_ID128_TO_STRING(f->header->tail_entry_boot_id),\n               SD_ID128_TO_STRING(f->header->seqnum_id),\n               f->header->state == STATE_OFFLINE ? \"OFFLINE\" :\n               f->header->state == STATE_ONLINE ? \"ONLINE\" :\n               f->header->state == STATE_ARCHIVED ? \"ARCHIVED\" : \"UNKNOWN\",\n               JOURNAL_HEADER_SEALED(f->header) ? \" SEALED\" : \"\",\n               JOURNAL_HEADER_TAIL_ENTRY_BOOT_ID(f->header) ? \" TAIL_ENTRY_BOOT_ID\" : \"\",\n               (le32toh(f->header->compatible_flags) & ~HEADER_COMPATIBLE_ANY) ? \" ???\" : \"\",\n               JOURNAL_HEADER_COMPRESSED_XZ(f->header) ? \" COMPRESSED-XZ\" : \"\",\n               JOURNAL_HEADER_COMPRESSED_LZ4(f->header) ? \" COMPRESSED-LZ4\" : \"\",\n               JOURNAL_HEADER_COMPRESSED_ZSTD(f->header) ? \" COMPRESSED-ZSTD\" : \"\",\n               JOURNAL_HEADER_KEYED_HASH(f->header) ? \" KEYED-HASH\" : \"\",\n               JOURNAL_HEADER_COMPACT(f->header) ? \" COMPACT\" : \"\",\n               (le32toh(f->header->incompatible_flags) & ~HEADER_INCOMPATIBLE_ANY) ? \" ???\" : \"\",\n               le64toh(f->header->header_size),\n               le64toh(f->header->arena_size),\n               le64toh(f->header->data_hash_table_size) / sizeof(HashItem),\n               le64toh(f->header->field_hash_table_size) / sizeof(HashItem),\n               yes_no(journal_file_rotate_suggested(f, 0, LOG_DEBUG)),\n               le64toh(f->header->head_entry_seqnum), le64toh(f->header->head_entry_seqnum),\n               le64toh(f->header->tail_entry_seqnum), le64toh(f->header->tail_entry_seqnum),\n               FORMAT_TIMESTAMP_SAFE(le64toh(f->header->head_entry_realtime)), le64toh(f->header->head_entry_realtime),\n               FORMAT_TIMESTAMP_SAFE(le64toh(f->header->tail_entry_realtime)), le64toh(f->header->tail_entry_realtime),\n               FORMAT_TIMESPAN(le64toh(f->header->tail_entry_monotonic), USEC_PER_MSEC), le64toh(f->header->tail_entry_monotonic),\n               le64toh(f->header->n_objects),\n               le64toh(f->header->n_entries));\n\n        if (JOURNAL_HEADER_CONTAINS(f->header, n_data))\n                printf(\"Data objects: %\"PRIu64\"\\n\"\n                       \"Data hash table fill: %.1f%%\\n\",\n                       le64toh(f->header->n_data),\n                       100.0 * (double) le64toh(f->header->n_data) / ((double) (le64toh(f->header->data_hash_table_size) / sizeof(HashItem))));\n\n        if (JOURNAL_HEADER_CONTAINS(f->header, n_fields))\n                printf(\"Field objects: %\"PRIu64\"\\n\"\n                       \"Field hash table fill: %.1f%%\\n\",\n                       le64toh(f->header->n_fields),\n                       100.0 * (double) le64toh(f->header->n_fields) / ((double) (le64toh(f->header->field_hash_table_size) / sizeof(HashItem))));\n\n        if (JOURNAL_HEADER_CONTAINS(f->header, n_tags))\n                printf(\"Tag objects: %\"PRIu64\"\\n\",\n                       le64toh(f->header->n_tags));\n        if (JOURNAL_HEADER_CONTAINS(f->header, n_entry_arrays))\n                printf(\"Entry array objects: %\"PRIu64\"\\n\",\n                       le64toh(f->header->n_entry_arrays));\n\n        if (JOURNAL_HEADER_CONTAINS(f->header, field_hash_chain_depth))\n                printf(\"Deepest field hash chain: %\" PRIu64\"\\n\",\n                       f->header->field_hash_chain_depth);\n\n        if (JOURNAL_HEADER_CONTAINS(f->header, data_hash_chain_depth))\n                printf(\"Deepest data hash chain: %\" PRIu64\"\\n\",\n                       f->header->data_hash_chain_depth);\n\n        if (fstat(f->fd, &st) >= 0)\n                printf(\"Disk usage: %s\\n\", FORMAT_BYTES((uint64_t) st.st_blocks * 512ULL));\n}",
  "abstract_func_before": "void journal_file_print_header(JournalFile *VAR_0) {\n        struct stat VAR_1;\n\n        assert(VAR_0);\n        assert(VAR_0->header);\n\n        printf(\"File path: %s\\n\"\n               \"File ID: %s\\n\"\n               \"Machine ID: %s\\n\"\n               \"Boot ID: %s\\n\"\n               \"Sequential number ID: %s\\n\"\n               \"State: %s\\n\"\n               \"Compatible flags:%s%s%s\\n\"\n               \"Incompatible flags:%s%s%s%s%s%s\\n\"\n               \"Header size: %\"VAR_2\"\\n\"\n               \"Arena size: %\"VAR_2\"\\n\"\n               \"Data hash table size: %\"VAR_2\"\\n\"\n               \"Field hash table size: %\"VAR_2\"\\n\"\n               \"Rotate suggested: %s\\n\"\n               \"Head sequential number: %\"VAR_2\" (%\"VAR_3\")\\n\"\n               \"Tail sequential number: %\"VAR_2\" (%\"VAR_3\")\\n\"\n               \"Head realtime timestamp: %s (%\"VAR_3\")\\n\"\n               \"Tail realtime timestamp: %s (%\"VAR_3\")\\n\"\n               \"Tail monotonic timestamp: %s (%\"VAR_3\")\\n\"\n               \"Objects: %\"VAR_2\"\\n\"\n               \"Entry objects: %\"VAR_2\"\\n\",\n               VAR_0->path,\n               SD_ID128_TO_STRING(VAR_0->header->file_id),\n               SD_ID128_TO_STRING(VAR_0->header->machine_id),\n               SD_ID128_TO_STRING(VAR_0->header->tail_entry_boot_id),\n               SD_ID128_TO_STRING(VAR_0->header->seqnum_id),\n               VAR_0->header->state == VAR_4 ? \"OFFLINE\" :\n               VAR_0->header->state == VAR_5 ? \"ONLINE\" :\n               VAR_0->header->state == VAR_6 ? \"ARCHIVED\" : \"UNKNOWN\",\n               JOURNAL_HEADER_SEALED(VAR_0->header) ? \" SEALED\" : \"\",\n               JOURNAL_HEADER_TAIL_ENTRY_BOOT_ID(VAR_0->header) ? \" TAIL_ENTRY_BOOT_ID\" : \"\",\n               (le32toh(VAR_0->header->compatible_flags) & ~VAR_7) ? \" ???\" : \"\",\n               JOURNAL_HEADER_COMPRESSED_XZ(VAR_0->header) ? \" COMPRESSED-XZ\" : \"\",\n               JOURNAL_HEADER_COMPRESSED_LZ4(VAR_0->header) ? \" COMPRESSED-LZ4\" : \"\",\n               JOURNAL_HEADER_COMPRESSED_ZSTD(VAR_0->header) ? \" COMPRESSED-ZSTD\" : \"\",\n               JOURNAL_HEADER_KEYED_HASH(VAR_0->header) ? \" KEYED-HASH\" : \"\",\n               JOURNAL_HEADER_COMPACT(VAR_0->header) ? \" COMPACT\" : \"\",\n               (le32toh(VAR_0->header->incompatible_flags) & ~VAR_8) ? \" ???\" : \"\",\n               le64toh(VAR_0->header->header_size),\n               le64toh(VAR_0->header->arena_size),\n               le64toh(VAR_0->header->data_hash_table_size) / sizeof(VAR_9),\n               le64toh(VAR_0->header->field_hash_table_size) / sizeof(VAR_9),\n               yes_no(journal_file_rotate_suggested(VAR_0, 0, VAR_10)),\n               le64toh(VAR_0->header->head_entry_seqnum), le64toh(VAR_0->header->head_entry_seqnum),\n               le64toh(VAR_0->header->tail_entry_seqnum), le64toh(VAR_0->header->tail_entry_seqnum),\n               FORMAT_TIMESTAMP_SAFE(le64toh(VAR_0->header->head_entry_realtime)), le64toh(VAR_0->header->head_entry_realtime),\n               FORMAT_TIMESTAMP_SAFE(le64toh(VAR_0->header->tail_entry_realtime)), le64toh(VAR_0->header->tail_entry_realtime),\n               FORMAT_TIMESPAN(le64toh(VAR_0->header->tail_entry_monotonic), VAR_11), le64toh(VAR_0->header->tail_entry_monotonic),\n               le64toh(VAR_0->header->n_objects),\n               le64toh(VAR_0->header->n_entries));\n\n        if (JOURNAL_HEADER_CONTAINS(VAR_0->header, VAR_12))\n                printf(\"Data objects: %\"VAR_2\"\\n\"\n                       \"Data hash table fill: %.1f%%\\n\",\n                       le64toh(VAR_0->header->n_data),\n                       100.0 * (double) le64toh(VAR_0->header->n_data) / ((double) (le64toh(VAR_0->header->data_hash_table_size) / sizeof(VAR_9))));\n\n        if (JOURNAL_HEADER_CONTAINS(VAR_0->header, VAR_13))\n                printf(\"Field objects: %\"VAR_2\"\\n\"\n                       \"Field hash table fill: %.1f%%\\n\",\n                       le64toh(VAR_0->header->n_fields),\n                       100.0 * (double) le64toh(VAR_0->header->n_fields) / ((double) (le64toh(VAR_0->header->field_hash_table_size) / sizeof(VAR_9))));\n\n        if (JOURNAL_HEADER_CONTAINS(VAR_0->header, VAR_14))\n                printf(\"Tag objects: %\"VAR_2\"\\n\",\n                       le64toh(VAR_0->header->n_tags));\n        if (JOURNAL_HEADER_CONTAINS(VAR_0->header, VAR_15))\n                printf(\"Entry array objects: %\"VAR_2\"\\n\",\n                       le64toh(VAR_0->header->n_entry_arrays));\n\n        if (JOURNAL_HEADER_CONTAINS(VAR_0->header, VAR_16))\n                printf(\"Deepest field hash chain: %\" VAR_2\"\\n\",\n                       VAR_0->header->field_hash_chain_depth);\n\n        if (JOURNAL_HEADER_CONTAINS(VAR_0->header, VAR_17))\n                printf(\"Deepest data hash chain: %\" VAR_2\"\\n\",\n                       VAR_0->header->data_hash_chain_depth);\n\n        if (fstat(VAR_0->fd, &VAR_1) >= 0)\n                printf(\"Disk usage: %s\\n\", FORMAT_BYTES((uint64_t) VAR_1.st_blocks * 512ULL));\n}",
  "func_graph_path_before": "systemd/8d7b0958cdb505047e5a66029468b8d12b8a7add/journal-file.c/vul/before/2.json",
  "func": "void journal_file_print_header(JournalFile *f) {\n        struct stat st;\n\n        assert(f);\n        assert(f->header);\n\n        printf(\"File path: %s\\n\"\n               \"File ID: %s\\n\"\n               \"Machine ID: %s\\n\"\n               \"Boot ID: %s\\n\"\n               \"Sequential number ID: %s\\n\"\n               \"State: %s\\n\"\n               \"Compatible flags:%s%s%s%s\\n\"\n               \"Incompatible flags:%s%s%s%s%s%s\\n\"\n               \"Header size: %\"PRIu64\"\\n\"\n               \"Arena size: %\"PRIu64\"\\n\"\n               \"Data hash table size: %\"PRIu64\"\\n\"\n               \"Field hash table size: %\"PRIu64\"\\n\"\n               \"Rotate suggested: %s\\n\"\n               \"Head sequential number: %\"PRIu64\" (%\"PRIx64\")\\n\"\n               \"Tail sequential number: %\"PRIu64\" (%\"PRIx64\")\\n\"\n               \"Head realtime timestamp: %s (%\"PRIx64\")\\n\"\n               \"Tail realtime timestamp: %s (%\"PRIx64\")\\n\"\n               \"Tail monotonic timestamp: %s (%\"PRIx64\")\\n\"\n               \"Objects: %\"PRIu64\"\\n\"\n               \"Entry objects: %\"PRIu64\"\\n\",\n               f->path,\n               SD_ID128_TO_STRING(f->header->file_id),\n               SD_ID128_TO_STRING(f->header->machine_id),\n               SD_ID128_TO_STRING(f->header->tail_entry_boot_id),\n               SD_ID128_TO_STRING(f->header->seqnum_id),\n               f->header->state == STATE_OFFLINE ? \"OFFLINE\" :\n               f->header->state == STATE_ONLINE ? \"ONLINE\" :\n               f->header->state == STATE_ARCHIVED ? \"ARCHIVED\" : \"UNKNOWN\",\n               JOURNAL_HEADER_SEALED(f->header) ? \" SEALED\" : \"\",\n               JOURNAL_HEADER_SEALED_CONTINUOUS(f->header) ? \" SEALED_CONTINUOUS\" : \"\",\n               JOURNAL_HEADER_TAIL_ENTRY_BOOT_ID(f->header) ? \" TAIL_ENTRY_BOOT_ID\" : \"\",\n               (le32toh(f->header->compatible_flags) & ~HEADER_COMPATIBLE_ANY) ? \" ???\" : \"\",\n               JOURNAL_HEADER_COMPRESSED_XZ(f->header) ? \" COMPRESSED-XZ\" : \"\",\n               JOURNAL_HEADER_COMPRESSED_LZ4(f->header) ? \" COMPRESSED-LZ4\" : \"\",\n               JOURNAL_HEADER_COMPRESSED_ZSTD(f->header) ? \" COMPRESSED-ZSTD\" : \"\",\n               JOURNAL_HEADER_KEYED_HASH(f->header) ? \" KEYED-HASH\" : \"\",\n               JOURNAL_HEADER_COMPACT(f->header) ? \" COMPACT\" : \"\",\n               (le32toh(f->header->incompatible_flags) & ~HEADER_INCOMPATIBLE_ANY) ? \" ???\" : \"\",\n               le64toh(f->header->header_size),\n               le64toh(f->header->arena_size),\n               le64toh(f->header->data_hash_table_size) / sizeof(HashItem),\n               le64toh(f->header->field_hash_table_size) / sizeof(HashItem),\n               yes_no(journal_file_rotate_suggested(f, 0, LOG_DEBUG)),\n               le64toh(f->header->head_entry_seqnum), le64toh(f->header->head_entry_seqnum),\n               le64toh(f->header->tail_entry_seqnum), le64toh(f->header->tail_entry_seqnum),\n               FORMAT_TIMESTAMP_SAFE(le64toh(f->header->head_entry_realtime)), le64toh(f->header->head_entry_realtime),\n               FORMAT_TIMESTAMP_SAFE(le64toh(f->header->tail_entry_realtime)), le64toh(f->header->tail_entry_realtime),\n               FORMAT_TIMESPAN(le64toh(f->header->tail_entry_monotonic), USEC_PER_MSEC), le64toh(f->header->tail_entry_monotonic),\n               le64toh(f->header->n_objects),\n               le64toh(f->header->n_entries));\n\n        if (JOURNAL_HEADER_CONTAINS(f->header, n_data))\n                printf(\"Data objects: %\"PRIu64\"\\n\"\n                       \"Data hash table fill: %.1f%%\\n\",\n                       le64toh(f->header->n_data),\n                       100.0 * (double) le64toh(f->header->n_data) / ((double) (le64toh(f->header->data_hash_table_size) / sizeof(HashItem))));\n\n        if (JOURNAL_HEADER_CONTAINS(f->header, n_fields))\n                printf(\"Field objects: %\"PRIu64\"\\n\"\n                       \"Field hash table fill: %.1f%%\\n\",\n                       le64toh(f->header->n_fields),\n                       100.0 * (double) le64toh(f->header->n_fields) / ((double) (le64toh(f->header->field_hash_table_size) / sizeof(HashItem))));\n\n        if (JOURNAL_HEADER_CONTAINS(f->header, n_tags))\n                printf(\"Tag objects: %\"PRIu64\"\\n\",\n                       le64toh(f->header->n_tags));\n        if (JOURNAL_HEADER_CONTAINS(f->header, n_entry_arrays))\n                printf(\"Entry array objects: %\"PRIu64\"\\n\",\n                       le64toh(f->header->n_entry_arrays));\n\n        if (JOURNAL_HEADER_CONTAINS(f->header, field_hash_chain_depth))\n                printf(\"Deepest field hash chain: %\" PRIu64\"\\n\",\n                       f->header->field_hash_chain_depth);\n\n        if (JOURNAL_HEADER_CONTAINS(f->header, data_hash_chain_depth))\n                printf(\"Deepest data hash chain: %\" PRIu64\"\\n\",\n                       f->header->data_hash_chain_depth);\n\n        if (fstat(f->fd, &st) >= 0)\n                printf(\"Disk usage: %s\\n\", FORMAT_BYTES((uint64_t) st.st_blocks * 512ULL));\n}",
  "abstract_func": "void journal_file_print_header(JournalFile *VAR_0) {\n        struct stat VAR_1;\n\n        assert(VAR_0);\n        assert(VAR_0->header);\n\n        printf(\"File path: %s\\n\"\n               \"File ID: %s\\n\"\n               \"Machine ID: %s\\n\"\n               \"Boot ID: %s\\n\"\n               \"Sequential number ID: %s\\n\"\n               \"State: %s\\n\"\n               \"Compatible flags:%s%s%s%s\\n\"\n               \"Incompatible flags:%s%s%s%s%s%s\\n\"\n               \"Header size: %\"VAR_2\"\\n\"\n               \"Arena size: %\"VAR_2\"\\n\"\n               \"Data hash table size: %\"VAR_2\"\\n\"\n               \"Field hash table size: %\"VAR_2\"\\n\"\n               \"Rotate suggested: %s\\n\"\n               \"Head sequential number: %\"VAR_2\" (%\"VAR_3\")\\n\"\n               \"Tail sequential number: %\"VAR_2\" (%\"VAR_3\")\\n\"\n               \"Head realtime timestamp: %s (%\"VAR_3\")\\n\"\n               \"Tail realtime timestamp: %s (%\"VAR_3\")\\n\"\n               \"Tail monotonic timestamp: %s (%\"VAR_3\")\\n\"\n               \"Objects: %\"VAR_2\"\\n\"\n               \"Entry objects: %\"VAR_2\"\\n\",\n               VAR_0->path,\n               SD_ID128_TO_STRING(VAR_0->header->file_id),\n               SD_ID128_TO_STRING(VAR_0->header->machine_id),\n               SD_ID128_TO_STRING(VAR_0->header->tail_entry_boot_id),\n               SD_ID128_TO_STRING(VAR_0->header->seqnum_id),\n               VAR_0->header->state == VAR_4 ? \"OFFLINE\" :\n               VAR_0->header->state == VAR_5 ? \"ONLINE\" :\n               VAR_0->header->state == VAR_6 ? \"ARCHIVED\" : \"UNKNOWN\",\n               JOURNAL_HEADER_SEALED(VAR_0->header) ? \" SEALED\" : \"\",\n               JOURNAL_HEADER_SEALED_CONTINUOUS(VAR_0->header) ? \" SEALED_CONTINUOUS\" : \"\",\n               JOURNAL_HEADER_TAIL_ENTRY_BOOT_ID(VAR_0->header) ? \" TAIL_ENTRY_BOOT_ID\" : \"\",\n               (le32toh(VAR_0->header->compatible_flags) & ~VAR_7) ? \" ???\" : \"\",\n               JOURNAL_HEADER_COMPRESSED_XZ(VAR_0->header) ? \" COMPRESSED-XZ\" : \"\",\n               JOURNAL_HEADER_COMPRESSED_LZ4(VAR_0->header) ? \" COMPRESSED-LZ4\" : \"\",\n               JOURNAL_HEADER_COMPRESSED_ZSTD(VAR_0->header) ? \" COMPRESSED-ZSTD\" : \"\",\n               JOURNAL_HEADER_KEYED_HASH(VAR_0->header) ? \" KEYED-HASH\" : \"\",\n               JOURNAL_HEADER_COMPACT(VAR_0->header) ? \" COMPACT\" : \"\",\n               (le32toh(VAR_0->header->incompatible_flags) & ~VAR_8) ? \" ???\" : \"\",\n               le64toh(VAR_0->header->header_size),\n               le64toh(VAR_0->header->arena_size),\n               le64toh(VAR_0->header->data_hash_table_size) / sizeof(VAR_9),\n               le64toh(VAR_0->header->field_hash_table_size) / sizeof(VAR_9),\n               yes_no(journal_file_rotate_suggested(VAR_0, 0, VAR_10)),\n               le64toh(VAR_0->header->head_entry_seqnum), le64toh(VAR_0->header->head_entry_seqnum),\n               le64toh(VAR_0->header->tail_entry_seqnum), le64toh(VAR_0->header->tail_entry_seqnum),\n               FORMAT_TIMESTAMP_SAFE(le64toh(VAR_0->header->head_entry_realtime)), le64toh(VAR_0->header->head_entry_realtime),\n               FORMAT_TIMESTAMP_SAFE(le64toh(VAR_0->header->tail_entry_realtime)), le64toh(VAR_0->header->tail_entry_realtime),\n               FORMAT_TIMESPAN(le64toh(VAR_0->header->tail_entry_monotonic), VAR_11), le64toh(VAR_0->header->tail_entry_monotonic),\n               le64toh(VAR_0->header->n_objects),\n               le64toh(VAR_0->header->n_entries));\n\n        if (JOURNAL_HEADER_CONTAINS(VAR_0->header, VAR_12))\n                printf(\"Data objects: %\"VAR_2\"\\n\"\n                       \"Data hash table fill: %.1f%%\\n\",\n                       le64toh(VAR_0->header->n_data),\n                       100.0 * (double) le64toh(VAR_0->header->n_data) / ((double) (le64toh(VAR_0->header->data_hash_table_size) / sizeof(VAR_9))));\n\n        if (JOURNAL_HEADER_CONTAINS(VAR_0->header, VAR_13))\n                printf(\"Field objects: %\"VAR_2\"\\n\"\n                       \"Field hash table fill: %.1f%%\\n\",\n                       le64toh(VAR_0->header->n_fields),\n                       100.0 * (double) le64toh(VAR_0->header->n_fields) / ((double) (le64toh(VAR_0->header->field_hash_table_size) / sizeof(VAR_9))));\n\n        if (JOURNAL_HEADER_CONTAINS(VAR_0->header, VAR_14))\n                printf(\"Tag objects: %\"VAR_2\"\\n\",\n                       le64toh(VAR_0->header->n_tags));\n        if (JOURNAL_HEADER_CONTAINS(VAR_0->header, VAR_15))\n                printf(\"Entry array objects: %\"VAR_2\"\\n\",\n                       le64toh(VAR_0->header->n_entry_arrays));\n\n        if (JOURNAL_HEADER_CONTAINS(VAR_0->header, VAR_16))\n                printf(\"Deepest field hash chain: %\" VAR_2\"\\n\",\n                       VAR_0->header->field_hash_chain_depth);\n\n        if (JOURNAL_HEADER_CONTAINS(VAR_0->header, VAR_17))\n                printf(\"Deepest data hash chain: %\" VAR_2\"\\n\",\n                       VAR_0->header->data_hash_chain_depth);\n\n        if (fstat(VAR_0->fd, &VAR_1) >= 0)\n                printf(\"Disk usage: %s\\n\", FORMAT_BYTES((uint64_t) VAR_1.st_blocks * 512ULL));\n}",
  "func_graph_path": "systemd/8d7b0958cdb505047e5a66029468b8d12b8a7add/journal-file.c/vul/after/2.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -10,7 +10,7 @@\n                \"Boot ID: %s\\n\"\n                \"Sequential number ID: %s\\n\"\n                \"State: %s\\n\"\n-               \"Compatible flags:%s%s%s\\n\"\n+               \"Compatible flags:%s%s%s%s\\n\"\n                \"Incompatible flags:%s%s%s%s%s%s\\n\"\n                \"Header size: %\"PRIu64\"\\n\"\n                \"Arena size: %\"PRIu64\"\\n\"\n@@ -33,6 +33,7 @@\n                f->header->state == STATE_ONLINE ? \"ONLINE\" :\n                f->header->state == STATE_ARCHIVED ? \"ARCHIVED\" : \"UNKNOWN\",\n                JOURNAL_HEADER_SEALED(f->header) ? \" SEALED\" : \"\",\n+               JOURNAL_HEADER_SEALED_CONTINUOUS(f->header) ? \" SEALED_CONTINUOUS\" : \"\",\n                JOURNAL_HEADER_TAIL_ENTRY_BOOT_ID(f->header) ? \" TAIL_ENTRY_BOOT_ID\" : \"\",\n                (le32toh(f->header->compatible_flags) & ~HEADER_COMPATIBLE_ANY) ? \" ???\" : \"\",\n                JOURNAL_HEADER_COMPRESSED_XZ(f->header) ? \" COMPRESSED-XZ\" : \"\",",
  "diff_line_info": {
    "deleted_lines": [
      "               \"Compatible flags:%s%s%s\\n\""
    ],
    "added_lines": [
      "               \"Compatible flags:%s%s%s%s\\n\"",
      "               JOURNAL_HEADER_SEALED_CONTINUOUS(f->header) ? \" SEALED_CONTINUOUS\" : \"\","
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/systemd/systemd/pull/28886",
  "description": {
    "pr_info": {
      "title": "journalctl: verify sealed log epochs are continuous",
      "number": 28886
    },
    "comment": [
      "Currently empty epochs are not sealed. This allows an attacker to truncate a sealed log and continue it without any problems showing when verifying the log.\r\n\r\nThis partially addresses CVE-2023-31438. One way to extend this change to address CVE-2023-31438 completely, would be to verify that there is exactly one seal per epoch (and not sealing when the epoch has not ended yet). I didn't remove the premature sealing, as it is implemented purposefully although I don't understand the purpose.\r\nSee https://github.com/kastel-security/Journald/blob/main/journald-publication.pdf for more background.\r\n\r\nThis change adjusts what journald writes into a log file but is compatible in the sense that old `journalctl` versions will successfully verify new journals, but the new `journalctl --verify` will refuse to accept a journal created with old journald if there are gaps in the sealed epochs.\r\n\r\nSee also #28433\n\n<!-- devel-freezer = {\"comment-id\":\"1801865051\",\"freezing-tag\":\"v255-rc1\"} -->",
      "looks good, but i am a bit concerned about the compat with this, see comment above",
      "Good idea. I added a draft version of a `SEALED_CONTINOUS`-flag to change the error message to a warning. Thinking more closely about it: We cannot guarantee completeness for old journal files regardless of whether the epochs are continuous or not, due to the fact that journald seals an epoch prematurely when closed. Because that allows an attacker to drop the second seal, when the epoch actually ended, and claim the premature seal is the only correct one.\r\n\r\nSo I think we should drop premature sealing and then this should be the behavior:\r\nWhen not `SEALED_CONTINOUS` we should issue a warning, that we cannot guarantee consistency, unconditionally. (And for the rest of the verification, fall back to verifying the more loose constraint).\r\n\r\nWould you be fine with dropping premature sealing, that is this block:\r\nhttps://github.com/systemd/systemd/blob/1ffa5cfb38b3d30d269259c531300fc629816ea9/src/journal/managed-journal-file.c#L395\r\nor can you tell my why it is needed?",
      "I've gone ahead and removed the premature sealing. The only remaining gap is now between rotated journal files.",
      "Please rebase and squash commits.",
      "So @yuwata you do not want to do a final review and merge this, but we let it sit again until someone else picks it up?",
      "lgtm. just some minor things.",
      "An -rc1 tag has been created and a release is being prepared, so please note that PRs introducing new features and APIs will be held back until the new version has been released.\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95  \n\n**Step-by-Step Explanation:**\n\n1. **Commit Message Analysis:**\n   - The commit refers to fixing a security issue by addressing a CVE-2023-31438. It mentions that empty epochs not being sealed allows an attacker to truncate logs, which is a security risk.\n   - The commit adds a new flag `HEADER_COMPATIBLE_SEALED_CONTINUOUS` to handle sealed log epochs continuously.\n\n2. **Code Changes:**\n   - Modified `journal_file_print_header` function to include the new flag, indicating changes in how journal logs are handled and verified.\n\n3. **Vulnerability Description:**\n   - Confirms that empty epochs are not sealed, presenting a security risk. The patch addresses this by ensuring logs are sealed continuously, thereby preventing exploitation.\n\n4. **Security Assessment:**\n   - The patch directly fixes a known CVE, enhancing log file integrity and security by preventing log truncation attacks.\n\n5. **Confidence Score:**\n   - High confidence as the commit and vulnerability explicitly refer to a security issue (CVE) with clear changes to mitigate the risk."
}