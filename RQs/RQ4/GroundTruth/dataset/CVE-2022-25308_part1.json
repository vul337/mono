{
  "cve_id": "CVE-2022-25308",
  "cwe_ids": [
    "CWE-121"
  ],
  "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "fribidi",
  "commit_msg": "Fix the stack buffer overflow issue\n\nstrlen() could returns 0. Without a conditional check for len,\naccessing S_ pointer with len - 1 may causes a stack buffer overflow.\n\nAddressSanitizer reports this like:\n==1219243==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffdce043c1f at pc 0x000000403547 bp 0x7ffdce0\n43b30 sp 0x7ffdce043b28\nREAD of size 1 at 0x7ffdce043c1f thread T0\n    #0 0x403546 in main ../bin/fribidi-main.c:393\n    #1 0x7f226804e58f in __libc_start_call_main (/lib64/libc.so.6+0x2d58f)\n    #2 0x7f226804e648 in __libc_start_main_impl (/lib64/libc.so.6+0x2d648)\n    #3 0x4036f4 in _start (/tmp/fribidi/build/bin/fribidi+0x4036f4)\n\nAddress 0x7ffdce043c1f is located in stack of thread T0 at offset 63 in frame\n    #0 0x4022bf in main ../bin/fribidi-main.c:193\n\n  This frame has 5 object(s):\n    [32, 36) 'option_index' (line 233)\n    [48, 52) 'base' (line 386)\n    [64, 65064) 'S_' (line 375) <== Memory access at offset 63 underflows this variable\n    [65328, 130328) 'outstring' (line 385)\n    [130592, 390592) 'logical' (line 384)\n\nThis fixes https://github.com/fribidi/fribidi/issues/181",
  "commit_hash": "ad3a19e6372b1e667128ed1ea2f49919884587e1",
  "git_url": "https://github.com/fribidi/fribidi/commit/ad3a19e6372b1e667128ed1ea2f49919884587e1",
  "file_path": "bin/fribidi-main.c",
  "func_name": "main",
  "func_before": "int\nmain (\n  int argc,\n  char *argv[]\n)\n{\n  int exit_val;\n  fribidi_boolean file_found;\n  char *s;\n  FILE *IN;\n\n  text_width = default_text_width;\n  do_break = true;\n  do_pad = true;\n  do_mirror = true;\n  do_clean = false;\n  do_reorder_nsm = false;\n  show_input = false;\n  show_visual = true;\n  show_basedir = false;\n  show_ltov = false;\n  show_vtol = false;\n  show_levels = false;\n  char_set = \"UTF-8\";\n  bol_text = NULL;\n  eol_text = NULL;\n  input_base_direction = FRIBIDI_PAR_ON;\n\n  if ((s = (char *) getenv (\"COLUMNS\")))\n    {\n      int i;\n\n      i = atoi (s);\n      if (i > 0)\n\ttext_width = i;\n    }\n\n#define CHARSETDESC 257\n#define CAPRTL 258\n\n  /* Parse the command line with getopt library */\n  /* Must set argv[0], getopt uses it to generate error messages */\n  argv[0] = appname;\n  while (1)\n    {\n      int option_index = 0, c;\n      static struct option long_options[] = {\n\t{\"help\", 0, 0, 'h'},\n\t{\"version\", 0, 0, 'V'},\n\t{\"verbose\", 0, 0, 'v'},\n\t{\"debug\", 0, 0, 'd'},\n\t{\"test\", 0, 0, 't'},\n\t{\"charset\", 1, 0, 'c'},\n\t{\"charsetdesc\", 1, 0, CHARSETDESC},\n\t{\"caprtl\", 0, 0, CAPRTL},\n\t{\"showinput\", 0, (int *) (void *) &show_input, true},\n\t{\"nopad\", 0, (int *) (void *) &do_pad, false},\n\t{\"nobreak\", 0, (int *) (void *) &do_break, false},\n\t{\"width\", 1, 0, 'w'},\n\t{\"bol\", 1, 0, 'B'},\n\t{\"eol\", 1, 0, 'E'},\n\t{\"nomirror\", 0, (int *) (void *) &do_mirror, false},\n\t{\"reordernsm\", 0, (int *) (void *) &do_reorder_nsm, true},\n\t{\"clean\", 0, (int *) (void *) &do_clean, true},\n\t{\"ltr\", 0, (int *) (void *) &input_base_direction, FRIBIDI_PAR_LTR},\n\t{\"rtl\", 0, (int *) (void *) &input_base_direction, FRIBIDI_PAR_RTL},\n\t{\"wltr\", 0, (int *) (void *) &input_base_direction,\n\t FRIBIDI_PAR_WLTR},\n\t{\"wrtl\", 0, (int *) (void *) &input_base_direction,\n\t FRIBIDI_PAR_WRTL},\n\t{\"basedir\", 0, (int *) (void *) &show_basedir, true},\n\t{\"ltov\", 0, (int *) (void *) &show_ltov, true},\n\t{\"vtol\", 0, (int *) (void *) &show_vtol, true},\n\t{\"levels\", 0, (int *) (void *) &show_levels, true},\n\t{\"novisual\", 0, (int *) (void *) &show_visual, false},\n\t{0, 0, 0, 0}\n      };\n\n      c =\n\tgetopt_long (argc, argv, \"hVvdtc:w:B:E:\", long_options,\n\t\t     &option_index);\n      if (c == -1)\n\tbreak;\n\n      switch (c)\n\t{\n\tcase 0:\n\t  break;\n\tcase 'h':\n\t  help ();\n\t  break;\n\tcase 'V':\n\t  version ();\n\t  break;\n\tcase 'v':\n\t  show_basedir = show_ltov = show_vtol = show_levels = true;\n\t  break;\n\tcase 'w':\n\t  text_width = atoi (optarg);\n\t  if (text_width <= 0)\n\t    die2 (\"invalid screen width `%s'\\n\", optarg);\n\t  break;\n\tcase 'B':\n\t  bol_text = optarg;\n\t  break;\n\tcase 'E':\n\t  eol_text = optarg;\n\t  break;\n\tcase 'd':\n\t  if (!fribidi_set_debug (true))\n\t    die1\n\t      (\"lib\" FRIBIDI\n\t       \" must be compiled with DEBUG option to enable\\nturn debug info on.\\n\");\n\t  break;\n\tcase 't':\n\t  do_clean = show_input = do_reorder_nsm = true;\n\t  do_break = false;\n\t  text_width = default_text_width;\n\t  break;\n\tcase 'c':\n\t  char_set = my_fribidi_strdup (optarg);\n\t  if (!char_set)\n\t    die1 (\"memory allocation failed for char_set!\");\n\t  break;\n\tcase CAPRTL:\n\t  char_set = \"CapRTL\";\n\t  break;\n\tcase CHARSETDESC:\n\t  char_set = optarg;\n\t  char_set_num = fribidi_parse_charset (char_set);\n\t  if (!char_set_num)\n\t    die2 (\"unrecognized character set `%s'\\n\", char_set);\n\t  if (!fribidi_char_set_desc (char_set_num))\n\t    die2 (\"no description available for character set `%s'\\n\",\n\t\t  fribidi_char_set_name (char_set_num));\n\t  else\n\t    printf (\"Descriptions for character set %s:\\n\"\n\t\t    \"\\n\" \"%s\", fribidi_char_set_title (char_set_num),\n\t\t    fribidi_char_set_desc (char_set_num));\n\t  exit (0);\n\t  break;\n\tcase ':':\n\tcase '?':\n\t  die2 (NULL, NULL);\n\t  break;\n\tdefault:\n\t  break;\n\t}\n    }\n\n  char_set_num = fribidi_parse_charset (char_set);\n\n  if (!char_set_num)\n    die2 (\"unrecognized character set `%s'\\n\", char_set);\n\nFRIBIDI_BEGIN_IGNORE_DEPRECATIONS\n  fribidi_set_mirroring (do_mirror);\n  fribidi_set_reorder_nsm (do_reorder_nsm);\nFRIBIDI_END_IGNORE_DEPRECATIONS\n  exit_val = 0;\n  file_found = false;\n  while (optind < argc || !file_found)\n    {\n      const char *filename;\n\n      filename = optind < argc ? argv[optind++] : \"-\";\n      file_found = true;\n\n      /* Open the infile for reading */\n      if (filename[0] == '-' && !filename[1])\n\t{\n\t  IN = stdin;\n\t}\n      else\n\t{\n\t  IN = fopen (filename, \"r\");\n\t  if (!IN)\n\t    {\n\t      fprintf (stderr, \"%s: %s: no such file or directory\\n\",\n\t\t       appname, filename);\n\t      exit_val = 1;\n\t      continue;\n\t    }\n\t}\n\n      /* Read and process input one line at a time */\n      {\n\tchar S_[MAX_STR_LEN];\n\tint padding_width, break_width;\n\n\tpadding_width = show_input ? (text_width - 10) / 2 : text_width;\n\tbreak_width = do_break ? padding_width : 3 * MAX_STR_LEN;\n\n\twhile (fgets (S_, sizeof (S_) - 1, IN))\n\t  {\n\t    const char *new_line, *nl_found;\n\t    FriBidiChar logical[MAX_STR_LEN];\n\t    char outstring[MAX_STR_LEN];\n\t    FriBidiParType base;\n\t    FriBidiStrIndex len;\n\n\t    nl_found = \"\";\n\t    S_[sizeof (S_) - 1] = 0;\n\t    len = strlen (S_);\n\t    /* chop */\n\t    if (S_[len - 1] == '\\n')\n\t      {\n\t\tlen--;\n\t\tS_[len] = '\\0';\n\t\tnew_line = \"\\n\";\n\t      }\n\t    else\n\t      new_line = \"\";\n\t    /* TODO: handle \\r */\n\n\t    len = fribidi_charset_to_unicode (char_set_num, S_, len, logical);\n\n\t    {\n\t      FriBidiChar *visual;\n\t      FriBidiStrIndex *ltov, *vtol;\n\t      FriBidiLevel *levels;\n\t      fribidi_boolean log2vis;\n\n\t      visual = show_visual ? ALLOCATE (FriBidiChar,\n\t\t\t\t\t       len + 1\n\t      ) : NULL;\n\t      ltov = show_ltov ? ALLOCATE (FriBidiStrIndex,\n\t\t\t\t\t   len + 1\n\t      ) : NULL;\n\t      vtol = show_vtol ? ALLOCATE (FriBidiStrIndex,\n\t\t\t\t\t   len + 1\n\t      ) : NULL;\n\t      levels = show_levels ? ALLOCATE (FriBidiLevel,\n\t\t\t\t\t       len + 1\n\t      ) : NULL;\n\n\t      /* Create a bidi string. */\n\t      base = input_base_direction;\n\n\t      log2vis = fribidi_log2vis (logical, len, &base,\n\t\t\t\t\t /* output */\n\t\t\t\t\t visual, ltov, vtol, levels);\n\n\t      if (log2vis)\n\t\t{\n\n\t\t  if (show_input)\n\t\t    printf (\"%-*s => \", padding_width, S_);\n\n\t\t  /* Remove explicit marks, if asked for. */\n\n\t\t  if (do_clean)\n\t\t    len =\n\t\t      fribidi_remove_bidi_marks (visual, len, ltov, vtol,\n\t\t\t\t\t\t levels);\n\n\t\t  if (show_visual)\n\t\t    {\n\t\t      printf (\"%s\", nl_found);\n\n\t\t      if (bol_text)\n\t\t\tprintf (\"%s\", bol_text);\n\n\t\t      /* Convert it to input charset and print. */\n\t\t      {\n\t\t\tFriBidiStrIndex idx, st;\n\t\t\tfor (idx = 0; idx < len;)\n\t\t\t  {\n\t\t\t    FriBidiStrIndex wid, inlen;\n\n\t\t\t    wid = break_width;\n\t\t\t    st = idx;\n\t\t\t    if (char_set_num != FRIBIDI_CHAR_SET_CAP_RTL)\n\t\t\t      while (wid > 0 && idx < len)\n\t\t\t\t{\n\t\t\t\t  wid -=\n\t\t\t\t    FRIBIDI_IS_EXPLICIT_OR_ISOLATE_OR_BN_OR_NSM\n\t\t\t\t    (fribidi_get_bidi_type (visual[idx])) ? 0\n\t\t\t\t    : 1;\n\t\t\t\t  idx++;\n\t\t\t\t}\n\t\t\t    else\n\t\t\t      while (wid > 0 && idx < len)\n\t\t\t\t{\n\t\t\t\t  wid--;\n\t\t\t\t  idx++;\n\t\t\t\t}\n\t\t\t    if (wid < 0 && idx - st > 1)\n\t\t\t      idx--;\n\t\t\t    inlen = idx - st;\n\n\t\t\t    fribidi_unicode_to_charset (char_set_num,\n\t\t\t\t\t\t\tvisual + st, inlen,\n\t\t\t\t\t\t\toutstring);\n\t\t\t    if (FRIBIDI_IS_RTL (base))\n\t\t\t      printf (\"%*s\",\n\t\t\t\t      (int) (do_pad ? (padding_width +\n\t\t\t\t\t\t       strlen (outstring) -\n\t\t\t\t\t\t       (break_width -\n\t\t\t\t\t\t\twid)) : 0),\n\t\t\t\t      outstring);\n\t\t\t    else\n\t\t\t      printf (\"%s\", outstring);\n\t\t\t    if (idx < len)\n\t\t\t      printf (\"\\n\");\n\t\t\t  }\n\t\t      }\n\t\t      if (eol_text)\n\t\t\tprintf (\"%s\", eol_text);\n\n\t\t      nl_found = \"\\n\";\n\t\t    }\n\t\t  if (show_basedir)\n\t\t    {\n\t\t      printf (\"%s\", nl_found);\n\t\t      printf (\"Base direction: %s\",\n\t\t\t      (FRIBIDI_DIR_TO_LEVEL (base) ? \"R\" : \"L\"));\n\t\t      nl_found = \"\\n\";\n\t\t    }\n\t\t  if (show_ltov)\n\t\t    {\n\t\t      FriBidiStrIndex i;\n\n\t\t      printf (\"%s\", nl_found);\n\t\t      for (i = 0; i < len; i++)\n\t\t\tprintf (\"%ld \", (long) ltov[i]);\n\t\t      nl_found = \"\\n\";\n\t\t    }\n\t\t  if (show_vtol)\n\t\t    {\n\t\t      FriBidiStrIndex i;\n\n\t\t      printf (\"%s\", nl_found);\n\t\t      for (i = 0; i < len; i++)\n\t\t\tprintf (\"%ld \", (long) vtol[i]);\n\t\t      nl_found = \"\\n\";\n\t\t    }\n\t\t  if (show_levels)\n\t\t    {\n\t\t      FriBidiStrIndex i;\n\n\t\t      printf (\"%s\", nl_found);\n\t\t      for (i = 0; i < len; i++)\n\t\t\tprintf (\"%d \", (int) levels[i]);\n\t\t      nl_found = \"\\n\";\n\t\t    }\n\t\t}\n\t      else\n\t\t{\n\t\t  exit_val = 2;\n\t\t}\n\n\t      if (show_visual)\n\t\tfree (visual);\n\t      if (show_ltov)\n\t\tfree (ltov);\n\t      if (show_vtol)\n\t\tfree (vtol);\n\t      if (show_levels)\n\t\tfree (levels);\n\t    }\n\n\t    if (*nl_found)\n\t      printf (\"%s\", new_line);\n\t  }\n      }\n    }",
  "abstract_func_before": "int\nmain (\n  int VAR_0,\n  char *VAR_1[]\n)\n{\n  int VAR_2;\n  fribidi_boolean VAR_3;\n  char *VAR_4;\n  VAR_5 *VAR_6;\n\n  VAR_7 = VAR_8;\n  VAR_9 = true;\n  VAR_10 = true;\n  VAR_11 = true;\n  VAR_12 = false;\n  VAR_13 = false;\n  VAR_14 = false;\n  VAR_15 = true;\n  VAR_16 = false;\n  VAR_17 = false;\n  VAR_18 = false;\n  VAR_19 = false;\n  VAR_20 = \"UTF-8\";\n  VAR_21 = NULL;\n  VAR_22 = NULL;\n  VAR_23 = VAR_24;\n\n  if ((VAR_4 = (char *) getenv (\"COLUMNS\")))\n    {\n      int VAR_25;\n\n      VAR_25 = atoi (VAR_4);\n      if (VAR_25 > 0)\n\tVAR_7 = VAR_25;\n    }\n\n#define VAR_26 257\n#define VAR_27 258\n\n  /* COMMENT_0 */\n  /* COMMENT_1 */\n  VAR_1[0] = VAR_28;\n  while (1)\n    {\n      int VAR_29 = 0, VAR_30;\n      static struct option VAR_31[] = {\n\t{\"help\", 0, 0, 'h'},\n\t{\"version\", 0, 0, 'V'},\n\t{\"verbose\", 0, 0, 'v'},\n\t{\"debug\", 0, 0, 'd'},\n\t{\"test\", 0, 0, 't'},\n\t{\"charset\", 1, 0, 'c'},\n\t{\"charsetdesc\", 1, 0, VAR_26},\n\t{\"caprtl\", 0, 0, VAR_27},\n\t{\"showinput\", 0, (int *) (void *) &VAR_14, true},\n\t{\"nopad\", 0, (int *) (void *) &VAR_10, false},\n\t{\"nobreak\", 0, (int *) (void *) &VAR_9, false},\n\t{\"width\", 1, 0, 'w'},\n\t{\"bol\", 1, 0, 'B'},\n\t{\"eol\", 1, 0, 'E'},\n\t{\"nomirror\", 0, (int *) (void *) &VAR_11, false},\n\t{\"reordernsm\", 0, (int *) (void *) &VAR_13, true},\n\t{\"clean\", 0, (int *) (void *) &VAR_12, true},\n\t{\"ltr\", 0, (int *) (void *) &VAR_23, VAR_32},\n\t{\"rtl\", 0, (int *) (void *) &VAR_23, VAR_33},\n\t{\"wltr\", 0, (int *) (void *) &VAR_23,\n\t VAR_34},\n\t{\"wrtl\", 0, (int *) (void *) &VAR_23,\n\t VAR_35},\n\t{\"basedir\", 0, (int *) (void *) &VAR_16, true},\n\t{\"ltov\", 0, (int *) (void *) &VAR_17, true},\n\t{\"vtol\", 0, (int *) (void *) &VAR_18, true},\n\t{\"levels\", 0, (int *) (void *) &VAR_19, true},\n\t{\"novisual\", 0, (int *) (void *) &VAR_15, false},\n\t{0, 0, 0, 0}\n      };\n\n      VAR_30 =\n\tgetopt_long (VAR_0, VAR_1, \"hVvdtc:w:B:E:\", VAR_31,\n\t\t     &VAR_29);\n      if (VAR_30 == -1)\n\tbreak;\n\n      switch (VAR_30)\n\t{\n\tcase 0:\n\t  break;\n\tcase 'h':\n\t  help ();\n\t  break;\n\tcase 'V':\n\t  version ();\n\t  break;\n\tcase 'v':\n\t  VAR_16 = VAR_17 = VAR_18 = VAR_19 = true;\n\t  break;\n\tcase 'w':\n\t  VAR_7 = atoi (VAR_36);\n\t  if (VAR_7 <= 0)\n\t    die2 (\"invalid screen width `%s'\\n\", VAR_36);\n\t  break;\n\tcase 'B':\n\t  VAR_21 = VAR_36;\n\t  break;\n\tcase 'E':\n\t  VAR_22 = VAR_36;\n\t  break;\n\tcase 'd':\n\t  if (!fribidi_set_debug (true))\n\t    die1\n\t      (\"lib\" VAR_37\n\t       \" must be compiled with DEBUG option to enable\\nturn debug info on.\\n\");\n\t  break;\n\tcase 't':\n\t  VAR_12 = VAR_14 = VAR_13 = true;\n\t  VAR_9 = false;\n\t  VAR_7 = VAR_8;\n\t  break;\n\tcase 'c':\n\t  VAR_20 = my_fribidi_strdup (VAR_36);\n\t  if (!VAR_20)\n\t    die1 (\"memory allocation failed for char_set!\");\n\t  break;\n\tcase VAR_27:\n\t  VAR_20 = \"CapRTL\";\n\t  break;\n\tcase VAR_26:\n\t  VAR_20 = VAR_36;\n\t  VAR_38 = fribidi_parse_charset (VAR_20);\n\t  if (!VAR_38)\n\t    die2 (\"unrecognized character set `%s'\\n\", VAR_20);\n\t  if (!fribidi_char_set_desc (VAR_38))\n\t    die2 (\"no description available for character set `%s'\\n\",\n\t\t  fribidi_char_set_name (VAR_38));\n\t  else\n\t    printf (\"Descriptions for character set %s:\\n\"\n\t\t    \"\\n\" \"%s\", fribidi_char_set_title (VAR_38),\n\t\t    fribidi_char_set_desc (VAR_38));\n\t  exit (0);\n\t  break;\n\tcase ':':\n\tcase '?':\n\t  die2 (NULL, NULL);\n\t  break;\n\tdefault:\n\t  break;\n\t}\n    }\n\n  VAR_38 = fribidi_parse_charset (VAR_20);\n\n  if (!VAR_38)\n    die2 (\"unrecognized character set `%s'\\n\", VAR_20);\n\nFRIBIDI_BEGIN_IGNORE_DEPRECATIONS\n  fribidi_set_mirroring (do_mirror);\n  fribidi_set_reorder_nsm (VAR_13);\nFRIBIDI_END_IGNORE_DEPRECATIONS\n  VAR_2 = 0;\n  VAR_3 = false;\n  while (VAR_39 < VAR_0 || !VAR_3)\n    {\n      const char *VAR_40;\n\n      VAR_40 = VAR_39 < VAR_0 ? VAR_1[VAR_39++] : \"-\";\n      VAR_3 = true;\n\n      /* COMMENT_2 */\n      if (VAR_40[0] == '-' && !VAR_40[1])\n\t{\n\t  IN = stdinVAR_41;\n\t}\n      else\n\t{\n\t  IN = VAR_42 (filename, \"VAR_43\");\n\t  if (!IN)\n\t    {\n\t      fprintf (stderr, \"%s: %s: no such file or directory\\n\",\n\t\t       VAR_28, filename);\n\t      VAR_2 = 1;\n\t      continue;\n\t    }\n\t}\n\n      /* COMMENT_3 */\n      {\n\tchar VAR_44[VAR_45];\n\tint VAR_46, VAR_47;\n\n\tVAR_46 = VAR_14 ? (VAR_7 - 10) / 2 : VAR_7;\n\tVAR_47 = VAR_9 ? VAR_46 : 3 * VAR_45;\n\n\twhile (fgets (VAR_44, sizeof (VAR_44) - 1, VAR_6))\n\t  {\n\t    const char *VAR_48, *VAR_49;\n\t    FriBidiChar VAR_50[VAR_45];\n\t    char VAR_51[VAR_45];\n\t    FriBidiParType VAR_52;\n\t    FriBidiStrIndex VAR_53;\n\n\t    VAR_49 = \"\";\n\t    VAR_44[sizeof (VAR_44) - 1] = 0;\n\t    VAR_53 = strlen (VAR_44);\n\t    /* COMMENT_4 */\n\t    if (VAR_44[VAR_53 - 1] == '\\n')\n\t      {\n\t\tVAR_53--;\n\t\tVAR_44[VAR_53] = '\\0';\n\t\tVAR_48 = \"\\n\";\n\t      }\n\t    else\n\t      VAR_48 = \"\";\n\t    /* COMMENT_5 */\n\n\t    VAR_53 = fribidi_charset_to_unicode (VAR_38, VAR_44, VAR_53, VAR_50);\n\n\t    {\n\t      FriBidiChar *VAR_54;\n\t      FriBidiStrIndex *VAR_55, *VAR_56;\n\t      FriBidiLevel *VAR_57;\n\t      fribidi_boolean VAR_58;\n\n\t      VAR_54 = VAR_15 ? ALLOCATE (FriBidiChar,\n\t\t\t\t\t       VAR_53 + 1\n\t      ) : NULL;\n\t      VAR_55 = VAR_17 ? ALLOCATE (FriBidiStrIndex,\n\t\t\t\t\t   VAR_53 + 1\n\t      ) : NULL;\n\t      VAR_56 = VAR_18 ? ALLOCATE (FriBidiStrIndex,\n\t\t\t\t\t   VAR_53 + 1\n\t      ) : NULL;\n\t      VAR_57 = VAR_19 ? ALLOCATE (FriBidiLevel,\n\t\t\t\t\t       VAR_53 + 1\n\t      ) : NULL;\n\n\t      /* COMMENT_6 */\n\t      VAR_52 = VAR_23;\n\n\t      VAR_58 = fribidi_log2vis (VAR_50, VAR_53, &VAR_52,\n\t\t\t\t\t /* COMMENT_7 */\n\t\t\t\t\t VAR_54, VAR_55, VAR_56, VAR_57);\n\n\t      if (VAR_58)\n\t\t{\n\n\t\t  if (VAR_14)\n\t\t    printf (\"%-*s => \", VAR_46, VAR_44);\n\n\t\t  /* COMMENT_8 */\n\n\t\t  if (VAR_12)\n\t\t    VAR_53 =\n\t\t      fribidi_remove_bidi_marks (VAR_54, VAR_53, VAR_55, VAR_56,\n\t\t\t\t\t\t VAR_57);\n\n\t\t  if (VAR_15)\n\t\t    {\n\t\t      printf (\"%s\", VAR_49);\n\n\t\t      if (VAR_21)\n\t\t\tprintf (\"%s\", VAR_21);\n\n\t\t      /* COMMENT_9 */\n\t\t      {\n\t\t\tFriBidiStrIndex VAR_59, VAR_60;\n\t\t\tfor (VAR_59 = 0; VAR_59 < VAR_53;)\n\t\t\t  {\n\t\t\t    FriBidiStrIndex VAR_61, VAR_62;\n\n\t\t\t    VAR_61 = VAR_47;\n\t\t\t    VAR_60 = VAR_59;\n\t\t\t    if (VAR_38 != VAR_63)\n\t\t\t      while (VAR_61 > 0 && VAR_59 < VAR_53)\n\t\t\t\t{\n\t\t\t\t  VAR_61 -=\n\t\t\t\t    FRIBIDI_IS_EXPLICIT_OR_ISOLATE_OR_BN_OR_NSM\n\t\t\t\t    (fribidi_get_bidi_type (VAR_54[VAR_59])) ? 0\n\t\t\t\t    : 1;\n\t\t\t\t  VAR_59++;\n\t\t\t\t}\n\t\t\t    else\n\t\t\t      while (VAR_61 > 0 && VAR_59 < VAR_53)\n\t\t\t\t{\n\t\t\t\t  VAR_61--;\n\t\t\t\t  VAR_59++;\n\t\t\t\t}\n\t\t\t    if (VAR_61 < 0 && VAR_59 - VAR_60 > 1)\n\t\t\t      VAR_59--;\n\t\t\t    VAR_62 = VAR_59 - VAR_60;\n\n\t\t\t    fribidi_unicode_to_charset (VAR_38,\n\t\t\t\t\t\t\tVAR_54 + VAR_60, VAR_62,\n\t\t\t\t\t\t\tVAR_51);\n\t\t\t    if (FRIBIDI_IS_RTL (VAR_52))\n\t\t\t      printf (\"%*s\",\n\t\t\t\t      (int) (VAR_10 ? (VAR_46 +\n\t\t\t\t\t\t       strlen (VAR_51) -\n\t\t\t\t\t\t       (VAR_47 -\n\t\t\t\t\t\t\tVAR_61)) : 0),\n\t\t\t\t      VAR_51);\n\t\t\t    else\n\t\t\t      printf (\"%s\", VAR_51);\n\t\t\t    if (VAR_59 < VAR_53)\n\t\t\t      printf (\"\\n\");\n\t\t\t  }\n\t\t      }\n\t\t      if (VAR_22)\n\t\t\tprintf (\"%s\", VAR_22);\n\n\t\t      VAR_49 = \"\\n\";\n\t\t    }\n\t\t  if (VAR_16)\n\t\t    {\n\t\t      printf (\"%s\", VAR_49);\n\t\t      printf (\"Base direction: %s\",\n\t\t\t      (FRIBIDI_DIR_TO_LEVEL (VAR_52) ? \"R\" : \"L\"));\n\t\t      VAR_49 = \"\\n\";\n\t\t    }\n\t\t  if (VAR_17)\n\t\t    {\n\t\t      FriBidiStrIndex VAR_25;\n\n\t\t      printf (\"%s\", VAR_49);\n\t\t      for (VAR_25 = 0; VAR_25 < VAR_53; VAR_25++)\n\t\t\tprintf (\"%ld \", (long) VAR_55[VAR_25]);\n\t\t      VAR_49 = \"\\n\";\n\t\t    }\n\t\t  if (VAR_18)\n\t\t    {\n\t\t      FriBidiStrIndex VAR_25;\n\n\t\t      printf (\"%s\", VAR_49);\n\t\t      for (VAR_25 = 0; VAR_25 < VAR_53; VAR_25++)\n\t\t\tprintf (\"%ld \", (long) VAR_56[VAR_25]);\n\t\t      VAR_49 = \"\\n\";\n\t\t    }\n\t\t  if (VAR_19)\n\t\t    {\n\t\t      FriBidiStrIndex VAR_25;\n\n\t\t      printf (\"%s\", VAR_49);\n\t\t      for (VAR_25 = 0; VAR_25 < VAR_53; VAR_25++)\n\t\t\tprintf (\"%d \", (int) VAR_57[VAR_25]);\n\t\t      VAR_49 = \"\\n\";\n\t\t    }\n\t\t}\n\t      else\n\t\t{\n\t\t  VAR_2 = 2;\n\t\t}\n\n\t      if (VAR_15)\n\t\tfree (VAR_54);\n\t      if (VAR_17)\n\t\tfree (VAR_55);\n\t      if (VAR_18)\n\t\tfree (VAR_56);\n\t      if (VAR_19)\n\t\tfree (VAR_57);\n\t    }\n\n\t    if (*VAR_49)\n\t      printf (\"%s\", VAR_48);\n\t  }\n      }\n    }",
  "func_graph_path_before": null,
  "func": "int\nmain (\n  int argc,\n  char *argv[]\n)\n{\n  int exit_val;\n  fribidi_boolean file_found;\n  char *s;\n  FILE *IN;\n\n  text_width = default_text_width;\n  do_break = true;\n  do_pad = true;\n  do_mirror = true;\n  do_clean = false;\n  do_reorder_nsm = false;\n  show_input = false;\n  show_visual = true;\n  show_basedir = false;\n  show_ltov = false;\n  show_vtol = false;\n  show_levels = false;\n  char_set = \"UTF-8\";\n  bol_text = NULL;\n  eol_text = NULL;\n  input_base_direction = FRIBIDI_PAR_ON;\n\n  if ((s = (char *) getenv (\"COLUMNS\")))\n    {\n      int i;\n\n      i = atoi (s);\n      if (i > 0)\n\ttext_width = i;\n    }\n\n#define CHARSETDESC 257\n#define CAPRTL 258\n\n  /* Parse the command line with getopt library */\n  /* Must set argv[0], getopt uses it to generate error messages */\n  argv[0] = appname;\n  while (1)\n    {\n      int option_index = 0, c;\n      static struct option long_options[] = {\n\t{\"help\", 0, 0, 'h'},\n\t{\"version\", 0, 0, 'V'},\n\t{\"verbose\", 0, 0, 'v'},\n\t{\"debug\", 0, 0, 'd'},\n\t{\"test\", 0, 0, 't'},\n\t{\"charset\", 1, 0, 'c'},\n\t{\"charsetdesc\", 1, 0, CHARSETDESC},\n\t{\"caprtl\", 0, 0, CAPRTL},\n\t{\"showinput\", 0, (int *) (void *) &show_input, true},\n\t{\"nopad\", 0, (int *) (void *) &do_pad, false},\n\t{\"nobreak\", 0, (int *) (void *) &do_break, false},\n\t{\"width\", 1, 0, 'w'},\n\t{\"bol\", 1, 0, 'B'},\n\t{\"eol\", 1, 0, 'E'},\n\t{\"nomirror\", 0, (int *) (void *) &do_mirror, false},\n\t{\"reordernsm\", 0, (int *) (void *) &do_reorder_nsm, true},\n\t{\"clean\", 0, (int *) (void *) &do_clean, true},\n\t{\"ltr\", 0, (int *) (void *) &input_base_direction, FRIBIDI_PAR_LTR},\n\t{\"rtl\", 0, (int *) (void *) &input_base_direction, FRIBIDI_PAR_RTL},\n\t{\"wltr\", 0, (int *) (void *) &input_base_direction,\n\t FRIBIDI_PAR_WLTR},\n\t{\"wrtl\", 0, (int *) (void *) &input_base_direction,\n\t FRIBIDI_PAR_WRTL},\n\t{\"basedir\", 0, (int *) (void *) &show_basedir, true},\n\t{\"ltov\", 0, (int *) (void *) &show_ltov, true},\n\t{\"vtol\", 0, (int *) (void *) &show_vtol, true},\n\t{\"levels\", 0, (int *) (void *) &show_levels, true},\n\t{\"novisual\", 0, (int *) (void *) &show_visual, false},\n\t{0, 0, 0, 0}\n      };\n\n      c =\n\tgetopt_long (argc, argv, \"hVvdtc:w:B:E:\", long_options,\n\t\t     &option_index);\n      if (c == -1)\n\tbreak;\n\n      switch (c)\n\t{\n\tcase 0:\n\t  break;\n\tcase 'h':\n\t  help ();\n\t  break;\n\tcase 'V':\n\t  version ();\n\t  break;\n\tcase 'v':\n\t  show_basedir = show_ltov = show_vtol = show_levels = true;\n\t  break;\n\tcase 'w':\n\t  text_width = atoi (optarg);\n\t  if (text_width <= 0)\n\t    die2 (\"invalid screen width `%s'\\n\", optarg);\n\t  break;\n\tcase 'B':\n\t  bol_text = optarg;\n\t  break;\n\tcase 'E':\n\t  eol_text = optarg;\n\t  break;\n\tcase 'd':\n\t  if (!fribidi_set_debug (true))\n\t    die1\n\t      (\"lib\" FRIBIDI\n\t       \" must be compiled with DEBUG option to enable\\nturn debug info on.\\n\");\n\t  break;\n\tcase 't':\n\t  do_clean = show_input = do_reorder_nsm = true;\n\t  do_break = false;\n\t  text_width = default_text_width;\n\t  break;\n\tcase 'c':\n\t  char_set = my_fribidi_strdup (optarg);\n\t  if (!char_set)\n\t    die1 (\"memory allocation failed for char_set!\");\n\t  break;\n\tcase CAPRTL:\n\t  char_set = \"CapRTL\";\n\t  break;\n\tcase CHARSETDESC:\n\t  char_set = optarg;\n\t  char_set_num = fribidi_parse_charset (char_set);\n\t  if (!char_set_num)\n\t    die2 (\"unrecognized character set `%s'\\n\", char_set);\n\t  if (!fribidi_char_set_desc (char_set_num))\n\t    die2 (\"no description available for character set `%s'\\n\",\n\t\t  fribidi_char_set_name (char_set_num));\n\t  else\n\t    printf (\"Descriptions for character set %s:\\n\"\n\t\t    \"\\n\" \"%s\", fribidi_char_set_title (char_set_num),\n\t\t    fribidi_char_set_desc (char_set_num));\n\t  exit (0);\n\t  break;\n\tcase ':':\n\tcase '?':\n\t  die2 (NULL, NULL);\n\t  break;\n\tdefault:\n\t  break;\n\t}\n    }\n\n  char_set_num = fribidi_parse_charset (char_set);\n\n  if (!char_set_num)\n    die2 (\"unrecognized character set `%s'\\n\", char_set);\n\nFRIBIDI_BEGIN_IGNORE_DEPRECATIONS\n  fribidi_set_mirroring (do_mirror);\n  fribidi_set_reorder_nsm (do_reorder_nsm);\nFRIBIDI_END_IGNORE_DEPRECATIONS\n  exit_val = 0;\n  file_found = false;\n  while (optind < argc || !file_found)\n    {\n      const char *filename;\n\n      filename = optind < argc ? argv[optind++] : \"-\";\n      file_found = true;\n\n      /* Open the infile for reading */\n      if (filename[0] == '-' && !filename[1])\n\t{\n\t  IN = stdin;\n\t}\n      else\n\t{\n\t  IN = fopen (filename, \"r\");\n\t  if (!IN)\n\t    {\n\t      fprintf (stderr, \"%s: %s: no such file or directory\\n\",\n\t\t       appname, filename);\n\t      exit_val = 1;\n\t      continue;\n\t    }\n\t}\n\n      /* Read and process input one line at a time */\n      {\n\tchar S_[MAX_STR_LEN];\n\tint padding_width, break_width;\n\n\tpadding_width = show_input ? (text_width - 10) / 2 : text_width;\n\tbreak_width = do_break ? padding_width : 3 * MAX_STR_LEN;\n\n\twhile (fgets (S_, sizeof (S_) - 1, IN))\n\t  {\n\t    const char *new_line, *nl_found;\n\t    FriBidiChar logical[MAX_STR_LEN];\n\t    char outstring[MAX_STR_LEN];\n\t    FriBidiParType base;\n\t    FriBidiStrIndex len;\n\n\t    nl_found = \"\";\n\t    S_[sizeof (S_) - 1] = 0;\n\t    len = strlen (S_);\n\t    /* chop */\n\t    if (len > 0 && S_[len - 1] == '\\n')\n\t      {\n\t\tlen--;\n\t\tS_[len] = '\\0';\n\t\tnew_line = \"\\n\";\n\t      }\n\t    else\n\t      new_line = \"\";\n\t    /* TODO: handle \\r */\n\n\t    len = fribidi_charset_to_unicode (char_set_num, S_, len, logical);\n\n\t    {\n\t      FriBidiChar *visual;\n\t      FriBidiStrIndex *ltov, *vtol;\n\t      FriBidiLevel *levels;\n\t      fribidi_boolean log2vis;\n\n\t      visual = show_visual ? ALLOCATE (FriBidiChar,\n\t\t\t\t\t       len + 1\n\t      ) : NULL;\n\t      ltov = show_ltov ? ALLOCATE (FriBidiStrIndex,\n\t\t\t\t\t   len + 1\n\t      ) : NULL;\n\t      vtol = show_vtol ? ALLOCATE (FriBidiStrIndex,\n\t\t\t\t\t   len + 1\n\t      ) : NULL;\n\t      levels = show_levels ? ALLOCATE (FriBidiLevel,\n\t\t\t\t\t       len + 1\n\t      ) : NULL;\n\n\t      /* Create a bidi string. */\n\t      base = input_base_direction;\n\n\t      log2vis = fribidi_log2vis (logical, len, &base,\n\t\t\t\t\t /* output */\n\t\t\t\t\t visual, ltov, vtol, levels);\n\n\t      if (log2vis)\n\t\t{\n\n\t\t  if (show_input)\n\t\t    printf (\"%-*s => \", padding_width, S_);\n\n\t\t  /* Remove explicit marks, if asked for. */\n\n\t\t  if (do_clean)\n\t\t    len =\n\t\t      fribidi_remove_bidi_marks (visual, len, ltov, vtol,\n\t\t\t\t\t\t levels);\n\n\t\t  if (show_visual)\n\t\t    {\n\t\t      printf (\"%s\", nl_found);\n\n\t\t      if (bol_text)\n\t\t\tprintf (\"%s\", bol_text);\n\n\t\t      /* Convert it to input charset and print. */\n\t\t      {\n\t\t\tFriBidiStrIndex idx, st;\n\t\t\tfor (idx = 0; idx < len;)\n\t\t\t  {\n\t\t\t    FriBidiStrIndex wid, inlen;\n\n\t\t\t    wid = break_width;\n\t\t\t    st = idx;\n\t\t\t    if (char_set_num != FRIBIDI_CHAR_SET_CAP_RTL)\n\t\t\t      while (wid > 0 && idx < len)\n\t\t\t\t{\n\t\t\t\t  wid -=\n\t\t\t\t    FRIBIDI_IS_EXPLICIT_OR_ISOLATE_OR_BN_OR_NSM\n\t\t\t\t    (fribidi_get_bidi_type (visual[idx])) ? 0\n\t\t\t\t    : 1;\n\t\t\t\t  idx++;\n\t\t\t\t}\n\t\t\t    else\n\t\t\t      while (wid > 0 && idx < len)\n\t\t\t\t{\n\t\t\t\t  wid--;\n\t\t\t\t  idx++;\n\t\t\t\t}\n\t\t\t    if (wid < 0 && idx - st > 1)\n\t\t\t      idx--;\n\t\t\t    inlen = idx - st;\n\n\t\t\t    fribidi_unicode_to_charset (char_set_num,\n\t\t\t\t\t\t\tvisual + st, inlen,\n\t\t\t\t\t\t\toutstring);\n\t\t\t    if (FRIBIDI_IS_RTL (base))\n\t\t\t      printf (\"%*s\",\n\t\t\t\t      (int) (do_pad ? (padding_width +\n\t\t\t\t\t\t       strlen (outstring) -\n\t\t\t\t\t\t       (break_width -\n\t\t\t\t\t\t\twid)) : 0),\n\t\t\t\t      outstring);\n\t\t\t    else\n\t\t\t      printf (\"%s\", outstring);\n\t\t\t    if (idx < len)\n\t\t\t      printf (\"\\n\");\n\t\t\t  }\n\t\t      }\n\t\t      if (eol_text)\n\t\t\tprintf (\"%s\", eol_text);\n\n\t\t      nl_found = \"\\n\";\n\t\t    }\n\t\t  if (show_basedir)\n\t\t    {\n\t\t      printf (\"%s\", nl_found);\n\t\t      printf (\"Base direction: %s\",\n\t\t\t      (FRIBIDI_DIR_TO_LEVEL (base) ? \"R\" : \"L\"));\n\t\t      nl_found = \"\\n\";\n\t\t    }\n\t\t  if (show_ltov)\n\t\t    {\n\t\t      FriBidiStrIndex i;\n\n\t\t      printf (\"%s\", nl_found);\n\t\t      for (i = 0; i < len; i++)\n\t\t\tprintf (\"%ld \", (long) ltov[i]);\n\t\t      nl_found = \"\\n\";\n\t\t    }\n\t\t  if (show_vtol)\n\t\t    {\n\t\t      FriBidiStrIndex i;\n\n\t\t      printf (\"%s\", nl_found);\n\t\t      for (i = 0; i < len; i++)\n\t\t\tprintf (\"%ld \", (long) vtol[i]);\n\t\t      nl_found = \"\\n\";\n\t\t    }\n\t\t  if (show_levels)\n\t\t    {\n\t\t      FriBidiStrIndex i;\n\n\t\t      printf (\"%s\", nl_found);\n\t\t      for (i = 0; i < len; i++)\n\t\t\tprintf (\"%d \", (int) levels[i]);\n\t\t      nl_found = \"\\n\";\n\t\t    }\n\t\t}\n\t      else\n\t\t{\n\t\t  exit_val = 2;\n\t\t}\n\n\t      if (show_visual)\n\t\tfree (visual);\n\t      if (show_ltov)\n\t\tfree (ltov);\n\t      if (show_vtol)\n\t\tfree (vtol);\n\t      if (show_levels)\n\t\tfree (levels);\n\t    }\n\n\t    if (*nl_found)\n\t      printf (\"%s\", new_line);\n\t  }\n      }\n    }",
  "abstract_func": "int\nmain (\n  int VAR_0,\n  char *VAR_1[]\n)\n{\n  int VAR_2;\n  fribidi_boolean VAR_3;\n  char *VAR_4;\n  VAR_5 *VAR_6;\n\n  VAR_7 = VAR_8;\n  VAR_9 = true;\n  VAR_10 = true;\n  VAR_11 = true;\n  VAR_12 = false;\n  VAR_13 = false;\n  VAR_14 = false;\n  VAR_15 = true;\n  VAR_16 = false;\n  VAR_17 = false;\n  VAR_18 = false;\n  VAR_19 = false;\n  VAR_20 = \"UTF-8\";\n  VAR_21 = NULL;\n  VAR_22 = NULL;\n  VAR_23 = VAR_24;\n\n  if ((VAR_4 = (char *) getenv (\"COLUMNS\")))\n    {\n      int VAR_25;\n\n      VAR_25 = atoi (VAR_4);\n      if (VAR_25 > 0)\n\tVAR_7 = VAR_25;\n    }\n\n#define VAR_26 257\n#define VAR_27 258\n\n  /* COMMENT_0 */\n  /* COMMENT_1 */\n  VAR_1[0] = VAR_28;\n  while (1)\n    {\n      int VAR_29 = 0, VAR_30;\n      static struct option VAR_31[] = {\n\t{\"help\", 0, 0, 'h'},\n\t{\"version\", 0, 0, 'V'},\n\t{\"verbose\", 0, 0, 'v'},\n\t{\"debug\", 0, 0, 'd'},\n\t{\"test\", 0, 0, 't'},\n\t{\"charset\", 1, 0, 'c'},\n\t{\"charsetdesc\", 1, 0, VAR_26},\n\t{\"caprtl\", 0, 0, VAR_27},\n\t{\"showinput\", 0, (int *) (void *) &VAR_14, true},\n\t{\"nopad\", 0, (int *) (void *) &VAR_10, false},\n\t{\"nobreak\", 0, (int *) (void *) &VAR_9, false},\n\t{\"width\", 1, 0, 'w'},\n\t{\"bol\", 1, 0, 'B'},\n\t{\"eol\", 1, 0, 'E'},\n\t{\"nomirror\", 0, (int *) (void *) &VAR_11, false},\n\t{\"reordernsm\", 0, (int *) (void *) &VAR_13, true},\n\t{\"clean\", 0, (int *) (void *) &VAR_12, true},\n\t{\"ltr\", 0, (int *) (void *) &VAR_23, VAR_32},\n\t{\"rtl\", 0, (int *) (void *) &VAR_23, VAR_33},\n\t{\"wltr\", 0, (int *) (void *) &VAR_23,\n\t VAR_34},\n\t{\"wrtl\", 0, (int *) (void *) &VAR_23,\n\t VAR_35},\n\t{\"basedir\", 0, (int *) (void *) &VAR_16, true},\n\t{\"ltov\", 0, (int *) (void *) &VAR_17, true},\n\t{\"vtol\", 0, (int *) (void *) &VAR_18, true},\n\t{\"levels\", 0, (int *) (void *) &VAR_19, true},\n\t{\"novisual\", 0, (int *) (void *) &VAR_15, false},\n\t{0, 0, 0, 0}\n      };\n\n      VAR_30 =\n\tgetopt_long (VAR_0, VAR_1, \"hVvdtc:w:B:E:\", VAR_31,\n\t\t     &VAR_29);\n      if (VAR_30 == -1)\n\tbreak;\n\n      switch (VAR_30)\n\t{\n\tcase 0:\n\t  break;\n\tcase 'h':\n\t  help ();\n\t  break;\n\tcase 'V':\n\t  version ();\n\t  break;\n\tcase 'v':\n\t  VAR_16 = VAR_17 = VAR_18 = VAR_19 = true;\n\t  break;\n\tcase 'w':\n\t  VAR_7 = atoi (VAR_36);\n\t  if (VAR_7 <= 0)\n\t    die2 (\"invalid screen width `%s'\\n\", VAR_36);\n\t  break;\n\tcase 'B':\n\t  VAR_21 = VAR_36;\n\t  break;\n\tcase 'E':\n\t  VAR_22 = VAR_36;\n\t  break;\n\tcase 'd':\n\t  if (!fribidi_set_debug (true))\n\t    die1\n\t      (\"lib\" VAR_37\n\t       \" must be compiled with DEBUG option to enable\\nturn debug info on.\\n\");\n\t  break;\n\tcase 't':\n\t  VAR_12 = VAR_14 = VAR_13 = true;\n\t  VAR_9 = false;\n\t  VAR_7 = VAR_8;\n\t  break;\n\tcase 'c':\n\t  VAR_20 = my_fribidi_strdup (VAR_36);\n\t  if (!VAR_20)\n\t    die1 (\"memory allocation failed for char_set!\");\n\t  break;\n\tcase VAR_27:\n\t  VAR_20 = \"CapRTL\";\n\t  break;\n\tcase VAR_26:\n\t  VAR_20 = VAR_36;\n\t  VAR_38 = fribidi_parse_charset (VAR_20);\n\t  if (!VAR_38)\n\t    die2 (\"unrecognized character set `%s'\\n\", VAR_20);\n\t  if (!fribidi_char_set_desc (VAR_38))\n\t    die2 (\"no description available for character set `%s'\\n\",\n\t\t  fribidi_char_set_name (VAR_38));\n\t  else\n\t    printf (\"Descriptions for character set %s:\\n\"\n\t\t    \"\\n\" \"%s\", fribidi_char_set_title (VAR_38),\n\t\t    fribidi_char_set_desc (VAR_38));\n\t  exit (0);\n\t  break;\n\tcase ':':\n\tcase '?':\n\t  die2 (NULL, NULL);\n\t  break;\n\tdefault:\n\t  break;\n\t}\n    }\n\n  VAR_38 = fribidi_parse_charset (VAR_20);\n\n  if (!VAR_38)\n    die2 (\"unrecognized character set `%s'\\n\", VAR_20);\n\nFRIBIDI_BEGIN_IGNORE_DEPRECATIONS\n  fribidi_set_mirroring (do_mirror);\n  fribidi_set_reorder_nsm (VAR_13);\nFRIBIDI_END_IGNORE_DEPRECATIONS\n  VAR_2 = 0;\n  VAR_3 = false;\n  while (VAR_39 < VAR_0 || !VAR_3)\n    {\n      const char *VAR_40;\n\n      VAR_40 = VAR_39 < VAR_0 ? VAR_1[VAR_39++] : \"-\";\n      VAR_3 = true;\n\n      /* COMMENT_2 */\n      if (VAR_40[0] == '-' && !VAR_40[1])\n\t{\n\t  IN = stdinVAR_41;\n\t}\n      else\n\t{\n\t  IN = VAR_42 (filename, \"VAR_43\");\n\t  if (!IN)\n\t    {\n\t      fprintf (stderr, \"%s: %s: no such file or directory\\n\",\n\t\t       VAR_28, filename);\n\t      VAR_2 = 1;\n\t      continue;\n\t    }\n\t}\n\n      /* COMMENT_3 */\n      {\n\tchar VAR_44[VAR_45];\n\tint VAR_46, VAR_47;\n\n\tVAR_46 = VAR_14 ? (VAR_7 - 10) / 2 : VAR_7;\n\tVAR_47 = VAR_9 ? VAR_46 : 3 * VAR_45;\n\n\twhile (fgets (VAR_44, sizeof (VAR_44) - 1, VAR_6))\n\t  {\n\t    const char *VAR_48, *VAR_49;\n\t    FriBidiChar VAR_50[VAR_45];\n\t    char VAR_51[VAR_45];\n\t    FriBidiParType VAR_52;\n\t    FriBidiStrIndex VAR_53;\n\n\t    VAR_49 = \"\";\n\t    VAR_44[sizeof (VAR_44) - 1] = 0;\n\t    VAR_53 = strlen (VAR_44);\n\t    /* COMMENT_4 */\n\t    if (VAR_53 > 0 && VAR_44[VAR_53 - 1] == '\\n')\n\t      {\n\t\tVAR_53--;\n\t\tVAR_44[VAR_53] = '\\0';\n\t\tVAR_48 = \"\\n\";\n\t      }\n\t    else\n\t      VAR_48 = \"\";\n\t    /* COMMENT_5 */\n\n\t    VAR_53 = fribidi_charset_to_unicode (VAR_38, VAR_44, VAR_53, VAR_50);\n\n\t    {\n\t      FriBidiChar *VAR_54;\n\t      FriBidiStrIndex *VAR_55, *VAR_56;\n\t      FriBidiLevel *VAR_57;\n\t      fribidi_boolean VAR_58;\n\n\t      VAR_54 = VAR_15 ? ALLOCATE (FriBidiChar,\n\t\t\t\t\t       VAR_53 + 1\n\t      ) : NULL;\n\t      VAR_55 = VAR_17 ? ALLOCATE (FriBidiStrIndex,\n\t\t\t\t\t   VAR_53 + 1\n\t      ) : NULL;\n\t      VAR_56 = VAR_18 ? ALLOCATE (FriBidiStrIndex,\n\t\t\t\t\t   VAR_53 + 1\n\t      ) : NULL;\n\t      VAR_57 = VAR_19 ? ALLOCATE (FriBidiLevel,\n\t\t\t\t\t       VAR_53 + 1\n\t      ) : NULL;\n\n\t      /* COMMENT_6 */\n\t      VAR_52 = VAR_23;\n\n\t      VAR_58 = fribidi_log2vis (VAR_50, VAR_53, &VAR_52,\n\t\t\t\t\t /* COMMENT_7 */\n\t\t\t\t\t VAR_54, VAR_55, VAR_56, VAR_57);\n\n\t      if (VAR_58)\n\t\t{\n\n\t\t  if (VAR_14)\n\t\t    printf (\"%-*s => \", VAR_46, VAR_44);\n\n\t\t  /* COMMENT_8 */\n\n\t\t  if (VAR_12)\n\t\t    VAR_53 =\n\t\t      fribidi_remove_bidi_marks (VAR_54, VAR_53, VAR_55, VAR_56,\n\t\t\t\t\t\t VAR_57);\n\n\t\t  if (VAR_15)\n\t\t    {\n\t\t      printf (\"%s\", VAR_49);\n\n\t\t      if (VAR_21)\n\t\t\tprintf (\"%s\", VAR_21);\n\n\t\t      /* COMMENT_9 */\n\t\t      {\n\t\t\tFriBidiStrIndex VAR_59, VAR_60;\n\t\t\tfor (VAR_59 = 0; VAR_59 < VAR_53;)\n\t\t\t  {\n\t\t\t    FriBidiStrIndex VAR_61, VAR_62;\n\n\t\t\t    VAR_61 = VAR_47;\n\t\t\t    VAR_60 = VAR_59;\n\t\t\t    if (VAR_38 != VAR_63)\n\t\t\t      while (VAR_61 > 0 && VAR_59 < VAR_53)\n\t\t\t\t{\n\t\t\t\t  VAR_61 -=\n\t\t\t\t    FRIBIDI_IS_EXPLICIT_OR_ISOLATE_OR_BN_OR_NSM\n\t\t\t\t    (fribidi_get_bidi_type (VAR_54[VAR_59])) ? 0\n\t\t\t\t    : 1;\n\t\t\t\t  VAR_59++;\n\t\t\t\t}\n\t\t\t    else\n\t\t\t      while (VAR_61 > 0 && VAR_59 < VAR_53)\n\t\t\t\t{\n\t\t\t\t  VAR_61--;\n\t\t\t\t  VAR_59++;\n\t\t\t\t}\n\t\t\t    if (VAR_61 < 0 && VAR_59 - VAR_60 > 1)\n\t\t\t      VAR_59--;\n\t\t\t    VAR_62 = VAR_59 - VAR_60;\n\n\t\t\t    fribidi_unicode_to_charset (VAR_38,\n\t\t\t\t\t\t\tVAR_54 + VAR_60, VAR_62,\n\t\t\t\t\t\t\tVAR_51);\n\t\t\t    if (FRIBIDI_IS_RTL (VAR_52))\n\t\t\t      printf (\"%*s\",\n\t\t\t\t      (int) (VAR_10 ? (VAR_46 +\n\t\t\t\t\t\t       strlen (VAR_51) -\n\t\t\t\t\t\t       (VAR_47 -\n\t\t\t\t\t\t\tVAR_61)) : 0),\n\t\t\t\t      VAR_51);\n\t\t\t    else\n\t\t\t      printf (\"%s\", VAR_51);\n\t\t\t    if (VAR_59 < VAR_53)\n\t\t\t      printf (\"\\n\");\n\t\t\t  }\n\t\t      }\n\t\t      if (VAR_22)\n\t\t\tprintf (\"%s\", VAR_22);\n\n\t\t      VAR_49 = \"\\n\";\n\t\t    }\n\t\t  if (VAR_16)\n\t\t    {\n\t\t      printf (\"%s\", VAR_49);\n\t\t      printf (\"Base direction: %s\",\n\t\t\t      (FRIBIDI_DIR_TO_LEVEL (VAR_52) ? \"R\" : \"L\"));\n\t\t      VAR_49 = \"\\n\";\n\t\t    }\n\t\t  if (VAR_17)\n\t\t    {\n\t\t      FriBidiStrIndex VAR_25;\n\n\t\t      printf (\"%s\", VAR_49);\n\t\t      for (VAR_25 = 0; VAR_25 < VAR_53; VAR_25++)\n\t\t\tprintf (\"%ld \", (long) VAR_55[VAR_25]);\n\t\t      VAR_49 = \"\\n\";\n\t\t    }\n\t\t  if (VAR_18)\n\t\t    {\n\t\t      FriBidiStrIndex VAR_25;\n\n\t\t      printf (\"%s\", VAR_49);\n\t\t      for (VAR_25 = 0; VAR_25 < VAR_53; VAR_25++)\n\t\t\tprintf (\"%ld \", (long) VAR_56[VAR_25]);\n\t\t      VAR_49 = \"\\n\";\n\t\t    }\n\t\t  if (VAR_19)\n\t\t    {\n\t\t      FriBidiStrIndex VAR_25;\n\n\t\t      printf (\"%s\", VAR_49);\n\t\t      for (VAR_25 = 0; VAR_25 < VAR_53; VAR_25++)\n\t\t\tprintf (\"%d \", (int) VAR_57[VAR_25]);\n\t\t      VAR_49 = \"\\n\";\n\t\t    }\n\t\t}\n\t      else\n\t\t{\n\t\t  VAR_2 = 2;\n\t\t}\n\n\t      if (VAR_15)\n\t\tfree (VAR_54);\n\t      if (VAR_17)\n\t\tfree (VAR_55);\n\t      if (VAR_18)\n\t\tfree (VAR_56);\n\t      if (VAR_19)\n\t\tfree (VAR_57);\n\t    }\n\n\t    if (*VAR_49)\n\t      printf (\"%s\", VAR_48);\n\t  }\n      }\n    }",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -203,7 +203,7 @@\n \t    S_[sizeof (S_) - 1] = 0;\n \t    len = strlen (S_);\n \t    /* chop */\n-\t    if (S_[len - 1] == '\\n')\n+\t    if (len > 0 && S_[len - 1] == '\\n')\n \t      {\n \t\tlen--;\n \t\tS_[len] = '\\0';",
  "diff_line_info": {
    "deleted_lines": [
      "\t    if (S_[len - 1] == '\\n')"
    ],
    "added_lines": [
      "\t    if (len > 0 && S_[len - 1] == '\\n')"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/fribidi/fribidi/pull/184",
  "description": {
    "pr_info": {
      "title": "Fix the stack buffer overflow issue",
      "number": 184
    },
    "comment": [
      "strlen() could returns 0. Without a conditional check for len,\r\naccessing S_ pointer with len - 1 may causes a stack buffer overflow.\r\n\r\nAddressSanitizer reports this like:\r\n==1219243==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffdce043c1f at pc 0x000000403547 bp 0x7ffdce0\r\n43b30 sp 0x7ffdce043b28\r\nREAD of size 1 at 0x7ffdce043c1f thread T0\r\n    #0 0x403546 in main ../bin/fribidi-main.c:393\r\n    #1 0x7f226804e58f in __libc_start_call_main (/lib64/libc.so.6+0x2d58f)\r\n    #2 0x7f226804e648 in __libc_start_main_impl (/lib64/libc.so.6+0x2d648)\r\n    #3 0x4036f4 in _start (/tmp/fribidi/build/bin/fribidi+0x4036f4)\r\n\r\nAddress 0x7ffdce043c1f is located in stack of thread T0 at offset 63 in frame\r\n    #0 0x4022bf in main ../bin/fribidi-main.c:193\r\n\r\n  This frame has 5 object(s):\r\n    [32, 36) 'option_index' (line 233)\r\n    [48, 52) 'base' (line 386)\r\n    [64, 65064) 'S_' (line 375) <== Memory access at offset 63 underflows this variable\r\n    [65328, 130328) 'outstring' (line 385)\r\n    [130592, 390592) 'logical' (line 384)\r\n\r\nThis fixes https://github.com/fribidi/fribidi/issues/181"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}