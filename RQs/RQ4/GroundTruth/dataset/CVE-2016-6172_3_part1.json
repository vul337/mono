{
  "cve_id": "CVE-2016-6172",
  "cwe_ids": [
    "CWE-400"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:C",
  "cvss_is_v3": false,
  "repo_name": "PowerDNS/pdns",
  "commit_msg": "Add limits to the size of received {A,I}XFR, in megabytes\n\nThis prevents memory exhaustion in case the master is sending a\nvery large amount of data in an update.",
  "commit_hash": "db8f9152168acf5d548d4f256789eae783e01667",
  "git_url": "https://github.com/PowerDNS/pdns/commit/db8f9152168acf5d548d4f256789eae783e01667",
  "file_path": "pdns/slavecommunicator.cc",
  "func_name": "doAxfr",
  "func_before": "vector<DNSResourceRecord> doAxfr(const ComboAddress& raddr, const DNSName& domain, const TSIGTriplet& tt, const ComboAddress& laddr,  scoped_ptr<AuthLua>& pdl, ZoneStatus& zs)\n{\n  vector<DNSResourceRecord> rrs;\n  AXFRRetriever retriever(raddr, domain, tt, (laddr.sin4.sin_family == 0) ? NULL : &laddr);\n  Resolver::res_t recs;\n  bool first=true;\n  bool firstNSEC3{true};\n  bool soa_received {false};\n  while(retriever.getChunk(recs)) {\n    if(first) {\n      L<<Logger::Error<<\"AXFR started for '\"<<domain<<\"'\"<<endl;\n      first=false;\n    }\n\n    for(Resolver::res_t::iterator i=recs.begin();i!=recs.end();++i) {\n      if(i->qtype.getCode() == QType::OPT || i->qtype.getCode() == QType::TSIG) // ignore EDNS0 & TSIG\n        continue;\n\n      if(!i->qname.isPartOf(domain)) {\n        L<<Logger::Error<<\"Remote \"<<raddr.toStringWithPort()<<\" tried to sneak in out-of-zone data '\"<<i->qname<<\"'|\"<<i->qtype.getName()<<\" during AXFR of zone '\"<<domain<<\"', ignoring\"<<endl;\n        continue;\n      }\n\n      vector<DNSResourceRecord> out;\n      if(!pdl || !pdl->axfrfilter(raddr, domain, *i, out)) {\n        out.push_back(*i); // if axfrfilter didn't do anything, we put our record in 'out' ourselves\n      }\n\n      for(DNSResourceRecord& rr :  out) {\n        if(!processRecordForZS(domain, firstNSEC3, rr, zs))\n          continue;\n        if(rr.qtype.getCode() == QType::SOA) {\n          if(soa_received)\n            continue; //skip the last SOA\n          SOAData sd;\n          fillSOAData(rr.content,sd);\n          zs.soa_serial = sd.serial;\n          soa_received = true;\n        }\n\n        rrs.push_back(rr);\n\n      }\n    }\n  }\n  return rrs;\n}",
  "abstract_func_before": "vector<DNSResourceRecord> doAxfr(const ComboAddress& VAR_0, const DNSName& VAR_1, const TSIGTriplet& VAR_2, const ComboAddress& VAR_3,  scoped_ptr<AuthLua>& VAR_4, ZoneStatus& VAR_5)\n{\n  vector<DNSResourceRecord> VAR_6;\n  AXFRRetriever VAR_7(VAR_0, VAR_1, VAR_2, (VAR_3.sin4.sin_family == 0) ? NULL : &VAR_3);\n  Resolver::res_t VAR_8;\n  bool VAR_9=true;\n  bool VAR_10{true};\n  bool VAR_11 {false};\n  while(VAR_7.getChunk(VAR_8)) {\n    if(VAR_9) {\n      VAR_12<<Logger::Error<<\"AXFR started for '\"<<VAR_1<<\"'\"<<VAR_13;\n      VAR_9=false;\n    }\n\n    for(Resolver::res_t::iterator VAR_14=VAR_8.begin();VAR_14!=VAR_8.end();++VAR_14) {\n      if(VAR_14->qtype.getCode() == QType::OPT || VAR_14->qtype.getCode() == QType::TSIG) /* COMMENT_0 */\n        continue;\n\n      if(!VAR_14->qname.isPartOf(VAR_1)) {\n        VAR_12<<Logger::Error<<\"Remote \"<<VAR_0.toStringWithPort()<<\" tried to sneak in out-of-zone data '\"<<VAR_14->qname<<\"'|\"<<VAR_14->qtype.getName()<<\" during AXFR of zone '\"<<VAR_1<<\"', ignoring\"<<VAR_13;\n        continue;\n      }\n\n      vector<DNSResourceRecord> VAR_15;\n      if(!VAR_4 || !VAR_4->axfrfilter(VAR_0, VAR_1, *VAR_14, VAR_15)) {\n        VAR_15.push_back(*VAR_14); /* COMMENT_1 */\n      }\n\n      for(DNSResourceRecord& VAR_16 :  VAR_15) {\n        if(!processRecordForZS(VAR_1, VAR_10, VAR_16, VAR_5))\n          continue;\n        if(VAR_16.qtype.getCode() == QType::SOA) {\n          if(VAR_11)\n            continue; /* COMMENT_2 */\n          SOAData VAR_17;\n          fillSOAData(VAR_16.content,VAR_17);\n          VAR_5.soa_serial = VAR_17.serial;\n          VAR_11 = true;\n        }\n\n        VAR_6.push_back(VAR_16);\n\n      }\n    }\n  }\n  return VAR_6;\n}",
  "func_graph_path_before": "PowerDNS/pdns/db8f9152168acf5d548d4f256789eae783e01667/slavecommunicator.cc/vul/before/0.json",
  "func": "vector<DNSResourceRecord> doAxfr(const ComboAddress& raddr, const DNSName& domain, const TSIGTriplet& tt, const ComboAddress& laddr,  scoped_ptr<AuthLua>& pdl, ZoneStatus& zs)\n{\n  vector<DNSResourceRecord> rrs;\n  AXFRRetriever retriever(raddr, domain, tt, (laddr.sin4.sin_family == 0) ? NULL : &laddr, ((size_t) ::arg().asNum(\"xfr-max-received-mbytes\")) * 1024 * 1024);\n  Resolver::res_t recs;\n  bool first=true;\n  bool firstNSEC3{true};\n  bool soa_received {false};\n  while(retriever.getChunk(recs)) {\n    if(first) {\n      L<<Logger::Error<<\"AXFR started for '\"<<domain<<\"'\"<<endl;\n      first=false;\n    }\n\n    for(Resolver::res_t::iterator i=recs.begin();i!=recs.end();++i) {\n      if(i->qtype.getCode() == QType::OPT || i->qtype.getCode() == QType::TSIG) // ignore EDNS0 & TSIG\n        continue;\n\n      if(!i->qname.isPartOf(domain)) {\n        L<<Logger::Error<<\"Remote \"<<raddr.toStringWithPort()<<\" tried to sneak in out-of-zone data '\"<<i->qname<<\"'|\"<<i->qtype.getName()<<\" during AXFR of zone '\"<<domain<<\"', ignoring\"<<endl;\n        continue;\n      }\n\n      vector<DNSResourceRecord> out;\n      if(!pdl || !pdl->axfrfilter(raddr, domain, *i, out)) {\n        out.push_back(*i); // if axfrfilter didn't do anything, we put our record in 'out' ourselves\n      }\n\n      for(DNSResourceRecord& rr :  out) {\n        if(!processRecordForZS(domain, firstNSEC3, rr, zs))\n          continue;\n        if(rr.qtype.getCode() == QType::SOA) {\n          if(soa_received)\n            continue; //skip the last SOA\n          SOAData sd;\n          fillSOAData(rr.content,sd);\n          zs.soa_serial = sd.serial;\n          soa_received = true;\n        }\n\n        rrs.push_back(rr);\n\n      }\n    }\n  }\n  return rrs;\n}",
  "abstract_func": "vector<DNSResourceRecord> doAxfr(const ComboAddress& VAR_0, const DNSName& VAR_1, const TSIGTriplet& VAR_2, const ComboAddress& VAR_3,  scoped_ptr<AuthLua>& VAR_4, ZoneStatus& VAR_5)\n{\n  vector<DNSResourceRecord> VAR_6;\n  AXFRRetriever VAR_7(VAR_0, VAR_1, VAR_2, (VAR_3.sin4.sin_family == 0) ? NULL : &VAR_3, ((size_t) ::arg().asNum(\"xfr-max-received-mbytes\")) * 1024 * 1024);\n  Resolver::res_t VAR_8;\n  bool VAR_9=true;\n  bool VAR_10{true};\n  bool VAR_11 {false};\n  while(VAR_7.getChunk(VAR_8)) {\n    if(VAR_9) {\n      VAR_12<<Logger::Error<<\"AXFR started for '\"<<VAR_1<<\"'\"<<VAR_13;\n      VAR_9=false;\n    }\n\n    for(Resolver::res_t::iterator VAR_14=VAR_8.begin();VAR_14!=VAR_8.end();++VAR_14) {\n      if(VAR_14->qtype.getCode() == QType::OPT || VAR_14->qtype.getCode() == QType::TSIG) /* COMMENT_0 */\n        continue;\n\n      if(!VAR_14->qname.isPartOf(VAR_1)) {\n        VAR_12<<Logger::Error<<\"Remote \"<<VAR_0.toStringWithPort()<<\" tried to sneak in out-of-zone data '\"<<VAR_14->qname<<\"'|\"<<VAR_14->qtype.getName()<<\" during AXFR of zone '\"<<VAR_1<<\"', ignoring\"<<VAR_13;\n        continue;\n      }\n\n      vector<DNSResourceRecord> VAR_15;\n      if(!VAR_4 || !VAR_4->axfrfilter(VAR_0, VAR_1, *VAR_14, VAR_15)) {\n        VAR_15.push_back(*VAR_14); /* COMMENT_1 */\n      }\n\n      for(DNSResourceRecord& VAR_16 :  VAR_15) {\n        if(!processRecordForZS(VAR_1, VAR_10, VAR_16, VAR_5))\n          continue;\n        if(VAR_16.qtype.getCode() == QType::SOA) {\n          if(VAR_11)\n            continue; /* COMMENT_2 */\n          SOAData VAR_17;\n          fillSOAData(VAR_16.content,VAR_17);\n          VAR_5.soa_serial = VAR_17.serial;\n          VAR_11 = true;\n        }\n\n        VAR_6.push_back(VAR_16);\n\n      }\n    }\n  }\n  return VAR_6;\n}",
  "func_graph_path": "PowerDNS/pdns/db8f9152168acf5d548d4f256789eae783e01667/slavecommunicator.cc/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,7 @@\n vector<DNSResourceRecord> doAxfr(const ComboAddress& raddr, const DNSName& domain, const TSIGTriplet& tt, const ComboAddress& laddr,  scoped_ptr<AuthLua>& pdl, ZoneStatus& zs)\n {\n   vector<DNSResourceRecord> rrs;\n-  AXFRRetriever retriever(raddr, domain, tt, (laddr.sin4.sin_family == 0) ? NULL : &laddr);\n+  AXFRRetriever retriever(raddr, domain, tt, (laddr.sin4.sin_family == 0) ? NULL : &laddr, ((size_t) ::arg().asNum(\"xfr-max-received-mbytes\")) * 1024 * 1024);\n   Resolver::res_t recs;\n   bool first=true;\n   bool firstNSEC3{true};",
  "diff_line_info": {
    "deleted_lines": [
      "  AXFRRetriever retriever(raddr, domain, tt, (laddr.sin4.sin_family == 0) ? NULL : &laddr);"
    ],
    "added_lines": [
      "  AXFRRetriever retriever(raddr, domain, tt, (laddr.sin4.sin_family == 0) ? NULL : &laddr, ((size_t) ::arg().asNum(\"xfr-max-received-mbytes\")) * 1024 * 1024);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/PowerDNS/pdns/pull/4133",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/PowerDNS/pdns/pull/4133: 403 Client Error: Forbidden for url: https://api.github.com/repos/PowerDNS/pdns/pulls/4133",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95"
}