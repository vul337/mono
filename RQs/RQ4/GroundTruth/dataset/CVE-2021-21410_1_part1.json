{
  "cve_id": "CVE-2021-21410",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "contiki-ng",
  "commit_msg": "Avoid passing the packet to the upper layer if the IPHC decompression failed.",
  "commit_hash": "971354a39e46abfb3ea8f3fe542f53a7c6b17dd1",
  "git_url": "https://github.com/contiki-ng/contiki-ng/commit/971354a39e46abfb3ea8f3fe542f53a7c6b17dd1",
  "file_path": "os/net/ipv6/sicslowpan.c",
  "func_name": "uncompress_hdr_iphc",
  "func_before": "static void\nuncompress_hdr_iphc(uint8_t *buf, uint16_t buf_size, uint16_t ip_len)\n{\n  uint8_t tmp, iphc0, iphc1, nhc;\n  struct uip_ext_hdr *exthdr;\n  uint8_t* last_nextheader;\n  uint8_t* ip_payload;\n  uint8_t ext_hdr_len = 0;\n\n  /* at least two byte will be used for the encoding */\n  hc06_ptr = packetbuf_ptr + packetbuf_hdr_len + 2;\n\n  iphc0 = PACKETBUF_IPHC_BUF[0];\n  iphc1 = PACKETBUF_IPHC_BUF[1];\n\n  /* another if the CID flag is set */\n  if(iphc1 & SICSLOWPAN_IPHC_CID) {\n    LOG_DBG(\"uncompression: CID flag set - increase header with one\\n\");\n    hc06_ptr++;\n  }\n\n  /* Traffic class and flow label */\n    if((iphc0 & SICSLOWPAN_IPHC_FL_C) == 0) {\n      /* Flow label are carried inline */\n      if((iphc0 & SICSLOWPAN_IPHC_TC_C) == 0) {\n        /* Traffic class is carried inline */\n        memcpy(&SICSLOWPAN_IP_BUF(buf)->tcflow, hc06_ptr + 1, 3);\n        tmp = *hc06_ptr;\n        hc06_ptr += 4;\n        /* IPHC format of tc is ECN | DSCP , original is DSCP | ECN */\n        /* set version, pick highest DSCP bits and set in vtc */\n        SICSLOWPAN_IP_BUF(buf)->vtc = 0x60 | ((tmp >> 2) & 0x0f);\n        /* ECN rolled down two steps + lowest DSCP bits at top two bits */\n        SICSLOWPAN_IP_BUF(buf)->tcflow = ((tmp >> 2) & 0x30) | (tmp << 6) |\n          (SICSLOWPAN_IP_BUF(buf)->tcflow & 0x0f);\n      } else {\n        /* Traffic class is compressed (set version and no TC)*/\n        SICSLOWPAN_IP_BUF(buf)->vtc = 0x60;\n        /* highest flow label bits + ECN bits */\n        SICSLOWPAN_IP_BUF(buf)->tcflow = (*hc06_ptr & 0x0F) |\n          ((*hc06_ptr >> 2) & 0x30);\n        memcpy(&SICSLOWPAN_IP_BUF(buf)->flow, hc06_ptr + 1, 2);\n        hc06_ptr += 3;\n      }\n    } else {\n      /* Version is always 6! */\n      /* Version and flow label are compressed */\n      if((iphc0 & SICSLOWPAN_IPHC_TC_C) == 0) {\n        /* Traffic class is inline */\n        SICSLOWPAN_IP_BUF(buf)->vtc = 0x60 | ((*hc06_ptr >> 2) & 0x0f);\n          SICSLOWPAN_IP_BUF(buf)->tcflow = ((*hc06_ptr << 6) & 0xC0) | ((*hc06_ptr >> 2) & 0x30);\n          SICSLOWPAN_IP_BUF(buf)->flow = 0;\n          hc06_ptr += 1;\n      } else {\n        /* Traffic class is compressed */\n        SICSLOWPAN_IP_BUF(buf)->vtc = 0x60;\n        SICSLOWPAN_IP_BUF(buf)->tcflow = 0;\n        SICSLOWPAN_IP_BUF(buf)->flow = 0;\n      }\n    }\n\n  /* Next Header */\n  if((iphc0 & SICSLOWPAN_IPHC_NH_C) == 0) {\n    /* Next header is carried inline */\n    SICSLOWPAN_IP_BUF(buf)->proto = *hc06_ptr;\n    LOG_DBG(\"uncompression: next header inline: %d\\n\", SICSLOWPAN_IP_BUF(buf)->proto);\n    hc06_ptr += 1;\n  }\n\n  /* Hop limit */\n  if((iphc0 & 0x03) != SICSLOWPAN_IPHC_TTL_I) {\n    SICSLOWPAN_IP_BUF(buf)->ttl = ttl_values[iphc0 & 0x03];\n  } else {\n    SICSLOWPAN_IP_BUF(buf)->ttl = *hc06_ptr;\n    hc06_ptr += 1;\n  }\n\n  /* put the source address compression mode SAM in the tmp var */\n  tmp = ((iphc1 & SICSLOWPAN_IPHC_SAM_11) >> SICSLOWPAN_IPHC_SAM_BIT) & 0x03;\n\n  /* context based compression */\n  if(iphc1 & SICSLOWPAN_IPHC_SAC) {\n    uint8_t sci = (iphc1 & SICSLOWPAN_IPHC_CID) ?\n      PACKETBUF_IPHC_BUF[2] >> 4 : 0;\n\n    /* Source address - check context != NULL only if SAM bits are != 0*/\n    if (tmp != 0) {\n      context = addr_context_lookup_by_number(sci);\n      if(context == NULL) {\n        LOG_ERR(\"uncompression: error context not found\\n\");\n        return;\n      }\n    }\n    /* if tmp == 0 we do not have a context and therefore no prefix */\n    uncompress_addr(&SICSLOWPAN_IP_BUF(buf)->srcipaddr,\n                    tmp != 0 ? context->prefix : NULL, unc_ctxconf[tmp],\n                    (uip_lladdr_t *)packetbuf_addr(PACKETBUF_ADDR_SENDER));\n  } else {\n    /* no compression and link local */\n    uncompress_addr(&SICSLOWPAN_IP_BUF(buf)->srcipaddr, llprefix, unc_llconf[tmp],\n                    (uip_lladdr_t *)packetbuf_addr(PACKETBUF_ADDR_SENDER));\n  }\n\n  /* Destination address */\n  /* put the destination address compression mode into tmp */\n  tmp = ((iphc1 & SICSLOWPAN_IPHC_DAM_11) >> SICSLOWPAN_IPHC_DAM_BIT) & 0x03;\n\n  /* multicast compression */\n  if(iphc1 & SICSLOWPAN_IPHC_M) {\n    /* context based multicast compression */\n    if(iphc1 & SICSLOWPAN_IPHC_DAC) {\n      /* TODO: implement this */\n    } else {\n      /* non-context based multicast compression - */\n      /* DAM_00: 128 bits  */\n      /* DAM_01:  48 bits FFXX::00XX:XXXX:XXXX */\n      /* DAM_10:  32 bits FFXX::00XX:XXXX */\n      /* DAM_11:   8 bits FF02::00XX */\n      uint8_t prefix[] = {0xff, 0x02};\n      if(tmp > 0 && tmp < 3) {\n        prefix[1] = *hc06_ptr;\n        hc06_ptr++;\n      }\n\n      uncompress_addr(&SICSLOWPAN_IP_BUF(buf)->destipaddr, prefix,\n                      unc_mxconf[tmp], NULL);\n    }\n  } else {\n    /* no multicast */\n    /* Context based */\n    if(iphc1 & SICSLOWPAN_IPHC_DAC) {\n      uint8_t dci = (iphc1 & SICSLOWPAN_IPHC_CID) ? PACKETBUF_IPHC_BUF[2] & 0x0f : 0;\n      context = addr_context_lookup_by_number(dci);\n\n      /* all valid cases below need the context! */\n      if(context == NULL) {\n        LOG_ERR(\"uncompression: error context not found\\n\");\n        return;\n      }\n      uncompress_addr(&SICSLOWPAN_IP_BUF(buf)->destipaddr, context->prefix,\n                      unc_ctxconf[tmp],\n                      (uip_lladdr_t *)packetbuf_addr(PACKETBUF_ADDR_RECEIVER));\n    } else {\n      /* not context based => link local M = 0, DAC = 0 - same as SAC */\n      uncompress_addr(&SICSLOWPAN_IP_BUF(buf)->destipaddr, llprefix,\n                      unc_llconf[tmp],\n                      (uip_lladdr_t *)packetbuf_addr(PACKETBUF_ADDR_RECEIVER));\n    }\n  }\n  uncomp_hdr_len += UIP_IPH_LEN;\n\n  /* Next header processing - continued */\n  nhc = iphc0 & SICSLOWPAN_IPHC_NH_C;\n  /* The next header is compressed, NHC is following */\n  last_nextheader =  &SICSLOWPAN_IP_BUF(buf)->proto;\n  ip_payload = SICSLOWPAN_IPPAYLOAD_BUF(buf);\n\n  while(nhc && (*hc06_ptr & SICSLOWPAN_NHC_MASK) == SICSLOWPAN_NHC_EXT_HDR) {\n    uint8_t eid = (*hc06_ptr & 0x0e) >> 1;\n    /* next header compression flag */\n    uint8_t nh = (*hc06_ptr & 0x01);\n    uint8_t next = 0;\n    uint8_t len;\n    uint8_t proto;\n\n    nhc = nh;\n\n    hc06_ptr++;\n    if(!nh) {\n      next = *hc06_ptr;\n      hc06_ptr++;\n      LOG_DBG(\"uncompression: next header is inlined. Next: %d\\n\", next);\n    }\n    len = *hc06_ptr;\n    hc06_ptr++;\n\n    LOG_DBG(\"uncompression: found ext header id: %d next: %d len: %d\\n\", eid, next, len);\n    switch(eid) {\n    case SICSLOWPAN_NHC_ETX_HDR_HBHO:\n      proto = UIP_PROTO_HBHO;\n      break;\n    case SICSLOWPAN_NHC_ETX_HDR_ROUTING:\n      proto = UIP_PROTO_ROUTING;\n      break;\n    case SICSLOWPAN_NHC_ETX_HDR_FRAG:\n      proto = UIP_PROTO_FRAG;\n      break;\n    case SICSLOWPAN_NHC_ETX_HDR_DESTO:\n      proto = UIP_PROTO_DESTO;\n      break;\n    default:\n      LOG_DBG(\"uncompression: error unsupported ext header\\n\");\n      return;\n    }\n    *last_nextheader = proto;\n\n    /* Check that there is enough room to write the extension header. */\n    if((ip_payload - buf) + UIP_EXT_HDR_LEN + len > buf_size) {\n      LOG_WARN(\"uncompression: cannot write ext header beyond target buffer\\n\");\n      return;\n    }\n\n    /* uncompress the extension header */\n    exthdr = (struct uip_ext_hdr *)ip_payload;\n    exthdr->len = (UIP_EXT_HDR_LEN + len) / 8;\n    if(exthdr->len == 0) {\n      LOG_WARN(\"Extension header length is below 8\\n\");\n      return;\n    }\n    exthdr->len--;\n    exthdr->next = next;\n    last_nextheader = &exthdr->next;\n    memcpy((uint8_t *)exthdr + UIP_EXT_HDR_LEN, hc06_ptr, len);\n\n    hc06_ptr += len;\n    uncomp_hdr_len += (exthdr->len + 1) * 8;\n    ip_payload += (exthdr->len + 1) * 8;\n    ext_hdr_len += (exthdr->len + 1) * 8;\n\n    LOG_DBG(\"uncompression: %d len: %d exthdr len: %d (calc: %d)\\n\",\n            proto, len, exthdr->len, (exthdr->len + 1) * 8);\n  }\n\n  /* The next header is compressed, NHC is following */\n  if(nhc && (*hc06_ptr & SICSLOWPAN_NHC_UDP_MASK) == SICSLOWPAN_NHC_UDP_ID) {\n    struct uip_udp_hdr *udp_buf = (struct uip_udp_hdr *)ip_payload;\n    uint16_t udp_len;\n    uint8_t checksum_compressed;\n    *last_nextheader = UIP_PROTO_UDP;\n    checksum_compressed = *hc06_ptr & SICSLOWPAN_NHC_UDP_CHECKSUMC;\n    LOG_DBG(\"uncompression: incoming header value: %i\\n\", *hc06_ptr);\n    switch(*hc06_ptr & SICSLOWPAN_NHC_UDP_CS_P_11) {\n    case SICSLOWPAN_NHC_UDP_CS_P_00:\n      /* 1 byte for NHC, 4 byte for ports, 2 bytes chksum */\n      memcpy(&udp_buf->srcport, hc06_ptr + 1, 2);\n      memcpy(&udp_buf->destport, hc06_ptr + 3, 2);\n      LOG_DBG(\"uncompression: UDP ports (ptr+5): %x, %x\\n\",\n             UIP_HTONS(udp_buf->srcport),\n             UIP_HTONS(udp_buf->destport));\n      hc06_ptr += 5;\n      break;\n\n    case SICSLOWPAN_NHC_UDP_CS_P_01:\n      /* 1 byte for NHC + source 16bit inline, dest = 0xF0 + 8 bit inline */\n      LOG_DBG(\"uncompression: destination address\\n\");\n      memcpy(&udp_buf->srcport, hc06_ptr + 1, 2);\n      udp_buf->destport = UIP_HTONS(SICSLOWPAN_UDP_8_BIT_PORT_MIN + (*(hc06_ptr + 3)));\n      LOG_DBG(\"uncompression: UDP ports (ptr+4): %x, %x\\n\",\n             UIP_HTONS(udp_buf->srcport), UIP_HTONS(udp_buf->destport));\n      hc06_ptr += 4;\n      break;\n\n    case SICSLOWPAN_NHC_UDP_CS_P_10:\n      /* 1 byte for NHC + source = 0xF0 + 8bit inline, dest = 16 bit inline*/\n      LOG_DBG(\"uncompression: source address\\n\");\n      udp_buf->srcport = UIP_HTONS(SICSLOWPAN_UDP_8_BIT_PORT_MIN +\n                                   (*(hc06_ptr + 1)));\n      memcpy(&udp_buf->destport, hc06_ptr + 2, 2);\n      LOG_DBG(\"uncompression: UDP ports (ptr+4): %x, %x\\n\",\n             UIP_HTONS(udp_buf->srcport), UIP_HTONS(udp_buf->destport));\n      hc06_ptr += 4;\n      break;\n\n    case SICSLOWPAN_NHC_UDP_CS_P_11:\n      /* 1 byte for NHC, 1 byte for ports */\n      udp_buf->srcport = UIP_HTONS(SICSLOWPAN_UDP_4_BIT_PORT_MIN +\n                                   (*(hc06_ptr + 1) >> 4));\n      udp_buf->destport = UIP_HTONS(SICSLOWPAN_UDP_4_BIT_PORT_MIN +\n                                    ((*(hc06_ptr + 1)) & 0x0F));\n      LOG_DBG(\"uncompression: UDP ports (ptr+2): %x, %x\\n\",\n             UIP_HTONS(udp_buf->srcport), UIP_HTONS(udp_buf->destport));\n      hc06_ptr += 2;\n      break;\n    default:\n      LOG_DBG(\"uncompression: error unsupported UDP compression\\n\");\n      return;\n    }\n    if(!checksum_compressed) { /* has_checksum, default  */\n      memcpy(&udp_buf->udpchksum, hc06_ptr, 2);\n      hc06_ptr += 2;\n      LOG_DBG(\"uncompression: checksum included\\n\");\n    } else {\n      LOG_DBG(\"uncompression: checksum *NOT* included\\n\");\n    }\n\n    /* length field in UDP header (8 byte header + payload) */\n    udp_len = 8 + packetbuf_datalen() - (hc06_ptr - packetbuf_ptr);\n    udp_buf->udplen = UIP_HTONS(ip_len == 0 ? udp_len :\n                                ip_len - UIP_IPH_LEN - ext_hdr_len);\n    LOG_DBG(\"uncompression: UDP length: %u (ext: %u) ip_len: %d udp_len: %d\\n\",\n           UIP_HTONS(udp_buf->udplen), ext_hdr_len, ip_len, udp_len);\n\n    uncomp_hdr_len += UIP_UDPH_LEN;\n  }\n\n  packetbuf_hdr_len = hc06_ptr - packetbuf_ptr;\n\n  /* IP length field. */\n  if(ip_len == 0) {\n    int len = packetbuf_datalen() - packetbuf_hdr_len + uncomp_hdr_len - UIP_IPH_LEN;\n    LOG_DBG(\"uncompression: IP payload length: %d. %u - %u + %u - %u\\n\", len,\n           packetbuf_datalen(), packetbuf_hdr_len, uncomp_hdr_len, UIP_IPH_LEN);\n\n    /* This is not a fragmented packet */\n    SICSLOWPAN_IP_BUF(buf)->len[0] = len >> 8;\n    SICSLOWPAN_IP_BUF(buf)->len[1] = len & 0x00FF;\n  } else {\n    /* This is a 1st fragment */\n    SICSLOWPAN_IP_BUF(buf)->len[0] = (ip_len - UIP_IPH_LEN) >> 8;\n    SICSLOWPAN_IP_BUF(buf)->len[1] = (ip_len - UIP_IPH_LEN) & 0x00FF;\n  }\n}",
  "abstract_func_before": "static void\nuncompress_hdr_iphc(uint8_t *VAR_0, uint16_t VAR_1, uint16_t VAR_2)\n{\n  uint8_t VAR_3, VAR_4, VAR_5, VAR_6;\n  struct uip_ext_hdr *VAR_7;\n  uint8_t* VAR_8;\n  uint8_t* VAR_9;\n  uint8_t VAR_10 = 0;\n\n  /* COMMENT_0 */\n  VAR_11 = VAR_12 + VAR_13 + 2;\n\n  VAR_4 = VAR_14[0];\n  VAR_5 = VAR_14[1];\n\n  /* COMMENT_1 */\n  if(VAR_5 & VAR_15) {\n    LOG_DBG(\"uncompression: CID flag set - increase header with one\\n\");\n    VAR_11++;\n  }\n\n  /* COMMENT_2 */\n    if((VAR_4 & VAR_16) == 0) {\n      /* COMMENT_3 */\n      if((VAR_4 & VAR_17) == 0) {\n        /* COMMENT_4 */\n        memcpy(&SICSLOWPAN_IP_BUF(VAR_0)->tcflow, VAR_11 + 1, 3);\n        VAR_3 = *VAR_11;\n        VAR_11 += 4;\n        /* COMMENT_5 */\n        /* COMMENT_6 */\n        SICSLOWPAN_IP_BUF(VAR_0)->vtc = 0x60 | ((VAR_3 >> 2) & 0x0f);\n        /* COMMENT_7 */\n        SICSLOWPAN_IP_BUF(VAR_0)->tcflow = ((VAR_3 >> 2) & 0x30) | (VAR_3 << 6) |\n          (SICSLOWPAN_IP_BUF(VAR_0)->tcflow & 0x0f);\n      } else {\n        /* COMMENT_8 */\n        SICSLOWPAN_IP_BUF(VAR_0)->vtc = 0x60;\n        /* COMMENT_9 */\n        SICSLOWPAN_IP_BUF(VAR_0)->tcflow = (*VAR_11 & 0x0F) |\n          ((*VAR_11 >> 2) & 0x30);\n        memcpy(&SICSLOWPAN_IP_BUF(VAR_0)->flow, VAR_11 + 1, 2);\n        VAR_11 += 3;\n      }\n    } else {\n      /* COMMENT_10 */\n      /* COMMENT_11 */\n      if((VAR_4 & VAR_17) == 0) {\n        /* COMMENT_12 */\n        SICSLOWPAN_IP_BUF(VAR_0)->vtc = 0x60 | ((*VAR_11 >> 2) & 0x0f);\n          SICSLOWPAN_IP_BUF(VAR_0)->tcflow = ((*VAR_11 << 6) & 0xC0) | ((*VAR_11 >> 2) & 0x30);\n          SICSLOWPAN_IP_BUF(VAR_0)->flow = 0;\n          VAR_11 += 1;\n      } else {\n        /* COMMENT_13 */\n        SICSLOWPAN_IP_BUF(VAR_0)->vtc = 0x60;\n        SICSLOWPAN_IP_BUF(VAR_0)->tcflow = 0;\n        SICSLOWPAN_IP_BUF(VAR_0)->flow = 0;\n      }\n    }\n\n  /* COMMENT_14 */\n  if((VAR_4 & VAR_18) == 0) {\n    /* COMMENT_15 */\n    SICSLOWPAN_IP_BUF(VAR_0)->proto = *VAR_11;\n    LOG_DBG(\"uncompression: next header inline: %d\\n\", SICSLOWPAN_IP_BUF(VAR_0)->proto);\n    VAR_11 += 1;\n  }\n\n  /* COMMENT_16 */\n  if((VAR_4 & 0x03) != VAR_19) {\n    SICSLOWPAN_IP_BUF(VAR_0)->ttl = VAR_20[VAR_4 & 0x03];\n  } else {\n    SICSLOWPAN_IP_BUF(VAR_0)->ttl = *VAR_11;\n    VAR_11 += 1;\n  }\n\n  /* COMMENT_17 */\n  VAR_3 = ((VAR_5 & VAR_21) >> VAR_22) & 0x03;\n\n  /* COMMENT_18 */\n  if(VAR_5 & VAR_23) {\n    uint8_t VAR_24 = (VAR_5 & VAR_15) ?\n      VAR_14[2] >> 4 : 0;\n\n    /* COMMENT_19 */\n    if (VAR_3 != 0) {\n      VAR_25 = addr_context_lookup_by_number(VAR_24);\n      if(VAR_25 == NULL) {\n        LOG_ERR(\"uncompression: error context not found\\n\");\n        return;\n      }\n    }\n    /* COMMENT_20 */\n    uncompress_addr(&SICSLOWPAN_IP_BUF(VAR_0)->srcipaddr,\n                    VAR_3 != 0 ? VAR_25->prefix : NULL, VAR_26[VAR_3],\n                    (uip_lladdr_t *)packetbuf_addr(VAR_27));\n  } else {\n    /* COMMENT_21 */\n    uncompress_addr(&SICSLOWPAN_IP_BUF(VAR_0)->srcipaddr, VAR_28, VAR_29[VAR_3],\n                    (uip_lladdr_t *)packetbuf_addr(VAR_27));\n  }\n\n  /* COMMENT_22 */\n  /* COMMENT_23 */\n  VAR_3 = ((VAR_5 & VAR_30) >> VAR_31) & 0x03;\n\n  /* COMMENT_24 */\n  if(VAR_5 & VAR_32) {\n    /* COMMENT_25 */\n    if(VAR_5 & VAR_33) {\n      /* COMMENT_26 */\n    } else {\n      /* COMMENT_27 */\n      /* COMMENT_28 */\n      /* COMMENT_29 */\n      /* COMMENT_30 */\n      /* COMMENT_31 */\n      uint8_t VAR_34[] = {0xff, 0x02};\n      if(VAR_3 > 0 && VAR_3 < 3) {\n        VAR_34[1] = *VAR_11;\n        VAR_11++;\n      }\n\n      uncompress_addr(&SICSLOWPAN_IP_BUF(VAR_0)->destipaddr, VAR_34,\n                      VAR_35[VAR_3], NULL);\n    }\n  } else {\n    /* COMMENT_32 */\n    /* COMMENT_33 */\n    if(VAR_5 & VAR_33) {\n      uint8_t VAR_36 = (VAR_5 & VAR_15) ? VAR_14[2] & 0x0f : 0;\n      VAR_25 = addr_context_lookup_by_number(VAR_36);\n\n      /* COMMENT_34 */\n      if(VAR_25 == NULL) {\n        LOG_ERR(\"uncompression: error context not found\\n\");\n        return;\n      }\n      uncompress_addr(&SICSLOWPAN_IP_BUF(VAR_0)->destipaddr, VAR_25->prefix,\n                      VAR_26[VAR_3],\n                      (uip_lladdr_t *)packetbuf_addr(VAR_37));\n    } else {\n      /* COMMENT_35 */\n      uncompress_addr(&SICSLOWPAN_IP_BUF(VAR_0)->destipaddr, VAR_28,\n                      VAR_29[VAR_3],\n                      (uip_lladdr_t *)packetbuf_addr(VAR_37));\n    }\n  }\n  VAR_38 += VAR_39;\n\n  /* COMMENT_36 */\n  VAR_6 = VAR_4 & VAR_18;\n  /* COMMENT_37 */\n  VAR_8 =  &SICSLOWPAN_IP_BUF(VAR_0)->proto;\n  VAR_9 = SICSLOWPAN_IPPAYLOAD_BUF(VAR_0);\n\n  while(VAR_6 && (*VAR_11 & VAR_40) == VAR_41) {\n    uint8_t VAR_42 = (*VAR_11 & 0x0e) >> 1;\n    /* COMMENT_38 */\n    uint8_t VAR_43 = (*VAR_11 & 0x01);\n    uint8_t VAR_44 = 0;\n    uint8_t VAR_45;\n    uint8_t VAR_46;\n\n    VAR_6 = VAR_43;\n\n    VAR_11++;\n    if(!VAR_43) {\n      VAR_44 = *VAR_11;\n      VAR_11++;\n      LOG_DBG(\"uncompression: next header is inlined. Next: %d\\n\", VAR_44);\n    }\n    VAR_45 = *VAR_11;\n    VAR_11++;\n\n    LOG_DBG(\"uncompression: found ext header id: %d next: %d len: %d\\n\", VAR_42, VAR_44, VAR_45);\n    switch(VAR_42) {\n    case VAR_47:\n      VAR_46 = VAR_48;\n      break;\n    case VAR_49:\n      VAR_46 = VAR_50;\n      break;\n    case VAR_51:\n      VAR_46 = VAR_52;\n      break;\n    case VAR_53:\n      VAR_46 = VAR_54;\n      break;\n    default:\n      LOG_DBG(\"uncompression: error unsupported ext header\\n\");\n      return;\n    }\n    *VAR_8 = VAR_46;\n\n    /* COMMENT_39 */\n    if((VAR_9 - VAR_0) + VAR_55 + VAR_45 > VAR_1) {\n      LOG_WARN(\"uncompression: cannot write ext header beyond target buffer\\n\");\n      return;\n    }\n\n    /* COMMENT_40 */\n    VAR_7 = (struct uip_ext_hdr *)VAR_9;\n    VAR_7->len = (VAR_55 + VAR_45) / 8;\n    if(VAR_7->len == 0) {\n      LOG_WARN(\"Extension header length is below 8\\n\");\n      return;\n    }\n    VAR_7->len--;\n    VAR_7->next = VAR_44;\n    VAR_8 = &VAR_7->next;\n    memcpy((uint8_t *)VAR_7 + VAR_55, VAR_11, VAR_45);\n\n    VAR_11 += VAR_45;\n    VAR_38 += (VAR_7->len + 1) * 8;\n    VAR_9 += (VAR_7->len + 1) * 8;\n    VAR_10 += (VAR_7->len + 1) * 8;\n\n    LOG_DBG(\"uncompression: %d len: %d exthdr len: %d (calc: %d)\\n\",\n            VAR_46, VAR_45, VAR_7->len, (VAR_7->len + 1) * 8);\n  }\n\n  /* COMMENT_37 */\n  if(VAR_6 && (*VAR_11 & VAR_56) == VAR_57) {\n    struct uip_udp_hdr *VAR_58 = (struct uip_udp_hdr *)VAR_9;\n    uint16_t VAR_59;\n    uint8_t VAR_60;\n    *VAR_8 = VAR_61;\n    VAR_60 = *VAR_11 & VAR_62;\n    LOG_DBG(\"uncompression: incoming header value: %i\\n\", *VAR_11);\n    switch(*VAR_11 & VAR_63) {\n    case VAR_64:\n      /* COMMENT_41 */\n      memcpy(&VAR_58->srcport, VAR_11 + 1, 2);\n      memcpy(&VAR_58->destport, VAR_11 + 3, 2);\n      LOG_DBG(\"uncompression: UDP ports (ptr+5): %x, %x\\n\",\n             UIP_HTONS(VAR_58->srcport),\n             UIP_HTONS(VAR_58->destport));\n      VAR_11 += 5;\n      break;\n\n    case VAR_65:\n      /* COMMENT_42 */\n      LOG_DBG(\"uncompression: destination address\\n\");\n      memcpy(&VAR_58->srcport, VAR_11 + 1, 2);\n      VAR_58->destport = UIP_HTONS(VAR_66 + (*(VAR_11 + 3)));\n      LOG_DBG(\"uncompression: UDP ports (ptr+4): %x, %x\\n\",\n             UIP_HTONS(VAR_58->srcport), UIP_HTONS(VAR_58->destport));\n      VAR_11 += 4;\n      break;\n\n    case VAR_67:\n      /* COMMENT_43 */\n      LOG_DBG(\"uncompression: source address\\n\");\n      VAR_58->srcport = UIP_HTONS(VAR_66 +\n                                   (*(VAR_11 + 1)));\n      memcpy(&VAR_58->destport, VAR_11 + 2, 2);\n      LOG_DBG(\"uncompression: UDP ports (ptr+4): %x, %x\\n\",\n             UIP_HTONS(VAR_58->srcport), UIP_HTONS(VAR_58->destport));\n      VAR_11 += 4;\n      break;\n\n    case VAR_63:\n      /* COMMENT_44 */\n      VAR_58->srcport = UIP_HTONS(VAR_68 +\n                                   (*(VAR_11 + 1) >> 4));\n      VAR_58->destport = UIP_HTONS(VAR_68 +\n                                    ((*(VAR_11 + 1)) & 0x0F));\n      LOG_DBG(\"uncompression: UDP ports (ptr+2): %x, %x\\n\",\n             UIP_HTONS(VAR_58->srcport), UIP_HTONS(VAR_58->destport));\n      VAR_11 += 2;\n      break;\n    default:\n      LOG_DBG(\"uncompression: error unsupported UDP compression\\n\");\n      return;\n    }\n    if(!VAR_60) { /* COMMENT_45 */\n      memcpy(&VAR_58->udpchksum, VAR_11, 2);\n      VAR_11 += 2;\n      LOG_DBG(\"uncompression: checksum included\\n\");\n    } else {\n      LOG_DBG(\"uncompression: checksum *NOT* included\\n\");\n    }\n\n    /* COMMENT_46 */\n    VAR_59 = 8 + packetbuf_datalen() - (VAR_11 - VAR_12);\n    VAR_58->udplen = UIP_HTONS(VAR_2 == 0 ? VAR_59 :\n                                VAR_2 - VAR_39 - VAR_10);\n    LOG_DBG(\"uncompression: UDP length: %u (ext: %u) ip_len: %d udp_len: %d\\n\",\n           UIP_HTONS(VAR_58->udplen), VAR_10, VAR_2, VAR_59);\n\n    VAR_38 += VAR_69;\n  }\n\n  VAR_13 = VAR_11 - VAR_12;\n\n  /* COMMENT_47 */\n  if(VAR_2 == 0) {\n    int VAR_45 = packetbuf_datalen() - VAR_13 + VAR_38 - VAR_39;\n    LOG_DBG(\"uncompression: IP payload length: %d. %u - %u + %u - %u\\n\", VAR_45,\n           packetbuf_datalen(), VAR_13, VAR_38, VAR_39);\n\n    /* COMMENT_48 */\n    SICSLOWPAN_IP_BUF(VAR_0)->len[0] = VAR_45 >> 8;\n    SICSLOWPAN_IP_BUF(VAR_0)->len[1] = VAR_45 & 0x00FF;\n  } else {\n    /* COMMENT_49 */\n    SICSLOWPAN_IP_BUF(VAR_0)->len[0] = (VAR_2 - VAR_39) >> 8;\n    SICSLOWPAN_IP_BUF(VAR_0)->len[1] = (VAR_2 - VAR_39) & 0x00FF;\n  }\n}",
  "func_graph_path_before": "contiki-ng/971354a39e46abfb3ea8f3fe542f53a7c6b17dd1/sicslowpan.c/vul/before/1.json",
  "func": "static bool\nuncompress_hdr_iphc(uint8_t *buf, uint16_t buf_size, uint16_t ip_len)\n{\n  uint8_t tmp, iphc0, iphc1, nhc;\n  struct uip_ext_hdr *exthdr;\n  uint8_t* last_nextheader;\n  uint8_t* ip_payload;\n  uint8_t ext_hdr_len = 0;\n\n  /* at least two byte will be used for the encoding */\n  hc06_ptr = packetbuf_ptr + packetbuf_hdr_len + 2;\n\n  iphc0 = PACKETBUF_IPHC_BUF[0];\n  iphc1 = PACKETBUF_IPHC_BUF[1];\n\n  /* another if the CID flag is set */\n  if(iphc1 & SICSLOWPAN_IPHC_CID) {\n    LOG_DBG(\"uncompression: CID flag set - increase header with one\\n\");\n    hc06_ptr++;\n  }\n\n  /* Traffic class and flow label */\n    if((iphc0 & SICSLOWPAN_IPHC_FL_C) == 0) {\n      /* Flow label are carried inline */\n      if((iphc0 & SICSLOWPAN_IPHC_TC_C) == 0) {\n        /* Traffic class is carried inline */\n        memcpy(&SICSLOWPAN_IP_BUF(buf)->tcflow, hc06_ptr + 1, 3);\n        tmp = *hc06_ptr;\n        hc06_ptr += 4;\n        /* IPHC format of tc is ECN | DSCP , original is DSCP | ECN */\n        /* set version, pick highest DSCP bits and set in vtc */\n        SICSLOWPAN_IP_BUF(buf)->vtc = 0x60 | ((tmp >> 2) & 0x0f);\n        /* ECN rolled down two steps + lowest DSCP bits at top two bits */\n        SICSLOWPAN_IP_BUF(buf)->tcflow = ((tmp >> 2) & 0x30) | (tmp << 6) |\n          (SICSLOWPAN_IP_BUF(buf)->tcflow & 0x0f);\n      } else {\n        /* Traffic class is compressed (set version and no TC)*/\n        SICSLOWPAN_IP_BUF(buf)->vtc = 0x60;\n        /* highest flow label bits + ECN bits */\n        SICSLOWPAN_IP_BUF(buf)->tcflow = (*hc06_ptr & 0x0F) |\n          ((*hc06_ptr >> 2) & 0x30);\n        memcpy(&SICSLOWPAN_IP_BUF(buf)->flow, hc06_ptr + 1, 2);\n        hc06_ptr += 3;\n      }\n    } else {\n      /* Version is always 6! */\n      /* Version and flow label are compressed */\n      if((iphc0 & SICSLOWPAN_IPHC_TC_C) == 0) {\n        /* Traffic class is inline */\n        SICSLOWPAN_IP_BUF(buf)->vtc = 0x60 | ((*hc06_ptr >> 2) & 0x0f);\n          SICSLOWPAN_IP_BUF(buf)->tcflow = ((*hc06_ptr << 6) & 0xC0) | ((*hc06_ptr >> 2) & 0x30);\n          SICSLOWPAN_IP_BUF(buf)->flow = 0;\n          hc06_ptr += 1;\n      } else {\n        /* Traffic class is compressed */\n        SICSLOWPAN_IP_BUF(buf)->vtc = 0x60;\n        SICSLOWPAN_IP_BUF(buf)->tcflow = 0;\n        SICSLOWPAN_IP_BUF(buf)->flow = 0;\n      }\n    }\n\n  /* Next Header */\n  if((iphc0 & SICSLOWPAN_IPHC_NH_C) == 0) {\n    /* Next header is carried inline */\n    SICSLOWPAN_IP_BUF(buf)->proto = *hc06_ptr;\n    LOG_DBG(\"uncompression: next header inline: %d\\n\", SICSLOWPAN_IP_BUF(buf)->proto);\n    hc06_ptr += 1;\n  }\n\n  /* Hop limit */\n  if((iphc0 & 0x03) != SICSLOWPAN_IPHC_TTL_I) {\n    SICSLOWPAN_IP_BUF(buf)->ttl = ttl_values[iphc0 & 0x03];\n  } else {\n    SICSLOWPAN_IP_BUF(buf)->ttl = *hc06_ptr;\n    hc06_ptr += 1;\n  }\n\n  /* put the source address compression mode SAM in the tmp var */\n  tmp = ((iphc1 & SICSLOWPAN_IPHC_SAM_11) >> SICSLOWPAN_IPHC_SAM_BIT) & 0x03;\n\n  /* context based compression */\n  if(iphc1 & SICSLOWPAN_IPHC_SAC) {\n    uint8_t sci = (iphc1 & SICSLOWPAN_IPHC_CID) ?\n      PACKETBUF_IPHC_BUF[2] >> 4 : 0;\n\n    /* Source address - check context != NULL only if SAM bits are != 0*/\n    if (tmp != 0) {\n      context = addr_context_lookup_by_number(sci);\n      if(context == NULL) {\n        LOG_ERR(\"uncompression: error context not found\\n\");\n        return false;\n      }\n    }\n    /* if tmp == 0 we do not have a context and therefore no prefix */\n    uncompress_addr(&SICSLOWPAN_IP_BUF(buf)->srcipaddr,\n                    tmp != 0 ? context->prefix : NULL, unc_ctxconf[tmp],\n                    (uip_lladdr_t *)packetbuf_addr(PACKETBUF_ADDR_SENDER));\n  } else {\n    /* no compression and link local */\n    uncompress_addr(&SICSLOWPAN_IP_BUF(buf)->srcipaddr, llprefix, unc_llconf[tmp],\n                    (uip_lladdr_t *)packetbuf_addr(PACKETBUF_ADDR_SENDER));\n  }\n\n  /* Destination address */\n  /* put the destination address compression mode into tmp */\n  tmp = ((iphc1 & SICSLOWPAN_IPHC_DAM_11) >> SICSLOWPAN_IPHC_DAM_BIT) & 0x03;\n\n  /* multicast compression */\n  if(iphc1 & SICSLOWPAN_IPHC_M) {\n    /* context based multicast compression */\n    if(iphc1 & SICSLOWPAN_IPHC_DAC) {\n      /* TODO: implement this */\n    } else {\n      /* non-context based multicast compression - */\n      /* DAM_00: 128 bits  */\n      /* DAM_01:  48 bits FFXX::00XX:XXXX:XXXX */\n      /* DAM_10:  32 bits FFXX::00XX:XXXX */\n      /* DAM_11:   8 bits FF02::00XX */\n      uint8_t prefix[] = {0xff, 0x02};\n      if(tmp > 0 && tmp < 3) {\n        prefix[1] = *hc06_ptr;\n        hc06_ptr++;\n      }\n\n      uncompress_addr(&SICSLOWPAN_IP_BUF(buf)->destipaddr, prefix,\n                      unc_mxconf[tmp], NULL);\n    }\n  } else {\n    /* no multicast */\n    /* Context based */\n    if(iphc1 & SICSLOWPAN_IPHC_DAC) {\n      uint8_t dci = (iphc1 & SICSLOWPAN_IPHC_CID) ? PACKETBUF_IPHC_BUF[2] & 0x0f : 0;\n      context = addr_context_lookup_by_number(dci);\n\n      /* all valid cases below need the context! */\n      if(context == NULL) {\n        LOG_ERR(\"uncompression: error context not found\\n\");\n        return false;\n      }\n      uncompress_addr(&SICSLOWPAN_IP_BUF(buf)->destipaddr, context->prefix,\n                      unc_ctxconf[tmp],\n                      (uip_lladdr_t *)packetbuf_addr(PACKETBUF_ADDR_RECEIVER));\n    } else {\n      /* not context based => link local M = 0, DAC = 0 - same as SAC */\n      uncompress_addr(&SICSLOWPAN_IP_BUF(buf)->destipaddr, llprefix,\n                      unc_llconf[tmp],\n                      (uip_lladdr_t *)packetbuf_addr(PACKETBUF_ADDR_RECEIVER));\n    }\n  }\n  uncomp_hdr_len += UIP_IPH_LEN;\n\n  /* Next header processing - continued */\n  nhc = iphc0 & SICSLOWPAN_IPHC_NH_C;\n  /* The next header is compressed, NHC is following */\n  last_nextheader =  &SICSLOWPAN_IP_BUF(buf)->proto;\n  ip_payload = SICSLOWPAN_IPPAYLOAD_BUF(buf);\n\n  while(nhc && (*hc06_ptr & SICSLOWPAN_NHC_MASK) == SICSLOWPAN_NHC_EXT_HDR) {\n    uint8_t eid = (*hc06_ptr & 0x0e) >> 1;\n    /* next header compression flag */\n    uint8_t nh = (*hc06_ptr & 0x01);\n    uint8_t next = 0;\n    uint8_t len;\n    uint8_t proto;\n\n    nhc = nh;\n\n    hc06_ptr++;\n    if(!nh) {\n      next = *hc06_ptr;\n      hc06_ptr++;\n      LOG_DBG(\"uncompression: next header is inlined. Next: %d\\n\", next);\n    }\n    len = *hc06_ptr;\n    hc06_ptr++;\n\n    LOG_DBG(\"uncompression: found ext header id: %d next: %d len: %d\\n\", eid, next, len);\n    switch(eid) {\n    case SICSLOWPAN_NHC_ETX_HDR_HBHO:\n      proto = UIP_PROTO_HBHO;\n      break;\n    case SICSLOWPAN_NHC_ETX_HDR_ROUTING:\n      proto = UIP_PROTO_ROUTING;\n      break;\n    case SICSLOWPAN_NHC_ETX_HDR_FRAG:\n      proto = UIP_PROTO_FRAG;\n      break;\n    case SICSLOWPAN_NHC_ETX_HDR_DESTO:\n      proto = UIP_PROTO_DESTO;\n      break;\n    default:\n      LOG_DBG(\"uncompression: error unsupported ext header\\n\");\n      return false;\n    }\n    *last_nextheader = proto;\n\n    /* Check that there is enough room to write the extension header. */\n    if((ip_payload - buf) + UIP_EXT_HDR_LEN + len > buf_size) {\n      LOG_WARN(\"uncompression: cannot write ext header beyond target buffer\\n\");\n      return false;\n    }\n\n    /* uncompress the extension header */\n    exthdr = (struct uip_ext_hdr *)ip_payload;\n    exthdr->len = (UIP_EXT_HDR_LEN + len) / 8;\n    if(exthdr->len == 0) {\n      LOG_WARN(\"Extension header length is below 8\\n\");\n      return false;\n    }\n    exthdr->len--;\n    exthdr->next = next;\n    last_nextheader = &exthdr->next;\n    memcpy((uint8_t *)exthdr + UIP_EXT_HDR_LEN, hc06_ptr, len);\n\n    hc06_ptr += len;\n    uncomp_hdr_len += (exthdr->len + 1) * 8;\n    ip_payload += (exthdr->len + 1) * 8;\n    ext_hdr_len += (exthdr->len + 1) * 8;\n\n    LOG_DBG(\"uncompression: %d len: %d exthdr len: %d (calc: %d)\\n\",\n            proto, len, exthdr->len, (exthdr->len + 1) * 8);\n  }\n\n  /* The next header is compressed, NHC is following */\n  if(nhc && (*hc06_ptr & SICSLOWPAN_NHC_UDP_MASK) == SICSLOWPAN_NHC_UDP_ID) {\n    struct uip_udp_hdr *udp_buf = (struct uip_udp_hdr *)ip_payload;\n    uint16_t udp_len;\n    uint8_t checksum_compressed;\n    *last_nextheader = UIP_PROTO_UDP;\n    checksum_compressed = *hc06_ptr & SICSLOWPAN_NHC_UDP_CHECKSUMC;\n    LOG_DBG(\"uncompression: incoming header value: %i\\n\", *hc06_ptr);\n    switch(*hc06_ptr & SICSLOWPAN_NHC_UDP_CS_P_11) {\n    case SICSLOWPAN_NHC_UDP_CS_P_00:\n      /* 1 byte for NHC, 4 byte for ports, 2 bytes chksum */\n      memcpy(&udp_buf->srcport, hc06_ptr + 1, 2);\n      memcpy(&udp_buf->destport, hc06_ptr + 3, 2);\n      LOG_DBG(\"uncompression: UDP ports (ptr+5): %x, %x\\n\",\n             UIP_HTONS(udp_buf->srcport),\n             UIP_HTONS(udp_buf->destport));\n      hc06_ptr += 5;\n      break;\n\n    case SICSLOWPAN_NHC_UDP_CS_P_01:\n      /* 1 byte for NHC + source 16bit inline, dest = 0xF0 + 8 bit inline */\n      LOG_DBG(\"uncompression: destination address\\n\");\n      memcpy(&udp_buf->srcport, hc06_ptr + 1, 2);\n      udp_buf->destport = UIP_HTONS(SICSLOWPAN_UDP_8_BIT_PORT_MIN + (*(hc06_ptr + 3)));\n      LOG_DBG(\"uncompression: UDP ports (ptr+4): %x, %x\\n\",\n             UIP_HTONS(udp_buf->srcport), UIP_HTONS(udp_buf->destport));\n      hc06_ptr += 4;\n      break;\n\n    case SICSLOWPAN_NHC_UDP_CS_P_10:\n      /* 1 byte for NHC + source = 0xF0 + 8bit inline, dest = 16 bit inline*/\n      LOG_DBG(\"uncompression: source address\\n\");\n      udp_buf->srcport = UIP_HTONS(SICSLOWPAN_UDP_8_BIT_PORT_MIN +\n                                   (*(hc06_ptr + 1)));\n      memcpy(&udp_buf->destport, hc06_ptr + 2, 2);\n      LOG_DBG(\"uncompression: UDP ports (ptr+4): %x, %x\\n\",\n             UIP_HTONS(udp_buf->srcport), UIP_HTONS(udp_buf->destport));\n      hc06_ptr += 4;\n      break;\n\n    case SICSLOWPAN_NHC_UDP_CS_P_11:\n      /* 1 byte for NHC, 1 byte for ports */\n      udp_buf->srcport = UIP_HTONS(SICSLOWPAN_UDP_4_BIT_PORT_MIN +\n                                   (*(hc06_ptr + 1) >> 4));\n      udp_buf->destport = UIP_HTONS(SICSLOWPAN_UDP_4_BIT_PORT_MIN +\n                                    ((*(hc06_ptr + 1)) & 0x0F));\n      LOG_DBG(\"uncompression: UDP ports (ptr+2): %x, %x\\n\",\n             UIP_HTONS(udp_buf->srcport), UIP_HTONS(udp_buf->destport));\n      hc06_ptr += 2;\n      break;\n    default:\n      LOG_DBG(\"uncompression: error unsupported UDP compression\\n\");\n      return false;\n    }\n    if(!checksum_compressed) { /* has_checksum, default  */\n      memcpy(&udp_buf->udpchksum, hc06_ptr, 2);\n      hc06_ptr += 2;\n      LOG_DBG(\"uncompression: checksum included\\n\");\n    } else {\n      LOG_DBG(\"uncompression: checksum *NOT* included\\n\");\n    }\n\n    /* length field in UDP header (8 byte header + payload) */\n    udp_len = 8 + packetbuf_datalen() - (hc06_ptr - packetbuf_ptr);\n    udp_buf->udplen = UIP_HTONS(ip_len == 0 ? udp_len :\n                                ip_len - UIP_IPH_LEN - ext_hdr_len);\n    LOG_DBG(\"uncompression: UDP length: %u (ext: %u) ip_len: %d udp_len: %d\\n\",\n           UIP_HTONS(udp_buf->udplen), ext_hdr_len, ip_len, udp_len);\n\n    uncomp_hdr_len += UIP_UDPH_LEN;\n  }\n\n  packetbuf_hdr_len = hc06_ptr - packetbuf_ptr;\n\n  /* IP length field. */\n  if(ip_len == 0) {\n    int len = packetbuf_datalen() - packetbuf_hdr_len + uncomp_hdr_len - UIP_IPH_LEN;\n    LOG_DBG(\"uncompression: IP payload length: %d. %u - %u + %u - %u\\n\", len,\n           packetbuf_datalen(), packetbuf_hdr_len, uncomp_hdr_len, UIP_IPH_LEN);\n\n    /* This is not a fragmented packet */\n    SICSLOWPAN_IP_BUF(buf)->len[0] = len >> 8;\n    SICSLOWPAN_IP_BUF(buf)->len[1] = len & 0x00FF;\n  } else {\n    /* This is a 1st fragment */\n    SICSLOWPAN_IP_BUF(buf)->len[0] = (ip_len - UIP_IPH_LEN) >> 8;\n    SICSLOWPAN_IP_BUF(buf)->len[1] = (ip_len - UIP_IPH_LEN) & 0x00FF;\n  }\n\n  return true;\n}",
  "abstract_func": "static bool\nuncompress_hdr_iphc(uint8_t *VAR_0, uint16_t VAR_1, uint16_t VAR_2)\n{\n  uint8_t VAR_3, VAR_4, VAR_5, VAR_6;\n  struct uip_ext_hdr *VAR_7;\n  uint8_t* VAR_8;\n  uint8_t* VAR_9;\n  uint8_t VAR_10 = 0;\n\n  /* COMMENT_0 */\n  VAR_11 = VAR_12 + VAR_13 + 2;\n\n  VAR_4 = VAR_14[0];\n  VAR_5 = VAR_14[1];\n\n  /* COMMENT_1 */\n  if(VAR_5 & VAR_15) {\n    LOG_DBG(\"uncompression: CID flag set - increase header with one\\n\");\n    VAR_11++;\n  }\n\n  /* COMMENT_2 */\n    if((VAR_4 & VAR_16) == 0) {\n      /* COMMENT_3 */\n      if((VAR_4 & VAR_17) == 0) {\n        /* COMMENT_4 */\n        memcpy(&SICSLOWPAN_IP_BUF(VAR_0)->tcflow, VAR_11 + 1, 3);\n        VAR_3 = *VAR_11;\n        VAR_11 += 4;\n        /* COMMENT_5 */\n        /* COMMENT_6 */\n        SICSLOWPAN_IP_BUF(VAR_0)->vtc = 0x60 | ((VAR_3 >> 2) & 0x0f);\n        /* COMMENT_7 */\n        SICSLOWPAN_IP_BUF(VAR_0)->tcflow = ((VAR_3 >> 2) & 0x30) | (VAR_3 << 6) |\n          (SICSLOWPAN_IP_BUF(VAR_0)->tcflow & 0x0f);\n      } else {\n        /* COMMENT_8 */\n        SICSLOWPAN_IP_BUF(VAR_0)->vtc = 0x60;\n        /* COMMENT_9 */\n        SICSLOWPAN_IP_BUF(VAR_0)->tcflow = (*VAR_11 & 0x0F) |\n          ((*VAR_11 >> 2) & 0x30);\n        memcpy(&SICSLOWPAN_IP_BUF(VAR_0)->flow, VAR_11 + 1, 2);\n        VAR_11 += 3;\n      }\n    } else {\n      /* COMMENT_10 */\n      /* COMMENT_11 */\n      if((VAR_4 & VAR_17) == 0) {\n        /* COMMENT_12 */\n        SICSLOWPAN_IP_BUF(VAR_0)->vtc = 0x60 | ((*VAR_11 >> 2) & 0x0f);\n          SICSLOWPAN_IP_BUF(VAR_0)->tcflow = ((*VAR_11 << 6) & 0xC0) | ((*VAR_11 >> 2) & 0x30);\n          SICSLOWPAN_IP_BUF(VAR_0)->flow = 0;\n          VAR_11 += 1;\n      } else {\n        /* COMMENT_13 */\n        SICSLOWPAN_IP_BUF(VAR_0)->vtc = 0x60;\n        SICSLOWPAN_IP_BUF(VAR_0)->tcflow = 0;\n        SICSLOWPAN_IP_BUF(VAR_0)->flow = 0;\n      }\n    }\n\n  /* COMMENT_14 */\n  if((VAR_4 & VAR_18) == 0) {\n    /* COMMENT_15 */\n    SICSLOWPAN_IP_BUF(VAR_0)->proto = *VAR_11;\n    LOG_DBG(\"uncompression: next header inline: %d\\n\", SICSLOWPAN_IP_BUF(VAR_0)->proto);\n    VAR_11 += 1;\n  }\n\n  /* COMMENT_16 */\n  if((VAR_4 & 0x03) != VAR_19) {\n    SICSLOWPAN_IP_BUF(VAR_0)->ttl = VAR_20[VAR_4 & 0x03];\n  } else {\n    SICSLOWPAN_IP_BUF(VAR_0)->ttl = *VAR_11;\n    VAR_11 += 1;\n  }\n\n  /* COMMENT_17 */\n  VAR_3 = ((VAR_5 & VAR_21) >> VAR_22) & 0x03;\n\n  /* COMMENT_18 */\n  if(VAR_5 & VAR_23) {\n    uint8_t VAR_24 = (VAR_5 & VAR_15) ?\n      VAR_14[2] >> 4 : 0;\n\n    /* COMMENT_19 */\n    if (VAR_3 != 0) {\n      VAR_25 = addr_context_lookup_by_number(VAR_24);\n      if(VAR_25 == NULL) {\n        LOG_ERR(\"uncompression: error context not found\\n\");\n        return false;\n      }\n    }\n    /* COMMENT_20 */\n    uncompress_addr(&SICSLOWPAN_IP_BUF(VAR_0)->srcipaddr,\n                    VAR_3 != 0 ? VAR_25->prefix : NULL, VAR_26[VAR_3],\n                    (uip_lladdr_t *)packetbuf_addr(VAR_27));\n  } else {\n    /* COMMENT_21 */\n    uncompress_addr(&SICSLOWPAN_IP_BUF(VAR_0)->srcipaddr, VAR_28, VAR_29[VAR_3],\n                    (uip_lladdr_t *)packetbuf_addr(VAR_27));\n  }\n\n  /* COMMENT_22 */\n  /* COMMENT_23 */\n  VAR_3 = ((VAR_5 & VAR_30) >> VAR_31) & 0x03;\n\n  /* COMMENT_24 */\n  if(VAR_5 & VAR_32) {\n    /* COMMENT_25 */\n    if(VAR_5 & VAR_33) {\n      /* COMMENT_26 */\n    } else {\n      /* COMMENT_27 */\n      /* COMMENT_28 */\n      /* COMMENT_29 */\n      /* COMMENT_30 */\n      /* COMMENT_31 */\n      uint8_t VAR_34[] = {0xff, 0x02};\n      if(VAR_3 > 0 && VAR_3 < 3) {\n        VAR_34[1] = *VAR_11;\n        VAR_11++;\n      }\n\n      uncompress_addr(&SICSLOWPAN_IP_BUF(VAR_0)->destipaddr, VAR_34,\n                      VAR_35[VAR_3], NULL);\n    }\n  } else {\n    /* COMMENT_32 */\n    /* COMMENT_33 */\n    if(VAR_5 & VAR_33) {\n      uint8_t VAR_36 = (VAR_5 & VAR_15) ? VAR_14[2] & 0x0f : 0;\n      VAR_25 = addr_context_lookup_by_number(VAR_36);\n\n      /* COMMENT_34 */\n      if(VAR_25 == NULL) {\n        LOG_ERR(\"uncompression: error context not found\\n\");\n        return false;\n      }\n      uncompress_addr(&SICSLOWPAN_IP_BUF(VAR_0)->destipaddr, VAR_25->prefix,\n                      VAR_26[VAR_3],\n                      (uip_lladdr_t *)packetbuf_addr(VAR_37));\n    } else {\n      /* COMMENT_35 */\n      uncompress_addr(&SICSLOWPAN_IP_BUF(VAR_0)->destipaddr, VAR_28,\n                      VAR_29[VAR_3],\n                      (uip_lladdr_t *)packetbuf_addr(VAR_37));\n    }\n  }\n  VAR_38 += VAR_39;\n\n  /* COMMENT_36 */\n  VAR_6 = VAR_4 & VAR_18;\n  /* COMMENT_37 */\n  VAR_8 =  &SICSLOWPAN_IP_BUF(VAR_0)->proto;\n  VAR_9 = SICSLOWPAN_IPPAYLOAD_BUF(VAR_0);\n\n  while(VAR_6 && (*VAR_11 & VAR_40) == VAR_41) {\n    uint8_t VAR_42 = (*VAR_11 & 0x0e) >> 1;\n    /* COMMENT_38 */\n    uint8_t VAR_43 = (*VAR_11 & 0x01);\n    uint8_t VAR_44 = 0;\n    uint8_t VAR_45;\n    uint8_t VAR_46;\n\n    VAR_6 = VAR_43;\n\n    VAR_11++;\n    if(!VAR_43) {\n      VAR_44 = *VAR_11;\n      VAR_11++;\n      LOG_DBG(\"uncompression: next header is inlined. Next: %d\\n\", VAR_44);\n    }\n    VAR_45 = *VAR_11;\n    VAR_11++;\n\n    LOG_DBG(\"uncompression: found ext header id: %d next: %d len: %d\\n\", VAR_42, VAR_44, VAR_45);\n    switch(VAR_42) {\n    case VAR_47:\n      VAR_46 = VAR_48;\n      break;\n    case VAR_49:\n      VAR_46 = VAR_50;\n      break;\n    case VAR_51:\n      VAR_46 = VAR_52;\n      break;\n    case VAR_53:\n      VAR_46 = VAR_54;\n      break;\n    default:\n      LOG_DBG(\"uncompression: error unsupported ext header\\n\");\n      return false;\n    }\n    *VAR_8 = VAR_46;\n\n    /* COMMENT_39 */\n    if((VAR_9 - VAR_0) + VAR_55 + VAR_45 > VAR_1) {\n      LOG_WARN(\"uncompression: cannot write ext header beyond target buffer\\n\");\n      return false;\n    }\n\n    /* COMMENT_40 */\n    VAR_7 = (struct uip_ext_hdr *)VAR_9;\n    VAR_7->len = (VAR_55 + VAR_45) / 8;\n    if(VAR_7->len == 0) {\n      LOG_WARN(\"Extension header length is below 8\\n\");\n      return false;\n    }\n    VAR_7->len--;\n    VAR_7->next = VAR_44;\n    VAR_8 = &VAR_7->next;\n    memcpy((uint8_t *)VAR_7 + VAR_55, VAR_11, VAR_45);\n\n    VAR_11 += VAR_45;\n    VAR_38 += (VAR_7->len + 1) * 8;\n    VAR_9 += (VAR_7->len + 1) * 8;\n    VAR_10 += (VAR_7->len + 1) * 8;\n\n    LOG_DBG(\"uncompression: %d len: %d exthdr len: %d (calc: %d)\\n\",\n            VAR_46, VAR_45, VAR_7->len, (VAR_7->len + 1) * 8);\n  }\n\n  /* COMMENT_37 */\n  if(VAR_6 && (*VAR_11 & VAR_56) == VAR_57) {\n    struct uip_udp_hdr *VAR_58 = (struct uip_udp_hdr *)VAR_9;\n    uint16_t VAR_59;\n    uint8_t VAR_60;\n    *VAR_8 = VAR_61;\n    VAR_60 = *VAR_11 & VAR_62;\n    LOG_DBG(\"uncompression: incoming header value: %i\\n\", *VAR_11);\n    switch(*VAR_11 & VAR_63) {\n    case VAR_64:\n      /* COMMENT_41 */\n      memcpy(&VAR_58->srcport, VAR_11 + 1, 2);\n      memcpy(&VAR_58->destport, VAR_11 + 3, 2);\n      LOG_DBG(\"uncompression: UDP ports (ptr+5): %x, %x\\n\",\n             UIP_HTONS(VAR_58->srcport),\n             UIP_HTONS(VAR_58->destport));\n      VAR_11 += 5;\n      break;\n\n    case VAR_65:\n      /* COMMENT_42 */\n      LOG_DBG(\"uncompression: destination address\\n\");\n      memcpy(&VAR_58->srcport, VAR_11 + 1, 2);\n      VAR_58->destport = UIP_HTONS(VAR_66 + (*(VAR_11 + 3)));\n      LOG_DBG(\"uncompression: UDP ports (ptr+4): %x, %x\\n\",\n             UIP_HTONS(VAR_58->srcport), UIP_HTONS(VAR_58->destport));\n      VAR_11 += 4;\n      break;\n\n    case VAR_67:\n      /* COMMENT_43 */\n      LOG_DBG(\"uncompression: source address\\n\");\n      VAR_58->srcport = UIP_HTONS(VAR_66 +\n                                   (*(VAR_11 + 1)));\n      memcpy(&VAR_58->destport, VAR_11 + 2, 2);\n      LOG_DBG(\"uncompression: UDP ports (ptr+4): %x, %x\\n\",\n             UIP_HTONS(VAR_58->srcport), UIP_HTONS(VAR_58->destport));\n      VAR_11 += 4;\n      break;\n\n    case VAR_63:\n      /* COMMENT_44 */\n      VAR_58->srcport = UIP_HTONS(VAR_68 +\n                                   (*(VAR_11 + 1) >> 4));\n      VAR_58->destport = UIP_HTONS(VAR_68 +\n                                    ((*(VAR_11 + 1)) & 0x0F));\n      LOG_DBG(\"uncompression: UDP ports (ptr+2): %x, %x\\n\",\n             UIP_HTONS(VAR_58->srcport), UIP_HTONS(VAR_58->destport));\n      VAR_11 += 2;\n      break;\n    default:\n      LOG_DBG(\"uncompression: error unsupported UDP compression\\n\");\n      return false;\n    }\n    if(!VAR_60) { /* COMMENT_45 */\n      memcpy(&VAR_58->udpchksum, VAR_11, 2);\n      VAR_11 += 2;\n      LOG_DBG(\"uncompression: checksum included\\n\");\n    } else {\n      LOG_DBG(\"uncompression: checksum *NOT* included\\n\");\n    }\n\n    /* COMMENT_46 */\n    VAR_59 = 8 + packetbuf_datalen() - (VAR_11 - VAR_12);\n    VAR_58->udplen = UIP_HTONS(VAR_2 == 0 ? VAR_59 :\n                                VAR_2 - VAR_39 - VAR_10);\n    LOG_DBG(\"uncompression: UDP length: %u (ext: %u) ip_len: %d udp_len: %d\\n\",\n           UIP_HTONS(VAR_58->udplen), VAR_10, VAR_2, VAR_59);\n\n    VAR_38 += VAR_69;\n  }\n\n  VAR_13 = VAR_11 - VAR_12;\n\n  /* COMMENT_47 */\n  if(VAR_2 == 0) {\n    int VAR_45 = packetbuf_datalen() - VAR_13 + VAR_38 - VAR_39;\n    LOG_DBG(\"uncompression: IP payload length: %d. %u - %u + %u - %u\\n\", VAR_45,\n           packetbuf_datalen(), VAR_13, VAR_38, VAR_39);\n\n    /* COMMENT_48 */\n    SICSLOWPAN_IP_BUF(VAR_0)->len[0] = VAR_45 >> 8;\n    SICSLOWPAN_IP_BUF(VAR_0)->len[1] = VAR_45 & 0x00FF;\n  } else {\n    /* COMMENT_49 */\n    SICSLOWPAN_IP_BUF(VAR_0)->len[0] = (VAR_2 - VAR_39) >> 8;\n    SICSLOWPAN_IP_BUF(VAR_0)->len[1] = (VAR_2 - VAR_39) & 0x00FF;\n  }\n\n  return true;\n}",
  "func_graph_path": "contiki-ng/971354a39e46abfb3ea8f3fe542f53a7c6b17dd1/sicslowpan.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-static void\n+static bool\n uncompress_hdr_iphc(uint8_t *buf, uint16_t buf_size, uint16_t ip_len)\n {\n   uint8_t tmp, iphc0, iphc1, nhc;\n@@ -88,7 +88,7 @@\n       context = addr_context_lookup_by_number(sci);\n       if(context == NULL) {\n         LOG_ERR(\"uncompression: error context not found\\n\");\n-        return;\n+        return false;\n       }\n     }\n     /* if tmp == 0 we do not have a context and therefore no prefix */\n@@ -135,7 +135,7 @@\n       /* all valid cases below need the context! */\n       if(context == NULL) {\n         LOG_ERR(\"uncompression: error context not found\\n\");\n-        return;\n+        return false;\n       }\n       uncompress_addr(&SICSLOWPAN_IP_BUF(buf)->destipaddr, context->prefix,\n                       unc_ctxconf[tmp],\n@@ -190,14 +190,14 @@\n       break;\n     default:\n       LOG_DBG(\"uncompression: error unsupported ext header\\n\");\n-      return;\n+      return false;\n     }\n     *last_nextheader = proto;\n \n     /* Check that there is enough room to write the extension header. */\n     if((ip_payload - buf) + UIP_EXT_HDR_LEN + len > buf_size) {\n       LOG_WARN(\"uncompression: cannot write ext header beyond target buffer\\n\");\n-      return;\n+      return false;\n     }\n \n     /* uncompress the extension header */\n@@ -205,7 +205,7 @@\n     exthdr->len = (UIP_EXT_HDR_LEN + len) / 8;\n     if(exthdr->len == 0) {\n       LOG_WARN(\"Extension header length is below 8\\n\");\n-      return;\n+      return false;\n     }\n     exthdr->len--;\n     exthdr->next = next;\n@@ -273,7 +273,7 @@\n       break;\n     default:\n       LOG_DBG(\"uncompression: error unsupported UDP compression\\n\");\n-      return;\n+      return false;\n     }\n     if(!checksum_compressed) { /* has_checksum, default  */\n       memcpy(&udp_buf->udpchksum, hc06_ptr, 2);\n@@ -309,4 +309,6 @@\n     SICSLOWPAN_IP_BUF(buf)->len[0] = (ip_len - UIP_IPH_LEN) >> 8;\n     SICSLOWPAN_IP_BUF(buf)->len[1] = (ip_len - UIP_IPH_LEN) & 0x00FF;\n   }\n+\n+  return true;\n }",
  "diff_line_info": {
    "deleted_lines": [
      "static void",
      "        return;",
      "        return;",
      "      return;",
      "      return;",
      "      return;",
      "      return;"
    ],
    "added_lines": [
      "static bool",
      "        return false;",
      "        return false;",
      "      return false;",
      "      return false;",
      "      return false;",
      "      return false;",
      "",
      "  return true;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/contiki-ng/contiki-ng/pull/1482",
  "description": {
    "pr_info": {
      "title": "Added buffer boundary checks for 6LoWPAN decompression",
      "number": 1482
    },
    "comment": [
      "Unlike for the 6LoWPAN compression function, there are no boundary checks in the decompression function. Additionally, packets that are not decompressed correctly are passed on the to the upper layer because the IPHC decompression function does not return a value indicating whether the operation succeeded.\r\n\r\nThis PR addresses these two issues. Moreover, a packet that demonstrates the out-of-bounds read is added to the packet test, but the problem might be noticed only when compiled with an address sanitizer."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}