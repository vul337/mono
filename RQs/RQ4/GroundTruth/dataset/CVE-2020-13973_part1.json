{
  "cve_id": "CVE-2020-13973",
  "cwe_ids": [
    "CWE-79"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "OWASP/json-sanitizer",
  "commit_msg": "Escape <!--, --> and <script\n\nIn HTML script elements, `</script` is not the only substring that\nswitches the HTML parser state even when contained in a JS string\nliteral. This commit adds escaping for `<!--`, `-->` and `<script`,\nwhich appear to be all substrings that cause state transitions which\nare not reset by the `\"` closing the string literal.",
  "commit_hash": "53ceaac3e0a10e86d512ce96a0056578f2d1978f",
  "git_url": "https://github.com/OWASP/json-sanitizer/commit/53ceaac3e0a10e86d512ce96a0056578f2d1978f",
  "file_path": "src/main/java/com/google/json/JsonSanitizer.java",
  "func_name": "sanitizeString",
  "func_before": "private void sanitizeString(int start, int end) {\n    boolean closed = false;\n    for (int i = start; i < end; ++i) {\n      char ch = jsonish.charAt(i);\n      switch (ch) {\n        // Fixup newlines.\n        case '\\n': replace(i, i + 1, \"\\\\n\"); break;\n        case '\\r': replace(i, i + 1, \"\\\\r\"); break;\n        // Not newlines in JSON but unparseable by JS eval.\n        case '\\u2028': replace(i, i + 1, \"\\\\u2028\"); break;\n        case '\\u2029': replace(i, i + 1, \"\\\\u2029\"); break;\n        // String delimiting quotes that need to be converted : 'foo' -> \"foo\"\n        // or internal quotes that might need to be escaped : f\"o -> f\\\"o.\n        case '\"': case '\\'':\n          if (i == start) {\n            if (ch == '\\'') { replace(i, i + 1, '\"'); }\n          } else {\n            if (i + 1 == end) {\n              char startDelim = jsonish.charAt(start);\n              if (startDelim != '\\'') {\n                // If we're sanitizing a string whose start was inferred, then\n                // treat '\"' as closing regardless.\n                startDelim = '\"';\n              }\n              closed = startDelim == ch;\n            }\n            if (closed) {\n              if (ch == '\\'') { replace(i, i + 1, '\"'); }\n            } else if (ch == '\"') {\n              insert(i, '\\\\');\n            }\n          }\n          break;\n        // Embedding.  Disallow </script and ]]> in string literals so that\n        // the output can be embedded in HTML script elements and in XML CDATA\n        // sections.\n        case '/':\n          // Don't over escape.  Many JSON bodies contain innocuous HTML\n          // that can be safely embedded.\n          if (i > start && i + 2 < end && '<' == jsonish.charAt(i - 1)\n              && 's' == (jsonish.charAt(i + 1) | 32)\n              && 'c' == (jsonish.charAt(i + 2) | 32)) {\n            insert(i, '\\\\');\n          }\n          break;\n        case ']':\n          if (i + 2 < end && ']' == jsonish.charAt(i + 1)\n              && '>' == jsonish.charAt(i + 2)) {\n            replace(i, i + 1, \"\\\\u005d\");\n          }\n          break;\n        // Normalize escape sequences.\n        case '\\\\':\n          if (i + 1 == end) {\n            elide(i, i + 1);\n            break;\n          }\n          char sch = jsonish.charAt(i + 1);\n          switch (sch) {\n            case 'b': case 'f': case 'n': case 'r': case 't': case '\\\\':\n            case '/': case '\"':\n              ++i;\n              break;\n            case 'v':  // Recognized by JS but not by JSON.\n              replace(i, i + 2, \"\\\\u0008\");\n              ++i;\n              break;\n            case 'x':\n              if (i + 4 < end && isHexAt(i+2) && isHexAt(i+3)) {\n                replace(i, i + 2, \"\\\\u00\");  // \\xab -> \\u00ab\n                i += 3;\n                break;\n              }\n              elide(i, i + 1);\n              break;\n            case 'u':\n              if (i + 6 < end && isHexAt(i + 2) && isHexAt(i + 3)\n                  && isHexAt(i + 4) && isHexAt(i + 5)) {\n                i += 5;\n                break;\n              }\n              elide(i, i + 1);\n              break;\n            case '0': case '1': case '2': case '3':\n            case '4': case '5': case '6': case '7':\n              int octalEnd = i + 1;\n              if (octalEnd + 1 < end && isOctAt(octalEnd + 1)) {\n                ++octalEnd;\n                if (ch <= '3' && octalEnd + 1 < end && isOctAt(octalEnd + 1)) {\n                  ++octalEnd;\n                }\n                int value = 0;\n                for (int j = i; j < octalEnd; ++j) {\n                  value = (value << 3) | (jsonish.charAt(j) - '0');\n                }\n                replace(i + 1, octalEnd, \"u00\");\n                appendHex(value, 2);\n              }\n              i = octalEnd - 1;\n              break;\n            default:\n              // Literal char that is recognized by JS but not by JSON.\n              // \"\\-\" is valid JS but not valid JSON.\n              elide(i, i + 1);\n              break;\n          }\n          break;\n        default:\n          // Escape all control code-points and isolated surrogates which are\n          // not embeddable in XML.\n          // http://www.w3.org/TR/xml/#charsets says\n          //     Char ::= #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD]\n          //            | [#x10000-#x10FFFF]\n          if (ch < 0x20) {\n            if (ch == 9 || ch == 0xa || ch == 0xd) { continue; }\n          } else if (ch < 0xd800) {  // Not a surrogate.\n            continue;\n          } else if (ch < 0xe000) {  // A surrogate\n            if (Character.isHighSurrogate(ch) && i+1 < end\n                && Character.isLowSurrogate(jsonish.charAt(i+1))) {\n              ++i;  // Skip over low surrogate since we have already vetted it.\n              continue;\n            }\n          } else if (ch <= 0xfffd) {  // Not one of the 0xff.. controls.\n            continue;\n          }\n          replace(i, i + 1, \"\\\\u\");\n          for (int j = 4; --j >= 0;) {\n            sanitizedJson.append(HEX_DIGITS[(ch >>> (j << 2)) & 0xf]);\n          }\n          break;\n      }\n    }\n    if (!closed) { insert(end, '\"'); }\n  }",
  "abstract_func_before": "private void sanitizeString(int VAR_0, int VAR_1) {\n    boolean VAR_2 = false;\n    for (int VAR_3 = VAR_0; VAR_3 < VAR_1; ++VAR_3) {\n      char VAR_4 = VAR_5.charAt(VAR_3);\n      switch (VAR_4) {\n        /* COMMENT_0 */\n        case '\\n': replace(VAR_3, VAR_3 + 1, \"\\\\n\"); break;\n        case '\\r': replace(VAR_3, VAR_3 + 1, \"\\\\r\"); break;\n        /* COMMENT_1 */\n        case '\\u2028': replace(VAR_3, VAR_3 + 1, \"\\\\u2028\"); break;\n        case '\\u2029': replace(VAR_3, VAR_3 + 1, \"\\\\u2029\"); break;\n        /* COMMENT_2 */\n        /* COMMENT_3 */\n        case '\"': case '\\'':\n          if (VAR_3 == VAR_0) {\n            if (VAR_4 == '\\'') { replace(VAR_3, VAR_3 + 1, '\"'); }\n          } else {\n            if (VAR_3 + 1 == VAR_1) {\n              char VAR_6 = VAR_5.charAt(VAR_0);\n              if (VAR_6 != '\\'') {\n                /* COMMENT_4 */\n                /* COMMENT_5 */\n                VAR_6 = '\"';\n              }\n              VAR_2 = VAR_6 == VAR_4;\n            }\n            if (VAR_2) {\n              if (VAR_4 == '\\'') { replace(VAR_3, VAR_3 + 1, '\"'); }\n            } else if (VAR_4 == '\"') {\n              insert(VAR_3, '\\\\');\n            }\n          }\n          break;\n        /* COMMENT_6 */\n        /* COMMENT_7 */\n        /* COMMENT_8 */\n        case '/':\n          /* COMMENT_9 */\n          /* COMMENT_10 */\n          if (VAR_3 > VAR_0 && VAR_3 + 2 < VAR_1 && '<' == VAR_5.charAt(VAR_3 - 1)\n              && 's' == (VAR_5.charAt(VAR_3 + 1) | 32)\n              && 'c' == (VAR_5.charAt(VAR_3 + 2) | 32)) {\n            insert(VAR_3, '\\\\');\n          }\n          break;\n        case ']':\n          if (VAR_3 + 2 < VAR_1 && ']' == VAR_5.charAt(VAR_3 + 1)\n              && '>' == VAR_5.charAt(VAR_3 + 2)) {\n            replace(VAR_3, VAR_3 + 1, \"\\\\u005d\");\n          }\n          break;\n        /* COMMENT_11 */\n        case '\\\\':\n          if (VAR_3 + 1 == VAR_1) {\n            elide(VAR_3, VAR_3 + 1);\n            break;\n          }\n          char VAR_7 = VAR_5.charAt(VAR_3 + 1);\n          switch (VAR_7) {\n            case 'b': case 'f': case 'n': case 'r': case 't': case '\\\\':\n            case '/': case '\"':\n              ++VAR_3;\n              break;\n            case 'v':  /* COMMENT_12 */\n              replace(VAR_3, VAR_3 + 2, \"\\\\u0008\");\n              ++VAR_3;\n              break;\n            case 'x':\n              if (VAR_3 + 4 < VAR_1 && isHexAt(VAR_3+2) && isHexAt(VAR_3+3)) {\n                replace(VAR_3, VAR_3 + 2, \"\\\\u00\");  /* COMMENT_13 */\n                VAR_3 += 3;\n                break;\n              }\n              elide(VAR_3, VAR_3 + 1);\n              break;\n            case 'u':\n              if (VAR_3 + 6 < VAR_1 && isHexAt(VAR_3 + 2) && isHexAt(VAR_3 + 3)\n                  && isHexAt(VAR_3 + 4) && isHexAt(VAR_3 + 5)) {\n                VAR_3 += 5;\n                break;\n              }\n              elide(VAR_3, VAR_3 + 1);\n              break;\n            case '0': case '1': case '2': case '3':\n            case '4': case '5': case '6': case '7':\n              int VAR_8 = VAR_3 + 1;\n              if (VAR_8 + 1 < VAR_1 && isOctAt(VAR_8 + 1)) {\n                ++VAR_8;\n                if (VAR_4 <= '3' && VAR_8 + 1 < VAR_1 && isOctAt(VAR_8 + 1)) {\n                  ++VAR_8;\n                }\n                int VAR_9 = 0;\n                for (int VAR_10 = VAR_3; VAR_10 < VAR_8; ++VAR_10) {\n                  VAR_9 = (VAR_9 << 3) | (VAR_5.charAt(VAR_10) - '0');\n                }\n                replace(VAR_3 + 1, VAR_8, \"u00\");\n                appendHex(VAR_9, 2);\n              }\n              VAR_3 = VAR_8 - 1;\n              break;\n            default:\n              /* COMMENT_14 */\n              /* COMMENT_15 */\n              elide(VAR_3, VAR_3 + 1);\n              break;\n          }\n          break;\n        default:\n          /* COMMENT_16 */\n          /* COMMENT_17 */\n          /* COMMENT_18 */\n          /* COMMENT_19 */\n          /* COMMENT_20 */\n          if (VAR_4 < 0x20) {\n            if (VAR_4 == 9 || VAR_4 == 0xa || VAR_4 == 0xd) { continue; }\n          } else if (VAR_4 < 0xd800) {  /* COMMENT_21 */\n            continue;\n          } else if (VAR_4 < 0xe000) {  /* COMMENT_22 */\n            if (VAR_11.isHighSurrogate(VAR_4) && VAR_3+1 < VAR_1\n                && VAR_11.isLowSurrogate(VAR_5.charAt(VAR_3+1))) {\n              ++VAR_3;  /* COMMENT_23 */\n              continue;\n            }\n          } else if (VAR_4 <= 0xfffd) {  /* COMMENT_24 */\n            continue;\n          }\n          replace(VAR_3, VAR_3 + 1, \"\\\\u\");\n          for (int VAR_10 = 4; --VAR_10 >= 0;) {\n            VAR_12.append(VAR_13[(VAR_4 >>> (VAR_10 << 2)) & 0xf]);\n          }\n          break;\n      }\n    }\n    if (!VAR_2) { insert(VAR_1, '\"'); }\n  }",
  "func_graph_path_before": "OWASP/json-sanitizer/53ceaac3e0a10e86d512ce96a0056578f2d1978f/JsonSanitizer.java/vul/before/0.json",
  "func": "private void sanitizeString(int start, int end) {\n    boolean closed = false;\n    for (int i = start; i < end; ++i) {\n      char ch = jsonish.charAt(i);\n      switch (ch) {\n        // Fixup newlines.\n        case '\\n': replace(i, i + 1, \"\\\\n\"); break;\n        case '\\r': replace(i, i + 1, \"\\\\r\"); break;\n        // Not newlines in JSON but unparseable by JS eval.\n        case '\\u2028': replace(i, i + 1, \"\\\\u2028\"); break;\n        case '\\u2029': replace(i, i + 1, \"\\\\u2029\"); break;\n        // String delimiting quotes that need to be converted : 'foo' -> \"foo\"\n        // or internal quotes that might need to be escaped : f\"o -> f\\\"o.\n        case '\"': case '\\'':\n          if (i == start) {\n            if (ch == '\\'') { replace(i, i + 1, '\"'); }\n          } else {\n            if (i + 1 == end) {\n              char startDelim = jsonish.charAt(start);\n              if (startDelim != '\\'') {\n                // If we're sanitizing a string whose start was inferred, then\n                // treat '\"' as closing regardless.\n                startDelim = '\"';\n              }\n              closed = startDelim == ch;\n            }\n            if (closed) {\n              if (ch == '\\'') { replace(i, i + 1, '\"'); }\n            } else if (ch == '\"') {\n              insert(i, '\\\\');\n            }\n          }\n          break;\n        // Embedding. Disallow <script, </script, <!--, --> and ]]> in string\n        // literals so that the output can be embedded in HTML script elements\n        // and in XML CDATA sections without affecting the parser state.\n        // References:\n        // https://www.w3.org/TR/html53/semantics-scripting.html#restrictions-for-contents-of-script-elements\n        // https://www.w3.org/TR/html53/syntax.html#script-data-escaped-state\n        // https://www.w3.org/TR/html53/syntax.html#script-data-double-escaped-state\n        // https://www.w3.org/TR/xml/#sec-cdata-sect\n        case '<':\n          // Disallow <!--, which lets the HTML parser switch into the \"script\n          // data escaped\" state.\n          // Disallow <script, which followed by various characters lets the\n          // HTML parser switch into or out of the \"script data double escaped\"\n          // state.\n          // Disallow </script, which ends a script block.\n          if (i + 3 >= end)\n            break;\n          char c1 = jsonish.charAt(i + 1);\n          char c2 = jsonish.charAt(i + 2);\n          char c3 = jsonish.charAt(i + 3);\n          char lc1 = (char) (c1 | 32);\n          char lc2 = (char) (c2 | 32);\n          char lc3 = (char) (c3 | 32);\n          if ((c1 == '!' && c2 == '-' && c3 == '-') ||\n              (lc1 == 's' && lc2 == 'c' && lc3 == 'r') ||\n              (c1 == '/' && lc2 == 's' && lc3 == 'c')) {\n            replace(i, i + 1, \"\\\\u003c\"); // Escaped <\n          }\n          break;\n        case '>':\n          // Disallow -->, which lets the HTML parser switch out of the \"script\n          // data escaped\" or \"script data double escaped\" state.\n          if ((i - 2) >= start && '-' == jsonish.charAt(i - 2)\n              && '-' == jsonish.charAt(i - 1)) {\n            replace(i, i + 1, \"\\\\u003e\"); // Escaped >\n          }\n          break;\n        case ']':\n          if (i + 2 < end && ']' == jsonish.charAt(i + 1)\n              && '>' == jsonish.charAt(i + 2)) {\n            replace(i, i + 1, \"\\\\u005d\");\n          }\n          break;\n        // Normalize escape sequences.\n        case '\\\\':\n          if (i + 1 == end) {\n            elide(i, i + 1);\n            break;\n          }\n          char sch = jsonish.charAt(i + 1);\n          switch (sch) {\n            case 'b': case 'f': case 'n': case 'r': case 't': case '\\\\':\n            case '/': case '\"':\n              ++i;\n              break;\n            case 'v':  // Recognized by JS but not by JSON.\n              replace(i, i + 2, \"\\\\u0008\");\n              ++i;\n              break;\n            case 'x':\n              if (i + 4 < end && isHexAt(i+2) && isHexAt(i+3)) {\n                replace(i, i + 2, \"\\\\u00\");  // \\xab -> \\u00ab\n                i += 3;\n                break;\n              }\n              elide(i, i + 1);\n              break;\n            case 'u':\n              if (i + 6 < end && isHexAt(i + 2) && isHexAt(i + 3)\n                  && isHexAt(i + 4) && isHexAt(i + 5)) {\n                i += 5;\n                break;\n              }\n              elide(i, i + 1);\n              break;\n            case '0': case '1': case '2': case '3':\n            case '4': case '5': case '6': case '7':\n              int octalEnd = i + 1;\n              if (octalEnd + 1 < end && isOctAt(octalEnd + 1)) {\n                ++octalEnd;\n                if (ch <= '3' && octalEnd + 1 < end && isOctAt(octalEnd + 1)) {\n                  ++octalEnd;\n                }\n                int value = 0;\n                for (int j = i; j < octalEnd; ++j) {\n                  value = (value << 3) | (jsonish.charAt(j) - '0');\n                }\n                replace(i + 1, octalEnd, \"u00\");\n                appendHex(value, 2);\n              }\n              i = octalEnd - 1;\n              break;\n            default:\n              // Literal char that is recognized by JS but not by JSON.\n              // \"\\-\" is valid JS but not valid JSON.\n              elide(i, i + 1);\n              break;\n          }\n          break;\n        default:\n          // Escape all control code-points and isolated surrogates which are\n          // not embeddable in XML.\n          // http://www.w3.org/TR/xml/#charsets says\n          //     Char ::= #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD]\n          //            | [#x10000-#x10FFFF]\n          if (ch < 0x20) {\n            if (ch == 9 || ch == 0xa || ch == 0xd) { continue; }\n          } else if (ch < 0xd800) {  // Not a surrogate.\n            continue;\n          } else if (ch < 0xe000) {  // A surrogate\n            if (Character.isHighSurrogate(ch) && i+1 < end\n                && Character.isLowSurrogate(jsonish.charAt(i+1))) {\n              ++i;  // Skip over low surrogate since we have already vetted it.\n              continue;\n            }\n          } else if (ch <= 0xfffd) {  // Not one of the 0xff.. controls.\n            continue;\n          }\n          replace(i, i + 1, \"\\\\u\");\n          for (int j = 4; --j >= 0;) {\n            sanitizedJson.append(HEX_DIGITS[(ch >>> (j << 2)) & 0xf]);\n          }\n          break;\n      }\n    }\n    if (!closed) { insert(end, '\"'); }\n  }",
  "abstract_func": "private void sanitizeString(int VAR_0, int VAR_1) {\n    boolean VAR_2 = false;\n    for (int VAR_3 = VAR_0; VAR_3 < VAR_1; ++VAR_3) {\n      char VAR_4 = VAR_5.charAt(VAR_3);\n      switch (VAR_4) {\n        /* COMMENT_0 */\n        case '\\n': replace(VAR_3, VAR_3 + 1, \"\\\\n\"); break;\n        case '\\r': replace(VAR_3, VAR_3 + 1, \"\\\\r\"); break;\n        /* COMMENT_1 */\n        case '\\u2028': replace(VAR_3, VAR_3 + 1, \"\\\\u2028\"); break;\n        case '\\u2029': replace(VAR_3, VAR_3 + 1, \"\\\\u2029\"); break;\n        /* COMMENT_2 */\n        /* COMMENT_3 */\n        case '\"': case '\\'':\n          if (VAR_3 == VAR_0) {\n            if (VAR_4 == '\\'') { replace(VAR_3, VAR_3 + 1, '\"'); }\n          } else {\n            if (VAR_3 + 1 == VAR_1) {\n              char VAR_6 = VAR_5.charAt(VAR_0);\n              if (VAR_6 != '\\'') {\n                /* COMMENT_4 */\n                /* COMMENT_5 */\n                VAR_6 = '\"';\n              }\n              VAR_2 = VAR_6 == VAR_4;\n            }\n            if (VAR_2) {\n              if (VAR_4 == '\\'') { replace(VAR_3, VAR_3 + 1, '\"'); }\n            } else if (VAR_4 == '\"') {\n              insert(VAR_3, '\\\\');\n            }\n          }\n          break;\n        /* COMMENT_6 */\n        /* COMMENT_7 */\n        /* COMMENT_8 */\n        /* COMMENT_9 */\n        /* COMMENT_10 */\n        /* COMMENT_11 */\n        /* COMMENT_12 */\n        /* COMMENT_13 */\n        case '<':\n          /* COMMENT_14 */\n          /* COMMENT_15 */\n          /* COMMENT_16 */\n          /* COMMENT_17 */\n          /* COMMENT_18 */\n          /* COMMENT_19 */\n          if (VAR_3 + 3 >= VAR_1)\n            break;\n          char VAR_7 = VAR_5.charAt(VAR_3 + 1);\n          char VAR_8 = VAR_5.charAt(VAR_3 + 2);\n          char VAR_9 = VAR_5.charAt(VAR_3 + 3);\n          char VAR_10 = (char) (VAR_7 | 32);\n          char VAR_11 = (char) (VAR_8 | 32);\n          char VAR_12 = (char) (VAR_9 | 32);\n          if ((VAR_7 == '!' && VAR_8 == '-' && VAR_9 == '-') ||\n              (VAR_10 == 's' && VAR_11 == 'c' && VAR_12 == 'r') ||\n              (VAR_7 == '/' && VAR_11 == 's' && VAR_12 == 'c')) {\n            replace(VAR_3, VAR_3 + 1, \"\\\\u003c\"); /* COMMENT_20 */\n          }\n          break;\n        case '>':\n          /* COMMENT_21 */\n          /* COMMENT_22 */\n          if ((VAR_3 - 2) >= VAR_0 && '-' == VAR_5.charAt(VAR_3 - 2)\n              && '-' == VAR_5.charAt(VAR_3 - 1)) {\n            replace(VAR_3, VAR_3 + 1, \"\\\\u003e\"); /* COMMENT_23 */\n          }\n          break;\n        case ']':\n          if (VAR_3 + 2 < VAR_1 && ']' == VAR_5.charAt(VAR_3 + 1)\n              && '>' == VAR_5.charAt(VAR_3 + 2)) {\n            replace(VAR_3, VAR_3 + 1, \"\\\\u005d\");\n          }\n          break;\n        /* COMMENT_24 */\n        case '\\\\':\n          if (VAR_3 + 1 == VAR_1) {\n            elide(VAR_3, VAR_3 + 1);\n            break;\n          }\n          char VAR_13 = VAR_5.charAt(VAR_3 + 1);\n          switch (VAR_13) {\n            case 'b': case 'f': case 'n': case 'r': case 't': case '\\\\':\n            case '/': case '\"':\n              ++VAR_3;\n              break;\n            case 'v':  /* COMMENT_25 */\n              replace(VAR_3, VAR_3 + 2, \"\\\\u0008\");\n              ++VAR_3;\n              break;\n            case 'x':\n              if (VAR_3 + 4 < VAR_1 && isHexAt(VAR_3+2) && isHexAt(VAR_3+3)) {\n                replace(VAR_3, VAR_3 + 2, \"\\\\u00\");  /* COMMENT_26 */\n                VAR_3 += 3;\n                break;\n              }\n              elide(VAR_3, VAR_3 + 1);\n              break;\n            case 'u':\n              if (VAR_3 + 6 < VAR_1 && isHexAt(VAR_3 + 2) && isHexAt(VAR_3 + 3)\n                  && isHexAt(VAR_3 + 4) && isHexAt(VAR_3 + 5)) {\n                VAR_3 += 5;\n                break;\n              }\n              elide(VAR_3, VAR_3 + 1);\n              break;\n            case '0': case '1': case '2': case '3':\n            case '4': case '5': case '6': case '7':\n              int VAR_14 = VAR_3 + 1;\n              if (VAR_14 + 1 < VAR_1 && isOctAt(VAR_14 + 1)) {\n                ++VAR_14;\n                if (VAR_4 <= '3' && VAR_14 + 1 < VAR_1 && isOctAt(VAR_14 + 1)) {\n                  ++VAR_14;\n                }\n                int VAR_15 = 0;\n                for (int VAR_16 = VAR_3; VAR_16 < VAR_14; ++VAR_16) {\n                  VAR_15 = (VAR_15 << 3) | (VAR_5.charAt(VAR_16) - '0');\n                }\n                replace(VAR_3 + 1, VAR_14, \"u00\");\n                appendHex(VAR_15, 2);\n              }\n              VAR_3 = VAR_14 - 1;\n              break;\n            default:\n              /* COMMENT_27 */\n              /* COMMENT_28 */\n              elide(VAR_3, VAR_3 + 1);\n              break;\n          }\n          break;\n        default:\n          /* COMMENT_29 */\n          /* COMMENT_30 */\n          /* COMMENT_31 */\n          /* COMMENT_32 */\n          /* COMMENT_33 */\n          if (VAR_4 < 0x20) {\n            if (VAR_4 == 9 || VAR_4 == 0xa || VAR_4 == 0xd) { continue; }\n          } else if (VAR_4 < 0xd800) {  /* COMMENT_34 */\n            continue;\n          } else if (VAR_4 < 0xe000) {  /* COMMENT_35 */\n            if (VAR_17.isHighSurrogate(VAR_4) && VAR_3+1 < VAR_1\n                && VAR_17.isLowSurrogate(VAR_5.charAt(VAR_3+1))) {\n              ++VAR_3;  /* COMMENT_36 */\n              continue;\n            }\n          } else if (VAR_4 <= 0xfffd) {  /* COMMENT_37 */\n            continue;\n          }\n          replace(VAR_3, VAR_3 + 1, \"\\\\u\");\n          for (int VAR_16 = 4; --VAR_16 >= 0;) {\n            VAR_18.append(VAR_19[(VAR_4 >>> (VAR_16 << 2)) & 0xf]);\n          }\n          break;\n      }\n    }\n    if (!VAR_2) { insert(VAR_1, '\"'); }\n  }",
  "func_graph_path": "OWASP/json-sanitizer/53ceaac3e0a10e86d512ce96a0056578f2d1978f/JsonSanitizer.java/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -31,16 +31,41 @@\n             }\n           }\n           break;\n-        // Embedding.  Disallow </script and ]]> in string literals so that\n-        // the output can be embedded in HTML script elements and in XML CDATA\n-        // sections.\n-        case '/':\n-          // Don't over escape.  Many JSON bodies contain innocuous HTML\n-          // that can be safely embedded.\n-          if (i > start && i + 2 < end && '<' == jsonish.charAt(i - 1)\n-              && 's' == (jsonish.charAt(i + 1) | 32)\n-              && 'c' == (jsonish.charAt(i + 2) | 32)) {\n-            insert(i, '\\\\');\n+        // Embedding. Disallow <script, </script, <!--, --> and ]]> in string\n+        // literals so that the output can be embedded in HTML script elements\n+        // and in XML CDATA sections without affecting the parser state.\n+        // References:\n+        // https://www.w3.org/TR/html53/semantics-scripting.html#restrictions-for-contents-of-script-elements\n+        // https://www.w3.org/TR/html53/syntax.html#script-data-escaped-state\n+        // https://www.w3.org/TR/html53/syntax.html#script-data-double-escaped-state\n+        // https://www.w3.org/TR/xml/#sec-cdata-sect\n+        case '<':\n+          // Disallow <!--, which lets the HTML parser switch into the \"script\n+          // data escaped\" state.\n+          // Disallow <script, which followed by various characters lets the\n+          // HTML parser switch into or out of the \"script data double escaped\"\n+          // state.\n+          // Disallow </script, which ends a script block.\n+          if (i + 3 >= end)\n+            break;\n+          char c1 = jsonish.charAt(i + 1);\n+          char c2 = jsonish.charAt(i + 2);\n+          char c3 = jsonish.charAt(i + 3);\n+          char lc1 = (char) (c1 | 32);\n+          char lc2 = (char) (c2 | 32);\n+          char lc3 = (char) (c3 | 32);\n+          if ((c1 == '!' && c2 == '-' && c3 == '-') ||\n+              (lc1 == 's' && lc2 == 'c' && lc3 == 'r') ||\n+              (c1 == '/' && lc2 == 's' && lc3 == 'c')) {\n+            replace(i, i + 1, \"\\\\u003c\"); // Escaped <\n+          }\n+          break;\n+        case '>':\n+          // Disallow -->, which lets the HTML parser switch out of the \"script\n+          // data escaped\" or \"script data double escaped\" state.\n+          if ((i - 2) >= start && '-' == jsonish.charAt(i - 2)\n+              && '-' == jsonish.charAt(i - 1)) {\n+            replace(i, i + 1, \"\\\\u003e\"); // Escaped >\n           }\n           break;\n         case ']':",
  "diff_line_info": {
    "deleted_lines": [
      "        // Embedding.  Disallow </script and ]]> in string literals so that",
      "        // the output can be embedded in HTML script elements and in XML CDATA",
      "        // sections.",
      "        case '/':",
      "          // Don't over escape.  Many JSON bodies contain innocuous HTML",
      "          // that can be safely embedded.",
      "          if (i > start && i + 2 < end && '<' == jsonish.charAt(i - 1)",
      "              && 's' == (jsonish.charAt(i + 1) | 32)",
      "              && 'c' == (jsonish.charAt(i + 2) | 32)) {",
      "            insert(i, '\\\\');"
    ],
    "added_lines": [
      "        // Embedding. Disallow <script, </script, <!--, --> and ]]> in string",
      "        // literals so that the output can be embedded in HTML script elements",
      "        // and in XML CDATA sections without affecting the parser state.",
      "        // References:",
      "        // https://www.w3.org/TR/html53/semantics-scripting.html#restrictions-for-contents-of-script-elements",
      "        // https://www.w3.org/TR/html53/syntax.html#script-data-escaped-state",
      "        // https://www.w3.org/TR/html53/syntax.html#script-data-double-escaped-state",
      "        // https://www.w3.org/TR/xml/#sec-cdata-sect",
      "        case '<':",
      "          // Disallow <!--, which lets the HTML parser switch into the \"script",
      "          // data escaped\" state.",
      "          // Disallow <script, which followed by various characters lets the",
      "          // HTML parser switch into or out of the \"script data double escaped\"",
      "          // state.",
      "          // Disallow </script, which ends a script block.",
      "          if (i + 3 >= end)",
      "            break;",
      "          char c1 = jsonish.charAt(i + 1);",
      "          char c2 = jsonish.charAt(i + 2);",
      "          char c3 = jsonish.charAt(i + 3);",
      "          char lc1 = (char) (c1 | 32);",
      "          char lc2 = (char) (c2 | 32);",
      "          char lc3 = (char) (c3 | 32);",
      "          if ((c1 == '!' && c2 == '-' && c3 == '-') ||",
      "              (lc1 == 's' && lc2 == 'c' && lc3 == 'r') ||",
      "              (c1 == '/' && lc2 == 's' && lc3 == 'c')) {",
      "            replace(i, i + 1, \"\\\\u003c\"); // Escaped <",
      "          }",
      "          break;",
      "        case '>':",
      "          // Disallow -->, which lets the HTML parser switch out of the \"script",
      "          // data escaped\" or \"script data double escaped\" state.",
      "          if ((i - 2) >= start && '-' == jsonish.charAt(i - 2)",
      "              && '-' == jsonish.charAt(i - 1)) {",
      "            replace(i, i + 1, \"\\\\u003e\"); // Escaped >"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/OWASP/json-sanitizer/pull/20",
  "description": {
    "pr_info": {
      "title": "Escape <!--, --> and <script",
      "number": 20
    },
    "comment": [
      "In HTML script elements, `</script` is not the only substring that switches the HTML parser state even when contained in a JS string literal. This commit adds escaping for `<!--`, `-->` and `<script`, which appear to be all substrings that cause state transitions which are not reset by the `\"` closing the string literal.\r\n\r\nThe injection of `<!--`, `-->` and `<script` in script elements is less severe than that of `</script` since they do not directly allow the execution of arbitrary HTML/JS. However, they could potentially be used to selectively disable scripts by causing syntax errors.\r\n\r\nThe following examples demonstrate the effect of these injections in a JSON context. In all cases, the alert is not executed, but will be executed if the value of the `json` variable is replaced with a harmless literal such as \"foobar\". The first example is the most relevant one since it does not have any further requirements on the contents of the script. The second and especially the third example are much more theoretical, but still valid HTML/JS.\r\n\r\n```html\r\n<script>\r\n    var json = \"<!--<script>\";\r\n    alert(\"not executed\");\r\n</script>\r\n```\r\n\r\n```html\r\n<script>\r\n    var unrelated_variable = \"<!--\";\r\n    // ...\r\n    var json = \"<script>\";\r\n    alert(\"not executed\");\r\n</script>\r\n```\r\n\r\n```html\r\n<script>\r\n<!--<script>\r\n    var json = \"-->\"\r\n</script />\r\nalert(\"not executed\");\r\n</script>\r\n```",
      "Thank you for this thoughtful contribution!\n\n--\nJim Manico\n\n\n> On Jun 4, 2020, at 7:40 AM, Fabian Henneke <notifications@github.com> wrote:\n> \n> ﻿\n> In HTML script elements, </script is not the only substring that switches the HTML parser state even when contained in a JS string literal. This commit adds escaping for <!--, --> and <script, which appear to be all substrings that cause state transitions which are not reset by the \" closing the string literal.\n> \n> The injection of <!--, --> and <scriptin script elements is less severe than that of</script` since they do not directly allow the execution of arbitrary HTML/JS. However, they could potentially be used to selectively disable scripts by causing syntax errors.\n> \n> The following examples demonstrate the effect of these injections in a JSON context. In all cases, the alert is not executed, but will be executed if the value of the json variable is replaced with a harmless literal such as \"foobar\". The first example is the most relevant one since it does not have any further requirements on the contents of the script. The second and especially the third example are much more theoretical, but still valid HTML/JS.\n> \n> <script>\n>     var json = \"<!--<script>\";\n>     alert(\"not executed\");\n> </script>\n> <script>\n>     var unrelated_variable = \"<!--\";\n>     // ...\n>     var json = \"<script>\";\n>     alert(\"not executed\");\n> </script>\n> <script>\n> <!--<script>\n>     var json = \"-->\"\n> </script />\n> alert(\"not executed\");\n> </script>\n> You can view, comment on, or merge this pull request online at:\n> \n>   https://github.com/OWASP/json-sanitizer/pull/20\n> \n> Commit Summary\n> \n> Escape <!--, --> and <script\n> File Changes\n> \n> M README.md (4)\n> M src/main/java/com/google/json/JsonSanitizer.java (43)\n> M src/test/java/com/google/json/JsonSanitizerTest.java (23)\n> Patch Links:\n> \n> https://github.com/OWASP/json-sanitizer/pull/20.patch\n> https://github.com/OWASP/json-sanitizer/pull/20.diff\n> —\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub, or unsubscribe.\n",
      "Here is another example that shows why escaping `<!--` by itself is necessary:\r\n\r\n```html\r\n<script>\r\n    var json = \"<!--\";\r\n    // ...\r\n    var unrelated_variable = \"<script>\";\r\n    alert(\"not executed\");\r\n</script>\r\n```",
      "I'll merge this tomorrow morning (US ET) and push a version to maven central.\r\n\r\nWhen I put out an advisory, does it need to touch on anything besides:\r\n\r\n- this affects embedders who are embedding sanitized JSON in HTML `<script>` elements after a `<!--` sequence\r\n  - either as part of a [*SingleLineHTMLOpenComment*](https://www.ecma-international.org/ecma-262/10.0/index.html#prod-annexB-SingleLineHTMLOpenComment)\r\n  - or embedded in JavaScript as in\r\n    ```js\r\n    [\"<!--\", x<!--y, /<!--/] // <!--\r\n    ```\r\n- users should update to version __TBD__",
      "> I'll merge this tomorrow morning (US ET) and push a version to maven central.\r\n> \r\n> When I put out an advisory, does it need to touch on anything besides:\r\n> \r\n> - this affects embedders who are embedding sanitized JSON in HTML `<script>` elements after a `<!--` sequence\r\n>   - either as part of a [*SingleLineHTMLOpenComment*](https://www.ecma-international.org/ecma-262/10.0/index.html#prod-annexB-SingleLineHTMLOpenComment)\r\n>   - or embedded in JavaScript as in\r\n>     ```js\r\n>     [\"<!--\", x<!--y, /<!--/] // <!--\r\n>     ```\r\n> - users should update to version __TBD__\r\n\r\nI think that this potentially affects **every** embedder, not just those that already have a `<!--`in their script (see the first example above): By injecting `<!--<script>`, a script element can be forced to continue through the first end tag until a second one is encountered. \r\n\r\nIf there is no second `</script>` tag, the script will simply not execute. With a stored injection, this could be a DoS attack, with a reflected injection, this could still be used to selectively disable parts of scripts.\r\n\r\nIf there is a second `</script>` tag on the page, the result will likely be a syntax error right on the first `</script>` since it is pretty unlikely that `</script>` itself forms valid JS. But this is not completely impossible, e.g.\r\n\r\n ```\r\nalert(1)\r\n</script />\r\nalert(2)\r\n```\r\nis a valid JavaScript expression which compares `undefined` to a regular expression and the resulting truth value `false` to `undefined`, in the process showing two alerts instead of just one. While it is extremely unlikely that this can be used for XSS in practice, it might allow for creative nonce-based CSP bypasses given another injection point right after the `</script>` tag.\r\n\r\n**Edit:** The following is an example of a CSP bypass when the attacker can additionally inject in the script end tag:\r\n\r\n```html\r\n<script nonce=\"secretnonce\">\r\n    // ...\r\n    var json = \"injection_point_1_valid_JSON\"\r\n    // ...\r\n    // The following command can be anything as long as it doesn't end with a semicolon\r\n    var foo = 36\r\n</script injection_point_2>\r\n```\r\n\r\nIn this case, the attacker can inject `<!--<script>` in injection point 1 and `/;alert(1)//` in injection point 2 to execute arbitrary JS, which I believe would not be possible without the JSON injection. This also applies if injection point 2 comes right after the script end tag on the same line. I currently don't see a way for this to work if `</script>` is followed by a line break, but there may be some part of the JS syntax I have missed.\r\n\r\nAll in all, the full scope seems pretty difficult to assess, but most embedders could at least suffer from a broken page as a result of sucu injection. Everything beyond that is probably more of a theoretical issue.\r\n\r\n",
      "Fix included in [:1.2.1](https://search.maven.org/search?q=g:com.mikesamuel%20AND%20a:json-sanitizer%20AND%20v:1.2.1) which should be indexed by maven shortly.\r\n\r\n@FabianHenneke did you request a CVE for this or would you like me to?\r\n\r\nHere's a second draft of the announcement.\r\n\r\n----\r\n\r\n# Users of *com.mikesamuel:json-sanitizer* should upgrade to version 1.2.1 or later.\r\n\r\nA bug in *com.mikesamuel:json-sanitizer:1.2.0* and prior allows an attacker who controls the content of a JSON string that is later embedded in an HTML `<script>` element to confuse the HTML parser as to where the `<script>` element ends.  If the attacker also controls other content, e.g. a string of non-JavaScript content adjacent to the `<script>` element, this can lead to RCE.\r\n\r\nSee https://github.com/OWASP/json-sanitizer/pull/20#issue-427776274 for details.\r\n\r\nIf you have questions, please ask at the [json-sanitizer-support](https://groups.google.com/forum/#!forum/json-sanitizer-support) Google Group.\r\n",
      "> @FabianHenneke did you request a CVE for this or would you like me to?\r\n\r\n@mikesamuel I haven't. Should this go directly through MITRE or to another CNA? I would generally prefer you to do the filing in order to keep the CVE metadata consistent for this project, but can take care of it if you are busy.\r\n\r\n> If the attacker also controls other content, e.g. a string of non-JavaScript content adjacent to the `<script>` element, this can lead to RCE.\r\n\r\nHow about the following, which is currently my best shot at describing the scope:\r\n\r\n> This can be used to prevent the execution of `<script>` elements. If the attacker additionally controls content in or right after the `</script>` end tag, this could lead to the execution of arbitrary JavaScript and a bypass of nonce-based CSPs.\r\n\r\nTo me, RCE in the context of a Java project sounds a bit more dramatic than \"execution of arbitrary JavaScript\", which is why I went for the latter. Feel free to tweak this further though.\r\n\r\n",
      "Why CVE? The injection occurs only if there is an attack payload as a JSON value. The sanitizer is meant to disallow illegal JSON structure not sanitize individual values per my understanding.\n\nI assume that data submitted server-side in untrusted JSON still needs to be used safely (ie: query parameterization, etc).\n\nI assume that JSON data embedded in HTML markup still needs to be encoded to embed it safely. (JSON  serializer and encoder like \nhttps://github.com/yahoo/serialize-javascript )\n\nMay I ask what security use case is broken and what are we fixing that needs a CVE?\n\nAloha,\n--\nJim Manico\n@Manicode\n\n\n> On Jun 8, 2020, at 2:32 AM, Fabian Henneke <notifications@github.com> wrote:\n> \n> ﻿\n> @FabianHenneke did you request a CVE for this or would you like me to?\n> \n> @mikesamuel I haven't. Should this go directly through MITRE or to another CNA? I would generally prefer you to do the filing in order to keep the CVE metadata consistent for this project, but can take care of it if you are busy.\n> \n> If the attacker also controls other content, e.g. a string of non-JavaScript content adjacent to the <script> element, this can lead to RCE.\n> \n> How about the following, which is currently my best shot at describing the scope:\n> \n> This can be used to prevent the execution of <script> elements. If the attacker additionally controls content in or right after the </script> end tag, this could lead to the execution of arbitrary JavaScript and a bypass of nonce-based CSPs.\n> \n> To me, RCE in the context of a Java project sounds a bit more dramatic than \"execution of arbitrary JavaScript\", which is why I went for the latter. Feel free to tweak this further though.\n> \n> —\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub, or unsubscribe.\n",
      "> I assume that JSON data embedded in HTML markup still needs to be encoded to embed it safely. \r\nhttps://github.com/OWASP/json-sanitizer#output says\r\n\r\n> The output will not contain the substrings (case-insensitively) `\"<script\"`, `\"</script\"` and `\"<!--\"` and can thus be embedded inside an HTML script element without further encoding.",
      "> > @FabianHenneke did you request a CVE for this or would you like me to?\r\n> \r\n> @mikesamuel I haven't. Should this go directly through MITRE or to another CNA? I would generally prefer you to do the filing in order to keep the CVE metadata consistent for this project, but can take care of it if you are busy.\r\n\r\nI am currently unaffiliated with any other CNA, so I was going to go through MITRE.\r\nI'll take care of it.\r\n\r\n\r\n> > If the attacker also controls other content, e.g. a string of non-JavaScript content adjacent to the `<script>` element, this can lead to RCE.\r\n> \r\n> How about the following, which is currently my best shot at describing the scope:\r\n> \r\n> > This can be used to prevent the execution of `<script>` elements. If the attacker additionally controls content in or right after the `</script>` end tag, this could lead to the execution of arbitrary JavaScript and a bypass of nonce-based CSPs.\r\n> \r\n> To me, RCE in the context of a Java project sounds a bit more dramatic than \"execution of arbitrary JavaScript\", which is why I went for the latter. Feel free to tweak this further though.\r\n\r\nGood point.  Will do.",
      "Understood, of course. I only use this tool server-side before hitting a JSON parser. \n\nYea, a CVE is in order. \n\n--\nJim Manico\n@Manicode\n\n> On Jun 8, 2020, at 10:19 AM, Mike Samuel <notifications@github.com> wrote:\n> \n> ﻿\n> I assume that JSON data embedded in HTML markup still needs to be encoded to embed it safely.\n> https://github.com/OWASP/json-sanitizer#output says\n> \n> The output will not contain the substrings (case-insensitively) \"<script\", \"</script\" and \"<!--\" and can thus be embedded inside an HTML script element without further encoding.\n> \n> —\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub, or unsubscribe.\n",
      "Ok.  CVE request is before the CVE gnomes.",
      "@mikesamuel I missed another way this could be abused: If there is a second injection point that allows `</script>`, this can also lead to XSS. See http://portswigger-labs.net/xss/script.php?x=%3C!--%3Cscript%3E&y=%3C/script%3E%3Cimg%20src=1%20onerror=alert(1)%3E for an example.",
      "CVE-2020-13973"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95"
}