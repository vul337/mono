{
  "cve_id": "CVE-2022-28068",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "radareorg/radare2",
  "commit_msg": "Fix oobread crash in DWARF parser (tests_64924) ##crash\n\nReported by giantbranch of NSFOCUS TIANJI Lab",
  "commit_hash": "637f4bd1af6752e28e0a9998e954e2e9ce6fa992",
  "git_url": "https://github.com/radareorg/radare2/commit/637f4bd1af6752e28e0a9998e954e2e9ce6fa992",
  "file_path": "libr/anal/dwarf_process.c",
  "func_name": "parse_dwarf_location",
  "func_before": "static VariableLocation *parse_dwarf_location (Context *ctx, const RBinDwarfAttrValue *loc, const RBinDwarfAttrValue *frame_base) {\n\t/* reg5 - val is in register 5\n\tfbreg <leb> - offset from frame base\n\tregx <leb> - contents is in register X\n\taddr <addr> - contents is in at addr\n\tbregXX <leb> - contents is at offset from specified register\n\t- we now support 3 options: SP, BP and register based arguments */\n\n\t/* Loclist offset is usually CONSTANT or REFERENCE at older DWARF versions, new one has LocListPtr for that */\n\tif (loc->kind != DW_AT_KIND_BLOCK && loc->kind != DW_AT_KIND_LOCLISTPTR && loc->kind != DW_AT_KIND_REFERENCE && loc->kind != DW_AT_KIND_CONSTANT) {\n\t\treturn NULL;\n\t}\n\tRBinDwarfBlock block;\n\tif (loc->kind == DW_AT_KIND_LOCLISTPTR || loc->kind == DW_AT_KIND_REFERENCE || loc->kind == DW_AT_KIND_CONSTANT) {\n\t\tut64 offset = loc->reference;\n\t\tRBinDwarfLocList *range_list = ht_up_find (ctx->locations, offset, NULL);\n\t\tif (!range_list) { /* for some reason offset isn't there, wrong parsing or malformed dwarf */\n\t\t\treturn NULL;\n\t\t}\n\t\t/* use the largest range as a variable */\n\t\tRBinDwarfLocRange *range = find_largest_loc_range (range_list->list);\n\t\tif (!range) {\n\t\t\treturn NULL;\n\t\t}\n\t\t/* Very rough and sloppy, refactor this hacked up stuff */\n\t\tblock = *range->expression;\n\t\t// range->expression... etc\n\t} else {\n\t\tblock = loc->block;\n\t}\n\tVariableLocationKind kind = LOCATION_UNKNOWN;\n\tst64 offset = 0;\n\tut64 address = 0;\n\tut64 reg_num = -1;\n\tconst char *reg_name = NULL; /* literal */\n\tsize_t i;\n\tfor (i = 0; i < block.length; i++) {\n\t\tswitch (block.data[i]) {\n\t\tcase DW_OP_fbreg: {\n\t\t/* TODO sometimes CFA is referenced, but we don't parse that yet\n\t\t   just an offset involving framebase of a function*/\n\t\t\tif (i == block.length - 1) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tconst ut8 *dump = &block.data[++i];\n\t\t\toffset = r_sleb128 (&dump, &block.data[loc->block.length]);\n\t\t\tif (frame_base) {\n\t\t\t\t/* recursive parsing, but frame_base should be only one, but someone\n\t\t\t\t   could make malicious resource exhaustion attack, so a depth counter might be cool? */\n\t\t\t\tVariableLocation *location = parse_dwarf_location (ctx, frame_base, NULL);\n\t\t\t\tif (location) {\n\t\t\t\t\tlocation->offset += offset;\n\t\t\t\t\treturn location;\n\t\t\t\t}\n\t\t\t\treturn NULL;\n\t\t\t} else {\n\t\t\t\t/* Might happen if frame_base has a frame_base reference? I don't think it can tho */\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase DW_OP_reg0:\n\t\tcase DW_OP_reg1:\n\t\tcase DW_OP_reg2:\n\t\tcase DW_OP_reg3:\n\t\tcase DW_OP_reg4:\n\t\tcase DW_OP_reg5:\n\t\tcase DW_OP_reg6:\n\t\tcase DW_OP_reg7:\n\t\tcase DW_OP_reg8:\n\t\tcase DW_OP_reg9:\n\t\tcase DW_OP_reg10:\n\t\tcase DW_OP_reg11:\n\t\tcase DW_OP_reg12:\n\t\tcase DW_OP_reg13:\n\t\tcase DW_OP_reg14:\n\t\tcase DW_OP_reg15:\n\t\tcase DW_OP_reg16:\n\t\tcase DW_OP_reg17:\n\t\tcase DW_OP_reg18:\n\t\tcase DW_OP_reg19:\n\t\tcase DW_OP_reg20:\n\t\tcase DW_OP_reg21:\n\t\tcase DW_OP_reg22:\n\t\tcase DW_OP_reg23:\n\t\tcase DW_OP_reg24:\n\t\tcase DW_OP_reg25:\n\t\tcase DW_OP_reg26:\n\t\tcase DW_OP_reg27:\n\t\tcase DW_OP_reg28:\n\t\tcase DW_OP_reg29:\n\t\tcase DW_OP_reg30:\n\t\tcase DW_OP_reg31: {\n\t\t\t/* Will mostly be used for SP based arguments */\n\t\t\t/* TODO I need to find binaries that uses this so I can test it out*/\n\t\t\treg_num = block.data[i] - DW_OP_reg0; // get the reg number\n\t\t\treg_name = get_dwarf_reg_name (ctx->anal->cpu, reg_num, &kind, ctx->anal->bits);\n\t\t\tbreak;\n\t\t}\n\t\tcase DW_OP_breg0:\n\t\tcase DW_OP_breg1:\n\t\tcase DW_OP_breg2:\n\t\tcase DW_OP_breg3:\n\t\tcase DW_OP_breg4:\n\t\tcase DW_OP_breg5:\n\t\tcase DW_OP_breg6:\n\t\tcase DW_OP_breg7:\n\t\tcase DW_OP_breg8:\n\t\tcase DW_OP_breg9:\n\t\tcase DW_OP_breg10:\n\t\tcase DW_OP_breg11:\n\t\tcase DW_OP_breg12:\n\t\tcase DW_OP_breg13:\n\t\tcase DW_OP_breg14:\n\t\tcase DW_OP_breg15:\n\t\tcase DW_OP_breg16:\n\t\tcase DW_OP_breg17:\n\t\tcase DW_OP_breg18:\n\t\tcase DW_OP_breg19:\n\t\tcase DW_OP_breg20:\n\t\tcase DW_OP_breg21:\n\t\tcase DW_OP_breg22:\n\t\tcase DW_OP_breg23:\n\t\tcase DW_OP_breg24:\n\t\tcase DW_OP_breg25:\n\t\tcase DW_OP_breg26:\n\t\tcase DW_OP_breg27:\n\t\tcase DW_OP_breg28:\n\t\tcase DW_OP_breg29:\n\t\tcase DW_OP_breg30:\n\t\tcase DW_OP_breg31: {\n\t\t\tif (i == block.length - 1) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\t/* The single operand of the DW_OP_bregn operations provides\n\t\t\tsigned LEB128 offset from the specified register.  */\n\t\t\treg_num = block.data[i] - DW_OP_breg0; // get the reg number\n\t\t\tconst ut8 *buffer = &block.data[++i];\n\t\t\toffset = r_sleb128 (&buffer, &block.data[block.length]);\n\t\t\t/* TODO do a proper expression parsing, move by the amount of bytes sleb reads */\n\t\t\ti += buffer - &block.data[0];\n\t\t\treg_name = get_dwarf_reg_name (ctx->anal->cpu, reg_num, &kind, ctx->anal->bits);\n\t\t\tbreak;\n\t\t}\n\t\tcase DW_OP_bregx: {\n\t\t\tif (i == block.length - 1) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\t/* 2 operands, reg_number, offset*/\n\t\t\t/* I need to find binaries that uses this so I can test it out*/\n\t\t\tconst ut8 *buffer = &block.data[++i];\n\t\t\tconst ut8 *buf_end = &block.data[block.length];\n\t\t\tbuffer = r_uleb128 (buffer, buf_end - buffer, &reg_num, NULL);\n\t\t\tif (buffer == buf_end) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\toffset = r_sleb128 (&buffer, buf_end);\n\t\t\treg_name = get_dwarf_reg_name (ctx->anal->cpu, reg_num, &kind, ctx->anal->bits);\n\t\t\tbreak;\n\t\t}\n\t\tcase DW_OP_addr: {\n\t\t\t/* The DW_OP_addr operation has a single operand that encodes a machine address and whose\n\t\t\tsize is the size of an address on the target machine.  */\n\t\t\tconst int addr_size = ctx->anal->bits / 8;\n\t\t\tconst ut8 *dump = &block.data[++i];\n\t\t\t/* malformed, not enough bytes to represent address */\n\t\t\tif (block.length - i < addr_size) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tswitch (addr_size) {\n\t\t\tcase 1:\n\t\t\t\taddress = r_read_ble8 (dump);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\taddress = r_read_ble16 (dump, ctx->anal->big_endian);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\taddress = r_read_ble32 (dump, ctx->anal->big_endian);\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\taddress = r_read_ble64 (dump, ctx->anal->big_endian);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tr_warn_if_reached (); /* weird addr_size */\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tkind = LOCATION_GLOBAL; // address\n\t\t\tbreak;\n\t\t}\n\t\tcase DW_OP_call_frame_cfa: {\n\t\t\t// REMOVE XXX\n\t\t\tkind = LOCATION_BP;\n\t\t\toffset += 16;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (kind == LOCATION_UNKNOWN) {\n\t\treturn NULL;\n\t}\n\tVariableLocation *location = R_NEW0 (VariableLocation);\n\tif (location) {\n\t\tlocation->reg_name = reg_name;\n\t\tlocation->reg_num = reg_num;\n\t\tlocation->kind = kind;\n\t\tlocation->offset = offset;\n\t\tlocation->address = address;\n\t}\n\treturn location;\n}",
  "abstract_func_before": "static VariableLocation *parse_dwarf_location (Context *VAR_0, const RBinDwarfAttrValue *VAR_1, const RBinDwarfAttrValue *VAR_2) {\n\t/* COMMENT_0 */\n                                     \n                                       \n                                     \n                                                             \n                                                                   \n\n\t/* COMMENT_6 */\n\tif (VAR_1->kind != VAR_3 && VAR_1->kind != VAR_4 && VAR_1->kind != VAR_5 && VAR_1->kind != VAR_6) {\n\t\treturn NULL;\n\t}\n\tRBinDwarfBlock VAR_7;\n\tif (VAR_1->kind == VAR_4 || VAR_1->kind == VAR_5 || VAR_1->kind == VAR_6) {\n\t\tut64 VAR_8 = VAR_1->reference;\n\t\tRBinDwarfLocList *VAR_9 = ht_up_find (VAR_0->locations, VAR_8, NULL);\n\t\tif (!VAR_9) { /* COMMENT_7 */\n\t\t\treturn NULL;\n\t\t}\n\t\t/* COMMENT_8 */\n\t\tRBinDwarfLocRange *VAR_10 = find_largest_loc_range (VAR_9->list);\n\t\tif (!VAR_10) {\n\t\t\treturn NULL;\n\t\t}\n\t\t/* COMMENT_9 */\n\t\tVAR_7 = *VAR_10->expression;\n\t\t/* COMMENT_10 */\n\t} else {\n\t\tVAR_7 = VAR_1->block;\n\t}\n\tVariableLocationKind VAR_11 = VAR_12;\n\tst64 VAR_8 = 0;\n\tut64 VAR_13 = 0;\n\tut64 VAR_14 = -1;\n\tconst char *VAR_15 = NULL; /* COMMENT_11 */\n\tsize_t VAR_16;\n\tfor (VAR_16 = 0; VAR_16 < VAR_7.length; VAR_16++) {\n\t\tswitch (VAR_7.data[VAR_16]) {\n\t\tcase VAR_17: {\n\t\t/* COMMENT_12 */\n                                                       \n\t\t\tif (VAR_16 == VAR_7.length - 1) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tconst ut8 *VAR_18 = &VAR_7.data[++VAR_16];\n\t\t\tVAR_8 = r_sleb128 (&VAR_18, &VAR_7.data[VAR_1->block.length]);\n\t\t\tif (VAR_2) {\n\t\t\t\t/* COMMENT_14 */\n                                                                                            \n\t\t\t\tVariableLocation *VAR_19 = parse_dwarf_location (VAR_0, VAR_2, NULL);\n\t\t\t\tif (VAR_19) {\n\t\t\t\t\tVAR_19->offset += VAR_8;\n\t\t\t\t\treturn VAR_19;\n\t\t\t\t}\n\t\t\t\treturn NULL;\n\t\t\t} else {\n\t\t\t\t/* COMMENT_16 */\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase VAR_20:\n\t\tcase VAR_21:\n\t\tcase VAR_22:\n\t\tcase VAR_23:\n\t\tcase VAR_24:\n\t\tcase VAR_25:\n\t\tcase VAR_26:\n\t\tcase VAR_27:\n\t\tcase VAR_28:\n\t\tcase VAR_29:\n\t\tcase VAR_30:\n\t\tcase VAR_31:\n\t\tcase VAR_32:\n\t\tcase VAR_33:\n\t\tcase VAR_34:\n\t\tcase VAR_35:\n\t\tcase VAR_36:\n\t\tcase VAR_37:\n\t\tcase VAR_38:\n\t\tcase VAR_39:\n\t\tcase VAR_40:\n\t\tcase VAR_41:\n\t\tcase VAR_42:\n\t\tcase VAR_43:\n\t\tcase VAR_44:\n\t\tcase VAR_45:\n\t\tcase VAR_46:\n\t\tcase VAR_47:\n\t\tcase VAR_48:\n\t\tcase VAR_49:\n\t\tcase VAR_50:\n\t\tcase VAR_51: {\n\t\t\t/* COMMENT_17 */\n\t\t\t/* COMMENT_18 */\n\t\t\tVAR_14 = VAR_7.data[VAR_16] - VAR_20; /* COMMENT_19 */\n\t\t\tVAR_15 = get_dwarf_reg_name (VAR_0->anal->cpu, VAR_14, &VAR_11, VAR_0->anal->bits);\n\t\t\tbreak;\n\t\t}\n\t\tcase VAR_52:\n\t\tcase VAR_53:\n\t\tcase VAR_54:\n\t\tcase VAR_55:\n\t\tcase VAR_56:\n\t\tcase VAR_57:\n\t\tcase VAR_58:\n\t\tcase VAR_59:\n\t\tcase VAR_60:\n\t\tcase VAR_61:\n\t\tcase VAR_62:\n\t\tcase VAR_63:\n\t\tcase VAR_64:\n\t\tcase VAR_65:\n\t\tcase VAR_66:\n\t\tcase VAR_67:\n\t\tcase VAR_68:\n\t\tcase VAR_69:\n\t\tcase VAR_70:\n\t\tcase VAR_71:\n\t\tcase VAR_72:\n\t\tcase VAR_73:\n\t\tcase VAR_74:\n\t\tcase VAR_75:\n\t\tcase VAR_76:\n\t\tcase VAR_77:\n\t\tcase VAR_78:\n\t\tcase VAR_79:\n\t\tcase VAR_80:\n\t\tcase VAR_81:\n\t\tcase VAR_82:\n\t\tcase VAR_83: {\n\t\t\tif (VAR_16 == VAR_7.length - 1) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\t/* COMMENT_20 */\n                                                        \n\t\t\tVAR_14 = VAR_7.data[VAR_16] - VAR_52; /* COMMENT_19 */\n\t\t\tconst ut8 *VAR_84 = &VAR_7.data[++VAR_16];\n\t\t\tVAR_8 = r_sleb128 (&VAR_84, &VAR_7.data[VAR_7.length]);\n\t\t\t/* COMMENT_22 */\n\t\t\tVAR_16 += VAR_84 - &VAR_7.data[0];\n\t\t\tVAR_15 = get_dwarf_reg_name (VAR_0->anal->cpu, VAR_14, &VAR_11, VAR_0->anal->bits);\n\t\t\tbreak;\n\t\t}\n\t\tcase VAR_85: {\n\t\t\tif (VAR_16 == VAR_7.length - 1) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\t/* COMMENT_23 */\n\t\t\t/* COMMENT_24 */\n\t\t\tconst ut8 *VAR_84 = &VAR_7.data[++VAR_16];\n\t\t\tconst ut8 *VAR_86 = &VAR_7.data[VAR_7.length];\n\t\t\tVAR_84 = r_uleb128 (VAR_84, VAR_86 - VAR_84, &VAR_14, NULL);\n\t\t\tif (VAR_84 == VAR_86) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tVAR_8 = r_sleb128 (&VAR_84, VAR_86);\n\t\t\tVAR_15 = get_dwarf_reg_name (VAR_0->anal->cpu, VAR_14, &VAR_11, VAR_0->anal->bits);\n\t\t\tbreak;\n\t\t}\n\t\tcase VAR_87: {\n\t\t\t/* COMMENT_25 */\n                                                            \n\t\t\tconst int VAR_88 = VAR_0->anal->bits / 8;\n\t\t\tconst ut8 *VAR_18 = &VAR_7.data[++VAR_16];\n\t\t\t/* COMMENT_27 */\n\t\t\tif (VAR_7.length - VAR_16 < VAR_88) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tswitch (VAR_88) {\n\t\t\tcase 1:\n\t\t\t\tVAR_13 = r_read_ble8 (VAR_18);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tVAR_13 = r_read_ble16 (VAR_18, VAR_0->anal->big_endian);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tVAR_13 = r_read_ble32 (VAR_18, VAR_0->anal->big_endian);\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\tVAR_13 = r_read_ble64 (VAR_18, VAR_0->anal->big_endian);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tr_warn_if_reached (); /* COMMENT_28 */\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tVAR_11 = VAR_89; /* COMMENT_29 */\n\t\t\tbreak;\n\t\t}\n\t\tcase VAR_90: {\n\t\t\t/* COMMENT_30 */\n\t\t\tVAR_11 = VAR_91;\n\t\t\tVAR_8 += 16;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (VAR_11 == VAR_12) {\n\t\treturn NULL;\n\t}\n\tVariableLocation *VAR_19 = R_NEW0 (VariableLocation);\n\tif (VAR_19) {\n\t\tVAR_19->reg_name = VAR_15;\n\t\tVAR_19->reg_num = VAR_14;\n\t\tVAR_19->kind = VAR_11;\n\t\tVAR_19->offset = VAR_8;\n\t\tVAR_19->address = VAR_13;\n\t}\n\treturn VAR_19;\n}",
  "func_graph_path_before": "radareorg/radare2/637f4bd1af6752e28e0a9998e954e2e9ce6fa992/dwarf_process.c/vul/before/0.json",
  "func": "static VariableLocation *parse_dwarf_location (Context *ctx, const RBinDwarfAttrValue *loc, const RBinDwarfAttrValue *frame_base) {\n\t/* reg5 - val is in register 5\n\tfbreg <leb> - offset from frame base\n\tregx <leb> - contents is in register X\n\taddr <addr> - contents is in at addr\n\tbregXX <leb> - contents is at offset from specified register\n\t- we now support 3 options: SP, BP and register based arguments */\n\n\t/* Loclist offset is usually CONSTANT or REFERENCE at older DWARF versions, new one has LocListPtr for that */\n\tif (loc->kind != DW_AT_KIND_BLOCK && loc->kind != DW_AT_KIND_LOCLISTPTR && loc->kind != DW_AT_KIND_REFERENCE && loc->kind != DW_AT_KIND_CONSTANT) {\n\t\treturn NULL;\n\t}\n\tRBinDwarfBlock block;\n\tif (loc->kind == DW_AT_KIND_LOCLISTPTR || loc->kind == DW_AT_KIND_REFERENCE || loc->kind == DW_AT_KIND_CONSTANT) {\n\t\tut64 offset = loc->reference;\n\t\tRBinDwarfLocList *range_list = ht_up_find (ctx->locations, offset, NULL);\n\t\tif (!range_list) { /* for some reason offset isn't there, wrong parsing or malformed dwarf */\n\t\t\treturn NULL;\n\t\t}\n\t\t/* use the largest range as a variable */\n\t\tRBinDwarfLocRange *range = find_largest_loc_range (range_list->list);\n\t\tif (!range) {\n\t\t\treturn NULL;\n\t\t}\n\t\t/* Very rough and sloppy, refactor this hacked up stuff */\n\t\tblock = *range->expression;\n\t\t// range->expression... etc\n\t} else {\n\t\tblock = loc->block;\n\t}\n\tVariableLocationKind kind = LOCATION_UNKNOWN;\n\tst64 offset = 0;\n\tut64 address = 0;\n\tut64 reg_num = -1;\n\tconst char *reg_name = NULL; /* literal */\n\tsize_t i;\n\tfor (i = 0; i < block.length; i++) {\n\t\tswitch (block.data[i]) {\n\t\tcase DW_OP_fbreg: {\n\t\t\t/* TODO sometimes CFA is referenced, but we don't parse that yet\n\t\t\t   just an offset involving framebase of a function*/\n\t\t\tif (i == block.length - 1) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ti++;\n\t\t\tconst ut8 *dump = block.data + i;\n\t\t\tif (loc->block.length > block.length) {\n\t\t\t\t// eprintf (\"skip = %d%c\", loc->block.length, 10);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\toffset = r_sleb128 (&dump, block.data + loc->block.length);\n\t\t\tif (frame_base) {\n\t\t\t\t/* recursive parsing, but frame_base should be only one, but someone\n\t\t\t\t   could make malicious resource exhaustion attack, so a depth counter might be cool? */\n\t\t\t\tVariableLocation *location = parse_dwarf_location (ctx, frame_base, NULL);\n\t\t\t\tif (location) {\n\t\t\t\t\tlocation->offset += offset;\n\t\t\t\t\treturn location;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* Might happen if frame_base has a frame_base reference? I don't think it can tho */\n\t\t\t}\n\t\t\treturn NULL;\n\t\t}\n\t\tcase DW_OP_reg0:\n\t\tcase DW_OP_reg1:\n\t\tcase DW_OP_reg2:\n\t\tcase DW_OP_reg3:\n\t\tcase DW_OP_reg4:\n\t\tcase DW_OP_reg5:\n\t\tcase DW_OP_reg6:\n\t\tcase DW_OP_reg7:\n\t\tcase DW_OP_reg8:\n\t\tcase DW_OP_reg9:\n\t\tcase DW_OP_reg10:\n\t\tcase DW_OP_reg11:\n\t\tcase DW_OP_reg12:\n\t\tcase DW_OP_reg13:\n\t\tcase DW_OP_reg14:\n\t\tcase DW_OP_reg15:\n\t\tcase DW_OP_reg16:\n\t\tcase DW_OP_reg17:\n\t\tcase DW_OP_reg18:\n\t\tcase DW_OP_reg19:\n\t\tcase DW_OP_reg20:\n\t\tcase DW_OP_reg21:\n\t\tcase DW_OP_reg22:\n\t\tcase DW_OP_reg23:\n\t\tcase DW_OP_reg24:\n\t\tcase DW_OP_reg25:\n\t\tcase DW_OP_reg26:\n\t\tcase DW_OP_reg27:\n\t\tcase DW_OP_reg28:\n\t\tcase DW_OP_reg29:\n\t\tcase DW_OP_reg30:\n\t\tcase DW_OP_reg31: {\n\t\t\t/* Will mostly be used for SP based arguments */\n\t\t\t/* TODO I need to find binaries that uses this so I can test it out*/\n\t\t\treg_num = block.data[i] - DW_OP_reg0; // get the reg number\n\t\t\treg_name = get_dwarf_reg_name (ctx->anal->cpu, reg_num, &kind, ctx->anal->bits);\n\t\t\tbreak;\n\t\t}\n\t\tcase DW_OP_breg0:\n\t\tcase DW_OP_breg1:\n\t\tcase DW_OP_breg2:\n\t\tcase DW_OP_breg3:\n\t\tcase DW_OP_breg4:\n\t\tcase DW_OP_breg5:\n\t\tcase DW_OP_breg6:\n\t\tcase DW_OP_breg7:\n\t\tcase DW_OP_breg8:\n\t\tcase DW_OP_breg9:\n\t\tcase DW_OP_breg10:\n\t\tcase DW_OP_breg11:\n\t\tcase DW_OP_breg12:\n\t\tcase DW_OP_breg13:\n\t\tcase DW_OP_breg14:\n\t\tcase DW_OP_breg15:\n\t\tcase DW_OP_breg16:\n\t\tcase DW_OP_breg17:\n\t\tcase DW_OP_breg18:\n\t\tcase DW_OP_breg19:\n\t\tcase DW_OP_breg20:\n\t\tcase DW_OP_breg21:\n\t\tcase DW_OP_breg22:\n\t\tcase DW_OP_breg23:\n\t\tcase DW_OP_breg24:\n\t\tcase DW_OP_breg25:\n\t\tcase DW_OP_breg26:\n\t\tcase DW_OP_breg27:\n\t\tcase DW_OP_breg28:\n\t\tcase DW_OP_breg29:\n\t\tcase DW_OP_breg30:\n\t\tcase DW_OP_breg31: {\n\t\t\tif (i == block.length - 1) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\t/* The single operand of the DW_OP_bregn operations provides\n\t\t\tsigned LEB128 offset from the specified register.  */\n\t\t\treg_num = block.data[i] - DW_OP_breg0; // get the reg number\n\t\t\tconst ut8 *buffer = &block.data[++i];\n\t\t\toffset = r_sleb128 (&buffer, &block.data[block.length]);\n\t\t\t/* TODO do a proper expression parsing, move by the amount of bytes sleb reads */\n\t\t\ti += buffer - &block.data[0];\n\t\t\treg_name = get_dwarf_reg_name (ctx->anal->cpu, reg_num, &kind, ctx->anal->bits);\n\t\t\tbreak;\n\t\t}\n\t\tcase DW_OP_bregx: {\n\t\t\tif (i == block.length - 1) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\t/* 2 operands, reg_number, offset*/\n\t\t\t/* I need to find binaries that uses this so I can test it out*/\n\t\t\tconst ut8 *buffer = &block.data[++i];\n\t\t\tconst ut8 *buf_end = &block.data[block.length];\n\t\t\tbuffer = r_uleb128 (buffer, buf_end - buffer, &reg_num, NULL);\n\t\t\tif (buffer == buf_end) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\toffset = r_sleb128 (&buffer, buf_end);\n\t\t\treg_name = get_dwarf_reg_name (ctx->anal->cpu, reg_num, &kind, ctx->anal->bits);\n\t\t\tbreak;\n\t\t}\n\t\tcase DW_OP_addr: {\n\t\t\t/* The DW_OP_addr operation has a single operand that encodes a machine address and whose\n\t\t\tsize is the size of an address on the target machine.  */\n\t\t\tconst int addr_size = ctx->anal->bits / 8;\n\t\t\tconst ut8 *dump = &block.data[++i];\n\t\t\t/* malformed, not enough bytes to represent address */\n\t\t\tif (block.length - i < addr_size) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tswitch (addr_size) {\n\t\t\tcase 1:\n\t\t\t\taddress = r_read_ble8 (dump);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\taddress = r_read_ble16 (dump, ctx->anal->big_endian);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\taddress = r_read_ble32 (dump, ctx->anal->big_endian);\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\taddress = r_read_ble64 (dump, ctx->anal->big_endian);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tr_warn_if_reached (); /* weird addr_size */\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tkind = LOCATION_GLOBAL; // address\n\t\t\tbreak;\n\t\t}\n\t\tcase DW_OP_call_frame_cfa: {\n\t\t\t// REMOVE XXX\n\t\t\tkind = LOCATION_BP;\n\t\t\toffset += 16;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (kind == LOCATION_UNKNOWN) {\n\t\treturn NULL;\n\t}\n\tVariableLocation *location = R_NEW0 (VariableLocation);\n\tif (location) {\n\t\tlocation->reg_name = reg_name;\n\t\tlocation->reg_num = reg_num;\n\t\tlocation->kind = kind;\n\t\tlocation->offset = offset;\n\t\tlocation->address = address;\n\t}\n\treturn location;\n}",
  "abstract_func": "static VariableLocation *parse_dwarf_location (Context *VAR_0, const RBinDwarfAttrValue *VAR_1, const RBinDwarfAttrValue *VAR_2) {\n\t/* COMMENT_0 */\n                                     \n                                       \n                                     \n                                                             \n                                                                   \n\n\t/* COMMENT_6 */\n\tif (VAR_1->kind != VAR_3 && VAR_1->kind != VAR_4 && VAR_1->kind != VAR_5 && VAR_1->kind != VAR_6) {\n\t\treturn NULL;\n\t}\n\tRBinDwarfBlock VAR_7;\n\tif (VAR_1->kind == VAR_4 || VAR_1->kind == VAR_5 || VAR_1->kind == VAR_6) {\n\t\tut64 VAR_8 = VAR_1->reference;\n\t\tRBinDwarfLocList *VAR_9 = ht_up_find (VAR_0->locations, VAR_8, NULL);\n\t\tif (!VAR_9) { /* COMMENT_7 */\n\t\t\treturn NULL;\n\t\t}\n\t\t/* COMMENT_8 */\n\t\tRBinDwarfLocRange *VAR_10 = find_largest_loc_range (VAR_9->list);\n\t\tif (!VAR_10) {\n\t\t\treturn NULL;\n\t\t}\n\t\t/* COMMENT_9 */\n\t\tVAR_7 = *VAR_10->expression;\n\t\t/* COMMENT_10 */\n\t} else {\n\t\tVAR_7 = VAR_1->block;\n\t}\n\tVariableLocationKind VAR_11 = VAR_12;\n\tst64 VAR_8 = 0;\n\tut64 VAR_13 = 0;\n\tut64 VAR_14 = -1;\n\tconst char *VAR_15 = NULL; /* COMMENT_11 */\n\tsize_t VAR_16;\n\tfor (VAR_16 = 0; VAR_16 < VAR_7.length; VAR_16++) {\n\t\tswitch (VAR_7.data[VAR_16]) {\n\t\tcase VAR_17: {\n\t\t\t/* COMMENT_12 */\n                                                        \n\t\t\tif (VAR_16 == VAR_7.length - 1) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tVAR_16++;\n\t\t\tconst ut8 *VAR_18 = VAR_7.data + VAR_16;\n\t\t\tif (VAR_1->block.length > VAR_7.length) {\n\t\t\t\t/* COMMENT_14 */\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tVAR_8 = r_sleb128 (&VAR_18, VAR_7.data + VAR_1->block.length);\n\t\t\tif (VAR_2) {\n\t\t\t\t/* COMMENT_15 */\n                                                                                            \n\t\t\t\tVariableLocation *VAR_19 = parse_dwarf_location (VAR_0, VAR_2, NULL);\n\t\t\t\tif (VAR_19) {\n\t\t\t\t\tVAR_19->offset += VAR_8;\n\t\t\t\t\treturn VAR_19;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* COMMENT_17 */\n\t\t\t}\n\t\t\treturn NULL;\n\t\t}\n\t\tcase VAR_20:\n\t\tcase VAR_21:\n\t\tcase VAR_22:\n\t\tcase VAR_23:\n\t\tcase VAR_24:\n\t\tcase VAR_25:\n\t\tcase VAR_26:\n\t\tcase VAR_27:\n\t\tcase VAR_28:\n\t\tcase VAR_29:\n\t\tcase VAR_30:\n\t\tcase VAR_31:\n\t\tcase VAR_32:\n\t\tcase VAR_33:\n\t\tcase VAR_34:\n\t\tcase VAR_35:\n\t\tcase VAR_36:\n\t\tcase VAR_37:\n\t\tcase VAR_38:\n\t\tcase VAR_39:\n\t\tcase VAR_40:\n\t\tcase VAR_41:\n\t\tcase VAR_42:\n\t\tcase VAR_43:\n\t\tcase VAR_44:\n\t\tcase VAR_45:\n\t\tcase VAR_46:\n\t\tcase VAR_47:\n\t\tcase VAR_48:\n\t\tcase VAR_49:\n\t\tcase VAR_50:\n\t\tcase VAR_51: {\n\t\t\t/* COMMENT_18 */\n\t\t\t/* COMMENT_19 */\n\t\t\tVAR_14 = VAR_7.data[VAR_16] - VAR_20; /* COMMENT_20 */\n\t\t\tVAR_15 = get_dwarf_reg_name (VAR_0->anal->cpu, VAR_14, &VAR_11, VAR_0->anal->bits);\n\t\t\tbreak;\n\t\t}\n\t\tcase VAR_52:\n\t\tcase VAR_53:\n\t\tcase VAR_54:\n\t\tcase VAR_55:\n\t\tcase VAR_56:\n\t\tcase VAR_57:\n\t\tcase VAR_58:\n\t\tcase VAR_59:\n\t\tcase VAR_60:\n\t\tcase VAR_61:\n\t\tcase VAR_62:\n\t\tcase VAR_63:\n\t\tcase VAR_64:\n\t\tcase VAR_65:\n\t\tcase VAR_66:\n\t\tcase VAR_67:\n\t\tcase VAR_68:\n\t\tcase VAR_69:\n\t\tcase VAR_70:\n\t\tcase VAR_71:\n\t\tcase VAR_72:\n\t\tcase VAR_73:\n\t\tcase VAR_74:\n\t\tcase VAR_75:\n\t\tcase VAR_76:\n\t\tcase VAR_77:\n\t\tcase VAR_78:\n\t\tcase VAR_79:\n\t\tcase VAR_80:\n\t\tcase VAR_81:\n\t\tcase VAR_82:\n\t\tcase VAR_83: {\n\t\t\tif (VAR_16 == VAR_7.length - 1) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\t/* COMMENT_21 */\n                                                        \n\t\t\tVAR_14 = VAR_7.data[VAR_16] - VAR_52; /* COMMENT_20 */\n\t\t\tconst ut8 *VAR_84 = &VAR_7.data[++VAR_16];\n\t\t\tVAR_8 = r_sleb128 (&VAR_84, &VAR_7.data[VAR_7.length]);\n\t\t\t/* COMMENT_23 */\n\t\t\tVAR_16 += VAR_84 - &VAR_7.data[0];\n\t\t\tVAR_15 = get_dwarf_reg_name (VAR_0->anal->cpu, VAR_14, &VAR_11, VAR_0->anal->bits);\n\t\t\tbreak;\n\t\t}\n\t\tcase VAR_85: {\n\t\t\tif (VAR_16 == VAR_7.length - 1) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\t/* COMMENT_24 */\n\t\t\t/* COMMENT_25 */\n\t\t\tconst ut8 *VAR_84 = &VAR_7.data[++VAR_16];\n\t\t\tconst ut8 *VAR_86 = &VAR_7.data[VAR_7.length];\n\t\t\tVAR_84 = r_uleb128 (VAR_84, VAR_86 - VAR_84, &VAR_14, NULL);\n\t\t\tif (VAR_84 == VAR_86) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tVAR_8 = r_sleb128 (&VAR_84, VAR_86);\n\t\t\tVAR_15 = get_dwarf_reg_name (VAR_0->anal->cpu, VAR_14, &VAR_11, VAR_0->anal->bits);\n\t\t\tbreak;\n\t\t}\n\t\tcase VAR_87: {\n\t\t\t/* COMMENT_26 */\n                                                            \n\t\t\tconst int VAR_88 = VAR_0->anal->bits / 8;\n\t\t\tconst ut8 *VAR_18 = &VAR_7.data[++VAR_16];\n\t\t\t/* COMMENT_28 */\n\t\t\tif (VAR_7.length - VAR_16 < VAR_88) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tswitch (VAR_88) {\n\t\t\tcase 1:\n\t\t\t\tVAR_13 = r_read_ble8 (VAR_18);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tVAR_13 = r_read_ble16 (VAR_18, VAR_0->anal->big_endian);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tVAR_13 = r_read_ble32 (VAR_18, VAR_0->anal->big_endian);\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\tVAR_13 = r_read_ble64 (VAR_18, VAR_0->anal->big_endian);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tr_warn_if_reached (); /* COMMENT_29 */\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tVAR_11 = VAR_89; /* COMMENT_30 */\n\t\t\tbreak;\n\t\t}\n\t\tcase VAR_90: {\n\t\t\t/* COMMENT_31 */\n\t\t\tVAR_11 = VAR_91;\n\t\t\tVAR_8 += 16;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (VAR_11 == VAR_12) {\n\t\treturn NULL;\n\t}\n\tVariableLocation *VAR_19 = R_NEW0 (VariableLocation);\n\tif (VAR_19) {\n\t\tVAR_19->reg_name = VAR_15;\n\t\tVAR_19->reg_num = VAR_14;\n\t\tVAR_19->kind = VAR_11;\n\t\tVAR_19->offset = VAR_8;\n\t\tVAR_19->address = VAR_13;\n\t}\n\treturn VAR_19;\n}",
  "func_graph_path": "radareorg/radare2/637f4bd1af6752e28e0a9998e954e2e9ce6fa992/dwarf_process.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -37,13 +37,18 @@\n \tfor (i = 0; i < block.length; i++) {\n \t\tswitch (block.data[i]) {\n \t\tcase DW_OP_fbreg: {\n-\t\t/* TODO sometimes CFA is referenced, but we don't parse that yet\n-\t\t   just an offset involving framebase of a function*/\n+\t\t\t/* TODO sometimes CFA is referenced, but we don't parse that yet\n+\t\t\t   just an offset involving framebase of a function*/\n \t\t\tif (i == block.length - 1) {\n \t\t\t\treturn NULL;\n \t\t\t}\n-\t\t\tconst ut8 *dump = &block.data[++i];\n-\t\t\toffset = r_sleb128 (&dump, &block.data[loc->block.length]);\n+\t\t\ti++;\n+\t\t\tconst ut8 *dump = block.data + i;\n+\t\t\tif (loc->block.length > block.length) {\n+\t\t\t\t// eprintf (\"skip = %d%c\", loc->block.length, 10);\n+\t\t\t\treturn NULL;\n+\t\t\t}\n+\t\t\toffset = r_sleb128 (&dump, block.data + loc->block.length);\n \t\t\tif (frame_base) {\n \t\t\t\t/* recursive parsing, but frame_base should be only one, but someone\n \t\t\t\t   could make malicious resource exhaustion attack, so a depth counter might be cool? */\n@@ -52,12 +57,10 @@\n \t\t\t\t\tlocation->offset += offset;\n \t\t\t\t\treturn location;\n \t\t\t\t}\n-\t\t\t\treturn NULL;\n \t\t\t} else {\n \t\t\t\t/* Might happen if frame_base has a frame_base reference? I don't think it can tho */\n-\t\t\t\treturn NULL;\n-\t\t\t}\n-\t\t\tbreak;\n+\t\t\t}\n+\t\t\treturn NULL;\n \t\t}\n \t\tcase DW_OP_reg0:\n \t\tcase DW_OP_reg1:",
  "diff_line_info": {
    "deleted_lines": [
      "\t\t/* TODO sometimes CFA is referenced, but we don't parse that yet",
      "\t\t   just an offset involving framebase of a function*/",
      "\t\t\tconst ut8 *dump = &block.data[++i];",
      "\t\t\toffset = r_sleb128 (&dump, &block.data[loc->block.length]);",
      "\t\t\t\treturn NULL;",
      "\t\t\t\treturn NULL;",
      "\t\t\t}",
      "\t\t\tbreak;"
    ],
    "added_lines": [
      "\t\t\t/* TODO sometimes CFA is referenced, but we don't parse that yet",
      "\t\t\t   just an offset involving framebase of a function*/",
      "\t\t\ti++;",
      "\t\t\tconst ut8 *dump = block.data + i;",
      "\t\t\tif (loc->block.length > block.length) {",
      "\t\t\t\t// eprintf (\"skip = %d%c\", loc->block.length, 10);",
      "\t\t\t\treturn NULL;",
      "\t\t\t}",
      "\t\t\toffset = r_sleb128 (&dump, block.data + loc->block.length);",
      "\t\t\t}",
      "\t\t\treturn NULL;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/radareorg/radare2/pull/19349",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/radareorg/radare2/pull/19349: 403 Client Error: Forbidden for url: https://api.github.com/repos/radareorg/radare2/pulls/19349",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "The patch addresses an out-of-bounds read in the DWARF parser, which is a security vulnerability. The code changes add boundary checks to prevent crashes, confirming this as a security fix.\n\n**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.9"
}