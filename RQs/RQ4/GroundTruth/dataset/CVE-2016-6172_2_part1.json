{
  "cve_id": "CVE-2016-6172",
  "cwe_ids": [
    "CWE-400"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:C",
  "cvss_is_v3": false,
  "repo_name": "PowerDNS/pdns",
  "commit_msg": "Add limits to the size of received AXFR, in megabytes\n\nThis prevents resource exhaustion in case the master is sending a\nvery large amount of data in an update.",
  "commit_hash": "a014f4c224a7b21f1c648257d1fd1128413129aa",
  "git_url": "https://github.com/PowerDNS/pdns/commit/a014f4c224a7b21f1c648257d1fd1128413129aa",
  "file_path": "pdns/resolver.cc",
  "func_name": "AXFRRetriever::getChunk",
  "func_before": "int AXFRRetriever::getChunk(Resolver::res_t &res) // Implementation is making sure RFC2845 4.4 is followed.\n{\n  if(d_soacount > 1)\n    return false;\n\n  // d_sock is connected and is about to spit out a packet\n  int len=getLength();\n  if(len<0)\n    throw ResolverException(\"EOF trying to read axfr chunk from remote TCP client\");\n  \n  timeoutReadn(len); \n  MOADNSParser mdp(d_buf.get(), len);\n\n  int err = parseResult(mdp, \"\", 0, 0, &res);\n  if(err) \n    throw ResolverException(\"AXFR chunk error: \" + RCode::to_s(err));\n\n  BOOST_FOREACH(const MOADNSParser::answers_t::value_type& answer, mdp.d_answers)\n    if (answer.first.d_type == QType::SOA)\n      d_soacount++;\n \n  if(!d_tsigkeyname.empty()) { // TSIG verify message\n    // If we have multiple messages, we need to concatenate them together. We also need to make sure we know the location of \n    // the TSIG record so we can remove it in makeTSIGMessageFromTSIGPacket\n    d_signData.append(d_buf.get(), len);\n    if (mdp.getTSIGPos() == 0)\n      d_tsigPos += len;\n    else \n      d_tsigPos += mdp.getTSIGPos();\n\n    string theirMac;\n    bool checkTSIG = false;\n    \n    BOOST_FOREACH(const MOADNSParser::answers_t::value_type& answer, mdp.d_answers) {\n      if (answer.first.d_type == QType::SOA)  // A SOA is either the first or the last record. We need to check TSIG if that's the case.\n        checkTSIG = true;\n      \n      if(answer.first.d_type == QType::TSIG) {\n        shared_ptr<TSIGRecordContent> trc = boost::dynamic_pointer_cast<TSIGRecordContent>(answer.first.d_content);\n        theirMac = trc->d_mac;\n        d_trc.d_time = trc->d_time;\n        checkTSIG = true;\n      }\n    }\n\n    if( ! checkTSIG && d_nonSignedMessages > 99) { // We're allowed to get 100 digest without a TSIG.\n      throw ResolverException(\"No TSIG message received in last 100 messages of AXFR transfer.\");\n    }\n\n    if (checkTSIG) {\n      if (theirMac.empty())\n        throw ResolverException(\"No TSIG on AXFR response from \"+d_remote.toStringWithPort()+\" , should be signed with TSIG key '\"+d_tsigkeyname+\"'\");\n\n      string message;\n      if (!d_prevMac.empty()) {\n        message = makeTSIGMessageFromTSIGPacket(d_signData, d_tsigPos, d_tsigkeyname, d_trc, d_prevMac, true, d_signData.size()-len);\n      } else {\n        message = makeTSIGMessageFromTSIGPacket(d_signData, d_tsigPos, d_tsigkeyname, d_trc, d_trc.d_mac, false);\n      }\n\n      TSIGHashEnum algo;\n      if (!getTSIGHashEnum(d_trc.d_algoName, algo)) {\n        throw ResolverException(\"Unsupported TSIG HMAC algorithm \" + d_trc.d_algoName);\n      }\n\n      string ourMac=calculateHMAC(d_tsigsecret, message, algo);\n\n      // ourMac[0]++; // sabotage == for testing :-)\n      if(ourMac != theirMac) {\n        throw ResolverException(\"Signature failed to validate on AXFR response from \"+d_remote.toStringWithPort()+\" signed with TSIG key '\"+d_tsigkeyname+\"'\");\n      }\n\n      // Reset and store some values for the next chunks. \n      d_prevMac = theirMac;\n      d_nonSignedMessages = 0;\n      d_signData.clear();\n      d_tsigPos = 0;\n    }\n    else\n      d_nonSignedMessages++;\n  }\n  \n  return true;\n}",
  "abstract_func_before": "int AXFRRetriever::getChunk(Resolver::res_t &VAR_0) /* COMMENT_0 */\n{\n  if(VAR_1 > 1)\n    return false;\n\n  /* COMMENT_1 */\n  int VAR_2=getLength();\n  if(VAR_2<0)\n    throw ResolverException(\"EOF trying to read axfr chunk from remote TCP client\");\n  \n  timeoutReadn(VAR_2); \n  MOADNSParser VAR_3(VAR_4.get(), VAR_2);\n\n  int VAR_5 = parseResult(VAR_3, \"\", 0, 0, &VAR_0);\n  if(VAR_5) \n    throw ResolverException(\"AXFR chunk error: \" + RCode::to_s(VAR_5));\n\n  BOOST_FOREACH(const MOADNSParser::answers_t::value_type& VAR_6, mdp.VAR_7)\n    if (VAR_6.first.d_type == QType::SOA)\n      VAR_1++;\n \n  if(!VAR_8.empty()) { /* COMMENT_2 */\n    /* COMMENT_3 */\n    /* COMMENT_4 */\n    VAR_9.append(VAR_4.get(), VAR_2);\n    if (mdp.getTSIGPos() == 0)\n      VAR_10 += VAR_2;\n    else \n      VAR_10 += mdp.getTSIGPos();\n\n    string VAR_11;\n    bool VAR_12 = false;\n    \n    BOOST_FOREACH(const MOADNSParser::answers_t::value_type& VAR_6, mdp.VAR_7) {\n      if (VAR_6.first.d_type == QType::SOA)  /* COMMENT_5 */\n        VAR_12 = true;\n      \n      if(VAR_6.first.d_type == QType::TSIG) {\n        shared_ptr<TSIGRecordContent> VAR_13 = boost::VAR_14<TSIGRecordContent>(VAR_6.first.d_content);\n        VAR_11 = VAR_13->d_mac;\n        VAR_15.d_time = VAR_13->d_time;\n        VAR_12 = true;\n      }\n    }\n\n    if( ! VAR_12 && VAR_16 > 99) { /* COMMENT_6 */\n      throw ResolverException(\"No TSIG message received in last 100 messages of AXFR transfer.\");\n    }\n\n    if (VAR_12) {\n      if (VAR_11.empty())\n        throw ResolverException(\"No TSIG on AXFR response from \"+VAR_17.toStringWithPort()+\" , should be signed with TSIG key '\"+VAR_8+\"'\");\n\n      string VAR_18;\n      if (!VAR_19.empty()) {\n        VAR_18 = makeTSIGMessageFromTSIGPacket(VAR_9, VAR_10, VAR_8, VAR_15, VAR_19, true, VAR_9.size()-VAR_2);\n      } else {\n        VAR_18 = makeTSIGMessageFromTSIGPacket(VAR_9, VAR_10, VAR_8, VAR_15, VAR_15.d_mac, false);\n      }\n\n      TSIGHashEnum VAR_20;\n      if (!getTSIGHashEnum(VAR_15.d_algoName, VAR_20)) {\n        throw ResolverException(\"Unsupported TSIG HMAC algorithm \" + VAR_15.d_algoName);\n      }\n\n      string VAR_21=calculateHMAC(VAR_22, VAR_18, VAR_20);\n\n      /* COMMENT_7 */\n      if(VAR_21 != VAR_11) {\n        throw ResolverException(\"Signature failed to validate on AXFR response from \"+VAR_17.toStringWithPort()+\" signed with TSIG key '\"+VAR_8+\"'\");\n      }\n\n      /* COMMENT_8 */\n      VAR_19 = VAR_11;\n      VAR_16 = 0;\n      VAR_9.clear();\n      VAR_10 = 0;\n    }\n    else\n      VAR_16++;\n  }\n  \n  return true;\n}",
  "func_graph_path_before": "PowerDNS/pdns/a014f4c224a7b21f1c648257d1fd1128413129aa/resolver.cc/vul/before/1.json",
  "func": "int AXFRRetriever::getChunk(Resolver::res_t &res) // Implementation is making sure RFC2845 4.4 is followed.\n{\n  if(d_soacount > 1)\n    return false;\n\n  // d_sock is connected and is about to spit out a packet\n  int len=getLength();\n  if(len<0)\n    throw ResolverException(\"EOF trying to read axfr chunk from remote TCP client\");\n\n  if (d_maxReceivedBytes > 0 && (d_maxReceivedBytes - d_receivedBytes) < (size_t) len)\n    throw ResolverException(\"Reached the maximum number of received bytes during AXFR\");\n\n  timeoutReadn(len);\n\n  d_receivedBytes += (uint16_t) len;\n\n  MOADNSParser mdp(d_buf.get(), len);\n\n  int err = parseResult(mdp, \"\", 0, 0, &res);\n  if(err) \n    throw ResolverException(\"AXFR chunk error: \" + RCode::to_s(err));\n\n  BOOST_FOREACH(const MOADNSParser::answers_t::value_type& answer, mdp.d_answers)\n    if (answer.first.d_type == QType::SOA)\n      d_soacount++;\n \n  if(!d_tsigkeyname.empty()) { // TSIG verify message\n    // If we have multiple messages, we need to concatenate them together. We also need to make sure we know the location of \n    // the TSIG record so we can remove it in makeTSIGMessageFromTSIGPacket\n    d_signData.append(d_buf.get(), len);\n    if (mdp.getTSIGPos() == 0)\n      d_tsigPos += len;\n    else \n      d_tsigPos += mdp.getTSIGPos();\n\n    string theirMac;\n    bool checkTSIG = false;\n    \n    BOOST_FOREACH(const MOADNSParser::answers_t::value_type& answer, mdp.d_answers) {\n      if (answer.first.d_type == QType::SOA)  // A SOA is either the first or the last record. We need to check TSIG if that's the case.\n        checkTSIG = true;\n      \n      if(answer.first.d_type == QType::TSIG) {\n        shared_ptr<TSIGRecordContent> trc = boost::dynamic_pointer_cast<TSIGRecordContent>(answer.first.d_content);\n        theirMac = trc->d_mac;\n        d_trc.d_time = trc->d_time;\n        checkTSIG = true;\n      }\n    }\n\n    if( ! checkTSIG && d_nonSignedMessages > 99) { // We're allowed to get 100 digest without a TSIG.\n      throw ResolverException(\"No TSIG message received in last 100 messages of AXFR transfer.\");\n    }\n\n    if (checkTSIG) {\n      if (theirMac.empty())\n        throw ResolverException(\"No TSIG on AXFR response from \"+d_remote.toStringWithPort()+\" , should be signed with TSIG key '\"+d_tsigkeyname+\"'\");\n\n      string message;\n      if (!d_prevMac.empty()) {\n        message = makeTSIGMessageFromTSIGPacket(d_signData, d_tsigPos, d_tsigkeyname, d_trc, d_prevMac, true, d_signData.size()-len);\n      } else {\n        message = makeTSIGMessageFromTSIGPacket(d_signData, d_tsigPos, d_tsigkeyname, d_trc, d_trc.d_mac, false);\n      }\n\n      TSIGHashEnum algo;\n      if (!getTSIGHashEnum(d_trc.d_algoName, algo)) {\n        throw ResolverException(\"Unsupported TSIG HMAC algorithm \" + d_trc.d_algoName);\n      }\n\n      string ourMac=calculateHMAC(d_tsigsecret, message, algo);\n\n      // ourMac[0]++; // sabotage == for testing :-)\n      if(ourMac != theirMac) {\n        throw ResolverException(\"Signature failed to validate on AXFR response from \"+d_remote.toStringWithPort()+\" signed with TSIG key '\"+d_tsigkeyname+\"'\");\n      }\n\n      // Reset and store some values for the next chunks. \n      d_prevMac = theirMac;\n      d_nonSignedMessages = 0;\n      d_signData.clear();\n      d_tsigPos = 0;\n    }\n    else\n      d_nonSignedMessages++;\n  }\n  \n  return true;\n}",
  "abstract_func": "int AXFRRetriever::getChunk(Resolver::res_t &VAR_0) /* COMMENT_0 */\n{\n  if(VAR_1 > 1)\n    return false;\n\n  /* COMMENT_1 */\n  int VAR_2=getLength();\n  if(VAR_2<0)\n    throw ResolverException(\"EOF trying to read axfr chunk from remote TCP client\");\n\n  if (VAR_3 > 0 && (VAR_3 - VAR_4) < (size_t) VAR_2)\n    throw ResolverException(\"Reached the maximum number of received bytes during AXFR\");\n\n  timeoutReadn(VAR_2);\n\n  VAR_4 += (uint16_t) VAR_2;\n\n  MOADNSParser VAR_5(VAR_6.get(), VAR_2);\n\n  int VAR_7 = parseResult(VAR_5, \"\", 0, 0, &VAR_0);\n  if(VAR_7) \n    throw ResolverException(\"AXFR chunk error: \" + RCode::to_s(VAR_7));\n\n  BOOST_FOREACH(const MOADNSParser::answers_t::value_type& VAR_8, mdp.VAR_9)\n    if (VAR_8.first.d_type == QType::SOA)\n      VAR_1++;\n \n  if(!VAR_10.empty()) { /* COMMENT_2 */\n    /* COMMENT_3 */\n    /* COMMENT_4 */\n    VAR_11.append(VAR_6.get(), VAR_2);\n    if (mdp.getTSIGPos() == 0)\n      VAR_12 += VAR_2;\n    else \n      VAR_12 += mdp.getTSIGPos();\n\n    string VAR_13;\n    bool VAR_14 = false;\n    \n    BOOST_FOREACH(const MOADNSParser::answers_t::value_type& VAR_8, mdp.VAR_9) {\n      if (VAR_8.first.d_type == QType::SOA)  /* COMMENT_5 */\n        VAR_14 = true;\n      \n      if(VAR_8.first.d_type == QType::TSIG) {\n        shared_ptr<TSIGRecordContent> VAR_15 = boost::VAR_16<TSIGRecordContent>(VAR_8.first.d_content);\n        VAR_13 = VAR_15->d_mac;\n        VAR_17.d_time = VAR_15->d_time;\n        VAR_14 = true;\n      }\n    }\n\n    if( ! VAR_14 && VAR_18 > 99) { /* COMMENT_6 */\n      throw ResolverException(\"No TSIG message received in last 100 messages of AXFR transfer.\");\n    }\n\n    if (VAR_14) {\n      if (VAR_13.empty())\n        throw ResolverException(\"No TSIG on AXFR response from \"+VAR_19.toStringWithPort()+\" , should be signed with TSIG key '\"+VAR_10+\"'\");\n\n      string VAR_20;\n      if (!VAR_21.empty()) {\n        VAR_20 = makeTSIGMessageFromTSIGPacket(VAR_11, VAR_12, VAR_10, VAR_17, VAR_21, true, VAR_11.size()-VAR_2);\n      } else {\n        VAR_20 = makeTSIGMessageFromTSIGPacket(VAR_11, VAR_12, VAR_10, VAR_17, VAR_17.d_mac, false);\n      }\n\n      TSIGHashEnum VAR_22;\n      if (!getTSIGHashEnum(VAR_17.d_algoName, VAR_22)) {\n        throw ResolverException(\"Unsupported TSIG HMAC algorithm \" + VAR_17.d_algoName);\n      }\n\n      string VAR_23=calculateHMAC(VAR_24, VAR_20, VAR_22);\n\n      /* COMMENT_7 */\n      if(VAR_23 != VAR_13) {\n        throw ResolverException(\"Signature failed to validate on AXFR response from \"+VAR_19.toStringWithPort()+\" signed with TSIG key '\"+VAR_10+\"'\");\n      }\n\n      /* COMMENT_8 */\n      VAR_21 = VAR_13;\n      VAR_18 = 0;\n      VAR_11.clear();\n      VAR_12 = 0;\n    }\n    else\n      VAR_18++;\n  }\n  \n  return true;\n}",
  "func_graph_path": "PowerDNS/pdns/a014f4c224a7b21f1c648257d1fd1128413129aa/resolver.cc/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -7,8 +7,14 @@\n   int len=getLength();\n   if(len<0)\n     throw ResolverException(\"EOF trying to read axfr chunk from remote TCP client\");\n-  \n-  timeoutReadn(len); \n+\n+  if (d_maxReceivedBytes > 0 && (d_maxReceivedBytes - d_receivedBytes) < (size_t) len)\n+    throw ResolverException(\"Reached the maximum number of received bytes during AXFR\");\n+\n+  timeoutReadn(len);\n+\n+  d_receivedBytes += (uint16_t) len;\n+\n   MOADNSParser mdp(d_buf.get(), len);\n \n   int err = parseResult(mdp, \"\", 0, 0, &res);",
  "diff_line_info": {
    "deleted_lines": [
      "  ",
      "  timeoutReadn(len); "
    ],
    "added_lines": [
      "",
      "  if (d_maxReceivedBytes > 0 && (d_maxReceivedBytes - d_receivedBytes) < (size_t) len)",
      "    throw ResolverException(\"Reached the maximum number of received bytes during AXFR\");",
      "",
      "  timeoutReadn(len);",
      "",
      "  d_receivedBytes += (uint16_t) len;",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/PowerDNS/pdns/pull/4134",
  "description": {
    "pr_info": {
      "title": "Add limits to the size of received AXFR, in megabytes",
      "number": 4134
    },
    "comment": [
      "This prevents resource exhaustion in case the master is sending a\nvery large amount of data in an update.\n",
      "Fixes #4128 for 3.4.x.\n",
      "LGTM. pdns.xml edit is useless, 3.x docs are built from markdown on the docs-3X branch.\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "The patch introduces checks to limit data size during AXFR retrieval, preventing resource exhaustion. This is aimed at mitigating a potential security vulnerability, specifically a denial of service scenario caused by excessive resource consumption. \n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}