{
  "cve_id": "CVE-2021-37620",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "Exiv2/exiv2",
  "commit_msg": "Safer std::vector indexing.",
  "commit_hash": "76e313745e813f80e8910aceb2210af3ad8cf897",
  "git_url": "https://github.com/Exiv2/exiv2/commit/76e313745e813f80e8910aceb2210af3ad8cf897",
  "file_path": "src/value.cpp",
  "func_name": "CommentValue::read",
  "func_before": "int CommentValue::read(const std::string& comment)\n    {\n        std::string c = comment;\n        CharsetId charsetId = undefined;\n        if (comment.length() > 8 && comment.substr(0, 8) == \"charset=\") {\n            std::string::size_type pos = comment.find_first_of(' ');\n            std::string name = comment.substr(8, pos-8);\n            // Strip quotes (so you can also specify the charset without quotes)\n            if (name[0] == '\"') name = name.substr(1);\n            if (name[name.length()-1] == '\"') name = name.substr(0, name.length()-1);\n            charsetId = CharsetInfo::charsetIdByName(name);\n            if (charsetId == invalidCharsetId) {\n#ifndef SUPPRESS_WARNINGS\n                EXV_WARNING << Error(kerInvalidCharset, name) << \"\\n\";\n#endif\n                return 1;\n            }\n            c.clear();\n            if (pos != std::string::npos) c = comment.substr(pos+1);\n        }\n        if (charsetId == unicode) {\n            const char* to = byteOrder_ == littleEndian ? \"UCS-2LE\" : \"UCS-2BE\";\n            convertStringCharset(c, \"UTF-8\", to);\n        }\n        const std::string code(CharsetInfo::code(charsetId), 8);\n        return StringValueBase::read(code + c);\n    }",
  "abstract_func_before": "int CommentValue::read(const std::string& VAR_0)\n    {\n        std::string VAR_1 = VAR_0;\n        CharsetId VAR_2 = VAR_3;\n        if (VAR_0.length() > 8 && VAR_0.substr(0, 8) == \"charset=\") {\n            std::string::size_type VAR_4 = VAR_0.find_first_of(' ');\n            std::string VAR_5 = VAR_0.substr(8, VAR_4-8);\n            /* COMMENT_0 */\n            if (VAR_5[0] == '\"') VAR_5 = VAR_5.substr(1);\n            if (VAR_5[VAR_5.length()-1] == '\"') VAR_5 = VAR_5.substr(0, VAR_5.length()-1);\n            VAR_2 = CharsetInfo::charsetIdByName(VAR_5);\n            if (VAR_2 == VAR_6) {\n#ifndef VAR_7\n                VAR_8 << Error(VAR_9, VAR_5) << \"\\n\";\n#endif\n                return 1;\n            }\n            VAR_1.clear();\n            if (VAR_4 != std::string::npos) VAR_1 = VAR_0.substr(VAR_4+1);\n        }\n        if (VAR_2 == VAR_10) {\n            const char* VAR_11 = VAR_12 == VAR_13 ? \"UCS-2LE\" : \"UCS-2BE\";\n            convertStringCharset(VAR_1, \"UTF-8\", VAR_11);\n        }\n        const std::string VAR_14(CharsetInfo::code(VAR_2), 8);\n        return StringValueBase::read(VAR_14 + VAR_1);\n    }",
  "func_graph_path_before": "Exiv2/exiv2/76e313745e813f80e8910aceb2210af3ad8cf897/value.cpp/vul/before/1.json",
  "func": "int CommentValue::read(const std::string& comment)\n    {\n        std::string c = comment;\n        CharsetId charsetId = undefined;\n        if (comment.length() > 8 && comment.substr(0, 8) == \"charset=\") {\n            std::string::size_type pos = comment.find_first_of(' ');\n            std::string name = comment.substr(8, pos-8);\n            // Strip quotes (so you can also specify the charset without quotes)\n            if (!name.empty()) {\n                if (name[0] == '\"') name = name.substr(1);\n                if (name[name.length()-1] == '\"') name = name.substr(0, name.length()-1);\n            }\n            charsetId = CharsetInfo::charsetIdByName(name);\n            if (charsetId == invalidCharsetId) {\n#ifndef SUPPRESS_WARNINGS\n                EXV_WARNING << Error(kerInvalidCharset, name) << \"\\n\";\n#endif\n                return 1;\n            }\n            c.clear();\n            if (pos != std::string::npos) c = comment.substr(pos+1);\n        }\n        if (charsetId == unicode) {\n            const char* to = byteOrder_ == littleEndian ? \"UCS-2LE\" : \"UCS-2BE\";\n            convertStringCharset(c, \"UTF-8\", to);\n        }\n        const std::string code(CharsetInfo::code(charsetId), 8);\n        return StringValueBase::read(code + c);\n    }",
  "abstract_func": "int CommentValue::read(const std::string& VAR_0)\n    {\n        std::string VAR_1 = VAR_0;\n        CharsetId VAR_2 = VAR_3;\n        if (VAR_0.length() > 8 && VAR_0.substr(0, 8) == \"charset=\") {\n            std::string::size_type VAR_4 = VAR_0.find_first_of(' ');\n            std::string VAR_5 = VAR_0.substr(8, VAR_4-8);\n            /* COMMENT_0 */\n            if (!VAR_5.empty()) {\n                if (VAR_5[0] == '\"') VAR_5 = VAR_5.substr(1);\n                if (VAR_5[VAR_5.length()-1] == '\"') VAR_5 = VAR_5.substr(0, VAR_5.length()-1);\n            }\n            VAR_2 = CharsetInfo::charsetIdByName(VAR_5);\n            if (VAR_2 == VAR_6) {\n#ifndef VAR_7\n                VAR_8 << Error(VAR_9, VAR_5) << \"\\n\";\n#endif\n                return 1;\n            }\n            VAR_1.clear();\n            if (VAR_4 != std::string::npos) VAR_1 = VAR_0.substr(VAR_4+1);\n        }\n        if (VAR_2 == VAR_10) {\n            const char* VAR_11 = VAR_12 == VAR_13 ? \"UCS-2LE\" : \"UCS-2BE\";\n            convertStringCharset(VAR_1, \"UTF-8\", VAR_11);\n        }\n        const std::string VAR_14(CharsetInfo::code(VAR_2), 8);\n        return StringValueBase::read(VAR_14 + VAR_1);\n    }",
  "func_graph_path": "Exiv2/exiv2/76e313745e813f80e8910aceb2210af3ad8cf897/value.cpp/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -6,8 +6,10 @@\n             std::string::size_type pos = comment.find_first_of(' ');\n             std::string name = comment.substr(8, pos-8);\n             // Strip quotes (so you can also specify the charset without quotes)\n-            if (name[0] == '\"') name = name.substr(1);\n-            if (name[name.length()-1] == '\"') name = name.substr(0, name.length()-1);\n+            if (!name.empty()) {\n+                if (name[0] == '\"') name = name.substr(1);\n+                if (name[name.length()-1] == '\"') name = name.substr(0, name.length()-1);\n+            }\n             charsetId = CharsetInfo::charsetIdByName(name);\n             if (charsetId == invalidCharsetId) {\n #ifndef SUPPRESS_WARNINGS",
  "diff_line_info": {
    "deleted_lines": [
      "            if (name[0] == '\"') name = name.substr(1);",
      "            if (name[name.length()-1] == '\"') name = name.substr(0, name.length()-1);"
    ],
    "added_lines": [
      "            if (!name.empty()) {",
      "                if (name[0] == '\"') name = name.substr(1);",
      "                if (name[name.length()-1] == '\"') name = name.substr(0, name.length()-1);",
      "            }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/sridharb1/exiv2/pull/4",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/sridharb1/exiv2/pull/4: 403 Client Error: Forbidden for url: https://api.github.com/repos/sridharb1/exiv2/pulls/4",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.8"
}