{
  "cve_id": "CVE-2022-2061",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "AV:L/AC:L/Au:N/C:P/I:N/A:N",
  "cvss_is_v3": false,
  "repo_name": "hpjansson/chafa",
  "commit_msg": "libnsgif: fix oob in lzw_decode",
  "commit_hash": "e6ce3746cdcf0836b9dae659a5aed15d73a080d8",
  "git_url": "https://github.com/hpjansson/chafa/commit/e6ce3746cdcf0836b9dae659a5aed15d73a080d8",
  "file_path": "libnsgif/lzw.c",
  "func_name": "lzw_decode",
  "func_before": "lzw_result lzw_decode(struct lzw_ctx *ctx,\n\t\tconst uint8_t ** const stack_pos_out)\n{\n\tlzw_result res;\n\tuint32_t code_new;\n\tuint32_t code_out;\n\tuint8_t last_value;\n\tuint8_t *stack_pos = ctx->stack_base;\n\tuint32_t clear_code = ctx->clear_code;\n\tuint32_t current_entry = ctx->current_entry;\n\tstruct lzw_dictionary_entry * const table = ctx->table;\n\n\t/* Get a new code from the input */\n\tres = lzw__next_code(&ctx->input, ctx->current_code_size, &code_new);\n\tif (res != LZW_OK) {\n\t\treturn res;\n\t}\n\n\t/* Handle the new code */\n\tif (code_new == clear_code) {\n\t\t/* Got Clear code */\n\t\treturn lzw__clear_codes(ctx, stack_pos_out);\n\n\t} else if (code_new == ctx->eoi_code) {\n\t\t/* Got End of Information code */\n\t\treturn LZW_EOI_CODE;\n\n\t} else if (code_new > current_entry) {\n\t\t/* Code is invalid */\n\t\treturn LZW_BAD_CODE;\n\n\t} else if (code_new < current_entry) {\n\t\t/* Code is in table */\n\t\tcode_out = code_new;\n\t\tlast_value = table[code_new].first_value;\n\t} else {\n\t\t/* Code not in table */\n\t\t*stack_pos++ = ctx->previous_code_first;\n\t\tcode_out = ctx->previous_code;\n\t\tlast_value = ctx->previous_code_first;\n\t}\n\n\t/* Add to the dictionary, only if there's space */\n\tif (current_entry < (1 << LZW_CODE_MAX)) {\n\t\tstruct lzw_dictionary_entry *entry = table + current_entry;\n\t\tentry->last_value     = last_value;\n\t\tentry->first_value    = ctx->previous_code_first;\n\t\tentry->previous_entry = ctx->previous_code;\n\t\tctx->current_entry++;\n\t}\n\n\t/* Ensure code size is increased, if needed. */\n\tif (current_entry == ctx->current_code_size_max) {\n\t\tif (ctx->current_code_size < LZW_CODE_MAX) {\n\t\t\tctx->current_code_size++;\n\t\t\tctx->current_code_size_max =\n\t\t\t\t\t(1 << ctx->current_code_size) - 1;\n\t\t}\n\t}\n\n\t/* Store details of this code as \"previous code\" to the context. */\n\tctx->previous_code_first = table[code_new].first_value;\n\tctx->previous_code = code_new;\n\n\t/* Put rest of data for this code on output stack.\n\t * Note, in the case of \"code not in table\", the last entry of the\n\t * current code has already been placed on the stack above. */\n\twhile (code_out > clear_code) {\n\t\tstruct lzw_dictionary_entry *entry = table + code_out;\n\t\t*stack_pos++ = entry->last_value;\n\t\tcode_out = entry->previous_entry;\n\t}\n\t*stack_pos++ = table[code_out].last_value;\n\n\t*stack_pos_out = stack_pos;\n\treturn LZW_OK;\n}",
  "abstract_func_before": "lzw_result lzw_decode(struct lzw_ctx *VAR_0,\n\t\tconst uint8_t ** const VAR_1)\n{\n\tlzw_result VAR_2;\n\tuint32_t VAR_3;\n\tuint32_t VAR_4;\n\tuint8_t VAR_5;\n\tuint8_t *VAR_6 = VAR_0->stack_base;\n\tuint32_t VAR_7 = VAR_0->clear_code;\n\tuint32_t VAR_8 = VAR_0->current_entry;\n\tstruct lzw_dictionary_entry * const VAR_9 = VAR_0->table;\n\n\t/* COMMENT_0 */\n\tVAR_2 = lzw__next_code(&VAR_0->input, VAR_0->current_code_size, &VAR_3);\n\tif (VAR_2 != VAR_10) {\n\t\treturn VAR_2;\n\t}\n\n\t/* COMMENT_1 */\n\tif (VAR_3 == VAR_7) {\n\t\t/* COMMENT_2 */\n\t\treturn lzw__clear_codes(VAR_0, VAR_1);\n\n\t} else if (VAR_3 == VAR_0->eoi_code) {\n\t\t/* COMMENT_3 */\n\t\treturn VAR_11;\n\n\t} else if (VAR_3 > VAR_8) {\n\t\t/* COMMENT_4 */\n\t\treturn VAR_12;\n\n\t} else if (VAR_3 < VAR_8) {\n\t\t/* COMMENT_5 */\n\t\tVAR_4 = VAR_3;\n\t\tVAR_5 = VAR_9[VAR_3].first_value;\n\t} else {\n\t\t/* COMMENT_6 */\n\t\t*VAR_6++ = VAR_0->previous_code_first;\n\t\tVAR_4 = VAR_0->previous_code;\n\t\tVAR_5 = VAR_0->previous_code_first;\n\t}\n\n\t/* COMMENT_7 */\n\tif (VAR_8 < (1 << VAR_13)) {\n\t\tstruct lzw_dictionary_entry *VAR_14 = VAR_9 + VAR_8;\n\t\tVAR_14->last_value     = VAR_5;\n\t\tVAR_14->first_value    = VAR_0->previous_code_first;\n\t\tVAR_14->previous_entry = VAR_0->previous_code;\n\t\tVAR_0->current_entry++;\n\t}\n\n\t/* COMMENT_8 */\n\tif (VAR_8 == VAR_0->current_code_size_max) {\n\t\tif (VAR_0->current_code_size < VAR_13) {\n\t\t\tVAR_0->current_code_size++;\n\t\t\tVAR_0->current_code_size_max =\n\t\t\t\t\t(1 << VAR_0->current_code_size) - 1;\n\t\t}\n\t}\n\n\t/* COMMENT_9 */\n\tVAR_0->previous_code_first = VAR_9[VAR_3].first_value;\n\tVAR_0->previous_code = VAR_3;\n\n\t/* COMMENT_10 */\n                                                                   \n                                                               \n\twhile (VAR_4 > VAR_7) {\n\t\tstruct lzw_dictionary_entry *VAR_14 = VAR_9 + VAR_4;\n\t\t*VAR_6++ = VAR_14->last_value;\n\t\tVAR_4 = VAR_14->previous_entry;\n\t}\n\t*VAR_6++ = VAR_9[VAR_4].last_value;\n\n\t*VAR_1 = VAR_6;\n\treturn VAR_10;\n}",
  "func_graph_path_before": "hpjansson/chafa/e6ce3746cdcf0836b9dae659a5aed15d73a080d8/lzw.c/vul/before/0.json",
  "func": "lzw_result lzw_decode(struct lzw_ctx *ctx,\n\t\tconst uint8_t ** const stack_pos_out)\n{\n\tlzw_result res;\n\tuint32_t code_new;\n\tuint32_t code_out;\n\tuint8_t last_value;\n\tuint8_t *stack_pos = ctx->stack_base;\n\tuint32_t clear_code = ctx->clear_code;\n\tuint32_t current_entry = ctx->current_entry;\n\tstruct lzw_dictionary_entry * const table = ctx->table;\n\n\t/* Get a new code from the input */\n\tres = lzw__next_code(&ctx->input, ctx->current_code_size, &code_new);\n\tif (res != LZW_OK) {\n\t\treturn res;\n\t}\n\n\t/* Handle the new code */\n\tif (code_new == clear_code) {\n\t\t/* Got Clear code */\n\t\treturn lzw__clear_codes(ctx, stack_pos_out);\n\n\t} else if (code_new == ctx->eoi_code) {\n\t\t/* Got End of Information code */\n\t\treturn LZW_EOI_CODE;\n\n\t} else if (code_new > current_entry) {\n\t\t/* Code is invalid */\n\t\treturn LZW_BAD_CODE;\n\n\t} else if (code_new >= 1 << LZW_CODE_MAX) {\n\t\t/* Don't access out of bound */\n\t\treturn LZW_BAD_CODE;\n\n\t} else if (code_new < current_entry) {\n\t\t/* Code is in table */\n\t\tcode_out = code_new;\n\t\tlast_value = table[code_new].first_value;\n\t} else {\n\t\t/* Code not in table */\n\t\t*stack_pos++ = ctx->previous_code_first;\n\t\tcode_out = ctx->previous_code;\n\t\tlast_value = ctx->previous_code_first;\n\t}\n\n\t/* Add to the dictionary, only if there's space */\n\tif (current_entry < (1 << LZW_CODE_MAX)) {\n\t\tstruct lzw_dictionary_entry *entry = table + current_entry;\n\t\tentry->last_value     = last_value;\n\t\tentry->first_value    = ctx->previous_code_first;\n\t\tentry->previous_entry = ctx->previous_code;\n\t\tctx->current_entry++;\n\t}\n\n\t/* Ensure code size is increased, if needed. */\n\tif (current_entry == ctx->current_code_size_max) {\n\t\tif (ctx->current_code_size < LZW_CODE_MAX) {\n\t\t\tctx->current_code_size++;\n\t\t\tctx->current_code_size_max =\n\t\t\t\t\t(1 << ctx->current_code_size) - 1;\n\t\t}\n\t}\n\n\t/* Store details of this code as \"previous code\" to the context. */\n\tctx->previous_code_first = table[code_new].first_value;\n\tctx->previous_code = code_new;\n\n\t/* Put rest of data for this code on output stack.\n\t * Note, in the case of \"code not in table\", the last entry of the\n\t * current code has already been placed on the stack above. */\n\twhile (code_out > clear_code) {\n\t\tstruct lzw_dictionary_entry *entry = table + code_out;\n\t\t*stack_pos++ = entry->last_value;\n\t\tcode_out = entry->previous_entry;\n\t}\n\t*stack_pos++ = table[code_out].last_value;\n\n\t*stack_pos_out = stack_pos;\n\treturn LZW_OK;\n}",
  "abstract_func": "lzw_result lzw_decode(struct lzw_ctx *VAR_0,\n\t\tconst uint8_t ** const VAR_1)\n{\n\tlzw_result VAR_2;\n\tuint32_t VAR_3;\n\tuint32_t VAR_4;\n\tuint8_t VAR_5;\n\tuint8_t *VAR_6 = VAR_0->stack_base;\n\tuint32_t VAR_7 = VAR_0->clear_code;\n\tuint32_t VAR_8 = VAR_0->current_entry;\n\tstruct lzw_dictionary_entry * const VAR_9 = VAR_0->table;\n\n\t/* COMMENT_0 */\n\tVAR_2 = lzw__next_code(&VAR_0->input, VAR_0->current_code_size, &VAR_3);\n\tif (VAR_2 != VAR_10) {\n\t\treturn VAR_2;\n\t}\n\n\t/* COMMENT_1 */\n\tif (VAR_3 == VAR_7) {\n\t\t/* COMMENT_2 */\n\t\treturn lzw__clear_codes(VAR_0, VAR_1);\n\n\t} else if (VAR_3 == VAR_0->eoi_code) {\n\t\t/* COMMENT_3 */\n\t\treturn VAR_11;\n\n\t} else if (VAR_3 > VAR_8) {\n\t\t/* COMMENT_4 */\n\t\treturn VAR_12;\n\n\t} else if (VAR_3 >= 1 << VAR_13) {\n\t\t/* COMMENT_5 */\n\t\treturn VAR_12;\n\n\t} else if (VAR_3 < VAR_8) {\n\t\t/* COMMENT_6 */\n\t\tVAR_4 = VAR_3;\n\t\tVAR_5 = VAR_9[VAR_3].first_value;\n\t} else {\n\t\t/* COMMENT_7 */\n\t\t*VAR_6++ = VAR_0->previous_code_first;\n\t\tVAR_4 = VAR_0->previous_code;\n\t\tVAR_5 = VAR_0->previous_code_first;\n\t}\n\n\t/* COMMENT_8 */\n\tif (VAR_8 < (1 << VAR_13)) {\n\t\tstruct lzw_dictionary_entry *VAR_14 = VAR_9 + VAR_8;\n\t\tVAR_14->last_value     = VAR_5;\n\t\tVAR_14->first_value    = VAR_0->previous_code_first;\n\t\tVAR_14->previous_entry = VAR_0->previous_code;\n\t\tVAR_0->current_entry++;\n\t}\n\n\t/* COMMENT_9 */\n\tif (VAR_8 == VAR_0->current_code_size_max) {\n\t\tif (VAR_0->current_code_size < VAR_13) {\n\t\t\tVAR_0->current_code_size++;\n\t\t\tVAR_0->current_code_size_max =\n\t\t\t\t\t(1 << VAR_0->current_code_size) - 1;\n\t\t}\n\t}\n\n\t/* COMMENT_10 */\n\tVAR_0->previous_code_first = VAR_9[VAR_3].first_value;\n\tVAR_0->previous_code = VAR_3;\n\n\t/* COMMENT_11 */\n                                                                   \n                                                               \n\twhile (VAR_4 > VAR_7) {\n\t\tstruct lzw_dictionary_entry *VAR_14 = VAR_9 + VAR_4;\n\t\t*VAR_6++ = VAR_14->last_value;\n\t\tVAR_4 = VAR_14->previous_entry;\n\t}\n\t*VAR_6++ = VAR_9[VAR_4].last_value;\n\n\t*VAR_1 = VAR_6;\n\treturn VAR_10;\n}",
  "func_graph_path": "hpjansson/chafa/e6ce3746cdcf0836b9dae659a5aed15d73a080d8/lzw.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -27,6 +27,10 @@\n \n \t} else if (code_new > current_entry) {\n \t\t/* Code is invalid */\n+\t\treturn LZW_BAD_CODE;\n+\n+\t} else if (code_new >= 1 << LZW_CODE_MAX) {\n+\t\t/* Don't access out of bound */\n \t\treturn LZW_BAD_CODE;\n \n \t} else if (code_new < current_entry) {",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "\t\treturn LZW_BAD_CODE;",
      "",
      "\t} else if (code_new >= 1 << LZW_CODE_MAX) {",
      "\t\t/* Don't access out of bound */"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/hpjansson/chafa/pull/93",
  "description": {
    "pr_info": {
      "title": "Fix OOB access in `lzw_decode`",
      "number": 93
    },
    "comment": [
      "See : https://huntr.dev/bounties/365ab61f-9a63-421c-97e6-21d4653021f0/\r\n\r\nAn out of bounds access on the `table` could happen in some case. In this PR I check the bounds before access and returns `LZW_BAD_CODE` if invalid index is found.\r\n\r\nAs the discussion on the huntr thread - `libnsgif` has changed a lot and this was silently patched. So I am adding this as a failsafe measure until the next release rolls out.",
      "Awesome, thanks a lot."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95  \n**Confidence Explanation:** The commit message and code changes directly address an out-of-bounds (OOB) vulnerability by adding bounds checks. The vulnerability description confirms it's a security issue with a bounty reference. The code modifications are clear and consistent with the commit intent, indicating a high confidence in this classification."
}