{
  "cve_id": "CVE-2019-15788",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "NVIDIA-Genomics-Research/GenomeWorks",
  "commit_msg": "[cudapoa] replace size_t with int64_t",
  "commit_hash": "8524f2c0c690ff594a9ebc6d729351b07a1fc5f0",
  "git_url": "https://github.com/NVIDIA-Genomics-Research/GenomeWorks/commit/8524f2c0c690ff594a9ebc6d729351b07a1fc5f0",
  "file_path": "cudapoa/src/allocate_block.cpp",
  "func_name": "BatchBlock::get_input_details",
  "func_before": "void BatchBlock::get_input_details(InputDetails** input_details_h_p, InputDetails** input_details_d_p)\n{\n    // on host\n    InputDetails* input_details_h{};\n    InputDetails* input_details_d{};\n\n    input_details_h = reinterpret_cast<InputDetails*>(&block_data_h_[offset_h_]);\n    offset_h_ += sizeof(InputDetails);\n    input_details_h->sequences = &block_data_h_[offset_h_];\n    offset_h_ += input_size_ * sizeof(uint8_t);\n    input_details_h->base_weights = reinterpret_cast<int8_t*>(&block_data_h_[offset_h_]);\n    offset_h_ += input_size_ * sizeof(int8_t);\n    input_details_h->sequence_lengths = reinterpret_cast<uint16_t*>(&block_data_h_[offset_h_]);\n    offset_h_ += max_poas_ * max_sequences_per_poa_ * sizeof(uint16_t);\n    input_details_h->window_details = reinterpret_cast<WindowDetails*>(&block_data_h_[offset_h_]);\n    offset_h_ += max_poas_ * sizeof(WindowDetails);\n    if (output_mask_ & OutputType::msa)\n    {\n        input_details_h->sequence_begin_nodes_ids = reinterpret_cast<uint16_t*>(&block_data_h_[offset_h_]);\n        offset_h_ += max_poas_ * max_sequences_per_poa_ * sizeof(uint16_t);\n    }\n\n    input_details_d = reinterpret_cast<InputDetails*>(&block_data_h_[offset_h_]);\n    offset_h_ += sizeof(InputDetails);\n\n    // on device\n    input_details_d->sequences = &block_data_d_[offset_d_];\n    offset_d_ += cudautils::align<size_t, 8>(input_size_ * sizeof(uint8_t));\n    input_details_d->base_weights = reinterpret_cast<int8_t*>(&block_data_d_[offset_d_]);\n    offset_d_ += cudautils::align<size_t, 8>(input_size_ * sizeof(int8_t));\n    input_details_d->sequence_lengths = reinterpret_cast<uint16_t*>(&block_data_d_[offset_d_]);\n    offset_d_ += cudautils::align<size_t, 8>(max_poas_ * max_sequences_per_poa_ * sizeof(uint16_t));\n    input_details_d->window_details = reinterpret_cast<WindowDetails*>(&block_data_d_[offset_d_]);\n    offset_d_ += cudautils::align<size_t, 8>(max_poas_ * sizeof(WindowDetails));\n    if (output_mask_ & OutputType::msa)\n    {\n        input_details_d->sequence_begin_nodes_ids = reinterpret_cast<uint16_t*>(&block_data_d_[offset_d_]);\n        offset_d_ += cudautils::align<size_t, 8>(max_poas_ * max_sequences_per_poa_ * sizeof(uint16_t));\n    }\n\n    *input_details_h_p = input_details_h;\n    *input_details_d_p = input_details_d;\n}",
  "abstract_func_before": "void BatchBlock::get_input_details(InputDetails** VAR_0, InputDetails** VAR_1)\n{\n    /* COMMENT_0 */\n    InputDetails* VAR_2{};\n    InputDetails* VAR_3{};\n\n    VAR_2 = VAR_4<InputDetails*>(&VAR_5[VAR_6]);\n    VAR_6 += sizeof(InputDetails);\n    VAR_2->sequences = &VAR_5[VAR_6];\n    VAR_6 += VAR_7 * sizeof(uint8_t);\n    VAR_2->base_weights = VAR_4<int8_t*>(&VAR_5[VAR_6]);\n    VAR_6 += VAR_7 * sizeof(int8_t);\n    VAR_2->sequence_lengths = VAR_4<uint16_t*>(&VAR_5[VAR_6]);\n    VAR_6 += VAR_8 * VAR_9 * sizeof(uint16_t);\n    VAR_2->window_details = VAR_4<WindowDetails*>(&VAR_5[VAR_6]);\n    VAR_6 += VAR_8 * sizeof(WindowDetails);\n    if (VAR_10 & OutputType::msa)\n    {\n        VAR_2->sequence_begin_nodes_ids = VAR_4<uint16_t*>(&VAR_5[VAR_6]);\n        VAR_6 += VAR_8 * VAR_9 * sizeof(uint16_t);\n    }\n\n    VAR_3 = VAR_4<InputDetails*>(&VAR_5[VAR_6]);\n    VAR_6 += sizeof(InputDetails);\n\n    /* COMMENT_1 */\n    VAR_3->sequences = &VAR_11[VAR_12];\n    VAR_12 += cudautils::VAR_13<size_t, 8>(VAR_7 * sizeof(uint8_t));\n    VAR_3->base_weights = VAR_4<int8_t*>(&VAR_11[VAR_12]);\n    VAR_12 += cudautils::VAR_13<size_t, 8>(VAR_7 * sizeof(int8_t));\n    VAR_3->sequence_lengths = VAR_4<uint16_t*>(&VAR_11[VAR_12]);\n    VAR_12 += cudautils::VAR_13<size_t, 8>(VAR_8 * VAR_9 * sizeof(uint16_t));\n    VAR_3->window_details = VAR_4<WindowDetails*>(&VAR_11[VAR_12]);\n    VAR_12 += cudautils::VAR_13<size_t, 8>(VAR_8 * sizeof(WindowDetails));\n    if (VAR_10 & OutputType::msa)\n    {\n        VAR_3->sequence_begin_nodes_ids = VAR_4<uint16_t*>(&VAR_11[VAR_12]);\n        VAR_12 += cudautils::VAR_13<size_t, 8>(VAR_8 * VAR_9 * sizeof(uint16_t));\n    }\n\n    *VAR_0 = VAR_2;\n    *VAR_1 = VAR_3;\n}",
  "func_graph_path_before": "NVIDIA-Genomics-Research/GenomeWorks/8524f2c0c690ff594a9ebc6d729351b07a1fc5f0/allocate_block.cpp/vul/before/2.json",
  "func": "void BatchBlock::get_input_details(InputDetails** input_details_h_p, InputDetails** input_details_d_p)\n{\n    // on host\n    InputDetails* input_details_h{};\n    InputDetails* input_details_d{};\n\n    input_details_h = reinterpret_cast<InputDetails*>(&block_data_h_[offset_h_]);\n    offset_h_ += sizeof(InputDetails);\n    input_details_h->sequences = &block_data_h_[offset_h_];\n    offset_h_ += input_size_ * sizeof(uint8_t);\n    input_details_h->base_weights = reinterpret_cast<int8_t*>(&block_data_h_[offset_h_]);\n    offset_h_ += input_size_ * sizeof(int8_t);\n    input_details_h->sequence_lengths = reinterpret_cast<uint16_t*>(&block_data_h_[offset_h_]);\n    offset_h_ += max_poas_ * max_sequences_per_poa_ * sizeof(uint16_t);\n    input_details_h->window_details = reinterpret_cast<WindowDetails*>(&block_data_h_[offset_h_]);\n    offset_h_ += max_poas_ * sizeof(WindowDetails);\n    if (output_mask_ & OutputType::msa)\n    {\n        input_details_h->sequence_begin_nodes_ids = reinterpret_cast<uint16_t*>(&block_data_h_[offset_h_]);\n        offset_h_ += max_poas_ * max_sequences_per_poa_ * sizeof(uint16_t);\n    }\n\n    input_details_d = reinterpret_cast<InputDetails*>(&block_data_h_[offset_h_]);\n    offset_h_ += sizeof(InputDetails);\n\n    // on device\n    input_details_d->sequences = &block_data_d_[offset_d_];\n    offset_d_ += cudautils::align<int64_t, 8>(input_size_ * sizeof(uint8_t));\n    input_details_d->base_weights = reinterpret_cast<int8_t*>(&block_data_d_[offset_d_]);\n    offset_d_ += cudautils::align<int64_t, 8>(input_size_ * sizeof(int8_t));\n    input_details_d->sequence_lengths = reinterpret_cast<uint16_t*>(&block_data_d_[offset_d_]);\n    offset_d_ += cudautils::align<int64_t, 8>(max_poas_ * max_sequences_per_poa_ * sizeof(uint16_t));\n    input_details_d->window_details = reinterpret_cast<WindowDetails*>(&block_data_d_[offset_d_]);\n    offset_d_ += cudautils::align<int64_t, 8>(max_poas_ * sizeof(WindowDetails));\n    if (output_mask_ & OutputType::msa)\n    {\n        input_details_d->sequence_begin_nodes_ids = reinterpret_cast<uint16_t*>(&block_data_d_[offset_d_]);\n        offset_d_ += cudautils::align<int64_t, 8>(max_poas_ * max_sequences_per_poa_ * sizeof(uint16_t));\n    }\n\n    *input_details_h_p = input_details_h;\n    *input_details_d_p = input_details_d;\n}",
  "abstract_func": "void BatchBlock::get_input_details(InputDetails** VAR_0, InputDetails** VAR_1)\n{\n    /* COMMENT_0 */\n    InputDetails* VAR_2{};\n    InputDetails* VAR_3{};\n\n    VAR_2 = VAR_4<InputDetails*>(&VAR_5[VAR_6]);\n    VAR_6 += sizeof(InputDetails);\n    VAR_2->sequences = &VAR_5[VAR_6];\n    VAR_6 += VAR_7 * sizeof(uint8_t);\n    VAR_2->base_weights = VAR_4<int8_t*>(&VAR_5[VAR_6]);\n    VAR_6 += VAR_7 * sizeof(int8_t);\n    VAR_2->sequence_lengths = VAR_4<uint16_t*>(&VAR_5[VAR_6]);\n    VAR_6 += VAR_8 * VAR_9 * sizeof(uint16_t);\n    VAR_2->window_details = VAR_4<WindowDetails*>(&VAR_5[VAR_6]);\n    VAR_6 += VAR_8 * sizeof(WindowDetails);\n    if (VAR_10 & OutputType::msa)\n    {\n        VAR_2->sequence_begin_nodes_ids = VAR_4<uint16_t*>(&VAR_5[VAR_6]);\n        VAR_6 += VAR_8 * VAR_9 * sizeof(uint16_t);\n    }\n\n    VAR_3 = VAR_4<InputDetails*>(&VAR_5[VAR_6]);\n    VAR_6 += sizeof(InputDetails);\n\n    /* COMMENT_1 */\n    VAR_3->sequences = &VAR_11[VAR_12];\n    VAR_12 += cudautils::VAR_13<int64_t, 8>(VAR_7 * sizeof(uint8_t));\n    VAR_3->base_weights = VAR_4<int8_t*>(&VAR_11[VAR_12]);\n    VAR_12 += cudautils::VAR_13<int64_t, 8>(VAR_7 * sizeof(int8_t));\n    VAR_3->sequence_lengths = VAR_4<uint16_t*>(&VAR_11[VAR_12]);\n    VAR_12 += cudautils::VAR_13<int64_t, 8>(VAR_8 * VAR_9 * sizeof(uint16_t));\n    VAR_3->window_details = VAR_4<WindowDetails*>(&VAR_11[VAR_12]);\n    VAR_12 += cudautils::VAR_13<int64_t, 8>(VAR_8 * sizeof(WindowDetails));\n    if (VAR_10 & OutputType::msa)\n    {\n        VAR_3->sequence_begin_nodes_ids = VAR_4<uint16_t*>(&VAR_11[VAR_12]);\n        VAR_12 += cudautils::VAR_13<int64_t, 8>(VAR_8 * VAR_9 * sizeof(uint16_t));\n    }\n\n    *VAR_0 = VAR_2;\n    *VAR_1 = VAR_3;\n}",
  "func_graph_path": "NVIDIA-Genomics-Research/GenomeWorks/8524f2c0c690ff594a9ebc6d729351b07a1fc5f0/allocate_block.cpp/vul/after/2.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -25,17 +25,17 @@\n \n     // on device\n     input_details_d->sequences = &block_data_d_[offset_d_];\n-    offset_d_ += cudautils::align<size_t, 8>(input_size_ * sizeof(uint8_t));\n+    offset_d_ += cudautils::align<int64_t, 8>(input_size_ * sizeof(uint8_t));\n     input_details_d->base_weights = reinterpret_cast<int8_t*>(&block_data_d_[offset_d_]);\n-    offset_d_ += cudautils::align<size_t, 8>(input_size_ * sizeof(int8_t));\n+    offset_d_ += cudautils::align<int64_t, 8>(input_size_ * sizeof(int8_t));\n     input_details_d->sequence_lengths = reinterpret_cast<uint16_t*>(&block_data_d_[offset_d_]);\n-    offset_d_ += cudautils::align<size_t, 8>(max_poas_ * max_sequences_per_poa_ * sizeof(uint16_t));\n+    offset_d_ += cudautils::align<int64_t, 8>(max_poas_ * max_sequences_per_poa_ * sizeof(uint16_t));\n     input_details_d->window_details = reinterpret_cast<WindowDetails*>(&block_data_d_[offset_d_]);\n-    offset_d_ += cudautils::align<size_t, 8>(max_poas_ * sizeof(WindowDetails));\n+    offset_d_ += cudautils::align<int64_t, 8>(max_poas_ * sizeof(WindowDetails));\n     if (output_mask_ & OutputType::msa)\n     {\n         input_details_d->sequence_begin_nodes_ids = reinterpret_cast<uint16_t*>(&block_data_d_[offset_d_]);\n-        offset_d_ += cudautils::align<size_t, 8>(max_poas_ * max_sequences_per_poa_ * sizeof(uint16_t));\n+        offset_d_ += cudautils::align<int64_t, 8>(max_poas_ * max_sequences_per_poa_ * sizeof(uint16_t));\n     }\n \n     *input_details_h_p = input_details_h;",
  "diff_line_info": {
    "deleted_lines": [
      "    offset_d_ += cudautils::align<size_t, 8>(input_size_ * sizeof(uint8_t));",
      "    offset_d_ += cudautils::align<size_t, 8>(input_size_ * sizeof(int8_t));",
      "    offset_d_ += cudautils::align<size_t, 8>(max_poas_ * max_sequences_per_poa_ * sizeof(uint16_t));",
      "    offset_d_ += cudautils::align<size_t, 8>(max_poas_ * sizeof(WindowDetails));",
      "        offset_d_ += cudautils::align<size_t, 8>(max_poas_ * max_sequences_per_poa_ * sizeof(uint16_t));"
    ],
    "added_lines": [
      "    offset_d_ += cudautils::align<int64_t, 8>(input_size_ * sizeof(uint8_t));",
      "    offset_d_ += cudautils::align<int64_t, 8>(input_size_ * sizeof(int8_t));",
      "    offset_d_ += cudautils::align<int64_t, 8>(max_poas_ * max_sequences_per_poa_ * sizeof(uint16_t));",
      "    offset_d_ += cudautils::align<int64_t, 8>(max_poas_ * sizeof(WindowDetails));",
      "        offset_d_ += cudautils::align<int64_t, 8>(max_poas_ * max_sequences_per_poa_ * sizeof(uint16_t));"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/NVIDIA-Genomics-Research/GenomeWorks/pull/70",
  "description": {
    "pr_info": {
      "title": "[cudapoa] fix integer overflow",
      "number": 70
    },
    "comment": [
      "1. Re-enable disabled cudapoa python test\r\n2. Fix integer overflow issue in cudapoa memory management"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}