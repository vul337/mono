{
  "cve_id": "CVE-2022-4904",
  "cwe_ids": [
    "CWE-1284"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:H",
  "cvss_is_v3": true,
  "repo_name": "c-ares",
  "commit_msg": "Add str len check in config_sortlist to avoid stack overflow\n\nIn ares_set_sortlist, it calls config_sortlist(..., sortstr) to parse\nthe input str and initialize a sortlist configuration.\n\nHowever, ares_set_sortlist has not any checks about the validity of the input str.\nIt is very easy to create an arbitrary length stack overflow with the unchecked\n`memcpy(ipbuf, str, q-str);` and `memcpy(ipbufpfx, str, q-str);`\nstatements in the config_sortlist call, which could potentially cause severe\nsecurity impact in practical programs.\n\nThis commit add necessary check for `ipbuf` and `ipbufpfx` which avoid the\npotential stack overflows.\n\nfixes #496\n\nSigned-off-by: hopper-vul <hopper.vul@gmail.com>",
  "commit_hash": "ac596026e77244481fd68736ae7f15855803a08a",
  "git_url": "https://github.com/c-ares/c-ares/commit/ac596026e77244481fd68736ae7f15855803a08a",
  "file_path": "src/lib/ares_init.c",
  "func_name": "config_sortlist",
  "func_before": "static int config_sortlist(struct apattern **sortlist, int *nsort,\n                           const char *str)\n{\n  struct apattern pat;\n  const char *q;\n\n  /* Add sortlist entries. */\n  while (*str && *str != ';')\n    {\n      int bits;\n      char ipbuf[16], ipbufpfx[32];\n      /* Find just the IP */\n      q = str;\n      while (*q && *q != '/' && *q != ';' && !ISSPACE(*q))\n        q++;\n      memcpy(ipbuf, str, q-str);\n      ipbuf[q-str] = '\\0';\n      /* Find the prefix */\n      if (*q == '/')\n        {\n          const char *str2 = q+1;\n          while (*q && *q != ';' && !ISSPACE(*q))\n            q++;\n          memcpy(ipbufpfx, str, q-str);\n          ipbufpfx[q-str] = '\\0';\n          str = str2;\n        }\n      else\n        ipbufpfx[0] = '\\0';\n      /* Lets see if it is CIDR */\n      /* First we'll try IPv6 */\n      if ((bits = ares_inet_net_pton(AF_INET6, ipbufpfx[0] ? ipbufpfx : ipbuf,\n                                     &pat.addrV6,\n                                     sizeof(pat.addrV6))) > 0)\n        {\n          pat.type = PATTERN_CIDR;\n          pat.mask.bits = (unsigned short)bits;\n          pat.family = AF_INET6;\n          if (!sortlist_alloc(sortlist, nsort, &pat)) {\n            ares_free(*sortlist);\n            *sortlist = NULL;\n            return ARES_ENOMEM;\n          }\n        }\n      else if (ipbufpfx[0] &&\n               (bits = ares_inet_net_pton(AF_INET, ipbufpfx, &pat.addrV4,\n                                          sizeof(pat.addrV4))) > 0)\n        {\n          pat.type = PATTERN_CIDR;\n          pat.mask.bits = (unsigned short)bits;\n          pat.family = AF_INET;\n          if (!sortlist_alloc(sortlist, nsort, &pat)) {\n            ares_free(*sortlist);\n            *sortlist = NULL;\n            return ARES_ENOMEM;\n          }\n        }\n      /* See if it is just a regular IP */\n      else if (ip_addr(ipbuf, q-str, &pat.addrV4) == 0)\n        {\n          if (ipbufpfx[0])\n            {\n              memcpy(ipbuf, str, q-str);\n              ipbuf[q-str] = '\\0';\n              if (ip_addr(ipbuf, q-str, &pat.mask.addr4) != 0)\n                natural_mask(&pat);\n            }\n          else\n            natural_mask(&pat);\n          pat.family = AF_INET;\n          pat.type = PATTERN_MASK;\n          if (!sortlist_alloc(sortlist, nsort, &pat)) {\n            ares_free(*sortlist);\n            *sortlist = NULL;\n            return ARES_ENOMEM;\n          }\n        }\n      else\n        {\n          while (*q && *q != ';' && !ISSPACE(*q))\n            q++;\n        }\n      str = q;\n      while (ISSPACE(*str))\n        str++;\n    }\n\n  return ARES_SUCCESS;\n}",
  "abstract_func_before": "static int config_sortlist(struct apattern **VAR_0, int *VAR_1,\n                           const char *VAR_2)\n{\n  struct apattern VAR_3;\n  const char *VAR_4;\n\n  /* COMMENT_0 */\n  while (*VAR_2 && *VAR_2 != ';')\n    {\n      int VAR_5;\n      char VAR_6[16], VAR_7[32];\n      /* COMMENT_1 */\n      VAR_4 = VAR_2;\n      while (*VAR_4 && *VAR_4 != '/' && *VAR_4 != ';' && !ISSPACE(*VAR_4))\n        VAR_4++;\n      memcpy(VAR_6, VAR_2, VAR_4-VAR_2);\n      VAR_6[VAR_4-VAR_2] = '\\0';\n      /* COMMENT_2 */\n      if (*VAR_4 == '/')\n        {\n          const char *VAR_8 = VAR_4+1;\n          while (*VAR_4 && *VAR_4 != ';' && !ISSPACE(*VAR_4))\n            VAR_4++;\n          memcpy(VAR_7, VAR_2, VAR_4-VAR_2);\n          VAR_7[VAR_4-VAR_2] = '\\0';\n          VAR_2 = VAR_8;\n        }\n      else\n        VAR_7[0] = '\\0';\n      /* COMMENT_3 */\n      /* COMMENT_4 */\n      if ((VAR_5 = ares_inet_net_pton(VAR_9, VAR_7[0] ? VAR_7 : VAR_6,\n                                     &VAR_3.addrV6,\n                                     sizeof(VAR_3.addrV6))) > 0)\n        {\n          VAR_3.type = VAR_10;\n          VAR_3.mask.bits = (unsigned short)VAR_5;\n          VAR_3.family = VAR_9;\n          if (!sortlist_alloc(VAR_0, VAR_1, &VAR_3)) {\n            ares_free(*VAR_0);\n            *VAR_0 = NULL;\n            return VAR_11;\n          }\n        }\n      else if (VAR_7[0] &&\n               (VAR_5 = ares_inet_net_pton(VAR_12, VAR_7, &VAR_3.addrV4,\n                                          sizeof(VAR_3.addrV4))) > 0)\n        {\n          VAR_3.type = VAR_10;\n          VAR_3.mask.bits = (unsigned short)VAR_5;\n          VAR_3.family = VAR_12;\n          if (!sortlist_alloc(VAR_0, VAR_1, &VAR_3)) {\n            ares_free(*VAR_0);\n            *VAR_0 = NULL;\n            return VAR_11;\n          }\n        }\n      /* COMMENT_5 */\n      else if (ip_addr(VAR_6, VAR_4-VAR_2, &VAR_3.addrV4) == 0)\n        {\n          if (VAR_7[0])\n            {\n              memcpy(VAR_6, VAR_2, VAR_4-VAR_2);\n              VAR_6[VAR_4-VAR_2] = '\\0';\n              if (ip_addr(VAR_6, VAR_4-VAR_2, &VAR_3.mask.addr4) != 0)\n                natural_mask(&VAR_3);\n            }\n          else\n            natural_mask(&VAR_3);\n          VAR_3.family = VAR_12;\n          VAR_3.type = VAR_13;\n          if (!sortlist_alloc(VAR_0, VAR_1, &VAR_3)) {\n            ares_free(*VAR_0);\n            *VAR_0 = NULL;\n            return VAR_11;\n          }\n        }\n      else\n        {\n          while (*VAR_4 && *VAR_4 != ';' && !ISSPACE(*VAR_4))\n            VAR_4++;\n        }\n      VAR_2 = VAR_4;\n      while (ISSPACE(*VAR_2))\n        VAR_2++;\n    }\n\n  return VAR_14;\n}",
  "func_graph_path_before": "c-ares/ac596026e77244481fd68736ae7f15855803a08a/ares_init.c/vul/before/0.json",
  "func": "static int config_sortlist(struct apattern **sortlist, int *nsort,\n                           const char *str)\n{\n  struct apattern pat;\n  const char *q;\n\n  /* Add sortlist entries. */\n  while (*str && *str != ';')\n    {\n      int bits;\n      char ipbuf[16], ipbufpfx[32];\n      /* Find just the IP */\n      q = str;\n      while (*q && *q != '/' && *q != ';' && !ISSPACE(*q))\n        q++;\n      if (q-str >= 16)\n        return ARES_EBADSTR;\n      memcpy(ipbuf, str, q-str);\n      ipbuf[q-str] = '\\0';\n      /* Find the prefix */\n      if (*q == '/')\n        {\n          const char *str2 = q+1;\n          while (*q && *q != ';' && !ISSPACE(*q))\n            q++;\n          if (q-str >= 32)\n            return ARES_EBADSTR;\n          memcpy(ipbufpfx, str, q-str);\n          ipbufpfx[q-str] = '\\0';\n          str = str2;\n        }\n      else\n        ipbufpfx[0] = '\\0';\n      /* Lets see if it is CIDR */\n      /* First we'll try IPv6 */\n      if ((bits = ares_inet_net_pton(AF_INET6, ipbufpfx[0] ? ipbufpfx : ipbuf,\n                                     &pat.addrV6,\n                                     sizeof(pat.addrV6))) > 0)\n        {\n          pat.type = PATTERN_CIDR;\n          pat.mask.bits = (unsigned short)bits;\n          pat.family = AF_INET6;\n          if (!sortlist_alloc(sortlist, nsort, &pat)) {\n            ares_free(*sortlist);\n            *sortlist = NULL;\n            return ARES_ENOMEM;\n          }\n        }\n      else if (ipbufpfx[0] &&\n               (bits = ares_inet_net_pton(AF_INET, ipbufpfx, &pat.addrV4,\n                                          sizeof(pat.addrV4))) > 0)\n        {\n          pat.type = PATTERN_CIDR;\n          pat.mask.bits = (unsigned short)bits;\n          pat.family = AF_INET;\n          if (!sortlist_alloc(sortlist, nsort, &pat)) {\n            ares_free(*sortlist);\n            *sortlist = NULL;\n            return ARES_ENOMEM;\n          }\n        }\n      /* See if it is just a regular IP */\n      else if (ip_addr(ipbuf, q-str, &pat.addrV4) == 0)\n        {\n          if (ipbufpfx[0])\n            {\n              memcpy(ipbuf, str, q-str);\n              ipbuf[q-str] = '\\0';\n              if (ip_addr(ipbuf, q-str, &pat.mask.addr4) != 0)\n                natural_mask(&pat);\n            }\n          else\n            natural_mask(&pat);\n          pat.family = AF_INET;\n          pat.type = PATTERN_MASK;\n          if (!sortlist_alloc(sortlist, nsort, &pat)) {\n            ares_free(*sortlist);\n            *sortlist = NULL;\n            return ARES_ENOMEM;\n          }\n        }\n      else\n        {\n          while (*q && *q != ';' && !ISSPACE(*q))\n            q++;\n        }\n      str = q;\n      while (ISSPACE(*str))\n        str++;\n    }\n\n  return ARES_SUCCESS;\n}",
  "abstract_func": "static int config_sortlist(struct apattern **VAR_0, int *VAR_1,\n                           const char *VAR_2)\n{\n  struct apattern VAR_3;\n  const char *VAR_4;\n\n  /* COMMENT_0 */\n  while (*VAR_2 && *VAR_2 != ';')\n    {\n      int VAR_5;\n      char VAR_6[16], VAR_7[32];\n      /* COMMENT_1 */\n      VAR_4 = VAR_2;\n      while (*VAR_4 && *VAR_4 != '/' && *VAR_4 != ';' && !ISSPACE(*VAR_4))\n        VAR_4++;\n      if (VAR_4-VAR_2 >= 16)\n        return VAR_8;\n      memcpy(VAR_6, VAR_2, VAR_4-VAR_2);\n      VAR_6[VAR_4-VAR_2] = '\\0';\n      /* COMMENT_2 */\n      if (*VAR_4 == '/')\n        {\n          const char *VAR_9 = VAR_4+1;\n          while (*VAR_4 && *VAR_4 != ';' && !ISSPACE(*VAR_4))\n            VAR_4++;\n          if (VAR_4-VAR_2 >= 32)\n            return VAR_8;\n          memcpy(VAR_7, VAR_2, VAR_4-VAR_2);\n          VAR_7[VAR_4-VAR_2] = '\\0';\n          VAR_2 = VAR_9;\n        }\n      else\n        VAR_7[0] = '\\0';\n      /* COMMENT_3 */\n      /* COMMENT_4 */\n      if ((VAR_5 = ares_inet_net_pton(VAR_10, VAR_7[0] ? VAR_7 : VAR_6,\n                                     &VAR_3.addrV6,\n                                     sizeof(VAR_3.addrV6))) > 0)\n        {\n          VAR_3.type = VAR_11;\n          VAR_3.mask.bits = (unsigned short)VAR_5;\n          VAR_3.family = VAR_10;\n          if (!sortlist_alloc(VAR_0, VAR_1, &VAR_3)) {\n            ares_free(*VAR_0);\n            *VAR_0 = NULL;\n            return VAR_12;\n          }\n        }\n      else if (VAR_7[0] &&\n               (VAR_5 = ares_inet_net_pton(VAR_13, VAR_7, &VAR_3.addrV4,\n                                          sizeof(VAR_3.addrV4))) > 0)\n        {\n          VAR_3.type = VAR_11;\n          VAR_3.mask.bits = (unsigned short)VAR_5;\n          VAR_3.family = VAR_13;\n          if (!sortlist_alloc(VAR_0, VAR_1, &VAR_3)) {\n            ares_free(*VAR_0);\n            *VAR_0 = NULL;\n            return VAR_12;\n          }\n        }\n      /* COMMENT_5 */\n      else if (ip_addr(VAR_6, VAR_4-VAR_2, &VAR_3.addrV4) == 0)\n        {\n          if (VAR_7[0])\n            {\n              memcpy(VAR_6, VAR_2, VAR_4-VAR_2);\n              VAR_6[VAR_4-VAR_2] = '\\0';\n              if (ip_addr(VAR_6, VAR_4-VAR_2, &VAR_3.mask.addr4) != 0)\n                natural_mask(&VAR_3);\n            }\n          else\n            natural_mask(&VAR_3);\n          VAR_3.family = VAR_13;\n          VAR_3.type = VAR_14;\n          if (!sortlist_alloc(VAR_0, VAR_1, &VAR_3)) {\n            ares_free(*VAR_0);\n            *VAR_0 = NULL;\n            return VAR_12;\n          }\n        }\n      else\n        {\n          while (*VAR_4 && *VAR_4 != ';' && !ISSPACE(*VAR_4))\n            VAR_4++;\n        }\n      VAR_2 = VAR_4;\n      while (ISSPACE(*VAR_2))\n        VAR_2++;\n    }\n\n  return VAR_15;\n}",
  "func_graph_path": "c-ares/ac596026e77244481fd68736ae7f15855803a08a/ares_init.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -13,6 +13,8 @@\n       q = str;\n       while (*q && *q != '/' && *q != ';' && !ISSPACE(*q))\n         q++;\n+      if (q-str >= 16)\n+        return ARES_EBADSTR;\n       memcpy(ipbuf, str, q-str);\n       ipbuf[q-str] = '\\0';\n       /* Find the prefix */\n@@ -21,6 +23,8 @@\n           const char *str2 = q+1;\n           while (*q && *q != ';' && !ISSPACE(*q))\n             q++;\n+          if (q-str >= 32)\n+            return ARES_EBADSTR;\n           memcpy(ipbufpfx, str, q-str);\n           ipbufpfx[q-str] = '\\0';\n           str = str2;",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "      if (q-str >= 16)",
      "        return ARES_EBADSTR;",
      "          if (q-str >= 32)",
      "            return ARES_EBADSTR;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/c-ares/c-ares/pull/497",
  "description": {
    "pr_info": {
      "title": "Add str len check in config_sortlist to avoid stack overflow",
      "number": 497
    },
    "comment": [
      "In `ares_set_sortlist`, it calls `config_sortlist(..., sortstr)` to parse the input str and initialize a sortlist configuration.\r\n\r\nHowever, `ares_set_sortlist` has not any checks about the validity of the input str. It is very easy to create an arbitrary length stack overflow with the unchecked `memcpy(ipbuf, str, q-str);` and `memcpy(ipbufpfx, str, q-str);` statements in the config_sortlist call, which could potentially cause severe security impact in practical programs.\r\n\r\nThis commit add necessary check for `ipbuf` and `ipbufpfx` which avoid the potential stack overflows.\r\n\r\nfixes #496\r\n\r\nSigned-off-by: hopper-vul <hopper.vul@gmail.com>",
      "I'm not aware of any users of this interface, but in general it just looks broken to me.\r\n\r\nIt looks like via the documentation its supposed to *only* take ip addresses or ip addresses with subnet masks, however looking at the pre-existing test cases, its accepting garbage and actively being tested to ensure it accepts garbage ???",
      "Yes, the `str` in document are constrained by \"The provided sortstr string that holds a space separated list of IP-address-netmask pairs\", but adding a few checks to avoid potential security bugs isn't a bad thing overall.\r\n\r\nIn current change, if it detects overflow (or means bad input string), it will return with a `ARES_EBADSTR`. Thus, i added the two test cases with the minimal invalid strings input in the `SetSortlistFailures` test (which i think it is to trigger some failures) to test whether the added checks work.\r\n\r\n",
      "JFTR, this was assigned CVE-2022-4904 (via https://bugzilla.redhat.com/show_bug.cgi?id=2168631)",
      "@mmuehlenhoff thanks for maintaining the record :)"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95"
}