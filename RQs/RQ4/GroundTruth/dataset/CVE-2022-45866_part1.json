{
  "cve_id": "CVE-2022-45866",
  "cwe_ids": [
    "CWE-22"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N",
  "cvss_is_v3": true,
  "repo_name": "PierreLvx/qpress",
  "commit_msg": "Fix qpress directory traversal vulnerability\n\nA bad actor user can prepare the payload as:\n\n```\nmkdir -p AAAAAAAAA/secure_file_priv_dir\ntouch AAAAAAAAA/secure_file_priv_dir/evil.so\nqpress -r AAAAAAAAA payload.qp\nThen edit the payload.qp in a hex editor or sed to replace AAAAAAAAA with ../../../\n(example: sed -i 's/AAAAAAAAA/..\\/..\\/..\\//' payload.qp)\n```\n\nFix bug by checking the directory and reject the command if find the attempt to traversal\n\nTest: see example above and try to reproduce it. Before fix you can observe\ntraversal. After fix - the error message(File path contains directory traversal\nwhich is not allowed.) shown, no traversal observe.\n\nAll new code of the whole pull request, including one or several files\nthat are either new files or modified ones, are contributed under the BSD-new\nlicense.  I am contributing on behalf of my employer Amazon Web Services,\nInc.",
  "commit_hash": "02a79a793f56e86e2014a606647b158b246811e3",
  "git_url": "https://github.com/PierreLvx/qpress/commit/02a79a793f56e86e2014a606647b158b246811e3",
  "file_path": "qpress.cpp",
  "func_name": "decompress_directory",
  "func_before": "void decompress_directory(string extract_dir, bool std_out)\n{\n    char c;\n    string curdir;\n    size_t r = 0;\n    unsigned int chunk_size;\n\n    curdir = string(extract_dir);\n\n    for(;;)\n    {\n        r = aread(&c, 1);\n        if (r == 0)\n            return;\n\n        if(c == 'D')\n        {\n\t\t\t// read directory name, append it to current path and create the directory\n            chunk_size = fread32();\n            try_aread(tmp, chunk_size + 1);\n            curdir = curdir + DELIM_STR + tmp;\n            PRINT(FILES_PROCESSED, \"%s%s%s\\n\", BLANK_LINE, remove_leading_curdir(curdir).c_str(), DELIM_STR);\n            if(!std_out)\n            {\n#ifdef WINDOWS\n                CreateDirectory(curdir.c_str(), 0);\n#else\n                mkdir(curdir.c_str(), 509);\n#endif\n            }\n        }\n        else if(c == 'U')\n            curdir = curdir.substr(0, curdir.find_last_of(DELIM_STR)); // remove last sub dir from current path\n        else if(c == 'F')\n        {\n            chunk_size = fread32(); // read length of file name\n            try_aread(tmp, chunk_size + 1); // read file name\n            string buf2 = curdir + DELIM_STR + tmp;\n            PRINT(FILES_PROCESSED, \"%s    %s\\n\", BLANK_LINE, tmp);\n            if(!std_out)\n            {\n                if(exists(buf2) && !force_flag)\n                    abort(\"Destination file '%s' already exists - aborted\", buf2.c_str());\n                else\n                    decompress_file(buf2);\n            }\n            else\n                decompress_file(\"<stdout>\");\n        }\n        else\n            abort(\"Source file is corrupted - try the -R flag to recover\");\n    }\n}",
  "abstract_func_before": "void decompress_directory(string VAR_0, bool VAR_1)\n{\n    char VAR_2;\n    string VAR_3;\n    size_t VAR_4 = 0;\n    unsigned int VAR_5;\n\n    VAR_3 = string(VAR_0);\n\n    for(;;)\n    {\n        VAR_4 = aread(&VAR_2, 1);\n        if (VAR_4 == 0)\n            return;\n\n        if(VAR_2 == 'D')\n        {\n\t\t\t/* COMMENT_0 */\n            VAR_5 = fread32();\n            try_aread(VAR_6, VAR_5 + 1);\n            VAR_3 = VAR_3 + VAR_7 + VAR_6;\n            PRINT(VAR_8, \"%s%s%s\\n\", VAR_9, remove_leading_curdir(VAR_3).c_str(), VAR_7);\n            if(!VAR_1)\n            {\n#ifdef VAR_10\n                CreateDirectory(VAR_3.c_str(), 0);\n#else\n                mkdir(VAR_3.c_str(), 509);\n#endif\n            }\n        }\n        else if(VAR_2 == 'U')\n            VAR_3 = VAR_3.substr(0, VAR_3.find_last_of(VAR_7)); /* COMMENT_1 */\n        else if(VAR_2 == 'F')\n        {\n            VAR_5 = fread32(); /* COMMENT_2 */\n            try_aread(VAR_6, VAR_5 + 1); /* COMMENT_3 */\n            string VAR_11 = VAR_3 + VAR_7 + VAR_6;\n            PRINT(VAR_8, \"%s    %s\\n\", VAR_9, VAR_6);\n            if(!VAR_1)\n            {\n                if(exists(VAR_11) && !VAR_12)\n                    abort(\"Destination file '%s' already exists - aborted\", VAR_11.c_str());\n                else\n                    decompress_file(VAR_11);\n            }\n            else\n                decompress_file(\"<stdout>\");\n        }\n        else\n            abort(\"Source file is corrupted - try the -R flag to recover\");\n    }\n}",
  "func_graph_path_before": "PierreLvx/qpress/02a79a793f56e86e2014a606647b158b246811e3/qpress.cpp/vul/before/0.json",
  "func": "void decompress_directory(string extract_dir, bool std_out)\n{\n    char c;\n    string curdir;\n    size_t r = 0;\n    unsigned int chunk_size;\n\n    curdir = string(extract_dir);\n\n    for(;;)\n    {\n        r = aread(&c, 1);\n        if (r == 0)\n            return;\n\n        if(c == 'D')\n        {\n\t\t\t// read directory name, append it to current path and create the directory\n            chunk_size = fread32();\n\t\t\tif(NAME_BUFFER_SIZE < chunk_size + 1)\n            {\n                abort(\"File path string is bigger than buffer size\");\n            }\n            try_aread(tmp, chunk_size + 1);\n            curdir = curdir + DELIM_STR + tmp;\n            PRINT(FILES_PROCESSED, \"%s%s%s\\n\", BLANK_LINE, remove_leading_curdir(curdir).c_str(), DELIM_STR);\n\t\t\t/* RDS security fix: https://rds-jira.amazon.com/browse/MMCP-231\n\t \t\tNeed to check if we try to decompress file or directory outside working directory\n\t \t\t*/\n\t        if(true == check_if_path_has_dir_traversal(tmp)) \n            {\n\t            abort(\"Directory path contains directory traversal which is not allowed.\");\n\t        }\n\t        /* End of RDS security fix*/\n            if(!std_out)\n            {\n#ifdef WINDOWS\n                CreateDirectory(curdir.c_str(), 0);\n#else\n                mkdir(curdir.c_str(), 509);\n#endif\n            }\n        }\n        else if(c == 'U')\n            curdir = curdir.substr(0, curdir.find_last_of(DELIM_STR)); // remove last sub dir from current path\n        else if(c == 'F')\n        {\n            chunk_size = fread32(); // read length of file name\n            if(NAME_BUFFER_SIZE < chunk_size + 1)\n\t             {\n\t                 abort(\"File path string is bigger than buffer size\");\n\t             }\n\t             try_aread(tmp, chunk_size + 1); // read file name to 'tmp' with size 'chunk_size + 1'\n\t         /* RDS security fix: https://rds-jira.amazon.com/browse/MMCP-231\n\t \t\t   Need to check if we try to decompress file or directory outside working directory\n\t \t\t*/\n\t         if(true == check_if_path_has_dir_traversal(tmp)) \n\t         {\n\t             abort(\"File path contains directory traversal which is not allowed.\");\n\t         }\n\t         /* End of RDS security fix*/\n            string buf2 = curdir + DELIM_STR + tmp;\n            PRINT(FILES_PROCESSED, \"%s    %s\\n\", BLANK_LINE, tmp);\n            if(!std_out)\n            {\n                if(exists(buf2) && !force_flag)\n                    abort(\"Destination file '%s' already exists - aborted\", buf2.c_str());\n                else\n                    decompress_file(buf2);\n            }\n            else\n                decompress_file(\"<stdout>\");\n        }\n        else\n            abort(\"Source file is corrupted - try the -R flag to recover\");\n    }\n}",
  "abstract_func": "void decompress_directory(string VAR_0, bool VAR_1)\n{\n    char VAR_2;\n    string VAR_3;\n    size_t VAR_4 = 0;\n    unsigned int VAR_5;\n\n    VAR_3 = string(VAR_0);\n\n    for(;;)\n    {\n        VAR_4 = aread(&VAR_2, 1);\n        if (VAR_4 == 0)\n            return;\n\n        if(VAR_2 == 'D')\n        {\n\t\t\t/* COMMENT_0 */\n            VAR_5 = fread32();\n\t\t\tif(VAR_6 < VAR_5 + 1)\n            {\n                abort(\"File path string is bigger than buffer size\");\n            }\n            try_aread(VAR_7, VAR_5 + 1);\n            VAR_3 = VAR_3 + VAR_8 + VAR_7;\n            PRINT(VAR_9, \"%s%s%s\\n\", VAR_10, remove_leading_curdir(VAR_3).c_str(), VAR_8);\n\t\t\t/* COMMENT_1 */\n                                                                                     \n      \n\t        if(true == check_if_path_has_dir_traversal(VAR_7)) \n            {\n\t            abort(\"Directory path contains directory traversal which is not allowed.\");\n\t        }\n\t        /* COMMENT_4 */\n            if(!VAR_1)\n            {\n#ifdef VAR_11\n                CreateDirectory(VAR_3.c_str(), 0);\n#else\n                mkdir(VAR_3.c_str(), 509);\n#endif\n            }\n        }\n        else if(VAR_2 == 'U')\n            VAR_3 = VAR_3.substr(0, VAR_3.find_last_of(VAR_8)); /* COMMENT_5 */\n        else if(VAR_2 == 'F')\n        {\n            VAR_5 = fread32(); /* COMMENT_6 */\n            if(VAR_6 < VAR_5 + 1)\n\t             {\n\t                 abort(\"File path string is bigger than buffer size\");\n\t             }\n\t             try_aread(VAR_7, VAR_5 + 1); /* COMMENT_7 */\n\t         /* COMMENT_8 */\n                                                                                        \n      \n\t         if(true == check_if_path_has_dir_traversal(VAR_7)) \n\t         {\n\t             abort(\"File path contains directory traversal which is not allowed.\");\n\t         }\n\t         /* COMMENT_4 */\n            string VAR_12 = VAR_3 + VAR_8 + VAR_7;\n            PRINT(VAR_9, \"%s    %s\\n\", VAR_10, VAR_7);\n            if(!VAR_1)\n            {\n                if(exists(VAR_12) && !VAR_13)\n                    abort(\"Destination file '%s' already exists - aborted\", VAR_12.c_str());\n                else\n                    decompress_file(VAR_12);\n            }\n            else\n                decompress_file(\"<stdout>\");\n        }\n        else\n            abort(\"Source file is corrupted - try the -R flag to recover\");\n    }\n}",
  "func_graph_path": "PierreLvx/qpress/02a79a793f56e86e2014a606647b158b246811e3/qpress.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -17,9 +17,21 @@\n         {\n \t\t\t// read directory name, append it to current path and create the directory\n             chunk_size = fread32();\n+\t\t\tif(NAME_BUFFER_SIZE < chunk_size + 1)\n+            {\n+                abort(\"File path string is bigger than buffer size\");\n+            }\n             try_aread(tmp, chunk_size + 1);\n             curdir = curdir + DELIM_STR + tmp;\n             PRINT(FILES_PROCESSED, \"%s%s%s\\n\", BLANK_LINE, remove_leading_curdir(curdir).c_str(), DELIM_STR);\n+\t\t\t/* RDS security fix: https://rds-jira.amazon.com/browse/MMCP-231\n+\t \t\tNeed to check if we try to decompress file or directory outside working directory\n+\t \t\t*/\n+\t        if(true == check_if_path_has_dir_traversal(tmp)) \n+            {\n+\t            abort(\"Directory path contains directory traversal which is not allowed.\");\n+\t        }\n+\t        /* End of RDS security fix*/\n             if(!std_out)\n             {\n #ifdef WINDOWS\n@@ -34,7 +46,19 @@\n         else if(c == 'F')\n         {\n             chunk_size = fread32(); // read length of file name\n-            try_aread(tmp, chunk_size + 1); // read file name\n+            if(NAME_BUFFER_SIZE < chunk_size + 1)\n+\t             {\n+\t                 abort(\"File path string is bigger than buffer size\");\n+\t             }\n+\t             try_aread(tmp, chunk_size + 1); // read file name to 'tmp' with size 'chunk_size + 1'\n+\t         /* RDS security fix: https://rds-jira.amazon.com/browse/MMCP-231\n+\t \t\t   Need to check if we try to decompress file or directory outside working directory\n+\t \t\t*/\n+\t         if(true == check_if_path_has_dir_traversal(tmp)) \n+\t         {\n+\t             abort(\"File path contains directory traversal which is not allowed.\");\n+\t         }\n+\t         /* End of RDS security fix*/\n             string buf2 = curdir + DELIM_STR + tmp;\n             PRINT(FILES_PROCESSED, \"%s    %s\\n\", BLANK_LINE, tmp);\n             if(!std_out)",
  "diff_line_info": {
    "deleted_lines": [
      "            try_aread(tmp, chunk_size + 1); // read file name"
    ],
    "added_lines": [
      "\t\t\tif(NAME_BUFFER_SIZE < chunk_size + 1)",
      "            {",
      "                abort(\"File path string is bigger than buffer size\");",
      "            }",
      "\t\t\t/* RDS security fix: https://rds-jira.amazon.com/browse/MMCP-231",
      "\t \t\tNeed to check if we try to decompress file or directory outside working directory",
      "\t \t\t*/",
      "\t        if(true == check_if_path_has_dir_traversal(tmp)) ",
      "            {",
      "\t            abort(\"Directory path contains directory traversal which is not allowed.\");",
      "\t        }",
      "\t        /* End of RDS security fix*/",
      "            if(NAME_BUFFER_SIZE < chunk_size + 1)",
      "\t             {",
      "\t                 abort(\"File path string is bigger than buffer size\");",
      "\t             }",
      "\t             try_aread(tmp, chunk_size + 1); // read file name to 'tmp' with size 'chunk_size + 1'",
      "\t         /* RDS security fix: https://rds-jira.amazon.com/browse/MMCP-231",
      "\t \t\t   Need to check if we try to decompress file or directory outside working directory",
      "\t \t\t*/",
      "\t         if(true == check_if_path_has_dir_traversal(tmp)) ",
      "\t         {",
      "\t             abort(\"File path contains directory traversal which is not allowed.\");",
      "\t         }",
      "\t         /* End of RDS security fix*/"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/PierreLvx/qpress/pull/6",
  "description": {
    "pr_info": {
      "title": "Fix qpress directory traversal vulnerability",
      "number": 6
    },
    "comment": [
      "A bad actor user can prepare the payload as:\r\n\r\n```\r\nmkdir -p AAAAAAAAA/secure_file_priv_dir\r\ntouch AAAAAAAAA/secure_file_priv_dir/evil.so\r\nqpress -r AAAAAAAAA payload.qp\r\nThen edit the payload.qp in a hex editor or sed to replace AAAAAAAAA with ../../../\r\n(example: sed -i 's/AAAAAAAAA/..\\/..\\/..\\//' payload.qp)\r\n```\r\n\r\nFix bug by checking the directory and reject the command if find the attempt to traversal\r\n\r\nTest: see example above and try to reproduce it. Before fix you can observe\r\ntraversal. After fix - the error message(File path contains directory traversal\r\nwhich is not allowed.) shown, no traversal observe.\r\n\r\nAll new code of the whole pull request, including one or several files\r\nthat are either new files or modified ones, are contributed under the BSD-new\r\nlicense.  I am contributing on behalf of my employer Amazon Web Services,\r\nInc.",
      "Thank you!",
      "Thanks for merging. Did you edit the commit before merging? It is no longer identical with our submission. Relevant fields such as author was changed.\r\n\r\nThis PR https://patch-diff.githubusercontent.com/raw/PierreLvx/qpress/pull/6.patch and merged commit https://github.com/PierreLvx/qpress/commit/ddb312090ebd5794e81bc6fb1dfb4e79eda48761.patch differ.",
      "I used Github's online interface to perform the merge.\r\n\r\nIt automatically edited the author (without any notice) and message but the code is unchanged. See:\r\n\r\n```\r\nâžœ  ~ diff 6.patch ddb312090ebd5794e81bc6fb1dfb4e79eda48761.patch\r\n1,4c1,4\r\n< From 02a79a793f56e86e2014a606647b158b246811e3 Mon Sep 17 00:00:00 2001\r\n< From: Mikhail Chalov <mcchalov@amazon.com>\r\n< Date: Wed, 14 Jul 2021 09:35:58 +0200\r\n< Subject: [PATCH] Fix qpress directory traversal vulnerability\r\n---\r\n> From ddb312090ebd5794e81bc6fb1dfb4e79eda48761 Mon Sep 17 00:00:00 2001\r\n> From: Mikhail Chalov <mike.chalov@gmail.com>\r\n> Date: Fri, 19 Aug 2022 14:33:18 -0700\r\n> Subject: [PATCH] Fix qpress directory traversal vulnerability (#6)\r\n25a26,27\r\n>\r\n> Co-authored-by: Mikhail Chalov <mcchalov@amazon.com>\r\n```"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}