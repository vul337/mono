{
  "cve_id": "CVE-2023-35847",
  "cwe_ids": [
    "CWE-908",
    "CWE-682"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "virtualsquare/picotcp",
  "commit_msg": "TCP: Fixed MSS size calculation. Set MSS lower bound.\n\nReported-by: \"P. Amsuo, Purdue University\"",
  "commit_hash": "eaf166009e44641e6570c576ba071217f100fd99",
  "git_url": "https://github.com/virtualsquare/picotcp/commit/eaf166009e44641e6570c576ba071217f100fd99",
  "file_path": "modules/pico_tcp.c",
  "func_name": "tcp_syn",
  "func_before": "static int tcp_syn(struct pico_socket *s, struct pico_frame *f)\n{\n    struct pico_socket_tcp *new = NULL;\n    struct pico_tcp_hdr *hdr = NULL;\n    uint16_t mtu;\n    if(s->number_of_pending_conn >= s->max_backlog)\n        return -1;\n\n    new = (struct pico_socket_tcp *)pico_socket_clone(s);\n    hdr = (struct pico_tcp_hdr *)f->transport_hdr;\n    if (!new)\n        return -1;\n\n#ifdef PICO_TCP_SUPPORT_SOCKET_STATS\n    if (!pico_timer_add(t->sock.stack, 2000, sock_stats, s)) {\n        tcp_dbg(\"TCP: Failed to start socket statistics timer\\n\");\n        return -1;\n    }\n#endif\n\n    new->sock.remote_port = ((struct pico_trans *)f->transport_hdr)->sport;\n#ifdef PICO_SUPPORT_IPV4\n    if (IS_IPV4(f)) {\n        new->sock.remote_addr.ip4.addr = ((struct pico_ipv4_hdr *)(f->net_hdr))->src.addr;\n        new->sock.local_addr.ip4.addr = ((struct pico_ipv4_hdr *)(f->net_hdr))->dst.addr;\n    }\n\n#endif\n#ifdef PICO_SUPPORT_IPV6\n    if (IS_IPV6(f)) {\n        new->sock.remote_addr.ip6 = ((struct pico_ipv6_hdr *)(f->net_hdr))->src;\n        new->sock.local_addr.ip6 = ((struct pico_ipv6_hdr *)(f->net_hdr))->dst;\n    }\n\n#endif\n    f->sock = &new->sock;\n    mtu = (uint16_t)pico_socket_get_mss(&new->sock);\n    new->mss = (uint16_t)(mtu - PICO_SIZE_TCPHDR);\n    if (tcp_parse_options(f) < 0)\n        return -1;\n    new->sock.stack = s->stack;\n    new->tcpq_in.max_size = PICO_DEFAULT_SOCKETQ;\n    new->tcpq_out.max_size = PICO_DEFAULT_SOCKETQ;\n    new->tcpq_hold.max_size = 2u * mtu;\n    new->rcv_nxt = long_be(hdr->seq) + 1;\n    new->snd_nxt = long_be(pico_paws());\n    new->snd_last = new->snd_nxt;\n    new->cwnd = PICO_TCP_IW;\n    new->ssthresh = (uint16_t)((uint16_t)(PICO_DEFAULT_SOCKETQ / new->mss) -  (((uint16_t)(PICO_DEFAULT_SOCKETQ / new->mss)) >> 3u));\n    new->recv_wnd = short_be(hdr->rwnd);\n    new->linger_timeout = PICO_SOCKET_LINGER_TIMEOUT;\n    s->number_of_pending_conn++;\n    new->sock.parent = s;\n    new->sock.wakeup = s->wakeup;\n    rto_set(new, PICO_TCP_RTO_MIN);\n    /* Initialize timestamp values */\n    new->sock.state = PICO_SOCKET_STATE_BOUND | PICO_SOCKET_STATE_CONNECTED | PICO_SOCKET_STATE_TCP_SYN_RECV;\n    pico_socket_add(&new->sock);\n    tcp_send_synack(&new->sock);\n    tcp_dbg(\"SYNACK sent, socket added. snd_nxt is %08x\\n\", new->snd_nxt);\n    return 0;\n}",
  "abstract_func_before": "static int tcp_syn(struct pico_socket *VAR_0, struct pico_frame *VAR_1)\n{\n    struct pico_socket_tcp *VAR_2 = NULL;\n    struct pico_tcp_hdr *VAR_3 = NULL;\n    uint16_t VAR_4;\n    if(VAR_0->number_of_pending_conn >= VAR_0->max_backlog)\n        return -1;\n\n    VAR_2 = (struct pico_socket_tcp *)pico_socket_clone(VAR_0);\n    VAR_3 = (struct pico_tcp_hdr *)VAR_1->transport_hdr;\n    if (!VAR_2)\n        return -1;\n\n#ifdef VAR_5\n    if (!pico_timer_add(VAR_6->sock.stack, 2000, VAR_7, VAR_0)) {\n        tcp_dbg(\"TCP: Failed to start socket statistics timer\\n\");\n        return -1;\n    }\n#endif\n\n    VAR_2->sock.remote_port = ((struct pico_trans *)VAR_1->transport_hdr)->sport;\n#ifdef VAR_8\n    if (IS_IPV4(VAR_1)) {\n        VAR_2->sock.remote_addr.ip4.addr = ((struct pico_ipv4_hdr *)(VAR_1->net_hdr))->src.addr;\n        VAR_2->sock.local_addr.ip4.addr = ((struct pico_ipv4_hdr *)(VAR_1->net_hdr))->dst.addr;\n    }\n\n#endif\n#ifdef VAR_9\n    if (IS_IPV6(VAR_1)) {\n        VAR_2->sock.remote_addr.ip6 = ((struct pico_ipv6_hdr *)(VAR_1->net_hdr))->src;\n        VAR_2->sock.local_addr.ip6 = ((struct pico_ipv6_hdr *)(VAR_1->net_hdr))->dst;\n    }\n\n#endif\n    VAR_1->sock = &VAR_2->sock;\n    VAR_4 = (uint16_t)pico_socket_get_mss(&VAR_2->sock);\n    VAR_2->mss = (uint16_t)(VAR_4 - VAR_10);\n    if (tcp_parse_options(VAR_1) < 0)\n        return -1;\n    VAR_2->sock.stack = VAR_0->stack;\n    VAR_2->tcpq_in.max_size = VAR_11;\n    VAR_2->tcpq_out.max_size = VAR_11;\n    VAR_2->tcpq_hold.max_size = 2u * VAR_4;\n    VAR_2->rcv_nxt = long_be(VAR_3->seq) + 1;\n    VAR_2->snd_nxt = long_be(pico_paws());\n    VAR_2->snd_last = VAR_2->snd_nxt;\n    VAR_2->cwnd = VAR_12;\n    VAR_2->ssthresh = (uint16_t)((uint16_t)(VAR_11 / VAR_2->mss) -  (((uint16_t)(VAR_11 / VAR_2->mss)) >> 3u));\n    VAR_2->recv_wnd = short_be(VAR_3->rwnd);\n    VAR_2->linger_timeout = VAR_13;\n    VAR_0->number_of_pending_conn++;\n    VAR_2->sock.parent = VAR_0;\n    VAR_2->sock.wakeup = VAR_0->wakeup;\n    rto_set(VAR_2, VAR_14);\n    /* COMMENT_0 */\n    VAR_2->sock.state = VAR_15 | VAR_16 | VAR_17;\n    pico_socket_add(&VAR_2->sock);\n    tcp_send_synack(&VAR_2->sock);\n    tcp_dbg(\"SYNACK sent, socket added. snd_nxt is %08x\\n\", VAR_2->snd_nxt);\n    return 0;\n}",
  "func_graph_path_before": "virtualsquare/picotcp/eaf166009e44641e6570c576ba071217f100fd99/pico_tcp.c/vul/before/2.json",
  "func": "static int tcp_syn(struct pico_socket *s, struct pico_frame *f)\n{\n    struct pico_socket_tcp *new = NULL;\n    struct pico_tcp_hdr *hdr = NULL;\n    uint16_t mtu;\n    if(s->number_of_pending_conn >= s->max_backlog)\n        return -1;\n\n    new = (struct pico_socket_tcp *)pico_socket_clone(s);\n    hdr = (struct pico_tcp_hdr *)f->transport_hdr;\n    if (!new)\n        return -1;\n\n#ifdef PICO_TCP_SUPPORT_SOCKET_STATS\n    if (!pico_timer_add(t->sock.stack, 2000, sock_stats, s)) {\n        tcp_dbg(\"TCP: Failed to start socket statistics timer\\n\");\n        return -1;\n    }\n#endif\n\n    new->sock.remote_port = ((struct pico_trans *)f->transport_hdr)->sport;\n#ifdef PICO_SUPPORT_IPV4\n    if (IS_IPV4(f)) {\n        new->sock.remote_addr.ip4.addr = ((struct pico_ipv4_hdr *)(f->net_hdr))->src.addr;\n        new->sock.local_addr.ip4.addr = ((struct pico_ipv4_hdr *)(f->net_hdr))->dst.addr;\n    }\n\n#endif\n#ifdef PICO_SUPPORT_IPV6\n    if (IS_IPV6(f)) {\n        new->sock.remote_addr.ip6 = ((struct pico_ipv6_hdr *)(f->net_hdr))->src;\n        new->sock.local_addr.ip6 = ((struct pico_ipv6_hdr *)(f->net_hdr))->dst;\n    }\n\n#endif\n    f->sock = &new->sock;\n    mtu = (uint16_t)pico_socket_get_mss(&new->sock);\n    if (mtu > PICO_SIZE_TCPHDR + PICO_TCP_MIN_MSS)\n        new->mss = (uint16_t)(mtu - PICO_SIZE_TCPHDR);\n    else\n        new->mss = PICO_TCP_MIN_MSS;\n    if (tcp_parse_options(f) < 0)\n        return -1;\n    new->sock.stack = s->stack;\n    new->tcpq_in.max_size = PICO_DEFAULT_SOCKETQ;\n    new->tcpq_out.max_size = PICO_DEFAULT_SOCKETQ;\n    new->tcpq_hold.max_size = 2u * mtu;\n    new->rcv_nxt = long_be(hdr->seq) + 1;\n    new->snd_nxt = long_be(pico_paws());\n    new->snd_last = new->snd_nxt;\n    new->cwnd = PICO_TCP_IW;\n    new->ssthresh = (uint16_t)((uint16_t)(PICO_DEFAULT_SOCKETQ / new->mss) -  (((uint16_t)(PICO_DEFAULT_SOCKETQ / new->mss)) >> 3u));\n    new->recv_wnd = short_be(hdr->rwnd);\n    new->linger_timeout = PICO_SOCKET_LINGER_TIMEOUT;\n    s->number_of_pending_conn++;\n    new->sock.parent = s;\n    new->sock.wakeup = s->wakeup;\n    rto_set(new, PICO_TCP_RTO_MIN);\n    /* Initialize timestamp values */\n    new->sock.state = PICO_SOCKET_STATE_BOUND | PICO_SOCKET_STATE_CONNECTED | PICO_SOCKET_STATE_TCP_SYN_RECV;\n    pico_socket_add(&new->sock);\n    tcp_send_synack(&new->sock);\n    tcp_dbg(\"SYNACK sent, socket added. snd_nxt is %08x\\n\", new->snd_nxt);\n    return 0;\n}",
  "abstract_func": "static int tcp_syn(struct pico_socket *VAR_0, struct pico_frame *VAR_1)\n{\n    struct pico_socket_tcp *VAR_2 = NULL;\n    struct pico_tcp_hdr *VAR_3 = NULL;\n    uint16_t VAR_4;\n    if(VAR_0->number_of_pending_conn >= VAR_0->max_backlog)\n        return -1;\n\n    VAR_2 = (struct pico_socket_tcp *)pico_socket_clone(VAR_0);\n    VAR_3 = (struct pico_tcp_hdr *)VAR_1->transport_hdr;\n    if (!VAR_2)\n        return -1;\n\n#ifdef VAR_5\n    if (!pico_timer_add(VAR_6->sock.stack, 2000, VAR_7, VAR_0)) {\n        tcp_dbg(\"TCP: Failed to start socket statistics timer\\n\");\n        return -1;\n    }\n#endif\n\n    VAR_2->sock.remote_port = ((struct pico_trans *)VAR_1->transport_hdr)->sport;\n#ifdef VAR_8\n    if (IS_IPV4(VAR_1)) {\n        VAR_2->sock.remote_addr.ip4.addr = ((struct pico_ipv4_hdr *)(VAR_1->net_hdr))->src.addr;\n        VAR_2->sock.local_addr.ip4.addr = ((struct pico_ipv4_hdr *)(VAR_1->net_hdr))->dst.addr;\n    }\n\n#endif\n#ifdef VAR_9\n    if (IS_IPV6(VAR_1)) {\n        VAR_2->sock.remote_addr.ip6 = ((struct pico_ipv6_hdr *)(VAR_1->net_hdr))->src;\n        VAR_2->sock.local_addr.ip6 = ((struct pico_ipv6_hdr *)(VAR_1->net_hdr))->dst;\n    }\n\n#endif\n    VAR_1->sock = &VAR_2->sock;\n    VAR_4 = (uint16_t)pico_socket_get_mss(&VAR_2->sock);\n    if (VAR_4 > VAR_10 + VAR_11)\n        VAR_2->mss = (uint16_t)(VAR_4 - VAR_10);\n    else\n        VAR_2->mss = VAR_11;\n    if (tcp_parse_options(VAR_1) < 0)\n        return -1;\n    VAR_2->sock.stack = VAR_0->stack;\n    VAR_2->tcpq_in.max_size = VAR_12;\n    VAR_2->tcpq_out.max_size = VAR_12;\n    VAR_2->tcpq_hold.max_size = 2u * VAR_4;\n    VAR_2->rcv_nxt = long_be(VAR_3->seq) + 1;\n    VAR_2->snd_nxt = long_be(pico_paws());\n    VAR_2->snd_last = VAR_2->snd_nxt;\n    VAR_2->cwnd = VAR_13;\n    VAR_2->ssthresh = (uint16_t)((uint16_t)(VAR_12 / VAR_2->mss) -  (((uint16_t)(VAR_12 / VAR_2->mss)) >> 3u));\n    VAR_2->recv_wnd = short_be(VAR_3->rwnd);\n    VAR_2->linger_timeout = VAR_14;\n    VAR_0->number_of_pending_conn++;\n    VAR_2->sock.parent = VAR_0;\n    VAR_2->sock.wakeup = VAR_0->wakeup;\n    rto_set(VAR_2, VAR_15);\n    /* COMMENT_0 */\n    VAR_2->sock.state = VAR_16 | VAR_17 | VAR_18;\n    pico_socket_add(&VAR_2->sock);\n    tcp_send_synack(&VAR_2->sock);\n    tcp_dbg(\"SYNACK sent, socket added. snd_nxt is %08x\\n\", VAR_2->snd_nxt);\n    return 0;\n}",
  "func_graph_path": "virtualsquare/picotcp/eaf166009e44641e6570c576ba071217f100fd99/pico_tcp.c/vul/after/2.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -35,7 +35,10 @@\n #endif\n     f->sock = &new->sock;\n     mtu = (uint16_t)pico_socket_get_mss(&new->sock);\n-    new->mss = (uint16_t)(mtu - PICO_SIZE_TCPHDR);\n+    if (mtu > PICO_SIZE_TCPHDR + PICO_TCP_MIN_MSS)\n+        new->mss = (uint16_t)(mtu - PICO_SIZE_TCPHDR);\n+    else\n+        new->mss = PICO_TCP_MIN_MSS;\n     if (tcp_parse_options(f) < 0)\n         return -1;\n     new->sock.stack = s->stack;",
  "diff_line_info": {
    "deleted_lines": [
      "    new->mss = (uint16_t)(mtu - PICO_SIZE_TCPHDR);"
    ],
    "added_lines": [
      "    if (mtu > PICO_SIZE_TCPHDR + PICO_TCP_MIN_MSS)",
      "        new->mss = (uint16_t)(mtu - PICO_SIZE_TCPHDR);",
      "    else",
      "        new->mss = PICO_TCP_MIN_MSS;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/virtualsquare/picotcp/pull/15",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/virtualsquare/picotcp/pull/15: 403 Client Error: Forbidden for url: https://api.github.com/repos/virtualsquare/picotcp/pulls/15",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.9. \n\nThe changes address a potential buffer overflow risk by ensuring the MSS calculation doesn't result in an excessively low value, thereby preventing associated vulnerabilities. The code modifications align well with the described security fix. \n\n**Step-by-Step Explanation:**\n\n1. **Input Analysis:** Identified the commit message and code changes related to fixing MSS size calculation and setting a lower bound.\n2. **Consistency Check:** The commit message accurately reflects the code changes.\n3. **Purpose Evaluation:** The changes modify core TCP logic to prevent potential overflow issues, indicating a security fix.\n4. **Security Assessment:** The patch addresses a buffer-related issue, a common security concern, by enforcing a minimum MSS, preventing potential attacks.\n5. **Classification:** Determined as a security fix as it mitigates an exploit vector.\n6. **Confidence Scoring:** High confidence (0.9) due to clear alignment of the changes with security concerns."
}