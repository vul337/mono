{
  "cve_id": "CVE-2023-35846",
  "cwe_ids": [
    "CWE-Other",
    "CWE-682"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "virtualsquare/picotcp",
  "commit_msg": "[ipfilter] Check transport layer length in frame before filtering ports\n\nReported-by: \"P. Amsuo, Purdue University\"",
  "commit_hash": "d561990a358899178115e156871cc054a1c55ffe",
  "git_url": "https://github.com/virtualsquare/picotcp/commit/d561990a358899178115e156871cc054a1c55ffe",
  "file_path": "modules/pico_ipfilter.c",
  "func_name": "ipfilter",
  "func_before": "int ipfilter(struct pico_frame *f)\n{\n    struct filter_node temp;\n    struct pico_ipv4_hdr *ipv4_hdr = (struct pico_ipv4_hdr *) f->net_hdr;\n    struct pico_trans *trans;\n    struct pico_icmp4_hdr *icmp_hdr;\n\n    memset(&temp, 0u, sizeof(struct filter_node));\n\n    temp.fdev = f->dev;\n    temp.out_addr = ipv4_hdr->dst.addr;\n    temp.in_addr = ipv4_hdr->src.addr;\n    if ((ipv4_hdr->proto == PICO_PROTO_TCP) || (ipv4_hdr->proto == PICO_PROTO_UDP)) {\n        trans = (struct pico_trans *) f->transport_hdr;\n        temp.out_port = short_be(trans->dport);\n        temp.in_port = short_be(trans->sport);\n    }\n    else if(ipv4_hdr->proto == PICO_PROTO_ICMP4) {\n        icmp_hdr = (struct pico_icmp4_hdr *) f->transport_hdr;\n        if(icmp_hdr->type == PICO_ICMP_UNREACH && icmp_hdr->code == PICO_ICMP_UNREACH_FILTER_PROHIB)\n            return 0;\n    }\n\n    temp.proto = ipv4_hdr->proto;\n    temp.priority = f->priority;\n    temp.tos = ipv4_hdr->tos;\n    return ipfilter_apply_filter(f, &temp);\n}",
  "abstract_func_before": "int ipfilter(struct pico_frame *VAR_0)\n{\n    struct filter_node VAR_1;\n    struct pico_ipv4_hdr *VAR_2 = (struct pico_ipv4_hdr *) VAR_0->net_hdr;\n    struct pico_trans *VAR_3;\n    struct pico_icmp4_hdr *VAR_4;\n\n    memset(&VAR_1, 0u, sizeof(struct filter_node));\n\n    VAR_1.fdev = VAR_0->dev;\n    VAR_1.out_addr = VAR_2->dst.addr;\n    VAR_1.in_addr = VAR_2->src.addr;\n    if ((VAR_2->proto == VAR_5) || (VAR_2->proto == VAR_6)) {\n        VAR_3 = (struct pico_trans *) VAR_0->transport_hdr;\n        VAR_1.out_port = short_be(VAR_3->dport);\n        VAR_1.in_port = short_be(VAR_3->sport);\n    }\n    else if(VAR_2->proto == VAR_7) {\n        VAR_4 = (struct pico_icmp4_hdr *) VAR_0->transport_hdr;\n        if(VAR_4->type == VAR_8 && VAR_4->code == VAR_9)\n            return 0;\n    }\n\n    VAR_1.proto = VAR_2->proto;\n    VAR_1.priority = VAR_0->priority;\n    VAR_1.tos = VAR_2->tos;\n    return ipfilter_apply_filter(VAR_0, &VAR_1);\n}",
  "func_graph_path_before": "virtualsquare/picotcp/d561990a358899178115e156871cc054a1c55ffe/pico_ipfilter.c/vul/before/0.json",
  "func": "int ipfilter(struct pico_frame *f)\n{\n    struct filter_node temp;\n    struct pico_ipv4_hdr *ipv4_hdr = (struct pico_ipv4_hdr *) f->net_hdr;\n    struct pico_trans *trans;\n    struct pico_icmp4_hdr *icmp_hdr;\n\n    memset(&temp, 0u, sizeof(struct filter_node));\n\n    temp.fdev = f->dev;\n    temp.out_addr = ipv4_hdr->dst.addr;\n    temp.in_addr = ipv4_hdr->src.addr;\n    if ((f->transport_hdr + sizeof(struct pico_trans)) <= (f->buffer + f->buffer_len)) {\n        if ((ipv4_hdr->proto == PICO_PROTO_TCP) || (ipv4_hdr->proto == PICO_PROTO_UDP)) {\n                trans = (struct pico_trans *) f->transport_hdr;\n                temp.out_port = short_be(trans->dport);\n                temp.in_port = short_be(trans->sport);\n        } else if(ipv4_hdr->proto == PICO_PROTO_ICMP4) {\n            icmp_hdr = (struct pico_icmp4_hdr *) f->transport_hdr;\n            if(icmp_hdr->type == PICO_ICMP_UNREACH && icmp_hdr->code == PICO_ICMP_UNREACH_FILTER_PROHIB)\n                return 0;\n        }\n        temp.proto = ipv4_hdr->proto;\n    }\n    temp.priority = f->priority;\n    temp.tos = ipv4_hdr->tos;\n    return ipfilter_apply_filter(f, &temp);\n}",
  "abstract_func": "int ipfilter(struct pico_frame *VAR_0)\n{\n    struct filter_node VAR_1;\n    struct pico_ipv4_hdr *VAR_2 = (struct pico_ipv4_hdr *) VAR_0->net_hdr;\n    struct pico_trans *VAR_3;\n    struct pico_icmp4_hdr *VAR_4;\n\n    memset(&VAR_1, 0u, sizeof(struct filter_node));\n\n    VAR_1.fdev = VAR_0->dev;\n    VAR_1.out_addr = VAR_2->dst.addr;\n    VAR_1.in_addr = VAR_2->src.addr;\n    if ((VAR_0->transport_hdr + sizeof(struct pico_trans)) <= (VAR_0->buffer + VAR_0->buffer_len)) {\n        if ((VAR_2->proto == VAR_5) || (VAR_2->proto == VAR_6)) {\n                VAR_3 = (struct pico_trans *) VAR_0->transport_hdr;\n                VAR_1.out_port = short_be(VAR_3->dport);\n                VAR_1.in_port = short_be(VAR_3->sport);\n        } else if(VAR_2->proto == VAR_7) {\n            VAR_4 = (struct pico_icmp4_hdr *) VAR_0->transport_hdr;\n            if(VAR_4->type == VAR_8 && VAR_4->code == VAR_9)\n                return 0;\n        }\n        VAR_1.proto = VAR_2->proto;\n    }\n    VAR_1.priority = VAR_0->priority;\n    VAR_1.tos = VAR_2->tos;\n    return ipfilter_apply_filter(VAR_0, &VAR_1);\n}",
  "func_graph_path": "virtualsquare/picotcp/d561990a358899178115e156871cc054a1c55ffe/pico_ipfilter.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -10,18 +10,18 @@\n     temp.fdev = f->dev;\n     temp.out_addr = ipv4_hdr->dst.addr;\n     temp.in_addr = ipv4_hdr->src.addr;\n-    if ((ipv4_hdr->proto == PICO_PROTO_TCP) || (ipv4_hdr->proto == PICO_PROTO_UDP)) {\n-        trans = (struct pico_trans *) f->transport_hdr;\n-        temp.out_port = short_be(trans->dport);\n-        temp.in_port = short_be(trans->sport);\n+    if ((f->transport_hdr + sizeof(struct pico_trans)) <= (f->buffer + f->buffer_len)) {\n+        if ((ipv4_hdr->proto == PICO_PROTO_TCP) || (ipv4_hdr->proto == PICO_PROTO_UDP)) {\n+                trans = (struct pico_trans *) f->transport_hdr;\n+                temp.out_port = short_be(trans->dport);\n+                temp.in_port = short_be(trans->sport);\n+        } else if(ipv4_hdr->proto == PICO_PROTO_ICMP4) {\n+            icmp_hdr = (struct pico_icmp4_hdr *) f->transport_hdr;\n+            if(icmp_hdr->type == PICO_ICMP_UNREACH && icmp_hdr->code == PICO_ICMP_UNREACH_FILTER_PROHIB)\n+                return 0;\n+        }\n+        temp.proto = ipv4_hdr->proto;\n     }\n-    else if(ipv4_hdr->proto == PICO_PROTO_ICMP4) {\n-        icmp_hdr = (struct pico_icmp4_hdr *) f->transport_hdr;\n-        if(icmp_hdr->type == PICO_ICMP_UNREACH && icmp_hdr->code == PICO_ICMP_UNREACH_FILTER_PROHIB)\n-            return 0;\n-    }\n-\n-    temp.proto = ipv4_hdr->proto;\n     temp.priority = f->priority;\n     temp.tos = ipv4_hdr->tos;\n     return ipfilter_apply_filter(f, &temp);",
  "diff_line_info": {
    "deleted_lines": [
      "    if ((ipv4_hdr->proto == PICO_PROTO_TCP) || (ipv4_hdr->proto == PICO_PROTO_UDP)) {",
      "        trans = (struct pico_trans *) f->transport_hdr;",
      "        temp.out_port = short_be(trans->dport);",
      "        temp.in_port = short_be(trans->sport);",
      "    else if(ipv4_hdr->proto == PICO_PROTO_ICMP4) {",
      "        icmp_hdr = (struct pico_icmp4_hdr *) f->transport_hdr;",
      "        if(icmp_hdr->type == PICO_ICMP_UNREACH && icmp_hdr->code == PICO_ICMP_UNREACH_FILTER_PROHIB)",
      "            return 0;",
      "    }",
      "",
      "    temp.proto = ipv4_hdr->proto;"
    ],
    "added_lines": [
      "    if ((f->transport_hdr + sizeof(struct pico_trans)) <= (f->buffer + f->buffer_len)) {",
      "        if ((ipv4_hdr->proto == PICO_PROTO_TCP) || (ipv4_hdr->proto == PICO_PROTO_UDP)) {",
      "                trans = (struct pico_trans *) f->transport_hdr;",
      "                temp.out_port = short_be(trans->dport);",
      "                temp.in_port = short_be(trans->sport);",
      "        } else if(ipv4_hdr->proto == PICO_PROTO_ICMP4) {",
      "            icmp_hdr = (struct pico_icmp4_hdr *) f->transport_hdr;",
      "            if(icmp_hdr->type == PICO_ICMP_UNREACH && icmp_hdr->code == PICO_ICMP_UNREACH_FILTER_PROHIB)",
      "                return 0;",
      "        }",
      "        temp.proto = ipv4_hdr->proto;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/virtualsquare/picotcp/pull/15",
  "description": {
    "pr_info": {
      "title": "Various fixes on size calculation",
      "number": 15
    },
    "comment": [
      "- TCP: Fixed MSS size calculation, set lower MSS bound\r\n- TCP: Check options size before parsing MSS field\r\n- ipfilter: Check transport layer size before dereferencing port numbers\r\n- IPv4: Check transport layer size before calculating checksum",
      "There should be CVEs for these fixes."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "Final Classification: Security Vulnerability Fix; Confidence: 0.95\n\n**Confidence Justification:**\nThe commit message and code changes clearly target preventing buffer overflow by checking transport layer lengths. The changes add necessary bounds checks before accessing protocol-specific data, which directly mitigates a potential security risk. The alignment between the commit message and code is strong, and the context points to a security fix without ambiguity. The presence of bounds checking and the reference to a reported issue further supports this classification with high confidence."
}