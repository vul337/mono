{
  "cve_id": "CVE-2018-11697",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "sass/libsass",
  "commit_msg": "Fix memory leak in `parse_ie_keyword_arg`\n\n`kwd_arg` would never get freed when there was a parse error in\n`parse_ie_keyword_arg`.\n\nCloses #2656",
  "commit_hash": "4573dbf9de0f43d745f4694bf92933166e6761a9",
  "git_url": "https://github.com/sass/libsass/commit/4573dbf9de0f43d745f4694bf92933166e6761a9",
  "file_path": "src/parser.cpp",
  "func_name": "Parser::parse_ie_keyword_arg",
  "func_before": "String_Obj Parser::parse_ie_keyword_arg()\n  {\n    String_Schema_Ptr kwd_arg = SASS_MEMORY_NEW(String_Schema, pstate, 3);\n    if (lex< variable >()) {\n      kwd_arg->append(SASS_MEMORY_NEW(Variable, pstate, Util::normalize_underscores(lexed)));\n    } else {\n      lex< alternatives< identifier_schema, identifier > >();\n      kwd_arg->append(SASS_MEMORY_NEW(String_Constant, pstate, lexed));\n    }\n    lex< exactly<'='> >();\n    kwd_arg->append(SASS_MEMORY_NEW(String_Constant, pstate, lexed));\n    if (peek< variable >()) kwd_arg->append(parse_list());\n    else if (lex< number >()) {\n      std::string parsed(lexed);\n      Util::normalize_decimals(parsed);\n      kwd_arg->append(lexed_number(parsed));\n    }\n    else if (peek < ie_keyword_arg_value >()) { kwd_arg->append(parse_list()); }\n    return kwd_arg;\n  }",
  "abstract_func_before": "String_Obj Parser::parse_ie_keyword_arg()\n  {\n    String_Schema_Ptr VAR_0 = SASS_MEMORY_NEW(VAR_1, VAR_2, 3);\n    if (VAR_3< variable >()) {\n      VAR_0->append(SASS_MEMORY_NEW(VAR_4, VAR_2, Util::normalize_underscores(VAR_5)));\n    } else {\n      VAR_3< alternatives< identifier_schema, identifier > >();\n      VAR_0->append(SASS_MEMORY_NEW(VAR_6, VAR_2, VAR_5));\n    }\n    VAR_3< exactly<'='> >();\n    VAR_0->append(SASS_MEMORY_NEW(VAR_6, VAR_2, VAR_5));\n    if (VAR_7< variable >()) VAR_0->append(parse_list());\n    else if (VAR_3< number >()) {\n      std::string parsed(lexed);\n      Util::normalize_decimals(VAR_8);\n      VAR_0->append(lexed_number(VAR_8));\n    }\n    else if (VAR_7 < ie_keyword_arg_value >()) { VAR_0->append(parse_list()); }\n    return VAR_0;\n  }",
  "func_graph_path_before": "sass/libsass/4573dbf9de0f43d745f4694bf92933166e6761a9/parser.cpp/vul/before/0.json",
  "func": "String_Obj Parser::parse_ie_keyword_arg()\n  {\n    String_Schema_Obj kwd_arg = SASS_MEMORY_NEW(String_Schema, pstate, 3);\n    if (lex< variable >()) {\n      kwd_arg->append(SASS_MEMORY_NEW(Variable, pstate, Util::normalize_underscores(lexed)));\n    } else {\n      lex< alternatives< identifier_schema, identifier > >();\n      kwd_arg->append(SASS_MEMORY_NEW(String_Constant, pstate, lexed));\n    }\n    lex< exactly<'='> >();\n    kwd_arg->append(SASS_MEMORY_NEW(String_Constant, pstate, lexed));\n    if (peek< variable >()) kwd_arg->append(parse_list());\n    else if (lex< number >()) {\n      std::string parsed(lexed);\n      Util::normalize_decimals(parsed);\n      kwd_arg->append(lexed_number(parsed));\n    }\n    else if (peek < ie_keyword_arg_value >()) { kwd_arg->append(parse_list()); }\n    return kwd_arg;\n  }",
  "abstract_func": "String_Obj Parser::parse_ie_keyword_arg()\n  {\n    String_Schema_Obj VAR_0 = SASS_MEMORY_NEW(VAR_1, VAR_2, 3);\n    if (VAR_3< variable >()) {\n      VAR_0->append(SASS_MEMORY_NEW(VAR_4, VAR_2, Util::normalize_underscores(VAR_5)));\n    } else {\n      VAR_3< alternatives< identifier_schema, identifier > >();\n      VAR_0->append(SASS_MEMORY_NEW(VAR_6, VAR_2, VAR_5));\n    }\n    VAR_3< exactly<'='> >();\n    VAR_0->append(SASS_MEMORY_NEW(VAR_6, VAR_2, VAR_5));\n    if (VAR_7< variable >()) VAR_0->append(parse_list());\n    else if (VAR_3< number >()) {\n      std::string parsed(lexed);\n      Util::normalize_decimals(VAR_8);\n      VAR_0->append(lexed_number(VAR_8));\n    }\n    else if (VAR_7 < ie_keyword_arg_value >()) { VAR_0->append(parse_list()); }\n    return VAR_0;\n  }",
  "func_graph_path": "sass/libsass/4573dbf9de0f43d745f4694bf92933166e6761a9/parser.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n String_Obj Parser::parse_ie_keyword_arg()\n   {\n-    String_Schema_Ptr kwd_arg = SASS_MEMORY_NEW(String_Schema, pstate, 3);\n+    String_Schema_Obj kwd_arg = SASS_MEMORY_NEW(String_Schema, pstate, 3);\n     if (lex< variable >()) {\n       kwd_arg->append(SASS_MEMORY_NEW(Variable, pstate, Util::normalize_underscores(lexed)));\n     } else {",
  "diff_line_info": {
    "deleted_lines": [
      "    String_Schema_Ptr kwd_arg = SASS_MEMORY_NEW(String_Schema, pstate, 3);"
    ],
    "added_lines": [
      "    String_Schema_Obj kwd_arg = SASS_MEMORY_NEW(String_Schema, pstate, 3);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/sass/libsass/pull/2763",
  "description": {
    "pr_info": {
      "title": "Fix memory leak in `parse_ie_keyword_arg`",
      "number": 2763
    },
    "comment": [
      "`kwd_arg` would never get freed when there was a parse error in `parse_ie_keyword_arg`.\r\n\r\nCloses #2656"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "The patch addresses a memory leak, which is a security issue, by fixing how `kwd_arg` is managed to prevent it from being unfreed during a parse error. This indicates a clear security fix.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}