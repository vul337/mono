{
  "cve_id": "CVE-2022-1319",
  "cwe_ids": [
    "CWE-252"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "undertow-io/undertow",
  "commit_msg": "[UNDERTOW-2060] fix double AJP response",
  "commit_hash": "1443a1a2bbb8e32e56788109d8285db250d55c8b",
  "git_url": "https://github.com/undertow-io/undertow/commit/1443a1a2bbb8e32e56788109d8285db250d55c8b",
  "file_path": "core/src/main/java/io/undertow/server/protocol/ajp/AjpReadListener.java",
  "func_name": "handleEvent",
  "func_before": "public void handleEvent(final StreamSourceChannel channel) {\n        if(connection.getOriginalSinkConduit().isWriteShutdown() || connection.getOriginalSourceConduit().isReadShutdown()) {\n            safeClose(connection);\n            channel.suspendReads();\n            return;\n        }\n\n        PooledByteBuffer existing = connection.getExtraBytes();\n\n        final PooledByteBuffer pooled = existing == null ? connection.getByteBufferPool().allocate() : existing;\n        final ByteBuffer buffer = pooled.getBuffer();\n        boolean free = true;\n        boolean bytesRead = false;\n        try {\n            int res;\n            do {\n                if (existing == null) {\n                    buffer.clear();\n                    res = channel.read(buffer);\n                } else {\n                    res = buffer.remaining();\n                }\n                if (res == 0) {\n\n                    if(bytesRead && parseTimeoutUpdater != null) {\n                        parseTimeoutUpdater.failedParse();\n                    }\n                    if (!channel.isReadResumed()) {\n                        channel.getReadSetter().set(this);\n                        channel.resumeReads();\n                    }\n                    return;\n                }\n                if (res == -1) {\n                    channel.shutdownReads();\n                    final StreamSinkChannel responseChannel = connection.getChannel().getSinkChannel();\n                    responseChannel.shutdownWrites();\n                    safeClose(connection);\n                    return;\n                }\n                bytesRead = true;\n                //TODO: we need to handle parse errors\n                if (existing != null) {\n                    existing = null;\n                    connection.setExtraBytes(null);\n                } else {\n                    buffer.flip();\n                }\n                int begin = buffer.remaining();\n                if(httpServerExchange == null) {\n                    httpServerExchange = new HttpServerExchange(connection, maxEntitySize);\n                }\n                parser.parse(buffer, state, httpServerExchange);\n\n                read += begin - buffer.remaining();\n                if (buffer.hasRemaining()) {\n                    free = false;\n                    connection.setExtraBytes(pooled);\n                }\n                if (read > maxRequestSize) {\n                    UndertowLogger.REQUEST_LOGGER.requestHeaderWasTooLarge(connection.getPeerAddress(), maxRequestSize);\n                    safeClose(connection);\n                    return;\n                }\n            } while (!state.isComplete());\n\n            if(parseTimeoutUpdater != null) {\n                parseTimeoutUpdater.requestStarted();\n            }\n            if (state.prefix != AjpRequestParser.FORWARD_REQUEST) {\n                if (state.prefix == AjpRequestParser.CPING) {\n                    UndertowLogger.REQUEST_LOGGER.debug(\"Received CPING, sending CPONG\");\n                    handleCPing();\n                } else if (state.prefix == AjpRequestParser.CPONG) {\n                    UndertowLogger.REQUEST_LOGGER.debug(\"Received CPONG, starting next request\");\n                    state = new AjpRequestParseState();\n                    channel.getReadSetter().set(this);\n                    channel.resumeReads();\n                } else {\n                    UndertowLogger.REQUEST_LOGGER.ignoringAjpRequestWithPrefixCode(state.prefix);\n                    safeClose(connection);\n                }\n                return;\n            }\n\n            // we remove ourselves as the read listener from the channel;\n            // if the http handler doesn't set any then reads will suspend, which is the right thing to do\n            channel.getReadSetter().set(null);\n            channel.suspendReads();\n\n            final HttpServerExchange httpServerExchange = this.httpServerExchange;\n            final AjpServerResponseConduit responseConduit = new AjpServerResponseConduit(connection.getChannel().getSinkChannel().getConduit(), connection.getByteBufferPool(), httpServerExchange, new ConduitListener<AjpServerResponseConduit>() {\n                @Override\n                public void handleEvent(AjpServerResponseConduit channel) {\n                    Connectors.terminateResponse(httpServerExchange);\n                }\n            }, httpServerExchange.getRequestMethod().equals(Methods.HEAD));\n            connection.getChannel().getSinkChannel().setConduit(responseConduit);\n            connection.getChannel().getSourceChannel().setConduit(createSourceConduit(connection.getChannel().getSourceChannel().getConduit(), responseConduit, httpServerExchange));\n            //we need to set the write ready handler. This allows the response conduit to wrap it\n            responseConduit.setWriteReadyHandler(writeReadyHandler);\n\n            connection.setSSLSessionInfo(state.createSslSessionInfo());\n            httpServerExchange.setSourceAddress(state.createPeerAddress());\n            httpServerExchange.setDestinationAddress(state.createDestinationAddress());\n            if(scheme != null) {\n                httpServerExchange.setRequestScheme(scheme);\n            }\n            if(state.attributes != null) {\n                httpServerExchange.putAttachment(HttpServerExchange.REQUEST_ATTRIBUTES, state.attributes);\n            }\n            AjpRequestParseState oldState = state;\n            state = null;\n            this.httpServerExchange = null;\n            httpServerExchange.setPersistent(true);\n\n            if(recordRequestStartTime) {\n                Connectors.setRequestStartTime(httpServerExchange);\n            }\n            connection.setCurrentExchange(httpServerExchange);\n            if(connectorStatistics != null) {\n                connectorStatistics.setup(httpServerExchange);\n            }\n            if(!Connectors.areRequestHeadersValid(httpServerExchange.getRequestHeaders())) {\n                oldState.badRequest = true;\n                UndertowLogger.REQUEST_IO_LOGGER.debugf(\"Invalid AJP request from %s, request contained invalid headers\", connection.getPeerAddress());\n            }\n\n            if(oldState.badRequest) {\n                httpServerExchange.setStatusCode(StatusCodes.BAD_REQUEST);\n                httpServerExchange.endExchange();\n                handleBadRequest();\n                safeClose(connection);\n            } else {\n                Connectors.executeRootHandler(connection.getRootHandler(), httpServerExchange);\n            }\n        } catch (BadRequestException e) {\n            UndertowLogger.REQUEST_IO_LOGGER.failedToParseRequest(e);\n            handleBadRequest();\n            safeClose(connection);\n        } catch (IOException e) {\n            UndertowLogger.REQUEST_IO_LOGGER.ioException(e);\n            handleInternalServerError();\n            safeClose(connection);\n        } catch (Throwable t) {\n            UndertowLogger.REQUEST_LOGGER.exceptionProcessingRequest(t);\n            handleInternalServerError();\n            safeClose(connection);\n        } finally {\n            if (free) pooled.close();\n        }\n    }",
  "abstract_func_before": "public void handleEvent(final StreamSourceChannel VAR_0) {\n        if(VAR_1.getOriginalSinkConduit().isWriteShutdown() || VAR_1.getOriginalSourceConduit().isReadShutdown()) {\n            safeClose(VAR_1);\n            VAR_0.suspendReads();\n            return;\n        }\n\n        PooledByteBuffer VAR_2 = VAR_1.getExtraBytes();\n\n        final PooledByteBuffer VAR_3 = VAR_2 == null ? VAR_1.getByteBufferPool().allocate() : VAR_2;\n        final ByteBuffer VAR_4 = VAR_3.getBuffer();\n        boolean VAR_5 = true;\n        boolean VAR_6 = false;\n        try {\n            int VAR_7;\n            do {\n                if (VAR_2 == null) {\n                    VAR_4.clear();\n                    VAR_7 = VAR_0.read(VAR_4);\n                } else {\n                    VAR_7 = VAR_4.remaining();\n                }\n                if (VAR_7 == 0) {\n\n                    if(VAR_6 && VAR_8 != null) {\n                        VAR_8.failedParse();\n                    }\n                    if (!VAR_0.isReadResumed()) {\n                        VAR_0.getReadSetter().set(this);\n                        VAR_0.resumeReads();\n                    }\n                    return;\n                }\n                if (VAR_7 == -1) {\n                    VAR_0.shutdownReads();\n                    final StreamSinkChannel VAR_9 = VAR_1.getChannel().getSinkChannel();\n                    VAR_9.shutdownWrites();\n                    safeClose(VAR_1);\n                    return;\n                }\n                VAR_6 = true;\n                /* COMMENT_0 */\n                if (VAR_2 != null) {\n                    VAR_2 = null;\n                    VAR_1.setExtraBytes(null);\n                } else {\n                    VAR_4.flip();\n                }\n                int VAR_10 = VAR_4.remaining();\n                if(VAR_11 == null) {\n                    VAR_11 = new HttpServerExchange(VAR_1, VAR_12);\n                }\n                VAR_13.parse(VAR_4, VAR_14, VAR_11);\n\n                VAR_15 += VAR_10 - VAR_4.remaining();\n                if (VAR_4.hasRemaining()) {\n                    VAR_5 = false;\n                    VAR_1.setExtraBytes(VAR_3);\n                }\n                if (VAR_15 > VAR_16) {\n                    VAR_17.REQUEST_LOGGER.requestHeaderWasTooLarge(VAR_1.getPeerAddress(), VAR_16);\n                    safeClose(VAR_1);\n                    return;\n                }\n            } while (!VAR_14.isComplete());\n\n            if(VAR_8 != null) {\n                VAR_8.requestStarted();\n            }\n            if (VAR_14.prefix != VAR_18.FORWARD_REQUEST) {\n                if (VAR_14.prefix == VAR_18.CPING) {\n                    VAR_17.REQUEST_LOGGER.debug(\"Received CPING, sending CPONG\");\n                    handleCPing();\n                } else if (VAR_14.prefix == VAR_18.CPONG) {\n                    VAR_17.REQUEST_LOGGER.debug(\"Received CPONG, starting next request\");\n                    VAR_14 = new AjpRequestParseState();\n                    VAR_0.getReadSetter().set(this);\n                    VAR_0.resumeReads();\n                } else {\n                    VAR_17.REQUEST_LOGGER.ignoringAjpRequestWithPrefixCode(VAR_14.prefix);\n                    safeClose(VAR_1);\n                }\n                return;\n            }\n\n            /* COMMENT_1 */\n            /* COMMENT_2 */\n            VAR_0.getReadSetter().set(null);\n            VAR_0.suspendReads();\n\n            final HttpServerExchange VAR_11 = this.httpServerExchange;\n            final AjpServerResponseConduit VAR_19 = new AjpServerResponseConduit(VAR_1.getChannel().getSinkChannel().getConduit(), VAR_1.getByteBufferPool(), VAR_11, new ConduitListener<AjpServerResponseConduit>() {\n                @Override\n                public void handleEvent(AjpServerResponseConduit VAR_0) {\n                    VAR_20.terminateResponse(VAR_11);\n                }\n            }, VAR_11.getRequestMethod().equals(VAR_21.HEAD));\n            VAR_1.getChannel().getSinkChannel().setConduit(VAR_19);\n            VAR_1.getChannel().getSourceChannel().setConduit(createSourceConduit(VAR_1.getChannel().getSourceChannel().getConduit(), VAR_19, VAR_11));\n            /* COMMENT_3 */\n            VAR_19.setWriteReadyHandler(VAR_22);\n\n            VAR_1.setSSLSessionInfo(VAR_14.createSslSessionInfo());\n            VAR_11.setSourceAddress(VAR_14.createPeerAddress());\n            VAR_11.setDestinationAddress(VAR_14.createDestinationAddress());\n            if(VAR_23 != null) {\n                VAR_11.setRequestScheme(VAR_23);\n            }\n            if(VAR_14.attributes != null) {\n                VAR_11.putAttachment(VAR_24.REQUEST_ATTRIBUTES, VAR_14.attributes);\n            }\n            AjpRequestParseState VAR_25 = VAR_14;\n            VAR_14 = null;\n            this.httpServerExchange = null;\n            VAR_11.setPersistent(true);\n\n            if(VAR_26) {\n                VAR_20.setRequestStartTime(VAR_11);\n            }\n            VAR_1.setCurrentExchange(VAR_11);\n            if(VAR_27 != null) {\n                VAR_27.setup(VAR_11);\n            }\n            if(!VAR_20.areRequestHeadersValid(VAR_11.getRequestHeaders())) {\n                VAR_25.badRequest = true;\n                VAR_17.REQUEST_IO_LOGGER.debugf(\"Invalid AJP request from %s, request contained invalid headers\", VAR_1.getPeerAddress());\n            }\n\n            if(VAR_25.badRequest) {\n                VAR_11.setStatusCode(VAR_28.BAD_REQUEST);\n                VAR_11.endExchange();\n                handleBadRequest();\n                safeClose(VAR_1);\n            } else {\n                VAR_20.executeRootHandler(VAR_1.getRootHandler(), VAR_11);\n            }\n        } catch (BadRequestException VAR_29) {\n            VAR_17.REQUEST_IO_LOGGER.failedToParseRequest(VAR_29);\n            handleBadRequest();\n            safeClose(VAR_1);\n        } catch (IOException VAR_29) {\n            VAR_17.REQUEST_IO_LOGGER.ioException(VAR_29);\n            handleInternalServerError();\n            safeClose(VAR_1);\n        } catch (Throwable VAR_30) {\n            VAR_17.REQUEST_LOGGER.exceptionProcessingRequest(VAR_30);\n            handleInternalServerError();\n            safeClose(VAR_1);\n        } finally {\n            if (VAR_5) VAR_3.close();\n        }\n    }",
  "func_graph_path_before": "undertow-io/undertow/1443a1a2bbb8e32e56788109d8285db250d55c8b/AjpReadListener.java/vul/before/0.json",
  "func": "public void handleEvent(final StreamSourceChannel channel) {\n        if(connection.getOriginalSinkConduit().isWriteShutdown() || connection.getOriginalSourceConduit().isReadShutdown()) {\n            safeClose(connection);\n            channel.suspendReads();\n            return;\n        }\n\n        PooledByteBuffer existing = connection.getExtraBytes();\n\n        final PooledByteBuffer pooled = existing == null ? connection.getByteBufferPool().allocate() : existing;\n        final ByteBuffer buffer = pooled.getBuffer();\n        boolean free = true;\n        boolean bytesRead = false;\n        try {\n            int res;\n            do {\n                if (existing == null) {\n                    buffer.clear();\n                    res = channel.read(buffer);\n                } else {\n                    res = buffer.remaining();\n                }\n                if (res == 0) {\n\n                    if(bytesRead && parseTimeoutUpdater != null) {\n                        parseTimeoutUpdater.failedParse();\n                    }\n                    if (!channel.isReadResumed()) {\n                        channel.getReadSetter().set(this);\n                        channel.resumeReads();\n                    }\n                    return;\n                }\n                if (res == -1) {\n                    channel.shutdownReads();\n                    final StreamSinkChannel responseChannel = connection.getChannel().getSinkChannel();\n                    responseChannel.shutdownWrites();\n                    safeClose(connection);\n                    return;\n                }\n                bytesRead = true;\n                //TODO: we need to handle parse errors\n                if (existing != null) {\n                    existing = null;\n                    connection.setExtraBytes(null);\n                } else {\n                    buffer.flip();\n                }\n                int begin = buffer.remaining();\n                if(httpServerExchange == null) {\n                    httpServerExchange = new HttpServerExchange(connection, maxEntitySize);\n                }\n                parser.parse(buffer, state, httpServerExchange);\n\n                read += begin - buffer.remaining();\n                if (buffer.hasRemaining()) {\n                    free = false;\n                    connection.setExtraBytes(pooled);\n                }\n                if (read > maxRequestSize) {\n                    UndertowLogger.REQUEST_LOGGER.requestHeaderWasTooLarge(connection.getPeerAddress(), maxRequestSize);\n                    safeClose(connection);\n                    return;\n                }\n            } while (!state.isComplete());\n\n            if(parseTimeoutUpdater != null) {\n                parseTimeoutUpdater.requestStarted();\n            }\n            if (state.prefix != AjpRequestParser.FORWARD_REQUEST) {\n                if (state.prefix == AjpRequestParser.CPING) {\n                    UndertowLogger.REQUEST_LOGGER.debug(\"Received CPING, sending CPONG\");\n                    handleCPing();\n                } else if (state.prefix == AjpRequestParser.CPONG) {\n                    UndertowLogger.REQUEST_LOGGER.debug(\"Received CPONG, starting next request\");\n                    state = new AjpRequestParseState();\n                    channel.getReadSetter().set(this);\n                    channel.resumeReads();\n                } else {\n                    UndertowLogger.REQUEST_LOGGER.ignoringAjpRequestWithPrefixCode(state.prefix);\n                    safeClose(connection);\n                }\n                return;\n            }\n\n            // we remove ourselves as the read listener from the channel;\n            // if the http handler doesn't set any then reads will suspend, which is the right thing to do\n            channel.getReadSetter().set(null);\n            channel.suspendReads();\n\n            final HttpServerExchange httpServerExchange = this.httpServerExchange;\n            final AjpServerResponseConduit responseConduit = new AjpServerResponseConduit(connection.getChannel().getSinkChannel().getConduit(), connection.getByteBufferPool(), httpServerExchange, new ConduitListener<AjpServerResponseConduit>() {\n                @Override\n                public void handleEvent(AjpServerResponseConduit channel) {\n                    Connectors.terminateResponse(httpServerExchange);\n                }\n            }, httpServerExchange.getRequestMethod().equals(Methods.HEAD));\n            connection.getChannel().getSinkChannel().setConduit(responseConduit);\n            connection.getChannel().getSourceChannel().setConduit(createSourceConduit(connection.getChannel().getSourceChannel().getConduit(), responseConduit, httpServerExchange));\n            //we need to set the write ready handler. This allows the response conduit to wrap it\n            responseConduit.setWriteReadyHandler(writeReadyHandler);\n\n            connection.setSSLSessionInfo(state.createSslSessionInfo());\n            httpServerExchange.setSourceAddress(state.createPeerAddress());\n            httpServerExchange.setDestinationAddress(state.createDestinationAddress());\n            if(scheme != null) {\n                httpServerExchange.setRequestScheme(scheme);\n            }\n            if(state.attributes != null) {\n                httpServerExchange.putAttachment(HttpServerExchange.REQUEST_ATTRIBUTES, state.attributes);\n            }\n            AjpRequestParseState oldState = state;\n            state = null;\n            this.httpServerExchange = null;\n            httpServerExchange.setPersistent(true);\n\n            if(recordRequestStartTime) {\n                Connectors.setRequestStartTime(httpServerExchange);\n            }\n            connection.setCurrentExchange(httpServerExchange);\n            if(connectorStatistics != null) {\n                connectorStatistics.setup(httpServerExchange);\n            }\n            if(!Connectors.areRequestHeadersValid(httpServerExchange.getRequestHeaders())) {\n                oldState.badRequest = true;\n                UndertowLogger.REQUEST_IO_LOGGER.debugf(\"Invalid AJP request from %s, request contained invalid headers\", connection.getPeerAddress());\n            }\n\n            if(oldState.badRequest) {\n                httpServerExchange.setStatusCode(StatusCodes.BAD_REQUEST);\n                httpServerExchange.endExchange();\n                safeClose(connection);\n            } else {\n                Connectors.executeRootHandler(connection.getRootHandler(), httpServerExchange);\n            }\n        } catch (BadRequestException e) {\n            UndertowLogger.REQUEST_IO_LOGGER.failedToParseRequest(e);\n            handleBadRequest();\n            safeClose(connection);\n        } catch (IOException e) {\n            UndertowLogger.REQUEST_IO_LOGGER.ioException(e);\n            handleInternalServerError();\n            safeClose(connection);\n        } catch (Throwable t) {\n            UndertowLogger.REQUEST_LOGGER.exceptionProcessingRequest(t);\n            handleInternalServerError();\n            safeClose(connection);\n        } finally {\n            if (free) pooled.close();\n        }\n    }",
  "abstract_func": "public void handleEvent(final StreamSourceChannel VAR_0) {\n        if(VAR_1.getOriginalSinkConduit().isWriteShutdown() || VAR_1.getOriginalSourceConduit().isReadShutdown()) {\n            safeClose(VAR_1);\n            VAR_0.suspendReads();\n            return;\n        }\n\n        PooledByteBuffer VAR_2 = VAR_1.getExtraBytes();\n\n        final PooledByteBuffer VAR_3 = VAR_2 == null ? VAR_1.getByteBufferPool().allocate() : VAR_2;\n        final ByteBuffer VAR_4 = VAR_3.getBuffer();\n        boolean VAR_5 = true;\n        boolean VAR_6 = false;\n        try {\n            int VAR_7;\n            do {\n                if (VAR_2 == null) {\n                    VAR_4.clear();\n                    VAR_7 = VAR_0.read(VAR_4);\n                } else {\n                    VAR_7 = VAR_4.remaining();\n                }\n                if (VAR_7 == 0) {\n\n                    if(VAR_6 && VAR_8 != null) {\n                        VAR_8.failedParse();\n                    }\n                    if (!VAR_0.isReadResumed()) {\n                        VAR_0.getReadSetter().set(this);\n                        VAR_0.resumeReads();\n                    }\n                    return;\n                }\n                if (VAR_7 == -1) {\n                    VAR_0.shutdownReads();\n                    final StreamSinkChannel VAR_9 = VAR_1.getChannel().getSinkChannel();\n                    VAR_9.shutdownWrites();\n                    safeClose(VAR_1);\n                    return;\n                }\n                VAR_6 = true;\n                /* COMMENT_0 */\n                if (VAR_2 != null) {\n                    VAR_2 = null;\n                    VAR_1.setExtraBytes(null);\n                } else {\n                    VAR_4.flip();\n                }\n                int VAR_10 = VAR_4.remaining();\n                if(VAR_11 == null) {\n                    VAR_11 = new HttpServerExchange(VAR_1, VAR_12);\n                }\n                VAR_13.parse(VAR_4, VAR_14, VAR_11);\n\n                VAR_15 += VAR_10 - VAR_4.remaining();\n                if (VAR_4.hasRemaining()) {\n                    VAR_5 = false;\n                    VAR_1.setExtraBytes(VAR_3);\n                }\n                if (VAR_15 > VAR_16) {\n                    VAR_17.REQUEST_LOGGER.requestHeaderWasTooLarge(VAR_1.getPeerAddress(), VAR_16);\n                    safeClose(VAR_1);\n                    return;\n                }\n            } while (!VAR_14.isComplete());\n\n            if(VAR_8 != null) {\n                VAR_8.requestStarted();\n            }\n            if (VAR_14.prefix != VAR_18.FORWARD_REQUEST) {\n                if (VAR_14.prefix == VAR_18.CPING) {\n                    VAR_17.REQUEST_LOGGER.debug(\"Received CPING, sending CPONG\");\n                    handleCPing();\n                } else if (VAR_14.prefix == VAR_18.CPONG) {\n                    VAR_17.REQUEST_LOGGER.debug(\"Received CPONG, starting next request\");\n                    VAR_14 = new AjpRequestParseState();\n                    VAR_0.getReadSetter().set(this);\n                    VAR_0.resumeReads();\n                } else {\n                    VAR_17.REQUEST_LOGGER.ignoringAjpRequestWithPrefixCode(VAR_14.prefix);\n                    safeClose(VAR_1);\n                }\n                return;\n            }\n\n            /* COMMENT_1 */\n            /* COMMENT_2 */\n            VAR_0.getReadSetter().set(null);\n            VAR_0.suspendReads();\n\n            final HttpServerExchange VAR_11 = this.httpServerExchange;\n            final AjpServerResponseConduit VAR_19 = new AjpServerResponseConduit(VAR_1.getChannel().getSinkChannel().getConduit(), VAR_1.getByteBufferPool(), VAR_11, new ConduitListener<AjpServerResponseConduit>() {\n                @Override\n                public void handleEvent(AjpServerResponseConduit VAR_0) {\n                    VAR_20.terminateResponse(VAR_11);\n                }\n            }, VAR_11.getRequestMethod().equals(VAR_21.HEAD));\n            VAR_1.getChannel().getSinkChannel().setConduit(VAR_19);\n            VAR_1.getChannel().getSourceChannel().setConduit(createSourceConduit(VAR_1.getChannel().getSourceChannel().getConduit(), VAR_19, VAR_11));\n            /* COMMENT_3 */\n            VAR_19.setWriteReadyHandler(VAR_22);\n\n            VAR_1.setSSLSessionInfo(VAR_14.createSslSessionInfo());\n            VAR_11.setSourceAddress(VAR_14.createPeerAddress());\n            VAR_11.setDestinationAddress(VAR_14.createDestinationAddress());\n            if(VAR_23 != null) {\n                VAR_11.setRequestScheme(VAR_23);\n            }\n            if(VAR_14.attributes != null) {\n                VAR_11.putAttachment(VAR_24.REQUEST_ATTRIBUTES, VAR_14.attributes);\n            }\n            AjpRequestParseState VAR_25 = VAR_14;\n            VAR_14 = null;\n            this.httpServerExchange = null;\n            VAR_11.setPersistent(true);\n\n            if(VAR_26) {\n                VAR_20.setRequestStartTime(VAR_11);\n            }\n            VAR_1.setCurrentExchange(VAR_11);\n            if(VAR_27 != null) {\n                VAR_27.setup(VAR_11);\n            }\n            if(!VAR_20.areRequestHeadersValid(VAR_11.getRequestHeaders())) {\n                VAR_25.badRequest = true;\n                VAR_17.REQUEST_IO_LOGGER.debugf(\"Invalid AJP request from %s, request contained invalid headers\", VAR_1.getPeerAddress());\n            }\n\n            if(VAR_25.badRequest) {\n                VAR_11.setStatusCode(VAR_28.BAD_REQUEST);\n                VAR_11.endExchange();\n                safeClose(VAR_1);\n            } else {\n                VAR_20.executeRootHandler(VAR_1.getRootHandler(), VAR_11);\n            }\n        } catch (BadRequestException VAR_29) {\n            VAR_17.REQUEST_IO_LOGGER.failedToParseRequest(VAR_29);\n            handleBadRequest();\n            safeClose(VAR_1);\n        } catch (IOException VAR_29) {\n            VAR_17.REQUEST_IO_LOGGER.ioException(VAR_29);\n            handleInternalServerError();\n            safeClose(VAR_1);\n        } catch (Throwable VAR_30) {\n            VAR_17.REQUEST_LOGGER.exceptionProcessingRequest(VAR_30);\n            handleInternalServerError();\n            safeClose(VAR_1);\n        } finally {\n            if (VAR_5) VAR_3.close();\n        }\n    }",
  "func_graph_path": "undertow-io/undertow/1443a1a2bbb8e32e56788109d8285db250d55c8b/AjpReadListener.java/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -129,7 +129,6 @@\n             if(oldState.badRequest) {\n                 httpServerExchange.setStatusCode(StatusCodes.BAD_REQUEST);\n                 httpServerExchange.endExchange();\n-                handleBadRequest();\n                 safeClose(connection);\n             } else {\n                 Connectors.executeRootHandler(connection.getRootHandler(), httpServerExchange);",
  "diff_line_info": {
    "deleted_lines": [
      "                handleBadRequest();"
    ],
    "added_lines": []
  },
  "is_vul": true,
  "pr_url": "https://github.com/undertow-io/undertow/pull/1329",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/undertow-io/undertow/pull/1329: 403 Client Error: Forbidden for url: https://api.github.com/repos/undertow-io/undertow/pulls/1329",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "The patch addresses a bug causing double AJP responses, which is a functional issue rather than a security vulnerability. The code change removes a method call that led to the problem, confirming it's a defect fix.\n\n**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.9"
}