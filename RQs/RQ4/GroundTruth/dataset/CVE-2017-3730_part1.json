{
  "cve_id": "CVE-2017-3730",
  "cwe_ids": [
    "CWE-476"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "openssl",
  "commit_msg": "Fix missing NULL checks in CKE processing\n\nReviewed-by: Rich Salz <rsalz@openssl.org>",
  "commit_hash": "efbe126e3ebb9123ac9d058aa2bb044261342aaa",
  "git_url": "https://github.com/openssl/openssl/commit/efbe126e3ebb9123ac9d058aa2bb044261342aaa",
  "file_path": "ssl/statem/statem_clnt.c",
  "func_name": "tls_construct_cke_ecdhe",
  "func_before": "static int tls_construct_cke_ecdhe(SSL *s, unsigned char **p, int *len, int *al)\n{\n#ifndef OPENSSL_NO_EC\n    unsigned char *encodedPoint = NULL;\n    int encoded_pt_len = 0;\n    EVP_PKEY *ckey = NULL, *skey = NULL;\n\n    skey = s->s3->peer_tmp;\n    if (skey == NULL) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n\n    ckey = ssl_generate_pkey(skey);\n\n    if (ssl_derive(s, ckey, skey) == 0) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_EVP_LIB);\n        goto err;\n    }\n\n    /* Generate encoding of client key */\n    encoded_pt_len = EVP_PKEY_get1_tls_encodedpoint(ckey, &encodedPoint);\n\n    if (encoded_pt_len == 0) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_EC_LIB);\n        goto err;\n    }\n\n    EVP_PKEY_free(ckey);\n    ckey = NULL;\n\n    *len = encoded_pt_len;\n\n    /* length of encoded point */\n    **p = *len;\n    *p += 1;\n    /* copy the point */\n    memcpy(*p, encodedPoint, *len);\n    /* increment len to account for length field */\n    *len += 1;\n\n    OPENSSL_free(encodedPoint);\n\n    return 1;\n err:\n    EVP_PKEY_free(ckey);\n    return 0;\n#else\n    SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);\n    *al = SSL_AD_INTERNAL_ERROR;\n    return 0;\n#endif\n}",
  "abstract_func_before": "static int tls_construct_cke_ecdhe(SSL *VAR_0, unsigned char **VAR_1, int *VAR_2, int *VAR_3)\n{\n#ifndef VAR_4\n    unsigned char *VAR_5 = NULL;\n    int VAR_6 = 0;\n    EVP_PKEY *VAR_7 = NULL, *VAR_8 = NULL;\n\n    VAR_8 = VAR_0->s3->peer_tmp;\n    if (VAR_8 == NULL) {\n        SSLerr(VAR_9, VAR_10);\n        return 0;\n    }\n\n    VAR_7 = ssl_generate_pkey(VAR_8);\n\n    if (ssl_derive(VAR_0, VAR_7, VAR_8) == 0) {\n        SSLerr(VAR_9, VAR_11);\n        goto err;\n    }\n\n    /* COMMENT_0 */\n    VAR_6 = EVP_PKEY_get1_tls_encodedpoint(VAR_7, &VAR_5);\n\n    if (VAR_6 == 0) {\n        SSLerr(VAR_9, VAR_12);\n        goto err;\n    }\n\n    EVP_PKEY_free(VAR_7);\n    VAR_7 = NULL;\n\n    *VAR_2 = VAR_6;\n\n    /* COMMENT_1 */\n    **VAR_1 = *VAR_2;\n    *VAR_1 += 1;\n    /* COMMENT_2 */\n    memcpy(*VAR_1, VAR_5, *VAR_2);\n    /* COMMENT_3 */\n    *VAR_2 += 1;\n\n    OPENSSL_free(VAR_5);\n\n    return 1;\n err:\n    EVP_PKEY_free(VAR_7);\n    return 0;\n#else\n    SSLerr(VAR_9, VAR_10);\n    *VAR_3 = VAR_13;\n    return 0;\n#endif\n}",
  "func_graph_path_before": "openssl/efbe126e3ebb9123ac9d058aa2bb044261342aaa/statem_clnt.c/vul/before/0.json",
  "func": "static int tls_construct_cke_ecdhe(SSL *s, unsigned char **p, int *len, int *al)\n{\n#ifndef OPENSSL_NO_EC\n    unsigned char *encodedPoint = NULL;\n    int encoded_pt_len = 0;\n    EVP_PKEY *ckey = NULL, *skey = NULL;\n\n    skey = s->s3->peer_tmp;\n    if (skey == NULL) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n\n    ckey = ssl_generate_pkey(skey);\n    if (ckey == NULL) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    if (ssl_derive(s, ckey, skey) == 0) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_EVP_LIB);\n        goto err;\n    }\n\n    /* Generate encoding of client key */\n    encoded_pt_len = EVP_PKEY_get1_tls_encodedpoint(ckey, &encodedPoint);\n\n    if (encoded_pt_len == 0) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_EC_LIB);\n        goto err;\n    }\n\n    EVP_PKEY_free(ckey);\n    ckey = NULL;\n\n    *len = encoded_pt_len;\n\n    /* length of encoded point */\n    **p = *len;\n    *p += 1;\n    /* copy the point */\n    memcpy(*p, encodedPoint, *len);\n    /* increment len to account for length field */\n    *len += 1;\n\n    OPENSSL_free(encodedPoint);\n\n    return 1;\n err:\n    EVP_PKEY_free(ckey);\n    return 0;\n#else\n    SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);\n    *al = SSL_AD_INTERNAL_ERROR;\n    return 0;\n#endif\n}",
  "abstract_func": "static int tls_construct_cke_ecdhe(SSL *VAR_0, unsigned char **VAR_1, int *VAR_2, int *VAR_3)\n{\n#ifndef VAR_4\n    unsigned char *VAR_5 = NULL;\n    int VAR_6 = 0;\n    EVP_PKEY *VAR_7 = NULL, *VAR_8 = NULL;\n\n    VAR_8 = VAR_0->s3->peer_tmp;\n    if (VAR_8 == NULL) {\n        SSLerr(VAR_9, VAR_10);\n        return 0;\n    }\n\n    VAR_7 = ssl_generate_pkey(VAR_8);\n    if (VAR_7 == NULL) {\n        SSLerr(VAR_9, VAR_10);\n        goto err;\n    }\n\n    if (ssl_derive(VAR_0, VAR_7, VAR_8) == 0) {\n        SSLerr(VAR_9, VAR_11);\n        goto err;\n    }\n\n    /* COMMENT_0 */\n    VAR_6 = EVP_PKEY_get1_tls_encodedpoint(VAR_7, &VAR_5);\n\n    if (VAR_6 == 0) {\n        SSLerr(VAR_9, VAR_12);\n        goto err;\n    }\n\n    EVP_PKEY_free(VAR_7);\n    VAR_7 = NULL;\n\n    *VAR_2 = VAR_6;\n\n    /* COMMENT_1 */\n    **VAR_1 = *VAR_2;\n    *VAR_1 += 1;\n    /* COMMENT_2 */\n    memcpy(*VAR_1, VAR_5, *VAR_2);\n    /* COMMENT_3 */\n    *VAR_2 += 1;\n\n    OPENSSL_free(VAR_5);\n\n    return 1;\n err:\n    EVP_PKEY_free(VAR_7);\n    return 0;\n#else\n    SSLerr(VAR_9, VAR_10);\n    *VAR_3 = VAR_13;\n    return 0;\n#endif\n}",
  "func_graph_path": "openssl/efbe126e3ebb9123ac9d058aa2bb044261342aaa/statem_clnt.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -12,6 +12,10 @@\n     }\n \n     ckey = ssl_generate_pkey(skey);\n+    if (ckey == NULL) {\n+        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);\n+        goto err;\n+    }\n \n     if (ssl_derive(s, ckey, skey) == 0) {\n         SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_EVP_LIB);",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "    if (ckey == NULL) {",
      "        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);",
      "        goto err;",
      "    }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/EktapopaT/openssl/pull/1",
  "description": {
    "pr_info": {
      "title": "Open ssl 1 1 0 stable",
      "number": 1
    },
    "comment": [
      "<!--\r\nThank you for your pull request. Please review below requirements.\r\n\r\nContributors guide: https://github.com/openssl/openssl/blob/master/CONTRIBUTING\r\n-->\r\n\r\n##### Checklist\r\n<!-- Remove items that do not apply. For completed items, change [ ] to [x]. -->\r\n- [ ] documentation is added or updated\r\n- [ ] tests are added or updated\r\n- [ ] CLA is signed\r\n\r\n##### Description of change\r\n<!-- Provide a description of the changes.\r\n\r\nIf it fixes a github issue, add Fixes #XXXX.\r\n-->\r\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "The commit fixes a potential security issue by adding necessary NULL checks, preventing possible crashes that could be exploited. \n\n**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.9"
}