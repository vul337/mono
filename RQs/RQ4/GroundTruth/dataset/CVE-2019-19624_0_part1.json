{
  "cve_id": "CVE-2019-19624",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "opencv",
  "commit_msg": "video:fixed DISOpticalFlow segfault from small img",
  "commit_hash": "d1615ba11a93062b1429fce9f0f638d1572d3418",
  "git_url": "https://github.com/opencv/opencv/commit/d1615ba11a93062b1429fce9f0f638d1572d3418",
  "file_path": "modules/video/src/dis_flow.cpp",
  "func_name": "DISOpticalFlowImpl::ocl_calc",
  "func_before": "bool DISOpticalFlowImpl::ocl_calc(InputArray I0, InputArray I1, InputOutputArray flow)\n{\n    UMat I0Mat = I0.getUMat();\n    UMat I1Mat = I1.getUMat();\n    bool use_input_flow = false;\n    if (flow.sameSize(I0) && flow.depth() == CV_32F && flow.channels() == 2)\n        use_input_flow = true;\n    else\n        flow.create(I1Mat.size(), CV_32FC2);\n    UMat &u_flowMat = flow.getUMatRef();\n    coarsest_scale = min((int)(log(max(I0Mat.cols, I0Mat.rows) / (4.0 * patch_size)) / log(2.0) + 0.5), /* Original code serach for maximal movement of width/4 */\n                         (int)(log(min(I0Mat.cols, I0Mat.rows) / patch_size) / log(2.0)));              /* Deepest pyramid level greater or equal than patch*/\n\n    ocl_prepareBuffers(I0Mat, I1Mat, u_flowMat, use_input_flow);\n    u_Ux[coarsest_scale].setTo(0.0f);\n    u_Uy[coarsest_scale].setTo(0.0f);\n\n    for (int i = coarsest_scale; i >= finest_scale; i--)\n    {\n        w = u_I0s[i].cols;\n        h = u_I0s[i].rows;\n        ws = 1 + (w - patch_size) / patch_stride;\n        hs = 1 + (h - patch_size) / patch_stride;\n\n        if (!ocl_precomputeStructureTensor(u_I0xx_buf, u_I0yy_buf, u_I0xy_buf,\n                                           u_I0x_buf, u_I0y_buf, u_I0xs[i], u_I0ys[i]))\n            return false;\n\n        if (!ocl_PatchInverseSearch(u_Ux[i], u_Uy[i], u_I0s[i], u_I1s_ext[i], u_I0xs[i], u_I0ys[i], 2, i))\n            return false;\n\n        if (!ocl_Densification(u_Ux[i], u_Uy[i], u_Sx, u_Sy, u_I0s[i], u_I1s[i]))\n            return false;\n\n        if (variational_refinement_iter > 0)\n            variational_refinement_processors[i]->calcUV(u_I0s[i], u_I1s[i],\n                                                         u_Ux[i].getMat(ACCESS_WRITE), u_Uy[i].getMat(ACCESS_WRITE));\n\n        if (i > finest_scale)\n        {\n            resize(u_Ux[i], u_Ux[i - 1], u_Ux[i - 1].size());\n            resize(u_Uy[i], u_Uy[i - 1], u_Uy[i - 1].size());\n            multiply(u_Ux[i - 1], 2, u_Ux[i - 1]);\n            multiply(u_Uy[i - 1], 2, u_Uy[i - 1]);\n        }\n    }\n    vector<UMat> uxy(2);\n    uxy[0] = u_Ux[finest_scale];\n    uxy[1] = u_Uy[finest_scale];\n    merge(uxy, u_U);\n    resize(u_U, u_flowMat, u_flowMat.size());\n    multiply(u_flowMat, 1 << finest_scale, u_flowMat);\n\n    return true;\n}",
  "abstract_func_before": "bool DISOpticalFlowImpl::ocl_calc(InputArray VAR_0, InputArray VAR_1, InputOutputArray VAR_2)\n{\n    UMat VAR_3 = VAR_0.getUMat();\n    UMat VAR_4 = VAR_1.getUMat();\n    bool VAR_5 = false;\n    if (VAR_2.sameSize(VAR_0) && VAR_2.depth() == VAR_6 && VAR_2.channels() == 2)\n        VAR_5 = true;\n    else\n        VAR_2.create(VAR_4.size(), VAR_7);\n    UMat &VAR_8 = VAR_2.getUMatRef();\n    VAR_9 = min((int)(log(max(VAR_3.cols, VAR_3.rows) / (4.0 * VAR_10)) / log(2.0) + 0.5), /* COMMENT_0 */\n                         (int)(log(min(VAR_3.cols, VAR_3.rows) / VAR_10) / log(2.0)));              /* COMMENT_1 */\n\n    ocl_prepareBuffers(VAR_3, VAR_4, VAR_8, VAR_5);\n    VAR_11[VAR_9].setTo(0.0f);\n    VAR_12[VAR_9].setTo(0.0f);\n\n    for (int VAR_13 = VAR_9; VAR_13 >= VAR_14; VAR_13--)\n    {\n        VAR_15 = VAR_16[VAR_13].cols;\n        VAR_17 = VAR_16[VAR_13].rows;\n        VAR_18 = 1 + (VAR_15 - VAR_10) / VAR_19;\n        VAR_20 = 1 + (VAR_17 - VAR_10) / VAR_19;\n\n        if (!ocl_precomputeStructureTensor(VAR_21, VAR_22, VAR_23,\n                                           VAR_24, VAR_25, VAR_26[VAR_13], VAR_27[VAR_13]))\n            return false;\n\n        if (!ocl_PatchInverseSearch(VAR_11[VAR_13], VAR_12[VAR_13], VAR_16[VAR_13], VAR_28[VAR_13], VAR_26[VAR_13], VAR_27[VAR_13], 2, VAR_13))\n            return false;\n\n        if (!ocl_Densification(VAR_11[VAR_13], VAR_12[VAR_13], VAR_29, VAR_30, VAR_16[VAR_13], VAR_31[VAR_13]))\n            return false;\n\n        if (VAR_32 > 0)\n            VAR_33[VAR_13]->calcUV(VAR_16[VAR_13], VAR_31[VAR_13],\n                                                         VAR_11[VAR_13].getMat(VAR_34), VAR_12[VAR_13].getMat(VAR_34));\n\n        if (VAR_13 > VAR_14)\n        {\n            resize(VAR_11[VAR_13], VAR_11[VAR_13 - 1], VAR_11[VAR_13 - 1].size());\n            resize(VAR_12[VAR_13], VAR_12[VAR_13 - 1], VAR_12[VAR_13 - 1].size());\n            multiply(VAR_11[VAR_13 - 1], 2, VAR_11[VAR_13 - 1]);\n            multiply(VAR_12[VAR_13 - 1], 2, VAR_12[VAR_13 - 1]);\n        }\n    }\n    vector<UMat> VAR_35(2);\n    VAR_35[0] = VAR_11[VAR_14];\n    VAR_35[1] = VAR_12[VAR_14];\n    merge(VAR_35, VAR_36);\n    resize(VAR_36, VAR_8, VAR_8.size());\n    multiply(VAR_8, 1 << VAR_14, VAR_8);\n\n    return true;\n}",
  "func_graph_path_before": "opencv/d1615ba11a93062b1429fce9f0f638d1572d3418/dis_flow.cpp/vul/before/1.json",
  "func": "bool DISOpticalFlowImpl::ocl_calc(InputArray I0, InputArray I1, InputOutputArray flow)\n{\n    UMat I0Mat = I0.getUMat();\n    UMat I1Mat = I1.getUMat();\n    bool use_input_flow = false;\n    if (flow.sameSize(I0) && flow.depth() == CV_32F && flow.channels() == 2)\n        use_input_flow = true;\n    else\n        flow.create(I1Mat.size(), CV_32FC2);\n    UMat &u_flowMat = flow.getUMatRef();\n    coarsest_scale = min((int)(log(max(I0Mat.cols, I0Mat.rows) / (4.0 * patch_size)) / log(2.0) + 0.5), /* Original code search for maximal movement of width/4 */\n                         (int)(log(min(I0Mat.cols, I0Mat.rows) / patch_size) / log(2.0)));              /* Deepest pyramid level greater or equal than patch*/\n\n    if (coarsest_scale<0)\n        CV_Error(cv::Error::StsBadSize, \"The input image must have either width or height >= 12\");\n\n    if (coarsest_scale<finest_scale)\n    {\n        // choose the finest level based on coarsest level.\n        // Refs: https://github.com/tikroeger/OF_DIS/blob/2c9f2a674f3128d3a41c10e41cc9f3a35bb1b523/run_dense.cpp#L239\n        int original_img_width = I0.size().width;\n        autoSelectPatchSizeAndScales(original_img_width);\n    }\n\n    ocl_prepareBuffers(I0Mat, I1Mat, u_flowMat, use_input_flow);\n    u_Ux[coarsest_scale].setTo(0.0f);\n    u_Uy[coarsest_scale].setTo(0.0f);\n\n    for (int i = coarsest_scale; i >= finest_scale; i--)\n    {\n        w = u_I0s[i].cols;\n        h = u_I0s[i].rows;\n        ws = 1 + (w - patch_size) / patch_stride;\n        hs = 1 + (h - patch_size) / patch_stride;\n\n        if (!ocl_precomputeStructureTensor(u_I0xx_buf, u_I0yy_buf, u_I0xy_buf,\n                                           u_I0x_buf, u_I0y_buf, u_I0xs[i], u_I0ys[i]))\n            return false;\n\n        if (!ocl_PatchInverseSearch(u_Ux[i], u_Uy[i], u_I0s[i], u_I1s_ext[i], u_I0xs[i], u_I0ys[i], 2, i))\n            return false;\n\n        if (!ocl_Densification(u_Ux[i], u_Uy[i], u_Sx, u_Sy, u_I0s[i], u_I1s[i]))\n            return false;\n\n        if (variational_refinement_iter > 0)\n            variational_refinement_processors[i]->calcUV(u_I0s[i], u_I1s[i],\n                                                         u_Ux[i].getMat(ACCESS_WRITE), u_Uy[i].getMat(ACCESS_WRITE));\n\n        if (i > finest_scale)\n        {\n            resize(u_Ux[i], u_Ux[i - 1], u_Ux[i - 1].size());\n            resize(u_Uy[i], u_Uy[i - 1], u_Uy[i - 1].size());\n            multiply(u_Ux[i - 1], 2, u_Ux[i - 1]);\n            multiply(u_Uy[i - 1], 2, u_Uy[i - 1]);\n        }\n    }\n    vector<UMat> uxy(2);\n    uxy[0] = u_Ux[finest_scale];\n    uxy[1] = u_Uy[finest_scale];\n    merge(uxy, u_U);\n    resize(u_U, u_flowMat, u_flowMat.size());\n    multiply(u_flowMat, 1 << finest_scale, u_flowMat);\n\n    return true;\n}",
  "abstract_func": "bool DISOpticalFlowImpl::ocl_calc(InputArray VAR_0, InputArray VAR_1, InputOutputArray VAR_2)\n{\n    UMat VAR_3 = VAR_0.getUMat();\n    UMat VAR_4 = VAR_1.getUMat();\n    bool VAR_5 = false;\n    if (VAR_2.sameSize(VAR_0) && VAR_2.depth() == VAR_6 && VAR_2.channels() == 2)\n        VAR_5 = true;\n    else\n        VAR_2.create(VAR_4.size(), VAR_7);\n    UMat &VAR_8 = VAR_2.getUMatRef();\n    VAR_9 = min((int)(log(max(VAR_3.cols, VAR_3.rows) / (4.0 * VAR_10)) / log(2.0) + 0.5), /* COMMENT_0 */\n                         (int)(log(min(VAR_3.cols, VAR_3.rows) / VAR_10) / log(2.0)));              /* COMMENT_1 */\n\n    if (VAR_9<0)\n        CV_Error(cv::Error::StsBadSize, \"The input image must have either width or height >= 12\");\n\n    if (VAR_9<VAR_11)\n    {\n        /* COMMENT_2 */\n        /* COMMENT_3 */\n        int VAR_12 = VAR_0.size().width;\n        autoSelectPatchSizeAndScales(VAR_12);\n    }\n\n    ocl_prepareBuffers(VAR_3, VAR_4, VAR_8, VAR_5);\n    VAR_13[VAR_9].setTo(0.0f);\n    VAR_14[VAR_9].setTo(0.0f);\n\n    for (int VAR_15 = VAR_9; VAR_15 >= VAR_11; VAR_15--)\n    {\n        VAR_16 = VAR_17[VAR_15].cols;\n        VAR_18 = VAR_17[VAR_15].rows;\n        VAR_19 = 1 + (VAR_16 - VAR_10) / VAR_20;\n        VAR_21 = 1 + (VAR_18 - VAR_10) / VAR_20;\n\n        if (!ocl_precomputeStructureTensor(VAR_22, VAR_23, VAR_24,\n                                           VAR_25, VAR_26, VAR_27[VAR_15], VAR_28[VAR_15]))\n            return false;\n\n        if (!ocl_PatchInverseSearch(VAR_13[VAR_15], VAR_14[VAR_15], VAR_17[VAR_15], VAR_29[VAR_15], VAR_27[VAR_15], VAR_28[VAR_15], 2, VAR_15))\n            return false;\n\n        if (!ocl_Densification(VAR_13[VAR_15], VAR_14[VAR_15], VAR_30, VAR_31, VAR_17[VAR_15], VAR_32[VAR_15]))\n            return false;\n\n        if (VAR_33 > 0)\n            VAR_34[VAR_15]->calcUV(VAR_17[VAR_15], VAR_32[VAR_15],\n                                                         VAR_13[VAR_15].getMat(VAR_35), VAR_14[VAR_15].getMat(VAR_35));\n\n        if (VAR_15 > VAR_11)\n        {\n            resize(VAR_13[VAR_15], VAR_13[VAR_15 - 1], VAR_13[VAR_15 - 1].size());\n            resize(VAR_14[VAR_15], VAR_14[VAR_15 - 1], VAR_14[VAR_15 - 1].size());\n            multiply(VAR_13[VAR_15 - 1], 2, VAR_13[VAR_15 - 1]);\n            multiply(VAR_14[VAR_15 - 1], 2, VAR_14[VAR_15 - 1]);\n        }\n    }\n    vector<UMat> VAR_36(2);\n    VAR_36[0] = VAR_13[VAR_11];\n    VAR_36[1] = VAR_14[VAR_11];\n    merge(VAR_36, VAR_37);\n    resize(VAR_37, VAR_8, VAR_8.size());\n    multiply(VAR_8, 1 << VAR_11, VAR_8);\n\n    return true;\n}",
  "func_graph_path": "opencv/d1615ba11a93062b1429fce9f0f638d1572d3418/dis_flow.cpp/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -8,8 +8,19 @@\n     else\n         flow.create(I1Mat.size(), CV_32FC2);\n     UMat &u_flowMat = flow.getUMatRef();\n-    coarsest_scale = min((int)(log(max(I0Mat.cols, I0Mat.rows) / (4.0 * patch_size)) / log(2.0) + 0.5), /* Original code serach for maximal movement of width/4 */\n+    coarsest_scale = min((int)(log(max(I0Mat.cols, I0Mat.rows) / (4.0 * patch_size)) / log(2.0) + 0.5), /* Original code search for maximal movement of width/4 */\n                          (int)(log(min(I0Mat.cols, I0Mat.rows) / patch_size) / log(2.0)));              /* Deepest pyramid level greater or equal than patch*/\n+\n+    if (coarsest_scale<0)\n+        CV_Error(cv::Error::StsBadSize, \"The input image must have either width or height >= 12\");\n+\n+    if (coarsest_scale<finest_scale)\n+    {\n+        // choose the finest level based on coarsest level.\n+        // Refs: https://github.com/tikroeger/OF_DIS/blob/2c9f2a674f3128d3a41c10e41cc9f3a35bb1b523/run_dense.cpp#L239\n+        int original_img_width = I0.size().width;\n+        autoSelectPatchSizeAndScales(original_img_width);\n+    }\n \n     ocl_prepareBuffers(I0Mat, I1Mat, u_flowMat, use_input_flow);\n     u_Ux[coarsest_scale].setTo(0.0f);",
  "diff_line_info": {
    "deleted_lines": [
      "    coarsest_scale = min((int)(log(max(I0Mat.cols, I0Mat.rows) / (4.0 * patch_size)) / log(2.0) + 0.5), /* Original code serach for maximal movement of width/4 */"
    ],
    "added_lines": [
      "    coarsest_scale = min((int)(log(max(I0Mat.cols, I0Mat.rows) / (4.0 * patch_size)) / log(2.0) + 0.5), /* Original code search for maximal movement of width/4 */",
      "",
      "    if (coarsest_scale<0)",
      "        CV_Error(cv::Error::StsBadSize, \"The input image must have either width or height >= 12\");",
      "",
      "    if (coarsest_scale<finest_scale)",
      "    {",
      "        // choose the finest level based on coarsest level.",
      "        // Refs: https://github.com/tikroeger/OF_DIS/blob/2c9f2a674f3128d3a41c10e41cc9f3a35bb1b523/run_dense.cpp#L239",
      "        int original_img_width = I0.size().width;",
      "        autoSelectPatchSizeAndScales(original_img_width);",
      "    }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/opencv/opencv/pull/14641",
  "description": {
    "pr_info": {
      "title": "video:fixed DISOpticalFlow segfault from small img",
      "number": 14641
    },
    "comment": [
      "- [x] added tests\r\n- [x] build successfully\r\n- [x] run tests successfully\r\n\r\nresolves #14554"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.9"
}