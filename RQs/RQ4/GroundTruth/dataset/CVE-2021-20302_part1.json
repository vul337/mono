{
  "cve_id": "CVE-2021-20302",
  "cwe_ids": [
    "CWE-20"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:C",
  "cvss_is_v3": false,
  "repo_name": "AcademySoftwareFoundation/openexr",
  "commit_msg": "add exrcheck binary and function in IlmImfUtil\n\nSigned-off-by: Peter Hillman <peterh@wetafx.co.nz>",
  "commit_hash": "f044caeed5c0f1566d804f37cbddb2d5ccfd75ea",
  "git_url": "https://github.com/AcademySoftwareFoundation/openexr/commit/f044caeed5c0f1566d804f37cbddb2d5ccfd75ea",
  "file_path": "OpenEXR/IlmImf/ImfTiledInputFile.cpp",
  "func_name": "TiledInputFile::initialize",
  "func_before": "void\nTiledInputFile::initialize ()\n{\n    // fix bad types in header (arises when a tool built against an older version of\n    // OpenEXR converts a scanline image to tiled)\n    // only applies when file is a single part, regular image, tiled file\n    //\n    if(!isMultiPart(_data->version) &&\n       !isNonImage(_data->version) && \n       isTiled(_data->version) && \n       _data->header.hasType() )\n    {\n        _data->header.setType(TILEDIMAGE);\n    }\n    \n    if (_data->partNumber == -1)\n    {\n        if (!isTiled (_data->version))\n            throw IEX_NAMESPACE::ArgExc (\"Expected a tiled file but the file is not tiled.\");\n        \n    }\n    else\n    {\n        if(_data->header.hasType() && _data->header.type()!=TILEDIMAGE)\n        {\n            throw IEX_NAMESPACE::ArgExc (\"TiledInputFile used for non-tiledimage part.\");\n        }\n    }\n    \n    _data->header.sanityCheck (true);\n\n    _data->tileDesc = _data->header.tileDescription();\n    _data->lineOrder = _data->header.lineOrder();\n\n    //\n    // Save the dataWindow information\n    //\n    \n    const Box2i &dataWindow = _data->header.dataWindow();\n    _data->minX = dataWindow.min.x;\n    _data->maxX = dataWindow.max.x;\n    _data->minY = dataWindow.min.y;\n    _data->maxY = dataWindow.max.y;\n\n    //\n    // Precompute level and tile information to speed up utility functions\n    //\n\n    precalculateTileInfo (_data->tileDesc,\n\t\t\t  _data->minX, _data->maxX,\n\t\t\t  _data->minY, _data->maxY,\n\t\t\t  _data->numXTiles, _data->numYTiles,\n\t\t\t  _data->numXLevels, _data->numYLevels);    \n\n    _data->bytesPerPixel = calculateBytesPerPixel (_data->header);\n\n    _data->maxBytesPerTileLine = _data->bytesPerPixel * _data->tileDesc.xSize;\n\n    _data->tileBufferSize = _data->maxBytesPerTileLine * _data->tileDesc.ySize;\n\n    //\n    // OpenEXR has a limit of INT_MAX compressed bytes per tile\n    // disallow uncompressed tile sizes above INT_MAX too to guarantee file is written\n    //\n    if( _data->tileBufferSize > INT_MAX )\n    {\n        throw IEX_NAMESPACE::ArgExc (\"Tile size too large for OpenEXR format\");\n    }\n\n\n    //\n    // Create all the TileBuffers and allocate their internal buffers\n    //\n\n    for (size_t i = 0; i < _data->tileBuffers.size(); i++)\n    {\n        _data->tileBuffers[i] = new TileBuffer (newTileCompressor\n\t\t\t\t\t\t  (_data->header.compression(),\n\t\t\t\t\t\t   _data->maxBytesPerTileLine,\n\t\t\t\t\t\t   _data->tileDesc.ySize,\n\t\t\t\t\t\t   _data->header));\n\n        if (!_data->_streamData->is->isMemoryMapped ())\n            _data->tileBuffers[i]->buffer = new char [_data->tileBufferSize];\n    }\n\n    _data->tileOffsets = TileOffsets (_data->tileDesc.mode,\n\t\t\t\t      _data->numXLevels,\n\t\t\t\t      _data->numYLevels,\n\t\t\t\t      _data->numXTiles,\n\t\t\t\t      _data->numYTiles);\n}",
  "abstract_func_before": "void\nTiledInputFile::initialize ()\n{\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n    /* COMMENT_3 */\n    if(!isMultiPart(VAR_0->version) &&\n       !isNonImage(VAR_0->version) && \n       isTiled(VAR_0->version) && \n       VAR_0->header.hasType() )\n    {\n        VAR_0->header.setType(VAR_1);\n    }\n    \n    if (VAR_0->partNumber == -1)\n    {\n        if (!isTiled (VAR_0->version))\n            throw IEX_NAMESPACE::ArgExc (\"Expected a tiled file but the file is not tiled.\");\n        \n    }\n    else\n    {\n        if(VAR_0->header.hasType() && VAR_0->header.type()!=VAR_1)\n        {\n            throw IEX_NAMESPACE::ArgExc (\"TiledInputFile used for non-tiledimage part.\");\n        }\n    }\n    \n    VAR_0->header.sanityCheck (true);\n\n    VAR_0->tileDesc = VAR_0->header.tileDescription();\n    VAR_0->lineOrder = VAR_0->header.lineOrder();\n\n    /* COMMENT_3 */\n    /* COMMENT_4 */\n    /* COMMENT_3 */\n    \n    const Box2i &VAR_2 = VAR_0->header.dataWindow();\n    VAR_0->minX = VAR_2.min.x;\n    VAR_0->maxX = VAR_2.max.x;\n    VAR_0->minY = VAR_2.min.y;\n    VAR_0->maxY = VAR_2.max.y;\n\n    /* COMMENT_3 */\n    /* COMMENT_5 */\n    /* COMMENT_3 */\n\n    precalculateTileInfo (VAR_0->tileDesc,\n\t\t\t  VAR_0->minX, VAR_0->maxX,\n\t\t\t  VAR_0->minY, VAR_0->maxY,\n\t\t\t  VAR_0->numXTiles, VAR_0->numYTiles,\n\t\t\t  VAR_0->numXLevels, VAR_0->numYLevels);    \n\n    VAR_0->bytesPerPixel = calculateBytesPerPixel (VAR_0->header);\n\n    VAR_0->maxBytesPerTileLine = VAR_0->bytesPerPixel * VAR_0->tileDesc.xSize;\n\n    VAR_0->tileBufferSize = VAR_0->maxBytesPerTileLine * VAR_0->tileDesc.ySize;\n\n    /* COMMENT_3 */\n    /* COMMENT_6 */\n    /* COMMENT_7 */\n    /* COMMENT_3 */\n    if( VAR_0->tileBufferSize > VAR_3 )\n    {\n        throw IEX_NAMESPACE::ArgExc (\"Tile size too large for OpenEXR format\");\n    }\n\n\n    /* COMMENT_3 */\n    /* COMMENT_8 */\n    /* COMMENT_3 */\n\n    for (size_t VAR_4 = 0; VAR_4 < VAR_0->tileBuffers.size(); VAR_4++)\n    {\n        VAR_0->tileBuffers[VAR_4] = new TileBuffer (newTileCompressor\n\t\t\t\t\t\t  (VAR_0->header.compression(),\n\t\t\t\t\t\t   VAR_0->maxBytesPerTileLine,\n\t\t\t\t\t\t   VAR_0->tileDesc.ySize,\n\t\t\t\t\t\t   VAR_0->header));\n\n        if (!VAR_0->_streamData->is->isMemoryMapped ())\n            VAR_0->tileBuffers[VAR_4]->buffer = new char [VAR_0->tileBufferSize];\n    }\n\n    VAR_0->tileOffsets = TileOffsets (VAR_0->tileDesc.mode,\n\t\t\t\t      VAR_0->numXLevels,\n\t\t\t\t      VAR_0->numYLevels,\n\t\t\t\t      VAR_0->numXTiles,\n\t\t\t\t      VAR_0->numYTiles);\n}",
  "func_graph_path_before": "AcademySoftwareFoundation/openexr/f044caeed5c0f1566d804f37cbddb2d5ccfd75ea/ImfTiledInputFile.cpp/vul/before/0.json",
  "func": "void\nTiledInputFile::initialize ()\n{\n    // fix bad types in header (arises when a tool built against an older version of\n    // OpenEXR converts a scanline image to tiled)\n    // only applies when file is a single part, regular image, tiled file\n    //\n    if(!isMultiPart(_data->version) &&\n       !isNonImage(_data->version) && \n       isTiled(_data->version) && \n       _data->header.hasType() )\n    {\n        _data->header.setType(TILEDIMAGE);\n    }\n    \n    if (_data->partNumber == -1)\n    {\n        if (!isTiled (_data->version))\n            throw IEX_NAMESPACE::ArgExc (\"Expected a tiled file but the file is not tiled.\");\n\n        if (isNonImage (_data->version))\n            throw IEX_NAMESPACE::ArgExc (\"File is not a regular tiled image.\");\n\n    }\n    else\n    {\n        if(_data->header.hasType() && _data->header.type()!=TILEDIMAGE)\n        {\n            throw IEX_NAMESPACE::ArgExc (\"TiledInputFile used for non-tiledimage part.\");\n        }\n    }\n    \n    _data->header.sanityCheck (true);\n\n    _data->tileDesc = _data->header.tileDescription();\n    _data->lineOrder = _data->header.lineOrder();\n\n    //\n    // Save the dataWindow information\n    //\n    \n    const Box2i &dataWindow = _data->header.dataWindow();\n    _data->minX = dataWindow.min.x;\n    _data->maxX = dataWindow.max.x;\n    _data->minY = dataWindow.min.y;\n    _data->maxY = dataWindow.max.y;\n\n    //\n    // Precompute level and tile information to speed up utility functions\n    //\n\n    precalculateTileInfo (_data->tileDesc,\n\t\t\t  _data->minX, _data->maxX,\n\t\t\t  _data->minY, _data->maxY,\n\t\t\t  _data->numXTiles, _data->numYTiles,\n\t\t\t  _data->numXLevels, _data->numYLevels);    \n\n    _data->bytesPerPixel = calculateBytesPerPixel (_data->header);\n\n    _data->maxBytesPerTileLine = _data->bytesPerPixel * _data->tileDesc.xSize;\n\n    _data->tileBufferSize = _data->maxBytesPerTileLine * _data->tileDesc.ySize;\n\n    //\n    // OpenEXR has a limit of INT_MAX compressed bytes per tile\n    // disallow uncompressed tile sizes above INT_MAX too to guarantee file is written\n    //\n    if( _data->tileBufferSize > INT_MAX )\n    {\n        throw IEX_NAMESPACE::ArgExc (\"Tile size too large for OpenEXR format\");\n    }\n\n\n    //\n    // Create all the TileBuffers and allocate their internal buffers\n    //\n\n    for (size_t i = 0; i < _data->tileBuffers.size(); i++)\n    {\n        _data->tileBuffers[i] = new TileBuffer (newTileCompressor\n\t\t\t\t\t\t  (_data->header.compression(),\n\t\t\t\t\t\t   _data->maxBytesPerTileLine,\n\t\t\t\t\t\t   _data->tileDesc.ySize,\n\t\t\t\t\t\t   _data->header));\n\n        if (!_data->_streamData->is->isMemoryMapped ())\n            _data->tileBuffers[i]->buffer = new char [_data->tileBufferSize];\n    }\n\n    _data->tileOffsets = TileOffsets (_data->tileDesc.mode,\n\t\t\t\t      _data->numXLevels,\n\t\t\t\t      _data->numYLevels,\n\t\t\t\t      _data->numXTiles,\n\t\t\t\t      _data->numYTiles);\n}",
  "abstract_func": "void\nTiledInputFile::initialize ()\n{\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n    /* COMMENT_3 */\n    if(!isMultiPart(VAR_0->version) &&\n       !isNonImage(VAR_0->version) && \n       isTiled(VAR_0->version) && \n       VAR_0->header.hasType() )\n    {\n        VAR_0->header.setType(VAR_1);\n    }\n    \n    if (VAR_0->partNumber == -1)\n    {\n        if (!isTiled (VAR_0->version))\n            throw IEX_NAMESPACE::ArgExc (\"Expected a tiled file but the file is not tiled.\");\n\n        if (isNonImage (VAR_0->version))\n            throw IEX_NAMESPACE::ArgExc (\"File is not a regular tiled image.\");\n\n    }\n    else\n    {\n        if(VAR_0->header.hasType() && VAR_0->header.type()!=VAR_1)\n        {\n            throw IEX_NAMESPACE::ArgExc (\"TiledInputFile used for non-tiledimage part.\");\n        }\n    }\n    \n    VAR_0->header.sanityCheck (true);\n\n    VAR_0->tileDesc = VAR_0->header.tileDescription();\n    VAR_0->lineOrder = VAR_0->header.lineOrder();\n\n    /* COMMENT_3 */\n    /* COMMENT_4 */\n    /* COMMENT_3 */\n    \n    const Box2i &VAR_2 = VAR_0->header.dataWindow();\n    VAR_0->minX = VAR_2.min.x;\n    VAR_0->maxX = VAR_2.max.x;\n    VAR_0->minY = VAR_2.min.y;\n    VAR_0->maxY = VAR_2.max.y;\n\n    /* COMMENT_3 */\n    /* COMMENT_5 */\n    /* COMMENT_3 */\n\n    precalculateTileInfo (VAR_0->tileDesc,\n\t\t\t  VAR_0->minX, VAR_0->maxX,\n\t\t\t  VAR_0->minY, VAR_0->maxY,\n\t\t\t  VAR_0->numXTiles, VAR_0->numYTiles,\n\t\t\t  VAR_0->numXLevels, VAR_0->numYLevels);    \n\n    VAR_0->bytesPerPixel = calculateBytesPerPixel (VAR_0->header);\n\n    VAR_0->maxBytesPerTileLine = VAR_0->bytesPerPixel * VAR_0->tileDesc.xSize;\n\n    VAR_0->tileBufferSize = VAR_0->maxBytesPerTileLine * VAR_0->tileDesc.ySize;\n\n    /* COMMENT_3 */\n    /* COMMENT_6 */\n    /* COMMENT_7 */\n    /* COMMENT_3 */\n    if( VAR_0->tileBufferSize > VAR_3 )\n    {\n        throw IEX_NAMESPACE::ArgExc (\"Tile size too large for OpenEXR format\");\n    }\n\n\n    /* COMMENT_3 */\n    /* COMMENT_8 */\n    /* COMMENT_3 */\n\n    for (size_t VAR_4 = 0; VAR_4 < VAR_0->tileBuffers.size(); VAR_4++)\n    {\n        VAR_0->tileBuffers[VAR_4] = new TileBuffer (newTileCompressor\n\t\t\t\t\t\t  (VAR_0->header.compression(),\n\t\t\t\t\t\t   VAR_0->maxBytesPerTileLine,\n\t\t\t\t\t\t   VAR_0->tileDesc.ySize,\n\t\t\t\t\t\t   VAR_0->header));\n\n        if (!VAR_0->_streamData->is->isMemoryMapped ())\n            VAR_0->tileBuffers[VAR_4]->buffer = new char [VAR_0->tileBufferSize];\n    }\n\n    VAR_0->tileOffsets = TileOffsets (VAR_0->tileDesc.mode,\n\t\t\t\t      VAR_0->numXLevels,\n\t\t\t\t      VAR_0->numYLevels,\n\t\t\t\t      VAR_0->numXTiles,\n\t\t\t\t      VAR_0->numYTiles);\n}",
  "func_graph_path": "AcademySoftwareFoundation/openexr/f044caeed5c0f1566d804f37cbddb2d5ccfd75ea/ImfTiledInputFile.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -17,7 +17,10 @@\n     {\n         if (!isTiled (_data->version))\n             throw IEX_NAMESPACE::ArgExc (\"Expected a tiled file but the file is not tiled.\");\n-        \n+\n+        if (isNonImage (_data->version))\n+            throw IEX_NAMESPACE::ArgExc (\"File is not a regular tiled image.\");\n+\n     }\n     else\n     {",
  "diff_line_info": {
    "deleted_lines": [
      "        "
    ],
    "added_lines": [
      "",
      "        if (isNonImage (_data->version))",
      "            throw IEX_NAMESPACE::ArgExc (\"File is not a regular tiled image.\");",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/AcademySoftwareFoundation/openexr/pull/842",
  "description": {
    "pr_info": {
      "title": "add exrcheck utility and hooks for fuzz testing",
      "number": 842
    },
    "comment": [
      "This adds an `exrcheck` binary (not installed by default) that can be used to check for bad files, as well as looking for issues in the OpenEXR library. This wraps a new API call in IlmImfUtil: checkOpenEXRFile()\r\n\r\nA hook to call this function with the [oss-fuzz](https://github.com/google/oss-fuzz) project has also been added in IlmImfFuzzTest. This file is to be compiled by that project\r\n\r\nOpenEXR's internal fuzz tests could also be adapted to use checkOpenEXRFile instead of their own function. This would allow for more exhaustive testing.\r\n\r\nA few other additions to the API:\r\n\r\n- For this to work efficiently, missing functionality is added to open (single part) DeepScanLineInputFiles via a stream interface. This was the only API missing that functionality\r\n- MultiPartInputFile::flushPartCache method is required to switch between part readers (Tiled files can be read either as TiledInputPart or InputPart. flushPartCache must be called to change the reader type within the same object)\r\n\r\nOther bugfixes to address issues found while testing against the 'Damaged' file list that were required to properly test `exrcheck`:\r\n\r\n- DeepScanLineInputFile had a 32 bit integer overflow accessing the sample count table with very large values of dataWindow.min.x\r\n- InputFile could crash when reading tiled files as scanlines in 'readPixels' if 'setFrameBuffer' was called with an empty frame buffer\r\n- Single part non-image files would not be detected in the TiledInputFile. Attempting to read anything which isn't a tiled regular image with this call now throws an exception. This should also address https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=25892 and https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=25894"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Step1: Input Analysis**\n- **Commit Message:** Adds `exrcheck` and a new API call `checkOpenEXRFile()`, along with other API additions and bug fixes.\n- **Vulnerability Description:** Mentions security-related changes like preventing crashes in `InputFile`, handling large values in `DeepScanLineInputFile`, and detecting non-image files in `TiledInputFile`.\n- **Code Diff:** Modifies `TiledInputFile::initialize` to throw an exception when the file is non-image.\n\n**Step2: Consistency Check**\n- The commit message aligns with the code changes, adding exceptions for non-image files and fixing bugs related to file handling.\n\n**Step3: Purpose Evaluation**\n- The changes address specific issues like integer overflow and potential crashes, which are crucial for data integrity and crash prevention.\n\n**Step4: Security Vulnerability Assessment**\n- Fixes issues that can lead to crashes or incorrect file handling, which are often security concerns. References to oss-fuzz issues suggest security relevance.\n\n**Step5: Non-Security Classification**\n- Not applicable as it's a security fix.\n\n**Step6: Confidence Scoring**\n- The fixes directly relate to security by preventing crashes and handling edge cases, hence high confidence.\n\n**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.9"
}