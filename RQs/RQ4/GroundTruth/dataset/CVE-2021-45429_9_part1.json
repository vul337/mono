{
  "cve_id": "CVE-2021-45429",
  "cwe_ids": [
    "CWE-120"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "VirusTotal/yara",
  "commit_msg": "Fix issue #1616\n\nThis is a more comprehensive fix than #1617, it adds new functions to the API for getting/setting uint32 and uint64 settings.  Using these functions is preferable over calling `yr_(get|set)_configuration` directly.",
  "commit_hash": "b34b7e74c862c129b801832b6b85401fbada2b01",
  "git_url": "https://github.com/VirusTotal/yara/commit/b34b7e74c862c129b801832b6b85401fbada2b01",
  "file_path": "libyara/scan.c",
  "func_name": "_yr_scan_match_callback",
  "func_before": "static int _yr_scan_match_callback(\n    const uint8_t* match_data,\n    int32_t match_length,\n    int flags,\n    void* args)\n{\n  CALLBACK_ARGS* callback_args = (CALLBACK_ARGS*) args;\n\n  YR_STRING* string = callback_args->string;\n  YR_MATCH* new_match;\n\n  int result = ERROR_SUCCESS;\n\n  size_t match_offset = match_data - callback_args->data;\n\n  YR_DEBUG_FPRINTF(\n      2,\n      stderr,\n      \"+ %s(match_data=%p match_length=%d) { //\"\n      \" match_offset=%zu args->data=%p args->string.length=%u\"\n      \" args->data_base=0x%\" PRIx64 \" args->data_size=%zu\"\n      \" args->forward_matches=%'u\\n\",\n      __FUNCTION__,\n      match_data,\n      match_length,\n      match_offset,\n      callback_args->data,\n      callback_args->string->length,\n      callback_args->data_base,\n      callback_args->data_size,\n      callback_args->forward_matches);\n\n  // total match length is the sum of backward and forward matches.\n  match_length += callback_args->forward_matches;\n\n  // make sure that match fits into the data.\n  assert(match_offset + match_length <= callback_args->data_size);\n\n  if (callback_args->full_word)\n  {\n    if (flags & RE_FLAGS_WIDE)\n    {\n      if (match_offset >= 2 && *(match_data - 1) == 0 &&\n          yr_isalnum(match_data - 2))\n        goto _exit;  // return ERROR_SUCCESS;\n\n      if (match_offset + match_length + 1 < callback_args->data_size &&\n          *(match_data + match_length + 1) == 0 &&\n          yr_isalnum(match_data + match_length))\n        goto _exit;  // return ERROR_SUCCESS;\n    }\n    else\n    {\n      if (match_offset >= 1 && yr_isalnum(match_data - 1))\n        goto _exit;  // return ERROR_SUCCESS;\n\n      if (match_offset + match_length < callback_args->data_size &&\n          yr_isalnum(match_data + match_length))\n        goto _exit;  // return ERROR_SUCCESS;\n    }\n  }\n\n  if (STRING_IS_CHAIN_PART(string))\n  {\n    result = _yr_scan_verify_chained_string_match(\n        string,\n        callback_args->context,\n        match_data,\n        callback_args->data_base,\n        match_offset,\n        match_length);\n  }\n  else\n  {\n    uint32_t max_match_data;\n\n    FAIL_ON_ERROR(\n        yr_get_configuration(YR_CONFIG_MAX_MATCH_DATA, &max_match_data));\n\n    new_match = yr_notebook_alloc(\n        callback_args->context->matches_notebook, sizeof(YR_MATCH));\n\n    if (new_match == NULL)\n    {\n      result = ERROR_INSUFFICIENT_MEMORY;\n      goto _exit;\n    }\n\n    new_match->data_length = yr_min(match_length, (int32_t) max_match_data);\n\n    if (new_match->data_length > 0)\n    {\n      new_match->data = yr_notebook_alloc(\n          callback_args->context->matches_notebook, new_match->data_length);\n\n      if (new_match->data == NULL)\n      {\n        result = ERROR_INSUFFICIENT_MEMORY;\n        goto _exit;\n      }\n\n      memcpy((void*) new_match->data, match_data, new_match->data_length);\n    }\n    else\n    {\n      new_match->data = NULL;\n    }\n\n    if (result == ERROR_SUCCESS)\n    {\n      new_match->base = callback_args->data_base;\n      new_match->offset = match_offset;\n      new_match->match_length = match_length;\n      new_match->prev = NULL;\n      new_match->next = NULL;\n      new_match->is_private = STRING_IS_PRIVATE(string);\n\n      FAIL_ON_ERROR(_yr_scan_add_match_to_list(\n          new_match,\n          &callback_args->context->matches[string->idx],\n          STRING_IS_GREEDY_REGEXP(string)));\n    }\n  }\n\n_exit:;\n\n  YR_DEBUG_FPRINTF(2, stderr, \"} = %d // %s()\\n\", result, __FUNCTION__);\n\n  return result;\n}",
  "abstract_func_before": "static int _yr_scan_match_callback(\n    const uint8_t* VAR_0,\n    int32_t VAR_1,\n    int VAR_2,\n    void* VAR_3)\n{\n  CALLBACK_ARGS* VAR_4 = (CALLBACK_ARGS*) VAR_3;\n\n  YR_STRING* VAR_5 = VAR_4->string;\n  YR_MATCH* VAR_6;\n\n  int VAR_7 = VAR_8;\n\n  size_t VAR_9 = VAR_0 - VAR_4->data;\n\n  YR_DEBUG_FPRINTF(\n      2,\n      VAR_10,\n      \"+ %s(match_data=%p match_length=%d) { //\"\n      \" match_offset=%zu args->data=%p args->string.length=%u\"\n      \" args->data_base=0x%\" VAR_11 \" args->data_size=%zu\"\n      \" args->forward_matches=%'u\\n\",\n      VAR_12,\n      VAR_0,\n      VAR_1,\n      VAR_9,\n      VAR_4->data,\n      VAR_4->string->length,\n      VAR_4->data_base,\n      VAR_4->data_size,\n      VAR_4->forward_matches);\n\n  /* COMMENT_0 */\n  VAR_1 += VAR_4->forward_matches;\n\n  /* COMMENT_1 */\n  assert(VAR_9 + VAR_1 <= VAR_4->data_size);\n\n  if (VAR_4->full_word)\n  {\n    if (VAR_2 & VAR_13)\n    {\n      if (VAR_9 >= 2 && *(VAR_0 - 1) == 0 &&\n          yr_isalnum(VAR_0 - 2))\n        goto _exit;  /* COMMENT_2 */\n\n      if (VAR_9 + VAR_1 + 1 < VAR_4->data_size &&\n          *(VAR_0 + VAR_1 + 1) == 0 &&\n          yr_isalnum(VAR_0 + VAR_1))\n        goto _exit;  /* COMMENT_2 */\n    }\n    else\n    {\n      if (VAR_9 >= 1 && yr_isalnum(VAR_0 - 1))\n        goto _exit;  /* COMMENT_2 */\n\n      if (VAR_9 + VAR_1 < VAR_4->data_size &&\n          yr_isalnum(VAR_0 + VAR_1))\n        goto _exit;  /* COMMENT_2 */\n    }\n  }\n\n  if (STRING_IS_CHAIN_PART(VAR_5))\n  {\n    VAR_7 = _yr_scan_verify_chained_string_match(\n        VAR_5,\n        VAR_4->context,\n        VAR_0,\n        VAR_4->data_base,\n        VAR_9,\n        VAR_1);\n  }\n  else\n  {\n    uint32_t VAR_14;\n\n    FAIL_ON_ERROR(\n        yr_get_configuration(VAR_15, &VAR_14));\n\n    VAR_6 = yr_notebook_alloc(\n        VAR_4->context->matches_notebook, sizeof(YR_MATCH));\n\n    if (VAR_6 == NULL)\n    {\n      VAR_7 = VAR_16;\n      goto _exit;\n    }\n\n    VAR_6->data_length = yr_min(VAR_1, (int32_t) VAR_14);\n\n    if (VAR_6->data_length > 0)\n    {\n      VAR_6->data = yr_notebook_alloc(\n          VAR_4->context->matches_notebook, VAR_6->data_length);\n\n      if (VAR_6->data == NULL)\n      {\n        VAR_7 = VAR_16;\n        goto _exit;\n      }\n\n      memcpy((void*) VAR_6->data, VAR_0, VAR_6->data_length);\n    }\n    else\n    {\n      VAR_6->data = NULL;\n    }\n\n    if (VAR_7 == VAR_8)\n    {\n      VAR_6->base = VAR_4->data_base;\n      VAR_6->offset = VAR_9;\n      VAR_6->match_length = VAR_1;\n      VAR_6->prev = NULL;\n      VAR_6->next = NULL;\n      VAR_6->is_private = STRING_IS_PRIVATE(VAR_5);\n\n      FAIL_ON_ERROR(_yr_scan_add_match_to_list(\n          VAR_6,\n          &VAR_4->context->matches[VAR_5->idx],\n          STRING_IS_GREEDY_REGEXP(VAR_5)));\n    }\n  }\n\n_exit:;\n\n  YR_DEBUG_FPRINTF(2, VAR_10, \"} = %d // %s()\\n\", VAR_7, VAR_12);\n\n  return VAR_7;\n}",
  "func_graph_path_before": "VirusTotal/yara/b34b7e74c862c129b801832b6b85401fbada2b01/scan.c/vul/before/0.json",
  "func": "static int _yr_scan_match_callback(\n    const uint8_t* match_data,\n    int32_t match_length,\n    int flags,\n    void* args)\n{\n  CALLBACK_ARGS* callback_args = (CALLBACK_ARGS*) args;\n\n  YR_STRING* string = callback_args->string;\n  YR_MATCH* new_match;\n\n  int result = ERROR_SUCCESS;\n\n  size_t match_offset = match_data - callback_args->data;\n\n  YR_DEBUG_FPRINTF(\n      2,\n      stderr,\n      \"+ %s(match_data=%p match_length=%d) { //\"\n      \" match_offset=%zu args->data=%p args->string.length=%u\"\n      \" args->data_base=0x%\" PRIx64 \" args->data_size=%zu\"\n      \" args->forward_matches=%'u\\n\",\n      __FUNCTION__,\n      match_data,\n      match_length,\n      match_offset,\n      callback_args->data,\n      callback_args->string->length,\n      callback_args->data_base,\n      callback_args->data_size,\n      callback_args->forward_matches);\n\n  // total match length is the sum of backward and forward matches.\n  match_length += callback_args->forward_matches;\n\n  // make sure that match fits into the data.\n  assert(match_offset + match_length <= callback_args->data_size);\n\n  if (callback_args->full_word)\n  {\n    if (flags & RE_FLAGS_WIDE)\n    {\n      if (match_offset >= 2 && *(match_data - 1) == 0 &&\n          yr_isalnum(match_data - 2))\n        goto _exit;  // return ERROR_SUCCESS;\n\n      if (match_offset + match_length + 1 < callback_args->data_size &&\n          *(match_data + match_length + 1) == 0 &&\n          yr_isalnum(match_data + match_length))\n        goto _exit;  // return ERROR_SUCCESS;\n    }\n    else\n    {\n      if (match_offset >= 1 && yr_isalnum(match_data - 1))\n        goto _exit;  // return ERROR_SUCCESS;\n\n      if (match_offset + match_length < callback_args->data_size &&\n          yr_isalnum(match_data + match_length))\n        goto _exit;  // return ERROR_SUCCESS;\n    }\n  }\n\n  if (STRING_IS_CHAIN_PART(string))\n  {\n    result = _yr_scan_verify_chained_string_match(\n        string,\n        callback_args->context,\n        match_data,\n        callback_args->data_base,\n        match_offset,\n        match_length);\n  }\n  else\n  {\n    uint32_t max_match_data;\n\n    FAIL_ON_ERROR(\n        yr_get_configuration_uint32(YR_CONFIG_MAX_MATCH_DATA, &max_match_data));\n\n    new_match = yr_notebook_alloc(\n        callback_args->context->matches_notebook, sizeof(YR_MATCH));\n\n    if (new_match == NULL)\n    {\n      result = ERROR_INSUFFICIENT_MEMORY;\n      goto _exit;\n    }\n\n    new_match->data_length = yr_min(match_length, (int32_t) max_match_data);\n\n    if (new_match->data_length > 0)\n    {\n      new_match->data = yr_notebook_alloc(\n          callback_args->context->matches_notebook, new_match->data_length);\n\n      if (new_match->data == NULL)\n      {\n        result = ERROR_INSUFFICIENT_MEMORY;\n        goto _exit;\n      }\n\n      memcpy((void*) new_match->data, match_data, new_match->data_length);\n    }\n    else\n    {\n      new_match->data = NULL;\n    }\n\n    if (result == ERROR_SUCCESS)\n    {\n      new_match->base = callback_args->data_base;\n      new_match->offset = match_offset;\n      new_match->match_length = match_length;\n      new_match->prev = NULL;\n      new_match->next = NULL;\n      new_match->is_private = STRING_IS_PRIVATE(string);\n\n      FAIL_ON_ERROR(_yr_scan_add_match_to_list(\n          new_match,\n          &callback_args->context->matches[string->idx],\n          STRING_IS_GREEDY_REGEXP(string)));\n    }\n  }\n\n_exit:;\n\n  YR_DEBUG_FPRINTF(2, stderr, \"} = %d // %s()\\n\", result, __FUNCTION__);\n\n  return result;\n}",
  "abstract_func": "static int _yr_scan_match_callback(\n    const uint8_t* VAR_0,\n    int32_t VAR_1,\n    int VAR_2,\n    void* VAR_3)\n{\n  CALLBACK_ARGS* VAR_4 = (CALLBACK_ARGS*) VAR_3;\n\n  YR_STRING* VAR_5 = VAR_4->string;\n  YR_MATCH* VAR_6;\n\n  int VAR_7 = VAR_8;\n\n  size_t VAR_9 = VAR_0 - VAR_4->data;\n\n  YR_DEBUG_FPRINTF(\n      2,\n      VAR_10,\n      \"+ %s(match_data=%p match_length=%d) { //\"\n      \" match_offset=%zu args->data=%p args->string.length=%u\"\n      \" args->data_base=0x%\" VAR_11 \" args->data_size=%zu\"\n      \" args->forward_matches=%'u\\n\",\n      VAR_12,\n      VAR_0,\n      VAR_1,\n      VAR_9,\n      VAR_4->data,\n      VAR_4->string->length,\n      VAR_4->data_base,\n      VAR_4->data_size,\n      VAR_4->forward_matches);\n\n  /* COMMENT_0 */\n  VAR_1 += VAR_4->forward_matches;\n\n  /* COMMENT_1 */\n  assert(VAR_9 + VAR_1 <= VAR_4->data_size);\n\n  if (VAR_4->full_word)\n  {\n    if (VAR_2 & VAR_13)\n    {\n      if (VAR_9 >= 2 && *(VAR_0 - 1) == 0 &&\n          yr_isalnum(VAR_0 - 2))\n        goto _exit;  /* COMMENT_2 */\n\n      if (VAR_9 + VAR_1 + 1 < VAR_4->data_size &&\n          *(VAR_0 + VAR_1 + 1) == 0 &&\n          yr_isalnum(VAR_0 + VAR_1))\n        goto _exit;  /* COMMENT_2 */\n    }\n    else\n    {\n      if (VAR_9 >= 1 && yr_isalnum(VAR_0 - 1))\n        goto _exit;  /* COMMENT_2 */\n\n      if (VAR_9 + VAR_1 < VAR_4->data_size &&\n          yr_isalnum(VAR_0 + VAR_1))\n        goto _exit;  /* COMMENT_2 */\n    }\n  }\n\n  if (STRING_IS_CHAIN_PART(VAR_5))\n  {\n    VAR_7 = _yr_scan_verify_chained_string_match(\n        VAR_5,\n        VAR_4->context,\n        VAR_0,\n        VAR_4->data_base,\n        VAR_9,\n        VAR_1);\n  }\n  else\n  {\n    uint32_t VAR_14;\n\n    FAIL_ON_ERROR(\n        yr_get_configuration_uint32(VAR_15, &VAR_14));\n\n    VAR_6 = yr_notebook_alloc(\n        VAR_4->context->matches_notebook, sizeof(YR_MATCH));\n\n    if (VAR_6 == NULL)\n    {\n      VAR_7 = VAR_16;\n      goto _exit;\n    }\n\n    VAR_6->data_length = yr_min(VAR_1, (int32_t) VAR_14);\n\n    if (VAR_6->data_length > 0)\n    {\n      VAR_6->data = yr_notebook_alloc(\n          VAR_4->context->matches_notebook, VAR_6->data_length);\n\n      if (VAR_6->data == NULL)\n      {\n        VAR_7 = VAR_16;\n        goto _exit;\n      }\n\n      memcpy((void*) VAR_6->data, VAR_0, VAR_6->data_length);\n    }\n    else\n    {\n      VAR_6->data = NULL;\n    }\n\n    if (VAR_7 == VAR_8)\n    {\n      VAR_6->base = VAR_4->data_base;\n      VAR_6->offset = VAR_9;\n      VAR_6->match_length = VAR_1;\n      VAR_6->prev = NULL;\n      VAR_6->next = NULL;\n      VAR_6->is_private = STRING_IS_PRIVATE(VAR_5);\n\n      FAIL_ON_ERROR(_yr_scan_add_match_to_list(\n          VAR_6,\n          &VAR_4->context->matches[VAR_5->idx],\n          STRING_IS_GREEDY_REGEXP(VAR_5)));\n    }\n  }\n\n_exit:;\n\n  YR_DEBUG_FPRINTF(2, VAR_10, \"} = %d // %s()\\n\", VAR_7, VAR_12);\n\n  return VAR_7;\n}",
  "func_graph_path": "VirusTotal/yara/b34b7e74c862c129b801832b6b85401fbada2b01/scan.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -75,7 +75,7 @@\n     uint32_t max_match_data;\n \n     FAIL_ON_ERROR(\n-        yr_get_configuration(YR_CONFIG_MAX_MATCH_DATA, &max_match_data));\n+        yr_get_configuration_uint32(YR_CONFIG_MAX_MATCH_DATA, &max_match_data));\n \n     new_match = yr_notebook_alloc(\n         callback_args->context->matches_notebook, sizeof(YR_MATCH));",
  "diff_line_info": {
    "deleted_lines": [
      "        yr_get_configuration(YR_CONFIG_MAX_MATCH_DATA, &max_match_data));"
    ],
    "added_lines": [
      "        yr_get_configuration_uint32(YR_CONFIG_MAX_MATCH_DATA, &max_match_data));"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/VirusTotal/yara/pull/1621",
  "description": {
    "pr_info": {
      "title": "Fix issue #1616",
      "number": 1621
    },
    "comment": [
      "This is a more comprehensive fix than #1617, it adds new functions to the API for getting/setting uint32 and uint64 settings.  Using these functions is preferable over calling `yr_(get|set)_configuration` directly."
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.7,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.7\n\nThe patch introduces new API functions to handle uint32 and uint64 settings, which is a functional improvement that likely addresses a specific issue, though not explicitly a security one. The confidence is medium due to the potential ambiguity between fixing a defect and introducing a new feature."
}