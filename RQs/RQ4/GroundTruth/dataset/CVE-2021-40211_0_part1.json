{
  "cve_id": "CVE-2021-40211",
  "cwe_ids": [
    "CWE-369"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "ImageMagick",
  "commit_msg": "fix Division by zero in XMenuWidget() of MagickCore/widget.c",
  "commit_hash": "784d270663061bbf472b500215915c282b131ae0",
  "git_url": "https://github.com/ImageMagick/ImageMagick/commit/784d270663061bbf472b500215915c282b131ae0",
  "file_path": "MagickCore/widget.c",
  "func_name": "XMenuWidget",
  "func_before": "MagickPrivate int XMenuWidget(Display *display,XWindows *windows,\n  const char *title,const char *const *selections,char *item)\n{\n  Cursor\n    cursor;\n\n  int\n    id,\n    x,\n    y;\n\n  unsigned int\n    height,\n    number_selections,\n    title_height,\n    top_offset,\n    width;\n\n  size_t\n    state;\n\n  XEvent\n    event;\n\n  XFontStruct\n    *font_info;\n\n  XSetWindowAttributes\n    window_attributes;\n\n  XWidgetInfo\n    highlight_info,\n    menu_info,\n    selection_info;\n\n  XWindowChanges\n    window_changes;\n\n  /*\n    Determine Menu widget attributes.\n  */\n  assert(display != (Display *) NULL);\n  assert(windows != (XWindows *) NULL);\n  assert(title != (char *) NULL);\n  assert(selections != (const char **) NULL);\n  assert(item != (char *) NULL);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",title);\n  font_info=windows->widget.font_info;\n  windows->widget.width=submenu_info.active == 0 ?\n    WidgetTextWidth(font_info,(char *) title) : 0;\n  for (id=0; selections[id] != (char *) NULL; id++)\n  {\n    width=WidgetTextWidth(font_info,(char *) selections[id]);\n    if (width > windows->widget.width)\n      windows->widget.width=width;\n  }\n  number_selections=(unsigned int) id;\n  XGetWidgetInfo((char *) NULL,&menu_info);\n  title_height=(unsigned int) (submenu_info.active == 0 ?\n    (3*(font_info->descent+font_info->ascent) >> 1)+5 : 2);\n  width=WidgetTextWidth(font_info,(char *) title);\n  height=(unsigned int) ((3*(font_info->ascent+font_info->descent)) >> 1);\n  /*\n    Position Menu widget.\n  */\n  windows->widget.width+=QuantumMargin+(menu_info.bevel_width << 1);\n  top_offset=title_height+menu_info.bevel_width-1;\n  windows->widget.height=top_offset+number_selections*height+4;\n  windows->widget.min_width=windows->widget.width;\n  windows->widget.min_height=windows->widget.height;\n  XQueryPosition(display,windows->widget.root,&x,&y);\n  windows->widget.x=x-(QuantumMargin >> 1);\n  if (submenu_info.active != 0)\n    {\n      windows->widget.x=\n        windows->command.x+windows->command.width-QuantumMargin;\n      toggle_info.raised=MagickTrue;\n      XDrawTriangleEast(display,&windows->command,&toggle_info);\n    }\n  windows->widget.y=submenu_info.active == 0 ? y-(int)\n    ((3*title_height) >> 2) : y;\n  if (submenu_info.active != 0)\n    windows->widget.y=windows->command.y+submenu_info.y;\n  XConstrainWindowPosition(display,&windows->widget);\n  /*\n    Map Menu widget.\n  */\n  window_attributes.override_redirect=MagickTrue;\n  (void) XChangeWindowAttributes(display,windows->widget.id,\n    (size_t) CWOverrideRedirect,&window_attributes);\n  window_changes.width=(int) windows->widget.width;\n  window_changes.height=(int) windows->widget.height;\n  window_changes.x=windows->widget.x;\n  window_changes.y=windows->widget.y;\n  (void) XReconfigureWMWindow(display,windows->widget.id,windows->widget.screen,\n    (unsigned int) (CWWidth | CWHeight | CWX | CWY),&window_changes);\n  (void) XMapRaised(display,windows->widget.id);\n  windows->widget.mapped=MagickFalse;\n  /*\n    Respond to X events.\n  */\n  selection_info.height=height;\n  cursor=XCreateFontCursor(display,XC_right_ptr);\n  (void) XCheckDefineCursor(display,windows->image.id,cursor);\n  (void) XCheckDefineCursor(display,windows->command.id,cursor);\n  (void) XCheckDefineCursor(display,windows->widget.id,cursor);\n  state=UpdateConfigurationState;\n  do\n  {\n    if (state & UpdateConfigurationState)\n      {\n        /*\n          Initialize selection information.\n        */\n        XGetWidgetInfo((char *) NULL,&menu_info);\n        menu_info.bevel_width--;\n        menu_info.width=windows->widget.width-((menu_info.bevel_width) << 1);\n        menu_info.height=windows->widget.height-((menu_info.bevel_width) << 1);\n        menu_info.x=(int) menu_info.bevel_width;\n        menu_info.y=(int) menu_info.bevel_width;\n        XGetWidgetInfo((char *) NULL,&selection_info);\n        selection_info.center=MagickFalse;\n        selection_info.width=menu_info.width;\n        selection_info.height=height;\n        selection_info.x=menu_info.x;\n        highlight_info=selection_info;\n        highlight_info.bevel_width--;\n        highlight_info.width-=(highlight_info.bevel_width << 1);\n        highlight_info.height-=(highlight_info.bevel_width << 1);\n        highlight_info.x+=highlight_info.bevel_width;\n        state&=(~UpdateConfigurationState);\n      }\n    if (state & RedrawWidgetState)\n      {\n        /*\n          Redraw Menu widget.\n        */\n        if (submenu_info.active == 0)\n          {\n            y=(int) title_height;\n            XSetBevelColor(display,&windows->widget,MagickFalse);\n            (void) XDrawLine(display,windows->widget.id,\n              windows->widget.widget_context,selection_info.x,y-1,\n              (int) selection_info.width,y-1);\n            XSetBevelColor(display,&windows->widget,MagickTrue);\n            (void) XDrawLine(display,windows->widget.id,\n              windows->widget.widget_context,selection_info.x,y,\n              (int) selection_info.width,y);\n            (void) XSetFillStyle(display,windows->widget.widget_context,\n              FillSolid);\n          }\n        /*\n          Draw menu selections.\n        */\n        selection_info.center=MagickTrue;\n        selection_info.y=(int) menu_info.bevel_width;\n        selection_info.text=(char *) title;\n        if (submenu_info.active == 0)\n          XDrawWidgetText(display,&windows->widget,&selection_info);\n        selection_info.center=MagickFalse;\n        selection_info.y=(int) top_offset;\n        for (id=0; id < (int) number_selections; id++)\n        {\n          selection_info.text=(char *) selections[id];\n          XDrawWidgetText(display,&windows->widget,&selection_info);\n          highlight_info.y=selection_info.y+highlight_info.bevel_width;\n          if (id == selection_info.id)\n            XDrawBevel(display,&windows->widget,&highlight_info);\n          selection_info.y+=(int) selection_info.height;\n        }\n        XDrawBevel(display,&windows->widget,&menu_info);\n        state&=(~RedrawWidgetState);\n      }\n    if (number_selections > 2)\n      {\n        /*\n          Redraw Menu line.\n        */\n        y=(int) (top_offset+selection_info.height*(number_selections-1));\n        XSetBevelColor(display,&windows->widget,MagickFalse);\n        (void) XDrawLine(display,windows->widget.id,\n          windows->widget.widget_context,selection_info.x,y-1,\n          (int) selection_info.width,y-1);\n        XSetBevelColor(display,&windows->widget,MagickTrue);\n        (void) XDrawLine(display,windows->widget.id,\n          windows->widget.widget_context,selection_info.x,y,\n          (int) selection_info.width,y);\n        (void) XSetFillStyle(display,windows->widget.widget_context,FillSolid);\n      }\n    /*\n      Wait for next event.\n    */\n    (void) XIfEvent(display,&event,XScreenEvent,(char *) windows);\n    switch (event.type)\n    {\n      case ButtonPress:\n      {\n        if (event.xbutton.window != windows->widget.id)\n          {\n            /*\n              exit menu.\n            */\n            if (event.xbutton.window == windows->command.id)\n              (void) XPutBackEvent(display,&event);\n            selection_info.id=(~0);\n            *item='\\0';\n            state|=ExitState;\n            break;\n          }\n        state&=(~InactiveWidgetState);\n        id=(event.xbutton.y-top_offset)/(int) selection_info.height;\n        selection_info.id=id;\n        if ((id < 0) || (id >= (int) number_selections))\n          break;\n        /*\n          Highlight this selection.\n        */\n        selection_info.y=(int) (top_offset+id*selection_info.height);\n        selection_info.text=(char *) selections[id];\n        XDrawWidgetText(display,&windows->widget,&selection_info);\n        highlight_info.y=selection_info.y+highlight_info.bevel_width;\n        XDrawBevel(display,&windows->widget,&highlight_info);\n        break;\n      }\n      case ButtonRelease:\n      {\n        if (windows->widget.mapped == MagickFalse)\n          break;\n        if (event.xbutton.window == windows->command.id)\n          if ((state & InactiveWidgetState) == 0)\n            break;\n        /*\n          exit menu.\n        */\n        XSetCursorState(display,windows,MagickFalse);\n        *item='\\0';\n        state|=ExitState;\n        break;\n      }\n      case ConfigureNotify:\n      {\n        /*\n          Update widget configuration.\n        */\n        if (event.xconfigure.window != windows->widget.id)\n          break;\n        if ((event.xconfigure.width == (int) windows->widget.width) &&\n            (event.xconfigure.height == (int) windows->widget.height))\n          break;\n        windows->widget.width=(unsigned int)\n          MagickMax(event.xconfigure.width,(int) windows->widget.min_width);\n        windows->widget.height=(unsigned int)\n          MagickMax(event.xconfigure.height,(int) windows->widget.min_height);\n        state|=UpdateConfigurationState;\n        break;\n      }\n      case EnterNotify:\n      {\n        if (event.xcrossing.window != windows->widget.id)\n          break;\n        if (event.xcrossing.state == 0)\n          break;\n        state&=(~InactiveWidgetState);\n        id=((event.xcrossing.y-top_offset)/(int) selection_info.height);\n        if ((selection_info.id >= 0) &&\n            (selection_info.id < (int) number_selections))\n          {\n            /*\n              Unhighlight last selection.\n            */\n            if (id == selection_info.id)\n              break;\n            selection_info.y=(int)\n              (top_offset+selection_info.id*selection_info.height);\n            selection_info.text=(char *) selections[selection_info.id];\n            XDrawWidgetText(display,&windows->widget,&selection_info);\n          }\n        if ((id < 0) || (id >= (int) number_selections))\n          break;\n        /*\n          Highlight this selection.\n        */\n        selection_info.id=id;\n        selection_info.y=(int)\n          (top_offset+selection_info.id*selection_info.height);\n        selection_info.text=(char *) selections[selection_info.id];\n        XDrawWidgetText(display,&windows->widget,&selection_info);\n        highlight_info.y=selection_info.y+highlight_info.bevel_width;\n        XDrawBevel(display,&windows->widget,&highlight_info);\n        break;\n      }\n      case Expose:\n      {\n        if (event.xexpose.window != windows->widget.id)\n          break;\n        if (event.xexpose.count != 0)\n          break;\n        state|=RedrawWidgetState;\n        break;\n      }\n      case LeaveNotify:\n      {\n        if (event.xcrossing.window != windows->widget.id)\n          break;\n        state|=InactiveWidgetState;\n        id=selection_info.id;\n        if ((id < 0) || (id >= (int) number_selections))\n          break;\n        /*\n          Unhighlight last selection.\n        */\n        selection_info.y=(int) (top_offset+id*selection_info.height);\n        selection_info.id=(~0);\n        selection_info.text=(char *) selections[id];\n        XDrawWidgetText(display,&windows->widget,&selection_info);\n        break;\n      }\n      case MotionNotify:\n      {\n        /*\n          Discard pending button motion events.\n        */\n        while (XCheckMaskEvent(display,ButtonMotionMask,&event)) ;\n        if (submenu_info.active != 0)\n          if (event.xmotion.window == windows->command.id)\n            {\n              if ((state & InactiveWidgetState) == 0)\n                {\n                  if (MatteIsActive(submenu_info,event.xmotion) == MagickFalse)\n                    {\n                      selection_info.id=(~0);\n                        *item='\\0';\n                      state|=ExitState;\n                      break;\n                    }\n                }\n              else\n                if (WindowIsActive(windows->command,event.xmotion))\n                  {\n                    selection_info.id=(~0);\n                    *item='\\0';\n                    state|=ExitState;\n                    break;\n                  }\n            }\n        if (event.xmotion.window != windows->widget.id)\n          break;\n        if (state & InactiveWidgetState)\n          break;\n        id=(event.xmotion.y-top_offset)/(int) selection_info.height;\n        if ((selection_info.id >= 0) &&\n            (selection_info.id < (int) number_selections))\n          {\n            /*\n              Unhighlight last selection.\n            */\n            if (id == selection_info.id)\n              break;\n            selection_info.y=(int)\n              (top_offset+selection_info.id*selection_info.height);\n            selection_info.text=(char *) selections[selection_info.id];\n            XDrawWidgetText(display,&windows->widget,&selection_info);\n          }\n        selection_info.id=id;\n        if ((id < 0) || (id >= (int) number_selections))\n          break;\n        /*\n          Highlight this selection.\n        */\n        selection_info.y=(int) (top_offset+id*selection_info.height);\n        selection_info.text=(char *) selections[id];\n        XDrawWidgetText(display,&windows->widget,&selection_info);\n        highlight_info.y=selection_info.y+highlight_info.bevel_width;\n        XDrawBevel(display,&windows->widget,&highlight_info);\n        break;\n      }\n      default:\n        break;\n    }\n  } while ((state & ExitState) == 0);\n  (void) XFreeCursor(display,cursor);\n  window_attributes.override_redirect=MagickFalse;\n  (void) XChangeWindowAttributes(display,windows->widget.id,\n    (size_t) CWOverrideRedirect,&window_attributes);\n  (void) XWithdrawWindow(display,windows->widget.id,windows->widget.screen);\n  XCheckRefreshWindows(display,windows);\n  if (submenu_info.active != 0)\n    {\n      submenu_info.active=MagickFalse;\n      toggle_info.raised=MagickFalse;\n      XDrawTriangleEast(display,&windows->command,&toggle_info);\n    }\n  if ((selection_info.id < 0) || (selection_info.id >= (int) number_selections))\n    return(~0);\n  (void) CopyMagickString(item,selections[selection_info.id],MagickPathExtent);\n  return(selection_info.id);\n}",
  "abstract_func_before": "MagickPrivate VAR_0 XMenuWidget(Display *VAR_1,XWindows *VAR_2,\n  const char *VAR_3,const char *const *VAR_4,char *VAR_5)\n{\n  Cursor\n    VAR_6;\n\n  int\n    VAR_7,\n    VAR_8,\n    VAR_9;\n\n  unsigned int\n    VAR_10,\n    VAR_11,\n    VAR_12,\n    VAR_13,\n    VAR_14;\n\n  size_t\n    VAR_15;\n\n  XEvent\n    VAR_16;\n\n  XFontStruct\n    *VAR_17;\n\n  XSetWindowAttributes\n    VAR_18;\n\n  XWidgetInfo\n    VAR_19,\n    VAR_20,\n    VAR_21;\n\n  XWindowChanges\n    VAR_22;\n\n  /* COMMENT_0 */\n                                     \n    \n  assert(VAR_1 != (Display *) NULL);\n  assert(VAR_2 != (XWindows *) NULL);\n  assert(VAR_3 != (char *) NULL);\n  assert(VAR_4 != (const char **) NULL);\n  assert(VAR_5 != (char *) NULL);\n  (void) LogMagickEvent(VAR_23,GetMagickModule(),\"%s\",VAR_3);\n  VAR_17=VAR_2->widget.font_info;\n  VAR_2->widget.width=VAR_24.active == 0 ?\n    WidgetTextWidth(VAR_17,(char *) VAR_3) : 0;\n  for (VAR_7=0; VAR_4[VAR_7] != (char *) NULL; VAR_7++)\n  {\n    VAR_14=WidgetTextWidth(VAR_17,(char *) VAR_4[VAR_7]);\n    if (VAR_14 > VAR_2->widget.width)\n      VAR_2->widget.width=VAR_14;\n  }\n  VAR_11=(unsigned int) VAR_7;\n  XGetWidgetInfo((char *) NULL,&VAR_20);\n  VAR_12=(unsigned int) (VAR_24.active == 0 ?\n    (3*(VAR_17->descent+VAR_17->ascent) >> 1)+5 : 2);\n  VAR_14=WidgetTextWidth(VAR_17,(char *) VAR_3);\n  VAR_10=(unsigned int) ((3*(VAR_17->ascent+VAR_17->descent)) >> 1);\n  /* COMMENT_3 */\n                         \n    \n  VAR_2->widget.width+=VAR_25+(VAR_20.bevel_width << 1);\n  VAR_13=VAR_12+VAR_20.bevel_width-1;\n  VAR_2->widget.height=VAR_13+VAR_11*VAR_10+4;\n  VAR_2->widget.min_width=VAR_2->widget.width;\n  VAR_2->widget.min_height=VAR_2->widget.height;\n  XQueryPosition(VAR_1,VAR_2->widget.root,&VAR_8,&VAR_9);\n  VAR_2->widget.x=VAR_8-(VAR_25 >> 1);\n  if (VAR_24.active != 0)\n    {\n      VAR_2->widget.x=\n        VAR_2->command.x+VAR_2->command.width-VAR_25;\n      VAR_26.raised=VAR_27;\n      XDrawTriangleEast(VAR_1,&VAR_2->command,&VAR_26);\n    }\n  VAR_2->widget.y=VAR_24.active == 0 ? VAR_9-(int)\n    ((3*VAR_12) >> 2) : VAR_9;\n  if (VAR_24.active != 0)\n    VAR_2->widget.y=VAR_2->command.y+VAR_24.y;\n  XConstrainWindowPosition(VAR_1,&VAR_2->widget);\n  /* COMMENT_6 */\n                    \n    \n  VAR_18.override_redirect=VAR_27;\n  (void) XChangeWindowAttributes(VAR_1,VAR_2->widget.id,\n    (size_t) VAR_28,&VAR_18);\n  VAR_22.width=(int) VAR_2->widget.width;\n  VAR_22.height=(int) VAR_2->widget.height;\n  VAR_22.x=VAR_2->widget.x;\n  VAR_22.y=VAR_2->widget.y;\n  (void) XReconfigureWMWindow(VAR_1,VAR_2->widget.id,VAR_2->widget.screen,\n    (unsigned int) (VAR_29 | VAR_30 | VAR_31 | VAR_32),&VAR_22);\n  (void) XMapRaised(VAR_1,VAR_2->widget.id);\n  VAR_2->widget.mapped=VAR_33;\n  /* COMMENT_9 */\n                        \n    \n  VAR_21.height=VAR_10;\n  VAR_6=XCreateFontCursor(VAR_1,VAR_34);\n  (void) XCheckDefineCursor(VAR_1,VAR_2->image.id,VAR_6);\n  (void) XCheckDefineCursor(VAR_1,VAR_2->command.id,VAR_6);\n  (void) XCheckDefineCursor(VAR_1,VAR_2->widget.id,VAR_6);\n  VAR_15=VAR_35;\n  do\n  {\n    if (VAR_15 & VAR_35)\n      {\n        /* COMMENT_12 */\n                                           \n          \n        XGetWidgetInfo((char *) NULL,&VAR_20);\n        VAR_20.bevel_width--;\n        VAR_20.width=VAR_2->widget.width-((VAR_20.bevel_width) << 1);\n        VAR_20.height=VAR_2->widget.height-((VAR_20.bevel_width) << 1);\n        VAR_20.x=(int) VAR_20.bevel_width;\n        VAR_20.y=(int) VAR_20.bevel_width;\n        XGetWidgetInfo((char *) NULL,&VAR_21);\n        VAR_21.center=VAR_33;\n        VAR_21.width=VAR_20.width;\n        VAR_21.height=VAR_10;\n        VAR_21.x=VAR_20.x;\n        VAR_19=VAR_21;\n        VAR_19.bevel_width--;\n        VAR_19.width-=(VAR_19.bevel_width << 1);\n        VAR_19.height-=(VAR_19.bevel_width << 1);\n        VAR_19.x+=VAR_19.bevel_width;\n        VAR_15&=(~VAR_35);\n      }\n    if (VAR_15 & VAR_36)\n      {\n        /* COMMENT_15 */\n                             \n          \n        if (VAR_24.active == 0)\n          {\n            VAR_9=(int) VAR_12;\n            XSetBevelColor(VAR_1,&VAR_2->widget,VAR_33);\n            (void) XDrawLine(VAR_1,VAR_2->widget.id,\n              VAR_2->widget.widget_context,VAR_21.x,VAR_9-1,\n              (int) VAR_21.width,VAR_9-1);\n            XSetBevelColor(VAR_1,&VAR_2->widget,VAR_27);\n            (void) XDrawLine(VAR_1,VAR_2->widget.id,\n              VAR_2->widget.widget_context,VAR_21.x,VAR_9,\n              (int) VAR_21.width,VAR_9);\n            (void) XSetFillStyle(VAR_1,VAR_2->widget.widget_context,\n              VAR_37);\n          }\n        /* COMMENT_18 */\n                               \n          \n        VAR_21.center=VAR_27;\n        VAR_21.y=(int) VAR_20.bevel_width;\n        VAR_21.text=(char *) VAR_3;\n        if (VAR_24.active == 0)\n          XDrawWidgetText(VAR_1,&VAR_2->widget,&VAR_21);\n        VAR_21.center=VAR_33;\n        VAR_21.y=(int) VAR_13;\n        for (VAR_7=0; VAR_7 < (int) VAR_11; VAR_7++)\n        {\n          VAR_21.text=(char *) VAR_4[VAR_7];\n          XDrawWidgetText(VAR_1,&VAR_2->widget,&VAR_21);\n          VAR_19.y=VAR_21.y+VAR_19.bevel_width;\n          if (VAR_7 == VAR_21.id)\n            XDrawBevel(VAR_1,&VAR_2->widget,&VAR_19);\n          VAR_21.y+=(int) VAR_21.height;\n        }\n        XDrawBevel(VAR_1,&VAR_2->widget,&VAR_20);\n        VAR_15&=(~VAR_36);\n      }\n    if (VAR_11 > 2)\n      {\n        /* COMMENT_21 */\n                           \n          \n        VAR_9=(int) (VAR_13+VAR_21.height*(VAR_11-1));\n        XSetBevelColor(VAR_1,&VAR_2->widget,VAR_33);\n        (void) XDrawLine(VAR_1,VAR_2->widget.id,\n          VAR_2->widget.widget_context,VAR_21.x,VAR_9-1,\n          (int) VAR_21.width,VAR_9-1);\n        XSetBevelColor(VAR_1,&VAR_2->widget,VAR_27);\n        (void) XDrawLine(VAR_1,VAR_2->widget.id,\n          VAR_2->widget.widget_context,VAR_21.x,VAR_9,\n          (int) VAR_21.width,VAR_9);\n        (void) XSetFillStyle(VAR_1,VAR_2->widget.widget_context,VAR_37);\n      }\n    /* COMMENT_24 */\n                          \n      \n    (void) XIfEvent(VAR_1,&VAR_16,VAR_38,(char *) VAR_2);\n    switch (VAR_16.type)\n    {\n      case VAR_39:\n      {\n        if (VAR_16.xbutton.window != VAR_2->widget.id)\n          {\n            /* COMMENT_27 */\n                        \n              \n            if (VAR_16.xbutton.window == VAR_2->command.id)\n              (void) XPutBackEvent(VAR_1,&VAR_16);\n            VAR_21.id=(~0);\n            *VAR_5='\\0';\n            VAR_15|=VAR_40;\n            break;\n          }\n        VAR_15&=(~VAR_41);\n        VAR_7=(VAR_16.xbutton.y-VAR_13)/(int) VAR_21.height;\n        VAR_21.id=VAR_7;\n        if ((VAR_7 < 0) || (VAR_7 >= (int) VAR_11))\n          break;\n        /* COMMENT_30 */\n                                   \n          \n        VAR_21.y=(int) (VAR_13+VAR_7*VAR_21.height);\n        VAR_21.text=(char *) VAR_4[VAR_7];\n        XDrawWidgetText(VAR_1,&VAR_2->widget,&VAR_21);\n        VAR_19.y=VAR_21.y+VAR_19.bevel_width;\n        XDrawBevel(VAR_1,&VAR_2->widget,&VAR_19);\n        break;\n      }\n      case VAR_42:\n      {\n        if (VAR_2->widget.mapped == VAR_33)\n          break;\n        if (VAR_16.xbutton.window == VAR_2->command.id)\n          if ((VAR_15 & VAR_41) == 0)\n            break;\n        /* COMMENT_33 */\n                    \n          \n        XSetCursorState(VAR_1,VAR_2,VAR_33);\n        *VAR_5='\\0';\n        VAR_15|=VAR_40;\n        break;\n      }\n      case VAR_43:\n      {\n        /* COMMENT_36 */\n                                      \n          \n        if (VAR_16.xconfigure.window != VAR_2->widget.id)\n          break;\n        if ((VAR_16.xconfigure.width == (int) VAR_2->widget.width) &&\n            (VAR_16.xconfigure.height == (int) VAR_2->widget.height))\n          break;\n        VAR_2->widget.width=(unsigned int)\n          MagickMax(VAR_16.xconfigure.width,(int) VAR_2->widget.min_width);\n        VAR_2->widget.height=(unsigned int)\n          MagickMax(VAR_16.xconfigure.height,(int) VAR_2->widget.min_height);\n        VAR_15|=VAR_35;\n        break;\n      }\n      case VAR_44:\n      {\n        if (VAR_16.xcrossing.window != VAR_2->widget.id)\n          break;\n        if (VAR_16.xcrossing.state == 0)\n          break;\n        VAR_15&=(~VAR_41);\n        VAR_7=((VAR_16.xcrossing.y-VAR_13)/(int) VAR_21.height);\n        if ((VAR_21.id >= 0) &&\n            (VAR_21.id < (int) VAR_11))\n          {\n            /* COMMENT_39 */\n                                         \n              \n            if (VAR_7 == VAR_21.id)\n              break;\n            VAR_21.y=(int)\n              (VAR_13+VAR_21.id*VAR_21.height);\n            VAR_21.text=(char *) VAR_4[VAR_21.id];\n            XDrawWidgetText(VAR_1,&VAR_2->widget,&VAR_21);\n          }\n        if ((VAR_7 < 0) || (VAR_7 >= (int) VAR_11))\n          break;\n        /* COMMENT_42 */\n                                   \n          \n        VAR_21.id=VAR_7;\n        VAR_21.y=(int)\n          (VAR_13+VAR_21.id*VAR_21.height);\n        VAR_21.text=(char *) VAR_4[VAR_21.id];\n        XDrawWidgetText(VAR_1,&VAR_2->widget,&VAR_21);\n        VAR_19.y=VAR_21.y+VAR_19.bevel_width;\n        XDrawBevel(VAR_1,&VAR_2->widget,&VAR_19);\n        break;\n      }\n      case VAR_45:\n      {\n        if (VAR_16.xexpose.window != VAR_2->widget.id)\n          break;\n        if (VAR_16.xexpose.count != 0)\n          break;\n        VAR_15|=VAR_36;\n        break;\n      }\n      case VAR_46:\n      {\n        if (VAR_16.xcrossing.window != VAR_2->widget.id)\n          break;\n        VAR_15|=VAR_41;\n        VAR_7=VAR_21.id;\n        if ((VAR_7 < 0) || (VAR_7 >= (int) VAR_11))\n          break;\n        /* COMMENT_45 */\n                                     \n          \n        VAR_21.y=(int) (VAR_13+VAR_7*VAR_21.height);\n        VAR_21.id=(~0);\n        VAR_21.text=(char *) VAR_4[VAR_7];\n        XDrawWidgetText(VAR_1,&VAR_2->widget,&VAR_21);\n        break;\n      }\n      case VAR_47:\n      {\n        /* COMMENT_48 */\n                                               \n          \n        while (XCheckMaskEvent(VAR_1,VAR_48,&VAR_16)) ;\n        if (VAR_24.active != 0)\n          if (VAR_16.xmotion.window == VAR_2->command.id)\n            {\n              if ((VAR_15 & VAR_41) == 0)\n                {\n                  if (MatteIsActive(VAR_24,VAR_16.xmotion) == VAR_33)\n                    {\n                      VAR_21.id=(~0);\n                        *VAR_5='\\0';\n                      VAR_15|=VAR_40;\n                      break;\n                    }\n                }\n              else\n                if (WindowIsActive(VAR_2->command,VAR_16.xmotion))\n                  {\n                    VAR_21.id=(~0);\n                    *VAR_5='\\0';\n                    VAR_15|=VAR_40;\n                    break;\n                  }\n            }\n        if (VAR_16.xmotion.window != VAR_2->widget.id)\n          break;\n        if (VAR_15 & VAR_41)\n          break;\n        VAR_7=(VAR_16.xmotion.y-VAR_13)/(int) VAR_21.height;\n        if ((VAR_21.id >= 0) &&\n            (VAR_21.id < (int) VAR_11))\n          {\n            /* COMMENT_51 */\n                                         \n              \n            if (VAR_7 == VAR_21.id)\n              break;\n            VAR_21.y=(int)\n              (VAR_13+VAR_21.id*VAR_21.height);\n            VAR_21.text=(char *) VAR_4[VAR_21.id];\n            XDrawWidgetText(VAR_1,&VAR_2->widget,&VAR_21);\n          }\n        VAR_21.id=VAR_7;\n        if ((VAR_7 < 0) || (VAR_7 >= (int) VAR_11))\n          break;\n        /* COMMENT_54 */\n                                   \n          \n        VAR_21.y=(int) (VAR_13+VAR_7*VAR_21.height);\n        VAR_21.text=(char *) VAR_4[VAR_7];\n        XDrawWidgetText(VAR_1,&VAR_2->widget,&VAR_21);\n        VAR_19.y=VAR_21.y+VAR_19.bevel_width;\n        XDrawBevel(VAR_1,&VAR_2->widget,&VAR_19);\n        break;\n      }\n      default:\n        break;\n    }\n  } while ((VAR_15 & VAR_40) == 0);\n  (void) XFreeCursor(VAR_1,VAR_6);\n  VAR_18.override_redirect=VAR_33;\n  (void) XChangeWindowAttributes(VAR_1,VAR_2->widget.id,\n    (size_t) VAR_28,&VAR_18);\n  (void) XWithdrawWindow(VAR_1,VAR_2->widget.id,VAR_2->widget.screen);\n  XCheckRefreshWindows(VAR_1,VAR_2);\n  if (VAR_24.active != 0)\n    {\n      VAR_24.active=VAR_33;\n      VAR_26.raised=VAR_33;\n      XDrawTriangleEast(VAR_1,&VAR_2->command,&VAR_26);\n    }\n  if ((VAR_21.id < 0) || (VAR_21.id >= (int) VAR_11))\n    return(~0);\n  (void) CopyMagickString(VAR_5,VAR_4[VAR_21.id],VAR_49);\n  return(VAR_21.id);\n}",
  "func_graph_path_before": null,
  "func": "MagickPrivate int XMenuWidget(Display *display,XWindows *windows,\n  const char *title,const char *const *selections,char *item)\n{\n  Cursor\n    cursor;\n\n  int\n    id,\n    x,\n    y;\n\n  unsigned int\n    height,\n    number_selections,\n    title_height,\n    top_offset,\n    width;\n\n  size_t\n    state;\n\n  XEvent\n    event;\n\n  XFontStruct\n    *font_info;\n\n  XSetWindowAttributes\n    window_attributes;\n\n  XWidgetInfo\n    highlight_info,\n    menu_info,\n    selection_info;\n\n  XWindowChanges\n    window_changes;\n\n  /*\n    Determine Menu widget attributes.\n  */\n  assert(display != (Display *) NULL);\n  assert(windows != (XWindows *) NULL);\n  assert(title != (char *) NULL);\n  assert(selections != (const char **) NULL);\n  assert(item != (char *) NULL);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",title);\n  font_info=windows->widget.font_info;\n  windows->widget.width=submenu_info.active == 0 ?\n    WidgetTextWidth(font_info,(char *) title) : 0;\n  for (id=0; selections[id] != (char *) NULL; id++)\n  {\n    width=WidgetTextWidth(font_info,(char *) selections[id]);\n    if (width > windows->widget.width)\n      windows->widget.width=width;\n  }\n  number_selections=(unsigned int) id;\n  XGetWidgetInfo((char *) NULL,&menu_info);\n  title_height=(unsigned int) (submenu_info.active == 0 ?\n    (3*(font_info->descent+font_info->ascent) >> 1)+5 : 2);\n  width=WidgetTextWidth(font_info,(char *) title);\n  height=(unsigned int) ((3*(font_info->ascent+font_info->descent)) >> 1);\n  /*\n    Position Menu widget.\n  */\n  windows->widget.width+=QuantumMargin+(menu_info.bevel_width << 1);\n  top_offset=title_height+menu_info.bevel_width-1;\n  windows->widget.height=top_offset+number_selections*height+4;\n  windows->widget.min_width=windows->widget.width;\n  windows->widget.min_height=windows->widget.height;\n  XQueryPosition(display,windows->widget.root,&x,&y);\n  windows->widget.x=x-(QuantumMargin >> 1);\n  if (submenu_info.active != 0)\n    {\n      windows->widget.x=\n        windows->command.x+windows->command.width-QuantumMargin;\n      toggle_info.raised=MagickTrue;\n      XDrawTriangleEast(display,&windows->command,&toggle_info);\n    }\n  windows->widget.y=submenu_info.active == 0 ? y-(int)\n    ((3*title_height) >> 2) : y;\n  if (submenu_info.active != 0)\n    windows->widget.y=windows->command.y+submenu_info.y;\n  XConstrainWindowPosition(display,&windows->widget);\n  /*\n    Map Menu widget.\n  */\n  window_attributes.override_redirect=MagickTrue;\n  (void) XChangeWindowAttributes(display,windows->widget.id,\n    (size_t) CWOverrideRedirect,&window_attributes);\n  window_changes.width=(int) windows->widget.width;\n  window_changes.height=(int) windows->widget.height;\n  window_changes.x=windows->widget.x;\n  window_changes.y=windows->widget.y;\n  (void) XReconfigureWMWindow(display,windows->widget.id,windows->widget.screen,\n    (unsigned int) (CWWidth | CWHeight | CWX | CWY),&window_changes);\n  (void) XMapRaised(display,windows->widget.id);\n  windows->widget.mapped=MagickFalse;\n  /*\n    Respond to X events.\n  */\n  selection_info.height=height;\n  cursor=XCreateFontCursor(display,XC_right_ptr);\n  (void) XCheckDefineCursor(display,windows->image.id,cursor);\n  (void) XCheckDefineCursor(display,windows->command.id,cursor);\n  (void) XCheckDefineCursor(display,windows->widget.id,cursor);\n  state=UpdateConfigurationState;\n  do\n  {\n    if (state & UpdateConfigurationState)\n      {\n        /*\n          Initialize selection information.\n        */\n        XGetWidgetInfo((char *) NULL,&menu_info);\n        menu_info.bevel_width--;\n        menu_info.width=windows->widget.width-((menu_info.bevel_width) << 1);\n        menu_info.height=windows->widget.height-((menu_info.bevel_width) << 1);\n        menu_info.x=(int) menu_info.bevel_width;\n        menu_info.y=(int) menu_info.bevel_width;\n        XGetWidgetInfo((char *) NULL,&selection_info);\n        selection_info.center=MagickFalse;\n        selection_info.width=menu_info.width;\n        selection_info.height=height;\n        selection_info.x=menu_info.x;\n        highlight_info=selection_info;\n        highlight_info.bevel_width--;\n        highlight_info.width-=(highlight_info.bevel_width << 1);\n        highlight_info.height-=(highlight_info.bevel_width << 1);\n        highlight_info.x+=highlight_info.bevel_width;\n        state&=(~UpdateConfigurationState);\n      }\n    if (state & RedrawWidgetState)\n      {\n        /*\n          Redraw Menu widget.\n        */\n        if (submenu_info.active == 0)\n          {\n            y=(int) title_height;\n            XSetBevelColor(display,&windows->widget,MagickFalse);\n            (void) XDrawLine(display,windows->widget.id,\n              windows->widget.widget_context,selection_info.x,y-1,\n              (int) selection_info.width,y-1);\n            XSetBevelColor(display,&windows->widget,MagickTrue);\n            (void) XDrawLine(display,windows->widget.id,\n              windows->widget.widget_context,selection_info.x,y,\n              (int) selection_info.width,y);\n            (void) XSetFillStyle(display,windows->widget.widget_context,\n              FillSolid);\n          }\n        /*\n          Draw menu selections.\n        */\n        selection_info.center=MagickTrue;\n        selection_info.y=(int) menu_info.bevel_width;\n        selection_info.text=(char *) title;\n        if (submenu_info.active == 0)\n          XDrawWidgetText(display,&windows->widget,&selection_info);\n        selection_info.center=MagickFalse;\n        selection_info.y=(int) top_offset;\n        for (id=0; id < (int) number_selections; id++)\n        {\n          selection_info.text=(char *) selections[id];\n          XDrawWidgetText(display,&windows->widget,&selection_info);\n          highlight_info.y=selection_info.y+highlight_info.bevel_width;\n          if (id == selection_info.id)\n            XDrawBevel(display,&windows->widget,&highlight_info);\n          selection_info.y+=(int) selection_info.height;\n        }\n        XDrawBevel(display,&windows->widget,&menu_info);\n        state&=(~RedrawWidgetState);\n      }\n    if (number_selections > 2)\n      {\n        /*\n          Redraw Menu line.\n        */\n        y=(int) (top_offset+selection_info.height*(number_selections-1));\n        XSetBevelColor(display,&windows->widget,MagickFalse);\n        (void) XDrawLine(display,windows->widget.id,\n          windows->widget.widget_context,selection_info.x,y-1,\n          (int) selection_info.width,y-1);\n        XSetBevelColor(display,&windows->widget,MagickTrue);\n        (void) XDrawLine(display,windows->widget.id,\n          windows->widget.widget_context,selection_info.x,y,\n          (int) selection_info.width,y);\n        (void) XSetFillStyle(display,windows->widget.widget_context,FillSolid);\n      }\n    /*\n      Wait for next event.\n    */\n    (void) XIfEvent(display,&event,XScreenEvent,(char *) windows);\n    switch (event.type)\n    {\n      case ButtonPress:\n      {\n        if (event.xbutton.window != windows->widget.id)\n          {\n            /*\n              exit menu.\n            */\n            if (event.xbutton.window == windows->command.id)\n              (void) XPutBackEvent(display,&event);\n            selection_info.id=(~0);\n            *item='\\0';\n            state|=ExitState;\n            break;\n          }\n        state&=(~InactiveWidgetState);\n        if (selection_info.height == 0)\n          break;\n        id=(event.xbutton.y-top_offset)/(int) selection_info.height;\n        selection_info.id=id;\n        if ((id < 0) || (id >= (int) number_selections))\n          break;\n        /*\n          Highlight this selection.\n        */\n        selection_info.y=(int) (top_offset+id*selection_info.height);\n        selection_info.text=(char *) selections[id];\n        XDrawWidgetText(display,&windows->widget,&selection_info);\n        highlight_info.y=selection_info.y+highlight_info.bevel_width;\n        XDrawBevel(display,&windows->widget,&highlight_info);\n        break;\n      }\n      case ButtonRelease:\n      {\n        if (windows->widget.mapped == MagickFalse)\n          break;\n        if (event.xbutton.window == windows->command.id)\n          if ((state & InactiveWidgetState) == 0)\n            break;\n        /*\n          exit menu.\n        */\n        XSetCursorState(display,windows,MagickFalse);\n        *item='\\0';\n        state|=ExitState;\n        break;\n      }\n      case ConfigureNotify:\n      {\n        /*\n          Update widget configuration.\n        */\n        if (event.xconfigure.window != windows->widget.id)\n          break;\n        if ((event.xconfigure.width == (int) windows->widget.width) &&\n            (event.xconfigure.height == (int) windows->widget.height))\n          break;\n        windows->widget.width=(unsigned int)\n          MagickMax(event.xconfigure.width,(int) windows->widget.min_width);\n        windows->widget.height=(unsigned int)\n          MagickMax(event.xconfigure.height,(int) windows->widget.min_height);\n        state|=UpdateConfigurationState;\n        break;\n      }\n      case EnterNotify:\n      {\n        if (event.xcrossing.window != windows->widget.id)\n          break;\n        if (event.xcrossing.state == 0)\n          break;\n        state&=(~InactiveWidgetState);\n        if (selection_info.height == 0)\n          break;\n        id=((event.xcrossing.y-top_offset)/(int) selection_info.height);\n        if ((selection_info.id >= 0) &&\n            (selection_info.id < (int) number_selections))\n          {\n            /*\n              Unhighlight last selection.\n            */\n            if (id == selection_info.id)\n              break;\n            selection_info.y=(int)\n              (top_offset+selection_info.id*selection_info.height);\n            selection_info.text=(char *) selections[selection_info.id];\n            XDrawWidgetText(display,&windows->widget,&selection_info);\n          }\n        if ((id < 0) || (id >= (int) number_selections))\n          break;\n        /*\n          Highlight this selection.\n        */\n        selection_info.id=id;\n        selection_info.y=(int)\n          (top_offset+selection_info.id*selection_info.height);\n        selection_info.text=(char *) selections[selection_info.id];\n        XDrawWidgetText(display,&windows->widget,&selection_info);\n        highlight_info.y=selection_info.y+highlight_info.bevel_width;\n        XDrawBevel(display,&windows->widget,&highlight_info);\n        break;\n      }\n      case Expose:\n      {\n        if (event.xexpose.window != windows->widget.id)\n          break;\n        if (event.xexpose.count != 0)\n          break;\n        state|=RedrawWidgetState;\n        break;\n      }\n      case LeaveNotify:\n      {\n        if (event.xcrossing.window != windows->widget.id)\n          break;\n        state|=InactiveWidgetState;\n        id=selection_info.id;\n        if ((id < 0) || (id >= (int) number_selections))\n          break;\n        /*\n          Unhighlight last selection.\n        */\n        selection_info.y=(int) (top_offset+id*selection_info.height);\n        selection_info.id=(~0);\n        selection_info.text=(char *) selections[id];\n        XDrawWidgetText(display,&windows->widget,&selection_info);\n        break;\n      }\n      case MotionNotify:\n      {\n        /*\n          Discard pending button motion events.\n        */\n        while (XCheckMaskEvent(display,ButtonMotionMask,&event)) ;\n        if (submenu_info.active != 0)\n          if (event.xmotion.window == windows->command.id)\n            {\n              if ((state & InactiveWidgetState) == 0)\n                {\n                  if (MatteIsActive(submenu_info,event.xmotion) == MagickFalse)\n                    {\n                      selection_info.id=(~0);\n                        *item='\\0';\n                      state|=ExitState;\n                      break;\n                    }\n                }\n              else\n                if (WindowIsActive(windows->command,event.xmotion))\n                  {\n                    selection_info.id=(~0);\n                    *item='\\0';\n                    state|=ExitState;\n                    break;\n                  }\n            }\n        if (event.xmotion.window != windows->widget.id)\n          break;\n        if (state & InactiveWidgetState)\n          break;\n        if (selection_info.height == 0)\n          break;\n        id=(event.xmotion.y-top_offset)/(int) selection_info.height;\n        if ((selection_info.id >= 0) &&\n            (selection_info.id < (int) number_selections))\n          {\n            /*\n              Unhighlight last selection.\n            */\n            if (id == selection_info.id)\n              break;\n            selection_info.y=(int)\n              (top_offset+selection_info.id*selection_info.height);\n            selection_info.text=(char *) selections[selection_info.id];\n            XDrawWidgetText(display,&windows->widget,&selection_info);\n          }\n        selection_info.id=id;\n        if ((id < 0) || (id >= (int) number_selections))\n          break;\n        /*\n          Highlight this selection.\n        */\n        selection_info.y=(int) (top_offset+id*selection_info.height);\n        selection_info.text=(char *) selections[id];\n        XDrawWidgetText(display,&windows->widget,&selection_info);\n        highlight_info.y=selection_info.y+highlight_info.bevel_width;\n        XDrawBevel(display,&windows->widget,&highlight_info);\n        break;\n      }\n      default:\n        break;\n    }\n  } while ((state & ExitState) == 0);\n  (void) XFreeCursor(display,cursor);\n  window_attributes.override_redirect=MagickFalse;\n  (void) XChangeWindowAttributes(display,windows->widget.id,\n    (size_t) CWOverrideRedirect,&window_attributes);\n  (void) XWithdrawWindow(display,windows->widget.id,windows->widget.screen);\n  XCheckRefreshWindows(display,windows);\n  if (submenu_info.active != 0)\n    {\n      submenu_info.active=MagickFalse;\n      toggle_info.raised=MagickFalse;\n      XDrawTriangleEast(display,&windows->command,&toggle_info);\n    }\n  if ((selection_info.id < 0) || (selection_info.id >= (int) number_selections))\n    return(~0);\n  (void) CopyMagickString(item,selections[selection_info.id],MagickPathExtent);\n  return(selection_info.id);\n}",
  "abstract_func": "MagickPrivate VAR_0 XMenuWidget(Display *VAR_1,XWindows *VAR_2,\n  const char *VAR_3,const char *const *VAR_4,char *VAR_5)\n{\n  Cursor\n    VAR_6;\n\n  int\n    VAR_7,\n    VAR_8,\n    VAR_9;\n\n  unsigned int\n    VAR_10,\n    VAR_11,\n    VAR_12,\n    VAR_13,\n    VAR_14;\n\n  size_t\n    VAR_15;\n\n  XEvent\n    VAR_16;\n\n  XFontStruct\n    *VAR_17;\n\n  XSetWindowAttributes\n    VAR_18;\n\n  XWidgetInfo\n    VAR_19,\n    VAR_20,\n    VAR_21;\n\n  XWindowChanges\n    VAR_22;\n\n  /* COMMENT_0 */\n                                     \n    \n  assert(VAR_1 != (Display *) NULL);\n  assert(VAR_2 != (XWindows *) NULL);\n  assert(VAR_3 != (char *) NULL);\n  assert(VAR_4 != (const char **) NULL);\n  assert(VAR_5 != (char *) NULL);\n  (void) LogMagickEvent(VAR_23,GetMagickModule(),\"%s\",VAR_3);\n  VAR_17=VAR_2->widget.font_info;\n  VAR_2->widget.width=VAR_24.active == 0 ?\n    WidgetTextWidth(VAR_17,(char *) VAR_3) : 0;\n  for (VAR_7=0; VAR_4[VAR_7] != (char *) NULL; VAR_7++)\n  {\n    VAR_14=WidgetTextWidth(VAR_17,(char *) VAR_4[VAR_7]);\n    if (VAR_14 > VAR_2->widget.width)\n      VAR_2->widget.width=VAR_14;\n  }\n  VAR_11=(unsigned int) VAR_7;\n  XGetWidgetInfo((char *) NULL,&VAR_20);\n  VAR_12=(unsigned int) (VAR_24.active == 0 ?\n    (3*(VAR_17->descent+VAR_17->ascent) >> 1)+5 : 2);\n  VAR_14=WidgetTextWidth(VAR_17,(char *) VAR_3);\n  VAR_10=(unsigned int) ((3*(VAR_17->ascent+VAR_17->descent)) >> 1);\n  /* COMMENT_3 */\n                         \n    \n  VAR_2->widget.width+=VAR_25+(VAR_20.bevel_width << 1);\n  VAR_13=VAR_12+VAR_20.bevel_width-1;\n  VAR_2->widget.height=VAR_13+VAR_11*VAR_10+4;\n  VAR_2->widget.min_width=VAR_2->widget.width;\n  VAR_2->widget.min_height=VAR_2->widget.height;\n  XQueryPosition(VAR_1,VAR_2->widget.root,&VAR_8,&VAR_9);\n  VAR_2->widget.x=VAR_8-(VAR_25 >> 1);\n  if (VAR_24.active != 0)\n    {\n      VAR_2->widget.x=\n        VAR_2->command.x+VAR_2->command.width-VAR_25;\n      VAR_26.raised=VAR_27;\n      XDrawTriangleEast(VAR_1,&VAR_2->command,&VAR_26);\n    }\n  VAR_2->widget.y=VAR_24.active == 0 ? VAR_9-(int)\n    ((3*VAR_12) >> 2) : VAR_9;\n  if (VAR_24.active != 0)\n    VAR_2->widget.y=VAR_2->command.y+VAR_24.y;\n  XConstrainWindowPosition(VAR_1,&VAR_2->widget);\n  /* COMMENT_6 */\n                    \n    \n  VAR_18.override_redirect=VAR_27;\n  (void) XChangeWindowAttributes(VAR_1,VAR_2->widget.id,\n    (size_t) VAR_28,&VAR_18);\n  VAR_22.width=(int) VAR_2->widget.width;\n  VAR_22.height=(int) VAR_2->widget.height;\n  VAR_22.x=VAR_2->widget.x;\n  VAR_22.y=VAR_2->widget.y;\n  (void) XReconfigureWMWindow(VAR_1,VAR_2->widget.id,VAR_2->widget.screen,\n    (unsigned int) (VAR_29 | VAR_30 | VAR_31 | VAR_32),&VAR_22);\n  (void) XMapRaised(VAR_1,VAR_2->widget.id);\n  VAR_2->widget.mapped=VAR_33;\n  /* COMMENT_9 */\n                        \n    \n  VAR_21.height=VAR_10;\n  VAR_6=XCreateFontCursor(VAR_1,VAR_34);\n  (void) XCheckDefineCursor(VAR_1,VAR_2->image.id,VAR_6);\n  (void) XCheckDefineCursor(VAR_1,VAR_2->command.id,VAR_6);\n  (void) XCheckDefineCursor(VAR_1,VAR_2->widget.id,VAR_6);\n  VAR_15=VAR_35;\n  do\n  {\n    if (VAR_15 & VAR_35)\n      {\n        /* COMMENT_12 */\n                                           \n          \n        XGetWidgetInfo((char *) NULL,&VAR_20);\n        VAR_20.bevel_width--;\n        VAR_20.width=VAR_2->widget.width-((VAR_20.bevel_width) << 1);\n        VAR_20.height=VAR_2->widget.height-((VAR_20.bevel_width) << 1);\n        VAR_20.x=(int) VAR_20.bevel_width;\n        VAR_20.y=(int) VAR_20.bevel_width;\n        XGetWidgetInfo((char *) NULL,&VAR_21);\n        VAR_21.center=VAR_33;\n        VAR_21.width=VAR_20.width;\n        VAR_21.height=VAR_10;\n        VAR_21.x=VAR_20.x;\n        VAR_19=VAR_21;\n        VAR_19.bevel_width--;\n        VAR_19.width-=(VAR_19.bevel_width << 1);\n        VAR_19.height-=(VAR_19.bevel_width << 1);\n        VAR_19.x+=VAR_19.bevel_width;\n        VAR_15&=(~VAR_35);\n      }\n    if (VAR_15 & VAR_36)\n      {\n        /* COMMENT_15 */\n                             \n          \n        if (VAR_24.active == 0)\n          {\n            VAR_9=(int) VAR_12;\n            XSetBevelColor(VAR_1,&VAR_2->widget,VAR_33);\n            (void) XDrawLine(VAR_1,VAR_2->widget.id,\n              VAR_2->widget.widget_context,VAR_21.x,VAR_9-1,\n              (int) VAR_21.width,VAR_9-1);\n            XSetBevelColor(VAR_1,&VAR_2->widget,VAR_27);\n            (void) XDrawLine(VAR_1,VAR_2->widget.id,\n              VAR_2->widget.widget_context,VAR_21.x,VAR_9,\n              (int) VAR_21.width,VAR_9);\n            (void) XSetFillStyle(VAR_1,VAR_2->widget.widget_context,\n              VAR_37);\n          }\n        /* COMMENT_18 */\n                               \n          \n        VAR_21.center=VAR_27;\n        VAR_21.y=(int) VAR_20.bevel_width;\n        VAR_21.text=(char *) VAR_3;\n        if (VAR_24.active == 0)\n          XDrawWidgetText(VAR_1,&VAR_2->widget,&VAR_21);\n        VAR_21.center=VAR_33;\n        VAR_21.y=(int) VAR_13;\n        for (VAR_7=0; VAR_7 < (int) VAR_11; VAR_7++)\n        {\n          VAR_21.text=(char *) VAR_4[VAR_7];\n          XDrawWidgetText(VAR_1,&VAR_2->widget,&VAR_21);\n          VAR_19.y=VAR_21.y+VAR_19.bevel_width;\n          if (VAR_7 == VAR_21.id)\n            XDrawBevel(VAR_1,&VAR_2->widget,&VAR_19);\n          VAR_21.y+=(int) VAR_21.height;\n        }\n        XDrawBevel(VAR_1,&VAR_2->widget,&VAR_20);\n        VAR_15&=(~VAR_36);\n      }\n    if (VAR_11 > 2)\n      {\n        /* COMMENT_21 */\n                           \n          \n        VAR_9=(int) (VAR_13+VAR_21.height*(VAR_11-1));\n        XSetBevelColor(VAR_1,&VAR_2->widget,VAR_33);\n        (void) XDrawLine(VAR_1,VAR_2->widget.id,\n          VAR_2->widget.widget_context,VAR_21.x,VAR_9-1,\n          (int) VAR_21.width,VAR_9-1);\n        XSetBevelColor(VAR_1,&VAR_2->widget,VAR_27);\n        (void) XDrawLine(VAR_1,VAR_2->widget.id,\n          VAR_2->widget.widget_context,VAR_21.x,VAR_9,\n          (int) VAR_21.width,VAR_9);\n        (void) XSetFillStyle(VAR_1,VAR_2->widget.widget_context,VAR_37);\n      }\n    /* COMMENT_24 */\n                          \n      \n    (void) XIfEvent(VAR_1,&VAR_16,VAR_38,(char *) VAR_2);\n    switch (VAR_16.type)\n    {\n      case VAR_39:\n      {\n        if (VAR_16.xbutton.window != VAR_2->widget.id)\n          {\n            /* COMMENT_27 */\n                        \n              \n            if (VAR_16.xbutton.window == VAR_2->command.id)\n              (void) XPutBackEvent(VAR_1,&VAR_16);\n            VAR_21.id=(~0);\n            *VAR_5='\\0';\n            VAR_15|=VAR_40;\n            break;\n          }\n        VAR_15&=(~VAR_41);\n        if (VAR_21.height == 0)\n          break;\n        VAR_7=(VAR_16.xbutton.y-VAR_13)/(int) VAR_21.height;\n        VAR_21.id=VAR_7;\n        if ((VAR_7 < 0) || (VAR_7 >= (int) VAR_11))\n          break;\n        /* COMMENT_30 */\n                                   \n          \n        VAR_21.y=(int) (VAR_13+VAR_7*VAR_21.height);\n        VAR_21.text=(char *) VAR_4[VAR_7];\n        XDrawWidgetText(VAR_1,&VAR_2->widget,&VAR_21);\n        VAR_19.y=VAR_21.y+VAR_19.bevel_width;\n        XDrawBevel(VAR_1,&VAR_2->widget,&VAR_19);\n        break;\n      }\n      case VAR_42:\n      {\n        if (VAR_2->widget.mapped == VAR_33)\n          break;\n        if (VAR_16.xbutton.window == VAR_2->command.id)\n          if ((VAR_15 & VAR_41) == 0)\n            break;\n        /* COMMENT_33 */\n                    \n          \n        XSetCursorState(VAR_1,VAR_2,VAR_33);\n        *VAR_5='\\0';\n        VAR_15|=VAR_40;\n        break;\n      }\n      case VAR_43:\n      {\n        /* COMMENT_36 */\n                                      \n          \n        if (VAR_16.xconfigure.window != VAR_2->widget.id)\n          break;\n        if ((VAR_16.xconfigure.width == (int) VAR_2->widget.width) &&\n            (VAR_16.xconfigure.height == (int) VAR_2->widget.height))\n          break;\n        VAR_2->widget.width=(unsigned int)\n          MagickMax(VAR_16.xconfigure.width,(int) VAR_2->widget.min_width);\n        VAR_2->widget.height=(unsigned int)\n          MagickMax(VAR_16.xconfigure.height,(int) VAR_2->widget.min_height);\n        VAR_15|=VAR_35;\n        break;\n      }\n      case VAR_44:\n      {\n        if (VAR_16.xcrossing.window != VAR_2->widget.id)\n          break;\n        if (VAR_16.xcrossing.state == 0)\n          break;\n        VAR_15&=(~VAR_41);\n        if (VAR_21.height == 0)\n          break;\n        VAR_7=((VAR_16.xcrossing.y-VAR_13)/(int) VAR_21.height);\n        if ((VAR_21.id >= 0) &&\n            (VAR_21.id < (int) VAR_11))\n          {\n            /* COMMENT_39 */\n                                         \n              \n            if (VAR_7 == VAR_21.id)\n              break;\n            VAR_21.y=(int)\n              (VAR_13+VAR_21.id*VAR_21.height);\n            VAR_21.text=(char *) VAR_4[VAR_21.id];\n            XDrawWidgetText(VAR_1,&VAR_2->widget,&VAR_21);\n          }\n        if ((VAR_7 < 0) || (VAR_7 >= (int) VAR_11))\n          break;\n        /* COMMENT_42 */\n                                   \n          \n        VAR_21.id=VAR_7;\n        VAR_21.y=(int)\n          (VAR_13+VAR_21.id*VAR_21.height);\n        VAR_21.text=(char *) VAR_4[VAR_21.id];\n        XDrawWidgetText(VAR_1,&VAR_2->widget,&VAR_21);\n        VAR_19.y=VAR_21.y+VAR_19.bevel_width;\n        XDrawBevel(VAR_1,&VAR_2->widget,&VAR_19);\n        break;\n      }\n      case VAR_45:\n      {\n        if (VAR_16.xexpose.window != VAR_2->widget.id)\n          break;\n        if (VAR_16.xexpose.count != 0)\n          break;\n        VAR_15|=VAR_36;\n        break;\n      }\n      case VAR_46:\n      {\n        if (VAR_16.xcrossing.window != VAR_2->widget.id)\n          break;\n        VAR_15|=VAR_41;\n        VAR_7=VAR_21.id;\n        if ((VAR_7 < 0) || (VAR_7 >= (int) VAR_11))\n          break;\n        /* COMMENT_45 */\n                                     \n          \n        VAR_21.y=(int) (VAR_13+VAR_7*VAR_21.height);\n        VAR_21.id=(~0);\n        VAR_21.text=(char *) VAR_4[VAR_7];\n        XDrawWidgetText(VAR_1,&VAR_2->widget,&VAR_21);\n        break;\n      }\n      case VAR_47:\n      {\n        /* COMMENT_48 */\n                                               \n          \n        while (XCheckMaskEvent(VAR_1,VAR_48,&VAR_16)) ;\n        if (VAR_24.active != 0)\n          if (VAR_16.xmotion.window == VAR_2->command.id)\n            {\n              if ((VAR_15 & VAR_41) == 0)\n                {\n                  if (MatteIsActive(VAR_24,VAR_16.xmotion) == VAR_33)\n                    {\n                      VAR_21.id=(~0);\n                        *VAR_5='\\0';\n                      VAR_15|=VAR_40;\n                      break;\n                    }\n                }\n              else\n                if (WindowIsActive(VAR_2->command,VAR_16.xmotion))\n                  {\n                    VAR_21.id=(~0);\n                    *VAR_5='\\0';\n                    VAR_15|=VAR_40;\n                    break;\n                  }\n            }\n        if (VAR_16.xmotion.window != VAR_2->widget.id)\n          break;\n        if (VAR_15 & VAR_41)\n          break;\n        if (VAR_21.height == 0)\n          break;\n        VAR_7=(VAR_16.xmotion.y-VAR_13)/(int) VAR_21.height;\n        if ((VAR_21.id >= 0) &&\n            (VAR_21.id < (int) VAR_11))\n          {\n            /* COMMENT_51 */\n                                         \n              \n            if (VAR_7 == VAR_21.id)\n              break;\n            VAR_21.y=(int)\n              (VAR_13+VAR_21.id*VAR_21.height);\n            VAR_21.text=(char *) VAR_4[VAR_21.id];\n            XDrawWidgetText(VAR_1,&VAR_2->widget,&VAR_21);\n          }\n        VAR_21.id=VAR_7;\n        if ((VAR_7 < 0) || (VAR_7 >= (int) VAR_11))\n          break;\n        /* COMMENT_54 */\n                                   \n          \n        VAR_21.y=(int) (VAR_13+VAR_7*VAR_21.height);\n        VAR_21.text=(char *) VAR_4[VAR_7];\n        XDrawWidgetText(VAR_1,&VAR_2->widget,&VAR_21);\n        VAR_19.y=VAR_21.y+VAR_19.bevel_width;\n        XDrawBevel(VAR_1,&VAR_2->widget,&VAR_19);\n        break;\n      }\n      default:\n        break;\n    }\n  } while ((VAR_15 & VAR_40) == 0);\n  (void) XFreeCursor(VAR_1,VAR_6);\n  VAR_18.override_redirect=VAR_33;\n  (void) XChangeWindowAttributes(VAR_1,VAR_2->widget.id,\n    (size_t) VAR_28,&VAR_18);\n  (void) XWithdrawWindow(VAR_1,VAR_2->widget.id,VAR_2->widget.screen);\n  XCheckRefreshWindows(VAR_1,VAR_2);\n  if (VAR_24.active != 0)\n    {\n      VAR_24.active=VAR_33;\n      VAR_26.raised=VAR_33;\n      XDrawTriangleEast(VAR_1,&VAR_2->command,&VAR_26);\n    }\n  if ((VAR_21.id < 0) || (VAR_21.id >= (int) VAR_11))\n    return(~0);\n  (void) CopyMagickString(VAR_5,VAR_4[VAR_21.id],VAR_49);\n  return(VAR_21.id);\n}",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -208,6 +208,8 @@\n             break;\n           }\n         state&=(~InactiveWidgetState);\n+        if (selection_info.height == 0)\n+          break;\n         id=(event.xbutton.y-top_offset)/(int) selection_info.height;\n         selection_info.id=id;\n         if ((id < 0) || (id >= (int) number_selections))\n@@ -261,6 +263,8 @@\n         if (event.xcrossing.state == 0)\n           break;\n         state&=(~InactiveWidgetState);\n+        if (selection_info.height == 0)\n+          break;\n         id=((event.xcrossing.y-top_offset)/(int) selection_info.height);\n         if ((selection_info.id >= 0) &&\n             (selection_info.id < (int) number_selections))\n@@ -347,6 +351,8 @@\n           break;\n         if (state & InactiveWidgetState)\n           break;\n+        if (selection_info.height == 0)\n+          break;\n         id=(event.xmotion.y-top_offset)/(int) selection_info.height;\n         if ((selection_info.id >= 0) &&\n             (selection_info.id < (int) number_selections))",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "        if (selection_info.height == 0)",
      "          break;",
      "        if (selection_info.height == 0)",
      "          break;",
      "        if (selection_info.height == 0)",
      "          break;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/ImageMagick/ImageMagick/pull/4041",
  "description": {
    "pr_info": {
      "title": "fix Division by zero in XMenuWidget() of MagickCore/widget.c",
      "number": 4041
    },
    "comment": [
      "### Prerequisites\r\n\r\n- [ y] I have written a descriptive pull-request title\r\n- [ y] I have verified that there are no overlapping [pull-requests](https://github.com/ImageMagick/ImageMagick/pulls) open\r\n- [ y] I have verified that I am following the existing coding patterns and practices as demonstrated in the repository.\r\n\r\n### Description\r\n<!-- A description of the changes proposed in the pull-request\r\n     If you want to change something in the 'www' or 'ImageMagick' folder please\r\n     open an issue here instead: https://github.com/ImageMagick/Website -->\r\nFixes #4040Division by zero in XMenuWidget() of MagickCore/widget.c\r\n\r\nInitialize the newly allocated memory\r\n\r\n<!-- Thanks for contributing to ImageMagick! -->\r\n"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.9"
}