{
  "cve_id": "CVE-2015-1828",
  "cwe_ids": [
    "CWE-200"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:N/A:N",
  "cvss_is_v3": false,
  "repo_name": "ruby/openssl",
  "commit_msg": "pkey: add support for PKCS #8 key serialization\n\nOpenSSL::PKey::PKey#private_to_der, #private_to_pem are added to the\ngeneric PKey class. They serialize the private key to PKCS #8\n{Encrypted,}PrivateKeyInfo format, in DER- and PEM- encoding,\nrespectively. For symmetry, also add #public_to_der and #public_to_pem\nthat serialize the public key into X.509 SubjectPublicKeyInfo format.\n\nOpenSSL::PKey.read now reads DER-encoded PKCS #8 keys as well as the\n\"raw\" private keys. PEM-encoded PKCS #8 keys have been already handled\nby PEM_read_bio_PrivateKey().",
  "commit_hash": "90afa5f9b595876af3b6832120deb979b214c022",
  "git_url": "https://github.com/ruby/openssl/commit/90afa5f9b595876af3b6832120deb979b214c022",
  "file_path": "ext/openssl/ossl_pkey.c",
  "func_name": "Init_ossl_pkey",
  "func_before": "void\nInit_ossl_pkey(void)\n{\n#undef rb_intern\n#if 0\n    mOSSL = rb_define_module(\"OpenSSL\");\n    eOSSLError = rb_define_class_under(mOSSL, \"OpenSSLError\", rb_eStandardError);\n#endif\n\n    /* Document-module: OpenSSL::PKey\n     *\n     * == Asymmetric Public Key Algorithms\n     *\n     * Asymmetric public key algorithms solve the problem of establishing and\n     * sharing secret keys to en-/decrypt messages. The key in such an\n     * algorithm consists of two parts: a public key that may be distributed\n     * to others and a private key that needs to remain secret.\n     *\n     * Messages encrypted with a public key can only be decrypted by\n     * recipients that are in possession of the associated private key.\n     * Since public key algorithms are considerably slower than symmetric\n     * key algorithms (cf. OpenSSL::Cipher) they are often used to establish\n     * a symmetric key shared between two parties that are in possession of\n     * each other's public key.\n     *\n     * Asymmetric algorithms offer a lot of nice features that are used in a\n     * lot of different areas. A very common application is the creation and\n     * validation of digital signatures. To sign a document, the signatory\n     * generally uses a message digest algorithm (cf. OpenSSL::Digest) to\n     * compute a digest of the document that is then encrypted (i.e. signed)\n     * using the private key. Anyone in possession of the public key may then\n     * verify the signature by computing the message digest of the original\n     * document on their own, decrypting the signature using the signatory's\n     * public key and comparing the result to the message digest they\n     * previously computed. The signature is valid if and only if the\n     * decrypted signature is equal to this message digest.\n     *\n     * The PKey module offers support for three popular public/private key\n     * algorithms:\n     * * RSA (OpenSSL::PKey::RSA)\n     * * DSA (OpenSSL::PKey::DSA)\n     * * Elliptic Curve Cryptography (OpenSSL::PKey::EC)\n     * Each of these implementations is in fact a sub-class of the abstract\n     * PKey class which offers the interface for supporting digital signatures\n     * in the form of PKey#sign and PKey#verify.\n     *\n     * == Diffie-Hellman Key Exchange\n     *\n     * Finally PKey also features OpenSSL::PKey::DH, an implementation of\n     * the Diffie-Hellman key exchange protocol based on discrete logarithms\n     * in finite fields, the same basis that DSA is built on.\n     * The Diffie-Hellman protocol can be used to exchange (symmetric) keys\n     * over insecure channels without needing any prior joint knowledge\n     * between the participating parties. As the security of DH demands\n     * relatively long \"public keys\" (i.e. the part that is overtly\n     * transmitted between participants) DH tends to be quite slow. If\n     * security or speed is your primary concern, OpenSSL::PKey::EC offers\n     * another implementation of the Diffie-Hellman protocol.\n     *\n     */\n    mPKey = rb_define_module_under(mOSSL, \"PKey\");\n\n    /* Document-class: OpenSSL::PKey::PKeyError\n     *\n     *Raised when errors occur during PKey#sign or PKey#verify.\n     */\n    ePKeyError = rb_define_class_under(mPKey, \"PKeyError\", eOSSLError);\n\n    /* Document-class: OpenSSL::PKey::PKey\n     *\n     * An abstract class that bundles signature creation (PKey#sign) and\n     * validation (PKey#verify) that is common to all implementations except\n     * OpenSSL::PKey::DH\n     * * OpenSSL::PKey::RSA\n     * * OpenSSL::PKey::DSA\n     * * OpenSSL::PKey::EC\n     */\n    cPKey = rb_define_class_under(mPKey, \"PKey\", rb_cObject);\n\n    rb_define_module_function(mPKey, \"read\", ossl_pkey_new_from_data, -1);\n\n    rb_define_alloc_func(cPKey, ossl_pkey_alloc);\n    rb_define_method(cPKey, \"initialize\", ossl_pkey_initialize, 0);\n\n    rb_define_method(cPKey, \"sign\", ossl_pkey_sign, 2);\n    rb_define_method(cPKey, \"verify\", ossl_pkey_verify, 3);\n\n    id_private_q = rb_intern(\"private?\");\n\n    /*\n     * INIT rsa, dsa, dh, ec\n     */\n    Init_ossl_rsa();\n    Init_ossl_dsa();\n    Init_ossl_dh();\n    Init_ossl_ec();\n}",
  "abstract_func_before": "void\nInit_ossl_pkey(void)\n{\n#undef rb_intern\n#if 0\n    VAR_0 = rb_define_module(\"OpenSSL\");\n    VAR_1 = rb_define_class_under(VAR_0, \"OpenSSLError\", VAR_2);\n#endif\n\n    /* COMMENT_0 */\n      \n                                          \n      \n                                                                             \n                                                                      \n                                                                            \n                                                               \n      \n                                                                    \n                                                                       \n                                                                         \n                                                                            \n                                                                           \n                               \n      \n                                                                            \n                                                                            \n                                                                          \n                                                                         \n                                                                            \n                                                                             \n                                                                           \n                                                                            \n                                                                     \n                                                                     \n                                                           \n      \n                                                                          \n                  \n                                 \n                                 \n                                                        \n                                                                           \n                                                                              \n                                                \n      \n                                     \n      \n                                                                         \n                                                                            \n                                                             \n                                                                           \n                                                                       \n                                                                       \n                                                                   \n                                                                      \n                                                                          \n                                                             \n      \n       \n    VAR_3 = rb_define_module_under(VAR_0, \"PKey\");\n\n    /* COMMENT_44 */\n      \n                                                               \n       \n    VAR_4 = rb_define_class_under(VAR_3, \"PKeyError\", VAR_1);\n\n    /* COMMENT_48 */\n      \n                                                                        \n                                                                            \n                        \n                           \n                           \n                          \n       \n    VAR_5 = rb_define_class_under(VAR_3, \"PKey\", VAR_6);\n\n    rb_define_module_function(VAR_3, \"read\", VAR_7, -1);\n\n    rb_define_alloc_func(VAR_5, VAR_8);\n    rb_define_method(VAR_5, \"initialize\", VAR_9, 0);\n\n    rb_define_method(VAR_5, \"sign\", VAR_10, 2);\n    rb_define_method(VAR_5, \"verify\", VAR_11, 3);\n\n    VAR_12 = rb_intern(\"private?\");\n\n    /* COMMENT_57 */\n                            \n       \n    Init_ossl_rsa();\n    Init_ossl_dsa();\n    Init_ossl_dh();\n    Init_ossl_ec();\n}",
  "func_graph_path_before": "ruby/openssl/90afa5f9b595876af3b6832120deb979b214c022/ossl_pkey.c/vul/before/1.json",
  "func": "void\nInit_ossl_pkey(void)\n{\n#undef rb_intern\n#if 0\n    mOSSL = rb_define_module(\"OpenSSL\");\n    eOSSLError = rb_define_class_under(mOSSL, \"OpenSSLError\", rb_eStandardError);\n#endif\n\n    /* Document-module: OpenSSL::PKey\n     *\n     * == Asymmetric Public Key Algorithms\n     *\n     * Asymmetric public key algorithms solve the problem of establishing and\n     * sharing secret keys to en-/decrypt messages. The key in such an\n     * algorithm consists of two parts: a public key that may be distributed\n     * to others and a private key that needs to remain secret.\n     *\n     * Messages encrypted with a public key can only be decrypted by\n     * recipients that are in possession of the associated private key.\n     * Since public key algorithms are considerably slower than symmetric\n     * key algorithms (cf. OpenSSL::Cipher) they are often used to establish\n     * a symmetric key shared between two parties that are in possession of\n     * each other's public key.\n     *\n     * Asymmetric algorithms offer a lot of nice features that are used in a\n     * lot of different areas. A very common application is the creation and\n     * validation of digital signatures. To sign a document, the signatory\n     * generally uses a message digest algorithm (cf. OpenSSL::Digest) to\n     * compute a digest of the document that is then encrypted (i.e. signed)\n     * using the private key. Anyone in possession of the public key may then\n     * verify the signature by computing the message digest of the original\n     * document on their own, decrypting the signature using the signatory's\n     * public key and comparing the result to the message digest they\n     * previously computed. The signature is valid if and only if the\n     * decrypted signature is equal to this message digest.\n     *\n     * The PKey module offers support for three popular public/private key\n     * algorithms:\n     * * RSA (OpenSSL::PKey::RSA)\n     * * DSA (OpenSSL::PKey::DSA)\n     * * Elliptic Curve Cryptography (OpenSSL::PKey::EC)\n     * Each of these implementations is in fact a sub-class of the abstract\n     * PKey class which offers the interface for supporting digital signatures\n     * in the form of PKey#sign and PKey#verify.\n     *\n     * == Diffie-Hellman Key Exchange\n     *\n     * Finally PKey also features OpenSSL::PKey::DH, an implementation of\n     * the Diffie-Hellman key exchange protocol based on discrete logarithms\n     * in finite fields, the same basis that DSA is built on.\n     * The Diffie-Hellman protocol can be used to exchange (symmetric) keys\n     * over insecure channels without needing any prior joint knowledge\n     * between the participating parties. As the security of DH demands\n     * relatively long \"public keys\" (i.e. the part that is overtly\n     * transmitted between participants) DH tends to be quite slow. If\n     * security or speed is your primary concern, OpenSSL::PKey::EC offers\n     * another implementation of the Diffie-Hellman protocol.\n     *\n     */\n    mPKey = rb_define_module_under(mOSSL, \"PKey\");\n\n    /* Document-class: OpenSSL::PKey::PKeyError\n     *\n     *Raised when errors occur during PKey#sign or PKey#verify.\n     */\n    ePKeyError = rb_define_class_under(mPKey, \"PKeyError\", eOSSLError);\n\n    /* Document-class: OpenSSL::PKey::PKey\n     *\n     * An abstract class that bundles signature creation (PKey#sign) and\n     * validation (PKey#verify) that is common to all implementations except\n     * OpenSSL::PKey::DH\n     * * OpenSSL::PKey::RSA\n     * * OpenSSL::PKey::DSA\n     * * OpenSSL::PKey::EC\n     */\n    cPKey = rb_define_class_under(mPKey, \"PKey\", rb_cObject);\n\n    rb_define_module_function(mPKey, \"read\", ossl_pkey_new_from_data, -1);\n\n    rb_define_alloc_func(cPKey, ossl_pkey_alloc);\n    rb_define_method(cPKey, \"initialize\", ossl_pkey_initialize, 0);\n    rb_define_method(cPKey, \"private_to_der\", ossl_pkey_private_to_der, -1);\n    rb_define_method(cPKey, \"private_to_pem\", ossl_pkey_private_to_pem, -1);\n    rb_define_method(cPKey, \"public_to_der\", ossl_pkey_public_to_der, 0);\n    rb_define_method(cPKey, \"public_to_pem\", ossl_pkey_public_to_pem, 0);\n\n    rb_define_method(cPKey, \"sign\", ossl_pkey_sign, 2);\n    rb_define_method(cPKey, \"verify\", ossl_pkey_verify, 3);\n\n    id_private_q = rb_intern(\"private?\");\n\n    /*\n     * INIT rsa, dsa, dh, ec\n     */\n    Init_ossl_rsa();\n    Init_ossl_dsa();\n    Init_ossl_dh();\n    Init_ossl_ec();\n}",
  "abstract_func": "void\nInit_ossl_pkey(void)\n{\n#undef rb_intern\n#if 0\n    VAR_0 = rb_define_module(\"OpenSSL\");\n    VAR_1 = rb_define_class_under(VAR_0, \"OpenSSLError\", VAR_2);\n#endif\n\n    /* COMMENT_0 */\n      \n                                          \n      \n                                                                             \n                                                                      \n                                                                            \n                                                               \n      \n                                                                    \n                                                                       \n                                                                         \n                                                                            \n                                                                           \n                               \n      \n                                                                            \n                                                                            \n                                                                          \n                                                                         \n                                                                            \n                                                                             \n                                                                           \n                                                                            \n                                                                     \n                                                                     \n                                                           \n      \n                                                                          \n                  \n                                 \n                                 \n                                                        \n                                                                           \n                                                                              \n                                                \n      \n                                     \n      \n                                                                         \n                                                                            \n                                                             \n                                                                           \n                                                                       \n                                                                       \n                                                                   \n                                                                      \n                                                                          \n                                                             \n      \n       \n    VAR_3 = rb_define_module_under(VAR_0, \"PKey\");\n\n    /* COMMENT_44 */\n      \n                                                               \n       \n    VAR_4 = rb_define_class_under(VAR_3, \"PKeyError\", VAR_1);\n\n    /* COMMENT_48 */\n      \n                                                                        \n                                                                            \n                        \n                           \n                           \n                          \n       \n    VAR_5 = rb_define_class_under(VAR_3, \"PKey\", VAR_6);\n\n    rb_define_module_function(VAR_3, \"read\", VAR_7, -1);\n\n    rb_define_alloc_func(VAR_5, VAR_8);\n    rb_define_method(VAR_5, \"initialize\", VAR_9, 0);\n    rb_define_method(VAR_5, \"private_to_der\", VAR_10, -1);\n    rb_define_method(VAR_5, \"private_to_pem\", VAR_11, -1);\n    rb_define_method(VAR_5, \"public_to_der\", VAR_12, 0);\n    rb_define_method(VAR_5, \"public_to_pem\", VAR_13, 0);\n\n    rb_define_method(VAR_5, \"sign\", VAR_14, 2);\n    rb_define_method(VAR_5, \"verify\", VAR_15, 3);\n\n    VAR_16 = rb_intern(\"private?\");\n\n    /* COMMENT_57 */\n                            \n       \n    Init_ossl_rsa();\n    Init_ossl_dsa();\n    Init_ossl_dh();\n    Init_ossl_ec();\n}",
  "func_graph_path": "ruby/openssl/90afa5f9b595876af3b6832120deb979b214c022/ossl_pkey.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -81,6 +81,10 @@\n \n     rb_define_alloc_func(cPKey, ossl_pkey_alloc);\n     rb_define_method(cPKey, \"initialize\", ossl_pkey_initialize, 0);\n+    rb_define_method(cPKey, \"private_to_der\", ossl_pkey_private_to_der, -1);\n+    rb_define_method(cPKey, \"private_to_pem\", ossl_pkey_private_to_pem, -1);\n+    rb_define_method(cPKey, \"public_to_der\", ossl_pkey_public_to_der, 0);\n+    rb_define_method(cPKey, \"public_to_pem\", ossl_pkey_public_to_pem, 0);\n \n     rb_define_method(cPKey, \"sign\", ossl_pkey_sign, 2);\n     rb_define_method(cPKey, \"verify\", ossl_pkey_verify, 3);",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "    rb_define_method(cPKey, \"private_to_der\", ossl_pkey_private_to_der, -1);",
      "    rb_define_method(cPKey, \"private_to_pem\", ossl_pkey_private_to_pem, -1);",
      "    rb_define_method(cPKey, \"public_to_der\", ossl_pkey_public_to_der, 0);",
      "    rb_define_method(cPKey, \"public_to_pem\", ossl_pkey_public_to_pem, 0);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/ruby/openssl/pull/297",
  "description": {
    "pr_info": {
      "title": "Export keys in PKCS8 format",
      "number": 297
    },
    "comment": [
      "Closes https://github.com/ruby/openssl/issues/294 by cherry-picking from https://github.com/ruby/openssl/pull/119 \r\n\r\nThe only line that needed changing to make it work on latest master was https://github.com/ruby/openssl/pull/119/files#diff-bae6e18b74ab1f890ac3e06a1aae16a2R614 to use `ossl_evp_get_cipherbyname ` as this was renamed in https://github.com/ruby/openssl/commit/679b6f490671439d1bc50ef4371d9fb3bbba0e29",
      "Great."
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "The commit introduces new methods for key serialization and improves key reading, indicating a feature upgrade rather than a security fix.\n\n**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.9  \n\n**Step-by-Step Explanation:**\n\n1. **Input Analysis:** The commit adds serialization methods and improves key reading, focusing on feature enhancement.\n2. **Consistency Check:** The message aligns with code changes, no mismatches found.\n3. **Purpose Evaluation:** Changes enhance core functionality, not fix bugs or address security.\n4. **Security Assessment:** No security issues addressed; focused on feature addition.\n5. **Classification:** Fits into feature upgrades as it enhances core business logic.\n6. **Confidence:** Clear focus on feature enhancement with high consistency.\n\n**Final Answer:**\n**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.9"
}