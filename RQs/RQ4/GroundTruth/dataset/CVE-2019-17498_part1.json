{
  "cve_id": "CVE-2019-17498",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "libssh2",
  "commit_msg": "packet.c: improve message parsing (#402)\n\n* packet.c: improve parsing of packets\r\n\r\nfile: packet.c\r\n\r\nnotes:\r\nUse _libssh2_get_string API in SSH_MSG_DEBUG/SSH_MSG_DISCONNECT. Additional uint32 bounds check in SSH_MSG_GLOBAL_REQUEST.",
  "commit_hash": "dedcbd106f8e52d5586b0205bc7677e4c9868f9c",
  "git_url": "https://github.com/libssh2/libssh2/commit/dedcbd106f8e52d5586b0205bc7677e4c9868f9c",
  "file_path": "src/packet.c",
  "func_name": "_libssh2_packet_add",
  "func_before": "int\n_libssh2_packet_add(LIBSSH2_SESSION * session, unsigned char *data,\n                    size_t datalen, int macstate)\n{\n    int rc = 0;\n    char *message = NULL;\n    char *language = NULL;\n    size_t message_len = 0;\n    size_t language_len = 0;\n    LIBSSH2_CHANNEL *channelp = NULL;\n    size_t data_head = 0;\n    unsigned char msg = data[0];\n\n    switch(session->packAdd_state) {\n    case libssh2_NB_state_idle:\n        _libssh2_debug(session, LIBSSH2_TRACE_TRANS,\n                       \"Packet type %d received, length=%d\",\n                       (int) msg, (int) datalen);\n\n        if((macstate == LIBSSH2_MAC_INVALID) &&\n            (!session->macerror ||\n             LIBSSH2_MACERROR(session, (char *) data, datalen))) {\n            /* Bad MAC input, but no callback set or non-zero return from the\n               callback */\n\n            LIBSSH2_FREE(session, data);\n            return _libssh2_error(session, LIBSSH2_ERROR_INVALID_MAC,\n                                  \"Invalid MAC received\");\n        }\n        session->packAdd_state = libssh2_NB_state_allocated;\n        break;\n    case libssh2_NB_state_jump1:\n        goto libssh2_packet_add_jump_point1;\n    case libssh2_NB_state_jump2:\n        goto libssh2_packet_add_jump_point2;\n    case libssh2_NB_state_jump3:\n        goto libssh2_packet_add_jump_point3;\n    case libssh2_NB_state_jump4:\n        goto libssh2_packet_add_jump_point4;\n    case libssh2_NB_state_jump5:\n        goto libssh2_packet_add_jump_point5;\n    default: /* nothing to do */\n        break;\n    }\n\n    if(session->packAdd_state == libssh2_NB_state_allocated) {\n        /* A couple exceptions to the packet adding rule: */\n        switch(msg) {\n\n            /*\n              byte      SSH_MSG_DISCONNECT\n              uint32    reason code\n              string    description in ISO-10646 UTF-8 encoding [RFC3629]\n              string    language tag [RFC3066]\n            */\n\n        case SSH_MSG_DISCONNECT:\n            if(datalen >= 5) {\n                size_t reason = _libssh2_ntohu32(data + 1);\n\n                if(datalen >= 9) {\n                    message_len = _libssh2_ntohu32(data + 5);\n\n                    if(message_len < datalen-13) {\n                        /* 9 = packet_type(1) + reason(4) + message_len(4) */\n                        message = (char *) data + 9;\n\n                        language_len =\n                            _libssh2_ntohu32(data + 9 + message_len);\n                        language = (char *) data + 9 + message_len + 4;\n\n                        if(language_len > (datalen-13-message_len)) {\n                            /* bad input, clear info */\n                            language = message = NULL;\n                            language_len = message_len = 0;\n                        }\n                    }\n                    else\n                        /* bad size, clear it */\n                        message_len = 0;\n                }\n                if(session->ssh_msg_disconnect) {\n                    LIBSSH2_DISCONNECT(session, reason, message,\n                                       message_len, language, language_len);\n                }\n                _libssh2_debug(session, LIBSSH2_TRACE_TRANS,\n                               \"Disconnect(%d): %s(%s)\", reason,\n                               message, language);\n            }\n\n            LIBSSH2_FREE(session, data);\n            session->socket_state = LIBSSH2_SOCKET_DISCONNECTED;\n            session->packAdd_state = libssh2_NB_state_idle;\n            return _libssh2_error(session, LIBSSH2_ERROR_SOCKET_DISCONNECT,\n                                  \"socket disconnect\");\n            /*\n              byte      SSH_MSG_IGNORE\n              string    data\n            */\n\n        case SSH_MSG_IGNORE:\n            if(datalen >= 2) {\n                if(session->ssh_msg_ignore) {\n                    LIBSSH2_IGNORE(session, (char *) data + 1, datalen - 1);\n                }\n            }\n            else if(session->ssh_msg_ignore) {\n                LIBSSH2_IGNORE(session, \"\", 0);\n            }\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return 0;\n\n            /*\n              byte      SSH_MSG_DEBUG\n              boolean   always_display\n              string    message in ISO-10646 UTF-8 encoding [RFC3629]\n              string    language tag [RFC3066]\n            */\n\n        case SSH_MSG_DEBUG:\n            if(datalen >= 2) {\n                int always_display = data[1];\n\n                if(datalen >= 6) {\n                    message_len = _libssh2_ntohu32(data + 2);\n\n                    if(message_len <= (datalen - 10)) {\n                        /* 6 = packet_type(1) + display(1) + message_len(4) */\n                        message = (char *) data + 6;\n                        language_len = _libssh2_ntohu32(data + 6 +\n                                                        message_len);\n\n                        if(language_len <= (datalen - 10 - message_len))\n                            language = (char *) data + 10 + message_len;\n                    }\n                }\n\n                if(session->ssh_msg_debug) {\n                    LIBSSH2_DEBUG(session, always_display, message,\n                                  message_len, language, language_len);\n                }\n            }\n            /*\n             * _libssh2_debug will actually truncate this for us so\n             * that it's not an inordinate about of data\n             */\n            _libssh2_debug(session, LIBSSH2_TRACE_TRANS,\n                           \"Debug Packet: %s\", message);\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return 0;\n\n            /*\n              byte      SSH_MSG_GLOBAL_REQUEST\n              string    request name in US-ASCII only\n              boolean   want reply\n              ....      request-specific data follows\n            */\n\n        case SSH_MSG_GLOBAL_REQUEST:\n            if(datalen >= 5) {\n                uint32_t len = 0;\n                unsigned char want_reply = 0;\n                len = _libssh2_ntohu32(data + 1);\n                if(datalen >= (6 + len)) {\n                    want_reply = data[5 + len];\n                    _libssh2_debug(session,\n                                   LIBSSH2_TRACE_CONN,\n                                   \"Received global request type %.*s (wr %X)\",\n                                   len, data + 5, want_reply);\n                }\n\n\n                if(want_reply) {\n                    static const unsigned char packet =\n                        SSH_MSG_REQUEST_FAILURE;\n                  libssh2_packet_add_jump_point5:\n                    session->packAdd_state = libssh2_NB_state_jump5;\n                    rc = _libssh2_transport_send(session, &packet, 1, NULL, 0);\n                    if(rc == LIBSSH2_ERROR_EAGAIN)\n                        return rc;\n                }\n            }\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return 0;\n\n            /*\n              byte      SSH_MSG_CHANNEL_EXTENDED_DATA\n              uint32    recipient channel\n              uint32    data_type_code\n              string    data\n            */\n\n        case SSH_MSG_CHANNEL_EXTENDED_DATA:\n            /* streamid(4) */\n            data_head += 4;\n\n            /* fall-through */\n\n            /*\n              byte      SSH_MSG_CHANNEL_DATA\n              uint32    recipient channel\n              string    data\n            */\n\n        case SSH_MSG_CHANNEL_DATA:\n            /* packet_type(1) + channelno(4) + datalen(4) */\n            data_head += 9;\n\n            if(datalen >= data_head)\n                channelp =\n                    _libssh2_channel_locate(session,\n                                            _libssh2_ntohu32(data + 1));\n\n            if(!channelp) {\n                _libssh2_error(session, LIBSSH2_ERROR_CHANNEL_UNKNOWN,\n                               \"Packet received for unknown channel\");\n                LIBSSH2_FREE(session, data);\n                session->packAdd_state = libssh2_NB_state_idle;\n                return 0;\n            }\n#ifdef LIBSSH2DEBUG\n            {\n                uint32_t stream_id = 0;\n                if(msg == SSH_MSG_CHANNEL_EXTENDED_DATA)\n                    stream_id = _libssh2_ntohu32(data + 5);\n\n                _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                               \"%d bytes packet_add() for %lu/%lu/%lu\",\n                               (int) (datalen - data_head),\n                               channelp->local.id,\n                               channelp->remote.id,\n                               stream_id);\n            }\n#endif\n            if((channelp->remote.extended_data_ignore_mode ==\n                 LIBSSH2_CHANNEL_EXTENDED_DATA_IGNORE) &&\n                (msg == SSH_MSG_CHANNEL_EXTENDED_DATA)) {\n                /* Pretend we didn't receive this */\n                LIBSSH2_FREE(session, data);\n\n                _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                               \"Ignoring extended data and refunding %d bytes\",\n                               (int) (datalen - 13));\n                if(channelp->read_avail + datalen - data_head >=\n                    channelp->remote.window_size)\n                    datalen = channelp->remote.window_size -\n                        channelp->read_avail + data_head;\n\n                channelp->remote.window_size -= datalen - data_head;\n                _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                               \"shrinking window size by %lu bytes to %lu, \"\n                               \"read_avail %lu\",\n                               datalen - data_head,\n                               channelp->remote.window_size,\n                               channelp->read_avail);\n\n                session->packAdd_channelp = channelp;\n\n                /* Adjust the window based on the block we just freed */\n              libssh2_packet_add_jump_point1:\n                session->packAdd_state = libssh2_NB_state_jump1;\n                rc = _libssh2_channel_receive_window_adjust(session->\n                                                            packAdd_channelp,\n                                                            datalen - 13,\n                                                            1, NULL);\n                if(rc == LIBSSH2_ERROR_EAGAIN)\n                    return rc;\n\n                session->packAdd_state = libssh2_NB_state_idle;\n                return 0;\n            }\n\n            /*\n             * REMEMBER! remote means remote as source of data,\n             * NOT remote window!\n             */\n            if(channelp->remote.packet_size < (datalen - data_head)) {\n                /*\n                 * Spec says we MAY ignore bytes sent beyond\n                 * packet_size\n                 */\n                _libssh2_error(session,\n                               LIBSSH2_ERROR_CHANNEL_PACKET_EXCEEDED,\n                               \"Packet contains more data than we offered\"\n                               \" to receive, truncating\");\n                datalen = channelp->remote.packet_size + data_head;\n            }\n            if(channelp->remote.window_size <= channelp->read_avail) {\n                /*\n                 * Spec says we MAY ignore bytes sent beyond\n                 * window_size\n                 */\n                _libssh2_error(session,\n                               LIBSSH2_ERROR_CHANNEL_WINDOW_EXCEEDED,\n                               \"The current receive window is full,\"\n                               \" data ignored\");\n                LIBSSH2_FREE(session, data);\n                session->packAdd_state = libssh2_NB_state_idle;\n                return 0;\n            }\n            /* Reset EOF status */\n            channelp->remote.eof = 0;\n\n            if(channelp->read_avail + datalen - data_head >\n                channelp->remote.window_size) {\n                _libssh2_error(session,\n                               LIBSSH2_ERROR_CHANNEL_WINDOW_EXCEEDED,\n                               \"Remote sent more data than current \"\n                               \"window allows, truncating\");\n                datalen = channelp->remote.window_size -\n                    channelp->read_avail + data_head;\n            }\n\n            /* Update the read_avail counter. The window size will be\n             * updated once the data is actually read from the queue\n             * from an upper layer */\n            channelp->read_avail += datalen - data_head;\n\n            _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                           \"increasing read_avail by %lu bytes to %lu/%lu\",\n                           (long)(datalen - data_head),\n                           (long)channelp->read_avail,\n                           (long)channelp->remote.window_size);\n\n            break;\n\n            /*\n              byte      SSH_MSG_CHANNEL_EOF\n              uint32    recipient channel\n            */\n\n        case SSH_MSG_CHANNEL_EOF:\n            if(datalen >= 5)\n                channelp =\n                    _libssh2_channel_locate(session,\n                                            _libssh2_ntohu32(data + 1));\n            if(!channelp)\n                /* We may have freed already, just quietly ignore this... */\n                ;\n            else {\n                _libssh2_debug(session,\n                               LIBSSH2_TRACE_CONN,\n                               \"EOF received for channel %lu/%lu\",\n                               channelp->local.id,\n                               channelp->remote.id);\n                channelp->remote.eof = 1;\n            }\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return 0;\n\n            /*\n              byte      SSH_MSG_CHANNEL_REQUEST\n              uint32    recipient channel\n              string    request type in US-ASCII characters only\n              boolean   want reply\n              ....      type-specific data follows\n            */\n\n        case SSH_MSG_CHANNEL_REQUEST:\n            if(datalen >= 9) {\n                uint32_t channel = _libssh2_ntohu32(data + 1);\n                uint32_t len = _libssh2_ntohu32(data + 5);\n                unsigned char want_reply = 1;\n\n                if((len + 9) < datalen)\n                    want_reply = data[len + 9];\n\n                _libssh2_debug(session,\n                               LIBSSH2_TRACE_CONN,\n                               \"Channel %d received request type %.*s (wr %X)\",\n                               channel, len, data + 9, want_reply);\n\n                if(len == sizeof(\"exit-status\") - 1\n                    && (sizeof(\"exit-status\") - 1 + 9) <= datalen\n                    && !memcmp(\"exit-status\", data + 9,\n                               sizeof(\"exit-status\") - 1)) {\n\n                    /* we've got \"exit-status\" packet. Set the session value */\n                    if(datalen >= 20)\n                        channelp =\n                            _libssh2_channel_locate(session, channel);\n\n                    if(channelp && (sizeof(\"exit-status\") + 13) <= datalen) {\n                        channelp->exit_status =\n                            _libssh2_ntohu32(data + 9 + sizeof(\"exit-status\"));\n                        _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                                       \"Exit status %lu received for \"\n                                       \"channel %lu/%lu\",\n                                       channelp->exit_status,\n                                       channelp->local.id,\n                                       channelp->remote.id);\n                    }\n\n                }\n                else if(len == sizeof(\"exit-signal\") - 1\n                         && (sizeof(\"exit-signal\") - 1 + 9) <= datalen\n                         && !memcmp(\"exit-signal\", data + 9,\n                                    sizeof(\"exit-signal\") - 1)) {\n                    /* command terminated due to signal */\n                    if(datalen >= 20)\n                        channelp = _libssh2_channel_locate(session, channel);\n\n                    if(channelp && (sizeof(\"exit-signal\") + 13) <= datalen) {\n                        /* set signal name (without SIG prefix) */\n                        uint32_t namelen =\n                            _libssh2_ntohu32(data + 9 + sizeof(\"exit-signal\"));\n\n                        if(namelen <= UINT_MAX - 1) {\n                            channelp->exit_signal =\n                                LIBSSH2_ALLOC(session, namelen + 1);\n                        }\n                        else {\n                            channelp->exit_signal = NULL;\n                        }\n\n                        if(!channelp->exit_signal)\n                            rc = _libssh2_error(session, LIBSSH2_ERROR_ALLOC,\n                                                \"memory for signal name\");\n                        else if((sizeof(\"exit-signal\") + 13 + namelen <=\n                                 datalen)) {\n                            memcpy(channelp->exit_signal,\n                                   data + 13 + sizeof(\"exit-signal\"), namelen);\n                            channelp->exit_signal[namelen] = '\\0';\n                            /* TODO: save error message and language tag */\n                            _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                                           \"Exit signal %s received for \"\n                                           \"channel %lu/%lu\",\n                                           channelp->exit_signal,\n                                           channelp->local.id,\n                                           channelp->remote.id);\n                        }\n                    }\n                }\n\n\n                if(want_reply) {\n                    unsigned char packet[5];\n                  libssh2_packet_add_jump_point4:\n                    session->packAdd_state = libssh2_NB_state_jump4;\n                    packet[0] = SSH_MSG_CHANNEL_FAILURE;\n                    memcpy(&packet[1], data + 1, 4);\n                    rc = _libssh2_transport_send(session, packet, 5, NULL, 0);\n                    if(rc == LIBSSH2_ERROR_EAGAIN)\n                        return rc;\n                }\n            }\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return rc;\n\n            /*\n              byte      SSH_MSG_CHANNEL_CLOSE\n              uint32    recipient channel\n            */\n\n        case SSH_MSG_CHANNEL_CLOSE:\n            if(datalen >= 5)\n                channelp =\n                    _libssh2_channel_locate(session,\n                                            _libssh2_ntohu32(data + 1));\n            if(!channelp) {\n                /* We may have freed already, just quietly ignore this... */\n                LIBSSH2_FREE(session, data);\n                session->packAdd_state = libssh2_NB_state_idle;\n                return 0;\n            }\n            _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                           \"Close received for channel %lu/%lu\",\n                           channelp->local.id,\n                           channelp->remote.id);\n\n            channelp->remote.close = 1;\n            channelp->remote.eof = 1;\n\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return 0;\n\n            /*\n              byte      SSH_MSG_CHANNEL_OPEN\n              string    \"session\"\n              uint32    sender channel\n              uint32    initial window size\n              uint32    maximum packet size\n            */\n\n        case SSH_MSG_CHANNEL_OPEN:\n            if(datalen < 17)\n                ;\n            else if((datalen >= (sizeof(\"forwarded-tcpip\") + 4)) &&\n                     ((sizeof(\"forwarded-tcpip\") - 1) ==\n                      _libssh2_ntohu32(data + 1))\n                     &&\n                     (memcmp(data + 5, \"forwarded-tcpip\",\n                             sizeof(\"forwarded-tcpip\") - 1) == 0)) {\n\n                /* init the state struct */\n                memset(&session->packAdd_Qlstn_state, 0,\n                       sizeof(session->packAdd_Qlstn_state));\n\n              libssh2_packet_add_jump_point2:\n                session->packAdd_state = libssh2_NB_state_jump2;\n                rc = packet_queue_listener(session, data, datalen,\n                                           &session->packAdd_Qlstn_state);\n            }\n            else if((datalen >= (sizeof(\"x11\") + 4)) &&\n                     ((sizeof(\"x11\") - 1) == _libssh2_ntohu32(data + 1)) &&\n                     (memcmp(data + 5, \"x11\", sizeof(\"x11\") - 1) == 0)) {\n\n                /* init the state struct */\n                memset(&session->packAdd_x11open_state, 0,\n                       sizeof(session->packAdd_x11open_state));\n\n              libssh2_packet_add_jump_point3:\n                session->packAdd_state = libssh2_NB_state_jump3;\n                rc = packet_x11_open(session, data, datalen,\n                                     &session->packAdd_x11open_state);\n            }\n            if(rc == LIBSSH2_ERROR_EAGAIN)\n                return rc;\n\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return rc;\n\n            /*\n              byte      SSH_MSG_CHANNEL_WINDOW_ADJUST\n              uint32    recipient channel\n              uint32    bytes to add\n            */\n        case SSH_MSG_CHANNEL_WINDOW_ADJUST:\n            if(datalen < 9)\n                ;\n            else {\n                uint32_t bytestoadd = _libssh2_ntohu32(data + 5);\n                channelp =\n                    _libssh2_channel_locate(session,\n                                            _libssh2_ntohu32(data + 1));\n                if(channelp) {\n                    channelp->local.window_size += bytestoadd;\n\n                    _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                                   \"Window adjust for channel %lu/%lu, \"\n                                   \"adding %lu bytes, new window_size=%lu\",\n                                   channelp->local.id,\n                                   channelp->remote.id,\n                                   bytestoadd,\n                                   channelp->local.window_size);\n                }\n            }\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return 0;\n        default:\n            break;\n        }\n\n        session->packAdd_state = libssh2_NB_state_sent;\n    }\n\n    if(session->packAdd_state == libssh2_NB_state_sent) {\n        LIBSSH2_PACKET *packetp =\n            LIBSSH2_ALLOC(session, sizeof(LIBSSH2_PACKET));\n        if(!packetp) {\n            _libssh2_debug(session, LIBSSH2_ERROR_ALLOC,\n                           \"memory for packet\");\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return LIBSSH2_ERROR_ALLOC;\n        }\n        packetp->data = data;\n        packetp->data_len = datalen;\n        packetp->data_head = data_head;\n\n        _libssh2_list_add(&session->packets, &packetp->node);\n\n        session->packAdd_state = libssh2_NB_state_sent1;\n    }\n\n    if((msg == SSH_MSG_KEXINIT &&\n         !(session->state & LIBSSH2_STATE_EXCHANGING_KEYS)) ||\n        (session->packAdd_state == libssh2_NB_state_sent2)) {\n        if(session->packAdd_state == libssh2_NB_state_sent1) {\n            /*\n             * Remote wants new keys\n             * Well, it's already in the brigade,\n             * let's just call back into ourselves\n             */\n            _libssh2_debug(session, LIBSSH2_TRACE_TRANS, \"Renegotiating Keys\");\n\n            session->packAdd_state = libssh2_NB_state_sent2;\n        }\n\n        /*\n         * The KEXINIT message has been added to the queue.  The packAdd and\n         * readPack states need to be reset because _libssh2_kex_exchange\n         * (eventually) calls upon _libssh2_transport_read to read the rest of\n         * the key exchange conversation.\n         */\n        session->readPack_state = libssh2_NB_state_idle;\n        session->packet.total_num = 0;\n        session->packAdd_state = libssh2_NB_state_idle;\n        session->fullpacket_state = libssh2_NB_state_idle;\n\n        memset(&session->startup_key_state, 0, sizeof(key_exchange_state_t));\n\n        /*\n         * If there was a key reexchange failure, let's just hope we didn't\n         * send NEWKEYS yet, otherwise remote will drop us like a rock\n         */\n        rc = _libssh2_kex_exchange(session, 1, &session->startup_key_state);\n        if(rc == LIBSSH2_ERROR_EAGAIN)\n            return rc;\n    }\n\n    session->packAdd_state = libssh2_NB_state_idle;\n    return 0;\n}",
  "abstract_func_before": "int\n_libssh2_packet_add(LIBSSH2_SESSION * VAR_0, unsigned char *VAR_1,\n                    size_t VAR_2, int VAR_3)\n{\n    int VAR_4 = 0;\n    char *VAR_5 = NULL;\n    char *VAR_6 = NULL;\n    size_t VAR_7 = 0;\n    size_t VAR_8 = 0;\n    LIBSSH2_CHANNEL *VAR_9 = NULL;\n    size_t VAR_10 = 0;\n    unsigned char VAR_11 = VAR_1[0];\n\n    switch(VAR_0->packAdd_state) {\n    case VAR_12:\n        _libssh2_debug(VAR_0, VAR_13,\n                       \"Packet type %d received, length=%d\",\n                       (int) VAR_11, (int) VAR_2);\n\n        if((VAR_3 == VAR_14) &&\n            (!VAR_0->macerror ||\n             LIBSSH2_MACERROR(VAR_0, (char *) VAR_1, VAR_2))) {\n            /* COMMENT_0 */\n                          \n\n            LIBSSH2_FREE(VAR_0, VAR_1);\n            return _libssh2_error(VAR_0, VAR_15,\n                                  \"Invalid MAC received\");\n        }\n        VAR_0->packAdd_state = VAR_16;\n        break;\n    case VAR_17:\n        goto libssh2_packet_add_jump_point1;\n    case VAR_18:\n        goto libssh2_packet_add_jump_point2;\n    case VAR_19:\n        goto libssh2_packet_add_jump_point3;\n    case VAR_20:\n        goto libssh2_packet_add_jump_point4;\n    case VAR_21:\n        goto libssh2_packet_add_jump_point5;\n    default: /* COMMENT_2 */\n        break;\n    }\n\n    if(VAR_0->packAdd_state == VAR_16) {\n        /* COMMENT_3 */\n        switch(VAR_11) {\n\n            /* COMMENT_4 */\n                                          \n                                   \n                                                                         \n                                              \n              \n\n        case VAR_22:\n            if(VAR_2 >= 5) {\n                size_t VAR_23 = _libssh2_ntohu32(VAR_1 + 1);\n\n                if(VAR_2 >= 9) {\n                    VAR_7 = _libssh2_ntohu32(VAR_1 + 5);\n\n                    if(VAR_7 < VAR_2-13) {\n                        /* COMMENT_10 */\n                        VAR_5 = (char *) VAR_1 + 9;\n\n                        VAR_8 =\n                            _libssh2_ntohu32(VAR_1 + 9 + VAR_7);\n                        VAR_6 = (char *) VAR_1 + 9 + VAR_7 + 4;\n\n                        if(VAR_8 > (VAR_2-13-VAR_7)) {\n                            /* COMMENT_11 */\n                            VAR_6 = VAR_5 = NULL;\n                            VAR_8 = VAR_7 = 0;\n                        }\n                    }\n                    else\n                        /* COMMENT_12 */\n                        VAR_7 = 0;\n                }\n                if(VAR_0->ssh_msg_disconnect) {\n                    LIBSSH2_DISCONNECT(VAR_0, VAR_23, VAR_5,\n                                       VAR_7, VAR_6, VAR_8);\n                }\n                _libssh2_debug(VAR_0, VAR_13,\n                               \"Disconnect(%d): %s(%s)\", VAR_23,\n                               VAR_5, VAR_6);\n            }\n\n            LIBSSH2_FREE(VAR_0, VAR_1);\n            VAR_0->socket_state = VAR_24;\n            VAR_0->packAdd_state = VAR_12;\n            return _libssh2_error(VAR_0, VAR_25,\n                                  \"socket disconnect\");\n            /* COMMENT_13 */\n                                      \n                            \n              \n\n        case VAR_26:\n            if(VAR_2 >= 2) {\n                if(VAR_0->ssh_msg_ignore) {\n                    LIBSSH2_IGNORE(VAR_0, (char *) VAR_1 + 1, VAR_2 - 1);\n                }\n            }\n            else if(VAR_0->ssh_msg_ignore) {\n                LIBSSH2_IGNORE(VAR_0, \"\", 0);\n            }\n            LIBSSH2_FREE(VAR_0, VAR_1);\n            VAR_0->packAdd_state = VAR_12;\n            return 0;\n\n            /* COMMENT_17 */\n                                     \n                                      \n                                                                     \n                                              \n              \n\n        case VAR_27:\n            if(VAR_2 >= 2) {\n                int VAR_28 = VAR_1[1];\n\n                if(VAR_2 >= 6) {\n                    VAR_7 = _libssh2_ntohu32(VAR_1 + 2);\n\n                    if(VAR_7 <= (VAR_2 - 10)) {\n                        /* COMMENT_23 */\n                        VAR_5 = (char *) VAR_1 + 6;\n                        VAR_8 = _libssh2_ntohu32(VAR_1 + 6 +\n                                                        VAR_7);\n\n                        if(VAR_8 <= (VAR_2 - 10 - VAR_7))\n                            VAR_6 = (char *) VAR_1 + 10 + VAR_7;\n                    }\n                }\n\n                if(VAR_0->ssh_msg_debug) {\n                    LIBSSH2_DEBUG(VAR_0, VAR_28, VAR_5,\n                                  VAR_7, VAR_6, VAR_8);\n                }\n            }\n            /* COMMENT_24 */\n                                                                   \n                                                        \n               \n            _libssh2_debug(VAR_0, VAR_13,\n                           \"Debug Packet: %s\", VAR_5);\n            LIBSSH2_FREE(VAR_0, VAR_1);\n            VAR_0->packAdd_state = VAR_12;\n            return 0;\n\n            /* COMMENT_28 */\n                                              \n                                                     \n                                  \n                                                     \n              \n\n        case VAR_29:\n            if(VAR_2 >= 5) {\n                uint32_t VAR_30 = 0;\n                unsigned char VAR_31 = 0;\n                VAR_30 = _libssh2_ntohu32(VAR_1 + 1);\n                if(VAR_2 >= (6 + VAR_30)) {\n                    VAR_31 = VAR_1[5 + VAR_30];\n                    _libssh2_debug(VAR_0,\n                                   VAR_32,\n                                   \"Received global request type %.*s (wr %X)\",\n                                   VAR_30, VAR_1 + 5, VAR_31);\n                }\n\n\n                if(VAR_31) {\n                    static const unsigned char VAR_33 =\n                        VAR_34;\n                  libssh2_packet_add_jump_point5:\n                    VAR_0->packAdd_state = VAR_21;\n                    VAR_4 = _libssh2_transport_send(VAR_0, &VAR_33, 1, NULL, 0);\n                    if(VAR_4 == VAR_35)\n                        return VAR_4;\n                }\n            }\n            LIBSSH2_FREE(VAR_0, VAR_1);\n            VAR_0->packAdd_state = VAR_12;\n            return 0;\n\n            /* COMMENT_34 */\n                                                     \n                                         \n                                      \n                            \n              \n\n        case VAR_36:\n            /* COMMENT_40 */\n            VAR_10 += 4;\n\n            /* COMMENT_41 */\n\n            /* COMMENT_42 */\n                                            \n                                         \n                            \n              \n\n        case VAR_37:\n            /* COMMENT_47 */\n            VAR_10 += 9;\n\n            if(VAR_2 >= VAR_10)\n                VAR_9 =\n                    _libssh2_channel_locate(VAR_0,\n                                            _libssh2_ntohu32(VAR_1 + 1));\n\n            if(!VAR_9) {\n                _libssh2_error(VAR_0, VAR_38,\n                               \"Packet received for unknown channel\");\n                LIBSSH2_FREE(VAR_0, VAR_1);\n                VAR_0->packAdd_state = VAR_12;\n                return 0;\n            }\n#ifdef VAR_39\n            {\n                uint32_t VAR_40 = 0;\n                if(VAR_11 == VAR_36)\n                    VAR_40 = _libssh2_ntohu32(VAR_1 + 5);\n\n                _libssh2_debug(VAR_0, VAR_32,\n                               \"%d bytes packet_add() for %lu/%lu/%lu\",\n                               (int) (VAR_2 - VAR_10),\n                               VAR_9->local.id,\n                               VAR_9->remote.id,\n                               VAR_40);\n            }\n#endif\n            if((VAR_9->remote.extended_data_ignore_mode ==\n                 VAR_41) &&\n                (VAR_11 == VAR_36)) {\n                /* COMMENT_48 */\n                LIBSSH2_FREE(VAR_0, VAR_1);\n\n                _libssh2_debug(VAR_0, VAR_32,\n                               \"Ignoring extended data and refunding %d bytes\",\n                               (int) (VAR_2 - 13));\n                if(VAR_9->read_avail + VAR_2 - VAR_10 >=\n                    VAR_9->remote.window_size)\n                    VAR_2 = VAR_9->remote.window_size -\n                        VAR_9->read_avail + VAR_10;\n\n                VAR_9->remote.window_size -= VAR_2 - VAR_10;\n                _libssh2_debug(VAR_0, VAR_32,\n                               \"shrinking window size by %lu bytes to %lu, \"\n                               \"read_avail %lu\",\n                               VAR_2 - VAR_10,\n                               VAR_9->remote.window_size,\n                               VAR_9->read_avail);\n\n                VAR_0->packAdd_channelp = VAR_9;\n\n                /* COMMENT_49 */\n              libssh2_packet_add_jump_point1:\n                VAR_0->packAdd_state = VAR_17;\n                VAR_4 = _libssh2_channel_receive_window_adjust(VAR_0->\n                                                            packAdd_channelp,\n                                                            VAR_2 - 13,\n                                                            1, NULL);\n                if(VAR_4 == VAR_35)\n                    return VAR_4;\n\n                VAR_0->packAdd_state = VAR_12;\n                return 0;\n            }\n\n            /* COMMENT_50 */\n                                                               \n                                 \n               \n            if(VAR_9->remote.packet_size < (VAR_2 - VAR_10)) {\n                /* COMMENT_54 */\n                                                            \n                              \n                   \n                _libssh2_error(VAR_0,\n                               VAR_42,\n                               \"Packet contains more data than we offered\"\n                               \" to receive, truncating\");\n                VAR_2 = VAR_9->remote.packet_size + VAR_10;\n            }\n            if(VAR_9->remote.window_size <= VAR_9->read_avail) {\n                /* COMMENT_58 */\n                                                            \n                              \n                   \n                _libssh2_error(VAR_0,\n                               VAR_43,\n                               \"The current receive window is full,\"\n                               \" data ignored\");\n                LIBSSH2_FREE(VAR_0, VAR_1);\n                VAR_0->packAdd_state = VAR_12;\n                return 0;\n            }\n            /* COMMENT_62 */\n            VAR_9->remote.eof = 0;\n\n            if(VAR_9->read_avail + VAR_2 - VAR_10 >\n                VAR_9->remote.window_size) {\n                _libssh2_error(VAR_0,\n                               VAR_43,\n                               \"Remote sent more data than current \"\n                               \"window allows, truncating\");\n                VAR_2 = VAR_9->remote.window_size -\n                    VAR_9->read_avail + VAR_10;\n            }\n\n            /* COMMENT_63 */\n                                                                    \n                                     \n            VAR_9->read_avail += VAR_2 - VAR_10;\n\n            _libssh2_debug(VAR_0, VAR_32,\n                           \"increasing read_avail by %lu bytes to %lu/%lu\",\n                           (long)(VAR_2 - VAR_10),\n                           (long)VAR_9->read_avail,\n                           (long)VAR_9->remote.window_size);\n\n            break;\n\n            /* COMMENT_66 */\n                                           \n                                         \n              \n\n        case VAR_44:\n            if(VAR_2 >= 5)\n                VAR_9 =\n                    _libssh2_channel_locate(VAR_0,\n                                            _libssh2_ntohu32(VAR_1 + 1));\n            if(!VAR_9)\n                /* COMMENT_70 */\n                ;\n            else {\n                _libssh2_debug(VAR_0,\n                               VAR_32,\n                               \"EOF received for channel %lu/%lu\",\n                               VAR_9->local.id,\n                               VAR_9->remote.id);\n                VAR_9->remote.eof = 1;\n            }\n            LIBSSH2_FREE(VAR_0, VAR_1);\n            VAR_0->packAdd_state = VAR_12;\n            return 0;\n\n            /* COMMENT_71 */\n                                               \n                                         \n                                                                \n                                  \n                                                  \n              \n\n        case VAR_45:\n            if(VAR_2 >= 9) {\n                uint32_t VAR_46 = _libssh2_ntohu32(VAR_1 + 1);\n                uint32_t VAR_30 = _libssh2_ntohu32(VAR_1 + 5);\n                unsigned char VAR_31 = 1;\n\n                if((VAR_30 + 9) < VAR_2)\n                    VAR_31 = VAR_1[VAR_30 + 9];\n\n                _libssh2_debug(VAR_0,\n                               VAR_32,\n                               \"Channel %d received request type %.*s (wr %X)\",\n                               VAR_46, VAR_30, VAR_1 + 9, VAR_31);\n\n                if(VAR_30 == sizeof(\"exit-status\") - 1\n                    && (sizeof(\"exit-status\") - 1 + 9) <= VAR_2\n                    && !memcmp(\"exit-status\", VAR_1 + 9,\n                               sizeof(\"exit-status\") - 1)) {\n\n                    /* COMMENT_78 */\n                    if(VAR_2 >= 20)\n                        VAR_9 =\n                            _libssh2_channel_locate(VAR_0, VAR_46);\n\n                    if(VAR_9 && (sizeof(\"exit-status\") + 13) <= VAR_2) {\n                        VAR_9->exit_status =\n                            _libssh2_ntohu32(VAR_1 + 9 + sizeof(\"exit-status\"));\n                        _libssh2_debug(VAR_0, VAR_32,\n                                       \"Exit status %lu received for \"\n                                       \"channel %lu/%lu\",\n                                       VAR_9->exit_status,\n                                       VAR_9->local.id,\n                                       VAR_9->remote.id);\n                    }\n\n                }\n                else if(VAR_30 == sizeof(\"exit-signal\") - 1\n                         && (sizeof(\"exit-signal\") - 1 + 9) <= VAR_2\n                         && !memcmp(\"exit-signal\", VAR_1 + 9,\n                                    sizeof(\"exit-signal\") - 1)) {\n                    /* COMMENT_79 */\n                    if(VAR_2 >= 20)\n                        VAR_9 = _libssh2_channel_locate(VAR_0, VAR_46);\n\n                    if(VAR_9 && (sizeof(\"exit-signal\") + 13) <= VAR_2) {\n                        /* COMMENT_80 */\n                        uint32_t VAR_47 =\n                            _libssh2_ntohu32(VAR_1 + 9 + sizeof(\"exit-signal\"));\n\n                        if(VAR_47 <= VAR_48 - 1) {\n                            VAR_9->exit_signal =\n                                LIBSSH2_ALLOC(VAR_0, VAR_47 + 1);\n                        }\n                        else {\n                            VAR_9->exit_signal = NULL;\n                        }\n\n                        if(!VAR_9->exit_signal)\n                            VAR_4 = _libssh2_error(VAR_0, VAR_49,\n                                                \"memory for signal name\");\n                        else if((sizeof(\"exit-signal\") + 13 + VAR_47 <=\n                                 VAR_2)) {\n                            memcpy(VAR_9->exit_signal,\n                                   VAR_1 + 13 + sizeof(\"exit-signal\"), VAR_47);\n                            VAR_9->exit_signal[VAR_47] = '\\0';\n                            /* COMMENT_81 */\n                            _libssh2_debug(VAR_0, VAR_32,\n                                           \"Exit signal %s received for \"\n                                           \"channel %lu/%lu\",\n                                           VAR_9->exit_signal,\n                                           VAR_9->local.id,\n                                           VAR_9->remote.id);\n                        }\n                    }\n                }\n\n\n                if(VAR_31) {\n                    unsigned char VAR_33[5];\n                  libssh2_packet_add_jump_point4:\n                    VAR_0->packAdd_state = VAR_20;\n                    VAR_33[0] = VAR_50;\n                    memcpy(&VAR_33[1], VAR_1 + 1, 4);\n                    VAR_4 = _libssh2_transport_send(VAR_0, VAR_33, 5, NULL, 0);\n                    if(VAR_4 == VAR_35)\n                        return VAR_4;\n                }\n            }\n            LIBSSH2_FREE(VAR_0, VAR_1);\n            VAR_0->packAdd_state = VAR_12;\n            return VAR_4;\n\n            /* COMMENT_82 */\n                                             \n                                         \n              \n\n        case VAR_51:\n            if(VAR_2 >= 5)\n                VAR_9 =\n                    _libssh2_channel_locate(VAR_0,\n                                            _libssh2_ntohu32(VAR_1 + 1));\n            if(!VAR_9) {\n                /* COMMENT_70 */\n                LIBSSH2_FREE(VAR_0, VAR_1);\n                VAR_0->packAdd_state = VAR_12;\n                return 0;\n            }\n            _libssh2_debug(VAR_0, VAR_32,\n                           \"Close received for channel %lu/%lu\",\n                           VAR_9->local.id,\n                           VAR_9->remote.id);\n\n            VAR_9->remote.close = 1;\n            VAR_9->remote.eof = 1;\n\n            LIBSSH2_FREE(VAR_0, VAR_1);\n            VAR_0->packAdd_state = VAR_12;\n            return 0;\n\n            /* COMMENT_86 */\n                                            \n                                 \n                                      \n                                           \n                                           \n              \n\n        case VAR_52:\n            if(VAR_2 < 17)\n                ;\n            else if((VAR_2 >= (sizeof(\"forwarded-tcpip\") + 4)) &&\n                     ((sizeof(\"forwarded-tcpip\") - 1) ==\n                      _libssh2_ntohu32(VAR_1 + 1))\n                     &&\n                     (memcmp(VAR_1 + 5, \"forwarded-tcpip\",\n                             sizeof(\"forwarded-tcpip\") - 1) == 0)) {\n\n                /* COMMENT_93 */\n                memset(&VAR_0->packAdd_Qlstn_state, 0,\n                       sizeof(VAR_0->packAdd_Qlstn_state));\n\n              libssh2_packet_add_jump_point2:\n                VAR_0->packAdd_state = VAR_18;\n                VAR_4 = packet_queue_listener(VAR_0, VAR_1, VAR_2,\n                                           &VAR_0->packAdd_Qlstn_state);\n            }\n            else if((VAR_2 >= (sizeof(\"x11\") + 4)) &&\n                     ((sizeof(\"x11\") - 1) == _libssh2_ntohu32(VAR_1 + 1)) &&\n                     (memcmp(VAR_1 + 5, \"x11\", sizeof(\"x11\") - 1) == 0)) {\n\n                /* COMMENT_93 */\n                memset(&VAR_0->packAdd_x11open_state, 0,\n                       sizeof(VAR_0->packAdd_x11open_state));\n\n              libssh2_packet_add_jump_point3:\n                VAR_0->packAdd_state = VAR_19;\n                VAR_4 = packet_x11_open(VAR_0, VAR_1, VAR_2,\n                                     &VAR_0->packAdd_x11open_state);\n            }\n            if(VAR_4 == VAR_35)\n                return VAR_4;\n\n            LIBSSH2_FREE(VAR_0, VAR_1);\n            VAR_0->packAdd_state = VAR_12;\n            return VAR_4;\n\n            /* COMMENT_94 */\n                                                     \n                                         \n                                    \n              \n        case VAR_53:\n            if(VAR_2 < 9)\n                ;\n            else {\n                uint32_t VAR_54 = _libssh2_ntohu32(VAR_1 + 5);\n                VAR_9 =\n                    _libssh2_channel_locate(VAR_0,\n                                            _libssh2_ntohu32(VAR_1 + 1));\n                if(VAR_9) {\n                    VAR_9->local.window_size += VAR_54;\n\n                    _libssh2_debug(VAR_0, VAR_32,\n                                   \"Window adjust for channel %lu/%lu, \"\n                                   \"adding %lu bytes, new window_size=%lu\",\n                                   VAR_9->local.id,\n                                   VAR_9->remote.id,\n                                   VAR_54,\n                                   VAR_9->local.window_size);\n                }\n            }\n            LIBSSH2_FREE(VAR_0, VAR_1);\n            VAR_0->packAdd_state = VAR_12;\n            return 0;\n        default:\n            break;\n        }\n\n        VAR_0->packAdd_state = VAR_55;\n    }\n\n    if(VAR_0->packAdd_state == VAR_55) {\n        LIBSSH2_PACKET *VAR_56 =\n            LIBSSH2_ALLOC(VAR_0, sizeof(LIBSSH2_PACKET));\n        if(!VAR_56) {\n            _libssh2_debug(VAR_0, VAR_49,\n                           \"memory for packet\");\n            LIBSSH2_FREE(VAR_0, VAR_1);\n            VAR_0->packAdd_state = VAR_12;\n            return VAR_49;\n        }\n        VAR_56->data = VAR_1;\n        VAR_56->data_len = VAR_2;\n        VAR_56->data_head = VAR_10;\n\n        _libssh2_list_add(&VAR_0->packets, &VAR_56->node);\n\n        VAR_0->packAdd_state = VAR_57;\n    }\n\n    if((VAR_11 == VAR_58 &&\n         !(VAR_0->state & VAR_59)) ||\n        (VAR_0->packAdd_state == VAR_60)) {\n        if(VAR_0->packAdd_state == VAR_57) {\n            /* COMMENT_99 */\n                                    \n                                                 \n                                                  \n               \n            _libssh2_debug(VAR_0, VAR_13, \"Renegotiating Keys\");\n\n            VAR_0->packAdd_state = VAR_60;\n        }\n\n        /* COMMENT_104 */\n                                                                            \n                                                                         \n                                                                              \n                                         \n           \n        VAR_0->readPack_state = VAR_12;\n        VAR_0->packet.total_num = 0;\n        VAR_0->packAdd_state = VAR_12;\n        VAR_0->fullpacket_state = VAR_12;\n\n        memset(&VAR_0->startup_key_state, 0, sizeof(VAR_61));\n\n        /* COMMENT_110 */\n                                                                           \n                                                                      \n           \n        VAR_4 = _libssh2_kex_exchange(VAR_0, 1, &VAR_0->startup_key_state);\n        if(VAR_4 == VAR_35)\n            return VAR_4;\n    }\n\n    VAR_0->packAdd_state = VAR_12;\n    return 0;\n}",
  "func_graph_path_before": "libssh2/dedcbd106f8e52d5586b0205bc7677e4c9868f9c/packet.c/vul/before/0.json",
  "func": "int\n_libssh2_packet_add(LIBSSH2_SESSION * session, unsigned char *data,\n                    size_t datalen, int macstate)\n{\n    int rc = 0;\n    unsigned char *message = NULL;\n    unsigned char *language = NULL;\n    size_t message_len = 0;\n    size_t language_len = 0;\n    LIBSSH2_CHANNEL *channelp = NULL;\n    size_t data_head = 0;\n    unsigned char msg = data[0];\n\n    switch(session->packAdd_state) {\n    case libssh2_NB_state_idle:\n        _libssh2_debug(session, LIBSSH2_TRACE_TRANS,\n                       \"Packet type %d received, length=%d\",\n                       (int) msg, (int) datalen);\n\n        if((macstate == LIBSSH2_MAC_INVALID) &&\n            (!session->macerror ||\n             LIBSSH2_MACERROR(session, (char *) data, datalen))) {\n            /* Bad MAC input, but no callback set or non-zero return from the\n               callback */\n\n            LIBSSH2_FREE(session, data);\n            return _libssh2_error(session, LIBSSH2_ERROR_INVALID_MAC,\n                                  \"Invalid MAC received\");\n        }\n        session->packAdd_state = libssh2_NB_state_allocated;\n        break;\n    case libssh2_NB_state_jump1:\n        goto libssh2_packet_add_jump_point1;\n    case libssh2_NB_state_jump2:\n        goto libssh2_packet_add_jump_point2;\n    case libssh2_NB_state_jump3:\n        goto libssh2_packet_add_jump_point3;\n    case libssh2_NB_state_jump4:\n        goto libssh2_packet_add_jump_point4;\n    case libssh2_NB_state_jump5:\n        goto libssh2_packet_add_jump_point5;\n    default: /* nothing to do */\n        break;\n    }\n\n    if(session->packAdd_state == libssh2_NB_state_allocated) {\n        /* A couple exceptions to the packet adding rule: */\n        switch(msg) {\n\n            /*\n              byte      SSH_MSG_DISCONNECT\n              uint32    reason code\n              string    description in ISO-10646 UTF-8 encoding [RFC3629]\n              string    language tag [RFC3066]\n            */\n\n        case SSH_MSG_DISCONNECT:\n            if(datalen >= 5) {\n                uint32_t reason = 0;\n                struct string_buf buf;\n                buf.data = (unsigned char *)data;\n                buf.dataptr = buf.data;\n                buf.len = datalen;\n                buf.dataptr++; /* advance past type */\n\n                _libssh2_get_u32(&buf, &reason);\n                _libssh2_get_string(&buf, &message, &message_len);\n                _libssh2_get_string(&buf, &language, &language_len);\n\n                if(session->ssh_msg_disconnect) {\n                    LIBSSH2_DISCONNECT(session, reason, (const char *)message,\n                                       message_len, (const char *)language,\n                                       language_len);\n                }\n\n                _libssh2_debug(session, LIBSSH2_TRACE_TRANS,\n                               \"Disconnect(%d): %s(%s)\", reason,\n                               message, language);\n            }\n\n            LIBSSH2_FREE(session, data);\n            session->socket_state = LIBSSH2_SOCKET_DISCONNECTED;\n            session->packAdd_state = libssh2_NB_state_idle;\n            return _libssh2_error(session, LIBSSH2_ERROR_SOCKET_DISCONNECT,\n                                  \"socket disconnect\");\n            /*\n              byte      SSH_MSG_IGNORE\n              string    data\n            */\n\n        case SSH_MSG_IGNORE:\n            if(datalen >= 2) {\n                if(session->ssh_msg_ignore) {\n                    LIBSSH2_IGNORE(session, (char *) data + 1, datalen - 1);\n                }\n            }\n            else if(session->ssh_msg_ignore) {\n                LIBSSH2_IGNORE(session, \"\", 0);\n            }\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return 0;\n\n            /*\n              byte      SSH_MSG_DEBUG\n              boolean   always_display\n              string    message in ISO-10646 UTF-8 encoding [RFC3629]\n              string    language tag [RFC3066]\n            */\n\n        case SSH_MSG_DEBUG:\n            if(datalen >= 2) {\n                int always_display = data[1];\n\n                if(datalen >= 6) {\n                    struct string_buf buf;\n                    buf.data = (unsigned char *)data;\n                    buf.dataptr = buf.data;\n                    buf.len = datalen;\n                    buf.dataptr += 2; /* advance past type & always display */\n\n                    _libssh2_get_string(&buf, &message, &message_len);\n                    _libssh2_get_string(&buf, &language, &language_len);\n                }\n\n                if(session->ssh_msg_debug) {\n                    LIBSSH2_DEBUG(session, always_display,\n                                  (const char *)message,\n                                  message_len, (const char *)language,\n                                  language_len);\n                }\n            }\n\n            /*\n             * _libssh2_debug will actually truncate this for us so\n             * that it's not an inordinate about of data\n             */\n            _libssh2_debug(session, LIBSSH2_TRACE_TRANS,\n                           \"Debug Packet: %s\", message);\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return 0;\n\n            /*\n              byte      SSH_MSG_GLOBAL_REQUEST\n              string    request name in US-ASCII only\n              boolean   want reply\n              ....      request-specific data follows\n            */\n\n        case SSH_MSG_GLOBAL_REQUEST:\n            if(datalen >= 5) {\n                uint32_t len = 0;\n                unsigned char want_reply = 0;\n                len = _libssh2_ntohu32(data + 1);\n                if((len <= (UINT_MAX - 6)) && (datalen >= (6 + len))) {\n                    want_reply = data[5 + len];\n                    _libssh2_debug(session,\n                                   LIBSSH2_TRACE_CONN,\n                                   \"Received global request type %.*s (wr %X)\",\n                                   len, data + 5, want_reply);\n                }\n\n\n                if(want_reply) {\n                    static const unsigned char packet =\n                        SSH_MSG_REQUEST_FAILURE;\n                  libssh2_packet_add_jump_point5:\n                    session->packAdd_state = libssh2_NB_state_jump5;\n                    rc = _libssh2_transport_send(session, &packet, 1, NULL, 0);\n                    if(rc == LIBSSH2_ERROR_EAGAIN)\n                        return rc;\n                }\n            }\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return 0;\n\n            /*\n              byte      SSH_MSG_CHANNEL_EXTENDED_DATA\n              uint32    recipient channel\n              uint32    data_type_code\n              string    data\n            */\n\n        case SSH_MSG_CHANNEL_EXTENDED_DATA:\n            /* streamid(4) */\n            data_head += 4;\n\n            /* fall-through */\n\n            /*\n              byte      SSH_MSG_CHANNEL_DATA\n              uint32    recipient channel\n              string    data\n            */\n\n        case SSH_MSG_CHANNEL_DATA:\n            /* packet_type(1) + channelno(4) + datalen(4) */\n            data_head += 9;\n\n            if(datalen >= data_head)\n                channelp =\n                    _libssh2_channel_locate(session,\n                                            _libssh2_ntohu32(data + 1));\n\n            if(!channelp) {\n                _libssh2_error(session, LIBSSH2_ERROR_CHANNEL_UNKNOWN,\n                               \"Packet received for unknown channel\");\n                LIBSSH2_FREE(session, data);\n                session->packAdd_state = libssh2_NB_state_idle;\n                return 0;\n            }\n#ifdef LIBSSH2DEBUG\n            {\n                uint32_t stream_id = 0;\n                if(msg == SSH_MSG_CHANNEL_EXTENDED_DATA)\n                    stream_id = _libssh2_ntohu32(data + 5);\n\n                _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                               \"%d bytes packet_add() for %lu/%lu/%lu\",\n                               (int) (datalen - data_head),\n                               channelp->local.id,\n                               channelp->remote.id,\n                               stream_id);\n            }\n#endif\n            if((channelp->remote.extended_data_ignore_mode ==\n                 LIBSSH2_CHANNEL_EXTENDED_DATA_IGNORE) &&\n                (msg == SSH_MSG_CHANNEL_EXTENDED_DATA)) {\n                /* Pretend we didn't receive this */\n                LIBSSH2_FREE(session, data);\n\n                _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                               \"Ignoring extended data and refunding %d bytes\",\n                               (int) (datalen - 13));\n                if(channelp->read_avail + datalen - data_head >=\n                    channelp->remote.window_size)\n                    datalen = channelp->remote.window_size -\n                        channelp->read_avail + data_head;\n\n                channelp->remote.window_size -= datalen - data_head;\n                _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                               \"shrinking window size by %lu bytes to %lu, \"\n                               \"read_avail %lu\",\n                               datalen - data_head,\n                               channelp->remote.window_size,\n                               channelp->read_avail);\n\n                session->packAdd_channelp = channelp;\n\n                /* Adjust the window based on the block we just freed */\n              libssh2_packet_add_jump_point1:\n                session->packAdd_state = libssh2_NB_state_jump1;\n                rc = _libssh2_channel_receive_window_adjust(session->\n                                                            packAdd_channelp,\n                                                            datalen - 13,\n                                                            1, NULL);\n                if(rc == LIBSSH2_ERROR_EAGAIN)\n                    return rc;\n\n                session->packAdd_state = libssh2_NB_state_idle;\n                return 0;\n            }\n\n            /*\n             * REMEMBER! remote means remote as source of data,\n             * NOT remote window!\n             */\n            if(channelp->remote.packet_size < (datalen - data_head)) {\n                /*\n                 * Spec says we MAY ignore bytes sent beyond\n                 * packet_size\n                 */\n                _libssh2_error(session,\n                               LIBSSH2_ERROR_CHANNEL_PACKET_EXCEEDED,\n                               \"Packet contains more data than we offered\"\n                               \" to receive, truncating\");\n                datalen = channelp->remote.packet_size + data_head;\n            }\n            if(channelp->remote.window_size <= channelp->read_avail) {\n                /*\n                 * Spec says we MAY ignore bytes sent beyond\n                 * window_size\n                 */\n                _libssh2_error(session,\n                               LIBSSH2_ERROR_CHANNEL_WINDOW_EXCEEDED,\n                               \"The current receive window is full,\"\n                               \" data ignored\");\n                LIBSSH2_FREE(session, data);\n                session->packAdd_state = libssh2_NB_state_idle;\n                return 0;\n            }\n            /* Reset EOF status */\n            channelp->remote.eof = 0;\n\n            if(channelp->read_avail + datalen - data_head >\n                channelp->remote.window_size) {\n                _libssh2_error(session,\n                               LIBSSH2_ERROR_CHANNEL_WINDOW_EXCEEDED,\n                               \"Remote sent more data than current \"\n                               \"window allows, truncating\");\n                datalen = channelp->remote.window_size -\n                    channelp->read_avail + data_head;\n            }\n\n            /* Update the read_avail counter. The window size will be\n             * updated once the data is actually read from the queue\n             * from an upper layer */\n            channelp->read_avail += datalen - data_head;\n\n            _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                           \"increasing read_avail by %lu bytes to %lu/%lu\",\n                           (long)(datalen - data_head),\n                           (long)channelp->read_avail,\n                           (long)channelp->remote.window_size);\n\n            break;\n\n            /*\n              byte      SSH_MSG_CHANNEL_EOF\n              uint32    recipient channel\n            */\n\n        case SSH_MSG_CHANNEL_EOF:\n            if(datalen >= 5)\n                channelp =\n                    _libssh2_channel_locate(session,\n                                            _libssh2_ntohu32(data + 1));\n            if(!channelp)\n                /* We may have freed already, just quietly ignore this... */\n                ;\n            else {\n                _libssh2_debug(session,\n                               LIBSSH2_TRACE_CONN,\n                               \"EOF received for channel %lu/%lu\",\n                               channelp->local.id,\n                               channelp->remote.id);\n                channelp->remote.eof = 1;\n            }\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return 0;\n\n            /*\n              byte      SSH_MSG_CHANNEL_REQUEST\n              uint32    recipient channel\n              string    request type in US-ASCII characters only\n              boolean   want reply\n              ....      type-specific data follows\n            */\n\n        case SSH_MSG_CHANNEL_REQUEST:\n            if(datalen >= 9) {\n                uint32_t channel = _libssh2_ntohu32(data + 1);\n                uint32_t len = _libssh2_ntohu32(data + 5);\n                unsigned char want_reply = 1;\n\n                if((len + 9) < datalen)\n                    want_reply = data[len + 9];\n\n                _libssh2_debug(session,\n                               LIBSSH2_TRACE_CONN,\n                               \"Channel %d received request type %.*s (wr %X)\",\n                               channel, len, data + 9, want_reply);\n\n                if(len == sizeof(\"exit-status\") - 1\n                    && (sizeof(\"exit-status\") - 1 + 9) <= datalen\n                    && !memcmp(\"exit-status\", data + 9,\n                               sizeof(\"exit-status\") - 1)) {\n\n                    /* we've got \"exit-status\" packet. Set the session value */\n                    if(datalen >= 20)\n                        channelp =\n                            _libssh2_channel_locate(session, channel);\n\n                    if(channelp && (sizeof(\"exit-status\") + 13) <= datalen) {\n                        channelp->exit_status =\n                            _libssh2_ntohu32(data + 9 + sizeof(\"exit-status\"));\n                        _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                                       \"Exit status %lu received for \"\n                                       \"channel %lu/%lu\",\n                                       channelp->exit_status,\n                                       channelp->local.id,\n                                       channelp->remote.id);\n                    }\n\n                }\n                else if(len == sizeof(\"exit-signal\") - 1\n                         && (sizeof(\"exit-signal\") - 1 + 9) <= datalen\n                         && !memcmp(\"exit-signal\", data + 9,\n                                    sizeof(\"exit-signal\") - 1)) {\n                    /* command terminated due to signal */\n                    if(datalen >= 20)\n                        channelp = _libssh2_channel_locate(session, channel);\n\n                    if(channelp && (sizeof(\"exit-signal\") + 13) <= datalen) {\n                        /* set signal name (without SIG prefix) */\n                        uint32_t namelen =\n                            _libssh2_ntohu32(data + 9 + sizeof(\"exit-signal\"));\n\n                        if(namelen <= UINT_MAX - 1) {\n                            channelp->exit_signal =\n                                LIBSSH2_ALLOC(session, namelen + 1);\n                        }\n                        else {\n                            channelp->exit_signal = NULL;\n                        }\n\n                        if(!channelp->exit_signal)\n                            rc = _libssh2_error(session, LIBSSH2_ERROR_ALLOC,\n                                                \"memory for signal name\");\n                        else if((sizeof(\"exit-signal\") + 13 + namelen <=\n                                 datalen)) {\n                            memcpy(channelp->exit_signal,\n                                   data + 13 + sizeof(\"exit-signal\"), namelen);\n                            channelp->exit_signal[namelen] = '\\0';\n                            /* TODO: save error message and language tag */\n                            _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                                           \"Exit signal %s received for \"\n                                           \"channel %lu/%lu\",\n                                           channelp->exit_signal,\n                                           channelp->local.id,\n                                           channelp->remote.id);\n                        }\n                    }\n                }\n\n\n                if(want_reply) {\n                    unsigned char packet[5];\n                  libssh2_packet_add_jump_point4:\n                    session->packAdd_state = libssh2_NB_state_jump4;\n                    packet[0] = SSH_MSG_CHANNEL_FAILURE;\n                    memcpy(&packet[1], data + 1, 4);\n                    rc = _libssh2_transport_send(session, packet, 5, NULL, 0);\n                    if(rc == LIBSSH2_ERROR_EAGAIN)\n                        return rc;\n                }\n            }\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return rc;\n\n            /*\n              byte      SSH_MSG_CHANNEL_CLOSE\n              uint32    recipient channel\n            */\n\n        case SSH_MSG_CHANNEL_CLOSE:\n            if(datalen >= 5)\n                channelp =\n                    _libssh2_channel_locate(session,\n                                            _libssh2_ntohu32(data + 1));\n            if(!channelp) {\n                /* We may have freed already, just quietly ignore this... */\n                LIBSSH2_FREE(session, data);\n                session->packAdd_state = libssh2_NB_state_idle;\n                return 0;\n            }\n            _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                           \"Close received for channel %lu/%lu\",\n                           channelp->local.id,\n                           channelp->remote.id);\n\n            channelp->remote.close = 1;\n            channelp->remote.eof = 1;\n\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return 0;\n\n            /*\n              byte      SSH_MSG_CHANNEL_OPEN\n              string    \"session\"\n              uint32    sender channel\n              uint32    initial window size\n              uint32    maximum packet size\n            */\n\n        case SSH_MSG_CHANNEL_OPEN:\n            if(datalen < 17)\n                ;\n            else if((datalen >= (sizeof(\"forwarded-tcpip\") + 4)) &&\n                     ((sizeof(\"forwarded-tcpip\") - 1) ==\n                      _libssh2_ntohu32(data + 1))\n                     &&\n                     (memcmp(data + 5, \"forwarded-tcpip\",\n                             sizeof(\"forwarded-tcpip\") - 1) == 0)) {\n\n                /* init the state struct */\n                memset(&session->packAdd_Qlstn_state, 0,\n                       sizeof(session->packAdd_Qlstn_state));\n\n              libssh2_packet_add_jump_point2:\n                session->packAdd_state = libssh2_NB_state_jump2;\n                rc = packet_queue_listener(session, data, datalen,\n                                           &session->packAdd_Qlstn_state);\n            }\n            else if((datalen >= (sizeof(\"x11\") + 4)) &&\n                     ((sizeof(\"x11\") - 1) == _libssh2_ntohu32(data + 1)) &&\n                     (memcmp(data + 5, \"x11\", sizeof(\"x11\") - 1) == 0)) {\n\n                /* init the state struct */\n                memset(&session->packAdd_x11open_state, 0,\n                       sizeof(session->packAdd_x11open_state));\n\n              libssh2_packet_add_jump_point3:\n                session->packAdd_state = libssh2_NB_state_jump3;\n                rc = packet_x11_open(session, data, datalen,\n                                     &session->packAdd_x11open_state);\n            }\n            if(rc == LIBSSH2_ERROR_EAGAIN)\n                return rc;\n\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return rc;\n\n            /*\n              byte      SSH_MSG_CHANNEL_WINDOW_ADJUST\n              uint32    recipient channel\n              uint32    bytes to add\n            */\n        case SSH_MSG_CHANNEL_WINDOW_ADJUST:\n            if(datalen < 9)\n                ;\n            else {\n                uint32_t bytestoadd = _libssh2_ntohu32(data + 5);\n                channelp =\n                    _libssh2_channel_locate(session,\n                                            _libssh2_ntohu32(data + 1));\n                if(channelp) {\n                    channelp->local.window_size += bytestoadd;\n\n                    _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                                   \"Window adjust for channel %lu/%lu, \"\n                                   \"adding %lu bytes, new window_size=%lu\",\n                                   channelp->local.id,\n                                   channelp->remote.id,\n                                   bytestoadd,\n                                   channelp->local.window_size);\n                }\n            }\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return 0;\n        default:\n            break;\n        }\n\n        session->packAdd_state = libssh2_NB_state_sent;\n    }\n\n    if(session->packAdd_state == libssh2_NB_state_sent) {\n        LIBSSH2_PACKET *packetp =\n            LIBSSH2_ALLOC(session, sizeof(LIBSSH2_PACKET));\n        if(!packetp) {\n            _libssh2_debug(session, LIBSSH2_ERROR_ALLOC,\n                           \"memory for packet\");\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return LIBSSH2_ERROR_ALLOC;\n        }\n        packetp->data = data;\n        packetp->data_len = datalen;\n        packetp->data_head = data_head;\n\n        _libssh2_list_add(&session->packets, &packetp->node);\n\n        session->packAdd_state = libssh2_NB_state_sent1;\n    }\n\n    if((msg == SSH_MSG_KEXINIT &&\n         !(session->state & LIBSSH2_STATE_EXCHANGING_KEYS)) ||\n        (session->packAdd_state == libssh2_NB_state_sent2)) {\n        if(session->packAdd_state == libssh2_NB_state_sent1) {\n            /*\n             * Remote wants new keys\n             * Well, it's already in the brigade,\n             * let's just call back into ourselves\n             */\n            _libssh2_debug(session, LIBSSH2_TRACE_TRANS, \"Renegotiating Keys\");\n\n            session->packAdd_state = libssh2_NB_state_sent2;\n        }\n\n        /*\n         * The KEXINIT message has been added to the queue.  The packAdd and\n         * readPack states need to be reset because _libssh2_kex_exchange\n         * (eventually) calls upon _libssh2_transport_read to read the rest of\n         * the key exchange conversation.\n         */\n        session->readPack_state = libssh2_NB_state_idle;\n        session->packet.total_num = 0;\n        session->packAdd_state = libssh2_NB_state_idle;\n        session->fullpacket_state = libssh2_NB_state_idle;\n\n        memset(&session->startup_key_state, 0, sizeof(key_exchange_state_t));\n\n        /*\n         * If there was a key reexchange failure, let's just hope we didn't\n         * send NEWKEYS yet, otherwise remote will drop us like a rock\n         */\n        rc = _libssh2_kex_exchange(session, 1, &session->startup_key_state);\n        if(rc == LIBSSH2_ERROR_EAGAIN)\n            return rc;\n    }\n\n    session->packAdd_state = libssh2_NB_state_idle;\n    return 0;\n}",
  "abstract_func": "int\n_libssh2_packet_add(LIBSSH2_SESSION * VAR_0, unsigned char *VAR_1,\n                    size_t VAR_2, int VAR_3)\n{\n    int VAR_4 = 0;\n    unsigned char *VAR_5 = NULL;\n    unsigned char *VAR_6 = NULL;\n    size_t VAR_7 = 0;\n    size_t VAR_8 = 0;\n    LIBSSH2_CHANNEL *VAR_9 = NULL;\n    size_t VAR_10 = 0;\n    unsigned char VAR_11 = VAR_1[0];\n\n    switch(VAR_0->packAdd_state) {\n    case VAR_12:\n        _libssh2_debug(VAR_0, VAR_13,\n                       \"Packet type %d received, length=%d\",\n                       (int) VAR_11, (int) VAR_2);\n\n        if((VAR_3 == VAR_14) &&\n            (!VAR_0->macerror ||\n             LIBSSH2_MACERROR(VAR_0, (char *) VAR_1, VAR_2))) {\n            /* COMMENT_0 */\n                          \n\n            LIBSSH2_FREE(VAR_0, VAR_1);\n            return _libssh2_error(VAR_0, VAR_15,\n                                  \"Invalid MAC received\");\n        }\n        VAR_0->packAdd_state = VAR_16;\n        break;\n    case VAR_17:\n        goto libssh2_packet_add_jump_point1;\n    case VAR_18:\n        goto libssh2_packet_add_jump_point2;\n    case VAR_19:\n        goto libssh2_packet_add_jump_point3;\n    case VAR_20:\n        goto libssh2_packet_add_jump_point4;\n    case VAR_21:\n        goto libssh2_packet_add_jump_point5;\n    default: /* COMMENT_2 */\n        break;\n    }\n\n    if(VAR_0->packAdd_state == VAR_16) {\n        /* COMMENT_3 */\n        switch(VAR_11) {\n\n            /* COMMENT_4 */\n                                          \n                                   \n                                                                         \n                                              \n              \n\n        case VAR_22:\n            if(VAR_2 >= 5) {\n                uint32_t VAR_23 = 0;\n                struct string_buf VAR_24;\n                VAR_24.data = (unsigned char *)VAR_1;\n                VAR_24.dataptr = VAR_24.data;\n                VAR_24.len = VAR_2;\n                VAR_24.dataptr++; /* COMMENT_10 */\n\n                _libssh2_get_u32(&VAR_24, &VAR_23);\n                _libssh2_get_string(&VAR_24, &VAR_5, &VAR_7);\n                _libssh2_get_string(&VAR_24, &VAR_6, &VAR_8);\n\n                if(VAR_0->ssh_msg_disconnect) {\n                    LIBSSH2_DISCONNECT(VAR_0, VAR_23, (const char *)VAR_5,\n                                       VAR_7, (const char *)VAR_6,\n                                       VAR_8);\n                }\n\n                _libssh2_debug(VAR_0, VAR_13,\n                               \"Disconnect(%d): %s(%s)\", VAR_23,\n                               VAR_5, VAR_6);\n            }\n\n            LIBSSH2_FREE(VAR_0, VAR_1);\n            VAR_0->socket_state = VAR_25;\n            VAR_0->packAdd_state = VAR_12;\n            return _libssh2_error(VAR_0, VAR_26,\n                                  \"socket disconnect\");\n            /* COMMENT_11 */\n                                      \n                            \n              \n\n        case VAR_27:\n            if(VAR_2 >= 2) {\n                if(VAR_0->ssh_msg_ignore) {\n                    LIBSSH2_IGNORE(VAR_0, (char *) VAR_1 + 1, VAR_2 - 1);\n                }\n            }\n            else if(VAR_0->ssh_msg_ignore) {\n                LIBSSH2_IGNORE(VAR_0, \"\", 0);\n            }\n            LIBSSH2_FREE(VAR_0, VAR_1);\n            VAR_0->packAdd_state = VAR_12;\n            return 0;\n\n            /* COMMENT_15 */\n                                     \n                                      \n                                                                     \n                                              \n              \n\n        case VAR_28:\n            if(VAR_2 >= 2) {\n                int VAR_29 = VAR_1[1];\n\n                if(VAR_2 >= 6) {\n                    struct string_buf VAR_24;\n                    VAR_24.data = (unsigned char *)VAR_1;\n                    VAR_24.dataptr = VAR_24.data;\n                    VAR_24.len = VAR_2;\n                    VAR_24.dataptr += 2; /* COMMENT_21 */\n\n                    _libssh2_get_string(&VAR_24, &VAR_5, &VAR_7);\n                    _libssh2_get_string(&VAR_24, &VAR_6, &VAR_8);\n                }\n\n                if(VAR_0->ssh_msg_debug) {\n                    LIBSSH2_DEBUG(VAR_0, VAR_29,\n                                  (const char *)VAR_5,\n                                  VAR_7, (const char *)VAR_6,\n                                  VAR_8);\n                }\n            }\n\n            /* COMMENT_22 */\n                                                                   \n                                                        \n               \n            _libssh2_debug(VAR_0, VAR_13,\n                           \"Debug Packet: %s\", VAR_5);\n            LIBSSH2_FREE(VAR_0, VAR_1);\n            VAR_0->packAdd_state = VAR_12;\n            return 0;\n\n            /* COMMENT_26 */\n                                              \n                                                     \n                                  \n                                                     \n              \n\n        case VAR_30:\n            if(VAR_2 >= 5) {\n                uint32_t VAR_31 = 0;\n                unsigned char VAR_32 = 0;\n                VAR_31 = _libssh2_ntohu32(VAR_1 + 1);\n                if((VAR_31 <= (VAR_33 - 6)) && (VAR_2 >= (6 + VAR_31))) {\n                    VAR_32 = VAR_1[5 + VAR_31];\n                    _libssh2_debug(VAR_0,\n                                   VAR_34,\n                                   \"Received global request type %.*s (wr %X)\",\n                                   VAR_31, VAR_1 + 5, VAR_32);\n                }\n\n\n                if(VAR_32) {\n                    static const unsigned char VAR_35 =\n                        VAR_36;\n                  libssh2_packet_add_jump_point5:\n                    VAR_0->packAdd_state = VAR_21;\n                    VAR_4 = _libssh2_transport_send(VAR_0, &VAR_35, 1, NULL, 0);\n                    if(VAR_4 == VAR_37)\n                        return VAR_4;\n                }\n            }\n            LIBSSH2_FREE(VAR_0, VAR_1);\n            VAR_0->packAdd_state = VAR_12;\n            return 0;\n\n            /* COMMENT_32 */\n                                                     \n                                         \n                                      \n                            \n              \n\n        case VAR_38:\n            /* COMMENT_38 */\n            VAR_10 += 4;\n\n            /* COMMENT_39 */\n\n            /* COMMENT_40 */\n                                            \n                                         \n                            \n              \n\n        case VAR_39:\n            /* COMMENT_45 */\n            VAR_10 += 9;\n\n            if(VAR_2 >= VAR_10)\n                VAR_9 =\n                    _libssh2_channel_locate(VAR_0,\n                                            _libssh2_ntohu32(VAR_1 + 1));\n\n            if(!VAR_9) {\n                _libssh2_error(VAR_0, VAR_40,\n                               \"Packet received for unknown channel\");\n                LIBSSH2_FREE(VAR_0, VAR_1);\n                VAR_0->packAdd_state = VAR_12;\n                return 0;\n            }\n#ifdef VAR_41\n            {\n                uint32_t VAR_42 = 0;\n                if(VAR_11 == VAR_38)\n                    VAR_42 = _libssh2_ntohu32(VAR_1 + 5);\n\n                _libssh2_debug(VAR_0, VAR_34,\n                               \"%d bytes packet_add() for %lu/%lu/%lu\",\n                               (int) (VAR_2 - VAR_10),\n                               VAR_9->local.id,\n                               VAR_9->remote.id,\n                               VAR_42);\n            }\n#endif\n            if((VAR_9->remote.extended_data_ignore_mode ==\n                 VAR_43) &&\n                (VAR_11 == VAR_38)) {\n                /* COMMENT_46 */\n                LIBSSH2_FREE(VAR_0, VAR_1);\n\n                _libssh2_debug(VAR_0, VAR_34,\n                               \"Ignoring extended data and refunding %d bytes\",\n                               (int) (VAR_2 - 13));\n                if(VAR_9->read_avail + VAR_2 - VAR_10 >=\n                    VAR_9->remote.window_size)\n                    VAR_2 = VAR_9->remote.window_size -\n                        VAR_9->read_avail + VAR_10;\n\n                VAR_9->remote.window_size -= VAR_2 - VAR_10;\n                _libssh2_debug(VAR_0, VAR_34,\n                               \"shrinking window size by %lu bytes to %lu, \"\n                               \"read_avail %lu\",\n                               VAR_2 - VAR_10,\n                               VAR_9->remote.window_size,\n                               VAR_9->read_avail);\n\n                VAR_0->packAdd_channelp = VAR_9;\n\n                /* COMMENT_47 */\n              libssh2_packet_add_jump_point1:\n                VAR_0->packAdd_state = VAR_17;\n                VAR_4 = _libssh2_channel_receive_window_adjust(VAR_0->\n                                                            packAdd_channelp,\n                                                            VAR_2 - 13,\n                                                            1, NULL);\n                if(VAR_4 == VAR_37)\n                    return VAR_4;\n\n                VAR_0->packAdd_state = VAR_12;\n                return 0;\n            }\n\n            /* COMMENT_48 */\n                                                               \n                                 \n               \n            if(VAR_9->remote.packet_size < (VAR_2 - VAR_10)) {\n                /* COMMENT_52 */\n                                                            \n                              \n                   \n                _libssh2_error(VAR_0,\n                               VAR_44,\n                               \"Packet contains more data than we offered\"\n                               \" to receive, truncating\");\n                VAR_2 = VAR_9->remote.packet_size + VAR_10;\n            }\n            if(VAR_9->remote.window_size <= VAR_9->read_avail) {\n                /* COMMENT_56 */\n                                                            \n                              \n                   \n                _libssh2_error(VAR_0,\n                               VAR_45,\n                               \"The current receive window is full,\"\n                               \" data ignored\");\n                LIBSSH2_FREE(VAR_0, VAR_1);\n                VAR_0->packAdd_state = VAR_12;\n                return 0;\n            }\n            /* COMMENT_60 */\n            VAR_9->remote.eof = 0;\n\n            if(VAR_9->read_avail + VAR_2 - VAR_10 >\n                VAR_9->remote.window_size) {\n                _libssh2_error(VAR_0,\n                               VAR_45,\n                               \"Remote sent more data than current \"\n                               \"window allows, truncating\");\n                VAR_2 = VAR_9->remote.window_size -\n                    VAR_9->read_avail + VAR_10;\n            }\n\n            /* COMMENT_61 */\n                                                                    \n                                     \n            VAR_9->read_avail += VAR_2 - VAR_10;\n\n            _libssh2_debug(VAR_0, VAR_34,\n                           \"increasing read_avail by %lu bytes to %lu/%lu\",\n                           (long)(VAR_2 - VAR_10),\n                           (long)VAR_9->read_avail,\n                           (long)VAR_9->remote.window_size);\n\n            break;\n\n            /* COMMENT_64 */\n                                           \n                                         \n              \n\n        case VAR_46:\n            if(VAR_2 >= 5)\n                VAR_9 =\n                    _libssh2_channel_locate(VAR_0,\n                                            _libssh2_ntohu32(VAR_1 + 1));\n            if(!VAR_9)\n                /* COMMENT_68 */\n                ;\n            else {\n                _libssh2_debug(VAR_0,\n                               VAR_34,\n                               \"EOF received for channel %lu/%lu\",\n                               VAR_9->local.id,\n                               VAR_9->remote.id);\n                VAR_9->remote.eof = 1;\n            }\n            LIBSSH2_FREE(VAR_0, VAR_1);\n            VAR_0->packAdd_state = VAR_12;\n            return 0;\n\n            /* COMMENT_69 */\n                                               \n                                         \n                                                                \n                                  \n                                                  \n              \n\n        case VAR_47:\n            if(VAR_2 >= 9) {\n                uint32_t VAR_48 = _libssh2_ntohu32(VAR_1 + 1);\n                uint32_t VAR_31 = _libssh2_ntohu32(VAR_1 + 5);\n                unsigned char VAR_32 = 1;\n\n                if((VAR_31 + 9) < VAR_2)\n                    VAR_32 = VAR_1[VAR_31 + 9];\n\n                _libssh2_debug(VAR_0,\n                               VAR_34,\n                               \"Channel %d received request type %.*s (wr %X)\",\n                               VAR_48, VAR_31, VAR_1 + 9, VAR_32);\n\n                if(VAR_31 == sizeof(\"exit-status\") - 1\n                    && (sizeof(\"exit-status\") - 1 + 9) <= VAR_2\n                    && !memcmp(\"exit-status\", VAR_1 + 9,\n                               sizeof(\"exit-status\") - 1)) {\n\n                    /* COMMENT_76 */\n                    if(VAR_2 >= 20)\n                        VAR_9 =\n                            _libssh2_channel_locate(VAR_0, VAR_48);\n\n                    if(VAR_9 && (sizeof(\"exit-status\") + 13) <= VAR_2) {\n                        VAR_9->exit_status =\n                            _libssh2_ntohu32(VAR_1 + 9 + sizeof(\"exit-status\"));\n                        _libssh2_debug(VAR_0, VAR_34,\n                                       \"Exit status %lu received for \"\n                                       \"channel %lu/%lu\",\n                                       VAR_9->exit_status,\n                                       VAR_9->local.id,\n                                       VAR_9->remote.id);\n                    }\n\n                }\n                else if(VAR_31 == sizeof(\"exit-signal\") - 1\n                         && (sizeof(\"exit-signal\") - 1 + 9) <= VAR_2\n                         && !memcmp(\"exit-signal\", VAR_1 + 9,\n                                    sizeof(\"exit-signal\") - 1)) {\n                    /* COMMENT_77 */\n                    if(VAR_2 >= 20)\n                        VAR_9 = _libssh2_channel_locate(VAR_0, VAR_48);\n\n                    if(VAR_9 && (sizeof(\"exit-signal\") + 13) <= VAR_2) {\n                        /* COMMENT_78 */\n                        uint32_t VAR_49 =\n                            _libssh2_ntohu32(VAR_1 + 9 + sizeof(\"exit-signal\"));\n\n                        if(VAR_49 <= VAR_33 - 1) {\n                            VAR_9->exit_signal =\n                                LIBSSH2_ALLOC(VAR_0, VAR_49 + 1);\n                        }\n                        else {\n                            VAR_9->exit_signal = NULL;\n                        }\n\n                        if(!VAR_9->exit_signal)\n                            VAR_4 = _libssh2_error(VAR_0, VAR_50,\n                                                \"memory for signal name\");\n                        else if((sizeof(\"exit-signal\") + 13 + VAR_49 <=\n                                 VAR_2)) {\n                            memcpy(VAR_9->exit_signal,\n                                   VAR_1 + 13 + sizeof(\"exit-signal\"), VAR_49);\n                            VAR_9->exit_signal[VAR_49] = '\\0';\n                            /* COMMENT_79 */\n                            _libssh2_debug(VAR_0, VAR_34,\n                                           \"Exit signal %s received for \"\n                                           \"channel %lu/%lu\",\n                                           VAR_9->exit_signal,\n                                           VAR_9->local.id,\n                                           VAR_9->remote.id);\n                        }\n                    }\n                }\n\n\n                if(VAR_32) {\n                    unsigned char VAR_35[5];\n                  libssh2_packet_add_jump_point4:\n                    VAR_0->packAdd_state = VAR_20;\n                    VAR_35[0] = VAR_51;\n                    memcpy(&VAR_35[1], VAR_1 + 1, 4);\n                    VAR_4 = _libssh2_transport_send(VAR_0, VAR_35, 5, NULL, 0);\n                    if(VAR_4 == VAR_37)\n                        return VAR_4;\n                }\n            }\n            LIBSSH2_FREE(VAR_0, VAR_1);\n            VAR_0->packAdd_state = VAR_12;\n            return VAR_4;\n\n            /* COMMENT_80 */\n                                             \n                                         \n              \n\n        case VAR_52:\n            if(VAR_2 >= 5)\n                VAR_9 =\n                    _libssh2_channel_locate(VAR_0,\n                                            _libssh2_ntohu32(VAR_1 + 1));\n            if(!VAR_9) {\n                /* COMMENT_68 */\n                LIBSSH2_FREE(VAR_0, VAR_1);\n                VAR_0->packAdd_state = VAR_12;\n                return 0;\n            }\n            _libssh2_debug(VAR_0, VAR_34,\n                           \"Close received for channel %lu/%lu\",\n                           VAR_9->local.id,\n                           VAR_9->remote.id);\n\n            VAR_9->remote.close = 1;\n            VAR_9->remote.eof = 1;\n\n            LIBSSH2_FREE(VAR_0, VAR_1);\n            VAR_0->packAdd_state = VAR_12;\n            return 0;\n\n            /* COMMENT_84 */\n                                            \n                                 \n                                      \n                                           \n                                           \n              \n\n        case VAR_53:\n            if(VAR_2 < 17)\n                ;\n            else if((VAR_2 >= (sizeof(\"forwarded-tcpip\") + 4)) &&\n                     ((sizeof(\"forwarded-tcpip\") - 1) ==\n                      _libssh2_ntohu32(VAR_1 + 1))\n                     &&\n                     (memcmp(VAR_1 + 5, \"forwarded-tcpip\",\n                             sizeof(\"forwarded-tcpip\") - 1) == 0)) {\n\n                /* COMMENT_91 */\n                memset(&VAR_0->packAdd_Qlstn_state, 0,\n                       sizeof(VAR_0->packAdd_Qlstn_state));\n\n              libssh2_packet_add_jump_point2:\n                VAR_0->packAdd_state = VAR_18;\n                VAR_4 = packet_queue_listener(VAR_0, VAR_1, VAR_2,\n                                           &VAR_0->packAdd_Qlstn_state);\n            }\n            else if((VAR_2 >= (sizeof(\"x11\") + 4)) &&\n                     ((sizeof(\"x11\") - 1) == _libssh2_ntohu32(VAR_1 + 1)) &&\n                     (memcmp(VAR_1 + 5, \"x11\", sizeof(\"x11\") - 1) == 0)) {\n\n                /* COMMENT_91 */\n                memset(&VAR_0->packAdd_x11open_state, 0,\n                       sizeof(VAR_0->packAdd_x11open_state));\n\n              libssh2_packet_add_jump_point3:\n                VAR_0->packAdd_state = VAR_19;\n                VAR_4 = packet_x11_open(VAR_0, VAR_1, VAR_2,\n                                     &VAR_0->packAdd_x11open_state);\n            }\n            if(VAR_4 == VAR_37)\n                return VAR_4;\n\n            LIBSSH2_FREE(VAR_0, VAR_1);\n            VAR_0->packAdd_state = VAR_12;\n            return VAR_4;\n\n            /* COMMENT_92 */\n                                                     \n                                         \n                                    \n              \n        case VAR_54:\n            if(VAR_2 < 9)\n                ;\n            else {\n                uint32_t VAR_55 = _libssh2_ntohu32(VAR_1 + 5);\n                VAR_9 =\n                    _libssh2_channel_locate(VAR_0,\n                                            _libssh2_ntohu32(VAR_1 + 1));\n                if(VAR_9) {\n                    VAR_9->local.window_size += VAR_55;\n\n                    _libssh2_debug(VAR_0, VAR_34,\n                                   \"Window adjust for channel %lu/%lu, \"\n                                   \"adding %lu bytes, new window_size=%lu\",\n                                   VAR_9->local.id,\n                                   VAR_9->remote.id,\n                                   VAR_55,\n                                   VAR_9->local.window_size);\n                }\n            }\n            LIBSSH2_FREE(VAR_0, VAR_1);\n            VAR_0->packAdd_state = VAR_12;\n            return 0;\n        default:\n            break;\n        }\n\n        VAR_0->packAdd_state = VAR_56;\n    }\n\n    if(VAR_0->packAdd_state == VAR_56) {\n        LIBSSH2_PACKET *VAR_57 =\n            LIBSSH2_ALLOC(VAR_0, sizeof(LIBSSH2_PACKET));\n        if(!VAR_57) {\n            _libssh2_debug(VAR_0, VAR_50,\n                           \"memory for packet\");\n            LIBSSH2_FREE(VAR_0, VAR_1);\n            VAR_0->packAdd_state = VAR_12;\n            return VAR_50;\n        }\n        VAR_57->data = VAR_1;\n        VAR_57->data_len = VAR_2;\n        VAR_57->data_head = VAR_10;\n\n        _libssh2_list_add(&VAR_0->packets, &VAR_57->node);\n\n        VAR_0->packAdd_state = VAR_58;\n    }\n\n    if((VAR_11 == VAR_59 &&\n         !(VAR_0->state & VAR_60)) ||\n        (VAR_0->packAdd_state == VAR_61)) {\n        if(VAR_0->packAdd_state == VAR_58) {\n            /* COMMENT_97 */\n                                    \n                                                 \n                                                  \n               \n            _libssh2_debug(VAR_0, VAR_13, \"Renegotiating Keys\");\n\n            VAR_0->packAdd_state = VAR_61;\n        }\n\n        /* COMMENT_102 */\n                                                                            \n                                                                         \n                                                                              \n                                         \n           \n        VAR_0->readPack_state = VAR_12;\n        VAR_0->packet.total_num = 0;\n        VAR_0->packAdd_state = VAR_12;\n        VAR_0->fullpacket_state = VAR_12;\n\n        memset(&VAR_0->startup_key_state, 0, sizeof(VAR_62));\n\n        /* COMMENT_108 */\n                                                                           \n                                                                      \n           \n        VAR_4 = _libssh2_kex_exchange(VAR_0, 1, &VAR_0->startup_key_state);\n        if(VAR_4 == VAR_37)\n            return VAR_4;\n    }\n\n    VAR_0->packAdd_state = VAR_12;\n    return 0;\n}",
  "func_graph_path": "libssh2/dedcbd106f8e52d5586b0205bc7677e4c9868f9c/packet.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -3,8 +3,8 @@\n                     size_t datalen, int macstate)\n {\n     int rc = 0;\n-    char *message = NULL;\n-    char *language = NULL;\n+    unsigned char *message = NULL;\n+    unsigned char *language = NULL;\n     size_t message_len = 0;\n     size_t language_len = 0;\n     LIBSSH2_CHANNEL *channelp = NULL;\n@@ -56,33 +56,23 @@\n \n         case SSH_MSG_DISCONNECT:\n             if(datalen >= 5) {\n-                size_t reason = _libssh2_ntohu32(data + 1);\n-\n-                if(datalen >= 9) {\n-                    message_len = _libssh2_ntohu32(data + 5);\n-\n-                    if(message_len < datalen-13) {\n-                        /* 9 = packet_type(1) + reason(4) + message_len(4) */\n-                        message = (char *) data + 9;\n-\n-                        language_len =\n-                            _libssh2_ntohu32(data + 9 + message_len);\n-                        language = (char *) data + 9 + message_len + 4;\n-\n-                        if(language_len > (datalen-13-message_len)) {\n-                            /* bad input, clear info */\n-                            language = message = NULL;\n-                            language_len = message_len = 0;\n-                        }\n-                    }\n-                    else\n-                        /* bad size, clear it */\n-                        message_len = 0;\n-                }\n+                uint32_t reason = 0;\n+                struct string_buf buf;\n+                buf.data = (unsigned char *)data;\n+                buf.dataptr = buf.data;\n+                buf.len = datalen;\n+                buf.dataptr++; /* advance past type */\n+\n+                _libssh2_get_u32(&buf, &reason);\n+                _libssh2_get_string(&buf, &message, &message_len);\n+                _libssh2_get_string(&buf, &language, &language_len);\n+\n                 if(session->ssh_msg_disconnect) {\n-                    LIBSSH2_DISCONNECT(session, reason, message,\n-                                       message_len, language, language_len);\n-                }\n+                    LIBSSH2_DISCONNECT(session, reason, (const char *)message,\n+                                       message_len, (const char *)language,\n+                                       language_len);\n+                }\n+\n                 _libssh2_debug(session, LIBSSH2_TRACE_TRANS,\n                                \"Disconnect(%d): %s(%s)\", reason,\n                                message, language);\n@@ -123,24 +113,24 @@\n                 int always_display = data[1];\n \n                 if(datalen >= 6) {\n-                    message_len = _libssh2_ntohu32(data + 2);\n-\n-                    if(message_len <= (datalen - 10)) {\n-                        /* 6 = packet_type(1) + display(1) + message_len(4) */\n-                        message = (char *) data + 6;\n-                        language_len = _libssh2_ntohu32(data + 6 +\n-                                                        message_len);\n-\n-                        if(language_len <= (datalen - 10 - message_len))\n-                            language = (char *) data + 10 + message_len;\n-                    }\n+                    struct string_buf buf;\n+                    buf.data = (unsigned char *)data;\n+                    buf.dataptr = buf.data;\n+                    buf.len = datalen;\n+                    buf.dataptr += 2; /* advance past type & always display */\n+\n+                    _libssh2_get_string(&buf, &message, &message_len);\n+                    _libssh2_get_string(&buf, &language, &language_len);\n                 }\n \n                 if(session->ssh_msg_debug) {\n-                    LIBSSH2_DEBUG(session, always_display, message,\n-                                  message_len, language, language_len);\n-                }\n-            }\n+                    LIBSSH2_DEBUG(session, always_display,\n+                                  (const char *)message,\n+                                  message_len, (const char *)language,\n+                                  language_len);\n+                }\n+            }\n+\n             /*\n              * _libssh2_debug will actually truncate this for us so\n              * that it's not an inordinate about of data\n@@ -163,7 +153,7 @@\n                 uint32_t len = 0;\n                 unsigned char want_reply = 0;\n                 len = _libssh2_ntohu32(data + 1);\n-                if(datalen >= (6 + len)) {\n+                if((len <= (UINT_MAX - 6)) && (datalen >= (6 + len))) {\n                     want_reply = data[5 + len];\n                     _libssh2_debug(session,\n                                    LIBSSH2_TRACE_CONN,",
  "diff_line_info": {
    "deleted_lines": [
      "    char *message = NULL;",
      "    char *language = NULL;",
      "                size_t reason = _libssh2_ntohu32(data + 1);",
      "",
      "                if(datalen >= 9) {",
      "                    message_len = _libssh2_ntohu32(data + 5);",
      "",
      "                    if(message_len < datalen-13) {",
      "                        /* 9 = packet_type(1) + reason(4) + message_len(4) */",
      "                        message = (char *) data + 9;",
      "",
      "                        language_len =",
      "                            _libssh2_ntohu32(data + 9 + message_len);",
      "                        language = (char *) data + 9 + message_len + 4;",
      "",
      "                        if(language_len > (datalen-13-message_len)) {",
      "                            /* bad input, clear info */",
      "                            language = message = NULL;",
      "                            language_len = message_len = 0;",
      "                        }",
      "                    }",
      "                    else",
      "                        /* bad size, clear it */",
      "                        message_len = 0;",
      "                }",
      "                    LIBSSH2_DISCONNECT(session, reason, message,",
      "                                       message_len, language, language_len);",
      "                }",
      "                    message_len = _libssh2_ntohu32(data + 2);",
      "",
      "                    if(message_len <= (datalen - 10)) {",
      "                        /* 6 = packet_type(1) + display(1) + message_len(4) */",
      "                        message = (char *) data + 6;",
      "                        language_len = _libssh2_ntohu32(data + 6 +",
      "                                                        message_len);",
      "",
      "                        if(language_len <= (datalen - 10 - message_len))",
      "                            language = (char *) data + 10 + message_len;",
      "                    }",
      "                    LIBSSH2_DEBUG(session, always_display, message,",
      "                                  message_len, language, language_len);",
      "                }",
      "            }",
      "                if(datalen >= (6 + len)) {"
    ],
    "added_lines": [
      "    unsigned char *message = NULL;",
      "    unsigned char *language = NULL;",
      "                uint32_t reason = 0;",
      "                struct string_buf buf;",
      "                buf.data = (unsigned char *)data;",
      "                buf.dataptr = buf.data;",
      "                buf.len = datalen;",
      "                buf.dataptr++; /* advance past type */",
      "",
      "                _libssh2_get_u32(&buf, &reason);",
      "                _libssh2_get_string(&buf, &message, &message_len);",
      "                _libssh2_get_string(&buf, &language, &language_len);",
      "",
      "                    LIBSSH2_DISCONNECT(session, reason, (const char *)message,",
      "                                       message_len, (const char *)language,",
      "                                       language_len);",
      "                }",
      "",
      "                    struct string_buf buf;",
      "                    buf.data = (unsigned char *)data;",
      "                    buf.dataptr = buf.data;",
      "                    buf.len = datalen;",
      "                    buf.dataptr += 2; /* advance past type & always display */",
      "",
      "                    _libssh2_get_string(&buf, &message, &message_len);",
      "                    _libssh2_get_string(&buf, &language, &language_len);",
      "                    LIBSSH2_DEBUG(session, always_display,",
      "                                  (const char *)message,",
      "                                  message_len, (const char *)language,",
      "                                  language_len);",
      "                }",
      "            }",
      "",
      "                if((len <= (UINT_MAX - 6)) && (datalen >= (6 + len))) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libssh2/libssh2/pull/402",
  "description": {
    "pr_info": {
      "title": "packet.c: improve message parsing",
      "number": 402
    },
    "comment": [
      "file: packet.c\r\n\r\nnotes:\r\nUse _libssh2_get_string API in SSH_MSG_DEBUG, additional uint32 bounds check in SSH_MSG_GLOBAL_REQUEST"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95"
}