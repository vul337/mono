{
  "cve_id": "CVE-2020-13921",
  "cwe_ids": [
    "CWE-89"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "apache/skywalking",
  "commit_msg": "fix fuzzy query sql injection",
  "commit_hash": "ddb6d9a5019a9c1fe31c364485a4e4b5066fefc3",
  "git_url": "https://github.com/apache/skywalking/commit/ddb6d9a5019a9c1fe31c364485a4e4b5066fefc3",
  "file_path": "oap-server/server-storage-plugin/storage-jdbc-hikaricp-plugin/src/main/java/org/apache/skywalking/oap/server/storage/plugin/jdbc/h2/dao/H2AlarmQueryDAO.java",
  "func_name": "getAlarm",
  "func_before": "@Override\n    public Alarms getAlarm(Integer scopeId, String keyword, int limit, int from, long startTB,\n        long endTB) throws IOException {\n        StringBuilder sql = new StringBuilder();\n        List<Object> parameters = new ArrayList<>(10);\n        sql.append(\"from \").append(AlarmRecord.INDEX_NAME).append(\" where \");\n        sql.append(\" 1=1 \");\n        if (Objects.nonNull(scopeId)) {\n            sql.append(\" and \").append(AlarmRecord.SCOPE).append(\" = ?\");\n            parameters.add(scopeId.intValue());\n        }\n        if (startTB != 0 && endTB != 0) {\n            sql.append(\" and \").append(AlarmRecord.TIME_BUCKET).append(\" >= ?\");\n            parameters.add(startTB);\n            sql.append(\" and \").append(AlarmRecord.TIME_BUCKET).append(\" <= ?\");\n            parameters.add(endTB);\n        }\n\n        if (!Strings.isNullOrEmpty(keyword)) {\n            sql.append(\" and \").append(AlarmRecord.ALARM_MESSAGE).append(\" like '%\").append(keyword).append(\"%' \");\n        }\n        sql.append(\" order by \").append(AlarmRecord.START_TIME).append(\" desc \");\n\n        Alarms alarms = new Alarms();\n        try (Connection connection = client.getConnection()) {\n\n            try (ResultSet resultSet = client.executeQuery(connection, \"select count(1) total from (select 1 \" + sql.toString() + \" )\", parameters\n                .toArray(new Object[0]))) {\n                while (resultSet.next()) {\n                    alarms.setTotal(resultSet.getInt(\"total\"));\n                }\n            }\n\n            this.buildLimit(sql, from, limit);\n\n            try (ResultSet resultSet = client.executeQuery(connection, \"select * \" + sql.toString(), parameters.toArray(new Object[0]))) {\n                while (resultSet.next()) {\n                    AlarmMessage message = new AlarmMessage();\n                    message.setId(resultSet.getString(AlarmRecord.ID0));\n                    message.setMessage(resultSet.getString(AlarmRecord.ALARM_MESSAGE));\n                    message.setStartTime(resultSet.getLong(AlarmRecord.START_TIME));\n                    message.setScope(Scope.Finder.valueOf(resultSet.getInt(AlarmRecord.SCOPE)));\n                    message.setScopeId(resultSet.getInt(AlarmRecord.SCOPE));\n\n                    alarms.getMsgs().add(message);\n                }\n            }\n        } catch (SQLException e) {\n            throw new IOException(e);\n        }\n\n        return alarms;\n    }",
  "abstract_func_before": "@Override\n    public Alarms getAlarm(Integer VAR_0, String VAR_1, int VAR_2, int VAR_3, long VAR_4,\n        long VAR_5) throws IOException {\n        StringBuilder VAR_6 = new StringBuilder();\n        List<Object> VAR_7 = new ArrayList<>(10);\n        VAR_6.append(\"from \").append(VAR_8.INDEX_NAME).append(\" where \");\n        VAR_6.append(\" 1=1 \");\n        if (VAR_9.nonNull(VAR_0)) {\n            VAR_6.append(\" and \").append(VAR_8.SCOPE).append(\" = ?\");\n            VAR_7.add(VAR_0.intValue());\n        }\n        if (VAR_4 != 0 && VAR_5 != 0) {\n            VAR_6.append(\" and \").append(VAR_8.TIME_BUCKET).append(\" >= ?\");\n            VAR_7.add(VAR_4);\n            VAR_6.append(\" and \").append(VAR_8.TIME_BUCKET).append(\" <= ?\");\n            VAR_7.add(VAR_5);\n        }\n\n        if (!VAR_10.isNullOrEmpty(VAR_1)) {\n            VAR_6.append(\" and \").append(VAR_8.ALARM_MESSAGE).append(\" like '%\").append(VAR_1).append(\"%' \");\n        }\n        VAR_6.append(\" order by \").append(VAR_8.START_TIME).append(\" desc \");\n\n        Alarms VAR_11 = new Alarms();\n        try (Connection VAR_12 = VAR_13.getConnection()) {\n\n            try (ResultSet VAR_14 = VAR_13.executeQuery(VAR_12, \"select count(1) total from (select 1 \" + VAR_6.toString() + \" )\", VAR_7\n                .toArray(new Object[0]))) {\n                while (VAR_14.next()) {\n                    VAR_11.setTotal(VAR_14.getInt(\"total\"));\n                }\n            }\n\n            this.buildLimit(VAR_6, VAR_3, VAR_2);\n\n            try (ResultSet VAR_14 = VAR_13.executeQuery(VAR_12, \"select * \" + VAR_6.toString(), VAR_7.toArray(new Object[0]))) {\n                while (VAR_14.next()) {\n                    AlarmMessage VAR_15 = new AlarmMessage();\n                    VAR_15.setId(VAR_14.getString(VAR_8.ID0));\n                    VAR_15.setMessage(VAR_14.getString(VAR_8.ALARM_MESSAGE));\n                    VAR_15.setStartTime(VAR_14.getLong(VAR_8.START_TIME));\n                    VAR_15.setScope(VAR_16.Finder.valueOf(VAR_14.getInt(VAR_8.SCOPE)));\n                    VAR_15.setScopeId(VAR_14.getInt(VAR_8.SCOPE));\n\n                    VAR_11.getMsgs().add(VAR_15);\n                }\n            }\n        } catch (SQLException VAR_17) {\n            throw new IOException(VAR_17);\n        }\n\n        return VAR_11;\n    }",
  "func_graph_path_before": "apache/skywalking/ddb6d9a5019a9c1fe31c364485a4e4b5066fefc3/H2AlarmQueryDAO.java/vul/before/0.json",
  "func": "@Override\n    public Alarms getAlarm(Integer scopeId, String keyword, int limit, int from, long startTB,\n        long endTB) throws IOException {\n        StringBuilder sql = new StringBuilder();\n        List<Object> parameters = new ArrayList<>(10);\n        sql.append(\"from \").append(AlarmRecord.INDEX_NAME).append(\" where \");\n        sql.append(\" 1=1 \");\n        if (Objects.nonNull(scopeId)) {\n            sql.append(\" and \").append(AlarmRecord.SCOPE).append(\" = ?\");\n            parameters.add(scopeId.intValue());\n        }\n        if (startTB != 0 && endTB != 0) {\n            sql.append(\" and \").append(AlarmRecord.TIME_BUCKET).append(\" >= ?\");\n            parameters.add(startTB);\n            sql.append(\" and \").append(AlarmRecord.TIME_BUCKET).append(\" <= ?\");\n            parameters.add(endTB);\n        }\n\n        if (!Strings.isNullOrEmpty(keyword)) {\n            sql.append(\" and \").append(AlarmRecord.ALARM_MESSAGE).append(\" like concat('%',?,'%') \");\n            parameters.add(keyword);\n        }\n        sql.append(\" order by \").append(AlarmRecord.START_TIME).append(\" desc \");\n\n        Alarms alarms = new Alarms();\n        try (Connection connection = client.getConnection()) {\n\n            try (ResultSet resultSet = client.executeQuery(connection, \"select count(1) total from (select 1 \" + sql.toString() + \" )\", parameters\n                .toArray(new Object[0]))) {\n                while (resultSet.next()) {\n                    alarms.setTotal(resultSet.getInt(\"total\"));\n                }\n            }\n\n            this.buildLimit(sql, from, limit);\n\n            try (ResultSet resultSet = client.executeQuery(connection, \"select * \" + sql.toString(), parameters.toArray(new Object[0]))) {\n                while (resultSet.next()) {\n                    AlarmMessage message = new AlarmMessage();\n                    message.setId(resultSet.getString(AlarmRecord.ID0));\n                    message.setMessage(resultSet.getString(AlarmRecord.ALARM_MESSAGE));\n                    message.setStartTime(resultSet.getLong(AlarmRecord.START_TIME));\n                    message.setScope(Scope.Finder.valueOf(resultSet.getInt(AlarmRecord.SCOPE)));\n                    message.setScopeId(resultSet.getInt(AlarmRecord.SCOPE));\n\n                    alarms.getMsgs().add(message);\n                }\n            }\n        } catch (SQLException e) {\n            throw new IOException(e);\n        }\n\n        return alarms;\n    }",
  "abstract_func": "@Override\n    public Alarms getAlarm(Integer VAR_0, String VAR_1, int VAR_2, int VAR_3, long VAR_4,\n        long VAR_5) throws IOException {\n        StringBuilder VAR_6 = new StringBuilder();\n        List<Object> VAR_7 = new ArrayList<>(10);\n        VAR_6.append(\"from \").append(VAR_8.INDEX_NAME).append(\" where \");\n        VAR_6.append(\" 1=1 \");\n        if (VAR_9.nonNull(VAR_0)) {\n            VAR_6.append(\" and \").append(VAR_8.SCOPE).append(\" = ?\");\n            VAR_7.add(VAR_0.intValue());\n        }\n        if (VAR_4 != 0 && VAR_5 != 0) {\n            VAR_6.append(\" and \").append(VAR_8.TIME_BUCKET).append(\" >= ?\");\n            VAR_7.add(VAR_4);\n            VAR_6.append(\" and \").append(VAR_8.TIME_BUCKET).append(\" <= ?\");\n            VAR_7.add(VAR_5);\n        }\n\n        if (!VAR_10.isNullOrEmpty(VAR_1)) {\n            VAR_6.append(\" and \").append(VAR_8.ALARM_MESSAGE).append(\" like concat('%',?,'%') \");\n            VAR_7.add(VAR_1);\n        }\n        VAR_6.append(\" order by \").append(VAR_8.START_TIME).append(\" desc \");\n\n        Alarms VAR_11 = new Alarms();\n        try (Connection VAR_12 = VAR_13.getConnection()) {\n\n            try (ResultSet VAR_14 = VAR_13.executeQuery(VAR_12, \"select count(1) total from (select 1 \" + VAR_6.toString() + \" )\", VAR_7\n                .toArray(new Object[0]))) {\n                while (VAR_14.next()) {\n                    VAR_11.setTotal(VAR_14.getInt(\"total\"));\n                }\n            }\n\n            this.buildLimit(VAR_6, VAR_3, VAR_2);\n\n            try (ResultSet VAR_14 = VAR_13.executeQuery(VAR_12, \"select * \" + VAR_6.toString(), VAR_7.toArray(new Object[0]))) {\n                while (VAR_14.next()) {\n                    AlarmMessage VAR_15 = new AlarmMessage();\n                    VAR_15.setId(VAR_14.getString(VAR_8.ID0));\n                    VAR_15.setMessage(VAR_14.getString(VAR_8.ALARM_MESSAGE));\n                    VAR_15.setStartTime(VAR_14.getLong(VAR_8.START_TIME));\n                    VAR_15.setScope(VAR_16.Finder.valueOf(VAR_14.getInt(VAR_8.SCOPE)));\n                    VAR_15.setScopeId(VAR_14.getInt(VAR_8.SCOPE));\n\n                    VAR_11.getMsgs().add(VAR_15);\n                }\n            }\n        } catch (SQLException VAR_17) {\n            throw new IOException(VAR_17);\n        }\n\n        return VAR_11;\n    }",
  "func_graph_path": "apache/skywalking/ddb6d9a5019a9c1fe31c364485a4e4b5066fefc3/H2AlarmQueryDAO.java/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -17,7 +17,8 @@\n         }\n \n         if (!Strings.isNullOrEmpty(keyword)) {\n-            sql.append(\" and \").append(AlarmRecord.ALARM_MESSAGE).append(\" like '%\").append(keyword).append(\"%' \");\n+            sql.append(\" and \").append(AlarmRecord.ALARM_MESSAGE).append(\" like concat('%',?,'%') \");\n+            parameters.add(keyword);\n         }\n         sql.append(\" order by \").append(AlarmRecord.START_TIME).append(\" desc \");\n ",
  "diff_line_info": {
    "deleted_lines": [
      "            sql.append(\" and \").append(AlarmRecord.ALARM_MESSAGE).append(\" like '%\").append(keyword).append(\"%' \");"
    ],
    "added_lines": [
      "            sql.append(\" and \").append(AlarmRecord.ALARM_MESSAGE).append(\" like concat('%',?,'%') \");",
      "            parameters.add(keyword);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/apache/skywalking/pull/4970",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/apache/skywalking/pull/4970: 403 Client Error: Forbidden for url: https://api.github.com/repos/apache/skywalking/pulls/4970",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "Final Classification: Security Vulnerability Fix; Confidence: 1.0\n\n**Step-by-Step Explanation:**\n\n1. **Commit Message Analysis**: The message \"fix fuzzy query sql injection\" clearly indicates a security fix targeting SQL injection, a known security vulnerability.\n\n2. **Vulnerability Description**: Confirms it's a bug fix related to a specific issue, supporting the security context.\n\n3. **Code Changes**: The patch replaces unsafe string concatenation with parameterized queries, a standard security measure to prevent SQL injection.\n\n4. **Consistency Check**: All elements (commit message, issue, code) align, showing a clear security intention with no discrepancies.\n\n**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}