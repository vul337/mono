{
  "cve_id": "CVE-2023-36328",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "libtom/libtommath",
  "commit_msg": "Fix possible integer overflow",
  "commit_hash": "beba892bc0d4e4ded4d667ab1d2a94f4d75109a9",
  "git_url": "https://github.com/libtom/libtommath/commit/beba892bc0d4e4ded4d667ab1d2a94f4d75109a9",
  "file_path": "bn_mp_mul_2d.c",
  "func_name": "mp_mul_2d",
  "func_before": "mp_err mp_mul_2d(const mp_int *a, int b, mp_int *c)\n{\n   mp_digit d;\n   mp_err   err;\n\n   /* copy */\n   if (a != c) {\n      if ((err = mp_copy(a, c)) != MP_OKAY) {\n         return err;\n      }\n   }\n\n   if (c->alloc < (c->used + (b / MP_DIGIT_BIT) + 1)) {\n      if ((err = mp_grow(c, c->used + (b / MP_DIGIT_BIT) + 1)) != MP_OKAY) {\n         return err;\n      }\n   }\n\n   /* shift by as many digits in the bit count */\n   if (b >= MP_DIGIT_BIT) {\n      if ((err = mp_lshd(c, b / MP_DIGIT_BIT)) != MP_OKAY) {\n         return err;\n      }\n   }\n\n   /* shift any bit count < MP_DIGIT_BIT */\n   d = (mp_digit)(b % MP_DIGIT_BIT);\n   if (d != 0u) {\n      mp_digit *tmpc, shift, mask, r, rr;\n      int x;\n\n      /* bitmask for carries */\n      mask = ((mp_digit)1 << d) - (mp_digit)1;\n\n      /* shift for msbs */\n      shift = (mp_digit)MP_DIGIT_BIT - d;\n\n      /* alias */\n      tmpc = c->dp;\n\n      /* carry */\n      r    = 0;\n      for (x = 0; x < c->used; x++) {\n         /* get the higher bits of the current word */\n         rr = (*tmpc >> shift) & mask;\n\n         /* shift the current word and OR in the carry */\n         *tmpc = ((*tmpc << d) | r) & MP_MASK;\n         ++tmpc;\n\n         /* set the carry to the carry bits of the current word */\n         r = rr;\n      }\n\n      /* set final carry */\n      if (r != 0u) {\n         c->dp[(c->used)++] = r;\n      }\n   }\n   mp_clamp(c);\n   return MP_OKAY;\n}",
  "abstract_func_before": "mp_err mp_mul_2d(const mp_int *VAR_0, int VAR_1, mp_int *VAR_2)\n{\n   mp_digit VAR_3;\n   mp_err   VAR_4;\n\n   /* COMMENT_0 */\n   if (VAR_0 != VAR_2) {\n      if ((VAR_4 = mp_copy(VAR_0, VAR_2)) != VAR_5) {\n         return VAR_4;\n      }\n   }\n\n   if (VAR_2->alloc < (VAR_2->used + (VAR_1 / VAR_6) + 1)) {\n      if ((VAR_4 = mp_grow(VAR_2, VAR_2->used + (VAR_1 / VAR_6) + 1)) != VAR_5) {\n         return VAR_4;\n      }\n   }\n\n   /* COMMENT_1 */\n   if (VAR_1 >= VAR_6) {\n      if ((VAR_4 = mp_lshd(VAR_2, VAR_1 / VAR_6)) != VAR_5) {\n         return VAR_4;\n      }\n   }\n\n   /* COMMENT_2 */\n   VAR_3 = (mp_digit)(VAR_1 % VAR_6);\n   if (VAR_3 != 0u) {\n      mp_digit *VAR_7, VAR_8, VAR_9, VAR_10, VAR_11;\n      int VAR_12;\n\n      /* COMMENT_3 */\n      VAR_9 = ((mp_digit)1 << VAR_3) - (mp_digit)1;\n\n      /* COMMENT_4 */\n      VAR_8 = (mp_digit)VAR_6 - VAR_3;\n\n      /* COMMENT_5 */\n      VAR_7 = VAR_2->dp;\n\n      /* COMMENT_6 */\n      VAR_10    = 0;\n      for (VAR_12 = 0; VAR_12 < VAR_2->used; VAR_12++) {\n         /* COMMENT_7 */\n         VAR_11 = (*VAR_7 >> VAR_8) & VAR_9;\n\n         /* COMMENT_8 */\n         *VAR_7 = ((*VAR_7 << VAR_3) | VAR_10) & VAR_13;\n         ++VAR_7;\n\n         /* COMMENT_9 */\n         VAR_10 = VAR_11;\n      }\n\n      /* COMMENT_10 */\n      if (VAR_10 != 0u) {\n         VAR_2->dp[(VAR_2->used)++] = VAR_10;\n      }\n   }\n   mp_clamp(VAR_2);\n   return VAR_5;\n}",
  "func_graph_path_before": "libtom/libtommath/beba892bc0d4e4ded4d667ab1d2a94f4d75109a9/bn_mp_mul_2d.c/vul/before/0.json",
  "func": "mp_err mp_mul_2d(const mp_int *a, int b, mp_int *c)\n{\n   mp_digit d;\n   mp_err   err;\n\n   if (b < 0) {\n      return MP_VAL;\n   }\n\n   /* copy */\n   if (a != c) {\n      if ((err = mp_copy(a, c)) != MP_OKAY) {\n         return err;\n      }\n   }\n\n   if (c->alloc < (c->used + (b / MP_DIGIT_BIT) + 1)) {\n      if ((err = mp_grow(c, c->used + (b / MP_DIGIT_BIT) + 1)) != MP_OKAY) {\n         return err;\n      }\n   }\n\n   /* shift by as many digits in the bit count */\n   if (b >= MP_DIGIT_BIT) {\n      if ((err = mp_lshd(c, b / MP_DIGIT_BIT)) != MP_OKAY) {\n         return err;\n      }\n   }\n\n   /* shift any bit count < MP_DIGIT_BIT */\n   d = (mp_digit)(b % MP_DIGIT_BIT);\n   if (d != 0u) {\n      mp_digit *tmpc, shift, mask, r, rr;\n      int x;\n\n      /* bitmask for carries */\n      mask = ((mp_digit)1 << d) - (mp_digit)1;\n\n      /* shift for msbs */\n      shift = (mp_digit)MP_DIGIT_BIT - d;\n\n      /* alias */\n      tmpc = c->dp;\n\n      /* carry */\n      r    = 0;\n      for (x = 0; x < c->used; x++) {\n         /* get the higher bits of the current word */\n         rr = (*tmpc >> shift) & mask;\n\n         /* shift the current word and OR in the carry */\n         *tmpc = ((*tmpc << d) | r) & MP_MASK;\n         ++tmpc;\n\n         /* set the carry to the carry bits of the current word */\n         r = rr;\n      }\n\n      /* set final carry */\n      if (r != 0u) {\n         c->dp[(c->used)++] = r;\n      }\n   }\n   mp_clamp(c);\n   return MP_OKAY;\n}",
  "abstract_func": "mp_err mp_mul_2d(const mp_int *VAR_0, int VAR_1, mp_int *VAR_2)\n{\n   mp_digit VAR_3;\n   mp_err   VAR_4;\n\n   if (VAR_1 < 0) {\n      return VAR_5;\n   }\n\n   /* COMMENT_0 */\n   if (VAR_0 != VAR_2) {\n      if ((VAR_4 = mp_copy(VAR_0, VAR_2)) != VAR_6) {\n         return VAR_4;\n      }\n   }\n\n   if (VAR_2->alloc < (VAR_2->used + (VAR_1 / VAR_7) + 1)) {\n      if ((VAR_4 = mp_grow(VAR_2, VAR_2->used + (VAR_1 / VAR_7) + 1)) != VAR_6) {\n         return VAR_4;\n      }\n   }\n\n   /* COMMENT_1 */\n   if (VAR_1 >= VAR_7) {\n      if ((VAR_4 = mp_lshd(VAR_2, VAR_1 / VAR_7)) != VAR_6) {\n         return VAR_4;\n      }\n   }\n\n   /* COMMENT_2 */\n   VAR_3 = (mp_digit)(VAR_1 % VAR_7);\n   if (VAR_3 != 0u) {\n      mp_digit *VAR_8, VAR_9, VAR_10, VAR_11, VAR_12;\n      int VAR_13;\n\n      /* COMMENT_3 */\n      VAR_10 = ((mp_digit)1 << VAR_3) - (mp_digit)1;\n\n      /* COMMENT_4 */\n      VAR_9 = (mp_digit)VAR_7 - VAR_3;\n\n      /* COMMENT_5 */\n      VAR_8 = VAR_2->dp;\n\n      /* COMMENT_6 */\n      VAR_11    = 0;\n      for (VAR_13 = 0; VAR_13 < VAR_2->used; VAR_13++) {\n         /* COMMENT_7 */\n         VAR_12 = (*VAR_8 >> VAR_9) & VAR_10;\n\n         /* COMMENT_8 */\n         *VAR_8 = ((*VAR_8 << VAR_3) | VAR_11) & VAR_14;\n         ++VAR_8;\n\n         /* COMMENT_9 */\n         VAR_11 = VAR_12;\n      }\n\n      /* COMMENT_10 */\n      if (VAR_11 != 0u) {\n         VAR_2->dp[(VAR_2->used)++] = VAR_11;\n      }\n   }\n   mp_clamp(VAR_2);\n   return VAR_6;\n}",
  "func_graph_path": "libtom/libtommath/beba892bc0d4e4ded4d667ab1d2a94f4d75109a9/bn_mp_mul_2d.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -2,6 +2,10 @@\n {\n    mp_digit d;\n    mp_err   err;\n+\n+   if (b < 0) {\n+      return MP_VAL;\n+   }\n \n    /* copy */\n    if (a != c) {",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "",
      "   if (b < 0) {",
      "      return MP_VAL;",
      "   }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libtom/libtommath/pull/546",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/libtom/libtommath/pull/546: 403 Client Error: Forbidden for url: https://api.github.com/repos/libtom/libtommath/pulls/546",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Output:**\n**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}