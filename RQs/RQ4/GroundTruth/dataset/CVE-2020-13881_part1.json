{
  "cve_id": "CVE-2020-13881",
  "cwe_ids": [
    "CWE-532"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:N/A:N",
  "cvss_is_v3": false,
  "repo_name": "kravietz/pam_tacplus",
  "commit_msg": "pam: don't leak TACACS+ secret to journald\n\nIf journald for syslog is used, the journal is going to store everything,\neven DEBUG loglevel messages. Pre-journald logging of system-wide DEBUG\nloglevel could be avoided and is not affected in all cases.\n\nWith journald presence it's probably safe to no longer log sensitive\ndetails at DEBUG level.\n\nFix #149\n\nSigned-off-by: Daniel Gollub <dgollub@att.com>",
  "commit_hash": "4a9852c31c2fd0c0e72fbb689a586aabcfb11cb0",
  "git_url": "https://github.com/kravietz/pam_tacplus/commit/4a9852c31c2fd0c0e72fbb689a586aabcfb11cb0",
  "file_path": "support.c",
  "func_name": "_pam_parse",
  "func_before": "int _pam_parse(int argc, const char **argv) {\n    int ctrl = 0;\n    const char *current_secret = NULL;\n\n    /* otherwise the list will grow with each call */\n    memset(tac_srv, 0, sizeof(tacplus_server_t) * TAC_PLUS_MAXSERVERS);\n    memset(&tac_srv_addr, 0, sizeof(struct addrinfo) * TAC_PLUS_MAXSERVERS);\n    memset(&tac_sock_addr, 0, sizeof(struct sockaddr) * TAC_PLUS_MAXSERVERS);\n    memset(&tac_sock6_addr, 0, sizeof(struct sockaddr_in6) * TAC_PLUS_MAXSERVERS);\n    tac_srv_no = 0;\n\n    tac_service[0] = 0;\n    tac_protocol[0] = 0;\n    tac_prompt[0] = 0;\n    tac_login[0] = 0;\n\n    for (ctrl = 0; argc-- > 0; ++argv) {\n        if (!strcmp(*argv, \"debug\")) { /* all */\n            ctrl |= PAM_TAC_DEBUG;\n        } else if (!strcmp(*argv, \"use_first_pass\")) {\n            ctrl |= PAM_TAC_USE_FIRST_PASS;\n        } else if (!strcmp(*argv, \"try_first_pass\")) {\n            ctrl |= PAM_TAC_TRY_FIRST_PASS;\n        } else if (!strncmp(*argv, \"service=\", 8)) { /* author & acct */\n            xstrcpy(tac_service, *argv + 8, sizeof(tac_service));\n        } else if (!strncmp(*argv, \"protocol=\", 9)) { /* author & acct */\n            xstrcpy(tac_protocol, *argv + 9, sizeof(tac_protocol));\n        } else if (!strncmp(*argv, \"prompt=\", 7)) { /* authentication */\n            xstrcpy(tac_prompt, *argv + 7, sizeof(tac_prompt));\n            /* Replace _ with space */\n            unsigned long chr;\n            for (chr = 0; chr < strlen(tac_prompt); chr++) {\n                if (tac_prompt[chr] == '_') {\n                    tac_prompt[chr] = ' ';\n                }\n            }\n        } else if (!strncmp(*argv, \"login=\", 6)) {\n            xstrcpy(tac_login, *argv + 6, sizeof(tac_login));\n        } else if (!strcmp(*argv, \"acct_all\")) {\n            ctrl |= PAM_TAC_ACCT;\n        } else if (!strncmp(*argv, \"server=\", 7)) { /* authen & acct */\n            if (tac_srv_no < TAC_PLUS_MAXSERVERS) {\n                struct addrinfo hints, *servers, *server;\n                int rv;\n                char *close_bracket, *server_name, *port, server_buf[256];\n\n                memset(&hints, 0, sizeof hints);\n                memset(&server_buf, 0, sizeof(server_buf));\n                hints.ai_family = AF_UNSPEC;  /* use IPv4 or IPv6, whichever */\n                hints.ai_socktype = SOCK_STREAM;\n\n                if (strlen(*argv + 7) >= sizeof(server_buf)) {\n                    _pam_log(LOG_ERR, \"server address too long, sorry\");\n                    continue;\n                }\n                strcpy(server_buf, *argv + 7);\n\n                if (*server_buf == '[' &&\n                    (close_bracket = strchr(server_buf, ']')) != NULL) { /* Check for URI syntax */\n                    server_name = server_buf + 1;\n                    _pam_log (LOG_ERR,\n                        \"reading server address as: %s \",\n                        server_name);\n                    port = strchr(close_bracket, ':');\n                    *close_bracket = '\\0';\n                } else { /* Fall back to traditional syntax */\n                    server_name = server_buf;\n                    port = strchr(server_buf, ':');\n                }\n                if (port != NULL) {\n                    *port = '\\0';\n                    port++;\n                }\n                _pam_log (LOG_DEBUG,\n                        \"sending server address to getaddrinfo as: %s \",\n                        server_name);\n                if ((rv = getaddrinfo(server_name, (port == NULL) ? \"49\" : port, &hints, &servers)) == 0) {\n                    for (server = servers;\n                         server != NULL && tac_srv_no < TAC_PLUS_MAXSERVERS; server = server->ai_next) {\n                        set_tac_srv_addr(tac_srv_no, server);\n                        set_tac_srv_key(tac_srv_no, current_secret);\n                        tac_srv_no++;\n                    }\n                    _pam_log(LOG_DEBUG, \"%s: server index %d \", __FUNCTION__, tac_srv_no);\n                    freeaddrinfo (servers);\n                } else {\n                    _pam_log(LOG_ERR,\n                             \"skip invalid server: %s (getaddrinfo: %s)\",\n                             server_name, gai_strerror(rv));\n                }\n            } else {\n                _pam_log(LOG_ERR, \"maximum number of servers (%d) exceeded, skipping\",\n                         TAC_PLUS_MAXSERVERS);\n            }\n        } else if (!strncmp(*argv, \"secret=\", 7)) {\n            current_secret = *argv + 7;     /* points right into argv (which is const) */\n\n            // this is possible because server structure is initialized only on the server= occurence\n            if (tac_srv_no == 0) {\n                _pam_log(LOG_ERR, \"secret set but no servers configured yet\");\n            } else {\n                // set secret for the last server configured\n                set_tac_srv_key(tac_srv_no - 1, current_secret);\n            }\n        } else if (!strncmp(*argv, \"timeout=\", 8)) {\n\n#ifdef HAVE_STRTOL\n            tac_timeout = strtol(*argv + 8, NULL, 10);\n\n#else\n            tac_timeout = atoi(*argv + 8);\n#endif\n            if (tac_timeout == LONG_MAX) {\n                _pam_log(LOG_ERR, \"timeout parameter cannot be parsed as integer: %s\", *argv);\n                tac_timeout = 0;\n            } else {\n                tac_readtimeout_enable = 1;\n            }\n        } else {\n            _pam_log(LOG_WARNING, \"unrecognized option: %s\", *argv);\n        }\n    }\n\n    if (ctrl & PAM_TAC_DEBUG) {\n        unsigned long n;\n\n        _pam_log(LOG_DEBUG, \"%d servers defined\", tac_srv_no);\n\n        for (n = 0; n < tac_srv_no; n++) {\n            _pam_log(LOG_DEBUG, \"server[%lu] { addr=%s, key='%s' }\", n, tac_ntop(tac_srv[n].addr->ai_addr),\n                     tac_srv[n].key);\n        }\n\n        _pam_log(LOG_DEBUG, \"tac_service='%s'\", tac_service);\n        _pam_log(LOG_DEBUG, \"tac_protocol='%s'\", tac_protocol);\n        _pam_log(LOG_DEBUG, \"tac_prompt='%s'\", tac_prompt);\n        _pam_log(LOG_DEBUG, \"tac_login='%s'\", tac_login);\n    }\n\n    return ctrl;\n}",
  "abstract_func_before": "int _pam_parse(int VAR_0, const char **VAR_1) {\n    int VAR_2 = 0;\n    const char *VAR_3 = NULL;\n\n    /* COMMENT_0 */\n    memset(VAR_4, 0, sizeof(VAR_5) * VAR_6);\n    memset(&VAR_7, 0, sizeof(struct addrinfo) * VAR_6);\n    memset(&VAR_8, 0, sizeof(struct sockaddr) * VAR_6);\n    memset(&VAR_9, 0, sizeof(struct sockaddr_in6) * VAR_6);\n    VAR_10 = 0;\n\n    VAR_11[0] = 0;\n    VAR_12[0] = 0;\n    VAR_13[0] = 0;\n    VAR_14[0] = 0;\n\n    for (VAR_2 = 0; VAR_0-- > 0; ++VAR_1) {\n        if (!strcmp(*VAR_1, \"debug\")) { /* COMMENT_1 */\n            VAR_2 |= VAR_15;\n        } else if (!strcmp(*VAR_1, \"use_first_pass\")) {\n            VAR_2 |= VAR_16;\n        } else if (!strcmp(*VAR_1, \"try_first_pass\")) {\n            VAR_2 |= VAR_17;\n        } else if (!strncmp(*VAR_1, \"service=\", 8)) { /* COMMENT_2 */\n            xstrcpy(VAR_11, *VAR_1 + 8, sizeof(VAR_11));\n        } else if (!strncmp(*VAR_1, \"protocol=\", 9)) { /* COMMENT_2 */\n            xstrcpy(VAR_12, *VAR_1 + 9, sizeof(VAR_12));\n        } else if (!strncmp(*VAR_1, \"prompt=\", 7)) { /* COMMENT_3 */\n            xstrcpy(VAR_13, *VAR_1 + 7, sizeof(VAR_13));\n            /* COMMENT_4 */\n            unsigned long VAR_18;\n            for (VAR_18 = 0; VAR_18 < strlen(VAR_13); VAR_18++) {\n                if (VAR_13[VAR_18] == '_') {\n                    VAR_13[VAR_18] = ' ';\n                }\n            }\n        } else if (!strncmp(*VAR_1, \"login=\", 6)) {\n            xstrcpy(VAR_14, *VAR_1 + 6, sizeof(VAR_14));\n        } else if (!strcmp(*VAR_1, \"acct_all\")) {\n            VAR_2 |= VAR_19;\n        } else if (!strncmp(*VAR_1, \"server=\", 7)) { /* COMMENT_5 */\n            if (VAR_10 < VAR_6) {\n                struct addrinfo VAR_20, *VAR_21, *VAR_22;\n                int VAR_23;\n                char *VAR_24, *VAR_25, *VAR_26, VAR_27[256];\n\n                memset(&VAR_20, 0, sizeof VAR_20);\n                memset(&VAR_27, 0, sizeof(VAR_27));\n                VAR_20.ai_family = VAR_28;  /* COMMENT_6 */\n                VAR_20.ai_socktype = VAR_29;\n\n                if (strlen(*VAR_1 + 7) >= sizeof(VAR_27)) {\n                    _pam_log(VAR_30, \"server address too long, sorry\");\n                    continue;\n                }\n                strcpy(VAR_27, *VAR_1 + 7);\n\n                if (*VAR_27 == '[' &&\n                    (VAR_24 = strchr(VAR_27, ']')) != NULL) { /* COMMENT_7 */\n                    VAR_25 = VAR_27 + 1;\n                    _pam_log (VAR_30,\n                        \"reading server address as: %s \",\n                        VAR_25);\n                    VAR_26 = strchr(VAR_24, ':');\n                    *VAR_24 = '\\0';\n                } else { /* COMMENT_8 */\n                    VAR_25 = VAR_27;\n                    VAR_26 = strchr(VAR_27, ':');\n                }\n                if (VAR_26 != NULL) {\n                    *VAR_26 = '\\0';\n                    VAR_26++;\n                }\n                _pam_log (VAR_31,\n                        \"sending server address to getaddrinfo as: %s \",\n                        VAR_25);\n                if ((VAR_23 = getaddrinfo(VAR_25, (VAR_26 == NULL) ? \"49\" : VAR_26, &VAR_20, &VAR_21)) == 0) {\n                    for (VAR_22 = VAR_21;\n                         VAR_22 != NULL && VAR_10 < VAR_6; VAR_22 = VAR_22->ai_next) {\n                        set_tac_srv_addr(VAR_10, VAR_22);\n                        set_tac_srv_key(VAR_10, VAR_3);\n                        VAR_10++;\n                    }\n                    _pam_log(VAR_31, \"%s: server index %d \", VAR_32, VAR_10);\n                    freeaddrinfo (VAR_21);\n                } else {\n                    _pam_log(VAR_30,\n                             \"skip invalid server: %s (getaddrinfo: %s)\",\n                             VAR_25, gai_strerror(VAR_23));\n                }\n            } else {\n                _pam_log(VAR_30, \"maximum number of servers (%d) exceeded, skipping\",\n                         VAR_6);\n            }\n        } else if (!strncmp(*VAR_1, \"secret=\", 7)) {\n            VAR_3 = *VAR_1 + 7;     /* COMMENT_9 */\n\n            /* COMMENT_10 */\n            if (VAR_10 == 0) {\n                _pam_log(VAR_30, \"secret set but no servers configured yet\");\n            } else {\n                /* COMMENT_11 */\n                set_tac_srv_key(VAR_10 - 1, VAR_3);\n            }\n        } else if (!strncmp(*VAR_1, \"timeout=\", 8)) {\n\n#ifdef VAR_33\n            VAR_34 = strtol(*VAR_1 + 8, NULL, 10);\n\n#else\n            VAR_34 = atoi(*VAR_1 + 8);\n#endif\n            if (VAR_34 == VAR_35) {\n                _pam_log(VAR_30, \"timeout parameter cannot be parsed as integer: %s\", *VAR_1);\n                VAR_34 = 0;\n            } else {\n                VAR_36 = 1;\n            }\n        } else {\n            _pam_log(VAR_37, \"unrecognized option: %s\", *VAR_1);\n        }\n    }\n\n    if (VAR_2 & VAR_15) {\n        unsigned long VAR_38;\n\n        _pam_log(VAR_31, \"%d servers defined\", VAR_10);\n\n        for (VAR_38 = 0; VAR_38 < VAR_10; VAR_38++) {\n            _pam_log(VAR_31, \"server[%lu] { addr=%s, key='%s' }\", VAR_38, tac_ntop(VAR_4[VAR_38].addr->ai_addr),\n                     VAR_4[VAR_38].key);\n        }\n\n        _pam_log(VAR_31, \"tac_service='%s'\", VAR_11);\n        _pam_log(VAR_31, \"tac_protocol='%s'\", VAR_12);\n        _pam_log(VAR_31, \"tac_prompt='%s'\", VAR_13);\n        _pam_log(VAR_31, \"tac_login='%s'\", VAR_14);\n    }\n\n    return VAR_2;\n}",
  "func_graph_path_before": "kravietz/pam_tacplus/4a9852c31c2fd0c0e72fbb689a586aabcfb11cb0/support.c/vul/before/0.json",
  "func": "int _pam_parse(int argc, const char **argv) {\n    int ctrl = 0;\n    const char *current_secret = NULL;\n\n    /* otherwise the list will grow with each call */\n    memset(tac_srv, 0, sizeof(tacplus_server_t) * TAC_PLUS_MAXSERVERS);\n    memset(&tac_srv_addr, 0, sizeof(struct addrinfo) * TAC_PLUS_MAXSERVERS);\n    memset(&tac_sock_addr, 0, sizeof(struct sockaddr) * TAC_PLUS_MAXSERVERS);\n    memset(&tac_sock6_addr, 0, sizeof(struct sockaddr_in6) * TAC_PLUS_MAXSERVERS);\n    tac_srv_no = 0;\n\n    tac_service[0] = 0;\n    tac_protocol[0] = 0;\n    tac_prompt[0] = 0;\n    tac_login[0] = 0;\n\n    for (ctrl = 0; argc-- > 0; ++argv) {\n        if (!strcmp(*argv, \"debug\")) { /* all */\n            ctrl |= PAM_TAC_DEBUG;\n        } else if (!strcmp(*argv, \"use_first_pass\")) {\n            ctrl |= PAM_TAC_USE_FIRST_PASS;\n        } else if (!strcmp(*argv, \"try_first_pass\")) {\n            ctrl |= PAM_TAC_TRY_FIRST_PASS;\n        } else if (!strncmp(*argv, \"service=\", 8)) { /* author & acct */\n            xstrcpy(tac_service, *argv + 8, sizeof(tac_service));\n        } else if (!strncmp(*argv, \"protocol=\", 9)) { /* author & acct */\n            xstrcpy(tac_protocol, *argv + 9, sizeof(tac_protocol));\n        } else if (!strncmp(*argv, \"prompt=\", 7)) { /* authentication */\n            xstrcpy(tac_prompt, *argv + 7, sizeof(tac_prompt));\n            /* Replace _ with space */\n            unsigned long chr;\n            for (chr = 0; chr < strlen(tac_prompt); chr++) {\n                if (tac_prompt[chr] == '_') {\n                    tac_prompt[chr] = ' ';\n                }\n            }\n        } else if (!strncmp(*argv, \"login=\", 6)) {\n            xstrcpy(tac_login, *argv + 6, sizeof(tac_login));\n        } else if (!strcmp(*argv, \"acct_all\")) {\n            ctrl |= PAM_TAC_ACCT;\n        } else if (!strncmp(*argv, \"server=\", 7)) { /* authen & acct */\n            if (tac_srv_no < TAC_PLUS_MAXSERVERS) {\n                struct addrinfo hints, *servers, *server;\n                int rv;\n                char *close_bracket, *server_name, *port, server_buf[256];\n\n                memset(&hints, 0, sizeof hints);\n                memset(&server_buf, 0, sizeof(server_buf));\n                hints.ai_family = AF_UNSPEC;  /* use IPv4 or IPv6, whichever */\n                hints.ai_socktype = SOCK_STREAM;\n\n                if (strlen(*argv + 7) >= sizeof(server_buf)) {\n                    _pam_log(LOG_ERR, \"server address too long, sorry\");\n                    continue;\n                }\n                strcpy(server_buf, *argv + 7);\n\n                if (*server_buf == '[' &&\n                    (close_bracket = strchr(server_buf, ']')) != NULL) { /* Check for URI syntax */\n                    server_name = server_buf + 1;\n                    _pam_log (LOG_ERR,\n                        \"reading server address as: %s \",\n                        server_name);\n                    port = strchr(close_bracket, ':');\n                    *close_bracket = '\\0';\n                } else { /* Fall back to traditional syntax */\n                    server_name = server_buf;\n                    port = strchr(server_buf, ':');\n                }\n                if (port != NULL) {\n                    *port = '\\0';\n                    port++;\n                }\n                _pam_log (LOG_DEBUG,\n                        \"sending server address to getaddrinfo as: %s \",\n                        server_name);\n                if ((rv = getaddrinfo(server_name, (port == NULL) ? \"49\" : port, &hints, &servers)) == 0) {\n                    for (server = servers;\n                         server != NULL && tac_srv_no < TAC_PLUS_MAXSERVERS; server = server->ai_next) {\n                        set_tac_srv_addr(tac_srv_no, server);\n                        set_tac_srv_key(tac_srv_no, current_secret);\n                        tac_srv_no++;\n                    }\n                    _pam_log(LOG_DEBUG, \"%s: server index %d \", __FUNCTION__, tac_srv_no);\n                    freeaddrinfo (servers);\n                } else {\n                    _pam_log(LOG_ERR,\n                             \"skip invalid server: %s (getaddrinfo: %s)\",\n                             server_name, gai_strerror(rv));\n                }\n            } else {\n                _pam_log(LOG_ERR, \"maximum number of servers (%d) exceeded, skipping\",\n                         TAC_PLUS_MAXSERVERS);\n            }\n        } else if (!strncmp(*argv, \"secret=\", 7)) {\n            current_secret = *argv + 7;     /* points right into argv (which is const) */\n\n            // this is possible because server structure is initialized only on the server= occurence\n            if (tac_srv_no == 0) {\n                _pam_log(LOG_ERR, \"secret set but no servers configured yet\");\n            } else {\n                // set secret for the last server configured\n                set_tac_srv_key(tac_srv_no - 1, current_secret);\n            }\n        } else if (!strncmp(*argv, \"timeout=\", 8)) {\n\n#ifdef HAVE_STRTOL\n            tac_timeout = strtol(*argv + 8, NULL, 10);\n\n#else\n            tac_timeout = atoi(*argv + 8);\n#endif\n            if (tac_timeout == LONG_MAX) {\n                _pam_log(LOG_ERR, \"timeout parameter cannot be parsed as integer: %s\", *argv);\n                tac_timeout = 0;\n            } else {\n                tac_readtimeout_enable = 1;\n            }\n        } else {\n            _pam_log(LOG_WARNING, \"unrecognized option: %s\", *argv);\n        }\n    }\n\n    if (ctrl & PAM_TAC_DEBUG) {\n        unsigned long n;\n\n        _pam_log(LOG_DEBUG, \"%d servers defined\", tac_srv_no);\n\n        for (n = 0; n < tac_srv_no; n++) {\n            _pam_log(LOG_DEBUG, \"server[%lu] { addr=%s, key='********' }\", n,\n\t\t\t    tac_ntop(tac_srv[n].addr->ai_addr));\n        }\n\n        _pam_log(LOG_DEBUG, \"tac_service='%s'\", tac_service);\n        _pam_log(LOG_DEBUG, \"tac_protocol='%s'\", tac_protocol);\n        _pam_log(LOG_DEBUG, \"tac_prompt='%s'\", tac_prompt);\n        _pam_log(LOG_DEBUG, \"tac_login='%s'\", tac_login);\n    }\n\n    return ctrl;\n}",
  "abstract_func": "int _pam_parse(int VAR_0, const char **VAR_1) {\n    int VAR_2 = 0;\n    const char *VAR_3 = NULL;\n\n    /* COMMENT_0 */\n    memset(VAR_4, 0, sizeof(VAR_5) * VAR_6);\n    memset(&VAR_7, 0, sizeof(struct addrinfo) * VAR_6);\n    memset(&VAR_8, 0, sizeof(struct sockaddr) * VAR_6);\n    memset(&VAR_9, 0, sizeof(struct sockaddr_in6) * VAR_6);\n    VAR_10 = 0;\n\n    VAR_11[0] = 0;\n    VAR_12[0] = 0;\n    VAR_13[0] = 0;\n    VAR_14[0] = 0;\n\n    for (VAR_2 = 0; VAR_0-- > 0; ++VAR_1) {\n        if (!strcmp(*VAR_1, \"debug\")) { /* COMMENT_1 */\n            VAR_2 |= VAR_15;\n        } else if (!strcmp(*VAR_1, \"use_first_pass\")) {\n            VAR_2 |= VAR_16;\n        } else if (!strcmp(*VAR_1, \"try_first_pass\")) {\n            VAR_2 |= VAR_17;\n        } else if (!strncmp(*VAR_1, \"service=\", 8)) { /* COMMENT_2 */\n            xstrcpy(VAR_11, *VAR_1 + 8, sizeof(VAR_11));\n        } else if (!strncmp(*VAR_1, \"protocol=\", 9)) { /* COMMENT_2 */\n            xstrcpy(VAR_12, *VAR_1 + 9, sizeof(VAR_12));\n        } else if (!strncmp(*VAR_1, \"prompt=\", 7)) { /* COMMENT_3 */\n            xstrcpy(VAR_13, *VAR_1 + 7, sizeof(VAR_13));\n            /* COMMENT_4 */\n            unsigned long VAR_18;\n            for (VAR_18 = 0; VAR_18 < strlen(VAR_13); VAR_18++) {\n                if (VAR_13[VAR_18] == '_') {\n                    VAR_13[VAR_18] = ' ';\n                }\n            }\n        } else if (!strncmp(*VAR_1, \"login=\", 6)) {\n            xstrcpy(VAR_14, *VAR_1 + 6, sizeof(VAR_14));\n        } else if (!strcmp(*VAR_1, \"acct_all\")) {\n            VAR_2 |= VAR_19;\n        } else if (!strncmp(*VAR_1, \"server=\", 7)) { /* COMMENT_5 */\n            if (VAR_10 < VAR_6) {\n                struct addrinfo VAR_20, *VAR_21, *VAR_22;\n                int VAR_23;\n                char *VAR_24, *VAR_25, *VAR_26, VAR_27[256];\n\n                memset(&VAR_20, 0, sizeof VAR_20);\n                memset(&VAR_27, 0, sizeof(VAR_27));\n                VAR_20.ai_family = VAR_28;  /* COMMENT_6 */\n                VAR_20.ai_socktype = VAR_29;\n\n                if (strlen(*VAR_1 + 7) >= sizeof(VAR_27)) {\n                    _pam_log(VAR_30, \"server address too long, sorry\");\n                    continue;\n                }\n                strcpy(VAR_27, *VAR_1 + 7);\n\n                if (*VAR_27 == '[' &&\n                    (VAR_24 = strchr(VAR_27, ']')) != NULL) { /* COMMENT_7 */\n                    VAR_25 = VAR_27 + 1;\n                    _pam_log (VAR_30,\n                        \"reading server address as: %s \",\n                        VAR_25);\n                    VAR_26 = strchr(VAR_24, ':');\n                    *VAR_24 = '\\0';\n                } else { /* COMMENT_8 */\n                    VAR_25 = VAR_27;\n                    VAR_26 = strchr(VAR_27, ':');\n                }\n                if (VAR_26 != NULL) {\n                    *VAR_26 = '\\0';\n                    VAR_26++;\n                }\n                _pam_log (VAR_31,\n                        \"sending server address to getaddrinfo as: %s \",\n                        VAR_25);\n                if ((VAR_23 = getaddrinfo(VAR_25, (VAR_26 == NULL) ? \"49\" : VAR_26, &VAR_20, &VAR_21)) == 0) {\n                    for (VAR_22 = VAR_21;\n                         VAR_22 != NULL && VAR_10 < VAR_6; VAR_22 = VAR_22->ai_next) {\n                        set_tac_srv_addr(VAR_10, VAR_22);\n                        set_tac_srv_key(VAR_10, VAR_3);\n                        VAR_10++;\n                    }\n                    _pam_log(VAR_31, \"%s: server index %d \", VAR_32, VAR_10);\n                    freeaddrinfo (VAR_21);\n                } else {\n                    _pam_log(VAR_30,\n                             \"skip invalid server: %s (getaddrinfo: %s)\",\n                             VAR_25, gai_strerror(VAR_23));\n                }\n            } else {\n                _pam_log(VAR_30, \"maximum number of servers (%d) exceeded, skipping\",\n                         VAR_6);\n            }\n        } else if (!strncmp(*VAR_1, \"secret=\", 7)) {\n            VAR_3 = *VAR_1 + 7;     /* COMMENT_9 */\n\n            /* COMMENT_10 */\n            if (VAR_10 == 0) {\n                _pam_log(VAR_30, \"secret set but no servers configured yet\");\n            } else {\n                /* COMMENT_11 */\n                set_tac_srv_key(VAR_10 - 1, VAR_3);\n            }\n        } else if (!strncmp(*VAR_1, \"timeout=\", 8)) {\n\n#ifdef VAR_33\n            VAR_34 = strtol(*VAR_1 + 8, NULL, 10);\n\n#else\n            VAR_34 = atoi(*VAR_1 + 8);\n#endif\n            if (VAR_34 == VAR_35) {\n                _pam_log(VAR_30, \"timeout parameter cannot be parsed as integer: %s\", *VAR_1);\n                VAR_34 = 0;\n            } else {\n                VAR_36 = 1;\n            }\n        } else {\n            _pam_log(VAR_37, \"unrecognized option: %s\", *VAR_1);\n        }\n    }\n\n    if (VAR_2 & VAR_15) {\n        unsigned long VAR_38;\n\n        _pam_log(VAR_31, \"%d servers defined\", VAR_10);\n\n        for (VAR_38 = 0; VAR_38 < VAR_10; VAR_38++) {\n            _pam_log(VAR_31, \"server[%lu] { addr=%s, key='********' }\", VAR_38,\n\t\t\t    tac_ntop(VAR_4[VAR_38].addr->ai_addr));\n        }\n\n        _pam_log(VAR_31, \"tac_service='%s'\", VAR_11);\n        _pam_log(VAR_31, \"tac_protocol='%s'\", VAR_12);\n        _pam_log(VAR_31, \"tac_prompt='%s'\", VAR_13);\n        _pam_log(VAR_31, \"tac_login='%s'\", VAR_14);\n    }\n\n    return VAR_2;\n}",
  "func_graph_path": "kravietz/pam_tacplus/4a9852c31c2fd0c0e72fbb689a586aabcfb11cb0/support.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -127,8 +127,8 @@\n         _pam_log(LOG_DEBUG, \"%d servers defined\", tac_srv_no);\n \n         for (n = 0; n < tac_srv_no; n++) {\n-            _pam_log(LOG_DEBUG, \"server[%lu] { addr=%s, key='%s' }\", n, tac_ntop(tac_srv[n].addr->ai_addr),\n-                     tac_srv[n].key);\n+            _pam_log(LOG_DEBUG, \"server[%lu] { addr=%s, key='********' }\", n,\n+\t\t\t    tac_ntop(tac_srv[n].addr->ai_addr));\n         }\n \n         _pam_log(LOG_DEBUG, \"tac_service='%s'\", tac_service);",
  "diff_line_info": {
    "deleted_lines": [
      "            _pam_log(LOG_DEBUG, \"server[%lu] { addr=%s, key='%s' }\", n, tac_ntop(tac_srv[n].addr->ai_addr),",
      "                     tac_srv[n].key);"
    ],
    "added_lines": [
      "            _pam_log(LOG_DEBUG, \"server[%lu] { addr=%s, key='********' }\", n,",
      "\t\t\t    tac_ntop(tac_srv[n].addr->ai_addr));"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/kravietz/pam_tacplus/pull/150",
  "description": {
    "pr_info": {
      "title": "pam: don't leak TACACS+ secret to journald",
      "number": 150
    },
    "comment": [
      "If journald for syslog is used, the journal is going to store everything,\r\neven DEBUG loglevel messages. Pre-journald logging of system-wide DEBUG\r\nloglevel could be avoided and is not affected in all cases.\r\n\r\nWith journald presence it's probably safe to no longer log sensitive\r\ndetails at DEBUG level.\r\n\r\nFix #149\r\n\r\nSigned-off-by: Daniel Gollub <dgollub@att.com>"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "The patch addresses a security issue by preventing sensitive data from being logged, reducing the risk of exposure.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9"
}