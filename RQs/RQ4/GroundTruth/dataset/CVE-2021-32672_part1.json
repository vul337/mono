{
  "cve_id": "CVE-2021-32672",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:L/Au:S/C:P/I:N/A:N",
  "cvss_is_v3": false,
  "repo_name": "redis",
  "commit_msg": "Fix protocol parsing on 'ldbReplParseCommand' (CVE-2021-32672)\n\nThe protocol parsing on 'ldbReplParseCommand' (LUA debugging)\nAssumed protocol correctness. This means that if the following\nis given:\n*1\n$100\ntest\nThe parser will try to read additional 94 unallocated bytes after\nthe client buffer.\nThis commit fixes this issue by validating that there are actually enough\nbytes to read. It also limits the amount of data that can be sent by\nthe debugger client to 1M so the client will not be able to explode\nthe memory.",
  "commit_hash": "6ac3c0b7abd35f37201ed2d6298ecef4ea1ae1dd",
  "git_url": "https://github.com/redis/redis/commit/6ac3c0b7abd35f37201ed2d6298ecef4ea1ae1dd",
  "file_path": "src/scripting.c",
  "func_name": "ldbReplParseCommand",
  "func_before": "sds *ldbReplParseCommand(int *argcp) {\n    sds *argv = NULL;\n    int argc = 0;\n    if (sdslen(ldb.cbuf) == 0) return NULL;\n\n    /* Working on a copy is simpler in this case. We can modify it freely\n     * for the sake of simpler parsing. */\n    sds copy = sdsdup(ldb.cbuf);\n    char *p = copy;\n\n    /* This Redis protocol parser is a joke... just the simplest thing that\n     * works in this context. It is also very forgiving regarding broken\n     * protocol. */\n\n    /* Seek and parse *<count>\\r\\n. */\n    p = strchr(p,'*'); if (!p) goto protoerr;\n    char *plen = p+1; /* Multi bulk len pointer. */\n    p = strstr(p,\"\\r\\n\"); if (!p) goto protoerr;\n    *p = '\\0'; p += 2;\n    *argcp = atoi(plen);\n    if (*argcp <= 0 || *argcp > 1024) goto protoerr;\n\n    /* Parse each argument. */\n    argv = zmalloc(sizeof(sds)*(*argcp));\n    argc = 0;\n    while(argc < *argcp) {\n        if (*p != '$') goto protoerr;\n        plen = p+1; /* Bulk string len pointer. */\n        p = strstr(p,\"\\r\\n\"); if (!p) goto protoerr;\n        *p = '\\0'; p += 2;\n        int slen = atoi(plen); /* Length of this arg. */\n        if (slen <= 0 || slen > 1024) goto protoerr;\n        argv[argc++] = sdsnewlen(p,slen);\n        p += slen; /* Skip the already parsed argument. */\n        if (p[0] != '\\r' || p[1] != '\\n') goto protoerr;\n        p += 2; /* Skip \\r\\n. */\n    }\n    sdsfree(copy);\n    return argv;\n\nprotoerr:\n    sdsfreesplitres(argv,argc);\n    sdsfree(copy);\n    return NULL;\n}",
  "abstract_func_before": "sds *ldbReplParseCommand(int *VAR_0) {\n    sds *VAR_1 = NULL;\n    int VAR_2 = 0;\n    if (sdslen(VAR_3.cbuf) == 0) return NULL;\n\n    /* COMMENT_0 */\n                                          \n    sds VAR_4 = sdsdup(VAR_3.cbuf);\n    char *VAR_5 = VAR_4;\n\n    /* COMMENT_2 */\n                                                                        \n                   \n\n    /* COMMENT_5 */\n    VAR_5 = strchr(VAR_5,'*'); if (!VAR_5) goto protoerr;\n    char *VAR_6 = VAR_5+1; /* COMMENT_6 */\n    VAR_5 = strstr(VAR_5,\"\\r\\n\"); if (!VAR_5) goto protoerr;\n    *VAR_5 = '\\0'; VAR_5 += 2;\n    *VAR_0 = atoi(VAR_6);\n    if (*VAR_0 <= 0 || *VAR_0 > 1024) goto protoerr;\n\n    /* COMMENT_7 */\n    VAR_1 = zmalloc(sizeof(sds)*(*VAR_0));\n    VAR_2 = 0;\n    while(VAR_2 < *VAR_0) {\n        if (*VAR_5 != '$') goto protoerr;\n        VAR_6 = VAR_5+1; /* COMMENT_8 */\n        VAR_5 = strstr(VAR_5,\"\\r\\n\"); if (!VAR_5) goto protoerr;\n        *VAR_5 = '\\0'; VAR_5 += 2;\n        int VAR_7 = atoi(VAR_6); /* COMMENT_9 */\n        if (VAR_7 <= 0 || VAR_7 > 1024) goto protoerr;\n        VAR_1[VAR_2++] = sdsnewlen(VAR_5,VAR_7);\n        VAR_5 += VAR_7; /* COMMENT_10 */\n        if (VAR_5[0] != '\\r' || VAR_5[1] != '\\n') goto protoerr;\n        VAR_5 += 2; /* COMMENT_11 */\n    }\n    sdsfree(VAR_4);\n    return VAR_1;\n\nprotoerr:\n    sdsfreesplitres(VAR_1,VAR_2);\n    sdsfree(VAR_4);\n    return NULL;\n}",
  "func_graph_path_before": "redis/6ac3c0b7abd35f37201ed2d6298ecef4ea1ae1dd/scripting.c/vul/before/0.json",
  "func": "sds *ldbReplParseCommand(int *argcp, char** err) {\n    static char* protocol_error = \"protocol error\";\n    sds *argv = NULL;\n    int argc = 0;\n    if (sdslen(ldb.cbuf) == 0) return NULL;\n\n    /* Working on a copy is simpler in this case. We can modify it freely\n     * for the sake of simpler parsing. */\n    sds copy = sdsdup(ldb.cbuf);\n    char *p = copy;\n\n    /* This Redis protocol parser is a joke... just the simplest thing that\n     * works in this context. It is also very forgiving regarding broken\n     * protocol. */\n\n    /* Seek and parse *<count>\\r\\n. */\n    p = strchr(p,'*'); if (!p) goto protoerr;\n    char *plen = p+1; /* Multi bulk len pointer. */\n    p = strstr(p,\"\\r\\n\"); if (!p) goto keep_reading;\n    *p = '\\0'; p += 2;\n    *argcp = atoi(plen);\n    if (*argcp <= 0 || *argcp > 1024) goto protoerr;\n\n    /* Parse each argument. */\n    argv = zmalloc(sizeof(sds)*(*argcp));\n    argc = 0;\n    while(argc < *argcp) {\n        // reached the end but there should be more data to read\n        if (*p == '\\0') goto keep_reading;\n\n        if (*p != '$') goto protoerr;\n        plen = p+1; /* Bulk string len pointer. */\n        p = strstr(p,\"\\r\\n\"); if (!p) goto keep_reading;\n        *p = '\\0'; p += 2;\n        int slen = atoi(plen); /* Length of this arg. */\n        if (slen <= 0 || slen > 1024) goto protoerr;\n        if ((size_t)(p + slen + 2 - copy) > sdslen(copy) ) goto keep_reading;\n        argv[argc++] = sdsnewlen(p,slen);\n        p += slen; /* Skip the already parsed argument. */\n        if (p[0] != '\\r' || p[1] != '\\n') goto protoerr;\n        p += 2; /* Skip \\r\\n. */\n    }\n    sdsfree(copy);\n    return argv;\n\nprotoerr:\n    *err = protocol_error;\nkeep_reading:\n    sdsfreesplitres(argv,argc);\n    sdsfree(copy);\n    return NULL;\n}",
  "abstract_func": "sds *ldbReplParseCommand(int *VAR_0, char** VAR_1) {\n    static char* VAR_2 = \"protocol error\";\n    sds *VAR_3 = NULL;\n    int VAR_4 = 0;\n    if (sdslen(VAR_5.cbuf) == 0) return NULL;\n\n    /* COMMENT_0 */\n                                          \n    sds VAR_6 = sdsdup(VAR_5.cbuf);\n    char *VAR_7 = VAR_6;\n\n    /* COMMENT_2 */\n                                                                        \n                   \n\n    /* COMMENT_5 */\n    VAR_7 = strchr(VAR_7,'*'); if (!VAR_7) goto protoerr;\n    char *VAR_8 = VAR_7+1; /* COMMENT_6 */\n    VAR_7 = strstr(VAR_7,\"\\r\\n\"); if (!VAR_7) goto keep_reading;\n    *VAR_7 = '\\0'; VAR_7 += 2;\n    *VAR_0 = atoi(VAR_8);\n    if (*VAR_0 <= 0 || *VAR_0 > 1024) goto protoerr;\n\n    /* COMMENT_7 */\n    VAR_3 = zmalloc(sizeof(sds)*(*VAR_0));\n    VAR_4 = 0;\n    while(VAR_4 < *VAR_0) {\n        /* COMMENT_8 */\n        if (*VAR_7 == '\\0') goto keep_reading;\n\n        if (*VAR_7 != '$') goto protoerr;\n        VAR_8 = VAR_7+1; /* COMMENT_9 */\n        VAR_7 = strstr(VAR_7,\"\\r\\n\"); if (!VAR_7) goto keep_reading;\n        *VAR_7 = '\\0'; VAR_7 += 2;\n        int VAR_9 = atoi(VAR_8); /* COMMENT_10 */\n        if (VAR_9 <= 0 || VAR_9 > 1024) goto protoerr;\n        if ((size_t)(VAR_7 + VAR_9 + 2 - VAR_6) > sdslen(VAR_6) ) goto keep_reading;\n        VAR_3[VAR_4++] = sdsnewlen(VAR_7,VAR_9);\n        VAR_7 += VAR_9; /* COMMENT_11 */\n        if (VAR_7[0] != '\\r' || VAR_7[1] != '\\n') goto protoerr;\n        VAR_7 += 2; /* COMMENT_12 */\n    }\n    sdsfree(VAR_6);\n    return VAR_3;\n\nprotoerr:\n    *VAR_1 = VAR_2;\nkeep_reading:\n    sdsfreesplitres(VAR_3,VAR_4);\n    sdsfree(VAR_6);\n    return NULL;\n}",
  "func_graph_path": "redis/6ac3c0b7abd35f37201ed2d6298ecef4ea1ae1dd/scripting.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,5 @@\n-sds *ldbReplParseCommand(int *argcp) {\n+sds *ldbReplParseCommand(int *argcp, char** err) {\n+    static char* protocol_error = \"protocol error\";\n     sds *argv = NULL;\n     int argc = 0;\n     if (sdslen(ldb.cbuf) == 0) return NULL;\n@@ -15,7 +16,7 @@\n     /* Seek and parse *<count>\\r\\n. */\n     p = strchr(p,'*'); if (!p) goto protoerr;\n     char *plen = p+1; /* Multi bulk len pointer. */\n-    p = strstr(p,\"\\r\\n\"); if (!p) goto protoerr;\n+    p = strstr(p,\"\\r\\n\"); if (!p) goto keep_reading;\n     *p = '\\0'; p += 2;\n     *argcp = atoi(plen);\n     if (*argcp <= 0 || *argcp > 1024) goto protoerr;\n@@ -24,12 +25,16 @@\n     argv = zmalloc(sizeof(sds)*(*argcp));\n     argc = 0;\n     while(argc < *argcp) {\n+        // reached the end but there should be more data to read\n+        if (*p == '\\0') goto keep_reading;\n+\n         if (*p != '$') goto protoerr;\n         plen = p+1; /* Bulk string len pointer. */\n-        p = strstr(p,\"\\r\\n\"); if (!p) goto protoerr;\n+        p = strstr(p,\"\\r\\n\"); if (!p) goto keep_reading;\n         *p = '\\0'; p += 2;\n         int slen = atoi(plen); /* Length of this arg. */\n         if (slen <= 0 || slen > 1024) goto protoerr;\n+        if ((size_t)(p + slen + 2 - copy) > sdslen(copy) ) goto keep_reading;\n         argv[argc++] = sdsnewlen(p,slen);\n         p += slen; /* Skip the already parsed argument. */\n         if (p[0] != '\\r' || p[1] != '\\n') goto protoerr;\n@@ -39,6 +44,8 @@\n     return argv;\n \n protoerr:\n+    *err = protocol_error;\n+keep_reading:\n     sdsfreesplitres(argv,argc);\n     sdsfree(copy);\n     return NULL;",
  "diff_line_info": {
    "deleted_lines": [
      "sds *ldbReplParseCommand(int *argcp) {",
      "    p = strstr(p,\"\\r\\n\"); if (!p) goto protoerr;",
      "        p = strstr(p,\"\\r\\n\"); if (!p) goto protoerr;"
    ],
    "added_lines": [
      "sds *ldbReplParseCommand(int *argcp, char** err) {",
      "    static char* protocol_error = \"protocol error\";",
      "    p = strstr(p,\"\\r\\n\"); if (!p) goto keep_reading;",
      "        // reached the end but there should be more data to read",
      "        if (*p == '\\0') goto keep_reading;",
      "",
      "        p = strstr(p,\"\\r\\n\"); if (!p) goto keep_reading;",
      "        if ((size_t)(p + slen + 2 - copy) > sdslen(copy) ) goto keep_reading;",
      "    *err = protocol_error;",
      "keep_reading:"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/redis/redis/pull/9584",
  "description": {
    "pr_info": {
      "title": "Release 6.0.16",
      "number": 9584
    },
    "comment": [
      "Upgrade urgency: SECURITY, contains fixes to security issues.\r\n\r\nSecurity Fixes:\r\n* (CVE-2021-41099) Integer to heap buffer overflow handling certain string\r\n  commands and network payloads, when proto-max-bulk-len is manually configured\r\n  to a non-default, very large value [reported by yiyuaner].\r\n* (CVE-2021-32762) Integer to heap buffer overflow issue in redis-cli and\r\n  redis-sentinel parsing large multi-bulk replies on some older and less common\r\n  platforms [reported by Microsoft Vulnerability Research].\r\n* (CVE-2021-32687) Integer to heap buffer overflow with intsets, when\r\n  set-max-intset-entries is manually configured to a non-default, very large\r\n  value [reported by Pawel Wieczorkiewicz, AWS].\r\n* (CVE-2021-32675) Denial Of Service when processing RESP request payloads with\r\n  a large number of elements on many connections.\r\n* (CVE-2021-32672) Random heap reading issue with Lua Debugger [reported by\r\n  Meir Shpilraien].\r\n* (CVE-2021-32628) Integer to heap buffer overflow handling ziplist-encoded\r\n  data types, when configuring a large, non-default value for\r\n  hash-max-ziplist-entries, hash-max-ziplist-value, zset-max-ziplist-entries\r\n  or zset-max-ziplist-value [reported by sundb].\r\n* (CVE-2021-32627) Integer to heap buffer overflow issue with streams, when\r\n  configuring a non-default, large value for proto-max-bulk-len and\r\n  client-query-buffer-limit [reported by sundb].\r\n* (CVE-2021-32626) Specially crafted Lua scripts may result with Heap buffer\r\n  overflow [reported by Meir Shpilraien].\r\n\r\nOther bug fixes:\r\n* Fix appendfsync to always guarantee fsync before reply, on MacOS and FreeBSD (kqueue) (#9416)\r\n* Fix the wrong mis-detection of sync_file_range system call, affecting performance (#9371)\r\n* Fix replication issues when repl-diskless-load is used (#9280)\r\n",
      "CI failures on MacOS (due to tests being timing sensitive): \r\n```\r\n*** [err]: No write if min-slaves-max-lag is > of the slave lag in tests/integration/replication-2.tcl\r\nExpected 'NOREPLICAS*' to equal or match 'OK'\r\n*** [err]: With min-slaves-to-write: master not writable with lagged slave in tests/integration/replication-4.tcl\r\nExpected 'NOREPLICAS*' to equal or match 'OK'\r\nCleanup: may take some time... OK\r\n```\r\nsolved by #8461 and #8583\r\n\r\nalso, the `build-ubuntu-old` CI got hung (probably no longer supported)",
      "Hi,\r\n [hi_sdsMakeRoomFor](https://github.com/redis/redis/blob/4930d19e70c391750479951022e207e19111eb55/deps/hiredis/sds.c#L196)  in deps/hiredis/sds.c wouldn't c487a9c03f89498976b3b6574df2cac763af16cc commit be applicable for hiredis code as well?\r\n",
      "Pinging @michael-grunder, do you think this fix is relevant for hiredis?"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0\n\n**Step-by-Step Explanation:**\n\n1. **Input Analysis:** The commit message mentions a specific CVE (CVE-2021-32672) and discusses fixing a protocol parsing issue related to the Lua Debugger, indicating a security concern.\n\n2. **Consistency Check:** The code diff modifies the function to add validation for buffer size and limits data input, consistent with addressing a security issue.\n\n3. **Purpose Evaluation:** The changes aim to prevent buffer overflow by validating input, which directly addresses a security vulnerability.\n\n4. **Security Assessment:** The patch targets a known CVE, clearly indicating a security fix.\n\n5. **Confidence Score:** 1.0 – The information is clear, with explicit mention of a CVE and corresponding code changes that fix a security issue."
}