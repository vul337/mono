{
  "cve_id": "CVE-2023-50020",
  "cwe_ids": [
    "CWE-400"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "open5gs",
  "commit_msg": "[SCTP] Fixed a crash on SIGPIPE (#2734)",
  "commit_hash": "1aba814938e3a1b2eec7014bf6ce132d34622e08",
  "git_url": "https://github.com/open5gs/open5gs/commit/1aba814938e3a1b2eec7014bf6ce132d34622e08",
  "file_path": "lib/core/ogs-epoll.c",
  "func_name": "epoll_process",
  "func_before": "static int epoll_process(ogs_pollset_t *pollset, ogs_time_t timeout)\n{\n    struct epoll_context_s *context = NULL;\n    int num_of_poll;\n    int i;\n\n    ogs_assert(pollset);\n    context = pollset->context;\n    ogs_assert(context);\n\n    num_of_poll = epoll_wait(context->epfd, context->event_list,\n            pollset->capacity,\n            timeout == OGS_INFINITE_TIME ? OGS_INFINITE_TIME :\n                ogs_time_to_msec(timeout));\n    if (num_of_poll < 0) {\n        ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno, \"epoll failed\");\n        return OGS_ERROR;\n    } else if (num_of_poll == 0) {\n        return OGS_TIMEUP;\n    }\n\n    for (i = 0; i < num_of_poll; i++) {\n        struct epoll_map_s *map = NULL;\n        uint32_t received;\n        short when = 0;\n        ogs_socket_t fd;\n\n        received = context->event_list[i].events;\n        if (received & EPOLLERR) {\n        /*\n         * The libevent library has OGS_POLLOUT turned on in EPOLLERR.\n         *\n         * However, SIGPIPE can occur if write() is called\n         * when the peer connection is closed.\n         *\n         * Therefore, Open5GS turns off OGS_POLLOUT\n         * so that write() cannot be called in case of EPOLLERR.\n         *\n         * See also #2411 and #2312\n         */\n#if 0\n            when = OGS_POLLIN|OGS_POLLOUT;\n#else\n            when = OGS_POLLIN;\n#endif\n        } else if ((received & EPOLLHUP) && !(received & EPOLLRDHUP)) {\n            when = OGS_POLLIN|OGS_POLLOUT;\n        } else {\n            if (received & EPOLLIN) {\n                when |= OGS_POLLIN;\n            }\n            if (received & EPOLLOUT) {\n                when |= OGS_POLLOUT;\n            }\n            if (received & EPOLLRDHUP) {\n                when |= OGS_POLLIN;\n            }\n        }\n\n        if (!when)\n            continue;\n\n        fd = context->event_list[i].data.fd;\n        ogs_assert(fd != INVALID_SOCKET);\n\n        map = ogs_hash_get(context->map_hash, &fd, sizeof(fd));\n        if (!map) continue;\n\n        if (map->read && map->write && map->read == map->write) {\n            map->read->handler(when, map->read->fd, map->read->data);\n        } else {\n            if ((when & OGS_POLLIN) && map->read)\n                map->read->handler(when, map->read->fd, map->read->data);\n\n            /*\n             * map->read->handler() can call ogs_remove_epoll()\n             * So, we need to check map instance\n             */\n            map = ogs_hash_get(context->map_hash, &fd, sizeof(fd));\n            if (!map) continue;\n\n            if ((when & OGS_POLLOUT) && map->write)\n                map->write->handler(when, map->write->fd, map->write->data);\n        }\n    }\n    \n    return OGS_OK;\n}",
  "abstract_func_before": "static int epoll_process(ogs_pollset_t *VAR_0, ogs_time_t VAR_1)\n{\n    struct epoll_context_s *VAR_2 = NULL;\n    int VAR_3;\n    int VAR_4;\n\n    ogs_assert(VAR_0);\n    VAR_2 = VAR_0->context;\n    ogs_assert(VAR_2);\n\n    VAR_3 = epoll_wait(VAR_2->epfd, VAR_2->event_list,\n            VAR_0->capacity,\n            VAR_1 == VAR_5 ? VAR_5 :\n                ogs_time_to_msec(VAR_1));\n    if (VAR_3 < 0) {\n        ogs_log_message(VAR_6, VAR_7, \"epoll failed\");\n        return VAR_8;\n    } else if (VAR_3 == 0) {\n        return VAR_9;\n    }\n\n    for (VAR_4 = 0; VAR_4 < VAR_3; VAR_4++) {\n        struct epoll_map_s *VAR_10 = NULL;\n        uint32_t VAR_11;\n        short VAR_12 = 0;\n        ogs_socket_t VAR_13;\n\n        VAR_11 = VAR_2->event_list[VAR_4].events;\n        if (VAR_11 & VAR_14) {\n        /* COMMENT_0 */\n                                                                      \n          \n                                                          \n                                              \n          \n                                                   \n                                                                \n          \n                                   \n           \n#if 0\n            VAR_12 = VAR_15|VAR_16;\n#else\n            VAR_12 = VAR_15;\n#endif\n        } else if ((VAR_11 & VAR_17) && !(VAR_11 & VAR_18)) {\n            VAR_12 = VAR_15|VAR_16;\n        } else {\n            if (VAR_11 & VAR_19) {\n                VAR_12 |= VAR_15;\n            }\n            if (VAR_11 & VAR_20) {\n                VAR_12 |= VAR_16;\n            }\n            if (VAR_11 & VAR_18) {\n                VAR_12 |= VAR_15;\n            }\n        }\n\n        if (!VAR_12)\n            continue;\n\n        VAR_13 = VAR_2->event_list[VAR_4].data.fd;\n        ogs_assert(VAR_13 != VAR_21);\n\n        VAR_10 = ogs_hash_get(VAR_2->map_hash, &VAR_13, sizeof(VAR_13));\n        if (!VAR_10) continue;\n\n        if (VAR_10->read && VAR_10->write && VAR_10->read == VAR_10->write) {\n            VAR_10->read->handler(VAR_12, VAR_10->read->fd, VAR_10->read->data);\n        } else {\n            if ((VAR_12 & VAR_15) && VAR_10->read)\n                VAR_10->read->handler(VAR_12, VAR_10->read->fd, VAR_10->read->data);\n\n            /* COMMENT_9 */\n                                                               \n                                                \n               \n            VAR_10 = ogs_hash_get(VAR_2->map_hash, &VAR_13, sizeof(VAR_13));\n            if (!VAR_10) continue;\n\n            if ((VAR_12 & VAR_16) && VAR_10->write)\n                VAR_10->write->handler(VAR_12, VAR_10->write->fd, VAR_10->write->data);\n        }\n    }\n    \n    return VAR_22;\n}",
  "func_graph_path_before": "open5gs/1aba814938e3a1b2eec7014bf6ce132d34622e08/ogs-epoll.c/vul/before/0.json",
  "func": "static int epoll_process(ogs_pollset_t *pollset, ogs_time_t timeout)\n{\n    struct epoll_context_s *context = NULL;\n    int num_of_poll;\n    int i;\n\n    ogs_assert(pollset);\n    context = pollset->context;\n    ogs_assert(context);\n\n    num_of_poll = epoll_wait(context->epfd, context->event_list,\n            pollset->capacity,\n            timeout == OGS_INFINITE_TIME ? OGS_INFINITE_TIME :\n                ogs_time_to_msec(timeout));\n    if (num_of_poll < 0) {\n        ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno, \"epoll failed\");\n        return OGS_ERROR;\n    } else if (num_of_poll == 0) {\n        return OGS_TIMEUP;\n    }\n\n    for (i = 0; i < num_of_poll; i++) {\n        struct epoll_map_s *map = NULL;\n        uint32_t received;\n        short when = 0;\n        ogs_socket_t fd;\n\n        received = context->event_list[i].events;\n        if (received & EPOLLERR) {\n        /*\n         * The libevent library has OGS_POLLOUT turned on in EPOLLERR.\n         *\n         * However, SIGPIPE can occur if write() is called\n         * when the peer connection is closed.\n         *\n         * Therefore, Open5GS turns off OGS_POLLOUT\n         * so that write() cannot be called in case of EPOLLERR.\n         *\n         * See also #2411 and #2312\n         */\n#if 0\n            when = OGS_POLLIN|OGS_POLLOUT;\n#else\n            when = OGS_POLLIN;\n#endif\n        } else if ((received & EPOLLHUP) && !(received & EPOLLRDHUP)) {\n            when = OGS_POLLIN|OGS_POLLOUT;\n        } else {\n            if (received & EPOLLIN) {\n                when |= OGS_POLLIN;\n            }\n            if (received & EPOLLOUT) {\n                when |= OGS_POLLOUT;\n            }\n            if (received & EPOLLRDHUP) {\n                when |= OGS_POLLIN;\n                when &= ~OGS_POLLOUT;\n            }\n        }\n\n        if (!when)\n            continue;\n\n        fd = context->event_list[i].data.fd;\n        ogs_assert(fd != INVALID_SOCKET);\n\n        map = ogs_hash_get(context->map_hash, &fd, sizeof(fd));\n        if (!map) continue;\n\n        if (map->read && map->write && map->read == map->write) {\n            map->read->handler(when, map->read->fd, map->read->data);\n        } else {\n            if ((when & OGS_POLLIN) && map->read)\n                map->read->handler(when, map->read->fd, map->read->data);\n\n            /*\n             * map->read->handler() can call ogs_remove_epoll()\n             * So, we need to check map instance\n             */\n            map = ogs_hash_get(context->map_hash, &fd, sizeof(fd));\n            if (!map) continue;\n\n            if ((when & OGS_POLLOUT) && map->write)\n                map->write->handler(when, map->write->fd, map->write->data);\n        }\n    }\n    \n    return OGS_OK;\n}",
  "abstract_func": "static int epoll_process(ogs_pollset_t *VAR_0, ogs_time_t VAR_1)\n{\n    struct epoll_context_s *VAR_2 = NULL;\n    int VAR_3;\n    int VAR_4;\n\n    ogs_assert(VAR_0);\n    VAR_2 = VAR_0->context;\n    ogs_assert(VAR_2);\n\n    VAR_3 = epoll_wait(VAR_2->epfd, VAR_2->event_list,\n            VAR_0->capacity,\n            VAR_1 == VAR_5 ? VAR_5 :\n                ogs_time_to_msec(VAR_1));\n    if (VAR_3 < 0) {\n        ogs_log_message(VAR_6, VAR_7, \"epoll failed\");\n        return VAR_8;\n    } else if (VAR_3 == 0) {\n        return VAR_9;\n    }\n\n    for (VAR_4 = 0; VAR_4 < VAR_3; VAR_4++) {\n        struct epoll_map_s *VAR_10 = NULL;\n        uint32_t VAR_11;\n        short VAR_12 = 0;\n        ogs_socket_t VAR_13;\n\n        VAR_11 = VAR_2->event_list[VAR_4].events;\n        if (VAR_11 & VAR_14) {\n        /* COMMENT_0 */\n                                                                      \n          \n                                                          \n                                              \n          \n                                                   \n                                                                \n          \n                                   \n           \n#if 0\n            VAR_12 = VAR_15|VAR_16;\n#else\n            VAR_12 = VAR_15;\n#endif\n        } else if ((VAR_11 & VAR_17) && !(VAR_11 & VAR_18)) {\n            VAR_12 = VAR_15|VAR_16;\n        } else {\n            if (VAR_11 & VAR_19) {\n                VAR_12 |= VAR_15;\n            }\n            if (VAR_11 & VAR_20) {\n                VAR_12 |= VAR_16;\n            }\n            if (VAR_11 & VAR_18) {\n                VAR_12 |= VAR_15;\n                VAR_12 &= ~VAR_16;\n            }\n        }\n\n        if (!VAR_12)\n            continue;\n\n        VAR_13 = VAR_2->event_list[VAR_4].data.fd;\n        ogs_assert(VAR_13 != VAR_21);\n\n        VAR_10 = ogs_hash_get(VAR_2->map_hash, &VAR_13, sizeof(VAR_13));\n        if (!VAR_10) continue;\n\n        if (VAR_10->read && VAR_10->write && VAR_10->read == VAR_10->write) {\n            VAR_10->read->handler(VAR_12, VAR_10->read->fd, VAR_10->read->data);\n        } else {\n            if ((VAR_12 & VAR_15) && VAR_10->read)\n                VAR_10->read->handler(VAR_12, VAR_10->read->fd, VAR_10->read->data);\n\n            /* COMMENT_9 */\n                                                               \n                                                \n               \n            VAR_10 = ogs_hash_get(VAR_2->map_hash, &VAR_13, sizeof(VAR_13));\n            if (!VAR_10) continue;\n\n            if ((VAR_12 & VAR_16) && VAR_10->write)\n                VAR_10->write->handler(VAR_12, VAR_10->write->fd, VAR_10->write->data);\n        }\n    }\n    \n    return VAR_22;\n}",
  "func_graph_path": "open5gs/1aba814938e3a1b2eec7014bf6ce132d34622e08/ogs-epoll.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -54,6 +54,7 @@\n             }\n             if (received & EPOLLRDHUP) {\n                 when |= OGS_POLLIN;\n+                when &= ~OGS_POLLOUT;\n             }\n         }\n ",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "                when &= ~OGS_POLLOUT;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/open5gs/open5gs/pull/2757",
  "description": {
    "pr_info": {
      "title": "[SCTP] Fixed a crash on SIGPIPE (#2734)",
      "number": 2757
    },
    "comment": [
      "If EPOLLIN, EPOLLOUT, and EPOLLRDHUP occur at the same time, Linux generates a SIGPIPE signal as below.\r\n\r\n```\r\n11/13 16:55:43.340: [core] INFO: after eopll_process , num_of_poll is 1 (../lib/core/ogs-epoll.c:215)\r\n11/13 16:55:43.340: [core] INFO: received: 2005 (../lib/core/ogs-epoll.c:230)\r\n11/13 16:55:43.340: [core] INFO: EPOLLIN event occurred (../lib/core/ogs-epoll.\r\n11/13 16:55:43.340: [core] INFO: EPOLLOUT event occurred (../lib/core/ogs-epoll.c:259)\r\n11/13 16:55:43.340: [core] INFO: EPOLLRDHUP event occurred (../lib/core/ogs-epoll.c:263)\r\n11/13 16:55:43.340: [amf] DEBUG: SCTP_SHUTDOWN_EVENT:[T:32773, F:0x0, L:12] (../src/amf/ngap-sctp.c:191)\r\n11/13 16:55:43.340: [amf] INFO: ogs_queue_push amf_sctp_event_push (../src/amf/event.c:104)\r\n```\r\n\r\nI've made modifications so that when EPOLLRDHUP occurs, only OGS_POLLIN is set and OGS_POLLOUT is unset to prevent SIGPIPE from occurring in such cases.\r\n\r\nThanks a lot!\r\nSukchan"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.9"
}