{
  "cve_id": "CVE-2023-6507",
  "cwe_ids": [
    "CWE-269"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:N/I:H/A:N",
  "cvss_is_v3": true,
  "repo_name": "python/cpython",
  "commit_msg": "gh-112334: Restore subprocess's use of `vfork()` & fix `extra_groups=[]`.\n\nFixed a performance regression in 3.12's :mod:`subprocess` on Linux where it\nwould no longer use the fast-path ``vfork()`` system call when it could have\ndue to a logic bug, instead falling back to the safe but slower ``fork()``.\n\nAlso fixed a second 3.12.0 potential security bug.  If a value of\n``extra_groups=[]`` was passed to :mod:`subprocess.Popen` or related APIs,\nthe underlying ``setgroups(0, NULL)`` system call to clear the groups list\nwould not be made in the child process prior to ``exec()``.\n\nThe security issue was identified via code inspection in the process of\nfixing the first bug.  Thanks to @vain for the detailed report and\nanalysis in the initial bug on Github.\n\n * [ ] A regression test is desirable. I'm pondering a test that runs when\n   `strace` is available and permitted which and confirms use of `vfork()`\n   vs `clone()`...",
  "commit_hash": "7a896fc464a6bceb9b95268b0141667645b2a8da",
  "git_url": "https://github.com/python/cpython/commit/7a896fc464a6bceb9b95268b0141667645b2a8da",
  "file_path": "Modules/_posixsubprocess.c",
  "func_name": "subprocess_fork_exec_impl",
  "func_before": "static PyObject *\nsubprocess_fork_exec_impl(PyObject *module, PyObject *process_args,\n                          PyObject *executable_list, int close_fds,\n                          PyObject *py_fds_to_keep, PyObject *cwd_obj,\n                          PyObject *env_list, int p2cread, int p2cwrite,\n                          int c2pread, int c2pwrite, int errread,\n                          int errwrite, int errpipe_read, int errpipe_write,\n                          int restore_signals, int call_setsid,\n                          pid_t pgid_to_set, PyObject *gid_object,\n                          PyObject *extra_groups_packed,\n                          PyObject *uid_object, int child_umask,\n                          PyObject *preexec_fn, int allow_vfork)\n/*[clinic end generated code: output=7ee4f6ee5cf22b5b input=51757287ef266ffa]*/\n{\n    PyObject *converted_args = NULL, *fast_args = NULL;\n    PyObject *preexec_fn_args_tuple = NULL;\n    gid_t *extra_groups = NULL;\n    PyObject *cwd_obj2 = NULL;\n    const char *cwd = NULL;\n    pid_t pid = -1;\n    int need_to_reenable_gc = 0;\n    char *const *argv = NULL, *const *envp = NULL;\n    Py_ssize_t extra_group_size = 0;\n    int need_after_fork = 0;\n    int saved_errno = 0;\n    int *c_fds_to_keep = NULL;\n    Py_ssize_t fds_to_keep_len = PyTuple_GET_SIZE(py_fds_to_keep);\n\n    PyInterpreterState *interp = _PyInterpreterState_GET();\n    if ((preexec_fn != Py_None) && interp->finalizing) {\n        PyErr_SetString(PyExc_RuntimeError,\n                        \"preexec_fn not supported at interpreter shutdown\");\n        return NULL;\n    }\n    if ((preexec_fn != Py_None) && (interp != PyInterpreterState_Main())) {\n        PyErr_SetString(PyExc_RuntimeError,\n                        \"preexec_fn not supported within subinterpreters\");\n        return NULL;\n    }\n\n    if (close_fds && errpipe_write < 3) {  /* precondition */\n        PyErr_SetString(PyExc_ValueError, \"errpipe_write must be >= 3\");\n        return NULL;\n    }\n    if (_sanity_check_python_fd_sequence(py_fds_to_keep)) {\n        PyErr_SetString(PyExc_ValueError, \"bad value(s) in fds_to_keep\");\n        return NULL;\n    }\n\n    /* We need to call gc.disable() when we'll be calling preexec_fn */\n    if (preexec_fn != Py_None) {\n        need_to_reenable_gc = PyGC_Disable();\n    }\n\n    char *const *exec_array = _PySequence_BytesToCharpArray(executable_list);\n    if (!exec_array)\n        goto cleanup;\n\n    /* Convert args and env into appropriate arguments for exec() */\n    /* These conversions are done in the parent process to avoid allocating\n       or freeing memory in the child process. */\n    if (process_args != Py_None) {\n        Py_ssize_t num_args;\n        /* Equivalent to:  */\n        /*  tuple(PyUnicode_FSConverter(arg) for arg in process_args)  */\n        fast_args = PySequence_Fast(process_args, \"argv must be a tuple\");\n        if (fast_args == NULL)\n            goto cleanup;\n        num_args = PySequence_Fast_GET_SIZE(fast_args);\n        converted_args = PyTuple_New(num_args);\n        if (converted_args == NULL)\n            goto cleanup;\n        for (Py_ssize_t arg_num = 0; arg_num < num_args; ++arg_num) {\n            PyObject *borrowed_arg, *converted_arg;\n            if (PySequence_Fast_GET_SIZE(fast_args) != num_args) {\n                PyErr_SetString(PyExc_RuntimeError, \"args changed during iteration\");\n                goto cleanup;\n            }\n            borrowed_arg = PySequence_Fast_GET_ITEM(fast_args, arg_num);\n            if (PyUnicode_FSConverter(borrowed_arg, &converted_arg) == 0)\n                goto cleanup;\n            PyTuple_SET_ITEM(converted_args, arg_num, converted_arg);\n        }\n\n        argv = _PySequence_BytesToCharpArray(converted_args);\n        Py_CLEAR(converted_args);\n        Py_CLEAR(fast_args);\n        if (!argv)\n            goto cleanup;\n    }\n\n    if (env_list != Py_None) {\n        envp = _PySequence_BytesToCharpArray(env_list);\n        if (!envp)\n            goto cleanup;\n    }\n\n    if (cwd_obj != Py_None) {\n        if (PyUnicode_FSConverter(cwd_obj, &cwd_obj2) == 0)\n            goto cleanup;\n        cwd = PyBytes_AsString(cwd_obj2);\n    }\n\n    if (extra_groups_packed != Py_None) {\n#ifdef HAVE_SETGROUPS\n        if (!PyList_Check(extra_groups_packed)) {\n            PyErr_SetString(PyExc_TypeError,\n                    \"setgroups argument must be a list\");\n            goto cleanup;\n        }\n        extra_group_size = PySequence_Size(extra_groups_packed);\n\n        if (extra_group_size < 0)\n            goto cleanup;\n\n        if (extra_group_size > MAX_GROUPS) {\n            PyErr_SetString(PyExc_ValueError, \"too many extra_groups\");\n            goto cleanup;\n        }\n\n        /* Deliberately keep extra_groups == NULL for extra_group_size == 0 */\n        if (extra_group_size > 0) {\n            extra_groups = PyMem_RawMalloc(extra_group_size * sizeof(gid_t));\n            if (extra_groups == NULL) {\n                PyErr_SetString(PyExc_MemoryError,\n                        \"failed to allocate memory for group list\");\n                goto cleanup;\n            }\n        }\n\n        for (Py_ssize_t i = 0; i < extra_group_size; i++) {\n            PyObject *elem;\n            elem = PySequence_GetItem(extra_groups_packed, i);\n            if (!elem)\n                goto cleanup;\n            if (!PyLong_Check(elem)) {\n                PyErr_SetString(PyExc_TypeError,\n                                \"extra_groups must be integers\");\n                Py_DECREF(elem);\n                goto cleanup;\n            } else {\n                gid_t gid;\n                if (!_Py_Gid_Converter(elem, &gid)) {\n                    Py_DECREF(elem);\n                    PyErr_SetString(PyExc_ValueError, \"invalid group id\");\n                    goto cleanup;\n                }\n                extra_groups[i] = gid;\n            }\n            Py_DECREF(elem);\n        }\n\n#else /* HAVE_SETGROUPS */\n        PyErr_BadInternalCall();\n        goto cleanup;\n#endif /* HAVE_SETGROUPS */\n    }\n\n    gid_t gid = (gid_t)-1;\n    if (gid_object != Py_None) {\n#ifdef HAVE_SETREGID\n        if (!_Py_Gid_Converter(gid_object, &gid))\n            goto cleanup;\n\n#else /* HAVE_SETREGID */\n        PyErr_BadInternalCall();\n        goto cleanup;\n#endif /* HAVE_SETREUID */\n    }\n\n    uid_t uid = (uid_t)-1;\n    if (uid_object != Py_None) {\n#ifdef HAVE_SETREUID\n        if (!_Py_Uid_Converter(uid_object, &uid))\n            goto cleanup;\n\n#else /* HAVE_SETREUID */\n        PyErr_BadInternalCall();\n        goto cleanup;\n#endif /* HAVE_SETREUID */\n    }\n\n    c_fds_to_keep = PyMem_Malloc(fds_to_keep_len * sizeof(int));\n    if (c_fds_to_keep == NULL) {\n        PyErr_SetString(PyExc_MemoryError, \"failed to malloc c_fds_to_keep\");\n        goto cleanup;\n    }\n    if (convert_fds_to_keep_to_c(py_fds_to_keep, c_fds_to_keep) < 0) {\n        goto cleanup;\n    }\n\n    /* This must be the last thing done before fork() because we do not\n     * want to call PyOS_BeforeFork() if there is any chance of another\n     * error leading to the cleanup: code without calling fork(). */\n    if (preexec_fn != Py_None) {\n        preexec_fn_args_tuple = PyTuple_New(0);\n        if (!preexec_fn_args_tuple)\n            goto cleanup;\n        PyOS_BeforeFork();\n        need_after_fork = 1;\n    }\n\n    /* NOTE: When old_sigmask is non-NULL, do_fork_exec() may use vfork(). */\n    const void *old_sigmask = NULL;\n#ifdef VFORK_USABLE\n    /* Use vfork() only if it's safe. See the comment above child_exec(). */\n    sigset_t old_sigs;\n    if (preexec_fn == Py_None && allow_vfork &&\n        uid == (uid_t)-1 && gid == (gid_t)-1 && extra_group_size < 0) {\n        /* Block all signals to ensure that no signal handlers are run in the\n         * child process while it shares memory with us. Note that signals\n         * used internally by C libraries won't be blocked by\n         * pthread_sigmask(), but signal handlers installed by C libraries\n         * normally service only signals originating from *within the process*,\n         * so it should be sufficient to consider any library function that\n         * might send such a signal to be vfork-unsafe and do not call it in\n         * the child.\n         */\n        sigset_t all_sigs;\n        sigfillset(&all_sigs);\n        if ((saved_errno = pthread_sigmask(SIG_BLOCK, &all_sigs, &old_sigs))) {\n            goto cleanup;\n        }\n        old_sigmask = &old_sigs;\n    }\n#endif\n\n    pid = do_fork_exec(exec_array, argv, envp, cwd,\n                       p2cread, p2cwrite, c2pread, c2pwrite,\n                       errread, errwrite, errpipe_read, errpipe_write,\n                       close_fds, restore_signals, call_setsid, pgid_to_set,\n                       gid, extra_group_size, extra_groups,\n                       uid, child_umask, old_sigmask,\n                       c_fds_to_keep, fds_to_keep_len,\n                       preexec_fn, preexec_fn_args_tuple);\n\n    /* Parent (original) process */\n    if (pid == (pid_t)-1) {\n        /* Capture errno for the exception. */\n        saved_errno = errno;\n    }\n\n#ifdef VFORK_USABLE\n    if (old_sigmask) {\n        /* vfork() semantics guarantees that the parent is blocked\n         * until the child performs _exit() or execve(), so it is safe\n         * to unblock signals once we're here.\n         * Note that in environments where vfork() is implemented as fork(),\n         * such as QEMU user-mode emulation, the parent won't be blocked,\n         * but it won't share the address space with the child,\n         * so it's still safe to unblock the signals.\n         *\n         * We don't handle errors here because this call can't fail\n         * if valid arguments are given, and because there is no good\n         * way for the caller to deal with a failure to restore\n         * the thread signal mask. */\n        (void) pthread_sigmask(SIG_SETMASK, old_sigmask, NULL);\n    }\n#endif\n\n    if (need_after_fork)\n        PyOS_AfterFork_Parent();\n\ncleanup:\n    if (c_fds_to_keep != NULL) {\n        PyMem_Free(c_fds_to_keep);\n    }\n\n    if (saved_errno != 0) {\n        errno = saved_errno;\n        /* We can't call this above as PyOS_AfterFork_Parent() calls back\n         * into Python code which would see the unreturned error. */\n        PyErr_SetFromErrno(PyExc_OSError);\n    }\n\n    Py_XDECREF(preexec_fn_args_tuple);\n    PyMem_RawFree(extra_groups);\n    Py_XDECREF(cwd_obj2);\n    if (envp)\n        _Py_FreeCharPArray(envp);\n    Py_XDECREF(converted_args);\n    Py_XDECREF(fast_args);\n    if (argv)\n        _Py_FreeCharPArray(argv);\n    if (exec_array)\n        _Py_FreeCharPArray(exec_array);\n\n    if (need_to_reenable_gc) {\n        PyGC_Enable();\n    }\n\n    return pid == -1 ? NULL : PyLong_FromPid(pid);\n}",
  "abstract_func_before": "static PyObject *\nsubprocess_fork_exec_impl(PyObject *VAR_0, PyObject *VAR_1,\n                          PyObject *VAR_2, int VAR_3,\n                          PyObject *VAR_4, PyObject *VAR_5,\n                          PyObject *VAR_6, int VAR_7, int VAR_8,\n                          int VAR_9, int VAR_10, int VAR_11,\n                          int VAR_12, int VAR_13, int VAR_14,\n                          int VAR_15, int VAR_16,\n                          pid_t VAR_17, PyObject *VAR_18,\n                          PyObject *VAR_19,\n                          PyObject *VAR_20, int VAR_21,\n                          PyObject *VAR_22, int VAR_23)\n/* COMMENT_0 */\n{\n    PyObject *VAR_24 = NULL, *VAR_25 = NULL;\n    PyObject *VAR_26 = NULL;\n    gid_t *VAR_27 = NULL;\n    PyObject *VAR_28 = NULL;\n    const char *VAR_29 = NULL;\n    pid_t VAR_30 = -1;\n    int VAR_31 = 0;\n    char *const *VAR_32 = NULL, *const *VAR_33 = NULL;\n    Py_ssize_t VAR_34 = 0;\n    int VAR_35 = 0;\n    int VAR_36 = 0;\n    int *VAR_37 = NULL;\n    Py_ssize_t VAR_38 = PyTuple_GET_SIZE(VAR_4);\n\n    PyInterpreterState *VAR_39 = _PyInterpreterState_GET();\n    if ((VAR_22 != VAR_40) && VAR_39->finalizing) {\n        PyErr_SetString(VAR_41,\n                        \"preexec_fn not supported at interpreter shutdown\");\n        return NULL;\n    }\n    if ((VAR_22 != VAR_40) && (VAR_39 != PyInterpreterState_Main())) {\n        PyErr_SetString(VAR_41,\n                        \"preexec_fn not supported within subinterpreters\");\n        return NULL;\n    }\n\n    if (VAR_3 && VAR_14 < 3) {  /* COMMENT_1 */\n        PyErr_SetString(VAR_42, \"errpipe_write must be >= 3\");\n        return NULL;\n    }\n    if (_sanity_check_python_fd_sequence(VAR_4)) {\n        PyErr_SetString(VAR_42, \"bad value(s) in fds_to_keep\");\n        return NULL;\n    }\n\n    /* COMMENT_2 */\n    if (VAR_22 != VAR_40) {\n        VAR_31 = PyGC_Disable();\n    }\n\n    char *const *VAR_43 = _PySequence_BytesToCharpArray(VAR_2);\n    if (!VAR_43)\n        goto cleanup;\n\n    /* COMMENT_3 */\n    /* COMMENT_4 */\n                                                 \n    if (VAR_1 != VAR_40) {\n        Py_ssize_t VAR_44;\n        /* COMMENT_6 */\n        /* COMMENT_7 */\n        VAR_25 = PySequence_Fast(VAR_1, \"argv must be a tuple\");\n        if (VAR_25 == NULL)\n            goto cleanup;\n        VAR_44 = PySequence_Fast_GET_SIZE(VAR_25);\n        VAR_24 = PyTuple_New(VAR_44);\n        if (VAR_24 == NULL)\n            goto cleanup;\n        for (Py_ssize_t VAR_45 = 0; VAR_45 < VAR_44; ++VAR_45) {\n            PyObject *VAR_46, *VAR_47;\n            if (PySequence_Fast_GET_SIZE(VAR_25) != VAR_44) {\n                PyErr_SetString(VAR_41, \"args changed during iteration\");\n                goto cleanup;\n            }\n            VAR_46 = PySequence_Fast_GET_ITEM(VAR_25, VAR_45);\n            if (PyUnicode_FSConverter(VAR_46, &VAR_47) == 0)\n                goto cleanup;\n            PyTuple_SET_ITEM(VAR_24, VAR_45, VAR_47);\n        }\n\n        VAR_32 = _PySequence_BytesToCharpArray(VAR_24);\n        Py_CLEAR(VAR_24);\n        Py_CLEAR(VAR_25);\n        if (!VAR_32)\n            goto cleanup;\n    }\n\n    if (VAR_6 != VAR_40) {\n        VAR_33 = _PySequence_BytesToCharpArray(VAR_6);\n        if (!VAR_33)\n            goto cleanup;\n    }\n\n    if (VAR_5 != VAR_40) {\n        if (PyUnicode_FSConverter(VAR_5, &VAR_28) == 0)\n            goto cleanup;\n        VAR_29 = PyBytes_AsString(VAR_28);\n    }\n\n    if (VAR_19 != VAR_40) {\n#ifdef VAR_48\n        if (!PyList_Check(VAR_19)) {\n            PyErr_SetString(VAR_49,\n                    \"setgroups argument must be a list\");\n            goto cleanup;\n        }\n        VAR_34 = PySequence_Size(VAR_19);\n\n        if (VAR_34 < 0)\n            goto cleanup;\n\n        if (VAR_34 > VAR_50) {\n            PyErr_SetString(VAR_42, \"too many extra_groups\");\n            goto cleanup;\n        }\n\n        /* COMMENT_8 */\n        if (VAR_34 > 0) {\n            VAR_27 = PyMem_RawMalloc(VAR_34 * sizeof(gid_t));\n            if (VAR_27 == NULL) {\n                PyErr_SetString(VAR_51,\n                        \"failed to allocate memory for group list\");\n                goto cleanup;\n            }\n        }\n\n        for (Py_ssize_t VAR_52 = 0; VAR_52 < VAR_34; VAR_52++) {\n            PyObject *VAR_53;\n            VAR_53 = PySequence_GetItem(VAR_19, VAR_52);\n            if (!VAR_53)\n                goto cleanup;\n            if (!PyLong_Check(VAR_53)) {\n                PyErr_SetString(VAR_49,\n                                \"extra_groups must be integers\");\n                Py_DECREF(VAR_53);\n                goto cleanup;\n            } else {\n                gid_t VAR_54;\n                if (!_Py_Gid_Converter(VAR_53, &VAR_54)) {\n                    Py_DECREF(VAR_53);\n                    PyErr_SetString(VAR_42, \"invalid group id\");\n                    goto cleanup;\n                }\n                VAR_27[VAR_52] = VAR_54;\n            }\n            Py_DECREF(VAR_53);\n        }\n\n#else /* COMMENT_9 */\n        PyErr_BadInternalCall();\n        goto cleanup;\n#endif /* COMMENT_9 */\n    }\n\n    gid_t VAR_54 = (gid_t)-1;\n    if (VAR_18 != VAR_40) {\n#ifdef VAR_55\n        if (!_Py_Gid_Converter(VAR_18, &VAR_54))\n            goto cleanup;\n\n#else /* COMMENT_10 */\n        PyErr_BadInternalCall();\n        goto cleanup;\n#endif /* COMMENT_11 */\n    }\n\n    uid_t VAR_56 = (uid_t)-1;\n    if (VAR_20 != VAR_40) {\n#ifdef VAR_57\n        if (!_Py_Uid_Converter(VAR_20, &VAR_56))\n            goto cleanup;\n\n#else /* COMMENT_11 */\n        PyErr_BadInternalCall();\n        goto cleanup;\n#endif /* COMMENT_11 */\n    }\n\n    VAR_37 = PyMem_Malloc(VAR_38 * sizeof(int));\n    if (VAR_37 == NULL) {\n        PyErr_SetString(VAR_51, \"failed to malloc c_fds_to_keep\");\n        goto cleanup;\n    }\n    if (convert_fds_to_keep_to_c(VAR_4, VAR_37) < 0) {\n        goto cleanup;\n    }\n\n    /* COMMENT_12 */\n                                                                       \n                                                                    \n    if (VAR_22 != VAR_40) {\n        VAR_26 = PyTuple_New(0);\n        if (!VAR_26)\n            goto cleanup;\n        PyOS_BeforeFork();\n        VAR_35 = 1;\n    }\n\n    /* COMMENT_15 */\n    const void *VAR_58 = NULL;\n#ifdef VAR_59\n    /* COMMENT_16 */\n    sigset_t VAR_60;\n    if (VAR_22 == VAR_40 && VAR_23 &&\n        VAR_56 == (uid_t)-1 && VAR_54 == (gid_t)-1 && VAR_34 < 0) {\n        /* COMMENT_17 */\n                                                                          \n                                                             \n                                                                          \n                                                                               \n                                                                           \n                                                                            \n                     \n           \n        sigset_t VAR_61;\n        sigfillset(&VAR_61);\n        if ((VAR_36 = pthread_sigmask(VAR_62, &VAR_61, &VAR_60))) {\n            goto cleanup;\n        }\n        VAR_58 = &VAR_60;\n    }\n#endif\n\n    VAR_30 = do_fork_exec(VAR_43, VAR_32, VAR_33, VAR_29,\n                       VAR_7, VAR_8, VAR_9, VAR_10,\n                       VAR_11, VAR_12, VAR_13, VAR_14,\n                       VAR_3, VAR_15, VAR_16, VAR_17,\n                       VAR_54, VAR_34, VAR_27,\n                       VAR_56, VAR_21, VAR_58,\n                       VAR_37, VAR_38,\n                       VAR_22, VAR_26);\n\n    /* COMMENT_26 */\n    if (VAR_30 == (pid_t)-1) {\n        /* COMMENT_27 */\n        VAR_36 = VAR_63;\n    }\n\n#ifdef VAR_59\n    if (VAR_58) {\n        /* COMMENT_28 */\n                                                                      \n                                              \n                                                                            \n                                                                         \n                                                               \n                                                     \n          \n                                                                   \n                                                                     \n                                                               \n                                     \n        (void) pthread_sigmask(VAR_64, VAR_58, NULL);\n    }\n#endif\n\n    if (VAR_35)\n        PyOS_AfterFork_Parent();\n\ncleanup:\n    if (VAR_37 != NULL) {\n        PyMem_Free(VAR_37);\n    }\n\n    if (VAR_36 != 0) {\n        VAR_63 = VAR_36;\n        /* COMMENT_40 */\n                                                                    \n        PyErr_SetFromErrno(VAR_65);\n    }\n\n    Py_XDECREF(VAR_26);\n    PyMem_RawFree(VAR_27);\n    Py_XDECREF(VAR_28);\n    if (VAR_33)\n        _Py_FreeCharPArray(VAR_33);\n    Py_XDECREF(VAR_24);\n    Py_XDECREF(VAR_25);\n    if (VAR_32)\n        _Py_FreeCharPArray(VAR_32);\n    if (VAR_43)\n        _Py_FreeCharPArray(VAR_43);\n\n    if (VAR_31) {\n        PyGC_Enable();\n    }\n\n    return VAR_30 == -1 ? NULL : PyLong_FromPid(VAR_30);\n}",
  "func_graph_path_before": "python/cpython/7a896fc464a6bceb9b95268b0141667645b2a8da/_posixsubprocess.c/vul/before/1.json",
  "func": "static PyObject *\nsubprocess_fork_exec_impl(PyObject *module, PyObject *process_args,\n                          PyObject *executable_list, int close_fds,\n                          PyObject *py_fds_to_keep, PyObject *cwd_obj,\n                          PyObject *env_list, int p2cread, int p2cwrite,\n                          int c2pread, int c2pwrite, int errread,\n                          int errwrite, int errpipe_read, int errpipe_write,\n                          int restore_signals, int call_setsid,\n                          pid_t pgid_to_set, PyObject *gid_object,\n                          PyObject *extra_groups_packed,\n                          PyObject *uid_object, int child_umask,\n                          PyObject *preexec_fn, int allow_vfork)\n/*[clinic end generated code: output=7ee4f6ee5cf22b5b input=51757287ef266ffa]*/\n{\n    PyObject *converted_args = NULL, *fast_args = NULL;\n    PyObject *preexec_fn_args_tuple = NULL;\n    gid_t *extra_groups = NULL;\n    PyObject *cwd_obj2 = NULL;\n    const char *cwd = NULL;\n    pid_t pid = -1;\n    int need_to_reenable_gc = 0;\n    char *const *argv = NULL, *const *envp = NULL;\n    int need_after_fork = 0;\n    int saved_errno = 0;\n    int *c_fds_to_keep = NULL;\n    Py_ssize_t fds_to_keep_len = PyTuple_GET_SIZE(py_fds_to_keep);\n\n    PyInterpreterState *interp = _PyInterpreterState_GET();\n    if ((preexec_fn != Py_None) && interp->finalizing) {\n        PyErr_SetString(PyExc_RuntimeError,\n                        \"preexec_fn not supported at interpreter shutdown\");\n        return NULL;\n    }\n    if ((preexec_fn != Py_None) && (interp != PyInterpreterState_Main())) {\n        PyErr_SetString(PyExc_RuntimeError,\n                        \"preexec_fn not supported within subinterpreters\");\n        return NULL;\n    }\n\n    if (close_fds && errpipe_write < 3) {  /* precondition */\n        PyErr_SetString(PyExc_ValueError, \"errpipe_write must be >= 3\");\n        return NULL;\n    }\n    if (_sanity_check_python_fd_sequence(py_fds_to_keep)) {\n        PyErr_SetString(PyExc_ValueError, \"bad value(s) in fds_to_keep\");\n        return NULL;\n    }\n\n    /* We need to call gc.disable() when we'll be calling preexec_fn */\n    if (preexec_fn != Py_None) {\n        need_to_reenable_gc = PyGC_Disable();\n    }\n\n    char *const *exec_array = _PySequence_BytesToCharpArray(executable_list);\n    if (!exec_array)\n        goto cleanup;\n\n    /* Convert args and env into appropriate arguments for exec() */\n    /* These conversions are done in the parent process to avoid allocating\n       or freeing memory in the child process. */\n    if (process_args != Py_None) {\n        Py_ssize_t num_args;\n        /* Equivalent to:  */\n        /*  tuple(PyUnicode_FSConverter(arg) for arg in process_args)  */\n        fast_args = PySequence_Fast(process_args, \"argv must be a tuple\");\n        if (fast_args == NULL)\n            goto cleanup;\n        num_args = PySequence_Fast_GET_SIZE(fast_args);\n        converted_args = PyTuple_New(num_args);\n        if (converted_args == NULL)\n            goto cleanup;\n        for (Py_ssize_t arg_num = 0; arg_num < num_args; ++arg_num) {\n            PyObject *borrowed_arg, *converted_arg;\n            if (PySequence_Fast_GET_SIZE(fast_args) != num_args) {\n                PyErr_SetString(PyExc_RuntimeError, \"args changed during iteration\");\n                goto cleanup;\n            }\n            borrowed_arg = PySequence_Fast_GET_ITEM(fast_args, arg_num);\n            if (PyUnicode_FSConverter(borrowed_arg, &converted_arg) == 0)\n                goto cleanup;\n            PyTuple_SET_ITEM(converted_args, arg_num, converted_arg);\n        }\n\n        argv = _PySequence_BytesToCharpArray(converted_args);\n        Py_CLEAR(converted_args);\n        Py_CLEAR(fast_args);\n        if (!argv)\n            goto cleanup;\n    }\n\n    if (env_list != Py_None) {\n        envp = _PySequence_BytesToCharpArray(env_list);\n        if (!envp)\n            goto cleanup;\n    }\n\n    if (cwd_obj != Py_None) {\n        if (PyUnicode_FSConverter(cwd_obj, &cwd_obj2) == 0)\n            goto cleanup;\n        cwd = PyBytes_AsString(cwd_obj2);\n    }\n\n    // Special initial value meaning that subprocess API was called with\n    // extra_groups=None leading to _posixsubprocess.fork_exec(gids=None).\n    // We use this to differentiate between code desiring a setgroups(0, NULL)\n    // call vs no call at all.  The fast vfork() code path could be used when\n    // there is no setgroups call.\n    Py_ssize_t extra_group_size = -2;\n\n    if (extra_groups_packed != Py_None) {\n#ifdef HAVE_SETGROUPS\n        if (!PyList_Check(extra_groups_packed)) {\n            PyErr_SetString(PyExc_TypeError,\n                    \"setgroups argument must be a list\");\n            goto cleanup;\n        }\n        extra_group_size = PySequence_Size(extra_groups_packed);\n\n        if (extra_group_size < 0)\n            goto cleanup;\n\n        if (extra_group_size > MAX_GROUPS) {\n            PyErr_SetString(PyExc_ValueError, \"too many extra_groups\");\n            goto cleanup;\n        }\n\n        /* Deliberately keep extra_groups == NULL for extra_group_size == 0 */\n        if (extra_group_size > 0) {\n            extra_groups = PyMem_RawMalloc(extra_group_size * sizeof(gid_t));\n            if (extra_groups == NULL) {\n                PyErr_SetString(PyExc_MemoryError,\n                        \"failed to allocate memory for group list\");\n                goto cleanup;\n            }\n        }\n\n        for (Py_ssize_t i = 0; i < extra_group_size; i++) {\n            PyObject *elem;\n            elem = PySequence_GetItem(extra_groups_packed, i);\n            if (!elem)\n                goto cleanup;\n            if (!PyLong_Check(elem)) {\n                PyErr_SetString(PyExc_TypeError,\n                                \"extra_groups must be integers\");\n                Py_DECREF(elem);\n                goto cleanup;\n            } else {\n                gid_t gid;\n                if (!_Py_Gid_Converter(elem, &gid)) {\n                    Py_DECREF(elem);\n                    PyErr_SetString(PyExc_ValueError, \"invalid group id\");\n                    goto cleanup;\n                }\n                extra_groups[i] = gid;\n            }\n            Py_DECREF(elem);\n        }\n\n#else /* HAVE_SETGROUPS */\n        PyErr_BadInternalCall();\n        goto cleanup;\n#endif /* HAVE_SETGROUPS */\n    }\n\n    gid_t gid = (gid_t)-1;\n    if (gid_object != Py_None) {\n#ifdef HAVE_SETREGID\n        if (!_Py_Gid_Converter(gid_object, &gid))\n            goto cleanup;\n\n#else /* HAVE_SETREGID */\n        PyErr_BadInternalCall();\n        goto cleanup;\n#endif /* HAVE_SETREUID */\n    }\n\n    uid_t uid = (uid_t)-1;\n    if (uid_object != Py_None) {\n#ifdef HAVE_SETREUID\n        if (!_Py_Uid_Converter(uid_object, &uid))\n            goto cleanup;\n\n#else /* HAVE_SETREUID */\n        PyErr_BadInternalCall();\n        goto cleanup;\n#endif /* HAVE_SETREUID */\n    }\n\n    c_fds_to_keep = PyMem_Malloc(fds_to_keep_len * sizeof(int));\n    if (c_fds_to_keep == NULL) {\n        PyErr_SetString(PyExc_MemoryError, \"failed to malloc c_fds_to_keep\");\n        goto cleanup;\n    }\n    if (convert_fds_to_keep_to_c(py_fds_to_keep, c_fds_to_keep) < 0) {\n        goto cleanup;\n    }\n\n    /* This must be the last thing done before fork() because we do not\n     * want to call PyOS_BeforeFork() if there is any chance of another\n     * error leading to the cleanup: code without calling fork(). */\n    if (preexec_fn != Py_None) {\n        preexec_fn_args_tuple = PyTuple_New(0);\n        if (!preexec_fn_args_tuple)\n            goto cleanup;\n        PyOS_BeforeFork();\n        need_after_fork = 1;\n    }\n\n    /* NOTE: When old_sigmask is non-NULL, do_fork_exec() may use vfork(). */\n    const void *old_sigmask = NULL;\n#ifdef VFORK_USABLE\n    /* Use vfork() only if it's safe. See the comment above child_exec(). */\n    sigset_t old_sigs;\n    if (preexec_fn == Py_None && allow_vfork &&\n        uid == (uid_t)-1 && gid == (gid_t)-1 && extra_group_size < 0) {\n        /* Block all signals to ensure that no signal handlers are run in the\n         * child process while it shares memory with us. Note that signals\n         * used internally by C libraries won't be blocked by\n         * pthread_sigmask(), but signal handlers installed by C libraries\n         * normally service only signals originating from *within the process*,\n         * so it should be sufficient to consider any library function that\n         * might send such a signal to be vfork-unsafe and do not call it in\n         * the child.\n         */\n        sigset_t all_sigs;\n        sigfillset(&all_sigs);\n        if ((saved_errno = pthread_sigmask(SIG_BLOCK, &all_sigs, &old_sigs))) {\n            goto cleanup;\n        }\n        old_sigmask = &old_sigs;\n    }\n#endif\n\n    pid = do_fork_exec(exec_array, argv, envp, cwd,\n                       p2cread, p2cwrite, c2pread, c2pwrite,\n                       errread, errwrite, errpipe_read, errpipe_write,\n                       close_fds, restore_signals, call_setsid, pgid_to_set,\n                       gid, extra_group_size, extra_groups,\n                       uid, child_umask, old_sigmask,\n                       c_fds_to_keep, fds_to_keep_len,\n                       preexec_fn, preexec_fn_args_tuple);\n\n    /* Parent (original) process */\n    if (pid == (pid_t)-1) {\n        /* Capture errno for the exception. */\n        saved_errno = errno;\n    }\n\n#ifdef VFORK_USABLE\n    if (old_sigmask) {\n        /* vfork() semantics guarantees that the parent is blocked\n         * until the child performs _exit() or execve(), so it is safe\n         * to unblock signals once we're here.\n         * Note that in environments where vfork() is implemented as fork(),\n         * such as QEMU user-mode emulation, the parent won't be blocked,\n         * but it won't share the address space with the child,\n         * so it's still safe to unblock the signals.\n         *\n         * We don't handle errors here because this call can't fail\n         * if valid arguments are given, and because there is no good\n         * way for the caller to deal with a failure to restore\n         * the thread signal mask. */\n        (void) pthread_sigmask(SIG_SETMASK, old_sigmask, NULL);\n    }\n#endif\n\n    if (need_after_fork)\n        PyOS_AfterFork_Parent();\n\ncleanup:\n    if (c_fds_to_keep != NULL) {\n        PyMem_Free(c_fds_to_keep);\n    }\n\n    if (saved_errno != 0) {\n        errno = saved_errno;\n        /* We can't call this above as PyOS_AfterFork_Parent() calls back\n         * into Python code which would see the unreturned error. */\n        PyErr_SetFromErrno(PyExc_OSError);\n    }\n\n    Py_XDECREF(preexec_fn_args_tuple);\n    PyMem_RawFree(extra_groups);\n    Py_XDECREF(cwd_obj2);\n    if (envp)\n        _Py_FreeCharPArray(envp);\n    Py_XDECREF(converted_args);\n    Py_XDECREF(fast_args);\n    if (argv)\n        _Py_FreeCharPArray(argv);\n    if (exec_array)\n        _Py_FreeCharPArray(exec_array);\n\n    if (need_to_reenable_gc) {\n        PyGC_Enable();\n    }\n\n    return pid == -1 ? NULL : PyLong_FromPid(pid);\n}",
  "abstract_func": "static PyObject *\nsubprocess_fork_exec_impl(PyObject *VAR_0, PyObject *VAR_1,\n                          PyObject *VAR_2, int VAR_3,\n                          PyObject *VAR_4, PyObject *VAR_5,\n                          PyObject *VAR_6, int VAR_7, int VAR_8,\n                          int VAR_9, int VAR_10, int VAR_11,\n                          int VAR_12, int VAR_13, int VAR_14,\n                          int VAR_15, int VAR_16,\n                          pid_t VAR_17, PyObject *VAR_18,\n                          PyObject *VAR_19,\n                          PyObject *VAR_20, int VAR_21,\n                          PyObject *VAR_22, int VAR_23)\n/* COMMENT_0 */\n{\n    PyObject *VAR_24 = NULL, *VAR_25 = NULL;\n    PyObject *VAR_26 = NULL;\n    gid_t *VAR_27 = NULL;\n    PyObject *VAR_28 = NULL;\n    const char *VAR_29 = NULL;\n    pid_t VAR_30 = -1;\n    int VAR_31 = 0;\n    char *const *VAR_32 = NULL, *const *VAR_33 = NULL;\n    int VAR_34 = 0;\n    int VAR_35 = 0;\n    int *VAR_36 = NULL;\n    Py_ssize_t VAR_37 = PyTuple_GET_SIZE(VAR_4);\n\n    PyInterpreterState *VAR_38 = _PyInterpreterState_GET();\n    if ((VAR_22 != VAR_39) && VAR_38->finalizing) {\n        PyErr_SetString(VAR_40,\n                        \"preexec_fn not supported at interpreter shutdown\");\n        return NULL;\n    }\n    if ((VAR_22 != VAR_39) && (VAR_38 != PyInterpreterState_Main())) {\n        PyErr_SetString(VAR_40,\n                        \"preexec_fn not supported within subinterpreters\");\n        return NULL;\n    }\n\n    if (VAR_3 && VAR_14 < 3) {  /* COMMENT_1 */\n        PyErr_SetString(VAR_41, \"errpipe_write must be >= 3\");\n        return NULL;\n    }\n    if (_sanity_check_python_fd_sequence(VAR_4)) {\n        PyErr_SetString(VAR_41, \"bad value(s) in fds_to_keep\");\n        return NULL;\n    }\n\n    /* COMMENT_2 */\n    if (VAR_22 != VAR_39) {\n        VAR_31 = PyGC_Disable();\n    }\n\n    char *const *VAR_42 = _PySequence_BytesToCharpArray(VAR_2);\n    if (!VAR_42)\n        goto cleanup;\n\n    /* COMMENT_3 */\n    /* COMMENT_4 */\n                                                 \n    if (VAR_1 != VAR_39) {\n        Py_ssize_t VAR_43;\n        /* COMMENT_6 */\n        /* COMMENT_7 */\n        VAR_25 = PySequence_Fast(VAR_1, \"argv must be a tuple\");\n        if (VAR_25 == NULL)\n            goto cleanup;\n        VAR_43 = PySequence_Fast_GET_SIZE(VAR_25);\n        VAR_24 = PyTuple_New(VAR_43);\n        if (VAR_24 == NULL)\n            goto cleanup;\n        for (Py_ssize_t VAR_44 = 0; VAR_44 < VAR_43; ++VAR_44) {\n            PyObject *VAR_45, *VAR_46;\n            if (PySequence_Fast_GET_SIZE(VAR_25) != VAR_43) {\n                PyErr_SetString(VAR_40, \"args changed during iteration\");\n                goto cleanup;\n            }\n            VAR_45 = PySequence_Fast_GET_ITEM(VAR_25, VAR_44);\n            if (PyUnicode_FSConverter(VAR_45, &VAR_46) == 0)\n                goto cleanup;\n            PyTuple_SET_ITEM(VAR_24, VAR_44, VAR_46);\n        }\n\n        VAR_32 = _PySequence_BytesToCharpArray(VAR_24);\n        Py_CLEAR(VAR_24);\n        Py_CLEAR(VAR_25);\n        if (!VAR_32)\n            goto cleanup;\n    }\n\n    if (VAR_6 != VAR_39) {\n        VAR_33 = _PySequence_BytesToCharpArray(VAR_6);\n        if (!VAR_33)\n            goto cleanup;\n    }\n\n    if (VAR_5 != VAR_39) {\n        if (PyUnicode_FSConverter(VAR_5, &VAR_28) == 0)\n            goto cleanup;\n        VAR_29 = PyBytes_AsString(VAR_28);\n    }\n\n    /* COMMENT_8 */\n    /* COMMENT_9 */\n    /* COMMENT_10 */\n    /* COMMENT_11 */\n    /* COMMENT_12 */\n    Py_ssize_t VAR_47 = -2;\n\n    if (VAR_19 != VAR_39) {\n#ifdef VAR_48\n        if (!PyList_Check(VAR_19)) {\n            PyErr_SetString(VAR_49,\n                    \"setgroups argument must be a list\");\n            goto cleanup;\n        }\n        VAR_47 = PySequence_Size(VAR_19);\n\n        if (VAR_47 < 0)\n            goto cleanup;\n\n        if (VAR_47 > VAR_50) {\n            PyErr_SetString(VAR_41, \"too many extra_groups\");\n            goto cleanup;\n        }\n\n        /* COMMENT_13 */\n        if (VAR_47 > 0) {\n            VAR_27 = PyMem_RawMalloc(VAR_47 * sizeof(gid_t));\n            if (VAR_27 == NULL) {\n                PyErr_SetString(VAR_51,\n                        \"failed to allocate memory for group list\");\n                goto cleanup;\n            }\n        }\n\n        for (Py_ssize_t VAR_52 = 0; VAR_52 < VAR_47; VAR_52++) {\n            PyObject *VAR_53;\n            VAR_53 = PySequence_GetItem(VAR_19, VAR_52);\n            if (!VAR_53)\n                goto cleanup;\n            if (!PyLong_Check(VAR_53)) {\n                PyErr_SetString(VAR_49,\n                                \"extra_groups must be integers\");\n                Py_DECREF(VAR_53);\n                goto cleanup;\n            } else {\n                gid_t VAR_54;\n                if (!_Py_Gid_Converter(VAR_53, &VAR_54)) {\n                    Py_DECREF(VAR_53);\n                    PyErr_SetString(VAR_41, \"invalid group id\");\n                    goto cleanup;\n                }\n                VAR_27[VAR_52] = VAR_54;\n            }\n            Py_DECREF(VAR_53);\n        }\n\n#else /* COMMENT_14 */\n        PyErr_BadInternalCall();\n        goto cleanup;\n#endif /* COMMENT_14 */\n    }\n\n    gid_t VAR_54 = (gid_t)-1;\n    if (VAR_18 != VAR_39) {\n#ifdef VAR_55\n        if (!_Py_Gid_Converter(VAR_18, &VAR_54))\n            goto cleanup;\n\n#else /* COMMENT_15 */\n        PyErr_BadInternalCall();\n        goto cleanup;\n#endif /* COMMENT_16 */\n    }\n\n    uid_t VAR_56 = (uid_t)-1;\n    if (VAR_20 != VAR_39) {\n#ifdef VAR_57\n        if (!_Py_Uid_Converter(VAR_20, &VAR_56))\n            goto cleanup;\n\n#else /* COMMENT_16 */\n        PyErr_BadInternalCall();\n        goto cleanup;\n#endif /* COMMENT_16 */\n    }\n\n    VAR_36 = PyMem_Malloc(VAR_37 * sizeof(int));\n    if (VAR_36 == NULL) {\n        PyErr_SetString(VAR_51, \"failed to malloc c_fds_to_keep\");\n        goto cleanup;\n    }\n    if (convert_fds_to_keep_to_c(VAR_4, VAR_36) < 0) {\n        goto cleanup;\n    }\n\n    /* COMMENT_17 */\n                                                                       \n                                                                    \n    if (VAR_22 != VAR_39) {\n        VAR_26 = PyTuple_New(0);\n        if (!VAR_26)\n            goto cleanup;\n        PyOS_BeforeFork();\n        VAR_34 = 1;\n    }\n\n    /* COMMENT_20 */\n    const void *VAR_58 = NULL;\n#ifdef VAR_59\n    /* COMMENT_21 */\n    sigset_t VAR_60;\n    if (VAR_22 == VAR_39 && VAR_23 &&\n        VAR_56 == (uid_t)-1 && VAR_54 == (gid_t)-1 && VAR_47 < 0) {\n        /* COMMENT_22 */\n                                                                          \n                                                             \n                                                                          \n                                                                               \n                                                                           \n                                                                            \n                     \n           \n        sigset_t VAR_61;\n        sigfillset(&VAR_61);\n        if ((VAR_35 = pthread_sigmask(VAR_62, &VAR_61, &VAR_60))) {\n            goto cleanup;\n        }\n        VAR_58 = &VAR_60;\n    }\n#endif\n\n    VAR_30 = do_fork_exec(VAR_42, VAR_32, VAR_33, VAR_29,\n                       VAR_7, VAR_8, VAR_9, VAR_10,\n                       VAR_11, VAR_12, VAR_13, VAR_14,\n                       VAR_3, VAR_15, VAR_16, VAR_17,\n                       VAR_54, VAR_47, VAR_27,\n                       VAR_56, VAR_21, VAR_58,\n                       VAR_36, VAR_37,\n                       VAR_22, VAR_26);\n\n    /* COMMENT_31 */\n    if (VAR_30 == (pid_t)-1) {\n        /* COMMENT_32 */\n        VAR_35 = VAR_63;\n    }\n\n#ifdef VAR_59\n    if (VAR_58) {\n        /* COMMENT_33 */\n                                                                      \n                                              \n                                                                            \n                                                                         \n                                                               \n                                                     \n          \n                                                                   \n                                                                     \n                                                               \n                                     \n        (void) pthread_sigmask(VAR_64, VAR_58, NULL);\n    }\n#endif\n\n    if (VAR_34)\n        PyOS_AfterFork_Parent();\n\ncleanup:\n    if (VAR_36 != NULL) {\n        PyMem_Free(VAR_36);\n    }\n\n    if (VAR_35 != 0) {\n        VAR_63 = VAR_35;\n        /* COMMENT_45 */\n                                                                    \n        PyErr_SetFromErrno(VAR_65);\n    }\n\n    Py_XDECREF(VAR_26);\n    PyMem_RawFree(VAR_27);\n    Py_XDECREF(VAR_28);\n    if (VAR_33)\n        _Py_FreeCharPArray(VAR_33);\n    Py_XDECREF(VAR_24);\n    Py_XDECREF(VAR_25);\n    if (VAR_32)\n        _Py_FreeCharPArray(VAR_32);\n    if (VAR_42)\n        _Py_FreeCharPArray(VAR_42);\n\n    if (VAR_31) {\n        PyGC_Enable();\n    }\n\n    return VAR_30 == -1 ? NULL : PyLong_FromPid(VAR_30);\n}",
  "func_graph_path": "python/cpython/7a896fc464a6bceb9b95268b0141667645b2a8da/_posixsubprocess.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -20,7 +20,6 @@\n     pid_t pid = -1;\n     int need_to_reenable_gc = 0;\n     char *const *argv = NULL, *const *envp = NULL;\n-    Py_ssize_t extra_group_size = 0;\n     int need_after_fork = 0;\n     int saved_errno = 0;\n     int *c_fds_to_keep = NULL;\n@@ -100,6 +99,13 @@\n             goto cleanup;\n         cwd = PyBytes_AsString(cwd_obj2);\n     }\n+\n+    // Special initial value meaning that subprocess API was called with\n+    // extra_groups=None leading to _posixsubprocess.fork_exec(gids=None).\n+    // We use this to differentiate between code desiring a setgroups(0, NULL)\n+    // call vs no call at all.  The fast vfork() code path could be used when\n+    // there is no setgroups call.\n+    Py_ssize_t extra_group_size = -2;\n \n     if (extra_groups_packed != Py_None) {\n #ifdef HAVE_SETGROUPS",
  "diff_line_info": {
    "deleted_lines": [
      "    Py_ssize_t extra_group_size = 0;"
    ],
    "added_lines": [
      "",
      "    // Special initial value meaning that subprocess API was called with",
      "    // extra_groups=None leading to _posixsubprocess.fork_exec(gids=None).",
      "    // We use this to differentiate between code desiring a setgroups(0, NULL)",
      "    // call vs no call at all.  The fast vfork() code path could be used when",
      "    // there is no setgroups call.",
      "    Py_ssize_t extra_group_size = -2;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/python/cpython/pull/112617",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/python/cpython/pull/112617: 403 Client Error: Forbidden for url: https://api.github.com/repos/python/cpython/pulls/112617",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "The patch addresses both a performance issue and a security bug related to improper handling of groups in subprocesses. The security aspect is confirmed by the assigned CVE and the code changes designed to fix it.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}