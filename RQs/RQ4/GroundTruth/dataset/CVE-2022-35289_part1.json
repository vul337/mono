{
  "cve_id": "CVE-2022-35289",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "facebook/hermes",
  "commit_msg": "Re-sync with internal repository (#791)\n\nCo-authored-by: Facebook Community Bot <6422482+facebook-github-bot@users.noreply.github.com>",
  "commit_hash": "5b6255ae049fa4641791e47fad994e8e8c4da374",
  "git_url": "https://github.com/facebook/hermes/commit/5b6255ae049fa4641791e47fad994e8e8c4da374",
  "file_path": "lib/VM/detail/IdentifierHashTable.cpp",
  "func_name": "IdentifierHashTable::growAndRehash",
  "func_before": "void IdentifierHashTable::growAndRehash(uint32_t newCapacity) {\n  assert(llvh::isPowerOf2_32(newCapacity) && \"capacity must be power of 2\");\n  CompactTable tmpTable(newCapacity, table_.getCurrentScale());\n  tmpTable.swap(table_);\n  for (uint32_t oldIdx = 0; oldIdx < tmpTable.size(); ++oldIdx) {\n    if (!tmpTable.isValid(oldIdx)) {\n      continue;\n    }\n    // Pass true as second argument as we know this string is not in the table.\n    uint32_t idx = 0;\n    uint32_t oldVal = tmpTable.get(oldIdx);\n    auto &lookupTableEntry = identifierTable_->getLookupTableEntry(oldVal);\n    uint32_t hash = lookupTableEntry.getHash();\n    if (lookupTableEntry.isStringPrim()) {\n      idx = lookupString(lookupTableEntry.getStringPrim(), hash, true);\n    } else if (lookupTableEntry.isLazyASCII()) {\n      idx = lookupString(lookupTableEntry.getLazyASCIIRef(), hash, true);\n    } else if (lookupTableEntry.isLazyUTF16()) {\n      idx = lookupString(lookupTableEntry.getLazyUTF16Ref(), hash, true);\n    }\n    table_.set(idx, oldVal);\n  }\n  nonEmptyEntryCount_ = size_;\n}",
  "abstract_func_before": "void IdentifierHashTable::growAndRehash(uint32_t VAR_0) {\n  assert(llvh::isPowerOf2_32(VAR_0) && \"capacity must be power of 2\");\n  CompactTable VAR_1(VAR_0, VAR_2.getCurrentScale());\n  VAR_1.swap(VAR_2);\n  for (uint32_t VAR_3 = 0; VAR_3 < VAR_1.size(); ++VAR_3) {\n    if (!VAR_1.isValid(VAR_3)) {\n      continue;\n    }\n    /* COMMENT_0 */\n    uint32_t VAR_4 = 0;\n    uint32_t VAR_5 = VAR_1.get(VAR_3);\n    auto &VAR_6 = VAR_7->getLookupTableEntry(VAR_5);\n    uint32_t VAR_8 = VAR_6.getHash();\n    if (VAR_6.isStringPrim()) {\n      VAR_4 = lookupString(VAR_6.getStringPrim(), VAR_8, true);\n    } else if (VAR_6.isLazyASCII()) {\n      VAR_4 = lookupString(VAR_6.getLazyASCIIRef(), VAR_8, true);\n    } else if (VAR_6.isLazyUTF16()) {\n      VAR_4 = lookupString(VAR_6.getLazyUTF16Ref(), VAR_8, true);\n    }\n    VAR_2.set(VAR_4, VAR_5);\n  }\n  VAR_9 = VAR_10;\n}",
  "func_graph_path_before": "facebook/hermes/5b6255ae049fa4641791e47fad994e8e8c4da374/IdentifierHashTable.cpp/vul/before/0.json",
  "func": "void IdentifierHashTable::growAndRehash(uint32_t newCapacity) {\n  // Guard against potential overflow in the calculation of new capacity.\n  if (LLVM_UNLIKELY(newCapacity <= capacity())) {\n    hermes_fatal(\"too many identifiers created\");\n  }\n  assert(llvh::isPowerOf2_32(newCapacity) && \"capacity must be power of 2\");\n  CompactTable tmpTable(newCapacity, table_.getCurrentScale());\n  tmpTable.swap(table_);\n  for (uint32_t oldIdx = 0; oldIdx < tmpTable.size(); ++oldIdx) {\n    if (!tmpTable.isValid(oldIdx)) {\n      continue;\n    }\n    // Pass true as second argument as we know this string is not in the table.\n    uint32_t idx = 0;\n    uint32_t oldVal = tmpTable.get(oldIdx);\n    auto &lookupTableEntry = identifierTable_->getLookupTableEntry(oldVal);\n    uint32_t hash = lookupTableEntry.getHash();\n    if (lookupTableEntry.isStringPrim()) {\n      idx = lookupString(lookupTableEntry.getStringPrim(), hash, true);\n    } else if (lookupTableEntry.isLazyASCII()) {\n      idx = lookupString(lookupTableEntry.getLazyASCIIRef(), hash, true);\n    } else if (lookupTableEntry.isLazyUTF16()) {\n      idx = lookupString(lookupTableEntry.getLazyUTF16Ref(), hash, true);\n    }\n    table_.set(idx, oldVal);\n  }\n  nonEmptyEntryCount_ = size_;\n}",
  "abstract_func": "void IdentifierHashTable::growAndRehash(uint32_t VAR_0) {\n  /* COMMENT_0 */\n  if (LLVM_UNLIKELY(VAR_0 <= capacity())) {\n    hermes_fatal(\"too many identifiers created\");\n  }\n  assert(llvh::isPowerOf2_32(VAR_0) && \"capacity must be power of 2\");\n  CompactTable VAR_1(VAR_0, VAR_2.getCurrentScale());\n  VAR_1.swap(VAR_2);\n  for (uint32_t VAR_3 = 0; VAR_3 < VAR_1.size(); ++VAR_3) {\n    if (!VAR_1.isValid(VAR_3)) {\n      continue;\n    }\n    /* COMMENT_1 */\n    uint32_t VAR_4 = 0;\n    uint32_t VAR_5 = VAR_1.get(VAR_3);\n    auto &VAR_6 = VAR_7->getLookupTableEntry(VAR_5);\n    uint32_t VAR_8 = VAR_6.getHash();\n    if (VAR_6.isStringPrim()) {\n      VAR_4 = lookupString(VAR_6.getStringPrim(), VAR_8, true);\n    } else if (VAR_6.isLazyASCII()) {\n      VAR_4 = lookupString(VAR_6.getLazyASCIIRef(), VAR_8, true);\n    } else if (VAR_6.isLazyUTF16()) {\n      VAR_4 = lookupString(VAR_6.getLazyUTF16Ref(), VAR_8, true);\n    }\n    VAR_2.set(VAR_4, VAR_5);\n  }\n  VAR_9 = VAR_10;\n}",
  "func_graph_path": "facebook/hermes/5b6255ae049fa4641791e47fad994e8e8c4da374/IdentifierHashTable.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,8 @@\n void IdentifierHashTable::growAndRehash(uint32_t newCapacity) {\n+  // Guard against potential overflow in the calculation of new capacity.\n+  if (LLVM_UNLIKELY(newCapacity <= capacity())) {\n+    hermes_fatal(\"too many identifiers created\");\n+  }\n   assert(llvh::isPowerOf2_32(newCapacity) && \"capacity must be power of 2\");\n   CompactTable tmpTable(newCapacity, table_.getCurrentScale());\n   tmpTable.swap(table_);",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "  // Guard against potential overflow in the calculation of new capacity.",
      "  if (LLVM_UNLIKELY(newCapacity <= capacity())) {",
      "    hermes_fatal(\"too many identifiers created\");",
      "  }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/facebook/hermes/pull/791",
  "description": {
    "pr_info": {
      "title": "Re-sync with internal repository",
      "number": 791
    },
    "comment": [
      "The internal and external repositories are out of sync. This attempts to brings them back in sync by patching the GitHub repository. Please carefully review this patch. You must disable ShipIt for your project in order to merge this pull request. DO NOT IMPORT this pull request. Instead, merge it directly on GitHub using the MERGE BUTTON. Re-enable ShipIt after merging."
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.7,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.7"
}