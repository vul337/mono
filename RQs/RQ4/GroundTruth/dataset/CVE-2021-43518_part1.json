{
  "cve_id": "CVE-2021-43518",
  "cwe_ids": [
    "CWE-120"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "teeworlds",
  "commit_msg": "hotfix CVE-2021-43518",
  "commit_hash": "91e5492d4c210f82f1ca6b43a73417fef5463368",
  "git_url": "https://github.com/teeworlds/teeworlds/commit/91e5492d4c210f82f1ca6b43a73417fef5463368",
  "file_path": "src/game/client/components/maplayers.cpp",
  "func_name": "CMapLayers::LoadEnvPoints",
  "func_before": "void CMapLayers::LoadEnvPoints(const CLayers *pLayers, array<CEnvPoint>& lEnvPoints)\n{\n\tlEnvPoints.clear();\n\n\t// get envelope points\n\tCEnvPoint *pPoints = 0x0;\n\t{\n\t\tint Start, Num;\n\t\tpLayers->Map()->GetType(MAPITEMTYPE_ENVPOINTS, &Start, &Num);\n\n\t\tif(!Num)\n\t\t\treturn;\n\n\t\tpPoints = (CEnvPoint *)pLayers->Map()->GetItem(Start, 0, 0);\n\t}\n\n\t// get envelopes\n\tint Start, Num;\n\tpLayers->Map()->GetType(MAPITEMTYPE_ENVELOPE, &Start, &Num);\n\tif(!Num)\n\t\treturn;\n\n\n\tfor(int env = 0; env < Num; env++)\n\t{\n\t\tCMapItemEnvelope *pItem = (CMapItemEnvelope *)pLayers->Map()->GetItem(Start+env, 0, 0);\n\n\t\tif(pItem->m_Version >= 3)\n\t\t{\n\t\t\tfor(int i = 0; i < pItem->m_NumPoints; i++)\n\t\t\t\tlEnvPoints.add(pPoints[i + pItem->m_StartPoint]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// backwards compatibility\n\t\t\tfor(int i = 0; i < pItem->m_NumPoints; i++)\n\t\t\t{\n\t\t\t\t// convert CEnvPoint_v1 -> CEnvPoint\n\t\t\t\tCEnvPoint_v1 *pEnvPoint_v1 = &((CEnvPoint_v1 *)pPoints)[i + pItem->m_StartPoint];\n\t\t\t\tCEnvPoint p;\n\n\t\t\t\tp.m_Time = pEnvPoint_v1->m_Time;\n\t\t\t\tp.m_Curvetype = pEnvPoint_v1->m_Curvetype;\n\n\t\t\t\tfor(int c = 0; c < pItem->m_Channels; c++)\n\t\t\t\t{\n\t\t\t\t\tp.m_aValues[c] = pEnvPoint_v1->m_aValues[c];\n\t\t\t\t\tp.m_aInTangentdx[c] = 0;\n\t\t\t\t\tp.m_aInTangentdy[c] = 0;\n\t\t\t\t\tp.m_aOutTangentdx[c] = 0;\n\t\t\t\t\tp.m_aOutTangentdy[c] = 0;\n\t\t\t\t}\n\n\t\t\t\tlEnvPoints.add(p);\n\t\t\t}\n\t\t}\n\t}\n}",
  "abstract_func_before": "void CMapLayers::LoadEnvPoints(const CLayers *VAR_0, array<CEnvPoint>& VAR_1)\n{\n\tVAR_1.clear();\n\n\t/* COMMENT_0 */\n\tCEnvPoint *VAR_2 = 0x0;\n\t{\n\t\tint VAR_3, VAR_4;\n\t\tVAR_0->Map()->GetType(VAR_5, &VAR_3, &VAR_4);\n\n\t\tif(!VAR_4)\n\t\t\treturn;\n\n\t\tVAR_2 = (CEnvPoint *)VAR_0->Map()->GetItem(VAR_3, 0, 0);\n\t}\n\n\t/* COMMENT_1 */\n\tint VAR_3, VAR_4;\n\tVAR_0->Map()->GetType(VAR_6, &VAR_3, &VAR_4);\n\tif(!VAR_4)\n\t\treturn;\n\n\n\tfor(int VAR_7 = 0; VAR_7 < VAR_4; VAR_7++)\n\t{\n\t\tCMapItemEnvelope *VAR_8 = (CMapItemEnvelope *)VAR_0->Map()->GetItem(VAR_3+VAR_7, 0, 0);\n\n\t\tif(VAR_8->m_Version >= 3)\n\t\t{\n\t\t\tfor(int VAR_9 = 0; VAR_9 < VAR_8->m_NumPoints; VAR_9++)\n\t\t\t\tVAR_1.add(VAR_2[VAR_9 + VAR_8->m_StartPoint]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* COMMENT_2 */\n\t\t\tfor(int VAR_9 = 0; VAR_9 < VAR_8->m_NumPoints; VAR_9++)\n\t\t\t{\n\t\t\t\t/* COMMENT_3 */\n\t\t\t\tCEnvPoint_v1 *VAR_10 = &((CEnvPoint_v1 *)VAR_2)[VAR_9 + VAR_8->m_StartPoint];\n\t\t\t\tCEnvPoint VAR_11;\n\n\t\t\t\tVAR_11.m_Time = VAR_10->m_Time;\n\t\t\t\tVAR_11.m_Curvetype = VAR_10->m_Curvetype;\n\n\t\t\t\tfor(int VAR_12 = 0; VAR_12 < VAR_8->m_Channels; VAR_12++)\n\t\t\t\t{\n\t\t\t\t\tVAR_11.m_aValues[VAR_12] = VAR_10->m_aValues[VAR_12];\n\t\t\t\t\tVAR_11.m_aInTangentdx[VAR_12] = 0;\n\t\t\t\t\tVAR_11.m_aInTangentdy[VAR_12] = 0;\n\t\t\t\t\tVAR_11.m_aOutTangentdx[VAR_12] = 0;\n\t\t\t\t\tVAR_11.m_aOutTangentdy[VAR_12] = 0;\n\t\t\t\t}\n\n\t\t\t\tVAR_1.add(VAR_11);\n\t\t\t}\n\t\t}\n\t}\n}",
  "func_graph_path_before": "teeworlds/91e5492d4c210f82f1ca6b43a73417fef5463368/maplayers.cpp/vul/before/0.json",
  "func": "void CMapLayers::LoadEnvPoints(const CLayers *pLayers, array<CEnvPoint>& lEnvPoints)\n{\n\tlEnvPoints.clear();\n\n\t// get envelope points\n\tCEnvPoint *pPoints = 0x0;\n\t{\n\t\tint Start, Num;\n\t\tpLayers->Map()->GetType(MAPITEMTYPE_ENVPOINTS, &Start, &Num);\n\n\t\tif(!Num)\n\t\t\treturn;\n\n\t\tpPoints = (CEnvPoint *)pLayers->Map()->GetItem(Start, 0, 0);\n\t}\n\n\t// get envelopes\n\tint Start, Num;\n\tpLayers->Map()->GetType(MAPITEMTYPE_ENVELOPE, &Start, &Num);\n\tif(!Num)\n\t\treturn;\n\n\n\tfor(int env = 0; env < Num; env++)\n\t{\n\t\tCMapItemEnvelope *pItem = (CMapItemEnvelope *)pLayers->Map()->GetItem(Start+env, 0, 0);\n\n\t\tif(pItem->m_Version >= 3)\n\t\t{\n\t\t\tfor(int i = 0; i < pItem->m_NumPoints; i++)\n\t\t\t\tlEnvPoints.add(pPoints[i + pItem->m_StartPoint]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// backwards compatibility\n\t\t\tfor(int i = 0; i < pItem->m_NumPoints; i++)\n\t\t\t{\n\t\t\t\t// convert CEnvPoint_v1 -> CEnvPoint\n\t\t\t\tCEnvPoint_v1 *pEnvPoint_v1 = &((CEnvPoint_v1 *)pPoints)[i + pItem->m_StartPoint];\n\t\t\t\tCEnvPoint p;\n\n\t\t\t\tp.m_Time = pEnvPoint_v1->m_Time;\n\t\t\t\tp.m_Curvetype = pEnvPoint_v1->m_Curvetype;\n\n\t\t\t\tfor(int c = 0; c < minimum(pItem->m_Channels, 4); c++)\n\t\t\t\t{\n\t\t\t\t\tp.m_aValues[c] = pEnvPoint_v1->m_aValues[c];\n\t\t\t\t\tp.m_aInTangentdx[c] = 0;\n\t\t\t\t\tp.m_aInTangentdy[c] = 0;\n\t\t\t\t\tp.m_aOutTangentdx[c] = 0;\n\t\t\t\t\tp.m_aOutTangentdy[c] = 0;\n\t\t\t\t}\n\n\t\t\t\tlEnvPoints.add(p);\n\t\t\t}\n\t\t}\n\t}\n}",
  "abstract_func": "void CMapLayers::LoadEnvPoints(const CLayers *VAR_0, array<CEnvPoint>& VAR_1)\n{\n\tVAR_1.clear();\n\n\t/* COMMENT_0 */\n\tCEnvPoint *VAR_2 = 0x0;\n\t{\n\t\tint VAR_3, VAR_4;\n\t\tVAR_0->Map()->GetType(VAR_5, &VAR_3, &VAR_4);\n\n\t\tif(!VAR_4)\n\t\t\treturn;\n\n\t\tVAR_2 = (CEnvPoint *)VAR_0->Map()->GetItem(VAR_3, 0, 0);\n\t}\n\n\t/* COMMENT_1 */\n\tint VAR_3, VAR_4;\n\tVAR_0->Map()->GetType(VAR_6, &VAR_3, &VAR_4);\n\tif(!VAR_4)\n\t\treturn;\n\n\n\tfor(int VAR_7 = 0; VAR_7 < VAR_4; VAR_7++)\n\t{\n\t\tCMapItemEnvelope *VAR_8 = (CMapItemEnvelope *)VAR_0->Map()->GetItem(VAR_3+VAR_7, 0, 0);\n\n\t\tif(VAR_8->m_Version >= 3)\n\t\t{\n\t\t\tfor(int VAR_9 = 0; VAR_9 < VAR_8->m_NumPoints; VAR_9++)\n\t\t\t\tVAR_1.add(VAR_2[VAR_9 + VAR_8->m_StartPoint]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* COMMENT_2 */\n\t\t\tfor(int VAR_9 = 0; VAR_9 < VAR_8->m_NumPoints; VAR_9++)\n\t\t\t{\n\t\t\t\t/* COMMENT_3 */\n\t\t\t\tCEnvPoint_v1 *VAR_10 = &((CEnvPoint_v1 *)VAR_2)[VAR_9 + VAR_8->m_StartPoint];\n\t\t\t\tCEnvPoint VAR_11;\n\n\t\t\t\tVAR_11.m_Time = VAR_10->m_Time;\n\t\t\t\tVAR_11.m_Curvetype = VAR_10->m_Curvetype;\n\n\t\t\t\tfor(int VAR_12 = 0; VAR_12 < minimum(VAR_8->m_Channels, 4); VAR_12++)\n\t\t\t\t{\n\t\t\t\t\tVAR_11.m_aValues[VAR_12] = VAR_10->m_aValues[VAR_12];\n\t\t\t\t\tVAR_11.m_aInTangentdx[VAR_12] = 0;\n\t\t\t\t\tVAR_11.m_aInTangentdy[VAR_12] = 0;\n\t\t\t\t\tVAR_11.m_aOutTangentdx[VAR_12] = 0;\n\t\t\t\t\tVAR_11.m_aOutTangentdy[VAR_12] = 0;\n\t\t\t\t}\n\n\t\t\t\tVAR_1.add(VAR_11);\n\t\t\t}\n\t\t}\n\t}\n}",
  "func_graph_path": "teeworlds/91e5492d4c210f82f1ca6b43a73417fef5463368/maplayers.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -42,7 +42,7 @@\n \t\t\t\tp.m_Time = pEnvPoint_v1->m_Time;\n \t\t\t\tp.m_Curvetype = pEnvPoint_v1->m_Curvetype;\n \n-\t\t\t\tfor(int c = 0; c < pItem->m_Channels; c++)\n+\t\t\t\tfor(int c = 0; c < minimum(pItem->m_Channels, 4); c++)\n \t\t\t\t{\n \t\t\t\t\tp.m_aValues[c] = pEnvPoint_v1->m_aValues[c];\n \t\t\t\t\tp.m_aInTangentdx[c] = 0;",
  "diff_line_info": {
    "deleted_lines": [
      "\t\t\t\tfor(int c = 0; c < pItem->m_Channels; c++)"
    ],
    "added_lines": [
      "\t\t\t\tfor(int c = 0; c < minimum(pItem->m_Channels, 4); c++)"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/teeworlds/teeworlds/pull/3018",
  "description": {
    "pr_info": {
      "title": "Hotfix CVE-2021-43518",
      "number": 3018
    },
    "comment": [
      "Hotfix for CVE-2021-43518. Closes #2981.\r\n\r\nAdding all the datafile validation (#2931) ended up being a rather large patch and it still needs some work. This hotfix just addresses the exploitable stack buffer overflow write.\r\n\r\nFixing the other issues individually would be pointless, as there are at least 50-100 more distinct maps that can crash the client or cause ASAN/UBSAN errors.",
      "I'm confused, why wasn't this released?",
      "> I'm confused, why wasn't this released?\r\n\r\nI guess because the proper fix it still a work in progress in https://github.com/teeworlds/teeworlds/pull/2931",
      "I don't understand the point of a *hotfix* if it isn't meant to be released immediately while the proper fix is in progress.",
      "> I don't understand the point of a _hotfix_ if it isn't meant to be released immediately while the proper fix is in progress.\r\n\r\nSafety for developers and others who build from source :D\r\nBut yea I guess you have a point here."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}