{
  "cve_id": "CVE-2020-12140",
  "cwe_ids": [
    "CWE-120"
  ],
  "cvss_vector": "AV:A/AC:L/Au:N/C:C/I:C/A:C",
  "cvss_is_v3": false,
  "repo_name": "contiki-ng",
  "commit_msg": "Changed the second overflow check to prevent integer overflows",
  "commit_hash": "280019dce685bd5cfa217880762976980aeecf30",
  "git_url": "https://github.com/contiki-ng/contiki-ng/commit/280019dce685bd5cfa217880762976980aeecf30",
  "file_path": "os/net/mac/ble/ble-l2cap.c",
  "func_name": "input_l2cap_frame_flow_channel",
  "func_before": "static void\ninput_l2cap_frame_flow_channel(l2cap_channel_t *channel, uint8_t *data, uint16_t data_len)\n{\n  uint16_t frame_len;\n  uint16_t payload_len;\n\n  if(data_len < 4) {\n    LOG_WARN(\"l2cap_frame: illegal L2CAP frame data_len: %d\\n\", data_len);\n    /* a L2CAP frame has a minimum length of 4 */\n    return;\n  }\n\n  if(channel->rx_buffer.sdu_length == 0) {\n    /* handle first fragment */\n    memcpy(&frame_len, &data[0], 2);\n    payload_len = frame_len - 2;\n\n    if(payload_len > BLE_L2CAP_NODE_MTU) {\n    \tLOG_WARN(\"l2cap_frame: illegal L2CAP frame payload_len: %d\\n\", payload_len);\n    \t/* the payload length may not be larger than the destination buffer */\n    \treturn;\n    }\n\n    memcpy(&channel->rx_buffer.sdu_length, &data[4], 2);\n\n    memcpy(channel->rx_buffer.sdu, &data[6], payload_len);\n    channel->rx_buffer.current_index = payload_len;\n  } else {\n    /* subsequent fragment */\n    memcpy(&frame_len, &data[0], 2);\n    payload_len = frame_len;\n    \n    if(channel->rx_buffer.current_index + payload_len > BLE_L2CAP_NODE_MTU) {\n    \tLOG_WARN(\"l2cap_frame: illegal L2CAP frame payload_len: %d\\n\", payload_len);\n    \t/* the current index plus the payload length may not be larger than \n\t * the destination buffer */\n    \treturn;\n    }\n\n    memcpy(&channel->rx_buffer.sdu[channel->rx_buffer.current_index], &data[4], payload_len);\n    channel->rx_buffer.current_index += payload_len;\n  }\n\n  if((channel->rx_buffer.sdu_length > 0) &&\n     (channel->rx_buffer.sdu_length == channel->rx_buffer.current_index)) {\n    /* do not use packetbuf_copyfrom here because the packetbuf_attr\n     * must not be cleared */\n    memcpy(packetbuf_dataptr(), channel->rx_buffer.sdu, channel->rx_buffer.sdu_length);\n    packetbuf_set_datalen(channel->rx_buffer.sdu_length);\n    NETSTACK_NETWORK.input();\n\n    /* reset counters */\n    channel->rx_buffer.sdu_length = 0;\n    channel->rx_buffer.current_index = 0;\n  }\n}",
  "abstract_func_before": "static void\ninput_l2cap_frame_flow_channel(l2cap_channel_t *VAR_0, uint8_t *VAR_1, uint16_t VAR_2)\n{\n  uint16_t VAR_3;\n  uint16_t VAR_4;\n\n  if(VAR_2 < 4) {\n    LOG_WARN(\"l2cap_frame: illegal L2CAP frame data_len: %d\\n\", VAR_2);\n    /* COMMENT_0 */\n    return;\n  }\n\n  if(VAR_0->rx_buffer.sdu_length == 0) {\n    /* COMMENT_1 */\n    memcpy(&VAR_3, &VAR_1[0], 2);\n    VAR_4 = VAR_3 - 2;\n\n    if(VAR_4 > VAR_5) {\n    \tLOG_WARN(\"l2cap_frame: illegal L2CAP frame payload_len: %d\\n\", VAR_4);\n    \t/* COMMENT_2 */\n    \treturn;\n    }\n\n    memcpy(&VAR_0->rx_buffer.sdu_length, &VAR_1[4], 2);\n\n    memcpy(VAR_0->rx_buffer.sdu, &VAR_1[6], VAR_4);\n    VAR_0->rx_buffer.current_index = VAR_4;\n  } else {\n    /* COMMENT_3 */\n    memcpy(&VAR_3, &VAR_1[0], 2);\n    VAR_4 = VAR_3;\n    \n    if(VAR_0->rx_buffer.current_index + VAR_4 > VAR_5) {\n    \tLOG_WARN(\"l2cap_frame: illegal L2CAP frame payload_len: %d\\n\", VAR_4);\n    \t/* COMMENT_4 */\n                             \n    \treturn;\n    }\n\n    memcpy(&VAR_0->rx_buffer.sdu[VAR_0->rx_buffer.current_index], &VAR_1[4], VAR_4);\n    VAR_0->rx_buffer.current_index += VAR_4;\n  }\n\n  if((VAR_0->rx_buffer.sdu_length > 0) &&\n     (VAR_0->rx_buffer.sdu_length == VAR_0->rx_buffer.current_index)) {\n    /* COMMENT_6 */\n                             \n    memcpy(packetbuf_dataptr(), VAR_0->rx_buffer.sdu, VAR_0->rx_buffer.sdu_length);\n    packetbuf_set_datalen(VAR_0->rx_buffer.sdu_length);\n    VAR_6.input();\n\n    /* COMMENT_8 */\n    VAR_0->rx_buffer.sdu_length = 0;\n    VAR_0->rx_buffer.current_index = 0;\n  }\n}",
  "func_graph_path_before": "contiki-ng/280019dce685bd5cfa217880762976980aeecf30/ble-l2cap.c/vul/before/0.json",
  "func": "static void\ninput_l2cap_frame_flow_channel(l2cap_channel_t *channel, uint8_t *data, uint16_t data_len)\n{\n  uint16_t frame_len;\n  uint16_t payload_len;\n\n  if(data_len < 4) {\n    LOG_WARN(\"l2cap_frame: illegal L2CAP frame data_len: %d\\n\", data_len);\n    /* a L2CAP frame has a minimum length of 4 */\n    return;\n  }\n\n  if(channel->rx_buffer.sdu_length == 0) {\n    /* handle first fragment */\n    memcpy(&frame_len, &data[0], 2);\n    payload_len = frame_len - 2;\n\n    if(payload_len > BLE_L2CAP_NODE_MTU) {\n    \tLOG_WARN(\"l2cap_frame: illegal L2CAP frame payload_len: %d\\n\", payload_len);\n    \t/* the payload length may not be larger than the destination buffer */\n    \treturn;\n    }\n\n    memcpy(&channel->rx_buffer.sdu_length, &data[4], 2);\n\n    memcpy(channel->rx_buffer.sdu, &data[6], payload_len);\n    channel->rx_buffer.current_index = payload_len;\n  } else {\n    /* subsequent fragment */\n    memcpy(&frame_len, &data[0], 2);\n    payload_len = frame_len;\n    \n    if(payload_len > BLE_L2CAP_NODE_MTU - channel->rx_buffer.current_index) {\n    \tLOG_WARN(\"l2cap_frame: illegal L2CAP frame payload_len: %d\\n\", payload_len);\n    \t/* the current index plus the payload length may not be larger than \n\t * the destination buffer */\n    \treturn;\n    }\n\n    memcpy(&channel->rx_buffer.sdu[channel->rx_buffer.current_index], &data[4], payload_len);\n    channel->rx_buffer.current_index += payload_len;\n  }\n\n  if((channel->rx_buffer.sdu_length > 0) &&\n     (channel->rx_buffer.sdu_length == channel->rx_buffer.current_index)) {\n    /* do not use packetbuf_copyfrom here because the packetbuf_attr\n     * must not be cleared */\n    memcpy(packetbuf_dataptr(), channel->rx_buffer.sdu, channel->rx_buffer.sdu_length);\n    packetbuf_set_datalen(channel->rx_buffer.sdu_length);\n    NETSTACK_NETWORK.input();\n\n    /* reset counters */\n    channel->rx_buffer.sdu_length = 0;\n    channel->rx_buffer.current_index = 0;\n  }\n}",
  "abstract_func": "static void\ninput_l2cap_frame_flow_channel(l2cap_channel_t *VAR_0, uint8_t *VAR_1, uint16_t VAR_2)\n{\n  uint16_t VAR_3;\n  uint16_t VAR_4;\n\n  if(VAR_2 < 4) {\n    LOG_WARN(\"l2cap_frame: illegal L2CAP frame data_len: %d\\n\", VAR_2);\n    /* COMMENT_0 */\n    return;\n  }\n\n  if(VAR_0->rx_buffer.sdu_length == 0) {\n    /* COMMENT_1 */\n    memcpy(&VAR_3, &VAR_1[0], 2);\n    VAR_4 = VAR_3 - 2;\n\n    if(VAR_4 > VAR_5) {\n    \tLOG_WARN(\"l2cap_frame: illegal L2CAP frame payload_len: %d\\n\", VAR_4);\n    \t/* COMMENT_2 */\n    \treturn;\n    }\n\n    memcpy(&VAR_0->rx_buffer.sdu_length, &VAR_1[4], 2);\n\n    memcpy(VAR_0->rx_buffer.sdu, &VAR_1[6], VAR_4);\n    VAR_0->rx_buffer.current_index = VAR_4;\n  } else {\n    /* COMMENT_3 */\n    memcpy(&VAR_3, &VAR_1[0], 2);\n    VAR_4 = VAR_3;\n    \n    if(VAR_4 > VAR_5 - VAR_0->rx_buffer.current_index) {\n    \tLOG_WARN(\"l2cap_frame: illegal L2CAP frame payload_len: %d\\n\", VAR_4);\n    \t/* COMMENT_4 */\n                             \n    \treturn;\n    }\n\n    memcpy(&VAR_0->rx_buffer.sdu[VAR_0->rx_buffer.current_index], &VAR_1[4], VAR_4);\n    VAR_0->rx_buffer.current_index += VAR_4;\n  }\n\n  if((VAR_0->rx_buffer.sdu_length > 0) &&\n     (VAR_0->rx_buffer.sdu_length == VAR_0->rx_buffer.current_index)) {\n    /* COMMENT_6 */\n                             \n    memcpy(packetbuf_dataptr(), VAR_0->rx_buffer.sdu, VAR_0->rx_buffer.sdu_length);\n    packetbuf_set_datalen(VAR_0->rx_buffer.sdu_length);\n    VAR_6.input();\n\n    /* COMMENT_8 */\n    VAR_0->rx_buffer.sdu_length = 0;\n    VAR_0->rx_buffer.current_index = 0;\n  }\n}",
  "func_graph_path": "contiki-ng/280019dce685bd5cfa217880762976980aeecf30/ble-l2cap.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -30,7 +30,7 @@\n     memcpy(&frame_len, &data[0], 2);\n     payload_len = frame_len;\n     \n-    if(channel->rx_buffer.current_index + payload_len > BLE_L2CAP_NODE_MTU) {\n+    if(payload_len > BLE_L2CAP_NODE_MTU - channel->rx_buffer.current_index) {\n     \tLOG_WARN(\"l2cap_frame: illegal L2CAP frame payload_len: %d\\n\", payload_len);\n     \t/* the current index plus the payload length may not be larger than \n \t * the destination buffer */",
  "diff_line_info": {
    "deleted_lines": [
      "    if(channel->rx_buffer.current_index + payload_len > BLE_L2CAP_NODE_MTU) {"
    ],
    "added_lines": [
      "    if(payload_len > BLE_L2CAP_NODE_MTU - channel->rx_buffer.current_index) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/contiki-ng/contiki-ng/pull/1662",
  "description": {
    "pr_info": {
      "title": "Fix for buffer overflow in BLE L2CAP",
      "number": 1662
    },
    "comment": [
      "This PR fixes a buffer overflow in the BLE L2CAP credit-based flow control.  \r\n\r\nThe overflow occurs in the `input_l2cap_frame_flow_channel` function, as an adversary is able to control the amount of data copied by memcpy ([source](https://github.com/contiki-ng/contiki-ng/blob/release/v4.4/os/net/mac/ble/ble-l2cap.c#L424)).\r\n\r\nTo fix this issue I suggest to:\r\n\r\n- Add a condition for the first fragment that checks, whether the received `payload_len` is larger than `BLE_L2CAP_NODE_MTU`, which is the length of the destination array.\r\n- Add an integer overflow resistant condition for the subsequent fragments that checks, whether the sum of the received `payload_len` of the current fragment and the `current_index` of the `rx_buffer` is larger than `BLE_L2CAP_NODE_MTU`, which is the length of the destination array.\r\n\r\nIn both cases illegal frames are simply dropped.\r\n",
      "Thanks for the fix, which checks that the destination buffer has enough space. While inspecting the code, it appears that it lacks more checks on length values extracted from input packets. This includes the <code>frame_len</code> (which should be checked against the available source data length <code>data_len</code>) and the <code>channel->rx_buffer.sdu_length</code> values. It is not necessary to fix it in this pull request, however.",
      "The merge of this pull request fixes the issue of a previously reserved CVE:\r\nCVEID: 2020-12140\r\nPRODUCT: Contiki-NG\r\nVERSION: the issue affects versions 4.7 and earlier\r\nPROBLEM TYPE: Memory Corruption allowing Remote Code Execution due to Buffer Overflow\r\nDESCRIPTION: A buffer overflow in os/net/mac/ble/ble-l2cap.c in the BLE stack in Contiki-NG 4.7 and earlier\r\nallows an attacker to execute arbitrary code via malicious L2CAP frames."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}