{
  "cve_id": "CVE-2023-45145",
  "cwe_ids": [
    "CWE-668"
  ],
  "cvss_vector": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:N",
  "cvss_is_v3": true,
  "repo_name": "redis",
  "commit_msg": "Fix issue of listen before chmod on Unix sockets (CVE-2023-45145) (#12671)\n\nBefore this commit, Unix socket setup performed chmod(2) on the socket\r\nfile after calling listen(2). Depending on what umask is used, this\r\ncould leave the file with the wrong permissions for a short period of\r\ntime. As a result, another process could exploit this race condition and\r\nestablish a connection that would otherwise not be possible.\r\n\r\nWe now make sure the socket permissions are set up prior to calling\r\nlisten(2).\r\n\r\n(cherry picked from commit 1119ecae6fd8796fa337df2212f09173ab6c7b0a)\r\n\r\nCo-authored-by: Yossi Gottlieb <yossigo@gmail.com>",
  "commit_hash": "03345ddc7faf7af079485f2cbe5d17a1611cbce1",
  "git_url": "https://github.com/redis/redis/commit/03345ddc7faf7af079485f2cbe5d17a1611cbce1",
  "file_path": "src/anet.c",
  "func_name": "_anetTcpServer",
  "func_before": "static int _anetTcpServer(char *err, int port, char *bindaddr, int af, int backlog)\n{\n    int s = -1, rv;\n    char _port[6];  /* strlen(\"65535\") */\n    struct addrinfo hints, *servinfo, *p;\n\n    snprintf(_port,6,\"%d\",port);\n    memset(&hints,0,sizeof(hints));\n    hints.ai_family = af;\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_flags = AI_PASSIVE;    /* No effect if bindaddr != NULL */\n    if (bindaddr && !strcmp(\"*\", bindaddr))\n        bindaddr = NULL;\n    if (af == AF_INET6 && bindaddr && !strcmp(\"::*\", bindaddr))\n        bindaddr = NULL;\n\n    if ((rv = getaddrinfo(bindaddr,_port,&hints,&servinfo)) != 0) {\n        anetSetError(err, \"%s\", gai_strerror(rv));\n        return ANET_ERR;\n    }\n    for (p = servinfo; p != NULL; p = p->ai_next) {\n        if ((s = socket(p->ai_family,p->ai_socktype,p->ai_protocol)) == -1)\n            continue;\n\n        if (af == AF_INET6 && anetV6Only(err,s) == ANET_ERR) goto error;\n        if (anetSetReuseAddr(err,s) == ANET_ERR) goto error;\n        if (anetListen(err,s,p->ai_addr,p->ai_addrlen,backlog) == ANET_ERR) s = ANET_ERR;\n        goto end;\n    }\n    if (p == NULL) {\n        anetSetError(err, \"unable to bind socket, errno: %d\", errno);\n        goto error;\n    }\n\nerror:\n    if (s != -1) close(s);\n    s = ANET_ERR;\nend:\n    freeaddrinfo(servinfo);\n    return s;\n}",
  "abstract_func_before": "static int _anetTcpServer(char *VAR_0, int VAR_1, char *VAR_2, int VAR_3, int VAR_4)\n{\n    int VAR_5 = -1, VAR_6;\n    char VAR_7[6];  /* COMMENT_0 */\n    struct addrinfo VAR_8, *VAR_9, *VAR_10;\n\n    snprintf(VAR_7,6,\"%d\",VAR_1);\n    memset(&VAR_8,0,sizeof(VAR_8));\n    VAR_8.ai_family = VAR_3;\n    VAR_8.ai_socktype = VAR_11;\n    VAR_8.ai_flags = VAR_12;    /* COMMENT_1 */\n    if (VAR_2 && !strcmp(\"*\", VAR_2))\n        VAR_2 = NULL;\n    if (VAR_3 == VAR_13 && VAR_2 && !strcmp(\"::*\", VAR_2))\n        VAR_2 = NULL;\n\n    if ((VAR_6 = getaddrinfo(VAR_2,VAR_7,&VAR_8,&VAR_9)) != 0) {\n        anetSetError(VAR_0, \"%s\", gai_strerror(VAR_6));\n        return VAR_14;\n    }\n    for (VAR_10 = VAR_9; VAR_10 != NULL; VAR_10 = VAR_10->ai_next) {\n        if ((VAR_5 = socket(VAR_10->ai_family,VAR_10->ai_socktype,VAR_10->ai_protocol)) == -1)\n            continue;\n\n        if (VAR_3 == VAR_13 && anetV6Only(VAR_0,VAR_5) == VAR_14) goto error;\n        if (anetSetReuseAddr(VAR_0,VAR_5) == VAR_14) goto error;\n        if (anetListen(VAR_0,VAR_5,VAR_10->ai_addr,VAR_10->ai_addrlen,VAR_4) == VAR_14) VAR_5 = VAR_14;\n        goto end;\n    }\n    if (VAR_10 == NULL) {\n        anetSetError(VAR_0, \"unable to bind socket, errno: %d\", VAR_15);\n        goto error;\n    }\n\nerror:\n    if (VAR_5 != -1) close(VAR_5);\n    VAR_5 = VAR_14;\nend:\n    freeaddrinfo(VAR_9);\n    return VAR_5;\n}",
  "func_graph_path_before": "redis/03345ddc7faf7af079485f2cbe5d17a1611cbce1/anet.c/vul/before/2.json",
  "func": "static int _anetTcpServer(char *err, int port, char *bindaddr, int af, int backlog)\n{\n    int s = -1, rv;\n    char _port[6];  /* strlen(\"65535\") */\n    struct addrinfo hints, *servinfo, *p;\n\n    snprintf(_port,6,\"%d\",port);\n    memset(&hints,0,sizeof(hints));\n    hints.ai_family = af;\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_flags = AI_PASSIVE;    /* No effect if bindaddr != NULL */\n    if (bindaddr && !strcmp(\"*\", bindaddr))\n        bindaddr = NULL;\n    if (af == AF_INET6 && bindaddr && !strcmp(\"::*\", bindaddr))\n        bindaddr = NULL;\n\n    if ((rv = getaddrinfo(bindaddr,_port,&hints,&servinfo)) != 0) {\n        anetSetError(err, \"%s\", gai_strerror(rv));\n        return ANET_ERR;\n    }\n    for (p = servinfo; p != NULL; p = p->ai_next) {\n        if ((s = socket(p->ai_family,p->ai_socktype,p->ai_protocol)) == -1)\n            continue;\n\n        if (af == AF_INET6 && anetV6Only(err,s) == ANET_ERR) goto error;\n        if (anetSetReuseAddr(err,s) == ANET_ERR) goto error;\n        if (anetListen(err,s,p->ai_addr,p->ai_addrlen,backlog,0) == ANET_ERR) s = ANET_ERR;\n        goto end;\n    }\n    if (p == NULL) {\n        anetSetError(err, \"unable to bind socket, errno: %d\", errno);\n        goto error;\n    }\n\nerror:\n    if (s != -1) close(s);\n    s = ANET_ERR;\nend:\n    freeaddrinfo(servinfo);\n    return s;\n}",
  "abstract_func": "static int _anetTcpServer(char *VAR_0, int VAR_1, char *VAR_2, int VAR_3, int VAR_4)\n{\n    int VAR_5 = -1, VAR_6;\n    char VAR_7[6];  /* COMMENT_0 */\n    struct addrinfo VAR_8, *VAR_9, *VAR_10;\n\n    snprintf(VAR_7,6,\"%d\",VAR_1);\n    memset(&VAR_8,0,sizeof(VAR_8));\n    VAR_8.ai_family = VAR_3;\n    VAR_8.ai_socktype = VAR_11;\n    VAR_8.ai_flags = VAR_12;    /* COMMENT_1 */\n    if (VAR_2 && !strcmp(\"*\", VAR_2))\n        VAR_2 = NULL;\n    if (VAR_3 == VAR_13 && VAR_2 && !strcmp(\"::*\", VAR_2))\n        VAR_2 = NULL;\n\n    if ((VAR_6 = getaddrinfo(VAR_2,VAR_7,&VAR_8,&VAR_9)) != 0) {\n        anetSetError(VAR_0, \"%s\", gai_strerror(VAR_6));\n        return VAR_14;\n    }\n    for (VAR_10 = VAR_9; VAR_10 != NULL; VAR_10 = VAR_10->ai_next) {\n        if ((VAR_5 = socket(VAR_10->ai_family,VAR_10->ai_socktype,VAR_10->ai_protocol)) == -1)\n            continue;\n\n        if (VAR_3 == VAR_13 && anetV6Only(VAR_0,VAR_5) == VAR_14) goto error;\n        if (anetSetReuseAddr(VAR_0,VAR_5) == VAR_14) goto error;\n        if (anetListen(VAR_0,VAR_5,VAR_10->ai_addr,VAR_10->ai_addrlen,VAR_4,0) == VAR_14) VAR_5 = VAR_14;\n        goto end;\n    }\n    if (VAR_10 == NULL) {\n        anetSetError(VAR_0, \"unable to bind socket, errno: %d\", VAR_15);\n        goto error;\n    }\n\nerror:\n    if (VAR_5 != -1) close(VAR_5);\n    VAR_5 = VAR_14;\nend:\n    freeaddrinfo(VAR_9);\n    return VAR_5;\n}",
  "func_graph_path": "redis/03345ddc7faf7af079485f2cbe5d17a1611cbce1/anet.c/vul/after/2.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -24,7 +24,7 @@\n \n         if (af == AF_INET6 && anetV6Only(err,s) == ANET_ERR) goto error;\n         if (anetSetReuseAddr(err,s) == ANET_ERR) goto error;\n-        if (anetListen(err,s,p->ai_addr,p->ai_addrlen,backlog) == ANET_ERR) s = ANET_ERR;\n+        if (anetListen(err,s,p->ai_addr,p->ai_addrlen,backlog,0) == ANET_ERR) s = ANET_ERR;\n         goto end;\n     }\n     if (p == NULL) {",
  "diff_line_info": {
    "deleted_lines": [
      "        if (anetListen(err,s,p->ai_addr,p->ai_addrlen,backlog) == ANET_ERR) s = ANET_ERR;"
    ],
    "added_lines": [
      "        if (anetListen(err,s,p->ai_addr,p->ai_addrlen,backlog,0) == ANET_ERR) s = ANET_ERR;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/redis/redis/pull/12671",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/redis/redis/pull/12671: 403 Client Error: Forbidden for url: https://api.github.com/repos/redis/redis/pulls/12671",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}