{
  "cve_id": "CVE-2018-16391",
  "cwe_ids": [
    "CWE-415",
    "CWE-119"
  ],
  "cvss_vector": "AV:L/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "OpenSC",
  "commit_msg": "fixed out of bounds writes\n\nThanks to Eric Sesterhenn from X41 D-SEC GmbH\nfor reporting the problems.",
  "commit_hash": "360e95d45ac4123255a4c796db96337f332160ad",
  "git_url": "https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad",
  "file_path": "src/libopensc/pkcs15-sc-hsm.c",
  "func_name": "sc_pkcs15emu_sc_hsm_init",
  "func_before": "static int sc_pkcs15emu_sc_hsm_init (sc_pkcs15_card_t * p15card)\n{\n\tsc_card_t *card = p15card->card;\n\tsc_hsm_private_data_t *priv = (sc_hsm_private_data_t *) card->drv_data;\n\tsc_file_t *file = NULL;\n\tsc_path_t path;\n\tu8 filelist[MAX_EXT_APDU_LENGTH];\n\tint filelistlength;\n\tint r, i;\n\tsc_cvc_t devcert;\n\tstruct sc_app_info *appinfo;\n\tstruct sc_pkcs15_auth_info pin_info;\n\tstruct sc_pkcs15_object pin_obj;\n\tstruct sc_pin_cmd_data pindata;\n\tu8 efbin[1024];\n\tu8 *ptr;\n\tsize_t len;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tappinfo = calloc(1, sizeof(struct sc_app_info));\n\n\tif (appinfo == NULL) {\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t}\n\n\tappinfo->aid = sc_hsm_aid;\n\n\tappinfo->ddo.aid = sc_hsm_aid;\n\tp15card->app = appinfo;\n\n\tsc_path_set(&path, SC_PATH_TYPE_DF_NAME, sc_hsm_aid.value, sc_hsm_aid.len, 0, 0);\n\tr = sc_select_file(card, &path, &file);\n\tLOG_TEST_RET(card->ctx, r, \"Could not select SmartCard-HSM application\");\n\n\tp15card->card->version.hw_major = 24;\t/* JCOP 2.4.1r3 */\n\tp15card->card->version.hw_minor = 13;\n\tif (file && file->prop_attr && file->prop_attr_len >= 2) {\n\t\tp15card->card->version.fw_major = file->prop_attr[file->prop_attr_len - 2];\n\t\tp15card->card->version.fw_minor = file->prop_attr[file->prop_attr_len - 1];\n\t}\n\n\tsc_file_free(file);\n\n\t/* Read device certificate to determine serial number */\n\tif (priv->EF_C_DevAut && priv->EF_C_DevAut_len) {\n\t\tptr = priv->EF_C_DevAut;\n\t\tlen = priv->EF_C_DevAut_len;\n\t} else {\n\t\tlen = sizeof efbin;\n\t\tr = read_file(p15card, (u8 *) \"\\x2F\\x02\", efbin, &len, 1);\n\t\tLOG_TEST_RET(card->ctx, r, \"Skipping optional EF.C_DevAut\");\n\n\t\t/* save EF_C_DevAut for further use */\n\t\tptr = realloc(priv->EF_C_DevAut, len);\n\t\tif (ptr) {\n\t\t\tmemcpy(ptr, efbin, len);\n\t\t\tpriv->EF_C_DevAut = ptr;\n\t\t\tpriv->EF_C_DevAut_len = len;\n\t\t}\n\n\t\tptr = efbin;\n\t}\n\n\tmemset(&devcert, 0 ,sizeof(devcert));\n\tr = sc_pkcs15emu_sc_hsm_decode_cvc(p15card, (const u8 **)&ptr, &len, &devcert);\n\tLOG_TEST_RET(card->ctx, r, \"Could not decode EF.C_DevAut\");\n\n\tsc_pkcs15emu_sc_hsm_read_tokeninfo(p15card);\n\n\tif (p15card->tokeninfo->label == NULL) {\n\t\tif (p15card->card->type == SC_CARD_TYPE_SC_HSM_GOID\n\t\t\t\t|| p15card->card->type == SC_CARD_TYPE_SC_HSM_SOC) {\n\t\t\tp15card->tokeninfo->label = strdup(\"GoID\");\n\t\t} else {\n\t\t\tp15card->tokeninfo->label = strdup(\"SmartCard-HSM\");\n\t\t}\n\t\tif (p15card->tokeninfo->label == NULL)\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t}\n\n\tif ((p15card->tokeninfo->manufacturer_id != NULL) && !strcmp(\"(unknown)\", p15card->tokeninfo->manufacturer_id)) {\n\t\tfree(p15card->tokeninfo->manufacturer_id);\n\t\tp15card->tokeninfo->manufacturer_id = NULL;\n\t}\n\n\tif (p15card->tokeninfo->manufacturer_id == NULL) {\n\t\tif (p15card->card->type == SC_CARD_TYPE_SC_HSM_GOID\n\t\t\t\t|| p15card->card->type == SC_CARD_TYPE_SC_HSM_SOC) {\n\t\t\tp15card->tokeninfo->manufacturer_id = strdup(\"Bundesdruckerei GmbH\");\n\t\t} else {\n\t\t\tp15card->tokeninfo->manufacturer_id = strdup(\"www.CardContact.de\");\n\t\t}\n\t\tif (p15card->tokeninfo->manufacturer_id == NULL)\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t}\n\n\tappinfo->label = strdup(p15card->tokeninfo->label);\n\tif (appinfo->label == NULL)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\n\tlen = strnlen(devcert.chr, sizeof devcert.chr);\t\t/* Strip last 5 digit sequence number from CHR */\n\tassert(len >= 8);\n\tlen -= 5;\n\n\tp15card->tokeninfo->serial_number = calloc(len + 1, 1);\n\tif (p15card->tokeninfo->serial_number == NULL)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\n\tmemcpy(p15card->tokeninfo->serial_number, devcert.chr, len);\n\t*(p15card->tokeninfo->serial_number + len) = 0;\n\n\tsc_hsm_set_serialnr(card, p15card->tokeninfo->serial_number);\n\n\tsc_pkcs15emu_sc_hsm_free_cvc(&devcert);\n\n\tmemset(&pin_info, 0, sizeof(pin_info));\n\tmemset(&pin_obj, 0, sizeof(pin_obj));\n\n\tpin_info.auth_id.len = 1;\n\tpin_info.auth_id.value[0] = 1;\n\tpin_info.path.aid = sc_hsm_aid;\n\tpin_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;\n\tpin_info.attrs.pin.reference = 0x81;\n\tpin_info.attrs.pin.flags = SC_PKCS15_PIN_FLAG_LOCAL|SC_PKCS15_PIN_FLAG_INITIALIZED|SC_PKCS15_PIN_FLAG_EXCHANGE_REF_DATA;\n\tpin_info.attrs.pin.type = SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;\n\tpin_info.attrs.pin.min_length = 6;\n\tpin_info.attrs.pin.stored_length = 0;\n\tpin_info.attrs.pin.max_length = 15;\n\tpin_info.attrs.pin.pad_char = '\\0';\n\tpin_info.tries_left = 3;\n\tpin_info.max_tries = 3;\n\n\tpin_obj.auth_id.len = 1;\n\tpin_obj.auth_id.value[0] = 2;\n\tstrlcpy(pin_obj.label, \"UserPIN\", sizeof(pin_obj.label));\n\tpin_obj.flags = SC_PKCS15_CO_FLAG_PRIVATE|SC_PKCS15_CO_FLAG_MODIFIABLE;\n\n\tr = sc_pkcs15emu_add_pin_obj(p15card, &pin_obj, &pin_info);\n\tif (r < 0)\n\t\tLOG_FUNC_RETURN(card->ctx, r);\n\n\tmemset(&pin_info, 0, sizeof(pin_info));\n\tmemset(&pin_obj, 0, sizeof(pin_obj));\n\n\tpin_info.auth_id.len = 1;\n\tpin_info.auth_id.value[0] = 2;\n\tpin_info.path.aid = sc_hsm_aid;\n\tpin_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;\n\tpin_info.attrs.pin.reference = 0x88;\n\tpin_info.attrs.pin.flags = SC_PKCS15_PIN_FLAG_LOCAL|SC_PKCS15_PIN_FLAG_INITIALIZED|SC_PKCS15_PIN_FLAG_UNBLOCK_DISABLED|SC_PKCS15_PIN_FLAG_SO_PIN;\n\tpin_info.attrs.pin.type = SC_PKCS15_PIN_TYPE_BCD;\n\tpin_info.attrs.pin.min_length = 16;\n\tpin_info.attrs.pin.stored_length = 0;\n\tpin_info.attrs.pin.max_length = 16;\n\tpin_info.attrs.pin.pad_char = '\\0';\n\tpin_info.tries_left = 15;\n\tpin_info.max_tries = 15;\n\n\tstrlcpy(pin_obj.label, \"SOPIN\", sizeof(pin_obj.label));\n\tpin_obj.flags = SC_PKCS15_CO_FLAG_PRIVATE;\n\n\tr = sc_pkcs15emu_add_pin_obj(p15card, &pin_obj, &pin_info);\n\tif (r < 0)\n\t\tLOG_FUNC_RETURN(card->ctx, r);\n\n\n\tif (card->type == SC_CARD_TYPE_SC_HSM_SOC\n\t\t\t|| card->type == SC_CARD_TYPE_SC_HSM_GOID) {\n\t\t/* SC-HSM of this type always has a PIN-Pad */\n\t\tr = SC_SUCCESS;\n\t} else {\n\t\tmemset(&pindata, 0, sizeof(pindata));\n\t\tpindata.cmd = SC_PIN_CMD_GET_INFO;\n\t\tpindata.pin_type = SC_AC_CHV;\n\t\tpindata.pin_reference = 0x85;\n\n\t\tr = sc_pin_cmd(card, &pindata, NULL);\n\t}\n\tif (r == SC_ERROR_DATA_OBJECT_NOT_FOUND) {\n\t\tmemset(&pindata, 0, sizeof(pindata));\n\t\tpindata.cmd = SC_PIN_CMD_GET_INFO;\n\t\tpindata.pin_type = SC_AC_CHV;\n\t\tpindata.pin_reference = 0x86;\n\n\t\tr = sc_pin_cmd(card, &pindata, NULL);\n\t}\n\n\tif ((r != SC_ERROR_DATA_OBJECT_NOT_FOUND) && (r != SC_ERROR_INCORRECT_PARAMETERS))\n\t\tcard->caps |= SC_CARD_CAP_PROTECTED_AUTHENTICATION_PATH;\n\n\n\tfilelistlength = sc_list_files(card, filelist, sizeof(filelist));\n\tLOG_TEST_RET(card->ctx, filelistlength, \"Could not enumerate file and key identifier\");\n\n\tfor (i = 0; i < filelistlength; i += 2) {\n\t\tswitch(filelist[i]) {\n\t\tcase KEY_PREFIX:\n\t\t\tr = sc_pkcs15emu_sc_hsm_add_prkd(p15card, filelist[i + 1]);\n\t\t\tbreak;\n\t\tcase DCOD_PREFIX:\n\t\t\tr = sc_pkcs15emu_sc_hsm_add_dcod(p15card, filelist[i + 1]);\n\t\t\tbreak;\n\t\tcase CD_PREFIX:\n\t\t\tr = sc_pkcs15emu_sc_hsm_add_cd(p15card, filelist[i + 1]);\n\t\t\tbreak;\n\t\t}\n\t\tif (r != SC_SUCCESS) {\n\t\t\tsc_log(card->ctx, \"Error %d adding elements to framework\", r);\n\t\t}\n\t}\n\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}",
  "abstract_func_before": "static int sc_pkcs15emu_sc_hsm_init (sc_pkcs15_card_t * VAR_0)\n{\n\tsc_card_t *VAR_1 = VAR_0->card;\n\tsc_hsm_private_data_t *VAR_2 = (sc_hsm_private_data_t *) VAR_1->drv_data;\n\tsc_file_t *VAR_3 = NULL;\n\tsc_path_t VAR_4;\n\tu8 VAR_5[VAR_6];\n\tint VAR_7;\n\tint VAR_8, VAR_9;\n\tsc_cvc_t VAR_10;\n\tstruct sc_app_info *VAR_11;\n\tstruct sc_pkcs15_auth_info VAR_12;\n\tstruct sc_pkcs15_object VAR_13;\n\tstruct sc_pin_cmd_data VAR_14;\n\tu8 VAR_15[1024];\n\tu8 *VAR_16;\n\tsize_t VAR_17;\n\n\tLOG_FUNC_CALLED(VAR_1->ctx);\n\n\tVAR_11 = calloc(1, sizeof(struct sc_app_info));\n\n\tif (VAR_11 == NULL) {\n\t\tLOG_FUNC_RETURN(VAR_1->ctx, VAR_18);\n\t}\n\n\tVAR_11->aid = VAR_19;\n\n\tVAR_11->ddo.aid = VAR_19;\n\tVAR_0->app = VAR_11;\n\n\tsc_path_set(&VAR_4, VAR_20, VAR_19.value, VAR_19.len, 0, 0);\n\tVAR_8 = sc_select_file(VAR_1, &VAR_4, &VAR_3);\n\tLOG_TEST_RET(VAR_1->ctx, VAR_8, \"Could not select SmartCard-HSM application\");\n\n\tVAR_0->card->version.hw_major = 24;\t/* COMMENT_0 */\n\tVAR_0->card->version.hw_minor = 13;\n\tif (VAR_3 && VAR_3->prop_attr && VAR_3->prop_attr_len >= 2) {\n\t\tVAR_0->card->version.fw_major = VAR_3->prop_attr[VAR_3->prop_attr_len - 2];\n\t\tVAR_0->card->version.fw_minor = VAR_3->prop_attr[VAR_3->prop_attr_len - 1];\n\t}\n\n\tsc_file_free(VAR_3);\n\n\t/* COMMENT_1 */\n\tif (VAR_2->EF_C_DevAut && VAR_2->EF_C_DevAut_len) {\n\t\tVAR_16 = VAR_2->EF_C_DevAut;\n\t\tVAR_17 = VAR_2->EF_C_DevAut_len;\n\t} else {\n\t\tVAR_17 = sizeof VAR_15;\n\t\tVAR_8 = read_file(VAR_0, (u8 *) \"\\x2F\\x02\", VAR_15, &VAR_17, 1);\n\t\tLOG_TEST_RET(VAR_1->ctx, VAR_8, \"Skipping optional EF.C_DevAut\");\n\n\t\t/* COMMENT_2 */\n\t\tVAR_16 = realloc(VAR_2->EF_C_DevAut, VAR_17);\n\t\tif (VAR_16) {\n\t\t\tmemcpy(VAR_16, VAR_15, VAR_17);\n\t\t\tVAR_2->EF_C_DevAut = VAR_16;\n\t\t\tVAR_2->EF_C_DevAut_len = VAR_17;\n\t\t}\n\n\t\tVAR_16 = VAR_15;\n\t}\n\n\tmemset(&VAR_10, 0 ,sizeof(VAR_10));\n\tVAR_8 = sc_pkcs15emu_sc_hsm_decode_cvc(VAR_0, (const u8 **)&VAR_16, &VAR_17, &VAR_10);\n\tLOG_TEST_RET(VAR_1->ctx, VAR_8, \"Could not decode EF.C_DevAut\");\n\n\tsc_pkcs15emu_sc_hsm_read_tokeninfo(VAR_0);\n\n\tif (VAR_0->tokeninfo->label == NULL) {\n\t\tif (VAR_0->card->type == VAR_21\n\t\t\t\t|| VAR_0->card->type == VAR_22) {\n\t\t\tVAR_0->tokeninfo->label = strdup(\"GoID\");\n\t\t} else {\n\t\t\tVAR_0->tokeninfo->label = strdup(\"SmartCard-HSM\");\n\t\t}\n\t\tif (VAR_0->tokeninfo->label == NULL)\n\t\t\tLOG_FUNC_RETURN(VAR_1->ctx, VAR_18);\n\t}\n\n\tif ((VAR_0->tokeninfo->manufacturer_id != NULL) && !strcmp(\"(unknown)\", VAR_0->tokeninfo->manufacturer_id)) {\n\t\tfree(VAR_0->tokeninfo->manufacturer_id);\n\t\tVAR_0->tokeninfo->manufacturer_id = NULL;\n\t}\n\n\tif (VAR_0->tokeninfo->manufacturer_id == NULL) {\n\t\tif (VAR_0->card->type == VAR_21\n\t\t\t\t|| VAR_0->card->type == VAR_22) {\n\t\t\tVAR_0->tokeninfo->manufacturer_id = strdup(\"Bundesdruckerei GmbH\");\n\t\t} else {\n\t\t\tVAR_0->tokeninfo->manufacturer_id = strdup(\"www.CardContact.de\");\n\t\t}\n\t\tif (VAR_0->tokeninfo->manufacturer_id == NULL)\n\t\t\tLOG_FUNC_RETURN(VAR_1->ctx, VAR_18);\n\t}\n\n\tVAR_11->label = strdup(VAR_0->tokeninfo->label);\n\tif (VAR_11->label == NULL)\n\t\tLOG_FUNC_RETURN(VAR_1->ctx, VAR_18);\n\n\tVAR_17 = strnlen(VAR_10.chr, sizeof VAR_10.chr);\t\t/* COMMENT_3 */\n\tassert(VAR_17 >= 8);\n\tVAR_17 -= 5;\n\n\tVAR_0->tokeninfo->serial_number = calloc(VAR_17 + 1, 1);\n\tif (VAR_0->tokeninfo->serial_number == NULL)\n\t\tLOG_FUNC_RETURN(VAR_1->ctx, VAR_18);\n\n\tmemcpy(VAR_0->tokeninfo->serial_number, VAR_10.chr, VAR_17);\n\t*(VAR_0->tokeninfo->serial_number + VAR_17) = 0;\n\n\tsc_hsm_set_serialnr(VAR_1, VAR_0->tokeninfo->serial_number);\n\n\tsc_pkcs15emu_sc_hsm_free_cvc(&VAR_10);\n\n\tmemset(&VAR_12, 0, sizeof(VAR_12));\n\tmemset(&VAR_13, 0, sizeof(VAR_13));\n\n\tVAR_12.auth_id.len = 1;\n\tVAR_12.auth_id.value[0] = 1;\n\tVAR_12.path.aid = VAR_19;\n\tVAR_12.auth_type = VAR_23;\n\tVAR_12.attrs.pin.reference = 0x81;\n\tVAR_12.attrs.pin.flags = VAR_24|VAR_25|VAR_26;\n\tVAR_12.attrs.pin.type = VAR_27;\n\tVAR_12.attrs.pin.min_length = 6;\n\tVAR_12.attrs.pin.stored_length = 0;\n\tVAR_12.attrs.pin.max_length = 15;\n\tVAR_12.attrs.pin.pad_char = '\\0';\n\tVAR_12.tries_left = 3;\n\tVAR_12.max_tries = 3;\n\n\tVAR_13.auth_id.len = 1;\n\tVAR_13.auth_id.value[0] = 2;\n\tstrlcpy(VAR_13.label, \"UserPIN\", sizeof(VAR_13.label));\n\tVAR_13.flags = VAR_28|VAR_29;\n\n\tVAR_8 = sc_pkcs15emu_add_pin_obj(VAR_0, &VAR_13, &VAR_12);\n\tif (VAR_8 < 0)\n\t\tLOG_FUNC_RETURN(VAR_1->ctx, VAR_8);\n\n\tmemset(&VAR_12, 0, sizeof(VAR_12));\n\tmemset(&VAR_13, 0, sizeof(VAR_13));\n\n\tVAR_12.auth_id.len = 1;\n\tVAR_12.auth_id.value[0] = 2;\n\tVAR_12.path.aid = VAR_19;\n\tVAR_12.auth_type = VAR_23;\n\tVAR_12.attrs.pin.reference = 0x88;\n\tVAR_12.attrs.pin.flags = VAR_24|VAR_25|VAR_30|VAR_31;\n\tVAR_12.attrs.pin.type = VAR_32;\n\tVAR_12.attrs.pin.min_length = 16;\n\tVAR_12.attrs.pin.stored_length = 0;\n\tVAR_12.attrs.pin.max_length = 16;\n\tVAR_12.attrs.pin.pad_char = '\\0';\n\tVAR_12.tries_left = 15;\n\tVAR_12.max_tries = 15;\n\n\tstrlcpy(VAR_13.label, \"SOPIN\", sizeof(VAR_13.label));\n\tVAR_13.flags = VAR_28;\n\n\tVAR_8 = sc_pkcs15emu_add_pin_obj(VAR_0, &VAR_13, &VAR_12);\n\tif (VAR_8 < 0)\n\t\tLOG_FUNC_RETURN(VAR_1->ctx, VAR_8);\n\n\n\tif (VAR_1->type == VAR_22\n\t\t\t|| VAR_1->type == VAR_21) {\n\t\t/* COMMENT_4 */\n\t\tVAR_8 = VAR_33;\n\t} else {\n\t\tmemset(&VAR_14, 0, sizeof(VAR_14));\n\t\tVAR_14.cmd = VAR_34;\n\t\tVAR_14.pin_type = VAR_35;\n\t\tVAR_14.pin_reference = 0x85;\n\n\t\tVAR_8 = sc_pin_cmd(VAR_1, &VAR_14, NULL);\n\t}\n\tif (VAR_8 == VAR_36) {\n\t\tmemset(&VAR_14, 0, sizeof(VAR_14));\n\t\tVAR_14.cmd = VAR_34;\n\t\tVAR_14.pin_type = VAR_35;\n\t\tVAR_14.pin_reference = 0x86;\n\n\t\tVAR_8 = sc_pin_cmd(VAR_1, &VAR_14, NULL);\n\t}\n\n\tif ((VAR_8 != VAR_36) && (VAR_8 != VAR_37))\n\t\tVAR_1->caps |= VAR_38;\n\n\n\tVAR_7 = sc_list_files(VAR_1, VAR_5, sizeof(VAR_5));\n\tLOG_TEST_RET(VAR_1->ctx, VAR_7, \"Could not enumerate file and key identifier\");\n\n\tfor (VAR_9 = 0; VAR_9 < VAR_7; VAR_9 += 2) {\n\t\tswitch(VAR_5[VAR_9]) {\n\t\tcase VAR_39:\n\t\t\tVAR_8 = sc_pkcs15emu_sc_hsm_add_prkd(VAR_0, VAR_5[VAR_9 + 1]);\n\t\t\tbreak;\n\t\tcase VAR_40:\n\t\t\tVAR_8 = sc_pkcs15emu_sc_hsm_add_dcod(VAR_0, VAR_5[VAR_9 + 1]);\n\t\t\tbreak;\n\t\tcase VAR_41:\n\t\t\tVAR_8 = sc_pkcs15emu_sc_hsm_add_cd(VAR_0, VAR_5[VAR_9 + 1]);\n\t\t\tbreak;\n\t\t}\n\t\tif (VAR_8 != VAR_33) {\n\t\t\tsc_log(VAR_1->ctx, \"Error %d adding elements to framework\", VAR_8);\n\t\t}\n\t}\n\n\tLOG_FUNC_RETURN(VAR_1->ctx, VAR_33);\n}",
  "func_graph_path_before": "OpenSC/360e95d45ac4123255a4c796db96337f332160ad/pkcs15-sc-hsm.c/vul/before/0.json",
  "func": "static int sc_pkcs15emu_sc_hsm_init (sc_pkcs15_card_t * p15card)\n{\n\tsc_card_t *card = p15card->card;\n\tsc_hsm_private_data_t *priv = (sc_hsm_private_data_t *) card->drv_data;\n\tsc_file_t *file = NULL;\n\tsc_path_t path;\n\tu8 filelist[MAX_EXT_APDU_LENGTH];\n\tint filelistlength;\n\tint r, i;\n\tsc_cvc_t devcert;\n\tstruct sc_app_info *appinfo;\n\tstruct sc_pkcs15_auth_info pin_info;\n\tstruct sc_pkcs15_object pin_obj;\n\tstruct sc_pin_cmd_data pindata;\n\tu8 efbin[1024];\n\tu8 *ptr;\n\tsize_t len;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tappinfo = calloc(1, sizeof(struct sc_app_info));\n\n\tif (appinfo == NULL) {\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t}\n\n\tappinfo->aid = sc_hsm_aid;\n\n\tappinfo->ddo.aid = sc_hsm_aid;\n\tp15card->app = appinfo;\n\n\tsc_path_set(&path, SC_PATH_TYPE_DF_NAME, sc_hsm_aid.value, sc_hsm_aid.len, 0, 0);\n\tr = sc_select_file(card, &path, &file);\n\tLOG_TEST_RET(card->ctx, r, \"Could not select SmartCard-HSM application\");\n\n\tp15card->card->version.hw_major = 24;\t/* JCOP 2.4.1r3 */\n\tp15card->card->version.hw_minor = 13;\n\tif (file && file->prop_attr && file->prop_attr_len >= 2) {\n\t\tp15card->card->version.fw_major = file->prop_attr[file->prop_attr_len - 2];\n\t\tp15card->card->version.fw_minor = file->prop_attr[file->prop_attr_len - 1];\n\t}\n\n\tsc_file_free(file);\n\n\t/* Read device certificate to determine serial number */\n\tif (priv->EF_C_DevAut && priv->EF_C_DevAut_len) {\n\t\tptr = priv->EF_C_DevAut;\n\t\tlen = priv->EF_C_DevAut_len;\n\t} else {\n\t\tlen = sizeof efbin;\n\t\tr = read_file(p15card, (u8 *) \"\\x2F\\x02\", efbin, &len, 1);\n\t\tLOG_TEST_RET(card->ctx, r, \"Skipping optional EF.C_DevAut\");\n\n\t\tif (len > 0) {\n\t\t\t/* save EF_C_DevAut for further use */\n\t\t\tptr = realloc(priv->EF_C_DevAut, len);\n\t\t\tif (ptr) {\n\t\t\t\tmemcpy(ptr, efbin, len);\n\t\t\t\tpriv->EF_C_DevAut = ptr;\n\t\t\t\tpriv->EF_C_DevAut_len = len;\n\t\t\t}\n\t\t}\n\n\t\tptr = efbin;\n\t}\n\n\tmemset(&devcert, 0 ,sizeof(devcert));\n\tr = sc_pkcs15emu_sc_hsm_decode_cvc(p15card, (const u8 **)&ptr, &len, &devcert);\n\tLOG_TEST_RET(card->ctx, r, \"Could not decode EF.C_DevAut\");\n\n\tsc_pkcs15emu_sc_hsm_read_tokeninfo(p15card);\n\n\tif (p15card->tokeninfo->label == NULL) {\n\t\tif (p15card->card->type == SC_CARD_TYPE_SC_HSM_GOID\n\t\t\t\t|| p15card->card->type == SC_CARD_TYPE_SC_HSM_SOC) {\n\t\t\tp15card->tokeninfo->label = strdup(\"GoID\");\n\t\t} else {\n\t\t\tp15card->tokeninfo->label = strdup(\"SmartCard-HSM\");\n\t\t}\n\t\tif (p15card->tokeninfo->label == NULL)\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t}\n\n\tif ((p15card->tokeninfo->manufacturer_id != NULL) && !strcmp(\"(unknown)\", p15card->tokeninfo->manufacturer_id)) {\n\t\tfree(p15card->tokeninfo->manufacturer_id);\n\t\tp15card->tokeninfo->manufacturer_id = NULL;\n\t}\n\n\tif (p15card->tokeninfo->manufacturer_id == NULL) {\n\t\tif (p15card->card->type == SC_CARD_TYPE_SC_HSM_GOID\n\t\t\t\t|| p15card->card->type == SC_CARD_TYPE_SC_HSM_SOC) {\n\t\t\tp15card->tokeninfo->manufacturer_id = strdup(\"Bundesdruckerei GmbH\");\n\t\t} else {\n\t\t\tp15card->tokeninfo->manufacturer_id = strdup(\"www.CardContact.de\");\n\t\t}\n\t\tif (p15card->tokeninfo->manufacturer_id == NULL)\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t}\n\n\tappinfo->label = strdup(p15card->tokeninfo->label);\n\tif (appinfo->label == NULL)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\n\tlen = strnlen(devcert.chr, sizeof devcert.chr);\t\t/* Strip last 5 digit sequence number from CHR */\n\tassert(len >= 8);\n\tlen -= 5;\n\n\tp15card->tokeninfo->serial_number = calloc(len + 1, 1);\n\tif (p15card->tokeninfo->serial_number == NULL)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\n\tmemcpy(p15card->tokeninfo->serial_number, devcert.chr, len);\n\t*(p15card->tokeninfo->serial_number + len) = 0;\n\n\tsc_hsm_set_serialnr(card, p15card->tokeninfo->serial_number);\n\n\tsc_pkcs15emu_sc_hsm_free_cvc(&devcert);\n\n\tmemset(&pin_info, 0, sizeof(pin_info));\n\tmemset(&pin_obj, 0, sizeof(pin_obj));\n\n\tpin_info.auth_id.len = 1;\n\tpin_info.auth_id.value[0] = 1;\n\tpin_info.path.aid = sc_hsm_aid;\n\tpin_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;\n\tpin_info.attrs.pin.reference = 0x81;\n\tpin_info.attrs.pin.flags = SC_PKCS15_PIN_FLAG_LOCAL|SC_PKCS15_PIN_FLAG_INITIALIZED|SC_PKCS15_PIN_FLAG_EXCHANGE_REF_DATA;\n\tpin_info.attrs.pin.type = SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;\n\tpin_info.attrs.pin.min_length = 6;\n\tpin_info.attrs.pin.stored_length = 0;\n\tpin_info.attrs.pin.max_length = 15;\n\tpin_info.attrs.pin.pad_char = '\\0';\n\tpin_info.tries_left = 3;\n\tpin_info.max_tries = 3;\n\n\tpin_obj.auth_id.len = 1;\n\tpin_obj.auth_id.value[0] = 2;\n\tstrlcpy(pin_obj.label, \"UserPIN\", sizeof(pin_obj.label));\n\tpin_obj.flags = SC_PKCS15_CO_FLAG_PRIVATE|SC_PKCS15_CO_FLAG_MODIFIABLE;\n\n\tr = sc_pkcs15emu_add_pin_obj(p15card, &pin_obj, &pin_info);\n\tif (r < 0)\n\t\tLOG_FUNC_RETURN(card->ctx, r);\n\n\tmemset(&pin_info, 0, sizeof(pin_info));\n\tmemset(&pin_obj, 0, sizeof(pin_obj));\n\n\tpin_info.auth_id.len = 1;\n\tpin_info.auth_id.value[0] = 2;\n\tpin_info.path.aid = sc_hsm_aid;\n\tpin_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;\n\tpin_info.attrs.pin.reference = 0x88;\n\tpin_info.attrs.pin.flags = SC_PKCS15_PIN_FLAG_LOCAL|SC_PKCS15_PIN_FLAG_INITIALIZED|SC_PKCS15_PIN_FLAG_UNBLOCK_DISABLED|SC_PKCS15_PIN_FLAG_SO_PIN;\n\tpin_info.attrs.pin.type = SC_PKCS15_PIN_TYPE_BCD;\n\tpin_info.attrs.pin.min_length = 16;\n\tpin_info.attrs.pin.stored_length = 0;\n\tpin_info.attrs.pin.max_length = 16;\n\tpin_info.attrs.pin.pad_char = '\\0';\n\tpin_info.tries_left = 15;\n\tpin_info.max_tries = 15;\n\n\tstrlcpy(pin_obj.label, \"SOPIN\", sizeof(pin_obj.label));\n\tpin_obj.flags = SC_PKCS15_CO_FLAG_PRIVATE;\n\n\tr = sc_pkcs15emu_add_pin_obj(p15card, &pin_obj, &pin_info);\n\tif (r < 0)\n\t\tLOG_FUNC_RETURN(card->ctx, r);\n\n\n\tif (card->type == SC_CARD_TYPE_SC_HSM_SOC\n\t\t\t|| card->type == SC_CARD_TYPE_SC_HSM_GOID) {\n\t\t/* SC-HSM of this type always has a PIN-Pad */\n\t\tr = SC_SUCCESS;\n\t} else {\n\t\tmemset(&pindata, 0, sizeof(pindata));\n\t\tpindata.cmd = SC_PIN_CMD_GET_INFO;\n\t\tpindata.pin_type = SC_AC_CHV;\n\t\tpindata.pin_reference = 0x85;\n\n\t\tr = sc_pin_cmd(card, &pindata, NULL);\n\t}\n\tif (r == SC_ERROR_DATA_OBJECT_NOT_FOUND) {\n\t\tmemset(&pindata, 0, sizeof(pindata));\n\t\tpindata.cmd = SC_PIN_CMD_GET_INFO;\n\t\tpindata.pin_type = SC_AC_CHV;\n\t\tpindata.pin_reference = 0x86;\n\n\t\tr = sc_pin_cmd(card, &pindata, NULL);\n\t}\n\n\tif ((r != SC_ERROR_DATA_OBJECT_NOT_FOUND) && (r != SC_ERROR_INCORRECT_PARAMETERS))\n\t\tcard->caps |= SC_CARD_CAP_PROTECTED_AUTHENTICATION_PATH;\n\n\n\tfilelistlength = sc_list_files(card, filelist, sizeof(filelist));\n\tLOG_TEST_RET(card->ctx, filelistlength, \"Could not enumerate file and key identifier\");\n\n\tfor (i = 0; i < filelistlength; i += 2) {\n\t\tswitch(filelist[i]) {\n\t\tcase KEY_PREFIX:\n\t\t\tr = sc_pkcs15emu_sc_hsm_add_prkd(p15card, filelist[i + 1]);\n\t\t\tbreak;\n\t\tcase DCOD_PREFIX:\n\t\t\tr = sc_pkcs15emu_sc_hsm_add_dcod(p15card, filelist[i + 1]);\n\t\t\tbreak;\n\t\tcase CD_PREFIX:\n\t\t\tr = sc_pkcs15emu_sc_hsm_add_cd(p15card, filelist[i + 1]);\n\t\t\tbreak;\n\t\t}\n\t\tif (r != SC_SUCCESS) {\n\t\t\tsc_log(card->ctx, \"Error %d adding elements to framework\", r);\n\t\t}\n\t}\n\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}",
  "abstract_func": "static int sc_pkcs15emu_sc_hsm_init (sc_pkcs15_card_t * VAR_0)\n{\n\tsc_card_t *VAR_1 = VAR_0->card;\n\tsc_hsm_private_data_t *VAR_2 = (sc_hsm_private_data_t *) VAR_1->drv_data;\n\tsc_file_t *VAR_3 = NULL;\n\tsc_path_t VAR_4;\n\tu8 VAR_5[VAR_6];\n\tint VAR_7;\n\tint VAR_8, VAR_9;\n\tsc_cvc_t VAR_10;\n\tstruct sc_app_info *VAR_11;\n\tstruct sc_pkcs15_auth_info VAR_12;\n\tstruct sc_pkcs15_object VAR_13;\n\tstruct sc_pin_cmd_data VAR_14;\n\tu8 VAR_15[1024];\n\tu8 *VAR_16;\n\tsize_t VAR_17;\n\n\tLOG_FUNC_CALLED(VAR_1->ctx);\n\n\tVAR_11 = calloc(1, sizeof(struct sc_app_info));\n\n\tif (VAR_11 == NULL) {\n\t\tLOG_FUNC_RETURN(VAR_1->ctx, VAR_18);\n\t}\n\n\tVAR_11->aid = VAR_19;\n\n\tVAR_11->ddo.aid = VAR_19;\n\tVAR_0->app = VAR_11;\n\n\tsc_path_set(&VAR_4, VAR_20, VAR_19.value, VAR_19.len, 0, 0);\n\tVAR_8 = sc_select_file(VAR_1, &VAR_4, &VAR_3);\n\tLOG_TEST_RET(VAR_1->ctx, VAR_8, \"Could not select SmartCard-HSM application\");\n\n\tVAR_0->card->version.hw_major = 24;\t/* COMMENT_0 */\n\tVAR_0->card->version.hw_minor = 13;\n\tif (VAR_3 && VAR_3->prop_attr && VAR_3->prop_attr_len >= 2) {\n\t\tVAR_0->card->version.fw_major = VAR_3->prop_attr[VAR_3->prop_attr_len - 2];\n\t\tVAR_0->card->version.fw_minor = VAR_3->prop_attr[VAR_3->prop_attr_len - 1];\n\t}\n\n\tsc_file_free(VAR_3);\n\n\t/* COMMENT_1 */\n\tif (VAR_2->EF_C_DevAut && VAR_2->EF_C_DevAut_len) {\n\t\tVAR_16 = VAR_2->EF_C_DevAut;\n\t\tVAR_17 = VAR_2->EF_C_DevAut_len;\n\t} else {\n\t\tVAR_17 = sizeof VAR_15;\n\t\tVAR_8 = read_file(VAR_0, (u8 *) \"\\x2F\\x02\", VAR_15, &VAR_17, 1);\n\t\tLOG_TEST_RET(VAR_1->ctx, VAR_8, \"Skipping optional EF.C_DevAut\");\n\n\t\tif (VAR_17 > 0) {\n\t\t\t/* COMMENT_2 */\n\t\t\tVAR_16 = realloc(VAR_2->EF_C_DevAut, VAR_17);\n\t\t\tif (VAR_16) {\n\t\t\t\tmemcpy(VAR_16, VAR_15, VAR_17);\n\t\t\t\tVAR_2->EF_C_DevAut = VAR_16;\n\t\t\t\tVAR_2->EF_C_DevAut_len = VAR_17;\n\t\t\t}\n\t\t}\n\n\t\tVAR_16 = VAR_15;\n\t}\n\n\tmemset(&VAR_10, 0 ,sizeof(VAR_10));\n\tVAR_8 = sc_pkcs15emu_sc_hsm_decode_cvc(VAR_0, (const u8 **)&VAR_16, &VAR_17, &VAR_10);\n\tLOG_TEST_RET(VAR_1->ctx, VAR_8, \"Could not decode EF.C_DevAut\");\n\n\tsc_pkcs15emu_sc_hsm_read_tokeninfo(VAR_0);\n\n\tif (VAR_0->tokeninfo->label == NULL) {\n\t\tif (VAR_0->card->type == VAR_21\n\t\t\t\t|| VAR_0->card->type == VAR_22) {\n\t\t\tVAR_0->tokeninfo->label = strdup(\"GoID\");\n\t\t} else {\n\t\t\tVAR_0->tokeninfo->label = strdup(\"SmartCard-HSM\");\n\t\t}\n\t\tif (VAR_0->tokeninfo->label == NULL)\n\t\t\tLOG_FUNC_RETURN(VAR_1->ctx, VAR_18);\n\t}\n\n\tif ((VAR_0->tokeninfo->manufacturer_id != NULL) && !strcmp(\"(unknown)\", VAR_0->tokeninfo->manufacturer_id)) {\n\t\tfree(VAR_0->tokeninfo->manufacturer_id);\n\t\tVAR_0->tokeninfo->manufacturer_id = NULL;\n\t}\n\n\tif (VAR_0->tokeninfo->manufacturer_id == NULL) {\n\t\tif (VAR_0->card->type == VAR_21\n\t\t\t\t|| VAR_0->card->type == VAR_22) {\n\t\t\tVAR_0->tokeninfo->manufacturer_id = strdup(\"Bundesdruckerei GmbH\");\n\t\t} else {\n\t\t\tVAR_0->tokeninfo->manufacturer_id = strdup(\"www.CardContact.de\");\n\t\t}\n\t\tif (VAR_0->tokeninfo->manufacturer_id == NULL)\n\t\t\tLOG_FUNC_RETURN(VAR_1->ctx, VAR_18);\n\t}\n\n\tVAR_11->label = strdup(VAR_0->tokeninfo->label);\n\tif (VAR_11->label == NULL)\n\t\tLOG_FUNC_RETURN(VAR_1->ctx, VAR_18);\n\n\tVAR_17 = strnlen(VAR_10.chr, sizeof VAR_10.chr);\t\t/* COMMENT_3 */\n\tassert(VAR_17 >= 8);\n\tVAR_17 -= 5;\n\n\tVAR_0->tokeninfo->serial_number = calloc(VAR_17 + 1, 1);\n\tif (VAR_0->tokeninfo->serial_number == NULL)\n\t\tLOG_FUNC_RETURN(VAR_1->ctx, VAR_18);\n\n\tmemcpy(VAR_0->tokeninfo->serial_number, VAR_10.chr, VAR_17);\n\t*(VAR_0->tokeninfo->serial_number + VAR_17) = 0;\n\n\tsc_hsm_set_serialnr(VAR_1, VAR_0->tokeninfo->serial_number);\n\n\tsc_pkcs15emu_sc_hsm_free_cvc(&VAR_10);\n\n\tmemset(&VAR_12, 0, sizeof(VAR_12));\n\tmemset(&VAR_13, 0, sizeof(VAR_13));\n\n\tVAR_12.auth_id.len = 1;\n\tVAR_12.auth_id.value[0] = 1;\n\tVAR_12.path.aid = VAR_19;\n\tVAR_12.auth_type = VAR_23;\n\tVAR_12.attrs.pin.reference = 0x81;\n\tVAR_12.attrs.pin.flags = VAR_24|VAR_25|VAR_26;\n\tVAR_12.attrs.pin.type = VAR_27;\n\tVAR_12.attrs.pin.min_length = 6;\n\tVAR_12.attrs.pin.stored_length = 0;\n\tVAR_12.attrs.pin.max_length = 15;\n\tVAR_12.attrs.pin.pad_char = '\\0';\n\tVAR_12.tries_left = 3;\n\tVAR_12.max_tries = 3;\n\n\tVAR_13.auth_id.len = 1;\n\tVAR_13.auth_id.value[0] = 2;\n\tstrlcpy(VAR_13.label, \"UserPIN\", sizeof(VAR_13.label));\n\tVAR_13.flags = VAR_28|VAR_29;\n\n\tVAR_8 = sc_pkcs15emu_add_pin_obj(VAR_0, &VAR_13, &VAR_12);\n\tif (VAR_8 < 0)\n\t\tLOG_FUNC_RETURN(VAR_1->ctx, VAR_8);\n\n\tmemset(&VAR_12, 0, sizeof(VAR_12));\n\tmemset(&VAR_13, 0, sizeof(VAR_13));\n\n\tVAR_12.auth_id.len = 1;\n\tVAR_12.auth_id.value[0] = 2;\n\tVAR_12.path.aid = VAR_19;\n\tVAR_12.auth_type = VAR_23;\n\tVAR_12.attrs.pin.reference = 0x88;\n\tVAR_12.attrs.pin.flags = VAR_24|VAR_25|VAR_30|VAR_31;\n\tVAR_12.attrs.pin.type = VAR_32;\n\tVAR_12.attrs.pin.min_length = 16;\n\tVAR_12.attrs.pin.stored_length = 0;\n\tVAR_12.attrs.pin.max_length = 16;\n\tVAR_12.attrs.pin.pad_char = '\\0';\n\tVAR_12.tries_left = 15;\n\tVAR_12.max_tries = 15;\n\n\tstrlcpy(VAR_13.label, \"SOPIN\", sizeof(VAR_13.label));\n\tVAR_13.flags = VAR_28;\n\n\tVAR_8 = sc_pkcs15emu_add_pin_obj(VAR_0, &VAR_13, &VAR_12);\n\tif (VAR_8 < 0)\n\t\tLOG_FUNC_RETURN(VAR_1->ctx, VAR_8);\n\n\n\tif (VAR_1->type == VAR_22\n\t\t\t|| VAR_1->type == VAR_21) {\n\t\t/* COMMENT_4 */\n\t\tVAR_8 = VAR_33;\n\t} else {\n\t\tmemset(&VAR_14, 0, sizeof(VAR_14));\n\t\tVAR_14.cmd = VAR_34;\n\t\tVAR_14.pin_type = VAR_35;\n\t\tVAR_14.pin_reference = 0x85;\n\n\t\tVAR_8 = sc_pin_cmd(VAR_1, &VAR_14, NULL);\n\t}\n\tif (VAR_8 == VAR_36) {\n\t\tmemset(&VAR_14, 0, sizeof(VAR_14));\n\t\tVAR_14.cmd = VAR_34;\n\t\tVAR_14.pin_type = VAR_35;\n\t\tVAR_14.pin_reference = 0x86;\n\n\t\tVAR_8 = sc_pin_cmd(VAR_1, &VAR_14, NULL);\n\t}\n\n\tif ((VAR_8 != VAR_36) && (VAR_8 != VAR_37))\n\t\tVAR_1->caps |= VAR_38;\n\n\n\tVAR_7 = sc_list_files(VAR_1, VAR_5, sizeof(VAR_5));\n\tLOG_TEST_RET(VAR_1->ctx, VAR_7, \"Could not enumerate file and key identifier\");\n\n\tfor (VAR_9 = 0; VAR_9 < VAR_7; VAR_9 += 2) {\n\t\tswitch(VAR_5[VAR_9]) {\n\t\tcase VAR_39:\n\t\t\tVAR_8 = sc_pkcs15emu_sc_hsm_add_prkd(VAR_0, VAR_5[VAR_9 + 1]);\n\t\t\tbreak;\n\t\tcase VAR_40:\n\t\t\tVAR_8 = sc_pkcs15emu_sc_hsm_add_dcod(VAR_0, VAR_5[VAR_9 + 1]);\n\t\t\tbreak;\n\t\tcase VAR_41:\n\t\t\tVAR_8 = sc_pkcs15emu_sc_hsm_add_cd(VAR_0, VAR_5[VAR_9 + 1]);\n\t\t\tbreak;\n\t\t}\n\t\tif (VAR_8 != VAR_33) {\n\t\t\tsc_log(VAR_1->ctx, \"Error %d adding elements to framework\", VAR_8);\n\t\t}\n\t}\n\n\tLOG_FUNC_RETURN(VAR_1->ctx, VAR_33);\n}",
  "func_graph_path": "OpenSC/360e95d45ac4123255a4c796db96337f332160ad/pkcs15-sc-hsm.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -51,12 +51,14 @@\n \t\tr = read_file(p15card, (u8 *) \"\\x2F\\x02\", efbin, &len, 1);\n \t\tLOG_TEST_RET(card->ctx, r, \"Skipping optional EF.C_DevAut\");\n \n-\t\t/* save EF_C_DevAut for further use */\n-\t\tptr = realloc(priv->EF_C_DevAut, len);\n-\t\tif (ptr) {\n-\t\t\tmemcpy(ptr, efbin, len);\n-\t\t\tpriv->EF_C_DevAut = ptr;\n-\t\t\tpriv->EF_C_DevAut_len = len;\n+\t\tif (len > 0) {\n+\t\t\t/* save EF_C_DevAut for further use */\n+\t\t\tptr = realloc(priv->EF_C_DevAut, len);\n+\t\t\tif (ptr) {\n+\t\t\t\tmemcpy(ptr, efbin, len);\n+\t\t\t\tpriv->EF_C_DevAut = ptr;\n+\t\t\t\tpriv->EF_C_DevAut_len = len;\n+\t\t\t}\n \t\t}\n \n \t\tptr = efbin;",
  "diff_line_info": {
    "deleted_lines": [
      "\t\t/* save EF_C_DevAut for further use */",
      "\t\tptr = realloc(priv->EF_C_DevAut, len);",
      "\t\tif (ptr) {",
      "\t\t\tmemcpy(ptr, efbin, len);",
      "\t\t\tpriv->EF_C_DevAut = ptr;",
      "\t\t\tpriv->EF_C_DevAut_len = len;"
    ],
    "added_lines": [
      "\t\tif (len > 0) {",
      "\t\t\t/* save EF_C_DevAut for further use */",
      "\t\t\tptr = realloc(priv->EF_C_DevAut, len);",
      "\t\t\tif (ptr) {",
      "\t\t\t\tmemcpy(ptr, efbin, len);",
      "\t\t\t\tpriv->EF_C_DevAut = ptr;",
      "\t\t\t\tpriv->EF_C_DevAut_len = len;",
      "\t\t\t}"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/OpenSC/OpenSC/pull/1447",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/OpenSC/OpenSC/pull/1447: 403 Client Error: Forbidden for url: https://api.github.com/repos/OpenSC/OpenSC/pulls/1447",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "The commit addresses a security issue identified through fuzzing. It fixes an out-of-bounds write by adding a length check, preventing potential buffer overflow.\n\n**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95\n\n**Step-by-Step Explanation:**\n\n1. **Commit Message Analysis:** References \"out of bounds writes,\" a security issue, and mentions a security researcher from X41 D-SEC.\n\n2. **Vulnerability Description:** Details fixes from fuzzing, indicating security concerns, and mentions testing of security-related modules.\n\n3. **Code Diff:** Introduces a check for 'len > 0,' preventing buffer overflow in the EF_C_DevAut buffer, a security-sensitive area.\n\n4. **Security Fix Assessment:** Change directly prevents a security exploit, consistent with vulnerability description and commit message.\n\n5. **Confidence High:** All elements align clearly with a security vulnerability fix."
}