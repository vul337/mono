{
  "cve_id": "CVE-2016-2145",
  "cwe_ids": [
    "CWE-119",
    "CWE-20"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "Uninett/mod_auth_mellon",
  "commit_msg": "Handle ap_get_client_block() error in am_read_post_data()",
  "commit_hash": "5f03a632c9652687c7dac1ea44f334b9983ab268",
  "git_url": "https://github.com/Uninett/mod_auth_mellon/commit/5f03a632c9652687c7dac1ea44f334b9983ab268",
  "file_path": "auth_mellon_util.c",
  "func_name": "am_read_post_data",
  "func_before": "int am_read_post_data(request_rec *r, char **data, apr_size_t *length)\n{\n    apr_size_t bytes_read;\n    apr_size_t bytes_left;\n    apr_size_t len;\n    long read_length;\n    int rc;\n\n    /* Prepare to receive data from the client. We request that apache\n     * dechunks data if it is chunked.\n     */\n    rc = ap_setup_client_block(r, REQUEST_CHUNKED_DECHUNK);\n    if (rc != OK) {\n        return rc;\n    }\n\n    /* This function will send a 100 Continue response if the client is\n     * waiting for that. If the client isn't going to send data, then this\n     * function will return 0.\n     */\n    if (!ap_should_client_block(r)) {\n        len = 0;\n    } else {\n        len = r->remaining;\n    }\n\n    if (length != NULL) {\n        *length = len;\n    }\n\n    *data = (char *)apr_palloc(r->pool, len + 1);\n\n    /* Make sure that the data is null-terminated.  */\n    (*data)[len] = '\\0';\n\n    bytes_read = 0;\n    bytes_left = len;\n\n    while (bytes_left > 0) {\n        /* Read data from the client. Returns 0 on EOF or error, the\n         * number of bytes otherwise.\n         */\n        read_length = ap_get_client_block(r, &(*data)[bytes_read],\n                                          bytes_left);\n        if (read_length == 0) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                          \"Failed to read POST data from client.\");\n            return HTTP_INTERNAL_SERVER_ERROR;\n        }\n\n        bytes_read += read_length;\n        bytes_left -= read_length;\n    }\n\n    return OK;\n}",
  "abstract_func_before": "int am_read_post_data(request_rec *VAR_0, char **VAR_1, apr_size_t *VAR_2)\n{\n    apr_size_t VAR_3;\n    apr_size_t VAR_4;\n    apr_size_t VAR_5;\n    long VAR_6;\n    int VAR_7;\n\n    /* COMMENT_0 */\n                                      \n       \n    VAR_7 = ap_setup_client_block(VAR_0, VAR_8);\n    if (VAR_7 != VAR_9) {\n        return VAR_7;\n    }\n\n    /* COMMENT_3 */\n                                                                          \n                              \n       \n    if (!ap_should_client_block(VAR_0)) {\n        VAR_5 = 0;\n    } else {\n        VAR_5 = VAR_0->remaining;\n    }\n\n    if (VAR_2 != NULL) {\n        *VAR_2 = VAR_5;\n    }\n\n    *VAR_1 = (char *)apr_palloc(VAR_0->pool, VAR_5 + 1);\n\n    /* COMMENT_7 */\n    (*VAR_1)[VAR_5] = '\\0';\n\n    VAR_3 = 0;\n    VAR_4 = VAR_5;\n\n    while (VAR_4 > 0) {\n        /* COMMENT_8 */\n                                     \n           \n        VAR_6 = ap_get_client_block(VAR_0, &(*VAR_1)[VAR_3],\n                                          VAR_4);\n        if (VAR_6 == 0) {\n            ap_log_rerror(VAR_10, VAR_11, 0, VAR_0,\n                          \"Failed to read POST data from client.\");\n            return VAR_12;\n        }\n\n        VAR_3 += VAR_6;\n        VAR_4 -= VAR_6;\n    }\n\n    return VAR_9;\n}",
  "func_graph_path_before": "Uninett/mod_auth_mellon/5f03a632c9652687c7dac1ea44f334b9983ab268/auth_mellon_util.c/vul/before/0.json",
  "func": "int am_read_post_data(request_rec *r, char **data, apr_size_t *length)\n{\n    apr_size_t bytes_read;\n    apr_size_t bytes_left;\n    apr_size_t len;\n    long read_length;\n    int rc;\n\n    /* Prepare to receive data from the client. We request that apache\n     * dechunks data if it is chunked.\n     */\n    rc = ap_setup_client_block(r, REQUEST_CHUNKED_DECHUNK);\n    if (rc != OK) {\n        return rc;\n    }\n\n    /* This function will send a 100 Continue response if the client is\n     * waiting for that. If the client isn't going to send data, then this\n     * function will return 0.\n     */\n    if (!ap_should_client_block(r)) {\n        len = 0;\n    } else {\n        len = r->remaining;\n    }\n\n    if (length != NULL) {\n        *length = len;\n    }\n\n    *data = (char *)apr_palloc(r->pool, len + 1);\n\n    /* Make sure that the data is null-terminated.  */\n    (*data)[len] = '\\0';\n\n    bytes_read = 0;\n    bytes_left = len;\n\n    while (bytes_left > 0) {\n        /* Read data from the client. Returns 0 on EOF and -1 on\n         * error, the number of bytes otherwise.\n         */\n        read_length = ap_get_client_block(r, &(*data)[bytes_read],\n                                          bytes_left);\n        if (read_length == 0) {\n            /* got the EOF */\n            (*data)[bytes_read] = '\\0';\n\n            if (length != NULL) {\n                *length = bytes_read;\n            }\n            break;\n        }\n        else if (read_length < 0) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                          \"Failed to read POST data from client.\");\n            return HTTP_INTERNAL_SERVER_ERROR;\n        }\n\n        bytes_read += read_length;\n        bytes_left -= read_length;\n    }\n\n    return OK;\n}",
  "abstract_func": "int am_read_post_data(request_rec *VAR_0, char **VAR_1, apr_size_t *VAR_2)\n{\n    apr_size_t VAR_3;\n    apr_size_t VAR_4;\n    apr_size_t VAR_5;\n    long VAR_6;\n    int VAR_7;\n\n    /* COMMENT_0 */\n                                      \n       \n    VAR_7 = ap_setup_client_block(VAR_0, VAR_8);\n    if (VAR_7 != VAR_9) {\n        return VAR_7;\n    }\n\n    /* COMMENT_3 */\n                                                                          \n                              \n       \n    if (!ap_should_client_block(VAR_0)) {\n        VAR_5 = 0;\n    } else {\n        VAR_5 = VAR_0->remaining;\n    }\n\n    if (VAR_2 != NULL) {\n        *VAR_2 = VAR_5;\n    }\n\n    *VAR_1 = (char *)apr_palloc(VAR_0->pool, VAR_5 + 1);\n\n    /* COMMENT_7 */\n    (*VAR_1)[VAR_5] = '\\0';\n\n    VAR_3 = 0;\n    VAR_4 = VAR_5;\n\n    while (VAR_4 > 0) {\n        /* COMMENT_8 */\n                                                \n           \n        VAR_6 = ap_get_client_block(VAR_0, &(*VAR_1)[VAR_3],\n                                          VAR_4);\n        if (VAR_6 == 0) {\n            /* COMMENT_11 */\n            (*VAR_1)[VAR_3] = '\\0';\n\n            if (VAR_2 != NULL) {\n                *VAR_2 = VAR_3;\n            }\n            break;\n        }\n        else if (VAR_6 < 0) {\n            ap_log_rerror(VAR_10, VAR_11, 0, VAR_0,\n                          \"Failed to read POST data from client.\");\n            return VAR_12;\n        }\n\n        VAR_3 += VAR_6;\n        VAR_4 -= VAR_6;\n    }\n\n    return VAR_9;\n}",
  "func_graph_path": "Uninett/mod_auth_mellon/5f03a632c9652687c7dac1ea44f334b9983ab268/auth_mellon_util.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -37,12 +37,21 @@\n     bytes_left = len;\n \n     while (bytes_left > 0) {\n-        /* Read data from the client. Returns 0 on EOF or error, the\n-         * number of bytes otherwise.\n+        /* Read data from the client. Returns 0 on EOF and -1 on\n+         * error, the number of bytes otherwise.\n          */\n         read_length = ap_get_client_block(r, &(*data)[bytes_read],\n                                           bytes_left);\n         if (read_length == 0) {\n+            /* got the EOF */\n+            (*data)[bytes_read] = '\\0';\n+\n+            if (length != NULL) {\n+                *length = bytes_read;\n+            }\n+            break;\n+        }\n+        else if (read_length < 0) {\n             ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                           \"Failed to read POST data from client.\");\n             return HTTP_INTERNAL_SERVER_ERROR;",
  "diff_line_info": {
    "deleted_lines": [
      "        /* Read data from the client. Returns 0 on EOF or error, the",
      "         * number of bytes otherwise."
    ],
    "added_lines": [
      "        /* Read data from the client. Returns 0 on EOF and -1 on",
      "         * error, the number of bytes otherwise.",
      "            /* got the EOF */",
      "            (*data)[bytes_read] = '\\0';",
      "",
      "            if (length != NULL) {",
      "                *length = bytes_read;",
      "            }",
      "            break;",
      "        }",
      "        else if (read_length < 0) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/Uninett/mod_auth_mellon/pull/71",
  "description": {
    "pr_info": {
      "title": "Handle ap_get_client_block() error in am_read_post_data()",
      "number": 71
    },
    "comment": [
      "Hello,\n\nI had the same segmentation fault as in the issue #48.\n\nHere is a patch that should fix the segfault: am_read_post_data() should check if ap_get_client_block() returns an error.\n\nThe patch also fixes a possible underflow in am_read_post_data() if mod_auth_mellon receives too much POST data. I have not checked if it is possible to trigger that underflow.\n\nRegards,\n\nVincent Rasneur\nSoftware security engineer, DenyAll\nvrasneur@denyall.com\n",
      "Thanks for looking into this!\n\nYou are right that we need to handle errors condition from `ap_get_client_block()`. The failure mode is a bit interesting -- as far as I can tell, we will repeatedly call `ap_get_client_block()` with an ever-larger read request. Not sure how many iterations are required before it crashes though.\n\nI do strongly suspect that it crashes on the second iteration, since at that point we are asking Apache to read from something that has already returned an error.\n\nLooking at the code, I think we also need to put an upper bound to the number of bytes that we are willing to read, but I think that belongs in a separate patch.\n",
      "Hi olavmrk,\n\nAs I have said, I did not check if the underflow is triggerable. The main fix is to check for the ap_get_client_block() error.\n\nFor the crash, when ap_get_client_block() returns -1, the loop in mod_auth_mellon will allocate an \"infinite\" number of empty bucket brigades.\n\nOn my coredump, you could see that Apache had created approximately 451,000,000 empty brigades before crashing ;-)\n",
      "> As I have said, I did not check if the underflow is triggerable. The main fix is to check for the ap_get_client_block() error.\n\nI don't think it can ever happen (`ap_get_client_block()` returning more data than requested) , so I'd remove that condition. Leaving it in will only lead to confusion for future generations.\n\n> For the crash, when ap_get_client_block() returns -1, the loop in mod_auth_mellon will allocate an \"infinite\" number of empty bucket brigades.\n\nOK, that is good to know. Then this crashes the web server process, but doesn't allow for overwriting arbitrary data.\n\nCould you amend your patch with:\n- The check for `(apr_size_t)read_length > bytes_left` removed.\n- Adjustments of `length` and null terminator on early EOF.\n",
      "I have updated the patch.\n\nIs it OK for you?\n",
      "Yes, thanks!\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.9"
}