{
  "cve_id": "CVE-2017-11368",
  "cwe_ids": [
    "CWE-617"
  ],
  "cvss_vector": "AV:N/AC:L/Au:S/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "krb5",
  "commit_msg": "Prevent KDC unset status assertion failures\n\nAssign status values if S4U2Self padata fails to decode, if an\nS4U2Proxy request uses invalid KDC options, or if an S4U2Proxy request\nuses an evidence ticket which does not match the canonicalized request\nserver principal name.  Reported by Samuel Cabrero.\n\nIf a status value is not assigned during KDC processing, default to\n\"UNKNOWN_REASON\" rather than failing an assertion.  This change will\nprevent future denial of service bugs due to similar mistakes, and\nwill allow us to omit assigning status values for unlikely errors such\nas small memory allocation failures.\n\nCVE-2017-11368:\n\nIn MIT krb5 1.7 and later, an authenticated attacker can cause an\nassertion failure in krb5kdc by sending an invalid S4U2Self or\nS4U2Proxy request.\n\n  CVSSv3 Vector: AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H/E:H/RL:O/RC:C\n\nticket: 8599 (new)\ntarget_version: 1.15-next\ntarget_version: 1.14-next\ntags: pullup",
  "commit_hash": "ffb35baac6981f9e8914f8f3bffd37f284b85970",
  "git_url": "https://github.com/krb5/krb5/commit/ffb35baac6981f9e8914f8f3bffd37f284b85970",
  "file_path": "src/kdc/do_as_req.c",
  "func_name": "finish_process_as_req",
  "func_before": "static void\nfinish_process_as_req(struct as_req_state *state, krb5_error_code errcode)\n{\n    krb5_key_data *server_key;\n    krb5_keyblock *as_encrypting_key = NULL;\n    krb5_data *response = NULL;\n    const char *emsg = 0;\n    int did_log = 0;\n    loop_respond_fn oldrespond;\n    void *oldarg;\n    kdc_realm_t *kdc_active_realm = state->active_realm;\n    krb5_audit_state *au_state = state->au_state;\n\n    assert(state);\n    oldrespond = state->respond;\n    oldarg = state->arg;\n\n    if (errcode)\n        goto egress;\n\n    au_state->stage = ENCR_REP;\n\n    if ((errcode = validate_forwardable(state->request, *state->client,\n                                        *state->server, state->kdc_time,\n                                        &state->status))) {\n        errcode += ERROR_TABLE_BASE_krb5;\n        goto egress;\n    }\n\n    errcode = check_indicators(kdc_context, state->server,\n                               state->auth_indicators);\n    if (errcode) {\n        state->status = \"HIGHER_AUTHENTICATION_REQUIRED\";\n        goto egress;\n    }\n\n    state->ticket_reply.enc_part2 = &state->enc_tkt_reply;\n\n    /*\n     * Find the server key\n     */\n    if ((errcode = krb5_dbe_find_enctype(kdc_context, state->server,\n                                         -1, /* ignore keytype   */\n                                         -1, /* Ignore salttype  */\n                                         0,  /* Get highest kvno */\n                                         &server_key))) {\n        state->status = \"FINDING_SERVER_KEY\";\n        goto egress;\n    }\n\n    /*\n     * Convert server->key into a real key\n     * (it may be encrypted in the database)\n     *\n     *  server_keyblock is later used to generate auth data signatures\n     */\n    if ((errcode = krb5_dbe_decrypt_key_data(kdc_context, NULL,\n                                             server_key,\n                                             &state->server_keyblock,\n                                             NULL))) {\n        state->status = \"DECRYPT_SERVER_KEY\";\n        goto egress;\n    }\n\n    /* Start assembling the response */\n    state->reply.msg_type = KRB5_AS_REP;\n    state->reply.client = state->enc_tkt_reply.client; /* post canonization */\n    state->reply.ticket = &state->ticket_reply;\n    state->reply_encpart.session = &state->session_key;\n    if ((errcode = fetch_last_req_info(state->client,\n                                       &state->reply_encpart.last_req))) {\n        state->status = \"FETCH_LAST_REQ\";\n        goto egress;\n    }\n    state->reply_encpart.nonce = state->request->nonce;\n    state->reply_encpart.key_exp = get_key_exp(state->client);\n    state->reply_encpart.flags = state->enc_tkt_reply.flags;\n    state->reply_encpart.server = state->ticket_reply.server;\n\n    /* copy the time fields EXCEPT for authtime; it's location\n     *  is used for ktime\n     */\n    state->reply_encpart.times = state->enc_tkt_reply.times;\n    state->reply_encpart.times.authtime = state->authtime = state->kdc_time;\n\n    state->reply_encpart.caddrs = state->enc_tkt_reply.caddrs;\n    state->reply_encpart.enc_padata = NULL;\n\n    /* Fetch the padata info to be returned (do this before\n     *  authdata to handle possible replacement of reply key\n     */\n    errcode = return_padata(kdc_context, &state->rock, state->req_pkt,\n                            state->request, &state->reply,\n                            &state->client_keyblock, &state->pa_context);\n    if (errcode) {\n        state->status = \"KDC_RETURN_PADATA\";\n        goto egress;\n    }\n\n    /* If we didn't find a client long-term key and no preauth mechanism\n     * replaced the reply key, error out now. */\n    if (state->client_keyblock.enctype == ENCTYPE_NULL) {\n        state->status = \"CANT_FIND_CLIENT_KEY\";\n        errcode = KRB5KDC_ERR_ETYPE_NOSUPP;\n        goto egress;\n    }\n\n    errcode = handle_authdata(kdc_context,\n                              state->c_flags,\n                              state->client,\n                              state->server,\n                              NULL,\n                              state->local_tgt,\n                              &state->client_keyblock,\n                              &state->server_keyblock,\n                              NULL,\n                              state->req_pkt,\n                              state->request,\n                              NULL, /* for_user_princ */\n                              NULL, /* enc_tkt_request */\n                              state->auth_indicators,\n                              &state->enc_tkt_reply);\n    if (errcode) {\n        krb5_klog_syslog(LOG_INFO, _(\"AS_REQ : handle_authdata (%d)\"),\n                         errcode);\n        state->status = \"HANDLE_AUTHDATA\";\n        goto egress;\n    }\n\n    errcode = krb5_encrypt_tkt_part(kdc_context, &state->server_keyblock,\n                                    &state->ticket_reply);\n    if (errcode) {\n        state->status = \"ENCRYPT_TICKET\";\n        goto egress;\n    }\n\n    errcode = kau_make_tkt_id(kdc_context, &state->ticket_reply,\n                              &au_state->tkt_out_id);\n    if (errcode) {\n        state->status = \"GENERATE_TICKET_ID\";\n        goto egress;\n    }\n\n    state->ticket_reply.enc_part.kvno = server_key->key_data_kvno;\n    errcode = kdc_fast_response_handle_padata(state->rstate,\n                                              state->request,\n                                              &state->reply,\n                                              state->client_keyblock.enctype);\n    if (errcode) {\n        state->status = \"MAKE_FAST_RESPONSE\";\n        goto egress;\n    }\n\n    /* now encode/encrypt the response */\n\n    state->reply.enc_part.enctype = state->client_keyblock.enctype;\n\n    errcode = kdc_fast_handle_reply_key(state->rstate, &state->client_keyblock,\n                                        &as_encrypting_key);\n    if (errcode) {\n        state->status = \"MAKE_FAST_REPLY_KEY\";\n        goto egress;\n    }\n    errcode = return_enc_padata(kdc_context, state->req_pkt, state->request,\n                                as_encrypting_key, state->server,\n                                &state->reply_encpart, FALSE);\n    if (errcode) {\n        state->status = \"KDC_RETURN_ENC_PADATA\";\n        goto egress;\n    }\n\n    if (kdc_fast_hide_client(state->rstate))\n        state->reply.client = (krb5_principal)krb5_anonymous_principal();\n    errcode = krb5_encode_kdc_rep(kdc_context, KRB5_AS_REP,\n                                  &state->reply_encpart, 0,\n                                  as_encrypting_key,\n                                  &state->reply, &response);\n    if (state->client_key != NULL)\n        state->reply.enc_part.kvno = state->client_key->key_data_kvno;\n    if (errcode) {\n        state->status = \"ENCODE_KDC_REP\";\n        goto egress;\n    }\n\n    /* these parts are left on as a courtesy from krb5_encode_kdc_rep so we\n       can use them in raw form if needed.  But, we don't... */\n    memset(state->reply.enc_part.ciphertext.data, 0,\n           state->reply.enc_part.ciphertext.length);\n    free(state->reply.enc_part.ciphertext.data);\n\n    log_as_req(kdc_context, state->local_addr, state->remote_addr,\n               state->request, &state->reply, state->client, state->cname,\n               state->server, state->sname, state->authtime, 0, 0, 0);\n    did_log = 1;\n\negress:\n    if (errcode != 0)\n        assert (state->status != 0);\n\n    au_state->status = state->status;\n    au_state->reply = &state->reply;\n    kau_as_req(kdc_context,\n              (errcode || state->preauth_err) ? FALSE : TRUE, au_state);\n    kau_free_kdc_req(au_state);\n\n    free_padata_context(kdc_context, state->pa_context);\n    if (as_encrypting_key)\n        krb5_free_keyblock(kdc_context, as_encrypting_key);\n    if (errcode)\n        emsg = krb5_get_error_message(kdc_context, errcode);\n\n    if (state->status) {\n        log_as_req(kdc_context, state->local_addr, state->remote_addr,\n                   state->request, &state->reply, state->client,\n                   state->cname, state->server, state->sname, state->authtime,\n                   state->status, errcode, emsg);\n        did_log = 1;\n    }\n    if (errcode) {\n        if (state->status == 0) {\n            state->status = emsg;\n        }\n        if (errcode != KRB5KDC_ERR_DISCARD) {\n            errcode -= ERROR_TABLE_BASE_krb5;\n            if (errcode < 0 || errcode > KRB_ERR_MAX)\n                errcode = KRB_ERR_GENERIC;\n\n            errcode = prepare_error_as(state->rstate, state->request,\n                                       state->local_tgt, errcode,\n                                       state->e_data, state->typed_e_data,\n                                       ((state->client != NULL) ?\n                                        state->client->princ : NULL),\n                                       &response, state->status);\n            state->status = 0;\n        }\n    }\n\n    if (emsg)\n        krb5_free_error_message(kdc_context, emsg);\n    if (state->enc_tkt_reply.authorization_data != NULL)\n        krb5_free_authdata(kdc_context,\n                           state->enc_tkt_reply.authorization_data);\n    if (state->server_keyblock.contents != NULL)\n        krb5_free_keyblock_contents(kdc_context, &state->server_keyblock);\n    if (state->client_keyblock.contents != NULL)\n        krb5_free_keyblock_contents(kdc_context, &state->client_keyblock);\n    if (state->reply.padata != NULL)\n        krb5_free_pa_data(kdc_context, state->reply.padata);\n    if (state->reply_encpart.enc_padata)\n        krb5_free_pa_data(kdc_context, state->reply_encpart.enc_padata);\n\n    if (state->cname != NULL)\n        free(state->cname);\n    if (state->sname != NULL)\n        free(state->sname);\n    krb5_db_free_principal(kdc_context, state->client);\n    krb5_db_free_principal(kdc_context, state->server);\n    krb5_db_free_principal(kdc_context, state->local_tgt_storage);\n    if (state->session_key.contents != NULL)\n        krb5_free_keyblock_contents(kdc_context, &state->session_key);\n    if (state->ticket_reply.enc_part.ciphertext.data != NULL) {\n        memset(state->ticket_reply.enc_part.ciphertext.data , 0,\n               state->ticket_reply.enc_part.ciphertext.length);\n        free(state->ticket_reply.enc_part.ciphertext.data);\n    }\n\n    krb5_free_pa_data(kdc_context, state->e_data);\n    krb5_free_data(kdc_context, state->inner_body);\n    kdc_free_rstate(state->rstate);\n    krb5_free_kdc_req(kdc_context, state->request);\n    k5_free_data_ptr_list(state->auth_indicators);\n    assert(did_log != 0);\n\n    free(state);\n    (*oldrespond)(oldarg, errcode, response);\n}",
  "abstract_func_before": "static void\nfinish_process_as_req(struct as_req_state *VAR_0, krb5_error_code VAR_1)\n{\n    krb5_key_data *VAR_2;\n    krb5_keyblock *VAR_3 = NULL;\n    krb5_data *VAR_4 = NULL;\n    const char *VAR_5 = 0;\n    int VAR_6 = 0;\n    loop_respond_fn VAR_7;\n    void *VAR_8;\n    kdc_realm_t *VAR_9 = VAR_0->active_realm;\n    krb5_audit_state *VAR_10 = VAR_0->au_state;\n\n    assert(VAR_0);\n    VAR_7 = VAR_0->respond;\n    VAR_8 = VAR_0->arg;\n\n    if (VAR_1)\n        goto egress;\n\n    VAR_10->stage = VAR_11;\n\n    if ((VAR_1 = validate_forwardable(VAR_0->request, *VAR_0->client,\n                                        *VAR_0->server, VAR_0->kdc_time,\n                                        &VAR_0->status))) {\n        VAR_1 += VAR_12;\n        goto egress;\n    }\n\n    VAR_1 = check_indicators(VAR_13, VAR_0->server,\n                               VAR_0->auth_indicators);\n    if (VAR_1) {\n        VAR_0->status = \"HIGHER_AUTHENTICATION_REQUIRED\";\n        goto egress;\n    }\n\n    VAR_0->ticket_reply.enc_part2 = &VAR_0->enc_tkt_reply;\n\n    /* COMMENT_0 */\n                          \n       \n    if ((VAR_1 = krb5_dbe_find_enctype(VAR_13, VAR_0->server,\n                                         -1, /* COMMENT_3 */\n                                         -1, /* COMMENT_4 */\n                                         0,  /* COMMENT_5 */\n                                         &VAR_2))) {\n        VAR_0->status = \"FINDING_SERVER_KEY\";\n        goto egress;\n    }\n\n    /* COMMENT_6 */\n                                          \n                                            \n      \n                                                                      \n       \n    if ((VAR_1 = krb5_dbe_decrypt_key_data(VAR_13, NULL,\n                                             VAR_2,\n                                             &VAR_0->server_keyblock,\n                                             NULL))) {\n        VAR_0->status = \"DECRYPT_SERVER_KEY\";\n        goto egress;\n    }\n\n    /* COMMENT_12 */\n    VAR_0->reply.msg_type = VAR_14;\n    VAR_0->reply.client = VAR_0->enc_tkt_reply.client; /* COMMENT_13 */\n    VAR_0->reply.ticket = &VAR_0->ticket_reply;\n    VAR_0->reply_encpart.session = &VAR_0->session_key;\n    if ((VAR_1 = fetch_last_req_info(VAR_0->client,\n                                       &VAR_0->reply_encpart.last_req))) {\n        VAR_0->status = \"FETCH_LAST_REQ\";\n        goto egress;\n    }\n    VAR_0->reply_encpart.nonce = VAR_0->request->nonce;\n    VAR_0->reply_encpart.key_exp = get_key_exp(VAR_0->client);\n    VAR_0->reply_encpart.flags = VAR_0->enc_tkt_reply.flags;\n    VAR_0->reply_encpart.server = VAR_0->ticket_reply.server;\n\n    /* COMMENT_14 */\n                         \n       \n    VAR_0->reply_encpart.times = VAR_0->enc_tkt_reply.times;\n    VAR_0->reply_encpart.times.authtime = VAR_0->authtime = VAR_0->kdc_time;\n\n    VAR_0->reply_encpart.caddrs = VAR_0->enc_tkt_reply.caddrs;\n    VAR_0->reply_encpart.enc_padata = NULL;\n\n    /* COMMENT_17 */\n                                                            \n       \n    VAR_1 = return_padata(VAR_13, &VAR_0->rock, VAR_0->req_pkt,\n                            VAR_0->request, &VAR_0->reply,\n                            &VAR_0->client_keyblock, &VAR_0->pa_context);\n    if (VAR_1) {\n        VAR_0->status = \"KDC_RETURN_PADATA\";\n        goto egress;\n    }\n\n    /* COMMENT_20 */\n                                                \n    if (VAR_0->client_keyblock.enctype == VAR_15) {\n        VAR_0->status = \"CANT_FIND_CLIENT_KEY\";\n        VAR_1 = VAR_16;\n        goto egress;\n    }\n\n    VAR_1 = handle_authdata(VAR_13,\n                              VAR_0->c_flags,\n                              VAR_0->client,\n                              VAR_0->server,\n                              NULL,\n                              VAR_0->local_tgt,\n                              &VAR_0->client_keyblock,\n                              &VAR_0->server_keyblock,\n                              NULL,\n                              VAR_0->req_pkt,\n                              VAR_0->request,\n                              NULL, /* COMMENT_22 */\n                              NULL, /* COMMENT_23 */\n                              VAR_0->auth_indicators,\n                              &VAR_0->enc_tkt_reply);\n    if (VAR_1) {\n        krb5_klog_syslog(VAR_17, _(\"AS_REQ : handle_authdata (%d)\"),\n                         VAR_1);\n        VAR_0->status = \"HANDLE_AUTHDATA\";\n        goto egress;\n    }\n\n    VAR_1 = krb5_encrypt_tkt_part(VAR_13, &VAR_0->server_keyblock,\n                                    &VAR_0->ticket_reply);\n    if (VAR_1) {\n        VAR_0->status = \"ENCRYPT_TICKET\";\n        goto egress;\n    }\n\n    VAR_1 = kau_make_tkt_id(VAR_13, &VAR_0->ticket_reply,\n                              &VAR_10->tkt_out_id);\n    if (VAR_1) {\n        VAR_0->status = \"GENERATE_TICKET_ID\";\n        goto egress;\n    }\n\n    VAR_0->ticket_reply.enc_part.kvno = VAR_2->key_data_kvno;\n    VAR_1 = kdc_fast_response_handle_padata(VAR_0->rstate,\n                                              VAR_0->request,\n                                              &VAR_0->reply,\n                                              VAR_0->client_keyblock.enctype);\n    if (VAR_1) {\n        VAR_0->status = \"MAKE_FAST_RESPONSE\";\n        goto egress;\n    }\n\n    /* COMMENT_24 */\n\n    VAR_0->reply.enc_part.enctype = VAR_0->client_keyblock.enctype;\n\n    VAR_1 = kdc_fast_handle_reply_key(VAR_0->rstate, &VAR_0->client_keyblock,\n                                        &VAR_3);\n    if (VAR_1) {\n        VAR_0->status = \"MAKE_FAST_REPLY_KEY\";\n        goto egress;\n    }\n    VAR_1 = return_enc_padata(VAR_13, VAR_0->req_pkt, VAR_0->request,\n                                VAR_3, VAR_0->server,\n                                &VAR_0->reply_encpart, FALSE);\n    if (VAR_1) {\n        VAR_0->status = \"KDC_RETURN_ENC_PADATA\";\n        goto egress;\n    }\n\n    if (kdc_fast_hide_client(VAR_0->rstate))\n        VAR_0->reply.client = (krb5_principal)krb5_anonymous_principal();\n    VAR_1 = krb5_encode_kdc_rep(VAR_13, VAR_14,\n                                  &VAR_0->reply_encpart, 0,\n                                  VAR_3,\n                                  &VAR_0->reply, &VAR_4);\n    if (VAR_0->client_key != NULL)\n        VAR_0->reply.enc_part.kvno = VAR_0->client_key->key_data_kvno;\n    if (VAR_1) {\n        VAR_0->status = \"ENCODE_KDC_REP\";\n        goto egress;\n    }\n\n    /* COMMENT_25 */\n                                                               \n    memset(VAR_0->reply.enc_part.ciphertext.data, 0,\n           VAR_0->reply.enc_part.ciphertext.length);\n    free(VAR_0->reply.enc_part.ciphertext.data);\n\n    log_as_req(VAR_13, VAR_0->local_addr, VAR_0->remote_addr,\n               VAR_0->request, &VAR_0->reply, VAR_0->client, VAR_0->cname,\n               VAR_0->server, VAR_0->sname, VAR_0->authtime, 0, 0, 0);\n    VAR_6 = 1;\n\negress:\n    if (VAR_1 != 0)\n        assert (VAR_0->status != 0);\n\n    VAR_10->status = VAR_0->status;\n    VAR_10->reply = &VAR_0->reply;\n    kau_as_req(VAR_13,\n              (VAR_1 || VAR_0->preauth_err) ? FALSE : TRUE, VAR_10);\n    kau_free_kdc_req(VAR_10);\n\n    free_padata_context(VAR_13, VAR_0->pa_context);\n    if (VAR_3)\n        krb5_free_keyblock(VAR_13, VAR_3);\n    if (VAR_1)\n        VAR_5 = krb5_get_error_message(VAR_13, VAR_1);\n\n    if (VAR_0->status) {\n        log_as_req(VAR_13, VAR_0->local_addr, VAR_0->remote_addr,\n                   VAR_0->request, &VAR_0->reply, VAR_0->client,\n                   VAR_0->cname, VAR_0->server, VAR_0->sname, VAR_0->authtime,\n                   VAR_0->status, VAR_1, VAR_5);\n        VAR_6 = 1;\n    }\n    if (VAR_1) {\n        if (VAR_0->status == 0) {\n            VAR_0->status = VAR_5;\n        }\n        if (VAR_1 != VAR_18) {\n            VAR_1 -= VAR_12;\n            if (VAR_1 < 0 || VAR_1 > VAR_19)\n                VAR_1 = VAR_20;\n\n            VAR_1 = prepare_error_as(VAR_0->rstate, VAR_0->request,\n                                       VAR_0->local_tgt, VAR_1,\n                                       VAR_0->e_data, VAR_0->typed_e_data,\n                                       ((VAR_0->client != NULL) ?\n                                        VAR_0->client->princ : NULL),\n                                       &VAR_4, VAR_0->status);\n            VAR_0->status = 0;\n        }\n    }\n\n    if (VAR_5)\n        krb5_free_error_message(VAR_13, VAR_5);\n    if (VAR_0->enc_tkt_reply.authorization_data != NULL)\n        krb5_free_authdata(VAR_13,\n                           VAR_0->enc_tkt_reply.authorization_data);\n    if (VAR_0->server_keyblock.contents != NULL)\n        krb5_free_keyblock_contents(VAR_13, &VAR_0->server_keyblock);\n    if (VAR_0->client_keyblock.contents != NULL)\n        krb5_free_keyblock_contents(VAR_13, &VAR_0->client_keyblock);\n    if (VAR_0->reply.padata != NULL)\n        krb5_free_pa_data(VAR_13, VAR_0->reply.padata);\n    if (VAR_0->reply_encpart.enc_padata)\n        krb5_free_pa_data(VAR_13, VAR_0->reply_encpart.enc_padata);\n\n    if (VAR_0->cname != NULL)\n        free(VAR_0->cname);\n    if (VAR_0->sname != NULL)\n        free(VAR_0->sname);\n    krb5_db_free_principal(VAR_13, VAR_0->client);\n    krb5_db_free_principal(VAR_13, VAR_0->server);\n    krb5_db_free_principal(VAR_13, VAR_0->local_tgt_storage);\n    if (VAR_0->session_key.contents != NULL)\n        krb5_free_keyblock_contents(VAR_13, &VAR_0->session_key);\n    if (VAR_0->ticket_reply.enc_part.ciphertext.data != NULL) {\n        memset(VAR_0->ticket_reply.enc_part.ciphertext.data , 0,\n               VAR_0->ticket_reply.enc_part.ciphertext.length);\n        free(VAR_0->ticket_reply.enc_part.ciphertext.data);\n    }\n\n    krb5_free_pa_data(VAR_13, VAR_0->e_data);\n    krb5_free_data(VAR_13, VAR_0->inner_body);\n    kdc_free_rstate(VAR_0->rstate);\n    krb5_free_kdc_req(VAR_13, VAR_0->request);\n    k5_free_data_ptr_list(VAR_0->auth_indicators);\n    assert(VAR_6 != 0);\n\n    free(VAR_0);\n    (*VAR_7)(VAR_8, VAR_1, VAR_4);\n}",
  "func_graph_path_before": "krb5/ffb35baac6981f9e8914f8f3bffd37f284b85970/do_as_req.c/vul/before/0.json",
  "func": "static void\nfinish_process_as_req(struct as_req_state *state, krb5_error_code errcode)\n{\n    krb5_key_data *server_key;\n    krb5_keyblock *as_encrypting_key = NULL;\n    krb5_data *response = NULL;\n    const char *emsg = 0;\n    int did_log = 0;\n    loop_respond_fn oldrespond;\n    void *oldarg;\n    kdc_realm_t *kdc_active_realm = state->active_realm;\n    krb5_audit_state *au_state = state->au_state;\n\n    assert(state);\n    oldrespond = state->respond;\n    oldarg = state->arg;\n\n    if (errcode)\n        goto egress;\n\n    au_state->stage = ENCR_REP;\n\n    if ((errcode = validate_forwardable(state->request, *state->client,\n                                        *state->server, state->kdc_time,\n                                        &state->status))) {\n        errcode += ERROR_TABLE_BASE_krb5;\n        goto egress;\n    }\n\n    errcode = check_indicators(kdc_context, state->server,\n                               state->auth_indicators);\n    if (errcode) {\n        state->status = \"HIGHER_AUTHENTICATION_REQUIRED\";\n        goto egress;\n    }\n\n    state->ticket_reply.enc_part2 = &state->enc_tkt_reply;\n\n    /*\n     * Find the server key\n     */\n    if ((errcode = krb5_dbe_find_enctype(kdc_context, state->server,\n                                         -1, /* ignore keytype   */\n                                         -1, /* Ignore salttype  */\n                                         0,  /* Get highest kvno */\n                                         &server_key))) {\n        state->status = \"FINDING_SERVER_KEY\";\n        goto egress;\n    }\n\n    /*\n     * Convert server->key into a real key\n     * (it may be encrypted in the database)\n     *\n     *  server_keyblock is later used to generate auth data signatures\n     */\n    if ((errcode = krb5_dbe_decrypt_key_data(kdc_context, NULL,\n                                             server_key,\n                                             &state->server_keyblock,\n                                             NULL))) {\n        state->status = \"DECRYPT_SERVER_KEY\";\n        goto egress;\n    }\n\n    /* Start assembling the response */\n    state->reply.msg_type = KRB5_AS_REP;\n    state->reply.client = state->enc_tkt_reply.client; /* post canonization */\n    state->reply.ticket = &state->ticket_reply;\n    state->reply_encpart.session = &state->session_key;\n    if ((errcode = fetch_last_req_info(state->client,\n                                       &state->reply_encpart.last_req))) {\n        state->status = \"FETCH_LAST_REQ\";\n        goto egress;\n    }\n    state->reply_encpart.nonce = state->request->nonce;\n    state->reply_encpart.key_exp = get_key_exp(state->client);\n    state->reply_encpart.flags = state->enc_tkt_reply.flags;\n    state->reply_encpart.server = state->ticket_reply.server;\n\n    /* copy the time fields EXCEPT for authtime; it's location\n     *  is used for ktime\n     */\n    state->reply_encpart.times = state->enc_tkt_reply.times;\n    state->reply_encpart.times.authtime = state->authtime = state->kdc_time;\n\n    state->reply_encpart.caddrs = state->enc_tkt_reply.caddrs;\n    state->reply_encpart.enc_padata = NULL;\n\n    /* Fetch the padata info to be returned (do this before\n     *  authdata to handle possible replacement of reply key\n     */\n    errcode = return_padata(kdc_context, &state->rock, state->req_pkt,\n                            state->request, &state->reply,\n                            &state->client_keyblock, &state->pa_context);\n    if (errcode) {\n        state->status = \"KDC_RETURN_PADATA\";\n        goto egress;\n    }\n\n    /* If we didn't find a client long-term key and no preauth mechanism\n     * replaced the reply key, error out now. */\n    if (state->client_keyblock.enctype == ENCTYPE_NULL) {\n        state->status = \"CANT_FIND_CLIENT_KEY\";\n        errcode = KRB5KDC_ERR_ETYPE_NOSUPP;\n        goto egress;\n    }\n\n    errcode = handle_authdata(kdc_context,\n                              state->c_flags,\n                              state->client,\n                              state->server,\n                              NULL,\n                              state->local_tgt,\n                              &state->client_keyblock,\n                              &state->server_keyblock,\n                              NULL,\n                              state->req_pkt,\n                              state->request,\n                              NULL, /* for_user_princ */\n                              NULL, /* enc_tkt_request */\n                              state->auth_indicators,\n                              &state->enc_tkt_reply);\n    if (errcode) {\n        krb5_klog_syslog(LOG_INFO, _(\"AS_REQ : handle_authdata (%d)\"),\n                         errcode);\n        state->status = \"HANDLE_AUTHDATA\";\n        goto egress;\n    }\n\n    errcode = krb5_encrypt_tkt_part(kdc_context, &state->server_keyblock,\n                                    &state->ticket_reply);\n    if (errcode) {\n        state->status = \"ENCRYPT_TICKET\";\n        goto egress;\n    }\n\n    errcode = kau_make_tkt_id(kdc_context, &state->ticket_reply,\n                              &au_state->tkt_out_id);\n    if (errcode) {\n        state->status = \"GENERATE_TICKET_ID\";\n        goto egress;\n    }\n\n    state->ticket_reply.enc_part.kvno = server_key->key_data_kvno;\n    errcode = kdc_fast_response_handle_padata(state->rstate,\n                                              state->request,\n                                              &state->reply,\n                                              state->client_keyblock.enctype);\n    if (errcode) {\n        state->status = \"MAKE_FAST_RESPONSE\";\n        goto egress;\n    }\n\n    /* now encode/encrypt the response */\n\n    state->reply.enc_part.enctype = state->client_keyblock.enctype;\n\n    errcode = kdc_fast_handle_reply_key(state->rstate, &state->client_keyblock,\n                                        &as_encrypting_key);\n    if (errcode) {\n        state->status = \"MAKE_FAST_REPLY_KEY\";\n        goto egress;\n    }\n    errcode = return_enc_padata(kdc_context, state->req_pkt, state->request,\n                                as_encrypting_key, state->server,\n                                &state->reply_encpart, FALSE);\n    if (errcode) {\n        state->status = \"KDC_RETURN_ENC_PADATA\";\n        goto egress;\n    }\n\n    if (kdc_fast_hide_client(state->rstate))\n        state->reply.client = (krb5_principal)krb5_anonymous_principal();\n    errcode = krb5_encode_kdc_rep(kdc_context, KRB5_AS_REP,\n                                  &state->reply_encpart, 0,\n                                  as_encrypting_key,\n                                  &state->reply, &response);\n    if (state->client_key != NULL)\n        state->reply.enc_part.kvno = state->client_key->key_data_kvno;\n    if (errcode) {\n        state->status = \"ENCODE_KDC_REP\";\n        goto egress;\n    }\n\n    /* these parts are left on as a courtesy from krb5_encode_kdc_rep so we\n       can use them in raw form if needed.  But, we don't... */\n    memset(state->reply.enc_part.ciphertext.data, 0,\n           state->reply.enc_part.ciphertext.length);\n    free(state->reply.enc_part.ciphertext.data);\n\n    log_as_req(kdc_context, state->local_addr, state->remote_addr,\n               state->request, &state->reply, state->client, state->cname,\n               state->server, state->sname, state->authtime, 0, 0, 0);\n    did_log = 1;\n\negress:\n    if (errcode != 0 && state->status == NULL)\n        state->status = \"UNKNOWN_REASON\";\n\n    au_state->status = state->status;\n    au_state->reply = &state->reply;\n    kau_as_req(kdc_context,\n              (errcode || state->preauth_err) ? FALSE : TRUE, au_state);\n    kau_free_kdc_req(au_state);\n\n    free_padata_context(kdc_context, state->pa_context);\n    if (as_encrypting_key)\n        krb5_free_keyblock(kdc_context, as_encrypting_key);\n    if (errcode)\n        emsg = krb5_get_error_message(kdc_context, errcode);\n\n    if (state->status) {\n        log_as_req(kdc_context, state->local_addr, state->remote_addr,\n                   state->request, &state->reply, state->client,\n                   state->cname, state->server, state->sname, state->authtime,\n                   state->status, errcode, emsg);\n        did_log = 1;\n    }\n    if (errcode) {\n        if (state->status == 0) {\n            state->status = emsg;\n        }\n        if (errcode != KRB5KDC_ERR_DISCARD) {\n            errcode -= ERROR_TABLE_BASE_krb5;\n            if (errcode < 0 || errcode > KRB_ERR_MAX)\n                errcode = KRB_ERR_GENERIC;\n\n            errcode = prepare_error_as(state->rstate, state->request,\n                                       state->local_tgt, errcode,\n                                       state->e_data, state->typed_e_data,\n                                       ((state->client != NULL) ?\n                                        state->client->princ : NULL),\n                                       &response, state->status);\n            state->status = 0;\n        }\n    }\n\n    if (emsg)\n        krb5_free_error_message(kdc_context, emsg);\n    if (state->enc_tkt_reply.authorization_data != NULL)\n        krb5_free_authdata(kdc_context,\n                           state->enc_tkt_reply.authorization_data);\n    if (state->server_keyblock.contents != NULL)\n        krb5_free_keyblock_contents(kdc_context, &state->server_keyblock);\n    if (state->client_keyblock.contents != NULL)\n        krb5_free_keyblock_contents(kdc_context, &state->client_keyblock);\n    if (state->reply.padata != NULL)\n        krb5_free_pa_data(kdc_context, state->reply.padata);\n    if (state->reply_encpart.enc_padata)\n        krb5_free_pa_data(kdc_context, state->reply_encpart.enc_padata);\n\n    if (state->cname != NULL)\n        free(state->cname);\n    if (state->sname != NULL)\n        free(state->sname);\n    krb5_db_free_principal(kdc_context, state->client);\n    krb5_db_free_principal(kdc_context, state->server);\n    krb5_db_free_principal(kdc_context, state->local_tgt_storage);\n    if (state->session_key.contents != NULL)\n        krb5_free_keyblock_contents(kdc_context, &state->session_key);\n    if (state->ticket_reply.enc_part.ciphertext.data != NULL) {\n        memset(state->ticket_reply.enc_part.ciphertext.data , 0,\n               state->ticket_reply.enc_part.ciphertext.length);\n        free(state->ticket_reply.enc_part.ciphertext.data);\n    }\n\n    krb5_free_pa_data(kdc_context, state->e_data);\n    krb5_free_data(kdc_context, state->inner_body);\n    kdc_free_rstate(state->rstate);\n    krb5_free_kdc_req(kdc_context, state->request);\n    k5_free_data_ptr_list(state->auth_indicators);\n    assert(did_log != 0);\n\n    free(state);\n    (*oldrespond)(oldarg, errcode, response);\n}",
  "abstract_func": "static void\nfinish_process_as_req(struct as_req_state *VAR_0, krb5_error_code VAR_1)\n{\n    krb5_key_data *VAR_2;\n    krb5_keyblock *VAR_3 = NULL;\n    krb5_data *VAR_4 = NULL;\n    const char *VAR_5 = 0;\n    int VAR_6 = 0;\n    loop_respond_fn VAR_7;\n    void *VAR_8;\n    kdc_realm_t *VAR_9 = VAR_0->active_realm;\n    krb5_audit_state *VAR_10 = VAR_0->au_state;\n\n    assert(VAR_0);\n    VAR_7 = VAR_0->respond;\n    VAR_8 = VAR_0->arg;\n\n    if (VAR_1)\n        goto egress;\n\n    VAR_10->stage = VAR_11;\n\n    if ((VAR_1 = validate_forwardable(VAR_0->request, *VAR_0->client,\n                                        *VAR_0->server, VAR_0->kdc_time,\n                                        &VAR_0->status))) {\n        VAR_1 += VAR_12;\n        goto egress;\n    }\n\n    VAR_1 = check_indicators(VAR_13, VAR_0->server,\n                               VAR_0->auth_indicators);\n    if (VAR_1) {\n        VAR_0->status = \"HIGHER_AUTHENTICATION_REQUIRED\";\n        goto egress;\n    }\n\n    VAR_0->ticket_reply.enc_part2 = &VAR_0->enc_tkt_reply;\n\n    /* COMMENT_0 */\n                          \n       \n    if ((VAR_1 = krb5_dbe_find_enctype(VAR_13, VAR_0->server,\n                                         -1, /* COMMENT_3 */\n                                         -1, /* COMMENT_4 */\n                                         0,  /* COMMENT_5 */\n                                         &VAR_2))) {\n        VAR_0->status = \"FINDING_SERVER_KEY\";\n        goto egress;\n    }\n\n    /* COMMENT_6 */\n                                          \n                                            \n      \n                                                                      \n       \n    if ((VAR_1 = krb5_dbe_decrypt_key_data(VAR_13, NULL,\n                                             VAR_2,\n                                             &VAR_0->server_keyblock,\n                                             NULL))) {\n        VAR_0->status = \"DECRYPT_SERVER_KEY\";\n        goto egress;\n    }\n\n    /* COMMENT_12 */\n    VAR_0->reply.msg_type = VAR_14;\n    VAR_0->reply.client = VAR_0->enc_tkt_reply.client; /* COMMENT_13 */\n    VAR_0->reply.ticket = &VAR_0->ticket_reply;\n    VAR_0->reply_encpart.session = &VAR_0->session_key;\n    if ((VAR_1 = fetch_last_req_info(VAR_0->client,\n                                       &VAR_0->reply_encpart.last_req))) {\n        VAR_0->status = \"FETCH_LAST_REQ\";\n        goto egress;\n    }\n    VAR_0->reply_encpart.nonce = VAR_0->request->nonce;\n    VAR_0->reply_encpart.key_exp = get_key_exp(VAR_0->client);\n    VAR_0->reply_encpart.flags = VAR_0->enc_tkt_reply.flags;\n    VAR_0->reply_encpart.server = VAR_0->ticket_reply.server;\n\n    /* COMMENT_14 */\n                         \n       \n    VAR_0->reply_encpart.times = VAR_0->enc_tkt_reply.times;\n    VAR_0->reply_encpart.times.authtime = VAR_0->authtime = VAR_0->kdc_time;\n\n    VAR_0->reply_encpart.caddrs = VAR_0->enc_tkt_reply.caddrs;\n    VAR_0->reply_encpart.enc_padata = NULL;\n\n    /* COMMENT_17 */\n                                                            \n       \n    VAR_1 = return_padata(VAR_13, &VAR_0->rock, VAR_0->req_pkt,\n                            VAR_0->request, &VAR_0->reply,\n                            &VAR_0->client_keyblock, &VAR_0->pa_context);\n    if (VAR_1) {\n        VAR_0->status = \"KDC_RETURN_PADATA\";\n        goto egress;\n    }\n\n    /* COMMENT_20 */\n                                                \n    if (VAR_0->client_keyblock.enctype == VAR_15) {\n        VAR_0->status = \"CANT_FIND_CLIENT_KEY\";\n        VAR_1 = VAR_16;\n        goto egress;\n    }\n\n    VAR_1 = handle_authdata(VAR_13,\n                              VAR_0->c_flags,\n                              VAR_0->client,\n                              VAR_0->server,\n                              NULL,\n                              VAR_0->local_tgt,\n                              &VAR_0->client_keyblock,\n                              &VAR_0->server_keyblock,\n                              NULL,\n                              VAR_0->req_pkt,\n                              VAR_0->request,\n                              NULL, /* COMMENT_22 */\n                              NULL, /* COMMENT_23 */\n                              VAR_0->auth_indicators,\n                              &VAR_0->enc_tkt_reply);\n    if (VAR_1) {\n        krb5_klog_syslog(VAR_17, _(\"AS_REQ : handle_authdata (%d)\"),\n                         VAR_1);\n        VAR_0->status = \"HANDLE_AUTHDATA\";\n        goto egress;\n    }\n\n    VAR_1 = krb5_encrypt_tkt_part(VAR_13, &VAR_0->server_keyblock,\n                                    &VAR_0->ticket_reply);\n    if (VAR_1) {\n        VAR_0->status = \"ENCRYPT_TICKET\";\n        goto egress;\n    }\n\n    VAR_1 = kau_make_tkt_id(VAR_13, &VAR_0->ticket_reply,\n                              &VAR_10->tkt_out_id);\n    if (VAR_1) {\n        VAR_0->status = \"GENERATE_TICKET_ID\";\n        goto egress;\n    }\n\n    VAR_0->ticket_reply.enc_part.kvno = VAR_2->key_data_kvno;\n    VAR_1 = kdc_fast_response_handle_padata(VAR_0->rstate,\n                                              VAR_0->request,\n                                              &VAR_0->reply,\n                                              VAR_0->client_keyblock.enctype);\n    if (VAR_1) {\n        VAR_0->status = \"MAKE_FAST_RESPONSE\";\n        goto egress;\n    }\n\n    /* COMMENT_24 */\n\n    VAR_0->reply.enc_part.enctype = VAR_0->client_keyblock.enctype;\n\n    VAR_1 = kdc_fast_handle_reply_key(VAR_0->rstate, &VAR_0->client_keyblock,\n                                        &VAR_3);\n    if (VAR_1) {\n        VAR_0->status = \"MAKE_FAST_REPLY_KEY\";\n        goto egress;\n    }\n    VAR_1 = return_enc_padata(VAR_13, VAR_0->req_pkt, VAR_0->request,\n                                VAR_3, VAR_0->server,\n                                &VAR_0->reply_encpart, FALSE);\n    if (VAR_1) {\n        VAR_0->status = \"KDC_RETURN_ENC_PADATA\";\n        goto egress;\n    }\n\n    if (kdc_fast_hide_client(VAR_0->rstate))\n        VAR_0->reply.client = (krb5_principal)krb5_anonymous_principal();\n    VAR_1 = krb5_encode_kdc_rep(VAR_13, VAR_14,\n                                  &VAR_0->reply_encpart, 0,\n                                  VAR_3,\n                                  &VAR_0->reply, &VAR_4);\n    if (VAR_0->client_key != NULL)\n        VAR_0->reply.enc_part.kvno = VAR_0->client_key->key_data_kvno;\n    if (VAR_1) {\n        VAR_0->status = \"ENCODE_KDC_REP\";\n        goto egress;\n    }\n\n    /* COMMENT_25 */\n                                                               \n    memset(VAR_0->reply.enc_part.ciphertext.data, 0,\n           VAR_0->reply.enc_part.ciphertext.length);\n    free(VAR_0->reply.enc_part.ciphertext.data);\n\n    log_as_req(VAR_13, VAR_0->local_addr, VAR_0->remote_addr,\n               VAR_0->request, &VAR_0->reply, VAR_0->client, VAR_0->cname,\n               VAR_0->server, VAR_0->sname, VAR_0->authtime, 0, 0, 0);\n    VAR_6 = 1;\n\negress:\n    if (VAR_1 != 0 && VAR_0->status == NULL)\n        VAR_0->status = \"UNKNOWN_REASON\";\n\n    VAR_10->status = VAR_0->status;\n    VAR_10->reply = &VAR_0->reply;\n    kau_as_req(VAR_13,\n              (VAR_1 || VAR_0->preauth_err) ? FALSE : TRUE, VAR_10);\n    kau_free_kdc_req(VAR_10);\n\n    free_padata_context(VAR_13, VAR_0->pa_context);\n    if (VAR_3)\n        krb5_free_keyblock(VAR_13, VAR_3);\n    if (VAR_1)\n        VAR_5 = krb5_get_error_message(VAR_13, VAR_1);\n\n    if (VAR_0->status) {\n        log_as_req(VAR_13, VAR_0->local_addr, VAR_0->remote_addr,\n                   VAR_0->request, &VAR_0->reply, VAR_0->client,\n                   VAR_0->cname, VAR_0->server, VAR_0->sname, VAR_0->authtime,\n                   VAR_0->status, VAR_1, VAR_5);\n        VAR_6 = 1;\n    }\n    if (VAR_1) {\n        if (VAR_0->status == 0) {\n            VAR_0->status = VAR_5;\n        }\n        if (VAR_1 != VAR_18) {\n            VAR_1 -= VAR_12;\n            if (VAR_1 < 0 || VAR_1 > VAR_19)\n                VAR_1 = VAR_20;\n\n            VAR_1 = prepare_error_as(VAR_0->rstate, VAR_0->request,\n                                       VAR_0->local_tgt, VAR_1,\n                                       VAR_0->e_data, VAR_0->typed_e_data,\n                                       ((VAR_0->client != NULL) ?\n                                        VAR_0->client->princ : NULL),\n                                       &VAR_4, VAR_0->status);\n            VAR_0->status = 0;\n        }\n    }\n\n    if (VAR_5)\n        krb5_free_error_message(VAR_13, VAR_5);\n    if (VAR_0->enc_tkt_reply.authorization_data != NULL)\n        krb5_free_authdata(VAR_13,\n                           VAR_0->enc_tkt_reply.authorization_data);\n    if (VAR_0->server_keyblock.contents != NULL)\n        krb5_free_keyblock_contents(VAR_13, &VAR_0->server_keyblock);\n    if (VAR_0->client_keyblock.contents != NULL)\n        krb5_free_keyblock_contents(VAR_13, &VAR_0->client_keyblock);\n    if (VAR_0->reply.padata != NULL)\n        krb5_free_pa_data(VAR_13, VAR_0->reply.padata);\n    if (VAR_0->reply_encpart.enc_padata)\n        krb5_free_pa_data(VAR_13, VAR_0->reply_encpart.enc_padata);\n\n    if (VAR_0->cname != NULL)\n        free(VAR_0->cname);\n    if (VAR_0->sname != NULL)\n        free(VAR_0->sname);\n    krb5_db_free_principal(VAR_13, VAR_0->client);\n    krb5_db_free_principal(VAR_13, VAR_0->server);\n    krb5_db_free_principal(VAR_13, VAR_0->local_tgt_storage);\n    if (VAR_0->session_key.contents != NULL)\n        krb5_free_keyblock_contents(VAR_13, &VAR_0->session_key);\n    if (VAR_0->ticket_reply.enc_part.ciphertext.data != NULL) {\n        memset(VAR_0->ticket_reply.enc_part.ciphertext.data , 0,\n               VAR_0->ticket_reply.enc_part.ciphertext.length);\n        free(VAR_0->ticket_reply.enc_part.ciphertext.data);\n    }\n\n    krb5_free_pa_data(VAR_13, VAR_0->e_data);\n    krb5_free_data(VAR_13, VAR_0->inner_body);\n    kdc_free_rstate(VAR_0->rstate);\n    krb5_free_kdc_req(VAR_13, VAR_0->request);\n    k5_free_data_ptr_list(VAR_0->auth_indicators);\n    assert(VAR_6 != 0);\n\n    free(VAR_0);\n    (*VAR_7)(VAR_8, VAR_1, VAR_4);\n}",
  "func_graph_path": "krb5/ffb35baac6981f9e8914f8f3bffd37f284b85970/do_as_req.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -194,8 +194,8 @@\n     did_log = 1;\n \n egress:\n-    if (errcode != 0)\n-        assert (state->status != 0);\n+    if (errcode != 0 && state->status == NULL)\n+        state->status = \"UNKNOWN_REASON\";\n \n     au_state->status = state->status;\n     au_state->reply = &state->reply;",
  "diff_line_info": {
    "deleted_lines": [
      "    if (errcode != 0)",
      "        assert (state->status != 0);"
    ],
    "added_lines": [
      "    if (errcode != 0 && state->status == NULL)",
      "        state->status = \"UNKNOWN_REASON\";"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/krb5/krb5/pull/678",
  "description": {
    "pr_info": {
      "title": "Prevent KDC unset status assertion failures",
      "number": 678
    },
    "comment": [
      "Assign status values if S4U2Self padata fails to decode, if an\r\nS4U2Proxy request uses invalid KDC options, or if an S4U2Proxy request\r\nuses an evidence ticket which does not match the canonicalized request\r\nserver principal name.  Reported by Samuel Cabrero.\r\n    \r\nIf a status value is not assigned during KDC processing, default to\r\n\"UNKNOWN_REASON\" rather than failing an assertion.  This change will\r\nprevent future denial of service bugs due to similar mistakes, and\r\nwill allow us to omit assigning status values for unlikely errors such\r\nas small memory allocation failures.\r\n\r\n[There is a second non-backport commit to remove status assignments for error conditions which don't look practically reachable to me.]"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Output:**\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0  \n\n**Reasoning:** The commit addresses a known security vulnerability (CVE-2017-11368) by preventing assertion failures that could lead to a denial of service. The code change assigns a default status to avoid crashes, directly resolving the security issue. All elements are consistent and clearly indicate a security fix."
}