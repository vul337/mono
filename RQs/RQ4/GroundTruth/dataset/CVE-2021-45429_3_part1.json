{
  "cve_id": "CVE-2021-45429",
  "cwe_ids": [
    "CWE-120"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "VirusTotal/yara",
  "commit_msg": "Fix issue #1616\n\nThis is a more comprehensive fix than #1617, it adds new functions to the API for getting/setting uint32 and uint64 settings.  Using these functions is preferable over calling `yr_(get|set)_configuration` directly.",
  "commit_hash": "b34b7e74c862c129b801832b6b85401fbada2b01",
  "git_url": "https://github.com/VirusTotal/yara/commit/b34b7e74c862c129b801832b6b85401fbada2b01",
  "file_path": "libyara/proc/windows.c",
  "func_name": "yr_process_get_next_memory_block",
  "func_before": "YR_API YR_MEMORY_BLOCK* yr_process_get_next_memory_block(\n    YR_MEMORY_BLOCK_ITERATOR* iterator)\n{\n  YR_PROC_ITERATOR_CTX* context = (YR_PROC_ITERATOR_CTX*) iterator->context;\n  YR_PROC_INFO* proc_info = (YR_PROC_INFO*) context->proc_info;\n\n  MEMORY_BASIC_INFORMATION mbi;\n  void* address =\n      (void*) (context->current_block.base + context->current_block.size);\n  uint64_t max_process_memory_chunk;\n\n  yr_get_configuration(\n      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, (void*) &max_process_memory_chunk);\n\n  iterator->last_error = ERROR_SUCCESS;\n\n  while (address < proc_info->si.lpMaximumApplicationAddress &&\n         VirtualQueryEx(proc_info->hProcess, address, &mbi, sizeof(mbi)) != 0)\n  {\n    // mbi.RegionSize can overflow address while scanning a 64-bit process\n    // with a 32-bit YARA.\n    if ((uint8_t*) address + mbi.RegionSize <= (uint8_t*) address)\n      break;\n\n    if (mbi.State == MEM_COMMIT && ((mbi.Protect & PAGE_NOACCESS) == 0))\n    {\n      size_t chuck_size =\n          mbi.RegionSize -\n          (size_t) (((uint8_t*) address) - ((uint8_t*) mbi.BaseAddress));\n\n      if (((uint64_t) chuck_size) > max_process_memory_chunk)\n      {\n        chuck_size = (size_t) max_process_memory_chunk;\n      }\n\n      context->current_block.base = (size_t) address;\n      context->current_block.size = chuck_size;\n\n      return &context->current_block;\n    }\n\n    address = (uint8_t*) mbi.BaseAddress + mbi.RegionSize;\n  }\n\n  return NULL;\n}",
  "abstract_func_before": "YR_API VAR_0* yr_process_get_next_memory_block(\n    YR_MEMORY_BLOCK_ITERATOR* VAR_1)\n{\n  YR_PROC_ITERATOR_CTX* VAR_2 = (YR_PROC_ITERATOR_CTX*) VAR_1->context;\n  YR_PROC_INFO* VAR_3 = (YR_PROC_INFO*) VAR_2->proc_info;\n\n  MEMORY_BASIC_INFORMATION VAR_4;\n  void* VAR_5 =\n      (void*) (VAR_2->current_block.base + VAR_2->current_block.size);\n  uint64_t VAR_6;\n\n  yr_get_configuration(\n      VAR_7, (void*) &VAR_6);\n\n  VAR_1->last_error = VAR_8;\n\n  while (VAR_5 < VAR_3->si.lpMaximumApplicationAddress &&\n         VirtualQueryEx(VAR_3->hProcess, VAR_5, &VAR_4, sizeof(VAR_4)) != 0)\n  {\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n    if ((uint8_t*) VAR_5 + VAR_4.RegionSize <= (uint8_t*) VAR_5)\n      break;\n\n    if (VAR_4.State == VAR_9 && ((VAR_4.Protect & VAR_10) == 0))\n    {\n      size_t VAR_11 =\n          VAR_4.RegionSize -\n          (size_t) (((uint8_t*) VAR_5) - ((uint8_t*) VAR_4.BaseAddress));\n\n      if (((uint64_t) VAR_11) > VAR_6)\n      {\n        VAR_11 = (size_t) VAR_6;\n      }\n\n      VAR_2->current_block.base = (size_t) VAR_5;\n      VAR_2->current_block.size = VAR_11;\n\n      return &VAR_2->current_block;\n    }\n\n    VAR_5 = (uint8_t*) VAR_4.BaseAddress + VAR_4.RegionSize;\n  }\n\n  return NULL;\n}",
  "func_graph_path_before": null,
  "func": "YR_API YR_MEMORY_BLOCK* yr_process_get_next_memory_block(\n    YR_MEMORY_BLOCK_ITERATOR* iterator)\n{\n  YR_PROC_ITERATOR_CTX* context = (YR_PROC_ITERATOR_CTX*) iterator->context;\n  YR_PROC_INFO* proc_info = (YR_PROC_INFO*) context->proc_info;\n\n  MEMORY_BASIC_INFORMATION mbi;\n  void* address =\n      (void*) (context->current_block.base + context->current_block.size);\n  uint64_t max_process_memory_chunk;\n\n  yr_get_configuration_uint64(\n      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, &max_process_memory_chunk);\n\n  iterator->last_error = ERROR_SUCCESS;\n\n  while (address < proc_info->si.lpMaximumApplicationAddress &&\n         VirtualQueryEx(proc_info->hProcess, address, &mbi, sizeof(mbi)) != 0)\n  {\n    // mbi.RegionSize can overflow address while scanning a 64-bit process\n    // with a 32-bit YARA.\n    if ((uint8_t*) address + mbi.RegionSize <= (uint8_t*) address)\n      break;\n\n    if (mbi.State == MEM_COMMIT && ((mbi.Protect & PAGE_NOACCESS) == 0))\n    {\n      size_t chuck_size =\n          mbi.RegionSize -\n          (size_t) (((uint8_t*) address) - ((uint8_t*) mbi.BaseAddress));\n\n      if (((uint64_t) chuck_size) > max_process_memory_chunk)\n      {\n        chuck_size = (size_t) max_process_memory_chunk;\n      }\n\n      context->current_block.base = (size_t) address;\n      context->current_block.size = chuck_size;\n\n      return &context->current_block;\n    }\n\n    address = (uint8_t*) mbi.BaseAddress + mbi.RegionSize;\n  }\n\n  return NULL;\n}",
  "abstract_func": "YR_API VAR_0* yr_process_get_next_memory_block(\n    YR_MEMORY_BLOCK_ITERATOR* VAR_1)\n{\n  YR_PROC_ITERATOR_CTX* VAR_2 = (YR_PROC_ITERATOR_CTX*) VAR_1->context;\n  YR_PROC_INFO* VAR_3 = (YR_PROC_INFO*) VAR_2->proc_info;\n\n  MEMORY_BASIC_INFORMATION VAR_4;\n  void* VAR_5 =\n      (void*) (VAR_2->current_block.base + VAR_2->current_block.size);\n  uint64_t VAR_6;\n\n  yr_get_configuration_uint64(\n      VAR_7, &VAR_6);\n\n  VAR_1->last_error = VAR_8;\n\n  while (VAR_5 < VAR_3->si.lpMaximumApplicationAddress &&\n         VirtualQueryEx(VAR_3->hProcess, VAR_5, &VAR_4, sizeof(VAR_4)) != 0)\n  {\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n    if ((uint8_t*) VAR_5 + VAR_4.RegionSize <= (uint8_t*) VAR_5)\n      break;\n\n    if (VAR_4.State == VAR_9 && ((VAR_4.Protect & VAR_10) == 0))\n    {\n      size_t VAR_11 =\n          VAR_4.RegionSize -\n          (size_t) (((uint8_t*) VAR_5) - ((uint8_t*) VAR_4.BaseAddress));\n\n      if (((uint64_t) VAR_11) > VAR_6)\n      {\n        VAR_11 = (size_t) VAR_6;\n      }\n\n      VAR_2->current_block.base = (size_t) VAR_5;\n      VAR_2->current_block.size = VAR_11;\n\n      return &VAR_2->current_block;\n    }\n\n    VAR_5 = (uint8_t*) VAR_4.BaseAddress + VAR_4.RegionSize;\n  }\n\n  return NULL;\n}",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -9,8 +9,8 @@\n       (void*) (context->current_block.base + context->current_block.size);\n   uint64_t max_process_memory_chunk;\n \n-  yr_get_configuration(\n-      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, (void*) &max_process_memory_chunk);\n+  yr_get_configuration_uint64(\n+      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, &max_process_memory_chunk);\n \n   iterator->last_error = ERROR_SUCCESS;\n ",
  "diff_line_info": {
    "deleted_lines": [
      "  yr_get_configuration(",
      "      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, (void*) &max_process_memory_chunk);"
    ],
    "added_lines": [
      "  yr_get_configuration_uint64(",
      "      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, &max_process_memory_chunk);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/VirusTotal/yara/pull/1621",
  "description": {
    "pr_info": {
      "title": "Fix issue #1616",
      "number": 1621
    },
    "comment": [
      "This is a more comprehensive fix than #1617, it adds new functions to the API for getting/setting uint32 and uint64 settings.  Using these functions is preferable over calling `yr_(get|set)_configuration` directly."
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "Final Classification: Defect Remediation & Feature Upgrades; Confidence: 0.9"
}