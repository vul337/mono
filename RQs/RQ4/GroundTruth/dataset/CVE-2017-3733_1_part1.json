{
  "cve_id": "CVE-2017-3733",
  "cwe_ids": [
    "CWE-20"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "openssl",
  "commit_msg": "Don't change the state of the ETM flags until CCS processing\n\nChanging the ciphersuite during a renegotiation can result in a crash\nleading to a DoS attack. ETM has not been implemented in 1.1.0 for DTLS\nso this is TLS only.\n\nThe problem is caused by changing the flag indicating whether to use ETM\nor not immediately on negotiation of ETM, rather than at CCS. Therefore,\nduring a renegotiation, if the ETM state is changing (usually due to a\nchange of ciphersuite), then an error/crash will occur.\n\nDue to the fact that there are separate CCS messages for read and write\nwe actually now need two flags to determine whether to use ETM or not.\n\nCVE-2017-3733\n\nReviewed-by: Richard Levitte <levitte@openssl.org>",
  "commit_hash": "4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2",
  "git_url": "https://github.com/openssl/openssl/commit/4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2",
  "file_path": "ssl/record/ssl3_record.c",
  "func_name": "tls1_mac",
  "func_before": "int tls1_mac(SSL *ssl, SSL3_RECORD *rec, unsigned char *md, int send)\n{\n    unsigned char *seq;\n    EVP_MD_CTX *hash;\n    size_t md_size;\n    int i;\n    EVP_MD_CTX *hmac = NULL, *mac_ctx;\n    unsigned char header[13];\n    int stream_mac = (send ? (ssl->mac_flags & SSL_MAC_FLAG_WRITE_MAC_STREAM)\n                      : (ssl->mac_flags & SSL_MAC_FLAG_READ_MAC_STREAM));\n    int t;\n\n    if (send) {\n        seq = RECORD_LAYER_get_write_sequence(&ssl->rlayer);\n        hash = ssl->write_hash;\n    } else {\n        seq = RECORD_LAYER_get_read_sequence(&ssl->rlayer);\n        hash = ssl->read_hash;\n    }\n\n    t = EVP_MD_CTX_size(hash);\n    OPENSSL_assert(t >= 0);\n    md_size = t;\n\n    /* I should fix this up TLS TLS TLS TLS TLS XXXXXXXX */\n    if (stream_mac) {\n        mac_ctx = hash;\n    } else {\n        hmac = EVP_MD_CTX_new();\n        if (hmac == NULL || !EVP_MD_CTX_copy(hmac, hash))\n            return -1;\n        mac_ctx = hmac;\n    }\n\n    if (SSL_IS_DTLS(ssl)) {\n        unsigned char dtlsseq[8], *p = dtlsseq;\n\n        s2n(send ? DTLS_RECORD_LAYER_get_w_epoch(&ssl->rlayer) :\n            DTLS_RECORD_LAYER_get_r_epoch(&ssl->rlayer), p);\n        memcpy(p, &seq[2], 6);\n\n        memcpy(header, dtlsseq, 8);\n    } else\n        memcpy(header, seq, 8);\n\n    header[8] = rec->type;\n    header[9] = (unsigned char)(ssl->version >> 8);\n    header[10] = (unsigned char)(ssl->version);\n    header[11] = (rec->length) >> 8;\n    header[12] = (rec->length) & 0xff;\n\n    if (!send && !SSL_USE_ETM(ssl) &&\n        EVP_CIPHER_CTX_mode(ssl->enc_read_ctx) == EVP_CIPH_CBC_MODE &&\n        ssl3_cbc_record_digest_supported(mac_ctx)) {\n        /*\n         * This is a CBC-encrypted record. We must avoid leaking any\n         * timing-side channel information about how many blocks of data we\n         * are hashing because that gives an attacker a timing-oracle.\n         */\n        /* Final param == not SSLv3 */\n        if (ssl3_cbc_digest_record(mac_ctx,\n                                   md, &md_size,\n                                   header, rec->input,\n                                   rec->length + md_size, rec->orig_len,\n                                   ssl->s3->read_mac_secret,\n                                   ssl->s3->read_mac_secret_size, 0) <= 0) {\n            EVP_MD_CTX_free(hmac);\n            return -1;\n        }\n    } else {\n        if (EVP_DigestSignUpdate(mac_ctx, header, sizeof(header)) <= 0\n            || EVP_DigestSignUpdate(mac_ctx, rec->input, rec->length) <= 0\n            || EVP_DigestSignFinal(mac_ctx, md, &md_size) <= 0) {\n            EVP_MD_CTX_free(hmac);\n            return -1;\n        }\n        if (!send && !SSL_USE_ETM(ssl) && FIPS_mode())\n            if (!tls_fips_digest_extra(ssl->enc_read_ctx,\n                                       mac_ctx, rec->input,\n                                       rec->length, rec->orig_len)) {\n                EVP_MD_CTX_free(hmac);\n                return -1;\n            }\n    }\n\n    EVP_MD_CTX_free(hmac);\n\n#ifdef SSL_DEBUG\n    fprintf(stderr, \"seq=\");\n    {\n        int z;\n        for (z = 0; z < 8; z++)\n            fprintf(stderr, \"%02X \", seq[z]);\n        fprintf(stderr, \"\\n\");\n    }\n    fprintf(stderr, \"rec=\");\n    {\n        unsigned int z;\n        for (z = 0; z < rec->length; z++)\n            fprintf(stderr, \"%02X \", rec->data[z]);\n        fprintf(stderr, \"\\n\");\n    }\n#endif\n\n    if (!SSL_IS_DTLS(ssl)) {\n        for (i = 7; i >= 0; i--) {\n            ++seq[i];\n            if (seq[i] != 0)\n                break;\n        }\n    }\n#ifdef SSL_DEBUG\n    {\n        unsigned int z;\n        for (z = 0; z < md_size; z++)\n            fprintf(stderr, \"%02X \", md[z]);\n        fprintf(stderr, \"\\n\");\n    }\n#endif\n    return (md_size);\n}",
  "abstract_func_before": "int tls1_mac(SSL *VAR_0, SSL3_RECORD *VAR_1, unsigned char *VAR_2, int VAR_3)\n{\n    unsigned char *VAR_4;\n    EVP_MD_CTX *VAR_5;\n    size_t VAR_6;\n    int VAR_7;\n    EVP_MD_CTX *VAR_8 = NULL, *VAR_9;\n    unsigned char VAR_10[13];\n    int VAR_11 = (VAR_3 ? (VAR_0->mac_flags & VAR_12)\n                      : (VAR_0->mac_flags & VAR_13));\n    int VAR_14;\n\n    if (VAR_3) {\n        VAR_4 = RECORD_LAYER_get_write_sequence(&VAR_0->rlayer);\n        VAR_5 = VAR_0->write_hash;\n    } else {\n        VAR_4 = RECORD_LAYER_get_read_sequence(&VAR_0->rlayer);\n        VAR_5 = VAR_0->read_hash;\n    }\n\n    VAR_14 = EVP_MD_CTX_size(VAR_5);\n    OPENSSL_assert(VAR_14 >= 0);\n    VAR_6 = VAR_14;\n\n    /* COMMENT_0 */\n    if (VAR_11) {\n        VAR_9 = VAR_5;\n    } else {\n        VAR_8 = EVP_MD_CTX_new();\n        if (VAR_8 == NULL || !EVP_MD_CTX_copy(VAR_8, VAR_5))\n            return -1;\n        VAR_9 = VAR_8;\n    }\n\n    if (SSL_IS_DTLS(VAR_0)) {\n        unsigned char VAR_15[8], *VAR_16 = VAR_15;\n\n        s2n(VAR_3 ? DTLS_RECORD_LAYER_get_w_epoch(&VAR_0->rlayer) :\n            DTLS_RECORD_LAYER_get_r_epoch(&VAR_0->rlayer), VAR_16);\n        memcpy(VAR_16, &VAR_4[2], 6);\n\n        memcpy(VAR_10, VAR_15, 8);\n    } else\n        memcpy(VAR_10, VAR_4, 8);\n\n    VAR_10[8] = VAR_1->type;\n    VAR_10[9] = (unsigned char)(VAR_0->version >> 8);\n    VAR_10[10] = (unsigned char)(VAR_0->version);\n    VAR_10[11] = (VAR_1->length) >> 8;\n    VAR_10[12] = (VAR_1->length) & 0xff;\n\n    if (!VAR_3 && !SSL_USE_ETM(VAR_0) &&\n        EVP_CIPHER_CTX_mode(VAR_0->enc_read_ctx) == VAR_17 &&\n        ssl3_cbc_record_digest_supported(VAR_9)) {\n        /* COMMENT_1 */\n                                                                    \n                                                                           \n                                                                      \n           \n        /* COMMENT_6 */\n        if (ssl3_cbc_digest_record(VAR_9,\n                                   VAR_2, &VAR_6,\n                                   VAR_10, VAR_1->input,\n                                   VAR_1->length + VAR_6, VAR_1->orig_len,\n                                   VAR_0->s3->read_mac_secret,\n                                   VAR_0->s3->read_mac_secret_size, 0) <= 0) {\n            EVP_MD_CTX_free(VAR_8);\n            return -1;\n        }\n    } else {\n        if (EVP_DigestSignUpdate(VAR_9, VAR_10, sizeof(VAR_10)) <= 0\n            || EVP_DigestSignUpdate(VAR_9, VAR_1->input, VAR_1->length) <= 0\n            || EVP_DigestSignFinal(VAR_9, VAR_2, &VAR_6) <= 0) {\n            EVP_MD_CTX_free(VAR_8);\n            return -1;\n        }\n        if (!VAR_3 && !SSL_USE_ETM(VAR_0) && FIPS_mode())\n            if (!tls_fips_digest_extra(VAR_0->enc_read_ctx,\n                                       VAR_9, VAR_1->input,\n                                       VAR_1->length, VAR_1->orig_len)) {\n                EVP_MD_CTX_free(VAR_8);\n                return -1;\n            }\n    }\n\n    EVP_MD_CTX_free(VAR_8);\n\n#ifdef VAR_18\n    fprintf(VAR_19, \"seq=\");\n    {\n        int VAR_20;\n        for (VAR_20 = 0; VAR_20 < 8; VAR_20++)\n            fprintf(VAR_19, \"%02X \", VAR_4[VAR_20]);\n        fprintf(VAR_19, \"\\n\");\n    }\n    fprintf(VAR_19, \"rec=\");\n    {\n        unsigned int VAR_20;\n        for (VAR_20 = 0; VAR_20 < VAR_1->length; VAR_20++)\n            fprintf(VAR_19, \"%02X \", VAR_1->data[VAR_20]);\n        fprintf(VAR_19, \"\\n\");\n    }\n#endif\n\n    if (!SSL_IS_DTLS(VAR_0)) {\n        for (VAR_7 = 7; VAR_7 >= 0; VAR_7--) {\n            ++VAR_4[VAR_7];\n            if (VAR_4[VAR_7] != 0)\n                break;\n        }\n    }\n#ifdef VAR_18\n    {\n        unsigned int VAR_20;\n        for (VAR_20 = 0; VAR_20 < VAR_6; VAR_20++)\n            fprintf(VAR_19, \"%02X \", VAR_2[VAR_20]);\n        fprintf(VAR_19, \"\\n\");\n    }\n#endif\n    return (VAR_6);\n}",
  "func_graph_path_before": "openssl/4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2/ssl3_record.c/vul/before/2.json",
  "func": "int tls1_mac(SSL *ssl, SSL3_RECORD *rec, unsigned char *md, int send)\n{\n    unsigned char *seq;\n    EVP_MD_CTX *hash;\n    size_t md_size;\n    int i;\n    EVP_MD_CTX *hmac = NULL, *mac_ctx;\n    unsigned char header[13];\n    int stream_mac = (send ? (ssl->mac_flags & SSL_MAC_FLAG_WRITE_MAC_STREAM)\n                      : (ssl->mac_flags & SSL_MAC_FLAG_READ_MAC_STREAM));\n    int t;\n\n    if (send) {\n        seq = RECORD_LAYER_get_write_sequence(&ssl->rlayer);\n        hash = ssl->write_hash;\n    } else {\n        seq = RECORD_LAYER_get_read_sequence(&ssl->rlayer);\n        hash = ssl->read_hash;\n    }\n\n    t = EVP_MD_CTX_size(hash);\n    OPENSSL_assert(t >= 0);\n    md_size = t;\n\n    /* I should fix this up TLS TLS TLS TLS TLS XXXXXXXX */\n    if (stream_mac) {\n        mac_ctx = hash;\n    } else {\n        hmac = EVP_MD_CTX_new();\n        if (hmac == NULL || !EVP_MD_CTX_copy(hmac, hash))\n            return -1;\n        mac_ctx = hmac;\n    }\n\n    if (SSL_IS_DTLS(ssl)) {\n        unsigned char dtlsseq[8], *p = dtlsseq;\n\n        s2n(send ? DTLS_RECORD_LAYER_get_w_epoch(&ssl->rlayer) :\n            DTLS_RECORD_LAYER_get_r_epoch(&ssl->rlayer), p);\n        memcpy(p, &seq[2], 6);\n\n        memcpy(header, dtlsseq, 8);\n    } else\n        memcpy(header, seq, 8);\n\n    header[8] = rec->type;\n    header[9] = (unsigned char)(ssl->version >> 8);\n    header[10] = (unsigned char)(ssl->version);\n    header[11] = (rec->length) >> 8;\n    header[12] = (rec->length) & 0xff;\n\n    if (!send && !SSL_READ_ETM(ssl) &&\n        EVP_CIPHER_CTX_mode(ssl->enc_read_ctx) == EVP_CIPH_CBC_MODE &&\n        ssl3_cbc_record_digest_supported(mac_ctx)) {\n        /*\n         * This is a CBC-encrypted record. We must avoid leaking any\n         * timing-side channel information about how many blocks of data we\n         * are hashing because that gives an attacker a timing-oracle.\n         */\n        /* Final param == not SSLv3 */\n        if (ssl3_cbc_digest_record(mac_ctx,\n                                   md, &md_size,\n                                   header, rec->input,\n                                   rec->length + md_size, rec->orig_len,\n                                   ssl->s3->read_mac_secret,\n                                   ssl->s3->read_mac_secret_size, 0) <= 0) {\n            EVP_MD_CTX_free(hmac);\n            return -1;\n        }\n    } else {\n        if (EVP_DigestSignUpdate(mac_ctx, header, sizeof(header)) <= 0\n            || EVP_DigestSignUpdate(mac_ctx, rec->input, rec->length) <= 0\n            || EVP_DigestSignFinal(mac_ctx, md, &md_size) <= 0) {\n            EVP_MD_CTX_free(hmac);\n            return -1;\n        }\n        if (!send && !SSL_READ_ETM(ssl) && FIPS_mode())\n            if (!tls_fips_digest_extra(ssl->enc_read_ctx,\n                                       mac_ctx, rec->input,\n                                       rec->length, rec->orig_len)) {\n                EVP_MD_CTX_free(hmac);\n                return -1;\n            }\n    }\n\n    EVP_MD_CTX_free(hmac);\n\n#ifdef SSL_DEBUG\n    fprintf(stderr, \"seq=\");\n    {\n        int z;\n        for (z = 0; z < 8; z++)\n            fprintf(stderr, \"%02X \", seq[z]);\n        fprintf(stderr, \"\\n\");\n    }\n    fprintf(stderr, \"rec=\");\n    {\n        unsigned int z;\n        for (z = 0; z < rec->length; z++)\n            fprintf(stderr, \"%02X \", rec->data[z]);\n        fprintf(stderr, \"\\n\");\n    }\n#endif\n\n    if (!SSL_IS_DTLS(ssl)) {\n        for (i = 7; i >= 0; i--) {\n            ++seq[i];\n            if (seq[i] != 0)\n                break;\n        }\n    }\n#ifdef SSL_DEBUG\n    {\n        unsigned int z;\n        for (z = 0; z < md_size; z++)\n            fprintf(stderr, \"%02X \", md[z]);\n        fprintf(stderr, \"\\n\");\n    }\n#endif\n    return (md_size);\n}",
  "abstract_func": "int tls1_mac(SSL *VAR_0, SSL3_RECORD *VAR_1, unsigned char *VAR_2, int VAR_3)\n{\n    unsigned char *VAR_4;\n    EVP_MD_CTX *VAR_5;\n    size_t VAR_6;\n    int VAR_7;\n    EVP_MD_CTX *VAR_8 = NULL, *VAR_9;\n    unsigned char VAR_10[13];\n    int VAR_11 = (VAR_3 ? (VAR_0->mac_flags & VAR_12)\n                      : (VAR_0->mac_flags & VAR_13));\n    int VAR_14;\n\n    if (VAR_3) {\n        VAR_4 = RECORD_LAYER_get_write_sequence(&VAR_0->rlayer);\n        VAR_5 = VAR_0->write_hash;\n    } else {\n        VAR_4 = RECORD_LAYER_get_read_sequence(&VAR_0->rlayer);\n        VAR_5 = VAR_0->read_hash;\n    }\n\n    VAR_14 = EVP_MD_CTX_size(VAR_5);\n    OPENSSL_assert(VAR_14 >= 0);\n    VAR_6 = VAR_14;\n\n    /* COMMENT_0 */\n    if (VAR_11) {\n        VAR_9 = VAR_5;\n    } else {\n        VAR_8 = EVP_MD_CTX_new();\n        if (VAR_8 == NULL || !EVP_MD_CTX_copy(VAR_8, VAR_5))\n            return -1;\n        VAR_9 = VAR_8;\n    }\n\n    if (SSL_IS_DTLS(VAR_0)) {\n        unsigned char VAR_15[8], *VAR_16 = VAR_15;\n\n        s2n(VAR_3 ? DTLS_RECORD_LAYER_get_w_epoch(&VAR_0->rlayer) :\n            DTLS_RECORD_LAYER_get_r_epoch(&VAR_0->rlayer), VAR_16);\n        memcpy(VAR_16, &VAR_4[2], 6);\n\n        memcpy(VAR_10, VAR_15, 8);\n    } else\n        memcpy(VAR_10, VAR_4, 8);\n\n    VAR_10[8] = VAR_1->type;\n    VAR_10[9] = (unsigned char)(VAR_0->version >> 8);\n    VAR_10[10] = (unsigned char)(VAR_0->version);\n    VAR_10[11] = (VAR_1->length) >> 8;\n    VAR_10[12] = (VAR_1->length) & 0xff;\n\n    if (!VAR_3 && !SSL_READ_ETM(VAR_0) &&\n        EVP_CIPHER_CTX_mode(VAR_0->enc_read_ctx) == VAR_17 &&\n        ssl3_cbc_record_digest_supported(VAR_9)) {\n        /* COMMENT_1 */\n                                                                    \n                                                                           \n                                                                      \n           \n        /* COMMENT_6 */\n        if (ssl3_cbc_digest_record(VAR_9,\n                                   VAR_2, &VAR_6,\n                                   VAR_10, VAR_1->input,\n                                   VAR_1->length + VAR_6, VAR_1->orig_len,\n                                   VAR_0->s3->read_mac_secret,\n                                   VAR_0->s3->read_mac_secret_size, 0) <= 0) {\n            EVP_MD_CTX_free(VAR_8);\n            return -1;\n        }\n    } else {\n        if (EVP_DigestSignUpdate(VAR_9, VAR_10, sizeof(VAR_10)) <= 0\n            || EVP_DigestSignUpdate(VAR_9, VAR_1->input, VAR_1->length) <= 0\n            || EVP_DigestSignFinal(VAR_9, VAR_2, &VAR_6) <= 0) {\n            EVP_MD_CTX_free(VAR_8);\n            return -1;\n        }\n        if (!VAR_3 && !SSL_READ_ETM(VAR_0) && FIPS_mode())\n            if (!tls_fips_digest_extra(VAR_0->enc_read_ctx,\n                                       VAR_9, VAR_1->input,\n                                       VAR_1->length, VAR_1->orig_len)) {\n                EVP_MD_CTX_free(VAR_8);\n                return -1;\n            }\n    }\n\n    EVP_MD_CTX_free(VAR_8);\n\n#ifdef VAR_18\n    fprintf(VAR_19, \"seq=\");\n    {\n        int VAR_20;\n        for (VAR_20 = 0; VAR_20 < 8; VAR_20++)\n            fprintf(VAR_19, \"%02X \", VAR_4[VAR_20]);\n        fprintf(VAR_19, \"\\n\");\n    }\n    fprintf(VAR_19, \"rec=\");\n    {\n        unsigned int VAR_20;\n        for (VAR_20 = 0; VAR_20 < VAR_1->length; VAR_20++)\n            fprintf(VAR_19, \"%02X \", VAR_1->data[VAR_20]);\n        fprintf(VAR_19, \"\\n\");\n    }\n#endif\n\n    if (!SSL_IS_DTLS(VAR_0)) {\n        for (VAR_7 = 7; VAR_7 >= 0; VAR_7--) {\n            ++VAR_4[VAR_7];\n            if (VAR_4[VAR_7] != 0)\n                break;\n        }\n    }\n#ifdef VAR_18\n    {\n        unsigned int VAR_20;\n        for (VAR_20 = 0; VAR_20 < VAR_6; VAR_20++)\n            fprintf(VAR_19, \"%02X \", VAR_2[VAR_20]);\n        fprintf(VAR_19, \"\\n\");\n    }\n#endif\n    return (VAR_6);\n}",
  "func_graph_path": "openssl/4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2/ssl3_record.c/vul/after/2.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -49,7 +49,7 @@\n     header[11] = (rec->length) >> 8;\n     header[12] = (rec->length) & 0xff;\n \n-    if (!send && !SSL_USE_ETM(ssl) &&\n+    if (!send && !SSL_READ_ETM(ssl) &&\n         EVP_CIPHER_CTX_mode(ssl->enc_read_ctx) == EVP_CIPH_CBC_MODE &&\n         ssl3_cbc_record_digest_supported(mac_ctx)) {\n         /*\n@@ -74,7 +74,7 @@\n             EVP_MD_CTX_free(hmac);\n             return -1;\n         }\n-        if (!send && !SSL_USE_ETM(ssl) && FIPS_mode())\n+        if (!send && !SSL_READ_ETM(ssl) && FIPS_mode())\n             if (!tls_fips_digest_extra(ssl->enc_read_ctx,\n                                        mac_ctx, rec->input,\n                                        rec->length, rec->orig_len)) {",
  "diff_line_info": {
    "deleted_lines": [
      "    if (!send && !SSL_USE_ETM(ssl) &&",
      "        if (!send && !SSL_USE_ETM(ssl) && FIPS_mode())"
    ],
    "added_lines": [
      "    if (!send && !SSL_READ_ETM(ssl) &&",
      "        if (!send && !SSL_READ_ETM(ssl) && FIPS_mode())"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/EktapopaT/openssl/pull/1",
  "description": {
    "pr_info": {
      "title": "Open ssl 1 1 0 stable",
      "number": 1
    },
    "comment": [
      "<!--\r\nThank you for your pull request. Please review below requirements.\r\n\r\nContributors guide: https://github.com/openssl/openssl/blob/master/CONTRIBUTING\r\n-->\r\n\r\n##### Checklist\r\n<!-- Remove items that do not apply. For completed items, change [ ] to [x]. -->\r\n- [ ] documentation is added or updated\r\n- [ ] tests are added or updated\r\n- [ ] CLA is signed\r\n\r\n##### Description of change\r\n<!-- Provide a description of the changes.\r\n\r\nIf it fixes a github issue, add Fixes #XXXX.\r\n-->\r\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}