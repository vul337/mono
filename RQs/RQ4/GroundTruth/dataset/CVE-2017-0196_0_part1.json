{
  "cve_id": "CVE-2017-0196",
  "cwe_ids": [
    "CWE-200"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:N/A:N",
  "cvss_is_v3": false,
  "repo_name": "chakra-core/ChakraCore",
  "commit_msg": "[CVE-2017-0196] Fixing an heap overread during slice.\n\nThe MissingItem check is happening on the array in a loop. It is possible that we get called into script and that mutates the array. So the Array's head is newly created with length.\nHowever the loop is still performing over the old length.\nFixed this by checking the length In IsMissingItem function.\nAdded a unittest.",
  "commit_hash": "065b7978c40ded35c356ced6cd922a40156c9c46",
  "git_url": "https://github.com/chakra-core/ChakraCore/commit/065b7978c40ded35c356ced6cd922a40156c9c46",
  "file_path": "lib/Runtime/Library/JavascriptArray.cpp",
  "func_name": "JavascriptArray::SliceHelper",
  "func_before": "void JavascriptArray::SliceHelper(JavascriptArray* pArr,  JavascriptArray* pnewArr, uint32 start, uint32 newLen)\n    {\n        SparseArraySegment<T>* headSeg = (SparseArraySegment<T>*)pArr->head;\n        SparseArraySegment<T>* pnewHeadSeg = (SparseArraySegment<T>*)pnewArr->head;\n\n        // Fill the newly created sliced array\n        js_memcpy_s(pnewHeadSeg->elements, sizeof(T) * newLen, headSeg->elements + start, sizeof(T) * newLen);\n        pnewHeadSeg->length = newLen;\n\n        Assert(pnewHeadSeg->length <= pnewHeadSeg->size);\n        // Prototype lookup for missing elements\n        if (!pArr->HasNoMissingValues())\n        {\n            for (uint32 i = 0; i < newLen; i++)\n            {\n                // array type might be changed in the below call to DirectGetItemAtFull\n                // need recheck array type before checking array item [i + start]\n                if (pArr->IsMissingItem(i + start))\n                {\n                    Var element;\n                    pnewArr->SetHasNoMissingValues(false);\n                    if (pArr->DirectGetItemAtFull(i + start, &element))\n                    {\n                        pnewArr->SetItem(i, element, PropertyOperation_None);\n                    }\n                }\n            }\n        }\n#ifdef DBG\n        else\n        {\n            for (uint32 i = 0; i < newLen; i++)\n            {\n                AssertMsg(!SparseArraySegment<T>::IsMissingItem(&headSeg->elements[i+start]), \"Array marked incorrectly as having missing value\");\n            }\n        }\n\n#endif\n    }",
  "abstract_func_before": "void JavascriptArray::SliceHelper(JavascriptArray* VAR_0,  JavascriptArray* VAR_1, uint32 VAR_2, uint32 VAR_3)\n    {\n        SparseArraySegment<T>* VAR_4 = (SparseArraySegment<T>*)VAR_0->head;\n        SparseArraySegment<T>* VAR_5 = (SparseArraySegment<T>*)VAR_1->head;\n\n        /* COMMENT_0 */\n        js_memcpy_s(VAR_5->elements, sizeof(T) * VAR_3, VAR_4->elements + VAR_2, sizeof(T) * VAR_3);\n        VAR_5->length = VAR_3;\n\n        Assert(VAR_5->length <= VAR_5->size);\n        /* COMMENT_1 */\n        if (!VAR_0->HasNoMissingValues())\n        {\n            for (uint32 VAR_6 = 0; VAR_6 < VAR_3; VAR_6++)\n            {\n                /* COMMENT_2 */\n                /* COMMENT_3 */\n                if (VAR_0->IsMissingItem(VAR_6 + VAR_2))\n                {\n                    Var VAR_7;\n                    VAR_1->SetHasNoMissingValues(false);\n                    if (VAR_0->DirectGetItemAtFull(VAR_6 + VAR_2, &VAR_7))\n                    {\n                        VAR_1->SetItem(VAR_6, VAR_7, VAR_8);\n                    }\n                }\n            }\n        }\n#ifdef VAR_9\n        else\n        {\n            for (uint32 VAR_6 = 0; i < VAR_3; i++)\n            {\n                AssertMsg(!SparseArraySegment<T>::IsMissingItem(&VAR_4->elements[i+VAR_2]), \"Array marked incorrectly as having missing value\");\n            }\n        }\n\n#endif\n    }",
  "func_graph_path_before": "chakra-core/ChakraCore/065b7978c40ded35c356ced6cd922a40156c9c46/JavascriptArray.cpp/vul/before/1.json",
  "func": "void JavascriptArray::SliceHelper(JavascriptArray* pArr,  JavascriptArray* pnewArr, uint32 start, uint32 newLen)\n    {\n        SparseArraySegment<T>* headSeg = (SparseArraySegment<T>*)pArr->head;\n        SparseArraySegment<T>* pnewHeadSeg = (SparseArraySegment<T>*)pnewArr->head;\n\n        // Fill the newly created sliced array\n        js_memcpy_s(pnewHeadSeg->elements, sizeof(T) * newLen, headSeg->elements + start, sizeof(T) * newLen);\n        pnewHeadSeg->length = newLen;\n\n        Assert(pnewHeadSeg->length <= pnewHeadSeg->size);\n        // Prototype lookup for missing elements\n        if (!pArr->HasNoMissingValues())\n        {\n            for (uint32 i = 0; i < newLen && (i + start) < pArr->length; i++)\n            {\n                // array type might be changed in the below call to DirectGetItemAtFull\n                // need recheck array type before checking array item [i + start]\n                if (pArr->IsMissingItem(i + start))\n                {\n                    Var element;\n                    pnewArr->SetHasNoMissingValues(false);\n                    if (pArr->DirectGetItemAtFull(i + start, &element))\n                    {\n                        pnewArr->SetItem(i, element, PropertyOperation_None);\n                    }\n                }\n            }\n        }\n#ifdef DBG\n        else\n        {\n            for (uint32 i = 0; i < newLen; i++)\n            {\n                AssertMsg(!SparseArraySegment<T>::IsMissingItem(&headSeg->elements[i+start]), \"Array marked incorrectly as having missing value\");\n            }\n        }\n\n#endif\n    }",
  "abstract_func": "void JavascriptArray::SliceHelper(JavascriptArray* VAR_0,  JavascriptArray* VAR_1, uint32 VAR_2, uint32 VAR_3)\n    {\n        SparseArraySegment<T>* VAR_4 = (SparseArraySegment<T>*)VAR_0->head;\n        SparseArraySegment<T>* VAR_5 = (SparseArraySegment<T>*)VAR_1->head;\n\n        /* COMMENT_0 */\n        js_memcpy_s(VAR_5->elements, sizeof(T) * VAR_3, VAR_4->elements + VAR_2, sizeof(T) * VAR_3);\n        VAR_5->length = VAR_3;\n\n        Assert(VAR_5->length <= VAR_5->size);\n        /* COMMENT_1 */\n        if (!VAR_0->HasNoMissingValues())\n        {\n            for (uint32 VAR_6 = 0; VAR_6 < VAR_3 && (VAR_6 + VAR_2) < VAR_0->length; VAR_6++)\n            {\n                /* COMMENT_2 */\n                /* COMMENT_3 */\n                if (VAR_0->IsMissingItem(VAR_6 + VAR_2))\n                {\n                    Var VAR_7;\n                    VAR_1->SetHasNoMissingValues(false);\n                    if (VAR_0->DirectGetItemAtFull(VAR_6 + VAR_2, &VAR_7))\n                    {\n                        VAR_1->SetItem(VAR_6, VAR_7, VAR_8);\n                    }\n                }\n            }\n        }\n#ifdef VAR_9\n        else\n        {\n            for (uint32 VAR_6 = 0; i < VAR_3; i++)\n            {\n                AssertMsg(!SparseArraySegment<T>::IsMissingItem(&VAR_4->elements[i+VAR_2]), \"Array marked incorrectly as having missing value\");\n            }\n        }\n\n#endif\n    }",
  "func_graph_path": "chakra-core/ChakraCore/065b7978c40ded35c356ced6cd922a40156c9c46/JavascriptArray.cpp/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -11,7 +11,7 @@\n         // Prototype lookup for missing elements\n         if (!pArr->HasNoMissingValues())\n         {\n-            for (uint32 i = 0; i < newLen; i++)\n+            for (uint32 i = 0; i < newLen && (i + start) < pArr->length; i++)\n             {\n                 // array type might be changed in the below call to DirectGetItemAtFull\n                 // need recheck array type before checking array item [i + start]",
  "diff_line_info": {
    "deleted_lines": [
      "            for (uint32 i = 0; i < newLen; i++)"
    ],
    "added_lines": [
      "            for (uint32 i = 0; i < newLen && (i + start) < pArr->length; i++)"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/chakra-core/ChakraCore/pull/2697",
  "description": {
    "pr_info": {
      "title": "17-03 ChakraCore servicing release",
      "number": 2697
    },
    "comment": [
      "Fixes the following CVEs impacting ChakraCore:\r\nCVE-2017-0067\r\nCVE-2017-0150\r\nCVE-2017-0138\r\nCVE-2017-0094\r\nCVE-2017-0132\r\nCVE-2017-0133\r\nCVE-2017-0134\r\nCVE-2017-0137\r\nCVE-2017-0071\r\nCVE-2017-0151\r\nCVE-2017-0141\r\nCVE-2017-0196\r\nCVE-2017-0136\r\nCVE-2017-0152\r\nCVE-2017-0010\r\nCVE-2017-0035\r\nCVE-2017-0015\r\nCVE-2017-0028",
      "@Cellule @Penguinwizzard @agarwal-sandeep @tcare @pleath @akroshg @aneeshdk @suwc @leirocks FYI",
      "My 2 commits look good.",
      "LGTM.",
      "LGTM",
      "LGTM",
      "LGTM",
      "LGTM"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Step-by-Step Explanation:**\n\n1. **Key Terms Identified:**\n   - CVE-2017-0196 (security identifier)\n   - Heap overread (security vulnerability)\n   - MissingItem check\n   - Array mutation\n   - Loop condition fix\n\n2. **Consistency Check:**\n   - Commit message aligns with code changes addressing an overread vulnerability.\n\n3. **Purpose Evaluation:**\n   - Modifies core logic to fix a security issue, not merely for testing or configuration.\n\n4. **Security Assessment:**\n   - Fixes an exploitable heap overread (memory issue), a clear security vulnerability.\n\n5. **Confidence Score:**\n   - 1.0 (Clear CVE reference, code addresses security issue directly.)\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}