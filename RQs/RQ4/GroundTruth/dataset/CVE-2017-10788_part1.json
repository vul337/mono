{
  "cve_id": "CVE-2017-10788",
  "cwe_ids": [
    "CWE-416"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "perl5-dbi/DBD-mysql",
  "commit_msg": "Fix use-after-free after calling mysql_stmt_close()\n\nIgnore return value from mysql_stmt_close() and also its error message\nbecause it points to freed memory after mysql_stmt_close() was called.",
  "commit_hash": "18e348b57160bfb45da1a5051a3466c8c6635e49",
  "git_url": "https://github.com/perl5-dbi/DBD-mysql/commit/18e348b57160bfb45da1a5051a3466c8c6635e49",
  "file_path": "dbdimp.c",
  "func_name": "dbd_st_destroy",
  "func_before": "void dbd_st_destroy(SV *sth, imp_sth_t *imp_sth) {\n  dTHX;\n  D_imp_xxh(sth);\n\n#if defined (dTHR)\n  dTHR;\n#endif\n\n  int i;\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n  imp_sth_fbh_t *fbh;\n  int n;\n\n  n= DBIc_NUM_PARAMS(imp_sth);\n  if (n)\n  {\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tFreeing %d parameters, bind %p fbind %p\\n\",\n          n, imp_sth->bind, imp_sth->fbind);\n\n    free_bind(imp_sth->bind);\n    free_fbind(imp_sth->fbind);\n  }\n\n  fbh= imp_sth->fbh;\n  if (fbh)\n  {\n    n = DBIc_NUM_FIELDS(imp_sth);\n    i = 0;\n    while (i < n)\n    {\n      if (fbh[i].data) Safefree(fbh[i].data);\n      ++i;\n    }\n\n    free_fbuffer(fbh);\n    if (imp_sth->buffer)\n      free_bind(imp_sth->buffer);\n  }\n\n  if (imp_sth->stmt)\n  {\n    if (mysql_stmt_close(imp_sth->stmt))\n    {\n      do_error(DBIc_PARENT_H(imp_sth), mysql_stmt_errno(imp_sth->stmt),\n          mysql_stmt_error(imp_sth->stmt),\n          mysql_stmt_sqlstate(imp_sth->stmt));\n    }\n  }\n#endif\n\n\n  /* dbd_st_finish has already been called by .xs code if needed.\t*/\n\n  /* Free values allocated by dbd_bind_ph */\n  if (imp_sth->params)\n  {\n    free_param(aTHX_ imp_sth->params, DBIc_NUM_PARAMS(imp_sth));\n    imp_sth->params= NULL;\n  }\n\n  /* Free cached array attributes */\n  for (i= 0; i < AV_ATTRIB_LAST; i++)\n  {\n    if (imp_sth->av_attr[i])\n      SvREFCNT_dec(imp_sth->av_attr[i]);\n    imp_sth->av_attr[i]= Nullav;\n  }\n  /* let DBI know we've done it   */\n  DBIc_IMPSET_off(imp_sth);\n}",
  "abstract_func_before": "void dbd_st_destroy(SV *VAR_0, imp_sth_t *VAR_1) {\n  VAR_2;\n  D_imp_xxh(VAR_0);\n\n#if defined (VAR_3)\n  VAR_3;\n#endif\n\n  int VAR_4;\n\n#if VAR_5 >= VAR_6\n  imp_sth_fbh_t *VAR_7;\n  int VAR_8;\n\n  VAR_8= DBIc_NUM_PARAMS(VAR_1);\n  if (VAR_8)\n  {\n    if (DBIc_TRACE_LEVEL(VAR_9) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(VAR_9), \"\\tFreeing %d parameters, bind %p fbind %p\\n\",\n          VAR_8, VAR_1->bind, VAR_1->fbind);\n\n    free_bind(VAR_1->bind);\n    free_fbind(VAR_1->fbind);\n  }\n\n  VAR_7= VAR_1->fbh;\n  if (VAR_7)\n  {\n    VAR_8 = DBIc_NUM_FIELDS(VAR_1);\n    VAR_4 = 0;\n    while (VAR_4 < VAR_8)\n    {\n      if (VAR_7[VAR_4].data) Safefree(VAR_7[VAR_4].data);\n      ++VAR_4;\n    }\n\n    free_fbuffer(VAR_7);\n    if (VAR_1->buffer)\n      free_bind(VAR_1->buffer);\n  }\n\n  if (VAR_1->stmt)\n  {\n    if (mysql_stmt_close(VAR_1->stmt))\n    {\n      do_error(DBIc_PARENT_H(VAR_1), mysql_stmt_errno(VAR_1->stmt),\n          mysql_stmt_error(VAR_1->stmt),\n          mysql_stmt_sqlstate(VAR_1->stmt));\n    }\n  }\n#endif\n\n\n  /* COMMENT_0 */\n\n  /* COMMENT_1 */\n  if (VAR_1->params)\n  {\n    VAR_10(aTHX_ VAR_1->params, DBIc_NUM_PARAMS(VAR_1));\n    VAR_1->params= NULL;\n  }\n\n  /* COMMENT_2 */\n  for (VAR_4= 0; VAR_4 < VAR_11; VAR_4++)\n  {\n    if (VAR_1->av_attr[VAR_4])\n      SvREFCNT_dec(VAR_1->av_attr[VAR_4]);\n    VAR_1->av_attr[VAR_4]= VAR_12;\n  }\n  /* COMMENT_3 */\n  DBIc_IMPSET_off(VAR_1);\n}",
  "func_graph_path_before": "perl5-dbi/DBD-mysql/18e348b57160bfb45da1a5051a3466c8c6635e49/dbdimp.c/vul/before/0.json",
  "func": "void dbd_st_destroy(SV *sth, imp_sth_t *imp_sth) {\n  dTHX;\n  D_imp_xxh(sth);\n\n#if defined (dTHR)\n  dTHR;\n#endif\n\n  int i;\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n  imp_sth_fbh_t *fbh;\n  int n;\n\n  n= DBIc_NUM_PARAMS(imp_sth);\n  if (n)\n  {\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\tFreeing %d parameters, bind %p fbind %p\\n\",\n          n, imp_sth->bind, imp_sth->fbind);\n\n    free_bind(imp_sth->bind);\n    free_fbind(imp_sth->fbind);\n  }\n\n  fbh= imp_sth->fbh;\n  if (fbh)\n  {\n    n = DBIc_NUM_FIELDS(imp_sth);\n    i = 0;\n    while (i < n)\n    {\n      if (fbh[i].data) Safefree(fbh[i].data);\n      ++i;\n    }\n\n    free_fbuffer(fbh);\n    if (imp_sth->buffer)\n      free_bind(imp_sth->buffer);\n  }\n\n  if (imp_sth->stmt)\n  {\n    mysql_stmt_close(imp_sth->stmt);\n    imp_sth->stmt= NULL;\n  }\n#endif\n\n\n  /* dbd_st_finish has already been called by .xs code if needed.\t*/\n\n  /* Free values allocated by dbd_bind_ph */\n  if (imp_sth->params)\n  {\n    free_param(aTHX_ imp_sth->params, DBIc_NUM_PARAMS(imp_sth));\n    imp_sth->params= NULL;\n  }\n\n  /* Free cached array attributes */\n  for (i= 0; i < AV_ATTRIB_LAST; i++)\n  {\n    if (imp_sth->av_attr[i])\n      SvREFCNT_dec(imp_sth->av_attr[i]);\n    imp_sth->av_attr[i]= Nullav;\n  }\n  /* let DBI know we've done it   */\n  DBIc_IMPSET_off(imp_sth);\n}",
  "abstract_func": "void dbd_st_destroy(SV *VAR_0, imp_sth_t *VAR_1) {\n  VAR_2;\n  D_imp_xxh(VAR_0);\n\n#if defined (VAR_3)\n  VAR_3;\n#endif\n\n  int VAR_4;\n\n#if VAR_5 >= VAR_6\n  imp_sth_fbh_t *VAR_7;\n  int VAR_8;\n\n  VAR_8= DBIc_NUM_PARAMS(VAR_1);\n  if (VAR_8)\n  {\n    if (DBIc_TRACE_LEVEL(VAR_9) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(VAR_9), \"\\tFreeing %d parameters, bind %p fbind %p\\n\",\n          VAR_8, VAR_1->bind, VAR_1->fbind);\n\n    free_bind(VAR_1->bind);\n    free_fbind(VAR_1->fbind);\n  }\n\n  VAR_7= VAR_1->fbh;\n  if (VAR_7)\n  {\n    VAR_8 = DBIc_NUM_FIELDS(VAR_1);\n    VAR_4 = 0;\n    while (VAR_4 < VAR_8)\n    {\n      if (VAR_7[VAR_4].data) Safefree(VAR_7[VAR_4].data);\n      ++VAR_4;\n    }\n\n    free_fbuffer(VAR_7);\n    if (VAR_1->buffer)\n      free_bind(VAR_1->buffer);\n  }\n\n  if (VAR_1->stmt)\n  {\n    mysql_stmt_close(VAR_1->stmt);\n    VAR_1->stmt= NULL;\n  }\n#endif\n\n\n  /* COMMENT_0 */\n\n  /* COMMENT_1 */\n  if (VAR_1->params)\n  {\n    VAR_10(aTHX_ VAR_1->params, DBIc_NUM_PARAMS(VAR_1));\n    VAR_1->params= NULL;\n  }\n\n  /* COMMENT_2 */\n  for (VAR_4= 0; VAR_4 < VAR_11; VAR_4++)\n  {\n    if (VAR_1->av_attr[VAR_4])\n      SvREFCNT_dec(VAR_1->av_attr[VAR_4]);\n    VAR_1->av_attr[VAR_4]= VAR_12;\n  }\n  /* COMMENT_3 */\n  DBIc_IMPSET_off(VAR_1);\n}",
  "func_graph_path": "perl5-dbi/DBD-mysql/18e348b57160bfb45da1a5051a3466c8c6635e49/dbdimp.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -41,12 +41,8 @@\n \n   if (imp_sth->stmt)\n   {\n-    if (mysql_stmt_close(imp_sth->stmt))\n-    {\n-      do_error(DBIc_PARENT_H(imp_sth), mysql_stmt_errno(imp_sth->stmt),\n-          mysql_stmt_error(imp_sth->stmt),\n-          mysql_stmt_sqlstate(imp_sth->stmt));\n-    }\n+    mysql_stmt_close(imp_sth->stmt);\n+    imp_sth->stmt= NULL;\n   }\n #endif\n ",
  "diff_line_info": {
    "deleted_lines": [
      "    if (mysql_stmt_close(imp_sth->stmt))",
      "    {",
      "      do_error(DBIc_PARENT_H(imp_sth), mysql_stmt_errno(imp_sth->stmt),",
      "          mysql_stmt_error(imp_sth->stmt),",
      "          mysql_stmt_sqlstate(imp_sth->stmt));",
      "    }"
    ],
    "added_lines": [
      "    mysql_stmt_close(imp_sth->stmt);",
      "    imp_sth->stmt= NULL;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/perl5-dbi/DBD-mysql/pull/142",
  "description": {
    "pr_info": {
      "title": "Fix use-after-free after calling mysql_stmt_close()",
      "number": 142
    },
    "comment": [
      "Ignore return value from mysql_stmt_close() and also its error message\nbecause it points to freed memory after mysql_stmt_close() was called.\n\nCloses: #120"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}