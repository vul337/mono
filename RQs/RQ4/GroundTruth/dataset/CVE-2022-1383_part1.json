{
  "cve_id": "CVE-2022-1383",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "radareorg/radare2",
  "commit_msg": "Fix oobread bug in NE parser ##crash\n\n* Reported by @cnitlrt via huntrdev\r\n* BountyID: 02b4b563-b946-4343-9092-38d1c5cd60c9\r\n* Reproducer: neoobread",
  "commit_hash": "1dd65336f0f0c351d6ea853efcf73cf9c0030862",
  "git_url": "https://github.com/radareorg/radare2/commit/1dd65336f0f0c351d6ea853efcf73cf9c0030862",
  "file_path": "libr/bin/format/mach0/coresymbolication.c",
  "func_name": "r_coresym_cache_element_new",
  "func_before": "RCoreSymCacheElement *r_coresym_cache_element_new(RBinFile *bf, RBuffer *buf, ut64 off, int bits, char * file_name) {\n\tRCoreSymCacheElement *result = NULL;\n\tut8 *b = NULL;\n\tRCoreSymCacheElementHdr *hdr = r_coresym_cache_element_header_new (buf, off, bits);\n\tif (!hdr) {\n\t\treturn NULL;\n\t}\n\tif (hdr->version != 1) {\n\t\teprintf (\"Unsupported CoreSymbolication cache version (%d)\\n\", hdr->version);\n\t\tgoto beach;\n\t}\n\tif (hdr->size == 0 || hdr->size > r_buf_size (buf) - off) {\n\t\teprintf (\"Corrupted CoreSymbolication header: size out of bounds (0x%x)\\n\", hdr->size);\n\t\tgoto beach;\n\t}\n\tresult = R_NEW0 (RCoreSymCacheElement);\n\tif (!result) {\n\t\tgoto beach;\n\t}\n\tresult->hdr = hdr;\n\tb = malloc (hdr->size);\n\tif (!b) {\n\t\tgoto beach;\n\t}\n\tif (r_buf_read_at (buf, off, b, hdr->size) != hdr->size) {\n\t\tgoto beach;\n\t}\n\tut8 *end = b + hdr->size;\n\tif (file_name) {\n\t\tresult->file_name = file_name;\n\t} else if (hdr->file_name_off) {\n\t\tresult->file_name = str_dup_safe (b, b + (size_t)hdr->file_name_off, end);\n\t}\n\tif (hdr->version_off) {\n\t\tresult->binary_version = str_dup_safe (b, b + (size_t)hdr->version_off, end);\n\t}\n\tconst size_t word_size = bits / 8;\n\tconst ut64 start_of_sections = (ut64)hdr->n_segments * R_CS_EL_SIZE_SEG + R_CS_EL_OFF_SEGS;\n\tconst ut64 sect_size = (bits == 32) ? R_CS_EL_SIZE_SECT_32 : R_CS_EL_SIZE_SECT_64;\n\tconst ut64 start_of_symbols = start_of_sections + (ut64)hdr->n_sections * sect_size;\n\tconst ut64 start_of_lined_symbols = start_of_symbols + (ut64)hdr->n_symbols * R_CS_EL_SIZE_SYM;\n\tconst ut64 start_of_line_info = start_of_lined_symbols + (ut64)hdr->n_lined_symbols * R_CS_EL_SIZE_LSYM;\n\tconst ut64 start_of_unknown_pairs = start_of_line_info + (ut64)hdr->n_line_info * R_CS_EL_SIZE_LINFO;\n\tconst ut64 start_of_strings = start_of_unknown_pairs + (ut64)hdr->n_symbols * 8;\n\n\tut64 page_zero_size = 0;\n\tsize_t page_zero_idx = 0;\n\tif (UT32_MUL_OVFCHK (hdr->n_segments, sizeof (RCoreSymCacheElementSegment))) {\n\t\tgoto beach;\n\t} else if (UT32_MUL_OVFCHK (hdr->n_sections, sizeof (RCoreSymCacheElementSection))) {\n\t\tgoto beach;\n\t} else if (UT32_MUL_OVFCHK (hdr->n_symbols, sizeof (RCoreSymCacheElementSymbol))) {\n\t\tgoto beach;\n\t} else if (UT32_MUL_OVFCHK (hdr->n_lined_symbols, sizeof (RCoreSymCacheElementLinedSymbol))) {\n\t\tgoto beach;\n\t} else if (UT32_MUL_OVFCHK (hdr->n_line_info, sizeof (RCoreSymCacheElementLineInfo))) {\n\t\tgoto beach;\n\t}\n\tif (hdr->n_segments > 0) {\n\t\tresult->segments = R_NEWS0 (RCoreSymCacheElementSegment, hdr->n_segments);\n\t\tif (!result->segments) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t i;\n\t\tut8 *cursor = b + R_CS_EL_OFF_SEGS;\n\t\tfor (i = 0; i < hdr->n_segments && cursor + sizeof (RCoreSymCacheElementSegment) < end; i++) {\n\t\t\tRCoreSymCacheElementSegment *seg = &result->segments[i];\n\t\t\tseg->paddr = seg->vaddr = r_read_le64 (cursor);\n\t\t\tcursor += 8;\n\t\t\tif (cursor >= end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tseg->size = seg->vsize = r_read_le64 (cursor);\n\t\t\tcursor += 8;\n\t\t\tif (cursor >= end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tseg->name = str_dup_safe_fixed (b, cursor, 16, end);\n\t\t\tcursor += 16;\n\t\t\tif (!seg->name) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!strcmp (seg->name, \"__PAGEZERO\")) {\n\t\t\t\tpage_zero_size = seg->size;\n\t\t\t\tpage_zero_idx = i;\n\t\t\t\tseg->paddr = seg->vaddr = 0;\n\t\t\t\tseg->size = 0;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < hdr->n_segments && page_zero_size > 0; i++) {\n\t\t\tif (i == page_zero_idx) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRCoreSymCacheElementSegment *seg = &result->segments[i];\n\t\t\tif (seg->vaddr < page_zero_size) {\n\t\t\t\tseg->vaddr += page_zero_size;\n\t\t\t}\n\t\t}\n\t}\n\tbool relative_to_strings = false;\n\tut8* string_origin;\n\tif (hdr->n_sections > 0) {\n\t\tresult->sections = R_NEWS0 (RCoreSymCacheElementSection, hdr->n_sections);\n\t\tif (!result->sections) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t i;\n\t\tut8 *cursor = b + start_of_sections;\n\t\tfor (i = 0; i < hdr->n_sections && cursor < end; i++) {\n\t\t\tut8 *sect_start = cursor;\n\t\t\tRCoreSymCacheElementSection *sect = &result->sections[i];\n\t\t\tsect->vaddr = sect->paddr = r_read_ble (cursor, false, bits);\n\t\t\tif (sect->vaddr < page_zero_size) {\n\t\t\t\tsect->vaddr += page_zero_size;\n\t\t\t}\n\t\t\tcursor += word_size;\n\t\t\tif (cursor >= end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsect->size = r_read_ble (cursor, false, bits);\n\t\t\tcursor += word_size;\n\t\t\tif (cursor >= end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut64 sect_name_off = r_read_ble (cursor, false, bits);\n\t\t\tif (!i && !sect_name_off) {\n\t\t\t\trelative_to_strings = true;\n\t\t\t}\n\t\t\tcursor += word_size;\n\t\t\tif (bits == 32) {\n\t\t\t\tcursor += word_size;\n\t\t\t}\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : sect_start;\n\t\t\tsect->name = str_dup_safe (b, string_origin + (size_t)sect_name_off, end);\n\t\t}\n\t}\n\tif (hdr->n_symbols) {\n\t\tresult->symbols = R_NEWS0 (RCoreSymCacheElementSymbol, hdr->n_symbols);\n\t\tif (!result->symbols) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t i;\n\t\tut8 *cursor = b + start_of_symbols;\n\t\tfor (i = 0; i < hdr->n_symbols && cursor + R_CS_EL_SIZE_SYM <= end; i++) {\n\t\t\tRCoreSymCacheElementSymbol *sym = &result->symbols[i];\n\t\t\tsym->paddr = r_read_le32 (cursor);\n\t\t\tsym->size = r_read_le32 (cursor + 0x4);\n\t\t\tsym->unk1 = r_read_le32 (cursor + 0x8);\n\t\t\tsize_t name_off = r_read_le32 (cursor + 0xc);\n\t\t\tsize_t mangled_name_off = r_read_le32 (cursor + 0x10);\n\t\t\tsym->unk2 = (st32)r_read_le32 (cursor + 0x14);\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tsym->name = str_dup_safe (b, string_origin + name_off, end);\n\t\t\tif (!sym->name) {\n\t\t\t\tcursor += R_CS_EL_SIZE_SYM;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tsym->mangled_name = str_dup_safe (b, string_origin + mangled_name_off, end);\n\t\t\tif (!sym->mangled_name) {\n\t\t\t\tcursor += R_CS_EL_SIZE_SYM;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcursor += R_CS_EL_SIZE_SYM;\n\t\t}\n\t}\n\tif (hdr->n_lined_symbols) {\n\t\tresult->lined_symbols = R_NEWS0 (RCoreSymCacheElementLinedSymbol, hdr->n_lined_symbols);\n\t\tif (!result->lined_symbols) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t i;\n\t\tut8 *cursor = b + start_of_lined_symbols;\n\t\tfor (i = 0; i < hdr->n_lined_symbols && cursor + R_CS_EL_SIZE_LSYM <= end; i++) {\n\t\t\tRCoreSymCacheElementLinedSymbol *lsym = &result->lined_symbols[i];\n\t\t\tlsym->sym.paddr = r_read_le32 (cursor);\n\t\t\tlsym->sym.size = r_read_le32 (cursor + 0x4);\n\t\t\tlsym->sym.unk1 = r_read_le32 (cursor + 0x8);\n\t\t\tsize_t name_off = r_read_le32 (cursor + 0xc);\n\t\t\tsize_t mangled_name_off = r_read_le32 (cursor + 0x10);\n\t\t\tlsym->sym.unk2 = (st32)r_read_le32 (cursor + 0x14);\n\t\t\tsize_t file_name_off = r_read_le32 (cursor + 0x18);\n\t\t\tlsym->flc.line = r_read_le32 (cursor + 0x1c);\n\t\t\tlsym->flc.col = r_read_le32 (cursor + 0x20);\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tlsym->sym.name = str_dup_safe (b, string_origin + name_off, end);\n\t\t\tif (!lsym->sym.name) {\n\t\t\t\tcursor += R_CS_EL_SIZE_LSYM;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tlsym->sym.mangled_name = str_dup_safe (b, string_origin + mangled_name_off, end);\n\t\t\tif (!lsym->sym.mangled_name) {\n\t\t\t\tcursor += R_CS_EL_SIZE_LSYM;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tlsym->flc.file = str_dup_safe (b, string_origin + file_name_off, end);\n\t\t\tif (!lsym->flc.file) {\n\t\t\t\tcursor += R_CS_EL_SIZE_LSYM;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcursor += R_CS_EL_SIZE_LSYM;\n\t\t\tmeta_add_fileline (bf, r_coresym_cache_element_pa2va (result, lsym->sym.paddr), lsym->sym.size, &lsym->flc);\n\t\t}\n\t}\n\tif (hdr->n_line_info) {\n\t\tresult->line_info = R_NEWS0 (RCoreSymCacheElementLineInfo, hdr->n_line_info);\n\t\tif (!result->line_info) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t i;\n\t\tut8 *cursor = b + start_of_line_info;\n\t\tfor (i = 0; i < hdr->n_line_info && cursor + R_CS_EL_SIZE_LINFO <= end; i++) {\n\t\t\tRCoreSymCacheElementLineInfo *info = &result->line_info[i];\n\t\t\tinfo->paddr = r_read_le32 (cursor);\n\t\t\tinfo->size = r_read_le32 (cursor + 4);\n\t\t\tsize_t file_name_off = r_read_le32 (cursor + 8);\n\t\t\tinfo->flc.line = r_read_le32 (cursor + 0xc);\n\t\t\tinfo->flc.col = r_read_le32 (cursor + 0x10);\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tinfo->flc.file = str_dup_safe (b, string_origin + file_name_off, end);\n\t\t\tif (!info->flc.file) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcursor += R_CS_EL_SIZE_LINFO;\n\t\t\tmeta_add_fileline (bf, r_coresym_cache_element_pa2va (result, info->paddr), info->size, &info->flc);\n\t\t}\n\t}\n\n\t/*\n\t * TODO:\n\t * Figure out the meaning of the 2 arrays of hdr->n_symbols\n\t * 32-bit integers located at the end of line info.\n\t * Those are the last info before the strings at the end.\n\t */\n\nbeach:\n\tfree (b);\n\treturn result;\n}",
  "abstract_func_before": "RCoreSymCacheElement *r_coresym_cache_element_new(RBinFile *VAR_0, RBuffer *VAR_1, ut64 VAR_2, int VAR_3, char * VAR_4) {\n\tRCoreSymCacheElement *VAR_5 = NULL;\n\tut8 *VAR_6 = NULL;\n\tRCoreSymCacheElementHdr *VAR_7 = r_coresym_cache_element_header_new (VAR_1, VAR_2, VAR_3);\n\tif (!VAR_7) {\n\t\treturn NULL;\n\t}\n\tif (VAR_7->version != 1) {\n\t\teprintf (\"Unsupported CoreSymbolication cache version (%d)\\n\", VAR_7->version);\n\t\tgoto beach;\n\t}\n\tif (VAR_7->size == 0 || VAR_7->size > r_buf_size (VAR_1) - VAR_2) {\n\t\teprintf (\"Corrupted CoreSymbolication header: size out of bounds (0x%x)\\n\", VAR_7->size);\n\t\tgoto beach;\n\t}\n\tVAR_5 = R_NEW0 (RCoreSymCacheElement);\n\tif (!VAR_5) {\n\t\tgoto beach;\n\t}\n\tVAR_5->hdr = VAR_7;\n\tVAR_6 = malloc (VAR_7->size);\n\tif (!VAR_6) {\n\t\tgoto beach;\n\t}\n\tif (r_buf_read_at (VAR_1, VAR_2, VAR_6, VAR_7->size) != VAR_7->size) {\n\t\tgoto beach;\n\t}\n\tut8 *VAR_8 = VAR_6 + VAR_7->size;\n\tif (VAR_4) {\n\t\tVAR_5->file_name = VAR_4;\n\t} else if (VAR_7->file_name_off) {\n\t\tVAR_5->file_name = str_dup_safe (VAR_6, VAR_6 + (size_t)VAR_7->file_name_off, VAR_8);\n\t}\n\tif (VAR_7->version_off) {\n\t\tVAR_5->binary_version = str_dup_safe (VAR_6, VAR_6 + (size_t)VAR_7->version_off, VAR_8);\n\t}\n\tconst size_t VAR_9 = VAR_3 / 8;\n\tconst ut64 VAR_10 = (ut64)VAR_7->n_segments * VAR_11 + VAR_12;\n\tconst ut64 VAR_13 = (VAR_3 == 32) ? VAR_14 : VAR_15;\n\tconst ut64 VAR_16 = VAR_10 + (ut64)VAR_7->n_sections * VAR_13;\n\tconst ut64 VAR_17 = VAR_16 + (ut64)VAR_7->n_symbols * VAR_18;\n\tconst ut64 VAR_19 = VAR_17 + (ut64)VAR_7->n_lined_symbols * VAR_20;\n\tconst ut64 VAR_21 = VAR_19 + (ut64)VAR_7->n_line_info * VAR_22;\n\tconst ut64 VAR_23 = VAR_21 + (ut64)VAR_7->n_symbols * 8;\n\n\tut64 VAR_24 = 0;\n\tsize_t VAR_25 = 0;\n\tif (UT32_MUL_OVFCHK (VAR_7->n_segments, sizeof (VAR_26))) {\n\t\tgoto beach;\n\t} else if (UT32_MUL_OVFCHK (VAR_7->n_sections, sizeof (VAR_27))) {\n\t\tgoto beach;\n\t} else if (UT32_MUL_OVFCHK (VAR_7->n_symbols, sizeof (VAR_28))) {\n\t\tgoto beach;\n\t} else if (UT32_MUL_OVFCHK (VAR_7->n_lined_symbols, sizeof (VAR_29))) {\n\t\tgoto beach;\n\t} else if (UT32_MUL_OVFCHK (VAR_7->n_line_info, sizeof (VAR_30))) {\n\t\tgoto beach;\n\t}\n\tif (VAR_7->n_segments > 0) {\n\t\tVAR_5->segments = R_NEWS0 (VAR_26, VAR_7->n_segments);\n\t\tif (!VAR_5->segments) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t VAR_31;\n\t\tut8 *VAR_32 = VAR_6 + VAR_12;\n\t\tfor (VAR_31 = 0; VAR_31 < VAR_7->n_segments && VAR_32 + sizeof (VAR_26) < VAR_8; VAR_31++) {\n\t\t\tRCoreSymCacheElementSegment *VAR_33 = &VAR_5->segments[VAR_31];\n\t\t\tVAR_33->paddr = VAR_33->vaddr = r_read_le64 (VAR_32);\n\t\t\tVAR_32 += 8;\n\t\t\tif (VAR_32 >= VAR_8) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tVAR_33->size = VAR_33->vsize = r_read_le64 (VAR_32);\n\t\t\tVAR_32 += 8;\n\t\t\tif (VAR_32 >= VAR_8) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tVAR_33->name = str_dup_safe_fixed (VAR_6, VAR_32, 16, VAR_8);\n\t\t\tVAR_32 += 16;\n\t\t\tif (!VAR_33->name) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!strcmp (VAR_33->name, \"__PAGEZERO\")) {\n\t\t\t\tVAR_24 = VAR_33->size;\n\t\t\t\tVAR_25 = VAR_31;\n\t\t\t\tVAR_33->paddr = VAR_33->vaddr = 0;\n\t\t\t\tVAR_33->size = 0;\n\t\t\t}\n\t\t}\n\t\tfor (VAR_31 = 0; VAR_31 < VAR_7->n_segments && VAR_24 > 0; VAR_31++) {\n\t\t\tif (VAR_31 == VAR_25) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRCoreSymCacheElementSegment *VAR_33 = &VAR_5->segments[VAR_31];\n\t\t\tif (VAR_33->vaddr < VAR_24) {\n\t\t\t\tVAR_33->vaddr += VAR_24;\n\t\t\t}\n\t\t}\n\t}\n\tbool VAR_34 = false;\n\tut8* VAR_35;\n\tif (VAR_7->n_sections > 0) {\n\t\tVAR_5->sections = R_NEWS0 (VAR_27, VAR_7->n_sections);\n\t\tif (!VAR_5->sections) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t VAR_31;\n\t\tut8 *VAR_32 = VAR_6 + VAR_10;\n\t\tfor (VAR_31 = 0; VAR_31 < VAR_7->n_sections && VAR_32 < VAR_8; VAR_31++) {\n\t\t\tut8 *VAR_36 = VAR_32;\n\t\t\tRCoreSymCacheElementSection *VAR_37 = &VAR_5->sections[VAR_31];\n\t\t\tVAR_37->vaddr = VAR_37->paddr = r_read_ble (VAR_32, false, VAR_3);\n\t\t\tif (VAR_37->vaddr < VAR_24) {\n\t\t\t\tVAR_37->vaddr += VAR_24;\n\t\t\t}\n\t\t\tVAR_32 += VAR_9;\n\t\t\tif (VAR_32 >= VAR_8) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tVAR_37->size = r_read_ble (VAR_32, false, VAR_3);\n\t\t\tVAR_32 += VAR_9;\n\t\t\tif (VAR_32 >= VAR_8) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut64 VAR_38 = r_read_ble (VAR_32, false, VAR_3);\n\t\t\tif (!VAR_31 && !VAR_38) {\n\t\t\t\tVAR_34 = true;\n\t\t\t}\n\t\t\tVAR_32 += VAR_9;\n\t\t\tif (VAR_3 == 32) {\n\t\t\t\tVAR_32 += VAR_9;\n\t\t\t}\n\t\t\tVAR_35 = VAR_34? VAR_6 + VAR_23 : VAR_36;\n\t\t\tVAR_37->name = str_dup_safe (VAR_6, VAR_35 + (size_t)VAR_38, VAR_8);\n\t\t}\n\t}\n\tif (VAR_7->n_symbols) {\n\t\tVAR_5->symbols = R_NEWS0 (VAR_28, VAR_7->n_symbols);\n\t\tif (!VAR_5->symbols) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t VAR_31;\n\t\tut8 *VAR_32 = VAR_6 + VAR_16;\n\t\tfor (VAR_31 = 0; VAR_31 < VAR_7->n_symbols && VAR_32 + VAR_18 <= VAR_8; VAR_31++) {\n\t\t\tRCoreSymCacheElementSymbol *VAR_39 = &VAR_5->symbols[VAR_31];\n\t\t\tVAR_39->paddr = r_read_le32 (VAR_32);\n\t\t\tVAR_39->size = r_read_le32 (VAR_32 + 0x4);\n\t\t\tVAR_39->unk1 = r_read_le32 (VAR_32 + 0x8);\n\t\t\tsize_t VAR_40 = r_read_le32 (VAR_32 + 0xc);\n\t\t\tsize_t VAR_41 = r_read_le32 (VAR_32 + 0x10);\n\t\t\tVAR_39->unk2 = (st32)r_read_le32 (VAR_32 + 0x14);\n\t\t\tVAR_35 = VAR_34? VAR_6 + VAR_23 : VAR_32;\n\t\t\tVAR_39->name = str_dup_safe (VAR_6, VAR_35 + VAR_40, VAR_8);\n\t\t\tif (!VAR_39->name) {\n\t\t\t\tVAR_32 += VAR_18;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tVAR_35 = VAR_34? VAR_6 + VAR_23 : VAR_32;\n\t\t\tVAR_39->mangled_name = str_dup_safe (VAR_6, VAR_35 + VAR_41, VAR_8);\n\t\t\tif (!VAR_39->mangled_name) {\n\t\t\t\tVAR_32 += VAR_18;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tVAR_32 += VAR_18;\n\t\t}\n\t}\n\tif (VAR_7->n_lined_symbols) {\n\t\tVAR_5->lined_symbols = R_NEWS0 (VAR_29, VAR_7->n_lined_symbols);\n\t\tif (!VAR_5->lined_symbols) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t VAR_31;\n\t\tut8 *VAR_32 = VAR_6 + VAR_17;\n\t\tfor (VAR_31 = 0; VAR_31 < VAR_7->n_lined_symbols && VAR_32 + VAR_20 <= VAR_8; VAR_31++) {\n\t\t\tRCoreSymCacheElementLinedSymbol *VAR_42 = &VAR_5->lined_symbols[VAR_31];\n\t\t\tVAR_42->sym.paddr = r_read_le32 (VAR_32);\n\t\t\tVAR_42->sym.size = r_read_le32 (VAR_32 + 0x4);\n\t\t\tVAR_42->sym.unk1 = r_read_le32 (VAR_32 + 0x8);\n\t\t\tsize_t VAR_40 = r_read_le32 (VAR_32 + 0xc);\n\t\t\tsize_t VAR_41 = r_read_le32 (VAR_32 + 0x10);\n\t\t\tVAR_42->sym.unk2 = (st32)r_read_le32 (VAR_32 + 0x14);\n\t\t\tsize_t VAR_43 = r_read_le32 (VAR_32 + 0x18);\n\t\t\tVAR_42->flc.line = r_read_le32 (VAR_32 + 0x1c);\n\t\t\tVAR_42->flc.col = r_read_le32 (VAR_32 + 0x20);\n\t\t\tVAR_35 = VAR_34? VAR_6 + VAR_23 : VAR_32;\n\t\t\tVAR_42->sym.name = str_dup_safe (VAR_6, VAR_35 + VAR_40, VAR_8);\n\t\t\tif (!VAR_42->sym.name) {\n\t\t\t\tVAR_32 += VAR_20;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tVAR_35 = VAR_34? VAR_6 + VAR_23 : VAR_32;\n\t\t\tVAR_42->sym.mangled_name = str_dup_safe (VAR_6, VAR_35 + VAR_41, VAR_8);\n\t\t\tif (!VAR_42->sym.mangled_name) {\n\t\t\t\tVAR_32 += VAR_20;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tVAR_35 = VAR_34? VAR_6 + VAR_23 : VAR_32;\n\t\t\tVAR_42->flc.file = str_dup_safe (VAR_6, VAR_35 + VAR_43, VAR_8);\n\t\t\tif (!VAR_42->flc.file) {\n\t\t\t\tVAR_32 += VAR_20;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tVAR_32 += VAR_20;\n\t\t\tmeta_add_fileline (VAR_0, r_coresym_cache_element_pa2va (VAR_5, VAR_42->sym.paddr), VAR_42->sym.size, &VAR_42->flc);\n\t\t}\n\t}\n\tif (VAR_7->n_line_info) {\n\t\tVAR_5->line_info = R_NEWS0 (VAR_30, VAR_7->n_line_info);\n\t\tif (!VAR_5->line_info) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t VAR_31;\n\t\tut8 *VAR_32 = VAR_6 + VAR_19;\n\t\tfor (VAR_31 = 0; VAR_31 < VAR_7->n_line_info && VAR_32 + VAR_22 <= VAR_8; VAR_31++) {\n\t\t\tRCoreSymCacheElementLineInfo *VAR_44 = &VAR_5->line_info[VAR_31];\n\t\t\tVAR_44->paddr = r_read_le32 (VAR_32);\n\t\t\tVAR_44->size = r_read_le32 (VAR_32 + 4);\n\t\t\tsize_t VAR_43 = r_read_le32 (VAR_32 + 8);\n\t\t\tVAR_44->flc.line = r_read_le32 (VAR_32 + 0xc);\n\t\t\tVAR_44->flc.col = r_read_le32 (VAR_32 + 0x10);\n\t\t\tVAR_35 = VAR_34? VAR_6 + VAR_23 : VAR_32;\n\t\t\tVAR_44->flc.file = str_dup_safe (VAR_6, VAR_35 + VAR_43, VAR_8);\n\t\t\tif (!VAR_44->flc.file) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tVAR_32 += VAR_22;\n\t\t\tmeta_add_fileline (VAR_0, r_coresym_cache_element_pa2va (VAR_5, VAR_44->paddr), VAR_44->size, &VAR_44->flc);\n\t\t}\n\t}\n\n\t/* COMMENT_0 */\n         \n                                                            \n                                                    \n                                                          \n    \n\nbeach:\n\tfree (VAR_6);\n\treturn VAR_5;\n}",
  "func_graph_path_before": "radareorg/radare2/1dd65336f0f0c351d6ea853efcf73cf9c0030862/coresymbolication.c/vul/before/0.json",
  "func": "RCoreSymCacheElement *r_coresym_cache_element_new(RBinFile *bf, RBuffer *buf, ut64 off, int bits, char * file_name) {\n\tRCoreSymCacheElement *result = NULL;\n\tut8 *b = NULL;\n\tRCoreSymCacheElementHdr *hdr = r_coresym_cache_element_header_new (buf, off, bits);\n\tif (!hdr) {\n\t\treturn NULL;\n\t}\n\tif (hdr->version != 1) {\n\t\teprintf (\"Unsupported CoreSymbolication cache version (%d)\\n\", hdr->version);\n\t\tgoto beach;\n\t}\n\tif (hdr->size == 0 || hdr->size > r_buf_size (buf) - off) {\n\t\teprintf (\"Corrupted CoreSymbolication header: size out of bounds (0x%x)\\n\", hdr->size);\n\t\tgoto beach;\n\t}\n\tresult = R_NEW0 (RCoreSymCacheElement);\n\tif (!result) {\n\t\tgoto beach;\n\t}\n\tresult->hdr = hdr;\n\tb = malloc (hdr->size);\n\tif (!b) {\n\t\tgoto beach;\n\t}\n\tif (r_buf_read_at (buf, off, b, hdr->size) != hdr->size) {\n\t\tgoto beach;\n\t}\n\tut8 *end = b + hdr->size;\n\tif (file_name) {\n\t\tresult->file_name = file_name;\n\t} else if (hdr->file_name_off) {\n\t\tresult->file_name = str_dup_safe (b, b + (size_t)hdr->file_name_off, end);\n\t}\n\tif (hdr->version_off) {\n\t\tresult->binary_version = str_dup_safe (b, b + (size_t)hdr->version_off, end);\n\t}\n\tconst size_t word_size = bits / 8;\n\tconst ut64 start_of_sections = (ut64)hdr->n_segments * R_CS_EL_SIZE_SEG + R_CS_EL_OFF_SEGS;\n\tconst ut64 sect_size = (bits == 32) ? R_CS_EL_SIZE_SECT_32 : R_CS_EL_SIZE_SECT_64;\n\tconst ut64 start_of_symbols = start_of_sections + (ut64)hdr->n_sections * sect_size;\n\tconst ut64 start_of_lined_symbols = start_of_symbols + (ut64)hdr->n_symbols * R_CS_EL_SIZE_SYM;\n\tconst ut64 start_of_line_info = start_of_lined_symbols + (ut64)hdr->n_lined_symbols * R_CS_EL_SIZE_LSYM;\n\tconst ut64 start_of_unknown_pairs = start_of_line_info + (ut64)hdr->n_line_info * R_CS_EL_SIZE_LINFO;\n\tconst ut64 start_of_strings = start_of_unknown_pairs + (ut64)hdr->n_symbols * 8;\n\n\tut64 page_zero_size = 0;\n\tsize_t page_zero_idx = 0;\n\tif (UT32_MUL_OVFCHK (hdr->n_segments, sizeof (RCoreSymCacheElementSegment))) {\n\t\tgoto beach;\n\t} else if (UT32_MUL_OVFCHK (hdr->n_sections, sizeof (RCoreSymCacheElementSection))) {\n\t\tgoto beach;\n\t} else if (UT32_MUL_OVFCHK (hdr->n_symbols, sizeof (RCoreSymCacheElementSymbol))) {\n\t\tgoto beach;\n\t} else if (UT32_MUL_OVFCHK (hdr->n_lined_symbols, sizeof (RCoreSymCacheElementLinedSymbol))) {\n\t\tgoto beach;\n\t} else if (UT32_MUL_OVFCHK (hdr->n_line_info, sizeof (RCoreSymCacheElementLineInfo))) {\n\t\tgoto beach;\n\t}\n\tif (hdr->n_segments > 0) {\n\t\tresult->segments = R_NEWS0 (RCoreSymCacheElementSegment, hdr->n_segments);\n\t\tif (!result->segments) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t i;\n\t\tut8 *cursor = b + R_CS_EL_OFF_SEGS;\n\t\tfor (i = 0; i < hdr->n_segments && cursor + sizeof (RCoreSymCacheElementSegment) < end; i++) {\n\t\t\tRCoreSymCacheElementSegment *seg = &result->segments[i];\n\t\t\tseg->paddr = seg->vaddr = r_read_le64 (cursor);\n\t\t\tcursor += 8;\n\t\t\tif (cursor >= end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tseg->size = seg->vsize = r_read_le64 (cursor);\n\t\t\tcursor += 8;\n\t\t\tif (cursor >= end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tseg->name = str_dup_safe_fixed (b, cursor, 16, end);\n\t\t\tcursor += 16;\n\t\t\tif (!seg->name) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!strcmp (seg->name, \"__PAGEZERO\")) {\n\t\t\t\tpage_zero_size = seg->size;\n\t\t\t\tpage_zero_idx = i;\n\t\t\t\tseg->paddr = seg->vaddr = 0;\n\t\t\t\tseg->size = 0;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < hdr->n_segments && page_zero_size > 0; i++) {\n\t\t\tif (i == page_zero_idx) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRCoreSymCacheElementSegment *seg = &result->segments[i];\n\t\t\tif (seg->vaddr < page_zero_size) {\n\t\t\t\tseg->vaddr += page_zero_size;\n\t\t\t}\n\t\t}\n\t}\n\tbool relative_to_strings = false;\n\tut8* string_origin;\n\tif (hdr->n_sections > 0) {\n\t\tresult->sections = R_NEWS0 (RCoreSymCacheElementSection, hdr->n_sections);\n\t\tif (!result->sections) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t i;\n\t\tut8 *cursor = b + start_of_sections;\n\t\tfor (i = 0; i < hdr->n_sections && cursor < end; i++) {\n\t\t\tut8 *sect_start = cursor;\n\t\t\tRCoreSymCacheElementSection *sect = &result->sections[i];\n\t\t\tsect->vaddr = sect->paddr = r_read_ble (cursor, false, bits);\n\t\t\tif (sect->vaddr < page_zero_size) {\n\t\t\t\tsect->vaddr += page_zero_size;\n\t\t\t}\n\t\t\tcursor += word_size;\n\t\t\tif (cursor + word_size >= end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsect->size = r_read_ble (cursor, false, bits);\n\t\t\tcursor += word_size;\n\t\t\tif (cursor + word_size >= end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut64 sect_name_off = r_read_ble (cursor, false, bits);\n\t\t\tif (!i && !sect_name_off) {\n\t\t\t\trelative_to_strings = true;\n\t\t\t}\n\t\t\tcursor += word_size;\n\t\t\tif (bits == 32) {\n\t\t\t\tcursor += word_size;\n\t\t\t}\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : sect_start;\n\t\t\tif (sect_name_off < (ut64)(size_t)(end - string_origin)) {\n\t\t\t\tsect->name = str_dup_safe (b, string_origin + sect_name_off, end);\n\t\t\t} else {\n\t\t\t\tsect->name = strdup (\"\");\n\t\t\t}\n\t\t}\n\t}\n\tif (hdr->n_symbols) {\n\t\tresult->symbols = R_NEWS0 (RCoreSymCacheElementSymbol, hdr->n_symbols);\n\t\tif (!result->symbols) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t i;\n\t\tut8 *cursor = b + start_of_symbols;\n\t\tfor (i = 0; i < hdr->n_symbols && cursor + R_CS_EL_SIZE_SYM <= end; i++) {\n\t\t\tRCoreSymCacheElementSymbol *sym = &result->symbols[i];\n\t\t\tsym->paddr = r_read_le32 (cursor);\n\t\t\tsym->size = r_read_le32 (cursor + 0x4);\n\t\t\tsym->unk1 = r_read_le32 (cursor + 0x8);\n\t\t\tsize_t name_off = r_read_le32 (cursor + 0xc);\n\t\t\tsize_t mangled_name_off = r_read_le32 (cursor + 0x10);\n\t\t\tsym->unk2 = (st32)r_read_le32 (cursor + 0x14);\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tsym->name = str_dup_safe (b, string_origin + name_off, end);\n\t\t\tif (!sym->name) {\n\t\t\t\tcursor += R_CS_EL_SIZE_SYM;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tsym->mangled_name = str_dup_safe (b, string_origin + mangled_name_off, end);\n\t\t\tif (!sym->mangled_name) {\n\t\t\t\tcursor += R_CS_EL_SIZE_SYM;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcursor += R_CS_EL_SIZE_SYM;\n\t\t}\n\t}\n\tif (hdr->n_lined_symbols) {\n\t\tresult->lined_symbols = R_NEWS0 (RCoreSymCacheElementLinedSymbol, hdr->n_lined_symbols);\n\t\tif (!result->lined_symbols) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t i;\n\t\tut8 *cursor = b + start_of_lined_symbols;\n\t\tfor (i = 0; i < hdr->n_lined_symbols && cursor + R_CS_EL_SIZE_LSYM <= end; i++) {\n\t\t\tRCoreSymCacheElementLinedSymbol *lsym = &result->lined_symbols[i];\n\t\t\tlsym->sym.paddr = r_read_le32 (cursor);\n\t\t\tlsym->sym.size = r_read_le32 (cursor + 0x4);\n\t\t\tlsym->sym.unk1 = r_read_le32 (cursor + 0x8);\n\t\t\tsize_t name_off = r_read_le32 (cursor + 0xc);\n\t\t\tsize_t mangled_name_off = r_read_le32 (cursor + 0x10);\n\t\t\tlsym->sym.unk2 = (st32)r_read_le32 (cursor + 0x14);\n\t\t\tsize_t file_name_off = r_read_le32 (cursor + 0x18);\n\t\t\tlsym->flc.line = r_read_le32 (cursor + 0x1c);\n\t\t\tlsym->flc.col = r_read_le32 (cursor + 0x20);\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tlsym->sym.name = str_dup_safe (b, string_origin + name_off, end);\n\t\t\tif (!lsym->sym.name) {\n\t\t\t\tcursor += R_CS_EL_SIZE_LSYM;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tlsym->sym.mangled_name = str_dup_safe (b, string_origin + mangled_name_off, end);\n\t\t\tif (!lsym->sym.mangled_name) {\n\t\t\t\tcursor += R_CS_EL_SIZE_LSYM;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tlsym->flc.file = str_dup_safe (b, string_origin + file_name_off, end);\n\t\t\tif (!lsym->flc.file) {\n\t\t\t\tcursor += R_CS_EL_SIZE_LSYM;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcursor += R_CS_EL_SIZE_LSYM;\n\t\t\tmeta_add_fileline (bf, r_coresym_cache_element_pa2va (result, lsym->sym.paddr), lsym->sym.size, &lsym->flc);\n\t\t}\n\t}\n\tif (hdr->n_line_info) {\n\t\tresult->line_info = R_NEWS0 (RCoreSymCacheElementLineInfo, hdr->n_line_info);\n\t\tif (!result->line_info) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t i;\n\t\tut8 *cursor = b + start_of_line_info;\n\t\tfor (i = 0; i < hdr->n_line_info && cursor + R_CS_EL_SIZE_LINFO <= end; i++) {\n\t\t\tRCoreSymCacheElementLineInfo *info = &result->line_info[i];\n\t\t\tinfo->paddr = r_read_le32 (cursor);\n\t\t\tinfo->size = r_read_le32 (cursor + 4);\n\t\t\tsize_t file_name_off = r_read_le32 (cursor + 8);\n\t\t\tinfo->flc.line = r_read_le32 (cursor + 0xc);\n\t\t\tinfo->flc.col = r_read_le32 (cursor + 0x10);\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tinfo->flc.file = str_dup_safe (b, string_origin + file_name_off, end);\n\t\t\tif (!info->flc.file) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcursor += R_CS_EL_SIZE_LINFO;\n\t\t\tmeta_add_fileline (bf, r_coresym_cache_element_pa2va (result, info->paddr), info->size, &info->flc);\n\t\t}\n\t}\n\n\t/*\n\t * TODO:\n\t * Figure out the meaning of the 2 arrays of hdr->n_symbols\n\t * 32-bit integers located at the end of line info.\n\t * Those are the last info before the strings at the end.\n\t */\n\nbeach:\n\tfree (b);\n\treturn result;\n}",
  "abstract_func": "RCoreSymCacheElement *r_coresym_cache_element_new(RBinFile *VAR_0, RBuffer *VAR_1, ut64 VAR_2, int VAR_3, char * VAR_4) {\n\tRCoreSymCacheElement *VAR_5 = NULL;\n\tut8 *VAR_6 = NULL;\n\tRCoreSymCacheElementHdr *VAR_7 = r_coresym_cache_element_header_new (VAR_1, VAR_2, VAR_3);\n\tif (!VAR_7) {\n\t\treturn NULL;\n\t}\n\tif (VAR_7->version != 1) {\n\t\teprintf (\"Unsupported CoreSymbolication cache version (%d)\\n\", VAR_7->version);\n\t\tgoto beach;\n\t}\n\tif (VAR_7->size == 0 || VAR_7->size > r_buf_size (VAR_1) - VAR_2) {\n\t\teprintf (\"Corrupted CoreSymbolication header: size out of bounds (0x%x)\\n\", VAR_7->size);\n\t\tgoto beach;\n\t}\n\tVAR_5 = R_NEW0 (RCoreSymCacheElement);\n\tif (!VAR_5) {\n\t\tgoto beach;\n\t}\n\tVAR_5->hdr = VAR_7;\n\tVAR_6 = malloc (VAR_7->size);\n\tif (!VAR_6) {\n\t\tgoto beach;\n\t}\n\tif (r_buf_read_at (VAR_1, VAR_2, VAR_6, VAR_7->size) != VAR_7->size) {\n\t\tgoto beach;\n\t}\n\tut8 *VAR_8 = VAR_6 + VAR_7->size;\n\tif (VAR_4) {\n\t\tVAR_5->file_name = VAR_4;\n\t} else if (VAR_7->file_name_off) {\n\t\tVAR_5->file_name = str_dup_safe (VAR_6, VAR_6 + (size_t)VAR_7->file_name_off, VAR_8);\n\t}\n\tif (VAR_7->version_off) {\n\t\tVAR_5->binary_version = str_dup_safe (VAR_6, VAR_6 + (size_t)VAR_7->version_off, VAR_8);\n\t}\n\tconst size_t VAR_9 = VAR_3 / 8;\n\tconst ut64 VAR_10 = (ut64)VAR_7->n_segments * VAR_11 + VAR_12;\n\tconst ut64 VAR_13 = (VAR_3 == 32) ? VAR_14 : VAR_15;\n\tconst ut64 VAR_16 = VAR_10 + (ut64)VAR_7->n_sections * VAR_13;\n\tconst ut64 VAR_17 = VAR_16 + (ut64)VAR_7->n_symbols * VAR_18;\n\tconst ut64 VAR_19 = VAR_17 + (ut64)VAR_7->n_lined_symbols * VAR_20;\n\tconst ut64 VAR_21 = VAR_19 + (ut64)VAR_7->n_line_info * VAR_22;\n\tconst ut64 VAR_23 = VAR_21 + (ut64)VAR_7->n_symbols * 8;\n\n\tut64 VAR_24 = 0;\n\tsize_t VAR_25 = 0;\n\tif (UT32_MUL_OVFCHK (VAR_7->n_segments, sizeof (VAR_26))) {\n\t\tgoto beach;\n\t} else if (UT32_MUL_OVFCHK (VAR_7->n_sections, sizeof (VAR_27))) {\n\t\tgoto beach;\n\t} else if (UT32_MUL_OVFCHK (VAR_7->n_symbols, sizeof (VAR_28))) {\n\t\tgoto beach;\n\t} else if (UT32_MUL_OVFCHK (VAR_7->n_lined_symbols, sizeof (VAR_29))) {\n\t\tgoto beach;\n\t} else if (UT32_MUL_OVFCHK (VAR_7->n_line_info, sizeof (VAR_30))) {\n\t\tgoto beach;\n\t}\n\tif (VAR_7->n_segments > 0) {\n\t\tVAR_5->segments = R_NEWS0 (VAR_26, VAR_7->n_segments);\n\t\tif (!VAR_5->segments) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t VAR_31;\n\t\tut8 *VAR_32 = VAR_6 + VAR_12;\n\t\tfor (VAR_31 = 0; VAR_31 < VAR_7->n_segments && VAR_32 + sizeof (VAR_26) < VAR_8; VAR_31++) {\n\t\t\tRCoreSymCacheElementSegment *VAR_33 = &VAR_5->segments[VAR_31];\n\t\t\tVAR_33->paddr = VAR_33->vaddr = r_read_le64 (VAR_32);\n\t\t\tVAR_32 += 8;\n\t\t\tif (VAR_32 >= VAR_8) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tVAR_33->size = VAR_33->vsize = r_read_le64 (VAR_32);\n\t\t\tVAR_32 += 8;\n\t\t\tif (VAR_32 >= VAR_8) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tVAR_33->name = str_dup_safe_fixed (VAR_6, VAR_32, 16, VAR_8);\n\t\t\tVAR_32 += 16;\n\t\t\tif (!VAR_33->name) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!strcmp (VAR_33->name, \"__PAGEZERO\")) {\n\t\t\t\tVAR_24 = VAR_33->size;\n\t\t\t\tVAR_25 = VAR_31;\n\t\t\t\tVAR_33->paddr = VAR_33->vaddr = 0;\n\t\t\t\tVAR_33->size = 0;\n\t\t\t}\n\t\t}\n\t\tfor (VAR_31 = 0; VAR_31 < VAR_7->n_segments && VAR_24 > 0; VAR_31++) {\n\t\t\tif (VAR_31 == VAR_25) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRCoreSymCacheElementSegment *VAR_33 = &VAR_5->segments[VAR_31];\n\t\t\tif (VAR_33->vaddr < VAR_24) {\n\t\t\t\tVAR_33->vaddr += VAR_24;\n\t\t\t}\n\t\t}\n\t}\n\tbool VAR_34 = false;\n\tut8* VAR_35;\n\tif (VAR_7->n_sections > 0) {\n\t\tVAR_5->sections = R_NEWS0 (VAR_27, VAR_7->n_sections);\n\t\tif (!VAR_5->sections) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t VAR_31;\n\t\tut8 *VAR_32 = VAR_6 + VAR_10;\n\t\tfor (VAR_31 = 0; VAR_31 < VAR_7->n_sections && VAR_32 < VAR_8; VAR_31++) {\n\t\t\tut8 *VAR_36 = VAR_32;\n\t\t\tRCoreSymCacheElementSection *VAR_37 = &VAR_5->sections[VAR_31];\n\t\t\tVAR_37->vaddr = VAR_37->paddr = r_read_ble (VAR_32, false, VAR_3);\n\t\t\tif (VAR_37->vaddr < VAR_24) {\n\t\t\t\tVAR_37->vaddr += VAR_24;\n\t\t\t}\n\t\t\tVAR_32 += VAR_9;\n\t\t\tif (VAR_32 + VAR_9 >= VAR_8) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tVAR_37->size = r_read_ble (VAR_32, false, VAR_3);\n\t\t\tVAR_32 += VAR_9;\n\t\t\tif (VAR_32 + VAR_9 >= VAR_8) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut64 VAR_38 = r_read_ble (VAR_32, false, VAR_3);\n\t\t\tif (!VAR_31 && !VAR_38) {\n\t\t\t\tVAR_34 = true;\n\t\t\t}\n\t\t\tVAR_32 += VAR_9;\n\t\t\tif (VAR_3 == 32) {\n\t\t\t\tVAR_32 += VAR_9;\n\t\t\t}\n\t\t\tVAR_35 = VAR_34? VAR_6 + VAR_23 : VAR_36;\n\t\t\tif (VAR_38 < (ut64)(size_t)(VAR_8 - VAR_35)) {\n\t\t\t\tVAR_37->name = str_dup_safe (VAR_6, VAR_35 + VAR_38, VAR_8);\n\t\t\t} else {\n\t\t\t\tVAR_37->name = strdup (\"\");\n\t\t\t}\n\t\t}\n\t}\n\tif (VAR_7->n_symbols) {\n\t\tVAR_5->symbols = R_NEWS0 (VAR_28, VAR_7->n_symbols);\n\t\tif (!VAR_5->symbols) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t VAR_31;\n\t\tut8 *VAR_32 = VAR_6 + VAR_16;\n\t\tfor (VAR_31 = 0; VAR_31 < VAR_7->n_symbols && VAR_32 + VAR_18 <= VAR_8; VAR_31++) {\n\t\t\tRCoreSymCacheElementSymbol *VAR_39 = &VAR_5->symbols[VAR_31];\n\t\t\tVAR_39->paddr = r_read_le32 (VAR_32);\n\t\t\tVAR_39->size = r_read_le32 (VAR_32 + 0x4);\n\t\t\tVAR_39->unk1 = r_read_le32 (VAR_32 + 0x8);\n\t\t\tsize_t VAR_40 = r_read_le32 (VAR_32 + 0xc);\n\t\t\tsize_t VAR_41 = r_read_le32 (VAR_32 + 0x10);\n\t\t\tVAR_39->unk2 = (st32)r_read_le32 (VAR_32 + 0x14);\n\t\t\tVAR_35 = VAR_34? VAR_6 + VAR_23 : VAR_32;\n\t\t\tVAR_39->name = str_dup_safe (VAR_6, VAR_35 + VAR_40, VAR_8);\n\t\t\tif (!VAR_39->name) {\n\t\t\t\tVAR_32 += VAR_18;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tVAR_35 = VAR_34? VAR_6 + VAR_23 : VAR_32;\n\t\t\tVAR_39->mangled_name = str_dup_safe (VAR_6, VAR_35 + VAR_41, VAR_8);\n\t\t\tif (!VAR_39->mangled_name) {\n\t\t\t\tVAR_32 += VAR_18;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tVAR_32 += VAR_18;\n\t\t}\n\t}\n\tif (VAR_7->n_lined_symbols) {\n\t\tVAR_5->lined_symbols = R_NEWS0 (VAR_29, VAR_7->n_lined_symbols);\n\t\tif (!VAR_5->lined_symbols) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t VAR_31;\n\t\tut8 *VAR_32 = VAR_6 + VAR_17;\n\t\tfor (VAR_31 = 0; VAR_31 < VAR_7->n_lined_symbols && VAR_32 + VAR_20 <= VAR_8; VAR_31++) {\n\t\t\tRCoreSymCacheElementLinedSymbol *VAR_42 = &VAR_5->lined_symbols[VAR_31];\n\t\t\tVAR_42->sym.paddr = r_read_le32 (VAR_32);\n\t\t\tVAR_42->sym.size = r_read_le32 (VAR_32 + 0x4);\n\t\t\tVAR_42->sym.unk1 = r_read_le32 (VAR_32 + 0x8);\n\t\t\tsize_t VAR_40 = r_read_le32 (VAR_32 + 0xc);\n\t\t\tsize_t VAR_41 = r_read_le32 (VAR_32 + 0x10);\n\t\t\tVAR_42->sym.unk2 = (st32)r_read_le32 (VAR_32 + 0x14);\n\t\t\tsize_t VAR_43 = r_read_le32 (VAR_32 + 0x18);\n\t\t\tVAR_42->flc.line = r_read_le32 (VAR_32 + 0x1c);\n\t\t\tVAR_42->flc.col = r_read_le32 (VAR_32 + 0x20);\n\t\t\tVAR_35 = VAR_34? VAR_6 + VAR_23 : VAR_32;\n\t\t\tVAR_42->sym.name = str_dup_safe (VAR_6, VAR_35 + VAR_40, VAR_8);\n\t\t\tif (!VAR_42->sym.name) {\n\t\t\t\tVAR_32 += VAR_20;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tVAR_35 = VAR_34? VAR_6 + VAR_23 : VAR_32;\n\t\t\tVAR_42->sym.mangled_name = str_dup_safe (VAR_6, VAR_35 + VAR_41, VAR_8);\n\t\t\tif (!VAR_42->sym.mangled_name) {\n\t\t\t\tVAR_32 += VAR_20;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tVAR_35 = VAR_34? VAR_6 + VAR_23 : VAR_32;\n\t\t\tVAR_42->flc.file = str_dup_safe (VAR_6, VAR_35 + VAR_43, VAR_8);\n\t\t\tif (!VAR_42->flc.file) {\n\t\t\t\tVAR_32 += VAR_20;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tVAR_32 += VAR_20;\n\t\t\tmeta_add_fileline (VAR_0, r_coresym_cache_element_pa2va (VAR_5, VAR_42->sym.paddr), VAR_42->sym.size, &VAR_42->flc);\n\t\t}\n\t}\n\tif (VAR_7->n_line_info) {\n\t\tVAR_5->line_info = R_NEWS0 (VAR_30, VAR_7->n_line_info);\n\t\tif (!VAR_5->line_info) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t VAR_31;\n\t\tut8 *VAR_32 = VAR_6 + VAR_19;\n\t\tfor (VAR_31 = 0; VAR_31 < VAR_7->n_line_info && VAR_32 + VAR_22 <= VAR_8; VAR_31++) {\n\t\t\tRCoreSymCacheElementLineInfo *VAR_44 = &VAR_5->line_info[VAR_31];\n\t\t\tVAR_44->paddr = r_read_le32 (VAR_32);\n\t\t\tVAR_44->size = r_read_le32 (VAR_32 + 4);\n\t\t\tsize_t VAR_43 = r_read_le32 (VAR_32 + 8);\n\t\t\tVAR_44->flc.line = r_read_le32 (VAR_32 + 0xc);\n\t\t\tVAR_44->flc.col = r_read_le32 (VAR_32 + 0x10);\n\t\t\tVAR_35 = VAR_34? VAR_6 + VAR_23 : VAR_32;\n\t\t\tVAR_44->flc.file = str_dup_safe (VAR_6, VAR_35 + VAR_43, VAR_8);\n\t\t\tif (!VAR_44->flc.file) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tVAR_32 += VAR_22;\n\t\t\tmeta_add_fileline (VAR_0, r_coresym_cache_element_pa2va (VAR_5, VAR_44->paddr), VAR_44->size, &VAR_44->flc);\n\t\t}\n\t}\n\n\t/* COMMENT_0 */\n         \n                                                            \n                                                    \n                                                          \n    \n\nbeach:\n\tfree (VAR_6);\n\treturn VAR_5;\n}",
  "func_graph_path": "radareorg/radare2/1dd65336f0f0c351d6ea853efcf73cf9c0030862/coresymbolication.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -115,12 +115,12 @@\n \t\t\t\tsect->vaddr += page_zero_size;\n \t\t\t}\n \t\t\tcursor += word_size;\n-\t\t\tif (cursor >= end) {\n+\t\t\tif (cursor + word_size >= end) {\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\tsect->size = r_read_ble (cursor, false, bits);\n \t\t\tcursor += word_size;\n-\t\t\tif (cursor >= end) {\n+\t\t\tif (cursor + word_size >= end) {\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\tut64 sect_name_off = r_read_ble (cursor, false, bits);\n@@ -132,7 +132,11 @@\n \t\t\t\tcursor += word_size;\n \t\t\t}\n \t\t\tstring_origin = relative_to_strings? b + start_of_strings : sect_start;\n-\t\t\tsect->name = str_dup_safe (b, string_origin + (size_t)sect_name_off, end);\n+\t\t\tif (sect_name_off < (ut64)(size_t)(end - string_origin)) {\n+\t\t\t\tsect->name = str_dup_safe (b, string_origin + sect_name_off, end);\n+\t\t\t} else {\n+\t\t\t\tsect->name = strdup (\"\");\n+\t\t\t}\n \t\t}\n \t}\n \tif (hdr->n_symbols) {",
  "diff_line_info": {
    "deleted_lines": [
      "\t\t\tif (cursor >= end) {",
      "\t\t\tif (cursor >= end) {",
      "\t\t\tsect->name = str_dup_safe (b, string_origin + (size_t)sect_name_off, end);"
    ],
    "added_lines": [
      "\t\t\tif (cursor + word_size >= end) {",
      "\t\t\tif (cursor + word_size >= end) {",
      "\t\t\tif (sect_name_off < (ut64)(size_t)(end - string_origin)) {",
      "\t\t\t\tsect->name = str_dup_safe (b, string_origin + sect_name_off, end);",
      "\t\t\t} else {",
      "\t\t\t\tsect->name = strdup (\"\");",
      "\t\t\t}"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/radareorg/radare2/pull/19962",
  "description": {
    "pr_info": {
      "title": "Fix oobread bug in NE parser ##crash",
      "number": 19962
    },
    "comment": [
      "* Reported by @cnitlrt via huntrdev\r\n* BountyID: 02b4b563-b946-4343-9092-38d1c5cd60c9\r\n* Reproducer: neoobread\r\n\r\n<!--\r\nRead https://github.com/radareorg/radare2/blob/master/DEVELOPERS.md\r\n* PR title must be capitalized, concise and use ##tags\r\n* If the PR is fixing a ticket use 'Fix #1234 - ..' in the commit message\r\n* Follow the coding style, add tests and documentation if necessary\r\n-->\r\n\r\n- [ ] Mark this if you consider it ready to merge\r\n- [ ] I've added tests (optional)\r\n- [ ] I wrote some lines in the [book](https://github.com/radareorg/radare2book) (optional)\r\n\r\n**Description**\r\n\r\n<!-- explain your changes if necessary -->\r\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95"
}