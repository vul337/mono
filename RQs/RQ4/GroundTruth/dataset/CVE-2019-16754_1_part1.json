{
  "cve_id": "CVE-2019-16754",
  "cwe_ids": [
    "CWE-476"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "RIOT-OS/RIOT",
  "commit_msg": "asymcute: don't make the assumption that req->arg is non-NULL\n\nThis fixes a denial of service where an attacker would be able to cause\na NULL pointer dereference by sending a spoofed packet. This attack only\nrequires knowledge about pending message ids.",
  "commit_hash": "30e4823e946949befe74ef94bc48fe43958c28a6",
  "git_url": "https://github.com/RIOT-OS/RIOT/commit/30e4823e946949befe74ef94bc48fe43958c28a6",
  "file_path": "sys/net/application_layer/asymcute/asymcute.c",
  "func_name": "_on_suback",
  "func_before": "static void _on_suback(asymcute_con_t *con, const uint8_t *data, size_t len)\n{\n    mutex_lock(&con->lock);\n    asymcute_req_t *req = _req_preprocess(con, len, MINLEN_SUBACK,\n                                          data, IDPOS_SUBACK);\n    if (req == NULL) {\n        mutex_unlock(&con->lock);\n        return;\n    }\n\n    unsigned ret = ASYMCUTE_REJECTED;\n    if (data[7] == MQTTSN_ACCEPTED) {\n        /* parse and apply assigned topic id */\n        asymcute_sub_t *sub = (asymcute_sub_t *)req->arg;\n        sub->topic->id = byteorder_bebuftohs(&data[3]);\n        sub->topic->con = con;\n        /* insert subscription to connection context */\n        sub->next = con->subscriptions;\n        con->subscriptions = sub;\n        ret = ASYMCUTE_SUBSCRIBED;\n    }\n\n    /* notify the user */\n    mutex_unlock(&req->lock);\n    mutex_unlock(&con->lock);\n    con->user_cb(req, ret);\n}",
  "abstract_func_before": "static void _on_suback(asymcute_con_t *VAR_0, const uint8_t *VAR_1, size_t VAR_2)\n{\n    mutex_lock(&VAR_0->lock);\n    asymcute_req_t *VAR_3 = _req_preprocess(VAR_0, VAR_2, VAR_4,\n                                          VAR_1, VAR_5);\n    if (VAR_3 == NULL) {\n        mutex_unlock(&VAR_0->lock);\n        return;\n    }\n\n    unsigned VAR_6 = VAR_7;\n    if (VAR_1[7] == VAR_8) {\n        /* COMMENT_0 */\n        asymcute_sub_t *VAR_9 = (asymcute_sub_t *)VAR_3->arg;\n        VAR_9->topic->id = byteorder_bebuftohs(&VAR_1[3]);\n        VAR_9->topic->con = VAR_0;\n        /* COMMENT_1 */\n        VAR_9->next = VAR_0->subscriptions;\n        VAR_0->subscriptions = VAR_9;\n        VAR_6 = VAR_10;\n    }\n\n    /* COMMENT_2 */\n    mutex_unlock(&VAR_3->lock);\n    mutex_unlock(&VAR_0->lock);\n    VAR_0->user_cb(VAR_3, VAR_6);\n}",
  "func_graph_path_before": "RIOT-OS/RIOT/30e4823e946949befe74ef94bc48fe43958c28a6/asymcute.c/vul/before/2.json",
  "func": "static void _on_suback(asymcute_con_t *con, const uint8_t *data, size_t len)\n{\n    mutex_lock(&con->lock);\n    asymcute_req_t *req = _req_preprocess(con, len, MINLEN_SUBACK,\n                                          data, IDPOS_SUBACK);\n    if (req == NULL) {\n        mutex_unlock(&con->lock);\n        return;\n    }\n\n    unsigned ret = ASYMCUTE_REJECTED;\n    if (data[7] == MQTTSN_ACCEPTED) {\n        /* parse and apply assigned topic id */\n        asymcute_sub_t *sub = (asymcute_sub_t *)req->arg;\n        if (sub == NULL) {\n            return;\n        }\n\n        sub->topic->id = byteorder_bebuftohs(&data[3]);\n        sub->topic->con = con;\n        /* insert subscription to connection context */\n        sub->next = con->subscriptions;\n        con->subscriptions = sub;\n        ret = ASYMCUTE_SUBSCRIBED;\n    }\n\n    /* notify the user */\n    mutex_unlock(&req->lock);\n    mutex_unlock(&con->lock);\n    con->user_cb(req, ret);\n}",
  "abstract_func": "static void _on_suback(asymcute_con_t *VAR_0, const uint8_t *VAR_1, size_t VAR_2)\n{\n    mutex_lock(&VAR_0->lock);\n    asymcute_req_t *VAR_3 = _req_preprocess(VAR_0, VAR_2, VAR_4,\n                                          VAR_1, VAR_5);\n    if (VAR_3 == NULL) {\n        mutex_unlock(&VAR_0->lock);\n        return;\n    }\n\n    unsigned VAR_6 = VAR_7;\n    if (VAR_1[7] == VAR_8) {\n        /* COMMENT_0 */\n        asymcute_sub_t *VAR_9 = (asymcute_sub_t *)VAR_3->arg;\n        if (VAR_9 == NULL) {\n            return;\n        }\n\n        VAR_9->topic->id = byteorder_bebuftohs(&VAR_1[3]);\n        VAR_9->topic->con = VAR_0;\n        /* COMMENT_1 */\n        VAR_9->next = VAR_0->subscriptions;\n        VAR_0->subscriptions = VAR_9;\n        VAR_6 = VAR_10;\n    }\n\n    /* COMMENT_2 */\n    mutex_unlock(&VAR_3->lock);\n    mutex_unlock(&VAR_0->lock);\n    VAR_0->user_cb(VAR_3, VAR_6);\n}",
  "func_graph_path": "RIOT-OS/RIOT/30e4823e946949befe74ef94bc48fe43958c28a6/asymcute.c/vul/after/2.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -12,6 +12,10 @@\n     if (data[7] == MQTTSN_ACCEPTED) {\n         /* parse and apply assigned topic id */\n         asymcute_sub_t *sub = (asymcute_sub_t *)req->arg;\n+        if (sub == NULL) {\n+            return;\n+        }\n+\n         sub->topic->id = byteorder_bebuftohs(&data[3]);\n         sub->topic->con = con;\n         /* insert subscription to connection context */",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "        if (sub == NULL) {",
      "            return;",
      "        }",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/RIOT-OS/RIOT/pull/12293",
  "description": {
    "pr_info": {
      "title": "asymcute: Fix null pointer dereference",
      "number": 12293
    },
    "comment": [
      "### Contribution description\r\n\r\nThis PR fixes various null pointer dereferences in `asymcute`. All of\r\nthese are due to the assumption that `req->arg` is always non-NULL.\r\nSince an attacker can spoof mqtt replies this is not neccessarly the\r\ncase.\r\n\r\nThis assumption is made at various places in the code. I only tested\r\nthis with `MQTTSN_SUBACK` messages (`_on_suback` function) but the same\r\nissue should apply to any function accessing `req->arg` without checking\r\nfor `NULL`.\r\n\r\n### Testing procedure\r\n\r\nMy tap setup is as follows:\r\n\r\n```\r\n4: tap0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000\r\n    link/ether 72:f3:e4:fd:13:9c brd ff:ff:ff:ff:ff:ff\r\n    inet6 fe80::70f3:e4ff:fefd:139c/64 scope link\r\n       valid_lft forever preferred_lft forever\r\n```\r\n\r\nOn `native`:\r\n\r\n```\r\n$ make -C `examples/asymcute_mqttsn` all-valgrind\r\n$ make -C `examples/asymcute_mqttsn` term-valgrind\r\nmain(): This is RIOT! (Version: UNKNOWN (builddir: /root/RIOT))\r\nAsymcute MQTT-SN example application\r\n\r\nType 'help' to get started and have a look at the README.md for more information.\r\n> connect myclient [fe80::70f3:e4ff:fefd:139c]:2342\r\n```\r\n\r\nBefore the connect request timesout spoof a reply using:\r\n\r\n```\r\nprintf CBMAAAIAAAA= | base64 -d | \\\r\n\tbusybox nc -p 2342 -u 'fe80::70f3:e4ff:fefd:139d%tap0' 49152\r\n```\r\n\r\n`49152` should be the default ephemeral port. The packet must have the\r\nserver address as source address and the server port as source port.\r\n\r\n**Expected result:** The packet should be rejected.\r\n**Actual result:** Segmentation fault + invalid read of size 4.\r\n\r\n### Impact\r\n\r\nThe null pointer dereference should result in a crash on most\r\nplatforms. Thereby allowing a denial of service. The attacker must be\r\nable to spoof a MQTT response which is easy as the ephemeral port is not\r\npicked at random. Additionally, the attacker needs to know a pending\r\nMQTT MsgId, however, those aren't picked at random either and there are\r\nonly `2^8` possible values."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95\n\n**Step-by-Step Explanation:**\n\n1. **Input Analysis**: The commit message and vulnerability description both address a NULL pointer dereference leading to a Denial of Service (DoS). The code diff adds a NULL check for `req->arg`.\n\n2. **Consistency Check**: The code changes directly address the described vulnerability by adding the necessary NULL check.\n\n3. **Purpose Evaluation**: The change fixes a security issue, not a non-security bug or feature enhancement.\n\n4. **Security Assessment**: The patch fixes an exploit leading to a crash, which is a clear security vulnerability.\n\n5. **Confidence**: High confidence as all elements clearly indicate a security fix with no ambiguities."
}