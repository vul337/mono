{
  "cve_id": "CVE-2017-5495",
  "cwe_ids": [
    "CWE-119"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:C",
  "cvss_is_v3": false,
  "repo_name": "FRRouting/frr",
  "commit_msg": "lib: limit size of vty buffer to 4096 bytes\n\nThis removes the automatic resizing of the vty input buffer and places a\nhard size cap of 4096 bytes. It also fixes a potentially unsafe strcpy.\n\nSigned-off-by: Quentin Young <qlyoung@cumulusnetworks.com>",
  "commit_hash": "2af38873d89e20bd039255418366c1601aa99e64",
  "git_url": "https://github.com/FRRouting/frr/commit/2af38873d89e20bd039255418366c1601aa99e64",
  "file_path": "lib/vty.c",
  "func_name": "vtysh_read",
  "func_before": "static int\nvtysh_read (struct thread *thread)\n{\n  int ret;\n  int sock;\n  int nbytes;\n  struct vty *vty;\n  unsigned char buf[VTY_READ_BUFSIZ];\n  unsigned char *p;\n  u_char header[4] = {0, 0, 0, 0};\n\n  sock = THREAD_FD (thread);\n  vty = THREAD_ARG (thread);\n  vty->t_read = NULL;\n\n  if ((nbytes = read (sock, buf, VTY_READ_BUFSIZ)) <= 0)\n    {\n      if (nbytes < 0)\n        {\n          if (ERRNO_IO_RETRY(errno))\n            {\n              vty_event (VTYSH_READ, sock, vty);\n              return 0;\n            }\n          vty->monitor = 0; /* disable monitoring to avoid infinite recursion */\n          zlog_warn(\"%s: read failed on vtysh client fd %d, closing: %s\",\n                    __func__, sock, safe_strerror(errno));\n        }\n      buffer_reset(vty->obuf);\n      vty_close (vty);\n#ifdef VTYSH_DEBUG\n      printf (\"close vtysh\\n\");\n#endif /* VTYSH_DEBUG */\n      return 0;\n    }\n\n#ifdef VTYSH_DEBUG\n  printf (\"line: %.*s\\n\", nbytes, buf);\n#endif /* VTYSH_DEBUG */\n\n  for (p = buf; p < buf+nbytes; p++)\n    {\n      vty_ensure(vty, vty->length+1);\n      vty->buf[vty->length++] = *p;\n      if (*p == '\\0')\n        {\n          /* Pass this line to parser. */\n          ret = vty_execute (vty);\n          /* Note that vty_execute clears the command buffer and resets\n             vty->length to 0. */\n\n          /* Return result. */\n#ifdef VTYSH_DEBUG\n          printf (\"result: %d\\n\", ret);\n          printf (\"vtysh node: %d\\n\", vty->node);\n#endif /* VTYSH_DEBUG */\n\n          /* hack for asynchronous \"write integrated\"\n           * - other commands in \"buf\" will be ditched\n           * - input during pending config-write is \"unsupported\" */\n          if (ret == CMD_SUSPEND)\n            break;\n\n          /* warning: watchfrr hardcodes this result write */\n\t  header[3] = ret;\n\t  buffer_put(vty->obuf, header, 4);\n\n          if (!vty->t_write && (vtysh_flush(vty) < 0))\n            /* Try to flush results; exit if a write error occurs. */\n            return 0;\n        }\n    }\n\n  vty_event (VTYSH_READ, sock, vty);\n\n  return 0;\n}",
  "abstract_func_before": "static int\nvtysh_read (struct thread *thread)\n{\n  int VAR_0;\n  int VAR_1;\n  int VAR_2;\n  struct vty *vty;\n  unsigned char VAR_3[VAR_4];\n  unsigned char *VAR_5;\n  u_char VAR_6[4] = {0, 0, 0, 0};\n\n  VAR_1 = THREAD_FD (thread);\n  vty = THREAD_ARG (thread);\n  vty->t_read = NULL;\n\n  if ((VAR_2 = read (VAR_1, VAR_3, VAR_4)) <= 0)\n    {\n      if (VAR_2 < 0)\n        {\n          if (ERRNO_IO_RETRY(VAR_7))\n            {\n              vty_event (VAR_8, VAR_1, vty);\n              return 0;\n            }\n          vty->monitor = 0; /* COMMENT_0 */\n          zlog_warn(\"%s: read failed on vtysh client fd %d, closing: %s\",\n                    VAR_9, VAR_1, safe_strerror(VAR_7));\n        }\n      buffer_reset(vty->obuf);\n      vty_close (vty);\n#ifdef VAR_10\n      printf (\"close vtysh\\n\");\n#endif /* COMMENT_1 */\n      return 0;\n    }\n\n#ifdef VAR_10\n  printf (\"line: %.*s\\n\", VAR_2, VAR_3);\n#endif /* COMMENT_1 */\n\n  for (VAR_5 = VAR_3; VAR_5 < VAR_3+VAR_2; VAR_5++)\n    {\n      vty_ensure(vty, vty->length+1);\n      vty->buf[vty->length++] = *VAR_5;\n      if (*VAR_5 == '\\0')\n        {\n          /* COMMENT_2 */\n          VAR_0 = vty_execute (vty);\n          /* COMMENT_3 */\n                                 \n\n          /* COMMENT_5 */\n#ifdef VAR_10\n          printf (\"result: %d\\n\", VAR_0);\n          printf (\"vtysh node: %d\\n\", vty->node);\n#endif /* COMMENT_1 */\n\n          /* COMMENT_6 */\n                                                      \n                                                                    \n          if (VAR_0 == VAR_11)\n            break;\n\n          /* COMMENT_9 */\n\t  VAR_6[3] = VAR_0;\n\t  buffer_put(vty->obuf, VAR_6, 4);\n\n          if (!vty->t_write && (vtysh_flush(vty) < 0))\n            /* COMMENT_10 */\n            return 0;\n        }\n    }\n\n  vty_event (VAR_8, VAR_1, vty);\n\n  return 0;\n}",
  "func_graph_path_before": "FRRouting/frr/2af38873d89e20bd039255418366c1601aa99e64/vty.c/vul/before/0.json",
  "func": "static int\nvtysh_read (struct thread *thread)\n{\n  int ret;\n  int sock;\n  int nbytes;\n  struct vty *vty;\n  unsigned char buf[VTY_READ_BUFSIZ];\n  unsigned char *p;\n  u_char header[4] = {0, 0, 0, 0};\n\n  sock = THREAD_FD (thread);\n  vty = THREAD_ARG (thread);\n  vty->t_read = NULL;\n\n  if ((nbytes = read (sock, buf, VTY_READ_BUFSIZ)) <= 0)\n    {\n      if (nbytes < 0)\n        {\n          if (ERRNO_IO_RETRY(errno))\n            {\n              vty_event (VTYSH_READ, sock, vty);\n              return 0;\n            }\n          vty->monitor = 0; /* disable monitoring to avoid infinite recursion */\n          zlog_warn(\"%s: read failed on vtysh client fd %d, closing: %s\",\n                    __func__, sock, safe_strerror(errno));\n        }\n      buffer_reset(vty->obuf);\n      vty_close (vty);\n#ifdef VTYSH_DEBUG\n      printf (\"close vtysh\\n\");\n#endif /* VTYSH_DEBUG */\n      return 0;\n    }\n\n#ifdef VTYSH_DEBUG\n  printf (\"line: %.*s\\n\", nbytes, buf);\n#endif /* VTYSH_DEBUG */\n\n  if (vty->length + nbytes > VTY_BUFSIZ)\n    {\n      /* Clear command line buffer. */\n      vty->cp = vty->length = 0;\n      vty_clear_buf (vty);\n      vty_out (vty, \"%% Command is too long.%s\", VTY_NEWLINE);\n    }\n  else\n    {\n      for (p = buf; p < buf+nbytes; p++)\n        {\n          vty->buf[vty->length++] = *p;\n          if (*p == '\\0')\n            {\n              /* Pass this line to parser. */\n              ret = vty_execute (vty);\n              /* Note that vty_execute clears the command buffer and resets\n                 vty->length to 0. */\n\n              /* Return result. */\n#ifdef VTYSH_DEBUG\n              printf (\"result: %d\\n\", ret);\n              printf (\"vtysh node: %d\\n\", vty->node);\n#endif /* VTYSH_DEBUG */\n\n              /* hack for asynchronous \"write integrated\"\n               * - other commands in \"buf\" will be ditched\n               * - input during pending config-write is \"unsupported\" */\n              if (ret == CMD_SUSPEND)\n                break;\n\n              /* warning: watchquagga hardcodes this result write */\n              header[3] = ret;\n              buffer_put(vty->obuf, header, 4);\n\n              if (!vty->t_write && (vtysh_flush(vty) < 0))\n                /* Try to flush results; exit if a write error occurs. */\n                return 0;\n            }\n        }\n    }\n\n  vty_event (VTYSH_READ, sock, vty);\n\n  return 0;\n}",
  "abstract_func": "static int\nvtysh_read (struct thread *thread)\n{\n  int VAR_0;\n  int VAR_1;\n  int VAR_2;\n  struct vty *vty;\n  unsigned char VAR_3[VAR_4];\n  unsigned char *VAR_5;\n  u_char VAR_6[4] = {0, 0, 0, 0};\n\n  VAR_1 = THREAD_FD (thread);\n  vty = THREAD_ARG (thread);\n  vty->t_read = NULL;\n\n  if ((VAR_2 = read (VAR_1, VAR_3, VAR_4)) <= 0)\n    {\n      if (VAR_2 < 0)\n        {\n          if (ERRNO_IO_RETRY(VAR_7))\n            {\n              vty_event (VAR_8, VAR_1, vty);\n              return 0;\n            }\n          vty->monitor = 0; /* COMMENT_0 */\n          zlog_warn(\"%s: read failed on vtysh client fd %d, closing: %s\",\n                    VAR_9, VAR_1, safe_strerror(VAR_7));\n        }\n      buffer_reset(vty->obuf);\n      vty_close (vty);\n#ifdef VAR_10\n      printf (\"close vtysh\\n\");\n#endif /* COMMENT_1 */\n      return 0;\n    }\n\n#ifdef VAR_10\n  printf (\"line: %.*s\\n\", VAR_2, VAR_3);\n#endif /* COMMENT_1 */\n\n  if (vty->length + VAR_2 > VAR_11)\n    {\n      /* COMMENT_2 */\n      vty->cp = vty->length = 0;\n      vty_clear_buf (vty);\n      vty_out (vty, \"%% Command is too long.%s\", VAR_12);\n    }\n  else\n    {\n      for (VAR_5 = VAR_3; VAR_5 < VAR_3+VAR_2; VAR_5++)\n        {\n          vty->buf[vty->length++] = *VAR_5;\n          if (*VAR_5 == '\\0')\n            {\n              /* COMMENT_3 */\n              VAR_0 = vty_execute (vty);\n              /* COMMENT_4 */\n                                     \n\n              /* COMMENT_6 */\n#ifdef VAR_10\n              printf (\"result: %d\\n\", VAR_0);\n              printf (\"vtysh node: %d\\n\", vty->node);\n#endif /* COMMENT_1 */\n\n              /* COMMENT_7 */\n                                                          \n                                                                        \n              if (VAR_0 == VAR_13)\n                break;\n\n              /* COMMENT_10 */\n              VAR_6[3] = VAR_0;\n              buffer_put(vty->obuf, VAR_6, 4);\n\n              if (!vty->t_write && (vtysh_flush(vty) < 0))\n                /* COMMENT_11 */\n                return 0;\n            }\n        }\n    }\n\n  vty_event (VAR_8, VAR_1, vty);\n\n  return 0;\n}",
  "func_graph_path": "FRRouting/frr/2af38873d89e20bd039255418366c1601aa99e64/vty.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -38,36 +38,45 @@\n   printf (\"line: %.*s\\n\", nbytes, buf);\n #endif /* VTYSH_DEBUG */\n \n-  for (p = buf; p < buf+nbytes; p++)\n+  if (vty->length + nbytes > VTY_BUFSIZ)\n     {\n-      vty_ensure(vty, vty->length+1);\n-      vty->buf[vty->length++] = *p;\n-      if (*p == '\\0')\n+      /* Clear command line buffer. */\n+      vty->cp = vty->length = 0;\n+      vty_clear_buf (vty);\n+      vty_out (vty, \"%% Command is too long.%s\", VTY_NEWLINE);\n+    }\n+  else\n+    {\n+      for (p = buf; p < buf+nbytes; p++)\n         {\n-          /* Pass this line to parser. */\n-          ret = vty_execute (vty);\n-          /* Note that vty_execute clears the command buffer and resets\n-             vty->length to 0. */\n+          vty->buf[vty->length++] = *p;\n+          if (*p == '\\0')\n+            {\n+              /* Pass this line to parser. */\n+              ret = vty_execute (vty);\n+              /* Note that vty_execute clears the command buffer and resets\n+                 vty->length to 0. */\n \n-          /* Return result. */\n+              /* Return result. */\n #ifdef VTYSH_DEBUG\n-          printf (\"result: %d\\n\", ret);\n-          printf (\"vtysh node: %d\\n\", vty->node);\n+              printf (\"result: %d\\n\", ret);\n+              printf (\"vtysh node: %d\\n\", vty->node);\n #endif /* VTYSH_DEBUG */\n \n-          /* hack for asynchronous \"write integrated\"\n-           * - other commands in \"buf\" will be ditched\n-           * - input during pending config-write is \"unsupported\" */\n-          if (ret == CMD_SUSPEND)\n-            break;\n+              /* hack for asynchronous \"write integrated\"\n+               * - other commands in \"buf\" will be ditched\n+               * - input during pending config-write is \"unsupported\" */\n+              if (ret == CMD_SUSPEND)\n+                break;\n \n-          /* warning: watchfrr hardcodes this result write */\n-\t  header[3] = ret;\n-\t  buffer_put(vty->obuf, header, 4);\n+              /* warning: watchquagga hardcodes this result write */\n+              header[3] = ret;\n+              buffer_put(vty->obuf, header, 4);\n \n-          if (!vty->t_write && (vtysh_flush(vty) < 0))\n-            /* Try to flush results; exit if a write error occurs. */\n-            return 0;\n+              if (!vty->t_write && (vtysh_flush(vty) < 0))\n+                /* Try to flush results; exit if a write error occurs. */\n+                return 0;\n+            }\n         }\n     }\n ",
  "diff_line_info": {
    "deleted_lines": [
      "  for (p = buf; p < buf+nbytes; p++)",
      "      vty_ensure(vty, vty->length+1);",
      "      vty->buf[vty->length++] = *p;",
      "      if (*p == '\\0')",
      "          /* Pass this line to parser. */",
      "          ret = vty_execute (vty);",
      "          /* Note that vty_execute clears the command buffer and resets",
      "             vty->length to 0. */",
      "          /* Return result. */",
      "          printf (\"result: %d\\n\", ret);",
      "          printf (\"vtysh node: %d\\n\", vty->node);",
      "          /* hack for asynchronous \"write integrated\"",
      "           * - other commands in \"buf\" will be ditched",
      "           * - input during pending config-write is \"unsupported\" */",
      "          if (ret == CMD_SUSPEND)",
      "            break;",
      "          /* warning: watchfrr hardcodes this result write */",
      "\t  header[3] = ret;",
      "\t  buffer_put(vty->obuf, header, 4);",
      "          if (!vty->t_write && (vtysh_flush(vty) < 0))",
      "            /* Try to flush results; exit if a write error occurs. */",
      "            return 0;"
    ],
    "added_lines": [
      "  if (vty->length + nbytes > VTY_BUFSIZ)",
      "      /* Clear command line buffer. */",
      "      vty->cp = vty->length = 0;",
      "      vty_clear_buf (vty);",
      "      vty_out (vty, \"%% Command is too long.%s\", VTY_NEWLINE);",
      "    }",
      "  else",
      "    {",
      "      for (p = buf; p < buf+nbytes; p++)",
      "          vty->buf[vty->length++] = *p;",
      "          if (*p == '\\0')",
      "            {",
      "              /* Pass this line to parser. */",
      "              ret = vty_execute (vty);",
      "              /* Note that vty_execute clears the command buffer and resets",
      "                 vty->length to 0. */",
      "              /* Return result. */",
      "              printf (\"result: %d\\n\", ret);",
      "              printf (\"vtysh node: %d\\n\", vty->node);",
      "              /* hack for asynchronous \"write integrated\"",
      "               * - other commands in \"buf\" will be ditched",
      "               * - input during pending config-write is \"unsupported\" */",
      "              if (ret == CMD_SUSPEND)",
      "                break;",
      "              /* warning: watchquagga hardcodes this result write */",
      "              header[3] = ret;",
      "              buffer_put(vty->obuf, header, 4);",
      "              if (!vty->t_write && (vtysh_flush(vty) < 0))",
      "                /* Try to flush results; exit if a write error occurs. */",
      "                return 0;",
      "            }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/FRRouting/frr/pull/63",
  "description": {
    "pr_info": {
      "title": "lib: limit size of vty buffer to 4096 bytes",
      "number": 63
    },
    "comment": [
      "This removes the automatic resizing of the vty input buffer and places a\r\nhard size cap of 4096 bytes. It also fixes a potentially unsafe strcpy.\r\n\r\nSigned-off-by: Quentin Young <qlyoung@cumulusnetworks.com>",
      "# Continous Integration Result: SUCCESSFUL\n\nCongratulations, this patch passed basic tests\n\nTested-by: NetDEF / OpenSourceRouting.org CI System\n\n__CI System Testrun URL: https://ci1.netdef.org/browse/FRR-FRRPULLREQ-34/__\n\nThis is a comment from an EXPERIMENTAL automated CI system.\nFor questions and feedback in regards to this CI system, please feel free to email\nMartin Winter - mwinter (at) opensourcerouting.org.\n\n",
      "This is [CVE-2017-5495](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-5495)"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95"
}