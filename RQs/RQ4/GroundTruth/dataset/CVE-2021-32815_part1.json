{
  "cve_id": "CVE-2021-32815",
  "cwe_ids": [
    "CWE-617"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "Exiv2/exiv2",
  "commit_msg": "Don't crash if s > size.",
  "commit_hash": "0c17eb33c0a7fad1796ce23b8bbc32067f511aed",
  "git_url": "https://github.com/Exiv2/exiv2/commit/0c17eb33c0a7fad1796ce23b8bbc32067f511aed",
  "file_path": "src/crwimage_int.cpp",
  "func_name": "packIfdId",
  "func_before": "DataBuf packIfdId(const ExifData& exifData,\n                            IfdId     ifdId,\n                            ByteOrder byteOrder)\n    {\n        const uint16_t size = 1024;\n        DataBuf buf(size);\n        std::memset(buf.pData_, 0x0, buf.size_);\n\n        uint16_t len = 0;\n        const ExifData::const_iterator b = exifData.begin();\n        const ExifData::const_iterator e = exifData.end();\n        for (ExifData::const_iterator i = b; i != e; ++i) {\n            if (i->ifdId() != ifdId) continue;\n            const uint16_t s = i->tag()*2 + static_cast<uint16_t>(i->size());\n            assert(s <= size);\n            if (len < s) len = s;\n            i->copy(buf.pData_ + i->tag()*2, byteOrder);\n        }\n        // Round the size to make it even.\n        buf.size_ = len + len%2;\n        return buf;\n    }",
  "abstract_func_before": "DataBuf packIfdId(const ExifData& VAR_0,\n                            IfdId     VAR_1,\n                            ByteOrder VAR_2)\n    {\n        const uint16_t VAR_3 = 1024;\n        DataBuf buf(size);\n        std::memset(VAR_4.pData_, 0x0, VAR_4.size_);\n\n        uint16_t VAR_5 = 0;\n        const ExifData::const_iterator VAR_6 = VAR_0.begin();\n        const ExifData::const_iterator VAR_7 = VAR_0.end();\n        for (ExifData::const_iterator VAR_8 = VAR_6; VAR_8 != VAR_7; ++VAR_8) {\n            if (VAR_8->ifdId() != VAR_1) continue;\n            const uint16_t VAR_9 = VAR_8->tag()*2 + VAR_10<uint16_t>(VAR_8->size());\n            assert(VAR_9 <= size);\n            if (VAR_5 < VAR_9) VAR_5 = VAR_9;\n            VAR_8->copy(VAR_4.pData_ + VAR_8->tag()*2, VAR_2);\n        }\n        /* COMMENT_0 */\n        VAR_4.size_ = VAR_5 + VAR_5%2;\n        return VAR_4;\n    }",
  "func_graph_path_before": "Exiv2/exiv2/0c17eb33c0a7fad1796ce23b8bbc32067f511aed/crwimage_int.cpp/vul/before/0.json",
  "func": "DataBuf packIfdId(const ExifData& exifData,\n                            IfdId     ifdId,\n                            ByteOrder byteOrder)\n    {\n        const uint16_t size = 1024;\n        DataBuf buf(size);\n        std::memset(buf.pData_, 0x0, buf.size_);\n\n        uint16_t len = 0;\n        const ExifData::const_iterator b = exifData.begin();\n        const ExifData::const_iterator e = exifData.end();\n        for (ExifData::const_iterator i = b; i != e; ++i) {\n            if (i->ifdId() != ifdId) continue;\n            const uint16_t s = i->tag()*2 + static_cast<uint16_t>(i->size());\n            if (s <= size) {\n                if (len < s) len = s;\n                i->copy(buf.pData_ + i->tag()*2, byteOrder);\n            }\n        }\n        // Round the size to make it even.\n        buf.size_ = len + len%2;\n        return buf;\n    }",
  "abstract_func": "DataBuf packIfdId(const ExifData& VAR_0,\n                            IfdId     VAR_1,\n                            ByteOrder VAR_2)\n    {\n        const uint16_t VAR_3 = 1024;\n        DataBuf buf(size);\n        std::memset(VAR_4.pData_, 0x0, VAR_4.size_);\n\n        uint16_t VAR_5 = 0;\n        const ExifData::const_iterator VAR_6 = VAR_0.begin();\n        const ExifData::const_iterator VAR_7 = VAR_0.end();\n        for (ExifData::const_iterator VAR_8 = VAR_6; VAR_8 != VAR_7; ++VAR_8) {\n            if (VAR_8->ifdId() != VAR_1) continue;\n            const uint16_t VAR_9 = VAR_8->tag()*2 + VAR_10<uint16_t>(VAR_8->size());\n            if (VAR_9 <= size) {\n                if (VAR_5 < VAR_9) VAR_5 = VAR_9;\n                VAR_8->copy(VAR_4.pData_ + VAR_8->tag()*2, VAR_2);\n            }\n        }\n        /* COMMENT_0 */\n        VAR_4.size_ = VAR_5 + VAR_5%2;\n        return VAR_4;\n    }",
  "func_graph_path": "Exiv2/exiv2/0c17eb33c0a7fad1796ce23b8bbc32067f511aed/crwimage_int.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -12,9 +12,10 @@\n         for (ExifData::const_iterator i = b; i != e; ++i) {\n             if (i->ifdId() != ifdId) continue;\n             const uint16_t s = i->tag()*2 + static_cast<uint16_t>(i->size());\n-            assert(s <= size);\n-            if (len < s) len = s;\n-            i->copy(buf.pData_ + i->tag()*2, byteOrder);\n+            if (s <= size) {\n+                if (len < s) len = s;\n+                i->copy(buf.pData_ + i->tag()*2, byteOrder);\n+            }\n         }\n         // Round the size to make it even.\n         buf.size_ = len + len%2;",
  "diff_line_info": {
    "deleted_lines": [
      "            assert(s <= size);",
      "            if (len < s) len = s;",
      "            i->copy(buf.pData_ + i->tag()*2, byteOrder);"
    ],
    "added_lines": [
      "            if (s <= size) {",
      "                if (len < s) len = s;",
      "                i->copy(buf.pData_ + i->tag()*2, byteOrder);",
      "            }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/sridharb1/exiv2/pull/4",
  "description": {
    "pr_info": {
      "title": "0.27 maintenance",
      "number": 4
    },
    "comment": []
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.9\n\nThe commit fixes a bug that caused a crash when a certain condition was met. The issue was related to file placement, not security, so it's categorized as a defect fix. The changes prevent the crash without involving security aspects, leading to a high confidence in this classification."
}