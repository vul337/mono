{
  "cve_id": "CVE-2020-19860",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:N/A:N",
  "cvss_is_v3": false,
  "repo_name": "NLnetLabs/ldns",
  "commit_msg": "* bugfix #70: heap Out-of-bound Read vulnerability in\n  rr_frm_str_internal reported by pokerfacett.",
  "commit_hash": "15d96206996bea969fbc918eb0a4a346f514b9f3",
  "git_url": "https://github.com/NLnetLabs/ldns/commit/15d96206996bea969fbc918eb0a4a346f514b9f3",
  "file_path": "rr.c",
  "func_name": "ldns_rr_new_frm_str_internal",
  "func_before": "static ldns_status\nldns_rr_new_frm_str_internal(ldns_rr **newrr, const char *str,\n\t\t\t\t\t\t\t uint32_t default_ttl, const ldns_rdf *origin,\n\t\t\t\t\t\t\t ldns_rdf **prev, bool question)\n{\n\tldns_rr *new;\n\tconst ldns_rr_descriptor *desc;\n\tldns_rr_type rr_type;\n\tldns_buffer *rr_buf = NULL;\n\tldns_buffer *rd_buf = NULL;\n\tuint32_t ttl_val;\n\tchar  *owner = NULL;\n\tchar  *ttl = NULL;\n\tldns_rr_class clas_val;\n\tchar  *clas = NULL;\n\tchar  *type = NULL;\n\tsize_t type_sz;\n\tchar  *rdata = NULL;\n\tchar  *rd = NULL;\n\tchar  *xtok = NULL; /* For RDF types with spaces (i.e. extra tokens) */\n\tsize_t rd_strlen;\n\tconst char *delimiters;\n\tssize_t c;\n\tldns_rdf *owner_dname;\n        const char* endptr;\n        int was_unknown_rr_format = 0;\n\tldns_status status = LDNS_STATUS_OK;\n\n\t/* used for types with unknown number of rdatas */\n\tbool done;\n\tbool quoted;\n\n\tldns_rdf *r = NULL;\n\tuint16_t r_cnt;\n\tuint16_t r_min;\n\tuint16_t r_max;\n        size_t pre_data_pos;\n\n\tuint16_t hex_data_size;\n\tchar *hex_data_str = NULL;\n\tuint16_t cur_hex_data_size;\n\tsize_t hex_pos = 0;\n\tuint8_t *hex_data = NULL;\n\n\tnew = ldns_rr_new();\n\n\towner = LDNS_XMALLOC(char, LDNS_MAX_DOMAINLEN + 1);\n\tttl = LDNS_XMALLOC(char, LDNS_TTL_DATALEN);\n\tclas = LDNS_XMALLOC(char, LDNS_SYNTAX_DATALEN);\n\trdata = LDNS_XMALLOC(char, LDNS_MAX_PACKETLEN + 1);\n\trr_buf = LDNS_MALLOC(ldns_buffer);\n\trd_buf = LDNS_MALLOC(ldns_buffer);\n\trd = LDNS_XMALLOC(char, LDNS_MAX_RDFLEN);\n\txtok = LDNS_XMALLOC(char, LDNS_MAX_RDFLEN);\n\tif (rr_buf) {\n\t\trr_buf->_data = NULL;\n\t}\n\tif (rd_buf) {\n\t\trd_buf->_data = NULL;\n\t}\n\tif (!new || !owner || !ttl || !clas || !rdata ||\n\t\t\t!rr_buf || !rd_buf || !rd || !xtok) {\n\n\t\tgoto memerror;\n\t}\n\n\tldns_buffer_new_frm_data(rr_buf, (char*)str, strlen(str));\n\n\t/* split the rr in its parts -1 signals trouble */\n\tif (ldns_bget_token(rr_buf, owner, \"\\t\\n \", LDNS_MAX_DOMAINLEN) == -1){\n\n\t\tstatus = LDNS_STATUS_SYNTAX_ERR;\n\t\tgoto error;\n\t}\n\n\tif (ldns_bget_token(rr_buf, ttl, \"\\t\\n \", LDNS_TTL_DATALEN) == -1) {\n\n\t\tstatus = LDNS_STATUS_SYNTAX_TTL_ERR;\n\t\tgoto error;\n\t}\n\tttl_val = (uint32_t) ldns_str2period(ttl, &endptr);\n\n\tif (strlen(ttl) > 0 && !isdigit((int) ttl[0])) {\n\t\t/* ah, it's not there or something */\n\t\tif (default_ttl == 0) {\n\t\t\tttl_val = LDNS_DEFAULT_TTL;\n\t\t} else {\n\t\t\tttl_val = default_ttl;\n\t\t}\n\t\t/* we not ASSUMING the TTL is missing and that\n\t\t * the rest of the RR is still there. That is\n\t\t * CLASS TYPE RDATA\n\t\t * so ttl value we read is actually the class\n\t\t */\n\t\tclas_val = ldns_get_rr_class_by_name(ttl);\n\t\t/* class can be left out too, assume IN, current\n\t\t * token must be type\n\t\t */\n\t\tif (clas_val == 0) {\n\t\t\tclas_val = LDNS_RR_CLASS_IN;\n\t\t\ttype_sz = strlen(ttl) + 1;\n\t\t\ttype = LDNS_XMALLOC(char, type_sz);\n\t\t\tif (!type) {\n\t\t\t\tgoto memerror;\n\t\t\t}\n\t\t\tstrlcpy(type, ttl, type_sz);\n\t\t}\n\t} else {\n\t\tif (-1 == ldns_bget_token(\n\t\t\t\trr_buf, clas, \"\\t\\n \", LDNS_SYNTAX_DATALEN)) {\n\n\t\t\tstatus = LDNS_STATUS_SYNTAX_CLASS_ERR;\n\t\t\tgoto error;\n\t\t}\n\t\tclas_val = ldns_get_rr_class_by_name(clas);\n\t\t/* class can be left out too, assume IN, current\n\t\t * token must be type\n\t\t */\n\t\tif (clas_val == 0) {\n\t\t\tclas_val = LDNS_RR_CLASS_IN;\n\t\t\ttype_sz = strlen(clas) + 1;\n\t\t\ttype = LDNS_XMALLOC(char, type_sz);\n\t\t\tif (!type) {\n\t\t\t\tgoto memerror;\n\t\t\t}\n\t\t\tstrlcpy(type, clas, type_sz);\n\t\t}\n\t}\n\t/* the rest should still be waiting for us */\n\n\tif (!type) {\n\t\ttype = LDNS_XMALLOC(char, LDNS_SYNTAX_DATALEN);\n\t\tif (!type) {\n\t\t\tgoto memerror;\n\t\t}\n\t\tif (-1 == ldns_bget_token(\n\t\t\t\trr_buf, type, \"\\t\\n \", LDNS_SYNTAX_DATALEN)) {\n\n\t\t\tstatus = LDNS_STATUS_SYNTAX_TYPE_ERR;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (ldns_bget_token(rr_buf, rdata, \"\\0\", LDNS_MAX_PACKETLEN) == -1) {\n\t\t/* apparently we are done, and it's only a question RR\n\t\t * so do not set status and go to ldnserror here\n\t\t */\n\t}\n\tldns_buffer_new_frm_data(rd_buf, rdata, strlen(rdata));\n\n\tif (strlen(owner) <= 1 && strncmp(owner, \"@\", 1) == 0) {\n\t\tif (origin) {\n\t\t\tldns_rr_set_owner(new, ldns_rdf_clone(origin));\n\t\t} else if (prev && *prev) {\n\t\t\tldns_rr_set_owner(new, ldns_rdf_clone(*prev));\n\t\t} else {\n\t\t\t/* default to root */\n\t\t\tldns_rr_set_owner(new, ldns_dname_new_frm_str(\".\"));\n\t\t}\n\n\t\t/* @ also overrides prev */\n\t\tif (prev) {\n\t\t\tldns_rdf_deep_free(*prev);\n\t\t\t*prev = ldns_rdf_clone(ldns_rr_owner(new));\n\t\t\tif (!*prev) {\n\t\t\t\tgoto memerror;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (strlen(owner) == 0) {\n\t\t\t/* no ownername was given, try prev, if that fails\n\t\t\t * origin, else default to root */\n\t\t\tif (prev && *prev) {\n\t\t\t\tldns_rr_set_owner(new, ldns_rdf_clone(*prev));\n\t\t\t} else if (origin) {\n\t\t\t\tldns_rr_set_owner(new, ldns_rdf_clone(origin));\n\t\t\t} else {\n\t\t\t\tldns_rr_set_owner(new,\n\t\t\t\t\t\tldns_dname_new_frm_str(\".\"));\n\t\t\t}\n\t\t\tif(!ldns_rr_owner(new)) {\n\t\t\t\tgoto memerror;\n\t\t\t}\n\t\t} else {\n\t\t\towner_dname = ldns_dname_new_frm_str(owner);\n\t\t\tif (!owner_dname) {\n\t\t\t\tstatus = LDNS_STATUS_SYNTAX_ERR;\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tldns_rr_set_owner(new, owner_dname);\n\t\t\tif (!ldns_dname_str_absolute(owner) && origin) {\n\t\t\t\tif(ldns_dname_cat(ldns_rr_owner(new), origin)\n\t\t\t\t\t\t!= LDNS_STATUS_OK) {\n\n\t\t\t\t\tstatus = LDNS_STATUS_SYNTAX_ERR;\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (prev) {\n\t\t\t\tldns_rdf_deep_free(*prev);\n\t\t\t\t*prev = ldns_rdf_clone(ldns_rr_owner(new));\n\t\t\t\tif (!*prev) {\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tLDNS_FREE(owner);\n\n\tldns_rr_set_question(new, question);\n\n\tldns_rr_set_ttl(new, ttl_val);\n\tLDNS_FREE(ttl);\n\n\tldns_rr_set_class(new, clas_val);\n\tLDNS_FREE(clas);\n\n\trr_type = ldns_get_rr_type_by_name(type);\n\tLDNS_FREE(type);\n\n\tdesc = ldns_rr_descript((uint16_t)rr_type);\n\tldns_rr_set_type(new, rr_type);\n\tif (desc) {\n\t\t/* only the rdata remains */\n\t\tr_max = ldns_rr_descriptor_maximum(desc);\n\t\tr_min = ldns_rr_descriptor_minimum(desc);\n\t} else {\n\t\tr_min = 0;\n\t\tr_max = 1;\n\t}\n\n\tfor (done = false, r_cnt = 0; !done && r_cnt < r_max; r_cnt++) {\n\t\tquoted = false;\n\n\t\tswitch (ldns_rr_descriptor_field_type(desc, r_cnt)) {\n\t\tcase LDNS_RDF_TYPE_B64        :\n\t\tcase LDNS_RDF_TYPE_HEX        : /* These rdf types may con- */\n\t\tcase LDNS_RDF_TYPE_LOC        : /* tain whitespace, only if */\n\t\tcase LDNS_RDF_TYPE_WKS        : /* it is the last rd field. */\n\t\tcase LDNS_RDF_TYPE_IPSECKEY   :\n\t\tcase LDNS_RDF_TYPE_AMTRELAY   :\n\t\tcase LDNS_RDF_TYPE_NSEC       :\tif (r_cnt == r_max - 1) {\n\t\t\t\t\t\t\tdelimiters = \"\\n\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* fallthrough */\n\t\tdefault                       :\tdelimiters = \"\\n\\t \"; \n\t\t}\n\n\t\tif (ldns_rdf_type_maybe_quoted(\n\t\t\t\tldns_rr_descriptor_field_type(\n\t\t\t\tdesc, r_cnt)) &&\n\t\t\t\tldns_buffer_remaining(rd_buf) > 0){\n\n\t\t\t/* skip spaces */\n\t\t\twhile (*(ldns_buffer_current(rd_buf)) == ' ') {\n\t\t\t\tldns_buffer_skip(rd_buf, 1);\n\t\t\t}\n\n\t\t\tif (*(ldns_buffer_current(rd_buf)) == '\\\"') {\n\t\t\t\tdelimiters = \"\\\"\\0\";\n\t\t\t\tldns_buffer_skip(rd_buf, 1);\n\t\t\t\tquoted = true;\n\t\t\t} else if (ldns_rr_descriptor_field_type(desc, r_cnt)\n\t\t\t\t\t== LDNS_RDF_TYPE_LONG_STR) {\n\n\t\t\t\tstatus = LDNS_STATUS_SYNTAX_RDATA_ERR;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\n\t\t/* because number of fields can be variable, we can't rely on\n\t\t * _maximum() only\n\t\t */\n\n\t\t/* skip spaces */\n\t\twhile (ldns_buffer_position(rd_buf) < ldns_buffer_limit(rd_buf)\n\t\t\t\t&& *(ldns_buffer_current(rd_buf)) == ' '\n\t\t\t\t&& !quoted) {\n\n\t\t\tldns_buffer_skip(rd_buf, 1);\n\t\t}\n\n\t\tpre_data_pos = ldns_buffer_position(rd_buf);\n\t\tif (-1 == (c = ldns_bget_token(\n\t\t\t\trd_buf, rd, delimiters, LDNS_MAX_RDFLEN))) {\n\n\t\t\tdone = true;\n\t\t\t(void)done; /* we're breaking, so done not read anymore */\n\t\t\tbreak;\n\t\t}\n\t\t/* hmmz, rfc3597 specifies that any type can be represented \n\t\t * with \\# method, which can contain spaces...\n\t\t * it does specify size though...\n\t\t */\n\t\trd_strlen = strlen(rd);\n\n\t\t/* unknown RR data */\n\t\tif (strncmp(rd, \"\\\\#\", 2) == 0 && !quoted &&\n\t\t\t\t(rd_strlen == 2 || rd[2]==' ')) {\n\n\t\t\twas_unknown_rr_format = 1;\n\t\t\t/* go back to before \\#\n\t\t\t * and skip it while setting delimiters better\n\t\t\t */\n\t\t\tldns_buffer_set_position(rd_buf, pre_data_pos);\n\t\t\tdelimiters = \"\\n\\t \";\n\t\t\t(void)ldns_bget_token(rd_buf, rd,\n\t\t\t\t\tdelimiters, LDNS_MAX_RDFLEN);\n\t\t\t/* read rdata octet length */\n\t\t\tc = ldns_bget_token(rd_buf, rd,\n\t\t\t\t\tdelimiters, LDNS_MAX_RDFLEN);\n\t\t\tif (c == -1) {\n\t\t\t\t/* something goes very wrong here */\n\t\t\t\tstatus = LDNS_STATUS_SYNTAX_RDATA_ERR;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\thex_data_size = (uint16_t) atoi(rd);\n\t\t\t/* copy hex chars into hex str (2 chars per byte) */\n\t\t\thex_data_str = LDNS_XMALLOC(char, 2*hex_data_size + 1);\n\t\t\tif (!hex_data_str) {\n\t\t\t\t/* malloc error */\n\t\t\t\tgoto memerror;\n\t\t\t}\n\t\t\tcur_hex_data_size = 0;\n\t\t\twhile(cur_hex_data_size < 2 * hex_data_size) {\n\t\t\t\tc = ldns_bget_token(rd_buf, rd,\n\t\t\t\t\t\tdelimiters, LDNS_MAX_RDFLEN);\n\t\t\t\tif (c == -1) {\n\t\t\t\t\tstatus = LDNS_STATUS_SYNTAX_RDATA_ERR;\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\trd_strlen = strlen(rd);\n\t\t\t\tif ((size_t)cur_hex_data_size + rd_strlen >\n\t\t\t\t    2 * (size_t)hex_data_size) {\n\t\t\t\t\tstatus = LDNS_STATUS_SYNTAX_RDATA_ERR;\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tstrlcpy(hex_data_str + cur_hex_data_size, rd,\n\t\t\t\t\t\trd_strlen + 1);\n\n\t\t\t\tcur_hex_data_size += rd_strlen;\n\t\t\t}\n\t\t\thex_data_str[cur_hex_data_size] = '\\0';\n\n\t\t\t/* correct the rdf type */\n\t\t\t/* if *we* know the type, interpret it as wireformat */\n\t\t\tif (desc) {\n\t\t\t\thex_pos = 0;\n\t\t\t\thex_data =\n\t\t\t\t\tLDNS_XMALLOC(uint8_t, hex_data_size+2);\n\n\t\t\t\tif (!hex_data) {\n\t\t\t\t\tgoto memerror;\n\t\t\t\t}\n\t\t\t\tldns_write_uint16(hex_data, hex_data_size);\n\t\t\t\tldns_hexstring_to_data(\n\t\t\t\t\t\thex_data + 2, hex_data_str);\n\t\t\t\tstatus = ldns_wire2rdf(new, hex_data,\n\t\t\t\t\t\thex_data_size + 2, &hex_pos);\n\t\t\t\tif (status != LDNS_STATUS_OK) {\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tLDNS_FREE(hex_data);\n\t\t\t} else {\n\t\t\t\tr = ldns_rdf_new_frm_str(LDNS_RDF_TYPE_HEX,\n\t\t\t\t\t\thex_data_str);\n\t\t\t\tif (!r) {\n\t\t\t\t\tgoto memerror;\n\t\t\t\t}\n\t\t\t\tldns_rdf_set_type(r, LDNS_RDF_TYPE_UNKNOWN);\n\t\t\t\tif (!ldns_rr_push_rdf(new, r)) {\n\t\t\t\t\tgoto memerror;\n\t\t\t\t}\n\t\t\t}\n\t\t\tLDNS_FREE(hex_data_str);\n\n\t\t} else if(rd_strlen > 0 || quoted) {\n\t\t\t/* Normal RR */\n\t\t\tswitch(ldns_rr_descriptor_field_type(desc, r_cnt)) {\n\n\t\t\tcase LDNS_RDF_TYPE_HEX:\n\t\t\tcase LDNS_RDF_TYPE_B64:\n\t\t\t\t/* When this is the last rdata field, then the\n\t\t\t\t * rest should be read in (cause then these\n\t\t\t\t * rdf types may contain spaces).\n\t\t\t\t */\n\t\t\t\tif (r_cnt == r_max - 1) {\n\t\t\t\t\tc = ldns_bget_token(rd_buf, xtok,\n\t\t\t\t\t\t\t\"\\n\", LDNS_MAX_RDFLEN);\n\t\t\t\t\tif (c != -1) {\n\t\t\t\t\t\t(void) strncat(rd, xtok,\n\t\t\t\t\t\t\tLDNS_MAX_RDFLEN -\n\t\t\t\t\t\t\tstrlen(rd) - 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr = ldns_rdf_new_frm_str(\n\t\t\t\t\t\tldns_rr_descriptor_field_type(\n\t\t\t\t\t\t\tdesc, r_cnt), rd);\n\t\t\t\tbreak;\n\n\t\t\tcase LDNS_RDF_TYPE_HIP:\n\t\t\t\t/*\n\t\t\t\t * In presentation format this RDATA type has\n\t\t\t\t * three tokens: An algorithm byte, then a\n\t\t\t\t * variable length HIT (in hexbytes) and then\n\t\t\t\t * a variable length Public Key (in base64).\n\t\t\t\t *\n\t\t\t\t * We have just read the algorithm, so we need\n\t\t\t\t * two more tokens: HIT and Public Key.\n\t\t\t\t */\n\t\t\t\tdo {\n\t\t\t\t\t/* Read and append HIT */\n\t\t\t\t\tif (ldns_bget_token(rd_buf,\n\t\t\t\t\t\t\txtok, delimiters,\n\t\t\t\t\t\t\tLDNS_MAX_RDFLEN) == -1)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t(void) strncat(rd, \" \",\n\t\t\t\t\t\t\tLDNS_MAX_RDFLEN -\n\t\t\t\t\t\t\tstrlen(rd) - 1);\n\t\t\t\t\t(void) strncat(rd, xtok,\n\t\t\t\t\t\t\tLDNS_MAX_RDFLEN -\n\t\t\t\t\t\t\tstrlen(rd) - 1);\n\n\t\t\t\t\t/* Read and append Public Key*/\n\t\t\t\t\tif (ldns_bget_token(rd_buf,\n\t\t\t\t\t\t\txtok, delimiters,\n\t\t\t\t\t\t\tLDNS_MAX_RDFLEN) == -1)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t(void) strncat(rd, \" \",\n\t\t\t\t\t\t\tLDNS_MAX_RDFLEN -\n\t\t\t\t\t\t\tstrlen(rd) - 1);\n\t\t\t\t\t(void) strncat(rd, xtok,\n\t\t\t\t\t\t\tLDNS_MAX_RDFLEN -\n\t\t\t\t\t\t\tstrlen(rd) - 1);\n\t\t\t\t} while (false);\n\n\t\t\t\tr = ldns_rdf_new_frm_str(\n\t\t\t\t\t\tldns_rr_descriptor_field_type(\n\t\t\t\t\t\t\tdesc, r_cnt), rd);\n\t\t\t\tbreak;\n\n\t\t\tcase LDNS_RDF_TYPE_DNAME:\n\t\t\t\tr = ldns_rdf_new_frm_str(\n\t\t\t\t\t\tldns_rr_descriptor_field_type(\n\t\t\t\t\t\t\tdesc, r_cnt), rd);\n\n\t\t\t\t/* check if the origin should be used\n\t\t\t\t * or concatenated\n\t\t\t\t */\n\t\t\t\tif (r && ldns_rdf_size(r) > 1 &&\n\t\t\t\t\t\tldns_rdf_data(r)[0] == 1 &&\n\t\t\t\t\t\tldns_rdf_data(r)[1] == '@') {\n\n\t\t\t\t\tldns_rdf_deep_free(r);\n\n\t\t\t\t\tr = origin ? ldns_rdf_clone(origin)\n\n\t\t\t\t\t  : ( rr_type == LDNS_RR_TYPE_SOA ?\n\n\t\t\t\t\t      ldns_rdf_clone(\n\t\t\t\t\t\t      ldns_rr_owner(new))\n\n\t\t\t\t\t    : ldns_rdf_new_frm_str(\n\t\t\t\t\t\t    LDNS_RDF_TYPE_DNAME, \".\")\n\t\t\t\t\t    );\n\n\t\t\t\t} else if (r && rd_strlen >= 1 && origin &&\n\t\t\t\t\t\t!ldns_dname_str_absolute(rd)) {\n\n\t\t\t\t\tstatus = ldns_dname_cat(r, origin);\n\t\t\t\t\tif (status != LDNS_STATUS_OK) {\n\t\t\t\t\t\tgoto error;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tr = ldns_rdf_new_frm_str(\n\t\t\t\t\t\tldns_rr_descriptor_field_type(\n\t\t\t\t\t\t\tdesc, r_cnt), rd);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!r) {\n\t\t\t\tstatus = LDNS_STATUS_SYNTAX_RDATA_ERR;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tldns_rr_push_rdf(new, r);\n\t\t}\n\t\tif (quoted) {\n\t\t\tif (ldns_buffer_available(rd_buf, 1)) {\n\t\t\t\tldns_buffer_skip(rd_buf, 1);\n\t\t\t} else {\n\t\t\t\tdone = true;\n\t\t\t}\n\t\t}\n\n\t} /* for (done = false, r_cnt = 0; !done && r_cnt < r_max; r_cnt++) */\n\tLDNS_FREE(rd);\n\tLDNS_FREE(xtok);\n\tldns_buffer_free(rr_buf);\n\tLDNS_FREE(rdata);\n\tif (ldns_buffer_remaining(rd_buf) > 0) {\n\t\tldns_buffer_free(rd_buf);\n\t\tldns_rr_free(new);\n\t\treturn LDNS_STATUS_SYNTAX_SUPERFLUOUS_TEXT_ERR;\n\t}\n\tldns_buffer_free(rd_buf);\n\n\tif (!question && desc && !was_unknown_rr_format &&\n\t\t\tldns_rr_rd_count(new) < r_min) {\n\n\t\tldns_rr_free(new);\n\t\treturn LDNS_STATUS_SYNTAX_MISSING_VALUE_ERR;\n\t}\n\n\tif (newrr) {\n\t\t*newrr = new;\n\t} else {\n\t\t/* Maybe the caller just wanted to see if it would parse? */\n\t\tldns_rr_free(new);\n\t}\n\treturn LDNS_STATUS_OK;\n\nmemerror:\n\tstatus = LDNS_STATUS_MEM_ERR;\nerror:\n\tif (rd_buf && rd_buf->_data) {\n\t\tldns_buffer_free(rd_buf);\n\t} else {\n\t\tLDNS_FREE(rd_buf);\n\t}\n\tif (rr_buf && rr_buf->_data) {\n\t\tldns_buffer_free(rr_buf);\n\t} else {\n\t\tLDNS_FREE(rr_buf);\n\t}\n\tLDNS_FREE(type);\n\tLDNS_FREE(owner);\n\tLDNS_FREE(ttl);\n\tLDNS_FREE(clas);\n\tLDNS_FREE(hex_data);\n\tLDNS_FREE(hex_data_str);\n\tLDNS_FREE(xtok);\n\tLDNS_FREE(rd);\n\tLDNS_FREE(rdata);\n\tldns_rr_free(new);\n\treturn status;\n}",
  "abstract_func_before": "static ldns_status\nldns_rr_new_frm_str_internal(ldns_rr **VAR_0, const char *VAR_1,\n\t\t\t\t\t\t\t uint32_t VAR_2, const ldns_rdf *VAR_3,\n\t\t\t\t\t\t\t ldns_rdf **VAR_4, bool VAR_5)\n{\n\tldns_rr *VAR_6;\n\tconst ldns_rr_descriptor *VAR_7;\n\tldns_rr_type VAR_8;\n\tldns_buffer *VAR_9 = NULL;\n\tldns_buffer *VAR_10 = NULL;\n\tuint32_t VAR_11;\n\tchar  *VAR_12 = NULL;\n\tchar  *VAR_13 = NULL;\n\tldns_rr_class VAR_14;\n\tchar  *VAR_15 = NULL;\n\tchar  *VAR_16 = NULL;\n\tsize_t VAR_17;\n\tchar  *VAR_18 = NULL;\n\tchar  *VAR_19 = NULL;\n\tchar  *VAR_20 = NULL; /* COMMENT_0 */\n\tsize_t VAR_21;\n\tconst char *VAR_22;\n\tssize_t VAR_23;\n\tldns_rdf *VAR_24;\n        const char* VAR_25;\n        int VAR_26 = 0;\n\tldns_status VAR_27 = VAR_28;\n\n\t/* COMMENT_1 */\n\tbool VAR_29;\n\tbool VAR_30;\n\n\tldns_rdf *VAR_31 = NULL;\n\tuint16_t VAR_32;\n\tuint16_t VAR_33;\n\tuint16_t VAR_34;\n        size_t VAR_35;\n\n\tuint16_t VAR_36;\n\tchar *VAR_37 = NULL;\n\tuint16_t VAR_38;\n\tsize_t VAR_39 = 0;\n\tuint8_t *VAR_40 = NULL;\n\n\tVAR_6 = ldns_rr_new();\n\n\tVAR_12 = LDNS_XMALLOC(char, VAR_41 + 1);\n\tVAR_13 = LDNS_XMALLOC(char, VAR_42);\n\tVAR_15 = LDNS_XMALLOC(char, VAR_43);\n\tVAR_18 = LDNS_XMALLOC(char, VAR_44 + 1);\n\tVAR_9 = LDNS_MALLOC(ldns_buffer);\n\tVAR_10 = LDNS_MALLOC(ldns_buffer);\n\tVAR_19 = LDNS_XMALLOC(char, VAR_45);\n\tVAR_20 = LDNS_XMALLOC(char, VAR_45);\n\tif (VAR_9) {\n\t\tVAR_9->_data = NULL;\n\t}\n\tif (VAR_10) {\n\t\tVAR_10->_data = NULL;\n\t}\n\tif (!VAR_6 || !VAR_12 || !VAR_13 || !VAR_15 || !VAR_18 ||\n\t\t\t!VAR_9 || !VAR_10 || !VAR_19 || !VAR_20) {\n\n\t\tgoto memerror;\n\t}\n\n\tldns_buffer_new_frm_data(VAR_9, (char*)VAR_1, strlen(VAR_1));\n\n\t/* COMMENT_2 */\n\tif (ldns_bget_token(VAR_9, VAR_12, \"\\t\\n \", VAR_41) == -1){\n\n\t\tVAR_27 = VAR_46;\n\t\tgoto error;\n\t}\n\n\tif (ldns_bget_token(VAR_9, VAR_13, \"\\t\\n \", VAR_42) == -1) {\n\n\t\tVAR_27 = VAR_47;\n\t\tgoto error;\n\t}\n\tVAR_11 = (uint32_t) ldns_str2period(VAR_13, &VAR_25);\n\n\tif (strlen(VAR_13) > 0 && !isdigit((int) VAR_13[0])) {\n\t\t/* COMMENT_3 */\n\t\tif (VAR_2 == 0) {\n\t\t\tVAR_11 = VAR_48;\n\t\t} else {\n\t\t\tVAR_11 = VAR_2;\n\t\t}\n\t\t/* COMMENT_4 */\n                                               \n                     \n                                               \n     \n\t\tVAR_14 = ldns_get_rr_class_by_name(VAR_13);\n\t\t/* COMMENT_9 */\n                       \n     \n\t\tif (VAR_14 == 0) {\n\t\t\tVAR_14 = VAR_49;\n\t\t\tVAR_17 = strlen(VAR_13) + 1;\n\t\t\tVAR_16 = LDNS_XMALLOC(char, VAR_17);\n\t\t\tif (!VAR_16) {\n\t\t\t\tgoto memerror;\n\t\t\t}\n\t\t\tstrlcpy(VAR_16, VAR_13, VAR_17);\n\t\t}\n\t} else {\n\t\tif (-1 == ldns_bget_token(\n\t\t\t\tVAR_9, VAR_15, \"\\t\\n \", VAR_43)) {\n\n\t\t\tVAR_27 = VAR_50;\n\t\t\tgoto error;\n\t\t}\n\t\tVAR_14 = ldns_get_rr_class_by_name(VAR_15);\n\t\t/* COMMENT_12 */\n                       \n     \n\t\tif (VAR_14 == 0) {\n\t\t\tVAR_14 = VAR_49;\n\t\t\tVAR_17 = strlen(VAR_15) + 1;\n\t\t\tVAR_16 = LDNS_XMALLOC(char, VAR_17);\n\t\t\tif (!VAR_16) {\n\t\t\t\tgoto memerror;\n\t\t\t}\n\t\t\tstrlcpy(VAR_16, VAR_15, VAR_17);\n\t\t}\n\t}\n\t/* COMMENT_15 */\n\n\tif (!VAR_16) {\n\t\tVAR_16 = LDNS_XMALLOC(char, VAR_43);\n\t\tif (!VAR_16) {\n\t\t\tgoto memerror;\n\t\t}\n\t\tif (-1 == ldns_bget_token(\n\t\t\t\tVAR_9, VAR_16, \"\\t\\n \", VAR_43)) {\n\n\t\t\tVAR_27 = VAR_51;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (ldns_bget_token(VAR_9, VAR_18, \"\\0\", VAR_44) == -1) {\n\t\t/* COMMENT_16 */\n                                                  \n     \n\t}\n\tldns_buffer_new_frm_data(VAR_10, VAR_18, strlen(VAR_18));\n\n\tif (strlen(VAR_12) <= 1 && strncmp(VAR_12, \"@\", 1) == 0) {\n\t\tif (VAR_3) {\n\t\t\tldns_rr_set_owner(VAR_6, ldns_rdf_clone(VAR_3));\n\t\t} else if (VAR_4 && *VAR_4) {\n\t\t\tldns_rr_set_owner(VAR_6, ldns_rdf_clone(*VAR_4));\n\t\t} else {\n\t\t\t/* COMMENT_19 */\n\t\t\tldns_rr_set_owner(VAR_6, ldns_dname_new_frm_str(\".\"));\n\t\t}\n\n\t\t/* COMMENT_20 */\n\t\tif (VAR_4) {\n\t\t\tldns_rdf_deep_free(*VAR_4);\n\t\t\t*VAR_4 = ldns_rdf_clone(ldns_rr_owner(VAR_6));\n\t\t\tif (!*VAR_4) {\n\t\t\t\tgoto memerror;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (strlen(VAR_12) == 0) {\n\t\t\t/* COMMENT_21 */\n                                     \n\t\t\tif (VAR_4 && *VAR_4) {\n\t\t\t\tldns_rr_set_owner(VAR_6, ldns_rdf_clone(*VAR_4));\n\t\t\t} else if (VAR_3) {\n\t\t\t\tldns_rr_set_owner(VAR_6, ldns_rdf_clone(VAR_3));\n\t\t\t} else {\n\t\t\t\tldns_rr_set_owner(VAR_6,\n\t\t\t\t\t\tldns_dname_new_frm_str(\".\"));\n\t\t\t}\n\t\t\tif(!ldns_rr_owner(VAR_6)) {\n\t\t\t\tgoto memerror;\n\t\t\t}\n\t\t} else {\n\t\t\tVAR_24 = ldns_dname_new_frm_str(VAR_12);\n\t\t\tif (!VAR_24) {\n\t\t\t\tVAR_27 = VAR_46;\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tldns_rr_set_owner(VAR_6, VAR_24);\n\t\t\tif (!ldns_dname_str_absolute(VAR_12) && VAR_3) {\n\t\t\t\tif(ldns_dname_cat(ldns_rr_owner(VAR_6), VAR_3)\n\t\t\t\t\t\t!= VAR_28) {\n\n\t\t\t\t\tVAR_27 = VAR_46;\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (VAR_4) {\n\t\t\t\tldns_rdf_deep_free(*VAR_4);\n\t\t\t\t*VAR_4 = ldns_rdf_clone(ldns_rr_owner(VAR_6));\n\t\t\t\tif (!*VAR_4) {\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tLDNS_FREE(VAR_12);\n\n\tldns_rr_set_question(VAR_6, VAR_5);\n\n\tldns_rr_set_ttl(VAR_6, VAR_11);\n\tLDNS_FREE(VAR_13);\n\n\tldns_rr_set_class(VAR_6, VAR_14);\n\tLDNS_FREE(VAR_15);\n\n\tVAR_8 = ldns_get_rr_type_by_name(VAR_16);\n\tLDNS_FREE(VAR_16);\n\n\tVAR_7 = ldns_rr_descript((uint16_t)VAR_8);\n\tldns_rr_set_type(VAR_6, VAR_8);\n\tif (VAR_7) {\n\t\t/* COMMENT_23 */\n\t\tVAR_34 = ldns_rr_descriptor_maximum(VAR_7);\n\t\tVAR_33 = ldns_rr_descriptor_minimum(VAR_7);\n\t} else {\n\t\tVAR_33 = 0;\n\t\tVAR_34 = 1;\n\t}\n\n\tfor (VAR_29 = false, VAR_32 = 0; !VAR_29 && VAR_32 < VAR_34; VAR_32++) {\n\t\tVAR_30 = false;\n\n\t\tswitch (ldns_rr_descriptor_field_type(VAR_7, VAR_32)) {\n\t\tcase VAR_52        :\n\t\tcase VAR_53        : /* COMMENT_24 */\n\t\tcase VAR_54        : /* COMMENT_25 */\n\t\tcase VAR_55        : /* COMMENT_26 */\n\t\tcase VAR_56   :\n\t\tcase VAR_57   :\n\t\tcase VAR_58       :\tif (VAR_32 == VAR_34 - 1) {\n\t\t\t\t\t\t\tVAR_22 = \"\\n\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* COMMENT_27 */\n\t\tdefault                       :\tVAR_22 = \"\\n\\t \"; \n\t\t}\n\n\t\tif (ldns_rdf_type_maybe_quoted(\n\t\t\t\tldns_rr_descriptor_field_type(\n\t\t\t\tVAR_7, VAR_32)) &&\n\t\t\t\tldns_buffer_remaining(VAR_10) > 0){\n\n\t\t\t/* COMMENT_28 */\n\t\t\twhile (*(ldns_buffer_current(VAR_10)) == ' ') {\n\t\t\t\tldns_buffer_skip(VAR_10, 1);\n\t\t\t}\n\n\t\t\tif (*(ldns_buffer_current(VAR_10)) == '\\\"') {\n\t\t\t\tVAR_22 = \"\\\"\\0\";\n\t\t\t\tldns_buffer_skip(VAR_10, 1);\n\t\t\t\tVAR_30 = true;\n\t\t\t} else if (ldns_rr_descriptor_field_type(VAR_7, VAR_32)\n\t\t\t\t\t== VAR_59) {\n\n\t\t\t\tVAR_27 = VAR_60;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\n\t\t/* COMMENT_29 */\n                    \n     \n\n\t\t/* COMMENT_28 */\n\t\twhile (ldns_buffer_position(VAR_10) < ldns_buffer_limit(VAR_10)\n\t\t\t\t&& *(ldns_buffer_current(VAR_10)) == ' '\n\t\t\t\t&& !VAR_30) {\n\n\t\t\tldns_buffer_skip(VAR_10, 1);\n\t\t}\n\n\t\tVAR_35 = ldns_buffer_position(VAR_10);\n\t\tif (-1 == (VAR_23 = ldns_bget_token(\n\t\t\t\tVAR_10, VAR_19, VAR_22, VAR_45))) {\n\n\t\t\tVAR_29 = true;\n\t\t\t(void)VAR_29; /* COMMENT_32 */\n\t\t\tbreak;\n\t\t}\n\t\t/* COMMENT_33 */\n                                                \n                                   \n     \n\t\tVAR_21 = strlen(VAR_19);\n\n\t\t/* COMMENT_37 */\n\t\tif (strncmp(VAR_19, \"\\\\#\", 2) == 0 && !VAR_30 &&\n\t\t\t\t(VAR_21 == 2 || VAR_19[2]==' ')) {\n\n\t\t\tVAR_26 = 1;\n\t\t\t/* COMMENT_38 */\n                                                 \n      \n\t\t\tldns_buffer_set_position(VAR_10, VAR_35);\n\t\t\tVAR_22 = \"\\n\\t \";\n\t\t\t(void)ldns_bget_token(VAR_10, VAR_19,\n\t\t\t\t\tVAR_22, VAR_45);\n\t\t\t/* COMMENT_41 */\n\t\t\tVAR_23 = ldns_bget_token(VAR_10, VAR_19,\n\t\t\t\t\tVAR_22, VAR_45);\n\t\t\tif (VAR_23 == -1) {\n\t\t\t\t/* COMMENT_42 */\n\t\t\t\tVAR_27 = VAR_60;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tVAR_36 = (uint16_t) atoi(VAR_19);\n\t\t\t/* COMMENT_43 */\n\t\t\tVAR_37 = LDNS_XMALLOC(char, 2*VAR_36 + 1);\n\t\t\tif (!VAR_37) {\n\t\t\t\t/* COMMENT_44 */\n\t\t\t\tgoto memerror;\n\t\t\t}\n\t\t\tVAR_38 = 0;\n\t\t\twhile(VAR_38 < 2 * VAR_36) {\n\t\t\t\tVAR_23 = ldns_bget_token(VAR_10, VAR_19,\n\t\t\t\t\t\tVAR_22, VAR_45);\n\t\t\t\tif (VAR_23 == -1) {\n\t\t\t\t\tVAR_27 = VAR_60;\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tVAR_21 = strlen(VAR_19);\n\t\t\t\tif ((size_t)VAR_38 + VAR_21 >\n\t\t\t\t    2 * (size_t)VAR_36) {\n\t\t\t\t\tVAR_27 = VAR_60;\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tstrlcpy(VAR_37 + VAR_38, VAR_19,\n\t\t\t\t\t\tVAR_21 + 1);\n\n\t\t\t\tVAR_38 += VAR_21;\n\t\t\t}\n\t\t\tVAR_37[VAR_38] = '\\0';\n\n\t\t\t/* COMMENT_45 */\n\t\t\t/* COMMENT_46 */\n\t\t\tif (VAR_7) {\n\t\t\t\tVAR_39 = 0;\n\t\t\t\tVAR_40 =\n\t\t\t\t\tLDNS_XMALLOC(uint8_t, VAR_36+2);\n\n\t\t\t\tif (!VAR_40) {\n\t\t\t\t\tgoto memerror;\n\t\t\t\t}\n\t\t\t\tldns_write_uint16(VAR_40, VAR_36);\n\t\t\t\tldns_hexstring_to_data(\n\t\t\t\t\t\tVAR_40 + 2, VAR_37);\n\t\t\t\tVAR_27 = ldns_wire2rdf(VAR_6, VAR_40,\n\t\t\t\t\t\tVAR_36 + 2, &VAR_39);\n\t\t\t\tif (VAR_27 != VAR_28) {\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tLDNS_FREE(VAR_40);\n\t\t\t} else {\n\t\t\t\tVAR_31 = ldns_rdf_new_frm_str(VAR_53,\n\t\t\t\t\t\tVAR_37);\n\t\t\t\tif (!VAR_31) {\n\t\t\t\t\tgoto memerror;\n\t\t\t\t}\n\t\t\t\tldns_rdf_set_type(VAR_31, VAR_61);\n\t\t\t\tif (!ldns_rr_push_rdf(VAR_6, VAR_31)) {\n\t\t\t\t\tgoto memerror;\n\t\t\t\t}\n\t\t\t}\n\t\t\tLDNS_FREE(VAR_37);\n\n\t\t} else if(VAR_21 > 0 || VAR_30) {\n\t\t\t/* COMMENT_47 */\n\t\t\tswitch(ldns_rr_descriptor_field_type(VAR_7, VAR_32)) {\n\n\t\t\tcase VAR_53:\n\t\t\tcase VAR_52:\n\t\t\t\t/* COMMENT_48 */\n                                               \n                                     \n       \n\t\t\t\tif (VAR_32 == VAR_34 - 1) {\n\t\t\t\t\tVAR_23 = ldns_bget_token(VAR_10, VAR_20,\n\t\t\t\t\t\t\t\"\\n\", VAR_45);\n\t\t\t\t\tif (VAR_23 != -1) {\n\t\t\t\t\t\t(void) strncat(VAR_19, VAR_20,\n\t\t\t\t\t\t\tVAR_45 -\n\t\t\t\t\t\t\tstrlen(VAR_19) - 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tVAR_31 = ldns_rdf_new_frm_str(\n\t\t\t\t\t\tldns_rr_descriptor_field_type(\n\t\t\t\t\t\t\tVAR_7, VAR_32), VAR_19);\n\t\t\t\tbreak;\n\n\t\t\tcase VAR_62:\n\t\t\t\t/* COMMENT_52 */\n                                                 \n                                              \n                                                 \n                                                \n      \n                                                  \n                                           \n       \n\t\t\t\tdo {\n\t\t\t\t\t/* COMMENT_61 */\n\t\t\t\t\tif (ldns_bget_token(VAR_10,\n\t\t\t\t\t\t\tVAR_20, VAR_22,\n\t\t\t\t\t\t\tVAR_45) == -1)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t(void) strncat(VAR_19, \" \",\n\t\t\t\t\t\t\tVAR_45 -\n\t\t\t\t\t\t\tstrlen(VAR_19) - 1);\n\t\t\t\t\t(void) strncat(VAR_19, VAR_20,\n\t\t\t\t\t\t\tVAR_45 -\n\t\t\t\t\t\t\tstrlen(VAR_19) - 1);\n\n\t\t\t\t\t/* COMMENT_62 */\n\t\t\t\t\tif (ldns_bget_token(VAR_10,\n\t\t\t\t\t\t\tVAR_20, VAR_22,\n\t\t\t\t\t\t\tVAR_45) == -1)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t(void) strncat(VAR_19, \" \",\n\t\t\t\t\t\t\tVAR_45 -\n\t\t\t\t\t\t\tstrlen(VAR_19) - 1);\n\t\t\t\t\t(void) strncat(VAR_19, VAR_20,\n\t\t\t\t\t\t\tVAR_45 -\n\t\t\t\t\t\t\tstrlen(VAR_19) - 1);\n\t\t\t\t} while (false);\n\n\t\t\t\tVAR_31 = ldns_rdf_new_frm_str(\n\t\t\t\t\t\tldns_rr_descriptor_field_type(\n\t\t\t\t\t\t\tVAR_7, VAR_32), VAR_19);\n\t\t\t\tbreak;\n\n\t\t\tcase VAR_63:\n\t\t\t\tVAR_31 = ldns_rdf_new_frm_str(\n\t\t\t\t\t\tldns_rr_descriptor_field_type(\n\t\t\t\t\t\t\tVAR_7, VAR_32), VAR_19);\n\n\t\t\t\t/* COMMENT_63 */\n                      \n       \n\t\t\t\tif (VAR_31 && ldns_rdf_size(VAR_31) > 1 &&\n\t\t\t\t\t\tldns_rdf_data(VAR_31)[0] == 1 &&\n\t\t\t\t\t\tldns_rdf_data(VAR_31)[1] == '@') {\n\n\t\t\t\t\tldns_rdf_deep_free(VAR_31);\n\n\t\t\t\t\tVAR_31 = VAR_3 ? ldns_rdf_clone(VAR_3)\n\n\t\t\t\t\t  : ( VAR_8 == VAR_64 ?\n\n\t\t\t\t\t      ldns_rdf_clone(\n\t\t\t\t\t\t      ldns_rr_owner(VAR_6))\n\n\t\t\t\t\t    : ldns_rdf_new_frm_str(\n\t\t\t\t\t\t    VAR_63, \".\")\n\t\t\t\t\t    );\n\n\t\t\t\t} else if (VAR_31 && VAR_21 >= 1 && VAR_3 &&\n\t\t\t\t\t\t!ldns_dname_str_absolute(VAR_19)) {\n\n\t\t\t\t\tVAR_27 = ldns_dname_cat(VAR_31, VAR_3);\n\t\t\t\t\tif (VAR_27 != VAR_28) {\n\t\t\t\t\t\tgoto error;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tVAR_31 = ldns_rdf_new_frm_str(\n\t\t\t\t\t\tldns_rr_descriptor_field_type(\n\t\t\t\t\t\t\tVAR_7, VAR_32), VAR_19);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!VAR_31) {\n\t\t\t\tVAR_27 = VAR_60;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tldns_rr_push_rdf(VAR_6, VAR_31);\n\t\t}\n\t\tif (VAR_30) {\n\t\t\tif (ldns_buffer_available(VAR_10, 1)) {\n\t\t\t\tldns_buffer_skip(VAR_10, 1);\n\t\t\t} else {\n\t\t\t\tVAR_29 = true;\n\t\t\t}\n\t\t}\n\n\t} /* COMMENT_66 */\n\tLDNS_FREE(VAR_19);\n\tLDNS_FREE(VAR_20);\n\tldns_buffer_free(VAR_9);\n\tLDNS_FREE(VAR_18);\n\tif (ldns_buffer_remaining(VAR_10) > 0) {\n\t\tldns_buffer_free(VAR_10);\n\t\tldns_rr_free(VAR_6);\n\t\treturn VAR_65;\n\t}\n\tldns_buffer_free(VAR_10);\n\n\tif (!VAR_5 && VAR_7 && !VAR_26 &&\n\t\t\tldns_rr_rd_count(VAR_6) < VAR_33) {\n\n\t\tldns_rr_free(VAR_6);\n\t\treturn VAR_66;\n\t}\n\n\tif (VAR_0) {\n\t\t*VAR_0 = VAR_6;\n\t} else {\n\t\t/* COMMENT_67 */\n\t\tldns_rr_free(VAR_6);\n\t}\n\treturn VAR_28;\n\nmemerror:\n\tVAR_27 = VAR_67;\nerror:\n\tif (VAR_10 && VAR_10->_data) {\n\t\tldns_buffer_free(VAR_10);\n\t} else {\n\t\tLDNS_FREE(VAR_10);\n\t}\n\tif (VAR_9 && VAR_9->_data) {\n\t\tldns_buffer_free(VAR_9);\n\t} else {\n\t\tLDNS_FREE(VAR_9);\n\t}\n\tLDNS_FREE(VAR_16);\n\tLDNS_FREE(VAR_12);\n\tLDNS_FREE(VAR_13);\n\tLDNS_FREE(VAR_15);\n\tLDNS_FREE(VAR_40);\n\tLDNS_FREE(VAR_37);\n\tLDNS_FREE(VAR_20);\n\tLDNS_FREE(VAR_19);\n\tLDNS_FREE(VAR_18);\n\tldns_rr_free(VAR_6);\n\treturn VAR_27;\n}",
  "func_graph_path_before": "NLnetLabs/ldns/15d96206996bea969fbc918eb0a4a346f514b9f3/rr.c/vul/before/0.json",
  "func": "static ldns_status\nldns_rr_new_frm_str_internal(ldns_rr **newrr, const char *str,\n\t\t\t\t\t\t\t uint32_t default_ttl, const ldns_rdf *origin,\n\t\t\t\t\t\t\t ldns_rdf **prev, bool question)\n{\n\tldns_rr *new;\n\tconst ldns_rr_descriptor *desc;\n\tldns_rr_type rr_type;\n\tldns_buffer *rr_buf = NULL;\n\tldns_buffer *rd_buf = NULL;\n\tuint32_t ttl_val;\n\tchar  *owner = NULL;\n\tchar  *ttl = NULL;\n\tldns_rr_class clas_val;\n\tchar  *clas = NULL;\n\tchar  *type = NULL;\n\tsize_t type_sz;\n\tchar  *rdata = NULL;\n\tchar  *rd = NULL;\n\tchar  *xtok = NULL; /* For RDF types with spaces (i.e. extra tokens) */\n\tsize_t rd_strlen;\n\tconst char *delimiters;\n\tssize_t c;\n\tldns_rdf *owner_dname;\n        const char* endptr;\n        int was_unknown_rr_format = 0;\n\tldns_status status = LDNS_STATUS_OK;\n\n\t/* used for types with unknown number of rdatas */\n\tbool done;\n\tbool quoted;\n\n\tldns_rdf *r = NULL;\n\tuint16_t r_cnt;\n\tuint16_t r_min;\n\tuint16_t r_max;\n        size_t pre_data_pos;\n\n\tuint16_t hex_data_size;\n\tchar *hex_data_str = NULL;\n\tuint16_t cur_hex_data_size;\n\tsize_t hex_pos = 0;\n\tuint8_t *hex_data = NULL;\n\n\tnew = ldns_rr_new();\n\n\towner = LDNS_XMALLOC(char, LDNS_MAX_DOMAINLEN + 1);\n\tttl = LDNS_XMALLOC(char, LDNS_TTL_DATALEN);\n\tclas = LDNS_XMALLOC(char, LDNS_SYNTAX_DATALEN);\n\trdata = LDNS_XMALLOC(char, LDNS_MAX_PACKETLEN + 1);\n\trr_buf = LDNS_MALLOC(ldns_buffer);\n\trd_buf = LDNS_MALLOC(ldns_buffer);\n\trd = LDNS_XMALLOC(char, LDNS_MAX_RDFLEN);\n\txtok = LDNS_XMALLOC(char, LDNS_MAX_RDFLEN);\n\tif (rr_buf) {\n\t\trr_buf->_data = NULL;\n\t}\n\tif (rd_buf) {\n\t\trd_buf->_data = NULL;\n\t}\n\tif (!new || !owner || !ttl || !clas || !rdata ||\n\t\t\t!rr_buf || !rd_buf || !rd || !xtok) {\n\n\t\tgoto memerror;\n\t}\n\n\tldns_buffer_new_frm_data(rr_buf, (char*)str, strlen(str));\n\n\t/* split the rr in its parts -1 signals trouble */\n\tif (ldns_bget_token(rr_buf, owner, \"\\t\\n \", LDNS_MAX_DOMAINLEN) == -1){\n\n\t\tstatus = LDNS_STATUS_SYNTAX_ERR;\n\t\tgoto error;\n\t}\n\n\tif (ldns_bget_token(rr_buf, ttl, \"\\t\\n \", LDNS_TTL_DATALEN) == -1) {\n\n\t\tstatus = LDNS_STATUS_SYNTAX_TTL_ERR;\n\t\tgoto error;\n\t}\n\tttl_val = (uint32_t) ldns_str2period(ttl, &endptr);\n\n\tif (strlen(ttl) > 0 && !isdigit((int) ttl[0])) {\n\t\t/* ah, it's not there or something */\n\t\tif (default_ttl == 0) {\n\t\t\tttl_val = LDNS_DEFAULT_TTL;\n\t\t} else {\n\t\t\tttl_val = default_ttl;\n\t\t}\n\t\t/* we not ASSUMING the TTL is missing and that\n\t\t * the rest of the RR is still there. That is\n\t\t * CLASS TYPE RDATA\n\t\t * so ttl value we read is actually the class\n\t\t */\n\t\tclas_val = ldns_get_rr_class_by_name(ttl);\n\t\t/* class can be left out too, assume IN, current\n\t\t * token must be type\n\t\t */\n\t\tif (clas_val == 0) {\n\t\t\tclas_val = LDNS_RR_CLASS_IN;\n\t\t\ttype_sz = strlen(ttl) + 1;\n\t\t\ttype = LDNS_XMALLOC(char, type_sz);\n\t\t\tif (!type) {\n\t\t\t\tgoto memerror;\n\t\t\t}\n\t\t\tstrlcpy(type, ttl, type_sz);\n\t\t}\n\t} else {\n\t\tif (-1 == ldns_bget_token(\n\t\t\t\trr_buf, clas, \"\\t\\n \", LDNS_SYNTAX_DATALEN)) {\n\n\t\t\tstatus = LDNS_STATUS_SYNTAX_CLASS_ERR;\n\t\t\tgoto error;\n\t\t}\n\t\tclas_val = ldns_get_rr_class_by_name(clas);\n\t\t/* class can be left out too, assume IN, current\n\t\t * token must be type\n\t\t */\n\t\tif (clas_val == 0) {\n\t\t\tclas_val = LDNS_RR_CLASS_IN;\n\t\t\ttype_sz = strlen(clas) + 1;\n\t\t\ttype = LDNS_XMALLOC(char, type_sz);\n\t\t\tif (!type) {\n\t\t\t\tgoto memerror;\n\t\t\t}\n\t\t\tstrlcpy(type, clas, type_sz);\n\t\t}\n\t}\n\t/* the rest should still be waiting for us */\n\n\tif (!type) {\n\t\ttype = LDNS_XMALLOC(char, LDNS_SYNTAX_DATALEN);\n\t\tif (!type) {\n\t\t\tgoto memerror;\n\t\t}\n\t\tif (-1 == ldns_bget_token(\n\t\t\t\trr_buf, type, \"\\t\\n \", LDNS_SYNTAX_DATALEN)) {\n\n\t\t\tstatus = LDNS_STATUS_SYNTAX_TYPE_ERR;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (ldns_bget_token(rr_buf, rdata, \"\\0\", LDNS_MAX_PACKETLEN) == -1) {\n\t\t/* apparently we are done, and it's only a question RR\n\t\t * so do not set status and go to ldnserror here\n\t\t */\n\t}\n\tldns_buffer_new_frm_data(rd_buf, rdata, strlen(rdata));\n\n\tif (strlen(owner) <= 1 && strncmp(owner, \"@\", 1) == 0) {\n\t\tif (origin) {\n\t\t\tldns_rr_set_owner(new, ldns_rdf_clone(origin));\n\t\t} else if (prev && *prev) {\n\t\t\tldns_rr_set_owner(new, ldns_rdf_clone(*prev));\n\t\t} else {\n\t\t\t/* default to root */\n\t\t\tldns_rr_set_owner(new, ldns_dname_new_frm_str(\".\"));\n\t\t}\n\n\t\t/* @ also overrides prev */\n\t\tif (prev) {\n\t\t\tldns_rdf_deep_free(*prev);\n\t\t\t*prev = ldns_rdf_clone(ldns_rr_owner(new));\n\t\t\tif (!*prev) {\n\t\t\t\tgoto memerror;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (strlen(owner) == 0) {\n\t\t\t/* no ownername was given, try prev, if that fails\n\t\t\t * origin, else default to root */\n\t\t\tif (prev && *prev) {\n\t\t\t\tldns_rr_set_owner(new, ldns_rdf_clone(*prev));\n\t\t\t} else if (origin) {\n\t\t\t\tldns_rr_set_owner(new, ldns_rdf_clone(origin));\n\t\t\t} else {\n\t\t\t\tldns_rr_set_owner(new,\n\t\t\t\t\t\tldns_dname_new_frm_str(\".\"));\n\t\t\t}\n\t\t\tif(!ldns_rr_owner(new)) {\n\t\t\t\tgoto memerror;\n\t\t\t}\n\t\t} else {\n\t\t\towner_dname = ldns_dname_new_frm_str(owner);\n\t\t\tif (!owner_dname) {\n\t\t\t\tstatus = LDNS_STATUS_SYNTAX_ERR;\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tldns_rr_set_owner(new, owner_dname);\n\t\t\tif (!ldns_dname_str_absolute(owner) && origin) {\n\t\t\t\tif(ldns_dname_cat(ldns_rr_owner(new), origin)\n\t\t\t\t\t\t!= LDNS_STATUS_OK) {\n\n\t\t\t\t\tstatus = LDNS_STATUS_SYNTAX_ERR;\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (prev) {\n\t\t\t\tldns_rdf_deep_free(*prev);\n\t\t\t\t*prev = ldns_rdf_clone(ldns_rr_owner(new));\n\t\t\t\tif (!*prev) {\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tLDNS_FREE(owner);\n\n\tldns_rr_set_question(new, question);\n\n\tldns_rr_set_ttl(new, ttl_val);\n\tLDNS_FREE(ttl);\n\n\tldns_rr_set_class(new, clas_val);\n\tLDNS_FREE(clas);\n\n\trr_type = ldns_get_rr_type_by_name(type);\n\tLDNS_FREE(type);\n\n\tdesc = ldns_rr_descript((uint16_t)rr_type);\n\tldns_rr_set_type(new, rr_type);\n\tif (desc) {\n\t\t/* only the rdata remains */\n\t\tr_max = ldns_rr_descriptor_maximum(desc);\n\t\tr_min = ldns_rr_descriptor_minimum(desc);\n\t} else {\n\t\tr_min = 0;\n\t\tr_max = 1;\n\t}\n\n\tfor (done = false, r_cnt = 0; !done && r_cnt < r_max; r_cnt++) {\n\t\tquoted = false;\n\n\t\tswitch (ldns_rr_descriptor_field_type(desc, r_cnt)) {\n\t\tcase LDNS_RDF_TYPE_B64        :\n\t\tcase LDNS_RDF_TYPE_HEX        : /* These rdf types may con- */\n\t\tcase LDNS_RDF_TYPE_LOC        : /* tain whitespace, only if */\n\t\tcase LDNS_RDF_TYPE_WKS        : /* it is the last rd field. */\n\t\tcase LDNS_RDF_TYPE_IPSECKEY   :\n\t\tcase LDNS_RDF_TYPE_AMTRELAY   :\n\t\tcase LDNS_RDF_TYPE_NSEC       :\tif (r_cnt == r_max - 1) {\n\t\t\t\t\t\t\tdelimiters = \"\\n\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* fallthrough */\n\t\tdefault                       :\tdelimiters = \"\\n\\t \"; \n\t\t}\n\n\t\tif (ldns_rdf_type_maybe_quoted(\n\t\t\t\tldns_rr_descriptor_field_type(\n\t\t\t\tdesc, r_cnt)) &&\n\t\t\t\tldns_buffer_remaining(rd_buf) > 0){\n\n\t\t\t/* skip spaces */\n\t\t\twhile (sldns_buffer_remaining(strbuf) > 0 &&\n\t\t\t\t*(ldns_buffer_current(rd_buf)) == ' ') {\n\t\t\t\tldns_buffer_skip(rd_buf, 1);\n\t\t\t}\n\n\t\t\tif (sldns_buffer_remaining(strbuf) > 0 &&\n\t\t\t\t*(ldns_buffer_current(rd_buf)) == '\\\"') {\n\t\t\t\tdelimiters = \"\\\"\\0\";\n\t\t\t\tldns_buffer_skip(rd_buf, 1);\n\t\t\t\tquoted = true;\n\t\t\t}\n\t\t\tif (!quoted && ldns_rr_descriptor_field_type(desc, r_cnt)\n\t\t\t\t\t== LDNS_RDF_TYPE_LONG_STR) {\n\n\t\t\t\tstatus = LDNS_STATUS_SYNTAX_RDATA_ERR;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\n\t\t/* because number of fields can be variable, we can't rely on\n\t\t * _maximum() only\n\t\t */\n\n\t\t/* skip spaces */\n\t\twhile (ldns_buffer_position(rd_buf) < ldns_buffer_limit(rd_buf)\n\t\t\t\t&& *(ldns_buffer_current(rd_buf)) == ' '\n\t\t\t\t&& !quoted) {\n\n\t\t\tldns_buffer_skip(rd_buf, 1);\n\t\t}\n\n\t\tpre_data_pos = ldns_buffer_position(rd_buf);\n\t\tif (-1 == (c = ldns_bget_token(\n\t\t\t\trd_buf, rd, delimiters, LDNS_MAX_RDFLEN))) {\n\n\t\t\tdone = true;\n\t\t\t(void)done; /* we're breaking, so done not read anymore */\n\t\t\tbreak;\n\t\t}\n\t\t/* hmmz, rfc3597 specifies that any type can be represented \n\t\t * with \\# method, which can contain spaces...\n\t\t * it does specify size though...\n\t\t */\n\t\trd_strlen = strlen(rd);\n\n\t\t/* unknown RR data */\n\t\tif (strncmp(rd, \"\\\\#\", 2) == 0 && !quoted &&\n\t\t\t\t(rd_strlen == 2 || rd[2]==' ')) {\n\n\t\t\twas_unknown_rr_format = 1;\n\t\t\t/* go back to before \\#\n\t\t\t * and skip it while setting delimiters better\n\t\t\t */\n\t\t\tldns_buffer_set_position(rd_buf, pre_data_pos);\n\t\t\tdelimiters = \"\\n\\t \";\n\t\t\t(void)ldns_bget_token(rd_buf, rd,\n\t\t\t\t\tdelimiters, LDNS_MAX_RDFLEN);\n\t\t\t/* read rdata octet length */\n\t\t\tc = ldns_bget_token(rd_buf, rd,\n\t\t\t\t\tdelimiters, LDNS_MAX_RDFLEN);\n\t\t\tif (c == -1) {\n\t\t\t\t/* something goes very wrong here */\n\t\t\t\tstatus = LDNS_STATUS_SYNTAX_RDATA_ERR;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\thex_data_size = (uint16_t) atoi(rd);\n\t\t\t/* copy hex chars into hex str (2 chars per byte) */\n\t\t\thex_data_str = LDNS_XMALLOC(char, 2*hex_data_size + 1);\n\t\t\tif (!hex_data_str) {\n\t\t\t\t/* malloc error */\n\t\t\t\tgoto memerror;\n\t\t\t}\n\t\t\tcur_hex_data_size = 0;\n\t\t\twhile(cur_hex_data_size < 2 * hex_data_size) {\n\t\t\t\tc = ldns_bget_token(rd_buf, rd,\n\t\t\t\t\t\tdelimiters, LDNS_MAX_RDFLEN);\n\t\t\t\tif (c == -1) {\n\t\t\t\t\tstatus = LDNS_STATUS_SYNTAX_RDATA_ERR;\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\trd_strlen = strlen(rd);\n\t\t\t\tif ((size_t)cur_hex_data_size + rd_strlen >\n\t\t\t\t    2 * (size_t)hex_data_size) {\n\t\t\t\t\tstatus = LDNS_STATUS_SYNTAX_RDATA_ERR;\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tstrlcpy(hex_data_str + cur_hex_data_size, rd,\n\t\t\t\t\t\trd_strlen + 1);\n\n\t\t\t\tcur_hex_data_size += rd_strlen;\n\t\t\t}\n\t\t\thex_data_str[cur_hex_data_size] = '\\0';\n\n\t\t\t/* correct the rdf type */\n\t\t\t/* if *we* know the type, interpret it as wireformat */\n\t\t\tif (desc) {\n\t\t\t\thex_pos = 0;\n\t\t\t\thex_data =\n\t\t\t\t\tLDNS_XMALLOC(uint8_t, hex_data_size+2);\n\n\t\t\t\tif (!hex_data) {\n\t\t\t\t\tgoto memerror;\n\t\t\t\t}\n\t\t\t\tldns_write_uint16(hex_data, hex_data_size);\n\t\t\t\tldns_hexstring_to_data(\n\t\t\t\t\t\thex_data + 2, hex_data_str);\n\t\t\t\tstatus = ldns_wire2rdf(new, hex_data,\n\t\t\t\t\t\thex_data_size + 2, &hex_pos);\n\t\t\t\tif (status != LDNS_STATUS_OK) {\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tLDNS_FREE(hex_data);\n\t\t\t} else {\n\t\t\t\tr = ldns_rdf_new_frm_str(LDNS_RDF_TYPE_HEX,\n\t\t\t\t\t\thex_data_str);\n\t\t\t\tif (!r) {\n\t\t\t\t\tgoto memerror;\n\t\t\t\t}\n\t\t\t\tldns_rdf_set_type(r, LDNS_RDF_TYPE_UNKNOWN);\n\t\t\t\tif (!ldns_rr_push_rdf(new, r)) {\n\t\t\t\t\tgoto memerror;\n\t\t\t\t}\n\t\t\t}\n\t\t\tLDNS_FREE(hex_data_str);\n\n\t\t} else if(rd_strlen > 0 || quoted) {\n\t\t\t/* Normal RR */\n\t\t\tswitch(ldns_rr_descriptor_field_type(desc, r_cnt)) {\n\n\t\t\tcase LDNS_RDF_TYPE_HEX:\n\t\t\tcase LDNS_RDF_TYPE_B64:\n\t\t\t\t/* When this is the last rdata field, then the\n\t\t\t\t * rest should be read in (cause then these\n\t\t\t\t * rdf types may contain spaces).\n\t\t\t\t */\n\t\t\t\tif (r_cnt == r_max - 1) {\n\t\t\t\t\tc = ldns_bget_token(rd_buf, xtok,\n\t\t\t\t\t\t\t\"\\n\", LDNS_MAX_RDFLEN);\n\t\t\t\t\tif (c != -1) {\n\t\t\t\t\t\t(void) strncat(rd, xtok,\n\t\t\t\t\t\t\tLDNS_MAX_RDFLEN -\n\t\t\t\t\t\t\tstrlen(rd) - 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr = ldns_rdf_new_frm_str(\n\t\t\t\t\t\tldns_rr_descriptor_field_type(\n\t\t\t\t\t\t\tdesc, r_cnt), rd);\n\t\t\t\tbreak;\n\n\t\t\tcase LDNS_RDF_TYPE_HIP:\n\t\t\t\t/*\n\t\t\t\t * In presentation format this RDATA type has\n\t\t\t\t * three tokens: An algorithm byte, then a\n\t\t\t\t * variable length HIT (in hexbytes) and then\n\t\t\t\t * a variable length Public Key (in base64).\n\t\t\t\t *\n\t\t\t\t * We have just read the algorithm, so we need\n\t\t\t\t * two more tokens: HIT and Public Key.\n\t\t\t\t */\n\t\t\t\tdo {\n\t\t\t\t\t/* Read and append HIT */\n\t\t\t\t\tif (ldns_bget_token(rd_buf,\n\t\t\t\t\t\t\txtok, delimiters,\n\t\t\t\t\t\t\tLDNS_MAX_RDFLEN) == -1)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t(void) strncat(rd, \" \",\n\t\t\t\t\t\t\tLDNS_MAX_RDFLEN -\n\t\t\t\t\t\t\tstrlen(rd) - 1);\n\t\t\t\t\t(void) strncat(rd, xtok,\n\t\t\t\t\t\t\tLDNS_MAX_RDFLEN -\n\t\t\t\t\t\t\tstrlen(rd) - 1);\n\n\t\t\t\t\t/* Read and append Public Key*/\n\t\t\t\t\tif (ldns_bget_token(rd_buf,\n\t\t\t\t\t\t\txtok, delimiters,\n\t\t\t\t\t\t\tLDNS_MAX_RDFLEN) == -1)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t(void) strncat(rd, \" \",\n\t\t\t\t\t\t\tLDNS_MAX_RDFLEN -\n\t\t\t\t\t\t\tstrlen(rd) - 1);\n\t\t\t\t\t(void) strncat(rd, xtok,\n\t\t\t\t\t\t\tLDNS_MAX_RDFLEN -\n\t\t\t\t\t\t\tstrlen(rd) - 1);\n\t\t\t\t} while (false);\n\n\t\t\t\tr = ldns_rdf_new_frm_str(\n\t\t\t\t\t\tldns_rr_descriptor_field_type(\n\t\t\t\t\t\t\tdesc, r_cnt), rd);\n\t\t\t\tbreak;\n\n\t\t\tcase LDNS_RDF_TYPE_DNAME:\n\t\t\t\tr = ldns_rdf_new_frm_str(\n\t\t\t\t\t\tldns_rr_descriptor_field_type(\n\t\t\t\t\t\t\tdesc, r_cnt), rd);\n\n\t\t\t\t/* check if the origin should be used\n\t\t\t\t * or concatenated\n\t\t\t\t */\n\t\t\t\tif (r && ldns_rdf_size(r) > 1 &&\n\t\t\t\t\t\tldns_rdf_data(r)[0] == 1 &&\n\t\t\t\t\t\tldns_rdf_data(r)[1] == '@') {\n\n\t\t\t\t\tldns_rdf_deep_free(r);\n\n\t\t\t\t\tr = origin ? ldns_rdf_clone(origin)\n\n\t\t\t\t\t  : ( rr_type == LDNS_RR_TYPE_SOA ?\n\n\t\t\t\t\t      ldns_rdf_clone(\n\t\t\t\t\t\t      ldns_rr_owner(new))\n\n\t\t\t\t\t    : ldns_rdf_new_frm_str(\n\t\t\t\t\t\t    LDNS_RDF_TYPE_DNAME, \".\")\n\t\t\t\t\t    );\n\n\t\t\t\t} else if (r && rd_strlen >= 1 && origin &&\n\t\t\t\t\t\t!ldns_dname_str_absolute(rd)) {\n\n\t\t\t\t\tstatus = ldns_dname_cat(r, origin);\n\t\t\t\t\tif (status != LDNS_STATUS_OK) {\n\t\t\t\t\t\tgoto error;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tr = ldns_rdf_new_frm_str(\n\t\t\t\t\t\tldns_rr_descriptor_field_type(\n\t\t\t\t\t\t\tdesc, r_cnt), rd);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!r) {\n\t\t\t\tstatus = LDNS_STATUS_SYNTAX_RDATA_ERR;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tldns_rr_push_rdf(new, r);\n\t\t}\n\t\tif (quoted) {\n\t\t\tif (ldns_buffer_available(rd_buf, 1)) {\n\t\t\t\tldns_buffer_skip(rd_buf, 1);\n\t\t\t} else {\n\t\t\t\tdone = true;\n\t\t\t}\n\t\t}\n\n\t} /* for (done = false, r_cnt = 0; !done && r_cnt < r_max; r_cnt++) */\n\tLDNS_FREE(rd);\n\tLDNS_FREE(xtok);\n\tldns_buffer_free(rr_buf);\n\tLDNS_FREE(rdata);\n\tif (ldns_buffer_remaining(rd_buf) > 0) {\n\t\tldns_buffer_free(rd_buf);\n\t\tldns_rr_free(new);\n\t\treturn LDNS_STATUS_SYNTAX_SUPERFLUOUS_TEXT_ERR;\n\t}\n\tldns_buffer_free(rd_buf);\n\n\tif (!question && desc && !was_unknown_rr_format &&\n\t\t\tldns_rr_rd_count(new) < r_min) {\n\n\t\tldns_rr_free(new);\n\t\treturn LDNS_STATUS_SYNTAX_MISSING_VALUE_ERR;\n\t}\n\n\tif (newrr) {\n\t\t*newrr = new;\n\t} else {\n\t\t/* Maybe the caller just wanted to see if it would parse? */\n\t\tldns_rr_free(new);\n\t}\n\treturn LDNS_STATUS_OK;\n\nmemerror:\n\tstatus = LDNS_STATUS_MEM_ERR;\nerror:\n\tif (rd_buf && rd_buf->_data) {\n\t\tldns_buffer_free(rd_buf);\n\t} else {\n\t\tLDNS_FREE(rd_buf);\n\t}\n\tif (rr_buf && rr_buf->_data) {\n\t\tldns_buffer_free(rr_buf);\n\t} else {\n\t\tLDNS_FREE(rr_buf);\n\t}\n\tLDNS_FREE(type);\n\tLDNS_FREE(owner);\n\tLDNS_FREE(ttl);\n\tLDNS_FREE(clas);\n\tLDNS_FREE(hex_data);\n\tLDNS_FREE(hex_data_str);\n\tLDNS_FREE(xtok);\n\tLDNS_FREE(rd);\n\tLDNS_FREE(rdata);\n\tldns_rr_free(new);\n\treturn status;\n}",
  "abstract_func": "static ldns_status\nldns_rr_new_frm_str_internal(ldns_rr **VAR_0, const char *VAR_1,\n\t\t\t\t\t\t\t uint32_t VAR_2, const ldns_rdf *VAR_3,\n\t\t\t\t\t\t\t ldns_rdf **VAR_4, bool VAR_5)\n{\n\tldns_rr *VAR_6;\n\tconst ldns_rr_descriptor *VAR_7;\n\tldns_rr_type VAR_8;\n\tldns_buffer *VAR_9 = NULL;\n\tldns_buffer *VAR_10 = NULL;\n\tuint32_t VAR_11;\n\tchar  *VAR_12 = NULL;\n\tchar  *VAR_13 = NULL;\n\tldns_rr_class VAR_14;\n\tchar  *VAR_15 = NULL;\n\tchar  *VAR_16 = NULL;\n\tsize_t VAR_17;\n\tchar  *VAR_18 = NULL;\n\tchar  *VAR_19 = NULL;\n\tchar  *VAR_20 = NULL; /* COMMENT_0 */\n\tsize_t VAR_21;\n\tconst char *VAR_22;\n\tssize_t VAR_23;\n\tldns_rdf *VAR_24;\n        const char* VAR_25;\n        int VAR_26 = 0;\n\tldns_status VAR_27 = VAR_28;\n\n\t/* COMMENT_1 */\n\tbool VAR_29;\n\tbool VAR_30;\n\n\tldns_rdf *VAR_31 = NULL;\n\tuint16_t VAR_32;\n\tuint16_t VAR_33;\n\tuint16_t VAR_34;\n        size_t VAR_35;\n\n\tuint16_t VAR_36;\n\tchar *VAR_37 = NULL;\n\tuint16_t VAR_38;\n\tsize_t VAR_39 = 0;\n\tuint8_t *VAR_40 = NULL;\n\n\tVAR_6 = ldns_rr_new();\n\n\tVAR_12 = LDNS_XMALLOC(char, VAR_41 + 1);\n\tVAR_13 = LDNS_XMALLOC(char, VAR_42);\n\tVAR_15 = LDNS_XMALLOC(char, VAR_43);\n\tVAR_18 = LDNS_XMALLOC(char, VAR_44 + 1);\n\tVAR_9 = LDNS_MALLOC(ldns_buffer);\n\tVAR_10 = LDNS_MALLOC(ldns_buffer);\n\tVAR_19 = LDNS_XMALLOC(char, VAR_45);\n\tVAR_20 = LDNS_XMALLOC(char, VAR_45);\n\tif (VAR_9) {\n\t\tVAR_9->_data = NULL;\n\t}\n\tif (VAR_10) {\n\t\tVAR_10->_data = NULL;\n\t}\n\tif (!VAR_6 || !VAR_12 || !VAR_13 || !VAR_15 || !VAR_18 ||\n\t\t\t!VAR_9 || !VAR_10 || !VAR_19 || !VAR_20) {\n\n\t\tgoto memerror;\n\t}\n\n\tldns_buffer_new_frm_data(VAR_9, (char*)VAR_1, strlen(VAR_1));\n\n\t/* COMMENT_2 */\n\tif (ldns_bget_token(VAR_9, VAR_12, \"\\t\\n \", VAR_41) == -1){\n\n\t\tVAR_27 = VAR_46;\n\t\tgoto error;\n\t}\n\n\tif (ldns_bget_token(VAR_9, VAR_13, \"\\t\\n \", VAR_42) == -1) {\n\n\t\tVAR_27 = VAR_47;\n\t\tgoto error;\n\t}\n\tVAR_11 = (uint32_t) ldns_str2period(VAR_13, &VAR_25);\n\n\tif (strlen(VAR_13) > 0 && !isdigit((int) VAR_13[0])) {\n\t\t/* COMMENT_3 */\n\t\tif (VAR_2 == 0) {\n\t\t\tVAR_11 = VAR_48;\n\t\t} else {\n\t\t\tVAR_11 = VAR_2;\n\t\t}\n\t\t/* COMMENT_4 */\n                                               \n                     \n                                               \n     \n\t\tVAR_14 = ldns_get_rr_class_by_name(VAR_13);\n\t\t/* COMMENT_9 */\n                       \n     \n\t\tif (VAR_14 == 0) {\n\t\t\tVAR_14 = VAR_49;\n\t\t\tVAR_17 = strlen(VAR_13) + 1;\n\t\t\tVAR_16 = LDNS_XMALLOC(char, VAR_17);\n\t\t\tif (!VAR_16) {\n\t\t\t\tgoto memerror;\n\t\t\t}\n\t\t\tstrlcpy(VAR_16, VAR_13, VAR_17);\n\t\t}\n\t} else {\n\t\tif (-1 == ldns_bget_token(\n\t\t\t\tVAR_9, VAR_15, \"\\t\\n \", VAR_43)) {\n\n\t\t\tVAR_27 = VAR_50;\n\t\t\tgoto error;\n\t\t}\n\t\tVAR_14 = ldns_get_rr_class_by_name(VAR_15);\n\t\t/* COMMENT_12 */\n                       \n     \n\t\tif (VAR_14 == 0) {\n\t\t\tVAR_14 = VAR_49;\n\t\t\tVAR_17 = strlen(VAR_15) + 1;\n\t\t\tVAR_16 = LDNS_XMALLOC(char, VAR_17);\n\t\t\tif (!VAR_16) {\n\t\t\t\tgoto memerror;\n\t\t\t}\n\t\t\tstrlcpy(VAR_16, VAR_15, VAR_17);\n\t\t}\n\t}\n\t/* COMMENT_15 */\n\n\tif (!VAR_16) {\n\t\tVAR_16 = LDNS_XMALLOC(char, VAR_43);\n\t\tif (!VAR_16) {\n\t\t\tgoto memerror;\n\t\t}\n\t\tif (-1 == ldns_bget_token(\n\t\t\t\tVAR_9, VAR_16, \"\\t\\n \", VAR_43)) {\n\n\t\t\tVAR_27 = VAR_51;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (ldns_bget_token(VAR_9, VAR_18, \"\\0\", VAR_44) == -1) {\n\t\t/* COMMENT_16 */\n                                                  \n     \n\t}\n\tldns_buffer_new_frm_data(VAR_10, VAR_18, strlen(VAR_18));\n\n\tif (strlen(VAR_12) <= 1 && strncmp(VAR_12, \"@\", 1) == 0) {\n\t\tif (VAR_3) {\n\t\t\tldns_rr_set_owner(VAR_6, ldns_rdf_clone(VAR_3));\n\t\t} else if (VAR_4 && *VAR_4) {\n\t\t\tldns_rr_set_owner(VAR_6, ldns_rdf_clone(*VAR_4));\n\t\t} else {\n\t\t\t/* COMMENT_19 */\n\t\t\tldns_rr_set_owner(VAR_6, ldns_dname_new_frm_str(\".\"));\n\t\t}\n\n\t\t/* COMMENT_20 */\n\t\tif (VAR_4) {\n\t\t\tldns_rdf_deep_free(*VAR_4);\n\t\t\t*VAR_4 = ldns_rdf_clone(ldns_rr_owner(VAR_6));\n\t\t\tif (!*VAR_4) {\n\t\t\t\tgoto memerror;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (strlen(VAR_12) == 0) {\n\t\t\t/* COMMENT_21 */\n                                     \n\t\t\tif (VAR_4 && *VAR_4) {\n\t\t\t\tldns_rr_set_owner(VAR_6, ldns_rdf_clone(*VAR_4));\n\t\t\t} else if (VAR_3) {\n\t\t\t\tldns_rr_set_owner(VAR_6, ldns_rdf_clone(VAR_3));\n\t\t\t} else {\n\t\t\t\tldns_rr_set_owner(VAR_6,\n\t\t\t\t\t\tldns_dname_new_frm_str(\".\"));\n\t\t\t}\n\t\t\tif(!ldns_rr_owner(VAR_6)) {\n\t\t\t\tgoto memerror;\n\t\t\t}\n\t\t} else {\n\t\t\tVAR_24 = ldns_dname_new_frm_str(VAR_12);\n\t\t\tif (!VAR_24) {\n\t\t\t\tVAR_27 = VAR_46;\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tldns_rr_set_owner(VAR_6, VAR_24);\n\t\t\tif (!ldns_dname_str_absolute(VAR_12) && VAR_3) {\n\t\t\t\tif(ldns_dname_cat(ldns_rr_owner(VAR_6), VAR_3)\n\t\t\t\t\t\t!= VAR_28) {\n\n\t\t\t\t\tVAR_27 = VAR_46;\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (VAR_4) {\n\t\t\t\tldns_rdf_deep_free(*VAR_4);\n\t\t\t\t*VAR_4 = ldns_rdf_clone(ldns_rr_owner(VAR_6));\n\t\t\t\tif (!*VAR_4) {\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tLDNS_FREE(VAR_12);\n\n\tldns_rr_set_question(VAR_6, VAR_5);\n\n\tldns_rr_set_ttl(VAR_6, VAR_11);\n\tLDNS_FREE(VAR_13);\n\n\tldns_rr_set_class(VAR_6, VAR_14);\n\tLDNS_FREE(VAR_15);\n\n\tVAR_8 = ldns_get_rr_type_by_name(VAR_16);\n\tLDNS_FREE(VAR_16);\n\n\tVAR_7 = ldns_rr_descript((uint16_t)VAR_8);\n\tldns_rr_set_type(VAR_6, VAR_8);\n\tif (VAR_7) {\n\t\t/* COMMENT_23 */\n\t\tVAR_34 = ldns_rr_descriptor_maximum(VAR_7);\n\t\tVAR_33 = ldns_rr_descriptor_minimum(VAR_7);\n\t} else {\n\t\tVAR_33 = 0;\n\t\tVAR_34 = 1;\n\t}\n\n\tfor (VAR_29 = false, VAR_32 = 0; !VAR_29 && VAR_32 < VAR_34; VAR_32++) {\n\t\tVAR_30 = false;\n\n\t\tswitch (ldns_rr_descriptor_field_type(VAR_7, VAR_32)) {\n\t\tcase VAR_52        :\n\t\tcase VAR_53        : /* COMMENT_24 */\n\t\tcase VAR_54        : /* COMMENT_25 */\n\t\tcase VAR_55        : /* COMMENT_26 */\n\t\tcase VAR_56   :\n\t\tcase VAR_57   :\n\t\tcase VAR_58       :\tif (VAR_32 == VAR_34 - 1) {\n\t\t\t\t\t\t\tVAR_22 = \"\\n\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* COMMENT_27 */\n\t\tdefault                       :\tVAR_22 = \"\\n\\t \"; \n\t\t}\n\n\t\tif (ldns_rdf_type_maybe_quoted(\n\t\t\t\tldns_rr_descriptor_field_type(\n\t\t\t\tVAR_7, VAR_32)) &&\n\t\t\t\tldns_buffer_remaining(VAR_10) > 0){\n\n\t\t\t/* COMMENT_28 */\n\t\t\twhile (sldns_buffer_remaining(VAR_59) > 0 &&\n\t\t\t\t*(ldns_buffer_current(VAR_10)) == ' ') {\n\t\t\t\tldns_buffer_skip(VAR_10, 1);\n\t\t\t}\n\n\t\t\tif (sldns_buffer_remaining(VAR_59) > 0 &&\n\t\t\t\t*(ldns_buffer_current(VAR_10)) == '\\\"') {\n\t\t\t\tVAR_22 = \"\\\"\\0\";\n\t\t\t\tldns_buffer_skip(VAR_10, 1);\n\t\t\t\tVAR_30 = true;\n\t\t\t}\n\t\t\tif (!VAR_30 && ldns_rr_descriptor_field_type(VAR_7, VAR_32)\n\t\t\t\t\t== VAR_60) {\n\n\t\t\t\tVAR_27 = VAR_61;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\n\t\t/* COMMENT_29 */\n                    \n     \n\n\t\t/* COMMENT_28 */\n\t\twhile (ldns_buffer_position(VAR_10) < ldns_buffer_limit(VAR_10)\n\t\t\t\t&& *(ldns_buffer_current(VAR_10)) == ' '\n\t\t\t\t&& !VAR_30) {\n\n\t\t\tldns_buffer_skip(VAR_10, 1);\n\t\t}\n\n\t\tVAR_35 = ldns_buffer_position(VAR_10);\n\t\tif (-1 == (VAR_23 = ldns_bget_token(\n\t\t\t\tVAR_10, VAR_19, VAR_22, VAR_45))) {\n\n\t\t\tVAR_29 = true;\n\t\t\t(void)VAR_29; /* COMMENT_32 */\n\t\t\tbreak;\n\t\t}\n\t\t/* COMMENT_33 */\n                                                \n                                   \n     \n\t\tVAR_21 = strlen(VAR_19);\n\n\t\t/* COMMENT_37 */\n\t\tif (strncmp(VAR_19, \"\\\\#\", 2) == 0 && !VAR_30 &&\n\t\t\t\t(VAR_21 == 2 || VAR_19[2]==' ')) {\n\n\t\t\tVAR_26 = 1;\n\t\t\t/* COMMENT_38 */\n                                                 \n      \n\t\t\tldns_buffer_set_position(VAR_10, VAR_35);\n\t\t\tVAR_22 = \"\\n\\t \";\n\t\t\t(void)ldns_bget_token(VAR_10, VAR_19,\n\t\t\t\t\tVAR_22, VAR_45);\n\t\t\t/* COMMENT_41 */\n\t\t\tVAR_23 = ldns_bget_token(VAR_10, VAR_19,\n\t\t\t\t\tVAR_22, VAR_45);\n\t\t\tif (VAR_23 == -1) {\n\t\t\t\t/* COMMENT_42 */\n\t\t\t\tVAR_27 = VAR_61;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tVAR_36 = (uint16_t) atoi(VAR_19);\n\t\t\t/* COMMENT_43 */\n\t\t\tVAR_37 = LDNS_XMALLOC(char, 2*VAR_36 + 1);\n\t\t\tif (!VAR_37) {\n\t\t\t\t/* COMMENT_44 */\n\t\t\t\tgoto memerror;\n\t\t\t}\n\t\t\tVAR_38 = 0;\n\t\t\twhile(VAR_38 < 2 * VAR_36) {\n\t\t\t\tVAR_23 = ldns_bget_token(VAR_10, VAR_19,\n\t\t\t\t\t\tVAR_22, VAR_45);\n\t\t\t\tif (VAR_23 == -1) {\n\t\t\t\t\tVAR_27 = VAR_61;\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tVAR_21 = strlen(VAR_19);\n\t\t\t\tif ((size_t)VAR_38 + VAR_21 >\n\t\t\t\t    2 * (size_t)VAR_36) {\n\t\t\t\t\tVAR_27 = VAR_61;\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tstrlcpy(VAR_37 + VAR_38, VAR_19,\n\t\t\t\t\t\tVAR_21 + 1);\n\n\t\t\t\tVAR_38 += VAR_21;\n\t\t\t}\n\t\t\tVAR_37[VAR_38] = '\\0';\n\n\t\t\t/* COMMENT_45 */\n\t\t\t/* COMMENT_46 */\n\t\t\tif (VAR_7) {\n\t\t\t\tVAR_39 = 0;\n\t\t\t\tVAR_40 =\n\t\t\t\t\tLDNS_XMALLOC(uint8_t, VAR_36+2);\n\n\t\t\t\tif (!VAR_40) {\n\t\t\t\t\tgoto memerror;\n\t\t\t\t}\n\t\t\t\tldns_write_uint16(VAR_40, VAR_36);\n\t\t\t\tldns_hexstring_to_data(\n\t\t\t\t\t\tVAR_40 + 2, VAR_37);\n\t\t\t\tVAR_27 = ldns_wire2rdf(VAR_6, VAR_40,\n\t\t\t\t\t\tVAR_36 + 2, &VAR_39);\n\t\t\t\tif (VAR_27 != VAR_28) {\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tLDNS_FREE(VAR_40);\n\t\t\t} else {\n\t\t\t\tVAR_31 = ldns_rdf_new_frm_str(VAR_53,\n\t\t\t\t\t\tVAR_37);\n\t\t\t\tif (!VAR_31) {\n\t\t\t\t\tgoto memerror;\n\t\t\t\t}\n\t\t\t\tldns_rdf_set_type(VAR_31, VAR_62);\n\t\t\t\tif (!ldns_rr_push_rdf(VAR_6, VAR_31)) {\n\t\t\t\t\tgoto memerror;\n\t\t\t\t}\n\t\t\t}\n\t\t\tLDNS_FREE(VAR_37);\n\n\t\t} else if(VAR_21 > 0 || VAR_30) {\n\t\t\t/* COMMENT_47 */\n\t\t\tswitch(ldns_rr_descriptor_field_type(VAR_7, VAR_32)) {\n\n\t\t\tcase VAR_53:\n\t\t\tcase VAR_52:\n\t\t\t\t/* COMMENT_48 */\n                                               \n                                     \n       \n\t\t\t\tif (VAR_32 == VAR_34 - 1) {\n\t\t\t\t\tVAR_23 = ldns_bget_token(VAR_10, VAR_20,\n\t\t\t\t\t\t\t\"\\n\", VAR_45);\n\t\t\t\t\tif (VAR_23 != -1) {\n\t\t\t\t\t\t(void) strncat(VAR_19, VAR_20,\n\t\t\t\t\t\t\tVAR_45 -\n\t\t\t\t\t\t\tstrlen(VAR_19) - 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tVAR_31 = ldns_rdf_new_frm_str(\n\t\t\t\t\t\tldns_rr_descriptor_field_type(\n\t\t\t\t\t\t\tVAR_7, VAR_32), VAR_19);\n\t\t\t\tbreak;\n\n\t\t\tcase VAR_63:\n\t\t\t\t/* COMMENT_52 */\n                                                 \n                                              \n                                                 \n                                                \n      \n                                                  \n                                           \n       \n\t\t\t\tdo {\n\t\t\t\t\t/* COMMENT_61 */\n\t\t\t\t\tif (ldns_bget_token(VAR_10,\n\t\t\t\t\t\t\tVAR_20, VAR_22,\n\t\t\t\t\t\t\tVAR_45) == -1)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t(void) strncat(VAR_19, \" \",\n\t\t\t\t\t\t\tVAR_45 -\n\t\t\t\t\t\t\tstrlen(VAR_19) - 1);\n\t\t\t\t\t(void) strncat(VAR_19, VAR_20,\n\t\t\t\t\t\t\tVAR_45 -\n\t\t\t\t\t\t\tstrlen(VAR_19) - 1);\n\n\t\t\t\t\t/* COMMENT_62 */\n\t\t\t\t\tif (ldns_bget_token(VAR_10,\n\t\t\t\t\t\t\tVAR_20, VAR_22,\n\t\t\t\t\t\t\tVAR_45) == -1)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t(void) strncat(VAR_19, \" \",\n\t\t\t\t\t\t\tVAR_45 -\n\t\t\t\t\t\t\tstrlen(VAR_19) - 1);\n\t\t\t\t\t(void) strncat(VAR_19, VAR_20,\n\t\t\t\t\t\t\tVAR_45 -\n\t\t\t\t\t\t\tstrlen(VAR_19) - 1);\n\t\t\t\t} while (false);\n\n\t\t\t\tVAR_31 = ldns_rdf_new_frm_str(\n\t\t\t\t\t\tldns_rr_descriptor_field_type(\n\t\t\t\t\t\t\tVAR_7, VAR_32), VAR_19);\n\t\t\t\tbreak;\n\n\t\t\tcase VAR_64:\n\t\t\t\tVAR_31 = ldns_rdf_new_frm_str(\n\t\t\t\t\t\tldns_rr_descriptor_field_type(\n\t\t\t\t\t\t\tVAR_7, VAR_32), VAR_19);\n\n\t\t\t\t/* COMMENT_63 */\n                      \n       \n\t\t\t\tif (VAR_31 && ldns_rdf_size(VAR_31) > 1 &&\n\t\t\t\t\t\tldns_rdf_data(VAR_31)[0] == 1 &&\n\t\t\t\t\t\tldns_rdf_data(VAR_31)[1] == '@') {\n\n\t\t\t\t\tldns_rdf_deep_free(VAR_31);\n\n\t\t\t\t\tVAR_31 = VAR_3 ? ldns_rdf_clone(VAR_3)\n\n\t\t\t\t\t  : ( VAR_8 == VAR_65 ?\n\n\t\t\t\t\t      ldns_rdf_clone(\n\t\t\t\t\t\t      ldns_rr_owner(VAR_6))\n\n\t\t\t\t\t    : ldns_rdf_new_frm_str(\n\t\t\t\t\t\t    VAR_64, \".\")\n\t\t\t\t\t    );\n\n\t\t\t\t} else if (VAR_31 && VAR_21 >= 1 && VAR_3 &&\n\t\t\t\t\t\t!ldns_dname_str_absolute(VAR_19)) {\n\n\t\t\t\t\tVAR_27 = ldns_dname_cat(VAR_31, VAR_3);\n\t\t\t\t\tif (VAR_27 != VAR_28) {\n\t\t\t\t\t\tgoto error;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tVAR_31 = ldns_rdf_new_frm_str(\n\t\t\t\t\t\tldns_rr_descriptor_field_type(\n\t\t\t\t\t\t\tVAR_7, VAR_32), VAR_19);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!VAR_31) {\n\t\t\t\tVAR_27 = VAR_61;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tldns_rr_push_rdf(VAR_6, VAR_31);\n\t\t}\n\t\tif (VAR_30) {\n\t\t\tif (ldns_buffer_available(VAR_10, 1)) {\n\t\t\t\tldns_buffer_skip(VAR_10, 1);\n\t\t\t} else {\n\t\t\t\tVAR_29 = true;\n\t\t\t}\n\t\t}\n\n\t} /* COMMENT_66 */\n\tLDNS_FREE(VAR_19);\n\tLDNS_FREE(VAR_20);\n\tldns_buffer_free(VAR_9);\n\tLDNS_FREE(VAR_18);\n\tif (ldns_buffer_remaining(VAR_10) > 0) {\n\t\tldns_buffer_free(VAR_10);\n\t\tldns_rr_free(VAR_6);\n\t\treturn VAR_66;\n\t}\n\tldns_buffer_free(VAR_10);\n\n\tif (!VAR_5 && VAR_7 && !VAR_26 &&\n\t\t\tldns_rr_rd_count(VAR_6) < VAR_33) {\n\n\t\tldns_rr_free(VAR_6);\n\t\treturn VAR_67;\n\t}\n\n\tif (VAR_0) {\n\t\t*VAR_0 = VAR_6;\n\t} else {\n\t\t/* COMMENT_67 */\n\t\tldns_rr_free(VAR_6);\n\t}\n\treturn VAR_28;\n\nmemerror:\n\tVAR_27 = VAR_68;\nerror:\n\tif (VAR_10 && VAR_10->_data) {\n\t\tldns_buffer_free(VAR_10);\n\t} else {\n\t\tLDNS_FREE(VAR_10);\n\t}\n\tif (VAR_9 && VAR_9->_data) {\n\t\tldns_buffer_free(VAR_9);\n\t} else {\n\t\tLDNS_FREE(VAR_9);\n\t}\n\tLDNS_FREE(VAR_16);\n\tLDNS_FREE(VAR_12);\n\tLDNS_FREE(VAR_13);\n\tLDNS_FREE(VAR_15);\n\tLDNS_FREE(VAR_40);\n\tLDNS_FREE(VAR_37);\n\tLDNS_FREE(VAR_20);\n\tLDNS_FREE(VAR_19);\n\tLDNS_FREE(VAR_18);\n\tldns_rr_free(VAR_6);\n\treturn VAR_27;\n}",
  "func_graph_path": "NLnetLabs/ldns/15d96206996bea969fbc918eb0a4a346f514b9f3/rr.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -254,15 +254,18 @@\n \t\t\t\tldns_buffer_remaining(rd_buf) > 0){\n \n \t\t\t/* skip spaces */\n-\t\t\twhile (*(ldns_buffer_current(rd_buf)) == ' ') {\n+\t\t\twhile (sldns_buffer_remaining(strbuf) > 0 &&\n+\t\t\t\t*(ldns_buffer_current(rd_buf)) == ' ') {\n \t\t\t\tldns_buffer_skip(rd_buf, 1);\n \t\t\t}\n \n-\t\t\tif (*(ldns_buffer_current(rd_buf)) == '\\\"') {\n+\t\t\tif (sldns_buffer_remaining(strbuf) > 0 &&\n+\t\t\t\t*(ldns_buffer_current(rd_buf)) == '\\\"') {\n \t\t\t\tdelimiters = \"\\\"\\0\";\n \t\t\t\tldns_buffer_skip(rd_buf, 1);\n \t\t\t\tquoted = true;\n-\t\t\t} else if (ldns_rr_descriptor_field_type(desc, r_cnt)\n+\t\t\t}\n+\t\t\tif (!quoted && ldns_rr_descriptor_field_type(desc, r_cnt)\n \t\t\t\t\t== LDNS_RDF_TYPE_LONG_STR) {\n \n \t\t\t\tstatus = LDNS_STATUS_SYNTAX_RDATA_ERR;",
  "diff_line_info": {
    "deleted_lines": [
      "\t\t\twhile (*(ldns_buffer_current(rd_buf)) == ' ') {",
      "\t\t\tif (*(ldns_buffer_current(rd_buf)) == '\\\"') {",
      "\t\t\t} else if (ldns_rr_descriptor_field_type(desc, r_cnt)"
    ],
    "added_lines": [
      "\t\t\twhile (sldns_buffer_remaining(strbuf) > 0 &&",
      "\t\t\t\t*(ldns_buffer_current(rd_buf)) == ' ') {",
      "\t\t\tif (sldns_buffer_remaining(strbuf) > 0 &&",
      "\t\t\t\t*(ldns_buffer_current(rd_buf)) == '\\\"') {",
      "\t\t\t}",
      "\t\t\tif (!quoted && ldns_rr_descriptor_field_type(desc, r_cnt)"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/NLnetLabs/ldns/pull/144",
  "description": {
    "pr_info": {
      "title": "Prepare for 1.8.0 release",
      "number": 144
    },
    "comment": [
      "Release candidate for 1.8.0 release. @wcawijngaards, @TCY16 & @Philip-NLnetLabs can you review or approve if you already reviewed by following the commits? Thanks!"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9\n\nThe commit explicitly addresses a heap out-of-bound read vulnerability, and the code changes add necessary boundary checks to prevent such issues, confirming it's a security fix."
}