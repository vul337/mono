{
  "cve_id": "CVE-2014-9379",
  "cwe_ids": [
    "CWE-119"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "Ettercap/ettercap",
  "commit_msg": "Fix radius stack overflow",
  "commit_hash": "c2a3c99af956146570d7883e4b540b9d0c0a3c46",
  "git_url": "https://github.com/Ettercap/ettercap/commit/c2a3c99af956146570d7883e4b540b9d0c0a3c46",
  "file_path": "src/dissectors/ec_radius.c",
  "func_name": "radius_get_attribute",
  "func_before": "static u_char * radius_get_attribute(u_int8 attr, u_int16 *attr_len, u_char *begin, u_char *end)\n{\n   /* sanity check */\n   if (begin == NULL || end == NULL)\n      return NULL;\n\n   if (begin > end)\n      return NULL;\n\n   DEBUG_MSG(\"radius_get_attribute: [%d]\", attr);\n   \n   /* stop when the attribute list ends */\n   while (begin < end) {\n\n      /* get the len of the attribute and subtract the header len */\n      *attr_len = *(begin + 1) - 2;\n     \n      /* we have found our attribute */\n      if (*begin == attr) {\n         /* return the pointer to the attribute value */\n         return begin + 2;\n      }\n\n      /* move to the next attribute */\n      if (*(begin + 1) > 0)\n         begin += *(begin + 1);\n      else\n         return NULL;\n   }\n  \n   /* not found */\n   return NULL;\n}",
  "abstract_func_before": "static u_char * radius_get_attribute(u_int8 VAR_0, u_int16 *VAR_1, u_char *VAR_2, u_char *VAR_3)\n{\n   /* COMMENT_0 */\n   if (VAR_2 == NULL || VAR_3 == NULL)\n      return NULL;\n\n   if (VAR_2 > VAR_3)\n      return NULL;\n\n   DEBUG_MSG(\"radius_get_attribute: [%d]\", VAR_0);\n   \n   /* COMMENT_1 */\n   while (VAR_2 < VAR_3) {\n\n      /* COMMENT_2 */\n      *VAR_1 = *(VAR_2 + 1) - 2;\n     \n      /* COMMENT_3 */\n      if (*VAR_2 == VAR_0) {\n         /* COMMENT_4 */\n         return VAR_2 + 2;\n      }\n\n      /* COMMENT_5 */\n      if (*(VAR_2 + 1) > 0)\n         VAR_2 += *(VAR_2 + 1);\n      else\n         return NULL;\n   }\n  \n   /* COMMENT_6 */\n   return NULL;\n}",
  "func_graph_path_before": "Ettercap/ettercap/c2a3c99af956146570d7883e4b540b9d0c0a3c46/ec_radius.c/vul/before/0.json",
  "func": "static u_char * radius_get_attribute(u_int8 attr, u_int16 *attr_len, u_char *begin, u_char *end)\n{\n   /* sanity check */\n   if (begin == NULL || end == NULL)\n      return NULL;\n\n   if (begin > end)\n      return NULL;\n\n   DEBUG_MSG(\"radius_get_attribute: [%d]\", attr);\n   \n   /* stop when the attribute list ends */\n   while (begin < end) {\n\n      /* get the len of the attribute and subtract the header len */\n      *attr_len = (u_char)*(begin + 1) - 2;\n     \n      /* we have found our attribute */\n      if (*begin == attr) {\n         /* return the pointer to the attribute value */\n         return begin + 2;\n      }\n\n      /* move to the next attribute */\n      if (*(begin + 1) > 0)\n         begin += *(begin + 1);\n      else\n         return NULL;\n   }\n  \n   /* not found */\n   return NULL;\n}",
  "abstract_func": "static u_char * radius_get_attribute(u_int8 VAR_0, u_int16 *VAR_1, u_char *VAR_2, u_char *VAR_3)\n{\n   /* COMMENT_0 */\n   if (VAR_2 == NULL || VAR_3 == NULL)\n      return NULL;\n\n   if (VAR_2 > VAR_3)\n      return NULL;\n\n   DEBUG_MSG(\"radius_get_attribute: [%d]\", VAR_0);\n   \n   /* COMMENT_1 */\n   while (VAR_2 < VAR_3) {\n\n      /* COMMENT_2 */\n      *VAR_1 = (u_char)*(VAR_2 + 1) - 2;\n     \n      /* COMMENT_3 */\n      if (*VAR_2 == VAR_0) {\n         /* COMMENT_4 */\n         return VAR_2 + 2;\n      }\n\n      /* COMMENT_5 */\n      if (*(VAR_2 + 1) > 0)\n         VAR_2 += *(VAR_2 + 1);\n      else\n         return NULL;\n   }\n  \n   /* COMMENT_6 */\n   return NULL;\n}",
  "func_graph_path": "Ettercap/ettercap/c2a3c99af956146570d7883e4b540b9d0c0a3c46/ec_radius.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -13,7 +13,7 @@\n    while (begin < end) {\n \n       /* get the len of the attribute and subtract the header len */\n-      *attr_len = *(begin + 1) - 2;\n+      *attr_len = (u_char)*(begin + 1) - 2;\n      \n       /* we have found our attribute */\n       if (*begin == attr) {",
  "diff_line_info": {
    "deleted_lines": [
      "      *attr_len = *(begin + 1) - 2;"
    ],
    "added_lines": [
      "      *attr_len = (u_char)*(begin + 1) - 2;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/Ettercap/ettercap/pull/607",
  "description": {
    "pr_info": {
      "title": "Fix radius stack overflow",
      "number": 607
    },
    "comment": [
      "function radius_get_attribute pass by reference attr_len, which is used as length argument in strncpy. radius_get_attribute does a subtraction -2, which may have a negative result (0xffff-0xfffe for u_int16). This value will lead to stack corruption \n",
      "Hi @NickSampanis sorry for taking so long to look at them, but I'm worried about this one.\nI don't understand why we should use uint16 if the value won't be greater than uint8.\nCan you please clarify?\n\nIf 8 bits is enough I propose to change the attr_len variable type, otherwise I propose to add a length check instead of the cast.\n\n(maybe I'm looking at the wrong problem)\n",
      "It's ok, The cves will be published shortly and some denial of service exploits too :). This bug has to do with how the c language does mathematical calculations with non int data types. C language automatically casts non int datatypes to int in order to do arithmetic  calculations. So the statement \nattr_len = *(begin + 1) - 2\n\nif the next character of the begin pointer is equal to one the result will be 0xffffffff, but because attr_len is 2 bytes it could hold only 0xffff and thats why i used the cast. Now in all my patches i am trying to wipe out the security bug without modifying the code despite what i think on how efficient is the implementation. It would be better if attr_len type is uint8 but in order to do that you should modify dissector_radius function too\n",
      "Feel free to do that :D \n",
      "Merging in the meanwhile\n",
      "I did the change, Nick, can you please check\nhttps://github.com/Ettercap/ettercap/pull/635 ? thanks!\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9  \n\nThe patch addresses a buffer overflow issue leading to stack corruption, which is a security concern. The commit message and code changes clearly indicate efforts to resolve a vulnerability."
}