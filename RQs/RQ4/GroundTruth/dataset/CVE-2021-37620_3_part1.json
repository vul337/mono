{
  "cve_id": "CVE-2021-37620",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "Exiv2/exiv2",
  "commit_msg": "Safer std::vector indexing.",
  "commit_hash": "76e313745e813f80e8910aceb2210af3ad8cf897",
  "git_url": "https://github.com/Exiv2/exiv2/commit/76e313745e813f80e8910aceb2210af3ad8cf897",
  "file_path": "src/tiffvisitor_int.cpp",
  "func_name": "TiffDecoder::decodeCanonAFInfo",
  "func_before": "void TiffDecoder::decodeCanonAFInfo(const TiffEntryBase* object) {\n        // report Exif.Canon.AFInfo as usual\n        TiffDecoder::decodeStdTiffEntry(object);\n        if ( object->pValue()->count() < 3 || object->pValue()->typeId() != unsignedShort ) return; // insufficient data\n\n        // create vector of signedShorts from unsignedShorts in Exif.Canon.AFInfo\n        std::vector<int16_t>  ints;\n        std::vector<uint16_t> uint;\n        for (int i = 0; i < object->pValue()->count(); i++) {\n            ints.push_back((int16_t) object->pValue()->toLong(i));\n            uint.push_back((uint16_t) object->pValue()->toLong(i));\n        }\n        // Check this is AFInfo2 (ints[0] = bytes in object)\n        if ( ints[0] != object->pValue()->count()*2 ) return ;\n\n        std::string familyGroup(std::string(\"Exif.\") + groupName(object->group()) + \".\");\n\n        const uint16_t nPoints = uint.at(2);\n        const uint16_t nMasks  = (nPoints+15)/(sizeof(uint16_t) * 8);\n        int            nStart  = 0;\n\n        struct {\n            uint16_t tag    ;\n            uint16_t size   ;\n            bool     bSigned;\n        } records[] = {\n            { 0x2600 , 1       , true  }, // AFInfoSize\n            { 0x2601 , 1       , true  }, // AFAreaMode\n            { 0x2602 , 1       , true  }, // AFNumPoints\n            { 0x2603 , 1       , true  }, // AFValidPoints\n            { 0x2604 , 1       , true  }, // AFCanonImageWidth\n            { 0x2605 , 1       , true  }, // AFCanonImageHeight\n            { 0x2606 , 1       , true  }, // AFImageWidth\"\n            { 0x2607 , 1       , true  }, // AFImageHeight\n            { 0x2608 , nPoints , true  }, // AFAreaWidths\n            { 0x2609 , nPoints , true  }, // AFAreaHeights\n            { 0x260a , nPoints , true  }, // AFXPositions\n            { 0x260b , nPoints , true  }, // AFYPositions\n            { 0x260c , nMasks  , false }, // AFPointsInFocus\n            { 0x260d , nMasks  , false }, // AFPointsSelected\n            { 0x260e , nMasks  , false }, // AFPointsUnusable\n            { 0xffff , 0       , true  }  // end marker\n        };\n        // check we have enough data!\n        uint16_t count = 0;\n        for ( uint16_t i = 0; records[i].tag != 0xffff ; i++) count += records[i].size ;\n        if  ( count > ints.size() ) return ;\n\n        for ( uint16_t i = 0; records[i].tag != 0xffff ; i++) {\n            const TagInfo* pTags = ExifTags::tagList(\"Canon\") ;\n            const TagInfo* pTag  = findTag(pTags,records[i].tag);\n            if ( pTag ) {\n                Exiv2::Value::AutoPtr v = Exiv2::Value::create(records[i].bSigned?Exiv2::signedShort:Exiv2::unsignedShort);\n                std::ostringstream    s;\n                if ( records[i].bSigned ) {\n                    for ( int16_t k = 0 ; k < records[i].size ; k++ ) s << \" \" << ints.at(nStart++);\n                } else {\n                    for ( int16_t k = 0 ; k < records[i].size ; k++ ) s << \" \" << uint.at(nStart++);\n                }\n\n                v->read(s.str());\n                exifData_[familyGroup + pTag->name_] = *v;\n            }\n        }\n    }",
  "abstract_func_before": "void TiffDecoder::decodeCanonAFInfo(const TiffEntryBase* VAR_0) {\n        /* COMMENT_0 */\n        TiffDecoder::decodeStdTiffEntry(VAR_0);\n        if ( VAR_0->pValue()->count() < 3 || VAR_0->pValue()->typeId() != VAR_1 ) return; /* COMMENT_1 */\n\n        /* COMMENT_2 */\n        std::vector<int16_t>  VAR_2;\n        std::vector<uint16_t> VAR_3;\n        for (int VAR_4 = 0; VAR_4 < VAR_0->pValue()->count(); VAR_4++) {\n            VAR_2.push_back((int16_t) VAR_0->pValue()->toLong(VAR_4));\n            VAR_3.push_back((uint16_t) VAR_0->pValue()->toLong(VAR_4));\n        }\n        /* COMMENT_3 */\n        if ( VAR_2[0] != VAR_0->pValue()->count()*2 ) return ;\n\n        std::string VAR_5(std::string(\"Exif.\") + groupName(VAR_0->group()) + \".\");\n\n        const uint16_t VAR_6 = VAR_3.at(2);\n        const uint16_t VAR_7  = (VAR_6+15)/(sizeof(uint16_t) * 8);\n        int            VAR_8  = 0;\n\n        struct {\n            uint16_t tag    ;\n            uint16_t size   ;\n            bool     bSigned;\n        } VAR_9[] = {\n            { 0x2600 , 1       , true  }, /* COMMENT_4 */\n            { 0x2601 , 1       , true  }, /* COMMENT_5 */\n            { 0x2602 , 1       , true  }, /* COMMENT_6 */\n            { 0x2603 , 1       , true  }, /* COMMENT_7 */\n            { 0x2604 , 1       , true  }, /* COMMENT_8 */\n            { 0x2605 , 1       , true  }, /* COMMENT_9 */\n            { 0x2606 , 1       , true  }, /* COMMENT_10 */\n            { 0x2607 , 1       , true  }, /* COMMENT_11 */\n            { 0x2608 , VAR_6 , true  }, /* COMMENT_12 */\n            { 0x2609 , VAR_6 , true  }, /* COMMENT_13 */\n            { 0x260a , VAR_6 , true  }, /* COMMENT_14 */\n            { 0x260b , VAR_6 , true  }, /* COMMENT_15 */\n            { 0x260c , VAR_7  , false }, /* COMMENT_16 */\n            { 0x260d , VAR_7  , false }, /* COMMENT_17 */\n            { 0x260e , VAR_7  , false }, /* COMMENT_18 */\n            { 0xffff , 0       , true  }  /* COMMENT_19 */\n        };\n        /* COMMENT_20 */\n        uint16_t VAR_10 = 0;\n        for ( uint16_t VAR_4 = 0; VAR_9[VAR_4].tag != 0xffff ; VAR_4++) VAR_10 += VAR_9[VAR_4].size ;\n        if  ( VAR_10 > VAR_2.size() ) return ;\n\n        for ( uint16_t VAR_4 = 0; VAR_9[VAR_4].tag != 0xffff ; VAR_4++) {\n            const TagInfo* VAR_11 = ExifTags::tagList(\"Canon\") ;\n            const TagInfo* VAR_12  = findTag(VAR_11,VAR_9[VAR_4].tag);\n            if ( VAR_12 ) {\n                Exiv2::Value::AutoPtr VAR_13 = Exiv2::Value::create(VAR_9[VAR_4].bSigned?Exiv2::signedShort:Exiv2::unsignedShort);\n                std::ostringstream    VAR_14;\n                if ( VAR_9[VAR_4].bSigned ) {\n                    for ( int16_t VAR_15 = 0 ; VAR_15 < VAR_9[VAR_4].size ; VAR_15++ ) VAR_14 << \" \" << VAR_2.at(VAR_8++);\n                } else {\n                    for ( int16_t VAR_15 = 0 ; VAR_15 < VAR_9[VAR_4].size ; VAR_15++ ) VAR_14 << \" \" << VAR_3.at(VAR_8++);\n                }\n\n                VAR_13->read(VAR_14.str());\n                VAR_16[VAR_5 + VAR_12->name_] = *VAR_13;\n            }\n        }\n    }",
  "func_graph_path_before": "Exiv2/exiv2/76e313745e813f80e8910aceb2210af3ad8cf897/tiffvisitor_int.cpp/vul/before/0.json",
  "func": "void TiffDecoder::decodeCanonAFInfo(const TiffEntryBase* object) {\n        // report Exif.Canon.AFInfo as usual\n        TiffDecoder::decodeStdTiffEntry(object);\n        if ( object->pValue()->count() < 3 || object->pValue()->typeId() != unsignedShort ) return; // insufficient data\n\n        // create vector of signedShorts from unsignedShorts in Exif.Canon.AFInfo\n        std::vector<int16_t>  ints;\n        std::vector<uint16_t> uint;\n        for (int i = 0; i < object->pValue()->count(); i++) {\n            ints.push_back((int16_t) object->pValue()->toLong(i));\n            uint.push_back((uint16_t) object->pValue()->toLong(i));\n        }\n        // Check this is AFInfo2 (ints[0] = bytes in object)\n        if ( ints.at(0) != object->pValue()->count()*2 ) return ;\n\n        std::string familyGroup(std::string(\"Exif.\") + groupName(object->group()) + \".\");\n\n        const uint16_t nPoints = uint.at(2);\n        const uint16_t nMasks  = (nPoints+15)/(sizeof(uint16_t) * 8);\n        int            nStart  = 0;\n\n        struct {\n            uint16_t tag    ;\n            uint16_t size   ;\n            bool     bSigned;\n        } records[] = {\n            { 0x2600 , 1       , true  }, // AFInfoSize\n            { 0x2601 , 1       , true  }, // AFAreaMode\n            { 0x2602 , 1       , true  }, // AFNumPoints\n            { 0x2603 , 1       , true  }, // AFValidPoints\n            { 0x2604 , 1       , true  }, // AFCanonImageWidth\n            { 0x2605 , 1       , true  }, // AFCanonImageHeight\n            { 0x2606 , 1       , true  }, // AFImageWidth\"\n            { 0x2607 , 1       , true  }, // AFImageHeight\n            { 0x2608 , nPoints , true  }, // AFAreaWidths\n            { 0x2609 , nPoints , true  }, // AFAreaHeights\n            { 0x260a , nPoints , true  }, // AFXPositions\n            { 0x260b , nPoints , true  }, // AFYPositions\n            { 0x260c , nMasks  , false }, // AFPointsInFocus\n            { 0x260d , nMasks  , false }, // AFPointsSelected\n            { 0x260e , nMasks  , false }, // AFPointsUnusable\n            { 0xffff , 0       , true  }  // end marker\n        };\n        // check we have enough data!\n        uint16_t count = 0;\n        for ( uint16_t i = 0; records[i].tag != 0xffff ; i++) count += records[i].size ;\n        if  ( count > ints.size() ) return ;\n\n        for ( uint16_t i = 0; records[i].tag != 0xffff ; i++) {\n            const TagInfo* pTags = ExifTags::tagList(\"Canon\") ;\n            const TagInfo* pTag  = findTag(pTags,records[i].tag);\n            if ( pTag ) {\n                Exiv2::Value::AutoPtr v = Exiv2::Value::create(records[i].bSigned?Exiv2::signedShort:Exiv2::unsignedShort);\n                std::ostringstream    s;\n                if ( records[i].bSigned ) {\n                    for ( int16_t k = 0 ; k < records[i].size ; k++ ) s << \" \" << ints.at(nStart++);\n                } else {\n                    for ( int16_t k = 0 ; k < records[i].size ; k++ ) s << \" \" << uint.at(nStart++);\n                }\n\n                v->read(s.str());\n                exifData_[familyGroup + pTag->name_] = *v;\n            }\n        }\n    }",
  "abstract_func": "void TiffDecoder::decodeCanonAFInfo(const TiffEntryBase* VAR_0) {\n        /* COMMENT_0 */\n        TiffDecoder::decodeStdTiffEntry(VAR_0);\n        if ( VAR_0->pValue()->count() < 3 || VAR_0->pValue()->typeId() != VAR_1 ) return; /* COMMENT_1 */\n\n        /* COMMENT_2 */\n        std::vector<int16_t>  VAR_2;\n        std::vector<uint16_t> VAR_3;\n        for (int VAR_4 = 0; VAR_4 < VAR_0->pValue()->count(); VAR_4++) {\n            VAR_2.push_back((int16_t) VAR_0->pValue()->toLong(VAR_4));\n            VAR_3.push_back((uint16_t) VAR_0->pValue()->toLong(VAR_4));\n        }\n        /* COMMENT_3 */\n        if ( VAR_2.at(0) != VAR_0->pValue()->count()*2 ) return ;\n\n        std::string VAR_5(std::string(\"Exif.\") + groupName(VAR_0->group()) + \".\");\n\n        const uint16_t VAR_6 = VAR_3.at(2);\n        const uint16_t VAR_7  = (VAR_6+15)/(sizeof(uint16_t) * 8);\n        int            VAR_8  = 0;\n\n        struct {\n            uint16_t tag    ;\n            uint16_t size   ;\n            bool     bSigned;\n        } VAR_9[] = {\n            { 0x2600 , 1       , true  }, /* COMMENT_4 */\n            { 0x2601 , 1       , true  }, /* COMMENT_5 */\n            { 0x2602 , 1       , true  }, /* COMMENT_6 */\n            { 0x2603 , 1       , true  }, /* COMMENT_7 */\n            { 0x2604 , 1       , true  }, /* COMMENT_8 */\n            { 0x2605 , 1       , true  }, /* COMMENT_9 */\n            { 0x2606 , 1       , true  }, /* COMMENT_10 */\n            { 0x2607 , 1       , true  }, /* COMMENT_11 */\n            { 0x2608 , VAR_6 , true  }, /* COMMENT_12 */\n            { 0x2609 , VAR_6 , true  }, /* COMMENT_13 */\n            { 0x260a , VAR_6 , true  }, /* COMMENT_14 */\n            { 0x260b , VAR_6 , true  }, /* COMMENT_15 */\n            { 0x260c , VAR_7  , false }, /* COMMENT_16 */\n            { 0x260d , VAR_7  , false }, /* COMMENT_17 */\n            { 0x260e , VAR_7  , false }, /* COMMENT_18 */\n            { 0xffff , 0       , true  }  /* COMMENT_19 */\n        };\n        /* COMMENT_20 */\n        uint16_t VAR_10 = 0;\n        for ( uint16_t VAR_4 = 0; VAR_9[VAR_4].tag != 0xffff ; VAR_4++) VAR_10 += VAR_9[VAR_4].size ;\n        if  ( VAR_10 > VAR_2.size() ) return ;\n\n        for ( uint16_t VAR_4 = 0; VAR_9[VAR_4].tag != 0xffff ; VAR_4++) {\n            const TagInfo* VAR_11 = ExifTags::tagList(\"Canon\") ;\n            const TagInfo* VAR_12  = findTag(VAR_11,VAR_9[VAR_4].tag);\n            if ( VAR_12 ) {\n                Exiv2::Value::AutoPtr VAR_13 = Exiv2::Value::create(VAR_9[VAR_4].bSigned?Exiv2::signedShort:Exiv2::unsignedShort);\n                std::ostringstream    VAR_14;\n                if ( VAR_9[VAR_4].bSigned ) {\n                    for ( int16_t VAR_15 = 0 ; VAR_15 < VAR_9[VAR_4].size ; VAR_15++ ) VAR_14 << \" \" << VAR_2.at(VAR_8++);\n                } else {\n                    for ( int16_t VAR_15 = 0 ; VAR_15 < VAR_9[VAR_4].size ; VAR_15++ ) VAR_14 << \" \" << VAR_3.at(VAR_8++);\n                }\n\n                VAR_13->read(VAR_14.str());\n                VAR_16[VAR_5 + VAR_12->name_] = *VAR_13;\n            }\n        }\n    }",
  "func_graph_path": "Exiv2/exiv2/76e313745e813f80e8910aceb2210af3ad8cf897/tiffvisitor_int.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -11,7 +11,7 @@\n             uint.push_back((uint16_t) object->pValue()->toLong(i));\n         }\n         // Check this is AFInfo2 (ints[0] = bytes in object)\n-        if ( ints[0] != object->pValue()->count()*2 ) return ;\n+        if ( ints.at(0) != object->pValue()->count()*2 ) return ;\n \n         std::string familyGroup(std::string(\"Exif.\") + groupName(object->group()) + \".\");\n ",
  "diff_line_info": {
    "deleted_lines": [
      "        if ( ints[0] != object->pValue()->count()*2 ) return ;"
    ],
    "added_lines": [
      "        if ( ints.at(0) != object->pValue()->count()*2 ) return ;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/sridharb1/exiv2/pull/4",
  "description": {
    "pr_info": {
      "title": "0.27 maintenance",
      "number": 4
    },
    "comment": []
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.75,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.75"
}