{
  "cve_id": "CVE-2014-9748",
  "cwe_ids": [
    "CWE-362"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "nodejs/node",
  "commit_msg": "crypto: replace rwlocks with simple mutexes\n\nIt was pointed out by Zhou Ran that the Windows XP implementation of\nuv_rwlock_rdlock() and friends may unlock the inner write mutex on a\ndifferent thread than the one that locked it, resulting in undefined\nbehavior.\n\nThe only place that uses rwlocks is the crypto module.  Make that use\nnormal (simple) mutexes instead.\n\nOpenSSL's critical sections are generally very short, with exclusive\naccess outnumbering shared access by a factor of three or more, so\nit's not as if using rwlocks gives a decisive performance advantage.\n\nPR-URL: https://github.com/nodejs/node/pull/2723\nReviewed-By: Fedor Indutny <fedor@indutny.com>",
  "commit_hash": "7ee58bebff8074610d83bdf75ce01e9833b58a0e",
  "git_url": "https://github.com/nodejs/node/commit/7ee58bebff8074610d83bdf75ce01e9833b58a0e",
  "file_path": "src/node_crypto.cc",
  "func_name": "crypto_lock_init",
  "func_before": "static void crypto_lock_init(void) {\n  int i, n;\n\n  n = CRYPTO_num_locks();\n  locks = new uv_rwlock_t[n];\n\n  for (i = 0; i < n; i++)\n    if (uv_rwlock_init(locks + i))\n      abort();\n}",
  "abstract_func_before": "static void crypto_lock_init(void) {\n  int VAR_0, VAR_1;\n\n  VAR_1 = CRYPTO_num_locks();\n  VAR_2 = new uv_rwlock_t[VAR_1];\n\n  for (VAR_0 = 0; VAR_0 < VAR_1; VAR_0++)\n    if (uv_rwlock_init(VAR_2 + VAR_0))\n      abort();\n}",
  "func_graph_path_before": "nodejs/node/7ee58bebff8074610d83bdf75ce01e9833b58a0e/node_crypto.cc/vul/before/0.json",
  "func": "static void crypto_lock_init(void) {\n  int i, n;\n\n  n = CRYPTO_num_locks();\n  locks = new uv_mutex_t[n];\n\n  for (i = 0; i < n; i++)\n    if (uv_mutex_init(locks + i))\n      abort();\n}",
  "abstract_func": "static void crypto_lock_init(void) {\n  int VAR_0, VAR_1;\n\n  VAR_1 = CRYPTO_num_locks();\n  VAR_2 = new uv_mutex_t[VAR_1];\n\n  for (VAR_0 = 0; VAR_0 < VAR_1; VAR_0++)\n    if (uv_mutex_init(VAR_2 + VAR_0))\n      abort();\n}",
  "func_graph_path": "nodejs/node/7ee58bebff8074610d83bdf75ce01e9833b58a0e/node_crypto.cc/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -2,9 +2,9 @@\n   int i, n;\n \n   n = CRYPTO_num_locks();\n-  locks = new uv_rwlock_t[n];\n+  locks = new uv_mutex_t[n];\n \n   for (i = 0; i < n; i++)\n-    if (uv_rwlock_init(locks + i))\n+    if (uv_mutex_init(locks + i))\n       abort();\n }",
  "diff_line_info": {
    "deleted_lines": [
      "  locks = new uv_rwlock_t[n];",
      "    if (uv_rwlock_init(locks + i))"
    ],
    "added_lines": [
      "  locks = new uv_mutex_t[n];",
      "    if (uv_mutex_init(locks + i))"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/nodejs/node/pull/2723",
  "description": {
    "pr_info": {
      "title": "crypto: replace rwlocks with simple mutexes",
      "number": 2723
    },
    "comment": [
      "It was pointed out by Zhou Ran that the Windows XP implementation of\nuv_rwlock_rdlock() and friends may unlock the inner write mutex on a\ndifferent thread than the one that locked it, resulting in undefined\nbehavior.\n\nThe only place that uses rwlocks is the crypto module.  Make that use\nnormal (simple) mutexes instead.\n\nR=@indutny\n\n/cc @misterdjules This should be back-ported to v0.10 and v0.12.  I think it applies cleanly.\n\nCI: https://ci.nodejs.org/job/node-test-pull-request/260/\n",
      "/cc @nodejs/lts for backporting :)\n",
      "Maybe we should fix the libuv instead? This thing will make threaded uses of OpenSSL block in the mutexes more than they are now. Is OpenSSL using read/write at all?\n",
      "I don't think this is going to get fixed in libuv anytime soon.  https://github.com/libuv/libuv/issues/515 has a description of when it happens and it's probably hard to fix without breaking ABI.\n\nI'm not that worried about increased contention.  OpenSSL does break down access in read and write sections but sections are always very short and very write heavy: exclusive access outnumbers shared access by a factor of 3 or more (established by instrumenting openssl.)  That's not the kind of workload where r/w locks help much.\n",
      "LGTM, thank you!\n",
      "Tagged with `land-on-v0.12` and `land-on-v0.10` .. I should wire something up to keep us accountable to those labels eh?\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.9"
}