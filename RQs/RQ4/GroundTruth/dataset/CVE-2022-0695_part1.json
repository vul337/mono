{
  "cve_id": "CVE-2022-0695",
  "cwe_ids": [
    "CWE-400"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "radareorg/radare2",
  "commit_msg": "Fix DoS in PE/QNX/DYLDCACHE/PSX parsers ##crash\n\n* Reported by lazymio\n* Reproducer: AAA4AAAAAB4=",
  "commit_hash": "634b886e84a5c568d243e744becc6b3223e089cf",
  "git_url": "https://github.com/radareorg/radare2/commit/634b886e84a5c568d243e744becc6b3223e089cf",
  "file_path": "libr/bin/p/bin_dyldcache.c",
  "func_name": "estimate_slide",
  "func_before": "static ut64 estimate_slide(RBinFile *bf, RDyldCache *cache, ut64 value_mask, ut64 value_add) {\n\tut64 slide = 0;\n\tif (cache->n_hdr > 1) {\n\t\treturn slide;\n\t}\n\tut64 *classlist = malloc (64);\n\tif (!classlist) {\n\t\tgoto beach;\n\t}\n\n\tRListIter *iter;\n\tRDyldBinImage *bin;\n\tr_list_foreach (cache->bins, iter, bin) {\n\t\tbool found_sample = false;\n\n\t\tstruct MACH0_(opts_t) opts = {0};\n\t\topts.verbose = bf->rbin->verbose;\n\t\topts.header_at = bin->header_at;\n\t\topts.symbols_off = 0;\n\n\t\tstruct MACH0_(obj_t) *mach0 = MACH0_(new_buf) (cache->buf, &opts);\n\t\tif (!mach0) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tstruct section_t *sections = NULL;\n\t\tif (!(sections = MACH0_(get_sections) (mach0))) {\n\t\t\tMACH0_(mach0_free) (mach0);\n\t\t\tgoto beach;\n\t\t}\n\n\t\tint i;\n\t\tint incomplete = 2;\n\t\tint classlist_idx = 0, data_idx = 0;\n\t\tfor (i = 0; !sections[i].last && incomplete; i++) {\n\t\t\tif (sections[i].size == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (strstr (sections[i].name, \"__objc_classlist\")) {\n\t\t\t\tincomplete--;\n\t\t\t\tclasslist_idx = i;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (strstr (sections[i].name, \"__objc_data\")) {\n\t\t\t\tincomplete--;\n\t\t\t\tdata_idx = i;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (incomplete) {\n\t\t\tgoto next_bin;\n\t\t}\n\n\t\tint classlist_sample_size = R_MIN (64, sections[classlist_idx].size);\n\t\tint n_classes = classlist_sample_size / 8;\n\t\tut64 sect_offset = sections[classlist_idx].offset + bin->hdr_offset;\n\n\t\tif (r_buf_fread_at (cache->buf, sect_offset, (ut8*) classlist, \"l\", n_classes) < classlist_sample_size) {\n\t\t\tgoto next_bin;\n\t\t}\n\n\t\tut64 data_addr = sections[data_idx].addr;\n\t\tut64 data_tail = data_addr & 0xfff;\n\t\tut64 data_tail_end = (data_addr + sections[data_idx].size) & 0xfff;\n\t\tfor (i = 0; i < n_classes; i++) {\n\t\t\tut64 cl_addr = (classlist[i] & value_mask) + value_add;\n\t\t\tut64 cl_tail = cl_addr & 0xfff;\n\t\t\tif (cl_tail >= data_tail && cl_tail < data_tail_end) {\n\t\t\t\tut64 off = cl_tail - data_tail;\n\t\t\t\tslide = ((cl_addr - off) & value_mask) - (data_addr & value_mask);\n\t\t\t\tfound_sample = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\nnext_bin:\n\t\tMACH0_(mach0_free) (mach0);\n\t\tR_FREE (sections);\n\n\t\tif (found_sample) {\n\t\t\tbreak;\n\t\t}\n\t}\n\nbeach:\n\tR_FREE (classlist);\n\treturn slide;\n}",
  "abstract_func_before": "static ut64 estimate_slide(RBinFile *VAR_0, RDyldCache *VAR_1, ut64 VAR_2, ut64 VAR_3) {\n\tut64 VAR_4 = 0;\n\tif (VAR_1->n_hdr > 1) {\n\t\treturn VAR_4;\n\t}\n\tut64 *VAR_5 = malloc (64);\n\tif (!VAR_5) {\n\t\tgoto beach;\n\t}\n\n\tRListIter *VAR_6;\n\tRDyldBinImage *VAR_7;\n\tr_list_foreach (VAR_1->bins, VAR_6, VAR_7) {\n\t\tbool VAR_8 = false;\n\n\t\tstruct MACH0_(VAR_9) VAR_10 = {0};\n\t\tVAR_10.verbose = VAR_0->rbin->verbose;\n\t\tVAR_10.header_at = VAR_7->header_at;\n\t\tVAR_10.symbols_off = 0;\n\n\t\tstruct MACH0_(VAR_11) *VAR_12 = MACH0_(VAR_13) (VAR_1->buf, &VAR_10);\n\t\tif (!VAR_12) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tstruct section_t *VAR_14 = NULL;\n\t\tif (!(VAR_14 = MACH0_(VAR_15) (VAR_12))) {\n\t\t\tMACH0_(VAR_16) (VAR_12);\n\t\t\tgoto beach;\n\t\t}\n\n\t\tint VAR_17;\n\t\tint VAR_18 = 2;\n\t\tint VAR_19 = 0, VAR_20 = 0;\n\t\tfor (VAR_17 = 0; !VAR_14[VAR_17].last && VAR_18; VAR_17++) {\n\t\t\tif (VAR_14[VAR_17].size == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (strstr (VAR_14[VAR_17].name, \"__objc_classlist\")) {\n\t\t\t\tVAR_18--;\n\t\t\t\tVAR_19 = VAR_17;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (strstr (VAR_14[VAR_17].name, \"__objc_data\")) {\n\t\t\t\tVAR_18--;\n\t\t\t\tVAR_20 = VAR_17;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (VAR_18) {\n\t\t\tgoto next_bin;\n\t\t}\n\n\t\tint VAR_21 = R_MIN (64, VAR_14[VAR_19].size);\n\t\tint VAR_22 = VAR_21 / 8;\n\t\tut64 VAR_23 = VAR_14[VAR_19].offset + VAR_7->hdr_offset;\n\n\t\tif (r_buf_fread_at (VAR_1->buf, VAR_23, (ut8*) VAR_5, \"l\", VAR_22) < VAR_21) {\n\t\t\tgoto next_bin;\n\t\t}\n\n\t\tut64 VAR_24 = VAR_14[VAR_20].addr;\n\t\tut64 VAR_25 = VAR_24 & 0xfff;\n\t\tut64 VAR_26 = (VAR_24 + VAR_14[VAR_20].size) & 0xfff;\n\t\tfor (VAR_17 = 0; VAR_17 < VAR_22; VAR_17++) {\n\t\t\tut64 VAR_27 = (VAR_5[VAR_17] & VAR_2) + VAR_3;\n\t\t\tut64 VAR_28 = VAR_27 & 0xfff;\n\t\t\tif (VAR_28 >= VAR_25 && VAR_28 < VAR_26) {\n\t\t\t\tut64 VAR_29 = VAR_28 - VAR_25;\n\t\t\t\tVAR_4 = ((VAR_27 - VAR_29) & VAR_2) - (VAR_24 & VAR_2);\n\t\t\t\tVAR_8 = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\nnext_bin:\n\t\tMACH0_(VAR_16) (VAR_12);\n\t\tR_FREE (VAR_14);\n\n\t\tif (VAR_8) {\n\t\t\tbreak;\n\t\t}\n\t}\n\nbeach:\n\tR_FREE (VAR_5);\n\treturn VAR_4;\n}",
  "func_graph_path_before": "radareorg/radare2/634b886e84a5c568d243e744becc6b3223e089cf/bin_dyldcache.c/vul/before/0.json",
  "func": "static ut64 estimate_slide(RBinFile *bf, RDyldCache *cache, ut64 value_mask, ut64 value_add) {\n\tut64 slide = 0;\n\tif (cache->n_hdr > 1) {\n\t\treturn slide;\n\t}\n\tut64 *classlist = malloc (64);\n\tif (!classlist) {\n\t\tgoto beach;\n\t}\n\n\tRListIter *iter;\n\tRDyldBinImage *bin;\n\tr_list_foreach (cache->bins, iter, bin) {\n\t\tbool found_sample = false;\n\n\t\tstruct MACH0_(opts_t) opts = {0};\n\t\topts.verbose = bf->rbin->verbose;\n\t\topts.header_at = bin->header_at;\n\t\topts.symbols_off = 0;\n\n\t\tstruct MACH0_(obj_t) *mach0 = MACH0_(new_buf) (cache->buf, &opts);\n\t\tif (!mach0) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tstruct section_t *sections = NULL;\n\t\tif (!(sections = MACH0_(get_sections) (mach0))) {\n\t\t\tMACH0_(mach0_free) (mach0);\n\t\t\tgoto beach;\n\t\t}\n\n\t\tint i;\n\t\tint incomplete = 2;\n\t\tint classlist_idx = 0, data_idx = 0;\n\t\tfor (i = 0; !sections[i].last && incomplete; i++) {\n\t\t\tif (sections[i].size == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (strstr (sections[i].name, \"__objc_classlist\")) {\n\t\t\t\tincomplete--;\n\t\t\t\tclasslist_idx = i;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (strstr (sections[i].name, \"__objc_data\")) {\n\t\t\t\tincomplete--;\n\t\t\t\tdata_idx = i;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (incomplete) {\n\t\t\tgoto next_bin;\n\t\t}\n\n\t\tint classlist_sample_size = R_MIN (64, sections[classlist_idx].size);\n\t\tint n_classes = classlist_sample_size / 8;\n\t\tut64 sect_offset = sections[classlist_idx].offset + bin->hdr_offset;\n\n\t\tif (r_buf_fread_at (cache->buf, sect_offset, (ut8*) classlist, \"l\", n_classes) != classlist_sample_size) {\n\t\t\tgoto next_bin;\n\t\t}\n\n\t\tut64 data_addr = sections[data_idx].addr;\n\t\tut64 data_tail = data_addr & 0xfff;\n\t\tut64 data_tail_end = (data_addr + sections[data_idx].size) & 0xfff;\n\t\tfor (i = 0; i < n_classes; i++) {\n\t\t\tut64 cl_addr = (classlist[i] & value_mask) + value_add;\n\t\t\tut64 cl_tail = cl_addr & 0xfff;\n\t\t\tif (cl_tail >= data_tail && cl_tail < data_tail_end) {\n\t\t\t\tut64 off = cl_tail - data_tail;\n\t\t\t\tslide = ((cl_addr - off) & value_mask) - (data_addr & value_mask);\n\t\t\t\tfound_sample = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\nnext_bin:\n\t\tMACH0_(mach0_free) (mach0);\n\t\tR_FREE (sections);\n\n\t\tif (found_sample) {\n\t\t\tbreak;\n\t\t}\n\t}\n\nbeach:\n\tR_FREE (classlist);\n\treturn slide;\n}",
  "abstract_func": "static ut64 estimate_slide(RBinFile *VAR_0, RDyldCache *VAR_1, ut64 VAR_2, ut64 VAR_3) {\n\tut64 VAR_4 = 0;\n\tif (VAR_1->n_hdr > 1) {\n\t\treturn VAR_4;\n\t}\n\tut64 *VAR_5 = malloc (64);\n\tif (!VAR_5) {\n\t\tgoto beach;\n\t}\n\n\tRListIter *VAR_6;\n\tRDyldBinImage *VAR_7;\n\tr_list_foreach (VAR_1->bins, VAR_6, VAR_7) {\n\t\tbool VAR_8 = false;\n\n\t\tstruct MACH0_(VAR_9) VAR_10 = {0};\n\t\tVAR_10.verbose = VAR_0->rbin->verbose;\n\t\tVAR_10.header_at = VAR_7->header_at;\n\t\tVAR_10.symbols_off = 0;\n\n\t\tstruct MACH0_(VAR_11) *VAR_12 = MACH0_(VAR_13) (VAR_1->buf, &VAR_10);\n\t\tif (!VAR_12) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tstruct section_t *VAR_14 = NULL;\n\t\tif (!(VAR_14 = MACH0_(VAR_15) (VAR_12))) {\n\t\t\tMACH0_(VAR_16) (VAR_12);\n\t\t\tgoto beach;\n\t\t}\n\n\t\tint VAR_17;\n\t\tint VAR_18 = 2;\n\t\tint VAR_19 = 0, VAR_20 = 0;\n\t\tfor (VAR_17 = 0; !VAR_14[VAR_17].last && VAR_18; VAR_17++) {\n\t\t\tif (VAR_14[VAR_17].size == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (strstr (VAR_14[VAR_17].name, \"__objc_classlist\")) {\n\t\t\t\tVAR_18--;\n\t\t\t\tVAR_19 = VAR_17;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (strstr (VAR_14[VAR_17].name, \"__objc_data\")) {\n\t\t\t\tVAR_18--;\n\t\t\t\tVAR_20 = VAR_17;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (VAR_18) {\n\t\t\tgoto next_bin;\n\t\t}\n\n\t\tint VAR_21 = R_MIN (64, VAR_14[VAR_19].size);\n\t\tint VAR_22 = VAR_21 / 8;\n\t\tut64 VAR_23 = VAR_14[VAR_19].offset + VAR_7->hdr_offset;\n\n\t\tif (r_buf_fread_at (VAR_1->buf, VAR_23, (ut8*) VAR_5, \"l\", VAR_22) != VAR_21) {\n\t\t\tgoto next_bin;\n\t\t}\n\n\t\tut64 VAR_24 = VAR_14[VAR_20].addr;\n\t\tut64 VAR_25 = VAR_24 & 0xfff;\n\t\tut64 VAR_26 = (VAR_24 + VAR_14[VAR_20].size) & 0xfff;\n\t\tfor (VAR_17 = 0; VAR_17 < VAR_22; VAR_17++) {\n\t\t\tut64 VAR_27 = (VAR_5[VAR_17] & VAR_2) + VAR_3;\n\t\t\tut64 VAR_28 = VAR_27 & 0xfff;\n\t\t\tif (VAR_28 >= VAR_25 && VAR_28 < VAR_26) {\n\t\t\t\tut64 VAR_29 = VAR_28 - VAR_25;\n\t\t\t\tVAR_4 = ((VAR_27 - VAR_29) & VAR_2) - (VAR_24 & VAR_2);\n\t\t\t\tVAR_8 = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\nnext_bin:\n\t\tMACH0_(VAR_16) (VAR_12);\n\t\tR_FREE (VAR_14);\n\n\t\tif (VAR_8) {\n\t\t\tbreak;\n\t\t}\n\t}\n\nbeach:\n\tR_FREE (VAR_5);\n\treturn VAR_4;\n}",
  "func_graph_path": "radareorg/radare2/634b886e84a5c568d243e744becc6b3223e089cf/bin_dyldcache.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -56,7 +56,7 @@\n \t\tint n_classes = classlist_sample_size / 8;\n \t\tut64 sect_offset = sections[classlist_idx].offset + bin->hdr_offset;\n \n-\t\tif (r_buf_fread_at (cache->buf, sect_offset, (ut8*) classlist, \"l\", n_classes) < classlist_sample_size) {\n+\t\tif (r_buf_fread_at (cache->buf, sect_offset, (ut8*) classlist, \"l\", n_classes) != classlist_sample_size) {\n \t\t\tgoto next_bin;\n \t\t}\n ",
  "diff_line_info": {
    "deleted_lines": [
      "\t\tif (r_buf_fread_at (cache->buf, sect_offset, (ut8*) classlist, \"l\", n_classes) < classlist_sample_size) {"
    ],
    "added_lines": [
      "\t\tif (r_buf_fread_at (cache->buf, sect_offset, (ut8*) classlist, \"l\", n_classes) != classlist_sample_size) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/radareorg/radare2/pull/19747",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/radareorg/radare2/pull/19747: 403 Client Error: Forbidden for url: https://api.github.com/repos/radareorg/radare2/pulls/19747",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95  \n\nThe commit addresses a Denial of Service (DoS) vulnerability in specific parsers, adjusting a condition to prevent buffer issues that cause crashes. The commit message and code changes are consistent, clearly indicating a security fix with high confidence."
}