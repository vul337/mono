{
  "cve_id": "CVE-2021-39184",
  "cwe_ids": [
    "CWE-862"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:N/A:N",
  "cvss_is_v3": false,
  "repo_name": "electron",
  "commit_msg": "ScopedCOMInitializer",
  "commit_hash": "225a64a3bd6d2bda8dfdbb7a39324326f79eb9b2",
  "git_url": "https://github.com/electron/electron/commit/225a64a3bd6d2bda8dfdbb7a39324326f79eb9b2",
  "file_path": "shell/common/api/electron_api_native_image_win.cc",
  "func_name": "NativeImage::CreateThumbnailFromPath",
  "func_before": "v8::Local<v8::Promise> NativeImage::CreateThumbnailFromPath(\n    v8::Isolate* isolate,\n    const base::FilePath& path,\n    const gfx::Size& size) {\n  gin_helper::Promise<gfx::Image> promise(isolate);\n  v8::Local<v8::Promise> handle = promise.GetHandle();\n  HRESULT hr;\n\n  if (size.IsEmpty()) {\n    promise.RejectWithErrorMessage(\"size must not be empty\");\n    return handle;\n  }\n\n  // create an IShellItem\n  Microsoft::WRL::ComPtr<IShellItem> pItem;\n  std::wstring image_path = path.value();\n  hr = SHCreateItemFromParsingName(image_path.c_str(), nullptr,\n                                   IID_PPV_ARGS(&pItem));\n\n  if (FAILED(hr)) {\n    promise.RejectWithErrorMessage(\n        \"failed to create IShellItem from the given path\");\n    return handle;\n  }\n\n  // Init thumbnail cache\n  Microsoft::WRL::ComPtr<IThumbnailCache> pThumbnailCache;\n  hr = CoCreateInstance(CLSID_LocalThumbnailCache, nullptr, CLSCTX_INPROC,\n                        IID_PPV_ARGS(&pThumbnailCache));\n  if (FAILED(hr)) {\n    promise.RejectWithErrorMessage(\n        \"failed to acquire local thumbnail cache reference\");\n    return handle;\n  }\n\n  // Populate the IShellBitmap\n  Microsoft::WRL::ComPtr<ISharedBitmap> pThumbnail;\n  WTS_CACHEFLAGS flags;\n  WTS_THUMBNAILID thumbId;\n  hr = pThumbnailCache->GetThumbnail(pItem.Get(), size.width(),\n                                     WTS_FLAGS::WTS_NONE, &pThumbnail, &flags,\n                                     &thumbId);\n\n  if (FAILED(hr)) {\n    promise.RejectWithErrorMessage(\n        \"failed to get thumbnail from local thumbnail cache reference\");\n    return handle;\n  }\n\n  // Init HBITMAP\n  HBITMAP hBitmap = NULL;\n  hr = pThumbnail->GetSharedBitmap(&hBitmap);\n  if (FAILED(hr)) {\n    promise.RejectWithErrorMessage(\"failed to extract bitmap from thumbnail\");\n    return handle;\n  }\n\n  // convert HBITMAP to gfx::Image\n  BITMAP bitmap;\n  if (!GetObject(hBitmap, sizeof(bitmap), &bitmap)) {\n    promise.RejectWithErrorMessage(\"could not convert HBITMAP to BITMAP\");\n    return handle;\n  }\n\n  ICONINFO icon_info;\n  icon_info.fIcon = TRUE;\n  icon_info.hbmMask = hBitmap;\n  icon_info.hbmColor = hBitmap;\n\n  base::win::ScopedHICON icon(CreateIconIndirect(&icon_info));\n  SkBitmap skbitmap = IconUtil::CreateSkBitmapFromHICON(icon.get());\n  gfx::ImageSkia image_skia =\n      gfx::ImageSkia::CreateFromBitmap(skbitmap, 1.0 /*scale factor*/);\n  gfx::Image gfx_image = gfx::Image(image_skia);\n  promise.Resolve(gfx_image);\n  return handle;\n}",
  "abstract_func_before": "v8::Local<v8::Promise> NativeImage::CreateThumbnailFromPath(\n    v8::Isolate* VAR_0,\n    const base::FilePath& VAR_1,\n    const gfx::Size& VAR_2) {\n  gin_helper::Promise<gfx::Image> promise(isolate);\n  v8::Local<v8::Promise> VAR_3 = VAR_4.GetHandle();\n  HRESULT VAR_5;\n\n  if (VAR_2.IsEmpty()) {\n    VAR_4.RejectWithErrorMessage(\"size must not be empty\");\n    return VAR_3;\n  }\n\n  /* COMMENT_0 */\n  Microsoft::WRL::ComPtr<IShellItem> VAR_6;\n  std::wstring VAR_7 = VAR_1.value();\n  VAR_5 = SHCreateItemFromParsingName(VAR_7.c_str(), nullptr,\n                                   IID_PPV_ARGS(&VAR_6));\n\n  if (FAILED(VAR_5)) {\n    VAR_4.RejectWithErrorMessage(\n        \"failed to create IShellItem from the given path\");\n    return VAR_3;\n  }\n\n  /* COMMENT_1 */\n  Microsoft::WRL::ComPtr<IThumbnailCache> VAR_8;\n  VAR_5 = CoCreateInstance(VAR_9, nullptr, VAR_10,\n                        IID_PPV_ARGS(&VAR_8));\n  if (FAILED(VAR_5)) {\n    VAR_4.RejectWithErrorMessage(\n        \"failed to acquire local thumbnail cache reference\");\n    return VAR_3;\n  }\n\n  /* COMMENT_2 */\n  Microsoft::WRL::ComPtr<ISharedBitmap> VAR_11;\n  WTS_CACHEFLAGS VAR_12;\n  WTS_THUMBNAILID VAR_13;\n  VAR_5 = VAR_8->GetThumbnail(VAR_6.Get(), VAR_2.width(),\n                                     WTS_FLAGS::WTS_NONE, &VAR_11, &VAR_12,\n                                     &VAR_13);\n\n  if (FAILED(VAR_5)) {\n    VAR_4.RejectWithErrorMessage(\n        \"failed to get thumbnail from local thumbnail cache reference\");\n    return VAR_3;\n  }\n\n  /* COMMENT_3 */\n  HBITMAP VAR_14 = NULL;\n  VAR_5 = VAR_11->GetSharedBitmap(&VAR_14);\n  if (FAILED(VAR_5)) {\n    VAR_4.RejectWithErrorMessage(\"failed to extract bitmap from thumbnail\");\n    return VAR_3;\n  }\n\n  /* COMMENT_4 */\n  BITMAP VAR_15;\n  if (!GetObject(VAR_14, sizeof(VAR_15), &VAR_15)) {\n    VAR_4.RejectWithErrorMessage(\"could not convert HBITMAP to BITMAP\");\n    return VAR_3;\n  }\n\n  ICONINFO VAR_16;\n  VAR_16.fIcon = TRUE;\n  VAR_16.hbmMask = VAR_14;\n  VAR_16.hbmColor = VAR_14;\n\n  base::win::ScopedHICON VAR_17(CreateIconIndirect(&VAR_16));\n  SkBitmap VAR_18 = IconUtil::CreateSkBitmapFromHICON(VAR_17.get());\n  gfx::ImageSkia VAR_19 =\n      gfx::ImageSkia::CreateFromBitmap(VAR_18, 1.0 /* COMMENT_5 */);\n  gfx::Image VAR_20 = gfx::Image(VAR_19);\n  VAR_4.Resolve(VAR_20);\n  return VAR_3;\n}",
  "func_graph_path_before": "electron/225a64a3bd6d2bda8dfdbb7a39324326f79eb9b2/electron_api_native_image_win.cc/vul/before/0.json",
  "func": "v8::Local<v8::Promise> NativeImage::CreateThumbnailFromPath(\n    v8::Isolate* isolate,\n    const base::FilePath& path,\n    const gfx::Size& size) {\n  base::win::ScopedCOMInitializer scoped_com_initializer;\n\n  gin_helper::Promise<gfx::Image> promise(isolate);\n  v8::Local<v8::Promise> handle = promise.GetHandle();\n  HRESULT hr;\n\n  if (size.IsEmpty()) {\n    promise.RejectWithErrorMessage(\"size must not be empty\");\n    return handle;\n  }\n\n  // create an IShellItem\n  Microsoft::WRL::ComPtr<IShellItem> pItem;\n  std::wstring image_path = path.value();\n  hr = SHCreateItemFromParsingName(image_path.c_str(), nullptr,\n                                   IID_PPV_ARGS(&pItem));\n\n  if (FAILED(hr)) {\n    promise.RejectWithErrorMessage(\n        \"failed to create IShellItem from the given path\");\n    return handle;\n  }\n\n  // Init thumbnail cache\n  Microsoft::WRL::ComPtr<IThumbnailCache> pThumbnailCache;\n  hr = CoCreateInstance(CLSID_LocalThumbnailCache, nullptr, CLSCTX_INPROC,\n                        IID_PPV_ARGS(&pThumbnailCache));\n  if (FAILED(hr)) {\n    promise.RejectWithErrorMessage(\n        \"failed to acquire local thumbnail cache reference\");\n    return handle;\n  }\n\n  // Populate the IShellBitmap\n  Microsoft::WRL::ComPtr<ISharedBitmap> pThumbnail;\n  WTS_CACHEFLAGS flags;\n  WTS_THUMBNAILID thumbId;\n  hr = pThumbnailCache->GetThumbnail(pItem.Get(), size.width(),\n                                     WTS_FLAGS::WTS_NONE, &pThumbnail, &flags,\n                                     &thumbId);\n\n  if (FAILED(hr)) {\n    promise.RejectWithErrorMessage(\n        \"failed to get thumbnail from local thumbnail cache reference\");\n    return handle;\n  }\n\n  // Init HBITMAP\n  HBITMAP hBitmap = NULL;\n  hr = pThumbnail->GetSharedBitmap(&hBitmap);\n  if (FAILED(hr)) {\n    promise.RejectWithErrorMessage(\"failed to extract bitmap from thumbnail\");\n    return handle;\n  }\n\n  // convert HBITMAP to gfx::Image\n  BITMAP bitmap;\n  if (!GetObject(hBitmap, sizeof(bitmap), &bitmap)) {\n    promise.RejectWithErrorMessage(\"could not convert HBITMAP to BITMAP\");\n    return handle;\n  }\n\n  ICONINFO icon_info;\n  icon_info.fIcon = TRUE;\n  icon_info.hbmMask = hBitmap;\n  icon_info.hbmColor = hBitmap;\n\n  base::win::ScopedHICON icon(CreateIconIndirect(&icon_info));\n  SkBitmap skbitmap = IconUtil::CreateSkBitmapFromHICON(icon.get());\n  gfx::ImageSkia image_skia =\n      gfx::ImageSkia::CreateFromBitmap(skbitmap, 1.0 /*scale factor*/);\n  gfx::Image gfx_image = gfx::Image(image_skia);\n  promise.Resolve(gfx_image);\n  return handle;\n}",
  "abstract_func": "v8::Local<v8::Promise> NativeImage::CreateThumbnailFromPath(\n    v8::Isolate* VAR_0,\n    const base::FilePath& VAR_1,\n    const gfx::Size& VAR_2) {\n  base::win::ScopedCOMInitializer VAR_3;\n\n  gin_helper::Promise<gfx::Image> promise(isolate);\n  v8::Local<v8::Promise> VAR_4 = VAR_5.GetHandle();\n  HRESULT VAR_6;\n\n  if (VAR_2.IsEmpty()) {\n    VAR_5.RejectWithErrorMessage(\"size must not be empty\");\n    return VAR_4;\n  }\n\n  /* COMMENT_0 */\n  Microsoft::WRL::ComPtr<IShellItem> VAR_7;\n  std::wstring VAR_8 = VAR_1.value();\n  VAR_6 = SHCreateItemFromParsingName(VAR_8.c_str(), nullptr,\n                                   IID_PPV_ARGS(&VAR_7));\n\n  if (FAILED(VAR_6)) {\n    VAR_5.RejectWithErrorMessage(\n        \"failed to create IShellItem from the given path\");\n    return VAR_4;\n  }\n\n  /* COMMENT_1 */\n  Microsoft::WRL::ComPtr<IThumbnailCache> VAR_9;\n  VAR_6 = CoCreateInstance(VAR_10, nullptr, VAR_11,\n                        IID_PPV_ARGS(&VAR_9));\n  if (FAILED(VAR_6)) {\n    VAR_5.RejectWithErrorMessage(\n        \"failed to acquire local thumbnail cache reference\");\n    return VAR_4;\n  }\n\n  /* COMMENT_2 */\n  Microsoft::WRL::ComPtr<ISharedBitmap> VAR_12;\n  WTS_CACHEFLAGS VAR_13;\n  WTS_THUMBNAILID VAR_14;\n  VAR_6 = VAR_9->GetThumbnail(VAR_7.Get(), VAR_2.width(),\n                                     WTS_FLAGS::WTS_NONE, &VAR_12, &VAR_13,\n                                     &VAR_14);\n\n  if (FAILED(VAR_6)) {\n    VAR_5.RejectWithErrorMessage(\n        \"failed to get thumbnail from local thumbnail cache reference\");\n    return VAR_4;\n  }\n\n  /* COMMENT_3 */\n  HBITMAP VAR_15 = NULL;\n  VAR_6 = VAR_12->GetSharedBitmap(&VAR_15);\n  if (FAILED(VAR_6)) {\n    VAR_5.RejectWithErrorMessage(\"failed to extract bitmap from thumbnail\");\n    return VAR_4;\n  }\n\n  /* COMMENT_4 */\n  BITMAP VAR_16;\n  if (!GetObject(VAR_15, sizeof(VAR_16), &VAR_16)) {\n    VAR_5.RejectWithErrorMessage(\"could not convert HBITMAP to BITMAP\");\n    return VAR_4;\n  }\n\n  ICONINFO VAR_17;\n  VAR_17.fIcon = TRUE;\n  VAR_17.hbmMask = VAR_15;\n  VAR_17.hbmColor = VAR_15;\n\n  base::win::ScopedHICON VAR_18(CreateIconIndirect(&VAR_17));\n  SkBitmap VAR_19 = IconUtil::CreateSkBitmapFromHICON(VAR_18.get());\n  gfx::ImageSkia VAR_20 =\n      gfx::ImageSkia::CreateFromBitmap(VAR_19, 1.0 /* COMMENT_5 */);\n  gfx::Image VAR_21 = gfx::Image(VAR_20);\n  VAR_5.Resolve(VAR_21);\n  return VAR_4;\n}",
  "func_graph_path": "electron/225a64a3bd6d2bda8dfdbb7a39324326f79eb9b2/electron_api_native_image_win.cc/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -2,6 +2,8 @@\n     v8::Isolate* isolate,\n     const base::FilePath& path,\n     const gfx::Size& size) {\n+  base::win::ScopedCOMInitializer scoped_com_initializer;\n+\n   gin_helper::Promise<gfx::Image> promise(isolate);\n   v8::Local<v8::Promise> handle = promise.GetHandle();\n   HRESULT hr;",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "  base::win::ScopedCOMInitializer scoped_com_initializer;",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/electron/electron/pull/30728",
  "description": {
    "pr_info": {
      "title": "fix: remove ipc wrapper for nativeImage.createThumbnailFromPath",
      "number": 30728
    },
    "comment": [
      "#### Description of Change\nThis removes the IPC wrapper for `nativeImage.createThumbnailFromPath`.\n\n#### Checklist\n<!-- Remove items that do not apply. For completed items, change [ ] to [x]. -->\n\n- [x] PR description included and stakeholders cc'd\n- [x] `npm test` passes\n- [ ] tests are [changed or added](https://github.com/electron/electron/blob/master/docs/development/testing.md)\n- [ ] relevant documentation is changed or added\n- [x] [PR release notes](https://github.com/electron/clerk/blob/master/README.md) describe the change in a way relevant to app developers, and are [capitalized, punctuated, and past tense](https://github.com/electron/clerk/blob/master/README.md#examples).\n\n#### Release Notes\n\nNotes: none\n",
      "**No Release Notes**",
      "I was unable to backport this PR to \"11-x-y\" cleanly;\n   you will need to perform this backport manually.",
      "I was unable to backport this PR to \"12-x-y\" cleanly;\n   you will need to perform this backport manually.",
      "I was unable to backport this PR to \"13-x-y\" cleanly;\n   you will need to perform this backport manually.",
      "I was unable to backport this PR to \"14-x-y\" cleanly;\n   you will need to perform this backport manually.",
      "I have automatically backported this PR to \"15-x-y\",     please check out #30734",
      "@nornagon has manually backported this PR to \"14-x-y\", please check out #30735",
      "@nornagon has manually backported this PR to \"13-x-y\", please check out #30736",
      "@nornagon has manually backported this PR to \"12-x-y\", please check out #30737",
      "@nornagon has manually backported this PR to \"11-x-y\", please check out #30738"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "Final Classification: Defect Remediation & Feature Upgrades  \nConfidence: 0.9"
}