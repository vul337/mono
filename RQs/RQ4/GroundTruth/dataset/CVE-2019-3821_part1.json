{
  "cve_id": "CVE-2019-3821",
  "cwe_ids": [
    "CWE-772"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "ceph/civetweb",
  "commit_msg": "Fix file descriptor leak.\n\nIf the openssl initial negotiation fails, then the rest of\nwhat sslize does doesn't happen.  One of the last things\nsslize does is to close the socket at the end of the session.\nThat needs to happen even if there's no session.\n\nSigned-off-by: Marcus Watts <mwatts@redhat.com>",
  "commit_hash": "8fba7751f61a20158fedc3fc69684e9fe8cd0dce",
  "git_url": "https://github.com/ceph/civetweb/commit/8fba7751f61a20158fedc3fc69684e9fe8cd0dce",
  "file_path": "src/civetweb.c",
  "func_name": "worker_thread_run",
  "func_before": "static void *\nworker_thread_run(struct worker_thread_args *thread_args)\n{\n\tstruct mg_context *ctx = thread_args->ctx;\n\tstruct mg_connection *conn;\n\tstruct mg_workerTLS tls;\n#if defined(MG_LEGACY_INTERFACE)\n\tuint32_t addr;\n#endif\n\n\tmg_set_thread_name(\"worker\");\n\n\ttls.is_master = 0;\n\ttls.thread_idx = (unsigned)mg_atomic_inc(&thread_idx_max);\n#if defined(_WIN32) && !defined(__SYMBIAN32__)\n\ttls.pthread_cond_helper_mutex = CreateEvent(NULL, FALSE, FALSE, NULL);\n#endif\n\n\t/* Initialize thread local storage before calling any callback */\n\tpthread_setspecific(sTlsKey, &tls);\n\n\tif (ctx->callbacks.init_thread) {\n\t\t/* call init_thread for a worker thread (type 1) */\n\t\tctx->callbacks.init_thread(ctx, 1);\n\t}\n\n\t/* Connection structure has been pre-allocated */\n\tif (((int)thread_args->index < 0)\n\t    || ((unsigned)thread_args->index\n\t        >= (unsigned)ctx->cfg_worker_threads)) {\n\t\tmg_cry(fc(ctx),\n\t\t       \"Internal error: Invalid worker index %i\",\n\t\t       (int)thread_args->index);\n\t\treturn NULL;\n\t}\n\tconn = ctx->worker_connections + thread_args->index;\n\n\t/* Request buffers are not pre-allocated. They are private to the\n\t * request and do not contain any state information that might be\n\t * of interest to anyone observing a server status.  */\n\tconn->buf = (char *)mg_malloc_ctx(ctx->max_request_size, conn->ctx);\n\tif (conn->buf == NULL) {\n\t\tmg_cry(fc(ctx),\n\t\t       \"Out of memory: Cannot allocate buffer for worker %i\",\n\t\t       (int)thread_args->index);\n\t\treturn NULL;\n\t}\n\tconn->buf_size = (int)ctx->max_request_size;\n\n\tconn->ctx = ctx;\n\tconn->thread_index = thread_args->index;\n\tconn->request_info.user_data = ctx->user_data;\n\t/* Allocate a mutex for this connection to allow communication both\n\t * within the request handler and from elsewhere in the application\n\t */\n\t(void)pthread_mutex_init(&conn->mutex, &pthread_mutex_attr);\n\n#if defined(USE_SERVER_STATS)\n\tconn->conn_state = 1; /* not consumed */\n#endif\n\n\t/* Call consume_socket() even when ctx->stop_flag > 0, to let it\n\t * signal sq_empty condvar to wake up the master waiting in\n\t * produce_socket() */\n\twhile (consume_socket(ctx, &conn->client, conn->thread_index)) {\n\t\tconn->conn_birth_time = time(NULL);\n\n/* Fill in IP, port info early so even if SSL setup below fails,\n * error handler would have the corresponding info.\n * Thanks to Johannes Winkelmann for the patch.\n */\n#if defined(USE_IPV6)\n\t\tif (conn->client.rsa.sa.sa_family == AF_INET6) {\n\t\t\tconn->request_info.remote_port =\n\t\t\t    ntohs(conn->client.rsa.sin6.sin6_port);\n\t\t} else\n#endif\n\t\t{\n\t\t\tconn->request_info.remote_port =\n\t\t\t    ntohs(conn->client.rsa.sin.sin_port);\n\t\t}\n\n\t\tsockaddr_to_string(conn->request_info.remote_addr,\n\t\t                   sizeof(conn->request_info.remote_addr),\n\t\t                   &conn->client.rsa);\n\n\t\tDEBUG_TRACE(\"Start processing connection from %s\",\n\t\t            conn->request_info.remote_addr);\n\n#if defined(MG_LEGACY_INTERFACE)\n\t\t/* This legacy interface only works for the IPv4 case */\n\t\taddr = ntohl(conn->client.rsa.sin.sin_addr.s_addr);\n\t\tmemcpy(&conn->request_info.remote_ip, &addr, 4);\n#endif\n\n\t\tconn->request_info.is_ssl = conn->client.is_ssl;\n\n\t\tif (conn->client.is_ssl) {\n#ifndef NO_SSL\n\t\t\t/* HTTPS connection */\n\t\t\tif (sslize(conn,\n\t\t\t           conn->ctx->ssl_ctx,\n\t\t\t           SSL_accept,\n\t\t\t           &(conn->ctx->stop_flag))) {\n\t\t\t\t/* Get SSL client certificate information (if set) */\n\t\t\t\tssl_get_client_cert_info(conn);\n\n\t\t\t\t/* process HTTPS connection */\n\t\t\t\tprocess_new_connection(conn);\n\n\t\t\t\t/* Free client certificate info */\n\t\t\t\tif (conn->request_info.client_cert) {\n\t\t\t\t\tmg_free((void *)(conn->request_info.client_cert->subject));\n\t\t\t\t\tmg_free((void *)(conn->request_info.client_cert->issuer));\n\t\t\t\t\tmg_free((void *)(conn->request_info.client_cert->serial));\n\t\t\t\t\tmg_free((void *)(conn->request_info.client_cert->finger));\n\t\t\t\t\tconn->request_info.client_cert->subject = 0;\n\t\t\t\t\tconn->request_info.client_cert->issuer = 0;\n\t\t\t\t\tconn->request_info.client_cert->serial = 0;\n\t\t\t\t\tconn->request_info.client_cert->finger = 0;\n\t\t\t\t\tmg_free(conn->request_info.client_cert);\n\t\t\t\t\tconn->request_info.client_cert = 0;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t} else {\n\t\t\t/* process HTTP connection */\n\t\t\tprocess_new_connection(conn);\n\t\t}\n\n\t\tDEBUG_TRACE(\"%s\", \"Connection closed\");\n\t}\n\n\n\tpthread_setspecific(sTlsKey, NULL);\n#if defined(_WIN32) && !defined(__SYMBIAN32__)\n\tCloseHandle(tls.pthread_cond_helper_mutex);\n#endif\n\tpthread_mutex_destroy(&conn->mutex);\n\n\t/* Free the request buffer. */\n\tconn->buf_size = 0;\n\tmg_free(conn->buf);\n\tconn->buf = NULL;\n\n#if defined(USE_SERVER_STATS)\n\tconn->conn_state = 9; /* done */\n#endif\n\n\tDEBUG_TRACE(\"%s\", \"exiting\");\n\treturn NULL;\n}",
  "abstract_func_before": "static void *\nworker_thread_run(struct worker_thread_args *VAR_0)\n{\n\tstruct mg_context *VAR_1 = VAR_0->ctx;\n\tstruct mg_connection *VAR_2;\n\tstruct mg_workerTLS VAR_3;\n#if defined(VAR_4)\n\tuint32_t VAR_5;\n#endif\n\n\tmg_set_thread_name(\"worker\");\n\n\tVAR_3.is_master = 0;\n\tVAR_3.thread_idx = (unsigned)mg_atomic_inc(&VAR_6);\n#if defined(VAR_7) && !defined(VAR_8)\n\tVAR_3.pthread_cond_helper_mutex = CreateEvent(NULL, FALSE, FALSE, NULL);\n#endif\n\n\t/* COMMENT_0 */\n\tpthread_setspecific(VAR_9, &VAR_3);\n\n\tif (VAR_1->callbacks.init_thread) {\n\t\t/* COMMENT_1 */\n\t\tVAR_1->callbacks.init_thread(VAR_1, 1);\n\t}\n\n\t/* COMMENT_2 */\n\tif (((int)VAR_0->index < 0)\n\t    || ((unsigned)VAR_0->index\n\t        >= (unsigned)VAR_1->cfg_worker_threads)) {\n\t\tmg_cry(fc(VAR_1),\n\t\t       \"Internal error: Invalid worker index %i\",\n\t\t       (int)VAR_0->index);\n\t\treturn NULL;\n\t}\n\tVAR_2 = VAR_1->worker_connections + VAR_0->index;\n\n\t/* COMMENT_3 */\n                                                                  \n                                                        \n\tVAR_2->buf = (char *)mg_malloc_ctx(VAR_1->max_request_size, VAR_2->ctx);\n\tif (VAR_2->buf == NULL) {\n\t\tmg_cry(fc(VAR_1),\n\t\t       \"Out of memory: Cannot allocate buffer for worker %i\",\n\t\t       (int)VAR_0->index);\n\t\treturn NULL;\n\t}\n\tVAR_2->buf_size = (int)VAR_1->max_request_size;\n\n\tVAR_2->ctx = VAR_1;\n\tVAR_2->thread_index = VAR_0->index;\n\tVAR_2->request_info.user_data = VAR_1->user_data;\n\t/* COMMENT_6 */\n                                                                    \n    \n\t(void)pthread_mutex_init(&VAR_2->mutex, &VAR_10);\n\n#if defined(VAR_11)\n\tVAR_2->conn_state = 1; /* COMMENT_9 */\n#endif\n\n\t/* COMMENT_10 */\n                                                            \n                       \n\twhile (consume_socket(VAR_1, &VAR_2->client, VAR_2->thread_index)) {\n\t\tVAR_2->conn_birth_time = time(NULL);\n\n/* COMMENT_13 */\n                                                   \n                                               \n   \n#if defined(VAR_12)\n\t\tif (VAR_2->client.rsa.sa.sa_family == VAR_13) {\n\t\t\tVAR_2->request_info.remote_port =\n\t\t\t    ntohs(VAR_2->client.rsa.sin6.sin6_port);\n\t\t} else\n#endif\n\t\t{\n\t\t\tVAR_2->request_info.remote_port =\n\t\t\t    ntohs(VAR_2->client.rsa.sin.sin_port);\n\t\t}\n\n\t\tsockaddr_to_string(VAR_2->request_info.remote_addr,\n\t\t                   sizeof(VAR_2->request_info.remote_addr),\n\t\t                   &VAR_2->client.rsa);\n\n\t\tDEBUG_TRACE(\"Start processing connection from %s\",\n\t\t            VAR_2->request_info.remote_addr);\n\n#if defined(VAR_4)\n\t\t/* COMMENT_17 */\n\t\tVAR_5 = ntohl(VAR_2->client.rsa.sin.sin_addr.s_addr);\n\t\tmemcpy(&VAR_2->request_info.remote_ip, &VAR_5, 4);\n#endif\n\n\t\tVAR_2->request_info.is_ssl = VAR_2->client.is_ssl;\n\n\t\tif (VAR_2->client.is_ssl) {\n#ifndef VAR_14\n\t\t\t/* COMMENT_18 */\n\t\t\tif (sslize(VAR_2,\n\t\t\t           VAR_2->ctx->ssl_ctx,\n\t\t\t           VAR_15,\n\t\t\t           &(VAR_2->ctx->stop_flag))) {\n\t\t\t\t/* COMMENT_19 */\n\t\t\t\tssl_get_client_cert_info(VAR_2);\n\n\t\t\t\t/* COMMENT_20 */\n\t\t\t\tprocess_new_connection(VAR_2);\n\n\t\t\t\t/* COMMENT_21 */\n\t\t\t\tif (VAR_2->request_info.client_cert) {\n\t\t\t\t\tmg_free((void *)(VAR_2->request_info.client_cert->subject));\n\t\t\t\t\tmg_free((void *)(VAR_2->request_info.client_cert->issuer));\n\t\t\t\t\tmg_free((void *)(VAR_2->request_info.client_cert->serial));\n\t\t\t\t\tmg_free((void *)(VAR_2->request_info.client_cert->finger));\n\t\t\t\t\tVAR_2->request_info.client_cert->subject = 0;\n\t\t\t\t\tVAR_2->request_info.client_cert->issuer = 0;\n\t\t\t\t\tVAR_2->request_info.client_cert->serial = 0;\n\t\t\t\t\tVAR_2->request_info.client_cert->finger = 0;\n\t\t\t\t\tmg_free(VAR_2->request_info.client_cert);\n\t\t\t\t\tVAR_2->request_info.client_cert = 0;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t} else {\n\t\t\t/* COMMENT_22 */\n\t\t\tprocess_new_connection(VAR_2);\n\t\t}\n\n\t\tDEBUG_TRACE(\"%s\", \"Connection closed\");\n\t}\n\n\n\tpthread_setspecific(VAR_9, NULL);\n#if defined(VAR_7) && !defined(VAR_8)\n\tCloseHandle(VAR_3.pthread_cond_helper_mutex);\n#endif\n\tpthread_mutex_destroy(&VAR_2->mutex);\n\n\t/* COMMENT_23 */\n\tVAR_2->buf_size = 0;\n\tmg_free(VAR_2->buf);\n\tVAR_2->buf = NULL;\n\n#if defined(VAR_11)\n\tVAR_2->conn_state = 9; /* COMMENT_24 */\n#endif\n\n\tDEBUG_TRACE(\"%s\", \"exiting\");\n\treturn NULL;\n}",
  "func_graph_path_before": "ceph/civetweb/8fba7751f61a20158fedc3fc69684e9fe8cd0dce/civetweb.c/vul/before/0.json",
  "func": "static void *\nworker_thread_run(struct worker_thread_args *thread_args)\n{\n\tstruct mg_context *ctx = thread_args->ctx;\n\tstruct mg_connection *conn;\n\tstruct mg_workerTLS tls;\n#if defined(MG_LEGACY_INTERFACE)\n\tuint32_t addr;\n#endif\n\n\tmg_set_thread_name(\"worker\");\n\n\ttls.is_master = 0;\n\ttls.thread_idx = (unsigned)mg_atomic_inc(&thread_idx_max);\n#if defined(_WIN32) && !defined(__SYMBIAN32__)\n\ttls.pthread_cond_helper_mutex = CreateEvent(NULL, FALSE, FALSE, NULL);\n#endif\n\n\t/* Initialize thread local storage before calling any callback */\n\tpthread_setspecific(sTlsKey, &tls);\n\n\tif (ctx->callbacks.init_thread) {\n\t\t/* call init_thread for a worker thread (type 1) */\n\t\tctx->callbacks.init_thread(ctx, 1);\n\t}\n\n\t/* Connection structure has been pre-allocated */\n\tif (((int)thread_args->index < 0)\n\t    || ((unsigned)thread_args->index\n\t        >= (unsigned)ctx->cfg_worker_threads)) {\n\t\tmg_cry(fc(ctx),\n\t\t       \"Internal error: Invalid worker index %i\",\n\t\t       (int)thread_args->index);\n\t\treturn NULL;\n\t}\n\tconn = ctx->worker_connections + thread_args->index;\n\n\t/* Request buffers are not pre-allocated. They are private to the\n\t * request and do not contain any state information that might be\n\t * of interest to anyone observing a server status.  */\n\tconn->buf = (char *)mg_malloc_ctx(ctx->max_request_size, conn->ctx);\n\tif (conn->buf == NULL) {\n\t\tmg_cry(fc(ctx),\n\t\t       \"Out of memory: Cannot allocate buffer for worker %i\",\n\t\t       (int)thread_args->index);\n\t\treturn NULL;\n\t}\n\tconn->buf_size = (int)ctx->max_request_size;\n\n\tconn->ctx = ctx;\n\tconn->thread_index = thread_args->index;\n\tconn->request_info.user_data = ctx->user_data;\n\t/* Allocate a mutex for this connection to allow communication both\n\t * within the request handler and from elsewhere in the application\n\t */\n\t(void)pthread_mutex_init(&conn->mutex, &pthread_mutex_attr);\n\n#if defined(USE_SERVER_STATS)\n\tconn->conn_state = 1; /* not consumed */\n#endif\n\n\t/* Call consume_socket() even when ctx->stop_flag > 0, to let it\n\t * signal sq_empty condvar to wake up the master waiting in\n\t * produce_socket() */\n\twhile (consume_socket(ctx, &conn->client, conn->thread_index)) {\n\t\tconn->conn_birth_time = time(NULL);\n\n/* Fill in IP, port info early so even if SSL setup below fails,\n * error handler would have the corresponding info.\n * Thanks to Johannes Winkelmann for the patch.\n */\n#if defined(USE_IPV6)\n\t\tif (conn->client.rsa.sa.sa_family == AF_INET6) {\n\t\t\tconn->request_info.remote_port =\n\t\t\t    ntohs(conn->client.rsa.sin6.sin6_port);\n\t\t} else\n#endif\n\t\t{\n\t\t\tconn->request_info.remote_port =\n\t\t\t    ntohs(conn->client.rsa.sin.sin_port);\n\t\t}\n\n\t\tsockaddr_to_string(conn->request_info.remote_addr,\n\t\t                   sizeof(conn->request_info.remote_addr),\n\t\t                   &conn->client.rsa);\n\n\t\tDEBUG_TRACE(\"Start processing connection from %s\",\n\t\t            conn->request_info.remote_addr);\n\n#if defined(MG_LEGACY_INTERFACE)\n\t\t/* This legacy interface only works for the IPv4 case */\n\t\taddr = ntohl(conn->client.rsa.sin.sin_addr.s_addr);\n\t\tmemcpy(&conn->request_info.remote_ip, &addr, 4);\n#endif\n\n\t\tconn->request_info.is_ssl = conn->client.is_ssl;\n\n\t\tif (conn->client.is_ssl) {\n#ifndef NO_SSL\n\t\t\t/* HTTPS connection */\n\t\t\tif (sslize(conn,\n\t\t\t           conn->ctx->ssl_ctx,\n\t\t\t           SSL_accept,\n\t\t\t           &(conn->ctx->stop_flag))) {\n\t\t\t\t/* Get SSL client certificate information (if set) */\n\t\t\t\tssl_get_client_cert_info(conn);\n\n\t\t\t\t/* process HTTPS connection */\n\t\t\t\tprocess_new_connection(conn);\n\n\t\t\t\t/* Free client certificate info */\n\t\t\t\tif (conn->request_info.client_cert) {\n\t\t\t\t\tmg_free((void *)(conn->request_info.client_cert->subject));\n\t\t\t\t\tmg_free((void *)(conn->request_info.client_cert->issuer));\n\t\t\t\t\tmg_free((void *)(conn->request_info.client_cert->serial));\n\t\t\t\t\tmg_free((void *)(conn->request_info.client_cert->finger));\n\t\t\t\t\tconn->request_info.client_cert->subject = 0;\n\t\t\t\t\tconn->request_info.client_cert->issuer = 0;\n\t\t\t\t\tconn->request_info.client_cert->serial = 0;\n\t\t\t\t\tconn->request_info.client_cert->finger = 0;\n\t\t\t\t\tmg_free(conn->request_info.client_cert);\n\t\t\t\t\tconn->request_info.client_cert = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tclose_connection(conn);\n\t\t\t}\n#endif\n\t\t} else {\n\t\t\t/* process HTTP connection */\n\t\t\tprocess_new_connection(conn);\n\t\t}\n\n\t\tDEBUG_TRACE(\"%s\", \"Connection closed\");\n\t}\n\n\n\tpthread_setspecific(sTlsKey, NULL);\n#if defined(_WIN32) && !defined(__SYMBIAN32__)\n\tCloseHandle(tls.pthread_cond_helper_mutex);\n#endif\n\tpthread_mutex_destroy(&conn->mutex);\n\n\t/* Free the request buffer. */\n\tconn->buf_size = 0;\n\tmg_free(conn->buf);\n\tconn->buf = NULL;\n\n#if defined(USE_SERVER_STATS)\n\tconn->conn_state = 9; /* done */\n#endif\n\n\tDEBUG_TRACE(\"%s\", \"exiting\");\n\treturn NULL;\n}",
  "abstract_func": "static void *\nworker_thread_run(struct worker_thread_args *VAR_0)\n{\n\tstruct mg_context *VAR_1 = VAR_0->ctx;\n\tstruct mg_connection *VAR_2;\n\tstruct mg_workerTLS VAR_3;\n#if defined(VAR_4)\n\tuint32_t VAR_5;\n#endif\n\n\tmg_set_thread_name(\"worker\");\n\n\tVAR_3.is_master = 0;\n\tVAR_3.thread_idx = (unsigned)mg_atomic_inc(&VAR_6);\n#if defined(VAR_7) && !defined(VAR_8)\n\tVAR_3.pthread_cond_helper_mutex = CreateEvent(NULL, FALSE, FALSE, NULL);\n#endif\n\n\t/* COMMENT_0 */\n\tpthread_setspecific(VAR_9, &VAR_3);\n\n\tif (VAR_1->callbacks.init_thread) {\n\t\t/* COMMENT_1 */\n\t\tVAR_1->callbacks.init_thread(VAR_1, 1);\n\t}\n\n\t/* COMMENT_2 */\n\tif (((int)VAR_0->index < 0)\n\t    || ((unsigned)VAR_0->index\n\t        >= (unsigned)VAR_1->cfg_worker_threads)) {\n\t\tmg_cry(fc(VAR_1),\n\t\t       \"Internal error: Invalid worker index %i\",\n\t\t       (int)VAR_0->index);\n\t\treturn NULL;\n\t}\n\tVAR_2 = VAR_1->worker_connections + VAR_0->index;\n\n\t/* COMMENT_3 */\n                                                                  \n                                                        \n\tVAR_2->buf = (char *)mg_malloc_ctx(VAR_1->max_request_size, VAR_2->ctx);\n\tif (VAR_2->buf == NULL) {\n\t\tmg_cry(fc(VAR_1),\n\t\t       \"Out of memory: Cannot allocate buffer for worker %i\",\n\t\t       (int)VAR_0->index);\n\t\treturn NULL;\n\t}\n\tVAR_2->buf_size = (int)VAR_1->max_request_size;\n\n\tVAR_2->ctx = VAR_1;\n\tVAR_2->thread_index = VAR_0->index;\n\tVAR_2->request_info.user_data = VAR_1->user_data;\n\t/* COMMENT_6 */\n                                                                    \n    \n\t(void)pthread_mutex_init(&VAR_2->mutex, &VAR_10);\n\n#if defined(VAR_11)\n\tVAR_2->conn_state = 1; /* COMMENT_9 */\n#endif\n\n\t/* COMMENT_10 */\n                                                            \n                       \n\twhile (consume_socket(VAR_1, &VAR_2->client, VAR_2->thread_index)) {\n\t\tVAR_2->conn_birth_time = time(NULL);\n\n/* COMMENT_13 */\n                                                   \n                                               \n   \n#if defined(VAR_12)\n\t\tif (VAR_2->client.rsa.sa.sa_family == VAR_13) {\n\t\t\tVAR_2->request_info.remote_port =\n\t\t\t    ntohs(VAR_2->client.rsa.sin6.sin6_port);\n\t\t} else\n#endif\n\t\t{\n\t\t\tVAR_2->request_info.remote_port =\n\t\t\t    ntohs(VAR_2->client.rsa.sin.sin_port);\n\t\t}\n\n\t\tsockaddr_to_string(VAR_2->request_info.remote_addr,\n\t\t                   sizeof(VAR_2->request_info.remote_addr),\n\t\t                   &VAR_2->client.rsa);\n\n\t\tDEBUG_TRACE(\"Start processing connection from %s\",\n\t\t            VAR_2->request_info.remote_addr);\n\n#if defined(VAR_4)\n\t\t/* COMMENT_17 */\n\t\tVAR_5 = ntohl(VAR_2->client.rsa.sin.sin_addr.s_addr);\n\t\tmemcpy(&VAR_2->request_info.remote_ip, &VAR_5, 4);\n#endif\n\n\t\tVAR_2->request_info.is_ssl = VAR_2->client.is_ssl;\n\n\t\tif (VAR_2->client.is_ssl) {\n#ifndef VAR_14\n\t\t\t/* COMMENT_18 */\n\t\t\tif (sslize(VAR_2,\n\t\t\t           VAR_2->ctx->ssl_ctx,\n\t\t\t           VAR_15,\n\t\t\t           &(VAR_2->ctx->stop_flag))) {\n\t\t\t\t/* COMMENT_19 */\n\t\t\t\tssl_get_client_cert_info(VAR_2);\n\n\t\t\t\t/* COMMENT_20 */\n\t\t\t\tprocess_new_connection(VAR_2);\n\n\t\t\t\t/* COMMENT_21 */\n\t\t\t\tif (VAR_2->request_info.client_cert) {\n\t\t\t\t\tmg_free((void *)(VAR_2->request_info.client_cert->subject));\n\t\t\t\t\tmg_free((void *)(VAR_2->request_info.client_cert->issuer));\n\t\t\t\t\tmg_free((void *)(VAR_2->request_info.client_cert->serial));\n\t\t\t\t\tmg_free((void *)(VAR_2->request_info.client_cert->finger));\n\t\t\t\t\tVAR_2->request_info.client_cert->subject = 0;\n\t\t\t\t\tVAR_2->request_info.client_cert->issuer = 0;\n\t\t\t\t\tVAR_2->request_info.client_cert->serial = 0;\n\t\t\t\t\tVAR_2->request_info.client_cert->finger = 0;\n\t\t\t\t\tmg_free(VAR_2->request_info.client_cert);\n\t\t\t\t\tVAR_2->request_info.client_cert = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tclose_connection(VAR_2);\n\t\t\t}\n#endif\n\t\t} else {\n\t\t\t/* COMMENT_22 */\n\t\t\tprocess_new_connection(VAR_2);\n\t\t}\n\n\t\tDEBUG_TRACE(\"%s\", \"Connection closed\");\n\t}\n\n\n\tpthread_setspecific(VAR_9, NULL);\n#if defined(VAR_7) && !defined(VAR_8)\n\tCloseHandle(VAR_3.pthread_cond_helper_mutex);\n#endif\n\tpthread_mutex_destroy(&VAR_2->mutex);\n\n\t/* COMMENT_23 */\n\tVAR_2->buf_size = 0;\n\tmg_free(VAR_2->buf);\n\tVAR_2->buf = NULL;\n\n#if defined(VAR_11)\n\tVAR_2->conn_state = 9; /* COMMENT_24 */\n#endif\n\n\tDEBUG_TRACE(\"%s\", \"exiting\");\n\treturn NULL;\n}",
  "func_graph_path": "ceph/civetweb/8fba7751f61a20158fedc3fc69684e9fe8cd0dce/civetweb.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -122,6 +122,9 @@\n \t\t\t\t\tconn->request_info.client_cert = 0;\n \t\t\t\t}\n \t\t\t}\n+\t\t\telse {\n+\t\t\t\tclose_connection(conn);\n+\t\t\t}\n #endif\n \t\t} else {\n \t\t\t/* process HTTP connection */",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "\t\t\telse {",
      "\t\t\t\tclose_connection(conn);",
      "\t\t\t}"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/ceph/civetweb/pull/37",
  "description": {
    "pr_info": {
      "title": "Wip master chunkphase1",
      "number": 37
    },
    "comment": [
      "3 fixes here.\r\n\r\n1 content-length vs. transfer-encoding: chunked; according to rfc 2616,\r\ntransfer-encoding chunked should supersede content-length. Later rfcs require this be treated as an error - sadly experience has shown s3 clients lag in this respect.\r\n\r\n 2 eat final crlf after last chunk header.  Otherwise, the *next* request fails.\r\n\r\n 3  mg_set_must_close, Gives ceph/rgw a way to say this connection is hosed, do not attempt to read another request out of it.\r\n\r\nThese are all issues from,\r\nhttps://tracker.ceph.com/issues/45789",
      "This supersedes PR #35 that I left for civetweb.  I'm guessing travis will fail again.  This is simplified to be just the \"safe\" fixes - I'll have further fixes past this that have more complicated issues.",
      "I had left out a commit originally and botched a refactor.  I've pushed corrections for both."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.97,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.97"
}