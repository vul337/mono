{
  "cve_id": "CVE-2014-9748",
  "cwe_ids": [
    "CWE-362"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "nodejs/node",
  "commit_msg": "crypto: replace rwlocks with simple mutexes\n\nIt was pointed out by Zhou Ran that the Windows XP implementation of\nuv_rwlock_rdlock() and friends may unlock the inner write mutex on a\ndifferent thread than the one that locked it, resulting in undefined\nbehavior.\n\nThe only place that uses rwlocks is the crypto module.  Make that use\nnormal (simple) mutexes instead.\n\nOpenSSL's critical sections are generally very short, with exclusive\naccess outnumbering shared access by a factor of three or more, so\nit's not as if using rwlocks gives a decisive performance advantage.\n\nPR-URL: https://github.com/nodejs/node/pull/2723\nReviewed-By: Fedor Indutny <fedor@indutny.com>",
  "commit_hash": "7ee58bebff8074610d83bdf75ce01e9833b58a0e",
  "git_url": "https://github.com/nodejs/node/commit/7ee58bebff8074610d83bdf75ce01e9833b58a0e",
  "file_path": "src/node_crypto.cc",
  "func_name": "crypto_lock_cb",
  "func_before": "static void crypto_lock_cb(int mode, int n, const char* file, int line) {\n  CHECK((mode & CRYPTO_LOCK) || (mode & CRYPTO_UNLOCK));\n  CHECK((mode & CRYPTO_READ) || (mode & CRYPTO_WRITE));\n\n  if (mode & CRYPTO_LOCK) {\n    if (mode & CRYPTO_READ)\n      uv_rwlock_rdlock(locks + n);\n    else\n      uv_rwlock_wrlock(locks + n);\n  } else {\n    if (mode & CRYPTO_READ)\n      uv_rwlock_rdunlock(locks + n);\n    else\n      uv_rwlock_wrunlock(locks + n);\n  }\n}",
  "abstract_func_before": "static void crypto_lock_cb(int VAR_0, int VAR_1, const char* VAR_2, int VAR_3) {\n  CHECK((VAR_0 & VAR_4) || (VAR_0 & VAR_5));\n  CHECK((VAR_0 & VAR_6) || (VAR_0 & VAR_7));\n\n  if (VAR_0 & VAR_4) {\n    if (VAR_0 & VAR_6)\n      uv_rwlock_rdlock(VAR_8 + VAR_1);\n    else\n      uv_rwlock_wrlock(VAR_8 + VAR_1);\n  } else {\n    if (VAR_0 & VAR_6)\n      uv_rwlock_rdunlock(VAR_8 + VAR_1);\n    else\n      uv_rwlock_wrunlock(VAR_8 + VAR_1);\n  }\n}",
  "func_graph_path_before": "nodejs/node/7ee58bebff8074610d83bdf75ce01e9833b58a0e/node_crypto.cc/vul/before/1.json",
  "func": "static void crypto_lock_cb(int mode, int n, const char* file, int line) {\n  CHECK(!(mode & CRYPTO_LOCK) ^ !(mode & CRYPTO_UNLOCK));\n  CHECK(!(mode & CRYPTO_READ) ^ !(mode & CRYPTO_WRITE));\n\n  if (mode & CRYPTO_LOCK)\n    uv_mutex_lock(locks + n);\n  else\n    uv_mutex_unlock(locks + n);\n}",
  "abstract_func": "static void crypto_lock_cb(int VAR_0, int VAR_1, const char* VAR_2, int VAR_3) {\n  CHECK(!(VAR_0 & VAR_4) ^ !(VAR_0 & VAR_5));\n  CHECK(!(VAR_0 & VAR_6) ^ !(VAR_0 & VAR_7));\n\n  if (VAR_0 & VAR_4)\n    uv_mutex_lock(VAR_8 + VAR_1);\n  else\n    uv_mutex_unlock(VAR_8 + VAR_1);\n}",
  "func_graph_path": "nodejs/node/7ee58bebff8074610d83bdf75ce01e9833b58a0e/node_crypto.cc/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,16 +1,9 @@\n static void crypto_lock_cb(int mode, int n, const char* file, int line) {\n-  CHECK((mode & CRYPTO_LOCK) || (mode & CRYPTO_UNLOCK));\n-  CHECK((mode & CRYPTO_READ) || (mode & CRYPTO_WRITE));\n+  CHECK(!(mode & CRYPTO_LOCK) ^ !(mode & CRYPTO_UNLOCK));\n+  CHECK(!(mode & CRYPTO_READ) ^ !(mode & CRYPTO_WRITE));\n \n-  if (mode & CRYPTO_LOCK) {\n-    if (mode & CRYPTO_READ)\n-      uv_rwlock_rdlock(locks + n);\n-    else\n-      uv_rwlock_wrlock(locks + n);\n-  } else {\n-    if (mode & CRYPTO_READ)\n-      uv_rwlock_rdunlock(locks + n);\n-    else\n-      uv_rwlock_wrunlock(locks + n);\n-  }\n+  if (mode & CRYPTO_LOCK)\n+    uv_mutex_lock(locks + n);\n+  else\n+    uv_mutex_unlock(locks + n);\n }",
  "diff_line_info": {
    "deleted_lines": [
      "  CHECK((mode & CRYPTO_LOCK) || (mode & CRYPTO_UNLOCK));",
      "  CHECK((mode & CRYPTO_READ) || (mode & CRYPTO_WRITE));",
      "  if (mode & CRYPTO_LOCK) {",
      "    if (mode & CRYPTO_READ)",
      "      uv_rwlock_rdlock(locks + n);",
      "    else",
      "      uv_rwlock_wrlock(locks + n);",
      "  } else {",
      "    if (mode & CRYPTO_READ)",
      "      uv_rwlock_rdunlock(locks + n);",
      "    else",
      "      uv_rwlock_wrunlock(locks + n);",
      "  }"
    ],
    "added_lines": [
      "  CHECK(!(mode & CRYPTO_LOCK) ^ !(mode & CRYPTO_UNLOCK));",
      "  CHECK(!(mode & CRYPTO_READ) ^ !(mode & CRYPTO_WRITE));",
      "  if (mode & CRYPTO_LOCK)",
      "    uv_mutex_lock(locks + n);",
      "  else",
      "    uv_mutex_unlock(locks + n);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/nodejs/node/pull/2723",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/nodejs/node/pull/2723: 403 Client Error: Forbidden for url: https://api.github.com/repos/nodejs/node/pulls/2723",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9"
}