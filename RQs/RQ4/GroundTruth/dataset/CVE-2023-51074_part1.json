{
  "cve_id": "CVE-2023-51074",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
  "cvss_is_v3": true,
  "repo_name": "json-path/JsonPath",
  "commit_msg": "Check for the existence of the next significant bracket",
  "commit_hash": "f49ff25e3bad8c8a0c853058181f2c00b5beb305",
  "git_url": "https://github.com/json-path/JsonPath/commit/f49ff25e3bad8c8a0c853058181f2c00b5beb305",
  "file_path": "json-path/src/main/java/com/jayway/jsonpath/internal/path/PathCompiler.java",
  "func_name": "readBracketPropertyToken",
  "func_before": "private boolean readBracketPropertyToken(PathTokenAppender appender) {\n        if (!path.currentCharIs(OPEN_SQUARE_BRACKET)) {\n            return false;\n        }\n        char potentialStringDelimiter = path.nextSignificantChar();\n        if (potentialStringDelimiter != SINGLE_QUOTE && potentialStringDelimiter != DOUBLE_QUOTE) {\n          return false;\n        }\n\n        List<String> properties = new ArrayList<String>();\n\n        int startPosition = path.position() + 1;\n        int readPosition = startPosition;\n        int endPosition = 0;\n        boolean inProperty = false;\n        boolean inEscape = false;\n        boolean lastSignificantWasComma = false;\n\n        while (path.inBounds(readPosition)) {\n            char c = path.charAt(readPosition);\n\n            if(inEscape){\n                inEscape = false;\n            } else if('\\\\' == c){\n                inEscape = true;\n            } else if (c == CLOSE_SQUARE_BRACKET && !inProperty) {\n                if (lastSignificantWasComma){\n                  fail(\"Found empty property at index \"+readPosition);\n                }\n                break;\n            } else if (c == potentialStringDelimiter) {\n                if (inProperty) {\n                    char nextSignificantChar = path.nextSignificantChar(readPosition);\n                    if (nextSignificantChar != CLOSE_SQUARE_BRACKET && nextSignificantChar != COMMA) {\n                        fail(\"Property must be separated by comma or Property must be terminated close square bracket at index \"+readPosition);\n                    }\n                    endPosition = readPosition;\n                    String prop = path.subSequence(startPosition, endPosition).toString();\n                    properties.add(Utils.unescape(prop));\n                    inProperty = false;\n                } else {\n                    startPosition = readPosition + 1;\n                    inProperty = true;\n                    lastSignificantWasComma = false;\n                }\n            } else if (c == COMMA && !inProperty) {\n                if (lastSignificantWasComma){\n                    fail(\"Found empty property at index \"+readPosition);\n                }\n                lastSignificantWasComma = true;\n            }\n            readPosition++;\n        }\n\n        if (inProperty){\n            fail(\"Property has not been closed - missing closing \" + potentialStringDelimiter);\n        }\n\n        int endBracketIndex = path.indexOfNextSignificantChar(endPosition, CLOSE_SQUARE_BRACKET) + 1;\n\n        path.setPosition(endBracketIndex);\n\n        appender.appendPathToken(PathTokenFactory.createPropertyPathToken(properties, potentialStringDelimiter));\n\n        return path.currentIsTail() || readNextToken(appender);\n    }",
  "abstract_func_before": "private boolean readBracketPropertyToken(PathTokenAppender VAR_0) {\n        if (!VAR_1.currentCharIs(VAR_2)) {\n            return false;\n        }\n        char VAR_3 = VAR_1.nextSignificantChar();\n        if (VAR_3 != VAR_4 && VAR_3 != VAR_5) {\n          return false;\n        }\n\n        List<String> VAR_6 = new ArrayList<String>();\n\n        int VAR_7 = VAR_1.position() + 1;\n        int VAR_8 = VAR_7;\n        int VAR_9 = 0;\n        boolean VAR_10 = false;\n        boolean VAR_11 = false;\n        boolean VAR_12 = false;\n\n        while (VAR_1.inBounds(VAR_8)) {\n            char VAR_13 = VAR_1.charAt(VAR_8);\n\n            if(VAR_11){\n                VAR_11 = false;\n            } else if('\\\\' == VAR_13){\n                VAR_11 = true;\n            } else if (VAR_13 == VAR_14 && !VAR_10) {\n                if (VAR_12){\n                  fail(\"Found empty property at index \"+VAR_8);\n                }\n                break;\n            } else if (VAR_13 == VAR_3) {\n                if (VAR_10) {\n                    char VAR_15 = VAR_1.nextSignificantChar(VAR_8);\n                    if (VAR_15 != VAR_14 && VAR_15 != VAR_16) {\n                        fail(\"Property must be separated by comma or Property must be terminated close square bracket at index \"+VAR_8);\n                    }\n                    VAR_9 = VAR_8;\n                    String VAR_17 = VAR_1.subSequence(VAR_7, VAR_9).toString();\n                    VAR_6.add(VAR_18.unescape(VAR_17));\n                    VAR_10 = false;\n                } else {\n                    VAR_7 = VAR_8 + 1;\n                    VAR_10 = true;\n                    VAR_12 = false;\n                }\n            } else if (VAR_13 == VAR_16 && !VAR_10) {\n                if (VAR_12){\n                    fail(\"Found empty property at index \"+VAR_8);\n                }\n                VAR_12 = true;\n            }\n            VAR_8++;\n        }\n\n        if (VAR_10){\n            fail(\"Property has not been closed - missing closing \" + VAR_3);\n        }\n\n        int VAR_19 = VAR_1.indexOfNextSignificantChar(VAR_9, VAR_14) + 1;\n\n        VAR_1.setPosition(VAR_19);\n\n        VAR_0.appendPathToken(VAR_20.createPropertyPathToken(VAR_6, VAR_3));\n\n        return VAR_1.currentIsTail() || readNextToken(VAR_0);\n    }",
  "func_graph_path_before": "json-path/JsonPath/f49ff25e3bad8c8a0c853058181f2c00b5beb305/PathCompiler.java/vul/before/0.json",
  "func": "private boolean readBracketPropertyToken(PathTokenAppender appender) {\n        if (!path.currentCharIs(OPEN_SQUARE_BRACKET)) {\n            return false;\n        }\n        char potentialStringDelimiter = path.nextSignificantChar();\n        if (potentialStringDelimiter != SINGLE_QUOTE && potentialStringDelimiter != DOUBLE_QUOTE) {\n          return false;\n        }\n\n        List<String> properties = new ArrayList<String>();\n\n        int startPosition = path.position() + 1;\n        int readPosition = startPosition;\n        int endPosition = 0;\n        boolean inProperty = false;\n        boolean inEscape = false;\n        boolean lastSignificantWasComma = false;\n\n        while (path.inBounds(readPosition)) {\n            char c = path.charAt(readPosition);\n\n            if(inEscape){\n                inEscape = false;\n            } else if('\\\\' == c){\n                inEscape = true;\n            } else if (c == CLOSE_SQUARE_BRACKET && !inProperty) {\n                if (lastSignificantWasComma){\n                  fail(\"Found empty property at index \"+readPosition);\n                }\n                break;\n            } else if (c == potentialStringDelimiter) {\n                if (inProperty) {\n                    char nextSignificantChar = path.nextSignificantChar(readPosition);\n                    if (nextSignificantChar != CLOSE_SQUARE_BRACKET && nextSignificantChar != COMMA) {\n                        fail(\"Property must be separated by comma or Property must be terminated close square bracket at index \"+readPosition);\n                    }\n                    endPosition = readPosition;\n                    String prop = path.subSequence(startPosition, endPosition).toString();\n                    properties.add(Utils.unescape(prop));\n                    inProperty = false;\n                } else {\n                    startPosition = readPosition + 1;\n                    inProperty = true;\n                    lastSignificantWasComma = false;\n                }\n            } else if (c == COMMA && !inProperty) {\n                if (lastSignificantWasComma){\n                    fail(\"Found empty property at index \"+readPosition);\n                }\n                lastSignificantWasComma = true;\n            }\n            readPosition++;\n        }\n\n        if (inProperty){\n            fail(\"Property has not been closed - missing closing \" + potentialStringDelimiter);\n        }\n\n        int endBracketIndex = path.indexOfNextSignificantChar(endPosition, CLOSE_SQUARE_BRACKET);\n        if(endBracketIndex == -1) {\n            fail(\"Property has not been closed - missing closing ]\");\n        }\n        endBracketIndex++;\n\n        path.setPosition(endBracketIndex);\n\n        appender.appendPathToken(PathTokenFactory.createPropertyPathToken(properties, potentialStringDelimiter));\n\n        return path.currentIsTail() || readNextToken(appender);\n    }",
  "abstract_func": "private boolean readBracketPropertyToken(PathTokenAppender VAR_0) {\n        if (!VAR_1.currentCharIs(VAR_2)) {\n            return false;\n        }\n        char VAR_3 = VAR_1.nextSignificantChar();\n        if (VAR_3 != VAR_4 && VAR_3 != VAR_5) {\n          return false;\n        }\n\n        List<String> VAR_6 = new ArrayList<String>();\n\n        int VAR_7 = VAR_1.position() + 1;\n        int VAR_8 = VAR_7;\n        int VAR_9 = 0;\n        boolean VAR_10 = false;\n        boolean VAR_11 = false;\n        boolean VAR_12 = false;\n\n        while (VAR_1.inBounds(VAR_8)) {\n            char VAR_13 = VAR_1.charAt(VAR_8);\n\n            if(VAR_11){\n                VAR_11 = false;\n            } else if('\\\\' == VAR_13){\n                VAR_11 = true;\n            } else if (VAR_13 == VAR_14 && !VAR_10) {\n                if (VAR_12){\n                  fail(\"Found empty property at index \"+VAR_8);\n                }\n                break;\n            } else if (VAR_13 == VAR_3) {\n                if (VAR_10) {\n                    char VAR_15 = VAR_1.nextSignificantChar(VAR_8);\n                    if (VAR_15 != VAR_14 && VAR_15 != VAR_16) {\n                        fail(\"Property must be separated by comma or Property must be terminated close square bracket at index \"+VAR_8);\n                    }\n                    VAR_9 = VAR_8;\n                    String VAR_17 = VAR_1.subSequence(VAR_7, VAR_9).toString();\n                    VAR_6.add(VAR_18.unescape(VAR_17));\n                    VAR_10 = false;\n                } else {\n                    VAR_7 = VAR_8 + 1;\n                    VAR_10 = true;\n                    VAR_12 = false;\n                }\n            } else if (VAR_13 == VAR_16 && !VAR_10) {\n                if (VAR_12){\n                    fail(\"Found empty property at index \"+VAR_8);\n                }\n                VAR_12 = true;\n            }\n            VAR_8++;\n        }\n\n        if (VAR_10){\n            fail(\"Property has not been closed - missing closing \" + VAR_3);\n        }\n\n        int VAR_19 = VAR_1.indexOfNextSignificantChar(VAR_9, VAR_14);\n        if(VAR_19 == -1) {\n            fail(\"Property has not been closed - missing closing ]\");\n        }\n        VAR_19++;\n\n        VAR_1.setPosition(VAR_19);\n\n        VAR_0.appendPathToken(VAR_20.createPropertyPathToken(VAR_6, VAR_3));\n\n        return VAR_1.currentIsTail() || readNextToken(VAR_0);\n    }",
  "func_graph_path": "json-path/JsonPath/f49ff25e3bad8c8a0c853058181f2c00b5beb305/PathCompiler.java/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -56,7 +56,11 @@\n             fail(\"Property has not been closed - missing closing \" + potentialStringDelimiter);\n         }\n \n-        int endBracketIndex = path.indexOfNextSignificantChar(endPosition, CLOSE_SQUARE_BRACKET) + 1;\n+        int endBracketIndex = path.indexOfNextSignificantChar(endPosition, CLOSE_SQUARE_BRACKET);\n+        if(endBracketIndex == -1) {\n+            fail(\"Property has not been closed - missing closing ]\");\n+        }\n+        endBracketIndex++;\n \n         path.setPosition(endBracketIndex);\n ",
  "diff_line_info": {
    "deleted_lines": [
      "        int endBracketIndex = path.indexOfNextSignificantChar(endPosition, CLOSE_SQUARE_BRACKET) + 1;"
    ],
    "added_lines": [
      "        int endBracketIndex = path.indexOfNextSignificantChar(endPosition, CLOSE_SQUARE_BRACKET);",
      "        if(endBracketIndex == -1) {",
      "            fail(\"Property has not been closed - missing closing ]\");",
      "        }",
      "        endBracketIndex++;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/json-path/JsonPath/pull/985",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/json-path/JsonPath/pull/985: 403 Client Error: Forbidden for url: https://api.github.com/repos/json-path/JsonPath/pulls/985",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95"
}