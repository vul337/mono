{
  "cve_id": "CVE-2020-13962",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "mumble-voip/mumble",
  "commit_msg": "src/murmur/Server.cpp: implement workaround for critical QSslSocket issue\n\nA severe bug was introduced in qt/qtbase@93a803a6de27d9eb57931c431b5f3d074914f693: q_SSL_shutdown() causes Qt to emit \"error()\" from unrelated QSslSocket(s), in addition to the correct one.\n\nThe issue causes Server::connectionClosed() to disconnect random authenticated clients.\n\nThe workaround consists in ignoring a specific OpenSSL error:\n\"Error while reading: error:140E0197:SSL routines:SSL_shutdown:shutdown while in init [20]\"\n\nDefinitely not ideal, but it fixes a critical vulnerability. Details on how to trigger it are deliberately omitted.",
  "commit_hash": "a48aea18b6c7ee534cd21f7febfe253e31b33eda",
  "git_url": "https://github.com/mumble-voip/mumble/commit/a48aea18b6c7ee534cd21f7febfe253e31b33eda",
  "file_path": "src/murmur/Server.cpp",
  "func_name": "Server::connectionClosed",
  "func_before": "void Server::connectionClosed(QAbstractSocket::SocketError err, const QString &reason) {\n\tConnection *c = qobject_cast<Connection *>(sender());\n\tif (! c)\n\t\treturn;\n\tif (c->bDisconnectedEmitted)\n\t\treturn;\n\tc->bDisconnectedEmitted = true;\n\n\tServerUser *u = static_cast<ServerUser *>(c);\n\n\tlog(u, QString(\"Connection closed: %1 [%2]\").arg(reason).arg(err));\n\n\tif (u->sState == ServerUser::Authenticated) {\n\t\tMumbleProto::UserRemove mpur;\n\t\tmpur.set_session(u->uiSession);\n\t\tsendExcept(u, mpur);\n\n\t\temit userDisconnected(u);\n\t}\n\n\tChannel *old = u->cChannel;\n\n\t{\n\t\tQWriteLocker wl(&qrwlVoiceThread);\n\n\t\tqhUsers.remove(u->uiSession);\n\t\tqhHostUsers[u->haAddress].remove(u);\n\n\t\tquint16 port = (u->saiUdpAddress.ss_family == AF_INET6) ? (reinterpret_cast<sockaddr_in6 *>(&u->saiUdpAddress)->sin6_port) : (reinterpret_cast<sockaddr_in *>(&u->saiUdpAddress)->sin_port);\n\t\tconst QPair<HostAddress, quint16> &key = QPair<HostAddress, quint16>(u->haAddress, port);\n\t\tqhPeerUsers.remove(key);\n\n\t\tif (old)\n\t\t\told->removeUser(u);\n\t}\n\n\tif (old && old->bTemporary && old->qlUsers.isEmpty())\n\t\tQCoreApplication::instance()->postEvent(this, new ExecEvent(boost::bind(&Server::removeChannel, this, old->iId)));\n\n\tif (static_cast<int>(u->uiSession) < iMaxUsers * 2)\n\t\tqqIds.enqueue(u->uiSession); // Reinsert session id into pool\n\n\tif (u->sState == ServerUser::Authenticated) {\n\t\tclearTempGroups(u); // Also clears ACL cache\n\t\trecheckCodecVersions(); // Maybe can choose a better codec now\n\t}\n\n\tu->deleteLater();\n\n\tif (qhUsers.isEmpty())\n\t\tstopThread();\n}",
  "abstract_func_before": "void Server::connectionClosed(QAbstractSocket::SocketError VAR_0, const QString &VAR_1) {\n\tConnection *VAR_2 = VAR_3<Connection *>(sender());\n\tif (! VAR_2)\n\t\treturn;\n\tif (VAR_2->bDisconnectedEmitted)\n\t\treturn;\n\tVAR_2->bDisconnectedEmitted = true;\n\n\tServerUser *VAR_4 = VAR_5<ServerUser *>(VAR_2);\n\n\tlog(VAR_4, QString(\"Connection closed: %1 [%2]\").arg(VAR_1).arg(VAR_0));\n\n\tif (VAR_4->sState == ServerUser::Authenticated) {\n\t\tMumbleProto::UserRemove VAR_6;\n\t\tVAR_6.set_session(VAR_4->uiSession);\n\t\tsendExcept(VAR_4, VAR_6);\n\n\t\temit userDisconnected(u);\n\t}\n\n\tChannel *VAR_7 = u->cChannel;\n\n\t{\n\t\tQWriteLocker VAR_8(&VAR_9);\n\n\t\tVAR_10.remove(u->uiSession);\n\t\tVAR_11[u->haAddress].remove(u);\n\n\t\tquint16 VAR_12 = (u->saiUdpAddress.ss_family == VAR_13) ? (VAR_14<sockaddr_in6 *>(&u->saiUdpAddress)->sin6_port) : (VAR_14<sockaddr_in *>(&u->saiUdpAddress)->sin_port);\n\t\tconst QPair<HostAddress, quint16> &VAR_15 = QPair<HostAddress, quint16>(u->haAddress, VAR_12);\n\t\tVAR_16.remove(VAR_15);\n\n\t\tif (VAR_7)\n\t\t\tVAR_7->removeUser(u);\n\t}\n\n\tif (VAR_7 && VAR_7->bTemporary && VAR_7->qlUsers.isEmpty())\n\t\tQCoreApplication::instance()->postEvent(this, new ExecEvent(boost::bind(&Server::removeChannel, this, VAR_7->iId)));\n\n\tif (VAR_5<int>(u->uiSession) < VAR_17 * 2)\n\t\tVAR_18.enqueue(u->uiSession); /* COMMENT_0 */\n\n\tif (u->sState == ServerUser::Authenticated) {\n\t\tclearTempGroups(u); /* COMMENT_1 */\n\t\trecheckCodecVersions(); /* COMMENT_2 */\n\t}\n\n\tu->deleteLater();\n\n\tif (VAR_10.isEmpty())\n\t\tstopThread();\n}",
  "func_graph_path_before": "mumble-voip/mumble/a48aea18b6c7ee534cd21f7febfe253e31b33eda/Server.cpp/vul/before/0.json",
  "func": "void Server::connectionClosed(QAbstractSocket::SocketError err, const QString &reason) {\n\tif (reason.contains(QLatin1String(\"140E0197\"))) {\n\t\t// A severe bug was introduced in qt/qtbase@93a803a6de27d9eb57931c431b5f3d074914f693.\n\t\t// q_SSL_shutdown() causes Qt to emit \"error()\" from unrelated QSslSocket(s), in addition to the correct one.\n\t\t// The issue causes this function to disconnect random authenticated clients.\n\t\t//\n\t\t// The workaround consists in ignoring a specific OpenSSL error:\n\t\t// \"Error while reading: error:140E0197:SSL routines:SSL_shutdown:shutdown while in init [20]\"\n\t\t//\n\t\t// Definitely not ideal, but it fixes a critical vulnerability.\n\t\tqWarning(\"Ignored OpenSSL error 140E0197 for %p\", sender());\n\t\treturn;\n\t}\n\n\tConnection *c = qobject_cast<Connection *>(sender());\n\tif (! c)\n\t\treturn;\n\tif (c->bDisconnectedEmitted)\n\t\treturn;\n\tc->bDisconnectedEmitted = true;\n\n\tServerUser *u = static_cast<ServerUser *>(c);\n\n\tlog(u, QString(\"Connection closed: %1 [%2]\").arg(reason).arg(err));\n\n\tif (u->sState == ServerUser::Authenticated) {\n\t\tMumbleProto::UserRemove mpur;\n\t\tmpur.set_session(u->uiSession);\n\t\tsendExcept(u, mpur);\n\n\t\temit userDisconnected(u);\n\t}\n\n\tChannel *old = u->cChannel;\n\n\t{\n\t\tQWriteLocker wl(&qrwlVoiceThread);\n\n\t\tqhUsers.remove(u->uiSession);\n\t\tqhHostUsers[u->haAddress].remove(u);\n\n\t\tquint16 port = (u->saiUdpAddress.ss_family == AF_INET6) ? (reinterpret_cast<sockaddr_in6 *>(&u->saiUdpAddress)->sin6_port) : (reinterpret_cast<sockaddr_in *>(&u->saiUdpAddress)->sin_port);\n\t\tconst QPair<HostAddress, quint16> &key = QPair<HostAddress, quint16>(u->haAddress, port);\n\t\tqhPeerUsers.remove(key);\n\n\t\tif (old)\n\t\t\told->removeUser(u);\n\t}\n\n\tif (old && old->bTemporary && old->qlUsers.isEmpty())\n\t\tQCoreApplication::instance()->postEvent(this, new ExecEvent(boost::bind(&Server::removeChannel, this, old->iId)));\n\n\tif (static_cast<int>(u->uiSession) < iMaxUsers * 2)\n\t\tqqIds.enqueue(u->uiSession); // Reinsert session id into pool\n\n\tif (u->sState == ServerUser::Authenticated) {\n\t\tclearTempGroups(u); // Also clears ACL cache\n\t\trecheckCodecVersions(); // Maybe can choose a better codec now\n\t}\n\n\tu->deleteLater();\n\n\tif (qhUsers.isEmpty())\n\t\tstopThread();\n}",
  "abstract_func": "void Server::connectionClosed(QAbstractSocket::SocketError VAR_0, const QString &VAR_1) {\n\tif (VAR_1.contains(QLatin1String(\"140E0197\"))) {\n\t\t/* COMMENT_0 */\n\t\t/* COMMENT_1 */\n\t\t/* COMMENT_2 */\n\t\t/* COMMENT_3 */\n\t\t/* COMMENT_4 */\n\t\t/* COMMENT_5 */\n\t\t/* COMMENT_3 */\n\t\t/* COMMENT_6 */\n\t\tqWarning(\"Ignored OpenSSL error 140E0197 for %p\", sender());\n\t\treturn;\n\t}\n\n\tConnection *VAR_2 = VAR_3<Connection *>(sender());\n\tif (! VAR_2)\n\t\treturn;\n\tif (VAR_2->bDisconnectedEmitted)\n\t\treturn;\n\tVAR_2->bDisconnectedEmitted = true;\n\n\tServerUser *VAR_4 = VAR_5<ServerUser *>(VAR_2);\n\n\tlog(VAR_4, QString(\"Connection closed: %1 [%2]\").arg(VAR_1).arg(VAR_0));\n\n\tif (VAR_4->sState == ServerUser::Authenticated) {\n\t\tMumbleProto::UserRemove VAR_6;\n\t\tVAR_6.set_session(VAR_4->uiSession);\n\t\tsendExcept(VAR_4, VAR_6);\n\n\t\temit userDisconnected(u);\n\t}\n\n\tChannel *VAR_7 = u->cChannel;\n\n\t{\n\t\tQWriteLocker VAR_8(&VAR_9);\n\n\t\tVAR_10.remove(u->uiSession);\n\t\tVAR_11[u->haAddress].remove(u);\n\n\t\tquint16 VAR_12 = (u->saiUdpAddress.ss_family == VAR_13) ? (VAR_14<sockaddr_in6 *>(&u->saiUdpAddress)->sin6_port) : (VAR_14<sockaddr_in *>(&u->saiUdpAddress)->sin_port);\n\t\tconst QPair<HostAddress, quint16> &VAR_15 = QPair<HostAddress, quint16>(u->haAddress, VAR_12);\n\t\tVAR_16.remove(VAR_15);\n\n\t\tif (VAR_7)\n\t\t\tVAR_7->removeUser(u);\n\t}\n\n\tif (VAR_7 && VAR_7->bTemporary && VAR_7->qlUsers.isEmpty())\n\t\tQCoreApplication::instance()->postEvent(this, new ExecEvent(boost::bind(&Server::removeChannel, this, VAR_7->iId)));\n\n\tif (VAR_5<int>(u->uiSession) < VAR_17 * 2)\n\t\tVAR_18.enqueue(u->uiSession); /* COMMENT_7 */\n\n\tif (u->sState == ServerUser::Authenticated) {\n\t\tclearTempGroups(u); /* COMMENT_8 */\n\t\trecheckCodecVersions(); /* COMMENT_9 */\n\t}\n\n\tu->deleteLater();\n\n\tif (VAR_10.isEmpty())\n\t\tstopThread();\n}",
  "func_graph_path": "mumble-voip/mumble/a48aea18b6c7ee534cd21f7febfe253e31b33eda/Server.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,17 @@\n void Server::connectionClosed(QAbstractSocket::SocketError err, const QString &reason) {\n+\tif (reason.contains(QLatin1String(\"140E0197\"))) {\n+\t\t// A severe bug was introduced in qt/qtbase@93a803a6de27d9eb57931c431b5f3d074914f693.\n+\t\t// q_SSL_shutdown() causes Qt to emit \"error()\" from unrelated QSslSocket(s), in addition to the correct one.\n+\t\t// The issue causes this function to disconnect random authenticated clients.\n+\t\t//\n+\t\t// The workaround consists in ignoring a specific OpenSSL error:\n+\t\t// \"Error while reading: error:140E0197:SSL routines:SSL_shutdown:shutdown while in init [20]\"\n+\t\t//\n+\t\t// Definitely not ideal, but it fixes a critical vulnerability.\n+\t\tqWarning(\"Ignored OpenSSL error 140E0197 for %p\", sender());\n+\t\treturn;\n+\t}\n+\n \tConnection *c = qobject_cast<Connection *>(sender());\n \tif (! c)\n \t\treturn;",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "\tif (reason.contains(QLatin1String(\"140E0197\"))) {",
      "\t\t// A severe bug was introduced in qt/qtbase@93a803a6de27d9eb57931c431b5f3d074914f693.",
      "\t\t// q_SSL_shutdown() causes Qt to emit \"error()\" from unrelated QSslSocket(s), in addition to the correct one.",
      "\t\t// The issue causes this function to disconnect random authenticated clients.",
      "\t\t//",
      "\t\t// The workaround consists in ignoring a specific OpenSSL error:",
      "\t\t// \"Error while reading: error:140E0197:SSL routines:SSL_shutdown:shutdown while in init [20]\"",
      "\t\t//",
      "\t\t// Definitely not ideal, but it fixes a critical vulnerability.",
      "\t\tqWarning(\"Ignored OpenSSL error 140E0197 for %p\", sender());",
      "\t\treturn;",
      "\t}",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/mumble-voip/mumble/pull/4032",
  "description": {
    "pr_info": {
      "title": "src/murmur/Server.cpp: implement workaround for critical QSslSocket issue",
      "number": 4032
    },
    "comment": [
      "Fixes #3679.\r\n\r\n---\r\n\r\nA severe bug was introduced in qt/qtbase@93a803a6de27d9eb57931c431b5f3d074914f693: `q_SSL_shutdown()` causes Qt to emit `error()` from unrelated `QSslSocket`(s), in addition to the correct one.\r\n\r\nThe issue causes `Server::connectionClosed()` to disconnect random authenticated clients.\r\n\r\nThe workaround consists in ignoring a specific OpenSSL error:\r\n> Error while reading: error:140E0197:SSL routines:SSL_shutdown:shutdown while in init [20]\r\n\r\nDefinitely not ideal, but it fixes a critical vulnerability. Details on how to trigger it are deliberately omitted.",
      "Is there plans for an emergency release with this fix?",
      "Not really an emergency release, but 1.3.1 is coming up soon anyways. And this fix will be included ;)",
      "I guess this commit fix it: https://github.com/qt/qtbase/commit/8907635da59c2ae0e8db01f27b24a841b830e655",
      "Yes, indeed."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Step1: Input Analysis**  \nThe commit message and vulnerability description both mention a severe bug in QSslSocket, which can cause random authenticated clients to be disconnected. The code diff shows a workaround that ignores a specific OpenSSL error to fix this issue.\n\n**Step2: Consistency Check**  \nThe commit message and code changes align well. The code adds a condition to ignore a specific SSL error, and the commit explains it as a critical vulnerability fix.\n\n**Step3: Purpose Evaluation**  \nThe patch modifies the `connectionClosed` function to handle a specific SSL error, preventing unintended disconnections. This addresses a security vulnerability.\n\n**Step4: Security Vulnerability Assessment**  \nThe issue involves SSL operations and preventing clients from being disconnected, which is a security concern. The description explicitly states it's a critical vulnerability.\n\n**Step5: Non-Security Classification**  \nNot applicable, as it's a security fix.\n\n**Step6: Confidence Scoring**  \nConfidence is high (0.95) due to clear indications of a security vulnerability being addressed.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95"
}