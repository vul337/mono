{
  "cve_id": "CVE-2023-6563",
  "cwe_ids": [
    "CWE-770"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "keycloak",
  "commit_msg": "Fix performance issues with many offline sessions\n\nFixes: #13340",
  "commit_hash": "11eb952e1df7cbb95b1e2c101dfd4839a2375695",
  "git_url": "https://github.com/keycloak/keycloak/commit/11eb952e1df7cbb95b1e2c101dfd4839a2375695",
  "file_path": "model/jpa/src/main/java/org/keycloak/models/jpa/session/JpaUserSessionPersisterProvider.java",
  "func_name": "loadUserSessionsWithClientSessions",
  "func_before": "private Stream<UserSessionModel> loadUserSessionsWithClientSessions(TypedQuery<PersistentUserSessionEntity> query, String offlineStr) {\n\n        List<PersistentUserSessionAdapter> userSessionAdapters = closing(query.getResultStream()\n                .map(this::toAdapter)\n                .filter(Objects::nonNull))\n                .collect(Collectors.toList());\n\n        Map<String, PersistentUserSessionAdapter> sessionsById = userSessionAdapters.stream()\n                .collect(Collectors.toMap(UserSessionModel::getId, Function.identity()));\n\n        Set<String> removedClientUUIDs = new HashSet<>();\n\n        if (!sessionsById.isEmpty()) {\n            String fromUserSessionId = userSessionAdapters.get(0).getId();\n            String toUserSessionId = userSessionAdapters.get(userSessionAdapters.size() - 1).getId();\n\n            TypedQuery<PersistentClientSessionEntity> queryClientSessions = em.createNamedQuery(\"findClientSessionsOrderedById\", PersistentClientSessionEntity.class);\n            queryClientSessions.setParameter(\"offline\", offlineStr);\n            queryClientSessions.setParameter(\"fromSessionId\", fromUserSessionId);\n            queryClientSessions.setParameter(\"toSessionId\", toUserSessionId);\n\n            closing(queryClientSessions.getResultStream()).forEach(clientSession -> {\n                PersistentUserSessionAdapter userSession = sessionsById.get(clientSession.getUserSessionId());\n                // check if we have a user session for the client session\n                if (userSession != null) {\n                    boolean added = addClientSessionToAuthenticatedClientSessionsIfPresent(userSession, clientSession);\n                    if (!added) {\n                        // client was removed in the meantime\n                        removedClientUUIDs.add(clientSession.getClientId());\n                    }\n                }\n            });\n        }\n\n        for (String clientUUID : removedClientUUIDs) {\n            onClientRemoved(clientUUID);\n        }\n\n        return userSessionAdapters.stream().map(UserSessionModel.class::cast);\n    }",
  "abstract_func_before": "private Stream<UserSessionModel> loadUserSessionsWithClientSessions(TypedQuery<PersistentUserSessionEntity> VAR_0, String VAR_1) {\n\n        List<PersistentUserSessionAdapter> VAR_2 = closing(VAR_0.getResultStream()\n                .map(this::VAR_3)\n                .filter(VAR_4::VAR_5))\n                .collect(VAR_6.toList());\n\n        Map<String, PersistentUserSessionAdapter> VAR_7 = VAR_2.stream()\n                .collect(VAR_6.toMap(VAR_8::VAR_9, VAR_10.identity()));\n\n        Set<String> VAR_11 = new HashSet<>();\n\n        if (!VAR_7.isEmpty()) {\n            String VAR_12 = VAR_2.get(0).getId();\n            String VAR_13 = VAR_2.get(VAR_2.size() - 1).getId();\n\n            TypedQuery<PersistentClientSessionEntity> VAR_14 = VAR_15.createNamedQuery(\"findClientSessionsOrderedById\", PersistentClientSessionEntity.class);\n            VAR_14.setParameter(\"offline\", VAR_1);\n            VAR_14.setParameter(\"fromSessionId\", VAR_12);\n            VAR_14.setParameter(\"toSessionId\", VAR_13);\n\n            closing(VAR_14.getResultStream()).forEach(VAR_16 -> {\n                PersistentUserSessionAdapter VAR_17 = VAR_7.get(VAR_16.getUserSessionId());\n                /* COMMENT_0 */\n                if (VAR_17 != null) {\n                    boolean VAR_18 = addClientSessionToAuthenticatedClientSessionsIfPresent(VAR_17, VAR_16);\n                    if (!VAR_18) {\n                        /* COMMENT_1 */\n                        VAR_11.add(VAR_16.getClientId());\n                    }\n                }\n            });\n        }\n\n        for (String VAR_19 : VAR_11) {\n            onClientRemoved(VAR_19);\n        }\n\n        return VAR_2.stream().map(UserSessionModel.class::VAR_20);\n    }",
  "func_graph_path_before": "keycloak/11eb952e1df7cbb95b1e2c101dfd4839a2375695/JpaUserSessionPersisterProvider.java/vul/before/3.json",
  "func": "private Stream<UserSessionModel> loadUserSessionsWithClientSessions(TypedQuery<PersistentUserSessionEntity> query, String offlineStr, boolean useExact) {\n\n        List<PersistentUserSessionAdapter> userSessionAdapters = closing(query.getResultStream()\n                .map(this::toAdapter)\n                .filter(Objects::nonNull))\n                .collect(Collectors.toList());\n\n        Map<String, PersistentUserSessionAdapter> sessionsById = userSessionAdapters.stream()\n                .collect(Collectors.toMap(UserSessionModel::getId, Function.identity()));\n\n        Set<String> userSessionIds = sessionsById.keySet();\n\n        Set<String> removedClientUUIDs = new HashSet<>();\n\n        if (!sessionsById.isEmpty()) {\n            TypedQuery<PersistentClientSessionEntity> queryClientSessions;\n            if (useExact) {\n                queryClientSessions = em.createNamedQuery(\"findClientSessionsOrderedByIdExact\", PersistentClientSessionEntity.class);\n                queryClientSessions.setParameter(\"offline\", offlineStr);\n                queryClientSessions.setParameter(\"userSessionIds\", userSessionIds);\n            } else {\n                String fromUserSessionId = userSessionAdapters.get(0).getId();\n                String toUserSessionId = userSessionAdapters.get(userSessionAdapters.size() - 1).getId();\n\n                queryClientSessions = em.createNamedQuery(\"findClientSessionsOrderedByIdInterval\", PersistentClientSessionEntity.class);\n                queryClientSessions.setParameter(\"offline\", offlineStr);\n                queryClientSessions.setParameter(\"fromSessionId\", fromUserSessionId);\n                queryClientSessions.setParameter(\"toSessionId\", toUserSessionId);\n            }\n\n            closing(queryClientSessions.getResultStream()).forEach(clientSession -> {\n                PersistentUserSessionAdapter userSession = sessionsById.get(clientSession.getUserSessionId());\n                // check if we have a user session for the client session\n                if (userSession != null) {\n                    boolean added = addClientSessionToAuthenticatedClientSessionsIfPresent(userSession, clientSession);\n                    if (!added) {\n                        // client was removed in the meantime\n                        removedClientUUIDs.add(clientSession.getClientId());\n                    }\n                }\n            });\n        }\n\n        for (String clientUUID : removedClientUUIDs) {\n            onClientRemoved(clientUUID);\n        }\n\n        return userSessionAdapters.stream().map(UserSessionModel.class::cast);\n    }",
  "abstract_func": "private Stream<UserSessionModel> loadUserSessionsWithClientSessions(TypedQuery<PersistentUserSessionEntity> VAR_0, String VAR_1, boolean VAR_2) {\n\n        List<PersistentUserSessionAdapter> VAR_3 = closing(VAR_0.getResultStream()\n                .map(this::VAR_4)\n                .filter(VAR_5::VAR_6))\n                .collect(VAR_7.toList());\n\n        Map<String, PersistentUserSessionAdapter> VAR_8 = VAR_3.stream()\n                .collect(VAR_7.toMap(VAR_9::VAR_10, VAR_11.identity()));\n\n        Set<String> VAR_12 = VAR_8.keySet();\n\n        Set<String> VAR_13 = new HashSet<>();\n\n        if (!VAR_8.isEmpty()) {\n            TypedQuery<PersistentClientSessionEntity> VAR_14;\n            if (VAR_2) {\n                VAR_14 = VAR_15.createNamedQuery(\"findClientSessionsOrderedByIdExact\", PersistentClientSessionEntity.class);\n                VAR_14.setParameter(\"offline\", VAR_1);\n                VAR_14.setParameter(\"userSessionIds\", VAR_12);\n            } else {\n                String VAR_16 = VAR_3.get(0).getId();\n                String VAR_17 = VAR_3.get(VAR_3.size() - 1).getId();\n\n                VAR_14 = VAR_15.createNamedQuery(\"findClientSessionsOrderedByIdInterval\", PersistentClientSessionEntity.class);\n                VAR_14.setParameter(\"offline\", VAR_1);\n                VAR_14.setParameter(\"fromSessionId\", VAR_16);\n                VAR_14.setParameter(\"toSessionId\", VAR_17);\n            }\n\n            closing(VAR_14.getResultStream()).forEach(VAR_18 -> {\n                PersistentUserSessionAdapter VAR_19 = VAR_8.get(VAR_18.getUserSessionId());\n                /* COMMENT_0 */\n                if (VAR_19 != null) {\n                    boolean VAR_20 = addClientSessionToAuthenticatedClientSessionsIfPresent(VAR_19, VAR_18);\n                    if (!VAR_20) {\n                        /* COMMENT_1 */\n                        VAR_13.add(VAR_18.getClientId());\n                    }\n                }\n            });\n        }\n\n        for (String VAR_21 : VAR_13) {\n            onClientRemoved(VAR_21);\n        }\n\n        return VAR_3.stream().map(UserSessionModel.class::VAR_22);\n    }",
  "func_graph_path": "keycloak/11eb952e1df7cbb95b1e2c101dfd4839a2375695/JpaUserSessionPersisterProvider.java/vul/after/3.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-private Stream<UserSessionModel> loadUserSessionsWithClientSessions(TypedQuery<PersistentUserSessionEntity> query, String offlineStr) {\n+private Stream<UserSessionModel> loadUserSessionsWithClientSessions(TypedQuery<PersistentUserSessionEntity> query, String offlineStr, boolean useExact) {\n \n         List<PersistentUserSessionAdapter> userSessionAdapters = closing(query.getResultStream()\n                 .map(this::toAdapter)\n@@ -8,16 +8,25 @@\n         Map<String, PersistentUserSessionAdapter> sessionsById = userSessionAdapters.stream()\n                 .collect(Collectors.toMap(UserSessionModel::getId, Function.identity()));\n \n+        Set<String> userSessionIds = sessionsById.keySet();\n+\n         Set<String> removedClientUUIDs = new HashSet<>();\n \n         if (!sessionsById.isEmpty()) {\n-            String fromUserSessionId = userSessionAdapters.get(0).getId();\n-            String toUserSessionId = userSessionAdapters.get(userSessionAdapters.size() - 1).getId();\n+            TypedQuery<PersistentClientSessionEntity> queryClientSessions;\n+            if (useExact) {\n+                queryClientSessions = em.createNamedQuery(\"findClientSessionsOrderedByIdExact\", PersistentClientSessionEntity.class);\n+                queryClientSessions.setParameter(\"offline\", offlineStr);\n+                queryClientSessions.setParameter(\"userSessionIds\", userSessionIds);\n+            } else {\n+                String fromUserSessionId = userSessionAdapters.get(0).getId();\n+                String toUserSessionId = userSessionAdapters.get(userSessionAdapters.size() - 1).getId();\n \n-            TypedQuery<PersistentClientSessionEntity> queryClientSessions = em.createNamedQuery(\"findClientSessionsOrderedById\", PersistentClientSessionEntity.class);\n-            queryClientSessions.setParameter(\"offline\", offlineStr);\n-            queryClientSessions.setParameter(\"fromSessionId\", fromUserSessionId);\n-            queryClientSessions.setParameter(\"toSessionId\", toUserSessionId);\n+                queryClientSessions = em.createNamedQuery(\"findClientSessionsOrderedByIdInterval\", PersistentClientSessionEntity.class);\n+                queryClientSessions.setParameter(\"offline\", offlineStr);\n+                queryClientSessions.setParameter(\"fromSessionId\", fromUserSessionId);\n+                queryClientSessions.setParameter(\"toSessionId\", toUserSessionId);\n+            }\n \n             closing(queryClientSessions.getResultStream()).forEach(clientSession -> {\n                 PersistentUserSessionAdapter userSession = sessionsById.get(clientSession.getUserSessionId());",
  "diff_line_info": {
    "deleted_lines": [
      "private Stream<UserSessionModel> loadUserSessionsWithClientSessions(TypedQuery<PersistentUserSessionEntity> query, String offlineStr) {",
      "            String fromUserSessionId = userSessionAdapters.get(0).getId();",
      "            String toUserSessionId = userSessionAdapters.get(userSessionAdapters.size() - 1).getId();",
      "            TypedQuery<PersistentClientSessionEntity> queryClientSessions = em.createNamedQuery(\"findClientSessionsOrderedById\", PersistentClientSessionEntity.class);",
      "            queryClientSessions.setParameter(\"offline\", offlineStr);",
      "            queryClientSessions.setParameter(\"fromSessionId\", fromUserSessionId);",
      "            queryClientSessions.setParameter(\"toSessionId\", toUserSessionId);"
    ],
    "added_lines": [
      "private Stream<UserSessionModel> loadUserSessionsWithClientSessions(TypedQuery<PersistentUserSessionEntity> query, String offlineStr, boolean useExact) {",
      "        Set<String> userSessionIds = sessionsById.keySet();",
      "",
      "            TypedQuery<PersistentClientSessionEntity> queryClientSessions;",
      "            if (useExact) {",
      "                queryClientSessions = em.createNamedQuery(\"findClientSessionsOrderedByIdExact\", PersistentClientSessionEntity.class);",
      "                queryClientSessions.setParameter(\"offline\", offlineStr);",
      "                queryClientSessions.setParameter(\"userSessionIds\", userSessionIds);",
      "            } else {",
      "                String fromUserSessionId = userSessionAdapters.get(0).getId();",
      "                String toUserSessionId = userSessionAdapters.get(userSessionAdapters.size() - 1).getId();",
      "                queryClientSessions = em.createNamedQuery(\"findClientSessionsOrderedByIdInterval\", PersistentClientSessionEntity.class);",
      "                queryClientSessions.setParameter(\"offline\", offlineStr);",
      "                queryClientSessions.setParameter(\"fromSessionId\", fromUserSessionId);",
      "                queryClientSessions.setParameter(\"toSessionId\", toUserSessionId);",
      "            }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/keycloak/keycloak/pull/15463",
  "description": {
    "pr_info": {
      "title": "Fix performance issues with many offline sessions",
      "number": 15463
    },
    "comment": [
      "Fixes: #13340\r\n\r\nPipeline run: https://master-jenkins.redhat.com/job/universal-test-pipeline-server/2385/\r\n<!---\r\nPlease read https://github.com/keycloak/keycloak/blob/main/CONTRIBUTING.md and follow these guidelines when contributing to Keycloak\r\n-->\r\n",
      "Thanks for the PR. I have been thinking about this a bit and here are my thoughts: \r\nShould we be worried about reintroducing IN-clause which was removed in last performance optimization [attempt](https://github.com/keycloak/keycloak/pull/8012)? If the `userSessionsIds` set used in IN-cause gets too big, performance will be probably bad. However, I think we should be OK because `userSessionIds` size should be reasonable. There are these use-cases: \r\n- load user session by user (not limited by first,max parameters as it is called with first=0, max=null, but limited by number of user session which user can has. Not sure if this can be a high number in real scenarios. Maybe yes, if someone creates many offline user sessions for a user by i.e `password` grant type)\r\n- load user sessions by client (this can be a high number but it is called only from services and endpoint is limiting max result size -- 100 by default)\r\n- load user sessions by interval - IN clause not used and method is called only from pre-loading\r\n\r\n@hmlnarik What are your thoughts on this?",
      "> @hmlnarik What are your thoughts on this?\r\n\r\nThank you for the reply. These are exactly the arguments why I am in favour of introducing the `IN` clauses for the cases when the session is known in advance while keeping the interval for preloading, and this PR should reflect it."
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.9"
}