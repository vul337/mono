{
  "cve_id": "CVE-2018-15858",
  "cwe_ids": [
    "CWE-476"
  ],
  "cvss_vector": "AV:L/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "xkbcommon/libxkbcommon",
  "commit_msg": "keycodes: don't try to copy zero key aliases\n\nMove the aliases copy to within the (num_key_aliases > 0) block.\n\nPassing info->aliases into this fuction with invalid aliases will\ncause log messages but num_key_aliases stays on 0. The key_aliases array\nis never allocated and remains NULL. We then loop through the aliases, causing\na null-pointer dereference.\n\nSigned-off-by: Peter Hutterer <peter.hutterer@who-t.net>",
  "commit_hash": "badb428e63387140720f22486b3acbd3d738859f",
  "git_url": "https://github.com/xkbcommon/libxkbcommon/commit/badb428e63387140720f22486b3acbd3d738859f",
  "file_path": "src/xkbcomp/keycodes.c",
  "func_name": "CopyKeyAliasesToKeymap",
  "func_before": "static bool\nCopyKeyAliasesToKeymap(struct xkb_keymap *keymap, KeyNamesInfo *info)\n{\n    AliasInfo *alias;\n    unsigned i, num_key_aliases;\n    struct xkb_key_alias *key_aliases;\n\n    /*\n     * Do some sanity checking on the aliases. We can't do it before\n     * because keys and their aliases may be added out-of-order.\n     */\n    num_key_aliases = 0;\n    darray_foreach(alias, info->aliases) {\n        /* Check that ->real is a key. */\n        if (!XkbKeyByName(keymap, alias->real, false)) {\n            log_vrb(info->ctx, 5,\n                    \"Attempt to alias %s to non-existent key %s; Ignored\\n\",\n                    KeyNameText(info->ctx, alias->alias),\n                    KeyNameText(info->ctx, alias->real));\n            alias->real = XKB_ATOM_NONE;\n            continue;\n        }\n\n        /* Check that ->alias is not a key. */\n        if (XkbKeyByName(keymap, alias->alias, false)) {\n            log_vrb(info->ctx, 5,\n                    \"Attempt to create alias with the name of a real key; \"\n                    \"Alias \\\"%s = %s\\\" ignored\\n\",\n                    KeyNameText(info->ctx, alias->alias),\n                    KeyNameText(info->ctx, alias->real));\n            alias->real = XKB_ATOM_NONE;\n            continue;\n        }\n\n        num_key_aliases++;\n    }\n\n    /* Copy key aliases. */\n    key_aliases = NULL;\n    if (num_key_aliases > 0) {\n        key_aliases = calloc(num_key_aliases, sizeof(*key_aliases));\n        if (!key_aliases)\n            return false;\n    }\n\n    i = 0;\n    darray_foreach(alias, info->aliases) {\n        if (alias->real != XKB_ATOM_NONE) {\n            key_aliases[i].alias = alias->alias;\n            key_aliases[i].real = alias->real;\n            i++;\n        }\n    }\n\n    keymap->num_key_aliases = num_key_aliases;\n    keymap->key_aliases = key_aliases;\n    return true;\n}",
  "abstract_func_before": "static bool\nCopyKeyAliasesToKeymap(struct xkb_keymap *VAR_0, KeyNamesInfo *VAR_1)\n{\n    AliasInfo *VAR_2;\n    unsigned VAR_3, VAR_4;\n    struct xkb_key_alias *VAR_5;\n\n    /* COMMENT_0 */\n                                                                    \n                                                                \n       \n    VAR_4 = 0;\n    darray_foreach(VAR_2, VAR_1->aliases) {\n        /* COMMENT_4 */\n        if (!XkbKeyByName(VAR_0, VAR_2->real, false)) {\n            log_vrb(VAR_1->ctx, 5,\n                    \"Attempt to alias %s to non-existent key %s; Ignored\\n\",\n                    KeyNameText(VAR_1->ctx, VAR_2->alias),\n                    KeyNameText(VAR_1->ctx, VAR_2->real));\n            VAR_2->real = VAR_6;\n            continue;\n        }\n\n        /* COMMENT_5 */\n        if (XkbKeyByName(VAR_0, VAR_2->alias, false)) {\n            log_vrb(VAR_1->ctx, 5,\n                    \"Attempt to create alias with the name of a real key; \"\n                    \"Alias \\\"%s = %s\\\" ignored\\n\",\n                    KeyNameText(VAR_1->ctx, VAR_2->alias),\n                    KeyNameText(VAR_1->ctx, VAR_2->real));\n            VAR_2->real = VAR_6;\n            continue;\n        }\n\n        VAR_4++;\n    }\n\n    /* COMMENT_6 */\n    VAR_5 = NULL;\n    if (VAR_4 > 0) {\n        VAR_5 = calloc(VAR_4, sizeof(*VAR_5));\n        if (!VAR_5)\n            return false;\n    }\n\n    VAR_3 = 0;\n    darray_foreach(VAR_2, VAR_1->aliases) {\n        if (VAR_2->real != VAR_6) {\n            VAR_5[VAR_3].alias = VAR_2->alias;\n            VAR_5[VAR_3].real = VAR_2->real;\n            VAR_3++;\n        }\n    }\n\n    VAR_0->num_key_aliases = VAR_4;\n    VAR_0->key_aliases = VAR_5;\n    return true;\n}",
  "func_graph_path_before": "xkbcommon/libxkbcommon/badb428e63387140720f22486b3acbd3d738859f/keycodes.c/vul/before/0.json",
  "func": "static bool\nCopyKeyAliasesToKeymap(struct xkb_keymap *keymap, KeyNamesInfo *info)\n{\n    AliasInfo *alias;\n    unsigned i, num_key_aliases;\n    struct xkb_key_alias *key_aliases;\n\n    /*\n     * Do some sanity checking on the aliases. We can't do it before\n     * because keys and their aliases may be added out-of-order.\n     */\n    num_key_aliases = 0;\n    darray_foreach(alias, info->aliases) {\n        /* Check that ->real is a key. */\n        if (!XkbKeyByName(keymap, alias->real, false)) {\n            log_vrb(info->ctx, 5,\n                    \"Attempt to alias %s to non-existent key %s; Ignored\\n\",\n                    KeyNameText(info->ctx, alias->alias),\n                    KeyNameText(info->ctx, alias->real));\n            alias->real = XKB_ATOM_NONE;\n            continue;\n        }\n\n        /* Check that ->alias is not a key. */\n        if (XkbKeyByName(keymap, alias->alias, false)) {\n            log_vrb(info->ctx, 5,\n                    \"Attempt to create alias with the name of a real key; \"\n                    \"Alias \\\"%s = %s\\\" ignored\\n\",\n                    KeyNameText(info->ctx, alias->alias),\n                    KeyNameText(info->ctx, alias->real));\n            alias->real = XKB_ATOM_NONE;\n            continue;\n        }\n\n        num_key_aliases++;\n    }\n\n    /* Copy key aliases. */\n    key_aliases = NULL;\n    if (num_key_aliases > 0) {\n        key_aliases = calloc(num_key_aliases, sizeof(*key_aliases));\n        if (!key_aliases)\n            return false;\n\n        i = 0;\n        darray_foreach(alias, info->aliases) {\n            if (alias->real != XKB_ATOM_NONE) {\n                key_aliases[i].alias = alias->alias;\n                key_aliases[i].real = alias->real;\n                i++;\n            }\n        }\n    }\n\n    keymap->num_key_aliases = num_key_aliases;\n    keymap->key_aliases = key_aliases;\n    return true;\n}",
  "abstract_func": "static bool\nCopyKeyAliasesToKeymap(struct xkb_keymap *VAR_0, KeyNamesInfo *VAR_1)\n{\n    AliasInfo *VAR_2;\n    unsigned VAR_3, VAR_4;\n    struct xkb_key_alias *VAR_5;\n\n    /* COMMENT_0 */\n                                                                    \n                                                                \n       \n    VAR_4 = 0;\n    darray_foreach(VAR_2, VAR_1->aliases) {\n        /* COMMENT_4 */\n        if (!XkbKeyByName(VAR_0, VAR_2->real, false)) {\n            log_vrb(VAR_1->ctx, 5,\n                    \"Attempt to alias %s to non-existent key %s; Ignored\\n\",\n                    KeyNameText(VAR_1->ctx, VAR_2->alias),\n                    KeyNameText(VAR_1->ctx, VAR_2->real));\n            VAR_2->real = VAR_6;\n            continue;\n        }\n\n        /* COMMENT_5 */\n        if (XkbKeyByName(VAR_0, VAR_2->alias, false)) {\n            log_vrb(VAR_1->ctx, 5,\n                    \"Attempt to create alias with the name of a real key; \"\n                    \"Alias \\\"%s = %s\\\" ignored\\n\",\n                    KeyNameText(VAR_1->ctx, VAR_2->alias),\n                    KeyNameText(VAR_1->ctx, VAR_2->real));\n            VAR_2->real = VAR_6;\n            continue;\n        }\n\n        VAR_4++;\n    }\n\n    /* COMMENT_6 */\n    VAR_5 = NULL;\n    if (VAR_4 > 0) {\n        VAR_5 = calloc(VAR_4, sizeof(*VAR_5));\n        if (!VAR_5)\n            return false;\n\n        VAR_3 = 0;\n        darray_foreach(VAR_2, VAR_1->aliases) {\n            if (VAR_2->real != VAR_6) {\n                VAR_5[VAR_3].alias = VAR_2->alias;\n                VAR_5[VAR_3].real = VAR_2->real;\n                VAR_3++;\n            }\n        }\n    }\n\n    VAR_0->num_key_aliases = VAR_4;\n    VAR_0->key_aliases = VAR_5;\n    return true;\n}",
  "func_graph_path": "xkbcommon/libxkbcommon/badb428e63387140720f22486b3acbd3d738859f/keycodes.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -41,14 +41,14 @@\n         key_aliases = calloc(num_key_aliases, sizeof(*key_aliases));\n         if (!key_aliases)\n             return false;\n-    }\n \n-    i = 0;\n-    darray_foreach(alias, info->aliases) {\n-        if (alias->real != XKB_ATOM_NONE) {\n-            key_aliases[i].alias = alias->alias;\n-            key_aliases[i].real = alias->real;\n-            i++;\n+        i = 0;\n+        darray_foreach(alias, info->aliases) {\n+            if (alias->real != XKB_ATOM_NONE) {\n+                key_aliases[i].alias = alias->alias;\n+                key_aliases[i].real = alias->real;\n+                i++;\n+            }\n         }\n     }\n ",
  "diff_line_info": {
    "deleted_lines": [
      "    }",
      "    i = 0;",
      "    darray_foreach(alias, info->aliases) {",
      "        if (alias->real != XKB_ATOM_NONE) {",
      "            key_aliases[i].alias = alias->alias;",
      "            key_aliases[i].real = alias->real;",
      "            i++;"
    ],
    "added_lines": [
      "        i = 0;",
      "        darray_foreach(alias, info->aliases) {",
      "            if (alias->real != XKB_ATOM_NONE) {",
      "                key_aliases[i].alias = alias->alias;",
      "                key_aliases[i].real = alias->real;",
      "                i++;",
      "            }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/xkbcommon/libxkbcommon/pull/66",
  "description": {
    "pr_info": {
      "title": "Coverity fixes (one real bug)",
      "number": 66
    },
    "comment": [
      "First two patches are just coverity warnings. Patch 3 is a valid fix but possibly theoretical. Patch4 (FreeStmt) is a definitive bug.",
      "Force-pushed, now with just a comment for coverity's sake.",
      "Thanks! I think I'll release 0.8.1 this weekend."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.9"
}