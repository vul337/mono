{
  "cve_id": "CVE-2021-41751",
  "cwe_ids": [
    "CWE-120"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "jerryscript-project/jerryscript",
  "commit_msg": "Avoid buffer-overflow in Array.slice when using fast arrays\n\nIn the Array.slice method when the engine uses fast arrays the \"end\" value\nwas not updated if the input array's length changed. This can occur when the start/end\nindex normalization executes a method and the length is changed forcefully.\nThis leads to a buffer-overflow as the element copy reads too much data from the input\narray.\n\nJerryScript-DCO-1.0-Signed-off-by: Peter Gal pgal.usz@partner.samsung.com",
  "commit_hash": "5ea5b5345e114ee78038874ceb2d1fc3e3096a05",
  "git_url": "https://github.com/jerryscript-project/jerryscript/commit/5ea5b5345e114ee78038874ceb2d1fc3e3096a05",
  "file_path": "jerry-core/ecma/builtin-objects/ecma-builtin-array-prototype.c",
  "func_name": "ecma_builtin_array_prototype_object_slice",
  "func_before": "static ecma_value_t\necma_builtin_array_prototype_object_slice (ecma_value_t arg1, /**< start */\n                                           ecma_value_t arg2, /**< end */\n                                           ecma_object_t *obj_p, /**< object */\n                                           ecma_length_t len) /**< object's length */\n{\n  ecma_length_t start = 0, end = len;\n\n  /* 5. 6.*/\n  if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (arg1,\n                                                                      len,\n                                                                      &start)))\n  {\n    return ECMA_VALUE_ERROR;\n  }\n\n  /* 7. */\n  if (ecma_is_value_undefined (arg2))\n  {\n    end = len;\n  }\n  else\n  {\n    /* 7. part 2, 8.*/\n    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (arg2,\n                                                                        len,\n                                                                        &end)))\n    {\n      return ECMA_VALUE_ERROR;\n    }\n  }\n\n  JERRY_ASSERT (start <= len && end <= len);\n\n  bool use_fast_path = ecma_op_object_is_fast_array (obj_p);\n  ecma_length_t copied_length = (end > start) ? end - start : 0;\n#if JERRY_ESNEXT\n  ecma_object_t *new_array_p = ecma_op_array_species_create (obj_p, copied_length);\n\n  if (JERRY_UNLIKELY (new_array_p == NULL))\n  {\n    return ECMA_VALUE_ERROR;\n  }\n\n  use_fast_path &= ecma_op_object_is_fast_array (new_array_p);\n#else /* !JERRY_ESNEXT */\n  ecma_object_t *new_array_p = ecma_op_new_array_object (0);\n#endif /* JERRY_ESNEXT */\n\n  if (use_fast_path && copied_length > 0)\n  {\n    ecma_extended_object_t *ext_from_obj_p = (ecma_extended_object_t *) obj_p;\n\n    if (ext_from_obj_p->u.array.length_prop_and_hole_count < ECMA_FAST_ARRAY_HOLE_ONE)\n    {\n      if (JERRY_UNLIKELY (obj_p->u1.property_list_cp == JMEM_CP_NULL))\n      {\n        /**\n         * Very unlikely case: the buffer copied from is a fast buffer and the property list was deleted.\n         * There is no need to do any copy.\n         */\n        return ecma_make_object_value (new_array_p);\n      }\n\n      ecma_extended_object_t *ext_to_obj_p = (ecma_extended_object_t *) new_array_p;\n\n#if JERRY_ESNEXT\n      uint32_t target_length = ext_to_obj_p->u.array.length;\n      ecma_value_t *to_buffer_p;\n      JERRY_ASSERT (copied_length <= UINT32_MAX);\n\n      if (copied_length == target_length)\n      {\n        to_buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, new_array_p->u1.property_list_cp);\n      }\n      else if (copied_length > target_length)\n      {\n        to_buffer_p = ecma_fast_array_extend (new_array_p, (uint32_t) copied_length);\n      }\n      else\n      {\n        ecma_delete_fast_array_properties (new_array_p, (uint32_t) copied_length);\n        to_buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, new_array_p->u1.property_list_cp);\n      }\n#else /* !JERRY_ESNEXT */\n      ecma_value_t *to_buffer_p = ecma_fast_array_extend (new_array_p, copied_length);\n#endif /* JERRY_ESNEXT */\n\n      ecma_value_t *from_buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, obj_p->u1.property_list_cp);\n\n      /* 9. */\n      uint32_t n = 0;\n\n      for (uint32_t k = (uint32_t) start; k < (uint32_t) end; k++, n++)\n      {\n#if JERRY_ESNEXT\n        ecma_free_value_if_not_object (to_buffer_p[n]);\n#endif /* JERRY_ESNEXT */\n        to_buffer_p[n] = ecma_copy_value_if_not_object (from_buffer_p[k]);\n      }\n\n      ext_to_obj_p->u.array.length_prop_and_hole_count &= ECMA_FAST_ARRAY_HOLE_ONE - 1;\n\n      return ecma_make_object_value (new_array_p);\n    }\n  }\n\n  /* 9. */\n  ecma_length_t n = 0;\n\n  /* 10. */\n  for (ecma_length_t k = start; k < end; k++, n++)\n  {\n    /* 10.c */\n    ecma_value_t get_value = ecma_op_object_find_by_index (obj_p, k);\n\n    if (ECMA_IS_VALUE_ERROR (get_value))\n    {\n      ecma_deref_object (new_array_p);\n      return get_value;\n    }\n\n    if (ecma_is_value_found (get_value))\n    {\n      /* 10.c.ii */\n      ecma_value_t put_comp;\n#if JERRY_ESNEXT\n      const uint32_t prop_flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE | JERRY_PROP_SHOULD_THROW;\n#else /* !JERRY_ESNEXT */\n      const uint32_t prop_flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE;\n#endif /* JERRY_ESNEXT */\n      put_comp = ecma_builtin_helper_def_prop_by_index (new_array_p,\n                                                        n,\n                                                        get_value,\n                                                        prop_flags);\n      ecma_free_value (get_value);\n\n#if JERRY_ESNEXT\n      if (ECMA_IS_VALUE_ERROR (put_comp))\n      {\n        ecma_deref_object (new_array_p);\n        return put_comp;\n      }\n#else /* !JERRY_ESNEXT */\n      JERRY_ASSERT (ecma_is_value_true (put_comp));\n#endif /* JERRY_ESNEXT */\n    }\n  }\n\n#if JERRY_ESNEXT\n  ecma_value_t set_length_value = ecma_builtin_array_prototype_helper_set_length (new_array_p, ((ecma_number_t) n));\n\n  if (ECMA_IS_VALUE_ERROR (set_length_value))\n  {\n    ecma_deref_object (new_array_p);\n    return set_length_value;\n  }\n#endif /* JERRY_ESNEXT */\n\n  return ecma_make_object_value (new_array_p);\n}",
  "abstract_func_before": "static ecma_value_t\necma_builtin_array_prototype_object_slice (ecma_value_t VAR_0, /* COMMENT_0 */\n                                           ecma_value_t VAR_1, /* COMMENT_1 */\n                                           ecma_object_t *VAR_2, /* COMMENT_2 */\n                                           ecma_length_t VAR_3) /* COMMENT_3 */\n{\n  ecma_length_t VAR_4 = 0, VAR_5 = VAR_3;\n\n  /* COMMENT_4 */\n  if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (VAR_0,\n                                                                      VAR_3,\n                                                                      &VAR_4)))\n  {\n    return VAR_6;\n  }\n\n  /* COMMENT_5 */\n  if (ecma_is_value_undefined (VAR_1))\n  {\n    VAR_5 = VAR_3;\n  }\n  else\n  {\n    /* COMMENT_6 */\n    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (VAR_1,\n                                                                        VAR_3,\n                                                                        &VAR_5)))\n    {\n      return VAR_6;\n    }\n  }\n\n  JERRY_ASSERT (VAR_4 <= VAR_3 && VAR_5 <= VAR_3);\n\n  bool VAR_7 = ecma_op_object_is_fast_array (VAR_2);\n  ecma_length_t VAR_8 = (VAR_5 > VAR_4) ? VAR_5 - VAR_4 : 0;\n#if VAR_9\n  ecma_object_t *VAR_10 = ecma_op_array_species_create (VAR_2, VAR_8);\n\n  if (JERRY_UNLIKELY (VAR_10 == NULL))\n  {\n    return VAR_6;\n  }\n\n  VAR_7 &= ecma_op_object_is_fast_array (VAR_10);\n#else /* COMMENT_7 */\n  ecma_object_t *VAR_10 = ecma_op_new_array_object (0);\n#endif /* COMMENT_8 */\n\n  if (VAR_7 && VAR_8 > 0)\n  {\n    ecma_extended_object_t *VAR_11 = (ecma_extended_object_t *) VAR_2;\n\n    if (VAR_11->u.array.length_prop_and_hole_count < VAR_12)\n    {\n      if (JERRY_UNLIKELY (VAR_2->u1.property_list_cp == VAR_13))\n      {\n        /* COMMENT_9 */\n                                                                                                         \n                                           \n           \n        return ecma_make_object_value (VAR_10);\n      }\n\n      ecma_extended_object_t *VAR_14 = (ecma_extended_object_t *) VAR_10;\n\n#if VAR_9\n      uint32_t VAR_15 = VAR_14->u.array.length;\n      ecma_value_t *VAR_16;\n      JERRY_ASSERT (VAR_8 <= VAR_17);\n\n      if (VAR_8 == VAR_15)\n      {\n        VAR_16 = ECMA_GET_NON_NULL_POINTER (ecma_value_t, VAR_10->u1.property_list_cp);\n      }\n      else if (VAR_8 > VAR_15)\n      {\n        VAR_16 = ecma_fast_array_extend (VAR_10, (uint32_t) VAR_8);\n      }\n      else\n      {\n        ecma_delete_fast_array_properties (VAR_10, (uint32_t) VAR_8);\n        VAR_16 = ECMA_GET_NON_NULL_POINTER (ecma_value_t, VAR_10->u1.property_list_cp);\n      }\n#else /* COMMENT_7 */\n      ecma_value_t *VAR_16 = ecma_fast_array_extend (VAR_10, VAR_8);\n#endif /* COMMENT_8 */\n\n      ecma_value_t *VAR_18 = ECMA_GET_NON_NULL_POINTER (ecma_value_t, VAR_2->u1.property_list_cp);\n\n      /* COMMENT_13 */\n      uint32_t VAR_19 = 0;\n\n      for (uint32_t VAR_20 = (uint32_t) VAR_4; VAR_20 < (uint32_t) VAR_5; VAR_20++, VAR_19++)\n      {\n#if VAR_9\n        ecma_free_value_if_not_object (VAR_16[VAR_19]);\n#endif /* COMMENT_8 */\n        VAR_16[VAR_19] = ecma_copy_value_if_not_object (VAR_18[VAR_20]);\n      }\n\n      VAR_14->u.array.length_prop_and_hole_count &= VAR_12 - 1;\n\n      return ecma_make_object_value (VAR_10);\n    }\n  }\n\n  /* COMMENT_13 */\n  ecma_length_t VAR_19 = 0;\n\n  /* COMMENT_14 */\n  for (ecma_length_t VAR_20 = VAR_4; VAR_20 < VAR_5; VAR_20++, VAR_19++)\n  {\n    /* COMMENT_15 */\n    ecma_value_t VAR_21 = ecma_op_object_find_by_index (VAR_2, VAR_20);\n\n    if (ECMA_IS_VALUE_ERROR (VAR_21))\n    {\n      ecma_deref_object (VAR_10);\n      return VAR_21;\n    }\n\n    if (ecma_is_value_found (VAR_21))\n    {\n      /* COMMENT_16 */\n      ecma_value_t VAR_22;\n#if VAR_9\n      const uint32_t VAR_23 = VAR_24 | VAR_25;\n#else /* COMMENT_7 */\n      const uint32_t VAR_23 = VAR_24;\n#endif /* COMMENT_8 */\n      VAR_22 = ecma_builtin_helper_def_prop_by_index (VAR_10,\n                                                        VAR_19,\n                                                        VAR_21,\n                                                        VAR_23);\n      ecma_free_value (VAR_21);\n\n#if VAR_9\n      if (ECMA_IS_VALUE_ERROR (VAR_22))\n      {\n        ecma_deref_object (VAR_10);\n        return VAR_22;\n      }\n#else /* COMMENT_7 */\n      JERRY_ASSERT (ecma_is_value_true (VAR_22));\n#endif /* COMMENT_8 */\n    }\n  }\n\n#if VAR_9\n  ecma_value_t VAR_26 = ecma_builtin_array_prototype_helper_set_length (VAR_10, ((ecma_number_t) VAR_19));\n\n  if (ECMA_IS_VALUE_ERROR (VAR_26))\n  {\n    ecma_deref_object (VAR_10);\n    return VAR_26;\n  }\n#endif /* COMMENT_8 */\n\n  return ecma_make_object_value (VAR_10);\n}",
  "func_graph_path_before": "jerryscript-project/jerryscript/5ea5b5345e114ee78038874ceb2d1fc3e3096a05/ecma-builtin-array-prototype.c/vul/before/0.json",
  "func": "static ecma_value_t\necma_builtin_array_prototype_object_slice (ecma_value_t arg1, /**< start */\n                                           ecma_value_t arg2, /**< end */\n                                           ecma_object_t *obj_p, /**< object */\n                                           ecma_length_t len) /**< object's length */\n{\n  ecma_length_t start = 0, end = len;\n\n  /* 5. 6.*/\n  if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (arg1,\n                                                                      len,\n                                                                      &start)))\n  {\n    return ECMA_VALUE_ERROR;\n  }\n\n  /* 7. */\n  if (ecma_is_value_undefined (arg2))\n  {\n    end = len;\n  }\n  else\n  {\n    /* 7. part 2, 8.*/\n    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (arg2,\n                                                                        len,\n                                                                        &end)))\n    {\n      return ECMA_VALUE_ERROR;\n    }\n  }\n\n  JERRY_ASSERT (start <= len && end <= len);\n\n  bool use_fast_path = ecma_op_object_is_fast_array (obj_p);\n  ecma_length_t copied_length = (end > start) ? end - start : 0;\n#if JERRY_ESNEXT\n  ecma_object_t *new_array_p = ecma_op_array_species_create (obj_p, copied_length);\n\n  if (JERRY_UNLIKELY (new_array_p == NULL))\n  {\n    return ECMA_VALUE_ERROR;\n  }\n\n  use_fast_path &= ecma_op_object_is_fast_array (new_array_p);\n#else /* !JERRY_ESNEXT */\n  ecma_object_t *new_array_p = ecma_op_new_array_object (0);\n#endif /* JERRY_ESNEXT */\n\n  if (use_fast_path && copied_length > 0)\n  {\n    ecma_extended_object_t *ext_from_obj_p = (ecma_extended_object_t *) obj_p;\n\n    if (ext_from_obj_p->u.array.length_prop_and_hole_count < ECMA_FAST_ARRAY_HOLE_ONE)\n    {\n      if (JERRY_UNLIKELY (obj_p->u1.property_list_cp == JMEM_CP_NULL))\n      {\n        /**\n         * Very unlikely case: the buffer copied from is a fast buffer and the property list was deleted.\n         * There is no need to do any copy.\n         */\n        return ecma_make_object_value (new_array_p);\n      }\n\n      /* Source array's length could be changed during the start/end normalization.\n       * If the \"end\" value is greater than the current length, clamp the value to avoid buffer-overflow. */\n      if (ext_from_obj_p->u.array.length < end)\n      {\n        end = ext_from_obj_p->u.array.length;\n      }\n\n      ecma_extended_object_t *ext_to_obj_p = (ecma_extended_object_t *) new_array_p;\n\n#if JERRY_ESNEXT\n      uint32_t target_length = ext_to_obj_p->u.array.length;\n      ecma_value_t *to_buffer_p;\n      JERRY_ASSERT (copied_length <= UINT32_MAX);\n\n      if (copied_length == target_length)\n      {\n        to_buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, new_array_p->u1.property_list_cp);\n      }\n      else if (copied_length > target_length)\n      {\n        to_buffer_p = ecma_fast_array_extend (new_array_p, (uint32_t) copied_length);\n      }\n      else\n      {\n        ecma_delete_fast_array_properties (new_array_p, (uint32_t) copied_length);\n        to_buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, new_array_p->u1.property_list_cp);\n      }\n#else /* !JERRY_ESNEXT */\n      ecma_value_t *to_buffer_p = ecma_fast_array_extend (new_array_p, copied_length);\n#endif /* JERRY_ESNEXT */\n\n      ecma_value_t *from_buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, obj_p->u1.property_list_cp);\n\n      /* 9. */\n      uint32_t n = 0;\n\n      for (uint32_t k = (uint32_t) start; k < (uint32_t) end; k++, n++)\n      {\n#if JERRY_ESNEXT\n        ecma_free_value_if_not_object (to_buffer_p[n]);\n#endif /* JERRY_ESNEXT */\n        to_buffer_p[n] = ecma_copy_value_if_not_object (from_buffer_p[k]);\n      }\n\n      ext_to_obj_p->u.array.length_prop_and_hole_count &= ECMA_FAST_ARRAY_HOLE_ONE - 1;\n\n      return ecma_make_object_value (new_array_p);\n    }\n  }\n\n  /* 9. */\n  ecma_length_t n = 0;\n\n  /* 10. */\n  for (ecma_length_t k = start; k < end; k++, n++)\n  {\n    /* 10.c */\n    ecma_value_t get_value = ecma_op_object_find_by_index (obj_p, k);\n\n    if (ECMA_IS_VALUE_ERROR (get_value))\n    {\n      ecma_deref_object (new_array_p);\n      return get_value;\n    }\n\n    if (ecma_is_value_found (get_value))\n    {\n      /* 10.c.ii */\n      ecma_value_t put_comp;\n#if JERRY_ESNEXT\n      const uint32_t prop_flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE | JERRY_PROP_SHOULD_THROW;\n#else /* !JERRY_ESNEXT */\n      const uint32_t prop_flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE;\n#endif /* JERRY_ESNEXT */\n      put_comp = ecma_builtin_helper_def_prop_by_index (new_array_p,\n                                                        n,\n                                                        get_value,\n                                                        prop_flags);\n      ecma_free_value (get_value);\n\n#if JERRY_ESNEXT\n      if (ECMA_IS_VALUE_ERROR (put_comp))\n      {\n        ecma_deref_object (new_array_p);\n        return put_comp;\n      }\n#else /* !JERRY_ESNEXT */\n      JERRY_ASSERT (ecma_is_value_true (put_comp));\n#endif /* JERRY_ESNEXT */\n    }\n  }\n\n#if JERRY_ESNEXT\n  ecma_value_t set_length_value = ecma_builtin_array_prototype_helper_set_length (new_array_p, ((ecma_number_t) n));\n\n  if (ECMA_IS_VALUE_ERROR (set_length_value))\n  {\n    ecma_deref_object (new_array_p);\n    return set_length_value;\n  }\n#endif /* JERRY_ESNEXT */\n\n  return ecma_make_object_value (new_array_p);\n}",
  "abstract_func": "static ecma_value_t\necma_builtin_array_prototype_object_slice (ecma_value_t VAR_0, /* COMMENT_0 */\n                                           ecma_value_t VAR_1, /* COMMENT_1 */\n                                           ecma_object_t *VAR_2, /* COMMENT_2 */\n                                           ecma_length_t VAR_3) /* COMMENT_3 */\n{\n  ecma_length_t VAR_4 = 0, VAR_5 = VAR_3;\n\n  /* COMMENT_4 */\n  if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (VAR_0,\n                                                                      VAR_3,\n                                                                      &VAR_4)))\n  {\n    return VAR_6;\n  }\n\n  /* COMMENT_5 */\n  if (ecma_is_value_undefined (VAR_1))\n  {\n    VAR_5 = VAR_3;\n  }\n  else\n  {\n    /* COMMENT_6 */\n    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (VAR_1,\n                                                                        VAR_3,\n                                                                        &VAR_5)))\n    {\n      return VAR_6;\n    }\n  }\n\n  JERRY_ASSERT (VAR_4 <= VAR_3 && VAR_5 <= VAR_3);\n\n  bool VAR_7 = ecma_op_object_is_fast_array (VAR_2);\n  ecma_length_t VAR_8 = (VAR_5 > VAR_4) ? VAR_5 - VAR_4 : 0;\n#if VAR_9\n  ecma_object_t *VAR_10 = ecma_op_array_species_create (VAR_2, VAR_8);\n\n  if (JERRY_UNLIKELY (VAR_10 == NULL))\n  {\n    return VAR_6;\n  }\n\n  VAR_7 &= ecma_op_object_is_fast_array (VAR_10);\n#else /* COMMENT_7 */\n  ecma_object_t *VAR_10 = ecma_op_new_array_object (0);\n#endif /* COMMENT_8 */\n\n  if (VAR_7 && VAR_8 > 0)\n  {\n    ecma_extended_object_t *VAR_11 = (ecma_extended_object_t *) VAR_2;\n\n    if (VAR_11->u.array.length_prop_and_hole_count < VAR_12)\n    {\n      if (JERRY_UNLIKELY (VAR_2->u1.property_list_cp == VAR_13))\n      {\n        /* COMMENT_9 */\n                                                                                                         \n                                           \n           \n        return ecma_make_object_value (VAR_10);\n      }\n\n      /* COMMENT_13 */\n                                                                                                            \n      if (VAR_11->u.array.length < VAR_5)\n      {\n        VAR_5 = VAR_11->u.array.length;\n      }\n\n      ecma_extended_object_t *VAR_14 = (ecma_extended_object_t *) VAR_10;\n\n#if VAR_9\n      uint32_t VAR_15 = VAR_14->u.array.length;\n      ecma_value_t *VAR_16;\n      JERRY_ASSERT (VAR_8 <= VAR_17);\n\n      if (VAR_8 == VAR_15)\n      {\n        VAR_16 = ECMA_GET_NON_NULL_POINTER (ecma_value_t, VAR_10->u1.property_list_cp);\n      }\n      else if (VAR_8 > VAR_15)\n      {\n        VAR_16 = ecma_fast_array_extend (VAR_10, (uint32_t) VAR_8);\n      }\n      else\n      {\n        ecma_delete_fast_array_properties (VAR_10, (uint32_t) VAR_8);\n        VAR_16 = ECMA_GET_NON_NULL_POINTER (ecma_value_t, VAR_10->u1.property_list_cp);\n      }\n#else /* COMMENT_7 */\n      ecma_value_t *VAR_16 = ecma_fast_array_extend (VAR_10, VAR_8);\n#endif /* COMMENT_8 */\n\n      ecma_value_t *VAR_18 = ECMA_GET_NON_NULL_POINTER (ecma_value_t, VAR_2->u1.property_list_cp);\n\n      /* COMMENT_15 */\n      uint32_t VAR_19 = 0;\n\n      for (uint32_t VAR_20 = (uint32_t) VAR_4; VAR_20 < (uint32_t) VAR_5; VAR_20++, VAR_19++)\n      {\n#if VAR_9\n        ecma_free_value_if_not_object (VAR_16[VAR_19]);\n#endif /* COMMENT_8 */\n        VAR_16[VAR_19] = ecma_copy_value_if_not_object (VAR_18[VAR_20]);\n      }\n\n      VAR_14->u.array.length_prop_and_hole_count &= VAR_12 - 1;\n\n      return ecma_make_object_value (VAR_10);\n    }\n  }\n\n  /* COMMENT_15 */\n  ecma_length_t VAR_19 = 0;\n\n  /* COMMENT_16 */\n  for (ecma_length_t VAR_20 = VAR_4; VAR_20 < VAR_5; VAR_20++, VAR_19++)\n  {\n    /* COMMENT_17 */\n    ecma_value_t VAR_21 = ecma_op_object_find_by_index (VAR_2, VAR_20);\n\n    if (ECMA_IS_VALUE_ERROR (VAR_21))\n    {\n      ecma_deref_object (VAR_10);\n      return VAR_21;\n    }\n\n    if (ecma_is_value_found (VAR_21))\n    {\n      /* COMMENT_18 */\n      ecma_value_t VAR_22;\n#if VAR_9\n      const uint32_t VAR_23 = VAR_24 | VAR_25;\n#else /* COMMENT_7 */\n      const uint32_t VAR_23 = VAR_24;\n#endif /* COMMENT_8 */\n      VAR_22 = ecma_builtin_helper_def_prop_by_index (VAR_10,\n                                                        VAR_19,\n                                                        VAR_21,\n                                                        VAR_23);\n      ecma_free_value (VAR_21);\n\n#if VAR_9\n      if (ECMA_IS_VALUE_ERROR (VAR_22))\n      {\n        ecma_deref_object (VAR_10);\n        return VAR_22;\n      }\n#else /* COMMENT_7 */\n      JERRY_ASSERT (ecma_is_value_true (VAR_22));\n#endif /* COMMENT_8 */\n    }\n  }\n\n#if VAR_9\n  ecma_value_t VAR_26 = ecma_builtin_array_prototype_helper_set_length (VAR_10, ((ecma_number_t) VAR_19));\n\n  if (ECMA_IS_VALUE_ERROR (VAR_26))\n  {\n    ecma_deref_object (VAR_10);\n    return VAR_26;\n  }\n#endif /* COMMENT_8 */\n\n  return ecma_make_object_value (VAR_10);\n}",
  "func_graph_path": "jerryscript-project/jerryscript/5ea5b5345e114ee78038874ceb2d1fc3e3096a05/ecma-builtin-array-prototype.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -60,6 +60,13 @@\n          * There is no need to do any copy.\n          */\n         return ecma_make_object_value (new_array_p);\n+      }\n+\n+      /* Source array's length could be changed during the start/end normalization.\n+       * If the \"end\" value is greater than the current length, clamp the value to avoid buffer-overflow. */\n+      if (ext_from_obj_p->u.array.length < end)\n+      {\n+        end = ext_from_obj_p->u.array.length;\n       }\n \n       ecma_extended_object_t *ext_to_obj_p = (ecma_extended_object_t *) new_array_p;",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "      }",
      "",
      "      /* Source array's length could be changed during the start/end normalization.",
      "       * If the \"end\" value is greater than the current length, clamp the value to avoid buffer-overflow. */",
      "      if (ext_from_obj_p->u.array.length < end)",
      "      {",
      "        end = ext_from_obj_p->u.array.length;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/jerryscript-project/jerryscript/pull/4797",
  "description": {
    "pr_info": {
      "title": "Avoid buffer-overflow in Array.slice when using fast arrays",
      "number": 4797
    },
    "comment": [
      "In the Array.slice method when the engine uses fast arrays the \"end\" value\r\nwas not updated if the input array's length changed. This can occur when the start/end\r\nindex normalization executes a method and the length is changed forcefully.\r\nThis leads to a buffer-overflow as the element copy reads too much data from the input\r\narray.\r\n\r\nFixes: #4777"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}