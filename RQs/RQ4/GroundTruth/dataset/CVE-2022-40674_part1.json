{
  "cve_id": "CVE-2022-40674",
  "cwe_ids": [
    "CWE-416"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "libexpat",
  "commit_msg": "Ensure raw tagnames are safe exiting internalEntityParser\n\nIt is possible to concoct a situation in which parsing is\nsuspended while substituting in an internal entity, so that\nXML_ResumeParser directly uses internalEntityProcessor as\nits processor.  If the subsequent parse includes some unclosed\ntags, this will return without calling storeRawNames to ensure\nthat the raw versions of the tag names are stored in memory other\nthan the parse buffer itself.  If the parse buffer is then changed\nor reallocated (for example if processing a file line by line),\nbadness will ensue.\n\nThis patch ensures storeRawNames is always called when needed\nafter calling doContent.  The earlier call do doContent does\nnot need the same protection; it only deals with entity\nsubstitution, which cannot leave unbalanced tags, and in any\ncase the raw names will be pointing into the stored entity\nvalue not the parse buffer.",
  "commit_hash": "4a32da87e931ba54393d465bb77c40b5c33d343b",
  "git_url": "https://github.com/libexpat/libexpat/commit/4a32da87e931ba54393d465bb77c40b5c33d343b",
  "file_path": "expat/lib/xmlparse.c",
  "func_name": "internalEntityProcessor",
  "func_before": "static enum XML_Error PTRCALL\ninternalEntityProcessor(XML_Parser parser, const char *s, const char *end,\n                        const char **nextPtr) {\n  ENTITY *entity;\n  const char *textStart, *textEnd;\n  const char *next;\n  enum XML_Error result;\n  OPEN_INTERNAL_ENTITY *openEntity = parser->m_openInternalEntities;\n  if (! openEntity)\n    return XML_ERROR_UNEXPECTED_STATE;\n\n  entity = openEntity->entity;\n  textStart = ((const char *)entity->textPtr) + entity->processed;\n  textEnd = (const char *)(entity->textPtr + entity->textLen);\n  /* Set a safe default value in case 'next' does not get set */\n  next = textStart;\n\n#ifdef XML_DTD\n  if (entity->is_param) {\n    int tok\n        = XmlPrologTok(parser->m_internalEncoding, textStart, textEnd, &next);\n    result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd,\n                      tok, next, &next, XML_FALSE, XML_TRUE,\n                      XML_ACCOUNT_ENTITY_EXPANSION);\n  } else\n#endif /* XML_DTD */\n    result = doContent(parser, openEntity->startTagLevel,\n                       parser->m_internalEncoding, textStart, textEnd, &next,\n                       XML_FALSE, XML_ACCOUNT_ENTITY_EXPANSION);\n\n  if (result != XML_ERROR_NONE)\n    return result;\n  else if (textEnd != next\n           && parser->m_parsingStatus.parsing == XML_SUSPENDED) {\n    entity->processed = (int)(next - (const char *)entity->textPtr);\n    return result;\n  } else {\n#ifdef XML_DTD\n    entityTrackingOnClose(parser, entity, __LINE__);\n#endif\n    entity->open = XML_FALSE;\n    parser->m_openInternalEntities = openEntity->next;\n    /* put openEntity back in list of free instances */\n    openEntity->next = parser->m_freeInternalEntities;\n    parser->m_freeInternalEntities = openEntity;\n  }\n\n#ifdef XML_DTD\n  if (entity->is_param) {\n    int tok;\n    parser->m_processor = prologProcessor;\n    tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n    return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                    (XML_Bool)! parser->m_parsingStatus.finalBuffer, XML_TRUE,\n                    XML_ACCOUNT_DIRECT);\n  } else\n#endif /* XML_DTD */\n  {\n    parser->m_processor = contentProcessor;\n    /* see externalEntityContentProcessor vs contentProcessor */\n    return doContent(parser, parser->m_parentParser ? 1 : 0, parser->m_encoding,\n                     s, end, nextPtr,\n                     (XML_Bool)! parser->m_parsingStatus.finalBuffer,\n                     XML_ACCOUNT_DIRECT);\n  }\n}",
  "abstract_func_before": "static enum XML_Error VAR_0\ninternalEntityProcessor(XML_Parser VAR_1, const char *VAR_2, const char *VAR_3,\n                        const char **VAR_4) {\n  ENTITY *VAR_5;\n  const char *VAR_6, *VAR_7;\n  const char *VAR_8;\n  enum XML_Error VAR_9;\n  OPEN_INTERNAL_ENTITY *VAR_10 = VAR_1->m_openInternalEntities;\n  if (! VAR_10)\n    return VAR_11;\n\n  VAR_5 = VAR_10->entity;\n  VAR_6 = ((const char *)VAR_5->textPtr) + VAR_5->processed;\n  VAR_7 = (const char *)(VAR_5->textPtr + VAR_5->textLen);\n  /* COMMENT_0 */\n  VAR_8 = VAR_6;\n\n#ifdef VAR_12\n  if (VAR_5->is_param) {\n    int VAR_13\n        = XmlPrologTok(VAR_1->m_internalEncoding, VAR_6, VAR_7, &VAR_8);\n    VAR_9 = doProlog(VAR_1, VAR_1->m_internalEncoding, VAR_6, VAR_7,\n                      VAR_13, VAR_8, &VAR_8, VAR_14, VAR_15,\n                      VAR_16);\n  } else\n#endif /* COMMENT_1 */\n    VAR_9 = doContent(VAR_1, VAR_10->startTagLevel,\n                       VAR_1->m_internalEncoding, VAR_6, VAR_7, &VAR_8,\n                       VAR_14, VAR_16);\n\n  if (VAR_9 != VAR_17)\n    return VAR_9;\n  else if (VAR_7 != VAR_8\n           && VAR_1->m_parsingStatus.parsing == VAR_18) {\n    VAR_5->processed = (int)(VAR_8 - (const char *)VAR_5->textPtr);\n    return VAR_9;\n  } else {\n#ifdef VAR_12\n    entityTrackingOnClose(VAR_1, VAR_5, VAR_19);\n#endif\n    VAR_5->open = VAR_14;\n    VAR_1->m_openInternalEntities = VAR_10->next;\n    /* COMMENT_2 */\n    VAR_10->next = VAR_1->m_freeInternalEntities;\n    VAR_1->m_freeInternalEntities = VAR_10;\n  }\n\n#ifdef VAR_12\n  if (VAR_5->is_param) {\n    int VAR_13;\n    VAR_1->m_processor = VAR_20;\n    VAR_13 = XmlPrologTok(VAR_1->m_encoding, VAR_2, VAR_3, &VAR_8);\n    return doProlog(VAR_1, VAR_1->m_encoding, VAR_2, VAR_3, VAR_13, VAR_8, VAR_4,\n                    (XML_Bool)! VAR_1->m_parsingStatus.finalBuffer, VAR_15,\n                    VAR_21);\n  } else\n#endif /* COMMENT_1 */\n  {\n    VAR_1->m_processor = VAR_22;\n    /* COMMENT_3 */\n    return doContent(VAR_1, VAR_1->m_parentParser ? 1 : 0, VAR_1->m_encoding,\n                     VAR_2, VAR_3, VAR_4,\n                     (XML_Bool)! VAR_1->m_parsingStatus.finalBuffer,\n                     VAR_21);\n  }\n}",
  "func_graph_path_before": null,
  "func": "static enum XML_Error PTRCALL\ninternalEntityProcessor(XML_Parser parser, const char *s, const char *end,\n                        const char **nextPtr) {\n  ENTITY *entity;\n  const char *textStart, *textEnd;\n  const char *next;\n  enum XML_Error result;\n  OPEN_INTERNAL_ENTITY *openEntity = parser->m_openInternalEntities;\n  if (! openEntity)\n    return XML_ERROR_UNEXPECTED_STATE;\n\n  entity = openEntity->entity;\n  textStart = ((const char *)entity->textPtr) + entity->processed;\n  textEnd = (const char *)(entity->textPtr + entity->textLen);\n  /* Set a safe default value in case 'next' does not get set */\n  next = textStart;\n\n#ifdef XML_DTD\n  if (entity->is_param) {\n    int tok\n        = XmlPrologTok(parser->m_internalEncoding, textStart, textEnd, &next);\n    result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd,\n                      tok, next, &next, XML_FALSE, XML_TRUE,\n                      XML_ACCOUNT_ENTITY_EXPANSION);\n  } else\n#endif /* XML_DTD */\n    result = doContent(parser, openEntity->startTagLevel,\n                       parser->m_internalEncoding, textStart, textEnd, &next,\n                       XML_FALSE, XML_ACCOUNT_ENTITY_EXPANSION);\n\n  if (result != XML_ERROR_NONE)\n    return result;\n  else if (textEnd != next\n           && parser->m_parsingStatus.parsing == XML_SUSPENDED) {\n    entity->processed = (int)(next - (const char *)entity->textPtr);\n    return result;\n  } else {\n#ifdef XML_DTD\n    entityTrackingOnClose(parser, entity, __LINE__);\n#endif\n    entity->open = XML_FALSE;\n    parser->m_openInternalEntities = openEntity->next;\n    /* put openEntity back in list of free instances */\n    openEntity->next = parser->m_freeInternalEntities;\n    parser->m_freeInternalEntities = openEntity;\n  }\n\n#ifdef XML_DTD\n  if (entity->is_param) {\n    int tok;\n    parser->m_processor = prologProcessor;\n    tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n    return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                    (XML_Bool)! parser->m_parsingStatus.finalBuffer, XML_TRUE,\n                    XML_ACCOUNT_DIRECT);\n  } else\n#endif /* XML_DTD */\n  {\n    parser->m_processor = contentProcessor;\n    /* see externalEntityContentProcessor vs contentProcessor */\n    result = doContent(parser, parser->m_parentParser ? 1 : 0,\n                       parser->m_encoding, s, end, nextPtr,\n                       (XML_Bool)! parser->m_parsingStatus.finalBuffer,\n                       XML_ACCOUNT_DIRECT);\n    if (result == XML_ERROR_NONE) {\n      if (! storeRawNames(parser))\n        return XML_ERROR_NO_MEMORY;\n    }\n    return result;\n  }\n}",
  "abstract_func": "static enum XML_Error VAR_0\ninternalEntityProcessor(XML_Parser VAR_1, const char *VAR_2, const char *VAR_3,\n                        const char **VAR_4) {\n  ENTITY *VAR_5;\n  const char *VAR_6, *VAR_7;\n  const char *VAR_8;\n  enum XML_Error VAR_9;\n  OPEN_INTERNAL_ENTITY *VAR_10 = VAR_1->m_openInternalEntities;\n  if (! VAR_10)\n    return VAR_11;\n\n  VAR_5 = VAR_10->entity;\n  VAR_6 = ((const char *)VAR_5->textPtr) + VAR_5->processed;\n  VAR_7 = (const char *)(VAR_5->textPtr + VAR_5->textLen);\n  /* COMMENT_0 */\n  VAR_8 = VAR_6;\n\n#ifdef VAR_12\n  if (VAR_5->is_param) {\n    int VAR_13\n        = XmlPrologTok(VAR_1->m_internalEncoding, VAR_6, VAR_7, &VAR_8);\n    VAR_9 = doProlog(VAR_1, VAR_1->m_internalEncoding, VAR_6, VAR_7,\n                      VAR_13, VAR_8, &VAR_8, VAR_14, VAR_15,\n                      VAR_16);\n  } else\n#endif /* COMMENT_1 */\n    VAR_9 = doContent(VAR_1, VAR_10->startTagLevel,\n                       VAR_1->m_internalEncoding, VAR_6, VAR_7, &VAR_8,\n                       VAR_14, VAR_16);\n\n  if (VAR_9 != VAR_17)\n    return VAR_9;\n  else if (VAR_7 != VAR_8\n           && VAR_1->m_parsingStatus.parsing == VAR_18) {\n    VAR_5->processed = (int)(VAR_8 - (const char *)VAR_5->textPtr);\n    return VAR_9;\n  } else {\n#ifdef VAR_12\n    entityTrackingOnClose(VAR_1, VAR_5, VAR_19);\n#endif\n    VAR_5->open = VAR_14;\n    VAR_1->m_openInternalEntities = VAR_10->next;\n    /* COMMENT_2 */\n    VAR_10->next = VAR_1->m_freeInternalEntities;\n    VAR_1->m_freeInternalEntities = VAR_10;\n  }\n\n#ifdef VAR_12\n  if (VAR_5->is_param) {\n    int VAR_13;\n    VAR_1->m_processor = VAR_20;\n    VAR_13 = XmlPrologTok(VAR_1->m_encoding, VAR_2, VAR_3, &VAR_8);\n    return doProlog(VAR_1, VAR_1->m_encoding, VAR_2, VAR_3, VAR_13, VAR_8, VAR_4,\n                    (XML_Bool)! VAR_1->m_parsingStatus.finalBuffer, VAR_15,\n                    VAR_21);\n  } else\n#endif /* COMMENT_1 */\n  {\n    VAR_1->m_processor = VAR_22;\n    /* COMMENT_3 */\n    VAR_9 = doContent(VAR_1, VAR_1->m_parentParser ? 1 : 0,\n                       VAR_1->m_encoding, VAR_2, VAR_3, VAR_4,\n                       (XML_Bool)! VAR_1->m_parsingStatus.finalBuffer,\n                       VAR_21);\n    if (VAR_9 == VAR_17) {\n      if (! storeRawNames(VAR_1))\n        return VAR_23;\n    }\n    return VAR_9;\n  }\n}",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -58,9 +58,14 @@\n   {\n     parser->m_processor = contentProcessor;\n     /* see externalEntityContentProcessor vs contentProcessor */\n-    return doContent(parser, parser->m_parentParser ? 1 : 0, parser->m_encoding,\n-                     s, end, nextPtr,\n-                     (XML_Bool)! parser->m_parsingStatus.finalBuffer,\n-                     XML_ACCOUNT_DIRECT);\n+    result = doContent(parser, parser->m_parentParser ? 1 : 0,\n+                       parser->m_encoding, s, end, nextPtr,\n+                       (XML_Bool)! parser->m_parsingStatus.finalBuffer,\n+                       XML_ACCOUNT_DIRECT);\n+    if (result == XML_ERROR_NONE) {\n+      if (! storeRawNames(parser))\n+        return XML_ERROR_NO_MEMORY;\n+    }\n+    return result;\n   }\n }",
  "diff_line_info": {
    "deleted_lines": [
      "    return doContent(parser, parser->m_parentParser ? 1 : 0, parser->m_encoding,",
      "                     s, end, nextPtr,",
      "                     (XML_Bool)! parser->m_parsingStatus.finalBuffer,",
      "                     XML_ACCOUNT_DIRECT);"
    ],
    "added_lines": [
      "    result = doContent(parser, parser->m_parentParser ? 1 : 0,",
      "                       parser->m_encoding, s, end, nextPtr,",
      "                       (XML_Bool)! parser->m_parsingStatus.finalBuffer,",
      "                       XML_ACCOUNT_DIRECT);",
      "    if (result == XML_ERROR_NONE) {",
      "      if (! storeRawNames(parser))",
      "        return XML_ERROR_NO_MEMORY;",
      "    }",
      "    return result;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libexpat/libexpat/pull/629",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/libexpat/libexpat/pull/629: 403 Client Error: Forbidden for url: https://api.github.com/repos/libexpat/libexpat/pulls/629",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.9"
}