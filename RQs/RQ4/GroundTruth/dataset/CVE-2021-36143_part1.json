{
  "cve_id": "CVE-2021-36143",
  "cwe_ids": [
    "CWE-476"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "projectacrn/acrn-hypervisor",
  "commit_msg": "dm: validate inputs in vq_endchains\n\n inputs shall be validated to avoid NULL pointer access.\n\nTracked-On: #6129\nSigned-off-by: Yonghua Huang <yonghua.huang@intel.com>",
  "commit_hash": "154fe59531c12b82e26d1b24b5531f5066d224f5",
  "git_url": "https://github.com/projectacrn/acrn-hypervisor/commit/154fe59531c12b82e26d1b24b5531f5066d224f5",
  "file_path": "devicemodel/hw/pci/virtio/virtio.c",
  "func_name": "vq_endchains",
  "func_before": "void\nvq_endchains(struct virtio_vq_info *vq, int used_all_avail)\n{\n\tstruct virtio_base *base;\n\tuint16_t event_idx, new_idx, old_idx;\n\tint intr;\n\n\t/*\n\t * Interrupt generation: if we're using EVENT_IDX,\n\t * interrupt if we've crossed the event threshold.\n\t * Otherwise interrupt is generated if we added \"used\" entries,\n\t * but suppressed by VRING_AVAIL_F_NO_INTERRUPT.\n\t *\n\t * In any case, though, if NOTIFY_ON_EMPTY is set and the\n\t * entire avail was processed, we need to interrupt always.\n\t */\n\n\tatomic_thread_fence();\n\n\tbase = vq->base;\n\told_idx = vq->save_used;\n\tvq->save_used = new_idx = vq->used->idx;\n\tif (used_all_avail &&\n\t    (base->negotiated_caps & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)))\n\t\tintr = 1;\n\telse if (base->negotiated_caps & (1 << VIRTIO_RING_F_EVENT_IDX)) {\n\t\tevent_idx = VQ_USED_EVENT_IDX(vq);\n\t\t/*\n\t\t * This calculation is per docs and the kernel\n\t\t * (see src/sys/dev/virtio/virtio_ring.h).\n\t\t */\n\t\tintr = (uint16_t)(new_idx - event_idx - 1) <\n\t\t\t(uint16_t)(new_idx - old_idx);\n\t} else {\n\t\tintr = new_idx != old_idx &&\n\t\t    !(vq->avail->flags & VRING_AVAIL_F_NO_INTERRUPT);\n\t}\n\tif (intr)\n\t\tvq_interrupt(base, vq);\n}",
  "abstract_func_before": "void\nvq_endchains(struct virtio_vq_info *VAR_0, int VAR_1)\n{\n\tstruct virtio_base *VAR_2;\n\tuint16_t VAR_3, VAR_4, VAR_5;\n\tint VAR_6;\n\n\t/* COMMENT_0 */\n                                                   \n                                                   \n                                                                \n                                                 \n   \n                                                          \n                                                            \n    \n\n\tatomic_thread_fence();\n\n\tVAR_2 = VAR_0->base;\n\tVAR_5 = VAR_0->save_used;\n\tVAR_0->save_used = VAR_4 = VAR_0->used->idx;\n\tif (VAR_1 &&\n\t    (VAR_2->negotiated_caps & (1 << VAR_7)))\n\t\tVAR_6 = 1;\n\telse if (VAR_2->negotiated_caps & (1 << VAR_8)) {\n\t\tVAR_3 = VQ_USED_EVENT_IDX(VAR_0);\n\t\t/* COMMENT_9 */\n                                                \n                                            \n     \n\t\tVAR_6 = (uint16_t)(VAR_4 - VAR_3 - 1) <\n\t\t\t(uint16_t)(VAR_4 - VAR_5);\n\t} else {\n\t\tVAR_6 = VAR_4 != VAR_5 &&\n\t\t    !(VAR_0->avail->flags & VAR_9);\n\t}\n\tif (VAR_6)\n\t\tvq_interrupt(VAR_2, VAR_0);\n}",
  "func_graph_path_before": "projectacrn/acrn-hypervisor/154fe59531c12b82e26d1b24b5531f5066d224f5/virtio.c/vul/before/0.json",
  "func": "void\nvq_endchains(struct virtio_vq_info *vq, int used_all_avail)\n{\n\tstruct virtio_base *base;\n\tuint16_t event_idx, new_idx, old_idx;\n\tint intr;\n\n\tif (!vq || !vq->used)\n\t\treturn;\n\n\t/*\n\t * Interrupt generation: if we're using EVENT_IDX,\n\t * interrupt if we've crossed the event threshold.\n\t * Otherwise interrupt is generated if we added \"used\" entries,\n\t * but suppressed by VRING_AVAIL_F_NO_INTERRUPT.\n\t *\n\t * In any case, though, if NOTIFY_ON_EMPTY is set and the\n\t * entire avail was processed, we need to interrupt always.\n\t */\n\n\tatomic_thread_fence();\n\n\tbase = vq->base;\n\told_idx = vq->save_used;\n\tvq->save_used = new_idx = vq->used->idx;\n\tif (used_all_avail &&\n\t    (base->negotiated_caps & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)))\n\t\tintr = 1;\n\telse if (base->negotiated_caps & (1 << VIRTIO_RING_F_EVENT_IDX)) {\n\t\tevent_idx = VQ_USED_EVENT_IDX(vq);\n\t\t/*\n\t\t * This calculation is per docs and the kernel\n\t\t * (see src/sys/dev/virtio/virtio_ring.h).\n\t\t */\n\t\tintr = (uint16_t)(new_idx - event_idx - 1) <\n\t\t\t(uint16_t)(new_idx - old_idx);\n\t} else {\n\t\tintr = new_idx != old_idx &&\n\t\t    !(vq->avail->flags & VRING_AVAIL_F_NO_INTERRUPT);\n\t}\n\tif (intr)\n\t\tvq_interrupt(base, vq);\n}",
  "abstract_func": "void\nvq_endchains(struct virtio_vq_info *VAR_0, int VAR_1)\n{\n\tstruct virtio_base *VAR_2;\n\tuint16_t VAR_3, VAR_4, VAR_5;\n\tint VAR_6;\n\n\tif (!VAR_0 || !VAR_0->used)\n\t\treturn;\n\n\t/* COMMENT_0 */\n                                                   \n                                                   \n                                                                \n                                                 \n   \n                                                          \n                                                            \n    \n\n\tatomic_thread_fence();\n\n\tVAR_2 = VAR_0->base;\n\tVAR_5 = VAR_0->save_used;\n\tVAR_0->save_used = VAR_4 = VAR_0->used->idx;\n\tif (VAR_1 &&\n\t    (VAR_2->negotiated_caps & (1 << VAR_7)))\n\t\tVAR_6 = 1;\n\telse if (VAR_2->negotiated_caps & (1 << VAR_8)) {\n\t\tVAR_3 = VQ_USED_EVENT_IDX(VAR_0);\n\t\t/* COMMENT_9 */\n                                                \n                                            \n     \n\t\tVAR_6 = (uint16_t)(VAR_4 - VAR_3 - 1) <\n\t\t\t(uint16_t)(VAR_4 - VAR_5);\n\t} else {\n\t\tVAR_6 = VAR_4 != VAR_5 &&\n\t\t    !(VAR_0->avail->flags & VAR_9);\n\t}\n\tif (VAR_6)\n\t\tvq_interrupt(VAR_2, VAR_0);\n}",
  "func_graph_path": "projectacrn/acrn-hypervisor/154fe59531c12b82e26d1b24b5531f5066d224f5/virtio.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,9 @@\n \tstruct virtio_base *base;\n \tuint16_t event_idx, new_idx, old_idx;\n \tint intr;\n+\n+\tif (!vq || !vq->used)\n+\t\treturn;\n \n \t/*\n \t * Interrupt generation: if we're using EVENT_IDX,",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "",
      "\tif (!vq || !vq->used)",
      "\t\treturn;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/projectacrn/acrn-hypervisor/pull/6150",
  "description": {
    "pr_info": {
      "title": "dm: validate inputs in vq_endchains",
      "number": 6150
    },
    "comment": [
      " inputs shall be validated to avoid NULL pointer access.\r\n\r\nTracked-On: #6129\r\nSigned-off-by: Yonghua Huang <yonghua.huang@intel.com>",
      "No new violations to the coding guideline detected.<br>No New Name Conflict<br>No New Function Declaration/Definition Mismatch",
      "OK to verify",
      "try verify EHL",
      "try verify EHL",
      "OK to verify"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95"
}