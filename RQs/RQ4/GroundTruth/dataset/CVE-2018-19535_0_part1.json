{
  "cve_id": "CVE-2018-19535",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "Exiv2/exiv2",
  "commit_msg": "Fix bug in PngChunk::readRawProfile\n\n- Now it takes into account text.size_ when searching for a newline\nchar.",
  "commit_hash": "03173751b4d7053d6ddf52a15904e8f751f78f56",
  "git_url": "https://github.com/Exiv2/exiv2/commit/03173751b4d7053d6ddf52a15904e8f751f78f56",
  "file_path": "src/pngchunk_int.cpp",
  "func_name": "PngChunk::readRawProfile",
  "func_before": "DataBuf PngChunk::readRawProfile(const DataBuf& text,bool iTXt)\n    {\n        DataBuf                 info;\n        register long           i;\n        register unsigned char *dp;\n        const char             *sp;\n        unsigned int            nibbles;\n        long                    length;\n        unsigned char           unhex[103]={0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,\n                                            0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,\n                                            0,0,0,0,0,0,0,0,0,1, 2,3,4,5,6,7,8,9,0,0,\n                                            0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,\n                                            0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,10,11,12,\n                                            13,14,15};\n        if (text.size_ == 0) {\n            return DataBuf();\n        }\n\n        if ( iTXt ) {\n            info.alloc(text.size_);\n            ::memcpy(info.pData_,text.pData_,text.size_);\n            return  info;\n        }\n\n\n        sp = (char*)text.pData_+1;\n\n        // Look for newline\n\n        while (*sp != '\\n')\n            sp++;\n\n        // Look for length\n\n        while (*sp == '\\0' || *sp == ' ' || *sp == '\\n')\n            sp++;\n\n        length = (long) atol(sp);\n\n        while (*sp != ' ' && *sp != '\\n')\n            sp++;\n\n        // Allocate space\n\n        if (length == 0)\n        {\n#ifdef DEBUG\n            std::cerr << \"Exiv2::PngChunk::readRawProfile: Unable To Copy Raw Profile: invalid profile length\\n\";\n#endif\n        }\n\n        info.alloc(length);\n\n        if (info.size_ != length)\n        {\n#ifdef DEBUG\n            std::cerr << \"Exiv2::PngChunk::readRawProfile: Unable To Copy Raw Profile: cannot allocate memory\\n\";\n#endif\n            return DataBuf();\n        }\n\n        // Copy profile, skipping white space and column 1 \"=\" signs\n\n        dp      = (unsigned char*)info.pData_;\n        nibbles = length * 2;\n\n        for (i = 0; i < (long) nibbles; i++)\n        {\n            while (*sp < '0' || (*sp > '9' && *sp < 'a') || *sp > 'f')\n            {\n                if (*sp == '\\0')\n                {\n#ifdef DEBUG\n                    std::cerr << \"Exiv2::PngChunk::readRawProfile: Unable To Copy Raw Profile: ran out of data\\n\";\n#endif\n                    return DataBuf();\n                }\n\n                sp++;\n            }\n\n            if (i%2 == 0)\n                *dp = (unsigned char) (16*unhex[(int) *sp++]);\n            else\n                (*dp++) += unhex[(int) *sp++];\n        }\n\n        return info;\n\n    }",
  "abstract_func_before": "DataBuf PngChunk::readRawProfile(const DataBuf& VAR_0,bool VAR_1)\n    {\n        DataBuf                 VAR_2;\n        register long           VAR_3;\n        register unsigned char *VAR_4;\n        const char             *VAR_5;\n        unsigned int            VAR_6;\n        long                    VAR_7;\n        unsigned char           VAR_8[103]={0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,\n                                            0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,\n                                            0,0,0,0,0,0,0,0,0,1, 2,3,4,5,6,7,8,9,0,0,\n                                            0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,\n                                            0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,10,11,12,\n                                            13,14,15};\n        if (VAR_0.size_ == 0) {\n            return DataBuf();\n        }\n\n        if ( VAR_1 ) {\n            VAR_2.alloc(VAR_0.size_);\n            ::memcpy(VAR_2.pData_,VAR_0.pData_,VAR_0.size_);\n            return  VAR_2;\n        }\n\n\n        VAR_5 = (char*)VAR_0.pData_+1;\n\n        /* COMMENT_0 */\n\n        while (*VAR_5 != '\\n')\n            VAR_5++;\n\n        /* COMMENT_1 */\n\n        while (*VAR_5 == '\\0' || *VAR_5 == ' ' || *VAR_5 == '\\n')\n            VAR_5++;\n\n        VAR_7 = (long) atol(VAR_5);\n\n        while (*VAR_5 != ' ' && *VAR_5 != '\\n')\n            VAR_5++;\n\n        /* COMMENT_2 */\n\n        if (VAR_7 == 0)\n        {\n#ifdef VAR_9\n            std::cerr << \"Exiv2::PngChunk::readRawProfile: Unable To Copy Raw Profile: invalid profile length\\n\";\n#endif\n        }\n\n        VAR_2.alloc(VAR_7);\n\n        if (VAR_2.size_ != VAR_7)\n        {\n#ifdef VAR_9\n            std::cerr << \"Exiv2::PngChunk::readRawProfile: Unable To Copy Raw Profile: cannot allocate memory\\n\";\n#endif\n            return DataBuf();\n        }\n\n        /* COMMENT_3 */\n\n        VAR_4      = (unsigned char*)VAR_2.pData_;\n        VAR_6 = VAR_7 * 2;\n\n        for (VAR_3 = 0; VAR_3 < (long) VAR_6; VAR_3++)\n        {\n            while (*VAR_5 < '0' || (*VAR_5 > '9' && *VAR_5 < 'a') || *VAR_5 > 'f')\n            {\n                if (*VAR_5 == '\\0')\n                {\n#ifdef VAR_9\n                    std::cerr << \"Exiv2::PngChunk::readRawProfile: Unable To Copy Raw Profile: ran out of data\\n\";\n#endif\n                    return DataBuf();\n                }\n\n                VAR_5++;\n            }\n\n            if (VAR_3%2 == 0)\n                *VAR_4 = (unsigned char) (16*VAR_8[(int) *VAR_5++]);\n            else\n                (*VAR_4++) += VAR_8[(int) *VAR_5++];\n        }\n\n        return VAR_2;\n\n    }",
  "func_graph_path_before": "Exiv2/exiv2/03173751b4d7053d6ddf52a15904e8f751f78f56/pngchunk_int.cpp/vul/before/0.json",
  "func": "DataBuf PngChunk::readRawProfile(const DataBuf& text,bool iTXt)\n    {\n        DataBuf                 info;\n        register long           i;\n        register unsigned char *dp;\n        const char             *sp;\n        unsigned int            nibbles;\n        long                    length;\n        unsigned char           unhex[103]={0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,\n                                            0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,\n                                            0,0,0,0,0,0,0,0,0,1, 2,3,4,5,6,7,8,9,0,0,\n                                            0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,\n                                            0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,10,11,12,\n                                            13,14,15};\n        if (text.size_ == 0) {\n            return DataBuf();\n        }\n\n        if ( iTXt ) {\n            info.alloc(text.size_);\n            ::memcpy(info.pData_,text.pData_,text.size_);\n            return  info;\n        }\n\n\n        sp = (char*)text.pData_+1;\n        int pointerPos = 1;\n\n        // Look for newline\n        while (*sp != '\\n' && pointerPos < (text.size_ - 1))\n        {\n            sp++;\n            pointerPos++;\n        }\n\n        if (pointerPos == (text.size_ - 1))\n        {\n            return DataBuf();\n        }\n\n        // Look for length\n\n        while (*sp == '\\0' || *sp == ' ' || *sp == '\\n')\n            sp++;\n\n        length = (long) atol(sp);\n\n        while (*sp != ' ' && *sp != '\\n')\n            sp++;\n\n        // Allocate space\n\n        if (length == 0)\n        {\n#ifdef DEBUG\n            std::cerr << \"Exiv2::PngChunk::readRawProfile: Unable To Copy Raw Profile: invalid profile length\\n\";\n#endif\n        }\n\n        info.alloc(length);\n\n        if (info.size_ != length)\n        {\n#ifdef DEBUG\n            std::cerr << \"Exiv2::PngChunk::readRawProfile: Unable To Copy Raw Profile: cannot allocate memory\\n\";\n#endif\n            return DataBuf();\n        }\n\n        // Copy profile, skipping white space and column 1 \"=\" signs\n\n        dp      = (unsigned char*)info.pData_;\n        nibbles = length * 2;\n\n        for (i = 0; i < (long) nibbles; i++)\n        {\n            while (*sp < '0' || (*sp > '9' && *sp < 'a') || *sp > 'f')\n            {\n                if (*sp == '\\0')\n                {\n#ifdef DEBUG\n                    std::cerr << \"Exiv2::PngChunk::readRawProfile: Unable To Copy Raw Profile: ran out of data\\n\";\n#endif\n                    return DataBuf();\n                }\n\n                sp++;\n            }\n\n            if (i%2 == 0)\n                *dp = (unsigned char) (16*unhex[(int) *sp++]);\n            else\n                (*dp++) += unhex[(int) *sp++];\n        }\n\n        return info;\n\n    }",
  "abstract_func": "DataBuf PngChunk::readRawProfile(const DataBuf& VAR_0,bool VAR_1)\n    {\n        DataBuf                 VAR_2;\n        register long           VAR_3;\n        register unsigned char *VAR_4;\n        const char             *VAR_5;\n        unsigned int            VAR_6;\n        long                    VAR_7;\n        unsigned char           VAR_8[103]={0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,\n                                            0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,\n                                            0,0,0,0,0,0,0,0,0,1, 2,3,4,5,6,7,8,9,0,0,\n                                            0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,\n                                            0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,10,11,12,\n                                            13,14,15};\n        if (VAR_0.size_ == 0) {\n            return DataBuf();\n        }\n\n        if ( VAR_1 ) {\n            VAR_2.alloc(VAR_0.size_);\n            ::memcpy(VAR_2.pData_,VAR_0.pData_,VAR_0.size_);\n            return  VAR_2;\n        }\n\n\n        VAR_5 = (char*)VAR_0.pData_+1;\n        int VAR_9 = 1;\n\n        /* COMMENT_0 */\n        while (*VAR_5 != '\\n' && VAR_9 < (VAR_0.size_ - 1))\n        {\n            VAR_5++;\n            VAR_9++;\n        }\n\n        if (VAR_9 == (VAR_0.size_ - 1))\n        {\n            return DataBuf();\n        }\n\n        /* COMMENT_1 */\n\n        while (*VAR_5 == '\\0' || *VAR_5 == ' ' || *VAR_5 == '\\n')\n            VAR_5++;\n\n        VAR_7 = (long) atol(VAR_5);\n\n        while (*VAR_5 != ' ' && *VAR_5 != '\\n')\n            VAR_5++;\n\n        /* COMMENT_2 */\n\n        if (VAR_7 == 0)\n        {\n#ifdef VAR_10\n            std::cerr << \"Exiv2::PngChunk::readRawProfile: Unable To Copy Raw Profile: invalid profile length\\n\";\n#endif\n        }\n\n        VAR_2.alloc(VAR_7);\n\n        if (VAR_2.size_ != VAR_7)\n        {\n#ifdef VAR_10\n            std::cerr << \"Exiv2::PngChunk::readRawProfile: Unable To Copy Raw Profile: cannot allocate memory\\n\";\n#endif\n            return DataBuf();\n        }\n\n        /* COMMENT_3 */\n\n        VAR_4      = (unsigned char*)VAR_2.pData_;\n        VAR_6 = VAR_7 * 2;\n\n        for (VAR_3 = 0; VAR_3 < (long) VAR_6; VAR_3++)\n        {\n            while (*VAR_5 < '0' || (*VAR_5 > '9' && *VAR_5 < 'a') || *VAR_5 > 'f')\n            {\n                if (*VAR_5 == '\\0')\n                {\n#ifdef VAR_10\n                    std::cerr << \"Exiv2::PngChunk::readRawProfile: Unable To Copy Raw Profile: ran out of data\\n\";\n#endif\n                    return DataBuf();\n                }\n\n                VAR_5++;\n            }\n\n            if (VAR_3%2 == 0)\n                *VAR_4 = (unsigned char) (16*VAR_8[(int) *VAR_5++]);\n            else\n                (*VAR_4++) += VAR_8[(int) *VAR_5++];\n        }\n\n        return VAR_2;\n\n    }",
  "func_graph_path": "Exiv2/exiv2/03173751b4d7053d6ddf52a15904e8f751f78f56/pngchunk_int.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -24,11 +24,19 @@\n \n \n         sp = (char*)text.pData_+1;\n+        int pointerPos = 1;\n \n         // Look for newline\n+        while (*sp != '\\n' && pointerPos < (text.size_ - 1))\n+        {\n+            sp++;\n+            pointerPos++;\n+        }\n \n-        while (*sp != '\\n')\n-            sp++;\n+        if (pointerPos == (text.size_ - 1))\n+        {\n+            return DataBuf();\n+        }\n \n         // Look for length\n ",
  "diff_line_info": {
    "deleted_lines": [
      "        while (*sp != '\\n')",
      "            sp++;"
    ],
    "added_lines": [
      "        int pointerPos = 1;",
      "        while (*sp != '\\n' && pointerPos < (text.size_ - 1))",
      "        {",
      "            sp++;",
      "            pointerPos++;",
      "        }",
      "        if (pointerPos == (text.size_ - 1))",
      "        {",
      "            return DataBuf();",
      "        }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/Exiv2/exiv2/pull/430",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/Exiv2/exiv2/pull/430: 403 Client Error: Forbidden for url: https://api.github.com/repos/Exiv2/exiv2/pulls/430",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.8  \n\nThe patch addresses a bug in the readRawProfile function by adding bounds checking, which prevents potential out-of-bounds issues. While this improves safety, without explicit security context, it's classified as a defect fix."
}