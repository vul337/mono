{
  "cve_id": "CVE-2021-43518",
  "cwe_ids": [
    "CWE-120"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "teeworlds",
  "commit_msg": "hotfix CVE-2021-43518",
  "commit_hash": "91e5492d4c210f82f1ca6b43a73417fef5463368",
  "git_url": "https://github.com/teeworlds/teeworlds/commit/91e5492d4c210f82f1ca6b43a73417fef5463368",
  "file_path": "src/game/editor/io.cpp",
  "func_name": "CEditorMap::Load",
  "func_before": "int CEditorMap::Load(class IStorage *pStorage, const char *pFileName, int StorageType)\n{\n\tCDataFileReader DataFile;\n\tif(!DataFile.Open(pStorage, pFileName, StorageType))\n\t\treturn 0;\n\n\tClean();\n\n\t// check version\n\tCMapItemVersion *pItem = (CMapItemVersion *)DataFile.FindItem(MAPITEMTYPE_VERSION, 0);\n\tif(!pItem)\n\t{\n\t\treturn 0;\n\t}\n\telse if(pItem->m_Version == CMapItemVersion::CURRENT_VERSION)\n\t{\n\t\t// load map info\n\t\t{\n\t\t\tCMapItemInfo *pItem = (CMapItemInfo *)DataFile.FindItem(MAPITEMTYPE_INFO, 0);\n\t\t\tif(pItem && pItem->m_Version == 1)\n\t\t\t{\n\t\t\t\tif(pItem->m_Author > -1)\n\t\t\t\t\tstr_copy(m_MapInfo.m_aAuthor, (char *)DataFile.GetData(pItem->m_Author), sizeof(m_MapInfo.m_aAuthor));\n\t\t\t\tif(pItem->m_MapVersion > -1)\n\t\t\t\t\tstr_copy(m_MapInfo.m_aVersion, (char *)DataFile.GetData(pItem->m_MapVersion), sizeof(m_MapInfo.m_aVersion));\n\t\t\t\tif(pItem->m_Credits > -1)\n\t\t\t\t\tstr_copy(m_MapInfo.m_aCredits, (char *)DataFile.GetData(pItem->m_Credits), sizeof(m_MapInfo.m_aCredits));\n\t\t\t\tif(pItem->m_License > -1)\n\t\t\t\t\tstr_copy(m_MapInfo.m_aLicense, (char *)DataFile.GetData(pItem->m_License), sizeof(m_MapInfo.m_aLicense));\n\t\t\t}\n\t\t}\n\n\t\t// load images\n\t\t{\n\t\t\tint Start, Num;\n\t\t\tDataFile.GetType( MAPITEMTYPE_IMAGE, &Start, &Num);\n\t\t\tfor(int i = 0; i < Num; i++)\n\t\t\t{\n\t\t\t\tCMapItemImage *pItem = (CMapItemImage *)DataFile.GetItem(Start+i, 0, 0);\n\t\t\t\tchar *pName = (char *)DataFile.GetData(pItem->m_ImageName);\n\n\t\t\t\t// copy base info\n\t\t\t\tCEditorImage *pImg = new CEditorImage(m_pEditor);\n\t\t\t\tpImg->m_External = pItem->m_External;\n\n\t\t\t\tif(pItem->m_External || (pItem->m_Version > 1 && pItem->m_Format != CImageInfo::FORMAT_RGB && pItem->m_Format != CImageInfo::FORMAT_RGBA))\n\t\t\t\t{\n\t\t\t\t\tchar aBuf[IO_MAX_PATH_LENGTH];\n\t\t\t\t\tstr_format(aBuf, sizeof(aBuf),\"mapres/%s.png\", pName);\n\n\t\t\t\t\t// load external\n\t\t\t\t\tCEditorImage ImgInfo(m_pEditor);\n\t\t\t\t\tif(m_pEditor->Graphics()->LoadPNG(&ImgInfo, aBuf, IStorage::TYPE_ALL))\n\t\t\t\t\t{\n\t\t\t\t\t\t*pImg = ImgInfo;\n\t\t\t\t\t\tpImg->m_Texture = m_pEditor->Graphics()->LoadTextureRaw(ImgInfo.m_Width, ImgInfo.m_Height, ImgInfo.m_Format, ImgInfo.m_pData, CImageInfo::FORMAT_AUTO, IGraphics::TEXLOAD_MULTI_DIMENSION);\n\t\t\t\t\t\tImgInfo.m_pData = 0;\n\t\t\t\t\t\tpImg->m_External = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpImg->m_Width = pItem->m_Width;\n\t\t\t\t\tpImg->m_Height = pItem->m_Height;\n\t\t\t\t\tpImg->m_Format = pItem->m_Version == 1 ? CImageInfo::FORMAT_RGBA : pItem->m_Format;\n\t\t\t\t\tint PixelSize = pImg->m_Format == CImageInfo::FORMAT_RGB ? 3 : 4;\n\n\t\t\t\t\t// copy image data\n\t\t\t\t\tint DataSize = pImg->m_Width * pImg->m_Height * PixelSize;\n\t\t\t\t\tvoid *pData = DataFile.GetData(pItem->m_ImageData);\n\t\t\t\t\tpImg->m_pData = mem_alloc(DataSize);\n\t\t\t\t\tmem_copy(pImg->m_pData, pData, DataSize);\n\t\t\t\t\tpImg->m_Texture = m_pEditor->Graphics()->LoadTextureRaw(pImg->m_Width, pImg->m_Height, pImg->m_Format, pImg->m_pData, CImageInfo::FORMAT_AUTO, IGraphics::TEXLOAD_MULTI_DIMENSION);\n\t\t\t\t}\n\n\t\t\t\t// copy image name\n\t\t\t\tif(pName)\n\t\t\t\t\tstr_copy(pImg->m_aName, pName, 128);\n\n\t\t\t\t// load auto mapper file\n\t\t\t\tpImg->LoadAutoMapper();\n\n\t\t\t\tm_lImages.add(pImg);\n\n\t\t\t\t// unload image\n\t\t\t\tDataFile.UnloadData(pItem->m_ImageData);\n\t\t\t\tDataFile.UnloadData(pItem->m_ImageName);\n\t\t\t}\n\t\t}\n\n\t\t// load groups\n\t\t{\n\t\t\tint LayersStart, LayersNum;\n\t\t\tDataFile.GetType(MAPITEMTYPE_LAYER, &LayersStart, &LayersNum);\n\n\t\t\tint Start, Num;\n\t\t\tDataFile.GetType(MAPITEMTYPE_GROUP, &Start, &Num);\n\t\t\tfor(int g = 0; g < Num; g++)\n\t\t\t{\n\t\t\t\tCMapItemGroup *pGItem = (CMapItemGroup *)DataFile.GetItem(Start+g, 0, 0);\n\n\t\t\t\tif(pGItem->m_Version < 1 || pGItem->m_Version > CMapItemGroup::CURRENT_VERSION)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tCLayerGroup *pGroup = NewGroup();\n\t\t\t\tpGroup->m_ParallaxX = pGItem->m_ParallaxX;\n\t\t\t\tpGroup->m_ParallaxY = pGItem->m_ParallaxY;\n\t\t\t\tpGroup->m_OffsetX = pGItem->m_OffsetX;\n\t\t\t\tpGroup->m_OffsetY = pGItem->m_OffsetY;\n\n\t\t\t\tif(pGItem->m_Version >= 2)\n\t\t\t\t{\n\t\t\t\t\tpGroup->m_UseClipping = pGItem->m_UseClipping;\n\t\t\t\t\tpGroup->m_ClipX = pGItem->m_ClipX;\n\t\t\t\t\tpGroup->m_ClipY = pGItem->m_ClipY;\n\t\t\t\t\tpGroup->m_ClipW = pGItem->m_ClipW;\n\t\t\t\t\tpGroup->m_ClipH = pGItem->m_ClipH;\n\t\t\t\t}\n\n\t\t\t\t// load group name\n\t\t\t\tif(pGItem->m_Version >= 3)\n\t\t\t\t\tIntsToStr(pGItem->m_aName, sizeof(pGroup->m_aName)/sizeof(int), pGroup->m_aName);\n\n\t\t\t\tfor(int l = 0; l < pGItem->m_NumLayers; l++)\n\t\t\t\t{\n\t\t\t\t\tCLayer *pLayer = 0;\n\t\t\t\t\tCMapItemLayer *pLayerItem = (CMapItemLayer *)DataFile.GetItem(LayersStart+pGItem->m_StartLayer+l, 0, 0);\n\t\t\t\t\tif(!pLayerItem)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif(pLayerItem->m_Type == LAYERTYPE_TILES)\n\t\t\t\t\t{\n\t\t\t\t\t\tCMapItemLayerTilemap *pTilemapItem = (CMapItemLayerTilemap *)pLayerItem;\n\t\t\t\t\t\tCLayerTiles *pTiles = 0;\n\n\t\t\t\t\t\tif(pTilemapItem->m_Flags&TILESLAYERFLAG_GAME)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpTiles = new CLayerGame(pTilemapItem->m_Width, pTilemapItem->m_Height);\n\t\t\t\t\t\t\tMakeGameLayer(pTiles);\n\t\t\t\t\t\t\tMakeGameGroup(pGroup);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpTiles = new CLayerTiles(pTilemapItem->m_Width, pTilemapItem->m_Height);\n\t\t\t\t\t\t\tpTiles->m_pEditor = m_pEditor;\n\t\t\t\t\t\t\tpTiles->m_Color = pTilemapItem->m_Color;\n\t\t\t\t\t\t\tpTiles->m_ColorEnv = pTilemapItem->m_ColorEnv;\n\t\t\t\t\t\t\tpTiles->m_ColorEnvOffset = pTilemapItem->m_ColorEnvOffset;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpLayer = pTiles;\n\n\t\t\t\t\t\tpGroup->AddLayer(pTiles);\n\t\t\t\t\t\tvoid *pData = DataFile.GetData(pTilemapItem->m_Data);\n\t\t\t\t\t\tpTiles->m_Image = pTilemapItem->m_Image;\n\t\t\t\t\t\tpTiles->m_Game = pTilemapItem->m_Flags&TILESLAYERFLAG_GAME;\n\n\t\t\t\t\t\t// load layer name\n\t\t\t\t\t\tif(pTilemapItem->m_Version >= 3)\n\t\t\t\t\t\t\tIntsToStr(pTilemapItem->m_aName, sizeof(pTiles->m_aName)/sizeof(int), pTiles->m_aName);\n\n\t\t\t\t\t\t// get tile data\n\t\t\t\t\t\tif(pTilemapItem->m_Version > 3)\n\t\t\t\t\t\t\tpTiles->ExtractTiles((CTile *)pData);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tmem_copy(pTiles->m_pTiles, pData, pTiles->m_Width*pTiles->m_Height*sizeof(CTile));\n\n\n\t\t\t\t\t\tif(pTiles->m_Game && pTilemapItem->m_Version == MakeVersion(1, *pTilemapItem))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor(int i = 0; i < pTiles->m_Width*pTiles->m_Height; i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(pTiles->m_pTiles[i].m_Index)\n\t\t\t\t\t\t\t\t\tpTiles->m_pTiles[i].m_Index += ENTITY_OFFSET;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tDataFile.UnloadData(pTilemapItem->m_Data);\n\t\t\t\t\t}\n\t\t\t\t\telse if(pLayerItem->m_Type == LAYERTYPE_QUADS)\n\t\t\t\t\t{\n\t\t\t\t\t\tCMapItemLayerQuads *pQuadsItem = (CMapItemLayerQuads *)pLayerItem;\n\t\t\t\t\t\tCLayerQuads *pQuads = new CLayerQuads;\n\t\t\t\t\t\tpQuads->m_pEditor = m_pEditor;\n\t\t\t\t\t\tpLayer = pQuads;\n\t\t\t\t\t\tpQuads->m_Image = pQuadsItem->m_Image;\n\t\t\t\t\t\tif(pQuads->m_Image < -1 || pQuads->m_Image >= m_lImages.size())\n\t\t\t\t\t\t\tpQuads->m_Image = -1;\n\n\t\t\t\t\t\t// load layer name\n\t\t\t\t\t\tif(pQuadsItem->m_Version >= 2)\n\t\t\t\t\t\t\tIntsToStr(pQuadsItem->m_aName, sizeof(pQuads->m_aName)/sizeof(int), pQuads->m_aName);\n\n\t\t\t\t\t\tvoid *pData = DataFile.GetDataSwapped(pQuadsItem->m_Data);\n\t\t\t\t\t\tpGroup->AddLayer(pQuads);\n\t\t\t\t\t\tpQuads->m_lQuads.set_size(pQuadsItem->m_NumQuads);\n\t\t\t\t\t\tmem_copy(pQuads->m_lQuads.base_ptr(), pData, sizeof(CQuad)*pQuadsItem->m_NumQuads);\n\t\t\t\t\t\tDataFile.UnloadData(pQuadsItem->m_Data);\n\t\t\t\t\t}\n\n\t\t\t\t\tif(pLayer)\n\t\t\t\t\t\tpLayer->m_Flags = pLayerItem->m_Flags;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// load envelopes\n\t\t{\n\t\t\tCEnvPoint *pEnvPoints = 0;\n\t\t\t{\n\t\t\t\tint Start, Num;\n\t\t\t\tDataFile.GetType(MAPITEMTYPE_ENVPOINTS, &Start, &Num);\n\t\t\t\tif(Num)\n\t\t\t\t\tpEnvPoints = (CEnvPoint *)DataFile.GetItem(Start, 0, 0);\n\t\t\t}\n\n\t\t\tint Start, Num;\n\t\t\tDataFile.GetType(MAPITEMTYPE_ENVELOPE, &Start, &Num);\n\t\t\tfor(int e = 0; e < Num; e++)\n\t\t\t{\n\t\t\t\tCMapItemEnvelope *pItem = (CMapItemEnvelope *)DataFile.GetItem(Start+e, 0, 0);\n\t\t\t\tCEnvelope *pEnv = new CEnvelope(pItem->m_Channels);\n\t\t\t\tpEnv->m_lPoints.set_size(pItem->m_NumPoints);\n\t\t\t\tfor(int n = 0; n < pItem->m_NumPoints; n++)\n\t\t\t\t{\n\t\t\t\t\tif(pItem->m_Version >= 3)\n\t\t\t\t\t{\n\t\t\t\t\t\tpEnv->m_lPoints[n] = pEnvPoints[pItem->m_StartPoint + n];\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// backwards compatibility\n\t\t\t\t\t\tCEnvPoint_v1 *pEnvPoint_v1 = &((CEnvPoint_v1 *)pEnvPoints)[pItem->m_StartPoint + n];\n\t\t\t\t\t\tmem_zero((void*)&pEnv->m_lPoints[n], sizeof(CEnvPoint));\n\n\t\t\t\t\t\tpEnv->m_lPoints[n].m_Time = pEnvPoint_v1->m_Time;\n\t\t\t\t\t\tpEnv->m_lPoints[n].m_Curvetype = pEnvPoint_v1->m_Curvetype;\n\n\t\t\t\t\t\tfor(int c = 0; c < pItem->m_Channels; c++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpEnv->m_lPoints[n].m_aValues[c] = pEnvPoint_v1->m_aValues[c];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(pItem->m_aName[0] != -1)\t// compatibility with old maps\n\t\t\t\t\tIntsToStr(pItem->m_aName, sizeof(pItem->m_aName)/sizeof(int), pEnv->m_aName);\n\t\t\t\tm_lEnvelopes.add(pEnv);\n\t\t\t\tif(pItem->m_Version >= 2)\n\t\t\t\t\tpEnv->m_Synchronized = pItem->m_Synchronized;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t\treturn 0;\n\n\treturn 1;\n}",
  "abstract_func_before": "int CEditorMap::Load(class IStorage *VAR_0, const char *VAR_1, int VAR_2)\n{\n\tCDataFileReader VAR_3;\n\tif(!VAR_3.Open(VAR_0, VAR_1, VAR_2))\n\t\treturn 0;\n\n\tClean();\n\n\t/* COMMENT_0 */\n\tCMapItemVersion *VAR_4 = (CMapItemVersion *)VAR_3.FindItem(VAR_5, 0);\n\tif(!VAR_4)\n\t{\n\t\treturn 0;\n\t}\n\telse if(VAR_4->m_Version == CMapItemVersion::CURRENT_VERSION)\n\t{\n\t\t/* COMMENT_1 */\n\t\t{\n\t\t\tCMapItemInfo *VAR_4 = (CMapItemInfo *)VAR_3.FindItem(VAR_6, 0);\n\t\t\tif(VAR_4 && VAR_4->m_Version == 1)\n\t\t\t{\n\t\t\t\tif(VAR_4->m_Author > -1)\n\t\t\t\t\tstr_copy(VAR_7.m_aAuthor, (char *)VAR_3.GetData(VAR_4->m_Author), sizeof(VAR_7.m_aAuthor));\n\t\t\t\tif(VAR_4->m_MapVersion > -1)\n\t\t\t\t\tstr_copy(VAR_7.m_aVersion, (char *)VAR_3.GetData(VAR_4->m_MapVersion), sizeof(VAR_7.m_aVersion));\n\t\t\t\tif(VAR_4->m_Credits > -1)\n\t\t\t\t\tstr_copy(VAR_7.m_aCredits, (char *)VAR_3.GetData(VAR_4->m_Credits), sizeof(VAR_7.m_aCredits));\n\t\t\t\tif(VAR_4->m_License > -1)\n\t\t\t\t\tstr_copy(VAR_7.m_aLicense, (char *)VAR_3.GetData(VAR_4->m_License), sizeof(VAR_7.m_aLicense));\n\t\t\t}\n\t\t}\n\n\t\t/* COMMENT_2 */\n\t\t{\n\t\t\tint VAR_8, VAR_9;\n\t\t\tVAR_3.GetType( VAR_10, &VAR_8, &VAR_9);\n\t\t\tfor(int VAR_11 = 0; VAR_11 < VAR_9; VAR_11++)\n\t\t\t{\n\t\t\t\tCMapItemImage *VAR_4 = (CMapItemImage *)VAR_3.GetItem(VAR_8+VAR_11, 0, 0);\n\t\t\t\tchar *VAR_12 = (char *)VAR_3.GetData(VAR_4->m_ImageName);\n\n\t\t\t\t/* COMMENT_3 */\n\t\t\t\tCEditorImage *VAR_13 = new CEditorImage(VAR_14);\n\t\t\t\tVAR_13->m_External = VAR_4->m_External;\n\n\t\t\t\tif(VAR_4->m_External || (VAR_4->m_Version > 1 && VAR_4->m_Format != CImageInfo::FORMAT_RGB && VAR_4->m_Format != CImageInfo::FORMAT_RGBA))\n\t\t\t\t{\n\t\t\t\t\tchar VAR_15[VAR_16];\n\t\t\t\t\tstr_format(VAR_15, sizeof(VAR_15),\"mapres/%s.png\", VAR_12);\n\n\t\t\t\t\t/* COMMENT_4 */\n\t\t\t\t\tCEditorImage ImgInfo(m_pEditor);\n\t\t\t\t\tif(m_pEditor->Graphics()->LoadPNG(&VAR_17, VAR_15, IStorage::TYPE_ALL))\n\t\t\t\t\t{\n\t\t\t\t\t\t*VAR_13 = VAR_17;\n\t\t\t\t\t\tVAR_13->m_Texture = m_pEditor->Graphics()->LoadTextureRaw(VAR_17.m_Width, VAR_17.m_Height, VAR_17.m_Format, VAR_17.m_pData, CImageInfo::FORMAT_AUTO, IGraphics::TEXLOAD_MULTI_DIMENSION);\n\t\t\t\t\t\tVAR_17.m_pData = 0;\n\t\t\t\t\t\tVAR_13->m_External = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tVAR_13->m_Width = VAR_4->m_Width;\n\t\t\t\t\tVAR_13->m_Height = VAR_4->m_Height;\n\t\t\t\t\tVAR_13->m_Format = VAR_4->m_Version == 1 ? CImageInfo::FORMAT_RGBA : VAR_4->m_Format;\n\t\t\t\t\tint VAR_18 = VAR_13->m_Format == CImageInfo::FORMAT_RGB ? 3 : 4;\n\n\t\t\t\t\t/* COMMENT_5 */\n\t\t\t\t\tint VAR_19 = VAR_13->m_Width * VAR_13->m_Height * VAR_18;\n\t\t\t\t\tvoid *VAR_20 = VAR_3.GetData(VAR_4->m_ImageData);\n\t\t\t\t\tVAR_13->m_pData = mem_alloc(VAR_19);\n\t\t\t\t\tmem_copy(VAR_13->m_pData, VAR_20, VAR_19);\n\t\t\t\t\tVAR_13->m_Texture = m_pEditor->Graphics()->LoadTextureRaw(VAR_13->m_Width, VAR_13->m_Height, VAR_13->m_Format, VAR_13->m_pData, CImageInfo::FORMAT_AUTO, IGraphics::TEXLOAD_MULTI_DIMENSION);\n\t\t\t\t}\n\n\t\t\t\t/* COMMENT_6 */\n\t\t\t\tif(VAR_12)\n\t\t\t\t\tstr_copy(VAR_13->m_aName, VAR_12, 128);\n\n\t\t\t\t/* COMMENT_7 */\n\t\t\t\tVAR_13->LoadAutoMapper();\n\n\t\t\t\tVAR_21.add(VAR_13);\n\n\t\t\t\t/* COMMENT_8 */\n\t\t\t\tVAR_3.UnloadData(VAR_4->m_ImageData);\n\t\t\t\tVAR_3.UnloadData(VAR_4->m_ImageName);\n\t\t\t}\n\t\t}\n\n\t\t/* COMMENT_9 */\n\t\t{\n\t\t\tint VAR_22, VAR_23;\n\t\t\tVAR_3.GetType(VAR_24, &VAR_22, &VAR_23);\n\n\t\t\tint VAR_8, VAR_9;\n\t\t\tVAR_3.GetType(VAR_25, &VAR_8, &VAR_9);\n\t\t\tfor(int VAR_26 = 0; VAR_26 < VAR_9; VAR_26++)\n\t\t\t{\n\t\t\t\tCMapItemGroup *VAR_27 = (CMapItemGroup *)VAR_3.GetItem(VAR_8+VAR_26, 0, 0);\n\n\t\t\t\tif(VAR_27->m_Version < 1 || VAR_27->m_Version > CMapItemGroup::CURRENT_VERSION)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tCLayerGroup *VAR_28 = NewGroup();\n\t\t\t\tVAR_28->m_ParallaxX = VAR_27->m_ParallaxX;\n\t\t\t\tVAR_28->m_ParallaxY = VAR_27->m_ParallaxY;\n\t\t\t\tVAR_28->m_OffsetX = VAR_27->m_OffsetX;\n\t\t\t\tVAR_28->m_OffsetY = VAR_27->m_OffsetY;\n\n\t\t\t\tif(VAR_27->m_Version >= 2)\n\t\t\t\t{\n\t\t\t\t\tVAR_28->m_UseClipping = VAR_27->m_UseClipping;\n\t\t\t\t\tVAR_28->m_ClipX = VAR_27->m_ClipX;\n\t\t\t\t\tVAR_28->m_ClipY = VAR_27->m_ClipY;\n\t\t\t\t\tVAR_28->m_ClipW = VAR_27->m_ClipW;\n\t\t\t\t\tVAR_28->m_ClipH = VAR_27->m_ClipH;\n\t\t\t\t}\n\n\t\t\t\t/* COMMENT_10 */\n\t\t\t\tif(VAR_27->m_Version >= 3)\n\t\t\t\t\tIntsToStr(VAR_27->m_aName, sizeof(VAR_28->m_aName)/sizeof(int), VAR_28->m_aName);\n\n\t\t\t\tfor(int VAR_29 = 0; VAR_29 < VAR_27->m_NumLayers; VAR_29++)\n\t\t\t\t{\n\t\t\t\t\tCLayer *VAR_30 = 0;\n\t\t\t\t\tCMapItemLayer *VAR_31 = (CMapItemLayer *)VAR_3.GetItem(VAR_22+VAR_27->m_StartLayer+VAR_29, 0, 0);\n\t\t\t\t\tif(!VAR_31)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif(VAR_31->m_Type == VAR_32)\n\t\t\t\t\t{\n\t\t\t\t\t\tCMapItemLayerTilemap *VAR_33 = (CMapItemLayerTilemap *)VAR_31;\n\t\t\t\t\t\tCLayerTiles *VAR_34 = 0;\n\n\t\t\t\t\t\tif(VAR_33->m_Flags&VAR_35)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tVAR_34 = new CLayerGame(VAR_33->m_Width, VAR_33->m_Height);\n\t\t\t\t\t\t\tMakeGameLayer(VAR_34);\n\t\t\t\t\t\t\tMakeGameGroup(VAR_28);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tVAR_34 = new CLayerTiles(VAR_33->m_Width, VAR_33->m_Height);\n\t\t\t\t\t\t\tVAR_34->m_pEditor = m_pEditor;\n\t\t\t\t\t\t\tVAR_34->m_Color = VAR_33->m_Color;\n\t\t\t\t\t\t\tVAR_34->m_ColorEnv = VAR_33->m_ColorEnv;\n\t\t\t\t\t\t\tVAR_34->m_ColorEnvOffset = VAR_33->m_ColorEnvOffset;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tVAR_30 = VAR_34;\n\n\t\t\t\t\t\tVAR_28->AddLayer(VAR_34);\n\t\t\t\t\t\tvoid *VAR_20 = VAR_3.GetData(VAR_33->m_Data);\n\t\t\t\t\t\tVAR_34->m_Image = VAR_33->m_Image;\n\t\t\t\t\t\tVAR_34->m_Game = VAR_33->m_Flags&VAR_35;\n\n\t\t\t\t\t\t/* COMMENT_11 */\n\t\t\t\t\t\tif(VAR_33->m_Version >= 3)\n\t\t\t\t\t\t\tIntsToStr(VAR_33->m_aName, sizeof(VAR_34->m_aName)/sizeof(int), VAR_34->m_aName);\n\n\t\t\t\t\t\t/* COMMENT_12 */\n\t\t\t\t\t\tif(VAR_33->m_Version > 3)\n\t\t\t\t\t\t\tVAR_34->ExtractTiles((CTile *)VAR_20);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tmem_copy(VAR_34->m_pTiles, VAR_20, VAR_34->m_Width*VAR_34->m_Height*sizeof(CTile));\n\n\n\t\t\t\t\t\tif(VAR_34->m_Game && VAR_33->m_Version == MakeVersion(1, *VAR_33))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor(int VAR_11 = 0; VAR_11 < VAR_34->m_Width*VAR_34->m_Height; VAR_11++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(VAR_34->m_pTiles[VAR_11].m_Index)\n\t\t\t\t\t\t\t\t\tVAR_34->m_pTiles[VAR_11].m_Index += VAR_36;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tVAR_3.UnloadData(VAR_33->m_Data);\n\t\t\t\t\t}\n\t\t\t\t\telse if(VAR_31->m_Type == VAR_37)\n\t\t\t\t\t{\n\t\t\t\t\t\tCMapItemLayerQuads *VAR_38 = (CMapItemLayerQuads *)VAR_31;\n\t\t\t\t\t\tCLayerQuads *VAR_39 = new CLayerQuads;\n\t\t\t\t\t\tVAR_39->m_pEditor = m_pEditor;\n\t\t\t\t\t\tVAR_30 = VAR_39;\n\t\t\t\t\t\tVAR_39->m_Image = VAR_38->m_Image;\n\t\t\t\t\t\tif(VAR_39->m_Image < -1 || VAR_39->m_Image >= VAR_21.size())\n\t\t\t\t\t\t\tVAR_39->m_Image = -1;\n\n\t\t\t\t\t\t/* COMMENT_11 */\n\t\t\t\t\t\tif(VAR_38->m_Version >= 2)\n\t\t\t\t\t\t\tIntsToStr(VAR_38->m_aName, sizeof(VAR_39->m_aName)/sizeof(int), VAR_39->m_aName);\n\n\t\t\t\t\t\tvoid *VAR_20 = VAR_3.GetDataSwapped(VAR_38->m_Data);\n\t\t\t\t\t\tVAR_28->AddLayer(VAR_39);\n\t\t\t\t\t\tVAR_39->m_lQuads.set_size(VAR_38->m_NumQuads);\n\t\t\t\t\t\tmem_copy(VAR_39->m_lQuads.base_ptr(), VAR_20, sizeof(VAR_40)*VAR_38->m_NumQuads);\n\t\t\t\t\t\tVAR_3.UnloadData(VAR_38->m_Data);\n\t\t\t\t\t}\n\n\t\t\t\t\tif(VAR_30)\n\t\t\t\t\t\tVAR_30->m_Flags = VAR_31->m_Flags;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* COMMENT_13 */\n\t\t{\n\t\t\tCEnvPoint *VAR_41 = 0;\n\t\t\t{\n\t\t\t\tint VAR_8, VAR_9;\n\t\t\t\tVAR_3.GetType(VAR_42, &VAR_8, &VAR_9);\n\t\t\t\tif(VAR_9)\n\t\t\t\t\tVAR_41 = (CEnvPoint *)VAR_3.GetItem(VAR_8, 0, 0);\n\t\t\t}\n\n\t\t\tint VAR_8, VAR_9;\n\t\t\tVAR_3.GetType(VAR_43, &VAR_8, &VAR_9);\n\t\t\tfor(int VAR_44 = 0; VAR_44 < VAR_9; VAR_44++)\n\t\t\t{\n\t\t\t\tCMapItemEnvelope *VAR_4 = (CMapItemEnvelope *)VAR_3.GetItem(VAR_8+VAR_44, 0, 0);\n\t\t\t\tCEnvelope *VAR_45 = new CEnvelope(VAR_4->m_Channels);\n\t\t\t\tVAR_45->m_lPoints.set_size(VAR_4->m_NumPoints);\n\t\t\t\tfor(int VAR_46 = 0; VAR_46 < VAR_4->m_NumPoints; VAR_46++)\n\t\t\t\t{\n\t\t\t\t\tif(VAR_4->m_Version >= 3)\n\t\t\t\t\t{\n\t\t\t\t\t\tVAR_45->m_lPoints[VAR_46] = VAR_41[VAR_4->m_StartPoint + VAR_46];\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* COMMENT_14 */\n\t\t\t\t\t\tCEnvPoint_v1 *VAR_47 = &((CEnvPoint_v1 *)VAR_41)[VAR_4->m_StartPoint + VAR_46];\n\t\t\t\t\t\tmem_zero((void*)&VAR_45->m_lPoints[VAR_46], sizeof(CEnvPoint));\n\n\t\t\t\t\t\tVAR_45->m_lPoints[VAR_46].m_Time = VAR_47->m_Time;\n\t\t\t\t\t\tVAR_45->m_lPoints[VAR_46].m_Curvetype = VAR_47->m_Curvetype;\n\n\t\t\t\t\t\tfor(int VAR_48 = 0; VAR_48 < VAR_4->m_Channels; VAR_48++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tVAR_45->m_lPoints[VAR_46].m_aValues[VAR_48] = VAR_47->m_aValues[VAR_48];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(VAR_4->m_aName[0] != -1)\t/* COMMENT_15 */\n\t\t\t\t\tIntsToStr(VAR_4->m_aName, sizeof(VAR_4->m_aName)/sizeof(int), VAR_45->m_aName);\n\t\t\t\tVAR_49.add(VAR_45);\n\t\t\t\tif(VAR_4->m_Version >= 2)\n\t\t\t\t\tVAR_45->m_Synchronized = VAR_4->m_Synchronized;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t\treturn 0;\n\n\treturn 1;\n}",
  "func_graph_path_before": "teeworlds/91e5492d4c210f82f1ca6b43a73417fef5463368/io.cpp/vul/before/0.json",
  "func": "int CEditorMap::Load(class IStorage *pStorage, const char *pFileName, int StorageType)\n{\n\tCDataFileReader DataFile;\n\tif(!DataFile.Open(pStorage, pFileName, StorageType))\n\t\treturn 0;\n\n\tClean();\n\n\t// check version\n\tCMapItemVersion *pItem = (CMapItemVersion *)DataFile.FindItem(MAPITEMTYPE_VERSION, 0);\n\tif(!pItem)\n\t{\n\t\treturn 0;\n\t}\n\telse if(pItem->m_Version == CMapItemVersion::CURRENT_VERSION)\n\t{\n\t\t// load map info\n\t\t{\n\t\t\tCMapItemInfo *pItem = (CMapItemInfo *)DataFile.FindItem(MAPITEMTYPE_INFO, 0);\n\t\t\tif(pItem && pItem->m_Version == 1)\n\t\t\t{\n\t\t\t\tif(pItem->m_Author > -1)\n\t\t\t\t\tstr_copy(m_MapInfo.m_aAuthor, (char *)DataFile.GetData(pItem->m_Author), sizeof(m_MapInfo.m_aAuthor));\n\t\t\t\tif(pItem->m_MapVersion > -1)\n\t\t\t\t\tstr_copy(m_MapInfo.m_aVersion, (char *)DataFile.GetData(pItem->m_MapVersion), sizeof(m_MapInfo.m_aVersion));\n\t\t\t\tif(pItem->m_Credits > -1)\n\t\t\t\t\tstr_copy(m_MapInfo.m_aCredits, (char *)DataFile.GetData(pItem->m_Credits), sizeof(m_MapInfo.m_aCredits));\n\t\t\t\tif(pItem->m_License > -1)\n\t\t\t\t\tstr_copy(m_MapInfo.m_aLicense, (char *)DataFile.GetData(pItem->m_License), sizeof(m_MapInfo.m_aLicense));\n\t\t\t}\n\t\t}\n\n\t\t// load images\n\t\t{\n\t\t\tint Start, Num;\n\t\t\tDataFile.GetType( MAPITEMTYPE_IMAGE, &Start, &Num);\n\t\t\tfor(int i = 0; i < Num; i++)\n\t\t\t{\n\t\t\t\tCMapItemImage *pItem = (CMapItemImage *)DataFile.GetItem(Start+i, 0, 0);\n\t\t\t\tchar *pName = (char *)DataFile.GetData(pItem->m_ImageName);\n\n\t\t\t\t// copy base info\n\t\t\t\tCEditorImage *pImg = new CEditorImage(m_pEditor);\n\t\t\t\tpImg->m_External = pItem->m_External;\n\n\t\t\t\tif(pItem->m_External || (pItem->m_Version > 1 && pItem->m_Format != CImageInfo::FORMAT_RGB && pItem->m_Format != CImageInfo::FORMAT_RGBA))\n\t\t\t\t{\n\t\t\t\t\tchar aBuf[IO_MAX_PATH_LENGTH];\n\t\t\t\t\tstr_format(aBuf, sizeof(aBuf),\"mapres/%s.png\", pName);\n\n\t\t\t\t\t// load external\n\t\t\t\t\tCEditorImage ImgInfo(m_pEditor);\n\t\t\t\t\tif(m_pEditor->Graphics()->LoadPNG(&ImgInfo, aBuf, IStorage::TYPE_ALL))\n\t\t\t\t\t{\n\t\t\t\t\t\t*pImg = ImgInfo;\n\t\t\t\t\t\tpImg->m_Texture = m_pEditor->Graphics()->LoadTextureRaw(ImgInfo.m_Width, ImgInfo.m_Height, ImgInfo.m_Format, ImgInfo.m_pData, CImageInfo::FORMAT_AUTO, IGraphics::TEXLOAD_MULTI_DIMENSION);\n\t\t\t\t\t\tImgInfo.m_pData = 0;\n\t\t\t\t\t\tpImg->m_External = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpImg->m_Width = pItem->m_Width;\n\t\t\t\t\tpImg->m_Height = pItem->m_Height;\n\t\t\t\t\tpImg->m_Format = pItem->m_Version == 1 ? CImageInfo::FORMAT_RGBA : pItem->m_Format;\n\t\t\t\t\tint PixelSize = pImg->m_Format == CImageInfo::FORMAT_RGB ? 3 : 4;\n\n\t\t\t\t\t// copy image data\n\t\t\t\t\tint DataSize = pImg->m_Width * pImg->m_Height * PixelSize;\n\t\t\t\t\tvoid *pData = DataFile.GetData(pItem->m_ImageData);\n\t\t\t\t\tpImg->m_pData = mem_alloc(DataSize);\n\t\t\t\t\tmem_copy(pImg->m_pData, pData, DataSize);\n\t\t\t\t\tpImg->m_Texture = m_pEditor->Graphics()->LoadTextureRaw(pImg->m_Width, pImg->m_Height, pImg->m_Format, pImg->m_pData, CImageInfo::FORMAT_AUTO, IGraphics::TEXLOAD_MULTI_DIMENSION);\n\t\t\t\t}\n\n\t\t\t\t// copy image name\n\t\t\t\tif(pName)\n\t\t\t\t\tstr_copy(pImg->m_aName, pName, 128);\n\n\t\t\t\t// load auto mapper file\n\t\t\t\tpImg->LoadAutoMapper();\n\n\t\t\t\tm_lImages.add(pImg);\n\n\t\t\t\t// unload image\n\t\t\t\tDataFile.UnloadData(pItem->m_ImageData);\n\t\t\t\tDataFile.UnloadData(pItem->m_ImageName);\n\t\t\t}\n\t\t}\n\n\t\t// load groups\n\t\t{\n\t\t\tint LayersStart, LayersNum;\n\t\t\tDataFile.GetType(MAPITEMTYPE_LAYER, &LayersStart, &LayersNum);\n\n\t\t\tint Start, Num;\n\t\t\tDataFile.GetType(MAPITEMTYPE_GROUP, &Start, &Num);\n\t\t\tfor(int g = 0; g < Num; g++)\n\t\t\t{\n\t\t\t\tCMapItemGroup *pGItem = (CMapItemGroup *)DataFile.GetItem(Start+g, 0, 0);\n\n\t\t\t\tif(pGItem->m_Version < 1 || pGItem->m_Version > CMapItemGroup::CURRENT_VERSION)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tCLayerGroup *pGroup = NewGroup();\n\t\t\t\tpGroup->m_ParallaxX = pGItem->m_ParallaxX;\n\t\t\t\tpGroup->m_ParallaxY = pGItem->m_ParallaxY;\n\t\t\t\tpGroup->m_OffsetX = pGItem->m_OffsetX;\n\t\t\t\tpGroup->m_OffsetY = pGItem->m_OffsetY;\n\n\t\t\t\tif(pGItem->m_Version >= 2)\n\t\t\t\t{\n\t\t\t\t\tpGroup->m_UseClipping = pGItem->m_UseClipping;\n\t\t\t\t\tpGroup->m_ClipX = pGItem->m_ClipX;\n\t\t\t\t\tpGroup->m_ClipY = pGItem->m_ClipY;\n\t\t\t\t\tpGroup->m_ClipW = pGItem->m_ClipW;\n\t\t\t\t\tpGroup->m_ClipH = pGItem->m_ClipH;\n\t\t\t\t}\n\n\t\t\t\t// load group name\n\t\t\t\tif(pGItem->m_Version >= 3)\n\t\t\t\t\tIntsToStr(pGItem->m_aName, sizeof(pGroup->m_aName)/sizeof(int), pGroup->m_aName);\n\n\t\t\t\tfor(int l = 0; l < pGItem->m_NumLayers; l++)\n\t\t\t\t{\n\t\t\t\t\tCLayer *pLayer = 0;\n\t\t\t\t\tCMapItemLayer *pLayerItem = (CMapItemLayer *)DataFile.GetItem(LayersStart+pGItem->m_StartLayer+l, 0, 0);\n\t\t\t\t\tif(!pLayerItem)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif(pLayerItem->m_Type == LAYERTYPE_TILES)\n\t\t\t\t\t{\n\t\t\t\t\t\tCMapItemLayerTilemap *pTilemapItem = (CMapItemLayerTilemap *)pLayerItem;\n\t\t\t\t\t\tCLayerTiles *pTiles = 0;\n\n\t\t\t\t\t\tif(pTilemapItem->m_Flags&TILESLAYERFLAG_GAME)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpTiles = new CLayerGame(pTilemapItem->m_Width, pTilemapItem->m_Height);\n\t\t\t\t\t\t\tMakeGameLayer(pTiles);\n\t\t\t\t\t\t\tMakeGameGroup(pGroup);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpTiles = new CLayerTiles(pTilemapItem->m_Width, pTilemapItem->m_Height);\n\t\t\t\t\t\t\tpTiles->m_pEditor = m_pEditor;\n\t\t\t\t\t\t\tpTiles->m_Color = pTilemapItem->m_Color;\n\t\t\t\t\t\t\tpTiles->m_ColorEnv = pTilemapItem->m_ColorEnv;\n\t\t\t\t\t\t\tpTiles->m_ColorEnvOffset = pTilemapItem->m_ColorEnvOffset;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpLayer = pTiles;\n\n\t\t\t\t\t\tpGroup->AddLayer(pTiles);\n\t\t\t\t\t\tvoid *pData = DataFile.GetData(pTilemapItem->m_Data);\n\t\t\t\t\t\tpTiles->m_Image = pTilemapItem->m_Image;\n\t\t\t\t\t\tpTiles->m_Game = pTilemapItem->m_Flags&TILESLAYERFLAG_GAME;\n\n\t\t\t\t\t\t// load layer name\n\t\t\t\t\t\tif(pTilemapItem->m_Version >= 3)\n\t\t\t\t\t\t\tIntsToStr(pTilemapItem->m_aName, sizeof(pTiles->m_aName)/sizeof(int), pTiles->m_aName);\n\n\t\t\t\t\t\t// get tile data\n\t\t\t\t\t\tif(pTilemapItem->m_Version > 3)\n\t\t\t\t\t\t\tpTiles->ExtractTiles((CTile *)pData);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tmem_copy(pTiles->m_pTiles, pData, pTiles->m_Width*pTiles->m_Height*sizeof(CTile));\n\n\n\t\t\t\t\t\tif(pTiles->m_Game && pTilemapItem->m_Version == MakeVersion(1, *pTilemapItem))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor(int i = 0; i < pTiles->m_Width*pTiles->m_Height; i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(pTiles->m_pTiles[i].m_Index)\n\t\t\t\t\t\t\t\t\tpTiles->m_pTiles[i].m_Index += ENTITY_OFFSET;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tDataFile.UnloadData(pTilemapItem->m_Data);\n\t\t\t\t\t}\n\t\t\t\t\telse if(pLayerItem->m_Type == LAYERTYPE_QUADS)\n\t\t\t\t\t{\n\t\t\t\t\t\tCMapItemLayerQuads *pQuadsItem = (CMapItemLayerQuads *)pLayerItem;\n\t\t\t\t\t\tCLayerQuads *pQuads = new CLayerQuads;\n\t\t\t\t\t\tpQuads->m_pEditor = m_pEditor;\n\t\t\t\t\t\tpLayer = pQuads;\n\t\t\t\t\t\tpQuads->m_Image = pQuadsItem->m_Image;\n\t\t\t\t\t\tif(pQuads->m_Image < -1 || pQuads->m_Image >= m_lImages.size())\n\t\t\t\t\t\t\tpQuads->m_Image = -1;\n\n\t\t\t\t\t\t// load layer name\n\t\t\t\t\t\tif(pQuadsItem->m_Version >= 2)\n\t\t\t\t\t\t\tIntsToStr(pQuadsItem->m_aName, sizeof(pQuads->m_aName)/sizeof(int), pQuads->m_aName);\n\n\t\t\t\t\t\tvoid *pData = DataFile.GetDataSwapped(pQuadsItem->m_Data);\n\t\t\t\t\t\tpGroup->AddLayer(pQuads);\n\t\t\t\t\t\tpQuads->m_lQuads.set_size(pQuadsItem->m_NumQuads);\n\t\t\t\t\t\tmem_copy(pQuads->m_lQuads.base_ptr(), pData, sizeof(CQuad)*pQuadsItem->m_NumQuads);\n\t\t\t\t\t\tDataFile.UnloadData(pQuadsItem->m_Data);\n\t\t\t\t\t}\n\n\t\t\t\t\tif(pLayer)\n\t\t\t\t\t\tpLayer->m_Flags = pLayerItem->m_Flags;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// load envelopes\n\t\t{\n\t\t\tCEnvPoint *pEnvPoints = 0;\n\t\t\t{\n\t\t\t\tint Start, Num;\n\t\t\t\tDataFile.GetType(MAPITEMTYPE_ENVPOINTS, &Start, &Num);\n\t\t\t\tif(Num)\n\t\t\t\t\tpEnvPoints = (CEnvPoint *)DataFile.GetItem(Start, 0, 0);\n\t\t\t}\n\n\t\t\tint Start, Num;\n\t\t\tDataFile.GetType(MAPITEMTYPE_ENVELOPE, &Start, &Num);\n\t\t\tfor(int e = 0; e < Num; e++)\n\t\t\t{\n\t\t\t\tCMapItemEnvelope *pItem = (CMapItemEnvelope *)DataFile.GetItem(Start+e, 0, 0);\n\t\t\t\tconst int Channels = minimum(pItem->m_Channels, 4);\n\t\t\t\tCEnvelope *pEnv = new CEnvelope(Channels);\n\t\t\t\tpEnv->m_lPoints.set_size(pItem->m_NumPoints);\n\t\t\t\tfor(int n = 0; n < pItem->m_NumPoints; n++)\n\t\t\t\t{\n\t\t\t\t\tif(pItem->m_Version >= 3)\n\t\t\t\t\t{\n\t\t\t\t\t\tpEnv->m_lPoints[n] = pEnvPoints[pItem->m_StartPoint + n];\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// backwards compatibility\n\t\t\t\t\t\tCEnvPoint_v1 *pEnvPoint_v1 = &((CEnvPoint_v1 *)pEnvPoints)[pItem->m_StartPoint + n];\n\t\t\t\t\t\tmem_zero((void*)&pEnv->m_lPoints[n], sizeof(CEnvPoint));\n\n\t\t\t\t\t\tpEnv->m_lPoints[n].m_Time = pEnvPoint_v1->m_Time;\n\t\t\t\t\t\tpEnv->m_lPoints[n].m_Curvetype = pEnvPoint_v1->m_Curvetype;\n\n\t\t\t\t\t\tfor(int c = 0; c < Channels; c++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpEnv->m_lPoints[n].m_aValues[c] = pEnvPoint_v1->m_aValues[c];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(pItem->m_aName[0] != -1)\t// compatibility with old maps\n\t\t\t\t\tIntsToStr(pItem->m_aName, sizeof(pItem->m_aName)/sizeof(int), pEnv->m_aName);\n\t\t\t\tm_lEnvelopes.add(pEnv);\n\t\t\t\tif(pItem->m_Version >= 2)\n\t\t\t\t\tpEnv->m_Synchronized = pItem->m_Synchronized;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t\treturn 0;\n\n\treturn 1;\n}",
  "abstract_func": "int CEditorMap::Load(class IStorage *VAR_0, const char *VAR_1, int VAR_2)\n{\n\tCDataFileReader VAR_3;\n\tif(!VAR_3.Open(VAR_0, VAR_1, VAR_2))\n\t\treturn 0;\n\n\tClean();\n\n\t/* COMMENT_0 */\n\tCMapItemVersion *VAR_4 = (CMapItemVersion *)VAR_3.FindItem(VAR_5, 0);\n\tif(!VAR_4)\n\t{\n\t\treturn 0;\n\t}\n\telse if(VAR_4->m_Version == CMapItemVersion::CURRENT_VERSION)\n\t{\n\t\t/* COMMENT_1 */\n\t\t{\n\t\t\tCMapItemInfo *VAR_4 = (CMapItemInfo *)VAR_3.FindItem(VAR_6, 0);\n\t\t\tif(VAR_4 && VAR_4->m_Version == 1)\n\t\t\t{\n\t\t\t\tif(VAR_4->m_Author > -1)\n\t\t\t\t\tstr_copy(VAR_7.m_aAuthor, (char *)VAR_3.GetData(VAR_4->m_Author), sizeof(VAR_7.m_aAuthor));\n\t\t\t\tif(VAR_4->m_MapVersion > -1)\n\t\t\t\t\tstr_copy(VAR_7.m_aVersion, (char *)VAR_3.GetData(VAR_4->m_MapVersion), sizeof(VAR_7.m_aVersion));\n\t\t\t\tif(VAR_4->m_Credits > -1)\n\t\t\t\t\tstr_copy(VAR_7.m_aCredits, (char *)VAR_3.GetData(VAR_4->m_Credits), sizeof(VAR_7.m_aCredits));\n\t\t\t\tif(VAR_4->m_License > -1)\n\t\t\t\t\tstr_copy(VAR_7.m_aLicense, (char *)VAR_3.GetData(VAR_4->m_License), sizeof(VAR_7.m_aLicense));\n\t\t\t}\n\t\t}\n\n\t\t/* COMMENT_2 */\n\t\t{\n\t\t\tint VAR_8, VAR_9;\n\t\t\tVAR_3.GetType( VAR_10, &VAR_8, &VAR_9);\n\t\t\tfor(int VAR_11 = 0; VAR_11 < VAR_9; VAR_11++)\n\t\t\t{\n\t\t\t\tCMapItemImage *VAR_4 = (CMapItemImage *)VAR_3.GetItem(VAR_8+VAR_11, 0, 0);\n\t\t\t\tchar *VAR_12 = (char *)VAR_3.GetData(VAR_4->m_ImageName);\n\n\t\t\t\t/* COMMENT_3 */\n\t\t\t\tCEditorImage *VAR_13 = new CEditorImage(VAR_14);\n\t\t\t\tVAR_13->m_External = VAR_4->m_External;\n\n\t\t\t\tif(VAR_4->m_External || (VAR_4->m_Version > 1 && VAR_4->m_Format != CImageInfo::FORMAT_RGB && VAR_4->m_Format != CImageInfo::FORMAT_RGBA))\n\t\t\t\t{\n\t\t\t\t\tchar VAR_15[VAR_16];\n\t\t\t\t\tstr_format(VAR_15, sizeof(VAR_15),\"mapres/%s.png\", VAR_12);\n\n\t\t\t\t\t/* COMMENT_4 */\n\t\t\t\t\tCEditorImage ImgInfo(m_pEditor);\n\t\t\t\t\tif(m_pEditor->Graphics()->LoadPNG(&VAR_17, VAR_15, IStorage::TYPE_ALL))\n\t\t\t\t\t{\n\t\t\t\t\t\t*VAR_13 = VAR_17;\n\t\t\t\t\t\tVAR_13->m_Texture = m_pEditor->Graphics()->LoadTextureRaw(VAR_17.m_Width, VAR_17.m_Height, VAR_17.m_Format, VAR_17.m_pData, CImageInfo::FORMAT_AUTO, IGraphics::TEXLOAD_MULTI_DIMENSION);\n\t\t\t\t\t\tVAR_17.m_pData = 0;\n\t\t\t\t\t\tVAR_13->m_External = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tVAR_13->m_Width = VAR_4->m_Width;\n\t\t\t\t\tVAR_13->m_Height = VAR_4->m_Height;\n\t\t\t\t\tVAR_13->m_Format = VAR_4->m_Version == 1 ? CImageInfo::FORMAT_RGBA : VAR_4->m_Format;\n\t\t\t\t\tint VAR_18 = VAR_13->m_Format == CImageInfo::FORMAT_RGB ? 3 : 4;\n\n\t\t\t\t\t/* COMMENT_5 */\n\t\t\t\t\tint VAR_19 = VAR_13->m_Width * VAR_13->m_Height * VAR_18;\n\t\t\t\t\tvoid *VAR_20 = VAR_3.GetData(VAR_4->m_ImageData);\n\t\t\t\t\tVAR_13->m_pData = mem_alloc(VAR_19);\n\t\t\t\t\tmem_copy(VAR_13->m_pData, VAR_20, VAR_19);\n\t\t\t\t\tVAR_13->m_Texture = m_pEditor->Graphics()->LoadTextureRaw(VAR_13->m_Width, VAR_13->m_Height, VAR_13->m_Format, VAR_13->m_pData, CImageInfo::FORMAT_AUTO, IGraphics::TEXLOAD_MULTI_DIMENSION);\n\t\t\t\t}\n\n\t\t\t\t/* COMMENT_6 */\n\t\t\t\tif(VAR_12)\n\t\t\t\t\tstr_copy(VAR_13->m_aName, VAR_12, 128);\n\n\t\t\t\t/* COMMENT_7 */\n\t\t\t\tVAR_13->LoadAutoMapper();\n\n\t\t\t\tVAR_21.add(VAR_13);\n\n\t\t\t\t/* COMMENT_8 */\n\t\t\t\tVAR_3.UnloadData(VAR_4->m_ImageData);\n\t\t\t\tVAR_3.UnloadData(VAR_4->m_ImageName);\n\t\t\t}\n\t\t}\n\n\t\t/* COMMENT_9 */\n\t\t{\n\t\t\tint VAR_22, VAR_23;\n\t\t\tVAR_3.GetType(VAR_24, &VAR_22, &VAR_23);\n\n\t\t\tint VAR_8, VAR_9;\n\t\t\tVAR_3.GetType(VAR_25, &VAR_8, &VAR_9);\n\t\t\tfor(int VAR_26 = 0; VAR_26 < VAR_9; VAR_26++)\n\t\t\t{\n\t\t\t\tCMapItemGroup *VAR_27 = (CMapItemGroup *)VAR_3.GetItem(VAR_8+VAR_26, 0, 0);\n\n\t\t\t\tif(VAR_27->m_Version < 1 || VAR_27->m_Version > CMapItemGroup::CURRENT_VERSION)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tCLayerGroup *VAR_28 = NewGroup();\n\t\t\t\tVAR_28->m_ParallaxX = VAR_27->m_ParallaxX;\n\t\t\t\tVAR_28->m_ParallaxY = VAR_27->m_ParallaxY;\n\t\t\t\tVAR_28->m_OffsetX = VAR_27->m_OffsetX;\n\t\t\t\tVAR_28->m_OffsetY = VAR_27->m_OffsetY;\n\n\t\t\t\tif(VAR_27->m_Version >= 2)\n\t\t\t\t{\n\t\t\t\t\tVAR_28->m_UseClipping = VAR_27->m_UseClipping;\n\t\t\t\t\tVAR_28->m_ClipX = VAR_27->m_ClipX;\n\t\t\t\t\tVAR_28->m_ClipY = VAR_27->m_ClipY;\n\t\t\t\t\tVAR_28->m_ClipW = VAR_27->m_ClipW;\n\t\t\t\t\tVAR_28->m_ClipH = VAR_27->m_ClipH;\n\t\t\t\t}\n\n\t\t\t\t/* COMMENT_10 */\n\t\t\t\tif(VAR_27->m_Version >= 3)\n\t\t\t\t\tIntsToStr(VAR_27->m_aName, sizeof(VAR_28->m_aName)/sizeof(int), VAR_28->m_aName);\n\n\t\t\t\tfor(int VAR_29 = 0; VAR_29 < VAR_27->m_NumLayers; VAR_29++)\n\t\t\t\t{\n\t\t\t\t\tCLayer *VAR_30 = 0;\n\t\t\t\t\tCMapItemLayer *VAR_31 = (CMapItemLayer *)VAR_3.GetItem(VAR_22+VAR_27->m_StartLayer+VAR_29, 0, 0);\n\t\t\t\t\tif(!VAR_31)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif(VAR_31->m_Type == VAR_32)\n\t\t\t\t\t{\n\t\t\t\t\t\tCMapItemLayerTilemap *VAR_33 = (CMapItemLayerTilemap *)VAR_31;\n\t\t\t\t\t\tCLayerTiles *VAR_34 = 0;\n\n\t\t\t\t\t\tif(VAR_33->m_Flags&VAR_35)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tVAR_34 = new CLayerGame(VAR_33->m_Width, VAR_33->m_Height);\n\t\t\t\t\t\t\tMakeGameLayer(VAR_34);\n\t\t\t\t\t\t\tMakeGameGroup(VAR_28);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tVAR_34 = new CLayerTiles(VAR_33->m_Width, VAR_33->m_Height);\n\t\t\t\t\t\t\tVAR_34->m_pEditor = m_pEditor;\n\t\t\t\t\t\t\tVAR_34->m_Color = VAR_33->m_Color;\n\t\t\t\t\t\t\tVAR_34->m_ColorEnv = VAR_33->m_ColorEnv;\n\t\t\t\t\t\t\tVAR_34->m_ColorEnvOffset = VAR_33->m_ColorEnvOffset;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tVAR_30 = VAR_34;\n\n\t\t\t\t\t\tVAR_28->AddLayer(VAR_34);\n\t\t\t\t\t\tvoid *VAR_20 = VAR_3.GetData(VAR_33->m_Data);\n\t\t\t\t\t\tVAR_34->m_Image = VAR_33->m_Image;\n\t\t\t\t\t\tVAR_34->m_Game = VAR_33->m_Flags&VAR_35;\n\n\t\t\t\t\t\t/* COMMENT_11 */\n\t\t\t\t\t\tif(VAR_33->m_Version >= 3)\n\t\t\t\t\t\t\tIntsToStr(VAR_33->m_aName, sizeof(VAR_34->m_aName)/sizeof(int), VAR_34->m_aName);\n\n\t\t\t\t\t\t/* COMMENT_12 */\n\t\t\t\t\t\tif(VAR_33->m_Version > 3)\n\t\t\t\t\t\t\tVAR_34->ExtractTiles((CTile *)VAR_20);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tmem_copy(VAR_34->m_pTiles, VAR_20, VAR_34->m_Width*VAR_34->m_Height*sizeof(CTile));\n\n\n\t\t\t\t\t\tif(VAR_34->m_Game && VAR_33->m_Version == MakeVersion(1, *VAR_33))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor(int VAR_11 = 0; VAR_11 < VAR_34->m_Width*VAR_34->m_Height; VAR_11++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(VAR_34->m_pTiles[VAR_11].m_Index)\n\t\t\t\t\t\t\t\t\tVAR_34->m_pTiles[VAR_11].m_Index += VAR_36;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tVAR_3.UnloadData(VAR_33->m_Data);\n\t\t\t\t\t}\n\t\t\t\t\telse if(VAR_31->m_Type == VAR_37)\n\t\t\t\t\t{\n\t\t\t\t\t\tCMapItemLayerQuads *VAR_38 = (CMapItemLayerQuads *)VAR_31;\n\t\t\t\t\t\tCLayerQuads *VAR_39 = new CLayerQuads;\n\t\t\t\t\t\tVAR_39->m_pEditor = m_pEditor;\n\t\t\t\t\t\tVAR_30 = VAR_39;\n\t\t\t\t\t\tVAR_39->m_Image = VAR_38->m_Image;\n\t\t\t\t\t\tif(VAR_39->m_Image < -1 || VAR_39->m_Image >= VAR_21.size())\n\t\t\t\t\t\t\tVAR_39->m_Image = -1;\n\n\t\t\t\t\t\t/* COMMENT_11 */\n\t\t\t\t\t\tif(VAR_38->m_Version >= 2)\n\t\t\t\t\t\t\tIntsToStr(VAR_38->m_aName, sizeof(VAR_39->m_aName)/sizeof(int), VAR_39->m_aName);\n\n\t\t\t\t\t\tvoid *VAR_20 = VAR_3.GetDataSwapped(VAR_38->m_Data);\n\t\t\t\t\t\tVAR_28->AddLayer(VAR_39);\n\t\t\t\t\t\tVAR_39->m_lQuads.set_size(VAR_38->m_NumQuads);\n\t\t\t\t\t\tmem_copy(VAR_39->m_lQuads.base_ptr(), VAR_20, sizeof(VAR_40)*VAR_38->m_NumQuads);\n\t\t\t\t\t\tVAR_3.UnloadData(VAR_38->m_Data);\n\t\t\t\t\t}\n\n\t\t\t\t\tif(VAR_30)\n\t\t\t\t\t\tVAR_30->m_Flags = VAR_31->m_Flags;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* COMMENT_13 */\n\t\t{\n\t\t\tCEnvPoint *VAR_41 = 0;\n\t\t\t{\n\t\t\t\tint VAR_8, VAR_9;\n\t\t\t\tVAR_3.GetType(VAR_42, &VAR_8, &VAR_9);\n\t\t\t\tif(VAR_9)\n\t\t\t\t\tVAR_41 = (CEnvPoint *)VAR_3.GetItem(VAR_8, 0, 0);\n\t\t\t}\n\n\t\t\tint VAR_8, VAR_9;\n\t\t\tVAR_3.GetType(VAR_43, &VAR_8, &VAR_9);\n\t\t\tfor(int VAR_44 = 0; VAR_44 < VAR_9; VAR_44++)\n\t\t\t{\n\t\t\t\tCMapItemEnvelope *VAR_4 = (CMapItemEnvelope *)VAR_3.GetItem(VAR_8+VAR_44, 0, 0);\n\t\t\t\tconst int VAR_45 = minimum(VAR_4->m_Channels, 4);\n\t\t\t\tCEnvelope *VAR_46 = new CEnvelope(VAR_45);\n\t\t\t\tVAR_46->m_lPoints.set_size(VAR_4->m_NumPoints);\n\t\t\t\tfor(int VAR_47 = 0; VAR_47 < VAR_4->m_NumPoints; VAR_47++)\n\t\t\t\t{\n\t\t\t\t\tif(VAR_4->m_Version >= 3)\n\t\t\t\t\t{\n\t\t\t\t\t\tVAR_46->m_lPoints[VAR_47] = VAR_41[VAR_4->m_StartPoint + VAR_47];\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* COMMENT_14 */\n\t\t\t\t\t\tCEnvPoint_v1 *VAR_48 = &((CEnvPoint_v1 *)VAR_41)[VAR_4->m_StartPoint + VAR_47];\n\t\t\t\t\t\tmem_zero((void*)&VAR_46->m_lPoints[VAR_47], sizeof(CEnvPoint));\n\n\t\t\t\t\t\tVAR_46->m_lPoints[VAR_47].m_Time = VAR_48->m_Time;\n\t\t\t\t\t\tVAR_46->m_lPoints[VAR_47].m_Curvetype = VAR_48->m_Curvetype;\n\n\t\t\t\t\t\tfor(int VAR_49 = 0; VAR_49 < VAR_45; VAR_49++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tVAR_46->m_lPoints[VAR_47].m_aValues[VAR_49] = VAR_48->m_aValues[VAR_49];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(VAR_4->m_aName[0] != -1)\t/* COMMENT_15 */\n\t\t\t\t\tIntsToStr(VAR_4->m_aName, sizeof(VAR_4->m_aName)/sizeof(int), VAR_46->m_aName);\n\t\t\t\tVAR_50.add(VAR_46);\n\t\t\t\tif(VAR_4->m_Version >= 2)\n\t\t\t\t\tVAR_46->m_Synchronized = VAR_4->m_Synchronized;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t\treturn 0;\n\n\treturn 1;\n}",
  "func_graph_path": "teeworlds/91e5492d4c210f82f1ca6b43a73417fef5463368/io.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -219,7 +219,8 @@\n \t\t\tfor(int e = 0; e < Num; e++)\n \t\t\t{\n \t\t\t\tCMapItemEnvelope *pItem = (CMapItemEnvelope *)DataFile.GetItem(Start+e, 0, 0);\n-\t\t\t\tCEnvelope *pEnv = new CEnvelope(pItem->m_Channels);\n+\t\t\t\tconst int Channels = minimum(pItem->m_Channels, 4);\n+\t\t\t\tCEnvelope *pEnv = new CEnvelope(Channels);\n \t\t\t\tpEnv->m_lPoints.set_size(pItem->m_NumPoints);\n \t\t\t\tfor(int n = 0; n < pItem->m_NumPoints; n++)\n \t\t\t\t{\n@@ -236,7 +237,7 @@\n \t\t\t\t\t\tpEnv->m_lPoints[n].m_Time = pEnvPoint_v1->m_Time;\n \t\t\t\t\t\tpEnv->m_lPoints[n].m_Curvetype = pEnvPoint_v1->m_Curvetype;\n \n-\t\t\t\t\t\tfor(int c = 0; c < pItem->m_Channels; c++)\n+\t\t\t\t\t\tfor(int c = 0; c < Channels; c++)\n \t\t\t\t\t\t{\n \t\t\t\t\t\t\tpEnv->m_lPoints[n].m_aValues[c] = pEnvPoint_v1->m_aValues[c];\n \t\t\t\t\t\t}",
  "diff_line_info": {
    "deleted_lines": [
      "\t\t\t\tCEnvelope *pEnv = new CEnvelope(pItem->m_Channels);",
      "\t\t\t\t\t\tfor(int c = 0; c < pItem->m_Channels; c++)"
    ],
    "added_lines": [
      "\t\t\t\tconst int Channels = minimum(pItem->m_Channels, 4);",
      "\t\t\t\tCEnvelope *pEnv = new CEnvelope(Channels);",
      "\t\t\t\t\t\tfor(int c = 0; c < Channels; c++)"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/teeworlds/teeworlds/pull/3018",
  "description": {
    "pr_info": {
      "title": "Hotfix CVE-2021-43518",
      "number": 3018
    },
    "comment": [
      "Hotfix for CVE-2021-43518. Closes #2981.\r\n\r\nAdding all the datafile validation (#2931) ended up being a rather large patch and it still needs some work. This hotfix just addresses the exploitable stack buffer overflow write.\r\n\r\nFixing the other issues individually would be pointless, as there are at least 50-100 more distinct maps that can crash the client or cause ASAN/UBSAN errors.",
      "I'm confused, why wasn't this released?",
      "> I'm confused, why wasn't this released?\r\n\r\nI guess because the proper fix it still a work in progress in https://github.com/teeworlds/teeworlds/pull/2931",
      "I don't understand the point of a *hotfix* if it isn't meant to be released immediately while the proper fix is in progress.",
      "> I don't understand the point of a _hotfix_ if it isn't meant to be released immediately while the proper fix is in progress.\r\n\r\nSafety for developers and others who build from source :D\r\nBut yea I guess you have a point here."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}