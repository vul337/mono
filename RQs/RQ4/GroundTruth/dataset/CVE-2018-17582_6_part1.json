{
  "cve_id": "CVE-2018-17582",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "appneta/tcpreplay",
  "commit_msg": "Bug #484 CVE-2018-17582 Check for corrupt PCAP files\n\n* Check for packets that are larger than 262144 bytes\n* Check for capture lengths that are greater than packet length\n\nExample of a corrupt PCAP file ...\n\nsudo src/tcpreplay -i ens33 --unique-ip -t --loop 4 get_next_paket_01\nsafe_pcap_next ERROR: Invalid packet length in send_packets.c:get_next_packet() line 1054: 8388670 is greater than maximum 262144",
  "commit_hash": "68f67b1a3a4d319543692afb5bd5b191ec984287",
  "git_url": "https://github.com/appneta/tcpreplay/commit/68f67b1a3a4d319543692afb5bd5b191ec984287",
  "file_path": "src/tcpprep.c",
  "func_name": "process_raw_packets",
  "func_before": "static COUNTER\nprocess_raw_packets(pcap_t * pcap)\n{\n    ipv4_hdr_t *ip_hdr = NULL;\n    ipv6_hdr_t *ip6_hdr = NULL;\n    eth_hdr_t *eth_hdr = NULL;\n    struct pcap_pkthdr pkthdr;\n    const u_char *pktdata = NULL;\n    COUNTER packetnum = 0;\n    int l2len;\n    u_char ipbuff[MAXPACKET], *buffptr;\n    tcpr_dir_t direction = TCPR_DIR_ERROR;\n    tcpprep_opt_t *options = tcpprep->options;\n\n    assert(pcap);\n    \n    while ((pktdata = pcap_next(pcap, &pkthdr)) != NULL) {\n        packetnum++;\n\n        dbgx(1, \"Packet \" COUNTER_SPEC, packetnum);\n\n        /* look for include or exclude LIST match */\n        if (options->xX.list != NULL) {\n            if (options->xX.mode < xXExclude) {\n                /* include list */\n                if (!check_list(options->xX.list, packetnum)) {\n                    add_cache(&(options->cachedata), DONT_SEND, 0);\n                    continue;\n                }\n            }\n            /* exclude list */\n            else if (check_list(options->xX.list, packetnum)) {\n                add_cache(&(options->cachedata), DONT_SEND, 0);\n                continue;\n            }\n        }\n\n        /*\n         * If the packet doesn't include an IPv4 header we should just treat\n         * it as a non-IP packet, UNLESS we're in MAC mode, in which case\n         * we should let the MAC matcher below handle it\n         */\n        if (options->mode != MAC_MODE) {\n            dbg(3, \"Looking for IPv4/v6 header in non-MAC mode\");\n            \n            /* get the IP header (if any) */\n            buffptr = ipbuff;\n    \n            /* first look for IPv4 */\n            if ((ip_hdr = (ipv4_hdr_t *)get_ipv4(pktdata, pkthdr.caplen, \n                    pcap_datalink(pcap), &buffptr))) {\n                dbg(2, \"Packet is IPv4\");\n            } else if ((ip6_hdr = (ipv6_hdr_t *)get_ipv6(pktdata, pkthdr.caplen,\n                    pcap_datalink(pcap), &buffptr))) {\n                /* IPv6 */\n                dbg(2, \"Packet is IPv6\");    \n            } else {\n                /* we're something else... */\n                dbg(2, \"Packet isn't IPv4/v6\");\n\n                /* we don't want to cache these packets twice */\n                if (options->mode != AUTO_MODE) {\n                    dbg(3, \"Adding to cache using options for Non-IP packets\");\n                    add_cache(&options->cachedata, SEND, options->nonip);\n                }\n\n                /* go to next packet */\n                continue;\n            }\n    \n            l2len = get_l2len(pktdata, pkthdr.caplen, pcap_datalink(pcap));\n            if (l2len < 0) {\n                /* go to next packet */\n                continue;\n            }\n\n            /* look for include or exclude CIDR match */\n            if (options->xX.cidr != NULL) {\n                if (ip_hdr) {\n                    if (!process_xX_by_cidr_ipv4(options->xX.mode, options->xX.cidr, ip_hdr)) {\n                        add_cache(&options->cachedata, DONT_SEND, 0);\n                        continue;\n                    }\n                } else if (ip6_hdr) {\n                    if (!process_xX_by_cidr_ipv6(options->xX.mode, options->xX.cidr, ip6_hdr)) {\n                        add_cache(&options->cachedata, DONT_SEND, 0);\n                        continue;\n                    }\n                }\n            }\n        }\n\n        switch (options->mode) {\n        case REGEX_MODE:\n            dbg(2, \"processing regex mode...\");\n            if (ip_hdr) {\n                direction = check_ipv4_regex(ip_hdr->ip_src.s_addr);\n            } else if (ip6_hdr) {\n                direction = check_ipv6_regex(&ip6_hdr->ip_src);\n            }\n\n            /* reverse direction? */\n            if (HAVE_OPT(REVERSE) && (direction == TCPR_DIR_C2S || direction == TCPR_DIR_S2C))\n                direction = direction == TCPR_DIR_C2S ? TCPR_DIR_S2C : TCPR_DIR_C2S;\n\n            add_cache(&options->cachedata, SEND, direction);\n            break;\n\n        case CIDR_MODE:\n            dbg(2, \"processing cidr mode...\");\n            if (ip_hdr) {\n                direction = check_ip_cidr(options->cidrdata, ip_hdr->ip_src.s_addr) ? TCPR_DIR_C2S : TCPR_DIR_S2C;\n            } else if (ip6_hdr) {\n                direction = check_ip6_cidr(options->cidrdata, &ip6_hdr->ip_src) ? TCPR_DIR_C2S : TCPR_DIR_S2C;\n            }\n\n            /* reverse direction? */\n            if (HAVE_OPT(REVERSE) && (direction == TCPR_DIR_C2S || direction == TCPR_DIR_S2C))\n                direction = direction == TCPR_DIR_C2S ? TCPR_DIR_S2C : TCPR_DIR_C2S;\n\n            add_cache(&options->cachedata, SEND, direction);\n            break;\n\n        case MAC_MODE:\n            dbg(2, \"processing mac mode...\");\n            if (pkthdr.caplen < sizeof(*eth_hdr)) {\n                dbg(2, \"capture length too short for mac mode processing\");\n                break;\n            }\n\n            eth_hdr = (eth_hdr_t *)pktdata;\n            direction = macinstring(options->maclist, (u_char *)eth_hdr->ether_shost);\n\n            /* reverse direction? */\n            if (HAVE_OPT(REVERSE) && (direction == TCPR_DIR_C2S || direction == TCPR_DIR_S2C))\n                direction = direction == TCPR_DIR_C2S ? TCPR_DIR_S2C : TCPR_DIR_C2S;\n\n            add_cache(&options->cachedata, SEND, direction);\n            break;\n\n        case AUTO_MODE:\n            dbg(2, \"processing first pass of auto mode...\");\n            /* first run through in auto mode: create tree */\n            if (options->automode != FIRST_MODE) {\n                if (ip_hdr) {\n                    add_tree_ipv4(ip_hdr->ip_src.s_addr, pktdata, pkthdr.caplen);\n                } else if (ip6_hdr) {\n                    add_tree_ipv6(&ip6_hdr->ip_src, pktdata, pkthdr.caplen);\n                }\n            } else {\n                if (ip_hdr) {\n                    add_tree_first_ipv4(pktdata, pkthdr.caplen);\n                } else if (ip6_hdr) {\n                    add_tree_first_ipv6(pktdata, pkthdr.caplen);\n                }\n            }  \n            break;\n\n        case ROUTER_MODE:\n            /* \n             * second run through in auto mode: create route\n             * based cache\n             */\n            dbg(2, \"processing second pass of auto: router mode...\");\n            if (ip_hdr) {\n                add_cache(&options->cachedata, SEND,\n                    check_ip_tree(options->nonip, ip_hdr->ip_src.s_addr));\n            } else {\n                add_cache(&options->cachedata, SEND,\n                    check_ip6_tree(options->nonip, &ip6_hdr->ip_src));\n            }\n            break;\n\n        case BRIDGE_MODE:\n            /*\n             * second run through in auto mode: create bridge\n             * based cache\n             */\n            dbg(2, \"processing second pass of auto: bridge mode...\");\n            if (ip_hdr) {\n                add_cache(&options->cachedata, SEND,\n                    check_ip_tree(DIR_UNKNOWN, ip_hdr->ip_src.s_addr));\n            } else {\n                add_cache(&options->cachedata, SEND,\n                    check_ip6_tree(DIR_UNKNOWN, &ip6_hdr->ip_src));\n            }\n            break;\n\n        case SERVER_MODE:\n            /* \n             * second run through in auto mode: create bridge\n             * where unknowns are servers\n             */\n            dbg(2, \"processing second pass of auto: server mode...\");\n            if (ip_hdr) {\n                add_cache(&options->cachedata, SEND,\n                    check_ip_tree(DIR_SERVER, ip_hdr->ip_src.s_addr));\n            } else {\n                add_cache(&options->cachedata, SEND,\n                    check_ip6_tree(DIR_SERVER, &ip6_hdr->ip_src));\n            }\n            break;\n\n        case CLIENT_MODE:\n            /* \n             * second run through in auto mode: create bridge\n             * where unknowns are clients\n             */\n            dbg(2, \"processing second pass of auto: client mode...\");\n            if (ip_hdr) {\n                add_cache(&options->cachedata, SEND,\n                    check_ip_tree(DIR_CLIENT, ip_hdr->ip_src.s_addr));\n            } else {\n                add_cache(&options->cachedata, SEND,\n                    check_ip6_tree(DIR_CLIENT, &ip6_hdr->ip_src));\n            }\n            break;\n\n        case PORT_MODE:\n            /*\n             * process ports based on their destination port\n             */\n            dbg(2, \"processing port mode...\");\n            add_cache(&options->cachedata, SEND,\n            \t\tcheck_dst_port(ip_hdr, ip6_hdr, (pkthdr.caplen - l2len)));\n            break;\n\n        case FIRST_MODE:\n            /*\n             * First packet mode, looks at each host and picks clients\n             * by the ones which send the first packet in a session\n             */\n            dbg(2, \"processing second pass of auto: first packet mode...\");\n            if (ip_hdr) {\n                add_cache(&options->cachedata, SEND,\n                    check_ip_tree(DIR_UNKNOWN, ip_hdr->ip_src.s_addr));\n            } else {\n                add_cache(&options->cachedata, SEND,\n                    check_ip6_tree(DIR_UNKNOWN, &ip6_hdr->ip_src));\n            }\n            break;\n            \n        default:\n            errx(-1, \"Whoops!  What mode are we in anyways? %d\", options->mode);\n        }\n#ifdef ENABLE_VERBOSE\n        if (options->verbose)\n            tcpdump_print(&tcpprep->tcpdump, &pkthdr, pktdata);\n#endif\n    }\n\n    return packetnum;\n}",
  "abstract_func_before": "static COUNTER\nprocess_raw_packets(pcap_t * VAR_0)\n{\n    ipv4_hdr_t *VAR_1 = NULL;\n    ipv6_hdr_t *VAR_2 = NULL;\n    eth_hdr_t *VAR_3 = NULL;\n    struct pcap_pkthdr VAR_4;\n    const u_char *VAR_5 = NULL;\n    COUNTER VAR_6 = 0;\n    int VAR_7;\n    u_char VAR_8[VAR_9], *VAR_10;\n    tcpr_dir_t VAR_11 = VAR_12;\n    tcpprep_opt_t *VAR_13 = VAR_14->options;\n\n    assert(VAR_0);\n    \n    while ((VAR_5 = pcap_next(VAR_0, &VAR_4)) != NULL) {\n        VAR_6++;\n\n        dbgx(1, \"Packet \" VAR_15, VAR_6);\n\n        /* COMMENT_0 */\n        if (VAR_13->xX.list != NULL) {\n            if (VAR_13->xX.mode < VAR_16) {\n                /* COMMENT_1 */\n                if (!check_list(VAR_13->xX.list, VAR_6)) {\n                    add_cache(&(VAR_13->cachedata), VAR_17, 0);\n                    continue;\n                }\n            }\n            /* COMMENT_2 */\n            else if (check_list(VAR_13->xX.list, VAR_6)) {\n                add_cache(&(VAR_13->cachedata), VAR_17, 0);\n                continue;\n            }\n        }\n\n        /* COMMENT_3 */\n                                                                            \n                                                                         \n                                                        \n           \n        if (VAR_13->mode != VAR_18) {\n            dbg(3, \"Looking for IPv4/v6 header in non-MAC mode\");\n            \n            /* COMMENT_8 */\n            VAR_10 = VAR_8;\n    \n            /* COMMENT_9 */\n            if ((VAR_1 = (ipv4_hdr_t *)get_ipv4(VAR_5, VAR_4.caplen, \n                    pcap_datalink(VAR_0), &VAR_10))) {\n                dbg(2, \"Packet is IPv4\");\n            } else if ((VAR_2 = (ipv6_hdr_t *)get_ipv6(VAR_5, VAR_4.caplen,\n                    pcap_datalink(VAR_0), &VAR_10))) {\n                /* COMMENT_10 */\n                dbg(2, \"Packet is IPv6\");    \n            } else {\n                /* COMMENT_11 */\n                dbg(2, \"Packet isn't IPv4/v6\");\n\n                /* COMMENT_12 */\n                if (VAR_13->mode != VAR_19) {\n                    dbg(3, \"Adding to cache using options for Non-IP packets\");\n                    add_cache(&VAR_13->cachedata, VAR_20, VAR_13->nonip);\n                }\n\n                /* COMMENT_13 */\n                continue;\n            }\n    \n            VAR_7 = get_l2len(VAR_5, VAR_4.caplen, pcap_datalink(VAR_0));\n            if (VAR_7 < 0) {\n                /* COMMENT_13 */\n                continue;\n            }\n\n            /* COMMENT_14 */\n            if (VAR_13->xX.cidr != NULL) {\n                if (VAR_1) {\n                    if (!process_xX_by_cidr_ipv4(VAR_13->xX.mode, VAR_13->xX.cidr, VAR_1)) {\n                        add_cache(&VAR_13->cachedata, VAR_17, 0);\n                        continue;\n                    }\n                } else if (VAR_2) {\n                    if (!process_xX_by_cidr_ipv6(VAR_13->xX.mode, VAR_13->xX.cidr, VAR_2)) {\n                        add_cache(&VAR_13->cachedata, VAR_17, 0);\n                        continue;\n                    }\n                }\n            }\n        }\n\n        switch (VAR_13->mode) {\n        case VAR_21:\n            dbg(2, \"processing regex mode...\");\n            if (VAR_1) {\n                VAR_11 = check_ipv4_regex(VAR_1->ip_src.s_addr);\n            } else if (VAR_2) {\n                VAR_11 = check_ipv6_regex(&VAR_2->ip_src);\n            }\n\n            /* COMMENT_15 */\n            if (HAVE_OPT(VAR_22) && (VAR_11 == VAR_23 || VAR_11 == VAR_24))\n                VAR_11 = VAR_11 == VAR_23 ? VAR_24 : VAR_23;\n\n            add_cache(&VAR_13->cachedata, VAR_20, VAR_11);\n            break;\n\n        case VAR_25:\n            dbg(2, \"processing cidr mode...\");\n            if (VAR_1) {\n                VAR_11 = check_ip_cidr(VAR_13->cidrdata, VAR_1->ip_src.s_addr) ? VAR_23 : VAR_24;\n            } else if (VAR_2) {\n                VAR_11 = check_ip6_cidr(VAR_13->cidrdata, &VAR_2->ip_src) ? VAR_23 : VAR_24;\n            }\n\n            /* COMMENT_15 */\n            if (HAVE_OPT(VAR_22) && (VAR_11 == VAR_23 || VAR_11 == VAR_24))\n                VAR_11 = VAR_11 == VAR_23 ? VAR_24 : VAR_23;\n\n            add_cache(&VAR_13->cachedata, VAR_20, VAR_11);\n            break;\n\n        case VAR_18:\n            dbg(2, \"processing mac mode...\");\n            if (VAR_4.caplen < sizeof(*VAR_3)) {\n                dbg(2, \"capture length too short for mac mode processing\");\n                break;\n            }\n\n            VAR_3 = (eth_hdr_t *)VAR_5;\n            VAR_11 = macinstring(VAR_13->maclist, (u_char *)VAR_3->ether_shost);\n\n            /* COMMENT_15 */\n            if (HAVE_OPT(VAR_22) && (VAR_11 == VAR_23 || VAR_11 == VAR_24))\n                VAR_11 = VAR_11 == VAR_23 ? VAR_24 : VAR_23;\n\n            add_cache(&VAR_13->cachedata, VAR_20, VAR_11);\n            break;\n\n        case VAR_19:\n            dbg(2, \"processing first pass of auto mode...\");\n            /* COMMENT_16 */\n            if (VAR_13->automode != VAR_26) {\n                if (VAR_1) {\n                    add_tree_ipv4(VAR_1->ip_src.s_addr, VAR_5, VAR_4.caplen);\n                } else if (VAR_2) {\n                    add_tree_ipv6(&VAR_2->ip_src, VAR_5, VAR_4.caplen);\n                }\n            } else {\n                if (VAR_1) {\n                    add_tree_first_ipv4(VAR_5, VAR_4.caplen);\n                } else if (VAR_2) {\n                    add_tree_first_ipv6(VAR_5, VAR_4.caplen);\n                }\n            }  \n            break;\n\n        case VAR_27:\n            /* COMMENT_17 */\n                                                            \n                          \n               \n            dbg(2, \"processing second pass of auto: router mode...\");\n            if (VAR_1) {\n                add_cache(&VAR_13->cachedata, VAR_20,\n                    check_ip_tree(VAR_13->nonip, VAR_1->ip_src.s_addr));\n            } else {\n                add_cache(&VAR_13->cachedata, VAR_20,\n                    check_ip6_tree(VAR_13->nonip, &VAR_2->ip_src));\n            }\n            break;\n\n        case VAR_28:\n            /* COMMENT_21 */\n                                                             \n                          \n               \n            dbg(2, \"processing second pass of auto: bridge mode...\");\n            if (VAR_1) {\n                add_cache(&VAR_13->cachedata, VAR_20,\n                    check_ip_tree(VAR_29, VAR_1->ip_src.s_addr));\n            } else {\n                add_cache(&VAR_13->cachedata, VAR_20,\n                    check_ip6_tree(VAR_29, &VAR_2->ip_src));\n            }\n            break;\n\n        case VAR_30:\n            /* COMMENT_25 */\n                                                             \n                                         \n               \n            dbg(2, \"processing second pass of auto: server mode...\");\n            if (VAR_1) {\n                add_cache(&VAR_13->cachedata, VAR_20,\n                    check_ip_tree(VAR_31, VAR_1->ip_src.s_addr));\n            } else {\n                add_cache(&VAR_13->cachedata, VAR_20,\n                    check_ip6_tree(VAR_31, &VAR_2->ip_src));\n            }\n            break;\n\n        case VAR_32:\n            /* COMMENT_29 */\n                                                             \n                                         \n               \n            dbg(2, \"processing second pass of auto: client mode...\");\n            if (VAR_1) {\n                add_cache(&VAR_13->cachedata, VAR_20,\n                    check_ip_tree(VAR_33, VAR_1->ip_src.s_addr));\n            } else {\n                add_cache(&VAR_13->cachedata, VAR_20,\n                    check_ip6_tree(VAR_33, &VAR_2->ip_src));\n            }\n            break;\n\n        case VAR_34:\n            /* COMMENT_33 */\n                                                            \n               \n            dbg(2, \"processing port mode...\");\n            add_cache(&VAR_13->cachedata, VAR_20,\n            \t\tcheck_dst_port(VAR_1, VAR_2, (VAR_4.caplen - VAR_7)));\n            break;\n\n        case VAR_26:\n            /* COMMENT_36 */\n                                                                      \n                                                                   \n               \n            dbg(2, \"processing second pass of auto: first packet mode...\");\n            if (VAR_1) {\n                add_cache(&VAR_13->cachedata, VAR_20,\n                    check_ip_tree(VAR_29, VAR_1->ip_src.s_addr));\n            } else {\n                add_cache(&VAR_13->cachedata, VAR_20,\n                    check_ip6_tree(VAR_29, &VAR_2->ip_src));\n            }\n            break;\n            \n        default:\n            errx(-1, \"Whoops!  What mode are we in anyways? %d\", VAR_13->mode);\n        }\n#ifdef VAR_35\n        if (VAR_13->verbose)\n            tcpdump_print(&VAR_14->tcpdump, &VAR_4, VAR_5);\n#endif\n    }\n\n    return VAR_6;\n}",
  "func_graph_path_before": "appneta/tcpreplay/68f67b1a3a4d319543692afb5bd5b191ec984287/tcpprep.c/vul/before/0.json",
  "func": "static COUNTER\nprocess_raw_packets(pcap_t * pcap)\n{\n    ipv4_hdr_t *ip_hdr = NULL;\n    ipv6_hdr_t *ip6_hdr = NULL;\n    eth_hdr_t *eth_hdr = NULL;\n    struct pcap_pkthdr pkthdr;\n    const u_char *pktdata = NULL;\n    COUNTER packetnum = 0;\n    int l2len;\n    u_char ipbuff[MAXPACKET], *buffptr;\n    tcpr_dir_t direction = TCPR_DIR_ERROR;\n    tcpprep_opt_t *options = tcpprep->options;\n\n    assert(pcap);\n    \n    while ((pktdata = safe_pcap_next(pcap, &pkthdr)) != NULL) {\n        packetnum++;\n\n        dbgx(1, \"Packet \" COUNTER_SPEC, packetnum);\n\n        /* look for include or exclude LIST match */\n        if (options->xX.list != NULL) {\n            if (options->xX.mode < xXExclude) {\n                /* include list */\n                if (!check_list(options->xX.list, packetnum)) {\n                    add_cache(&(options->cachedata), DONT_SEND, 0);\n                    continue;\n                }\n            }\n            /* exclude list */\n            else if (check_list(options->xX.list, packetnum)) {\n                add_cache(&(options->cachedata), DONT_SEND, 0);\n                continue;\n            }\n        }\n\n        /*\n         * If the packet doesn't include an IPv4 header we should just treat\n         * it as a non-IP packet, UNLESS we're in MAC mode, in which case\n         * we should let the MAC matcher below handle it\n         */\n        if (options->mode != MAC_MODE) {\n            dbg(3, \"Looking for IPv4/v6 header in non-MAC mode\");\n            \n            /* get the IP header (if any) */\n            buffptr = ipbuff;\n    \n            /* first look for IPv4 */\n            if ((ip_hdr = (ipv4_hdr_t *)get_ipv4(pktdata, pkthdr.caplen, \n                    pcap_datalink(pcap), &buffptr))) {\n                dbg(2, \"Packet is IPv4\");\n            } else if ((ip6_hdr = (ipv6_hdr_t *)get_ipv6(pktdata, pkthdr.caplen,\n                    pcap_datalink(pcap), &buffptr))) {\n                /* IPv6 */\n                dbg(2, \"Packet is IPv6\");    \n            } else {\n                /* we're something else... */\n                dbg(2, \"Packet isn't IPv4/v6\");\n\n                /* we don't want to cache these packets twice */\n                if (options->mode != AUTO_MODE) {\n                    dbg(3, \"Adding to cache using options for Non-IP packets\");\n                    add_cache(&options->cachedata, SEND, options->nonip);\n                }\n\n                /* go to next packet */\n                continue;\n            }\n    \n            l2len = get_l2len(pktdata, pkthdr.caplen, pcap_datalink(pcap));\n            if (l2len < 0) {\n                /* go to next packet */\n                continue;\n            }\n\n            /* look for include or exclude CIDR match */\n            if (options->xX.cidr != NULL) {\n                if (ip_hdr) {\n                    if (!process_xX_by_cidr_ipv4(options->xX.mode, options->xX.cidr, ip_hdr)) {\n                        add_cache(&options->cachedata, DONT_SEND, 0);\n                        continue;\n                    }\n                } else if (ip6_hdr) {\n                    if (!process_xX_by_cidr_ipv6(options->xX.mode, options->xX.cidr, ip6_hdr)) {\n                        add_cache(&options->cachedata, DONT_SEND, 0);\n                        continue;\n                    }\n                }\n            }\n        }\n\n        switch (options->mode) {\n        case REGEX_MODE:\n            dbg(2, \"processing regex mode...\");\n            if (ip_hdr) {\n                direction = check_ipv4_regex(ip_hdr->ip_src.s_addr);\n            } else if (ip6_hdr) {\n                direction = check_ipv6_regex(&ip6_hdr->ip_src);\n            }\n\n            /* reverse direction? */\n            if (HAVE_OPT(REVERSE) && (direction == TCPR_DIR_C2S || direction == TCPR_DIR_S2C))\n                direction = direction == TCPR_DIR_C2S ? TCPR_DIR_S2C : TCPR_DIR_C2S;\n\n            add_cache(&options->cachedata, SEND, direction);\n            break;\n\n        case CIDR_MODE:\n            dbg(2, \"processing cidr mode...\");\n            if (ip_hdr) {\n                direction = check_ip_cidr(options->cidrdata, ip_hdr->ip_src.s_addr) ? TCPR_DIR_C2S : TCPR_DIR_S2C;\n            } else if (ip6_hdr) {\n                direction = check_ip6_cidr(options->cidrdata, &ip6_hdr->ip_src) ? TCPR_DIR_C2S : TCPR_DIR_S2C;\n            }\n\n            /* reverse direction? */\n            if (HAVE_OPT(REVERSE) && (direction == TCPR_DIR_C2S || direction == TCPR_DIR_S2C))\n                direction = direction == TCPR_DIR_C2S ? TCPR_DIR_S2C : TCPR_DIR_C2S;\n\n            add_cache(&options->cachedata, SEND, direction);\n            break;\n\n        case MAC_MODE:\n            dbg(2, \"processing mac mode...\");\n            if (pkthdr.caplen < sizeof(*eth_hdr)) {\n                dbg(2, \"capture length too short for mac mode processing\");\n                break;\n            }\n\n            eth_hdr = (eth_hdr_t *)pktdata;\n            direction = macinstring(options->maclist, (u_char *)eth_hdr->ether_shost);\n\n            /* reverse direction? */\n            if (HAVE_OPT(REVERSE) && (direction == TCPR_DIR_C2S || direction == TCPR_DIR_S2C))\n                direction = direction == TCPR_DIR_C2S ? TCPR_DIR_S2C : TCPR_DIR_C2S;\n\n            add_cache(&options->cachedata, SEND, direction);\n            break;\n\n        case AUTO_MODE:\n            dbg(2, \"processing first pass of auto mode...\");\n            /* first run through in auto mode: create tree */\n            if (options->automode != FIRST_MODE) {\n                if (ip_hdr) {\n                    add_tree_ipv4(ip_hdr->ip_src.s_addr, pktdata, pkthdr.caplen);\n                } else if (ip6_hdr) {\n                    add_tree_ipv6(&ip6_hdr->ip_src, pktdata, pkthdr.caplen);\n                }\n            } else {\n                if (ip_hdr) {\n                    add_tree_first_ipv4(pktdata, pkthdr.caplen);\n                } else if (ip6_hdr) {\n                    add_tree_first_ipv6(pktdata, pkthdr.caplen);\n                }\n            }  \n            break;\n\n        case ROUTER_MODE:\n            /* \n             * second run through in auto mode: create route\n             * based cache\n             */\n            dbg(2, \"processing second pass of auto: router mode...\");\n            if (ip_hdr) {\n                add_cache(&options->cachedata, SEND,\n                    check_ip_tree(options->nonip, ip_hdr->ip_src.s_addr));\n            } else {\n                add_cache(&options->cachedata, SEND,\n                    check_ip6_tree(options->nonip, &ip6_hdr->ip_src));\n            }\n            break;\n\n        case BRIDGE_MODE:\n            /*\n             * second run through in auto mode: create bridge\n             * based cache\n             */\n            dbg(2, \"processing second pass of auto: bridge mode...\");\n            if (ip_hdr) {\n                add_cache(&options->cachedata, SEND,\n                    check_ip_tree(DIR_UNKNOWN, ip_hdr->ip_src.s_addr));\n            } else {\n                add_cache(&options->cachedata, SEND,\n                    check_ip6_tree(DIR_UNKNOWN, &ip6_hdr->ip_src));\n            }\n            break;\n\n        case SERVER_MODE:\n            /* \n             * second run through in auto mode: create bridge\n             * where unknowns are servers\n             */\n            dbg(2, \"processing second pass of auto: server mode...\");\n            if (ip_hdr) {\n                add_cache(&options->cachedata, SEND,\n                    check_ip_tree(DIR_SERVER, ip_hdr->ip_src.s_addr));\n            } else {\n                add_cache(&options->cachedata, SEND,\n                    check_ip6_tree(DIR_SERVER, &ip6_hdr->ip_src));\n            }\n            break;\n\n        case CLIENT_MODE:\n            /* \n             * second run through in auto mode: create bridge\n             * where unknowns are clients\n             */\n            dbg(2, \"processing second pass of auto: client mode...\");\n            if (ip_hdr) {\n                add_cache(&options->cachedata, SEND,\n                    check_ip_tree(DIR_CLIENT, ip_hdr->ip_src.s_addr));\n            } else {\n                add_cache(&options->cachedata, SEND,\n                    check_ip6_tree(DIR_CLIENT, &ip6_hdr->ip_src));\n            }\n            break;\n\n        case PORT_MODE:\n            /*\n             * process ports based on their destination port\n             */\n            dbg(2, \"processing port mode...\");\n            add_cache(&options->cachedata, SEND,\n            \t\tcheck_dst_port(ip_hdr, ip6_hdr, (pkthdr.caplen - l2len)));\n            break;\n\n        case FIRST_MODE:\n            /*\n             * First packet mode, looks at each host and picks clients\n             * by the ones which send the first packet in a session\n             */\n            dbg(2, \"processing second pass of auto: first packet mode...\");\n            if (ip_hdr) {\n                add_cache(&options->cachedata, SEND,\n                    check_ip_tree(DIR_UNKNOWN, ip_hdr->ip_src.s_addr));\n            } else {\n                add_cache(&options->cachedata, SEND,\n                    check_ip6_tree(DIR_UNKNOWN, &ip6_hdr->ip_src));\n            }\n            break;\n            \n        default:\n            errx(-1, \"Whoops!  What mode are we in anyways? %d\", options->mode);\n        }\n#ifdef ENABLE_VERBOSE\n        if (options->verbose)\n            tcpdump_print(&tcpprep->tcpdump, &pkthdr, pktdata);\n#endif\n    }\n\n    return packetnum;\n}",
  "abstract_func": "static COUNTER\nprocess_raw_packets(pcap_t * VAR_0)\n{\n    ipv4_hdr_t *VAR_1 = NULL;\n    ipv6_hdr_t *VAR_2 = NULL;\n    eth_hdr_t *VAR_3 = NULL;\n    struct pcap_pkthdr VAR_4;\n    const u_char *VAR_5 = NULL;\n    COUNTER VAR_6 = 0;\n    int VAR_7;\n    u_char VAR_8[VAR_9], *VAR_10;\n    tcpr_dir_t VAR_11 = VAR_12;\n    tcpprep_opt_t *VAR_13 = VAR_14->options;\n\n    assert(VAR_0);\n    \n    while ((VAR_5 = safe_pcap_next(VAR_0, &VAR_4)) != NULL) {\n        VAR_6++;\n\n        dbgx(1, \"Packet \" VAR_15, VAR_6);\n\n        /* COMMENT_0 */\n        if (VAR_13->xX.list != NULL) {\n            if (VAR_13->xX.mode < VAR_16) {\n                /* COMMENT_1 */\n                if (!check_list(VAR_13->xX.list, VAR_6)) {\n                    add_cache(&(VAR_13->cachedata), VAR_17, 0);\n                    continue;\n                }\n            }\n            /* COMMENT_2 */\n            else if (check_list(VAR_13->xX.list, VAR_6)) {\n                add_cache(&(VAR_13->cachedata), VAR_17, 0);\n                continue;\n            }\n        }\n\n        /* COMMENT_3 */\n                                                                            \n                                                                         \n                                                        \n           \n        if (VAR_13->mode != VAR_18) {\n            dbg(3, \"Looking for IPv4/v6 header in non-MAC mode\");\n            \n            /* COMMENT_8 */\n            VAR_10 = VAR_8;\n    \n            /* COMMENT_9 */\n            if ((VAR_1 = (ipv4_hdr_t *)get_ipv4(VAR_5, VAR_4.caplen, \n                    pcap_datalink(VAR_0), &VAR_10))) {\n                dbg(2, \"Packet is IPv4\");\n            } else if ((VAR_2 = (ipv6_hdr_t *)get_ipv6(VAR_5, VAR_4.caplen,\n                    pcap_datalink(VAR_0), &VAR_10))) {\n                /* COMMENT_10 */\n                dbg(2, \"Packet is IPv6\");    \n            } else {\n                /* COMMENT_11 */\n                dbg(2, \"Packet isn't IPv4/v6\");\n\n                /* COMMENT_12 */\n                if (VAR_13->mode != VAR_19) {\n                    dbg(3, \"Adding to cache using options for Non-IP packets\");\n                    add_cache(&VAR_13->cachedata, VAR_20, VAR_13->nonip);\n                }\n\n                /* COMMENT_13 */\n                continue;\n            }\n    \n            VAR_7 = get_l2len(VAR_5, VAR_4.caplen, pcap_datalink(VAR_0));\n            if (VAR_7 < 0) {\n                /* COMMENT_13 */\n                continue;\n            }\n\n            /* COMMENT_14 */\n            if (VAR_13->xX.cidr != NULL) {\n                if (VAR_1) {\n                    if (!process_xX_by_cidr_ipv4(VAR_13->xX.mode, VAR_13->xX.cidr, VAR_1)) {\n                        add_cache(&VAR_13->cachedata, VAR_17, 0);\n                        continue;\n                    }\n                } else if (VAR_2) {\n                    if (!process_xX_by_cidr_ipv6(VAR_13->xX.mode, VAR_13->xX.cidr, VAR_2)) {\n                        add_cache(&VAR_13->cachedata, VAR_17, 0);\n                        continue;\n                    }\n                }\n            }\n        }\n\n        switch (VAR_13->mode) {\n        case VAR_21:\n            dbg(2, \"processing regex mode...\");\n            if (VAR_1) {\n                VAR_11 = check_ipv4_regex(VAR_1->ip_src.s_addr);\n            } else if (VAR_2) {\n                VAR_11 = check_ipv6_regex(&VAR_2->ip_src);\n            }\n\n            /* COMMENT_15 */\n            if (HAVE_OPT(VAR_22) && (VAR_11 == VAR_23 || VAR_11 == VAR_24))\n                VAR_11 = VAR_11 == VAR_23 ? VAR_24 : VAR_23;\n\n            add_cache(&VAR_13->cachedata, VAR_20, VAR_11);\n            break;\n\n        case VAR_25:\n            dbg(2, \"processing cidr mode...\");\n            if (VAR_1) {\n                VAR_11 = check_ip_cidr(VAR_13->cidrdata, VAR_1->ip_src.s_addr) ? VAR_23 : VAR_24;\n            } else if (VAR_2) {\n                VAR_11 = check_ip6_cidr(VAR_13->cidrdata, &VAR_2->ip_src) ? VAR_23 : VAR_24;\n            }\n\n            /* COMMENT_15 */\n            if (HAVE_OPT(VAR_22) && (VAR_11 == VAR_23 || VAR_11 == VAR_24))\n                VAR_11 = VAR_11 == VAR_23 ? VAR_24 : VAR_23;\n\n            add_cache(&VAR_13->cachedata, VAR_20, VAR_11);\n            break;\n\n        case VAR_18:\n            dbg(2, \"processing mac mode...\");\n            if (VAR_4.caplen < sizeof(*VAR_3)) {\n                dbg(2, \"capture length too short for mac mode processing\");\n                break;\n            }\n\n            VAR_3 = (eth_hdr_t *)VAR_5;\n            VAR_11 = macinstring(VAR_13->maclist, (u_char *)VAR_3->ether_shost);\n\n            /* COMMENT_15 */\n            if (HAVE_OPT(VAR_22) && (VAR_11 == VAR_23 || VAR_11 == VAR_24))\n                VAR_11 = VAR_11 == VAR_23 ? VAR_24 : VAR_23;\n\n            add_cache(&VAR_13->cachedata, VAR_20, VAR_11);\n            break;\n\n        case VAR_19:\n            dbg(2, \"processing first pass of auto mode...\");\n            /* COMMENT_16 */\n            if (VAR_13->automode != VAR_26) {\n                if (VAR_1) {\n                    add_tree_ipv4(VAR_1->ip_src.s_addr, VAR_5, VAR_4.caplen);\n                } else if (VAR_2) {\n                    add_tree_ipv6(&VAR_2->ip_src, VAR_5, VAR_4.caplen);\n                }\n            } else {\n                if (VAR_1) {\n                    add_tree_first_ipv4(VAR_5, VAR_4.caplen);\n                } else if (VAR_2) {\n                    add_tree_first_ipv6(VAR_5, VAR_4.caplen);\n                }\n            }  \n            break;\n\n        case VAR_27:\n            /* COMMENT_17 */\n                                                            \n                          \n               \n            dbg(2, \"processing second pass of auto: router mode...\");\n            if (VAR_1) {\n                add_cache(&VAR_13->cachedata, VAR_20,\n                    check_ip_tree(VAR_13->nonip, VAR_1->ip_src.s_addr));\n            } else {\n                add_cache(&VAR_13->cachedata, VAR_20,\n                    check_ip6_tree(VAR_13->nonip, &VAR_2->ip_src));\n            }\n            break;\n\n        case VAR_28:\n            /* COMMENT_21 */\n                                                             \n                          \n               \n            dbg(2, \"processing second pass of auto: bridge mode...\");\n            if (VAR_1) {\n                add_cache(&VAR_13->cachedata, VAR_20,\n                    check_ip_tree(VAR_29, VAR_1->ip_src.s_addr));\n            } else {\n                add_cache(&VAR_13->cachedata, VAR_20,\n                    check_ip6_tree(VAR_29, &VAR_2->ip_src));\n            }\n            break;\n\n        case VAR_30:\n            /* COMMENT_25 */\n                                                             \n                                         \n               \n            dbg(2, \"processing second pass of auto: server mode...\");\n            if (VAR_1) {\n                add_cache(&VAR_13->cachedata, VAR_20,\n                    check_ip_tree(VAR_31, VAR_1->ip_src.s_addr));\n            } else {\n                add_cache(&VAR_13->cachedata, VAR_20,\n                    check_ip6_tree(VAR_31, &VAR_2->ip_src));\n            }\n            break;\n\n        case VAR_32:\n            /* COMMENT_29 */\n                                                             \n                                         \n               \n            dbg(2, \"processing second pass of auto: client mode...\");\n            if (VAR_1) {\n                add_cache(&VAR_13->cachedata, VAR_20,\n                    check_ip_tree(VAR_33, VAR_1->ip_src.s_addr));\n            } else {\n                add_cache(&VAR_13->cachedata, VAR_20,\n                    check_ip6_tree(VAR_33, &VAR_2->ip_src));\n            }\n            break;\n\n        case VAR_34:\n            /* COMMENT_33 */\n                                                            \n               \n            dbg(2, \"processing port mode...\");\n            add_cache(&VAR_13->cachedata, VAR_20,\n            \t\tcheck_dst_port(VAR_1, VAR_2, (VAR_4.caplen - VAR_7)));\n            break;\n\n        case VAR_26:\n            /* COMMENT_36 */\n                                                                      \n                                                                   \n               \n            dbg(2, \"processing second pass of auto: first packet mode...\");\n            if (VAR_1) {\n                add_cache(&VAR_13->cachedata, VAR_20,\n                    check_ip_tree(VAR_29, VAR_1->ip_src.s_addr));\n            } else {\n                add_cache(&VAR_13->cachedata, VAR_20,\n                    check_ip6_tree(VAR_29, &VAR_2->ip_src));\n            }\n            break;\n            \n        default:\n            errx(-1, \"Whoops!  What mode are we in anyways? %d\", VAR_13->mode);\n        }\n#ifdef VAR_35\n        if (VAR_13->verbose)\n            tcpdump_print(&VAR_14->tcpdump, &VAR_4, VAR_5);\n#endif\n    }\n\n    return VAR_6;\n}",
  "func_graph_path": "appneta/tcpreplay/68f67b1a3a4d319543692afb5bd5b191ec984287/tcpprep.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -14,7 +14,7 @@\n \n     assert(pcap);\n     \n-    while ((pktdata = pcap_next(pcap, &pkthdr)) != NULL) {\n+    while ((pktdata = safe_pcap_next(pcap, &pkthdr)) != NULL) {\n         packetnum++;\n \n         dbgx(1, \"Packet \" COUNTER_SPEC, packetnum);",
  "diff_line_info": {
    "deleted_lines": [
      "    while ((pktdata = pcap_next(pcap, &pkthdr)) != NULL) {"
    ],
    "added_lines": [
      "    while ((pktdata = safe_pcap_next(pcap, &pkthdr)) != NULL) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/appneta/tcpreplay/pull/491",
  "description": {
    "pr_info": {
      "title": "Bug #484 CVE-2018-17582 Check for corrupt PCAP files",
      "number": 491
    },
    "comment": [
      "* Check for packets that are larger than 262144 bytes\r\n* Check for capture lengths that are greater than packet length\r\n\r\nExample of a corrupt PCAP file ...\r\n\r\nsudo src/tcpreplay -i ens33 --unique-ip -t --loop 4 get_next_paket_01\r\nsafe_pcap_next ERROR: Invalid packet length in send_packets.c:get_next_packet() line 1054: 8388670 is greater than maximum 262144"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}