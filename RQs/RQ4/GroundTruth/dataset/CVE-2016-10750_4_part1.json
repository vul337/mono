{
  "cve_id": "CVE-2016-10750",
  "cwe_ids": [
    "CWE-502"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "hazelcast",
  "commit_msg": "Add basic protection against untrusted deserialization.",
  "commit_hash": "c1c31359a1df953e79a9ca9b6c54b3cdbfef11e9",
  "git_url": "https://github.com/hazelcast/hazelcast/commit/c1c31359a1df953e79a9ca9b6c54b3cdbfef11e9",
  "file_path": "hazelcast/src/main/java/com/hazelcast/config/AbstractXmlConfigHelper.java",
  "func_name": "parseSerialization",
  "func_before": "protected SerializationConfig parseSerialization(final Node node) {\n        SerializationConfig serializationConfig = new SerializationConfig();\n        for (Node child : childElements(node)) {\n            final String name = cleanNodeName(child);\n            if (\"portable-version\".equals(name)) {\n                String value = getTextContent(child);\n                serializationConfig.setPortableVersion(getIntegerValue(name, value));\n            } else if (\"check-class-def-errors\".equals(name)) {\n                String value = getTextContent(child);\n                serializationConfig.setCheckClassDefErrors(getBooleanValue(value));\n            } else if (\"use-native-byte-order\".equals(name)) {\n                serializationConfig.setUseNativeByteOrder(getBooleanValue(getTextContent(child)));\n            } else if (\"byte-order\".equals(name)) {\n                String value = getTextContent(child);\n                ByteOrder byteOrder = null;\n                if (ByteOrder.BIG_ENDIAN.toString().equals(value)) {\n                    byteOrder = ByteOrder.BIG_ENDIAN;\n                } else if (ByteOrder.LITTLE_ENDIAN.toString().equals(value)) {\n                    byteOrder = ByteOrder.LITTLE_ENDIAN;\n                }\n                serializationConfig.setByteOrder(byteOrder != null ? byteOrder : ByteOrder.BIG_ENDIAN);\n            } else if (\"enable-compression\".equals(name)) {\n                serializationConfig.setEnableCompression(getBooleanValue(getTextContent(child)));\n            } else if (\"enable-shared-object\".equals(name)) {\n                serializationConfig.setEnableSharedObject(getBooleanValue(getTextContent(child)));\n            } else if (\"allow-unsafe\".equals(name)) {\n                serializationConfig.setAllowUnsafe(getBooleanValue(getTextContent(child)));\n            } else if (\"data-serializable-factories\".equals(name)) {\n                fillDataSerializableFactories(child, serializationConfig);\n            } else if (\"portable-factories\".equals(name)) {\n                fillPortableFactories(child, serializationConfig);\n            } else if (\"serializers\".equals(name)) {\n                fillSerializers(child, serializationConfig);\n            }\n        }\n        return serializationConfig;\n    }",
  "abstract_func_before": "protected SerializationConfig parseSerialization(final Node VAR_0) {\n        SerializationConfig VAR_1 = new SerializationConfig();\n        for (Node VAR_2 : childElements(VAR_0)) {\n            final String VAR_3 = cleanNodeName(VAR_2);\n            if (\"portable-version\".equals(VAR_3)) {\n                String VAR_4 = getTextContent(VAR_2);\n                VAR_1.setPortableVersion(getIntegerValue(VAR_3, VAR_4));\n            } else if (\"check-class-def-errors\".equals(VAR_3)) {\n                String VAR_4 = getTextContent(VAR_2);\n                VAR_1.setCheckClassDefErrors(getBooleanValue(VAR_4));\n            } else if (\"use-native-byte-order\".equals(VAR_3)) {\n                VAR_1.setUseNativeByteOrder(getBooleanValue(getTextContent(VAR_2)));\n            } else if (\"byte-order\".equals(VAR_3)) {\n                String VAR_4 = getTextContent(VAR_2);\n                ByteOrder VAR_5 = null;\n                if (VAR_6.BIG_ENDIAN.toString().equals(VAR_4)) {\n                    VAR_5 = VAR_6.BIG_ENDIAN;\n                } else if (VAR_6.LITTLE_ENDIAN.toString().equals(VAR_4)) {\n                    VAR_5 = VAR_6.LITTLE_ENDIAN;\n                }\n                VAR_1.setByteOrder(VAR_5 != null ? VAR_5 : VAR_6.BIG_ENDIAN);\n            } else if (\"enable-compression\".equals(VAR_3)) {\n                VAR_1.setEnableCompression(getBooleanValue(getTextContent(VAR_2)));\n            } else if (\"enable-shared-object\".equals(VAR_3)) {\n                VAR_1.setEnableSharedObject(getBooleanValue(getTextContent(VAR_2)));\n            } else if (\"allow-unsafe\".equals(VAR_3)) {\n                VAR_1.setAllowUnsafe(getBooleanValue(getTextContent(VAR_2)));\n            } else if (\"data-serializable-factories\".equals(VAR_3)) {\n                fillDataSerializableFactories(VAR_2, VAR_1);\n            } else if (\"portable-factories\".equals(VAR_3)) {\n                fillPortableFactories(VAR_2, VAR_1);\n            } else if (\"serializers\".equals(VAR_3)) {\n                fillSerializers(VAR_2, VAR_1);\n            }\n        }\n        return VAR_1;\n    }",
  "func_graph_path_before": "hazelcast/c1c31359a1df953e79a9ca9b6c54b3cdbfef11e9/AbstractXmlConfigHelper.java/vul/before/0.json",
  "func": "protected SerializationConfig parseSerialization(final Node node) {\n        SerializationConfig serializationConfig = new SerializationConfig();\n        for (Node child : childElements(node)) {\n            final String name = cleanNodeName(child);\n            if (\"portable-version\".equals(name)) {\n                String value = getTextContent(child);\n                serializationConfig.setPortableVersion(getIntegerValue(name, value));\n            } else if (\"check-class-def-errors\".equals(name)) {\n                String value = getTextContent(child);\n                serializationConfig.setCheckClassDefErrors(getBooleanValue(value));\n            } else if (\"use-native-byte-order\".equals(name)) {\n                serializationConfig.setUseNativeByteOrder(getBooleanValue(getTextContent(child)));\n            } else if (\"byte-order\".equals(name)) {\n                String value = getTextContent(child);\n                ByteOrder byteOrder = null;\n                if (ByteOrder.BIG_ENDIAN.toString().equals(value)) {\n                    byteOrder = ByteOrder.BIG_ENDIAN;\n                } else if (ByteOrder.LITTLE_ENDIAN.toString().equals(value)) {\n                    byteOrder = ByteOrder.LITTLE_ENDIAN;\n                }\n                serializationConfig.setByteOrder(byteOrder != null ? byteOrder : ByteOrder.BIG_ENDIAN);\n            } else if (\"enable-compression\".equals(name)) {\n                serializationConfig.setEnableCompression(getBooleanValue(getTextContent(child)));\n            } else if (\"enable-shared-object\".equals(name)) {\n                serializationConfig.setEnableSharedObject(getBooleanValue(getTextContent(child)));\n            } else if (\"allow-unsafe\".equals(name)) {\n                serializationConfig.setAllowUnsafe(getBooleanValue(getTextContent(child)));\n            } else if (\"data-serializable-factories\".equals(name)) {\n                fillDataSerializableFactories(child, serializationConfig);\n            } else if (\"portable-factories\".equals(name)) {\n                fillPortableFactories(child, serializationConfig);\n            } else if (\"serializers\".equals(name)) {\n                fillSerializers(child, serializationConfig);\n            } else if (\"java-serialization-filter\".equals(name)) {\n                fillJavaSerializationFilter(child, serializationConfig);\n            }\n        }\n        return serializationConfig;\n    }",
  "abstract_func": "protected SerializationConfig parseSerialization(final Node VAR_0) {\n        SerializationConfig VAR_1 = new SerializationConfig();\n        for (Node VAR_2 : childElements(VAR_0)) {\n            final String VAR_3 = cleanNodeName(VAR_2);\n            if (\"portable-version\".equals(VAR_3)) {\n                String VAR_4 = getTextContent(VAR_2);\n                VAR_1.setPortableVersion(getIntegerValue(VAR_3, VAR_4));\n            } else if (\"check-class-def-errors\".equals(VAR_3)) {\n                String VAR_4 = getTextContent(VAR_2);\n                VAR_1.setCheckClassDefErrors(getBooleanValue(VAR_4));\n            } else if (\"use-native-byte-order\".equals(VAR_3)) {\n                VAR_1.setUseNativeByteOrder(getBooleanValue(getTextContent(VAR_2)));\n            } else if (\"byte-order\".equals(VAR_3)) {\n                String VAR_4 = getTextContent(VAR_2);\n                ByteOrder VAR_5 = null;\n                if (VAR_6.BIG_ENDIAN.toString().equals(VAR_4)) {\n                    VAR_5 = VAR_6.BIG_ENDIAN;\n                } else if (VAR_6.LITTLE_ENDIAN.toString().equals(VAR_4)) {\n                    VAR_5 = VAR_6.LITTLE_ENDIAN;\n                }\n                VAR_1.setByteOrder(VAR_5 != null ? VAR_5 : VAR_6.BIG_ENDIAN);\n            } else if (\"enable-compression\".equals(VAR_3)) {\n                VAR_1.setEnableCompression(getBooleanValue(getTextContent(VAR_2)));\n            } else if (\"enable-shared-object\".equals(VAR_3)) {\n                VAR_1.setEnableSharedObject(getBooleanValue(getTextContent(VAR_2)));\n            } else if (\"allow-unsafe\".equals(VAR_3)) {\n                VAR_1.setAllowUnsafe(getBooleanValue(getTextContent(VAR_2)));\n            } else if (\"data-serializable-factories\".equals(VAR_3)) {\n                fillDataSerializableFactories(VAR_2, VAR_1);\n            } else if (\"portable-factories\".equals(VAR_3)) {\n                fillPortableFactories(VAR_2, VAR_1);\n            } else if (\"serializers\".equals(VAR_3)) {\n                fillSerializers(VAR_2, VAR_1);\n            } else if (\"java-serialization-filter\".equals(VAR_3)) {\n                fillJavaSerializationFilter(VAR_2, VAR_1);\n            }\n        }\n        return VAR_1;\n    }",
  "func_graph_path": "hazelcast/c1c31359a1df953e79a9ca9b6c54b3cdbfef11e9/AbstractXmlConfigHelper.java/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -31,6 +31,8 @@\n                 fillPortableFactories(child, serializationConfig);\n             } else if (\"serializers\".equals(name)) {\n                 fillSerializers(child, serializationConfig);\n+            } else if (\"java-serialization-filter\".equals(name)) {\n+                fillJavaSerializationFilter(child, serializationConfig);\n             }\n         }\n         return serializationConfig;",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "            } else if (\"java-serialization-filter\".equals(name)) {",
      "                fillJavaSerializationFilter(child, serializationConfig);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/hazelcast/hazelcast/pull/12230",
  "description": {
    "pr_info": {
      "title": "Add basic protection against untrusted deserialization by introducing blacklisting/whitelisting capabilities",
      "number": 12230
    },
    "comment": [
      "### Untrusted deserialization protection for Hazelcast\r\n\r\nThis pull request introduces java deserialization protection based on class names blacklisting and whitelisting.\r\n\r\nThe new feature is controlled by a new section in Hazelcast serialization configuration. The feature is not enabled by default, you can enable it by adding `<java-serialization-filter/>` element into `<serialization/>` configuration section.\r\n\r\n**Example:**\r\n```xml\r\n<hazelcast>\r\n    <serialization>\r\n        <java-serialization-filter>\r\n            <whitelist>\r\n                <class>java.lang.String</class>\r\n                <class>example.Foo</class>\r\n                <package>com.acme.app</package>\r\n                <package>com.acme.app.subpkg</package>\r\n            </whitelist>\r\n            <blacklist>\r\n                <class>com.acme.app.BeanComparator</class>\r\n            </blacklist>\r\n        </java-serialization-filter>\r\n    </serialization>\r\n</hazelcast>\r\n```\r\n\r\nOnce the feature is enabled, following filtering rules are used when objects are deserialized.\r\n\r\n**Filtering rules**\r\n* When whitelist is not provided:\r\n  1. if the deserialized object's getClass().getName() is blacklisted or getClass().getPackage().getName() is blacklisted, then deserialization fails;\r\n  1. deserialization is allowed otherwise.\r\n* When whitelist is provided:\r\n  1. if the deserialized object's getClass().getName() is blacklisted or getClass().getPackage().getName() is blacklisted, then deserialization fails;\r\n  1. if the deserialized object's getClass().getName() is whitelisted or getClass().getPackage().getName() is whitelisted, then deserialization is allowed;\r\n  1. deserialization fails otherwise.\r\n\r\nFailed deserialization means a `SecurityException` is thrown.\r\n\r\nWhen the blacklist is not explicitly provided, a default hardcoded value with some well known vulnerable class names is used.\r\n\r\nThe safest way to protect against untrusted deserialization is to use whitelisting, nevertheless it's also hard to maintain such a whitelist.\r\n",
      "@Donnerbart, Thanks for the comments, I'll work on them.\r\n\r\nI'll rework the configuration to avoid using properties.\r\n\r\nUnill the changes are in place, I'm flagging this PR with a \"Don't merge\" prefix.",
      "@drosenbauer Thanks for comments.\r\n\r\nCurrent plan is to have following configuration:\r\n```xml\r\n<hazelcast>\r\n    <serialization>\r\n        <java-serialization-filter>\r\n            <whitelist>\r\n                <class>java.lang.String</class>\r\n                <class>example.Foo</class>\r\n                <package>com.acme.app</package>\r\n                <package>com.acme.app.subpkg</package>\r\n            </whitelist>\r\n            <blacklist>\r\n                <class>com.acme.app.BeanComparator</class>\r\n            </blacklist>\r\n        </java-serialization-filter>\r\n    </serialization>\r\n</hazelcast>\r\n```\r\n\r\nThe exception, which will be thrown by look-ahead ObjectInputStream is `java.lang.SecurityException`. The deserializer will wrap it into `HazelcastSerializationException`.\r\n\r\n**Filtering rules**\r\n* When whitelist is not provided:\r\n  1. if the deserialized object's getClass().getName() is blacklisted or getClass().getPackage().getName() is blacklisted, then deserialization fails;\r\n  1. deserialization is allowed otherwise.\r\n* When whitelist is provided:\r\n  1. if the deserialized object's getClass().getName() is blacklisted or getClass().getPackage().getName() is blacklisted, then deserialization fails;\r\n  1. if the deserialized object's getClass().getName() is whitelisted or getClass().getPackage().getName() is whitelisted, then deserialization is allowed;\r\n  1. deserialization fails otherwise.",
      "There is quite a lot of 'repetition'\r\n\r\nSerializationClassNameFilter\r\nClassFilterList\r\nShadeOfGreyList\r\n\r\nThey all contain the same thing.. list of packages and list of classes.",
      "This task has been moved to the 3.11 release. So I'm going to update the milestone.",
      "I've updated the PR. The comments were mostly addressed.\r\n\r\nThe feature is not enabled by default now. The default blacklist is used after adding the `<java-serialization-filter/>` element. \r\n\r\nI don't think the package name extraction from a class name is a litter, I like it more than adding classnames without limit to the classname `Set`, or using an overkill like a cache with a proper eviction mechanism. As the feature is not enabled by default, I think we are safe here now from the performance PoV. Do you agree @pveentjer?",
      "# [Codecov](https://codecov.io/gh/hazelcast/hazelcast/pull/12230?src=pr&el=h1) Report\n> Merging [#12230](https://codecov.io/gh/hazelcast/hazelcast/pull/12230?src=pr&el=desc) into [master](https://codecov.io/gh/hazelcast/hazelcast/commit/56f63a9b3ae20488ef6e2c57dc47ed2be2b53253?src=pr&el=desc) will **increase** coverage by `0.2%`.\n> The diff coverage is `80.4%`.\n\n[![Impacted file tree graph](https://codecov.io/gh/hazelcast/hazelcast/pull/12230/graphs/tree.svg?token=8zC1zaT3xz&height=150&src=pr&width=650)](https://codecov.io/gh/hazelcast/hazelcast/pull/12230?src=pr&el=tree)\n\n```diff\n@@             Coverage Diff             @@\n##             master   #12230     +/-   ##\n===========================================\n+ Coverage     76.22%   76.43%   +0.2%     \n- Complexity    34722    34868    +146     \n===========================================\n  Files          3032     3035      +3     \n  Lines        129595   129819    +224     \n  Branches      15168    15203     +35     \n===========================================\n+ Hits          98785    99227    +442     \n+ Misses        25073    24913    -160     \n+ Partials       5737     5679     -58\n```\n\n\n| [Impacted Files](https://codecov.io/gh/hazelcast/hazelcast/pull/12230?src=pr&el=tree) | Coverage Δ | Complexity Δ | |\n|---|---|---|---|\n| [...rialization/impl/AbstractSerializationService.java](https://codecov.io/gh/hazelcast/hazelcast/pull/12230/diff?src=pr&el=tree#diff-aGF6ZWxjYXN0L3NyYy9tYWluL2phdmEvY29tL2hhemVsY2FzdC9pbnRlcm5hbC9zZXJpYWxpemF0aW9uL2ltcGwvQWJzdHJhY3RTZXJpYWxpemF0aW9uU2VydmljZS5qYXZh) | `87.59% <100%> (+0.58%)` | `86 <0> (-1)` | :arrow_down: |\n| [...om/hazelcast/nio/SerializationClassNameFilter.java](https://codecov.io/gh/hazelcast/hazelcast/pull/12230/diff?src=pr&el=tree#diff-aGF6ZWxjYXN0L3NyYy9tYWluL2phdmEvY29tL2hhemVsY2FzdC9uaW8vU2VyaWFsaXphdGlvbkNsYXNzTmFtZUZpbHRlci5qYXZh) | `100% <100%> (ø)` | `5 <5> (?)` | |\n| [...ation/impl/DefaultSerializationServiceBuilder.java](https://codecov.io/gh/hazelcast/hazelcast/pull/12230/diff?src=pr&el=tree#diff-aGF6ZWxjYXN0L3NyYy9tYWluL2phdmEvY29tL2hhemVsY2FzdC9pbnRlcm5hbC9zZXJpYWxpemF0aW9uL2ltcGwvRGVmYXVsdFNlcmlhbGl6YXRpb25TZXJ2aWNlQnVpbGRlci5qYXZh) | `81.86% <100%> (+1.64%)` | `56 <0> (+1)` | :arrow_up: |\n| [...nal/serialization/impl/JavaDefaultSerializers.java](https://codecov.io/gh/hazelcast/hazelcast/pull/12230/diff?src=pr&el=tree#diff-aGF6ZWxjYXN0L3NyYy9tYWluL2phdmEvY29tL2hhemVsY2FzdC9pbnRlcm5hbC9zZXJpYWxpemF0aW9uL2ltcGwvSmF2YURlZmF1bHRTZXJpYWxpemVycy5qYXZh) | `86.33% <100%> (+0.19%)` | `1 <0> (ø)` | :arrow_down: |\n| [...java/com/hazelcast/config/SerializationConfig.java](https://codecov.io/gh/hazelcast/hazelcast/pull/12230/diff?src=pr&el=tree#diff-aGF6ZWxjYXN0L3NyYy9tYWluL2phdmEvY29tL2hhemVsY2FzdC9jb25maWcvU2VyaWFsaXphdGlvbkNvbmZpZy5qYXZh) | `89.02% <100%> (+0.41%)` | `43 <2> (+2)` | :arrow_up: |\n| [...rc/main/java/com/hazelcast/config/ClassFilter.java](https://codecov.io/gh/hazelcast/hazelcast/pull/12230/diff?src=pr&el=tree#diff-aGF6ZWxjYXN0L3NyYy9tYWluL2phdmEvY29tL2hhemVsY2FzdC9jb25maWcvQ2xhc3NGaWx0ZXIuamF2YQ==) | `52.83% <52.83%> (ø)` | `17 <17> (?)` | |\n| [...azelcast/config/JavaSerializationFilterConfig.java](https://codecov.io/gh/hazelcast/hazelcast/pull/12230/diff?src=pr&el=tree#diff-aGF6ZWxjYXN0L3NyYy9tYWluL2phdmEvY29tL2hhemVsY2FzdC9jb25maWcvSmF2YVNlcmlhbGl6YXRpb25GaWx0ZXJDb25maWcuamF2YQ==) | `53.84% <53.84%> (ø)` | `8 <8> (?)` | |\n| [...elcast/src/main/java/com/hazelcast/nio/IOUtil.java](https://codecov.io/gh/hazelcast/hazelcast/pull/12230/diff?src=pr&el=tree#diff-aGF6ZWxjYXN0L3NyYy9tYWluL2phdmEvY29tL2hhemVsY2FzdC9uaW8vSU9VdGlsLmphdmE=) | `73.12% <66.66%> (-0.32%)` | `78 <1> (ø)` | |\n| [.../com/hazelcast/config/AbstractXmlConfigHelper.java](https://codecov.io/gh/hazelcast/hazelcast/pull/12230/diff?src=pr&el=tree#diff-aGF6ZWxjYXN0L3NyYy9tYWluL2phdmEvY29tL2hhemVsY2FzdC9jb25maWcvQWJzdHJhY3RYbWxDb25maWdIZWxwZXIuamF2YQ==) | `70.41% <86.95%> (+1.66%)` | `71 <6> (+7)` | :arrow_up: |\n| [.../spring/AbstractHazelcastBeanDefinitionParser.java](https://codecov.io/gh/hazelcast/hazelcast/pull/12230/diff?src=pr&el=tree#diff-aGF6ZWxjYXN0LXNwcmluZy9zcmMvbWFpbi9qYXZhL2NvbS9oYXplbGNhc3Qvc3ByaW5nL0Fic3RyYWN0SGF6ZWxjYXN0QmVhbkRlZmluaXRpb25QYXJzZXIuamF2YQ==) | `86.82% <88.46%> (+0.46%)` | `1 <0> (ø)` | :arrow_down: |\n| ... and [119 more](https://codecov.io/gh/hazelcast/hazelcast/pull/12230/diff?src=pr&el=tree-more) | |\n",
      "Thanks @pveentjer for review and pushing for the solution with better performance!\r\n\r\nI'm going to squash the commits."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}