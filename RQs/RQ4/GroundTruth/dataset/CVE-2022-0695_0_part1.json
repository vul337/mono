{
  "cve_id": "CVE-2022-0695",
  "cwe_ids": [
    "CWE-400"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "radareorg/radare2",
  "commit_msg": "Fix DoS in PE/QNX/DYLDCACHE/PSX parsers ##crash\n\n* Reported by lazymio\n* Reproducer: AAA4AAAAAB4=",
  "commit_hash": "634b886e84a5c568d243e744becc6b3223e089cf",
  "git_url": "https://github.com/radareorg/radare2/commit/634b886e84a5c568d243e744becc6b3223e089cf",
  "file_path": "libr/bin/format/pe/pe.c",
  "func_name": "bin_pe_parse_imports",
  "func_before": "static int bin_pe_parse_imports(RBinPEObj* pe,\n                                struct r_bin_pe_import_t** importp, int* nimp,\n                                const char* dll_name,\n                                PE_DWord OriginalFirstThunk,\n                                PE_DWord FirstThunk) {\n\tchar import_name[PE_NAME_LENGTH + 1];\n\tchar name[PE_NAME_LENGTH + 1];\n\tPE_Word import_hint, import_ordinal = 0;\n\tPE_DWord import_table = 0, off = 0;\n\tint i = 0, len;\n\tSdb* db = NULL;\n\tchar* sdb_module = NULL;\n\tchar* symname = NULL;\n\tchar* symdllname = NULL;\n\n\tif (!dll_name || !*dll_name || *dll_name == '0') {\n\t\treturn 0;\n\t}\n\n\tif (!(off = PE_(va2pa) (pe, OriginalFirstThunk)) &&\n\t!(off = PE_(va2pa) (pe, FirstThunk))) {\n\t\treturn 0;\n\t}\n\tdo {\n\t\tif (import_ordinal >= UT16_MAX) {\n\t\t\tbreak;\n\t\t}\n\t\tif (off + i * sizeof (PE_DWord) > pe->size) {\n\t\t\tbreak;\n\t\t}\n\t\timport_table = R_BUF_READ_PE_DWORD_AT (pe->b, off + i * sizeof (PE_DWord));\n\t\tif (import_table == PE_DWORD_MAX) {\n\t\t\tpe_printf (\"Warning: read (import table)\\n\");\n\t\t\tgoto error;\n\t\t} else if (import_table) {\n\t\t\tif (import_table & ILT_MASK1) {\n\t\t\t\timport_ordinal = import_table & ILT_MASK2;\n\t\t\t\timport_hint = 0;\n\t\t\t\tsnprintf (import_name, PE_NAME_LENGTH, \"Ordinal_%i\", import_ordinal);\n\t\t\t\tfree (symdllname);\n\t\t\t\tstrncpy (name, dll_name, sizeof (name) - 1);\n\t\t\t\tname[sizeof (name) - 1] = 0;\n\t\t\t\tsymdllname = strdup (name);\n\n\t\t\t\t// remove the trailling \".dll\"\n\t\t\t\tsize_t len = strlen (symdllname);\n\t\t\t\tr_str_case (symdllname, 0);\n\t\t\t\tlen = len < 4? 0: len - 4;\n\t\t\t\tsymdllname[len] = 0;\n\n\t\t\t\tchar* filename = NULL;\n\t\t\t\tif (!sdb_module || strcmp (symdllname, sdb_module)) {\n\t\t\t\t\tsdb_free (db);\n\t\t\t\t\tdb = NULL;\n\t\t\t\t\tfree (sdb_module);\n\t\t\t\t\tsdb_module = strdup (symdllname);\n\t\t\t\t\tfilename = r_str_newf (\"%s.sdb\", symdllname);\n\t\t\t\t\tif (filename && r_file_exists (filename)) {\n\t\t\t\t\t\tdb = sdb_new (NULL, filename, 0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst char *dirPrefix = r_sys_prefix (NULL);\n\t\t\t\t\t\tchar *lower_symdllname = strdup (symdllname);\n\t\t\t\t\t\tr_str_case (lower_symdllname, false);\n\t\t\t\t\t\tfilename = r_str_newf (R_JOIN_4_PATHS (\"%s\", R2_SDB_FORMAT, \"dll\", \"%s.sdb\"),\n\t\t\t\t\t\t\tdirPrefix, lower_symdllname);\n\t\t\t\t\t\tfree (lower_symdllname);\n\t\t\t\t\t\tif (r_file_exists (filename)) {\n\t\t\t\t\t\t\tdb = sdb_new (NULL, filename, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (db) {\n\t\t\t\t\tsymname = resolveModuleOrdinal (db, symdllname, import_ordinal);\n\t\t\t\t\tif (symname) {\n\t\t\t\t\t\tsnprintf (import_name, PE_NAME_LENGTH, \"%s\", symname);\n\t\t\t\t\t\tR_FREE (symname);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpe_printf (\"Cannot find %s\\n\", filename);\n\t\t\t\t}\n\t\t\t\tfree (filename);\n\t\t\t} else {\n\t\t\t\timport_ordinal++;\n\t\t\t\tconst ut64 off = PE_(va2pa) (pe, import_table);\n\t\t\t\tif (off > pe->size || (off + sizeof (PE_Word)) > pe->size) {\n\t\t\t\t\tpe_printf (\"Warning: off > pe->size\\n\");\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\timport_hint = r_buf_read_le16_at (pe->b, off);\n\t\t\t\tif (import_hint == UT16_MAX) {\n\t\t\t\t\tpe_printf (\"Warning: read import hint at 0x%08\"PFMT64x \"\\n\", off);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tname[0] = '\\0';\n\t\t\t\tlen = r_buf_read_at (pe->b, off + sizeof (PE_Word), (ut8*) name, PE_NAME_LENGTH);\n\t\t\t\tif (len < 1) {\n\t\t\t\t\tpe_printf (\"Warning: read (import name)\\n\");\n\t\t\t\t\tgoto error;\n\t\t\t\t} else if (!*name) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tname[PE_NAME_LENGTH] = '\\0';\n\t\t\t\tint len = snprintf (import_name, sizeof (import_name), \"%s\" , name);\n\t\t\t\tif (len >= sizeof (import_name)) {\n\t\t\t\t\teprintf (\"Import name '%s' has been truncated.\\n\", import_name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tstruct r_bin_pe_import_t *new_importp = realloc (*importp, (*nimp + 1) * sizeof (struct r_bin_pe_import_t));\n\t\t\tif (!new_importp) {\n\t\t\t\tr_sys_perror (\"realloc (import)\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\t*importp = new_importp;\n\t\t\tmemcpy ((*importp)[*nimp].name, import_name, PE_NAME_LENGTH);\n\t\t\t(*importp)[*nimp].name[PE_NAME_LENGTH] = '\\0';\n\t\t\tmemcpy ((*importp)[*nimp].libname, dll_name, PE_NAME_LENGTH);\n\t\t\t(*importp)[*nimp].libname[PE_NAME_LENGTH] = '\\0';\n\t\t\t(*importp)[*nimp].vaddr = bin_pe_rva_to_va (pe, FirstThunk + i * sizeof (PE_DWord));\n\t\t\t(*importp)[*nimp].paddr = PE_(va2pa) (pe, FirstThunk) + i * sizeof (PE_DWord);\n\t\t\t(*importp)[*nimp].hint = import_hint;\n\t\t\t(*importp)[*nimp].ordinal = import_ordinal;\n\t\t\t(*importp)[*nimp].last = 0;\n\t\t\t(*nimp)++;\n\t\t\ti++;\n\t\t}\n\t} while (import_table);\n\n\tif (db) {\n\t\tsdb_free (db);\n\t\tdb = NULL;\n\t}\n\tfree (symdllname);\n\tfree (sdb_module);\n\treturn i;\n\nerror:\n\tif (db) {\n\t\tsdb_free (db);\n\t\tdb = NULL;\n\t}\n\tfree (symdllname);\n\tfree (sdb_module);\n\treturn false;\n}",
  "abstract_func_before": "static int bin_pe_parse_imports(RBinPEObj* VAR_0,\n                                struct r_bin_pe_import_t** VAR_1, int* VAR_2,\n                                const char* VAR_3,\n                                PE_DWord VAR_4,\n                                PE_DWord VAR_5) {\n\tchar VAR_6[VAR_7 + 1];\n\tchar VAR_8[VAR_7 + 1];\n\tPE_Word VAR_9, VAR_10 = 0;\n\tPE_DWord VAR_11 = 0, VAR_12 = 0;\n\tint VAR_13 = 0, VAR_14;\n\tSdb* VAR_15 = NULL;\n\tchar* VAR_16 = NULL;\n\tchar* VAR_17 = NULL;\n\tchar* VAR_18 = NULL;\n\n\tif (!VAR_3 || !*VAR_3 || *VAR_3 == '0') {\n\t\treturn 0;\n\t}\n\n\tif (!(VAR_12 = PE_(VAR_19) (VAR_0, VAR_4)) &&\n\t!(VAR_12 = PE_(VAR_19) (VAR_0, VAR_5))) {\n\t\treturn 0;\n\t}\n\tdo {\n\t\tif (VAR_10 >= VAR_20) {\n\t\t\tbreak;\n\t\t}\n\t\tif (VAR_12 + VAR_13 * sizeof (PE_DWord) > VAR_0->size) {\n\t\t\tbreak;\n\t\t}\n\t\tVAR_11 = R_BUF_READ_PE_DWORD_AT (VAR_0->b, VAR_12 + VAR_13 * sizeof (PE_DWord));\n\t\tif (VAR_11 == VAR_21) {\n\t\t\tpe_printf (\"Warning: read (import table)\\n\");\n\t\t\tgoto error;\n\t\t} else if (VAR_11) {\n\t\t\tif (VAR_11 & VAR_22) {\n\t\t\t\tVAR_10 = VAR_11 & VAR_23;\n\t\t\t\tVAR_9 = 0;\n\t\t\t\tsnprintf (VAR_6, VAR_7, \"Ordinal_%i\", VAR_10);\n\t\t\t\tfree (VAR_18);\n\t\t\t\tstrncpy (VAR_8, VAR_3, sizeof (VAR_8) - 1);\n\t\t\t\tVAR_8[sizeof (VAR_8) - 1] = 0;\n\t\t\t\tVAR_18 = strdup (VAR_8);\n\n\t\t\t\t/* COMMENT_0 */\n\t\t\t\tsize_t VAR_14 = strlen (VAR_18);\n\t\t\t\tr_str_case (VAR_18, 0);\n\t\t\t\tVAR_14 = VAR_14 < 4? 0: VAR_14 - 4;\n\t\t\t\tVAR_18[VAR_14] = 0;\n\n\t\t\t\tchar* VAR_24 = NULL;\n\t\t\t\tif (!VAR_16 || strcmp (VAR_18, VAR_16)) {\n\t\t\t\t\tsdb_free (VAR_15);\n\t\t\t\t\tVAR_15 = NULL;\n\t\t\t\t\tfree (VAR_16);\n\t\t\t\t\tVAR_16 = strdup (VAR_18);\n\t\t\t\t\tVAR_24 = r_str_newf (\"%s.sdb\", VAR_18);\n\t\t\t\t\tif (VAR_24 && r_file_exists (VAR_24)) {\n\t\t\t\t\t\tVAR_15 = sdb_new (NULL, VAR_24, 0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst char *VAR_25 = r_sys_prefix (NULL);\n\t\t\t\t\t\tchar *VAR_26 = strdup (VAR_18);\n\t\t\t\t\t\tr_str_case (VAR_26, false);\n\t\t\t\t\t\tVAR_24 = r_str_newf (R_JOIN_4_PATHS (\"%s\", VAR_27, \"dll\", \"%s.sdb\"),\n\t\t\t\t\t\t\tVAR_25, VAR_26);\n\t\t\t\t\t\tfree (VAR_26);\n\t\t\t\t\t\tif (r_file_exists (VAR_24)) {\n\t\t\t\t\t\t\tVAR_15 = sdb_new (NULL, VAR_24, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (VAR_15) {\n\t\t\t\t\tVAR_17 = resolveModuleOrdinal (VAR_15, VAR_18, VAR_10);\n\t\t\t\t\tif (VAR_17) {\n\t\t\t\t\t\tsnprintf (VAR_6, VAR_7, \"%s\", VAR_17);\n\t\t\t\t\t\tR_FREE (VAR_17);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpe_printf (\"Cannot find %s\\n\", VAR_24);\n\t\t\t\t}\n\t\t\t\tfree (VAR_24);\n\t\t\t} else {\n\t\t\t\tVAR_10++;\n\t\t\t\tconst ut64 VAR_12 = PE_(VAR_19) (VAR_0, VAR_11);\n\t\t\t\tif (VAR_12 > VAR_0->size || (VAR_12 + sizeof (PE_Word)) > VAR_0->size) {\n\t\t\t\t\tpe_printf (\"Warning: off > pe->size\\n\");\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tVAR_9 = r_buf_read_le16_at (VAR_0->b, VAR_12);\n\t\t\t\tif (VAR_9 == VAR_20) {\n\t\t\t\t\tpe_printf (\"Warning: read import hint at 0x%08\"VAR_28 \"\\n\", VAR_12);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tVAR_8[0] = '\\0';\n\t\t\t\tVAR_14 = r_buf_read_at (VAR_0->b, VAR_12 + sizeof (PE_Word), (ut8*) VAR_8, VAR_7);\n\t\t\t\tif (VAR_14 < 1) {\n\t\t\t\t\tpe_printf (\"Warning: read (import name)\\n\");\n\t\t\t\t\tgoto error;\n\t\t\t\t} else if (!*VAR_8) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tVAR_8[VAR_7] = '\\0';\n\t\t\t\tint VAR_14 = snprintf (VAR_6, sizeof (VAR_6), \"%s\" , VAR_8);\n\t\t\t\tif (VAR_14 >= sizeof (VAR_6)) {\n\t\t\t\t\teprintf (\"Import name '%s' has been truncated.\\n\", VAR_6);\n\t\t\t\t}\n\t\t\t}\n\t\t\tstruct r_bin_pe_import_t *VAR_29 = realloc (*VAR_1, (*VAR_2 + 1) * sizeof (struct r_bin_pe_import_t));\n\t\t\tif (!VAR_29) {\n\t\t\t\tr_sys_perror (\"realloc (import)\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\t*VAR_1 = VAR_29;\n\t\t\tmemcpy ((*VAR_1)[*VAR_2].name, VAR_6, VAR_7);\n\t\t\t(*VAR_1)[*VAR_2].name[VAR_7] = '\\0';\n\t\t\tmemcpy ((*VAR_1)[*VAR_2].libname, VAR_3, VAR_7);\n\t\t\t(*VAR_1)[*VAR_2].libname[VAR_7] = '\\0';\n\t\t\t(*VAR_1)[*VAR_2].vaddr = bin_pe_rva_to_va (VAR_0, VAR_5 + VAR_13 * sizeof (PE_DWord));\n\t\t\t(*VAR_1)[*VAR_2].paddr = PE_(VAR_19) (VAR_0, VAR_5) + VAR_13 * sizeof (PE_DWord);\n\t\t\t(*VAR_1)[*VAR_2].hint = VAR_9;\n\t\t\t(*VAR_1)[*VAR_2].ordinal = VAR_10;\n\t\t\t(*VAR_1)[*VAR_2].last = 0;\n\t\t\t(*VAR_2)++;\n\t\t\tVAR_13++;\n\t\t}\n\t} while (VAR_11);\n\n\tif (VAR_15) {\n\t\tsdb_free (VAR_15);\n\t\tVAR_15 = NULL;\n\t}\n\tfree (VAR_18);\n\tfree (VAR_16);\n\treturn VAR_13;\n\nerror:\n\tif (VAR_15) {\n\t\tsdb_free (VAR_15);\n\t\tVAR_15 = NULL;\n\t}\n\tfree (VAR_18);\n\tfree (VAR_16);\n\treturn false;\n}",
  "func_graph_path_before": "radareorg/radare2/634b886e84a5c568d243e744becc6b3223e089cf/pe.c/vul/before/0.json",
  "func": "static int bin_pe_parse_imports(RBinPEObj* pe,\n                                struct r_bin_pe_import_t** importp, int* nimp,\n                                const char* dll_name,\n                                PE_DWord OriginalFirstThunk,\n                                PE_DWord FirstThunk) {\n\tchar import_name[PE_NAME_LENGTH + 1];\n\tchar name[PE_NAME_LENGTH + 1];\n\tPE_Word import_hint, import_ordinal = 0;\n\tPE_DWord import_table = 0, off = 0;\n\tint i = 0, len;\n\tSdb* db = NULL;\n\tchar* sdb_module = NULL;\n\tchar* symname = NULL;\n\tchar* symdllname = NULL;\n\n\tif (!dll_name || !*dll_name || *dll_name == '0') {\n\t\treturn 0;\n\t}\n\n\tif (!(off = PE_(va2pa) (pe, OriginalFirstThunk)) &&\n\t!(off = PE_(va2pa) (pe, FirstThunk))) {\n\t\treturn 0;\n\t}\n\tdo {\n\t\tif (import_ordinal >= UT16_MAX) {\n\t\t\tbreak;\n\t\t}\n\t\tif (off + i * sizeof (PE_DWord) > pe->size) {\n\t\t\tbreak;\n\t\t}\n\t\timport_table = R_BUF_READ_PE_DWORD_AT (pe->b, off + i * sizeof (PE_DWord));\n\t\tif (import_table == PE_DWORD_MAX) {\n\t\t\tpe_printf (\"Warning: read (import table)\\n\");\n\t\t\tgoto error;\n\t\t} else if (import_table) {\n\t\t\tif (import_table & ILT_MASK1) {\n\t\t\t\timport_ordinal = import_table & ILT_MASK2;\n\t\t\t\timport_hint = 0;\n\t\t\t\tsnprintf (import_name, PE_NAME_LENGTH, \"Ordinal_%i\", import_ordinal);\n\t\t\t\tfree (symdllname);\n\t\t\t\tstrncpy (name, dll_name, sizeof (name) - 1);\n\t\t\t\tname[sizeof (name) - 1] = 0;\n\t\t\t\tsymdllname = strdup (name);\n\n\t\t\t\t// remove the trailling \".dll\"\n\t\t\t\tsize_t len = strlen (symdllname);\n\t\t\t\tr_str_case (symdllname, 0);\n\t\t\t\tlen = len < 4? 0: len - 4;\n\t\t\t\tsymdllname[len] = 0;\n\n\t\t\t\tchar* filename = NULL;\n\t\t\t\tif (!sdb_module || strcmp (symdllname, sdb_module)) {\n\t\t\t\t\tsdb_free (db);\n\t\t\t\t\tdb = NULL;\n\t\t\t\t\tfree (sdb_module);\n\t\t\t\t\tsdb_module = strdup (symdllname);\n\t\t\t\t\tfilename = r_str_newf (\"%s.sdb\", symdllname);\n\t\t\t\t\tif (filename && r_file_exists (filename)) {\n\t\t\t\t\t\tdb = sdb_new (NULL, filename, 0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst char *dirPrefix = r_sys_prefix (NULL);\n\t\t\t\t\t\tchar *lower_symdllname = strdup (symdllname);\n\t\t\t\t\t\tr_str_case (lower_symdllname, false);\n\t\t\t\t\t\tfilename = r_str_newf (R_JOIN_4_PATHS (\"%s\", R2_SDB_FORMAT, \"dll\", \"%s.sdb\"),\n\t\t\t\t\t\t\tdirPrefix, lower_symdllname);\n\t\t\t\t\t\tfree (lower_symdllname);\n\t\t\t\t\t\tif (r_file_exists (filename)) {\n\t\t\t\t\t\t\tdb = sdb_new (NULL, filename, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (db) {\n\t\t\t\t\tsymname = resolveModuleOrdinal (db, symdllname, import_ordinal);\n\t\t\t\t\tif (symname) {\n\t\t\t\t\t\tsnprintf (import_name, PE_NAME_LENGTH, \"%s\", symname);\n\t\t\t\t\t\tR_FREE (symname);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpe_printf (\"Cannot find %s\\n\", filename);\n\t\t\t\t}\n\t\t\t\tfree (filename);\n\t\t\t} else {\n\t\t\t\timport_ordinal++;\n\t\t\t\tconst ut64 off = PE_(va2pa) (pe, import_table);\n\t\t\t\tif (off > pe->size || (off + sizeof (PE_Word)) > pe->size) {\n\t\t\t\t\tpe_printf (\"Warning: off > pe->size\\n\");\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\timport_hint = r_buf_read_le16_at (pe->b, off);\n\t\t\t\tif (import_hint == UT16_MAX) {\n\t\t\t\t\tpe_printf (\"Warning: read import hint at 0x%08\"PFMT64x \"\\n\", off);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tname[0] = '\\0';\n\t\t\t\tlen = r_buf_read_at (pe->b, off + sizeof (PE_Word), (ut8*) name, PE_NAME_LENGTH);\n\t\t\t\tif (len < 1) {\n\t\t\t\t\tpe_printf (\"Warning: read (import name)\\n\");\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tif (!*name) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tname[PE_NAME_LENGTH] = '\\0';\n\t\t\t\tint len = snprintf (import_name, sizeof (import_name), \"%s\" , name);\n\t\t\t\tif (len >= sizeof (import_name)) {\n\t\t\t\t\teprintf (\"Import name '%s' has been truncated.\\n\", import_name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tstruct r_bin_pe_import_t *new_importp = realloc (*importp, (*nimp + 1) * sizeof (struct r_bin_pe_import_t));\n\t\t\tif (!new_importp) {\n\t\t\t\tr_sys_perror (\"realloc (import)\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\t*importp = new_importp;\n\t\t\tmemcpy ((*importp)[*nimp].name, import_name, PE_NAME_LENGTH);\n\t\t\t(*importp)[*nimp].name[PE_NAME_LENGTH] = '\\0';\n\t\t\tmemcpy ((*importp)[*nimp].libname, dll_name, PE_NAME_LENGTH);\n\t\t\t(*importp)[*nimp].libname[PE_NAME_LENGTH] = '\\0';\n\t\t\t(*importp)[*nimp].vaddr = bin_pe_rva_to_va (pe, FirstThunk + i * sizeof (PE_DWord));\n\t\t\t(*importp)[*nimp].paddr = PE_(va2pa) (pe, FirstThunk) + i * sizeof (PE_DWord);\n\t\t\t(*importp)[*nimp].hint = import_hint;\n\t\t\t(*importp)[*nimp].ordinal = import_ordinal;\n\t\t\t(*importp)[*nimp].last = 0;\n\t\t\t(*nimp)++;\n\t\t\ti++;\n\t\t}\n\t} while (import_table);\n\n\tif (db) {\n\t\tsdb_free (db);\n\t\tdb = NULL;\n\t}\n\tfree (symdllname);\n\tfree (sdb_module);\n\treturn i;\n\nerror:\n\tif (db) {\n\t\tsdb_free (db);\n\t\tdb = NULL;\n\t}\n\tfree (symdllname);\n\tfree (sdb_module);\n\treturn false;\n}",
  "abstract_func": "static int bin_pe_parse_imports(RBinPEObj* VAR_0,\n                                struct r_bin_pe_import_t** VAR_1, int* VAR_2,\n                                const char* VAR_3,\n                                PE_DWord VAR_4,\n                                PE_DWord VAR_5) {\n\tchar VAR_6[VAR_7 + 1];\n\tchar VAR_8[VAR_7 + 1];\n\tPE_Word VAR_9, VAR_10 = 0;\n\tPE_DWord VAR_11 = 0, VAR_12 = 0;\n\tint VAR_13 = 0, VAR_14;\n\tSdb* VAR_15 = NULL;\n\tchar* VAR_16 = NULL;\n\tchar* VAR_17 = NULL;\n\tchar* VAR_18 = NULL;\n\n\tif (!VAR_3 || !*VAR_3 || *VAR_3 == '0') {\n\t\treturn 0;\n\t}\n\n\tif (!(VAR_12 = PE_(VAR_19) (VAR_0, VAR_4)) &&\n\t!(VAR_12 = PE_(VAR_19) (VAR_0, VAR_5))) {\n\t\treturn 0;\n\t}\n\tdo {\n\t\tif (VAR_10 >= VAR_20) {\n\t\t\tbreak;\n\t\t}\n\t\tif (VAR_12 + VAR_13 * sizeof (PE_DWord) > VAR_0->size) {\n\t\t\tbreak;\n\t\t}\n\t\tVAR_11 = R_BUF_READ_PE_DWORD_AT (VAR_0->b, VAR_12 + VAR_13 * sizeof (PE_DWord));\n\t\tif (VAR_11 == VAR_21) {\n\t\t\tpe_printf (\"Warning: read (import table)\\n\");\n\t\t\tgoto error;\n\t\t} else if (VAR_11) {\n\t\t\tif (VAR_11 & VAR_22) {\n\t\t\t\tVAR_10 = VAR_11 & VAR_23;\n\t\t\t\tVAR_9 = 0;\n\t\t\t\tsnprintf (VAR_6, VAR_7, \"Ordinal_%i\", VAR_10);\n\t\t\t\tfree (VAR_18);\n\t\t\t\tstrncpy (VAR_8, VAR_3, sizeof (VAR_8) - 1);\n\t\t\t\tVAR_8[sizeof (VAR_8) - 1] = 0;\n\t\t\t\tVAR_18 = strdup (VAR_8);\n\n\t\t\t\t/* COMMENT_0 */\n\t\t\t\tsize_t VAR_14 = strlen (VAR_18);\n\t\t\t\tr_str_case (VAR_18, 0);\n\t\t\t\tVAR_14 = VAR_14 < 4? 0: VAR_14 - 4;\n\t\t\t\tVAR_18[VAR_14] = 0;\n\n\t\t\t\tchar* VAR_24 = NULL;\n\t\t\t\tif (!VAR_16 || strcmp (VAR_18, VAR_16)) {\n\t\t\t\t\tsdb_free (VAR_15);\n\t\t\t\t\tVAR_15 = NULL;\n\t\t\t\t\tfree (VAR_16);\n\t\t\t\t\tVAR_16 = strdup (VAR_18);\n\t\t\t\t\tVAR_24 = r_str_newf (\"%s.sdb\", VAR_18);\n\t\t\t\t\tif (VAR_24 && r_file_exists (VAR_24)) {\n\t\t\t\t\t\tVAR_15 = sdb_new (NULL, VAR_24, 0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst char *VAR_25 = r_sys_prefix (NULL);\n\t\t\t\t\t\tchar *VAR_26 = strdup (VAR_18);\n\t\t\t\t\t\tr_str_case (VAR_26, false);\n\t\t\t\t\t\tVAR_24 = r_str_newf (R_JOIN_4_PATHS (\"%s\", VAR_27, \"dll\", \"%s.sdb\"),\n\t\t\t\t\t\t\tVAR_25, VAR_26);\n\t\t\t\t\t\tfree (VAR_26);\n\t\t\t\t\t\tif (r_file_exists (VAR_24)) {\n\t\t\t\t\t\t\tVAR_15 = sdb_new (NULL, VAR_24, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (VAR_15) {\n\t\t\t\t\tVAR_17 = resolveModuleOrdinal (VAR_15, VAR_18, VAR_10);\n\t\t\t\t\tif (VAR_17) {\n\t\t\t\t\t\tsnprintf (VAR_6, VAR_7, \"%s\", VAR_17);\n\t\t\t\t\t\tR_FREE (VAR_17);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpe_printf (\"Cannot find %s\\n\", VAR_24);\n\t\t\t\t}\n\t\t\t\tfree (VAR_24);\n\t\t\t} else {\n\t\t\t\tVAR_10++;\n\t\t\t\tconst ut64 VAR_12 = PE_(VAR_19) (VAR_0, VAR_11);\n\t\t\t\tif (VAR_12 > VAR_0->size || (VAR_12 + sizeof (PE_Word)) > VAR_0->size) {\n\t\t\t\t\tpe_printf (\"Warning: off > pe->size\\n\");\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tVAR_9 = r_buf_read_le16_at (VAR_0->b, VAR_12);\n\t\t\t\tif (VAR_9 == VAR_20) {\n\t\t\t\t\tpe_printf (\"Warning: read import hint at 0x%08\"VAR_28 \"\\n\", VAR_12);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tVAR_8[0] = '\\0';\n\t\t\t\tVAR_14 = r_buf_read_at (VAR_0->b, VAR_12 + sizeof (PE_Word), (ut8*) VAR_8, VAR_7);\n\t\t\t\tif (VAR_14 < 1) {\n\t\t\t\t\tpe_printf (\"Warning: read (import name)\\n\");\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tif (!*VAR_8) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tVAR_8[VAR_7] = '\\0';\n\t\t\t\tint VAR_14 = snprintf (VAR_6, sizeof (VAR_6), \"%s\" , VAR_8);\n\t\t\t\tif (VAR_14 >= sizeof (VAR_6)) {\n\t\t\t\t\teprintf (\"Import name '%s' has been truncated.\\n\", VAR_6);\n\t\t\t\t}\n\t\t\t}\n\t\t\tstruct r_bin_pe_import_t *VAR_29 = realloc (*VAR_1, (*VAR_2 + 1) * sizeof (struct r_bin_pe_import_t));\n\t\t\tif (!VAR_29) {\n\t\t\t\tr_sys_perror (\"realloc (import)\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\t*VAR_1 = VAR_29;\n\t\t\tmemcpy ((*VAR_1)[*VAR_2].name, VAR_6, VAR_7);\n\t\t\t(*VAR_1)[*VAR_2].name[VAR_7] = '\\0';\n\t\t\tmemcpy ((*VAR_1)[*VAR_2].libname, VAR_3, VAR_7);\n\t\t\t(*VAR_1)[*VAR_2].libname[VAR_7] = '\\0';\n\t\t\t(*VAR_1)[*VAR_2].vaddr = bin_pe_rva_to_va (VAR_0, VAR_5 + VAR_13 * sizeof (PE_DWord));\n\t\t\t(*VAR_1)[*VAR_2].paddr = PE_(VAR_19) (VAR_0, VAR_5) + VAR_13 * sizeof (PE_DWord);\n\t\t\t(*VAR_1)[*VAR_2].hint = VAR_9;\n\t\t\t(*VAR_1)[*VAR_2].ordinal = VAR_10;\n\t\t\t(*VAR_1)[*VAR_2].last = 0;\n\t\t\t(*VAR_2)++;\n\t\t\tVAR_13++;\n\t\t}\n\t} while (VAR_11);\n\n\tif (VAR_15) {\n\t\tsdb_free (VAR_15);\n\t\tVAR_15 = NULL;\n\t}\n\tfree (VAR_18);\n\tfree (VAR_16);\n\treturn VAR_13;\n\nerror:\n\tif (VAR_15) {\n\t\tsdb_free (VAR_15);\n\t\tVAR_15 = NULL;\n\t}\n\tfree (VAR_18);\n\tfree (VAR_16);\n\treturn false;\n}",
  "func_graph_path": "radareorg/radare2/634b886e84a5c568d243e744becc6b3223e089cf/pe.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -96,7 +96,8 @@\n \t\t\t\tif (len < 1) {\n \t\t\t\t\tpe_printf (\"Warning: read (import name)\\n\");\n \t\t\t\t\tgoto error;\n-\t\t\t\t} else if (!*name) {\n+\t\t\t\t}\n+\t\t\t\tif (!*name) {\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tname[PE_NAME_LENGTH] = '\\0';",
  "diff_line_info": {
    "deleted_lines": [
      "\t\t\t\t} else if (!*name) {"
    ],
    "added_lines": [
      "\t\t\t\t}",
      "\t\t\t\tif (!*name) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/radareorg/radare2/pull/19747",
  "description": {
    "pr_info": {
      "title": "Fix DoS in PE/QNX/DYLDCACHE/PSX parsers ##crash",
      "number": 19747
    },
    "comment": [
      "* Reported by lazymio\r\n* Reproducer: AAA4AAAAAB4=\r\n\r\n<!--\r\nRead https://github.com/radareorg/radare2/blob/master/DEVELOPERS.md\r\n* PR title must be capitalized, concise and use ##tags\r\n* If the PR is fixing a ticket use 'Fix #1234 - ..' in the commit message\r\n* Follow the coding style, add tests and documentation if necessary\r\n-->\r\n\r\n- [ ] Mark this if you consider it ready to merge\r\n- [ ] I've added tests (optional)\r\n- [ ] I wrote some lines in the [book](https://github.com/radareorg/radare2book) (optional)\r\n\r\n**Description**\r\n\r\n<!-- explain your changes if necessary -->\r\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95"
}