{
  "cve_id": "CVE-2018-6358",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "libming",
  "commit_msg": "Fix heap buffer overflow in listfdb.c\n\nlistfdb reads nGlyphs + 1 glyphs and stores them in an array of size\nnGlyphs*sizeof(int), resulting in a heap buffer overflow.\n\nIn this commit we replace for(i=0; i<=nGlyphs; ++i)\nby for(i=0; i < nGlyphs; ++i) so that only nGlyphs glyphs are read.\n\nThis patch addresses CVE-2018-6358 (fixes #104).",
  "commit_hash": "cff9a3bd2c428ad0cd8c8deb538031e11f29a0fe",
  "git_url": "https://github.com/libming/libming/commit/cff9a3bd2c428ad0cd8c8deb538031e11f29a0fe",
  "file_path": "util/listfdb.c",
  "func_name": "printDefineFont2",
  "func_before": "void printDefineFont2(FILE *f)\n{\n  int flags, nGlyphs, namelen, off, i, fillBits, lineBits;\n  int here = fileOffset;\n  unsigned int *offset;\n\n  flags = readUInt8(f);\n\n  readUInt8(f); /* \"reserved\" */\n\n  namelen = readUInt8(f);\n\n  printf(\"%sFont Name: \", indent());\n\n  for(; namelen>0; --namelen)\n    putchar((unsigned char)readUInt8(f));\n\n  putchar('\\n');\n\n  nGlyphs = readUInt16(f);\n  printf(\"%snumber of glyphs: %i\\n\\n\", indent(), nGlyphs);\n\n  offset = (unsigned int *)malloc(nGlyphs*sizeof(int));\n\n  /* offset table */\n\n  here = fileOffset;\n\n  for(i=0; i<=nGlyphs; ++i)\n  {\n    if(flags & FONTINFO2_WIDEOFFSETS)\n      off = readUInt32(f);\n    else\n      off = readUInt16(f);\n\n    offset[i] = off-nGlyphs*4-4;\n    printf(\"%sOffset%i: %i\\n\", indent(), i, offset[i]);\n  }\n\n  here = fileOffset;\n\n  /* shape table */\n  for(i=0; i<nGlyphs; ++i)\n  {\n    byteAlign();\n    printf(\"%sGlyph %i:\\n\", indent(), i);\n\n    fillBits = readBits(f, 4);\n    lineBits = readBits(f, 4);\n\n    byteAlign();\n    while(printShapeRec(f, &fillBits, &lineBits, 2)) ;\n\n    putchar('\\n');\n  }\n\n  /* code table */\n  for(i=0; i<nGlyphs; ++i)\n  {\n    if(flags & FONTINFO2_WIDECODES)\n      printf(\"%sglyph code %i: %i\\n\", indent(), i, readUInt16(f));\n    else\n      printf(\"%sglyph code %i: %i\\n\", indent(), i, readUInt8(f));\n  }\n\n  if(flags & FONTINFO2_HASLAYOUT)\n  {\n    int kernCount, code1, code2;\n\n    printf(\"%sascender height: %i\\n\", indent(), readSInt16(f));\n    printf(\"%sdescender height: %i\\n\", indent(), readSInt16(f));\n    printf(\"%sleading height: %i\\n\", indent(), readSInt16(f));\n\n    for(i=0; i<nGlyphs; ++i)\n      printf(\"\\tadvance %i: %i\\n\", i, readSInt16(f));\n\n    for(i=0; i<nGlyphs; ++i)\n    {\n      printf(\"%sbounds %i: \", indent(), i);\n      printRect(f);\n      putchar('\\n');\n    }\n\n    kernCount = readUInt16(f);\n\n    for(i=0; i<kernCount; ++i)\n    {\n      code1 = (flags & FONTINFO2_WIDECODES) ? readUInt16(f) : readUInt8(f);\n      code2 = (flags & FONTINFO2_WIDECODES) ? readUInt16(f) : readUInt8(f);\n      printf(\"%s(%i,%i): adjustment = %i\\n\", indent(), code1, code2, readSInt16(f));\n    }\n  }\n\n  putchar('\\n');\n}",
  "abstract_func_before": "void printDefineFont2(FILE *VAR_0)\n{\n  int VAR_1, VAR_2, VAR_3, VAR_4, VAR_5, VAR_6, VAR_7;\n  int VAR_8 = VAR_9;\n  unsigned int *VAR_10;\n\n  VAR_1 = readUInt8(VAR_0);\n\n  readUInt8(VAR_0); /* COMMENT_0 */\n\n  VAR_3 = readUInt8(VAR_0);\n\n  printf(\"%sFont Name: \", indent());\n\n  for(; VAR_3>0; --VAR_3)\n    putchar((unsigned char)readUInt8(VAR_0));\n\n  putchar('\\n');\n\n  VAR_2 = readUInt16(VAR_0);\n  printf(\"%snumber of glyphs: %i\\n\\n\", indent(), VAR_2);\n\n  VAR_10 = (unsigned int *)malloc(VAR_2*sizeof(int));\n\n  /* COMMENT_1 */\n\n  VAR_8 = VAR_9;\n\n  for(VAR_5=0; VAR_5<=VAR_2; ++VAR_5)\n  {\n    if(VAR_1 & VAR_11)\n      VAR_4 = readUInt32(VAR_0);\n    else\n      VAR_4 = readUInt16(VAR_0);\n\n    VAR_10[VAR_5] = VAR_4-VAR_2*4-4;\n    printf(\"%sOffset%i: %i\\n\", indent(), VAR_5, VAR_10[VAR_5]);\n  }\n\n  VAR_8 = VAR_9;\n\n  /* COMMENT_2 */\n  for(VAR_5=0; VAR_5<VAR_2; ++VAR_5)\n  {\n    byteAlign();\n    printf(\"%sGlyph %i:\\n\", indent(), VAR_5);\n\n    VAR_6 = readBits(VAR_0, 4);\n    VAR_7 = readBits(VAR_0, 4);\n\n    byteAlign();\n    while(printShapeRec(VAR_0, &VAR_6, &VAR_7, 2)) ;\n\n    putchar('\\n');\n  }\n\n  /* COMMENT_3 */\n  for(VAR_5=0; VAR_5<VAR_2; ++VAR_5)\n  {\n    if(VAR_1 & VAR_12)\n      printf(\"%sglyph code %i: %i\\n\", indent(), VAR_5, readUInt16(VAR_0));\n    else\n      printf(\"%sglyph code %i: %i\\n\", indent(), VAR_5, readUInt8(VAR_0));\n  }\n\n  if(VAR_1 & VAR_13)\n  {\n    int VAR_14, VAR_15, VAR_16;\n\n    printf(\"%sascender height: %i\\n\", indent(), readSInt16(VAR_0));\n    printf(\"%sdescender height: %i\\n\", indent(), readSInt16(VAR_0));\n    printf(\"%sleading height: %i\\n\", indent(), readSInt16(VAR_0));\n\n    for(VAR_5=0; VAR_5<VAR_2; ++VAR_5)\n      printf(\"\\tadvance %i: %i\\n\", VAR_5, readSInt16(VAR_0));\n\n    for(VAR_5=0; VAR_5<VAR_2; ++VAR_5)\n    {\n      printf(\"%sbounds %i: \", indent(), VAR_5);\n      printRect(VAR_0);\n      putchar('\\n');\n    }\n\n    VAR_14 = readUInt16(VAR_0);\n\n    for(VAR_5=0; VAR_5<VAR_14; ++VAR_5)\n    {\n      VAR_15 = (VAR_1 & VAR_12) ? readUInt16(VAR_0) : readUInt8(VAR_0);\n      VAR_16 = (VAR_1 & VAR_12) ? readUInt16(VAR_0) : readUInt8(VAR_0);\n      printf(\"%s(%i,%i): adjustment = %i\\n\", indent(), VAR_15, VAR_16, readSInt16(VAR_0));\n    }\n  }\n\n  putchar('\\n');\n}",
  "func_graph_path_before": "libming/cff9a3bd2c428ad0cd8c8deb538031e11f29a0fe/listfdb.c/vul/before/0.json",
  "func": "void printDefineFont2(FILE *f)\n{\n  int flags, nGlyphs, namelen, off, i, fillBits, lineBits;\n  int here = fileOffset;\n  unsigned int *offset;\n\n  flags = readUInt8(f);\n\n  readUInt8(f); /* \"reserved\" */\n\n  namelen = readUInt8(f);\n\n  printf(\"%sFont Name: \", indent());\n\n  for(; namelen>0; --namelen)\n    putchar((unsigned char)readUInt8(f));\n\n  putchar('\\n');\n\n  nGlyphs = readUInt16(f);\n  printf(\"%snumber of glyphs: %i\\n\\n\", indent(), nGlyphs);\n\n  offset = (unsigned int *)malloc(nGlyphs*sizeof(int));\n\n  /* offset table */\n\n  here = fileOffset;\n\n  for(i=0; i<nGlyphs; ++i)\n  {\n    if(flags & FONTINFO2_WIDEOFFSETS)\n      off = readUInt32(f);\n    else\n      off = readUInt16(f);\n\n    offset[i] = off-nGlyphs*4-4;\n    printf(\"%sOffset%i: %i\\n\", indent(), i, offset[i]);\n  }\n\n  here = fileOffset;\n\n  /* shape table */\n  for(i=0; i<nGlyphs; ++i)\n  {\n    byteAlign();\n    printf(\"%sGlyph %i:\\n\", indent(), i);\n\n    fillBits = readBits(f, 4);\n    lineBits = readBits(f, 4);\n\n    byteAlign();\n    while(printShapeRec(f, &fillBits, &lineBits, 2)) ;\n\n    putchar('\\n');\n  }\n\n  /* code table */\n  for(i=0; i<nGlyphs; ++i)\n  {\n    if(flags & FONTINFO2_WIDECODES)\n      printf(\"%sglyph code %i: %i\\n\", indent(), i, readUInt16(f));\n    else\n      printf(\"%sglyph code %i: %i\\n\", indent(), i, readUInt8(f));\n  }\n\n  if(flags & FONTINFO2_HASLAYOUT)\n  {\n    int kernCount, code1, code2;\n\n    printf(\"%sascender height: %i\\n\", indent(), readSInt16(f));\n    printf(\"%sdescender height: %i\\n\", indent(), readSInt16(f));\n    printf(\"%sleading height: %i\\n\", indent(), readSInt16(f));\n\n    for(i=0; i<nGlyphs; ++i)\n      printf(\"\\tadvance %i: %i\\n\", i, readSInt16(f));\n\n    for(i=0; i<nGlyphs; ++i)\n    {\n      printf(\"%sbounds %i: \", indent(), i);\n      printRect(f);\n      putchar('\\n');\n    }\n\n    kernCount = readUInt16(f);\n\n    for(i=0; i<kernCount; ++i)\n    {\n      code1 = (flags & FONTINFO2_WIDECODES) ? readUInt16(f) : readUInt8(f);\n      code2 = (flags & FONTINFO2_WIDECODES) ? readUInt16(f) : readUInt8(f);\n      printf(\"%s(%i,%i): adjustment = %i\\n\", indent(), code1, code2, readSInt16(f));\n    }\n  }\n\n  putchar('\\n');\n}",
  "abstract_func": "void printDefineFont2(FILE *VAR_0)\n{\n  int VAR_1, VAR_2, VAR_3, VAR_4, VAR_5, VAR_6, VAR_7;\n  int VAR_8 = VAR_9;\n  unsigned int *VAR_10;\n\n  VAR_1 = readUInt8(VAR_0);\n\n  readUInt8(VAR_0); /* COMMENT_0 */\n\n  VAR_3 = readUInt8(VAR_0);\n\n  printf(\"%sFont Name: \", indent());\n\n  for(; VAR_3>0; --VAR_3)\n    putchar((unsigned char)readUInt8(VAR_0));\n\n  putchar('\\n');\n\n  VAR_2 = readUInt16(VAR_0);\n  printf(\"%snumber of glyphs: %i\\n\\n\", indent(), VAR_2);\n\n  VAR_10 = (unsigned int *)malloc(VAR_2*sizeof(int));\n\n  /* COMMENT_1 */\n\n  VAR_8 = VAR_9;\n\n  for(VAR_5=0; VAR_5<VAR_2; ++VAR_5)\n  {\n    if(VAR_1 & VAR_11)\n      VAR_4 = readUInt32(VAR_0);\n    else\n      VAR_4 = readUInt16(VAR_0);\n\n    VAR_10[VAR_5] = VAR_4-VAR_2*4-4;\n    printf(\"%sOffset%i: %i\\n\", indent(), VAR_5, VAR_10[VAR_5]);\n  }\n\n  VAR_8 = VAR_9;\n\n  /* COMMENT_2 */\n  for(VAR_5=0; VAR_5<VAR_2; ++VAR_5)\n  {\n    byteAlign();\n    printf(\"%sGlyph %i:\\n\", indent(), VAR_5);\n\n    VAR_6 = readBits(VAR_0, 4);\n    VAR_7 = readBits(VAR_0, 4);\n\n    byteAlign();\n    while(printShapeRec(VAR_0, &VAR_6, &VAR_7, 2)) ;\n\n    putchar('\\n');\n  }\n\n  /* COMMENT_3 */\n  for(VAR_5=0; VAR_5<VAR_2; ++VAR_5)\n  {\n    if(VAR_1 & VAR_12)\n      printf(\"%sglyph code %i: %i\\n\", indent(), VAR_5, readUInt16(VAR_0));\n    else\n      printf(\"%sglyph code %i: %i\\n\", indent(), VAR_5, readUInt8(VAR_0));\n  }\n\n  if(VAR_1 & VAR_13)\n  {\n    int VAR_14, VAR_15, VAR_16;\n\n    printf(\"%sascender height: %i\\n\", indent(), readSInt16(VAR_0));\n    printf(\"%sdescender height: %i\\n\", indent(), readSInt16(VAR_0));\n    printf(\"%sleading height: %i\\n\", indent(), readSInt16(VAR_0));\n\n    for(VAR_5=0; VAR_5<VAR_2; ++VAR_5)\n      printf(\"\\tadvance %i: %i\\n\", VAR_5, readSInt16(VAR_0));\n\n    for(VAR_5=0; VAR_5<VAR_2; ++VAR_5)\n    {\n      printf(\"%sbounds %i: \", indent(), VAR_5);\n      printRect(VAR_0);\n      putchar('\\n');\n    }\n\n    VAR_14 = readUInt16(VAR_0);\n\n    for(VAR_5=0; VAR_5<VAR_14; ++VAR_5)\n    {\n      VAR_15 = (VAR_1 & VAR_12) ? readUInt16(VAR_0) : readUInt8(VAR_0);\n      VAR_16 = (VAR_1 & VAR_12) ? readUInt16(VAR_0) : readUInt8(VAR_0);\n      printf(\"%s(%i,%i): adjustment = %i\\n\", indent(), VAR_15, VAR_16, readSInt16(VAR_0));\n    }\n  }\n\n  putchar('\\n');\n}",
  "func_graph_path": "libming/cff9a3bd2c428ad0cd8c8deb538031e11f29a0fe/listfdb.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -26,7 +26,7 @@\n \n   here = fileOffset;\n \n-  for(i=0; i<=nGlyphs; ++i)\n+  for(i=0; i<nGlyphs; ++i)\n   {\n     if(flags & FONTINFO2_WIDEOFFSETS)\n       off = readUInt32(f);",
  "diff_line_info": {
    "deleted_lines": [
      "  for(i=0; i<=nGlyphs; ++i)"
    ],
    "added_lines": [
      "  for(i=0; i<nGlyphs; ++i)"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libming/libming/pull/124",
  "description": {
    "pr_info": {
      "title": "Fix several issues in listfdb and some compiler warnings",
      "number": 124
    },
    "comment": [
      "**Issue #104:**\r\n\r\nlistfdb reads nGlyphs + 1 glyphs and stores them in an array of size nGlyphs*sizeof(int), resulting in a heap buffer overflow.\r\n\r\nIn this commit we replace `for(i=0; i<=nGlyphs; ++i)` by `for(i=0; i < nGlyphs; ++i)` so that only nGlyphs glyphs are read.\r\n\r\n**Issues #106 and #107:**\r\n\r\nlistfdb is shipping a large portion of duplicate code from the read module. This is a major security flaw given that the copied source code is affected by a large number of security issues (actually, almost all issues discovered in read.c for a long long time).\r\n\r\nIn this patch we remove the duplicate code from listfdb.\r\n\r\nIn order to do this we:\r\n- Link again read.h\r\n- Add the required dependency in util/Makefile.am\r\n- Make the bufbits variable extern in read.h\r\n\r\nThese changes are *not* trivial and a detailed review would be really helpful.\r\n\r\n**Compiler warnings:**\r\n\r\nRemove useless variables blockstart, blockoffset and here.\r\n\r\nThis PR fixes #104, #106 and #107.",
      "Thanks, merged with c4d20b127bac8cfd13fc7a965f3ffdf3d59e5793\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0\n\n**Step-by-Step Explanation:**\n\n- **Commit Message Analysis:** The message explicitly mentions fixing a \"heap buffer overflow\" and references a CVE-2018-6358, indicating a security issue.\n- **Code Diff Analysis:** The loop condition is corrected to prevent reading beyond the array's bounds, directly addressing the buffer overflow.\n- **Vulnerability Description:** Confirms the buffer overflow bug and the associated CVE, aligning with the commit and code changes.\n\n**Conclusion:** The patch addresses a security vulnerability, specifically a buffer overflow, with high confidence due to explicit references and clear code changes."
}