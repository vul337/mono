{
  "cve_id": "CVE-2020-16124",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "ros/ros_comm",
  "commit_msg": "Trap for overly large input to XmlRPCPP which could cause problems with int <-> size_t conversions.\n\n - In XmlRpcClient, XmlRpcServerConnection and XmlRpcSocket, recognize when incoming or outgoing data is too large, generate an error and discard the data when practical.\n - Use the safe strtol() rather than atoi() to decode an incoming content-length header, and generate an error if the length is invalid or too large.\n - In XmlRpcUtil, prevent attempts to parse overly large XML input.\n - Add tests where they can reasonably be inserted into existing test routines.\n\nAlthough this fix could be cleaner the update is written to make the update ABI compatible.\n\nThis fix addresses CVE-2020-16124 / Integer overflow in ros_comm.\n\nSigned-off-by: Sid Faber <sid.faber@canonical.com>",
  "commit_hash": "3dd308911d7294bc6cff12f626b8467fe1555423",
  "git_url": "https://github.com/ros/ros_comm/commit/3dd308911d7294bc6cff12f626b8467fe1555423",
  "file_path": "utilities/xmlrpcpp/src/XmlRpcClient.cpp",
  "func_name": "XmlRpcClient::readResponse",
  "func_before": "bool\nXmlRpcClient::readResponse()\n{\n  // If we dont have the entire response yet, read available data\n  if (int(_response.length()) < _contentLength) {\n    std::string buff;\n    if ( ! XmlRpcSocket::nbRead(this->getfd(), buff, &_eof)) {\n      XmlRpcUtil::error(\"Error in XmlRpcClient::readResponse: read error (%s).\",XmlRpcSocket::getErrorMsg().c_str());\n      // nbRead returned an error, indicating that the socket is in a bad state.\n      // close it and stop monitoring this client.\n      close();\n      return false;\n    }\n    _response += buff;\n\n    // If we haven't gotten the entire _response yet, return (keep reading)\n    if (int(_response.length()) < _contentLength) {\n      if (_eof) {\n        XmlRpcUtil::error(\"Error in XmlRpcClient::readResponse: EOF while reading response\");\n        // nbRead returned an eof, indicating that the socket is disconnected.\n        // close it and stop monitoring this client.\n        close();\n        return false;\n      }\n      return true;\n    }\n  }\n\n  // Otherwise, parse and return the result\n  XmlRpcUtil::log(3, \"XmlRpcClient::readResponse (read %d bytes)\", _response.length());\n  XmlRpcUtil::log(5, \"response:\\n%s\", _response.c_str());\n\n  _connectionState = IDLE;\n\n  return false;    // Stop monitoring this source (causes return from work)\n}",
  "abstract_func_before": "bool\nXmlRpcClient::readResponse()\n{\n  /* COMMENT_0 */\n  if (int(VAR_0.length()) < VAR_1) {\n    std::string VAR_2;\n    if ( ! XmlRpcSocket::nbRead(this->getfd(), VAR_2, &VAR_3)) {\n      XmlRpcUtil::error(\"Error in XmlRpcClient::readResponse: read error (%s).\",XmlRpcSocket::getErrorMsg().c_str());\n      /* COMMENT_1 */\n      /* COMMENT_2 */\n      close();\n      return false;\n    }\n    VAR_0 += VAR_2;\n\n    /* COMMENT_3 */\n    if (int(VAR_0.length()) < VAR_1) {\n      if (VAR_3) {\n        XmlRpcUtil::error(\"Error in XmlRpcClient::readResponse: EOF while reading response\");\n        /* COMMENT_4 */\n        /* COMMENT_2 */\n        close();\n        return false;\n      }\n      return true;\n    }\n  }\n\n  /* COMMENT_5 */\n  XmlRpcUtil::log(3, \"XmlRpcClient::readResponse (read %d bytes)\", VAR_0.length());\n  XmlRpcUtil::log(5, \"response:\\n%s\", VAR_0.c_str());\n\n  VAR_4 = VAR_5;\n\n  return false;    /* COMMENT_6 */\n}",
  "func_graph_path_before": "ros/ros_comm/3dd308911d7294bc6cff12f626b8467fe1555423/XmlRpcClient.cpp/vul/before/1.json",
  "func": "bool\nXmlRpcClient::readResponse()\n{\n  // If we dont have the entire response yet, read available data\n  if (int(_response.length()) < _contentLength) {\n    std::string buff;\n    if ( ! XmlRpcSocket::nbRead(this->getfd(), buff, &_eof)) {\n      XmlRpcUtil::error(\"Error in XmlRpcClient::readResponse: read error (%s).\",XmlRpcSocket::getErrorMsg().c_str());\n      // nbRead returned an error, indicating that the socket is in a bad state.\n      // close it and stop monitoring this client.\n      close();\n      return false;\n    }\n    _response += buff;\n\n    // Avoid an overly large response\n    if (_response.length() > size_t(__INT_MAX__)) {\n      XmlRpcUtil::error(\"XmlRpcClient::readResponse: response length (%u) exceeds the maximum allowed size (%u).\",\n                        _response.length(), __INT_MAX__);\n      _response.clear();\n      close();\n      return false;\n    }\n    // If we haven't gotten the entire _response yet, return (keep reading)\n    if (int(_response.length()) < _contentLength) {\n      if (_eof) {\n        XmlRpcUtil::error(\"Error in XmlRpcClient::readResponse: EOF while reading response\");\n        // nbRead returned an eof, indicating that the socket is disconnected.\n        // close it and stop monitoring this client.\n        close();\n        return false;\n      }\n      return true;\n    }\n  }\n\n  // Otherwise, parse and return the result\n  XmlRpcUtil::log(3, \"XmlRpcClient::readResponse (read %d bytes)\", _response.length());\n  XmlRpcUtil::log(5, \"response:\\n%s\", _response.c_str());\n\n  _connectionState = IDLE;\n\n  return false;    // Stop monitoring this source (causes return from work)\n}",
  "abstract_func": "bool\nXmlRpcClient::readResponse()\n{\n  /* COMMENT_0 */\n  if (int(VAR_0.length()) < VAR_1) {\n    std::string VAR_2;\n    if ( ! XmlRpcSocket::nbRead(this->getfd(), VAR_2, &VAR_3)) {\n      XmlRpcUtil::error(\"Error in XmlRpcClient::readResponse: read error (%s).\",XmlRpcSocket::getErrorMsg().c_str());\n      /* COMMENT_1 */\n      /* COMMENT_2 */\n      close();\n      return false;\n    }\n    VAR_0 += VAR_2;\n\n    /* COMMENT_3 */\n    if (VAR_0.length() > size_t(VAR_4)) {\n      XmlRpcUtil::error(\"XmlRpcClient::readResponse: response length (%u) exceeds the maximum allowed size (%u).\",\n                        VAR_0.length(), VAR_4);\n      VAR_0.clear();\n      close();\n      return false;\n    }\n    /* COMMENT_4 */\n    if (int(VAR_0.length()) < VAR_1) {\n      if (VAR_3) {\n        XmlRpcUtil::error(\"Error in XmlRpcClient::readResponse: EOF while reading response\");\n        /* COMMENT_5 */\n        /* COMMENT_2 */\n        close();\n        return false;\n      }\n      return true;\n    }\n  }\n\n  /* COMMENT_6 */\n  XmlRpcUtil::log(3, \"XmlRpcClient::readResponse (read %d bytes)\", VAR_0.length());\n  XmlRpcUtil::log(5, \"response:\\n%s\", VAR_0.c_str());\n\n  VAR_5 = VAR_6;\n\n  return false;    /* COMMENT_7 */\n}",
  "func_graph_path": "ros/ros_comm/3dd308911d7294bc6cff12f626b8467fe1555423/XmlRpcClient.cpp/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -13,6 +13,14 @@\n     }\n     _response += buff;\n \n+    // Avoid an overly large response\n+    if (_response.length() > size_t(__INT_MAX__)) {\n+      XmlRpcUtil::error(\"XmlRpcClient::readResponse: response length (%u) exceeds the maximum allowed size (%u).\",\n+                        _response.length(), __INT_MAX__);\n+      _response.clear();\n+      close();\n+      return false;\n+    }\n     // If we haven't gotten the entire _response yet, return (keep reading)\n     if (int(_response.length()) < _contentLength) {\n       if (_eof) {",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "    // Avoid an overly large response",
      "    if (_response.length() > size_t(__INT_MAX__)) {",
      "      XmlRpcUtil::error(\"XmlRpcClient::readResponse: response length (%u) exceeds the maximum allowed size (%u).\",",
      "                        _response.length(), __INT_MAX__);",
      "      _response.clear();",
      "      close();",
      "      return false;",
      "    }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/ros/ros_comm/pull/2065",
  "description": {
    "pr_info": {
      "title": "Trap for overly large input to XmlRPCPP",
      "number": 2065
    },
    "comment": [
      "Oversize input to XmlRPCPP could cause problems with int <-> size_t conversions.\r\n\r\n - Recognize when incoming or outgoing data is too large, generate an error and discard the data when practical.\r\n - Use the safe strtol() rather than atoi() to decode an incoming content-length header and generate an error if the length is invalid or too large.\r\n - Prevent attempts to parse overly large XML input.\r\n - Add tests where they can reasonably be inserted into existing test routines.\r\n\r\nAlthough this fix could be cleaner the update is written to make the update ABI compatible.\r\n\r\nThis fix addresses CVE-2020-16124 / Integer overflow in ros_comm.\r\n\r\nSigned-off-by: Sid Faber <sid.faber@canonical.com>",
      "> Atm CI is failing for two tests though.\r\n\r\n@dirk-thomas, thanks for the review. The overrun tests I added are causing memory allocation failures--they work on my local machine but I assume the CI tests don't expect to be handling 2Gb input values. Any suggestions on how best to handle, is it advisable to remove the overrun tests?",
      "> Any suggestions on how best to handle, is it advisable to remove the overrun tests?\r\n\r\nCan the code be written in a way that it fails gracefully if that much memory isn't available? Maybe marking the test as skipped.",
      "Debian Buster only has Googletest 1.8.1 which doesn't have `GTEST_SKIP`.\r\n\r\nThe `readResponse_oversize` test still fails in CI.",
      "I removed GTEST_SKIP, printed an error message but otherwise let the test succeed. Also I removed one test that was causing problems. The test_client routines for readResponse still run when objects are finalized; since the test object could be in an unpredictable state I couldn't find a good way to ignore the results.",
      "> I removed GTEST_SKIP, printed an error message but otherwise let the test succeed.\r\n\r\nThat sounds like a good fall backback behavior. Can you make this conditional based on if `GTEST_SKIP` is available? If it is use it to give better feedback, otherwise fall back to the error message / succeed.",
      "@dirk-thomas, I added the conditional statement in one of the tests but had to rip another one out--the Ubuntu tests started running long and got killed causing the whole module to fail. I think this is as good as I can get it unless you have any ideas on how to safely & consistently write tests for huge input strings.",
      "Sounds good to me. Thanks for the patch and for iterating on it."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}