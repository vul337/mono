{
  "cve_id": "CVE-2019-3878",
  "cwe_ids": [
    "CWE-287"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "Uninett/mod_auth_mellon",
  "commit_msg": "Modify am_handler setup to run before mod_proxy\n\nThe way the ECP flow works is that when a client initiates the flow, the\nSP's response is HTTP 200, but not the requested content, but a signed XML\ndocument that contains the \"samlp:AuthnRequest\" element. The idea is that\nthe ECP client would then determine the IDP and send the document to the\nIDP, get a samlp:Response and convey that to the SP to get access to the\nprotected resource.\n\nInternally, the auth check which is normally done with am_check_uid() set to\napache's ap_hook_check_user_id() hook, just responds with OK, so it pretends\nto authenticate the user. Then in the usual flow, the request reaches the\nap_hook_handler which handles the request. There in the pipeline, mellon\nregisters functions am_handler() which should run first (APR_HOOK_FIRST),\ndetermine that this request is an ECP one and return the ECP AuthnRequest\ndocument. But in case the proxy module is also in the picture, the proxy\nmodule \"races\" for who gets to be the first to handle the request in the\npipeline and wins. Therefore, the request reaches the protected resource\nvia mod_proxy and returns it.\n\nThis fix modifies the ap_hook_handler() call to explicitly run before\nhandlers from mod_proxy.c\n\nTo reproduce the bug:\n0) Have a SP with mellon connected to a Keycloak IDP (or any other IDP I\n   guess). In the example below, my SAML SP is saml.federation.test\n1) Set a Location protected by mellon that proxies requests to another\n   URL. For example:\n\n    ProxyPass         /sp-proxy  http://app.federation.test/example_app/\n    <Location /sp-proxy>\n        AuthType Mellon\n        MellonEnable auth\n        Require valid-user\n    </Location>\n\n2) call:\n curl -L -H \"Accept: application/vnd.paos+xml\" \\\n         -H 'PAOS: ver=\"urn:liberty:paos:2003-08\";\"urn:oasis:names:tc:SAML:2.0:profiles:SSO:ecp\"' \\\n          http://saml.federation.test/sp-proxy\n\nBefore the patch, you would see whatever is served from the proxied\npage. With the patch, you should get back a XML document with a\nsamlp:AuthnRequest.",
  "commit_hash": "e09a28a30e13e5c22b481010f26b4a7743a09280",
  "git_url": "https://github.com/Uninett/mod_auth_mellon/commit/e09a28a30e13e5c22b481010f26b4a7743a09280",
  "file_path": "mod_auth_mellon.c",
  "func_name": "register_hooks",
  "func_before": "static void register_hooks(apr_pool_t *p)\n{\n    ap_hook_access_checker(am_auth_mellon_user, NULL, NULL, APR_HOOK_MIDDLE);\n    ap_hook_check_user_id(am_check_uid, NULL, NULL, APR_HOOK_MIDDLE);\n    ap_hook_post_config(am_global_init, NULL, NULL, APR_HOOK_MIDDLE);\n    ap_hook_child_init(am_child_init, NULL, NULL, APR_HOOK_MIDDLE);\n    ap_hook_create_request(am_create_request, NULL, NULL, APR_HOOK_MIDDLE);\n\n    /* Add the hook to handle requests to the mod_auth_mellon endpoint.\n     *\n     * This is APR_HOOK_FIRST because we do not expect nor require users\n     * to add a SetHandler option for the endpoint. Instead, simply\n     * setting MellonEndpointPath should be enough.\n     *\n     * Therefore this hook must run before any handler that may check\n     * r->handler and decide that it is the only handler for this URL.\n     */\n    ap_hook_handler(am_handler, NULL, NULL, APR_HOOK_FIRST);\n\n#ifdef ENABLE_DIAGNOSTICS\n    ap_hook_open_logs(am_diag_log_init,NULL,NULL,APR_HOOK_MIDDLE);\n    ap_hook_log_transaction(am_diag_finalize_request,NULL,NULL,APR_HOOK_REALLY_LAST);\n#endif\n}",
  "abstract_func_before": "static void register_hooks(apr_pool_t *VAR_0)\n{\n    ap_hook_access_checker(VAR_1, NULL, NULL, VAR_2);\n    ap_hook_check_user_id(VAR_3, NULL, NULL, VAR_2);\n    ap_hook_post_config(VAR_4, NULL, NULL, VAR_2);\n    ap_hook_child_init(VAR_5, NULL, NULL, VAR_2);\n    ap_hook_create_request(VAR_6, NULL, NULL, VAR_2);\n\n    /* COMMENT_0 */\n      \n                                                                        \n                                                                   \n                                                   \n      \n                                                                     \n                                                                      \n       \n    ap_hook_handler(VAR_7, NULL, NULL, VAR_8);\n\n#ifdef VAR_9\n    ap_hook_open_logs(VAR_10,NULL,NULL,VAR_2);\n    ap_hook_log_transaction(VAR_11,NULL,NULL,VAR_12);\n#endif\n}",
  "func_graph_path_before": "Uninett/mod_auth_mellon/e09a28a30e13e5c22b481010f26b4a7743a09280/mod_auth_mellon.c/vul/before/0.json",
  "func": "static void register_hooks(apr_pool_t *p)\n{\n    /* Our handler needs to run before mod_proxy so that it can properly\n     * return ECP AuthnRequest messages when running as a reverse proxy.\n     * See: https://github.com/Uninett/mod_auth_mellon/pull/196\n     */\n    static const char * const run_handler_before[]={ \"mod_proxy.c\", NULL };\n\n    ap_hook_access_checker(am_auth_mellon_user, NULL, NULL, APR_HOOK_MIDDLE);\n    ap_hook_check_user_id(am_check_uid, NULL, NULL, APR_HOOK_MIDDLE);\n    ap_hook_post_config(am_global_init, NULL, NULL, APR_HOOK_MIDDLE);\n    ap_hook_child_init(am_child_init, NULL, NULL, APR_HOOK_MIDDLE);\n    ap_hook_create_request(am_create_request, NULL, NULL, APR_HOOK_MIDDLE);\n\n    /* Add the hook to handle requests to the mod_auth_mellon endpoint.\n     *\n     * This is APR_HOOK_FIRST because we do not expect nor require users\n     * to add a SetHandler option for the endpoint. Instead, simply\n     * setting MellonEndpointPath should be enough.\n     *\n     * Therefore this hook must run before any handler that may check\n     * r->handler and decide that it is the only handler for this URL.\n     */\n    ap_hook_handler(am_handler, NULL, run_handler_before, APR_HOOK_FIRST);\n\n#ifdef ENABLE_DIAGNOSTICS\n    ap_hook_open_logs(am_diag_log_init,NULL,NULL,APR_HOOK_MIDDLE);\n    ap_hook_log_transaction(am_diag_finalize_request,NULL,NULL,APR_HOOK_REALLY_LAST);\n#endif\n}",
  "abstract_func": "static void register_hooks(apr_pool_t *VAR_0)\n{\n    /* COMMENT_0 */\n                                                                        \n                                                               \n       \n    static const char * const VAR_1[]={ \"mod_proxy.c\", NULL };\n\n    ap_hook_access_checker(VAR_2, NULL, NULL, VAR_3);\n    ap_hook_check_user_id(VAR_4, NULL, NULL, VAR_3);\n    ap_hook_post_config(VAR_5, NULL, NULL, VAR_3);\n    ap_hook_child_init(VAR_6, NULL, NULL, VAR_3);\n    ap_hook_create_request(VAR_7, NULL, NULL, VAR_3);\n\n    /* COMMENT_4 */\n      \n                                                                        \n                                                                   \n                                                   \n      \n                                                                     \n                                                                      \n       \n    ap_hook_handler(VAR_8, NULL, VAR_1, VAR_9);\n\n#ifdef VAR_10\n    ap_hook_open_logs(VAR_11,NULL,NULL,VAR_3);\n    ap_hook_log_transaction(VAR_12,NULL,NULL,VAR_13);\n#endif\n}",
  "func_graph_path": "Uninett/mod_auth_mellon/e09a28a30e13e5c22b481010f26b4a7743a09280/mod_auth_mellon.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,11 @@\n static void register_hooks(apr_pool_t *p)\n {\n+    /* Our handler needs to run before mod_proxy so that it can properly\n+     * return ECP AuthnRequest messages when running as a reverse proxy.\n+     * See: https://github.com/Uninett/mod_auth_mellon/pull/196\n+     */\n+    static const char * const run_handler_before[]={ \"mod_proxy.c\", NULL };\n+\n     ap_hook_access_checker(am_auth_mellon_user, NULL, NULL, APR_HOOK_MIDDLE);\n     ap_hook_check_user_id(am_check_uid, NULL, NULL, APR_HOOK_MIDDLE);\n     ap_hook_post_config(am_global_init, NULL, NULL, APR_HOOK_MIDDLE);\n@@ -15,7 +21,7 @@\n      * Therefore this hook must run before any handler that may check\n      * r->handler and decide that it is the only handler for this URL.\n      */\n-    ap_hook_handler(am_handler, NULL, NULL, APR_HOOK_FIRST);\n+    ap_hook_handler(am_handler, NULL, run_handler_before, APR_HOOK_FIRST);\n \n #ifdef ENABLE_DIAGNOSTICS\n     ap_hook_open_logs(am_diag_log_init,NULL,NULL,APR_HOOK_MIDDLE);",
  "diff_line_info": {
    "deleted_lines": [
      "    ap_hook_handler(am_handler, NULL, NULL, APR_HOOK_FIRST);"
    ],
    "added_lines": [
      "    /* Our handler needs to run before mod_proxy so that it can properly",
      "     * return ECP AuthnRequest messages when running as a reverse proxy.",
      "     * See: https://github.com/Uninett/mod_auth_mellon/pull/196",
      "     */",
      "    static const char * const run_handler_before[]={ \"mod_proxy.c\", NULL };",
      "",
      "    ap_hook_handler(am_handler, NULL, run_handler_before, APR_HOOK_FIRST);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/Uninett/mod_auth_mellon/pull/196",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/Uninett/mod_auth_mellon/pull/196: 403 Client Error: Forbidden for url: https://api.github.com/repos/Uninett/mod_auth_mellon/pulls/196",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.9  \n\nThe patch addresses a functional bug in the ECP flow, ensuring proper handler execution order without security implications, thus it's a non-security defect fix. High confidence due to clear context and code purpose."
}