{
  "cve_id": "CVE-2014-7203",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "zeromq/libzmq",
  "commit_msg": "Problem: curve messages can be replayed\n\nSolution: ensure message short nonces are strictly increasing and validate them",
  "commit_hash": "0900a489213d74feb86fc0b343308fe7884a2a3c",
  "git_url": "https://github.com/zeromq/libzmq/commit/0900a489213d74feb86fc0b343308fe7884a2a3c",
  "file_path": "src/curve_server.cpp",
  "func_name": "zmq::curve_server_t::curve_server_t",
  "func_before": "zmq::curve_server_t::curve_server_t (session_base_t *session_,\n                                     const std::string &peer_address_,\n                                     const options_t &options_) :\n    mechanism_t (options_),\n    session (session_),\n    peer_address (peer_address_),\n    state (expect_hello),\n    cn_nonce (1),\n    sync()\n{\n    //  Fetch our secret key from socket options\n    memcpy (secret_key, options_.curve_secret_key, crypto_box_SECRETKEYBYTES);\n    scoped_lock_t lock (sync);\n#if defined(HAVE_TWEETNACL)\n    // allow opening of /dev/urandom\n    unsigned char tmpbytes[4];\n    randombytes(tmpbytes, 4);\n#else\n    // todo check return code\n    sodium_init();\n#endif\n\n    //  Generate short-term key pair\n    const int rc = crypto_box_keypair (cn_public, cn_secret);\n    zmq_assert (rc == 0);\n}",
  "abstract_func_before": "zmq::curve_server_t::curve_server_t (session_base_t *VAR_0,\n                                     const std::string &VAR_1,\n                                     const options_t &VAR_2) :\n    mechanism_t (VAR_2),\n    session (VAR_0),\n    peer_address (VAR_1),\n    state (VAR_3),\n    cn_nonce (1),\n    sync()\n{\n    /* COMMENT_0 */\n    memcpy (VAR_4, VAR_2.curve_secret_key, VAR_5);\n    scoped_lock_t lock (sync);\n#if defined(VAR_6)\n    /* COMMENT_1 */\n    unsigned char VAR_7[4];\n    randombytes(VAR_7, 4);\n#else\n    /* COMMENT_2 */\n    sodium_init();\n#endif\n\n    /* COMMENT_3 */\n    const int VAR_8 = crypto_box_keypair (VAR_9, VAR_10);\n    zmq_assert (VAR_8 == 0);\n}",
  "func_graph_path_before": "zeromq/libzmq/0900a489213d74feb86fc0b343308fe7884a2a3c/curve_server.cpp/vul/before/0.json",
  "func": "zmq::curve_server_t::curve_server_t (session_base_t *session_,\n                                     const std::string &peer_address_,\n                                     const options_t &options_) :\n    mechanism_t (options_),\n    session (session_),\n    peer_address (peer_address_),\n    state (expect_hello),\n    cn_nonce (1),\n    cn_peer_nonce(1),\n    sync()\n{\n    //  Fetch our secret key from socket options\n    memcpy (secret_key, options_.curve_secret_key, crypto_box_SECRETKEYBYTES);\n    scoped_lock_t lock (sync);\n#if defined(HAVE_TWEETNACL)\n    // allow opening of /dev/urandom\n    unsigned char tmpbytes[4];\n    randombytes(tmpbytes, 4);\n#else\n    // todo check return code\n    sodium_init();\n#endif\n\n    //  Generate short-term key pair\n    const int rc = crypto_box_keypair (cn_public, cn_secret);\n    zmq_assert (rc == 0);\n}",
  "abstract_func": "zmq::curve_server_t::curve_server_t (session_base_t *VAR_0,\n                                     const std::string &VAR_1,\n                                     const options_t &VAR_2) :\n    mechanism_t (VAR_2),\n    session (VAR_0),\n    peer_address (VAR_1),\n    state (VAR_3),\n    cn_nonce (1),\n    cn_peer_nonce(1),\n    sync()\n{\n    /* COMMENT_0 */\n    memcpy (VAR_4, VAR_2.curve_secret_key, VAR_5);\n    scoped_lock_t lock (sync);\n#if defined(VAR_6)\n    /* COMMENT_1 */\n    unsigned char VAR_7[4];\n    randombytes(VAR_7, 4);\n#else\n    /* COMMENT_2 */\n    sodium_init();\n#endif\n\n    /* COMMENT_3 */\n    const int VAR_8 = crypto_box_keypair (VAR_9, VAR_10);\n    zmq_assert (VAR_8 == 0);\n}",
  "func_graph_path": "zeromq/libzmq/0900a489213d74feb86fc0b343308fe7884a2a3c/curve_server.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -6,6 +6,7 @@\n     peer_address (peer_address_),\n     state (expect_hello),\n     cn_nonce (1),\n+    cn_peer_nonce(1),\n     sync()\n {\n     //  Fetch our secret key from socket options",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "    cn_peer_nonce(1),"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/zeromq/libzmq/pull/1189",
  "description": {
    "pr_info": {
      "title": "Problem: curve messages can be replayed",
      "number": 1189
    },
    "comment": [
      "Solution: ensure message short nonces are strictly increasing and validate them\n",
      "Fixes #1191.\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95"
}