{
  "cve_id": "CVE-2020-15166",
  "cwe_ids": [
    "CWE-400"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "zeromq/libzmq",
  "commit_msg": "problem: zeromq connects peer before handshake is completed\n\nSolution: delay connecting the peer pipe until the handshake is completed",
  "commit_hash": "e7f0090b161ce6344f6bd35009816a925c070b09",
  "git_url": "https://github.com/zeromq/libzmq/commit/e7f0090b161ce6344f6bd35009816a925c070b09",
  "file_path": "src/zmtp_engine.cpp",
  "func_name": "zmq::zmtp_engine_t::zmtp_engine_t",
  "func_before": "zmq::zmtp_engine_t::zmtp_engine_t (\n  fd_t fd_,\n  const options_t &options_,\n  const endpoint_uri_pair_t &endpoint_uri_pair_) :\n    stream_engine_base_t (fd_, options_, endpoint_uri_pair_),\n    _greeting_size (v2_greeting_size),\n    _greeting_bytes_read (0),\n    _subscription_required (false),\n    _heartbeat_timeout (0)\n{\n    _next_msg = static_cast<int (stream_engine_base_t::*) (msg_t *)> (\n      &zmtp_engine_t::routing_id_msg);\n    _process_msg = static_cast<int (stream_engine_base_t::*) (msg_t *)> (\n      &zmtp_engine_t::process_routing_id_msg);\n\n    int rc = _pong_msg.init ();\n    errno_assert (rc == 0);\n\n    rc = _routing_id_msg.init ();\n    errno_assert (rc == 0);\n\n    if (_options.heartbeat_interval > 0) {\n        _heartbeat_timeout = _options.heartbeat_timeout;\n        if (_heartbeat_timeout == -1)\n            _heartbeat_timeout = _options.heartbeat_interval;\n    }\n}\n\nzmq::zmtp_engine_t::~zmtp_engine_t ()\n{\n    const int rc = _routing_id_msg.close ();\n    errno_assert (rc == 0);\n}\n\nvoid zmq::zmtp_engine_t::plug_internal ()\n{\n    // start optional timer, to prevent handshake hanging on no input\n    set_handshake_timer ();\n\n    //  Send the 'length' and 'flags' fields of the routing id message.\n    //  The 'length' field is encoded in the long format.\n    _outpos = _greeting_send;\n    _outpos[_outsize++] = UCHAR_MAX;\n    put_uint64 (&_outpos[_outsize], _options.routing_id_size + 1);\n    _outsize += 8;\n    _outpos[_outsize++] = 0x7f;\n\n    set_pollin ();\n    set_pollout ();\n    //  Flush all the data that may have been already received downstream.\n    in_event ();\n}\n\n//  Position of the revision and minor fields in the greeting.\nconst size_t revision_pos = 10;\nconst size_t minor_pos = 11;\n\nbool zmq::zmtp_engine_t::handshake ()\n{\n    zmq_assert (_greeting_bytes_read < _greeting_size);\n    //  Receive the greeting.\n    const int rc = receive_greeting ();\n    if (rc == -1)\n        return false;\n    const bool unversioned = rc != 0;\n\n    if (!(this\n            ->*select_handshake_fun (unversioned, _greeting_recv[revision_pos],\n                                     _greeting_recv[minor_pos])) ())\n        return false;\n\n    // Start polling for output if necessary.\n    if (_outsize == 0)\n        set_pollout ();\n\n    if (_has_handshake_timer) {\n        cancel_timer (handshake_timer_id);\n        _has_handshake_timer = false;\n    }\n\n    return true;\n}\n\nint zmq::zmtp_engine_t::receive_greeting ()\n{\n    bool unversioned = false;\n    while (_greeting_bytes_read < _greeting_size) {\n        const int n = read (_greeting_recv + _greeting_bytes_read,\n                            _greeting_size - _greeting_bytes_read);\n        if (n == -1) {\n            if (errno != EAGAIN)\n                error (connection_error);\n            return -1;\n        }\n\n        _greeting_bytes_read += n;\n\n        //  We have received at least one byte from the peer.\n        //  If the first byte is not 0xff, we know that the\n        //  peer is using unversioned protocol.\n        if (_greeting_recv[0] != 0xff) {\n            unversioned = true;\n            break;\n        }\n\n        if (_greeting_bytes_read < signature_size)\n            continue;\n\n        //  Inspect the right-most bit of the 10th byte (which coincides\n        //  with the 'flags' field if a regular message was sent).\n        //  Zero indicates this is a header of a routing id message\n        //  (i.e. the peer is using the unversioned protocol).\n        if (!(_greeting_recv[9] & 0x01)) {\n            unversioned = true;\n            break;\n        }\n\n        //  The peer is using versioned protocol.\n        receive_greeting_versioned ();\n    }\n    return unversioned ? 1 : 0;\n}\n\nvoid zmq::zmtp_engine_t::receive_greeting_versioned ()\n{\n    //  Send the major version number.\n    if (_outpos + _outsize == _greeting_send + signature_size) {\n        if (_outsize == 0)\n            set_pollout ();\n        _outpos[_outsize++] = 3; //  Major version number\n    }\n\n    if (_greeting_bytes_read > signature_size) {\n        if (_outpos + _outsize == _greeting_send + signature_size + 1) {\n            if (_outsize == 0)\n                set_pollout ();\n\n            //  Use ZMTP/2.0 to talk to older peers.\n            if (_greeting_recv[revision_pos] == ZMTP_1_0\n                || _greeting_recv[revision_pos] == ZMTP_2_0)\n                _outpos[_outsize++] = _options.type;\n            else {\n                _outpos[_outsize++] = 1; //  Minor version number\n                memset (_outpos + _outsize, 0, 20);\n\n                zmq_assert (_options.mechanism == ZMQ_NULL\n                            || _options.mechanism == ZMQ_PLAIN\n                            || _options.mechanism == ZMQ_CURVE\n                            || _options.mechanism == ZMQ_GSSAPI);\n\n                if (_options.mechanism == ZMQ_NULL)\n                    memcpy (_outpos + _outsize, \"NULL\", 4);\n                else if (_options.mechanism == ZMQ_PLAIN)\n                    memcpy (_outpos + _outsize, \"PLAIN\", 5);\n                else if (_options.mechanism == ZMQ_GSSAPI)\n                    memcpy (_outpos + _outsize, \"GSSAPI\", 6);\n                else if (_options.mechanism == ZMQ_CURVE)\n                    memcpy (_outpos + _outsize, \"CURVE\", 5);\n                _outsize += 20;\n                memset (_outpos + _outsize, 0, 32);\n                _outsize += 32;\n                _greeting_size = v3_greeting_size;\n            }\n        }\n    }\n}\n\nzmq::zmtp_engine_t::handshake_fun_t zmq::zmtp_engine_t::select_handshake_fun (\n  bool unversioned_, unsigned char revision_, unsigned char minor_)\n{\n    //  Is the peer using ZMTP/1.0 with no revision number?\n    if (unversioned_) {\n        return &zmtp_engine_t::handshake_v1_0_unversioned;\n    }\n    switch (revision_) {\n        case ZMTP_1_0:\n            return &zmtp_engine_t::handshake_v1_0;\n        case ZMTP_2_0:\n            return &zmtp_engine_t::handshake_v2_0;\n        case ZMTP_3_x:\n            switch (minor_) {\n                case 0:\n                    return &zmtp_engine_t::handshake_v3_0;\n                default:\n                    return &zmtp_engine_t::handshake_v3_1;\n            }\n        default:\n            return &zmtp_engine_t::handshake_v3_1;\n    }\n}",
  "abstract_func_before": "zmq::zmtp_engine_t::zmtp_engine_t (\n  fd_t VAR_0,\n  const options_t &VAR_1,\n  const endpoint_uri_pair_t &VAR_2) :\n    stream_engine_base_t (VAR_0, VAR_1, VAR_2),\n    _greeting_size (VAR_3),\n    _greeting_bytes_read (0),\n    _subscription_required (false),\n    _heartbeat_timeout (0)\n{\n    VAR_4 = static_cast<int (stream_engine_base_t::*) (msg_t *)> (\n      &zmtp_engine_t::routing_id_msg);\n    VAR_5 = static_cast<int (stream_engine_base_t::*) (msg_t *)> (\n      &zmtp_engine_t::process_routing_id_msg);\n\n    int VAR_6 = VAR_7.init ();\n    errno_assert (VAR_6 == 0);\n\n    VAR_6 = VAR_8.init ();\n    errno_assert (VAR_6 == 0);\n\n    if (VAR_9.heartbeat_interval > 0) {\n        VAR_10 = VAR_9.heartbeat_timeout;\n        if (VAR_10 == -1)\n            VAR_10 = VAR_9.heartbeat_interval;\n    }\n}\n\nzmq::zmtp_engine_t::~VAR_11 ()\n{\n    VAR_12 int VAR_6 = VAR_8.close ();\n    errno_assert (VAR_6 == 0);\n}\n\nVAR_13 zmq::zmtp_engine_t::plug_internal ()\n{\n    /* COMMENT_0 */\n    set_handshake_timer ();\n\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n    VAR_14 = VAR_15;\n    VAR_14[VAR_16++] = VAR_17;\n    put_uint64 (&VAR_14[VAR_16], VAR_9.routing_id_size + 1);\n    VAR_16 += 8;\n    VAR_14[VAR_16++] = 0x7f;\n\n    set_pollin ();\n    set_pollout ();\n    /* COMMENT_3 */\n    in_event ();\n}\n\n/* COMMENT_4 */\nVAR_12 size_t VAR_18 = 10;\nconst size_t VAR_19 = 11;\n\nbool VAR_20::VAR_11::VAR_21 ()\n{\n    zmq_assert (VAR_22 < VAR_23);\n    /* COMMENT_5 */\n    const int VAR_6 = receive_greeting ();\n    if (VAR_6 == -1)\n        return false;\n    const bool VAR_24 = VAR_6 != 0;\n\n    if (!(this\n            ->*VAR_25 (VAR_24, VAR_26[VAR_18],\n                                     VAR_26[VAR_19])) ())\n        return false;\n\n    /* COMMENT_6 */\n    if (VAR_16 == 0)\n        set_pollout ();\n\n    if (VAR_27) {\n        cancel_timer (VAR_28);\n        VAR_27 = false;\n    }\n\n    return true;\n}\n\nint VAR_20::VAR_11::VAR_29 ()\n{\n    bool VAR_24 = false;\n    while (VAR_22 < VAR_23) {\n        VAR_12 int VAR_30 = read (VAR_26 + VAR_22,\n                            VAR_23 - VAR_22);\n        if (VAR_30 == -1) {\n            if (VAR_31 != VAR_32)\n                VAR_33 (VAR_34);\n            return -1;\n        }\n\n        VAR_22 += VAR_30;\n\n        /* COMMENT_7 */\n        /* COMMENT_8 */\n        /* COMMENT_9 */\n        if (VAR_26[0] != 0xff) {\n            VAR_24 = true;\n            break;\n        }\n\n        if (VAR_22 < VAR_35)\n            continue;\n\n        /* COMMENT_10 */\n        /* COMMENT_11 */\n        /* COMMENT_12 */\n        /* COMMENT_13 */\n        if (!(VAR_26[9] & 0x01)) {\n            VAR_24 = true;\n            break;\n        }\n\n        /* COMMENT_14 */\n        VAR_36 ();\n    }\n    return VAR_24 ? 1 : 0;\n}\n\nvoid VAR_20::VAR_11::VAR_36 ()\n{\n    /* COMMENT_15 */\n    if (VAR_14 + VAR_16 == VAR_15 + VAR_35) {\n        if (VAR_16 == 0)\n            VAR_37 ();\n        VAR_14[VAR_16++] = 3; /* COMMENT_16 */\n    }\n\n    if (VAR_22 > VAR_35) {\n        if (VAR_14 + VAR_16 == VAR_15 + VAR_35 + 1) {\n            if (VAR_16 == 0)\n                VAR_37 ();\n\n            /* COMMENT_17 */\n            if (VAR_26[VAR_18] == VAR_38\n                || VAR_26[VAR_18] == VAR_39)\n                VAR_14[VAR_16++] = VAR_9.type;\n            else {\n                VAR_14[VAR_16++] = 1; /* COMMENT_18 */\n                VAR_40 (VAR_14 + VAR_16, 0, 20);\n\n                VAR_41 (VAR_9.mechanism == VAR_42\n                            || VAR_9.mechanism == VAR_43\n                            || VAR_9.mechanism == VAR_44\n                            || VAR_9.mechanism == VAR_45);\n\n                if (VAR_9.mechanism == VAR_42)\n                    VAR_46 (VAR_14 + VAR_16, \"NULL\", 4);\n                else if (VAR_9.mechanism == VAR_43)\n                    VAR_46 (VAR_14 + VAR_16, \"PLAIN\", 5);\n                else if (VAR_9.mechanism == VAR_45)\n                    VAR_46 (VAR_14 + VAR_16, \"GSSAPI\", 6);\n                else if (VAR_9.mechanism == VAR_44)\n                    VAR_46 (VAR_14 + VAR_16, \"CURVE\", 5);\n                VAR_16 += 20;\n                VAR_40 (VAR_14 + VAR_16, 0, 32);\n                VAR_16 += 32;\n                VAR_23 = VAR_47;\n            }\n        }\n    }\n}\n\nVAR_20::VAR_11::VAR_48 VAR_20::VAR_11::VAR_25 (\n  bool VAR_49, unsigned VAR_50 VAR_51, unsigned VAR_50 VAR_52)\n{\n    /* COMMENT_19 */\n    if (VAR_49) {\n        return &zmtp_engine_t::handshake_v1_0_unversioned;\n    }\n    switch (revision_) {\n        case VAR_38:\n            return &zmtp_engine_t::handshake_v1_0;\n        case VAR_39:\n            return &zmtp_engine_t::handshake_v2_0;\n        case VAR_53:\n            switch (VAR_52) {\n                case 0:\n                    return &zmtp_engine_t::handshake_v3_0;\n                default:\n                    return &zmtp_engine_t::handshake_v3_1;\n            }\n        default:\n            return &zmtp_engine_t::handshake_v3_1;\n    }\n}",
  "func_graph_path_before": "zeromq/libzmq/e7f0090b161ce6344f6bd35009816a925c070b09/zmtp_engine.cpp/vul/before/0.json",
  "func": "zmq::zmtp_engine_t::zmtp_engine_t (\n  fd_t fd_,\n  const options_t &options_,\n  const endpoint_uri_pair_t &endpoint_uri_pair_) :\n    stream_engine_base_t (fd_, options_, endpoint_uri_pair_, true),\n    _greeting_size (v2_greeting_size),\n    _greeting_bytes_read (0),\n    _subscription_required (false),\n    _heartbeat_timeout (0)\n{\n    _next_msg = static_cast<int (stream_engine_base_t::*) (msg_t *)> (\n      &zmtp_engine_t::routing_id_msg);\n    _process_msg = static_cast<int (stream_engine_base_t::*) (msg_t *)> (\n      &zmtp_engine_t::process_routing_id_msg);\n\n    int rc = _pong_msg.init ();\n    errno_assert (rc == 0);\n\n    rc = _routing_id_msg.init ();\n    errno_assert (rc == 0);\n\n    if (_options.heartbeat_interval > 0) {\n        _heartbeat_timeout = _options.heartbeat_timeout;\n        if (_heartbeat_timeout == -1)\n            _heartbeat_timeout = _options.heartbeat_interval;\n    }\n}\n\nzmq::zmtp_engine_t::~zmtp_engine_t ()\n{\n    const int rc = _routing_id_msg.close ();\n    errno_assert (rc == 0);\n}\n\nvoid zmq::zmtp_engine_t::plug_internal ()\n{\n    // start optional timer, to prevent handshake hanging on no input\n    set_handshake_timer ();\n\n    //  Send the 'length' and 'flags' fields of the routing id message.\n    //  The 'length' field is encoded in the long format.\n    _outpos = _greeting_send;\n    _outpos[_outsize++] = UCHAR_MAX;\n    put_uint64 (&_outpos[_outsize], _options.routing_id_size + 1);\n    _outsize += 8;\n    _outpos[_outsize++] = 0x7f;\n\n    set_pollin ();\n    set_pollout ();\n    //  Flush all the data that may have been already received downstream.\n    in_event ();\n}\n\n//  Position of the revision and minor fields in the greeting.\nconst size_t revision_pos = 10;\nconst size_t minor_pos = 11;\n\nbool zmq::zmtp_engine_t::handshake ()\n{\n    zmq_assert (_greeting_bytes_read < _greeting_size);\n    //  Receive the greeting.\n    const int rc = receive_greeting ();\n    if (rc == -1)\n        return false;\n    const bool unversioned = rc != 0;\n\n    if (!(this\n            ->*select_handshake_fun (unversioned, _greeting_recv[revision_pos],\n                                     _greeting_recv[minor_pos])) ())\n        return false;\n\n    // Start polling for output if necessary.\n    if (_outsize == 0)\n        set_pollout ();\n\n    if (_has_handshake_timer) {\n        cancel_timer (handshake_timer_id);\n        _has_handshake_timer = false;\n    }\n\n    return true;\n}\n\nint zmq::zmtp_engine_t::receive_greeting ()\n{\n    bool unversioned = false;\n    while (_greeting_bytes_read < _greeting_size) {\n        const int n = read (_greeting_recv + _greeting_bytes_read,\n                            _greeting_size - _greeting_bytes_read);\n        if (n == -1) {\n            if (errno != EAGAIN)\n                error (connection_error);\n            return -1;\n        }\n\n        _greeting_bytes_read += n;\n\n        //  We have received at least one byte from the peer.\n        //  If the first byte is not 0xff, we know that the\n        //  peer is using unversioned protocol.\n        if (_greeting_recv[0] != 0xff) {\n            unversioned = true;\n            break;\n        }\n\n        if (_greeting_bytes_read < signature_size)\n            continue;\n\n        //  Inspect the right-most bit of the 10th byte (which coincides\n        //  with the 'flags' field if a regular message was sent).\n        //  Zero indicates this is a header of a routing id message\n        //  (i.e. the peer is using the unversioned protocol).\n        if (!(_greeting_recv[9] & 0x01)) {\n            unversioned = true;\n            break;\n        }\n\n        //  The peer is using versioned protocol.\n        receive_greeting_versioned ();\n    }\n    return unversioned ? 1 : 0;\n}\n\nvoid zmq::zmtp_engine_t::receive_greeting_versioned ()\n{\n    //  Send the major version number.\n    if (_outpos + _outsize == _greeting_send + signature_size) {\n        if (_outsize == 0)\n            set_pollout ();\n        _outpos[_outsize++] = 3; //  Major version number\n    }\n\n    if (_greeting_bytes_read > signature_size) {\n        if (_outpos + _outsize == _greeting_send + signature_size + 1) {\n            if (_outsize == 0)\n                set_pollout ();\n\n            //  Use ZMTP/2.0 to talk to older peers.\n            if (_greeting_recv[revision_pos] == ZMTP_1_0\n                || _greeting_recv[revision_pos] == ZMTP_2_0)\n                _outpos[_outsize++] = _options.type;\n            else {\n                _outpos[_outsize++] = 1; //  Minor version number\n                memset (_outpos + _outsize, 0, 20);\n\n                zmq_assert (_options.mechanism == ZMQ_NULL\n                            || _options.mechanism == ZMQ_PLAIN\n                            || _options.mechanism == ZMQ_CURVE\n                            || _options.mechanism == ZMQ_GSSAPI);\n\n                if (_options.mechanism == ZMQ_NULL)\n                    memcpy (_outpos + _outsize, \"NULL\", 4);\n                else if (_options.mechanism == ZMQ_PLAIN)\n                    memcpy (_outpos + _outsize, \"PLAIN\", 5);\n                else if (_options.mechanism == ZMQ_GSSAPI)\n                    memcpy (_outpos + _outsize, \"GSSAPI\", 6);\n                else if (_options.mechanism == ZMQ_CURVE)\n                    memcpy (_outpos + _outsize, \"CURVE\", 5);\n                _outsize += 20;\n                memset (_outpos + _outsize, 0, 32);\n                _outsize += 32;\n                _greeting_size = v3_greeting_size;\n            }\n        }\n    }\n}\n\nzmq::zmtp_engine_t::handshake_fun_t zmq::zmtp_engine_t::select_handshake_fun (\n  bool unversioned_, unsigned char revision_, unsigned char minor_)\n{\n    //  Is the peer using ZMTP/1.0 with no revision number?\n    if (unversioned_) {\n        return &zmtp_engine_t::handshake_v1_0_unversioned;\n    }\n    switch (revision_) {\n        case ZMTP_1_0:\n            return &zmtp_engine_t::handshake_v1_0;\n        case ZMTP_2_0:\n            return &zmtp_engine_t::handshake_v2_0;\n        case ZMTP_3_x:\n            switch (minor_) {\n                case 0:\n                    return &zmtp_engine_t::handshake_v3_0;\n                default:\n                    return &zmtp_engine_t::handshake_v3_1;\n            }\n        default:\n            return &zmtp_engine_t::handshake_v3_1;\n    }\n}",
  "abstract_func": "zmq::zmtp_engine_t::zmtp_engine_t (\n  fd_t VAR_0,\n  const options_t &VAR_1,\n  const endpoint_uri_pair_t &VAR_2) :\n    stream_engine_base_t (VAR_0, VAR_1, VAR_2, true),\n    _greeting_size (VAR_3),\n    _greeting_bytes_read (0),\n    _subscription_required (false),\n    _heartbeat_timeout (0)\n{\n    VAR_4 = static_cast<int (stream_engine_base_t::*) (msg_t *)> (\n      &zmtp_engine_t::routing_id_msg);\n    VAR_5 = static_cast<int (stream_engine_base_t::*) (msg_t *)> (\n      &zmtp_engine_t::process_routing_id_msg);\n\n    int VAR_6 = VAR_7.init ();\n    errno_assert (VAR_6 == 0);\n\n    VAR_6 = VAR_8.init ();\n    errno_assert (VAR_6 == 0);\n\n    if (VAR_9.heartbeat_interval > 0) {\n        VAR_10 = VAR_9.heartbeat_timeout;\n        if (VAR_10 == -1)\n            VAR_10 = VAR_9.heartbeat_interval;\n    }\n}\n\nzmq::zmtp_engine_t::~VAR_11 ()\n{\n    VAR_12 int VAR_6 = VAR_8.close ();\n    errno_assert (VAR_6 == 0);\n}\n\nVAR_13 zmq::zmtp_engine_t::plug_internal ()\n{\n    /* COMMENT_0 */\n    set_handshake_timer ();\n\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n    VAR_14 = VAR_15;\n    VAR_14[VAR_16++] = VAR_17;\n    put_uint64 (&VAR_14[VAR_16], VAR_9.routing_id_size + 1);\n    VAR_16 += 8;\n    VAR_14[VAR_16++] = 0x7f;\n\n    set_pollin ();\n    set_pollout ();\n    /* COMMENT_3 */\n    in_event ();\n}\n\n/* COMMENT_4 */\nVAR_12 size_t VAR_18 = 10;\nconst size_t VAR_19 = 11;\n\nbool VAR_20::VAR_11::VAR_21 ()\n{\n    zmq_assert (VAR_22 < VAR_23);\n    /* COMMENT_5 */\n    const int VAR_6 = receive_greeting ();\n    if (VAR_6 == -1)\n        return false;\n    const bool VAR_24 = VAR_6 != 0;\n\n    if (!(this\n            ->*VAR_25 (VAR_24, VAR_26[VAR_18],\n                                     VAR_26[VAR_19])) ())\n        return false;\n\n    /* COMMENT_6 */\n    if (VAR_16 == 0)\n        set_pollout ();\n\n    if (VAR_27) {\n        cancel_timer (VAR_28);\n        VAR_27 = false;\n    }\n\n    return true;\n}\n\nint VAR_20::VAR_11::VAR_29 ()\n{\n    bool VAR_24 = false;\n    while (VAR_22 < VAR_23) {\n        VAR_12 int VAR_30 = read (VAR_26 + VAR_22,\n                            VAR_23 - VAR_22);\n        if (VAR_30 == -1) {\n            if (VAR_31 != VAR_32)\n                VAR_33 (VAR_34);\n            return -1;\n        }\n\n        VAR_22 += VAR_30;\n\n        /* COMMENT_7 */\n        /* COMMENT_8 */\n        /* COMMENT_9 */\n        if (VAR_26[0] != 0xff) {\n            VAR_24 = true;\n            break;\n        }\n\n        if (VAR_22 < VAR_35)\n            continue;\n\n        /* COMMENT_10 */\n        /* COMMENT_11 */\n        /* COMMENT_12 */\n        /* COMMENT_13 */\n        if (!(VAR_26[9] & 0x01)) {\n            VAR_24 = true;\n            break;\n        }\n\n        /* COMMENT_14 */\n        VAR_36 ();\n    }\n    return VAR_24 ? 1 : 0;\n}\n\nvoid VAR_20::VAR_11::VAR_36 ()\n{\n    /* COMMENT_15 */\n    if (VAR_14 + VAR_16 == VAR_15 + VAR_35) {\n        if (VAR_16 == 0)\n            VAR_37 ();\n        VAR_14[VAR_16++] = 3; /* COMMENT_16 */\n    }\n\n    if (VAR_22 > VAR_35) {\n        if (VAR_14 + VAR_16 == VAR_15 + VAR_35 + 1) {\n            if (VAR_16 == 0)\n                VAR_37 ();\n\n            /* COMMENT_17 */\n            if (VAR_26[VAR_18] == VAR_38\n                || VAR_26[VAR_18] == VAR_39)\n                VAR_14[VAR_16++] = VAR_9.type;\n            else {\n                VAR_14[VAR_16++] = 1; /* COMMENT_18 */\n                VAR_40 (VAR_14 + VAR_16, 0, 20);\n\n                VAR_41 (VAR_9.mechanism == VAR_42\n                            || VAR_9.mechanism == VAR_43\n                            || VAR_9.mechanism == VAR_44\n                            || VAR_9.mechanism == VAR_45);\n\n                if (VAR_9.mechanism == VAR_42)\n                    VAR_46 (VAR_14 + VAR_16, \"NULL\", 4);\n                else if (VAR_9.mechanism == VAR_43)\n                    VAR_46 (VAR_14 + VAR_16, \"PLAIN\", 5);\n                else if (VAR_9.mechanism == VAR_45)\n                    VAR_46 (VAR_14 + VAR_16, \"GSSAPI\", 6);\n                else if (VAR_9.mechanism == VAR_44)\n                    VAR_46 (VAR_14 + VAR_16, \"CURVE\", 5);\n                VAR_16 += 20;\n                VAR_40 (VAR_14 + VAR_16, 0, 32);\n                VAR_16 += 32;\n                VAR_23 = VAR_47;\n            }\n        }\n    }\n}\n\nVAR_20::VAR_11::VAR_48 VAR_20::VAR_11::VAR_25 (\n  bool VAR_49, unsigned VAR_50 VAR_51, unsigned VAR_50 VAR_52)\n{\n    /* COMMENT_19 */\n    if (VAR_49) {\n        return &zmtp_engine_t::handshake_v1_0_unversioned;\n    }\n    switch (revision_) {\n        case VAR_38:\n            return &zmtp_engine_t::handshake_v1_0;\n        case VAR_39:\n            return &zmtp_engine_t::handshake_v2_0;\n        case VAR_53:\n            switch (VAR_52) {\n                case 0:\n                    return &zmtp_engine_t::handshake_v3_0;\n                default:\n                    return &zmtp_engine_t::handshake_v3_1;\n            }\n        default:\n            return &zmtp_engine_t::handshake_v3_1;\n    }\n}",
  "func_graph_path": "zeromq/libzmq/e7f0090b161ce6344f6bd35009816a925c070b09/zmtp_engine.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -2,7 +2,7 @@\n   fd_t fd_,\n   const options_t &options_,\n   const endpoint_uri_pair_t &endpoint_uri_pair_) :\n-    stream_engine_base_t (fd_, options_, endpoint_uri_pair_),\n+    stream_engine_base_t (fd_, options_, endpoint_uri_pair_, true),\n     _greeting_size (v2_greeting_size),\n     _greeting_bytes_read (0),\n     _subscription_required (false),",
  "diff_line_info": {
    "deleted_lines": [
      "    stream_engine_base_t (fd_, options_, endpoint_uri_pair_),"
    ],
    "added_lines": [
      "    stream_engine_base_t (fd_, options_, endpoint_uri_pair_, true),"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/zeromq/libzmq/pull/3913",
  "description": {
    "pr_info": {
      "title": "problem: zeromq connects peer before handshake is complete",
      "number": 3913
    },
    "comment": [
      "Solution: delay connecting the peer pipe until the handshake is complete",
      "@bluca PR is ready ",
      "Thanks!"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.8"
}