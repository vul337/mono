{
  "cve_id": "CVE-2020-26682",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "libass",
  "commit_msg": "outline: fix overflows in outline processing\n\nThis commit enforces strict invariant on ASS_Outline\nto contain point coordinates into predetermined range.\n\nFixes https://github.com/libass/libass/issues/431.",
  "commit_hash": "676f9dc5b52ef406c5527bdadbcb947f11392929",
  "git_url": "https://github.com/libass/libass/commit/676f9dc5b52ef406c5527bdadbcb947f11392929",
  "file_path": "libass/ass_outline.c",
  "func_name": "outline_add_point",
  "func_before": "bool outline_add_point(ASS_Outline *outline, ASS_Vector pt, char segment)\n{\n    if (outline->n_points >= outline->max_points) {\n        size_t new_size = 2 * outline->max_points;\n        if (!ASS_REALLOC_ARRAY(outline->points, new_size))\n            return false;\n        outline->max_points = new_size;\n    }\n    outline->points[outline->n_points] = pt;\n    outline->n_points++;\n\n    return !segment || outline_add_segment(outline, segment);\n}",
  "abstract_func_before": "bool outline_add_point(ASS_Outline *VAR_0, ASS_Vector VAR_1, char VAR_2)\n{\n    if (VAR_0->n_points >= VAR_0->max_points) {\n        size_t VAR_3 = 2 * VAR_0->max_points;\n        if (!ASS_REALLOC_ARRAY(VAR_0->points, VAR_3))\n            return false;\n        VAR_0->max_points = VAR_3;\n    }\n    VAR_0->points[VAR_0->n_points] = VAR_1;\n    VAR_0->n_points++;\n\n    return !VAR_2 || outline_add_segment(VAR_0, VAR_2);\n}",
  "func_graph_path_before": "libass/676f9dc5b52ef406c5527bdadbcb947f11392929/ass_outline.c/vul/before/0.json",
  "func": "bool outline_add_point(ASS_Outline *outline, ASS_Vector pt, char segment)\n{\n    if(abs(pt.x) > OUTLINE_MAX || abs(pt.y) > OUTLINE_MAX)\n        return false;\n\n    if (outline->n_points >= outline->max_points) {\n        size_t new_size = 2 * outline->max_points;\n        if (!ASS_REALLOC_ARRAY(outline->points, new_size))\n            return false;\n        outline->max_points = new_size;\n    }\n    outline->points[outline->n_points] = pt;\n    outline->n_points++;\n\n    return !segment || outline_add_segment(outline, segment);\n}",
  "abstract_func": "bool outline_add_point(ASS_Outline *VAR_0, ASS_Vector VAR_1, char VAR_2)\n{\n    if(abs(VAR_1.x) > VAR_3 || abs(VAR_1.y) > VAR_3)\n        return false;\n\n    if (VAR_0->n_points >= VAR_0->max_points) {\n        size_t VAR_4 = 2 * VAR_0->max_points;\n        if (!ASS_REALLOC_ARRAY(VAR_0->points, VAR_4))\n            return false;\n        VAR_0->max_points = VAR_4;\n    }\n    VAR_0->points[VAR_0->n_points] = VAR_1;\n    VAR_0->n_points++;\n\n    return !VAR_2 || outline_add_segment(VAR_0, VAR_2);\n}",
  "func_graph_path": "libass/676f9dc5b52ef406c5527bdadbcb947f11392929/ass_outline.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,8 @@\n bool outline_add_point(ASS_Outline *outline, ASS_Vector pt, char segment)\n {\n+    if(abs(pt.x) > OUTLINE_MAX || abs(pt.y) > OUTLINE_MAX)\n+        return false;\n+\n     if (outline->n_points >= outline->max_points) {\n         size_t new_size = 2 * outline->max_points;\n         if (!ASS_REALLOC_ARRAY(outline->points, new_size))",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "    if(abs(pt.x) > OUTLINE_MAX || abs(pt.y) > OUTLINE_MAX)",
      "        return false;",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libass/libass/pull/432",
  "description": {
    "pr_info": {
      "title": "Fix overflows in outline processing",
      "number": 432
    },
    "comment": [
      "I've added a couple of checks for overflows in outline pipeline. Should fix #431, but I'm not familiar with that fuzzing business so I can't ascertain it for now.",
      "Can confirm that this fixes #431. \r\n\r\nOverflow checks seem fine to me. *(Assuming `abs(OUTLINE_MAX) < abs(OUTLINE_MIN)` will stay true in future version, which it probably will, I guess)*",
      "> Assuming `abs(OUTLINE_MAX) < abs(OUTLINE_MIN)` will stay true in future version, which it probably will, I guess\r\n\r\nMaybe it's even better to get rid of `OUTLINE_MIN` altogether and use `-OUTLINE_MAX` instead.",
      "New, more strict version. `max(abs(x), abs(y)) <= OUTLINE_MAX` is now enforced invariant of `ASS_Outline` instead of some ad hoc check. Also I've got rid of `OUTLINE_MIN`.",
      "@MrSmile \r\n\r\n```\r\nass_outline.c:53:12: warning: absolute value function 'abs' given an argument of type 'const FT_Pos' (aka 'const long') but has parameter of type 'int' which may cause truncation of value [-Wabsolute-value]\r\n    return abs(pt->x) <= OUTLINE_MAX && abs(pt->y) <= OUTLINE_MAX;\r\n           ^\r\nass_outline.c:53:12: note: use function 'labs' instead\r\n    return abs(pt->x) <= OUTLINE_MAX && abs(pt->y) <= OUTLINE_MAX;\r\n           ^~~\r\n           labs\r\nass_outline.c:53:41: warning: absolute value function 'abs' given an argument of type 'const FT_Pos' (aka 'const long') but has parameter of type 'int' which may cause truncation of value [-Wabsolute-value]\r\n    return abs(pt->x) <= OUTLINE_MAX && abs(pt->y) <= OUTLINE_MAX;\r\n                                        ^\r\nass_outline.c:53:41: note: use function 'labs' instead\r\n    return abs(pt->x) <= OUTLINE_MAX && abs(pt->y) <= OUTLINE_MAX;\r\n                                        ^~~\r\n                                        labs\r\n```",
      "FT docs specify that `FT_Pos` is 16.16 or 26.6 fixed-point representation, so I'm not sure what's better, to cast into `int32_t` or use `labs` here.",
      "Just use `labs`. In a way, this will also serve as a sanity check to ensure the FT docs arenâ€™t lying."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}