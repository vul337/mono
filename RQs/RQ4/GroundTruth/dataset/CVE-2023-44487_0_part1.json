{
  "cve_id": "CVE-2023-44487",
  "cwe_ids": [
    "CWE-400"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "line/armeria",
  "commit_msg": "Limit max reset frames to mitigate HTTP/2 RST floods\n\nMotivation:\n\nTo mitigate against the \"HTTP/2 Rapid Reset\" attack, it is recommended\nthat HTTP/2 servers should close connections that exceed the concurrent\nstream limit.\n\nReference:\n\n- https://blog.cloudflare.com/technical-breakdown-http2-rapid-reset-ddos-attack/\n- https://www.cve.org/CVERecord?id=CVE-2023-44487\n- https://github.com/netty/netty/commit/58f75f665aa81a8cbcf6ffa74820042a285c5e61#diff-82f568a075ff63e9727ce8622f3a2b1553099182edf1fd0b4f857226252b05adR47\n\nModifications:\n\n- Add `ServerBuilder.http2MaxRestFramesPerWindow()` option\n  `-Dcom.linecorp.armeria.defaultHttp2MaxResetFramesPerMinute<integer>`\n  property to limit the maximum allowed RST frames.\n  - If not set, 400 RST frames per minute are alllowed by default.\n- Bump Netty version to 4.1.100 from 4.1.96\n\nResult:\n\nYou can now protect your server against DDOS caused by RST floods.\n```java\nServer\n  .builder()\n  .http2MaxResetFramesPerWindow(100, 10)\n  .build();\n```",
  "commit_hash": "df7f85824a62e997b910b5d6194a3335841065fd",
  "git_url": "https://github.com/line/armeria/commit/df7f85824a62e997b910b5d6194a3335841065fd",
  "file_path": "core/src/main/java/com/linecorp/armeria/server/ServerBuilder.java",
  "func_name": "buildServerConfig",
  "func_before": "private DefaultServerConfig buildServerConfig(List<ServerPort> serverPorts) {\n        final AnnotatedServiceExtensions extensions =\n                virtualHostTemplate.annotatedServiceExtensions();\n        assert extensions != null;\n        final DependencyInjector dependencyInjector = dependencyInjectorOrReflective();\n\n        final UnhandledExceptionsReporter unhandledExceptionsReporter;\n        if (unhandledExceptionsReportIntervalMillis > 0) {\n            unhandledExceptionsReporter = UnhandledExceptionsReporter.of(\n                    meterRegistry, unhandledExceptionsReportIntervalMillis);\n            serverListeners.add(unhandledExceptionsReporter);\n        } else {\n            unhandledExceptionsReporter = null;\n        }\n\n        final VirtualHost defaultVirtualHost =\n                defaultVirtualHostBuilder.build(virtualHostTemplate, dependencyInjector,\n                                                unhandledExceptionsReporter);\n        final List<VirtualHost> virtualHosts =\n                virtualHostBuilders.stream()\n                                   .map(vhb -> vhb.build(virtualHostTemplate, dependencyInjector,\n                                                         unhandledExceptionsReporter))\n                                   .collect(toImmutableList());\n        // Pre-populate the domain name mapping for later matching.\n        final Mapping<String, SslContext> sslContexts;\n        final SslContext defaultSslContext = findDefaultSslContext(defaultVirtualHost, virtualHosts);\n        final Collection<ServerPort> ports;\n\n        for (ServerPort port : this.ports) {\n            checkState(port.protocols().stream().anyMatch(p -> p != PROXY),\n                       \"protocols: %s (expected: at least one %s or %s)\",\n                       port.protocols(), HTTP, HTTPS);\n        }\n\n        // The port numbers of port-based virtual hosts must exist in 'ServerPort's.\n        final List<VirtualHost> portBasedVirtualHosts = virtualHosts.stream()\n                                                                    .filter(v -> v.port() > 0)\n                                                                    .collect(toImmutableList());\n        final List<Integer> portNumbers = this.ports.stream()\n                                                    .map(port -> port.localAddress().getPort())\n                                                    .filter(port -> port > 0)\n                                                    .collect(toImmutableList());\n        for (VirtualHost virtualHost : portBasedVirtualHosts) {\n            final int virtualHostPort = virtualHost.port();\n            final boolean portMatched = portNumbers.stream().anyMatch(port -> port == virtualHostPort);\n            checkState(portMatched, \"virtual host port: %s (expected: one of %s)\",\n                       virtualHostPort, portNumbers);\n        }\n\n        if (defaultSslContext == null) {\n            sslContexts = null;\n            if (!serverPorts.isEmpty()) {\n                ports = resolveDistinctPorts(serverPorts);\n                for (final ServerPort p : ports) {\n                    if (p.hasTls()) {\n                        throw new IllegalArgumentException(\"TLS not configured; cannot serve HTTPS\");\n                    }\n                }\n            } else {\n                ports = ImmutableList.of(new ServerPort(0, HTTP));\n            }\n        } else {\n            if (!Flags.useOpenSsl() && !SystemInfo.jettyAlpnOptionalOrAvailable()) {\n                throw new IllegalStateException(\n                        \"TLS configured but this is Java 8 and neither OpenSSL nor Jetty ALPN could be \" +\n                        \"detected. To use TLS with Armeria, you must either use Java 9+, enable OpenSSL, \" +\n                        \"usually by adding a build dependency on the \" +\n                        \"io.netty:netty-tcnative-boringssl-static artifact or enable Jetty ALPN as described \" +\n                        \"at https://www.eclipse.org/jetty/documentation/9.4.x/alpn-chapter.html\");\n            }\n\n            if (!serverPorts.isEmpty()) {\n                ports = resolveDistinctPorts(serverPorts);\n            } else {\n                ports = ImmutableList.of(new ServerPort(0, HTTPS));\n            }\n\n            final DomainMappingBuilder<SslContext>\n                    mappingBuilder = new DomainMappingBuilder<>(defaultSslContext);\n            for (VirtualHost h : virtualHosts) {\n                final SslContext sslCtx = h.sslContext();\n                if (sslCtx != null) {\n                    final String originalHostnamePattern = h.originalHostnamePattern();\n                    // The SslContext for the default virtual host was added when creating DomainMappingBuilder.\n                    if (!\"*\".equals(originalHostnamePattern)) {\n                        mappingBuilder.add(originalHostnamePattern, sslCtx);\n                    }\n                }\n            }\n            sslContexts = mappingBuilder.build();\n        }\n\n        if (pingIntervalMillis > 0) {\n            pingIntervalMillis = Math.max(pingIntervalMillis, MIN_PING_INTERVAL_MILLIS);\n            if (idleTimeoutMillis > 0 && pingIntervalMillis >= idleTimeoutMillis) {\n                pingIntervalMillis = 0;\n            }\n        }\n\n        if (maxConnectionAgeMillis > 0) {\n            maxConnectionAgeMillis = Math.max(maxConnectionAgeMillis, MIN_MAX_CONNECTION_AGE_MILLIS);\n            if (idleTimeoutMillis == 0 || idleTimeoutMillis > maxConnectionAgeMillis) {\n                idleTimeoutMillis = maxConnectionAgeMillis;\n            }\n        }\n\n        final Map<ChannelOption<?>, Object> newChildChannelOptions =\n                ChannelUtil.applyDefaultChannelOptions(\n                        childChannelOptions, idleTimeoutMillis, pingIntervalMillis);\n\n        final BlockingTaskExecutor blockingTaskExecutor = defaultVirtualHost.blockingTaskExecutor();\n        return new DefaultServerConfig(\n                ports, setSslContextIfAbsent(defaultVirtualHost, defaultSslContext),\n                virtualHosts, workerGroup, shutdownWorkerGroupOnStop, startStopExecutor, maxNumConnections,\n                idleTimeoutMillis, keepAliveOnPing, pingIntervalMillis, maxConnectionAgeMillis,\n                maxNumRequestsPerConnection,\n                connectionDrainDurationMicros, http2InitialConnectionWindowSize,\n                http2InitialStreamWindowSize, http2MaxStreamsPerConnection,\n                http2MaxFrameSize, http2MaxHeaderListSize, http1MaxInitialLineLength, http1MaxHeaderSize,\n                http1MaxChunkSize, gracefulShutdownQuietPeriod, gracefulShutdownTimeout,\n                blockingTaskExecutor,\n                meterRegistry, proxyProtocolMaxTlvSize, channelOptions, newChildChannelOptions,\n                childChannelPipelineCustomizer,\n                clientAddressSources, clientAddressTrustedProxyFilter, clientAddressFilter, clientAddressMapper,\n                enableServerHeader, enableDateHeader, errorHandler, sslContexts,\n                http1HeaderNaming, dependencyInjector, absoluteUriTransformer,\n                unhandledExceptionsReportIntervalMillis, ImmutableList.copyOf(shutdownSupports));\n    }",
  "abstract_func_before": "private DefaultServerConfig buildServerConfig(List<ServerPort> VAR_0) {\n        final AnnotatedServiceExtensions VAR_1 =\n                VAR_2.annotatedServiceExtensions();\n        assert VAR_1 != null;\n        final DependencyInjector VAR_3 = dependencyInjectorOrReflective();\n\n        final UnhandledExceptionsReporter VAR_4;\n        if (VAR_5 > 0) {\n            VAR_4 = VAR_6.of(\n                    VAR_7, VAR_5);\n            VAR_8.add(VAR_4);\n        } else {\n            VAR_4 = null;\n        }\n\n        final VirtualHost VAR_9 =\n                VAR_10.build(VAR_2, VAR_3,\n                                                VAR_4);\n        final List<VirtualHost> VAR_11 =\n                VAR_12.stream()\n                                   .map(VAR_13 -> VAR_13.build(VAR_2, VAR_3,\n                                                         VAR_4))\n                                   .collect(toImmutableList());\n        /* COMMENT_0 */\n        final Mapping<String, SslContext> VAR_14;\n        final SslContext VAR_15 = findDefaultSslContext(VAR_9, VAR_11);\n        final Collection<ServerPort> VAR_16;\n\n        for (ServerPort VAR_17 : this.ports) {\n            checkState(VAR_17.protocols().stream().anyMatch(VAR_18 -> VAR_18 != VAR_19),\n                       \"protocols: %s (expected: at least one %s or %s)\",\n                       VAR_17.protocols(), VAR_20, VAR_21);\n        }\n\n        /* COMMENT_1 */\n        final List<VirtualHost> VAR_22 = VAR_11.stream()\n                                                                    .filter(VAR_23 -> VAR_23.port() > 0)\n                                                                    .collect(toImmutableList());\n        final List<Integer> VAR_24 = this.ports.stream()\n                                                    .map(VAR_17 -> VAR_17.localAddress().getPort())\n                                                    .filter(VAR_17 -> VAR_17 > 0)\n                                                    .collect(toImmutableList());\n        for (VirtualHost VAR_25 : VAR_22) {\n            final int VAR_26 = VAR_25.port();\n            final boolean VAR_27 = VAR_24.stream().anyMatch(VAR_17 -> VAR_17 == VAR_26);\n            checkState(VAR_27, \"virtual host port: %s (expected: one of %s)\",\n                       VAR_26, VAR_24);\n        }\n\n        if (VAR_15 == null) {\n            VAR_14 = null;\n            if (!VAR_0.isEmpty()) {\n                VAR_16 = resolveDistinctPorts(VAR_0);\n                for (final ServerPort VAR_18 : VAR_16) {\n                    if (VAR_18.hasTls()) {\n                        throw new IllegalArgumentException(\"TLS not configured; cannot serve HTTPS\");\n                    }\n                }\n            } else {\n                VAR_16 = VAR_28.of(new ServerPort(0, VAR_20));\n            }\n        } else {\n            if (!VAR_29.useOpenSsl() && !VAR_30.jettyAlpnOptionalOrAvailable()) {\n                throw new IllegalStateException(\n                        \"TLS configured but this is Java 8 and neither OpenSSL nor Jetty ALPN could be \" +\n                        \"detected. To use TLS with Armeria, you must either use Java 9+, enable OpenSSL, \" +\n                        \"usually by adding a build dependency on the \" +\n                        \"io.netty:netty-tcnative-boringssl-static artifact or enable Jetty ALPN as described \" +\n                        \"at https://www.eclipse.org/jetty/documentation/9.4.x/alpn-chapter.html\");\n            }\n\n            if (!VAR_0.isEmpty()) {\n                VAR_16 = resolveDistinctPorts(VAR_0);\n            } else {\n                VAR_16 = VAR_28.of(new ServerPort(0, VAR_21));\n            }\n\n            final DomainMappingBuilder<SslContext>\n                    VAR_31 = new DomainMappingBuilder<>(VAR_15);\n            for (VirtualHost VAR_32 : VAR_11) {\n                final SslContext VAR_33 = VAR_32.sslContext();\n                if (VAR_33 != null) {\n                    final String VAR_34 = VAR_32.originalHostnamePattern();\n                    /* COMMENT_2 */\n                    if (!\"*\".equals(VAR_34)) {\n                        VAR_31.add(VAR_34, VAR_33);\n                    }\n                }\n            }\n            VAR_14 = VAR_31.build();\n        }\n\n        if (VAR_35 > 0) {\n            VAR_35 = VAR_36.max(VAR_35, VAR_37);\n            if (VAR_38 > 0 && VAR_35 >= VAR_38) {\n                VAR_35 = 0;\n            }\n        }\n\n        if (VAR_39 > 0) {\n            VAR_39 = VAR_36.max(VAR_39, VAR_40);\n            if (VAR_38 == 0 || VAR_38 > VAR_39) {\n                VAR_38 = VAR_39;\n            }\n        }\n\n        final Map<ChannelOption<?>, Object> VAR_41 =\n                VAR_42.applyDefaultChannelOptions(\n                        VAR_43, VAR_38, VAR_35);\n\n        final BlockingTaskExecutor VAR_44 = VAR_9.blockingTaskExecutor();\n        return new DefaultServerConfig(\n                VAR_16, setSslContextIfAbsent(VAR_9, VAR_15),\n                VAR_11, VAR_45, VAR_46, VAR_47, VAR_48,\n                VAR_38, VAR_49, VAR_35, VAR_39,\n                VAR_50,\n                VAR_51, VAR_52,\n                VAR_53, VAR_54,\n                VAR_55, VAR_56, VAR_57, VAR_58,\n                VAR_59, VAR_60, VAR_61,\n                VAR_44,\n                VAR_7, VAR_62, VAR_63, VAR_41,\n                VAR_64,\n                VAR_65, VAR_66, VAR_67, VAR_68,\n                VAR_69, VAR_70, VAR_71, VAR_14,\n                VAR_72, VAR_3, VAR_73,\n                VAR_5, VAR_28.copyOf(VAR_74));\n    }",
  "func_graph_path_before": "line/armeria/df7f85824a62e997b910b5d6194a3335841065fd/ServerBuilder.java/vul/before/0.json",
  "func": "private DefaultServerConfig buildServerConfig(List<ServerPort> serverPorts) {\n        final AnnotatedServiceExtensions extensions =\n                virtualHostTemplate.annotatedServiceExtensions();\n        assert extensions != null;\n        final DependencyInjector dependencyInjector = dependencyInjectorOrReflective();\n\n        final UnhandledExceptionsReporter unhandledExceptionsReporter;\n        if (unhandledExceptionsReportIntervalMillis > 0) {\n            unhandledExceptionsReporter = UnhandledExceptionsReporter.of(\n                    meterRegistry, unhandledExceptionsReportIntervalMillis);\n            serverListeners.add(unhandledExceptionsReporter);\n        } else {\n            unhandledExceptionsReporter = null;\n        }\n\n        final VirtualHost defaultVirtualHost =\n                defaultVirtualHostBuilder.build(virtualHostTemplate, dependencyInjector,\n                                                unhandledExceptionsReporter);\n        final List<VirtualHost> virtualHosts =\n                virtualHostBuilders.stream()\n                                   .map(vhb -> vhb.build(virtualHostTemplate, dependencyInjector,\n                                                         unhandledExceptionsReporter))\n                                   .collect(toImmutableList());\n        // Pre-populate the domain name mapping for later matching.\n        final Mapping<String, SslContext> sslContexts;\n        final SslContext defaultSslContext = findDefaultSslContext(defaultVirtualHost, virtualHosts);\n        final Collection<ServerPort> ports;\n\n        for (ServerPort port : this.ports) {\n            checkState(port.protocols().stream().anyMatch(p -> p != PROXY),\n                       \"protocols: %s (expected: at least one %s or %s)\",\n                       port.protocols(), HTTP, HTTPS);\n        }\n\n        // The port numbers of port-based virtual hosts must exist in 'ServerPort's.\n        final List<VirtualHost> portBasedVirtualHosts = virtualHosts.stream()\n                                                                    .filter(v -> v.port() > 0)\n                                                                    .collect(toImmutableList());\n        final List<Integer> portNumbers = this.ports.stream()\n                                                    .map(port -> port.localAddress().getPort())\n                                                    .filter(port -> port > 0)\n                                                    .collect(toImmutableList());\n        for (VirtualHost virtualHost : portBasedVirtualHosts) {\n            final int virtualHostPort = virtualHost.port();\n            final boolean portMatched = portNumbers.stream().anyMatch(port -> port == virtualHostPort);\n            checkState(portMatched, \"virtual host port: %s (expected: one of %s)\",\n                       virtualHostPort, portNumbers);\n        }\n\n        if (defaultSslContext == null) {\n            sslContexts = null;\n            if (!serverPorts.isEmpty()) {\n                ports = resolveDistinctPorts(serverPorts);\n                for (final ServerPort p : ports) {\n                    if (p.hasTls()) {\n                        throw new IllegalArgumentException(\"TLS not configured; cannot serve HTTPS\");\n                    }\n                }\n            } else {\n                ports = ImmutableList.of(new ServerPort(0, HTTP));\n            }\n        } else {\n            if (!Flags.useOpenSsl() && !SystemInfo.jettyAlpnOptionalOrAvailable()) {\n                throw new IllegalStateException(\n                        \"TLS configured but this is Java 8 and neither OpenSSL nor Jetty ALPN could be \" +\n                        \"detected. To use TLS with Armeria, you must either use Java 9+, enable OpenSSL, \" +\n                        \"usually by adding a build dependency on the \" +\n                        \"io.netty:netty-tcnative-boringssl-static artifact or enable Jetty ALPN as described \" +\n                        \"at https://www.eclipse.org/jetty/documentation/9.4.x/alpn-chapter.html\");\n            }\n\n            if (!serverPorts.isEmpty()) {\n                ports = resolveDistinctPorts(serverPorts);\n            } else {\n                ports = ImmutableList.of(new ServerPort(0, HTTPS));\n            }\n\n            final DomainMappingBuilder<SslContext>\n                    mappingBuilder = new DomainMappingBuilder<>(defaultSslContext);\n            for (VirtualHost h : virtualHosts) {\n                final SslContext sslCtx = h.sslContext();\n                if (sslCtx != null) {\n                    final String originalHostnamePattern = h.originalHostnamePattern();\n                    // The SslContext for the default virtual host was added when creating DomainMappingBuilder.\n                    if (!\"*\".equals(originalHostnamePattern)) {\n                        mappingBuilder.add(originalHostnamePattern, sslCtx);\n                    }\n                }\n            }\n            sslContexts = mappingBuilder.build();\n        }\n\n        if (pingIntervalMillis > 0) {\n            pingIntervalMillis = Math.max(pingIntervalMillis, MIN_PING_INTERVAL_MILLIS);\n            if (idleTimeoutMillis > 0 && pingIntervalMillis >= idleTimeoutMillis) {\n                pingIntervalMillis = 0;\n            }\n        }\n\n        if (maxConnectionAgeMillis > 0) {\n            maxConnectionAgeMillis = Math.max(maxConnectionAgeMillis, MIN_MAX_CONNECTION_AGE_MILLIS);\n            if (idleTimeoutMillis == 0 || idleTimeoutMillis > maxConnectionAgeMillis) {\n                idleTimeoutMillis = maxConnectionAgeMillis;\n            }\n        }\n\n        final Map<ChannelOption<?>, Object> newChildChannelOptions =\n                ChannelUtil.applyDefaultChannelOptions(\n                        childChannelOptions, idleTimeoutMillis, pingIntervalMillis);\n\n        final BlockingTaskExecutor blockingTaskExecutor = defaultVirtualHost.blockingTaskExecutor();\n        return new DefaultServerConfig(\n                ports, setSslContextIfAbsent(defaultVirtualHost, defaultSslContext),\n                virtualHosts, workerGroup, shutdownWorkerGroupOnStop, startStopExecutor, maxNumConnections,\n                idleTimeoutMillis, keepAliveOnPing, pingIntervalMillis, maxConnectionAgeMillis,\n                maxNumRequestsPerConnection,\n                connectionDrainDurationMicros, http2InitialConnectionWindowSize,\n                http2InitialStreamWindowSize, http2MaxStreamsPerConnection,\n                http2MaxFrameSize, http2MaxHeaderListSize,\n                http2MaxResetFramesPerWindow, http2MaxResetFramesWindowSeconds,\n                http1MaxInitialLineLength, http1MaxHeaderSize,\n                http1MaxChunkSize, gracefulShutdownQuietPeriod, gracefulShutdownTimeout,\n                blockingTaskExecutor,\n                meterRegistry, proxyProtocolMaxTlvSize, channelOptions, newChildChannelOptions,\n                childChannelPipelineCustomizer,\n                clientAddressSources, clientAddressTrustedProxyFilter, clientAddressFilter, clientAddressMapper,\n                enableServerHeader, enableDateHeader, errorHandler, sslContexts,\n                http1HeaderNaming, dependencyInjector, absoluteUriTransformer,\n                unhandledExceptionsReportIntervalMillis, ImmutableList.copyOf(shutdownSupports));\n    }",
  "abstract_func": "private DefaultServerConfig buildServerConfig(List<ServerPort> VAR_0) {\n        final AnnotatedServiceExtensions VAR_1 =\n                VAR_2.annotatedServiceExtensions();\n        assert VAR_1 != null;\n        final DependencyInjector VAR_3 = dependencyInjectorOrReflective();\n\n        final UnhandledExceptionsReporter VAR_4;\n        if (VAR_5 > 0) {\n            VAR_4 = VAR_6.of(\n                    VAR_7, VAR_5);\n            VAR_8.add(VAR_4);\n        } else {\n            VAR_4 = null;\n        }\n\n        final VirtualHost VAR_9 =\n                VAR_10.build(VAR_2, VAR_3,\n                                                VAR_4);\n        final List<VirtualHost> VAR_11 =\n                VAR_12.stream()\n                                   .map(VAR_13 -> VAR_13.build(VAR_2, VAR_3,\n                                                         VAR_4))\n                                   .collect(toImmutableList());\n        /* COMMENT_0 */\n        final Mapping<String, SslContext> VAR_14;\n        final SslContext VAR_15 = findDefaultSslContext(VAR_9, VAR_11);\n        final Collection<ServerPort> VAR_16;\n\n        for (ServerPort VAR_17 : this.ports) {\n            checkState(VAR_17.protocols().stream().anyMatch(VAR_18 -> VAR_18 != VAR_19),\n                       \"protocols: %s (expected: at least one %s or %s)\",\n                       VAR_17.protocols(), VAR_20, VAR_21);\n        }\n\n        /* COMMENT_1 */\n        final List<VirtualHost> VAR_22 = VAR_11.stream()\n                                                                    .filter(VAR_23 -> VAR_23.port() > 0)\n                                                                    .collect(toImmutableList());\n        final List<Integer> VAR_24 = this.ports.stream()\n                                                    .map(VAR_17 -> VAR_17.localAddress().getPort())\n                                                    .filter(VAR_17 -> VAR_17 > 0)\n                                                    .collect(toImmutableList());\n        for (VirtualHost VAR_25 : VAR_22) {\n            final int VAR_26 = VAR_25.port();\n            final boolean VAR_27 = VAR_24.stream().anyMatch(VAR_17 -> VAR_17 == VAR_26);\n            checkState(VAR_27, \"virtual host port: %s (expected: one of %s)\",\n                       VAR_26, VAR_24);\n        }\n\n        if (VAR_15 == null) {\n            VAR_14 = null;\n            if (!VAR_0.isEmpty()) {\n                VAR_16 = resolveDistinctPorts(VAR_0);\n                for (final ServerPort VAR_18 : VAR_16) {\n                    if (VAR_18.hasTls()) {\n                        throw new IllegalArgumentException(\"TLS not configured; cannot serve HTTPS\");\n                    }\n                }\n            } else {\n                VAR_16 = VAR_28.of(new ServerPort(0, VAR_20));\n            }\n        } else {\n            if (!VAR_29.useOpenSsl() && !VAR_30.jettyAlpnOptionalOrAvailable()) {\n                throw new IllegalStateException(\n                        \"TLS configured but this is Java 8 and neither OpenSSL nor Jetty ALPN could be \" +\n                        \"detected. To use TLS with Armeria, you must either use Java 9+, enable OpenSSL, \" +\n                        \"usually by adding a build dependency on the \" +\n                        \"io.netty:netty-tcnative-boringssl-static artifact or enable Jetty ALPN as described \" +\n                        \"at https://www.eclipse.org/jetty/documentation/9.4.x/alpn-chapter.html\");\n            }\n\n            if (!VAR_0.isEmpty()) {\n                VAR_16 = resolveDistinctPorts(VAR_0);\n            } else {\n                VAR_16 = VAR_28.of(new ServerPort(0, VAR_21));\n            }\n\n            final DomainMappingBuilder<SslContext>\n                    VAR_31 = new DomainMappingBuilder<>(VAR_15);\n            for (VirtualHost VAR_32 : VAR_11) {\n                final SslContext VAR_33 = VAR_32.sslContext();\n                if (VAR_33 != null) {\n                    final String VAR_34 = VAR_32.originalHostnamePattern();\n                    /* COMMENT_2 */\n                    if (!\"*\".equals(VAR_34)) {\n                        VAR_31.add(VAR_34, VAR_33);\n                    }\n                }\n            }\n            VAR_14 = VAR_31.build();\n        }\n\n        if (VAR_35 > 0) {\n            VAR_35 = VAR_36.max(VAR_35, VAR_37);\n            if (VAR_38 > 0 && VAR_35 >= VAR_38) {\n                VAR_35 = 0;\n            }\n        }\n\n        if (VAR_39 > 0) {\n            VAR_39 = VAR_36.max(VAR_39, VAR_40);\n            if (VAR_38 == 0 || VAR_38 > VAR_39) {\n                VAR_38 = VAR_39;\n            }\n        }\n\n        final Map<ChannelOption<?>, Object> VAR_41 =\n                VAR_42.applyDefaultChannelOptions(\n                        VAR_43, VAR_38, VAR_35);\n\n        final BlockingTaskExecutor VAR_44 = VAR_9.blockingTaskExecutor();\n        return new DefaultServerConfig(\n                VAR_16, setSslContextIfAbsent(VAR_9, VAR_15),\n                VAR_11, VAR_45, VAR_46, VAR_47, VAR_48,\n                VAR_38, VAR_49, VAR_35, VAR_39,\n                VAR_50,\n                VAR_51, VAR_52,\n                VAR_53, VAR_54,\n                VAR_55, VAR_56,\n                VAR_57, VAR_58,\n                VAR_59, VAR_60,\n                VAR_61, VAR_62, VAR_63,\n                VAR_44,\n                VAR_7, VAR_64, VAR_65, VAR_41,\n                VAR_66,\n                VAR_67, VAR_68, VAR_69, VAR_70,\n                VAR_71, VAR_72, VAR_73, VAR_14,\n                VAR_74, VAR_3, VAR_75,\n                VAR_5, VAR_28.copyOf(VAR_76));\n    }",
  "func_graph_path": "line/armeria/df7f85824a62e997b910b5d6194a3335841065fd/ServerBuilder.java/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -116,7 +116,9 @@\n                 maxNumRequestsPerConnection,\n                 connectionDrainDurationMicros, http2InitialConnectionWindowSize,\n                 http2InitialStreamWindowSize, http2MaxStreamsPerConnection,\n-                http2MaxFrameSize, http2MaxHeaderListSize, http1MaxInitialLineLength, http1MaxHeaderSize,\n+                http2MaxFrameSize, http2MaxHeaderListSize,\n+                http2MaxResetFramesPerWindow, http2MaxResetFramesWindowSeconds,\n+                http1MaxInitialLineLength, http1MaxHeaderSize,\n                 http1MaxChunkSize, gracefulShutdownQuietPeriod, gracefulShutdownTimeout,\n                 blockingTaskExecutor,\n                 meterRegistry, proxyProtocolMaxTlvSize, channelOptions, newChildChannelOptions,",
  "diff_line_info": {
    "deleted_lines": [
      "                http2MaxFrameSize, http2MaxHeaderListSize, http1MaxInitialLineLength, http1MaxHeaderSize,"
    ],
    "added_lines": [
      "                http2MaxFrameSize, http2MaxHeaderListSize,",
      "                http2MaxResetFramesPerWindow, http2MaxResetFramesWindowSeconds,",
      "                http1MaxInitialLineLength, http1MaxHeaderSize,"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/line/armeria/pull/5232",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/line/armeria/pull/5232: 403 Client Error: Forbidden for url: https://api.github.com/repos/line/armeria/pulls/5232",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95"
}