{
  "cve_id": "CVE-2023-35847",
  "cwe_ids": [
    "CWE-908",
    "CWE-682"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "virtualsquare/picotcp",
  "commit_msg": "TCP: Fixed MSS size calculation. Set MSS lower bound.\n\nReported-by: \"P. Amsuo, Purdue University\"",
  "commit_hash": "eaf166009e44641e6570c576ba071217f100fd99",
  "git_url": "https://github.com/virtualsquare/picotcp/commit/eaf166009e44641e6570c576ba071217f100fd99",
  "file_path": "modules/pico_tcp.c",
  "func_name": "pico_tcp_open",
  "func_before": "struct pico_socket *pico_tcp_open(struct pico_stack *S, uint16_t family)\n{\n    struct pico_socket_tcp *t = PICO_ZALLOC(sizeof(struct pico_socket_tcp));\n    if (!t)\n        return NULL;\n\n    t->sock.stack = S;\n    t->sock.timestamp = TCP_TIME;\n    pico_socket_set_family(&t->sock, family);\n    t->mss = (uint16_t)(pico_socket_get_mss(&t->sock) - PICO_SIZE_TCPHDR);\n    t->tcpq_in.pool.root = t->tcpq_hold.pool.root = t->tcpq_out.pool.root = &LEAF;\n    t->tcpq_hold.pool.compare = t->tcpq_out.pool.compare = segment_compare;\n    t->tcpq_in.pool.compare = input_segment_compare;\n    t->tcpq_in.max_size = PICO_DEFAULT_SOCKETQ;\n    t->tcpq_out.max_size = PICO_DEFAULT_SOCKETQ;\n    t->tcpq_hold.max_size = 2u * t->mss;\n    rto_set(t, PICO_TCP_RTO_MIN);\n\n    /* Uncomment next line and disable Nagle by default */\n    t->sock.opt_flags |= (1 << PICO_SOCKET_OPT_TCPNODELAY);\n\n    /* Uncomment next line and Nagle is enabled by default */\n    /* t->sock.opt_flags &= (uint16_t) ~(1 << PICO_SOCKET_OPT_TCPNODELAY); */\n\n    /* Set default linger for the socket */\n    t->linger_timeout = PICO_SOCKET_LINGER_TIMEOUT;\n\n\n#ifdef PICO_TCP_SUPPORT_SOCKET_STATS\n    if (!pico_timer_add(t->sock.stack, 2000, sock_stats, t)) {\n        tcp_dbg(\"TCP: Failed to start socket statistics timer\\n\");\n        PICO_FREE(t);\n        return NULL;\n    }\n#endif\n\n    t->keepalive_tmr = pico_timer_add(t->sock.stack, 1000, pico_tcp_keepalive, t);\n    if (!t->keepalive_tmr) {\n        tcp_dbg(\"TCP: Failed to start keepalive timer\\n\");\n        PICO_FREE(t);\n        return NULL;\n    }\n    tcp_set_space(t);\n    return &t->sock;\n}",
  "abstract_func_before": "struct pico_socket *pico_tcp_open(struct pico_stack *VAR_0, uint16_t VAR_1)\n{\n    struct pico_socket_tcp *VAR_2 = PICO_ZALLOC(sizeof(struct pico_socket_tcp));\n    if (!VAR_2)\n        return NULL;\n\n    VAR_2->sock.stack = VAR_0;\n    VAR_2->sock.timestamp = VAR_3;\n    pico_socket_set_family(&VAR_2->sock, VAR_1);\n    VAR_2->mss = (uint16_t)(pico_socket_get_mss(&VAR_2->sock) - VAR_4);\n    VAR_2->tcpq_in.pool.root = VAR_2->tcpq_hold.pool.root = VAR_2->tcpq_out.pool.root = &VAR_5;\n    VAR_2->tcpq_hold.pool.compare = VAR_2->tcpq_out.pool.compare = VAR_6;\n    VAR_2->tcpq_in.pool.compare = VAR_7;\n    VAR_2->tcpq_in.max_size = VAR_8;\n    VAR_2->tcpq_out.max_size = VAR_8;\n    VAR_2->tcpq_hold.max_size = 2u * VAR_2->mss;\n    rto_set(VAR_2, VAR_9);\n\n    /* COMMENT_0 */\n    VAR_2->sock.opt_flags |= (1 << VAR_10);\n\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n\n    /* COMMENT_3 */\n    VAR_2->linger_timeout = VAR_11;\n\n\n#ifdef VAR_12\n    if (!pico_timer_add(VAR_2->sock.stack, 2000, VAR_13, VAR_2)) {\n        tcp_dbg(\"TCP: Failed to start socket statistics timer\\n\");\n        PICO_FREE(VAR_2);\n        return NULL;\n    }\n#endif\n\n    VAR_2->keepalive_tmr = pico_timer_add(VAR_2->sock.stack, 1000, VAR_14, VAR_2);\n    if (!VAR_2->keepalive_tmr) {\n        tcp_dbg(\"TCP: Failed to start keepalive timer\\n\");\n        PICO_FREE(VAR_2);\n        return NULL;\n    }\n    tcp_set_space(VAR_2);\n    return &VAR_2->sock;\n}",
  "func_graph_path_before": "virtualsquare/picotcp/eaf166009e44641e6570c576ba071217f100fd99/pico_tcp.c/vul/before/0.json",
  "func": "struct pico_socket *pico_tcp_open(struct pico_stack *S, uint16_t family)\n{\n    struct pico_socket_tcp *t = PICO_ZALLOC(sizeof(struct pico_socket_tcp));\n    if (!t)\n        return NULL;\n\n    t->sock.stack = S;\n    t->sock.timestamp = TCP_TIME;\n    pico_socket_set_family(&t->sock, family);\n    t->mss = (uint16_t)(pico_socket_get_mss(&t->sock));\n    if (t->mss > PICO_SIZE_TCPHDR + PICO_TCP_MIN_MSS)\n        t->mss -= (uint16_t)PICO_SIZE_TCPHDR;\n    else\n        t->mss = PICO_TCP_MIN_MSS;\n    t->tcpq_in.pool.root = t->tcpq_hold.pool.root = t->tcpq_out.pool.root = &LEAF;\n    t->tcpq_hold.pool.compare = t->tcpq_out.pool.compare = segment_compare;\n    t->tcpq_in.pool.compare = input_segment_compare;\n    t->tcpq_in.max_size = PICO_DEFAULT_SOCKETQ;\n    t->tcpq_out.max_size = PICO_DEFAULT_SOCKETQ;\n    t->tcpq_hold.max_size = 2u * t->mss;\n    rto_set(t, PICO_TCP_RTO_MIN);\n\n    /* Uncomment next line and disable Nagle by default */\n    t->sock.opt_flags |= (1 << PICO_SOCKET_OPT_TCPNODELAY);\n\n    /* Uncomment next line and Nagle is enabled by default */\n    /* t->sock.opt_flags &= (uint16_t) ~(1 << PICO_SOCKET_OPT_TCPNODELAY); */\n\n    /* Set default linger for the socket */\n    t->linger_timeout = PICO_SOCKET_LINGER_TIMEOUT;\n\n\n#ifdef PICO_TCP_SUPPORT_SOCKET_STATS\n    if (!pico_timer_add(t->sock.stack, 2000, sock_stats, t)) {\n        tcp_dbg(\"TCP: Failed to start socket statistics timer\\n\");\n        PICO_FREE(t);\n        return NULL;\n    }\n#endif\n\n    t->keepalive_tmr = pico_timer_add(t->sock.stack, 1000, pico_tcp_keepalive, t);\n    if (!t->keepalive_tmr) {\n        tcp_dbg(\"TCP: Failed to start keepalive timer\\n\");\n        PICO_FREE(t);\n        return NULL;\n    }\n    tcp_set_space(t);\n    return &t->sock;\n}",
  "abstract_func": "struct pico_socket *pico_tcp_open(struct pico_stack *VAR_0, uint16_t VAR_1)\n{\n    struct pico_socket_tcp *VAR_2 = PICO_ZALLOC(sizeof(struct pico_socket_tcp));\n    if (!VAR_2)\n        return NULL;\n\n    VAR_2->sock.stack = VAR_0;\n    VAR_2->sock.timestamp = VAR_3;\n    pico_socket_set_family(&VAR_2->sock, VAR_1);\n    VAR_2->mss = (uint16_t)(pico_socket_get_mss(&VAR_2->sock));\n    if (VAR_2->mss > VAR_4 + VAR_5)\n        VAR_2->mss -= (uint16_t)VAR_4;\n    else\n        VAR_2->mss = VAR_5;\n    VAR_2->tcpq_in.pool.root = VAR_2->tcpq_hold.pool.root = VAR_2->tcpq_out.pool.root = &VAR_6;\n    VAR_2->tcpq_hold.pool.compare = VAR_2->tcpq_out.pool.compare = VAR_7;\n    VAR_2->tcpq_in.pool.compare = VAR_8;\n    VAR_2->tcpq_in.max_size = VAR_9;\n    VAR_2->tcpq_out.max_size = VAR_9;\n    VAR_2->tcpq_hold.max_size = 2u * VAR_2->mss;\n    rto_set(VAR_2, VAR_10);\n\n    /* COMMENT_0 */\n    VAR_2->sock.opt_flags |= (1 << VAR_11);\n\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n\n    /* COMMENT_3 */\n    VAR_2->linger_timeout = VAR_12;\n\n\n#ifdef VAR_13\n    if (!pico_timer_add(VAR_2->sock.stack, 2000, VAR_14, VAR_2)) {\n        tcp_dbg(\"TCP: Failed to start socket statistics timer\\n\");\n        PICO_FREE(VAR_2);\n        return NULL;\n    }\n#endif\n\n    VAR_2->keepalive_tmr = pico_timer_add(VAR_2->sock.stack, 1000, VAR_15, VAR_2);\n    if (!VAR_2->keepalive_tmr) {\n        tcp_dbg(\"TCP: Failed to start keepalive timer\\n\");\n        PICO_FREE(VAR_2);\n        return NULL;\n    }\n    tcp_set_space(VAR_2);\n    return &VAR_2->sock;\n}",
  "func_graph_path": "virtualsquare/picotcp/eaf166009e44641e6570c576ba071217f100fd99/pico_tcp.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -7,7 +7,11 @@\n     t->sock.stack = S;\n     t->sock.timestamp = TCP_TIME;\n     pico_socket_set_family(&t->sock, family);\n-    t->mss = (uint16_t)(pico_socket_get_mss(&t->sock) - PICO_SIZE_TCPHDR);\n+    t->mss = (uint16_t)(pico_socket_get_mss(&t->sock));\n+    if (t->mss > PICO_SIZE_TCPHDR + PICO_TCP_MIN_MSS)\n+        t->mss -= (uint16_t)PICO_SIZE_TCPHDR;\n+    else\n+        t->mss = PICO_TCP_MIN_MSS;\n     t->tcpq_in.pool.root = t->tcpq_hold.pool.root = t->tcpq_out.pool.root = &LEAF;\n     t->tcpq_hold.pool.compare = t->tcpq_out.pool.compare = segment_compare;\n     t->tcpq_in.pool.compare = input_segment_compare;",
  "diff_line_info": {
    "deleted_lines": [
      "    t->mss = (uint16_t)(pico_socket_get_mss(&t->sock) - PICO_SIZE_TCPHDR);"
    ],
    "added_lines": [
      "    t->mss = (uint16_t)(pico_socket_get_mss(&t->sock));",
      "    if (t->mss > PICO_SIZE_TCPHDR + PICO_TCP_MIN_MSS)",
      "        t->mss -= (uint16_t)PICO_SIZE_TCPHDR;",
      "    else",
      "        t->mss = PICO_TCP_MIN_MSS;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/virtualsquare/picotcp/pull/15",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/virtualsquare/picotcp/pull/15: 403 Client Error: Forbidden for url: https://api.github.com/repos/virtualsquare/picotcp/pulls/15",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.85,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.85\n\nThe patch addresses a bug in MSS calculation, which is a core TCP function. The changes do not explicitly fix a security vulnerability but rather a functional issue. The confidence is high as the code modifications are consistent with the commit message and fix a specific defect."
}