{
  "cve_id": "CVE-2019-16058",
  "cwe_ids": [
    "CWE-119"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "OpenSC/pam_p11",
  "commit_msg": "Use EVP_PKEY_size() to allocate correct size of signature buffer. (#18)\n\nDo not use fixed buffer size for signature, EVP_SignFinal() requires\r\nbuffer for signature at least  EVP_PKEY_size(pkey) bytes in size.\r\n\r\nFixes crash when using 4K RSA signatures (https://github.com/OpenSC/pam_p11/issues/16, https://github.com/OpenSC/pam_p11/issues/15)",
  "commit_hash": "d150b60e1e14c261b113f55681419ad1dfa8a76c",
  "git_url": "https://github.com/OpenSC/pam_p11/commit/d150b60e1e14c261b113f55681419ad1dfa8a76c",
  "file_path": "src/pam_p11.c",
  "func_name": "key_verify",
  "func_before": "static int key_verify(pam_handle_t *pamh, int flags, PKCS11_KEY *authkey)\n{\n\tint ok = 0;\n\tunsigned char challenge[30];\n\tunsigned char signature[256];\n\tunsigned int siglen = sizeof signature;\n\tconst EVP_MD *md = EVP_sha1();\n\tEVP_MD_CTX *md_ctx = EVP_MD_CTX_new();\n\tEVP_PKEY *privkey = PKCS11_get_private_key(authkey);\n\tEVP_PKEY *pubkey = PKCS11_get_public_key(authkey);\n\n\t/* Verify a SHA-1 hash of random data, signed by the key.\n\t *\n\t * Note that this will not work keys that aren't eligible for signing.\n\t * Unfortunately, libp11 currently has no way of checking\n\t * C_GetAttributeValue(CKA_SIGN), see\n\t * https://github.com/OpenSC/libp11/issues/219. Since we don't want to\n\t * implement try and error, we live with this limitation */\n\tif (1 != randomize(pamh, challenge, sizeof challenge)) {\n\t\tgoto err;\n\t}\n\tif (NULL == pubkey || NULL == privkey || NULL == md_ctx || NULL == md\n\t\t\t|| !EVP_SignInit(md_ctx, md)\n\t\t\t|| !EVP_SignUpdate(md_ctx, challenge, sizeof challenge)\n\t\t\t|| !EVP_SignFinal(md_ctx, signature, &siglen, privkey)\n\t\t\t|| !EVP_MD_CTX_reset(md_ctx)\n\t\t\t|| !EVP_VerifyInit(md_ctx, md)\n\t\t\t|| !EVP_VerifyUpdate(md_ctx, challenge, sizeof challenge)\n\t\t\t|| 1 != EVP_VerifyFinal(md_ctx, signature, siglen, pubkey)) {\n\t\tpam_syslog(pamh, LOG_DEBUG, \"Error verifying key: %s\\n\",\n\t\t\t\tERR_reason_error_string(ERR_get_error()));\n\t\tprompt(flags, pamh, PAM_ERROR_MSG, NULL, _(\"Error verifying key\"));\n\t\tgoto err;\n\t}\n\tok = 1;\n\nerr:\n\tif (NULL != pubkey)\n\t\tEVP_PKEY_free(pubkey);\n\tif (NULL != privkey)\n\t\tEVP_PKEY_free(privkey);\n\tif (NULL != md_ctx) {\n\t\tEVP_MD_CTX_free(md_ctx);\n\t}\n\treturn ok;\n}",
  "abstract_func_before": "static int key_verify(pam_handle_t *VAR_0, int VAR_1, PKCS11_KEY *VAR_2)\n{\n\tint VAR_3 = 0;\n\tunsigned char VAR_4[30];\n\tunsigned char VAR_5[256];\n\tunsigned int VAR_6 = sizeof VAR_5;\n\tconst EVP_MD *VAR_7 = EVP_sha1();\n\tEVP_MD_CTX *VAR_8 = EVP_MD_CTX_new();\n\tEVP_PKEY *VAR_9 = PKCS11_get_private_key(VAR_2);\n\tEVP_PKEY *VAR_10 = PKCS11_get_public_key(VAR_2);\n\n\t/* COMMENT_0 */\n   \n                                                                       \n                                                          \n                                      \n                                                                       \n                                                            \n\tif (1 != randomize(VAR_0, VAR_4, sizeof VAR_4)) {\n\t\tgoto err;\n\t}\n\tif (NULL == VAR_10 || NULL == VAR_9 || NULL == VAR_8 || NULL == VAR_7\n\t\t\t|| !EVP_SignInit(VAR_8, VAR_7)\n\t\t\t|| !EVP_SignUpdate(VAR_8, VAR_4, sizeof VAR_4)\n\t\t\t|| !EVP_SignFinal(VAR_8, VAR_5, &VAR_6, VAR_9)\n\t\t\t|| !EVP_MD_CTX_reset(VAR_8)\n\t\t\t|| !EVP_VerifyInit(VAR_8, VAR_7)\n\t\t\t|| !EVP_VerifyUpdate(VAR_8, VAR_4, sizeof VAR_4)\n\t\t\t|| 1 != EVP_VerifyFinal(VAR_8, VAR_5, VAR_6, VAR_10)) {\n\t\tpam_syslog(VAR_0, VAR_11, \"Error verifying key: %s\\n\",\n\t\t\t\tERR_reason_error_string(ERR_get_error()));\n\t\tprompt(VAR_1, VAR_0, VAR_12, NULL, _(\"Error verifying key\"));\n\t\tgoto err;\n\t}\n\tVAR_3 = 1;\n\nerr:\n\tif (NULL != VAR_10)\n\t\tEVP_PKEY_free(VAR_10);\n\tif (NULL != VAR_9)\n\t\tEVP_PKEY_free(VAR_9);\n\tif (NULL != VAR_8) {\n\t\tEVP_MD_CTX_free(VAR_8);\n\t}\n\treturn VAR_3;\n}",
  "func_graph_path_before": "OpenSC/pam_p11/d150b60e1e14c261b113f55681419ad1dfa8a76c/pam_p11.c/vul/before/0.json",
  "func": "static int key_verify(pam_handle_t *pamh, int flags, PKCS11_KEY *authkey)\n{\n\tint ok = 0;\n\tunsigned char challenge[30];\n\tunsigned char *signature = NULL;\n\tunsigned int siglen;\n\tconst EVP_MD *md = EVP_sha1();\n\tEVP_MD_CTX *md_ctx = EVP_MD_CTX_new();\n\tEVP_PKEY *privkey = PKCS11_get_private_key(authkey);\n\tEVP_PKEY *pubkey = PKCS11_get_public_key(authkey);\n\n\tif (NULL == privkey)\n\t\tgoto err;\n\tsiglen = EVP_PKEY_size(privkey);\n\tif (siglen <= 0)\n\t\tgoto err;\n\tsignature = malloc(siglen);\n\tif (NULL == signature)\n\t\tgoto err;\n\n\t/* Verify a SHA-1 hash of random data, signed by the key.\n\t *\n\t * Note that this will not work keys that aren't eligible for signing.\n\t * Unfortunately, libp11 currently has no way of checking\n\t * C_GetAttributeValue(CKA_SIGN), see\n\t * https://github.com/OpenSC/libp11/issues/219. Since we don't want to\n\t * implement try and error, we live with this limitation */\n\tif (1 != randomize(pamh, challenge, sizeof challenge)) {\n\t\tgoto err;\n\t}\n\tif (NULL == pubkey || NULL == privkey || NULL == md_ctx || NULL == md\n\t\t\t|| !EVP_SignInit(md_ctx, md)\n\t\t\t|| !EVP_SignUpdate(md_ctx, challenge, sizeof challenge)\n\t\t\t|| !EVP_SignFinal(md_ctx, signature, &siglen, privkey)\n\t\t\t|| !EVP_MD_CTX_reset(md_ctx)\n\t\t\t|| !EVP_VerifyInit(md_ctx, md)\n\t\t\t|| !EVP_VerifyUpdate(md_ctx, challenge, sizeof challenge)\n\t\t\t|| 1 != EVP_VerifyFinal(md_ctx, signature, siglen, pubkey)) {\n\t\tpam_syslog(pamh, LOG_DEBUG, \"Error verifying key: %s\\n\",\n\t\t\t\tERR_reason_error_string(ERR_get_error()));\n\t\tprompt(flags, pamh, PAM_ERROR_MSG, NULL, _(\"Error verifying key\"));\n\t\tgoto err;\n\t}\n\tok = 1;\n\nerr:\n\tfree(signature);\n\tif (NULL != pubkey)\n\t\tEVP_PKEY_free(pubkey);\n\tif (NULL != privkey)\n\t\tEVP_PKEY_free(privkey);\n\tif (NULL != md_ctx) {\n\t\tEVP_MD_CTX_free(md_ctx);\n\t}\n\treturn ok;\n}",
  "abstract_func": "static int key_verify(pam_handle_t *VAR_0, int VAR_1, PKCS11_KEY *VAR_2)\n{\n\tint VAR_3 = 0;\n\tunsigned char VAR_4[30];\n\tunsigned char *VAR_5 = NULL;\n\tunsigned int VAR_6;\n\tconst EVP_MD *VAR_7 = EVP_sha1();\n\tEVP_MD_CTX *VAR_8 = EVP_MD_CTX_new();\n\tEVP_PKEY *VAR_9 = PKCS11_get_private_key(VAR_2);\n\tEVP_PKEY *VAR_10 = PKCS11_get_public_key(VAR_2);\n\n\tif (NULL == VAR_9)\n\t\tgoto err;\n\tVAR_6 = EVP_PKEY_size(VAR_9);\n\tif (VAR_6 <= 0)\n\t\tgoto err;\n\tVAR_5 = malloc(VAR_6);\n\tif (NULL == VAR_5)\n\t\tgoto err;\n\n\t/* COMMENT_0 */\n   \n                                                                       \n                                                          \n                                      \n                                                                       \n                                                            \n\tif (1 != randomize(VAR_0, VAR_4, sizeof VAR_4)) {\n\t\tgoto err;\n\t}\n\tif (NULL == VAR_10 || NULL == VAR_9 || NULL == VAR_8 || NULL == VAR_7\n\t\t\t|| !EVP_SignInit(VAR_8, VAR_7)\n\t\t\t|| !EVP_SignUpdate(VAR_8, VAR_4, sizeof VAR_4)\n\t\t\t|| !EVP_SignFinal(VAR_8, VAR_5, &VAR_6, VAR_9)\n\t\t\t|| !EVP_MD_CTX_reset(VAR_8)\n\t\t\t|| !EVP_VerifyInit(VAR_8, VAR_7)\n\t\t\t|| !EVP_VerifyUpdate(VAR_8, VAR_4, sizeof VAR_4)\n\t\t\t|| 1 != EVP_VerifyFinal(VAR_8, VAR_5, VAR_6, VAR_10)) {\n\t\tpam_syslog(VAR_0, VAR_11, \"Error verifying key: %s\\n\",\n\t\t\t\tERR_reason_error_string(ERR_get_error()));\n\t\tprompt(VAR_1, VAR_0, VAR_12, NULL, _(\"Error verifying key\"));\n\t\tgoto err;\n\t}\n\tVAR_3 = 1;\n\nerr:\n\tfree(VAR_5);\n\tif (NULL != VAR_10)\n\t\tEVP_PKEY_free(VAR_10);\n\tif (NULL != VAR_9)\n\t\tEVP_PKEY_free(VAR_9);\n\tif (NULL != VAR_8) {\n\t\tEVP_MD_CTX_free(VAR_8);\n\t}\n\treturn VAR_3;\n}",
  "func_graph_path": "OpenSC/pam_p11/d150b60e1e14c261b113f55681419ad1dfa8a76c/pam_p11.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -2,12 +2,21 @@\n {\n \tint ok = 0;\n \tunsigned char challenge[30];\n-\tunsigned char signature[256];\n-\tunsigned int siglen = sizeof signature;\n+\tunsigned char *signature = NULL;\n+\tunsigned int siglen;\n \tconst EVP_MD *md = EVP_sha1();\n \tEVP_MD_CTX *md_ctx = EVP_MD_CTX_new();\n \tEVP_PKEY *privkey = PKCS11_get_private_key(authkey);\n \tEVP_PKEY *pubkey = PKCS11_get_public_key(authkey);\n+\n+\tif (NULL == privkey)\n+\t\tgoto err;\n+\tsiglen = EVP_PKEY_size(privkey);\n+\tif (siglen <= 0)\n+\t\tgoto err;\n+\tsignature = malloc(siglen);\n+\tif (NULL == signature)\n+\t\tgoto err;\n \n \t/* Verify a SHA-1 hash of random data, signed by the key.\n \t *\n@@ -35,6 +44,7 @@\n \tok = 1;\n \n err:\n+\tfree(signature);\n \tif (NULL != pubkey)\n \t\tEVP_PKEY_free(pubkey);\n \tif (NULL != privkey)",
  "diff_line_info": {
    "deleted_lines": [
      "\tunsigned char signature[256];",
      "\tunsigned int siglen = sizeof signature;"
    ],
    "added_lines": [
      "\tunsigned char *signature = NULL;",
      "\tunsigned int siglen;",
      "",
      "\tif (NULL == privkey)",
      "\t\tgoto err;",
      "\tsiglen = EVP_PKEY_size(privkey);",
      "\tif (siglen <= 0)",
      "\t\tgoto err;",
      "\tsignature = malloc(siglen);",
      "\tif (NULL == signature)",
      "\t\tgoto err;",
      "\tfree(signature);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/OpenSC/pam_p11/pull/18",
  "description": {
    "pr_info": {
      "title": "Use EVP_PKEY_size() to allocate correct size of signature buffer.",
      "number": 18
    },
    "comment": [
      "Do not use fixed buffer size for signature, EVP_SignFinal() requires\r\nbuffer for signature at least  EVP_PKEY_size(pkey) bytes in size.",
      "Thanks for comments, PR changed.",
      "I've edited the PR, please check if you think it's OK",
      "Looks good, but if we rely on openssl, there is enough to check  return value from `EVP_PKEY_size()` ..  test on `privkey` is not necesary. From openssl:\r\n\r\nint EVP_PKEY_size(const EVP_PKEY *pkey)\r\n{\r\n    if (pkey && pkey->ameth && pkey->ameth->pkey_size)\r\n        return pkey->ameth->pkey_size(pkey);\r\n    return 0;\r\n}\r\n\r\n\r\n\r\n\r\n",
      "I wonder if it would be better to write it without `malloc` i.e.:\r\n\r\nunsigned char signature[4096];\r\n\r\nif(EVP_PKEY_size(privkey)<= 0 || EVP_PKEY_size(privkey) > sizeof signature) goto err;\r\n\r\nFeel free to rewrite whole PR, if this solution is acceptable. "
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}