{
  "cve_id": "CVE-2018-16149",
  "cwe_ids": [
    "CWE-347"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "igrr/axtls-8266",
  "commit_msg": "Apply CVE fixes for X509 parsing\n\nApply patches developed by Sze Yiu which correct a vulnerability in\nX509 parsing.  See CVE-2018-16150 and CVE-2018-16149 for more info.",
  "commit_hash": "5efe2947ab45e81d84b5f707c51d1c64be52f36c",
  "git_url": "https://github.com/igrr/axtls-8266/commit/5efe2947ab45e81d84b5f707c51d1c64be52f36c",
  "file_path": "ssl/x509.c",
  "func_name": "x509_verify",
  "func_before": "int x509_verify(const CA_CERT_CTX *ca_cert_ctx, const X509_CTX *cert, \n        int *pathLenConstraint) \n{\n    int ret = X509_OK, i = 0;\n    bigint *cert_sig;\n    X509_CTX *next_cert = NULL;\n    BI_CTX *ctx = NULL;\n    bigint *mod = NULL, *expn = NULL;\n    int match_ca_cert = 0;\n    struct timeval tv;\n    uint8_t is_self_signed = 0;\n\n    if (cert == NULL)\n    {\n        ret = X509_VFY_ERROR_NO_TRUSTED_CERT;       \n        goto end_verify;\n    }\n\n    /* a self-signed certificate that is not in the CA store - use this \n       to check the signature */\n    if (asn1_compare_dn(cert->ca_cert_dn, cert->cert_dn) == 0)\n    {\n        is_self_signed = 1;\n        ctx = cert->rsa_ctx->bi_ctx;\n        mod = cert->rsa_ctx->m;\n        expn = cert->rsa_ctx->e;\n    }\n\n    gettimeofday(&tv, NULL);\n\n    /* check the not before date */\n    if (tv.tv_sec < cert->not_before)\n    {\n        ret = X509_VFY_ERROR_NOT_YET_VALID;\n        goto end_verify;\n    }\n\n    /* check the not after date */\n    if (tv.tv_sec > cert->not_after)\n    {\n        ret = X509_VFY_ERROR_EXPIRED;\n        goto end_verify;\n    }\n\n    if (cert->basic_constraint_present)\n    {\n        /* If the cA boolean is not asserted,\n           then the keyCertSign bit in the key usage extension MUST NOT be\n           asserted. */\n        if (!cert->basic_constraint_cA &&\n                IS_SET_KEY_USAGE_FLAG(cert, KEY_USAGE_KEY_CERT_SIGN))\n        {\n            ret = X509_VFY_ERROR_BASIC_CONSTRAINT;\n            goto end_verify;\n        }\n\n        /* The pathLenConstraint field is meaningful only if the cA boolean is\n           asserted and the key usage extension, if present, asserts the\n           keyCertSign bit.  In this case, it gives the maximum number of \n           non-self-issued intermediate certificates that may follow this \n           certificate in a valid certification path. */\n        if (cert->basic_constraint_cA &&\n            (!cert->key_usage_present || \n                IS_SET_KEY_USAGE_FLAG(cert, KEY_USAGE_KEY_CERT_SIGN)) &&\n            (cert->basic_constraint_pathLenConstraint+1) < *pathLenConstraint)\n        {\n            ret = X509_VFY_ERROR_BASIC_CONSTRAINT;\n            goto end_verify;\n        }\n    }\n\n    next_cert = cert->next;\n\n    /* last cert in the chain - look for a trusted cert */\n    if (next_cert == NULL)\n    {\n       if (ca_cert_ctx != NULL) \n       {\n            /* go thru the CA store */\n            while (i < CONFIG_X509_MAX_CA_CERTS && ca_cert_ctx->cert[i])\n            {\n                /* the extension is present but the cA boolean is not \n                   asserted, then the certified public key MUST NOT be used \n                   to verify certificate signatures. */\n                if (cert->basic_constraint_present && \n                        !ca_cert_ctx->cert[i]->basic_constraint_cA)\n                    continue;\n                        \n                if (asn1_compare_dn(cert->ca_cert_dn,\n                                            ca_cert_ctx->cert[i]->cert_dn) == 0)\n                {\n                    /* use this CA certificate for signature verification */\n                    match_ca_cert = true;\n                    ctx = ca_cert_ctx->cert[i]->rsa_ctx->bi_ctx;\n                    mod = ca_cert_ctx->cert[i]->rsa_ctx->m;\n                    expn = ca_cert_ctx->cert[i]->rsa_ctx->e;\n\n\n                    break;\n                }\n\n                i++;\n            }\n        }\n\n        /* couldn't find a trusted cert (& let self-signed errors \n           be returned) */\n        if (!match_ca_cert && !is_self_signed)\n        {\n            ret = X509_VFY_ERROR_NO_TRUSTED_CERT;       \n            goto end_verify;\n        }\n    }\n    else if (asn1_compare_dn(cert->ca_cert_dn, next_cert->cert_dn) != 0)\n    {\n        /* check the chain */\n        ret = X509_VFY_ERROR_INVALID_CHAIN;\n        goto end_verify;\n    }\n    else /* use the next certificate in the chain for signature verify */\n    {\n        ctx = next_cert->rsa_ctx->bi_ctx;\n        mod = next_cert->rsa_ctx->m;\n        expn = next_cert->rsa_ctx->e;\n    }\n\n    /* cert is self signed */\n    if (!match_ca_cert && is_self_signed)\n    {\n        ret = X509_VFY_ERROR_SELF_SIGNED;\n        goto end_verify;\n    }\n\n    /* check the signature */\n    cert_sig = sig_verify(ctx, cert->signature, cert->sig_len, \n                        bi_clone(ctx, mod), bi_clone(ctx, expn));\n\n    if (cert_sig && cert->digest)\n    {\n        if (bi_compare(cert_sig, cert->digest) != 0)\n            ret = X509_VFY_ERROR_BAD_SIGNATURE;\n\n\n        bi_free(ctx, cert_sig);\n    }\n    else\n    {\n        ret = X509_VFY_ERROR_BAD_SIGNATURE;\n    }\n\n    bi_clear_cache(ctx);\n\n    if (ret)\n        goto end_verify;\n\n    /* go down the certificate chain using recursion. */\n    if (next_cert != NULL)\n    {\n        (*pathLenConstraint)++; /* don't include last certificate */\n        ret = x509_verify(ca_cert_ctx, next_cert, pathLenConstraint);\n    }\n\nend_verify:\n    return ret;\n}",
  "abstract_func_before": "int x509_verify(const CA_CERT_CTX *VAR_0, const X509_CTX *VAR_1, \n        int *VAR_2) \n{\n    int VAR_3 = VAR_4, VAR_5 = 0;\n    bigint *VAR_6;\n    X509_CTX *VAR_7 = NULL;\n    BI_CTX *VAR_8 = NULL;\n    bigint *VAR_9 = NULL, *VAR_10 = NULL;\n    int VAR_11 = 0;\n    struct timeval VAR_12;\n    uint8_t VAR_13 = 0;\n\n    if (VAR_1 == NULL)\n    {\n        VAR_3 = VAR_14;       \n        goto end_verify;\n    }\n\n    /* COMMENT_0 */\n                                \n    if (asn1_compare_dn(VAR_1->ca_cert_dn, VAR_1->cert_dn) == 0)\n    {\n        VAR_13 = 1;\n        VAR_8 = VAR_1->rsa_ctx->bi_ctx;\n        VAR_9 = VAR_1->rsa_ctx->m;\n        VAR_10 = VAR_1->rsa_ctx->e;\n    }\n\n    gettimeofday(&VAR_12, NULL);\n\n    /* COMMENT_2 */\n    if (VAR_12.tv_sec < VAR_1->not_before)\n    {\n        VAR_3 = VAR_15;\n        goto end_verify;\n    }\n\n    /* COMMENT_3 */\n    if (VAR_12.tv_sec > VAR_1->not_after)\n    {\n        VAR_3 = VAR_16;\n        goto end_verify;\n    }\n\n    if (VAR_1->basic_constraint_present)\n    {\n        /* COMMENT_4 */\n                                                                          \n                       \n        if (!VAR_1->basic_constraint_cA &&\n                IS_SET_KEY_USAGE_FLAG(VAR_1, VAR_17))\n        {\n            VAR_3 = VAR_18;\n            goto end_verify;\n        }\n\n        /* COMMENT_7 */\n                                                                        \n                                                                          \n                                                                          \n                                                        \n        if (VAR_1->basic_constraint_cA &&\n            (!VAR_1->key_usage_present || \n                IS_SET_KEY_USAGE_FLAG(VAR_1, VAR_17)) &&\n            (VAR_1->basic_constraint_pathLenConstraint+1) < *VAR_2)\n        {\n            VAR_3 = VAR_18;\n            goto end_verify;\n        }\n    }\n\n    VAR_7 = VAR_1->next;\n\n    /* COMMENT_12 */\n    if (VAR_7 == NULL)\n    {\n       if (VAR_0 != NULL) \n       {\n            /* COMMENT_13 */\n            while (VAR_5 < VAR_19 && VAR_0->cert[VAR_5])\n            {\n                /* COMMENT_14 */\n                                                                            \n                                                       \n                if (VAR_1->basic_constraint_present && \n                        !VAR_0->cert[VAR_5]->basic_constraint_cA)\n                    continue;\n                        \n                if (asn1_compare_dn(VAR_1->ca_cert_dn,\n                                            VAR_0->cert[VAR_5]->cert_dn) == 0)\n                {\n                    /* COMMENT_17 */\n                    VAR_11 = true;\n                    VAR_8 = VAR_0->cert[VAR_5]->rsa_ctx->bi_ctx;\n                    VAR_9 = VAR_0->cert[VAR_5]->rsa_ctx->m;\n                    VAR_10 = VAR_0->cert[VAR_5]->rsa_ctx->e;\n\n\n                    break;\n                }\n\n                VAR_5++;\n            }\n        }\n\n        /* COMMENT_18 */\n                          \n        if (!VAR_11 && !VAR_13)\n        {\n            VAR_3 = VAR_14;       \n            goto end_verify;\n        }\n    }\n    else if (asn1_compare_dn(VAR_1->ca_cert_dn, VAR_7->cert_dn) != 0)\n    {\n        /* COMMENT_20 */\n        VAR_3 = VAR_20;\n        goto end_verify;\n    }\n    else /* COMMENT_21 */\n    {\n        VAR_8 = VAR_7->rsa_ctx->bi_ctx;\n        VAR_9 = VAR_7->rsa_ctx->m;\n        VAR_10 = VAR_7->rsa_ctx->e;\n    }\n\n    /* COMMENT_22 */\n    if (!VAR_11 && VAR_13)\n    {\n        VAR_3 = VAR_21;\n        goto end_verify;\n    }\n\n    /* COMMENT_23 */\n    VAR_6 = sig_verify(VAR_8, VAR_1->signature, VAR_1->sig_len, \n                        bi_clone(VAR_8, VAR_9), bi_clone(VAR_8, VAR_10));\n\n    if (VAR_6 && VAR_1->digest)\n    {\n        if (bi_compare(VAR_6, VAR_1->digest) != 0)\n            VAR_3 = VAR_22;\n\n\n        bi_free(VAR_8, VAR_6);\n    }\n    else\n    {\n        VAR_3 = VAR_22;\n    }\n\n    bi_clear_cache(VAR_8);\n\n    if (VAR_3)\n        goto end_verify;\n\n    /* COMMENT_24 */\n    if (VAR_7 != NULL)\n    {\n        (*VAR_2)++; /* COMMENT_25 */\n        VAR_3 = x509_verify(VAR_0, VAR_7, VAR_2);\n    }\n\nend_verify:\n    return VAR_3;\n}",
  "func_graph_path_before": "igrr/axtls-8266/5efe2947ab45e81d84b5f707c51d1c64be52f36c/x509.c/vul/before/0.json",
  "func": "int x509_verify(const CA_CERT_CTX *ca_cert_ctx, const X509_CTX *cert, \n        int *pathLenConstraint) \n{\n    int ret = X509_OK, i = 0;\n    bigint *cert_sig;\n    X509_CTX *next_cert = NULL;\n    BI_CTX *ctx = NULL;\n    bigint *mod = NULL, *expn = NULL;\n    int match_ca_cert = 0;\n    struct timeval tv;\n    uint8_t is_self_signed = 0;\n\n    if (cert == NULL)\n    {\n        ret = X509_VFY_ERROR_NO_TRUSTED_CERT;       \n        goto end_verify;\n    }\n\n    /* a self-signed certificate that is not in the CA store - use this \n       to check the signature */\n    if (asn1_compare_dn(cert->ca_cert_dn, cert->cert_dn) == 0)\n    {\n        is_self_signed = 1;\n        ctx = cert->rsa_ctx->bi_ctx;\n        mod = cert->rsa_ctx->m;\n        expn = cert->rsa_ctx->e;\n    }\n\n    gettimeofday(&tv, NULL);\n\n    /* check the not before date */\n    if (tv.tv_sec < cert->not_before)\n    {\n        ret = X509_VFY_ERROR_NOT_YET_VALID;\n        goto end_verify;\n    }\n\n    /* check the not after date */\n    if (tv.tv_sec > cert->not_after)\n    {\n        ret = X509_VFY_ERROR_EXPIRED;\n        goto end_verify;\n    }\n\n    if (cert->basic_constraint_present)\n    {\n        /* If the cA boolean is not asserted,\n           then the keyCertSign bit in the key usage extension MUST NOT be\n           asserted. */\n        if (!cert->basic_constraint_cA &&\n                IS_SET_KEY_USAGE_FLAG(cert, KEY_USAGE_KEY_CERT_SIGN))\n        {\n            ret = X509_VFY_ERROR_BASIC_CONSTRAINT;\n            goto end_verify;\n        }\n\n        /* The pathLenConstraint field is meaningful only if the cA boolean is\n           asserted and the key usage extension, if present, asserts the\n           keyCertSign bit.  In this case, it gives the maximum number of \n           non-self-issued intermediate certificates that may follow this \n           certificate in a valid certification path. */\n        if (cert->basic_constraint_cA &&\n            (!cert->key_usage_present || \n                IS_SET_KEY_USAGE_FLAG(cert, KEY_USAGE_KEY_CERT_SIGN)) &&\n            (cert->basic_constraint_pathLenConstraint+1) < *pathLenConstraint)\n        {\n            ret = X509_VFY_ERROR_BASIC_CONSTRAINT;\n            goto end_verify;\n        }\n    }\n\n    next_cert = cert->next;\n\n    /* last cert in the chain - look for a trusted cert */\n    if (next_cert == NULL)\n    {\n       if (ca_cert_ctx != NULL) \n       {\n            /* go thru the CA store */\n            while (i < CONFIG_X509_MAX_CA_CERTS && ca_cert_ctx->cert[i])\n            {\n                /* the extension is present but the cA boolean is not \n                   asserted, then the certified public key MUST NOT be used \n                   to verify certificate signatures. */\n                if (cert->basic_constraint_present && \n                        !ca_cert_ctx->cert[i]->basic_constraint_cA)\n                    continue;\n                        \n                if (asn1_compare_dn(cert->ca_cert_dn,\n                                            ca_cert_ctx->cert[i]->cert_dn) == 0)\n                {\n                    /* use this CA certificate for signature verification */\n                    match_ca_cert = true;\n                    ctx = ca_cert_ctx->cert[i]->rsa_ctx->bi_ctx;\n                    mod = ca_cert_ctx->cert[i]->rsa_ctx->m;\n                    expn = ca_cert_ctx->cert[i]->rsa_ctx->e;\n\n\n                    break;\n                }\n\n                i++;\n            }\n        }\n\n        /* couldn't find a trusted cert (& let self-signed errors \n           be returned) */\n        if (!match_ca_cert && !is_self_signed)\n        {\n            ret = X509_VFY_ERROR_NO_TRUSTED_CERT;       \n            goto end_verify;\n        }\n    }\n    else if (asn1_compare_dn(cert->ca_cert_dn, next_cert->cert_dn) != 0)\n    {\n        /* check the chain */\n        ret = X509_VFY_ERROR_INVALID_CHAIN;\n        goto end_verify;\n    }\n    else /* use the next certificate in the chain for signature verify */\n    {\n        ctx = next_cert->rsa_ctx->bi_ctx;\n        mod = next_cert->rsa_ctx->m;\n        expn = next_cert->rsa_ctx->e;\n    }\n\n    /* cert is self signed */\n    if (!match_ca_cert && is_self_signed)\n    {\n        ret = X509_VFY_ERROR_SELF_SIGNED;\n        goto end_verify;\n    }\n\n    /* check the signature */\n    cert_sig = sig_verify(ctx, cert->signature, cert->sig_len, cert->sig_type,\n                        bi_clone(ctx, mod), bi_clone(ctx, expn));\n\n    if (cert_sig && cert->digest)\n    {\n        if (bi_compare(cert_sig, cert->digest) != 0)\n            ret = X509_VFY_ERROR_BAD_SIGNATURE;\n\n\n        bi_free(ctx, cert_sig);\n    }\n    else\n    {\n        ret = X509_VFY_ERROR_BAD_SIGNATURE;\n    }\n\n    bi_clear_cache(ctx);\n\n    if (ret)\n        goto end_verify;\n\n    /* go down the certificate chain using recursion. */\n    if (next_cert != NULL)\n    {\n        (*pathLenConstraint)++; /* don't include last certificate */\n        ret = x509_verify(ca_cert_ctx, next_cert, pathLenConstraint);\n    }\n\nend_verify:\n    return ret;\n}",
  "abstract_func": "int x509_verify(const CA_CERT_CTX *VAR_0, const X509_CTX *VAR_1, \n        int *VAR_2) \n{\n    int VAR_3 = VAR_4, VAR_5 = 0;\n    bigint *VAR_6;\n    X509_CTX *VAR_7 = NULL;\n    BI_CTX *VAR_8 = NULL;\n    bigint *VAR_9 = NULL, *VAR_10 = NULL;\n    int VAR_11 = 0;\n    struct timeval VAR_12;\n    uint8_t VAR_13 = 0;\n\n    if (VAR_1 == NULL)\n    {\n        VAR_3 = VAR_14;       \n        goto end_verify;\n    }\n\n    /* COMMENT_0 */\n                                \n    if (asn1_compare_dn(VAR_1->ca_cert_dn, VAR_1->cert_dn) == 0)\n    {\n        VAR_13 = 1;\n        VAR_8 = VAR_1->rsa_ctx->bi_ctx;\n        VAR_9 = VAR_1->rsa_ctx->m;\n        VAR_10 = VAR_1->rsa_ctx->e;\n    }\n\n    gettimeofday(&VAR_12, NULL);\n\n    /* COMMENT_2 */\n    if (VAR_12.tv_sec < VAR_1->not_before)\n    {\n        VAR_3 = VAR_15;\n        goto end_verify;\n    }\n\n    /* COMMENT_3 */\n    if (VAR_12.tv_sec > VAR_1->not_after)\n    {\n        VAR_3 = VAR_16;\n        goto end_verify;\n    }\n\n    if (VAR_1->basic_constraint_present)\n    {\n        /* COMMENT_4 */\n                                                                          \n                       \n        if (!VAR_1->basic_constraint_cA &&\n                IS_SET_KEY_USAGE_FLAG(VAR_1, VAR_17))\n        {\n            VAR_3 = VAR_18;\n            goto end_verify;\n        }\n\n        /* COMMENT_7 */\n                                                                        \n                                                                          \n                                                                          \n                                                        \n        if (VAR_1->basic_constraint_cA &&\n            (!VAR_1->key_usage_present || \n                IS_SET_KEY_USAGE_FLAG(VAR_1, VAR_17)) &&\n            (VAR_1->basic_constraint_pathLenConstraint+1) < *VAR_2)\n        {\n            VAR_3 = VAR_18;\n            goto end_verify;\n        }\n    }\n\n    VAR_7 = VAR_1->next;\n\n    /* COMMENT_12 */\n    if (VAR_7 == NULL)\n    {\n       if (VAR_0 != NULL) \n       {\n            /* COMMENT_13 */\n            while (VAR_5 < VAR_19 && VAR_0->cert[VAR_5])\n            {\n                /* COMMENT_14 */\n                                                                            \n                                                       \n                if (VAR_1->basic_constraint_present && \n                        !VAR_0->cert[VAR_5]->basic_constraint_cA)\n                    continue;\n                        \n                if (asn1_compare_dn(VAR_1->ca_cert_dn,\n                                            VAR_0->cert[VAR_5]->cert_dn) == 0)\n                {\n                    /* COMMENT_17 */\n                    VAR_11 = true;\n                    VAR_8 = VAR_0->cert[VAR_5]->rsa_ctx->bi_ctx;\n                    VAR_9 = VAR_0->cert[VAR_5]->rsa_ctx->m;\n                    VAR_10 = VAR_0->cert[VAR_5]->rsa_ctx->e;\n\n\n                    break;\n                }\n\n                VAR_5++;\n            }\n        }\n\n        /* COMMENT_18 */\n                          \n        if (!VAR_11 && !VAR_13)\n        {\n            VAR_3 = VAR_14;       \n            goto end_verify;\n        }\n    }\n    else if (asn1_compare_dn(VAR_1->ca_cert_dn, VAR_7->cert_dn) != 0)\n    {\n        /* COMMENT_20 */\n        VAR_3 = VAR_20;\n        goto end_verify;\n    }\n    else /* COMMENT_21 */\n    {\n        VAR_8 = VAR_7->rsa_ctx->bi_ctx;\n        VAR_9 = VAR_7->rsa_ctx->m;\n        VAR_10 = VAR_7->rsa_ctx->e;\n    }\n\n    /* COMMENT_22 */\n    if (!VAR_11 && VAR_13)\n    {\n        VAR_3 = VAR_21;\n        goto end_verify;\n    }\n\n    /* COMMENT_23 */\n    VAR_6 = sig_verify(VAR_8, VAR_1->signature, VAR_1->sig_len, VAR_1->sig_type,\n                        bi_clone(VAR_8, VAR_9), bi_clone(VAR_8, VAR_10));\n\n    if (VAR_6 && VAR_1->digest)\n    {\n        if (bi_compare(VAR_6, VAR_1->digest) != 0)\n            VAR_3 = VAR_22;\n\n\n        bi_free(VAR_8, VAR_6);\n    }\n    else\n    {\n        VAR_3 = VAR_22;\n    }\n\n    bi_clear_cache(VAR_8);\n\n    if (VAR_3)\n        goto end_verify;\n\n    /* COMMENT_24 */\n    if (VAR_7 != NULL)\n    {\n        (*VAR_2)++; /* COMMENT_25 */\n        VAR_3 = x509_verify(VAR_0, VAR_7, VAR_2);\n    }\n\nend_verify:\n    return VAR_3;\n}",
  "func_graph_path": "igrr/axtls-8266/5efe2947ab45e81d84b5f707c51d1c64be52f36c/x509.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -132,7 +132,7 @@\n     }\n \n     /* check the signature */\n-    cert_sig = sig_verify(ctx, cert->signature, cert->sig_len, \n+    cert_sig = sig_verify(ctx, cert->signature, cert->sig_len, cert->sig_type,\n                         bi_clone(ctx, mod), bi_clone(ctx, expn));\n \n     if (cert_sig && cert->digest)",
  "diff_line_info": {
    "deleted_lines": [
      "    cert_sig = sig_verify(ctx, cert->signature, cert->sig_len, "
    ],
    "added_lines": [
      "    cert_sig = sig_verify(ctx, cert->signature, cert->sig_len, cert->sig_type,"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/igrr/axtls-8266/pull/60",
  "description": {
    "pr_info": {
      "title": "Apply CVE fixes for X509 parsing",
      "number": 60
    },
    "comment": [
      "Apply patches developed by Sze Yiu which correct a vulnerability in\r\nX509 parsing.  See CVE-2018-16150 and CVE-2018-16149 for more info.",
      "Yay, more CVEs this week! Thanks!"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}