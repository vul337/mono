{
  "cve_id": "CVE-2016-10130",
  "cwe_ids": [
    "CWE-284"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "libgit2",
  "commit_msg": "http: check certificate validity before clobbering the error variable",
  "commit_hash": "b5c6a1b407b7f8b952bded2789593b68b1876211",
  "git_url": "https://github.com/libgit2/libgit2/commit/b5c6a1b407b7f8b952bded2789593b68b1876211",
  "file_path": "src/transports/http.c",
  "func_name": "http_connect",
  "func_before": "static int http_connect(http_subtransport *t)\n{\n\tint error;\n\tchar *proxy_url;\n\n\tif (t->connected &&\n\t\thttp_should_keep_alive(&t->parser) &&\n\t\tt->parse_finished)\n\t\treturn 0;\n\n\tif (t->io) {\n\t\tgit_stream_close(t->io);\n\t\tgit_stream_free(t->io);\n\t\tt->io = NULL;\n\t\tt->connected = 0;\n\t}\n\n\tif (t->connection_data.use_ssl) {\n\t\terror = git_tls_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n\t} else {\n#ifdef GIT_CURL\n\t\terror = git_curl_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n#else\n\t\terror = git_socket_stream_new(&t->io,  t->connection_data.host, t->connection_data.port);\n#endif\n\t}\n\n\tif (error < 0)\n\t\treturn error;\n\n\tGITERR_CHECK_VERSION(t->io, GIT_STREAM_VERSION, \"git_stream\");\n\n\tif (git_stream_supports_proxy(t->io) &&\n\t    !git_remote__get_http_proxy(t->owner->owner, !!t->connection_data.use_ssl, &proxy_url)) {\n\t\terror = git_stream_set_proxy(t->io, proxy_url);\n\t\tgit__free(proxy_url);\n\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\n\terror = git_stream_connect(t->io);\n\n#if defined(GIT_OPENSSL) || defined(GIT_SECURE_TRANSPORT) || defined(GIT_CURL)\n\tif ((!error || error == GIT_ECERTIFICATE) && t->owner->certificate_check_cb != NULL &&\n\t    git_stream_is_encrypted(t->io)) {\n\t\tgit_cert *cert;\n\t\tint is_valid;\n\n\t\tif ((error = git_stream_certificate(&cert, t->io)) < 0)\n\t\t\treturn error;\n\n\t\tgiterr_clear();\n\t\tis_valid = error != GIT_ECERTIFICATE;\n\t\terror = t->owner->certificate_check_cb(cert, is_valid, t->connection_data.host, t->owner->message_cb_payload);\n\n\t\tif (error < 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set(GITERR_NET, \"user cancelled certificate check\");\n\n\t\t\treturn error;\n\t\t}\n\t}\n#endif\n\tif (error < 0)\n\t\treturn error;\n\n\tt->connected = 1;\n\treturn 0;\n}",
  "abstract_func_before": "static int http_connect(http_subtransport *VAR_0)\n{\n\tint VAR_1;\n\tchar *VAR_2;\n\n\tif (VAR_0->connected &&\n\t\thttp_should_keep_alive(&VAR_0->parser) &&\n\t\tVAR_0->parse_finished)\n\t\treturn 0;\n\n\tif (VAR_0->io) {\n\t\tgit_stream_close(VAR_0->io);\n\t\tgit_stream_free(VAR_0->io);\n\t\tVAR_0->io = NULL;\n\t\tVAR_0->connected = 0;\n\t}\n\n\tif (VAR_0->connection_data.use_ssl) {\n\t\tVAR_1 = git_tls_stream_new(&VAR_0->io, VAR_0->connection_data.host, VAR_0->connection_data.port);\n\t} else {\n#ifdef VAR_3\n\t\tVAR_1 = git_curl_stream_new(&VAR_0->io, VAR_0->connection_data.host, VAR_0->connection_data.port);\n#else\n\t\tVAR_1 = git_socket_stream_new(&VAR_0->io,  VAR_0->connection_data.host, VAR_0->connection_data.port);\n#endif\n\t}\n\n\tif (VAR_1 < 0)\n\t\treturn VAR_1;\n\n\tGITERR_CHECK_VERSION(VAR_0->io, VAR_4, \"git_stream\");\n\n\tif (git_stream_supports_proxy(VAR_0->io) &&\n\t    !git_remote__get_http_proxy(VAR_0->owner->owner, !!VAR_0->connection_data.use_ssl, &VAR_2)) {\n\t\tVAR_1 = git_stream_set_proxy(VAR_0->io, VAR_2);\n\t\tgit__free(VAR_2);\n\n\t\tif (VAR_1 < 0)\n\t\t\treturn VAR_1;\n\t}\n\n\tVAR_1 = git_stream_connect(VAR_0->io);\n\n#if defined(VAR_5) || defined(VAR_6) || defined(VAR_3)\n\tif ((!VAR_1 || VAR_1 == VAR_7) && VAR_0->owner->certificate_check_cb != NULL &&\n\t    git_stream_is_encrypted(VAR_0->io)) {\n\t\tgit_cert *VAR_8;\n\t\tint VAR_9;\n\n\t\tif ((VAR_1 = git_stream_certificate(&VAR_8, VAR_0->io)) < 0)\n\t\t\treturn VAR_1;\n\n\t\tgiterr_clear();\n\t\tVAR_9 = VAR_1 != VAR_7;\n\t\tVAR_1 = VAR_0->owner->certificate_check_cb(VAR_8, VAR_9, VAR_0->connection_data.host, VAR_0->owner->message_cb_payload);\n\n\t\tif (VAR_1 < 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set(VAR_10, \"user cancelled certificate check\");\n\n\t\t\treturn VAR_1;\n\t\t}\n\t}\n#endif\n\tif (VAR_1 < 0)\n\t\treturn VAR_1;\n\n\tVAR_0->connected = 1;\n\treturn 0;\n}",
  "func_graph_path_before": "libgit2/b5c6a1b407b7f8b952bded2789593b68b1876211/http.c/vul/before/0.json",
  "func": "static int http_connect(http_subtransport *t)\n{\n\tint error;\n\tchar *proxy_url;\n\n\tif (t->connected &&\n\t\thttp_should_keep_alive(&t->parser) &&\n\t\tt->parse_finished)\n\t\treturn 0;\n\n\tif (t->io) {\n\t\tgit_stream_close(t->io);\n\t\tgit_stream_free(t->io);\n\t\tt->io = NULL;\n\t\tt->connected = 0;\n\t}\n\n\tif (t->connection_data.use_ssl) {\n\t\terror = git_tls_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n\t} else {\n#ifdef GIT_CURL\n\t\terror = git_curl_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n#else\n\t\terror = git_socket_stream_new(&t->io,  t->connection_data.host, t->connection_data.port);\n#endif\n\t}\n\n\tif (error < 0)\n\t\treturn error;\n\n\tGITERR_CHECK_VERSION(t->io, GIT_STREAM_VERSION, \"git_stream\");\n\n\tif (git_stream_supports_proxy(t->io) &&\n\t    !git_remote__get_http_proxy(t->owner->owner, !!t->connection_data.use_ssl, &proxy_url)) {\n\t\terror = git_stream_set_proxy(t->io, proxy_url);\n\t\tgit__free(proxy_url);\n\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\n\terror = git_stream_connect(t->io);\n\n#if defined(GIT_OPENSSL) || defined(GIT_SECURE_TRANSPORT) || defined(GIT_CURL)\n\tif ((!error || error == GIT_ECERTIFICATE) && t->owner->certificate_check_cb != NULL &&\n\t    git_stream_is_encrypted(t->io)) {\n\t\tgit_cert *cert;\n\t\tint is_valid = (error == GIT_OK);\n\n\t\tif ((error = git_stream_certificate(&cert, t->io)) < 0)\n\t\t\treturn error;\n\n\t\tgiterr_clear();\n\t\terror = t->owner->certificate_check_cb(cert, is_valid, t->connection_data.host, t->owner->message_cb_payload);\n\n\t\tif (error < 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set(GITERR_NET, \"user cancelled certificate check\");\n\n\t\t\treturn error;\n\t\t}\n\t}\n#endif\n\tif (error < 0)\n\t\treturn error;\n\n\tt->connected = 1;\n\treturn 0;\n}",
  "abstract_func": "static int http_connect(http_subtransport *VAR_0)\n{\n\tint VAR_1;\n\tchar *VAR_2;\n\n\tif (VAR_0->connected &&\n\t\thttp_should_keep_alive(&VAR_0->parser) &&\n\t\tVAR_0->parse_finished)\n\t\treturn 0;\n\n\tif (VAR_0->io) {\n\t\tgit_stream_close(VAR_0->io);\n\t\tgit_stream_free(VAR_0->io);\n\t\tVAR_0->io = NULL;\n\t\tVAR_0->connected = 0;\n\t}\n\n\tif (VAR_0->connection_data.use_ssl) {\n\t\tVAR_1 = git_tls_stream_new(&VAR_0->io, VAR_0->connection_data.host, VAR_0->connection_data.port);\n\t} else {\n#ifdef VAR_3\n\t\tVAR_1 = git_curl_stream_new(&VAR_0->io, VAR_0->connection_data.host, VAR_0->connection_data.port);\n#else\n\t\tVAR_1 = git_socket_stream_new(&VAR_0->io,  VAR_0->connection_data.host, VAR_0->connection_data.port);\n#endif\n\t}\n\n\tif (VAR_1 < 0)\n\t\treturn VAR_1;\n\n\tGITERR_CHECK_VERSION(VAR_0->io, VAR_4, \"git_stream\");\n\n\tif (git_stream_supports_proxy(VAR_0->io) &&\n\t    !git_remote__get_http_proxy(VAR_0->owner->owner, !!VAR_0->connection_data.use_ssl, &VAR_2)) {\n\t\tVAR_1 = git_stream_set_proxy(VAR_0->io, VAR_2);\n\t\tgit__free(VAR_2);\n\n\t\tif (VAR_1 < 0)\n\t\t\treturn VAR_1;\n\t}\n\n\tVAR_1 = git_stream_connect(VAR_0->io);\n\n#if defined(VAR_5) || defined(VAR_6) || defined(VAR_3)\n\tif ((!VAR_1 || VAR_1 == VAR_7) && VAR_0->owner->certificate_check_cb != NULL &&\n\t    git_stream_is_encrypted(VAR_0->io)) {\n\t\tgit_cert *VAR_8;\n\t\tint VAR_9 = (VAR_1 == VAR_10);\n\n\t\tif ((VAR_1 = git_stream_certificate(&VAR_8, VAR_0->io)) < 0)\n\t\t\treturn VAR_1;\n\n\t\tgiterr_clear();\n\t\tVAR_1 = VAR_0->owner->certificate_check_cb(VAR_8, VAR_9, VAR_0->connection_data.host, VAR_0->owner->message_cb_payload);\n\n\t\tif (VAR_1 < 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set(VAR_11, \"user cancelled certificate check\");\n\n\t\t\treturn VAR_1;\n\t\t}\n\t}\n#endif\n\tif (VAR_1 < 0)\n\t\treturn VAR_1;\n\n\tVAR_0->connected = 1;\n\treturn 0;\n}",
  "func_graph_path": "libgit2/b5c6a1b407b7f8b952bded2789593b68b1876211/http.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -45,13 +45,12 @@\n \tif ((!error || error == GIT_ECERTIFICATE) && t->owner->certificate_check_cb != NULL &&\n \t    git_stream_is_encrypted(t->io)) {\n \t\tgit_cert *cert;\n-\t\tint is_valid;\n+\t\tint is_valid = (error == GIT_OK);\n \n \t\tif ((error = git_stream_certificate(&cert, t->io)) < 0)\n \t\t\treturn error;\n \n \t\tgiterr_clear();\n-\t\tis_valid = error != GIT_ECERTIFICATE;\n \t\terror = t->owner->certificate_check_cb(cert, is_valid, t->connection_data.host, t->owner->message_cb_payload);\n \n \t\tif (error < 0) {",
  "diff_line_info": {
    "deleted_lines": [
      "\t\tint is_valid;",
      "\t\tis_valid = error != GIT_ECERTIFICATE;"
    ],
    "added_lines": [
      "\t\tint is_valid = (error == GIT_OK);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libgit2/libgit2/pull/4075",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/libgit2/libgit2/pull/4075: 403 Client Error: Forbidden for url: https://api.github.com/repos/libgit2/libgit2/pulls/4075",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95  \n\nThe patch addresses a buffer boundary check error and ensures proper certificate validity checks, directly fixing known security issues. The code changes align with the description, confirming it's a security fix."
}