{
  "cve_id": "CVE-2021-32843",
  "cwe_ids": [
    "CWE-476"
  ],
  "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "moby/hyperkit",
  "commit_msg": "Fix vi_pci_read null vc_cfgread function pointer dereference (GHSL-2021-054)\n\nThis is backport of what is done in bhyve\n\nSigned-off-by: Frederic Dalleau <frederic.dalleau@docker.com>",
  "commit_hash": "df0e46c7dbfd81a957d85e449ba41b52f6f7beb4",
  "git_url": "https://github.com/moby/hyperkit/commit/df0e46c7dbfd81a957d85e449ba41b52f6f7beb4",
  "file_path": "src/lib/virtio.c",
  "func_name": "vi_pci_read",
  "func_before": "uint64_t\nvi_pci_read(UNUSED int vcpu, struct pci_devinst *pi, int baridx,\n\tuint64_t offset, int size)\n{\n\tstruct virtio_softc *vs = pi->pi_arg;\n\tstruct virtio_consts *vc;\n\tstruct config_reg *cr;\n\tuint64_t virtio_config_size, max;\n\tconst char *name;\n\tuint32_t newoff;\n\tuint32_t value;\n\tint error;\n\n\tif (vs->vs_flags & VIRTIO_USE_MSIX) {\n\t\tif (baridx == pci_msix_table_bar(pi) ||\n\t\t    baridx == pci_msix_pba_bar(pi)) {\n\t\t\treturn (pci_emul_msix_tread(pi, offset, size));\n\t\t}\n\t}\n\n\t/* XXX probably should do something better than just assert() */\n\tassert(baridx == 0);\n\n\tif (vs->vs_mtx)\n\t\tpthread_mutex_lock(vs->vs_mtx);\n\n\tvc = vs->vs_vc;\n\tname = vc->vc_name;\n\tvalue = size == 1 ? 0xff : size == 2 ? 0xffff : 0xffffffff;\n\n\tif (size != 1 && size != 2 && size != 4)\n\t\tgoto bad;\n\n\tif (pci_msix_enabled(pi))\n\t\tvirtio_config_size = VTCFG_R_CFG1;\n\telse\n\t\tvirtio_config_size = VTCFG_R_CFG0;\n\n\tif (offset >= virtio_config_size) {\n\t\t/*\n\t\t * Subtract off the standard size (including MSI-X\n\t\t * registers if enabled) and dispatch to underlying driver.\n\t\t * If that fails, fall into general code.\n\t\t */\n\t\tnewoff = (uint32_t) (offset - virtio_config_size);\n\t\tmax = vc->vc_cfgsize ? vc->vc_cfgsize : 0x100000000;\n\t\tif ((newoff + ((unsigned) size)) > max)\n\t\t\tgoto bad;\n\t\terror = (*vc->vc_cfgread)(DEV_SOFTC(vs), ((int) newoff), size, &value);\n\t\tif (!error)\n\t\t\tgoto done;\n\t}\n\nbad:\n\tcr = vi_find_cr((int) offset);\n\tif (cr == NULL || cr->cr_size != size) {\n\t\tif (cr != NULL) {\n\t\t\t/* offset must be OK, so size must be bad */\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s: read from %s: bad size %d\\r\\n\",\n\t\t\t    name, cr->cr_name, size);\n\t\t} else {\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s: read from bad offset/size %jd/%d\\r\\n\",\n\t\t\t    name, (uintmax_t)offset, size);\n\t\t}\n\t\tgoto done;\n\t}\n\n\tswitch (offset) {\n\tcase VTCFG_R_HOSTCAP:\n\t\tvalue = (uint32_t) vc->vc_hv_caps;\n\t\tbreak;\n\tcase VTCFG_R_GUESTCAP:\n\t\tvalue = vs->vs_negotiated_caps;\n\t\tbreak;\n\tcase VTCFG_R_PFN:\n\t\tif (vs->vs_curq < vc->vc_nvq)\n\t\t\tvalue = vs->vs_queues[vs->vs_curq].vq_pfn;\n\t\tbreak;\n\tcase VTCFG_R_QNUM:\n\t\tvalue = vs->vs_curq < vc->vc_nvq ?\n\t\t    vs->vs_queues[vs->vs_curq].vq_qsize : 0;\n\t\tbreak;\n\tcase VTCFG_R_QSEL:\n\t\tvalue = (uint32_t) (vs->vs_curq);\n\t\tbreak;\n\tcase VTCFG_R_QNOTIFY:\n\t\tvalue = 0;\t/* XXX */\n\t\tbreak;\n\tcase VTCFG_R_STATUS:\n\t\tvalue = vs->vs_status;\n\t\tbreak;\n\tcase VTCFG_R_ISR:\n\t\tvalue = vs->vs_isr;\n\t\tvs->vs_isr = 0;\t\t/* a read clears this flag */\n\t\tif (value)\n\t\t\tpci_lintr_deassert(pi);\n\t\tbreak;\n\tcase VTCFG_R_CFGVEC:\n\t\tvalue = vs->vs_msix_cfg_idx;\n\t\tbreak;\n\tcase VTCFG_R_QVEC:\n\t\tvalue = vs->vs_curq < vc->vc_nvq ?\n\t\t    vs->vs_queues[vs->vs_curq].vq_msix_idx :\n\t\t    VIRTIO_MSI_NO_VECTOR;\n\t\tbreak;\n\t}\ndone:\n\tif (vs->vs_mtx)\n\t\tpthread_mutex_unlock(vs->vs_mtx);\n\treturn (value);\n}",
  "abstract_func_before": "uint64_t\nvi_pci_read(UNUSED int VAR_0, struct pci_devinst *VAR_1, int VAR_2,\n\tuint64_t VAR_3, int VAR_4)\n{\n\tstruct virtio_softc *VAR_5 = VAR_1->pi_arg;\n\tstruct virtio_consts *VAR_6;\n\tstruct config_reg *VAR_7;\n\tuint64_t VAR_8, VAR_9;\n\tconst char *VAR_10;\n\tuint32_t VAR_11;\n\tuint32_t VAR_12;\n\tint VAR_13;\n\n\tif (VAR_5->vs_flags & VAR_14) {\n\t\tif (VAR_2 == pci_msix_table_bar(VAR_1) ||\n\t\t    VAR_2 == pci_msix_pba_bar(VAR_1)) {\n\t\t\treturn (pci_emul_msix_tread(VAR_1, VAR_3, VAR_4));\n\t\t}\n\t}\n\n\t/* COMMENT_0 */\n\tassert(VAR_2 == 0);\n\n\tif (VAR_5->vs_mtx)\n\t\tpthread_mutex_lock(VAR_5->vs_mtx);\n\n\tVAR_6 = VAR_5->vs_vc;\n\tVAR_10 = VAR_6->vc_name;\n\tVAR_12 = VAR_4 == 1 ? 0xff : VAR_4 == 2 ? 0xffff : 0xffffffff;\n\n\tif (VAR_4 != 1 && VAR_4 != 2 && VAR_4 != 4)\n\t\tgoto bad;\n\n\tif (pci_msix_enabled(VAR_1))\n\t\tVAR_8 = VAR_15;\n\telse\n\t\tVAR_8 = VAR_16;\n\n\tif (VAR_3 >= VAR_8) {\n\t\t/* COMMENT_1 */\n                                                    \n                                                             \n                                           \n     \n\t\tVAR_11 = (uint32_t) (VAR_3 - VAR_8);\n\t\tVAR_9 = VAR_6->vc_cfgsize ? VAR_6->vc_cfgsize : 0x100000000;\n\t\tif ((VAR_11 + ((unsigned) VAR_4)) > VAR_9)\n\t\t\tgoto bad;\n\t\tVAR_13 = (*VAR_6->vc_cfgread)(DEV_SOFTC(VAR_5), ((int) VAR_11), VAR_4, &VAR_12);\n\t\tif (!VAR_13)\n\t\t\tgoto done;\n\t}\n\nbad:\n\tVAR_7 = vi_find_cr((int) VAR_3);\n\tif (VAR_7 == NULL || VAR_7->cr_size != VAR_4) {\n\t\tif (VAR_7 != NULL) {\n\t\t\t/* COMMENT_6 */\n\t\t\tfprintf(VAR_17,\n\t\t\t    \"%s: read from %s: bad size %d\\r\\n\",\n\t\t\t    VAR_10, VAR_7->cr_name, VAR_4);\n\t\t} else {\n\t\t\tfprintf(VAR_17,\n\t\t\t    \"%s: read from bad offset/size %jd/%d\\r\\n\",\n\t\t\t    VAR_10, (uintmax_t)VAR_3, VAR_4);\n\t\t}\n\t\tgoto done;\n\t}\n\n\tswitch (VAR_3) {\n\tcase VAR_18:\n\t\tVAR_12 = (uint32_t) VAR_6->vc_hv_caps;\n\t\tbreak;\n\tcase VAR_19:\n\t\tVAR_12 = VAR_5->vs_negotiated_caps;\n\t\tbreak;\n\tcase VAR_20:\n\t\tif (VAR_5->vs_curq < VAR_6->vc_nvq)\n\t\t\tVAR_12 = VAR_5->vs_queues[VAR_5->vs_curq].vq_pfn;\n\t\tbreak;\n\tcase VAR_21:\n\t\tVAR_12 = VAR_5->vs_curq < VAR_6->vc_nvq ?\n\t\t    VAR_5->vs_queues[VAR_5->vs_curq].vq_qsize : 0;\n\t\tbreak;\n\tcase VAR_22:\n\t\tVAR_12 = (uint32_t) (VAR_5->vs_curq);\n\t\tbreak;\n\tcase VAR_23:\n\t\tVAR_12 = 0;\t/* COMMENT_7 */\n\t\tbreak;\n\tcase VAR_24:\n\t\tVAR_12 = VAR_5->vs_status;\n\t\tbreak;\n\tcase VAR_25:\n\t\tVAR_12 = VAR_5->vs_isr;\n\t\tVAR_5->vs_isr = 0;\t\t/* COMMENT_8 */\n\t\tif (VAR_12)\n\t\t\tpci_lintr_deassert(VAR_1);\n\t\tbreak;\n\tcase VAR_26:\n\t\tVAR_12 = VAR_5->vs_msix_cfg_idx;\n\t\tbreak;\n\tcase VAR_27:\n\t\tVAR_12 = VAR_5->vs_curq < VAR_6->vc_nvq ?\n\t\t    VAR_5->vs_queues[VAR_5->vs_curq].vq_msix_idx :\n\t\t    VAR_28;\n\t\tbreak;\n\t}\ndone:\n\tif (VAR_5->vs_mtx)\n\t\tpthread_mutex_unlock(VAR_5->vs_mtx);\n\treturn (VAR_12);\n}",
  "func_graph_path_before": null,
  "func": "uint64_t\nvi_pci_read(UNUSED int vcpu, struct pci_devinst *pi, int baridx,\n\tuint64_t offset, int size)\n{\n\tstruct virtio_softc *vs = pi->pi_arg;\n\tstruct virtio_consts *vc;\n\tstruct config_reg *cr;\n\tuint64_t virtio_config_size, max;\n\tconst char *name;\n\tuint32_t newoff;\n\tuint32_t value;\n\tint error;\n\n\tif (vs->vs_flags & VIRTIO_USE_MSIX) {\n\t\tif (baridx == pci_msix_table_bar(pi) ||\n\t\t    baridx == pci_msix_pba_bar(pi)) {\n\t\t\treturn (pci_emul_msix_tread(pi, offset, size));\n\t\t}\n\t}\n\n\t/* XXX probably should do something better than just assert() */\n\tassert(baridx == 0);\n\n\tif (vs->vs_mtx)\n\t\tpthread_mutex_lock(vs->vs_mtx);\n\n\tvc = vs->vs_vc;\n\tname = vc->vc_name;\n\tvalue = size == 1 ? 0xff : size == 2 ? 0xffff : 0xffffffff;\n\n\tif (size != 1 && size != 2 && size != 4)\n\t\tgoto bad;\n\n\tif (pci_msix_enabled(pi))\n\t\tvirtio_config_size = VTCFG_R_CFG1;\n\telse\n\t\tvirtio_config_size = VTCFG_R_CFG0;\n\n\tif (offset >= virtio_config_size) {\n\t\t/*\n\t\t * Subtract off the standard size (including MSI-X\n\t\t * registers if enabled) and dispatch to underlying driver.\n\t\t * If that fails, fall into general code.\n\t\t */\n\t\tnewoff = (uint32_t) (offset - virtio_config_size);\n\t\tmax = vc->vc_cfgsize ? vc->vc_cfgsize : 0x100000000;\n\t\tif ((newoff + ((unsigned) size)) > max)\n\t\t\tgoto bad;\n\t\tif (vc->vc_cfgread != NULL)\n\t\t\terror = (*vc->vc_cfgread)(DEV_SOFTC(vs), ((int) newoff), size, &value);\n\t\telse\n\t\t\terror = 0;\n\t\tif (!error)\n\t\t\tgoto done;\n\t}\n\nbad:\n\tcr = vi_find_cr((int) offset);\n\tif (cr == NULL || cr->cr_size != size) {\n\t\tif (cr != NULL) {\n\t\t\t/* offset must be OK, so size must be bad */\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s: read from %s: bad size %d\\r\\n\",\n\t\t\t    name, cr->cr_name, size);\n\t\t} else {\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s: read from bad offset/size %jd/%d\\r\\n\",\n\t\t\t    name, (uintmax_t)offset, size);\n\t\t}\n\t\tgoto done;\n\t}\n\n\tswitch (offset) {\n\tcase VTCFG_R_HOSTCAP:\n\t\tvalue = (uint32_t) vc->vc_hv_caps;\n\t\tbreak;\n\tcase VTCFG_R_GUESTCAP:\n\t\tvalue = vs->vs_negotiated_caps;\n\t\tbreak;\n\tcase VTCFG_R_PFN:\n\t\tif (vs->vs_curq < vc->vc_nvq)\n\t\t\tvalue = vs->vs_queues[vs->vs_curq].vq_pfn;\n\t\tbreak;\n\tcase VTCFG_R_QNUM:\n\t\tvalue = vs->vs_curq < vc->vc_nvq ?\n\t\t    vs->vs_queues[vs->vs_curq].vq_qsize : 0;\n\t\tbreak;\n\tcase VTCFG_R_QSEL:\n\t\tvalue = (uint32_t) (vs->vs_curq);\n\t\tbreak;\n\tcase VTCFG_R_QNOTIFY:\n\t\tvalue = 0;\t/* XXX */\n\t\tbreak;\n\tcase VTCFG_R_STATUS:\n\t\tvalue = vs->vs_status;\n\t\tbreak;\n\tcase VTCFG_R_ISR:\n\t\tvalue = vs->vs_isr;\n\t\tvs->vs_isr = 0;\t\t/* a read clears this flag */\n\t\tif (value)\n\t\t\tpci_lintr_deassert(pi);\n\t\tbreak;\n\tcase VTCFG_R_CFGVEC:\n\t\tvalue = vs->vs_msix_cfg_idx;\n\t\tbreak;\n\tcase VTCFG_R_QVEC:\n\t\tvalue = vs->vs_curq < vc->vc_nvq ?\n\t\t    vs->vs_queues[vs->vs_curq].vq_msix_idx :\n\t\t    VIRTIO_MSI_NO_VECTOR;\n\t\tbreak;\n\t}\ndone:\n\tif (vs->vs_mtx)\n\t\tpthread_mutex_unlock(vs->vs_mtx);\n\treturn (value);\n}",
  "abstract_func": "uint64_t\nvi_pci_read(UNUSED int VAR_0, struct pci_devinst *VAR_1, int VAR_2,\n\tuint64_t VAR_3, int VAR_4)\n{\n\tstruct virtio_softc *VAR_5 = VAR_1->pi_arg;\n\tstruct virtio_consts *VAR_6;\n\tstruct config_reg *VAR_7;\n\tuint64_t VAR_8, VAR_9;\n\tconst char *VAR_10;\n\tuint32_t VAR_11;\n\tuint32_t VAR_12;\n\tint VAR_13;\n\n\tif (VAR_5->vs_flags & VAR_14) {\n\t\tif (VAR_2 == pci_msix_table_bar(VAR_1) ||\n\t\t    VAR_2 == pci_msix_pba_bar(VAR_1)) {\n\t\t\treturn (pci_emul_msix_tread(VAR_1, VAR_3, VAR_4));\n\t\t}\n\t}\n\n\t/* COMMENT_0 */\n\tassert(VAR_2 == 0);\n\n\tif (VAR_5->vs_mtx)\n\t\tpthread_mutex_lock(VAR_5->vs_mtx);\n\n\tVAR_6 = VAR_5->vs_vc;\n\tVAR_10 = VAR_6->vc_name;\n\tVAR_12 = VAR_4 == 1 ? 0xff : VAR_4 == 2 ? 0xffff : 0xffffffff;\n\n\tif (VAR_4 != 1 && VAR_4 != 2 && VAR_4 != 4)\n\t\tgoto bad;\n\n\tif (pci_msix_enabled(VAR_1))\n\t\tVAR_8 = VAR_15;\n\telse\n\t\tVAR_8 = VAR_16;\n\n\tif (VAR_3 >= VAR_8) {\n\t\t/* COMMENT_1 */\n                                                    \n                                                             \n                                           \n     \n\t\tVAR_11 = (uint32_t) (VAR_3 - VAR_8);\n\t\tVAR_9 = VAR_6->vc_cfgsize ? VAR_6->vc_cfgsize : 0x100000000;\n\t\tif ((VAR_11 + ((unsigned) VAR_4)) > VAR_9)\n\t\t\tgoto bad;\n\t\tif (VAR_6->vc_cfgread != NULL)\n\t\t\tVAR_13 = (*VAR_6->vc_cfgread)(DEV_SOFTC(VAR_5), ((int) VAR_11), VAR_4, &VAR_12);\n\t\telse\n\t\t\tVAR_13 = 0;\n\t\tif (!VAR_13)\n\t\t\tgoto done;\n\t}\n\nbad:\n\tVAR_7 = vi_find_cr((int) VAR_3);\n\tif (VAR_7 == NULL || VAR_7->cr_size != VAR_4) {\n\t\tif (VAR_7 != NULL) {\n\t\t\t/* COMMENT_6 */\n\t\t\tfprintf(VAR_17,\n\t\t\t    \"%s: read from %s: bad size %d\\r\\n\",\n\t\t\t    VAR_10, VAR_7->cr_name, VAR_4);\n\t\t} else {\n\t\t\tfprintf(VAR_17,\n\t\t\t    \"%s: read from bad offset/size %jd/%d\\r\\n\",\n\t\t\t    VAR_10, (uintmax_t)VAR_3, VAR_4);\n\t\t}\n\t\tgoto done;\n\t}\n\n\tswitch (VAR_3) {\n\tcase VAR_18:\n\t\tVAR_12 = (uint32_t) VAR_6->vc_hv_caps;\n\t\tbreak;\n\tcase VAR_19:\n\t\tVAR_12 = VAR_5->vs_negotiated_caps;\n\t\tbreak;\n\tcase VAR_20:\n\t\tif (VAR_5->vs_curq < VAR_6->vc_nvq)\n\t\t\tVAR_12 = VAR_5->vs_queues[VAR_5->vs_curq].vq_pfn;\n\t\tbreak;\n\tcase VAR_21:\n\t\tVAR_12 = VAR_5->vs_curq < VAR_6->vc_nvq ?\n\t\t    VAR_5->vs_queues[VAR_5->vs_curq].vq_qsize : 0;\n\t\tbreak;\n\tcase VAR_22:\n\t\tVAR_12 = (uint32_t) (VAR_5->vs_curq);\n\t\tbreak;\n\tcase VAR_23:\n\t\tVAR_12 = 0;\t/* COMMENT_7 */\n\t\tbreak;\n\tcase VAR_24:\n\t\tVAR_12 = VAR_5->vs_status;\n\t\tbreak;\n\tcase VAR_25:\n\t\tVAR_12 = VAR_5->vs_isr;\n\t\tVAR_5->vs_isr = 0;\t\t/* COMMENT_8 */\n\t\tif (VAR_12)\n\t\t\tpci_lintr_deassert(VAR_1);\n\t\tbreak;\n\tcase VAR_26:\n\t\tVAR_12 = VAR_5->vs_msix_cfg_idx;\n\t\tbreak;\n\tcase VAR_27:\n\t\tVAR_12 = VAR_5->vs_curq < VAR_6->vc_nvq ?\n\t\t    VAR_5->vs_queues[VAR_5->vs_curq].vq_msix_idx :\n\t\t    VAR_28;\n\t\tbreak;\n\t}\ndone:\n\tif (VAR_5->vs_mtx)\n\t\tpthread_mutex_unlock(VAR_5->vs_mtx);\n\treturn (VAR_12);\n}",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -46,7 +46,10 @@\n \t\tmax = vc->vc_cfgsize ? vc->vc_cfgsize : 0x100000000;\n \t\tif ((newoff + ((unsigned) size)) > max)\n \t\t\tgoto bad;\n-\t\terror = (*vc->vc_cfgread)(DEV_SOFTC(vs), ((int) newoff), size, &value);\n+\t\tif (vc->vc_cfgread != NULL)\n+\t\t\terror = (*vc->vc_cfgread)(DEV_SOFTC(vs), ((int) newoff), size, &value);\n+\t\telse\n+\t\t\terror = 0;\n \t\tif (!error)\n \t\t\tgoto done;\n \t}",
  "diff_line_info": {
    "deleted_lines": [
      "\t\terror = (*vc->vc_cfgread)(DEV_SOFTC(vs), ((int) newoff), size, &value);"
    ],
    "added_lines": [
      "\t\tif (vc->vc_cfgread != NULL)",
      "\t\t\terror = (*vc->vc_cfgread)(DEV_SOFTC(vs), ((int) newoff), size, &value);",
      "\t\telse",
      "\t\t\terror = 0;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/moby/hyperkit/pull/313",
  "description": {
    "pr_info": {
      "title": "Various fixes",
      "number": 313
    },
    "comment": [
      "This series add some fixes for various cases that have been reported that allow the guest to trigger a crash of the virtual machine.\r\n\r\nThe first two are NULL pointer dereference and are already handled in bhyve.\r\nhttps://cgit.freebsd.org/src/tree/usr.sbin/bhyve/virtio.c#n606\r\nhttps://cgit.freebsd.org/src/tree/usr.sbin/bhyve/virtio.c#n725\r\n\r\nThe other two are unhandled returned errors in vq_getchain. For now, trace and return as in pci_vt9p_notify.\r\n\r\nLet me know what you think."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "The commit addresses a null pointer dereference issue, which is a security vulnerability. The code change adds a check to prevent dereferencing a null function pointer, preventing potential crashes or exploits.\n\n**Final Classification:** Security Vulnerability Fix\n**Confidence:** 0.9"
}