{
  "cve_id": "CVE-2021-26805",
  "cwe_ids": [
    "CWE-120"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "justdan96/tsMuxer",
  "commit_msg": "Fix an invalid delete error",
  "commit_hash": "ce0a0972aad04bedd779de38b78f13b2f740178d",
  "git_url": "https://github.com/justdan96/tsMuxer/commit/ce0a0972aad04bedd779de38b78f13b2f740178d",
  "file_path": "tsMuxer/vc1Parser.h",
  "func_name": "vc1_unescape_buffer",
  "func_before": "inline int vc1_unescape_buffer(uint8_t* src, int size)\n    {\n        if (m_nalBuffer != 0)\n            delete m_nalBuffer;\n        m_nalBuffer = new uint8_t[size];\n        int dsize = 0, i;\n        if (size < 4)\n        {\n            for (dsize = 0; dsize < size; dsize++) *m_nalBuffer++ = *src++;\n            m_nalBufferLen = size;\n            return size;\n        }\n        for (i = 0; i < size; i++, src++)\n        {\n            if (src[0] == 3 && i >= 2 && !src[-1] && !src[-2] && i < size - 1 && src[1] < 4)\n            {\n                m_nalBuffer[dsize++] = src[1];\n                src++;\n                i++;\n            }\n            else\n                m_nalBuffer[dsize++] = *src;\n        }\n        m_nalBufferLen = dsize;\n        return dsize;\n    }",
  "abstract_func_before": "inline int vc1_unescape_buffer(uint8_t* VAR_0, int VAR_1)\n    {\n        if (VAR_2 != 0)\n            delete VAR_2;\n        VAR_2 = new uint8_t[VAR_1];\n        int VAR_3 = 0, VAR_4;\n        if (VAR_1 < 4)\n        {\n            for (VAR_3 = 0; VAR_3 < VAR_1; VAR_3++) *VAR_2++ = *VAR_0++;\n            VAR_5 = VAR_1;\n            return VAR_1;\n        }\n        for (VAR_4 = 0; VAR_4 < VAR_1; VAR_4++, VAR_0++)\n        {\n            if (VAR_0[0] == 3 && VAR_4 >= 2 && !VAR_0[-1] && !VAR_0[-2] && VAR_4 < VAR_1 - 1 && VAR_0[1] < 4)\n            {\n                VAR_2[VAR_3++] = VAR_0[1];\n                VAR_0++;\n                VAR_4++;\n            }\n            else\n                VAR_2[VAR_3++] = *VAR_0;\n        }\n        VAR_5 = VAR_3;\n        return VAR_3;\n    }",
  "func_graph_path_before": "justdan96/tsMuxer/ce0a0972aad04bedd779de38b78f13b2f740178d/vc1Parser.h/vul/before/1.json",
  "func": "inline int vc1_unescape_buffer(uint8_t* src, int size)\n    {\n        if (m_nalBuffer != 0)\n            delete m_nalBuffer;\n        m_nalBuffer = new uint8_t[size];\n        int dsize = 0, i;\n        if (size < 4)\n        {\n            std::copy(src, src + size, m_nalBuffer);\n            m_nalBufferLen = size;\n            return size;\n        }\n        for (i = 0; i < size; i++, src++)\n        {\n            if (src[0] == 3 && i >= 2 && !src[-1] && !src[-2] && i < size - 1 && src[1] < 4)\n            {\n                m_nalBuffer[dsize++] = src[1];\n                src++;\n                i++;\n            }\n            else\n                m_nalBuffer[dsize++] = *src;\n        }\n        m_nalBufferLen = dsize;\n        return dsize;\n    }",
  "abstract_func": "inline int vc1_unescape_buffer(uint8_t* VAR_0, int VAR_1)\n    {\n        if (VAR_2 != 0)\n            delete VAR_2;\n        VAR_2 = new uint8_t[VAR_1];\n        int VAR_3 = 0, VAR_4;\n        if (VAR_1 < 4)\n        {\n            std::copy(VAR_0, VAR_0 + VAR_1, VAR_2);\n            VAR_5 = VAR_1;\n            return VAR_1;\n        }\n        for (VAR_4 = 0; VAR_4 < VAR_1; VAR_4++, VAR_0++)\n        {\n            if (VAR_0[0] == 3 && VAR_4 >= 2 && !VAR_0[-1] && !VAR_0[-2] && VAR_4 < VAR_1 - 1 && VAR_0[1] < 4)\n            {\n                VAR_2[VAR_3++] = VAR_0[1];\n                VAR_0++;\n                VAR_4++;\n            }\n            else\n                VAR_2[VAR_3++] = *VAR_0;\n        }\n        VAR_5 = VAR_3;\n        return VAR_3;\n    }",
  "func_graph_path": "justdan96/tsMuxer/ce0a0972aad04bedd779de38b78f13b2f740178d/vc1Parser.h/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,7 @@\n         int dsize = 0, i;\n         if (size < 4)\n         {\n-            for (dsize = 0; dsize < size; dsize++) *m_nalBuffer++ = *src++;\n+            std::copy(src, src + size, m_nalBuffer);\n             m_nalBufferLen = size;\n             return size;\n         }",
  "diff_line_info": {
    "deleted_lines": [
      "            for (dsize = 0; dsize < size; dsize++) *m_nalBuffer++ = *src++;"
    ],
    "added_lines": [
      "            std::copy(src, src + size, m_nalBuffer);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/justdan96/tsMuxer/pull/396",
  "description": {
    "pr_info": {
      "title": "Fix an invalid delete error in vc1Parser.h",
      "number": 396
    },
    "comment": [
      "The `m_nalBuffer` member was incremented in the loop while copying, which naturally led to the pointer being invalid when the destructor is executed in order to delete the array. The code was replaced with an equivalent `std::copy` call.\r\nAlso, replaced the invalid `delete` with `delete[]`.\r\nFixes #395.",
      "What about the `delete` in line 93 ?",
      "@jcdr428 Fixed in 16a9c2885d9fdbc0499a776a2b29acee45e1d8a2."
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.9"
}