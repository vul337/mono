{
  "cve_id": "CVE-2020-35963",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "fluent/fluent-bit",
  "commit_msg": "gzip: fix compression size calculation (oss-fuzz 27261)\n\nSigned-off-by: davkor <david@adalogics.com>",
  "commit_hash": "cadff53c093210404aed01c4cf586adb8caa07af",
  "git_url": "https://github.com/fluent/fluent-bit/commit/cadff53c093210404aed01c4cf586adb8caa07af",
  "file_path": "src/flb_gzip.c",
  "func_name": "flb_gzip_compress",
  "func_before": "int flb_gzip_compress(void *in_data, size_t in_len,\n                      void **out_data, size_t *out_len)\n{\n    int flush;\n    int status;\n    int footer_start;\n    uint8_t *pb;\n    size_t out_size;\n    void *out_buf;\n    z_stream strm;\n    mz_ulong crc;\n\n    out_size = in_len + 32;\n    out_buf = flb_malloc(out_size);\n    if (!out_buf) {\n        flb_errno();\n        flb_error(\"[gzip] could not allocate outgoing buffer\");\n        return -1;\n    }\n\n    /* Initialize streaming buffer context */\n    memset(&strm, '\\0', sizeof(strm));\n    strm.zalloc    = Z_NULL;\n    strm.zfree     = Z_NULL;\n    strm.opaque    = Z_NULL;\n    strm.next_in   = in_data;\n    strm.avail_in  = in_len;\n    strm.total_out = 0;\n\n    /* Deflate mode */\n    deflateInit2(&strm, Z_DEFAULT_COMPRESSION,\n                 Z_DEFLATED, -Z_DEFAULT_WINDOW_BITS, 9, Z_DEFAULT_STRATEGY);\n\n    /*\n     * Miniz don't support GZip format directly, instead we will:\n     *\n     * - append manual GZip magic bytes\n     * - deflate raw content\n     * - append manual CRC32 data\n     */\n    gzip_header(out_buf);\n\n    /* Header offset */\n    pb = (uint8_t *) out_buf + FLB_GZIP_HEADER_OFFSET;\n\n    flush = Z_NO_FLUSH;\n    while (1) {\n        strm.next_out  = pb + strm.total_out;\n        strm.avail_out = out_size - (pb - (uint8_t *) out_buf);\n\n        if (strm.avail_in == 0) {\n            flush = Z_FINISH;\n        }\n\n        status = deflate(&strm, flush);\n        if (status == Z_STREAM_END) {\n            break;\n        }\n        else if (status != Z_OK) {\n            deflateEnd(&strm);\n            return -1;\n        }\n    }\n\n    if (deflateEnd(&strm) != Z_OK) {\n        flb_free(out_buf);\n        return -1;\n    }\n    *out_len = strm.total_out;\n\n    /* Construct the gzip checksum (CRC32 footer) */\n    footer_start = FLB_GZIP_HEADER_OFFSET + *out_len;\n    pb = (uint8_t *) out_buf + footer_start;\n\n    crc = mz_crc32(MZ_CRC32_INIT, in_data, in_len);\n    *pb++ = crc & 0xFF;\n    *pb++ = (crc >> 8) & 0xFF;\n    *pb++ = (crc >> 16) & 0xFF;\n    *pb++ = (crc >> 24) & 0xFF;\n    *pb++ = in_len & 0xFF;\n    *pb++ = (in_len >> 8) & 0xFF;\n    *pb++ = (in_len >> 16) & 0xFF;\n    *pb++ = (in_len >> 24) & 0xFF;\n\n    /* Set the real buffer size for the caller */\n    *out_len += FLB_GZIP_HEADER_OFFSET + 8;\n    *out_data = out_buf;\n\n    return 0;\n}",
  "abstract_func_before": "int flb_gzip_compress(void *VAR_0, size_t VAR_1,\n                      void **VAR_2, size_t *VAR_3)\n{\n    int VAR_4;\n    int VAR_5;\n    int VAR_6;\n    uint8_t *VAR_7;\n    size_t VAR_8;\n    void *VAR_9;\n    z_stream VAR_10;\n    mz_ulong VAR_11;\n\n    VAR_8 = VAR_1 + 32;\n    VAR_9 = flb_malloc(VAR_8);\n    if (!VAR_9) {\n        flb_errno();\n        flb_error(\"[gzip] could not allocate outgoing buffer\");\n        return -1;\n    }\n\n    /* COMMENT_0 */\n    memset(&VAR_10, '\\0', sizeof(VAR_10));\n    VAR_10.zalloc    = VAR_12;\n    VAR_10.zfree     = VAR_12;\n    VAR_10.opaque    = VAR_12;\n    VAR_10.next_in   = VAR_0;\n    VAR_10.avail_in  = VAR_1;\n    VAR_10.total_out = 0;\n\n    /* COMMENT_1 */\n    deflateInit2(&VAR_10, VAR_13,\n                 VAR_14, -VAR_15, 9, VAR_16);\n\n    /* COMMENT_2 */\n                                                                 \n      \n                                       \n                            \n                                 \n       \n    gzip_header(VAR_9);\n\n    /* COMMENT_9 */\n    VAR_7 = (uint8_t *) VAR_9 + VAR_17;\n\n    VAR_4 = VAR_18;\n    while (1) {\n        VAR_10.next_out  = VAR_7 + VAR_10.total_out;\n        VAR_10.avail_out = VAR_8 - (VAR_7 - (uint8_t *) VAR_9);\n\n        if (VAR_10.avail_in == 0) {\n            VAR_4 = VAR_19;\n        }\n\n        VAR_5 = deflate(&VAR_10, VAR_4);\n        if (VAR_5 == VAR_20) {\n            break;\n        }\n        else if (VAR_5 != VAR_21) {\n            deflateEnd(&VAR_10);\n            return -1;\n        }\n    }\n\n    if (deflateEnd(&VAR_10) != VAR_21) {\n        flb_free(VAR_9);\n        return -1;\n    }\n    *VAR_3 = VAR_10.total_out;\n\n    /* COMMENT_10 */\n    VAR_6 = VAR_17 + *VAR_3;\n    VAR_7 = (uint8_t *) VAR_9 + VAR_6;\n\n    VAR_11 = mz_crc32(VAR_22, VAR_0, VAR_1);\n    *VAR_7++ = VAR_11 & 0xFF;\n    *VAR_7++ = (VAR_11 >> 8) & 0xFF;\n    *VAR_7++ = (VAR_11 >> 16) & 0xFF;\n    *VAR_7++ = (VAR_11 >> 24) & 0xFF;\n    *VAR_7++ = VAR_1 & 0xFF;\n    *VAR_7++ = (VAR_1 >> 8) & 0xFF;\n    *VAR_7++ = (VAR_1 >> 16) & 0xFF;\n    *VAR_7++ = (VAR_1 >> 24) & 0xFF;\n\n    /* COMMENT_11 */\n    *VAR_3 += VAR_17 + 8;\n    *VAR_2 = VAR_9;\n\n    return 0;\n}",
  "func_graph_path_before": "fluent/fluent-bit/cadff53c093210404aed01c4cf586adb8caa07af/flb_gzip.c/vul/before/0.json",
  "func": "int flb_gzip_compress(void *in_data, size_t in_len,\n                      void **out_data, size_t *out_len)\n{\n    int flush;\n    int status;\n    int footer_start;\n    uint8_t *pb;\n    size_t out_size;\n    void *out_buf;\n    z_stream strm;\n    mz_ulong crc;\n\n\n    /*\n     * GZIP relies on an algorithm with worst-case expansion\n     * of 5 bytes per 32KB data. This means we need to create a variable\n     * length output, that depends on the input length.\n     * See RFC 1951 for details.\n     */\n    int max_input_expansion = ((int)(in_len / 32000) + 1) * 5;\n\n    /*\n     * Max compressed size is equal to sum of:\n     *   10 byte header\n     *   8 byte foot\n     *   max input expansion\n     *   size of input\n     */\n    out_size = 10 + 8 + max_input_expansion + in_len;\n    out_buf = flb_malloc(out_size);\n\n    if (!out_buf) {\n        flb_errno();\n        flb_error(\"[gzip] could not allocate outgoing buffer\");\n        return -1;\n    }\n\n    /* Initialize streaming buffer context */\n    memset(&strm, '\\0', sizeof(strm));\n    strm.zalloc    = Z_NULL;\n    strm.zfree     = Z_NULL;\n    strm.opaque    = Z_NULL;\n    strm.next_in   = in_data;\n    strm.avail_in  = in_len;\n    strm.total_out = 0;\n\n    /* Deflate mode */\n    deflateInit2(&strm, Z_DEFAULT_COMPRESSION,\n                 Z_DEFLATED, -Z_DEFAULT_WINDOW_BITS, 9, Z_DEFAULT_STRATEGY);\n\n    /*\n     * Miniz don't support GZip format directly, instead we will:\n     *\n     * - append manual GZip magic bytes\n     * - deflate raw content\n     * - append manual CRC32 data\n     */\n    gzip_header(out_buf);\n\n    /* Header offset */\n    pb = (uint8_t *) out_buf + FLB_GZIP_HEADER_OFFSET;\n\n    flush = Z_NO_FLUSH;\n    while (1) {\n        strm.next_out  = pb + strm.total_out;\n        strm.avail_out = out_size - (pb - (uint8_t *) out_buf);\n\n        if (strm.avail_in == 0) {\n            flush = Z_FINISH;\n        }\n\n        status = deflate(&strm, flush);\n        if (status == Z_STREAM_END) {\n            break;\n        }\n        else if (status != Z_OK) {\n            deflateEnd(&strm);\n            return -1;\n        }\n    }\n\n    if (deflateEnd(&strm) != Z_OK) {\n        flb_free(out_buf);\n        return -1;\n    }\n    *out_len = strm.total_out;\n\n    /* Construct the gzip checksum (CRC32 footer) */\n    footer_start = FLB_GZIP_HEADER_OFFSET + *out_len;\n    pb = (uint8_t *) out_buf + footer_start;\n\n    crc = mz_crc32(MZ_CRC32_INIT, in_data, in_len);\n    *pb++ = crc & 0xFF;\n    *pb++ = (crc >> 8) & 0xFF;\n    *pb++ = (crc >> 16) & 0xFF;\n    *pb++ = (crc >> 24) & 0xFF;\n    *pb++ = in_len & 0xFF;\n    *pb++ = (in_len >> 8) & 0xFF;\n    *pb++ = (in_len >> 16) & 0xFF;\n    *pb++ = (in_len >> 24) & 0xFF;\n\n    /* Set the real buffer size for the caller */\n    *out_len += FLB_GZIP_HEADER_OFFSET + 8;\n    *out_data = out_buf;\n\n    return 0;\n}",
  "abstract_func": "int flb_gzip_compress(void *VAR_0, size_t VAR_1,\n                      void **VAR_2, size_t *VAR_3)\n{\n    int VAR_4;\n    int VAR_5;\n    int VAR_6;\n    uint8_t *VAR_7;\n    size_t VAR_8;\n    void *VAR_9;\n    z_stream VAR_10;\n    mz_ulong VAR_11;\n\n\n    /* COMMENT_0 */\n                                                            \n                                                                        \n                                                       \n                                \n       \n    int VAR_12 = ((int)(VAR_1 / 32000) + 1) * 5;\n\n    /* COMMENT_6 */\n                                              \n                       \n                    \n                            \n                      \n       \n    VAR_8 = 10 + 8 + VAR_12 + VAR_1;\n    VAR_9 = flb_malloc(VAR_8);\n\n    if (!VAR_9) {\n        flb_errno();\n        flb_error(\"[gzip] could not allocate outgoing buffer\");\n        return -1;\n    }\n\n    /* COMMENT_13 */\n    memset(&VAR_10, '\\0', sizeof(VAR_10));\n    VAR_10.zalloc    = VAR_13;\n    VAR_10.zfree     = VAR_13;\n    VAR_10.opaque    = VAR_13;\n    VAR_10.next_in   = VAR_0;\n    VAR_10.avail_in  = VAR_1;\n    VAR_10.total_out = 0;\n\n    /* COMMENT_14 */\n    deflateInit2(&VAR_10, VAR_14,\n                 VAR_15, -VAR_16, 9, VAR_17);\n\n    /* COMMENT_15 */\n                                                                 \n      \n                                       \n                            \n                                 \n       \n    gzip_header(VAR_9);\n\n    /* COMMENT_22 */\n    VAR_7 = (uint8_t *) VAR_9 + VAR_18;\n\n    VAR_4 = VAR_19;\n    while (1) {\n        VAR_10.next_out  = VAR_7 + VAR_10.total_out;\n        VAR_10.avail_out = VAR_8 - (VAR_7 - (uint8_t *) VAR_9);\n\n        if (VAR_10.avail_in == 0) {\n            VAR_4 = VAR_20;\n        }\n\n        VAR_5 = deflate(&VAR_10, VAR_4);\n        if (VAR_5 == VAR_21) {\n            break;\n        }\n        else if (VAR_5 != VAR_22) {\n            deflateEnd(&VAR_10);\n            return -1;\n        }\n    }\n\n    if (deflateEnd(&VAR_10) != VAR_22) {\n        flb_free(VAR_9);\n        return -1;\n    }\n    *VAR_3 = VAR_10.total_out;\n\n    /* COMMENT_23 */\n    VAR_6 = VAR_18 + *VAR_3;\n    VAR_7 = (uint8_t *) VAR_9 + VAR_6;\n\n    VAR_11 = mz_crc32(VAR_23, VAR_0, VAR_1);\n    *VAR_7++ = VAR_11 & 0xFF;\n    *VAR_7++ = (VAR_11 >> 8) & 0xFF;\n    *VAR_7++ = (VAR_11 >> 16) & 0xFF;\n    *VAR_7++ = (VAR_11 >> 24) & 0xFF;\n    *VAR_7++ = VAR_1 & 0xFF;\n    *VAR_7++ = (VAR_1 >> 8) & 0xFF;\n    *VAR_7++ = (VAR_1 >> 16) & 0xFF;\n    *VAR_7++ = (VAR_1 >> 24) & 0xFF;\n\n    /* COMMENT_24 */\n    *VAR_3 += VAR_18 + 8;\n    *VAR_2 = VAR_9;\n\n    return 0;\n}",
  "func_graph_path": "fluent/fluent-bit/cadff53c093210404aed01c4cf586adb8caa07af/flb_gzip.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -10,8 +10,25 @@\n     z_stream strm;\n     mz_ulong crc;\n \n-    out_size = in_len + 32;\n+\n+    /*\n+     * GZIP relies on an algorithm with worst-case expansion\n+     * of 5 bytes per 32KB data. This means we need to create a variable\n+     * length output, that depends on the input length.\n+     * See RFC 1951 for details.\n+     */\n+    int max_input_expansion = ((int)(in_len / 32000) + 1) * 5;\n+\n+    /*\n+     * Max compressed size is equal to sum of:\n+     *   10 byte header\n+     *   8 byte foot\n+     *   max input expansion\n+     *   size of input\n+     */\n+    out_size = 10 + 8 + max_input_expansion + in_len;\n     out_buf = flb_malloc(out_size);\n+\n     if (!out_buf) {\n         flb_errno();\n         flb_error(\"[gzip] could not allocate outgoing buffer\");",
  "diff_line_info": {
    "deleted_lines": [
      "    out_size = in_len + 32;"
    ],
    "added_lines": [
      "",
      "    /*",
      "     * GZIP relies on an algorithm with worst-case expansion",
      "     * of 5 bytes per 32KB data. This means we need to create a variable",
      "     * length output, that depends on the input length.",
      "     * See RFC 1951 for details.",
      "     */",
      "    int max_input_expansion = ((int)(in_len / 32000) + 1) * 5;",
      "",
      "    /*",
      "     * Max compressed size is equal to sum of:",
      "     *   10 byte header",
      "     *   8 byte foot",
      "     *   max input expansion",
      "     *   size of input",
      "     */",
      "    out_size = 10 + 8 + max_input_expansion + in_len;",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/fluent/fluent-bit/pull/2751",
  "description": {
    "pr_info": {
      "title": "Bug fixes",
      "number": 2751
    },
    "comment": [
      "<!-- Provide summary of changes -->\r\nFixes several issues found by fuzzing.\r\n\r\nOne that is particularly interesting is in the gzip compression logic where we have a fixed-size calculation on the output of the compression. However, this can vary as \"the worst case expansion is 5 bytes per 32K\" ref https://tools.ietf.org/html/rfc1951\r\n\r\nThe other ones seem to be more explicit and are related to bounds-checking as well as NULL-pointer dereferences.\r\n\r\n<!-- Issue number, if available. E.g. \"Fixes #31\", \"Addresses #42, #77\" -->\r\n\r\noss-fuzz issue 27261\r\noss-fuzz issue 27241\r\noss-fuzz issue 27023\r\noss-fuzz testcase 5200866812100608 \r\n----\r\nEnter `[N/A]` in the box, if an item is not applicable to your change.\r\n\r\n**Testing**\r\nBefore we can approve your change; please submit the following in a comment:\r\n- [N/A] Example configuration file for the change\r\n- [N/A] Debug log output from testing the change\r\n<!-- Invoke Fluent Bit and Valgrind as: $ valgrind ./bin/fluent-bit <args> -->\r\n- [N/A] Attached [Valgrind](https://valgrind.org/docs/manual/quick-start.html) output that shows no leaks or memory corruption was found\r\n\r\n**Documentation**\r\n<!-- Docs can be edited at https://github.com/fluent/fluent-bit-docs -->\r\n- [N/A] Documentation required for this feature\r\n\r\n<!--  Doc PR (not required but highly recommended) -->\r\n\r\n----\r\n\r\nFluent Bit is licensed under Apache 2.0, by submitting this pull request I understand that this code will be released under the terms of that license.\r\n",
      "thanks!"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Step-by-Step Explanation:**\n\n1. **Commit Message Analysis**: The commit message mentions \"fix compression size calculation\" related to an oss-fuzz issue, indicating a potential security concern.\n\n2. **Vulnerability Description**: It details issues found by fuzzing, including buffer overflows and NULL pointer dereferences, which are security risks.\n\n3. **Code Changes**: The patch changes the output buffer calculation to account for variable expansion, preventing potential buffer overflows.\n\n4. **Consistency Check**: The commit's intent matches the code changes, showing a focused fix on the buffer calculation.\n\n5. **Purpose Evaluation**: The change is a core fix in compression logic to prevent overflows, a clear security concern.\n\n6. **Security Assessment**: The fix addresses buffer overflow, a known security vulnerability, making it a security patch.\n\n7. **Confidence**: High confidence due to alignment of commit, description, and code changes, all pointing to a security fix.\n\n**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}