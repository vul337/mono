{
  "cve_id": "CVE-2023-35847",
  "cwe_ids": [
    "CWE-908",
    "CWE-682"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "virtualsquare/picotcp",
  "commit_msg": "TCP: Fixed MSS size calculation. Set MSS lower bound.\n\nReported-by: \"P. Amsuo, Purdue University\"",
  "commit_hash": "eaf166009e44641e6570c576ba071217f100fd99",
  "git_url": "https://github.com/virtualsquare/picotcp/commit/eaf166009e44641e6570c576ba071217f100fd99",
  "file_path": "modules/pico_tcp.c",
  "func_name": "pico_tcp_initconn",
  "func_before": "int pico_tcp_initconn(struct pico_socket *s)\n{\n    struct pico_socket_tcp *ts = TCP_SOCK(s);\n    struct pico_frame *syn;\n    struct pico_tcp_hdr *hdr;\n    uint16_t mtu, opt_len = tcp_options_size(ts, PICO_TCP_SYN);\n\n    syn = s->net->alloc(s->stack, s->net, NULL, (uint16_t)(PICO_SIZE_TCPHDR + opt_len));\n    if (!syn)\n        return -1;\n\n    hdr = (struct pico_tcp_hdr *) syn->transport_hdr;\n\n    if (!ts->snd_nxt)\n        ts->snd_nxt = long_be(pico_paws());\n\n    ts->snd_last = ts->snd_nxt;\n    ts->cwnd = PICO_TCP_IW;\n    mtu = (uint16_t)pico_socket_get_mss(s);\n    ts->mss = (uint16_t)(mtu - PICO_SIZE_TCPHDR);\n    ts->ssthresh = (uint16_t)((uint16_t)(PICO_DEFAULT_SOCKETQ / ts->mss) -  (((uint16_t)(PICO_DEFAULT_SOCKETQ / ts->mss)) >> 3u));\n    syn->sock = s;\n    hdr->seq = long_be(ts->snd_nxt);\n    hdr->len = (uint8_t)((PICO_SIZE_TCPHDR + opt_len) << 2);\n    hdr->flags = PICO_TCP_SYN;\n    tcp_set_space(ts);\n    hdr->rwnd = short_be(ts->wnd);\n    tcp_add_options(ts, syn, PICO_TCP_SYN, opt_len);\n    hdr->trans.sport = ts->sock.local_port;\n    hdr->trans.dport = ts->sock.remote_port;\n\n    hdr->crc = 0;\n    hdr->crc = short_be(pico_tcp_checksum(syn));\n\n    /* TCP: ENQUEUE to PROTO ( SYN ) */\n    tcp_dbg(\"Sending SYN... (ports: %d - %d) size: %d\\n\", short_be(ts->sock.local_port), short_be(ts->sock.remote_port), syn->buffer_len);\n    ts->retrans_tmr = pico_timer_add(s->stack, PICO_TCP_SYN_TO << ts->backoff, initconn_retry, ts);\n    if (!ts->retrans_tmr) {\n        tcp_dbg(\"TCP: Failed to start initconn_retry timer\\n\");\n        PICO_FREE(syn);\n        return -1;\n    }\n    pico_enqueue(&s->stack->q_tcp.out, syn);\n    return 0;\n}",
  "abstract_func_before": "int pico_tcp_initconn(struct pico_socket *VAR_0)\n{\n    struct pico_socket_tcp *VAR_1 = TCP_SOCK(VAR_0);\n    struct pico_frame *VAR_2;\n    struct pico_tcp_hdr *VAR_3;\n    uint16_t VAR_4, VAR_5 = tcp_options_size(VAR_1, VAR_6);\n\n    VAR_2 = VAR_0->net->alloc(VAR_0->stack, VAR_0->net, NULL, (uint16_t)(VAR_7 + VAR_5));\n    if (!VAR_2)\n        return -1;\n\n    VAR_3 = (struct pico_tcp_hdr *) VAR_2->transport_hdr;\n\n    if (!VAR_1->snd_nxt)\n        VAR_1->snd_nxt = long_be(pico_paws());\n\n    VAR_1->snd_last = VAR_1->snd_nxt;\n    VAR_1->cwnd = VAR_8;\n    VAR_4 = (uint16_t)pico_socket_get_mss(VAR_0);\n    VAR_1->mss = (uint16_t)(VAR_4 - VAR_7);\n    VAR_1->ssthresh = (uint16_t)((uint16_t)(VAR_9 / VAR_1->mss) -  (((uint16_t)(VAR_9 / VAR_1->mss)) >> 3u));\n    VAR_2->sock = VAR_0;\n    VAR_3->seq = long_be(VAR_1->snd_nxt);\n    VAR_3->len = (uint8_t)((VAR_7 + VAR_5) << 2);\n    VAR_3->flags = VAR_6;\n    tcp_set_space(VAR_1);\n    VAR_3->rwnd = short_be(VAR_1->wnd);\n    tcp_add_options(VAR_1, VAR_2, VAR_6, VAR_5);\n    VAR_3->trans.sport = VAR_1->sock.local_port;\n    VAR_3->trans.dport = VAR_1->sock.remote_port;\n\n    VAR_3->crc = 0;\n    VAR_3->crc = short_be(pico_tcp_checksum(VAR_2));\n\n    /* COMMENT_0 */\n    tcp_dbg(\"Sending SYN... (ports: %d - %d) size: %d\\n\", short_be(VAR_1->sock.local_port), short_be(VAR_1->sock.remote_port), VAR_2->buffer_len);\n    VAR_1->retrans_tmr = pico_timer_add(VAR_0->stack, VAR_10 << VAR_1->backoff, VAR_11, VAR_1);\n    if (!VAR_1->retrans_tmr) {\n        tcp_dbg(\"TCP: Failed to start initconn_retry timer\\n\");\n        PICO_FREE(VAR_2);\n        return -1;\n    }\n    pico_enqueue(&VAR_0->stack->q_tcp.out, VAR_2);\n    return 0;\n}",
  "func_graph_path_before": "virtualsquare/picotcp/eaf166009e44641e6570c576ba071217f100fd99/pico_tcp.c/vul/before/1.json",
  "func": "int pico_tcp_initconn(struct pico_socket *s)\n{\n    struct pico_socket_tcp *ts = TCP_SOCK(s);\n    struct pico_frame *syn;\n    struct pico_tcp_hdr *hdr;\n    uint16_t mtu, opt_len = tcp_options_size(ts, PICO_TCP_SYN);\n\n    syn = s->net->alloc(s->stack, s->net, NULL, (uint16_t)(PICO_SIZE_TCPHDR + opt_len));\n    if (!syn)\n        return -1;\n\n    hdr = (struct pico_tcp_hdr *) syn->transport_hdr;\n\n    if (!ts->snd_nxt)\n        ts->snd_nxt = long_be(pico_paws());\n\n    ts->snd_last = ts->snd_nxt;\n    ts->cwnd = PICO_TCP_IW;\n    mtu = (uint16_t)pico_socket_get_mss(s);\n    if (mtu > PICO_SIZE_TCPHDR + PICO_TCP_MIN_MSS)\n        ts->mss = (uint16_t)(mtu - PICO_SIZE_TCPHDR);\n    else\n        ts->mss = PICO_TCP_MIN_MSS;\n    ts->ssthresh = (uint16_t)((uint16_t)(PICO_DEFAULT_SOCKETQ / ts->mss) -  (((uint16_t)(PICO_DEFAULT_SOCKETQ / ts->mss)) >> 3u));\n    syn->sock = s;\n    hdr->seq = long_be(ts->snd_nxt);\n    hdr->len = (uint8_t)((PICO_SIZE_TCPHDR + opt_len) << 2);\n    hdr->flags = PICO_TCP_SYN;\n    tcp_set_space(ts);\n    hdr->rwnd = short_be(ts->wnd);\n    tcp_add_options(ts, syn, PICO_TCP_SYN, opt_len);\n    hdr->trans.sport = ts->sock.local_port;\n    hdr->trans.dport = ts->sock.remote_port;\n\n    hdr->crc = 0;\n    hdr->crc = short_be(pico_tcp_checksum(syn));\n\n    /* TCP: ENQUEUE to PROTO ( SYN ) */\n    tcp_dbg(\"Sending SYN... (ports: %d - %d) size: %d\\n\", short_be(ts->sock.local_port), short_be(ts->sock.remote_port), syn->buffer_len);\n    ts->retrans_tmr = pico_timer_add(s->stack, PICO_TCP_SYN_TO << ts->backoff, initconn_retry, ts);\n    if (!ts->retrans_tmr) {\n        tcp_dbg(\"TCP: Failed to start initconn_retry timer\\n\");\n        PICO_FREE(syn);\n        return -1;\n    }\n    pico_enqueue(&s->stack->q_tcp.out, syn);\n    return 0;\n}",
  "abstract_func": "int pico_tcp_initconn(struct pico_socket *VAR_0)\n{\n    struct pico_socket_tcp *VAR_1 = TCP_SOCK(VAR_0);\n    struct pico_frame *VAR_2;\n    struct pico_tcp_hdr *VAR_3;\n    uint16_t VAR_4, VAR_5 = tcp_options_size(VAR_1, VAR_6);\n\n    VAR_2 = VAR_0->net->alloc(VAR_0->stack, VAR_0->net, NULL, (uint16_t)(VAR_7 + VAR_5));\n    if (!VAR_2)\n        return -1;\n\n    VAR_3 = (struct pico_tcp_hdr *) VAR_2->transport_hdr;\n\n    if (!VAR_1->snd_nxt)\n        VAR_1->snd_nxt = long_be(pico_paws());\n\n    VAR_1->snd_last = VAR_1->snd_nxt;\n    VAR_1->cwnd = VAR_8;\n    VAR_4 = (uint16_t)pico_socket_get_mss(VAR_0);\n    if (VAR_4 > VAR_7 + VAR_9)\n        VAR_1->mss = (uint16_t)(VAR_4 - VAR_7);\n    else\n        VAR_1->mss = VAR_9;\n    VAR_1->ssthresh = (uint16_t)((uint16_t)(VAR_10 / VAR_1->mss) -  (((uint16_t)(VAR_10 / VAR_1->mss)) >> 3u));\n    VAR_2->sock = VAR_0;\n    VAR_3->seq = long_be(VAR_1->snd_nxt);\n    VAR_3->len = (uint8_t)((VAR_7 + VAR_5) << 2);\n    VAR_3->flags = VAR_6;\n    tcp_set_space(VAR_1);\n    VAR_3->rwnd = short_be(VAR_1->wnd);\n    tcp_add_options(VAR_1, VAR_2, VAR_6, VAR_5);\n    VAR_3->trans.sport = VAR_1->sock.local_port;\n    VAR_3->trans.dport = VAR_1->sock.remote_port;\n\n    VAR_3->crc = 0;\n    VAR_3->crc = short_be(pico_tcp_checksum(VAR_2));\n\n    /* COMMENT_0 */\n    tcp_dbg(\"Sending SYN... (ports: %d - %d) size: %d\\n\", short_be(VAR_1->sock.local_port), short_be(VAR_1->sock.remote_port), VAR_2->buffer_len);\n    VAR_1->retrans_tmr = pico_timer_add(VAR_0->stack, VAR_11 << VAR_1->backoff, VAR_12, VAR_1);\n    if (!VAR_1->retrans_tmr) {\n        tcp_dbg(\"TCP: Failed to start initconn_retry timer\\n\");\n        PICO_FREE(VAR_2);\n        return -1;\n    }\n    pico_enqueue(&VAR_0->stack->q_tcp.out, VAR_2);\n    return 0;\n}",
  "func_graph_path": "virtualsquare/picotcp/eaf166009e44641e6570c576ba071217f100fd99/pico_tcp.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -17,7 +17,10 @@\n     ts->snd_last = ts->snd_nxt;\n     ts->cwnd = PICO_TCP_IW;\n     mtu = (uint16_t)pico_socket_get_mss(s);\n-    ts->mss = (uint16_t)(mtu - PICO_SIZE_TCPHDR);\n+    if (mtu > PICO_SIZE_TCPHDR + PICO_TCP_MIN_MSS)\n+        ts->mss = (uint16_t)(mtu - PICO_SIZE_TCPHDR);\n+    else\n+        ts->mss = PICO_TCP_MIN_MSS;\n     ts->ssthresh = (uint16_t)((uint16_t)(PICO_DEFAULT_SOCKETQ / ts->mss) -  (((uint16_t)(PICO_DEFAULT_SOCKETQ / ts->mss)) >> 3u));\n     syn->sock = s;\n     hdr->seq = long_be(ts->snd_nxt);",
  "diff_line_info": {
    "deleted_lines": [
      "    ts->mss = (uint16_t)(mtu - PICO_SIZE_TCPHDR);"
    ],
    "added_lines": [
      "    if (mtu > PICO_SIZE_TCPHDR + PICO_TCP_MIN_MSS)",
      "        ts->mss = (uint16_t)(mtu - PICO_SIZE_TCPHDR);",
      "    else",
      "        ts->mss = PICO_TCP_MIN_MSS;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/virtualsquare/picotcp/pull/15",
  "description": {
    "pr_info": {
      "title": "Various fixes on size calculation",
      "number": 15
    },
    "comment": [
      "- TCP: Fixed MSS size calculation, set lower MSS bound\r\n- TCP: Check options size before parsing MSS field\r\n- ipfilter: Check transport layer size before dereferencing port numbers\r\n- IPv4: Check transport layer size before calculating checksum",
      "There should be CVEs for these fixes."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95"
}