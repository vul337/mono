{
  "cve_id": "CVE-2015-2778",
  "cwe_ids": [
    "CWE-399"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "quassel",
  "commit_msg": "Improve the message-splitting algorithm for PRIVMSG and CTCP\n\nThis introduces a new message splitting algorithm based on\nQTextBoundaryFinder.  It works by first starting with the entire\nmessage to be sent, encoding it, and checking to see if it is over\nthe maximum message length.  If it is, it uses QTBF to find the\nword boundary most immediately preceding the maximum length.  If no\nsuitable boundary can be found, it falls back to searching for\ngrapheme boundaries.  It repeats this process until the entire\nmessage has been sent.\n\nUnlike what it replaces, the new splitting code is not recursive\nand cannot cause stack overflows.  Additionally, if it is unable\nto split a string, it will give up gracefully and not crash the\ncore or cause a thread to run away.\n\nThis patch fixes two bugs.  The first is garbage characters caused\nby accidentally splitting the string in the middle of a multibyte\ncharacter.  Since the new code splits at a character level instead\nof a byte level, this will no longer be an issue.  The second is\nthe core crash caused by sending an overlength CTCP query (\"/me\")\ncontaining only multibyte characters.  This bug was caused by the\nold CTCP splitter using the byte index from lastParamOverrun() as\na character index for a QString.",
  "commit_hash": "b5e38970ffd55e2dd9f706ce75af9a8d7730b1b8",
  "git_url": "https://github.com/quassel/quassel/commit/b5e38970ffd55e2dd9f706ce75af9a8d7730b1b8",
  "file_path": "src/core/ctcpparser.cpp",
  "func_name": "CtcpParser::query",
  "func_before": "void CtcpParser::query(CoreNetwork *net, const QString &bufname, const QString &ctcpTag, const QString &message)\n{\n    QList<QByteArray> params;\n    params << net->serverEncode(bufname) << lowLevelQuote(pack(net->serverEncode(ctcpTag), net->userEncode(bufname, message)));\n\n    static const char *splitter = \" .,-!?\";\n    int maxSplitPos = message.count();\n    int splitPos = maxSplitPos;\n\n    int overrun = net->userInputHandler()->lastParamOverrun(\"PRIVMSG\", params);\n    if (overrun) {\n        maxSplitPos = message.count() - overrun -2;\n        splitPos = -1;\n        for (const char *splitChar = splitter; *splitChar != 0; splitChar++) {\n            splitPos = qMax(splitPos, message.lastIndexOf(*splitChar, maxSplitPos) + 1); // keep split char on old line\n        }\n        if (splitPos <= 0 || splitPos > maxSplitPos)\n            splitPos = maxSplitPos;\n\n        params = params.mid(0, 1) <<  lowLevelQuote(pack(net->serverEncode(ctcpTag), net->userEncode(bufname, message.left(splitPos))));\n    }\n    net->putCmd(\"PRIVMSG\", params);\n\n    if (splitPos < message.count())\n        query(net, bufname, ctcpTag, message.mid(splitPos));\n}",
  "abstract_func_before": "void CtcpParser::query(CoreNetwork *VAR_0, const QString &VAR_1, const QString &VAR_2, const QString &VAR_3)\n{\n    QList<QByteArray> VAR_4;\n    VAR_4 << VAR_0->serverEncode(VAR_1) << lowLevelQuote(pack(VAR_0->serverEncode(VAR_2), VAR_0->userEncode(VAR_1, VAR_3)));\n\n    static const char *VAR_5 = \" .,-!?\";\n    int VAR_6 = VAR_3.count();\n    int VAR_7 = VAR_6;\n\n    int VAR_8 = VAR_0->userInputHandler()->lastParamOverrun(\"PRIVMSG\", VAR_4);\n    if (VAR_8) {\n        VAR_6 = VAR_3.count() - VAR_8 -2;\n        VAR_7 = -1;\n        for (const char *VAR_9 = VAR_5; *VAR_9 != 0; VAR_9++) {\n            VAR_7 = qMax(VAR_7, VAR_3.lastIndexOf(*VAR_9, VAR_6) + 1); /* COMMENT_0 */\n        }\n        if (VAR_7 <= 0 || VAR_7 > VAR_6)\n            VAR_7 = VAR_6;\n\n        VAR_4 = VAR_4.mid(0, 1) <<  lowLevelQuote(pack(VAR_0->serverEncode(VAR_2), VAR_0->userEncode(VAR_1, VAR_3.left(VAR_7))));\n    }\n    VAR_0->putCmd(\"PRIVMSG\", VAR_4);\n\n    if (VAR_7 < VAR_3.count())\n        query(VAR_0, VAR_1, VAR_2, VAR_3.mid(VAR_7));\n}",
  "func_graph_path_before": "quassel/b5e38970ffd55e2dd9f706ce75af9a8d7730b1b8/ctcpparser.cpp/vul/before/0.json",
  "func": "void CtcpParser::query(CoreNetwork *net, const QString &bufname, const QString &ctcpTag, const QString &message)\n{\n    QString cmd(\"PRIVMSG\");\n\n    std::function<QList<QByteArray>(QString &)> cmdGenerator = [&] (QString &splitMsg) -> QList<QByteArray> {\n        return QList<QByteArray>() << net->serverEncode(bufname) << lowLevelQuote(pack(net->serverEncode(ctcpTag), net->userEncode(bufname, splitMsg)));\n    };\n\n    net->putCmd(cmd, net->splitMessage(cmd, message, cmdGenerator));\n}",
  "abstract_func": "void CtcpParser::query(CoreNetwork *VAR_0, const QString &VAR_1, const QString &VAR_2, const QString &VAR_3)\n{\n    QString VAR_4(\"PRIVMSG\");\n\n    std::function<QList<QByteArray>(QString &)> VAR_5 = [&] (QString &VAR_6) -> QList<QByteArray> {\n        return QList<QByteArray>() << VAR_0->serverEncode(VAR_1) << lowLevelQuote(pack(VAR_0->serverEncode(VAR_2), VAR_0->userEncode(VAR_1, VAR_6)));\n    };\n\n    VAR_0->putCmd(VAR_4, VAR_0->splitMessage(VAR_4, VAR_3, VAR_5));\n}",
  "func_graph_path": "quassel/b5e38970ffd55e2dd9f706ce75af9a8d7730b1b8/ctcpparser.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,26 +1,10 @@\n void CtcpParser::query(CoreNetwork *net, const QString &bufname, const QString &ctcpTag, const QString &message)\n {\n-    QList<QByteArray> params;\n-    params << net->serverEncode(bufname) << lowLevelQuote(pack(net->serverEncode(ctcpTag), net->userEncode(bufname, message)));\n+    QString cmd(\"PRIVMSG\");\n \n-    static const char *splitter = \" .,-!?\";\n-    int maxSplitPos = message.count();\n-    int splitPos = maxSplitPos;\n+    std::function<QList<QByteArray>(QString &)> cmdGenerator = [&] (QString &splitMsg) -> QList<QByteArray> {\n+        return QList<QByteArray>() << net->serverEncode(bufname) << lowLevelQuote(pack(net->serverEncode(ctcpTag), net->userEncode(bufname, splitMsg)));\n+    };\n \n-    int overrun = net->userInputHandler()->lastParamOverrun(\"PRIVMSG\", params);\n-    if (overrun) {\n-        maxSplitPos = message.count() - overrun -2;\n-        splitPos = -1;\n-        for (const char *splitChar = splitter; *splitChar != 0; splitChar++) {\n-            splitPos = qMax(splitPos, message.lastIndexOf(*splitChar, maxSplitPos) + 1); // keep split char on old line\n-        }\n-        if (splitPos <= 0 || splitPos > maxSplitPos)\n-            splitPos = maxSplitPos;\n-\n-        params = params.mid(0, 1) <<  lowLevelQuote(pack(net->serverEncode(ctcpTag), net->userEncode(bufname, message.left(splitPos))));\n-    }\n-    net->putCmd(\"PRIVMSG\", params);\n-\n-    if (splitPos < message.count())\n-        query(net, bufname, ctcpTag, message.mid(splitPos));\n+    net->putCmd(cmd, net->splitMessage(cmd, message, cmdGenerator));\n }",
  "diff_line_info": {
    "deleted_lines": [
      "    QList<QByteArray> params;",
      "    params << net->serverEncode(bufname) << lowLevelQuote(pack(net->serverEncode(ctcpTag), net->userEncode(bufname, message)));",
      "    static const char *splitter = \" .,-!?\";",
      "    int maxSplitPos = message.count();",
      "    int splitPos = maxSplitPos;",
      "    int overrun = net->userInputHandler()->lastParamOverrun(\"PRIVMSG\", params);",
      "    if (overrun) {",
      "        maxSplitPos = message.count() - overrun -2;",
      "        splitPos = -1;",
      "        for (const char *splitChar = splitter; *splitChar != 0; splitChar++) {",
      "            splitPos = qMax(splitPos, message.lastIndexOf(*splitChar, maxSplitPos) + 1); // keep split char on old line",
      "        }",
      "        if (splitPos <= 0 || splitPos > maxSplitPos)",
      "            splitPos = maxSplitPos;",
      "",
      "        params = params.mid(0, 1) <<  lowLevelQuote(pack(net->serverEncode(ctcpTag), net->userEncode(bufname, message.left(splitPos))));",
      "    }",
      "    net->putCmd(\"PRIVMSG\", params);",
      "",
      "    if (splitPos < message.count())",
      "        query(net, bufname, ctcpTag, message.mid(splitPos));"
    ],
    "added_lines": [
      "    QString cmd(\"PRIVMSG\");",
      "    std::function<QList<QByteArray>(QString &)> cmdGenerator = [&] (QString &splitMsg) -> QList<QByteArray> {",
      "        return QList<QByteArray>() << net->serverEncode(bufname) << lowLevelQuote(pack(net->serverEncode(ctcpTag), net->userEncode(bufname, splitMsg)));",
      "    };",
      "    net->putCmd(cmd, net->splitMessage(cmd, message, cmdGenerator));"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/quassel/quassel/pull/116",
  "description": {
    "pr_info": {
      "title": "Improve the message-splitting algorithm for PRIVMSG and CTCP",
      "number": 116
    },
    "comment": [
      "This introduces a new message splitting algorithm based on\nQTextBoundaryFinder.  It works by first starting with the entire\nmessage to be sent, encoding it, and checking to see if it is over\nthe maximum message length.  If it is, it uses QTBF to find the\nword boundary most immediately preceding the maximum length.  If no\nsuitable boundary can be found, it falls back to searching for\ngrapheme boundaries.  It repeats this process until the entire\nmessage has been sent.\n\nUnlike what it replaces, the new splitting code is not recursive\nand cannot cause stack overflows.  Additionally, if it is unable\nto split a string, it will give up gracefully and not crash the\ncore or cause a thread to run away.\n\nThis patch fixes two bugs.  The first is garbage characters caused\nby accidentally splitting the string in the middle of a multibyte\ncharacter.  Since the new code splits at a character level instead\nof a byte level, this will no longer be an issue.  The second is\nthe core crash caused by sending an overlength CTCP query (\"/me\")\ncontaining only multibyte characters.  This bug was caused by the\nold CTCP splitter using the byte index from lastParamOverrun() as\na character index for a QString.\n"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.95"
}