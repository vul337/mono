{
  "cve_id": "CVE-2018-14568",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "OISF/suricata",
  "commit_msg": "stream: support RST getting lost/ignored\n\nIn case of a valid RST on a SYN, the state is switched to 'TCP_CLOSED'.\nHowever, the target of the RST may not have received it, or may not\nhave accepted it. Also, the RST may have been injected, so the supposed\nsender may not actually be aware of the RST that was sent in it's name.\n\nIn this case the previous behavior was to switch the state to CLOSED and\naccept no further TCP updates or stream reassembly.\n\nThis patch changes this. It still switches the state to CLOSED, as this\nis by far the most likely to be correct. However, it will reconsider\nthe state if the receiver continues to talk.\n\nTo do this on each state change the previous state will be recorded in\nTcpSession::pstate. If a non-RST packet is received after a RST, this\nTcpSession::pstate is used to try to continue the conversation.\n\nIf the (supposed) sender of the RST is also continueing the conversation\nas normal, it's highly likely it didn't send the RST. In this case\na stream event is generated.\n\nTicket: #2501\n\nReported-By: Kirill Shipulin",
  "commit_hash": "843d0b7a10bb45627f94764a6c5d468a24143345",
  "git_url": "https://github.com/OISF/suricata/commit/843d0b7a10bb45627f94764a6c5d468a24143345",
  "file_path": "src/stream-tcp.c",
  "func_name": "StreamTcpPacketStateSynSent",
  "func_before": "static int StreamTcpPacketStateSynSent(ThreadVars *tv, Packet *p,\n                        StreamTcpThread *stt, TcpSession *ssn, PacketQueue *pq)\n{\n    if (ssn == NULL)\n        return -1;\n\n    SCLogDebug(\"ssn %p: pkt received: %s\", ssn, PKT_IS_TOCLIENT(p) ?\n               \"toclient\":\"toserver\");\n\n    /* RST */\n    if (p->tcph->th_flags & TH_RST) {\n        if (!StreamTcpValidateRst(ssn, p))\n            return -1;\n\n        if (PKT_IS_TOSERVER(p)) {\n            if (SEQ_EQ(TCP_GET_SEQ(p), ssn->client.isn) &&\n                    SEQ_EQ(TCP_GET_WINDOW(p), 0) &&\n                    SEQ_EQ(TCP_GET_ACK(p), (ssn->client.isn + 1)))\n            {\n                StreamTcpPacketSetState(p, ssn, TCP_CLOSED);\n                SCLogDebug(\"ssn %p: Reset received and state changed to \"\n                        \"TCP_CLOSED\", ssn);\n            }\n        } else {\n            StreamTcpPacketSetState(p, ssn, TCP_CLOSED);\n            SCLogDebug(\"ssn %p: Reset received and state changed to \"\n                    \"TCP_CLOSED\", ssn);\n        }\n\n    /* FIN */\n    } else if (p->tcph->th_flags & TH_FIN) {\n        /** \\todo */\n\n    /* SYN/ACK */\n    } else if ((p->tcph->th_flags & (TH_SYN|TH_ACK)) == (TH_SYN|TH_ACK)) {\n        if ((ssn->flags & STREAMTCP_FLAG_4WHS) && PKT_IS_TOSERVER(p)) {\n            SCLogDebug(\"ssn %p: SYN/ACK received on 4WHS session\", ssn);\n\n            /* Check if the SYN/ACK packet ack's the earlier\n             * received SYN packet. */\n            if (!(SEQ_EQ(TCP_GET_ACK(p), ssn->server.isn + 1))) {\n                StreamTcpSetEvent(p, STREAM_4WHS_SYNACK_WITH_WRONG_ACK);\n\n                SCLogDebug(\"ssn %p: 4WHS ACK mismatch, packet ACK %\"PRIu32\"\"\n                        \" != %\" PRIu32 \" from stream\", ssn,\n                        TCP_GET_ACK(p), ssn->server.isn + 1);\n                return -1;\n            }\n\n            /* Check if the SYN/ACK packet SEQ's the *FIRST* received SYN\n             * packet. */\n            if (!(SEQ_EQ(TCP_GET_SEQ(p), ssn->client.isn))) {\n                StreamTcpSetEvent(p, STREAM_4WHS_SYNACK_WITH_WRONG_SYN);\n\n                SCLogDebug(\"ssn %p: 4WHS SEQ mismatch, packet SEQ %\"PRIu32\"\"\n                        \" != %\" PRIu32 \" from *first* SYN pkt\", ssn,\n                        TCP_GET_SEQ(p), ssn->client.isn);\n                return -1;\n            }\n\n\n            /* update state */\n            StreamTcpPacketSetState(p, ssn, TCP_SYN_RECV);\n            SCLogDebug(\"ssn %p: =~ 4WHS ssn state is now TCP_SYN_RECV\", ssn);\n\n            /* sequence number & window */\n            ssn->client.isn = TCP_GET_SEQ(p);\n            STREAMTCP_SET_RA_BASE_SEQ(&ssn->client, ssn->client.isn);\n            ssn->client.next_seq = ssn->client.isn + 1;\n\n            ssn->server.window = TCP_GET_WINDOW(p);\n            SCLogDebug(\"ssn %p: 4WHS window %\" PRIu32 \"\", ssn,\n                    ssn->client.window);\n\n            /* Set the timestamp values used to validate the timestamp of\n             * received packets. */\n            if ((TCP_HAS_TS(p)) &&\n                    (ssn->server.flags & STREAMTCP_STREAM_FLAG_TIMESTAMP))\n            {\n                ssn->client.last_ts = TCP_GET_TSVAL(p);\n                SCLogDebug(\"ssn %p: 4WHS ssn->client.last_ts %\" PRIu32\" \"\n                        \"ssn->server.last_ts %\" PRIu32\"\", ssn,\n                        ssn->client.last_ts, ssn->server.last_ts);\n                ssn->flags |= STREAMTCP_FLAG_TIMESTAMP;\n                ssn->client.last_pkt_ts = p->ts.tv_sec;\n                if (ssn->client.last_ts == 0)\n                    ssn->client.flags |= STREAMTCP_STREAM_FLAG_ZERO_TIMESTAMP;\n            } else {\n                ssn->server.last_ts = 0;\n                ssn->client.last_ts = 0;\n                ssn->server.flags &= ~STREAMTCP_STREAM_FLAG_ZERO_TIMESTAMP;\n            }\n\n            ssn->server.last_ack = TCP_GET_ACK(p);\n            ssn->client.last_ack = ssn->client.isn + 1;\n\n            /** check for the presense of the ws ptr to determine if we\n             *  support wscale at all */\n            if ((ssn->flags & STREAMTCP_FLAG_SERVER_WSCALE) &&\n                    (TCP_HAS_WSCALE(p)))\n            {\n                ssn->server.wscale = TCP_GET_WSCALE(p);\n            } else {\n                ssn->server.wscale = 0;\n            }\n\n            if ((ssn->flags & STREAMTCP_FLAG_CLIENT_SACKOK) &&\n                    TCP_GET_SACKOK(p) == 1) {\n                ssn->flags |= STREAMTCP_FLAG_SACKOK;\n                SCLogDebug(\"ssn %p: SACK permitted for 4WHS session\", ssn);\n            }\n\n            ssn->client.next_win = ssn->client.last_ack + ssn->client.window;\n            ssn->server.next_win = ssn->server.last_ack + ssn->server.window;\n            SCLogDebug(\"ssn %p: 4WHS ssn->client.next_win %\" PRIu32 \"\", ssn,\n                    ssn->client.next_win);\n            SCLogDebug(\"ssn %p: 4WHS ssn->server.next_win %\" PRIu32 \"\", ssn,\n                    ssn->server.next_win);\n            SCLogDebug(\"ssn %p: 4WHS ssn->client.isn %\" PRIu32 \", \"\n                    \"ssn->client.next_seq %\" PRIu32 \", \"\n                    \"ssn->client.last_ack %\" PRIu32 \" \"\n                    \"(ssn->server.last_ack %\" PRIu32 \")\", ssn,\n                    ssn->client.isn, ssn->client.next_seq,\n                    ssn->client.last_ack, ssn->server.last_ack);\n\n            /* done here */\n            return 0;\n        }\n\n        if (PKT_IS_TOSERVER(p)) {\n            StreamTcpSetEvent(p, STREAM_3WHS_SYNACK_IN_WRONG_DIRECTION);\n            SCLogDebug(\"ssn %p: SYN/ACK received in the wrong direction\", ssn);\n            return -1;\n        }\n\n        /* Check if the SYN/ACK packet ack's the earlier\n         * received SYN packet. */\n        if (!(SEQ_EQ(TCP_GET_ACK(p), ssn->client.isn + 1))) {\n            StreamTcpSetEvent(p, STREAM_3WHS_SYNACK_WITH_WRONG_ACK);\n            SCLogDebug(\"ssn %p: ACK mismatch, packet ACK %\" PRIu32 \" != \"\n                    \"%\" PRIu32 \" from stream\", ssn, TCP_GET_ACK(p),\n                    ssn->client.isn + 1);\n            return -1;\n        }\n\n        StreamTcp3whsSynAckUpdate(ssn, p, /* no queue override */NULL);\n\n    } else if (p->tcph->th_flags & TH_SYN) {\n        SCLogDebug(\"ssn %p: SYN packet on state SYN_SENT... resent\", ssn);\n        if (ssn->flags & STREAMTCP_FLAG_4WHS) {\n            SCLogDebug(\"ssn %p: SYN packet on state SYN_SENT... resent of \"\n                    \"4WHS SYN\", ssn);\n        }\n\n        if (PKT_IS_TOCLIENT(p)) {\n            /** a SYN only packet in the opposite direction could be:\n             *  http://www.breakingpointsystems.com/community/blog/tcp-\n             *  portals-the-three-way-handshake-is-a-lie\n             *\n             * \\todo improve resetting the session */\n\n            /* indicate that we're dealing with 4WHS here */\n            ssn->flags |= STREAMTCP_FLAG_4WHS;\n            SCLogDebug(\"ssn %p: STREAMTCP_FLAG_4WHS flag set\", ssn);\n\n            /* set the sequence numbers and window for server\n             * We leave the ssn->client.isn in place as we will\n             * check the SYN/ACK pkt with that.\n             */\n            ssn->server.isn = TCP_GET_SEQ(p);\n            STREAMTCP_SET_RA_BASE_SEQ(&ssn->server, ssn->server.isn);\n            ssn->server.next_seq = ssn->server.isn + 1;\n\n            /* Set the stream timestamp value, if packet has timestamp\n             * option enabled. */\n            if (TCP_HAS_TS(p)) {\n                ssn->server.last_ts = TCP_GET_TSVAL(p);\n                SCLogDebug(\"ssn %p: %02x\", ssn, ssn->server.last_ts);\n\n                if (ssn->server.last_ts == 0)\n                    ssn->server.flags |= STREAMTCP_STREAM_FLAG_ZERO_TIMESTAMP;\n                ssn->server.last_pkt_ts = p->ts.tv_sec;\n                ssn->server.flags |= STREAMTCP_STREAM_FLAG_TIMESTAMP;\n            }\n\n            ssn->server.window = TCP_GET_WINDOW(p);\n            if (TCP_HAS_WSCALE(p)) {\n                ssn->flags |= STREAMTCP_FLAG_SERVER_WSCALE;\n                ssn->server.wscale = TCP_GET_WSCALE(p);\n            } else {\n                ssn->flags &= ~STREAMTCP_FLAG_SERVER_WSCALE;\n                ssn->server.wscale = 0;\n            }\n\n            if (TCP_GET_SACKOK(p) == 1) {\n                ssn->flags |= STREAMTCP_FLAG_CLIENT_SACKOK;\n            } else {\n                ssn->flags &= ~STREAMTCP_FLAG_CLIENT_SACKOK;\n            }\n\n            SCLogDebug(\"ssn %p: 4WHS ssn->server.isn %\" PRIu32 \", \"\n                    \"ssn->server.next_seq %\" PRIu32 \", \"\n                    \"ssn->server.last_ack %\"PRIu32\"\", ssn,\n                    ssn->server.isn, ssn->server.next_seq,\n                    ssn->server.last_ack);\n            SCLogDebug(\"ssn %p: 4WHS ssn->client.isn %\" PRIu32 \", \"\n                    \"ssn->client.next_seq %\" PRIu32 \", \"\n                    \"ssn->client.last_ack %\"PRIu32\"\", ssn,\n                    ssn->client.isn, ssn->client.next_seq,\n                    ssn->client.last_ack);\n        }\n\n        /** \\todo check if it's correct or set event */\n\n    } else if (p->tcph->th_flags & TH_ACK) {\n        /* Handle the asynchronous stream, when we receive a  SYN packet\n           and now istead of receving a SYN/ACK we receive a ACK from the\n           same host, which sent the SYN, this suggests the ASNYC streams.*/\n        if (stream_config.async_oneside == FALSE)\n            return 0;\n\n        /* we are in AYNC (one side) mode now. */\n\n        /* one side async means we won't see a SYN/ACK, so we can\n         * only check the SYN. */\n        if (!(SEQ_EQ(TCP_GET_SEQ(p), ssn->client.next_seq))) {\n            StreamTcpSetEvent(p, STREAM_3WHS_ASYNC_WRONG_SEQ);\n\n            SCLogDebug(\"ssn %p: SEQ mismatch, packet SEQ %\" PRIu32 \" != \"\n                    \"%\" PRIu32 \" from stream\",ssn, TCP_GET_SEQ(p),\n                    ssn->client.next_seq);\n            return -1;\n        }\n\n        ssn->flags |= STREAMTCP_FLAG_ASYNC;\n        StreamTcpPacketSetState(p, ssn, TCP_ESTABLISHED);\n        SCLogDebug(\"ssn %p: =~ ssn state is now TCP_ESTABLISHED\", ssn);\n\n        ssn->client.window = TCP_GET_WINDOW(p);\n        ssn->client.last_ack = TCP_GET_SEQ(p);\n        ssn->client.next_win = ssn->client.last_ack + ssn->client.window;\n\n        /* Set the server side parameters */\n        ssn->server.isn = TCP_GET_ACK(p) - 1;\n        STREAMTCP_SET_RA_BASE_SEQ(&ssn->server, ssn->server.isn);\n        ssn->server.next_seq = ssn->server.isn + 1;\n        ssn->server.last_ack = ssn->server.next_seq;\n        ssn->server.next_win = ssn->server.last_ack;\n\n        SCLogDebug(\"ssn %p: synsent => Asynchronous stream, packet SEQ\"\n                \" %\" PRIu32 \", payload size %\" PRIu32 \" (%\" PRIu32 \"), \"\n                \"ssn->client.next_seq %\" PRIu32 \"\"\n                ,ssn, TCP_GET_SEQ(p), p->payload_len, TCP_GET_SEQ(p)\n                + p->payload_len, ssn->client.next_seq);\n\n        /* if SYN had wscale, assume it to be supported. Otherwise\n         * we know it not to be supported. */\n        if (ssn->flags & STREAMTCP_FLAG_SERVER_WSCALE) {\n            ssn->client.wscale = TCP_WSCALE_MAX;\n        }\n\n        /* Set the timestamp values used to validate the timestamp of\n         * received packets.*/\n        if (TCP_HAS_TS(p) &&\n                (ssn->client.flags & STREAMTCP_STREAM_FLAG_TIMESTAMP))\n        {\n            ssn->flags |= STREAMTCP_FLAG_TIMESTAMP;\n            ssn->client.flags &= ~STREAMTCP_STREAM_FLAG_TIMESTAMP;\n            ssn->client.last_pkt_ts = p->ts.tv_sec;\n        } else {\n            ssn->client.last_ts = 0;\n            ssn->client.flags &= ~STREAMTCP_STREAM_FLAG_ZERO_TIMESTAMP;\n        }\n\n        if (ssn->flags & STREAMTCP_FLAG_CLIENT_SACKOK) {\n            ssn->flags |= STREAMTCP_FLAG_SACKOK;\n        }\n\n        StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                &ssn->client, p, pq);\n\n    } else {\n        SCLogDebug(\"ssn %p: default case\", ssn);\n    }\n\n    return 0;\n}",
  "abstract_func_before": "static int StreamTcpPacketStateSynSent(ThreadVars *VAR_0, Packet *VAR_1,\n                        StreamTcpThread *VAR_2, TcpSession *VAR_3, PacketQueue *VAR_4)\n{\n    if (VAR_3 == NULL)\n        return -1;\n\n    SCLogDebug(\"ssn %p: pkt received: %s\", VAR_3, PKT_IS_TOCLIENT(VAR_1) ?\n               \"toclient\":\"toserver\");\n\n    /* COMMENT_0 */\n    if (VAR_1->tcph->th_flags & VAR_5) {\n        if (!StreamTcpValidateRst(VAR_3, VAR_1))\n            return -1;\n\n        if (PKT_IS_TOSERVER(VAR_1)) {\n            if (SEQ_EQ(TCP_GET_SEQ(VAR_1), VAR_3->client.isn) &&\n                    SEQ_EQ(TCP_GET_WINDOW(VAR_1), 0) &&\n                    SEQ_EQ(TCP_GET_ACK(VAR_1), (VAR_3->client.isn + 1)))\n            {\n                StreamTcpPacketSetState(VAR_1, VAR_3, VAR_6);\n                SCLogDebug(\"ssn %p: Reset received and state changed to \"\n                        \"TCP_CLOSED\", VAR_3);\n            }\n        } else {\n            StreamTcpPacketSetState(VAR_1, VAR_3, VAR_6);\n            SCLogDebug(\"ssn %p: Reset received and state changed to \"\n                    \"TCP_CLOSED\", VAR_3);\n        }\n\n    /* COMMENT_1 */\n    } else if (VAR_1->tcph->th_flags & VAR_7) {\n        /* COMMENT_2 */\n\n    /* COMMENT_3 */\n    } else if ((VAR_1->tcph->th_flags & (VAR_8|VAR_9)) == (VAR_8|VAR_9)) {\n        if ((VAR_3->flags & VAR_10) && PKT_IS_TOSERVER(VAR_1)) {\n            SCLogDebug(\"ssn %p: SYN/ACK received on 4WHS session\", VAR_3);\n\n            /* COMMENT_4 */\n                                      \n            if (!(SEQ_EQ(TCP_GET_ACK(VAR_1), VAR_3->server.isn + 1))) {\n                StreamTcpSetEvent(VAR_1, VAR_11);\n\n                SCLogDebug(\"ssn %p: 4WHS ACK mismatch, packet ACK %\"VAR_12\"\"\n                        \" != %\" VAR_12 \" from stream\", VAR_3,\n                        TCP_GET_ACK(VAR_1), VAR_3->server.isn + 1);\n                return -1;\n            }\n\n            /* COMMENT_6 */\n                         \n            if (!(SEQ_EQ(TCP_GET_SEQ(VAR_1), VAR_3->client.isn))) {\n                StreamTcpSetEvent(VAR_1, VAR_13);\n\n                SCLogDebug(\"ssn %p: 4WHS SEQ mismatch, packet SEQ %\"VAR_12\"\"\n                        \" != %\" VAR_12 \" from *first* SYN pkt\", VAR_3,\n                        TCP_GET_SEQ(VAR_1), VAR_3->client.isn);\n                return -1;\n            }\n\n\n            /* COMMENT_8 */\n            StreamTcpPacketSetState(VAR_1, VAR_3, VAR_14);\n            SCLogDebug(\"ssn %p: =~ 4WHS ssn state is now TCP_SYN_RECV\", VAR_3);\n\n            /* COMMENT_9 */\n            VAR_3->client.isn = TCP_GET_SEQ(VAR_1);\n            STREAMTCP_SET_RA_BASE_SEQ(&VAR_3->client, VAR_3->client.isn);\n            VAR_3->client.next_seq = VAR_3->client.isn + 1;\n\n            VAR_3->server.window = TCP_GET_WINDOW(VAR_1);\n            SCLogDebug(\"ssn %p: 4WHS window %\" VAR_12 \"\", VAR_3,\n                    VAR_3->client.window);\n\n            /* COMMENT_10 */\n                                   \n            if ((TCP_HAS_TS(VAR_1)) &&\n                    (VAR_3->server.flags & VAR_15))\n            {\n                VAR_3->client.last_ts = TCP_GET_TSVAL(VAR_1);\n                SCLogDebug(\"ssn %p: 4WHS ssn->client.last_ts %\" VAR_12\" \"\n                        \"ssn->server.last_ts %\" VAR_12\"\", VAR_3,\n                        VAR_3->client.last_ts, VAR_3->server.last_ts);\n                VAR_3->flags |= VAR_16;\n                VAR_3->client.last_pkt_ts = VAR_1->ts.tv_sec;\n                if (VAR_3->client.last_ts == 0)\n                    VAR_3->client.flags |= VAR_17;\n            } else {\n                VAR_3->server.last_ts = 0;\n                VAR_3->client.last_ts = 0;\n                VAR_3->server.flags &= ~VAR_17;\n            }\n\n            VAR_3->server.last_ack = TCP_GET_ACK(VAR_1);\n            VAR_3->client.last_ack = VAR_3->client.isn + 1;\n\n            /* COMMENT_12 */\n                                        \n            if ((VAR_3->flags & VAR_18) &&\n                    (TCP_HAS_WSCALE(VAR_1)))\n            {\n                VAR_3->server.wscale = TCP_GET_WSCALE(VAR_1);\n            } else {\n                VAR_3->server.wscale = 0;\n            }\n\n            if ((VAR_3->flags & VAR_19) &&\n                    TCP_GET_SACKOK(VAR_1) == 1) {\n                VAR_3->flags |= VAR_20;\n                SCLogDebug(\"ssn %p: SACK permitted for 4WHS session\", VAR_3);\n            }\n\n            VAR_3->client.next_win = VAR_3->client.last_ack + VAR_3->client.window;\n            VAR_3->server.next_win = VAR_3->server.last_ack + VAR_3->server.window;\n            SCLogDebug(\"ssn %p: 4WHS ssn->client.next_win %\" VAR_12 \"\", VAR_3,\n                    VAR_3->client.next_win);\n            SCLogDebug(\"ssn %p: 4WHS ssn->server.next_win %\" VAR_12 \"\", VAR_3,\n                    VAR_3->server.next_win);\n            SCLogDebug(\"ssn %p: 4WHS ssn->client.isn %\" VAR_12 \", \"\n                    \"ssn->client.next_seq %\" VAR_12 \", \"\n                    \"ssn->client.last_ack %\" VAR_12 \" \"\n                    \"(ssn->server.last_ack %\" VAR_12 \")\", VAR_3,\n                    VAR_3->client.isn, VAR_3->client.next_seq,\n                    VAR_3->client.last_ack, VAR_3->server.last_ack);\n\n            /* COMMENT_14 */\n            return 0;\n        }\n\n        if (PKT_IS_TOSERVER(VAR_1)) {\n            StreamTcpSetEvent(VAR_1, VAR_21);\n            SCLogDebug(\"ssn %p: SYN/ACK received in the wrong direction\", VAR_3);\n            return -1;\n        }\n\n        /* COMMENT_15 */\n                                  \n        if (!(SEQ_EQ(TCP_GET_ACK(VAR_1), VAR_3->client.isn + 1))) {\n            StreamTcpSetEvent(VAR_1, VAR_22);\n            SCLogDebug(\"ssn %p: ACK mismatch, packet ACK %\" VAR_12 \" != \"\n                    \"%\" VAR_12 \" from stream\", VAR_3, TCP_GET_ACK(VAR_1),\n                    VAR_3->client.isn + 1);\n            return -1;\n        }\n\n        StreamTcp3whsSynAckUpdate(VAR_3, VAR_1, /* COMMENT_17 */NULL);\n\n    } else if (VAR_1->tcph->th_flags & VAR_8) {\n        SCLogDebug(\"ssn %p: SYN packet on state SYN_SENT... resent\", VAR_3);\n        if (VAR_3->flags & VAR_10) {\n            SCLogDebug(\"ssn %p: SYN packet on state SYN_SENT... resent of \"\n                    \"4WHS SYN\", VAR_3);\n        }\n\n        if (PKT_IS_TOCLIENT(VAR_1)) {\n            /* COMMENT_18 */\n                                                                       \n                                                        \n              \n                                                     \n\n            /* COMMENT_23 */\n            VAR_3->flags |= VAR_10;\n            SCLogDebug(\"ssn %p: STREAMTCP_FLAG_4WHS flag set\", VAR_3);\n\n            /* COMMENT_24 */\n                                                               \n                                               \n               \n            VAR_3->server.isn = TCP_GET_SEQ(VAR_1);\n            STREAMTCP_SET_RA_BASE_SEQ(&VAR_3->server, VAR_3->server.isn);\n            VAR_3->server.next_seq = VAR_3->server.isn + 1;\n\n            /* COMMENT_28 */\n                                 \n            if (TCP_HAS_TS(VAR_1)) {\n                VAR_3->server.last_ts = TCP_GET_TSVAL(VAR_1);\n                SCLogDebug(\"ssn %p: %02x\", VAR_3, VAR_3->server.last_ts);\n\n                if (VAR_3->server.last_ts == 0)\n                    VAR_3->server.flags |= VAR_17;\n                VAR_3->server.last_pkt_ts = VAR_1->ts.tv_sec;\n                VAR_3->server.flags |= VAR_15;\n            }\n\n            VAR_3->server.window = TCP_GET_WINDOW(VAR_1);\n            if (TCP_HAS_WSCALE(VAR_1)) {\n                VAR_3->flags |= VAR_18;\n                VAR_3->server.wscale = TCP_GET_WSCALE(VAR_1);\n            } else {\n                VAR_3->flags &= ~VAR_18;\n                VAR_3->server.wscale = 0;\n            }\n\n            if (TCP_GET_SACKOK(VAR_1) == 1) {\n                VAR_3->flags |= VAR_19;\n            } else {\n                VAR_3->flags &= ~VAR_19;\n            }\n\n            SCLogDebug(\"ssn %p: 4WHS ssn->server.isn %\" VAR_12 \", \"\n                    \"ssn->server.next_seq %\" VAR_12 \", \"\n                    \"ssn->server.last_ack %\"VAR_12\"\", VAR_3,\n                    VAR_3->server.isn, VAR_3->server.next_seq,\n                    VAR_3->server.last_ack);\n            SCLogDebug(\"ssn %p: 4WHS ssn->client.isn %\" VAR_12 \", \"\n                    \"ssn->client.next_seq %\" VAR_12 \", \"\n                    \"ssn->client.last_ack %\"VAR_12\"\", VAR_3,\n                    VAR_3->client.isn, VAR_3->client.next_seq,\n                    VAR_3->client.last_ack);\n        }\n\n        /* COMMENT_30 */\n\n    } else if (VAR_1->tcph->th_flags & VAR_9) {\n        /* COMMENT_31 */\n                                                                         \n                                                                            \n        if (VAR_23.async_oneside == FALSE)\n            return 0;\n\n        /* COMMENT_34 */\n\n        /* COMMENT_35 */\n                                 \n        if (!(SEQ_EQ(TCP_GET_SEQ(VAR_1), VAR_3->client.next_seq))) {\n            StreamTcpSetEvent(VAR_1, VAR_24);\n\n            SCLogDebug(\"ssn %p: SEQ mismatch, packet SEQ %\" VAR_12 \" != \"\n                    \"%\" VAR_12 \" from stream\",VAR_3, TCP_GET_SEQ(VAR_1),\n                    VAR_3->client.next_seq);\n            return -1;\n        }\n\n        VAR_3->flags |= VAR_25;\n        StreamTcpPacketSetState(VAR_1, VAR_3, VAR_26);\n        SCLogDebug(\"ssn %p: =~ ssn state is now TCP_ESTABLISHED\", VAR_3);\n\n        VAR_3->client.window = TCP_GET_WINDOW(VAR_1);\n        VAR_3->client.last_ack = TCP_GET_SEQ(VAR_1);\n        VAR_3->client.next_win = VAR_3->client.last_ack + VAR_3->client.window;\n\n        /* COMMENT_37 */\n        VAR_3->server.isn = TCP_GET_ACK(VAR_1) - 1;\n        STREAMTCP_SET_RA_BASE_SEQ(&VAR_3->server, VAR_3->server.isn);\n        VAR_3->server.next_seq = VAR_3->server.isn + 1;\n        VAR_3->server.last_ack = VAR_3->server.next_seq;\n        VAR_3->server.next_win = VAR_3->server.last_ack;\n\n        SCLogDebug(\"ssn %p: synsent => Asynchronous stream, packet SEQ\"\n                \" %\" VAR_12 \", payload size %\" VAR_12 \" (%\" VAR_12 \"), \"\n                \"ssn->client.next_seq %\" VAR_12 \"\"\n                ,VAR_3, TCP_GET_SEQ(VAR_1), VAR_1->payload_len, TCP_GET_SEQ(VAR_1)\n                + VAR_1->payload_len, VAR_3->client.next_seq);\n\n        /* COMMENT_38 */\n                                             \n        if (VAR_3->flags & VAR_18) {\n            VAR_3->client.wscale = VAR_27;\n        }\n\n        /* COMMENT_40 */\n                              \n        if (TCP_HAS_TS(VAR_1) &&\n                (VAR_3->client.flags & VAR_15))\n        {\n            VAR_3->flags |= VAR_16;\n            VAR_3->client.flags &= ~VAR_15;\n            VAR_3->client.last_pkt_ts = VAR_1->ts.tv_sec;\n        } else {\n            VAR_3->client.last_ts = 0;\n            VAR_3->client.flags &= ~VAR_17;\n        }\n\n        if (VAR_3->flags & VAR_19) {\n            VAR_3->flags |= VAR_20;\n        }\n\n        StreamTcpReassembleHandleSegment(VAR_0, VAR_2->ra_ctx, VAR_3,\n                &VAR_3->client, VAR_1, VAR_4);\n\n    } else {\n        SCLogDebug(\"ssn %p: default case\", VAR_3);\n    }\n\n    return 0;\n}",
  "func_graph_path_before": "OISF/suricata/843d0b7a10bb45627f94764a6c5d468a24143345/stream-tcp.c/vul/before/0.json",
  "func": "static int StreamTcpPacketStateSynSent(ThreadVars *tv, Packet *p,\n                        StreamTcpThread *stt, TcpSession *ssn, PacketQueue *pq)\n{\n    if (ssn == NULL)\n        return -1;\n\n    SCLogDebug(\"ssn %p: pkt received: %s\", ssn, PKT_IS_TOCLIENT(p) ?\n               \"toclient\":\"toserver\");\n\n    /* RST */\n    if (p->tcph->th_flags & TH_RST) {\n        if (!StreamTcpValidateRst(ssn, p))\n            return -1;\n\n        if (PKT_IS_TOSERVER(p)) {\n            if (SEQ_EQ(TCP_GET_SEQ(p), ssn->client.isn) &&\n                    SEQ_EQ(TCP_GET_WINDOW(p), 0) &&\n                    SEQ_EQ(TCP_GET_ACK(p), (ssn->client.isn + 1)))\n            {\n                SCLogDebug(\"ssn->server.flags |= STREAMTCP_STREAM_FLAG_RST_RECV\");\n                ssn->server.flags |= STREAMTCP_STREAM_FLAG_RST_RECV;\n\n                StreamTcpPacketSetState(p, ssn, TCP_CLOSED);\n                SCLogDebug(\"ssn %p: Reset received and state changed to \"\n                        \"TCP_CLOSED\", ssn);\n            }\n        } else {\n            ssn->client.flags |= STREAMTCP_STREAM_FLAG_RST_RECV;\n            SCLogDebug(\"ssn->client.flags |= STREAMTCP_STREAM_FLAG_RST_RECV\");\n            StreamTcpPacketSetState(p, ssn, TCP_CLOSED);\n            SCLogDebug(\"ssn %p: Reset received and state changed to \"\n                    \"TCP_CLOSED\", ssn);\n        }\n\n    /* FIN */\n    } else if (p->tcph->th_flags & TH_FIN) {\n        /** \\todo */\n\n    /* SYN/ACK */\n    } else if ((p->tcph->th_flags & (TH_SYN|TH_ACK)) == (TH_SYN|TH_ACK)) {\n        if ((ssn->flags & STREAMTCP_FLAG_4WHS) && PKT_IS_TOSERVER(p)) {\n            SCLogDebug(\"ssn %p: SYN/ACK received on 4WHS session\", ssn);\n\n            /* Check if the SYN/ACK packet ack's the earlier\n             * received SYN packet. */\n            if (!(SEQ_EQ(TCP_GET_ACK(p), ssn->server.isn + 1))) {\n                StreamTcpSetEvent(p, STREAM_4WHS_SYNACK_WITH_WRONG_ACK);\n\n                SCLogDebug(\"ssn %p: 4WHS ACK mismatch, packet ACK %\"PRIu32\"\"\n                        \" != %\" PRIu32 \" from stream\", ssn,\n                        TCP_GET_ACK(p), ssn->server.isn + 1);\n                return -1;\n            }\n\n            /* Check if the SYN/ACK packet SEQ's the *FIRST* received SYN\n             * packet. */\n            if (!(SEQ_EQ(TCP_GET_SEQ(p), ssn->client.isn))) {\n                StreamTcpSetEvent(p, STREAM_4WHS_SYNACK_WITH_WRONG_SYN);\n\n                SCLogDebug(\"ssn %p: 4WHS SEQ mismatch, packet SEQ %\"PRIu32\"\"\n                        \" != %\" PRIu32 \" from *first* SYN pkt\", ssn,\n                        TCP_GET_SEQ(p), ssn->client.isn);\n                return -1;\n            }\n\n\n            /* update state */\n            StreamTcpPacketSetState(p, ssn, TCP_SYN_RECV);\n            SCLogDebug(\"ssn %p: =~ 4WHS ssn state is now TCP_SYN_RECV\", ssn);\n\n            /* sequence number & window */\n            ssn->client.isn = TCP_GET_SEQ(p);\n            STREAMTCP_SET_RA_BASE_SEQ(&ssn->client, ssn->client.isn);\n            ssn->client.next_seq = ssn->client.isn + 1;\n\n            ssn->server.window = TCP_GET_WINDOW(p);\n            SCLogDebug(\"ssn %p: 4WHS window %\" PRIu32 \"\", ssn,\n                    ssn->client.window);\n\n            /* Set the timestamp values used to validate the timestamp of\n             * received packets. */\n            if ((TCP_HAS_TS(p)) &&\n                    (ssn->server.flags & STREAMTCP_STREAM_FLAG_TIMESTAMP))\n            {\n                ssn->client.last_ts = TCP_GET_TSVAL(p);\n                SCLogDebug(\"ssn %p: 4WHS ssn->client.last_ts %\" PRIu32\" \"\n                        \"ssn->server.last_ts %\" PRIu32\"\", ssn,\n                        ssn->client.last_ts, ssn->server.last_ts);\n                ssn->flags |= STREAMTCP_FLAG_TIMESTAMP;\n                ssn->client.last_pkt_ts = p->ts.tv_sec;\n                if (ssn->client.last_ts == 0)\n                    ssn->client.flags |= STREAMTCP_STREAM_FLAG_ZERO_TIMESTAMP;\n            } else {\n                ssn->server.last_ts = 0;\n                ssn->client.last_ts = 0;\n                ssn->server.flags &= ~STREAMTCP_STREAM_FLAG_ZERO_TIMESTAMP;\n            }\n\n            ssn->server.last_ack = TCP_GET_ACK(p);\n            ssn->client.last_ack = ssn->client.isn + 1;\n\n            /** check for the presense of the ws ptr to determine if we\n             *  support wscale at all */\n            if ((ssn->flags & STREAMTCP_FLAG_SERVER_WSCALE) &&\n                    (TCP_HAS_WSCALE(p)))\n            {\n                ssn->server.wscale = TCP_GET_WSCALE(p);\n            } else {\n                ssn->server.wscale = 0;\n            }\n\n            if ((ssn->flags & STREAMTCP_FLAG_CLIENT_SACKOK) &&\n                    TCP_GET_SACKOK(p) == 1) {\n                ssn->flags |= STREAMTCP_FLAG_SACKOK;\n                SCLogDebug(\"ssn %p: SACK permitted for 4WHS session\", ssn);\n            }\n\n            ssn->client.next_win = ssn->client.last_ack + ssn->client.window;\n            ssn->server.next_win = ssn->server.last_ack + ssn->server.window;\n            SCLogDebug(\"ssn %p: 4WHS ssn->client.next_win %\" PRIu32 \"\", ssn,\n                    ssn->client.next_win);\n            SCLogDebug(\"ssn %p: 4WHS ssn->server.next_win %\" PRIu32 \"\", ssn,\n                    ssn->server.next_win);\n            SCLogDebug(\"ssn %p: 4WHS ssn->client.isn %\" PRIu32 \", \"\n                    \"ssn->client.next_seq %\" PRIu32 \", \"\n                    \"ssn->client.last_ack %\" PRIu32 \" \"\n                    \"(ssn->server.last_ack %\" PRIu32 \")\", ssn,\n                    ssn->client.isn, ssn->client.next_seq,\n                    ssn->client.last_ack, ssn->server.last_ack);\n\n            /* done here */\n            return 0;\n        }\n\n        if (PKT_IS_TOSERVER(p)) {\n            StreamTcpSetEvent(p, STREAM_3WHS_SYNACK_IN_WRONG_DIRECTION);\n            SCLogDebug(\"ssn %p: SYN/ACK received in the wrong direction\", ssn);\n            return -1;\n        }\n\n        /* Check if the SYN/ACK packet ack's the earlier\n         * received SYN packet. */\n        if (!(SEQ_EQ(TCP_GET_ACK(p), ssn->client.isn + 1))) {\n            StreamTcpSetEvent(p, STREAM_3WHS_SYNACK_WITH_WRONG_ACK);\n            SCLogDebug(\"ssn %p: ACK mismatch, packet ACK %\" PRIu32 \" != \"\n                    \"%\" PRIu32 \" from stream\", ssn, TCP_GET_ACK(p),\n                    ssn->client.isn + 1);\n            return -1;\n        }\n\n        StreamTcp3whsSynAckUpdate(ssn, p, /* no queue override */NULL);\n\n    } else if (p->tcph->th_flags & TH_SYN) {\n        SCLogDebug(\"ssn %p: SYN packet on state SYN_SENT... resent\", ssn);\n        if (ssn->flags & STREAMTCP_FLAG_4WHS) {\n            SCLogDebug(\"ssn %p: SYN packet on state SYN_SENT... resent of \"\n                    \"4WHS SYN\", ssn);\n        }\n\n        if (PKT_IS_TOCLIENT(p)) {\n            /** a SYN only packet in the opposite direction could be:\n             *  http://www.breakingpointsystems.com/community/blog/tcp-\n             *  portals-the-three-way-handshake-is-a-lie\n             *\n             * \\todo improve resetting the session */\n\n            /* indicate that we're dealing with 4WHS here */\n            ssn->flags |= STREAMTCP_FLAG_4WHS;\n            SCLogDebug(\"ssn %p: STREAMTCP_FLAG_4WHS flag set\", ssn);\n\n            /* set the sequence numbers and window for server\n             * We leave the ssn->client.isn in place as we will\n             * check the SYN/ACK pkt with that.\n             */\n            ssn->server.isn = TCP_GET_SEQ(p);\n            STREAMTCP_SET_RA_BASE_SEQ(&ssn->server, ssn->server.isn);\n            ssn->server.next_seq = ssn->server.isn + 1;\n\n            /* Set the stream timestamp value, if packet has timestamp\n             * option enabled. */\n            if (TCP_HAS_TS(p)) {\n                ssn->server.last_ts = TCP_GET_TSVAL(p);\n                SCLogDebug(\"ssn %p: %02x\", ssn, ssn->server.last_ts);\n\n                if (ssn->server.last_ts == 0)\n                    ssn->server.flags |= STREAMTCP_STREAM_FLAG_ZERO_TIMESTAMP;\n                ssn->server.last_pkt_ts = p->ts.tv_sec;\n                ssn->server.flags |= STREAMTCP_STREAM_FLAG_TIMESTAMP;\n            }\n\n            ssn->server.window = TCP_GET_WINDOW(p);\n            if (TCP_HAS_WSCALE(p)) {\n                ssn->flags |= STREAMTCP_FLAG_SERVER_WSCALE;\n                ssn->server.wscale = TCP_GET_WSCALE(p);\n            } else {\n                ssn->flags &= ~STREAMTCP_FLAG_SERVER_WSCALE;\n                ssn->server.wscale = 0;\n            }\n\n            if (TCP_GET_SACKOK(p) == 1) {\n                ssn->flags |= STREAMTCP_FLAG_CLIENT_SACKOK;\n            } else {\n                ssn->flags &= ~STREAMTCP_FLAG_CLIENT_SACKOK;\n            }\n\n            SCLogDebug(\"ssn %p: 4WHS ssn->server.isn %\" PRIu32 \", \"\n                    \"ssn->server.next_seq %\" PRIu32 \", \"\n                    \"ssn->server.last_ack %\"PRIu32\"\", ssn,\n                    ssn->server.isn, ssn->server.next_seq,\n                    ssn->server.last_ack);\n            SCLogDebug(\"ssn %p: 4WHS ssn->client.isn %\" PRIu32 \", \"\n                    \"ssn->client.next_seq %\" PRIu32 \", \"\n                    \"ssn->client.last_ack %\"PRIu32\"\", ssn,\n                    ssn->client.isn, ssn->client.next_seq,\n                    ssn->client.last_ack);\n        }\n\n        /** \\todo check if it's correct or set event */\n\n    } else if (p->tcph->th_flags & TH_ACK) {\n        /* Handle the asynchronous stream, when we receive a  SYN packet\n           and now istead of receving a SYN/ACK we receive a ACK from the\n           same host, which sent the SYN, this suggests the ASNYC streams.*/\n        if (stream_config.async_oneside == FALSE)\n            return 0;\n\n        /* we are in AYNC (one side) mode now. */\n\n        /* one side async means we won't see a SYN/ACK, so we can\n         * only check the SYN. */\n        if (!(SEQ_EQ(TCP_GET_SEQ(p), ssn->client.next_seq))) {\n            StreamTcpSetEvent(p, STREAM_3WHS_ASYNC_WRONG_SEQ);\n\n            SCLogDebug(\"ssn %p: SEQ mismatch, packet SEQ %\" PRIu32 \" != \"\n                    \"%\" PRIu32 \" from stream\",ssn, TCP_GET_SEQ(p),\n                    ssn->client.next_seq);\n            return -1;\n        }\n\n        ssn->flags |= STREAMTCP_FLAG_ASYNC;\n        StreamTcpPacketSetState(p, ssn, TCP_ESTABLISHED);\n        SCLogDebug(\"ssn %p: =~ ssn state is now TCP_ESTABLISHED\", ssn);\n\n        ssn->client.window = TCP_GET_WINDOW(p);\n        ssn->client.last_ack = TCP_GET_SEQ(p);\n        ssn->client.next_win = ssn->client.last_ack + ssn->client.window;\n\n        /* Set the server side parameters */\n        ssn->server.isn = TCP_GET_ACK(p) - 1;\n        STREAMTCP_SET_RA_BASE_SEQ(&ssn->server, ssn->server.isn);\n        ssn->server.next_seq = ssn->server.isn + 1;\n        ssn->server.last_ack = ssn->server.next_seq;\n        ssn->server.next_win = ssn->server.last_ack;\n\n        SCLogDebug(\"ssn %p: synsent => Asynchronous stream, packet SEQ\"\n                \" %\" PRIu32 \", payload size %\" PRIu32 \" (%\" PRIu32 \"), \"\n                \"ssn->client.next_seq %\" PRIu32 \"\"\n                ,ssn, TCP_GET_SEQ(p), p->payload_len, TCP_GET_SEQ(p)\n                + p->payload_len, ssn->client.next_seq);\n\n        /* if SYN had wscale, assume it to be supported. Otherwise\n         * we know it not to be supported. */\n        if (ssn->flags & STREAMTCP_FLAG_SERVER_WSCALE) {\n            ssn->client.wscale = TCP_WSCALE_MAX;\n        }\n\n        /* Set the timestamp values used to validate the timestamp of\n         * received packets.*/\n        if (TCP_HAS_TS(p) &&\n                (ssn->client.flags & STREAMTCP_STREAM_FLAG_TIMESTAMP))\n        {\n            ssn->flags |= STREAMTCP_FLAG_TIMESTAMP;\n            ssn->client.flags &= ~STREAMTCP_STREAM_FLAG_TIMESTAMP;\n            ssn->client.last_pkt_ts = p->ts.tv_sec;\n        } else {\n            ssn->client.last_ts = 0;\n            ssn->client.flags &= ~STREAMTCP_STREAM_FLAG_ZERO_TIMESTAMP;\n        }\n\n        if (ssn->flags & STREAMTCP_FLAG_CLIENT_SACKOK) {\n            ssn->flags |= STREAMTCP_FLAG_SACKOK;\n        }\n\n        StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                &ssn->client, p, pq);\n\n    } else {\n        SCLogDebug(\"ssn %p: default case\", ssn);\n    }\n\n    return 0;\n}",
  "abstract_func": "static int StreamTcpPacketStateSynSent(ThreadVars *VAR_0, Packet *VAR_1,\n                        StreamTcpThread *VAR_2, TcpSession *VAR_3, PacketQueue *VAR_4)\n{\n    if (VAR_3 == NULL)\n        return -1;\n\n    SCLogDebug(\"ssn %p: pkt received: %s\", VAR_3, PKT_IS_TOCLIENT(VAR_1) ?\n               \"toclient\":\"toserver\");\n\n    /* COMMENT_0 */\n    if (VAR_1->tcph->th_flags & VAR_5) {\n        if (!StreamTcpValidateRst(VAR_3, VAR_1))\n            return -1;\n\n        if (PKT_IS_TOSERVER(VAR_1)) {\n            if (SEQ_EQ(TCP_GET_SEQ(VAR_1), VAR_3->client.isn) &&\n                    SEQ_EQ(TCP_GET_WINDOW(VAR_1), 0) &&\n                    SEQ_EQ(TCP_GET_ACK(VAR_1), (VAR_3->client.isn + 1)))\n            {\n                SCLogDebug(\"ssn->server.flags |= STREAMTCP_STREAM_FLAG_RST_RECV\");\n                VAR_3->server.flags |= VAR_6;\n\n                StreamTcpPacketSetState(VAR_1, VAR_3, VAR_7);\n                SCLogDebug(\"ssn %p: Reset received and state changed to \"\n                        \"TCP_CLOSED\", VAR_3);\n            }\n        } else {\n            VAR_3->client.flags |= VAR_6;\n            SCLogDebug(\"ssn->client.flags |= STREAMTCP_STREAM_FLAG_RST_RECV\");\n            StreamTcpPacketSetState(VAR_1, VAR_3, VAR_7);\n            SCLogDebug(\"ssn %p: Reset received and state changed to \"\n                    \"TCP_CLOSED\", VAR_3);\n        }\n\n    /* COMMENT_1 */\n    } else if (VAR_1->tcph->th_flags & VAR_8) {\n        /* COMMENT_2 */\n\n    /* COMMENT_3 */\n    } else if ((VAR_1->tcph->th_flags & (VAR_9|VAR_10)) == (VAR_9|VAR_10)) {\n        if ((VAR_3->flags & VAR_11) && PKT_IS_TOSERVER(VAR_1)) {\n            SCLogDebug(\"ssn %p: SYN/ACK received on 4WHS session\", VAR_3);\n\n            /* COMMENT_4 */\n                                      \n            if (!(SEQ_EQ(TCP_GET_ACK(VAR_1), VAR_3->server.isn + 1))) {\n                StreamTcpSetEvent(VAR_1, VAR_12);\n\n                SCLogDebug(\"ssn %p: 4WHS ACK mismatch, packet ACK %\"VAR_13\"\"\n                        \" != %\" VAR_13 \" from stream\", VAR_3,\n                        TCP_GET_ACK(VAR_1), VAR_3->server.isn + 1);\n                return -1;\n            }\n\n            /* COMMENT_6 */\n                         \n            if (!(SEQ_EQ(TCP_GET_SEQ(VAR_1), VAR_3->client.isn))) {\n                StreamTcpSetEvent(VAR_1, VAR_14);\n\n                SCLogDebug(\"ssn %p: 4WHS SEQ mismatch, packet SEQ %\"VAR_13\"\"\n                        \" != %\" VAR_13 \" from *first* SYN pkt\", VAR_3,\n                        TCP_GET_SEQ(VAR_1), VAR_3->client.isn);\n                return -1;\n            }\n\n\n            /* COMMENT_8 */\n            StreamTcpPacketSetState(VAR_1, VAR_3, VAR_15);\n            SCLogDebug(\"ssn %p: =~ 4WHS ssn state is now TCP_SYN_RECV\", VAR_3);\n\n            /* COMMENT_9 */\n            VAR_3->client.isn = TCP_GET_SEQ(VAR_1);\n            STREAMTCP_SET_RA_BASE_SEQ(&VAR_3->client, VAR_3->client.isn);\n            VAR_3->client.next_seq = VAR_3->client.isn + 1;\n\n            VAR_3->server.window = TCP_GET_WINDOW(VAR_1);\n            SCLogDebug(\"ssn %p: 4WHS window %\" VAR_13 \"\", VAR_3,\n                    VAR_3->client.window);\n\n            /* COMMENT_10 */\n                                   \n            if ((TCP_HAS_TS(VAR_1)) &&\n                    (VAR_3->server.flags & VAR_16))\n            {\n                VAR_3->client.last_ts = TCP_GET_TSVAL(VAR_1);\n                SCLogDebug(\"ssn %p: 4WHS ssn->client.last_ts %\" VAR_13\" \"\n                        \"ssn->server.last_ts %\" VAR_13\"\", VAR_3,\n                        VAR_3->client.last_ts, VAR_3->server.last_ts);\n                VAR_3->flags |= VAR_17;\n                VAR_3->client.last_pkt_ts = VAR_1->ts.tv_sec;\n                if (VAR_3->client.last_ts == 0)\n                    VAR_3->client.flags |= VAR_18;\n            } else {\n                VAR_3->server.last_ts = 0;\n                VAR_3->client.last_ts = 0;\n                VAR_3->server.flags &= ~VAR_18;\n            }\n\n            VAR_3->server.last_ack = TCP_GET_ACK(VAR_1);\n            VAR_3->client.last_ack = VAR_3->client.isn + 1;\n\n            /* COMMENT_12 */\n                                        \n            if ((VAR_3->flags & VAR_19) &&\n                    (TCP_HAS_WSCALE(VAR_1)))\n            {\n                VAR_3->server.wscale = TCP_GET_WSCALE(VAR_1);\n            } else {\n                VAR_3->server.wscale = 0;\n            }\n\n            if ((VAR_3->flags & VAR_20) &&\n                    TCP_GET_SACKOK(VAR_1) == 1) {\n                VAR_3->flags |= VAR_21;\n                SCLogDebug(\"ssn %p: SACK permitted for 4WHS session\", VAR_3);\n            }\n\n            VAR_3->client.next_win = VAR_3->client.last_ack + VAR_3->client.window;\n            VAR_3->server.next_win = VAR_3->server.last_ack + VAR_3->server.window;\n            SCLogDebug(\"ssn %p: 4WHS ssn->client.next_win %\" VAR_13 \"\", VAR_3,\n                    VAR_3->client.next_win);\n            SCLogDebug(\"ssn %p: 4WHS ssn->server.next_win %\" VAR_13 \"\", VAR_3,\n                    VAR_3->server.next_win);\n            SCLogDebug(\"ssn %p: 4WHS ssn->client.isn %\" VAR_13 \", \"\n                    \"ssn->client.next_seq %\" VAR_13 \", \"\n                    \"ssn->client.last_ack %\" VAR_13 \" \"\n                    \"(ssn->server.last_ack %\" VAR_13 \")\", VAR_3,\n                    VAR_3->client.isn, VAR_3->client.next_seq,\n                    VAR_3->client.last_ack, VAR_3->server.last_ack);\n\n            /* COMMENT_14 */\n            return 0;\n        }\n\n        if (PKT_IS_TOSERVER(VAR_1)) {\n            StreamTcpSetEvent(VAR_1, VAR_22);\n            SCLogDebug(\"ssn %p: SYN/ACK received in the wrong direction\", VAR_3);\n            return -1;\n        }\n\n        /* COMMENT_15 */\n                                  \n        if (!(SEQ_EQ(TCP_GET_ACK(VAR_1), VAR_3->client.isn + 1))) {\n            StreamTcpSetEvent(VAR_1, VAR_23);\n            SCLogDebug(\"ssn %p: ACK mismatch, packet ACK %\" VAR_13 \" != \"\n                    \"%\" VAR_13 \" from stream\", VAR_3, TCP_GET_ACK(VAR_1),\n                    VAR_3->client.isn + 1);\n            return -1;\n        }\n\n        StreamTcp3whsSynAckUpdate(VAR_3, VAR_1, /* COMMENT_17 */NULL);\n\n    } else if (VAR_1->tcph->th_flags & VAR_9) {\n        SCLogDebug(\"ssn %p: SYN packet on state SYN_SENT... resent\", VAR_3);\n        if (VAR_3->flags & VAR_11) {\n            SCLogDebug(\"ssn %p: SYN packet on state SYN_SENT... resent of \"\n                    \"4WHS SYN\", VAR_3);\n        }\n\n        if (PKT_IS_TOCLIENT(VAR_1)) {\n            /* COMMENT_18 */\n                                                                       \n                                                        \n              \n                                                     \n\n            /* COMMENT_23 */\n            VAR_3->flags |= VAR_11;\n            SCLogDebug(\"ssn %p: STREAMTCP_FLAG_4WHS flag set\", VAR_3);\n\n            /* COMMENT_24 */\n                                                               \n                                               \n               \n            VAR_3->server.isn = TCP_GET_SEQ(VAR_1);\n            STREAMTCP_SET_RA_BASE_SEQ(&VAR_3->server, VAR_3->server.isn);\n            VAR_3->server.next_seq = VAR_3->server.isn + 1;\n\n            /* COMMENT_28 */\n                                 \n            if (TCP_HAS_TS(VAR_1)) {\n                VAR_3->server.last_ts = TCP_GET_TSVAL(VAR_1);\n                SCLogDebug(\"ssn %p: %02x\", VAR_3, VAR_3->server.last_ts);\n\n                if (VAR_3->server.last_ts == 0)\n                    VAR_3->server.flags |= VAR_18;\n                VAR_3->server.last_pkt_ts = VAR_1->ts.tv_sec;\n                VAR_3->server.flags |= VAR_16;\n            }\n\n            VAR_3->server.window = TCP_GET_WINDOW(VAR_1);\n            if (TCP_HAS_WSCALE(VAR_1)) {\n                VAR_3->flags |= VAR_19;\n                VAR_3->server.wscale = TCP_GET_WSCALE(VAR_1);\n            } else {\n                VAR_3->flags &= ~VAR_19;\n                VAR_3->server.wscale = 0;\n            }\n\n            if (TCP_GET_SACKOK(VAR_1) == 1) {\n                VAR_3->flags |= VAR_20;\n            } else {\n                VAR_3->flags &= ~VAR_20;\n            }\n\n            SCLogDebug(\"ssn %p: 4WHS ssn->server.isn %\" VAR_13 \", \"\n                    \"ssn->server.next_seq %\" VAR_13 \", \"\n                    \"ssn->server.last_ack %\"VAR_13\"\", VAR_3,\n                    VAR_3->server.isn, VAR_3->server.next_seq,\n                    VAR_3->server.last_ack);\n            SCLogDebug(\"ssn %p: 4WHS ssn->client.isn %\" VAR_13 \", \"\n                    \"ssn->client.next_seq %\" VAR_13 \", \"\n                    \"ssn->client.last_ack %\"VAR_13\"\", VAR_3,\n                    VAR_3->client.isn, VAR_3->client.next_seq,\n                    VAR_3->client.last_ack);\n        }\n\n        /* COMMENT_30 */\n\n    } else if (VAR_1->tcph->th_flags & VAR_10) {\n        /* COMMENT_31 */\n                                                                         \n                                                                            \n        if (VAR_24.async_oneside == FALSE)\n            return 0;\n\n        /* COMMENT_34 */\n\n        /* COMMENT_35 */\n                                 \n        if (!(SEQ_EQ(TCP_GET_SEQ(VAR_1), VAR_3->client.next_seq))) {\n            StreamTcpSetEvent(VAR_1, VAR_25);\n\n            SCLogDebug(\"ssn %p: SEQ mismatch, packet SEQ %\" VAR_13 \" != \"\n                    \"%\" VAR_13 \" from stream\",VAR_3, TCP_GET_SEQ(VAR_1),\n                    VAR_3->client.next_seq);\n            return -1;\n        }\n\n        VAR_3->flags |= VAR_26;\n        StreamTcpPacketSetState(VAR_1, VAR_3, VAR_27);\n        SCLogDebug(\"ssn %p: =~ ssn state is now TCP_ESTABLISHED\", VAR_3);\n\n        VAR_3->client.window = TCP_GET_WINDOW(VAR_1);\n        VAR_3->client.last_ack = TCP_GET_SEQ(VAR_1);\n        VAR_3->client.next_win = VAR_3->client.last_ack + VAR_3->client.window;\n\n        /* COMMENT_37 */\n        VAR_3->server.isn = TCP_GET_ACK(VAR_1) - 1;\n        STREAMTCP_SET_RA_BASE_SEQ(&VAR_3->server, VAR_3->server.isn);\n        VAR_3->server.next_seq = VAR_3->server.isn + 1;\n        VAR_3->server.last_ack = VAR_3->server.next_seq;\n        VAR_3->server.next_win = VAR_3->server.last_ack;\n\n        SCLogDebug(\"ssn %p: synsent => Asynchronous stream, packet SEQ\"\n                \" %\" VAR_13 \", payload size %\" VAR_13 \" (%\" VAR_13 \"), \"\n                \"ssn->client.next_seq %\" VAR_13 \"\"\n                ,VAR_3, TCP_GET_SEQ(VAR_1), VAR_1->payload_len, TCP_GET_SEQ(VAR_1)\n                + VAR_1->payload_len, VAR_3->client.next_seq);\n\n        /* COMMENT_38 */\n                                             \n        if (VAR_3->flags & VAR_19) {\n            VAR_3->client.wscale = VAR_28;\n        }\n\n        /* COMMENT_40 */\n                              \n        if (TCP_HAS_TS(VAR_1) &&\n                (VAR_3->client.flags & VAR_16))\n        {\n            VAR_3->flags |= VAR_17;\n            VAR_3->client.flags &= ~VAR_16;\n            VAR_3->client.last_pkt_ts = VAR_1->ts.tv_sec;\n        } else {\n            VAR_3->client.last_ts = 0;\n            VAR_3->client.flags &= ~VAR_18;\n        }\n\n        if (VAR_3->flags & VAR_20) {\n            VAR_3->flags |= VAR_21;\n        }\n\n        StreamTcpReassembleHandleSegment(VAR_0, VAR_2->ra_ctx, VAR_3,\n                &VAR_3->client, VAR_1, VAR_4);\n\n    } else {\n        SCLogDebug(\"ssn %p: default case\", VAR_3);\n    }\n\n    return 0;\n}",
  "func_graph_path": "OISF/suricata/843d0b7a10bb45627f94764a6c5d468a24143345/stream-tcp.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -17,11 +17,16 @@\n                     SEQ_EQ(TCP_GET_WINDOW(p), 0) &&\n                     SEQ_EQ(TCP_GET_ACK(p), (ssn->client.isn + 1)))\n             {\n+                SCLogDebug(\"ssn->server.flags |= STREAMTCP_STREAM_FLAG_RST_RECV\");\n+                ssn->server.flags |= STREAMTCP_STREAM_FLAG_RST_RECV;\n+\n                 StreamTcpPacketSetState(p, ssn, TCP_CLOSED);\n                 SCLogDebug(\"ssn %p: Reset received and state changed to \"\n                         \"TCP_CLOSED\", ssn);\n             }\n         } else {\n+            ssn->client.flags |= STREAMTCP_STREAM_FLAG_RST_RECV;\n+            SCLogDebug(\"ssn->client.flags |= STREAMTCP_STREAM_FLAG_RST_RECV\");\n             StreamTcpPacketSetState(p, ssn, TCP_CLOSED);\n             SCLogDebug(\"ssn %p: Reset received and state changed to \"\n                     \"TCP_CLOSED\", ssn);",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "                SCLogDebug(\"ssn->server.flags |= STREAMTCP_STREAM_FLAG_RST_RECV\");",
      "                ssn->server.flags |= STREAMTCP_STREAM_FLAG_RST_RECV;",
      "",
      "            ssn->client.flags |= STREAMTCP_STREAM_FLAG_RST_RECV;",
      "            SCLogDebug(\"ssn->client.flags |= STREAMTCP_STREAM_FLAG_RST_RECV\");"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/OISF/suricata/pull/3428",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/OISF/suricata/pull/3428: 403 Client Error: Forbidden for url: https://api.github.com/repos/OISF/suricata/pulls/3428",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "Final Classification: Defect Remediation & Feature Upgrades  \nConfidence: 0.9"
}