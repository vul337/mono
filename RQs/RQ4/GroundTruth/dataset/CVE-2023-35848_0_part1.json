{
  "cve_id": "CVE-2023-35848",
  "cwe_ids": [
    "CWE-682",
    "CWE-754"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "virtualsquare/picotcp",
  "commit_msg": "More checks for correct header sizes\n\nReported-by: \"P. Amsuo, Purdue University\"",
  "commit_hash": "4b9a16764f2b12b611de9c34a50b4713d10ca401",
  "git_url": "https://github.com/virtualsquare/picotcp/commit/4b9a16764f2b12b611de9c34a50b4713d10ca401",
  "file_path": "modules/pico_tcp.c",
  "func_name": "tcp_parse_options",
  "func_before": "static int tcp_parse_options(struct pico_frame *f)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)f->sock;\n    uint8_t *opt = f->transport_hdr + PICO_SIZE_TCPHDR;\n    uint32_t i = 0;\n    f->timestamp = 0;\n    while (i < (f->transport_len - PICO_SIZE_TCPHDR)) {\n        uint8_t type =  opt[i++];\n        uint8_t len;\n        if(i < (f->transport_len - PICO_SIZE_TCPHDR) && (type > 1))\n            len =  opt[i++];\n        else\n            len = 1;\n\n        if (f->payload && ((opt + i) > f->payload))\n            break;\n\n        if (len == 0) {\n            return -1;\n        }\n\n        tcp_dbg_options(\"Received option '%d', len = %d \\n\", type, len);\n        switch (type) {\n        case PICO_TCP_OPTION_NOOP:\n        case PICO_TCP_OPTION_END:\n            break;\n        case PICO_TCP_OPTION_WS:\n            tcp_parse_option_ws(t, len, opt, &i);\n            break;\n        case PICO_TCP_OPTION_SACK_OK:\n            tcp_parse_option_sack_ok(t, f, len, &i);\n            break;\n        case PICO_TCP_OPTION_MSS:\n            tcp_parse_option_mss(t, len, opt, &i);\n            break;\n        case PICO_TCP_OPTION_TIMESTAMP:\n            tcp_parse_option_timestamp(t, f, len, opt, &i);\n            break;\n\n        case PICO_TCP_OPTION_SACK:\n            tcp_rcv_sack(t, opt + i, len - 2);\n            i = i + len - 2;\n            break;\n        default:\n            tcp_dbg_options(\"TCP: received unsupported option %u\\n\", type);\n            i = i + len - 2;\n        }\n    }\n    return 0;\n}",
  "abstract_func_before": "static int tcp_parse_options(struct pico_frame *VAR_0)\n{\n    struct pico_socket_tcp *VAR_1 = (struct pico_socket_tcp *)VAR_0->sock;\n    uint8_t *VAR_2 = VAR_0->transport_hdr + VAR_3;\n    uint32_t VAR_4 = 0;\n    VAR_0->timestamp = 0;\n    while (VAR_4 < (VAR_0->transport_len - VAR_3)) {\n        uint8_t VAR_5 =  VAR_2[VAR_4++];\n        uint8_t VAR_6;\n        if(VAR_4 < (VAR_0->transport_len - VAR_3) && (VAR_5 > 1))\n            VAR_6 =  VAR_2[VAR_4++];\n        else\n            VAR_6 = 1;\n\n        if (VAR_0->payload && ((VAR_2 + VAR_4) > VAR_0->payload))\n            break;\n\n        if (VAR_6 == 0) {\n            return -1;\n        }\n\n        tcp_dbg_options(\"Received option '%d', len = %d \\n\", VAR_5, VAR_6);\n        switch (VAR_5) {\n        case VAR_7:\n        case VAR_8:\n            break;\n        case VAR_9:\n            tcp_parse_option_ws(VAR_1, VAR_6, VAR_2, &VAR_4);\n            break;\n        case VAR_10:\n            tcp_parse_option_sack_ok(VAR_1, VAR_0, VAR_6, &VAR_4);\n            break;\n        case VAR_11:\n            tcp_parse_option_mss(VAR_1, VAR_6, VAR_2, &VAR_4);\n            break;\n        case VAR_12:\n            tcp_parse_option_timestamp(VAR_1, VAR_0, VAR_6, VAR_2, &VAR_4);\n            break;\n\n        case VAR_13:\n            tcp_rcv_sack(VAR_1, VAR_2 + VAR_4, VAR_6 - 2);\n            VAR_4 = VAR_4 + VAR_6 - 2;\n            break;\n        default:\n            tcp_dbg_options(\"TCP: received unsupported option %u\\n\", VAR_5);\n            VAR_4 = VAR_4 + VAR_6 - 2;\n        }\n    }\n    return 0;\n}",
  "func_graph_path_before": "virtualsquare/picotcp/4b9a16764f2b12b611de9c34a50b4713d10ca401/pico_tcp.c/vul/before/0.json",
  "func": "static int tcp_parse_options(struct pico_frame *f)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)f->sock;\n    uint8_t *opt = f->transport_hdr + PICO_SIZE_TCPHDR;\n    uint32_t i = 0;\n    f->timestamp = 0;\n\n    if (f->buffer + f->buffer_len > f->transport_hdr + f->transport_len)\n        return -1;\n\n    while (i < (f->transport_len - PICO_SIZE_TCPHDR)) {\n        uint8_t type =  opt[i++];\n        uint8_t len;\n        if(i < (f->transport_len - PICO_SIZE_TCPHDR) && (type > 1))\n            len =  opt[i++];\n        else\n            len = 1;\n\n        if (f->payload && ((opt + i) > f->payload))\n            break;\n\n        if (len == 0) {\n            return -1;\n        }\n\n        tcp_dbg_options(\"Received option '%d', len = %d \\n\", type, len);\n        switch (type) {\n        case PICO_TCP_OPTION_NOOP:\n        case PICO_TCP_OPTION_END:\n            break;\n        case PICO_TCP_OPTION_WS:\n            tcp_parse_option_ws(t, len, opt, &i);\n            break;\n        case PICO_TCP_OPTION_SACK_OK:\n            tcp_parse_option_sack_ok(t, f, len, &i);\n            break;\n        case PICO_TCP_OPTION_MSS:\n            tcp_parse_option_mss(t, len, opt, &i);\n            break;\n        case PICO_TCP_OPTION_TIMESTAMP:\n            tcp_parse_option_timestamp(t, f, len, opt, &i);\n            break;\n\n        case PICO_TCP_OPTION_SACK:\n            tcp_rcv_sack(t, opt + i, len - 2);\n            i = i + len - 2;\n            break;\n        default:\n            tcp_dbg_options(\"TCP: received unsupported option %u\\n\", type);\n            i = i + len - 2;\n        }\n    }\n    return 0;\n}",
  "abstract_func": "static int tcp_parse_options(struct pico_frame *VAR_0)\n{\n    struct pico_socket_tcp *VAR_1 = (struct pico_socket_tcp *)VAR_0->sock;\n    uint8_t *VAR_2 = VAR_0->transport_hdr + VAR_3;\n    uint32_t VAR_4 = 0;\n    VAR_0->timestamp = 0;\n\n    if (VAR_0->buffer + VAR_0->buffer_len > VAR_0->transport_hdr + VAR_0->transport_len)\n        return -1;\n\n    while (VAR_4 < (VAR_0->transport_len - VAR_3)) {\n        uint8_t VAR_5 =  VAR_2[VAR_4++];\n        uint8_t VAR_6;\n        if(VAR_4 < (VAR_0->transport_len - VAR_3) && (VAR_5 > 1))\n            VAR_6 =  VAR_2[VAR_4++];\n        else\n            VAR_6 = 1;\n\n        if (VAR_0->payload && ((VAR_2 + VAR_4) > VAR_0->payload))\n            break;\n\n        if (VAR_6 == 0) {\n            return -1;\n        }\n\n        tcp_dbg_options(\"Received option '%d', len = %d \\n\", VAR_5, VAR_6);\n        switch (VAR_5) {\n        case VAR_7:\n        case VAR_8:\n            break;\n        case VAR_9:\n            tcp_parse_option_ws(VAR_1, VAR_6, VAR_2, &VAR_4);\n            break;\n        case VAR_10:\n            tcp_parse_option_sack_ok(VAR_1, VAR_0, VAR_6, &VAR_4);\n            break;\n        case VAR_11:\n            tcp_parse_option_mss(VAR_1, VAR_6, VAR_2, &VAR_4);\n            break;\n        case VAR_12:\n            tcp_parse_option_timestamp(VAR_1, VAR_0, VAR_6, VAR_2, &VAR_4);\n            break;\n\n        case VAR_13:\n            tcp_rcv_sack(VAR_1, VAR_2 + VAR_4, VAR_6 - 2);\n            VAR_4 = VAR_4 + VAR_6 - 2;\n            break;\n        default:\n            tcp_dbg_options(\"TCP: received unsupported option %u\\n\", VAR_5);\n            VAR_4 = VAR_4 + VAR_6 - 2;\n        }\n    }\n    return 0;\n}",
  "func_graph_path": "virtualsquare/picotcp/4b9a16764f2b12b611de9c34a50b4713d10ca401/pico_tcp.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,10 @@\n     uint8_t *opt = f->transport_hdr + PICO_SIZE_TCPHDR;\n     uint32_t i = 0;\n     f->timestamp = 0;\n+\n+    if (f->buffer + f->buffer_len > f->transport_hdr + f->transport_len)\n+        return -1;\n+\n     while (i < (f->transport_len - PICO_SIZE_TCPHDR)) {\n         uint8_t type =  opt[i++];\n         uint8_t len;",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "",
      "    if (f->buffer + f->buffer_len > f->transport_hdr + f->transport_len)",
      "        return -1;",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/virtualsquare/picotcp/pull/15",
  "description": {
    "pr_info": {
      "title": "Various fixes on size calculation",
      "number": 15
    },
    "comment": [
      "- TCP: Fixed MSS size calculation, set lower MSS bound\r\n- TCP: Check options size before parsing MSS field\r\n- ipfilter: Check transport layer size before dereferencing port numbers\r\n- IPv4: Check transport layer size before calculating checksum",
      "There should be CVEs for these fixes."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}