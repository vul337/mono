{
  "cve_id": "CVE-2019-1010295",
  "cwe_ids": [
    "CWE-20",
    "CWE-787",
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "OP-TEE/optee_os",
  "commit_msg": "core: svc: always check ta parameters\n\nAlways check TA parameters from a user TA. This prevents a user TA from\npassing invalid pointers to a pseudo TA.\n\nFixes: OP-TEE-2018-0007: \"Buffer checks missing when calling pseudo\nTAs\".\n\nSigned-off-by: Jens Wiklander <jens.wiklander@linaro.org>\nTested-by: Joakim Bech <joakim.bech@linaro.org> (QEMU v7, v8)\nReviewed-by: Joakim Bech <joakim.bech@linaro.org>\nReported-by: Riscure <inforequest@riscure.com>\nReported-by: Alyssa Milburn <a.a.milburn@vu.nl>\nAcked-by: Etienne Carriere <etienne.carriere@linaro.org>",
  "commit_hash": "d5c5b0b77b2b589666024d219a8007b3f5b6faeb",
  "git_url": "https://github.com/OP-TEE/optee_os/commit/d5c5b0b77b2b589666024d219a8007b3f5b6faeb",
  "file_path": "core/tee/tee_svc.c",
  "func_name": "tee_svc_copy_param",
  "func_before": "static TEE_Result tee_svc_copy_param(struct tee_ta_session *sess,\n\t\t\t\t     struct tee_ta_session *called_sess,\n\t\t\t\t     struct utee_params *callee_params,\n\t\t\t\t     struct tee_ta_param *param,\n\t\t\t\t     void *tmp_buf_va[TEE_NUM_PARAMS],\n\t\t\t\t     struct mobj **mobj_tmp)\n{\n\tsize_t n;\n\tTEE_Result res;\n\tsize_t req_mem = 0;\n\tsize_t s;\n\tuint8_t *dst = 0;\n\tbool ta_private_memref[TEE_NUM_PARAMS];\n\tstruct user_ta_ctx *utc = to_user_ta_ctx(sess->ctx);\n\tvoid *va;\n\tsize_t dst_offs;\n\n\t/* fill 'param' input struct with caller params description buffer */\n\tif (!callee_params) {\n\t\tmemset(param, 0, sizeof(*param));\n\t} else {\n\t\tres = tee_mmu_check_access_rights(utc,\n\t\t\tTEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t(uaddr_t)callee_params, sizeof(struct utee_params));\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tutee_param_to_param(param, callee_params);\n\t}\n\n\tif (called_sess && is_pseudo_ta_ctx(called_sess->ctx)) {\n\t\t/* pseudo TA borrows the mapping of the calling TA */\n\t\treturn TEE_SUCCESS;\n\t}\n\n\t/* All mobj in param are of type MOJB_TYPE_VIRT */\n\n\tfor (n = 0; n < TEE_NUM_PARAMS; n++) {\n\n\t\tta_private_memref[n] = false;\n\n\t\tswitch (TEE_PARAM_TYPE_GET(param->types, n)) {\n\t\tcase TEE_PARAM_TYPE_MEMREF_INPUT:\n\t\tcase TEE_PARAM_TYPE_MEMREF_OUTPUT:\n\t\tcase TEE_PARAM_TYPE_MEMREF_INOUT:\n\t\t\tva = (void *)param->u[n].mem.offs;\n\t\t\ts = param->u[n].mem.size;\n\t\t\tif (!va) {\n\t\t\t\tif (s)\n\t\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* uTA cannot expose its private memory */\n\t\t\tif (tee_mmu_is_vbuf_inside_ta_private(utc, va, s)) {\n\n\t\t\t\ts = ROUNDUP(s, sizeof(uint32_t));\n\t\t\t\tif (ADD_OVERFLOW(req_mem, s, &req_mem))\n\t\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t\t\tta_private_memref[n] = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tres = tee_mmu_vbuf_to_mobj_offs(utc, va, s,\n\t\t\t\t\t\t\t&param->u[n].mem.mobj,\n\t\t\t\t\t\t\t&param->u[n].mem.offs);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (req_mem == 0)\n\t\treturn TEE_SUCCESS;\n\n\tres = alloc_temp_sec_mem(req_mem, mobj_tmp, &dst);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tdst_offs = 0;\n\n\tfor (n = 0; n < TEE_NUM_PARAMS; n++) {\n\n\t\tif (!ta_private_memref[n])\n\t\t\tcontinue;\n\n\t\ts = ROUNDUP(param->u[n].mem.size, sizeof(uint32_t));\n\n\t\tswitch (TEE_PARAM_TYPE_GET(param->types, n)) {\n\t\tcase TEE_PARAM_TYPE_MEMREF_INPUT:\n\t\tcase TEE_PARAM_TYPE_MEMREF_INOUT:\n\t\t\tva = (void *)param->u[n].mem.offs;\n\t\t\tif (va) {\n\t\t\t\tres = tee_svc_copy_from_user(dst, va,\n\t\t\t\t\t\tparam->u[n].mem.size);\n\t\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\t\treturn res;\n\t\t\t\tparam->u[n].mem.offs = dst_offs;\n\t\t\t\tparam->u[n].mem.mobj = *mobj_tmp;\n\t\t\t\ttmp_buf_va[n] = dst;\n\t\t\t\tdst += s;\n\t\t\t\tdst_offs += s;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TEE_PARAM_TYPE_MEMREF_OUTPUT:\n\t\t\tva = (void *)param->u[n].mem.offs;\n\t\t\tif (va) {\n\t\t\t\tparam->u[n].mem.offs = dst_offs;\n\t\t\t\tparam->u[n].mem.mobj = *mobj_tmp;\n\t\t\t\ttmp_buf_va[n] = dst;\n\t\t\t\tdst += s;\n\t\t\t\tdst_offs += s;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\treturn TEE_SUCCESS;\n}",
  "abstract_func_before": "static TEE_Result tee_svc_copy_param(struct tee_ta_session *VAR_0,\n\t\t\t\t     struct tee_ta_session *VAR_1,\n\t\t\t\t     struct utee_params *VAR_2,\n\t\t\t\t     struct tee_ta_param *VAR_3,\n\t\t\t\t     void *VAR_4[VAR_5],\n\t\t\t\t     struct mobj **VAR_6)\n{\n\tsize_t VAR_7;\n\tTEE_Result VAR_8;\n\tsize_t VAR_9 = 0;\n\tsize_t VAR_10;\n\tuint8_t *VAR_11 = 0;\n\tbool VAR_12[VAR_5];\n\tstruct user_ta_ctx *VAR_13 = to_user_ta_ctx(VAR_0->ctx);\n\tvoid *VAR_14;\n\tsize_t VAR_15;\n\n\t/* COMMENT_0 */\n\tif (!VAR_2) {\n\t\tmemset(VAR_3, 0, sizeof(*VAR_3));\n\t} else {\n\t\tVAR_8 = tee_mmu_check_access_rights(VAR_13,\n\t\t\tVAR_16 | VAR_17,\n\t\t\t(uaddr_t)VAR_2, sizeof(struct utee_params));\n\t\tif (VAR_8 != VAR_18)\n\t\t\treturn VAR_8;\n\t\tutee_param_to_param(VAR_3, VAR_2);\n\t}\n\n\tif (VAR_1 && is_pseudo_ta_ctx(VAR_1->ctx)) {\n\t\t/* COMMENT_1 */\n\t\treturn VAR_18;\n\t}\n\n\t/* COMMENT_2 */\n\n\tfor (VAR_7 = 0; VAR_7 < VAR_5; VAR_7++) {\n\n\t\tVAR_12[VAR_7] = false;\n\n\t\tswitch (TEE_PARAM_TYPE_GET(VAR_3->types, VAR_7)) {\n\t\tcase VAR_19:\n\t\tcase VAR_20:\n\t\tcase VAR_21:\n\t\t\tVAR_14 = (void *)VAR_3->u[VAR_7].mem.offs;\n\t\t\tVAR_10 = VAR_3->u[VAR_7].mem.size;\n\t\t\tif (!VAR_14) {\n\t\t\t\tif (VAR_10)\n\t\t\t\t\treturn VAR_22;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* COMMENT_3 */\n\t\t\tif (tee_mmu_is_vbuf_inside_ta_private(VAR_13, VAR_14, VAR_10)) {\n\n\t\t\t\tVAR_10 = ROUNDUP(VAR_10, sizeof(uint32_t));\n\t\t\t\tif (ADD_OVERFLOW(VAR_9, VAR_10, &VAR_9))\n\t\t\t\t\treturn VAR_22;\n\t\t\t\tVAR_12[VAR_7] = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tVAR_8 = tee_mmu_vbuf_to_mobj_offs(VAR_13, VAR_14, VAR_10,\n\t\t\t\t\t\t\t&VAR_3->u[VAR_7].mem.mobj,\n\t\t\t\t\t\t\t&VAR_3->u[VAR_7].mem.offs);\n\t\t\tif (VAR_8 != VAR_18)\n\t\t\t\treturn VAR_8;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (VAR_9 == 0)\n\t\treturn VAR_18;\n\n\tVAR_8 = alloc_temp_sec_mem(VAR_9, VAR_6, &VAR_11);\n\tif (VAR_8 != VAR_18)\n\t\treturn VAR_8;\n\tVAR_15 = 0;\n\n\tfor (VAR_7 = 0; VAR_7 < VAR_5; VAR_7++) {\n\n\t\tif (!VAR_12[VAR_7])\n\t\t\tcontinue;\n\n\t\tVAR_10 = ROUNDUP(VAR_3->u[VAR_7].mem.size, sizeof(uint32_t));\n\n\t\tswitch (TEE_PARAM_TYPE_GET(VAR_3->types, VAR_7)) {\n\t\tcase VAR_19:\n\t\tcase VAR_21:\n\t\t\tVAR_14 = (void *)VAR_3->u[VAR_7].mem.offs;\n\t\t\tif (VAR_14) {\n\t\t\t\tVAR_8 = tee_svc_copy_from_user(VAR_11, VAR_14,\n\t\t\t\t\t\tVAR_3->u[VAR_7].mem.size);\n\t\t\t\tif (VAR_8 != VAR_18)\n\t\t\t\t\treturn VAR_8;\n\t\t\t\tVAR_3->u[VAR_7].mem.offs = VAR_15;\n\t\t\t\tVAR_3->u[VAR_7].mem.mobj = *VAR_6;\n\t\t\t\tVAR_4[VAR_7] = VAR_11;\n\t\t\t\tVAR_11 += VAR_10;\n\t\t\t\tVAR_15 += VAR_10;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase VAR_20:\n\t\t\tVAR_14 = (void *)VAR_3->u[VAR_7].mem.offs;\n\t\t\tif (VAR_14) {\n\t\t\t\tVAR_3->u[VAR_7].mem.offs = VAR_15;\n\t\t\t\tVAR_3->u[VAR_7].mem.mobj = *VAR_6;\n\t\t\t\tVAR_4[VAR_7] = VAR_11;\n\t\t\t\tVAR_11 += VAR_10;\n\t\t\t\tVAR_15 += VAR_10;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\treturn VAR_18;\n}",
  "func_graph_path_before": "OP-TEE/optee_os/d5c5b0b77b2b589666024d219a8007b3f5b6faeb/tee_svc.c/vul/before/0.json",
  "func": "static TEE_Result tee_svc_copy_param(struct tee_ta_session *sess,\n\t\t\t\t     struct tee_ta_session *called_sess,\n\t\t\t\t     struct utee_params *callee_params,\n\t\t\t\t     struct tee_ta_param *param,\n\t\t\t\t     void *tmp_buf_va[TEE_NUM_PARAMS],\n\t\t\t\t     struct mobj **mobj_tmp)\n{\n\tsize_t n;\n\tTEE_Result res;\n\tsize_t req_mem = 0;\n\tsize_t s;\n\tuint8_t *dst = 0;\n\tbool ta_private_memref[TEE_NUM_PARAMS];\n\tstruct user_ta_ctx *utc = to_user_ta_ctx(sess->ctx);\n\tvoid *va;\n\tsize_t dst_offs;\n\n\t/* fill 'param' input struct with caller params description buffer */\n\tif (!callee_params) {\n\t\tmemset(param, 0, sizeof(*param));\n\t} else {\n\t\tres = tee_mmu_check_access_rights(utc,\n\t\t\tTEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t(uaddr_t)callee_params, sizeof(struct utee_params));\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tres = utee_param_to_param(utc, param, callee_params);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\n\tif (called_sess && is_pseudo_ta_ctx(called_sess->ctx)) {\n\t\t/* pseudo TA borrows the mapping of the calling TA */\n\t\treturn TEE_SUCCESS;\n\t}\n\n\t/* All mobj in param are of type MOJB_TYPE_VIRT */\n\n\tfor (n = 0; n < TEE_NUM_PARAMS; n++) {\n\n\t\tta_private_memref[n] = false;\n\n\t\tswitch (TEE_PARAM_TYPE_GET(param->types, n)) {\n\t\tcase TEE_PARAM_TYPE_MEMREF_INPUT:\n\t\tcase TEE_PARAM_TYPE_MEMREF_OUTPUT:\n\t\tcase TEE_PARAM_TYPE_MEMREF_INOUT:\n\t\t\tva = (void *)param->u[n].mem.offs;\n\t\t\ts = param->u[n].mem.size;\n\t\t\tif (!va) {\n\t\t\t\tif (s)\n\t\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* uTA cannot expose its private memory */\n\t\t\tif (tee_mmu_is_vbuf_inside_ta_private(utc, va, s)) {\n\n\t\t\t\ts = ROUNDUP(s, sizeof(uint32_t));\n\t\t\t\tif (ADD_OVERFLOW(req_mem, s, &req_mem))\n\t\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t\t\tta_private_memref[n] = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tres = tee_mmu_vbuf_to_mobj_offs(utc, va, s,\n\t\t\t\t\t\t\t&param->u[n].mem.mobj,\n\t\t\t\t\t\t\t&param->u[n].mem.offs);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (req_mem == 0)\n\t\treturn TEE_SUCCESS;\n\n\tres = alloc_temp_sec_mem(req_mem, mobj_tmp, &dst);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tdst_offs = 0;\n\n\tfor (n = 0; n < TEE_NUM_PARAMS; n++) {\n\n\t\tif (!ta_private_memref[n])\n\t\t\tcontinue;\n\n\t\ts = ROUNDUP(param->u[n].mem.size, sizeof(uint32_t));\n\n\t\tswitch (TEE_PARAM_TYPE_GET(param->types, n)) {\n\t\tcase TEE_PARAM_TYPE_MEMREF_INPUT:\n\t\tcase TEE_PARAM_TYPE_MEMREF_INOUT:\n\t\t\tva = (void *)param->u[n].mem.offs;\n\t\t\tif (va) {\n\t\t\t\tres = tee_svc_copy_from_user(dst, va,\n\t\t\t\t\t\tparam->u[n].mem.size);\n\t\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\t\treturn res;\n\t\t\t\tparam->u[n].mem.offs = dst_offs;\n\t\t\t\tparam->u[n].mem.mobj = *mobj_tmp;\n\t\t\t\ttmp_buf_va[n] = dst;\n\t\t\t\tdst += s;\n\t\t\t\tdst_offs += s;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TEE_PARAM_TYPE_MEMREF_OUTPUT:\n\t\t\tva = (void *)param->u[n].mem.offs;\n\t\t\tif (va) {\n\t\t\t\tparam->u[n].mem.offs = dst_offs;\n\t\t\t\tparam->u[n].mem.mobj = *mobj_tmp;\n\t\t\t\ttmp_buf_va[n] = dst;\n\t\t\t\tdst += s;\n\t\t\t\tdst_offs += s;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\treturn TEE_SUCCESS;\n}",
  "abstract_func": "static TEE_Result tee_svc_copy_param(struct tee_ta_session *VAR_0,\n\t\t\t\t     struct tee_ta_session *VAR_1,\n\t\t\t\t     struct utee_params *VAR_2,\n\t\t\t\t     struct tee_ta_param *VAR_3,\n\t\t\t\t     void *VAR_4[VAR_5],\n\t\t\t\t     struct mobj **VAR_6)\n{\n\tsize_t VAR_7;\n\tTEE_Result VAR_8;\n\tsize_t VAR_9 = 0;\n\tsize_t VAR_10;\n\tuint8_t *VAR_11 = 0;\n\tbool VAR_12[VAR_5];\n\tstruct user_ta_ctx *VAR_13 = to_user_ta_ctx(VAR_0->ctx);\n\tvoid *VAR_14;\n\tsize_t VAR_15;\n\n\t/* COMMENT_0 */\n\tif (!VAR_2) {\n\t\tmemset(VAR_3, 0, sizeof(*VAR_3));\n\t} else {\n\t\tVAR_8 = tee_mmu_check_access_rights(VAR_13,\n\t\t\tVAR_16 | VAR_17,\n\t\t\t(uaddr_t)VAR_2, sizeof(struct utee_params));\n\t\tif (VAR_8 != VAR_18)\n\t\t\treturn VAR_8;\n\t\tVAR_8 = utee_param_to_param(VAR_13, VAR_3, VAR_2);\n\t\tif (VAR_8 != VAR_18)\n\t\t\treturn VAR_8;\n\t}\n\n\tif (VAR_1 && is_pseudo_ta_ctx(VAR_1->ctx)) {\n\t\t/* COMMENT_1 */\n\t\treturn VAR_18;\n\t}\n\n\t/* COMMENT_2 */\n\n\tfor (VAR_7 = 0; VAR_7 < VAR_5; VAR_7++) {\n\n\t\tVAR_12[VAR_7] = false;\n\n\t\tswitch (TEE_PARAM_TYPE_GET(VAR_3->types, VAR_7)) {\n\t\tcase VAR_19:\n\t\tcase VAR_20:\n\t\tcase VAR_21:\n\t\t\tVAR_14 = (void *)VAR_3->u[VAR_7].mem.offs;\n\t\t\tVAR_10 = VAR_3->u[VAR_7].mem.size;\n\t\t\tif (!VAR_14) {\n\t\t\t\tif (VAR_10)\n\t\t\t\t\treturn VAR_22;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* COMMENT_3 */\n\t\t\tif (tee_mmu_is_vbuf_inside_ta_private(VAR_13, VAR_14, VAR_10)) {\n\n\t\t\t\tVAR_10 = ROUNDUP(VAR_10, sizeof(uint32_t));\n\t\t\t\tif (ADD_OVERFLOW(VAR_9, VAR_10, &VAR_9))\n\t\t\t\t\treturn VAR_22;\n\t\t\t\tVAR_12[VAR_7] = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tVAR_8 = tee_mmu_vbuf_to_mobj_offs(VAR_13, VAR_14, VAR_10,\n\t\t\t\t\t\t\t&VAR_3->u[VAR_7].mem.mobj,\n\t\t\t\t\t\t\t&VAR_3->u[VAR_7].mem.offs);\n\t\t\tif (VAR_8 != VAR_18)\n\t\t\t\treturn VAR_8;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (VAR_9 == 0)\n\t\treturn VAR_18;\n\n\tVAR_8 = alloc_temp_sec_mem(VAR_9, VAR_6, &VAR_11);\n\tif (VAR_8 != VAR_18)\n\t\treturn VAR_8;\n\tVAR_15 = 0;\n\n\tfor (VAR_7 = 0; VAR_7 < VAR_5; VAR_7++) {\n\n\t\tif (!VAR_12[VAR_7])\n\t\t\tcontinue;\n\n\t\tVAR_10 = ROUNDUP(VAR_3->u[VAR_7].mem.size, sizeof(uint32_t));\n\n\t\tswitch (TEE_PARAM_TYPE_GET(VAR_3->types, VAR_7)) {\n\t\tcase VAR_19:\n\t\tcase VAR_21:\n\t\t\tVAR_14 = (void *)VAR_3->u[VAR_7].mem.offs;\n\t\t\tif (VAR_14) {\n\t\t\t\tVAR_8 = tee_svc_copy_from_user(VAR_11, VAR_14,\n\t\t\t\t\t\tVAR_3->u[VAR_7].mem.size);\n\t\t\t\tif (VAR_8 != VAR_18)\n\t\t\t\t\treturn VAR_8;\n\t\t\t\tVAR_3->u[VAR_7].mem.offs = VAR_15;\n\t\t\t\tVAR_3->u[VAR_7].mem.mobj = *VAR_6;\n\t\t\t\tVAR_4[VAR_7] = VAR_11;\n\t\t\t\tVAR_11 += VAR_10;\n\t\t\t\tVAR_15 += VAR_10;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase VAR_20:\n\t\t\tVAR_14 = (void *)VAR_3->u[VAR_7].mem.offs;\n\t\t\tif (VAR_14) {\n\t\t\t\tVAR_3->u[VAR_7].mem.offs = VAR_15;\n\t\t\t\tVAR_3->u[VAR_7].mem.mobj = *VAR_6;\n\t\t\t\tVAR_4[VAR_7] = VAR_11;\n\t\t\t\tVAR_11 += VAR_10;\n\t\t\t\tVAR_15 += VAR_10;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\treturn VAR_18;\n}",
  "func_graph_path": "OP-TEE/optee_os/d5c5b0b77b2b589666024d219a8007b3f5b6faeb/tee_svc.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -24,7 +24,9 @@\n \t\t\t(uaddr_t)callee_params, sizeof(struct utee_params));\n \t\tif (res != TEE_SUCCESS)\n \t\t\treturn res;\n-\t\tutee_param_to_param(param, callee_params);\n+\t\tres = utee_param_to_param(utc, param, callee_params);\n+\t\tif (res != TEE_SUCCESS)\n+\t\t\treturn res;\n \t}\n \n \tif (called_sess && is_pseudo_ta_ctx(called_sess->ctx)) {",
  "diff_line_info": {
    "deleted_lines": [
      "\t\tutee_param_to_param(param, callee_params);"
    ],
    "added_lines": [
      "\t\tres = utee_param_to_param(utc, param, callee_params);",
      "\t\tif (res != TEE_SUCCESS)",
      "\t\t\treturn res;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/OP-TEE/optee_os/pull/2745",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/OP-TEE/optee_os/pull/2745: 403 Client Error: Forbidden for url: https://api.github.com/repos/OP-TEE/optee_os/pulls/2745",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}