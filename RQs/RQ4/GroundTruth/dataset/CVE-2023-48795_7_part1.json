{
  "cve_id": "CVE-2023-48795",
  "cwe_ids": [
    "CWE-354"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:H/A:N",
  "cvss_is_v3": true,
  "repo_name": "janmojzis/tinyssh",
  "commit_msg": "implementation kex-strict-s-v00@openssh.com",
  "commit_hash": "12ec08d24e43e382cb6d9b61facd87685f99eae0",
  "git_url": "https://github.com/janmojzis/tinyssh/commit/12ec08d24e43e382cb6d9b61facd87685f99eae0",
  "file_path": "tinyssh/sshcrypto_kex.c",
  "func_name": "sshcrypto_kex_select",
  "func_before": "int sshcrypto_kex_select(const unsigned char *buf, long long len, crypto_uint8 *kex_guess) {\n\n    long long i, pos = 0;\n    unsigned char *x;\n    long long xlen;\n\n    if (sshcrypto_kex_name) return 1;\n\n    if (buf[len] != 0) bug_proto();\n    log_d2(\"kex: client: kex algorithms: \", (char *)buf); \n\n    *kex_guess = 1;\n\n    for (;;) {\n        pos = stringparser(buf, len, pos, &x, &xlen);\n        if (!pos) break;\n\n        for (i = 0; sshcrypto_kexs[i].name; ++i) {\n            if (!sshcrypto_kexs[i].flagenabled) continue;\n            if (str_equaln((char *)x, xlen, sshcrypto_kexs[i].name)) {\n                sshcrypto_kex_name = sshcrypto_kexs[i].name;\n                sshcrypto_enc = sshcrypto_kexs[i].enc;\n                sshcrypto_kem_publickeybytes = sshcrypto_kexs[i].kem_publickeybytes;\n                sshcrypto_kem_ciphertextbytes = sshcrypto_kexs[i].kem_ciphertextbytes;\n                sshcrypto_kem_bytes = sshcrypto_kexs[i].kem_bytes;\n                sshcrypto_hash = sshcrypto_kexs[i].hash;\n                sshcrypto_hash_bytes = sshcrypto_kexs[i].hash_bytes;\n                sshcrypto_buf_putkemkey = sshcrypto_kexs[i].buf_putkemkey;\n                log_d2(\"kex: kex selected: \", sshcrypto_kexs[i].name);\n                return 1;\n            }\n        }\n        *kex_guess = 0;\n    }\n    log_d2(\"kex: kex not available \", (char *)buf);\n    errno = EPROTO;\n    return 0;\n}",
  "abstract_func_before": "int sshcrypto_kex_select(const unsigned char *VAR_0, long long VAR_1, crypto_uint8 *VAR_2) {\n\n    long long VAR_3, VAR_4 = 0;\n    unsigned char *VAR_5;\n    long long VAR_6;\n\n    if (VAR_7) return 1;\n\n    if (VAR_0[VAR_1] != 0) bug_proto();\n    log_d2(\"kex: client: kex algorithms: \", (char *)VAR_0); \n\n    *VAR_2 = 1;\n\n    for (;;) {\n        VAR_4 = stringparser(VAR_0, VAR_1, VAR_4, &VAR_5, &VAR_6);\n        if (!VAR_4) break;\n\n        for (VAR_3 = 0; VAR_8[VAR_3].name; ++VAR_3) {\n            if (!VAR_8[VAR_3].flagenabled) continue;\n            if (str_equaln((char *)VAR_5, VAR_6, VAR_8[VAR_3].name)) {\n                VAR_7 = VAR_8[VAR_3].name;\n                VAR_9 = VAR_8[VAR_3].enc;\n                VAR_10 = VAR_8[VAR_3].kem_publickeybytes;\n                VAR_11 = VAR_8[VAR_3].kem_ciphertextbytes;\n                VAR_12 = VAR_8[VAR_3].kem_bytes;\n                VAR_13 = VAR_8[VAR_3].hash;\n                VAR_14 = VAR_8[VAR_3].hash_bytes;\n                VAR_15 = VAR_8[VAR_3].buf_putkemkey;\n                log_d2(\"kex: kex selected: \", VAR_8[VAR_3].name);\n                return 1;\n            }\n        }\n        *VAR_2 = 0;\n    }\n    log_d2(\"kex: kex not available \", (char *)VAR_0);\n    VAR_16 = VAR_17;\n    return 0;\n}",
  "func_graph_path_before": "janmojzis/tinyssh/12ec08d24e43e382cb6d9b61facd87685f99eae0/sshcrypto_kex.c/vul/before/1.json",
  "func": "int sshcrypto_kex_select(const unsigned char *buf, long long len, crypto_uint8 *kex_guess) {\n\n    long long i, pos;\n    unsigned char *x;\n    long long xlen;\n\n    if (sshcrypto_kex_name) return 1;\n\n    if (buf[len] != 0) bug_proto();\n    log_d2(\"kex: client: kex algorithms: \", (char *)buf); \n\n    *kex_guess = 1;\n\n    pos = 0;\n    for (;;) {\n        pos = stringparser(buf, len, pos, &x, &xlen);\n        if (!pos) break;\n        for (i = 0; sshcrypto_pseudokexs[i].name; ++i) {\n            if (str_equaln((char *)x, xlen, sshcrypto_pseudokexs[i].cname)) {\n                log_d2(\"kex: pseudokex selected: \", sshcrypto_pseudokexs[i].name);\n                sshcrypto_kex_flags |= sshcrypto_pseudokexs[i].flag;\n            }\n        }\n    }\n\n    pos = 0;\n    for (;;) {\n        pos = stringparser(buf, len, pos, &x, &xlen);\n        if (!pos) break;\n\n        for (i = 0; sshcrypto_kexs[i].name; ++i) {\n            if (!sshcrypto_kexs[i].flagenabled) continue;\n            if (str_equaln((char *)x, xlen, sshcrypto_kexs[i].name)) {\n                sshcrypto_kex_name = sshcrypto_kexs[i].name;\n                sshcrypto_enc = sshcrypto_kexs[i].enc;\n                sshcrypto_kem_publickeybytes = sshcrypto_kexs[i].kem_publickeybytes;\n                sshcrypto_kem_ciphertextbytes = sshcrypto_kexs[i].kem_ciphertextbytes;\n                sshcrypto_kem_bytes = sshcrypto_kexs[i].kem_bytes;\n                sshcrypto_hash = sshcrypto_kexs[i].hash;\n                sshcrypto_hash_bytes = sshcrypto_kexs[i].hash_bytes;\n                sshcrypto_buf_putkemkey = sshcrypto_kexs[i].buf_putkemkey;\n                log_d2(\"kex: kex selected: \", sshcrypto_kexs[i].name);\n                return 1;\n            }\n        }\n        *kex_guess = 0;\n    }\n    log_d2(\"kex: kex not available \", (char *)buf);\n    errno = EPROTO;\n    return 0;\n}",
  "abstract_func": "int sshcrypto_kex_select(const unsigned char *VAR_0, long long VAR_1, crypto_uint8 *VAR_2) {\n\n    long long VAR_3, VAR_4;\n    unsigned char *VAR_5;\n    long long VAR_6;\n\n    if (VAR_7) return 1;\n\n    if (VAR_0[VAR_1] != 0) bug_proto();\n    log_d2(\"kex: client: kex algorithms: \", (char *)VAR_0); \n\n    *VAR_2 = 1;\n\n    VAR_4 = 0;\n    for (;;) {\n        VAR_4 = stringparser(VAR_0, VAR_1, VAR_4, &VAR_5, &VAR_6);\n        if (!VAR_4) break;\n        for (VAR_3 = 0; VAR_8[VAR_3].name; ++VAR_3) {\n            if (str_equaln((char *)VAR_5, VAR_6, VAR_8[VAR_3].cname)) {\n                log_d2(\"kex: pseudokex selected: \", VAR_8[VAR_3].name);\n                VAR_9 |= VAR_8[VAR_3].flag;\n            }\n        }\n    }\n\n    VAR_4 = 0;\n    for (;;) {\n        VAR_4 = stringparser(VAR_0, VAR_1, VAR_4, &VAR_5, &VAR_6);\n        if (!VAR_4) break;\n\n        for (VAR_3 = 0; VAR_10[VAR_3].name; ++VAR_3) {\n            if (!VAR_10[VAR_3].flagenabled) continue;\n            if (str_equaln((char *)VAR_5, VAR_6, VAR_10[VAR_3].name)) {\n                VAR_7 = VAR_10[VAR_3].name;\n                VAR_11 = VAR_10[VAR_3].enc;\n                VAR_12 = VAR_10[VAR_3].kem_publickeybytes;\n                VAR_13 = VAR_10[VAR_3].kem_ciphertextbytes;\n                VAR_14 = VAR_10[VAR_3].kem_bytes;\n                VAR_15 = VAR_10[VAR_3].hash;\n                VAR_16 = VAR_10[VAR_3].hash_bytes;\n                VAR_17 = VAR_10[VAR_3].buf_putkemkey;\n                log_d2(\"kex: kex selected: \", VAR_10[VAR_3].name);\n                return 1;\n            }\n        }\n        *VAR_2 = 0;\n    }\n    log_d2(\"kex: kex not available \", (char *)VAR_0);\n    VAR_18 = VAR_19;\n    return 0;\n}",
  "func_graph_path": "janmojzis/tinyssh/12ec08d24e43e382cb6d9b61facd87685f99eae0/sshcrypto_kex.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n int sshcrypto_kex_select(const unsigned char *buf, long long len, crypto_uint8 *kex_guess) {\n \n-    long long i, pos = 0;\n+    long long i, pos;\n     unsigned char *x;\n     long long xlen;\n \n@@ -11,6 +11,19 @@\n \n     *kex_guess = 1;\n \n+    pos = 0;\n+    for (;;) {\n+        pos = stringparser(buf, len, pos, &x, &xlen);\n+        if (!pos) break;\n+        for (i = 0; sshcrypto_pseudokexs[i].name; ++i) {\n+            if (str_equaln((char *)x, xlen, sshcrypto_pseudokexs[i].cname)) {\n+                log_d2(\"kex: pseudokex selected: \", sshcrypto_pseudokexs[i].name);\n+                sshcrypto_kex_flags |= sshcrypto_pseudokexs[i].flag;\n+            }\n+        }\n+    }\n+\n+    pos = 0;\n     for (;;) {\n         pos = stringparser(buf, len, pos, &x, &xlen);\n         if (!pos) break;",
  "diff_line_info": {
    "deleted_lines": [
      "    long long i, pos = 0;"
    ],
    "added_lines": [
      "    long long i, pos;",
      "    pos = 0;",
      "    for (;;) {",
      "        pos = stringparser(buf, len, pos, &x, &xlen);",
      "        if (!pos) break;",
      "        for (i = 0; sshcrypto_pseudokexs[i].name; ++i) {",
      "            if (str_equaln((char *)x, xlen, sshcrypto_pseudokexs[i].cname)) {",
      "                log_d2(\"kex: pseudokex selected: \", sshcrypto_pseudokexs[i].name);",
      "                sshcrypto_kex_flags |= sshcrypto_pseudokexs[i].flag;",
      "            }",
      "        }",
      "    }",
      "",
      "    pos = 0;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/janmojzis/tinyssh/pull/82",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/janmojzis/tinyssh/pull/82: 403 Client Error: Forbidden for url: https://api.github.com/repos/janmojzis/tinyssh/pulls/82",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}