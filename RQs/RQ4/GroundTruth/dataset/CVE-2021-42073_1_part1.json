{
  "cve_id": "CVE-2021-42073",
  "cwe_ids": [
    "CWE-384"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "debauchee/barrier",
  "commit_msg": "Implement client identity verification\n\nThis commit fixes two security vulnerabilities: CVE-2021-42072 and\nCVE-2021-42073.\n\nThe issues have been reported by Matthias Gerstner <mgerstner@suse.de>.",
  "commit_hash": "229abab99f39f11624e5651f819e7f1f8eddedcc",
  "git_url": "https://github.com/debauchee/barrier/commit/229abab99f39f11624e5651f819e7f1f8eddedcc",
  "file_path": "src/gui/src/MainWindow.cpp",
  "func_name": "MainWindow::checkFingerprint",
  "func_before": "void MainWindow::checkFingerprint(const QString& line)\n{\n    QRegExp fingerprintRegex(\".*server fingerprint \\\\(SHA1\\\\): ([A-F0-9:]+) \\\\(SHA256\\\\): ([A-F0-9:]+)\");\n    if (!fingerprintRegex.exactMatch(line)) {\n        return;\n    }\n\n    barrier::FingerprintData fingerprint_sha1 = {\n        barrier::fingerprint_type_to_string(barrier::FingerprintType::SHA1),\n        barrier::string::from_hex(fingerprintRegex.cap(1).toStdString())\n    };\n\n    barrier::FingerprintData fingerprint_sha256 = {\n        barrier::fingerprint_type_to_string(barrier::FingerprintType::SHA256),\n        barrier::string::from_hex(fingerprintRegex.cap(2).toStdString())\n    };\n\n    auto db_path = barrier::DataDirectories::trusted_servers_ssl_fingerprints_path();\n\n    auto db_dir = db_path.parent_path();\n    if (!barrier::fs::exists(db_dir)) {\n        barrier::fs::create_directories(db_dir);\n    }\n\n    // We compare only SHA256 fingerprints, but show both SHA1 and SHA256 so that the users can\n    // still verify fingerprints on old Barrier servers. This way the only time when we are exposed\n    // to SHA1 vulnerabilities is when the user is reconnecting again.\n    barrier::FingerprintDatabase db;\n    db.read(db_path);\n    if (db.is_trusted(fingerprint_sha256)) {\n        return;\n    }\n\n    static bool messageBoxAlreadyShown = false;\n\n    if (!messageBoxAlreadyShown) {\n        stopBarrier();\n\n        messageBoxAlreadyShown = true;\n        QMessageBox::StandardButton fingerprintReply =\n            QMessageBox::information(\n            this, tr(\"Security question\"),\n            tr(\"Do you trust this fingerprint?\\n\\n\"\n               \"SHA256:\\n\"\n               \"%1\\n\"\n               \"%2\\n\\n\"\n               \"SHA1 (obsolete, when using old Barrier server):\\n\"\n               \"%3\\n\\n\"\n               \"This is a server fingerprint. You should compare this \"\n               \"fingerprint to the one on your server's screen. If the \"\n               \"two don't match exactly, then it's probably not the server \"\n               \"you're expecting (it could be a malicious user).\\n\\n\"\n               \"To automatically trust this fingerprint for future \"\n               \"connections, click Yes. To reject this fingerprint and \"\n               \"disconnect from the server, click No.\")\n            .arg(QString::fromStdString(barrier::format_ssl_fingerprint(fingerprint_sha256.data)))\n            .arg(QString::fromStdString(\n                     barrier::create_fingerprint_randomart(fingerprint_sha256.data)))\n            .arg(QString::fromStdString(barrier::format_ssl_fingerprint(fingerprint_sha1.data))),\n            QMessageBox::Yes | QMessageBox::No);\n\n        if (fingerprintReply == QMessageBox::Yes) {\n            // restart core process after trusting fingerprint.\n            db.add_trusted(fingerprint_sha256);\n            db.write(db_path);\n            startBarrier();\n        }\n\n        messageBoxAlreadyShown = false;\n    }\n}",
  "abstract_func_before": "void MainWindow::checkFingerprint(const QString& VAR_0)\n{\n    QRegExp VAR_1(\".*server fingerprint \\\\(SHA1\\\\): ([A-F0-9:]+) \\\\(SHA256\\\\): ([A-F0-9:]+)\");\n    if (!VAR_1.exactMatch(VAR_0)) {\n        return;\n    }\n\n    barrier::FingerprintData VAR_2 = {\n        barrier::fingerprint_type_to_string(barrier::FingerprintType::SHA1),\n        barrier::string::from_hex(VAR_1.cap(1).toStdString())\n    };\n\n    barrier::FingerprintData VAR_3 = {\n        barrier::fingerprint_type_to_string(barrier::FingerprintType::SHA256),\n        barrier::string::from_hex(VAR_1.cap(2).toStdString())\n    };\n\n    auto VAR_4 = barrier::DataDirectories::trusted_servers_ssl_fingerprints_path();\n\n    auto VAR_5 = VAR_4.parent_path();\n    if (!barrier::fs::exists(VAR_5)) {\n        barrier::fs::create_directories(VAR_5);\n    }\n\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n    barrier::FingerprintDatabase VAR_6;\n    VAR_6.read(VAR_4);\n    if (VAR_6.is_trusted(VAR_3)) {\n        return;\n    }\n\n    static bool VAR_7 = false;\n\n    if (!VAR_7) {\n        stopBarrier();\n\n        VAR_7 = true;\n        QMessageBox::StandardButton VAR_8 =\n            QMessageBox::information(\n            this, tr(\"Security question\"),\n            tr(\"Do you trust this fingerprint?\\n\\n\"\n               \"SHA256:\\n\"\n               \"%1\\n\"\n               \"%2\\n\\n\"\n               \"SHA1 (obsolete, when using old Barrier server):\\n\"\n               \"%3\\n\\n\"\n               \"This is a server fingerprint. You should compare this \"\n               \"fingerprint to the one on your server's screen. If the \"\n               \"two don't match exactly, then it's probably not the server \"\n               \"you're expecting (it could be a malicious user).\\n\\n\"\n               \"To automatically trust this fingerprint for future \"\n               \"connections, click Yes. To reject this fingerprint and \"\n               \"disconnect from the server, click No.\")\n            .arg(QString::fromStdString(barrier::format_ssl_fingerprint(VAR_3.data)))\n            .arg(QString::fromStdString(\n                     barrier::create_fingerprint_randomart(VAR_3.data)))\n            .arg(QString::fromStdString(barrier::format_ssl_fingerprint(VAR_2.data))),\n            QMessageBox::Yes | QMessageBox::No);\n\n        if (VAR_8 == QMessageBox::Yes) {\n            /* COMMENT_3 */\n            VAR_6.add_trusted(VAR_3);\n            VAR_6.write(VAR_4);\n            startBarrier();\n        }\n\n        VAR_7 = false;\n    }\n}",
  "func_graph_path_before": "debauchee/barrier/229abab99f39f11624e5651f819e7f1f8eddedcc/MainWindow.cpp/vul/before/1.json",
  "func": "void MainWindow::checkFingerprint(const QString& line)\n{\n    QRegExp fingerprintRegex(\".*peer fingerprint \\\\(SHA1\\\\): ([A-F0-9:]+) \\\\(SHA256\\\\): ([A-F0-9:]+)\");\n    if (!fingerprintRegex.exactMatch(line)) {\n        return;\n    }\n\n    barrier::FingerprintData fingerprint_sha1 = {\n        barrier::fingerprint_type_to_string(barrier::FingerprintType::SHA1),\n        barrier::string::from_hex(fingerprintRegex.cap(1).toStdString())\n    };\n\n    barrier::FingerprintData fingerprint_sha256 = {\n        barrier::fingerprint_type_to_string(barrier::FingerprintType::SHA256),\n        barrier::string::from_hex(fingerprintRegex.cap(2).toStdString())\n    };\n\n    bool is_client = barrierType() == barrierClient;\n\n    auto db_path = is_client\n            ? barrier::DataDirectories::trusted_servers_ssl_fingerprints_path()\n            : barrier::DataDirectories::trusted_clients_ssl_fingerprints_path();\n\n    auto db_dir = db_path.parent_path();\n    if (!barrier::fs::exists(db_dir)) {\n        barrier::fs::create_directories(db_dir);\n    }\n\n    // We compare only SHA256 fingerprints, but show both SHA1 and SHA256 so that the users can\n    // still verify fingerprints on old Barrier servers. This way the only time when we are exposed\n    // to SHA1 vulnerabilities is when the user is reconnecting again.\n    barrier::FingerprintDatabase db;\n    db.read(db_path);\n    if (db.is_trusted(fingerprint_sha256)) {\n        return;\n    }\n\n    static bool messageBoxAlreadyShown = false;\n\n    if (!messageBoxAlreadyShown) {\n        if (is_client) {\n            stopBarrier();\n        }\n\n        QString message;\n        if (is_client) {\n            message = tr(\"Do you trust this fingerprint?\\n\\n\"\n               \"SHA256:\\n\"\n               \"%1\\n\"\n               \"%2\\n\\n\"\n               \"SHA1 (obsolete, when using old Barrier client):\\n\"\n               \"%3\\n\\n\"\n               \"This is a server fingerprint. You should compare this \"\n               \"fingerprint to the one on your server's screen. If the \"\n               \"two don't match exactly, then it's probably not the server \"\n               \"you're expecting (it could be a malicious user).\\n\\n\"\n               \"To automatically trust this fingerprint for future \"\n               \"connections, click Yes. To reject this fingerprint and \"\n               \"disconnect from the server, click No.\")\n            .arg(QString::fromStdString(barrier::format_ssl_fingerprint(fingerprint_sha256.data)))\n            .arg(QString::fromStdString(\n                     barrier::create_fingerprint_randomart(fingerprint_sha256.data)))\n            .arg(QString::fromStdString(barrier::format_ssl_fingerprint(fingerprint_sha1.data)));\n        } else {\n            message = tr(\"Do you trust this fingerprint?\\n\\n\"\n               \"SHA256:\\n\"\n               \"%1\\n\"\n               \"%2\\n\\n\"\n               \"This is a client fingerprint. You should compare this \"\n               \"fingerprint to the one on your client's screen. If the \"\n               \"two don't match exactly, then it's probably not the client \"\n               \"you're expecting (it could be a malicious user).\\n\\n\"\n               \"To automatically trust this fingerprint for future \"\n               \"connections, click Yes. To reject this fingerprint and \"\n               \"disconnect the client, click No.\")\n            .arg(QString::fromStdString(barrier::format_ssl_fingerprint(fingerprint_sha256.data)))\n            .arg(QString::fromStdString(\n                     barrier::create_fingerprint_randomart(fingerprint_sha256.data)));\n        }\n\n        messageBoxAlreadyShown = true;\n        QMessageBox::StandardButton fingerprintReply =\n            QMessageBox::information(\n            this, tr(\"Security question\"),\n            message,\n            QMessageBox::Yes | QMessageBox::No);\n\n        if (fingerprintReply == QMessageBox::Yes) {\n            // restart core process after trusting fingerprint.\n            db.add_trusted(fingerprint_sha256);\n            db.write(db_path);\n            if (is_client) {\n                startBarrier();\n            }\n        }\n\n        messageBoxAlreadyShown = false;\n    }\n}",
  "abstract_func": "void MainWindow::checkFingerprint(const QString& VAR_0)\n{\n    QRegExp VAR_1(\".*peer fingerprint \\\\(SHA1\\\\): ([A-F0-9:]+) \\\\(SHA256\\\\): ([A-F0-9:]+)\");\n    if (!VAR_1.exactMatch(VAR_0)) {\n        return;\n    }\n\n    barrier::FingerprintData VAR_2 = {\n        barrier::fingerprint_type_to_string(barrier::FingerprintType::SHA1),\n        barrier::string::from_hex(VAR_1.cap(1).toStdString())\n    };\n\n    barrier::FingerprintData VAR_3 = {\n        barrier::fingerprint_type_to_string(barrier::FingerprintType::SHA256),\n        barrier::string::from_hex(VAR_1.cap(2).toStdString())\n    };\n\n    bool VAR_4 = barrierType() == VAR_5;\n\n    auto VAR_6 = VAR_4\n            ? barrier::DataDirectories::trusted_servers_ssl_fingerprints_path()\n            : barrier::DataDirectories::trusted_clients_ssl_fingerprints_path();\n\n    auto VAR_7 = VAR_6.parent_path();\n    if (!barrier::fs::exists(VAR_7)) {\n        barrier::fs::create_directories(VAR_7);\n    }\n\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n    barrier::FingerprintDatabase VAR_8;\n    VAR_8.read(VAR_6);\n    if (VAR_8.is_trusted(VAR_3)) {\n        return;\n    }\n\n    static bool VAR_9 = false;\n\n    if (!VAR_9) {\n        if (VAR_4) {\n            stopBarrier();\n        }\n\n        QString VAR_10;\n        if (VAR_4) {\n            VAR_10 = tr(\"Do you trust this fingerprint?\\n\\n\"\n               \"SHA256:\\n\"\n               \"%1\\n\"\n               \"%2\\n\\n\"\n               \"SHA1 (obsolete, when using old Barrier client):\\n\"\n               \"%3\\n\\n\"\n               \"This is a server fingerprint. You should compare this \"\n               \"fingerprint to the one on your server's screen. If the \"\n               \"two don't match exactly, then it's probably not the server \"\n               \"you're expecting (it could be a malicious user).\\n\\n\"\n               \"To automatically trust this fingerprint for future \"\n               \"connections, click Yes. To reject this fingerprint and \"\n               \"disconnect from the server, click No.\")\n            .arg(QString::fromStdString(barrier::format_ssl_fingerprint(VAR_3.data)))\n            .arg(QString::fromStdString(\n                     barrier::create_fingerprint_randomart(VAR_3.data)))\n            .arg(QString::fromStdString(barrier::format_ssl_fingerprint(VAR_2.data)));\n        } else {\n            VAR_10 = tr(\"Do you trust this fingerprint?\\n\\n\"\n               \"SHA256:\\n\"\n               \"%1\\n\"\n               \"%2\\n\\n\"\n               \"This is a client fingerprint. You should compare this \"\n               \"fingerprint to the one on your client's screen. If the \"\n               \"two don't match exactly, then it's probably not the client \"\n               \"you're expecting (it could be a malicious user).\\n\\n\"\n               \"To automatically trust this fingerprint for future \"\n               \"connections, click Yes. To reject this fingerprint and \"\n               \"disconnect the client, click No.\")\n            .arg(QString::fromStdString(barrier::format_ssl_fingerprint(VAR_3.data)))\n            .arg(QString::fromStdString(\n                     barrier::create_fingerprint_randomart(VAR_3.data)));\n        }\n\n        VAR_9 = true;\n        QMessageBox::StandardButton VAR_11 =\n            QMessageBox::information(\n            this, tr(\"Security question\"),\n            VAR_10,\n            QMessageBox::Yes | QMessageBox::No);\n\n        if (VAR_11 == QMessageBox::Yes) {\n            /* COMMENT_3 */\n            VAR_8.add_trusted(VAR_3);\n            VAR_8.write(VAR_6);\n            if (VAR_4) {\n                startBarrier();\n            }\n        }\n\n        VAR_9 = false;\n    }\n}",
  "func_graph_path": "debauchee/barrier/229abab99f39f11624e5651f819e7f1f8eddedcc/MainWindow.cpp/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n void MainWindow::checkFingerprint(const QString& line)\n {\n-    QRegExp fingerprintRegex(\".*server fingerprint \\\\(SHA1\\\\): ([A-F0-9:]+) \\\\(SHA256\\\\): ([A-F0-9:]+)\");\n+    QRegExp fingerprintRegex(\".*peer fingerprint \\\\(SHA1\\\\): ([A-F0-9:]+) \\\\(SHA256\\\\): ([A-F0-9:]+)\");\n     if (!fingerprintRegex.exactMatch(line)) {\n         return;\n     }\n@@ -15,7 +15,11 @@\n         barrier::string::from_hex(fingerprintRegex.cap(2).toStdString())\n     };\n \n-    auto db_path = barrier::DataDirectories::trusted_servers_ssl_fingerprints_path();\n+    bool is_client = barrierType() == barrierClient;\n+\n+    auto db_path = is_client\n+            ? barrier::DataDirectories::trusted_servers_ssl_fingerprints_path()\n+            : barrier::DataDirectories::trusted_clients_ssl_fingerprints_path();\n \n     auto db_dir = db_path.parent_path();\n     if (!barrier::fs::exists(db_dir)) {\n@@ -34,17 +38,17 @@\n     static bool messageBoxAlreadyShown = false;\n \n     if (!messageBoxAlreadyShown) {\n-        stopBarrier();\n+        if (is_client) {\n+            stopBarrier();\n+        }\n \n-        messageBoxAlreadyShown = true;\n-        QMessageBox::StandardButton fingerprintReply =\n-            QMessageBox::information(\n-            this, tr(\"Security question\"),\n-            tr(\"Do you trust this fingerprint?\\n\\n\"\n+        QString message;\n+        if (is_client) {\n+            message = tr(\"Do you trust this fingerprint?\\n\\n\"\n                \"SHA256:\\n\"\n                \"%1\\n\"\n                \"%2\\n\\n\"\n-               \"SHA1 (obsolete, when using old Barrier server):\\n\"\n+               \"SHA1 (obsolete, when using old Barrier client):\\n\"\n                \"%3\\n\\n\"\n                \"This is a server fingerprint. You should compare this \"\n                \"fingerprint to the one on your server's screen. If the \"\n@@ -56,14 +60,38 @@\n             .arg(QString::fromStdString(barrier::format_ssl_fingerprint(fingerprint_sha256.data)))\n             .arg(QString::fromStdString(\n                      barrier::create_fingerprint_randomart(fingerprint_sha256.data)))\n-            .arg(QString::fromStdString(barrier::format_ssl_fingerprint(fingerprint_sha1.data))),\n+            .arg(QString::fromStdString(barrier::format_ssl_fingerprint(fingerprint_sha1.data)));\n+        } else {\n+            message = tr(\"Do you trust this fingerprint?\\n\\n\"\n+               \"SHA256:\\n\"\n+               \"%1\\n\"\n+               \"%2\\n\\n\"\n+               \"This is a client fingerprint. You should compare this \"\n+               \"fingerprint to the one on your client's screen. If the \"\n+               \"two don't match exactly, then it's probably not the client \"\n+               \"you're expecting (it could be a malicious user).\\n\\n\"\n+               \"To automatically trust this fingerprint for future \"\n+               \"connections, click Yes. To reject this fingerprint and \"\n+               \"disconnect the client, click No.\")\n+            .arg(QString::fromStdString(barrier::format_ssl_fingerprint(fingerprint_sha256.data)))\n+            .arg(QString::fromStdString(\n+                     barrier::create_fingerprint_randomart(fingerprint_sha256.data)));\n+        }\n+\n+        messageBoxAlreadyShown = true;\n+        QMessageBox::StandardButton fingerprintReply =\n+            QMessageBox::information(\n+            this, tr(\"Security question\"),\n+            message,\n             QMessageBox::Yes | QMessageBox::No);\n \n         if (fingerprintReply == QMessageBox::Yes) {\n             // restart core process after trusting fingerprint.\n             db.add_trusted(fingerprint_sha256);\n             db.write(db_path);\n-            startBarrier();\n+            if (is_client) {\n+                startBarrier();\n+            }\n         }\n \n         messageBoxAlreadyShown = false;",
  "diff_line_info": {
    "deleted_lines": [
      "    QRegExp fingerprintRegex(\".*server fingerprint \\\\(SHA1\\\\): ([A-F0-9:]+) \\\\(SHA256\\\\): ([A-F0-9:]+)\");",
      "    auto db_path = barrier::DataDirectories::trusted_servers_ssl_fingerprints_path();",
      "        stopBarrier();",
      "        messageBoxAlreadyShown = true;",
      "        QMessageBox::StandardButton fingerprintReply =",
      "            QMessageBox::information(",
      "            this, tr(\"Security question\"),",
      "            tr(\"Do you trust this fingerprint?\\n\\n\"",
      "               \"SHA1 (obsolete, when using old Barrier server):\\n\"",
      "            .arg(QString::fromStdString(barrier::format_ssl_fingerprint(fingerprint_sha1.data))),",
      "            startBarrier();"
    ],
    "added_lines": [
      "    QRegExp fingerprintRegex(\".*peer fingerprint \\\\(SHA1\\\\): ([A-F0-9:]+) \\\\(SHA256\\\\): ([A-F0-9:]+)\");",
      "    bool is_client = barrierType() == barrierClient;",
      "",
      "    auto db_path = is_client",
      "            ? barrier::DataDirectories::trusted_servers_ssl_fingerprints_path()",
      "            : barrier::DataDirectories::trusted_clients_ssl_fingerprints_path();",
      "        if (is_client) {",
      "            stopBarrier();",
      "        }",
      "        QString message;",
      "        if (is_client) {",
      "            message = tr(\"Do you trust this fingerprint?\\n\\n\"",
      "               \"SHA1 (obsolete, when using old Barrier client):\\n\"",
      "            .arg(QString::fromStdString(barrier::format_ssl_fingerprint(fingerprint_sha1.data)));",
      "        } else {",
      "            message = tr(\"Do you trust this fingerprint?\\n\\n\"",
      "               \"SHA256:\\n\"",
      "               \"%1\\n\"",
      "               \"%2\\n\\n\"",
      "               \"This is a client fingerprint. You should compare this \"",
      "               \"fingerprint to the one on your client's screen. If the \"",
      "               \"two don't match exactly, then it's probably not the client \"",
      "               \"you're expecting (it could be a malicious user).\\n\\n\"",
      "               \"To automatically trust this fingerprint for future \"",
      "               \"connections, click Yes. To reject this fingerprint and \"",
      "               \"disconnect the client, click No.\")",
      "            .arg(QString::fromStdString(barrier::format_ssl_fingerprint(fingerprint_sha256.data)))",
      "            .arg(QString::fromStdString(",
      "                     barrier::create_fingerprint_randomart(fingerprint_sha256.data)));",
      "        }",
      "",
      "        messageBoxAlreadyShown = true;",
      "        QMessageBox::StandardButton fingerprintReply =",
      "            QMessageBox::information(",
      "            this, tr(\"Security question\"),",
      "            message,",
      "            if (is_client) {",
      "                startBarrier();",
      "            }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/debauchee/barrier/pull/1346",
  "description": {
    "pr_info": {
      "title": "Implement client identity verification [SECURITY VULNERABILITIES CVE-2021-42072, CVE-2021-42073]",
      "number": 1346
    },
    "comment": [
      "This PR implements client identity verification. Essentially server gets the same process of accepting and rejecting clients like the clients can accept or reject the server. This is important because even though the client can't move the mouse on the server, it can still receive input and potentially set the clipboard.\r\n\r\nThis PR fixes the following security vulnerabilities:\r\n\r\n - CVE-2021-42072 server does not verify client identity (certificate fingerprint)\r\n - CVE-2021-42073 By guessing/listening in on valid client names server clipboard content can be manipulated.\r\n\r\nThe issues have been reported by Matthias Gerstner <mgerstner@suse.de> @mgerstner. Matthias also provided insights into how best to fix the issues, precise reproduction steps and any used tools and made the maintainer's life as pleasant as possible. Thank you!"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}