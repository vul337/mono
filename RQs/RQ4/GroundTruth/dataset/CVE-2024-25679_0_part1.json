{
  "cve_id": "CVE-2024-25679",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:L",
  "cvss_is_v3": true,
  "repo_name": "p-quic/pquic",
  "commit_msg": "discard the keys after handshake is done; use the correct original_destination_connection_id; discard the re-transmission packets correctly; limit the active_connection_id",
  "commit_hash": "2dbc6bbd71ddffe0f040016240541658b6e3ebba",
  "git_url": "https://github.com/p-quic/pquic/commit/2dbc6bbd71ddffe0f040016240541658b6e3ebba",
  "file_path": "picoquic/quicctx.c",
  "func_name": "picoquic_create_cnx",
  "func_before": "picoquic_cnx_t* picoquic_create_cnx(picoquic_quic_t* quic,\n    picoquic_connection_id_t initial_cnx_id, picoquic_connection_id_t remote_cnx_id,\n    struct sockaddr* addr, uint64_t start_time, uint32_t preferred_version,\n    char const* sni, char const* alpn, char client_mode)\n{\n    picoquic_cnx_t* cnx = (picoquic_cnx_t*)malloc(sizeof(picoquic_cnx_t));\n\n    if (cnx != NULL) {\n        int ret;\n\n        memset(cnx, 0, sizeof(picoquic_cnx_t));\n\n        cnx->quic = quic;\n        cnx->client_mode = client_mode;\n        /* Should return 0, since this is the first path */\n        ret = picoquic_create_path(cnx, start_time, addr);\n\n        if (ret != 0) {\n            free(cnx);\n            cnx = NULL;\n        } else {\n            cnx->next_wake_time = start_time;\n            cnx->start_time = start_time;\n\n            picoquic_insert_cnx_in_list(quic, cnx);\n            picoquic_insert_cnx_by_wake_time(quic, cnx);\n            /* Do not require verification for default path */\n            cnx->path[0]->challenge_verified = 1;\n        }\n    }\n\n    if (cnx != NULL) {\n        if (quic->default_tp == NULL) {\n            picoquic_init_transport_parameters(&cnx->local_parameters, cnx->client_mode);\n        } else {\n            memcpy(&cnx->local_parameters, quic->default_tp, sizeof(picoquic_tp_t));\n        }\n        if (cnx->quic->mtu_max > 0)\n        {\n            cnx->local_parameters.max_packet_size = cnx->quic->mtu_max;\n        }\n\n\n        /* Initialize local flow control variables to advertised values */\n        cnx->maxdata_local = ((uint64_t)cnx->local_parameters.initial_max_data);\n        cnx->max_stream_id_bidir_local = picoquic_transport_param_to_stream_id(cnx->local_parameters.initial_max_streams_bidi, cnx->client_mode, PICOQUIC_STREAM_ID_BIDIR);\n        cnx->max_stream_id_bidir_local_computed = cnx->max_stream_id_bidir_local;\n        cnx->max_stream_id_unidir_local = picoquic_transport_param_to_stream_id(cnx->local_parameters.initial_max_streams_uni, cnx->client_mode, PICOQUIC_STREAM_ID_UNIDIR);\n        cnx->max_stream_id_unidir_local_computed = cnx->max_stream_id_unidir_local;\n\n        /* Initialize remote variables to some plausible value.\n\t\t * Hopefully, this will be overwritten by the parameters received in\n\t\t * the TLS transport parameter extension */\n        cnx->maxdata_remote = PICOQUIC_DEFAULT_0RTT_WINDOW;\n        cnx->remote_parameters.initial_max_stream_data_bidi_remote = PICOQUIC_DEFAULT_0RTT_WINDOW;\n        cnx->remote_parameters.initial_max_stream_data_uni = PICOQUIC_DEFAULT_0RTT_WINDOW;\n        cnx->max_stream_id_bidir_remote = (cnx->client_mode)?4:0;\n        cnx->max_stream_id_unidir_remote = 0;\n\n        if (sni != NULL) {\n            cnx->sni = picoquic_string_duplicate(sni);\n        }\n\n        if (alpn != NULL) {\n            cnx->alpn = picoquic_string_duplicate(alpn);\n        }\n\n        cnx->callback_fn = quic->default_callback_fn;\n        cnx->callback_ctx = quic->default_callback_ctx;\n        cnx->congestion_alg = quic->default_congestion_alg;\n\n        if (cnx->client_mode) {\n            if (preferred_version == 0) {\n                cnx->proposed_version = picoquic_supported_versions[0].version;\n                cnx->version_index = 0;\n            } else {\n                cnx->version_index = picoquic_get_version_index(preferred_version);\n                if (cnx->version_index < 0) {\n                    cnx->version_index = PICOQUIC_INTEROP_VERSION_INDEX;\n                    if ((preferred_version & 0x0A0A0A0A) == 0x0A0A0A0A) {\n                        /* This is a hack, to allow greasing the cnx ID */\n                        cnx->proposed_version = preferred_version;\n\n                    } else {\n                        cnx->proposed_version = picoquic_supported_versions[PICOQUIC_INTEROP_VERSION_INDEX].version;\n                    }\n                } else {\n                    cnx->proposed_version = preferred_version;\n                }\n            }\n\n            cnx->cnx_state = picoquic_state_client_init;\n            if (picoquic_is_connection_id_null(initial_cnx_id)) {\n                picoquic_create_random_cnx_id(quic, &initial_cnx_id, 8);\n            }\n\n            if (quic->cnx_id_callback_fn) {\n                quic->cnx_id_callback_fn(cnx->path[0]->local_cnxid, picoquic_null_connection_id, quic->cnx_id_callback_ctx, &cnx->path[0]->local_cnxid);\n            }\n\n            cnx->initial_cnxid = initial_cnx_id;\n        } else {\n            for (int epoch = 0; epoch < PICOQUIC_NUMBER_OF_EPOCHS; epoch++) {\n                cnx->tls_stream[epoch].send_queue = NULL;\n            }\n            cnx->cnx_state = picoquic_state_server_init;\n            cnx->initial_cnxid = initial_cnx_id;\n            cnx->path[0]->remote_cnxid = remote_cnx_id;\n\n            if (quic->cnx_id_callback_fn)\n                quic->cnx_id_callback_fn(cnx->path[0]->local_cnxid, cnx->initial_cnxid,\n                    quic->cnx_id_callback_ctx, &cnx->path[0]->local_cnxid);\n\n            (void)picoquic_create_cnxid_reset_secret(quic, &cnx->path[0]->local_cnxid,\n                cnx->path[0]->reset_secret);\n\n            cnx->version_index = picoquic_get_version_index(preferred_version);\n            if (cnx->version_index < 0) {\n                /* TODO: this is an internal error condition, should not happen */\n                cnx->version_index = 0;\n                cnx->proposed_version = picoquic_supported_versions[0].version;\n            } else {\n                cnx->proposed_version = preferred_version;\n            }\n        }\n\n        if (cnx != NULL) {\n            /* Moved packet context initialization into path creation */\n\n            cnx->latest_progress_time = start_time;\n            cnx->local_parameters.initial_source_connection_id = cnx->path[0]->local_cnxid;\n\n            for (int epoch = 0; epoch < PICOQUIC_NUMBER_OF_EPOCHS; epoch++) {\n                cnx->tls_stream[epoch].stream_id = 0;\n                cnx->tls_stream[epoch].consumed_offset = 0;\n                cnx->tls_stream[epoch].fin_offset = 0;\n                cnx->tls_stream[epoch].next_stream = NULL;\n                cnx->tls_stream[epoch].stream_data = NULL;\n                cnx->tls_stream[epoch].sent_offset = 0;\n                cnx->tls_stream[epoch].local_error = 0;\n                cnx->tls_stream[epoch].remote_error = 0;\n                cnx->tls_stream[epoch].maxdata_local = (uint64_t)((int64_t)-1);\n                cnx->tls_stream[epoch].maxdata_remote = (uint64_t)((int64_t)-1);\n                /* No need to reset the state flags, as they are not used for the crypto stream */\n            }\n\n            cnx->congestion_alg = cnx->quic->default_congestion_alg;\n            if (cnx->congestion_alg != NULL) {\n                cnx->congestion_alg->alg_init(cnx, cnx->path[0]);\n            }\n        }\n    }\n\n    if (cnx != NULL) {\n        register_protocol_operations(cnx);\n        /* It's already the time to inject plugins, as creating the TLS context sets up the transport parameters */\n        if (quic->local_plugins.size > 0) {\n            int err = plugin_insert_plugins(cnx, quic->local_plugins.size, quic->local_plugins.elems);\n            if (err) {\n                cnx = NULL;\n            }\n        }\n    }\n\n    /* Only initialize TLS after all parameters have been set */\n\n    if (cnx != NULL) {\n        if (picoquic_tlscontext_create(quic, cnx, start_time) != 0) {\n            /* Cannot just do partial creation! */\n            picoquic_delete_cnx(cnx);\n            cnx = NULL;\n        }\n    }\n\n    if (cnx != NULL) {\n        if (picoquic_setup_initial_traffic_keys(cnx)) {\n            /* Cannot initialize aead for initial packets */\n            picoquic_delete_cnx(cnx);\n            cnx = NULL;\n        }\n    }\n\n    if (cnx != NULL) {\n        if (!picoquic_is_connection_id_null(cnx->path[0]->local_cnxid)) {\n            (void)picoquic_register_cnx_id(quic, cnx, &cnx->path[0]->local_cnxid);\n        }\n\n        if (addr != NULL) {\n            (void)picoquic_register_net_id(quic, cnx, addr);\n        }\n    }\n\n    if (cnx != NULL) {\n        /* Also initialize reserve queue */\n        cnx->reserved_frames = queue_init();\n        /* And the retry queue */\n        cnx->retry_frames = queue_init();\n        for (int pc = 0; pc < picoquic_nb_packet_context; pc++) {\n            cnx->rtx_frames[pc] = queue_init();\n        }\n        /* TODO change this arbitrary value */\n        cnx->core_rate = 500;\n    }\n\n    return cnx;\n}",
  "abstract_func_before": "picoquic_cnx_t* picoquic_create_cnx(picoquic_quic_t* VAR_0,\n    picoquic_connection_id_t VAR_1, picoquic_connection_id_t VAR_2,\n    struct sockaddr* VAR_3, uint64_t VAR_4, uint32_t VAR_5,\n    char const* VAR_6, char const* VAR_7, char VAR_8)\n{\n    picoquic_cnx_t* VAR_9 = (picoquic_cnx_t*)malloc(sizeof(picoquic_cnx_t));\n\n    if (VAR_9 != NULL) {\n        int VAR_10;\n\n        memset(VAR_9, 0, sizeof(picoquic_cnx_t));\n\n        VAR_9->quic = VAR_0;\n        VAR_9->client_mode = VAR_8;\n        /* COMMENT_0 */\n        VAR_10 = picoquic_create_path(VAR_9, VAR_4, VAR_3);\n\n        if (VAR_10 != 0) {\n            free(VAR_9);\n            VAR_9 = NULL;\n        } else {\n            VAR_9->next_wake_time = VAR_4;\n            VAR_9->start_time = VAR_4;\n\n            picoquic_insert_cnx_in_list(VAR_0, VAR_9);\n            picoquic_insert_cnx_by_wake_time(VAR_0, VAR_9);\n            /* COMMENT_1 */\n            VAR_9->path[0]->challenge_verified = 1;\n        }\n    }\n\n    if (VAR_9 != NULL) {\n        if (VAR_0->default_tp == NULL) {\n            picoquic_init_transport_parameters(&VAR_9->local_parameters, VAR_9->client_mode);\n        } else {\n            memcpy(&VAR_9->local_parameters, VAR_0->default_tp, sizeof(VAR_11));\n        }\n        if (VAR_9->quic->mtu_max > 0)\n        {\n            VAR_9->local_parameters.max_packet_size = VAR_9->quic->mtu_max;\n        }\n\n\n        /* COMMENT_2 */\n        VAR_9->maxdata_local = ((uint64_t)VAR_9->local_parameters.initial_max_data);\n        VAR_9->max_stream_id_bidir_local = picoquic_transport_param_to_stream_id(VAR_9->local_parameters.initial_max_streams_bidi, VAR_9->client_mode, VAR_12);\n        VAR_9->max_stream_id_bidir_local_computed = VAR_9->max_stream_id_bidir_local;\n        VAR_9->max_stream_id_unidir_local = picoquic_transport_param_to_stream_id(VAR_9->local_parameters.initial_max_streams_uni, VAR_9->client_mode, VAR_13);\n        VAR_9->max_stream_id_unidir_local_computed = VAR_9->max_stream_id_unidir_local;\n\n        /* COMMENT_3 */\n                                                                      \n                                             \n        VAR_9->maxdata_remote = VAR_14;\n        VAR_9->remote_parameters.initial_max_stream_data_bidi_remote = VAR_14;\n        VAR_9->remote_parameters.initial_max_stream_data_uni = VAR_14;\n        VAR_9->max_stream_id_bidir_remote = (VAR_9->client_mode)?4:0;\n        VAR_9->max_stream_id_unidir_remote = 0;\n\n        if (VAR_6 != NULL) {\n            VAR_9->sni = picoquic_string_duplicate(VAR_6);\n        }\n\n        if (VAR_7 != NULL) {\n            VAR_9->alpn = picoquic_string_duplicate(VAR_7);\n        }\n\n        VAR_9->callback_fn = VAR_0->default_callback_fn;\n        VAR_9->callback_ctx = VAR_0->default_callback_ctx;\n        VAR_9->congestion_alg = VAR_0->default_congestion_alg;\n\n        if (VAR_9->client_mode) {\n            if (VAR_5 == 0) {\n                VAR_9->proposed_version = VAR_15[0].version;\n                VAR_9->version_index = 0;\n            } else {\n                VAR_9->version_index = picoquic_get_version_index(VAR_5);\n                if (VAR_9->version_index < 0) {\n                    VAR_9->version_index = VAR_16;\n                    if ((VAR_5 & 0x0A0A0A0A) == 0x0A0A0A0A) {\n                        /* COMMENT_6 */\n                        VAR_9->proposed_version = VAR_5;\n\n                    } else {\n                        VAR_9->proposed_version = VAR_15[VAR_16].version;\n                    }\n                } else {\n                    VAR_9->proposed_version = VAR_5;\n                }\n            }\n\n            VAR_9->cnx_state = VAR_17;\n            if (picoquic_is_connection_id_null(VAR_1)) {\n                picoquic_create_random_cnx_id(VAR_0, &VAR_1, 8);\n            }\n\n            if (VAR_0->cnx_id_callback_fn) {\n                VAR_0->cnx_id_callback_fn(VAR_9->path[0]->local_cnxid, VAR_18, VAR_0->cnx_id_callback_ctx, &VAR_9->path[0]->local_cnxid);\n            }\n\n            VAR_9->initial_cnxid = VAR_1;\n        } else {\n            for (int VAR_19 = 0; VAR_19 < VAR_20; VAR_19++) {\n                VAR_9->tls_stream[VAR_19].send_queue = NULL;\n            }\n            VAR_9->cnx_state = VAR_21;\n            VAR_9->initial_cnxid = VAR_1;\n            VAR_9->path[0]->remote_cnxid = VAR_2;\n\n            if (VAR_0->cnx_id_callback_fn)\n                VAR_0->cnx_id_callback_fn(VAR_9->path[0]->local_cnxid, VAR_9->initial_cnxid,\n                    VAR_0->cnx_id_callback_ctx, &VAR_9->path[0]->local_cnxid);\n\n            (void)picoquic_create_cnxid_reset_secret(VAR_0, &VAR_9->path[0]->local_cnxid,\n                VAR_9->path[0]->reset_secret);\n\n            VAR_9->version_index = picoquic_get_version_index(VAR_5);\n            if (VAR_9->version_index < 0) {\n                /* COMMENT_7 */\n                VAR_9->version_index = 0;\n                VAR_9->proposed_version = VAR_15[0].version;\n            } else {\n                VAR_9->proposed_version = VAR_5;\n            }\n        }\n\n        if (VAR_9 != NULL) {\n            /* COMMENT_8 */\n\n            VAR_9->latest_progress_time = VAR_4;\n            VAR_9->local_parameters.initial_source_connection_id = VAR_9->path[0]->local_cnxid;\n\n            for (int VAR_19 = 0; VAR_19 < VAR_20; VAR_19++) {\n                VAR_9->tls_stream[VAR_19].stream_id = 0;\n                VAR_9->tls_stream[VAR_19].consumed_offset = 0;\n                VAR_9->tls_stream[VAR_19].fin_offset = 0;\n                VAR_9->tls_stream[VAR_19].next_stream = NULL;\n                VAR_9->tls_stream[VAR_19].stream_data = NULL;\n                VAR_9->tls_stream[VAR_19].sent_offset = 0;\n                VAR_9->tls_stream[VAR_19].local_error = 0;\n                VAR_9->tls_stream[VAR_19].remote_error = 0;\n                VAR_9->tls_stream[VAR_19].maxdata_local = (uint64_t)((int64_t)-1);\n                VAR_9->tls_stream[VAR_19].maxdata_remote = (uint64_t)((int64_t)-1);\n                /* COMMENT_9 */\n            }\n\n            VAR_9->congestion_alg = VAR_9->quic->default_congestion_alg;\n            if (VAR_9->congestion_alg != NULL) {\n                VAR_9->congestion_alg->alg_init(VAR_9, VAR_9->path[0]);\n            }\n        }\n    }\n\n    if (VAR_9 != NULL) {\n        register_protocol_operations(VAR_9);\n        /* COMMENT_10 */\n        if (VAR_0->local_plugins.size > 0) {\n            int VAR_22 = plugin_insert_plugins(VAR_9, VAR_0->local_plugins.size, VAR_0->local_plugins.elems);\n            if (VAR_22) {\n                VAR_9 = NULL;\n            }\n        }\n    }\n\n    /* COMMENT_11 */\n\n    if (VAR_9 != NULL) {\n        if (picoquic_tlscontext_create(VAR_0, VAR_9, VAR_4) != 0) {\n            /* COMMENT_12 */\n            picoquic_delete_cnx(VAR_9);\n            VAR_9 = NULL;\n        }\n    }\n\n    if (VAR_9 != NULL) {\n        if (picoquic_setup_initial_traffic_keys(VAR_9)) {\n            /* COMMENT_13 */\n            picoquic_delete_cnx(VAR_9);\n            VAR_9 = NULL;\n        }\n    }\n\n    if (VAR_9 != NULL) {\n        if (!picoquic_is_connection_id_null(VAR_9->path[0]->local_cnxid)) {\n            (void)picoquic_register_cnx_id(VAR_0, VAR_9, &VAR_9->path[0]->local_cnxid);\n        }\n\n        if (VAR_3 != NULL) {\n            (void)picoquic_register_net_id(VAR_0, VAR_9, VAR_3);\n        }\n    }\n\n    if (VAR_9 != NULL) {\n        /* COMMENT_14 */\n        VAR_9->reserved_frames = queue_init();\n        /* COMMENT_15 */\n        VAR_9->retry_frames = queue_init();\n        for (int VAR_23 = 0; VAR_23 < VAR_24; VAR_23++) {\n            VAR_9->rtx_frames[VAR_23] = queue_init();\n        }\n        /* COMMENT_16 */\n        VAR_9->core_rate = 500;\n    }\n\n    return VAR_9;\n}",
  "func_graph_path_before": "p-quic/pquic/2dbc6bbd71ddffe0f040016240541658b6e3ebba/quicctx.c/vul/before/0.json",
  "func": "picoquic_cnx_t* picoquic_create_cnx(picoquic_quic_t* quic,\n    picoquic_connection_id_t initial_cnx_id, picoquic_connection_id_t remote_cnx_id,\n    struct sockaddr* addr, uint64_t start_time, uint32_t preferred_version,\n    char const* sni, char const* alpn, char client_mode)\n{\n    picoquic_cnx_t* cnx = (picoquic_cnx_t*)malloc(sizeof(picoquic_cnx_t));\n\n    if (cnx != NULL) {\n        int ret;\n\n        memset(cnx, 0, sizeof(picoquic_cnx_t));\n\n        cnx->quic = quic;\n        cnx->client_mode = client_mode;\n        /* Should return 0, since this is the first path */\n        ret = picoquic_create_path(cnx, start_time, addr);\n\n        if (ret != 0) {\n            free(cnx);\n            cnx = NULL;\n        } else {\n            cnx->next_wake_time = start_time;\n            cnx->start_time = start_time;\n\n            picoquic_insert_cnx_in_list(quic, cnx);\n            picoquic_insert_cnx_by_wake_time(quic, cnx);\n            /* Do not require verification for default path */\n            cnx->path[0]->challenge_verified = 1;\n        }\n    }\n\n    if (cnx != NULL) {\n        if (quic->default_tp == NULL) {\n            picoquic_init_transport_parameters(&cnx->local_parameters, cnx->client_mode);\n        } else {\n            memcpy(&cnx->local_parameters, quic->default_tp, sizeof(picoquic_tp_t));\n        }\n        if (cnx->quic->mtu_max > 0)\n        {\n            cnx->local_parameters.max_packet_size = cnx->quic->mtu_max;\n        }\n\n\n        /* Initialize local flow control variables to advertised values */\n        cnx->maxdata_local = ((uint64_t)cnx->local_parameters.initial_max_data);\n        cnx->max_stream_id_bidir_local = picoquic_transport_param_to_stream_id(cnx->local_parameters.initial_max_streams_bidi, cnx->client_mode, PICOQUIC_STREAM_ID_BIDIR);\n        cnx->max_stream_id_bidir_local_computed = cnx->max_stream_id_bidir_local;\n        cnx->max_stream_id_unidir_local = picoquic_transport_param_to_stream_id(cnx->local_parameters.initial_max_streams_uni, cnx->client_mode, PICOQUIC_STREAM_ID_UNIDIR);\n        cnx->max_stream_id_unidir_local_computed = cnx->max_stream_id_unidir_local;\n\n        /* Initialize remote variables to some plausible value.\n\t\t * Hopefully, this will be overwritten by the parameters received in\n\t\t * the TLS transport parameter extension */\n        cnx->maxdata_remote = PICOQUIC_DEFAULT_0RTT_WINDOW;\n        cnx->remote_parameters.initial_max_stream_data_bidi_remote = PICOQUIC_DEFAULT_0RTT_WINDOW;\n        cnx->remote_parameters.initial_max_stream_data_uni = PICOQUIC_DEFAULT_0RTT_WINDOW;\n        cnx->max_stream_id_bidir_remote = (cnx->client_mode)?4:0;\n        cnx->max_stream_id_unidir_remote = 0;\n\n        if (sni != NULL) {\n            cnx->sni = picoquic_string_duplicate(sni);\n        }\n\n        if (alpn != NULL) {\n            cnx->alpn = picoquic_string_duplicate(alpn);\n        }\n\n        cnx->callback_fn = quic->default_callback_fn;\n        cnx->callback_ctx = quic->default_callback_ctx;\n        cnx->congestion_alg = quic->default_congestion_alg;\n\n        if (cnx->client_mode) {\n            if (preferred_version == 0) {\n                cnx->proposed_version = picoquic_supported_versions[0].version;\n                cnx->version_index = 0;\n            } else {\n                cnx->version_index = picoquic_get_version_index(preferred_version);\n                if (cnx->version_index < 0) {\n                    cnx->version_index = PICOQUIC_INTEROP_VERSION_INDEX;\n                    if ((preferred_version & 0x0A0A0A0A) == 0x0A0A0A0A) {\n                        /* This is a hack, to allow greasing the cnx ID */\n                        cnx->proposed_version = preferred_version;\n\n                    } else {\n                        cnx->proposed_version = picoquic_supported_versions[PICOQUIC_INTEROP_VERSION_INDEX].version;\n                    }\n                } else {\n                    cnx->proposed_version = preferred_version;\n                }\n            }\n\n            cnx->cnx_state = picoquic_state_client_init;\n            if (picoquic_is_connection_id_null(initial_cnx_id)) {\n                picoquic_create_random_cnx_id(quic, &initial_cnx_id, 8);\n            }\n\n            if (quic->cnx_id_callback_fn) {\n                quic->cnx_id_callback_fn(cnx->path[0]->local_cnxid, picoquic_null_connection_id, quic->cnx_id_callback_ctx, &cnx->path[0]->local_cnxid);\n            }\n\n            cnx->initial_cnxid = initial_cnx_id;\n        } else {\n            for (int epoch = 0; epoch < PICOQUIC_NUMBER_OF_EPOCHS; epoch++) {\n                cnx->tls_stream[epoch].send_queue = NULL;\n            }\n            cnx->cnx_state = picoquic_state_server_init;\n            cnx->initial_cnxid = initial_cnx_id;\n            cnx->path[0]->remote_cnxid = remote_cnx_id;\n            cnx->active_connection_id_count = 1;\n\n            if (quic->cnx_id_callback_fn)\n                quic->cnx_id_callback_fn(cnx->path[0]->local_cnxid, cnx->initial_cnxid,\n                    quic->cnx_id_callback_ctx, &cnx->path[0]->local_cnxid);\n\n            (void)picoquic_create_cnxid_reset_secret(quic, &cnx->path[0]->local_cnxid,\n                cnx->path[0]->reset_secret);\n\n            cnx->version_index = picoquic_get_version_index(preferred_version);\n            if (cnx->version_index < 0) {\n                /* TODO: this is an internal error condition, should not happen */\n                cnx->version_index = 0;\n                cnx->proposed_version = picoquic_supported_versions[0].version;\n            } else {\n                cnx->proposed_version = preferred_version;\n            }\n        }\n\n        if (cnx != NULL) {\n            /* Moved packet context initialization into path creation */\n\n            cnx->latest_progress_time = start_time;\n            cnx->local_parameters.initial_source_connection_id = cnx->path[0]->local_cnxid;\n\n            for (int epoch = 0; epoch < PICOQUIC_NUMBER_OF_EPOCHS; epoch++) {\n                cnx->tls_stream[epoch].stream_id = 0;\n                cnx->tls_stream[epoch].consumed_offset = 0;\n                cnx->tls_stream[epoch].fin_offset = 0;\n                cnx->tls_stream[epoch].next_stream = NULL;\n                cnx->tls_stream[epoch].stream_data = NULL;\n                cnx->tls_stream[epoch].sent_offset = 0;\n                cnx->tls_stream[epoch].local_error = 0;\n                cnx->tls_stream[epoch].remote_error = 0;\n                cnx->tls_stream[epoch].maxdata_local = (uint64_t)((int64_t)-1);\n                cnx->tls_stream[epoch].maxdata_remote = (uint64_t)((int64_t)-1);\n                /* No need to reset the state flags, as they are not used for the crypto stream */\n            }\n\n            cnx->congestion_alg = cnx->quic->default_congestion_alg;\n            if (cnx->congestion_alg != NULL) {\n                cnx->congestion_alg->alg_init(cnx, cnx->path[0]);\n            }\n        }\n    }\n\n    if (cnx != NULL) {\n        register_protocol_operations(cnx);\n        /* It's already the time to inject plugins, as creating the TLS context sets up the transport parameters */\n        if (quic->local_plugins.size > 0) {\n            int err = plugin_insert_plugins(cnx, quic->local_plugins.size, quic->local_plugins.elems);\n            if (err) {\n                cnx = NULL;\n            }\n        }\n    }\n\n    /* Only initialize TLS after all parameters have been set */\n\n    if (cnx != NULL) {\n        if (picoquic_tlscontext_create(quic, cnx, start_time) != 0) {\n            /* Cannot just do partial creation! */\n            picoquic_delete_cnx(cnx);\n            cnx = NULL;\n        }\n    }\n\n    if (cnx != NULL) {\n        if (picoquic_setup_initial_traffic_keys(cnx)) {\n            /* Cannot initialize aead for initial packets */\n            picoquic_delete_cnx(cnx);\n            cnx = NULL;\n        }\n    }\n\n    if (cnx != NULL) {\n        if (!picoquic_is_connection_id_null(cnx->path[0]->local_cnxid)) {\n            (void)picoquic_register_cnx_id(quic, cnx, &cnx->path[0]->local_cnxid);\n        }\n\n        if (addr != NULL) {\n            (void)picoquic_register_net_id(quic, cnx, addr);\n        }\n    }\n\n    if (cnx != NULL) {\n        /* Also initialize reserve queue */\n        cnx->reserved_frames = queue_init();\n        /* And the retry queue */\n        cnx->retry_frames = queue_init();\n        for (int pc = 0; pc < picoquic_nb_packet_context; pc++) {\n            cnx->rtx_frames[pc] = queue_init();\n        }\n        /* TODO change this arbitrary value */\n        cnx->core_rate = 500;\n    }\n\n    return cnx;\n}",
  "abstract_func": "picoquic_cnx_t* picoquic_create_cnx(picoquic_quic_t* VAR_0,\n    picoquic_connection_id_t VAR_1, picoquic_connection_id_t VAR_2,\n    struct sockaddr* VAR_3, uint64_t VAR_4, uint32_t VAR_5,\n    char const* VAR_6, char const* VAR_7, char VAR_8)\n{\n    picoquic_cnx_t* VAR_9 = (picoquic_cnx_t*)malloc(sizeof(picoquic_cnx_t));\n\n    if (VAR_9 != NULL) {\n        int VAR_10;\n\n        memset(VAR_9, 0, sizeof(picoquic_cnx_t));\n\n        VAR_9->quic = VAR_0;\n        VAR_9->client_mode = VAR_8;\n        /* COMMENT_0 */\n        VAR_10 = picoquic_create_path(VAR_9, VAR_4, VAR_3);\n\n        if (VAR_10 != 0) {\n            free(VAR_9);\n            VAR_9 = NULL;\n        } else {\n            VAR_9->next_wake_time = VAR_4;\n            VAR_9->start_time = VAR_4;\n\n            picoquic_insert_cnx_in_list(VAR_0, VAR_9);\n            picoquic_insert_cnx_by_wake_time(VAR_0, VAR_9);\n            /* COMMENT_1 */\n            VAR_9->path[0]->challenge_verified = 1;\n        }\n    }\n\n    if (VAR_9 != NULL) {\n        if (VAR_0->default_tp == NULL) {\n            picoquic_init_transport_parameters(&VAR_9->local_parameters, VAR_9->client_mode);\n        } else {\n            memcpy(&VAR_9->local_parameters, VAR_0->default_tp, sizeof(VAR_11));\n        }\n        if (VAR_9->quic->mtu_max > 0)\n        {\n            VAR_9->local_parameters.max_packet_size = VAR_9->quic->mtu_max;\n        }\n\n\n        /* COMMENT_2 */\n        VAR_9->maxdata_local = ((uint64_t)VAR_9->local_parameters.initial_max_data);\n        VAR_9->max_stream_id_bidir_local = picoquic_transport_param_to_stream_id(VAR_9->local_parameters.initial_max_streams_bidi, VAR_9->client_mode, VAR_12);\n        VAR_9->max_stream_id_bidir_local_computed = VAR_9->max_stream_id_bidir_local;\n        VAR_9->max_stream_id_unidir_local = picoquic_transport_param_to_stream_id(VAR_9->local_parameters.initial_max_streams_uni, VAR_9->client_mode, VAR_13);\n        VAR_9->max_stream_id_unidir_local_computed = VAR_9->max_stream_id_unidir_local;\n\n        /* COMMENT_3 */\n                                                                      \n                                             \n        VAR_9->maxdata_remote = VAR_14;\n        VAR_9->remote_parameters.initial_max_stream_data_bidi_remote = VAR_14;\n        VAR_9->remote_parameters.initial_max_stream_data_uni = VAR_14;\n        VAR_9->max_stream_id_bidir_remote = (VAR_9->client_mode)?4:0;\n        VAR_9->max_stream_id_unidir_remote = 0;\n\n        if (VAR_6 != NULL) {\n            VAR_9->sni = picoquic_string_duplicate(VAR_6);\n        }\n\n        if (VAR_7 != NULL) {\n            VAR_9->alpn = picoquic_string_duplicate(VAR_7);\n        }\n\n        VAR_9->callback_fn = VAR_0->default_callback_fn;\n        VAR_9->callback_ctx = VAR_0->default_callback_ctx;\n        VAR_9->congestion_alg = VAR_0->default_congestion_alg;\n\n        if (VAR_9->client_mode) {\n            if (VAR_5 == 0) {\n                VAR_9->proposed_version = VAR_15[0].version;\n                VAR_9->version_index = 0;\n            } else {\n                VAR_9->version_index = picoquic_get_version_index(VAR_5);\n                if (VAR_9->version_index < 0) {\n                    VAR_9->version_index = VAR_16;\n                    if ((VAR_5 & 0x0A0A0A0A) == 0x0A0A0A0A) {\n                        /* COMMENT_6 */\n                        VAR_9->proposed_version = VAR_5;\n\n                    } else {\n                        VAR_9->proposed_version = VAR_15[VAR_16].version;\n                    }\n                } else {\n                    VAR_9->proposed_version = VAR_5;\n                }\n            }\n\n            VAR_9->cnx_state = VAR_17;\n            if (picoquic_is_connection_id_null(VAR_1)) {\n                picoquic_create_random_cnx_id(VAR_0, &VAR_1, 8);\n            }\n\n            if (VAR_0->cnx_id_callback_fn) {\n                VAR_0->cnx_id_callback_fn(VAR_9->path[0]->local_cnxid, VAR_18, VAR_0->cnx_id_callback_ctx, &VAR_9->path[0]->local_cnxid);\n            }\n\n            VAR_9->initial_cnxid = VAR_1;\n        } else {\n            for (int VAR_19 = 0; VAR_19 < VAR_20; VAR_19++) {\n                VAR_9->tls_stream[VAR_19].send_queue = NULL;\n            }\n            VAR_9->cnx_state = VAR_21;\n            VAR_9->initial_cnxid = VAR_1;\n            VAR_9->path[0]->remote_cnxid = VAR_2;\n            VAR_9->active_connection_id_count = 1;\n\n            if (VAR_0->cnx_id_callback_fn)\n                VAR_0->cnx_id_callback_fn(VAR_9->path[0]->local_cnxid, VAR_9->initial_cnxid,\n                    VAR_0->cnx_id_callback_ctx, &VAR_9->path[0]->local_cnxid);\n\n            (void)picoquic_create_cnxid_reset_secret(VAR_0, &VAR_9->path[0]->local_cnxid,\n                VAR_9->path[0]->reset_secret);\n\n            VAR_9->version_index = picoquic_get_version_index(VAR_5);\n            if (VAR_9->version_index < 0) {\n                /* COMMENT_7 */\n                VAR_9->version_index = 0;\n                VAR_9->proposed_version = VAR_15[0].version;\n            } else {\n                VAR_9->proposed_version = VAR_5;\n            }\n        }\n\n        if (VAR_9 != NULL) {\n            /* COMMENT_8 */\n\n            VAR_9->latest_progress_time = VAR_4;\n            VAR_9->local_parameters.initial_source_connection_id = VAR_9->path[0]->local_cnxid;\n\n            for (int VAR_19 = 0; VAR_19 < VAR_20; VAR_19++) {\n                VAR_9->tls_stream[VAR_19].stream_id = 0;\n                VAR_9->tls_stream[VAR_19].consumed_offset = 0;\n                VAR_9->tls_stream[VAR_19].fin_offset = 0;\n                VAR_9->tls_stream[VAR_19].next_stream = NULL;\n                VAR_9->tls_stream[VAR_19].stream_data = NULL;\n                VAR_9->tls_stream[VAR_19].sent_offset = 0;\n                VAR_9->tls_stream[VAR_19].local_error = 0;\n                VAR_9->tls_stream[VAR_19].remote_error = 0;\n                VAR_9->tls_stream[VAR_19].maxdata_local = (uint64_t)((int64_t)-1);\n                VAR_9->tls_stream[VAR_19].maxdata_remote = (uint64_t)((int64_t)-1);\n                /* COMMENT_9 */\n            }\n\n            VAR_9->congestion_alg = VAR_9->quic->default_congestion_alg;\n            if (VAR_9->congestion_alg != NULL) {\n                VAR_9->congestion_alg->alg_init(VAR_9, VAR_9->path[0]);\n            }\n        }\n    }\n\n    if (VAR_9 != NULL) {\n        register_protocol_operations(VAR_9);\n        /* COMMENT_10 */\n        if (VAR_0->local_plugins.size > 0) {\n            int VAR_22 = plugin_insert_plugins(VAR_9, VAR_0->local_plugins.size, VAR_0->local_plugins.elems);\n            if (VAR_22) {\n                VAR_9 = NULL;\n            }\n        }\n    }\n\n    /* COMMENT_11 */\n\n    if (VAR_9 != NULL) {\n        if (picoquic_tlscontext_create(VAR_0, VAR_9, VAR_4) != 0) {\n            /* COMMENT_12 */\n            picoquic_delete_cnx(VAR_9);\n            VAR_9 = NULL;\n        }\n    }\n\n    if (VAR_9 != NULL) {\n        if (picoquic_setup_initial_traffic_keys(VAR_9)) {\n            /* COMMENT_13 */\n            picoquic_delete_cnx(VAR_9);\n            VAR_9 = NULL;\n        }\n    }\n\n    if (VAR_9 != NULL) {\n        if (!picoquic_is_connection_id_null(VAR_9->path[0]->local_cnxid)) {\n            (void)picoquic_register_cnx_id(VAR_0, VAR_9, &VAR_9->path[0]->local_cnxid);\n        }\n\n        if (VAR_3 != NULL) {\n            (void)picoquic_register_net_id(VAR_0, VAR_9, VAR_3);\n        }\n    }\n\n    if (VAR_9 != NULL) {\n        /* COMMENT_14 */\n        VAR_9->reserved_frames = queue_init();\n        /* COMMENT_15 */\n        VAR_9->retry_frames = queue_init();\n        for (int VAR_23 = 0; VAR_23 < VAR_24; VAR_23++) {\n            VAR_9->rtx_frames[VAR_23] = queue_init();\n        }\n        /* COMMENT_16 */\n        VAR_9->core_rate = 500;\n    }\n\n    return VAR_9;\n}",
  "func_graph_path": "p-quic/pquic/2dbc6bbd71ddffe0f040016240541658b6e3ebba/quicctx.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -106,6 +106,7 @@\n             cnx->cnx_state = picoquic_state_server_init;\n             cnx->initial_cnxid = initial_cnx_id;\n             cnx->path[0]->remote_cnxid = remote_cnx_id;\n+            cnx->active_connection_id_count = 1;\n \n             if (quic->cnx_id_callback_fn)\n                 quic->cnx_id_callback_fn(cnx->path[0]->local_cnxid, cnx->initial_cnxid,",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "            cnx->active_connection_id_count = 1;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/p-quic/pquic/pull/39",
  "description": {
    "pr_info": {
      "title": "Minor Fix",
      "number": 39
    },
    "comment": [
      "Hi, I try to fix the bugs in #34 #35 #36 and #38.\r\n\r\nCan you validate these fixes please.\r\n",
      "The code looks good. Have you done any test to ensure it fixes these issues ?"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "The patch modifies core connection handling logic without explicit security indicators. It addresses specific bug fixes, fitting the non-security category of defect remediation.\n\n**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.8\n\nThe changes in the patch address issues with connection state management, specifically setting the active connection ID count. While it's crucial for proper operation, the absence of security terms and references suggests a non-security bug fix. The code changes directly impact core functionality, aligning with feature upgrading or defect remediation rather than security fixes.\n\n**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.8"
}