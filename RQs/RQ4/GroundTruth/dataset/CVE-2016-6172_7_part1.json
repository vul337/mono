{
  "cve_id": "CVE-2016-6172",
  "cwe_ids": [
    "CWE-400"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:C",
  "cvss_is_v3": false,
  "repo_name": "PowerDNS/pdns",
  "commit_msg": "Add limits to the size of received {A,I}XFR, in megabytes\n\nThis prevents memory exhaustion in case the master is sending a\nvery large amount of data in an update.",
  "commit_hash": "db8f9152168acf5d548d4f256789eae783e01667",
  "git_url": "https://github.com/PowerDNS/pdns/commit/db8f9152168acf5d548d4f256789eae783e01667",
  "file_path": "pdns/resolver.cc",
  "func_name": "AXFRRetriever::getChunk",
  "func_before": "int AXFRRetriever::getChunk(Resolver::res_t &res, vector<DNSRecord>* records) // Implementation is making sure RFC2845 4.4 is followed.\n{\n  if(d_soacount > 1)\n    return false;\n\n  // d_sock is connected and is about to spit out a packet\n  int len=getLength();\n  if(len<0)\n    throw ResolverException(\"EOF trying to read axfr chunk from remote TCP client\");\n  \n  timeoutReadn(len); \n  MOADNSParser mdp(d_buf.get(), len);\n\n  int err;\n  if(!records)\n    err=parseResult(mdp, DNSName(), 0, 0, &res);\n  else {\n    records->clear();\n    for(const auto& r: mdp.d_answers)\n      records->push_back(r.first);\n    err = mdp.d_header.rcode;\n  }\n  \n  if(err) \n    throw ResolverException(\"AXFR chunk error: \" + RCode::to_s(err));\n\n  for(const MOADNSParser::answers_t::value_type& answer :  mdp.d_answers)\n    if (answer.first.d_type == QType::SOA)\n      d_soacount++;\n \n  if(!d_tt.name.empty()) { // TSIG verify message\n    // If we have multiple messages, we need to concatenate them together. We also need to make sure we know the location of \n    // the TSIG record so we can remove it in makeTSIGMessageFromTSIGPacket\n    d_signData.append(d_buf.get(), len);\n    if (mdp.getTSIGPos() == 0)\n      d_tsigPos += len;\n    else \n      d_tsigPos += mdp.getTSIGPos();\n\n    string theirMac;\n    bool checkTSIG = false;\n    \n    for(const MOADNSParser::answers_t::value_type& answer :  mdp.d_answers) {\n      if (answer.first.d_type == QType::SOA)  // A SOA is either the first or the last record. We need to check TSIG if that's the case.\n        checkTSIG = true;\n      \n      if(answer.first.d_type == QType::TSIG) {\n        shared_ptr<TSIGRecordContent> trc = getRR<TSIGRecordContent>(answer.first);\n        if(trc) {\n          theirMac = trc->d_mac;\n          d_trc.d_time = trc->d_time;\n          checkTSIG = true;\n        }\n      }\n    }\n\n    if( ! checkTSIG && d_nonSignedMessages > 99) { // We're allowed to get 100 digest without a TSIG.\n      throw ResolverException(\"No TSIG message received in last 100 messages of AXFR transfer.\");\n    }\n\n    if (checkTSIG) {\n      if (theirMac.empty())\n        throw ResolverException(\"No TSIG on AXFR response from \"+d_remote.toStringWithPort()+\" , should be signed with TSIG key '\"+d_tt.name.toString()+\"'\");\n\n      string message;\n      if (!d_prevMac.empty()) {\n        message = makeTSIGMessageFromTSIGPacket(d_signData, d_tsigPos, d_tt.name, d_trc, d_prevMac, true, d_signData.size()-len);\n      } else {\n        message = makeTSIGMessageFromTSIGPacket(d_signData, d_tsigPos, d_tt.name, d_trc, d_trc.d_mac, false);\n      }\n\n      TSIGHashEnum algo;\n      if (!getTSIGHashEnum(d_trc.d_algoName, algo)) {\n        throw ResolverException(\"Unsupported TSIG HMAC algorithm \" + d_trc.d_algoName.toString());\n      }\n\n      if (algo == TSIG_GSS) {\n        GssContext gssctx(d_tt.name);\n        if (!gss_verify_signature(d_tt.name, message, theirMac)) {\n          throw ResolverException(\"Signature failed to validate on AXFR response from \"+d_remote.toStringWithPort()+\" signed with TSIG key '\"+d_tt.name.toString()+\"'\");\n        }\n      } else {\n        string ourMac=calculateHMAC(d_tt.secret, message, algo);\n\n        // ourMac[0]++; // sabotage == for testing :-)\n        if(ourMac != theirMac) {\n          throw ResolverException(\"Signature failed to validate on AXFR response from \"+d_remote.toStringWithPort()+\" signed with TSIG key '\"+d_tt.name.toString()+\"'\");\n        }\n      }\n\n      // Reset and store some values for the next chunks. \n      d_prevMac = theirMac;\n      d_nonSignedMessages = 0;\n      d_signData.clear();\n      d_tsigPos = 0;\n    }\n    else\n      d_nonSignedMessages++;\n  }\n  \n  return true;\n}",
  "abstract_func_before": "int AXFRRetriever::getChunk(Resolver::res_t &VAR_0, vector<DNSRecord>* VAR_1) /* COMMENT_0 */\n{\n  if(VAR_2 > 1)\n    return false;\n\n  /* COMMENT_1 */\n  int VAR_3=getLength();\n  if(VAR_3<0)\n    throw ResolverException(\"EOF trying to read axfr chunk from remote TCP client\");\n  \n  timeoutReadn(VAR_3); \n  MOADNSParser VAR_4(VAR_5.get(), VAR_3);\n\n  int VAR_6;\n  if(!VAR_1)\n    VAR_6=parseResult(VAR_4, DNSName(), 0, 0, &VAR_0);\n  else {\n    VAR_1->clear();\n    for(const auto& VAR_7: VAR_4.d_answers)\n      VAR_1->push_back(VAR_7.first);\n    VAR_6 = VAR_4.d_header.rcode;\n  }\n  \n  if(VAR_6) \n    throw ResolverException(\"AXFR chunk error: \" + RCode::to_s(VAR_6));\n\n  for(const MOADNSParser::answers_t::value_type& VAR_8 :  VAR_4.d_answers)\n    if (VAR_8.first.d_type == QType::SOA)\n      VAR_2++;\n \n  if(!VAR_9.name.empty()) { /* COMMENT_2 */\n    /* COMMENT_3 */\n    /* COMMENT_4 */\n    VAR_10.append(VAR_5.get(), VAR_3);\n    if (VAR_4.getTSIGPos() == 0)\n      VAR_11 += VAR_3;\n    else \n      VAR_11 += VAR_4.getTSIGPos();\n\n    string VAR_12;\n    bool VAR_13 = false;\n    \n    for(const MOADNSParser::answers_t::value_type& VAR_8 :  VAR_4.d_answers) {\n      if (VAR_8.first.d_type == QType::SOA)  /* COMMENT_5 */\n        VAR_13 = true;\n      \n      if(VAR_8.first.d_type == QType::TSIG) {\n        shared_ptr<TSIGRecordContent> VAR_14 = VAR_15<TSIGRecordContent>(VAR_8.first);\n        if(VAR_14) {\n          VAR_12 = VAR_14->d_mac;\n          VAR_16.d_time = VAR_14->d_time;\n          VAR_13 = true;\n        }\n      }\n    }\n\n    if( ! VAR_13 && VAR_17 > 99) { /* COMMENT_6 */\n      throw ResolverException(\"No TSIG message received in last 100 messages of AXFR transfer.\");\n    }\n\n    if (VAR_13) {\n      if (VAR_12.empty())\n        throw ResolverException(\"No TSIG on AXFR response from \"+VAR_18.toStringWithPort()+\" , should be signed with TSIG key '\"+VAR_9.name.toString()+\"'\");\n\n      string VAR_19;\n      if (!VAR_20.empty()) {\n        VAR_19 = makeTSIGMessageFromTSIGPacket(VAR_10, VAR_11, VAR_9.name, VAR_16, VAR_20, true, VAR_10.size()-VAR_3);\n      } else {\n        VAR_19 = makeTSIGMessageFromTSIGPacket(VAR_10, VAR_11, VAR_9.name, VAR_16, VAR_16.d_mac, false);\n      }\n\n      TSIGHashEnum VAR_21;\n      if (!getTSIGHashEnum(VAR_16.d_algoName, VAR_21)) {\n        throw ResolverException(\"Unsupported TSIG HMAC algorithm \" + VAR_16.d_algoName.toString());\n      }\n\n      if (VAR_21 == VAR_22) {\n        GssContext VAR_23(VAR_9.name);\n        if (!gss_verify_signature(VAR_9.name, VAR_19, VAR_12)) {\n          throw ResolverException(\"Signature failed to validate on AXFR response from \"+VAR_18.toStringWithPort()+\" signed with TSIG key '\"+VAR_9.name.toString()+\"'\");\n        }\n      } else {\n        string VAR_24=calculateHMAC(VAR_9.secret, VAR_19, VAR_21);\n\n        /* COMMENT_7 */\n        if(VAR_24 != VAR_12) {\n          throw ResolverException(\"Signature failed to validate on AXFR response from \"+VAR_18.toStringWithPort()+\" signed with TSIG key '\"+VAR_9.name.toString()+\"'\");\n        }\n      }\n\n      /* COMMENT_8 */\n      VAR_20 = VAR_12;\n      VAR_17 = 0;\n      VAR_10.clear();\n      VAR_11 = 0;\n    }\n    else\n      VAR_17++;\n  }\n  \n  return true;\n}",
  "func_graph_path_before": "PowerDNS/pdns/db8f9152168acf5d548d4f256789eae783e01667/resolver.cc/vul/before/1.json",
  "func": "int AXFRRetriever::getChunk(Resolver::res_t &res, vector<DNSRecord>* records) // Implementation is making sure RFC2845 4.4 is followed.\n{\n  if(d_soacount > 1)\n    return false;\n\n  // d_sock is connected and is about to spit out a packet\n  int len=getLength();\n  if(len<0)\n    throw ResolverException(\"EOF trying to read axfr chunk from remote TCP client\");\n\n  if (d_maxReceivedBytes > 0 && (d_maxReceivedBytes - d_receivedBytes) < (size_t) len)\n    throw ResolverException(\"Reached the maximum number of received bytes during AXFR\");\n\n  timeoutReadn(len);\n\n  d_receivedBytes += (uint16_t) len;\n\n  MOADNSParser mdp(d_buf.get(), len);\n\n  int err;\n  if(!records)\n    err=parseResult(mdp, DNSName(), 0, 0, &res);\n  else {\n    records->clear();\n    for(const auto& r: mdp.d_answers)\n      records->push_back(r.first);\n    err = mdp.d_header.rcode;\n  }\n  \n  if(err) \n    throw ResolverException(\"AXFR chunk error: \" + RCode::to_s(err));\n\n  for(const MOADNSParser::answers_t::value_type& answer :  mdp.d_answers)\n    if (answer.first.d_type == QType::SOA)\n      d_soacount++;\n \n  if(!d_tt.name.empty()) { // TSIG verify message\n    // If we have multiple messages, we need to concatenate them together. We also need to make sure we know the location of \n    // the TSIG record so we can remove it in makeTSIGMessageFromTSIGPacket\n    d_signData.append(d_buf.get(), len);\n    if (mdp.getTSIGPos() == 0)\n      d_tsigPos += len;\n    else \n      d_tsigPos += mdp.getTSIGPos();\n\n    string theirMac;\n    bool checkTSIG = false;\n    \n    for(const MOADNSParser::answers_t::value_type& answer :  mdp.d_answers) {\n      if (answer.first.d_type == QType::SOA)  // A SOA is either the first or the last record. We need to check TSIG if that's the case.\n        checkTSIG = true;\n      \n      if(answer.first.d_type == QType::TSIG) {\n        shared_ptr<TSIGRecordContent> trc = getRR<TSIGRecordContent>(answer.first);\n        if(trc) {\n          theirMac = trc->d_mac;\n          d_trc.d_time = trc->d_time;\n          checkTSIG = true;\n        }\n      }\n    }\n\n    if( ! checkTSIG && d_nonSignedMessages > 99) { // We're allowed to get 100 digest without a TSIG.\n      throw ResolverException(\"No TSIG message received in last 100 messages of AXFR transfer.\");\n    }\n\n    if (checkTSIG) {\n      if (theirMac.empty())\n        throw ResolverException(\"No TSIG on AXFR response from \"+d_remote.toStringWithPort()+\" , should be signed with TSIG key '\"+d_tt.name.toString()+\"'\");\n\n      string message;\n      if (!d_prevMac.empty()) {\n        message = makeTSIGMessageFromTSIGPacket(d_signData, d_tsigPos, d_tt.name, d_trc, d_prevMac, true, d_signData.size()-len);\n      } else {\n        message = makeTSIGMessageFromTSIGPacket(d_signData, d_tsigPos, d_tt.name, d_trc, d_trc.d_mac, false);\n      }\n\n      TSIGHashEnum algo;\n      if (!getTSIGHashEnum(d_trc.d_algoName, algo)) {\n        throw ResolverException(\"Unsupported TSIG HMAC algorithm \" + d_trc.d_algoName.toString());\n      }\n\n      if (algo == TSIG_GSS) {\n        GssContext gssctx(d_tt.name);\n        if (!gss_verify_signature(d_tt.name, message, theirMac)) {\n          throw ResolverException(\"Signature failed to validate on AXFR response from \"+d_remote.toStringWithPort()+\" signed with TSIG key '\"+d_tt.name.toString()+\"'\");\n        }\n      } else {\n        string ourMac=calculateHMAC(d_tt.secret, message, algo);\n\n        // ourMac[0]++; // sabotage == for testing :-)\n        if(ourMac != theirMac) {\n          throw ResolverException(\"Signature failed to validate on AXFR response from \"+d_remote.toStringWithPort()+\" signed with TSIG key '\"+d_tt.name.toString()+\"'\");\n        }\n      }\n\n      // Reset and store some values for the next chunks. \n      d_prevMac = theirMac;\n      d_nonSignedMessages = 0;\n      d_signData.clear();\n      d_tsigPos = 0;\n    }\n    else\n      d_nonSignedMessages++;\n  }\n  \n  return true;\n}",
  "abstract_func": "int AXFRRetriever::getChunk(Resolver::res_t &VAR_0, vector<DNSRecord>* VAR_1) /* COMMENT_0 */\n{\n  if(VAR_2 > 1)\n    return false;\n\n  /* COMMENT_1 */\n  int VAR_3=getLength();\n  if(VAR_3<0)\n    throw ResolverException(\"EOF trying to read axfr chunk from remote TCP client\");\n\n  if (VAR_4 > 0 && (VAR_4 - VAR_5) < (size_t) VAR_3)\n    throw ResolverException(\"Reached the maximum number of received bytes during AXFR\");\n\n  timeoutReadn(VAR_3);\n\n  VAR_5 += (uint16_t) VAR_3;\n\n  MOADNSParser VAR_6(VAR_7.get(), VAR_3);\n\n  int VAR_8;\n  if(!VAR_1)\n    VAR_8=parseResult(VAR_6, DNSName(), 0, 0, &VAR_0);\n  else {\n    VAR_1->clear();\n    for(const auto& VAR_9: VAR_6.d_answers)\n      VAR_1->push_back(VAR_9.first);\n    VAR_8 = VAR_6.d_header.rcode;\n  }\n  \n  if(VAR_8) \n    throw ResolverException(\"AXFR chunk error: \" + RCode::to_s(VAR_8));\n\n  for(const MOADNSParser::answers_t::value_type& VAR_10 :  VAR_6.d_answers)\n    if (VAR_10.first.d_type == QType::SOA)\n      VAR_2++;\n \n  if(!VAR_11.name.empty()) { /* COMMENT_2 */\n    /* COMMENT_3 */\n    /* COMMENT_4 */\n    VAR_12.append(VAR_7.get(), VAR_3);\n    if (VAR_6.getTSIGPos() == 0)\n      VAR_13 += VAR_3;\n    else \n      VAR_13 += VAR_6.getTSIGPos();\n\n    string VAR_14;\n    bool VAR_15 = false;\n    \n    for(const MOADNSParser::answers_t::value_type& VAR_10 :  VAR_6.d_answers) {\n      if (VAR_10.first.d_type == QType::SOA)  /* COMMENT_5 */\n        VAR_15 = true;\n      \n      if(VAR_10.first.d_type == QType::TSIG) {\n        shared_ptr<TSIGRecordContent> VAR_16 = VAR_17<TSIGRecordContent>(VAR_10.first);\n        if(VAR_16) {\n          VAR_14 = VAR_16->d_mac;\n          VAR_18.d_time = VAR_16->d_time;\n          VAR_15 = true;\n        }\n      }\n    }\n\n    if( ! VAR_15 && VAR_19 > 99) { /* COMMENT_6 */\n      throw ResolverException(\"No TSIG message received in last 100 messages of AXFR transfer.\");\n    }\n\n    if (VAR_15) {\n      if (VAR_14.empty())\n        throw ResolverException(\"No TSIG on AXFR response from \"+VAR_20.toStringWithPort()+\" , should be signed with TSIG key '\"+VAR_11.name.toString()+\"'\");\n\n      string VAR_21;\n      if (!VAR_22.empty()) {\n        VAR_21 = makeTSIGMessageFromTSIGPacket(VAR_12, VAR_13, VAR_11.name, VAR_18, VAR_22, true, VAR_12.size()-VAR_3);\n      } else {\n        VAR_21 = makeTSIGMessageFromTSIGPacket(VAR_12, VAR_13, VAR_11.name, VAR_18, VAR_18.d_mac, false);\n      }\n\n      TSIGHashEnum VAR_23;\n      if (!getTSIGHashEnum(VAR_18.d_algoName, VAR_23)) {\n        throw ResolverException(\"Unsupported TSIG HMAC algorithm \" + VAR_18.d_algoName.toString());\n      }\n\n      if (VAR_23 == VAR_24) {\n        GssContext VAR_25(VAR_11.name);\n        if (!gss_verify_signature(VAR_11.name, VAR_21, VAR_14)) {\n          throw ResolverException(\"Signature failed to validate on AXFR response from \"+VAR_20.toStringWithPort()+\" signed with TSIG key '\"+VAR_11.name.toString()+\"'\");\n        }\n      } else {\n        string VAR_26=calculateHMAC(VAR_11.secret, VAR_21, VAR_23);\n\n        /* COMMENT_7 */\n        if(VAR_26 != VAR_14) {\n          throw ResolverException(\"Signature failed to validate on AXFR response from \"+VAR_20.toStringWithPort()+\" signed with TSIG key '\"+VAR_11.name.toString()+\"'\");\n        }\n      }\n\n      /* COMMENT_8 */\n      VAR_22 = VAR_14;\n      VAR_19 = 0;\n      VAR_12.clear();\n      VAR_13 = 0;\n    }\n    else\n      VAR_19++;\n  }\n  \n  return true;\n}",
  "func_graph_path": "PowerDNS/pdns/db8f9152168acf5d548d4f256789eae783e01667/resolver.cc/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -7,8 +7,14 @@\n   int len=getLength();\n   if(len<0)\n     throw ResolverException(\"EOF trying to read axfr chunk from remote TCP client\");\n-  \n-  timeoutReadn(len); \n+\n+  if (d_maxReceivedBytes > 0 && (d_maxReceivedBytes - d_receivedBytes) < (size_t) len)\n+    throw ResolverException(\"Reached the maximum number of received bytes during AXFR\");\n+\n+  timeoutReadn(len);\n+\n+  d_receivedBytes += (uint16_t) len;\n+\n   MOADNSParser mdp(d_buf.get(), len);\n \n   int err;",
  "diff_line_info": {
    "deleted_lines": [
      "  ",
      "  timeoutReadn(len); "
    ],
    "added_lines": [
      "",
      "  if (d_maxReceivedBytes > 0 && (d_maxReceivedBytes - d_receivedBytes) < (size_t) len)",
      "    throw ResolverException(\"Reached the maximum number of received bytes during AXFR\");",
      "",
      "  timeoutReadn(len);",
      "",
      "  d_receivedBytes += (uint16_t) len;",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/PowerDNS/pdns/pull/4133",
  "description": {
    "pr_info": {
      "title": "Add limits to the size of received {A,I}XFR, in megabytes",
      "number": 4133
    },
    "comment": [
      "This prevents memory exhaustion in case the master is sending a\nvery large amount of data in an update.\n",
      "LGTM from a quick glance.\n",
      "Fixes #4128 for master.\n",
      "This is ready for merge if you ask me.\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}