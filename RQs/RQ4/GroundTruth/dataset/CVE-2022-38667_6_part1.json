{
  "cve_id": "CVE-2022-38667",
  "cwe_ids": [
    "CWE-416"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "CrowCpp/Crow",
  "commit_msg": "Prevent HTTP pipelining which Crow doesn't support.",
  "commit_hash": "fba01dc76d6ea940ad7c8392e8f39f9647241d8e",
  "git_url": "https://github.com/CrowCpp/Crow/commit/fba01dc76d6ea940ad7c8392e8f39f9647241d8e",
  "file_path": "include/crow/http_connection.h",
  "func_name": "do_write_static",
  "func_before": "void do_write_static()\n        {\n            is_writing = true;\n            asio::write(adaptor_.socket(), buffers_);\n\n            if (res.file_info.statResult == 0)\n            {\n                std::ifstream is(res.file_info.path.c_str(), std::ios::in | std::ios::binary);\n                char buf[16384];\n                while (is.read(buf, sizeof(buf)).gcount() > 0)\n                {\n                    std::vector<asio::const_buffer> buffers;\n                    buffers.push_back(asio::buffer(buf));\n                    do_write_sync(buffers);\n                }\n            }\n            is_writing = false;\n            if (close_connection_)\n            {\n                adaptor_.shutdown_readwrite();\n                adaptor_.close();\n                CROW_LOG_DEBUG << this << \" from write (static)\";\n                check_destroy();\n            }\n\n            res.end();\n            res.clear();\n            buffers_.clear();\n        }",
  "abstract_func_before": "void do_write_static()\n        {\n            VAR_0 = true;\n            asio::write(VAR_1.socket(), VAR_2);\n\n            if (VAR_3.file_info.statResult == 0)\n            {\n                std::ifstream VAR_4(VAR_3.file_info.path.c_str(), std::ios::in | std::ios::binary);\n                char VAR_5[16384];\n                while (VAR_4.read(VAR_5, sizeof(VAR_5)).gcount() > 0)\n                {\n                    std::vector<asio::const_buffer> VAR_6;\n                    VAR_6.push_back(asio::buffer(VAR_5));\n                    do_write_sync(VAR_6);\n                }\n            }\n            VAR_0 = false;\n            if (VAR_7)\n            {\n                VAR_1.shutdown_readwrite();\n                VAR_1.close();\n                VAR_8 << this << \" from write (static)\";\n                check_destroy();\n            }\n\n            VAR_3.end();\n            VAR_3.clear();\n            VAR_2.clear();\n        }",
  "func_graph_path_before": "CrowCpp/Crow/fba01dc76d6ea940ad7c8392e8f39f9647241d8e/http_connection.h/vul/before/2.json",
  "func": "void do_write_static()\n        {\n            is_writing = true;\n            asio::write(adaptor_.socket(), buffers_);\n\n            if (res.file_info.statResult == 0)\n            {\n                std::ifstream is(res.file_info.path.c_str(), std::ios::in | std::ios::binary);\n                char buf[16384];\n                while (is.read(buf, sizeof(buf)).gcount() > 0)\n                {\n                    std::vector<asio::const_buffer> buffers;\n                    buffers.push_back(asio::buffer(buf));\n                    do_write_sync(buffers);\n                }\n            }\n            is_writing = false;\n            if (close_connection_)\n            {\n                adaptor_.shutdown_readwrite();\n                adaptor_.close();\n                CROW_LOG_DEBUG << this << \" from write (static)\";\n                check_destroy();\n            }\n\n            res.end();\n            res.clear();\n            buffers_.clear();\n            parser_.clear();\n        }",
  "abstract_func": "void do_write_static()\n        {\n            VAR_0 = true;\n            asio::write(VAR_1.socket(), VAR_2);\n\n            if (VAR_3.file_info.statResult == 0)\n            {\n                std::ifstream VAR_4(VAR_3.file_info.path.c_str(), std::ios::in | std::ios::binary);\n                char VAR_5[16384];\n                while (VAR_4.read(VAR_5, sizeof(VAR_5)).gcount() > 0)\n                {\n                    std::vector<asio::const_buffer> VAR_6;\n                    VAR_6.push_back(asio::buffer(VAR_5));\n                    do_write_sync(VAR_6);\n                }\n            }\n            VAR_0 = false;\n            if (VAR_7)\n            {\n                VAR_1.shutdown_readwrite();\n                VAR_1.close();\n                VAR_8 << this << \" from write (static)\";\n                check_destroy();\n            }\n\n            VAR_3.end();\n            VAR_3.clear();\n            VAR_2.clear();\n            VAR_9.clear();\n        }",
  "func_graph_path": "CrowCpp/Crow/fba01dc76d6ea940ad7c8392e8f39f9647241d8e/http_connection.h/vul/after/2.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -26,4 +26,5 @@\n             res.end();\n             res.clear();\n             buffers_.clear();\n+            parser_.clear();\n         }",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "            parser_.clear();"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/CrowCpp/Crow/pull/524",
  "description": {
    "pr_info": {
      "title": "Prevent HTTP pipelining",
      "number": 524
    },
    "comment": [
      "Fixes a potential use-after-free vulnerability where using HTTP pipelining could cause Crow to execute code related to a connection after deleting it.\r\n\r\nIt also fixes a small bug where websocket connections could be established with invalid HTTP requests (ones that don't have a `Host` header)\r\n\r\nThanks to hebi Gynvael Coldwind for discovering and reporting the vulnerability."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95"
}