{
  "cve_id": "CVE-2022-24754",
  "cwe_ids": [
    "CWE-120"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "pjsip/pjproject",
  "commit_msg": "Use PJ_ASSERT_RETURN() on pjsip_auth_create_digest() and pjsua_init_tpselector() (#3009)\n\n* Use PJ_ASSERT_RETURN on pjsip_auth_create_digest\r\n\r\n* Use PJ_ASSERT_RETURN on pjsua_init_tpselector()\r\n\r\n* Fix incorrect check.\r\n\r\n* Add return value to pjsip_auth_create_digest() and pjsip_auth_create_digestSHA256()\r\n\r\n* Modification based on comments.",
  "commit_hash": "d27f79da11df7bc8bb56c2f291d71e54df8d2c47",
  "git_url": "https://github.com/pjsip/pjproject/commit/d27f79da11df7bc8bb56c2f291d71e54df8d2c47",
  "file_path": "pjsip/src/pjsip/sip_auth_client.c",
  "func_name": "respond_digest",
  "func_before": "static pj_status_t respond_digest( pj_pool_t *pool,\n\t\t\t\t   pjsip_digest_credential *cred,\n\t\t\t\t   const pjsip_digest_challenge *chal,\n\t\t\t\t   const pj_str_t *uri,\n\t\t\t\t   const pjsip_cred_info *cred_info,\n\t\t\t\t   const pj_str_t *cnonce,\n\t\t\t\t   pj_uint32_t nc,\n\t\t\t\t   const pj_str_t *method)\n{\n    const pj_str_t pjsip_AKAv1_MD5_STR = { \"AKAv1-MD5\", 9 };\n    pj_bool_t algo_sha256 = PJ_FALSE;\n\n    /* Check if algo is sha256 */\n#if PJSIP_AUTH_HAS_DIGEST_SHA256\n    algo_sha256 = (pj_stricmp(&chal->algorithm, &pjsip_SHA256_STR)==0);\n#endif\n\n    /* Check algorithm is supported. We support MD5, AKAv1-MD5, and SHA256. */\n    if (chal->algorithm.slen==0 ||\n        (algo_sha256 ||\n\t pj_stricmp(&chal->algorithm, &pjsip_MD5_STR)==0 ||\n         pj_stricmp(&chal->algorithm, &pjsip_AKAv1_MD5_STR)==0))\n    {\n\tPJ_LOG(4,(THIS_FILE, \"Digest algorithm is \\\"%.*s\\\"\",\n\t\t  chal->algorithm.slen, chal->algorithm.ptr));\n    }\n    else {\n\tPJ_LOG(4,(THIS_FILE, \"Unsupported digest algorithm \\\"%.*s\\\"\",\n\t\t  chal->algorithm.slen, chal->algorithm.ptr));\n\treturn PJSIP_EINVALIDALGORITHM;\n    }\n\n    /* Build digest credential from arguments. */\n    pj_strdup(pool, &cred->username, &cred_info->username);\n    pj_strdup(pool, &cred->realm, &chal->realm);\n    pj_strdup(pool, &cred->nonce, &chal->nonce);\n    pj_strdup(pool, &cred->uri, uri);\n    pj_strdup(pool, &cred->algorithm, &chal->algorithm);\n    pj_strdup(pool, &cred->opaque, &chal->opaque);\n\n    /* Allocate memory. */\n    cred->response.slen = algo_sha256? PJSIP_SHA256STRLEN : PJSIP_MD5STRLEN;\n    cred->response.ptr = (char*) pj_pool_alloc(pool, cred->response.slen);\n\n    if (chal->qop.slen == 0) {\n\t/* Server doesn't require quality of protection. */\n\n\tif ((cred_info->data_type & EXT_MASK) == PJSIP_CRED_DATA_EXT_AKA) {\n\t    /* Call application callback to create the response digest */\n\t    return (*cred_info->ext.aka.cb)(pool, chal, cred_info,\n\t\t\t\t\t    method, cred);\n\t}\n\telse {\n\t    /* Convert digest to string and store in chal->response. */\n\t    if (algo_sha256) {\n\t\tpjsip_auth_create_digestSHA256(\n\t\t\t\t\t  &cred->response, &cred->nonce, NULL,\n\t\t\t\t\t  NULL,  NULL, uri, &chal->realm,\n\t\t\t\t\t  cred_info, method);\n\t    } else {\n\t\tpjsip_auth_create_digest( &cred->response, &cred->nonce, NULL,\n\t\t\t\t\t  NULL,  NULL, uri, &chal->realm,\n\t\t\t\t\t  cred_info, method);\n\t    }\n\t}\n\n    } else if (has_auth_qop(pool, &chal->qop)) {\n\t/* Server requires quality of protection.\n\t * We respond with selecting \"qop=auth\" protection.\n\t */\n\tcred->qop = pjsip_AUTH_STR;\n\tcred->nc.ptr = (char*) pj_pool_alloc(pool, 16);\n\tcred->nc.slen = pj_ansi_snprintf(cred->nc.ptr, 16, \"%08u\", nc);\n\n\tif (cnonce && cnonce->slen) {\n\t    pj_strdup(pool, &cred->cnonce, cnonce);\n\t} else {\n\t    pj_str_t dummy_cnonce = { \"b39971\", 6};\n\t    pj_strdup(pool, &cred->cnonce, &dummy_cnonce);\n\t}\n\n\tif ((cred_info->data_type & EXT_MASK) == PJSIP_CRED_DATA_EXT_AKA) {\n\t    /* Call application callback to create the response digest */\n\t    return (*cred_info->ext.aka.cb)(pool, chal, cred_info,\n\t\t\t\t\t    method, cred);\n\t}\n\telse {\n\t    /* Convert digest to string and store in chal->response. */\n\t    if (algo_sha256) {\n\t\tpjsip_auth_create_digestSHA256(\n\t\t\t\t\t  &cred->response, &cred->nonce,\n\t\t\t\t\t  &cred->nc, &cred->cnonce,\n\t\t\t\t\t  &pjsip_AUTH_STR, uri,\n\t\t\t\t\t  &chal->realm, cred_info,\n\t\t\t\t\t  method);\n\t    } else {\n\t\tpjsip_auth_create_digest( &cred->response, &cred->nonce,\n\t\t\t\t\t  &cred->nc, &cred->cnonce,\n\t\t\t\t\t  &pjsip_AUTH_STR, uri,\n\t\t\t\t\t  &chal->realm, cred_info,\n\t\t\t\t\t  method);\n\t    }\n\t}\n\n    } else {\n\t/* Server requires quality protection that we don't support. */\n\tPJ_LOG(4,(THIS_FILE, \"Unsupported qop offer %.*s\",\n\t\t  chal->qop.slen, chal->qop.ptr));\n\treturn PJSIP_EINVALIDQOP;\n    }\n\n    return PJ_SUCCESS;\n}",
  "abstract_func_before": "static pj_status_t respond_digest( pj_pool_t *VAR_0,\n\t\t\t\t   pjsip_digest_credential *VAR_1,\n\t\t\t\t   const pjsip_digest_challenge *VAR_2,\n\t\t\t\t   const pj_str_t *VAR_3,\n\t\t\t\t   const pjsip_cred_info *VAR_4,\n\t\t\t\t   const pj_str_t *VAR_5,\n\t\t\t\t   pj_uint32_t VAR_6,\n\t\t\t\t   const pj_str_t *VAR_7)\n{\n    const pj_str_t VAR_8 = { \"AKAv1-MD5\", 9 };\n    pj_bool_t VAR_9 = VAR_10;\n\n    /* COMMENT_0 */\n#if VAR_11\n    VAR_9 = (pj_stricmp(&VAR_2->algorithm, &VAR_12)==0);\n#endif\n\n    /* COMMENT_1 */\n    if (VAR_2->algorithm.slen==0 ||\n        (VAR_9 ||\n\t pj_stricmp(&VAR_2->algorithm, &VAR_13)==0 ||\n         pj_stricmp(&VAR_2->algorithm, &VAR_8)==0))\n    {\n\tPJ_LOG(4,(VAR_14, \"Digest algorithm is \\\"%.*s\\\"\",\n\t\t  VAR_2->algorithm.slen, VAR_2->algorithm.ptr));\n    }\n    else {\n\tPJ_LOG(4,(VAR_14, \"Unsupported digest algorithm \\\"%.*s\\\"\",\n\t\t  VAR_2->algorithm.slen, VAR_2->algorithm.ptr));\n\treturn VAR_15;\n    }\n\n    /* COMMENT_2 */\n    pj_strdup(VAR_0, &VAR_1->username, &VAR_4->username);\n    pj_strdup(VAR_0, &VAR_1->realm, &VAR_2->realm);\n    pj_strdup(VAR_0, &VAR_1->nonce, &VAR_2->nonce);\n    pj_strdup(VAR_0, &VAR_1->uri, VAR_3);\n    pj_strdup(VAR_0, &VAR_1->algorithm, &VAR_2->algorithm);\n    pj_strdup(VAR_0, &VAR_1->opaque, &VAR_2->opaque);\n\n    /* COMMENT_3 */\n    VAR_1->response.slen = VAR_9? VAR_16 : VAR_17;\n    VAR_1->response.ptr = (char*) pj_pool_alloc(VAR_0, VAR_1->response.slen);\n\n    if (VAR_2->qop.slen == 0) {\n\t/* COMMENT_4 */\n\n\tif ((VAR_4->data_type & VAR_18) == VAR_19) {\n\t    /* COMMENT_5 */\n\t    return (*VAR_4->ext.aka.cb)(VAR_0, VAR_2, VAR_4,\n\t\t\t\t\t    VAR_7, VAR_1);\n\t}\n\telse {\n\t    /* COMMENT_6 */\n\t    if (VAR_9) {\n\t\tpjsip_auth_create_digestSHA256(\n\t\t\t\t\t  &VAR_1->response, &VAR_1->nonce, NULL,\n\t\t\t\t\t  NULL,  NULL, VAR_3, &VAR_2->realm,\n\t\t\t\t\t  VAR_4, VAR_7);\n\t    } else {\n\t\tpjsip_auth_create_digest( &VAR_1->response, &VAR_1->nonce, NULL,\n\t\t\t\t\t  NULL,  NULL, VAR_3, &VAR_2->realm,\n\t\t\t\t\t  VAR_4, VAR_7);\n\t    }\n\t}\n\n    } else if (has_auth_qop(VAR_0, &VAR_2->qop)) {\n\t/* COMMENT_7 */\n                                                    \n    \n\tVAR_1->qop = VAR_20;\n\tVAR_1->nc.ptr = (char*) pj_pool_alloc(VAR_0, 16);\n\tVAR_1->nc.slen = pj_ansi_snprintf(VAR_1->nc.ptr, 16, \"%08u\", VAR_6);\n\n\tif (VAR_5 && VAR_5->slen) {\n\t    pj_strdup(VAR_0, &VAR_1->cnonce, VAR_5);\n\t} else {\n\t    pj_str_t VAR_21 = { \"b39971\", 6};\n\t    pj_strdup(VAR_0, &VAR_1->cnonce, &VAR_21);\n\t}\n\n\tif ((VAR_4->data_type & VAR_18) == VAR_19) {\n\t    /* COMMENT_5 */\n\t    return (*VAR_4->ext.aka.cb)(VAR_0, VAR_2, VAR_4,\n\t\t\t\t\t    VAR_7, VAR_1);\n\t}\n\telse {\n\t    /* COMMENT_6 */\n\t    if (VAR_9) {\n\t\tpjsip_auth_create_digestSHA256(\n\t\t\t\t\t  &VAR_1->response, &VAR_1->nonce,\n\t\t\t\t\t  &VAR_1->nc, &VAR_1->cnonce,\n\t\t\t\t\t  &VAR_20, VAR_3,\n\t\t\t\t\t  &VAR_2->realm, VAR_4,\n\t\t\t\t\t  VAR_7);\n\t    } else {\n\t\tpjsip_auth_create_digest( &VAR_1->response, &VAR_1->nonce,\n\t\t\t\t\t  &VAR_1->nc, &VAR_1->cnonce,\n\t\t\t\t\t  &VAR_20, VAR_3,\n\t\t\t\t\t  &VAR_2->realm, VAR_4,\n\t\t\t\t\t  VAR_7);\n\t    }\n\t}\n\n    } else {\n\t/* COMMENT_10 */\n\tPJ_LOG(4,(VAR_14, \"Unsupported qop offer %.*s\",\n\t\t  VAR_2->qop.slen, VAR_2->qop.ptr));\n\treturn VAR_22;\n    }\n\n    return VAR_23;\n}",
  "func_graph_path_before": "pjsip/pjproject/d27f79da11df7bc8bb56c2f291d71e54df8d2c47/sip_auth_client.c/vul/before/2.json",
  "func": "static pj_status_t respond_digest( pj_pool_t *pool,\n\t\t\t\t   pjsip_digest_credential *cred,\n\t\t\t\t   const pjsip_digest_challenge *chal,\n\t\t\t\t   const pj_str_t *uri,\n\t\t\t\t   const pjsip_cred_info *cred_info,\n\t\t\t\t   const pj_str_t *cnonce,\n\t\t\t\t   pj_uint32_t nc,\n\t\t\t\t   const pj_str_t *method)\n{\n    const pj_str_t pjsip_AKAv1_MD5_STR = { \"AKAv1-MD5\", 9 };\n    pj_bool_t algo_sha256 = PJ_FALSE;\n    pj_status_t status = PJ_SUCCESS;\n\n    /* Check if algo is sha256 */\n#if PJSIP_AUTH_HAS_DIGEST_SHA256\n    algo_sha256 = (pj_stricmp(&chal->algorithm, &pjsip_SHA256_STR)==0);\n#endif\n\n    /* Check algorithm is supported. We support MD5, AKAv1-MD5, and SHA256. */\n    if (chal->algorithm.slen==0 ||\n        (algo_sha256 ||\n\t pj_stricmp(&chal->algorithm, &pjsip_MD5_STR)==0 ||\n         pj_stricmp(&chal->algorithm, &pjsip_AKAv1_MD5_STR)==0))\n    {\n\tPJ_LOG(4,(THIS_FILE, \"Digest algorithm is \\\"%.*s\\\"\",\n\t\t  chal->algorithm.slen, chal->algorithm.ptr));\n    }\n    else {\n\tPJ_LOG(4,(THIS_FILE, \"Unsupported digest algorithm \\\"%.*s\\\"\",\n\t\t  chal->algorithm.slen, chal->algorithm.ptr));\n\treturn PJSIP_EINVALIDALGORITHM;\n    }\n\n    /* Build digest credential from arguments. */\n    pj_strdup(pool, &cred->username, &cred_info->username);\n    pj_strdup(pool, &cred->realm, &chal->realm);\n    pj_strdup(pool, &cred->nonce, &chal->nonce);\n    pj_strdup(pool, &cred->uri, uri);\n    pj_strdup(pool, &cred->algorithm, &chal->algorithm);\n    pj_strdup(pool, &cred->opaque, &chal->opaque);\n\n    /* Allocate memory. */\n    cred->response.slen = algo_sha256? PJSIP_SHA256STRLEN : PJSIP_MD5STRLEN;\n    cred->response.ptr = (char*) pj_pool_alloc(pool, cred->response.slen);\n\n    if (chal->qop.slen == 0) {\n\t/* Server doesn't require quality of protection. */\n\n\tif ((cred_info->data_type & EXT_MASK) == PJSIP_CRED_DATA_EXT_AKA) {\n\t    /* Call application callback to create the response digest */\n\t    return (*cred_info->ext.aka.cb)(pool, chal, cred_info,\n\t\t\t\t\t    method, cred);\n\t}\n\telse {\n\t    /* Convert digest to string and store in chal->response. */\n\t    if (algo_sha256) {\n\t\tstatus = pjsip_auth_create_digestSHA256(\n\t\t\t\t\t  &cred->response, &cred->nonce, NULL,\n\t\t\t\t\t  NULL,  NULL, uri, &chal->realm,\n\t\t\t\t\t  cred_info, method);\n\t    } else {\n\t\tstatus = pjsip_auth_create_digest( &cred->response, \n\t\t\t\t\t  &cred->nonce, NULL, NULL, NULL, uri, \n\t\t\t\t\t  &chal->realm, cred_info, method);\n\t    }\n\t}\n\n    } else if (has_auth_qop(pool, &chal->qop)) {\n\t/* Server requires quality of protection.\n\t * We respond with selecting \"qop=auth\" protection.\n\t */\n\tcred->qop = pjsip_AUTH_STR;\n\tcred->nc.ptr = (char*) pj_pool_alloc(pool, 16);\n\tcred->nc.slen = pj_ansi_snprintf(cred->nc.ptr, 16, \"%08u\", nc);\n\n\tif (cnonce && cnonce->slen) {\n\t    pj_strdup(pool, &cred->cnonce, cnonce);\n\t} else {\n\t    pj_str_t dummy_cnonce = { \"b39971\", 6};\n\t    pj_strdup(pool, &cred->cnonce, &dummy_cnonce);\n\t}\n\n\tif ((cred_info->data_type & EXT_MASK) == PJSIP_CRED_DATA_EXT_AKA) {\n\t    /* Call application callback to create the response digest */\n\t    return (*cred_info->ext.aka.cb)(pool, chal, cred_info,\n\t\t\t\t\t    method, cred);\n\t}\n\telse {\n\t    /* Convert digest to string and store in chal->response. */\n\t    if (algo_sha256) {\n\t\tstatus = pjsip_auth_create_digestSHA256(\n\t\t\t\t\t  &cred->response, &cred->nonce,\n\t\t\t\t\t  &cred->nc, &cred->cnonce,\n\t\t\t\t\t  &pjsip_AUTH_STR, uri,\n\t\t\t\t\t  &chal->realm, cred_info,\n\t\t\t\t\t  method);\n\t    } else {\n\t\tstatus = pjsip_auth_create_digest( &cred->response, \n\t\t\t\t\t  &cred->nonce, &cred->nc, \n\t\t\t\t          &cred->cnonce, &pjsip_AUTH_STR, \n\t\t\t\t\t  uri, &chal->realm, \n\t\t\t\t\t  cred_info, method);\n\t    }\n\t}\n\n    } else {\n\t/* Server requires quality protection that we don't support. */\n\tPJ_LOG(4,(THIS_FILE, \"Unsupported qop offer %.*s\",\n\t\t  chal->qop.slen, chal->qop.ptr));\n\treturn PJSIP_EINVALIDQOP;\n    }\n\n    return status;\n}",
  "abstract_func": "static pj_status_t respond_digest( pj_pool_t *VAR_0,\n\t\t\t\t   pjsip_digest_credential *VAR_1,\n\t\t\t\t   const pjsip_digest_challenge *VAR_2,\n\t\t\t\t   const pj_str_t *VAR_3,\n\t\t\t\t   const pjsip_cred_info *VAR_4,\n\t\t\t\t   const pj_str_t *VAR_5,\n\t\t\t\t   pj_uint32_t VAR_6,\n\t\t\t\t   const pj_str_t *VAR_7)\n{\n    const pj_str_t VAR_8 = { \"AKAv1-MD5\", 9 };\n    pj_bool_t VAR_9 = VAR_10;\n    pj_status_t VAR_11 = VAR_12;\n\n    /* COMMENT_0 */\n#if VAR_13\n    VAR_9 = (pj_stricmp(&VAR_2->algorithm, &VAR_14)==0);\n#endif\n\n    /* COMMENT_1 */\n    if (VAR_2->algorithm.slen==0 ||\n        (VAR_9 ||\n\t pj_stricmp(&VAR_2->algorithm, &VAR_15)==0 ||\n         pj_stricmp(&VAR_2->algorithm, &VAR_8)==0))\n    {\n\tPJ_LOG(4,(VAR_16, \"Digest algorithm is \\\"%.*s\\\"\",\n\t\t  VAR_2->algorithm.slen, VAR_2->algorithm.ptr));\n    }\n    else {\n\tPJ_LOG(4,(VAR_16, \"Unsupported digest algorithm \\\"%.*s\\\"\",\n\t\t  VAR_2->algorithm.slen, VAR_2->algorithm.ptr));\n\treturn VAR_17;\n    }\n\n    /* COMMENT_2 */\n    pj_strdup(VAR_0, &VAR_1->username, &VAR_4->username);\n    pj_strdup(VAR_0, &VAR_1->realm, &VAR_2->realm);\n    pj_strdup(VAR_0, &VAR_1->nonce, &VAR_2->nonce);\n    pj_strdup(VAR_0, &VAR_1->uri, VAR_3);\n    pj_strdup(VAR_0, &VAR_1->algorithm, &VAR_2->algorithm);\n    pj_strdup(VAR_0, &VAR_1->opaque, &VAR_2->opaque);\n\n    /* COMMENT_3 */\n    VAR_1->response.slen = VAR_9? VAR_18 : VAR_19;\n    VAR_1->response.ptr = (char*) pj_pool_alloc(VAR_0, VAR_1->response.slen);\n\n    if (VAR_2->qop.slen == 0) {\n\t/* COMMENT_4 */\n\n\tif ((VAR_4->data_type & VAR_20) == VAR_21) {\n\t    /* COMMENT_5 */\n\t    return (*VAR_4->ext.aka.cb)(VAR_0, VAR_2, VAR_4,\n\t\t\t\t\t    VAR_7, VAR_1);\n\t}\n\telse {\n\t    /* COMMENT_6 */\n\t    if (VAR_9) {\n\t\tVAR_11 = pjsip_auth_create_digestSHA256(\n\t\t\t\t\t  &VAR_1->response, &VAR_1->nonce, NULL,\n\t\t\t\t\t  NULL,  NULL, VAR_3, &VAR_2->realm,\n\t\t\t\t\t  VAR_4, VAR_7);\n\t    } else {\n\t\tVAR_11 = pjsip_auth_create_digest( &VAR_1->response, \n\t\t\t\t\t  &VAR_1->nonce, NULL, NULL, NULL, VAR_3, \n\t\t\t\t\t  &VAR_2->realm, VAR_4, VAR_7);\n\t    }\n\t}\n\n    } else if (has_auth_qop(VAR_0, &VAR_2->qop)) {\n\t/* COMMENT_7 */\n                                                    \n    \n\tVAR_1->qop = VAR_22;\n\tVAR_1->nc.ptr = (char*) pj_pool_alloc(VAR_0, 16);\n\tVAR_1->nc.slen = pj_ansi_snprintf(VAR_1->nc.ptr, 16, \"%08u\", VAR_6);\n\n\tif (VAR_5 && VAR_5->slen) {\n\t    pj_strdup(VAR_0, &VAR_1->cnonce, VAR_5);\n\t} else {\n\t    pj_str_t VAR_23 = { \"b39971\", 6};\n\t    pj_strdup(VAR_0, &VAR_1->cnonce, &VAR_23);\n\t}\n\n\tif ((VAR_4->data_type & VAR_20) == VAR_21) {\n\t    /* COMMENT_5 */\n\t    return (*VAR_4->ext.aka.cb)(VAR_0, VAR_2, VAR_4,\n\t\t\t\t\t    VAR_7, VAR_1);\n\t}\n\telse {\n\t    /* COMMENT_6 */\n\t    if (VAR_9) {\n\t\tVAR_11 = pjsip_auth_create_digestSHA256(\n\t\t\t\t\t  &VAR_1->response, &VAR_1->nonce,\n\t\t\t\t\t  &VAR_1->nc, &VAR_1->cnonce,\n\t\t\t\t\t  &VAR_22, VAR_3,\n\t\t\t\t\t  &VAR_2->realm, VAR_4,\n\t\t\t\t\t  VAR_7);\n\t    } else {\n\t\tVAR_11 = pjsip_auth_create_digest( &VAR_1->response, \n\t\t\t\t\t  &VAR_1->nonce, &VAR_1->nc, \n\t\t\t\t          &VAR_1->cnonce, &VAR_22, \n\t\t\t\t\t  VAR_3, &VAR_2->realm, \n\t\t\t\t\t  VAR_4, VAR_7);\n\t    }\n\t}\n\n    } else {\n\t/* COMMENT_10 */\n\tPJ_LOG(4,(VAR_16, \"Unsupported qop offer %.*s\",\n\t\t  VAR_2->qop.slen, VAR_2->qop.ptr));\n\treturn VAR_24;\n    }\n\n    return VAR_11;\n}",
  "func_graph_path": "pjsip/pjproject/d27f79da11df7bc8bb56c2f291d71e54df8d2c47/sip_auth_client.c/vul/after/2.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -9,6 +9,7 @@\n {\n     const pj_str_t pjsip_AKAv1_MD5_STR = { \"AKAv1-MD5\", 9 };\n     pj_bool_t algo_sha256 = PJ_FALSE;\n+    pj_status_t status = PJ_SUCCESS;\n \n     /* Check if algo is sha256 */\n #if PJSIP_AUTH_HAS_DIGEST_SHA256\n@@ -53,14 +54,14 @@\n \telse {\n \t    /* Convert digest to string and store in chal->response. */\n \t    if (algo_sha256) {\n-\t\tpjsip_auth_create_digestSHA256(\n+\t\tstatus = pjsip_auth_create_digestSHA256(\n \t\t\t\t\t  &cred->response, &cred->nonce, NULL,\n \t\t\t\t\t  NULL,  NULL, uri, &chal->realm,\n \t\t\t\t\t  cred_info, method);\n \t    } else {\n-\t\tpjsip_auth_create_digest( &cred->response, &cred->nonce, NULL,\n-\t\t\t\t\t  NULL,  NULL, uri, &chal->realm,\n-\t\t\t\t\t  cred_info, method);\n+\t\tstatus = pjsip_auth_create_digest( &cred->response, \n+\t\t\t\t\t  &cred->nonce, NULL, NULL, NULL, uri, \n+\t\t\t\t\t  &chal->realm, cred_info, method);\n \t    }\n \t}\n \n@@ -87,18 +88,18 @@\n \telse {\n \t    /* Convert digest to string and store in chal->response. */\n \t    if (algo_sha256) {\n-\t\tpjsip_auth_create_digestSHA256(\n+\t\tstatus = pjsip_auth_create_digestSHA256(\n \t\t\t\t\t  &cred->response, &cred->nonce,\n \t\t\t\t\t  &cred->nc, &cred->cnonce,\n \t\t\t\t\t  &pjsip_AUTH_STR, uri,\n \t\t\t\t\t  &chal->realm, cred_info,\n \t\t\t\t\t  method);\n \t    } else {\n-\t\tpjsip_auth_create_digest( &cred->response, &cred->nonce,\n-\t\t\t\t\t  &cred->nc, &cred->cnonce,\n-\t\t\t\t\t  &pjsip_AUTH_STR, uri,\n-\t\t\t\t\t  &chal->realm, cred_info,\n-\t\t\t\t\t  method);\n+\t\tstatus = pjsip_auth_create_digest( &cred->response, \n+\t\t\t\t\t  &cred->nonce, &cred->nc, \n+\t\t\t\t          &cred->cnonce, &pjsip_AUTH_STR, \n+\t\t\t\t\t  uri, &chal->realm, \n+\t\t\t\t\t  cred_info, method);\n \t    }\n \t}\n \n@@ -109,5 +110,5 @@\n \treturn PJSIP_EINVALIDQOP;\n     }\n \n-    return PJ_SUCCESS;\n+    return status;\n }",
  "diff_line_info": {
    "deleted_lines": [
      "\t\tpjsip_auth_create_digestSHA256(",
      "\t\tpjsip_auth_create_digest( &cred->response, &cred->nonce, NULL,",
      "\t\t\t\t\t  NULL,  NULL, uri, &chal->realm,",
      "\t\t\t\t\t  cred_info, method);",
      "\t\tpjsip_auth_create_digestSHA256(",
      "\t\tpjsip_auth_create_digest( &cred->response, &cred->nonce,",
      "\t\t\t\t\t  &cred->nc, &cred->cnonce,",
      "\t\t\t\t\t  &pjsip_AUTH_STR, uri,",
      "\t\t\t\t\t  &chal->realm, cred_info,",
      "\t\t\t\t\t  method);",
      "    return PJ_SUCCESS;"
    ],
    "added_lines": [
      "    pj_status_t status = PJ_SUCCESS;",
      "\t\tstatus = pjsip_auth_create_digestSHA256(",
      "\t\tstatus = pjsip_auth_create_digest( &cred->response, ",
      "\t\t\t\t\t  &cred->nonce, NULL, NULL, NULL, uri, ",
      "\t\t\t\t\t  &chal->realm, cred_info, method);",
      "\t\tstatus = pjsip_auth_create_digestSHA256(",
      "\t\tstatus = pjsip_auth_create_digest( &cred->response, ",
      "\t\t\t\t\t  &cred->nonce, &cred->nc, ",
      "\t\t\t\t          &cred->cnonce, &pjsip_AUTH_STR, ",
      "\t\t\t\t\t  uri, &chal->realm, ",
      "\t\t\t\t\t  cred_info, method);",
      "    return status;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/pjsip/pjproject/pull/3009",
  "description": {
    "pr_info": {
      "title": "Check potential buffer overflow in `pjsip_auth_create_digest()`",
      "number": 3009
    },
    "comment": [
      "Related commit of https://github.com/pjsip/pjproject/commit/d27f79da11df7bc8bb56c2f291d71e54df8d2c47 of [GHSA-73f7-48m9-w662](https://github.com/pjsip/pjproject/security/advisories/GHSA-73f7-48m9-w662) : fix potential buffer overflow in `pjsip_auth_create_digest()`",
      "I'm having a hard time figuring out whether `pjsip_auth_create_digest` is part of the public API and therefore whether applying this patch would be API/ABI-breaking."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}