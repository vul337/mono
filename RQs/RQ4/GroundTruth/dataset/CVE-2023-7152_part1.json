{
  "cve_id": "CVE-2023-7152",
  "cwe_ids": [
    "CWE-416"
  ],
  "cvss_vector": "AV:A/AC:L/Au:S/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "micropython",
  "commit_msg": "extmod/modselect: Handle growing the pollfds allocation correctly.\n\nThe poll_obj_t instances have their pollfd field point into this\nallocation.  So if re-allocating results in a move, we need to update the\nexisting poll_obj_t's.\n\nUpdate the test to cover this case.\n\nFixes issue #12887.\n\nThis work was funded through GitHub Sponsors.\n\nSigned-off-by: Jim Mussared <jim.mussared@gmail.com>",
  "commit_hash": "8b24aa36ba978eafc6114b6798b47b7bfecdca26",
  "git_url": "https://github.com/micropython/micropython/commit/8b24aa36ba978eafc6114b6798b47b7bfecdca26",
  "file_path": "extmod/modselect.c",
  "func_name": "poll_set_add_fd",
  "func_before": "pollfd *poll_set_add_fd(poll_set_t *poll_set, int fd) {\n    struct pollfd *free_slot = NULL;\n\n    if (poll_set->used == poll_set->max_used) {\n        // No free slots below max_used, so expand max_used (and possibly allocate).\n        if (poll_set->max_used >= poll_set->alloc) {\n            poll_set->pollfds = m_renew(struct pollfd, poll_set->pollfds, poll_set->alloc, poll_set->alloc + 4);\n            poll_set->alloc += 4;\n        }\n        free_slot = &poll_set->pollfds[poll_set->max_used++];\n    } else {\n        // There should be a free slot below max_used.\n        for (unsigned int i = 0; i < poll_set->max_used; ++i) {\n            struct pollfd *slot = &poll_set->pollfds[i];\n            if (slot->fd == -1) {\n                free_slot = slot;\n                break;\n            }\n        }\n        assert(free_slot != NULL);\n    }\n\n    free_slot->fd = fd;\n    ++poll_set->used;\n\n    return free_slot;\n}",
  "abstract_func_before": "pollfd *poll_set_add_fd(poll_set_t *VAR_0, int VAR_1) {\n    struct pollfd *VAR_2 = NULL;\n\n    if (VAR_0->used == VAR_0->max_used) {\n        /* COMMENT_0 */\n        if (VAR_0->max_used >= VAR_0->alloc) {\n            VAR_0->pollfds = m_renew(struct pollfd, VAR_0->pollfds, VAR_0->alloc, VAR_0->alloc + 4);\n            VAR_0->alloc += 4;\n        }\n        VAR_2 = &VAR_0->pollfds[VAR_0->max_used++];\n    } else {\n        /* COMMENT_1 */\n        for (unsigned int VAR_3 = 0; VAR_3 < VAR_0->max_used; ++VAR_3) {\n            struct pollfd *VAR_4 = &VAR_0->pollfds[VAR_3];\n            if (VAR_4->fd == -1) {\n                VAR_2 = VAR_4;\n                break;\n            }\n        }\n        assert(VAR_2 != NULL);\n    }\n\n    VAR_2->fd = VAR_1;\n    ++VAR_0->used;\n\n    return VAR_2;\n}",
  "func_graph_path_before": "micropython/8b24aa36ba978eafc6114b6798b47b7bfecdca26/modselect.c/vul/before/0.json",
  "func": "pollfd *poll_set_add_fd(poll_set_t *poll_set, int fd) {\n    struct pollfd *free_slot = NULL;\n\n    if (poll_set->used == poll_set->max_used) {\n        // No free slots below max_used, so expand max_used (and possibly allocate).\n        if (poll_set->max_used >= poll_set->alloc) {\n            size_t new_alloc = poll_set->alloc + POLL_SET_ALLOC_INCREMENT;\n            // Try to grow in-place.\n            struct pollfd *new_fds = m_renew_maybe(struct pollfd, poll_set->pollfds, poll_set->alloc, new_alloc, false);\n            if (!new_fds) {\n                // Failed to grow in-place. Do a new allocation and copy over the pollfd values.\n                new_fds = m_new(struct pollfd, new_alloc);\n                memcpy(new_fds, poll_set->pollfds, sizeof(struct pollfd) * poll_set->alloc);\n\n                // Update existing poll_obj_t to update their pollfd field to\n                // point to the same offset inside the new allocation.\n                for (mp_uint_t i = 0; i < poll_set->map.alloc; ++i) {\n                    if (!mp_map_slot_is_filled(&poll_set->map, i)) {\n                        continue;\n                    }\n\n                    poll_obj_t *poll_obj = MP_OBJ_TO_PTR(poll_set->map.table[i].value);\n                    if (!poll_obj) {\n                        // This is the one we're currently adding,\n                        // poll_set_add_obj doesn't assign elem->value until\n                        // afterwards.\n                        continue;\n                    }\n\n                    poll_obj->pollfd = new_fds + (poll_obj->pollfd - poll_set->pollfds);\n                }\n\n                // Delete the old allocation.\n                m_del(struct pollfd, poll_set->pollfds, poll_set->alloc);\n            }\n\n            poll_set->pollfds = new_fds;\n            poll_set->alloc = new_alloc;\n        }\n        free_slot = &poll_set->pollfds[poll_set->max_used++];\n    } else {\n        // There should be a free slot below max_used.\n        for (unsigned int i = 0; i < poll_set->max_used; ++i) {\n            struct pollfd *slot = &poll_set->pollfds[i];\n            if (slot->fd == -1) {\n                free_slot = slot;\n                break;\n            }\n        }\n        assert(free_slot != NULL);\n    }\n\n    free_slot->fd = fd;\n    ++poll_set->used;\n\n    return free_slot;\n}",
  "abstract_func": "pollfd *poll_set_add_fd(poll_set_t *VAR_0, int VAR_1) {\n    struct pollfd *VAR_2 = NULL;\n\n    if (VAR_0->used == VAR_0->max_used) {\n        /* COMMENT_0 */\n        if (VAR_0->max_used >= VAR_0->alloc) {\n            size_t VAR_3 = VAR_0->alloc + VAR_4;\n            /* COMMENT_1 */\n            struct pollfd *VAR_5 = m_renew_maybe(struct pollfd, VAR_0->pollfds, VAR_0->alloc, VAR_3, false);\n            if (!VAR_5) {\n                /* COMMENT_2 */\n                VAR_5 = m_new(struct pollfd, VAR_3);\n                memcpy(VAR_5, VAR_0->pollfds, sizeof(struct pollfd) * VAR_0->alloc);\n\n                /* COMMENT_3 */\n                /* COMMENT_4 */\n                for (mp_uint_t VAR_6 = 0; VAR_6 < VAR_0->map.alloc; ++VAR_6) {\n                    if (!mp_map_slot_is_filled(&VAR_0->map, VAR_6)) {\n                        continue;\n                    }\n\n                    poll_obj_t *VAR_7 = MP_OBJ_TO_PTR(VAR_0->map.table[VAR_6].value);\n                    if (!VAR_7) {\n                        /* COMMENT_5 */\n                        /* COMMENT_6 */\n                        /* COMMENT_7 */\n                        continue;\n                    }\n\n                    VAR_7->pollfd = VAR_5 + (VAR_7->pollfd - VAR_0->pollfds);\n                }\n\n                /* COMMENT_8 */\n                VAR_8(struct pollfd, VAR_0->pollfds, VAR_0->alloc);\n            }\n\n            VAR_0->pollfds = VAR_5;\n            VAR_0->alloc = VAR_3;\n        }\n        VAR_2 = &VAR_0->pollfds[VAR_0->max_used++];\n    } else {\n        /* COMMENT_9 */\n        for (unsigned int VAR_6 = 0; VAR_6 < VAR_0->max_used; ++VAR_6) {\n            struct pollfd *VAR_9 = &VAR_0->pollfds[VAR_6];\n            if (VAR_9->fd == -1) {\n                VAR_2 = VAR_9;\n                break;\n            }\n        }\n        assert(VAR_2 != NULL);\n    }\n\n    VAR_2->fd = VAR_1;\n    ++VAR_0->used;\n\n    return VAR_2;\n}",
  "func_graph_path": "micropython/8b24aa36ba978eafc6114b6798b47b7bfecdca26/modselect.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -4,8 +4,38 @@\n     if (poll_set->used == poll_set->max_used) {\n         // No free slots below max_used, so expand max_used (and possibly allocate).\n         if (poll_set->max_used >= poll_set->alloc) {\n-            poll_set->pollfds = m_renew(struct pollfd, poll_set->pollfds, poll_set->alloc, poll_set->alloc + 4);\n-            poll_set->alloc += 4;\n+            size_t new_alloc = poll_set->alloc + POLL_SET_ALLOC_INCREMENT;\n+            // Try to grow in-place.\n+            struct pollfd *new_fds = m_renew_maybe(struct pollfd, poll_set->pollfds, poll_set->alloc, new_alloc, false);\n+            if (!new_fds) {\n+                // Failed to grow in-place. Do a new allocation and copy over the pollfd values.\n+                new_fds = m_new(struct pollfd, new_alloc);\n+                memcpy(new_fds, poll_set->pollfds, sizeof(struct pollfd) * poll_set->alloc);\n+\n+                // Update existing poll_obj_t to update their pollfd field to\n+                // point to the same offset inside the new allocation.\n+                for (mp_uint_t i = 0; i < poll_set->map.alloc; ++i) {\n+                    if (!mp_map_slot_is_filled(&poll_set->map, i)) {\n+                        continue;\n+                    }\n+\n+                    poll_obj_t *poll_obj = MP_OBJ_TO_PTR(poll_set->map.table[i].value);\n+                    if (!poll_obj) {\n+                        // This is the one we're currently adding,\n+                        // poll_set_add_obj doesn't assign elem->value until\n+                        // afterwards.\n+                        continue;\n+                    }\n+\n+                    poll_obj->pollfd = new_fds + (poll_obj->pollfd - poll_set->pollfds);\n+                }\n+\n+                // Delete the old allocation.\n+                m_del(struct pollfd, poll_set->pollfds, poll_set->alloc);\n+            }\n+\n+            poll_set->pollfds = new_fds;\n+            poll_set->alloc = new_alloc;\n         }\n         free_slot = &poll_set->pollfds[poll_set->max_used++];\n     } else {",
  "diff_line_info": {
    "deleted_lines": [
      "            poll_set->pollfds = m_renew(struct pollfd, poll_set->pollfds, poll_set->alloc, poll_set->alloc + 4);",
      "            poll_set->alloc += 4;"
    ],
    "added_lines": [
      "            size_t new_alloc = poll_set->alloc + POLL_SET_ALLOC_INCREMENT;",
      "            // Try to grow in-place.",
      "            struct pollfd *new_fds = m_renew_maybe(struct pollfd, poll_set->pollfds, poll_set->alloc, new_alloc, false);",
      "            if (!new_fds) {",
      "                // Failed to grow in-place. Do a new allocation and copy over the pollfd values.",
      "                new_fds = m_new(struct pollfd, new_alloc);",
      "                memcpy(new_fds, poll_set->pollfds, sizeof(struct pollfd) * poll_set->alloc);",
      "",
      "                // Update existing poll_obj_t to update their pollfd field to",
      "                // point to the same offset inside the new allocation.",
      "                for (mp_uint_t i = 0; i < poll_set->map.alloc; ++i) {",
      "                    if (!mp_map_slot_is_filled(&poll_set->map, i)) {",
      "                        continue;",
      "                    }",
      "",
      "                    poll_obj_t *poll_obj = MP_OBJ_TO_PTR(poll_set->map.table[i].value);",
      "                    if (!poll_obj) {",
      "                        // This is the one we're currently adding,",
      "                        // poll_set_add_obj doesn't assign elem->value until",
      "                        // afterwards.",
      "                        continue;",
      "                    }",
      "",
      "                    poll_obj->pollfd = new_fds + (poll_obj->pollfd - poll_set->pollfds);",
      "                }",
      "",
      "                // Delete the old allocation.",
      "                m_del(struct pollfd, poll_set->pollfds, poll_set->alloc);",
      "            }",
      "",
      "            poll_set->pollfds = new_fds;",
      "            poll_set->alloc = new_alloc;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/micropython/micropython/pull/12895",
  "description": {
    "pr_info": {
      "title": "extmod/modselect: Handle growing the pollfds allocation correctly.",
      "number": 12895
    },
    "comment": [
      "Fixes https://github.com/micropython/micropython/issues/12887 -- thanks @junwha0511\r\n\r\n---\r\n\r\nThe poll_obj_t instances have their pollfd field point into this allocation. So if re-allocating results in a move, we need to update the existing poll_obj_t's.\r\n\r\nUpdate the test to cover this case.\r\n\r\nAlso, because the implementation allows unregistering but allows the pollfds allocation to be sparse (by setting the unregistered entries to fd=-1, in order to make the final poll call succeed, we need to ensure that max_used is below the system limit, even though only three entries are in-use.\r\n\r\n_This work was funded through GitHub Sponsors._",
      "Code size report:\n\n```\n   bare-arm:    +0 +0.000% \nminimal x86:    +0 +0.000% \n   unix x64:  +168 +0.021% standard\n      stm32:    +0 +0.000% PYBV10\n     mimxrt:    +0 +0.000% TEENSY40\n        rp2:    +0 +0.000% RPI_PICO\n       samd:    +0 +0.000% ADAFRUIT_ITSYBITSY_M4_EXPRESS\n\n```\n",
      "## [Codecov](https://app.codecov.io/gh/micropython/micropython/pull/12895?src=pr&el=h1&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=micropython) Report\nAll modified and coverable lines are covered by tests :white_check_mark:\n> Comparison is base [(`e9bcd49`)](https://app.codecov.io/gh/micropython/micropython/commit/e9bcd49b3ef7bcf69026c747411408061b3a46be?el=desc&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=micropython) 98.40% compared to head [(`a5bdd39`)](https://app.codecov.io/gh/micropython/micropython/pull/12895?src=pr&el=desc&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=micropython) 98.43%.\n\n> :exclamation: Current head a5bdd39 differs from pull request most recent head 74fd7b3. Consider uploading reports for the commit 74fd7b3 to get more accurate results\n\n\n<details><summary>Additional details and impacted files</summary>\n\n\n```diff\n@@            Coverage Diff             @@\n##           master   #12895      +/-   ##\n==========================================\n+ Coverage   98.40%   98.43%   +0.03%     \n==========================================\n  Files         159      158       -1     \n  Lines       21075    20991      -84     \n==========================================\n- Hits        20738    20663      -75     \n+ Misses        337      328       -9     \n```\n\n\n\n</details>\n\n[:umbrella: View full report in Codecov by Sentry](https://app.codecov.io/gh/micropython/micropython/pull/12895?src=pr&el=continue&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=micropython).   \n:loudspeaker: Have feedback on the report? [Share it here](https://about.codecov.io/codecov-pr-comment-feedback/?utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=micropython).\n"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.9  \nThe patch addresses a bug related to memory management during pollfds allocation, ensuring pointers are correctly updated. This is a non-security fix aimed at improving core functionality."
}