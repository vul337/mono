{
  "cve_id": "CVE-2018-18928",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "unicode-org/icu",
  "commit_msg": "ICU-20246 Fixing another integer overflow in number parsing.",
  "commit_hash": "53d8c8f3d181d87a6aa925b449b51c4a2c922a51",
  "git_url": "https://github.com/unicode-org/icu/commit/53d8c8f3d181d87a6aa925b449b51c4a2c922a51",
  "file_path": "icu4c/source/i18n/number_decimalquantity.cpp",
  "func_name": "DecimalQuantity::toScientificString",
  "func_before": "UnicodeString DecimalQuantity::toScientificString() const {\n    U_ASSERT(!isApproximate);\n    UnicodeString result;\n    if (isNegative()) {\n        result.append(u'-');\n    }\n    if (precision == 0) {\n        result.append(u\"0E+0\", -1);\n        return result;\n    }\n    // NOTE: It is not safe to add to lOptPos (aka maxInt) or subtract from\n    // rOptPos (aka -maxFrac) due to overflow.\n    int32_t upperPos = std::min(precision + scale, lOptPos) - scale - 1;\n    int32_t lowerPos = std::max(scale, rOptPos) - scale;\n    int32_t p = upperPos;\n    result.append(u'0' + getDigitPos(p));\n    if ((--p) >= lowerPos) {\n        result.append(u'.');\n        for (; p >= lowerPos; p--) {\n            result.append(u'0' + getDigitPos(p));\n        }\n    }\n    result.append(u'E');\n    int32_t _scale = upperPos + scale;\n    if (_scale < 0) {\n        _scale *= -1;\n        result.append(u'-');\n    } else {\n        result.append(u'+');\n    }\n    if (_scale == 0) {\n        result.append(u'0');\n    }\n    int32_t insertIndex = result.length();\n    while (_scale > 0) {\n        std::div_t res = std::div(_scale, 10);\n        result.insert(insertIndex, u'0' + res.rem);\n        _scale = res.quot;\n    }\n    return result;\n}",
  "abstract_func_before": "UnicodeString DecimalQuantity::toScientificString() const {\n    U_ASSERT(!VAR_0);\n    UnicodeString VAR_1;\n    if (isNegative()) {\n        VAR_1.append(u'-');\n    }\n    if (VAR_2 == 0) {\n        VAR_1.append(u\"0E+0\", -1);\n        return VAR_1;\n    }\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n    int32_t VAR_3 = std::min(VAR_2 + VAR_4, VAR_5) - VAR_4 - 1;\n    int32_t VAR_6 = std::max(VAR_4, VAR_7) - VAR_4;\n    int32_t VAR_8 = VAR_3;\n    VAR_1.append(u'0' + getDigitPos(VAR_8));\n    if ((--VAR_8) >= VAR_6) {\n        VAR_1.append(u'.');\n        for (; VAR_8 >= VAR_6; VAR_8--) {\n            VAR_1.append(u'0' + getDigitPos(VAR_8));\n        }\n    }\n    VAR_1.append(u'E');\n    int32_t VAR_9 = VAR_3 + VAR_4;\n    if (VAR_9 < 0) {\n        VAR_9 *= -1;\n        VAR_1.append(u'-');\n    } else {\n        VAR_1.append(u'+');\n    }\n    if (VAR_9 == 0) {\n        VAR_1.append(u'0');\n    }\n    int32_t VAR_10 = VAR_1.length();\n    while (VAR_9 > 0) {\n        std::div_t VAR_11 = std::div(VAR_9, 10);\n        VAR_1.insert(VAR_10, u'0' + VAR_11.rem);\n        VAR_9 = VAR_11.quot;\n    }\n    return VAR_1;\n}",
  "func_graph_path_before": "unicode-org/icu/53d8c8f3d181d87a6aa925b449b51c4a2c922a51/number_decimalquantity.cpp/vul/before/0.json",
  "func": "UnicodeString DecimalQuantity::toScientificString() const {\n    U_ASSERT(!isApproximate);\n    UnicodeString result;\n    if (isNegative()) {\n        result.append(u'-');\n    }\n    if (precision == 0) {\n        result.append(u\"0E+0\", -1);\n        return result;\n    }\n    // NOTE: It is not safe to add to lOptPos (aka maxInt) or subtract from\n    // rOptPos (aka -maxFrac) due to overflow.\n    int32_t upperPos = std::min(precision + scale, lOptPos) - scale - 1;\n    int32_t lowerPos = std::max(scale, rOptPos) - scale;\n    int32_t p = upperPos;\n    result.append(u'0' + getDigitPos(p));\n    if ((--p) >= lowerPos) {\n        result.append(u'.');\n        for (; p >= lowerPos; p--) {\n            result.append(u'0' + getDigitPos(p));\n        }\n    }\n    result.append(u'E');\n    int32_t _scale = upperPos + scale;\n    if (_scale == INT32_MIN) {\n        result.append({u\"-2147483648\", -1});\n        return result;\n    } else if (_scale < 0) {\n        _scale *= -1;\n        result.append(u'-');\n    } else {\n        result.append(u'+');\n    }\n    if (_scale == 0) {\n        result.append(u'0');\n    }\n    int32_t insertIndex = result.length();\n    while (_scale > 0) {\n        std::div_t res = std::div(_scale, 10);\n        result.insert(insertIndex, u'0' + res.rem);\n        _scale = res.quot;\n    }\n    return result;\n}",
  "abstract_func": "UnicodeString DecimalQuantity::toScientificString() const {\n    U_ASSERT(!VAR_0);\n    UnicodeString VAR_1;\n    if (isNegative()) {\n        VAR_1.append(u'-');\n    }\n    if (VAR_2 == 0) {\n        VAR_1.append(u\"0E+0\", -1);\n        return VAR_1;\n    }\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n    int32_t VAR_3 = std::min(VAR_2 + VAR_4, VAR_5) - VAR_4 - 1;\n    int32_t VAR_6 = std::max(VAR_4, VAR_7) - VAR_4;\n    int32_t VAR_8 = VAR_3;\n    VAR_1.append(u'0' + getDigitPos(VAR_8));\n    if ((--VAR_8) >= VAR_6) {\n        VAR_1.append(u'.');\n        for (; VAR_8 >= VAR_6; VAR_8--) {\n            VAR_1.append(u'0' + getDigitPos(VAR_8));\n        }\n    }\n    VAR_1.append(u'E');\n    int32_t VAR_9 = VAR_3 + VAR_4;\n    if (VAR_9 == VAR_10) {\n        VAR_1.append({u\"-2147483648\", -1});\n        return VAR_1;\n    } else if (VAR_9 < 0) {\n        VAR_9 *= -1;\n        VAR_1.append(u'-');\n    } else {\n        VAR_1.append(u'+');\n    }\n    if (VAR_9 == 0) {\n        VAR_1.append(u'0');\n    }\n    int32_t VAR_11 = VAR_1.length();\n    while (VAR_9 > 0) {\n        std::div_t VAR_12 = std::div(VAR_9, 10);\n        VAR_1.insert(VAR_11, u'0' + VAR_12.rem);\n        VAR_9 = VAR_12.quot;\n    }\n    return VAR_1;\n}",
  "func_graph_path": "unicode-org/icu/53d8c8f3d181d87a6aa925b449b51c4a2c922a51/number_decimalquantity.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -22,7 +22,10 @@\n     }\n     result.append(u'E');\n     int32_t _scale = upperPos + scale;\n-    if (_scale < 0) {\n+    if (_scale == INT32_MIN) {\n+        result.append({u\"-2147483648\", -1});\n+        return result;\n+    } else if (_scale < 0) {\n         _scale *= -1;\n         result.append(u'-');\n     } else {",
  "diff_line_info": {
    "deleted_lines": [
      "    if (_scale < 0) {"
    ],
    "added_lines": [
      "    if (_scale == INT32_MIN) {",
      "        result.append({u\"-2147483648\", -1});",
      "        return result;",
      "    } else if (_scale < 0) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/unicode-org/icu/pull/253",
  "description": {
    "pr_info": {
      "title": "ICU-20246 Fixing another integer overflow in number parsing.",
      "number": 253
    },
    "comment": [
      "<!--\r\nThank you for your pull request.\r\nPlease see http://site.icu-project.org/processes/contribute for general\r\ninformation on contributing to ICU.\r\n\r\nYou will be automatically asked to sign the contributors license before the PR is accepted.\r\n- sign: https://cla-assistant.io/unicode-org/icu\r\n- license: http://www.unicode.org/copyright.html#License\r\n-->\r\n\r\n##### Checklist\r\n\r\n- [x] Issue filed: https://unicode-org.atlassian.net/browse/ICU-20246\r\n- [x] Updated PR title and link in previous line to include Issue number\r\n- [ ] Issue accepted\r\n- [x] Tests included\r\n- [ ] Documentation is changed or added\r\n\r\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "The patch addresses an integer overflow issue during number parsing, which is a security concern. The code change specifically handles a case that could cause an underflow, preventing potential exploits.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}