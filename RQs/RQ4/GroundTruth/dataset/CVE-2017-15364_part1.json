{
  "cve_id": "CVE-2017-15364",
  "cwe_ids": [
    "CWE-415"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "evan/ccsv",
  "commit_msg": "proposed non elegant fix for double free vulnerability",
  "commit_hash": "24e0b9b94c44a15b23475e821366239d53764dbd",
  "git_url": "https://github.com/evan/ccsv/commit/24e0b9b94c44a15b23475e821366239d53764dbd",
  "file_path": "ext/ccsv.c",
  "func_name": "foreach",
  "func_before": "static VALUE foreach(int argc, VALUE* argv, VALUE self) {\n  char *DELIM=DEF_DELIM;\n  char *line = NULL;\n  char *line2 =NULL, *new_line=NULL;\n  size_t len = 0, len2=0, i, pairs_count;\n  char *token,*start,*nobackslash,*t2;\n  size_t idx,count,searchfield,flag,array_length,range_i;\n  long check;\n  int  was_read;\n  FILE *file;\n  ID min_method, max_method;\n  VALUE min_val, max_val;\n  VALUE tmp_value, rest_args, filename;\n  ID    array_length_method; /*----------------------------------------*/\n  struct pair_st pairs[MAX_INTERVALS];\n\n  VALUE ary;\n\n  rb_scan_args(argc,argv,\"1*\", &filename, &rest_args);\n\n/*  if (argc == 0) {  // there should only be 1 or 2 arguments\n    rb_raise(rb_eArgError, \"wrong number of arguments\");\n  }\n\n  file = fopen(StringValueCStr(argv[0]), \"r\");\n  if (file == NULL)\n    rb_raise(rb_eRuntimeError, \"File not found\");\n*/\n  file = fopen(StringValueCStr(filename), \"r\");\n  if(file==NULL){\n    rb_raise(rb_eRuntimeError, \"File not found\");\n  }\n\n  if (argc >1 ) { /* delimiter */\n    tmp_value=rb_ary_entry(rest_args,0);\n    DELIM=StringValueCStr(tmp_value);;\n  }\n\n  if (argc >2 ) { /* search index */\n    tmp_value=rb_ary_entry(rest_args,1);\n    searchfield=NUM2INT(tmp_value);\n  }\n  else{\n    searchfield=-1;\n  }\n\n  array_length_method=rb_funcall(rest_args,rb_intern(\"length\"), 0);\n  array_length=NUM2INT(array_length_method);\n\n  min_method = rb_intern(\"first\");\n  max_method = rb_intern(\"last\");\n  /*------------test_id    = rb_intern(\"class\");*/\n  range_i=0;\n  for(idx=2;idx<array_length;++idx){\n    min_val=rb_funcall(rb_ary_entry(rest_args,idx),rb_intern(\"length\"), 0);\n    len2=NUM2INT(min_val);\n    for(i=0;i<len2;++i){\n      VALUE e=rb_ary_entry(rb_ary_entry(rest_args,idx),i);\n      if(range_i>MAX_INTERVALS)\n        rb_raise(rb_eRuntimeError, \"Too much ranges passed\");\n      if(TYPE(e) == T_NIL){\n        pairs[range_i].low=LONG_MIN;\n        pairs[range_i].high=LONG_MAX;\n\n        continue; /* just skip nil */\n      }\n      if (! (rb_respond_to(e, min_method) & rb_respond_to(e, max_method)))\n        rb_raise(rb_eRuntimeError, \"Not range passed to Ccsv.foreach\");\n\n      min_val=rb_funcall(e, min_method, 0);\n      max_val=rb_funcall(e, max_method, 0);\n      pairs[range_i].low=NUM2LONG(min_val);\n      pairs[range_i].high=NUM2LONG(max_val);\n      range_i++;\n    }\n  }\n  pairs_count=range_i;\n\n  /* main loop lines reading */\n\n  while ((was_read=getline(&line, &len, file)) != -1) {\n\n    if(was_read<1)\n      continue;\n\n    len=was_read-1;\n    /* try to join escaped lines */\n    for(;;) {\n      /* check for backslashed newline */\n      if(line[len]!=EOL)\n        break;\n      if(line[len]==CR){\n        len-=1;\n      }\n      //rb_warn(\"NONLAST (%c,%c)\",line[len],line[len]);\n      count=0;\n      t2=line+len-1;\n      while((t2>=line) && (*t2=='\\\\'))\n        {++count;--t2;}\n      if(count%2 ==1){ /* backslashed! skip */\n        /* get another line... */\n        line2=NULL;\n        len2=0;\n        if((was_read=getline(&line2, &len2, file)) != -1) {\n          len2=was_read;\n          if(new_line)\n            free(new_line); //!!!!\n          new_line=malloc(len+len2+1);\n          strcpy(new_line,line);\n          new_line[len-1]='\\n';\n          strcpy(new_line+len,line2);\n          line=new_line;\n          //nobackslash=len+1;\n          start=new_line;\n          len+=len2-1;\n          nobackslash=start;\n          free(line);\n          free(line2);\n          continue;\n        }\n      }\n      break;\n    }\n    /* chomp! */\n    if(line[len]==EOL){\n      if(line[len-1]==CR)\n        len-=1;\n      line[len]='\\0';\n    }\n    /* skip empty line */\n    if(len<2)\n      continue;\n\n    ary = rb_ary_new();\n    start=line;\n    nobackslash=line;\n    \n    idx = 0;\n    flag=1;\n\n    while (nobackslash != NULL) {\n\n      /* get full field */\n      while(token=strstr(nobackslash, DELIM)){\n        count=0;\n        t2=token-1;\n        while((t2>=line) && (*t2=='\\\\'))\n          {++count;--t2;}\n        if(count%2 ==1){ /* backslashed! skip */\n          nobackslash=token;\n          continue;\n        }\n        break;\n      }\n\n      if(token)\n        *token='\\0';\n      else\n        token=start+strlen(start);\n\n      if(searchfield==idx){\n        flag=0;\n        /* do check! */\n        sscanf(start,\"%ld\",&check);\n        for(i=0;i<pairs_count;++i){\n          /*rb_warn(\"check %ld: [%ld .. %ld]\",check,pairs[i].low,pairs[i].high);*/\n          if(pairs[i].low<check && pairs[i].high>check){\n            /*rb_warn(\"check passed\");*/\n            flag=1; /* yahooo! */\n            break;\n          }\n        }\n      }\n\n      /* not in ranges! */\n      if(flag==0)\n        break;\n\n      rb_ary_store(ary, idx, rb_str_new(start, token-start));\n      idx++;\n      nobackslash=start=token+strlen(DELIM);\n      while(token=strstr(nobackslash, DELIM)){\n        count=0;\n        t2=token-1;\n        while((t2>=line) && (*t2=='\\\\'))\n          {++count;--t2;}\n        if(count%2 ==1){ /* backslashed! skip */\n          nobackslash=token+strlen(DELIM);\n          continue;\n        }\n        break;\n      }\n      nobackslash=token;\n    }\n    if(flag==0)\n      continue;\n\n    /* last item */\n    rb_ary_store(ary, idx, rb_str_new(start, strlen(start)));\n    /* OBJ_FREEZE(ary); */\n\n    rb_yield(ary);\n    /* FL_UNSET((ary), FL_FREEZE); */\n\n    /* for(idx = 0; idx < RARRAY_LEN(ary); idx ++) {\n      rb_ary_store(ary, idx, Qnil);\n    } */\n\n  }\n  fclose(file);\n  free(line);\n\n  return Qnil;\n}",
  "abstract_func_before": "static VALUE foreach(int VAR_0, VALUE* VAR_1, VALUE VAR_2) {\n  char *VAR_3=VAR_4;\n  char *VAR_5 = NULL;\n  char *VAR_6 =NULL, *VAR_7=NULL;\n  size_t VAR_8 = 0, VAR_9=0, VAR_10, VAR_11;\n  char *VAR_12,*VAR_13,*VAR_14,*VAR_15;\n  size_t VAR_16,VAR_17,VAR_18,VAR_19,VAR_20,VAR_21;\n  long VAR_22;\n  int  VAR_23;\n  FILE *VAR_24;\n  ID VAR_25, VAR_26;\n  VALUE VAR_27, VAR_28;\n  VALUE VAR_29, VAR_30, VAR_31;\n  ID    VAR_32; /* COMMENT_0 */\n  struct pair_st VAR_33[VAR_34];\n\n  VALUE VAR_35;\n\n  rb_scan_args(VAR_0,VAR_1,\"1*\", &VAR_31, &VAR_30);\n\n/* COMMENT_1 */\n                                                        \n   \n\n                                              \n                   \n                                                 \n  \n  VAR_24 = fopen(StringValueCStr(VAR_31), \"r\");\n  if(VAR_24==NULL){\n    rb_raise(VAR_36, \"File not found\");\n  }\n\n  if (VAR_0 >1 ) { /* COMMENT_9 */\n    VAR_29=rb_ary_entry(VAR_30,0);\n    VAR_3=StringValueCStr(VAR_29);;\n  }\n\n  if (VAR_0 >2 ) { /* COMMENT_10 */\n    VAR_29=rb_ary_entry(VAR_30,1);\n    VAR_18=NUM2INT(VAR_29);\n  }\n  else{\n    VAR_18=-1;\n  }\n\n  VAR_32=rb_funcall(VAR_30,rb_intern(\"length\"), 0);\n  VAR_20=NUM2INT(VAR_32);\n\n  VAR_25 = rb_intern(\"first\");\n  VAR_26 = rb_intern(\"last\");\n  /* COMMENT_11 */\n  VAR_21=0;\n  for(VAR_16=2;VAR_16<VAR_20;++VAR_16){\n    VAR_27=rb_funcall(rb_ary_entry(VAR_30,VAR_16),rb_intern(\"length\"), 0);\n    VAR_9=NUM2INT(VAR_27);\n    for(VAR_10=0;VAR_10<VAR_9;++VAR_10){\n      VALUE VAR_37=rb_ary_entry(rb_ary_entry(VAR_30,VAR_16),VAR_10);\n      if(VAR_21>VAR_34)\n        rb_raise(VAR_36, \"Too much ranges passed\");\n      if(TYPE(VAR_37) == VAR_38){\n        VAR_33[VAR_21].low=VAR_39;\n        VAR_33[VAR_21].high=VAR_40;\n\n        continue; /* COMMENT_12 */\n      }\n      if (! (rb_respond_to(VAR_37, VAR_25) & rb_respond_to(VAR_37, VAR_26)))\n        rb_raise(VAR_36, \"Not range passed to Ccsv.foreach\");\n\n      VAR_27=rb_funcall(VAR_37, VAR_25, 0);\n      VAR_28=rb_funcall(VAR_37, VAR_26, 0);\n      VAR_33[VAR_21].low=NUM2LONG(VAR_27);\n      VAR_33[VAR_21].high=NUM2LONG(VAR_28);\n      VAR_21++;\n    }\n  }\n  VAR_11=VAR_21;\n\n  /* COMMENT_13 */\n\n  while ((VAR_23=getline(&VAR_5, &VAR_8, VAR_24)) != -1) {\n\n    if(VAR_23<1)\n      continue;\n\n    VAR_8=VAR_23-1;\n    /* COMMENT_14 */\n    for(;;) {\n      /* COMMENT_15 */\n      if(VAR_5[VAR_8]!=VAR_41)\n        break;\n      if(VAR_5[VAR_8]==VAR_42){\n        VAR_8-=1;\n      }\n      /* COMMENT_16 */\n      VAR_17=0;\n      VAR_15=VAR_5+VAR_8-1;\n      while((VAR_15>=VAR_5) && (*VAR_15=='\\\\'))\n        {++VAR_17;--VAR_15;}\n      if(VAR_17%2 ==1){ /* COMMENT_17 */\n        /* COMMENT_18 */\n        VAR_6=NULL;\n        VAR_9=0;\n        if((VAR_23=getline(&VAR_6, &VAR_9, VAR_24)) != -1) {\n          VAR_9=VAR_23;\n          if(VAR_7)\n            free(VAR_7); /* COMMENT_19 */\n          VAR_7=malloc(VAR_8+VAR_9+1);\n          strcpy(VAR_7,VAR_5);\n          VAR_7[VAR_8-1]='\\n';\n          strcpy(VAR_7+VAR_8,VAR_6);\n          VAR_5=VAR_7;\n          /* COMMENT_20 */\n          VAR_13=VAR_7;\n          VAR_8+=VAR_9-1;\n          VAR_14=VAR_13;\n          free(VAR_5);\n          free(VAR_6);\n          continue;\n        }\n      }\n      break;\n    }\n    /* COMMENT_21 */\n    if(VAR_5[VAR_8]==VAR_41){\n      if(VAR_5[VAR_8-1]==VAR_42)\n        VAR_8-=1;\n      VAR_5[VAR_8]='\\0';\n    }\n    /* COMMENT_22 */\n    if(VAR_8<2)\n      continue;\n\n    VAR_35 = rb_ary_new();\n    VAR_13=VAR_5;\n    VAR_14=VAR_5;\n    \n    VAR_16 = 0;\n    VAR_19=1;\n\n    while (VAR_14 != NULL) {\n\n      /* COMMENT_23 */\n      while(VAR_12=strstr(VAR_14, VAR_3)){\n        VAR_17=0;\n        VAR_15=VAR_12-1;\n        while((VAR_15>=VAR_5) && (*VAR_15=='\\\\'))\n          {++VAR_17;--VAR_15;}\n        if(VAR_17%2 ==1){ /* COMMENT_17 */\n          VAR_14=VAR_12;\n          continue;\n        }\n        break;\n      }\n\n      if(VAR_12)\n        *VAR_12='\\0';\n      else\n        VAR_12=VAR_13+strlen(VAR_13);\n\n      if(VAR_18==VAR_16){\n        VAR_19=0;\n        /* COMMENT_24 */\n        sscanf(VAR_13,\"%ld\",&VAR_22);\n        for(VAR_10=0;VAR_10<VAR_11;++VAR_10){\n          /* COMMENT_25 */\n          if(VAR_33[VAR_10].low<VAR_22 && VAR_33[VAR_10].high>VAR_22){\n            /* COMMENT_26 */\n            VAR_19=1; /* COMMENT_27 */\n            break;\n          }\n        }\n      }\n\n      /* COMMENT_28 */\n      if(VAR_19==0)\n        break;\n\n      rb_ary_store(VAR_35, VAR_16, rb_str_new(VAR_13, VAR_12-VAR_13));\n      VAR_16++;\n      VAR_14=VAR_13=VAR_12+strlen(VAR_3);\n      while(VAR_12=strstr(VAR_14, VAR_3)){\n        VAR_17=0;\n        VAR_15=VAR_12-1;\n        while((VAR_15>=VAR_5) && (*VAR_15=='\\\\'))\n          {++VAR_17;--VAR_15;}\n        if(VAR_17%2 ==1){ /* COMMENT_17 */\n          VAR_14=VAR_12+strlen(VAR_3);\n          continue;\n        }\n        break;\n      }\n      VAR_14=VAR_12;\n    }\n    if(VAR_19==0)\n      continue;\n\n    /* COMMENT_29 */\n    rb_ary_store(VAR_35, VAR_16, rb_str_new(VAR_13, strlen(VAR_13)));\n    /* COMMENT_30 */\n\n    rb_yield(VAR_35);\n    /* COMMENT_31 */\n\n    /* COMMENT_32 */\n                                   \n        \n\n  }\n  fclose(VAR_24);\n  free(VAR_5);\n\n  return VAR_43;\n}",
  "func_graph_path_before": "evan/ccsv/24e0b9b94c44a15b23475e821366239d53764dbd/ccsv.c/vul/before/0.json",
  "func": "static VALUE foreach(int argc, VALUE* argv, VALUE self) {\n  char *DELIM=DEF_DELIM;\n  char *line = NULL;\n  char *line2 =NULL, *new_line=NULL;\n  size_t len = 0, len2=0, i, pairs_count;\n  char *token,*start,*nobackslash,*t2;\n  size_t idx,count,searchfield,flag,array_length,range_i;\n  long check;\n  int  was_read, backslashed;\n  FILE *file;\n  ID min_method, max_method;\n  VALUE min_val, max_val;\n  VALUE tmp_value, rest_args, filename;\n  ID    array_length_method; /*----------------------------------------*/\n  struct pair_st pairs[MAX_INTERVALS];\n\n  VALUE ary;\n\n  rb_scan_args(argc,argv,\"1*\", &filename, &rest_args);\n\n/*  if (argc == 0) {  // there should only be 1 or 2 arguments\n    rb_raise(rb_eArgError, \"wrong number of arguments\");\n  }\n\n  file = fopen(StringValueCStr(argv[0]), \"r\");\n  if (file == NULL)\n    rb_raise(rb_eRuntimeError, \"File not found\");\n*/\n  file = fopen(StringValueCStr(filename), \"r\");\n  if(file==NULL){\n    rb_raise(rb_eRuntimeError, \"File not found\");\n  }\n\n  if (argc >1 ) { /* delimiter */\n    tmp_value=rb_ary_entry(rest_args,0);\n    DELIM=StringValueCStr(tmp_value);;\n  }\n\n  if (argc >2 ) { /* search index */\n    tmp_value=rb_ary_entry(rest_args,1);\n    searchfield=NUM2INT(tmp_value);\n  }\n  else{\n    searchfield=-1;\n  }\n\n  array_length_method=rb_funcall(rest_args,rb_intern(\"length\"), 0);\n  array_length=NUM2INT(array_length_method);\n\n  min_method = rb_intern(\"first\");\n  max_method = rb_intern(\"last\");\n  /*------------test_id    = rb_intern(\"class\");*/\n  range_i=0;\n  for(idx=2;idx<array_length;++idx){\n    min_val=rb_funcall(rb_ary_entry(rest_args,idx),rb_intern(\"length\"), 0);\n    len2=NUM2INT(min_val);\n    for(i=0;i<len2;++i){\n      VALUE e=rb_ary_entry(rb_ary_entry(rest_args,idx),i);\n      if(range_i>MAX_INTERVALS)\n        rb_raise(rb_eRuntimeError, \"Too much ranges passed\");\n      if(TYPE(e) == T_NIL){\n        pairs[range_i].low=LONG_MIN;\n        pairs[range_i].high=LONG_MAX;\n\n        continue; /* just skip nil */\n      }\n      if (! (rb_respond_to(e, min_method) & rb_respond_to(e, max_method)))\n        rb_raise(rb_eRuntimeError, \"Not range passed to Ccsv.foreach\");\n\n      min_val=rb_funcall(e, min_method, 0);\n      max_val=rb_funcall(e, max_method, 0);\n      pairs[range_i].low=NUM2LONG(min_val);\n      pairs[range_i].high=NUM2LONG(max_val);\n      range_i++;\n    }\n  }\n  pairs_count=range_i;\n\n  /* main loop lines reading */\n\n  while ((was_read=getline(&line, &len, file)) != -1) {\n\n    if(was_read<1)\n      continue;\n\n    backslashed = 0;\n    len=was_read-1;\n    /* try to join escaped lines */\n    for(;;) {\n      /* check for backslashed newline */\n      if(line[len]!=EOL)\n        break;\n      if(line[len]==CR){\n        len-=1;\n      }\n      //rb_warn(\"NONLAST (%c,%c)\",line[len],line[len]);\n      count=0;\n      t2=line+len-1;\n      while((t2>=line) && (*t2=='\\\\'))\n        {++count;--t2;}\n      if(count%2 ==1){ /* backslashed! skip */\n        /* get another line... */\n        line2=NULL;\n        len2=0;\n        if((was_read=getline(&line2, &len2, file)) != -1) {\n          len2=was_read;\n          if(new_line)\n            free(new_line); //!!!!\n          new_line=malloc(len+len2+1);\n          strcpy(new_line,line);\n          new_line[len-1]='\\n';\n          strcpy(new_line+len,line2);\n          line=new_line;\n          //nobackslash=len+1;\n          start=new_line;\n          len+=len2-1;\n          nobackslash=start;\n          backslashed = 1;\n          free(line);\n          free(line2);\n          continue;\n        }\n      }\n      break;\n    }\n    /* chomp! */\n    if(line[len]==EOL){\n      if(line[len-1]==CR)\n        len-=1;\n      line[len]='\\0';\n    }\n    /* skip empty line */\n    if(len<2)\n      continue;\n\n    ary = rb_ary_new();\n    start=line;\n    nobackslash=line;\n\n    idx = 0;\n    flag=1;\n\n    while (nobackslash != NULL) {\n\n      /* get full field */\n      while(token=strstr(nobackslash, DELIM)){\n        count=0;\n        t2=token-1;\n        while((t2>=line) && (*t2=='\\\\'))\n          {++count;--t2;}\n        if(count%2 ==1){ /* backslashed! skip */\n          nobackslash=token;\n          continue;\n        }\n        break;\n      }\n\n      if(token)\n        *token='\\0';\n      else\n        token=start+strlen(start);\n\n      if(searchfield==idx){\n        flag=0;\n        /* do check! */\n        sscanf(start,\"%ld\",&check);\n        for(i=0;i<pairs_count;++i){\n          /*rb_warn(\"check %ld: [%ld .. %ld]\",check,pairs[i].low,pairs[i].high);*/\n          if(pairs[i].low<check && pairs[i].high>check){\n            /*rb_warn(\"check passed\");*/\n            flag=1; /* yahooo! */\n            break;\n          }\n        }\n      }\n\n      /* not in ranges! */\n      if(flag==0)\n        break;\n\n      rb_ary_store(ary, idx, rb_str_new(start, token-start));\n      idx++;\n      nobackslash=start=token+strlen(DELIM);\n      while(token=strstr(nobackslash, DELIM)){\n        count=0;\n        t2=token-1;\n        while((t2>=line) && (*t2=='\\\\'))\n          {++count;--t2;}\n        if(count%2 ==1){ /* backslashed! skip */\n          nobackslash=token+strlen(DELIM);\n          continue;\n        }\n        break;\n      }\n      nobackslash=token;\n    }\n    if(flag==0)\n      continue;\n\n    /* last item */\n    rb_ary_store(ary, idx, rb_str_new(start, strlen(start)));\n    /* OBJ_FREEZE(ary); */\n\n    rb_yield(ary);\n    /* FL_UNSET((ary), FL_FREEZE); */\n\n    /* for(idx = 0; idx < RARRAY_LEN(ary); idx ++) {\n      rb_ary_store(ary, idx, Qnil);\n    } */\n\n  }\n  fclose(file);\n  if(!backslashed)\n    free(line);\n\n  return Qnil;\n}",
  "abstract_func": "static VALUE foreach(int VAR_0, VALUE* VAR_1, VALUE VAR_2) {\n  char *VAR_3=VAR_4;\n  char *VAR_5 = NULL;\n  char *VAR_6 =NULL, *VAR_7=NULL;\n  size_t VAR_8 = 0, VAR_9=0, VAR_10, VAR_11;\n  char *VAR_12,*VAR_13,*VAR_14,*VAR_15;\n  size_t VAR_16,VAR_17,VAR_18,VAR_19,VAR_20,VAR_21;\n  long VAR_22;\n  int  VAR_23, VAR_24;\n  FILE *VAR_25;\n  ID VAR_26, VAR_27;\n  VALUE VAR_28, VAR_29;\n  VALUE VAR_30, VAR_31, VAR_32;\n  ID    VAR_33; /* COMMENT_0 */\n  struct pair_st VAR_34[VAR_35];\n\n  VALUE VAR_36;\n\n  rb_scan_args(VAR_0,VAR_1,\"1*\", &VAR_32, &VAR_31);\n\n/* COMMENT_1 */\n                                                        \n   \n\n                                              \n                   \n                                                 \n  \n  VAR_25 = fopen(StringValueCStr(VAR_32), \"r\");\n  if(VAR_25==NULL){\n    rb_raise(VAR_37, \"File not found\");\n  }\n\n  if (VAR_0 >1 ) { /* COMMENT_9 */\n    VAR_30=rb_ary_entry(VAR_31,0);\n    VAR_3=StringValueCStr(VAR_30);;\n  }\n\n  if (VAR_0 >2 ) { /* COMMENT_10 */\n    VAR_30=rb_ary_entry(VAR_31,1);\n    VAR_18=NUM2INT(VAR_30);\n  }\n  else{\n    VAR_18=-1;\n  }\n\n  VAR_33=rb_funcall(VAR_31,rb_intern(\"length\"), 0);\n  VAR_20=NUM2INT(VAR_33);\n\n  VAR_26 = rb_intern(\"first\");\n  VAR_27 = rb_intern(\"last\");\n  /* COMMENT_11 */\n  VAR_21=0;\n  for(VAR_16=2;VAR_16<VAR_20;++VAR_16){\n    VAR_28=rb_funcall(rb_ary_entry(VAR_31,VAR_16),rb_intern(\"length\"), 0);\n    VAR_9=NUM2INT(VAR_28);\n    for(VAR_10=0;VAR_10<VAR_9;++VAR_10){\n      VALUE VAR_38=rb_ary_entry(rb_ary_entry(VAR_31,VAR_16),VAR_10);\n      if(VAR_21>VAR_35)\n        rb_raise(VAR_37, \"Too much ranges passed\");\n      if(TYPE(VAR_38) == VAR_39){\n        VAR_34[VAR_21].low=VAR_40;\n        VAR_34[VAR_21].high=VAR_41;\n\n        continue; /* COMMENT_12 */\n      }\n      if (! (rb_respond_to(VAR_38, VAR_26) & rb_respond_to(VAR_38, VAR_27)))\n        rb_raise(VAR_37, \"Not range passed to Ccsv.foreach\");\n\n      VAR_28=rb_funcall(VAR_38, VAR_26, 0);\n      VAR_29=rb_funcall(VAR_38, VAR_27, 0);\n      VAR_34[VAR_21].low=NUM2LONG(VAR_28);\n      VAR_34[VAR_21].high=NUM2LONG(VAR_29);\n      VAR_21++;\n    }\n  }\n  VAR_11=VAR_21;\n\n  /* COMMENT_13 */\n\n  while ((VAR_23=getline(&VAR_5, &VAR_8, VAR_25)) != -1) {\n\n    if(VAR_23<1)\n      continue;\n\n    VAR_24 = 0;\n    VAR_8=VAR_23-1;\n    /* COMMENT_14 */\n    for(;;) {\n      /* COMMENT_15 */\n      if(VAR_5[VAR_8]!=VAR_42)\n        break;\n      if(VAR_5[VAR_8]==VAR_43){\n        VAR_8-=1;\n      }\n      /* COMMENT_16 */\n      VAR_17=0;\n      VAR_15=VAR_5+VAR_8-1;\n      while((VAR_15>=VAR_5) && (*VAR_15=='\\\\'))\n        {++VAR_17;--VAR_15;}\n      if(VAR_17%2 ==1){ /* COMMENT_17 */\n        /* COMMENT_18 */\n        VAR_6=NULL;\n        VAR_9=0;\n        if((VAR_23=getline(&VAR_6, &VAR_9, VAR_25)) != -1) {\n          VAR_9=VAR_23;\n          if(VAR_7)\n            free(VAR_7); /* COMMENT_19 */\n          VAR_7=malloc(VAR_8+VAR_9+1);\n          strcpy(VAR_7,VAR_5);\n          VAR_7[VAR_8-1]='\\n';\n          strcpy(VAR_7+VAR_8,VAR_6);\n          VAR_5=VAR_7;\n          /* COMMENT_20 */\n          VAR_13=VAR_7;\n          VAR_8+=VAR_9-1;\n          VAR_14=VAR_13;\n          VAR_24 = 1;\n          free(VAR_5);\n          free(VAR_6);\n          continue;\n        }\n      }\n      break;\n    }\n    /* COMMENT_21 */\n    if(VAR_5[VAR_8]==VAR_42){\n      if(VAR_5[VAR_8-1]==VAR_43)\n        VAR_8-=1;\n      VAR_5[VAR_8]='\\0';\n    }\n    /* COMMENT_22 */\n    if(VAR_8<2)\n      continue;\n\n    VAR_36 = rb_ary_new();\n    VAR_13=VAR_5;\n    VAR_14=VAR_5;\n\n    VAR_16 = 0;\n    VAR_19=1;\n\n    while (VAR_14 != NULL) {\n\n      /* COMMENT_23 */\n      while(VAR_12=strstr(VAR_14, VAR_3)){\n        VAR_17=0;\n        VAR_15=VAR_12-1;\n        while((VAR_15>=VAR_5) && (*VAR_15=='\\\\'))\n          {++VAR_17;--VAR_15;}\n        if(VAR_17%2 ==1){ /* COMMENT_17 */\n          VAR_14=VAR_12;\n          continue;\n        }\n        break;\n      }\n\n      if(VAR_12)\n        *VAR_12='\\0';\n      else\n        VAR_12=VAR_13+strlen(VAR_13);\n\n      if(VAR_18==VAR_16){\n        VAR_19=0;\n        /* COMMENT_24 */\n        sscanf(VAR_13,\"%ld\",&VAR_22);\n        for(VAR_10=0;VAR_10<VAR_11;++VAR_10){\n          /* COMMENT_25 */\n          if(VAR_34[VAR_10].low<VAR_22 && VAR_34[VAR_10].high>VAR_22){\n            /* COMMENT_26 */\n            VAR_19=1; /* COMMENT_27 */\n            break;\n          }\n        }\n      }\n\n      /* COMMENT_28 */\n      if(VAR_19==0)\n        break;\n\n      rb_ary_store(VAR_36, VAR_16, rb_str_new(VAR_13, VAR_12-VAR_13));\n      VAR_16++;\n      VAR_14=VAR_13=VAR_12+strlen(VAR_3);\n      while(VAR_12=strstr(VAR_14, VAR_3)){\n        VAR_17=0;\n        VAR_15=VAR_12-1;\n        while((VAR_15>=VAR_5) && (*VAR_15=='\\\\'))\n          {++VAR_17;--VAR_15;}\n        if(VAR_17%2 ==1){ /* COMMENT_17 */\n          VAR_14=VAR_12+strlen(VAR_3);\n          continue;\n        }\n        break;\n      }\n      VAR_14=VAR_12;\n    }\n    if(VAR_19==0)\n      continue;\n\n    /* COMMENT_29 */\n    rb_ary_store(VAR_36, VAR_16, rb_str_new(VAR_13, strlen(VAR_13)));\n    /* COMMENT_30 */\n\n    rb_yield(VAR_36);\n    /* COMMENT_31 */\n\n    /* COMMENT_32 */\n                                   \n        \n\n  }\n  fclose(VAR_25);\n  if(!VAR_24)\n    free(VAR_5);\n\n  return VAR_44;\n}",
  "func_graph_path": "evan/ccsv/24e0b9b94c44a15b23475e821366239d53764dbd/ccsv.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,7 @@\n   char *token,*start,*nobackslash,*t2;\n   size_t idx,count,searchfield,flag,array_length,range_i;\n   long check;\n-  int  was_read;\n+  int  was_read, backslashed;\n   FILE *file;\n   ID min_method, max_method;\n   VALUE min_val, max_val;\n@@ -83,6 +83,7 @@\n     if(was_read<1)\n       continue;\n \n+    backslashed = 0;\n     len=was_read-1;\n     /* try to join escaped lines */\n     for(;;) {\n@@ -114,6 +115,7 @@\n           start=new_line;\n           len+=len2-1;\n           nobackslash=start;\n+          backslashed = 1;\n           free(line);\n           free(line2);\n           continue;\n@@ -134,7 +136,7 @@\n     ary = rb_ary_new();\n     start=line;\n     nobackslash=line;\n-    \n+\n     idx = 0;\n     flag=1;\n \n@@ -208,7 +210,8 @@\n \n   }\n   fclose(file);\n-  free(line);\n+  if(!backslashed)\n+    free(line);\n \n   return Qnil;\n }",
  "diff_line_info": {
    "deleted_lines": [
      "  int  was_read;",
      "    ",
      "  free(line);"
    ],
    "added_lines": [
      "  int  was_read, backslashed;",
      "    backslashed = 0;",
      "          backslashed = 1;",
      "",
      "  if(!backslashed)",
      "    free(line);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/evan/ccsv/pull/16",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/evan/ccsv/pull/16: 403 Client Error: Forbidden for url: https://api.github.com/repos/evan/ccsv/pulls/16",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "The commit addresses a double free vulnerability by introducing a condition before freeing memory, preventing multiple frees.\n\n**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}