{
  "cve_id": "CVE-2021-29463",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "Exiv2/exiv2",
  "commit_msg": "Improve bound checking in WebPImage::doWriteMetadata()",
  "commit_hash": "783b3a6ff15ed6f82a8f8e6c8a6f3b84a9b04d4b",
  "git_url": "https://github.com/Exiv2/exiv2/commit/783b3a6ff15ed6f82a8f8e6c8a6f3b84a9b04d4b",
  "file_path": "src/webpimage.cpp",
  "func_name": "WebPImage::doWriteMetadata",
  "func_before": "void WebPImage::doWriteMetadata(BasicIo& outIo)\n    {\n        if (!io_->isopen()) throw Error(kerInputDataReadFailed);\n        if (!outIo.isopen()) throw Error(kerImageWriteFailed);\n\n#ifdef EXIV2_DEBUG_MESSAGES\n        std::cout << \"Writing metadata\" << std::endl;\n#endif\n\n        byte    data   [WEBP_TAG_SIZE*3];\n        DataBuf chunkId(WEBP_TAG_SIZE+1);\n        chunkId.pData_ [WEBP_TAG_SIZE] = '\\0';\n\n        io_->read(data, WEBP_TAG_SIZE * 3);\n        uint64_t filesize = Exiv2::getULong(data + WEBP_TAG_SIZE, littleEndian);\n\n        /* Set up header */\n        if (outIo.write(data, WEBP_TAG_SIZE * 3) != WEBP_TAG_SIZE * 3)\n            throw Error(kerImageWriteFailed);\n\n        /* Parse Chunks */\n        bool has_size  = false;\n        bool has_xmp   = false;\n        bool has_exif  = false;\n        bool has_vp8x  = false;\n        bool has_alpha = false;\n        bool has_icc   = iccProfileDefined();\n\n        int width      = 0;\n        int height     = 0;\n\n        byte       size_buff[WEBP_TAG_SIZE];\n        Blob       blob;\n\n        if (exifData_.count() > 0) {\n            ExifParser::encode(blob, littleEndian, exifData_);\n            if (blob.size() > 0) {\n                has_exif = true;\n            }\n        }\n\n        if (xmpData_.count() > 0 && !writeXmpFromPacket()) {\n            XmpParser::encode(xmpPacket_, xmpData_,\n                              XmpParser::useCompactFormat |\n                              XmpParser::omitAllFormatting);\n        }\n        has_xmp = xmpPacket_.size() > 0;\n        std::string xmp(xmpPacket_);\n\n        /* Verify for a VP8X Chunk First before writing in\n         case we have any exif or xmp data, also check\n         for any chunks with alpha frame/layer set */\n        while ( !io_->eof() && (uint64_t) io_->tell() < filesize) {\n            io_->read(chunkId.pData_, WEBP_TAG_SIZE);\n            io_->read(size_buff, WEBP_TAG_SIZE);\n            long size = Exiv2::getULong(size_buff, littleEndian);\n            DataBuf payload(size);\n            io_->read(payload.pData_, payload.size_);\n            byte c;\n            if ( payload.size_ % 2 ) io_->read(&c,1);\n\n            /* Chunk with information about features\n             used in the file. */\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8X) && !has_vp8x) {\n                has_vp8x = true;\n            }\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8X) && !has_size) {\n                has_size = true;\n                byte size_buf[WEBP_TAG_SIZE];\n\n                // Fetch width - stored in 24bits\n                memcpy(&size_buf, &payload.pData_[4], 3);\n                size_buf[3] = 0;\n                width = Exiv2::getULong(size_buf, littleEndian) + 1;\n\n                // Fetch height - stored in 24bits\n                memcpy(&size_buf, &payload.pData_[7], 3);\n                size_buf[3] = 0;\n                height = Exiv2::getULong(size_buf, littleEndian) + 1;\n            }\n\n            /* Chunk with with animation control data. */\n#ifdef __CHECK_FOR_ALPHA__  // Maybe in the future\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_ANIM) && !has_alpha) {\n                has_alpha = true;\n            }\n#endif\n\n            /* Chunk with with lossy image data. */\n#ifdef __CHECK_FOR_ALPHA__ // Maybe in the future\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8) && !has_alpha) {\n                has_alpha = true;\n            }\n#endif\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8) && !has_size) {\n                has_size = true;\n                byte size_buf[2];\n\n                /* Refer to this https://tools.ietf.org/html/rfc6386\n                   for height and width reference for VP8 chunks */\n\n                // Fetch width - stored in 16bits\n                memcpy(&size_buf, &payload.pData_[6], 2);\n                width = Exiv2::getUShort(size_buf, littleEndian) & 0x3fff;\n\n                // Fetch height - stored in 16bits\n                memcpy(&size_buf, &payload.pData_[8], 2);\n                height = Exiv2::getUShort(size_buf, littleEndian) & 0x3fff;\n            }\n\n            /* Chunk with with lossless image data. */\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8L) && !has_alpha) {\n                if ((payload.pData_[4] & WEBP_VP8X_ALPHA_BIT) == WEBP_VP8X_ALPHA_BIT) {\n                    has_alpha = true;\n                }\n            }\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8L) && !has_size) {\n                has_size = true;\n                byte size_buf_w[2];\n                byte size_buf_h[3];\n\n                /* For VP8L chunks width & height are stored in 28 bits\n                   of a 32 bit field requires bitshifting to get actual\n                   sizes. Width and height are split even into 14 bits\n                   each. Refer to this https://goo.gl/bpgMJf */\n\n                // Fetch width - 14 bits wide\n                memcpy(&size_buf_w, &payload.pData_[1], 2);\n                size_buf_w[1] &= 0x3F;\n                width = Exiv2::getUShort(size_buf_w, littleEndian) + 1;\n\n                // Fetch height - 14 bits wide\n                memcpy(&size_buf_h, &payload.pData_[2], 3);\n                size_buf_h[0] =\n                  ((size_buf_h[0] >> 6) & 0x3) |\n                    ((size_buf_h[1] & 0x3F) << 0x2);\n                size_buf_h[1] =\n                  ((size_buf_h[1] >> 6) & 0x3) |\n                    ((size_buf_h[2] & 0xF) << 0x2);\n                height = Exiv2::getUShort(size_buf_h, littleEndian) + 1;\n            }\n\n            /* Chunk with animation frame. */\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_ANMF) && !has_alpha) {\n                if ((payload.pData_[5] & 0x2) == 0x2) {\n                    has_alpha = true;\n                }\n            }\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_ANMF) && !has_size) {\n                has_size = true;\n                byte size_buf[WEBP_TAG_SIZE];\n\n                // Fetch width - stored in 24bits\n                memcpy(&size_buf, &payload.pData_[6], 3);\n                size_buf[3] = 0;\n                width = Exiv2::getULong(size_buf, littleEndian) + 1;\n\n                // Fetch height - stored in 24bits\n                memcpy(&size_buf, &payload.pData_[9], 3);\n                size_buf[3] = 0;\n                height = Exiv2::getULong(size_buf, littleEndian) + 1;\n            }\n\n            /* Chunk with alpha data. */\n            if (equalsWebPTag(chunkId, \"ALPH\") && !has_alpha) {\n                has_alpha = true;\n            }\n        }\n\n        /* Inject a VP8X chunk if one isn't available. */\n        if (!has_vp8x) {\n            inject_VP8X(outIo, has_xmp, has_exif, has_alpha,\n                        has_icc, width, height);\n        }\n\n        io_->seek(12, BasicIo::beg);\n        while ( !io_->eof() && (uint64_t) io_->tell() < filesize) {\n            io_->read(chunkId.pData_, 4);\n            io_->read(size_buff, 4);\n\n            long size = Exiv2::getULong(size_buff, littleEndian);\n\n            DataBuf payload(size);\n            io_->read(payload.pData_, size);\n            if ( io_->tell() % 2 ) io_->seek(+1,BasicIo::cur); // skip pad\n\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8X)) {\n                if (has_icc){\n                    payload.pData_[0] |= WEBP_VP8X_ICC_BIT;\n                } else {\n                    payload.pData_[0] &= ~WEBP_VP8X_ICC_BIT;\n                }\n\n                if (has_xmp){\n                    payload.pData_[0] |= WEBP_VP8X_XMP_BIT;\n                } else {\n                    payload.pData_[0] &= ~WEBP_VP8X_XMP_BIT;\n                }\n\n                if (has_exif) {\n                    payload.pData_[0] |= WEBP_VP8X_EXIF_BIT;\n                } else {\n                    payload.pData_[0] &= ~WEBP_VP8X_EXIF_BIT;\n                }\n\n                if (outIo.write(chunkId.pData_, WEBP_TAG_SIZE) != WEBP_TAG_SIZE)\n                    throw Error(kerImageWriteFailed);\n                if (outIo.write(size_buff, WEBP_TAG_SIZE) != WEBP_TAG_SIZE)\n                    throw Error(kerImageWriteFailed);\n                if (outIo.write(payload.pData_, payload.size_) != payload.size_)\n                    throw Error(kerImageWriteFailed);\n                if (outIo.tell() % 2) {\n                    if (outIo.write(&WEBP_PAD_ODD, 1) != 1) throw Error(kerImageWriteFailed);\n                }\n\n                if (has_icc) {\n                    if (outIo.write((const byte*)WEBP_CHUNK_HEADER_ICCP, WEBP_TAG_SIZE) != WEBP_TAG_SIZE) throw Error(kerImageWriteFailed);\n                    ul2Data(data, (uint32_t) iccProfile_.size_, littleEndian);\n                    if (outIo.write(data, WEBP_TAG_SIZE) != WEBP_TAG_SIZE) throw Error(kerImageWriteFailed);\n                    if (outIo.write(iccProfile_.pData_, iccProfile_.size_) != iccProfile_.size_) {\n                        throw Error(kerImageWriteFailed);\n                    }\n                    has_icc = false;\n                }\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_ICCP)) {\n                // Skip it altogether handle it prior to here :)\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_EXIF)) {\n                // Skip and add new data afterwards\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_XMP)) {\n                // Skip and add new data afterwards\n            } else {\n                if (outIo.write(chunkId.pData_, WEBP_TAG_SIZE) != WEBP_TAG_SIZE)\n                    throw Error(kerImageWriteFailed);\n                if (outIo.write(size_buff, WEBP_TAG_SIZE) != WEBP_TAG_SIZE)\n                    throw Error(kerImageWriteFailed);\n                if (outIo.write(payload.pData_, payload.size_) != payload.size_)\n                    throw Error(kerImageWriteFailed);\n            }\n\n            // Encoder required to pad odd sized data with a null byte\n            if (outIo.tell() % 2) {\n                if (outIo.write(&WEBP_PAD_ODD, 1) != 1) throw Error(kerImageWriteFailed);\n            }\n        }\n\n        if (has_exif) {\n            if (outIo.write((const byte*)WEBP_CHUNK_HEADER_EXIF, WEBP_TAG_SIZE) != WEBP_TAG_SIZE) throw Error(kerImageWriteFailed);\n            us2Data(data, (uint16_t) blob.size()+8, bigEndian);\n            ul2Data(data, (uint32_t) blob.size(), littleEndian);\n            if (outIo.write(data, WEBP_TAG_SIZE) != WEBP_TAG_SIZE) throw Error(kerImageWriteFailed);\n            if (outIo.write((const byte*)&blob[0], static_cast<long>(blob.size())) != (long)blob.size())\n            {\n                throw Error(kerImageWriteFailed);\n            }\n            if (outIo.tell() % 2) {\n                if (outIo.write(&WEBP_PAD_ODD, 1) != 1) throw Error(kerImageWriteFailed);\n            }\n        }\n\n        if (has_xmp) {\n            if (outIo.write((const byte*)WEBP_CHUNK_HEADER_XMP, WEBP_TAG_SIZE) != WEBP_TAG_SIZE) throw Error(kerImageWriteFailed);\n            ul2Data(data, (uint32_t) xmpPacket().size(), littleEndian);\n            if (outIo.write(data, WEBP_TAG_SIZE) != WEBP_TAG_SIZE) throw Error(kerImageWriteFailed);\n            if (outIo.write((const byte*)xmp.data(), static_cast<long>(xmp.size())) != (long)xmp.size()) {\n                throw Error(kerImageWriteFailed);\n            }\n            if (outIo.tell() % 2) {\n                if (outIo.write(&WEBP_PAD_ODD, 1) != 1) throw Error(kerImageWriteFailed);\n            }\n        }\n\n        // Fix File Size Payload Data\n        outIo.seek(0, BasicIo::beg);\n        filesize = outIo.size() - 8;\n        outIo.seek(4, BasicIo::beg);\n        ul2Data(data, (uint32_t) filesize, littleEndian);\n        if (outIo.write(data, WEBP_TAG_SIZE) != WEBP_TAG_SIZE) throw Error(kerImageWriteFailed);\n\n    }",
  "abstract_func_before": "void WebPImage::doWriteMetadata(BasicIo& VAR_0)\n    {\n        if (!VAR_1->isopen()) throw Error(VAR_2);\n        if (!VAR_0.isopen()) throw Error(VAR_3);\n\n#ifdef VAR_4\n        std::cout << \"Writing metadata\" << std::endl;\n#endif\n\n        byte    VAR_5   [VAR_6*3];\n        DataBuf VAR_7(VAR_6+1);\n        VAR_7.pData_ [VAR_6] = '\\0';\n\n        VAR_1->read(VAR_5, VAR_6 * 3);\n        uint64_t VAR_8 = Exiv2::getULong(VAR_5 + VAR_6, VAR_9);\n\n        /* COMMENT_0 */\n        if (VAR_0.write(VAR_5, VAR_6 * 3) != VAR_6 * 3)\n            throw Error(VAR_3);\n\n        /* COMMENT_1 */\n        bool VAR_10  = false;\n        bool VAR_11   = false;\n        bool VAR_12  = false;\n        bool VAR_13  = false;\n        bool VAR_14 = false;\n        bool VAR_15   = iccProfileDefined();\n\n        int VAR_16      = 0;\n        int VAR_17     = 0;\n\n        byte       VAR_18[VAR_6];\n        Blob       VAR_19;\n\n        if (VAR_20.count() > 0) {\n            ExifParser::encode(VAR_19, VAR_9, VAR_20);\n            if (VAR_19.size() > 0) {\n                VAR_12 = true;\n            }\n        }\n\n        if (VAR_21.count() > 0 && !writeXmpFromPacket()) {\n            XmpParser::encode(VAR_22, VAR_21,\n                              XmpParser::useCompactFormat |\n                              XmpParser::omitAllFormatting);\n        }\n        VAR_11 = VAR_22.size() > 0;\n        std::string xmp(xmpPacket_);\n\n        /* COMMENT_2 */\n                                                      \n                                                     \n        while ( !VAR_1->eof() && (uint64_t) VAR_1->tell() < VAR_8) {\n            VAR_1->read(VAR_7.pData_, VAR_6);\n            VAR_1->read(VAR_18, VAR_6);\n            long VAR_23 = Exiv2::getULong(VAR_18, VAR_9);\n            DataBuf payload(size);\n            VAR_1->read(VAR_24.pData_, VAR_24.size_);\n            byte VAR_25;\n            if ( VAR_24.size_ % 2 ) VAR_1->read(&VAR_25,1);\n\n            /* COMMENT_5 */\n                                 \n            if (equalsWebPTag(VAR_7, VAR_26) && !VAR_13) {\n                VAR_13 = true;\n            }\n            if (equalsWebPTag(VAR_7, VAR_26) && !VAR_10) {\n                VAR_10 = true;\n                byte VAR_27[VAR_6];\n\n                /* COMMENT_7 */\n                memcpy(&VAR_27, &VAR_24.pData_[4], 3);\n                VAR_27[3] = 0;\n                VAR_16 = Exiv2::getULong(VAR_27, VAR_9) + 1;\n\n                /* COMMENT_8 */\n                memcpy(&VAR_27, &VAR_24.pData_[7], 3);\n                VAR_27[3] = 0;\n                VAR_17 = Exiv2::getULong(VAR_27, VAR_9) + 1;\n            }\n\n            /* COMMENT_9 */\n#ifdef VAR_28  /* COMMENT_10 */\n            if (equalsWebPTag(VAR_7, VAR_29) && !VAR_14) {\n                VAR_14 = true;\n            }\n#endif\n\n            /* COMMENT_11 */\n#ifdef VAR_28 /* COMMENT_10 */\n            if (equalsWebPTag(VAR_7, VAR_30) && !VAR_14) {\n                VAR_14 = true;\n            }\n#endif\n            if (equalsWebPTag(VAR_7, VAR_30) && !VAR_10) {\n                VAR_10 = true;\n                byte VAR_27[2];\n\n                /* COMMENT_12 */\n                                                                   \n\n                /* COMMENT_14 */\n                memcpy(&VAR_27, &VAR_24.pData_[6], 2);\n                VAR_16 = Exiv2::getUShort(VAR_27, VAR_9) & 0x3fff;\n\n                /* COMMENT_15 */\n                memcpy(&VAR_27, &VAR_24.pData_[8], 2);\n                VAR_17 = Exiv2::getUShort(VAR_27, VAR_9) & 0x3fff;\n            }\n\n            /* COMMENT_16 */\n            if (equalsWebPTag(VAR_7, VAR_31) && !VAR_14) {\n                if ((VAR_24.pData_[4] & VAR_32) == VAR_32) {\n                    VAR_14 = true;\n                }\n            }\n            if (equalsWebPTag(VAR_7, VAR_31) && !VAR_10) {\n                VAR_10 = true;\n                byte VAR_33[2];\n                byte VAR_34[3];\n\n                /* COMMENT_17 */\n                                                                       \n                                                                      \n                                                               \n\n                /* COMMENT_21 */\n                memcpy(&VAR_33, &VAR_24.pData_[1], 2);\n                VAR_33[1] &= 0x3F;\n                VAR_16 = Exiv2::getUShort(VAR_33, VAR_9) + 1;\n\n                /* COMMENT_22 */\n                memcpy(&VAR_34, &VAR_24.pData_[2], 3);\n                VAR_34[0] =\n                  ((VAR_34[0] >> 6) & 0x3) |\n                    ((VAR_34[1] & 0x3F) << 0x2);\n                VAR_34[1] =\n                  ((VAR_34[1] >> 6) & 0x3) |\n                    ((VAR_34[2] & 0xF) << 0x2);\n                VAR_17 = Exiv2::getUShort(VAR_34, VAR_9) + 1;\n            }\n\n            /* COMMENT_23 */\n            if (equalsWebPTag(VAR_7, VAR_35) && !VAR_14) {\n                if ((VAR_24.pData_[5] & 0x2) == 0x2) {\n                    VAR_14 = true;\n                }\n            }\n            if (equalsWebPTag(VAR_7, VAR_35) && !VAR_10) {\n                VAR_10 = true;\n                byte VAR_27[VAR_6];\n\n                /* COMMENT_7 */\n                memcpy(&VAR_27, &VAR_24.pData_[6], 3);\n                VAR_27[3] = 0;\n                VAR_16 = Exiv2::getULong(VAR_27, VAR_9) + 1;\n\n                /* COMMENT_8 */\n                memcpy(&VAR_27, &VAR_24.pData_[9], 3);\n                VAR_27[3] = 0;\n                VAR_17 = Exiv2::getULong(VAR_27, VAR_9) + 1;\n            }\n\n            /* COMMENT_24 */\n            if (equalsWebPTag(VAR_7, \"ALPH\") && !VAR_14) {\n                VAR_14 = true;\n            }\n        }\n\n        /* COMMENT_25 */\n        if (!VAR_13) {\n            inject_VP8X(VAR_0, VAR_11, VAR_12, VAR_14,\n                        VAR_15, VAR_16, VAR_17);\n        }\n\n        VAR_1->seek(12, BasicIo::beg);\n        while ( !VAR_1->eof() && (uint64_t) VAR_1->tell() < VAR_8) {\n            VAR_1->read(VAR_7.pData_, 4);\n            VAR_1->read(VAR_18, 4);\n\n            long size = Exiv2::getULong(VAR_18, VAR_9);\n\n            DataBuf payload(size);\n            VAR_1->read(VAR_24.pData_, size);\n            if ( VAR_1->tell() % 2 ) VAR_1->seek(+1,BasicIo::cur); /* COMMENT_26 */\n\n            if (equalsWebPTag(VAR_7, VAR_26)) {\n                if (VAR_15){\n                    VAR_24.pData_[0] |= VAR_36;\n                } else {\n                    VAR_24.pData_[0] &= ~VAR_36;\n                }\n\n                if (VAR_11){\n                    VAR_24.pData_[0] |= VAR_37;\n                } else {\n                    VAR_24.pData_[0] &= ~VAR_37;\n                }\n\n                if (VAR_12) {\n                    VAR_24.pData_[0] |= VAR_38;\n                } else {\n                    VAR_24.pData_[0] &= ~VAR_38;\n                }\n\n                if (VAR_0.write(VAR_7.pData_, VAR_6) != VAR_6)\n                    throw Error(VAR_3);\n                if (VAR_0.write(VAR_18, VAR_6) != VAR_6)\n                    throw Error(VAR_3);\n                if (VAR_0.write(VAR_24.pData_, VAR_24.size_) != VAR_24.size_)\n                    throw Error(VAR_3);\n                if (VAR_0.tell() % 2) {\n                    if (VAR_0.write(&VAR_39, 1) != 1) throw Error(VAR_3);\n                }\n\n                if (VAR_15) {\n                    if (VAR_0.write((const byte*)VAR_40, VAR_6) != VAR_6) throw Error(VAR_3);\n                    ul2Data(VAR_5, (uint32_t) VAR_41.size_, VAR_9);\n                    if (VAR_0.write(VAR_5, VAR_6) != VAR_6) throw Error(VAR_3);\n                    if (VAR_0.write(VAR_41.pData_, VAR_41.size_) != VAR_41.size_) {\n                        throw Error(VAR_3);\n                    }\n                    VAR_15 = false;\n                }\n            } else if (equalsWebPTag(VAR_7, VAR_40)) {\n                /* COMMENT_27 */\n            } else if (equalsWebPTag(VAR_7, VAR_42)) {\n                /* COMMENT_28 */\n            } else if (equalsWebPTag(VAR_7, VAR_43)) {\n                /* COMMENT_28 */\n            } else {\n                if (VAR_0.write(VAR_7.pData_, VAR_6) != VAR_6)\n                    throw Error(VAR_3);\n                if (VAR_0.write(VAR_18, VAR_6) != VAR_6)\n                    throw Error(VAR_3);\n                if (VAR_0.write(VAR_24.pData_, VAR_24.size_) != VAR_24.size_)\n                    throw Error(VAR_3);\n            }\n\n            /* COMMENT_29 */\n            if (VAR_0.tell() % 2) {\n                if (VAR_0.write(&VAR_39, 1) != 1) throw Error(VAR_3);\n            }\n        }\n\n        if (VAR_12) {\n            if (VAR_0.write((const byte*)VAR_42, VAR_6) != VAR_6) throw Error(VAR_3);\n            us2Data(VAR_5, (uint16_t) VAR_19.size()+8, VAR_44);\n            ul2Data(VAR_5, (uint32_t) VAR_19.size(), VAR_9);\n            if (VAR_0.write(VAR_5, VAR_6) != VAR_6) throw Error(VAR_3);\n            if (VAR_0.write((const byte*)&VAR_19[0], VAR_45<long>(VAR_19.size())) != (long)VAR_19.size())\n            {\n                throw Error(VAR_3);\n            }\n            if (VAR_0.tell() % 2) {\n                if (VAR_0.write(&VAR_39, 1) != 1) throw Error(VAR_3);\n            }\n        }\n\n        if (VAR_11) {\n            if (VAR_0.write((const byte*)VAR_43, VAR_6) != VAR_6) throw Error(VAR_3);\n            ul2Data(VAR_5, (uint32_t) xmpPacket().size(), VAR_9);\n            if (VAR_0.write(VAR_5, VAR_6) != VAR_6) throw Error(VAR_3);\n            if (VAR_0.write((const byte*)VAR_46.data(), VAR_45<long>(VAR_46.size())) != (long)VAR_46.size()) {\n                throw Error(VAR_3);\n            }\n            if (VAR_0.tell() % 2) {\n                if (VAR_0.write(&VAR_39, 1) != 1) throw Error(VAR_3);\n            }\n        }\n\n        /* COMMENT_30 */\n        VAR_0.seek(0, BasicIo::beg);\n        VAR_8 = VAR_0.size() - 8;\n        VAR_0.seek(4, BasicIo::beg);\n        ul2Data(VAR_5, (uint32_t) VAR_8, VAR_9);\n        if (VAR_0.write(VAR_5, VAR_6) != VAR_6) throw Error(VAR_3);\n\n    }",
  "func_graph_path_before": "Exiv2/exiv2/783b3a6ff15ed6f82a8f8e6c8a6f3b84a9b04d4b/webpimage.cpp/vul/before/0.json",
  "func": "void WebPImage::doWriteMetadata(BasicIo& outIo)\n    {\n        if (!io_->isopen()) throw Error(kerInputDataReadFailed);\n        if (!outIo.isopen()) throw Error(kerImageWriteFailed);\n\n#ifdef EXIV2_DEBUG_MESSAGES\n        std::cout << \"Writing metadata\" << std::endl;\n#endif\n\n        byte    data   [WEBP_TAG_SIZE*3];\n        DataBuf chunkId(WEBP_TAG_SIZE+1);\n        chunkId.pData_ [WEBP_TAG_SIZE] = '\\0';\n\n        readOrThrow(*io_, data, WEBP_TAG_SIZE * 3, Exiv2::kerCorruptedMetadata);\n        uint64_t filesize = Exiv2::getULong(data + WEBP_TAG_SIZE, littleEndian);\n\n        /* Set up header */\n        if (outIo.write(data, WEBP_TAG_SIZE * 3) != WEBP_TAG_SIZE * 3)\n            throw Error(kerImageWriteFailed);\n\n        /* Parse Chunks */\n        bool has_size  = false;\n        bool has_xmp   = false;\n        bool has_exif  = false;\n        bool has_vp8x  = false;\n        bool has_alpha = false;\n        bool has_icc   = iccProfileDefined();\n\n        int width      = 0;\n        int height     = 0;\n\n        byte       size_buff[WEBP_TAG_SIZE];\n        Blob       blob;\n\n        if (exifData_.count() > 0) {\n            ExifParser::encode(blob, littleEndian, exifData_);\n            if (blob.size() > 0) {\n                has_exif = true;\n            }\n        }\n\n        if (xmpData_.count() > 0 && !writeXmpFromPacket()) {\n            XmpParser::encode(xmpPacket_, xmpData_,\n                              XmpParser::useCompactFormat |\n                              XmpParser::omitAllFormatting);\n        }\n        has_xmp = xmpPacket_.size() > 0;\n        std::string xmp(xmpPacket_);\n\n        /* Verify for a VP8X Chunk First before writing in\n         case we have any exif or xmp data, also check\n         for any chunks with alpha frame/layer set */\n        while ( !io_->eof() && (uint64_t) io_->tell() < filesize) {\n            readOrThrow(*io_, chunkId.pData_, WEBP_TAG_SIZE, Exiv2::kerCorruptedMetadata);\n            readOrThrow(*io_, size_buff, WEBP_TAG_SIZE, Exiv2::kerCorruptedMetadata);\n            const uint32_t size_u32 = Exiv2::getULong(size_buff, littleEndian);\n\n            // Check that `size_u32` is safe to cast to `long`.\n            enforce(size_u32 <= static_cast<size_t>(std::numeric_limits<unsigned int>::max()),\n                    Exiv2::kerCorruptedMetadata);\n            const long size = static_cast<long>(size_u32);\n            DataBuf payload(size);\n            readOrThrow(*io_, payload.pData_, payload.size_, Exiv2::kerCorruptedMetadata);\n            if ( payload.size_ % 2 ) {\n              byte c;\n              readOrThrow(*io_, &c, 1, Exiv2::kerCorruptedMetadata);\n            }\n\n            /* Chunk with information about features\n             used in the file. */\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8X) && !has_vp8x) {\n                has_vp8x = true;\n            }\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8X) && !has_size) {\n                enforce(size >= 10, Exiv2::kerCorruptedMetadata);\n                has_size = true;\n                byte size_buf[WEBP_TAG_SIZE];\n\n                // Fetch width - stored in 24bits\n                memcpy(&size_buf, &payload.pData_[4], 3);\n                size_buf[3] = 0;\n                width = Exiv2::getULong(size_buf, littleEndian) + 1;\n\n                // Fetch height - stored in 24bits\n                memcpy(&size_buf, &payload.pData_[7], 3);\n                size_buf[3] = 0;\n                height = Exiv2::getULong(size_buf, littleEndian) + 1;\n            }\n\n            /* Chunk with with animation control data. */\n#ifdef __CHECK_FOR_ALPHA__  // Maybe in the future\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_ANIM) && !has_alpha) {\n                has_alpha = true;\n            }\n#endif\n\n            /* Chunk with with lossy image data. */\n#ifdef __CHECK_FOR_ALPHA__ // Maybe in the future\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8) && !has_alpha) {\n                has_alpha = true;\n            }\n#endif\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8) && !has_size) {\n                enforce(size >= 10, Exiv2::kerCorruptedMetadata);\n                has_size = true;\n                byte size_buf[2];\n\n                /* Refer to this https://tools.ietf.org/html/rfc6386\n                   for height and width reference for VP8 chunks */\n\n                // Fetch width - stored in 16bits\n                memcpy(&size_buf, &payload.pData_[6], 2);\n                width = Exiv2::getUShort(size_buf, littleEndian) & 0x3fff;\n\n                // Fetch height - stored in 16bits\n                memcpy(&size_buf, &payload.pData_[8], 2);\n                height = Exiv2::getUShort(size_buf, littleEndian) & 0x3fff;\n            }\n\n            /* Chunk with with lossless image data. */\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8L) && !has_alpha) {\n                enforce(size >= 5, Exiv2::kerCorruptedMetadata);\n                if ((payload.pData_[4] & WEBP_VP8X_ALPHA_BIT) == WEBP_VP8X_ALPHA_BIT) {\n                    has_alpha = true;\n                }\n            }\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8L) && !has_size) {\n                enforce(size >= 5, Exiv2::kerCorruptedMetadata);\n                has_size = true;\n                byte size_buf_w[2];\n                byte size_buf_h[3];\n\n                /* For VP8L chunks width & height are stored in 28 bits\n                   of a 32 bit field requires bitshifting to get actual\n                   sizes. Width and height are split even into 14 bits\n                   each. Refer to this https://goo.gl/bpgMJf */\n\n                // Fetch width - 14 bits wide\n                memcpy(&size_buf_w, &payload.pData_[1], 2);\n                size_buf_w[1] &= 0x3F;\n                width = Exiv2::getUShort(size_buf_w, littleEndian) + 1;\n\n                // Fetch height - 14 bits wide\n                memcpy(&size_buf_h, &payload.pData_[2], 3);\n                size_buf_h[0] =\n                  ((size_buf_h[0] >> 6) & 0x3) |\n                    ((size_buf_h[1] & 0x3F) << 0x2);\n                size_buf_h[1] =\n                  ((size_buf_h[1] >> 6) & 0x3) |\n                    ((size_buf_h[2] & 0xF) << 0x2);\n                height = Exiv2::getUShort(size_buf_h, littleEndian) + 1;\n            }\n\n            /* Chunk with animation frame. */\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_ANMF) && !has_alpha) {\n                enforce(size >= 6, Exiv2::kerCorruptedMetadata);\n                if ((payload.pData_[5] & 0x2) == 0x2) {\n                    has_alpha = true;\n                }\n            }\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_ANMF) && !has_size) {\n                enforce(size >= 12, Exiv2::kerCorruptedMetadata);\n                has_size = true;\n                byte size_buf[WEBP_TAG_SIZE];\n\n                // Fetch width - stored in 24bits\n                memcpy(&size_buf, &payload.pData_[6], 3);\n                size_buf[3] = 0;\n                width = Exiv2::getULong(size_buf, littleEndian) + 1;\n\n                // Fetch height - stored in 24bits\n                memcpy(&size_buf, &payload.pData_[9], 3);\n                size_buf[3] = 0;\n                height = Exiv2::getULong(size_buf, littleEndian) + 1;\n            }\n\n            /* Chunk with alpha data. */\n            if (equalsWebPTag(chunkId, \"ALPH\") && !has_alpha) {\n                has_alpha = true;\n            }\n        }\n\n        /* Inject a VP8X chunk if one isn't available. */\n        if (!has_vp8x) {\n            inject_VP8X(outIo, has_xmp, has_exif, has_alpha,\n                        has_icc, width, height);\n        }\n\n        io_->seek(12, BasicIo::beg);\n        while ( !io_->eof() && (uint64_t) io_->tell() < filesize) {\n            readOrThrow(*io_, chunkId.pData_, 4, Exiv2::kerCorruptedMetadata);\n            readOrThrow(*io_, size_buff, 4, Exiv2::kerCorruptedMetadata);\n\n            const uint32_t size_u32 = Exiv2::getULong(size_buff, littleEndian);\n\n            // Check that `size_u32` is safe to cast to `long`.\n            enforce(size_u32 <= static_cast<size_t>(std::numeric_limits<unsigned int>::max()),\n                    Exiv2::kerCorruptedMetadata);\n            const long size = static_cast<long>(size_u32);\n\n            DataBuf payload(size);\n            readOrThrow(*io_, payload.pData_, size, Exiv2::kerCorruptedMetadata);\n            if ( io_->tell() % 2 ) io_->seek(+1,BasicIo::cur); // skip pad\n\n            if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8X)) {\n                enforce(size >= 1, Exiv2::kerCorruptedMetadata);\n                if (has_icc){\n                    payload.pData_[0] |= WEBP_VP8X_ICC_BIT;\n                } else {\n                    payload.pData_[0] &= ~WEBP_VP8X_ICC_BIT;\n                }\n\n                if (has_xmp){\n                    payload.pData_[0] |= WEBP_VP8X_XMP_BIT;\n                } else {\n                    payload.pData_[0] &= ~WEBP_VP8X_XMP_BIT;\n                }\n\n                if (has_exif) {\n                    payload.pData_[0] |= WEBP_VP8X_EXIF_BIT;\n                } else {\n                    payload.pData_[0] &= ~WEBP_VP8X_EXIF_BIT;\n                }\n\n                if (outIo.write(chunkId.pData_, WEBP_TAG_SIZE) != WEBP_TAG_SIZE)\n                    throw Error(kerImageWriteFailed);\n                if (outIo.write(size_buff, WEBP_TAG_SIZE) != WEBP_TAG_SIZE)\n                    throw Error(kerImageWriteFailed);\n                if (outIo.write(payload.pData_, payload.size_) != payload.size_)\n                    throw Error(kerImageWriteFailed);\n                if (outIo.tell() % 2) {\n                    if (outIo.write(&WEBP_PAD_ODD, 1) != 1) throw Error(kerImageWriteFailed);\n                }\n\n                if (has_icc) {\n                    if (outIo.write((const byte*)WEBP_CHUNK_HEADER_ICCP, WEBP_TAG_SIZE) != WEBP_TAG_SIZE) throw Error(kerImageWriteFailed);\n                    ul2Data(data, (uint32_t) iccProfile_.size_, littleEndian);\n                    if (outIo.write(data, WEBP_TAG_SIZE) != WEBP_TAG_SIZE) throw Error(kerImageWriteFailed);\n                    if (outIo.write(iccProfile_.pData_, iccProfile_.size_) != iccProfile_.size_) {\n                        throw Error(kerImageWriteFailed);\n                    }\n                    has_icc = false;\n                }\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_ICCP)) {\n                // Skip it altogether handle it prior to here :)\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_EXIF)) {\n                // Skip and add new data afterwards\n            } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_XMP)) {\n                // Skip and add new data afterwards\n            } else {\n                if (outIo.write(chunkId.pData_, WEBP_TAG_SIZE) != WEBP_TAG_SIZE)\n                    throw Error(kerImageWriteFailed);\n                if (outIo.write(size_buff, WEBP_TAG_SIZE) != WEBP_TAG_SIZE)\n                    throw Error(kerImageWriteFailed);\n                if (outIo.write(payload.pData_, payload.size_) != payload.size_)\n                    throw Error(kerImageWriteFailed);\n            }\n\n            // Encoder required to pad odd sized data with a null byte\n            if (outIo.tell() % 2) {\n                if (outIo.write(&WEBP_PAD_ODD, 1) != 1) throw Error(kerImageWriteFailed);\n            }\n        }\n\n        if (has_exif) {\n            if (outIo.write((const byte*)WEBP_CHUNK_HEADER_EXIF, WEBP_TAG_SIZE) != WEBP_TAG_SIZE) throw Error(kerImageWriteFailed);\n            us2Data(data, (uint16_t) blob.size()+8, bigEndian);\n            ul2Data(data, (uint32_t) blob.size(), littleEndian);\n            if (outIo.write(data, WEBP_TAG_SIZE) != WEBP_TAG_SIZE) throw Error(kerImageWriteFailed);\n            if (outIo.write((const byte*)&blob[0], static_cast<long>(blob.size())) != (long)blob.size())\n            {\n                throw Error(kerImageWriteFailed);\n            }\n            if (outIo.tell() % 2) {\n                if (outIo.write(&WEBP_PAD_ODD, 1) != 1) throw Error(kerImageWriteFailed);\n            }\n        }\n\n        if (has_xmp) {\n            if (outIo.write((const byte*)WEBP_CHUNK_HEADER_XMP, WEBP_TAG_SIZE) != WEBP_TAG_SIZE) throw Error(kerImageWriteFailed);\n            ul2Data(data, (uint32_t) xmpPacket().size(), littleEndian);\n            if (outIo.write(data, WEBP_TAG_SIZE) != WEBP_TAG_SIZE) throw Error(kerImageWriteFailed);\n            if (outIo.write((const byte*)xmp.data(), static_cast<long>(xmp.size())) != (long)xmp.size()) {\n                throw Error(kerImageWriteFailed);\n            }\n            if (outIo.tell() % 2) {\n                if (outIo.write(&WEBP_PAD_ODD, 1) != 1) throw Error(kerImageWriteFailed);\n            }\n        }\n\n        // Fix File Size Payload Data\n        outIo.seek(0, BasicIo::beg);\n        filesize = outIo.size() - 8;\n        outIo.seek(4, BasicIo::beg);\n        ul2Data(data, (uint32_t) filesize, littleEndian);\n        if (outIo.write(data, WEBP_TAG_SIZE) != WEBP_TAG_SIZE) throw Error(kerImageWriteFailed);\n\n    }",
  "abstract_func": "void WebPImage::doWriteMetadata(BasicIo& VAR_0)\n    {\n        if (!VAR_1->isopen()) throw Error(VAR_2);\n        if (!VAR_0.isopen()) throw Error(VAR_3);\n\n#ifdef VAR_4\n        std::cout << \"Writing metadata\" << std::endl;\n#endif\n\n        byte    VAR_5   [VAR_6*3];\n        DataBuf VAR_7(VAR_6+1);\n        VAR_7.pData_ [VAR_6] = '\\0';\n\n        readOrThrow(*VAR_1, VAR_5, VAR_6 * 3, Exiv2::kerCorruptedMetadata);\n        uint64_t VAR_8 = Exiv2::getULong(VAR_5 + VAR_6, VAR_9);\n\n        /* COMMENT_0 */\n        if (VAR_0.write(VAR_5, VAR_6 * 3) != VAR_6 * 3)\n            throw Error(VAR_3);\n\n        /* COMMENT_1 */\n        bool VAR_10  = false;\n        bool VAR_11   = false;\n        bool VAR_12  = false;\n        bool VAR_13  = false;\n        bool VAR_14 = false;\n        bool VAR_15   = iccProfileDefined();\n\n        int VAR_16      = 0;\n        int VAR_17     = 0;\n\n        byte       VAR_18[VAR_6];\n        Blob       VAR_19;\n\n        if (VAR_20.count() > 0) {\n            ExifParser::encode(VAR_19, VAR_9, VAR_20);\n            if (VAR_19.size() > 0) {\n                VAR_12 = true;\n            }\n        }\n\n        if (VAR_21.count() > 0 && !writeXmpFromPacket()) {\n            XmpParser::encode(VAR_22, VAR_21,\n                              XmpParser::useCompactFormat |\n                              XmpParser::omitAllFormatting);\n        }\n        VAR_11 = VAR_22.size() > 0;\n        std::string xmp(xmpPacket_);\n\n        /* COMMENT_2 */\n                                                      \n                                                     \n        while ( !VAR_1->eof() && (uint64_t) VAR_1->tell() < VAR_8) {\n            readOrThrow(*VAR_1, VAR_7.pData_, VAR_6, Exiv2::kerCorruptedMetadata);\n            readOrThrow(*VAR_1, VAR_18, VAR_6, Exiv2::kerCorruptedMetadata);\n            const uint32_t VAR_23 = Exiv2::getULong(VAR_18, VAR_9);\n\n            /* COMMENT_5 */\n            enforce(VAR_23 <= VAR_24<size_t>(std::numeric_limits<unsigned int>::max()),\n                    Exiv2::kerCorruptedMetadata);\n            const long VAR_25 = VAR_24<long>(VAR_23);\n            DataBuf payload(size);\n            readOrThrow(*VAR_1, VAR_26.pData_, VAR_26.size_, Exiv2::kerCorruptedMetadata);\n            if ( VAR_26.size_ % 2 ) {\n              byte VAR_27;\n              readOrThrow(*VAR_1, &VAR_27, 1, Exiv2::kerCorruptedMetadata);\n            }\n\n            /* COMMENT_6 */\n                                 \n            if (equalsWebPTag(VAR_7, VAR_28) && !VAR_13) {\n                VAR_13 = true;\n            }\n            if (equalsWebPTag(VAR_7, VAR_28) && !VAR_10) {\n                enforce(size >= 10, Exiv2::kerCorruptedMetadata);\n                VAR_10 = true;\n                byte VAR_29[VAR_6];\n\n                /* COMMENT_8 */\n                memcpy(&VAR_29, &VAR_26.pData_[4], 3);\n                VAR_29[3] = 0;\n                VAR_16 = Exiv2::getULong(VAR_29, VAR_9) + 1;\n\n                /* COMMENT_9 */\n                memcpy(&VAR_29, &VAR_26.pData_[7], 3);\n                VAR_29[3] = 0;\n                VAR_17 = Exiv2::getULong(VAR_29, VAR_9) + 1;\n            }\n\n            /* COMMENT_10 */\n#ifdef VAR_30  /* COMMENT_11 */\n            if (equalsWebPTag(VAR_7, VAR_31) && !VAR_14) {\n                VAR_14 = true;\n            }\n#endif\n\n            /* COMMENT_12 */\n#ifdef VAR_30 /* COMMENT_11 */\n            if (equalsWebPTag(VAR_7, VAR_32) && !VAR_14) {\n                VAR_14 = true;\n            }\n#endif\n            if (equalsWebPTag(VAR_7, VAR_32) && !VAR_10) {\n                enforce(size >= 10, Exiv2::kerCorruptedMetadata);\n                VAR_10 = true;\n                byte VAR_29[2];\n\n                /* COMMENT_13 */\n                                                                   \n\n                /* COMMENT_15 */\n                memcpy(&VAR_29, &VAR_26.pData_[6], 2);\n                VAR_16 = Exiv2::getUShort(VAR_29, VAR_9) & 0x3fff;\n\n                /* COMMENT_16 */\n                memcpy(&VAR_29, &VAR_26.pData_[8], 2);\n                VAR_17 = Exiv2::getUShort(VAR_29, VAR_9) & 0x3fff;\n            }\n\n            /* COMMENT_17 */\n            if (equalsWebPTag(VAR_7, VAR_33) && !VAR_14) {\n                enforce(size >= 5, Exiv2::kerCorruptedMetadata);\n                if ((VAR_26.pData_[4] & VAR_34) == VAR_34) {\n                    VAR_14 = true;\n                }\n            }\n            if (equalsWebPTag(VAR_7, VAR_33) && !VAR_10) {\n                enforce(size >= 5, Exiv2::kerCorruptedMetadata);\n                VAR_10 = true;\n                byte VAR_35[2];\n                byte VAR_36[3];\n\n                /* COMMENT_18 */\n                                                                       \n                                                                      \n                                                               \n\n                /* COMMENT_22 */\n                memcpy(&VAR_35, &VAR_26.pData_[1], 2);\n                VAR_35[1] &= 0x3F;\n                VAR_16 = Exiv2::getUShort(VAR_35, VAR_9) + 1;\n\n                /* COMMENT_23 */\n                memcpy(&VAR_36, &VAR_26.pData_[2], 3);\n                VAR_36[0] =\n                  ((VAR_36[0] >> 6) & 0x3) |\n                    ((VAR_36[1] & 0x3F) << 0x2);\n                VAR_36[1] =\n                  ((VAR_36[1] >> 6) & 0x3) |\n                    ((VAR_36[2] & 0xF) << 0x2);\n                VAR_17 = Exiv2::getUShort(VAR_36, VAR_9) + 1;\n            }\n\n            /* COMMENT_24 */\n            if (equalsWebPTag(VAR_7, VAR_37) && !VAR_14) {\n                enforce(size >= 6, Exiv2::kerCorruptedMetadata);\n                if ((VAR_26.pData_[5] & 0x2) == 0x2) {\n                    VAR_14 = true;\n                }\n            }\n            if (equalsWebPTag(VAR_7, VAR_37) && !VAR_10) {\n                enforce(size >= 12, Exiv2::kerCorruptedMetadata);\n                VAR_10 = true;\n                byte VAR_29[VAR_6];\n\n                /* COMMENT_8 */\n                memcpy(&VAR_29, &VAR_26.pData_[6], 3);\n                VAR_29[3] = 0;\n                VAR_16 = Exiv2::getULong(VAR_29, VAR_9) + 1;\n\n                /* COMMENT_9 */\n                memcpy(&VAR_29, &VAR_26.pData_[9], 3);\n                VAR_29[3] = 0;\n                VAR_17 = Exiv2::getULong(VAR_29, VAR_9) + 1;\n            }\n\n            /* COMMENT_25 */\n            if (equalsWebPTag(VAR_7, \"ALPH\") && !VAR_14) {\n                VAR_14 = true;\n            }\n        }\n\n        /* COMMENT_26 */\n        if (!VAR_13) {\n            inject_VP8X(VAR_0, VAR_11, VAR_12, VAR_14,\n                        VAR_15, VAR_16, VAR_17);\n        }\n\n        VAR_1->seek(12, BasicIo::beg);\n        while ( !VAR_1->eof() && (uint64_t) VAR_1->tell() < VAR_8) {\n            readOrThrow(*VAR_1, VAR_7.pData_, 4, Exiv2::kerCorruptedMetadata);\n            readOrThrow(*VAR_1, VAR_18, 4, Exiv2::kerCorruptedMetadata);\n\n            const uint32_t VAR_23 = Exiv2::getULong(VAR_18, VAR_9);\n\n            /* COMMENT_5 */\n            enforce(VAR_23 <= VAR_24<size_t>(std::numeric_limits<unsigned int>::max()),\n                    Exiv2::kerCorruptedMetadata);\n            const long size = VAR_24<long>(VAR_23);\n\n            DataBuf payload(size);\n            readOrThrow(*VAR_1, VAR_26.pData_, size, Exiv2::kerCorruptedMetadata);\n            if ( VAR_1->tell() % 2 ) VAR_1->seek(+1,BasicIo::cur); /* COMMENT_27 */\n\n            if (equalsWebPTag(VAR_7, VAR_28)) {\n                enforce(size >= 1, Exiv2::kerCorruptedMetadata);\n                if (VAR_15){\n                    VAR_26.pData_[0] |= VAR_38;\n                } else {\n                    VAR_26.pData_[0] &= ~VAR_38;\n                }\n\n                if (VAR_11){\n                    VAR_26.pData_[0] |= VAR_39;\n                } else {\n                    VAR_26.pData_[0] &= ~VAR_39;\n                }\n\n                if (VAR_12) {\n                    VAR_26.pData_[0] |= VAR_40;\n                } else {\n                    VAR_26.pData_[0] &= ~VAR_40;\n                }\n\n                if (VAR_0.write(VAR_7.pData_, VAR_6) != VAR_6)\n                    throw Error(VAR_3);\n                if (VAR_0.write(VAR_18, VAR_6) != VAR_6)\n                    throw Error(VAR_3);\n                if (VAR_0.write(VAR_26.pData_, VAR_26.size_) != VAR_26.size_)\n                    throw Error(VAR_3);\n                if (VAR_0.tell() % 2) {\n                    if (VAR_0.write(&VAR_41, 1) != 1) throw Error(VAR_3);\n                }\n\n                if (VAR_15) {\n                    if (VAR_0.write((const byte*)VAR_42, VAR_6) != VAR_6) throw Error(VAR_3);\n                    ul2Data(VAR_5, (uint32_t) VAR_43.size_, VAR_9);\n                    if (VAR_0.write(VAR_5, VAR_6) != VAR_6) throw Error(VAR_3);\n                    if (VAR_0.write(VAR_43.pData_, VAR_43.size_) != VAR_43.size_) {\n                        throw Error(VAR_3);\n                    }\n                    VAR_15 = false;\n                }\n            } else if (equalsWebPTag(VAR_7, VAR_42)) {\n                /* COMMENT_28 */\n            } else if (equalsWebPTag(VAR_7, VAR_44)) {\n                /* COMMENT_29 */\n            } else if (equalsWebPTag(VAR_7, VAR_45)) {\n                /* COMMENT_29 */\n            } else {\n                if (VAR_0.write(VAR_7.pData_, VAR_6) != VAR_6)\n                    throw Error(VAR_3);\n                if (VAR_0.write(VAR_18, VAR_6) != VAR_6)\n                    throw Error(VAR_3);\n                if (VAR_0.write(VAR_26.pData_, VAR_26.size_) != VAR_26.size_)\n                    throw Error(VAR_3);\n            }\n\n            /* COMMENT_30 */\n            if (VAR_0.tell() % 2) {\n                if (VAR_0.write(&VAR_41, 1) != 1) throw Error(VAR_3);\n            }\n        }\n\n        if (VAR_12) {\n            if (VAR_0.write((const byte*)VAR_44, VAR_6) != VAR_6) throw Error(VAR_3);\n            us2Data(VAR_5, (uint16_t) VAR_19.size()+8, VAR_46);\n            ul2Data(VAR_5, (uint32_t) VAR_19.size(), VAR_9);\n            if (VAR_0.write(VAR_5, VAR_6) != VAR_6) throw Error(VAR_3);\n            if (VAR_0.write((const byte*)&VAR_19[0], VAR_24<long>(VAR_19.size())) != (long)VAR_19.size())\n            {\n                throw Error(VAR_3);\n            }\n            if (VAR_0.tell() % 2) {\n                if (VAR_0.write(&VAR_41, 1) != 1) throw Error(VAR_3);\n            }\n        }\n\n        if (VAR_11) {\n            if (VAR_0.write((const byte*)VAR_45, VAR_6) != VAR_6) throw Error(VAR_3);\n            ul2Data(VAR_5, (uint32_t) xmpPacket().size(), VAR_9);\n            if (VAR_0.write(VAR_5, VAR_6) != VAR_6) throw Error(VAR_3);\n            if (VAR_0.write((const byte*)VAR_47.data(), VAR_24<long>(VAR_47.size())) != (long)VAR_47.size()) {\n                throw Error(VAR_3);\n            }\n            if (VAR_0.tell() % 2) {\n                if (VAR_0.write(&VAR_41, 1) != 1) throw Error(VAR_3);\n            }\n        }\n\n        /* COMMENT_31 */\n        VAR_0.seek(0, BasicIo::beg);\n        VAR_8 = VAR_0.size() - 8;\n        VAR_0.seek(4, BasicIo::beg);\n        ul2Data(VAR_5, (uint32_t) VAR_8, VAR_9);\n        if (VAR_0.write(VAR_5, VAR_6) != VAR_6) throw Error(VAR_3);\n\n    }",
  "func_graph_path": "Exiv2/exiv2/783b3a6ff15ed6f82a8f8e6c8a6f3b84a9b04d4b/webpimage.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -11,7 +11,7 @@\n         DataBuf chunkId(WEBP_TAG_SIZE+1);\n         chunkId.pData_ [WEBP_TAG_SIZE] = '\\0';\n \n-        io_->read(data, WEBP_TAG_SIZE * 3);\n+        readOrThrow(*io_, data, WEBP_TAG_SIZE * 3, Exiv2::kerCorruptedMetadata);\n         uint64_t filesize = Exiv2::getULong(data + WEBP_TAG_SIZE, littleEndian);\n \n         /* Set up header */\n@@ -51,13 +51,20 @@\n          case we have any exif or xmp data, also check\n          for any chunks with alpha frame/layer set */\n         while ( !io_->eof() && (uint64_t) io_->tell() < filesize) {\n-            io_->read(chunkId.pData_, WEBP_TAG_SIZE);\n-            io_->read(size_buff, WEBP_TAG_SIZE);\n-            long size = Exiv2::getULong(size_buff, littleEndian);\n+            readOrThrow(*io_, chunkId.pData_, WEBP_TAG_SIZE, Exiv2::kerCorruptedMetadata);\n+            readOrThrow(*io_, size_buff, WEBP_TAG_SIZE, Exiv2::kerCorruptedMetadata);\n+            const uint32_t size_u32 = Exiv2::getULong(size_buff, littleEndian);\n+\n+            // Check that `size_u32` is safe to cast to `long`.\n+            enforce(size_u32 <= static_cast<size_t>(std::numeric_limits<unsigned int>::max()),\n+                    Exiv2::kerCorruptedMetadata);\n+            const long size = static_cast<long>(size_u32);\n             DataBuf payload(size);\n-            io_->read(payload.pData_, payload.size_);\n-            byte c;\n-            if ( payload.size_ % 2 ) io_->read(&c,1);\n+            readOrThrow(*io_, payload.pData_, payload.size_, Exiv2::kerCorruptedMetadata);\n+            if ( payload.size_ % 2 ) {\n+              byte c;\n+              readOrThrow(*io_, &c, 1, Exiv2::kerCorruptedMetadata);\n+            }\n \n             /* Chunk with information about features\n              used in the file. */\n@@ -65,6 +72,7 @@\n                 has_vp8x = true;\n             }\n             if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8X) && !has_size) {\n+                enforce(size >= 10, Exiv2::kerCorruptedMetadata);\n                 has_size = true;\n                 byte size_buf[WEBP_TAG_SIZE];\n \n@@ -93,6 +101,7 @@\n             }\n #endif\n             if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8) && !has_size) {\n+                enforce(size >= 10, Exiv2::kerCorruptedMetadata);\n                 has_size = true;\n                 byte size_buf[2];\n \n@@ -110,11 +119,13 @@\n \n             /* Chunk with with lossless image data. */\n             if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8L) && !has_alpha) {\n+                enforce(size >= 5, Exiv2::kerCorruptedMetadata);\n                 if ((payload.pData_[4] & WEBP_VP8X_ALPHA_BIT) == WEBP_VP8X_ALPHA_BIT) {\n                     has_alpha = true;\n                 }\n             }\n             if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8L) && !has_size) {\n+                enforce(size >= 5, Exiv2::kerCorruptedMetadata);\n                 has_size = true;\n                 byte size_buf_w[2];\n                 byte size_buf_h[3];\n@@ -142,11 +153,13 @@\n \n             /* Chunk with animation frame. */\n             if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_ANMF) && !has_alpha) {\n+                enforce(size >= 6, Exiv2::kerCorruptedMetadata);\n                 if ((payload.pData_[5] & 0x2) == 0x2) {\n                     has_alpha = true;\n                 }\n             }\n             if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_ANMF) && !has_size) {\n+                enforce(size >= 12, Exiv2::kerCorruptedMetadata);\n                 has_size = true;\n                 byte size_buf[WEBP_TAG_SIZE];\n \n@@ -175,16 +188,22 @@\n \n         io_->seek(12, BasicIo::beg);\n         while ( !io_->eof() && (uint64_t) io_->tell() < filesize) {\n-            io_->read(chunkId.pData_, 4);\n-            io_->read(size_buff, 4);\n-\n-            long size = Exiv2::getULong(size_buff, littleEndian);\n+            readOrThrow(*io_, chunkId.pData_, 4, Exiv2::kerCorruptedMetadata);\n+            readOrThrow(*io_, size_buff, 4, Exiv2::kerCorruptedMetadata);\n+\n+            const uint32_t size_u32 = Exiv2::getULong(size_buff, littleEndian);\n+\n+            // Check that `size_u32` is safe to cast to `long`.\n+            enforce(size_u32 <= static_cast<size_t>(std::numeric_limits<unsigned int>::max()),\n+                    Exiv2::kerCorruptedMetadata);\n+            const long size = static_cast<long>(size_u32);\n \n             DataBuf payload(size);\n-            io_->read(payload.pData_, size);\n+            readOrThrow(*io_, payload.pData_, size, Exiv2::kerCorruptedMetadata);\n             if ( io_->tell() % 2 ) io_->seek(+1,BasicIo::cur); // skip pad\n \n             if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8X)) {\n+                enforce(size >= 1, Exiv2::kerCorruptedMetadata);\n                 if (has_icc){\n                     payload.pData_[0] |= WEBP_VP8X_ICC_BIT;\n                 } else {",
  "diff_line_info": {
    "deleted_lines": [
      "        io_->read(data, WEBP_TAG_SIZE * 3);",
      "            io_->read(chunkId.pData_, WEBP_TAG_SIZE);",
      "            io_->read(size_buff, WEBP_TAG_SIZE);",
      "            long size = Exiv2::getULong(size_buff, littleEndian);",
      "            io_->read(payload.pData_, payload.size_);",
      "            byte c;",
      "            if ( payload.size_ % 2 ) io_->read(&c,1);",
      "            io_->read(chunkId.pData_, 4);",
      "            io_->read(size_buff, 4);",
      "",
      "            long size = Exiv2::getULong(size_buff, littleEndian);",
      "            io_->read(payload.pData_, size);"
    ],
    "added_lines": [
      "        readOrThrow(*io_, data, WEBP_TAG_SIZE * 3, Exiv2::kerCorruptedMetadata);",
      "            readOrThrow(*io_, chunkId.pData_, WEBP_TAG_SIZE, Exiv2::kerCorruptedMetadata);",
      "            readOrThrow(*io_, size_buff, WEBP_TAG_SIZE, Exiv2::kerCorruptedMetadata);",
      "            const uint32_t size_u32 = Exiv2::getULong(size_buff, littleEndian);",
      "",
      "            // Check that `size_u32` is safe to cast to `long`.",
      "            enforce(size_u32 <= static_cast<size_t>(std::numeric_limits<unsigned int>::max()),",
      "                    Exiv2::kerCorruptedMetadata);",
      "            const long size = static_cast<long>(size_u32);",
      "            readOrThrow(*io_, payload.pData_, payload.size_, Exiv2::kerCorruptedMetadata);",
      "            if ( payload.size_ % 2 ) {",
      "              byte c;",
      "              readOrThrow(*io_, &c, 1, Exiv2::kerCorruptedMetadata);",
      "            }",
      "                enforce(size >= 10, Exiv2::kerCorruptedMetadata);",
      "                enforce(size >= 10, Exiv2::kerCorruptedMetadata);",
      "                enforce(size >= 5, Exiv2::kerCorruptedMetadata);",
      "                enforce(size >= 5, Exiv2::kerCorruptedMetadata);",
      "                enforce(size >= 6, Exiv2::kerCorruptedMetadata);",
      "                enforce(size >= 12, Exiv2::kerCorruptedMetadata);",
      "            readOrThrow(*io_, chunkId.pData_, 4, Exiv2::kerCorruptedMetadata);",
      "            readOrThrow(*io_, size_buff, 4, Exiv2::kerCorruptedMetadata);",
      "",
      "            const uint32_t size_u32 = Exiv2::getULong(size_buff, littleEndian);",
      "",
      "            // Check that `size_u32` is safe to cast to `long`.",
      "            enforce(size_u32 <= static_cast<size_t>(std::numeric_limits<unsigned int>::max()),",
      "                    Exiv2::kerCorruptedMetadata);",
      "            const long size = static_cast<long>(size_u32);",
      "            readOrThrow(*io_, payload.pData_, size, Exiv2::kerCorruptedMetadata);",
      "                enforce(size >= 1, Exiv2::kerCorruptedMetadata);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/Exiv2/exiv2/pull/1579",
  "description": {
    "pr_info": {
      "title": "Main WebPImage bounds",
      "number": 1579
    },
    "comment": [
      "Port of #1577 to main\r\n\r\n@kevinbackhouse I decided to port this so that we do not forget to include these changes in master. However, if you had something else in mind for the synchronisation process between 0.27-maintenance and master, please let me know.",
      "Thanks @piponazo! I was under the mistaken impression that these kinds of fixes were promoted automatically.",
      "> Thanks @piponazo! I was under the mistaken impression that these kinds of fixes were promoted automatically.\r\n\r\nActually in the past we were using a service that was making that kind of promotion very easy (just by adding a tag `to-main` to your PR pointing to `0.27-maintenance` that was done semi-automatically). But it looks like this is not available anymore ... I do not know what happend with that  "
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "The patch adds bound checking and error handling to prevent buffer overflows, which are common security issues. The absence of an explicit CVE doesn't negate the security implications of the changes.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9"
}