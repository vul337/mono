{
  "cve_id": "CVE-2018-20843",
  "cwe_ids": [
    "CWE-611"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:C",
  "cvss_is_v3": false,
  "repo_name": "libexpat",
  "commit_msg": "xmlparse.c: Fix extraction of namespace prefix from XML name (#186)",
  "commit_hash": "11f8838bf99ea0a6f0b76f9760c43704d00c4ff6",
  "git_url": "https://github.com/libexpat/libexpat/commit/11f8838bf99ea0a6f0b76f9760c43704d00c4ff6",
  "file_path": "expat/lib/xmlparse.c",
  "func_name": "setElementTypePrefix",
  "func_before": "static int\nsetElementTypePrefix(XML_Parser parser, ELEMENT_TYPE *elementType)\n{\n  DTD * const dtd = parser->m_dtd;  /* save one level of indirection */\n  const XML_Char *name;\n  for (name = elementType->name; *name; name++) {\n    if (*name == XML_T(ASCII_COLON)) {\n      PREFIX *prefix;\n      const XML_Char *s;\n      for (s = elementType->name; s != name; s++) {\n        if (!poolAppendChar(&dtd->pool, *s))\n          return 0;\n      }\n      if (!poolAppendChar(&dtd->pool, XML_T('\\0')))\n        return 0;\n      prefix = (PREFIX *)lookup(parser, &dtd->prefixes, poolStart(&dtd->pool),\n                                sizeof(PREFIX));\n      if (!prefix)\n        return 0;\n      if (prefix->name == poolStart(&dtd->pool))\n        poolFinish(&dtd->pool);\n      else\n        poolDiscard(&dtd->pool);\n      elementType->prefix = prefix;\n\n    }\n  }\n  return 1;\n}",
  "abstract_func_before": "static int\nsetElementTypePrefix(XML_Parser VAR_0, ELEMENT_TYPE *VAR_1)\n{\n  DTD * const VAR_2 = VAR_0->m_dtd;  /* COMMENT_0 */\n  const XML_Char *VAR_3;\n  for (VAR_3 = VAR_1->name; *VAR_3; VAR_3++) {\n    if (*VAR_3 == XML_T(VAR_4)) {\n      PREFIX *VAR_5;\n      const XML_Char *VAR_6;\n      for (VAR_6 = VAR_1->name; VAR_6 != VAR_3; VAR_6++) {\n        if (!poolAppendChar(&VAR_2->pool, *VAR_6))\n          return 0;\n      }\n      if (!poolAppendChar(&VAR_2->pool, XML_T('\\0')))\n        return 0;\n      VAR_5 = (PREFIX *)lookup(VAR_0, &VAR_2->prefixes, poolStart(&VAR_2->pool),\n                                sizeof(PREFIX));\n      if (!VAR_5)\n        return 0;\n      if (VAR_5->name == poolStart(&VAR_2->pool))\n        poolFinish(&VAR_2->pool);\n      else\n        poolDiscard(&VAR_2->pool);\n      VAR_1->prefix = VAR_5;\n\n    }\n  }\n  return 1;\n}",
  "func_graph_path_before": "libexpat/11f8838bf99ea0a6f0b76f9760c43704d00c4ff6/xmlparse.c/vul/before/0.json",
  "func": "static int\nsetElementTypePrefix(XML_Parser parser, ELEMENT_TYPE *elementType)\n{\n  DTD * const dtd = parser->m_dtd;  /* save one level of indirection */\n  const XML_Char *name;\n  for (name = elementType->name; *name; name++) {\n    if (*name == XML_T(ASCII_COLON)) {\n      PREFIX *prefix;\n      const XML_Char *s;\n      for (s = elementType->name; s != name; s++) {\n        if (!poolAppendChar(&dtd->pool, *s))\n          return 0;\n      }\n      if (!poolAppendChar(&dtd->pool, XML_T('\\0')))\n        return 0;\n      prefix = (PREFIX *)lookup(parser, &dtd->prefixes, poolStart(&dtd->pool),\n                                sizeof(PREFIX));\n      if (!prefix)\n        return 0;\n      if (prefix->name == poolStart(&dtd->pool))\n        poolFinish(&dtd->pool);\n      else\n        poolDiscard(&dtd->pool);\n      elementType->prefix = prefix;\n      break;\n    }\n  }\n  return 1;\n}",
  "abstract_func": "static int\nsetElementTypePrefix(XML_Parser VAR_0, ELEMENT_TYPE *VAR_1)\n{\n  DTD * const VAR_2 = VAR_0->m_dtd;  /* COMMENT_0 */\n  const XML_Char *VAR_3;\n  for (VAR_3 = VAR_1->name; *VAR_3; VAR_3++) {\n    if (*VAR_3 == XML_T(VAR_4)) {\n      PREFIX *VAR_5;\n      const XML_Char *VAR_6;\n      for (VAR_6 = VAR_1->name; VAR_6 != VAR_3; VAR_6++) {\n        if (!poolAppendChar(&VAR_2->pool, *VAR_6))\n          return 0;\n      }\n      if (!poolAppendChar(&VAR_2->pool, XML_T('\\0')))\n        return 0;\n      VAR_5 = (PREFIX *)lookup(VAR_0, &VAR_2->prefixes, poolStart(&VAR_2->pool),\n                                sizeof(PREFIX));\n      if (!VAR_5)\n        return 0;\n      if (VAR_5->name == poolStart(&VAR_2->pool))\n        poolFinish(&VAR_2->pool);\n      else\n        poolDiscard(&VAR_2->pool);\n      VAR_1->prefix = VAR_5;\n      break;\n    }\n  }\n  return 1;\n}",
  "func_graph_path": "libexpat/11f8838bf99ea0a6f0b76f9760c43704d00c4ff6/xmlparse.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -22,7 +22,7 @@\n       else\n         poolDiscard(&dtd->pool);\n       elementType->prefix = prefix;\n-\n+      break;\n     }\n   }\n   return 1;",
  "diff_line_info": {
    "deleted_lines": [
      ""
    ],
    "added_lines": [
      "      break;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libexpat/libexpat/pull/262",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/libexpat/libexpat/pull/262: 403 Client Error: Forbidden for url: https://api.github.com/repos/libexpat/libexpat/pulls/262",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix;  \n**Confidence:** 0.8"
}