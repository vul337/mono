{
  "cve_id": "CVE-2013-20001",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:N/A:N",
  "cvss_is_v3": false,
  "repo_name": "openzfs/zfs",
  "commit_msg": "libshare: nfs: correctly pass through ipv6 addresses in bracket notation\n\nCloses: #11171, #1894\nSigned-off-by: Felix DÃ¶rre <felix@dogcraft.de>",
  "commit_hash": "5421a04adce8465a5f9fc1a0346587404a885632",
  "git_url": "https://github.com/openzfs/zfs/commit/5421a04adce8465a5f9fc1a0346587404a885632",
  "file_path": "lib/libshare/os/linux/nfs.c",
  "func_name": "foreach_nfs_host_cb",
  "func_before": "static int\nforeach_nfs_host_cb(const char *opt, const char *value, void *pcookie)\n{\n\tint error;\n\tconst char *access;\n\tchar *host_dup, *host, *next;\n\tnfs_host_cookie_t *udata = (nfs_host_cookie_t *)pcookie;\n\n#ifdef DEBUG\n\tfprintf(stderr, \"foreach_nfs_host_cb: key=%s, value=%s\\n\", opt, value);\n#endif\n\n\tif (strcmp(opt, \"sec\") == 0)\n\t\tudata->security = value;\n\n\tif (strcmp(opt, \"rw\") == 0 || strcmp(opt, \"ro\") == 0) {\n\t\tif (value == NULL)\n\t\t\tvalue = \"*\";\n\n\t\taccess = opt;\n\n\t\thost_dup = strdup(value);\n\n\t\tif (host_dup == NULL)\n\t\t\treturn (SA_NO_MEMORY);\n\n\t\thost = host_dup;\n\n\t\tdo {\n\t\t\tnext = strchr(host, ':');\n\t\t\tif (next != NULL) {\n\t\t\t\t*next = '\\0';\n\t\t\t\tnext++;\n\t\t\t}\n\n\t\t\terror = udata->callback(udata->filename,\n\t\t\t    udata->sharepath, host, udata->security,\n\t\t\t    access, udata->cookie);\n\n\t\t\tif (error != SA_OK) {\n\t\t\t\tfree(host_dup);\n\n\t\t\t\treturn (error);\n\t\t\t}\n\n\t\t\thost = next;\n\t\t} while (host != NULL);\n\n\t\tfree(host_dup);\n\t}\n\n\treturn (SA_OK);\n}",
  "abstract_func_before": "static int\nforeach_nfs_host_cb(const char *VAR_0, const char *VAR_1, void *VAR_2)\n{\n\tint VAR_3;\n\tconst char *VAR_4;\n\tchar *VAR_5, *VAR_6, *VAR_7;\n\tnfs_host_cookie_t *VAR_8 = (nfs_host_cookie_t *)VAR_2;\n\n#ifdef VAR_9\n\tfprintf(VAR_10, \"foreach_nfs_host_cb: key=%s, value=%s\\n\", VAR_0, VAR_1);\n#endif\n\n\tif (strcmp(VAR_0, \"sec\") == 0)\n\t\tVAR_8->security = VAR_1;\n\n\tif (strcmp(VAR_0, \"rw\") == 0 || strcmp(VAR_0, \"ro\") == 0) {\n\t\tif (VAR_1 == NULL)\n\t\t\tVAR_1 = \"*\";\n\n\t\tVAR_4 = VAR_0;\n\n\t\tVAR_5 = strdup(VAR_1);\n\n\t\tif (VAR_5 == NULL)\n\t\t\treturn (VAR_11);\n\n\t\tVAR_6 = VAR_5;\n\n\t\tdo {\n\t\t\tVAR_7 = strchr(VAR_6, ':');\n\t\t\tif (VAR_7 != NULL) {\n\t\t\t\t*VAR_7 = '\\0';\n\t\t\t\tVAR_7++;\n\t\t\t}\n\n\t\t\tVAR_3 = VAR_8->callback(VAR_8->filename,\n\t\t\t    VAR_8->sharepath, VAR_6, VAR_8->security,\n\t\t\t    VAR_4, VAR_8->cookie);\n\n\t\t\tif (VAR_3 != VAR_12) {\n\t\t\t\tfree(VAR_5);\n\n\t\t\t\treturn (VAR_3);\n\t\t\t}\n\n\t\t\tVAR_6 = VAR_7;\n\t\t} while (VAR_6 != NULL);\n\n\t\tfree(VAR_5);\n\t}\n\n\treturn (VAR_12);\n}",
  "func_graph_path_before": "openzfs/zfs/5421a04adce8465a5f9fc1a0346587404a885632/nfs.c/vul/before/0.json",
  "func": "static int\nforeach_nfs_host_cb(const char *opt, const char *value, void *pcookie)\n{\n\tint error;\n\tconst char *access;\n\tchar *host_dup, *host, *next, *v6Literal;\n\tnfs_host_cookie_t *udata = (nfs_host_cookie_t *)pcookie;\n\tint cidr_len;\n\n#ifdef DEBUG\n\tfprintf(stderr, \"foreach_nfs_host_cb: key=%s, value=%s\\n\", opt, value);\n#endif\n\n\tif (strcmp(opt, \"sec\") == 0)\n\t\tudata->security = value;\n\n\tif (strcmp(opt, \"rw\") == 0 || strcmp(opt, \"ro\") == 0) {\n\t\tif (value == NULL)\n\t\t\tvalue = \"*\";\n\n\t\taccess = opt;\n\n\t\thost_dup = strdup(value);\n\n\t\tif (host_dup == NULL)\n\t\t\treturn (SA_NO_MEMORY);\n\n\t\thost = host_dup;\n\n\t\tdo {\n\t\t\tif (*host == '[') {\n\t\t\t\thost++;\n\t\t\t\tv6Literal = strchr(host, ']');\n\t\t\t\tif (v6Literal == NULL) {\n\t\t\t\t\tfree(host_dup);\n\t\t\t\t\treturn (SA_SYNTAX_ERR);\n\t\t\t\t}\n\t\t\t\tif (v6Literal[1] == '\\0') {\n\t\t\t\t\t*v6Literal = '\\0';\n\t\t\t\t\tnext = NULL;\n\t\t\t\t} else if (v6Literal[1] == '/') {\n\t\t\t\t\tnext = strchr(v6Literal + 2, ':');\n\t\t\t\t\tif (next == NULL) {\n\t\t\t\t\t\tcidr_len =\n\t\t\t\t\t\t    strlen(v6Literal + 1);\n\t\t\t\t\t\tmemmove(v6Literal,\n\t\t\t\t\t\t    v6Literal + 1,\n\t\t\t\t\t\t    cidr_len);\n\t\t\t\t\t\tv6Literal[cidr_len] = '\\0';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcidr_len = next - v6Literal - 1;\n\t\t\t\t\t\tmemmove(v6Literal,\n\t\t\t\t\t\t    v6Literal + 1,\n\t\t\t\t\t\t    cidr_len);\n\t\t\t\t\t\tv6Literal[cidr_len] = '\\0';\n\t\t\t\t\t\tnext++;\n\t\t\t\t\t}\n\t\t\t\t} else if (v6Literal[1] == ':') {\n\t\t\t\t\t*v6Literal = '\\0';\n\t\t\t\t\tnext = v6Literal + 2;\n\t\t\t\t} else {\n\t\t\t\t\tfree(host_dup);\n\t\t\t\t\treturn (SA_SYNTAX_ERR);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnext = strchr(host, ':');\n\t\t\t\tif (next != NULL) {\n\t\t\t\t\t*next = '\\0';\n\t\t\t\t\tnext++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\terror = udata->callback(udata->filename,\n\t\t\t    udata->sharepath, host, udata->security,\n\t\t\t    access, udata->cookie);\n\n\t\t\tif (error != SA_OK) {\n\t\t\t\tfree(host_dup);\n\n\t\t\t\treturn (error);\n\t\t\t}\n\n\t\t\thost = next;\n\t\t} while (host != NULL);\n\n\t\tfree(host_dup);\n\t}\n\n\treturn (SA_OK);\n}",
  "abstract_func": "static int\nforeach_nfs_host_cb(const char *VAR_0, const char *VAR_1, void *VAR_2)\n{\n\tint VAR_3;\n\tconst char *VAR_4;\n\tchar *VAR_5, *VAR_6, *VAR_7, *VAR_8;\n\tnfs_host_cookie_t *VAR_9 = (nfs_host_cookie_t *)VAR_2;\n\tint VAR_10;\n\n#ifdef VAR_11\n\tfprintf(VAR_12, \"foreach_nfs_host_cb: key=%s, value=%s\\n\", VAR_0, VAR_1);\n#endif\n\n\tif (strcmp(VAR_0, \"sec\") == 0)\n\t\tVAR_9->security = VAR_1;\n\n\tif (strcmp(VAR_0, \"rw\") == 0 || strcmp(VAR_0, \"ro\") == 0) {\n\t\tif (VAR_1 == NULL)\n\t\t\tVAR_1 = \"*\";\n\n\t\tVAR_4 = VAR_0;\n\n\t\tVAR_5 = strdup(VAR_1);\n\n\t\tif (VAR_5 == NULL)\n\t\t\treturn (VAR_13);\n\n\t\tVAR_6 = VAR_5;\n\n\t\tdo {\n\t\t\tif (*VAR_6 == '[') {\n\t\t\t\tVAR_6++;\n\t\t\t\tVAR_8 = strchr(VAR_6, ']');\n\t\t\t\tif (VAR_8 == NULL) {\n\t\t\t\t\tfree(VAR_5);\n\t\t\t\t\treturn (VAR_14);\n\t\t\t\t}\n\t\t\t\tif (VAR_8[1] == '\\0') {\n\t\t\t\t\t*VAR_8 = '\\0';\n\t\t\t\t\tVAR_7 = NULL;\n\t\t\t\t} else if (VAR_8[1] == '/') {\n\t\t\t\t\tVAR_7 = strchr(VAR_8 + 2, ':');\n\t\t\t\t\tif (VAR_7 == NULL) {\n\t\t\t\t\t\tVAR_10 =\n\t\t\t\t\t\t    strlen(VAR_8 + 1);\n\t\t\t\t\t\tmemmove(VAR_8,\n\t\t\t\t\t\t    VAR_8 + 1,\n\t\t\t\t\t\t    VAR_10);\n\t\t\t\t\t\tVAR_8[VAR_10] = '\\0';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tVAR_10 = VAR_7 - VAR_8 - 1;\n\t\t\t\t\t\tmemmove(VAR_8,\n\t\t\t\t\t\t    VAR_8 + 1,\n\t\t\t\t\t\t    VAR_10);\n\t\t\t\t\t\tVAR_8[VAR_10] = '\\0';\n\t\t\t\t\t\tVAR_7++;\n\t\t\t\t\t}\n\t\t\t\t} else if (VAR_8[1] == ':') {\n\t\t\t\t\t*VAR_8 = '\\0';\n\t\t\t\t\tVAR_7 = VAR_8 + 2;\n\t\t\t\t} else {\n\t\t\t\t\tfree(VAR_5);\n\t\t\t\t\treturn (VAR_14);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tVAR_7 = strchr(VAR_6, ':');\n\t\t\t\tif (VAR_7 != NULL) {\n\t\t\t\t\t*VAR_7 = '\\0';\n\t\t\t\t\tVAR_7++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tVAR_3 = VAR_9->callback(VAR_9->filename,\n\t\t\t    VAR_9->sharepath, VAR_6, VAR_9->security,\n\t\t\t    VAR_4, VAR_9->cookie);\n\n\t\t\tif (VAR_3 != VAR_15) {\n\t\t\t\tfree(VAR_5);\n\n\t\t\t\treturn (VAR_3);\n\t\t\t}\n\n\t\t\tVAR_6 = VAR_7;\n\t\t} while (VAR_6 != NULL);\n\n\t\tfree(VAR_5);\n\t}\n\n\treturn (VAR_15);\n}",
  "func_graph_path": "openzfs/zfs/5421a04adce8465a5f9fc1a0346587404a885632/nfs.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -3,8 +3,9 @@\n {\n \tint error;\n \tconst char *access;\n-\tchar *host_dup, *host, *next;\n+\tchar *host_dup, *host, *next, *v6Literal;\n \tnfs_host_cookie_t *udata = (nfs_host_cookie_t *)pcookie;\n+\tint cidr_len;\n \n #ifdef DEBUG\n \tfprintf(stderr, \"foreach_nfs_host_cb: key=%s, value=%s\\n\", opt, value);\n@@ -27,10 +28,46 @@\n \t\thost = host_dup;\n \n \t\tdo {\n-\t\t\tnext = strchr(host, ':');\n-\t\t\tif (next != NULL) {\n-\t\t\t\t*next = '\\0';\n-\t\t\t\tnext++;\n+\t\t\tif (*host == '[') {\n+\t\t\t\thost++;\n+\t\t\t\tv6Literal = strchr(host, ']');\n+\t\t\t\tif (v6Literal == NULL) {\n+\t\t\t\t\tfree(host_dup);\n+\t\t\t\t\treturn (SA_SYNTAX_ERR);\n+\t\t\t\t}\n+\t\t\t\tif (v6Literal[1] == '\\0') {\n+\t\t\t\t\t*v6Literal = '\\0';\n+\t\t\t\t\tnext = NULL;\n+\t\t\t\t} else if (v6Literal[1] == '/') {\n+\t\t\t\t\tnext = strchr(v6Literal + 2, ':');\n+\t\t\t\t\tif (next == NULL) {\n+\t\t\t\t\t\tcidr_len =\n+\t\t\t\t\t\t    strlen(v6Literal + 1);\n+\t\t\t\t\t\tmemmove(v6Literal,\n+\t\t\t\t\t\t    v6Literal + 1,\n+\t\t\t\t\t\t    cidr_len);\n+\t\t\t\t\t\tv6Literal[cidr_len] = '\\0';\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tcidr_len = next - v6Literal - 1;\n+\t\t\t\t\t\tmemmove(v6Literal,\n+\t\t\t\t\t\t    v6Literal + 1,\n+\t\t\t\t\t\t    cidr_len);\n+\t\t\t\t\t\tv6Literal[cidr_len] = '\\0';\n+\t\t\t\t\t\tnext++;\n+\t\t\t\t\t}\n+\t\t\t\t} else if (v6Literal[1] == ':') {\n+\t\t\t\t\t*v6Literal = '\\0';\n+\t\t\t\t\tnext = v6Literal + 2;\n+\t\t\t\t} else {\n+\t\t\t\t\tfree(host_dup);\n+\t\t\t\t\treturn (SA_SYNTAX_ERR);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tnext = strchr(host, ':');\n+\t\t\t\tif (next != NULL) {\n+\t\t\t\t\t*next = '\\0';\n+\t\t\t\t\tnext++;\n+\t\t\t\t}\n \t\t\t}\n \n \t\t\terror = udata->callback(udata->filename,",
  "diff_line_info": {
    "deleted_lines": [
      "\tchar *host_dup, *host, *next;",
      "\t\t\tnext = strchr(host, ':');",
      "\t\t\tif (next != NULL) {",
      "\t\t\t\t*next = '\\0';",
      "\t\t\t\tnext++;"
    ],
    "added_lines": [
      "\tchar *host_dup, *host, *next, *v6Literal;",
      "\tint cidr_len;",
      "\t\t\tif (*host == '[') {",
      "\t\t\t\thost++;",
      "\t\t\t\tv6Literal = strchr(host, ']');",
      "\t\t\t\tif (v6Literal == NULL) {",
      "\t\t\t\t\tfree(host_dup);",
      "\t\t\t\t\treturn (SA_SYNTAX_ERR);",
      "\t\t\t\t}",
      "\t\t\t\tif (v6Literal[1] == '\\0') {",
      "\t\t\t\t\t*v6Literal = '\\0';",
      "\t\t\t\t\tnext = NULL;",
      "\t\t\t\t} else if (v6Literal[1] == '/') {",
      "\t\t\t\t\tnext = strchr(v6Literal + 2, ':');",
      "\t\t\t\t\tif (next == NULL) {",
      "\t\t\t\t\t\tcidr_len =",
      "\t\t\t\t\t\t    strlen(v6Literal + 1);",
      "\t\t\t\t\t\tmemmove(v6Literal,",
      "\t\t\t\t\t\t    v6Literal + 1,",
      "\t\t\t\t\t\t    cidr_len);",
      "\t\t\t\t\t\tv6Literal[cidr_len] = '\\0';",
      "\t\t\t\t\t} else {",
      "\t\t\t\t\t\tcidr_len = next - v6Literal - 1;",
      "\t\t\t\t\t\tmemmove(v6Literal,",
      "\t\t\t\t\t\t    v6Literal + 1,",
      "\t\t\t\t\t\t    cidr_len);",
      "\t\t\t\t\t\tv6Literal[cidr_len] = '\\0';",
      "\t\t\t\t\t\tnext++;",
      "\t\t\t\t\t}",
      "\t\t\t\t} else if (v6Literal[1] == ':') {",
      "\t\t\t\t\t*v6Literal = '\\0';",
      "\t\t\t\t\tnext = v6Literal + 2;",
      "\t\t\t\t} else {",
      "\t\t\t\t\tfree(host_dup);",
      "\t\t\t\t\treturn (SA_SYNTAX_ERR);",
      "\t\t\t\t}",
      "\t\t\t} else {",
      "\t\t\t\tnext = strchr(host, ':');",
      "\t\t\t\tif (next != NULL) {",
      "\t\t\t\t\t*next = '\\0';",
      "\t\t\t\t\tnext++;",
      "\t\t\t\t}"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/openzfs/zfs/pull/11939",
  "description": {
    "pr_info": {
      "title": "Correclty pass through Ipv6 addresses in sharenfs",
      "number": 11939
    },
    "comment": [
      "Recognize when the host part of a `sharenfs` attribute is an ipv6 Literal and pass that through without modification.\r\n\r\n### Motivation and Context\r\nCloses: #11171\r\nCloses: #1894\r\n\r\nIt might also solve CVE-2013-20001. This depends on the expectations an admin has. CVE-2013-20001 is exploitable when an admin configures an ipv6 address (range) for sharenfs and it is effectively ignored resulting in no error. With this patch, the Ipv6 range is interpreted successfully if enclosed in square brackets. If it is not enclosed in square brackets it is still interpreted as before: a list of strange host names, which could result in the confusion for CVE-2013-20001.\r\n\r\n### Description\r\nIf a host starts with `[` it is interpreted as an Ipv6 Literal. In that case, the host is assumed to go until the next `]`. If such a `]` does not occur, it is treated as syntax error. The next byte after `]` must be either `:` (for another host) or a null byte or `/` indicating an IP-Range.\r\n\r\n### How Has This Been Tested?\r\nCreated a new test case that runs through perfectly. Also manually setting the property and inspecting the corresponding file in `/etc/exports` shows the expected contents.\r\n\r\n### Types of changes\r\n<!--- What types of changes does your code introduce? Put an `x` in all the boxes that apply: -->\r\n- [x] Bug fix (non-breaking change which fixes an issue)\r\n- [x] New feature (non-breaking change which adds functionality)\r\n- [ ] Performance enhancement (non-breaking change which improves efficiency)\r\n- [ ] Code cleanup (non-breaking change which makes code smaller or more readable)\r\n- [ ] Breaking change (fix or feature that would cause existing functionality to change)\r\n- [ ] Library ABI change (libzfs, libzfs\\_core, libnvpair, libuutil and libzfsbootenv)\r\n- [ ] Documentation (a change to man pages or other documentation)\r\n\r\n### Checklist:\r\n<!--- Go over all the following points, and put an `x` in all the boxes that apply. -->\r\n<!--- If you're unsure about any of these, don't hesitate to ask. We're here to help! -->\r\n- [x] My code follows the OpenZFS [code style requirements](https://github.com/openzfs/zfs/blob/master/.github/CONTRIBUTING.md#coding-conventions).\r\n- [x] I have updated the documentation accordingly.\r\n- [x] I have read the [**contributing** document](https://github.com/openzfs/zfs/blob/master/.github/CONTRIBUTING.md).\r\n- [x] I have added [tests](https://github.com/openzfs/zfs/tree/master/tests) to cover my changes.\r\n- [x] I have run the ZFS Test Suite with this change applied.\r\n- [x] All commit messages are properly formatted and contain [`Signed-off-by`](https://github.com/openzfs/zfs/blob/master/.github/CONTRIBUTING.md#signed-off-by).\r\n",
      "@behlendorf Hi, I've found time to build/run testcases locally. I have now moved some of the testing into a new test case and in the last force-push updated only the assertions in that test case. I have run the new test-case locally and it goes through, so I am resonably sure that we shouldn't see any CI-Failure caused by the changes.\r\n\r\nI'd say that this PR is now ready for review, but I can't remove the \"Work-In-Progress\"-Label. It would be nice, if you could do that.",
      "Do you know when this pull request will make it into the official release? I see it merged in the master branch, but the code is not making in the official releases"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95\n\nThe patch corrects the handling of IPv6 addresses in NFS shares, addressing the exploit linked to CVE-2013-20001, making it a security fix."
}