{
  "cve_id": "CVE-2021-29623",
  "cwe_ids": [
    "CWE-908"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:N/A:N",
  "cvss_is_v3": false,
  "repo_name": "Exiv2/exiv2",
  "commit_msg": "Use readOrThrow to check error conditions of iIo.read().",
  "commit_hash": "82e46b5524fb904e6660dadd2c6d8e5e47375a1a",
  "git_url": "https://github.com/Exiv2/exiv2/commit/82e46b5524fb904e6660dadd2c6d8e5e47375a1a",
  "file_path": "src/webpimage.cpp",
  "func_name": "isWebPType",
  "func_before": "bool isWebPType(BasicIo& iIo, bool /*advance*/)\n    {\n        if (iIo.size() < 12) {\n          return false;\n        }\n        const int32_t len = 4;\n        const unsigned char RiffImageId[4] = { 'R', 'I', 'F' ,'F'};\n        const unsigned char WebPImageId[4] = { 'W', 'E', 'B' ,'P'};\n        byte webp[len];\n        byte data[len];\n        byte riff[len];\n        iIo.read(riff, len);\n        iIo.read(data, len);\n        iIo.read(webp, len);\n        bool matched_riff = (memcmp(riff, RiffImageId, len) == 0);\n        bool matched_webp = (memcmp(webp, WebPImageId, len) == 0);\n        iIo.seek(-12, BasicIo::cur);\n        return matched_riff && matched_webp;\n    }",
  "abstract_func_before": "bool isWebPType(BasicIo& VAR_0, bool /* COMMENT_0 */)\n    {\n        if (VAR_0.size() < 12) {\n          return false;\n        }\n        const int32_t VAR_1 = 4;\n        const unsigned char VAR_2[4] = { 'R', 'I', 'F' ,'F'};\n        const unsigned char VAR_3[4] = { 'W', 'E', 'B' ,'P'};\n        byte VAR_4[VAR_1];\n        byte VAR_5[VAR_1];\n        byte VAR_6[VAR_1];\n        VAR_0.read(VAR_6, VAR_1);\n        VAR_0.read(VAR_5, VAR_1);\n        VAR_0.read(VAR_4, VAR_1);\n        bool VAR_7 = (memcmp(VAR_6, VAR_2, VAR_1) == 0);\n        bool VAR_8 = (memcmp(VAR_4, VAR_3, VAR_1) == 0);\n        VAR_0.seek(-12, BasicIo::cur);\n        return VAR_7 && VAR_8;\n    }",
  "func_graph_path_before": "Exiv2/exiv2/82e46b5524fb904e6660dadd2c6d8e5e47375a1a/webpimage.cpp/vul/before/0.json",
  "func": "bool isWebPType(BasicIo& iIo, bool /*advance*/)\n    {\n        if (iIo.size() < 12) {\n          return false;\n        }\n        const int32_t len = 4;\n        const unsigned char RiffImageId[4] = { 'R', 'I', 'F' ,'F'};\n        const unsigned char WebPImageId[4] = { 'W', 'E', 'B' ,'P'};\n        byte webp[len];\n        byte data[len];\n        byte riff[len];\n        readOrThrow(iIo, riff, len, Exiv2::kerCorruptedMetadata);\n        readOrThrow(iIo, data, len, Exiv2::kerCorruptedMetadata);\n        readOrThrow(iIo, webp, len, Exiv2::kerCorruptedMetadata);\n        bool matched_riff = (memcmp(riff, RiffImageId, len) == 0);\n        bool matched_webp = (memcmp(webp, WebPImageId, len) == 0);\n        iIo.seek(-12, BasicIo::cur);\n        return matched_riff && matched_webp;\n    }",
  "abstract_func": "bool isWebPType(BasicIo& VAR_0, bool /* COMMENT_0 */)\n    {\n        if (VAR_0.size() < 12) {\n          return false;\n        }\n        const int32_t VAR_1 = 4;\n        const unsigned char VAR_2[4] = { 'R', 'I', 'F' ,'F'};\n        const unsigned char VAR_3[4] = { 'W', 'E', 'B' ,'P'};\n        byte VAR_4[VAR_1];\n        byte VAR_5[VAR_1];\n        byte VAR_6[VAR_1];\n        readOrThrow(VAR_0, VAR_6, VAR_1, Exiv2::kerCorruptedMetadata);\n        readOrThrow(VAR_0, VAR_5, VAR_1, Exiv2::kerCorruptedMetadata);\n        readOrThrow(VAR_0, VAR_4, VAR_1, Exiv2::kerCorruptedMetadata);\n        bool VAR_7 = (memcmp(VAR_6, VAR_2, VAR_1) == 0);\n        bool VAR_8 = (memcmp(VAR_4, VAR_3, VAR_1) == 0);\n        VAR_0.seek(-12, BasicIo::cur);\n        return VAR_7 && VAR_8;\n    }",
  "func_graph_path": "Exiv2/exiv2/82e46b5524fb904e6660dadd2c6d8e5e47375a1a/webpimage.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -9,9 +9,9 @@\n         byte webp[len];\n         byte data[len];\n         byte riff[len];\n-        iIo.read(riff, len);\n-        iIo.read(data, len);\n-        iIo.read(webp, len);\n+        readOrThrow(iIo, riff, len, Exiv2::kerCorruptedMetadata);\n+        readOrThrow(iIo, data, len, Exiv2::kerCorruptedMetadata);\n+        readOrThrow(iIo, webp, len, Exiv2::kerCorruptedMetadata);\n         bool matched_riff = (memcmp(riff, RiffImageId, len) == 0);\n         bool matched_webp = (memcmp(webp, WebPImageId, len) == 0);\n         iIo.seek(-12, BasicIo::cur);",
  "diff_line_info": {
    "deleted_lines": [
      "        iIo.read(riff, len);",
      "        iIo.read(data, len);",
      "        iIo.read(webp, len);"
    ],
    "added_lines": [
      "        readOrThrow(iIo, riff, len, Exiv2::kerCorruptedMetadata);",
      "        readOrThrow(iIo, data, len, Exiv2::kerCorruptedMetadata);",
      "        readOrThrow(iIo, webp, len, Exiv2::kerCorruptedMetadata);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/Exiv2/exiv2/pull/1627",
  "description": {
    "pr_info": {
      "title": "Use readOrThrow to check error conditions of io.read()",
      "number": 1627
    },
    "comment": [
      "It is safer to use `readOrThrow`, because it checks against the scenario where reading from the file fails.",
      "@mergifyio backport main",
      "**Command `backport main`: success**\n> **Backports have been created**\n> * [#1636 Use readOrThrow to check error conditions of io.read() (backport #1627)](https://github.com/Exiv2/exiv2/pull/1636) has been created for branch `main`\n",
      "@kevinbackhouse how does this protect against read of uninitialized memory? I'm not intimately familiar with all of the inner workings of Exiv2, but looking at this, I see there is a length check of `iIo.size() < 12`, hardcoded `len = 4` which seems fine. There is a read into `data` and `data` is never actually used, which seems to be just a seek basically. The only issue I could think of is that `iIo` could have uninitialized data somehow. I just don't see how a call to `error()` would prevent that, but I'm not often working on C++ either.",
      "Hi @tcullum-rh, I think you are right in your analysis. I did not notice the `iIo.size() < 12` check at the beginning of the function, which should prevent any situation in which we try to read beyond the `iOo` reserved memory. ",
      "@tcullum-rh: you are right, I misdiagnosed this. I just stepped through it in gdb and figured out what's going on. The poc is a 15 byte file, which is so short that it triggers an error in [isCr2Type](https://github.com/Exiv2/exiv2/blob/c7a41230f0f7e837e8f636408b07817ad5971650/src/cr2image.cpp#L212). Normally, these \"is\" functions (`isCr2Type`, `isJpegType`, etc.) rewind the file back to the beginning. But it looks like most of them don't bother if they get an EOF error.\r\n\r\nSo that's why the `iIo.size() < 12` isn't working: the file hasn't been rewound back to the beginning. So the subsequent calls to `iIo.read` get EOF errors which are ignored.\r\n\r\nEven though I misunderstood the bug, I think my fix is still the right thing to do. `readOrThrow` is safer than checking `iIo.size()`, due to the possibility that file position isn't zero."
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.9"
}