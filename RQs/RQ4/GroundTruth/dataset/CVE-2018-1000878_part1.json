{
  "cve_id": "CVE-2018-1000878",
  "cwe_ids": [
    "CWE-416"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "libarchive",
  "commit_msg": "rar: file split across multi-part archives must match\n\nFuzzing uncovered some UAF and memory overrun bugs where a file in a\nsingle file archive reported that it was split across multiple\nvolumes. This was caused by ppmd7 operations calling\nrar_br_fillup. This would invoke rar_read_ahead, which would in some\nsituations invoke archive_read_format_rar_read_header.  That would\ncheck the new file name against the old file name, and if they didn't\nmatch up it would free the ppmd7 buffer and allocate a new\none. However, because the ppmd7 decoder wasn't actually done with the\nbuffer, it would continue to used the freed buffer. Both reads and\nwrites to the freed region can be observed.\n\nThis is quite tricky to solve: once the buffer has been freed it is\ntoo late, as the ppmd7 decoder functions almost universally assume\nsuccess - there's no way for ppmd_read to signal error, nor are there\ngood ways for functions like Range_Normalise to propagate them. So we\ncan't detect after the fact that we're in an invalid state - e.g. by\nchecking rar->cursor, we have to prevent ourselves from ever ending up\nthere. So, when we are in the dangerous part or rar_read_ahead that\nassumes a valid split, we set a flag force read_header to either go\ndown the path for split files or bail. This means that the ppmd7\ndecoder keeps a valid buffer and just runs out of data.\n\nFound with a combination of AFL, afl-rb and qsym.",
  "commit_hash": "bfcfe6f04ed20db2504db8a254d1f40a1d84eb28",
  "git_url": "https://github.com/libarchive/libarchive/commit/bfcfe6f04ed20db2504db8a254d1f40a1d84eb28",
  "file_path": "libarchive/archive_read_support_format_rar.c",
  "func_name": "rar_read_ahead",
  "func_before": "static const void *\nrar_read_ahead(struct archive_read *a, size_t min, ssize_t *avail)\n{\n  struct rar *rar = (struct rar *)(a->format->data);\n  const void *h = __archive_read_ahead(a, min, avail);\n  int ret;\n  if (avail)\n  {\n    if (a->archive.read_data_is_posix_read && *avail > (ssize_t)a->archive.read_data_requested)\n      *avail = a->archive.read_data_requested;\n    if (*avail > rar->bytes_remaining)\n      *avail = (ssize_t)rar->bytes_remaining;\n    if (*avail < 0)\n      return NULL;\n    else if (*avail == 0 && rar->main_flags & MHD_VOLUME &&\n      rar->file_flags & FHD_SPLIT_AFTER)\n    {\n      ret = archive_read_format_rar_read_header(a, a->entry);\n      if (ret == (ARCHIVE_EOF))\n      {\n        rar->has_endarc_header = 1;\n        ret = archive_read_format_rar_read_header(a, a->entry);\n      }\n      if (ret != (ARCHIVE_OK))\n        return NULL;\n      return rar_read_ahead(a, min, avail);\n    }\n  }\n  return h;\n}",
  "abstract_func_before": "static const void *\nrar_read_ahead(struct archive_read *VAR_0, size_t VAR_1, ssize_t *VAR_2)\n{\n  struct rar *rar = (struct rar *)(VAR_0->format->data);\n  const void *VAR_3 = __archive_read_ahead(VAR_0, VAR_1, VAR_2);\n  int VAR_4;\n  if (VAR_2)\n  {\n    if (VAR_0->archive.read_data_is_posix_read && *VAR_2 > (ssize_t)VAR_0->archive.read_data_requested)\n      *VAR_2 = VAR_0->archive.read_data_requested;\n    if (*VAR_2 > rar->bytes_remaining)\n      *VAR_2 = (ssize_t)rar->bytes_remaining;\n    if (*VAR_2 < 0)\n      return NULL;\n    else if (*VAR_2 == 0 && rar->main_flags & VAR_5 &&\n      rar->file_flags & VAR_6)\n    {\n      VAR_4 = archive_read_format_rar_read_header(VAR_0, VAR_0->entry);\n      if (VAR_4 == (VAR_7))\n      {\n        rar->has_endarc_header = 1;\n        VAR_4 = archive_read_format_rar_read_header(VAR_0, VAR_0->entry);\n      }\n      if (VAR_4 != (VAR_8))\n        return NULL;\n      return rar_read_ahead(VAR_0, VAR_1, VAR_2);\n    }\n  }\n  return VAR_3;\n}",
  "func_graph_path_before": "libarchive/bfcfe6f04ed20db2504db8a254d1f40a1d84eb28/archive_read_support_format_rar.c/vul/before/0.json",
  "func": "static const void *\nrar_read_ahead(struct archive_read *a, size_t min, ssize_t *avail)\n{\n  struct rar *rar = (struct rar *)(a->format->data);\n  const void *h = __archive_read_ahead(a, min, avail);\n  int ret;\n  if (avail)\n  {\n    if (a->archive.read_data_is_posix_read && *avail > (ssize_t)a->archive.read_data_requested)\n      *avail = a->archive.read_data_requested;\n    if (*avail > rar->bytes_remaining)\n      *avail = (ssize_t)rar->bytes_remaining;\n    if (*avail < 0)\n      return NULL;\n    else if (*avail == 0 && rar->main_flags & MHD_VOLUME &&\n      rar->file_flags & FHD_SPLIT_AFTER)\n    {\n      rar->filename_must_match = 1;\n      ret = archive_read_format_rar_read_header(a, a->entry);\n      if (ret == (ARCHIVE_EOF))\n      {\n        rar->has_endarc_header = 1;\n        ret = archive_read_format_rar_read_header(a, a->entry);\n      }\n      rar->filename_must_match = 0;\n      if (ret != (ARCHIVE_OK))\n        return NULL;\n      return rar_read_ahead(a, min, avail);\n    }\n  }\n  return h;\n}",
  "abstract_func": "static const void *\nrar_read_ahead(struct archive_read *VAR_0, size_t VAR_1, ssize_t *VAR_2)\n{\n  struct rar *rar = (struct rar *)(VAR_0->format->data);\n  const void *VAR_3 = __archive_read_ahead(VAR_0, VAR_1, VAR_2);\n  int VAR_4;\n  if (VAR_2)\n  {\n    if (VAR_0->archive.read_data_is_posix_read && *VAR_2 > (ssize_t)VAR_0->archive.read_data_requested)\n      *VAR_2 = VAR_0->archive.read_data_requested;\n    if (*VAR_2 > rar->bytes_remaining)\n      *VAR_2 = (ssize_t)rar->bytes_remaining;\n    if (*VAR_2 < 0)\n      return NULL;\n    else if (*VAR_2 == 0 && rar->main_flags & VAR_5 &&\n      rar->file_flags & VAR_6)\n    {\n      rar->filename_must_match = 1;\n      VAR_4 = archive_read_format_rar_read_header(VAR_0, VAR_0->entry);\n      if (VAR_4 == (VAR_7))\n      {\n        rar->has_endarc_header = 1;\n        VAR_4 = archive_read_format_rar_read_header(VAR_0, VAR_0->entry);\n      }\n      rar->filename_must_match = 0;\n      if (VAR_4 != (VAR_8))\n        return NULL;\n      return rar_read_ahead(VAR_0, VAR_1, VAR_2);\n    }\n  }\n  return VAR_3;\n}",
  "func_graph_path": "libarchive/bfcfe6f04ed20db2504db8a254d1f40a1d84eb28/archive_read_support_format_rar.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -15,12 +15,14 @@\n     else if (*avail == 0 && rar->main_flags & MHD_VOLUME &&\n       rar->file_flags & FHD_SPLIT_AFTER)\n     {\n+      rar->filename_must_match = 1;\n       ret = archive_read_format_rar_read_header(a, a->entry);\n       if (ret == (ARCHIVE_EOF))\n       {\n         rar->has_endarc_header = 1;\n         ret = archive_read_format_rar_read_header(a, a->entry);\n       }\n+      rar->filename_must_match = 0;\n       if (ret != (ARCHIVE_OK))\n         return NULL;\n       return rar_read_ahead(a, min, avail);",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "      rar->filename_must_match = 1;",
      "      rar->filename_must_match = 0;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libarchive/libarchive/pull/1105",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/libarchive/libarchive/pull/1105: 403 Client Error: Forbidden for url: https://api.github.com/repos/libarchive/libarchive/issues/1105/comments",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}