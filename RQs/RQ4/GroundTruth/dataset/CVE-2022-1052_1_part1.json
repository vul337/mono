{
  "cve_id": "CVE-2022-1052",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "AV:L/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "radareorg/radare2",
  "commit_msg": "Fix heap OOB read in macho.iterate_chained_fixups ##crash\n\n* Reported by peacock-doris via huntr.dev\r\n* Reproducer 'tests_65305'\r\n\r\nmrmacete:\r\n* Return early if segs_count is 0\r\n* Initialize segs_count also for reconstructed fixups\r\n\r\nCo-authored-by: pancake <pancake@nopcode.org>\r\nCo-authored-by: Francesco Tamagni <mrmacete@protonmail.ch>",
  "commit_hash": "0052500c1ed5bf8263b26b9fd7773dbdc6f170c4",
  "git_url": "https://github.com/radareorg/radare2/commit/0052500c1ed5bf8263b26b9fd7773dbdc6f170c4",
  "file_path": "libr/bin/format/mach0/mach0.c",
  "func_name": "parse_chained_fixups",
  "func_before": "static bool parse_chained_fixups(struct MACH0_(obj_t) *bin, ut32 offset, ut32 size) {\n\tstruct dyld_chained_fixups_header header;\n\tif (size < sizeof (header)) {\n\t\treturn false;\n\t}\n\tif (r_buf_fread_at (bin->b, offset, (ut8 *)&header, \"7i\", 1) != sizeof (header)) {\n\t\treturn false;\n\t}\n\tif (header.fixups_version > 0) {\n\t\teprintf (\"Unsupported fixups version: %u\\n\", header.fixups_version);\n\t\treturn false;\n\t}\n\tut64 starts_at = offset + header.starts_offset;\n\tif (header.starts_offset > size) {\n\t\treturn false;\n\t}\n\tut32 segs_count;\n\tif ((segs_count = r_buf_read_le32_at (bin->b, starts_at)) == UT32_MAX) {\n\t\treturn false;\n\t}\n\tbin->chained_starts = R_NEWS0 (struct r_dyld_chained_starts_in_segment *, segs_count);\n\tif (!bin->chained_starts) {\n\t\treturn false;\n\t}\n\tbin->fixups_header = header;\n\tbin->fixups_offset = offset;\n\tbin->fixups_size = size;\n\tsize_t i;\n\tut64 cursor = starts_at + sizeof (ut32);\n\tut64 bsize = r_buf_size (bin->b);\n\tfor (i = 0; i < segs_count && cursor + 4 < bsize; i++) {\n\t\tut32 seg_off;\n\t\tif ((seg_off = r_buf_read_le32_at (bin->b, cursor)) == UT32_MAX || !seg_off) {\n\t\t\tcursor += sizeof (ut32);\n\t\t\tcontinue;\n\t\t}\n\t\tif (i >= bin->nsegs) {\n\t\t\tbreak;\n\t\t}\n\t\tstruct r_dyld_chained_starts_in_segment *cur_seg = R_NEW0 (struct r_dyld_chained_starts_in_segment);\n\t\tif (!cur_seg) {\n\t\t\treturn false;\n\t\t}\n\t\tbin->chained_starts[i] = cur_seg;\n\t\tif (r_buf_fread_at (bin->b, starts_at + seg_off, (ut8 *)cur_seg, \"isslis\", 1) != 22) {\n\t\t\treturn false;\n\t\t}\n\t\tif (cur_seg->page_count > 0) {\n\t\t\tut16 *page_start = malloc (sizeof (ut16) * cur_seg->page_count);\n\t\t\tif (!page_start) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (bin->b, starts_at + seg_off + 22, (ut8 *)page_start, \"s\", cur_seg->page_count)\n\t\t\t\t\t!= cur_seg->page_count * 2) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tcur_seg->page_start = page_start;\n\t\t}\n\t\tcursor += sizeof (ut32);\n\t}\n\t/* TODO: handle also imports, symbols and multiple starts (32-bit only) */\n\treturn true;\n}",
  "abstract_func_before": "static bool parse_chained_fixups(struct MACH0_(obj_t) *VAR_0, ut32 VAR_1, ut32 VAR_2) {\n\tstruct dyld_chained_fixups_header VAR_3;\n\tif (VAR_2 < sizeof (VAR_3)) {\n\t\treturn false;\n\t}\n\tif (r_buf_fread_at (VAR_0->b, VAR_1, (ut8 *)&VAR_3, \"7i\", 1) != sizeof (VAR_3)) {\n\t\treturn false;\n\t}\n\tif (VAR_3.fixups_version > 0) {\n\t\teprintf (\"Unsupported fixups version: %u\\n\", VAR_3.fixups_version);\n\t\treturn false;\n\t}\n\tut64 VAR_4 = VAR_1 + VAR_3.starts_offset;\n\tif (VAR_3.starts_offset > VAR_2) {\n\t\treturn false;\n\t}\n\tut32 VAR_5;\n\tif ((VAR_5 = r_buf_read_le32_at (VAR_0->b, VAR_4)) == VAR_6) {\n\t\treturn false;\n\t}\n\tVAR_0->chained_starts = R_NEWS0 (struct VAR_7 *, VAR_5);\n\tif (!VAR_0->chained_starts) {\n\t\treturn false;\n\t}\n\tVAR_0->fixups_header = VAR_3;\n\tVAR_0->fixups_offset = VAR_1;\n\tVAR_0->fixups_size = VAR_2;\n\tsize_t VAR_8;\n\tut64 VAR_9 = VAR_4 + sizeof (ut32);\n\tut64 VAR_10 = r_buf_size (VAR_0->b);\n\tfor (VAR_8 = 0; VAR_8 < VAR_5 && VAR_9 + 4 < VAR_10; VAR_8++) {\n\t\tut32 VAR_11;\n\t\tif ((VAR_11 = r_buf_read_le32_at (VAR_0->b, VAR_9)) == VAR_6 || !VAR_11) {\n\t\t\tVAR_9 += sizeof (ut32);\n\t\t\tcontinue;\n\t\t}\n\t\tif (VAR_8 >= VAR_0->nsegs) {\n\t\t\tbreak;\n\t\t}\n\t\tstruct r_dyld_chained_starts_in_segment *VAR_12 = R_NEW0 (struct r_dyld_chained_starts_in_segment);\n\t\tif (!VAR_12) {\n\t\t\treturn false;\n\t\t}\n\t\tVAR_0->chained_starts[VAR_8] = VAR_12;\n\t\tif (r_buf_fread_at (VAR_0->b, VAR_4 + VAR_11, (ut8 *)VAR_12, \"isslis\", 1) != 22) {\n\t\t\treturn false;\n\t\t}\n\t\tif (VAR_12->page_count > 0) {\n\t\t\tut16 *VAR_13 = malloc (sizeof (ut16) * VAR_12->page_count);\n\t\t\tif (!VAR_13) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (VAR_0->b, VAR_4 + VAR_11 + 22, (ut8 *)VAR_13, \"s\", VAR_12->page_count)\n\t\t\t\t\t!= VAR_12->page_count * 2) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tVAR_12->page_start = VAR_13;\n\t\t}\n\t\tVAR_9 += sizeof (ut32);\n\t}\n\t/* COMMENT_0 */\n\treturn true;\n}",
  "func_graph_path_before": null,
  "func": "static bool parse_chained_fixups(struct MACH0_(obj_t) *bin, ut32 offset, ut32 size) {\n\tstruct dyld_chained_fixups_header header;\n\tif (size < sizeof (header)) {\n\t\treturn false;\n\t}\n\tif (r_buf_fread_at (bin->b, offset, (ut8 *)&header, \"7i\", 1) != sizeof (header)) {\n\t\treturn false;\n\t}\n\tif (header.fixups_version > 0) {\n\t\teprintf (\"Unsupported fixups version: %u\\n\", header.fixups_version);\n\t\treturn false;\n\t}\n\tut64 starts_at = offset + header.starts_offset;\n\tif (header.starts_offset > size) {\n\t\treturn false;\n\t}\n\tut32 segs_count = r_buf_read_le32_at (bin->b, starts_at);\n\tif (segs_count == UT32_MAX || segs_count == 0) {\n\t\treturn false;\n\t}\n\tbin->segs_count = segs_count;\n\tbin->chained_starts = R_NEWS0 (struct r_dyld_chained_starts_in_segment *, segs_count);\n\tif (!bin->chained_starts) {\n\t\treturn false;\n\t}\n\tbin->fixups_header = header;\n\tbin->fixups_offset = offset;\n\tbin->fixups_size = size;\n\tsize_t i;\n\tut64 cursor = starts_at + sizeof (ut32);\n\tut64 bsize = r_buf_size (bin->b);\n\tfor (i = 0; i < segs_count && cursor + 4 < bsize; i++) {\n\t\tut32 seg_off;\n\t\tif ((seg_off = r_buf_read_le32_at (bin->b, cursor)) == UT32_MAX || !seg_off) {\n\t\t\tcursor += sizeof (ut32);\n\t\t\tcontinue;\n\t\t}\n\t\tif (i >= bin->nsegs) {\n\t\t\tbreak;\n\t\t}\n\t\tstruct r_dyld_chained_starts_in_segment *cur_seg = R_NEW0 (struct r_dyld_chained_starts_in_segment);\n\t\tif (!cur_seg) {\n\t\t\treturn false;\n\t\t}\n\t\tbin->chained_starts[i] = cur_seg;\n\t\tif (r_buf_fread_at (bin->b, starts_at + seg_off, (ut8 *)cur_seg, \"isslis\", 1) != 22) {\n\t\t\treturn false;\n\t\t}\n\t\tif (cur_seg->page_count > 0) {\n\t\t\tut16 *page_start = malloc (sizeof (ut16) * cur_seg->page_count);\n\t\t\tif (!page_start) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (bin->b, starts_at + seg_off + 22, (ut8 *)page_start, \"s\", cur_seg->page_count)\n\t\t\t\t\t!= cur_seg->page_count * 2) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tcur_seg->page_start = page_start;\n\t\t}\n\t\tcursor += sizeof (ut32);\n\t}\n\t/* TODO: handle also imports, symbols and multiple starts (32-bit only) */\n\treturn true;\n}",
  "abstract_func": "static bool parse_chained_fixups(struct MACH0_(obj_t) *VAR_0, ut32 VAR_1, ut32 VAR_2) {\n\tstruct dyld_chained_fixups_header VAR_3;\n\tif (VAR_2 < sizeof (VAR_3)) {\n\t\treturn false;\n\t}\n\tif (r_buf_fread_at (VAR_0->b, VAR_1, (ut8 *)&VAR_3, \"7i\", 1) != sizeof (VAR_3)) {\n\t\treturn false;\n\t}\n\tif (VAR_3.fixups_version > 0) {\n\t\teprintf (\"Unsupported fixups version: %u\\n\", VAR_3.fixups_version);\n\t\treturn false;\n\t}\n\tut64 VAR_4 = VAR_1 + VAR_3.starts_offset;\n\tif (VAR_3.starts_offset > VAR_2) {\n\t\treturn false;\n\t}\n\tut32 VAR_5 = r_buf_read_le32_at (VAR_0->b, VAR_4);\n\tif (VAR_5 == VAR_6 || VAR_5 == 0) {\n\t\treturn false;\n\t}\n\tVAR_0->segs_count = VAR_5;\n\tVAR_0->chained_starts = R_NEWS0 (struct VAR_7 *, VAR_5);\n\tif (!VAR_0->chained_starts) {\n\t\treturn false;\n\t}\n\tVAR_0->fixups_header = VAR_3;\n\tVAR_0->fixups_offset = VAR_1;\n\tVAR_0->fixups_size = VAR_2;\n\tsize_t VAR_8;\n\tut64 VAR_9 = VAR_4 + sizeof (ut32);\n\tut64 VAR_10 = r_buf_size (VAR_0->b);\n\tfor (VAR_8 = 0; VAR_8 < VAR_5 && VAR_9 + 4 < VAR_10; VAR_8++) {\n\t\tut32 VAR_11;\n\t\tif ((VAR_11 = r_buf_read_le32_at (VAR_0->b, VAR_9)) == VAR_6 || !VAR_11) {\n\t\t\tVAR_9 += sizeof (ut32);\n\t\t\tcontinue;\n\t\t}\n\t\tif (VAR_8 >= VAR_0->nsegs) {\n\t\t\tbreak;\n\t\t}\n\t\tstruct r_dyld_chained_starts_in_segment *VAR_12 = R_NEW0 (struct r_dyld_chained_starts_in_segment);\n\t\tif (!VAR_12) {\n\t\t\treturn false;\n\t\t}\n\t\tVAR_0->chained_starts[VAR_8] = VAR_12;\n\t\tif (r_buf_fread_at (VAR_0->b, VAR_4 + VAR_11, (ut8 *)VAR_12, \"isslis\", 1) != 22) {\n\t\t\treturn false;\n\t\t}\n\t\tif (VAR_12->page_count > 0) {\n\t\t\tut16 *VAR_13 = malloc (sizeof (ut16) * VAR_12->page_count);\n\t\t\tif (!VAR_13) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (VAR_0->b, VAR_4 + VAR_11 + 22, (ut8 *)VAR_13, \"s\", VAR_12->page_count)\n\t\t\t\t\t!= VAR_12->page_count * 2) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tVAR_12->page_start = VAR_13;\n\t\t}\n\t\tVAR_9 += sizeof (ut32);\n\t}\n\t/* COMMENT_0 */\n\treturn true;\n}",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -14,10 +14,11 @@\n \tif (header.starts_offset > size) {\n \t\treturn false;\n \t}\n-\tut32 segs_count;\n-\tif ((segs_count = r_buf_read_le32_at (bin->b, starts_at)) == UT32_MAX) {\n+\tut32 segs_count = r_buf_read_le32_at (bin->b, starts_at);\n+\tif (segs_count == UT32_MAX || segs_count == 0) {\n \t\treturn false;\n \t}\n+\tbin->segs_count = segs_count;\n \tbin->chained_starts = R_NEWS0 (struct r_dyld_chained_starts_in_segment *, segs_count);\n \tif (!bin->chained_starts) {\n \t\treturn false;",
  "diff_line_info": {
    "deleted_lines": [
      "\tut32 segs_count;",
      "\tif ((segs_count = r_buf_read_le32_at (bin->b, starts_at)) == UT32_MAX) {"
    ],
    "added_lines": [
      "\tut32 segs_count = r_buf_read_le32_at (bin->b, starts_at);",
      "\tif (segs_count == UT32_MAX || segs_count == 0) {",
      "\tbin->segs_count = segs_count;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/radareorg/radare2/pull/19859",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/radareorg/radare2/pull/19859: 403 Client Error: Forbidden for url: https://api.github.com/repos/radareorg/radare2/pulls/19859",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "The patch addresses an out-of-bounds heap read vulnerability by adding checks for segs_count being zero or invalid, preventing potential crashes or security issues.\n\n**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95\n\nThe code changes clearly fix an OOB memory access issue, with reported testing and referencing a security reporter."
}