{
  "cve_id": "CVE-2017-1000203",
  "cwe_ids": [
    "CWE-78"
  ],
  "cvss_vector": "AV:N/AC:L/Au:S/C:C/I:C/A:C",
  "cvss_is_v3": false,
  "repo_name": "root-project/root",
  "commit_msg": "rootd: do not use popen() to expand path names (#513)\n\nAddressed security threat reported by S. Luders.\r\nUsing the same technology used in TSystem::ExpandFileName (with clang-format processing).",
  "commit_hash": "88ccff152604e0f1012653a596d802ff7ede3145",
  "git_url": "https://github.com/root-project/root/commit/88ccff152604e0f1012653a596d802ff7ede3145",
  "file_path": "net/rootd/src/rootd.cxx",
  "func_name": "RootdExpandPathName",
  "func_before": "char *RootdExpandPathName(const char *name)\n{\n   const char *patbuf = name;\n\n   // skip leading blanks\n   while (*patbuf == ' ')\n      patbuf++;\n\n   // any shell meta characters?\n   for (const char *p = patbuf; *p; p++)\n      if (strchr(shellMeta, *p))\n         goto needshell;\n\n   return strdup(name);\n\nneedshell:\n   // escape shell quote characters\n   char escPatbuf[kMAXPATHLEN];\n   EscChar(patbuf, escPatbuf, sizeof(escPatbuf), shellStuff, shellEscape);\n\n   char cmd[kMAXPATHLEN];\n#ifdef __hpux\n   strlcpy(cmd, \"/bin/echo \", sizeof(cmd));\n#else\n   strlcpy(cmd, \"echo \", sizeof(cmd));\n#endif\n\n   // emulate csh -> popen executes sh\n   if (escPatbuf[0] == '~') {\n      const char *hd;\n      if (escPatbuf[1] != '\\0' && escPatbuf[1] != '/') {\n         // extract user name\n         char uname[70], *p, *q;\n         for (p = &escPatbuf[1], q = uname; *p && *p !='/';)\n            *q++ = *p++;\n         *q = '\\0';\n         hd = HomeDirectory(uname);\n         if (hd == 0)\n            strcat(cmd, escPatbuf);\n         else {\n            strcat(cmd, hd);\n            strcat(cmd, p);\n         }\n\n      } else {\n         hd = HomeDirectory(0);\n         if (hd == 0) {\n            Error(ErrSys, kErrFatal, \"RootdExpandPathName: no home directory\");\n            return 0;\n         }\n         strcat(cmd, hd);\n         strcat(cmd, &escPatbuf[1]);\n      }\n   } else\n      strcat(cmd, escPatbuf);\n\n   FILE *pf;\n   if ((pf = ::popen(&cmd[0], \"r\")) == 0) {\n      Error(ErrSys, kErrFatal, \"RootdExpandPathName: error in popen(%s)\", cmd);\n      return 0;\n   }\n\n   // read first argument\n   char expPatbuf[kMAXPATHLEN];\n   int  ch, i, cnt = 0;\nagain:\n   for (i = 0, ch = fgetc(pf); ch != EOF && ch != ' ' && ch != '\\n'; i++, ch = fgetc(pf)) {\n      expPatbuf[i] = ch;\n      cnt++;\n   }\n   // this will be true if forked process was not yet ready to be read\n   if (cnt == 0 && ch == EOF) goto again;\n   expPatbuf[cnt] = '\\0';\n\n   // skip rest of pipe\n   while (ch != EOF) {\n      ch = fgetc(pf);\n      if (ch == ' ' || ch == '\\t') {\n         ::pclose(pf);\n         Error(ErrFatal, kErrFatal, \"RootdExpandPathName: expression ambigous\");\n         return 0;\n      }\n   }\n\n   ::pclose(pf);\n\n   return strdup(expPatbuf);\n}",
  "abstract_func_before": "char *RootdExpandPathName(const char *VAR_0)\n{\n   const char *VAR_1 = VAR_0;\n\n   /* COMMENT_0 */\n   while (*VAR_1 == ' ')\n      VAR_1++;\n\n   /* COMMENT_1 */\n   for (const char *VAR_2 = VAR_1; *VAR_2; VAR_2++)\n      if (strchr(VAR_3, *VAR_2))\n         goto needshell;\n\n   return strdup(VAR_0);\n\nneedshell:\n   /* COMMENT_2 */\n   char VAR_4[VAR_5];\n   EscChar(VAR_1, VAR_4, sizeof(VAR_4), VAR_6, VAR_7);\n\n   char VAR_8[VAR_5];\n#ifdef VAR_9\n   strlcpy(VAR_8, \"/bin/echo \", sizeof(VAR_8));\n#else\n   strlcpy(VAR_8, \"echo \", sizeof(VAR_8));\n#endif\n\n   /* COMMENT_3 */\n   if (VAR_4[0] == '~') {\n      const char *VAR_10;\n      if (VAR_4[1] != '\\0' && VAR_4[1] != '/') {\n         /* COMMENT_4 */\n         char VAR_11[70], *VAR_2, *VAR_12;\n         for (VAR_2 = &VAR_4[1], VAR_12 = VAR_11; *VAR_2 && *VAR_2 !='/';)\n            *VAR_12++ = *VAR_2++;\n         *VAR_12 = '\\0';\n         VAR_10 = HomeDirectory(VAR_11);\n         if (VAR_10 == 0)\n            strcat(VAR_8, VAR_4);\n         else {\n            strcat(VAR_8, VAR_10);\n            strcat(VAR_8, VAR_2);\n         }\n\n      } else {\n         VAR_10 = HomeDirectory(0);\n         if (VAR_10 == 0) {\n            Error(VAR_13, VAR_14, \"RootdExpandPathName: no home directory\");\n            return 0;\n         }\n         strcat(VAR_8, VAR_10);\n         strcat(VAR_8, &VAR_4[1]);\n      }\n   } else\n      strcat(VAR_8, VAR_4);\n\n   FILE *VAR_15;\n   if ((VAR_15 = ::popen(&VAR_8[0], \"r\")) == 0) {\n      Error(VAR_13, VAR_14, \"RootdExpandPathName: error in popen(%s)\", VAR_8);\n      return 0;\n   }\n\n   /* COMMENT_5 */\n   char VAR_16[VAR_5];\n   int  VAR_17, VAR_18, VAR_19 = 0;\nagain:\n   for (VAR_18 = 0, VAR_17 = fgetc(VAR_15); VAR_17 != VAR_20 && VAR_17 != ' ' && VAR_17 != '\\n'; VAR_18++, VAR_17 = fgetc(VAR_15)) {\n      VAR_16[VAR_18] = VAR_17;\n      VAR_19++;\n   }\n   /* COMMENT_6 */\n   if (VAR_19 == 0 && VAR_17 == VAR_20) goto again;\n   VAR_16[VAR_19] = '\\0';\n\n   /* COMMENT_7 */\n   while (VAR_17 != VAR_20) {\n      VAR_17 = fgetc(VAR_15);\n      if (VAR_17 == ' ' || VAR_17 == '\\t') {\n         ::pclose(VAR_15);\n         Error(VAR_21, VAR_14, \"RootdExpandPathName: expression ambigous\");\n         return 0;\n      }\n   }\n\n   ::pclose(VAR_15);\n\n   return strdup(VAR_16);\n}",
  "func_graph_path_before": "root-project/root/88ccff152604e0f1012653a596d802ff7ede3145/rootd.cxx/vul/before/0.json",
  "func": "char *RootdExpandPathName(const char *name)\n{\n   const char *patbuf = name;\n\n   // skip leading blanks\n   while (*patbuf == ' ') patbuf++;\n\n   // any shell meta characters?\n   bool needesc = false;\n   for (const char *p = patbuf; *p; p++)\n      if (strchr(shellMeta, *p)) {\n         needesc = true;\n         break;\n      }\n\n   // Escape meta characters, if required\n   if (needesc) {\n      const int kBufSize = kMAXPATHLEN;\n      char xname[kBufSize];\n      if (RootdExpandFileName(name, xname, kBufSize)) {\n         Error(ErrFatal, kErrFatal, \"RootdExpandPathName: problem escaping meta characters\");\n         return 0;\n      } else {\n         return strdup(xname);\n      }\n   }\n   return strdup(name);\n}",
  "abstract_func": "char *RootdExpandPathName(const char *VAR_0)\n{\n   const char *VAR_1 = VAR_0;\n\n   /* COMMENT_0 */\n   while (*VAR_1 == ' ') VAR_1++;\n\n   /* COMMENT_1 */\n   bool VAR_2 = false;\n   for (const char *VAR_3 = VAR_1; *VAR_3; VAR_3++)\n      if (strchr(VAR_4, *VAR_3)) {\n         VAR_2 = true;\n         break;\n      }\n\n   /* COMMENT_2 */\n   if (VAR_2) {\n      const int VAR_5 = VAR_6;\n      char VAR_7[VAR_5];\n      if (RootdExpandFileName(VAR_0, VAR_7, VAR_5)) {\n         Error(VAR_8, VAR_9, \"RootdExpandPathName: problem escaping meta characters\");\n         return 0;\n      } else {\n         return strdup(VAR_7);\n      }\n   }\n   return strdup(VAR_0);\n}",
  "func_graph_path": "root-project/root/88ccff152604e0f1012653a596d802ff7ede3145/rootd.cxx/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -3,86 +3,26 @@\n    const char *patbuf = name;\n \n    // skip leading blanks\n-   while (*patbuf == ' ')\n-      patbuf++;\n+   while (*patbuf == ' ') patbuf++;\n \n    // any shell meta characters?\n+   bool needesc = false;\n    for (const char *p = patbuf; *p; p++)\n-      if (strchr(shellMeta, *p))\n-         goto needshell;\n+      if (strchr(shellMeta, *p)) {\n+         needesc = true;\n+         break;\n+      }\n \n-   return strdup(name);\n-\n-needshell:\n-   // escape shell quote characters\n-   char escPatbuf[kMAXPATHLEN];\n-   EscChar(patbuf, escPatbuf, sizeof(escPatbuf), shellStuff, shellEscape);\n-\n-   char cmd[kMAXPATHLEN];\n-#ifdef __hpux\n-   strlcpy(cmd, \"/bin/echo \", sizeof(cmd));\n-#else\n-   strlcpy(cmd, \"echo \", sizeof(cmd));\n-#endif\n-\n-   // emulate csh -> popen executes sh\n-   if (escPatbuf[0] == '~') {\n-      const char *hd;\n-      if (escPatbuf[1] != '\\0' && escPatbuf[1] != '/') {\n-         // extract user name\n-         char uname[70], *p, *q;\n-         for (p = &escPatbuf[1], q = uname; *p && *p !='/';)\n-            *q++ = *p++;\n-         *q = '\\0';\n-         hd = HomeDirectory(uname);\n-         if (hd == 0)\n-            strcat(cmd, escPatbuf);\n-         else {\n-            strcat(cmd, hd);\n-            strcat(cmd, p);\n-         }\n-\n+   // Escape meta characters, if required\n+   if (needesc) {\n+      const int kBufSize = kMAXPATHLEN;\n+      char xname[kBufSize];\n+      if (RootdExpandFileName(name, xname, kBufSize)) {\n+         Error(ErrFatal, kErrFatal, \"RootdExpandPathName: problem escaping meta characters\");\n+         return 0;\n       } else {\n-         hd = HomeDirectory(0);\n-         if (hd == 0) {\n-            Error(ErrSys, kErrFatal, \"RootdExpandPathName: no home directory\");\n-            return 0;\n-         }\n-         strcat(cmd, hd);\n-         strcat(cmd, &escPatbuf[1]);\n-      }\n-   } else\n-      strcat(cmd, escPatbuf);\n-\n-   FILE *pf;\n-   if ((pf = ::popen(&cmd[0], \"r\")) == 0) {\n-      Error(ErrSys, kErrFatal, \"RootdExpandPathName: error in popen(%s)\", cmd);\n-      return 0;\n-   }\n-\n-   // read first argument\n-   char expPatbuf[kMAXPATHLEN];\n-   int  ch, i, cnt = 0;\n-again:\n-   for (i = 0, ch = fgetc(pf); ch != EOF && ch != ' ' && ch != '\\n'; i++, ch = fgetc(pf)) {\n-      expPatbuf[i] = ch;\n-      cnt++;\n-   }\n-   // this will be true if forked process was not yet ready to be read\n-   if (cnt == 0 && ch == EOF) goto again;\n-   expPatbuf[cnt] = '\\0';\n-\n-   // skip rest of pipe\n-   while (ch != EOF) {\n-      ch = fgetc(pf);\n-      if (ch == ' ' || ch == '\\t') {\n-         ::pclose(pf);\n-         Error(ErrFatal, kErrFatal, \"RootdExpandPathName: expression ambigous\");\n-         return 0;\n+         return strdup(xname);\n       }\n    }\n-\n-   ::pclose(pf);\n-\n-   return strdup(expPatbuf);\n+   return strdup(name);\n }",
  "diff_line_info": {
    "deleted_lines": [
      "   while (*patbuf == ' ')",
      "      patbuf++;",
      "      if (strchr(shellMeta, *p))",
      "         goto needshell;",
      "   return strdup(name);",
      "",
      "needshell:",
      "   // escape shell quote characters",
      "   char escPatbuf[kMAXPATHLEN];",
      "   EscChar(patbuf, escPatbuf, sizeof(escPatbuf), shellStuff, shellEscape);",
      "",
      "   char cmd[kMAXPATHLEN];",
      "#ifdef __hpux",
      "   strlcpy(cmd, \"/bin/echo \", sizeof(cmd));",
      "#else",
      "   strlcpy(cmd, \"echo \", sizeof(cmd));",
      "#endif",
      "",
      "   // emulate csh -> popen executes sh",
      "   if (escPatbuf[0] == '~') {",
      "      const char *hd;",
      "      if (escPatbuf[1] != '\\0' && escPatbuf[1] != '/') {",
      "         // extract user name",
      "         char uname[70], *p, *q;",
      "         for (p = &escPatbuf[1], q = uname; *p && *p !='/';)",
      "            *q++ = *p++;",
      "         *q = '\\0';",
      "         hd = HomeDirectory(uname);",
      "         if (hd == 0)",
      "            strcat(cmd, escPatbuf);",
      "         else {",
      "            strcat(cmd, hd);",
      "            strcat(cmd, p);",
      "         }",
      "",
      "         hd = HomeDirectory(0);",
      "         if (hd == 0) {",
      "            Error(ErrSys, kErrFatal, \"RootdExpandPathName: no home directory\");",
      "            return 0;",
      "         }",
      "         strcat(cmd, hd);",
      "         strcat(cmd, &escPatbuf[1]);",
      "      }",
      "   } else",
      "      strcat(cmd, escPatbuf);",
      "",
      "   FILE *pf;",
      "   if ((pf = ::popen(&cmd[0], \"r\")) == 0) {",
      "      Error(ErrSys, kErrFatal, \"RootdExpandPathName: error in popen(%s)\", cmd);",
      "      return 0;",
      "   }",
      "",
      "   // read first argument",
      "   char expPatbuf[kMAXPATHLEN];",
      "   int  ch, i, cnt = 0;",
      "again:",
      "   for (i = 0, ch = fgetc(pf); ch != EOF && ch != ' ' && ch != '\\n'; i++, ch = fgetc(pf)) {",
      "      expPatbuf[i] = ch;",
      "      cnt++;",
      "   }",
      "   // this will be true if forked process was not yet ready to be read",
      "   if (cnt == 0 && ch == EOF) goto again;",
      "   expPatbuf[cnt] = '\\0';",
      "",
      "   // skip rest of pipe",
      "   while (ch != EOF) {",
      "      ch = fgetc(pf);",
      "      if (ch == ' ' || ch == '\\t') {",
      "         ::pclose(pf);",
      "         Error(ErrFatal, kErrFatal, \"RootdExpandPathName: expression ambigous\");",
      "         return 0;",
      "",
      "   ::pclose(pf);",
      "",
      "   return strdup(expPatbuf);"
    ],
    "added_lines": [
      "   while (*patbuf == ' ') patbuf++;",
      "   bool needesc = false;",
      "      if (strchr(shellMeta, *p)) {",
      "         needesc = true;",
      "         break;",
      "      }",
      "   // Escape meta characters, if required",
      "   if (needesc) {",
      "      const int kBufSize = kMAXPATHLEN;",
      "      char xname[kBufSize];",
      "      if (RootdExpandFileName(name, xname, kBufSize)) {",
      "         Error(ErrFatal, kErrFatal, \"RootdExpandPathName: problem escaping meta characters\");",
      "         return 0;",
      "         return strdup(xname);",
      "   return strdup(name);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/root-project/root/pull/513",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/root-project/root/pull/513: 403 Client Error: Forbidden for url: https://api.github.com/repos/root-project/root/pulls/513",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}