{
  "cve_id": "CVE-2021-37501",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "HDFGroup/hdf5",
  "commit_msg": "Remove duplicate code\n\nSigned-off-by: Egbert Eich <eich@suse.com>",
  "commit_hash": "6463322c70b1080aba687fc61c5eaa0a0a3f3be9",
  "git_url": "https://github.com/HDFGroup/hdf5/commit/6463322c70b1080aba687fc61c5eaa0a0a3f3be9",
  "file_path": "src/H5Oattr.c",
  "func_name": "H5O__attr_decode",
  "func_before": "static void *\nH5O__attr_decode(H5F_t *f, H5O_t *open_oh, unsigned H5_ATTR_UNUSED mesg_flags, unsigned *ioflags,\n                 size_t p_size, const uint8_t *p)\n{\n    H5A_t        *attr = NULL;\n    H5S_extent_t *extent;           /*extent dimensionality information  */\n    size_t        name_len;         /*attribute name length */\n    size_t        dt_size;          /* Datatype size */\n    hssize_t      sds_size;         /* Signed Dataspace size */\n    hsize_t       ds_size;          /* Dataspace size */\n    unsigned      flags     = 0;    /* Attribute flags */\n    H5A_t        *ret_value = NULL; /* Return value */\n\n    FUNC_ENTER_PACKAGE\n\n    /* check args */\n    HDassert(f);\n    HDassert(p);\n\n    if (NULL == (attr = H5FL_CALLOC(H5A_t)))\n        HGOTO_ERROR(H5E_RESOURCE, H5E_NOSPACE, NULL, \"memory allocation failed\")\n\n    if (NULL == (attr->shared = H5FL_CALLOC(H5A_shared_t)))\n        HGOTO_ERROR(H5E_FILE, H5E_NOSPACE, NULL, \"can't allocate shared attr structure\")\n\n    /* Version number */\n    attr->shared->version = *p++;\n    if (attr->shared->version < H5O_ATTR_VERSION_1 || attr->shared->version > H5O_ATTR_VERSION_LATEST)\n        HGOTO_ERROR(H5E_ATTR, H5E_CANTLOAD, NULL, \"bad version number for attribute message\")\n\n    /* Get the flags byte if we have a later version of the attribute */\n    if (attr->shared->version >= H5O_ATTR_VERSION_2) {\n        flags = *p++;\n\n        /* Check for unknown flag */\n        if (flags & (unsigned)~H5O_ATTR_FLAG_ALL)\n            HGOTO_ERROR(H5E_ATTR, H5E_CANTLOAD, NULL, \"unknown flag for attribute message\")\n    } /* end if */\n    else\n        p++; /* Byte is unused when version<2 */\n\n    /*\n     * Decode the sizes of the parts of the attribute.  The sizes stored in\n     * the file are exact but the parts are aligned on 8-byte boundaries.\n     */\n    UINT16DECODE(p, name_len); /*including null*/\n    UINT16DECODE(p, attr->shared->dt_size);\n    UINT16DECODE(p, attr->shared->ds_size);\n\n    /*\n     * Decode the character encoding for the name for versions 3 or later,\n     * as well as some reserved bytes.\n     */\n    if (attr->shared->version >= H5O_ATTR_VERSION_3)\n        attr->shared->encoding = (H5T_cset_t)*p++;\n\n    /* Decode and store the name */\n    if (NULL == (attr->shared->name = H5MM_strdup((const char *)p)))\n        HGOTO_ERROR(H5E_RESOURCE, H5E_NOSPACE, NULL, \"memory allocation failed\")\n\n    /* Make an attempt to detect corrupted name or name length - HDFFV-10588 */\n    if (name_len != (HDstrlen(attr->shared->name) + 1))\n        HGOTO_ERROR(H5E_ATTR, H5E_CANTDECODE, NULL, \"attribute name has different length than stored length\")\n\n    if (attr->shared->version < H5O_ATTR_VERSION_2)\n        p += H5O_ALIGN_OLD(name_len); /* advance the memory pointer */\n    else\n        p += name_len; /* advance the memory pointer */\n\n    /* Decode the attribute's datatype */\n    if (NULL == (attr->shared->dt = (H5T_t *)(H5O_MSG_DTYPE->decode)(\n                     f, open_oh, ((flags & H5O_ATTR_FLAG_TYPE_SHARED) ? H5O_MSG_FLAG_SHARED : 0), ioflags,\n                     attr->shared->dt_size, p)))\n        HGOTO_ERROR(H5E_ATTR, H5E_CANTDECODE, NULL, \"can't decode attribute datatype\")\n    if (attr->shared->version < H5O_ATTR_VERSION_2)\n        p += H5O_ALIGN_OLD(attr->shared->dt_size);\n    else\n        p += attr->shared->dt_size;\n\n    /* decode the attribute dataspace.  It can be shared in versions >= 3\n     * What's actually shared, though, is only the extent.\n     */\n    if (NULL == (attr->shared->ds = H5FL_CALLOC(H5S_t)))\n        HGOTO_ERROR(H5E_RESOURCE, H5E_NOSPACE, NULL, \"memory allocation failed\")\n\n    /* Decode attribute's dataspace extent */\n    if ((extent = (H5S_extent_t *)(H5O_MSG_SDSPACE->decode)(\n             f, open_oh, ((flags & H5O_ATTR_FLAG_SPACE_SHARED) ? H5O_MSG_FLAG_SHARED : 0), ioflags,\n             attr->shared->ds_size, p)) == NULL)\n        HGOTO_ERROR(H5E_ATTR, H5E_CANTDECODE, NULL, \"can't decode attribute dataspace\")\n\n    /* Copy the extent information to the dataspace */\n    H5MM_memcpy(&(attr->shared->ds->extent), extent, sizeof(H5S_extent_t));\n\n    /* Release temporary extent information */\n    extent = H5FL_FREE(H5S_extent_t, extent);\n\n    /* Default to entire dataspace being selected */\n    if (H5S_select_all(attr->shared->ds, FALSE) < 0)\n        HGOTO_ERROR(H5E_DATASPACE, H5E_CANTSET, NULL, \"unable to set all selection\")\n\n    if (attr->shared->version < H5O_ATTR_VERSION_2)\n        p += H5O_ALIGN_OLD(attr->shared->ds_size);\n    else\n        p += attr->shared->ds_size;\n\n    /* Get the datatype's size */\n    if (0 == (dt_size = H5T_get_size(attr->shared->dt)))\n        HGOTO_ERROR(H5E_ATTR, H5E_CANTGET, NULL, \"unable to get datatype size\")\n\n    /* Get the datatype & dataspace sizes */\n    if (0 == (dt_size = H5T_get_size(attr->shared->dt)))\n        HGOTO_ERROR(H5E_ATTR, H5E_CANTGET, NULL, \"unable to get datatype size\")\n    if ((sds_size = H5S_GET_EXTENT_NPOINTS(attr->shared->ds)) < 0)\n        HGOTO_ERROR(H5E_ATTR, H5E_CANTGET, NULL, \"unable to get dataspace size\")\n    ds_size = (hsize_t)sds_size;\n\n    /* Compute the size of the data */\n    H5_CHECKED_ASSIGN(attr->shared->data_size, size_t, ds_size * (hsize_t)dt_size, hsize_t);\n\n    /* Go get the data */\n    if (attr->shared->data_size) {\n        /* Ensure that data size doesn't exceed buffer size, in case of\n           it's being corrupted in the file */\n        if (attr->shared->data_size > p_size)\n            HGOTO_ERROR(H5E_RESOURCE, H5E_OVERFLOW, NULL, \"data size exceeds buffer size\")\n\n        if (NULL == (attr->shared->data = H5FL_BLK_MALLOC(attr_buf, attr->shared->data_size)))\n            HGOTO_ERROR(H5E_RESOURCE, H5E_NOSPACE, NULL, \"memory allocation failed\")\n        H5MM_memcpy(attr->shared->data, p, attr->shared->data_size);\n    } /* end if */\n\n    /* Increment the reference count for this object header message in cache(compact\n       storage) or for the object from dense storage. */\n    attr->shared->nrefs++;\n\n    /* Set return value */\n    ret_value = attr;\n\ndone:\n    if (NULL == ret_value)\n        if (attr) {\n            /* Free any dynamically allocated items */\n            if (attr->shared)\n                if (H5A__shared_free(attr) < 0)\n                    HDONE_ERROR(H5E_ATTR, H5E_CANTRELEASE, NULL, \"can't release attribute info\")\n\n            attr = H5FL_FREE(H5A_t, attr);\n        } /* end if */\n\n    FUNC_LEAVE_NOAPI(ret_value)\n}",
  "abstract_func_before": "static void *\nH5O__attr_decode(H5F_t *VAR_0, H5O_t *VAR_1, unsigned H5_ATTR_UNUSED VAR_2, unsigned *VAR_3,\n                 size_t VAR_4, const uint8_t *VAR_5)\n{\n    H5A_t        *VAR_6 = NULL;\n    H5S_extent_t *VAR_7;           /* COMMENT_0 */\n    size_t        VAR_8;         /* COMMENT_1 */\n    size_t        VAR_9;          /* COMMENT_2 */\n    hssize_t      VAR_10;         /* COMMENT_3 */\n    hsize_t       VAR_11;          /* COMMENT_4 */\n    unsigned      VAR_12     = 0;    /* COMMENT_5 */\n    H5A_t        *VAR_13 = NULL; /* COMMENT_6 */\n\n    FUNC_ENTER_PACKAGE\n\n    /* COMMENT_7 */\n    HDassert(f);\n    HDassert(VAR_5);\n\n    if (NULL == (VAR_6 = H5FL_CALLOC(H5A_t)))\n        HGOTO_ERROR(VAR_14, VAR_15, NULL, \"memory allocation failed\")\n\n    if (NULL == (VAR_6->shared = H5FL_CALLOC(VAR_16)))\n        HGOTO_ERROR(VAR_17, VAR_15, NULL, \"can't allocate shared attr structure\")\n\n    /* COMMENT_8 */\n    VAR_6->shared->version = *VAR_5++;\n    if (VAR_6->shared->version < VAR_18 || VAR_6->shared->version > VAR_19)\n        HGOTO_ERROR(VAR_20, VAR_21, NULL, \"bad version number for attribute message\")\n\n    /* COMMENT_9 */\n    if (VAR_6->shared->version >= VAR_22) {\n        VAR_12 = *VAR_5++;\n\n        /* COMMENT_10 */\n        if (VAR_12 & (unsigned)~VAR_23)\n            HGOTO_ERROR(VAR_20, VAR_21, NULL, \"unknown flag for attribute message\")\n    } /* COMMENT_11 */\n    else\n        VAR_5++; /* COMMENT_12 */\n\n    /* COMMENT_13 */\n                                                                           \n                                                                         \n       \n    UINT16DECODE(VAR_5, VAR_8); /* COMMENT_17 */\n    UINT16DECODE(VAR_5, VAR_6->shared->dt_size);\n    UINT16DECODE(VAR_5, VAR_6->shared->ds_size);\n\n    /* COMMENT_18 */\n                                                                          \n                                      \n       \n    if (VAR_6->shared->version >= VAR_24)\n        VAR_6->shared->encoding = (VAR_25)*VAR_5++;\n\n    /* COMMENT_22 */\n    if (NULL == (VAR_6->shared->name = H5MM_strdup((const char *)VAR_5)))\n        HGOTO_ERROR(VAR_14, VAR_15, NULL, \"memory allocation failed\")\n\n    /* COMMENT_23 */\n    if (VAR_8 != (HDstrlen(VAR_6->shared->name) + 1))\n        HGOTO_ERROR(VAR_20, VAR_26, NULL, \"attribute name has different length than stored length\")\n\n    if (VAR_6->shared->version < VAR_22)\n        VAR_5 += H5O_ALIGN_OLD(VAR_8); /* COMMENT_24 */\n    else\n        VAR_5 += VAR_8; /* COMMENT_24 */\n\n    /* COMMENT_25 */\n    if (NULL == (VAR_6->shared->dt = (H5T_t *)(VAR_27->decode)(\n                     f, VAR_1, ((VAR_12 & VAR_28) ? VAR_29 : 0), VAR_3,\n                     VAR_6->shared->dt_size, VAR_5)))\n        HGOTO_ERROR(VAR_20, VAR_26, NULL, \"can't decode attribute datatype\")\n    if (VAR_6->shared->version < VAR_22)\n        VAR_5 += H5O_ALIGN_OLD(VAR_6->shared->dt_size);\n    else\n        VAR_5 += VAR_6->shared->dt_size;\n\n    /* COMMENT_26 */\n                                                          \n       \n    if (NULL == (VAR_6->shared->ds = H5FL_CALLOC(VAR_30)))\n        HGOTO_ERROR(VAR_14, VAR_15, NULL, \"memory allocation failed\")\n\n    /* COMMENT_29 */\n    if ((VAR_7 = (H5S_extent_t *)(VAR_31->decode)(\n             f, VAR_1, ((VAR_12 & VAR_32) ? VAR_29 : 0), VAR_3,\n             VAR_6->shared->ds_size, VAR_5)) == NULL)\n        HGOTO_ERROR(VAR_20, VAR_26, NULL, \"can't decode attribute dataspace\")\n\n    /* COMMENT_30 */\n    H5MM_memcpy(&(VAR_6->shared->ds->extent), VAR_7, sizeof(H5S_extent_t));\n\n    /* COMMENT_31 */\n    VAR_7 = H5FL_FREE(H5S_extent_t, VAR_7);\n\n    /* COMMENT_32 */\n    if (H5S_select_all(VAR_6->shared->ds, FALSE) < 0)\n        HGOTO_ERROR(VAR_33, VAR_34, NULL, \"unable to set all selection\")\n\n    if (VAR_6->shared->version < VAR_22)\n        VAR_5 += H5O_ALIGN_OLD(VAR_6->shared->ds_size);\n    else\n        VAR_5 += VAR_6->shared->ds_size;\n\n    /* COMMENT_33 */\n    if (0 == (VAR_9 = H5T_get_size(VAR_6->shared->dt)))\n        HGOTO_ERROR(VAR_20, VAR_35, NULL, \"unable to get datatype size\")\n\n    /* COMMENT_34 */\n    if (0 == (VAR_9 = H5T_get_size(VAR_6->shared->dt)))\n        HGOTO_ERROR(VAR_20, VAR_35, NULL, \"unable to get datatype size\")\n    if ((VAR_10 = H5S_GET_EXTENT_NPOINTS(VAR_6->shared->ds)) < 0)\n        HGOTO_ERROR(VAR_20, VAR_35, NULL, \"unable to get dataspace size\")\n    VAR_11 = (hsize_t)VAR_10;\n\n    /* COMMENT_35 */\n    H5_CHECKED_ASSIGN(VAR_6->shared->data_size, size_t, VAR_11 * (hsize_t)VAR_9, hsize_t);\n\n    /* COMMENT_36 */\n    if (VAR_6->shared->data_size) {\n        /* COMMENT_37 */\n                                              \n        if (VAR_6->shared->data_size > VAR_4)\n            HGOTO_ERROR(VAR_14, VAR_36, NULL, \"data size exceeds buffer size\")\n\n        if (NULL == (VAR_6->shared->data = H5FL_BLK_MALLOC(VAR_37, VAR_6->shared->data_size)))\n            HGOTO_ERROR(VAR_14, VAR_15, NULL, \"memory allocation failed\")\n        H5MM_memcpy(VAR_6->shared->data, VAR_5, VAR_6->shared->data_size);\n    } /* COMMENT_11 */\n\n    /* COMMENT_39 */\n                                                        \n    VAR_6->shared->nrefs++;\n\n    /* COMMENT_41 */\n    VAR_13 = VAR_6;\n\ndone:\n    if (NULL == VAR_13)\n        if (VAR_6) {\n            /* COMMENT_42 */\n            if (VAR_6->shared)\n                if (H5A__shared_free(VAR_6) < 0)\n                    HDONE_ERROR(VAR_20, VAR_38, NULL, \"can't release attribute info\")\n\n            VAR_6 = H5FL_FREE(H5A_t, VAR_6);\n        } /* COMMENT_11 */\n\n    VAR_39(ret_value)\n}",
  "func_graph_path_before": null,
  "func": "static void *\nH5O__attr_decode(H5F_t *f, H5O_t *open_oh, unsigned H5_ATTR_UNUSED mesg_flags, unsigned *ioflags,\n                 size_t p_size, const uint8_t *p)\n{\n    H5A_t        *attr = NULL;\n    H5S_extent_t *extent;           /*extent dimensionality information  */\n    size_t        name_len;         /*attribute name length */\n    size_t        dt_size;          /* Datatype size */\n    hssize_t      sds_size;         /* Signed Dataspace size */\n    hsize_t       ds_size;          /* Dataspace size */\n    unsigned      flags     = 0;    /* Attribute flags */\n    H5A_t        *ret_value = NULL; /* Return value */\n\n    FUNC_ENTER_PACKAGE\n\n    /* check args */\n    HDassert(f);\n    HDassert(p);\n\n    if (NULL == (attr = H5FL_CALLOC(H5A_t)))\n        HGOTO_ERROR(H5E_RESOURCE, H5E_NOSPACE, NULL, \"memory allocation failed\")\n\n    if (NULL == (attr->shared = H5FL_CALLOC(H5A_shared_t)))\n        HGOTO_ERROR(H5E_FILE, H5E_NOSPACE, NULL, \"can't allocate shared attr structure\")\n\n    /* Version number */\n    attr->shared->version = *p++;\n    if (attr->shared->version < H5O_ATTR_VERSION_1 || attr->shared->version > H5O_ATTR_VERSION_LATEST)\n        HGOTO_ERROR(H5E_ATTR, H5E_CANTLOAD, NULL, \"bad version number for attribute message\")\n\n    /* Get the flags byte if we have a later version of the attribute */\n    if (attr->shared->version >= H5O_ATTR_VERSION_2) {\n        flags = *p++;\n\n        /* Check for unknown flag */\n        if (flags & (unsigned)~H5O_ATTR_FLAG_ALL)\n            HGOTO_ERROR(H5E_ATTR, H5E_CANTLOAD, NULL, \"unknown flag for attribute message\")\n    } /* end if */\n    else\n        p++; /* Byte is unused when version<2 */\n\n    /*\n     * Decode the sizes of the parts of the attribute.  The sizes stored in\n     * the file are exact but the parts are aligned on 8-byte boundaries.\n     */\n    UINT16DECODE(p, name_len); /*including null*/\n    UINT16DECODE(p, attr->shared->dt_size);\n    UINT16DECODE(p, attr->shared->ds_size);\n\n    /*\n     * Decode the character encoding for the name for versions 3 or later,\n     * as well as some reserved bytes.\n     */\n    if (attr->shared->version >= H5O_ATTR_VERSION_3)\n        attr->shared->encoding = (H5T_cset_t)*p++;\n\n    /* Decode and store the name */\n    if (NULL == (attr->shared->name = H5MM_strdup((const char *)p)))\n        HGOTO_ERROR(H5E_RESOURCE, H5E_NOSPACE, NULL, \"memory allocation failed\")\n\n    /* Make an attempt to detect corrupted name or name length - HDFFV-10588 */\n    if (name_len != (HDstrlen(attr->shared->name) + 1))\n        HGOTO_ERROR(H5E_ATTR, H5E_CANTDECODE, NULL, \"attribute name has different length than stored length\")\n\n    if (attr->shared->version < H5O_ATTR_VERSION_2)\n        p += H5O_ALIGN_OLD(name_len); /* advance the memory pointer */\n    else\n        p += name_len; /* advance the memory pointer */\n\n    /* Decode the attribute's datatype */\n    if (NULL == (attr->shared->dt = (H5T_t *)(H5O_MSG_DTYPE->decode)(\n                     f, open_oh, ((flags & H5O_ATTR_FLAG_TYPE_SHARED) ? H5O_MSG_FLAG_SHARED : 0), ioflags,\n                     attr->shared->dt_size, p)))\n        HGOTO_ERROR(H5E_ATTR, H5E_CANTDECODE, NULL, \"can't decode attribute datatype\")\n    if (attr->shared->version < H5O_ATTR_VERSION_2)\n        p += H5O_ALIGN_OLD(attr->shared->dt_size);\n    else\n        p += attr->shared->dt_size;\n\n    /* decode the attribute dataspace.  It can be shared in versions >= 3\n     * What's actually shared, though, is only the extent.\n     */\n    if (NULL == (attr->shared->ds = H5FL_CALLOC(H5S_t)))\n        HGOTO_ERROR(H5E_RESOURCE, H5E_NOSPACE, NULL, \"memory allocation failed\")\n\n    /* Decode attribute's dataspace extent */\n    if ((extent = (H5S_extent_t *)(H5O_MSG_SDSPACE->decode)(\n             f, open_oh, ((flags & H5O_ATTR_FLAG_SPACE_SHARED) ? H5O_MSG_FLAG_SHARED : 0), ioflags,\n             attr->shared->ds_size, p)) == NULL)\n        HGOTO_ERROR(H5E_ATTR, H5E_CANTDECODE, NULL, \"can't decode attribute dataspace\")\n\n    /* Copy the extent information to the dataspace */\n    H5MM_memcpy(&(attr->shared->ds->extent), extent, sizeof(H5S_extent_t));\n\n    /* Release temporary extent information */\n    extent = H5FL_FREE(H5S_extent_t, extent);\n\n    /* Default to entire dataspace being selected */\n    if (H5S_select_all(attr->shared->ds, FALSE) < 0)\n        HGOTO_ERROR(H5E_DATASPACE, H5E_CANTSET, NULL, \"unable to set all selection\")\n\n    if (attr->shared->version < H5O_ATTR_VERSION_2)\n        p += H5O_ALIGN_OLD(attr->shared->ds_size);\n    else\n        p += attr->shared->ds_size;\n\n    /* Get the datatype & dataspace sizes */\n    if (0 == (dt_size = H5T_get_size(attr->shared->dt)))\n        HGOTO_ERROR(H5E_ATTR, H5E_CANTGET, NULL, \"unable to get datatype size\")\n    if ((sds_size = H5S_GET_EXTENT_NPOINTS(attr->shared->ds)) < 0)\n        HGOTO_ERROR(H5E_ATTR, H5E_CANTGET, NULL, \"unable to get dataspace size\")\n    ds_size = (hsize_t)sds_size;\n\n    /* Compute the size of the data */\n    H5_CHECKED_ASSIGN(attr->shared->data_size, size_t, ds_size * (hsize_t)dt_size, hsize_t);\n\n    /* Go get the data */\n    if (attr->shared->data_size) {\n        /* Ensure that data size doesn't exceed buffer size, in case of\n           it's being corrupted in the file */\n        if (attr->shared->data_size > p_size)\n            HGOTO_ERROR(H5E_RESOURCE, H5E_OVERFLOW, NULL, \"data size exceeds buffer size\")\n\n        if (NULL == (attr->shared->data = H5FL_BLK_MALLOC(attr_buf, attr->shared->data_size)))\n            HGOTO_ERROR(H5E_RESOURCE, H5E_NOSPACE, NULL, \"memory allocation failed\")\n        H5MM_memcpy(attr->shared->data, p, attr->shared->data_size);\n    } /* end if */\n\n    /* Increment the reference count for this object header message in cache(compact\n       storage) or for the object from dense storage. */\n    attr->shared->nrefs++;\n\n    /* Set return value */\n    ret_value = attr;\n\ndone:\n    if (NULL == ret_value)\n        if (attr) {\n            /* Free any dynamically allocated items */\n            if (attr->shared)\n                if (H5A__shared_free(attr) < 0)\n                    HDONE_ERROR(H5E_ATTR, H5E_CANTRELEASE, NULL, \"can't release attribute info\")\n\n            attr = H5FL_FREE(H5A_t, attr);\n        } /* end if */\n\n    FUNC_LEAVE_NOAPI(ret_value)\n}",
  "abstract_func": "static void *\nH5O__attr_decode(H5F_t *VAR_0, H5O_t *VAR_1, unsigned H5_ATTR_UNUSED VAR_2, unsigned *VAR_3,\n                 size_t VAR_4, const uint8_t *VAR_5)\n{\n    H5A_t        *VAR_6 = NULL;\n    H5S_extent_t *VAR_7;           /* COMMENT_0 */\n    size_t        VAR_8;         /* COMMENT_1 */\n    size_t        VAR_9;          /* COMMENT_2 */\n    hssize_t      VAR_10;         /* COMMENT_3 */\n    hsize_t       VAR_11;          /* COMMENT_4 */\n    unsigned      VAR_12     = 0;    /* COMMENT_5 */\n    H5A_t        *VAR_13 = NULL; /* COMMENT_6 */\n\n    FUNC_ENTER_PACKAGE\n\n    /* COMMENT_7 */\n    HDassert(f);\n    HDassert(VAR_5);\n\n    if (NULL == (VAR_6 = H5FL_CALLOC(H5A_t)))\n        HGOTO_ERROR(VAR_14, VAR_15, NULL, \"memory allocation failed\")\n\n    if (NULL == (VAR_6->shared = H5FL_CALLOC(VAR_16)))\n        HGOTO_ERROR(VAR_17, VAR_15, NULL, \"can't allocate shared attr structure\")\n\n    /* COMMENT_8 */\n    VAR_6->shared->version = *VAR_5++;\n    if (VAR_6->shared->version < VAR_18 || VAR_6->shared->version > VAR_19)\n        HGOTO_ERROR(VAR_20, VAR_21, NULL, \"bad version number for attribute message\")\n\n    /* COMMENT_9 */\n    if (VAR_6->shared->version >= VAR_22) {\n        VAR_12 = *VAR_5++;\n\n        /* COMMENT_10 */\n        if (VAR_12 & (unsigned)~VAR_23)\n            HGOTO_ERROR(VAR_20, VAR_21, NULL, \"unknown flag for attribute message\")\n    } /* COMMENT_11 */\n    else\n        VAR_5++; /* COMMENT_12 */\n\n    /* COMMENT_13 */\n                                                                           \n                                                                         \n       \n    UINT16DECODE(VAR_5, VAR_8); /* COMMENT_17 */\n    UINT16DECODE(VAR_5, VAR_6->shared->dt_size);\n    UINT16DECODE(VAR_5, VAR_6->shared->ds_size);\n\n    /* COMMENT_18 */\n                                                                          \n                                      \n       \n    if (VAR_6->shared->version >= VAR_24)\n        VAR_6->shared->encoding = (VAR_25)*VAR_5++;\n\n    /* COMMENT_22 */\n    if (NULL == (VAR_6->shared->name = H5MM_strdup((const char *)VAR_5)))\n        HGOTO_ERROR(VAR_14, VAR_15, NULL, \"memory allocation failed\")\n\n    /* COMMENT_23 */\n    if (VAR_8 != (HDstrlen(VAR_6->shared->name) + 1))\n        HGOTO_ERROR(VAR_20, VAR_26, NULL, \"attribute name has different length than stored length\")\n\n    if (VAR_6->shared->version < VAR_22)\n        VAR_5 += H5O_ALIGN_OLD(VAR_8); /* COMMENT_24 */\n    else\n        VAR_5 += VAR_8; /* COMMENT_24 */\n\n    /* COMMENT_25 */\n    if (NULL == (VAR_6->shared->dt = (H5T_t *)(VAR_27->decode)(\n                     f, VAR_1, ((VAR_12 & VAR_28) ? VAR_29 : 0), VAR_3,\n                     VAR_6->shared->dt_size, VAR_5)))\n        HGOTO_ERROR(VAR_20, VAR_26, NULL, \"can't decode attribute datatype\")\n    if (VAR_6->shared->version < VAR_22)\n        VAR_5 += H5O_ALIGN_OLD(VAR_6->shared->dt_size);\n    else\n        VAR_5 += VAR_6->shared->dt_size;\n\n    /* COMMENT_26 */\n                                                          \n       \n    if (NULL == (VAR_6->shared->ds = H5FL_CALLOC(VAR_30)))\n        HGOTO_ERROR(VAR_14, VAR_15, NULL, \"memory allocation failed\")\n\n    /* COMMENT_29 */\n    if ((VAR_7 = (H5S_extent_t *)(VAR_31->decode)(\n             f, VAR_1, ((VAR_12 & VAR_32) ? VAR_29 : 0), VAR_3,\n             VAR_6->shared->ds_size, VAR_5)) == NULL)\n        HGOTO_ERROR(VAR_20, VAR_26, NULL, \"can't decode attribute dataspace\")\n\n    /* COMMENT_30 */\n    H5MM_memcpy(&(VAR_6->shared->ds->extent), VAR_7, sizeof(H5S_extent_t));\n\n    /* COMMENT_31 */\n    VAR_7 = H5FL_FREE(H5S_extent_t, VAR_7);\n\n    /* COMMENT_32 */\n    if (H5S_select_all(VAR_6->shared->ds, FALSE) < 0)\n        HGOTO_ERROR(VAR_33, VAR_34, NULL, \"unable to set all selection\")\n\n    if (VAR_6->shared->version < VAR_22)\n        VAR_5 += H5O_ALIGN_OLD(VAR_6->shared->ds_size);\n    else\n        VAR_5 += VAR_6->shared->ds_size;\n\n    /* COMMENT_33 */\n    if (0 == (VAR_9 = H5T_get_size(VAR_6->shared->dt)))\n        HGOTO_ERROR(VAR_20, VAR_35, NULL, \"unable to get datatype size\")\n    if ((VAR_10 = H5S_GET_EXTENT_NPOINTS(VAR_6->shared->ds)) < 0)\n        HGOTO_ERROR(VAR_20, VAR_35, NULL, \"unable to get dataspace size\")\n    VAR_11 = (hsize_t)VAR_10;\n\n    /* COMMENT_34 */\n    H5_CHECKED_ASSIGN(VAR_6->shared->data_size, size_t, VAR_11 * (hsize_t)VAR_9, hsize_t);\n\n    /* COMMENT_35 */\n    if (VAR_6->shared->data_size) {\n        /* COMMENT_36 */\n                                              \n        if (VAR_6->shared->data_size > VAR_4)\n            HGOTO_ERROR(VAR_14, VAR_36, NULL, \"data size exceeds buffer size\")\n\n        if (NULL == (VAR_6->shared->data = H5FL_BLK_MALLOC(VAR_37, VAR_6->shared->data_size)))\n            HGOTO_ERROR(VAR_14, VAR_15, NULL, \"memory allocation failed\")\n        H5MM_memcpy(VAR_6->shared->data, VAR_5, VAR_6->shared->data_size);\n    } /* COMMENT_11 */\n\n    /* COMMENT_38 */\n                                                        \n    VAR_6->shared->nrefs++;\n\n    /* COMMENT_40 */\n    VAR_13 = VAR_6;\n\ndone:\n    if (NULL == VAR_13)\n        if (VAR_6) {\n            /* COMMENT_41 */\n            if (VAR_6->shared)\n                if (H5A__shared_free(VAR_6) < 0)\n                    HDONE_ERROR(VAR_20, VAR_38, NULL, \"can't release attribute info\")\n\n            VAR_6 = H5FL_FREE(H5A_t, VAR_6);\n        } /* COMMENT_11 */\n\n    VAR_39(ret_value)\n}",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -104,10 +104,6 @@\n     else\n         p += attr->shared->ds_size;\n \n-    /* Get the datatype's size */\n-    if (0 == (dt_size = H5T_get_size(attr->shared->dt)))\n-        HGOTO_ERROR(H5E_ATTR, H5E_CANTGET, NULL, \"unable to get datatype size\")\n-\n     /* Get the datatype & dataspace sizes */\n     if (0 == (dt_size = H5T_get_size(attr->shared->dt)))\n         HGOTO_ERROR(H5E_ATTR, H5E_CANTGET, NULL, \"unable to get datatype size\")",
  "diff_line_info": {
    "deleted_lines": [
      "    /* Get the datatype's size */",
      "    if (0 == (dt_size = H5T_get_size(attr->shared->dt)))",
      "        HGOTO_ERROR(H5E_ATTR, H5E_CANTGET, NULL, \"unable to get datatype size\")",
      ""
    ],
    "added_lines": []
  },
  "is_vul": true,
  "pr_url": "https://github.com/HDFGroup/hdf5/pull/2459",
  "description": {
    "pr_info": {
      "title": "Check for overflow when calculating on-disk attribute data size",
      "number": 2459
    },
    "comment": [
      "A bogus hdf5 file may contain dataspace messages with sizes which lead to the on-disk data sizes to exceed what is addressable. When calculating the size, make sure, the multiplication does not\r\noverflow.\r\nThe test case was crafted in a way that the overflow caused the  size to be 0.\r\n    \r\nThis fixes CVE-2021-37501 / Bug #2458.\r\n\r\nAlso remove duplicate code.",
      "Thanks for merging!\r\n@byrnHDF , @vchoi-hdfgroup , @derobins , @lrknox would you like me to add reproducers for CVEs we had fixed earlier as well? I can give it a go, but would only do so if there is interest.",
      "Does the change will merge to 1.8 branch or does the hdf5 1.8.21 have the issue? Thanks!"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95  \n\nThe patch addresses a known security vulnerability (CVE-2021-37501) by fixing an overflow issue in the data size calculation. The changes directly relate to preventing the security risk, making it a clear security fix."
}