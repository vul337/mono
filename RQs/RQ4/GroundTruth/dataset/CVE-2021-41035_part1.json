{
  "cve_id": "CVE-2021-41035",
  "cwe_ids": [
    "CWE-440",
    "CWE-250"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "eclipse-openj9/openj9",
  "commit_msg": "Throw IAE when an InterfaceHandle thunk finds a non-public method\n\nThe interface dispatch implemented by InterfaceHandle is supposed to\nthrow IllegalAccessError (IAE) when the dispatched callee is not public,\njust like the dispatch performed by invokeinterface.",
  "commit_hash": "c6e0d9296ff9a3084965d83e207403de373c0bad",
  "git_url": "https://github.com/eclipse-openj9/openj9/commit/c6e0d9296ff9a3084965d83e207403de373c0bad",
  "file_path": "runtime/compiler/env/VMJ9.cpp",
  "func_name": "Java_java_lang_invoke_InterfaceHandle_convertITableIndexToVTableIndex",
  "func_before": "JNIEXPORT jint JNICALL Java_java_lang_invoke_InterfaceHandle_convertITableIndexToVTableIndex\n  (JNIEnv *env, jclass InterfaceMethodHandle, jlong interfaceArg, jint itableIndex, jlong receiverClassArg)\n   {\n   J9Class  *interfaceClass = (J9Class*)(intptr_t)interfaceArg;\n   J9Class  *receiverClass  = (J9Class*)(intptr_t)receiverClassArg;\n   J9ITable *itableEntry;\n   for (itableEntry = (J9ITable*)receiverClass->iTable; itableEntry; itableEntry = itableEntry->next)\n      if (itableEntry->interfaceClass == interfaceClass)\n         break;\n   TR_ASSERT(itableEntry, \"Shouldn't call convertITableIndexToVTableIndex without first ensuring the receiver implements the interface\");\n   UDATA *itableArray = (UDATA*)(itableEntry+1);\n   return (itableArray[itableIndex] - sizeof(J9Class))/sizeof(intptr_t);\n#if 0 // TODO:JSR292: We probably want to do something more like this instead, so it will properly handle exceptional cases\n   struct\n      {\n      UDATA interfaceClass;\n      UDATA methodIndex;\n      } indexAndLiterals =\n      {\n      (UDATA)interfaceClass,\n      (UDATA)itableIndex\n      };\n   J9Object *receiver = (J9Object*)receiverArg;\n   return (jint)jitLookupInterfaceMethod(receiver->clazz, &indexAndLiterals, 0);\n#endif\n   }",
  "abstract_func_before": "JNIEXPORT VAR_0 VAR_1 Java_java_lang_invoke_InterfaceHandle_convertITableIndexToVTableIndex\n  (JNIEnv *VAR_2, jclass VAR_3, jlong VAR_4, jint VAR_5, jlong VAR_6)\n   {\n   J9Class  *VAR_7 = (J9Class*)(intptr_t)VAR_4;\n   J9Class  *VAR_8  = (J9Class*)(intptr_t)VAR_6;\n   J9ITable *VAR_9;\n   for (VAR_9 = (J9ITable*)VAR_8->iTable; VAR_9; VAR_9 = VAR_9->next)\n      if (VAR_9->interfaceClass == VAR_7)\n         break;\n   TR_ASSERT(VAR_9, \"Shouldn't call convertITableIndexToVTableIndex without first ensuring the receiver implements the interface\");\n   UDATA *VAR_10 = (UDATA*)(VAR_9+1);\n   return (VAR_10[VAR_5] - sizeof(J9Class))/sizeof(intptr_t);\n#if 0 /* COMMENT_0 */\n   struct\n      {\n      UDATA interfaceClass;\n      UDATA methodIndex;\n      } VAR_11 =\n      {\n      (UDATA)VAR_7,\n      (UDATA)VAR_5\n      };\n   J9Object *VAR_12 = (J9Object*)VAR_13;\n   return (jint)jitLookupInterfaceMethod(VAR_12->clazz, &VAR_11, 0);\n#endif\n   }",
  "func_graph_path_before": null,
  "func": "JNIEXPORT jint JNICALL Java_java_lang_invoke_InterfaceHandle_convertITableIndexToVTableIndex\n  (JNIEnv *env, jclass InterfaceMethodHandle, jlong interfaceArg, jint itableIndex, jlong receiverClassArg)\n   {\n   J9Class  *interfaceClass = (J9Class*)(intptr_t)interfaceArg;\n   J9Class  *receiverClass  = (J9Class*)(intptr_t)receiverClassArg;\n   J9ITable *itableEntry;\n   for (itableEntry = (J9ITable*)receiverClass->iTable; itableEntry; itableEntry = itableEntry->next)\n      if (itableEntry->interfaceClass == interfaceClass)\n         break;\n   TR_ASSERT(itableEntry, \"Shouldn't call convertITableIndexToVTableIndex without first ensuring the receiver implements the interface\");\n   UDATA *itableArray = (UDATA*)(itableEntry+1);\n   UDATA vTableOffset = itableArray[itableIndex];\n   J9Method *method = *(J9Method**)((UDATA)receiverClass + vTableOffset);\n   if ((J9_ROM_METHOD_FROM_RAM_METHOD(method)->modifiers & J9AccPublic) == 0)\n      return -1;\n\n   return (vTableOffset - sizeof(J9Class))/sizeof(intptr_t);\n#if 0 // TODO:JSR292: We probably want to do something more like this instead, so it will properly handle exceptional cases\n   struct\n      {\n      UDATA interfaceClass;\n      UDATA methodIndex;\n      } indexAndLiterals =\n      {\n      (UDATA)interfaceClass,\n      (UDATA)itableIndex\n      };\n   J9Object *receiver = (J9Object*)receiverArg;\n   return (jint)jitLookupInterfaceMethod(receiver->clazz, &indexAndLiterals, 0);\n#endif\n   }",
  "abstract_func": "JNIEXPORT VAR_0 VAR_1 Java_java_lang_invoke_InterfaceHandle_convertITableIndexToVTableIndex\n  (JNIEnv *VAR_2, jclass VAR_3, jlong VAR_4, jint VAR_5, jlong VAR_6)\n   {\n   J9Class  *VAR_7 = (J9Class*)(intptr_t)VAR_4;\n   J9Class  *VAR_8  = (J9Class*)(intptr_t)VAR_6;\n   J9ITable *VAR_9;\n   for (VAR_9 = (J9ITable*)VAR_8->iTable; VAR_9; VAR_9 = VAR_9->next)\n      if (VAR_9->interfaceClass == VAR_7)\n         break;\n   TR_ASSERT(VAR_9, \"Shouldn't call convertITableIndexToVTableIndex without first ensuring the receiver implements the interface\");\n   UDATA *VAR_10 = (UDATA*)(VAR_9+1);\n   UDATA VAR_11 = VAR_10[VAR_5];\n   J9Method *VAR_12 = *(J9Method**)((UDATA)VAR_8 + VAR_11);\n   if ((J9_ROM_METHOD_FROM_RAM_METHOD(VAR_12)->modifiers & VAR_13) == 0)\n      return -1;\n\n   return (VAR_11 - sizeof(J9Class))/sizeof(intptr_t);\n#if 0 /* COMMENT_0 */\n   struct\n      {\n      UDATA interfaceClass;\n      UDATA methodIndex;\n      } VAR_14 =\n      {\n      (UDATA)VAR_7,\n      (UDATA)VAR_5\n      };\n   J9Object *VAR_15 = (J9Object*)VAR_16;\n   return (jint)jitLookupInterfaceMethod(VAR_15->clazz, &VAR_14, 0);\n#endif\n   }",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -9,7 +9,12 @@\n          break;\n    TR_ASSERT(itableEntry, \"Shouldn't call convertITableIndexToVTableIndex without first ensuring the receiver implements the interface\");\n    UDATA *itableArray = (UDATA*)(itableEntry+1);\n-   return (itableArray[itableIndex] - sizeof(J9Class))/sizeof(intptr_t);\n+   UDATA vTableOffset = itableArray[itableIndex];\n+   J9Method *method = *(J9Method**)((UDATA)receiverClass + vTableOffset);\n+   if ((J9_ROM_METHOD_FROM_RAM_METHOD(method)->modifiers & J9AccPublic) == 0)\n+      return -1;\n+\n+   return (vTableOffset - sizeof(J9Class))/sizeof(intptr_t);\n #if 0 // TODO:JSR292: We probably want to do something more like this instead, so it will properly handle exceptional cases\n    struct\n       {",
  "diff_line_info": {
    "deleted_lines": [
      "   return (itableArray[itableIndex] - sizeof(J9Class))/sizeof(intptr_t);"
    ],
    "added_lines": [
      "   UDATA vTableOffset = itableArray[itableIndex];",
      "   J9Method *method = *(J9Method**)((UDATA)receiverClass + vTableOffset);",
      "   if ((J9_ROM_METHOD_FROM_RAM_METHOD(method)->modifiers & J9AccPublic) == 0)",
      "      return -1;",
      "",
      "   return (vTableOffset - sizeof(J9Class))/sizeof(intptr_t);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/eclipse-openj9/openj9/pull/13740",
  "description": {
    "pr_info": {
      "title": "Throw IllegalAccessError (IAE): Lookup.findVirtual",
      "number": 13740
    },
    "comment": [
      "Throw IAE for non-public virtual methods if invoked by MethodHandles created\r\nusing Lookup.findVirtual.\r\nFor KIND_INTERFACE, OpenJ9 MHs always get the method from the vTable. Private\r\nmethods do not appear in the vTable. So, the check for J9AccPrivate is not\r\nneeded.",
      "This has been tested internally."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "The patch addresses a security issue by enforcing method visibility checks, preventing unauthorized access to non-public methods.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}