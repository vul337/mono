{
  "cve_id": "CVE-2021-33185",
  "cwe_ids": [
    "CWE-120"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:N/A:N",
  "cvss_is_v3": false,
  "repo_name": "SerenityOS/serenity",
  "commit_msg": "LibCore: Use Vector instead of VLA in ArgsParser::parse()\n\nIf there happens to be zero positional arguments, this constructs a\n0-length VLA, which is UB caught by UBSAN.",
  "commit_hash": "fafe204ef20c6717427916cc4795a28adafe2f69",
  "git_url": "https://github.com/SerenityOS/serenity/commit/fafe204ef20c6717427916cc4795a28adafe2f69",
  "file_path": "Userland/Libraries/LibCore/ArgsParser.cpp",
  "func_name": "ArgsParser::parse",
  "func_before": "bool ArgsParser::parse(int argc, char** argv, bool exit_on_failure)\n{\n    auto print_usage_and_exit = [this, argv, exit_on_failure] {\n        print_usage(stderr, argv[0]);\n        if (exit_on_failure)\n            exit(1);\n    };\n\n    Vector<option> long_options;\n    StringBuilder short_options_builder;\n\n    int index_of_found_long_option = -1;\n\n    // Tell getopt() to reset its internal state, and start scanning from optind = 1.\n    // We could also set optreset = 1, but the host platform may not support that.\n    optind = 0;\n\n    for (size_t i = 0; i < m_options.size(); i++) {\n        auto& opt = m_options[i];\n        if (opt.long_name) {\n            option long_opt {\n                opt.long_name,\n                opt.requires_argument ? required_argument : no_argument,\n                &index_of_found_long_option,\n                static_cast<int>(i)\n            };\n            long_options.append(long_opt);\n        }\n        if (opt.short_name) {\n            short_options_builder.append(opt.short_name);\n            if (opt.requires_argument)\n                short_options_builder.append(':');\n        }\n    }\n    long_options.append({ 0, 0, 0, 0 });\n\n    String short_options = short_options_builder.build();\n\n    while (true) {\n        int c = getopt_long(argc, argv, short_options.characters(), long_options.data(), nullptr);\n        if (c == -1) {\n            // We have reached the end.\n            break;\n        } else if (c == '?') {\n            // There was an error, and getopt() has already\n            // printed its error message.\n            print_usage_and_exit();\n            return false;\n        }\n\n        // Let's see what option we just found.\n        Option* found_option = nullptr;\n        if (c == 0) {\n            // It was a long option.\n            VERIFY(index_of_found_long_option >= 0);\n            found_option = &m_options[index_of_found_long_option];\n            index_of_found_long_option = -1;\n        } else {\n            // It was a short option, look it up.\n            auto it = m_options.find_if([c](auto& opt) { return c == opt.short_name; });\n            VERIFY(!it.is_end());\n            found_option = &*it;\n        }\n        VERIFY(found_option);\n\n        const char* arg = found_option->requires_argument ? optarg : nullptr;\n        if (!found_option->accept_value(arg)) {\n            warnln(\"\\033[31mInvalid value for option \\033[1m{}\\033[22m, dude\\033[0m\", found_option->name_for_display());\n            print_usage_and_exit();\n            return false;\n        }\n    }\n\n    // We're done processing options, now let's parse positional arguments.\n\n    int values_left = argc - optind;\n    int num_values_for_arg[m_positional_args.size()];\n    int total_values_required = 0;\n    for (size_t i = 0; i < m_positional_args.size(); i++) {\n        auto& arg = m_positional_args[i];\n        num_values_for_arg[i] = arg.min_values;\n        total_values_required += arg.min_values;\n    }\n\n    if (total_values_required > values_left) {\n        print_usage_and_exit();\n        return false;\n    }\n    int extra_values_to_distribute = values_left - total_values_required;\n\n    for (size_t i = 0; i < m_positional_args.size(); i++) {\n        auto& arg = m_positional_args[i];\n        int extra_values_to_this_arg = min(arg.max_values - arg.min_values, extra_values_to_distribute);\n        num_values_for_arg[i] += extra_values_to_this_arg;\n        extra_values_to_distribute -= extra_values_to_this_arg;\n        if (extra_values_to_distribute == 0)\n            break;\n    }\n\n    if (extra_values_to_distribute > 0) {\n        // We still have too many values :(\n        print_usage_and_exit();\n        return false;\n    }\n\n    for (size_t i = 0; i < m_positional_args.size(); i++) {\n        auto& arg = m_positional_args[i];\n        for (int j = 0; j < num_values_for_arg[i]; j++) {\n            const char* value = argv[optind++];\n            if (!arg.accept_value(value)) {\n                warnln(\"Invalid value for argument {}\", arg.name);\n                print_usage_and_exit();\n                return false;\n            }\n        }\n    }\n\n    // We're done parsing! :)\n    // Now let's show help if requested.\n    if (m_show_help) {\n        print_usage(stdout, argv[0]);\n        if (exit_on_failure)\n            exit(0);\n        return false;\n    }\n\n    return true;\n}",
  "abstract_func_before": "bool ArgsParser::parse(int VAR_0, char** VAR_1, bool VAR_2)\n{\n    auto VAR_3 = [this, VAR_1, VAR_2] {\n        print_usage(VAR_4, VAR_1[0]);\n        if (VAR_2)\n            exit(1);\n    };\n\n    Vector<option> VAR_5;\n    StringBuilder VAR_6;\n\n    int VAR_7 = -1;\n\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n    VAR_8 = 0;\n\n    for (size_t VAR_9 = 0; VAR_9 < VAR_10.size(); VAR_9++) {\n        auto& VAR_11 = VAR_10[VAR_9];\n        if (VAR_11.long_name) {\n            option VAR_12 {\n                VAR_11.long_name,\n                VAR_11.requires_argument ? VAR_13 : VAR_14,\n                &VAR_7,\n                VAR_15<int>(VAR_9)\n            };\n            VAR_5.append(VAR_12);\n        }\n        if (VAR_11.short_name) {\n            VAR_6.append(VAR_11.short_name);\n            if (VAR_11.requires_argument)\n                VAR_6.append(':');\n        }\n    }\n    VAR_5.append({ 0, 0, 0, 0 });\n\n    String VAR_16 = VAR_6.build();\n\n    while (true) {\n        int VAR_17 = getopt_long(VAR_0, VAR_1, VAR_16.characters(), VAR_5.data(), nullptr);\n        if (VAR_17 == -1) {\n            /* COMMENT_2 */\n            break;\n        } else if (VAR_17 == '?') {\n            /* COMMENT_3 */\n            /* COMMENT_4 */\n            VAR_3();\n            return false;\n        }\n\n        /* COMMENT_5 */\n        Option* VAR_18 = nullptr;\n        if (VAR_17 == 0) {\n            /* COMMENT_6 */\n            VERIFY(VAR_7 >= 0);\n            VAR_18 = &VAR_10[VAR_7];\n            VAR_7 = -1;\n        } else {\n            /* COMMENT_7 */\n            auto VAR_19 = VAR_10.find_if([VAR_17](auto& VAR_11) { return VAR_17 == VAR_11.short_name; });\n            VERIFY(!VAR_19.is_end());\n            VAR_18 = &*VAR_19;\n        }\n        VERIFY(VAR_18);\n\n        const char* VAR_20 = VAR_18->requires_argument ? VAR_21 : nullptr;\n        if (!VAR_18->accept_value(VAR_20)) {\n            warnln(\"\\033[31mInvalid value for option \\033[1m{}\\033[22m, dude\\033[0m\", VAR_18->name_for_display());\n            VAR_3();\n            return false;\n        }\n    }\n\n    /* COMMENT_8 */\n\n    int VAR_22 = VAR_0 - VAR_8;\n    int VAR_23[VAR_24.size()];\n    int VAR_25 = 0;\n    for (size_t VAR_9 = 0; VAR_9 < VAR_24.size(); VAR_9++) {\n        auto& VAR_20 = VAR_24[VAR_9];\n        VAR_23[VAR_9] = VAR_20.min_values;\n        VAR_25 += VAR_20.min_values;\n    }\n\n    if (VAR_25 > VAR_22) {\n        VAR_3();\n        return false;\n    }\n    int VAR_26 = VAR_22 - VAR_25;\n\n    for (size_t VAR_9 = 0; VAR_9 < VAR_24.size(); VAR_9++) {\n        auto& VAR_20 = VAR_24[VAR_9];\n        int VAR_27 = min(VAR_20.max_values - VAR_20.min_values, VAR_26);\n        VAR_23[VAR_9] += VAR_27;\n        VAR_26 -= VAR_27;\n        if (VAR_26 == 0)\n            break;\n    }\n\n    if (VAR_26 > 0) {\n        /* COMMENT_9 */\n        VAR_3();\n        return false;\n    }\n\n    for (size_t VAR_9 = 0; VAR_9 < VAR_24.size(); VAR_9++) {\n        auto& VAR_20 = VAR_24[VAR_9];\n        for (int VAR_28 = 0; VAR_28 < VAR_23[VAR_9]; VAR_28++) {\n            const char* VAR_29 = VAR_1[VAR_8++];\n            if (!VAR_20.accept_value(VAR_29)) {\n                warnln(\"Invalid value for argument {}\", VAR_20.name);\n                VAR_3();\n                return false;\n            }\n        }\n    }\n\n    /* COMMENT_10 */\n    /* COMMENT_11 */\n    if (VAR_30) {\n        print_usage(VAR_31, VAR_1[0]);\n        if (VAR_2)\n            exit(0);\n        return false;\n    }\n\n    return true;\n}",
  "func_graph_path_before": "SerenityOS/serenity/fafe204ef20c6717427916cc4795a28adafe2f69/ArgsParser.cpp/vul/before/0.json",
  "func": "bool ArgsParser::parse(int argc, char** argv, bool exit_on_failure)\n{\n    auto print_usage_and_exit = [this, argv, exit_on_failure] {\n        print_usage(stderr, argv[0]);\n        if (exit_on_failure)\n            exit(1);\n    };\n\n    Vector<option> long_options;\n    StringBuilder short_options_builder;\n\n    int index_of_found_long_option = -1;\n\n    // Tell getopt() to reset its internal state, and start scanning from optind = 1.\n    // We could also set optreset = 1, but the host platform may not support that.\n    optind = 0;\n\n    for (size_t i = 0; i < m_options.size(); i++) {\n        auto& opt = m_options[i];\n        if (opt.long_name) {\n            option long_opt {\n                opt.long_name,\n                opt.requires_argument ? required_argument : no_argument,\n                &index_of_found_long_option,\n                static_cast<int>(i)\n            };\n            long_options.append(long_opt);\n        }\n        if (opt.short_name) {\n            short_options_builder.append(opt.short_name);\n            if (opt.requires_argument)\n                short_options_builder.append(':');\n        }\n    }\n    long_options.append({ 0, 0, 0, 0 });\n\n    String short_options = short_options_builder.build();\n\n    while (true) {\n        int c = getopt_long(argc, argv, short_options.characters(), long_options.data(), nullptr);\n        if (c == -1) {\n            // We have reached the end.\n            break;\n        } else if (c == '?') {\n            // There was an error, and getopt() has already\n            // printed its error message.\n            print_usage_and_exit();\n            return false;\n        }\n\n        // Let's see what option we just found.\n        Option* found_option = nullptr;\n        if (c == 0) {\n            // It was a long option.\n            VERIFY(index_of_found_long_option >= 0);\n            found_option = &m_options[index_of_found_long_option];\n            index_of_found_long_option = -1;\n        } else {\n            // It was a short option, look it up.\n            auto it = m_options.find_if([c](auto& opt) { return c == opt.short_name; });\n            VERIFY(!it.is_end());\n            found_option = &*it;\n        }\n        VERIFY(found_option);\n\n        const char* arg = found_option->requires_argument ? optarg : nullptr;\n        if (!found_option->accept_value(arg)) {\n            warnln(\"\\033[31mInvalid value for option \\033[1m{}\\033[22m, dude\\033[0m\", found_option->name_for_display());\n            print_usage_and_exit();\n            return false;\n        }\n    }\n\n    // We're done processing options, now let's parse positional arguments.\n\n    int values_left = argc - optind;\n    Vector<int, 16> num_values_for_arg;\n    num_values_for_arg.resize(m_positional_args.size(), true);\n    int total_values_required = 0;\n    for (size_t i = 0; i < m_positional_args.size(); i++) {\n        auto& arg = m_positional_args[i];\n        num_values_for_arg[i] = arg.min_values;\n        total_values_required += arg.min_values;\n    }\n\n    if (total_values_required > values_left) {\n        print_usage_and_exit();\n        return false;\n    }\n    int extra_values_to_distribute = values_left - total_values_required;\n\n    for (size_t i = 0; i < m_positional_args.size(); i++) {\n        auto& arg = m_positional_args[i];\n        int extra_values_to_this_arg = min(arg.max_values - arg.min_values, extra_values_to_distribute);\n        num_values_for_arg[i] += extra_values_to_this_arg;\n        extra_values_to_distribute -= extra_values_to_this_arg;\n        if (extra_values_to_distribute == 0)\n            break;\n    }\n\n    if (extra_values_to_distribute > 0) {\n        // We still have too many values :(\n        print_usage_and_exit();\n        return false;\n    }\n\n    for (size_t i = 0; i < m_positional_args.size(); i++) {\n        auto& arg = m_positional_args[i];\n        for (int j = 0; j < num_values_for_arg[i]; j++) {\n            const char* value = argv[optind++];\n            if (!arg.accept_value(value)) {\n                warnln(\"Invalid value for argument {}\", arg.name);\n                print_usage_and_exit();\n                return false;\n            }\n        }\n    }\n\n    // We're done parsing! :)\n    // Now let's show help if requested.\n    if (m_show_help) {\n        print_usage(stdout, argv[0]);\n        if (exit_on_failure)\n            exit(0);\n        return false;\n    }\n\n    return true;\n}",
  "abstract_func": "bool ArgsParser::parse(int VAR_0, char** VAR_1, bool VAR_2)\n{\n    auto VAR_3 = [this, VAR_1, VAR_2] {\n        print_usage(VAR_4, VAR_1[0]);\n        if (VAR_2)\n            exit(1);\n    };\n\n    Vector<option> VAR_5;\n    StringBuilder VAR_6;\n\n    int VAR_7 = -1;\n\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n    VAR_8 = 0;\n\n    for (size_t VAR_9 = 0; VAR_9 < VAR_10.size(); VAR_9++) {\n        auto& VAR_11 = VAR_10[VAR_9];\n        if (VAR_11.long_name) {\n            option VAR_12 {\n                VAR_11.long_name,\n                VAR_11.requires_argument ? VAR_13 : VAR_14,\n                &VAR_7,\n                VAR_15<int>(VAR_9)\n            };\n            VAR_5.append(VAR_12);\n        }\n        if (VAR_11.short_name) {\n            VAR_6.append(VAR_11.short_name);\n            if (VAR_11.requires_argument)\n                VAR_6.append(':');\n        }\n    }\n    VAR_5.append({ 0, 0, 0, 0 });\n\n    String VAR_16 = VAR_6.build();\n\n    while (true) {\n        int VAR_17 = getopt_long(VAR_0, VAR_1, VAR_16.characters(), VAR_5.data(), nullptr);\n        if (VAR_17 == -1) {\n            /* COMMENT_2 */\n            break;\n        } else if (VAR_17 == '?') {\n            /* COMMENT_3 */\n            /* COMMENT_4 */\n            VAR_3();\n            return false;\n        }\n\n        /* COMMENT_5 */\n        Option* VAR_18 = nullptr;\n        if (VAR_17 == 0) {\n            /* COMMENT_6 */\n            VERIFY(VAR_7 >= 0);\n            VAR_18 = &VAR_10[VAR_7];\n            VAR_7 = -1;\n        } else {\n            /* COMMENT_7 */\n            auto VAR_19 = VAR_10.find_if([VAR_17](auto& VAR_11) { return VAR_17 == VAR_11.short_name; });\n            VERIFY(!VAR_19.is_end());\n            VAR_18 = &*VAR_19;\n        }\n        VERIFY(VAR_18);\n\n        const char* VAR_20 = VAR_18->requires_argument ? VAR_21 : nullptr;\n        if (!VAR_18->accept_value(VAR_20)) {\n            warnln(\"\\033[31mInvalid value for option \\033[1m{}\\033[22m, dude\\033[0m\", VAR_18->name_for_display());\n            VAR_3();\n            return false;\n        }\n    }\n\n    /* COMMENT_8 */\n\n    int VAR_22 = VAR_0 - VAR_8;\n    Vector<int, 16> VAR_23;\n    VAR_23.resize(VAR_24.size(), true);\n    int VAR_25 = 0;\n    for (size_t VAR_9 = 0; VAR_9 < VAR_24.size(); VAR_9++) {\n        auto& VAR_20 = VAR_24[VAR_9];\n        VAR_23[VAR_9] = VAR_20.min_values;\n        VAR_25 += VAR_20.min_values;\n    }\n\n    if (VAR_25 > VAR_22) {\n        VAR_3();\n        return false;\n    }\n    int VAR_26 = VAR_22 - VAR_25;\n\n    for (size_t VAR_9 = 0; VAR_9 < VAR_24.size(); VAR_9++) {\n        auto& VAR_20 = VAR_24[VAR_9];\n        int VAR_27 = min(VAR_20.max_values - VAR_20.min_values, VAR_26);\n        VAR_23[VAR_9] += VAR_27;\n        VAR_26 -= VAR_27;\n        if (VAR_26 == 0)\n            break;\n    }\n\n    if (VAR_26 > 0) {\n        /* COMMENT_9 */\n        VAR_3();\n        return false;\n    }\n\n    for (size_t VAR_9 = 0; VAR_9 < VAR_24.size(); VAR_9++) {\n        auto& VAR_20 = VAR_24[VAR_9];\n        for (int VAR_28 = 0; VAR_28 < VAR_23[VAR_9]; VAR_28++) {\n            const char* VAR_29 = VAR_1[VAR_8++];\n            if (!VAR_20.accept_value(VAR_29)) {\n                warnln(\"Invalid value for argument {}\", VAR_20.name);\n                VAR_3();\n                return false;\n            }\n        }\n    }\n\n    /* COMMENT_10 */\n    /* COMMENT_11 */\n    if (VAR_30) {\n        print_usage(VAR_31, VAR_1[0]);\n        if (VAR_2)\n            exit(0);\n        return false;\n    }\n\n    return true;\n}",
  "func_graph_path": "SerenityOS/serenity/fafe204ef20c6717427916cc4795a28adafe2f69/ArgsParser.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -74,7 +74,8 @@\n     // We're done processing options, now let's parse positional arguments.\n \n     int values_left = argc - optind;\n-    int num_values_for_arg[m_positional_args.size()];\n+    Vector<int, 16> num_values_for_arg;\n+    num_values_for_arg.resize(m_positional_args.size(), true);\n     int total_values_required = 0;\n     for (size_t i = 0; i < m_positional_args.size(); i++) {\n         auto& arg = m_positional_args[i];",
  "diff_line_info": {
    "deleted_lines": [
      "    int num_values_for_arg[m_positional_args.size()];"
    ],
    "added_lines": [
      "    Vector<int, 16> num_values_for_arg;",
      "    num_values_for_arg.resize(m_positional_args.size(), true);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/SerenityOS/serenity/pull/7157",
  "description": {
    "pr_info": {
      "title": "Tests/CI: Resolve ASAN/UBSAN errors and run with Sanitizers in CI",
      "number": 7157
    },
    "comment": [
      "Fixes the last remaining UBSAN and ASAN reported errors in the current suite of Lagom tests.\r\n\r\n- Copying a zero size byte buffer would pass nullptr to __builtin_memcpy\r\n- Zero Length VLAs were possible in ArgsParser::parse\r\n- BitmapView::count_in_range would read one-past-the-end of byte-aligned sized bitmaps. Fixes #7073 \r\n\r\nAnd finally, enable USBAN and ASAN in CI runs so that properly sanitized Tests/UUTs become other people's problems too :^)",
      "Note that building with ASAN and UBSAN significantly increases the Lagom build times.. not sure what can be done about that. It seems very valuable to run with sanitizers in CI.",
      "> Note that building with ASAN and UBSAN significantly increases the Lagom build times.. not sure what can be done about that. It seems very valuable to run with sanitizers in CI.\r\n\r\nlooks like building lagom with sanitizers is still faster than building serenity for on-target tests, so that doesnt really matter :)",
      "> I believe this commit breaks BitMapView::count_in_range() when doing multiples of 8, showing a count that is missing the last byte. I was looking at this bug earlier and had added some more tests, for example:\r\n> \r\n> ```\r\n> Bitmap bitmap(16, true);\r\n> EXPECT_EQ(bitmap.count_in_range(0,16,true),16u);\r\n> ```\r\n> \r\n> Fails with\r\n> `EXPECT_EQ(bitmap.count_in_range(0,16,true), 16u) failed with lhs=8 and rhs=16`\r\n> \r\n> ```\r\n> Bitmap bitmap(16, true);\r\n> EXPECT_EQ(bitmap.count_in_range(8,8,true),8u);\r\n> ```\r\n> \r\n> Fails with\r\n> `EXPECT_EQ(bitmap.count_in_range(8,8,true), 8u) failed with lhs=0 and rhs=8`\r\n\r\nSo it does. Dang. Thanks. Back to the drawing board.",
      "@metmo I tried to request a re-review through the gitlab UI but it doesn't seem to be showing up ü§∑‚Äç‚ôÇÔ∏è  So sorry if it spammed you. Anyway, I think this new strategy should be correct, and I added more test cases similar to the ones you posted."
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.9"
}