{
  "cve_id": "CVE-2023-39949",
  "cwe_ids": [
    "CWE-617"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "eProsima/Fast-DDS",
  "commit_msg": "Implement a validity check for firstSN\n\nFollowing 8.3.8.6.3 of DDS-RTPS 2.5.\nThis fixes issue #3236.\n\nSigned-off-by: Seulbae Kim <squizz617@gmail.com>",
  "commit_hash": "60c15edf9e5ddf813d3ea25fa3ef2ccdae4e11a6",
  "git_url": "https://github.com/eProsima/Fast-DDS/commit/60c15edf9e5ddf813d3ea25fa3ef2ccdae4e11a6",
  "file_path": "src/cpp/rtps/messages/MessageReceiver.cpp",
  "func_name": "MessageReceiver::proc_Submsg_Heartbeat",
  "func_before": "bool MessageReceiver::proc_Submsg_Heartbeat(\n        CDRMessage_t* msg,\n        SubmessageHeader_t* smh) const\n{\n    eprosima::shared_lock<eprosima::shared_mutex> guard(mtx_);\n\n    bool endiannessFlag = (smh->flags & BIT(0)) != 0;\n    bool finalFlag = (smh->flags & BIT(1)) != 0;\n    bool livelinessFlag = (smh->flags & BIT(2)) != 0;\n    //Assign message endianness\n    if (endiannessFlag)\n    {\n        msg->msg_endian = LITTLEEND;\n    }\n    else\n    {\n        msg->msg_endian = BIGEND;\n    }\n\n    GUID_t readerGUID;\n    GUID_t writerGUID;\n    readerGUID.guidPrefix = dest_guid_prefix_;\n    CDRMessage::readEntityId(msg, &readerGUID.entityId);\n    writerGUID.guidPrefix = source_guid_prefix_;\n    CDRMessage::readEntityId(msg, &writerGUID.entityId);\n    SequenceNumber_t firstSN;\n    SequenceNumber_t lastSN;\n    CDRMessage::readSequenceNumber(msg, &firstSN);\n    CDRMessage::readSequenceNumber(msg, &lastSN);\n    if (lastSN < firstSN && lastSN != firstSN - 1)\n    {\n        EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Invalid Heartbeat received (\" << firstSN << \") - (\" <<\n                lastSN << \"), ignoring\");\n        return false;\n    }\n    uint32_t HBCount;\n    if (!CDRMessage::readUInt32(msg, &HBCount))\n    {\n        EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Unable to read heartbeat count from heartbeat message\");\n        return false;\n    }\n\n    //Look for the correct reader and writers:\n    findAllReaders(readerGUID.entityId,\n            [&writerGUID, &HBCount, &firstSN, &lastSN, finalFlag, livelinessFlag](RTPSReader* reader)\n            {\n                reader->processHeartbeatMsg(writerGUID, HBCount, firstSN, lastSN, finalFlag, livelinessFlag);\n            });\n\n    return true;\n}",
  "abstract_func_before": "bool MessageReceiver::proc_Submsg_Heartbeat(\n        CDRMessage_t* VAR_0,\n        SubmessageHeader_t* VAR_1) const\n{\n    eprosima::shared_lock<eprosima::shared_mutex> guard(mtx_);\n\n    bool VAR_2 = (VAR_1->flags & BIT(0)) != 0;\n    bool VAR_3 = (VAR_1->flags & BIT(1)) != 0;\n    bool VAR_4 = (VAR_1->flags & BIT(2)) != 0;\n    /* COMMENT_0 */\n    if (VAR_2)\n    {\n        VAR_0->msg_endian = VAR_5;\n    }\n    else\n    {\n        VAR_0->msg_endian = VAR_6;\n    }\n\n    GUID_t VAR_7;\n    GUID_t VAR_8;\n    VAR_7.guidPrefix = VAR_9;\n    CDRMessage::readEntityId(VAR_0, &VAR_7.entityId);\n    VAR_8.guidPrefix = VAR_10;\n    CDRMessage::readEntityId(VAR_0, &VAR_8.entityId);\n    SequenceNumber_t VAR_11;\n    SequenceNumber_t VAR_12;\n    CDRMessage::readSequenceNumber(VAR_0, &VAR_11);\n    CDRMessage::readSequenceNumber(VAR_0, &VAR_12);\n    if (VAR_12 < VAR_11 && VAR_12 != VAR_11 - 1)\n    {\n        EPROSIMA_LOG_WARNING(VAR_13, VAR_14 \"Invalid Heartbeat received (\" << VAR_11 << \") - (\" <<\n                VAR_12 << \"), ignoring\");\n        return false;\n    }\n    uint32_t VAR_15;\n    if (!CDRMessage::readUInt32(VAR_0, &VAR_15))\n    {\n        EPROSIMA_LOG_WARNING(VAR_13, VAR_14 \"Unable to read heartbeat count from heartbeat message\");\n        return false;\n    }\n\n    /* COMMENT_1 */\n    findAllReaders(VAR_7.entityId,\n            [&VAR_8, &VAR_15, &VAR_11, &VAR_12, VAR_3, VAR_4](RTPSReader* VAR_16)\n            {\n                VAR_16->processHeartbeatMsg(VAR_8, VAR_15, VAR_11, VAR_12, VAR_3, VAR_4);\n            });\n\n    return true;\n}",
  "func_graph_path_before": "eProsima/Fast-DDS/60c15edf9e5ddf813d3ea25fa3ef2ccdae4e11a6/MessageReceiver.cpp/vul/before/0.json",
  "func": "bool MessageReceiver::proc_Submsg_Heartbeat(\n        CDRMessage_t* msg,\n        SubmessageHeader_t* smh) const\n{\n    eprosima::shared_lock<eprosima::shared_mutex> guard(mtx_);\n\n    bool endiannessFlag = (smh->flags & BIT(0)) != 0;\n    bool finalFlag = (smh->flags & BIT(1)) != 0;\n    bool livelinessFlag = (smh->flags & BIT(2)) != 0;\n    //Assign message endianness\n    if (endiannessFlag)\n    {\n        msg->msg_endian = LITTLEEND;\n    }\n    else\n    {\n        msg->msg_endian = BIGEND;\n    }\n\n    GUID_t readerGUID;\n    GUID_t writerGUID;\n    readerGUID.guidPrefix = dest_guid_prefix_;\n    CDRMessage::readEntityId(msg, &readerGUID.entityId);\n    writerGUID.guidPrefix = source_guid_prefix_;\n    CDRMessage::readEntityId(msg, &writerGUID.entityId);\n    SequenceNumber_t firstSN;\n    SequenceNumber_t lastSN;\n    CDRMessage::readSequenceNumber(msg, &firstSN);\n    CDRMessage::readSequenceNumber(msg, &lastSN);\n\n    SequenceNumber_t zeroSN;\n    if (fisrtSN <= zeroSN)\n    {\n        EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Invalid Heartbeat received (\" << firstSN << \" <= 0), ignoring\");\n        return false;\n    }\n    if (lastSN < firstSN && lastSN != firstSN - 1)\n    {\n        EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Invalid Heartbeat received (\" << firstSN << \") - (\" <<\n                lastSN << \"), ignoring\");\n        return false;\n    }\n    uint32_t HBCount;\n    if (!CDRMessage::readUInt32(msg, &HBCount))\n    {\n        EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Unable to read heartbeat count from heartbeat message\");\n        return false;\n    }\n\n    //Look for the correct reader and writers:\n    findAllReaders(readerGUID.entityId,\n            [&writerGUID, &HBCount, &firstSN, &lastSN, finalFlag, livelinessFlag](RTPSReader* reader)\n            {\n                reader->processHeartbeatMsg(writerGUID, HBCount, firstSN, lastSN, finalFlag, livelinessFlag);\n            });\n\n    return true;\n}",
  "abstract_func": "bool MessageReceiver::proc_Submsg_Heartbeat(\n        CDRMessage_t* VAR_0,\n        SubmessageHeader_t* VAR_1) const\n{\n    eprosima::shared_lock<eprosima::shared_mutex> guard(mtx_);\n\n    bool VAR_2 = (VAR_1->flags & BIT(0)) != 0;\n    bool VAR_3 = (VAR_1->flags & BIT(1)) != 0;\n    bool VAR_4 = (VAR_1->flags & BIT(2)) != 0;\n    /* COMMENT_0 */\n    if (VAR_2)\n    {\n        VAR_0->msg_endian = VAR_5;\n    }\n    else\n    {\n        VAR_0->msg_endian = VAR_6;\n    }\n\n    GUID_t VAR_7;\n    GUID_t VAR_8;\n    VAR_7.guidPrefix = VAR_9;\n    CDRMessage::readEntityId(VAR_0, &VAR_7.entityId);\n    VAR_8.guidPrefix = VAR_10;\n    CDRMessage::readEntityId(VAR_0, &VAR_8.entityId);\n    SequenceNumber_t VAR_11;\n    SequenceNumber_t VAR_12;\n    CDRMessage::readSequenceNumber(VAR_0, &VAR_11);\n    CDRMessage::readSequenceNumber(VAR_0, &VAR_12);\n\n    SequenceNumber_t VAR_13;\n    if (VAR_14 <= VAR_13)\n    {\n        EPROSIMA_LOG_WARNING(VAR_15, VAR_16 \"Invalid Heartbeat received (\" << VAR_11 << \" <= 0), ignoring\");\n        return false;\n    }\n    if (VAR_12 < VAR_11 && VAR_12 != VAR_11 - 1)\n    {\n        EPROSIMA_LOG_WARNING(VAR_15, VAR_16 \"Invalid Heartbeat received (\" << VAR_11 << \") - (\" <<\n                VAR_12 << \"), ignoring\");\n        return false;\n    }\n    uint32_t VAR_17;\n    if (!CDRMessage::readUInt32(VAR_0, &VAR_17))\n    {\n        EPROSIMA_LOG_WARNING(VAR_15, VAR_16 \"Unable to read heartbeat count from heartbeat message\");\n        return false;\n    }\n\n    /* COMMENT_1 */\n    findAllReaders(VAR_7.entityId,\n            [&VAR_8, &VAR_17, &VAR_11, &VAR_12, VAR_3, VAR_4](RTPSReader* VAR_18)\n            {\n                VAR_18->processHeartbeatMsg(VAR_8, VAR_17, VAR_11, VAR_12, VAR_3, VAR_4);\n            });\n\n    return true;\n}",
  "func_graph_path": "eProsima/Fast-DDS/60c15edf9e5ddf813d3ea25fa3ef2ccdae4e11a6/MessageReceiver.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -27,6 +27,13 @@\n     SequenceNumber_t lastSN;\n     CDRMessage::readSequenceNumber(msg, &firstSN);\n     CDRMessage::readSequenceNumber(msg, &lastSN);\n+\n+    SequenceNumber_t zeroSN;\n+    if (fisrtSN <= zeroSN)\n+    {\n+        EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Invalid Heartbeat received (\" << firstSN << \" <= 0), ignoring\");\n+        return false;\n+    }\n     if (lastSN < firstSN && lastSN != firstSN - 1)\n     {\n         EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Invalid Heartbeat received (\" << firstSN << \") - (\" <<",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "",
      "    SequenceNumber_t zeroSN;",
      "    if (fisrtSN <= zeroSN)",
      "    {",
      "        EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Invalid Heartbeat received (\" << firstSN << \" <= 0), ignoring\");",
      "        return false;",
      "    }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/eProsima/Fast-DDS/pull/3274",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/eProsima/Fast-DDS/pull/3274: 403 Client Error: Forbidden for url: https://api.github.com/repos/eProsima/Fast-DDS/pulls/3274",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.9\n\n**Step-by-Step Explanation:**\n\n1. **Input Analysis**: The commit message mentions implementing a validity check as per a standard, addressing issue #3236. The vulnerability description specifies an assertion failure due to invalid firstSN values, linking to a security concern.\n\n2. **Consistency Check**: The code adds a validation check for firstSN, which directly addresses the described issue without discrepancies.\n\n3. **Purpose Evaluation**: The patch introduces input validation for a specific condition (firstSN <= zeroSN), preventing assertion failures. This is a core logic fix.\n\n4. **Security Assessment**: The fix addresses an external input issue, preventing a potential crash, which is a security concern. While no CVE/CWE is cited, the context strongly suggests a security vulnerability.\n\n5. **Classification**: The fix prevents exploitable input handling, classifying it as a security fix.\n\n6. **Confidence**: High confidence due to clear alignment between issue, code change, and security implications."
}