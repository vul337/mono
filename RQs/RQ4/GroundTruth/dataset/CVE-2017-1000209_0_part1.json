{
  "cve_id": "CVE-2017-1000209",
  "cwe_ids": [
    "CWE-295"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:N/A:N",
  "cvss_is_v3": false,
  "repo_name": "TakahikoKawasaki/nv-websocket-client",
  "commit_msg": "Verify that certificate is valid for server hostname\n\nWithout this change, the WebSocket library will accept\na trusted certificate issued for domain A when connecting\nto domain B. This could be exploited for Man-in-the-middle\nattacks.\n\nThe underlying issue is that Java considers hostname\nverification to be a part of HTTPS and as such, will\nnot perform it by default.\n\nThis change adds the default HostnameVerifier used\nby Android, which in recent versions is derived from\nOkHttp. Minor changes were made to make it build for\nJava 1.6.\n\nTested with and without a proxy configured.",
  "commit_hash": "feb9c8302757fd279f4cfc99cbcdfb6ee709402d",
  "git_url": "https://github.com/TakahikoKawasaki/nv-websocket-client/commit/feb9c8302757fd279f4cfc99cbcdfb6ee709402d",
  "file_path": "src/main/java/com/neovisionaries/ws/client/SocketConnector.java",
  "func_name": "handshake",
  "func_before": "private void handshake() throws WebSocketException\n    {\n        try\n        {\n            // Perform handshake with the proxy server.\n            mProxyHandshaker.perform();\n        }\n        catch (IOException e)\n        {\n            // Handshake with the proxy server failed.\n            String message = String.format(\n                \"Handshake with the proxy server (%s) failed: %s\", mAddress, e.getMessage());\n\n            // Raise an exception with PROXY_HANDSHAKE_ERROR.\n            throw new WebSocketException(WebSocketError.PROXY_HANDSHAKE_ERROR, message, e);\n        }\n\n        if (mSSLSocketFactory == null)\n        {\n            // SSL handshake with the WebSocket endpoint is not needed.\n            return;\n        }\n\n        try\n        {\n            // Overlay the existing socket.\n            mSocket = mSSLSocketFactory.createSocket(mSocket, mHost, mPort, true);\n        }\n        catch (IOException e)\n        {\n            // Failed to overlay an existing socket.\n            String message = \"Failed to overlay an existing socket: \" + e.getMessage();\n\n            // Raise an exception with SOCKET_OVERLAY_ERROR.\n            throw new WebSocketException(WebSocketError.SOCKET_OVERLAY_ERROR, message, e);\n        }\n\n        try\n        {\n            // Start the SSL handshake manually. As for the reason, see\n            // http://docs.oracle.com/javase/7/docs/technotes/guides/security/jsse/samples/sockets/client/SSLSocketClient.java\n            ((SSLSocket)mSocket).startHandshake();\n        }\n        catch (IOException e)\n        {\n            // SSL handshake with the WebSocket endpoint failed.\n            String message = String.format(\n                \"SSL handshake with the WebSocket endpoint (%s) failed: %s\", mAddress, e.getMessage());\n\n            // Raise an exception with SSL_HANDSHAKE_ERROR.\n            throw new WebSocketException(WebSocketError.SSL_HANDSHAKE_ERROR, message, e);\n        }\n    }",
  "abstract_func_before": "private void handshake() throws WebSocketException\n    {\n        try\n        {\n            /* COMMENT_0 */\n            VAR_0.perform();\n        }\n        catch (IOException VAR_1)\n        {\n            /* COMMENT_1 */\n            String VAR_2 = VAR_3.format(\n                \"Handshake with the proxy server (%s) failed: %s\", VAR_4, VAR_1.getMessage());\n\n            /* COMMENT_2 */\n            throw new WebSocketException(VAR_5.PROXY_HANDSHAKE_ERROR, VAR_2, VAR_1);\n        }\n\n        if (VAR_6 == null)\n        {\n            /* COMMENT_3 */\n            return;\n        }\n\n        try\n        {\n            /* COMMENT_4 */\n            VAR_7 = VAR_6.createSocket(VAR_7, VAR_8, VAR_9, true);\n        }\n        catch (IOException VAR_1)\n        {\n            /* COMMENT_5 */\n            String VAR_2 = \"Failed to overlay an existing socket: \" + VAR_1.getMessage();\n\n            /* COMMENT_6 */\n            throw new WebSocketException(VAR_5.SOCKET_OVERLAY_ERROR, VAR_2, VAR_1);\n        }\n\n        try\n        {\n            /* COMMENT_7 */\n            /* COMMENT_8 */\n            ((SSLSocket)VAR_7).startHandshake();\n        }\n        catch (IOException VAR_1)\n        {\n            /* COMMENT_9 */\n            String VAR_2 = VAR_3.format(\n                \"SSL handshake with the WebSocket endpoint (%s) failed: %s\", VAR_4, VAR_1.getMessage());\n\n            /* COMMENT_10 */\n            throw new WebSocketException(VAR_5.SSL_HANDSHAKE_ERROR, VAR_2, VAR_1);\n        }\n    }",
  "func_graph_path_before": "TakahikoKawasaki/nv-websocket-client/feb9c8302757fd279f4cfc99cbcdfb6ee709402d/SocketConnector.java/vul/before/1.json",
  "func": "private void handshake() throws WebSocketException\n    {\n        try\n        {\n            // Perform handshake with the proxy server.\n            mProxyHandshaker.perform();\n        }\n        catch (IOException e)\n        {\n            // Handshake with the proxy server failed.\n            String message = String.format(\n                \"Handshake with the proxy server (%s) failed: %s\", mAddress, e.getMessage());\n\n            // Raise an exception with PROXY_HANDSHAKE_ERROR.\n            throw new WebSocketException(WebSocketError.PROXY_HANDSHAKE_ERROR, message, e);\n        }\n\n        if (mSSLSocketFactory == null)\n        {\n            // SSL handshake with the WebSocket endpoint is not needed.\n            return;\n        }\n\n        try\n        {\n            // Overlay the existing socket.\n            mSocket = mSSLSocketFactory.createSocket(mSocket, mHost, mPort, true);\n        }\n        catch (IOException e)\n        {\n            // Failed to overlay an existing socket.\n            String message = \"Failed to overlay an existing socket: \" + e.getMessage();\n\n            // Raise an exception with SOCKET_OVERLAY_ERROR.\n            throw new WebSocketException(WebSocketError.SOCKET_OVERLAY_ERROR, message, e);\n        }\n\n        try\n        {\n            // Start the SSL handshake manually. As for the reason, see\n            // http://docs.oracle.com/javase/7/docs/technotes/guides/security/jsse/samples/sockets/client/SSLSocketClient.java\n            ((SSLSocket)mSocket).startHandshake();\n            \n            if (mSocket instanceof SSLSocket)\n            {\n                // Verify that the proxied hostname matches the certificate here since\n                // this is not automatically done by the SSLSocket.\n                OkHostnameVerifier hostnameVerifier = OkHostnameVerifier.INSTANCE;\n                \n                SSLSession sslSession = ((SSLSocket) mSocket).getSession();\n            \n                if (!hostnameVerifier.verify(mProxyHandshaker.getProxiedHostname(), sslSession))\n                {\n                    throw new SSLPeerUnverifiedException(\"Proxied hostname \" + mProxyHandshaker.getProxiedHostname()\n                            + \" does not match certificate (\" + sslSession.getPeerPrincipal() + \")\");\n                }\n            }\n        }\n        catch (IOException e)\n        {\n            // SSL handshake with the WebSocket endpoint failed.\n            String message = String.format(\n                \"SSL handshake with the WebSocket endpoint (%s) failed: %s\", mAddress, e.getMessage());\n\n            // Raise an exception with SSL_HANDSHAKE_ERROR.\n            throw new WebSocketException(WebSocketError.SSL_HANDSHAKE_ERROR, message, e);\n        }\n    }",
  "abstract_func": "private void handshake() throws WebSocketException\n    {\n        try\n        {\n            /* COMMENT_0 */\n            VAR_0.perform();\n        }\n        catch (IOException VAR_1)\n        {\n            /* COMMENT_1 */\n            String VAR_2 = VAR_3.format(\n                \"Handshake with the proxy server (%s) failed: %s\", VAR_4, VAR_1.getMessage());\n\n            /* COMMENT_2 */\n            throw new WebSocketException(VAR_5.PROXY_HANDSHAKE_ERROR, VAR_2, VAR_1);\n        }\n\n        if (VAR_6 == null)\n        {\n            /* COMMENT_3 */\n            return;\n        }\n\n        try\n        {\n            /* COMMENT_4 */\n            VAR_7 = VAR_6.createSocket(VAR_7, VAR_8, VAR_9, true);\n        }\n        catch (IOException VAR_1)\n        {\n            /* COMMENT_5 */\n            String VAR_2 = \"Failed to overlay an existing socket: \" + VAR_1.getMessage();\n\n            /* COMMENT_6 */\n            throw new WebSocketException(VAR_5.SOCKET_OVERLAY_ERROR, VAR_2, VAR_1);\n        }\n\n        try\n        {\n            /* COMMENT_7 */\n            /* COMMENT_8 */\n            ((SSLSocket)VAR_7).startHandshake();\n            \n            if (VAR_7 instanceof SSLSocket)\n            {\n                /* COMMENT_9 */\n                /* COMMENT_10 */\n                OkHostnameVerifier VAR_10 = VAR_11.INSTANCE;\n                \n                SSLSession VAR_12 = ((SSLSocket) VAR_7).getSession();\n            \n                if (!VAR_10.verify(VAR_0.getProxiedHostname(), VAR_12))\n                {\n                    throw new SSLPeerUnverifiedException(\"Proxied hostname \" + VAR_0.getProxiedHostname()\n                            + \" does not match certificate (\" + VAR_12.getPeerPrincipal() + \")\");\n                }\n            }\n        }\n        catch (IOException VAR_1)\n        {\n            /* COMMENT_11 */\n            String VAR_2 = VAR_3.format(\n                \"SSL handshake with the WebSocket endpoint (%s) failed: %s\", VAR_4, VAR_1.getMessage());\n\n            /* COMMENT_12 */\n            throw new WebSocketException(VAR_5.SSL_HANDSHAKE_ERROR, VAR_2, VAR_1);\n        }\n    }",
  "func_graph_path": "TakahikoKawasaki/nv-websocket-client/feb9c8302757fd279f4cfc99cbcdfb6ee709402d/SocketConnector.java/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -40,6 +40,21 @@\n             // Start the SSL handshake manually. As for the reason, see\n             // http://docs.oracle.com/javase/7/docs/technotes/guides/security/jsse/samples/sockets/client/SSLSocketClient.java\n             ((SSLSocket)mSocket).startHandshake();\n+            \n+            if (mSocket instanceof SSLSocket)\n+            {\n+                // Verify that the proxied hostname matches the certificate here since\n+                // this is not automatically done by the SSLSocket.\n+                OkHostnameVerifier hostnameVerifier = OkHostnameVerifier.INSTANCE;\n+                \n+                SSLSession sslSession = ((SSLSocket) mSocket).getSession();\n+            \n+                if (!hostnameVerifier.verify(mProxyHandshaker.getProxiedHostname(), sslSession))\n+                {\n+                    throw new SSLPeerUnverifiedException(\"Proxied hostname \" + mProxyHandshaker.getProxiedHostname()\n+                            + \" does not match certificate (\" + sslSession.getPeerPrincipal() + \")\");\n+                }\n+            }\n         }\n         catch (IOException e)\n         {",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "            ",
      "            if (mSocket instanceof SSLSocket)",
      "            {",
      "                // Verify that the proxied hostname matches the certificate here since",
      "                // this is not automatically done by the SSLSocket.",
      "                OkHostnameVerifier hostnameVerifier = OkHostnameVerifier.INSTANCE;",
      "                ",
      "                SSLSession sslSession = ((SSLSocket) mSocket).getSession();",
      "            ",
      "                if (!hostnameVerifier.verify(mProxyHandshaker.getProxiedHostname(), sslSession))",
      "                {",
      "                    throw new SSLPeerUnverifiedException(\"Proxied hostname \" + mProxyHandshaker.getProxiedHostname()",
      "                            + \" does not match certificate (\" + sslSession.getPeerPrincipal() + \")\");",
      "                }",
      "            }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/TakahikoKawasaki/nv-websocket-client/pull/107",
  "description": {
    "pr_info": {
      "title": "Verify that certificate is valid for server hostname",
      "number": 107
    },
    "comment": [
      "Without this change, the WebSocket library will accept\r\na trusted certificate issued for domain A when connecting\r\nto domain B. This could be exploited for Man-in-the-middle\r\nattacks.\r\n\r\nThe underlying issue is that Java considers hostname\r\nverification to be a part of HTTPS and as such, will\r\nnot perform it by default.\r\n\r\nThis change adds the default HostnameVerifier used\r\nby Android, which in recent versions is derived from\r\nOkHttp. Minor changes were made to make it build for\r\nJava 1.6.\r\n\r\nTested with and without a proxy configured.",
      "@TakahikoKawasaki A public test server that can be used to reliably reproduce this issue is available to you upon request.\r\n\r\n**Status with this change:**\r\n- **No proxy:** Working\r\n- **Standard HTTP proxy:** Working (verifies that hostname of the wss:// request matches certificate of the endpoint server)\r\n- **HTTPS proxy:** Untested (likely not working but I was unable to find a suitable proxy to test this with)",
      "@blunden Thank you very much. Apparently, you have much more knowledge about this field than I.",
      "@blunden Released nv-websocket-client version 2.2. `WebSocket.connect()` method throws `HostnameUnverifiedException` (a subclass of `WebSocketException`) when the certificate of the peer does not match the expected hostname. Thank you for your contribution.",
      "@TakahikoKawasaki Thanks for merging it.\r\n\r\nYou will likely need to add hostname verification of the proxy's certificate if it's an HTTPS proxy. Like I said above, I don't have any of those to test with so currently it won't verify the hostname of the proxy, which it really should. It would probably be a simple fix but the ProxyHandshaker or Address would have to be able to return whether the user specified an http or https proxy address. You could then just add an if-statement based on that and a similar hostname verification of mAddress.getHostname() (which I think will be the proxy hostname) inside it. It did not do it myself because I couldn't test it and didn't want to risk breaking it."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}