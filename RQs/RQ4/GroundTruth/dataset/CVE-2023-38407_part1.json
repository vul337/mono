{
  "cve_id": "CVE-2023-38407",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "FRRouting/frr",
  "commit_msg": "bgpd: Fix use beyond end of stream of labeled unicast parsing\n\nFixes a couple crashes associated with attempting to read\nbeyond the end of the stream.\n\nReported-by: Iggy Frankovic <iggyfran@amazon.com>\nSigned-off-by: Donald Sharp <sharpd@nvidia.com>",
  "commit_hash": "7404a914b0cafe046703c8381903a80d3def8f8b",
  "git_url": "https://github.com/FRRouting/frr/commit/7404a914b0cafe046703c8381903a80d3def8f8b",
  "file_path": "bgpd/bgp_label.c",
  "func_name": "bgp_nlri_parse_label",
  "func_before": "int bgp_nlri_parse_label(struct peer *peer, struct attr *attr,\n\t\t\t struct bgp_nlri *packet)\n{\n\tuint8_t *pnt;\n\tuint8_t *lim;\n\tstruct prefix p;\n\tint psize = 0;\n\tint prefixlen;\n\tafi_t afi;\n\tsafi_t safi;\n\tbool addpath_capable;\n\tuint32_t addpath_id;\n\tmpls_label_t label = MPLS_INVALID_LABEL;\n\tuint8_t llen;\n\n\tpnt = packet->nlri;\n\tlim = pnt + packet->length;\n\tafi = packet->afi;\n\tsafi = packet->safi;\n\taddpath_id = 0;\n\n\taddpath_capable = bgp_addpath_encode_rx(peer, afi, safi);\n\n\tfor (; pnt < lim; pnt += psize) {\n\t\t/* Clear prefix structure. */\n\t\tmemset(&p, 0, sizeof(p));\n\n\t\tif (addpath_capable) {\n\n\t\t\t/* When packet overflow occurs return immediately. */\n\t\t\tif (pnt + BGP_ADDPATH_ID_LEN > lim)\n\t\t\t\treturn BGP_NLRI_PARSE_ERROR_PACKET_OVERFLOW;\n\n\t\t\tmemcpy(&addpath_id, pnt, BGP_ADDPATH_ID_LEN);\n\t\t\taddpath_id = ntohl(addpath_id);\n\t\t\tpnt += BGP_ADDPATH_ID_LEN;\n\t\t}\n\n\t\t/* Fetch prefix length. */\n\t\tprefixlen = *pnt++;\n\t\tp.family = afi2family(packet->afi);\n\t\tpsize = PSIZE(prefixlen);\n\n\t\t/* sanity check against packet data */\n\t\tif ((pnt + psize) > lim) {\n\t\t\tflog_err(\n\t\t\t\tEC_BGP_UPDATE_RCV,\n\t\t\t\t\"%s [Error] Update packet error / L-U (prefix length %d exceeds packet size %u)\",\n\t\t\t\tpeer->host, prefixlen, (uint)(lim - pnt));\n\t\t\treturn BGP_NLRI_PARSE_ERROR_PACKET_OVERFLOW;\n\t\t}\n\n\t\t/* Fill in the labels */\n\t\tllen = bgp_nlri_get_labels(peer, pnt, psize, &label);\n\t\tp.prefixlen = prefixlen - BSIZE(llen);\n\n\t\t/* There needs to be at least one label */\n\t\tif (prefixlen < 24) {\n\t\t\tflog_err(EC_BGP_UPDATE_RCV,\n\t\t\t\t \"%s [Error] Update packet error (wrong label length %d)\",\n\t\t\t\t peer->host, prefixlen);\n\t\t\tbgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\t\tBGP_NOTIFY_UPDATE_INVAL_NETWORK);\n\t\t\treturn BGP_NLRI_PARSE_ERROR_LABEL_LENGTH;\n\t\t}\n\n\t\tif ((afi == AFI_IP && p.prefixlen > IPV4_MAX_BITLEN)\n\t\t    || (afi == AFI_IP6 && p.prefixlen > IPV6_MAX_BITLEN))\n\t\t\treturn BGP_NLRI_PARSE_ERROR_PREFIX_LENGTH;\n\n\t\t/* Fetch prefix from NLRI packet */\n\t\tmemcpy(&p.u.prefix, pnt + llen, psize - llen);\n\n\t\t/* Check address. */\n\t\tif (afi == AFI_IP && safi == SAFI_LABELED_UNICAST) {\n\t\t\tif (IN_CLASSD(ntohl(p.u.prefix4.s_addr))) {\n\t\t\t\t/* From RFC4271 Section 6.3:\n\t\t\t\t *\n\t\t\t\t * If a prefix in the NLRI field is semantically\n\t\t\t\t * incorrect\n\t\t\t\t * (e.g., an unexpected multicast IP address),\n\t\t\t\t * an error SHOULD\n\t\t\t\t * be logged locally, and the prefix SHOULD be\n\t\t\t\t * ignored.\n\t\t\t\t  */\n\t\t\t\tflog_err(\n\t\t\t\t\tEC_BGP_UPDATE_RCV,\n\t\t\t\t\t\"%s: IPv4 labeled-unicast NLRI is multicast address %pI4, ignoring\",\n\t\t\t\t\tpeer->host, &p.u.prefix4);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* Check address. */\n\t\tif (afi == AFI_IP6 && safi == SAFI_LABELED_UNICAST) {\n\t\t\tif (IN6_IS_ADDR_LINKLOCAL(&p.u.prefix6)) {\n\t\t\t\tflog_err(\n\t\t\t\t\tEC_BGP_UPDATE_RCV,\n\t\t\t\t\t\"%s: IPv6 labeled-unicast NLRI is link-local address %pI6, ignoring\",\n\t\t\t\t\tpeer->host, &p.u.prefix6);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (IN6_IS_ADDR_MULTICAST(&p.u.prefix6)) {\n\t\t\t\tflog_err(\n\t\t\t\t\tEC_BGP_UPDATE_RCV,\n\t\t\t\t\t\"%s: IPv6 unicast NLRI is multicast address %pI6, ignoring\",\n\t\t\t\t\tpeer->host, &p.u.prefix6);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (attr) {\n\t\t\tbgp_update(peer, &p, addpath_id, attr, packet->afi,\n\t\t\t\t   safi, ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL,\n\t\t\t\t   NULL, &label, 1, 0, NULL);\n\t\t} else {\n\t\t\tbgp_withdraw(peer, &p, addpath_id, packet->afi,\n\t\t\t\t     SAFI_UNICAST, ZEBRA_ROUTE_BGP,\n\t\t\t\t     BGP_ROUTE_NORMAL, NULL, &label, 1, NULL);\n\t\t}\n\t}\n\n\t/* Packet length consistency check. */\n\tif (pnt != lim) {\n\t\tflog_err(\n\t\t\tEC_BGP_UPDATE_RCV,\n\t\t\t\"%s [Error] Update packet error / L-U (%td data remaining after parsing)\",\n\t\t\tpeer->host, lim - pnt);\n\t\treturn BGP_NLRI_PARSE_ERROR_PACKET_LENGTH;\n\t}\n\n\treturn BGP_NLRI_PARSE_OK;\n}",
  "abstract_func_before": "int bgp_nlri_parse_label(struct peer *peer, struct attr *attr,\n\t\t\t struct bgp_nlri *VAR_0)\n{\n\tuint8_t *VAR_1;\n\tuint8_t *VAR_2;\n\tstruct prefix VAR_3;\n\tint VAR_4 = 0;\n\tint VAR_5;\n\tafi_t VAR_6;\n\tsafi_t VAR_7;\n\tbool VAR_8;\n\tuint32_t VAR_9;\n\tmpls_label_t VAR_10 = VAR_11;\n\tuint8_t VAR_12;\n\n\tVAR_1 = VAR_0->nlri;\n\tVAR_2 = VAR_1 + VAR_0->length;\n\tVAR_6 = VAR_0->afi;\n\tVAR_7 = VAR_0->safi;\n\tVAR_9 = 0;\n\n\tVAR_8 = bgp_addpath_encode_rx(peer, VAR_6, VAR_7);\n\n\tfor (; VAR_1 < VAR_2; VAR_1 += VAR_4) {\n\t\t/* COMMENT_0 */\n\t\tmemset(&VAR_3, 0, sizeof(VAR_3));\n\n\t\tif (VAR_8) {\n\n\t\t\t/* COMMENT_1 */\n\t\t\tif (VAR_1 + VAR_13 > VAR_2)\n\t\t\t\treturn VAR_14;\n\n\t\t\tmemcpy(&VAR_9, VAR_1, VAR_13);\n\t\t\tVAR_9 = ntohl(VAR_9);\n\t\t\tVAR_1 += VAR_13;\n\t\t}\n\n\t\t/* COMMENT_2 */\n\t\tVAR_5 = *VAR_1++;\n\t\tVAR_3.family = afi2family(VAR_0->afi);\n\t\tVAR_4 = PSIZE(VAR_5);\n\n\t\t/* COMMENT_3 */\n\t\tif ((VAR_1 + VAR_4) > VAR_2) {\n\t\t\tflog_err(\n\t\t\t\tVAR_15,\n\t\t\t\t\"%s [Error] Update packet error / L-U (prefix length %d exceeds packet size %u)\",\n\t\t\t\tpeer->host, VAR_5, (VAR_16)(VAR_2 - VAR_1));\n\t\t\treturn VAR_14;\n\t\t}\n\n\t\t/* COMMENT_4 */\n\t\tVAR_12 = bgp_nlri_get_labels(peer, VAR_1, VAR_4, &VAR_10);\n\t\tVAR_3.prefixlen = VAR_5 - BSIZE(VAR_12);\n\n\t\t/* COMMENT_5 */\n\t\tif (VAR_5 < 24) {\n\t\t\tflog_err(VAR_15,\n\t\t\t\t \"%s [Error] Update packet error (wrong label length %d)\",\n\t\t\t\t peer->host, VAR_5);\n\t\t\tbgp_notify_send(peer, VAR_17,\n\t\t\t\t\tVAR_18);\n\t\t\treturn VAR_19;\n\t\t}\n\n\t\tif ((VAR_6 == VAR_20 && VAR_3.prefixlen > VAR_21)\n\t\t    || (VAR_6 == VAR_22 && VAR_3.prefixlen > VAR_23))\n\t\t\treturn VAR_24;\n\n\t\t/* COMMENT_6 */\n\t\tmemcpy(&VAR_3.u.prefix, VAR_1 + VAR_12, VAR_4 - VAR_12);\n\n\t\t/* COMMENT_7 */\n\t\tif (VAR_6 == VAR_20 && VAR_7 == VAR_25) {\n\t\t\tif (IN_CLASSD(ntohl(VAR_3.u.prefix4.s_addr))) {\n\t\t\t\t/* COMMENT_8 */\n      \n                                                    \n                \n                                                  \n                      \n                                                  \n               \n        \n\t\t\t\tflog_err(\n\t\t\t\t\tVAR_15,\n\t\t\t\t\t\"%s: IPv4 labeled-unicast NLRI is multicast address %pI4, ignoring\",\n\t\t\t\t\tpeer->host, &VAR_3.u.prefix4);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* COMMENT_7 */\n\t\tif (VAR_6 == VAR_22 && VAR_7 == VAR_25) {\n\t\t\tif (IN6_IS_ADDR_LINKLOCAL(&VAR_3.u.prefix6)) {\n\t\t\t\tflog_err(\n\t\t\t\t\tVAR_15,\n\t\t\t\t\t\"%s: IPv6 labeled-unicast NLRI is link-local address %pI6, ignoring\",\n\t\t\t\t\tpeer->host, &VAR_3.u.prefix6);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (IN6_IS_ADDR_MULTICAST(&VAR_3.u.prefix6)) {\n\t\t\t\tflog_err(\n\t\t\t\t\tVAR_15,\n\t\t\t\t\t\"%s: IPv6 unicast NLRI is multicast address %pI6, ignoring\",\n\t\t\t\t\tpeer->host, &VAR_3.u.prefix6);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (attr) {\n\t\t\tbgp_update(peer, &VAR_3, VAR_9, attr, VAR_0->afi,\n\t\t\t\t   VAR_7, VAR_26, VAR_27,\n\t\t\t\t   NULL, &VAR_10, 1, 0, NULL);\n\t\t} else {\n\t\t\tbgp_withdraw(peer, &VAR_3, VAR_9, VAR_0->afi,\n\t\t\t\t     VAR_28, VAR_26,\n\t\t\t\t     VAR_27, NULL, &VAR_10, 1, NULL);\n\t\t}\n\t}\n\n\t/* COMMENT_17 */\n\tif (VAR_1 != VAR_2) {\n\t\tflog_err(\n\t\t\tVAR_15,\n\t\t\t\"%s [Error] Update packet error / L-U (%td data remaining after parsing)\",\n\t\t\tpeer->host, VAR_2 - VAR_1);\n\t\treturn VAR_29;\n\t}\n\n\treturn VAR_30;\n}",
  "func_graph_path_before": "FRRouting/frr/7404a914b0cafe046703c8381903a80d3def8f8b/bgp_label.c/vul/before/0.json",
  "func": "int bgp_nlri_parse_label(struct peer *peer, struct attr *attr,\n\t\t\t struct bgp_nlri *packet)\n{\n\tuint8_t *pnt;\n\tuint8_t *lim;\n\tstruct prefix p;\n\tint psize = 0;\n\tint prefixlen;\n\tafi_t afi;\n\tsafi_t safi;\n\tbool addpath_capable;\n\tuint32_t addpath_id;\n\tmpls_label_t label = MPLS_INVALID_LABEL;\n\tuint8_t llen;\n\n\tpnt = packet->nlri;\n\tlim = pnt + packet->length;\n\tafi = packet->afi;\n\tsafi = packet->safi;\n\taddpath_id = 0;\n\n\taddpath_capable = bgp_addpath_encode_rx(peer, afi, safi);\n\n\tfor (; pnt < lim; pnt += psize) {\n\t\t/* Clear prefix structure. */\n\t\tmemset(&p, 0, sizeof(p));\n\n\t\tif (addpath_capable) {\n\n\t\t\t/* When packet overflow occurs return immediately. */\n\t\t\tif (pnt + BGP_ADDPATH_ID_LEN > lim)\n\t\t\t\treturn BGP_NLRI_PARSE_ERROR_PACKET_OVERFLOW;\n\n\t\t\tmemcpy(&addpath_id, pnt, BGP_ADDPATH_ID_LEN);\n\t\t\taddpath_id = ntohl(addpath_id);\n\t\t\tpnt += BGP_ADDPATH_ID_LEN;\n\n\t\t\tif (pnt >= lim)\n\t\t\t\treturn BGP_NLRI_PARSE_ERROR_PACKET_OVERFLOW;\n\t\t}\n\n\t\t/* Fetch prefix length. */\n\t\tprefixlen = *pnt++;\n\t\tp.family = afi2family(packet->afi);\n\t\tpsize = PSIZE(prefixlen);\n\n\t\t/* sanity check against packet data */\n\t\tif ((pnt + psize) > lim) {\n\t\t\tflog_err(\n\t\t\t\tEC_BGP_UPDATE_RCV,\n\t\t\t\t\"%s [Error] Update packet error / L-U (prefix length %d exceeds packet size %u)\",\n\t\t\t\tpeer->host, prefixlen, (uint)(lim - pnt));\n\t\t\treturn BGP_NLRI_PARSE_ERROR_PACKET_OVERFLOW;\n\t\t}\n\n\t\t/* Fill in the labels */\n\t\tllen = bgp_nlri_get_labels(peer, pnt, psize, &label);\n\t\tif (llen == 0) {\n\t\t\tflog_err(\n\t\t\t\tEC_BGP_UPDATE_RCV,\n\t\t\t\t\"%s [Error] Update packet error (wrong label length 0)\",\n\t\t\t\tpeer->host);\n\t\t\tbgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\t\tBGP_NOTIFY_UPDATE_INVAL_NETWORK);\n\t\t\treturn BGP_NLRI_PARSE_ERROR_LABEL_LENGTH;\n\t\t}\n\t\tp.prefixlen = prefixlen - BSIZE(llen);\n\n\t\t/* There needs to be at least one label */\n\t\tif (prefixlen < 24) {\n\t\t\tflog_err(EC_BGP_UPDATE_RCV,\n\t\t\t\t \"%s [Error] Update packet error (wrong label length %d)\",\n\t\t\t\t peer->host, prefixlen);\n\t\t\tbgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\t\tBGP_NOTIFY_UPDATE_INVAL_NETWORK);\n\t\t\treturn BGP_NLRI_PARSE_ERROR_LABEL_LENGTH;\n\t\t}\n\n\t\tif ((afi == AFI_IP && p.prefixlen > IPV4_MAX_BITLEN)\n\t\t    || (afi == AFI_IP6 && p.prefixlen > IPV6_MAX_BITLEN))\n\t\t\treturn BGP_NLRI_PARSE_ERROR_PREFIX_LENGTH;\n\n\t\t/* Fetch prefix from NLRI packet */\n\t\tmemcpy(&p.u.prefix, pnt + llen, psize - llen);\n\n\t\t/* Check address. */\n\t\tif (afi == AFI_IP && safi == SAFI_LABELED_UNICAST) {\n\t\t\tif (IN_CLASSD(ntohl(p.u.prefix4.s_addr))) {\n\t\t\t\t/* From RFC4271 Section 6.3:\n\t\t\t\t *\n\t\t\t\t * If a prefix in the NLRI field is semantically\n\t\t\t\t * incorrect\n\t\t\t\t * (e.g., an unexpected multicast IP address),\n\t\t\t\t * an error SHOULD\n\t\t\t\t * be logged locally, and the prefix SHOULD be\n\t\t\t\t * ignored.\n\t\t\t\t  */\n\t\t\t\tflog_err(\n\t\t\t\t\tEC_BGP_UPDATE_RCV,\n\t\t\t\t\t\"%s: IPv4 labeled-unicast NLRI is multicast address %pI4, ignoring\",\n\t\t\t\t\tpeer->host, &p.u.prefix4);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* Check address. */\n\t\tif (afi == AFI_IP6 && safi == SAFI_LABELED_UNICAST) {\n\t\t\tif (IN6_IS_ADDR_LINKLOCAL(&p.u.prefix6)) {\n\t\t\t\tflog_err(\n\t\t\t\t\tEC_BGP_UPDATE_RCV,\n\t\t\t\t\t\"%s: IPv6 labeled-unicast NLRI is link-local address %pI6, ignoring\",\n\t\t\t\t\tpeer->host, &p.u.prefix6);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (IN6_IS_ADDR_MULTICAST(&p.u.prefix6)) {\n\t\t\t\tflog_err(\n\t\t\t\t\tEC_BGP_UPDATE_RCV,\n\t\t\t\t\t\"%s: IPv6 unicast NLRI is multicast address %pI6, ignoring\",\n\t\t\t\t\tpeer->host, &p.u.prefix6);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (attr) {\n\t\t\tbgp_update(peer, &p, addpath_id, attr, packet->afi,\n\t\t\t\t   safi, ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL,\n\t\t\t\t   NULL, &label, 1, 0, NULL);\n\t\t} else {\n\t\t\tbgp_withdraw(peer, &p, addpath_id, packet->afi,\n\t\t\t\t     SAFI_UNICAST, ZEBRA_ROUTE_BGP,\n\t\t\t\t     BGP_ROUTE_NORMAL, NULL, &label, 1, NULL);\n\t\t}\n\t}\n\n\t/* Packet length consistency check. */\n\tif (pnt != lim) {\n\t\tflog_err(\n\t\t\tEC_BGP_UPDATE_RCV,\n\t\t\t\"%s [Error] Update packet error / L-U (%td data remaining after parsing)\",\n\t\t\tpeer->host, lim - pnt);\n\t\treturn BGP_NLRI_PARSE_ERROR_PACKET_LENGTH;\n\t}\n\n\treturn BGP_NLRI_PARSE_OK;\n}",
  "abstract_func": "int bgp_nlri_parse_label(struct peer *peer, struct attr *attr,\n\t\t\t struct bgp_nlri *VAR_0)\n{\n\tuint8_t *VAR_1;\n\tuint8_t *VAR_2;\n\tstruct prefix VAR_3;\n\tint VAR_4 = 0;\n\tint VAR_5;\n\tafi_t VAR_6;\n\tsafi_t VAR_7;\n\tbool VAR_8;\n\tuint32_t VAR_9;\n\tmpls_label_t VAR_10 = VAR_11;\n\tuint8_t VAR_12;\n\n\tVAR_1 = VAR_0->nlri;\n\tVAR_2 = VAR_1 + VAR_0->length;\n\tVAR_6 = VAR_0->afi;\n\tVAR_7 = VAR_0->safi;\n\tVAR_9 = 0;\n\n\tVAR_8 = bgp_addpath_encode_rx(peer, VAR_6, VAR_7);\n\n\tfor (; VAR_1 < VAR_2; VAR_1 += VAR_4) {\n\t\t/* COMMENT_0 */\n\t\tmemset(&VAR_3, 0, sizeof(VAR_3));\n\n\t\tif (VAR_8) {\n\n\t\t\t/* COMMENT_1 */\n\t\t\tif (VAR_1 + VAR_13 > VAR_2)\n\t\t\t\treturn VAR_14;\n\n\t\t\tmemcpy(&VAR_9, VAR_1, VAR_13);\n\t\t\tVAR_9 = ntohl(VAR_9);\n\t\t\tVAR_1 += VAR_13;\n\n\t\t\tif (VAR_1 >= VAR_2)\n\t\t\t\treturn VAR_14;\n\t\t}\n\n\t\t/* COMMENT_2 */\n\t\tVAR_5 = *VAR_1++;\n\t\tVAR_3.family = afi2family(VAR_0->afi);\n\t\tVAR_4 = PSIZE(VAR_5);\n\n\t\t/* COMMENT_3 */\n\t\tif ((VAR_1 + VAR_4) > VAR_2) {\n\t\t\tflog_err(\n\t\t\t\tVAR_15,\n\t\t\t\t\"%s [Error] Update packet error / L-U (prefix length %d exceeds packet size %u)\",\n\t\t\t\tpeer->host, VAR_5, (VAR_16)(VAR_2 - VAR_1));\n\t\t\treturn VAR_14;\n\t\t}\n\n\t\t/* COMMENT_4 */\n\t\tVAR_12 = bgp_nlri_get_labels(peer, VAR_1, VAR_4, &VAR_10);\n\t\tif (VAR_12 == 0) {\n\t\t\tflog_err(\n\t\t\t\tVAR_15,\n\t\t\t\t\"%s [Error] Update packet error (wrong label length 0)\",\n\t\t\t\tpeer->host);\n\t\t\tbgp_notify_send(peer, VAR_17,\n\t\t\t\t\tVAR_18);\n\t\t\treturn VAR_19;\n\t\t}\n\t\tVAR_3.prefixlen = VAR_5 - BSIZE(VAR_12);\n\n\t\t/* COMMENT_5 */\n\t\tif (VAR_5 < 24) {\n\t\t\tflog_err(VAR_15,\n\t\t\t\t \"%s [Error] Update packet error (wrong label length %d)\",\n\t\t\t\t peer->host, VAR_5);\n\t\t\tbgp_notify_send(peer, VAR_17,\n\t\t\t\t\tVAR_18);\n\t\t\treturn VAR_19;\n\t\t}\n\n\t\tif ((VAR_6 == VAR_20 && VAR_3.prefixlen > VAR_21)\n\t\t    || (VAR_6 == VAR_22 && VAR_3.prefixlen > VAR_23))\n\t\t\treturn VAR_24;\n\n\t\t/* COMMENT_6 */\n\t\tmemcpy(&VAR_3.u.prefix, VAR_1 + VAR_12, VAR_4 - VAR_12);\n\n\t\t/* COMMENT_7 */\n\t\tif (VAR_6 == VAR_20 && VAR_7 == VAR_25) {\n\t\t\tif (IN_CLASSD(ntohl(VAR_3.u.prefix4.s_addr))) {\n\t\t\t\t/* COMMENT_8 */\n      \n                                                    \n                \n                                                  \n                      \n                                                  \n               \n        \n\t\t\t\tflog_err(\n\t\t\t\t\tVAR_15,\n\t\t\t\t\t\"%s: IPv4 labeled-unicast NLRI is multicast address %pI4, ignoring\",\n\t\t\t\t\tpeer->host, &VAR_3.u.prefix4);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* COMMENT_7 */\n\t\tif (VAR_6 == VAR_22 && VAR_7 == VAR_25) {\n\t\t\tif (IN6_IS_ADDR_LINKLOCAL(&VAR_3.u.prefix6)) {\n\t\t\t\tflog_err(\n\t\t\t\t\tVAR_15,\n\t\t\t\t\t\"%s: IPv6 labeled-unicast NLRI is link-local address %pI6, ignoring\",\n\t\t\t\t\tpeer->host, &VAR_3.u.prefix6);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (IN6_IS_ADDR_MULTICAST(&VAR_3.u.prefix6)) {\n\t\t\t\tflog_err(\n\t\t\t\t\tVAR_15,\n\t\t\t\t\t\"%s: IPv6 unicast NLRI is multicast address %pI6, ignoring\",\n\t\t\t\t\tpeer->host, &VAR_3.u.prefix6);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (attr) {\n\t\t\tbgp_update(peer, &VAR_3, VAR_9, attr, VAR_0->afi,\n\t\t\t\t   VAR_7, VAR_26, VAR_27,\n\t\t\t\t   NULL, &VAR_10, 1, 0, NULL);\n\t\t} else {\n\t\t\tbgp_withdraw(peer, &VAR_3, VAR_9, VAR_0->afi,\n\t\t\t\t     VAR_28, VAR_26,\n\t\t\t\t     VAR_27, NULL, &VAR_10, 1, NULL);\n\t\t}\n\t}\n\n\t/* COMMENT_17 */\n\tif (VAR_1 != VAR_2) {\n\t\tflog_err(\n\t\t\tVAR_15,\n\t\t\t\"%s [Error] Update packet error / L-U (%td data remaining after parsing)\",\n\t\t\tpeer->host, VAR_2 - VAR_1);\n\t\treturn VAR_29;\n\t}\n\n\treturn VAR_30;\n}",
  "func_graph_path": "FRRouting/frr/7404a914b0cafe046703c8381903a80d3def8f8b/bgp_label.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -34,6 +34,9 @@\n \t\t\tmemcpy(&addpath_id, pnt, BGP_ADDPATH_ID_LEN);\n \t\t\taddpath_id = ntohl(addpath_id);\n \t\t\tpnt += BGP_ADDPATH_ID_LEN;\n+\n+\t\t\tif (pnt >= lim)\n+\t\t\t\treturn BGP_NLRI_PARSE_ERROR_PACKET_OVERFLOW;\n \t\t}\n \n \t\t/* Fetch prefix length. */\n@@ -52,6 +55,15 @@\n \n \t\t/* Fill in the labels */\n \t\tllen = bgp_nlri_get_labels(peer, pnt, psize, &label);\n+\t\tif (llen == 0) {\n+\t\t\tflog_err(\n+\t\t\t\tEC_BGP_UPDATE_RCV,\n+\t\t\t\t\"%s [Error] Update packet error (wrong label length 0)\",\n+\t\t\t\tpeer->host);\n+\t\t\tbgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,\n+\t\t\t\t\tBGP_NOTIFY_UPDATE_INVAL_NETWORK);\n+\t\t\treturn BGP_NLRI_PARSE_ERROR_LABEL_LENGTH;\n+\t\t}\n \t\tp.prefixlen = prefixlen - BSIZE(llen);\n \n \t\t/* There needs to be at least one label */",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "",
      "\t\t\tif (pnt >= lim)",
      "\t\t\t\treturn BGP_NLRI_PARSE_ERROR_PACKET_OVERFLOW;",
      "\t\tif (llen == 0) {",
      "\t\t\tflog_err(",
      "\t\t\t\tEC_BGP_UPDATE_RCV,",
      "\t\t\t\t\"%s [Error] Update packet error (wrong label length 0)\",",
      "\t\t\t\tpeer->host);",
      "\t\t\tbgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,",
      "\t\t\t\t\tBGP_NOTIFY_UPDATE_INVAL_NETWORK);",
      "\t\t\treturn BGP_NLRI_PARSE_ERROR_LABEL_LENGTH;",
      "\t\t}"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/FRRouting/frr/pull/12951",
  "description": {
    "pr_info": {
      "title": "bgpd: Fix use beyond end of stream of labeled unicast parsing",
      "number": 12951
    },
    "comment": [
      "Fixes a couple crashes associated with attempting to read beyond the end of the stream.\r\n\r\nReported-by: Iggy Frankovic <iggyfran@amazon.com>",
      "@mergifyio backport stable/8.5 stable/8.4 stable/8.3 stable/8.2 stable/8.1 stable/8.0",
      "> backport stable/8.5 stable/8.4 stable/8.3 stable/8.2 stable/8.1 stable/8.0\n\n#### ❌ No backport have been created\n\n<details>\n\n* Backport to branch `stable/8.5` failed\n\nGitHub error: ```Branch not found```\n* Backport to branch `stable/8.4` in progress\n* Backport to branch `stable/8.3` in progress\n* Backport to branch `stable/8.2` in progress\n* Backport to branch `stable/8.1` in progress\n* Backport to branch `stable/8.0` in progress\n\n</details>\n\n\n<!---\nDO NOT EDIT\n-*- Mergify Payload -*-\n{\"command\": \"backport stable/8.5 stable/8.4 stable/8.3 stable/8.2 stable/8.1 stable/8.0\", \"conclusion\": \"failure\"}\n-*- Mergify Payload End -*-\n-->",
      "# Continuous Integration Result: SUCCESSFUL\n\nCongratulations, this patch passed basic tests\n\nTested-by: NetDEF / OpenSourceRouting.org CI System\n\nCI System Testrun URL: https://ci1.netdef.org/browse/FRR-PULLREQ2-10043/\n\nThis is a comment from an automated CI system.\nFor questions and feedback in regards to this CI system, please feel free to email\nMartin Winter - mwinter (at) opensourcerouting.org.\n\n\n",
      "@Mergifyio backport dev/8.5 stable/8.4 stable/8.3 stable/8.2 stable/8.1 stable/8.0",
      "> backport dev/8.5 stable/8.4 stable/8.3 stable/8.2 stable/8.1 stable/8.0\n\n#### ✅ Backports have been created\n\n<details>\n\n* [#12956 bgpd: Fix use beyond end of stream of labeled unicast parsing (backport #12951)](https://github.com/FRRouting/frr/pull/12956) has been created for branch `dev/8.5`\n* Backport to branch `stable/8.4` in progress\n* Backport to branch `stable/8.3` in progress\n* Backport to branch `stable/8.2` in progress\n* Backport to branch `stable/8.1` in progress\n* Backport to branch `stable/8.0` in progress\n\n</details>\n\n\n<!---\nDO NOT EDIT\n-*- Mergify Payload -*-\n{\"command\": \"backport dev/8.5 stable/8.4 stable/8.3 stable/8.2 stable/8.1 stable/8.0\", \"conclusion\": \"success\"}\n-*- Mergify Payload End -*-\n-->",
      "@Mergifyio backport stable/8.4",
      "> backport stable/8.4\n\n#### ✅ Backports have been created\n\n<details>\n\n* [#15926 bgpd: Fix use beyond end of stream of labeled unicast parsing (backport #12951)](https://github.com/FRRouting/frr/pull/15926) has been created for branch `stable/8.4`\n\n</details>\n\n\n<!---\nDO NOT EDIT\n-*- Mergify Payload -*-\n{\"command\": \"backport stable/8.4\", \"conclusion\": \"success\", \"action_is_running\": true}\n-*- Mergify Payload End -*-\n-->"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "The patch addresses a buffer overflow issue in parsing code, which is a common security concern. The changes prevent accessing memory beyond the data stream, which can lead to crashes and potential security risks.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9  \n\nThe modifications add checks to prevent reading beyond the buffer limits, which are critical for avoiding crashes and potential exploitation."
}