{
  "cve_id": "CVE-2019-15784",
  "cwe_ids": [
    "CWE-129"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "Haivision/srt",
  "commit_msg": "[core] Fixed sender list to reallocate on insert\nif required",
  "commit_hash": "47e589072c44350b0305c05066c224d1cbda992d",
  "git_url": "https://github.com/Haivision/srt/commit/47e589072c44350b0305c05066c224d1cbda992d",
  "file_path": "srtcore/queue.cpp",
  "func_name": "CSndUList::insert_",
  "func_before": "void CSndUList::insert_(int64_t ts, const CUDT* u)\n{\n   CSNode* n = u->m_pSNode;\n\n   // do not insert repeated node\n   if (n->m_iHeapLoc >= 0)\n      return;\n\n   m_iLastEntry ++;\n   m_pHeap[m_iLastEntry] = n;\n   n->m_llTimeStamp_tk = ts;\n\n   int q = m_iLastEntry;\n   int p = q;\n   while (p != 0)\n   {\n      p = (q - 1) >> 1;\n      if (m_pHeap[p]->m_llTimeStamp_tk > m_pHeap[q]->m_llTimeStamp_tk)\n      {\n         CSNode* t = m_pHeap[p];\n         m_pHeap[p] = m_pHeap[q];\n         m_pHeap[q] = t;\n         t->m_iHeapLoc = q;\n         q = p;\n      }\n      else\n         break;\n   }\n\n   n->m_iHeapLoc = q;\n\n   // an earlier event has been inserted, wake up sending worker\n   if (n->m_iHeapLoc == 0)\n      m_pTimer->interrupt();\n\n   // first entry, activate the sending queue\n   if (0 == m_iLastEntry)\n   {\n       pthread_mutex_lock(m_pWindowLock);\n       pthread_cond_signal(m_pWindowCond);\n       pthread_mutex_unlock(m_pWindowLock);\n   }\n}",
  "abstract_func_before": "void CSndUList::insert_(int64_t VAR_0, const CUDT* VAR_1)\n{\n   CSNode* VAR_2 = VAR_1->m_pSNode;\n\n   /* COMMENT_0 */\n   if (VAR_2->m_iHeapLoc >= 0)\n      return;\n\n   VAR_3 ++;\n   VAR_4[VAR_3] = VAR_2;\n   VAR_2->m_llTimeStamp_tk = VAR_0;\n\n   int VAR_5 = VAR_3;\n   int VAR_6 = VAR_5;\n   while (VAR_6 != 0)\n   {\n      VAR_6 = (VAR_5 - 1) >> 1;\n      if (VAR_4[VAR_6]->m_llTimeStamp_tk > VAR_4[VAR_5]->m_llTimeStamp_tk)\n      {\n         CSNode* VAR_7 = VAR_4[VAR_6];\n         VAR_4[VAR_6] = VAR_4[VAR_5];\n         VAR_4[VAR_5] = VAR_7;\n         VAR_7->m_iHeapLoc = VAR_5;\n         VAR_5 = VAR_6;\n      }\n      else\n         break;\n   }\n\n   VAR_2->m_iHeapLoc = VAR_5;\n\n   /* COMMENT_1 */\n   if (VAR_2->m_iHeapLoc == 0)\n      VAR_8->interrupt();\n\n   /* COMMENT_2 */\n   if (0 == VAR_3)\n   {\n       pthread_mutex_lock(VAR_9);\n       pthread_cond_signal(VAR_10);\n       pthread_mutex_unlock(VAR_9);\n   }\n}",
  "func_graph_path_before": "Haivision/srt/47e589072c44350b0305c05066c224d1cbda992d/queue.cpp/vul/before/0.json",
  "func": "void CSndUList::insert_(int64_t ts, const CUDT* u)\n{\n    // increase the heap array size if necessary\n    if (m_iLastEntry == m_iArrayLength - 1)\n        realloc_();\n\n    insert_norealloc(ts, u);\n}",
  "abstract_func": "void CSndUList::insert_(int64_t VAR_0, const CUDT* VAR_1)\n{\n    /* COMMENT_0 */\n    if (VAR_2 == VAR_3 - 1)\n        realloc_();\n\n    insert_norealloc(VAR_0, VAR_1);\n}",
  "func_graph_path": "Haivision/srt/47e589072c44350b0305c05066c224d1cbda992d/queue.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,43 +1,8 @@\n void CSndUList::insert_(int64_t ts, const CUDT* u)\n {\n-   CSNode* n = u->m_pSNode;\n+    // increase the heap array size if necessary\n+    if (m_iLastEntry == m_iArrayLength - 1)\n+        realloc_();\n \n-   // do not insert repeated node\n-   if (n->m_iHeapLoc >= 0)\n-      return;\n-\n-   m_iLastEntry ++;\n-   m_pHeap[m_iLastEntry] = n;\n-   n->m_llTimeStamp_tk = ts;\n-\n-   int q = m_iLastEntry;\n-   int p = q;\n-   while (p != 0)\n-   {\n-      p = (q - 1) >> 1;\n-      if (m_pHeap[p]->m_llTimeStamp_tk > m_pHeap[q]->m_llTimeStamp_tk)\n-      {\n-         CSNode* t = m_pHeap[p];\n-         m_pHeap[p] = m_pHeap[q];\n-         m_pHeap[q] = t;\n-         t->m_iHeapLoc = q;\n-         q = p;\n-      }\n-      else\n-         break;\n-   }\n-\n-   n->m_iHeapLoc = q;\n-\n-   // an earlier event has been inserted, wake up sending worker\n-   if (n->m_iHeapLoc == 0)\n-      m_pTimer->interrupt();\n-\n-   // first entry, activate the sending queue\n-   if (0 == m_iLastEntry)\n-   {\n-       pthread_mutex_lock(m_pWindowLock);\n-       pthread_cond_signal(m_pWindowCond);\n-       pthread_mutex_unlock(m_pWindowLock);\n-   }\n+    insert_norealloc(ts, u);\n }",
  "diff_line_info": {
    "deleted_lines": [
      "   CSNode* n = u->m_pSNode;",
      "   // do not insert repeated node",
      "   if (n->m_iHeapLoc >= 0)",
      "      return;",
      "",
      "   m_iLastEntry ++;",
      "   m_pHeap[m_iLastEntry] = n;",
      "   n->m_llTimeStamp_tk = ts;",
      "",
      "   int q = m_iLastEntry;",
      "   int p = q;",
      "   while (p != 0)",
      "   {",
      "      p = (q - 1) >> 1;",
      "      if (m_pHeap[p]->m_llTimeStamp_tk > m_pHeap[q]->m_llTimeStamp_tk)",
      "      {",
      "         CSNode* t = m_pHeap[p];",
      "         m_pHeap[p] = m_pHeap[q];",
      "         m_pHeap[q] = t;",
      "         t->m_iHeapLoc = q;",
      "         q = p;",
      "      }",
      "      else",
      "         break;",
      "   }",
      "",
      "   n->m_iHeapLoc = q;",
      "",
      "   // an earlier event has been inserted, wake up sending worker",
      "   if (n->m_iHeapLoc == 0)",
      "      m_pTimer->interrupt();",
      "",
      "   // first entry, activate the sending queue",
      "   if (0 == m_iLastEntry)",
      "   {",
      "       pthread_mutex_lock(m_pWindowLock);",
      "       pthread_cond_signal(m_pWindowCond);",
      "       pthread_mutex_unlock(m_pWindowLock);",
      "   }"
    ],
    "added_lines": [
      "    // increase the heap array size if necessary",
      "    if (m_iLastEntry == m_iArrayLength - 1)",
      "        realloc_();",
      "    insert_norealloc(ts, u);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/Haivision/srt/pull/811",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/Haivision/srt/pull/811: 403 Client Error: Forbidden for url: https://api.github.com/repos/Haivision/srt/pulls/811",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.92,
  "Bug Filter Response": "The patch addresses a buffer overflow risk by dynamically resizing the list when it's full, thus preventing out-of-border operations. This is a security fix, even without an explicit CVE mention.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.92\n\nThe code changes directly address an overflow issue by reallocating memory when needed, which is a common security fix pattern."
}