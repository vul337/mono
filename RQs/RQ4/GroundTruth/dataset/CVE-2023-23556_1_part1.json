{
  "cve_id": "CVE-2023-23556",
  "cwe_ids": [
    "CWE-416",
    "CWE-787"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "facebook/hermes",
  "commit_msg": "Re-sync with internal repository (#908)\n\nFixes for CVE-2023-23556, and CVE-2023-24833.\r\n\r\nCo-authored-by: Facebook Community Bot <6422482+facebook-github-bot@users.noreply.github.com>",
  "commit_hash": "a6dcafe6ded8e61658b40f5699878cd19a481f80",
  "git_url": "https://github.com/facebook/hermes/commit/a6dcafe6ded8e61658b40f5699878cd19a481f80",
  "file_path": "lib/VM/Operations.cpp",
  "func_name": "addOp_RJS",
  "func_before": "CallResult<HermesValue>\naddOp_RJS(Runtime &runtime, Handle<> xHandle, Handle<> yHandle) {\n  auto resX = toPrimitive_RJS(runtime, xHandle, PreferredType::NONE);\n  if (resX == ExecutionStatus::EXCEPTION) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto xPrim = runtime.makeHandle(resX.getValue());\n\n  auto resY = toPrimitive_RJS(runtime, yHandle, PreferredType::NONE);\n  if (resY == ExecutionStatus::EXCEPTION) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto yPrim = runtime.makeHandle(resY.getValue());\n\n  // If one of the values is a string, concatenate as strings.\n  if (xPrim->isString() || yPrim->isString()) {\n    auto resX = toString_RJS(runtime, xPrim);\n    if (resX == ExecutionStatus::EXCEPTION) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    auto xStr = runtime.makeHandle(std::move(*resX));\n\n    auto resY = toString_RJS(runtime, yPrim);\n    if (resY == ExecutionStatus::EXCEPTION) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    auto yStr = runtime.makeHandle(std::move(*resY));\n\n    return StringPrimitive::concat(runtime, xStr, yStr);\n  }\n\n  // xPrim and yPrim are primitives; hence, they are already bigints, or they\n  // will never be bigints.\n  if (LLVM_LIKELY(!xPrim->isBigInt())) {\n    // xPrim is not a bigint; thus this is Number + Number.\n    auto res = toNumber_RJS(runtime, xPrim);\n    if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    const double xNum = res->getNumber();\n    // N.B.: toNumber(yPrim) will raise an TypeError if yPrim is bigint, which\n    // is the correct exception to be raised when trying to perform\n    // Number + BigInt. This avoids the need to check if yPrim is a bigint.\n    res = toNumber_RJS(runtime, yPrim);\n    if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    const double yNum = res->getNumber();\n    return HermesValue::encodeDoubleValue(xNum + yNum);\n  }\n\n  // yPrim is a primitive; therefore it is already a BigInt, or it will never be\n  // one.\n  if (!yPrim->isBigInt()) {\n    return runtime.raiseTypeErrorForValue(\n        \"Cannot convert \", yHandle, \" to BigInt\");\n  }\n\n  return BigIntPrimitive::add(\n      runtime,\n      runtime.makeHandle(resX->getBigInt()),\n      runtime.makeHandle(resY->getBigInt()));\n}",
  "abstract_func_before": "CallResult<HermesValue>\naddOp_RJS(Runtime &VAR_0, Handle<> VAR_1, Handle<> VAR_2) {\n  auto VAR_3 = toPrimitive_RJS(VAR_0, VAR_1, PreferredType::NONE);\n  if (VAR_3 == ExecutionStatus::EXCEPTION) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto VAR_4 = VAR_0.makeHandle(VAR_3.getValue());\n\n  auto VAR_5 = toPrimitive_RJS(VAR_0, VAR_2, PreferredType::NONE);\n  if (VAR_5 == ExecutionStatus::EXCEPTION) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto VAR_6 = VAR_0.makeHandle(VAR_5.getValue());\n\n  /* COMMENT_0 */\n  if (VAR_4->isString() || VAR_6->isString()) {\n    auto VAR_3 = toString_RJS(VAR_0, VAR_4);\n    if (VAR_3 == ExecutionStatus::EXCEPTION) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    auto VAR_7 = VAR_0.makeHandle(std::move(*VAR_3));\n\n    auto VAR_5 = toString_RJS(VAR_0, VAR_6);\n    if (VAR_5 == ExecutionStatus::EXCEPTION) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    auto VAR_8 = VAR_0.makeHandle(std::move(*VAR_5));\n\n    return StringPrimitive::concat(VAR_0, VAR_7, VAR_8);\n  }\n\n  /* COMMENT_1 */\n  /* COMMENT_2 */\n  if (LLVM_LIKELY(!VAR_4->isBigInt())) {\n    /* COMMENT_3 */\n    auto VAR_9 = toNumber_RJS(VAR_0, VAR_4);\n    if (LLVM_UNLIKELY(VAR_9 == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    const double VAR_10 = VAR_9->getNumber();\n    /* COMMENT_4 */\n    /* COMMENT_5 */\n    /* COMMENT_6 */\n    VAR_9 = toNumber_RJS(VAR_0, VAR_6);\n    if (LLVM_UNLIKELY(VAR_9 == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    const double VAR_11 = VAR_9->getNumber();\n    return HermesValue::encodeDoubleValue(VAR_10 + VAR_11);\n  }\n\n  /* COMMENT_7 */\n  /* COMMENT_8 */\n  if (!VAR_6->isBigInt()) {\n    return VAR_0.raiseTypeErrorForValue(\n        \"Cannot convert \", VAR_2, \" to BigInt\");\n  }\n\n  return BigIntPrimitive::add(\n      VAR_0,\n      VAR_0.makeHandle(VAR_3->getBigInt()),\n      VAR_0.makeHandle(VAR_5->getBigInt()));\n}",
  "func_graph_path_before": "facebook/hermes/a6dcafe6ded8e61658b40f5699878cd19a481f80/Operations.cpp/vul/before/0.json",
  "func": "CallResult<HermesValue>\naddOp_RJS(Runtime &runtime, Handle<> xHandle, Handle<> yHandle) {\n  auto resX = toPrimitive_RJS(runtime, xHandle, PreferredType::NONE);\n  if (resX == ExecutionStatus::EXCEPTION) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto xPrim = runtime.makeHandle(resX.getValue());\n\n  auto resY = toPrimitive_RJS(runtime, yHandle, PreferredType::NONE);\n  if (resY == ExecutionStatus::EXCEPTION) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto yPrim = runtime.makeHandle(resY.getValue());\n\n  // If one of the values is a string, concatenate as strings.\n  if (xPrim->isString() || yPrim->isString()) {\n    auto resX = toString_RJS(runtime, xPrim);\n    if (resX == ExecutionStatus::EXCEPTION) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    auto xStr = runtime.makeHandle(std::move(*resX));\n\n    auto resY = toString_RJS(runtime, yPrim);\n    if (resY == ExecutionStatus::EXCEPTION) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    auto yStr = runtime.makeHandle(std::move(*resY));\n\n    return StringPrimitive::concat(runtime, xStr, yStr);\n  }\n\n  // xPrim and yPrim are primitives; hence, they are already bigints, or they\n  // will never be bigints.\n  if (LLVM_LIKELY(!xPrim->isBigInt())) {\n    // xPrim is not a bigint; thus this is Number + Number.\n    auto res = toNumber_RJS(runtime, xPrim);\n    if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    const double xNum = res->getNumber();\n    // N.B.: toNumber(yPrim) will raise an TypeError if yPrim is bigint, which\n    // is the correct exception to be raised when trying to perform\n    // Number + BigInt. This avoids the need to check if yPrim is a bigint.\n    res = toNumber_RJS(runtime, yPrim);\n    if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    const double yNum = res->getNumber();\n    return HermesValue::encodeDoubleValue(xNum + yNum);\n  }\n\n  // yPrim is a primitive; therefore it is already a BigInt, or it will never be\n  // one.\n  if (!yPrim->isBigInt()) {\n    return runtime.raiseTypeErrorForValue(\n        \"Cannot convert \", yHandle, \" to BigInt\");\n  }\n\n  return BigIntPrimitive::add(\n      runtime,\n      runtime.makeHandle(xPrim->getBigInt()),\n      runtime.makeHandle(yPrim->getBigInt()));\n}",
  "abstract_func": "CallResult<HermesValue>\naddOp_RJS(Runtime &VAR_0, Handle<> VAR_1, Handle<> VAR_2) {\n  auto VAR_3 = toPrimitive_RJS(VAR_0, VAR_1, PreferredType::NONE);\n  if (VAR_3 == ExecutionStatus::EXCEPTION) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto VAR_4 = VAR_0.makeHandle(VAR_3.getValue());\n\n  auto VAR_5 = toPrimitive_RJS(VAR_0, VAR_2, PreferredType::NONE);\n  if (VAR_5 == ExecutionStatus::EXCEPTION) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto VAR_6 = VAR_0.makeHandle(VAR_5.getValue());\n\n  /* COMMENT_0 */\n  if (VAR_4->isString() || VAR_6->isString()) {\n    auto VAR_3 = toString_RJS(VAR_0, VAR_4);\n    if (VAR_3 == ExecutionStatus::EXCEPTION) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    auto VAR_7 = VAR_0.makeHandle(std::move(*VAR_3));\n\n    auto VAR_5 = toString_RJS(VAR_0, VAR_6);\n    if (VAR_5 == ExecutionStatus::EXCEPTION) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    auto VAR_8 = VAR_0.makeHandle(std::move(*VAR_5));\n\n    return StringPrimitive::concat(VAR_0, VAR_7, VAR_8);\n  }\n\n  /* COMMENT_1 */\n  /* COMMENT_2 */\n  if (LLVM_LIKELY(!VAR_4->isBigInt())) {\n    /* COMMENT_3 */\n    auto VAR_9 = toNumber_RJS(VAR_0, VAR_4);\n    if (LLVM_UNLIKELY(VAR_9 == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    const double VAR_10 = VAR_9->getNumber();\n    /* COMMENT_4 */\n    /* COMMENT_5 */\n    /* COMMENT_6 */\n    VAR_9 = toNumber_RJS(VAR_0, VAR_6);\n    if (LLVM_UNLIKELY(VAR_9 == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    const double VAR_11 = VAR_9->getNumber();\n    return HermesValue::encodeDoubleValue(VAR_10 + VAR_11);\n  }\n\n  /* COMMENT_7 */\n  /* COMMENT_8 */\n  if (!VAR_6->isBigInt()) {\n    return VAR_0.raiseTypeErrorForValue(\n        \"Cannot convert \", VAR_2, \" to BigInt\");\n  }\n\n  return BigIntPrimitive::add(\n      VAR_0,\n      VAR_0.makeHandle(VAR_4->getBigInt()),\n      VAR_0.makeHandle(VAR_6->getBigInt()));\n}",
  "func_graph_path": "facebook/hermes/a6dcafe6ded8e61658b40f5699878cd19a481f80/Operations.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -58,6 +58,6 @@\n \n   return BigIntPrimitive::add(\n       runtime,\n-      runtime.makeHandle(resX->getBigInt()),\n-      runtime.makeHandle(resY->getBigInt()));\n+      runtime.makeHandle(xPrim->getBigInt()),\n+      runtime.makeHandle(yPrim->getBigInt()));\n }",
  "diff_line_info": {
    "deleted_lines": [
      "      runtime.makeHandle(resX->getBigInt()),",
      "      runtime.makeHandle(resY->getBigInt()));"
    ],
    "added_lines": [
      "      runtime.makeHandle(xPrim->getBigInt()),",
      "      runtime.makeHandle(yPrim->getBigInt()));"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/facebook/hermes/pull/908",
  "description": {
    "pr_info": {
      "title": "Re-sync with internal repository",
      "number": 908
    },
    "comment": [
      "The internal and external repositories are out of sync. This attempts to brings them back in sync by patching the GitHub repository. Please carefully review this patch. You must disable ShipIt for your project in order to merge this pull request. DO NOT IMPORT this pull request. Instead, merge it directly on GitHub using the MERGE BUTTON. Re-enable ShipIt after merging."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9  \n\nThe commit message explicitly references fixing specific CVEs, and the code changes involve modifications to critical functions, indicating a security patch. Although the description mentions repository sync, the presence of CVEs strongly suggests a security fix."
}