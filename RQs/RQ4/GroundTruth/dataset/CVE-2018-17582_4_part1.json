{
  "cve_id": "CVE-2018-17582",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "appneta/tcpreplay",
  "commit_msg": "Bug #484 CVE-2018-17582 Check for corrupt PCAP files\n\n* Check for packets that are larger than 262144 bytes\n* Check for capture lengths that are greater than packet length\n\nExample of a corrupt PCAP file ...\n\nsudo src/tcpreplay -i ens33 --unique-ip -t --loop 4 get_next_paket_01\nsafe_pcap_next ERROR: Invalid packet length in send_packets.c:get_next_packet() line 1054: 8388670 is greater than maximum 262144",
  "commit_hash": "68f67b1a3a4d319543692afb5bd5b191ec984287",
  "git_url": "https://github.com/appneta/tcpreplay/commit/68f67b1a3a4d319543692afb5bd5b191ec984287",
  "file_path": "src/tcprewrite.c",
  "func_name": "rewrite_packets",
  "func_before": "int\nrewrite_packets(tcpedit_t *tcpedit, pcap_t *pin, pcap_dumper_t *pout)\n{\n    tcpr_dir_t cache_result = TCPR_DIR_C2S;     /* default to primary */\n    struct pcap_pkthdr pkthdr, *pkthdr_ptr;     /* packet header */\n    const u_char *pktconst = NULL;              /* packet from libpcap */\n    u_char **pktdata = NULL;\n    static u_char *pktdata_buff;\n    static char *frag = NULL;\n    COUNTER packetnum = 0;\n    int rcode;\n#ifdef ENABLE_FRAGROUTE\n    int frag_len, proto;\n#endif\n\n    pkthdr_ptr = &pkthdr;\n\n    if (pktdata_buff == NULL)\n        pktdata_buff = (u_char *)safe_malloc(MAXPACKET);\n\n    pktdata = &pktdata_buff;\n\n    if (frag == NULL)\n        frag = (char *)safe_malloc(MAXPACKET);\n\n    /* MAIN LOOP \n     * Keep sending while we have packets or until\n     * we've sent enough packets\n     */\n    while ((pktconst = pcap_next(pin, pkthdr_ptr)) != NULL) {\n        packetnum++;\n        dbgx(2, \"packet \" COUNTER_SPEC \" caplen %d\", packetnum, pkthdr.caplen);\n\n        if (pkthdr.caplen > MAXPACKET)\n            errx(-1, \"Frame too big, caplen %d exceeds %d\", pkthdr.caplen, MAXPACKET);\n        /* \n         * copy over the packet so we can pad it out if necessary and\n         * because pcap_next() returns a const ptr\n         */\n        memcpy(*pktdata, pktconst, pkthdr.caplen);\n\n#ifdef ENABLE_VERBOSE\n        if (options.verbose)\n            tcpdump_print(&tcpdump, pkthdr_ptr, *pktdata);\n#endif\n\n        /* Dual nic processing? */\n        if (options.cachedata != NULL) {\n            cache_result = check_cache(options.cachedata, packetnum);\n        }\n\n        /* sometimes we should not send the packet, in such cases\n         * no point in editing this packet at all, just write it to the\n         * output file (note, we can't just remove it, or the tcpprep cache\n         * file will loose it's indexing\n         */\n\n        if (cache_result == TCPR_DIR_NOSEND)\n            goto WRITE_PACKET; /* still need to write it so cache stays in sync */\n\n        if ((rcode = tcpedit_packet(tcpedit, &pkthdr_ptr, pktdata, cache_result)) == TCPEDIT_ERROR) {\n            return -1;\n        } else if ((rcode == TCPEDIT_SOFT_ERROR) && HAVE_OPT(SKIP_SOFT_ERRORS)) {\n            /* don't write packet */\n            dbgx(1, \"Packet \" COUNTER_SPEC \" is suppressed from being written due to soft errors\", packetnum);\n            continue;\n        }\n\n\nWRITE_PACKET:\n#ifdef ENABLE_FRAGROUTE\n        if (options.frag_ctx == NULL) {\n            /* write the packet when there's no fragrouting to be done */\n            pcap_dump((u_char *)pout, pkthdr_ptr, *pktdata);\n        } else {\n            /* get the L3 protocol of the packet */\n            proto = tcpedit_l3proto(tcpedit, AFTER_PROCESS, *pktdata, pkthdr_ptr->caplen);\n\n            /* packet is IPv4/IPv6 AND needs to be fragmented */\n            if ((proto ==  ETHERTYPE_IP || proto == ETHERTYPE_IP6) &&\n                    ((options.fragroute_dir == FRAGROUTE_DIR_BOTH) ||\n                    (cache_result == TCPR_DIR_C2S && options.fragroute_dir == FRAGROUTE_DIR_C2S) ||\n                    (cache_result == TCPR_DIR_S2C && options.fragroute_dir == FRAGROUTE_DIR_S2C))) {\n#ifdef DEBUG\n                int i = 0;\n#endif\n                if (fragroute_process(options.frag_ctx, *pktdata, pkthdr_ptr->caplen) < 0)\n                    errx(-1, \"Error processing packet via fragroute: %s\", options.frag_ctx->errbuf);\n\n                while ((frag_len = fragroute_getfragment(options.frag_ctx, &frag)) > 0) {\n                    /* frags get the same timestamp as the original packet */\n                    dbgx(1, \"processing packet \" COUNTER_SPEC \" frag: %u (%d)\", packetnum, i++, frag_len);\n                    pkthdr_ptr->caplen = frag_len;\n                    pkthdr_ptr->len = frag_len;\n                    pcap_dump((u_char *)pout, pkthdr_ptr, (u_char *)frag);\n                }\n            } else {\n                /* write the packet without fragroute */\n                pcap_dump((u_char *)pout, pkthdr_ptr, *pktdata);\n            }\n        }\n#else\n    /* write the packet when there's no fragrouting to be done */\n    pcap_dump((u_char *)pout, pkthdr_ptr, *pktdata);\n\n#endif\n    } /* while() */\n    return 0;\n}",
  "abstract_func_before": "int\nrewrite_packets(tcpedit_t *VAR_0, pcap_t *VAR_1, pcap_dumper_t *VAR_2)\n{\n    tcpr_dir_t VAR_3 = VAR_4;     /* COMMENT_0 */\n    struct pcap_pkthdr VAR_5, *VAR_6;     /* COMMENT_1 */\n    const u_char *VAR_7 = NULL;              /* COMMENT_2 */\n    u_char **VAR_8 = NULL;\n    static u_char *VAR_9;\n    static char *VAR_10 = NULL;\n    COUNTER VAR_11 = 0;\n    int VAR_12;\n#ifdef VAR_13\n    int VAR_14, VAR_15;\n#endif\n\n    VAR_6 = &VAR_5;\n\n    if (VAR_9 == NULL)\n        VAR_9 = (u_char *)safe_malloc(VAR_16);\n\n    VAR_8 = &VAR_9;\n\n    if (VAR_10 == NULL)\n        VAR_10 = (char *)safe_malloc(VAR_16);\n\n    /* COMMENT_3 */\n                                                  \n                                \n       \n    while ((VAR_7 = pcap_next(VAR_1, VAR_6)) != NULL) {\n        VAR_11++;\n        dbgx(2, \"packet \" VAR_17 \" caplen %d\", VAR_11, VAR_5.caplen);\n\n        if (VAR_5.caplen > VAR_16)\n            errx(-1, \"Frame too big, caplen %d exceeds %d\", VAR_5.caplen, VAR_16);\n        /* COMMENT_7 */\n                                                                     \n                                                  \n           \n        memcpy(*VAR_8, VAR_7, VAR_5.caplen);\n\n#ifdef VAR_18\n        if (VAR_19.verbose)\n            tcpdump_print(&VAR_20, VAR_6, *VAR_8);\n#endif\n\n        /* COMMENT_11 */\n        if (VAR_19.cachedata != NULL) {\n            VAR_3 = check_cache(VAR_19.cachedata, VAR_11);\n        }\n\n        /* COMMENT_12 */\n                                                                       \n                                                                           \n                                        \n           \n\n        if (VAR_3 == VAR_21)\n            goto WRITE_PACKET; /* COMMENT_17 */\n\n        if ((VAR_12 = tcpedit_packet(VAR_0, &VAR_6, VAR_8, VAR_3)) == VAR_22) {\n            return -1;\n        } else if ((VAR_12 == VAR_23) && HAVE_OPT(VAR_24)) {\n            /* COMMENT_18 */\n            dbgx(1, \"Packet \" VAR_17 \" is suppressed from being written due to soft errors\", VAR_11);\n            continue;\n        }\n\n\nWRITE_PACKET:\n#ifdef VAR_13\n        if (VAR_19.frag_ctx == NULL) {\n            /* COMMENT_19 */\n            pcap_dump((u_char *)VAR_2, VAR_6, *VAR_8);\n        } else {\n            /* COMMENT_20 */\n            VAR_15 = tcpedit_l3proto(VAR_0, VAR_25, *VAR_8, VAR_6->caplen);\n\n            /* COMMENT_21 */\n            if ((VAR_15 ==  VAR_26 || VAR_15 == VAR_27) &&\n                    ((VAR_19.fragroute_dir == VAR_28) ||\n                    (VAR_3 == VAR_4 && VAR_19.fragroute_dir == VAR_29) ||\n                    (VAR_3 == VAR_30 && VAR_19.fragroute_dir == VAR_31))) {\n#ifdef VAR_32\n                int VAR_33 = 0;\n#endif\n                if (fragroute_process(VAR_19.frag_ctx, *VAR_8, VAR_6->caplen) < 0)\n                    errx(-1, \"Error processing packet via fragroute: %s\", VAR_19.frag_ctx->errbuf);\n\n                while ((VAR_14 = fragroute_getfragment(VAR_19.frag_ctx, &VAR_10)) > 0) {\n                    /* COMMENT_22 */\n                    dbgx(1, \"processing packet \" VAR_17 \" frag: %u (%d)\", VAR_11, VAR_33++, VAR_14);\n                    VAR_6->caplen = VAR_14;\n                    VAR_6->len = VAR_14;\n                    pcap_dump((u_char *)VAR_2, VAR_6, (u_char *)VAR_10);\n                }\n            } else {\n                /* COMMENT_23 */\n                pcap_dump((u_char *)VAR_2, VAR_6, *VAR_8);\n            }\n        }\n#else\n    /* COMMENT_19 */\n    pcap_dump((u_char *)VAR_2, VAR_6, *VAR_8);\n\n#endif\n    } /* COMMENT_24 */\n    return 0;\n}",
  "func_graph_path_before": "appneta/tcpreplay/68f67b1a3a4d319543692afb5bd5b191ec984287/tcprewrite.c/vul/before/0.json",
  "func": "int\nrewrite_packets(tcpedit_t *tcpedit, pcap_t *pin, pcap_dumper_t *pout)\n{\n    tcpr_dir_t cache_result = TCPR_DIR_C2S;     /* default to primary */\n    struct pcap_pkthdr pkthdr, *pkthdr_ptr;     /* packet header */\n    const u_char *pktconst = NULL;              /* packet from libpcap */\n    u_char **pktdata = NULL;\n    static u_char *pktdata_buff;\n    static char *frag = NULL;\n    COUNTER packetnum = 0;\n    int rcode;\n#ifdef ENABLE_FRAGROUTE\n    int frag_len, proto;\n#endif\n\n    pkthdr_ptr = &pkthdr;\n\n    if (pktdata_buff == NULL)\n        pktdata_buff = (u_char *)safe_malloc(MAXPACKET);\n\n    pktdata = &pktdata_buff;\n\n    if (frag == NULL)\n        frag = (char *)safe_malloc(MAXPACKET);\n\n    /* MAIN LOOP \n     * Keep sending while we have packets or until\n     * we've sent enough packets\n     */\n    while ((pktconst = safe_pcap_next(pin, pkthdr_ptr)) != NULL) {\n        packetnum++;\n        dbgx(2, \"packet \" COUNTER_SPEC \" caplen %d\", packetnum, pkthdr.caplen);\n\n        if (pkthdr.caplen > MAXPACKET)\n            errx(-1, \"Frame too big, caplen %d exceeds %d\", pkthdr.caplen, MAXPACKET);\n        /* \n         * copy over the packet so we can pad it out if necessary and\n         * because pcap_next() returns a const ptr\n         */\n        memcpy(*pktdata, pktconst, pkthdr.caplen);\n\n#ifdef ENABLE_VERBOSE\n        if (options.verbose)\n            tcpdump_print(&tcpdump, pkthdr_ptr, *pktdata);\n#endif\n\n        /* Dual nic processing? */\n        if (options.cachedata != NULL) {\n            cache_result = check_cache(options.cachedata, packetnum);\n        }\n\n        /* sometimes we should not send the packet, in such cases\n         * no point in editing this packet at all, just write it to the\n         * output file (note, we can't just remove it, or the tcpprep cache\n         * file will loose it's indexing\n         */\n\n        if (cache_result == TCPR_DIR_NOSEND)\n            goto WRITE_PACKET; /* still need to write it so cache stays in sync */\n\n        if ((rcode = tcpedit_packet(tcpedit, &pkthdr_ptr, pktdata, cache_result)) == TCPEDIT_ERROR) {\n            return -1;\n        } else if ((rcode == TCPEDIT_SOFT_ERROR) && HAVE_OPT(SKIP_SOFT_ERRORS)) {\n            /* don't write packet */\n            dbgx(1, \"Packet \" COUNTER_SPEC \" is suppressed from being written due to soft errors\", packetnum);\n            continue;\n        }\n\n\nWRITE_PACKET:\n#ifdef ENABLE_FRAGROUTE\n        if (options.frag_ctx == NULL) {\n            /* write the packet when there's no fragrouting to be done */\n            pcap_dump((u_char *)pout, pkthdr_ptr, *pktdata);\n        } else {\n            /* get the L3 protocol of the packet */\n            proto = tcpedit_l3proto(tcpedit, AFTER_PROCESS, *pktdata, pkthdr_ptr->caplen);\n\n            /* packet is IPv4/IPv6 AND needs to be fragmented */\n            if ((proto ==  ETHERTYPE_IP || proto == ETHERTYPE_IP6) &&\n                    ((options.fragroute_dir == FRAGROUTE_DIR_BOTH) ||\n                    (cache_result == TCPR_DIR_C2S && options.fragroute_dir == FRAGROUTE_DIR_C2S) ||\n                    (cache_result == TCPR_DIR_S2C && options.fragroute_dir == FRAGROUTE_DIR_S2C))) {\n#ifdef DEBUG\n                int i = 0;\n#endif\n                if (fragroute_process(options.frag_ctx, *pktdata, pkthdr_ptr->caplen) < 0)\n                    errx(-1, \"Error processing packet via fragroute: %s\", options.frag_ctx->errbuf);\n\n                while ((frag_len = fragroute_getfragment(options.frag_ctx, &frag)) > 0) {\n                    /* frags get the same timestamp as the original packet */\n                    dbgx(1, \"processing packet \" COUNTER_SPEC \" frag: %u (%d)\", packetnum, i++, frag_len);\n                    pkthdr_ptr->caplen = frag_len;\n                    pkthdr_ptr->len = frag_len;\n                    pcap_dump((u_char *)pout, pkthdr_ptr, (u_char *)frag);\n                }\n            } else {\n                /* write the packet without fragroute */\n                pcap_dump((u_char *)pout, pkthdr_ptr, *pktdata);\n            }\n        }\n#else\n    /* write the packet when there's no fragrouting to be done */\n    pcap_dump((u_char *)pout, pkthdr_ptr, *pktdata);\n\n#endif\n    } /* while() */\n    return 0;\n}",
  "abstract_func": "int\nrewrite_packets(tcpedit_t *VAR_0, pcap_t *VAR_1, pcap_dumper_t *VAR_2)\n{\n    tcpr_dir_t VAR_3 = VAR_4;     /* COMMENT_0 */\n    struct pcap_pkthdr VAR_5, *VAR_6;     /* COMMENT_1 */\n    const u_char *VAR_7 = NULL;              /* COMMENT_2 */\n    u_char **VAR_8 = NULL;\n    static u_char *VAR_9;\n    static char *VAR_10 = NULL;\n    COUNTER VAR_11 = 0;\n    int VAR_12;\n#ifdef VAR_13\n    int VAR_14, VAR_15;\n#endif\n\n    VAR_6 = &VAR_5;\n\n    if (VAR_9 == NULL)\n        VAR_9 = (u_char *)safe_malloc(VAR_16);\n\n    VAR_8 = &VAR_9;\n\n    if (VAR_10 == NULL)\n        VAR_10 = (char *)safe_malloc(VAR_16);\n\n    /* COMMENT_3 */\n                                                  \n                                \n       \n    while ((VAR_7 = safe_pcap_next(VAR_1, VAR_6)) != NULL) {\n        VAR_11++;\n        dbgx(2, \"packet \" VAR_17 \" caplen %d\", VAR_11, VAR_5.caplen);\n\n        if (VAR_5.caplen > VAR_16)\n            errx(-1, \"Frame too big, caplen %d exceeds %d\", VAR_5.caplen, VAR_16);\n        /* COMMENT_7 */\n                                                                     \n                                                  \n           \n        memcpy(*VAR_8, VAR_7, VAR_5.caplen);\n\n#ifdef VAR_18\n        if (VAR_19.verbose)\n            tcpdump_print(&VAR_20, VAR_6, *VAR_8);\n#endif\n\n        /* COMMENT_11 */\n        if (VAR_19.cachedata != NULL) {\n            VAR_3 = check_cache(VAR_19.cachedata, VAR_11);\n        }\n\n        /* COMMENT_12 */\n                                                                       \n                                                                           \n                                        \n           \n\n        if (VAR_3 == VAR_21)\n            goto WRITE_PACKET; /* COMMENT_17 */\n\n        if ((VAR_12 = tcpedit_packet(VAR_0, &VAR_6, VAR_8, VAR_3)) == VAR_22) {\n            return -1;\n        } else if ((VAR_12 == VAR_23) && HAVE_OPT(VAR_24)) {\n            /* COMMENT_18 */\n            dbgx(1, \"Packet \" VAR_17 \" is suppressed from being written due to soft errors\", VAR_11);\n            continue;\n        }\n\n\nWRITE_PACKET:\n#ifdef VAR_13\n        if (VAR_19.frag_ctx == NULL) {\n            /* COMMENT_19 */\n            pcap_dump((u_char *)VAR_2, VAR_6, *VAR_8);\n        } else {\n            /* COMMENT_20 */\n            VAR_15 = tcpedit_l3proto(VAR_0, VAR_25, *VAR_8, VAR_6->caplen);\n\n            /* COMMENT_21 */\n            if ((VAR_15 ==  VAR_26 || VAR_15 == VAR_27) &&\n                    ((VAR_19.fragroute_dir == VAR_28) ||\n                    (VAR_3 == VAR_4 && VAR_19.fragroute_dir == VAR_29) ||\n                    (VAR_3 == VAR_30 && VAR_19.fragroute_dir == VAR_31))) {\n#ifdef VAR_32\n                int VAR_33 = 0;\n#endif\n                if (fragroute_process(VAR_19.frag_ctx, *VAR_8, VAR_6->caplen) < 0)\n                    errx(-1, \"Error processing packet via fragroute: %s\", VAR_19.frag_ctx->errbuf);\n\n                while ((VAR_14 = fragroute_getfragment(VAR_19.frag_ctx, &VAR_10)) > 0) {\n                    /* COMMENT_22 */\n                    dbgx(1, \"processing packet \" VAR_17 \" frag: %u (%d)\", VAR_11, VAR_33++, VAR_14);\n                    VAR_6->caplen = VAR_14;\n                    VAR_6->len = VAR_14;\n                    pcap_dump((u_char *)VAR_2, VAR_6, (u_char *)VAR_10);\n                }\n            } else {\n                /* COMMENT_23 */\n                pcap_dump((u_char *)VAR_2, VAR_6, *VAR_8);\n            }\n        }\n#else\n    /* COMMENT_19 */\n    pcap_dump((u_char *)VAR_2, VAR_6, *VAR_8);\n\n#endif\n    } /* COMMENT_24 */\n    return 0;\n}",
  "func_graph_path": "appneta/tcpreplay/68f67b1a3a4d319543692afb5bd5b191ec984287/tcprewrite.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -27,7 +27,7 @@\n      * Keep sending while we have packets or until\n      * we've sent enough packets\n      */\n-    while ((pktconst = pcap_next(pin, pkthdr_ptr)) != NULL) {\n+    while ((pktconst = safe_pcap_next(pin, pkthdr_ptr)) != NULL) {\n         packetnum++;\n         dbgx(2, \"packet \" COUNTER_SPEC \" caplen %d\", packetnum, pkthdr.caplen);\n ",
  "diff_line_info": {
    "deleted_lines": [
      "    while ((pktconst = pcap_next(pin, pkthdr_ptr)) != NULL) {"
    ],
    "added_lines": [
      "    while ((pktconst = safe_pcap_next(pin, pkthdr_ptr)) != NULL) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/appneta/tcpreplay/pull/491",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/appneta/tcpreplay/pull/491: 403 Client Error: Forbidden for url: https://api.github.com/repos/appneta/tcpreplay/pulls/491",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "The patch addresses a known security vulnerability (CVE-2018-17582) by adding checks for corrupt PCAP files, preventing potential security risks. The code change introduces a safer function to handle packet processing correctly.\n\n**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}