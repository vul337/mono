{
  "cve_id": "CVE-2017-14201",
  "cwe_ids": [
    "CWE-416"
  ],
  "cvss_vector": "AV:L/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "zephyrproject-rtos/zephyr",
  "commit_msg": "net: shell: dns: Properly manage lifetime of callback data\n\nDNS callback needs \"struct shell *shell\" data structure to pass as\na parameter to shell print. How it was achieved previously is that\nit was packaged together with cosmetic \"bool first\" param into\n\"struct net_shell_user_data\" on the stack, and passed to the\ncallback. The problem was that the original command handler then\nreturned, so the \"struct net_shell_user_data\" on the stack was\noverwritten, and the callback crashed on accessing it.\n\nAn obvious solution was to make that structure static, but that would\nleave to issues still, as turns out we allow system shell to be run\nas more than one concurrent instances.\n\nNext solution was to keep this structure on the stack, but block the\ncommand handler until callback is finished. However, that hit a\ndeadlock due to not well thought out use of a mutex in the shell\nprinting routines.\n\nThe solution presented here is due to @nordic-krch, who noticed that\n\"bool first\" param is indeed cosmetic and not really required. Then\nwe have only \"struct shell *shell\" to pass to the callback, and can\ndo that in callback's pointer param directly, ditching\n\"struct net_shell_user_data\" which needs to be stored on the stack.\n\nSigned-off-by: Paul Sokolovsky <paul.sokolovsky@linaro.org>",
  "commit_hash": "c55722b22e58c5337c36cc21159330735cb64603",
  "git_url": "https://github.com/zephyrproject-rtos/zephyr/commit/c55722b22e58c5337c36cc21159330735cb64603",
  "file_path": "subsys/net/ip/net_shell.c",
  "func_name": "dns_result_cb",
  "func_before": "static void dns_result_cb(enum dns_resolve_status status,\n\t\t\t  struct dns_addrinfo *info,\n\t\t\t  void *user_data)\n{\n\tstruct net_shell_user_data *data = user_data;\n\tconst struct shell *shell = data->shell;\n\tbool *first = data->user_data;\n\n\tif (status == DNS_EAI_CANCELED) {\n\t\tPR_WARNING(\"\\nTimeout while resolving name.\\n\");\n\t\t*first = false;\n\t\treturn;\n\t}\n\n\tif (status == DNS_EAI_INPROGRESS && info) {\n\t\tchar addr[NET_IPV6_ADDR_LEN];\n\n\t\tif (*first) {\n\t\t\tPR(\"\\n\");\n\t\t\t*first = false;\n\t\t}\n\n\t\tif (info->ai_family == AF_INET) {\n\t\t\tnet_addr_ntop(AF_INET,\n\t\t\t\t      &net_sin(&info->ai_addr)->sin_addr,\n\t\t\t\t      addr, NET_IPV4_ADDR_LEN);\n\t\t} else if (info->ai_family == AF_INET6) {\n\t\t\tnet_addr_ntop(AF_INET6,\n\t\t\t\t      &net_sin6(&info->ai_addr)->sin6_addr,\n\t\t\t\t      addr, NET_IPV6_ADDR_LEN);\n\t\t} else {\n\t\t\tstrncpy(addr, \"Invalid protocol family\",\n\t\t\t\tsizeof(addr));\n\t\t}\n\n\t\tPR(\"\\t%s\\n\", addr);\n\t\treturn;\n\t}\n\n\tif (status == DNS_EAI_ALLDONE) {\n\t\tPR(\"All results received\\n\");\n\t\t*first = false;\n\t\treturn;\n\t}\n\n\tif (status == DNS_EAI_FAIL) {\n\t\tPR_WARNING(\"No such name found.\\n\");\n\t\t*first = false;\n\t\treturn;\n\t}\n\n\tPR_WARNING(\"Unhandled status %d received\\n\", status);\n}",
  "abstract_func_before": "static void dns_result_cb(enum dns_resolve_status VAR_0,\n\t\t\t  struct dns_addrinfo *VAR_1,\n\t\t\t  void *VAR_2)\n{\n\tstruct net_shell_user_data *VAR_3 = VAR_2;\n\tconst struct shell *shell = VAR_3->shell;\n\tbool *VAR_4 = VAR_3->user_data;\n\n\tif (VAR_0 == VAR_5) {\n\t\tPR_WARNING(\"\\nTimeout while resolving name.\\n\");\n\t\t*VAR_4 = false;\n\t\treturn;\n\t}\n\n\tif (VAR_0 == VAR_6 && VAR_1) {\n\t\tchar VAR_7[VAR_8];\n\n\t\tif (*VAR_4) {\n\t\t\tPR(\"\\n\");\n\t\t\t*VAR_4 = false;\n\t\t}\n\n\t\tif (VAR_1->ai_family == VAR_9) {\n\t\t\tnet_addr_ntop(VAR_9,\n\t\t\t\t      &net_sin(&VAR_1->ai_addr)->sin_addr,\n\t\t\t\t      VAR_7, VAR_10);\n\t\t} else if (VAR_1->ai_family == VAR_11) {\n\t\t\tnet_addr_ntop(VAR_11,\n\t\t\t\t      &net_sin6(&VAR_1->ai_addr)->sin6_addr,\n\t\t\t\t      VAR_7, VAR_8);\n\t\t} else {\n\t\t\tstrncpy(VAR_7, \"Invalid protocol family\",\n\t\t\t\tsizeof(VAR_7));\n\t\t}\n\n\t\tPR(\"\\t%s\\n\", VAR_7);\n\t\treturn;\n\t}\n\n\tif (VAR_0 == VAR_12) {\n\t\tPR(\"All results received\\n\");\n\t\t*VAR_4 = false;\n\t\treturn;\n\t}\n\n\tif (VAR_0 == VAR_13) {\n\t\tPR_WARNING(\"No such name found.\\n\");\n\t\t*VAR_4 = false;\n\t\treturn;\n\t}\n\n\tPR_WARNING(\"Unhandled status %d received\\n\", VAR_0);\n}",
  "func_graph_path_before": "zephyrproject-rtos/zephyr/c55722b22e58c5337c36cc21159330735cb64603/net_shell.c/vul/before/0.json",
  "func": "static void dns_result_cb(enum dns_resolve_status status,\n\t\t\t  struct dns_addrinfo *info,\n\t\t\t  void *user_data)\n{\n\tconst struct shell *shell = user_data;\n\n\tif (status == DNS_EAI_CANCELED) {\n\t\tPR_WARNING(\"dns: Timeout while resolving name.\\n\");\n\t\treturn;\n\t}\n\n\tif (status == DNS_EAI_INPROGRESS && info) {\n\t\tchar addr[NET_IPV6_ADDR_LEN];\n\n\t\tif (info->ai_family == AF_INET) {\n\t\t\tnet_addr_ntop(AF_INET,\n\t\t\t\t      &net_sin(&info->ai_addr)->sin_addr,\n\t\t\t\t      addr, NET_IPV4_ADDR_LEN);\n\t\t} else if (info->ai_family == AF_INET6) {\n\t\t\tnet_addr_ntop(AF_INET6,\n\t\t\t\t      &net_sin6(&info->ai_addr)->sin6_addr,\n\t\t\t\t      addr, NET_IPV6_ADDR_LEN);\n\t\t} else {\n\t\t\tstrncpy(addr, \"Invalid protocol family\",\n\t\t\t\tsizeof(addr));\n\t\t\t/* strncpy() doesn't guarantee NUL byte at the end. */\n\t\t\taddr[sizeof(addr) - 1] = 0;\n\t\t}\n\n\t\tPR(\"dns: %s\\n\", addr);\n\t\treturn;\n\t}\n\n\tif (status == DNS_EAI_ALLDONE) {\n\t\tPR(\"dns: All results received\\n\");\n\t\treturn;\n\t}\n\n\tif (status == DNS_EAI_FAIL) {\n\t\tPR_WARNING(\"dns: No such name found.\\n\");\n\t\treturn;\n\t}\n\n\tPR_WARNING(\"dns: Unhandled status %d received\\n\", status);\n}",
  "abstract_func": "static void dns_result_cb(enum dns_resolve_status VAR_0,\n\t\t\t  struct dns_addrinfo *VAR_1,\n\t\t\t  void *VAR_2)\n{\n\tconst struct shell *shell = VAR_2;\n\n\tif (VAR_0 == VAR_3) {\n\t\tPR_WARNING(\"dns: Timeout while resolving name.\\n\");\n\t\treturn;\n\t}\n\n\tif (VAR_0 == VAR_4 && VAR_1) {\n\t\tchar VAR_5[VAR_6];\n\n\t\tif (VAR_1->ai_family == VAR_7) {\n\t\t\tnet_addr_ntop(VAR_7,\n\t\t\t\t      &net_sin(&VAR_1->ai_addr)->sin_addr,\n\t\t\t\t      VAR_5, VAR_8);\n\t\t} else if (VAR_1->ai_family == VAR_9) {\n\t\t\tnet_addr_ntop(VAR_9,\n\t\t\t\t      &net_sin6(&VAR_1->ai_addr)->sin6_addr,\n\t\t\t\t      VAR_5, VAR_6);\n\t\t} else {\n\t\t\tstrncpy(VAR_5, \"Invalid protocol family\",\n\t\t\t\tsizeof(VAR_5));\n\t\t\t/* COMMENT_0 */\n\t\t\tVAR_5[sizeof(VAR_5) - 1] = 0;\n\t\t}\n\n\t\tPR(\"dns: %s\\n\", VAR_5);\n\t\treturn;\n\t}\n\n\tif (VAR_0 == VAR_10) {\n\t\tPR(\"dns: All results received\\n\");\n\t\treturn;\n\t}\n\n\tif (VAR_0 == VAR_11) {\n\t\tPR_WARNING(\"dns: No such name found.\\n\");\n\t\treturn;\n\t}\n\n\tPR_WARNING(\"dns: Unhandled status %d received\\n\", VAR_0);\n}",
  "func_graph_path": "zephyrproject-rtos/zephyr/c55722b22e58c5337c36cc21159330735cb64603/net_shell.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -2,23 +2,15 @@\n \t\t\t  struct dns_addrinfo *info,\n \t\t\t  void *user_data)\n {\n-\tstruct net_shell_user_data *data = user_data;\n-\tconst struct shell *shell = data->shell;\n-\tbool *first = data->user_data;\n+\tconst struct shell *shell = user_data;\n \n \tif (status == DNS_EAI_CANCELED) {\n-\t\tPR_WARNING(\"\\nTimeout while resolving name.\\n\");\n-\t\t*first = false;\n+\t\tPR_WARNING(\"dns: Timeout while resolving name.\\n\");\n \t\treturn;\n \t}\n \n \tif (status == DNS_EAI_INPROGRESS && info) {\n \t\tchar addr[NET_IPV6_ADDR_LEN];\n-\n-\t\tif (*first) {\n-\t\t\tPR(\"\\n\");\n-\t\t\t*first = false;\n-\t\t}\n \n \t\tif (info->ai_family == AF_INET) {\n \t\t\tnet_addr_ntop(AF_INET,\n@@ -31,23 +23,23 @@\n \t\t} else {\n \t\t\tstrncpy(addr, \"Invalid protocol family\",\n \t\t\t\tsizeof(addr));\n+\t\t\t/* strncpy() doesn't guarantee NUL byte at the end. */\n+\t\t\taddr[sizeof(addr) - 1] = 0;\n \t\t}\n \n-\t\tPR(\"\\t%s\\n\", addr);\n+\t\tPR(\"dns: %s\\n\", addr);\n \t\treturn;\n \t}\n \n \tif (status == DNS_EAI_ALLDONE) {\n-\t\tPR(\"All results received\\n\");\n-\t\t*first = false;\n+\t\tPR(\"dns: All results received\\n\");\n \t\treturn;\n \t}\n \n \tif (status == DNS_EAI_FAIL) {\n-\t\tPR_WARNING(\"No such name found.\\n\");\n-\t\t*first = false;\n+\t\tPR_WARNING(\"dns: No such name found.\\n\");\n \t\treturn;\n \t}\n \n-\tPR_WARNING(\"Unhandled status %d received\\n\", status);\n+\tPR_WARNING(\"dns: Unhandled status %d received\\n\", status);\n }",
  "diff_line_info": {
    "deleted_lines": [
      "\tstruct net_shell_user_data *data = user_data;",
      "\tconst struct shell *shell = data->shell;",
      "\tbool *first = data->user_data;",
      "\t\tPR_WARNING(\"\\nTimeout while resolving name.\\n\");",
      "\t\t*first = false;",
      "",
      "\t\tif (*first) {",
      "\t\t\tPR(\"\\n\");",
      "\t\t\t*first = false;",
      "\t\t}",
      "\t\tPR(\"\\t%s\\n\", addr);",
      "\t\tPR(\"All results received\\n\");",
      "\t\t*first = false;",
      "\t\tPR_WARNING(\"No such name found.\\n\");",
      "\t\t*first = false;",
      "\tPR_WARNING(\"Unhandled status %d received\\n\", status);"
    ],
    "added_lines": [
      "\tconst struct shell *shell = user_data;",
      "\t\tPR_WARNING(\"dns: Timeout while resolving name.\\n\");",
      "\t\t\t/* strncpy() doesn't guarantee NUL byte at the end. */",
      "\t\t\taddr[sizeof(addr) - 1] = 0;",
      "\t\tPR(\"dns: %s\\n\", addr);",
      "\t\tPR(\"dns: All results received\\n\");",
      "\t\tPR_WARNING(\"dns: No such name found.\\n\");",
      "\tPR_WARNING(\"dns: Unhandled status %d received\\n\", status);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/zephyrproject-rtos/zephyr/pull/13260",
  "description": {
    "pr_info": {
      "title": "net: shell: dns: Properly manage lifetime of callback data ",
      "number": 13260
    },
    "comment": [
      "DNS callback needs \"struct shell *shell\" data structure to pass as\r\na parameter to shell print. How it was achieved previously is that\r\nit was packaged together with cosmetic \"bool first\" param into\r\n\"struct net_shell_user_data\" on the stack, and passed to the\r\ncallback. The problem was that the original command handler then\r\nreturned, so the \"struct net_shell_user_data\" on the stack was\r\noverwritten, and the callback crashed on accessing it.\r\n\r\nAn obvious solution was to make that structure static, but that would\r\nleave to issues still, as turns out we allow system shell to be run\r\nas more than one concurrent instances.\r\n\r\nNext solution was to keep this structure on the stack, but block the\r\ncommand handler until callback is finished. However, that hit a\r\ndeadlock due to not well thought out use of a mutex in the shell\r\nprinting routines.\r\n\r\nThe solution presented here is due to @nordic-krch, who noticed that\r\n\"bool first\" param is indeed cosmetic and not really required. Then\r\nwe have only \"struct shell *shell\" to pass to the callback, and can\r\ndo that in callback's pointer param directly, ditching\r\n\"struct net_shell_user_data\" which needs to be stored on the stack.\r\n\r\nSigned-off-by: Paul Sokolovsky <paul.sokolovsky@linaro.org>",
      "@agross-linaro: Let's start simple. I would like to say right away that we may still arrive at your solution (using getaddrinfo), but the whole idea to trace the path  thru the issues, so we (not even just me) understand the matter and how to avoid similar cases - not just fix one case. So, please bare with us as we trace thru this.\r\n\r\nSo, this is the minimal changes required to fix any \"net dns query &lthost>\" crashes for me. In particular, I don't see anything special in the behavior of `net dns query AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA A` (as the original repro case) from e.g. `net dns query google.com`.\r\n\r\nElsewhere you wrote that with an alternative patch, similar in that nature to this one, you still experienced some issues, and that's what prompted you to go the getaddrinfo way. Can you elaborate on that?\r\n\r\nNow I tested this only with qemu_x86. Proceeding to test with frdm_k64f, I'm blocked by https://github.com/zephyrproject-rtos/zephyr/issues/13251, https://github.com/zephyrproject-rtos/zephyr/issues/13250 . I may imagine that the real meat of the issue shows itself when the shell is accessed via telnet, and I yet will need to look into that. So, this is the very beginning of the investigation, and not the end, and again, I don't claim that 2-line patch resolves all the issues, just that it addresses some.\r\n",
      "Not that dead networking allows to keyboard-fuzz this better (working resolution happens too fast otherwise). For example, what happens if we issue new \"net dns query\" while previous is still active? Can't crash the stupid thing, it seems:\r\n\r\n~~~\r\nuart:~$ net dns query AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA A\r\nIPv4 address type\r\nQuery for 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' sent.\r\n\r\ndns: Timeout while resolving name.\r\nuart:~$ \r\nuart:~$ \r\nuart:~$ net dns query AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA A\r\nIPv4 address type\r\nQuery for 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' sent.\r\nuart:~$ net dns query AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA A\r\nIPv4 address type\r\nCannot resolve 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' (-11)\r\nuart:~$ net dns query AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA A\r\nIPv4 address type\r\nCannot resolve 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' (-11)\r\nuart:~$ net dns query AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA A\r\nIPv4 address type\r\nCannot resolve 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' (-11)\r\n\r\ndns: Timeout while resolving name.\r\nuart:~$ net dns query AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA A\r\nIPv4 address type\r\nQuery for 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' sent.\r\nuart:~$ net dns query AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA A\r\nIPv4 address type\r\nCannot resolve 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' (-11)\r\nuart:~$ net dns query AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA A\r\nIPv4 address type\r\nCannot resolve 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' (-11)\r\nuart:~$ net dns query AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA A\r\nIPv4 address type\r\nCannot resolve 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' (-11)\r\n\r\ndns: Timeout while resolving name.\r\nuart:~$ net dns query AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA A\r\nIPv4 address type\r\nCannot resolve 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' (-2)\r\nuart:~$ net dns query AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA A\r\nIPv4 address type\r\nCannot resolve 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' (-2)\r\nuart:~$ net dns query AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA A\r\nIPv4 address type\r\nCannot resolve 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' (-2)\r\nuart:~$ net dns query AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA A\r\nIPv4 address type\r\nCannot resolve 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' (-2)\r\n~~~\r\n ",
      "# [Codecov](https://codecov.io/gh/zephyrproject-rtos/zephyr/pull/13260?src=pr&el=h1) Report\n> Merging [#13260](https://codecov.io/gh/zephyrproject-rtos/zephyr/pull/13260?src=pr&el=desc) into [master](https://codecov.io/gh/zephyrproject-rtos/zephyr/commit/b44e06ea5b49671f7a34b622cdcc4f72d63d2418?src=pr&el=desc) will **increase** coverage by `<.01%`.\n> The diff coverage is `n/a`.\n\n[![Impacted file tree graph](https://codecov.io/gh/zephyrproject-rtos/zephyr/pull/13260/graphs/tree.svg?width=650&token=ftaqgO8OOj&height=150&src=pr)](https://codecov.io/gh/zephyrproject-rtos/zephyr/pull/13260?src=pr&el=tree)\n\n```diff\n@@            Coverage Diff             @@\n##           master   #13260      +/-   ##\n==========================================\n+ Coverage   48.76%   48.76%   +<.01%     \n==========================================\n  Files         319      319              \n  Lines       46864    46864              \n  Branches    10832    10832              \n==========================================\n+ Hits        22853    22854       +1     \n  Misses      19381    19381              \n+ Partials     4630     4629       -1\n```\n\n\n| [Impacted Files](https://codecov.io/gh/zephyrproject-rtos/zephyr/pull/13260?src=pr&el=tree) | Coverage Δ | |\n|---|---|---|\n| [arch/posix/core/posix\\_core.c](https://codecov.io/gh/zephyrproject-rtos/zephyr/pull/13260/diff?src=pr&el=tree#diff-YXJjaC9wb3NpeC9jb3JlL3Bvc2l4X2NvcmUuYw==) | `91.91% <0%> (+1.01%)` | :arrow_up: |\n\n------\n\n[Continue to review full report at Codecov](https://codecov.io/gh/zephyrproject-rtos/zephyr/pull/13260?src=pr&el=continue).\n> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)\n> `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`\n> Powered by [Codecov](https://codecov.io/gh/zephyrproject-rtos/zephyr/pull/13260?src=pr&el=footer). Last update [b44e06e...c55722b](https://codecov.io/gh/zephyrproject-rtos/zephyr/pull/13260?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).\n",
      "I am concerned about the use of statics.  Multiple shells could cause issue.",
      "> I am concerned about the use of statics.\r\n\r\nThis is supposed to be change \"in the right direction\" (e.g., by assessment of effects, e.g., previously there was an obviously reproducible crash, while with this change, there's no such), but not necessarily final/ultimate fix.\r\n\r\n> Multiple shells could cause issue.\r\n\r\n@jarz-nordic: Could you comment on this? I guess it would make sense to draw a line regarding what to call \"multiple shells\". I would draw it like that: is it possible for an end user, using officially available and supported Zephyr configuration, to enable 2 concurrent and independent instances of the *system* shell, e.g. on 2 different I/O devices?",
      "@pfalcon : In my opinion `static` has nothing to do in contexts of multiple shells. Either way you will have a problem if two different shell backends will use these structures at the same time. They will modify them separately in other words they will compete for it. \r\n\r\nIn order to avoid it you need to have dedicated data sets for each shell backend.",
      "@jarz-nordic: Ok, so now we have this \"shell backend\" complication. Can you please explain what \"shell backend\" is? My intuition would be that \"shell backend\" is an adapter which allows to multiplex **the same** shell instance over multiple I/O devices. E.g. there may be shell with backend on UART1 and UART2. Then a character typed on UART1 would appear on UART2, and vice-versa. It would *not* be the case that you could type on UART1 and UART2 independently, and run different concurrent commands on each of them.\r\n\r\nIs it something different in reality?\r\n",
      "@pfalcon : Your understanding is not correct. Each shell backend is separate and independent object. All they have in common is a command set. They can call different commands at the same time. Problem is when two objects will call the same command at the same time and this command is using the same data.",
      "> Each shell backend is separate and independent object.\r\n\r\nThen they would rather be called \"shell instances\" and not \"shell backends\".\r\n\r\n> They can call different commands at the same time.\r\n\r\nI have no idea how we've arrived at such design. Apparently, we have too much memory to spend. That's of course why we have previously well-working samples lock up on stack overflow, and when they don't lock up, they still don't work: https://github.com/zephyrproject-rtos/zephyr/issues/13251#issuecomment-462421746 .\r\n\r\nAnyway, no-static fix is coming.\r\n",
      "@pfalcon : In most cases it is enough to have only one backend so I do not consider it as a wasto of memory. If you are already using 2 backends usually they are for different things so there should be no conflict.\r\n\r\nRegarding: [#13251 (comment)](https://github.com/zephyrproject-rtos/zephyr/issues/13251#issuecomment-462421746)\r\n\r\nI found 2 examples not working on frdm_k64f today. For one I've started an issue - it is realted to DT: #13243. The other I've described in #13251.\r\n",
      "> In most cases it is enough to have only one backend so I do not consider it as a wasto of memory.\r\n\r\nThanks, what's important in the end is that multiple backends do work concurrently, so @agross-linaro's concerns are very relevant. I'm happy that he knows it, and well, that's kind of knowledge which should be shared and well emphasized. I'd say we should review usage of callbacks, global/static data, and async primitives in shell overall, because I find it hard to believe that DNS is the only case of this issue.\r\n",
      "> Anyway, no-static fix is coming.\r\n\r\nBut yeah, sure, with the world model as described by @jarz-nordic, there's no \"simple, frugal\" solution. We can't have static. Seemingly here it's utilized to just pass useless \"first\" param down to callback, but nope, the real cause is to pass a \"shell\" reference, so it can be printed to. Again, in a simple, frugal world that would be worked around using old good printk(). But here we're trying to do it \"correctly\" for all these layers we've built. Then *duplicating* what getaddrinfo() is apparently the only way to do it. Sorry, @agross-linaro, I do this not out of stubbornness, I truly believe that shoving some fat, and especially not forcing newlib in, is important for shell, which is pretty bloated itself (all the strings, whatnot). Well, at least, I have little choice - I can't really call out others bringing in all this \"bloat\" and then giving in and doing the same. (getaddrinfo() is again has very different usecase, and grows more bloated as we speak, myself adding more POSIX compatibility.)\r\n",
      "**All checks are passing now.**\n\nReview history of this comment for details about previous failed status.\nNote that some checks might have not completed yet.",
      "Ok, I've come full circle here with tracing @agross-linaro's steps. Nothing works. On each step the shell plays against programmer, and of course programmer can only lose. I'm reading to revive https://github.com/zephyrproject-rtos/zephyr/pull/13191 and +1 it, but then we need do ban any callback usage with the shell. All the processing *and printing* should be synchronous in command handlers only.\r\n\r\n@jarz-nordic, this patch is update to show an issue if you'd like to have a look. Note that previously it was possible for that to work, with shell_command_enter(). It was suddenly removed 75ad61f7ef9dfd7db053942819cb647e0267d1e4, and I exactly mean suddenly, because the commit message there just ascertains the fact of removal and gives zero explanation for why it happens. The change comes from https://github.com/zephyrproject-rtos/zephyr/pull/12747 titled \"Shell: printf available safely from different threads\". So, case in this PR demonstrates that the changes there (besides all the good things they bring) the opposite effect: while it was possible before to synchronize different thread as needed, and use shell, now shell tries to complete in synchronization with threads, leading to deadlocks.\r\n",
      "@pfalcon : I had a discussion about `shell_print` and I was asked to use it without any \"freeze\" concept.\r\n\r\nTo avoid the deadlock you can eihter use printk driven by Logger or you can replace it with `shell_print`. What is problem here?",
      "> I head a discussion about `shell_print` and I was asked to use it without any \"freeze\" concept.\r\n\r\nI'm not sure I understand what you mean. From my PoV based on this PR, shell_command_enter() is useful.\r\n\r\n> To avoid the deadlock you can eihter use printk driven by Logger or you can use replace it with `shell_print`. What is problem here?\r\n\r\nAgain, I'm not sure I understand exactly what you mean. But yes, I seem to forget to ask you to try this patch and show what I get with it:\r\n\r\nSo, the test example here is \"samples/net/dns_resolve\". As usual, run it for BOARD=qemu_x86. Then:\r\n\r\n~~~\r\nuart:~$ net dns query foo\r\nQuery for 'foo' sent.\r\nin cb, status=-101, sem=0x004023e4, isr=0\r\nshell: hehe, I'm deadlocking!\r\n~~~\r\n\r\nSo, trying to use shell_fprintf() (via shell_error()) leads to deadlock (by apparent attempt to lock the mutex again.)\r\n",
      "@pfalcon : Yes I got it at some point of time it is not review request but you are just showing the problem.\r\nI will take a look today into this.",
      "Thanks!\r\n",
      "@pfalcon : I am starting analyzing your use case. I am not familiar with this application architecture. Please just let me know if you are using shell print functions in some interrupt? ",
      "@pfalcon : It was investigated and fixed by @nordic-krch . He will explain you details in several minutes.",
      "@pfalcon, i've looked at dns query command and provided example of how to fix it here: https://github.com/nordic-krch/zephyr/commit/b91318adb1c80accd78bd8eb7a7d6ce0167f6cbe\r\n\r\nThere was deadlock in that code but it was caused by shell misuse. Shell thread is taking mutex when processing data and releases it after command is processed. Same mutex is taken is printing to shell happens from different thread than shell thread.\r\n\r\nHere, command was blocking on semaphore (blocking shell thread, keeping mutex taken) and then callback was attempting to take same mutex. Command was probably blocking to prevent others to print to shell but after #12747 it is not needed. After #12747 it is forbidden to block in shell command and attempt to print from another context (shell documentation should be updated to explicitly state that) as that will lead to deadlock.\r\n\r\nIn the example fix it is quite simplified as semaphore is not needed and shell can be passed directly as user_data.\r\n",
      "Well, that was smart, but it's not that easy. So, tracing thru all the questions posed.\r\n\r\n> Please just let me know if you are using shell print functions in some interrupt?\r\n\r\nNo, not from interrupt. From callback. And with Zephyr architecture, callbacks are (almost?) always called from some another thread. It's very hard to imagine situation when callback fires from the same thread.\r\n\r\n> There was deadlock in that code but it was caused by shell misuse.\r\n\r\nNo, no, not so simple ;-). There was deadlock in that code definitely, but it's caused by ...\r\n\r\n> Shell thread is taking mutex when processing data and releases it after command is processed. Same mutex is taken is printing\r\n\r\nSo, don't use think that there's mix up and misuse of the mutex in the shell, not user's misuse of the shell? Because you see, using the same mutex for both of:\r\n\r\n* Wrap around shell command handler\r\n* Merely printing to shell\r\n\r\nDon't you think that using the same mutex for both is way to coarse-grained and that's what leads to problems?\r\n\r\n> Command was probably blocking to prevent others to print to shell\r\n\r\nNo, command was blocking to not let callback's context on the stack to go away.\r\n\r\n> After #12747 it is forbidden to block in shell command and attempt to print from another context\r\n\r\nThat doesn't make any sense! In this PR it's very valid usecase to do that: shell command handler effectively hands over (borrows) shell context to a callback (and all callbacks run in another thread(s)). It even makes sure that there's mutual exclusion between the command handler and a callback - when one prints, another doesn't and vice-versa.\r\n\r\n> shell documentation should be updated to explicitly state that\r\n\r\nNo amount of documentation will help, if the subsystem behavior is contra-logical. I am the command handler. When I'm called, I own the shell structure. If I want, I pass that shell structure to someone else for temporary ownership. When I do, I make sure that I don't use it while it's owned bu someone else. Please stay off my way while I'm doing that.\r\n\r\n> In the example fix it is quite simplified as [...] shell can be passed directly as user_data.\r\n\r\nThat was smart. That's the solution I was looking for yesterday night when I bravely wrote to @agross-linaro that \"we can still do it different way\". I just got fooled by that stupid \"bool first\". While I removed it eventually, I overlooked that we can ditch `struct net_shell_user_data` completely, thus not store anything on stack, thus return from handler safely without any static's, while callback is still running.\r\n\r\nSo, it's smart, but it's hack. There's nothing wrong to pass any additional data into callback. As there can be multiple shell instances (which for some reason called \"backends\"), we can't use static vars. Then the additional data needs to be stored on stack, and the command handler needs to block for lifetime of this additional data (can't just return, or it'll go off the stack). So, @jarz-nordic, @nordic-krch, guys, we didn't finish here yet. This issue will happen again. Unfortunately, it will happen rare enough, so it'll take long time to raise enough level of alert. And each time it will be painful debugging. Because it totally makes no sense to allow callbacks without params to work with shell, but deadlock on callbacks which take params.\r\n ",
      "Ok, the latest patch is based on @nordic-krch's solution (who is credited in the description), plus some cosmetic changes, as the callback is back to run (and print) asynchronously.\r\n\r\nAs I said above, while this particular issue now (hopefully!) should be fixed, the whole matter of using shell with callbacks is very tangled, and it doesn't need to be.\r\n",
      "First:\r\n@pfalcon , @agross-linaro: I will sprinkle my head with ashes on `static`. In git diff I missed that data is stored on the stack. In this case of course adding static is a not a good idea. My obvious fault.\r\n\r\nRegading your concer: \r\n\r\n> * Wrap around shell command handler\r\n> * Merely printing to shell\r\n> \r\n> Don't you think that using the same mutex for both is way to coarse-grained and that's what leads to problems?\r\n\r\nWith regard to this observation, I believe that this could be improved and we will find a compromise.\r\nThe solution may be to release the mutex not before leaving the shell thread but before calling the command handler. It will require a bit of update in the shell but it is probably a good way to solve the problem.\r\n\r\nFrankly speaking, I did not consider such an application as you presented hence we are where we are...",
      "@jarz-nordic \r\n\r\n> I will sprinkle my head with ashes on `static`. In git diff I missed that data is stored on the stack. In this case of course adding static is a not a good idea. My obvious fault.\r\n\r\nBut I don't think it was your fault, because it was me who added \"static\" in the very first version of this patch, then promptly corrected by you in https://github.com/zephyrproject-rtos/zephyr/pull/13260#issuecomment-462416841 .\r\n"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.9"
}