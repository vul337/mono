{
  "cve_id": "CVE-2019-17389",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:C",
  "cvss_is_v3": false,
  "repo_name": "RIOT-OS/RIOT",
  "commit_msg": "emcute: never return from receive loop\n\nWithout this change an attacker would be able to stop the emcute server\nby sending a crafted packet triggering this branch. The solution is\nusing `continue` instead of `return`.",
  "commit_hash": "74e19d451cfa4397b58745a1efcfce81d2eb6426",
  "git_url": "https://github.com/RIOT-OS/RIOT/commit/74e19d451cfa4397b58745a1efcfce81d2eb6426",
  "file_path": "sys/net/application_layer/emcute/emcute.c",
  "func_name": "emcute_run",
  "func_before": "void emcute_run(uint16_t port, const char *id)\n{\n    assert(strlen(id) >= MQTTSN_CLI_ID_MINLEN &&\n           strlen(id) <= MQTTSN_CLI_ID_MAXLEN);\n\n    sock_udp_ep_t local = SOCK_IPV6_EP_ANY;\n    sock_udp_ep_t remote;\n    local.port = port;\n    cli_id = id;\n    timer.callback = time_evt;\n    timer.arg = NULL;\n    mutex_init(&txlock);\n\n    if (sock_udp_create(&sock, &local, NULL, 0) < 0) {\n        LOG_ERROR(\"[emcute] unable to open UDP socket on port %i\\n\", (int)port);\n        return;\n    }\n\n    uint32_t start = xtimer_now_usec();\n    uint32_t t_out = (EMCUTE_KEEPALIVE * US_PER_SEC);\n\n    while (1) {\n        ssize_t len = sock_udp_recv(&sock, rbuf, sizeof(rbuf), t_out, &remote);\n\n        if ((len < 0) && (len != -ETIMEDOUT)) {\n            LOG_ERROR(\"[emcute] error while receiving UDP packet\\n\");\n            return;\n        }\n\n        if (len >= 2) {\n            /* handle the packet */\n            uint16_t pkt_len;\n            /* catch invalid length field */\n            if ((len == 2) && (rbuf[0] == 0x01)) {\n                continue;\n            }\n            /* parse length field */\n            size_t pos = get_len(rbuf, &pkt_len);\n            /* verify length to prevent overflows */\n            if (((size_t)pkt_len > (size_t)len) || (pos >= (size_t)len)) {\n                continue;\n            }\n            /* get packet type */\n            uint8_t type = rbuf[pos];\n\n            switch (type) {\n                case CONNACK:       on_ack(type, 0, 2, 0);              break;\n                case WILLTOPICREQ:  on_ack(type, 0, 0, 0);              break;\n                case WILLMSGREQ:    on_ack(type, 0, 0, 0);              break;\n                case REGACK:        on_ack(type, 4, 6, 2);              break;\n                case PUBLISH:       on_publish((size_t)pkt_len, pos);   break;\n                case PUBACK:        on_ack(type, 4, 6, 0);              break;\n                case SUBACK:        on_ack(type, 5, 7, 3);              break;\n                case UNSUBACK:      on_ack(type, 2, 0, 0);              break;\n                case PINGREQ:       on_pingreq(&remote);                break;\n                case PINGRESP:      on_pingresp();                      break;\n                case DISCONNECT:    on_disconnect();                    break;\n                case WILLTOPICRESP: on_ack(type, 0, 0, 0);              break;\n                case WILLMSGRESP:   on_ack(type, 0, 0, 0);              break;\n                default:\n                    LOG_DEBUG(\"[emcute] received unexpected type [%s]\\n\",\n                              emcute_type_str(type));\n            }\n        }\n\n        uint32_t now = xtimer_now_usec();\n        if ((now - start) >= (EMCUTE_KEEPALIVE * US_PER_SEC)) {\n            send_ping();\n            start = now;\n            t_out = (EMCUTE_KEEPALIVE * US_PER_SEC);\n        }\n        else {\n            t_out = (EMCUTE_KEEPALIVE * US_PER_SEC) - (now - start);\n        }\n    }\n}",
  "abstract_func_before": "void emcute_run(uint16_t VAR_0, const char *VAR_1)\n{\n    assert(strlen(VAR_1) >= VAR_2 &&\n           strlen(VAR_1) <= VAR_3);\n\n    sock_udp_ep_t VAR_4 = VAR_5;\n    sock_udp_ep_t VAR_6;\n    VAR_4.port = VAR_0;\n    VAR_7 = VAR_1;\n    VAR_8.callback = VAR_9;\n    VAR_8.arg = NULL;\n    mutex_init(&VAR_10);\n\n    if (sock_udp_create(&VAR_11, &VAR_4, NULL, 0) < 0) {\n        LOG_ERROR(\"[emcute] unable to open UDP socket on port %i\\n\", (int)VAR_0);\n        return;\n    }\n\n    uint32_t VAR_12 = xtimer_now_usec();\n    uint32_t VAR_13 = (VAR_14 * VAR_15);\n\n    while (1) {\n        ssize_t VAR_16 = sock_udp_recv(&VAR_11, VAR_17, sizeof(VAR_17), VAR_13, &VAR_6);\n\n        if ((VAR_16 < 0) && (VAR_16 != -VAR_18)) {\n            LOG_ERROR(\"[emcute] error while receiving UDP packet\\n\");\n            return;\n        }\n\n        if (VAR_16 >= 2) {\n            /* COMMENT_0 */\n            uint16_t VAR_19;\n            /* COMMENT_1 */\n            if ((VAR_16 == 2) && (VAR_17[0] == 0x01)) {\n                continue;\n            }\n            /* COMMENT_2 */\n            size_t VAR_20 = get_len(VAR_17, &VAR_19);\n            /* COMMENT_3 */\n            if (((size_t)VAR_19 > (size_t)VAR_16) || (VAR_20 >= (size_t)VAR_16)) {\n                continue;\n            }\n            /* COMMENT_4 */\n            uint8_t VAR_21 = VAR_17[VAR_20];\n\n            switch (VAR_21) {\n                case VAR_22:       on_ack(VAR_21, 0, 2, 0);              break;\n                case VAR_23:  on_ack(VAR_21, 0, 0, 0);              break;\n                case VAR_24:    on_ack(VAR_21, 0, 0, 0);              break;\n                case VAR_25:        on_ack(VAR_21, 4, 6, 2);              break;\n                case VAR_26:       on_publish((size_t)VAR_19, VAR_20);   break;\n                case VAR_27:        on_ack(VAR_21, 4, 6, 0);              break;\n                case VAR_28:        on_ack(VAR_21, 5, 7, 3);              break;\n                case VAR_29:      on_ack(VAR_21, 2, 0, 0);              break;\n                case VAR_30:       on_pingreq(&VAR_6);                break;\n                case VAR_31:      on_pingresp();                      break;\n                case VAR_32:    on_disconnect();                    break;\n                case VAR_33: on_ack(VAR_21, 0, 0, 0);              break;\n                case VAR_34:   on_ack(VAR_21, 0, 0, 0);              break;\n                default:\n                    LOG_DEBUG(\"[emcute] received unexpected type [%s]\\n\",\n                              emcute_type_str(VAR_21));\n            }\n        }\n\n        uint32_t VAR_35 = xtimer_now_usec();\n        if ((VAR_35 - VAR_12) >= (VAR_14 * VAR_15)) {\n            send_ping();\n            VAR_12 = VAR_35;\n            VAR_13 = (VAR_14 * VAR_15);\n        }\n        else {\n            VAR_13 = (VAR_14 * VAR_15) - (VAR_35 - VAR_12);\n        }\n    }\n}",
  "func_graph_path_before": "RIOT-OS/RIOT/74e19d451cfa4397b58745a1efcfce81d2eb6426/emcute.c/vul/before/0.json",
  "func": "void emcute_run(uint16_t port, const char *id)\n{\n    assert(strlen(id) >= MQTTSN_CLI_ID_MINLEN &&\n           strlen(id) <= MQTTSN_CLI_ID_MAXLEN);\n\n    sock_udp_ep_t local = SOCK_IPV6_EP_ANY;\n    sock_udp_ep_t remote;\n    local.port = port;\n    cli_id = id;\n    timer.callback = time_evt;\n    timer.arg = NULL;\n    mutex_init(&txlock);\n\n    if (sock_udp_create(&sock, &local, NULL, 0) < 0) {\n        LOG_ERROR(\"[emcute] unable to open UDP socket on port %i\\n\", (int)port);\n        return;\n    }\n\n    uint32_t start = xtimer_now_usec();\n    uint32_t t_out = (EMCUTE_KEEPALIVE * US_PER_SEC);\n\n    while (1) {\n        ssize_t len = sock_udp_recv(&sock, rbuf, sizeof(rbuf), t_out, &remote);\n\n        if ((len < 0) && (len != -ETIMEDOUT)) {\n            LOG_ERROR(\"[emcute] error while receiving UDP packet\\n\");\n            continue;\n        }\n\n        if (len >= 2) {\n            /* handle the packet */\n            uint16_t pkt_len;\n            /* catch invalid length field */\n            if ((len == 2) && (rbuf[0] == 0x01)) {\n                continue;\n            }\n            /* parse length field */\n            size_t pos = get_len(rbuf, &pkt_len);\n            /* verify length to prevent overflows */\n            if (((size_t)pkt_len > (size_t)len) || (pos >= (size_t)len)) {\n                continue;\n            }\n            /* get packet type */\n            uint8_t type = rbuf[pos];\n\n            switch (type) {\n                case CONNACK:       on_ack(type, 0, 2, 0);              break;\n                case WILLTOPICREQ:  on_ack(type, 0, 0, 0);              break;\n                case WILLMSGREQ:    on_ack(type, 0, 0, 0);              break;\n                case REGACK:        on_ack(type, 4, 6, 2);              break;\n                case PUBLISH:       on_publish((size_t)pkt_len, pos);   break;\n                case PUBACK:        on_ack(type, 4, 6, 0);              break;\n                case SUBACK:        on_ack(type, 5, 7, 3);              break;\n                case UNSUBACK:      on_ack(type, 2, 0, 0);              break;\n                case PINGREQ:       on_pingreq(&remote);                break;\n                case PINGRESP:      on_pingresp();                      break;\n                case DISCONNECT:    on_disconnect();                    break;\n                case WILLTOPICRESP: on_ack(type, 0, 0, 0);              break;\n                case WILLMSGRESP:   on_ack(type, 0, 0, 0);              break;\n                default:\n                    LOG_DEBUG(\"[emcute] received unexpected type [%s]\\n\",\n                              emcute_type_str(type));\n            }\n        }\n\n        uint32_t now = xtimer_now_usec();\n        if ((now - start) >= (EMCUTE_KEEPALIVE * US_PER_SEC)) {\n            send_ping();\n            start = now;\n            t_out = (EMCUTE_KEEPALIVE * US_PER_SEC);\n        }\n        else {\n            t_out = (EMCUTE_KEEPALIVE * US_PER_SEC) - (now - start);\n        }\n    }\n}",
  "abstract_func": "void emcute_run(uint16_t VAR_0, const char *VAR_1)\n{\n    assert(strlen(VAR_1) >= VAR_2 &&\n           strlen(VAR_1) <= VAR_3);\n\n    sock_udp_ep_t VAR_4 = VAR_5;\n    sock_udp_ep_t VAR_6;\n    VAR_4.port = VAR_0;\n    VAR_7 = VAR_1;\n    VAR_8.callback = VAR_9;\n    VAR_8.arg = NULL;\n    mutex_init(&VAR_10);\n\n    if (sock_udp_create(&VAR_11, &VAR_4, NULL, 0) < 0) {\n        LOG_ERROR(\"[emcute] unable to open UDP socket on port %i\\n\", (int)VAR_0);\n        return;\n    }\n\n    uint32_t VAR_12 = xtimer_now_usec();\n    uint32_t VAR_13 = (VAR_14 * VAR_15);\n\n    while (1) {\n        ssize_t VAR_16 = sock_udp_recv(&VAR_11, VAR_17, sizeof(VAR_17), VAR_13, &VAR_6);\n\n        if ((VAR_16 < 0) && (VAR_16 != -VAR_18)) {\n            LOG_ERROR(\"[emcute] error while receiving UDP packet\\n\");\n            continue;\n        }\n\n        if (VAR_16 >= 2) {\n            /* COMMENT_0 */\n            uint16_t VAR_19;\n            /* COMMENT_1 */\n            if ((VAR_16 == 2) && (VAR_17[0] == 0x01)) {\n                continue;\n            }\n            /* COMMENT_2 */\n            size_t VAR_20 = get_len(VAR_17, &VAR_19);\n            /* COMMENT_3 */\n            if (((size_t)VAR_19 > (size_t)VAR_16) || (VAR_20 >= (size_t)VAR_16)) {\n                continue;\n            }\n            /* COMMENT_4 */\n            uint8_t VAR_21 = VAR_17[VAR_20];\n\n            switch (VAR_21) {\n                case VAR_22:       on_ack(VAR_21, 0, 2, 0);              break;\n                case VAR_23:  on_ack(VAR_21, 0, 0, 0);              break;\n                case VAR_24:    on_ack(VAR_21, 0, 0, 0);              break;\n                case VAR_25:        on_ack(VAR_21, 4, 6, 2);              break;\n                case VAR_26:       on_publish((size_t)VAR_19, VAR_20);   break;\n                case VAR_27:        on_ack(VAR_21, 4, 6, 0);              break;\n                case VAR_28:        on_ack(VAR_21, 5, 7, 3);              break;\n                case VAR_29:      on_ack(VAR_21, 2, 0, 0);              break;\n                case VAR_30:       on_pingreq(&VAR_6);                break;\n                case VAR_31:      on_pingresp();                      break;\n                case VAR_32:    on_disconnect();                    break;\n                case VAR_33: on_ack(VAR_21, 0, 0, 0);              break;\n                case VAR_34:   on_ack(VAR_21, 0, 0, 0);              break;\n                default:\n                    LOG_DEBUG(\"[emcute] received unexpected type [%s]\\n\",\n                              emcute_type_str(VAR_21));\n            }\n        }\n\n        uint32_t VAR_35 = xtimer_now_usec();\n        if ((VAR_35 - VAR_12) >= (VAR_14 * VAR_15)) {\n            send_ping();\n            VAR_12 = VAR_35;\n            VAR_13 = (VAR_14 * VAR_15);\n        }\n        else {\n            VAR_13 = (VAR_14 * VAR_15) - (VAR_35 - VAR_12);\n        }\n    }\n}",
  "func_graph_path": "RIOT-OS/RIOT/74e19d451cfa4397b58745a1efcfce81d2eb6426/emcute.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -24,7 +24,7 @@\n \n         if ((len < 0) && (len != -ETIMEDOUT)) {\n             LOG_ERROR(\"[emcute] error while receiving UDP packet\\n\");\n-            return;\n+            continue;\n         }\n \n         if (len >= 2) {",
  "diff_line_info": {
    "deleted_lines": [
      "            return;"
    ],
    "added_lines": [
      "            continue;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/RIOT-OS/RIOT/pull/12382",
  "description": {
    "pr_info": {
      "title": "emcute: never return from receive loop",
      "number": 12382
    },
    "comment": [
      "### Contribution description\r\n\r\nThe receive thread of the MQTT-SN implementation emcute returns from the packet receive loop if `sock_udp_recv` returns an error. This is, for instance, the case when a given packet doesn't fit into the supplied buffer. This condition can be triggered by anyone able to send large packets (> 512 byte) to the UDP socket. If so, this will stop the MQTT client from working until the device is restarted, i.e. `emcute_run` is invoked again.\r\n\r\nhttps://github.com/RIOT-OS/RIOT/blob/89afc378a92bf198246335fd2fa64a76dfe6e00e/sys/net/application_layer/emcute/emcute.c#L515-L521\r\n\r\n### Testing procedure\r\n\r\nMy tap configuration is as follows:\r\n\r\n```\r\n4: tap0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000\r\n    link/ether 32:e2:ba:2b:07:d1 brd ff:ff:ff:ff:ff:ff\r\n    inet6 fe80::30e2:baff:fe2b:7d1/64 scope link \r\n       valid_lft forever preferred_lft forever\r\n```\r\n\r\n1. Enable debug in `sys/net/application_layer/emcute/emcute.c`.\r\n2. Compile and run `examples/emcute_mqttsn`.\r\n3. Connect to a bugos MQTT server address.\r\n4. Spoof a server reply with a packet exceeding the default buffer size (512 byte). This causes `sock_udp_recv` to return `-ENOBUFS`.\r\n5. Attempt to connect to a real working MQTT server (will fail).\r\n\r\n```\r\nMQTT-SN example application\r\n\r\nType 'help' to get started. Have a look at the README.md for more information.\r\n> con fe80::30e2:baff:fe2b:7d1 2342\r\n```\r\n\r\nSpoof the reply, e.g. using:\r\n\r\n```\r\nhead -c 525 < /dev/urandom  | busybox nc -p 2342 -u 'fe80::30e2:baff:fe2b:7d2%tap0' 1883\r\n```\r\n\r\nThis should cause `emcute_run` to return and output the message `[emcute] error while receiving UDP packet`. Afterwards, it should no longer be possible to connect to a working MQTT-SN server since emcute will nerver receive the CONNACK reply from it since it doesn't read from the socket anymore.\r\n\r\n### Impact\r\n\r\nDenial of service, a spoofed server message will cause the emcute client to stop working until `emcute_run` is invoked again which is usually the case when the device is restarted.",
      "Will try to remember to add a test case for that to #11823.",
      "Ok, wasn't that hard...: https://github.com/RIOT-OS/RIOT/pull/11823/commits/edae2c268abc7fd69d784b8b8f67d1aa98b3fb03. I was able to confirm this bug fix using that patch and cherry-picking https://github.com/RIOT-OS/RIOT/pull/12382/commits/74e19d451cfa4397b58745a1efcfce81d2eb6426 and https://github.com/RIOT-OS/RIOT/pull/11957/commits/10a3f3e8ed7f94596379b2edc0ac2a86a2699cbd on top (and without of course)."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "The patch fixes a security vulnerability where an attacker could cause a DoS by sending large packets, leading the server to stop. The code uses `continue` instead of `return` to handle errors gracefully.\n\n**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}