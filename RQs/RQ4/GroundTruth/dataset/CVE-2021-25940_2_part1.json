{
  "cve_id": "CVE-2021-25940",
  "cwe_ids": [
    "CWE-613"
  ],
  "cvss_vector": "AV:N/AC:M/Au:S/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "arangodb",
  "commit_msg": "Revive startup parameter `--server.session-timeout` (#14118)\n\nCo-authored-by: Tobias GÃ¶dderz <tobias@arangodb.com>",
  "commit_hash": "e9c6ee9dcca7b9b4fbcd02a0b323d205bee838d3",
  "git_url": "https://github.com/arangodb/arangodb/commit/e9c6ee9dcca7b9b4fbcd02a0b323d205bee838d3",
  "file_path": "arangod/RestHandler/RestAuthHandler.cpp",
  "func_name": "RestAuthHandler::execute",
  "func_before": "RestStatus RestAuthHandler::execute() {\n  auto const type = _request->requestType();\n  if (type != rest::RequestType::POST) {\n    generateError(rest::ResponseCode::METHOD_NOT_ALLOWED, TRI_ERROR_HTTP_METHOD_NOT_ALLOWED);\n    return RestStatus::DONE;\n  }\n\n  bool parseSuccess = false;\n  VPackSlice slice = this->parseVPackBody(parseSuccess);\n  if (!parseSuccess) { // error already set\n    return RestStatus::DONE;\n  }\n\n  if (!slice.isObject()) {\n    return badRequest();\n  }\n\n  VPackSlice usernameSlice = slice.get(\"username\");\n  VPackSlice passwordSlice = slice.get(\"password\");\n\n  if (!usernameSlice.isString() || !passwordSlice.isString()) {\n    return badRequest();\n  }\n\n  _username = usernameSlice.copyString();\n  std::string const password = passwordSlice.copyString();\n\n  auth::UserManager* um = AuthenticationFeature::instance()->userManager();\n  if (um == nullptr) {\n    std::string msg = \"This server does not support users\";\n    LOG_TOPIC(\"2e7d4\", ERR, Logger::AUTHENTICATION) << msg;\n    generateError(rest::ResponseCode::UNAUTHORIZED, TRI_ERROR_HTTP_UNAUTHORIZED, msg);\n  } else if (um->checkPassword(_username, password)) {\n    VPackBuilder resultBuilder;\n    {\n      VPackObjectBuilder b(&resultBuilder);\n      std::string jwt = generateJwt(_username, password);\n      resultBuilder.add(\"jwt\", VPackValue(jwt));\n    }\n\n    _isValid = true;\n    generateDocument(resultBuilder.slice(), true, &VPackOptions::Defaults);\n  } else {\n    // mop: rfc 2616 10.4.2 (if credentials wrong 401)\n    generateError(rest::ResponseCode::UNAUTHORIZED, TRI_ERROR_HTTP_UNAUTHORIZED,\n                  \"Wrong credentials\");\n  }\n  return RestStatus::DONE;\n}",
  "abstract_func_before": "RestStatus RestAuthHandler::execute() {\n  auto const VAR_0 = VAR_1->requestType();\n  if (VAR_0 != rest::RequestType::POST) {\n    generateError(rest::ResponseCode::METHOD_NOT_ALLOWED, VAR_2);\n    return RestStatus::DONE;\n  }\n\n  bool VAR_3 = false;\n  VPackSlice VAR_4 = this->parseVPackBody(VAR_3);\n  if (!VAR_3) { /* COMMENT_0 */\n    return RestStatus::DONE;\n  }\n\n  if (!VAR_4.isObject()) {\n    return badRequest();\n  }\n\n  VPackSlice VAR_5 = VAR_4.get(\"username\");\n  VPackSlice VAR_6 = VAR_4.get(\"password\");\n\n  if (!VAR_5.isString() || !VAR_6.isString()) {\n    return badRequest();\n  }\n\n  VAR_7 = VAR_5.copyString();\n  std::string const VAR_8 = VAR_6.copyString();\n\n  auth::UserManager* VAR_9 = AuthenticationFeature::instance()->userManager();\n  if (VAR_9 == nullptr) {\n    std::string VAR_10 = \"This server does not support users\";\n    LOG_TOPIC(\"2e7d4\", VAR_11, Logger::AUTHENTICATION) << VAR_10;\n    generateError(rest::ResponseCode::UNAUTHORIZED, VAR_12, VAR_10);\n  } else if (VAR_9->checkPassword(VAR_7, VAR_8)) {\n    VPackBuilder VAR_13;\n    {\n      VPackObjectBuilder VAR_14(&VAR_13);\n      std::string VAR_15 = generateJwt(VAR_7, VAR_8);\n      VAR_13.add(\"jwt\", VPackValue(VAR_15));\n    }\n\n    VAR_16 = true;\n    generateDocument(VAR_13.slice(), true, &VPackOptions::Defaults);\n  } else {\n    /* COMMENT_1 */\n    generateError(rest::ResponseCode::UNAUTHORIZED, VAR_12,\n                  \"Wrong credentials\");\n  }\n  return RestStatus::DONE;\n}",
  "func_graph_path_before": null,
  "func": "RestStatus RestAuthHandler::execute() {\n  auto const type = _request->requestType();\n  if (type != rest::RequestType::POST) {\n    generateError(rest::ResponseCode::METHOD_NOT_ALLOWED, TRI_ERROR_HTTP_METHOD_NOT_ALLOWED);\n    return RestStatus::DONE;\n  }\n\n  bool parseSuccess = false;\n  VPackSlice slice = this->parseVPackBody(parseSuccess);\n  if (!parseSuccess) { // error already set\n    return RestStatus::DONE;\n  }\n\n  if (!slice.isObject()) {\n    return badRequest();\n  }\n\n  VPackSlice usernameSlice = slice.get(\"username\");\n  VPackSlice passwordSlice = slice.get(\"password\");\n\n  if (!usernameSlice.isString() || !passwordSlice.isString()) {\n    return badRequest();\n  }\n\n  std::string const username = usernameSlice.copyString();\n  std::string const password = passwordSlice.copyString();\n\n  bool isValid = false;\n\n  auto guard = scopeGuard([&]() {\n    try {\n      if (isValid) {\n        events::LoggedIn(*_request, username);\n      } else {\n        events::CredentialsBad(*_request, username);\n      }\n    } catch (...) {\n      // nothing we can do\n    }\n  });\n  \n  auth::UserManager* um = AuthenticationFeature::instance()->userManager();\n  if (um == nullptr) {\n    std::string msg = \"This server does not support users\";\n    LOG_TOPIC(\"2e7d4\", ERR, Logger::AUTHENTICATION) << msg;\n    generateError(rest::ResponseCode::UNAUTHORIZED, TRI_ERROR_HTTP_UNAUTHORIZED, msg);\n  } else if (um->checkPassword(username, password)) {\n    VPackBuilder resultBuilder;\n    {\n      VPackObjectBuilder b(&resultBuilder);\n      resultBuilder.add(\"jwt\", VPackValue(generateJwt(username)));\n    }\n\n    isValid = true;\n    generateDocument(resultBuilder.slice(), true, &VPackOptions::Defaults);\n  } else {\n    // mop: rfc 2616 10.4.2 (if credentials wrong 401)\n    generateError(rest::ResponseCode::UNAUTHORIZED, TRI_ERROR_HTTP_UNAUTHORIZED,\n                  \"Wrong credentials\");\n  }\n  return RestStatus::DONE;\n}",
  "abstract_func": "RestStatus RestAuthHandler::execute() {\n  auto const VAR_0 = VAR_1->requestType();\n  if (VAR_0 != rest::RequestType::POST) {\n    generateError(rest::ResponseCode::METHOD_NOT_ALLOWED, VAR_2);\n    return RestStatus::DONE;\n  }\n\n  bool VAR_3 = false;\n  VPackSlice VAR_4 = this->parseVPackBody(VAR_3);\n  if (!VAR_3) { /* COMMENT_0 */\n    return RestStatus::DONE;\n  }\n\n  if (!VAR_4.isObject()) {\n    return badRequest();\n  }\n\n  VPackSlice VAR_5 = VAR_4.get(\"username\");\n  VPackSlice VAR_6 = VAR_4.get(\"password\");\n\n  if (!VAR_5.isString() || !VAR_6.isString()) {\n    return badRequest();\n  }\n\n  std::string const VAR_7 = VAR_5.copyString();\n  std::string const VAR_8 = VAR_6.copyString();\n\n  bool VAR_9 = false;\n\n  auto VAR_10 = scopeGuard([&]() {\n    try {\n      if (VAR_9) {\n        events::LoggedIn(*VAR_1, VAR_7);\n      } else {\n        events::CredentialsBad(*VAR_1, VAR_7);\n      }\n    } catch (...) {\n      /* COMMENT_1 */\n    }\n  });\n  \n  auth::UserManager* VAR_11 = AuthenticationFeature::instance()->userManager();\n  if (VAR_11 == nullptr) {\n    std::string VAR_12 = \"This server does not support users\";\n    LOG_TOPIC(\"2e7d4\", VAR_13, Logger::AUTHENTICATION) << VAR_12;\n    generateError(rest::ResponseCode::UNAUTHORIZED, VAR_14, VAR_12);\n  } else if (VAR_11->checkPassword(VAR_7, VAR_8)) {\n    VPackBuilder VAR_15;\n    {\n      VPackObjectBuilder VAR_16(&VAR_15);\n      VAR_15.add(\"jwt\", VPackValue(generateJwt(VAR_7)));\n    }\n\n    VAR_9 = true;\n    generateDocument(VAR_15.slice(), true, &VPackOptions::Defaults);\n  } else {\n    /* COMMENT_2 */\n    generateError(rest::ResponseCode::UNAUTHORIZED, VAR_14,\n                  \"Wrong credentials\");\n  }\n  return RestStatus::DONE;\n}",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -22,23 +22,36 @@\n     return badRequest();\n   }\n \n-  _username = usernameSlice.copyString();\n+  std::string const username = usernameSlice.copyString();\n   std::string const password = passwordSlice.copyString();\n \n+  bool isValid = false;\n+\n+  auto guard = scopeGuard([&]() {\n+    try {\n+      if (isValid) {\n+        events::LoggedIn(*_request, username);\n+      } else {\n+        events::CredentialsBad(*_request, username);\n+      }\n+    } catch (...) {\n+      // nothing we can do\n+    }\n+  });\n+  \n   auth::UserManager* um = AuthenticationFeature::instance()->userManager();\n   if (um == nullptr) {\n     std::string msg = \"This server does not support users\";\n     LOG_TOPIC(\"2e7d4\", ERR, Logger::AUTHENTICATION) << msg;\n     generateError(rest::ResponseCode::UNAUTHORIZED, TRI_ERROR_HTTP_UNAUTHORIZED, msg);\n-  } else if (um->checkPassword(_username, password)) {\n+  } else if (um->checkPassword(username, password)) {\n     VPackBuilder resultBuilder;\n     {\n       VPackObjectBuilder b(&resultBuilder);\n-      std::string jwt = generateJwt(_username, password);\n-      resultBuilder.add(\"jwt\", VPackValue(jwt));\n+      resultBuilder.add(\"jwt\", VPackValue(generateJwt(username)));\n     }\n \n-    _isValid = true;\n+    isValid = true;\n     generateDocument(resultBuilder.slice(), true, &VPackOptions::Defaults);\n   } else {\n     // mop: rfc 2616 10.4.2 (if credentials wrong 401)",
  "diff_line_info": {
    "deleted_lines": [
      "  _username = usernameSlice.copyString();",
      "  } else if (um->checkPassword(_username, password)) {",
      "      std::string jwt = generateJwt(_username, password);",
      "      resultBuilder.add(\"jwt\", VPackValue(jwt));",
      "    _isValid = true;"
    ],
    "added_lines": [
      "  std::string const username = usernameSlice.copyString();",
      "  bool isValid = false;",
      "",
      "  auto guard = scopeGuard([&]() {",
      "    try {",
      "      if (isValid) {",
      "        events::LoggedIn(*_request, username);",
      "      } else {",
      "        events::CredentialsBad(*_request, username);",
      "      }",
      "    } catch (...) {",
      "      // nothing we can do",
      "    }",
      "  });",
      "  ",
      "  } else if (um->checkPassword(username, password)) {",
      "      resultBuilder.add(\"jwt\", VPackValue(generateJwt(username)));",
      "    isValid = true;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/arangodb/arangodb/pull/14118",
  "description": {
    "pr_info": {
      "title": "Revive startup parameter `--server.session-timeout`",
      "number": 14118
    },
    "comment": [
      "### Scope & Purpose\r\n\r\nIn order to address APM-79: https://arangodb.atlassian.net/browse/APM-79\r\nDocs PR: https://github.com/arangodb/docs/pull/720\r\n\r\nRevive startup parameter `--server.session-timeout` to control the timeout for web interface sessions and other sessions that are based on JWTs created by the `/_open/auth` API.\r\nThe default timeout value is 30 days, which is identical to the currently hard-coded timeout used.\r\n\r\nQuestions: shall we introduce this with a lower timeout value? Or at least adjust the timeout in devel?\r\n\r\n- [x] :hankey: Bugfix (requires CHANGELOG entry)\r\n- [x] :pizza: New feature (requires CHANGELOG entry, feature documentation and release notes)\r\n- [ ] :fire: Performance improvement\r\n- [ ] :hammer: Refactoring/simplification\r\n- [x] :book: CHANGELOG entry made\r\n\r\n#### Backports:\r\n\r\n- [x] Backports required for: *3.8*, *3.7*\r\n\r\n#### Related Information\r\n\r\n- [x] Docs PR: https://github.com/arangodb/docs/pull/720\r\n- [x] GitHub issue / Jira ticket number: https://arangodb.atlassian.net/browse/APM-79\r\n\r\n### Testing & Verification\r\n\r\n- [x] This change is a trivial rework / code cleanup without any test coverage.\r\n- [x] The behavior in this PR was *manually tested*\r\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Step-by-Step Explanation:**\n\n1. **Input Analysis:**\n   - Commit Message: Introduces a new session timeout parameter affecting session management.\n   - Vulnerability Description: Portrays an enhancement in session timeout control, tied to a bug fix and new feature.\n   - Code Diff: Changes involve authentication handler, JWT generation without password, and logging events.\n\n2. **Consistency Check:**\n   - The code changes align with the commit message, focusing on session and authentication.\n   \n3. **Purpose Evaluation:**\n   - Modifications are to core authentication logic, affecting session management and security.\n\n4. **Security Vulnerability Assessment:**\n   - Addresses session timeout, crucial for security to prevent misuse from long sessions.\n   - Adjusting timeout can mitigate risks like session hijacking.\n\n5. **Non-Security Classification:**\n   - Not applicable. Changes address a security concern.\n\n6. **Confidence Scoring:**\n   - 0.9: Clear intent to enhance security through session management and logging.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9"
}