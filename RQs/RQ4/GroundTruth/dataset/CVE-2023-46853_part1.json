{
  "cve_id": "CVE-2023-46853",
  "cwe_ids": [
    "CWE-193"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "memcached",
  "commit_msg": "proxy: fix off-by-one if \\r is missing\n\nA bunch of the parser assumed we only had \\r\\n, but I didn't actually\nhave that strictness set. Some commands worked and some broke in subtle\nways when just \"\\n\" was being submitted.\n\nI'm not 100% confident in this change yet so I'm opening a PR to stage\nit while I run some more thorough tests.",
  "commit_hash": "6987918e9a3094ec4fc8976f01f769f624d790fa",
  "git_url": "https://github.com/memcached/memcached/commit/6987918e9a3094ec4fc8976f01f769f624d790fa",
  "file_path": "proxy_request.c",
  "func_name": "_process_request_metaflags",
  "func_before": "static int _process_request_metaflags(mcp_parser_t *pr, int token) {\n    if (pr->ntokens <= token) {\n        pr->t.meta.flags = 0; // no flags found.\n        return 0;\n    }\n    const char *cur = pr->request + pr->tokens[token];\n    const char *end = pr->request + pr->reqlen - 2;\n\n    // We blindly convert flags into bits, since the range of possible\n    // flags is deliberately < 64.\n    int state = 0;\n    while (cur != end) {\n        switch (state) {\n            case 0:\n                if (*cur == ' ') {\n                    cur++;\n                } else {\n                    if (*cur < 65 || *cur > 122) {\n                        return -1;\n                    }\n                    P_DEBUG(\"%s: setting meta flag: %d\\n\", __func__, *cur - 65);\n                    pr->t.meta.flags |= (uint64_t)1 << (*cur - 65);\n                    state = 1;\n                }\n                break;\n            case 1:\n                if (*cur != ' ') {\n                    cur++;\n                } else {\n                    state = 0;\n                }\n                break;\n        }\n    }\n\n    // not too great hack for noreply detection: this can be flattened out\n    // once a few other contexts are fixed and we detect the noreply from the\n    // coroutine start instead.\n    if (pr->t.meta.flags & ((uint64_t)1 << 48)) {\n        pr->noreply = true;\n    }\n\n    return 0;\n}",
  "abstract_func_before": "static int _process_request_metaflags(mcp_parser_t *VAR_0, int VAR_1) {\n    if (VAR_0->ntokens <= VAR_1) {\n        VAR_0->t.meta.flags = 0; /* COMMENT_0 */\n        return 0;\n    }\n    const char *VAR_2 = VAR_0->request + VAR_0->tokens[VAR_1];\n    const char *VAR_3 = VAR_0->request + VAR_0->reqlen - 2;\n\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n    int VAR_4 = 0;\n    while (VAR_2 != VAR_3) {\n        switch (VAR_4) {\n            case 0:\n                if (*VAR_2 == ' ') {\n                    VAR_2++;\n                } else {\n                    if (*VAR_2 < 65 || *VAR_2 > 122) {\n                        return -1;\n                    }\n                    P_DEBUG(\"%s: setting meta flag: %d\\n\", VAR_5, *VAR_2 - 65);\n                    VAR_0->t.meta.flags |= (uint64_t)1 << (*VAR_2 - 65);\n                    VAR_4 = 1;\n                }\n                break;\n            case 1:\n                if (*VAR_2 != ' ') {\n                    VAR_2++;\n                } else {\n                    VAR_4 = 0;\n                }\n                break;\n        }\n    }\n\n    /* COMMENT_3 */\n    /* COMMENT_4 */\n    /* COMMENT_5 */\n    if (VAR_0->t.meta.flags & ((uint64_t)1 << 48)) {\n        VAR_0->noreply = true;\n    }\n\n    return 0;\n}",
  "func_graph_path_before": "memcached/6987918e9a3094ec4fc8976f01f769f624d790fa/proxy_request.c/vul/before/0.json",
  "func": "static int _process_request_metaflags(mcp_parser_t *pr, int token) {\n    if (pr->ntokens <= token) {\n        pr->t.meta.flags = 0; // no flags found.\n        return 0;\n    }\n    const char *cur = pr->request + pr->tokens[token];\n    const char *end = pr->request + pr->endlen;\n\n    // We blindly convert flags into bits, since the range of possible\n    // flags is deliberately < 64.\n    int state = 0;\n    while (cur != end) {\n        switch (state) {\n            case 0:\n                if (*cur == ' ') {\n                    cur++;\n                } else {\n                    if (*cur < 65 || *cur > 122) {\n                        return -1;\n                    }\n                    P_DEBUG(\"%s: setting meta flag: %d\\n\", __func__, *cur - 65);\n                    pr->t.meta.flags |= (uint64_t)1 << (*cur - 65);\n                    state = 1;\n                }\n                break;\n            case 1:\n                if (*cur != ' ') {\n                    cur++;\n                } else {\n                    state = 0;\n                }\n                break;\n        }\n    }\n\n    // not too great hack for noreply detection: this can be flattened out\n    // once a few other contexts are fixed and we detect the noreply from the\n    // coroutine start instead.\n    if (pr->t.meta.flags & ((uint64_t)1 << 48)) {\n        pr->noreply = true;\n    }\n\n    return 0;\n}",
  "abstract_func": "static int _process_request_metaflags(mcp_parser_t *VAR_0, int VAR_1) {\n    if (VAR_0->ntokens <= VAR_1) {\n        VAR_0->t.meta.flags = 0; /* COMMENT_0 */\n        return 0;\n    }\n    const char *VAR_2 = VAR_0->request + VAR_0->tokens[VAR_1];\n    const char *VAR_3 = VAR_0->request + VAR_0->endlen;\n\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n    int VAR_4 = 0;\n    while (VAR_2 != VAR_3) {\n        switch (VAR_4) {\n            case 0:\n                if (*VAR_2 == ' ') {\n                    VAR_2++;\n                } else {\n                    if (*VAR_2 < 65 || *VAR_2 > 122) {\n                        return -1;\n                    }\n                    P_DEBUG(\"%s: setting meta flag: %d\\n\", VAR_5, *VAR_2 - 65);\n                    VAR_0->t.meta.flags |= (uint64_t)1 << (*VAR_2 - 65);\n                    VAR_4 = 1;\n                }\n                break;\n            case 1:\n                if (*VAR_2 != ' ') {\n                    VAR_2++;\n                } else {\n                    VAR_4 = 0;\n                }\n                break;\n        }\n    }\n\n    /* COMMENT_3 */\n    /* COMMENT_4 */\n    /* COMMENT_5 */\n    if (VAR_0->t.meta.flags & ((uint64_t)1 << 48)) {\n        VAR_0->noreply = true;\n    }\n\n    return 0;\n}",
  "func_graph_path": "memcached/6987918e9a3094ec4fc8976f01f769f624d790fa/proxy_request.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -4,7 +4,7 @@\n         return 0;\n     }\n     const char *cur = pr->request + pr->tokens[token];\n-    const char *end = pr->request + pr->reqlen - 2;\n+    const char *end = pr->request + pr->endlen;\n \n     // We blindly convert flags into bits, since the range of possible\n     // flags is deliberately < 64.",
  "diff_line_info": {
    "deleted_lines": [
      "    const char *end = pr->request + pr->reqlen - 2;"
    ],
    "added_lines": [
      "    const char *end = pr->request + pr->endlen;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/memcached/memcached/pull/1063",
  "description": {
    "pr_info": {
      "title": "proxy: fix off-by-one if \\r is missing",
      "number": 1063
    },
    "comment": [
      "A bunch of the parser assumed we only had \\r\\n, but I didn't actually have that strictness set. Some commands worked and some broke in subtle ways when just \"\\n\" was being submitted.\r\n\r\nI'm not 100% confident in this change yet so I'm opening a PR to stage it while I run some more thorough tests.",
      "running the stability suite on it now too.",
      "okay I'm good with this now. it's passed half the stability suite while I stepped through the code in a debugger.. so it's run through the multiget tests several times now."
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.9"
}