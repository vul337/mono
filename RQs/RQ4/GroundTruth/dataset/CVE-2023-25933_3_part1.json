{
  "cve_id": "CVE-2023-25933",
  "cwe_ids": [
    "CWE-416",
    "CWE-843"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "facebook/hermes",
  "commit_msg": "Re-sync with internal repository (#960)\n\nCo-authored-by: Facebook Community Bot <6422482+facebook-github-bot@users.noreply.github.com>",
  "commit_hash": "e6ed9c1a4b02dc219de1648f44cd808a56171b81",
  "git_url": "https://github.com/facebook/hermes/commit/e6ed9c1a4b02dc219de1648f44cd808a56171b81",
  "file_path": "lib/VM/JSLib/TypedArray.cpp",
  "func_name": "typedArrayPrototypeAt",
  "func_before": "CallResult<HermesValue>\ntypedArrayPrototypeAt(void *, Runtime &runtime, NativeArgs args) {\n  // 1. Let O be the this value.\n  // 2. Perform ? ValidateTypedArray(O).\n  if (LLVM_UNLIKELY(\n          JSTypedArrayBase::validateTypedArray(\n              runtime, args.getThisHandle(), true) ==\n          ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  GCScope gcScope{runtime};\n\n  auto O = args.vmcastThis<JSTypedArrayBase>();\n\n  // 3. Let len be O.[[ArrayLength]].\n  // The this object‚Äôs [[ArrayLength]] internal slot is accessed in place of\n  // performing a [[Get]] of \"length\".\n  double len = O->getLength();\n\n  // 4. Let relativeIndex be ? ToIntegerOrInfinity(index).\n  auto idx = args.getArgHandle(0);\n  auto relativeIndexRes = toIntegerOrInfinity(runtime, idx);\n  if (relativeIndexRes == ExecutionStatus::EXCEPTION) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  const double relativeIndex = relativeIndexRes->getNumber();\n\n  double k;\n  // 5. If relativeIndex ‚â• 0, then\n  if (relativeIndex >= 0) {\n    // a. Let k be relativeIndex.\n    k = relativeIndex;\n  } else {\n    // 6. Else,\n    // a. Let k be len + relativeIndex.\n    k = len + relativeIndex;\n  }\n\n  // 7. If k < 0 or k ‚â• len, return undefined.\n  if (k < 0 || k >= len) {\n    return HermesValue::encodeUndefinedValue();\n  }\n\n  // 8. Return ? Get(O, ! ToString(ùîΩ(k))).\n  // Since we know we have a TypedArray, we can directly call JSTypedArray::at\n  // rather than getComputed_RJS like the spec mandates.\n#define TYPED_ARRAY(name, type)                                            \\\n  case CellKind::name##ArrayKind: {                                        \\\n    auto *arr = vmcast<JSTypedArray<type, CellKind::name##ArrayKind>>(*O); \\\n    if (!arr->attached(runtime)) {                                         \\\n      return runtime.raiseTypeError(\"Underlying ArrayBuffer detached\");    \\\n    }                                                                      \\\n    return HermesValue::encodeNumberValue(arr->at(runtime, k));            \\\n  }\n  switch (O->getKind()) {\n#include \"hermes/VM/TypedArrays.def\"\n    default:\n      llvm_unreachable(\"Invalid TypedArray after ValidateTypedArray call\");\n  }\n}",
  "abstract_func_before": "CallResult<HermesValue>\ntypedArrayPrototypeAt(void *, Runtime &VAR_0, NativeArgs VAR_1) {\n  /* COMMENT_0 */\n  /* COMMENT_1 */\n  if (LLVM_UNLIKELY(\n          JSTypedArrayBase::validateTypedArray(\n              VAR_0, VAR_1.getThisHandle(), true) ==\n          ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  GCScope VAR_2{VAR_0};\n\n  auto VAR_3 = VAR_1.vmcastThis<JSTypedArrayBase>();\n\n  /* COMMENT_2 */\n  /* COMMENT_3 */\n  /* COMMENT_4 */\n  double VAR_4 = VAR_3->getLength();\n\n  /* COMMENT_5 */\n  auto VAR_5 = VAR_1.getArgHandle(0);\n  auto VAR_6 = toIntegerOrInfinity(VAR_0, VAR_5);\n  if (VAR_6 == ExecutionStatus::EXCEPTION) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  const double VAR_7 = VAR_6->getNumber();\n\n  double VAR_8;\n  /* COMMENT_6 */\n  if (VAR_7 >= 0) {\n    /* COMMENT_7 */\n    VAR_8 = VAR_7;\n  } else {\n    /* COMMENT_8 */\n    /* COMMENT_9 */\n    VAR_8 = VAR_4 + VAR_7;\n  }\n\n  /* COMMENT_10 */\n  if (VAR_8 < 0 || VAR_8 >= VAR_4) {\n    return HermesValue::encodeUndefinedValue();\n  }\n\n  /* COMMENT_11 */\n  /* COMMENT_12 */\n  /* COMMENT_13 */\n#define TYPED_ARRAY(VAR_9, VAR_10)                                            \\\n  case CellKind::name##ArrayKind: {                                        \\\n    auto *arr = vmcast<JSTypedArray<type, CellKind::name##ArrayKind>>(*O); \\\n    if (!arr->attached(runtime)) {                                         \\\n      return runtime.raiseTypeError(\"Underlying ArrayBuffer detached\");    \\\n    }                                                                      \\\n    return HermesValue::encodeNumberValue(arr->at(runtime, k));            \\\n  }\n  switch (VAR_3->getKind()) {\n#include \"hermes/VM/TypedArrays.def\"\n    default:\n      llvm_unreachable(\"Invalid TypedArray after ValidateTypedArray call\");\n  }\n}",
  "func_graph_path_before": "facebook/hermes/e6ed9c1a4b02dc219de1648f44cd808a56171b81/TypedArray.cpp/vul/before/0.json",
  "func": "CallResult<HermesValue>\ntypedArrayPrototypeAt(void *, Runtime &runtime, NativeArgs args) {\n  // 1. Let O be the this value.\n  // 2. Perform ? ValidateTypedArray(O).\n  if (LLVM_UNLIKELY(\n          JSTypedArrayBase::validateTypedArray(\n              runtime, args.getThisHandle(), true) ==\n          ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  GCScope gcScope{runtime};\n\n  auto O = args.vmcastThis<JSTypedArrayBase>();\n\n  // 3. Let len be O.[[ArrayLength]].\n  // The this object‚Äôs [[ArrayLength]] internal slot is accessed in place of\n  // performing a [[Get]] of \"length\".\n  double len = O->getLength();\n\n  // 4. Let relativeIndex be ? ToIntegerOrInfinity(index).\n  auto idx = args.getArgHandle(0);\n  auto relativeIndexRes = toIntegerOrInfinity(runtime, idx);\n  if (relativeIndexRes == ExecutionStatus::EXCEPTION) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  const double relativeIndex = relativeIndexRes->getNumber();\n\n  double k;\n  // 5. If relativeIndex ‚â• 0, then\n  if (relativeIndex >= 0) {\n    // a. Let k be relativeIndex.\n    k = relativeIndex;\n  } else {\n    // 6. Else,\n    // a. Let k be len + relativeIndex.\n    k = len + relativeIndex;\n  }\n\n  // 7. If k < 0 or k ‚â• len, return undefined.\n  if (k < 0 || k >= len) {\n    return HermesValue::encodeUndefinedValue();\n  }\n\n  // 8. Return ? Get(O, ! ToString(ùîΩ(k))).\n  // Since we know we have a TypedArray, we can directly call JSTypedArray::at\n  // rather than getComputed_RJS like the spec mandates.\n#define TYPED_ARRAY(name, type)                                            \\\n  case CellKind::name##ArrayKind: {                                        \\\n    auto *arr = vmcast<JSTypedArray<type, CellKind::name##ArrayKind>>(*O); \\\n    if (!arr->attached(runtime)) {                                         \\\n      return runtime.raiseTypeError(\"Underlying ArrayBuffer detached\");    \\\n    }                                                                      \\\n    return HermesValue::encodeUntrustedNumberValue(arr->at(runtime, k));   \\\n  }\n  switch (O->getKind()) {\n#include \"hermes/VM/TypedArrays.def\"\n    default:\n      llvm_unreachable(\"Invalid TypedArray after ValidateTypedArray call\");\n  }\n}",
  "abstract_func": "CallResult<HermesValue>\ntypedArrayPrototypeAt(void *, Runtime &VAR_0, NativeArgs VAR_1) {\n  /* COMMENT_0 */\n  /* COMMENT_1 */\n  if (LLVM_UNLIKELY(\n          JSTypedArrayBase::validateTypedArray(\n              VAR_0, VAR_1.getThisHandle(), true) ==\n          ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  GCScope VAR_2{VAR_0};\n\n  auto VAR_3 = VAR_1.vmcastThis<JSTypedArrayBase>();\n\n  /* COMMENT_2 */\n  /* COMMENT_3 */\n  /* COMMENT_4 */\n  double VAR_4 = VAR_3->getLength();\n\n  /* COMMENT_5 */\n  auto VAR_5 = VAR_1.getArgHandle(0);\n  auto VAR_6 = toIntegerOrInfinity(VAR_0, VAR_5);\n  if (VAR_6 == ExecutionStatus::EXCEPTION) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  const double VAR_7 = VAR_6->getNumber();\n\n  double VAR_8;\n  /* COMMENT_6 */\n  if (VAR_7 >= 0) {\n    /* COMMENT_7 */\n    VAR_8 = VAR_7;\n  } else {\n    /* COMMENT_8 */\n    /* COMMENT_9 */\n    VAR_8 = VAR_4 + VAR_7;\n  }\n\n  /* COMMENT_10 */\n  if (VAR_8 < 0 || VAR_8 >= VAR_4) {\n    return HermesValue::encodeUndefinedValue();\n  }\n\n  /* COMMENT_11 */\n  /* COMMENT_12 */\n  /* COMMENT_13 */\n#define TYPED_ARRAY(VAR_9, VAR_10)                                            \\\n  case CellKind::name##ArrayKind: {                                        \\\n    auto *arr = vmcast<JSTypedArray<type, CellKind::name##ArrayKind>>(*O); \\\n    if (!arr->attached(runtime)) {                                         \\\n      return runtime.raiseTypeError(\"Underlying ArrayBuffer detached\");    \\\n    }                                                                      \\\n    return HermesValue::encodeUntrustedNumberValue(arr->at(runtime, k));   \\\n  }\n  switch (VAR_3->getKind()) {\n#include \"hermes/VM/TypedArrays.def\"\n    default:\n      llvm_unreachable(\"Invalid TypedArray after ValidateTypedArray call\");\n  }\n}",
  "func_graph_path": "facebook/hermes/e6ed9c1a4b02dc219de1648f44cd808a56171b81/TypedArray.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -50,7 +50,7 @@\n     if (!arr->attached(runtime)) {                                         \\\n       return runtime.raiseTypeError(\"Underlying ArrayBuffer detached\");    \\\n     }                                                                      \\\n-    return HermesValue::encodeNumberValue(arr->at(runtime, k));            \\\n+    return HermesValue::encodeUntrustedNumberValue(arr->at(runtime, k));   \\\n   }\n   switch (O->getKind()) {\n #include \"hermes/VM/TypedArrays.def\"",
  "diff_line_info": {
    "deleted_lines": [
      "    return HermesValue::encodeNumberValue(arr->at(runtime, k));            \\"
    ],
    "added_lines": [
      "    return HermesValue::encodeUntrustedNumberValue(arr->at(runtime, k));   \\"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/facebook/hermes/pull/960",
  "description": {
    "pr_info": {
      "title": "Re-sync with internal repository",
      "number": 960
    },
    "comment": [
      "The internal and external repositories are out of sync. This attempts to brings them back in sync by patching the GitHub repository. Please carefully review this patch. You must disable ShipIt for your project in order to merge this pull request. DO NOT IMPORT this pull request. Instead, merge it directly on GitHub using the MERGE BUTTON. Re-enable ShipIt after merging."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.6,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.6\n\nThe commit addresses a code change that modifies how numbers are encoded, specifically using an \"untrusted\" method, suggesting a security enhancement. While the commit message doesn't explicitly mention security, the code change implies a security fix, though the confidence is moderate due to the lack of explicit references."
}