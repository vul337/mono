{
  "cve_id": "CVE-2022-0367",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "stephane/libmodbus",
  "commit_msg": "modbus_reply: fix copy & paste error in sanity check (fixes #614)\n\nWhile handling MODBUS_FC_WRITE_AND_READ_REGISTERS, both address offsets\nmust be checked, i.e. the read and the write address must be within the\nmapping range.\n\nAt the moment, only the read address was considered, it looks like a\nsimple copy and paste error, so let's fix it.\n\nSigned-off-by: Michael Heimpold <mhei@heimpold.de>",
  "commit_hash": "b4ef4c17d618eba0adccc4c7d9e9a1ef809fc9b6",
  "git_url": "https://github.com/stephane/libmodbus/commit/b4ef4c17d618eba0adccc4c7d9e9a1ef809fc9b6",
  "file_path": "src/modbus.c",
  "func_name": "modbus_reply",
  "func_before": "int modbus_reply(modbus_t *ctx, const uint8_t *req,\n                 int req_length, modbus_mapping_t *mb_mapping)\n{\n    int offset;\n    int slave;\n    int function;\n    uint16_t address;\n    uint8_t rsp[MAX_MESSAGE_LENGTH];\n    int rsp_length = 0;\n    sft_t sft;\n\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    offset = ctx->backend->header_length;\n    slave = req[offset - 1];\n    function = req[offset];\n    address = (req[offset + 1] << 8) + req[offset + 2];\n\n    sft.slave = slave;\n    sft.function = function;\n    sft.t_id = ctx->backend->prepare_response_tid(req, &req_length);\n\n    /* Data are flushed on illegal number of values errors. */\n    switch (function) {\n    case MODBUS_FC_READ_COILS:\n    case MODBUS_FC_READ_DISCRETE_INPUTS: {\n        unsigned int is_input = (function == MODBUS_FC_READ_DISCRETE_INPUTS);\n        int start_bits = is_input ? mb_mapping->start_input_bits : mb_mapping->start_bits;\n        int nb_bits = is_input ? mb_mapping->nb_input_bits : mb_mapping->nb_bits;\n        uint8_t *tab_bits = is_input ? mb_mapping->tab_input_bits : mb_mapping->tab_bits;\n        const char * const name = is_input ? \"read_input_bits\" : \"read_bits\";\n        int nb = (req[offset + 3] << 8) + req[offset + 4];\n        /* The mapping can be shifted to reduce memory consumption and it\n           doesn't always start at address zero. */\n        int mapping_address = address - start_bits;\n\n        if (nb < 1 || MODBUS_MAX_READ_BITS < nb) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,\n                \"Illegal nb of values %d in %s (max %d)\\n\",\n                nb, name, MODBUS_MAX_READ_BITS);\n        } else if (mapping_address < 0 || (mapping_address + nb) > nb_bits) {\n            rsp_length = response_exception(\n                ctx, &sft,\n                MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data address 0x%0X in %s\\n\",\n                mapping_address < 0 ? address : address + nb, name);\n        } else {\n            rsp_length = ctx->backend->build_response_basis(&sft, rsp);\n            rsp[rsp_length++] = (nb / 8) + ((nb % 8) ? 1 : 0);\n            rsp_length = response_io_status(tab_bits, mapping_address, nb,\n                                            rsp, rsp_length);\n        }\n    }\n        break;\n    case MODBUS_FC_READ_HOLDING_REGISTERS:\n    case MODBUS_FC_READ_INPUT_REGISTERS: {\n        unsigned int is_input = (function == MODBUS_FC_READ_INPUT_REGISTERS);\n        int start_registers = is_input ? mb_mapping->start_input_registers : mb_mapping->start_registers;\n        int nb_registers = is_input ? mb_mapping->nb_input_registers : mb_mapping->nb_registers;\n        uint16_t *tab_registers = is_input ? mb_mapping->tab_input_registers : mb_mapping->tab_registers;\n        const char * const name = is_input ? \"read_input_registers\" : \"read_registers\";\n        int nb = (req[offset + 3] << 8) + req[offset + 4];\n        /* The mapping can be shifted to reduce memory consumption and it\n           doesn't always start at address zero. */\n        int mapping_address = address - start_registers;\n\n        if (nb < 1 || MODBUS_MAX_READ_REGISTERS < nb) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,\n                \"Illegal nb of values %d in %s (max %d)\\n\",\n                nb, name, MODBUS_MAX_READ_REGISTERS);\n        } else if (mapping_address < 0 || (mapping_address + nb) > nb_registers) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data address 0x%0X in %s\\n\",\n                mapping_address < 0 ? address : address + nb, name);\n        } else {\n            int i;\n\n            rsp_length = ctx->backend->build_response_basis(&sft, rsp);\n            rsp[rsp_length++] = nb << 1;\n            for (i = mapping_address; i < mapping_address + nb; i++) {\n                rsp[rsp_length++] = tab_registers[i] >> 8;\n                rsp[rsp_length++] = tab_registers[i] & 0xFF;\n            }\n        }\n    }\n        break;\n    case MODBUS_FC_WRITE_SINGLE_COIL: {\n        int mapping_address = address - mb_mapping->start_bits;\n\n        if (mapping_address < 0 || mapping_address >= mb_mapping->nb_bits) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data address 0x%0X in write_bit\\n\",\n                address);\n        } else {\n            int data = (req[offset + 3] << 8) + req[offset + 4];\n\n            if (data == 0xFF00 || data == 0x0) {\n                mb_mapping->tab_bits[mapping_address] = data ? ON : OFF;\n                memcpy(rsp, req, req_length);\n                rsp_length = req_length;\n            } else {\n                rsp_length = response_exception(\n                    ctx, &sft,\n                    MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, FALSE,\n                    \"Illegal data value 0x%0X in write_bit request at address %0X\\n\",\n                    data, address);\n            }\n        }\n    }\n        break;\n    case MODBUS_FC_WRITE_SINGLE_REGISTER: {\n        int mapping_address = address - mb_mapping->start_registers;\n\n        if (mapping_address < 0 || mapping_address >= mb_mapping->nb_registers) {\n            rsp_length = response_exception(\n                ctx, &sft,\n                MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data address 0x%0X in write_register\\n\",\n                address);\n        } else {\n            int data = (req[offset + 3] << 8) + req[offset + 4];\n\n            mb_mapping->tab_registers[mapping_address] = data;\n            memcpy(rsp, req, req_length);\n            rsp_length = req_length;\n        }\n    }\n        break;\n    case MODBUS_FC_WRITE_MULTIPLE_COILS: {\n        int nb = (req[offset + 3] << 8) + req[offset + 4];\n        int nb_bits = req[offset + 5];\n        int mapping_address = address - mb_mapping->start_bits;\n\n        if (nb < 1 || MODBUS_MAX_WRITE_BITS < nb || nb_bits * 8 < nb) {\n            /* May be the indication has been truncated on reading because of\n             * invalid address (eg. nb is 0 but the request contains values to\n             * write) so it's necessary to flush. */\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,\n                \"Illegal number of values %d in write_bits (max %d)\\n\",\n                nb, MODBUS_MAX_WRITE_BITS);\n        } else if (mapping_address < 0 ||\n                   (mapping_address + nb) > mb_mapping->nb_bits) {\n            rsp_length = response_exception(\n                ctx, &sft,\n                MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data address 0x%0X in write_bits\\n\",\n                mapping_address < 0 ? address : address + nb);\n        } else {\n            /* 6 = byte count */\n            modbus_set_bits_from_bytes(mb_mapping->tab_bits, mapping_address, nb,\n                                       &req[offset + 6]);\n\n            rsp_length = ctx->backend->build_response_basis(&sft, rsp);\n            /* 4 to copy the bit address (2) and the quantity of bits */\n            memcpy(rsp + rsp_length, req + rsp_length, 4);\n            rsp_length += 4;\n        }\n    }\n        break;\n    case MODBUS_FC_WRITE_MULTIPLE_REGISTERS: {\n        int nb = (req[offset + 3] << 8) + req[offset + 4];\n        int nb_bytes = req[offset + 5];\n        int mapping_address = address - mb_mapping->start_registers;\n\n        if (nb < 1 || MODBUS_MAX_WRITE_REGISTERS < nb || nb_bytes != nb * 2) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,\n                \"Illegal number of values %d in write_registers (max %d)\\n\",\n                nb, MODBUS_MAX_WRITE_REGISTERS);\n        } else if (mapping_address < 0 ||\n                   (mapping_address + nb) > mb_mapping->nb_registers) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data address 0x%0X in write_registers\\n\",\n                mapping_address < 0 ? address : address + nb);\n        } else {\n            int i, j;\n            for (i = mapping_address, j = 6; i < mapping_address + nb; i++, j += 2) {\n                /* 6 and 7 = first value */\n                mb_mapping->tab_registers[i] =\n                    (req[offset + j] << 8) + req[offset + j + 1];\n            }\n\n            rsp_length = ctx->backend->build_response_basis(&sft, rsp);\n            /* 4 to copy the address (2) and the no. of registers */\n            memcpy(rsp + rsp_length, req + rsp_length, 4);\n            rsp_length += 4;\n        }\n    }\n        break;\n    case MODBUS_FC_REPORT_SLAVE_ID: {\n        int str_len;\n        int byte_count_pos;\n\n        rsp_length = ctx->backend->build_response_basis(&sft, rsp);\n        /* Skip byte count for now */\n        byte_count_pos = rsp_length++;\n        rsp[rsp_length++] = _REPORT_SLAVE_ID;\n        /* Run indicator status to ON */\n        rsp[rsp_length++] = 0xFF;\n        /* LMB + length of LIBMODBUS_VERSION_STRING */\n        str_len = 3 + strlen(LIBMODBUS_VERSION_STRING);\n        memcpy(rsp + rsp_length, \"LMB\" LIBMODBUS_VERSION_STRING, str_len);\n        rsp_length += str_len;\n        rsp[byte_count_pos] = rsp_length - byte_count_pos - 1;\n    }\n        break;\n    case MODBUS_FC_READ_EXCEPTION_STATUS:\n        if (ctx->debug) {\n            fprintf(stderr, \"FIXME Not implemented\\n\");\n        }\n        errno = ENOPROTOOPT;\n        return -1;\n        break;\n    case MODBUS_FC_MASK_WRITE_REGISTER: {\n        int mapping_address = address - mb_mapping->start_registers;\n\n        if (mapping_address < 0 || mapping_address >= mb_mapping->nb_registers) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data address 0x%0X in write_register\\n\",\n                address);\n        } else {\n            uint16_t data = mb_mapping->tab_registers[mapping_address];\n            uint16_t and = (req[offset + 3] << 8) + req[offset + 4];\n            uint16_t or = (req[offset + 5] << 8) + req[offset + 6];\n\n            data = (data & and) | (or & (~and));\n            mb_mapping->tab_registers[mapping_address] = data;\n            memcpy(rsp, req, req_length);\n            rsp_length = req_length;\n        }\n    }\n        break;\n    case MODBUS_FC_WRITE_AND_READ_REGISTERS: {\n        int nb = (req[offset + 3] << 8) + req[offset + 4];\n        uint16_t address_write = (req[offset + 5] << 8) + req[offset + 6];\n        int nb_write = (req[offset + 7] << 8) + req[offset + 8];\n        int nb_write_bytes = req[offset + 9];\n        int mapping_address = address - mb_mapping->start_registers;\n        int mapping_address_write = address_write - mb_mapping->start_registers;\n\n        if (nb_write < 1 || MODBUS_MAX_WR_WRITE_REGISTERS < nb_write ||\n            nb < 1 || MODBUS_MAX_WR_READ_REGISTERS < nb ||\n            nb_write_bytes != nb_write * 2) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,\n                \"Illegal nb of values (W%d, R%d) in write_and_read_registers (max W%d, R%d)\\n\",\n                nb_write, nb, MODBUS_MAX_WR_WRITE_REGISTERS, MODBUS_MAX_WR_READ_REGISTERS);\n        } else if (mapping_address < 0 ||\n                   (mapping_address + nb) > mb_mapping->nb_registers ||\n                   mapping_address < 0 ||\n                   (mapping_address_write + nb_write) > mb_mapping->nb_registers) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data read address 0x%0X or write address 0x%0X write_and_read_registers\\n\",\n                mapping_address < 0 ? address : address + nb,\n                mapping_address_write < 0 ? address_write : address_write + nb_write);\n        } else {\n            int i, j;\n            rsp_length = ctx->backend->build_response_basis(&sft, rsp);\n            rsp[rsp_length++] = nb << 1;\n\n            /* Write first.\n               10 and 11 are the offset of the first values to write */\n            for (i = mapping_address_write, j = 10;\n                 i < mapping_address_write + nb_write; i++, j += 2) {\n                mb_mapping->tab_registers[i] =\n                    (req[offset + j] << 8) + req[offset + j + 1];\n            }\n\n            /* and read the data for the response */\n            for (i = mapping_address; i < mapping_address + nb; i++) {\n                rsp[rsp_length++] = mb_mapping->tab_registers[i] >> 8;\n                rsp[rsp_length++] = mb_mapping->tab_registers[i] & 0xFF;\n            }\n        }\n    }\n        break;\n\n    default:\n        rsp_length = response_exception(\n            ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_FUNCTION, rsp, TRUE,\n            \"Unknown Modbus function code: 0x%0X\\n\", function);\n        break;\n    }\n\n    /* Suppress any responses when the request was a broadcast */\n    return (ctx->backend->backend_type == _MODBUS_BACKEND_TYPE_RTU &&\n            slave == MODBUS_BROADCAST_ADDRESS) ? 0 : send_msg(ctx, rsp, rsp_length);\n}",
  "abstract_func_before": "int modbus_reply(modbus_t *VAR_0, const uint8_t *VAR_1,\n                 int VAR_2, modbus_mapping_t *VAR_3)\n{\n    int VAR_4;\n    int VAR_5;\n    int VAR_6;\n    uint16_t VAR_7;\n    uint8_t VAR_8[VAR_9];\n    int VAR_10 = 0;\n    sft_t VAR_11;\n\n    if (VAR_0 == NULL) {\n        VAR_12 = VAR_13;\n        return -1;\n    }\n\n    VAR_4 = VAR_0->backend->header_length;\n    VAR_5 = VAR_1[VAR_4 - 1];\n    VAR_6 = VAR_1[VAR_4];\n    VAR_7 = (VAR_1[VAR_4 + 1] << 8) + VAR_1[VAR_4 + 2];\n\n    VAR_11.slave = VAR_5;\n    VAR_11.function = VAR_6;\n    VAR_11.t_id = VAR_0->backend->prepare_response_tid(VAR_1, &VAR_2);\n\n    /* COMMENT_0 */\n    switch (VAR_6) {\n    case VAR_14:\n    case VAR_15: {\n        unsigned int VAR_16 = (VAR_6 == VAR_15);\n        int VAR_17 = VAR_16 ? VAR_3->start_input_bits : VAR_3->start_bits;\n        int VAR_18 = VAR_16 ? VAR_3->nb_input_bits : VAR_3->nb_bits;\n        uint8_t *VAR_19 = VAR_16 ? VAR_3->tab_input_bits : VAR_3->tab_bits;\n        const char * const VAR_20 = VAR_16 ? \"read_input_bits\" : \"read_bits\";\n        int VAR_21 = (VAR_1[VAR_4 + 3] << 8) + VAR_1[VAR_4 + 4];\n        /* COMMENT_1 */\n                                                   \n        int VAR_22 = VAR_7 - VAR_17;\n\n        if (VAR_21 < 1 || VAR_23 < VAR_21) {\n            VAR_10 = response_exception(\n                VAR_0, &VAR_11, VAR_24, VAR_8, TRUE,\n                \"Illegal nb of values %d in %s (max %d)\\n\",\n                VAR_21, VAR_20, VAR_23);\n        } else if (VAR_22 < 0 || (VAR_22 + VAR_21) > VAR_18) {\n            VAR_10 = response_exception(\n                VAR_0, &VAR_11,\n                VAR_25, VAR_8, FALSE,\n                \"Illegal data address 0x%0X in %s\\n\",\n                VAR_22 < 0 ? VAR_7 : VAR_7 + VAR_21, VAR_20);\n        } else {\n            VAR_10 = VAR_0->backend->build_response_basis(&VAR_11, VAR_8);\n            VAR_8[VAR_10++] = (VAR_21 / 8) + ((VAR_21 % 8) ? 1 : 0);\n            VAR_10 = response_io_status(VAR_19, VAR_22, VAR_21,\n                                            VAR_8, VAR_10);\n        }\n    }\n        break;\n    case VAR_26:\n    case VAR_27: {\n        unsigned int VAR_16 = (VAR_6 == VAR_27);\n        int VAR_28 = VAR_16 ? VAR_3->start_input_registers : VAR_3->start_registers;\n        int VAR_29 = VAR_16 ? VAR_3->nb_input_registers : VAR_3->nb_registers;\n        uint16_t *VAR_30 = VAR_16 ? VAR_3->tab_input_registers : VAR_3->tab_registers;\n        const char * const VAR_20 = VAR_16 ? \"read_input_registers\" : \"read_registers\";\n        int VAR_21 = (VAR_1[VAR_4 + 3] << 8) + VAR_1[VAR_4 + 4];\n        /* COMMENT_3 */\n                                                   \n        int VAR_22 = VAR_7 - VAR_28;\n\n        if (VAR_21 < 1 || VAR_31 < VAR_21) {\n            VAR_10 = response_exception(\n                VAR_0, &VAR_11, VAR_24, VAR_8, TRUE,\n                \"Illegal nb of values %d in %s (max %d)\\n\",\n                VAR_21, VAR_20, VAR_31);\n        } else if (VAR_22 < 0 || (VAR_22 + VAR_21) > VAR_29) {\n            VAR_10 = response_exception(\n                VAR_0, &VAR_11, VAR_25, VAR_8, FALSE,\n                \"Illegal data address 0x%0X in %s\\n\",\n                VAR_22 < 0 ? VAR_7 : VAR_7 + VAR_21, VAR_20);\n        } else {\n            int VAR_32;\n\n            VAR_10 = VAR_0->backend->build_response_basis(&VAR_11, VAR_8);\n            VAR_8[VAR_10++] = VAR_21 << 1;\n            for (VAR_32 = VAR_22; VAR_32 < VAR_22 + VAR_21; VAR_32++) {\n                VAR_8[VAR_10++] = VAR_30[VAR_32] >> 8;\n                VAR_8[VAR_10++] = VAR_30[VAR_32] & 0xFF;\n            }\n        }\n    }\n        break;\n    case VAR_33: {\n        int VAR_22 = VAR_7 - VAR_3->start_bits;\n\n        if (VAR_22 < 0 || VAR_22 >= VAR_3->nb_bits) {\n            VAR_10 = response_exception(\n                VAR_0, &VAR_11, VAR_25, VAR_8, FALSE,\n                \"Illegal data address 0x%0X in write_bit\\n\",\n                VAR_7);\n        } else {\n            int VAR_34 = (VAR_1[VAR_4 + 3] << 8) + VAR_1[VAR_4 + 4];\n\n            if (VAR_34 == 0xFF00 || VAR_34 == 0x0) {\n                VAR_3->tab_bits[VAR_22] = VAR_34 ? VAR_35 : VAR_36;\n                memcpy(VAR_8, VAR_1, VAR_2);\n                VAR_10 = VAR_2;\n            } else {\n                VAR_10 = response_exception(\n                    VAR_0, &VAR_11,\n                    VAR_24, VAR_8, FALSE,\n                    \"Illegal data value 0x%0X in write_bit request at address %0X\\n\",\n                    VAR_34, VAR_7);\n            }\n        }\n    }\n        break;\n    case VAR_37: {\n        int VAR_22 = VAR_7 - VAR_3->start_registers;\n\n        if (VAR_22 < 0 || VAR_22 >= VAR_3->nb_registers) {\n            VAR_10 = response_exception(\n                VAR_0, &VAR_11,\n                VAR_25, VAR_8, FALSE,\n                \"Illegal data address 0x%0X in write_register\\n\",\n                VAR_7);\n        } else {\n            int VAR_34 = (VAR_1[VAR_4 + 3] << 8) + VAR_1[VAR_4 + 4];\n\n            VAR_3->tab_registers[VAR_22] = VAR_34;\n            memcpy(VAR_8, VAR_1, VAR_2);\n            VAR_10 = VAR_2;\n        }\n    }\n        break;\n    case VAR_38: {\n        int VAR_21 = (VAR_1[VAR_4 + 3] << 8) + VAR_1[VAR_4 + 4];\n        int VAR_18 = VAR_1[VAR_4 + 5];\n        int VAR_22 = VAR_7 - VAR_3->start_bits;\n\n        if (VAR_21 < 1 || VAR_39 < VAR_21 || VAR_18 * 8 < VAR_21) {\n            /* COMMENT_5 */\n                                                                              \n                                                    \n            VAR_10 = response_exception(\n                VAR_0, &VAR_11, VAR_24, VAR_8, TRUE,\n                \"Illegal number of values %d in write_bits (max %d)\\n\",\n                VAR_21, VAR_39);\n        } else if (VAR_22 < 0 ||\n                   (VAR_22 + VAR_21) > VAR_3->nb_bits) {\n            VAR_10 = response_exception(\n                VAR_0, &VAR_11,\n                VAR_25, VAR_8, FALSE,\n                \"Illegal data address 0x%0X in write_bits\\n\",\n                VAR_22 < 0 ? VAR_7 : VAR_7 + VAR_21);\n        } else {\n            /* COMMENT_8 */\n            modbus_set_bits_from_bytes(VAR_3->tab_bits, VAR_22, VAR_21,\n                                       &VAR_1[VAR_4 + 6]);\n\n            VAR_10 = VAR_0->backend->build_response_basis(&VAR_11, VAR_8);\n            /* COMMENT_9 */\n            memcpy(VAR_8 + VAR_10, VAR_1 + VAR_10, 4);\n            VAR_10 += 4;\n        }\n    }\n        break;\n    case VAR_40: {\n        int VAR_21 = (VAR_1[VAR_4 + 3] << 8) + VAR_1[VAR_4 + 4];\n        int VAR_41 = VAR_1[VAR_4 + 5];\n        int VAR_22 = VAR_7 - VAR_3->start_registers;\n\n        if (VAR_21 < 1 || VAR_42 < VAR_21 || VAR_41 != VAR_21 * 2) {\n            VAR_10 = response_exception(\n                VAR_0, &VAR_11, VAR_24, VAR_8, TRUE,\n                \"Illegal number of values %d in write_registers (max %d)\\n\",\n                VAR_21, VAR_42);\n        } else if (VAR_22 < 0 ||\n                   (VAR_22 + VAR_21) > VAR_3->nb_registers) {\n            VAR_10 = response_exception(\n                VAR_0, &VAR_11, VAR_25, VAR_8, FALSE,\n                \"Illegal data address 0x%0X in write_registers\\n\",\n                VAR_22 < 0 ? VAR_7 : VAR_7 + VAR_21);\n        } else {\n            int VAR_32, VAR_43;\n            for (VAR_32 = VAR_22, VAR_43 = 6; VAR_32 < VAR_22 + VAR_21; VAR_32++, VAR_43 += 2) {\n                /* COMMENT_10 */\n                VAR_3->tab_registers[VAR_32] =\n                    (VAR_1[VAR_4 + VAR_43] << 8) + VAR_1[VAR_4 + VAR_43 + 1];\n            }\n\n            VAR_10 = VAR_0->backend->build_response_basis(&VAR_11, VAR_8);\n            /* COMMENT_11 */\n            memcpy(VAR_8 + VAR_10, VAR_1 + VAR_10, 4);\n            VAR_10 += 4;\n        }\n    }\n        break;\n    case VAR_44: {\n        int VAR_45;\n        int VAR_46;\n\n        VAR_10 = VAR_0->backend->build_response_basis(&VAR_11, VAR_8);\n        /* COMMENT_12 */\n        VAR_46 = VAR_10++;\n        VAR_8[VAR_10++] = VAR_47;\n        /* COMMENT_13 */\n        VAR_8[VAR_10++] = 0xFF;\n        /* COMMENT_14 */\n        VAR_45 = 3 + strlen(VAR_48);\n        memcpy(VAR_8 + VAR_10, \"LMB\" VAR_48, VAR_45);\n        VAR_10 += VAR_45;\n        VAR_8[VAR_46] = VAR_10 - VAR_46 - 1;\n    }\n        break;\n    case VAR_49:\n        if (VAR_0->debug) {\n            fprintf(VAR_50, \"FIXME Not implemented\\n\");\n        }\n        VAR_12 = VAR_51;\n        return -1;\n        break;\n    case VAR_52: {\n        int VAR_22 = VAR_7 - VAR_3->start_registers;\n\n        if (VAR_22 < 0 || VAR_22 >= VAR_3->nb_registers) {\n            VAR_10 = response_exception(\n                VAR_0, &VAR_11, VAR_25, VAR_8, FALSE,\n                \"Illegal data address 0x%0X in write_register\\n\",\n                VAR_7);\n        } else {\n            uint16_t VAR_34 = VAR_3->tab_registers[VAR_22];\n            uint16_t VAR_53 = (VAR_1[VAR_4 + 3] << 8) + VAR_1[VAR_4 + 4];\n            uint16_t VAR_54 = (VAR_1[VAR_4 + 5] << 8) + VAR_1[VAR_4 + 6];\n\n            VAR_34 = (VAR_34 & VAR_53) | (VAR_54 & (~VAR_53));\n            VAR_3->tab_registers[VAR_22] = VAR_34;\n            memcpy(VAR_8, VAR_1, VAR_2);\n            VAR_10 = VAR_2;\n        }\n    }\n        break;\n    case VAR_55: {\n        int VAR_21 = (VAR_1[VAR_4 + 3] << 8) + VAR_1[VAR_4 + 4];\n        uint16_t VAR_56 = (VAR_1[VAR_4 + 5] << 8) + VAR_1[VAR_4 + 6];\n        int VAR_57 = (VAR_1[VAR_4 + 7] << 8) + VAR_1[VAR_4 + 8];\n        int VAR_58 = VAR_1[VAR_4 + 9];\n        int VAR_22 = VAR_7 - VAR_3->start_registers;\n        int VAR_59 = VAR_56 - VAR_3->start_registers;\n\n        if (VAR_57 < 1 || VAR_60 < VAR_57 ||\n            VAR_21 < 1 || VAR_61 < VAR_21 ||\n            VAR_58 != VAR_57 * 2) {\n            VAR_10 = response_exception(\n                VAR_0, &VAR_11, VAR_24, VAR_8, TRUE,\n                \"Illegal nb of values (W%d, R%d) in write_and_read_registers (max W%d, R%d)\\n\",\n                VAR_57, VAR_21, VAR_60, VAR_61);\n        } else if (VAR_22 < 0 ||\n                   (VAR_22 + VAR_21) > VAR_3->nb_registers ||\n                   VAR_22 < 0 ||\n                   (VAR_59 + VAR_57) > VAR_3->nb_registers) {\n            VAR_10 = response_exception(\n                VAR_0, &VAR_11, VAR_25, VAR_8, FALSE,\n                \"Illegal data read address 0x%0X or write address 0x%0X write_and_read_registers\\n\",\n                VAR_22 < 0 ? VAR_7 : VAR_7 + VAR_21,\n                VAR_59 < 0 ? VAR_56 : VAR_56 + VAR_57);\n        } else {\n            int VAR_32, VAR_43;\n            VAR_10 = VAR_0->backend->build_response_basis(&VAR_11, VAR_8);\n            VAR_8[VAR_10++] = VAR_21 << 1;\n\n            /* COMMENT_15 */\n                                                                       \n            for (VAR_32 = VAR_59, VAR_43 = 10;\n                 VAR_32 < VAR_59 + VAR_57; VAR_32++, VAR_43 += 2) {\n                VAR_3->tab_registers[VAR_32] =\n                    (VAR_1[VAR_4 + VAR_43] << 8) + VAR_1[VAR_4 + VAR_43 + 1];\n            }\n\n            /* COMMENT_17 */\n            for (VAR_32 = VAR_22; VAR_32 < VAR_22 + VAR_21; VAR_32++) {\n                VAR_8[VAR_10++] = VAR_3->tab_registers[VAR_32] >> 8;\n                VAR_8[VAR_10++] = VAR_3->tab_registers[VAR_32] & 0xFF;\n            }\n        }\n    }\n        break;\n\n    default:\n        VAR_10 = response_exception(\n            VAR_0, &VAR_11, VAR_62, VAR_8, TRUE,\n            \"Unknown Modbus function code: 0x%0X\\n\", VAR_6);\n        break;\n    }\n\n    /* COMMENT_18 */\n    return (VAR_0->backend->backend_type == VAR_63 &&\n            VAR_5 == VAR_64) ? 0 : send_msg(VAR_0, VAR_8, VAR_10);\n}",
  "func_graph_path_before": "stephane/libmodbus/b4ef4c17d618eba0adccc4c7d9e9a1ef809fc9b6/modbus.c/vul/before/0.json",
  "func": "int modbus_reply(modbus_t *ctx, const uint8_t *req,\n                 int req_length, modbus_mapping_t *mb_mapping)\n{\n    int offset;\n    int slave;\n    int function;\n    uint16_t address;\n    uint8_t rsp[MAX_MESSAGE_LENGTH];\n    int rsp_length = 0;\n    sft_t sft;\n\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    offset = ctx->backend->header_length;\n    slave = req[offset - 1];\n    function = req[offset];\n    address = (req[offset + 1] << 8) + req[offset + 2];\n\n    sft.slave = slave;\n    sft.function = function;\n    sft.t_id = ctx->backend->prepare_response_tid(req, &req_length);\n\n    /* Data are flushed on illegal number of values errors. */\n    switch (function) {\n    case MODBUS_FC_READ_COILS:\n    case MODBUS_FC_READ_DISCRETE_INPUTS: {\n        unsigned int is_input = (function == MODBUS_FC_READ_DISCRETE_INPUTS);\n        int start_bits = is_input ? mb_mapping->start_input_bits : mb_mapping->start_bits;\n        int nb_bits = is_input ? mb_mapping->nb_input_bits : mb_mapping->nb_bits;\n        uint8_t *tab_bits = is_input ? mb_mapping->tab_input_bits : mb_mapping->tab_bits;\n        const char * const name = is_input ? \"read_input_bits\" : \"read_bits\";\n        int nb = (req[offset + 3] << 8) + req[offset + 4];\n        /* The mapping can be shifted to reduce memory consumption and it\n           doesn't always start at address zero. */\n        int mapping_address = address - start_bits;\n\n        if (nb < 1 || MODBUS_MAX_READ_BITS < nb) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,\n                \"Illegal nb of values %d in %s (max %d)\\n\",\n                nb, name, MODBUS_MAX_READ_BITS);\n        } else if (mapping_address < 0 || (mapping_address + nb) > nb_bits) {\n            rsp_length = response_exception(\n                ctx, &sft,\n                MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data address 0x%0X in %s\\n\",\n                mapping_address < 0 ? address : address + nb, name);\n        } else {\n            rsp_length = ctx->backend->build_response_basis(&sft, rsp);\n            rsp[rsp_length++] = (nb / 8) + ((nb % 8) ? 1 : 0);\n            rsp_length = response_io_status(tab_bits, mapping_address, nb,\n                                            rsp, rsp_length);\n        }\n    }\n        break;\n    case MODBUS_FC_READ_HOLDING_REGISTERS:\n    case MODBUS_FC_READ_INPUT_REGISTERS: {\n        unsigned int is_input = (function == MODBUS_FC_READ_INPUT_REGISTERS);\n        int start_registers = is_input ? mb_mapping->start_input_registers : mb_mapping->start_registers;\n        int nb_registers = is_input ? mb_mapping->nb_input_registers : mb_mapping->nb_registers;\n        uint16_t *tab_registers = is_input ? mb_mapping->tab_input_registers : mb_mapping->tab_registers;\n        const char * const name = is_input ? \"read_input_registers\" : \"read_registers\";\n        int nb = (req[offset + 3] << 8) + req[offset + 4];\n        /* The mapping can be shifted to reduce memory consumption and it\n           doesn't always start at address zero. */\n        int mapping_address = address - start_registers;\n\n        if (nb < 1 || MODBUS_MAX_READ_REGISTERS < nb) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,\n                \"Illegal nb of values %d in %s (max %d)\\n\",\n                nb, name, MODBUS_MAX_READ_REGISTERS);\n        } else if (mapping_address < 0 || (mapping_address + nb) > nb_registers) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data address 0x%0X in %s\\n\",\n                mapping_address < 0 ? address : address + nb, name);\n        } else {\n            int i;\n\n            rsp_length = ctx->backend->build_response_basis(&sft, rsp);\n            rsp[rsp_length++] = nb << 1;\n            for (i = mapping_address; i < mapping_address + nb; i++) {\n                rsp[rsp_length++] = tab_registers[i] >> 8;\n                rsp[rsp_length++] = tab_registers[i] & 0xFF;\n            }\n        }\n    }\n        break;\n    case MODBUS_FC_WRITE_SINGLE_COIL: {\n        int mapping_address = address - mb_mapping->start_bits;\n\n        if (mapping_address < 0 || mapping_address >= mb_mapping->nb_bits) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data address 0x%0X in write_bit\\n\",\n                address);\n        } else {\n            int data = (req[offset + 3] << 8) + req[offset + 4];\n\n            if (data == 0xFF00 || data == 0x0) {\n                mb_mapping->tab_bits[mapping_address] = data ? ON : OFF;\n                memcpy(rsp, req, req_length);\n                rsp_length = req_length;\n            } else {\n                rsp_length = response_exception(\n                    ctx, &sft,\n                    MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, FALSE,\n                    \"Illegal data value 0x%0X in write_bit request at address %0X\\n\",\n                    data, address);\n            }\n        }\n    }\n        break;\n    case MODBUS_FC_WRITE_SINGLE_REGISTER: {\n        int mapping_address = address - mb_mapping->start_registers;\n\n        if (mapping_address < 0 || mapping_address >= mb_mapping->nb_registers) {\n            rsp_length = response_exception(\n                ctx, &sft,\n                MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data address 0x%0X in write_register\\n\",\n                address);\n        } else {\n            int data = (req[offset + 3] << 8) + req[offset + 4];\n\n            mb_mapping->tab_registers[mapping_address] = data;\n            memcpy(rsp, req, req_length);\n            rsp_length = req_length;\n        }\n    }\n        break;\n    case MODBUS_FC_WRITE_MULTIPLE_COILS: {\n        int nb = (req[offset + 3] << 8) + req[offset + 4];\n        int nb_bits = req[offset + 5];\n        int mapping_address = address - mb_mapping->start_bits;\n\n        if (nb < 1 || MODBUS_MAX_WRITE_BITS < nb || nb_bits * 8 < nb) {\n            /* May be the indication has been truncated on reading because of\n             * invalid address (eg. nb is 0 but the request contains values to\n             * write) so it's necessary to flush. */\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,\n                \"Illegal number of values %d in write_bits (max %d)\\n\",\n                nb, MODBUS_MAX_WRITE_BITS);\n        } else if (mapping_address < 0 ||\n                   (mapping_address + nb) > mb_mapping->nb_bits) {\n            rsp_length = response_exception(\n                ctx, &sft,\n                MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data address 0x%0X in write_bits\\n\",\n                mapping_address < 0 ? address : address + nb);\n        } else {\n            /* 6 = byte count */\n            modbus_set_bits_from_bytes(mb_mapping->tab_bits, mapping_address, nb,\n                                       &req[offset + 6]);\n\n            rsp_length = ctx->backend->build_response_basis(&sft, rsp);\n            /* 4 to copy the bit address (2) and the quantity of bits */\n            memcpy(rsp + rsp_length, req + rsp_length, 4);\n            rsp_length += 4;\n        }\n    }\n        break;\n    case MODBUS_FC_WRITE_MULTIPLE_REGISTERS: {\n        int nb = (req[offset + 3] << 8) + req[offset + 4];\n        int nb_bytes = req[offset + 5];\n        int mapping_address = address - mb_mapping->start_registers;\n\n        if (nb < 1 || MODBUS_MAX_WRITE_REGISTERS < nb || nb_bytes != nb * 2) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,\n                \"Illegal number of values %d in write_registers (max %d)\\n\",\n                nb, MODBUS_MAX_WRITE_REGISTERS);\n        } else if (mapping_address < 0 ||\n                   (mapping_address + nb) > mb_mapping->nb_registers) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data address 0x%0X in write_registers\\n\",\n                mapping_address < 0 ? address : address + nb);\n        } else {\n            int i, j;\n            for (i = mapping_address, j = 6; i < mapping_address + nb; i++, j += 2) {\n                /* 6 and 7 = first value */\n                mb_mapping->tab_registers[i] =\n                    (req[offset + j] << 8) + req[offset + j + 1];\n            }\n\n            rsp_length = ctx->backend->build_response_basis(&sft, rsp);\n            /* 4 to copy the address (2) and the no. of registers */\n            memcpy(rsp + rsp_length, req + rsp_length, 4);\n            rsp_length += 4;\n        }\n    }\n        break;\n    case MODBUS_FC_REPORT_SLAVE_ID: {\n        int str_len;\n        int byte_count_pos;\n\n        rsp_length = ctx->backend->build_response_basis(&sft, rsp);\n        /* Skip byte count for now */\n        byte_count_pos = rsp_length++;\n        rsp[rsp_length++] = _REPORT_SLAVE_ID;\n        /* Run indicator status to ON */\n        rsp[rsp_length++] = 0xFF;\n        /* LMB + length of LIBMODBUS_VERSION_STRING */\n        str_len = 3 + strlen(LIBMODBUS_VERSION_STRING);\n        memcpy(rsp + rsp_length, \"LMB\" LIBMODBUS_VERSION_STRING, str_len);\n        rsp_length += str_len;\n        rsp[byte_count_pos] = rsp_length - byte_count_pos - 1;\n    }\n        break;\n    case MODBUS_FC_READ_EXCEPTION_STATUS:\n        if (ctx->debug) {\n            fprintf(stderr, \"FIXME Not implemented\\n\");\n        }\n        errno = ENOPROTOOPT;\n        return -1;\n        break;\n    case MODBUS_FC_MASK_WRITE_REGISTER: {\n        int mapping_address = address - mb_mapping->start_registers;\n\n        if (mapping_address < 0 || mapping_address >= mb_mapping->nb_registers) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data address 0x%0X in write_register\\n\",\n                address);\n        } else {\n            uint16_t data = mb_mapping->tab_registers[mapping_address];\n            uint16_t and = (req[offset + 3] << 8) + req[offset + 4];\n            uint16_t or = (req[offset + 5] << 8) + req[offset + 6];\n\n            data = (data & and) | (or & (~and));\n            mb_mapping->tab_registers[mapping_address] = data;\n            memcpy(rsp, req, req_length);\n            rsp_length = req_length;\n        }\n    }\n        break;\n    case MODBUS_FC_WRITE_AND_READ_REGISTERS: {\n        int nb = (req[offset + 3] << 8) + req[offset + 4];\n        uint16_t address_write = (req[offset + 5] << 8) + req[offset + 6];\n        int nb_write = (req[offset + 7] << 8) + req[offset + 8];\n        int nb_write_bytes = req[offset + 9];\n        int mapping_address = address - mb_mapping->start_registers;\n        int mapping_address_write = address_write - mb_mapping->start_registers;\n\n        if (nb_write < 1 || MODBUS_MAX_WR_WRITE_REGISTERS < nb_write ||\n            nb < 1 || MODBUS_MAX_WR_READ_REGISTERS < nb ||\n            nb_write_bytes != nb_write * 2) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,\n                \"Illegal nb of values (W%d, R%d) in write_and_read_registers (max W%d, R%d)\\n\",\n                nb_write, nb, MODBUS_MAX_WR_WRITE_REGISTERS, MODBUS_MAX_WR_READ_REGISTERS);\n        } else if (mapping_address < 0 ||\n                   (mapping_address + nb) > mb_mapping->nb_registers ||\n                   mapping_address_write < 0 ||\n                   (mapping_address_write + nb_write) > mb_mapping->nb_registers) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data read address 0x%0X or write address 0x%0X write_and_read_registers\\n\",\n                mapping_address < 0 ? address : address + nb,\n                mapping_address_write < 0 ? address_write : address_write + nb_write);\n        } else {\n            int i, j;\n            rsp_length = ctx->backend->build_response_basis(&sft, rsp);\n            rsp[rsp_length++] = nb << 1;\n\n            /* Write first.\n               10 and 11 are the offset of the first values to write */\n            for (i = mapping_address_write, j = 10;\n                 i < mapping_address_write + nb_write; i++, j += 2) {\n                mb_mapping->tab_registers[i] =\n                    (req[offset + j] << 8) + req[offset + j + 1];\n            }\n\n            /* and read the data for the response */\n            for (i = mapping_address; i < mapping_address + nb; i++) {\n                rsp[rsp_length++] = mb_mapping->tab_registers[i] >> 8;\n                rsp[rsp_length++] = mb_mapping->tab_registers[i] & 0xFF;\n            }\n        }\n    }\n        break;\n\n    default:\n        rsp_length = response_exception(\n            ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_FUNCTION, rsp, TRUE,\n            \"Unknown Modbus function code: 0x%0X\\n\", function);\n        break;\n    }\n\n    /* Suppress any responses when the request was a broadcast */\n    return (ctx->backend->backend_type == _MODBUS_BACKEND_TYPE_RTU &&\n            slave == MODBUS_BROADCAST_ADDRESS) ? 0 : send_msg(ctx, rsp, rsp_length);\n}",
  "abstract_func": "int modbus_reply(modbus_t *VAR_0, const uint8_t *VAR_1,\n                 int VAR_2, modbus_mapping_t *VAR_3)\n{\n    int VAR_4;\n    int VAR_5;\n    int VAR_6;\n    uint16_t VAR_7;\n    uint8_t VAR_8[VAR_9];\n    int VAR_10 = 0;\n    sft_t VAR_11;\n\n    if (VAR_0 == NULL) {\n        VAR_12 = VAR_13;\n        return -1;\n    }\n\n    VAR_4 = VAR_0->backend->header_length;\n    VAR_5 = VAR_1[VAR_4 - 1];\n    VAR_6 = VAR_1[VAR_4];\n    VAR_7 = (VAR_1[VAR_4 + 1] << 8) + VAR_1[VAR_4 + 2];\n\n    VAR_11.slave = VAR_5;\n    VAR_11.function = VAR_6;\n    VAR_11.t_id = VAR_0->backend->prepare_response_tid(VAR_1, &VAR_2);\n\n    /* COMMENT_0 */\n    switch (VAR_6) {\n    case VAR_14:\n    case VAR_15: {\n        unsigned int VAR_16 = (VAR_6 == VAR_15);\n        int VAR_17 = VAR_16 ? VAR_3->start_input_bits : VAR_3->start_bits;\n        int VAR_18 = VAR_16 ? VAR_3->nb_input_bits : VAR_3->nb_bits;\n        uint8_t *VAR_19 = VAR_16 ? VAR_3->tab_input_bits : VAR_3->tab_bits;\n        const char * const VAR_20 = VAR_16 ? \"read_input_bits\" : \"read_bits\";\n        int VAR_21 = (VAR_1[VAR_4 + 3] << 8) + VAR_1[VAR_4 + 4];\n        /* COMMENT_1 */\n                                                   \n        int VAR_22 = VAR_7 - VAR_17;\n\n        if (VAR_21 < 1 || VAR_23 < VAR_21) {\n            VAR_10 = response_exception(\n                VAR_0, &VAR_11, VAR_24, VAR_8, TRUE,\n                \"Illegal nb of values %d in %s (max %d)\\n\",\n                VAR_21, VAR_20, VAR_23);\n        } else if (VAR_22 < 0 || (VAR_22 + VAR_21) > VAR_18) {\n            VAR_10 = response_exception(\n                VAR_0, &VAR_11,\n                VAR_25, VAR_8, FALSE,\n                \"Illegal data address 0x%0X in %s\\n\",\n                VAR_22 < 0 ? VAR_7 : VAR_7 + VAR_21, VAR_20);\n        } else {\n            VAR_10 = VAR_0->backend->build_response_basis(&VAR_11, VAR_8);\n            VAR_8[VAR_10++] = (VAR_21 / 8) + ((VAR_21 % 8) ? 1 : 0);\n            VAR_10 = response_io_status(VAR_19, VAR_22, VAR_21,\n                                            VAR_8, VAR_10);\n        }\n    }\n        break;\n    case VAR_26:\n    case VAR_27: {\n        unsigned int VAR_16 = (VAR_6 == VAR_27);\n        int VAR_28 = VAR_16 ? VAR_3->start_input_registers : VAR_3->start_registers;\n        int VAR_29 = VAR_16 ? VAR_3->nb_input_registers : VAR_3->nb_registers;\n        uint16_t *VAR_30 = VAR_16 ? VAR_3->tab_input_registers : VAR_3->tab_registers;\n        const char * const VAR_20 = VAR_16 ? \"read_input_registers\" : \"read_registers\";\n        int VAR_21 = (VAR_1[VAR_4 + 3] << 8) + VAR_1[VAR_4 + 4];\n        /* COMMENT_3 */\n                                                   \n        int VAR_22 = VAR_7 - VAR_28;\n\n        if (VAR_21 < 1 || VAR_31 < VAR_21) {\n            VAR_10 = response_exception(\n                VAR_0, &VAR_11, VAR_24, VAR_8, TRUE,\n                \"Illegal nb of values %d in %s (max %d)\\n\",\n                VAR_21, VAR_20, VAR_31);\n        } else if (VAR_22 < 0 || (VAR_22 + VAR_21) > VAR_29) {\n            VAR_10 = response_exception(\n                VAR_0, &VAR_11, VAR_25, VAR_8, FALSE,\n                \"Illegal data address 0x%0X in %s\\n\",\n                VAR_22 < 0 ? VAR_7 : VAR_7 + VAR_21, VAR_20);\n        } else {\n            int VAR_32;\n\n            VAR_10 = VAR_0->backend->build_response_basis(&VAR_11, VAR_8);\n            VAR_8[VAR_10++] = VAR_21 << 1;\n            for (VAR_32 = VAR_22; VAR_32 < VAR_22 + VAR_21; VAR_32++) {\n                VAR_8[VAR_10++] = VAR_30[VAR_32] >> 8;\n                VAR_8[VAR_10++] = VAR_30[VAR_32] & 0xFF;\n            }\n        }\n    }\n        break;\n    case VAR_33: {\n        int VAR_22 = VAR_7 - VAR_3->start_bits;\n\n        if (VAR_22 < 0 || VAR_22 >= VAR_3->nb_bits) {\n            VAR_10 = response_exception(\n                VAR_0, &VAR_11, VAR_25, VAR_8, FALSE,\n                \"Illegal data address 0x%0X in write_bit\\n\",\n                VAR_7);\n        } else {\n            int VAR_34 = (VAR_1[VAR_4 + 3] << 8) + VAR_1[VAR_4 + 4];\n\n            if (VAR_34 == 0xFF00 || VAR_34 == 0x0) {\n                VAR_3->tab_bits[VAR_22] = VAR_34 ? VAR_35 : VAR_36;\n                memcpy(VAR_8, VAR_1, VAR_2);\n                VAR_10 = VAR_2;\n            } else {\n                VAR_10 = response_exception(\n                    VAR_0, &VAR_11,\n                    VAR_24, VAR_8, FALSE,\n                    \"Illegal data value 0x%0X in write_bit request at address %0X\\n\",\n                    VAR_34, VAR_7);\n            }\n        }\n    }\n        break;\n    case VAR_37: {\n        int VAR_22 = VAR_7 - VAR_3->start_registers;\n\n        if (VAR_22 < 0 || VAR_22 >= VAR_3->nb_registers) {\n            VAR_10 = response_exception(\n                VAR_0, &VAR_11,\n                VAR_25, VAR_8, FALSE,\n                \"Illegal data address 0x%0X in write_register\\n\",\n                VAR_7);\n        } else {\n            int VAR_34 = (VAR_1[VAR_4 + 3] << 8) + VAR_1[VAR_4 + 4];\n\n            VAR_3->tab_registers[VAR_22] = VAR_34;\n            memcpy(VAR_8, VAR_1, VAR_2);\n            VAR_10 = VAR_2;\n        }\n    }\n        break;\n    case VAR_38: {\n        int VAR_21 = (VAR_1[VAR_4 + 3] << 8) + VAR_1[VAR_4 + 4];\n        int VAR_18 = VAR_1[VAR_4 + 5];\n        int VAR_22 = VAR_7 - VAR_3->start_bits;\n\n        if (VAR_21 < 1 || VAR_39 < VAR_21 || VAR_18 * 8 < VAR_21) {\n            /* COMMENT_5 */\n                                                                              \n                                                    \n            VAR_10 = response_exception(\n                VAR_0, &VAR_11, VAR_24, VAR_8, TRUE,\n                \"Illegal number of values %d in write_bits (max %d)\\n\",\n                VAR_21, VAR_39);\n        } else if (VAR_22 < 0 ||\n                   (VAR_22 + VAR_21) > VAR_3->nb_bits) {\n            VAR_10 = response_exception(\n                VAR_0, &VAR_11,\n                VAR_25, VAR_8, FALSE,\n                \"Illegal data address 0x%0X in write_bits\\n\",\n                VAR_22 < 0 ? VAR_7 : VAR_7 + VAR_21);\n        } else {\n            /* COMMENT_8 */\n            modbus_set_bits_from_bytes(VAR_3->tab_bits, VAR_22, VAR_21,\n                                       &VAR_1[VAR_4 + 6]);\n\n            VAR_10 = VAR_0->backend->build_response_basis(&VAR_11, VAR_8);\n            /* COMMENT_9 */\n            memcpy(VAR_8 + VAR_10, VAR_1 + VAR_10, 4);\n            VAR_10 += 4;\n        }\n    }\n        break;\n    case VAR_40: {\n        int VAR_21 = (VAR_1[VAR_4 + 3] << 8) + VAR_1[VAR_4 + 4];\n        int VAR_41 = VAR_1[VAR_4 + 5];\n        int VAR_22 = VAR_7 - VAR_3->start_registers;\n\n        if (VAR_21 < 1 || VAR_42 < VAR_21 || VAR_41 != VAR_21 * 2) {\n            VAR_10 = response_exception(\n                VAR_0, &VAR_11, VAR_24, VAR_8, TRUE,\n                \"Illegal number of values %d in write_registers (max %d)\\n\",\n                VAR_21, VAR_42);\n        } else if (VAR_22 < 0 ||\n                   (VAR_22 + VAR_21) > VAR_3->nb_registers) {\n            VAR_10 = response_exception(\n                VAR_0, &VAR_11, VAR_25, VAR_8, FALSE,\n                \"Illegal data address 0x%0X in write_registers\\n\",\n                VAR_22 < 0 ? VAR_7 : VAR_7 + VAR_21);\n        } else {\n            int VAR_32, VAR_43;\n            for (VAR_32 = VAR_22, VAR_43 = 6; VAR_32 < VAR_22 + VAR_21; VAR_32++, VAR_43 += 2) {\n                /* COMMENT_10 */\n                VAR_3->tab_registers[VAR_32] =\n                    (VAR_1[VAR_4 + VAR_43] << 8) + VAR_1[VAR_4 + VAR_43 + 1];\n            }\n\n            VAR_10 = VAR_0->backend->build_response_basis(&VAR_11, VAR_8);\n            /* COMMENT_11 */\n            memcpy(VAR_8 + VAR_10, VAR_1 + VAR_10, 4);\n            VAR_10 += 4;\n        }\n    }\n        break;\n    case VAR_44: {\n        int VAR_45;\n        int VAR_46;\n\n        VAR_10 = VAR_0->backend->build_response_basis(&VAR_11, VAR_8);\n        /* COMMENT_12 */\n        VAR_46 = VAR_10++;\n        VAR_8[VAR_10++] = VAR_47;\n        /* COMMENT_13 */\n        VAR_8[VAR_10++] = 0xFF;\n        /* COMMENT_14 */\n        VAR_45 = 3 + strlen(VAR_48);\n        memcpy(VAR_8 + VAR_10, \"LMB\" VAR_48, VAR_45);\n        VAR_10 += VAR_45;\n        VAR_8[VAR_46] = VAR_10 - VAR_46 - 1;\n    }\n        break;\n    case VAR_49:\n        if (VAR_0->debug) {\n            fprintf(VAR_50, \"FIXME Not implemented\\n\");\n        }\n        VAR_12 = VAR_51;\n        return -1;\n        break;\n    case VAR_52: {\n        int VAR_22 = VAR_7 - VAR_3->start_registers;\n\n        if (VAR_22 < 0 || VAR_22 >= VAR_3->nb_registers) {\n            VAR_10 = response_exception(\n                VAR_0, &VAR_11, VAR_25, VAR_8, FALSE,\n                \"Illegal data address 0x%0X in write_register\\n\",\n                VAR_7);\n        } else {\n            uint16_t VAR_34 = VAR_3->tab_registers[VAR_22];\n            uint16_t VAR_53 = (VAR_1[VAR_4 + 3] << 8) + VAR_1[VAR_4 + 4];\n            uint16_t VAR_54 = (VAR_1[VAR_4 + 5] << 8) + VAR_1[VAR_4 + 6];\n\n            VAR_34 = (VAR_34 & VAR_53) | (VAR_54 & (~VAR_53));\n            VAR_3->tab_registers[VAR_22] = VAR_34;\n            memcpy(VAR_8, VAR_1, VAR_2);\n            VAR_10 = VAR_2;\n        }\n    }\n        break;\n    case VAR_55: {\n        int VAR_21 = (VAR_1[VAR_4 + 3] << 8) + VAR_1[VAR_4 + 4];\n        uint16_t VAR_56 = (VAR_1[VAR_4 + 5] << 8) + VAR_1[VAR_4 + 6];\n        int VAR_57 = (VAR_1[VAR_4 + 7] << 8) + VAR_1[VAR_4 + 8];\n        int VAR_58 = VAR_1[VAR_4 + 9];\n        int VAR_22 = VAR_7 - VAR_3->start_registers;\n        int VAR_59 = VAR_56 - VAR_3->start_registers;\n\n        if (VAR_57 < 1 || VAR_60 < VAR_57 ||\n            VAR_21 < 1 || VAR_61 < VAR_21 ||\n            VAR_58 != VAR_57 * 2) {\n            VAR_10 = response_exception(\n                VAR_0, &VAR_11, VAR_24, VAR_8, TRUE,\n                \"Illegal nb of values (W%d, R%d) in write_and_read_registers (max W%d, R%d)\\n\",\n                VAR_57, VAR_21, VAR_60, VAR_61);\n        } else if (VAR_22 < 0 ||\n                   (VAR_22 + VAR_21) > VAR_3->nb_registers ||\n                   VAR_59 < 0 ||\n                   (VAR_59 + VAR_57) > VAR_3->nb_registers) {\n            VAR_10 = response_exception(\n                VAR_0, &VAR_11, VAR_25, VAR_8, FALSE,\n                \"Illegal data read address 0x%0X or write address 0x%0X write_and_read_registers\\n\",\n                VAR_22 < 0 ? VAR_7 : VAR_7 + VAR_21,\n                VAR_59 < 0 ? VAR_56 : VAR_56 + VAR_57);\n        } else {\n            int VAR_32, VAR_43;\n            VAR_10 = VAR_0->backend->build_response_basis(&VAR_11, VAR_8);\n            VAR_8[VAR_10++] = VAR_21 << 1;\n\n            /* COMMENT_15 */\n                                                                       \n            for (VAR_32 = VAR_59, VAR_43 = 10;\n                 VAR_32 < VAR_59 + VAR_57; VAR_32++, VAR_43 += 2) {\n                VAR_3->tab_registers[VAR_32] =\n                    (VAR_1[VAR_4 + VAR_43] << 8) + VAR_1[VAR_4 + VAR_43 + 1];\n            }\n\n            /* COMMENT_17 */\n            for (VAR_32 = VAR_22; VAR_32 < VAR_22 + VAR_21; VAR_32++) {\n                VAR_8[VAR_10++] = VAR_3->tab_registers[VAR_32] >> 8;\n                VAR_8[VAR_10++] = VAR_3->tab_registers[VAR_32] & 0xFF;\n            }\n        }\n    }\n        break;\n\n    default:\n        VAR_10 = response_exception(\n            VAR_0, &VAR_11, VAR_62, VAR_8, TRUE,\n            \"Unknown Modbus function code: 0x%0X\\n\", VAR_6);\n        break;\n    }\n\n    /* COMMENT_18 */\n    return (VAR_0->backend->backend_type == VAR_63 &&\n            VAR_5 == VAR_64) ? 0 : send_msg(VAR_0, VAR_8, VAR_10);\n}",
  "func_graph_path": "stephane/libmodbus/b4ef4c17d618eba0adccc4c7d9e9a1ef809fc9b6/modbus.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -257,7 +257,7 @@\n                 nb_write, nb, MODBUS_MAX_WR_WRITE_REGISTERS, MODBUS_MAX_WR_READ_REGISTERS);\n         } else if (mapping_address < 0 ||\n                    (mapping_address + nb) > mb_mapping->nb_registers ||\n-                   mapping_address < 0 ||\n+                   mapping_address_write < 0 ||\n                    (mapping_address_write + nb_write) > mb_mapping->nb_registers) {\n             rsp_length = response_exception(\n                 ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,",
  "diff_line_info": {
    "deleted_lines": [
      "                   mapping_address < 0 ||"
    ],
    "added_lines": [
      "                   mapping_address_write < 0 ||"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/stephane/libmodbus/pull/619",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/stephane/libmodbus/pull/619: 403 Client Error: Forbidden for url: https://api.github.com/repos/stephane/libmodbus/pulls/619",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.9\n\nThe patch addresses an incomplete address validation that could lead to security issues, thus it's a security fix with high confidence."
}