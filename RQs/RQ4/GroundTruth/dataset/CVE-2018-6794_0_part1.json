{
  "cve_id": "CVE-2018-6794",
  "cwe_ids": [
    "CWE-693"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "OISF/suricata",
  "commit_msg": "stream: still inspect packets dropped by stream\n\nThe detect engine would bypass packets that are set as dropped. This\nseems sane, as these packets are going to be dropped anyway.\n\nHowever, it lead to the following corner case: stream events that\ntriggered the drop could not be matched on the rules. The packet\nwith the event wouldn't make it to the detect engine due to the bypass.\n\nThis patch changes the logic to not bypass DROP packets anymore.\nPackets that are dropped by the stream engine will set the no payload\ninspection flag, so avoid needless cost.",
  "commit_hash": "e1ef57c848bbe4e567d5d4b66d346a742e3f77a1",
  "git_url": "https://github.com/OISF/suricata/commit/e1ef57c848bbe4e567d5d4b66d346a742e3f77a1",
  "file_path": "src/stream-tcp.c",
  "func_name": "StreamTcpPacket",
  "func_before": "int StreamTcpPacket (ThreadVars *tv, Packet *p, StreamTcpThread *stt,\n                     PacketQueue *pq)\n{\n    SCEnter();\n\n    DEBUG_ASSERT_FLOW_LOCKED(p->flow);\n\n    SCLogDebug(\"p->pcap_cnt %\"PRIu64, p->pcap_cnt);\n\n    /* assign the thread id to the flow */\n    if (unlikely(p->flow->thread_id == 0)) {\n        p->flow->thread_id = (FlowThreadId)tv->id;\n#ifdef DEBUG\n    } else if (unlikely((FlowThreadId)tv->id != p->flow->thread_id)) {\n        SCLogDebug(\"wrong thread: flow has %u, we are %d\", p->flow->thread_id, tv->id);\n#endif\n    }\n\n    TcpSession *ssn = (TcpSession *)p->flow->protoctx;\n\n    /* track TCP flags */\n    if (ssn != NULL) {\n        ssn->tcp_packet_flags |= p->tcph->th_flags;\n        if (PKT_IS_TOSERVER(p))\n            ssn->client.tcp_flags |= p->tcph->th_flags;\n        else if (PKT_IS_TOCLIENT(p))\n            ssn->server.tcp_flags |= p->tcph->th_flags;\n\n        /* check if we need to unset the ASYNC flag */\n        if (ssn->flags & STREAMTCP_FLAG_ASYNC &&\n            ssn->client.tcp_flags != 0 &&\n            ssn->server.tcp_flags != 0)\n        {\n            SCLogDebug(\"ssn %p: removing ASYNC flag as we have packets on both sides\", ssn);\n            ssn->flags &= ~STREAMTCP_FLAG_ASYNC;\n        }\n    }\n\n    /* update counters */\n    if ((p->tcph->th_flags & (TH_SYN|TH_ACK)) == (TH_SYN|TH_ACK)) {\n        StatsIncr(tv, stt->counter_tcp_synack);\n    } else if (p->tcph->th_flags & (TH_SYN)) {\n        StatsIncr(tv, stt->counter_tcp_syn);\n    }\n    if (p->tcph->th_flags & (TH_RST)) {\n        StatsIncr(tv, stt->counter_tcp_rst);\n    }\n\n    /* broken TCP http://ask.wireshark.org/questions/3183/acknowledgment-number-broken-tcp-the-acknowledge-field-is-nonzero-while-the-ack-flag-is-not-set */\n    if (!(p->tcph->th_flags & TH_ACK) && TCP_GET_ACK(p) != 0) {\n        StreamTcpSetEvent(p, STREAM_PKT_BROKEN_ACK);\n    }\n\n    /* If we are on IPS mode, and got a drop action triggered from\n     * the IP only module, or from a reassembled msg and/or from an\n     * applayer detection, then drop the rest of the packets of the\n     * same stream and avoid inspecting it any further */\n    if (StreamTcpCheckFlowDrops(p) == 1) {\n        SCLogDebug(\"This flow/stream triggered a drop rule\");\n        FlowSetNoPacketInspectionFlag(p->flow);\n        DecodeSetNoPacketInspectionFlag(p);\n        StreamTcpDisableAppLayer(p->flow);\n        PACKET_DROP(p);\n        /* return the segments to the pool */\n        StreamTcpSessionPktFree(p);\n        SCReturnInt(0);\n    }\n\n    if (ssn == NULL || ssn->state == TCP_NONE) {\n        if (StreamTcpPacketStateNone(tv, p, stt, ssn, &stt->pseudo_queue) == -1) {\n            goto error;\n        }\n\n        if (ssn != NULL)\n            SCLogDebug(\"ssn->alproto %\"PRIu16\"\", p->flow->alproto);\n    } else {\n        /* special case for PKT_PSEUDO_STREAM_END packets:\n         * bypass the state handling and various packet checks,\n         * we care about reassembly here. */\n        if (p->flags & PKT_PSEUDO_STREAM_END) {\n            if (PKT_IS_TOCLIENT(p)) {\n                ssn->client.last_ack = TCP_GET_ACK(p);\n                StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                        &ssn->server, p, pq);\n            } else {\n                ssn->server.last_ack = TCP_GET_ACK(p);\n                StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                        &ssn->client, p, pq);\n            }\n            /* straight to 'skip' as we already handled reassembly */\n            goto skip;\n        }\n\n        /* check if the packet is in right direction, when we missed the\n           SYN packet and picked up midstream session. */\n        if (ssn->flags & STREAMTCP_FLAG_MIDSTREAM_SYNACK)\n            StreamTcpPacketSwitchDir(ssn, p);\n\n        if (StreamTcpPacketIsKeepAlive(ssn, p) == 1) {\n            goto skip;\n        }\n        if (StreamTcpPacketIsKeepAliveACK(ssn, p) == 1) {\n            StreamTcpClearKeepAliveFlag(ssn, p);\n            goto skip;\n        }\n        StreamTcpClearKeepAliveFlag(ssn, p);\n\n        /* if packet is not a valid window update, check if it is perhaps\n         * a bad window update that we should ignore (and alert on) */\n        if (StreamTcpPacketIsFinShutdownAck(ssn, p) == 0)\n            if (StreamTcpPacketIsWindowUpdate(ssn, p) == 0)\n                if (StreamTcpPacketIsBadWindowUpdate(ssn,p))\n                    goto skip;\n\n        switch (ssn->state) {\n            case TCP_SYN_SENT:\n                if(StreamTcpPacketStateSynSent(tv, p, stt, ssn, &stt->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case TCP_SYN_RECV:\n                if(StreamTcpPacketStateSynRecv(tv, p, stt, ssn, &stt->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case TCP_ESTABLISHED:\n                if(StreamTcpPacketStateEstablished(tv, p, stt, ssn, &stt->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case TCP_FIN_WAIT1:\n                if(StreamTcpPacketStateFinWait1(tv, p, stt, ssn, &stt->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case TCP_FIN_WAIT2:\n                if(StreamTcpPacketStateFinWait2(tv, p, stt, ssn, &stt->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case TCP_CLOSING:\n                if(StreamTcpPacketStateClosing(tv, p, stt, ssn, &stt->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case TCP_CLOSE_WAIT:\n                if(StreamTcpPacketStateCloseWait(tv, p, stt, ssn, &stt->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case TCP_LAST_ACK:\n                if(StreamTcpPacketStateLastAck(tv, p, stt, ssn, &stt->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case TCP_TIME_WAIT:\n                if(StreamTcpPacketStateTimeWait(tv, p, stt, ssn, &stt->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case TCP_CLOSED:\n                /* TCP session memory is not returned to pool until timeout. */\n                SCLogDebug(\"packet received on closed state\");\n                break;\n            default:\n                SCLogDebug(\"packet received on default state\");\n                break;\n        }\n    skip:\n\n        if (ssn->state >= TCP_ESTABLISHED) {\n            p->flags |= PKT_STREAM_EST;\n        }\n    }\n\n    /* deal with a pseudo packet that is created upon receiving a RST\n     * segment. To be sure we process both sides of the connection, we\n     * inject a fake packet into the system, forcing reassembly of the\n     * opposing direction.\n     * There should be only one, but to be sure we do a while loop. */\n    if (ssn != NULL) {\n        while (stt->pseudo_queue.len > 0) {\n            SCLogDebug(\"processing pseudo packet / stream end\");\n            Packet *np = PacketDequeue(&stt->pseudo_queue);\n            if (np != NULL) {\n                /* process the opposing direction of the original packet */\n                if (PKT_IS_TOSERVER(np)) {\n                    SCLogDebug(\"pseudo packet is to server\");\n                    StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                            &ssn->client, np, NULL);\n                } else {\n                    SCLogDebug(\"pseudo packet is to client\");\n                    StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                            &ssn->server, np, NULL);\n                }\n\n                /* enqueue this packet so we inspect it in detect etc */\n                PacketEnqueue(pq, np);\n            }\n            SCLogDebug(\"processing pseudo packet / stream end done\");\n        }\n\n        /* recalc the csum on the packet if it was modified */\n        if (p->flags & PKT_STREAM_MODIFIED) {\n            ReCalculateChecksum(p);\n        }\n\n        /* check for conditions that may make us not want to log this packet */\n\n        /* streams that hit depth */\n        if ((ssn->client.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED) &&\n             (ssn->server.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED))\n        {\n            /* we can call bypass callback, if enabled */\n            if (StreamTcpBypassEnabled()) {\n                PacketBypassCallback(p);\n            }\n        }\n\n        if ((ssn->client.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED) ||\n             (ssn->server.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED))\n        {\n            p->flags |= PKT_STREAM_NOPCAPLOG;\n        }\n\n        /* encrypted packets */\n        if ((PKT_IS_TOSERVER(p) && (ssn->client.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY)) ||\n            (PKT_IS_TOCLIENT(p) && (ssn->server.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY)))\n        {\n            p->flags |= PKT_STREAM_NOPCAPLOG;\n        }\n\n        if (ssn->flags & STREAMTCP_FLAG_BYPASS) {\n            /* we can call bypass callback, if enabled */\n            if (StreamTcpBypassEnabled()) {\n                PacketBypassCallback(p);\n            }\n\n        /* if stream is dead and we have no detect engine at all, bypass. */\n        } else if (g_detect_disabled &&\n                (ssn->client.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY) &&\n                (ssn->server.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY) &&\n                StreamTcpBypassEnabled())\n        {\n            SCLogDebug(\"bypass as stream is dead and we have no rules\");\n            PacketBypassCallback(p);\n        }\n    }\n\n    SCReturnInt(0);\n\nerror:\n    /* make sure we don't leave packets in our pseudo queue */\n    while (stt->pseudo_queue.len > 0) {\n        Packet *np = PacketDequeue(&stt->pseudo_queue);\n        if (np != NULL) {\n            PacketEnqueue(pq, np);\n        }\n    }\n\n    /* recalc the csum on the packet if it was modified */\n    if (p->flags & PKT_STREAM_MODIFIED) {\n        ReCalculateChecksum(p);\n    }\n\n    if (StreamTcpInlineDropInvalid()) {\n        PACKET_DROP(p);\n    }\n    SCReturnInt(-1);\n}",
  "abstract_func_before": "int StreamTcpPacket (ThreadVars *VAR_0, Packet *VAR_1, StreamTcpThread *VAR_2,\n                     PacketQueue *VAR_3)\n{\n    SCEnter();\n\n    DEBUG_ASSERT_FLOW_LOCKED(VAR_1->flow);\n\n    SCLogDebug(\"p->pcap_cnt %\"VAR_4, VAR_1->pcap_cnt);\n\n    /* COMMENT_0 */\n    if (unlikely(VAR_1->flow->thread_id == 0)) {\n        VAR_1->flow->thread_id = (FlowThreadId)VAR_0->id;\n#ifdef VAR_5\n    } else if (unlikely((FlowThreadId)VAR_0->id != VAR_1->flow->thread_id)) {\n        SCLogDebug(\"wrong thread: flow has %u, we are %d\", VAR_1->flow->thread_id, VAR_0->id);\n#endif\n    }\n\n    TcpSession *VAR_6 = (TcpSession *)VAR_1->flow->protoctx;\n\n    /* COMMENT_1 */\n    if (VAR_6 != NULL) {\n        VAR_6->tcp_packet_flags |= VAR_1->tcph->th_flags;\n        if (PKT_IS_TOSERVER(VAR_1))\n            VAR_6->client.tcp_flags |= VAR_1->tcph->th_flags;\n        else if (PKT_IS_TOCLIENT(VAR_1))\n            VAR_6->server.tcp_flags |= VAR_1->tcph->th_flags;\n\n        /* COMMENT_2 */\n        if (VAR_6->flags & VAR_7 &&\n            VAR_6->client.tcp_flags != 0 &&\n            VAR_6->server.tcp_flags != 0)\n        {\n            SCLogDebug(\"ssn %p: removing ASYNC flag as we have packets on both sides\", VAR_6);\n            VAR_6->flags &= ~VAR_7;\n        }\n    }\n\n    /* COMMENT_3 */\n    if ((VAR_1->tcph->th_flags & (VAR_8|VAR_9)) == (VAR_8|VAR_9)) {\n        StatsIncr(VAR_0, VAR_2->counter_tcp_synack);\n    } else if (VAR_1->tcph->th_flags & (VAR_8)) {\n        StatsIncr(VAR_0, VAR_2->counter_tcp_syn);\n    }\n    if (VAR_1->tcph->th_flags & (VAR_10)) {\n        StatsIncr(VAR_0, VAR_2->counter_tcp_rst);\n    }\n\n    /* COMMENT_4 */\n    if (!(VAR_1->tcph->th_flags & VAR_9) && TCP_GET_ACK(VAR_1) != 0) {\n        StreamTcpSetEvent(VAR_1, VAR_11);\n    }\n\n    /* COMMENT_5 */\n                                                                   \n                                                                   \n                                                         \n    if (StreamTcpCheckFlowDrops(VAR_1) == 1) {\n        SCLogDebug(\"This flow/stream triggered a drop rule\");\n        FlowSetNoPacketInspectionFlag(VAR_1->flow);\n        DecodeSetNoPacketInspectionFlag(VAR_1);\n        StreamTcpDisableAppLayer(VAR_1->flow);\n        PACKET_DROP(VAR_1);\n        /* COMMENT_9 */\n        StreamTcpSessionPktFree(VAR_1);\n        SCReturnInt(0);\n    }\n\n    if (VAR_6 == NULL || VAR_6->state == VAR_12) {\n        if (StreamTcpPacketStateNone(VAR_0, VAR_1, VAR_2, VAR_6, &VAR_2->pseudo_queue) == -1) {\n            goto error;\n        }\n\n        if (VAR_6 != NULL)\n            SCLogDebug(\"ssn->alproto %\"VAR_13\"\", VAR_1->flow->alproto);\n    } else {\n        /* COMMENT_10 */\n                                                               \n                                            \n        if (VAR_1->flags & VAR_14) {\n            if (PKT_IS_TOCLIENT(VAR_1)) {\n                VAR_6->client.last_ack = TCP_GET_ACK(VAR_1);\n                StreamTcpReassembleHandleSegment(VAR_0, VAR_2->ra_ctx, VAR_6,\n                        &VAR_6->server, VAR_1, VAR_3);\n            } else {\n                VAR_6->server.last_ack = TCP_GET_ACK(VAR_1);\n                StreamTcpReassembleHandleSegment(VAR_0, VAR_2->ra_ctx, VAR_6,\n                        &VAR_6->client, VAR_1, VAR_3);\n            }\n            /* COMMENT_13 */\n            goto skip;\n        }\n\n        /* COMMENT_14 */\n                                                         \n        if (VAR_6->flags & VAR_15)\n            StreamTcpPacketSwitchDir(VAR_6, VAR_1);\n\n        if (StreamTcpPacketIsKeepAlive(VAR_6, VAR_1) == 1) {\n            goto skip;\n        }\n        if (StreamTcpPacketIsKeepAliveACK(VAR_6, VAR_1) == 1) {\n            StreamTcpClearKeepAliveFlag(VAR_6, VAR_1);\n            goto skip;\n        }\n        StreamTcpClearKeepAliveFlag(VAR_6, VAR_1);\n\n        /* COMMENT_16 */\n                                                                      \n        if (StreamTcpPacketIsFinShutdownAck(VAR_6, VAR_1) == 0)\n            if (StreamTcpPacketIsWindowUpdate(VAR_6, VAR_1) == 0)\n                if (StreamTcpPacketIsBadWindowUpdate(VAR_6,VAR_1))\n                    goto skip;\n\n        switch (VAR_6->state) {\n            case VAR_16:\n                if(StreamTcpPacketStateSynSent(VAR_0, VAR_1, VAR_2, VAR_6, &VAR_2->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case VAR_17:\n                if(StreamTcpPacketStateSynRecv(VAR_0, VAR_1, VAR_2, VAR_6, &VAR_2->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case VAR_18:\n                if(StreamTcpPacketStateEstablished(VAR_0, VAR_1, VAR_2, VAR_6, &VAR_2->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case VAR_19:\n                if(StreamTcpPacketStateFinWait1(VAR_0, VAR_1, VAR_2, VAR_6, &VAR_2->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case VAR_20:\n                if(StreamTcpPacketStateFinWait2(VAR_0, VAR_1, VAR_2, VAR_6, &VAR_2->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case VAR_21:\n                if(StreamTcpPacketStateClosing(VAR_0, VAR_1, VAR_2, VAR_6, &VAR_2->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case VAR_22:\n                if(StreamTcpPacketStateCloseWait(VAR_0, VAR_1, VAR_2, VAR_6, &VAR_2->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case VAR_23:\n                if(StreamTcpPacketStateLastAck(VAR_0, VAR_1, VAR_2, VAR_6, &VAR_2->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case VAR_24:\n                if(StreamTcpPacketStateTimeWait(VAR_0, VAR_1, VAR_2, VAR_6, &VAR_2->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case VAR_25:\n                /* COMMENT_18 */\n                SCLogDebug(\"packet received on closed state\");\n                break;\n            default:\n                SCLogDebug(\"packet received on default state\");\n                break;\n        }\n    skip:\n\n        if (VAR_6->state >= VAR_18) {\n            VAR_1->flags |= VAR_26;\n        }\n    }\n\n    /* COMMENT_19 */\n                                                                      \n                                                                      \n                          \n                                                                      \n    if (VAR_6 != NULL) {\n        while (VAR_2->pseudo_queue.len > 0) {\n            SCLogDebug(\"processing pseudo packet / stream end\");\n            Packet *VAR_27 = PacketDequeue(&VAR_2->pseudo_queue);\n            if (VAR_27 != NULL) {\n                /* COMMENT_24 */\n                if (PKT_IS_TOSERVER(VAR_27)) {\n                    SCLogDebug(\"pseudo packet is to server\");\n                    StreamTcpReassembleHandleSegment(VAR_0, VAR_2->ra_ctx, VAR_6,\n                            &VAR_6->client, VAR_27, NULL);\n                } else {\n                    SCLogDebug(\"pseudo packet is to client\");\n                    StreamTcpReassembleHandleSegment(VAR_0, VAR_2->ra_ctx, VAR_6,\n                            &VAR_6->server, VAR_27, NULL);\n                }\n\n                /* COMMENT_25 */\n                PacketEnqueue(VAR_3, VAR_27);\n            }\n            SCLogDebug(\"processing pseudo packet / stream end done\");\n        }\n\n        /* COMMENT_26 */\n        if (VAR_1->flags & VAR_28) {\n            ReCalculateChecksum(VAR_1);\n        }\n\n        /* COMMENT_27 */\n\n        /* COMMENT_28 */\n        if ((VAR_6->client.flags & VAR_29) &&\n             (VAR_6->server.flags & VAR_29))\n        {\n            /* COMMENT_29 */\n            if (StreamTcpBypassEnabled()) {\n                PacketBypassCallback(VAR_1);\n            }\n        }\n\n        if ((VAR_6->client.flags & VAR_29) ||\n             (VAR_6->server.flags & VAR_29))\n        {\n            VAR_1->flags |= VAR_30;\n        }\n\n        /* COMMENT_30 */\n        if ((PKT_IS_TOSERVER(VAR_1) && (VAR_6->client.flags & VAR_31)) ||\n            (PKT_IS_TOCLIENT(VAR_1) && (VAR_6->server.flags & VAR_31)))\n        {\n            VAR_1->flags |= VAR_30;\n        }\n\n        if (VAR_6->flags & VAR_32) {\n            /* COMMENT_29 */\n            if (StreamTcpBypassEnabled()) {\n                PacketBypassCallback(VAR_1);\n            }\n\n        /* COMMENT_31 */\n        } else if (VAR_33 &&\n                (VAR_6->client.flags & VAR_31) &&\n                (VAR_6->server.flags & VAR_31) &&\n                StreamTcpBypassEnabled())\n        {\n            SCLogDebug(\"bypass as stream is dead and we have no rules\");\n            PacketBypassCallback(VAR_1);\n        }\n    }\n\n    SCReturnInt(0);\n\nerror:\n    /* COMMENT_32 */\n    while (VAR_2->pseudo_queue.len > 0) {\n        Packet *VAR_27 = PacketDequeue(&VAR_2->pseudo_queue);\n        if (VAR_27 != NULL) {\n            PacketEnqueue(VAR_3, VAR_27);\n        }\n    }\n\n    /* COMMENT_26 */\n    if (VAR_1->flags & VAR_28) {\n        ReCalculateChecksum(VAR_1);\n    }\n\n    if (StreamTcpInlineDropInvalid()) {\n        PACKET_DROP(VAR_1);\n    }\n    SCReturnInt(-1);\n}",
  "func_graph_path_before": "OISF/suricata/e1ef57c848bbe4e567d5d4b66d346a742e3f77a1/stream-tcp.c/vul/before/0.json",
  "func": "int StreamTcpPacket (ThreadVars *tv, Packet *p, StreamTcpThread *stt,\n                     PacketQueue *pq)\n{\n    SCEnter();\n\n    DEBUG_ASSERT_FLOW_LOCKED(p->flow);\n\n    SCLogDebug(\"p->pcap_cnt %\"PRIu64, p->pcap_cnt);\n\n    /* assign the thread id to the flow */\n    if (unlikely(p->flow->thread_id == 0)) {\n        p->flow->thread_id = (FlowThreadId)tv->id;\n#ifdef DEBUG\n    } else if (unlikely((FlowThreadId)tv->id != p->flow->thread_id)) {\n        SCLogDebug(\"wrong thread: flow has %u, we are %d\", p->flow->thread_id, tv->id);\n#endif\n    }\n\n    TcpSession *ssn = (TcpSession *)p->flow->protoctx;\n\n    /* track TCP flags */\n    if (ssn != NULL) {\n        ssn->tcp_packet_flags |= p->tcph->th_flags;\n        if (PKT_IS_TOSERVER(p))\n            ssn->client.tcp_flags |= p->tcph->th_flags;\n        else if (PKT_IS_TOCLIENT(p))\n            ssn->server.tcp_flags |= p->tcph->th_flags;\n\n        /* check if we need to unset the ASYNC flag */\n        if (ssn->flags & STREAMTCP_FLAG_ASYNC &&\n            ssn->client.tcp_flags != 0 &&\n            ssn->server.tcp_flags != 0)\n        {\n            SCLogDebug(\"ssn %p: removing ASYNC flag as we have packets on both sides\", ssn);\n            ssn->flags &= ~STREAMTCP_FLAG_ASYNC;\n        }\n    }\n\n    /* update counters */\n    if ((p->tcph->th_flags & (TH_SYN|TH_ACK)) == (TH_SYN|TH_ACK)) {\n        StatsIncr(tv, stt->counter_tcp_synack);\n    } else if (p->tcph->th_flags & (TH_SYN)) {\n        StatsIncr(tv, stt->counter_tcp_syn);\n    }\n    if (p->tcph->th_flags & (TH_RST)) {\n        StatsIncr(tv, stt->counter_tcp_rst);\n    }\n\n    /* broken TCP http://ask.wireshark.org/questions/3183/acknowledgment-number-broken-tcp-the-acknowledge-field-is-nonzero-while-the-ack-flag-is-not-set */\n    if (!(p->tcph->th_flags & TH_ACK) && TCP_GET_ACK(p) != 0) {\n        StreamTcpSetEvent(p, STREAM_PKT_BROKEN_ACK);\n    }\n\n    /* If we are on IPS mode, and got a drop action triggered from\n     * the IP only module, or from a reassembled msg and/or from an\n     * applayer detection, then drop the rest of the packets of the\n     * same stream and avoid inspecting it any further */\n    if (StreamTcpCheckFlowDrops(p) == 1) {\n        SCLogDebug(\"This flow/stream triggered a drop rule\");\n        FlowSetNoPacketInspectionFlag(p->flow);\n        DecodeSetNoPacketInspectionFlag(p);\n        StreamTcpDisableAppLayer(p->flow);\n        PACKET_DROP(p);\n        /* return the segments to the pool */\n        StreamTcpSessionPktFree(p);\n        SCReturnInt(0);\n    }\n\n    if (ssn == NULL || ssn->state == TCP_NONE) {\n        if (StreamTcpPacketStateNone(tv, p, stt, ssn, &stt->pseudo_queue) == -1) {\n            goto error;\n        }\n\n        if (ssn != NULL)\n            SCLogDebug(\"ssn->alproto %\"PRIu16\"\", p->flow->alproto);\n    } else {\n        /* special case for PKT_PSEUDO_STREAM_END packets:\n         * bypass the state handling and various packet checks,\n         * we care about reassembly here. */\n        if (p->flags & PKT_PSEUDO_STREAM_END) {\n            if (PKT_IS_TOCLIENT(p)) {\n                ssn->client.last_ack = TCP_GET_ACK(p);\n                StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                        &ssn->server, p, pq);\n            } else {\n                ssn->server.last_ack = TCP_GET_ACK(p);\n                StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                        &ssn->client, p, pq);\n            }\n            /* straight to 'skip' as we already handled reassembly */\n            goto skip;\n        }\n\n        /* check if the packet is in right direction, when we missed the\n           SYN packet and picked up midstream session. */\n        if (ssn->flags & STREAMTCP_FLAG_MIDSTREAM_SYNACK)\n            StreamTcpPacketSwitchDir(ssn, p);\n\n        if (StreamTcpPacketIsKeepAlive(ssn, p) == 1) {\n            goto skip;\n        }\n        if (StreamTcpPacketIsKeepAliveACK(ssn, p) == 1) {\n            StreamTcpClearKeepAliveFlag(ssn, p);\n            goto skip;\n        }\n        StreamTcpClearKeepAliveFlag(ssn, p);\n\n        /* if packet is not a valid window update, check if it is perhaps\n         * a bad window update that we should ignore (and alert on) */\n        if (StreamTcpPacketIsFinShutdownAck(ssn, p) == 0)\n            if (StreamTcpPacketIsWindowUpdate(ssn, p) == 0)\n                if (StreamTcpPacketIsBadWindowUpdate(ssn,p))\n                    goto skip;\n\n        switch (ssn->state) {\n            case TCP_SYN_SENT:\n                if(StreamTcpPacketStateSynSent(tv, p, stt, ssn, &stt->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case TCP_SYN_RECV:\n                if(StreamTcpPacketStateSynRecv(tv, p, stt, ssn, &stt->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case TCP_ESTABLISHED:\n                if(StreamTcpPacketStateEstablished(tv, p, stt, ssn, &stt->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case TCP_FIN_WAIT1:\n                if(StreamTcpPacketStateFinWait1(tv, p, stt, ssn, &stt->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case TCP_FIN_WAIT2:\n                if(StreamTcpPacketStateFinWait2(tv, p, stt, ssn, &stt->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case TCP_CLOSING:\n                if(StreamTcpPacketStateClosing(tv, p, stt, ssn, &stt->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case TCP_CLOSE_WAIT:\n                if(StreamTcpPacketStateCloseWait(tv, p, stt, ssn, &stt->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case TCP_LAST_ACK:\n                if(StreamTcpPacketStateLastAck(tv, p, stt, ssn, &stt->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case TCP_TIME_WAIT:\n                if(StreamTcpPacketStateTimeWait(tv, p, stt, ssn, &stt->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case TCP_CLOSED:\n                /* TCP session memory is not returned to pool until timeout. */\n                SCLogDebug(\"packet received on closed state\");\n                break;\n            default:\n                SCLogDebug(\"packet received on default state\");\n                break;\n        }\n    skip:\n\n        if (ssn->state >= TCP_ESTABLISHED) {\n            p->flags |= PKT_STREAM_EST;\n        }\n    }\n\n    /* deal with a pseudo packet that is created upon receiving a RST\n     * segment. To be sure we process both sides of the connection, we\n     * inject a fake packet into the system, forcing reassembly of the\n     * opposing direction.\n     * There should be only one, but to be sure we do a while loop. */\n    if (ssn != NULL) {\n        while (stt->pseudo_queue.len > 0) {\n            SCLogDebug(\"processing pseudo packet / stream end\");\n            Packet *np = PacketDequeue(&stt->pseudo_queue);\n            if (np != NULL) {\n                /* process the opposing direction of the original packet */\n                if (PKT_IS_TOSERVER(np)) {\n                    SCLogDebug(\"pseudo packet is to server\");\n                    StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                            &ssn->client, np, NULL);\n                } else {\n                    SCLogDebug(\"pseudo packet is to client\");\n                    StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                            &ssn->server, np, NULL);\n                }\n\n                /* enqueue this packet so we inspect it in detect etc */\n                PacketEnqueue(pq, np);\n            }\n            SCLogDebug(\"processing pseudo packet / stream end done\");\n        }\n\n        /* recalc the csum on the packet if it was modified */\n        if (p->flags & PKT_STREAM_MODIFIED) {\n            ReCalculateChecksum(p);\n        }\n\n        /* check for conditions that may make us not want to log this packet */\n\n        /* streams that hit depth */\n        if ((ssn->client.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED) &&\n             (ssn->server.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED))\n        {\n            /* we can call bypass callback, if enabled */\n            if (StreamTcpBypassEnabled()) {\n                PacketBypassCallback(p);\n            }\n        }\n\n        if ((ssn->client.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED) ||\n             (ssn->server.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED))\n        {\n            p->flags |= PKT_STREAM_NOPCAPLOG;\n        }\n\n        /* encrypted packets */\n        if ((PKT_IS_TOSERVER(p) && (ssn->client.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY)) ||\n            (PKT_IS_TOCLIENT(p) && (ssn->server.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY)))\n        {\n            p->flags |= PKT_STREAM_NOPCAPLOG;\n        }\n\n        if (ssn->flags & STREAMTCP_FLAG_BYPASS) {\n            /* we can call bypass callback, if enabled */\n            if (StreamTcpBypassEnabled()) {\n                PacketBypassCallback(p);\n            }\n\n        /* if stream is dead and we have no detect engine at all, bypass. */\n        } else if (g_detect_disabled &&\n                (ssn->client.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY) &&\n                (ssn->server.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY) &&\n                StreamTcpBypassEnabled())\n        {\n            SCLogDebug(\"bypass as stream is dead and we have no rules\");\n            PacketBypassCallback(p);\n        }\n    }\n\n    SCReturnInt(0);\n\nerror:\n    /* make sure we don't leave packets in our pseudo queue */\n    while (stt->pseudo_queue.len > 0) {\n        Packet *np = PacketDequeue(&stt->pseudo_queue);\n        if (np != NULL) {\n            PacketEnqueue(pq, np);\n        }\n    }\n\n    /* recalc the csum on the packet if it was modified */\n    if (p->flags & PKT_STREAM_MODIFIED) {\n        ReCalculateChecksum(p);\n    }\n\n    if (StreamTcpInlineDropInvalid()) {\n        /* disable payload inspection as we're dropping this packet\n         * anyway. Doesn't disable all detection, so we can still\n         * match on the stream event that was set. */\n        DecodeSetNoPayloadInspectionFlag(p);\n        PACKET_DROP(p);\n    }\n    SCReturnInt(-1);\n}",
  "abstract_func": "int StreamTcpPacket (ThreadVars *VAR_0, Packet *VAR_1, StreamTcpThread *VAR_2,\n                     PacketQueue *VAR_3)\n{\n    SCEnter();\n\n    DEBUG_ASSERT_FLOW_LOCKED(VAR_1->flow);\n\n    SCLogDebug(\"p->pcap_cnt %\"VAR_4, VAR_1->pcap_cnt);\n\n    /* COMMENT_0 */\n    if (unlikely(VAR_1->flow->thread_id == 0)) {\n        VAR_1->flow->thread_id = (FlowThreadId)VAR_0->id;\n#ifdef VAR_5\n    } else if (unlikely((FlowThreadId)VAR_0->id != VAR_1->flow->thread_id)) {\n        SCLogDebug(\"wrong thread: flow has %u, we are %d\", VAR_1->flow->thread_id, VAR_0->id);\n#endif\n    }\n\n    TcpSession *VAR_6 = (TcpSession *)VAR_1->flow->protoctx;\n\n    /* COMMENT_1 */\n    if (VAR_6 != NULL) {\n        VAR_6->tcp_packet_flags |= VAR_1->tcph->th_flags;\n        if (PKT_IS_TOSERVER(VAR_1))\n            VAR_6->client.tcp_flags |= VAR_1->tcph->th_flags;\n        else if (PKT_IS_TOCLIENT(VAR_1))\n            VAR_6->server.tcp_flags |= VAR_1->tcph->th_flags;\n\n        /* COMMENT_2 */\n        if (VAR_6->flags & VAR_7 &&\n            VAR_6->client.tcp_flags != 0 &&\n            VAR_6->server.tcp_flags != 0)\n        {\n            SCLogDebug(\"ssn %p: removing ASYNC flag as we have packets on both sides\", VAR_6);\n            VAR_6->flags &= ~VAR_7;\n        }\n    }\n\n    /* COMMENT_3 */\n    if ((VAR_1->tcph->th_flags & (VAR_8|VAR_9)) == (VAR_8|VAR_9)) {\n        StatsIncr(VAR_0, VAR_2->counter_tcp_synack);\n    } else if (VAR_1->tcph->th_flags & (VAR_8)) {\n        StatsIncr(VAR_0, VAR_2->counter_tcp_syn);\n    }\n    if (VAR_1->tcph->th_flags & (VAR_10)) {\n        StatsIncr(VAR_0, VAR_2->counter_tcp_rst);\n    }\n\n    /* COMMENT_4 */\n    if (!(VAR_1->tcph->th_flags & VAR_9) && TCP_GET_ACK(VAR_1) != 0) {\n        StreamTcpSetEvent(VAR_1, VAR_11);\n    }\n\n    /* COMMENT_5 */\n                                                                   \n                                                                   \n                                                         \n    if (StreamTcpCheckFlowDrops(VAR_1) == 1) {\n        SCLogDebug(\"This flow/stream triggered a drop rule\");\n        FlowSetNoPacketInspectionFlag(VAR_1->flow);\n        DecodeSetNoPacketInspectionFlag(VAR_1);\n        StreamTcpDisableAppLayer(VAR_1->flow);\n        PACKET_DROP(VAR_1);\n        /* COMMENT_9 */\n        StreamTcpSessionPktFree(VAR_1);\n        SCReturnInt(0);\n    }\n\n    if (VAR_6 == NULL || VAR_6->state == VAR_12) {\n        if (StreamTcpPacketStateNone(VAR_0, VAR_1, VAR_2, VAR_6, &VAR_2->pseudo_queue) == -1) {\n            goto error;\n        }\n\n        if (VAR_6 != NULL)\n            SCLogDebug(\"ssn->alproto %\"VAR_13\"\", VAR_1->flow->alproto);\n    } else {\n        /* COMMENT_10 */\n                                                               \n                                            \n        if (VAR_1->flags & VAR_14) {\n            if (PKT_IS_TOCLIENT(VAR_1)) {\n                VAR_6->client.last_ack = TCP_GET_ACK(VAR_1);\n                StreamTcpReassembleHandleSegment(VAR_0, VAR_2->ra_ctx, VAR_6,\n                        &VAR_6->server, VAR_1, VAR_3);\n            } else {\n                VAR_6->server.last_ack = TCP_GET_ACK(VAR_1);\n                StreamTcpReassembleHandleSegment(VAR_0, VAR_2->ra_ctx, VAR_6,\n                        &VAR_6->client, VAR_1, VAR_3);\n            }\n            /* COMMENT_13 */\n            goto skip;\n        }\n\n        /* COMMENT_14 */\n                                                         \n        if (VAR_6->flags & VAR_15)\n            StreamTcpPacketSwitchDir(VAR_6, VAR_1);\n\n        if (StreamTcpPacketIsKeepAlive(VAR_6, VAR_1) == 1) {\n            goto skip;\n        }\n        if (StreamTcpPacketIsKeepAliveACK(VAR_6, VAR_1) == 1) {\n            StreamTcpClearKeepAliveFlag(VAR_6, VAR_1);\n            goto skip;\n        }\n        StreamTcpClearKeepAliveFlag(VAR_6, VAR_1);\n\n        /* COMMENT_16 */\n                                                                      \n        if (StreamTcpPacketIsFinShutdownAck(VAR_6, VAR_1) == 0)\n            if (StreamTcpPacketIsWindowUpdate(VAR_6, VAR_1) == 0)\n                if (StreamTcpPacketIsBadWindowUpdate(VAR_6,VAR_1))\n                    goto skip;\n\n        switch (VAR_6->state) {\n            case VAR_16:\n                if(StreamTcpPacketStateSynSent(VAR_0, VAR_1, VAR_2, VAR_6, &VAR_2->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case VAR_17:\n                if(StreamTcpPacketStateSynRecv(VAR_0, VAR_1, VAR_2, VAR_6, &VAR_2->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case VAR_18:\n                if(StreamTcpPacketStateEstablished(VAR_0, VAR_1, VAR_2, VAR_6, &VAR_2->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case VAR_19:\n                if(StreamTcpPacketStateFinWait1(VAR_0, VAR_1, VAR_2, VAR_6, &VAR_2->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case VAR_20:\n                if(StreamTcpPacketStateFinWait2(VAR_0, VAR_1, VAR_2, VAR_6, &VAR_2->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case VAR_21:\n                if(StreamTcpPacketStateClosing(VAR_0, VAR_1, VAR_2, VAR_6, &VAR_2->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case VAR_22:\n                if(StreamTcpPacketStateCloseWait(VAR_0, VAR_1, VAR_2, VAR_6, &VAR_2->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case VAR_23:\n                if(StreamTcpPacketStateLastAck(VAR_0, VAR_1, VAR_2, VAR_6, &VAR_2->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case VAR_24:\n                if(StreamTcpPacketStateTimeWait(VAR_0, VAR_1, VAR_2, VAR_6, &VAR_2->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case VAR_25:\n                /* COMMENT_18 */\n                SCLogDebug(\"packet received on closed state\");\n                break;\n            default:\n                SCLogDebug(\"packet received on default state\");\n                break;\n        }\n    skip:\n\n        if (VAR_6->state >= VAR_18) {\n            VAR_1->flags |= VAR_26;\n        }\n    }\n\n    /* COMMENT_19 */\n                                                                      \n                                                                      \n                          \n                                                                      \n    if (VAR_6 != NULL) {\n        while (VAR_2->pseudo_queue.len > 0) {\n            SCLogDebug(\"processing pseudo packet / stream end\");\n            Packet *VAR_27 = PacketDequeue(&VAR_2->pseudo_queue);\n            if (VAR_27 != NULL) {\n                /* COMMENT_24 */\n                if (PKT_IS_TOSERVER(VAR_27)) {\n                    SCLogDebug(\"pseudo packet is to server\");\n                    StreamTcpReassembleHandleSegment(VAR_0, VAR_2->ra_ctx, VAR_6,\n                            &VAR_6->client, VAR_27, NULL);\n                } else {\n                    SCLogDebug(\"pseudo packet is to client\");\n                    StreamTcpReassembleHandleSegment(VAR_0, VAR_2->ra_ctx, VAR_6,\n                            &VAR_6->server, VAR_27, NULL);\n                }\n\n                /* COMMENT_25 */\n                PacketEnqueue(VAR_3, VAR_27);\n            }\n            SCLogDebug(\"processing pseudo packet / stream end done\");\n        }\n\n        /* COMMENT_26 */\n        if (VAR_1->flags & VAR_28) {\n            ReCalculateChecksum(VAR_1);\n        }\n\n        /* COMMENT_27 */\n\n        /* COMMENT_28 */\n        if ((VAR_6->client.flags & VAR_29) &&\n             (VAR_6->server.flags & VAR_29))\n        {\n            /* COMMENT_29 */\n            if (StreamTcpBypassEnabled()) {\n                PacketBypassCallback(VAR_1);\n            }\n        }\n\n        if ((VAR_6->client.flags & VAR_29) ||\n             (VAR_6->server.flags & VAR_29))\n        {\n            VAR_1->flags |= VAR_30;\n        }\n\n        /* COMMENT_30 */\n        if ((PKT_IS_TOSERVER(VAR_1) && (VAR_6->client.flags & VAR_31)) ||\n            (PKT_IS_TOCLIENT(VAR_1) && (VAR_6->server.flags & VAR_31)))\n        {\n            VAR_1->flags |= VAR_30;\n        }\n\n        if (VAR_6->flags & VAR_32) {\n            /* COMMENT_29 */\n            if (StreamTcpBypassEnabled()) {\n                PacketBypassCallback(VAR_1);\n            }\n\n        /* COMMENT_31 */\n        } else if (VAR_33 &&\n                (VAR_6->client.flags & VAR_31) &&\n                (VAR_6->server.flags & VAR_31) &&\n                StreamTcpBypassEnabled())\n        {\n            SCLogDebug(\"bypass as stream is dead and we have no rules\");\n            PacketBypassCallback(VAR_1);\n        }\n    }\n\n    SCReturnInt(0);\n\nerror:\n    /* COMMENT_32 */\n    while (VAR_2->pseudo_queue.len > 0) {\n        Packet *VAR_27 = PacketDequeue(&VAR_2->pseudo_queue);\n        if (VAR_27 != NULL) {\n            PacketEnqueue(VAR_3, VAR_27);\n        }\n    }\n\n    /* COMMENT_26 */\n    if (VAR_1->flags & VAR_28) {\n        ReCalculateChecksum(VAR_1);\n    }\n\n    if (StreamTcpInlineDropInvalid()) {\n        /* COMMENT_33 */\n                                                                 \n                                                     \n        DecodeSetNoPayloadInspectionFlag(VAR_1);\n        PACKET_DROP(VAR_1);\n    }\n    SCReturnInt(-1);\n}",
  "func_graph_path": "OISF/suricata/e1ef57c848bbe4e567d5d4b66d346a742e3f77a1/stream-tcp.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -264,6 +264,10 @@\n     }\n \n     if (StreamTcpInlineDropInvalid()) {\n+        /* disable payload inspection as we're dropping this packet\n+         * anyway. Doesn't disable all detection, so we can still\n+         * match on the stream event that was set. */\n+        DecodeSetNoPayloadInspectionFlag(p);\n         PACKET_DROP(p);\n     }\n     SCReturnInt(-1);",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "        /* disable payload inspection as we're dropping this packet",
      "         * anyway. Doesn't disable all detection, so we can still",
      "         * match on the stream event that was set. */",
      "        DecodeSetNoPayloadInspectionFlag(p);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/OISF/suricata/pull/3201",
  "description": {
    "pr_info": {
      "title": "Next/20180129/v12",
      "number": 3201
    },
    "comment": [
      "Supports HTTP pickup by response. Requires https://github.com/OISF/libhtp/pull/163\r\nImproves NFS file handling.\r\nAdds the metadata work from #3198\r\nAdds doc updates from #3194\r\nAdds TFTP logging from #3185\r\n\r\nhttps://redmine.openinfosecfoundation.org/issues/993\r\nhttps://redmine.openinfosecfoundation.org/issues/2391\r\nhttps://redmine.openinfosecfoundation.org/issues/2427\r\n\r\n[PRScript](https://redmine.openinfosecfoundation.org/projects/suricata/wiki/PRscript) output (if applicable):\r\n- PR victorjulien-pcap: https://buildbot.openinfosecfoundation.org/builders/victorjulien-pcap/builds/81\r\n- PR victorjulien: https://buildbot.openinfosecfoundation.org/builders/victorjulien/builds/83\r\n"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.8  \n\nThe patch addresses a logic issue where certain packets were incorrectly bypassed, leading to missed stream events. It's a core logic fix without security implications."
}