{
  "cve_id": "CVE-2017-3733",
  "cwe_ids": [
    "CWE-20"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "openssl",
  "commit_msg": "Don't change the state of the ETM flags until CCS processing\n\nChanging the ciphersuite during a renegotiation can result in a crash\nleading to a DoS attack. ETM has not been implemented in 1.1.0 for DTLS\nso this is TLS only.\n\nThe problem is caused by changing the flag indicating whether to use ETM\nor not immediately on negotiation of ETM, rather than at CCS. Therefore,\nduring a renegotiation, if the ETM state is changing (usually due to a\nchange of ciphersuite), then an error/crash will occur.\n\nDue to the fact that there are separate CCS messages for read and write\nwe actually now need two flags to determine whether to use ETM or not.\n\nCVE-2017-3733\n\nReviewed-by: Richard Levitte <levitte@openssl.org>",
  "commit_hash": "4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2",
  "git_url": "https://github.com/openssl/openssl/commit/4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2",
  "file_path": "ssl/record/ssl3_record.c",
  "func_name": "tls1_enc",
  "func_before": "int tls1_enc(SSL *s, SSL3_RECORD *recs, unsigned int n_recs, int send)\n{\n    EVP_CIPHER_CTX *ds;\n    size_t reclen[SSL_MAX_PIPELINES];\n    unsigned char buf[SSL_MAX_PIPELINES][EVP_AEAD_TLS1_AAD_LEN];\n    int bs, i, j, k, pad = 0, ret, mac_size = 0;\n    const EVP_CIPHER *enc;\n    unsigned int ctr;\n\n    if (send) {\n        if (EVP_MD_CTX_md(s->write_hash)) {\n            int n = EVP_MD_CTX_size(s->write_hash);\n            OPENSSL_assert(n >= 0);\n        }\n        ds = s->enc_write_ctx;\n        if (s->enc_write_ctx == NULL)\n            enc = NULL;\n        else {\n            int ivlen;\n            enc = EVP_CIPHER_CTX_cipher(s->enc_write_ctx);\n            /* For TLSv1.1 and later explicit IV */\n            if (SSL_USE_EXPLICIT_IV(s)\n                && EVP_CIPHER_mode(enc) == EVP_CIPH_CBC_MODE)\n                ivlen = EVP_CIPHER_iv_length(enc);\n            else\n                ivlen = 0;\n            if (ivlen > 1) {\n                for (ctr = 0; ctr < n_recs; ctr++) {\n                    if (recs[ctr].data != recs[ctr].input) {\n                        /*\n                         * we can't write into the input stream: Can this ever\n                         * happen?? (steve)\n                         */\n                        SSLerr(SSL_F_TLS1_ENC, ERR_R_INTERNAL_ERROR);\n                        return -1;\n                    } else if (RAND_bytes(recs[ctr].input, ivlen) <= 0) {\n                        SSLerr(SSL_F_TLS1_ENC, ERR_R_INTERNAL_ERROR);\n                        return -1;\n                    }\n                }\n            }\n        }\n    } else {\n        if (EVP_MD_CTX_md(s->read_hash)) {\n            int n = EVP_MD_CTX_size(s->read_hash);\n            OPENSSL_assert(n >= 0);\n        }\n        ds = s->enc_read_ctx;\n        if (s->enc_read_ctx == NULL)\n            enc = NULL;\n        else\n            enc = EVP_CIPHER_CTX_cipher(s->enc_read_ctx);\n    }\n\n    if ((s->session == NULL) || (ds == NULL) || (enc == NULL)) {\n        for (ctr = 0; ctr < n_recs; ctr++) {\n            memmove(recs[ctr].data, recs[ctr].input, recs[ctr].length);\n            recs[ctr].input = recs[ctr].data;\n        }\n        ret = 1;\n    } else {\n        bs = EVP_CIPHER_block_size(EVP_CIPHER_CTX_cipher(ds));\n\n        if (n_recs > 1) {\n            if (!(EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(ds))\n                  & EVP_CIPH_FLAG_PIPELINE)) {\n                /*\n                 * We shouldn't have been called with pipeline data if the\n                 * cipher doesn't support pipelining\n                 */\n                SSLerr(SSL_F_TLS1_ENC, SSL_R_PIPELINE_FAILURE);\n                return -1;\n            }\n        }\n        for (ctr = 0; ctr < n_recs; ctr++) {\n            reclen[ctr] = recs[ctr].length;\n\n            if (EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(ds))\n                & EVP_CIPH_FLAG_AEAD_CIPHER) {\n                unsigned char *seq;\n\n                seq = send ? RECORD_LAYER_get_write_sequence(&s->rlayer)\n                    : RECORD_LAYER_get_read_sequence(&s->rlayer);\n\n                if (SSL_IS_DTLS(s)) {\n                    /* DTLS does not support pipelining */\n                    unsigned char dtlsseq[9], *p = dtlsseq;\n\n                    s2n(send ? DTLS_RECORD_LAYER_get_w_epoch(&s->rlayer) :\n                        DTLS_RECORD_LAYER_get_r_epoch(&s->rlayer), p);\n                    memcpy(p, &seq[2], 6);\n                    memcpy(buf[ctr], dtlsseq, 8);\n                } else {\n                    memcpy(buf[ctr], seq, 8);\n                    for (i = 7; i >= 0; i--) { /* increment */\n                        ++seq[i];\n                        if (seq[i] != 0)\n                            break;\n                    }\n                }\n\n                buf[ctr][8] = recs[ctr].type;\n                buf[ctr][9] = (unsigned char)(s->version >> 8);\n                buf[ctr][10] = (unsigned char)(s->version);\n                buf[ctr][11] = recs[ctr].length >> 8;\n                buf[ctr][12] = recs[ctr].length & 0xff;\n                pad = EVP_CIPHER_CTX_ctrl(ds, EVP_CTRL_AEAD_TLS1_AAD,\n                                          EVP_AEAD_TLS1_AAD_LEN, buf[ctr]);\n                if (pad <= 0)\n                    return -1;\n\n                if (send) {\n                    reclen[ctr] += pad;\n                    recs[ctr].length += pad;\n                }\n\n            } else if ((bs != 1) && send) {\n                i = bs - ((int)reclen[ctr] % bs);\n\n                /* Add weird padding of upto 256 bytes */\n\n                /* we need to add 'i' padding bytes of value j */\n                j = i - 1;\n                for (k = (int)reclen[ctr]; k < (int)(reclen[ctr] + i); k++)\n                    recs[ctr].input[k] = j;\n                reclen[ctr] += i;\n                recs[ctr].length += i;\n            }\n\n            if (!send) {\n                if (reclen[ctr] == 0 || reclen[ctr] % bs != 0)\n                    return 0;\n            }\n        }\n        if (n_recs > 1) {\n            unsigned char *data[SSL_MAX_PIPELINES];\n\n            /* Set the output buffers */\n            for (ctr = 0; ctr < n_recs; ctr++) {\n                data[ctr] = recs[ctr].data;\n            }\n            if (EVP_CIPHER_CTX_ctrl(ds, EVP_CTRL_SET_PIPELINE_OUTPUT_BUFS,\n                                    n_recs, data) <= 0) {\n                SSLerr(SSL_F_TLS1_ENC, SSL_R_PIPELINE_FAILURE);\n            }\n            /* Set the input buffers */\n            for (ctr = 0; ctr < n_recs; ctr++) {\n                data[ctr] = recs[ctr].input;\n            }\n            if (EVP_CIPHER_CTX_ctrl(ds, EVP_CTRL_SET_PIPELINE_INPUT_BUFS,\n                                    n_recs, data) <= 0\n                || EVP_CIPHER_CTX_ctrl(ds, EVP_CTRL_SET_PIPELINE_INPUT_LENS,\n                                       n_recs, reclen) <= 0) {\n                SSLerr(SSL_F_TLS1_ENC, SSL_R_PIPELINE_FAILURE);\n                return -1;\n            }\n        }\n\n        i = EVP_Cipher(ds, recs[0].data, recs[0].input, reclen[0]);\n        if ((EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(ds))\n             & EVP_CIPH_FLAG_CUSTOM_CIPHER)\n            ? (i < 0)\n            : (i == 0))\n            return -1;          /* AEAD can fail to verify MAC */\n        if (send == 0) {\n            if (EVP_CIPHER_mode(enc) == EVP_CIPH_GCM_MODE) {\n                for (ctr = 0; ctr < n_recs; ctr++) {\n                    recs[ctr].data += EVP_GCM_TLS_EXPLICIT_IV_LEN;\n                    recs[ctr].input += EVP_GCM_TLS_EXPLICIT_IV_LEN;\n                    recs[ctr].length -= EVP_GCM_TLS_EXPLICIT_IV_LEN;\n                }\n            } else if (EVP_CIPHER_mode(enc) == EVP_CIPH_CCM_MODE) {\n                for (ctr = 0; ctr < n_recs; ctr++) {\n                    recs[ctr].data += EVP_CCM_TLS_EXPLICIT_IV_LEN;\n                    recs[ctr].input += EVP_CCM_TLS_EXPLICIT_IV_LEN;\n                    recs[ctr].length -= EVP_CCM_TLS_EXPLICIT_IV_LEN;\n                }\n            }\n        }\n\n        ret = 1;\n        if (!SSL_USE_ETM(s) && EVP_MD_CTX_md(s->read_hash) != NULL)\n            mac_size = EVP_MD_CTX_size(s->read_hash);\n        if ((bs != 1) && !send) {\n            int tmpret;\n            for (ctr = 0; ctr < n_recs; ctr++) {\n                tmpret = tls1_cbc_remove_padding(s, &recs[ctr], bs, mac_size);\n                /*\n                 * If tmpret == 0 then this means publicly invalid so we can\n                 * short circuit things here. Otherwise we must respect constant\n                 * time behaviour.\n                 */\n                if (tmpret == 0)\n                    return 0;\n                ret = constant_time_select_int(constant_time_eq_int(tmpret, 1),\n                                               ret, -1);\n            }\n        }\n        if (pad && !send) {\n            for (ctr = 0; ctr < n_recs; ctr++) {\n                recs[ctr].length -= pad;\n            }\n        }\n    }\n    return ret;\n}",
  "abstract_func_before": "int tls1_enc(SSL *VAR_0, SSL3_RECORD *VAR_1, unsigned int VAR_2, int VAR_3)\n{\n    EVP_CIPHER_CTX *VAR_4;\n    size_t VAR_5[VAR_6];\n    unsigned char VAR_7[VAR_6][VAR_8];\n    int VAR_9, VAR_10, VAR_11, VAR_12, VAR_13 = 0, VAR_14, VAR_15 = 0;\n    const EVP_CIPHER *VAR_16;\n    unsigned int VAR_17;\n\n    if (VAR_3) {\n        if (EVP_MD_CTX_md(VAR_0->write_hash)) {\n            int VAR_18 = EVP_MD_CTX_size(VAR_0->write_hash);\n            OPENSSL_assert(VAR_18 >= 0);\n        }\n        VAR_4 = VAR_0->enc_write_ctx;\n        if (VAR_0->enc_write_ctx == NULL)\n            VAR_16 = NULL;\n        else {\n            int VAR_19;\n            VAR_16 = EVP_CIPHER_CTX_cipher(VAR_0->enc_write_ctx);\n            /* COMMENT_0 */\n            if (SSL_USE_EXPLICIT_IV(VAR_0)\n                && EVP_CIPHER_mode(VAR_16) == VAR_20)\n                VAR_19 = EVP_CIPHER_iv_length(VAR_16);\n            else\n                VAR_19 = 0;\n            if (VAR_19 > 1) {\n                for (VAR_17 = 0; VAR_17 < VAR_2; VAR_17++) {\n                    if (VAR_1[VAR_17].data != VAR_1[VAR_17].input) {\n                        /* COMMENT_1 */\n                                                                              \n                                           \n                           \n                        SSLerr(VAR_21, VAR_22);\n                        return -1;\n                    } else if (RAND_bytes(VAR_1[VAR_17].input, VAR_19) <= 0) {\n                        SSLerr(VAR_21, VAR_22);\n                        return -1;\n                    }\n                }\n            }\n        }\n    } else {\n        if (EVP_MD_CTX_md(VAR_0->read_hash)) {\n            int VAR_18 = EVP_MD_CTX_size(VAR_0->read_hash);\n            OPENSSL_assert(VAR_18 >= 0);\n        }\n        VAR_4 = VAR_0->enc_read_ctx;\n        if (VAR_0->enc_read_ctx == NULL)\n            VAR_16 = NULL;\n        else\n            VAR_16 = EVP_CIPHER_CTX_cipher(VAR_0->enc_read_ctx);\n    }\n\n    if ((VAR_0->session == NULL) || (VAR_4 == NULL) || (VAR_16 == NULL)) {\n        for (VAR_17 = 0; VAR_17 < VAR_2; VAR_17++) {\n            memmove(VAR_1[VAR_17].data, VAR_1[VAR_17].input, VAR_1[VAR_17].length);\n            VAR_1[VAR_17].input = VAR_1[VAR_17].data;\n        }\n        VAR_14 = 1;\n    } else {\n        VAR_9 = EVP_CIPHER_block_size(EVP_CIPHER_CTX_cipher(VAR_4));\n\n        if (VAR_2 > 1) {\n            if (!(EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(VAR_4))\n                  & VAR_23)) {\n                /* COMMENT_5 */\n                                                                          \n                                                    \n                   \n                SSLerr(VAR_21, VAR_24);\n                return -1;\n            }\n        }\n        for (VAR_17 = 0; VAR_17 < VAR_2; VAR_17++) {\n            VAR_5[VAR_17] = VAR_1[VAR_17].length;\n\n            if (EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(VAR_4))\n                & VAR_25) {\n                unsigned char *VAR_26;\n\n                VAR_26 = VAR_3 ? RECORD_LAYER_get_write_sequence(&VAR_0->rlayer)\n                    : RECORD_LAYER_get_read_sequence(&VAR_0->rlayer);\n\n                if (SSL_IS_DTLS(VAR_0)) {\n                    /* COMMENT_9 */\n                    unsigned char VAR_27[9], *VAR_28 = VAR_27;\n\n                    s2n(VAR_3 ? DTLS_RECORD_LAYER_get_w_epoch(&VAR_0->rlayer) :\n                        DTLS_RECORD_LAYER_get_r_epoch(&VAR_0->rlayer), VAR_28);\n                    memcpy(VAR_28, &VAR_26[2], 6);\n                    memcpy(VAR_7[VAR_17], VAR_27, 8);\n                } else {\n                    memcpy(VAR_7[VAR_17], VAR_26, 8);\n                    for (VAR_10 = 7; VAR_10 >= 0; VAR_10--) { /* COMMENT_10 */\n                        ++VAR_26[VAR_10];\n                        if (VAR_26[VAR_10] != 0)\n                            break;\n                    }\n                }\n\n                VAR_7[VAR_17][8] = VAR_1[VAR_17].type;\n                VAR_7[VAR_17][9] = (unsigned char)(VAR_0->version >> 8);\n                VAR_7[VAR_17][10] = (unsigned char)(VAR_0->version);\n                VAR_7[VAR_17][11] = VAR_1[VAR_17].length >> 8;\n                VAR_7[VAR_17][12] = VAR_1[VAR_17].length & 0xff;\n                VAR_13 = EVP_CIPHER_CTX_ctrl(VAR_4, VAR_29,\n                                          VAR_8, VAR_7[VAR_17]);\n                if (VAR_13 <= 0)\n                    return -1;\n\n                if (VAR_3) {\n                    VAR_5[VAR_17] += VAR_13;\n                    VAR_1[VAR_17].length += VAR_13;\n                }\n\n            } else if ((VAR_9 != 1) && VAR_3) {\n                VAR_10 = VAR_9 - ((int)VAR_5[VAR_17] % VAR_9);\n\n                /* COMMENT_11 */\n\n                /* COMMENT_12 */\n                VAR_11 = VAR_10 - 1;\n                for (VAR_12 = (int)VAR_5[VAR_17]; VAR_12 < (int)(VAR_5[VAR_17] + VAR_10); VAR_12++)\n                    VAR_1[VAR_17].input[VAR_12] = VAR_11;\n                VAR_5[VAR_17] += VAR_10;\n                VAR_1[VAR_17].length += VAR_10;\n            }\n\n            if (!VAR_3) {\n                if (VAR_5[VAR_17] == 0 || VAR_5[VAR_17] % VAR_9 != 0)\n                    return 0;\n            }\n        }\n        if (VAR_2 > 1) {\n            unsigned char *VAR_30[VAR_6];\n\n            /* COMMENT_13 */\n            for (VAR_17 = 0; VAR_17 < VAR_2; VAR_17++) {\n                VAR_30[VAR_17] = VAR_1[VAR_17].data;\n            }\n            if (EVP_CIPHER_CTX_ctrl(VAR_4, VAR_31,\n                                    VAR_2, VAR_30) <= 0) {\n                SSLerr(VAR_21, VAR_24);\n            }\n            /* COMMENT_14 */\n            for (VAR_17 = 0; VAR_17 < VAR_2; VAR_17++) {\n                VAR_30[VAR_17] = VAR_1[VAR_17].input;\n            }\n            if (EVP_CIPHER_CTX_ctrl(VAR_4, VAR_32,\n                                    VAR_2, VAR_30) <= 0\n                || EVP_CIPHER_CTX_ctrl(VAR_4, VAR_33,\n                                       VAR_2, VAR_5) <= 0) {\n                SSLerr(VAR_21, VAR_24);\n                return -1;\n            }\n        }\n\n        VAR_10 = EVP_Cipher(VAR_4, VAR_1[0].data, VAR_1[0].input, VAR_5[0]);\n        if ((EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(VAR_4))\n             & VAR_34)\n            ? (VAR_10 < 0)\n            : (VAR_10 == 0))\n            return -1;          /* COMMENT_15 */\n        if (VAR_3 == 0) {\n            if (EVP_CIPHER_mode(VAR_16) == VAR_35) {\n                for (VAR_17 = 0; VAR_17 < VAR_2; VAR_17++) {\n                    VAR_1[VAR_17].data += VAR_36;\n                    VAR_1[VAR_17].input += VAR_36;\n                    VAR_1[VAR_17].length -= VAR_36;\n                }\n            } else if (EVP_CIPHER_mode(VAR_16) == VAR_37) {\n                for (VAR_17 = 0; VAR_17 < VAR_2; VAR_17++) {\n                    VAR_1[VAR_17].data += VAR_38;\n                    VAR_1[VAR_17].input += VAR_38;\n                    VAR_1[VAR_17].length -= VAR_38;\n                }\n            }\n        }\n\n        VAR_14 = 1;\n        if (!SSL_USE_ETM(VAR_0) && EVP_MD_CTX_md(VAR_0->read_hash) != NULL)\n            VAR_15 = EVP_MD_CTX_size(VAR_0->read_hash);\n        if ((VAR_9 != 1) && !VAR_3) {\n            int VAR_39;\n            for (VAR_17 = 0; VAR_17 < VAR_2; VAR_17++) {\n                VAR_39 = tls1_cbc_remove_padding(VAR_0, &VAR_1[VAR_17], VAR_9, VAR_15);\n                /* COMMENT_16 */\n                                                                            \n                                                                                \n                                  \n                   \n                if (VAR_39 == 0)\n                    return 0;\n                VAR_14 = constant_time_select_int(constant_time_eq_int(VAR_39, 1),\n                                               VAR_14, -1);\n            }\n        }\n        if (VAR_13 && !VAR_3) {\n            for (VAR_17 = 0; VAR_17 < VAR_2; VAR_17++) {\n                VAR_1[VAR_17].length -= VAR_13;\n            }\n        }\n    }\n    return VAR_14;\n}",
  "func_graph_path_before": "openssl/4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2/ssl3_record.c/vul/before/0.json",
  "func": "int tls1_enc(SSL *s, SSL3_RECORD *recs, unsigned int n_recs, int send)\n{\n    EVP_CIPHER_CTX *ds;\n    size_t reclen[SSL_MAX_PIPELINES];\n    unsigned char buf[SSL_MAX_PIPELINES][EVP_AEAD_TLS1_AAD_LEN];\n    int bs, i, j, k, pad = 0, ret, mac_size = 0;\n    const EVP_CIPHER *enc;\n    unsigned int ctr;\n\n    if (send) {\n        if (EVP_MD_CTX_md(s->write_hash)) {\n            int n = EVP_MD_CTX_size(s->write_hash);\n            OPENSSL_assert(n >= 0);\n        }\n        ds = s->enc_write_ctx;\n        if (s->enc_write_ctx == NULL)\n            enc = NULL;\n        else {\n            int ivlen;\n            enc = EVP_CIPHER_CTX_cipher(s->enc_write_ctx);\n            /* For TLSv1.1 and later explicit IV */\n            if (SSL_USE_EXPLICIT_IV(s)\n                && EVP_CIPHER_mode(enc) == EVP_CIPH_CBC_MODE)\n                ivlen = EVP_CIPHER_iv_length(enc);\n            else\n                ivlen = 0;\n            if (ivlen > 1) {\n                for (ctr = 0; ctr < n_recs; ctr++) {\n                    if (recs[ctr].data != recs[ctr].input) {\n                        /*\n                         * we can't write into the input stream: Can this ever\n                         * happen?? (steve)\n                         */\n                        SSLerr(SSL_F_TLS1_ENC, ERR_R_INTERNAL_ERROR);\n                        return -1;\n                    } else if (RAND_bytes(recs[ctr].input, ivlen) <= 0) {\n                        SSLerr(SSL_F_TLS1_ENC, ERR_R_INTERNAL_ERROR);\n                        return -1;\n                    }\n                }\n            }\n        }\n    } else {\n        if (EVP_MD_CTX_md(s->read_hash)) {\n            int n = EVP_MD_CTX_size(s->read_hash);\n            OPENSSL_assert(n >= 0);\n        }\n        ds = s->enc_read_ctx;\n        if (s->enc_read_ctx == NULL)\n            enc = NULL;\n        else\n            enc = EVP_CIPHER_CTX_cipher(s->enc_read_ctx);\n    }\n\n    if ((s->session == NULL) || (ds == NULL) || (enc == NULL)) {\n        for (ctr = 0; ctr < n_recs; ctr++) {\n            memmove(recs[ctr].data, recs[ctr].input, recs[ctr].length);\n            recs[ctr].input = recs[ctr].data;\n        }\n        ret = 1;\n    } else {\n        bs = EVP_CIPHER_block_size(EVP_CIPHER_CTX_cipher(ds));\n\n        if (n_recs > 1) {\n            if (!(EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(ds))\n                  & EVP_CIPH_FLAG_PIPELINE)) {\n                /*\n                 * We shouldn't have been called with pipeline data if the\n                 * cipher doesn't support pipelining\n                 */\n                SSLerr(SSL_F_TLS1_ENC, SSL_R_PIPELINE_FAILURE);\n                return -1;\n            }\n        }\n        for (ctr = 0; ctr < n_recs; ctr++) {\n            reclen[ctr] = recs[ctr].length;\n\n            if (EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(ds))\n                & EVP_CIPH_FLAG_AEAD_CIPHER) {\n                unsigned char *seq;\n\n                seq = send ? RECORD_LAYER_get_write_sequence(&s->rlayer)\n                    : RECORD_LAYER_get_read_sequence(&s->rlayer);\n\n                if (SSL_IS_DTLS(s)) {\n                    /* DTLS does not support pipelining */\n                    unsigned char dtlsseq[9], *p = dtlsseq;\n\n                    s2n(send ? DTLS_RECORD_LAYER_get_w_epoch(&s->rlayer) :\n                        DTLS_RECORD_LAYER_get_r_epoch(&s->rlayer), p);\n                    memcpy(p, &seq[2], 6);\n                    memcpy(buf[ctr], dtlsseq, 8);\n                } else {\n                    memcpy(buf[ctr], seq, 8);\n                    for (i = 7; i >= 0; i--) { /* increment */\n                        ++seq[i];\n                        if (seq[i] != 0)\n                            break;\n                    }\n                }\n\n                buf[ctr][8] = recs[ctr].type;\n                buf[ctr][9] = (unsigned char)(s->version >> 8);\n                buf[ctr][10] = (unsigned char)(s->version);\n                buf[ctr][11] = recs[ctr].length >> 8;\n                buf[ctr][12] = recs[ctr].length & 0xff;\n                pad = EVP_CIPHER_CTX_ctrl(ds, EVP_CTRL_AEAD_TLS1_AAD,\n                                          EVP_AEAD_TLS1_AAD_LEN, buf[ctr]);\n                if (pad <= 0)\n                    return -1;\n\n                if (send) {\n                    reclen[ctr] += pad;\n                    recs[ctr].length += pad;\n                }\n\n            } else if ((bs != 1) && send) {\n                i = bs - ((int)reclen[ctr] % bs);\n\n                /* Add weird padding of upto 256 bytes */\n\n                /* we need to add 'i' padding bytes of value j */\n                j = i - 1;\n                for (k = (int)reclen[ctr]; k < (int)(reclen[ctr] + i); k++)\n                    recs[ctr].input[k] = j;\n                reclen[ctr] += i;\n                recs[ctr].length += i;\n            }\n\n            if (!send) {\n                if (reclen[ctr] == 0 || reclen[ctr] % bs != 0)\n                    return 0;\n            }\n        }\n        if (n_recs > 1) {\n            unsigned char *data[SSL_MAX_PIPELINES];\n\n            /* Set the output buffers */\n            for (ctr = 0; ctr < n_recs; ctr++) {\n                data[ctr] = recs[ctr].data;\n            }\n            if (EVP_CIPHER_CTX_ctrl(ds, EVP_CTRL_SET_PIPELINE_OUTPUT_BUFS,\n                                    n_recs, data) <= 0) {\n                SSLerr(SSL_F_TLS1_ENC, SSL_R_PIPELINE_FAILURE);\n            }\n            /* Set the input buffers */\n            for (ctr = 0; ctr < n_recs; ctr++) {\n                data[ctr] = recs[ctr].input;\n            }\n            if (EVP_CIPHER_CTX_ctrl(ds, EVP_CTRL_SET_PIPELINE_INPUT_BUFS,\n                                    n_recs, data) <= 0\n                || EVP_CIPHER_CTX_ctrl(ds, EVP_CTRL_SET_PIPELINE_INPUT_LENS,\n                                       n_recs, reclen) <= 0) {\n                SSLerr(SSL_F_TLS1_ENC, SSL_R_PIPELINE_FAILURE);\n                return -1;\n            }\n        }\n\n        i = EVP_Cipher(ds, recs[0].data, recs[0].input, reclen[0]);\n        if ((EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(ds))\n             & EVP_CIPH_FLAG_CUSTOM_CIPHER)\n            ? (i < 0)\n            : (i == 0))\n            return -1;          /* AEAD can fail to verify MAC */\n        if (send == 0) {\n            if (EVP_CIPHER_mode(enc) == EVP_CIPH_GCM_MODE) {\n                for (ctr = 0; ctr < n_recs; ctr++) {\n                    recs[ctr].data += EVP_GCM_TLS_EXPLICIT_IV_LEN;\n                    recs[ctr].input += EVP_GCM_TLS_EXPLICIT_IV_LEN;\n                    recs[ctr].length -= EVP_GCM_TLS_EXPLICIT_IV_LEN;\n                }\n            } else if (EVP_CIPHER_mode(enc) == EVP_CIPH_CCM_MODE) {\n                for (ctr = 0; ctr < n_recs; ctr++) {\n                    recs[ctr].data += EVP_CCM_TLS_EXPLICIT_IV_LEN;\n                    recs[ctr].input += EVP_CCM_TLS_EXPLICIT_IV_LEN;\n                    recs[ctr].length -= EVP_CCM_TLS_EXPLICIT_IV_LEN;\n                }\n            }\n        }\n\n        ret = 1;\n        if (!SSL_READ_ETM(s) && EVP_MD_CTX_md(s->read_hash) != NULL)\n            mac_size = EVP_MD_CTX_size(s->read_hash);\n        if ((bs != 1) && !send) {\n            int tmpret;\n            for (ctr = 0; ctr < n_recs; ctr++) {\n                tmpret = tls1_cbc_remove_padding(s, &recs[ctr], bs, mac_size);\n                /*\n                 * If tmpret == 0 then this means publicly invalid so we can\n                 * short circuit things here. Otherwise we must respect constant\n                 * time behaviour.\n                 */\n                if (tmpret == 0)\n                    return 0;\n                ret = constant_time_select_int(constant_time_eq_int(tmpret, 1),\n                                               ret, -1);\n            }\n        }\n        if (pad && !send) {\n            for (ctr = 0; ctr < n_recs; ctr++) {\n                recs[ctr].length -= pad;\n            }\n        }\n    }\n    return ret;\n}",
  "abstract_func": "int tls1_enc(SSL *VAR_0, SSL3_RECORD *VAR_1, unsigned int VAR_2, int VAR_3)\n{\n    EVP_CIPHER_CTX *VAR_4;\n    size_t VAR_5[VAR_6];\n    unsigned char VAR_7[VAR_6][VAR_8];\n    int VAR_9, VAR_10, VAR_11, VAR_12, VAR_13 = 0, VAR_14, VAR_15 = 0;\n    const EVP_CIPHER *VAR_16;\n    unsigned int VAR_17;\n\n    if (VAR_3) {\n        if (EVP_MD_CTX_md(VAR_0->write_hash)) {\n            int VAR_18 = EVP_MD_CTX_size(VAR_0->write_hash);\n            OPENSSL_assert(VAR_18 >= 0);\n        }\n        VAR_4 = VAR_0->enc_write_ctx;\n        if (VAR_0->enc_write_ctx == NULL)\n            VAR_16 = NULL;\n        else {\n            int VAR_19;\n            VAR_16 = EVP_CIPHER_CTX_cipher(VAR_0->enc_write_ctx);\n            /* COMMENT_0 */\n            if (SSL_USE_EXPLICIT_IV(VAR_0)\n                && EVP_CIPHER_mode(VAR_16) == VAR_20)\n                VAR_19 = EVP_CIPHER_iv_length(VAR_16);\n            else\n                VAR_19 = 0;\n            if (VAR_19 > 1) {\n                for (VAR_17 = 0; VAR_17 < VAR_2; VAR_17++) {\n                    if (VAR_1[VAR_17].data != VAR_1[VAR_17].input) {\n                        /* COMMENT_1 */\n                                                                              \n                                           \n                           \n                        SSLerr(VAR_21, VAR_22);\n                        return -1;\n                    } else if (RAND_bytes(VAR_1[VAR_17].input, VAR_19) <= 0) {\n                        SSLerr(VAR_21, VAR_22);\n                        return -1;\n                    }\n                }\n            }\n        }\n    } else {\n        if (EVP_MD_CTX_md(VAR_0->read_hash)) {\n            int VAR_18 = EVP_MD_CTX_size(VAR_0->read_hash);\n            OPENSSL_assert(VAR_18 >= 0);\n        }\n        VAR_4 = VAR_0->enc_read_ctx;\n        if (VAR_0->enc_read_ctx == NULL)\n            VAR_16 = NULL;\n        else\n            VAR_16 = EVP_CIPHER_CTX_cipher(VAR_0->enc_read_ctx);\n    }\n\n    if ((VAR_0->session == NULL) || (VAR_4 == NULL) || (VAR_16 == NULL)) {\n        for (VAR_17 = 0; VAR_17 < VAR_2; VAR_17++) {\n            memmove(VAR_1[VAR_17].data, VAR_1[VAR_17].input, VAR_1[VAR_17].length);\n            VAR_1[VAR_17].input = VAR_1[VAR_17].data;\n        }\n        VAR_14 = 1;\n    } else {\n        VAR_9 = EVP_CIPHER_block_size(EVP_CIPHER_CTX_cipher(VAR_4));\n\n        if (VAR_2 > 1) {\n            if (!(EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(VAR_4))\n                  & VAR_23)) {\n                /* COMMENT_5 */\n                                                                          \n                                                    \n                   \n                SSLerr(VAR_21, VAR_24);\n                return -1;\n            }\n        }\n        for (VAR_17 = 0; VAR_17 < VAR_2; VAR_17++) {\n            VAR_5[VAR_17] = VAR_1[VAR_17].length;\n\n            if (EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(VAR_4))\n                & VAR_25) {\n                unsigned char *VAR_26;\n\n                VAR_26 = VAR_3 ? RECORD_LAYER_get_write_sequence(&VAR_0->rlayer)\n                    : RECORD_LAYER_get_read_sequence(&VAR_0->rlayer);\n\n                if (SSL_IS_DTLS(VAR_0)) {\n                    /* COMMENT_9 */\n                    unsigned char VAR_27[9], *VAR_28 = VAR_27;\n\n                    s2n(VAR_3 ? DTLS_RECORD_LAYER_get_w_epoch(&VAR_0->rlayer) :\n                        DTLS_RECORD_LAYER_get_r_epoch(&VAR_0->rlayer), VAR_28);\n                    memcpy(VAR_28, &VAR_26[2], 6);\n                    memcpy(VAR_7[VAR_17], VAR_27, 8);\n                } else {\n                    memcpy(VAR_7[VAR_17], VAR_26, 8);\n                    for (VAR_10 = 7; VAR_10 >= 0; VAR_10--) { /* COMMENT_10 */\n                        ++VAR_26[VAR_10];\n                        if (VAR_26[VAR_10] != 0)\n                            break;\n                    }\n                }\n\n                VAR_7[VAR_17][8] = VAR_1[VAR_17].type;\n                VAR_7[VAR_17][9] = (unsigned char)(VAR_0->version >> 8);\n                VAR_7[VAR_17][10] = (unsigned char)(VAR_0->version);\n                VAR_7[VAR_17][11] = VAR_1[VAR_17].length >> 8;\n                VAR_7[VAR_17][12] = VAR_1[VAR_17].length & 0xff;\n                VAR_13 = EVP_CIPHER_CTX_ctrl(VAR_4, VAR_29,\n                                          VAR_8, VAR_7[VAR_17]);\n                if (VAR_13 <= 0)\n                    return -1;\n\n                if (VAR_3) {\n                    VAR_5[VAR_17] += VAR_13;\n                    VAR_1[VAR_17].length += VAR_13;\n                }\n\n            } else if ((VAR_9 != 1) && VAR_3) {\n                VAR_10 = VAR_9 - ((int)VAR_5[VAR_17] % VAR_9);\n\n                /* COMMENT_11 */\n\n                /* COMMENT_12 */\n                VAR_11 = VAR_10 - 1;\n                for (VAR_12 = (int)VAR_5[VAR_17]; VAR_12 < (int)(VAR_5[VAR_17] + VAR_10); VAR_12++)\n                    VAR_1[VAR_17].input[VAR_12] = VAR_11;\n                VAR_5[VAR_17] += VAR_10;\n                VAR_1[VAR_17].length += VAR_10;\n            }\n\n            if (!VAR_3) {\n                if (VAR_5[VAR_17] == 0 || VAR_5[VAR_17] % VAR_9 != 0)\n                    return 0;\n            }\n        }\n        if (VAR_2 > 1) {\n            unsigned char *VAR_30[VAR_6];\n\n            /* COMMENT_13 */\n            for (VAR_17 = 0; VAR_17 < VAR_2; VAR_17++) {\n                VAR_30[VAR_17] = VAR_1[VAR_17].data;\n            }\n            if (EVP_CIPHER_CTX_ctrl(VAR_4, VAR_31,\n                                    VAR_2, VAR_30) <= 0) {\n                SSLerr(VAR_21, VAR_24);\n            }\n            /* COMMENT_14 */\n            for (VAR_17 = 0; VAR_17 < VAR_2; VAR_17++) {\n                VAR_30[VAR_17] = VAR_1[VAR_17].input;\n            }\n            if (EVP_CIPHER_CTX_ctrl(VAR_4, VAR_32,\n                                    VAR_2, VAR_30) <= 0\n                || EVP_CIPHER_CTX_ctrl(VAR_4, VAR_33,\n                                       VAR_2, VAR_5) <= 0) {\n                SSLerr(VAR_21, VAR_24);\n                return -1;\n            }\n        }\n\n        VAR_10 = EVP_Cipher(VAR_4, VAR_1[0].data, VAR_1[0].input, VAR_5[0]);\n        if ((EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(VAR_4))\n             & VAR_34)\n            ? (VAR_10 < 0)\n            : (VAR_10 == 0))\n            return -1;          /* COMMENT_15 */\n        if (VAR_3 == 0) {\n            if (EVP_CIPHER_mode(VAR_16) == VAR_35) {\n                for (VAR_17 = 0; VAR_17 < VAR_2; VAR_17++) {\n                    VAR_1[VAR_17].data += VAR_36;\n                    VAR_1[VAR_17].input += VAR_36;\n                    VAR_1[VAR_17].length -= VAR_36;\n                }\n            } else if (EVP_CIPHER_mode(VAR_16) == VAR_37) {\n                for (VAR_17 = 0; VAR_17 < VAR_2; VAR_17++) {\n                    VAR_1[VAR_17].data += VAR_38;\n                    VAR_1[VAR_17].input += VAR_38;\n                    VAR_1[VAR_17].length -= VAR_38;\n                }\n            }\n        }\n\n        VAR_14 = 1;\n        if (!SSL_READ_ETM(VAR_0) && EVP_MD_CTX_md(VAR_0->read_hash) != NULL)\n            VAR_15 = EVP_MD_CTX_size(VAR_0->read_hash);\n        if ((VAR_9 != 1) && !VAR_3) {\n            int VAR_39;\n            for (VAR_17 = 0; VAR_17 < VAR_2; VAR_17++) {\n                VAR_39 = tls1_cbc_remove_padding(VAR_0, &VAR_1[VAR_17], VAR_9, VAR_15);\n                /* COMMENT_16 */\n                                                                            \n                                                                                \n                                  \n                   \n                if (VAR_39 == 0)\n                    return 0;\n                VAR_14 = constant_time_select_int(constant_time_eq_int(VAR_39, 1),\n                                               VAR_14, -1);\n            }\n        }\n        if (VAR_13 && !VAR_3) {\n            for (VAR_17 = 0; VAR_17 < VAR_2; VAR_17++) {\n                VAR_1[VAR_17].length -= VAR_13;\n            }\n        }\n    }\n    return VAR_14;\n}",
  "func_graph_path": "openssl/4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2/ssl3_record.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -179,7 +179,7 @@\n         }\n \n         ret = 1;\n-        if (!SSL_USE_ETM(s) && EVP_MD_CTX_md(s->read_hash) != NULL)\n+        if (!SSL_READ_ETM(s) && EVP_MD_CTX_md(s->read_hash) != NULL)\n             mac_size = EVP_MD_CTX_size(s->read_hash);\n         if ((bs != 1) && !send) {\n             int tmpret;",
  "diff_line_info": {
    "deleted_lines": [
      "        if (!SSL_USE_ETM(s) && EVP_MD_CTX_md(s->read_hash) != NULL)"
    ],
    "added_lines": [
      "        if (!SSL_READ_ETM(s) && EVP_MD_CTX_md(s->read_hash) != NULL)"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/EktapopaT/openssl/pull/1",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/EktapopaT/openssl/pull/1: 403 Client Error: Forbidden for url: https://api.github.com/repos/EktapopaT/openssl/pulls/1",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "The patch is clearly addressing a security issue related to a DoS vulnerability, indicated by the CVE-2017-3733 reference. The code changes in `tls1_enc` adjust how ETM flags are handled, preventing the crash during renegotiation. Although the vulnerability description provided seems unrelated, the commit and code changes strongly suggest a security fix.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95"
}