{
  "cve_id": "CVE-2018-10932",
  "cwe_ids": [
    "CWE-117"
  ],
  "cvss_vector": "AV:A/AC:L/Au:N/C:N/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "intel/openlldp",
  "commit_msg": "basman_clif: print the OID properly\n\nWhen invoking the lldp tool to view the management information, the display\nfor the OID is printed as the actual binary bits, rather than the\nOID dotted-notation form.\n\nThis change will display the OID as expected.\n\nSigned-off-by: Aaron Conole <aconole@redhat.com>",
  "commit_hash": "cf3f54d1883e5bc23e4c4006a63e1dde88684013",
  "git_url": "https://github.com/intel/openlldp/commit/cf3f54d1883e5bc23e4c4006a63e1dde88684013",
  "file_path": "lldp_basman_clif.c",
  "func_name": "print_mng_addr",
  "func_before": "void print_mng_addr(u16 len, char *info)\n{\n\tu8 addrlen;\n\tu8 addrnum;\n\tu8 iftype;\n\tu8 oidlen;\n\tu32 ifnum;\n\tu32 offset;\n\tint i;\n\tchar buf[132];\n\n\tif (len < 9 || len > 167) {\n\t\tprintf(\"Bad Management Address TLV: %*.*s\\n\",\n\t\t\t2*len, 2*len, info);\n\t\treturn;\n\t}\n\n\thexstr2bin(info, (u8 *)&addrlen, sizeof(addrlen));\n\thexstr2bin(info+2, (u8 *)&addrnum, sizeof(addrnum));\n\n\tswitch(addrnum) {\n\tcase MANADDR_ALL802:\n\t\tif (addrlen != 1 + 6)\n\t\t\treturn;\n\t\tprintf(\"MAC: \");\n\t\tfor (i = 0; i < 12; i+=2) {\n\t\t\tprintf(\"%2.2s\", info + 4 + i);\n\t\t\tif (i < 10)\n\t\t\t\tprintf(\":\");\n\t\t\telse\n\t\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tbreak;\n\tcase MANADDR_IPV4:\n\t\tif (addrlen == 5) {\n\t\t\tstruct in_addr addr;\n\t\t\thexstr2bin(info+4, (u8 *)&addr, sizeof(addr));\n\t\t\tinet_ntop(AF_INET, (void *)&addr, buf,\n\t\t\t\t  sizeof(buf));\n\t\t\tprintf(\"IPv4: %s\\n\", buf);\n\t\t} else {\n\t\t\tprintf(\"Bad IPv4: %*.*s\\n\",\n\t\t\t       2*(addrlen-2), 2*(addrlen-2), info+4);\n\t\t}\n\t\tbreak;\n\tcase MANADDR_IPV6:\n\t\tif (addrlen == 17) {\n\t\t\tstruct in6_addr addr;\n\t\t\thexstr2bin(info+4, (u8 *)&addr, sizeof(addr));\n\t\t\tmemset(buf, 0, sizeof(buf));\n\t\t\tinet_ntop(AF_INET6, (void *)&addr, buf,\n\t\t\t\t  sizeof(buf));\n\t\t\tprintf(\"IPv6: %s\\n\", buf);\n\t\t} else {\n\t\t\tprintf(\"Bad IPv6: %*.*s\\n\",\n\t\t\t       2*(addrlen-2), 2*(addrlen-2), info+4);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"Network Address Type %d: %*.*s\\n\", addrnum,\n\t\t       2*(addrlen-1), 2*(addrlen-1), info+4);\n\t\tbreak;\n\t}\n\n\toffset = 2*(1+addrlen);\n\thexstr2bin(info+offset, (u8 *)&iftype, sizeof(iftype));\n\toffset += 2;\n\thexstr2bin(info+offset, (u8 *)&ifnum, sizeof(ifnum));\n\toffset += 2*sizeof(u32);\n\tifnum = ntohl(ifnum);\n\n\tswitch (iftype) {\n\tcase IFNUM_UNKNOWN:\n\t\tprintf(\"\\tUnknown interface subtype: \");\n\t\tbreak;\n\tcase IFNUM_IFINDEX:\n\t\tprintf(\"\\tIfindex: \");\n\t\tbreak;\n\tcase IFNUM_SYS_PORT_NUM:\n\t\tprintf(\"\\tSystem port number: \");\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"\\tBad interface numbering subtype: \");\n\t\tbreak;\n\t}\n\tprintf(\"%d\\n\", ifnum);\n\n\thexstr2bin(info+offset, (u8 *)&oidlen, sizeof(oidlen));\n\toffset += 2;\n\n\tif (oidlen && oidlen <= 128) {\n\t\tmemset(buf, 0, sizeof(buf));\n\t\tif (hexstr2bin(info+offset, (u8 *)&buf, oidlen))\n\t\t\tprintf(\"\\tOID: Error parsing OID\\n\");\n\t\telse\n\t\t\tprintf(\"\\tOID: %s\\n\", buf);\n\t} else if (oidlen > 128) {\n\t\tprintf(\"\\tOID: Invalid length = %d\\n\", oidlen);\n\t}\n}",
  "abstract_func_before": "void print_mng_addr(u16 VAR_0, char *VAR_1)\n{\n\tu8 VAR_2;\n\tu8 VAR_3;\n\tu8 VAR_4;\n\tu8 VAR_5;\n\tu32 VAR_6;\n\tu32 VAR_7;\n\tint VAR_8;\n\tchar VAR_9[132];\n\n\tif (VAR_0 < 9 || VAR_0 > 167) {\n\t\tprintf(\"Bad Management Address TLV: %*.*s\\n\",\n\t\t\t2*VAR_0, 2*VAR_0, VAR_1);\n\t\treturn;\n\t}\n\n\thexstr2bin(VAR_1, (u8 *)&VAR_2, sizeof(VAR_2));\n\thexstr2bin(VAR_1+2, (u8 *)&VAR_3, sizeof(VAR_3));\n\n\tswitch(VAR_3) {\n\tcase VAR_10:\n\t\tif (VAR_2 != 1 + 6)\n\t\t\treturn;\n\t\tprintf(\"MAC: \");\n\t\tfor (VAR_8 = 0; VAR_8 < 12; VAR_8+=2) {\n\t\t\tprintf(\"%2.2s\", VAR_1 + 4 + VAR_8);\n\t\t\tif (VAR_8 < 10)\n\t\t\t\tprintf(\":\");\n\t\t\telse\n\t\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tbreak;\n\tcase VAR_11:\n\t\tif (VAR_2 == 5) {\n\t\t\tstruct in_addr VAR_12;\n\t\t\thexstr2bin(VAR_1+4, (u8 *)&VAR_12, sizeof(VAR_12));\n\t\t\tinet_ntop(VAR_13, (void *)&VAR_12, VAR_9,\n\t\t\t\t  sizeof(VAR_9));\n\t\t\tprintf(\"IPv4: %s\\n\", VAR_9);\n\t\t} else {\n\t\t\tprintf(\"Bad IPv4: %*.*s\\n\",\n\t\t\t       2*(VAR_2-2), 2*(VAR_2-2), VAR_1+4);\n\t\t}\n\t\tbreak;\n\tcase VAR_14:\n\t\tif (VAR_2 == 17) {\n\t\t\tstruct in6_addr VAR_12;\n\t\t\thexstr2bin(VAR_1+4, (u8 *)&VAR_12, sizeof(VAR_12));\n\t\t\tmemset(VAR_9, 0, sizeof(VAR_9));\n\t\t\tinet_ntop(VAR_15, (void *)&VAR_12, VAR_9,\n\t\t\t\t  sizeof(VAR_9));\n\t\t\tprintf(\"IPv6: %s\\n\", VAR_9);\n\t\t} else {\n\t\t\tprintf(\"Bad IPv6: %*.*s\\n\",\n\t\t\t       2*(VAR_2-2), 2*(VAR_2-2), VAR_1+4);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"Network Address Type %d: %*.*s\\n\", VAR_3,\n\t\t       2*(VAR_2-1), 2*(VAR_2-1), VAR_1+4);\n\t\tbreak;\n\t}\n\n\tVAR_7 = 2*(1+VAR_2);\n\thexstr2bin(VAR_1+VAR_7, (u8 *)&VAR_4, sizeof(VAR_4));\n\tVAR_7 += 2;\n\thexstr2bin(VAR_1+VAR_7, (u8 *)&VAR_6, sizeof(VAR_6));\n\tVAR_7 += 2*sizeof(u32);\n\tVAR_6 = ntohl(VAR_6);\n\n\tswitch (VAR_4) {\n\tcase VAR_16:\n\t\tprintf(\"\\tUnknown interface subtype: \");\n\t\tbreak;\n\tcase VAR_17:\n\t\tprintf(\"\\tIfindex: \");\n\t\tbreak;\n\tcase VAR_18:\n\t\tprintf(\"\\tSystem port number: \");\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"\\tBad interface numbering subtype: \");\n\t\tbreak;\n\t}\n\tprintf(\"%d\\n\", VAR_6);\n\n\thexstr2bin(VAR_1+VAR_7, (u8 *)&VAR_5, sizeof(VAR_5));\n\tVAR_7 += 2;\n\n\tif (VAR_5 && VAR_5 <= 128) {\n\t\tmemset(VAR_9, 0, sizeof(VAR_9));\n\t\tif (hexstr2bin(VAR_1+VAR_7, (u8 *)&VAR_9, VAR_5))\n\t\t\tprintf(\"\\tOID: Error parsing OID\\n\");\n\t\telse\n\t\t\tprintf(\"\\tOID: %s\\n\", VAR_9);\n\t} else if (VAR_5 > 128) {\n\t\tprintf(\"\\tOID: Invalid length = %d\\n\", VAR_5);\n\t}\n}",
  "func_graph_path_before": "intel/openlldp/cf3f54d1883e5bc23e4c4006a63e1dde88684013/lldp_basman_clif.c/vul/before/0.json",
  "func": "void print_mng_addr(u16 len, char *info)\n{\n\tu8 addrlen;\n\tu8 addrnum;\n\tu8 iftype;\n\tu8 oidlen;\n\tu32 ifnum;\n\tu32 offset;\n\tint i;\n\tchar buf[132];\n\n\tif (len < 9 || len > 167) {\n\t\tprintf(\"Bad Management Address TLV: %*.*s\\n\",\n\t\t\t2*len, 2*len, info);\n\t\treturn;\n\t}\n\n\thexstr2bin(info, (u8 *)&addrlen, sizeof(addrlen));\n\thexstr2bin(info+2, (u8 *)&addrnum, sizeof(addrnum));\n\n\tswitch(addrnum) {\n\tcase MANADDR_ALL802:\n\t\tif (addrlen != 1 + 6)\n\t\t\treturn;\n\t\tprintf(\"MAC: \");\n\t\tfor (i = 0; i < 12; i+=2) {\n\t\t\tprintf(\"%2.2s\", info + 4 + i);\n\t\t\tif (i < 10)\n\t\t\t\tprintf(\":\");\n\t\t\telse\n\t\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tbreak;\n\tcase MANADDR_IPV4:\n\t\tif (addrlen == 5) {\n\t\t\tstruct in_addr addr;\n\t\t\thexstr2bin(info+4, (u8 *)&addr, sizeof(addr));\n\t\t\tinet_ntop(AF_INET, (void *)&addr, buf,\n\t\t\t\t  sizeof(buf));\n\t\t\tprintf(\"IPv4: %s\\n\", buf);\n\t\t} else {\n\t\t\tprintf(\"Bad IPv4: %*.*s\\n\",\n\t\t\t       2*(addrlen-2), 2*(addrlen-2), info+4);\n\t\t}\n\t\tbreak;\n\tcase MANADDR_IPV6:\n\t\tif (addrlen == 17) {\n\t\t\tstruct in6_addr addr;\n\t\t\thexstr2bin(info+4, (u8 *)&addr, sizeof(addr));\n\t\t\tmemset(buf, 0, sizeof(buf));\n\t\t\tinet_ntop(AF_INET6, (void *)&addr, buf,\n\t\t\t\t  sizeof(buf));\n\t\t\tprintf(\"IPv6: %s\\n\", buf);\n\t\t} else {\n\t\t\tprintf(\"Bad IPv6: %*.*s\\n\",\n\t\t\t       2*(addrlen-2), 2*(addrlen-2), info+4);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"Network Address Type %d: %*.*s\\n\", addrnum,\n\t\t       2*(addrlen-1), 2*(addrlen-1), info+4);\n\t\tbreak;\n\t}\n\n\toffset = 2*(1+addrlen);\n\thexstr2bin(info+offset, (u8 *)&iftype, sizeof(iftype));\n\toffset += 2;\n\thexstr2bin(info+offset, (u8 *)&ifnum, sizeof(ifnum));\n\toffset += 2*sizeof(u32);\n\tifnum = ntohl(ifnum);\n\n\tswitch (iftype) {\n\tcase IFNUM_UNKNOWN:\n\t\tprintf(\"\\tUnknown interface subtype: \");\n\t\tbreak;\n\tcase IFNUM_IFINDEX:\n\t\tprintf(\"\\tIfindex: \");\n\t\tbreak;\n\tcase IFNUM_SYS_PORT_NUM:\n\t\tprintf(\"\\tSystem port number: \");\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"\\tBad interface numbering subtype: \");\n\t\tbreak;\n\t}\n\tprintf(\"%d\\n\", ifnum);\n\n\thexstr2bin(info+offset, (u8 *)&oidlen, sizeof(oidlen));\n\toffset += 2;\n\n\tif (oidlen && oidlen <= 128) {\n\t\tmemset(buf, 0, sizeof(buf));\n\t\tif (hexstr2bin(info+offset, (u8 *)&buf, oidlen))\n\t\t\tprintf(\"\\tOID: Error parsing OID\\n\");\n\t\telse {\n\t\t\tprintf(\"\\tOID: 0.\");\n\t\t\tfor (i = 0; i < oidlen; ++i) {\n\t\t\t\tprintf(\"%d\", buf[i]);\n\t\t\t\tif (i != (oidlen - 1))\n\t\t\t\t\tprintf(\".\");\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t} else if (oidlen > 128) {\n\t\tprintf(\"\\tOID: Invalid length = %d\\n\", oidlen);\n\t}\n}",
  "abstract_func": "void print_mng_addr(u16 VAR_0, char *VAR_1)\n{\n\tu8 VAR_2;\n\tu8 VAR_3;\n\tu8 VAR_4;\n\tu8 VAR_5;\n\tu32 VAR_6;\n\tu32 VAR_7;\n\tint VAR_8;\n\tchar VAR_9[132];\n\n\tif (VAR_0 < 9 || VAR_0 > 167) {\n\t\tprintf(\"Bad Management Address TLV: %*.*s\\n\",\n\t\t\t2*VAR_0, 2*VAR_0, VAR_1);\n\t\treturn;\n\t}\n\n\thexstr2bin(VAR_1, (u8 *)&VAR_2, sizeof(VAR_2));\n\thexstr2bin(VAR_1+2, (u8 *)&VAR_3, sizeof(VAR_3));\n\n\tswitch(VAR_3) {\n\tcase VAR_10:\n\t\tif (VAR_2 != 1 + 6)\n\t\t\treturn;\n\t\tprintf(\"MAC: \");\n\t\tfor (VAR_8 = 0; VAR_8 < 12; VAR_8+=2) {\n\t\t\tprintf(\"%2.2s\", VAR_1 + 4 + VAR_8);\n\t\t\tif (VAR_8 < 10)\n\t\t\t\tprintf(\":\");\n\t\t\telse\n\t\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tbreak;\n\tcase VAR_11:\n\t\tif (VAR_2 == 5) {\n\t\t\tstruct in_addr VAR_12;\n\t\t\thexstr2bin(VAR_1+4, (u8 *)&VAR_12, sizeof(VAR_12));\n\t\t\tinet_ntop(VAR_13, (void *)&VAR_12, VAR_9,\n\t\t\t\t  sizeof(VAR_9));\n\t\t\tprintf(\"IPv4: %s\\n\", VAR_9);\n\t\t} else {\n\t\t\tprintf(\"Bad IPv4: %*.*s\\n\",\n\t\t\t       2*(VAR_2-2), 2*(VAR_2-2), VAR_1+4);\n\t\t}\n\t\tbreak;\n\tcase VAR_14:\n\t\tif (VAR_2 == 17) {\n\t\t\tstruct in6_addr VAR_12;\n\t\t\thexstr2bin(VAR_1+4, (u8 *)&VAR_12, sizeof(VAR_12));\n\t\t\tmemset(VAR_9, 0, sizeof(VAR_9));\n\t\t\tinet_ntop(VAR_15, (void *)&VAR_12, VAR_9,\n\t\t\t\t  sizeof(VAR_9));\n\t\t\tprintf(\"IPv6: %s\\n\", VAR_9);\n\t\t} else {\n\t\t\tprintf(\"Bad IPv6: %*.*s\\n\",\n\t\t\t       2*(VAR_2-2), 2*(VAR_2-2), VAR_1+4);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"Network Address Type %d: %*.*s\\n\", VAR_3,\n\t\t       2*(VAR_2-1), 2*(VAR_2-1), VAR_1+4);\n\t\tbreak;\n\t}\n\n\tVAR_7 = 2*(1+VAR_2);\n\thexstr2bin(VAR_1+VAR_7, (u8 *)&VAR_4, sizeof(VAR_4));\n\tVAR_7 += 2;\n\thexstr2bin(VAR_1+VAR_7, (u8 *)&VAR_6, sizeof(VAR_6));\n\tVAR_7 += 2*sizeof(u32);\n\tVAR_6 = ntohl(VAR_6);\n\n\tswitch (VAR_4) {\n\tcase VAR_16:\n\t\tprintf(\"\\tUnknown interface subtype: \");\n\t\tbreak;\n\tcase VAR_17:\n\t\tprintf(\"\\tIfindex: \");\n\t\tbreak;\n\tcase VAR_18:\n\t\tprintf(\"\\tSystem port number: \");\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"\\tBad interface numbering subtype: \");\n\t\tbreak;\n\t}\n\tprintf(\"%d\\n\", VAR_6);\n\n\thexstr2bin(VAR_1+VAR_7, (u8 *)&VAR_5, sizeof(VAR_5));\n\tVAR_7 += 2;\n\n\tif (VAR_5 && VAR_5 <= 128) {\n\t\tmemset(VAR_9, 0, sizeof(VAR_9));\n\t\tif (hexstr2bin(VAR_1+VAR_7, (u8 *)&VAR_9, VAR_5))\n\t\t\tprintf(\"\\tOID: Error parsing OID\\n\");\n\t\telse {\n\t\t\tprintf(\"\\tOID: 0.\");\n\t\t\tfor (VAR_8 = 0; VAR_8 < VAR_5; ++VAR_8) {\n\t\t\t\tprintf(\"%d\", VAR_9[VAR_8]);\n\t\t\t\tif (VAR_8 != (VAR_5 - 1))\n\t\t\t\t\tprintf(\".\");\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t} else if (VAR_5 > 128) {\n\t\tprintf(\"\\tOID: Invalid length = %d\\n\", VAR_5);\n\t}\n}",
  "func_graph_path": "intel/openlldp/cf3f54d1883e5bc23e4c4006a63e1dde88684013/lldp_basman_clif.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -92,8 +92,15 @@\n \t\tmemset(buf, 0, sizeof(buf));\n \t\tif (hexstr2bin(info+offset, (u8 *)&buf, oidlen))\n \t\t\tprintf(\"\\tOID: Error parsing OID\\n\");\n-\t\telse\n-\t\t\tprintf(\"\\tOID: %s\\n\", buf);\n+\t\telse {\n+\t\t\tprintf(\"\\tOID: 0.\");\n+\t\t\tfor (i = 0; i < oidlen; ++i) {\n+\t\t\t\tprintf(\"%d\", buf[i]);\n+\t\t\t\tif (i != (oidlen - 1))\n+\t\t\t\t\tprintf(\".\");\n+\t\t\t}\n+\t\t\tprintf(\"\\n\");\n+\t\t}\n \t} else if (oidlen > 128) {\n \t\tprintf(\"\\tOID: Invalid length = %d\\n\", oidlen);\n \t}",
  "diff_line_info": {
    "deleted_lines": [
      "\t\telse",
      "\t\t\tprintf(\"\\tOID: %s\\n\", buf);"
    ],
    "added_lines": [
      "\t\telse {",
      "\t\t\tprintf(\"\\tOID: 0.\");",
      "\t\t\tfor (i = 0; i < oidlen; ++i) {",
      "\t\t\t\tprintf(\"%d\", buf[i]);",
      "\t\t\t\tif (i != (oidlen - 1))",
      "\t\t\t\t\tprintf(\".\");",
      "\t\t\t}",
      "\t\t\tprintf(\"\\n\");",
      "\t\t}"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/intel/openlldp/pull/7",
  "description": {
    "pr_info": {
      "title": "OID Printing changes",
      "number": 7
    },
    "comment": [
      "The OID display from lldp-tool is currently dumping the raw bytes from the MIB, rather\r\nthan formatting them into a common dotted notation.  This series corrects that by displaying\r\nas the common notation.\r\n\r\nAdditionally, this series incorporates the GNU Autotools 'make check' facility.  It introduces a check\r\nin 2/3 which fails, and then fixes the failure in 3/3.\r\n\r\nSigned-off-by: Aaron Conole <aconole@redhat.com>\r\n\r\n",
      "We are in the process of validating your patch, thank you for your PR! We have tested this on the Mellanox Connectx-4 and Intel X520 with no issues observed.",
      "Ping.  Any update?",
      "This has been validated as ready to merge, assigning to Dave to merge. ",
      "@praeluceo who should approve this patch? It solves an annoying bug the is recurring on my network.",
      "CVE-2018-10932 was assigned to this issue.",
      "@pedrohc do you have more details on your comment on this PR? Currently 10932 is still reserved:\r\n\r\nhttps://cve.mitre.org/cgi-bin/cvename.cgi?name=2018-10932",
      "https://bugzilla.redhat.com/show_bug.cgi?id=1614896",
      "I have to apologize as I may have overstepped here. I didn't realize you guys were CNA until too late. I can reject the CVE is needed."
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.9"
}