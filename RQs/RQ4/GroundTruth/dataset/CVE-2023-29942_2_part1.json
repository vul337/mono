{
  "cve_id": "CVE-2023-29942",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "llvm/llvm-project",
  "commit_msg": "[mlir][spirv] Handle failed conversions of struct elements (#70005)\n\nLLVMStructTypes could be emitted with some null elements. This caused a\r\ncrash later in the LLVMDialect verifier.\r\n\r\nWe now use `convertTypes` and check that all types were successfully converted before passing them to the `LLVMStructType` constructor.\r\n\r\nSee #59990",
  "commit_hash": "30ca16ec87206294f4ad0e9688c88f32421b343e",
  "git_url": "https://github.com/llvm/llvm-project/commit/30ca16ec87206294f4ad0e9688c88f32421b343e",
  "file_path": "mlir/lib/Conversion/SPIRVToLLVM/SPIRVToLLVM.cpp",
  "func_name": "convertStructTypeWithOffset",
  "func_before": "static std::optional<Type>\nconvertStructTypeWithOffset(spirv::StructType type,\n                            LLVMTypeConverter &converter) {\n  if (type != VulkanLayoutUtils::decorateType(type))\n    return std::nullopt;\n\n  auto elementsVector = llvm::to_vector<8>(\n      llvm::map_range(type.getElementTypes(), [&](Type elementType) {\n        return converter.convertType(elementType);\n      }));\n  return LLVM::LLVMStructType::getLiteral(type.getContext(), elementsVector,\n                                          /*isPacked=*/false);\n}",
  "abstract_func_before": "static std::optional<Type>\nconvertStructTypeWithOffset(spirv::StructType VAR_0,\n                            LLVMTypeConverter &VAR_1) {\n  if (VAR_0 != VulkanLayoutUtils::decorateType(VAR_0))\n    return std::nullopt;\n\n  auto VAR_2 = llvm::VAR_3<8>(\n      llvm::map_range(VAR_0.getElementTypes(), [&](Type VAR_4) {\n        return VAR_1.convertType(VAR_4);\n      }));\n  return LLVM::LLVMStructType::getLiteral(VAR_0.getContext(), VAR_2,\n                                          /* COMMENT_0 */false);\n}",
  "func_graph_path_before": "llvm/llvm-project/30ca16ec87206294f4ad0e9688c88f32421b343e/SPIRVToLLVM.cpp/vul/before/2.json",
  "func": "static Type convertStructTypeWithOffset(spirv::StructType type,\n                                        LLVMTypeConverter &converter) {\n  if (type != VulkanLayoutUtils::decorateType(type))\n    return nullptr;\n\n  SmallVector<Type> elementsVector;\n  if (failed(converter.convertTypes(type.getElementTypes(), elementsVector)))\n    return nullptr;\n  return LLVM::LLVMStructType::getLiteral(type.getContext(), elementsVector,\n                                          /*isPacked=*/false);\n}",
  "abstract_func": "static Type convertStructTypeWithOffset(spirv::StructType VAR_0,\n                                        LLVMTypeConverter &VAR_1) {\n  if (VAR_0 != VulkanLayoutUtils::decorateType(VAR_0))\n    return nullptr;\n\n  SmallVector<Type> VAR_2;\n  if (failed(VAR_1.convertTypes(VAR_0.getElementTypes(), VAR_2)))\n    return nullptr;\n  return LLVM::LLVMStructType::getLiteral(VAR_0.getContext(), VAR_2,\n                                          /* COMMENT_0 */false);\n}",
  "func_graph_path": "llvm/llvm-project/30ca16ec87206294f4ad0e9688c88f32421b343e/SPIRVToLLVM.cpp/vul/after/2.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,13 +1,11 @@\n-static std::optional<Type>\n-convertStructTypeWithOffset(spirv::StructType type,\n-                            LLVMTypeConverter &converter) {\n+static Type convertStructTypeWithOffset(spirv::StructType type,\n+                                        LLVMTypeConverter &converter) {\n   if (type != VulkanLayoutUtils::decorateType(type))\n-    return std::nullopt;\n+    return nullptr;\n \n-  auto elementsVector = llvm::to_vector<8>(\n-      llvm::map_range(type.getElementTypes(), [&](Type elementType) {\n-        return converter.convertType(elementType);\n-      }));\n+  SmallVector<Type> elementsVector;\n+  if (failed(converter.convertTypes(type.getElementTypes(), elementsVector)))\n+    return nullptr;\n   return LLVM::LLVMStructType::getLiteral(type.getContext(), elementsVector,\n                                           /*isPacked=*/false);\n }",
  "diff_line_info": {
    "deleted_lines": [
      "static std::optional<Type>",
      "convertStructTypeWithOffset(spirv::StructType type,",
      "                            LLVMTypeConverter &converter) {",
      "    return std::nullopt;",
      "  auto elementsVector = llvm::to_vector<8>(",
      "      llvm::map_range(type.getElementTypes(), [&](Type elementType) {",
      "        return converter.convertType(elementType);",
      "      }));"
    ],
    "added_lines": [
      "static Type convertStructTypeWithOffset(spirv::StructType type,",
      "                                        LLVMTypeConverter &converter) {",
      "    return nullptr;",
      "  SmallVector<Type> elementsVector;",
      "  if (failed(converter.convertTypes(type.getElementTypes(), elementsVector)))",
      "    return nullptr;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/llvm/llvm-project/pull/70005",
  "description": {
    "pr_info": {
      "title": "[mlir][spirv] Handle failed conversions of struct elements",
      "number": 70005
    },
    "comment": [
      "LLVMStructTypes could be emitted with some null elements. This caused a crash later in the LLVMDialect verifier.\r\n\r\nNow, properly check that all struct elements were successfully converted before passing them to the LLVMStructType ctor.\r\n\r\nSee #59990",
      "\n<!--LLVM PR SUMMARY COMMENT-->\n@llvm/pr-subscribers-mlir\n\n@llvm/pr-subscribers-mlir-spirv\n\nAuthor: Pierre van Houtryve (Pierre-vh)\n\n<details>\n<summary>Changes</summary>\n\nLLVMStructTypes could be emitted with some null elements. This caused a crash later in the LLVMDialect verifier.\r\n\r\nNow, properly check that all struct elements were successfully converted before passing them to the LLVMStructType ctor.\r\n\r\nSee #<!-- -->59990\n\n---\nFull diff: https://github.com/llvm/llvm-project/pull/70005.diff\n\n\n2 Files Affected:\n\n- (modified) mlir/lib/Conversion/SPIRVToLLVM/SPIRVToLLVM.cpp (+17-9) \n- (modified) mlir/test/Conversion/SPIRVToLLVM/spirv-types-to-llvm-invalid.mlir (+7) \n\n\n``````````diff\ndiff --git a/mlir/lib/Conversion/SPIRVToLLVM/SPIRVToLLVM.cpp b/mlir/lib/Conversion/SPIRVToLLVM/SPIRVToLLVM.cpp\nindex 60f34f413f587d4..5f752765f6d7f20 100644\n--- a/mlir/lib/Conversion/SPIRVToLLVM/SPIRVToLLVM.cpp\n+++ b/mlir/lib/Conversion/SPIRVToLLVM/SPIRVToLLVM.cpp\n@@ -199,6 +199,16 @@ static Value processCountOrOffset(Location loc, Value value, Type srcType,\n   return optionallyTruncateOrExtend(loc, broadcasted, dstType, rewriter);\n }\n \n+static bool convertTypes(LLVMTypeConverter &converter, const spirv::StructType::ElementTypeRange &types, SmallVectorImpl<Type> &out) {\n+  for(const auto &type: types) {\n+    if(auto convertedType = converter.convertType(type))\n+      out.push_back(convertedType);\n+    else\n+      return false;\n+  }\n+  return true;\n+}\n+\n /// Converts SPIR-V struct with a regular (according to `VulkanLayoutUtils`)\n /// offset to LLVM struct. Otherwise, the conversion is not supported.\n static std::optional<Type>\n@@ -207,21 +217,19 @@ convertStructTypeWithOffset(spirv::StructType type,\n   if (type != VulkanLayoutUtils::decorateType(type))\n     return std::nullopt;\n \n-  auto elementsVector = llvm::to_vector<8>(\n-      llvm::map_range(type.getElementTypes(), [&](Type elementType) {\n-        return converter.convertType(elementType);\n-      }));\n+  SmallVector<Type> elementsVector;\n+  if(!convertTypes(converter, type.getElementTypes(), elementsVector))\n+    return std::nullopt;\n   return LLVM::LLVMStructType::getLiteral(type.getContext(), elementsVector,\n                                           /*isPacked=*/false);\n }\n \n /// Converts SPIR-V struct with no offset to packed LLVM struct.\n-static Type convertStructTypePacked(spirv::StructType type,\n+static std::optional<Type> convertStructTypePacked(spirv::StructType type,\n                                     LLVMTypeConverter &converter) {\n-  auto elementsVector = llvm::to_vector<8>(\n-      llvm::map_range(type.getElementTypes(), [&](Type elementType) {\n-        return converter.convertType(elementType);\n-      }));\n+  SmallVector<Type> elementsVector;\n+  if(!convertTypes(converter, type.getElementTypes(), elementsVector))\n+    return std::nullopt;\n   return LLVM::LLVMStructType::getLiteral(type.getContext(), elementsVector,\n                                           /*isPacked=*/true);\n }\ndiff --git a/mlir/test/Conversion/SPIRVToLLVM/spirv-types-to-llvm-invalid.mlir b/mlir/test/Conversion/SPIRVToLLVM/spirv-types-to-llvm-invalid.mlir\nindex 3965c47ec199fcb..438c90205abedc4 100644\n--- a/mlir/test/Conversion/SPIRVToLLVM/spirv-types-to-llvm-invalid.mlir\n+++ b/mlir/test/Conversion/SPIRVToLLVM/spirv-types-to-llvm-invalid.mlir\n@@ -7,6 +7,13 @@ spirv.func @array_with_unnatural_stride(%arg: !spirv.array<4 x f32, stride=8>) -\n \n // -----\n \n+// expected-error@+1 {{failed to legalize operation 'spirv.func' that was explicitly marked illegal}}\n+spirv.func @struct_array_with_unnatural_stride(%arg: !spirv.struct<(!spirv.array<4 x f32, stride=8>)>) -> () \"None\" {\n+  spirv.Return\n+}\n+\n+// -----\n+\n // expected-error@+1 {{failed to legalize operation 'spirv.func' that was explicitly marked illegal}}\n spirv.func @struct_with_unnatural_offset(%arg: !spirv.struct<(i32[0], i32[8])>) -> () \"None\" {\n   spirv.Return\n\n``````````\n\n</details>\n",
      "<!--LLVM CODE FORMAT COMMENT: {clang-format}-->\n\n\n:white_check_mark: With the latest revision this PR passed the C/C++ code formatter.\n",
      "> Change LGTM. Also checking element types for other compound types (`ArrayType`, `PointerType` and `RuntimeArrayType`) would be a plus.\r\n\r\nI'm not too familiar with SPIRV semantics so I just want to focus on avoiding the crash in this patch.\r\n@kuhar is this good to land?"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Step-by-Step Explanation:**\n\n1. **Input Analysis:** The commit and vulnerability description address a crash due to null struct elements. The code adds type conversion checks before creating a struct.\n\n2. **Consistency Check:** The message matches the code change; no discrepancies found.\n\n3. **Purpose Evaluation:** Fixes a bug leading to a crash, ensuring all types convert properly.\n\n4. **Security Assessment:** Not a security issue; it's a crash due to programming error, not an exploit.\n\n5. **Non-Security Classification:** Falls under Defect Remediation as it fixes a core logic bug.\n\n**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.9"
}