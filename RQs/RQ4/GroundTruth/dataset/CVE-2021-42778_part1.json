{
  "cve_id": "CVE-2021-42778",
  "cwe_ids": [
    "CWE-415"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "OpenSC",
  "commit_msg": "idprime: Use temporary variable instead of messing up the passed one\n\nThanks oss-fuzz\n\nhttps://bugs.chromium.org/p/oss-fuzz/issues/detail?id=28185",
  "commit_hash": "f015746d",
  "git_url": "https://github.com/OpenSC/OpenSC/commit/f015746d22d249642c19674298a18ad824db0ed7",
  "file_path": "src/libopensc/card-idprime.c",
  "func_name": "idprime_get_token_name",
  "func_before": "static int idprime_get_token_name(sc_card_t* card, char** tname)\n{\n\tidprime_private_data_t * priv = card->drv_data;\n\tsc_path_t tinfo_path = {\"\\x00\\x00\", 2, 0, 0, SC_PATH_TYPE_PATH, {\"\", 0}};\n\tsc_file_t *file = NULL;\n\tu8 buf[2];\n\tint r;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tif (tname == NULL) {\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_ARGUMENTS);\n\t}\n\n\tif (!priv->tinfo_present) {\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_NOT_SUPPORTED);\n\t}\n\n\tmemcpy(tinfo_path.value, priv->tinfo_df, 2);\n\tr = iso_ops->select_file(card, &tinfo_path, &file);\n\tif (r != SC_SUCCESS || file->size == 0) {\n\t\tsc_file_free(file);\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_NOT_SUPPORTED);\n\t}\n\n\t/* First two bytes lists 0x01, the second indicates length */\n\tr = iso_ops->read_binary(card, 0, buf, 2, 0);\n\tif (r < 2 || buf[1] > file->size) { /* make sure we do not overrun */\n\t\tsc_file_free(file);\n\t\tLOG_FUNC_RETURN(card->ctx, r);\n\t}\n\tsc_file_free(file);\n\n\t*tname = malloc(buf[1]);\n\tif (*tname == NULL) {\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t}\n\n\tr = iso_ops->read_binary(card, 2, (unsigned char *)*tname, buf[1], 0);\n\tif (r < 1) {\n\t\tfree(*tname);\n\t\tLOG_FUNC_RETURN(card->ctx, r);\n\t}\n\n\tif ((*tname)[r-1] != '\\0') {\n\t\t(*tname)[r-1] = '\\0';\n\t}\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}",
  "abstract_func_before": "static int idprime_get_token_name(sc_card_t* VAR_0, char** VAR_1)\n{\n\tidprime_private_data_t * VAR_2 = VAR_0->drv_data;\n\tsc_path_t VAR_3 = {\"\\x00\\x00\", 2, 0, 0, VAR_4, {\"\", 0}};\n\tsc_file_t *VAR_5 = NULL;\n\tu8 VAR_6[2];\n\tint VAR_7;\n\n\tLOG_FUNC_CALLED(VAR_0->ctx);\n\n\tif (VAR_1 == NULL) {\n\t\tLOG_FUNC_RETURN(VAR_0->ctx, VAR_8);\n\t}\n\n\tif (!VAR_2->tinfo_present) {\n\t\tLOG_FUNC_RETURN(VAR_0->ctx, VAR_9);\n\t}\n\n\tmemcpy(VAR_3.value, VAR_2->tinfo_df, 2);\n\tVAR_7 = VAR_10->select_file(VAR_0, &VAR_3, &VAR_5);\n\tif (VAR_7 != VAR_11 || VAR_5->size == 0) {\n\t\tsc_file_free(VAR_5);\n\t\tLOG_FUNC_RETURN(VAR_0->ctx, VAR_9);\n\t}\n\n\t/* COMMENT_0 */\n\tVAR_7 = VAR_10->read_binary(VAR_0, 0, VAR_6, 2, 0);\n\tif (VAR_7 < 2 || VAR_6[1] > VAR_5->size) { /* COMMENT_1 */\n\t\tsc_file_free(VAR_5);\n\t\tLOG_FUNC_RETURN(VAR_0->ctx, VAR_7);\n\t}\n\tsc_file_free(VAR_5);\n\n\t*VAR_1 = malloc(VAR_6[1]);\n\tif (*VAR_1 == NULL) {\n\t\tLOG_FUNC_RETURN(VAR_0->ctx, VAR_12);\n\t}\n\n\tVAR_7 = VAR_10->read_binary(VAR_0, 2, (unsigned char *)*VAR_1, VAR_6[1], 0);\n\tif (VAR_7 < 1) {\n\t\tfree(*VAR_1);\n\t\tLOG_FUNC_RETURN(VAR_0->ctx, VAR_7);\n\t}\n\n\tif ((*VAR_1)[VAR_7-1] != '\\0') {\n\t\t(*VAR_1)[VAR_7-1] = '\\0';\n\t}\n\tLOG_FUNC_RETURN(VAR_0->ctx, VAR_11);\n}",
  "func_graph_path_before": "OpenSC/f015746d/card-idprime.c/vul/before/0.json",
  "func": "static int idprime_get_token_name(sc_card_t* card, char** tname)\n{\n\tidprime_private_data_t * priv = card->drv_data;\n\tsc_path_t tinfo_path = {\"\\x00\\x00\", 2, 0, 0, SC_PATH_TYPE_PATH, {\"\", 0}};\n\tsc_file_t *file = NULL;\n\tu8 buf[2];\n\tchar *name;\n\tint r;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tif (tname == NULL) {\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_ARGUMENTS);\n\t}\n\n\tif (!priv->tinfo_present) {\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_NOT_SUPPORTED);\n\t}\n\n\tmemcpy(tinfo_path.value, priv->tinfo_df, 2);\n\tr = iso_ops->select_file(card, &tinfo_path, &file);\n\tif (r != SC_SUCCESS || file->size == 0) {\n\t\tsc_file_free(file);\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_NOT_SUPPORTED);\n\t}\n\n\t/* First two bytes lists 0x01, the second indicates length */\n\tr = iso_ops->read_binary(card, 0, buf, 2, 0);\n\tif (r < 2 || buf[1] > file->size) { /* make sure we do not overrun */\n\t\tsc_file_free(file);\n\t\tLOG_FUNC_RETURN(card->ctx, r);\n\t}\n\tsc_file_free(file);\n\n\tname = malloc(buf[1]);\n\tif (name == NULL) {\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t}\n\n\tr = iso_ops->read_binary(card, 2, (unsigned char *)name, buf[1], 0);\n\tif (r < 1) {\n\t\tfree(name);\n\t\tLOG_FUNC_RETURN(card->ctx, r);\n\t}\n\n\tif (name[r-1] != '\\0') {\n\t\tname[r-1] = '\\0';\n\t}\n\t*tname = name;\n\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}",
  "abstract_func": "static int idprime_get_token_name(sc_card_t* VAR_0, char** VAR_1)\n{\n\tidprime_private_data_t * VAR_2 = VAR_0->drv_data;\n\tsc_path_t VAR_3 = {\"\\x00\\x00\", 2, 0, 0, VAR_4, {\"\", 0}};\n\tsc_file_t *VAR_5 = NULL;\n\tu8 VAR_6[2];\n\tchar *VAR_7;\n\tint VAR_8;\n\n\tLOG_FUNC_CALLED(VAR_0->ctx);\n\n\tif (VAR_1 == NULL) {\n\t\tLOG_FUNC_RETURN(VAR_0->ctx, VAR_9);\n\t}\n\n\tif (!VAR_2->tinfo_present) {\n\t\tLOG_FUNC_RETURN(VAR_0->ctx, VAR_10);\n\t}\n\n\tmemcpy(VAR_3.value, VAR_2->tinfo_df, 2);\n\tVAR_8 = VAR_11->select_file(VAR_0, &VAR_3, &VAR_5);\n\tif (VAR_8 != VAR_12 || VAR_5->size == 0) {\n\t\tsc_file_free(VAR_5);\n\t\tLOG_FUNC_RETURN(VAR_0->ctx, VAR_10);\n\t}\n\n\t/* COMMENT_0 */\n\tVAR_8 = VAR_11->read_binary(VAR_0, 0, VAR_6, 2, 0);\n\tif (VAR_8 < 2 || VAR_6[1] > VAR_5->size) { /* COMMENT_1 */\n\t\tsc_file_free(VAR_5);\n\t\tLOG_FUNC_RETURN(VAR_0->ctx, VAR_8);\n\t}\n\tsc_file_free(VAR_5);\n\n\tVAR_7 = malloc(VAR_6[1]);\n\tif (VAR_7 == NULL) {\n\t\tLOG_FUNC_RETURN(VAR_0->ctx, VAR_13);\n\t}\n\n\tVAR_8 = VAR_11->read_binary(VAR_0, 2, (unsigned char *)VAR_7, VAR_6[1], 0);\n\tif (VAR_8 < 1) {\n\t\tfree(VAR_7);\n\t\tLOG_FUNC_RETURN(VAR_0->ctx, VAR_8);\n\t}\n\n\tif (VAR_7[VAR_8-1] != '\\0') {\n\t\tVAR_7[VAR_8-1] = '\\0';\n\t}\n\t*VAR_1 = VAR_7;\n\n\tLOG_FUNC_RETURN(VAR_0->ctx, VAR_12);\n}",
  "func_graph_path": "OpenSC/f015746d/card-idprime.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,7 @@\n \tsc_path_t tinfo_path = {\"\\x00\\x00\", 2, 0, 0, SC_PATH_TYPE_PATH, {\"\", 0}};\n \tsc_file_t *file = NULL;\n \tu8 buf[2];\n+\tchar *name;\n \tint r;\n \n \tLOG_FUNC_CALLED(card->ctx);\n@@ -31,19 +32,21 @@\n \t}\n \tsc_file_free(file);\n \n-\t*tname = malloc(buf[1]);\n-\tif (*tname == NULL) {\n+\tname = malloc(buf[1]);\n+\tif (name == NULL) {\n \t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n \t}\n \n-\tr = iso_ops->read_binary(card, 2, (unsigned char *)*tname, buf[1], 0);\n+\tr = iso_ops->read_binary(card, 2, (unsigned char *)name, buf[1], 0);\n \tif (r < 1) {\n-\t\tfree(*tname);\n+\t\tfree(name);\n \t\tLOG_FUNC_RETURN(card->ctx, r);\n \t}\n \n-\tif ((*tname)[r-1] != '\\0') {\n-\t\t(*tname)[r-1] = '\\0';\n+\tif (name[r-1] != '\\0') {\n+\t\tname[r-1] = '\\0';\n \t}\n+\t*tname = name;\n+\n \tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n }",
  "diff_line_info": {
    "deleted_lines": [
      "\t*tname = malloc(buf[1]);",
      "\tif (*tname == NULL) {",
      "\tr = iso_ops->read_binary(card, 2, (unsigned char *)*tname, buf[1], 0);",
      "\t\tfree(*tname);",
      "\tif ((*tname)[r-1] != '\\0') {",
      "\t\t(*tname)[r-1] = '\\0';"
    ],
    "added_lines": [
      "\tchar *name;",
      "\tname = malloc(buf[1]);",
      "\tif (name == NULL) {",
      "\tr = iso_ops->read_binary(card, 2, (unsigned char *)name, buf[1], 0);",
      "\t\tfree(name);",
      "\tif (name[r-1] != '\\0') {",
      "\t\tname[r-1] = '\\0';",
      "\t*tname = name;",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/OpenSC/OpenSC/pull/2169",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/OpenSC/OpenSC/pull/2169: 403 Client Error: Forbidden for url: https://api.github.com/repos/OpenSC/OpenSC/pulls/2169",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.8\n\nThe patch addresses a pointer management issue, likely preventing memory corruption, which suggests a security fix, though without an explicit CVE, confidence is moderate."
}