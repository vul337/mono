{
  "cve_id": "CVE-2023-0302",
  "cwe_ids": [
    "CWE-74"
  ],
  "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "radareorg/radare2",
  "commit_msg": "Fix ANSI Escape Sequence Injection vulns via DWARF ##vuln\n\n* Reported by @solid-snail via huntrdev\r\n* BountyID: 583133af-7ae6-4a21-beef-a4b0182cf82e\r\n* Reproducer: dwarf_test_func_patched",
  "commit_hash": "961f0e723903011d4f54c2396e44efa91fcc74ce",
  "git_url": "https://github.com/radareorg/radare2/commit/961f0e723903011d4f54c2396e44efa91fcc74ce",
  "file_path": "libr/bin/dwarf.c",
  "func_name": "parse_attr_value",
  "func_before": "static const ut8 *parse_attr_value(const ut8 *obuf, int obuf_len,\n\t\tRBinDwarfAttrDef *def, RBinDwarfAttrValue *value,\n\t\tconst RBinDwarfCompUnitHdr *hdr,\n\t\tconst ut8 *debug_str, size_t debug_str_len) {\n\tr_return_val_if_fail (def && value && hdr && obuf, NULL);\n\n\tvalue->attr_form = def->attr_form;\n\tvalue->attr_name = def->attr_name;\n\tvalue->block.data = NULL;\n\tvalue->string.content = NULL;\n\tvalue->string.offset = 0;\n\n\n\tconst ut8 *buf = obuf;\n\tconst ut8 *buf_end = obuf + obuf_len;\n\tsize_t j;\n\n\tif (obuf_len < 1) {\n\t\treturn NULL;\n\t}\n\n\t// http://www.dwarfstd.org/doc/DWARF4.pdf#page=161&zoom=100,0,560\n\tswitch (def->attr_form) {\n\tcase DW_FORM_addr:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tswitch (hdr->address_size) {\n\t\tcase 1:\n\t\t\tvalue->address = READ8 (buf);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tvalue->address = READ16 (buf);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tvalue->address = READ32 (buf);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tvalue->address = READ64 (buf);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tR_LOG_WARN (\"DWARF: Unexpected pointer size: %u\", (unsigned)hdr->address_size);\n\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_data1:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ8 (buf);\n\t\tbreak;\n\tcase DW_FORM_data2:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ16 (buf);\n\t\tbreak;\n\tcase DW_FORM_data4:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_data8:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ64 (buf);\n\t\tbreak;\n\tcase DW_FORM_data16: // TODO Fix this, right now I just read the data, but I need to make storage for it\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ64 (buf);\n\t\tvalue->uconstant = READ64 (buf);\n\t\tbreak;\n\tcase DW_FORM_sdata:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tbuf = r_leb128 (buf, buf_end - buf, &value->sconstant);\n\t\tbreak;\n\tcase DW_FORM_udata:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->uconstant, NULL);\n\t\tbreak;\n\tcase DW_FORM_string:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.content = *buf ? r_str_ndup ((const char *)buf, buf_end - buf) : NULL;\n\t\tif (value->string.content) {\n\t\t\tbuf += strlen (value->string.content) + 1;\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_block1:\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tvalue->block.length = READ8 (buf);\n\t\tbuf = fill_block_data (buf, buf_end, &value->block);\n\t\tbreak;\n\tcase DW_FORM_block2:\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tvalue->block.length = READ16 (buf);\n\t\tif (value->block.length > 0) {\n\t\t\tvalue->block.data = calloc (sizeof (ut8), value->block.length);\n\t\t\tif (!value->block.data) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tfor (j = 0; j < value->block.length; j++) {\n\t\t\t\tvalue->block.data[j] = READ (buf, ut8);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_block4:\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tvalue->block.length = READ32 (buf);\n\t\tbuf = fill_block_data (buf, buf_end, &value->block);\n\t\tbreak;\n\tcase DW_FORM_block: // variable length ULEB128\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->block.length, NULL);\n\t\tif (!buf || buf >= buf_end) {\n\t\t\treturn NULL;\n\t\t}\n\t\tbuf = fill_block_data (buf, buf_end, &value->block);\n\t\tbreak;\n\tcase DW_FORM_flag:\n\t\tvalue->kind = DW_AT_KIND_FLAG;\n\t\tvalue->flag = READ (buf, ut8);\n\t\tbreak;\n\t// offset in .debug_str\n\tcase DW_FORM_strp:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\t\tif (debug_str && value->string.offset < debug_str_len) {\n\t\t\tconst char *ds = (const char *)(debug_str + value->string.offset);\n\t\t\tvalue->string.content = strdup (ds); // r_str_ndup (ds, debug_str_len - value->string.offset);\n\t\t} else {\n\t\t\tvalue->string.content = NULL; // Means malformed DWARF, should we print error message?\n\t\t}\n\t\tbreak;\n\t// offset in .debug_info\n\tcase DW_FORM_ref_addr:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\t\tbreak;\n\t// This type of reference is an offset from the first byte of the compilation\n\t// header for the compilation unit containing the reference\n\tcase DW_FORM_ref1:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = hdr->unit_offset + READ8 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref2:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = hdr->unit_offset + READ16 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref4:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = hdr->unit_offset + READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref8:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = hdr->unit_offset + READ64 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref_udata:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\t// uleb128 is enough to fit into ut64?\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->reference, NULL);\n\t\tvalue->reference += hdr->unit_offset;\n\t\tbreak;\n\t// offset in a section other than .debug_info or .debug_str\n\tcase DW_FORM_sec_offset:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = dwarf_read_offset(hdr->is_64bit, &buf, buf_end);\n\t\tbreak;\n\tcase DW_FORM_exprloc:\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->block.length, NULL);\n\t\tif (!buf || buf >= buf_end) {\n\t\t\treturn NULL;\n\t\t}\n\t\tbuf = fill_block_data (buf, buf_end, &value->block);\n\t\tbreak;\n\t// this means that the flag is present, nothing is read\n\tcase DW_FORM_flag_present:\n\t\tvalue->kind = DW_AT_KIND_FLAG;\n\t\tvalue->flag = true;\n\t\tbreak;\n\tcase DW_FORM_ref_sig8:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = READ64 (buf);\n\t\tbreak;\n\t// offset into .debug_line_str section, can't parse the section now, so we just skip\n\tcase DW_FORM_strx:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\t// value->string.offset = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\t\t// if (debug_str && value->string.offset < debug_line_str_len) {\n\t\t// \tvalue->string.content =\n\t\t// \t\tstrdup ((const char *)(debug_str + value->string.offset));\n\t\t// } else {\n\t\t// \tvalue->string.content = NULL; // Means malformed DWARF, should we print error message?\n\t\t// }\n\t\tbreak;\n\tcase DW_FORM_strx1:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = READ8 (buf);\n\t\tbreak;\n\tcase DW_FORM_strx2:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = READ16 (buf);\n\t\tbreak;\n\tcase DW_FORM_strx3: // TODO Add 3 byte int read\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tbuf += 3;\n\t\tbreak;\n\tcase DW_FORM_strx4:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_implicit_const:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = def->special;\n\t\tbreak;\n\t/*  addrx* forms : The index is relative to the value of the\n\t\tDW_AT_addr_base attribute of the associated compilation unit.\n\t    index into an array of addresses in the .debug_addr section.*/\n\tcase DW_FORM_addrx:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->address, NULL);\n\t\tbreak;\n\tcase DW_FORM_addrx1:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tvalue->address = READ8 (buf);\n\t\tbreak;\n\tcase DW_FORM_addrx2:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tvalue->address = READ16 (buf);\n\t\tbreak;\n\tcase DW_FORM_addrx3:\n\t\t// I need to add 3byte endianess free read here TODO\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tbuf += 3;\n\t\tbreak;\n\tcase DW_FORM_addrx4:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tvalue->address = READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_line_ptr: // offset in a section .debug_line_str\n\tcase DW_FORM_strp_sup: // offset in a section .debug_line_str\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\t\t// if (debug_str && value->string.offset < debug_line_str_len) {\n\t\t// \tvalue->string.content =\n\t\t// \t\tstrdupsts\n\t\tbreak;\n\t// offset in the supplementary object file\n\tcase DW_FORM_ref_sup4:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref_sup8:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = READ64 (buf);\n\t\tbreak;\n\t// An index into the .debug_loc\n\tcase DW_FORM_loclistx:\n\t\tvalue->kind = DW_AT_KIND_LOCLISTPTR;\n\t\tvalue->reference = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\t\tbreak;\n\t // An index into the .debug_rnglists\n\tcase DW_FORM_rnglistx:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->address, NULL);\n\t\tbreak;\n\tcase 0:\n\t\tvalue->uconstant = 0;\n\t\treturn NULL;\n\tdefault:\n\t\tR_LOG_WARN (\"Unknown DW_FORM 0x%02\" PFMT64x, def->attr_form);\n\t\tvalue->uconstant = 0;\n\t\treturn NULL;\n\t}\n\treturn buf;\n}",
  "abstract_func_before": "static const ut8 *parse_attr_value(const ut8 *VAR_0, int VAR_1,\n\t\tRBinDwarfAttrDef *VAR_2, RBinDwarfAttrValue *VAR_3,\n\t\tconst RBinDwarfCompUnitHdr *VAR_4,\n\t\tconst ut8 *VAR_5, size_t VAR_6) {\n\tr_return_val_if_fail (VAR_2 && VAR_3 && VAR_4 && VAR_0, NULL);\n\n\tVAR_3->attr_form = VAR_2->attr_form;\n\tVAR_3->attr_name = VAR_2->attr_name;\n\tVAR_3->block.data = NULL;\n\tVAR_3->string.content = NULL;\n\tVAR_3->string.offset = 0;\n\n\n\tconst ut8 *VAR_7 = VAR_0;\n\tconst ut8 *VAR_8 = VAR_0 + VAR_1;\n\tsize_t VAR_9;\n\n\tif (VAR_1 < 1) {\n\t\treturn NULL;\n\t}\n\n\t/* COMMENT_0 */\n\tswitch (VAR_2->attr_form) {\n\tcase VAR_10:\n\t\tVAR_3->kind = VAR_11;\n\t\tswitch (VAR_4->address_size) {\n\t\tcase 1:\n\t\t\tVAR_3->address = READ8 (VAR_7);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tVAR_3->address = READ16 (VAR_7);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tVAR_3->address = READ32 (VAR_7);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tVAR_3->address = READ64 (VAR_7);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tR_LOG_WARN (\"DWARF: Unexpected pointer size: %u\", (unsigned)VAR_4->address_size);\n\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n\tcase VAR_12:\n\t\tVAR_3->kind = VAR_13;\n\t\tVAR_3->uconstant = READ8 (VAR_7);\n\t\tbreak;\n\tcase VAR_14:\n\t\tVAR_3->kind = VAR_13;\n\t\tVAR_3->uconstant = READ16 (VAR_7);\n\t\tbreak;\n\tcase VAR_15:\n\t\tVAR_3->kind = VAR_13;\n\t\tVAR_3->uconstant = READ32 (VAR_7);\n\t\tbreak;\n\tcase VAR_16:\n\t\tVAR_3->kind = VAR_13;\n\t\tVAR_3->uconstant = READ64 (VAR_7);\n\t\tbreak;\n\tcase VAR_17: /* COMMENT_1 */\n\t\tVAR_3->kind = VAR_13;\n\t\tVAR_3->uconstant = READ64 (VAR_7);\n\t\tVAR_3->uconstant = READ64 (VAR_7);\n\t\tbreak;\n\tcase VAR_18:\n\t\tVAR_3->kind = VAR_13;\n\t\tVAR_7 = r_leb128 (VAR_7, VAR_8 - VAR_7, &VAR_3->sconstant);\n\t\tbreak;\n\tcase VAR_19:\n\t\tVAR_3->kind = VAR_13;\n\t\tVAR_7 = r_uleb128 (VAR_7, VAR_8 - VAR_7, &VAR_3->uconstant, NULL);\n\t\tbreak;\n\tcase VAR_20:\n\t\tVAR_3->kind = VAR_21;\n\t\tVAR_3->string.content = *VAR_7 ? r_str_ndup ((const char *)VAR_7, VAR_8 - VAR_7) : NULL;\n\t\tif (VAR_3->string.content) {\n\t\t\tVAR_7 += strlen (VAR_3->string.content) + 1;\n\t\t}\n\t\tbreak;\n\tcase VAR_22:\n\t\tVAR_3->kind = VAR_23;\n\t\tVAR_3->block.length = READ8 (VAR_7);\n\t\tVAR_7 = fill_block_data (VAR_7, VAR_8, &VAR_3->block);\n\t\tbreak;\n\tcase VAR_24:\n\t\tVAR_3->kind = VAR_23;\n\t\tVAR_3->block.length = READ16 (VAR_7);\n\t\tif (VAR_3->block.length > 0) {\n\t\t\tVAR_3->block.data = calloc (sizeof (ut8), VAR_3->block.length);\n\t\t\tif (!VAR_3->block.data) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tfor (VAR_9 = 0; VAR_9 < VAR_3->block.length; VAR_9++) {\n\t\t\t\tVAR_3->block.data[VAR_9] = READ (VAR_7, ut8);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase VAR_25:\n\t\tVAR_3->kind = VAR_23;\n\t\tVAR_3->block.length = READ32 (VAR_7);\n\t\tVAR_7 = fill_block_data (VAR_7, VAR_8, &VAR_3->block);\n\t\tbreak;\n\tcase VAR_26: /* COMMENT_2 */\n\t\tVAR_3->kind = VAR_23;\n\t\tVAR_7 = r_uleb128 (VAR_7, VAR_8 - VAR_7, &VAR_3->block.length, NULL);\n\t\tif (!VAR_7 || VAR_7 >= VAR_8) {\n\t\t\treturn NULL;\n\t\t}\n\t\tVAR_7 = fill_block_data (VAR_7, VAR_8, &VAR_3->block);\n\t\tbreak;\n\tcase VAR_27:\n\t\tVAR_3->kind = VAR_28;\n\t\tVAR_3->flag = READ (VAR_7, ut8);\n\t\tbreak;\n\t/* COMMENT_3 */\n\tcase VAR_29:\n\t\tVAR_3->kind = VAR_21;\n\t\tVAR_3->string.offset = dwarf_read_offset (VAR_4->is_64bit, &VAR_7, VAR_8);\n\t\tif (VAR_5 && VAR_3->string.offset < VAR_6) {\n\t\t\tconst char *VAR_30 = (const char *)(VAR_5 + VAR_3->string.offset);\n\t\t\tVAR_3->string.content = strdup (VAR_30); /* COMMENT_4 */\n\t\t} else {\n\t\t\tVAR_3->string.content = NULL; /* COMMENT_5 */\n\t\t}\n\t\tbreak;\n\t/* COMMENT_6 */\n\tcase VAR_31:\n\t\tVAR_3->kind = VAR_32;\n\t\tVAR_3->reference = dwarf_read_offset (VAR_4->is_64bit, &VAR_7, VAR_8);\n\t\tbreak;\n\t/* COMMENT_7 */\n\t/* COMMENT_8 */\n\tcase VAR_33:\n\t\tVAR_3->kind = VAR_32;\n\t\tVAR_3->reference = VAR_4->unit_offset + READ8 (VAR_7);\n\t\tbreak;\n\tcase VAR_34:\n\t\tVAR_3->kind = VAR_32;\n\t\tVAR_3->reference = VAR_4->unit_offset + READ16 (VAR_7);\n\t\tbreak;\n\tcase VAR_35:\n\t\tVAR_3->kind = VAR_32;\n\t\tVAR_3->reference = VAR_4->unit_offset + READ32 (VAR_7);\n\t\tbreak;\n\tcase VAR_36:\n\t\tVAR_3->kind = VAR_32;\n\t\tVAR_3->reference = VAR_4->unit_offset + READ64 (VAR_7);\n\t\tbreak;\n\tcase VAR_37:\n\t\tVAR_3->kind = VAR_32;\n\t\t/* COMMENT_9 */\n\t\tVAR_7 = r_uleb128 (VAR_7, VAR_8 - VAR_7, &VAR_3->reference, NULL);\n\t\tVAR_3->reference += VAR_4->unit_offset;\n\t\tbreak;\n\t/* COMMENT_10 */\n\tcase VAR_38:\n\t\tVAR_3->kind = VAR_32;\n\t\tVAR_3->reference = dwarf_read_offset(VAR_4->is_64bit, &VAR_7, VAR_8);\n\t\tbreak;\n\tcase VAR_39:\n\t\tVAR_3->kind = VAR_23;\n\t\tVAR_7 = r_uleb128 (VAR_7, VAR_8 - VAR_7, &VAR_3->block.length, NULL);\n\t\tif (!VAR_7 || VAR_7 >= VAR_8) {\n\t\t\treturn NULL;\n\t\t}\n\t\tVAR_7 = fill_block_data (VAR_7, VAR_8, &VAR_3->block);\n\t\tbreak;\n\t/* COMMENT_11 */\n\tcase VAR_40:\n\t\tVAR_3->kind = VAR_28;\n\t\tVAR_3->flag = true;\n\t\tbreak;\n\tcase VAR_41:\n\t\tVAR_3->kind = VAR_32;\n\t\tVAR_3->reference = READ64 (VAR_7);\n\t\tbreak;\n\t/* COMMENT_12 */\n\tcase VAR_42:\n\t\tVAR_3->kind = VAR_21;\n\t\t/* COMMENT_13 */\n\t\t/* COMMENT_14 */\n\t\t/* COMMENT_15 */\n\t\t/* COMMENT_16 */\n\t\t/* COMMENT_17 */\n\t\t/* COMMENT_18 */\n\t\t/* COMMENT_19 */\n\t\tbreak;\n\tcase VAR_43:\n\t\tVAR_3->kind = VAR_21;\n\t\tVAR_3->string.offset = READ8 (VAR_7);\n\t\tbreak;\n\tcase VAR_44:\n\t\tVAR_3->kind = VAR_21;\n\t\tVAR_3->string.offset = READ16 (VAR_7);\n\t\tbreak;\n\tcase VAR_45: /* COMMENT_20 */\n\t\tVAR_3->kind = VAR_21;\n\t\tVAR_7 += 3;\n\t\tbreak;\n\tcase VAR_46:\n\t\tVAR_3->kind = VAR_21;\n\t\tVAR_3->string.offset = READ32 (VAR_7);\n\t\tbreak;\n\tcase VAR_47:\n\t\tVAR_3->kind = VAR_13;\n\t\tVAR_3->uconstant = VAR_2->special;\n\t\tbreak;\n\t/* COMMENT_21 */\n                                                               \n                                                                   \n\tcase VAR_48:\n\t\tVAR_3->kind = VAR_11;\n\t\tVAR_7 = r_uleb128 (VAR_7, VAR_8 - VAR_7, &VAR_3->address, NULL);\n\t\tbreak;\n\tcase VAR_49:\n\t\tVAR_3->kind = VAR_11;\n\t\tVAR_3->address = READ8 (VAR_7);\n\t\tbreak;\n\tcase VAR_50:\n\t\tVAR_3->kind = VAR_11;\n\t\tVAR_3->address = READ16 (VAR_7);\n\t\tbreak;\n\tcase VAR_51:\n\t\t/* COMMENT_24 */\n\t\tVAR_3->kind = VAR_11;\n\t\tVAR_7 += 3;\n\t\tbreak;\n\tcase VAR_52:\n\t\tVAR_3->kind = VAR_11;\n\t\tVAR_3->address = READ32 (VAR_7);\n\t\tbreak;\n\tcase VAR_53: /* COMMENT_25 */\n\tcase VAR_54: /* COMMENT_25 */\n\t\tVAR_3->kind = VAR_21;\n\t\tVAR_3->string.offset = dwarf_read_offset (VAR_4->is_64bit, &VAR_7, VAR_8);\n\t\t/* COMMENT_14 */\n\t\t/* COMMENT_15 */\n\t\t/* COMMENT_26 */\n\t\tbreak;\n\t/* COMMENT_27 */\n\tcase VAR_55:\n\t\tVAR_3->kind = VAR_32;\n\t\tVAR_3->reference = READ32 (VAR_7);\n\t\tbreak;\n\tcase VAR_56:\n\t\tVAR_3->kind = VAR_32;\n\t\tVAR_3->reference = READ64 (VAR_7);\n\t\tbreak;\n\t/* COMMENT_28 */\n\tcase VAR_57:\n\t\tVAR_3->kind = VAR_58;\n\t\tVAR_3->reference = dwarf_read_offset (VAR_4->is_64bit, &VAR_7, VAR_8);\n\t\tbreak;\n\t /* COMMENT_29 */\n\tcase VAR_59:\n\t\tVAR_3->kind = VAR_11;\n\t\tVAR_7 = r_uleb128 (VAR_7, VAR_8 - VAR_7, &VAR_3->address, NULL);\n\t\tbreak;\n\tcase 0:\n\t\tVAR_3->uconstant = 0;\n\t\treturn NULL;\n\tdefault:\n\t\tR_LOG_WARN (\"Unknown DW_FORM 0x%02\" VAR_60, VAR_2->attr_form);\n\t\tVAR_3->uconstant = 0;\n\t\treturn NULL;\n\t}\n\treturn VAR_7;\n}",
  "func_graph_path_before": "radareorg/radare2/961f0e723903011d4f54c2396e44efa91fcc74ce/dwarf.c/vul/before/1.json",
  "func": "static const ut8 *parse_attr_value(const ut8 *obuf, int obuf_len,\n\t\tRBinDwarfAttrDef *def, RBinDwarfAttrValue *value,\n\t\tconst RBinDwarfCompUnitHdr *hdr,\n\t\tconst ut8 *debug_str, size_t debug_str_len) {\n\tr_return_val_if_fail (def && value && hdr && obuf, NULL);\n\n\tvalue->attr_form = def->attr_form;\n\tvalue->attr_name = def->attr_name;\n\tvalue->block.data = NULL;\n\tvalue->string.content = NULL;\n\tvalue->string.offset = 0;\n\n\n\tconst ut8 *buf = obuf;\n\tconst ut8 *buf_end = obuf + obuf_len;\n\tsize_t j;\n\n\tif (obuf_len < 1) {\n\t\treturn NULL;\n\t}\n\n\t// http://www.dwarfstd.org/doc/DWARF4.pdf#page=161&zoom=100,0,560\n\tswitch (def->attr_form) {\n\tcase DW_FORM_addr:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tswitch (hdr->address_size) {\n\t\tcase 1:\n\t\t\tvalue->address = READ8 (buf);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tvalue->address = READ16 (buf);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tvalue->address = READ32 (buf);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tvalue->address = READ64 (buf);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tR_LOG_WARN (\"DWARF: Unexpected pointer size: %u\", (unsigned)hdr->address_size);\n\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_data1:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ8 (buf);\n\t\tbreak;\n\tcase DW_FORM_data2:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ16 (buf);\n\t\tbreak;\n\tcase DW_FORM_data4:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_data8:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ64 (buf);\n\t\tbreak;\n\tcase DW_FORM_data16: // TODO Fix this, right now I just read the data, but I need to make storage for it\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ64 (buf);\n\t\tvalue->uconstant = READ64 (buf);\n\t\tbreak;\n\tcase DW_FORM_sdata:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tbuf = r_leb128 (buf, buf_end - buf, &value->sconstant);\n\t\tbreak;\n\tcase DW_FORM_udata:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->uconstant, NULL);\n\t\tbreak;\n\tcase DW_FORM_string:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tif (*buf) {\n\t\t\tchar *name = r_str_ndup ((const char *)buf, buf_end - buf);\n\t\t\tr_str_ansi_strip (name);\n\t\t\tr_str_replace_ch (name, '\\n', 0, true);\n\t\t\tr_str_replace_ch (name, '\\t', 0, true);\n\t\t\tvalue->string.content = name;\n\t\t} else {\n\t\t\tvalue->string.content = NULL;\n\t\t}\n\t\tif (value->string.content) {\n\t\t\tbuf += strlen (value->string.content) + 1;\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_block1:\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tvalue->block.length = READ8 (buf);\n\t\tbuf = fill_block_data (buf, buf_end, &value->block);\n\t\tbreak;\n\tcase DW_FORM_block2:\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tvalue->block.length = READ16 (buf);\n\t\tif (value->block.length > 0) {\n\t\t\tvalue->block.data = calloc (sizeof (ut8), value->block.length);\n\t\t\tif (!value->block.data) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tfor (j = 0; j < value->block.length; j++) {\n\t\t\t\tvalue->block.data[j] = READ (buf, ut8);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_block4:\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tvalue->block.length = READ32 (buf);\n\t\tbuf = fill_block_data (buf, buf_end, &value->block);\n\t\tbreak;\n\tcase DW_FORM_block: // variable length ULEB128\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->block.length, NULL);\n\t\tif (!buf || buf >= buf_end) {\n\t\t\treturn NULL;\n\t\t}\n\t\tbuf = fill_block_data (buf, buf_end, &value->block);\n\t\tbreak;\n\tcase DW_FORM_flag:\n\t\tvalue->kind = DW_AT_KIND_FLAG;\n\t\tvalue->flag = READ (buf, ut8);\n\t\tbreak;\n\t// offset in .debug_str\n\tcase DW_FORM_strp:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\t\tif (debug_str && value->string.offset < debug_str_len) {\n\t\t\tchar *ds = r_str_ndup ((const char *)(debug_str + value->string.offset), debug_str_len);\n\t\t\tif (ds) {\n\t\t\t\tr_str_ansi_strip (ds);\n\t\t\t\tr_str_replace_ch (ds, '\\n', 0, true);\n\t\t\t\tr_str_replace_ch (ds, '\\t', 0, true);\n\t\t\t\tvalue->string.content = ds;\n\t\t\t} else {\n\t\t\t\tvalue->string.content = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tvalue->string.content = NULL; // Means malformed DWARF, should we print error message?\n\t\t}\n\t\tbreak;\n\t// offset in .debug_info\n\tcase DW_FORM_ref_addr:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\t\tbreak;\n\t// This type of reference is an offset from the first byte of the compilation\n\t// header for the compilation unit containing the reference\n\tcase DW_FORM_ref1:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = hdr->unit_offset + READ8 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref2:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = hdr->unit_offset + READ16 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref4:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = hdr->unit_offset + READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref8:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = hdr->unit_offset + READ64 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref_udata:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\t// uleb128 is enough to fit into ut64?\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->reference, NULL);\n\t\tvalue->reference += hdr->unit_offset;\n\t\tbreak;\n\t// offset in a section other than .debug_info or .debug_str\n\tcase DW_FORM_sec_offset:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = dwarf_read_offset(hdr->is_64bit, &buf, buf_end);\n\t\tbreak;\n\tcase DW_FORM_exprloc:\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->block.length, NULL);\n\t\tif (!buf || buf >= buf_end) {\n\t\t\treturn NULL;\n\t\t}\n\t\tbuf = fill_block_data (buf, buf_end, &value->block);\n\t\tbreak;\n\t// this means that the flag is present, nothing is read\n\tcase DW_FORM_flag_present:\n\t\tvalue->kind = DW_AT_KIND_FLAG;\n\t\tvalue->flag = true;\n\t\tbreak;\n\tcase DW_FORM_ref_sig8:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = READ64 (buf);\n\t\tbreak;\n\t// offset into .debug_line_str section, can't parse the section now, so we just skip\n\tcase DW_FORM_strx:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\t// value->string.offset = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\t\t// if (debug_str && value->string.offset < debug_line_str_len) {\n\t\t// \tvalue->string.content =\n\t\t// \t\tstrdup ((const char *)(debug_str + value->string.offset));\n\t\t// } else {\n\t\t// \tvalue->string.content = NULL; // Means malformed DWARF, should we print error message?\n\t\t// }\n\t\tbreak;\n\tcase DW_FORM_strx1:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = READ8 (buf);\n\t\tbreak;\n\tcase DW_FORM_strx2:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = READ16 (buf);\n\t\tbreak;\n\tcase DW_FORM_strx3: // TODO Add 3 byte int read\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tbuf += 3;\n\t\tbreak;\n\tcase DW_FORM_strx4:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_implicit_const:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = def->special;\n\t\tbreak;\n\t/*  addrx* forms : The index is relative to the value of the\n\t\tDW_AT_addr_base attribute of the associated compilation unit.\n\t    index into an array of addresses in the .debug_addr section.*/\n\tcase DW_FORM_addrx:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->address, NULL);\n\t\tbreak;\n\tcase DW_FORM_addrx1:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tvalue->address = READ8 (buf);\n\t\tbreak;\n\tcase DW_FORM_addrx2:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tvalue->address = READ16 (buf);\n\t\tbreak;\n\tcase DW_FORM_addrx3:\n\t\t// I need to add 3byte endianess free read here TODO\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tbuf += 3;\n\t\tbreak;\n\tcase DW_FORM_addrx4:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tvalue->address = READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_line_ptr: // offset in a section .debug_line_str\n\tcase DW_FORM_strp_sup: // offset in a section .debug_line_str\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\t\t// if (debug_str && value->string.offset < debug_line_str_len) {\n\t\t// \tvalue->string.content =\n\t\t// \t\tstrdupsts\n\t\tbreak;\n\t// offset in the supplementary object file\n\tcase DW_FORM_ref_sup4:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref_sup8:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = READ64 (buf);\n\t\tbreak;\n\t// An index into the .debug_loc\n\tcase DW_FORM_loclistx:\n\t\tvalue->kind = DW_AT_KIND_LOCLISTPTR;\n\t\tvalue->reference = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\t\tbreak;\n\t // An index into the .debug_rnglists\n\tcase DW_FORM_rnglistx:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->address, NULL);\n\t\tbreak;\n\tcase 0:\n\t\tvalue->uconstant = 0;\n\t\treturn NULL;\n\tdefault:\n\t\tR_LOG_WARN (\"Unknown DW_FORM 0x%02\" PFMT64x, def->attr_form);\n\t\tvalue->uconstant = 0;\n\t\treturn NULL;\n\t}\n\treturn buf;\n}",
  "abstract_func": "static const ut8 *parse_attr_value(const ut8 *VAR_0, int VAR_1,\n\t\tRBinDwarfAttrDef *VAR_2, RBinDwarfAttrValue *VAR_3,\n\t\tconst RBinDwarfCompUnitHdr *VAR_4,\n\t\tconst ut8 *VAR_5, size_t VAR_6) {\n\tr_return_val_if_fail (VAR_2 && VAR_3 && VAR_4 && VAR_0, NULL);\n\n\tVAR_3->attr_form = VAR_2->attr_form;\n\tVAR_3->attr_name = VAR_2->attr_name;\n\tVAR_3->block.data = NULL;\n\tVAR_3->string.content = NULL;\n\tVAR_3->string.offset = 0;\n\n\n\tconst ut8 *VAR_7 = VAR_0;\n\tconst ut8 *VAR_8 = VAR_0 + VAR_1;\n\tsize_t VAR_9;\n\n\tif (VAR_1 < 1) {\n\t\treturn NULL;\n\t}\n\n\t/* COMMENT_0 */\n\tswitch (VAR_2->attr_form) {\n\tcase VAR_10:\n\t\tVAR_3->kind = VAR_11;\n\t\tswitch (VAR_4->address_size) {\n\t\tcase 1:\n\t\t\tVAR_3->address = READ8 (VAR_7);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tVAR_3->address = READ16 (VAR_7);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tVAR_3->address = READ32 (VAR_7);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tVAR_3->address = READ64 (VAR_7);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tR_LOG_WARN (\"DWARF: Unexpected pointer size: %u\", (unsigned)VAR_4->address_size);\n\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n\tcase VAR_12:\n\t\tVAR_3->kind = VAR_13;\n\t\tVAR_3->uconstant = READ8 (VAR_7);\n\t\tbreak;\n\tcase VAR_14:\n\t\tVAR_3->kind = VAR_13;\n\t\tVAR_3->uconstant = READ16 (VAR_7);\n\t\tbreak;\n\tcase VAR_15:\n\t\tVAR_3->kind = VAR_13;\n\t\tVAR_3->uconstant = READ32 (VAR_7);\n\t\tbreak;\n\tcase VAR_16:\n\t\tVAR_3->kind = VAR_13;\n\t\tVAR_3->uconstant = READ64 (VAR_7);\n\t\tbreak;\n\tcase VAR_17: /* COMMENT_1 */\n\t\tVAR_3->kind = VAR_13;\n\t\tVAR_3->uconstant = READ64 (VAR_7);\n\t\tVAR_3->uconstant = READ64 (VAR_7);\n\t\tbreak;\n\tcase VAR_18:\n\t\tVAR_3->kind = VAR_13;\n\t\tVAR_7 = r_leb128 (VAR_7, VAR_8 - VAR_7, &VAR_3->sconstant);\n\t\tbreak;\n\tcase VAR_19:\n\t\tVAR_3->kind = VAR_13;\n\t\tVAR_7 = r_uleb128 (VAR_7, VAR_8 - VAR_7, &VAR_3->uconstant, NULL);\n\t\tbreak;\n\tcase VAR_20:\n\t\tVAR_3->kind = VAR_21;\n\t\tif (*VAR_7) {\n\t\t\tchar *VAR_22 = r_str_ndup ((const char *)VAR_7, VAR_8 - VAR_7);\n\t\t\tr_str_ansi_strip (VAR_22);\n\t\t\tr_str_replace_ch (VAR_22, '\\n', 0, true);\n\t\t\tr_str_replace_ch (VAR_22, '\\t', 0, true);\n\t\t\tVAR_3->string.content = VAR_22;\n\t\t} else {\n\t\t\tVAR_3->string.content = NULL;\n\t\t}\n\t\tif (VAR_3->string.content) {\n\t\t\tVAR_7 += strlen (VAR_3->string.content) + 1;\n\t\t}\n\t\tbreak;\n\tcase VAR_23:\n\t\tVAR_3->kind = VAR_24;\n\t\tVAR_3->block.length = READ8 (VAR_7);\n\t\tVAR_7 = fill_block_data (VAR_7, VAR_8, &VAR_3->block);\n\t\tbreak;\n\tcase VAR_25:\n\t\tVAR_3->kind = VAR_24;\n\t\tVAR_3->block.length = READ16 (VAR_7);\n\t\tif (VAR_3->block.length > 0) {\n\t\t\tVAR_3->block.data = calloc (sizeof (ut8), VAR_3->block.length);\n\t\t\tif (!VAR_3->block.data) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tfor (VAR_9 = 0; VAR_9 < VAR_3->block.length; VAR_9++) {\n\t\t\t\tVAR_3->block.data[VAR_9] = READ (VAR_7, ut8);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase VAR_26:\n\t\tVAR_3->kind = VAR_24;\n\t\tVAR_3->block.length = READ32 (VAR_7);\n\t\tVAR_7 = fill_block_data (VAR_7, VAR_8, &VAR_3->block);\n\t\tbreak;\n\tcase VAR_27: /* COMMENT_2 */\n\t\tVAR_3->kind = VAR_24;\n\t\tVAR_7 = r_uleb128 (VAR_7, VAR_8 - VAR_7, &VAR_3->block.length, NULL);\n\t\tif (!VAR_7 || VAR_7 >= VAR_8) {\n\t\t\treturn NULL;\n\t\t}\n\t\tVAR_7 = fill_block_data (VAR_7, VAR_8, &VAR_3->block);\n\t\tbreak;\n\tcase VAR_28:\n\t\tVAR_3->kind = VAR_29;\n\t\tVAR_3->flag = READ (VAR_7, ut8);\n\t\tbreak;\n\t/* COMMENT_3 */\n\tcase VAR_30:\n\t\tVAR_3->kind = VAR_21;\n\t\tVAR_3->string.offset = dwarf_read_offset (VAR_4->is_64bit, &VAR_7, VAR_8);\n\t\tif (VAR_5 && VAR_3->string.offset < VAR_6) {\n\t\t\tchar *VAR_31 = r_str_ndup ((const char *)(VAR_5 + VAR_3->string.offset), VAR_6);\n\t\t\tif (VAR_31) {\n\t\t\t\tr_str_ansi_strip (VAR_31);\n\t\t\t\tr_str_replace_ch (VAR_31, '\\n', 0, true);\n\t\t\t\tr_str_replace_ch (VAR_31, '\\t', 0, true);\n\t\t\t\tVAR_3->string.content = VAR_31;\n\t\t\t} else {\n\t\t\t\tVAR_3->string.content = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tVAR_3->string.content = NULL; /* COMMENT_4 */\n\t\t}\n\t\tbreak;\n\t/* COMMENT_5 */\n\tcase VAR_32:\n\t\tVAR_3->kind = VAR_33;\n\t\tVAR_3->reference = dwarf_read_offset (VAR_4->is_64bit, &VAR_7, VAR_8);\n\t\tbreak;\n\t/* COMMENT_6 */\n\t/* COMMENT_7 */\n\tcase VAR_34:\n\t\tVAR_3->kind = VAR_33;\n\t\tVAR_3->reference = VAR_4->unit_offset + READ8 (VAR_7);\n\t\tbreak;\n\tcase VAR_35:\n\t\tVAR_3->kind = VAR_33;\n\t\tVAR_3->reference = VAR_4->unit_offset + READ16 (VAR_7);\n\t\tbreak;\n\tcase VAR_36:\n\t\tVAR_3->kind = VAR_33;\n\t\tVAR_3->reference = VAR_4->unit_offset + READ32 (VAR_7);\n\t\tbreak;\n\tcase VAR_37:\n\t\tVAR_3->kind = VAR_33;\n\t\tVAR_3->reference = VAR_4->unit_offset + READ64 (VAR_7);\n\t\tbreak;\n\tcase VAR_38:\n\t\tVAR_3->kind = VAR_33;\n\t\t/* COMMENT_8 */\n\t\tVAR_7 = r_uleb128 (VAR_7, VAR_8 - VAR_7, &VAR_3->reference, NULL);\n\t\tVAR_3->reference += VAR_4->unit_offset;\n\t\tbreak;\n\t/* COMMENT_9 */\n\tcase VAR_39:\n\t\tVAR_3->kind = VAR_33;\n\t\tVAR_3->reference = dwarf_read_offset(VAR_4->is_64bit, &VAR_7, VAR_8);\n\t\tbreak;\n\tcase VAR_40:\n\t\tVAR_3->kind = VAR_24;\n\t\tVAR_7 = r_uleb128 (VAR_7, VAR_8 - VAR_7, &VAR_3->block.length, NULL);\n\t\tif (!VAR_7 || VAR_7 >= VAR_8) {\n\t\t\treturn NULL;\n\t\t}\n\t\tVAR_7 = fill_block_data (VAR_7, VAR_8, &VAR_3->block);\n\t\tbreak;\n\t/* COMMENT_10 */\n\tcase VAR_41:\n\t\tVAR_3->kind = VAR_29;\n\t\tVAR_3->flag = true;\n\t\tbreak;\n\tcase VAR_42:\n\t\tVAR_3->kind = VAR_33;\n\t\tVAR_3->reference = READ64 (VAR_7);\n\t\tbreak;\n\t/* COMMENT_11 */\n\tcase VAR_43:\n\t\tVAR_3->kind = VAR_21;\n\t\t/* COMMENT_12 */\n\t\t/* COMMENT_13 */\n\t\t/* COMMENT_14 */\n\t\t/* COMMENT_15 */\n\t\t/* COMMENT_16 */\n\t\t/* COMMENT_17 */\n\t\t/* COMMENT_18 */\n\t\tbreak;\n\tcase VAR_44:\n\t\tVAR_3->kind = VAR_21;\n\t\tVAR_3->string.offset = READ8 (VAR_7);\n\t\tbreak;\n\tcase VAR_45:\n\t\tVAR_3->kind = VAR_21;\n\t\tVAR_3->string.offset = READ16 (VAR_7);\n\t\tbreak;\n\tcase VAR_46: /* COMMENT_19 */\n\t\tVAR_3->kind = VAR_21;\n\t\tVAR_7 += 3;\n\t\tbreak;\n\tcase VAR_47:\n\t\tVAR_3->kind = VAR_21;\n\t\tVAR_3->string.offset = READ32 (VAR_7);\n\t\tbreak;\n\tcase VAR_48:\n\t\tVAR_3->kind = VAR_13;\n\t\tVAR_3->uconstant = VAR_2->special;\n\t\tbreak;\n\t/* COMMENT_20 */\n                                                               \n                                                                   \n\tcase VAR_49:\n\t\tVAR_3->kind = VAR_11;\n\t\tVAR_7 = r_uleb128 (VAR_7, VAR_8 - VAR_7, &VAR_3->address, NULL);\n\t\tbreak;\n\tcase VAR_50:\n\t\tVAR_3->kind = VAR_11;\n\t\tVAR_3->address = READ8 (VAR_7);\n\t\tbreak;\n\tcase VAR_51:\n\t\tVAR_3->kind = VAR_11;\n\t\tVAR_3->address = READ16 (VAR_7);\n\t\tbreak;\n\tcase VAR_52:\n\t\t/* COMMENT_23 */\n\t\tVAR_3->kind = VAR_11;\n\t\tVAR_7 += 3;\n\t\tbreak;\n\tcase VAR_53:\n\t\tVAR_3->kind = VAR_11;\n\t\tVAR_3->address = READ32 (VAR_7);\n\t\tbreak;\n\tcase VAR_54: /* COMMENT_24 */\n\tcase VAR_55: /* COMMENT_24 */\n\t\tVAR_3->kind = VAR_21;\n\t\tVAR_3->string.offset = dwarf_read_offset (VAR_4->is_64bit, &VAR_7, VAR_8);\n\t\t/* COMMENT_13 */\n\t\t/* COMMENT_14 */\n\t\t/* COMMENT_25 */\n\t\tbreak;\n\t/* COMMENT_26 */\n\tcase VAR_56:\n\t\tVAR_3->kind = VAR_33;\n\t\tVAR_3->reference = READ32 (VAR_7);\n\t\tbreak;\n\tcase VAR_57:\n\t\tVAR_3->kind = VAR_33;\n\t\tVAR_3->reference = READ64 (VAR_7);\n\t\tbreak;\n\t/* COMMENT_27 */\n\tcase VAR_58:\n\t\tVAR_3->kind = VAR_59;\n\t\tVAR_3->reference = dwarf_read_offset (VAR_4->is_64bit, &VAR_7, VAR_8);\n\t\tbreak;\n\t /* COMMENT_28 */\n\tcase VAR_60:\n\t\tVAR_3->kind = VAR_11;\n\t\tVAR_7 = r_uleb128 (VAR_7, VAR_8 - VAR_7, &VAR_3->address, NULL);\n\t\tbreak;\n\tcase 0:\n\t\tVAR_3->uconstant = 0;\n\t\treturn NULL;\n\tdefault:\n\t\tR_LOG_WARN (\"Unknown DW_FORM 0x%02\" VAR_61, VAR_2->attr_form);\n\t\tVAR_3->uconstant = 0;\n\t\treturn NULL;\n\t}\n\treturn VAR_7;\n}",
  "func_graph_path": "radareorg/radare2/961f0e723903011d4f54c2396e44efa91fcc74ce/dwarf.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -72,7 +72,15 @@\n \t\tbreak;\n \tcase DW_FORM_string:\n \t\tvalue->kind = DW_AT_KIND_STRING;\n-\t\tvalue->string.content = *buf ? r_str_ndup ((const char *)buf, buf_end - buf) : NULL;\n+\t\tif (*buf) {\n+\t\t\tchar *name = r_str_ndup ((const char *)buf, buf_end - buf);\n+\t\t\tr_str_ansi_strip (name);\n+\t\t\tr_str_replace_ch (name, '\\n', 0, true);\n+\t\t\tr_str_replace_ch (name, '\\t', 0, true);\n+\t\t\tvalue->string.content = name;\n+\t\t} else {\n+\t\t\tvalue->string.content = NULL;\n+\t\t}\n \t\tif (value->string.content) {\n \t\t\tbuf += strlen (value->string.content) + 1;\n \t\t}\n@@ -117,8 +125,15 @@\n \t\tvalue->kind = DW_AT_KIND_STRING;\n \t\tvalue->string.offset = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n \t\tif (debug_str && value->string.offset < debug_str_len) {\n-\t\t\tconst char *ds = (const char *)(debug_str + value->string.offset);\n-\t\t\tvalue->string.content = strdup (ds); // r_str_ndup (ds, debug_str_len - value->string.offset);\n+\t\t\tchar *ds = r_str_ndup ((const char *)(debug_str + value->string.offset), debug_str_len);\n+\t\t\tif (ds) {\n+\t\t\t\tr_str_ansi_strip (ds);\n+\t\t\t\tr_str_replace_ch (ds, '\\n', 0, true);\n+\t\t\t\tr_str_replace_ch (ds, '\\t', 0, true);\n+\t\t\t\tvalue->string.content = ds;\n+\t\t\t} else {\n+\t\t\t\tvalue->string.content = NULL;\n+\t\t\t}\n \t\t} else {\n \t\t\tvalue->string.content = NULL; // Means malformed DWARF, should we print error message?\n \t\t}",
  "diff_line_info": {
    "deleted_lines": [
      "\t\tvalue->string.content = *buf ? r_str_ndup ((const char *)buf, buf_end - buf) : NULL;",
      "\t\t\tconst char *ds = (const char *)(debug_str + value->string.offset);",
      "\t\t\tvalue->string.content = strdup (ds); // r_str_ndup (ds, debug_str_len - value->string.offset);"
    ],
    "added_lines": [
      "\t\tif (*buf) {",
      "\t\t\tchar *name = r_str_ndup ((const char *)buf, buf_end - buf);",
      "\t\t\tr_str_ansi_strip (name);",
      "\t\t\tr_str_replace_ch (name, '\\n', 0, true);",
      "\t\t\tr_str_replace_ch (name, '\\t', 0, true);",
      "\t\t\tvalue->string.content = name;",
      "\t\t} else {",
      "\t\t\tvalue->string.content = NULL;",
      "\t\t}",
      "\t\t\tchar *ds = r_str_ndup ((const char *)(debug_str + value->string.offset), debug_str_len);",
      "\t\t\tif (ds) {",
      "\t\t\t\tr_str_ansi_strip (ds);",
      "\t\t\t\tr_str_replace_ch (ds, '\\n', 0, true);",
      "\t\t\t\tr_str_replace_ch (ds, '\\t', 0, true);",
      "\t\t\t\tvalue->string.content = ds;",
      "\t\t\t} else {",
      "\t\t\t\tvalue->string.content = NULL;",
      "\t\t\t}"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/radareorg/radare2/pull/21231",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/radareorg/radare2/pull/21231: 403 Client Error: Forbidden for url: https://api.github.com/repos/radareorg/radare2/pulls/21231",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.9"
}