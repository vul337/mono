{
  "cve_id": "CVE-2021-45429",
  "cwe_ids": [
    "CWE-120"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "VirusTotal/yara",
  "commit_msg": "Fix issue #1616\n\nThis is a more comprehensive fix than #1617, it adds new functions to the API for getting/setting uint32 and uint64 settings.  Using these functions is preferable over calling `yr_(get|set)_configuration` directly.",
  "commit_hash": "b34b7e74c862c129b801832b6b85401fbada2b01",
  "git_url": "https://github.com/VirusTotal/yara/commit/b34b7e74c862c129b801832b6b85401fbada2b01",
  "file_path": "libyara/proc/linux.c",
  "func_name": "yr_process_get_next_memory_block",
  "func_before": "YR_API YR_MEMORY_BLOCK* yr_process_get_next_memory_block(\n    YR_MEMORY_BLOCK_ITERATOR* iterator)\n{\n  YR_PROC_ITERATOR_CTX* context = (YR_PROC_ITERATOR_CTX*) iterator->context;\n  YR_PROC_INFO* proc_info = (YR_PROC_INFO*) context->proc_info;\n\n  char buffer[PATH_MAX];\n  char perm[5];\n  uint64_t begin, end;\n\n  uint64_t current_begin = context->current_block.base +\n                           context->current_block.size;\n\n  uint64_t max_process_memory_chunk;\n\n  yr_get_configuration(\n      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, (void*) &max_process_memory_chunk);\n\n  if (proc_info->next_block_end <= current_begin)\n  {\n    int n, path_start;\n\n    while (fgets(buffer, sizeof(buffer), proc_info->maps) != NULL)\n    {\n      // If we haven't read the whole line, skip over the rest.\n      if (strrchr(buffer, '\\n') == NULL)\n      {\n        int c;\n        do\n        {\n          c = fgetc(proc_info->maps);\n        } while (c >= 0 && c != '\\n');\n      }\n\n      // Each row in /proc/$PID/maps describes a region of contiguous virtual\n      // memory in a process or thread. Each row has the following fields:\n      //\n      // address           perms offset  dev   inode   pathname\n      // 08048000-08056000 r-xp 00000000 03:0c 64593   /usr/sbin/gpm\n      //\n      n = sscanf(\n          buffer,\n          \"%\" SCNx64 \"-%\" SCNx64 \" %4s \"\n          \"%\" SCNx64 \" %\" SCNx64 \":%\" SCNx64 \" %\" SCNu64 \" %n\",\n          &begin,\n          &end,\n          perm,\n          &(proc_info->map_offset),\n          &(proc_info->map_dmaj),\n          &(proc_info->map_dmin),\n          &(proc_info->map_ino),\n          &path_start);\n\n      // If the row was parsed correctly sscan must return 7.\n      if (n == 7)\n      {\n        // path_start contains the offset within buffer where the path starts,\n        // the path should start with /.\n        if (buffer[path_start] == '/')\n          strncpy(\n              proc_info->map_path,\n              buffer + path_start,\n              sizeof(proc_info->map_path) - 1);\n        else\n          proc_info->map_path[0] = '\\0';\n        break;\n      }\n    }\n\n    if (n == 7)\n    {\n      current_begin = begin;\n      proc_info->next_block_end = end;\n    }\n    else\n    {\n      YR_DEBUG_FPRINTF(2, stderr, \"+ %s() = NULL\\n\", __FUNCTION__);\n      return NULL;\n    }\n  }\n\n  context->current_block.base = current_begin;\n  context->current_block.size = yr_min(\n      proc_info->next_block_end - current_begin, max_process_memory_chunk);\n\n  assert(context->current_block.size > 0);\n\n  iterator->last_error = ERROR_SUCCESS;\n\n  YR_DEBUG_FPRINTF(\n      2,\n      stderr,\n      \"- %s() {} = %p // .base=0x%\" PRIx64 \" .size=%\" PRIu64 \"\\n\",\n      __FUNCTION__,\n      result,\n      context->current_block.base,\n      context->current_block.size);\n\n  return &context->current_block;\n}",
  "abstract_func_before": "YR_API VAR_0* yr_process_get_next_memory_block(\n    YR_MEMORY_BLOCK_ITERATOR* VAR_1)\n{\n  YR_PROC_ITERATOR_CTX* VAR_2 = (YR_PROC_ITERATOR_CTX*) VAR_1->context;\n  YR_PROC_INFO* VAR_3 = (YR_PROC_INFO*) VAR_2->proc_info;\n\n  char VAR_4[VAR_5];\n  char VAR_6[5];\n  uint64_t VAR_7, VAR_8;\n\n  uint64_t VAR_9 = VAR_2->current_block.base +\n                           VAR_2->current_block.size;\n\n  uint64_t VAR_10;\n\n  yr_get_configuration(\n      VAR_11, (void*) &VAR_10);\n\n  if (VAR_3->next_block_end <= VAR_9)\n  {\n    int VAR_12, VAR_13;\n\n    while (fgets(VAR_4, sizeof(VAR_4), VAR_3->maps) != NULL)\n    {\n      /* COMMENT_0 */\n      if (strrchr(VAR_4, '\\n') == NULL)\n      {\n        int VAR_14;\n        do\n        {\n          VAR_14 = fgetc(VAR_3->maps);\n        } while (VAR_14 >= 0 && VAR_14 != '\\n');\n      }\n\n      /* COMMENT_1 */\n      /* COMMENT_2 */\n      /* COMMENT_3 */\n      /* COMMENT_4 */\n      /* COMMENT_5 */\n      /* COMMENT_3 */\n      VAR_12 = sscanf(\n          VAR_4,\n          \"%\" VAR_15 \"-%\" VAR_15 \" %4s \"\n          \"%\" VAR_15 \" %\" VAR_15 \":%\" VAR_15 \" %\" VAR_16 \" %n\",\n          &VAR_7,\n          &VAR_8,\n          VAR_6,\n          &(VAR_3->map_offset),\n          &(VAR_3->map_dmaj),\n          &(VAR_3->map_dmin),\n          &(VAR_3->map_ino),\n          &VAR_13);\n\n      /* COMMENT_6 */\n      if (VAR_12 == 7)\n      {\n        /* COMMENT_7 */\n        /* COMMENT_8 */\n        if (VAR_4[VAR_13] == '/')\n          strncpy(\n              VAR_3->map_path,\n              VAR_4 + VAR_13,\n              sizeof(VAR_3->map_path) - 1);\n        else\n          VAR_3->map_path[0] = '\\0';\n        break;\n      }\n    }\n\n    if (VAR_12 == 7)\n    {\n      VAR_9 = VAR_7;\n      VAR_3->next_block_end = VAR_8;\n    }\n    else\n    {\n      YR_DEBUG_FPRINTF(2, VAR_17, \"+ %s() = NULL\\n\", VAR_18);\n      return NULL;\n    }\n  }\n\n  VAR_2->current_block.base = VAR_9;\n  VAR_2->current_block.size = yr_min(\n      VAR_3->next_block_end - VAR_9, VAR_10);\n\n  assert(VAR_2->current_block.size > 0);\n\n  VAR_1->last_error = VAR_19;\n\n  YR_DEBUG_FPRINTF(\n      2,\n      VAR_17,\n      \"- %s() {} = %p // .base=0x%\" VAR_20 \" .size=%\" VAR_21 \"\\n\",\n      VAR_18,\n      VAR_22,\n      VAR_2->current_block.base,\n      VAR_2->current_block.size);\n\n  return &VAR_2->current_block;\n}",
  "func_graph_path_before": null,
  "func": "YR_API YR_MEMORY_BLOCK* yr_process_get_next_memory_block(\n    YR_MEMORY_BLOCK_ITERATOR* iterator)\n{\n  YR_PROC_ITERATOR_CTX* context = (YR_PROC_ITERATOR_CTX*) iterator->context;\n  YR_PROC_INFO* proc_info = (YR_PROC_INFO*) context->proc_info;\n\n  char buffer[PATH_MAX];\n  char perm[5];\n  uint64_t begin, end;\n\n  uint64_t current_begin = context->current_block.base +\n                           context->current_block.size;\n\n  uint64_t max_process_memory_chunk;\n\n  yr_get_configuration_uint64(\n      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, &max_process_memory_chunk);\n\n  if (proc_info->next_block_end <= current_begin)\n  {\n    int n, path_start;\n\n    while (fgets(buffer, sizeof(buffer), proc_info->maps) != NULL)\n    {\n      // If we haven't read the whole line, skip over the rest.\n      if (strrchr(buffer, '\\n') == NULL)\n      {\n        int c;\n        do\n        {\n          c = fgetc(proc_info->maps);\n        } while (c >= 0 && c != '\\n');\n      }\n\n      // Each row in /proc/$PID/maps describes a region of contiguous virtual\n      // memory in a process or thread. Each row has the following fields:\n      //\n      // address           perms offset  dev   inode   pathname\n      // 08048000-08056000 r-xp 00000000 03:0c 64593   /usr/sbin/gpm\n      //\n      n = sscanf(\n          buffer,\n          \"%\" SCNx64 \"-%\" SCNx64 \" %4s \"\n          \"%\" SCNx64 \" %\" SCNx64 \":%\" SCNx64 \" %\" SCNu64 \" %n\",\n          &begin,\n          &end,\n          perm,\n          &(proc_info->map_offset),\n          &(proc_info->map_dmaj),\n          &(proc_info->map_dmin),\n          &(proc_info->map_ino),\n          &path_start);\n\n      // If the row was parsed correctly sscan must return 7.\n      if (n == 7)\n      {\n        // path_start contains the offset within buffer where the path starts,\n        // the path should start with /.\n        if (buffer[path_start] == '/')\n          strncpy(\n              proc_info->map_path,\n              buffer + path_start,\n              sizeof(proc_info->map_path) - 1);\n        else\n          proc_info->map_path[0] = '\\0';\n        break;\n      }\n    }\n\n    if (n == 7)\n    {\n      current_begin = begin;\n      proc_info->next_block_end = end;\n    }\n    else\n    {\n      YR_DEBUG_FPRINTF(2, stderr, \"+ %s() = NULL\\n\", __FUNCTION__);\n      return NULL;\n    }\n  }\n\n  context->current_block.base = current_begin;\n  context->current_block.size = yr_min(\n      proc_info->next_block_end - current_begin, max_process_memory_chunk);\n\n  assert(context->current_block.size > 0);\n\n  iterator->last_error = ERROR_SUCCESS;\n\n  YR_DEBUG_FPRINTF(\n      2,\n      stderr,\n      \"- %s() {} = %p // .base=0x%\" PRIx64 \" .size=%\" PRIu64 \"\\n\",\n      __FUNCTION__,\n      result,\n      context->current_block.base,\n      context->current_block.size);\n\n  return &context->current_block;\n}",
  "abstract_func": "YR_API VAR_0* yr_process_get_next_memory_block(\n    YR_MEMORY_BLOCK_ITERATOR* VAR_1)\n{\n  YR_PROC_ITERATOR_CTX* VAR_2 = (YR_PROC_ITERATOR_CTX*) VAR_1->context;\n  YR_PROC_INFO* VAR_3 = (YR_PROC_INFO*) VAR_2->proc_info;\n\n  char VAR_4[VAR_5];\n  char VAR_6[5];\n  uint64_t VAR_7, VAR_8;\n\n  uint64_t VAR_9 = VAR_2->current_block.base +\n                           VAR_2->current_block.size;\n\n  uint64_t VAR_10;\n\n  yr_get_configuration_uint64(\n      VAR_11, &VAR_10);\n\n  if (VAR_3->next_block_end <= VAR_9)\n  {\n    int VAR_12, VAR_13;\n\n    while (fgets(VAR_4, sizeof(VAR_4), VAR_3->maps) != NULL)\n    {\n      /* COMMENT_0 */\n      if (strrchr(VAR_4, '\\n') == NULL)\n      {\n        int VAR_14;\n        do\n        {\n          VAR_14 = fgetc(VAR_3->maps);\n        } while (VAR_14 >= 0 && VAR_14 != '\\n');\n      }\n\n      /* COMMENT_1 */\n      /* COMMENT_2 */\n      /* COMMENT_3 */\n      /* COMMENT_4 */\n      /* COMMENT_5 */\n      /* COMMENT_3 */\n      VAR_12 = sscanf(\n          VAR_4,\n          \"%\" VAR_15 \"-%\" VAR_15 \" %4s \"\n          \"%\" VAR_15 \" %\" VAR_15 \":%\" VAR_15 \" %\" VAR_16 \" %n\",\n          &VAR_7,\n          &VAR_8,\n          VAR_6,\n          &(VAR_3->map_offset),\n          &(VAR_3->map_dmaj),\n          &(VAR_3->map_dmin),\n          &(VAR_3->map_ino),\n          &VAR_13);\n\n      /* COMMENT_6 */\n      if (VAR_12 == 7)\n      {\n        /* COMMENT_7 */\n        /* COMMENT_8 */\n        if (VAR_4[VAR_13] == '/')\n          strncpy(\n              VAR_3->map_path,\n              VAR_4 + VAR_13,\n              sizeof(VAR_3->map_path) - 1);\n        else\n          VAR_3->map_path[0] = '\\0';\n        break;\n      }\n    }\n\n    if (VAR_12 == 7)\n    {\n      VAR_9 = VAR_7;\n      VAR_3->next_block_end = VAR_8;\n    }\n    else\n    {\n      YR_DEBUG_FPRINTF(2, VAR_17, \"+ %s() = NULL\\n\", VAR_18);\n      return NULL;\n    }\n  }\n\n  VAR_2->current_block.base = VAR_9;\n  VAR_2->current_block.size = yr_min(\n      VAR_3->next_block_end - VAR_9, VAR_10);\n\n  assert(VAR_2->current_block.size > 0);\n\n  VAR_1->last_error = VAR_19;\n\n  YR_DEBUG_FPRINTF(\n      2,\n      VAR_17,\n      \"- %s() {} = %p // .base=0x%\" VAR_20 \" .size=%\" VAR_21 \"\\n\",\n      VAR_18,\n      VAR_22,\n      VAR_2->current_block.base,\n      VAR_2->current_block.size);\n\n  return &VAR_2->current_block;\n}",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -13,8 +13,8 @@\n \n   uint64_t max_process_memory_chunk;\n \n-  yr_get_configuration(\n-      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, (void*) &max_process_memory_chunk);\n+  yr_get_configuration_uint64(\n+      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, &max_process_memory_chunk);\n \n   if (proc_info->next_block_end <= current_begin)\n   {",
  "diff_line_info": {
    "deleted_lines": [
      "  yr_get_configuration(",
      "      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, (void*) &max_process_memory_chunk);"
    ],
    "added_lines": [
      "  yr_get_configuration_uint64(",
      "      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, &max_process_memory_chunk);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/VirusTotal/yara/pull/1621",
  "description": {
    "pr_info": {
      "title": "Fix issue #1616",
      "number": 1621
    },
    "comment": [
      "This is a more comprehensive fix than #1617, it adds new functions to the API for getting/setting uint32 and uint64 settings.  Using these functions is preferable over calling `yr_(get|set)_configuration` directly."
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "The commit adds new API functions for handling specific data types, which is a functional improvement rather than a security fix. It enhances the API by providing more appropriate methods for uint32 and uint64, making the code cleaner and more efficient. Since the change doesn't address any security risks or vulnerabilities, it falls under defect remediation or feature upgrades.\n\n**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.9"
}