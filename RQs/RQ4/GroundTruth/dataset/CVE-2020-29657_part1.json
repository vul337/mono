{
  "cve_id": "CVE-2020-29657",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "jerryscript-project/jerryscript",
  "commit_msg": "Correct syntax error printing in case of end of file\n\nThe old variant of the syntax error printing method could incorrectly\nover-read the source file contents.\n\nJerryScript-DCO-1.0-Signed-off-by: Peter Gal pgal.usz@partner.samsung.com",
  "commit_hash": "5d08eb84a1e5d240daa0720e063587253c9bfe62",
  "git_url": "https://github.com/jerryscript-project/jerryscript/commit/5d08eb84a1e5d240daa0720e063587253c9bfe62",
  "file_path": "jerry-main/main-utils.c",
  "func_name": "main_print_unhandled_exception",
  "func_before": "void\nmain_print_unhandled_exception (jerry_value_t error_value) /**< error value */\n{\n  assert (jerry_value_is_error (error_value));\n  error_value = jerry_get_value_from_error (error_value, true);\n\n  jerry_char_t err_str_buf[256];\n\n  jerry_value_t err_str_val = jerry_value_to_string (error_value);\n  jerry_size_t err_str_size = jerry_get_utf8_string_size (err_str_val);\n\n  if (err_str_size >= 256)\n  {\n    const char msg[] = \"[Error message too long]\";\n    err_str_size = sizeof (msg) / sizeof (char) - 1;\n    memcpy (err_str_buf, msg, err_str_size + 1);\n  }\n  else\n  {\n    jerry_size_t string_end = jerry_string_to_utf8_char_buffer (err_str_val, err_str_buf, err_str_size);\n    assert (string_end == err_str_size);\n    err_str_buf[string_end] = 0;\n\n    if (jerry_is_feature_enabled (JERRY_FEATURE_ERROR_MESSAGES)\n        && jerry_get_error_type (error_value) == JERRY_ERROR_SYNTAX)\n    {\n      jerry_char_t *string_end_p = err_str_buf + string_end;\n      unsigned int err_line = 0;\n      unsigned int err_col = 0;\n      char *path_str_p = NULL;\n      char *path_str_end_p = NULL;\n\n      /* 1. parse column and line information */\n      for (jerry_char_t *current_p = err_str_buf; current_p < string_end_p; current_p++)\n      {\n        if (*current_p == '[')\n        {\n          current_p++;\n\n          if (*current_p == '<')\n          {\n            break;\n          }\n\n          path_str_p = (char *) current_p;\n          while (current_p < string_end_p && *current_p != ':')\n          {\n            current_p++;\n          }\n\n          path_str_end_p = (char *) current_p++;\n\n          err_line = (unsigned int) strtol ((char *) current_p, (char **) &current_p, 10);\n\n          current_p++;\n\n          err_col = (unsigned int) strtol ((char *) current_p, NULL, 10);\n          break;\n        }\n      } /* for */\n\n      if (err_line != 0 && err_col > 0 && err_col < SYNTAX_ERROR_MAX_LINE_LENGTH)\n      {\n        uint32_t curr_line = 1;\n        uint32_t pos = 0;\n\n        /* Temporarily modify the error message, so we can use the path. */\n        *path_str_end_p = '\\0';\n\n        size_t source_size;\n        uint8_t *source_p = jerry_port_read_source (path_str_p, &source_size);\n\n        /* Revert the error message. */\n        *path_str_end_p = ':';\n\n        /* 2. seek and print */\n        while (pos < source_size && curr_line < err_line)\n        {\n          if (source_p[pos] == '\\n')\n          {\n            curr_line++;\n          }\n\n          pos++;\n        }\n\n        uint32_t char_count = 0;\n        uint8_t ch;\n\n        do\n        {\n          ch = source_p[pos++];\n          jerry_port_log (JERRY_LOG_LEVEL_ERROR, \"%c\", ch);\n        }\n        while (ch != '\\n' && char_count++ < SYNTAX_ERROR_MAX_LINE_LENGTH);\n\n        jerry_port_release_source (source_p);\n\n        while (--err_col)\n        {\n          jerry_port_log (JERRY_LOG_LEVEL_ERROR, \"~\");\n        }\n\n        jerry_port_log (JERRY_LOG_LEVEL_ERROR, \"^\\n\\n\");\n      }\n    }\n  }\n\n  jerry_port_log (JERRY_LOG_LEVEL_ERROR, \"%s\\n\", err_str_buf);\n  jerry_release_value (err_str_val);\n\n  if (jerry_value_is_object (error_value))\n  {\n    jerry_value_t stack_str = jerry_create_string ((const jerry_char_t *) \"stack\");\n    jerry_value_t backtrace_val = jerry_get_property (error_value, stack_str);\n    jerry_release_value (stack_str);\n\n    if (jerry_value_is_array (backtrace_val))\n    {\n      uint32_t length = jerry_get_array_length (backtrace_val);\n\n      /* This length should be enough. */\n      if (length > 32)\n      {\n        length = 32;\n      }\n\n      for (uint32_t i = 0; i < length; i++)\n      {\n        jerry_value_t item_val = jerry_get_property_by_index (backtrace_val, i);\n\n        if (jerry_value_is_string (item_val))\n        {\n          jerry_size_t str_size = jerry_get_utf8_string_size (item_val);\n\n          if (str_size >= 256)\n          {\n            printf (\"%6u: [Backtrace string too long]\\n\", i);\n          }\n          else\n          {\n            jerry_size_t string_end = jerry_string_to_utf8_char_buffer (item_val, err_str_buf, str_size);\n            assert (string_end == str_size);\n            err_str_buf[string_end] = 0;\n\n            printf (\"%6u: %s\\n\", i, err_str_buf);\n          }\n        }\n\n        jerry_release_value (item_val);\n      }\n    }\n\n    jerry_release_value (backtrace_val);\n  }\n\n  jerry_release_value (error_value);\n}",
  "abstract_func_before": "void\nmain_print_unhandled_exception (jerry_value_t VAR_0) /* COMMENT_0 */\n{\n  assert (jerry_value_is_error (VAR_0));\n  VAR_0 = jerry_get_value_from_error (VAR_0, true);\n\n  jerry_char_t VAR_1[256];\n\n  jerry_value_t VAR_2 = jerry_value_to_string (VAR_0);\n  jerry_size_t VAR_3 = jerry_get_utf8_string_size (VAR_2);\n\n  if (VAR_3 >= 256)\n  {\n    const char VAR_4[] = \"[Error message too long]\";\n    VAR_3 = sizeof (msg) / sizeof (char) - 1;\n    memcpy (VAR_1, msg, VAR_3 + 1);\n  }\n  else\n  {\n    jerry_size_t VAR_5 = jerry_string_to_utf8_char_buffer (VAR_2, VAR_1, VAR_3);\n    assert (VAR_5 == VAR_3);\n    VAR_1[VAR_5] = 0;\n\n    if (jerry_is_feature_enabled (VAR_6)\n        && jerry_get_error_type (VAR_0) == VAR_7)\n    {\n      jerry_char_t *VAR_8 = VAR_1 + VAR_5;\n      unsigned int VAR_9 = 0;\n      unsigned int VAR_10 = 0;\n      char *VAR_11 = NULL;\n      char *VAR_12 = NULL;\n\n      /* COMMENT_1 */\n      for (jerry_char_t *VAR_13 = VAR_1; VAR_13 < VAR_8; VAR_13++)\n      {\n        if (*VAR_13 == '[')\n        {\n          VAR_13++;\n\n          if (*VAR_13 == '<')\n          {\n            break;\n          }\n\n          VAR_11 = (char *) VAR_13;\n          while (VAR_13 < VAR_8 && *VAR_13 != ':')\n          {\n            VAR_13++;\n          }\n\n          VAR_12 = (char *) VAR_13++;\n\n          VAR_9 = (unsigned int) strtol ((char *) VAR_13, (char **) &VAR_13, 10);\n\n          VAR_13++;\n\n          VAR_10 = (unsigned int) strtol ((char *) VAR_13, NULL, 10);\n          break;\n        }\n      } /* COMMENT_2 */\n\n      if (VAR_9 != 0 && VAR_10 > 0 && VAR_10 < VAR_14)\n      {\n        uint32_t VAR_15 = 1;\n        uint32_t VAR_16 = 0;\n\n        /* COMMENT_3 */\n        *VAR_12 = '\\0';\n\n        size_t VAR_17;\n        uint8_t *VAR_18 = jerry_port_read_source (VAR_11, &VAR_17);\n\n        /* COMMENT_4 */\n        *VAR_12 = ':';\n\n        /* COMMENT_5 */\n        while (VAR_16 < VAR_17 && VAR_15 < VAR_9)\n        {\n          if (VAR_18[VAR_16] == '\\n')\n          {\n            VAR_15++;\n          }\n\n          VAR_16++;\n        }\n\n        uint32_t VAR_19 = 0;\n        uint8_t VAR_20;\n\n        do\n        {\n          VAR_20 = VAR_18[VAR_16++];\n          jerry_port_log (VAR_21, \"%c\", VAR_20);\n        }\n        while (VAR_20 != '\\n' && VAR_19++ < VAR_14);\n\n        jerry_port_release_source (VAR_18);\n\n        while (--VAR_10)\n        {\n          jerry_port_log (VAR_21, \"~\");\n        }\n\n        jerry_port_log (VAR_21, \"^\\n\\n\");\n      }\n    }\n  }\n\n  jerry_port_log (VAR_21, \"%s\\n\", VAR_1);\n  jerry_release_value (VAR_2);\n\n  if (jerry_value_is_object (VAR_0))\n  {\n    jerry_value_t VAR_22 = jerry_create_string ((const jerry_char_t *) \"stack\");\n    jerry_value_t VAR_23 = jerry_get_property (VAR_0, VAR_22);\n    jerry_release_value (VAR_22);\n\n    if (jerry_value_is_array (VAR_23))\n    {\n      uint32_t VAR_24 = jerry_get_array_length (VAR_23);\n\n      /* COMMENT_6 */\n      if (VAR_24 > 32)\n      {\n        VAR_24 = 32;\n      }\n\n      for (uint32_t VAR_25 = 0; VAR_25 < VAR_24; VAR_25++)\n      {\n        jerry_value_t VAR_26 = jerry_get_property_by_index (VAR_23, VAR_25);\n\n        if (jerry_value_is_string (VAR_26))\n        {\n          jerry_size_t VAR_27 = jerry_get_utf8_string_size (VAR_26);\n\n          if (VAR_27 >= 256)\n          {\n            printf (\"%6u: [Backtrace string too long]\\n\", VAR_25);\n          }\n          else\n          {\n            jerry_size_t VAR_5 = jerry_string_to_utf8_char_buffer (VAR_26, VAR_1, VAR_27);\n            assert (VAR_5 == VAR_27);\n            VAR_1[VAR_5] = 0;\n\n            printf (\"%6u: %s\\n\", VAR_25, VAR_1);\n          }\n        }\n\n        jerry_release_value (VAR_26);\n      }\n    }\n\n    jerry_release_value (VAR_23);\n  }\n\n  jerry_release_value (VAR_0);\n}",
  "func_graph_path_before": "jerryscript-project/jerryscript/5d08eb84a1e5d240daa0720e063587253c9bfe62/main-utils.c/vul/before/0.json",
  "func": "void\nmain_print_unhandled_exception (jerry_value_t error_value) /**< error value */\n{\n  assert (jerry_value_is_error (error_value));\n  error_value = jerry_get_value_from_error (error_value, true);\n\n  jerry_char_t err_str_buf[256];\n\n  jerry_value_t err_str_val = jerry_value_to_string (error_value);\n  jerry_size_t err_str_size = jerry_get_utf8_string_size (err_str_val);\n\n  if (err_str_size >= 256)\n  {\n    const char msg[] = \"[Error message too long]\";\n    err_str_size = sizeof (msg) / sizeof (char) - 1;\n    memcpy (err_str_buf, msg, err_str_size + 1);\n  }\n  else\n  {\n    jerry_size_t string_end = jerry_string_to_utf8_char_buffer (err_str_val, err_str_buf, err_str_size);\n    assert (string_end == err_str_size);\n    err_str_buf[string_end] = 0;\n\n    if (jerry_is_feature_enabled (JERRY_FEATURE_ERROR_MESSAGES)\n        && jerry_get_error_type (error_value) == JERRY_ERROR_SYNTAX)\n    {\n      jerry_char_t *string_end_p = err_str_buf + string_end;\n      unsigned int err_line = 0;\n      unsigned int err_col = 0;\n      char *path_str_p = NULL;\n      char *path_str_end_p = NULL;\n\n      /* 1. parse column and line information */\n      for (jerry_char_t *current_p = err_str_buf; current_p < string_end_p; current_p++)\n      {\n        if (*current_p == '[')\n        {\n          current_p++;\n\n          if (*current_p == '<')\n          {\n            break;\n          }\n\n          path_str_p = (char *) current_p;\n          while (current_p < string_end_p && *current_p != ':')\n          {\n            current_p++;\n          }\n\n          path_str_end_p = (char *) current_p++;\n\n          err_line = (unsigned int) strtol ((char *) current_p, (char **) &current_p, 10);\n\n          current_p++;\n\n          err_col = (unsigned int) strtol ((char *) current_p, NULL, 10);\n          break;\n        }\n      } /* for */\n\n      if (err_line != 0 && err_col > 0 && err_col < SYNTAX_ERROR_MAX_LINE_LENGTH)\n      {\n        uint32_t curr_line = 1;\n        uint32_t pos = 0;\n\n        /* Temporarily modify the error message, so we can use the path. */\n        *path_str_end_p = '\\0';\n\n        size_t source_size;\n        uint8_t *source_p = jerry_port_read_source (path_str_p, &source_size);\n\n        /* Revert the error message. */\n        *path_str_end_p = ':';\n\n        /* 2. seek and print */\n        while (pos < source_size && curr_line < err_line)\n        {\n          if (source_p[pos] == '\\n')\n          {\n            curr_line++;\n          }\n\n          pos++;\n        }\n\n        /* Print character if:\n         * - The max line length is not reached.\n         * - The current position is valid (it is not the end of the source).\n         * - The current character is not a newline.\n         **/\n        for (uint32_t char_count = 0;\n             (char_count < SYNTAX_ERROR_MAX_LINE_LENGTH) && (pos < source_size) && (source_p[pos] != '\\n');\n             char_count++, pos++)\n        {\n          jerry_port_log (JERRY_LOG_LEVEL_ERROR, \"%c\", source_p[pos]);\n        }\n        jerry_port_log (JERRY_LOG_LEVEL_ERROR, \"\\n\");\n\n        jerry_port_release_source (source_p);\n\n        while (--err_col)\n        {\n          jerry_port_log (JERRY_LOG_LEVEL_ERROR, \"~\");\n        }\n\n        jerry_port_log (JERRY_LOG_LEVEL_ERROR, \"^\\n\\n\");\n      }\n    }\n  }\n\n  jerry_port_log (JERRY_LOG_LEVEL_ERROR, \"%s\\n\", err_str_buf);\n  jerry_release_value (err_str_val);\n\n  if (jerry_value_is_object (error_value))\n  {\n    jerry_value_t stack_str = jerry_create_string ((const jerry_char_t *) \"stack\");\n    jerry_value_t backtrace_val = jerry_get_property (error_value, stack_str);\n    jerry_release_value (stack_str);\n\n    if (jerry_value_is_array (backtrace_val))\n    {\n      uint32_t length = jerry_get_array_length (backtrace_val);\n\n      /* This length should be enough. */\n      if (length > 32)\n      {\n        length = 32;\n      }\n\n      for (uint32_t i = 0; i < length; i++)\n      {\n        jerry_value_t item_val = jerry_get_property_by_index (backtrace_val, i);\n\n        if (jerry_value_is_string (item_val))\n        {\n          jerry_size_t str_size = jerry_get_utf8_string_size (item_val);\n\n          if (str_size >= 256)\n          {\n            printf (\"%6u: [Backtrace string too long]\\n\", i);\n          }\n          else\n          {\n            jerry_size_t string_end = jerry_string_to_utf8_char_buffer (item_val, err_str_buf, str_size);\n            assert (string_end == str_size);\n            err_str_buf[string_end] = 0;\n\n            printf (\"%6u: %s\\n\", i, err_str_buf);\n          }\n        }\n\n        jerry_release_value (item_val);\n      }\n    }\n\n    jerry_release_value (backtrace_val);\n  }\n\n  jerry_release_value (error_value);\n}",
  "abstract_func": "void\nmain_print_unhandled_exception (jerry_value_t VAR_0) /* COMMENT_0 */\n{\n  assert (jerry_value_is_error (VAR_0));\n  VAR_0 = jerry_get_value_from_error (VAR_0, true);\n\n  jerry_char_t VAR_1[256];\n\n  jerry_value_t VAR_2 = jerry_value_to_string (VAR_0);\n  jerry_size_t VAR_3 = jerry_get_utf8_string_size (VAR_2);\n\n  if (VAR_3 >= 256)\n  {\n    const char VAR_4[] = \"[Error message too long]\";\n    VAR_3 = sizeof (msg) / sizeof (char) - 1;\n    memcpy (VAR_1, msg, VAR_3 + 1);\n  }\n  else\n  {\n    jerry_size_t VAR_5 = jerry_string_to_utf8_char_buffer (VAR_2, VAR_1, VAR_3);\n    assert (VAR_5 == VAR_3);\n    VAR_1[VAR_5] = 0;\n\n    if (jerry_is_feature_enabled (VAR_6)\n        && jerry_get_error_type (VAR_0) == VAR_7)\n    {\n      jerry_char_t *VAR_8 = VAR_1 + VAR_5;\n      unsigned int VAR_9 = 0;\n      unsigned int VAR_10 = 0;\n      char *VAR_11 = NULL;\n      char *VAR_12 = NULL;\n\n      /* COMMENT_1 */\n      for (jerry_char_t *VAR_13 = VAR_1; VAR_13 < VAR_8; VAR_13++)\n      {\n        if (*VAR_13 == '[')\n        {\n          VAR_13++;\n\n          if (*VAR_13 == '<')\n          {\n            break;\n          }\n\n          VAR_11 = (char *) VAR_13;\n          while (VAR_13 < VAR_8 && *VAR_13 != ':')\n          {\n            VAR_13++;\n          }\n\n          VAR_12 = (char *) VAR_13++;\n\n          VAR_9 = (unsigned int) strtol ((char *) VAR_13, (char **) &VAR_13, 10);\n\n          VAR_13++;\n\n          VAR_10 = (unsigned int) strtol ((char *) VAR_13, NULL, 10);\n          break;\n        }\n      } /* COMMENT_2 */\n\n      if (VAR_9 != 0 && VAR_10 > 0 && VAR_10 < VAR_14)\n      {\n        uint32_t VAR_15 = 1;\n        uint32_t VAR_16 = 0;\n\n        /* COMMENT_3 */\n        *VAR_12 = '\\0';\n\n        size_t VAR_17;\n        uint8_t *VAR_18 = jerry_port_read_source (VAR_11, &VAR_17);\n\n        /* COMMENT_4 */\n        *VAR_12 = ':';\n\n        /* COMMENT_5 */\n        while (VAR_16 < VAR_17 && VAR_15 < VAR_9)\n        {\n          if (VAR_18[VAR_16] == '\\n')\n          {\n            VAR_15++;\n          }\n\n          VAR_16++;\n        }\n\n        /* COMMENT_6 */\n                                                \n                                                                             \n                                                    \n            \n        for (uint32_t VAR_19 = 0;\n             (VAR_19 < VAR_14) && (VAR_16 < VAR_17) && (VAR_18[VAR_16] != '\\n');\n             VAR_19++, VAR_16++)\n        {\n          jerry_port_log (VAR_20, \"%c\", VAR_18[VAR_16]);\n        }\n        jerry_port_log (VAR_20, \"\\n\");\n\n        jerry_port_release_source (VAR_18);\n\n        while (--VAR_10)\n        {\n          jerry_port_log (VAR_20, \"~\");\n        }\n\n        jerry_port_log (VAR_20, \"^\\n\\n\");\n      }\n    }\n  }\n\n  jerry_port_log (VAR_20, \"%s\\n\", VAR_1);\n  jerry_release_value (VAR_2);\n\n  if (jerry_value_is_object (VAR_0))\n  {\n    jerry_value_t VAR_21 = jerry_create_string ((const jerry_char_t *) \"stack\");\n    jerry_value_t VAR_22 = jerry_get_property (VAR_0, VAR_21);\n    jerry_release_value (VAR_21);\n\n    if (jerry_value_is_array (VAR_22))\n    {\n      uint32_t VAR_23 = jerry_get_array_length (VAR_22);\n\n      /* COMMENT_11 */\n      if (VAR_23 > 32)\n      {\n        VAR_23 = 32;\n      }\n\n      for (uint32_t VAR_24 = 0; VAR_24 < VAR_23; VAR_24++)\n      {\n        jerry_value_t VAR_25 = jerry_get_property_by_index (VAR_22, VAR_24);\n\n        if (jerry_value_is_string (VAR_25))\n        {\n          jerry_size_t VAR_26 = jerry_get_utf8_string_size (VAR_25);\n\n          if (VAR_26 >= 256)\n          {\n            printf (\"%6u: [Backtrace string too long]\\n\", VAR_24);\n          }\n          else\n          {\n            jerry_size_t VAR_5 = jerry_string_to_utf8_char_buffer (VAR_25, VAR_1, VAR_26);\n            assert (VAR_5 == VAR_26);\n            VAR_1[VAR_5] = 0;\n\n            printf (\"%6u: %s\\n\", VAR_24, VAR_1);\n          }\n        }\n\n        jerry_release_value (VAR_25);\n      }\n    }\n\n    jerry_release_value (VAR_22);\n  }\n\n  jerry_release_value (VAR_0);\n}",
  "func_graph_path": "jerryscript-project/jerryscript/5d08eb84a1e5d240daa0720e063587253c9bfe62/main-utils.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -84,15 +84,18 @@\n           pos++;\n         }\n \n-        uint32_t char_count = 0;\n-        uint8_t ch;\n-\n-        do\n+        /* Print character if:\n+         * - The max line length is not reached.\n+         * - The current position is valid (it is not the end of the source).\n+         * - The current character is not a newline.\n+         **/\n+        for (uint32_t char_count = 0;\n+             (char_count < SYNTAX_ERROR_MAX_LINE_LENGTH) && (pos < source_size) && (source_p[pos] != '\\n');\n+             char_count++, pos++)\n         {\n-          ch = source_p[pos++];\n-          jerry_port_log (JERRY_LOG_LEVEL_ERROR, \"%c\", ch);\n+          jerry_port_log (JERRY_LOG_LEVEL_ERROR, \"%c\", source_p[pos]);\n         }\n-        while (ch != '\\n' && char_count++ < SYNTAX_ERROR_MAX_LINE_LENGTH);\n+        jerry_port_log (JERRY_LOG_LEVEL_ERROR, \"\\n\");\n \n         jerry_port_release_source (source_p);\n ",
  "diff_line_info": {
    "deleted_lines": [
      "        uint32_t char_count = 0;",
      "        uint8_t ch;",
      "",
      "        do",
      "          ch = source_p[pos++];",
      "          jerry_port_log (JERRY_LOG_LEVEL_ERROR, \"%c\", ch);",
      "        while (ch != '\\n' && char_count++ < SYNTAX_ERROR_MAX_LINE_LENGTH);"
    ],
    "added_lines": [
      "        /* Print character if:",
      "         * - The max line length is not reached.",
      "         * - The current position is valid (it is not the end of the source).",
      "         * - The current character is not a newline.",
      "         **/",
      "        for (uint32_t char_count = 0;",
      "             (char_count < SYNTAX_ERROR_MAX_LINE_LENGTH) && (pos < source_size) && (source_p[pos] != '\\n');",
      "             char_count++, pos++)",
      "          jerry_port_log (JERRY_LOG_LEVEL_ERROR, \"%c\", source_p[pos]);",
      "        jerry_port_log (JERRY_LOG_LEVEL_ERROR, \"\\n\");"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/jerryscript-project/jerryscript/pull/4350",
  "description": {
    "pr_info": {
      "title": "Correct syntax error printing in case of end of file",
      "number": 4350
    },
    "comment": [
      "The old variant of the syntax error printing method could incorrectly over-read the source file contents.\r\n\r\nFixes: #4244 "
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "The code addresses a potential buffer over-read issue when printing errors, which is a security concern. \n\n**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.8"
}