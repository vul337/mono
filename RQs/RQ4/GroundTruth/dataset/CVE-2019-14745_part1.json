{
  "cve_id": "CVE-2019-14745",
  "cwe_ids": [
    "CWE-77"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "radareorg/radare2",
  "commit_msg": "bin_symbols: Add quoting",
  "commit_hash": "f0c6dfa7a3eaad6a4a684ebfac0b2d282266adf9",
  "git_url": "https://github.com/radareorg/radare2/commit/f0c6dfa7a3eaad6a4a684ebfac0b2d282266adf9",
  "file_path": "libr/core/cbin.c",
  "func_name": "bin_symbols",
  "func_before": "static int bin_symbols(RCore *r, int mode, ut64 laddr, int va, ut64 at, const char *name, bool exponly, const char *args) {\n\tRBinInfo *info = r_bin_get_info (r->bin);\n\tRList *entries = r_bin_get_entries (r->bin);\n\tRBinSymbol *symbol;\n\tRBinAddr *entry;\n\tRListIter *iter;\n\tbool firstexp = true;\n\tbool printHere = false;\n\tint i = 0, lastfs = 's';\n\tbool bin_demangle = r_config_get_i (r->config, \"bin.demangle\");\n\tif (!info) {\n\t\treturn 0;\n\t}\n\n\tif (args && *args == '.') {\n\t\tprintHere = true;\n\t}\n\n\tbool is_arm = info && info->arch && !strncmp (info->arch, \"arm\", 3);\n\tconst char *lang = bin_demangle ? r_config_get (r->config, \"bin.lang\") : NULL;\n\n\tRList *symbols = r_bin_get_symbols (r->bin);\n\tr_spaces_push (&r->anal->meta_spaces, \"bin\");\n\n\tif (IS_MODE_JSON (mode) && !printHere) {\n\t\tr_cons_printf (\"[\");\n\t} else if (IS_MODE_SET (mode)) {\n\t\tr_flag_space_set (r->flags, R_FLAGS_FS_SYMBOLS);\n\t} else if (!at && exponly) {\n\t\tif (IS_MODE_RAD (mode)) {\n\t\t\tr_cons_printf (\"fs exports\\n\");\n\t\t} else if (IS_MODE_NORMAL (mode)) {\n\t\t\tr_cons_printf (printHere ? \"\" : \"[Exports]\\n\");\n\t\t}\n\t} else if (!at && !exponly) {\n\t\tif (IS_MODE_RAD (mode)) {\n\t\t\tr_cons_printf (\"fs symbols\\n\");\n\t\t} else if (IS_MODE_NORMAL (mode)) {\n\t\t\tr_cons_printf (printHere ? \"\" : \"[Symbols]\\n\");\n\t\t}\n\t}\n\tif (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_printf (\"Num Paddr      Vaddr      Bind     Type Size Name\\n\");\n\t}\n\n\n\tsize_t count = 0;\n\tr_list_foreach (symbols, iter, symbol) {\n\t\tif (!symbol->name) {\n\t\t\tcontinue;\n\t\t}\n\t\tchar *r_symbol_name = r_str_escape_utf8 (symbol->name, false, true);\n\t\tut64 addr = compute_addr (r->bin, symbol->paddr, symbol->vaddr, va);\n\t\tint len = symbol->size ? symbol->size : 32;\n\t\tSymName sn = {0};\n\n\t\tif (exponly && !isAnExport (symbol)) {\n\t\t\tfree (r_symbol_name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (name && strcmp (r_symbol_name, name)) {\n\t\t\tfree (r_symbol_name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (at && (!symbol->size || !is_in_range (at, addr, symbol->size))) {\n\t\t\tfree (r_symbol_name);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((printHere && !is_in_range (r->offset, symbol->paddr, len))\n\t\t\t\t&& (printHere && !is_in_range (r->offset, addr, len))) {\n\t\t\tfree (r_symbol_name);\n\t\t\tcontinue;\n\t\t}\n\t\tcount ++;\n\t\tsnInit (r, &sn, symbol, lang);\n\n\t\tif (IS_MODE_SET (mode) && (is_section_symbol (symbol) || is_file_symbol (symbol))) {\n\t\t\t/*\n\t\t\t * Skip section symbols because they will have their own flag.\n\t\t\t * Skip also file symbols because not useful for now.\n\t\t\t */\n\t\t} else if (IS_MODE_SET (mode) && is_special_symbol (symbol)) {\n\t\t\tif (is_arm) {\n\t\t\t\thandle_arm_special_symbol (r, symbol, va);\n\t\t\t}\n\t\t} else if (IS_MODE_SET (mode)) {\n\t\t\t// TODO: provide separate API in RBinPlugin to let plugins handle anal hints/metadata\n\t\t\tif (is_arm) {\n\t\t\t\thandle_arm_symbol (r, symbol, info, va);\n\t\t\t}\n\t\t\tselect_flag_space (r, symbol);\n\t\t\t/* If that's a Classed symbol (method or so) */\n\t\t\tif (sn.classname) {\n\t\t\t\tRFlagItem *fi = r_flag_get (r->flags, sn.methflag);\n\t\t\t\tif (r->bin->prefix) {\n\t\t\t\t\tchar *prname = r_str_newf (\"%s.%s\", r->bin->prefix, sn.methflag);\n\t\t\t\t\tr_name_filter (sn.methflag, -1);\n\t\t\t\t\tfree (sn.methflag);\n\t\t\t\t\tsn.methflag = prname;\n\t\t\t\t}\n\t\t\t\tif (fi) {\n\t\t\t\t\tr_flag_item_set_realname (fi, sn.methname);\n\t\t\t\t\tif ((fi->offset - r->flags->base) == addr) {\n\t\t\t\t//\t\tchar *comment = fi->comment ? strdup (fi->comment) : NULL;\n\t\t\t\t\t\tr_flag_unset (r->flags, fi);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfi = r_flag_set (r->flags, sn.methflag, addr, symbol->size);\n\t\t\t\t\tchar *comment = fi->comment ? strdup (fi->comment) : NULL;\n\t\t\t\t\tif (comment) {\n\t\t\t\t\t\tr_flag_item_set_comment (fi, comment);\n\t\t\t\t\t\tR_FREE (comment);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst char *n = sn.demname ? sn.demname : sn.name;\n\t\t\t\tconst char *fn = sn.demflag ? sn.demflag : sn.nameflag;\n\t\t\t\tchar *fnp = (r->bin->prefix) ?\n\t\t\t\t\tr_str_newf (\"%s.%s\", r->bin->prefix, fn):\n\t\t\t\t\tstrdup (fn);\n\t\t\t\tRFlagItem *fi = r_flag_set (r->flags, fnp, addr, symbol->size);\n\t\t\t\tif (fi) {\n\t\t\t\t\tr_flag_item_set_realname (fi, n);\n\t\t\t\t\tfi->demangled = (bool)(size_t)sn.demname;\n\t\t\t\t} else {\n\t\t\t\t\tif (fn) {\n\t\t\t\t\t\teprintf (\"[Warning] Can't find flag (%s)\\n\", fn);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree (fnp);\n\t\t\t}\n\t\t\tif (sn.demname) {\n\t\t\t\tr_meta_add (r->anal, R_META_TYPE_COMMENT,\n\t\t\t\t\taddr, symbol->size, sn.demname);\n\t\t\t}\n\t\t\tr_flag_space_pop (r->flags);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tchar *str = r_str_escape_utf8_for_json (r_symbol_name, -1);\n\t\t\t// str = r_str_replace (str, \"\\\"\", \"\\\\\\\"\", 1);\n\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"demname\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"flagname\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"ordinal\\\":%d,\"\n\t\t\t\t\"\\\"bind\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"size\\\":%d,\"\n\t\t\t\t\"\\\"type\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"vaddr\\\":%\"PFMT64d\",\"\n\t\t\t\t\"\\\"paddr\\\":%\"PFMT64d\"}\",\n\t\t\t\t((exponly && firstexp) || printHere) ? \"\" : (iter->p ? \",\" : \"\"),\n\t\t\t\tstr,\n\t\t\t\tsn.demname? sn.demname: \"\",\n\t\t\t\tsn.nameflag,\n\t\t\t\tsymbol->ordinal,\n\t\t\t\tsymbol->bind,\n\t\t\t\t(int)symbol->size,\n\t\t\t\tsymbol->type,\n\t\t\t\t(ut64)addr, (ut64)symbol->paddr);\n\t\t\tfree (str);\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tconst char *name = sn.demname? sn.demname: r_symbol_name;\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" %d %s\\n\",\n\t\t\t\taddr, (int)symbol->size, name);\n\t\t} else if (IS_MODE_SIMPLEST (mode)) {\n\t\t\tconst char *name = sn.demname? sn.demname: r_symbol_name;\n\t\t\tr_cons_printf (\"%s\\n\", name);\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\t/* Skip special symbols because we do not flag them and\n\t\t\t * they shouldn't be printed in the rad format either */\n\t\t\tif (!is_special_symbol (symbol)) {\n\t\t\t\tRBinFile *binfile;\n\t\t\t\tRBinPlugin *plugin;\n\t\t\t\tchar *name = strdup (sn.demname? sn.demname: r_symbol_name);\n\t\t\t\tr_name_filter (name, -1);\n\t\t\t\tif (!strncmp (name, \"imp.\", 4)) {\n\t\t\t\t\tif (lastfs != 'i') {\n\t\t\t\t\t\tr_cons_printf (\"fs imports\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tlastfs = 'i';\n\t\t\t\t} else {\n\t\t\t\t\tif (lastfs != 's') {\n\t\t\t\t\t\tr_cons_printf (\"fs %s\\n\",\n\t\t\t\t\t\t\texponly? \"exports\": \"symbols\");\n\t\t\t\t\t}\n\t\t\t\t\tlastfs = 's';\n\t\t\t\t}\n\t\t\t\tif (r->bin->prefix) {\n\t\t\t\t\tr_cons_printf (\"f %s.sym.%s %u 0x%08\" PFMT64x \"\\n\",\n\t\t\t\t\t\tr->bin->prefix, r_bin_symbol_name (symbol), symbol->size, addr);\n\t\t\t\t} else {\n\t\t\t\t\tif (*name) {\n\t\t\t\t\t\tr_cons_printf (\"f sym.%s %u 0x%08\" PFMT64x \"\\n\",\n\t\t\t\t\t\t\tr_bin_symbol_name (symbol), symbol->size, addr);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// we don't want unnamed symbol flags\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbinfile = r_bin_cur (r->bin);\n\t\t\t\tplugin = r_bin_file_cur_plugin (binfile);\n\t\t\t\tif (plugin && plugin->name) {\n\t\t\t\t\tif (r_str_startswith (plugin->name, \"pe\")) {\n\t\t\t\t\t\tchar *module = strdup (r_symbol_name);\n\t\t\t\t\t\tchar *p = strstr (module, \".dll_\");\n\t\t\t\t\t\tif (p && strstr (module, \"imp.\")) {\n\t\t\t\t\t\t\tconst char *symname = p + 5;\n\t\t\t\t\t\t\t*p = 0;\n\t\t\t\t\t\t\tif (r->bin->prefix) {\n\t\t\t\t\t\t\t\tr_cons_printf (\"k bin/pe/%s/%d=%s.%s\\n\",\n\t\t\t\t\t\t\t\t\tmodule, symbol->ordinal, r->bin->prefix, symname);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tr_cons_printf (\"k bin/pe/%s/%d=%s\\n\",\n\t\t\t\t\t\t\t\t\tmodule, symbol->ordinal, symname);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree (module);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tconst char *bind = symbol->bind? symbol->bind: \"NONE\";\n\t\t\tconst char *type = symbol->type? symbol->type: \"NONE\";\n\t\t\tconst char *name = r_str_get (sn.demname? sn.demname: r_symbol_name);\n\t\t\t// const char *fwd = r_str_get (symbol->forwarder);\n\t\t\tr_cons_printf (\"%03u\", symbol->ordinal);\n\t\t\tif (symbol->paddr == UT64_MAX) {\n\t\t\t\tr_cons_printf (\" ----------\");\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\" 0x%08\"PFMT64x, symbol->paddr);\n\t\t\t}\n\t\t\tr_cons_printf (\" 0x%08\"PFMT64x\" %6s %6s %4d%s%s\\n\",\n\t\t\t               addr, bind, type, symbol->size, *name? \" \": \"\", name);\n\t\t}\n\t\tsnFini (&sn);\n\t\ti++;\n\t\tfree (r_symbol_name);\n\t\tif (exponly && firstexp) {\n\t\t\tfirstexp = false;\n\t\t}\n\t\tif (printHere) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (count == 0 && IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"{}\");\n\t}\n\n\n\t//handle thumb and arm for entry point since they are not present in symbols\n\tif (is_arm) {\n\t\tr_list_foreach (entries, iter, entry) {\n\t\t\tif (IS_MODE_SET (mode)) {\n\t\t\t\thandle_arm_entry (r, entry, info, va);\n\t\t\t}\n\t\t}\n\t}\n\tif (IS_MODE_JSON (mode) && !printHere) {\n\t\tr_cons_printf (\"]\");\n\t}\n\n\tr_spaces_pop (&r->anal->meta_spaces);\n\treturn true;\n}",
  "abstract_func_before": "static int bin_symbols(RCore *VAR_0, int VAR_1, ut64 VAR_2, int VAR_3, ut64 VAR_4, const char *VAR_5, bool VAR_6, const char *VAR_7) {\n\tRBinInfo *VAR_8 = r_bin_get_info (VAR_0->bin);\n\tRList *VAR_9 = r_bin_get_entries (VAR_0->bin);\n\tRBinSymbol *VAR_10;\n\tRBinAddr *VAR_11;\n\tRListIter *VAR_12;\n\tbool VAR_13 = true;\n\tbool VAR_14 = false;\n\tint VAR_15 = 0, VAR_16 = 's';\n\tbool VAR_17 = r_config_get_i (VAR_0->config, \"bin.demangle\");\n\tif (!VAR_8) {\n\t\treturn 0;\n\t}\n\n\tif (VAR_7 && *VAR_7 == '.') {\n\t\tVAR_14 = true;\n\t}\n\n\tbool VAR_18 = VAR_8 && VAR_8->arch && !strncmp (VAR_8->arch, \"arm\", 3);\n\tconst char *VAR_19 = VAR_17 ? r_config_get (VAR_0->config, \"bin.lang\") : NULL;\n\n\tRList *VAR_20 = r_bin_get_symbols (VAR_0->bin);\n\tr_spaces_push (&VAR_0->anal->meta_spaces, \"bin\");\n\n\tif (IS_MODE_JSON (VAR_1) && !VAR_14) {\n\t\tr_cons_printf (\"[\");\n\t} else if (IS_MODE_SET (VAR_1)) {\n\t\tr_flag_space_set (VAR_0->flags, VAR_21);\n\t} else if (!VAR_4 && VAR_6) {\n\t\tif (IS_MODE_RAD (VAR_1)) {\n\t\t\tr_cons_printf (\"fs exports\\n\");\n\t\t} else if (IS_MODE_NORMAL (VAR_1)) {\n\t\t\tr_cons_printf (VAR_14 ? \"\" : \"[Exports]\\n\");\n\t\t}\n\t} else if (!VAR_4 && !VAR_6) {\n\t\tif (IS_MODE_RAD (VAR_1)) {\n\t\t\tr_cons_printf (\"fs symbols\\n\");\n\t\t} else if (IS_MODE_NORMAL (VAR_1)) {\n\t\t\tr_cons_printf (VAR_14 ? \"\" : \"[Symbols]\\n\");\n\t\t}\n\t}\n\tif (IS_MODE_NORMAL (VAR_1)) {\n\t\tr_cons_printf (\"Num Paddr      Vaddr      Bind     Type Size Name\\n\");\n\t}\n\n\n\tsize_t VAR_22 = 0;\n\tr_list_foreach (VAR_20, VAR_12, VAR_10) {\n\t\tif (!VAR_10->name) {\n\t\t\tcontinue;\n\t\t}\n\t\tchar *VAR_23 = r_str_escape_utf8 (VAR_10->name, false, true);\n\t\tut64 VAR_24 = compute_addr (VAR_0->bin, VAR_10->paddr, VAR_10->vaddr, VAR_3);\n\t\tint VAR_25 = VAR_10->size ? VAR_10->size : 32;\n\t\tSymName VAR_26 = {0};\n\n\t\tif (VAR_6 && !isAnExport (VAR_10)) {\n\t\t\tfree (VAR_23);\n\t\t\tcontinue;\n\t\t}\n\t\tif (VAR_5 && strcmp (VAR_23, VAR_5)) {\n\t\t\tfree (VAR_23);\n\t\t\tcontinue;\n\t\t}\n\t\tif (VAR_4 && (!VAR_10->size || !is_in_range (VAR_4, VAR_24, VAR_10->size))) {\n\t\t\tfree (VAR_23);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((VAR_14 && !is_in_range (VAR_0->offset, VAR_10->paddr, VAR_25))\n\t\t\t\t&& (VAR_14 && !is_in_range (VAR_0->offset, VAR_24, VAR_25))) {\n\t\t\tfree (VAR_23);\n\t\t\tcontinue;\n\t\t}\n\t\tVAR_22 ++;\n\t\tsnInit (VAR_0, &VAR_26, VAR_10, VAR_19);\n\n\t\tif (IS_MODE_SET (VAR_1) && (is_section_symbol (VAR_10) || is_file_symbol (VAR_10))) {\n\t\t\t/* COMMENT_0 */\n                                                                 \n                                                        \n      \n\t\t} else if (IS_MODE_SET (VAR_1) && is_special_symbol (VAR_10)) {\n\t\t\tif (VAR_18) {\n\t\t\t\thandle_arm_special_symbol (VAR_0, VAR_10, VAR_3);\n\t\t\t}\n\t\t} else if (IS_MODE_SET (VAR_1)) {\n\t\t\t/* COMMENT_4 */\n\t\t\tif (VAR_18) {\n\t\t\t\thandle_arm_symbol (VAR_0, VAR_10, VAR_8, VAR_3);\n\t\t\t}\n\t\t\tselect_flag_space (VAR_0, VAR_10);\n\t\t\t/* COMMENT_5 */\n\t\t\tif (VAR_26.classname) {\n\t\t\t\tRFlagItem *VAR_27 = r_flag_get (VAR_0->flags, VAR_26.methflag);\n\t\t\t\tif (VAR_0->bin->prefix) {\n\t\t\t\t\tchar *VAR_28 = r_str_newf (\"%s.%s\", VAR_0->bin->prefix, VAR_26.methflag);\n\t\t\t\t\tr_name_filter (VAR_26.methflag, -1);\n\t\t\t\t\tfree (VAR_26.methflag);\n\t\t\t\t\tVAR_26.methflag = VAR_28;\n\t\t\t\t}\n\t\t\t\tif (VAR_27) {\n\t\t\t\t\tr_flag_item_set_realname (VAR_27, VAR_26.methname);\n\t\t\t\t\tif ((VAR_27->offset - VAR_0->flags->base) == VAR_24) {\n\t\t\t\t/* COMMENT_6 */\n\t\t\t\t\t\tr_flag_unset (VAR_0->flags, VAR_27);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tVAR_27 = r_flag_set (VAR_0->flags, VAR_26.methflag, VAR_24, VAR_10->size);\n\t\t\t\t\tchar *VAR_29 = VAR_27->comment ? strdup (VAR_27->comment) : NULL;\n\t\t\t\t\tif (VAR_29) {\n\t\t\t\t\t\tr_flag_item_set_comment (VAR_27, VAR_29);\n\t\t\t\t\t\tR_FREE (VAR_29);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst char *VAR_30 = VAR_26.demname ? VAR_26.demname : VAR_26.name;\n\t\t\t\tconst char *VAR_31 = VAR_26.demflag ? VAR_26.demflag : VAR_26.nameflag;\n\t\t\t\tchar *VAR_32 = (VAR_0->bin->prefix) ?\n\t\t\t\t\tr_str_newf (\"%s.%s\", VAR_0->bin->prefix, VAR_31):\n\t\t\t\t\tstrdup (VAR_31);\n\t\t\t\tRFlagItem *VAR_27 = r_flag_set (VAR_0->flags, VAR_32, VAR_24, VAR_10->size);\n\t\t\t\tif (VAR_27) {\n\t\t\t\t\tr_flag_item_set_realname (VAR_27, VAR_30);\n\t\t\t\t\tVAR_27->demangled = (bool)(size_t)VAR_26.demname;\n\t\t\t\t} else {\n\t\t\t\t\tif (VAR_31) {\n\t\t\t\t\t\teprintf (\"[Warning] Can't find flag (%s)\\n\", VAR_31);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree (VAR_32);\n\t\t\t}\n\t\t\tif (VAR_26.demname) {\n\t\t\t\tr_meta_add (VAR_0->anal, VAR_33,\n\t\t\t\t\tVAR_24, VAR_10->size, VAR_26.demname);\n\t\t\t}\n\t\t\tr_flag_space_pop (VAR_0->flags);\n\t\t} else if (IS_MODE_JSON (VAR_1)) {\n\t\t\tchar *VAR_34 = r_str_escape_utf8_for_json (VAR_23, -1);\n\t\t\t/* COMMENT_7 */\n\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"demname\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"flagname\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"ordinal\\\":%d,\"\n\t\t\t\t\"\\\"bind\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"size\\\":%d,\"\n\t\t\t\t\"\\\"type\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"vaddr\\\":%\"VAR_35\",\"\n\t\t\t\t\"\\\"paddr\\\":%\"VAR_35\"}\",\n\t\t\t\t((VAR_6 && VAR_13) || VAR_14) ? \"\" : (VAR_12->p ? \",\" : \"\"),\n\t\t\t\tVAR_34,\n\t\t\t\tVAR_26.demname? VAR_26.demname: \"\",\n\t\t\t\tVAR_26.nameflag,\n\t\t\t\tVAR_10->ordinal,\n\t\t\t\tVAR_10->bind,\n\t\t\t\t(int)VAR_10->size,\n\t\t\t\tVAR_10->type,\n\t\t\t\t(ut64)VAR_24, (ut64)VAR_10->paddr);\n\t\t\tfree (VAR_34);\n\t\t} else if (IS_MODE_SIMPLE (VAR_1)) {\n\t\t\tconst char *VAR_5 = VAR_26.demname? VAR_26.demname: VAR_23;\n\t\t\tr_cons_printf (\"0x%08\"VAR_36\" %d %s\\n\",\n\t\t\t\tVAR_24, (int)VAR_10->size, VAR_5);\n\t\t} else if (IS_MODE_SIMPLEST (VAR_1)) {\n\t\t\tconst char *VAR_5 = VAR_26.demname? VAR_26.demname: VAR_23;\n\t\t\tr_cons_printf (\"%s\\n\", VAR_5);\n\t\t} else if (IS_MODE_RAD (VAR_1)) {\n\t\t\t/* COMMENT_8 */\n                                                           \n\t\t\tif (!is_special_symbol (VAR_10)) {\n\t\t\t\tRBinFile *VAR_37;\n\t\t\t\tRBinPlugin *VAR_38;\n\t\t\t\tchar *VAR_5 = strdup (VAR_26.demname? VAR_26.demname: VAR_23);\n\t\t\t\tr_name_filter (VAR_5, -1);\n\t\t\t\tif (!strncmp (VAR_5, \"imp.\", 4)) {\n\t\t\t\t\tif (VAR_16 != 'i') {\n\t\t\t\t\t\tr_cons_printf (\"fs imports\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tVAR_16 = 'i';\n\t\t\t\t} else {\n\t\t\t\t\tif (VAR_16 != 's') {\n\t\t\t\t\t\tr_cons_printf (\"fs %s\\n\",\n\t\t\t\t\t\t\tVAR_6? \"exports\": \"symbols\");\n\t\t\t\t\t}\n\t\t\t\t\tVAR_16 = 's';\n\t\t\t\t}\n\t\t\t\tif (VAR_0->bin->prefix) {\n\t\t\t\t\tr_cons_printf (\"f %s.sym.%s %u 0x%08\" VAR_36 \"\\n\",\n\t\t\t\t\t\tVAR_0->bin->prefix, r_bin_symbol_name (VAR_10), VAR_10->size, VAR_24);\n\t\t\t\t} else {\n\t\t\t\t\tif (*VAR_5) {\n\t\t\t\t\t\tr_cons_printf (\"f sym.%s %u 0x%08\" VAR_36 \"\\n\",\n\t\t\t\t\t\t\tr_bin_symbol_name (VAR_10), VAR_10->size, VAR_24);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* COMMENT_10 */\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tVAR_37 = r_bin_cur (VAR_0->bin);\n\t\t\t\tVAR_38 = r_bin_file_cur_plugin (VAR_37);\n\t\t\t\tif (VAR_38 && VAR_38->name) {\n\t\t\t\t\tif (r_str_startswith (VAR_38->name, \"pe\")) {\n\t\t\t\t\t\tchar *VAR_39 = strdup (VAR_23);\n\t\t\t\t\t\tchar *VAR_40 = strstr (VAR_39, \".dll_\");\n\t\t\t\t\t\tif (VAR_40 && strstr (VAR_39, \"imp.\")) {\n\t\t\t\t\t\t\tconst char *VAR_41 = VAR_40 + 5;\n\t\t\t\t\t\t\t*VAR_40 = 0;\n\t\t\t\t\t\t\tif (VAR_0->bin->prefix) {\n\t\t\t\t\t\t\t\tr_cons_printf (\"k bin/pe/%s/%d=%s.%s\\n\",\n\t\t\t\t\t\t\t\t\tVAR_39, VAR_10->ordinal, VAR_0->bin->prefix, VAR_41);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tr_cons_printf (\"k bin/pe/%s/%d=%s\\n\",\n\t\t\t\t\t\t\t\t\tVAR_39, VAR_10->ordinal, VAR_41);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree (VAR_39);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tconst char *VAR_42 = VAR_10->bind? VAR_10->bind: \"NONE\";\n\t\t\tconst char *VAR_43 = VAR_10->type? VAR_10->type: \"NONE\";\n\t\t\tconst char *VAR_5 = r_str_get (VAR_26.demname? VAR_26.demname: VAR_23);\n\t\t\t/* COMMENT_11 */\n\t\t\tr_cons_printf (\"%03u\", VAR_10->ordinal);\n\t\t\tif (VAR_10->paddr == VAR_44) {\n\t\t\t\tr_cons_printf (\" ----------\");\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\" 0x%08\"VAR_36, VAR_10->paddr);\n\t\t\t}\n\t\t\tr_cons_printf (\" 0x%08\"VAR_36\" %6s %6s %4d%s%s\\n\",\n\t\t\t               VAR_24, VAR_42, VAR_43, VAR_10->size, *VAR_5? \" \": \"\", VAR_5);\n\t\t}\n\t\tsnFini (&VAR_26);\n\t\tVAR_15++;\n\t\tfree (VAR_23);\n\t\tif (VAR_6 && VAR_13) {\n\t\t\tVAR_13 = false;\n\t\t}\n\t\tif (VAR_14) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (VAR_22 == 0 && IS_MODE_JSON (VAR_1)) {\n\t\tr_cons_printf (\"{}\");\n\t}\n\n\n\t/* COMMENT_12 */\n\tif (VAR_18) {\n\t\tr_list_foreach (VAR_9, VAR_12, VAR_11) {\n\t\t\tif (IS_MODE_SET (VAR_1)) {\n\t\t\t\thandle_arm_entry (VAR_0, VAR_11, VAR_8, VAR_3);\n\t\t\t}\n\t\t}\n\t}\n\tif (IS_MODE_JSON (VAR_1) && !VAR_14) {\n\t\tr_cons_printf (\"]\");\n\t}\n\n\tr_spaces_pop (&VAR_0->anal->meta_spaces);\n\treturn true;\n}",
  "func_graph_path_before": "radareorg/radare2/f0c6dfa7a3eaad6a4a684ebfac0b2d282266adf9/cbin.c/vul/before/0.json",
  "func": "static int bin_symbols(RCore *r, int mode, ut64 laddr, int va, ut64 at, const char *name, bool exponly, const char *args) {\n\tRBinInfo *info = r_bin_get_info (r->bin);\n\tRList *entries = r_bin_get_entries (r->bin);\n\tRBinSymbol *symbol;\n\tRBinAddr *entry;\n\tRListIter *iter;\n\tbool firstexp = true;\n\tbool printHere = false;\n\tint i = 0, lastfs = 's';\n\tbool bin_demangle = r_config_get_i (r->config, \"bin.demangle\");\n\tif (!info) {\n\t\treturn 0;\n\t}\n\n\tif (args && *args == '.') {\n\t\tprintHere = true;\n\t}\n\n\tbool is_arm = info && info->arch && !strncmp (info->arch, \"arm\", 3);\n\tconst char *lang = bin_demangle ? r_config_get (r->config, \"bin.lang\") : NULL;\n\n\tRList *symbols = r_bin_get_symbols (r->bin);\n\tr_spaces_push (&r->anal->meta_spaces, \"bin\");\n\n\tif (IS_MODE_JSON (mode) && !printHere) {\n\t\tr_cons_printf (\"[\");\n\t} else if (IS_MODE_SET (mode)) {\n\t\tr_flag_space_set (r->flags, R_FLAGS_FS_SYMBOLS);\n\t} else if (!at && exponly) {\n\t\tif (IS_MODE_RAD (mode)) {\n\t\t\tr_cons_printf (\"fs exports\\n\");\n\t\t} else if (IS_MODE_NORMAL (mode)) {\n\t\t\tr_cons_printf (printHere ? \"\" : \"[Exports]\\n\");\n\t\t}\n\t} else if (!at && !exponly) {\n\t\tif (IS_MODE_RAD (mode)) {\n\t\t\tr_cons_printf (\"fs symbols\\n\");\n\t\t} else if (IS_MODE_NORMAL (mode)) {\n\t\t\tr_cons_printf (printHere ? \"\" : \"[Symbols]\\n\");\n\t\t}\n\t}\n\tif (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_printf (\"Num Paddr      Vaddr      Bind     Type Size Name\\n\");\n\t}\n\n\n\tsize_t count = 0;\n\tr_list_foreach (symbols, iter, symbol) {\n\t\tif (!symbol->name) {\n\t\t\tcontinue;\n\t\t}\n\t\tchar *r_symbol_name = r_str_escape_utf8 (symbol->name, false, true);\n\t\tut64 addr = compute_addr (r->bin, symbol->paddr, symbol->vaddr, va);\n\t\tint len = symbol->size ? symbol->size : 32;\n\t\tSymName sn = {0};\n\n\t\tif (exponly && !isAnExport (symbol)) {\n\t\t\tfree (r_symbol_name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (name && strcmp (r_symbol_name, name)) {\n\t\t\tfree (r_symbol_name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (at && (!symbol->size || !is_in_range (at, addr, symbol->size))) {\n\t\t\tfree (r_symbol_name);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((printHere && !is_in_range (r->offset, symbol->paddr, len))\n\t\t\t\t&& (printHere && !is_in_range (r->offset, addr, len))) {\n\t\t\tfree (r_symbol_name);\n\t\t\tcontinue;\n\t\t}\n\t\tcount ++;\n\t\tsnInit (r, &sn, symbol, lang);\n\n\t\tif (IS_MODE_SET (mode) && (is_section_symbol (symbol) || is_file_symbol (symbol))) {\n\t\t\t/*\n\t\t\t * Skip section symbols because they will have their own flag.\n\t\t\t * Skip also file symbols because not useful for now.\n\t\t\t */\n\t\t} else if (IS_MODE_SET (mode) && is_special_symbol (symbol)) {\n\t\t\tif (is_arm) {\n\t\t\t\thandle_arm_special_symbol (r, symbol, va);\n\t\t\t}\n\t\t} else if (IS_MODE_SET (mode)) {\n\t\t\t// TODO: provide separate API in RBinPlugin to let plugins handle anal hints/metadata\n\t\t\tif (is_arm) {\n\t\t\t\thandle_arm_symbol (r, symbol, info, va);\n\t\t\t}\n\t\t\tselect_flag_space (r, symbol);\n\t\t\t/* If that's a Classed symbol (method or so) */\n\t\t\tif (sn.classname) {\n\t\t\t\tRFlagItem *fi = r_flag_get (r->flags, sn.methflag);\n\t\t\t\tif (r->bin->prefix) {\n\t\t\t\t\tchar *prname = r_str_newf (\"%s.%s\", r->bin->prefix, sn.methflag);\n\t\t\t\t\tr_name_filter (sn.methflag, -1);\n\t\t\t\t\tfree (sn.methflag);\n\t\t\t\t\tsn.methflag = prname;\n\t\t\t\t}\n\t\t\t\tif (fi) {\n\t\t\t\t\tr_flag_item_set_realname (fi, sn.methname);\n\t\t\t\t\tif ((fi->offset - r->flags->base) == addr) {\n\t\t\t\t//\t\tchar *comment = fi->comment ? strdup (fi->comment) : NULL;\n\t\t\t\t\t\tr_flag_unset (r->flags, fi);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfi = r_flag_set (r->flags, sn.methflag, addr, symbol->size);\n\t\t\t\t\tchar *comment = fi->comment ? strdup (fi->comment) : NULL;\n\t\t\t\t\tif (comment) {\n\t\t\t\t\t\tr_flag_item_set_comment (fi, comment);\n\t\t\t\t\t\tR_FREE (comment);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst char *n = sn.demname ? sn.demname : sn.name;\n\t\t\t\tconst char *fn = sn.demflag ? sn.demflag : sn.nameflag;\n\t\t\t\tchar *fnp = (r->bin->prefix) ?\n\t\t\t\t\tr_str_newf (\"%s.%s\", r->bin->prefix, fn):\n\t\t\t\t\tstrdup (fn);\n\t\t\t\tRFlagItem *fi = r_flag_set (r->flags, fnp, addr, symbol->size);\n\t\t\t\tif (fi) {\n\t\t\t\t\tr_flag_item_set_realname (fi, n);\n\t\t\t\t\tfi->demangled = (bool)(size_t)sn.demname;\n\t\t\t\t} else {\n\t\t\t\t\tif (fn) {\n\t\t\t\t\t\teprintf (\"[Warning] Can't find flag (%s)\\n\", fn);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree (fnp);\n\t\t\t}\n\t\t\tif (sn.demname) {\n\t\t\t\tr_meta_add (r->anal, R_META_TYPE_COMMENT,\n\t\t\t\t\taddr, symbol->size, sn.demname);\n\t\t\t}\n\t\t\tr_flag_space_pop (r->flags);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tchar *str = r_str_escape_utf8_for_json (r_symbol_name, -1);\n\t\t\t// str = r_str_replace (str, \"\\\"\", \"\\\\\\\"\", 1);\n\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"demname\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"flagname\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"ordinal\\\":%d,\"\n\t\t\t\t\"\\\"bind\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"size\\\":%d,\"\n\t\t\t\t\"\\\"type\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"vaddr\\\":%\"PFMT64d\",\"\n\t\t\t\t\"\\\"paddr\\\":%\"PFMT64d\"}\",\n\t\t\t\t((exponly && firstexp) || printHere) ? \"\" : (iter->p ? \",\" : \"\"),\n\t\t\t\tstr,\n\t\t\t\tsn.demname? sn.demname: \"\",\n\t\t\t\tsn.nameflag,\n\t\t\t\tsymbol->ordinal,\n\t\t\t\tsymbol->bind,\n\t\t\t\t(int)symbol->size,\n\t\t\t\tsymbol->type,\n\t\t\t\t(ut64)addr, (ut64)symbol->paddr);\n\t\t\tfree (str);\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tconst char *name = sn.demname? sn.demname: r_symbol_name;\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" %d %s\\n\",\n\t\t\t\taddr, (int)symbol->size, name);\n\t\t} else if (IS_MODE_SIMPLEST (mode)) {\n\t\t\tconst char *name = sn.demname? sn.demname: r_symbol_name;\n\t\t\tr_cons_printf (\"%s\\n\", name);\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\t/* Skip special symbols because we do not flag them and\n\t\t\t * they shouldn't be printed in the rad format either */\n\t\t\tif (!is_special_symbol (symbol)) {\n\t\t\t\tRBinFile *binfile;\n\t\t\t\tRBinPlugin *plugin;\n\t\t\t\tchar *name = strdup (sn.demname? sn.demname: r_symbol_name);\n\t\t\t\tr_name_filter (name, -1);\n\t\t\t\tif (!strncmp (name, \"imp.\", 4)) {\n\t\t\t\t\tif (lastfs != 'i') {\n\t\t\t\t\t\tr_cons_printf (\"fs imports\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tlastfs = 'i';\n\t\t\t\t} else {\n\t\t\t\t\tif (lastfs != 's') {\n\t\t\t\t\t\tr_cons_printf (\"fs %s\\n\",\n\t\t\t\t\t\t\texponly? \"exports\": \"symbols\");\n\t\t\t\t\t}\n\t\t\t\t\tlastfs = 's';\n\t\t\t\t}\n\t\t\t\tif (r->bin->prefix) {\n\t\t\t\t\tr_cons_printf (\"\\\"f %s.sym.%s %u 0x%08\" PFMT64x \"\\\"\\n\",\n\t\t\t\t\t\tr->bin->prefix, r_bin_symbol_name (symbol), symbol->size, addr);\n\t\t\t\t} else {\n\t\t\t\t\tif (*name) {\n\t\t\t\t\t\tr_cons_printf (\"\\\"f sym.%s %u 0x%08\" PFMT64x \"\\\"\\n\",\n\t\t\t\t\t\t\tr_bin_symbol_name (symbol), symbol->size, addr);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// we don't want unnamed symbol flags\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbinfile = r_bin_cur (r->bin);\n\t\t\t\tplugin = r_bin_file_cur_plugin (binfile);\n\t\t\t\tif (plugin && plugin->name) {\n\t\t\t\t\tif (r_str_startswith (plugin->name, \"pe\")) {\n\t\t\t\t\t\tchar *module = strdup (r_symbol_name);\n\t\t\t\t\t\tchar *p = strstr (module, \".dll_\");\n\t\t\t\t\t\tif (p && strstr (module, \"imp.\")) {\n\t\t\t\t\t\t\tconst char *symname = p + 5;\n\t\t\t\t\t\t\t*p = 0;\n\t\t\t\t\t\t\tif (r->bin->prefix) {\n\t\t\t\t\t\t\t\tr_cons_printf (\"k bin/pe/%s/%d=%s.%s\\n\",\n\t\t\t\t\t\t\t\t\tmodule, symbol->ordinal, r->bin->prefix, symname);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tr_cons_printf (\"k bin/pe/%s/%d=%s\\n\",\n\t\t\t\t\t\t\t\t\tmodule, symbol->ordinal, symname);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree (module);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tconst char *bind = symbol->bind? symbol->bind: \"NONE\";\n\t\t\tconst char *type = symbol->type? symbol->type: \"NONE\";\n\t\t\tconst char *name = r_str_get (sn.demname? sn.demname: r_symbol_name);\n\t\t\t// const char *fwd = r_str_get (symbol->forwarder);\n\t\t\tr_cons_printf (\"%03u\", symbol->ordinal);\n\t\t\tif (symbol->paddr == UT64_MAX) {\n\t\t\t\tr_cons_printf (\" ----------\");\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\" 0x%08\"PFMT64x, symbol->paddr);\n\t\t\t}\n\t\t\tr_cons_printf (\" 0x%08\"PFMT64x\" %6s %6s %4d%s%s\\n\",\n\t\t\t               addr, bind, type, symbol->size, *name? \" \": \"\", name);\n\t\t}\n\t\tsnFini (&sn);\n\t\ti++;\n\t\tfree (r_symbol_name);\n\t\tif (exponly && firstexp) {\n\t\t\tfirstexp = false;\n\t\t}\n\t\tif (printHere) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (count == 0 && IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"{}\");\n\t}\n\n\n\t//handle thumb and arm for entry point since they are not present in symbols\n\tif (is_arm) {\n\t\tr_list_foreach (entries, iter, entry) {\n\t\t\tif (IS_MODE_SET (mode)) {\n\t\t\t\thandle_arm_entry (r, entry, info, va);\n\t\t\t}\n\t\t}\n\t}\n\tif (IS_MODE_JSON (mode) && !printHere) {\n\t\tr_cons_printf (\"]\");\n\t}\n\n\tr_spaces_pop (&r->anal->meta_spaces);\n\treturn true;\n}",
  "abstract_func": "static int bin_symbols(RCore *VAR_0, int VAR_1, ut64 VAR_2, int VAR_3, ut64 VAR_4, const char *VAR_5, bool VAR_6, const char *VAR_7) {\n\tRBinInfo *VAR_8 = r_bin_get_info (VAR_0->bin);\n\tRList *VAR_9 = r_bin_get_entries (VAR_0->bin);\n\tRBinSymbol *VAR_10;\n\tRBinAddr *VAR_11;\n\tRListIter *VAR_12;\n\tbool VAR_13 = true;\n\tbool VAR_14 = false;\n\tint VAR_15 = 0, VAR_16 = 's';\n\tbool VAR_17 = r_config_get_i (VAR_0->config, \"bin.demangle\");\n\tif (!VAR_8) {\n\t\treturn 0;\n\t}\n\n\tif (VAR_7 && *VAR_7 == '.') {\n\t\tVAR_14 = true;\n\t}\n\n\tbool VAR_18 = VAR_8 && VAR_8->arch && !strncmp (VAR_8->arch, \"arm\", 3);\n\tconst char *VAR_19 = VAR_17 ? r_config_get (VAR_0->config, \"bin.lang\") : NULL;\n\n\tRList *VAR_20 = r_bin_get_symbols (VAR_0->bin);\n\tr_spaces_push (&VAR_0->anal->meta_spaces, \"bin\");\n\n\tif (IS_MODE_JSON (VAR_1) && !VAR_14) {\n\t\tr_cons_printf (\"[\");\n\t} else if (IS_MODE_SET (VAR_1)) {\n\t\tr_flag_space_set (VAR_0->flags, VAR_21);\n\t} else if (!VAR_4 && VAR_6) {\n\t\tif (IS_MODE_RAD (VAR_1)) {\n\t\t\tr_cons_printf (\"fs exports\\n\");\n\t\t} else if (IS_MODE_NORMAL (VAR_1)) {\n\t\t\tr_cons_printf (VAR_14 ? \"\" : \"[Exports]\\n\");\n\t\t}\n\t} else if (!VAR_4 && !VAR_6) {\n\t\tif (IS_MODE_RAD (VAR_1)) {\n\t\t\tr_cons_printf (\"fs symbols\\n\");\n\t\t} else if (IS_MODE_NORMAL (VAR_1)) {\n\t\t\tr_cons_printf (VAR_14 ? \"\" : \"[Symbols]\\n\");\n\t\t}\n\t}\n\tif (IS_MODE_NORMAL (VAR_1)) {\n\t\tr_cons_printf (\"Num Paddr      Vaddr      Bind     Type Size Name\\n\");\n\t}\n\n\n\tsize_t VAR_22 = 0;\n\tr_list_foreach (VAR_20, VAR_12, VAR_10) {\n\t\tif (!VAR_10->name) {\n\t\t\tcontinue;\n\t\t}\n\t\tchar *VAR_23 = r_str_escape_utf8 (VAR_10->name, false, true);\n\t\tut64 VAR_24 = compute_addr (VAR_0->bin, VAR_10->paddr, VAR_10->vaddr, VAR_3);\n\t\tint VAR_25 = VAR_10->size ? VAR_10->size : 32;\n\t\tSymName VAR_26 = {0};\n\n\t\tif (VAR_6 && !isAnExport (VAR_10)) {\n\t\t\tfree (VAR_23);\n\t\t\tcontinue;\n\t\t}\n\t\tif (VAR_5 && strcmp (VAR_23, VAR_5)) {\n\t\t\tfree (VAR_23);\n\t\t\tcontinue;\n\t\t}\n\t\tif (VAR_4 && (!VAR_10->size || !is_in_range (VAR_4, VAR_24, VAR_10->size))) {\n\t\t\tfree (VAR_23);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((VAR_14 && !is_in_range (VAR_0->offset, VAR_10->paddr, VAR_25))\n\t\t\t\t&& (VAR_14 && !is_in_range (VAR_0->offset, VAR_24, VAR_25))) {\n\t\t\tfree (VAR_23);\n\t\t\tcontinue;\n\t\t}\n\t\tVAR_22 ++;\n\t\tsnInit (VAR_0, &VAR_26, VAR_10, VAR_19);\n\n\t\tif (IS_MODE_SET (VAR_1) && (is_section_symbol (VAR_10) || is_file_symbol (VAR_10))) {\n\t\t\t/* COMMENT_0 */\n                                                                 \n                                                        \n      \n\t\t} else if (IS_MODE_SET (VAR_1) && is_special_symbol (VAR_10)) {\n\t\t\tif (VAR_18) {\n\t\t\t\thandle_arm_special_symbol (VAR_0, VAR_10, VAR_3);\n\t\t\t}\n\t\t} else if (IS_MODE_SET (VAR_1)) {\n\t\t\t/* COMMENT_4 */\n\t\t\tif (VAR_18) {\n\t\t\t\thandle_arm_symbol (VAR_0, VAR_10, VAR_8, VAR_3);\n\t\t\t}\n\t\t\tselect_flag_space (VAR_0, VAR_10);\n\t\t\t/* COMMENT_5 */\n\t\t\tif (VAR_26.classname) {\n\t\t\t\tRFlagItem *VAR_27 = r_flag_get (VAR_0->flags, VAR_26.methflag);\n\t\t\t\tif (VAR_0->bin->prefix) {\n\t\t\t\t\tchar *VAR_28 = r_str_newf (\"%s.%s\", VAR_0->bin->prefix, VAR_26.methflag);\n\t\t\t\t\tr_name_filter (VAR_26.methflag, -1);\n\t\t\t\t\tfree (VAR_26.methflag);\n\t\t\t\t\tVAR_26.methflag = VAR_28;\n\t\t\t\t}\n\t\t\t\tif (VAR_27) {\n\t\t\t\t\tr_flag_item_set_realname (VAR_27, VAR_26.methname);\n\t\t\t\t\tif ((VAR_27->offset - VAR_0->flags->base) == VAR_24) {\n\t\t\t\t/* COMMENT_6 */\n\t\t\t\t\t\tr_flag_unset (VAR_0->flags, VAR_27);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tVAR_27 = r_flag_set (VAR_0->flags, VAR_26.methflag, VAR_24, VAR_10->size);\n\t\t\t\t\tchar *VAR_29 = VAR_27->comment ? strdup (VAR_27->comment) : NULL;\n\t\t\t\t\tif (VAR_29) {\n\t\t\t\t\t\tr_flag_item_set_comment (VAR_27, VAR_29);\n\t\t\t\t\t\tR_FREE (VAR_29);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst char *VAR_30 = VAR_26.demname ? VAR_26.demname : VAR_26.name;\n\t\t\t\tconst char *VAR_31 = VAR_26.demflag ? VAR_26.demflag : VAR_26.nameflag;\n\t\t\t\tchar *VAR_32 = (VAR_0->bin->prefix) ?\n\t\t\t\t\tr_str_newf (\"%s.%s\", VAR_0->bin->prefix, VAR_31):\n\t\t\t\t\tstrdup (VAR_31);\n\t\t\t\tRFlagItem *VAR_27 = r_flag_set (VAR_0->flags, VAR_32, VAR_24, VAR_10->size);\n\t\t\t\tif (VAR_27) {\n\t\t\t\t\tr_flag_item_set_realname (VAR_27, VAR_30);\n\t\t\t\t\tVAR_27->demangled = (bool)(size_t)VAR_26.demname;\n\t\t\t\t} else {\n\t\t\t\t\tif (VAR_31) {\n\t\t\t\t\t\teprintf (\"[Warning] Can't find flag (%s)\\n\", VAR_31);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree (VAR_32);\n\t\t\t}\n\t\t\tif (VAR_26.demname) {\n\t\t\t\tr_meta_add (VAR_0->anal, VAR_33,\n\t\t\t\t\tVAR_24, VAR_10->size, VAR_26.demname);\n\t\t\t}\n\t\t\tr_flag_space_pop (VAR_0->flags);\n\t\t} else if (IS_MODE_JSON (VAR_1)) {\n\t\t\tchar *VAR_34 = r_str_escape_utf8_for_json (VAR_23, -1);\n\t\t\t/* COMMENT_7 */\n\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"demname\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"flagname\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"ordinal\\\":%d,\"\n\t\t\t\t\"\\\"bind\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"size\\\":%d,\"\n\t\t\t\t\"\\\"type\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"vaddr\\\":%\"VAR_35\",\"\n\t\t\t\t\"\\\"paddr\\\":%\"VAR_35\"}\",\n\t\t\t\t((VAR_6 && VAR_13) || VAR_14) ? \"\" : (VAR_12->p ? \",\" : \"\"),\n\t\t\t\tVAR_34,\n\t\t\t\tVAR_26.demname? VAR_26.demname: \"\",\n\t\t\t\tVAR_26.nameflag,\n\t\t\t\tVAR_10->ordinal,\n\t\t\t\tVAR_10->bind,\n\t\t\t\t(int)VAR_10->size,\n\t\t\t\tVAR_10->type,\n\t\t\t\t(ut64)VAR_24, (ut64)VAR_10->paddr);\n\t\t\tfree (VAR_34);\n\t\t} else if (IS_MODE_SIMPLE (VAR_1)) {\n\t\t\tconst char *VAR_5 = VAR_26.demname? VAR_26.demname: VAR_23;\n\t\t\tr_cons_printf (\"0x%08\"VAR_36\" %d %s\\n\",\n\t\t\t\tVAR_24, (int)VAR_10->size, VAR_5);\n\t\t} else if (IS_MODE_SIMPLEST (VAR_1)) {\n\t\t\tconst char *VAR_5 = VAR_26.demname? VAR_26.demname: VAR_23;\n\t\t\tr_cons_printf (\"%s\\n\", VAR_5);\n\t\t} else if (IS_MODE_RAD (VAR_1)) {\n\t\t\t/* COMMENT_8 */\n                                                           \n\t\t\tif (!is_special_symbol (VAR_10)) {\n\t\t\t\tRBinFile *VAR_37;\n\t\t\t\tRBinPlugin *VAR_38;\n\t\t\t\tchar *VAR_5 = strdup (VAR_26.demname? VAR_26.demname: VAR_23);\n\t\t\t\tr_name_filter (VAR_5, -1);\n\t\t\t\tif (!strncmp (VAR_5, \"imp.\", 4)) {\n\t\t\t\t\tif (VAR_16 != 'i') {\n\t\t\t\t\t\tr_cons_printf (\"fs imports\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tVAR_16 = 'i';\n\t\t\t\t} else {\n\t\t\t\t\tif (VAR_16 != 's') {\n\t\t\t\t\t\tr_cons_printf (\"fs %s\\n\",\n\t\t\t\t\t\t\tVAR_6? \"exports\": \"symbols\");\n\t\t\t\t\t}\n\t\t\t\t\tVAR_16 = 's';\n\t\t\t\t}\n\t\t\t\tif (VAR_0->bin->prefix) {\n\t\t\t\t\tr_cons_printf (\"\\\"f %s.sym.%s %u 0x%08\" VAR_36 \"\\\"\\n\",\n\t\t\t\t\t\tVAR_0->bin->prefix, r_bin_symbol_name (VAR_10), VAR_10->size, VAR_24);\n\t\t\t\t} else {\n\t\t\t\t\tif (*VAR_5) {\n\t\t\t\t\t\tr_cons_printf (\"\\\"f sym.%s %u 0x%08\" VAR_36 \"\\\"\\n\",\n\t\t\t\t\t\t\tr_bin_symbol_name (VAR_10), VAR_10->size, VAR_24);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* COMMENT_10 */\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tVAR_37 = r_bin_cur (VAR_0->bin);\n\t\t\t\tVAR_38 = r_bin_file_cur_plugin (VAR_37);\n\t\t\t\tif (VAR_38 && VAR_38->name) {\n\t\t\t\t\tif (r_str_startswith (VAR_38->name, \"pe\")) {\n\t\t\t\t\t\tchar *VAR_39 = strdup (VAR_23);\n\t\t\t\t\t\tchar *VAR_40 = strstr (VAR_39, \".dll_\");\n\t\t\t\t\t\tif (VAR_40 && strstr (VAR_39, \"imp.\")) {\n\t\t\t\t\t\t\tconst char *VAR_41 = VAR_40 + 5;\n\t\t\t\t\t\t\t*VAR_40 = 0;\n\t\t\t\t\t\t\tif (VAR_0->bin->prefix) {\n\t\t\t\t\t\t\t\tr_cons_printf (\"k bin/pe/%s/%d=%s.%s\\n\",\n\t\t\t\t\t\t\t\t\tVAR_39, VAR_10->ordinal, VAR_0->bin->prefix, VAR_41);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tr_cons_printf (\"k bin/pe/%s/%d=%s\\n\",\n\t\t\t\t\t\t\t\t\tVAR_39, VAR_10->ordinal, VAR_41);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree (VAR_39);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tconst char *VAR_42 = VAR_10->bind? VAR_10->bind: \"NONE\";\n\t\t\tconst char *VAR_43 = VAR_10->type? VAR_10->type: \"NONE\";\n\t\t\tconst char *VAR_5 = r_str_get (VAR_26.demname? VAR_26.demname: VAR_23);\n\t\t\t/* COMMENT_11 */\n\t\t\tr_cons_printf (\"%03u\", VAR_10->ordinal);\n\t\t\tif (VAR_10->paddr == VAR_44) {\n\t\t\t\tr_cons_printf (\" ----------\");\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\" 0x%08\"VAR_36, VAR_10->paddr);\n\t\t\t}\n\t\t\tr_cons_printf (\" 0x%08\"VAR_36\" %6s %6s %4d%s%s\\n\",\n\t\t\t               VAR_24, VAR_42, VAR_43, VAR_10->size, *VAR_5? \" \": \"\", VAR_5);\n\t\t}\n\t\tsnFini (&VAR_26);\n\t\tVAR_15++;\n\t\tfree (VAR_23);\n\t\tif (VAR_6 && VAR_13) {\n\t\t\tVAR_13 = false;\n\t\t}\n\t\tif (VAR_14) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (VAR_22 == 0 && IS_MODE_JSON (VAR_1)) {\n\t\tr_cons_printf (\"{}\");\n\t}\n\n\n\t/* COMMENT_12 */\n\tif (VAR_18) {\n\t\tr_list_foreach (VAR_9, VAR_12, VAR_11) {\n\t\t\tif (IS_MODE_SET (VAR_1)) {\n\t\t\t\thandle_arm_entry (VAR_0, VAR_11, VAR_8, VAR_3);\n\t\t\t}\n\t\t}\n\t}\n\tif (IS_MODE_JSON (VAR_1) && !VAR_14) {\n\t\tr_cons_printf (\"]\");\n\t}\n\n\tr_spaces_pop (&VAR_0->anal->meta_spaces);\n\treturn true;\n}",
  "func_graph_path": "radareorg/radare2/f0c6dfa7a3eaad6a4a684ebfac0b2d282266adf9/cbin.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -184,11 +184,11 @@\n \t\t\t\t\tlastfs = 's';\n \t\t\t\t}\n \t\t\t\tif (r->bin->prefix) {\n-\t\t\t\t\tr_cons_printf (\"f %s.sym.%s %u 0x%08\" PFMT64x \"\\n\",\n+\t\t\t\t\tr_cons_printf (\"\\\"f %s.sym.%s %u 0x%08\" PFMT64x \"\\\"\\n\",\n \t\t\t\t\t\tr->bin->prefix, r_bin_symbol_name (symbol), symbol->size, addr);\n \t\t\t\t} else {\n \t\t\t\t\tif (*name) {\n-\t\t\t\t\t\tr_cons_printf (\"f sym.%s %u 0x%08\" PFMT64x \"\\n\",\n+\t\t\t\t\t\tr_cons_printf (\"\\\"f sym.%s %u 0x%08\" PFMT64x \"\\\"\\n\",\n \t\t\t\t\t\t\tr_bin_symbol_name (symbol), symbol->size, addr);\n \t\t\t\t\t} else {\n \t\t\t\t\t\t// we don't want unnamed symbol flags",
  "diff_line_info": {
    "deleted_lines": [
      "\t\t\t\t\tr_cons_printf (\"f %s.sym.%s %u 0x%08\" PFMT64x \"\\n\",",
      "\t\t\t\t\t\tr_cons_printf (\"f sym.%s %u 0x%08\" PFMT64x \"\\n\","
    ],
    "added_lines": [
      "\t\t\t\t\tr_cons_printf (\"\\\"f %s.sym.%s %u 0x%08\" PFMT64x \"\\\"\\n\",",
      "\t\t\t\t\t\tr_cons_printf (\"\\\"f sym.%s %u 0x%08\" PFMT64x \"\\\"\\n\","
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/radareorg/radare2/pull/14690",
  "description": {
    "pr_info": {
      "title": "bin_symbols: Add quoting",
      "number": 14690
    },
    "comment": [
      "Hello there. Since @blenk92  and me looked at potential issues for the PwnDebian challenge, we are proposing a fix regarding quoting for the `is` / `is*` commands.\r\n\r\nThis fixes the output, so that\r\n```\r\nf sym.imp.__sprintf_chk 16 0x00000000\r\n```\r\n\r\nbecomes\r\n\r\n```\r\n\"f sym.imp.__sprintf_chk 16 0x5562473eb000\"\r\n```\r\n\r\nwhen executing `is*`.\r\n\r\nGreetings"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.8  \n\n**Step-by-Step Explanation:**\n\n1. **Input Analysis:** The commit adds quotes to output strings in the bin_symbols function, addressing an output formatting issue for the `is`/`is*` commands.\n\n2. **Consistency Check:** The commit message and code changes align; both focus on adding quotes to output, ensuring consistency.\n\n3. **Purpose Evaluation:** The changes fix formatting, preventing potential misinterpretation but not directly addressing a core logic bug beyond output correction.\n\n4. **Security Assessment:** No explicit mention of security issues or CVEs; the fix seems to address a display defect rather than a security vulnerability.\n\n5. **Classification:** Non-security fix, categorized as Defect Remediation as it corrects an output formatting defect without altering core security mechanisms.\n\n6. **Confidence:** 0.8, due to the clear non-security focus with some ambiguity from the PwnDebian context, but predominantly a functional fix."
}