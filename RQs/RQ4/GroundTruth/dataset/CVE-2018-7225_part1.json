{
  "cve_id": "CVE-2018-7225",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "LibVNC/libvncserver",
  "commit_msg": "Limit client cut text length to 1 MB\n\nThis patch constrains a client cut text length to 1 MB. Otherwise\na client could make server allocate 2 GB of memory and that seems to\nbe to much to classify it as a denial of service.\n\nThe limit also prevents from an integer overflow followed by copying\nan uninitilized memory when processing msg.cct.length value larger\nthan SIZE_MAX or INT_MAX - sz_rfbClientCutTextMsg.\n\nThis patch also corrects accepting length value of zero (malloc(0) is\ninterpreted on differnet systems differently).\n\nCVE-2018-7225\n<https://github.com/LibVNC/libvncserver/issues/218>",
  "commit_hash": "28afb6c537dc82ba04d5f245b15ca7205c6dbb9c",
  "git_url": "https://github.com/LibVNC/libvncserver/commit/28afb6c537dc82ba04d5f245b15ca7205c6dbb9c",
  "file_path": "libvncserver/rfbserver.c",
  "func_name": "rfbProcessClientNormalMessage",
  "func_before": "static void\nrfbProcessClientNormalMessage(rfbClientPtr cl)\n{\n    int n=0;\n    rfbClientToServerMsg msg;\n    char *str;\n    int i;\n    uint32_t enc=0;\n    uint32_t lastPreferredEncoding = -1;\n    char encBuf[64];\n    char encBuf2[64];\n\n    if ((n = rfbReadExact(cl, (char *)&msg, 1)) <= 0) {\n        if (n != 0)\n            rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n        rfbCloseClient(cl);\n        return;\n    }\n\n    switch (msg.type) {\n\n    case rfbSetPixelFormat:\n\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                           sz_rfbSetPixelFormatMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n\n        cl->format.bitsPerPixel = msg.spf.format.bitsPerPixel;\n        cl->format.depth = msg.spf.format.depth;\n        cl->format.bigEndian = (msg.spf.format.bigEndian ? TRUE : FALSE);\n        cl->format.trueColour = (msg.spf.format.trueColour ? TRUE : FALSE);\n        cl->format.redMax = Swap16IfLE(msg.spf.format.redMax);\n        cl->format.greenMax = Swap16IfLE(msg.spf.format.greenMax);\n        cl->format.blueMax = Swap16IfLE(msg.spf.format.blueMax);\n        cl->format.redShift = msg.spf.format.redShift;\n        cl->format.greenShift = msg.spf.format.greenShift;\n        cl->format.blueShift = msg.spf.format.blueShift;\n\n\tcl->readyForSetColourMapEntries = TRUE;\n        cl->screen->setTranslateFunction(cl);\n\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetPixelFormatMsg, sz_rfbSetPixelFormatMsg);\n\n        return;\n\n\n    case rfbFixColourMapEntries:\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                           sz_rfbFixColourMapEntriesMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetPixelFormatMsg, sz_rfbSetPixelFormatMsg);\n        rfbLog(\"rfbProcessClientNormalMessage: %s\",\n                \"FixColourMapEntries unsupported\\n\");\n        rfbCloseClient(cl);\n        return;\n\n\n    /* NOTE: Some clients send us a set of encodings (ie: PointerPos) designed to enable/disable features...\n     * We may want to look into this...\n     * Example:\n     *     case rfbEncodingXCursor:\n     *         cl->enableCursorShapeUpdates = TRUE;\n     *\n     * Currently: cl->enableCursorShapeUpdates can *never* be turned off...\n     */\n    case rfbSetEncodings:\n    {\n\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                           sz_rfbSetEncodingsMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n\n        msg.se.nEncodings = Swap16IfLE(msg.se.nEncodings);\n\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetEncodingsMsg+(msg.se.nEncodings*4),sz_rfbSetEncodingsMsg+(msg.se.nEncodings*4));\n\n        /*\n         * UltraVNC Client has the ability to adapt to changing network environments\n         * So, let's give it a change to tell us what it wants now!\n         */\n        if (cl->preferredEncoding!=-1)\n            lastPreferredEncoding = cl->preferredEncoding;\n\n        /* Reset all flags to defaults (allows us to switch between PointerPos and Server Drawn Cursors) */\n        cl->preferredEncoding=-1;\n        cl->useCopyRect              = FALSE;\n        cl->useNewFBSize             = FALSE;\n        cl->cursorWasChanged         = FALSE;\n        cl->useRichCursorEncoding    = FALSE;\n        cl->enableCursorPosUpdates   = FALSE;\n        cl->enableCursorShapeUpdates = FALSE;\n        cl->enableCursorShapeUpdates = FALSE;\n        cl->enableLastRectEncoding   = FALSE;\n        cl->enableKeyboardLedState   = FALSE;\n        cl->enableSupportedMessages  = FALSE;\n        cl->enableSupportedEncodings = FALSE;\n        cl->enableServerIdentity     = FALSE;\n#if defined(LIBVNCSERVER_HAVE_LIBZ) || defined(LIBVNCSERVER_HAVE_LIBPNG)\n        cl->tightQualityLevel        = -1;\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n        cl->tightCompressLevel       = TIGHT_DEFAULT_COMPRESSION;\n        cl->turboSubsampLevel        = TURBO_DEFAULT_SUBSAMP;\n        cl->turboQualityLevel        = -1;\n#endif\n#endif\n\n\n        for (i = 0; i < msg.se.nEncodings; i++) {\n            if ((n = rfbReadExact(cl, (char *)&enc, 4)) <= 0) {\n                if (n != 0)\n                    rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n                rfbCloseClient(cl);\n                return;\n            }\n            enc = Swap32IfLE(enc);\n\n            switch (enc) {\n\n            case rfbEncodingCopyRect:\n\t\tcl->useCopyRect = TRUE;\n                break;\n            case rfbEncodingRaw:\n            case rfbEncodingRRE:\n            case rfbEncodingCoRRE:\n            case rfbEncodingHextile:\n            case rfbEncodingUltra:\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n\t    case rfbEncodingZlib:\n            case rfbEncodingZRLE:\n            case rfbEncodingZYWRLE:\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n\t    case rfbEncodingTight:\n#endif\n#endif\n#ifdef LIBVNCSERVER_HAVE_LIBPNG\n\t    case rfbEncodingTightPng:\n#endif\n            /* The first supported encoding is the 'preferred' encoding */\n                if (cl->preferredEncoding == -1)\n                    cl->preferredEncoding = enc;\n\n\n                break;\n\t    case rfbEncodingXCursor:\n\t\tif(!cl->screen->dontConvertRichCursorToXCursor) {\n\t\t    rfbLog(\"Enabling X-style cursor updates for client %s\\n\",\n\t\t\t   cl->host);\n\t\t    /* if cursor was drawn, hide the cursor */\n\t\t    if(!cl->enableCursorShapeUpdates)\n\t\t        rfbRedrawAfterHideCursor(cl,NULL);\n\n\t\t    cl->enableCursorShapeUpdates = TRUE;\n\t\t    cl->cursorWasChanged = TRUE;\n\t\t}\n\t\tbreak;\n\t    case rfbEncodingRichCursor:\n\t        rfbLog(\"Enabling full-color cursor updates for client %s\\n\",\n\t\t       cl->host);\n\t\t/* if cursor was drawn, hide the cursor */\n\t\tif(!cl->enableCursorShapeUpdates)\n\t\t    rfbRedrawAfterHideCursor(cl,NULL);\n\n\t        cl->enableCursorShapeUpdates = TRUE;\n\t        cl->useRichCursorEncoding = TRUE;\n\t        cl->cursorWasChanged = TRUE;\n\t        break;\n\t    case rfbEncodingPointerPos:\n\t\tif (!cl->enableCursorPosUpdates) {\n\t\t    rfbLog(\"Enabling cursor position updates for client %s\\n\",\n\t\t\t   cl->host);\n\t\t    cl->enableCursorPosUpdates = TRUE;\n\t\t    cl->cursorWasMoved = TRUE;\n\t\t}\n\t        break;\n\t    case rfbEncodingLastRect:\n\t\tif (!cl->enableLastRectEncoding) {\n\t\t    rfbLog(\"Enabling LastRect protocol extension for client \"\n\t\t\t   \"%s\\n\", cl->host);\n\t\t    cl->enableLastRectEncoding = TRUE;\n\t\t}\n\t\tbreak;\n\t    case rfbEncodingNewFBSize:\n\t\tif (!cl->useNewFBSize) {\n\t\t    rfbLog(\"Enabling NewFBSize protocol extension for client \"\n\t\t\t   \"%s\\n\", cl->host);\n\t\t    cl->useNewFBSize = TRUE;\n\t\t}\n\t\tbreak;\n            case rfbEncodingKeyboardLedState:\n                if (!cl->enableKeyboardLedState) {\n                  rfbLog(\"Enabling KeyboardLedState protocol extension for client \"\n                          \"%s\\n\", cl->host);\n                  cl->enableKeyboardLedState = TRUE;\n                }\n                break;           \n            case rfbEncodingSupportedMessages:\n                if (!cl->enableSupportedMessages) {\n                  rfbLog(\"Enabling SupportedMessages protocol extension for client \"\n                          \"%s\\n\", cl->host);\n                  cl->enableSupportedMessages = TRUE;\n                }\n                break;           \n            case rfbEncodingSupportedEncodings:\n                if (!cl->enableSupportedEncodings) {\n                  rfbLog(\"Enabling SupportedEncodings protocol extension for client \"\n                          \"%s\\n\", cl->host);\n                  cl->enableSupportedEncodings = TRUE;\n                }\n                break;           \n            case rfbEncodingServerIdentity:\n                if (!cl->enableServerIdentity) {\n                  rfbLog(\"Enabling ServerIdentity protocol extension for client \"\n                          \"%s\\n\", cl->host);\n                  cl->enableServerIdentity = TRUE;\n                }\n                break;\n            case rfbEncodingXvp:\n                if (cl->screen->xvpHook) {\n                  rfbLog(\"Enabling Xvp protocol extension for client \"\n                          \"%s\\n\", cl->host);\n                  if (!rfbSendXvp(cl, 1, rfbXvp_Init)) {\n                    rfbCloseClient(cl);\n                    return;\n                  }\n                }\n                break;\n            default:\n#if defined(LIBVNCSERVER_HAVE_LIBZ) || defined(LIBVNCSERVER_HAVE_LIBPNG)\n\t\tif ( enc >= (uint32_t)rfbEncodingCompressLevel0 &&\n\t\t     enc <= (uint32_t)rfbEncodingCompressLevel9 ) {\n\t\t    cl->zlibCompressLevel = enc & 0x0F;\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n\t\t    cl->tightCompressLevel = enc & 0x0F;\n\t\t    rfbLog(\"Using compression level %d for client %s\\n\",\n\t\t\t   cl->tightCompressLevel, cl->host);\n#endif\n\t\t} else if ( enc >= (uint32_t)rfbEncodingQualityLevel0 &&\n\t\t\t    enc <= (uint32_t)rfbEncodingQualityLevel9 ) {\n\t\t    cl->tightQualityLevel = enc & 0x0F;\n\t\t    rfbLog(\"Using image quality level %d for client %s\\n\",\n\t\t\t   cl->tightQualityLevel, cl->host);\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n\t\t    cl->turboQualityLevel = tight2turbo_qual[enc & 0x0F];\n\t\t    cl->turboSubsampLevel = tight2turbo_subsamp[enc & 0x0F];\n\t\t    rfbLog(\"Using JPEG subsampling %d, Q%d for client %s\\n\",\n\t\t\t   cl->turboSubsampLevel, cl->turboQualityLevel, cl->host);\n\t\t} else if ( enc >= (uint32_t)rfbEncodingFineQualityLevel0 + 1 &&\n\t\t\t    enc <= (uint32_t)rfbEncodingFineQualityLevel100 ) {\n\t\t    cl->turboQualityLevel = enc & 0xFF;\n\t\t    rfbLog(\"Using fine quality level %d for client %s\\n\",\n\t\t\t   cl->turboQualityLevel, cl->host);\n\t\t} else if ( enc >= (uint32_t)rfbEncodingSubsamp1X &&\n\t\t\t    enc <= (uint32_t)rfbEncodingSubsampGray ) {\n\t\t    cl->turboSubsampLevel = enc & 0xFF;\n\t\t    rfbLog(\"Using subsampling level %d for client %s\\n\",\n\t\t\t   cl->turboSubsampLevel, cl->host);\n#endif\n\t\t} else\n#endif\n\t\t{\n\t\t\trfbExtensionData* e;\n\t\t\tfor(e = cl->extensions; e;) {\n\t\t\t\trfbExtensionData* next = e->next;\n\t\t\t\tif(e->extension->enablePseudoEncoding &&\n\t\t\t\t\te->extension->enablePseudoEncoding(cl,\n\t\t\t\t\t\t&e->data, (int)enc))\n\t\t\t\t\t/* ext handles this encoding */\n\t\t\t\t\tbreak;\n\t\t\t\te = next;\n\t\t\t}\n\t\t\tif(e == NULL) {\n\t\t\t\trfbBool handled = FALSE;\n\t\t\t\t/* if the pseudo encoding is not handled by the\n\t\t\t\t   enabled extensions, search through all\n\t\t\t\t   extensions. */\n\t\t\t\trfbProtocolExtension* e;\n\n\t\t\t\tfor(e = rfbGetExtensionIterator(); e;) {\n\t\t\t\t\tint* encs = e->pseudoEncodings;\n\t\t\t\t\twhile(encs && *encs!=0) {\n\t\t\t\t\t\tif(*encs==(int)enc) {\n\t\t\t\t\t\t\tvoid* data = NULL;\n\t\t\t\t\t\t\tif(!e->enablePseudoEncoding(cl, &data, (int)enc)) {\n\t\t\t\t\t\t\t\trfbLog(\"Installed extension pretends to handle pseudo encoding 0x%x, but does not!\\n\",(int)enc);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\trfbEnableExtension(cl, e, data);\n\t\t\t\t\t\t\t\thandled = TRUE;\n\t\t\t\t\t\t\t\te = NULL;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tencs++;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(e)\n\t\t\t\t\t\te = e->next;\n\t\t\t\t}\n\t\t\t\trfbReleaseExtensionIterator();\n\n\t\t\t\tif(!handled)\n\t\t\t\t\trfbLog(\"rfbProcessClientNormalMessage: \"\n\t\t\t\t\t    \"ignoring unsupported encoding type %s\\n\",\n\t\t\t\t\t    encodingName(enc,encBuf,sizeof(encBuf)));\n\t\t\t}\n\t\t}\n            }\n        }\n\n\n\n        if (cl->preferredEncoding == -1) {\n            if (lastPreferredEncoding==-1) {\n                cl->preferredEncoding = rfbEncodingRaw;\n                rfbLog(\"Defaulting to %s encoding for client %s\\n\", encodingName(cl->preferredEncoding,encBuf,sizeof(encBuf)),cl->host);\n            }\n            else {\n                cl->preferredEncoding = lastPreferredEncoding;\n                rfbLog(\"Sticking with %s encoding for client %s\\n\", encodingName(cl->preferredEncoding,encBuf,sizeof(encBuf)),cl->host);\n            }\n        }\n        else\n        {\n          if (lastPreferredEncoding==-1) {\n              rfbLog(\"Using %s encoding for client %s\\n\", encodingName(cl->preferredEncoding,encBuf,sizeof(encBuf)),cl->host);\n          } else {\n              rfbLog(\"Switching from %s to %s Encoding for client %s\\n\", \n                  encodingName(lastPreferredEncoding,encBuf2,sizeof(encBuf2)),\n                  encodingName(cl->preferredEncoding,encBuf,sizeof(encBuf)), cl->host);\n          }\n        }\n        \n\tif (cl->enableCursorPosUpdates && !cl->enableCursorShapeUpdates) {\n\t  rfbLog(\"Disabling cursor position updates for client %s\\n\",\n\t\t cl->host);\n\t  cl->enableCursorPosUpdates = FALSE;\n\t}\n\n        return;\n    }\n\n\n    case rfbFramebufferUpdateRequest:\n    {\n        sraRegionPtr tmpRegion;\n\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                           sz_rfbFramebufferUpdateRequestMsg-1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbFramebufferUpdateRequestMsg,sz_rfbFramebufferUpdateRequestMsg);\n\n        /* The values come in based on the scaled screen, we need to convert them to\n         * values based on the main screen's coordinate system\n         */\n\tif(!rectSwapIfLEAndClip(&msg.fur.x,&msg.fur.y,&msg.fur.w,&msg.fur.h,cl))\n\t{\n\t        rfbLog(\"Warning, ignoring rfbFramebufferUpdateRequest: %dXx%dY-%dWx%dH\\n\",msg.fur.x, msg.fur.y, msg.fur.w, msg.fur.h);\n\t\treturn;\n        }\n \n        \n\ttmpRegion =\n\t  sraRgnCreateRect(msg.fur.x,\n\t\t\t   msg.fur.y,\n\t\t\t   msg.fur.x+msg.fur.w,\n\t\t\t   msg.fur.y+msg.fur.h);\n\n        LOCK(cl->updateMutex);\n\tsraRgnOr(cl->requestedRegion,tmpRegion);\n\n\tif (!cl->readyForSetColourMapEntries) {\n\t    /* client hasn't sent a SetPixelFormat so is using server's */\n\t    cl->readyForSetColourMapEntries = TRUE;\n\t    if (!cl->format.trueColour) {\n\t\tif (!rfbSetClientColourMap(cl, 0, 0)) {\n\t\t    sraRgnDestroy(tmpRegion);\n\t\t    TSIGNAL(cl->updateCond);\n\t\t    UNLOCK(cl->updateMutex);\n\t\t    return;\n\t\t}\n\t    }\n\t}\n\n       if (!msg.fur.incremental) {\n\t    sraRgnOr(cl->modifiedRegion,tmpRegion);\n\t    sraRgnSubtract(cl->copyRegion,tmpRegion);\n       }\n       TSIGNAL(cl->updateCond);\n       UNLOCK(cl->updateMutex);\n\n       sraRgnDestroy(tmpRegion);\n\n       return;\n    }\n\n    case rfbKeyEvent:\n\n\tif ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n\t\t\t   sz_rfbKeyEventMsg - 1)) <= 0) {\n\t    if (n != 0)\n\t\trfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n\n\trfbStatRecordMessageRcvd(cl, msg.type, sz_rfbKeyEventMsg, sz_rfbKeyEventMsg);\n\n\tif(!cl->viewOnly) {\n\t    cl->screen->kbdAddEvent(msg.ke.down, (rfbKeySym)Swap32IfLE(msg.ke.key), cl);\n\t}\n\n        return;\n\n\n    case rfbPointerEvent:\n\n\tif ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n\t\t\t   sz_rfbPointerEventMsg - 1)) <= 0) {\n\t    if (n != 0)\n\t\trfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n\n\trfbStatRecordMessageRcvd(cl, msg.type, sz_rfbPointerEventMsg, sz_rfbPointerEventMsg);\n\t\n\tif (cl->screen->pointerClient && cl->screen->pointerClient != cl)\n\t    return;\n\n\tif (msg.pe.buttonMask == 0)\n\t    cl->screen->pointerClient = NULL;\n\telse\n\t    cl->screen->pointerClient = cl;\n\n\tif(!cl->viewOnly) {\n\t    if (msg.pe.buttonMask != cl->lastPtrButtons ||\n\t\t    cl->screen->deferPtrUpdateTime == 0) {\n\t\tcl->screen->ptrAddEvent(msg.pe.buttonMask,\n\t\t\tScaleX(cl->scaledScreen, cl->screen, Swap16IfLE(msg.pe.x)), \n\t\t\tScaleY(cl->scaledScreen, cl->screen, Swap16IfLE(msg.pe.y)),\n\t\t\tcl);\n\t\tcl->lastPtrButtons = msg.pe.buttonMask;\n\t    } else {\n\t\tcl->lastPtrX = ScaleX(cl->scaledScreen, cl->screen, Swap16IfLE(msg.pe.x));\n\t\tcl->lastPtrY = ScaleY(cl->scaledScreen, cl->screen, Swap16IfLE(msg.pe.y));\n\t\tcl->lastPtrButtons = msg.pe.buttonMask;\n\t    }\n      }      \n      return;\n\n\n    case rfbFileTransfer:\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                              sz_rfbFileTransferMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n        msg.ft.size         = Swap32IfLE(msg.ft.size);\n        msg.ft.length       = Swap32IfLE(msg.ft.length);\n        /* record statistics in rfbProcessFileTransfer as length is filled with garbage when it is not valid */\n        rfbProcessFileTransfer(cl, msg.ft.contentType, msg.ft.contentParam, msg.ft.size, msg.ft.length);\n        return;\n\n    case rfbSetSW:\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                              sz_rfbSetSWMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n        msg.sw.x = Swap16IfLE(msg.sw.x);\n        msg.sw.y = Swap16IfLE(msg.sw.y);\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetSWMsg, sz_rfbSetSWMsg);\n        /* msg.sw.status is not initialized in the ultraVNC viewer and contains random numbers (why???) */\n\n        rfbLog(\"Received a rfbSetSingleWindow(%d x, %d y)\\n\", msg.sw.x, msg.sw.y);\n        if (cl->screen->setSingleWindow!=NULL)\n            cl->screen->setSingleWindow(cl, msg.sw.x, msg.sw.y);\n        return;\n\n    case rfbSetServerInput:\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                              sz_rfbSetServerInputMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetServerInputMsg, sz_rfbSetServerInputMsg);\n\n        /* msg.sim.pad is not initialized in the ultraVNC viewer and contains random numbers (why???) */\n        /* msg.sim.pad = Swap16IfLE(msg.sim.pad); */\n\n        rfbLog(\"Received a rfbSetServerInput(%d status)\\n\", msg.sim.status);\n        if (cl->screen->setServerInput!=NULL)\n            cl->screen->setServerInput(cl, msg.sim.status);\n        return;\n        \n    case rfbTextChat:\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                              sz_rfbTextChatMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n        \n        msg.tc.pad2   = Swap16IfLE(msg.tc.pad2);\n        msg.tc.length = Swap32IfLE(msg.tc.length);\n\n        switch (msg.tc.length) {\n        case rfbTextChatOpen:\n        case rfbTextChatClose:\n        case rfbTextChatFinished:\n            /* commands do not have text following */\n            /* Why couldn't they have used the pad byte??? */\n            str=NULL;\n            rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbTextChatMsg, sz_rfbTextChatMsg);\n            break;\n        default:\n            if ((msg.tc.length>0) && (msg.tc.length<rfbTextMaxSize))\n            {\n                str = (char *)malloc(msg.tc.length);\n                if (str==NULL)\n                {\n                    rfbLog(\"Unable to malloc %d bytes for a TextChat Message\\n\", msg.tc.length);\n                    rfbCloseClient(cl);\n                    return;\n                }\n                if ((n = rfbReadExact(cl, str, msg.tc.length)) <= 0) {\n                    if (n != 0)\n                        rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n                    free(str);\n                    rfbCloseClient(cl);\n                    return;\n                }\n                rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbTextChatMsg+msg.tc.length, sz_rfbTextChatMsg+msg.tc.length);\n            }\n            else\n            {\n                /* This should never happen */\n                rfbLog(\"client sent us a Text Message that is too big %d>%d\\n\", msg.tc.length, rfbTextMaxSize);\n                rfbCloseClient(cl);\n                return;\n            }\n        }\n\n        /* Note: length can be commands: rfbTextChatOpen, rfbTextChatClose, and rfbTextChatFinished\n         * at which point, the str is NULL (as it is not sent)\n         */\n        if (cl->screen->setTextChat!=NULL)\n            cl->screen->setTextChat(cl, msg.tc.length, str);\n\n        free(str);\n        return;\n\n\n    case rfbClientCutText:\n\n\tif ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n\t\t\t   sz_rfbClientCutTextMsg - 1)) <= 0) {\n\t    if (n != 0)\n\t\trfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n\n\tmsg.cct.length = Swap32IfLE(msg.cct.length);\n\n\tstr = (char *)malloc(msg.cct.length);\n\tif (str == NULL) {\n\t\trfbLogPerror(\"rfbProcessClientNormalMessage: not enough memory\");\n\t\trfbCloseClient(cl);\n\t\treturn;\n\t}\n\n\tif ((n = rfbReadExact(cl, str, msg.cct.length)) <= 0) {\n\t    if (n != 0)\n\t        rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n\t    free(str);\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n\trfbStatRecordMessageRcvd(cl, msg.type, sz_rfbClientCutTextMsg+msg.cct.length, sz_rfbClientCutTextMsg+msg.cct.length);\n\tif(!cl->viewOnly) {\n\t    cl->screen->setXCutText(str, msg.cct.length, cl);\n\t}\n\tfree(str);\n\n        return;\n\n    case rfbPalmVNCSetScaleFactor:\n      cl->PalmVNC = TRUE;\n      if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n          sz_rfbSetScaleMsg - 1)) <= 0) {\n          if (n != 0)\n            rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n          rfbCloseClient(cl);\n          return;\n      }\n\n      if (msg.ssc.scale == 0) {\n          rfbLogPerror(\"rfbProcessClientNormalMessage: will not accept a scale factor of zero\");\n          rfbCloseClient(cl);\n          return;\n      }\n\n      rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetScaleMsg, sz_rfbSetScaleMsg);\n      rfbLog(\"rfbSetScale(%d)\\n\", msg.ssc.scale);\n      rfbScalingSetup(cl,cl->screen->width/msg.ssc.scale, cl->screen->height/msg.ssc.scale);\n\n      rfbSendNewScaleSize(cl);\n      return;\n      \n    case rfbSetScale:\n\n      if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n          sz_rfbSetScaleMsg - 1)) <= 0) {\n          if (n != 0)\n            rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n          rfbCloseClient(cl);\n          return;\n      }\n\n      if (msg.ssc.scale == 0) {\n          rfbLogPerror(\"rfbProcessClientNormalMessage: will not accept a scale factor of zero\");\n          rfbCloseClient(cl);\n          return;\n      }\n\n      rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetScaleMsg, sz_rfbSetScaleMsg);\n      rfbLog(\"rfbSetScale(%d)\\n\", msg.ssc.scale);\n      rfbScalingSetup(cl,cl->screen->width/msg.ssc.scale, cl->screen->height/msg.ssc.scale);\n\n      rfbSendNewScaleSize(cl);\n      return;\n\n    case rfbXvp:\n\n      if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n          sz_rfbXvpMsg - 1)) <= 0) {\n          if (n != 0)\n            rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n          rfbCloseClient(cl);\n          return;\n      }\n      rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbXvpMsg, sz_rfbXvpMsg);\n\n      /* only version when is defined, so echo back a fail */\n      if(msg.xvp.version != 1) {\n\trfbSendXvp(cl, msg.xvp.version, rfbXvp_Fail);\n      }\n      else {\n\t/* if the hook exists and fails, send a fail msg */\n\tif(cl->screen->xvpHook && !cl->screen->xvpHook(cl, msg.xvp.version, msg.xvp.code))\n\t  rfbSendXvp(cl, 1, rfbXvp_Fail);\n      }\n      return;\n\n    default:\n\t{\n\t    rfbExtensionData *e,*next;\n\n\t    for(e=cl->extensions; e;) {\n\t\tnext = e->next;\n\t\tif(e->extension->handleMessage &&\n\t\t\te->extension->handleMessage(cl, e->data, &msg))\n                {\n                    rfbStatRecordMessageRcvd(cl, msg.type, 0, 0); /* Extension should handle this */\n\t\t    return;\n                }\n\t\te = next;\n\t    }\n\n\t    rfbLog(\"rfbProcessClientNormalMessage: unknown message type %d\\n\",\n\t\t    msg.type);\n\t    rfbLog(\" ... closing connection\\n\");\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n    }\n}",
  "abstract_func_before": "static void\nrfbProcessClientNormalMessage(rfbClientPtr VAR_0)\n{\n    int VAR_1=0;\n    rfbClientToServerMsg VAR_2;\n    char *VAR_3;\n    int VAR_4;\n    uint32_t VAR_5=0;\n    uint32_t VAR_6 = -1;\n    char VAR_7[64];\n    char VAR_8[64];\n\n    if ((VAR_1 = rfbReadExact(VAR_0, (char *)&VAR_2, 1)) <= 0) {\n        if (VAR_1 != 0)\n            rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n        rfbCloseClient(VAR_0);\n        return;\n    }\n\n    switch (VAR_2.type) {\n\n    case VAR_9:\n\n        if ((VAR_1 = rfbReadExact(VAR_0, ((char *)&VAR_2) + 1,\n                           VAR_10 - 1)) <= 0) {\n            if (VAR_1 != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(VAR_0);\n            return;\n        }\n\n        VAR_0->format.bitsPerPixel = VAR_2.spf.format.bitsPerPixel;\n        VAR_0->format.depth = VAR_2.spf.format.depth;\n        VAR_0->format.bigEndian = (VAR_2.spf.format.bigEndian ? TRUE : FALSE);\n        VAR_0->format.trueColour = (VAR_2.spf.format.trueColour ? TRUE : FALSE);\n        VAR_0->format.redMax = Swap16IfLE(VAR_2.spf.format.redMax);\n        VAR_0->format.greenMax = Swap16IfLE(VAR_2.spf.format.greenMax);\n        VAR_0->format.blueMax = Swap16IfLE(VAR_2.spf.format.blueMax);\n        VAR_0->format.redShift = VAR_2.spf.format.redShift;\n        VAR_0->format.greenShift = VAR_2.spf.format.greenShift;\n        VAR_0->format.blueShift = VAR_2.spf.format.blueShift;\n\n\tVAR_0->readyForSetColourMapEntries = TRUE;\n        VAR_0->screen->setTranslateFunction(VAR_0);\n\n        rfbStatRecordMessageRcvd(VAR_0, VAR_2.type, VAR_10, VAR_10);\n\n        return;\n\n\n    case VAR_11:\n        if ((VAR_1 = rfbReadExact(VAR_0, ((char *)&VAR_2) + 1,\n                           VAR_12 - 1)) <= 0) {\n            if (VAR_1 != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(VAR_0);\n            return;\n        }\n        rfbStatRecordMessageRcvd(VAR_0, VAR_2.type, VAR_10, VAR_10);\n        rfbLog(\"rfbProcessClientNormalMessage: %s\",\n                \"FixColourMapEntries unsupported\\n\");\n        rfbCloseClient(VAR_0);\n        return;\n\n\n    /* COMMENT_0 */\n                                       \n               \n                                   \n                                                   \n      \n                                                                           \n       \n    case VAR_13:\n    {\n\n        if ((VAR_1 = rfbReadExact(VAR_0, ((char *)&VAR_2) + 1,\n                           VAR_14 - 1)) <= 0) {\n            if (VAR_1 != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(VAR_0);\n            return;\n        }\n\n        VAR_2.se.nEncodings = Swap16IfLE(VAR_2.se.nEncodings);\n\n        rfbStatRecordMessageRcvd(VAR_0, VAR_2.type, VAR_14+(VAR_2.se.nEncodings*4),VAR_14+(VAR_2.se.nEncodings*4));\n\n        /* COMMENT_8 */\n                                                                                    \n                                                                   \n           \n        if (VAR_0->preferredEncoding!=-1)\n            VAR_6 = VAR_0->preferredEncoding;\n\n        /* COMMENT_12 */\n        VAR_0->preferredEncoding=-1;\n        VAR_0->useCopyRect              = FALSE;\n        VAR_0->useNewFBSize             = FALSE;\n        VAR_0->cursorWasChanged         = FALSE;\n        VAR_0->useRichCursorEncoding    = FALSE;\n        VAR_0->enableCursorPosUpdates   = FALSE;\n        VAR_0->enableCursorShapeUpdates = FALSE;\n        VAR_0->enableCursorShapeUpdates = FALSE;\n        VAR_0->enableLastRectEncoding   = FALSE;\n        VAR_0->enableKeyboardLedState   = FALSE;\n        VAR_0->enableSupportedMessages  = FALSE;\n        VAR_0->enableSupportedEncodings = FALSE;\n        VAR_0->enableServerIdentity     = FALSE;\n#if defined(VAR_15) || defined(VAR_16)\n        VAR_0->tightQualityLevel        = -1;\n#ifdef VAR_17\n        VAR_0->tightCompressLevel       = VAR_18;\n        VAR_0->turboSubsampLevel        = VAR_19;\n        VAR_0->turboQualityLevel        = -1;\n#endif\n#endif\n\n\n        for (VAR_4 = 0; VAR_4 < VAR_2.se.nEncodings; VAR_4++) {\n            if ((VAR_1 = rfbReadExact(VAR_0, (char *)&VAR_5, 4)) <= 0) {\n                if (VAR_1 != 0)\n                    rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n                rfbCloseClient(VAR_0);\n                return;\n            }\n            VAR_5 = Swap32IfLE(VAR_5);\n\n            switch (VAR_5) {\n\n            case VAR_20:\n\t\tVAR_0->useCopyRect = TRUE;\n                break;\n            case VAR_21:\n            case VAR_22:\n            case VAR_23:\n            case VAR_24:\n            case VAR_25:\n#ifdef VAR_15\n\t    case VAR_26:\n            case VAR_27:\n            case VAR_28:\n#ifdef VAR_17\n\t    case VAR_29:\n#endif\n#endif\n#ifdef VAR_16\n\t    case VAR_30:\n#endif\n            /* COMMENT_13 */\n                if (VAR_0->preferredEncoding == -1)\n                    VAR_0->preferredEncoding = VAR_5;\n\n\n                break;\n\t    case VAR_31:\n\t\tif(!VAR_0->screen->dontConvertRichCursorToXCursor) {\n\t\t    rfbLog(\"Enabling X-style cursor updates for client %s\\n\",\n\t\t\t   VAR_0->host);\n\t\t    /* COMMENT_14 */\n\t\t    if(!VAR_0->enableCursorShapeUpdates)\n\t\t        rfbRedrawAfterHideCursor(VAR_0,NULL);\n\n\t\t    VAR_0->enableCursorShapeUpdates = TRUE;\n\t\t    VAR_0->cursorWasChanged = TRUE;\n\t\t}\n\t\tbreak;\n\t    case VAR_32:\n\t        rfbLog(\"Enabling full-color cursor updates for client %s\\n\",\n\t\t       VAR_0->host);\n\t\t/* COMMENT_14 */\n\t\tif(!VAR_0->enableCursorShapeUpdates)\n\t\t    rfbRedrawAfterHideCursor(VAR_0,NULL);\n\n\t        VAR_0->enableCursorShapeUpdates = TRUE;\n\t        VAR_0->useRichCursorEncoding = TRUE;\n\t        VAR_0->cursorWasChanged = TRUE;\n\t        break;\n\t    case VAR_33:\n\t\tif (!VAR_0->enableCursorPosUpdates) {\n\t\t    rfbLog(\"Enabling cursor position updates for client %s\\n\",\n\t\t\t   VAR_0->host);\n\t\t    VAR_0->enableCursorPosUpdates = TRUE;\n\t\t    VAR_0->cursorWasMoved = TRUE;\n\t\t}\n\t        break;\n\t    case VAR_34:\n\t\tif (!VAR_0->enableLastRectEncoding) {\n\t\t    rfbLog(\"Enabling LastRect protocol extension for client \"\n\t\t\t   \"%s\\n\", VAR_0->host);\n\t\t    VAR_0->enableLastRectEncoding = TRUE;\n\t\t}\n\t\tbreak;\n\t    case VAR_35:\n\t\tif (!VAR_0->useNewFBSize) {\n\t\t    rfbLog(\"Enabling NewFBSize protocol extension for client \"\n\t\t\t   \"%s\\n\", VAR_0->host);\n\t\t    VAR_0->useNewFBSize = TRUE;\n\t\t}\n\t\tbreak;\n            case VAR_36:\n                if (!VAR_0->enableKeyboardLedState) {\n                  rfbLog(\"Enabling KeyboardLedState protocol extension for client \"\n                          \"%s\\n\", VAR_0->host);\n                  VAR_0->enableKeyboardLedState = TRUE;\n                }\n                break;           \n            case VAR_37:\n                if (!VAR_0->enableSupportedMessages) {\n                  rfbLog(\"Enabling SupportedMessages protocol extension for client \"\n                          \"%s\\n\", VAR_0->host);\n                  VAR_0->enableSupportedMessages = TRUE;\n                }\n                break;           \n            case VAR_38:\n                if (!VAR_0->enableSupportedEncodings) {\n                  rfbLog(\"Enabling SupportedEncodings protocol extension for client \"\n                          \"%s\\n\", VAR_0->host);\n                  VAR_0->enableSupportedEncodings = TRUE;\n                }\n                break;           \n            case VAR_39:\n                if (!VAR_0->enableServerIdentity) {\n                  rfbLog(\"Enabling ServerIdentity protocol extension for client \"\n                          \"%s\\n\", VAR_0->host);\n                  VAR_0->enableServerIdentity = TRUE;\n                }\n                break;\n            case VAR_40:\n                if (VAR_0->screen->xvpHook) {\n                  rfbLog(\"Enabling Xvp protocol extension for client \"\n                          \"%s\\n\", VAR_0->host);\n                  if (!rfbSendXvp(VAR_0, 1, VAR_41)) {\n                    rfbCloseClient(VAR_0);\n                    return;\n                  }\n                }\n                break;\n            default:\n#if defined(VAR_15) || defined(VAR_16)\n\t\tif ( VAR_5 >= (uint32_t)VAR_42 &&\n\t\t     VAR_5 <= (uint32_t)VAR_43 ) {\n\t\t    VAR_0->zlibCompressLevel = VAR_5 & 0x0F;\n#ifdef VAR_17\n\t\t    VAR_0->tightCompressLevel = VAR_5 & 0x0F;\n\t\t    rfbLog(\"Using compression level %d for client %s\\n\",\n\t\t\t   VAR_0->tightCompressLevel, VAR_0->host);\n#endif\n\t\t} else if ( VAR_5 >= (uint32_t)VAR_44 &&\n\t\t\t    VAR_5 <= (uint32_t)VAR_45 ) {\n\t\t    VAR_0->tightQualityLevel = VAR_5 & 0x0F;\n\t\t    rfbLog(\"Using image quality level %d for client %s\\n\",\n\t\t\t   VAR_0->tightQualityLevel, VAR_0->host);\n#ifdef VAR_17\n\t\t    VAR_0->turboQualityLevel = VAR_46[VAR_5 & 0x0F];\n\t\t    VAR_0->turboSubsampLevel = VAR_47[VAR_5 & 0x0F];\n\t\t    rfbLog(\"Using JPEG subsampling %d, Q%d for client %s\\n\",\n\t\t\t   VAR_0->turboSubsampLevel, VAR_0->turboQualityLevel, VAR_0->host);\n\t\t} else if ( VAR_5 >= (uint32_t)VAR_48 + 1 &&\n\t\t\t    VAR_5 <= (uint32_t)VAR_49 ) {\n\t\t    VAR_0->turboQualityLevel = VAR_5 & 0xFF;\n\t\t    rfbLog(\"Using fine quality level %d for client %s\\n\",\n\t\t\t   VAR_0->turboQualityLevel, VAR_0->host);\n\t\t} else if ( VAR_5 >= (uint32_t)VAR_50 &&\n\t\t\t    VAR_5 <= (uint32_t)VAR_51 ) {\n\t\t    VAR_0->turboSubsampLevel = VAR_5 & 0xFF;\n\t\t    rfbLog(\"Using subsampling level %d for client %s\\n\",\n\t\t\t   VAR_0->turboSubsampLevel, VAR_0->host);\n#endif\n\t\t} else\n#endif\n\t\t{\n\t\t\trfbExtensionData* VAR_52;\n\t\t\tfor(VAR_52 = VAR_0->extensions; VAR_52;) {\n\t\t\t\trfbExtensionData* VAR_53 = VAR_52->next;\n\t\t\t\tif(VAR_52->extension->enablePseudoEncoding &&\n\t\t\t\t\tVAR_52->extension->enablePseudoEncoding(VAR_0,\n\t\t\t\t\t\t&VAR_52->data, (int)VAR_5))\n\t\t\t\t\t/* COMMENT_15 */\n\t\t\t\t\tbreak;\n\t\t\t\tVAR_52 = VAR_53;\n\t\t\t}\n\t\t\tif(VAR_52 == NULL) {\n\t\t\t\trfbBool VAR_54 = FALSE;\n\t\t\t\t/* COMMENT_16 */\n                                             \n                     \n\t\t\t\trfbProtocolExtension* VAR_52;\n\n\t\t\t\tfor(VAR_52 = rfbGetExtensionIterator(); VAR_52;) {\n\t\t\t\t\tint* VAR_55 = VAR_52->pseudoEncodings;\n\t\t\t\t\twhile(VAR_55 && *VAR_55!=0) {\n\t\t\t\t\t\tif(*VAR_55==(int)VAR_5) {\n\t\t\t\t\t\t\tvoid* VAR_56 = NULL;\n\t\t\t\t\t\t\tif(!VAR_52->enablePseudoEncoding(VAR_0, &VAR_56, (int)VAR_5)) {\n\t\t\t\t\t\t\t\trfbLog(\"Installed extension pretends to handle pseudo encoding 0x%x, but does not!\\n\",(int)VAR_5);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\trfbEnableExtension(VAR_0, VAR_52, VAR_56);\n\t\t\t\t\t\t\t\tVAR_54 = TRUE;\n\t\t\t\t\t\t\t\tVAR_52 = NULL;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tVAR_55++;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(VAR_52)\n\t\t\t\t\t\tVAR_52 = VAR_52->next;\n\t\t\t\t}\n\t\t\t\trfbReleaseExtensionIterator();\n\n\t\t\t\tif(!VAR_54)\n\t\t\t\t\trfbLog(\"rfbProcessClientNormalMessage: \"\n\t\t\t\t\t    \"ignoring unsupported encoding type %s\\n\",\n\t\t\t\t\t    encodingName(VAR_5,VAR_7,sizeof(VAR_7)));\n\t\t\t}\n\t\t}\n            }\n        }\n\n\n\n        if (VAR_0->preferredEncoding == -1) {\n            if (VAR_6==-1) {\n                VAR_0->preferredEncoding = VAR_21;\n                rfbLog(\"Defaulting to %s encoding for client %s\\n\", encodingName(VAR_0->preferredEncoding,VAR_7,sizeof(VAR_7)),VAR_0->host);\n            }\n            else {\n                VAR_0->preferredEncoding = VAR_6;\n                rfbLog(\"Sticking with %s encoding for client %s\\n\", encodingName(VAR_0->preferredEncoding,VAR_7,sizeof(VAR_7)),VAR_0->host);\n            }\n        }\n        else\n        {\n          if (VAR_6==-1) {\n              rfbLog(\"Using %s encoding for client %s\\n\", encodingName(VAR_0->preferredEncoding,VAR_7,sizeof(VAR_7)),VAR_0->host);\n          } else {\n              rfbLog(\"Switching from %s to %s Encoding for client %s\\n\", \n                  encodingName(VAR_6,VAR_8,sizeof(VAR_8)),\n                  encodingName(VAR_0->preferredEncoding,VAR_7,sizeof(VAR_7)), VAR_0->host);\n          }\n        }\n        \n\tif (VAR_0->enableCursorPosUpdates && !VAR_0->enableCursorShapeUpdates) {\n\t  rfbLog(\"Disabling cursor position updates for client %s\\n\",\n\t\t VAR_0->host);\n\t  VAR_0->enableCursorPosUpdates = FALSE;\n\t}\n\n        return;\n    }\n\n\n    case VAR_57:\n    {\n        sraRegionPtr VAR_58;\n\n        if ((VAR_1 = rfbReadExact(VAR_0, ((char *)&VAR_2) + 1,\n                           VAR_59-1)) <= 0) {\n            if (VAR_1 != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(VAR_0);\n            return;\n        }\n\n        rfbStatRecordMessageRcvd(VAR_0, VAR_2.type, VAR_59,VAR_59);\n\n        /* COMMENT_19 */\n                                                              \n           \n\tif(!rectSwapIfLEAndClip(&VAR_2.fur.x,&VAR_2.fur.y,&VAR_2.fur.w,&VAR_2.fur.h,VAR_0))\n\t{\n\t        rfbLog(\"Warning, ignoring rfbFramebufferUpdateRequest: %dXx%dY-%dWx%dH\\n\",VAR_2.fur.x, VAR_2.fur.y, VAR_2.fur.w, VAR_2.fur.h);\n\t\treturn;\n        }\n \n        \n\tVAR_58 =\n\t  sraRgnCreateRect(VAR_2.fur.x,\n\t\t\t   VAR_2.fur.y,\n\t\t\t   VAR_2.fur.x+VAR_2.fur.w,\n\t\t\t   VAR_2.fur.y+VAR_2.fur.h);\n\n        LOCK(VAR_0->updateMutex);\n\tsraRgnOr(VAR_0->requestedRegion,VAR_58);\n\n\tif (!VAR_0->readyForSetColourMapEntries) {\n\t    /* COMMENT_22 */\n\t    VAR_0->readyForSetColourMapEntries = TRUE;\n\t    if (!VAR_0->format.trueColour) {\n\t\tif (!rfbSetClientColourMap(VAR_0, 0, 0)) {\n\t\t    sraRgnDestroy(VAR_58);\n\t\t    TSIGNAL(VAR_0->updateCond);\n\t\t    UNLOCK(VAR_0->updateMutex);\n\t\t    return;\n\t\t}\n\t    }\n\t}\n\n       if (!VAR_2.fur.incremental) {\n\t    sraRgnOr(VAR_0->modifiedRegion,VAR_58);\n\t    sraRgnSubtract(VAR_0->copyRegion,VAR_58);\n       }\n       TSIGNAL(VAR_0->updateCond);\n       UNLOCK(VAR_0->updateMutex);\n\n       sraRgnDestroy(VAR_58);\n\n       return;\n    }\n\n    case VAR_60:\n\n\tif ((VAR_1 = rfbReadExact(VAR_0, ((char *)&VAR_2) + 1,\n\t\t\t   VAR_61 - 1)) <= 0) {\n\t    if (VAR_1 != 0)\n\t\trfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n\t    rfbCloseClient(VAR_0);\n\t    return;\n\t}\n\n\trfbStatRecordMessageRcvd(VAR_0, VAR_2.type, VAR_61, VAR_61);\n\n\tif(!VAR_0->viewOnly) {\n\t    VAR_0->screen->kbdAddEvent(VAR_2.ke.down, (rfbKeySym)Swap32IfLE(VAR_2.ke.key), VAR_0);\n\t}\n\n        return;\n\n\n    case VAR_62:\n\n\tif ((VAR_1 = rfbReadExact(VAR_0, ((char *)&VAR_2) + 1,\n\t\t\t   VAR_63 - 1)) <= 0) {\n\t    if (VAR_1 != 0)\n\t\trfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n\t    rfbCloseClient(VAR_0);\n\t    return;\n\t}\n\n\trfbStatRecordMessageRcvd(VAR_0, VAR_2.type, VAR_63, VAR_63);\n\t\n\tif (VAR_0->screen->pointerClient && VAR_0->screen->pointerClient != VAR_0)\n\t    return;\n\n\tif (VAR_2.pe.buttonMask == 0)\n\t    VAR_0->screen->pointerClient = NULL;\n\telse\n\t    VAR_0->screen->pointerClient = VAR_0;\n\n\tif(!VAR_0->viewOnly) {\n\t    if (VAR_2.pe.buttonMask != VAR_0->lastPtrButtons ||\n\t\t    VAR_0->screen->deferPtrUpdateTime == 0) {\n\t\tVAR_0->screen->ptrAddEvent(VAR_2.pe.buttonMask,\n\t\t\tScaleX(VAR_0->scaledScreen, VAR_0->screen, Swap16IfLE(VAR_2.pe.x)), \n\t\t\tScaleY(VAR_0->scaledScreen, VAR_0->screen, Swap16IfLE(VAR_2.pe.y)),\n\t\t\tVAR_0);\n\t\tVAR_0->lastPtrButtons = VAR_2.pe.buttonMask;\n\t    } else {\n\t\tVAR_0->lastPtrX = ScaleX(VAR_0->scaledScreen, VAR_0->screen, Swap16IfLE(VAR_2.pe.x));\n\t\tVAR_0->lastPtrY = ScaleY(VAR_0->scaledScreen, VAR_0->screen, Swap16IfLE(VAR_2.pe.y));\n\t\tVAR_0->lastPtrButtons = VAR_2.pe.buttonMask;\n\t    }\n      }      \n      return;\n\n\n    case VAR_64:\n        if ((VAR_1 = rfbReadExact(VAR_0, ((char *)&VAR_2) + 1,\n                              VAR_65 - 1)) <= 0) {\n            if (VAR_1 != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(VAR_0);\n            return;\n        }\n        VAR_2.ft.size         = Swap32IfLE(VAR_2.ft.size);\n        VAR_2.ft.length       = Swap32IfLE(VAR_2.ft.length);\n        /* COMMENT_23 */\n        rfbProcessFileTransfer(VAR_0, VAR_2.ft.contentType, VAR_2.ft.contentParam, VAR_2.ft.size, VAR_2.ft.length);\n        return;\n\n    case VAR_66:\n        if ((VAR_1 = rfbReadExact(VAR_0, ((char *)&VAR_2) + 1,\n                              VAR_67 - 1)) <= 0) {\n            if (VAR_1 != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(VAR_0);\n            return;\n        }\n        VAR_2.sw.x = Swap16IfLE(VAR_2.sw.x);\n        VAR_2.sw.y = Swap16IfLE(VAR_2.sw.y);\n        rfbStatRecordMessageRcvd(VAR_0, VAR_2.type, VAR_67, VAR_67);\n        /* COMMENT_24 */\n\n        rfbLog(\"Received a rfbSetSingleWindow(%d x, %d y)\\n\", VAR_2.sw.x, VAR_2.sw.y);\n        if (VAR_0->screen->setSingleWindow!=NULL)\n            VAR_0->screen->setSingleWindow(VAR_0, VAR_2.sw.x, VAR_2.sw.y);\n        return;\n\n    case VAR_68:\n        if ((VAR_1 = rfbReadExact(VAR_0, ((char *)&VAR_2) + 1,\n                              VAR_69 - 1)) <= 0) {\n            if (VAR_1 != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(VAR_0);\n            return;\n        }\n        rfbStatRecordMessageRcvd(VAR_0, VAR_2.type, VAR_69, VAR_69);\n\n        /* COMMENT_25 */\n        /* COMMENT_26 */\n\n        rfbLog(\"Received a rfbSetServerInput(%d status)\\n\", VAR_2.sim.status);\n        if (VAR_0->screen->setServerInput!=NULL)\n            VAR_0->screen->setServerInput(VAR_0, VAR_2.sim.status);\n        return;\n        \n    case VAR_70:\n        if ((VAR_1 = rfbReadExact(VAR_0, ((char *)&VAR_2) + 1,\n                              VAR_71 - 1)) <= 0) {\n            if (VAR_1 != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(VAR_0);\n            return;\n        }\n        \n        VAR_2.tc.pad2   = Swap16IfLE(VAR_2.tc.pad2);\n        VAR_2.tc.length = Swap32IfLE(VAR_2.tc.length);\n\n        switch (VAR_2.tc.length) {\n        case VAR_72:\n        case VAR_73:\n        case VAR_74:\n            /* COMMENT_27 */\n            /* COMMENT_28 */\n            VAR_3=NULL;\n            rfbStatRecordMessageRcvd(VAR_0, VAR_2.type, VAR_71, VAR_71);\n            break;\n        default:\n            if ((VAR_2.tc.length>0) && (VAR_2.tc.length<VAR_75))\n            {\n                VAR_3 = (char *)malloc(VAR_2.tc.length);\n                if (VAR_3==NULL)\n                {\n                    rfbLog(\"Unable to malloc %d bytes for a TextChat Message\\n\", VAR_2.tc.length);\n                    rfbCloseClient(VAR_0);\n                    return;\n                }\n                if ((VAR_1 = rfbReadExact(VAR_0, VAR_3, VAR_2.tc.length)) <= 0) {\n                    if (VAR_1 != 0)\n                        rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n                    free(VAR_3);\n                    rfbCloseClient(VAR_0);\n                    return;\n                }\n                rfbStatRecordMessageRcvd(VAR_0, VAR_2.type, VAR_71+VAR_2.tc.length, VAR_71+VAR_2.tc.length);\n            }\n            else\n            {\n                /* COMMENT_29 */\n                rfbLog(\"client sent us a Text Message that is too big %d>%d\\n\", VAR_2.tc.length, VAR_75);\n                rfbCloseClient(VAR_0);\n                return;\n            }\n        }\n\n        /* COMMENT_30 */\n                                                              \n           \n        if (VAR_0->screen->setTextChat!=NULL)\n            VAR_0->screen->setTextChat(VAR_0, VAR_2.tc.length, VAR_3);\n\n        free(VAR_3);\n        return;\n\n\n    case VAR_76:\n\n\tif ((VAR_1 = rfbReadExact(VAR_0, ((char *)&VAR_2) + 1,\n\t\t\t   VAR_77 - 1)) <= 0) {\n\t    if (VAR_1 != 0)\n\t\trfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n\t    rfbCloseClient(VAR_0);\n\t    return;\n\t}\n\n\tVAR_2.cct.length = Swap32IfLE(VAR_2.cct.length);\n\n\tVAR_3 = (char *)malloc(VAR_2.cct.length);\n\tif (VAR_3 == NULL) {\n\t\trfbLogPerror(\"rfbProcessClientNormalMessage: not enough memory\");\n\t\trfbCloseClient(VAR_0);\n\t\treturn;\n\t}\n\n\tif ((VAR_1 = rfbReadExact(VAR_0, VAR_3, VAR_2.cct.length)) <= 0) {\n\t    if (VAR_1 != 0)\n\t        rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n\t    free(VAR_3);\n\t    rfbCloseClient(VAR_0);\n\t    return;\n\t}\n\trfbStatRecordMessageRcvd(VAR_0, VAR_2.type, VAR_77+VAR_2.cct.length, VAR_77+VAR_2.cct.length);\n\tif(!VAR_0->viewOnly) {\n\t    VAR_0->screen->setXCutText(VAR_3, VAR_2.cct.length, VAR_0);\n\t}\n\tfree(VAR_3);\n\n        return;\n\n    case VAR_78:\n      VAR_0->PalmVNC = TRUE;\n      if ((VAR_1 = rfbReadExact(VAR_0, ((char *)&VAR_2) + 1,\n          VAR_79 - 1)) <= 0) {\n          if (VAR_1 != 0)\n            rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n          rfbCloseClient(VAR_0);\n          return;\n      }\n\n      if (VAR_2.ssc.scale == 0) {\n          rfbLogPerror(\"rfbProcessClientNormalMessage: will not accept a scale factor of zero\");\n          rfbCloseClient(VAR_0);\n          return;\n      }\n\n      rfbStatRecordMessageRcvd(VAR_0, VAR_2.type, VAR_79, VAR_79);\n      rfbLog(\"rfbSetScale(%d)\\n\", VAR_2.ssc.scale);\n      rfbScalingSetup(VAR_0,VAR_0->screen->width/VAR_2.ssc.scale, VAR_0->screen->height/VAR_2.ssc.scale);\n\n      rfbSendNewScaleSize(VAR_0);\n      return;\n      \n    case VAR_80:\n\n      if ((VAR_1 = rfbReadExact(VAR_0, ((char *)&VAR_2) + 1,\n          VAR_79 - 1)) <= 0) {\n          if (VAR_1 != 0)\n            rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n          rfbCloseClient(VAR_0);\n          return;\n      }\n\n      if (VAR_2.ssc.scale == 0) {\n          rfbLogPerror(\"rfbProcessClientNormalMessage: will not accept a scale factor of zero\");\n          rfbCloseClient(VAR_0);\n          return;\n      }\n\n      rfbStatRecordMessageRcvd(VAR_0, VAR_2.type, VAR_79, VAR_79);\n      rfbLog(\"rfbSetScale(%d)\\n\", VAR_2.ssc.scale);\n      rfbScalingSetup(VAR_0,VAR_0->screen->width/VAR_2.ssc.scale, VAR_0->screen->height/VAR_2.ssc.scale);\n\n      rfbSendNewScaleSize(VAR_0);\n      return;\n\n    case VAR_81:\n\n      if ((VAR_1 = rfbReadExact(VAR_0, ((char *)&VAR_2) + 1,\n          VAR_82 - 1)) <= 0) {\n          if (VAR_1 != 0)\n            rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n          rfbCloseClient(VAR_0);\n          return;\n      }\n      rfbStatRecordMessageRcvd(VAR_0, VAR_2.type, VAR_82, VAR_82);\n\n      /* COMMENT_33 */\n      if(VAR_2.xvp.version != 1) {\n\trfbSendXvp(VAR_0, VAR_2.xvp.version, VAR_83);\n      }\n      else {\n\t/* COMMENT_34 */\n\tif(VAR_0->screen->xvpHook && !VAR_0->screen->xvpHook(VAR_0, VAR_2.xvp.version, VAR_2.xvp.code))\n\t  rfbSendXvp(VAR_0, 1, VAR_83);\n      }\n      return;\n\n    default:\n\t{\n\t    rfbExtensionData *VAR_52,*VAR_53;\n\n\t    for(VAR_52=VAR_0->extensions; VAR_52;) {\n\t\tVAR_53 = VAR_52->next;\n\t\tif(VAR_52->extension->handleMessage &&\n\t\t\tVAR_52->extension->handleMessage(VAR_0, VAR_52->data, &VAR_2))\n                {\n                    rfbStatRecordMessageRcvd(VAR_0, VAR_2.type, 0, 0); /* COMMENT_35 */\n\t\t    return;\n                }\n\t\tVAR_52 = VAR_53;\n\t    }\n\n\t    rfbLog(\"rfbProcessClientNormalMessage: unknown message type %d\\n\",\n\t\t    VAR_2.type);\n\t    rfbLog(\" ... closing connection\\n\");\n\t    rfbCloseClient(VAR_0);\n\t    return;\n\t}\n    }\n}",
  "func_graph_path_before": "LibVNC/libvncserver/28afb6c537dc82ba04d5f245b15ca7205c6dbb9c/rfbserver.c/vul/before/0.json",
  "func": "static void\nrfbProcessClientNormalMessage(rfbClientPtr cl)\n{\n    int n=0;\n    rfbClientToServerMsg msg;\n    char *str;\n    int i;\n    uint32_t enc=0;\n    uint32_t lastPreferredEncoding = -1;\n    char encBuf[64];\n    char encBuf2[64];\n\n    if ((n = rfbReadExact(cl, (char *)&msg, 1)) <= 0) {\n        if (n != 0)\n            rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n        rfbCloseClient(cl);\n        return;\n    }\n\n    switch (msg.type) {\n\n    case rfbSetPixelFormat:\n\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                           sz_rfbSetPixelFormatMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n\n        cl->format.bitsPerPixel = msg.spf.format.bitsPerPixel;\n        cl->format.depth = msg.spf.format.depth;\n        cl->format.bigEndian = (msg.spf.format.bigEndian ? TRUE : FALSE);\n        cl->format.trueColour = (msg.spf.format.trueColour ? TRUE : FALSE);\n        cl->format.redMax = Swap16IfLE(msg.spf.format.redMax);\n        cl->format.greenMax = Swap16IfLE(msg.spf.format.greenMax);\n        cl->format.blueMax = Swap16IfLE(msg.spf.format.blueMax);\n        cl->format.redShift = msg.spf.format.redShift;\n        cl->format.greenShift = msg.spf.format.greenShift;\n        cl->format.blueShift = msg.spf.format.blueShift;\n\n\tcl->readyForSetColourMapEntries = TRUE;\n        cl->screen->setTranslateFunction(cl);\n\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetPixelFormatMsg, sz_rfbSetPixelFormatMsg);\n\n        return;\n\n\n    case rfbFixColourMapEntries:\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                           sz_rfbFixColourMapEntriesMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetPixelFormatMsg, sz_rfbSetPixelFormatMsg);\n        rfbLog(\"rfbProcessClientNormalMessage: %s\",\n                \"FixColourMapEntries unsupported\\n\");\n        rfbCloseClient(cl);\n        return;\n\n\n    /* NOTE: Some clients send us a set of encodings (ie: PointerPos) designed to enable/disable features...\n     * We may want to look into this...\n     * Example:\n     *     case rfbEncodingXCursor:\n     *         cl->enableCursorShapeUpdates = TRUE;\n     *\n     * Currently: cl->enableCursorShapeUpdates can *never* be turned off...\n     */\n    case rfbSetEncodings:\n    {\n\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                           sz_rfbSetEncodingsMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n\n        msg.se.nEncodings = Swap16IfLE(msg.se.nEncodings);\n\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetEncodingsMsg+(msg.se.nEncodings*4),sz_rfbSetEncodingsMsg+(msg.se.nEncodings*4));\n\n        /*\n         * UltraVNC Client has the ability to adapt to changing network environments\n         * So, let's give it a change to tell us what it wants now!\n         */\n        if (cl->preferredEncoding!=-1)\n            lastPreferredEncoding = cl->preferredEncoding;\n\n        /* Reset all flags to defaults (allows us to switch between PointerPos and Server Drawn Cursors) */\n        cl->preferredEncoding=-1;\n        cl->useCopyRect              = FALSE;\n        cl->useNewFBSize             = FALSE;\n        cl->cursorWasChanged         = FALSE;\n        cl->useRichCursorEncoding    = FALSE;\n        cl->enableCursorPosUpdates   = FALSE;\n        cl->enableCursorShapeUpdates = FALSE;\n        cl->enableCursorShapeUpdates = FALSE;\n        cl->enableLastRectEncoding   = FALSE;\n        cl->enableKeyboardLedState   = FALSE;\n        cl->enableSupportedMessages  = FALSE;\n        cl->enableSupportedEncodings = FALSE;\n        cl->enableServerIdentity     = FALSE;\n#if defined(LIBVNCSERVER_HAVE_LIBZ) || defined(LIBVNCSERVER_HAVE_LIBPNG)\n        cl->tightQualityLevel        = -1;\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n        cl->tightCompressLevel       = TIGHT_DEFAULT_COMPRESSION;\n        cl->turboSubsampLevel        = TURBO_DEFAULT_SUBSAMP;\n        cl->turboQualityLevel        = -1;\n#endif\n#endif\n\n\n        for (i = 0; i < msg.se.nEncodings; i++) {\n            if ((n = rfbReadExact(cl, (char *)&enc, 4)) <= 0) {\n                if (n != 0)\n                    rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n                rfbCloseClient(cl);\n                return;\n            }\n            enc = Swap32IfLE(enc);\n\n            switch (enc) {\n\n            case rfbEncodingCopyRect:\n\t\tcl->useCopyRect = TRUE;\n                break;\n            case rfbEncodingRaw:\n            case rfbEncodingRRE:\n            case rfbEncodingCoRRE:\n            case rfbEncodingHextile:\n            case rfbEncodingUltra:\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n\t    case rfbEncodingZlib:\n            case rfbEncodingZRLE:\n            case rfbEncodingZYWRLE:\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n\t    case rfbEncodingTight:\n#endif\n#endif\n#ifdef LIBVNCSERVER_HAVE_LIBPNG\n\t    case rfbEncodingTightPng:\n#endif\n            /* The first supported encoding is the 'preferred' encoding */\n                if (cl->preferredEncoding == -1)\n                    cl->preferredEncoding = enc;\n\n\n                break;\n\t    case rfbEncodingXCursor:\n\t\tif(!cl->screen->dontConvertRichCursorToXCursor) {\n\t\t    rfbLog(\"Enabling X-style cursor updates for client %s\\n\",\n\t\t\t   cl->host);\n\t\t    /* if cursor was drawn, hide the cursor */\n\t\t    if(!cl->enableCursorShapeUpdates)\n\t\t        rfbRedrawAfterHideCursor(cl,NULL);\n\n\t\t    cl->enableCursorShapeUpdates = TRUE;\n\t\t    cl->cursorWasChanged = TRUE;\n\t\t}\n\t\tbreak;\n\t    case rfbEncodingRichCursor:\n\t        rfbLog(\"Enabling full-color cursor updates for client %s\\n\",\n\t\t       cl->host);\n\t\t/* if cursor was drawn, hide the cursor */\n\t\tif(!cl->enableCursorShapeUpdates)\n\t\t    rfbRedrawAfterHideCursor(cl,NULL);\n\n\t        cl->enableCursorShapeUpdates = TRUE;\n\t        cl->useRichCursorEncoding = TRUE;\n\t        cl->cursorWasChanged = TRUE;\n\t        break;\n\t    case rfbEncodingPointerPos:\n\t\tif (!cl->enableCursorPosUpdates) {\n\t\t    rfbLog(\"Enabling cursor position updates for client %s\\n\",\n\t\t\t   cl->host);\n\t\t    cl->enableCursorPosUpdates = TRUE;\n\t\t    cl->cursorWasMoved = TRUE;\n\t\t}\n\t        break;\n\t    case rfbEncodingLastRect:\n\t\tif (!cl->enableLastRectEncoding) {\n\t\t    rfbLog(\"Enabling LastRect protocol extension for client \"\n\t\t\t   \"%s\\n\", cl->host);\n\t\t    cl->enableLastRectEncoding = TRUE;\n\t\t}\n\t\tbreak;\n\t    case rfbEncodingNewFBSize:\n\t\tif (!cl->useNewFBSize) {\n\t\t    rfbLog(\"Enabling NewFBSize protocol extension for client \"\n\t\t\t   \"%s\\n\", cl->host);\n\t\t    cl->useNewFBSize = TRUE;\n\t\t}\n\t\tbreak;\n            case rfbEncodingKeyboardLedState:\n                if (!cl->enableKeyboardLedState) {\n                  rfbLog(\"Enabling KeyboardLedState protocol extension for client \"\n                          \"%s\\n\", cl->host);\n                  cl->enableKeyboardLedState = TRUE;\n                }\n                break;           \n            case rfbEncodingSupportedMessages:\n                if (!cl->enableSupportedMessages) {\n                  rfbLog(\"Enabling SupportedMessages protocol extension for client \"\n                          \"%s\\n\", cl->host);\n                  cl->enableSupportedMessages = TRUE;\n                }\n                break;           \n            case rfbEncodingSupportedEncodings:\n                if (!cl->enableSupportedEncodings) {\n                  rfbLog(\"Enabling SupportedEncodings protocol extension for client \"\n                          \"%s\\n\", cl->host);\n                  cl->enableSupportedEncodings = TRUE;\n                }\n                break;           \n            case rfbEncodingServerIdentity:\n                if (!cl->enableServerIdentity) {\n                  rfbLog(\"Enabling ServerIdentity protocol extension for client \"\n                          \"%s\\n\", cl->host);\n                  cl->enableServerIdentity = TRUE;\n                }\n                break;\n            case rfbEncodingXvp:\n                if (cl->screen->xvpHook) {\n                  rfbLog(\"Enabling Xvp protocol extension for client \"\n                          \"%s\\n\", cl->host);\n                  if (!rfbSendXvp(cl, 1, rfbXvp_Init)) {\n                    rfbCloseClient(cl);\n                    return;\n                  }\n                }\n                break;\n            default:\n#if defined(LIBVNCSERVER_HAVE_LIBZ) || defined(LIBVNCSERVER_HAVE_LIBPNG)\n\t\tif ( enc >= (uint32_t)rfbEncodingCompressLevel0 &&\n\t\t     enc <= (uint32_t)rfbEncodingCompressLevel9 ) {\n\t\t    cl->zlibCompressLevel = enc & 0x0F;\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n\t\t    cl->tightCompressLevel = enc & 0x0F;\n\t\t    rfbLog(\"Using compression level %d for client %s\\n\",\n\t\t\t   cl->tightCompressLevel, cl->host);\n#endif\n\t\t} else if ( enc >= (uint32_t)rfbEncodingQualityLevel0 &&\n\t\t\t    enc <= (uint32_t)rfbEncodingQualityLevel9 ) {\n\t\t    cl->tightQualityLevel = enc & 0x0F;\n\t\t    rfbLog(\"Using image quality level %d for client %s\\n\",\n\t\t\t   cl->tightQualityLevel, cl->host);\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n\t\t    cl->turboQualityLevel = tight2turbo_qual[enc & 0x0F];\n\t\t    cl->turboSubsampLevel = tight2turbo_subsamp[enc & 0x0F];\n\t\t    rfbLog(\"Using JPEG subsampling %d, Q%d for client %s\\n\",\n\t\t\t   cl->turboSubsampLevel, cl->turboQualityLevel, cl->host);\n\t\t} else if ( enc >= (uint32_t)rfbEncodingFineQualityLevel0 + 1 &&\n\t\t\t    enc <= (uint32_t)rfbEncodingFineQualityLevel100 ) {\n\t\t    cl->turboQualityLevel = enc & 0xFF;\n\t\t    rfbLog(\"Using fine quality level %d for client %s\\n\",\n\t\t\t   cl->turboQualityLevel, cl->host);\n\t\t} else if ( enc >= (uint32_t)rfbEncodingSubsamp1X &&\n\t\t\t    enc <= (uint32_t)rfbEncodingSubsampGray ) {\n\t\t    cl->turboSubsampLevel = enc & 0xFF;\n\t\t    rfbLog(\"Using subsampling level %d for client %s\\n\",\n\t\t\t   cl->turboSubsampLevel, cl->host);\n#endif\n\t\t} else\n#endif\n\t\t{\n\t\t\trfbExtensionData* e;\n\t\t\tfor(e = cl->extensions; e;) {\n\t\t\t\trfbExtensionData* next = e->next;\n\t\t\t\tif(e->extension->enablePseudoEncoding &&\n\t\t\t\t\te->extension->enablePseudoEncoding(cl,\n\t\t\t\t\t\t&e->data, (int)enc))\n\t\t\t\t\t/* ext handles this encoding */\n\t\t\t\t\tbreak;\n\t\t\t\te = next;\n\t\t\t}\n\t\t\tif(e == NULL) {\n\t\t\t\trfbBool handled = FALSE;\n\t\t\t\t/* if the pseudo encoding is not handled by the\n\t\t\t\t   enabled extensions, search through all\n\t\t\t\t   extensions. */\n\t\t\t\trfbProtocolExtension* e;\n\n\t\t\t\tfor(e = rfbGetExtensionIterator(); e;) {\n\t\t\t\t\tint* encs = e->pseudoEncodings;\n\t\t\t\t\twhile(encs && *encs!=0) {\n\t\t\t\t\t\tif(*encs==(int)enc) {\n\t\t\t\t\t\t\tvoid* data = NULL;\n\t\t\t\t\t\t\tif(!e->enablePseudoEncoding(cl, &data, (int)enc)) {\n\t\t\t\t\t\t\t\trfbLog(\"Installed extension pretends to handle pseudo encoding 0x%x, but does not!\\n\",(int)enc);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\trfbEnableExtension(cl, e, data);\n\t\t\t\t\t\t\t\thandled = TRUE;\n\t\t\t\t\t\t\t\te = NULL;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tencs++;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(e)\n\t\t\t\t\t\te = e->next;\n\t\t\t\t}\n\t\t\t\trfbReleaseExtensionIterator();\n\n\t\t\t\tif(!handled)\n\t\t\t\t\trfbLog(\"rfbProcessClientNormalMessage: \"\n\t\t\t\t\t    \"ignoring unsupported encoding type %s\\n\",\n\t\t\t\t\t    encodingName(enc,encBuf,sizeof(encBuf)));\n\t\t\t}\n\t\t}\n            }\n        }\n\n\n\n        if (cl->preferredEncoding == -1) {\n            if (lastPreferredEncoding==-1) {\n                cl->preferredEncoding = rfbEncodingRaw;\n                rfbLog(\"Defaulting to %s encoding for client %s\\n\", encodingName(cl->preferredEncoding,encBuf,sizeof(encBuf)),cl->host);\n            }\n            else {\n                cl->preferredEncoding = lastPreferredEncoding;\n                rfbLog(\"Sticking with %s encoding for client %s\\n\", encodingName(cl->preferredEncoding,encBuf,sizeof(encBuf)),cl->host);\n            }\n        }\n        else\n        {\n          if (lastPreferredEncoding==-1) {\n              rfbLog(\"Using %s encoding for client %s\\n\", encodingName(cl->preferredEncoding,encBuf,sizeof(encBuf)),cl->host);\n          } else {\n              rfbLog(\"Switching from %s to %s Encoding for client %s\\n\", \n                  encodingName(lastPreferredEncoding,encBuf2,sizeof(encBuf2)),\n                  encodingName(cl->preferredEncoding,encBuf,sizeof(encBuf)), cl->host);\n          }\n        }\n        \n\tif (cl->enableCursorPosUpdates && !cl->enableCursorShapeUpdates) {\n\t  rfbLog(\"Disabling cursor position updates for client %s\\n\",\n\t\t cl->host);\n\t  cl->enableCursorPosUpdates = FALSE;\n\t}\n\n        return;\n    }\n\n\n    case rfbFramebufferUpdateRequest:\n    {\n        sraRegionPtr tmpRegion;\n\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                           sz_rfbFramebufferUpdateRequestMsg-1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbFramebufferUpdateRequestMsg,sz_rfbFramebufferUpdateRequestMsg);\n\n        /* The values come in based on the scaled screen, we need to convert them to\n         * values based on the main screen's coordinate system\n         */\n\tif(!rectSwapIfLEAndClip(&msg.fur.x,&msg.fur.y,&msg.fur.w,&msg.fur.h,cl))\n\t{\n\t        rfbLog(\"Warning, ignoring rfbFramebufferUpdateRequest: %dXx%dY-%dWx%dH\\n\",msg.fur.x, msg.fur.y, msg.fur.w, msg.fur.h);\n\t\treturn;\n        }\n \n        \n\ttmpRegion =\n\t  sraRgnCreateRect(msg.fur.x,\n\t\t\t   msg.fur.y,\n\t\t\t   msg.fur.x+msg.fur.w,\n\t\t\t   msg.fur.y+msg.fur.h);\n\n        LOCK(cl->updateMutex);\n\tsraRgnOr(cl->requestedRegion,tmpRegion);\n\n\tif (!cl->readyForSetColourMapEntries) {\n\t    /* client hasn't sent a SetPixelFormat so is using server's */\n\t    cl->readyForSetColourMapEntries = TRUE;\n\t    if (!cl->format.trueColour) {\n\t\tif (!rfbSetClientColourMap(cl, 0, 0)) {\n\t\t    sraRgnDestroy(tmpRegion);\n\t\t    TSIGNAL(cl->updateCond);\n\t\t    UNLOCK(cl->updateMutex);\n\t\t    return;\n\t\t}\n\t    }\n\t}\n\n       if (!msg.fur.incremental) {\n\t    sraRgnOr(cl->modifiedRegion,tmpRegion);\n\t    sraRgnSubtract(cl->copyRegion,tmpRegion);\n       }\n       TSIGNAL(cl->updateCond);\n       UNLOCK(cl->updateMutex);\n\n       sraRgnDestroy(tmpRegion);\n\n       return;\n    }\n\n    case rfbKeyEvent:\n\n\tif ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n\t\t\t   sz_rfbKeyEventMsg - 1)) <= 0) {\n\t    if (n != 0)\n\t\trfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n\n\trfbStatRecordMessageRcvd(cl, msg.type, sz_rfbKeyEventMsg, sz_rfbKeyEventMsg);\n\n\tif(!cl->viewOnly) {\n\t    cl->screen->kbdAddEvent(msg.ke.down, (rfbKeySym)Swap32IfLE(msg.ke.key), cl);\n\t}\n\n        return;\n\n\n    case rfbPointerEvent:\n\n\tif ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n\t\t\t   sz_rfbPointerEventMsg - 1)) <= 0) {\n\t    if (n != 0)\n\t\trfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n\n\trfbStatRecordMessageRcvd(cl, msg.type, sz_rfbPointerEventMsg, sz_rfbPointerEventMsg);\n\t\n\tif (cl->screen->pointerClient && cl->screen->pointerClient != cl)\n\t    return;\n\n\tif (msg.pe.buttonMask == 0)\n\t    cl->screen->pointerClient = NULL;\n\telse\n\t    cl->screen->pointerClient = cl;\n\n\tif(!cl->viewOnly) {\n\t    if (msg.pe.buttonMask != cl->lastPtrButtons ||\n\t\t    cl->screen->deferPtrUpdateTime == 0) {\n\t\tcl->screen->ptrAddEvent(msg.pe.buttonMask,\n\t\t\tScaleX(cl->scaledScreen, cl->screen, Swap16IfLE(msg.pe.x)), \n\t\t\tScaleY(cl->scaledScreen, cl->screen, Swap16IfLE(msg.pe.y)),\n\t\t\tcl);\n\t\tcl->lastPtrButtons = msg.pe.buttonMask;\n\t    } else {\n\t\tcl->lastPtrX = ScaleX(cl->scaledScreen, cl->screen, Swap16IfLE(msg.pe.x));\n\t\tcl->lastPtrY = ScaleY(cl->scaledScreen, cl->screen, Swap16IfLE(msg.pe.y));\n\t\tcl->lastPtrButtons = msg.pe.buttonMask;\n\t    }\n      }      \n      return;\n\n\n    case rfbFileTransfer:\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                              sz_rfbFileTransferMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n        msg.ft.size         = Swap32IfLE(msg.ft.size);\n        msg.ft.length       = Swap32IfLE(msg.ft.length);\n        /* record statistics in rfbProcessFileTransfer as length is filled with garbage when it is not valid */\n        rfbProcessFileTransfer(cl, msg.ft.contentType, msg.ft.contentParam, msg.ft.size, msg.ft.length);\n        return;\n\n    case rfbSetSW:\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                              sz_rfbSetSWMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n        msg.sw.x = Swap16IfLE(msg.sw.x);\n        msg.sw.y = Swap16IfLE(msg.sw.y);\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetSWMsg, sz_rfbSetSWMsg);\n        /* msg.sw.status is not initialized in the ultraVNC viewer and contains random numbers (why???) */\n\n        rfbLog(\"Received a rfbSetSingleWindow(%d x, %d y)\\n\", msg.sw.x, msg.sw.y);\n        if (cl->screen->setSingleWindow!=NULL)\n            cl->screen->setSingleWindow(cl, msg.sw.x, msg.sw.y);\n        return;\n\n    case rfbSetServerInput:\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                              sz_rfbSetServerInputMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetServerInputMsg, sz_rfbSetServerInputMsg);\n\n        /* msg.sim.pad is not initialized in the ultraVNC viewer and contains random numbers (why???) */\n        /* msg.sim.pad = Swap16IfLE(msg.sim.pad); */\n\n        rfbLog(\"Received a rfbSetServerInput(%d status)\\n\", msg.sim.status);\n        if (cl->screen->setServerInput!=NULL)\n            cl->screen->setServerInput(cl, msg.sim.status);\n        return;\n        \n    case rfbTextChat:\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                              sz_rfbTextChatMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n        \n        msg.tc.pad2   = Swap16IfLE(msg.tc.pad2);\n        msg.tc.length = Swap32IfLE(msg.tc.length);\n\n        switch (msg.tc.length) {\n        case rfbTextChatOpen:\n        case rfbTextChatClose:\n        case rfbTextChatFinished:\n            /* commands do not have text following */\n            /* Why couldn't they have used the pad byte??? */\n            str=NULL;\n            rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbTextChatMsg, sz_rfbTextChatMsg);\n            break;\n        default:\n            if ((msg.tc.length>0) && (msg.tc.length<rfbTextMaxSize))\n            {\n                str = (char *)malloc(msg.tc.length);\n                if (str==NULL)\n                {\n                    rfbLog(\"Unable to malloc %d bytes for a TextChat Message\\n\", msg.tc.length);\n                    rfbCloseClient(cl);\n                    return;\n                }\n                if ((n = rfbReadExact(cl, str, msg.tc.length)) <= 0) {\n                    if (n != 0)\n                        rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n                    free(str);\n                    rfbCloseClient(cl);\n                    return;\n                }\n                rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbTextChatMsg+msg.tc.length, sz_rfbTextChatMsg+msg.tc.length);\n            }\n            else\n            {\n                /* This should never happen */\n                rfbLog(\"client sent us a Text Message that is too big %d>%d\\n\", msg.tc.length, rfbTextMaxSize);\n                rfbCloseClient(cl);\n                return;\n            }\n        }\n\n        /* Note: length can be commands: rfbTextChatOpen, rfbTextChatClose, and rfbTextChatFinished\n         * at which point, the str is NULL (as it is not sent)\n         */\n        if (cl->screen->setTextChat!=NULL)\n            cl->screen->setTextChat(cl, msg.tc.length, str);\n\n        free(str);\n        return;\n\n\n    case rfbClientCutText:\n\n\tif ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n\t\t\t   sz_rfbClientCutTextMsg - 1)) <= 0) {\n\t    if (n != 0)\n\t\trfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n\n\tmsg.cct.length = Swap32IfLE(msg.cct.length);\n\n\t/* uint32_t input is passed to malloc()'s size_t argument,\n\t * to rfbReadExact()'s int argument, to rfbStatRecordMessageRcvd()'s int\n\t * argument increased of sz_rfbClientCutTextMsg, and to setXCutText()'s int\n\t * argument. Here we impose a limit of 1 MB so that the value fits\n\t * into all of the types to prevent from misinterpretation and thus\n\t * from accessing uninitialized memory (CVE-2018-7225) and also to\n\t * prevent from a denial-of-service by allocating to much memory in\n\t * the server. */\n\tif (msg.cct.length > 1<<20) {\n\t    rfbLog(\"rfbClientCutText: too big cut text length requested: %\" PRIu32 \"\\n\",\n\t\t    msg.cct.length);\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n\n\t/* Allow zero-length client cut text. */\n\tstr = (char *)calloc(msg.cct.length ? msg.cct.length : 1, 1);\n\tif (str == NULL) {\n\t\trfbLogPerror(\"rfbProcessClientNormalMessage: not enough memory\");\n\t\trfbCloseClient(cl);\n\t\treturn;\n\t}\n\n\tif ((n = rfbReadExact(cl, str, msg.cct.length)) <= 0) {\n\t    if (n != 0)\n\t        rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n\t    free(str);\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n\trfbStatRecordMessageRcvd(cl, msg.type, sz_rfbClientCutTextMsg+msg.cct.length, sz_rfbClientCutTextMsg+msg.cct.length);\n\tif(!cl->viewOnly) {\n\t    cl->screen->setXCutText(str, msg.cct.length, cl);\n\t}\n\tfree(str);\n\n        return;\n\n    case rfbPalmVNCSetScaleFactor:\n      cl->PalmVNC = TRUE;\n      if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n          sz_rfbSetScaleMsg - 1)) <= 0) {\n          if (n != 0)\n            rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n          rfbCloseClient(cl);\n          return;\n      }\n\n      if (msg.ssc.scale == 0) {\n          rfbLogPerror(\"rfbProcessClientNormalMessage: will not accept a scale factor of zero\");\n          rfbCloseClient(cl);\n          return;\n      }\n\n      rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetScaleMsg, sz_rfbSetScaleMsg);\n      rfbLog(\"rfbSetScale(%d)\\n\", msg.ssc.scale);\n      rfbScalingSetup(cl,cl->screen->width/msg.ssc.scale, cl->screen->height/msg.ssc.scale);\n\n      rfbSendNewScaleSize(cl);\n      return;\n      \n    case rfbSetScale:\n\n      if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n          sz_rfbSetScaleMsg - 1)) <= 0) {\n          if (n != 0)\n            rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n          rfbCloseClient(cl);\n          return;\n      }\n\n      if (msg.ssc.scale == 0) {\n          rfbLogPerror(\"rfbProcessClientNormalMessage: will not accept a scale factor of zero\");\n          rfbCloseClient(cl);\n          return;\n      }\n\n      rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetScaleMsg, sz_rfbSetScaleMsg);\n      rfbLog(\"rfbSetScale(%d)\\n\", msg.ssc.scale);\n      rfbScalingSetup(cl,cl->screen->width/msg.ssc.scale, cl->screen->height/msg.ssc.scale);\n\n      rfbSendNewScaleSize(cl);\n      return;\n\n    case rfbXvp:\n\n      if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n          sz_rfbXvpMsg - 1)) <= 0) {\n          if (n != 0)\n            rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n          rfbCloseClient(cl);\n          return;\n      }\n      rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbXvpMsg, sz_rfbXvpMsg);\n\n      /* only version when is defined, so echo back a fail */\n      if(msg.xvp.version != 1) {\n\trfbSendXvp(cl, msg.xvp.version, rfbXvp_Fail);\n      }\n      else {\n\t/* if the hook exists and fails, send a fail msg */\n\tif(cl->screen->xvpHook && !cl->screen->xvpHook(cl, msg.xvp.version, msg.xvp.code))\n\t  rfbSendXvp(cl, 1, rfbXvp_Fail);\n      }\n      return;\n\n    default:\n\t{\n\t    rfbExtensionData *e,*next;\n\n\t    for(e=cl->extensions; e;) {\n\t\tnext = e->next;\n\t\tif(e->extension->handleMessage &&\n\t\t\te->extension->handleMessage(cl, e->data, &msg))\n                {\n                    rfbStatRecordMessageRcvd(cl, msg.type, 0, 0); /* Extension should handle this */\n\t\t    return;\n                }\n\t\te = next;\n\t    }\n\n\t    rfbLog(\"rfbProcessClientNormalMessage: unknown message type %d\\n\",\n\t\t    msg.type);\n\t    rfbLog(\" ... closing connection\\n\");\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n    }\n}",
  "abstract_func": "static void\nrfbProcessClientNormalMessage(rfbClientPtr VAR_0)\n{\n    int VAR_1=0;\n    rfbClientToServerMsg VAR_2;\n    char *VAR_3;\n    int VAR_4;\n    uint32_t VAR_5=0;\n    uint32_t VAR_6 = -1;\n    char VAR_7[64];\n    char VAR_8[64];\n\n    if ((VAR_1 = rfbReadExact(VAR_0, (char *)&VAR_2, 1)) <= 0) {\n        if (VAR_1 != 0)\n            rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n        rfbCloseClient(VAR_0);\n        return;\n    }\n\n    switch (VAR_2.type) {\n\n    case VAR_9:\n\n        if ((VAR_1 = rfbReadExact(VAR_0, ((char *)&VAR_2) + 1,\n                           VAR_10 - 1)) <= 0) {\n            if (VAR_1 != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(VAR_0);\n            return;\n        }\n\n        VAR_0->format.bitsPerPixel = VAR_2.spf.format.bitsPerPixel;\n        VAR_0->format.depth = VAR_2.spf.format.depth;\n        VAR_0->format.bigEndian = (VAR_2.spf.format.bigEndian ? TRUE : FALSE);\n        VAR_0->format.trueColour = (VAR_2.spf.format.trueColour ? TRUE : FALSE);\n        VAR_0->format.redMax = Swap16IfLE(VAR_2.spf.format.redMax);\n        VAR_0->format.greenMax = Swap16IfLE(VAR_2.spf.format.greenMax);\n        VAR_0->format.blueMax = Swap16IfLE(VAR_2.spf.format.blueMax);\n        VAR_0->format.redShift = VAR_2.spf.format.redShift;\n        VAR_0->format.greenShift = VAR_2.spf.format.greenShift;\n        VAR_0->format.blueShift = VAR_2.spf.format.blueShift;\n\n\tVAR_0->readyForSetColourMapEntries = TRUE;\n        VAR_0->screen->setTranslateFunction(VAR_0);\n\n        rfbStatRecordMessageRcvd(VAR_0, VAR_2.type, VAR_10, VAR_10);\n\n        return;\n\n\n    case VAR_11:\n        if ((VAR_1 = rfbReadExact(VAR_0, ((char *)&VAR_2) + 1,\n                           VAR_12 - 1)) <= 0) {\n            if (VAR_1 != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(VAR_0);\n            return;\n        }\n        rfbStatRecordMessageRcvd(VAR_0, VAR_2.type, VAR_10, VAR_10);\n        rfbLog(\"rfbProcessClientNormalMessage: %s\",\n                \"FixColourMapEntries unsupported\\n\");\n        rfbCloseClient(VAR_0);\n        return;\n\n\n    /* COMMENT_0 */\n                                       \n               \n                                   \n                                                   \n      \n                                                                           \n       \n    case VAR_13:\n    {\n\n        if ((VAR_1 = rfbReadExact(VAR_0, ((char *)&VAR_2) + 1,\n                           VAR_14 - 1)) <= 0) {\n            if (VAR_1 != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(VAR_0);\n            return;\n        }\n\n        VAR_2.se.nEncodings = Swap16IfLE(VAR_2.se.nEncodings);\n\n        rfbStatRecordMessageRcvd(VAR_0, VAR_2.type, VAR_14+(VAR_2.se.nEncodings*4),VAR_14+(VAR_2.se.nEncodings*4));\n\n        /* COMMENT_8 */\n                                                                                    \n                                                                   \n           \n        if (VAR_0->preferredEncoding!=-1)\n            VAR_6 = VAR_0->preferredEncoding;\n\n        /* COMMENT_12 */\n        VAR_0->preferredEncoding=-1;\n        VAR_0->useCopyRect              = FALSE;\n        VAR_0->useNewFBSize             = FALSE;\n        VAR_0->cursorWasChanged         = FALSE;\n        VAR_0->useRichCursorEncoding    = FALSE;\n        VAR_0->enableCursorPosUpdates   = FALSE;\n        VAR_0->enableCursorShapeUpdates = FALSE;\n        VAR_0->enableCursorShapeUpdates = FALSE;\n        VAR_0->enableLastRectEncoding   = FALSE;\n        VAR_0->enableKeyboardLedState   = FALSE;\n        VAR_0->enableSupportedMessages  = FALSE;\n        VAR_0->enableSupportedEncodings = FALSE;\n        VAR_0->enableServerIdentity     = FALSE;\n#if defined(VAR_15) || defined(VAR_16)\n        VAR_0->tightQualityLevel        = -1;\n#ifdef VAR_17\n        VAR_0->tightCompressLevel       = VAR_18;\n        VAR_0->turboSubsampLevel        = VAR_19;\n        VAR_0->turboQualityLevel        = -1;\n#endif\n#endif\n\n\n        for (VAR_4 = 0; VAR_4 < VAR_2.se.nEncodings; VAR_4++) {\n            if ((VAR_1 = rfbReadExact(VAR_0, (char *)&VAR_5, 4)) <= 0) {\n                if (VAR_1 != 0)\n                    rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n                rfbCloseClient(VAR_0);\n                return;\n            }\n            VAR_5 = Swap32IfLE(VAR_5);\n\n            switch (VAR_5) {\n\n            case VAR_20:\n\t\tVAR_0->useCopyRect = TRUE;\n                break;\n            case VAR_21:\n            case VAR_22:\n            case VAR_23:\n            case VAR_24:\n            case VAR_25:\n#ifdef VAR_15\n\t    case VAR_26:\n            case VAR_27:\n            case VAR_28:\n#ifdef VAR_17\n\t    case VAR_29:\n#endif\n#endif\n#ifdef VAR_16\n\t    case VAR_30:\n#endif\n            /* COMMENT_13 */\n                if (VAR_0->preferredEncoding == -1)\n                    VAR_0->preferredEncoding = VAR_5;\n\n\n                break;\n\t    case VAR_31:\n\t\tif(!VAR_0->screen->dontConvertRichCursorToXCursor) {\n\t\t    rfbLog(\"Enabling X-style cursor updates for client %s\\n\",\n\t\t\t   VAR_0->host);\n\t\t    /* COMMENT_14 */\n\t\t    if(!VAR_0->enableCursorShapeUpdates)\n\t\t        rfbRedrawAfterHideCursor(VAR_0,NULL);\n\n\t\t    VAR_0->enableCursorShapeUpdates = TRUE;\n\t\t    VAR_0->cursorWasChanged = TRUE;\n\t\t}\n\t\tbreak;\n\t    case VAR_32:\n\t        rfbLog(\"Enabling full-color cursor updates for client %s\\n\",\n\t\t       VAR_0->host);\n\t\t/* COMMENT_14 */\n\t\tif(!VAR_0->enableCursorShapeUpdates)\n\t\t    rfbRedrawAfterHideCursor(VAR_0,NULL);\n\n\t        VAR_0->enableCursorShapeUpdates = TRUE;\n\t        VAR_0->useRichCursorEncoding = TRUE;\n\t        VAR_0->cursorWasChanged = TRUE;\n\t        break;\n\t    case VAR_33:\n\t\tif (!VAR_0->enableCursorPosUpdates) {\n\t\t    rfbLog(\"Enabling cursor position updates for client %s\\n\",\n\t\t\t   VAR_0->host);\n\t\t    VAR_0->enableCursorPosUpdates = TRUE;\n\t\t    VAR_0->cursorWasMoved = TRUE;\n\t\t}\n\t        break;\n\t    case VAR_34:\n\t\tif (!VAR_0->enableLastRectEncoding) {\n\t\t    rfbLog(\"Enabling LastRect protocol extension for client \"\n\t\t\t   \"%s\\n\", VAR_0->host);\n\t\t    VAR_0->enableLastRectEncoding = TRUE;\n\t\t}\n\t\tbreak;\n\t    case VAR_35:\n\t\tif (!VAR_0->useNewFBSize) {\n\t\t    rfbLog(\"Enabling NewFBSize protocol extension for client \"\n\t\t\t   \"%s\\n\", VAR_0->host);\n\t\t    VAR_0->useNewFBSize = TRUE;\n\t\t}\n\t\tbreak;\n            case VAR_36:\n                if (!VAR_0->enableKeyboardLedState) {\n                  rfbLog(\"Enabling KeyboardLedState protocol extension for client \"\n                          \"%s\\n\", VAR_0->host);\n                  VAR_0->enableKeyboardLedState = TRUE;\n                }\n                break;           \n            case VAR_37:\n                if (!VAR_0->enableSupportedMessages) {\n                  rfbLog(\"Enabling SupportedMessages protocol extension for client \"\n                          \"%s\\n\", VAR_0->host);\n                  VAR_0->enableSupportedMessages = TRUE;\n                }\n                break;           \n            case VAR_38:\n                if (!VAR_0->enableSupportedEncodings) {\n                  rfbLog(\"Enabling SupportedEncodings protocol extension for client \"\n                          \"%s\\n\", VAR_0->host);\n                  VAR_0->enableSupportedEncodings = TRUE;\n                }\n                break;           \n            case VAR_39:\n                if (!VAR_0->enableServerIdentity) {\n                  rfbLog(\"Enabling ServerIdentity protocol extension for client \"\n                          \"%s\\n\", VAR_0->host);\n                  VAR_0->enableServerIdentity = TRUE;\n                }\n                break;\n            case VAR_40:\n                if (VAR_0->screen->xvpHook) {\n                  rfbLog(\"Enabling Xvp protocol extension for client \"\n                          \"%s\\n\", VAR_0->host);\n                  if (!rfbSendXvp(VAR_0, 1, VAR_41)) {\n                    rfbCloseClient(VAR_0);\n                    return;\n                  }\n                }\n                break;\n            default:\n#if defined(VAR_15) || defined(VAR_16)\n\t\tif ( VAR_5 >= (uint32_t)VAR_42 &&\n\t\t     VAR_5 <= (uint32_t)VAR_43 ) {\n\t\t    VAR_0->zlibCompressLevel = VAR_5 & 0x0F;\n#ifdef VAR_17\n\t\t    VAR_0->tightCompressLevel = VAR_5 & 0x0F;\n\t\t    rfbLog(\"Using compression level %d for client %s\\n\",\n\t\t\t   VAR_0->tightCompressLevel, VAR_0->host);\n#endif\n\t\t} else if ( VAR_5 >= (uint32_t)VAR_44 &&\n\t\t\t    VAR_5 <= (uint32_t)VAR_45 ) {\n\t\t    VAR_0->tightQualityLevel = VAR_5 & 0x0F;\n\t\t    rfbLog(\"Using image quality level %d for client %s\\n\",\n\t\t\t   VAR_0->tightQualityLevel, VAR_0->host);\n#ifdef VAR_17\n\t\t    VAR_0->turboQualityLevel = VAR_46[VAR_5 & 0x0F];\n\t\t    VAR_0->turboSubsampLevel = VAR_47[VAR_5 & 0x0F];\n\t\t    rfbLog(\"Using JPEG subsampling %d, Q%d for client %s\\n\",\n\t\t\t   VAR_0->turboSubsampLevel, VAR_0->turboQualityLevel, VAR_0->host);\n\t\t} else if ( VAR_5 >= (uint32_t)VAR_48 + 1 &&\n\t\t\t    VAR_5 <= (uint32_t)VAR_49 ) {\n\t\t    VAR_0->turboQualityLevel = VAR_5 & 0xFF;\n\t\t    rfbLog(\"Using fine quality level %d for client %s\\n\",\n\t\t\t   VAR_0->turboQualityLevel, VAR_0->host);\n\t\t} else if ( VAR_5 >= (uint32_t)VAR_50 &&\n\t\t\t    VAR_5 <= (uint32_t)VAR_51 ) {\n\t\t    VAR_0->turboSubsampLevel = VAR_5 & 0xFF;\n\t\t    rfbLog(\"Using subsampling level %d for client %s\\n\",\n\t\t\t   VAR_0->turboSubsampLevel, VAR_0->host);\n#endif\n\t\t} else\n#endif\n\t\t{\n\t\t\trfbExtensionData* VAR_52;\n\t\t\tfor(VAR_52 = VAR_0->extensions; VAR_52;) {\n\t\t\t\trfbExtensionData* VAR_53 = VAR_52->next;\n\t\t\t\tif(VAR_52->extension->enablePseudoEncoding &&\n\t\t\t\t\tVAR_52->extension->enablePseudoEncoding(VAR_0,\n\t\t\t\t\t\t&VAR_52->data, (int)VAR_5))\n\t\t\t\t\t/* COMMENT_15 */\n\t\t\t\t\tbreak;\n\t\t\t\tVAR_52 = VAR_53;\n\t\t\t}\n\t\t\tif(VAR_52 == NULL) {\n\t\t\t\trfbBool VAR_54 = FALSE;\n\t\t\t\t/* COMMENT_16 */\n                                             \n                     \n\t\t\t\trfbProtocolExtension* VAR_52;\n\n\t\t\t\tfor(VAR_52 = rfbGetExtensionIterator(); VAR_52;) {\n\t\t\t\t\tint* VAR_55 = VAR_52->pseudoEncodings;\n\t\t\t\t\twhile(VAR_55 && *VAR_55!=0) {\n\t\t\t\t\t\tif(*VAR_55==(int)VAR_5) {\n\t\t\t\t\t\t\tvoid* VAR_56 = NULL;\n\t\t\t\t\t\t\tif(!VAR_52->enablePseudoEncoding(VAR_0, &VAR_56, (int)VAR_5)) {\n\t\t\t\t\t\t\t\trfbLog(\"Installed extension pretends to handle pseudo encoding 0x%x, but does not!\\n\",(int)VAR_5);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\trfbEnableExtension(VAR_0, VAR_52, VAR_56);\n\t\t\t\t\t\t\t\tVAR_54 = TRUE;\n\t\t\t\t\t\t\t\tVAR_52 = NULL;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tVAR_55++;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(VAR_52)\n\t\t\t\t\t\tVAR_52 = VAR_52->next;\n\t\t\t\t}\n\t\t\t\trfbReleaseExtensionIterator();\n\n\t\t\t\tif(!VAR_54)\n\t\t\t\t\trfbLog(\"rfbProcessClientNormalMessage: \"\n\t\t\t\t\t    \"ignoring unsupported encoding type %s\\n\",\n\t\t\t\t\t    encodingName(VAR_5,VAR_7,sizeof(VAR_7)));\n\t\t\t}\n\t\t}\n            }\n        }\n\n\n\n        if (VAR_0->preferredEncoding == -1) {\n            if (VAR_6==-1) {\n                VAR_0->preferredEncoding = VAR_21;\n                rfbLog(\"Defaulting to %s encoding for client %s\\n\", encodingName(VAR_0->preferredEncoding,VAR_7,sizeof(VAR_7)),VAR_0->host);\n            }\n            else {\n                VAR_0->preferredEncoding = VAR_6;\n                rfbLog(\"Sticking with %s encoding for client %s\\n\", encodingName(VAR_0->preferredEncoding,VAR_7,sizeof(VAR_7)),VAR_0->host);\n            }\n        }\n        else\n        {\n          if (VAR_6==-1) {\n              rfbLog(\"Using %s encoding for client %s\\n\", encodingName(VAR_0->preferredEncoding,VAR_7,sizeof(VAR_7)),VAR_0->host);\n          } else {\n              rfbLog(\"Switching from %s to %s Encoding for client %s\\n\", \n                  encodingName(VAR_6,VAR_8,sizeof(VAR_8)),\n                  encodingName(VAR_0->preferredEncoding,VAR_7,sizeof(VAR_7)), VAR_0->host);\n          }\n        }\n        \n\tif (VAR_0->enableCursorPosUpdates && !VAR_0->enableCursorShapeUpdates) {\n\t  rfbLog(\"Disabling cursor position updates for client %s\\n\",\n\t\t VAR_0->host);\n\t  VAR_0->enableCursorPosUpdates = FALSE;\n\t}\n\n        return;\n    }\n\n\n    case VAR_57:\n    {\n        sraRegionPtr VAR_58;\n\n        if ((VAR_1 = rfbReadExact(VAR_0, ((char *)&VAR_2) + 1,\n                           VAR_59-1)) <= 0) {\n            if (VAR_1 != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(VAR_0);\n            return;\n        }\n\n        rfbStatRecordMessageRcvd(VAR_0, VAR_2.type, VAR_59,VAR_59);\n\n        /* COMMENT_19 */\n                                                              \n           \n\tif(!rectSwapIfLEAndClip(&VAR_2.fur.x,&VAR_2.fur.y,&VAR_2.fur.w,&VAR_2.fur.h,VAR_0))\n\t{\n\t        rfbLog(\"Warning, ignoring rfbFramebufferUpdateRequest: %dXx%dY-%dWx%dH\\n\",VAR_2.fur.x, VAR_2.fur.y, VAR_2.fur.w, VAR_2.fur.h);\n\t\treturn;\n        }\n \n        \n\tVAR_58 =\n\t  sraRgnCreateRect(VAR_2.fur.x,\n\t\t\t   VAR_2.fur.y,\n\t\t\t   VAR_2.fur.x+VAR_2.fur.w,\n\t\t\t   VAR_2.fur.y+VAR_2.fur.h);\n\n        LOCK(VAR_0->updateMutex);\n\tsraRgnOr(VAR_0->requestedRegion,VAR_58);\n\n\tif (!VAR_0->readyForSetColourMapEntries) {\n\t    /* COMMENT_22 */\n\t    VAR_0->readyForSetColourMapEntries = TRUE;\n\t    if (!VAR_0->format.trueColour) {\n\t\tif (!rfbSetClientColourMap(VAR_0, 0, 0)) {\n\t\t    sraRgnDestroy(VAR_58);\n\t\t    TSIGNAL(VAR_0->updateCond);\n\t\t    UNLOCK(VAR_0->updateMutex);\n\t\t    return;\n\t\t}\n\t    }\n\t}\n\n       if (!VAR_2.fur.incremental) {\n\t    sraRgnOr(VAR_0->modifiedRegion,VAR_58);\n\t    sraRgnSubtract(VAR_0->copyRegion,VAR_58);\n       }\n       TSIGNAL(VAR_0->updateCond);\n       UNLOCK(VAR_0->updateMutex);\n\n       sraRgnDestroy(VAR_58);\n\n       return;\n    }\n\n    case VAR_60:\n\n\tif ((VAR_1 = rfbReadExact(VAR_0, ((char *)&VAR_2) + 1,\n\t\t\t   VAR_61 - 1)) <= 0) {\n\t    if (VAR_1 != 0)\n\t\trfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n\t    rfbCloseClient(VAR_0);\n\t    return;\n\t}\n\n\trfbStatRecordMessageRcvd(VAR_0, VAR_2.type, VAR_61, VAR_61);\n\n\tif(!VAR_0->viewOnly) {\n\t    VAR_0->screen->kbdAddEvent(VAR_2.ke.down, (rfbKeySym)Swap32IfLE(VAR_2.ke.key), VAR_0);\n\t}\n\n        return;\n\n\n    case VAR_62:\n\n\tif ((VAR_1 = rfbReadExact(VAR_0, ((char *)&VAR_2) + 1,\n\t\t\t   VAR_63 - 1)) <= 0) {\n\t    if (VAR_1 != 0)\n\t\trfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n\t    rfbCloseClient(VAR_0);\n\t    return;\n\t}\n\n\trfbStatRecordMessageRcvd(VAR_0, VAR_2.type, VAR_63, VAR_63);\n\t\n\tif (VAR_0->screen->pointerClient && VAR_0->screen->pointerClient != VAR_0)\n\t    return;\n\n\tif (VAR_2.pe.buttonMask == 0)\n\t    VAR_0->screen->pointerClient = NULL;\n\telse\n\t    VAR_0->screen->pointerClient = VAR_0;\n\n\tif(!VAR_0->viewOnly) {\n\t    if (VAR_2.pe.buttonMask != VAR_0->lastPtrButtons ||\n\t\t    VAR_0->screen->deferPtrUpdateTime == 0) {\n\t\tVAR_0->screen->ptrAddEvent(VAR_2.pe.buttonMask,\n\t\t\tScaleX(VAR_0->scaledScreen, VAR_0->screen, Swap16IfLE(VAR_2.pe.x)), \n\t\t\tScaleY(VAR_0->scaledScreen, VAR_0->screen, Swap16IfLE(VAR_2.pe.y)),\n\t\t\tVAR_0);\n\t\tVAR_0->lastPtrButtons = VAR_2.pe.buttonMask;\n\t    } else {\n\t\tVAR_0->lastPtrX = ScaleX(VAR_0->scaledScreen, VAR_0->screen, Swap16IfLE(VAR_2.pe.x));\n\t\tVAR_0->lastPtrY = ScaleY(VAR_0->scaledScreen, VAR_0->screen, Swap16IfLE(VAR_2.pe.y));\n\t\tVAR_0->lastPtrButtons = VAR_2.pe.buttonMask;\n\t    }\n      }      \n      return;\n\n\n    case VAR_64:\n        if ((VAR_1 = rfbReadExact(VAR_0, ((char *)&VAR_2) + 1,\n                              VAR_65 - 1)) <= 0) {\n            if (VAR_1 != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(VAR_0);\n            return;\n        }\n        VAR_2.ft.size         = Swap32IfLE(VAR_2.ft.size);\n        VAR_2.ft.length       = Swap32IfLE(VAR_2.ft.length);\n        /* COMMENT_23 */\n        rfbProcessFileTransfer(VAR_0, VAR_2.ft.contentType, VAR_2.ft.contentParam, VAR_2.ft.size, VAR_2.ft.length);\n        return;\n\n    case VAR_66:\n        if ((VAR_1 = rfbReadExact(VAR_0, ((char *)&VAR_2) + 1,\n                              VAR_67 - 1)) <= 0) {\n            if (VAR_1 != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(VAR_0);\n            return;\n        }\n        VAR_2.sw.x = Swap16IfLE(VAR_2.sw.x);\n        VAR_2.sw.y = Swap16IfLE(VAR_2.sw.y);\n        rfbStatRecordMessageRcvd(VAR_0, VAR_2.type, VAR_67, VAR_67);\n        /* COMMENT_24 */\n\n        rfbLog(\"Received a rfbSetSingleWindow(%d x, %d y)\\n\", VAR_2.sw.x, VAR_2.sw.y);\n        if (VAR_0->screen->setSingleWindow!=NULL)\n            VAR_0->screen->setSingleWindow(VAR_0, VAR_2.sw.x, VAR_2.sw.y);\n        return;\n\n    case VAR_68:\n        if ((VAR_1 = rfbReadExact(VAR_0, ((char *)&VAR_2) + 1,\n                              VAR_69 - 1)) <= 0) {\n            if (VAR_1 != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(VAR_0);\n            return;\n        }\n        rfbStatRecordMessageRcvd(VAR_0, VAR_2.type, VAR_69, VAR_69);\n\n        /* COMMENT_25 */\n        /* COMMENT_26 */\n\n        rfbLog(\"Received a rfbSetServerInput(%d status)\\n\", VAR_2.sim.status);\n        if (VAR_0->screen->setServerInput!=NULL)\n            VAR_0->screen->setServerInput(VAR_0, VAR_2.sim.status);\n        return;\n        \n    case VAR_70:\n        if ((VAR_1 = rfbReadExact(VAR_0, ((char *)&VAR_2) + 1,\n                              VAR_71 - 1)) <= 0) {\n            if (VAR_1 != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(VAR_0);\n            return;\n        }\n        \n        VAR_2.tc.pad2   = Swap16IfLE(VAR_2.tc.pad2);\n        VAR_2.tc.length = Swap32IfLE(VAR_2.tc.length);\n\n        switch (VAR_2.tc.length) {\n        case VAR_72:\n        case VAR_73:\n        case VAR_74:\n            /* COMMENT_27 */\n            /* COMMENT_28 */\n            VAR_3=NULL;\n            rfbStatRecordMessageRcvd(VAR_0, VAR_2.type, VAR_71, VAR_71);\n            break;\n        default:\n            if ((VAR_2.tc.length>0) && (VAR_2.tc.length<VAR_75))\n            {\n                VAR_3 = (char *)malloc(VAR_2.tc.length);\n                if (VAR_3==NULL)\n                {\n                    rfbLog(\"Unable to malloc %d bytes for a TextChat Message\\n\", VAR_2.tc.length);\n                    rfbCloseClient(VAR_0);\n                    return;\n                }\n                if ((VAR_1 = rfbReadExact(VAR_0, VAR_3, VAR_2.tc.length)) <= 0) {\n                    if (VAR_1 != 0)\n                        rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n                    free(VAR_3);\n                    rfbCloseClient(VAR_0);\n                    return;\n                }\n                rfbStatRecordMessageRcvd(VAR_0, VAR_2.type, VAR_71+VAR_2.tc.length, VAR_71+VAR_2.tc.length);\n            }\n            else\n            {\n                /* COMMENT_29 */\n                rfbLog(\"client sent us a Text Message that is too big %d>%d\\n\", VAR_2.tc.length, VAR_75);\n                rfbCloseClient(VAR_0);\n                return;\n            }\n        }\n\n        /* COMMENT_30 */\n                                                              \n           \n        if (VAR_0->screen->setTextChat!=NULL)\n            VAR_0->screen->setTextChat(VAR_0, VAR_2.tc.length, VAR_3);\n\n        free(VAR_3);\n        return;\n\n\n    case VAR_76:\n\n\tif ((VAR_1 = rfbReadExact(VAR_0, ((char *)&VAR_2) + 1,\n\t\t\t   VAR_77 - 1)) <= 0) {\n\t    if (VAR_1 != 0)\n\t\trfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n\t    rfbCloseClient(VAR_0);\n\t    return;\n\t}\n\n\tVAR_2.cct.length = Swap32IfLE(VAR_2.cct.length);\n\n\t/* COMMENT_33 */\n                                                                         \n                                                                            \n                                                                   \n                                                                    \n                                                                   \n                                                                    \n                  \n\tif (VAR_2.cct.length > 1<<20) {\n\t    rfbLog(\"rfbClientCutText: too big cut text length requested: %\" VAR_78 \"\\n\",\n\t\t    VAR_2.cct.length);\n\t    rfbCloseClient(VAR_0);\n\t    return;\n\t}\n\n\t/* COMMENT_41 */\n\tVAR_3 = (char *)calloc(VAR_2.cct.length ? VAR_2.cct.length : 1, 1);\n\tif (VAR_3 == NULL) {\n\t\trfbLogPerror(\"rfbProcessClientNormalMessage: not enough memory\");\n\t\trfbCloseClient(VAR_0);\n\t\treturn;\n\t}\n\n\tif ((VAR_1 = rfbReadExact(VAR_0, VAR_3, VAR_2.cct.length)) <= 0) {\n\t    if (VAR_1 != 0)\n\t        rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n\t    free(VAR_3);\n\t    rfbCloseClient(VAR_0);\n\t    return;\n\t}\n\trfbStatRecordMessageRcvd(VAR_0, VAR_2.type, VAR_77+VAR_2.cct.length, VAR_77+VAR_2.cct.length);\n\tif(!VAR_0->viewOnly) {\n\t    VAR_0->screen->setXCutText(VAR_3, VAR_2.cct.length, VAR_0);\n\t}\n\tfree(VAR_3);\n\n        return;\n\n    case VAR_79:\n      VAR_0->PalmVNC = TRUE;\n      if ((VAR_1 = rfbReadExact(VAR_0, ((char *)&VAR_2) + 1,\n          VAR_80 - 1)) <= 0) {\n          if (VAR_1 != 0)\n            rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n          rfbCloseClient(VAR_0);\n          return;\n      }\n\n      if (VAR_2.ssc.scale == 0) {\n          rfbLogPerror(\"rfbProcessClientNormalMessage: will not accept a scale factor of zero\");\n          rfbCloseClient(VAR_0);\n          return;\n      }\n\n      rfbStatRecordMessageRcvd(VAR_0, VAR_2.type, VAR_80, VAR_80);\n      rfbLog(\"rfbSetScale(%d)\\n\", VAR_2.ssc.scale);\n      rfbScalingSetup(VAR_0,VAR_0->screen->width/VAR_2.ssc.scale, VAR_0->screen->height/VAR_2.ssc.scale);\n\n      rfbSendNewScaleSize(VAR_0);\n      return;\n      \n    case VAR_81:\n\n      if ((VAR_1 = rfbReadExact(VAR_0, ((char *)&VAR_2) + 1,\n          VAR_80 - 1)) <= 0) {\n          if (VAR_1 != 0)\n            rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n          rfbCloseClient(VAR_0);\n          return;\n      }\n\n      if (VAR_2.ssc.scale == 0) {\n          rfbLogPerror(\"rfbProcessClientNormalMessage: will not accept a scale factor of zero\");\n          rfbCloseClient(VAR_0);\n          return;\n      }\n\n      rfbStatRecordMessageRcvd(VAR_0, VAR_2.type, VAR_80, VAR_80);\n      rfbLog(\"rfbSetScale(%d)\\n\", VAR_2.ssc.scale);\n      rfbScalingSetup(VAR_0,VAR_0->screen->width/VAR_2.ssc.scale, VAR_0->screen->height/VAR_2.ssc.scale);\n\n      rfbSendNewScaleSize(VAR_0);\n      return;\n\n    case VAR_82:\n\n      if ((VAR_1 = rfbReadExact(VAR_0, ((char *)&VAR_2) + 1,\n          VAR_83 - 1)) <= 0) {\n          if (VAR_1 != 0)\n            rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n          rfbCloseClient(VAR_0);\n          return;\n      }\n      rfbStatRecordMessageRcvd(VAR_0, VAR_2.type, VAR_83, VAR_83);\n\n      /* COMMENT_42 */\n      if(VAR_2.xvp.version != 1) {\n\trfbSendXvp(VAR_0, VAR_2.xvp.version, VAR_84);\n      }\n      else {\n\t/* COMMENT_43 */\n\tif(VAR_0->screen->xvpHook && !VAR_0->screen->xvpHook(VAR_0, VAR_2.xvp.version, VAR_2.xvp.code))\n\t  rfbSendXvp(VAR_0, 1, VAR_84);\n      }\n      return;\n\n    default:\n\t{\n\t    rfbExtensionData *VAR_52,*VAR_53;\n\n\t    for(VAR_52=VAR_0->extensions; VAR_52;) {\n\t\tVAR_53 = VAR_52->next;\n\t\tif(VAR_52->extension->handleMessage &&\n\t\t\tVAR_52->extension->handleMessage(VAR_0, VAR_52->data, &VAR_2))\n                {\n                    rfbStatRecordMessageRcvd(VAR_0, VAR_2.type, 0, 0); /* COMMENT_44 */\n\t\t    return;\n                }\n\t\tVAR_52 = VAR_53;\n\t    }\n\n\t    rfbLog(\"rfbProcessClientNormalMessage: unknown message type %d\\n\",\n\t\t    VAR_2.type);\n\t    rfbLog(\" ... closing connection\\n\");\n\t    rfbCloseClient(VAR_0);\n\t    return;\n\t}\n    }\n}",
  "func_graph_path": "LibVNC/libvncserver/28afb6c537dc82ba04d5f245b15ca7205c6dbb9c/rfbserver.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -586,7 +586,23 @@\n \n \tmsg.cct.length = Swap32IfLE(msg.cct.length);\n \n-\tstr = (char *)malloc(msg.cct.length);\n+\t/* uint32_t input is passed to malloc()'s size_t argument,\n+\t * to rfbReadExact()'s int argument, to rfbStatRecordMessageRcvd()'s int\n+\t * argument increased of sz_rfbClientCutTextMsg, and to setXCutText()'s int\n+\t * argument. Here we impose a limit of 1 MB so that the value fits\n+\t * into all of the types to prevent from misinterpretation and thus\n+\t * from accessing uninitialized memory (CVE-2018-7225) and also to\n+\t * prevent from a denial-of-service by allocating to much memory in\n+\t * the server. */\n+\tif (msg.cct.length > 1<<20) {\n+\t    rfbLog(\"rfbClientCutText: too big cut text length requested: %\" PRIu32 \"\\n\",\n+\t\t    msg.cct.length);\n+\t    rfbCloseClient(cl);\n+\t    return;\n+\t}\n+\n+\t/* Allow zero-length client cut text. */\n+\tstr = (char *)calloc(msg.cct.length ? msg.cct.length : 1, 1);\n \tif (str == NULL) {\n \t\trfbLogPerror(\"rfbProcessClientNormalMessage: not enough memory\");\n \t\trfbCloseClient(cl);",
  "diff_line_info": {
    "deleted_lines": [
      "\tstr = (char *)malloc(msg.cct.length);"
    ],
    "added_lines": [
      "\t/* uint32_t input is passed to malloc()'s size_t argument,",
      "\t * to rfbReadExact()'s int argument, to rfbStatRecordMessageRcvd()'s int",
      "\t * argument increased of sz_rfbClientCutTextMsg, and to setXCutText()'s int",
      "\t * argument. Here we impose a limit of 1 MB so that the value fits",
      "\t * into all of the types to prevent from misinterpretation and thus",
      "\t * from accessing uninitialized memory (CVE-2018-7225) and also to",
      "\t * prevent from a denial-of-service by allocating to much memory in",
      "\t * the server. */",
      "\tif (msg.cct.length > 1<<20) {",
      "\t    rfbLog(\"rfbClientCutText: too big cut text length requested: %\" PRIu32 \"\\n\",",
      "\t\t    msg.cct.length);",
      "\t    rfbCloseClient(cl);",
      "\t    return;",
      "\t}",
      "",
      "\t/* Allow zero-length client cut text. */",
      "\tstr = (char *)calloc(msg.cct.length ? msg.cct.length : 1, 1);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/LibVNC/libvncserver/pull/221",
  "description": {
    "pr_info": {
      "title": "Validate client cut text length",
      "number": 221
    },
    "comment": [
      "Client-provided unsigned 32-bit cut text length is passed to various\r\nfunctions that expects argument of a different type.\r\n\r\nE.g. \"RFB 003.003\\n\\001\\006\\0\\0\\0\\xff\\xff\\xff\\xff\" string sent to the\r\nRFB server leads to 4294967295 msg.cct.length value that in turn is\r\ninterpreted as -1 by rfbReadExact() and thus uninitialized str buffer\r\nwith potentially sensitive data is passed to subsequent functions.\r\n\r\nThis patch fixes it by checking for a maximal value that still can be\r\nprocessed correctly. It also corrects accepting length value of zero\r\n(malloc(0) is interpreted on differnet systems differently).\r\n\r\nWhether a client can make the server allocate up to 2 GB and cause\r\na denial of service on memory-tight systems is kept without answer.\r\nA possible solution would be adding an arbitrary memory limit that is\r\ndeemed safe.\r\n\r\nCVE-2018-7225\r\n<https://github.com/LibVNC/libvncserver/issues/218>",
      "I added a second patch that limits the client cut length to 1 MB as it looks reasonable. Then I rebased them to the latest upstream master HEAD.",
      "Thanks! I'll have a look ASAP",
      "Also, please update the PR to contain a single commit.",
      "On Thu, Mar 08, 2018 at 11:06:32AM -0800, Christian Beier wrote:\n> bk138 requested changes on this pull request.\n> \n> Almost there! It also seems to me that the 2nd paragraph in the commit log is obsolete?\n>\nIt's required. This fix is about CVE-2018-7225.\n\n> > @@ -2575,7 +2577,23 @@ rfbProcessClientNormalMessage(rfbClientPtr cl)\n>  \n>  \tmsg.cct.length = Swap32IfLE(msg.cct.length);\n>  \n> -\tstr = (char *)malloc(msg.cct.length);\n> +\t/* uint32_t input is passed to malloc()'s size_t argument,\n> +\t * to rfbReadExact()'s int argument, to rfbStatRecordMessageRcvd()'s int\n> +\t * argument increased of sz_rfbClientCutTextMsg, and to setXCutText()'s int\n> +\t * argument. Here we impose a limit of 1 MB so that the value fits\n> +\t * into all of the types to prevent from misinterpretation and thus\n> +\t * from accessing uninitialized memory (CVE-2018-7225) and also to\n> +\t * prevent from a denial-of-service by allocating to much memory in\n> +\t * the server. */\n> +\tif (msg.cct.length > 1<<20) {\n> +\t    rfbLog(\"rfbClientCutText: too big cut text length requested: %\" PRIu32 \"\\n\",\n> \n> Why not simply use %u here?\n> \nBecause msg.cct.length is not of type unsigned int.\n\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}