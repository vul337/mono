{
  "cve_id": "CVE-2018-20217",
  "cwe_ids": [
    "CWE-617"
  ],
  "cvss_vector": "AV:N/AC:M/Au:S/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "krb5",
  "commit_msg": "Ignore password attributes for S4U2Self requests\n\nFor consistency with Windows KDCs, allow protocol transition to work\neven if the password has expired or needs changing.\n\nAlso, when looking up an enterprise principal with an AS request,\ntreat ERR_KEY_EXP as confirmation that the client is present in the\nrealm.\n\n[ghudson@mit.edu: added comment in kdc_process_s4u2self_req(); edited\ncommit message]\n\nticket: 8763 (new)\ntags: pullup\ntarget_version: 1.17",
  "commit_hash": "5e6d1796106df8ba6bc1973ee0917c170d929086",
  "git_url": "https://github.com/krb5/krb5/commit/5e6d1796106df8ba6bc1973ee0917c170d929086",
  "file_path": "src/lib/krb5/krb/s4u_creds.c",
  "func_name": "s4u_identify_user",
  "func_before": "static krb5_error_code\ns4u_identify_user(krb5_context context,\n                  krb5_creds *in_creds,\n                  krb5_data *subject_cert,\n                  krb5_principal *canon_user)\n{\n    krb5_error_code code;\n    krb5_preauthtype ptypes[1] = { KRB5_PADATA_S4U_X509_USER };\n    krb5_creds creds;\n    int use_master = 0;\n    krb5_get_init_creds_opt *opts = NULL;\n    krb5_principal_data client;\n    krb5_s4u_userid userid;\n\n    *canon_user = NULL;\n\n    if (in_creds->client == NULL && subject_cert == NULL) {\n        return EINVAL;\n    }\n\n    if (in_creds->client != NULL &&\n        in_creds->client->type != KRB5_NT_ENTERPRISE_PRINCIPAL) {\n        int anonymous;\n\n        anonymous = krb5_principal_compare(context, in_creds->client,\n                                           krb5_anonymous_principal());\n\n        return krb5_copy_principal(context,\n                                   anonymous ? in_creds->server\n                                   : in_creds->client,\n                                   canon_user);\n    }\n\n    memset(&creds, 0, sizeof(creds));\n\n    memset(&userid, 0, sizeof(userid));\n    if (subject_cert != NULL)\n        userid.subject_cert = *subject_cert;\n\n    code = krb5_get_init_creds_opt_alloc(context, &opts);\n    if (code != 0)\n        goto cleanup;\n    krb5_get_init_creds_opt_set_tkt_life(opts, 15);\n    krb5_get_init_creds_opt_set_renew_life(opts, 0);\n    krb5_get_init_creds_opt_set_forwardable(opts, 0);\n    krb5_get_init_creds_opt_set_proxiable(opts, 0);\n    krb5_get_init_creds_opt_set_canonicalize(opts, 1);\n    krb5_get_init_creds_opt_set_preauth_list(opts, ptypes, 1);\n\n    if (in_creds->client != NULL) {\n        client = *in_creds->client;\n        client.realm = in_creds->server->realm;\n    } else {\n        client.magic = KV5M_PRINCIPAL;\n        client.realm = in_creds->server->realm;\n        /* should this be NULL, empty or a fixed string? XXX */\n        client.data = NULL;\n        client.length = 0;\n        client.type = KRB5_NT_ENTERPRISE_PRINCIPAL;\n    }\n\n    code = k5_get_init_creds(context, &creds, &client, NULL, NULL, 0, NULL,\n                             opts, krb5_get_as_key_noop, &userid, &use_master,\n                             NULL);\n    if (code == 0 || code == KRB5_PREAUTH_FAILED) {\n        *canon_user = userid.user;\n        userid.user = NULL;\n        code = 0;\n    }\n\ncleanup:\n    krb5_free_cred_contents(context, &creds);\n    if (opts != NULL)\n        krb5_get_init_creds_opt_free(context, opts);\n    if (userid.user != NULL)\n        krb5_free_principal(context, userid.user);\n\n    return code;\n}",
  "abstract_func_before": "static krb5_error_code\ns4u_identify_user(krb5_context VAR_0,\n                  krb5_creds *VAR_1,\n                  krb5_data *VAR_2,\n                  krb5_principal *VAR_3)\n{\n    krb5_error_code VAR_4;\n    krb5_preauthtype VAR_5[1] = { VAR_6 };\n    krb5_creds VAR_7;\n    int VAR_8 = 0;\n    krb5_get_init_creds_opt *VAR_9 = NULL;\n    krb5_principal_data VAR_10;\n    krb5_s4u_userid VAR_11;\n\n    *VAR_3 = NULL;\n\n    if (VAR_1->client == NULL && VAR_2 == NULL) {\n        return VAR_12;\n    }\n\n    if (VAR_1->client != NULL &&\n        VAR_1->client->type != VAR_13) {\n        int VAR_14;\n\n        VAR_14 = krb5_principal_compare(VAR_0, VAR_1->client,\n                                           krb5_anonymous_principal());\n\n        return krb5_copy_principal(VAR_0,\n                                   VAR_14 ? VAR_1->server\n                                   : VAR_1->client,\n                                   VAR_3);\n    }\n\n    memset(&VAR_7, 0, sizeof(VAR_7));\n\n    memset(&VAR_11, 0, sizeof(VAR_11));\n    if (VAR_2 != NULL)\n        VAR_11.subject_cert = *VAR_2;\n\n    VAR_4 = krb5_get_init_creds_opt_alloc(VAR_0, &VAR_9);\n    if (VAR_4 != 0)\n        goto cleanup;\n    krb5_get_init_creds_opt_set_tkt_life(VAR_9, 15);\n    krb5_get_init_creds_opt_set_renew_life(VAR_9, 0);\n    krb5_get_init_creds_opt_set_forwardable(VAR_9, 0);\n    krb5_get_init_creds_opt_set_proxiable(VAR_9, 0);\n    krb5_get_init_creds_opt_set_canonicalize(VAR_9, 1);\n    krb5_get_init_creds_opt_set_preauth_list(VAR_9, VAR_5, 1);\n\n    if (VAR_1->client != NULL) {\n        VAR_10 = *VAR_1->client;\n        VAR_10.realm = VAR_1->server->realm;\n    } else {\n        VAR_10.magic = VAR_15;\n        VAR_10.realm = VAR_1->server->realm;\n        /* COMMENT_0 */\n        VAR_10.data = NULL;\n        VAR_10.length = 0;\n        VAR_10.type = VAR_13;\n    }\n\n    VAR_4 = k5_get_init_creds(VAR_0, &VAR_7, &VAR_10, NULL, NULL, 0, NULL,\n                             VAR_9, VAR_16, &VAR_11, &VAR_8,\n                             NULL);\n    if (VAR_4 == 0 || VAR_4 == VAR_17) {\n        *VAR_3 = VAR_11.user;\n        VAR_11.user = NULL;\n        VAR_4 = 0;\n    }\n\ncleanup:\n    krb5_free_cred_contents(VAR_0, &VAR_7);\n    if (VAR_9 != NULL)\n        krb5_get_init_creds_opt_free(VAR_0, VAR_9);\n    if (VAR_11.user != NULL)\n        krb5_free_principal(VAR_0, VAR_11.user);\n\n    return VAR_4;\n}",
  "func_graph_path_before": "krb5/5e6d1796106df8ba6bc1973ee0917c170d929086/s4u_creds.c/vul/before/0.json",
  "func": "static krb5_error_code\ns4u_identify_user(krb5_context context,\n                  krb5_creds *in_creds,\n                  krb5_data *subject_cert,\n                  krb5_principal *canon_user)\n{\n    krb5_error_code code;\n    krb5_preauthtype ptypes[1] = { KRB5_PADATA_S4U_X509_USER };\n    krb5_creds creds;\n    int use_master = 0;\n    krb5_get_init_creds_opt *opts = NULL;\n    krb5_principal_data client;\n    krb5_s4u_userid userid;\n\n    *canon_user = NULL;\n\n    if (in_creds->client == NULL && subject_cert == NULL) {\n        return EINVAL;\n    }\n\n    if (in_creds->client != NULL &&\n        in_creds->client->type != KRB5_NT_ENTERPRISE_PRINCIPAL) {\n        int anonymous;\n\n        anonymous = krb5_principal_compare(context, in_creds->client,\n                                           krb5_anonymous_principal());\n\n        return krb5_copy_principal(context,\n                                   anonymous ? in_creds->server\n                                   : in_creds->client,\n                                   canon_user);\n    }\n\n    memset(&creds, 0, sizeof(creds));\n\n    memset(&userid, 0, sizeof(userid));\n    if (subject_cert != NULL)\n        userid.subject_cert = *subject_cert;\n\n    code = krb5_get_init_creds_opt_alloc(context, &opts);\n    if (code != 0)\n        goto cleanup;\n    krb5_get_init_creds_opt_set_tkt_life(opts, 15);\n    krb5_get_init_creds_opt_set_renew_life(opts, 0);\n    krb5_get_init_creds_opt_set_forwardable(opts, 0);\n    krb5_get_init_creds_opt_set_proxiable(opts, 0);\n    krb5_get_init_creds_opt_set_canonicalize(opts, 1);\n    krb5_get_init_creds_opt_set_preauth_list(opts, ptypes, 1);\n\n    if (in_creds->client != NULL) {\n        client = *in_creds->client;\n        client.realm = in_creds->server->realm;\n    } else {\n        client.magic = KV5M_PRINCIPAL;\n        client.realm = in_creds->server->realm;\n        /* should this be NULL, empty or a fixed string? XXX */\n        client.data = NULL;\n        client.length = 0;\n        client.type = KRB5_NT_ENTERPRISE_PRINCIPAL;\n    }\n\n    code = k5_get_init_creds(context, &creds, &client, NULL, NULL, 0, NULL,\n                             opts, krb5_get_as_key_noop, &userid, &use_master,\n                             NULL);\n    if (!code || code == KRB5_PREAUTH_FAILED || code == KRB5KDC_ERR_KEY_EXP) {\n        *canon_user = userid.user;\n        userid.user = NULL;\n        code = 0;\n    }\n\ncleanup:\n    krb5_free_cred_contents(context, &creds);\n    if (opts != NULL)\n        krb5_get_init_creds_opt_free(context, opts);\n    if (userid.user != NULL)\n        krb5_free_principal(context, userid.user);\n\n    return code;\n}",
  "abstract_func": "static krb5_error_code\ns4u_identify_user(krb5_context VAR_0,\n                  krb5_creds *VAR_1,\n                  krb5_data *VAR_2,\n                  krb5_principal *VAR_3)\n{\n    krb5_error_code VAR_4;\n    krb5_preauthtype VAR_5[1] = { VAR_6 };\n    krb5_creds VAR_7;\n    int VAR_8 = 0;\n    krb5_get_init_creds_opt *VAR_9 = NULL;\n    krb5_principal_data VAR_10;\n    krb5_s4u_userid VAR_11;\n\n    *VAR_3 = NULL;\n\n    if (VAR_1->client == NULL && VAR_2 == NULL) {\n        return VAR_12;\n    }\n\n    if (VAR_1->client != NULL &&\n        VAR_1->client->type != VAR_13) {\n        int VAR_14;\n\n        VAR_14 = krb5_principal_compare(VAR_0, VAR_1->client,\n                                           krb5_anonymous_principal());\n\n        return krb5_copy_principal(VAR_0,\n                                   VAR_14 ? VAR_1->server\n                                   : VAR_1->client,\n                                   VAR_3);\n    }\n\n    memset(&VAR_7, 0, sizeof(VAR_7));\n\n    memset(&VAR_11, 0, sizeof(VAR_11));\n    if (VAR_2 != NULL)\n        VAR_11.subject_cert = *VAR_2;\n\n    VAR_4 = krb5_get_init_creds_opt_alloc(VAR_0, &VAR_9);\n    if (VAR_4 != 0)\n        goto cleanup;\n    krb5_get_init_creds_opt_set_tkt_life(VAR_9, 15);\n    krb5_get_init_creds_opt_set_renew_life(VAR_9, 0);\n    krb5_get_init_creds_opt_set_forwardable(VAR_9, 0);\n    krb5_get_init_creds_opt_set_proxiable(VAR_9, 0);\n    krb5_get_init_creds_opt_set_canonicalize(VAR_9, 1);\n    krb5_get_init_creds_opt_set_preauth_list(VAR_9, VAR_5, 1);\n\n    if (VAR_1->client != NULL) {\n        VAR_10 = *VAR_1->client;\n        VAR_10.realm = VAR_1->server->realm;\n    } else {\n        VAR_10.magic = VAR_15;\n        VAR_10.realm = VAR_1->server->realm;\n        /* COMMENT_0 */\n        VAR_10.data = NULL;\n        VAR_10.length = 0;\n        VAR_10.type = VAR_13;\n    }\n\n    VAR_4 = k5_get_init_creds(VAR_0, &VAR_7, &VAR_10, NULL, NULL, 0, NULL,\n                             VAR_9, VAR_16, &VAR_11, &VAR_8,\n                             NULL);\n    if (!VAR_4 || VAR_4 == VAR_17 || VAR_4 == VAR_18) {\n        *VAR_3 = VAR_11.user;\n        VAR_11.user = NULL;\n        VAR_4 = 0;\n    }\n\ncleanup:\n    krb5_free_cred_contents(VAR_0, &VAR_7);\n    if (VAR_9 != NULL)\n        krb5_get_init_creds_opt_free(VAR_0, VAR_9);\n    if (VAR_11.user != NULL)\n        krb5_free_principal(VAR_0, VAR_11.user);\n\n    return VAR_4;\n}",
  "func_graph_path": "krb5/5e6d1796106df8ba6bc1973ee0917c170d929086/s4u_creds.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -62,7 +62,7 @@\n     code = k5_get_init_creds(context, &creds, &client, NULL, NULL, 0, NULL,\n                              opts, krb5_get_as_key_noop, &userid, &use_master,\n                              NULL);\n-    if (code == 0 || code == KRB5_PREAUTH_FAILED) {\n+    if (!code || code == KRB5_PREAUTH_FAILED || code == KRB5KDC_ERR_KEY_EXP) {\n         *canon_user = userid.user;\n         userid.user = NULL;\n         code = 0;",
  "diff_line_info": {
    "deleted_lines": [
      "    if (code == 0 || code == KRB5_PREAUTH_FAILED) {"
    ],
    "added_lines": [
      "    if (!code || code == KRB5_PREAUTH_FAILED || code == KRB5KDC_ERR_KEY_EXP) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/krb5/krb5/pull/874",
  "description": {
    "pr_info": {
      "title": "Ignore password attributes for S4U2Self requests",
      "number": 874
    },
    "comment": [
      "This allows protocol transition to work even if\r\nthe password has expired or needchange (same as\r\nin Windows implementation).\r\n\r\nAlso, when looking up an enterprise principal with an\r\nAS request, treat ERR_KEY_EXP as a sign that the realm\r\nwas found, and proceed with S4U2Self TGS request.\r\n\r\nSigned-off-by: Isaac Boukris <iboukris@gmail.com>"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades;  \n**Confidence:** 0.95"
}