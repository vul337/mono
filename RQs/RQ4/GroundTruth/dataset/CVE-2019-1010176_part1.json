{
  "cve_id": "CVE-2019-1010176",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "jerryscript-project/jerryscript",
  "commit_msg": "Add a validation before evaluating the source code\n\nThis patch checks whether the source code is a valid UTF-8 string before evaluating it in prompt mode.\nAlso fixes #2476.\n\nJerryScript-DCO-1.0-Signed-off-by: Robert Fancsik frobert@inf.u-szeged.hu",
  "commit_hash": "675047d389d4846bd4d88d5006f9e4a506770659",
  "git_url": "https://github.com/jerryscript-project/jerryscript/commit/675047d389d4846bd4d88d5006f9e4a506770659",
  "file_path": "jerry-main/main-unix.c",
  "func_name": "main",
  "func_before": "int\nmain (int argc,\n      char **argv)\n{\n  srand ((unsigned) jerry_port_get_current_time ());\n  JERRY_VLA (const char *, file_names, argc);\n  int files_counter = 0;\n\n  jerry_init_flag_t flags = JERRY_INIT_EMPTY;\n\n  JERRY_VLA (const char *, exec_snapshot_file_names, argc);\n  JERRY_VLA (uint32_t, exec_snapshot_file_indices, argc);\n  int exec_snapshots_count = 0;\n\n  bool is_parse_only = false;\n\n  bool start_debug_server = false;\n  uint16_t debug_port = 5001;\n\n  bool is_repl_mode = false;\n  bool is_wait_mode = false;\n  bool no_prompt = false;\n\n  cli_state_t cli_state = cli_init (main_opts, argc - 1, argv + 1);\n  for (int id = cli_consume_option (&cli_state); id != CLI_OPT_END; id = cli_consume_option (&cli_state))\n  {\n    switch (id)\n    {\n      case OPT_HELP:\n      {\n        cli_help (argv[0], NULL, main_opts);\n        return JERRY_STANDALONE_EXIT_CODE_OK;\n      }\n      case OPT_VERSION:\n      {\n        printf (\"Version: %d.%d%s\\n\", JERRY_API_MAJOR_VERSION, JERRY_API_MINOR_VERSION, JERRY_COMMIT_HASH);\n        return JERRY_STANDALONE_EXIT_CODE_OK;\n      }\n      case OPT_MEM_STATS:\n      {\n        if (check_feature (JERRY_FEATURE_MEM_STATS, cli_state.arg))\n        {\n          jerry_port_default_set_log_level (JERRY_LOG_LEVEL_DEBUG);\n          flags |= JERRY_INIT_MEM_STATS;\n        }\n        break;\n      }\n      case OPT_PARSE_ONLY:\n      {\n        is_parse_only = true;\n        break;\n      }\n      case OPT_SHOW_OP:\n      {\n        if (check_feature (JERRY_FEATURE_PARSER_DUMP, cli_state.arg))\n        {\n          jerry_port_default_set_log_level (JERRY_LOG_LEVEL_DEBUG);\n          flags |= JERRY_INIT_SHOW_OPCODES;\n        }\n        break;\n      }\n      case OPT_SHOW_RE_OP:\n      {\n        if (check_feature (JERRY_FEATURE_REGEXP_DUMP, cli_state.arg))\n        {\n          jerry_port_default_set_log_level (JERRY_LOG_LEVEL_DEBUG);\n          flags |= JERRY_INIT_SHOW_REGEXP_OPCODES;\n        }\n        break;\n      }\n      case OPT_DEBUG_SERVER:\n      {\n        if (check_feature (JERRY_FEATURE_DEBUGGER, cli_state.arg))\n        {\n          start_debug_server = true;\n        }\n        break;\n      }\n      case OPT_DEBUG_PORT:\n      {\n        if (check_feature (JERRY_FEATURE_DEBUGGER, cli_state.arg))\n        {\n          debug_port = (uint16_t) cli_consume_int (&cli_state);\n        }\n        break;\n      }\n      case OPT_DEBUGGER_WAIT_SOURCE:\n      {\n        if (check_feature (JERRY_FEATURE_DEBUGGER, cli_state.arg))\n        {\n          is_wait_mode = true;\n        }\n        break;\n      }\n      case OPT_EXEC_SNAP:\n      {\n        if (check_feature (JERRY_FEATURE_SNAPSHOT_EXEC, cli_state.arg))\n        {\n          exec_snapshot_file_names[exec_snapshots_count] = cli_consume_string (&cli_state);\n          exec_snapshot_file_indices[exec_snapshots_count++] = 0;\n        }\n        else\n        {\n          cli_consume_string (&cli_state);\n        }\n        break;\n      }\n      case OPT_EXEC_SNAP_FUNC:\n      {\n        if (check_feature (JERRY_FEATURE_SNAPSHOT_EXEC, cli_state.arg))\n        {\n          exec_snapshot_file_names[exec_snapshots_count] = cli_consume_string (&cli_state);\n          exec_snapshot_file_indices[exec_snapshots_count++] = (uint32_t) cli_consume_int (&cli_state);\n        }\n        else\n        {\n          cli_consume_string (&cli_state);\n        }\n        break;\n      }\n      case OPT_LOG_LEVEL:\n      {\n        long int log_level = cli_consume_int (&cli_state);\n        check_usage (log_level >= 0 && log_level <= 3,\n                     argv[0], \"Error: invalid value for --log-level: \", cli_state.arg);\n\n        jerry_port_default_set_log_level ((jerry_log_level_t) log_level);\n        break;\n      }\n      case OPT_ABORT_ON_FAIL:\n      {\n        jerry_port_default_set_abort_on_fail (true);\n        break;\n      }\n      case OPT_NO_PROMPT:\n      {\n        no_prompt = true;\n        break;\n      }\n      case CLI_OPT_DEFAULT:\n      {\n        file_names[files_counter++] = cli_consume_string (&cli_state);\n        break;\n      }\n      default:\n      {\n        cli_state.error = \"Internal error\";\n        break;\n      }\n    }\n  }\n\n  if (cli_state.error != NULL)\n  {\n    if (cli_state.arg != NULL)\n    {\n      jerry_port_log (JERRY_LOG_LEVEL_ERROR, \"Error: %s %s\\n\", cli_state.error, cli_state.arg);\n    }\n    else\n    {\n      jerry_port_log (JERRY_LOG_LEVEL_ERROR, \"Error: %s\\n\", cli_state.error);\n    }\n\n    return JERRY_STANDALONE_EXIT_CODE_FAIL;\n  }\n\n  if (files_counter == 0\n      && exec_snapshots_count == 0)\n  {\n    is_repl_mode = true;\n  }\n\n#ifdef JERRY_ENABLE_EXTERNAL_CONTEXT\n\n  jerry_instance_t *instance_p = jerry_create_instance (512*1024, instance_alloc, NULL);\n  jerry_port_default_set_instance (instance_p);\n\n#endif /* JERRY_ENABLE_EXTERNAL_CONTEXT */\n\n  init_engine (flags, start_debug_server, debug_port);\n\n  jerry_value_t ret_value = jerry_create_undefined ();\n\n  if (jerry_is_feature_enabled (JERRY_FEATURE_SNAPSHOT_EXEC))\n  {\n    for (int i = 0; i < exec_snapshots_count; i++)\n    {\n      size_t snapshot_size;\n      const uint32_t *snapshot_p = read_file (exec_snapshot_file_names[i], &snapshot_size);\n\n      if (snapshot_p == NULL)\n      {\n        ret_value = jerry_create_error (JERRY_ERROR_COMMON, (jerry_char_t *) \"Snapshot file load error\");\n      }\n      else\n      {\n        ret_value = jerry_exec_snapshot (snapshot_p,\n                                         snapshot_size,\n                                         exec_snapshot_file_indices[i],\n                                         JERRY_SNAPSHOT_EXEC_COPY_DATA);\n      }\n\n      if (jerry_value_is_error (ret_value))\n      {\n        break;\n      }\n    }\n  }\n\n  while (true)\n  {\n\n    if (!jerry_value_is_error (ret_value))\n    {\n      for (int i = 0; i < files_counter; i++)\n      {\n        size_t source_size;\n        const jerry_char_t *source_p = (jerry_char_t *) read_file (file_names[i], &source_size);\n\n        if (source_p == NULL)\n        {\n          ret_value = jerry_create_error (JERRY_ERROR_COMMON, (jerry_char_t *) \"Source file load error\");\n          break;\n        }\n\n        if (!jerry_is_valid_utf8_string (source_p, (jerry_size_t) source_size))\n        {\n          ret_value = jerry_create_error (JERRY_ERROR_COMMON, (jerry_char_t *) (\"Input must be a valid UTF-8 string.\"));\n          break;\n        }\n\n        ret_value = jerry_parse ((jerry_char_t *) file_names[i],\n                                 strlen (file_names[i]),\n                                 source_p,\n                                 source_size,\n                                 JERRY_PARSE_NO_OPTS);\n\n        if (!jerry_value_is_error (ret_value) && !is_parse_only)\n        {\n          jerry_value_t func_val = ret_value;\n          ret_value = jerry_run (func_val);\n          jerry_release_value (func_val);\n        }\n\n        if (jerry_value_is_error (ret_value))\n        {\n          break;\n        }\n\n        jerry_release_value (ret_value);\n        ret_value = jerry_create_undefined ();\n      }\n    }\n\n    if (is_wait_mode)\n    {\n      is_repl_mode = false;\n\n      if (jerry_is_feature_enabled (JERRY_FEATURE_DEBUGGER))\n      {\n        while (true)\n        {\n          jerry_debugger_wait_for_source_status_t receive_status;\n\n          do\n          {\n            jerry_value_t run_result;\n\n            receive_status = jerry_debugger_wait_for_client_source (wait_for_source_callback,\n                                                                    NULL,\n                                                                    &run_result);\n\n            if (receive_status == JERRY_DEBUGGER_SOURCE_RECEIVE_FAILED)\n            {\n              ret_value = jerry_create_error (JERRY_ERROR_COMMON,\n                                              (jerry_char_t *) \"Connection aborted before source arrived.\");\n            }\n\n            if (receive_status == JERRY_DEBUGGER_SOURCE_END)\n            {\n              jerry_port_log (JERRY_LOG_LEVEL_DEBUG, \"No more client source.\\n\");\n            }\n\n            if (jerry_value_is_abort (run_result))\n            {\n              ret_value = jerry_acquire_value (run_result);\n            }\n\n            jerry_release_value (run_result);\n          }\n          while (receive_status == JERRY_DEBUGGER_SOURCE_RECEIVED);\n\n          if (receive_status != JERRY_DEBUGGER_CONTEXT_RESET_RECEIVED)\n          {\n            break;\n          }\n\n          init_engine (flags, true, debug_port);\n\n          ret_value = jerry_create_undefined ();\n        }\n      }\n\n    }\n\n    bool restart = false;\n\n    if (jerry_is_feature_enabled (JERRY_FEATURE_DEBUGGER) && jerry_value_is_abort (ret_value))\n    {\n      jerry_value_t abort_value = jerry_get_value_from_error (ret_value, false);\n      if (jerry_value_is_string (abort_value))\n      {\n        static const char restart_str[] = \"r353t\";\n\n        jerry_value_t str_val = jerry_value_to_string (abort_value);\n        jerry_size_t str_size = jerry_get_string_size (str_val);\n\n        if (str_size == sizeof (restart_str) - 1)\n        {\n          JERRY_VLA (jerry_char_t, str_buf, str_size);\n          jerry_string_to_char_buffer (str_val, str_buf, str_size);\n          if (memcmp (restart_str, (char *) (str_buf), str_size) == 0)\n          {\n            jerry_release_value (ret_value);\n            restart = true;\n          }\n        }\n\n        jerry_release_value (str_val);\n      }\n\n      jerry_release_value (abort_value);\n    }\n\n    if (!restart)\n    {\n      break;\n    }\n\n    jerry_cleanup ();\n\n    init_engine (flags, true, debug_port);\n\n    ret_value = jerry_create_undefined ();\n  }\n\n  if (is_repl_mode)\n  {\n    const char *prompt = !no_prompt ? \"jerry> \" : \"\";\n    bool is_done = false;\n\n    while (!is_done)\n    {\n      uint8_t *source_buffer_tail = buffer;\n      size_t len = 0;\n\n      printf (\"%s\", prompt);\n\n      /* Read a line */\n      while (true)\n      {\n        if (fread (source_buffer_tail, 1, 1, stdin) != 1 && len == 0)\n        {\n          is_done = true;\n          break;\n        }\n        if (*source_buffer_tail == '\\n')\n        {\n          break;\n        }\n        source_buffer_tail ++;\n        len ++;\n      }\n      *source_buffer_tail = 0;\n\n      if (len > 0)\n      {\n        /* Evaluate the line */\n        jerry_value_t ret_val_eval = jerry_eval (buffer, len, JERRY_PARSE_NO_OPTS);\n\n        if (!jerry_value_is_error (ret_val_eval))\n        {\n          /* Print return value */\n          const jerry_value_t args[] = { ret_val_eval };\n          jerry_value_t ret_val_print = jerryx_handler_print (jerry_create_undefined (),\n                                                              jerry_create_undefined (),\n                                                              args,\n                                                              1);\n          jerry_release_value (ret_val_print);\n          jerry_release_value (ret_val_eval);\n          ret_val_eval = jerry_run_all_enqueued_jobs ();\n\n          if (jerry_value_is_error (ret_val_eval))\n          {\n            ret_val_eval = jerry_get_value_from_error (ret_val_eval, true);\n            print_unhandled_exception (ret_val_eval);\n          }\n        }\n        else\n        {\n          ret_val_eval = jerry_get_value_from_error (ret_val_eval, true);\n          print_unhandled_exception (ret_val_eval);\n        }\n\n        jerry_release_value (ret_val_eval);\n      }\n    }\n  }\n\n  int ret_code = JERRY_STANDALONE_EXIT_CODE_OK;\n\n  if (jerry_value_is_error (ret_value))\n  {\n    ret_value = jerry_get_value_from_error (ret_value, true);\n    print_unhandled_exception (ret_value);\n\n    ret_code = JERRY_STANDALONE_EXIT_CODE_FAIL;\n  }\n\n  jerry_release_value (ret_value);\n\n  ret_value = jerry_run_all_enqueued_jobs ();\n\n  if (jerry_value_is_error (ret_value))\n  {\n    ret_value = jerry_get_value_from_error (ret_value, true);\n    print_unhandled_exception (ret_value);\n    ret_code = JERRY_STANDALONE_EXIT_CODE_FAIL;\n  }\n\n  jerry_release_value (ret_value);\n\n  jerry_cleanup ();\n#ifdef JERRY_ENABLE_EXTERNAL_CONTEXT\n  free (instance_p);\n#endif /* JERRY_ENABLE_EXTERNAL_CONTEXT */\n  return ret_code;\n}",
  "abstract_func_before": "int\nmain (int VAR_0,\n      char **VAR_1)\n{\n  srand ((unsigned) jerry_port_get_current_time ());\n  VAR_2 (const char *, VAR_3, VAR_0);\n  int VAR_4 = 0;\n\n  jerry_init_flag_t VAR_5 = VAR_6;\n\n  VAR_2 (const char *, VAR_7, VAR_0);\n  VAR_2 (VAR_8, VAR_9, VAR_0);\n  int VAR_10 = 0;\n\n  bool VAR_11 = false;\n\n  bool VAR_12 = false;\n  uint16_t VAR_13 = 5001;\n\n  bool VAR_14 = false;\n  bool VAR_15 = false;\n  bool VAR_16 = false;\n\n  cli_state_t VAR_17 = cli_init (VAR_18, VAR_0 - 1, VAR_1 + 1);\n  for (int VAR_19 = cli_consume_option (&VAR_17); VAR_19 != VAR_20; VAR_19 = cli_consume_option (&VAR_17))\n  {\n    switch (VAR_19)\n    {\n      case VAR_21:\n      {\n        cli_help (VAR_1[0], NULL, VAR_18);\n        return VAR_22;\n      }\n      case VAR_23:\n      {\n        printf (\"Version: %d.%d%s\\n\", VAR_24, VAR_25, VAR_26);\n        return VAR_22;\n      }\n      case VAR_27:\n      {\n        if (check_feature (VAR_28, VAR_17.arg))\n        {\n          jerry_port_default_set_log_level (VAR_29);\n          VAR_5 |= VAR_30;\n        }\n        break;\n      }\n      case VAR_31:\n      {\n        VAR_11 = true;\n        break;\n      }\n      case VAR_32:\n      {\n        if (check_feature (VAR_33, VAR_17.arg))\n        {\n          jerry_port_default_set_log_level (VAR_29);\n          VAR_5 |= VAR_34;\n        }\n        break;\n      }\n      case VAR_35:\n      {\n        if (check_feature (VAR_36, VAR_17.arg))\n        {\n          jerry_port_default_set_log_level (VAR_29);\n          VAR_5 |= VAR_37;\n        }\n        break;\n      }\n      case VAR_38:\n      {\n        if (check_feature (VAR_39, VAR_17.arg))\n        {\n          VAR_12 = true;\n        }\n        break;\n      }\n      case VAR_40:\n      {\n        if (check_feature (VAR_39, VAR_17.arg))\n        {\n          VAR_13 = (uint16_t) cli_consume_int (&VAR_17);\n        }\n        break;\n      }\n      case VAR_41:\n      {\n        if (check_feature (VAR_39, VAR_17.arg))\n        {\n          VAR_15 = true;\n        }\n        break;\n      }\n      case VAR_42:\n      {\n        if (check_feature (VAR_43, VAR_17.arg))\n        {\n          VAR_7[VAR_10] = cli_consume_string (&VAR_17);\n          VAR_9[VAR_10++] = 0;\n        }\n        else\n        {\n          cli_consume_string (&VAR_17);\n        }\n        break;\n      }\n      case VAR_44:\n      {\n        if (check_feature (VAR_43, VAR_17.arg))\n        {\n          VAR_7[VAR_10] = cli_consume_string (&VAR_17);\n          VAR_9[VAR_10++] = (uint32_t) cli_consume_int (&VAR_17);\n        }\n        else\n        {\n          cli_consume_string (&VAR_17);\n        }\n        break;\n      }\n      case VAR_45:\n      {\n        long int VAR_46 = cli_consume_int (&VAR_17);\n        check_usage (VAR_46 >= 0 && VAR_46 <= 3,\n                     VAR_1[0], \"Error: invalid value for --log-level: \", VAR_17.arg);\n\n        jerry_port_default_set_log_level ((jerry_log_level_t) VAR_46);\n        break;\n      }\n      case VAR_47:\n      {\n        jerry_port_default_set_abort_on_fail (true);\n        break;\n      }\n      case VAR_48:\n      {\n        VAR_16 = true;\n        break;\n      }\n      case VAR_49:\n      {\n        VAR_3[VAR_4++] = cli_consume_string (&VAR_17);\n        break;\n      }\n      default:\n      {\n        VAR_17.error = \"Internal error\";\n        break;\n      }\n    }\n  }\n\n  if (VAR_17.error != NULL)\n  {\n    if (VAR_17.arg != NULL)\n    {\n      jerry_port_log (VAR_50, \"Error: %s %s\\n\", VAR_17.error, VAR_17.arg);\n    }\n    else\n    {\n      jerry_port_log (VAR_50, \"Error: %s\\n\", VAR_17.error);\n    }\n\n    return VAR_51;\n  }\n\n  if (VAR_4 == 0\n      && VAR_10 == 0)\n  {\n    VAR_14 = true;\n  }\n\n#ifdef VAR_52\n\n  jerry_instance_t *VAR_53 = jerry_create_instance (512*1024, VAR_54, NULL);\n  jerry_port_default_set_instance (VAR_53);\n\n#endif /* COMMENT_0 */\n\n  init_engine (VAR_5, VAR_12, VAR_13);\n\n  jerry_value_t VAR_55 = jerry_create_undefined ();\n\n  if (jerry_is_feature_enabled (VAR_43))\n  {\n    for (int VAR_56 = 0; VAR_56 < VAR_10; VAR_56++)\n    {\n      size_t VAR_57;\n      const uint32_t *VAR_58 = read_file (VAR_7[VAR_56], &VAR_57);\n\n      if (VAR_58 == NULL)\n      {\n        VAR_55 = jerry_create_error (VAR_59, (jerry_char_t *) \"Snapshot file load error\");\n      }\n      else\n      {\n        VAR_55 = jerry_exec_snapshot (VAR_58,\n                                         VAR_57,\n                                         VAR_9[VAR_56],\n                                         VAR_60);\n      }\n\n      if (jerry_value_is_error (VAR_55))\n      {\n        break;\n      }\n    }\n  }\n\n  while (true)\n  {\n\n    if (!jerry_value_is_error (VAR_55))\n    {\n      for (int VAR_56 = 0; VAR_56 < VAR_4; VAR_56++)\n      {\n        size_t VAR_61;\n        const jerry_char_t *VAR_62 = (jerry_char_t *) read_file (VAR_3[VAR_56], &VAR_61);\n\n        if (VAR_62 == NULL)\n        {\n          VAR_55 = jerry_create_error (VAR_59, (jerry_char_t *) \"Source file load error\");\n          break;\n        }\n\n        if (!jerry_is_valid_utf8_string (VAR_62, (jerry_size_t) VAR_61))\n        {\n          VAR_55 = jerry_create_error (VAR_59, (jerry_char_t *) (\"Input must be a valid UTF-8 string.\"));\n          break;\n        }\n\n        VAR_55 = jerry_parse ((jerry_char_t *) VAR_3[VAR_56],\n                                 strlen (VAR_3[VAR_56]),\n                                 VAR_62,\n                                 VAR_61,\n                                 VAR_63);\n\n        if (!jerry_value_is_error (VAR_55) && !VAR_11)\n        {\n          jerry_value_t VAR_64 = VAR_55;\n          VAR_55 = jerry_run (VAR_64);\n          jerry_release_value (VAR_64);\n        }\n\n        if (jerry_value_is_error (VAR_55))\n        {\n          break;\n        }\n\n        jerry_release_value (VAR_55);\n        VAR_55 = jerry_create_undefined ();\n      }\n    }\n\n    if (VAR_15)\n    {\n      VAR_14 = false;\n\n      if (jerry_is_feature_enabled (VAR_39))\n      {\n        while (true)\n        {\n          jerry_debugger_wait_for_source_status_t VAR_65;\n\n          do\n          {\n            jerry_value_t VAR_66;\n\n            VAR_65 = jerry_debugger_wait_for_client_source (VAR_67,\n                                                                    NULL,\n                                                                    &VAR_66);\n\n            if (VAR_65 == VAR_68)\n            {\n              VAR_55 = jerry_create_error (VAR_59,\n                                              (jerry_char_t *) \"Connection aborted before source arrived.\");\n            }\n\n            if (VAR_65 == VAR_69)\n            {\n              jerry_port_log (VAR_29, \"No more client source.\\n\");\n            }\n\n            if (jerry_value_is_abort (VAR_66))\n            {\n              VAR_55 = jerry_acquire_value (VAR_66);\n            }\n\n            jerry_release_value (VAR_66);\n          }\n          while (VAR_65 == VAR_70);\n\n          if (VAR_65 != VAR_71)\n          {\n            break;\n          }\n\n          init_engine (VAR_5, true, VAR_13);\n\n          VAR_55 = jerry_create_undefined ();\n        }\n      }\n\n    }\n\n    bool VAR_72 = false;\n\n    if (jerry_is_feature_enabled (VAR_39) && jerry_value_is_abort (VAR_55))\n    {\n      jerry_value_t VAR_73 = jerry_get_value_from_error (VAR_55, false);\n      if (jerry_value_is_string (VAR_73))\n      {\n        static const char VAR_74[] = \"r353t\";\n\n        jerry_value_t VAR_75 = jerry_value_to_string (VAR_73);\n        jerry_size_t VAR_76 = jerry_get_string_size (VAR_75);\n\n        if (VAR_76 == sizeof (VAR_74) - 1)\n        {\n          VAR_2 (jerry_char_t, VAR_77, VAR_76);\n          jerry_string_to_char_buffer (VAR_75, VAR_77, VAR_76);\n          if (memcmp (VAR_74, (char *) (VAR_77), VAR_76) == 0)\n          {\n            jerry_release_value (VAR_55);\n            VAR_72 = true;\n          }\n        }\n\n        jerry_release_value (VAR_75);\n      }\n\n      jerry_release_value (VAR_73);\n    }\n\n    if (!VAR_72)\n    {\n      break;\n    }\n\n    jerry_cleanup ();\n\n    init_engine (VAR_5, true, VAR_13);\n\n    VAR_55 = jerry_create_undefined ();\n  }\n\n  if (VAR_14)\n  {\n    const char *VAR_78 = !VAR_16 ? \"jerry> \" : \"\";\n    bool VAR_79 = false;\n\n    while (!VAR_79)\n    {\n      uint8_t *VAR_80 = VAR_81;\n      size_t VAR_82 = 0;\n\n      printf (\"%s\", VAR_78);\n\n      /* COMMENT_1 */\n      while (true)\n      {\n        if (fread (VAR_80, 1, 1, VAR_83) != 1 && VAR_82 == 0)\n        {\n          VAR_79 = true;\n          break;\n        }\n        if (*VAR_80 == '\\n')\n        {\n          break;\n        }\n        VAR_80 ++;\n        VAR_82 ++;\n      }\n      *VAR_80 = 0;\n\n      if (VAR_82 > 0)\n      {\n        /* COMMENT_2 */\n        jerry_value_t VAR_84 = jerry_eval (VAR_81, VAR_82, VAR_63);\n\n        if (!jerry_value_is_error (VAR_84))\n        {\n          /* COMMENT_3 */\n          const jerry_value_t VAR_85[] = { VAR_84 };\n          jerry_value_t VAR_86 = jerryx_handler_print (jerry_create_undefined (),\n                                                              jerry_create_undefined (),\n                                                              VAR_85,\n                                                              1);\n          jerry_release_value (VAR_86);\n          jerry_release_value (VAR_84);\n          VAR_84 = jerry_run_all_enqueued_jobs ();\n\n          if (jerry_value_is_error (VAR_84))\n          {\n            VAR_84 = jerry_get_value_from_error (VAR_84, true);\n            print_unhandled_exception (VAR_84);\n          }\n        }\n        else\n        {\n          VAR_84 = jerry_get_value_from_error (VAR_84, true);\n          print_unhandled_exception (VAR_84);\n        }\n\n        jerry_release_value (VAR_84);\n      }\n    }\n  }\n\n  int VAR_87 = VAR_22;\n\n  if (jerry_value_is_error (VAR_55))\n  {\n    VAR_55 = jerry_get_value_from_error (VAR_55, true);\n    print_unhandled_exception (VAR_55);\n\n    VAR_87 = VAR_51;\n  }\n\n  jerry_release_value (VAR_55);\n\n  VAR_55 = jerry_run_all_enqueued_jobs ();\n\n  if (jerry_value_is_error (VAR_55))\n  {\n    VAR_55 = jerry_get_value_from_error (VAR_55, true);\n    print_unhandled_exception (VAR_55);\n    VAR_87 = VAR_51;\n  }\n\n  jerry_release_value (VAR_55);\n\n  jerry_cleanup ();\n#ifdef VAR_52\n  free (VAR_53);\n#endif /* COMMENT_0 */\n  return VAR_87;\n}",
  "func_graph_path_before": "jerryscript-project/jerryscript/675047d389d4846bd4d88d5006f9e4a506770659/main-unix.c/vul/before/0.json",
  "func": "int\nmain (int argc,\n      char **argv)\n{\n  srand ((unsigned) jerry_port_get_current_time ());\n  JERRY_VLA (const char *, file_names, argc);\n  int files_counter = 0;\n\n  jerry_init_flag_t flags = JERRY_INIT_EMPTY;\n\n  JERRY_VLA (const char *, exec_snapshot_file_names, argc);\n  JERRY_VLA (uint32_t, exec_snapshot_file_indices, argc);\n  int exec_snapshots_count = 0;\n\n  bool is_parse_only = false;\n\n  bool start_debug_server = false;\n  uint16_t debug_port = 5001;\n\n  bool is_repl_mode = false;\n  bool is_wait_mode = false;\n  bool no_prompt = false;\n\n  cli_state_t cli_state = cli_init (main_opts, argc - 1, argv + 1);\n  for (int id = cli_consume_option (&cli_state); id != CLI_OPT_END; id = cli_consume_option (&cli_state))\n  {\n    switch (id)\n    {\n      case OPT_HELP:\n      {\n        cli_help (argv[0], NULL, main_opts);\n        return JERRY_STANDALONE_EXIT_CODE_OK;\n      }\n      case OPT_VERSION:\n      {\n        printf (\"Version: %d.%d%s\\n\", JERRY_API_MAJOR_VERSION, JERRY_API_MINOR_VERSION, JERRY_COMMIT_HASH);\n        return JERRY_STANDALONE_EXIT_CODE_OK;\n      }\n      case OPT_MEM_STATS:\n      {\n        if (check_feature (JERRY_FEATURE_MEM_STATS, cli_state.arg))\n        {\n          jerry_port_default_set_log_level (JERRY_LOG_LEVEL_DEBUG);\n          flags |= JERRY_INIT_MEM_STATS;\n        }\n        break;\n      }\n      case OPT_PARSE_ONLY:\n      {\n        is_parse_only = true;\n        break;\n      }\n      case OPT_SHOW_OP:\n      {\n        if (check_feature (JERRY_FEATURE_PARSER_DUMP, cli_state.arg))\n        {\n          jerry_port_default_set_log_level (JERRY_LOG_LEVEL_DEBUG);\n          flags |= JERRY_INIT_SHOW_OPCODES;\n        }\n        break;\n      }\n      case OPT_SHOW_RE_OP:\n      {\n        if (check_feature (JERRY_FEATURE_REGEXP_DUMP, cli_state.arg))\n        {\n          jerry_port_default_set_log_level (JERRY_LOG_LEVEL_DEBUG);\n          flags |= JERRY_INIT_SHOW_REGEXP_OPCODES;\n        }\n        break;\n      }\n      case OPT_DEBUG_SERVER:\n      {\n        if (check_feature (JERRY_FEATURE_DEBUGGER, cli_state.arg))\n        {\n          start_debug_server = true;\n        }\n        break;\n      }\n      case OPT_DEBUG_PORT:\n      {\n        if (check_feature (JERRY_FEATURE_DEBUGGER, cli_state.arg))\n        {\n          debug_port = (uint16_t) cli_consume_int (&cli_state);\n        }\n        break;\n      }\n      case OPT_DEBUGGER_WAIT_SOURCE:\n      {\n        if (check_feature (JERRY_FEATURE_DEBUGGER, cli_state.arg))\n        {\n          is_wait_mode = true;\n        }\n        break;\n      }\n      case OPT_EXEC_SNAP:\n      {\n        if (check_feature (JERRY_FEATURE_SNAPSHOT_EXEC, cli_state.arg))\n        {\n          exec_snapshot_file_names[exec_snapshots_count] = cli_consume_string (&cli_state);\n          exec_snapshot_file_indices[exec_snapshots_count++] = 0;\n        }\n        else\n        {\n          cli_consume_string (&cli_state);\n        }\n        break;\n      }\n      case OPT_EXEC_SNAP_FUNC:\n      {\n        if (check_feature (JERRY_FEATURE_SNAPSHOT_EXEC, cli_state.arg))\n        {\n          exec_snapshot_file_names[exec_snapshots_count] = cli_consume_string (&cli_state);\n          exec_snapshot_file_indices[exec_snapshots_count++] = (uint32_t) cli_consume_int (&cli_state);\n        }\n        else\n        {\n          cli_consume_string (&cli_state);\n        }\n        break;\n      }\n      case OPT_LOG_LEVEL:\n      {\n        long int log_level = cli_consume_int (&cli_state);\n        check_usage (log_level >= 0 && log_level <= 3,\n                     argv[0], \"Error: invalid value for --log-level: \", cli_state.arg);\n\n        jerry_port_default_set_log_level ((jerry_log_level_t) log_level);\n        break;\n      }\n      case OPT_ABORT_ON_FAIL:\n      {\n        jerry_port_default_set_abort_on_fail (true);\n        break;\n      }\n      case OPT_NO_PROMPT:\n      {\n        no_prompt = true;\n        break;\n      }\n      case CLI_OPT_DEFAULT:\n      {\n        file_names[files_counter++] = cli_consume_string (&cli_state);\n        break;\n      }\n      default:\n      {\n        cli_state.error = \"Internal error\";\n        break;\n      }\n    }\n  }\n\n  if (cli_state.error != NULL)\n  {\n    if (cli_state.arg != NULL)\n    {\n      jerry_port_log (JERRY_LOG_LEVEL_ERROR, \"Error: %s %s\\n\", cli_state.error, cli_state.arg);\n    }\n    else\n    {\n      jerry_port_log (JERRY_LOG_LEVEL_ERROR, \"Error: %s\\n\", cli_state.error);\n    }\n\n    return JERRY_STANDALONE_EXIT_CODE_FAIL;\n  }\n\n  if (files_counter == 0\n      && exec_snapshots_count == 0)\n  {\n    is_repl_mode = true;\n  }\n\n#ifdef JERRY_ENABLE_EXTERNAL_CONTEXT\n\n  jerry_instance_t *instance_p = jerry_create_instance (512*1024, instance_alloc, NULL);\n  jerry_port_default_set_instance (instance_p);\n\n#endif /* JERRY_ENABLE_EXTERNAL_CONTEXT */\n\n  init_engine (flags, start_debug_server, debug_port);\n\n  jerry_value_t ret_value = jerry_create_undefined ();\n\n  if (jerry_is_feature_enabled (JERRY_FEATURE_SNAPSHOT_EXEC))\n  {\n    for (int i = 0; i < exec_snapshots_count; i++)\n    {\n      size_t snapshot_size;\n      const uint32_t *snapshot_p = read_file (exec_snapshot_file_names[i], &snapshot_size);\n\n      if (snapshot_p == NULL)\n      {\n        ret_value = jerry_create_error (JERRY_ERROR_COMMON, (jerry_char_t *) \"Snapshot file load error\");\n      }\n      else\n      {\n        ret_value = jerry_exec_snapshot (snapshot_p,\n                                         snapshot_size,\n                                         exec_snapshot_file_indices[i],\n                                         JERRY_SNAPSHOT_EXEC_COPY_DATA);\n      }\n\n      if (jerry_value_is_error (ret_value))\n      {\n        break;\n      }\n    }\n  }\n\n  while (true)\n  {\n\n    if (!jerry_value_is_error (ret_value))\n    {\n      for (int i = 0; i < files_counter; i++)\n      {\n        size_t source_size;\n        const jerry_char_t *source_p = (jerry_char_t *) read_file (file_names[i], &source_size);\n\n        if (source_p == NULL)\n        {\n          ret_value = jerry_create_error (JERRY_ERROR_COMMON, (jerry_char_t *) \"Source file load error\");\n          break;\n        }\n\n        if (!jerry_is_valid_utf8_string (source_p, (jerry_size_t) source_size))\n        {\n          ret_value = jerry_create_error (JERRY_ERROR_COMMON, (jerry_char_t *) (\"Input must be a valid UTF-8 string.\"));\n          break;\n        }\n\n        ret_value = jerry_parse ((jerry_char_t *) file_names[i],\n                                 strlen (file_names[i]),\n                                 source_p,\n                                 source_size,\n                                 JERRY_PARSE_NO_OPTS);\n\n        if (!jerry_value_is_error (ret_value) && !is_parse_only)\n        {\n          jerry_value_t func_val = ret_value;\n          ret_value = jerry_run (func_val);\n          jerry_release_value (func_val);\n        }\n\n        if (jerry_value_is_error (ret_value))\n        {\n          break;\n        }\n\n        jerry_release_value (ret_value);\n        ret_value = jerry_create_undefined ();\n      }\n    }\n\n    if (is_wait_mode)\n    {\n      is_repl_mode = false;\n\n      if (jerry_is_feature_enabled (JERRY_FEATURE_DEBUGGER))\n      {\n        while (true)\n        {\n          jerry_debugger_wait_for_source_status_t receive_status;\n\n          do\n          {\n            jerry_value_t run_result;\n\n            receive_status = jerry_debugger_wait_for_client_source (wait_for_source_callback,\n                                                                    NULL,\n                                                                    &run_result);\n\n            if (receive_status == JERRY_DEBUGGER_SOURCE_RECEIVE_FAILED)\n            {\n              ret_value = jerry_create_error (JERRY_ERROR_COMMON,\n                                              (jerry_char_t *) \"Connection aborted before source arrived.\");\n            }\n\n            if (receive_status == JERRY_DEBUGGER_SOURCE_END)\n            {\n              jerry_port_log (JERRY_LOG_LEVEL_DEBUG, \"No more client source.\\n\");\n            }\n\n            if (jerry_value_is_abort (run_result))\n            {\n              ret_value = jerry_acquire_value (run_result);\n            }\n\n            jerry_release_value (run_result);\n          }\n          while (receive_status == JERRY_DEBUGGER_SOURCE_RECEIVED);\n\n          if (receive_status != JERRY_DEBUGGER_CONTEXT_RESET_RECEIVED)\n          {\n            break;\n          }\n\n          init_engine (flags, true, debug_port);\n\n          ret_value = jerry_create_undefined ();\n        }\n      }\n\n    }\n\n    bool restart = false;\n\n    if (jerry_is_feature_enabled (JERRY_FEATURE_DEBUGGER) && jerry_value_is_abort (ret_value))\n    {\n      jerry_value_t abort_value = jerry_get_value_from_error (ret_value, false);\n      if (jerry_value_is_string (abort_value))\n      {\n        static const char restart_str[] = \"r353t\";\n\n        jerry_value_t str_val = jerry_value_to_string (abort_value);\n        jerry_size_t str_size = jerry_get_string_size (str_val);\n\n        if (str_size == sizeof (restart_str) - 1)\n        {\n          JERRY_VLA (jerry_char_t, str_buf, str_size);\n          jerry_string_to_char_buffer (str_val, str_buf, str_size);\n          if (memcmp (restart_str, (char *) (str_buf), str_size) == 0)\n          {\n            jerry_release_value (ret_value);\n            restart = true;\n          }\n        }\n\n        jerry_release_value (str_val);\n      }\n\n      jerry_release_value (abort_value);\n    }\n\n    if (!restart)\n    {\n      break;\n    }\n\n    jerry_cleanup ();\n\n    init_engine (flags, true, debug_port);\n\n    ret_value = jerry_create_undefined ();\n  }\n\n  if (is_repl_mode)\n  {\n    const char *prompt = !no_prompt ? \"jerry> \" : \"\";\n    bool is_done = false;\n\n    while (!is_done)\n    {\n      uint8_t *source_buffer_tail = buffer;\n      size_t len = 0;\n\n      printf (\"%s\", prompt);\n\n      /* Read a line */\n      while (true)\n      {\n        if (fread (source_buffer_tail, 1, 1, stdin) != 1 && len == 0)\n        {\n          is_done = true;\n          break;\n        }\n        if (*source_buffer_tail == '\\n')\n        {\n          break;\n        }\n        source_buffer_tail ++;\n        len ++;\n      }\n      *source_buffer_tail = 0;\n\n      if (len > 0)\n      {\n        if (!jerry_is_valid_utf8_string (buffer, (jerry_size_t) len))\n        {\n          jerry_port_log (JERRY_LOG_LEVEL_ERROR, \"Error: Input must be a valid UTF-8 string.\\n\");\n          return JERRY_STANDALONE_EXIT_CODE_FAIL;\n        }\n\n        /* Evaluate the line */\n        jerry_value_t ret_val_eval = jerry_eval (buffer, len, JERRY_PARSE_NO_OPTS);\n\n        if (!jerry_value_is_error (ret_val_eval))\n        {\n          /* Print return value */\n          const jerry_value_t args[] = { ret_val_eval };\n          jerry_value_t ret_val_print = jerryx_handler_print (jerry_create_undefined (),\n                                                              jerry_create_undefined (),\n                                                              args,\n                                                              1);\n          jerry_release_value (ret_val_print);\n          jerry_release_value (ret_val_eval);\n          ret_val_eval = jerry_run_all_enqueued_jobs ();\n\n          if (jerry_value_is_error (ret_val_eval))\n          {\n            ret_val_eval = jerry_get_value_from_error (ret_val_eval, true);\n            print_unhandled_exception (ret_val_eval);\n          }\n        }\n        else\n        {\n          ret_val_eval = jerry_get_value_from_error (ret_val_eval, true);\n          print_unhandled_exception (ret_val_eval);\n        }\n\n        jerry_release_value (ret_val_eval);\n      }\n    }\n  }\n\n  int ret_code = JERRY_STANDALONE_EXIT_CODE_OK;\n\n  if (jerry_value_is_error (ret_value))\n  {\n    ret_value = jerry_get_value_from_error (ret_value, true);\n    print_unhandled_exception (ret_value);\n\n    ret_code = JERRY_STANDALONE_EXIT_CODE_FAIL;\n  }\n\n  jerry_release_value (ret_value);\n\n  ret_value = jerry_run_all_enqueued_jobs ();\n\n  if (jerry_value_is_error (ret_value))\n  {\n    ret_value = jerry_get_value_from_error (ret_value, true);\n    print_unhandled_exception (ret_value);\n    ret_code = JERRY_STANDALONE_EXIT_CODE_FAIL;\n  }\n\n  jerry_release_value (ret_value);\n\n  jerry_cleanup ();\n#ifdef JERRY_ENABLE_EXTERNAL_CONTEXT\n  free (instance_p);\n#endif /* JERRY_ENABLE_EXTERNAL_CONTEXT */\n  return ret_code;\n}",
  "abstract_func": "int\nmain (int VAR_0,\n      char **VAR_1)\n{\n  srand ((unsigned) jerry_port_get_current_time ());\n  VAR_2 (const char *, VAR_3, VAR_0);\n  int VAR_4 = 0;\n\n  jerry_init_flag_t VAR_5 = VAR_6;\n\n  VAR_2 (const char *, VAR_7, VAR_0);\n  VAR_2 (VAR_8, VAR_9, VAR_0);\n  int VAR_10 = 0;\n\n  bool VAR_11 = false;\n\n  bool VAR_12 = false;\n  uint16_t VAR_13 = 5001;\n\n  bool VAR_14 = false;\n  bool VAR_15 = false;\n  bool VAR_16 = false;\n\n  cli_state_t VAR_17 = cli_init (VAR_18, VAR_0 - 1, VAR_1 + 1);\n  for (int VAR_19 = cli_consume_option (&VAR_17); VAR_19 != VAR_20; VAR_19 = cli_consume_option (&VAR_17))\n  {\n    switch (VAR_19)\n    {\n      case VAR_21:\n      {\n        cli_help (VAR_1[0], NULL, VAR_18);\n        return VAR_22;\n      }\n      case VAR_23:\n      {\n        printf (\"Version: %d.%d%s\\n\", VAR_24, VAR_25, VAR_26);\n        return VAR_22;\n      }\n      case VAR_27:\n      {\n        if (check_feature (VAR_28, VAR_17.arg))\n        {\n          jerry_port_default_set_log_level (VAR_29);\n          VAR_5 |= VAR_30;\n        }\n        break;\n      }\n      case VAR_31:\n      {\n        VAR_11 = true;\n        break;\n      }\n      case VAR_32:\n      {\n        if (check_feature (VAR_33, VAR_17.arg))\n        {\n          jerry_port_default_set_log_level (VAR_29);\n          VAR_5 |= VAR_34;\n        }\n        break;\n      }\n      case VAR_35:\n      {\n        if (check_feature (VAR_36, VAR_17.arg))\n        {\n          jerry_port_default_set_log_level (VAR_29);\n          VAR_5 |= VAR_37;\n        }\n        break;\n      }\n      case VAR_38:\n      {\n        if (check_feature (VAR_39, VAR_17.arg))\n        {\n          VAR_12 = true;\n        }\n        break;\n      }\n      case VAR_40:\n      {\n        if (check_feature (VAR_39, VAR_17.arg))\n        {\n          VAR_13 = (uint16_t) cli_consume_int (&VAR_17);\n        }\n        break;\n      }\n      case VAR_41:\n      {\n        if (check_feature (VAR_39, VAR_17.arg))\n        {\n          VAR_15 = true;\n        }\n        break;\n      }\n      case VAR_42:\n      {\n        if (check_feature (VAR_43, VAR_17.arg))\n        {\n          VAR_7[VAR_10] = cli_consume_string (&VAR_17);\n          VAR_9[VAR_10++] = 0;\n        }\n        else\n        {\n          cli_consume_string (&VAR_17);\n        }\n        break;\n      }\n      case VAR_44:\n      {\n        if (check_feature (VAR_43, VAR_17.arg))\n        {\n          VAR_7[VAR_10] = cli_consume_string (&VAR_17);\n          VAR_9[VAR_10++] = (uint32_t) cli_consume_int (&VAR_17);\n        }\n        else\n        {\n          cli_consume_string (&VAR_17);\n        }\n        break;\n      }\n      case VAR_45:\n      {\n        long int VAR_46 = cli_consume_int (&VAR_17);\n        check_usage (VAR_46 >= 0 && VAR_46 <= 3,\n                     VAR_1[0], \"Error: invalid value for --log-level: \", VAR_17.arg);\n\n        jerry_port_default_set_log_level ((jerry_log_level_t) VAR_46);\n        break;\n      }\n      case VAR_47:\n      {\n        jerry_port_default_set_abort_on_fail (true);\n        break;\n      }\n      case VAR_48:\n      {\n        VAR_16 = true;\n        break;\n      }\n      case VAR_49:\n      {\n        VAR_3[VAR_4++] = cli_consume_string (&VAR_17);\n        break;\n      }\n      default:\n      {\n        VAR_17.error = \"Internal error\";\n        break;\n      }\n    }\n  }\n\n  if (VAR_17.error != NULL)\n  {\n    if (VAR_17.arg != NULL)\n    {\n      jerry_port_log (VAR_50, \"Error: %s %s\\n\", VAR_17.error, VAR_17.arg);\n    }\n    else\n    {\n      jerry_port_log (VAR_50, \"Error: %s\\n\", VAR_17.error);\n    }\n\n    return VAR_51;\n  }\n\n  if (VAR_4 == 0\n      && VAR_10 == 0)\n  {\n    VAR_14 = true;\n  }\n\n#ifdef VAR_52\n\n  jerry_instance_t *VAR_53 = jerry_create_instance (512*1024, VAR_54, NULL);\n  jerry_port_default_set_instance (VAR_53);\n\n#endif /* COMMENT_0 */\n\n  init_engine (VAR_5, VAR_12, VAR_13);\n\n  jerry_value_t VAR_55 = jerry_create_undefined ();\n\n  if (jerry_is_feature_enabled (VAR_43))\n  {\n    for (int VAR_56 = 0; VAR_56 < VAR_10; VAR_56++)\n    {\n      size_t VAR_57;\n      const uint32_t *VAR_58 = read_file (VAR_7[VAR_56], &VAR_57);\n\n      if (VAR_58 == NULL)\n      {\n        VAR_55 = jerry_create_error (VAR_59, (jerry_char_t *) \"Snapshot file load error\");\n      }\n      else\n      {\n        VAR_55 = jerry_exec_snapshot (VAR_58,\n                                         VAR_57,\n                                         VAR_9[VAR_56],\n                                         VAR_60);\n      }\n\n      if (jerry_value_is_error (VAR_55))\n      {\n        break;\n      }\n    }\n  }\n\n  while (true)\n  {\n\n    if (!jerry_value_is_error (VAR_55))\n    {\n      for (int VAR_56 = 0; VAR_56 < VAR_4; VAR_56++)\n      {\n        size_t VAR_61;\n        const jerry_char_t *VAR_62 = (jerry_char_t *) read_file (VAR_3[VAR_56], &VAR_61);\n\n        if (VAR_62 == NULL)\n        {\n          VAR_55 = jerry_create_error (VAR_59, (jerry_char_t *) \"Source file load error\");\n          break;\n        }\n\n        if (!jerry_is_valid_utf8_string (VAR_62, (jerry_size_t) VAR_61))\n        {\n          VAR_55 = jerry_create_error (VAR_59, (jerry_char_t *) (\"Input must be a valid UTF-8 string.\"));\n          break;\n        }\n\n        VAR_55 = jerry_parse ((jerry_char_t *) VAR_3[VAR_56],\n                                 strlen (VAR_3[VAR_56]),\n                                 VAR_62,\n                                 VAR_61,\n                                 VAR_63);\n\n        if (!jerry_value_is_error (VAR_55) && !VAR_11)\n        {\n          jerry_value_t VAR_64 = VAR_55;\n          VAR_55 = jerry_run (VAR_64);\n          jerry_release_value (VAR_64);\n        }\n\n        if (jerry_value_is_error (VAR_55))\n        {\n          break;\n        }\n\n        jerry_release_value (VAR_55);\n        VAR_55 = jerry_create_undefined ();\n      }\n    }\n\n    if (VAR_15)\n    {\n      VAR_14 = false;\n\n      if (jerry_is_feature_enabled (VAR_39))\n      {\n        while (true)\n        {\n          jerry_debugger_wait_for_source_status_t VAR_65;\n\n          do\n          {\n            jerry_value_t VAR_66;\n\n            VAR_65 = jerry_debugger_wait_for_client_source (VAR_67,\n                                                                    NULL,\n                                                                    &VAR_66);\n\n            if (VAR_65 == VAR_68)\n            {\n              VAR_55 = jerry_create_error (VAR_59,\n                                              (jerry_char_t *) \"Connection aborted before source arrived.\");\n            }\n\n            if (VAR_65 == VAR_69)\n            {\n              jerry_port_log (VAR_29, \"No more client source.\\n\");\n            }\n\n            if (jerry_value_is_abort (VAR_66))\n            {\n              VAR_55 = jerry_acquire_value (VAR_66);\n            }\n\n            jerry_release_value (VAR_66);\n          }\n          while (VAR_65 == VAR_70);\n\n          if (VAR_65 != VAR_71)\n          {\n            break;\n          }\n\n          init_engine (VAR_5, true, VAR_13);\n\n          VAR_55 = jerry_create_undefined ();\n        }\n      }\n\n    }\n\n    bool VAR_72 = false;\n\n    if (jerry_is_feature_enabled (VAR_39) && jerry_value_is_abort (VAR_55))\n    {\n      jerry_value_t VAR_73 = jerry_get_value_from_error (VAR_55, false);\n      if (jerry_value_is_string (VAR_73))\n      {\n        static const char VAR_74[] = \"r353t\";\n\n        jerry_value_t VAR_75 = jerry_value_to_string (VAR_73);\n        jerry_size_t VAR_76 = jerry_get_string_size (VAR_75);\n\n        if (VAR_76 == sizeof (VAR_74) - 1)\n        {\n          VAR_2 (jerry_char_t, VAR_77, VAR_76);\n          jerry_string_to_char_buffer (VAR_75, VAR_77, VAR_76);\n          if (memcmp (VAR_74, (char *) (VAR_77), VAR_76) == 0)\n          {\n            jerry_release_value (VAR_55);\n            VAR_72 = true;\n          }\n        }\n\n        jerry_release_value (VAR_75);\n      }\n\n      jerry_release_value (VAR_73);\n    }\n\n    if (!VAR_72)\n    {\n      break;\n    }\n\n    jerry_cleanup ();\n\n    init_engine (VAR_5, true, VAR_13);\n\n    VAR_55 = jerry_create_undefined ();\n  }\n\n  if (VAR_14)\n  {\n    const char *VAR_78 = !VAR_16 ? \"jerry> \" : \"\";\n    bool VAR_79 = false;\n\n    while (!VAR_79)\n    {\n      uint8_t *VAR_80 = VAR_81;\n      size_t VAR_82 = 0;\n\n      printf (\"%s\", VAR_78);\n\n      /* COMMENT_1 */\n      while (true)\n      {\n        if (fread (VAR_80, 1, 1, VAR_83) != 1 && VAR_82 == 0)\n        {\n          VAR_79 = true;\n          break;\n        }\n        if (*VAR_80 == '\\n')\n        {\n          break;\n        }\n        VAR_80 ++;\n        VAR_82 ++;\n      }\n      *VAR_80 = 0;\n\n      if (VAR_82 > 0)\n      {\n        if (!jerry_is_valid_utf8_string (VAR_81, (jerry_size_t) VAR_82))\n        {\n          jerry_port_log (VAR_50, \"Error: Input must be a valid UTF-8 string.\\n\");\n          return VAR_51;\n        }\n\n        /* COMMENT_2 */\n        jerry_value_t VAR_84 = jerry_eval (VAR_81, VAR_82, VAR_63);\n\n        if (!jerry_value_is_error (VAR_84))\n        {\n          /* COMMENT_3 */\n          const jerry_value_t VAR_85[] = { VAR_84 };\n          jerry_value_t VAR_86 = jerryx_handler_print (jerry_create_undefined (),\n                                                              jerry_create_undefined (),\n                                                              VAR_85,\n                                                              1);\n          jerry_release_value (VAR_86);\n          jerry_release_value (VAR_84);\n          VAR_84 = jerry_run_all_enqueued_jobs ();\n\n          if (jerry_value_is_error (VAR_84))\n          {\n            VAR_84 = jerry_get_value_from_error (VAR_84, true);\n            print_unhandled_exception (VAR_84);\n          }\n        }\n        else\n        {\n          VAR_84 = jerry_get_value_from_error (VAR_84, true);\n          print_unhandled_exception (VAR_84);\n        }\n\n        jerry_release_value (VAR_84);\n      }\n    }\n  }\n\n  int VAR_87 = VAR_22;\n\n  if (jerry_value_is_error (VAR_55))\n  {\n    VAR_55 = jerry_get_value_from_error (VAR_55, true);\n    print_unhandled_exception (VAR_55);\n\n    VAR_87 = VAR_51;\n  }\n\n  jerry_release_value (VAR_55);\n\n  VAR_55 = jerry_run_all_enqueued_jobs ();\n\n  if (jerry_value_is_error (VAR_55))\n  {\n    VAR_55 = jerry_get_value_from_error (VAR_55, true);\n    print_unhandled_exception (VAR_55);\n    VAR_87 = VAR_51;\n  }\n\n  jerry_release_value (VAR_55);\n\n  jerry_cleanup ();\n#ifdef VAR_52\n  free (VAR_53);\n#endif /* COMMENT_0 */\n  return VAR_87;\n}",
  "func_graph_path": "jerryscript-project/jerryscript/675047d389d4846bd4d88d5006f9e4a506770659/main-unix.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -375,6 +375,12 @@\n \n       if (len > 0)\n       {\n+        if (!jerry_is_valid_utf8_string (buffer, (jerry_size_t) len))\n+        {\n+          jerry_port_log (JERRY_LOG_LEVEL_ERROR, \"Error: Input must be a valid UTF-8 string.\\n\");\n+          return JERRY_STANDALONE_EXIT_CODE_FAIL;\n+        }\n+\n         /* Evaluate the line */\n         jerry_value_t ret_val_eval = jerry_eval (buffer, len, JERRY_PARSE_NO_OPTS);\n ",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "        if (!jerry_is_valid_utf8_string (buffer, (jerry_size_t) len))",
      "        {",
      "          jerry_port_log (JERRY_LOG_LEVEL_ERROR, \"Error: Input must be a valid UTF-8 string.\\n\");",
      "          return JERRY_STANDALONE_EXIT_CODE_FAIL;",
      "        }",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/jerryscript-project/jerryscript/pull/2480",
  "description": {
    "pr_info": {
      "title": "Add a validation before evaluating the source code",
      "number": 2480
    },
    "comment": [
      "This patch checks whether the source code is a valid UTF-8 string before evaluating it in prompt mode.\r\nAlso fixes #2476.\r\n\r\nJerryScript-DCO-1.0-Signed-off-by: Robert Fancsik frobert@inf.u-szeged.hu"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.8\n\nThe patch adds a validation check for UTF-8 input, which serves as a security measure by preventing potential vulnerabilities, though the description doesn't explicitly state it as a security fix."
}