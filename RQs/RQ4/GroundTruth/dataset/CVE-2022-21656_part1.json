{
  "cve_id": "CVE-2022-21656",
  "cwe_ids": [
    "CWE-843"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "envoyproxy/envoy",
  "commit_msg": "Specify type for matching Subject Alternative Name. (#18628)\n\n\r\nSigned-off-by: Pradeep Rao <pcrao@google.com>",
  "commit_hash": "bb95af848c939cfe5b5ee33c5b1770558077e64e",
  "git_url": "https://github.com/envoyproxy/envoy/commit/bb95af848c939cfe5b5ee33c5b1770558077e64e",
  "file_path": "source/extensions/transport_sockets/tls/cert_validator/spiffe/spiffe_validator.cc",
  "func_name": "SPIFFEValidator::matchSubjectAltName",
  "func_before": "bool SPIFFEValidator::matchSubjectAltName(X509& leaf_cert) {\n  bssl::UniquePtr<GENERAL_NAMES> san_names(static_cast<GENERAL_NAMES*>(\n      X509_get_ext_d2i(&leaf_cert, NID_subject_alt_name, nullptr, nullptr)));\n  // We must not have san_names == nullptr here because this function is called after the\n  // SPIFFE cert validation algorithm succeeded, which requires exactly one URI SAN in the leaf\n  // cert.\n  ASSERT(san_names != nullptr,\n         \"san_names should have at least one name after SPIFFE cert validation\");\n\n  // Only match against URI SAN since SPIFFE specification does not restrict values in other SAN\n  // types. See the discussion: https://github.com/envoyproxy/envoy/issues/15392\n  for (const GENERAL_NAME* general_name : san_names.get()) {\n    if (general_name->type == GEN_URI) {\n      const std::string san = Utility::generalNameAsString(general_name);\n      for (const auto& config_san_matcher : subject_alt_name_matchers_) {\n        if (config_san_matcher.match(san)) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}",
  "abstract_func_before": "bool SPIFFEValidator::matchSubjectAltName(X509& VAR_0) {\n  bssl::UniquePtr<GENERAL_NAMES> VAR_1(VAR_2<GENERAL_NAMES*>(\n      X509_get_ext_d2i(&VAR_0, VAR_3, nullptr, nullptr)));\n  /* COMMENT_0 */\n  /* COMMENT_1 */\n  /* COMMENT_2 */\n  ASSERT(VAR_1 != nullptr,\n         \"san_names should have at least one name after SPIFFE cert validation\");\n\n  /* COMMENT_3 */\n  /* COMMENT_4 */\n  for (const GENERAL_NAME* VAR_4 : VAR_1.get()) {\n    if (VAR_4->type == VAR_5) {\n      const std::string VAR_6 = Utility::generalNameAsString(VAR_4);\n      for (const auto& VAR_7 : VAR_8) {\n        if (VAR_7.match(VAR_6)) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}",
  "func_graph_path_before": "envoyproxy/envoy/bb95af848c939cfe5b5ee33c5b1770558077e64e/spiffe_validator.cc/vul/before/0.json",
  "func": "bool SPIFFEValidator::matchSubjectAltName(X509& leaf_cert) {\n  bssl::UniquePtr<GENERAL_NAMES> san_names(static_cast<GENERAL_NAMES*>(\n      X509_get_ext_d2i(&leaf_cert, NID_subject_alt_name, nullptr, nullptr)));\n  // We must not have san_names == nullptr here because this function is called after the\n  // SPIFFE cert validation algorithm succeeded, which requires exactly one URI SAN in the leaf\n  // cert.\n  ASSERT(san_names != nullptr,\n         \"san_names should have at least one name after SPIFFE cert validation\");\n\n  for (const GENERAL_NAME* general_name : san_names.get()) {\n    for (const auto& config_san_matcher : subject_alt_name_matchers_) {\n      if (config_san_matcher->match(general_name)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}",
  "abstract_func": "bool SPIFFEValidator::matchSubjectAltName(X509& VAR_0) {\n  bssl::UniquePtr<GENERAL_NAMES> VAR_1(VAR_2<GENERAL_NAMES*>(\n      X509_get_ext_d2i(&VAR_0, VAR_3, nullptr, nullptr)));\n  /* COMMENT_0 */\n  /* COMMENT_1 */\n  /* COMMENT_2 */\n  ASSERT(VAR_1 != nullptr,\n         \"san_names should have at least one name after SPIFFE cert validation\");\n\n  for (const GENERAL_NAME* VAR_4 : VAR_1.get()) {\n    for (const auto& VAR_5 : VAR_6) {\n      if (VAR_5->match(VAR_4)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}",
  "func_graph_path": "envoyproxy/envoy/bb95af848c939cfe5b5ee33c5b1770558077e64e/spiffe_validator.cc/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -7,15 +7,10 @@\n   ASSERT(san_names != nullptr,\n          \"san_names should have at least one name after SPIFFE cert validation\");\n \n-  // Only match against URI SAN since SPIFFE specification does not restrict values in other SAN\n-  // types. See the discussion: https://github.com/envoyproxy/envoy/issues/15392\n   for (const GENERAL_NAME* general_name : san_names.get()) {\n-    if (general_name->type == GEN_URI) {\n-      const std::string san = Utility::generalNameAsString(general_name);\n-      for (const auto& config_san_matcher : subject_alt_name_matchers_) {\n-        if (config_san_matcher.match(san)) {\n-          return true;\n-        }\n+    for (const auto& config_san_matcher : subject_alt_name_matchers_) {\n+      if (config_san_matcher->match(general_name)) {\n+        return true;\n       }\n     }\n   }",
  "diff_line_info": {
    "deleted_lines": [
      "  // Only match against URI SAN since SPIFFE specification does not restrict values in other SAN",
      "  // types. See the discussion: https://github.com/envoyproxy/envoy/issues/15392",
      "    if (general_name->type == GEN_URI) {",
      "      const std::string san = Utility::generalNameAsString(general_name);",
      "      for (const auto& config_san_matcher : subject_alt_name_matchers_) {",
      "        if (config_san_matcher.match(san)) {",
      "          return true;",
      "        }"
    ],
    "added_lines": [
      "    for (const auto& config_san_matcher : subject_alt_name_matchers_) {",
      "      if (config_san_matcher->match(general_name)) {",
      "        return true;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/envoyproxy/envoy/pull/18628",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/envoyproxy/envoy/pull/18628: 403 Client Error: Forbidden for url: https://api.github.com/repos/envoyproxy/envoy/pulls/18628",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.9."
}