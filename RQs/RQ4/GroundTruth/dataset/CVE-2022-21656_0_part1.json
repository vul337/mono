{
  "cve_id": "CVE-2022-21656",
  "cwe_ids": [
    "CWE-843"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "envoyproxy/envoy",
  "commit_msg": "Specify type for matching Subject Alternative Name. (#18628)\n\n\r\nSigned-off-by: Pradeep Rao <pcrao@google.com>",
  "commit_hash": "bb95af848c939cfe5b5ee33c5b1770558077e64e",
  "git_url": "https://github.com/envoyproxy/envoy/commit/bb95af848c939cfe5b5ee33c5b1770558077e64e",
  "file_path": "source/extensions/transport_sockets/tls/cert_validator/spiffe/spiffe_validator.cc",
  "func_name": "SPIFFEValidator::SPIFFEValidator",
  "func_before": "SPIFFEValidator::SPIFFEValidator(const Envoy::Ssl::CertificateValidationContextConfig* config,\n                                 SslStats& stats, TimeSource& time_source)\n    : stats_(stats), time_source_(time_source) {\n  ASSERT(config != nullptr);\n  allow_expired_certificate_ = config->allowExpiredCertificate();\n\n  SPIFFEConfig message;\n  Config::Utility::translateOpaqueConfig(config->customValidatorConfig().value().typed_config(),\n                                         ProtobufMessage::getStrictValidationVisitor(), message);\n\n  if (!config->subjectAltNameMatchers().empty()) {\n    for (const auto& matcher : config->subjectAltNameMatchers()) {\n      subject_alt_name_matchers_.push_back(Matchers::StringMatcherImpl(matcher));\n    }\n  }\n\n  const auto size = message.trust_domains().size();\n  trust_bundle_stores_.reserve(size);\n  for (auto& domain : message.trust_domains()) {\n    if (trust_bundle_stores_.find(domain.name()) != trust_bundle_stores_.end()) {\n      throw EnvoyException(absl::StrCat(\n          \"Multiple trust bundles are given for one trust domain for \", domain.name()));\n    }\n\n    auto cert = Config::DataSource::read(domain.trust_bundle(), true, config->api());\n    bssl::UniquePtr<BIO> bio(BIO_new_mem_buf(const_cast<char*>(cert.data()), cert.size()));\n    RELEASE_ASSERT(bio != nullptr, \"\");\n    bssl::UniquePtr<STACK_OF(X509_INFO)> list(\n        PEM_X509_INFO_read_bio(bio.get(), nullptr, nullptr, nullptr));\n    if (list == nullptr || sk_X509_INFO_num(list.get()) == 0) {\n      throw EnvoyException(\n          absl::StrCat(\"Failed to load trusted CA certificate for \", domain.name()));\n    }\n\n    auto store = X509StorePtr(X509_STORE_new());\n    bool has_crl = false;\n    bool ca_loaded = false;\n    for (const X509_INFO* item : list.get()) {\n      if (item->x509) {\n        X509_STORE_add_cert(store.get(), item->x509);\n        ca_certs_.push_back(bssl::UniquePtr<X509>(item->x509));\n        X509_up_ref(item->x509);\n        if (!ca_loaded) {\n          // TODO: With the current interface, we cannot return the multiple\n          // cert information on getCaCertInformation method.\n          // So temporarily we return the first CA's info here.\n          ca_loaded = true;\n          ca_file_name_ = absl::StrCat(domain.name(), \": \",\n                                       domain.trust_bundle().filename().empty()\n                                           ? \"<inline>\"\n                                           : domain.trust_bundle().filename());\n        }\n      }\n\n      if (item->crl) {\n        has_crl = true;\n        X509_STORE_add_crl(store.get(), item->crl);\n      }\n    }\n    if (has_crl) {\n      X509_STORE_set_flags(store.get(), X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL);\n    }\n    trust_bundle_stores_[domain.name()] = std::move(store);\n  }\n}",
  "abstract_func_before": "SPIFFEValidator::SPIFFEValidator(const Envoy::Ssl::CertificateValidationContextConfig* VAR_0,\n                                 SslStats& VAR_1, TimeSource& VAR_2)\n    : stats_(VAR_1), time_source_(VAR_2) {\n  ASSERT(VAR_0 != nullptr);\n  VAR_3 = VAR_0->allowExpiredCertificate();\n\n  SPIFFEConfig VAR_4;\n  Config::Utility::translateOpaqueConfig(VAR_0->customValidatorConfig().value().typed_config(),\n                                         ProtobufMessage::getStrictValidationVisitor(), VAR_4);\n\n  if (!VAR_0->subjectAltNameMatchers().empty()) {\n    for (const auto& VAR_5 : VAR_0->subjectAltNameMatchers()) {\n      VAR_6.push_back(Matchers::StringMatcherImpl(VAR_5));\n    }\n  }\n\n  const auto VAR_7 = VAR_4.trust_domains().size();\n  VAR_8.reserve(VAR_7);\n  for (auto& VAR_9 : VAR_4.trust_domains()) {\n    if (VAR_8.find(VAR_9.name()) != VAR_8.end()) {\n      throw EnvoyException(absl::StrCat(\n          \"Multiple trust bundles are given for one trust domain for \", VAR_9.name()));\n    }\n\n    auto VAR_10 = Config::DataSource::read(VAR_9.trust_bundle(), true, VAR_0->api());\n    bssl::UniquePtr<BIO> VAR_11(BIO_new_mem_buf(VAR_12<char*>(VAR_10.data()), VAR_10.size()));\n    RELEASE_ASSERT(VAR_11 != nullptr, \"\");\n    bssl::UniquePtr<STACK_OF(X509_INFO)> VAR_13(\n        PEM_X509_INFO_read_bio(VAR_11.get(), nullptr, nullptr, nullptr));\n    if (VAR_13 == nullptr || sk_X509_INFO_num(VAR_13.get()) == 0) {\n      throw EnvoyException(\n          absl::StrCat(\"Failed to load trusted CA certificate for \", VAR_9.name()));\n    }\n\n    auto VAR_14 = X509StorePtr(X509_STORE_new());\n    bool VAR_15 = false;\n    bool VAR_16 = false;\n    for (const X509_INFO* VAR_17 : VAR_13.get()) {\n      if (VAR_17->x509) {\n        X509_STORE_add_cert(VAR_14.get(), VAR_17->x509);\n        VAR_18.push_back(bssl::UniquePtr<X509>(VAR_17->x509));\n        X509_up_ref(VAR_17->x509);\n        if (!VAR_16) {\n          /* COMMENT_0 */\n          /* COMMENT_1 */\n          /* COMMENT_2 */\n          VAR_16 = true;\n          VAR_19 = absl::StrCat(VAR_9.name(), \": \",\n                                       VAR_9.trust_bundle().filename().empty()\n                                           ? \"<inline>\"\n                                           : VAR_9.trust_bundle().filename());\n        }\n      }\n\n      if (VAR_17->crl) {\n        VAR_15 = true;\n        X509_STORE_add_crl(VAR_14.get(), VAR_17->crl);\n      }\n    }\n    if (VAR_15) {\n      X509_STORE_set_flags(VAR_14.get(), VAR_20 | VAR_21);\n    }\n    VAR_8[VAR_9.name()] = std::move(VAR_14);\n  }\n}",
  "func_graph_path_before": "envoyproxy/envoy/bb95af848c939cfe5b5ee33c5b1770558077e64e/spiffe_validator.cc/vul/before/1.json",
  "func": "SPIFFEValidator::SPIFFEValidator(const Envoy::Ssl::CertificateValidationContextConfig* config,\n                                 SslStats& stats, TimeSource& time_source)\n    : stats_(stats), time_source_(time_source) {\n  ASSERT(config != nullptr);\n  allow_expired_certificate_ = config->allowExpiredCertificate();\n\n  SPIFFEConfig message;\n  Config::Utility::translateOpaqueConfig(config->customValidatorConfig().value().typed_config(),\n                                         ProtobufMessage::getStrictValidationVisitor(), message);\n\n  if (!config->subjectAltNameMatchers().empty()) {\n    for (const auto& matcher : config->subjectAltNameMatchers()) {\n      if (matcher.san_type() ==\n          envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::URI) {\n        // Only match against URI SAN since SPIFFE specification does not restrict values in other\n        // SAN types. See the discussion: https://github.com/envoyproxy/envoy/issues/15392\n        // TODO(pradeepcrao): Throw an exception when a non-URI matcher is encountered after the\n        // deprecated field match_subject_alt_names is removed\n        subject_alt_name_matchers_.emplace_back(createStringSanMatcher(matcher));\n      }\n    }\n  }\n\n  const auto size = message.trust_domains().size();\n  trust_bundle_stores_.reserve(size);\n  for (auto& domain : message.trust_domains()) {\n    if (trust_bundle_stores_.find(domain.name()) != trust_bundle_stores_.end()) {\n      throw EnvoyException(absl::StrCat(\n          \"Multiple trust bundles are given for one trust domain for \", domain.name()));\n    }\n\n    auto cert = Config::DataSource::read(domain.trust_bundle(), true, config->api());\n    bssl::UniquePtr<BIO> bio(BIO_new_mem_buf(const_cast<char*>(cert.data()), cert.size()));\n    RELEASE_ASSERT(bio != nullptr, \"\");\n    bssl::UniquePtr<STACK_OF(X509_INFO)> list(\n        PEM_X509_INFO_read_bio(bio.get(), nullptr, nullptr, nullptr));\n    if (list == nullptr || sk_X509_INFO_num(list.get()) == 0) {\n      throw EnvoyException(\n          absl::StrCat(\"Failed to load trusted CA certificate for \", domain.name()));\n    }\n\n    auto store = X509StorePtr(X509_STORE_new());\n    bool has_crl = false;\n    bool ca_loaded = false;\n    for (const X509_INFO* item : list.get()) {\n      if (item->x509) {\n        X509_STORE_add_cert(store.get(), item->x509);\n        ca_certs_.push_back(bssl::UniquePtr<X509>(item->x509));\n        X509_up_ref(item->x509);\n        if (!ca_loaded) {\n          // TODO: With the current interface, we cannot return the multiple\n          // cert information on getCaCertInformation method.\n          // So temporarily we return the first CA's info here.\n          ca_loaded = true;\n          ca_file_name_ = absl::StrCat(domain.name(), \": \",\n                                       domain.trust_bundle().filename().empty()\n                                           ? \"<inline>\"\n                                           : domain.trust_bundle().filename());\n        }\n      }\n\n      if (item->crl) {\n        has_crl = true;\n        X509_STORE_add_crl(store.get(), item->crl);\n      }\n    }\n    if (has_crl) {\n      X509_STORE_set_flags(store.get(), X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL);\n    }\n    trust_bundle_stores_[domain.name()] = std::move(store);\n  }\n}",
  "abstract_func": "SPIFFEValidator::SPIFFEValidator(const Envoy::Ssl::CertificateValidationContextConfig* VAR_0,\n                                 SslStats& VAR_1, TimeSource& VAR_2)\n    : stats_(VAR_1), time_source_(VAR_2) {\n  ASSERT(VAR_0 != nullptr);\n  VAR_3 = VAR_0->allowExpiredCertificate();\n\n  SPIFFEConfig VAR_4;\n  Config::Utility::translateOpaqueConfig(VAR_0->customValidatorConfig().value().typed_config(),\n                                         ProtobufMessage::getStrictValidationVisitor(), VAR_4);\n\n  if (!VAR_0->subjectAltNameMatchers().empty()) {\n    for (const auto& VAR_5 : VAR_0->subjectAltNameMatchers()) {\n      if (VAR_5.san_type() ==\n          envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::URI) {\n        /* COMMENT_0 */\n        /* COMMENT_1 */\n        /* COMMENT_2 */\n        /* COMMENT_3 */\n        VAR_6.emplace_back(createStringSanMatcher(VAR_5));\n      }\n    }\n  }\n\n  const auto VAR_7 = VAR_4.trust_domains().size();\n  VAR_8.reserve(VAR_7);\n  for (auto& VAR_9 : VAR_4.trust_domains()) {\n    if (VAR_8.find(VAR_9.name()) != VAR_8.end()) {\n      throw EnvoyException(absl::StrCat(\n          \"Multiple trust bundles are given for one trust domain for \", VAR_9.name()));\n    }\n\n    auto VAR_10 = Config::DataSource::read(VAR_9.trust_bundle(), true, VAR_0->api());\n    bssl::UniquePtr<BIO> VAR_11(BIO_new_mem_buf(VAR_12<char*>(VAR_10.data()), VAR_10.size()));\n    RELEASE_ASSERT(VAR_11 != nullptr, \"\");\n    bssl::UniquePtr<STACK_OF(X509_INFO)> VAR_13(\n        PEM_X509_INFO_read_bio(VAR_11.get(), nullptr, nullptr, nullptr));\n    if (VAR_13 == nullptr || sk_X509_INFO_num(VAR_13.get()) == 0) {\n      throw EnvoyException(\n          absl::StrCat(\"Failed to load trusted CA certificate for \", VAR_9.name()));\n    }\n\n    auto VAR_14 = X509StorePtr(X509_STORE_new());\n    bool VAR_15 = false;\n    bool VAR_16 = false;\n    for (const X509_INFO* VAR_17 : VAR_13.get()) {\n      if (VAR_17->x509) {\n        X509_STORE_add_cert(VAR_14.get(), VAR_17->x509);\n        VAR_18.push_back(bssl::UniquePtr<X509>(VAR_17->x509));\n        X509_up_ref(VAR_17->x509);\n        if (!VAR_16) {\n          /* COMMENT_4 */\n          /* COMMENT_5 */\n          /* COMMENT_6 */\n          VAR_16 = true;\n          VAR_19 = absl::StrCat(VAR_9.name(), \": \",\n                                       VAR_9.trust_bundle().filename().empty()\n                                           ? \"<inline>\"\n                                           : VAR_9.trust_bundle().filename());\n        }\n      }\n\n      if (VAR_17->crl) {\n        VAR_15 = true;\n        X509_STORE_add_crl(VAR_14.get(), VAR_17->crl);\n      }\n    }\n    if (VAR_15) {\n      X509_STORE_set_flags(VAR_14.get(), VAR_20 | VAR_21);\n    }\n    VAR_8[VAR_9.name()] = std::move(VAR_14);\n  }\n}",
  "func_graph_path": "envoyproxy/envoy/bb95af848c939cfe5b5ee33c5b1770558077e64e/spiffe_validator.cc/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -10,7 +10,14 @@\n \n   if (!config->subjectAltNameMatchers().empty()) {\n     for (const auto& matcher : config->subjectAltNameMatchers()) {\n-      subject_alt_name_matchers_.push_back(Matchers::StringMatcherImpl(matcher));\n+      if (matcher.san_type() ==\n+          envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::URI) {\n+        // Only match against URI SAN since SPIFFE specification does not restrict values in other\n+        // SAN types. See the discussion: https://github.com/envoyproxy/envoy/issues/15392\n+        // TODO(pradeepcrao): Throw an exception when a non-URI matcher is encountered after the\n+        // deprecated field match_subject_alt_names is removed\n+        subject_alt_name_matchers_.emplace_back(createStringSanMatcher(matcher));\n+      }\n     }\n   }\n ",
  "diff_line_info": {
    "deleted_lines": [
      "      subject_alt_name_matchers_.push_back(Matchers::StringMatcherImpl(matcher));"
    ],
    "added_lines": [
      "      if (matcher.san_type() ==",
      "          envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::URI) {",
      "        // Only match against URI SAN since SPIFFE specification does not restrict values in other",
      "        // SAN types. See the discussion: https://github.com/envoyproxy/envoy/issues/15392",
      "        // TODO(pradeepcrao): Throw an exception when a non-URI matcher is encountered after the",
      "        // deprecated field match_subject_alt_names is removed",
      "        subject_alt_name_matchers_.emplace_back(createStringSanMatcher(matcher));",
      "      }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/envoyproxy/envoy/pull/18628",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/envoyproxy/envoy/pull/18628: 403 Client Error: Forbidden for url: https://api.github.com/repos/envoyproxy/envoy/pulls/18628",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.7,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.7\n\n**Step-by-Step Explanation:**\n\n1. **Input Analysis**: The commit message and code diff focus on handling Subject Alternative Name matchers, specifically for URIs as per SPIFFE guidelines. No security-related keywords are present.\n2. **Consistency Check**: The commit message matches the code changes, which involve adding a check for URI SAN type.\n3. **Purpose Evaluation**: The changes are functional, refining how SANs are validated rather than fixing a security issue.\n4. **Security Assessment**: No evidence of a security fix, as the patch doesn't address vulnerabilities.\n5. **Non-Security Classification**: Falls under defect remediation as it improves the validation logic, a core feature.\n\n**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.7"
}