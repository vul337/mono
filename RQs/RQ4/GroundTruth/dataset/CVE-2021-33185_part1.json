{
  "cve_id": "CVE-2021-33185",
  "cwe_ids": [
    "CWE-120"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:N/A:N",
  "cvss_is_v3": false,
  "repo_name": "SerenityOS/serenity",
  "commit_msg": "AK: Don't read past the end in BitmapView::count_in_range()\n\nThe current code is factored such that reads to the entirety of the last\nbyte should be dropped. This was relying on the fact that last would be\none past the end in that case. Instead of actually reading that byte\nwhen it's completely out of bounds of the bitmask, just skip reads that\nwould be invalid. Add more tests to make sure that the behavior is\ncorrect for byte aligned reads of byte aligned bitmaps.",
  "commit_hash": "e8cc105a54ca7ab1859dbb1afee87c5d95c0284a",
  "git_url": "https://github.com/SerenityOS/serenity/commit/e8cc105a54ca7ab1859dbb1afee87c5d95c0284a",
  "file_path": "AK/BitmapView.h",
  "func_name": "count_in_range",
  "func_before": "size_t count_in_range(size_t start, size_t len, bool value) const\n    {\n        VERIFY(start < m_size);\n        VERIFY(start + len <= m_size);\n        if (len == 0)\n            return 0;\n\n        static const u8 bitmask_first_byte[8] = { 0xFF, 0xFE, 0xFC, 0xF8, 0xF0, 0xE0, 0xC0, 0x80 };\n        static const u8 bitmask_last_byte[8] = { 0x0, 0x1, 0x3, 0x7, 0xF, 0x1F, 0x3F, 0x7F };\n\n        size_t count;\n        const u8* first = &m_data[start / 8];\n        const u8* last = &m_data[(start + len) / 8];\n        u8 byte = *first;\n        byte &= bitmask_first_byte[start % 8];\n        if (first == last) {\n            byte &= bitmask_last_byte[(start + len) % 8];\n            count = __builtin_popcount(byte);\n        } else {\n            count = __builtin_popcount(byte);\n            byte = *last;\n            byte &= bitmask_last_byte[(start + len) % 8];\n            count += __builtin_popcount(byte);\n            if (++first < last) {\n                const u32* ptr32 = (const u32*)(((FlatPtr)first + sizeof(u32) - 1) & ~(sizeof(u32) - 1));\n                if ((const u8*)ptr32 > last)\n                    ptr32 = (const u32*)last;\n                while (first < (const u8*)ptr32) {\n                    count += __builtin_popcount(*first);\n                    first++;\n                }\n                const u32* last32 = (const u32*)((FlatPtr)last & ~(sizeof(u32) - 1));\n                while (ptr32 < last32) {\n                    count += __builtin_popcountl(*ptr32);\n                    ptr32++;\n                }\n                for (first = (const u8*)ptr32; first < last; first++)\n                    count += __builtin_popcount(*first);\n            }\n        }\n\n        if (!value)\n            count = len - count;\n        return count;\n    }",
  "abstract_func_before": "size_t count_in_range(size_t VAR_0, size_t VAR_1, bool VAR_2) VAR_3\n    {\n        VERIFY(VAR_0 < VAR_4);\n        VERIFY(VAR_0 + VAR_1 <= VAR_4);\n        if (VAR_1 == 0)\n            return 0;\n\n        static const u8 VAR_5[8] = { 0xFF, 0xFE, 0xFC, 0xF8, 0xF0, 0xE0, 0xC0, 0x80 };\n        static const u8 VAR_6[8] = { 0x0, 0x1, 0x3, 0x7, 0xF, 0x1F, 0x3F, 0x7F };\n\n        size_t VAR_7;\n        const u8* VAR_8 = &VAR_9[VAR_0 / 8];\n        const u8* VAR_10 = &VAR_9[(VAR_0 + VAR_1) / 8];\n        u8 VAR_11 = *VAR_8;\n        VAR_11 &= VAR_5[VAR_0 % 8];\n        if (VAR_8 == VAR_10) {\n            VAR_11 &= VAR_6[(VAR_0 + VAR_1) % 8];\n            VAR_7 = __builtin_popcount(VAR_11);\n        } else {\n            VAR_7 = __builtin_popcount(VAR_11);\n            VAR_11 = *VAR_10;\n            VAR_11 &= VAR_6[(VAR_0 + VAR_1) % 8];\n            VAR_7 += __builtin_popcount(VAR_11);\n            if (++VAR_8 < VAR_10) {\n                const u32* VAR_12 = (const u32*)(((FlatPtr)VAR_8 + sizeof(u32) - 1) & ~(sizeof(u32) - 1));\n                if ((const u8*)VAR_12 > VAR_10)\n                    VAR_12 = (const u32*)VAR_10;\n                while (VAR_8 < (const u8*)VAR_12) {\n                    VAR_7 += __builtin_popcount(*VAR_8);\n                    VAR_8++;\n                }\n                const u32* VAR_13 = (const u32*)((FlatPtr)VAR_10 & ~(sizeof(u32) - 1));\n                while (VAR_12 < VAR_13) {\n                    VAR_7 += __builtin_popcountl(*VAR_12);\n                    VAR_12++;\n                }\n                for (VAR_8 = (const u8*)VAR_12; VAR_8 < VAR_10; VAR_8++)\n                    VAR_7 += __builtin_popcount(*VAR_8);\n            }\n        }\n\n        if (!VAR_2)\n            VAR_7 = VAR_1 - VAR_7;\n        return VAR_7;\n    }",
  "func_graph_path_before": null,
  "func": "size_t count_in_range(size_t start, size_t len, bool value) const\n    {\n        VERIFY(start < m_size);\n        VERIFY(start + len <= m_size);\n        if (len == 0)\n            return 0;\n\n        static const u8 bitmask_first_byte[8] = { 0xFF, 0xFE, 0xFC, 0xF8, 0xF0, 0xE0, 0xC0, 0x80 };\n        static const u8 bitmask_last_byte[8] = { 0x00, 0x1, 0x3, 0x7, 0xF, 0x1F, 0x3F, 0x7F };\n\n        size_t count;\n        const u8* first = &m_data[start / 8];\n        const u8* last = &m_data[(start + len) / 8];\n        u8 byte = *first;\n        byte &= bitmask_first_byte[start % 8];\n        if (first == last) {\n            byte &= bitmask_last_byte[(start + len) % 8];\n            count = __builtin_popcount(byte);\n        } else {\n            count = __builtin_popcount(byte);\n            // Don't access *last if it's out of bounds\n            if (last < &m_data[size_in_bytes()]) {\n                byte = *last;\n                byte &= bitmask_last_byte[(start + len) % 8];\n                count += __builtin_popcount(byte);\n            }\n            if (++first < last) {\n                const u32* ptr32 = (const u32*)(((FlatPtr)first + sizeof(u32) - 1) & ~(sizeof(u32) - 1));\n                if ((const u8*)ptr32 > last)\n                    ptr32 = (const u32*)last;\n                while (first < (const u8*)ptr32) {\n                    count += __builtin_popcount(*first);\n                    first++;\n                }\n                const u32* last32 = (const u32*)((FlatPtr)last & ~(sizeof(u32) - 1));\n                while (ptr32 < last32) {\n                    count += __builtin_popcountl(*ptr32);\n                    ptr32++;\n                }\n                for (first = (const u8*)ptr32; first < last; first++)\n                    count += __builtin_popcount(*first);\n            }\n        }\n\n        if (!value)\n            count = len - count;\n        return count;\n    }",
  "abstract_func": "size_t count_in_range(size_t VAR_0, size_t VAR_1, bool VAR_2) VAR_3\n    {\n        VERIFY(VAR_0 < VAR_4);\n        VERIFY(VAR_0 + VAR_1 <= VAR_4);\n        if (VAR_1 == 0)\n            return 0;\n\n        static const u8 VAR_5[8] = { 0xFF, 0xFE, 0xFC, 0xF8, 0xF0, 0xE0, 0xC0, 0x80 };\n        static const u8 VAR_6[8] = { 0x00, 0x1, 0x3, 0x7, 0xF, 0x1F, 0x3F, 0x7F };\n\n        size_t VAR_7;\n        const u8* VAR_8 = &VAR_9[VAR_0 / 8];\n        const u8* VAR_10 = &VAR_9[(VAR_0 + VAR_1) / 8];\n        u8 VAR_11 = *VAR_8;\n        VAR_11 &= VAR_5[VAR_0 % 8];\n        if (VAR_8 == VAR_10) {\n            VAR_11 &= VAR_6[(VAR_0 + VAR_1) % 8];\n            VAR_7 = __builtin_popcount(VAR_11);\n        } else {\n            VAR_7 = __builtin_popcount(VAR_11);\n            /* COMMENT_0 */\n            if (VAR_10 < &VAR_9[size_in_bytes()]) {\n                VAR_11 = *VAR_10;\n                VAR_11 &= VAR_6[(VAR_0 + VAR_1) % 8];\n                VAR_7 += __builtin_popcount(VAR_11);\n            }\n            if (++VAR_8 < VAR_10) {\n                const u32* VAR_12 = (const u32*)(((FlatPtr)VAR_8 + sizeof(u32) - 1) & ~(sizeof(u32) - 1));\n                if ((const u8*)VAR_12 > VAR_10)\n                    VAR_12 = (const u32*)VAR_10;\n                while (VAR_8 < (const u8*)VAR_12) {\n                    VAR_7 += __builtin_popcount(*VAR_8);\n                    VAR_8++;\n                }\n                const u32* VAR_13 = (const u32*)((FlatPtr)VAR_10 & ~(sizeof(u32) - 1));\n                while (VAR_12 < VAR_13) {\n                    VAR_7 += __builtin_popcountl(*VAR_12);\n                    VAR_12++;\n                }\n                for (VAR_8 = (const u8*)VAR_12; VAR_8 < VAR_10; VAR_8++)\n                    VAR_7 += __builtin_popcount(*VAR_8);\n            }\n        }\n\n        if (!VAR_2)\n            VAR_7 = VAR_1 - VAR_7;\n        return VAR_7;\n    }",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,7 @@\n             return 0;\n \n         static const u8 bitmask_first_byte[8] = { 0xFF, 0xFE, 0xFC, 0xF8, 0xF0, 0xE0, 0xC0, 0x80 };\n-        static const u8 bitmask_last_byte[8] = { 0x0, 0x1, 0x3, 0x7, 0xF, 0x1F, 0x3F, 0x7F };\n+        static const u8 bitmask_last_byte[8] = { 0x00, 0x1, 0x3, 0x7, 0xF, 0x1F, 0x3F, 0x7F };\n \n         size_t count;\n         const u8* first = &m_data[start / 8];\n@@ -18,9 +18,12 @@\n             count = __builtin_popcount(byte);\n         } else {\n             count = __builtin_popcount(byte);\n-            byte = *last;\n-            byte &= bitmask_last_byte[(start + len) % 8];\n-            count += __builtin_popcount(byte);\n+            // Don't access *last if it's out of bounds\n+            if (last < &m_data[size_in_bytes()]) {\n+                byte = *last;\n+                byte &= bitmask_last_byte[(start + len) % 8];\n+                count += __builtin_popcount(byte);\n+            }\n             if (++first < last) {\n                 const u32* ptr32 = (const u32*)(((FlatPtr)first + sizeof(u32) - 1) & ~(sizeof(u32) - 1));\n                 if ((const u8*)ptr32 > last)",
  "diff_line_info": {
    "deleted_lines": [
      "        static const u8 bitmask_last_byte[8] = { 0x0, 0x1, 0x3, 0x7, 0xF, 0x1F, 0x3F, 0x7F };",
      "            byte = *last;",
      "            byte &= bitmask_last_byte[(start + len) % 8];",
      "            count += __builtin_popcount(byte);"
    ],
    "added_lines": [
      "        static const u8 bitmask_last_byte[8] = { 0x00, 0x1, 0x3, 0x7, 0xF, 0x1F, 0x3F, 0x7F };",
      "            // Don't access *last if it's out of bounds",
      "            if (last < &m_data[size_in_bytes()]) {",
      "                byte = *last;",
      "                byte &= bitmask_last_byte[(start + len) % 8];",
      "                count += __builtin_popcount(byte);",
      "            }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/SerenityOS/serenity/pull/7157",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/SerenityOS/serenity/pull/7157: 403 Client Error: Forbidden for url: https://api.github.com/repos/SerenityOS/serenity/pulls/7157",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "Final Classification: Security Vulnerability Fix; Confidence: 1.0"
}