{
  "cve_id": "CVE-2017-11704",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "libming",
  "commit_msg": "Fix various overflows in util/ (CVE-2017-11704)\n\n* Add a check in decompileIF to avoid overflows.\n\n    Avoid processing block when sact->numActions is 0, as\n    sact->numActions - 1 may be used as index when accessing\n    sact->Actions array.\n\n* Fix overflow in readUInt32.\n\n    o Fix declaration of readUInt32 and readSInt32 in util/read.h:\n      return types should be unsigned long and long.\n    o readUInt32: Avoid calling all readUInt8(f) in one line, order of\n      evaluation is not guaranteed in the C standard.\n    o readUInt32: Cast result of readUInt8(f) before << 24 to avoid\n      overflow.\n\n* Fix overflow in readMovie.\n\n    length has int type but according to the specification it should be able\n    to store unsigned 32bit numbers. Instead of changing the type of\n    length, which would be a major refactoring, we verify that the value\n    returned by readUInt32 is smaller than INT_MAX and update length if\n    it's the case. Otherwise we print a warning and ignore the block.\n\nThis commit fixes CVE-2017-11704.",
  "commit_hash": "7fed314748be817c7ded84854acb649786625cb6",
  "git_url": "https://github.com/libming/libming/commit/7fed314748be817c7ded84854acb649786625cb6",
  "file_path": "util/main.c",
  "func_name": "readMovie",
  "func_before": "static void readMovie(FILE *f)\n{\n\tint block, type, blockstart, blockoffset, length, nextFrame=0;\n\tSWF_Parserstruct *blockp;\n\tfor (;;)\n\t{\n\t\tblockoffset = fileOffset;\n\n\t\t// printf (\"Block offset: %d %d\\n\", fileOffset, m.size);\n\n\t\tif(filelen_check_fails(2))\n\t\t\tbreak;\n\t\tblock = readUInt16 (f);\n\t\ttype = block >> 6;\n\n\t\tlength = block & ((1 << 6) - 1);\n\n\t\tif (length == 63)\t\t/* it's a long block. */ \n\t\t{\n\t\t\tif(filelen_check_fails(4))\n\t\t\t\tbreak;\n\t\t\tlength = readUInt32 (f);\n\t\t}\n\t\t\n\t\t//      printf (\"Found Block: %s (%i), %i bytes\\n\", blockName (type), type, length);\n\t\tblockstart = fileOffset;\n\t\tnextFrame = fileOffset+length;\n\t\t\n\t\tif(filelen_check_fails(length))\n\t\t\tbreak;\n\t\tblockp= blockParse(f, length, type);\n\n\t\tif( ftell(f) != nextFrame ) \n\t\t{\n\t\t\t// will SEEK_SET later, so this is not a critical error\n\t\t        SWF_warn(\" Stream out of sync after parse of blocktype %d (%s).\"\n\t\t\t\t\" %ld but expecting %d.\\n\", type, blockName(type),\n\t\t\t\tftell(f),nextFrame);\n\t\t}\n\n\t\tif( blockp ) \n\t\t{\n\t\t\toutputBlock( type, blockp, f);\n\t\t\tfree(blockp);\t\n\t\t} else {\n\t\t\tSWF_warn(\"Error parsing block (unknown block type: %d, length %d)\\n\", \n\t\t\t\ttype, length);\n\t\t}\n\n\t\tif (type == 0 || fileOffset >= m.size)\n\t\t\tbreak;\n\t\n\t\tfseek(f, nextFrame, SEEK_SET);\n\t\tfileOffset = ftell(f);\n\t}\n\tputchar ('\\n');\n\n\tif (fileOffset < m.size)\n\t{\n\t\tSWF_warn(\"extra garbage (i.e., we messed up in main): \\n\");\n\t\tdumpBytes (f, m.size - fileOffset);\n\t\tprintf (\"\\n\\n\");\n\t}\n\toutputTrailer(&m);\n}",
  "abstract_func_before": "static void readMovie(FILE *VAR_0)\n{\n\tint VAR_1, VAR_2, VAR_3, VAR_4, VAR_5, VAR_6=0;\n\tSWF_Parserstruct *VAR_7;\n\tfor (;;)\n\t{\n\t\tVAR_4 = VAR_8;\n\n\t\t/* COMMENT_0 */\n\n\t\tif(filelen_check_fails(2))\n\t\t\tbreak;\n\t\tVAR_1 = readUInt16 (VAR_0);\n\t\tVAR_2 = VAR_1 >> 6;\n\n\t\tVAR_5 = VAR_1 & ((1 << 6) - 1);\n\n\t\tif (VAR_5 == 63)\t\t/* COMMENT_1 */ \n\t\t{\n\t\t\tif(filelen_check_fails(4))\n\t\t\t\tbreak;\n\t\t\tVAR_5 = readUInt32 (VAR_0);\n\t\t}\n\t\t\n\t\t/* COMMENT_2 */\n\t\tVAR_3 = VAR_8;\n\t\tVAR_6 = VAR_8+VAR_5;\n\t\t\n\t\tif(filelen_check_fails(VAR_5))\n\t\t\tbreak;\n\t\tVAR_7= blockParse(VAR_0, VAR_5, VAR_2);\n\n\t\tif( ftell(VAR_0) != VAR_6 ) \n\t\t{\n\t\t\t/* COMMENT_3 */\n\t\t        SWF_warn(\" Stream out of sync after parse of blocktype %d (%s).\"\n\t\t\t\t\" %ld but expecting %d.\\n\", VAR_2, blockName(VAR_2),\n\t\t\t\tftell(VAR_0),VAR_6);\n\t\t}\n\n\t\tif( VAR_7 ) \n\t\t{\n\t\t\toutputBlock( VAR_2, VAR_7, VAR_0);\n\t\t\tfree(VAR_7);\t\n\t\t} else {\n\t\t\tSWF_warn(\"Error parsing block (unknown block type: %d, length %d)\\n\", \n\t\t\t\tVAR_2, VAR_5);\n\t\t}\n\n\t\tif (VAR_2 == 0 || VAR_8 >= VAR_9.size)\n\t\t\tbreak;\n\t\n\t\tfseek(VAR_0, VAR_6, VAR_10);\n\t\tVAR_8 = ftell(VAR_0);\n\t}\n\tputchar ('\\n');\n\n\tif (VAR_8 < VAR_9.size)\n\t{\n\t\tSWF_warn(\"extra garbage (i.e., we messed up in main): \\n\");\n\t\tdumpBytes (VAR_0, VAR_9.size - VAR_8);\n\t\tprintf (\"\\n\\n\");\n\t}\n\toutputTrailer(&VAR_9);\n}",
  "func_graph_path_before": "libming/7fed314748be817c7ded84854acb649786625cb6/main.c/vul/before/0.json",
  "func": "static void readMovie(FILE *f)\n{\n\tint block, type, blockstart, blockoffset, length, nextFrame=0;\n\tSWF_Parserstruct *blockp;\n\tfor (;;)\n\t{\n\t\tblockoffset = fileOffset;\n\n\t\t// printf (\"Block offset: %d %d\\n\", fileOffset, m.size);\n\n\t\tif(filelen_check_fails(2))\n\t\t\tbreak;\n\t\tblock = readUInt16 (f);\n\t\ttype = block >> 6;\n\n\t\tlength = block & ((1 << 6) - 1);\n\n\t\tif (length == 63)\t\t/* it's a long block. */ \n\t\t{\n\t\t\tif(filelen_check_fails(4))\n\t\t\t\tbreak;\n\t\t\tunsigned long real_length = readUInt32 (f);\n\n                        if (real_length > INT_MAX) {\n\t\t            SWF_warn(\" Could not process long block with length %lu:\"\n                                     \" blocks with length > %d not supported on this system\\n\",\n                                     real_length, INT_MAX);\n                            continue;\n                        } else {\n                            length = (int) real_length;\n                        }\n\t\t}\n\t\t\n\t\t//      printf (\"Found Block: %s (%i), %i bytes\\n\", blockName (type), type, length);\n\t\tblockstart = fileOffset;\n\t\tnextFrame = fileOffset+length;\n\t\t\n\t\tif(filelen_check_fails(length))\n\t\t\tbreak;\n\t\tblockp= blockParse(f, length, type);\n\n\t\tif( ftell(f) != nextFrame ) \n\t\t{\n\t\t\t// will SEEK_SET later, so this is not a critical error\n\t\t        SWF_warn(\" Stream out of sync after parse of blocktype %d (%s).\"\n\t\t\t\t\" %ld but expecting %d.\\n\", type, blockName(type),\n\t\t\t\tftell(f),nextFrame);\n\t\t}\n\n\t\tif( blockp ) \n\t\t{\n\t\t\toutputBlock( type, blockp, f);\n\t\t\tfree(blockp);\t\n\t\t} else {\n\t\t\tSWF_warn(\"Error parsing block (unknown block type: %d, length %d)\\n\", \n\t\t\t\ttype, length);\n\t\t}\n\n\t\tif (type == 0 || fileOffset >= m.size)\n\t\t\tbreak;\n\t\n\t\tfseek(f, nextFrame, SEEK_SET);\n\t\tfileOffset = ftell(f);\n\t}\n\tputchar ('\\n');\n\n\tif (fileOffset < m.size)\n\t{\n\t\tSWF_warn(\"extra garbage (i.e., we messed up in main): \\n\");\n\t\tdumpBytes (f, m.size - fileOffset);\n\t\tprintf (\"\\n\\n\");\n\t}\n\toutputTrailer(&m);\n}",
  "abstract_func": "static void readMovie(FILE *VAR_0)\n{\n\tint VAR_1, VAR_2, VAR_3, VAR_4, VAR_5, VAR_6=0;\n\tSWF_Parserstruct *VAR_7;\n\tfor (;;)\n\t{\n\t\tVAR_4 = VAR_8;\n\n\t\t/* COMMENT_0 */\n\n\t\tif(filelen_check_fails(2))\n\t\t\tbreak;\n\t\tVAR_1 = readUInt16 (VAR_0);\n\t\tVAR_2 = VAR_1 >> 6;\n\n\t\tVAR_5 = VAR_1 & ((1 << 6) - 1);\n\n\t\tif (VAR_5 == 63)\t\t/* COMMENT_1 */ \n\t\t{\n\t\t\tif(filelen_check_fails(4))\n\t\t\t\tbreak;\n\t\t\tunsigned long VAR_9 = readUInt32 (VAR_0);\n\n                        if (VAR_9 > VAR_10) {\n\t\t            SWF_warn(\" Could not process long block with length %lu:\"\n                                     \" blocks with length > %d not supported on this system\\n\",\n                                     VAR_9, VAR_10);\n                            continue;\n                        } else {\n                            VAR_5 = (int) VAR_9;\n                        }\n\t\t}\n\t\t\n\t\t/* COMMENT_2 */\n\t\tVAR_3 = VAR_8;\n\t\tVAR_6 = VAR_8+VAR_5;\n\t\t\n\t\tif(filelen_check_fails(VAR_5))\n\t\t\tbreak;\n\t\tVAR_7= blockParse(VAR_0, VAR_5, VAR_2);\n\n\t\tif( ftell(VAR_0) != VAR_6 ) \n\t\t{\n\t\t\t/* COMMENT_3 */\n\t\t        SWF_warn(\" Stream out of sync after parse of blocktype %d (%s).\"\n\t\t\t\t\" %ld but expecting %d.\\n\", VAR_2, blockName(VAR_2),\n\t\t\t\tftell(VAR_0),VAR_6);\n\t\t}\n\n\t\tif( VAR_7 ) \n\t\t{\n\t\t\toutputBlock( VAR_2, VAR_7, VAR_0);\n\t\t\tfree(VAR_7);\t\n\t\t} else {\n\t\t\tSWF_warn(\"Error parsing block (unknown block type: %d, length %d)\\n\", \n\t\t\t\tVAR_2, VAR_5);\n\t\t}\n\n\t\tif (VAR_2 == 0 || VAR_8 >= VAR_11.size)\n\t\t\tbreak;\n\t\n\t\tfseek(VAR_0, VAR_6, VAR_12);\n\t\tVAR_8 = ftell(VAR_0);\n\t}\n\tputchar ('\\n');\n\n\tif (VAR_8 < VAR_11.size)\n\t{\n\t\tSWF_warn(\"extra garbage (i.e., we messed up in main): \\n\");\n\t\tdumpBytes (VAR_0, VAR_11.size - VAR_8);\n\t\tprintf (\"\\n\\n\");\n\t}\n\toutputTrailer(&VAR_11);\n}",
  "func_graph_path": "libming/7fed314748be817c7ded84854acb649786625cb6/main.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -19,7 +19,16 @@\n \t\t{\n \t\t\tif(filelen_check_fails(4))\n \t\t\t\tbreak;\n-\t\t\tlength = readUInt32 (f);\n+\t\t\tunsigned long real_length = readUInt32 (f);\n+\n+                        if (real_length > INT_MAX) {\n+\t\t            SWF_warn(\" Could not process long block with length %lu:\"\n+                                     \" blocks with length > %d not supported on this system\\n\",\n+                                     real_length, INT_MAX);\n+                            continue;\n+                        } else {\n+                            length = (int) real_length;\n+                        }\n \t\t}\n \t\t\n \t\t//      printf (\"Found Block: %s (%i), %i bytes\\n\", blockName (type), type, length);",
  "diff_line_info": {
    "deleted_lines": [
      "\t\t\tlength = readUInt32 (f);"
    ],
    "added_lines": [
      "\t\t\tunsigned long real_length = readUInt32 (f);",
      "",
      "                        if (real_length > INT_MAX) {",
      "\t\t            SWF_warn(\" Could not process long block with length %lu:\"",
      "                                     \" blocks with length > %d not supported on this system\\n\",",
      "                                     real_length, INT_MAX);",
      "                            continue;",
      "                        } else {",
      "                            length = (int) real_length;",
      "                        }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libming/libming/pull/88",
  "description": {
    "pr_info": {
      "title": "Fix various overflows in util/ (CVE-2017-11704)",
      "number": 88
    },
    "comment": [
      "Avoid processing block when `sact->numActions` is 0, as `sact->numActions - 1` may be used as index when accessing `sact->Actions` array.\r\n\r\nI wasn't sure whether 0 was a good return value, or whether `decompileIF` was the right place for this check.\r\n\r\nThis should be partial fix of CVE-2017-11704, see issue #76.",
      "Also, fix overflow in `readUInt32`.\r\n\r\n* Fix declaration of `readUInt32` and `readSInt32` in `util/read.h`: return types should be unsigned long and long.\r\n* readUInt32: Avoid calling all `readUInt8(f)` in one line, order of evaluation is not guaranteed in the C standard.\r\n* readUInt32: Cast result of `readUInt8(f)` before `<< 24` to avoid overflow.",
      "Do you plan to add more fixes to completely address CVE-2017-11704\nbefore I merge ?\n",
      "You should be able to get a successful travis build by rebasing to current master",
      "Fine, rebase fixed travis build.\r\n\r\nYes, I am planning to add more fixes to completely address CVE-2017-11704 if possible.",
      "Hum, I've looked into changing the type of `length` from `int` to `unsigned long`, but I'm not sure it's the right solution. This looks like a major refactoring and since I'm preparing the fix in sight of a Debian LTS security update, this is not exactly what I want.\r\n\r\nWhat about simply declaring length > `INT_MAX` unsupported ? This is already quite big (especially when `sizeof(int)` = 4) and could be a temporary solution. And, anyway, it would still be better than what we have now.",
      "In this case I'd suggest something like\r\n\r\n```\r\ndiff --git a/util/main.c b/util/main.c\r\nindex cb277804..923d4c75 100644\r\n--- a/util/main.c\r\n+++ b/util/main.c\r\n@@ -253,7 +253,16 @@ static void readMovie(FILE *f)\r\n                {\r\n                        if(filelen_check_fails(4))\r\n                                break;\r\n-                       length = readUInt32 (f);\r\n+                       unsigned long real_length = readUInt32 (f);\r\n+\r\n+                        if (real_length > INT_MAX) {\r\n+                           SWF_warn(\" Could not process long block with length %lu:\"\r\n+                                     \" blocks with length > %d not supported on this system\\n\",\r\n+                                     real_length, INT_MAX);\r\n+                            continue;\r\n+                        } else {\r\n+                            length = (int) real_length;\r\n+                        }\r\n                }\r\n                \r\n                //      printf (\"Found Block: %s (%i), %i bytes\\n\", blockName (type), type, length);\r\n```",
      "I have updated the PR to ship previously discussed patch. This PR should completely address CVE-2017-11704.",
      "Thank! Merged.\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}