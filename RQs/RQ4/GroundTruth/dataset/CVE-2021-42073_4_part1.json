{
  "cve_id": "CVE-2021-42073",
  "cwe_ids": [
    "CWE-384"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "debauchee/barrier",
  "commit_msg": "Implement client identity verification\n\nThis commit fixes two security vulnerabilities: CVE-2021-42072 and\nCVE-2021-42073.\n\nThe issues have been reported by Matthias Gerstner <mgerstner@suse.de>.",
  "commit_hash": "229abab99f39f11624e5651f819e7f1f8eddedcc",
  "git_url": "https://github.com/debauchee/barrier/commit/229abab99f39f11624e5651f819e7f1f8eddedcc",
  "file_path": "src/lib/net/SecureSocket.cpp",
  "func_name": "SecureSocket::secureAccept",
  "func_before": "int\nSecureSocket::secureAccept(int socket)\n{\n    createSSL();\n\n    // set connection socket to SSL state\n    SSL_set_fd(m_ssl->m_ssl, socket);\n\n    LOG((CLOG_DEBUG2 \"accepting secure socket\"));\n    int r = SSL_accept(m_ssl->m_ssl);\n\n    static int retry;\n\n    checkResult(r, retry);\n\n    if (isFatal()) {\n        // tell user and sleep so the socket isn't hammered.\n        LOG((CLOG_ERR \"failed to accept secure socket\"));\n        LOG((CLOG_INFO \"client connection may not be secure\"));\n        m_secureReady = false;\n        ARCH->sleep(1);\n        retry = 0;\n        return -1; // Failed, error out\n    }\n\n    // If not fatal and no retry, state is good\n    if (retry == 0) {\n        m_secureReady = true;\n        LOG((CLOG_INFO \"accepted secure socket\"));\n        if (CLOG->getFilter() >= kDEBUG1) {\n            showSecureCipherInfo();\n        }\n        showSecureConnectInfo();\n        return 1;\n    }\n\n    // If not fatal and retry is set, not ready, and return retry\n    if (retry > 0) {\n        LOG((CLOG_DEBUG2 \"retry accepting secure socket\"));\n        m_secureReady = false;\n        ARCH->sleep(s_retryDelay);\n        return 0;\n    }\n\n    // no good state exists here\n    LOG((CLOG_ERR \"unexpected state attempting to accept connection\"));\n    return -1;\n}",
  "abstract_func_before": "int\nSecureSocket::secureAccept(int VAR_0)\n{\n    createSSL();\n\n    /* COMMENT_0 */\n    SSL_set_fd(VAR_1->m_ssl, VAR_0);\n\n    LOG((VAR_2 \"accepting secure socket\"));\n    int VAR_3 = SSL_accept(VAR_1->m_ssl);\n\n    static int VAR_4;\n\n    checkResult(VAR_3, VAR_4);\n\n    if (isFatal()) {\n        /* COMMENT_1 */\n        LOG((VAR_5 \"failed to accept secure socket\"));\n        LOG((VAR_6 \"client connection may not be secure\"));\n        VAR_7 = false;\n        VAR_8->sleep(1);\n        VAR_4 = 0;\n        return -1; /* COMMENT_2 */\n    }\n\n    /* COMMENT_3 */\n    if (VAR_4 == 0) {\n        VAR_7 = true;\n        LOG((VAR_6 \"accepted secure socket\"));\n        if (VAR_9->getFilter() >= VAR_10) {\n            showSecureCipherInfo();\n        }\n        showSecureConnectInfo();\n        return 1;\n    }\n\n    /* COMMENT_4 */\n    if (VAR_4 > 0) {\n        LOG((VAR_2 \"retry accepting secure socket\"));\n        VAR_7 = false;\n        VAR_8->sleep(VAR_11);\n        return 0;\n    }\n\n    /* COMMENT_5 */\n    LOG((VAR_5 \"unexpected state attempting to accept connection\"));\n    return -1;\n}",
  "func_graph_path_before": "debauchee/barrier/229abab99f39f11624e5651f819e7f1f8eddedcc/SecureSocket.cpp/vul/before/2.json",
  "func": "int\nSecureSocket::secureAccept(int socket)\n{\n    createSSL();\n\n    // set connection socket to SSL state\n    SSL_set_fd(m_ssl->m_ssl, socket);\n\n    LOG((CLOG_DEBUG2 \"accepting secure socket\"));\n    int r = SSL_accept(m_ssl->m_ssl);\n\n    static int retry;\n\n    checkResult(r, retry);\n\n    if (isFatal()) {\n        // tell user and sleep so the socket isn't hammered.\n        LOG((CLOG_ERR \"failed to accept secure socket\"));\n        LOG((CLOG_INFO \"client connection may not be secure\"));\n        m_secureReady = false;\n        ARCH->sleep(1);\n        retry = 0;\n        return -1; // Failed, error out\n    }\n\n    // If not fatal and no retry, state is good\n    if (retry == 0) {\n        if (security_level_ == ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED) {\n            if (verify_cert_fingerprint(\n                        barrier::DataDirectories::trusted_clients_ssl_fingerprints_path())) {\n                LOG((CLOG_INFO \"accepted secure socket\"));\n                if (!ensure_peer_certificate()) {\n                    retry = 0;\n                    disconnect();\n                    return -1;// Cert fail, error\n                }\n            }\n            else {\n                LOG((CLOG_ERR \"failed to verify server certificate fingerprint\"));\n                retry = 0;\n                disconnect();\n                return -1; // Fingerprint failed, error\n            }\n        }\n\n        m_secureReady = true;\n        LOG((CLOG_INFO \"accepted secure socket\"));\n        if (CLOG->getFilter() >= kDEBUG1) {\n            showSecureCipherInfo();\n        }\n        showSecureConnectInfo();\n        return 1;\n    }\n\n    // If not fatal and retry is set, not ready, and return retry\n    if (retry > 0) {\n        LOG((CLOG_DEBUG2 \"retry accepting secure socket\"));\n        m_secureReady = false;\n        ARCH->sleep(s_retryDelay);\n        return 0;\n    }\n\n    // no good state exists here\n    LOG((CLOG_ERR \"unexpected state attempting to accept connection\"));\n    return -1;\n}",
  "abstract_func": "int\nSecureSocket::secureAccept(int VAR_0)\n{\n    createSSL();\n\n    /* COMMENT_0 */\n    SSL_set_fd(VAR_1->m_ssl, VAR_0);\n\n    LOG((VAR_2 \"accepting secure socket\"));\n    int VAR_3 = SSL_accept(VAR_1->m_ssl);\n\n    static int VAR_4;\n\n    checkResult(VAR_3, VAR_4);\n\n    if (isFatal()) {\n        /* COMMENT_1 */\n        LOG((VAR_5 \"failed to accept secure socket\"));\n        LOG((VAR_6 \"client connection may not be secure\"));\n        VAR_7 = false;\n        VAR_8->sleep(1);\n        VAR_4 = 0;\n        return -1; /* COMMENT_2 */\n    }\n\n    /* COMMENT_3 */\n    if (VAR_4 == 0) {\n        if (VAR_9 == ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED) {\n            if (verify_cert_fingerprint(\n                        barrier::DataDirectories::trusted_clients_ssl_fingerprints_path())) {\n                LOG((VAR_6 \"accepted secure socket\"));\n                if (!ensure_peer_certificate()) {\n                    VAR_4 = 0;\n                    disconnect();\n                    return -1;/* COMMENT_4 */\n                }\n            }\n            else {\n                LOG((VAR_5 \"failed to verify server certificate fingerprint\"));\n                VAR_4 = 0;\n                disconnect();\n                return -1; /* COMMENT_5 */\n            }\n        }\n\n        VAR_7 = true;\n        LOG((VAR_6 \"accepted secure socket\"));\n        if (VAR_10->getFilter() >= VAR_11) {\n            showSecureCipherInfo();\n        }\n        showSecureConnectInfo();\n        return 1;\n    }\n\n    /* COMMENT_6 */\n    if (VAR_4 > 0) {\n        LOG((VAR_2 \"retry accepting secure socket\"));\n        VAR_7 = false;\n        VAR_8->sleep(VAR_12);\n        return 0;\n    }\n\n    /* COMMENT_7 */\n    LOG((VAR_5 \"unexpected state attempting to accept connection\"));\n    return -1;\n}",
  "func_graph_path": "debauchee/barrier/229abab99f39f11624e5651f819e7f1f8eddedcc/SecureSocket.cpp/vul/after/2.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -25,6 +25,24 @@\n \n     // If not fatal and no retry, state is good\n     if (retry == 0) {\n+        if (security_level_ == ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED) {\n+            if (verify_cert_fingerprint(\n+                        barrier::DataDirectories::trusted_clients_ssl_fingerprints_path())) {\n+                LOG((CLOG_INFO \"accepted secure socket\"));\n+                if (!ensure_peer_certificate()) {\n+                    retry = 0;\n+                    disconnect();\n+                    return -1;// Cert fail, error\n+                }\n+            }\n+            else {\n+                LOG((CLOG_ERR \"failed to verify server certificate fingerprint\"));\n+                retry = 0;\n+                disconnect();\n+                return -1; // Fingerprint failed, error\n+            }\n+        }\n+\n         m_secureReady = true;\n         LOG((CLOG_INFO \"accepted secure socket\"));\n         if (CLOG->getFilter() >= kDEBUG1) {",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "        if (security_level_ == ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED) {",
      "            if (verify_cert_fingerprint(",
      "                        barrier::DataDirectories::trusted_clients_ssl_fingerprints_path())) {",
      "                LOG((CLOG_INFO \"accepted secure socket\"));",
      "                if (!ensure_peer_certificate()) {",
      "                    retry = 0;",
      "                    disconnect();",
      "                    return -1;// Cert fail, error",
      "                }",
      "            }",
      "            else {",
      "                LOG((CLOG_ERR \"failed to verify server certificate fingerprint\"));",
      "                retry = 0;",
      "                disconnect();",
      "                return -1; // Fingerprint failed, error",
      "            }",
      "        }",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/debauchee/barrier/pull/1346",
  "description": {
    "pr_info": {
      "title": "Implement client identity verification [SECURITY VULNERABILITIES CVE-2021-42072, CVE-2021-42073]",
      "number": 1346
    },
    "comment": [
      "This PR implements client identity verification. Essentially server gets the same process of accepting and rejecting clients like the clients can accept or reject the server. This is important because even though the client can't move the mouse on the server, it can still receive input and potentially set the clipboard.\r\n\r\nThis PR fixes the following security vulnerabilities:\r\n\r\n - CVE-2021-42072 server does not verify client identity (certificate fingerprint)\r\n - CVE-2021-42073 By guessing/listening in on valid client names server clipboard content can be manipulated.\r\n\r\nThe issues have been reported by Matthias Gerstner <mgerstner@suse.de> @mgerstner. Matthias also provided insights into how best to fix the issues, precise reproduction steps and any used tools and made the maintainer's life as pleasant as possible. Thank you!"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95\n\nThe patch addresses specific CVEs, adds security checks, and aligns perfectly with the commit message and vulnerability description, confirming it's a security fix."
}