{
  "cve_id": "CVE-2019-20386",
  "cwe_ids": [
    "CWE-401"
  ],
  "cvss_vector": "AV:L/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "systemd",
  "commit_msg": "bus_open leak sd_event_source when udevadm triggerã€‚\n\nOn my host, when executing the udevadm trigger, I only receive the change event, which causes memleak",
  "commit_hash": "b2774a3ae692113e1f47a336a6c09bac9cfb49ad",
  "git_url": "https://github.com/systemd/systemd/commit/b2774a3ae692113e1f47a336a6c09bac9cfb49ad",
  "file_path": "src/login/logind-button.c",
  "func_name": "button_open",
  "func_before": "int button_open(Button *b) {\n        char *p, name[256];\n        int r;\n\n        assert(b);\n\n        b->fd = safe_close(b->fd);\n\n        p = strjoina(\"/dev/input/\", b->name);\n\n        b->fd = open(p, O_RDWR|O_CLOEXEC|O_NOCTTY|O_NONBLOCK);\n        if (b->fd < 0)\n                return log_warning_errno(errno, \"Failed to open %s: %m\", p);\n\n        r = button_suitable(b);\n        if (r < 0)\n                return log_warning_errno(r, \"Failed to determine whether input device is relevant to us: %m\");\n        if (r == 0)\n                return log_debug_errno(SYNTHETIC_ERRNO(EADDRNOTAVAIL),\n                                       \"Device %s does not expose keys or switches relevant to us, ignoring.\",\n                                       p);\n\n        if (ioctl(b->fd, EVIOCGNAME(sizeof(name)), name) < 0) {\n                r = log_error_errno(errno, \"Failed to get input name: %m\");\n                goto fail;\n        }\n\n        (void) button_set_mask(b);\n\n        r = sd_event_add_io(b->manager->event, &b->io_event_source, b->fd, EPOLLIN, button_dispatch, b);\n        if (r < 0) {\n                log_error_errno(r, \"Failed to add button event: %m\");\n                goto fail;\n        }\n\n        log_info(\"Watching system buttons on /dev/input/%s (%s)\", b->name, name);\n\n        return 0;\n\nfail:\n        b->fd = safe_close(b->fd);\n        return r;\n}",
  "abstract_func_before": "int button_open(Button *VAR_0) {\n        char *VAR_1, VAR_2[256];\n        int VAR_3;\n\n        assert(VAR_0);\n\n        VAR_0->fd = safe_close(VAR_0->fd);\n\n        VAR_1 = strjoina(\"/dev/input/\", VAR_0->name);\n\n        VAR_0->fd = open(VAR_1, VAR_4|VAR_5|VAR_6|VAR_7);\n        if (VAR_0->fd < 0)\n                return log_warning_errno(VAR_8, \"Failed to open %s: %m\", VAR_1);\n\n        VAR_3 = button_suitable(VAR_0);\n        if (VAR_3 < 0)\n                return log_warning_errno(VAR_3, \"Failed to determine whether input device is relevant to us: %m\");\n        if (VAR_3 == 0)\n                return log_debug_errno(SYNTHETIC_ERRNO(VAR_9),\n                                       \"Device %s does not expose keys or switches relevant to us, ignoring.\",\n                                       VAR_1);\n\n        if (ioctl(VAR_0->fd, EVIOCGNAME(sizeof(VAR_2)), VAR_2) < 0) {\n                VAR_3 = log_error_errno(VAR_8, \"Failed to get input name: %m\");\n                goto fail;\n        }\n\n        (void) button_set_mask(VAR_0);\n\n        VAR_3 = sd_event_add_io(VAR_0->manager->event, &VAR_0->io_event_source, VAR_0->fd, VAR_10, VAR_11, VAR_0);\n        if (VAR_3 < 0) {\n                log_error_errno(VAR_3, \"Failed to add button event: %m\");\n                goto fail;\n        }\n\n        log_info(\"Watching system buttons on /dev/input/%s (%s)\", VAR_0->name, VAR_2);\n\n        return 0;\n\nfail:\n        VAR_0->fd = safe_close(VAR_0->fd);\n        return VAR_3;\n}",
  "func_graph_path_before": "systemd/b2774a3ae692113e1f47a336a6c09bac9cfb49ad/logind-button.c/vul/before/0.json",
  "func": "int button_open(Button *b) {\n        char *p, name[256];\n        int r;\n\n        assert(b);\n\n        b->fd = safe_close(b->fd);\n\n        p = strjoina(\"/dev/input/\", b->name);\n\n        b->fd = open(p, O_RDWR|O_CLOEXEC|O_NOCTTY|O_NONBLOCK);\n        if (b->fd < 0)\n                return log_warning_errno(errno, \"Failed to open %s: %m\", p);\n\n        r = button_suitable(b);\n        if (r < 0)\n                return log_warning_errno(r, \"Failed to determine whether input device is relevant to us: %m\");\n        if (r == 0)\n                return log_debug_errno(SYNTHETIC_ERRNO(EADDRNOTAVAIL),\n                                       \"Device %s does not expose keys or switches relevant to us, ignoring.\",\n                                       p);\n\n        if (ioctl(b->fd, EVIOCGNAME(sizeof(name)), name) < 0) {\n                r = log_error_errno(errno, \"Failed to get input name: %m\");\n                goto fail;\n        }\n\n        (void) button_set_mask(b);\n        \n        b->io_event_source = sd_event_source_unref(b->io_event_source);\n        r = sd_event_add_io(b->manager->event, &b->io_event_source, b->fd, EPOLLIN, button_dispatch, b);\n        if (r < 0) {\n                log_error_errno(r, \"Failed to add button event: %m\");\n                goto fail;\n        }\n\n        log_info(\"Watching system buttons on /dev/input/%s (%s)\", b->name, name);\n\n        return 0;\n\nfail:\n        b->fd = safe_close(b->fd);\n        return r;\n}",
  "abstract_func": "int button_open(Button *VAR_0) {\n        char *VAR_1, VAR_2[256];\n        int VAR_3;\n\n        assert(VAR_0);\n\n        VAR_0->fd = safe_close(VAR_0->fd);\n\n        VAR_1 = strjoina(\"/dev/input/\", VAR_0->name);\n\n        VAR_0->fd = open(VAR_1, VAR_4|VAR_5|VAR_6|VAR_7);\n        if (VAR_0->fd < 0)\n                return log_warning_errno(VAR_8, \"Failed to open %s: %m\", VAR_1);\n\n        VAR_3 = button_suitable(VAR_0);\n        if (VAR_3 < 0)\n                return log_warning_errno(VAR_3, \"Failed to determine whether input device is relevant to us: %m\");\n        if (VAR_3 == 0)\n                return log_debug_errno(SYNTHETIC_ERRNO(VAR_9),\n                                       \"Device %s does not expose keys or switches relevant to us, ignoring.\",\n                                       VAR_1);\n\n        if (ioctl(VAR_0->fd, EVIOCGNAME(sizeof(VAR_2)), VAR_2) < 0) {\n                VAR_3 = log_error_errno(VAR_8, \"Failed to get input name: %m\");\n                goto fail;\n        }\n\n        (void) button_set_mask(VAR_0);\n        \n        VAR_0->io_event_source = sd_event_source_unref(VAR_0->io_event_source);\n        VAR_3 = sd_event_add_io(VAR_0->manager->event, &VAR_0->io_event_source, VAR_0->fd, VAR_10, VAR_11, VAR_0);\n        if (VAR_3 < 0) {\n                log_error_errno(VAR_3, \"Failed to add button event: %m\");\n                goto fail;\n        }\n\n        log_info(\"Watching system buttons on /dev/input/%s (%s)\", VAR_0->name, VAR_2);\n\n        return 0;\n\nfail:\n        VAR_0->fd = safe_close(VAR_0->fd);\n        return VAR_3;\n}",
  "func_graph_path": "systemd/b2774a3ae692113e1f47a336a6c09bac9cfb49ad/logind-button.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -26,7 +26,8 @@\n         }\n \n         (void) button_set_mask(b);\n-\n+        \n+        b->io_event_source = sd_event_source_unref(b->io_event_source);\n         r = sd_event_add_io(b->manager->event, &b->io_event_source, b->fd, EPOLLIN, button_dispatch, b);\n         if (r < 0) {\n                 log_error_errno(r, \"Failed to add button event: %m\");",
  "diff_line_info": {
    "deleted_lines": [
      ""
    ],
    "added_lines": [
      "        ",
      "        b->io_event_source = sd_event_source_unref(b->io_event_source);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/systemd/systemd/pull/12632",
  "description": {
    "pr_info": {
      "title": "button_open leak sd_event_source when udevadm trigger.",
      "number": 12632
    },
    "comment": [
      "On my host, when executing the udevadm trigger, I only receive the change event, which causes memleak",
      "centos ci (arch in kvm): `qemu-system-x86_64: terminating on signal 15 from pid 59081 (timeout)`"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.85,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.85"
}