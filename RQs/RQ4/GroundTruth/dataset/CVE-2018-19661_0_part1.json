{
  "cve_id": "CVE-2018-19661",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "libsndfile",
  "commit_msg": "a/ulaw: fix multiple buffer overflows\n\ni2ulaw_array() and i2alaw_array() fail to handle ptr [count] = INT_MIN\nproperly, leading to buffer underflow. INT_MIN is a special value\nsince - INT_MIN cannot be represented as int.\n\nIn this case round - INT_MIN to INT_MAX and proceed as usual.\n\nf2ulaw_array() and f2alaw_array() fail to handle ptr [count] = NaN\nproperly, leading to null pointer dereference.\n\nIn this case, arbitrarily set the buffer value to 0.\n\nThis commit fixes #429 (CVE-2018-19661 and CVE-2018-19662) and\nfixes #344 (CVE-2017-17456 and CVE-2017-17457).",
  "commit_hash": "c4dd30d69b070a3cb32b4bf74c47a8163b1916da",
  "git_url": "https://github.com/libsndfile/libsndfile/commit/c4dd30d69b070a3cb32b4bf74c47a8163b1916da",
  "file_path": "src/alaw.c",
  "func_name": "i2alaw_array",
  "func_before": "static inline void\ni2alaw_array (const int *ptr, int count, unsigned char *buffer)\n{\twhile (--count >= 0)\n\t{\tif (ptr [count] >= 0)\n\t\t\tbuffer [count] = alaw_encode [ptr [count] >> (16 + 4)] ;\n\t\telse\n\t\t\tbuffer [count] = 0x7F & alaw_encode [- ptr [count] >> (16 + 4)] ;\n\t\t} ;\n}",
  "abstract_func_before": "static inline void\ni2alaw_array (const int *VAR_0, int VAR_1, unsigned char *VAR_2)\n{\twhile (--VAR_1 >= 0)\n\t{\tif (VAR_0 [VAR_1] >= 0)\n\t\t\tVAR_2 [VAR_1] = VAR_3 [VAR_0 [VAR_1] >> (16 + 4)] ;\n\t\telse\n\t\t\tVAR_2 [VAR_1] = 0x7F & VAR_3 [- VAR_0 [VAR_1] >> (16 + 4)] ;\n\t\t} ;\n}",
  "func_graph_path_before": "libsndfile/c4dd30d69b070a3cb32b4bf74c47a8163b1916da/alaw.c/vul/before/1.json",
  "func": "static inline void\ni2alaw_array (const int *ptr, int count, unsigned char *buffer)\n{\twhile (--count >= 0)\n\t{\tif (ptr [count] == INT_MIN)\n\t\t\tbuffer [count] = alaw_encode [INT_MAX >> (16 + 4)] ;\n\t\telse if (ptr [count] >= 0)\n\t\t\tbuffer [count] = alaw_encode [ptr [count] >> (16 + 4)] ;\n\t\telse\n\t\t\tbuffer [count] = 0x7F & alaw_encode [- ptr [count] >> (16 + 4)] ;\n\t\t} ;\n}",
  "abstract_func": "static inline void\ni2alaw_array (const int *VAR_0, int VAR_1, unsigned char *VAR_2)\n{\twhile (--VAR_1 >= 0)\n\t{\tif (VAR_0 [VAR_1] == VAR_3)\n\t\t\tVAR_2 [VAR_1] = VAR_4 [VAR_5 >> (16 + 4)] ;\n\t\telse if (VAR_0 [VAR_1] >= 0)\n\t\t\tVAR_2 [VAR_1] = VAR_4 [VAR_0 [VAR_1] >> (16 + 4)] ;\n\t\telse\n\t\t\tVAR_2 [VAR_1] = 0x7F & VAR_4 [- VAR_0 [VAR_1] >> (16 + 4)] ;\n\t\t} ;\n}",
  "func_graph_path": "libsndfile/c4dd30d69b070a3cb32b4bf74c47a8163b1916da/alaw.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,9 @@\n static inline void\n i2alaw_array (const int *ptr, int count, unsigned char *buffer)\n {\twhile (--count >= 0)\n-\t{\tif (ptr [count] >= 0)\n+\t{\tif (ptr [count] == INT_MIN)\n+\t\t\tbuffer [count] = alaw_encode [INT_MAX >> (16 + 4)] ;\n+\t\telse if (ptr [count] >= 0)\n \t\t\tbuffer [count] = alaw_encode [ptr [count] >> (16 + 4)] ;\n \t\telse\n \t\t\tbuffer [count] = 0x7F & alaw_encode [- ptr [count] >> (16 + 4)] ;",
  "diff_line_info": {
    "deleted_lines": [
      "\t{\tif (ptr [count] >= 0)"
    ],
    "added_lines": [
      "\t{\tif (ptr [count] == INT_MIN)",
      "\t\t\tbuffer [count] = alaw_encode [INT_MAX >> (16 + 4)] ;",
      "\t\telse if (ptr [count] >= 0)"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libsndfile/libsndfile/pull/432",
  "description": {
    "pr_info": {
      "title": "a/ulaw: fix multiple buffer overflows",
      "number": 432
    },
    "comment": [
      "i2ulaw_array() and i2alaw_array() fail to handle ptr [count] = INT_MIN properly, leading to buffer underflow. INT_MIN is a special value since - INT_MIN cannot be represented as int.\r\n\r\nIn this case round - INT_MIN to INT_MAX and proceed as usual.\r\n\r\nf2ulaw_array() and f2alaw_array() fail to handle ptr [count] = NaN properly, leading to null pointer dereference.\r\n\r\nIn this case, arbitrarily set the buffer value to 0.\r\n\r\nNot sure 0 is the right value here.\r\n\r\nThis PR fixes #429 (CVE-2018-19661 + CVE-2018-19662), #344 (CVE-2017-17456 + CVE-2017-17457) and #317 (CVE-2017-14245 and CVE-2017-14246).",
      "Oh, I just realized that #344 is very similar (identical ?) to #317. If PR #325 is merged then the dirty isnan() part of this patch can be removed.\r\n\r\n**Edit:** Ok, looks like #325 is not the best solution. I agree that checks in the library would be better.\r\n\r\nSome additional comments:\r\n\r\nAFAIK the only loop going through potentially NaN/invalid data in the library is located in the a/ulaw_array functions. Unless we add checks earlier, the fix should be there right ?\r\n\r\nNow I see two solutions: either we handle the error in the a/ulaw_array functions or we add a return value to them, return error code and let caller handle it. I chose the first solution in my patch.\r\n\r\nConcerning the error handling, we can either refuse to process the file and exit or provide some arbitrary value to fill the hole and continue. I chose the second solution in my patch.\r\n\r\nIn any case the error should be logged. This has to be fixed in my patch in any case but apart from adding a new psf argument to a/ulaw_array functions I don't know the proper way to do it.",
      "Thanks!"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95  \n\n**Rationale:**  \nThe commit addresses buffer overflow and null pointer dereference issues, which are security vulnerabilities, and is linked to specific CVEs, confirming its security fix nature."
}