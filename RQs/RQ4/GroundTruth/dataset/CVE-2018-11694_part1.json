{
  "cve_id": "CVE-2018-11694",
  "cwe_ids": [
    "CWE-476"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "sass/libsass",
  "commit_msg": "Fix crash in `selector-append('.x~~', 'a')`\n\nFixes #2663",
  "commit_hash": "be8c924744f1f19fa9c52cbd4dd85d44c34392ee",
  "git_url": "https://github.com/sass/libsass/commit/be8c924744f1f19fa9c52cbd4dd85d44c34392ee",
  "file_path": "src/fn_selectors.cpp",
  "func_name": "BUILT_IN",
  "func_before": "BUILT_IN(selector_append)\n    {\n      List_Ptr arglist = ARG(\"$selectors\", List);\n\n      // Not enough parameters\n      if( arglist->length() == 0 )\n        error(\"$selectors: At least one selector must be passed for `selector-append'\", pstate, traces);\n\n      // Parse args into vector of selectors\n      SelectorStack parsedSelectors;\n      for (size_t i = 0, L = arglist->length(); i < L; ++i) {\n        Expression_Obj exp = Cast<Expression>(arglist->value_at_index(i));\n        if (exp->concrete_type() == Expression::NULL_VAL) {\n          std::stringstream msg;\n          msg << \"$selectors: null is not a valid selector: it must be a string,\\n\";\n          msg << \"a list of strings, or a list of lists of strings for 'selector-append'\";\n          error(msg.str(), pstate, traces);\n        }\n        if (String_Constant_Ptr str = Cast<String_Constant>(exp)) {\n          str->quote_mark(0);\n        }\n        std::string exp_src = exp->to_string();\n        Selector_List_Obj sel = Parser::parse_selector(exp_src.c_str(), ctx, traces,\n                                                       exp->pstate(), pstate.src,\n                                                       /*allow_parent=*/false);\n\n        parsedSelectors.push_back(sel);\n      }\n\n      // Nothing to do\n      if( parsedSelectors.empty() ) {\n        return SASS_MEMORY_NEW(Null, pstate);\n      }\n\n      // Set the first element as the `result`, keep appending to as we go down the parsedSelector vector.\n      SelectorStack::iterator itr = parsedSelectors.begin();\n      Selector_List_Obj result = *itr;\n      ++itr;\n\n      for(;itr != parsedSelectors.end(); ++itr) {\n        Selector_List_Obj child = *itr;\n        std::vector<Complex_Selector_Obj> newElements;\n\n        // For every COMPLEX_SELECTOR in `result`\n        // For every COMPLEX_SELECTOR in `child`\n          // let parentSeqClone equal a copy of result->elements[i]\n          // let childSeq equal child->elements[j]\n          // Append all of childSeq head elements into parentSeqClone\n          // Set the innermost tail of parentSeqClone, to childSeq's tail\n        // Replace result->elements with newElements\n        for (size_t i = 0, resultLen = result->length(); i < resultLen; ++i) {\n          for (size_t j = 0, childLen = child->length(); j < childLen; ++j) {\n            Complex_Selector_Obj parentSeqClone = SASS_MEMORY_CLONE((*result)[i]);\n            Complex_Selector_Obj childSeq = (*child)[j];\n            Complex_Selector_Obj base = childSeq->tail();\n\n            // Must be a simple sequence\n            if( childSeq->combinator() != Complex_Selector::Combinator::ANCESTOR_OF ) {\n              std::string msg(\"Can't append \\\"\");\n              msg += childSeq->to_string();\n              msg += \"\\\" to \\\"\";\n              msg += parentSeqClone->to_string();\n              msg += \"\\\" for `selector-append'\";\n              error(msg, pstate, traces);\n            }\n\n            // Cannot be a Universal selector\n            Element_Selector_Obj pType = Cast<Element_Selector>(childSeq->head()->first());\n            if(pType && pType->name() == \"*\") {\n              std::string msg(\"Can't append \\\"\");\n              msg += childSeq->to_string();\n              msg += \"\\\" to \\\"\";\n              msg += parentSeqClone->to_string();\n              msg += \"\\\" for `selector-append'\";\n              error(msg, pstate, traces);\n            }\n\n            // TODO: Add check for namespace stuff\n\n            // append any selectors in childSeq's head\n            parentSeqClone->mutable_last()->head()->concat(base->head());\n\n            // Set parentSeqClone new tail\n            parentSeqClone->mutable_last()->tail( base->tail() );\n\n            newElements.push_back(parentSeqClone);\n          }\n        }\n\n        result->elements(newElements);\n      }\n\n      Listize listize;\n      return Cast<Value>(result->perform(&listize));\n    }",
  "abstract_func_before": "BUILT_IN(selector_append)\n    {\n      List_Ptr VAR_0 = ARG(\"$selectors\", VAR_1);\n\n      /* COMMENT_0 */\n      if( VAR_0->length() == 0 )\n        error(\"$selectors: At least one selector must be passed for `selector-append'\", VAR_2, VAR_3);\n\n      /* COMMENT_1 */\n      SelectorStack VAR_4;\n      for (size_t VAR_5 = 0, VAR_6 = VAR_0->length(); VAR_5 < VAR_6; ++VAR_5) {\n        Expression_Obj VAR_7 = VAR_8<Expression>(VAR_0->value_at_index(VAR_5));\n        if (VAR_7->concrete_type() == Expression::NULL_VAL) {\n          std::stringstream VAR_9;\n          VAR_9 << \"$selectors: null is not a valid selector: it must be a string,\\n\";\n          VAR_9 << \"a list of strings, or a list of lists of strings for 'selector-append'\";\n          error(VAR_9.str(), VAR_2, VAR_3);\n        }\n        if (String_Constant_Ptr VAR_10 = VAR_8<String_Constant>(VAR_7)) {\n          VAR_10->quote_mark(0);\n        }\n        std::string VAR_11 = VAR_7->to_string();\n        Selector_List_Obj VAR_12 = Parser::parse_selector(VAR_11.c_str(), VAR_13, VAR_3,\n                                                       VAR_7->pstate(), VAR_2.src,\n                                                       /* COMMENT_2 */false);\n\n        VAR_4.push_back(VAR_12);\n      }\n\n      /* COMMENT_3 */\n      if( VAR_4.empty() ) {\n        return SASS_MEMORY_NEW(VAR_14, VAR_2);\n      }\n\n      /* COMMENT_4 */\n      SelectorStack::iterator VAR_15 = VAR_4.begin();\n      Selector_List_Obj VAR_16 = *VAR_15;\n      ++VAR_15;\n\n      for(;VAR_15 != VAR_4.end(); ++VAR_15) {\n        Selector_List_Obj VAR_17 = *VAR_15;\n        std::vector<Complex_Selector_Obj> VAR_18;\n\n        /* COMMENT_5 */\n        /* COMMENT_6 */\n          /* COMMENT_7 */\n          /* COMMENT_8 */\n          /* COMMENT_9 */\n          /* COMMENT_10 */\n        /* COMMENT_11 */\n        for (size_t VAR_5 = 0, VAR_19 = VAR_16->length(); VAR_5 < VAR_19; ++VAR_5) {\n          for (size_t VAR_20 = 0, VAR_21 = VAR_17->length(); VAR_20 < VAR_21; ++VAR_20) {\n            Complex_Selector_Obj VAR_22 = SASS_MEMORY_CLONE((*VAR_16)[VAR_5]);\n            Complex_Selector_Obj VAR_23 = (*VAR_17)[VAR_20];\n            Complex_Selector_Obj VAR_24 = VAR_23->tail();\n\n            /* COMMENT_12 */\n            if( VAR_23->combinator() != Complex_Selector::Combinator::ANCESTOR_OF ) {\n              std::string VAR_9(\"Can't append \\\"\");\n              VAR_9 += VAR_23->to_string();\n              VAR_9 += \"\\\" to \\\"\";\n              VAR_9 += VAR_22->to_string();\n              VAR_9 += \"\\\" for `selector-append'\";\n              error(VAR_9, VAR_2, VAR_3);\n            }\n\n            /* COMMENT_13 */\n            Element_Selector_Obj VAR_25 = VAR_8<Element_Selector>(VAR_23->head()->first());\n            if(VAR_25 && VAR_25->name() == \"*\") {\n              std::string VAR_9(\"Can't append \\\"\");\n              VAR_9 += VAR_23->to_string();\n              VAR_9 += \"\\\" to \\\"\";\n              VAR_9 += VAR_22->to_string();\n              VAR_9 += \"\\\" for `selector-append'\";\n              error(VAR_9, VAR_2, VAR_3);\n            }\n\n            /* COMMENT_14 */\n\n            /* COMMENT_15 */\n            VAR_22->mutable_last()->head()->concat(VAR_24->head());\n\n            /* COMMENT_16 */\n            VAR_22->mutable_last()->tail( VAR_24->tail() );\n\n            VAR_18.push_back(VAR_22);\n          }\n        }\n\n        VAR_16->elements(VAR_18);\n      }\n\n      Listize VAR_26;\n      return VAR_8<Value>(VAR_16->perform(&VAR_26));\n    }",
  "func_graph_path_before": null,
  "func": "BUILT_IN(selector_append)\n    {\n      List_Ptr arglist = ARG(\"$selectors\", List);\n\n      // Not enough parameters\n      if( arglist->length() == 0 )\n        error(\"$selectors: At least one selector must be passed for `selector-append'\", pstate, traces);\n\n      // Parse args into vector of selectors\n      SelectorStack parsedSelectors;\n      for (size_t i = 0, L = arglist->length(); i < L; ++i) {\n        Expression_Obj exp = Cast<Expression>(arglist->value_at_index(i));\n        if (exp->concrete_type() == Expression::NULL_VAL) {\n          std::stringstream msg;\n          msg << \"$selectors: null is not a valid selector: it must be a string,\\n\";\n          msg << \"a list of strings, or a list of lists of strings for 'selector-append'\";\n          error(msg.str(), pstate, traces);\n        }\n        if (String_Constant_Ptr str = Cast<String_Constant>(exp)) {\n          str->quote_mark(0);\n        }\n        std::string exp_src = exp->to_string();\n        Selector_List_Obj sel = Parser::parse_selector(exp_src.c_str(), ctx, traces,\n                                                       exp->pstate(), pstate.src,\n                                                       /*allow_parent=*/false);\n\n        parsedSelectors.push_back(sel);\n      }\n\n      // Nothing to do\n      if( parsedSelectors.empty() ) {\n        return SASS_MEMORY_NEW(Null, pstate);\n      }\n\n      // Set the first element as the `result`, keep appending to as we go down the parsedSelector vector.\n      SelectorStack::iterator itr = parsedSelectors.begin();\n      Selector_List_Obj result = *itr;\n      ++itr;\n\n      for(;itr != parsedSelectors.end(); ++itr) {\n        Selector_List_Obj child = *itr;\n        std::vector<Complex_Selector_Obj> newElements;\n\n        // For every COMPLEX_SELECTOR in `result`\n        // For every COMPLEX_SELECTOR in `child`\n          // let parentSeqClone equal a copy of result->elements[i]\n          // let childSeq equal child->elements[j]\n          // Append all of childSeq head elements into parentSeqClone\n          // Set the innermost tail of parentSeqClone, to childSeq's tail\n        // Replace result->elements with newElements\n        for (size_t i = 0, resultLen = result->length(); i < resultLen; ++i) {\n          for (size_t j = 0, childLen = child->length(); j < childLen; ++j) {\n            Complex_Selector_Obj parentSeqClone = SASS_MEMORY_CLONE((*result)[i]);\n            Complex_Selector_Obj childSeq = (*child)[j];\n            Complex_Selector_Obj base = childSeq->tail();\n\n            // Must be a simple sequence\n            if( childSeq->combinator() != Complex_Selector::Combinator::ANCESTOR_OF ) {\n              std::string msg(\"Can't append \\\"\");\n              msg += childSeq->to_string();\n              msg += \"\\\" to \\\"\";\n              msg += parentSeqClone->to_string();\n              msg += \"\\\" for `selector-append'\";\n              error(msg, pstate, traces);\n            }\n\n            // Cannot be a Universal selector\n            Element_Selector_Obj pType = Cast<Element_Selector>(childSeq->head()->first());\n            if(pType && pType->name() == \"*\") {\n              std::string msg(\"Can't append \\\"\");\n              msg += childSeq->to_string();\n              msg += \"\\\" to \\\"\";\n              msg += parentSeqClone->to_string();\n              msg += \"\\\" for `selector-append'\";\n              error(msg, pstate, traces);\n            }\n\n            // TODO: Add check for namespace stuff\n\n            Complex_Selector_Ptr lastComponent = parentSeqClone->mutable_last();\n            if (lastComponent->head() == nullptr) {\n              std::string msg = \"Parent \\\"\" + parentSeqClone->to_string() + \"\\\" is incompatible with \\\"\" + base->to_string() + \"\\\"\";\n              error(msg, pstate, traces);\n            }\n            lastComponent->head()->concat(base->head());\n            lastComponent->tail(base->tail());\n\n            newElements.push_back(parentSeqClone);\n          }\n        }\n\n        result->elements(newElements);\n      }\n\n      Listize listize;\n      return Cast<Value>(result->perform(&listize));\n    }",
  "abstract_func": "BUILT_IN(selector_append)\n    {\n      List_Ptr VAR_0 = ARG(\"$selectors\", VAR_1);\n\n      /* COMMENT_0 */\n      if( VAR_0->length() == 0 )\n        error(\"$selectors: At least one selector must be passed for `selector-append'\", VAR_2, VAR_3);\n\n      /* COMMENT_1 */\n      SelectorStack VAR_4;\n      for (size_t VAR_5 = 0, VAR_6 = VAR_0->length(); VAR_5 < VAR_6; ++VAR_5) {\n        Expression_Obj VAR_7 = VAR_8<Expression>(VAR_0->value_at_index(VAR_5));\n        if (VAR_7->concrete_type() == Expression::NULL_VAL) {\n          std::stringstream VAR_9;\n          VAR_9 << \"$selectors: null is not a valid selector: it must be a string,\\n\";\n          VAR_9 << \"a list of strings, or a list of lists of strings for 'selector-append'\";\n          error(VAR_9.str(), VAR_2, VAR_3);\n        }\n        if (String_Constant_Ptr VAR_10 = VAR_8<String_Constant>(VAR_7)) {\n          VAR_10->quote_mark(0);\n        }\n        std::string VAR_11 = VAR_7->to_string();\n        Selector_List_Obj VAR_12 = Parser::parse_selector(VAR_11.c_str(), VAR_13, VAR_3,\n                                                       VAR_7->pstate(), VAR_2.src,\n                                                       /* COMMENT_2 */false);\n\n        VAR_4.push_back(VAR_12);\n      }\n\n      /* COMMENT_3 */\n      if( VAR_4.empty() ) {\n        return SASS_MEMORY_NEW(VAR_14, VAR_2);\n      }\n\n      /* COMMENT_4 */\n      SelectorStack::iterator VAR_15 = VAR_4.begin();\n      Selector_List_Obj VAR_16 = *VAR_15;\n      ++VAR_15;\n\n      for(;VAR_15 != VAR_4.end(); ++VAR_15) {\n        Selector_List_Obj VAR_17 = *VAR_15;\n        std::vector<Complex_Selector_Obj> VAR_18;\n\n        /* COMMENT_5 */\n        /* COMMENT_6 */\n          /* COMMENT_7 */\n          /* COMMENT_8 */\n          /* COMMENT_9 */\n          /* COMMENT_10 */\n        /* COMMENT_11 */\n        for (size_t VAR_5 = 0, VAR_19 = VAR_16->length(); VAR_5 < VAR_19; ++VAR_5) {\n          for (size_t VAR_20 = 0, VAR_21 = VAR_17->length(); VAR_20 < VAR_21; ++VAR_20) {\n            Complex_Selector_Obj VAR_22 = SASS_MEMORY_CLONE((*VAR_16)[VAR_5]);\n            Complex_Selector_Obj VAR_23 = (*VAR_17)[VAR_20];\n            Complex_Selector_Obj VAR_24 = VAR_23->tail();\n\n            /* COMMENT_12 */\n            if( VAR_23->combinator() != Complex_Selector::Combinator::ANCESTOR_OF ) {\n              std::string VAR_9(\"Can't append \\\"\");\n              VAR_9 += VAR_23->to_string();\n              VAR_9 += \"\\\" to \\\"\";\n              VAR_9 += VAR_22->to_string();\n              VAR_9 += \"\\\" for `selector-append'\";\n              error(VAR_9, VAR_2, VAR_3);\n            }\n\n            /* COMMENT_13 */\n            Element_Selector_Obj VAR_25 = VAR_8<Element_Selector>(VAR_23->head()->first());\n            if(VAR_25 && VAR_25->name() == \"*\") {\n              std::string VAR_9(\"Can't append \\\"\");\n              VAR_9 += VAR_23->to_string();\n              VAR_9 += \"\\\" to \\\"\";\n              VAR_9 += VAR_22->to_string();\n              VAR_9 += \"\\\" for `selector-append'\";\n              error(VAR_9, VAR_2, VAR_3);\n            }\n\n            /* COMMENT_14 */\n\n            Complex_Selector_Ptr VAR_26 = VAR_22->mutable_last();\n            if (VAR_26->head() == nullptr) {\n              std::string VAR_9 = \"Parent \\\"\" + VAR_22->to_string() + \"\\\" is incompatible with \\\"\" + VAR_24->to_string() + \"\\\"\";\n              error(VAR_9, VAR_2, VAR_3);\n            }\n            VAR_26->head()->concat(VAR_24->head());\n            VAR_26->tail(VAR_24->tail());\n\n            VAR_18.push_back(VAR_22);\n          }\n        }\n\n        VAR_16->elements(VAR_18);\n      }\n\n      Listize VAR_27;\n      return VAR_8<Value>(VAR_16->perform(&VAR_27));\n    }",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -77,11 +77,13 @@\n \n             // TODO: Add check for namespace stuff\n \n-            // append any selectors in childSeq's head\n-            parentSeqClone->mutable_last()->head()->concat(base->head());\n-\n-            // Set parentSeqClone new tail\n-            parentSeqClone->mutable_last()->tail( base->tail() );\n+            Complex_Selector_Ptr lastComponent = parentSeqClone->mutable_last();\n+            if (lastComponent->head() == nullptr) {\n+              std::string msg = \"Parent \\\"\" + parentSeqClone->to_string() + \"\\\" is incompatible with \\\"\" + base->to_string() + \"\\\"\";\n+              error(msg, pstate, traces);\n+            }\n+            lastComponent->head()->concat(base->head());\n+            lastComponent->tail(base->tail());\n \n             newElements.push_back(parentSeqClone);\n           }",
  "diff_line_info": {
    "deleted_lines": [
      "            // append any selectors in childSeq's head",
      "            parentSeqClone->mutable_last()->head()->concat(base->head());",
      "",
      "            // Set parentSeqClone new tail",
      "            parentSeqClone->mutable_last()->tail( base->tail() );"
    ],
    "added_lines": [
      "            Complex_Selector_Ptr lastComponent = parentSeqClone->mutable_last();",
      "            if (lastComponent->head() == nullptr) {",
      "              std::string msg = \"Parent \\\"\" + parentSeqClone->to_string() + \"\\\" is incompatible with \\\"\" + base->to_string() + \"\\\"\";",
      "              error(msg, pstate, traces);",
      "            }",
      "            lastComponent->head()->concat(base->head());",
      "            lastComponent->tail(base->tail());"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/sass/libsass/pull/2762",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/sass/libsass/pull/2762: 403 Client Error: Forbidden for url: https://api.github.com/repos/sass/libsass/pulls/2762",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "Final Classification: Defect Remediation & Feature Upgrades; Confidence: 0.9"
}