{
  "cve_id": "CVE-2022-40138",
  "cwe_ids": [
    "CWE-681"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "facebook/hermes",
  "commit_msg": "Re-sync with internal repository (#822)\n\nCo-authored-by: Facebook Community Bot <6422482+facebook-github-bot@users.noreply.github.com>",
  "commit_hash": "6aa825e480d48127b480b08d13adf70033237097",
  "git_url": "https://github.com/facebook/hermes/commit/6aa825e480d48127b480b08d13adf70033237097",
  "file_path": "lib/VM/Operations.cpp",
  "func_name": "isConstructor",
  "func_before": "CallResult<bool> isConstructor(Runtime &runtime, Callable *callable) {\n  // This is not a complete definition, since ES6 and later define member\n  // functions of objects to not be constructors; however, Hermes does not have\n  // ES6 classes implemented yet, so we cannot check for that case.\n  if (!callable) {\n    return false;\n  }\n\n  // We traverse the BoundFunction target chain to find the eventual target.\n  while (BoundFunction *b = dyn_vmcast<BoundFunction>(callable)) {\n    callable = b->getTarget(runtime);\n  }\n\n  // If it is a bytecode function, check the flags.\n  if (auto *func = dyn_vmcast<JSFunction>(callable)) {\n    auto *cb = func->getCodeBlock(runtime);\n    // Even though it doesn't make sense logically, we need to compile the\n    // function in order to access it flags.\n    cb->lazyCompile(runtime);\n    return !func->getCodeBlock(runtime)->getHeaderFlags().isCallProhibited(\n        true);\n  }\n\n  // We check for NativeFunction since those are defined to not be\n  // constructible, with the exception of NativeConstructor.\n  if (!vmisa<NativeFunction>(callable) || vmisa<NativeConstructor>(callable)) {\n    return true;\n  }\n\n  // JSCallableProxy is a NativeFunction, but may or may not be a\n  // constructor, so we ask it.\n  if (auto *cproxy = dyn_vmcast<JSCallableProxy>(callable)) {\n    return cproxy->isConstructor(runtime);\n  }\n\n  return false;\n}",
  "abstract_func_before": "CallResult<bool> isConstructor(Runtime &VAR_0, Callable *VAR_1) {\n  /* COMMENT_0 */\n  /* COMMENT_1 */\n  /* COMMENT_2 */\n  if (!VAR_1) {\n    return false;\n  }\n\n  /* COMMENT_3 */\n  while (BoundFunction *VAR_2 = VAR_3<BoundFunction>(VAR_1)) {\n    VAR_1 = VAR_2->getTarget(VAR_0);\n  }\n\n  /* COMMENT_4 */\n  if (auto *VAR_4 = VAR_3<JSFunction>(VAR_1)) {\n    auto *VAR_5 = VAR_4->getCodeBlock(VAR_0);\n    /* COMMENT_5 */\n    /* COMMENT_6 */\n    VAR_5->lazyCompile(VAR_0);\n    return !VAR_4->getCodeBlock(VAR_0)->getHeaderFlags().isCallProhibited(\n        true);\n  }\n\n  /* COMMENT_7 */\n  /* COMMENT_8 */\n  if (!VAR_6<NativeFunction>(VAR_1) || VAR_6<NativeConstructor>(VAR_1)) {\n    return true;\n  }\n\n  /* COMMENT_9 */\n  /* COMMENT_10 */\n  if (auto *VAR_7 = VAR_3<JSCallableProxy>(VAR_1)) {\n    return VAR_7->isConstructor(VAR_0);\n  }\n\n  return false;\n}",
  "func_graph_path_before": "facebook/hermes/6aa825e480d48127b480b08d13adf70033237097/Operations.cpp/vul/before/0.json",
  "func": "CallResult<bool> isConstructor(Runtime &runtime, Callable *callable) {\n  // This is not a complete definition, since ES6 and later define member\n  // functions of objects to not be constructors; however, Hermes does not have\n  // ES6 classes implemented yet, so we cannot check for that case.\n  if (!callable) {\n    return false;\n  }\n\n  // We traverse the BoundFunction target chain to find the eventual target.\n  while (BoundFunction *b = dyn_vmcast<BoundFunction>(callable)) {\n    callable = b->getTarget(runtime);\n  }\n\n  // If it is a bytecode function, check the flags.\n  if (auto *func = dyn_vmcast<JSFunction>(callable)) {\n    auto *cb = func->getCodeBlock(runtime);\n    // Even though it doesn't make sense logically, we need to compile the\n    // function in order to access it flags.\n    if (LLVM_UNLIKELY(cb->lazyCompile(runtime) == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    return !func->getCodeBlock(runtime)->getHeaderFlags().isCallProhibited(\n        true);\n  }\n\n  // We check for NativeFunction since those are defined to not be\n  // constructible, with the exception of NativeConstructor.\n  if (!vmisa<NativeFunction>(callable) || vmisa<NativeConstructor>(callable)) {\n    return true;\n  }\n\n  // JSCallableProxy is a NativeFunction, but may or may not be a\n  // constructor, so we ask it.\n  if (auto *cproxy = dyn_vmcast<JSCallableProxy>(callable)) {\n    return cproxy->isConstructor(runtime);\n  }\n\n  return false;\n}",
  "abstract_func": "CallResult<bool> isConstructor(Runtime &VAR_0, Callable *VAR_1) {\n  /* COMMENT_0 */\n  /* COMMENT_1 */\n  /* COMMENT_2 */\n  if (!VAR_1) {\n    return false;\n  }\n\n  /* COMMENT_3 */\n  while (BoundFunction *VAR_2 = VAR_3<BoundFunction>(VAR_1)) {\n    VAR_1 = VAR_2->getTarget(VAR_0);\n  }\n\n  /* COMMENT_4 */\n  if (auto *VAR_4 = VAR_3<JSFunction>(VAR_1)) {\n    auto *VAR_5 = VAR_4->getCodeBlock(VAR_0);\n    /* COMMENT_5 */\n    /* COMMENT_6 */\n    if (LLVM_UNLIKELY(VAR_5->lazyCompile(VAR_0) == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    return !VAR_4->getCodeBlock(VAR_0)->getHeaderFlags().isCallProhibited(\n        true);\n  }\n\n  /* COMMENT_7 */\n  /* COMMENT_8 */\n  if (!VAR_6<NativeFunction>(VAR_1) || VAR_6<NativeConstructor>(VAR_1)) {\n    return true;\n  }\n\n  /* COMMENT_9 */\n  /* COMMENT_10 */\n  if (auto *VAR_7 = VAR_3<JSCallableProxy>(VAR_1)) {\n    return VAR_7->isConstructor(VAR_0);\n  }\n\n  return false;\n}",
  "func_graph_path": "facebook/hermes/6aa825e480d48127b480b08d13adf70033237097/Operations.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -16,7 +16,9 @@\n     auto *cb = func->getCodeBlock(runtime);\n     // Even though it doesn't make sense logically, we need to compile the\n     // function in order to access it flags.\n-    cb->lazyCompile(runtime);\n+    if (LLVM_UNLIKELY(cb->lazyCompile(runtime) == ExecutionStatus::EXCEPTION)) {\n+      return ExecutionStatus::EXCEPTION;\n+    }\n     return !func->getCodeBlock(runtime)->getHeaderFlags().isCallProhibited(\n         true);\n   }",
  "diff_line_info": {
    "deleted_lines": [
      "    cb->lazyCompile(runtime);"
    ],
    "added_lines": [
      "    if (LLVM_UNLIKELY(cb->lazyCompile(runtime) == ExecutionStatus::EXCEPTION)) {",
      "      return ExecutionStatus::EXCEPTION;",
      "    }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/facebook/hermes/pull/822",
  "description": {
    "pr_info": {
      "title": "Re-sync with internal repository",
      "number": 822
    },
    "comment": [
      "The internal and external repositories are out of sync. This attempts to brings them back in sync by patching the GitHub repository. Please carefully review this patch. You must disable ShipIt for your project in order to merge this pull request. DO NOT IMPORT this pull request. Instead, merge it directly on GitHub using the MERGE BUTTON. Re-enable ShipIt after merging."
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.9"
}