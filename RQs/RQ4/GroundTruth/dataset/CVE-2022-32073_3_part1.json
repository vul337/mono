{
  "cve_id": "CVE-2022-32073",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "wolfSSL/wolfssh",
  "commit_msg": "ASAN SFTP Fixes\nWhen decoding SFTP messages, fix the size checks so they don't wrap. (ZD12766)",
  "commit_hash": "edb272e35ee57e7b89f3e127222c6981b6a1e730",
  "git_url": "https://github.com/wolfSSL/wolfssh/commit/edb272e35ee57e7b89f3e127222c6981b6a1e730",
  "file_path": "src/wolfsftp.c",
  "func_name": "wolfSSH_SFTP_DoStatus",
  "func_before": "static int wolfSSH_SFTP_DoStatus(WOLFSSH* ssh, word32 reqId,\n        WS_SFTP_BUFFER* buffer)\n{\n    word32 sz;\n    word32 status = WOLFSSH_FTP_FAILURE;\n    word32 localIdx = wolfSSH_SFTP_buffer_idx(buffer);\n    word32 maxIdx = wolfSSH_SFTP_buffer_size(buffer);\n    byte* buf = wolfSSH_SFTP_buffer_data(buffer);\n\n    (void)reqId;\n    if (localIdx + UINT32_SZ > maxIdx) {\n        return WS_FATAL_ERROR;\n    }\n    ato32(buf + localIdx, &status);\n    localIdx += UINT32_SZ;\n\n    /* read error message */\n    if (localIdx + UINT32_SZ > maxIdx) {\n        return WS_FATAL_ERROR;\n    }\n    ato32(buf + localIdx, &sz);\n    localIdx += UINT32_SZ;\n\n    if (sz > 0) {\n        byte* s;\n\n        if (localIdx + sz > maxIdx) {\n            return WS_FATAL_ERROR;\n        }\n        s = (byte*)WMALLOC(sz + 1, ssh->ctx->heap, DYNTYPE_BUFFER);\n        if (s == NULL) {\n            return WS_MEMORY_E;\n        }\n\n        /* make sure is null terminated string */\n        WMEMCPY(s, buf + localIdx, sz);\n        s[sz] = '\\0';\n        WLOG(WS_LOG_SFTP, \"Status Recv : %s\", s);\n        WFREE(s, ssh->ctx->heap, DYNTYPE_BUFFER);\n        localIdx += sz;\n    }\n\n    /* read language tag */\n    if (localIdx + UINT32_SZ > maxIdx) {\n        return WS_FATAL_ERROR;\n    }\n    ato32(buf + localIdx, &sz);\n    localIdx += UINT32_SZ;\n\n    if (sz > 0) {\n        byte* s;\n\n        if (localIdx + sz > maxIdx) {\n            return WS_FATAL_ERROR;\n        }\n        s = (byte*)WMALLOC(sz + 1, ssh->ctx->heap, DYNTYPE_BUFFER);\n        if (s == NULL) {\n            return WS_MEMORY_E;\n        }\n\n        /* make sure is null terminated string */\n        WMEMCPY(s, buf + localIdx, sz);\n        s[sz] = '\\0';\n        WLOG(WS_LOG_SFTP, \"Status Language : %s\", s);\n        WFREE(s, ssh->ctx->heap, DYNTYPE_BUFFER);\n        localIdx += sz;\n    }\n\n    wolfSSH_SFTP_buffer_seek(buffer, 0, localIdx);\n    return status;\n}",
  "abstract_func_before": "static int wolfSSH_SFTP_DoStatus(WOLFSSH* VAR_0, word32 VAR_1,\n        WS_SFTP_BUFFER* VAR_2)\n{\n    word32 VAR_3;\n    word32 VAR_4 = VAR_5;\n    word32 VAR_6 = wolfSSH_SFTP_buffer_idx(VAR_2);\n    word32 VAR_7 = wolfSSH_SFTP_buffer_size(VAR_2);\n    byte* VAR_8 = wolfSSH_SFTP_buffer_data(VAR_2);\n\n    (void)VAR_1;\n    if (VAR_6 + VAR_9 > VAR_7) {\n        return VAR_10;\n    }\n    ato32(VAR_8 + VAR_6, &VAR_4);\n    VAR_6 += VAR_9;\n\n    /* COMMENT_0 */\n    if (VAR_6 + VAR_9 > VAR_7) {\n        return VAR_10;\n    }\n    ato32(VAR_8 + VAR_6, &VAR_3);\n    VAR_6 += VAR_9;\n\n    if (VAR_3 > 0) {\n        byte* VAR_11;\n\n        if (VAR_6 + VAR_3 > VAR_7) {\n            return VAR_10;\n        }\n        VAR_11 = (byte*)WMALLOC(VAR_3 + 1, VAR_0->ctx->heap, VAR_12);\n        if (VAR_11 == NULL) {\n            return VAR_13;\n        }\n\n        /* COMMENT_1 */\n        WMEMCPY(VAR_11, VAR_8 + VAR_6, VAR_3);\n        VAR_11[VAR_3] = '\\0';\n        WLOG(VAR_14, \"Status Recv : %s\", VAR_11);\n        WFREE(VAR_11, VAR_0->ctx->heap, VAR_12);\n        VAR_6 += VAR_3;\n    }\n\n    /* COMMENT_2 */\n    if (VAR_6 + VAR_9 > VAR_7) {\n        return VAR_10;\n    }\n    ato32(VAR_8 + VAR_6, &VAR_3);\n    VAR_6 += VAR_9;\n\n    if (VAR_3 > 0) {\n        byte* VAR_11;\n\n        if (VAR_6 + VAR_3 > VAR_7) {\n            return VAR_10;\n        }\n        VAR_11 = (byte*)WMALLOC(VAR_3 + 1, VAR_0->ctx->heap, VAR_12);\n        if (VAR_11 == NULL) {\n            return VAR_13;\n        }\n\n        /* COMMENT_1 */\n        WMEMCPY(VAR_11, VAR_8 + VAR_6, VAR_3);\n        VAR_11[VAR_3] = '\\0';\n        WLOG(VAR_14, \"Status Language : %s\", VAR_11);\n        WFREE(VAR_11, VAR_0->ctx->heap, VAR_12);\n        VAR_6 += VAR_3;\n    }\n\n    wolfSSH_SFTP_buffer_seek(VAR_2, 0, VAR_6);\n    return VAR_4;\n}",
  "func_graph_path_before": "wolfSSL/wolfssh/edb272e35ee57e7b89f3e127222c6981b6a1e730/wolfsftp.c/vul/before/4.json",
  "func": "static int wolfSSH_SFTP_DoStatus(WOLFSSH* ssh, word32 reqId,\n        WS_SFTP_BUFFER* buffer)\n{\n    word32 sz;\n    word32 status = WOLFSSH_FTP_FAILURE;\n    word32 localIdx = wolfSSH_SFTP_buffer_idx(buffer);\n    word32 maxIdx = wolfSSH_SFTP_buffer_size(buffer);\n    byte* buf = wolfSSH_SFTP_buffer_data(buffer);\n\n    (void)reqId;\n    if (localIdx + UINT32_SZ > maxIdx) {\n        return WS_FATAL_ERROR;\n    }\n    ato32(buf + localIdx, &status);\n    localIdx += UINT32_SZ;\n\n    /* read error message */\n    if (localIdx + UINT32_SZ > maxIdx) {\n        return WS_FATAL_ERROR;\n    }\n    ato32(buf + localIdx, &sz);\n    localIdx += UINT32_SZ;\n\n    if (sz > 0) {\n        byte* s;\n\n        if (sz > maxIdx - localIdx) {\n            return WS_FATAL_ERROR;\n        }\n        s = (byte*)WMALLOC(sz + 1, ssh->ctx->heap, DYNTYPE_BUFFER);\n        if (s == NULL) {\n            return WS_MEMORY_E;\n        }\n\n        /* make sure is null terminated string */\n        WMEMCPY(s, buf + localIdx, sz);\n        s[sz] = '\\0';\n        WLOG(WS_LOG_SFTP, \"Status Recv : %s\", s);\n        WFREE(s, ssh->ctx->heap, DYNTYPE_BUFFER);\n        localIdx += sz;\n    }\n\n    /* read language tag */\n    if (localIdx + UINT32_SZ > maxIdx) {\n        return WS_FATAL_ERROR;\n    }\n    ato32(buf + localIdx, &sz);\n    localIdx += UINT32_SZ;\n\n    if (sz > 0) {\n        byte* s;\n\n        if (sz > maxIdx - localIdx) {\n            return WS_FATAL_ERROR;\n        }\n        s = (byte*)WMALLOC(sz + 1, ssh->ctx->heap, DYNTYPE_BUFFER);\n        if (s == NULL) {\n            return WS_MEMORY_E;\n        }\n\n        /* make sure is null terminated string */\n        WMEMCPY(s, buf + localIdx, sz);\n        s[sz] = '\\0';\n        WLOG(WS_LOG_SFTP, \"Status Language : %s\", s);\n        WFREE(s, ssh->ctx->heap, DYNTYPE_BUFFER);\n        localIdx += sz;\n    }\n\n    wolfSSH_SFTP_buffer_seek(buffer, 0, localIdx);\n    return status;\n}",
  "abstract_func": "static int wolfSSH_SFTP_DoStatus(WOLFSSH* VAR_0, word32 VAR_1,\n        WS_SFTP_BUFFER* VAR_2)\n{\n    word32 VAR_3;\n    word32 VAR_4 = VAR_5;\n    word32 VAR_6 = wolfSSH_SFTP_buffer_idx(VAR_2);\n    word32 VAR_7 = wolfSSH_SFTP_buffer_size(VAR_2);\n    byte* VAR_8 = wolfSSH_SFTP_buffer_data(VAR_2);\n\n    (void)VAR_1;\n    if (VAR_6 + VAR_9 > VAR_7) {\n        return VAR_10;\n    }\n    ato32(VAR_8 + VAR_6, &VAR_4);\n    VAR_6 += VAR_9;\n\n    /* COMMENT_0 */\n    if (VAR_6 + VAR_9 > VAR_7) {\n        return VAR_10;\n    }\n    ato32(VAR_8 + VAR_6, &VAR_3);\n    VAR_6 += VAR_9;\n\n    if (VAR_3 > 0) {\n        byte* VAR_11;\n\n        if (VAR_3 > VAR_7 - VAR_6) {\n            return VAR_10;\n        }\n        VAR_11 = (byte*)WMALLOC(VAR_3 + 1, VAR_0->ctx->heap, VAR_12);\n        if (VAR_11 == NULL) {\n            return VAR_13;\n        }\n\n        /* COMMENT_1 */\n        WMEMCPY(VAR_11, VAR_8 + VAR_6, VAR_3);\n        VAR_11[VAR_3] = '\\0';\n        WLOG(VAR_14, \"Status Recv : %s\", VAR_11);\n        WFREE(VAR_11, VAR_0->ctx->heap, VAR_12);\n        VAR_6 += VAR_3;\n    }\n\n    /* COMMENT_2 */\n    if (VAR_6 + VAR_9 > VAR_7) {\n        return VAR_10;\n    }\n    ato32(VAR_8 + VAR_6, &VAR_3);\n    VAR_6 += VAR_9;\n\n    if (VAR_3 > 0) {\n        byte* VAR_11;\n\n        if (VAR_3 > VAR_7 - VAR_6) {\n            return VAR_10;\n        }\n        VAR_11 = (byte*)WMALLOC(VAR_3 + 1, VAR_0->ctx->heap, VAR_12);\n        if (VAR_11 == NULL) {\n            return VAR_13;\n        }\n\n        /* COMMENT_1 */\n        WMEMCPY(VAR_11, VAR_8 + VAR_6, VAR_3);\n        VAR_11[VAR_3] = '\\0';\n        WLOG(VAR_14, \"Status Language : %s\", VAR_11);\n        WFREE(VAR_11, VAR_0->ctx->heap, VAR_12);\n        VAR_6 += VAR_3;\n    }\n\n    wolfSSH_SFTP_buffer_seek(VAR_2, 0, VAR_6);\n    return VAR_4;\n}",
  "func_graph_path": "wolfSSL/wolfssh/edb272e35ee57e7b89f3e127222c6981b6a1e730/wolfsftp.c/vul/after/4.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -24,7 +24,7 @@\n     if (sz > 0) {\n         byte* s;\n \n-        if (localIdx + sz > maxIdx) {\n+        if (sz > maxIdx - localIdx) {\n             return WS_FATAL_ERROR;\n         }\n         s = (byte*)WMALLOC(sz + 1, ssh->ctx->heap, DYNTYPE_BUFFER);\n@@ -50,7 +50,7 @@\n     if (sz > 0) {\n         byte* s;\n \n-        if (localIdx + sz > maxIdx) {\n+        if (sz > maxIdx - localIdx) {\n             return WS_FATAL_ERROR;\n         }\n         s = (byte*)WMALLOC(sz + 1, ssh->ctx->heap, DYNTYPE_BUFFER);",
  "diff_line_info": {
    "deleted_lines": [
      "        if (localIdx + sz > maxIdx) {",
      "        if (localIdx + sz > maxIdx) {"
    ],
    "added_lines": [
      "        if (sz > maxIdx - localIdx) {",
      "        if (sz > maxIdx - localIdx) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/wolfSSL/wolfssh/pull/360",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/wolfSSL/wolfssh/pull/360: 403 Client Error: Forbidden for url: https://api.github.com/repos/wolfSSL/wolfssh/pulls/360",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.9\n\nThe patch addresses a buffer overflow issue in SFTP message decoding, which is a security vulnerability. The changes in the code fix the condition to prevent integer overflow, aligning with the commit message and vulnerability description. While there's no explicit CVE reference, the context strongly indicates a security fix. Confidence is high but slightly tempered by the absence of a specific vulnerability identifier."
}