{
  "cve_id": "CVE-2019-25058",
  "cwe_ids": [
    "CWE-863"
  ],
  "cvss_vector": "AV:L/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "USBGuard/usbguard",
  "commit_msg": "dbus: Add missing checks for authorization using Polkit",
  "commit_hash": "df5f01c6ed0c20d269f7239901d21883cc871bbb",
  "git_url": "https://github.com/USBGuard/usbguard/commit/df5f01c6ed0c20d269f7239901d21883cc871bbb",
  "file_path": "src/DBus/DBusBridge.cpp",
  "func_name": "DBusBridge::handlePolicyMethodCall",
  "func_before": "void DBusBridge::handlePolicyMethodCall(const std::string& method_name, GVariant* parameters, GDBusMethodInvocation* invocation)\n  {\n    if (method_name == \"listRules\") {\n      const char* label_cstr = nullptr;\n      g_variant_get(parameters, \"(&s)\", &label_cstr);\n      std::string label(label_cstr);\n      auto rules = listRules(label);\n\n      if (rules.size() > 0) {\n        auto gvbuilder = g_variant_builder_new(G_VARIANT_TYPE_ARRAY);\n\n        try {\n          for (auto rule : rules) {\n            g_variant_builder_add(gvbuilder, \"(us)\",\n              rule.getRuleID(),\n              rule.toString().c_str());\n          }\n\n          g_dbus_method_invocation_return_value(invocation, g_variant_new(\"(a(us))\", gvbuilder));\n        }\n        catch (...) {\n          g_variant_builder_unref(gvbuilder);\n          throw;\n        }\n\n        g_variant_builder_unref(gvbuilder);\n      }\n      else {\n        g_dbus_method_invocation_return_value(invocation, g_variant_new(\"(a(us))\", nullptr));\n      }\n\n      return;\n    }\n\n    if (method_name == \"appendRule\") {\n      const char* rule_spec_cstr = nullptr;\n      uint32_t parent_id = 0;\n      gboolean temporary = false;\n      g_variant_get(parameters, \"(&sub)\", &rule_spec_cstr, &parent_id, &temporary);\n      std::string rule_spec(rule_spec_cstr);\n      const uint32_t rule_id = appendRule(rule_spec, parent_id, !temporary);\n      g_dbus_method_invocation_return_value(invocation, g_variant_new(\"(u)\", rule_id));\n      return;\n    }\n\n    if (method_name == \"removeRule\") {\n      uint32_t rule_id = 0;\n      g_variant_get(parameters, \"(u)\", &rule_id);\n      removeRule(rule_id);\n      g_dbus_method_invocation_return_value(invocation, nullptr);\n      return;\n    }\n\n    g_dbus_method_invocation_return_error(invocation, G_DBUS_ERROR,\n      G_DBUS_ERROR_UNKNOWN_METHOD, \"Unknown method interface\");\n    return;\n  }",
  "abstract_func_before": "void DBusBridge::handlePolicyMethodCall(const std::string& VAR_0, GVariant* VAR_1, GDBusMethodInvocation* VAR_2)\n  {\n    if (VAR_0 == \"listRules\") {\n      const char* VAR_3 = nullptr;\n      g_variant_get(VAR_1, \"(&s)\", &VAR_3);\n      std::string label(label_cstr);\n      auto VAR_4 = listRules(VAR_5);\n\n      if (VAR_4.size() > 0) {\n        auto VAR_6 = g_variant_builder_new(VAR_7);\n\n        try {\n          for (auto VAR_8 : VAR_4) {\n            g_variant_builder_add(VAR_6, \"(us)\",\n              VAR_8.getRuleID(),\n              VAR_8.toString().c_str());\n          }\n\n          g_dbus_method_invocation_return_value(VAR_2, g_variant_new(\"(a(us))\", VAR_6));\n        }\n        catch (...) {\n          g_variant_builder_unref(VAR_6);\n          throw;\n        }\n\n        g_variant_builder_unref(VAR_6);\n      }\n      else {\n        g_dbus_method_invocation_return_value(VAR_2, g_variant_new(\"(a(us))\", nullptr));\n      }\n\n      return;\n    }\n\n    if (VAR_0 == \"appendRule\") {\n      const char* VAR_9 = nullptr;\n      uint32_t VAR_10 = 0;\n      gboolean VAR_11 = false;\n      g_variant_get(VAR_1, \"(&sub)\", &VAR_9, &VAR_10, &VAR_11);\n      std::string rule_spec(rule_spec_cstr);\n      const uint32_t VAR_12 = appendRule(VAR_13, VAR_10, !VAR_11);\n      g_dbus_method_invocation_return_value(VAR_2, g_variant_new(\"(u)\", VAR_12));\n      return;\n    }\n\n    if (VAR_0 == \"removeRule\") {\n      uint32_t VAR_12 = 0;\n      g_variant_get(VAR_1, \"(u)\", &VAR_12);\n      removeRule(VAR_12);\n      g_dbus_method_invocation_return_value(VAR_2, nullptr);\n      return;\n    }\n\n    g_dbus_method_invocation_return_error(VAR_2, VAR_14,\n      VAR_15, \"Unknown method interface\");\n    return;\n  }",
  "func_graph_path_before": null,
  "func": "void DBusBridge::handlePolicyMethodCall(const std::string& method_name, GVariant* parameters, GDBusMethodInvocation* invocation)\n  {\n    if (method_name == \"listRules\") {\n      if (! isAuthorizedByPolkit(invocation)) {\n        return;\n      }\n\n      const char* label_cstr = nullptr;\n      g_variant_get(parameters, \"(&s)\", &label_cstr);\n      std::string label(label_cstr);\n      auto rules = listRules(label);\n\n      if (rules.size() > 0) {\n        auto gvbuilder = g_variant_builder_new(G_VARIANT_TYPE_ARRAY);\n\n        try {\n          for (auto rule : rules) {\n            g_variant_builder_add(gvbuilder, \"(us)\",\n              rule.getRuleID(),\n              rule.toString().c_str());\n          }\n\n          g_dbus_method_invocation_return_value(invocation, g_variant_new(\"(a(us))\", gvbuilder));\n        }\n        catch (...) {\n          g_variant_builder_unref(gvbuilder);\n          throw;\n        }\n\n        g_variant_builder_unref(gvbuilder);\n      }\n      else {\n        g_dbus_method_invocation_return_value(invocation, g_variant_new(\"(a(us))\", nullptr));\n      }\n\n      return;\n    }\n\n    if (method_name == \"appendRule\") {\n      if (! isAuthorizedByPolkit(invocation)) {\n        return;\n      }\n\n      const char* rule_spec_cstr = nullptr;\n      uint32_t parent_id = 0;\n      gboolean temporary = false;\n      g_variant_get(parameters, \"(&sub)\", &rule_spec_cstr, &parent_id, &temporary);\n      std::string rule_spec(rule_spec_cstr);\n      const uint32_t rule_id = appendRule(rule_spec, parent_id, !temporary);\n      g_dbus_method_invocation_return_value(invocation, g_variant_new(\"(u)\", rule_id));\n      return;\n    }\n\n    if (method_name == \"removeRule\") {\n      if (! isAuthorizedByPolkit(invocation)) {\n        return;\n      }\n\n      uint32_t rule_id = 0;\n      g_variant_get(parameters, \"(u)\", &rule_id);\n      removeRule(rule_id);\n      g_dbus_method_invocation_return_value(invocation, nullptr);\n      return;\n    }\n\n    g_dbus_method_invocation_return_error(invocation, G_DBUS_ERROR,\n      G_DBUS_ERROR_UNKNOWN_METHOD, \"Unknown method interface\");\n    return;\n  }",
  "abstract_func": "void DBusBridge::handlePolicyMethodCall(const std::string& VAR_0, GVariant* VAR_1, GDBusMethodInvocation* VAR_2)\n  {\n    if (VAR_0 == \"listRules\") {\n      if (! isAuthorizedByPolkit(VAR_2)) {\n        return;\n      }\n\n      const char* VAR_3 = nullptr;\n      g_variant_get(VAR_1, \"(&s)\", &VAR_3);\n      std::string label(label_cstr);\n      auto VAR_4 = listRules(VAR_5);\n\n      if (VAR_4.size() > 0) {\n        auto VAR_6 = g_variant_builder_new(VAR_7);\n\n        try {\n          for (auto VAR_8 : VAR_4) {\n            g_variant_builder_add(VAR_6, \"(us)\",\n              VAR_8.getRuleID(),\n              VAR_8.toString().c_str());\n          }\n\n          g_dbus_method_invocation_return_value(VAR_2, g_variant_new(\"(a(us))\", VAR_6));\n        }\n        catch (...) {\n          g_variant_builder_unref(VAR_6);\n          throw;\n        }\n\n        g_variant_builder_unref(VAR_6);\n      }\n      else {\n        g_dbus_method_invocation_return_value(VAR_2, g_variant_new(\"(a(us))\", nullptr));\n      }\n\n      return;\n    }\n\n    if (VAR_0 == \"appendRule\") {\n      if (! isAuthorizedByPolkit(VAR_2)) {\n        return;\n      }\n\n      const char* VAR_9 = nullptr;\n      uint32_t VAR_10 = 0;\n      gboolean VAR_11 = false;\n      g_variant_get(VAR_1, \"(&sub)\", &VAR_9, &VAR_10, &VAR_11);\n      std::string rule_spec(rule_spec_cstr);\n      const uint32_t VAR_12 = appendRule(VAR_13, VAR_10, !VAR_11);\n      g_dbus_method_invocation_return_value(VAR_2, g_variant_new(\"(u)\", VAR_12));\n      return;\n    }\n\n    if (VAR_0 == \"removeRule\") {\n      if (! isAuthorizedByPolkit(VAR_2)) {\n        return;\n      }\n\n      uint32_t VAR_12 = 0;\n      g_variant_get(VAR_1, \"(u)\", &VAR_12);\n      removeRule(VAR_12);\n      g_dbus_method_invocation_return_value(VAR_2, nullptr);\n      return;\n    }\n\n    g_dbus_method_invocation_return_error(VAR_2, VAR_14,\n      VAR_15, \"Unknown method interface\");\n    return;\n  }",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,10 @@\n void DBusBridge::handlePolicyMethodCall(const std::string& method_name, GVariant* parameters, GDBusMethodInvocation* invocation)\n   {\n     if (method_name == \"listRules\") {\n+      if (! isAuthorizedByPolkit(invocation)) {\n+        return;\n+      }\n+\n       const char* label_cstr = nullptr;\n       g_variant_get(parameters, \"(&s)\", &label_cstr);\n       std::string label(label_cstr);\n@@ -33,6 +37,10 @@\n     }\n \n     if (method_name == \"appendRule\") {\n+      if (! isAuthorizedByPolkit(invocation)) {\n+        return;\n+      }\n+\n       const char* rule_spec_cstr = nullptr;\n       uint32_t parent_id = 0;\n       gboolean temporary = false;\n@@ -44,6 +52,10 @@\n     }\n \n     if (method_name == \"removeRule\") {\n+      if (! isAuthorizedByPolkit(invocation)) {\n+        return;\n+      }\n+\n       uint32_t rule_id = 0;\n       g_variant_get(parameters, \"(u)\", &rule_id);\n       removeRule(rule_id);",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "      if (! isAuthorizedByPolkit(invocation)) {",
      "        return;",
      "      }",
      "",
      "      if (! isAuthorizedByPolkit(invocation)) {",
      "        return;",
      "      }",
      "",
      "      if (! isAuthorizedByPolkit(invocation)) {",
      "        return;",
      "      }",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/USBGuard/usbguard/pull/531",
  "description": {
    "pr_info": {
      "title": "[CVE-2019-25058] Fix unauthorized access via D-Bus (fixes #273, fixes #403)",
      "number": 531
    },
    "comment": [
      "Fixes #273\r\nFixes #403\r\n\r\n- Fix `.policy` file:\r\n  - Replace unsupported value `auth_self_keep_session` by `auth_self_keep` to fix the Polkit parse error so that Polkit stops ignoring the USBGuard `.policy` file.\r\n  - Drop actions/methods from the policy that no longer exist.\r\n  - Add actions/methods to the policy file that have been missing.\r\n- Make `usbguard-dbus` call out to Polkit for authorization so that the policies from the `.policy` file are actually respected.\r\n- Add CI to protect against policy file parse error regressions.\r\n\r\nCC @radosroka @Cropi ",
      "I don't have any objections."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "The patch introduces Polkit authorization checks to fix insecure handling of dbus method calls, addressing a security vulnerability by ensuring proper authorization is enforced.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}