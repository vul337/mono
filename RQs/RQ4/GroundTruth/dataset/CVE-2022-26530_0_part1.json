{
  "cve_id": "CVE-2022-26530",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "swaywm/swaylock",
  "commit_msg": "Add support for ext-session-lock-v1\n\nThis is a new protocol to lock the session [1]. It should be more\nreliable than layer-shell + input-inhibitor.\n\n[1]: https://gitlab.freedesktop.org/wayland/wayland-protocols/-/merge_requests/131",
  "commit_hash": "1d1c75b6316d21933069a9d201f966d84099f6ca",
  "git_url": "https://github.com/swaywm/swaylock/commit/1d1c75b6316d21933069a9d201f966d84099f6ca",
  "file_path": "main.c",
  "func_name": "main",
  "func_before": "int main(int argc, char **argv) {\n\tswaylock_log_init(LOG_ERROR);\n\tinitialize_pw_backend(argc, argv);\n\tsrand(time(NULL));\n\n\tenum line_mode line_mode = LM_LINE;\n\tstate.failed_attempts = 0;\n\tstate.args = (struct swaylock_args){\n\t\t.mode = BACKGROUND_MODE_FILL,\n\t\t.font = strdup(\"sans-serif\"),\n\t\t.font_size = 0,\n\t\t.radius = 50,\n\t\t.thickness = 10,\n\t\t.indicator_x_position = 0,\n\t\t.indicator_y_position = 0,\n\t\t.override_indicator_x_position = false,\n\t\t.override_indicator_y_position = false,\n\t\t.ignore_empty = false,\n\t\t.show_indicator = true,\n\t\t.show_caps_lock_indicator = false,\n\t\t.show_caps_lock_text = true,\n\t\t.show_keyboard_layout = false,\n\t\t.hide_keyboard_layout = false,\n\t\t.show_failed_attempts = false,\n\t\t.indicator_idle_visible = false\n\t};\n\twl_list_init(&state.images);\n\tset_default_colors(&state.args.colors);\n\n\tchar *config_path = NULL;\n\tint result = parse_options(argc, argv, NULL, NULL, &config_path);\n\tif (result != 0) {\n\t\tfree(config_path);\n\t\treturn result;\n\t}\n\tif (!config_path) {\n\t\tconfig_path = get_config_path();\n\t}\n\n\tif (config_path) {\n\t\tswaylock_log(LOG_DEBUG, \"Found config at %s\", config_path);\n\t\tint config_status = load_config(config_path, &state, &line_mode);\n\t\tfree(config_path);\n\t\tif (config_status != 0) {\n\t\t\tfree(state.args.font);\n\t\t\treturn config_status;\n\t\t}\n\t}\n\n\tif (argc > 1) {\n\t\tswaylock_log(LOG_DEBUG, \"Parsing CLI Args\");\n\t\tint result = parse_options(argc, argv, &state, &line_mode, NULL);\n\t\tif (result != 0) {\n\t\t\tfree(state.args.font);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tif (line_mode == LM_INSIDE) {\n\t\tstate.args.colors.line = state.args.colors.inside;\n\t} else if (line_mode == LM_RING) {\n\t\tstate.args.colors.line = state.args.colors.ring;\n\t}\n\n#ifdef __linux__\n\t// Most non-linux platforms require root to mlock()\n\tif (mlock(state.password.buffer, sizeof(state.password.buffer)) != 0) {\n\t\tswaylock_log(LOG_ERROR, \"Unable to mlock() password memory.\");\n\t\treturn EXIT_FAILURE;\n\t}\n#endif\n\n\twl_list_init(&state.surfaces);\n\tstate.xkb.context = xkb_context_new(XKB_CONTEXT_NO_FLAGS);\n\tstate.display = wl_display_connect(NULL);\n\tif (!state.display) {\n\t\tfree(state.args.font);\n\t\tswaylock_log(LOG_ERROR, \"Unable to connect to the compositor. \"\n\t\t\t\t\"If your compositor is running, check or set the \"\n\t\t\t\t\"WAYLAND_DISPLAY environment variable.\");\n\t\treturn EXIT_FAILURE;\n\t}\n\n\tstruct wl_registry *registry = wl_display_get_registry(state.display);\n\twl_registry_add_listener(registry, &registry_listener, &state);\n\twl_display_roundtrip(state.display);\n\tassert(state.compositor && state.layer_shell && state.shm);\n\tif (!state.input_inhibit_manager) {\n\t\tfree(state.args.font);\n\t\tswaylock_log(LOG_ERROR, \"Compositor does not support the input \"\n\t\t\t\t\"inhibitor protocol, refusing to run insecurely\");\n\t\treturn 1;\n\t}\n\n\tzwlr_input_inhibit_manager_v1_get_inhibitor(state.input_inhibit_manager);\n\tif (wl_display_roundtrip(state.display) == -1) {\n\t\tfree(state.args.font);\n\t\tswaylock_log(LOG_ERROR, \"Exiting - failed to inhibit input:\"\n\t\t\t\t\" is another lockscreen already running?\");\n\t\treturn 2;\n\t}\n\n\tif (state.zxdg_output_manager) {\n\t\tstruct swaylock_surface *surface;\n\t\twl_list_for_each(surface, &state.surfaces, link) {\n\t\t\tsurface->xdg_output = zxdg_output_manager_v1_get_xdg_output(\n\t\t\t\t\t\tstate.zxdg_output_manager, surface->output);\n\t\t\tzxdg_output_v1_add_listener(\n\t\t\t\t\tsurface->xdg_output, &_xdg_output_listener, surface);\n\t\t}\n\t\twl_display_roundtrip(state.display);\n\t} else {\n\t\tswaylock_log(LOG_INFO, \"Compositor does not support zxdg output \"\n\t\t\t\t\"manager, images assigned to named outputs will not work\");\n\t}\n\n\tstruct swaylock_surface *surface;\n\twl_list_for_each(surface, &state.surfaces, link) {\n\t\tcreate_layer_surface(surface);\n\t}\n\n\tif (state.args.daemonize) {\n\t\twl_display_roundtrip(state.display);\n\t\tdaemonize();\n\t}\n\n\tstate.eventloop = loop_create();\n\tloop_add_fd(state.eventloop, wl_display_get_fd(state.display), POLLIN,\n\t\t\tdisplay_in, NULL);\n\n\tloop_add_fd(state.eventloop, get_comm_reply_fd(), POLLIN, comm_in, NULL);\n\n\tstate.run_display = true;\n\twhile (state.run_display) {\n\t\terrno = 0;\n\t\tif (wl_display_flush(state.display) == -1 && errno != EAGAIN) {\n\t\t\tbreak;\n\t\t}\n\t\tloop_poll(state.eventloop);\n\t}\n\n\tfree(state.args.font);\n\treturn 0;\n}",
  "abstract_func_before": "int main(int VAR_0, char **VAR_1) {\n\tswaylock_log_init(VAR_2);\n\tinitialize_pw_backend(VAR_0, VAR_1);\n\tsrand(time(NULL));\n\n\tenum line_mode line_mode = VAR_3;\n\tVAR_4.failed_attempts = 0;\n\tVAR_4.args = (struct swaylock_args){\n\t\t.mode = VAR_5,\n\t\t.font = strdup(\"sans-serif\"),\n\t\t.font_size = 0,\n\t\t.radius = 50,\n\t\t.thickness = 10,\n\t\t.indicator_x_position = 0,\n\t\t.indicator_y_position = 0,\n\t\t.override_indicator_x_position = false,\n\t\t.override_indicator_y_position = false,\n\t\t.ignore_empty = false,\n\t\t.show_indicator = true,\n\t\t.show_caps_lock_indicator = false,\n\t\t.show_caps_lock_text = true,\n\t\t.show_keyboard_layout = false,\n\t\t.hide_keyboard_layout = false,\n\t\t.show_failed_attempts = false,\n\t\t.indicator_idle_visible = false\n\t};\n\twl_list_init(&VAR_4.images);\n\tset_default_colors(&VAR_4.args.colors);\n\n\tchar *VAR_6 = NULL;\n\tint VAR_7 = parse_options(VAR_0, VAR_1, NULL, NULL, &VAR_6);\n\tif (VAR_7 != 0) {\n\t\tfree(VAR_6);\n\t\treturn VAR_7;\n\t}\n\tif (!VAR_6) {\n\t\tVAR_6 = get_config_path();\n\t}\n\n\tif (VAR_6) {\n\t\tswaylock_log(VAR_8, \"Found config at %s\", VAR_6);\n\t\tint VAR_9 = load_config(VAR_6, &VAR_4, &line_mode);\n\t\tfree(VAR_6);\n\t\tif (VAR_9 != 0) {\n\t\t\tfree(VAR_4.args.font);\n\t\t\treturn VAR_9;\n\t\t}\n\t}\n\n\tif (VAR_0 > 1) {\n\t\tswaylock_log(VAR_8, \"Parsing CLI Args\");\n\t\tint VAR_7 = parse_options(VAR_0, VAR_1, &VAR_4, &line_mode, NULL);\n\t\tif (VAR_7 != 0) {\n\t\t\tfree(VAR_4.args.font);\n\t\t\treturn VAR_7;\n\t\t}\n\t}\n\n\tif (line_mode == VAR_10) {\n\t\tVAR_4.args.colors.line = VAR_4.args.colors.inside;\n\t} else if (line_mode == VAR_11) {\n\t\tVAR_4.args.colors.line = VAR_4.args.colors.ring;\n\t}\n\n#ifdef VAR_12\n\t/* COMMENT_0 */\n\tif (mlock(VAR_4.password.buffer, sizeof(VAR_4.password.buffer)) != 0) {\n\t\tswaylock_log(VAR_2, \"Unable to mlock() password memory.\");\n\t\treturn VAR_13;\n\t}\n#endif\n\n\twl_list_init(&VAR_4.surfaces);\n\tVAR_4.xkb.context = xkb_context_new(VAR_14);\n\tVAR_4.display = wl_display_connect(NULL);\n\tif (!VAR_4.display) {\n\t\tfree(VAR_4.args.font);\n\t\tswaylock_log(VAR_2, \"Unable to connect to the compositor. \"\n\t\t\t\t\"If your compositor is running, check or set the \"\n\t\t\t\t\"WAYLAND_DISPLAY environment variable.\");\n\t\treturn VAR_13;\n\t}\n\n\tstruct wl_registry *VAR_15 = wl_display_get_registry(VAR_4.display);\n\twl_registry_add_listener(VAR_15, &VAR_16, &VAR_4);\n\twl_display_roundtrip(VAR_4.display);\n\tassert(VAR_4.compositor && VAR_4.layer_shell && VAR_4.shm);\n\tif (!VAR_4.input_inhibit_manager) {\n\t\tfree(VAR_4.args.font);\n\t\tswaylock_log(VAR_2, \"Compositor does not support the input \"\n\t\t\t\t\"inhibitor protocol, refusing to run insecurely\");\n\t\treturn 1;\n\t}\n\n\tzwlr_input_inhibit_manager_v1_get_inhibitor(VAR_4.input_inhibit_manager);\n\tif (wl_display_roundtrip(VAR_4.display) == -1) {\n\t\tfree(VAR_4.args.font);\n\t\tswaylock_log(VAR_2, \"Exiting - failed to inhibit input:\"\n\t\t\t\t\" is another lockscreen already running?\");\n\t\treturn 2;\n\t}\n\n\tif (VAR_4.zxdg_output_manager) {\n\t\tstruct swaylock_surface *VAR_17;\n\t\twl_list_for_each(VAR_17, &VAR_4.surfaces, VAR_18) {\n\t\t\tVAR_17->xdg_output = zxdg_output_manager_v1_get_xdg_output(\n\t\t\t\t\t\tVAR_4.zxdg_output_manager, VAR_17->output);\n\t\t\tzxdg_output_v1_add_listener(\n\t\t\t\t\tVAR_17->xdg_output, &VAR_19, VAR_17);\n\t\t}\n\t\twl_display_roundtrip(VAR_4.display);\n\t} else {\n\t\tswaylock_log(VAR_20, \"Compositor does not support zxdg output \"\n\t\t\t\t\"manager, images assigned to named outputs will not work\");\n\t}\n\n\tstruct swaylock_surface *VAR_17;\n\twl_list_for_each(VAR_17, &VAR_4.surfaces, VAR_18) {\n\t\tcreate_layer_surface(VAR_17);\n\t}\n\n\tif (VAR_4.args.daemonize) {\n\t\twl_display_roundtrip(VAR_4.display);\n\t\tdaemonize();\n\t}\n\n\tVAR_4.eventloop = loop_create();\n\tloop_add_fd(VAR_4.eventloop, wl_display_get_fd(VAR_4.display), VAR_21,\n\t\t\tVAR_22, NULL);\n\n\tloop_add_fd(VAR_4.eventloop, get_comm_reply_fd(), VAR_21, VAR_23, NULL);\n\n\tVAR_4.run_display = true;\n\twhile (VAR_4.run_display) {\n\t\tVAR_24 = 0;\n\t\tif (wl_display_flush(VAR_4.display) == -1 && VAR_24 != VAR_25) {\n\t\t\tbreak;\n\t\t}\n\t\tloop_poll(VAR_4.eventloop);\n\t}\n\n\tfree(VAR_4.args.font);\n\treturn 0;\n}",
  "func_graph_path_before": "swaywm/swaylock/1d1c75b6316d21933069a9d201f966d84099f6ca/main.c/vul/before/1.json",
  "func": "int main(int argc, char **argv) {\n\tswaylock_log_init(LOG_ERROR);\n\tinitialize_pw_backend(argc, argv);\n\tsrand(time(NULL));\n\n\tenum line_mode line_mode = LM_LINE;\n\tstate.failed_attempts = 0;\n\tstate.args = (struct swaylock_args){\n\t\t.mode = BACKGROUND_MODE_FILL,\n\t\t.font = strdup(\"sans-serif\"),\n\t\t.font_size = 0,\n\t\t.radius = 50,\n\t\t.thickness = 10,\n\t\t.indicator_x_position = 0,\n\t\t.indicator_y_position = 0,\n\t\t.override_indicator_x_position = false,\n\t\t.override_indicator_y_position = false,\n\t\t.ignore_empty = false,\n\t\t.show_indicator = true,\n\t\t.show_caps_lock_indicator = false,\n\t\t.show_caps_lock_text = true,\n\t\t.show_keyboard_layout = false,\n\t\t.hide_keyboard_layout = false,\n\t\t.show_failed_attempts = false,\n\t\t.indicator_idle_visible = false\n\t};\n\twl_list_init(&state.images);\n\tset_default_colors(&state.args.colors);\n\n\tchar *config_path = NULL;\n\tint result = parse_options(argc, argv, NULL, NULL, &config_path);\n\tif (result != 0) {\n\t\tfree(config_path);\n\t\treturn result;\n\t}\n\tif (!config_path) {\n\t\tconfig_path = get_config_path();\n\t}\n\n\tif (config_path) {\n\t\tswaylock_log(LOG_DEBUG, \"Found config at %s\", config_path);\n\t\tint config_status = load_config(config_path, &state, &line_mode);\n\t\tfree(config_path);\n\t\tif (config_status != 0) {\n\t\t\tfree(state.args.font);\n\t\t\treturn config_status;\n\t\t}\n\t}\n\n\tif (argc > 1) {\n\t\tswaylock_log(LOG_DEBUG, \"Parsing CLI Args\");\n\t\tint result = parse_options(argc, argv, &state, &line_mode, NULL);\n\t\tif (result != 0) {\n\t\t\tfree(state.args.font);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tif (line_mode == LM_INSIDE) {\n\t\tstate.args.colors.line = state.args.colors.inside;\n\t} else if (line_mode == LM_RING) {\n\t\tstate.args.colors.line = state.args.colors.ring;\n\t}\n\n#ifdef __linux__\n\t// Most non-linux platforms require root to mlock()\n\tif (mlock(state.password.buffer, sizeof(state.password.buffer)) != 0) {\n\t\tswaylock_log(LOG_ERROR, \"Unable to mlock() password memory.\");\n\t\treturn EXIT_FAILURE;\n\t}\n#endif\n\n\twl_list_init(&state.surfaces);\n\tstate.xkb.context = xkb_context_new(XKB_CONTEXT_NO_FLAGS);\n\tstate.display = wl_display_connect(NULL);\n\tif (!state.display) {\n\t\tfree(state.args.font);\n\t\tswaylock_log(LOG_ERROR, \"Unable to connect to the compositor. \"\n\t\t\t\t\"If your compositor is running, check or set the \"\n\t\t\t\t\"WAYLAND_DISPLAY environment variable.\");\n\t\treturn EXIT_FAILURE;\n\t}\n\n\tstruct wl_registry *registry = wl_display_get_registry(state.display);\n\twl_registry_add_listener(registry, &registry_listener, &state);\n\twl_display_roundtrip(state.display);\n\n\tif (!state.compositor || !state.shm) {\n\t\tswaylock_log(LOG_ERROR, \"Missing wl_compositor or wl_shm\");\n\t\treturn 1;\n\t}\n\n\tif (state.ext_session_lock_manager_v1) {\n\t\tswaylock_log(LOG_DEBUG, \"Using ext-session-lock-v1\");\n\t\tstate.ext_session_lock_v1 = ext_session_lock_manager_v1_lock(state.ext_session_lock_manager_v1);\n\t\text_session_lock_v1_add_listener(state.ext_session_lock_v1,\n\t\t\t\t&ext_session_lock_v1_listener, &state);\n\t} else if (state.layer_shell && state.input_inhibit_manager) {\n\t\tswaylock_log(LOG_DEBUG, \"Using wlr-layer-shell + wlr-input-inhibitor\");\n\t\tzwlr_input_inhibit_manager_v1_get_inhibitor(state.input_inhibit_manager);\n\t} else {\n\t\tswaylock_log(LOG_ERROR, \"Missing ext-session-lock-v1, wlr-layer-shell \"\n\t\t\t\t\"and wlr-input-inhibitor\");\n\t\treturn 1;\n\t}\n\n\tif (wl_display_roundtrip(state.display) == -1) {\n\t\tfree(state.args.font);\n\t\tif (state.input_inhibit_manager) {\n\t\t\tswaylock_log(LOG_ERROR, \"Exiting - failed to inhibit input:\"\n\t\t\t\t\t\" is another lockscreen already running?\");\n\t\t\treturn 2;\n\t\t}\n\t\treturn 1;\n\t}\n\n\tif (state.zxdg_output_manager) {\n\t\tstruct swaylock_surface *surface;\n\t\twl_list_for_each(surface, &state.surfaces, link) {\n\t\t\tsurface->xdg_output = zxdg_output_manager_v1_get_xdg_output(\n\t\t\t\t\t\tstate.zxdg_output_manager, surface->output);\n\t\t\tzxdg_output_v1_add_listener(\n\t\t\t\t\tsurface->xdg_output, &_xdg_output_listener, surface);\n\t\t}\n\t\twl_display_roundtrip(state.display);\n\t} else {\n\t\tswaylock_log(LOG_INFO, \"Compositor does not support zxdg output \"\n\t\t\t\t\"manager, images assigned to named outputs will not work\");\n\t}\n\n\tstruct swaylock_surface *surface;\n\twl_list_for_each(surface, &state.surfaces, link) {\n\t\tcreate_surface(surface);\n\t}\n\n\tif (state.args.daemonize) {\n\t\twl_display_roundtrip(state.display);\n\t\tdaemonize();\n\t}\n\n\tstate.eventloop = loop_create();\n\tloop_add_fd(state.eventloop, wl_display_get_fd(state.display), POLLIN,\n\t\t\tdisplay_in, NULL);\n\n\tloop_add_fd(state.eventloop, get_comm_reply_fd(), POLLIN, comm_in, NULL);\n\n\tstate.run_display = true;\n\twhile (state.run_display) {\n\t\terrno = 0;\n\t\tif (wl_display_flush(state.display) == -1 && errno != EAGAIN) {\n\t\t\tbreak;\n\t\t}\n\t\tloop_poll(state.eventloop);\n\t}\n\n\tif (state.ext_session_lock_v1) {\n\t\text_session_lock_v1_unlock_and_destroy(state.ext_session_lock_v1);\n\t\twl_display_flush(state.display);\n\t}\n\n\tfree(state.args.font);\n\treturn 0;\n}",
  "abstract_func": "int main(int VAR_0, char **VAR_1) {\n\tswaylock_log_init(VAR_2);\n\tinitialize_pw_backend(VAR_0, VAR_1);\n\tsrand(time(NULL));\n\n\tenum line_mode line_mode = VAR_3;\n\tVAR_4.failed_attempts = 0;\n\tVAR_4.args = (struct swaylock_args){\n\t\t.mode = VAR_5,\n\t\t.font = strdup(\"sans-serif\"),\n\t\t.font_size = 0,\n\t\t.radius = 50,\n\t\t.thickness = 10,\n\t\t.indicator_x_position = 0,\n\t\t.indicator_y_position = 0,\n\t\t.override_indicator_x_position = false,\n\t\t.override_indicator_y_position = false,\n\t\t.ignore_empty = false,\n\t\t.show_indicator = true,\n\t\t.show_caps_lock_indicator = false,\n\t\t.show_caps_lock_text = true,\n\t\t.show_keyboard_layout = false,\n\t\t.hide_keyboard_layout = false,\n\t\t.show_failed_attempts = false,\n\t\t.indicator_idle_visible = false\n\t};\n\twl_list_init(&VAR_4.images);\n\tset_default_colors(&VAR_4.args.colors);\n\n\tchar *VAR_6 = NULL;\n\tint VAR_7 = parse_options(VAR_0, VAR_1, NULL, NULL, &VAR_6);\n\tif (VAR_7 != 0) {\n\t\tfree(VAR_6);\n\t\treturn VAR_7;\n\t}\n\tif (!VAR_6) {\n\t\tVAR_6 = get_config_path();\n\t}\n\n\tif (VAR_6) {\n\t\tswaylock_log(VAR_8, \"Found config at %s\", VAR_6);\n\t\tint VAR_9 = load_config(VAR_6, &VAR_4, &line_mode);\n\t\tfree(VAR_6);\n\t\tif (VAR_9 != 0) {\n\t\t\tfree(VAR_4.args.font);\n\t\t\treturn VAR_9;\n\t\t}\n\t}\n\n\tif (VAR_0 > 1) {\n\t\tswaylock_log(VAR_8, \"Parsing CLI Args\");\n\t\tint VAR_7 = parse_options(VAR_0, VAR_1, &VAR_4, &line_mode, NULL);\n\t\tif (VAR_7 != 0) {\n\t\t\tfree(VAR_4.args.font);\n\t\t\treturn VAR_7;\n\t\t}\n\t}\n\n\tif (line_mode == VAR_10) {\n\t\tVAR_4.args.colors.line = VAR_4.args.colors.inside;\n\t} else if (line_mode == VAR_11) {\n\t\tVAR_4.args.colors.line = VAR_4.args.colors.ring;\n\t}\n\n#ifdef VAR_12\n\t/* COMMENT_0 */\n\tif (mlock(VAR_4.password.buffer, sizeof(VAR_4.password.buffer)) != 0) {\n\t\tswaylock_log(VAR_2, \"Unable to mlock() password memory.\");\n\t\treturn VAR_13;\n\t}\n#endif\n\n\twl_list_init(&VAR_4.surfaces);\n\tVAR_4.xkb.context = xkb_context_new(VAR_14);\n\tVAR_4.display = wl_display_connect(NULL);\n\tif (!VAR_4.display) {\n\t\tfree(VAR_4.args.font);\n\t\tswaylock_log(VAR_2, \"Unable to connect to the compositor. \"\n\t\t\t\t\"If your compositor is running, check or set the \"\n\t\t\t\t\"WAYLAND_DISPLAY environment variable.\");\n\t\treturn VAR_13;\n\t}\n\n\tstruct wl_registry *VAR_15 = wl_display_get_registry(VAR_4.display);\n\twl_registry_add_listener(VAR_15, &VAR_16, &VAR_4);\n\twl_display_roundtrip(VAR_4.display);\n\n\tif (!VAR_4.compositor || !VAR_4.shm) {\n\t\tswaylock_log(VAR_2, \"Missing wl_compositor or wl_shm\");\n\t\treturn 1;\n\t}\n\n\tif (VAR_4.ext_session_lock_manager_v1) {\n\t\tswaylock_log(VAR_8, \"Using ext-session-lock-v1\");\n\t\tVAR_4.ext_session_lock_v1 = ext_session_lock_manager_v1_lock(VAR_4.ext_session_lock_manager_v1);\n\t\text_session_lock_v1_add_listener(VAR_4.ext_session_lock_v1,\n\t\t\t\t&VAR_17, &VAR_4);\n\t} else if (VAR_4.layer_shell && VAR_4.input_inhibit_manager) {\n\t\tswaylock_log(VAR_8, \"Using wlr-layer-shell + wlr-input-inhibitor\");\n\t\tzwlr_input_inhibit_manager_v1_get_inhibitor(VAR_4.input_inhibit_manager);\n\t} else {\n\t\tswaylock_log(VAR_2, \"Missing ext-session-lock-v1, wlr-layer-shell \"\n\t\t\t\t\"and wlr-input-inhibitor\");\n\t\treturn 1;\n\t}\n\n\tif (wl_display_roundtrip(VAR_4.display) == -1) {\n\t\tfree(VAR_4.args.font);\n\t\tif (VAR_4.input_inhibit_manager) {\n\t\t\tswaylock_log(VAR_2, \"Exiting - failed to inhibit input:\"\n\t\t\t\t\t\" is another lockscreen already running?\");\n\t\t\treturn 2;\n\t\t}\n\t\treturn 1;\n\t}\n\n\tif (VAR_4.zxdg_output_manager) {\n\t\tstruct swaylock_surface *VAR_18;\n\t\twl_list_for_each(VAR_18, &VAR_4.surfaces, VAR_19) {\n\t\t\tVAR_18->xdg_output = zxdg_output_manager_v1_get_xdg_output(\n\t\t\t\t\t\tVAR_4.zxdg_output_manager, VAR_18->output);\n\t\t\tzxdg_output_v1_add_listener(\n\t\t\t\t\tVAR_18->xdg_output, &VAR_20, VAR_18);\n\t\t}\n\t\twl_display_roundtrip(VAR_4.display);\n\t} else {\n\t\tswaylock_log(VAR_21, \"Compositor does not support zxdg output \"\n\t\t\t\t\"manager, images assigned to named outputs will not work\");\n\t}\n\n\tstruct swaylock_surface *VAR_18;\n\twl_list_for_each(VAR_18, &VAR_4.surfaces, VAR_19) {\n\t\tcreate_surface(VAR_18);\n\t}\n\n\tif (VAR_4.args.daemonize) {\n\t\twl_display_roundtrip(VAR_4.display);\n\t\tdaemonize();\n\t}\n\n\tVAR_4.eventloop = loop_create();\n\tloop_add_fd(VAR_4.eventloop, wl_display_get_fd(VAR_4.display), VAR_22,\n\t\t\tVAR_23, NULL);\n\n\tloop_add_fd(VAR_4.eventloop, get_comm_reply_fd(), VAR_22, VAR_24, NULL);\n\n\tVAR_4.run_display = true;\n\twhile (VAR_4.run_display) {\n\t\tVAR_25 = 0;\n\t\tif (wl_display_flush(VAR_4.display) == -1 && VAR_25 != VAR_26) {\n\t\t\tbreak;\n\t\t}\n\t\tloop_poll(VAR_4.eventloop);\n\t}\n\n\tif (VAR_4.ext_session_lock_v1) {\n\t\text_session_lock_v1_unlock_and_destroy(VAR_4.ext_session_lock_v1);\n\t\twl_display_flush(VAR_4.display);\n\t}\n\n\tfree(VAR_4.args.font);\n\treturn 0;\n}",
  "func_graph_path": "swaywm/swaylock/1d1c75b6316d21933069a9d201f966d84099f6ca/main.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -84,20 +84,34 @@\n \tstruct wl_registry *registry = wl_display_get_registry(state.display);\n \twl_registry_add_listener(registry, &registry_listener, &state);\n \twl_display_roundtrip(state.display);\n-\tassert(state.compositor && state.layer_shell && state.shm);\n-\tif (!state.input_inhibit_manager) {\n-\t\tfree(state.args.font);\n-\t\tswaylock_log(LOG_ERROR, \"Compositor does not support the input \"\n-\t\t\t\t\"inhibitor protocol, refusing to run insecurely\");\n+\n+\tif (!state.compositor || !state.shm) {\n+\t\tswaylock_log(LOG_ERROR, \"Missing wl_compositor or wl_shm\");\n \t\treturn 1;\n \t}\n \n-\tzwlr_input_inhibit_manager_v1_get_inhibitor(state.input_inhibit_manager);\n+\tif (state.ext_session_lock_manager_v1) {\n+\t\tswaylock_log(LOG_DEBUG, \"Using ext-session-lock-v1\");\n+\t\tstate.ext_session_lock_v1 = ext_session_lock_manager_v1_lock(state.ext_session_lock_manager_v1);\n+\t\text_session_lock_v1_add_listener(state.ext_session_lock_v1,\n+\t\t\t\t&ext_session_lock_v1_listener, &state);\n+\t} else if (state.layer_shell && state.input_inhibit_manager) {\n+\t\tswaylock_log(LOG_DEBUG, \"Using wlr-layer-shell + wlr-input-inhibitor\");\n+\t\tzwlr_input_inhibit_manager_v1_get_inhibitor(state.input_inhibit_manager);\n+\t} else {\n+\t\tswaylock_log(LOG_ERROR, \"Missing ext-session-lock-v1, wlr-layer-shell \"\n+\t\t\t\t\"and wlr-input-inhibitor\");\n+\t\treturn 1;\n+\t}\n+\n \tif (wl_display_roundtrip(state.display) == -1) {\n \t\tfree(state.args.font);\n-\t\tswaylock_log(LOG_ERROR, \"Exiting - failed to inhibit input:\"\n-\t\t\t\t\" is another lockscreen already running?\");\n-\t\treturn 2;\n+\t\tif (state.input_inhibit_manager) {\n+\t\t\tswaylock_log(LOG_ERROR, \"Exiting - failed to inhibit input:\"\n+\t\t\t\t\t\" is another lockscreen already running?\");\n+\t\t\treturn 2;\n+\t\t}\n+\t\treturn 1;\n \t}\n \n \tif (state.zxdg_output_manager) {\n@@ -116,7 +130,7 @@\n \n \tstruct swaylock_surface *surface;\n \twl_list_for_each(surface, &state.surfaces, link) {\n-\t\tcreate_layer_surface(surface);\n+\t\tcreate_surface(surface);\n \t}\n \n \tif (state.args.daemonize) {\n@@ -139,6 +153,11 @@\n \t\tloop_poll(state.eventloop);\n \t}\n \n+\tif (state.ext_session_lock_v1) {\n+\t\text_session_lock_v1_unlock_and_destroy(state.ext_session_lock_v1);\n+\t\twl_display_flush(state.display);\n+\t}\n+\n \tfree(state.args.font);\n \treturn 0;\n }",
  "diff_line_info": {
    "deleted_lines": [
      "\tassert(state.compositor && state.layer_shell && state.shm);",
      "\tif (!state.input_inhibit_manager) {",
      "\t\tfree(state.args.font);",
      "\t\tswaylock_log(LOG_ERROR, \"Compositor does not support the input \"",
      "\t\t\t\t\"inhibitor protocol, refusing to run insecurely\");",
      "\tzwlr_input_inhibit_manager_v1_get_inhibitor(state.input_inhibit_manager);",
      "\t\tswaylock_log(LOG_ERROR, \"Exiting - failed to inhibit input:\"",
      "\t\t\t\t\" is another lockscreen already running?\");",
      "\t\treturn 2;",
      "\t\tcreate_layer_surface(surface);"
    ],
    "added_lines": [
      "",
      "\tif (!state.compositor || !state.shm) {",
      "\t\tswaylock_log(LOG_ERROR, \"Missing wl_compositor or wl_shm\");",
      "\tif (state.ext_session_lock_manager_v1) {",
      "\t\tswaylock_log(LOG_DEBUG, \"Using ext-session-lock-v1\");",
      "\t\tstate.ext_session_lock_v1 = ext_session_lock_manager_v1_lock(state.ext_session_lock_manager_v1);",
      "\t\text_session_lock_v1_add_listener(state.ext_session_lock_v1,",
      "\t\t\t\t&ext_session_lock_v1_listener, &state);",
      "\t} else if (state.layer_shell && state.input_inhibit_manager) {",
      "\t\tswaylock_log(LOG_DEBUG, \"Using wlr-layer-shell + wlr-input-inhibitor\");",
      "\t\tzwlr_input_inhibit_manager_v1_get_inhibitor(state.input_inhibit_manager);",
      "\t} else {",
      "\t\tswaylock_log(LOG_ERROR, \"Missing ext-session-lock-v1, wlr-layer-shell \"",
      "\t\t\t\t\"and wlr-input-inhibitor\");",
      "\t\treturn 1;",
      "\t}",
      "",
      "\t\tif (state.input_inhibit_manager) {",
      "\t\t\tswaylock_log(LOG_ERROR, \"Exiting - failed to inhibit input:\"",
      "\t\t\t\t\t\" is another lockscreen already running?\");",
      "\t\t\treturn 2;",
      "\t\t}",
      "\t\treturn 1;",
      "\t\tcreate_surface(surface);",
      "\tif (state.ext_session_lock_v1) {",
      "\t\text_session_lock_v1_unlock_and_destroy(state.ext_session_lock_v1);",
      "\t\twl_display_flush(state.display);",
      "\t}",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/swaywm/swaylock/pull/219",
  "description": {
    "pr_info": {
      "title": "Add support for ext-session-lock-v1 ",
      "number": 219
    },
    "comment": [
      "This is a new protocol to lock the session [1]. It should be more\r\nreliable than layer-shell + input-inhibitor.\r\n\r\n- [x] Bump wayland-protocols dep version\r\n\r\n[1]: https://gitlab.freedesktop.org/wayland/wayland-protocols/-/merge_requests/131\r\n\r\nTo build locally:\r\n\r\n```sh\r\nmkdir subprojects\r\ngit clone \"git@gitlab.freedesktop.org:ifreund/wayland-protocols.git\" -b ext-lock-v1 subprojects/wayland-protocols\r\nmeson configure build/ --force-fallback-for=wayland-protocols\r\n```",
      "Addressed the comments, thanks for the review!"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "Final Classification: Defect Remediation & Feature Upgrades; Confidence: 0.9"
}