{
  "cve_id": "CVE-2021-28167",
  "cwe_ids": [
    "CWE-909"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "eclipse-openj9/openj9",
  "commit_msg": "Correctly load/initialize classes when using ConstantPool\n\n- do not load classes in the \"ifLoaded\" calls\n- never intitialize classes in the natives\n- do not update the constant pool when querying from the natives\n\nFixes: #12016\n\n[ci skip]\n\nSigned-off-by: Graham Chapman <graham_chapman@ca.ibm.com>",
  "commit_hash": "840f3af31a5b8d2d395d9367c826ed756e380fb9",
  "git_url": "https://github.com/eclipse-openj9/openj9/commit/840f3af31a5b8d2d395d9367c826ed756e380fb9",
  "file_path": "runtime/vm/resolvesupport.cpp",
  "func_name": "resolveVirtualMethodRefInto",
  "func_before": "UDATA   \nresolveVirtualMethodRefInto(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags, J9Method **resolvedMethod, J9RAMVirtualMethodRef *ramCPEntry)\n{\n\tUDATA vTableOffset = 0;\n\tJ9ROMMethodRef *romMethodRef = NULL;\n\tJ9Class *resolvedClass = NULL;\n\tJ9JavaVM *vm = vmStruct->javaVM;\n\tbool jitCompileTimeResolve = J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_JIT_COMPILE_TIME);\n\tbool canRunJavaCode = !jitCompileTimeResolve && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_REDEFINE_CLASS);\n\tbool throwException = canRunJavaCode && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);\n\tUDATA lookupOptions = 0;\n\tif (canRunJavaCode) {\n\t\tif (!throwException) {\n\t\t\tlookupOptions = J9_LOOK_NO_THROW;\t\t\t\n\t\t}\n\t} else {\n\t\tlookupOptions = J9_LOOK_NO_JAVA;\n\t}\n\n\tTrc_VM_resolveVirtualMethodRef_Entry(vmStruct, ramCP, cpIndex, resolveFlags, resolvedMethod);\n\n\tromMethodRef = (J9ROMMethodRef *)&ramCP->romConstantPool[cpIndex];\n\n\tcheckForDecompile(vmStruct, romMethodRef, jitCompileTimeResolve);\n\n\t/* Resolve the class. */\n\tresolvedClass = resolveClassRef(vmStruct, ramCP, romMethodRef->classRefCPIndex, resolveFlags);\n\n\t/* If resolvedClass is NULL, the exception has already been set. */\n\tif (NULL != resolvedClass) {\n\t\tJ9ROMNameAndSignature *nameAndSig = J9ROMFIELDREF_NAMEANDSIGNATURE(romMethodRef);\n\t\tU_32 *cpShapeDescription = NULL;\n\t\tJ9Method *method = NULL;\n\t\tJ9Class *cpClass = NULL;\n\n\t\t/* Stack allocate a byte array for MethodHandle & VarHandle method name and signature. The array size is:\n\t\t *  - J9ROMNameAndSignature\n\t\t *  - Modified method name\n\t\t *      - U_16 for J9UTF8 length\n\t\t *      - 26 bytes for the original method name (\"compareAndExchangeAcquire\" is the longest)\n\t\t *      - 5 bytes for \"_impl\".\n\t\t *  - J9UTF8 for empty signature\n\t\t */\n\t\tU_8 onStackNAS[sizeof(J9ROMNameAndSignature) + (sizeof(U_16) + 26 + 5) + sizeof(J9UTF8)];\n\n\t\tlookupOptions |= J9_LOOK_VIRTUAL;\n\t\tif ((resolveFlags & J9_RESOLVE_FLAG_JCL_CONSTANT_POOL) == J9_RESOLVE_FLAG_JCL_CONSTANT_POOL) {\n\t\t\tcpClass = NULL;\n\t\t} else {\n\t\t\tcpClass = J9_CLASS_FROM_CP(ramCP);\n\t\t\tcpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(cpClass->romClass);\n\t\t\tlookupOptions |= J9_LOOK_CLCONSTRAINTS;\n\t\t}\n\n#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n\t\tJ9UTF8 nullSignature = {0};\n\t\tif ((NULL != cpShapeDescription) && (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(vm))) {\n\t\t\t/**\n\t\t\t * Check for MH intrinsic methods\n\t\t\t *\n\t\t\t * Modify the signature to avoid signature mismatch due to varargs\n\t\t\t * These methods have special INL send targets\n\t\t\t */\n\t\t\tJ9UTF8 *nameUTF = J9ROMNAMEANDSIGNATURE_NAME(nameAndSig);\n\t\t\tU_8* methodName = J9UTF8_DATA(nameUTF);\n\t\t\tU_16 methodNameLength = J9UTF8_LENGTH(nameUTF);\n\n\t\t\tif (isMethodHandleINL(methodName, methodNameLength)) {\n\t\t\t\t/* Create new J9NameAndSignature */\n\t\t\t\t((J9NameAndSignature *)onStackNAS)->name = nameUTF;\n\t\t\t\t((J9NameAndSignature *)onStackNAS)->signature = &nullSignature;\n\t\t\t\tnameAndSig = (J9ROMNameAndSignature *)(&onStackNAS);\n\n\t\t\t\t/* Set flag for partial signature lookup. Signature length is already initialized to 0. */\n\t\t\t\tlookupOptions |= (J9_LOOK_DIRECT_NAS | J9_LOOK_PARTIAL_SIGNATURE);\n\t\t\t}\n\t\t}\n#elif defined(J9VM_OPT_METHOD_HANDLE) /* defined(J9VM_OPT_OPENJDK_METHODHANDLE) */\n\t\tif ((NULL != cpShapeDescription) && (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(vm))) {\n\t\t\t/*\n\t\t\t* Check for MH.invoke and MH.invokeExact.\n\t\t\t*\n\t\t\t* Methodrefs corresponding to those methods already have their methodIndex set to index into\n\t\t\t* cpClass->methodTypes. We resolve them by calling into MethodType.fromMethodDescriptorString()\n\t\t\t* and storing the result into the cpClass->methodTypes table.\n\t\t\t*/\n\t\t\tJ9UTF8 *nameUTF = J9ROMNAMEANDSIGNATURE_NAME(nameAndSig);\n\t\t\tJ9UTF8 *sigUTF = J9ROMNAMEANDSIGNATURE_SIGNATURE(nameAndSig);\n\t\t\tif ((J9CPTYPE_HANDLE_METHOD == J9_CP_TYPE(cpShapeDescription, cpIndex))\n\t\t\t|| J9UTF8_LITERAL_EQUALS(J9UTF8_DATA(nameUTF), J9UTF8_LENGTH(nameUTF), \"invokeExact\")\n\t\t\t|| J9UTF8_LITERAL_EQUALS(J9UTF8_DATA(nameUTF), J9UTF8_LENGTH(nameUTF), \"invoke\")\n\t\t\t) {\n\t\t\t\tJ9RAMMethodRef *ramMethodRef = (J9RAMMethodRef *)&ramCP[cpIndex];\n\t\t\t\tUDATA methodTypeIndex = ramMethodRef->methodIndexAndArgCount >> 8;\n\t\t\t\tj9object_t methodType = NULL;\n\n\t\t\t\t/* Return NULL if not allowed to run java code. The only way to resolve\n\t\t\t\t * a MethodType object is to call-in using MethodType.fromMethodDescriptorString()\n\t\t\t\t * which runs Java code.\n\t\t\t\t */\n\t\t\t\tif (!canRunJavaCode) {\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\t/* Throw LinkageError if more than 255 stack slots are\n\t\t\t\t * required by the MethodType and the MethodHandle.\n\t\t\t\t */\n\t\t\t\tif (MAX_STACK_SLOTS == (ramMethodRef->methodIndexAndArgCount & MAX_STACK_SLOTS)) {\n\t\t\t\t\tif (throwException) {\n\t\t\t\t\t\tsetCurrentExceptionNLS(vmStruct, J9VMCONSTANTPOOL_JAVALANGLINKAGEERROR, J9NLS_VM_TOO_MANY_ARGUMENTS);\n\t\t\t\t\t}\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\t/* Call VM Entry point to create the MethodType - Result is put into the\n\t\t\t\t * vmThread->returnValue as entry points don't \"return\" in the expected way\n\t\t\t\t */\n\t\t\t\tsendFromMethodDescriptorString(vmStruct, sigUTF, J9_CLASS_FROM_CP(ramCP)->classLoader, NULL);\n\t\t\t\tmethodType = (j9object_t) vmStruct->returnValue;\n\n\t\t\t\t/* check if an exception is already pending */\n\t\t\t\tif (threadEventsPending(vmStruct)) {\n\t\t\t\t\t/* Already a pending exception */\n\t\t\t\t\tmethodType = NULL;\n\t\t\t\t} else if (NULL == methodType) {\n\t\t\t\t\t/* Resolved MethodType was null - throw NPE that includes the lookupSignature from the NaS */\n\t\t\t\t\tj9object_t lookupSigString = vm->memoryManagerFunctions->j9gc_createJavaLangString(vmStruct, J9UTF8_DATA(sigUTF), J9UTF8_LENGTH(sigUTF), 0);\n\t\t\t\t\tif (throwException) {\n\t\t\t\t\t\tif (NULL == vmStruct->currentException) {\n\t\t\t\t\t\t\tsetCurrentException(vmStruct, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, (UDATA*)lookupSigString);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tVM_VMHelpers::clearException(vmStruct);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* Only write the value in if its not null */\n\t\t\t\tif (NULL != methodType) {\n\t\t\t\t\tJ9Class *clazz = J9_CLASS_FROM_CP(ramCP);\n\t\t\t\t\tj9object_t *methodTypeObjectP = clazz->methodTypes + methodTypeIndex;\n\t\t\t\t\t/* Overwriting NULL with an immortal pointer, so no exception can occur */\n\t\t\t\t\tJ9STATIC_OBJECT_STORE(vmStruct, clazz, methodTypeObjectP, methodType);\n\n\t\t\t\t\t/* Record vTableOffset for the exit tracepoint. */\n\t\t\t\t\tvTableOffset = methodTypeIndex;\n\t\t\t\t}\n\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t} else if (resolvedClass == J9VMJAVALANGINVOKEVARHANDLE_OR_NULL(vm)) {\n\t\t\tJ9UTF8 *nameUTF = J9ROMNAMEANDSIGNATURE_NAME(nameAndSig);\n\t\t\tJ9UTF8 *sigUTF = J9ROMNAMEANDSIGNATURE_SIGNATURE(nameAndSig);\n\t\t\tU_8* initialMethodName = J9UTF8_DATA(nameUTF);\n\t\t\tU_16 initialMethodNameLength = J9UTF8_LENGTH(nameUTF);\n\t\t\tBOOLEAN isVarHandle = FALSE;\n\n\t\t\tswitch (initialMethodNameLength) {\n\t\t\tcase 3:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"get\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"set\")\n\t\t\t\t) {\n\t\t\t\t\tisVarHandle = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getOpaque\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"setOpaque\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndSet\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndAdd\")\n\t\t\t\t) {\n\t\t\t\t\tisVarHandle = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 10:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAcquire\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"setRelease\")\n\t\t\t\t) {\n\t\t\t\t\tisVarHandle = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 11:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getVolatile\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"setVolatile\")\n\t\t\t\t) {\n\t\t\t\t\tisVarHandle = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 16:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndSetAcquire\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndSetRelease\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndAddAcquire\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndAddRelease\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndBitwiseAnd\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndBitwiseXor\")\n\t\t\t\t) {\n\t\t\t\t\tisVarHandle = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 22:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndBitwiseOrAcquire\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndBitwiseOrRelease\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"weakCompareAndSetPlain\")\n\t\t\t\t) {\n\t\t\t\t\tisVarHandle = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 23:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndBitwiseAndAcquire\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndBitwiseAndRelease\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndBitwiseXorAcquire\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndBitwiseXorRelease\")\n\t\t\t\t) {\n\t\t\t\t\tisVarHandle = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 24:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"weakCompareAndSetAcquire\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"weakCompareAndSetRelease\")\n\t\t\t\t) {\n\t\t\t\t\tisVarHandle = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 25:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"compareAndExchangeAcquire\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"compareAndExchangeRelease\")\n\t\t\t\t) {\n\t\t\t\t\tisVarHandle = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"compareAndSet\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndBitwiseOr\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"weakCompareAndSet\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"compareAndExchange\")\n\t\t\t\t) {\n\t\t\t\t\tisVarHandle = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (isVarHandle) {\n\t\t\t\tJ9UTF8 *modifiedMethodName = (J9UTF8 *)(onStackNAS + sizeof(J9ROMNameAndSignature));\n\t\t\t\tJ9UTF8 *modifiedMethodSig = (J9UTF8 *)(onStackNAS + sizeof(onStackNAS) - sizeof(J9UTF8));\n\t\t\t\tmemset(onStackNAS, 0, sizeof(onStackNAS));\n\n\t\t\t\t/* Create new J9ROMNameAndSignature */\n\t\t\t\tnameAndSig = (J9ROMNameAndSignature *)onStackNAS;\n\t\t\t\tNNSRP_SET(nameAndSig->name, modifiedMethodName);\n\t\t\t\tNNSRP_SET(nameAndSig->signature, modifiedMethodSig);\n\n\t\t\t\t/* Change method name to include the suffix \"_impl\", which are the methods with VarHandle send targets. */\n\t\t\t\tJ9UTF8_SET_LENGTH(modifiedMethodName, initialMethodNameLength + 5);\n\t\t\t\tmemcpy(J9UTF8_DATA(modifiedMethodName), initialMethodName, initialMethodNameLength);\n\t\t\t\tmemcpy(J9UTF8_DATA(modifiedMethodName) + initialMethodNameLength, \"_impl\", 5);\n\n\t\t\t\t/* Set flag for partial signature lookup. Signature length is already initialized to 0. */\n\t\t\t\tlookupOptions |= J9_LOOK_PARTIAL_SIGNATURE;\n\n\t\t\t\t/* Redirect resolution to VarHandleInternal */\n\t\t\t\tresolvedClass = VM_VMHelpers::getSuperclass(resolvedClass);\n\n\t\t\t\t/* Ensure visibility passes */\n\t\t\t\tcpClass = resolvedClass;\n\n\t\t\t\t/* Resolve the MethodType. */\n\t\t\t\tif (canRunJavaCode) {\n\t\t\t\t\tj9object_t methodType = NULL;\n\t\t\t\t\tJ9Class *ramClass = ramCP->ramClass;\n\t\t\t\t\tJ9ROMClass *romClass = ramClass->romClass;\n\t\t\t\t\tJ9RAMMethodRef *ramMethodRef = (J9RAMMethodRef *)&ramCP[cpIndex];\n\n\t\t\t\t\t/* Throw LinkageError if more than 255 stack slots are\n\t\t\t\t\t * required by the MethodType and the MethodHandle.\n\t\t\t\t\t */\n\t\t\t\t\tif (MAX_STACK_SLOTS == (ramMethodRef->methodIndexAndArgCount & MAX_STACK_SLOTS)) {\n\t\t\t\t\t\tif (throwException) {\n\t\t\t\t\t\t\tsetCurrentExceptionNLS(vmStruct, J9VMCONSTANTPOOL_JAVALANGLINKAGEERROR, J9NLS_VM_TOO_MANY_ARGUMENTS);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Call VM Entry point to create the MethodType - Result is put into the\n\t\t\t\t\t * vmThread->returnValue as entry points don't \"return\" in the expected way\n\t\t\t\t\t *\n\t\t\t\t\t * NB! An extra VarHandle argument is appended to the MethodType's argument list,\n\t\t\t\t\t * so the returned MethodType doesn't represent the provided method signature.\n\t\t\t\t\t * E.g. the MethodType for \"(I)I\" will have the following descriptor string:\n\t\t\t\t\t *     \"(Ijava/lang/invoke/VarHandle;)I\"\n\t\t\t\t\t */\n\t\t\t\t\tsendFromMethodDescriptorString(vmStruct, sigUTF, J9_CLASS_FROM_CP(ramCP)->classLoader, J9VMJAVALANGINVOKEVARHANDLE_OR_NULL(vm));\n\t\t\t\t\tmethodType = (j9object_t)vmStruct->returnValue;\n\n\t\t\t\t\t/* Check if an exception is already pending */\n\t\t\t\t\tif (threadEventsPending(vmStruct)) {\n\t\t\t\t\t\t/* Already a pending exception */\n\t\t\t\t\t\tmethodType = NULL;\n\t\t\t\t\t} else if (NULL == methodType) {\n\t\t\t\t\t\t/* Resolved MethodType was null - throw NPE that includes the lookupSignature from the NaS */\n\t\t\t\t\t\tj9object_t lookupSigString = vm->memoryManagerFunctions->j9gc_createJavaLangString(vmStruct, J9UTF8_DATA(sigUTF), J9UTF8_LENGTH(sigUTF), 0);\n\t\t\t\t\t\tif (throwException) {\n\t\t\t\t\t\t\tif (NULL == vmStruct->currentException) {\n\t\t\t\t\t\t\t\tsetCurrentException(vmStruct, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, (UDATA*)lookupSigString);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tVM_VMHelpers::clearException(vmStruct);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Store MethodType in cache */\n\t\t\t\t\tif (NULL != methodType) {\n\t\t\t\t\t\tU_32 methodTypeIndex = VM_VMHelpers::lookupVarHandleMethodTypeCacheIndex(romClass, cpIndex);\n\t\t\t\t\t\tj9object_t *methodTypeObjectP = ramClass->varHandleMethodTypes + methodTypeIndex;\n\t\t\t\t\t\tJ9STATIC_OBJECT_STORE(vmStruct, ramClass, methodTypeObjectP, methodType);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#else /* defined(J9VM_OPT_METHOD_HANDLE) */\n\t\tTrc_VM_Assert_ShouldNeverHappen();\n#endif /* defined(J9VM_OPT_METHOD_HANDLE) */\n\n\t\tmethod = (J9Method *)javaLookupMethod(vmStruct, resolvedClass, nameAndSig, cpClass, lookupOptions);\n\n\t\tTrc_VM_resolveVirtualMethodRef_lookupMethod(vmStruct, method);\n\n\t\t/* If method is NULL, the exception has already been set. */\n\t\tif (NULL != method) {\n\t\t\tJ9ROMMethod* romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(method);\n\t\t\t/* Only allow non-interface method to call invokePrivate, private interface method should use \"invokeInterface\" bytecode\n\t\t\t * The else case will throw ICCE for private interface method \n\t\t\t */\n\t\t\tif (!J9ROMMETHOD_HAS_VTABLE(romMethod) && J9_ARE_NO_BITS_SET(resolvedClass->romClass->modifiers, J9AccInterface)) {\n\t\t\t\t/* Private method found, will not be in vTable, point vTable index to invokePrivate */\n\t\t\t\tif (NULL != ramCPEntry) {\n\t\t\t\t\tramCPEntry->method = method;\n\t\t\t\t\tUDATA methodIndexAndArgCount = J9VTABLE_INVOKE_PRIVATE_OFFSET << 8;\n\t\t\t\t\tmethodIndexAndArgCount |= (ramCPEntry->methodIndexAndArgCount & 255);\n\t\t\t\t\tramCPEntry->methodIndexAndArgCount = methodIndexAndArgCount;\n\t\t\t\t}\n\t\t\t\tif (NULL != resolvedMethod) {\n\t\t\t\t\t/* save away method for callee */\n\t\t\t\t\t*resolvedMethod = method;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* Fill in the constant pool entry. Don't bother checking for failure on the vtable index, since we know the method is there. */\n\t\t\t\tvTableOffset = getVTableOffsetForMethod(method, resolvedClass, vmStruct);\n\t\t\t\tif (0 == vTableOffset) {\n\t\t\t\t\tif (throwException) {\n\t\t\t\t\t\tj9object_t errorString = methodToString(vmStruct, method);\n\t\t\t\t\t\tif (NULL != errorString) {\n\t\t\t\t\t\t\tsetCurrentException(vmStruct, J9VMCONSTANTPOOL_JAVALANGINCOMPATIBLECLASSCHANGEERROR, (UDATA *)errorString);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (ramCPEntry != NULL) {\n\t\t\t\t\t\tUDATA argSlotCount = vTableOffset << 8;\n\t\t\t\t\t\targSlotCount |= (ramCPEntry->methodIndexAndArgCount & 255);\n\t\t\t\t\t\tramCPEntry->methodIndexAndArgCount = argSlotCount;\n\t\t\t\t\t}\n\t\t\t\t\tif (NULL != resolvedMethod) {\n\t\t\t\t\t\t/* save away method for callee */\n\t\t\t\t\t\t*resolvedMethod = method;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n#if defined(J9VM_OPT_METHOD_HANDLE)\ndone:\n#endif /* defined(J9VM_OPT_METHOD_HANDLE) */\n\tTrc_VM_resolveVirtualMethodRef_Exit(vmStruct, vTableOffset);\n\treturn vTableOffset;\n}",
  "abstract_func_before": "UDATA   \nresolveVirtualMethodRefInto(J9VMThread *VAR_0, J9ConstantPool *VAR_1, UDATA VAR_2, UDATA VAR_3, J9Method **VAR_4, J9RAMVirtualMethodRef *VAR_5)\n{\n\tUDATA VAR_6 = 0;\n\tJ9ROMMethodRef *VAR_7 = NULL;\n\tJ9Class *VAR_8 = NULL;\n\tJ9JavaVM *VAR_9 = VAR_0->javaVM;\n\tbool VAR_10 = J9_ARE_ANY_BITS_SET(VAR_3, VAR_11);\n\tbool VAR_12 = !VAR_10 && J9_ARE_NO_BITS_SET(VAR_3, VAR_13);\n\tbool VAR_14 = VAR_12 && J9_ARE_NO_BITS_SET(VAR_3, VAR_15);\n\tUDATA VAR_16 = 0;\n\tif (VAR_12) {\n\t\tif (!VAR_14) {\n\t\t\tVAR_16 = VAR_17;\t\t\t\n\t\t}\n\t} else {\n\t\tVAR_16 = VAR_18;\n\t}\n\n\tTrc_VM_resolveVirtualMethodRef_Entry(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4);\n\n\tVAR_7 = (J9ROMMethodRef *)&VAR_1->romConstantPool[VAR_2];\n\n\tcheckForDecompile(VAR_0, VAR_7, VAR_10);\n\n\t/* COMMENT_0 */\n\tVAR_8 = resolveClassRef(VAR_0, VAR_1, VAR_7->classRefCPIndex, VAR_3);\n\n\t/* COMMENT_1 */\n\tif (NULL != VAR_8) {\n\t\tJ9ROMNameAndSignature *VAR_19 = J9ROMFIELDREF_NAMEANDSIGNATURE(VAR_7);\n\t\tU_32 *VAR_20 = NULL;\n\t\tJ9Method *VAR_21 = NULL;\n\t\tJ9Class *VAR_22 = NULL;\n\n\t\t/* COMMENT_2 */\n                             \n                            \n                                  \n                                                                                              \n                                \n                                  \n     \n\t\tU_8 VAR_23[sizeof(J9ROMNameAndSignature) + (sizeof(VAR_24) + 26 + 5) + sizeof(VAR_25)];\n\n\t\tVAR_16 |= VAR_26;\n\t\tif ((VAR_3 & VAR_27) == VAR_27) {\n\t\t\tVAR_22 = NULL;\n\t\t} else {\n\t\t\tVAR_22 = J9_CLASS_FROM_CP(VAR_1);\n\t\t\tVAR_20 = J9ROMCLASS_CPSHAPEDESCRIPTION(VAR_22->romClass);\n\t\t\tVAR_16 |= VAR_28;\n\t\t}\n\n#if defined(VAR_29)\n\t\tJ9UTF8 VAR_30 = {0};\n\t\tif ((NULL != VAR_20) && (VAR_8 == J9VMJAVALANGINVOKEMETHODHANDLE(VAR_9))) {\n\t\t\t/* COMMENT_10 */\n                                    \n     \n                                                                     \n                                                 \n      \n\t\t\tJ9UTF8 *VAR_31 = J9ROMNAMEANDSIGNATURE_NAME(VAR_19);\n\t\t\tU_8* VAR_32 = J9UTF8_DATA(VAR_31);\n\t\t\tU_16 VAR_33 = J9UTF8_LENGTH(VAR_31);\n\n\t\t\tif (isMethodHandleINL(VAR_32, VAR_33)) {\n\t\t\t\t/* COMMENT_16 */\n\t\t\t\t((J9NameAndSignature *)VAR_23)->name = VAR_31;\n\t\t\t\t((J9NameAndSignature *)VAR_23)->signature = &VAR_30;\n\t\t\t\tVAR_19 = (J9ROMNameAndSignature *)(&VAR_23);\n\n\t\t\t\t/* COMMENT_17 */\n\t\t\t\tVAR_16 |= (VAR_34 | VAR_35);\n\t\t\t}\n\t\t}\n#elif defined(VAR_36) /* COMMENT_18 */\n\t\tif ((NULL != VAR_20) && (VAR_8 == J9VMJAVALANGINVOKEMETHODHANDLE(VAR_9))) {\n\t\t\t/* COMMENT_19 */\n                                            \n    \n                                                                                               \n                                                                                                  \n                                                                \n     \n\t\t\tJ9UTF8 *VAR_31 = J9ROMNAMEANDSIGNATURE_NAME(VAR_19);\n\t\t\tJ9UTF8 *VAR_37 = J9ROMNAMEANDSIGNATURE_SIGNATURE(VAR_19);\n\t\t\tif ((VAR_38 == J9_CP_TYPE(VAR_20, VAR_2))\n\t\t\t|| J9UTF8_LITERAL_EQUALS(J9UTF8_DATA(VAR_31), J9UTF8_LENGTH(VAR_31), \"invokeExact\")\n\t\t\t|| J9UTF8_LITERAL_EQUALS(J9UTF8_DATA(VAR_31), J9UTF8_LENGTH(VAR_31), \"invoke\")\n\t\t\t) {\n\t\t\t\tJ9RAMMethodRef *VAR_39 = (J9RAMMethodRef *)&VAR_1[VAR_2];\n\t\t\t\tUDATA VAR_40 = VAR_39->methodIndexAndArgCount >> 8;\n\t\t\t\tj9object_t VAR_41 = NULL;\n\n\t\t\t\t/* COMMENT_26 */\n                                                                                      \n                            \n       \n\t\t\t\tif (!VAR_12) {\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\t/* COMMENT_30 */\n                                                       \n       \n\t\t\t\tif (VAR_42 == (VAR_39->methodIndexAndArgCount & VAR_42)) {\n\t\t\t\t\tif (VAR_14) {\n\t\t\t\t\t\tsetCurrentExceptionNLS(VAR_0, VAR_43, VAR_44);\n\t\t\t\t\t}\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\t/* COMMENT_33 */\n                                                                               \n       \n\t\t\t\tsendFromMethodDescriptorString(VAR_0, VAR_37, J9_CLASS_FROM_CP(VAR_1)->classLoader, NULL);\n\t\t\t\tVAR_41 = (j9object_t) VAR_0->returnValue;\n\n\t\t\t\t/* COMMENT_36 */\n\t\t\t\tif (threadEventsPending(VAR_0)) {\n\t\t\t\t\t/* COMMENT_37 */\n\t\t\t\t\tVAR_41 = NULL;\n\t\t\t\t} else if (NULL == VAR_41) {\n\t\t\t\t\t/* COMMENT_38 */\n\t\t\t\t\tj9object_t VAR_45 = VAR_9->memoryManagerFunctions->j9gc_createJavaLangString(VAR_0, J9UTF8_DATA(VAR_37), J9UTF8_LENGTH(VAR_37), 0);\n\t\t\t\t\tif (VAR_14) {\n\t\t\t\t\t\tif (NULL == VAR_0->currentException) {\n\t\t\t\t\t\t\tsetCurrentException(VAR_0, VAR_46, (UDATA*)VAR_45);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tVM_VMHelpers::clearException(VAR_0);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* COMMENT_39 */\n\t\t\t\tif (NULL != VAR_41) {\n\t\t\t\t\tJ9Class *VAR_47 = J9_CLASS_FROM_CP(VAR_1);\n\t\t\t\t\tj9object_t *VAR_48 = VAR_47->methodTypes + VAR_40;\n\t\t\t\t\t/* COMMENT_40 */\n\t\t\t\t\tJ9STATIC_OBJECT_STORE(VAR_0, VAR_47, VAR_48, VAR_41);\n\n\t\t\t\t\t/* COMMENT_41 */\n\t\t\t\t\tVAR_6 = VAR_40;\n\t\t\t\t}\n\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t} else if (VAR_8 == J9VMJAVALANGINVOKEVARHANDLE_OR_NULL(VAR_9)) {\n\t\t\tJ9UTF8 *VAR_31 = J9ROMNAMEANDSIGNATURE_NAME(VAR_19);\n\t\t\tJ9UTF8 *VAR_37 = J9ROMNAMEANDSIGNATURE_SIGNATURE(VAR_19);\n\t\t\tU_8* VAR_49 = J9UTF8_DATA(VAR_31);\n\t\t\tU_16 VAR_50 = J9UTF8_LENGTH(VAR_31);\n\t\t\tBOOLEAN VAR_51 = FALSE;\n\n\t\t\tswitch (VAR_50) {\n\t\t\tcase 3:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"get\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"set\")\n\t\t\t\t) {\n\t\t\t\t\tVAR_51 = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"getOpaque\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"setOpaque\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"getAndSet\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"getAndAdd\")\n\t\t\t\t) {\n\t\t\t\t\tVAR_51 = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 10:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"getAcquire\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"setRelease\")\n\t\t\t\t) {\n\t\t\t\t\tVAR_51 = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 11:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"getVolatile\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"setVolatile\")\n\t\t\t\t) {\n\t\t\t\t\tVAR_51 = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 16:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"getAndSetAcquire\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"getAndSetRelease\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"getAndAddAcquire\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"getAndAddRelease\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"getAndBitwiseAnd\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"getAndBitwiseXor\")\n\t\t\t\t) {\n\t\t\t\t\tVAR_51 = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 22:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"getAndBitwiseOrAcquire\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"getAndBitwiseOrRelease\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"weakCompareAndSetPlain\")\n\t\t\t\t) {\n\t\t\t\t\tVAR_51 = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 23:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"getAndBitwiseAndAcquire\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"getAndBitwiseAndRelease\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"getAndBitwiseXorAcquire\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"getAndBitwiseXorRelease\")\n\t\t\t\t) {\n\t\t\t\t\tVAR_51 = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 24:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"weakCompareAndSetAcquire\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"weakCompareAndSetRelease\")\n\t\t\t\t) {\n\t\t\t\t\tVAR_51 = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 25:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"compareAndExchangeAcquire\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"compareAndExchangeRelease\")\n\t\t\t\t) {\n\t\t\t\t\tVAR_51 = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"compareAndSet\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"getAndBitwiseOr\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"weakCompareAndSet\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"compareAndExchange\")\n\t\t\t\t) {\n\t\t\t\t\tVAR_51 = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (VAR_51) {\n\t\t\t\tJ9UTF8 *VAR_52 = (J9UTF8 *)(VAR_23 + sizeof(J9ROMNameAndSignature));\n\t\t\t\tJ9UTF8 *VAR_53 = (J9UTF8 *)(VAR_23 + sizeof(VAR_23) - sizeof(J9UTF8));\n\t\t\t\tmemset(VAR_23, 0, sizeof(VAR_23));\n\n\t\t\t\t/* COMMENT_42 */\n\t\t\t\tVAR_19 = (J9ROMNameAndSignature *)VAR_23;\n\t\t\t\tNNSRP_SET(VAR_19->name, VAR_52);\n\t\t\t\tNNSRP_SET(VAR_19->signature, VAR_53);\n\n\t\t\t\t/* COMMENT_43 */\n\t\t\t\tJ9UTF8_SET_LENGTH(VAR_52, VAR_50 + 5);\n\t\t\t\tmemcpy(J9UTF8_DATA(VAR_52), VAR_49, VAR_50);\n\t\t\t\tmemcpy(J9UTF8_DATA(VAR_52) + VAR_50, \"_impl\", 5);\n\n\t\t\t\t/* COMMENT_17 */\n\t\t\t\tVAR_16 |= VAR_35;\n\n\t\t\t\t/* COMMENT_44 */\n\t\t\t\tVAR_8 = VM_VMHelpers::getSuperclass(VAR_8);\n\n\t\t\t\t/* COMMENT_45 */\n\t\t\t\tVAR_22 = VAR_8;\n\n\t\t\t\t/* COMMENT_46 */\n\t\t\t\tif (VAR_12) {\n\t\t\t\t\tj9object_t VAR_41 = NULL;\n\t\t\t\t\tJ9Class *VAR_54 = VAR_1->ramClass;\n\t\t\t\t\tJ9ROMClass *VAR_55 = VAR_54->romClass;\n\t\t\t\t\tJ9RAMMethodRef *VAR_39 = (J9RAMMethodRef *)&VAR_1[VAR_2];\n\n\t\t\t\t\t/* COMMENT_47 */\n                                                        \n        \n\t\t\t\t\tif (VAR_42 == (VAR_39->methodIndexAndArgCount & VAR_42)) {\n\t\t\t\t\t\tif (VAR_14) {\n\t\t\t\t\t\t\tsetCurrentExceptionNLS(VAR_0, VAR_43, VAR_44);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* COMMENT_50 */\n                                                                                \n       \n                                                                                      \n                                                                                   \n                                                                                 \n                                             \n        \n\t\t\t\t\tsendFromMethodDescriptorString(VAR_0, VAR_37, J9_CLASS_FROM_CP(VAR_1)->classLoader, J9VMJAVALANGINVOKEVARHANDLE_OR_NULL(VAR_9));\n\t\t\t\t\tVAR_41 = (j9object_t)VAR_0->returnValue;\n\n\t\t\t\t\t/* COMMENT_58 */\n\t\t\t\t\tif (threadEventsPending(VAR_0)) {\n\t\t\t\t\t\t/* COMMENT_37 */\n\t\t\t\t\t\tVAR_41 = NULL;\n\t\t\t\t\t} else if (NULL == VAR_41) {\n\t\t\t\t\t\t/* COMMENT_38 */\n\t\t\t\t\t\tj9object_t VAR_45 = VAR_9->memoryManagerFunctions->j9gc_createJavaLangString(VAR_0, J9UTF8_DATA(VAR_37), J9UTF8_LENGTH(VAR_37), 0);\n\t\t\t\t\t\tif (VAR_14) {\n\t\t\t\t\t\t\tif (NULL == VAR_0->currentException) {\n\t\t\t\t\t\t\t\tsetCurrentException(VAR_0, VAR_46, (UDATA*)VAR_45);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tVM_VMHelpers::clearException(VAR_0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/* COMMENT_59 */\n\t\t\t\t\tif (NULL != VAR_41) {\n\t\t\t\t\t\tU_32 VAR_40 = VM_VMHelpers::lookupVarHandleMethodTypeCacheIndex(VAR_55, VAR_2);\n\t\t\t\t\t\tj9object_t *VAR_48 = VAR_54->varHandleMethodTypes + VAR_40;\n\t\t\t\t\t\tJ9STATIC_OBJECT_STORE(VAR_0, VAR_54, VAR_48, VAR_41);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#else /* COMMENT_60 */\n\t\tTrc_VM_Assert_ShouldNeverHappen();\n#endif /* COMMENT_60 */\n\n\t\tVAR_21 = (J9Method *)javaLookupMethod(VAR_0, VAR_8, VAR_19, VAR_22, VAR_16);\n\n\t\tTrc_VM_resolveVirtualMethodRef_lookupMethod(VAR_0, VAR_21);\n\n\t\t/* COMMENT_61 */\n\t\tif (NULL != VAR_21) {\n\t\t\tJ9ROMMethod* VAR_56 = J9_ROM_METHOD_FROM_RAM_METHOD(VAR_21);\n\t\t\t/* COMMENT_62 */\n                                                                 \n      \n\t\t\tif (!J9ROMMETHOD_HAS_VTABLE(VAR_56) && J9_ARE_NO_BITS_SET(VAR_8->romClass->modifiers, VAR_57)) {\n\t\t\t\t/* COMMENT_65 */\n\t\t\t\tif (NULL != VAR_5) {\n\t\t\t\t\tVAR_5->method = VAR_21;\n\t\t\t\t\tUDATA VAR_58 = VAR_59 << 8;\n\t\t\t\t\tVAR_58 |= (VAR_5->methodIndexAndArgCount & 255);\n\t\t\t\t\tVAR_5->methodIndexAndArgCount = VAR_58;\n\t\t\t\t}\n\t\t\t\tif (NULL != VAR_4) {\n\t\t\t\t\t/* COMMENT_66 */\n\t\t\t\t\t*VAR_4 = VAR_21;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* COMMENT_67 */\n\t\t\t\tVAR_6 = getVTableOffsetForMethod(VAR_21, VAR_8, VAR_0);\n\t\t\t\tif (0 == VAR_6) {\n\t\t\t\t\tif (VAR_14) {\n\t\t\t\t\t\tj9object_t VAR_60 = methodToString(VAR_0, VAR_21);\n\t\t\t\t\t\tif (NULL != VAR_60) {\n\t\t\t\t\t\t\tsetCurrentException(VAR_0, VAR_61, (UDATA *)VAR_60);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (VAR_5 != NULL) {\n\t\t\t\t\t\tUDATA VAR_62 = VAR_6 << 8;\n\t\t\t\t\t\tVAR_62 |= (VAR_5->methodIndexAndArgCount & 255);\n\t\t\t\t\t\tVAR_5->methodIndexAndArgCount = VAR_62;\n\t\t\t\t\t}\n\t\t\t\t\tif (NULL != VAR_4) {\n\t\t\t\t\t\t/* COMMENT_66 */\n\t\t\t\t\t\t*VAR_4 = VAR_21;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n#if defined(VAR_36)\ndone:\n#endif /* COMMENT_60 */\n\tTrc_VM_resolveVirtualMethodRef_Exit(VAR_0, VAR_6);\n\treturn VAR_6;\n}",
  "func_graph_path_before": "eclipse-openj9/openj9/840f3af31a5b8d2d395d9367c826ed756e380fb9/resolvesupport.cpp/vul/before/2.json",
  "func": "UDATA   \nresolveVirtualMethodRefInto(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags, J9Method **resolvedMethod, J9RAMVirtualMethodRef *ramCPEntry)\n{\n\tUDATA vTableOffset = 0;\n\tJ9ROMMethodRef *romMethodRef = NULL;\n\tJ9Class *resolvedClass = NULL;\n\tJ9JavaVM *vm = vmStruct->javaVM;\n\tbool jitCompileTimeResolve = J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_JIT_COMPILE_TIME);\n\tbool canRunJavaCode = !jitCompileTimeResolve && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_REDEFINE_CLASS);\n\tbool throwException = canRunJavaCode && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);\n\tUDATA lookupOptions = 0;\n\tif (canRunJavaCode) {\n\t\tif (!throwException) {\n\t\t\tlookupOptions = J9_LOOK_NO_THROW;\t\t\t\n\t\t}\n\t} else {\n\t\tlookupOptions = J9_LOOK_NO_JAVA;\n\t}\n\n\tTrc_VM_resolveVirtualMethodRef_Entry(vmStruct, ramCP, cpIndex, resolveFlags, resolvedMethod);\n\n\tromMethodRef = (J9ROMMethodRef *)&ramCP->romConstantPool[cpIndex];\n\n\tcheckForDecompile(vmStruct, romMethodRef, jitCompileTimeResolve);\n\n\t/* Resolve the class. */\n\tresolvedClass = resolveClassRef(vmStruct, ramCP, romMethodRef->classRefCPIndex, resolveFlags);\n\n\t/* If resolvedClass is NULL, the exception has already been set. */\n\tif (NULL != resolvedClass) {\n\t\tJ9ROMNameAndSignature *nameAndSig = J9ROMFIELDREF_NAMEANDSIGNATURE(romMethodRef);\n\t\tU_32 *cpShapeDescription = NULL;\n\t\tJ9Method *method = NULL;\n\t\tJ9Class *cpClass = NULL;\n\n\t\t/* Stack allocate a byte array for MethodHandle & VarHandle method name and signature. The array size is:\n\t\t *  - J9ROMNameAndSignature\n\t\t *  - Modified method name\n\t\t *      - U_16 for J9UTF8 length\n\t\t *      - 26 bytes for the original method name (\"compareAndExchangeAcquire\" is the longest)\n\t\t *      - 5 bytes for \"_impl\".\n\t\t *  - J9UTF8 for empty signature\n\t\t */\n\t\tU_8 onStackNAS[sizeof(J9ROMNameAndSignature) + (sizeof(U_16) + 26 + 5) + sizeof(J9UTF8)];\n\n\t\tlookupOptions |= J9_LOOK_VIRTUAL;\n\t\tif ((resolveFlags & J9_RESOLVE_FLAG_JCL_CONSTANT_POOL) == J9_RESOLVE_FLAG_JCL_CONSTANT_POOL) {\n\t\t\tcpClass = NULL;\n\t\t} else {\n\t\t\tcpClass = J9_CLASS_FROM_CP(ramCP);\n\t\t\tcpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(cpClass->romClass);\n\t\t\tlookupOptions |= J9_LOOK_CLCONSTRAINTS;\n\t\t}\n\n#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n\t\tJ9UTF8 nullSignature = {0};\n\t\tif ((NULL != cpShapeDescription) && (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(vm))) {\n\t\t\t/**\n\t\t\t * Check for MH intrinsic methods\n\t\t\t *\n\t\t\t * Modify the signature to avoid signature mismatch due to varargs\n\t\t\t * These methods have special INL send targets\n\t\t\t */\n\t\t\tJ9UTF8 *nameUTF = J9ROMNAMEANDSIGNATURE_NAME(nameAndSig);\n\t\t\tU_8* methodName = J9UTF8_DATA(nameUTF);\n\t\t\tU_16 methodNameLength = J9UTF8_LENGTH(nameUTF);\n\n\t\t\tif (isMethodHandleINL(methodName, methodNameLength)) {\n\t\t\t\t/* Create new J9NameAndSignature */\n\t\t\t\t((J9NameAndSignature *)onStackNAS)->name = nameUTF;\n\t\t\t\t((J9NameAndSignature *)onStackNAS)->signature = &nullSignature;\n\t\t\t\tnameAndSig = (J9ROMNameAndSignature *)(&onStackNAS);\n\n\t\t\t\t/* Set flag for partial signature lookup. Signature length is already initialized to 0. */\n\t\t\t\tlookupOptions |= (J9_LOOK_DIRECT_NAS | J9_LOOK_PARTIAL_SIGNATURE);\n\t\t\t}\n\t\t}\n#elif defined(J9VM_OPT_METHOD_HANDLE) /* defined(J9VM_OPT_OPENJDK_METHODHANDLE) */\n\t\tif ((NULL != cpShapeDescription) && (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(vm))) {\n\t\t\t/*\n\t\t\t* Check for MH.invoke and MH.invokeExact.\n\t\t\t*\n\t\t\t* Methodrefs corresponding to those methods already have their methodIndex set to index into\n\t\t\t* cpClass->methodTypes. We resolve them by calling into MethodType.fromMethodDescriptorString()\n\t\t\t* and storing the result into the cpClass->methodTypes table.\n\t\t\t*/\n\t\t\tJ9UTF8 *nameUTF = J9ROMNAMEANDSIGNATURE_NAME(nameAndSig);\n\t\t\tJ9UTF8 *sigUTF = J9ROMNAMEANDSIGNATURE_SIGNATURE(nameAndSig);\n\t\t\tif ((J9CPTYPE_HANDLE_METHOD == J9_CP_TYPE(cpShapeDescription, cpIndex))\n\t\t\t|| J9UTF8_LITERAL_EQUALS(J9UTF8_DATA(nameUTF), J9UTF8_LENGTH(nameUTF), \"invokeExact\")\n\t\t\t|| J9UTF8_LITERAL_EQUALS(J9UTF8_DATA(nameUTF), J9UTF8_LENGTH(nameUTF), \"invoke\")\n\t\t\t) {\n\t\t\t\tJ9RAMMethodRef *ramMethodRef = (J9RAMMethodRef *)&ramCP[cpIndex];\n\t\t\t\tUDATA methodTypeIndex = ramMethodRef->methodIndexAndArgCount >> 8;\n\t\t\t\tj9object_t methodType = NULL;\n\n\t\t\t\t/* Return NULL if not allowed to run java code. The only way to resolve\n\t\t\t\t * a MethodType object is to call-in using MethodType.fromMethodDescriptorString()\n\t\t\t\t * which runs Java code.\n\t\t\t\t */\n\t\t\t\tif (!canRunJavaCode) {\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\t/* Throw LinkageError if more than 255 stack slots are\n\t\t\t\t * required by the MethodType and the MethodHandle.\n\t\t\t\t */\n\t\t\t\tif (MAX_STACK_SLOTS == (ramMethodRef->methodIndexAndArgCount & MAX_STACK_SLOTS)) {\n\t\t\t\t\tif (throwException) {\n\t\t\t\t\t\tsetCurrentExceptionNLS(vmStruct, J9VMCONSTANTPOOL_JAVALANGLINKAGEERROR, J9NLS_VM_TOO_MANY_ARGUMENTS);\n\t\t\t\t\t}\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\t/* Call VM Entry point to create the MethodType - Result is put into the\n\t\t\t\t * vmThread->returnValue as entry points don't \"return\" in the expected way\n\t\t\t\t */\n\t\t\t\tsendFromMethodDescriptorString(vmStruct, sigUTF, J9_CLASS_FROM_CP(ramCP)->classLoader, NULL);\n\t\t\t\tmethodType = (j9object_t) vmStruct->returnValue;\n\n\t\t\t\t/* check if an exception is already pending */\n\t\t\t\tif (threadEventsPending(vmStruct)) {\n\t\t\t\t\t/* Already a pending exception */\n\t\t\t\t\tmethodType = NULL;\n\t\t\t\t} else if (NULL == methodType) {\n\t\t\t\t\t/* Resolved MethodType was null - throw NPE that includes the lookupSignature from the NaS */\n\t\t\t\t\tj9object_t lookupSigString = vm->memoryManagerFunctions->j9gc_createJavaLangString(vmStruct, J9UTF8_DATA(sigUTF), J9UTF8_LENGTH(sigUTF), 0);\n\t\t\t\t\tif (throwException) {\n\t\t\t\t\t\tif (NULL == vmStruct->currentException) {\n\t\t\t\t\t\t\tsetCurrentException(vmStruct, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, (UDATA*)lookupSigString);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tVM_VMHelpers::clearException(vmStruct);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* Only write the value in if its not null */\n\t\t\t\tif (NULL != methodType) {\n\t\t\t\t\tJ9Class *clazz = J9_CLASS_FROM_CP(ramCP);\n\t\t\t\t\tj9object_t *methodTypeObjectP = clazz->methodTypes + methodTypeIndex;\n\t\t\t\t\t/* Overwriting NULL with an immortal pointer, so no exception can occur */\n\t\t\t\t\tJ9STATIC_OBJECT_STORE(vmStruct, clazz, methodTypeObjectP, methodType);\n\n\t\t\t\t\t/* Record vTableOffset for the exit tracepoint. */\n\t\t\t\t\tvTableOffset = methodTypeIndex;\n\t\t\t\t}\n\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t} else if (resolvedClass == J9VMJAVALANGINVOKEVARHANDLE_OR_NULL(vm)) {\n\t\t\tJ9UTF8 *nameUTF = J9ROMNAMEANDSIGNATURE_NAME(nameAndSig);\n\t\t\tJ9UTF8 *sigUTF = J9ROMNAMEANDSIGNATURE_SIGNATURE(nameAndSig);\n\t\t\tU_8* initialMethodName = J9UTF8_DATA(nameUTF);\n\t\t\tU_16 initialMethodNameLength = J9UTF8_LENGTH(nameUTF);\n\t\t\tBOOLEAN isVarHandle = FALSE;\n\n\t\t\tswitch (initialMethodNameLength) {\n\t\t\tcase 3:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"get\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"set\")\n\t\t\t\t) {\n\t\t\t\t\tisVarHandle = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getOpaque\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"setOpaque\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndSet\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndAdd\")\n\t\t\t\t) {\n\t\t\t\t\tisVarHandle = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 10:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAcquire\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"setRelease\")\n\t\t\t\t) {\n\t\t\t\t\tisVarHandle = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 11:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getVolatile\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"setVolatile\")\n\t\t\t\t) {\n\t\t\t\t\tisVarHandle = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 16:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndSetAcquire\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndSetRelease\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndAddAcquire\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndAddRelease\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndBitwiseAnd\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndBitwiseXor\")\n\t\t\t\t) {\n\t\t\t\t\tisVarHandle = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 22:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndBitwiseOrAcquire\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndBitwiseOrRelease\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"weakCompareAndSetPlain\")\n\t\t\t\t) {\n\t\t\t\t\tisVarHandle = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 23:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndBitwiseAndAcquire\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndBitwiseAndRelease\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndBitwiseXorAcquire\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndBitwiseXorRelease\")\n\t\t\t\t) {\n\t\t\t\t\tisVarHandle = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 24:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"weakCompareAndSetAcquire\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"weakCompareAndSetRelease\")\n\t\t\t\t) {\n\t\t\t\t\tisVarHandle = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 25:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"compareAndExchangeAcquire\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"compareAndExchangeRelease\")\n\t\t\t\t) {\n\t\t\t\t\tisVarHandle = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"compareAndSet\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndBitwiseOr\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"weakCompareAndSet\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"compareAndExchange\")\n\t\t\t\t) {\n\t\t\t\t\tisVarHandle = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (isVarHandle) {\n\t\t\t\tJ9UTF8 *modifiedMethodName = (J9UTF8 *)(onStackNAS + sizeof(J9ROMNameAndSignature));\n\t\t\t\tJ9UTF8 *modifiedMethodSig = (J9UTF8 *)(onStackNAS + sizeof(onStackNAS) - sizeof(J9UTF8));\n\t\t\t\tmemset(onStackNAS, 0, sizeof(onStackNAS));\n\n\t\t\t\t/* Create new J9ROMNameAndSignature */\n\t\t\t\tnameAndSig = (J9ROMNameAndSignature *)onStackNAS;\n\t\t\t\tNNSRP_SET(nameAndSig->name, modifiedMethodName);\n\t\t\t\tNNSRP_SET(nameAndSig->signature, modifiedMethodSig);\n\n\t\t\t\t/* Change method name to include the suffix \"_impl\", which are the methods with VarHandle send targets. */\n\t\t\t\tJ9UTF8_SET_LENGTH(modifiedMethodName, initialMethodNameLength + 5);\n\t\t\t\tmemcpy(J9UTF8_DATA(modifiedMethodName), initialMethodName, initialMethodNameLength);\n\t\t\t\tmemcpy(J9UTF8_DATA(modifiedMethodName) + initialMethodNameLength, \"_impl\", 5);\n\n\t\t\t\t/* Set flag for partial signature lookup. Signature length is already initialized to 0. */\n\t\t\t\tlookupOptions |= J9_LOOK_PARTIAL_SIGNATURE;\n\n\t\t\t\t/* Redirect resolution to VarHandleInternal */\n\t\t\t\tresolvedClass = VM_VMHelpers::getSuperclass(resolvedClass);\n\n\t\t\t\t/* Ensure visibility passes */\n\t\t\t\tcpClass = resolvedClass;\n\n\t\t\t\t/* Resolve the MethodType. */\n\t\t\t\tif (canRunJavaCode) {\n\t\t\t\t\tj9object_t methodType = NULL;\n\t\t\t\t\tJ9Class *ramClass = ramCP->ramClass;\n\t\t\t\t\tJ9ROMClass *romClass = ramClass->romClass;\n\t\t\t\t\tJ9RAMMethodRef *ramMethodRef = (J9RAMMethodRef *)&ramCP[cpIndex];\n\n\t\t\t\t\t/* Throw LinkageError if more than 255 stack slots are\n\t\t\t\t\t * required by the MethodType and the MethodHandle.\n\t\t\t\t\t */\n\t\t\t\t\tif (MAX_STACK_SLOTS == (ramMethodRef->methodIndexAndArgCount & MAX_STACK_SLOTS)) {\n\t\t\t\t\t\tif (throwException) {\n\t\t\t\t\t\t\tsetCurrentExceptionNLS(vmStruct, J9VMCONSTANTPOOL_JAVALANGLINKAGEERROR, J9NLS_VM_TOO_MANY_ARGUMENTS);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Call VM Entry point to create the MethodType - Result is put into the\n\t\t\t\t\t * vmThread->returnValue as entry points don't \"return\" in the expected way\n\t\t\t\t\t *\n\t\t\t\t\t * NB! An extra VarHandle argument is appended to the MethodType's argument list,\n\t\t\t\t\t * so the returned MethodType doesn't represent the provided method signature.\n\t\t\t\t\t * E.g. the MethodType for \"(I)I\" will have the following descriptor string:\n\t\t\t\t\t *     \"(Ijava/lang/invoke/VarHandle;)I\"\n\t\t\t\t\t */\n\t\t\t\t\tsendFromMethodDescriptorString(vmStruct, sigUTF, J9_CLASS_FROM_CP(ramCP)->classLoader, J9VMJAVALANGINVOKEVARHANDLE_OR_NULL(vm));\n\t\t\t\t\tmethodType = (j9object_t)vmStruct->returnValue;\n\n\t\t\t\t\t/* Check if an exception is already pending */\n\t\t\t\t\tif (threadEventsPending(vmStruct)) {\n\t\t\t\t\t\t/* Already a pending exception */\n\t\t\t\t\t\tmethodType = NULL;\n\t\t\t\t\t} else if (NULL == methodType) {\n\t\t\t\t\t\t/* Resolved MethodType was null - throw NPE that includes the lookupSignature from the NaS */\n\t\t\t\t\t\tj9object_t lookupSigString = vm->memoryManagerFunctions->j9gc_createJavaLangString(vmStruct, J9UTF8_DATA(sigUTF), J9UTF8_LENGTH(sigUTF), 0);\n\t\t\t\t\t\tif (throwException) {\n\t\t\t\t\t\t\tif (NULL == vmStruct->currentException) {\n\t\t\t\t\t\t\t\tsetCurrentException(vmStruct, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, (UDATA*)lookupSigString);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tVM_VMHelpers::clearException(vmStruct);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Store MethodType in cache */\n\t\t\t\t\tif (NULL != methodType) {\n\t\t\t\t\t\tU_32 methodTypeIndex = VM_VMHelpers::lookupVarHandleMethodTypeCacheIndex(romClass, cpIndex);\n\t\t\t\t\t\tj9object_t *methodTypeObjectP = ramClass->varHandleMethodTypes + methodTypeIndex;\n\t\t\t\t\t\tJ9STATIC_OBJECT_STORE(vmStruct, ramClass, methodTypeObjectP, methodType);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#else /* defined(J9VM_OPT_METHOD_HANDLE) */\n\t\tTrc_VM_Assert_ShouldNeverHappen();\n#endif /* defined(J9VM_OPT_METHOD_HANDLE) */\n\n\t\tmethod = (J9Method *)javaLookupMethod(vmStruct, resolvedClass, nameAndSig, cpClass, lookupOptions);\n\n\t\tTrc_VM_resolveVirtualMethodRef_lookupMethod(vmStruct, method);\n\n\t\t/* If method is NULL, the exception has already been set. */\n\t\tif (NULL != method) {\n\t\t\tJ9ROMMethod* romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(method);\n\t\t\t/* Only allow non-interface method to call invokePrivate, private interface method should use \"invokeInterface\" bytecode\n\t\t\t * The else case will throw ICCE for private interface method \n\t\t\t */\n\t\t\tif (!J9ROMMETHOD_HAS_VTABLE(romMethod) && J9_ARE_NO_BITS_SET(resolvedClass->romClass->modifiers, J9AccInterface)) {\n\t\t\t\t/* Private method found, will not be in vTable, point vTable index to invokePrivate */\n\t\t\t\tif (NULL != ramCPEntry) {\n\t\t\t\t\tramCPEntry->method = method;\n\t\t\t\t\tUDATA methodIndexAndArgCount = J9VTABLE_INVOKE_PRIVATE_OFFSET << 8;\n\t\t\t\t\tmethodIndexAndArgCount |= (ramCPEntry->methodIndexAndArgCount & 255);\n\t\t\t\t\tramCPEntry->methodIndexAndArgCount = methodIndexAndArgCount;\n\t\t\t\t}\n\t\t\t\tif (NULL != resolvedMethod) {\n\t\t\t\t\t/* save away method for callee */\n\t\t\t\t\t*resolvedMethod = method;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* Fill in the constant pool entry. Don't bother checking for failure on the vtable index, since we know the method is there. */\n\t\t\t\tvTableOffset = getVTableOffsetForMethod(method, resolvedClass, vmStruct);\n\t\t\t\tif (0 == vTableOffset) {\n\t\t\t\t\tif (throwException) {\n\t\t\t\t\t\tj9object_t errorString = methodToString(vmStruct, method);\n\t\t\t\t\t\tif (NULL != errorString) {\n\t\t\t\t\t\t\tsetCurrentException(vmStruct, J9VMCONSTANTPOOL_JAVALANGINCOMPATIBLECLASSCHANGEERROR, (UDATA *)errorString);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ((NULL != ramCPEntry) && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\n\t\t\t\t\t\tUDATA argSlotCount = vTableOffset << 8;\n\t\t\t\t\t\targSlotCount |= (ramCPEntry->methodIndexAndArgCount & 255);\n\t\t\t\t\t\tramCPEntry->methodIndexAndArgCount = argSlotCount;\n\t\t\t\t\t}\n\t\t\t\t\tif (NULL != resolvedMethod) {\n\t\t\t\t\t\t/* save away method for callee */\n\t\t\t\t\t\t*resolvedMethod = method;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n#if defined(J9VM_OPT_METHOD_HANDLE)\ndone:\n#endif /* defined(J9VM_OPT_METHOD_HANDLE) */\n\tTrc_VM_resolveVirtualMethodRef_Exit(vmStruct, vTableOffset);\n\treturn vTableOffset;\n}",
  "abstract_func": "UDATA   \nresolveVirtualMethodRefInto(J9VMThread *VAR_0, J9ConstantPool *VAR_1, UDATA VAR_2, UDATA VAR_3, J9Method **VAR_4, J9RAMVirtualMethodRef *VAR_5)\n{\n\tUDATA VAR_6 = 0;\n\tJ9ROMMethodRef *VAR_7 = NULL;\n\tJ9Class *VAR_8 = NULL;\n\tJ9JavaVM *VAR_9 = VAR_0->javaVM;\n\tbool VAR_10 = J9_ARE_ANY_BITS_SET(VAR_3, VAR_11);\n\tbool VAR_12 = !VAR_10 && J9_ARE_NO_BITS_SET(VAR_3, VAR_13);\n\tbool VAR_14 = VAR_12 && J9_ARE_NO_BITS_SET(VAR_3, VAR_15);\n\tUDATA VAR_16 = 0;\n\tif (VAR_12) {\n\t\tif (!VAR_14) {\n\t\t\tVAR_16 = VAR_17;\t\t\t\n\t\t}\n\t} else {\n\t\tVAR_16 = VAR_18;\n\t}\n\n\tTrc_VM_resolveVirtualMethodRef_Entry(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4);\n\n\tVAR_7 = (J9ROMMethodRef *)&VAR_1->romConstantPool[VAR_2];\n\n\tcheckForDecompile(VAR_0, VAR_7, VAR_10);\n\n\t/* COMMENT_0 */\n\tVAR_8 = resolveClassRef(VAR_0, VAR_1, VAR_7->classRefCPIndex, VAR_3);\n\n\t/* COMMENT_1 */\n\tif (NULL != VAR_8) {\n\t\tJ9ROMNameAndSignature *VAR_19 = J9ROMFIELDREF_NAMEANDSIGNATURE(VAR_7);\n\t\tU_32 *VAR_20 = NULL;\n\t\tJ9Method *VAR_21 = NULL;\n\t\tJ9Class *VAR_22 = NULL;\n\n\t\t/* COMMENT_2 */\n                             \n                            \n                                  \n                                                                                              \n                                \n                                  \n     \n\t\tU_8 VAR_23[sizeof(J9ROMNameAndSignature) + (sizeof(VAR_24) + 26 + 5) + sizeof(VAR_25)];\n\n\t\tVAR_16 |= VAR_26;\n\t\tif ((VAR_3 & VAR_27) == VAR_27) {\n\t\t\tVAR_22 = NULL;\n\t\t} else {\n\t\t\tVAR_22 = J9_CLASS_FROM_CP(VAR_1);\n\t\t\tVAR_20 = J9ROMCLASS_CPSHAPEDESCRIPTION(VAR_22->romClass);\n\t\t\tVAR_16 |= VAR_28;\n\t\t}\n\n#if defined(VAR_29)\n\t\tJ9UTF8 VAR_30 = {0};\n\t\tif ((NULL != VAR_20) && (VAR_8 == J9VMJAVALANGINVOKEMETHODHANDLE(VAR_9))) {\n\t\t\t/* COMMENT_10 */\n                                    \n     \n                                                                     \n                                                 \n      \n\t\t\tJ9UTF8 *VAR_31 = J9ROMNAMEANDSIGNATURE_NAME(VAR_19);\n\t\t\tU_8* VAR_32 = J9UTF8_DATA(VAR_31);\n\t\t\tU_16 VAR_33 = J9UTF8_LENGTH(VAR_31);\n\n\t\t\tif (isMethodHandleINL(VAR_32, VAR_33)) {\n\t\t\t\t/* COMMENT_16 */\n\t\t\t\t((J9NameAndSignature *)VAR_23)->name = VAR_31;\n\t\t\t\t((J9NameAndSignature *)VAR_23)->signature = &VAR_30;\n\t\t\t\tVAR_19 = (J9ROMNameAndSignature *)(&VAR_23);\n\n\t\t\t\t/* COMMENT_17 */\n\t\t\t\tVAR_16 |= (VAR_34 | VAR_35);\n\t\t\t}\n\t\t}\n#elif defined(VAR_36) /* COMMENT_18 */\n\t\tif ((NULL != VAR_20) && (VAR_8 == J9VMJAVALANGINVOKEMETHODHANDLE(VAR_9))) {\n\t\t\t/* COMMENT_19 */\n                                            \n    \n                                                                                               \n                                                                                                  \n                                                                \n     \n\t\t\tJ9UTF8 *VAR_31 = J9ROMNAMEANDSIGNATURE_NAME(VAR_19);\n\t\t\tJ9UTF8 *VAR_37 = J9ROMNAMEANDSIGNATURE_SIGNATURE(VAR_19);\n\t\t\tif ((VAR_38 == J9_CP_TYPE(VAR_20, VAR_2))\n\t\t\t|| J9UTF8_LITERAL_EQUALS(J9UTF8_DATA(VAR_31), J9UTF8_LENGTH(VAR_31), \"invokeExact\")\n\t\t\t|| J9UTF8_LITERAL_EQUALS(J9UTF8_DATA(VAR_31), J9UTF8_LENGTH(VAR_31), \"invoke\")\n\t\t\t) {\n\t\t\t\tJ9RAMMethodRef *VAR_39 = (J9RAMMethodRef *)&VAR_1[VAR_2];\n\t\t\t\tUDATA VAR_40 = VAR_39->methodIndexAndArgCount >> 8;\n\t\t\t\tj9object_t VAR_41 = NULL;\n\n\t\t\t\t/* COMMENT_26 */\n                                                                                      \n                            \n       \n\t\t\t\tif (!VAR_12) {\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\t/* COMMENT_30 */\n                                                       \n       \n\t\t\t\tif (VAR_42 == (VAR_39->methodIndexAndArgCount & VAR_42)) {\n\t\t\t\t\tif (VAR_14) {\n\t\t\t\t\t\tsetCurrentExceptionNLS(VAR_0, VAR_43, VAR_44);\n\t\t\t\t\t}\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\t/* COMMENT_33 */\n                                                                               \n       \n\t\t\t\tsendFromMethodDescriptorString(VAR_0, VAR_37, J9_CLASS_FROM_CP(VAR_1)->classLoader, NULL);\n\t\t\t\tVAR_41 = (j9object_t) VAR_0->returnValue;\n\n\t\t\t\t/* COMMENT_36 */\n\t\t\t\tif (threadEventsPending(VAR_0)) {\n\t\t\t\t\t/* COMMENT_37 */\n\t\t\t\t\tVAR_41 = NULL;\n\t\t\t\t} else if (NULL == VAR_41) {\n\t\t\t\t\t/* COMMENT_38 */\n\t\t\t\t\tj9object_t VAR_45 = VAR_9->memoryManagerFunctions->j9gc_createJavaLangString(VAR_0, J9UTF8_DATA(VAR_37), J9UTF8_LENGTH(VAR_37), 0);\n\t\t\t\t\tif (VAR_14) {\n\t\t\t\t\t\tif (NULL == VAR_0->currentException) {\n\t\t\t\t\t\t\tsetCurrentException(VAR_0, VAR_46, (UDATA*)VAR_45);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tVM_VMHelpers::clearException(VAR_0);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* COMMENT_39 */\n\t\t\t\tif (NULL != VAR_41) {\n\t\t\t\t\tJ9Class *VAR_47 = J9_CLASS_FROM_CP(VAR_1);\n\t\t\t\t\tj9object_t *VAR_48 = VAR_47->methodTypes + VAR_40;\n\t\t\t\t\t/* COMMENT_40 */\n\t\t\t\t\tJ9STATIC_OBJECT_STORE(VAR_0, VAR_47, VAR_48, VAR_41);\n\n\t\t\t\t\t/* COMMENT_41 */\n\t\t\t\t\tVAR_6 = VAR_40;\n\t\t\t\t}\n\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t} else if (VAR_8 == J9VMJAVALANGINVOKEVARHANDLE_OR_NULL(VAR_9)) {\n\t\t\tJ9UTF8 *VAR_31 = J9ROMNAMEANDSIGNATURE_NAME(VAR_19);\n\t\t\tJ9UTF8 *VAR_37 = J9ROMNAMEANDSIGNATURE_SIGNATURE(VAR_19);\n\t\t\tU_8* VAR_49 = J9UTF8_DATA(VAR_31);\n\t\t\tU_16 VAR_50 = J9UTF8_LENGTH(VAR_31);\n\t\t\tBOOLEAN VAR_51 = FALSE;\n\n\t\t\tswitch (VAR_50) {\n\t\t\tcase 3:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"get\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"set\")\n\t\t\t\t) {\n\t\t\t\t\tVAR_51 = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"getOpaque\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"setOpaque\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"getAndSet\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"getAndAdd\")\n\t\t\t\t) {\n\t\t\t\t\tVAR_51 = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 10:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"getAcquire\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"setRelease\")\n\t\t\t\t) {\n\t\t\t\t\tVAR_51 = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 11:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"getVolatile\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"setVolatile\")\n\t\t\t\t) {\n\t\t\t\t\tVAR_51 = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 16:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"getAndSetAcquire\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"getAndSetRelease\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"getAndAddAcquire\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"getAndAddRelease\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"getAndBitwiseAnd\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"getAndBitwiseXor\")\n\t\t\t\t) {\n\t\t\t\t\tVAR_51 = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 22:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"getAndBitwiseOrAcquire\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"getAndBitwiseOrRelease\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"weakCompareAndSetPlain\")\n\t\t\t\t) {\n\t\t\t\t\tVAR_51 = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 23:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"getAndBitwiseAndAcquire\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"getAndBitwiseAndRelease\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"getAndBitwiseXorAcquire\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"getAndBitwiseXorRelease\")\n\t\t\t\t) {\n\t\t\t\t\tVAR_51 = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 24:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"weakCompareAndSetAcquire\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"weakCompareAndSetRelease\")\n\t\t\t\t) {\n\t\t\t\t\tVAR_51 = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 25:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"compareAndExchangeAcquire\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"compareAndExchangeRelease\")\n\t\t\t\t) {\n\t\t\t\t\tVAR_51 = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"compareAndSet\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"getAndBitwiseOr\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"weakCompareAndSet\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(VAR_49, VAR_50, \"compareAndExchange\")\n\t\t\t\t) {\n\t\t\t\t\tVAR_51 = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (VAR_51) {\n\t\t\t\tJ9UTF8 *VAR_52 = (J9UTF8 *)(VAR_23 + sizeof(J9ROMNameAndSignature));\n\t\t\t\tJ9UTF8 *VAR_53 = (J9UTF8 *)(VAR_23 + sizeof(VAR_23) - sizeof(J9UTF8));\n\t\t\t\tmemset(VAR_23, 0, sizeof(VAR_23));\n\n\t\t\t\t/* COMMENT_42 */\n\t\t\t\tVAR_19 = (J9ROMNameAndSignature *)VAR_23;\n\t\t\t\tNNSRP_SET(VAR_19->name, VAR_52);\n\t\t\t\tNNSRP_SET(VAR_19->signature, VAR_53);\n\n\t\t\t\t/* COMMENT_43 */\n\t\t\t\tJ9UTF8_SET_LENGTH(VAR_52, VAR_50 + 5);\n\t\t\t\tmemcpy(J9UTF8_DATA(VAR_52), VAR_49, VAR_50);\n\t\t\t\tmemcpy(J9UTF8_DATA(VAR_52) + VAR_50, \"_impl\", 5);\n\n\t\t\t\t/* COMMENT_17 */\n\t\t\t\tVAR_16 |= VAR_35;\n\n\t\t\t\t/* COMMENT_44 */\n\t\t\t\tVAR_8 = VM_VMHelpers::getSuperclass(VAR_8);\n\n\t\t\t\t/* COMMENT_45 */\n\t\t\t\tVAR_22 = VAR_8;\n\n\t\t\t\t/* COMMENT_46 */\n\t\t\t\tif (VAR_12) {\n\t\t\t\t\tj9object_t VAR_41 = NULL;\n\t\t\t\t\tJ9Class *VAR_54 = VAR_1->ramClass;\n\t\t\t\t\tJ9ROMClass *VAR_55 = VAR_54->romClass;\n\t\t\t\t\tJ9RAMMethodRef *VAR_39 = (J9RAMMethodRef *)&VAR_1[VAR_2];\n\n\t\t\t\t\t/* COMMENT_47 */\n                                                        \n        \n\t\t\t\t\tif (VAR_42 == (VAR_39->methodIndexAndArgCount & VAR_42)) {\n\t\t\t\t\t\tif (VAR_14) {\n\t\t\t\t\t\t\tsetCurrentExceptionNLS(VAR_0, VAR_43, VAR_44);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* COMMENT_50 */\n                                                                                \n       \n                                                                                      \n                                                                                   \n                                                                                 \n                                             \n        \n\t\t\t\t\tsendFromMethodDescriptorString(VAR_0, VAR_37, J9_CLASS_FROM_CP(VAR_1)->classLoader, J9VMJAVALANGINVOKEVARHANDLE_OR_NULL(VAR_9));\n\t\t\t\t\tVAR_41 = (j9object_t)VAR_0->returnValue;\n\n\t\t\t\t\t/* COMMENT_58 */\n\t\t\t\t\tif (threadEventsPending(VAR_0)) {\n\t\t\t\t\t\t/* COMMENT_37 */\n\t\t\t\t\t\tVAR_41 = NULL;\n\t\t\t\t\t} else if (NULL == VAR_41) {\n\t\t\t\t\t\t/* COMMENT_38 */\n\t\t\t\t\t\tj9object_t VAR_45 = VAR_9->memoryManagerFunctions->j9gc_createJavaLangString(VAR_0, J9UTF8_DATA(VAR_37), J9UTF8_LENGTH(VAR_37), 0);\n\t\t\t\t\t\tif (VAR_14) {\n\t\t\t\t\t\t\tif (NULL == VAR_0->currentException) {\n\t\t\t\t\t\t\t\tsetCurrentException(VAR_0, VAR_46, (UDATA*)VAR_45);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tVM_VMHelpers::clearException(VAR_0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/* COMMENT_59 */\n\t\t\t\t\tif (NULL != VAR_41) {\n\t\t\t\t\t\tU_32 VAR_40 = VM_VMHelpers::lookupVarHandleMethodTypeCacheIndex(VAR_55, VAR_2);\n\t\t\t\t\t\tj9object_t *VAR_48 = VAR_54->varHandleMethodTypes + VAR_40;\n\t\t\t\t\t\tJ9STATIC_OBJECT_STORE(VAR_0, VAR_54, VAR_48, VAR_41);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#else /* COMMENT_60 */\n\t\tTrc_VM_Assert_ShouldNeverHappen();\n#endif /* COMMENT_60 */\n\n\t\tVAR_21 = (J9Method *)javaLookupMethod(VAR_0, VAR_8, VAR_19, VAR_22, VAR_16);\n\n\t\tTrc_VM_resolveVirtualMethodRef_lookupMethod(VAR_0, VAR_21);\n\n\t\t/* COMMENT_61 */\n\t\tif (NULL != VAR_21) {\n\t\t\tJ9ROMMethod* VAR_56 = J9_ROM_METHOD_FROM_RAM_METHOD(VAR_21);\n\t\t\t/* COMMENT_62 */\n                                                                 \n      \n\t\t\tif (!J9ROMMETHOD_HAS_VTABLE(VAR_56) && J9_ARE_NO_BITS_SET(VAR_8->romClass->modifiers, VAR_57)) {\n\t\t\t\t/* COMMENT_65 */\n\t\t\t\tif (NULL != VAR_5) {\n\t\t\t\t\tVAR_5->method = VAR_21;\n\t\t\t\t\tUDATA VAR_58 = VAR_59 << 8;\n\t\t\t\t\tVAR_58 |= (VAR_5->methodIndexAndArgCount & 255);\n\t\t\t\t\tVAR_5->methodIndexAndArgCount = VAR_58;\n\t\t\t\t}\n\t\t\t\tif (NULL != VAR_4) {\n\t\t\t\t\t/* COMMENT_66 */\n\t\t\t\t\t*VAR_4 = VAR_21;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* COMMENT_67 */\n\t\t\t\tVAR_6 = getVTableOffsetForMethod(VAR_21, VAR_8, VAR_0);\n\t\t\t\tif (0 == VAR_6) {\n\t\t\t\t\tif (VAR_14) {\n\t\t\t\t\t\tj9object_t VAR_60 = methodToString(VAR_0, VAR_21);\n\t\t\t\t\t\tif (NULL != VAR_60) {\n\t\t\t\t\t\t\tsetCurrentException(VAR_0, VAR_61, (UDATA *)VAR_60);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ((NULL != VAR_5) && J9_ARE_NO_BITS_SET(VAR_3, VAR_62)) {\n\t\t\t\t\t\tUDATA VAR_63 = VAR_6 << 8;\n\t\t\t\t\t\tVAR_63 |= (VAR_5->methodIndexAndArgCount & 255);\n\t\t\t\t\t\tVAR_5->methodIndexAndArgCount = VAR_63;\n\t\t\t\t\t}\n\t\t\t\t\tif (NULL != VAR_4) {\n\t\t\t\t\t\t/* COMMENT_66 */\n\t\t\t\t\t\t*VAR_4 = VAR_21;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n#if defined(VAR_36)\ndone:\n#endif /* COMMENT_60 */\n\tTrc_VM_resolveVirtualMethodRef_Exit(VAR_0, VAR_6);\n\treturn VAR_6;\n}",
  "func_graph_path": "eclipse-openj9/openj9/840f3af31a5b8d2d395d9367c826ed756e380fb9/resolvesupport.cpp/vul/after/2.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -352,7 +352,7 @@\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t} else {\n-\t\t\t\t\tif (ramCPEntry != NULL) {\n+\t\t\t\t\tif ((NULL != ramCPEntry) && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\n \t\t\t\t\t\tUDATA argSlotCount = vTableOffset << 8;\n \t\t\t\t\t\targSlotCount |= (ramCPEntry->methodIndexAndArgCount & 255);\n \t\t\t\t\t\tramCPEntry->methodIndexAndArgCount = argSlotCount;",
  "diff_line_info": {
    "deleted_lines": [
      "\t\t\t\t\tif (ramCPEntry != NULL) {"
    ],
    "added_lines": [
      "\t\t\t\t\tif ((NULL != ramCPEntry) && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/eclipse-openj9/openj9/pull/12148",
  "description": {
    "pr_info": {
      "title": "Correctly load/initialize classes when using ConstantPool",
      "number": 12148
    },
    "comment": [
      "- do not load classes in the \"ifLoaded\" calls\r\n- never intitialize classes in the natives\r\n- do not update the constant pool when querying from the natives\r\n\r\nFixes: #12016\r\n\r\n[ci skip]\r\n\r\nSigned-off-by: Graham Chapman <graham_chapman@ca.ibm.com>",
      "jenkins test sanity,extended zlinux jdk11",
      "jenkins compile win jdk8",
      "@gacholio can you please open another PR for the 0.26 stream",
      "https://github.com/eclipse/openj9/pull/12164"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.9"
}