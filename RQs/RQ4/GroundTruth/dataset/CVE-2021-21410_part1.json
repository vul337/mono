{
  "cve_id": "CVE-2021-21410",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "contiki-ng",
  "commit_msg": "Add buffer space checks for packet decompression.",
  "commit_hash": "668f244058644c79752ef8a0d24d45721b510021",
  "git_url": "https://github.com/contiki-ng/contiki-ng/commit/668f244058644c79752ef8a0d24d45721b510021",
  "file_path": "os/net/ipv6/sicslowpan.c",
  "func_name": "uncompress_hdr_iphc",
  "func_before": "static bool\nuncompress_hdr_iphc(uint8_t *buf, uint16_t buf_size, uint16_t ip_len)\n{\n  uint8_t tmp, iphc0, iphc1, nhc;\n  struct uip_ext_hdr *exthdr;\n  uint8_t* last_nextheader;\n  uint8_t* ip_payload;\n  uint8_t ext_hdr_len = 0;\n\n  /* at least two byte will be used for the encoding */\n  hc06_ptr = packetbuf_ptr + packetbuf_hdr_len + 2;\n\n  iphc0 = PACKETBUF_IPHC_BUF[0];\n  iphc1 = PACKETBUF_IPHC_BUF[1];\n\n  /* another if the CID flag is set */\n  if(iphc1 & SICSLOWPAN_IPHC_CID) {\n    LOG_DBG(\"uncompression: CID flag set - increase header with one\\n\");\n    hc06_ptr++;\n  }\n\n  /* Traffic class and flow label */\n    if((iphc0 & SICSLOWPAN_IPHC_FL_C) == 0) {\n      /* Flow label are carried inline */\n      if((iphc0 & SICSLOWPAN_IPHC_TC_C) == 0) {\n        /* Traffic class is carried inline */\n        memcpy(&SICSLOWPAN_IP_BUF(buf)->tcflow, hc06_ptr + 1, 3);\n        tmp = *hc06_ptr;\n        hc06_ptr += 4;\n        /* IPHC format of tc is ECN | DSCP , original is DSCP | ECN */\n        /* set version, pick highest DSCP bits and set in vtc */\n        SICSLOWPAN_IP_BUF(buf)->vtc = 0x60 | ((tmp >> 2) & 0x0f);\n        /* ECN rolled down two steps + lowest DSCP bits at top two bits */\n        SICSLOWPAN_IP_BUF(buf)->tcflow = ((tmp >> 2) & 0x30) | (tmp << 6) |\n          (SICSLOWPAN_IP_BUF(buf)->tcflow & 0x0f);\n      } else {\n        /* Traffic class is compressed (set version and no TC)*/\n        SICSLOWPAN_IP_BUF(buf)->vtc = 0x60;\n        /* highest flow label bits + ECN bits */\n        SICSLOWPAN_IP_BUF(buf)->tcflow = (*hc06_ptr & 0x0F) |\n          ((*hc06_ptr >> 2) & 0x30);\n        memcpy(&SICSLOWPAN_IP_BUF(buf)->flow, hc06_ptr + 1, 2);\n        hc06_ptr += 3;\n      }\n    } else {\n      /* Version is always 6! */\n      /* Version and flow label are compressed */\n      if((iphc0 & SICSLOWPAN_IPHC_TC_C) == 0) {\n        /* Traffic class is inline */\n        SICSLOWPAN_IP_BUF(buf)->vtc = 0x60 | ((*hc06_ptr >> 2) & 0x0f);\n          SICSLOWPAN_IP_BUF(buf)->tcflow = ((*hc06_ptr << 6) & 0xC0) | ((*hc06_ptr >> 2) & 0x30);\n          SICSLOWPAN_IP_BUF(buf)->flow = 0;\n          hc06_ptr += 1;\n      } else {\n        /* Traffic class is compressed */\n        SICSLOWPAN_IP_BUF(buf)->vtc = 0x60;\n        SICSLOWPAN_IP_BUF(buf)->tcflow = 0;\n        SICSLOWPAN_IP_BUF(buf)->flow = 0;\n      }\n    }\n\n  /* Next Header */\n  if((iphc0 & SICSLOWPAN_IPHC_NH_C) == 0) {\n    /* Next header is carried inline */\n    SICSLOWPAN_IP_BUF(buf)->proto = *hc06_ptr;\n    LOG_DBG(\"uncompression: next header inline: %d\\n\", SICSLOWPAN_IP_BUF(buf)->proto);\n    hc06_ptr += 1;\n  }\n\n  /* Hop limit */\n  if((iphc0 & 0x03) != SICSLOWPAN_IPHC_TTL_I) {\n    SICSLOWPAN_IP_BUF(buf)->ttl = ttl_values[iphc0 & 0x03];\n  } else {\n    SICSLOWPAN_IP_BUF(buf)->ttl = *hc06_ptr;\n    hc06_ptr += 1;\n  }\n\n  /* put the source address compression mode SAM in the tmp var */\n  tmp = ((iphc1 & SICSLOWPAN_IPHC_SAM_11) >> SICSLOWPAN_IPHC_SAM_BIT) & 0x03;\n\n  /* context based compression */\n  if(iphc1 & SICSLOWPAN_IPHC_SAC) {\n    uint8_t sci = (iphc1 & SICSLOWPAN_IPHC_CID) ?\n      PACKETBUF_IPHC_BUF[2] >> 4 : 0;\n\n    /* Source address - check context != NULL only if SAM bits are != 0*/\n    if (tmp != 0) {\n      context = addr_context_lookup_by_number(sci);\n      if(context == NULL) {\n        LOG_ERR(\"uncompression: error context not found\\n\");\n        return false;\n      }\n    }\n    /* if tmp == 0 we do not have a context and therefore no prefix */\n    uncompress_addr(&SICSLOWPAN_IP_BUF(buf)->srcipaddr,\n                    tmp != 0 ? context->prefix : NULL, unc_ctxconf[tmp],\n                    (uip_lladdr_t *)packetbuf_addr(PACKETBUF_ADDR_SENDER));\n  } else {\n    /* no compression and link local */\n    uncompress_addr(&SICSLOWPAN_IP_BUF(buf)->srcipaddr, llprefix, unc_llconf[tmp],\n                    (uip_lladdr_t *)packetbuf_addr(PACKETBUF_ADDR_SENDER));\n  }\n\n  /* Destination address */\n  /* put the destination address compression mode into tmp */\n  tmp = ((iphc1 & SICSLOWPAN_IPHC_DAM_11) >> SICSLOWPAN_IPHC_DAM_BIT) & 0x03;\n\n  /* multicast compression */\n  if(iphc1 & SICSLOWPAN_IPHC_M) {\n    /* context based multicast compression */\n    if(iphc1 & SICSLOWPAN_IPHC_DAC) {\n      /* TODO: implement this */\n    } else {\n      /* non-context based multicast compression - */\n      /* DAM_00: 128 bits  */\n      /* DAM_01:  48 bits FFXX::00XX:XXXX:XXXX */\n      /* DAM_10:  32 bits FFXX::00XX:XXXX */\n      /* DAM_11:   8 bits FF02::00XX */\n      uint8_t prefix[] = {0xff, 0x02};\n      if(tmp > 0 && tmp < 3) {\n        prefix[1] = *hc06_ptr;\n        hc06_ptr++;\n      }\n\n      uncompress_addr(&SICSLOWPAN_IP_BUF(buf)->destipaddr, prefix,\n                      unc_mxconf[tmp], NULL);\n    }\n  } else {\n    /* no multicast */\n    /* Context based */\n    if(iphc1 & SICSLOWPAN_IPHC_DAC) {\n      uint8_t dci = (iphc1 & SICSLOWPAN_IPHC_CID) ? PACKETBUF_IPHC_BUF[2] & 0x0f : 0;\n      context = addr_context_lookup_by_number(dci);\n\n      /* all valid cases below need the context! */\n      if(context == NULL) {\n        LOG_ERR(\"uncompression: error context not found\\n\");\n        return false;\n      }\n      uncompress_addr(&SICSLOWPAN_IP_BUF(buf)->destipaddr, context->prefix,\n                      unc_ctxconf[tmp],\n                      (uip_lladdr_t *)packetbuf_addr(PACKETBUF_ADDR_RECEIVER));\n    } else {\n      /* not context based => link local M = 0, DAC = 0 - same as SAC */\n      uncompress_addr(&SICSLOWPAN_IP_BUF(buf)->destipaddr, llprefix,\n                      unc_llconf[tmp],\n                      (uip_lladdr_t *)packetbuf_addr(PACKETBUF_ADDR_RECEIVER));\n    }\n  }\n  uncomp_hdr_len += UIP_IPH_LEN;\n\n  /* Next header processing - continued */\n  nhc = iphc0 & SICSLOWPAN_IPHC_NH_C;\n  /* The next header is compressed, NHC is following */\n  last_nextheader =  &SICSLOWPAN_IP_BUF(buf)->proto;\n  ip_payload = SICSLOWPAN_IPPAYLOAD_BUF(buf);\n\n  while(nhc && (*hc06_ptr & SICSLOWPAN_NHC_MASK) == SICSLOWPAN_NHC_EXT_HDR) {\n    uint8_t eid = (*hc06_ptr & 0x0e) >> 1;\n    /* next header compression flag */\n    uint8_t nh = (*hc06_ptr & 0x01);\n    uint8_t next = 0;\n    uint8_t len;\n    uint8_t proto;\n\n    nhc = nh;\n\n    hc06_ptr++;\n    if(!nh) {\n      next = *hc06_ptr;\n      hc06_ptr++;\n      LOG_DBG(\"uncompression: next header is inlined. Next: %d\\n\", next);\n    }\n    len = *hc06_ptr;\n    hc06_ptr++;\n\n    LOG_DBG(\"uncompression: found ext header id: %d next: %d len: %d\\n\", eid, next, len);\n    switch(eid) {\n    case SICSLOWPAN_NHC_ETX_HDR_HBHO:\n      proto = UIP_PROTO_HBHO;\n      break;\n    case SICSLOWPAN_NHC_ETX_HDR_ROUTING:\n      proto = UIP_PROTO_ROUTING;\n      break;\n    case SICSLOWPAN_NHC_ETX_HDR_FRAG:\n      proto = UIP_PROTO_FRAG;\n      break;\n    case SICSLOWPAN_NHC_ETX_HDR_DESTO:\n      proto = UIP_PROTO_DESTO;\n      break;\n    default:\n      LOG_DBG(\"uncompression: error unsupported ext header\\n\");\n      return false;\n    }\n    *last_nextheader = proto;\n\n    /* Check that there is enough room to write the extension header. */\n    if((ip_payload - buf) + UIP_EXT_HDR_LEN + len > buf_size) {\n      LOG_WARN(\"uncompression: cannot write ext header beyond target buffer\\n\");\n      return false;\n    }\n\n    /* uncompress the extension header */\n    exthdr = (struct uip_ext_hdr *)ip_payload;\n    exthdr->len = (UIP_EXT_HDR_LEN + len) / 8;\n    if(exthdr->len == 0) {\n      LOG_WARN(\"Extension header length is below 8\\n\");\n      return false;\n    }\n    exthdr->len--;\n    exthdr->next = next;\n    last_nextheader = &exthdr->next;\n    memcpy((uint8_t *)exthdr + UIP_EXT_HDR_LEN, hc06_ptr, len);\n\n    hc06_ptr += len;\n    uncomp_hdr_len += (exthdr->len + 1) * 8;\n    ip_payload += (exthdr->len + 1) * 8;\n    ext_hdr_len += (exthdr->len + 1) * 8;\n\n    LOG_DBG(\"uncompression: %d len: %d exthdr len: %d (calc: %d)\\n\",\n            proto, len, exthdr->len, (exthdr->len + 1) * 8);\n  }\n\n  /* The next header is compressed, NHC is following */\n  if(nhc && (*hc06_ptr & SICSLOWPAN_NHC_UDP_MASK) == SICSLOWPAN_NHC_UDP_ID) {\n    struct uip_udp_hdr *udp_buf = (struct uip_udp_hdr *)ip_payload;\n    uint16_t udp_len;\n    uint8_t checksum_compressed;\n    *last_nextheader = UIP_PROTO_UDP;\n    checksum_compressed = *hc06_ptr & SICSLOWPAN_NHC_UDP_CHECKSUMC;\n    LOG_DBG(\"uncompression: incoming header value: %i\\n\", *hc06_ptr);\n    switch(*hc06_ptr & SICSLOWPAN_NHC_UDP_CS_P_11) {\n    case SICSLOWPAN_NHC_UDP_CS_P_00:\n      /* 1 byte for NHC, 4 byte for ports, 2 bytes chksum */\n      memcpy(&udp_buf->srcport, hc06_ptr + 1, 2);\n      memcpy(&udp_buf->destport, hc06_ptr + 3, 2);\n      LOG_DBG(\"uncompression: UDP ports (ptr+5): %x, %x\\n\",\n             UIP_HTONS(udp_buf->srcport),\n             UIP_HTONS(udp_buf->destport));\n      hc06_ptr += 5;\n      break;\n\n    case SICSLOWPAN_NHC_UDP_CS_P_01:\n      /* 1 byte for NHC + source 16bit inline, dest = 0xF0 + 8 bit inline */\n      LOG_DBG(\"uncompression: destination address\\n\");\n      memcpy(&udp_buf->srcport, hc06_ptr + 1, 2);\n      udp_buf->destport = UIP_HTONS(SICSLOWPAN_UDP_8_BIT_PORT_MIN + (*(hc06_ptr + 3)));\n      LOG_DBG(\"uncompression: UDP ports (ptr+4): %x, %x\\n\",\n             UIP_HTONS(udp_buf->srcport), UIP_HTONS(udp_buf->destport));\n      hc06_ptr += 4;\n      break;\n\n    case SICSLOWPAN_NHC_UDP_CS_P_10:\n      /* 1 byte for NHC + source = 0xF0 + 8bit inline, dest = 16 bit inline*/\n      LOG_DBG(\"uncompression: source address\\n\");\n      udp_buf->srcport = UIP_HTONS(SICSLOWPAN_UDP_8_BIT_PORT_MIN +\n                                   (*(hc06_ptr + 1)));\n      memcpy(&udp_buf->destport, hc06_ptr + 2, 2);\n      LOG_DBG(\"uncompression: UDP ports (ptr+4): %x, %x\\n\",\n             UIP_HTONS(udp_buf->srcport), UIP_HTONS(udp_buf->destport));\n      hc06_ptr += 4;\n      break;\n\n    case SICSLOWPAN_NHC_UDP_CS_P_11:\n      /* 1 byte for NHC, 1 byte for ports */\n      udp_buf->srcport = UIP_HTONS(SICSLOWPAN_UDP_4_BIT_PORT_MIN +\n                                   (*(hc06_ptr + 1) >> 4));\n      udp_buf->destport = UIP_HTONS(SICSLOWPAN_UDP_4_BIT_PORT_MIN +\n                                    ((*(hc06_ptr + 1)) & 0x0F));\n      LOG_DBG(\"uncompression: UDP ports (ptr+2): %x, %x\\n\",\n             UIP_HTONS(udp_buf->srcport), UIP_HTONS(udp_buf->destport));\n      hc06_ptr += 2;\n      break;\n    default:\n      LOG_DBG(\"uncompression: error unsupported UDP compression\\n\");\n      return false;\n    }\n    if(!checksum_compressed) { /* has_checksum, default  */\n      memcpy(&udp_buf->udpchksum, hc06_ptr, 2);\n      hc06_ptr += 2;\n      LOG_DBG(\"uncompression: checksum included\\n\");\n    } else {\n      LOG_DBG(\"uncompression: checksum *NOT* included\\n\");\n    }\n\n    /* length field in UDP header (8 byte header + payload) */\n    udp_len = 8 + packetbuf_datalen() - (hc06_ptr - packetbuf_ptr);\n    udp_buf->udplen = UIP_HTONS(ip_len == 0 ? udp_len :\n                                ip_len - UIP_IPH_LEN - ext_hdr_len);\n    LOG_DBG(\"uncompression: UDP length: %u (ext: %u) ip_len: %d udp_len: %d\\n\",\n           UIP_HTONS(udp_buf->udplen), ext_hdr_len, ip_len, udp_len);\n\n    uncomp_hdr_len += UIP_UDPH_LEN;\n  }\n\n  packetbuf_hdr_len = hc06_ptr - packetbuf_ptr;\n\n  /* IP length field. */\n  if(ip_len == 0) {\n    int len = packetbuf_datalen() - packetbuf_hdr_len + uncomp_hdr_len - UIP_IPH_LEN;\n    LOG_DBG(\"uncompression: IP payload length: %d. %u - %u + %u - %u\\n\", len,\n           packetbuf_datalen(), packetbuf_hdr_len, uncomp_hdr_len, UIP_IPH_LEN);\n\n    /* This is not a fragmented packet */\n    SICSLOWPAN_IP_BUF(buf)->len[0] = len >> 8;\n    SICSLOWPAN_IP_BUF(buf)->len[1] = len & 0x00FF;\n  } else {\n    /* This is a 1st fragment */\n    SICSLOWPAN_IP_BUF(buf)->len[0] = (ip_len - UIP_IPH_LEN) >> 8;\n    SICSLOWPAN_IP_BUF(buf)->len[1] = (ip_len - UIP_IPH_LEN) & 0x00FF;\n  }\n\n  return true;\n}",
  "abstract_func_before": "static bool\nuncompress_hdr_iphc(uint8_t *VAR_0, uint16_t VAR_1, uint16_t VAR_2)\n{\n  uint8_t VAR_3, VAR_4, VAR_5, VAR_6;\n  struct uip_ext_hdr *VAR_7;\n  uint8_t* VAR_8;\n  uint8_t* VAR_9;\n  uint8_t VAR_10 = 0;\n\n  /* COMMENT_0 */\n  VAR_11 = VAR_12 + VAR_13 + 2;\n\n  VAR_4 = VAR_14[0];\n  VAR_5 = VAR_14[1];\n\n  /* COMMENT_1 */\n  if(VAR_5 & VAR_15) {\n    LOG_DBG(\"uncompression: CID flag set - increase header with one\\n\");\n    VAR_11++;\n  }\n\n  /* COMMENT_2 */\n    if((VAR_4 & VAR_16) == 0) {\n      /* COMMENT_3 */\n      if((VAR_4 & VAR_17) == 0) {\n        /* COMMENT_4 */\n        memcpy(&SICSLOWPAN_IP_BUF(VAR_0)->tcflow, VAR_11 + 1, 3);\n        VAR_3 = *VAR_11;\n        VAR_11 += 4;\n        /* COMMENT_5 */\n        /* COMMENT_6 */\n        SICSLOWPAN_IP_BUF(VAR_0)->vtc = 0x60 | ((VAR_3 >> 2) & 0x0f);\n        /* COMMENT_7 */\n        SICSLOWPAN_IP_BUF(VAR_0)->tcflow = ((VAR_3 >> 2) & 0x30) | (VAR_3 << 6) |\n          (SICSLOWPAN_IP_BUF(VAR_0)->tcflow & 0x0f);\n      } else {\n        /* COMMENT_8 */\n        SICSLOWPAN_IP_BUF(VAR_0)->vtc = 0x60;\n        /* COMMENT_9 */\n        SICSLOWPAN_IP_BUF(VAR_0)->tcflow = (*VAR_11 & 0x0F) |\n          ((*VAR_11 >> 2) & 0x30);\n        memcpy(&SICSLOWPAN_IP_BUF(VAR_0)->flow, VAR_11 + 1, 2);\n        VAR_11 += 3;\n      }\n    } else {\n      /* COMMENT_10 */\n      /* COMMENT_11 */\n      if((VAR_4 & VAR_17) == 0) {\n        /* COMMENT_12 */\n        SICSLOWPAN_IP_BUF(VAR_0)->vtc = 0x60 | ((*VAR_11 >> 2) & 0x0f);\n          SICSLOWPAN_IP_BUF(VAR_0)->tcflow = ((*VAR_11 << 6) & 0xC0) | ((*VAR_11 >> 2) & 0x30);\n          SICSLOWPAN_IP_BUF(VAR_0)->flow = 0;\n          VAR_11 += 1;\n      } else {\n        /* COMMENT_13 */\n        SICSLOWPAN_IP_BUF(VAR_0)->vtc = 0x60;\n        SICSLOWPAN_IP_BUF(VAR_0)->tcflow = 0;\n        SICSLOWPAN_IP_BUF(VAR_0)->flow = 0;\n      }\n    }\n\n  /* COMMENT_14 */\n  if((VAR_4 & VAR_18) == 0) {\n    /* COMMENT_15 */\n    SICSLOWPAN_IP_BUF(VAR_0)->proto = *VAR_11;\n    LOG_DBG(\"uncompression: next header inline: %d\\n\", SICSLOWPAN_IP_BUF(VAR_0)->proto);\n    VAR_11 += 1;\n  }\n\n  /* COMMENT_16 */\n  if((VAR_4 & 0x03) != VAR_19) {\n    SICSLOWPAN_IP_BUF(VAR_0)->ttl = VAR_20[VAR_4 & 0x03];\n  } else {\n    SICSLOWPAN_IP_BUF(VAR_0)->ttl = *VAR_11;\n    VAR_11 += 1;\n  }\n\n  /* COMMENT_17 */\n  VAR_3 = ((VAR_5 & VAR_21) >> VAR_22) & 0x03;\n\n  /* COMMENT_18 */\n  if(VAR_5 & VAR_23) {\n    uint8_t VAR_24 = (VAR_5 & VAR_15) ?\n      VAR_14[2] >> 4 : 0;\n\n    /* COMMENT_19 */\n    if (VAR_3 != 0) {\n      VAR_25 = addr_context_lookup_by_number(VAR_24);\n      if(VAR_25 == NULL) {\n        LOG_ERR(\"uncompression: error context not found\\n\");\n        return false;\n      }\n    }\n    /* COMMENT_20 */\n    uncompress_addr(&SICSLOWPAN_IP_BUF(VAR_0)->srcipaddr,\n                    VAR_3 != 0 ? VAR_25->prefix : NULL, VAR_26[VAR_3],\n                    (uip_lladdr_t *)packetbuf_addr(VAR_27));\n  } else {\n    /* COMMENT_21 */\n    uncompress_addr(&SICSLOWPAN_IP_BUF(VAR_0)->srcipaddr, VAR_28, VAR_29[VAR_3],\n                    (uip_lladdr_t *)packetbuf_addr(VAR_27));\n  }\n\n  /* COMMENT_22 */\n  /* COMMENT_23 */\n  VAR_3 = ((VAR_5 & VAR_30) >> VAR_31) & 0x03;\n\n  /* COMMENT_24 */\n  if(VAR_5 & VAR_32) {\n    /* COMMENT_25 */\n    if(VAR_5 & VAR_33) {\n      /* COMMENT_26 */\n    } else {\n      /* COMMENT_27 */\n      /* COMMENT_28 */\n      /* COMMENT_29 */\n      /* COMMENT_30 */\n      /* COMMENT_31 */\n      uint8_t VAR_34[] = {0xff, 0x02};\n      if(VAR_3 > 0 && VAR_3 < 3) {\n        VAR_34[1] = *VAR_11;\n        VAR_11++;\n      }\n\n      uncompress_addr(&SICSLOWPAN_IP_BUF(VAR_0)->destipaddr, VAR_34,\n                      VAR_35[VAR_3], NULL);\n    }\n  } else {\n    /* COMMENT_32 */\n    /* COMMENT_33 */\n    if(VAR_5 & VAR_33) {\n      uint8_t VAR_36 = (VAR_5 & VAR_15) ? VAR_14[2] & 0x0f : 0;\n      VAR_25 = addr_context_lookup_by_number(VAR_36);\n\n      /* COMMENT_34 */\n      if(VAR_25 == NULL) {\n        LOG_ERR(\"uncompression: error context not found\\n\");\n        return false;\n      }\n      uncompress_addr(&SICSLOWPAN_IP_BUF(VAR_0)->destipaddr, VAR_25->prefix,\n                      VAR_26[VAR_3],\n                      (uip_lladdr_t *)packetbuf_addr(VAR_37));\n    } else {\n      /* COMMENT_35 */\n      uncompress_addr(&SICSLOWPAN_IP_BUF(VAR_0)->destipaddr, VAR_28,\n                      VAR_29[VAR_3],\n                      (uip_lladdr_t *)packetbuf_addr(VAR_37));\n    }\n  }\n  VAR_38 += VAR_39;\n\n  /* COMMENT_36 */\n  VAR_6 = VAR_4 & VAR_18;\n  /* COMMENT_37 */\n  VAR_8 =  &SICSLOWPAN_IP_BUF(VAR_0)->proto;\n  VAR_9 = SICSLOWPAN_IPPAYLOAD_BUF(VAR_0);\n\n  while(VAR_6 && (*VAR_11 & VAR_40) == VAR_41) {\n    uint8_t VAR_42 = (*VAR_11 & 0x0e) >> 1;\n    /* COMMENT_38 */\n    uint8_t VAR_43 = (*VAR_11 & 0x01);\n    uint8_t VAR_44 = 0;\n    uint8_t VAR_45;\n    uint8_t VAR_46;\n\n    VAR_6 = VAR_43;\n\n    VAR_11++;\n    if(!VAR_43) {\n      VAR_44 = *VAR_11;\n      VAR_11++;\n      LOG_DBG(\"uncompression: next header is inlined. Next: %d\\n\", VAR_44);\n    }\n    VAR_45 = *VAR_11;\n    VAR_11++;\n\n    LOG_DBG(\"uncompression: found ext header id: %d next: %d len: %d\\n\", VAR_42, VAR_44, VAR_45);\n    switch(VAR_42) {\n    case VAR_47:\n      VAR_46 = VAR_48;\n      break;\n    case VAR_49:\n      VAR_46 = VAR_50;\n      break;\n    case VAR_51:\n      VAR_46 = VAR_52;\n      break;\n    case VAR_53:\n      VAR_46 = VAR_54;\n      break;\n    default:\n      LOG_DBG(\"uncompression: error unsupported ext header\\n\");\n      return false;\n    }\n    *VAR_8 = VAR_46;\n\n    /* COMMENT_39 */\n    if((VAR_9 - VAR_0) + VAR_55 + VAR_45 > VAR_1) {\n      LOG_WARN(\"uncompression: cannot write ext header beyond target buffer\\n\");\n      return false;\n    }\n\n    /* COMMENT_40 */\n    VAR_7 = (struct uip_ext_hdr *)VAR_9;\n    VAR_7->len = (VAR_55 + VAR_45) / 8;\n    if(VAR_7->len == 0) {\n      LOG_WARN(\"Extension header length is below 8\\n\");\n      return false;\n    }\n    VAR_7->len--;\n    VAR_7->next = VAR_44;\n    VAR_8 = &VAR_7->next;\n    memcpy((uint8_t *)VAR_7 + VAR_55, VAR_11, VAR_45);\n\n    VAR_11 += VAR_45;\n    VAR_38 += (VAR_7->len + 1) * 8;\n    VAR_9 += (VAR_7->len + 1) * 8;\n    VAR_10 += (VAR_7->len + 1) * 8;\n\n    LOG_DBG(\"uncompression: %d len: %d exthdr len: %d (calc: %d)\\n\",\n            VAR_46, VAR_45, VAR_7->len, (VAR_7->len + 1) * 8);\n  }\n\n  /* COMMENT_37 */\n  if(VAR_6 && (*VAR_11 & VAR_56) == VAR_57) {\n    struct uip_udp_hdr *VAR_58 = (struct uip_udp_hdr *)VAR_9;\n    uint16_t VAR_59;\n    uint8_t VAR_60;\n    *VAR_8 = VAR_61;\n    VAR_60 = *VAR_11 & VAR_62;\n    LOG_DBG(\"uncompression: incoming header value: %i\\n\", *VAR_11);\n    switch(*VAR_11 & VAR_63) {\n    case VAR_64:\n      /* COMMENT_41 */\n      memcpy(&VAR_58->srcport, VAR_11 + 1, 2);\n      memcpy(&VAR_58->destport, VAR_11 + 3, 2);\n      LOG_DBG(\"uncompression: UDP ports (ptr+5): %x, %x\\n\",\n             UIP_HTONS(VAR_58->srcport),\n             UIP_HTONS(VAR_58->destport));\n      VAR_11 += 5;\n      break;\n\n    case VAR_65:\n      /* COMMENT_42 */\n      LOG_DBG(\"uncompression: destination address\\n\");\n      memcpy(&VAR_58->srcport, VAR_11 + 1, 2);\n      VAR_58->destport = UIP_HTONS(VAR_66 + (*(VAR_11 + 3)));\n      LOG_DBG(\"uncompression: UDP ports (ptr+4): %x, %x\\n\",\n             UIP_HTONS(VAR_58->srcport), UIP_HTONS(VAR_58->destport));\n      VAR_11 += 4;\n      break;\n\n    case VAR_67:\n      /* COMMENT_43 */\n      LOG_DBG(\"uncompression: source address\\n\");\n      VAR_58->srcport = UIP_HTONS(VAR_66 +\n                                   (*(VAR_11 + 1)));\n      memcpy(&VAR_58->destport, VAR_11 + 2, 2);\n      LOG_DBG(\"uncompression: UDP ports (ptr+4): %x, %x\\n\",\n             UIP_HTONS(VAR_58->srcport), UIP_HTONS(VAR_58->destport));\n      VAR_11 += 4;\n      break;\n\n    case VAR_63:\n      /* COMMENT_44 */\n      VAR_58->srcport = UIP_HTONS(VAR_68 +\n                                   (*(VAR_11 + 1) >> 4));\n      VAR_58->destport = UIP_HTONS(VAR_68 +\n                                    ((*(VAR_11 + 1)) & 0x0F));\n      LOG_DBG(\"uncompression: UDP ports (ptr+2): %x, %x\\n\",\n             UIP_HTONS(VAR_58->srcport), UIP_HTONS(VAR_58->destport));\n      VAR_11 += 2;\n      break;\n    default:\n      LOG_DBG(\"uncompression: error unsupported UDP compression\\n\");\n      return false;\n    }\n    if(!VAR_60) { /* COMMENT_45 */\n      memcpy(&VAR_58->udpchksum, VAR_11, 2);\n      VAR_11 += 2;\n      LOG_DBG(\"uncompression: checksum included\\n\");\n    } else {\n      LOG_DBG(\"uncompression: checksum *NOT* included\\n\");\n    }\n\n    /* COMMENT_46 */\n    VAR_59 = 8 + packetbuf_datalen() - (VAR_11 - VAR_12);\n    VAR_58->udplen = UIP_HTONS(VAR_2 == 0 ? VAR_59 :\n                                VAR_2 - VAR_39 - VAR_10);\n    LOG_DBG(\"uncompression: UDP length: %u (ext: %u) ip_len: %d udp_len: %d\\n\",\n           UIP_HTONS(VAR_58->udplen), VAR_10, VAR_2, VAR_59);\n\n    VAR_38 += VAR_69;\n  }\n\n  VAR_13 = VAR_11 - VAR_12;\n\n  /* COMMENT_47 */\n  if(VAR_2 == 0) {\n    int VAR_45 = packetbuf_datalen() - VAR_13 + VAR_38 - VAR_39;\n    LOG_DBG(\"uncompression: IP payload length: %d. %u - %u + %u - %u\\n\", VAR_45,\n           packetbuf_datalen(), VAR_13, VAR_38, VAR_39);\n\n    /* COMMENT_48 */\n    SICSLOWPAN_IP_BUF(VAR_0)->len[0] = VAR_45 >> 8;\n    SICSLOWPAN_IP_BUF(VAR_0)->len[1] = VAR_45 & 0x00FF;\n  } else {\n    /* COMMENT_49 */\n    SICSLOWPAN_IP_BUF(VAR_0)->len[0] = (VAR_2 - VAR_39) >> 8;\n    SICSLOWPAN_IP_BUF(VAR_0)->len[1] = (VAR_2 - VAR_39) & 0x00FF;\n  }\n\n  return true;\n}",
  "func_graph_path_before": "contiki-ng/668f244058644c79752ef8a0d24d45721b510021/sicslowpan.c/vul/before/0.json",
  "func": "static bool\nuncompress_hdr_iphc(uint8_t *buf, uint16_t buf_size, uint16_t ip_len)\n{\n  uint8_t tmp, iphc0, iphc1, nhc;\n  struct uip_ext_hdr *exthdr;\n  uint8_t* last_nextheader;\n  uint8_t* ip_payload;\n  uint8_t ext_hdr_len = 0;\n  uint16_t cmpr_len;\n\n/* Macro used only internally, during header uncompression. Checks if there\n * is sufficient space in packetbuf before reading any further. */\n#define CHECK_READ_SPACE(readlen) \\\n  if((hc06_ptr - packetbuf_ptr) + (readlen) > cmpr_len) { \\\n    LOG_WARN(\"Not enough packetbuf space to decompress header (%u bytes, %u left). Aborting.\\n\", \\\n             (unsigned)(readlen), (unsigned)(cmpr_len - (hc06_ptr - packetbuf_ptr))); \\\n    return false; \\\n  }\n\n  /* at least two byte will be used for the encoding */\n  cmpr_len = packetbuf_datalen();\n  if(cmpr_len < packetbuf_hdr_len + 2) {\n    return false;\n  }\n  hc06_ptr = packetbuf_ptr + packetbuf_hdr_len + 2;\n\n  iphc0 = PACKETBUF_IPHC_BUF[0];\n  iphc1 = PACKETBUF_IPHC_BUF[1];\n\n  /* another if the CID flag is set */\n  if(iphc1 & SICSLOWPAN_IPHC_CID) {\n    LOG_DBG(\"uncompression: CID flag set - increase header with one\\n\");\n    hc06_ptr++;\n  }\n\n  /* Traffic class and flow label */\n    if((iphc0 & SICSLOWPAN_IPHC_FL_C) == 0) {\n      /* Flow label are carried inline */\n      if((iphc0 & SICSLOWPAN_IPHC_TC_C) == 0) {\n        /* Traffic class is carried inline */\n        CHECK_READ_SPACE(4);\n        memcpy(&SICSLOWPAN_IP_BUF(buf)->tcflow, hc06_ptr + 1, 3);\n        tmp = *hc06_ptr;\n        hc06_ptr += 4;\n        /* IPHC format of tc is ECN | DSCP , original is DSCP | ECN */\n        /* set version, pick highest DSCP bits and set in vtc */\n        SICSLOWPAN_IP_BUF(buf)->vtc = 0x60 | ((tmp >> 2) & 0x0f);\n        /* ECN rolled down two steps + lowest DSCP bits at top two bits */\n        SICSLOWPAN_IP_BUF(buf)->tcflow = ((tmp >> 2) & 0x30) | (tmp << 6) |\n          (SICSLOWPAN_IP_BUF(buf)->tcflow & 0x0f);\n      } else {\n        /* Traffic class is compressed (set version and no TC)*/\n        SICSLOWPAN_IP_BUF(buf)->vtc = 0x60;\n        /* highest flow label bits + ECN bits */\n        CHECK_READ_SPACE(3);\n        SICSLOWPAN_IP_BUF(buf)->tcflow = (*hc06_ptr & 0x0F) | \n          ((*hc06_ptr >> 2) & 0x30);\n        memcpy(&SICSLOWPAN_IP_BUF(buf)->flow, hc06_ptr + 1, 2);\n        hc06_ptr += 3;\n      }\n    } else {\n      /* Version is always 6! */\n      /* Version and flow label are compressed */\n      if((iphc0 & SICSLOWPAN_IPHC_TC_C) == 0) {\n        /* Traffic class is inline */\n        CHECK_READ_SPACE(1);\n        SICSLOWPAN_IP_BUF(buf)->vtc = 0x60 | ((*hc06_ptr >> 2) & 0x0f);\n        SICSLOWPAN_IP_BUF(buf)->tcflow = ((*hc06_ptr << 6) & 0xC0) | ((*hc06_ptr >> 2) & 0x30);\n        SICSLOWPAN_IP_BUF(buf)->flow = 0;\n        hc06_ptr += 1;\n      } else {\n        /* Traffic class is compressed */\n        SICSLOWPAN_IP_BUF(buf)->vtc = 0x60;\n        SICSLOWPAN_IP_BUF(buf)->tcflow = 0;\n        SICSLOWPAN_IP_BUF(buf)->flow = 0;\n      }\n    }\n\n  /* Next Header */\n  if((iphc0 & SICSLOWPAN_IPHC_NH_C) == 0) {\n    /* Next header is carried inline */\n    CHECK_READ_SPACE(1);\n    SICSLOWPAN_IP_BUF(buf)->proto = *hc06_ptr;\n    LOG_DBG(\"uncompression: next header inline: %d\\n\", SICSLOWPAN_IP_BUF(buf)->proto);\n    hc06_ptr += 1;\n  }\n\n  /* Hop limit */\n  if((iphc0 & 0x03) != SICSLOWPAN_IPHC_TTL_I) {\n    SICSLOWPAN_IP_BUF(buf)->ttl = ttl_values[iphc0 & 0x03];\n  } else {\n    CHECK_READ_SPACE(1);\n    SICSLOWPAN_IP_BUF(buf)->ttl = *hc06_ptr;\n    hc06_ptr += 1;\n  }\n\n  /* put the source address compression mode SAM in the tmp var */\n  tmp = ((iphc1 & SICSLOWPAN_IPHC_SAM_11) >> SICSLOWPAN_IPHC_SAM_BIT) & 0x03;\n\n  /* context based compression */\n  if(iphc1 & SICSLOWPAN_IPHC_SAC) {\n    uint8_t sci = (iphc1 & SICSLOWPAN_IPHC_CID) ?\n      PACKETBUF_IPHC_BUF[2] >> 4 : 0;\n\n    /* Source address - check context != NULL only if SAM bits are != 0*/\n    if (tmp != 0) {\n      context = addr_context_lookup_by_number(sci);\n      if(context == NULL) {\n        LOG_ERR(\"uncompression: error context not found\\n\");\n        return false;\n      }\n    }\n    /* if tmp == 0 we do not have a context and therefore no prefix */\n    uncompress_addr(&SICSLOWPAN_IP_BUF(buf)->srcipaddr,\n                    tmp != 0 ? context->prefix : NULL, unc_ctxconf[tmp],\n                    (uip_lladdr_t *)packetbuf_addr(PACKETBUF_ADDR_SENDER));\n  } else {\n    /* no compression and link local */\n    uncompress_addr(&SICSLOWPAN_IP_BUF(buf)->srcipaddr, llprefix, unc_llconf[tmp],\n                    (uip_lladdr_t *)packetbuf_addr(PACKETBUF_ADDR_SENDER));\n  }\n\n  /* Destination address */\n  /* put the destination address compression mode into tmp */\n  tmp = ((iphc1 & SICSLOWPAN_IPHC_DAM_11) >> SICSLOWPAN_IPHC_DAM_BIT) & 0x03;\n\n  /* multicast compression */\n  if(iphc1 & SICSLOWPAN_IPHC_M) {\n    /* context based multicast compression */\n    if(iphc1 & SICSLOWPAN_IPHC_DAC) {\n      /* TODO: implement this */\n    } else {\n      /* non-context based multicast compression - */\n      /* DAM_00: 128 bits  */\n      /* DAM_01:  48 bits FFXX::00XX:XXXX:XXXX */\n      /* DAM_10:  32 bits FFXX::00XX:XXXX */\n      /* DAM_11:   8 bits FF02::00XX */\n      uint8_t prefix[] = {0xff, 0x02};\n      if(tmp > 0 && tmp < 3) {\n        CHECK_READ_SPACE(1);\n        prefix[1] = *hc06_ptr;\n        hc06_ptr++;\n      }\n\n      uncompress_addr(&SICSLOWPAN_IP_BUF(buf)->destipaddr, prefix,\n                      unc_mxconf[tmp], NULL);\n    }\n  } else {\n    /* no multicast */\n    /* Context based */\n    if(iphc1 & SICSLOWPAN_IPHC_DAC) {\n      uint8_t dci = (iphc1 & SICSLOWPAN_IPHC_CID) ? PACKETBUF_IPHC_BUF[2] & 0x0f : 0;\n      context = addr_context_lookup_by_number(dci);\n\n      /* all valid cases below need the context! */\n      if(context == NULL) {\n        LOG_ERR(\"uncompression: error context not found\\n\");\n        return false;\n      }\n      uncompress_addr(&SICSLOWPAN_IP_BUF(buf)->destipaddr, context->prefix,\n                      unc_ctxconf[tmp],\n                      (uip_lladdr_t *)packetbuf_addr(PACKETBUF_ADDR_RECEIVER));\n    } else {\n      /* not context based => link local M = 0, DAC = 0 - same as SAC */\n      uncompress_addr(&SICSLOWPAN_IP_BUF(buf)->destipaddr, llprefix,\n                      unc_llconf[tmp],\n                      (uip_lladdr_t *)packetbuf_addr(PACKETBUF_ADDR_RECEIVER));\n    }\n  }\n  uncomp_hdr_len += UIP_IPH_LEN;\n\n  /* Next header processing - continued */\n  nhc = iphc0 & SICSLOWPAN_IPHC_NH_C;\n  /* The next header is compressed, NHC is following */\n  last_nextheader =  &SICSLOWPAN_IP_BUF(buf)->proto;\n  ip_payload = SICSLOWPAN_IPPAYLOAD_BUF(buf);\n\n  while(nhc && (*hc06_ptr & SICSLOWPAN_NHC_MASK) == SICSLOWPAN_NHC_EXT_HDR) {\n    CHECK_READ_SPACE(1);\n    uint8_t eid = (*hc06_ptr & 0x0e) >> 1;\n    /* next header compression flag */\n    uint8_t nh = (*hc06_ptr & 0x01);\n    uint8_t next = 0;\n    uint8_t len;\n    uint8_t proto;\n\n    nhc = nh;\n\n    hc06_ptr++;\n    if(!nh) {\n      CHECK_READ_SPACE(1);\n      next = *hc06_ptr;\n      hc06_ptr++;\n      LOG_DBG(\"uncompression: next header is inlined. Next: %d\\n\", next);\n    }\n    CHECK_READ_SPACE(1);\n    len = *hc06_ptr;\n    hc06_ptr++;\n\n    LOG_DBG(\"uncompression: found ext header id: %d next: %d len: %d\\n\", eid, next, len);\n    switch(eid) {\n    case SICSLOWPAN_NHC_ETX_HDR_HBHO:\n      proto = UIP_PROTO_HBHO;\n      break;\n    case SICSLOWPAN_NHC_ETX_HDR_ROUTING:\n      proto = UIP_PROTO_ROUTING;\n      break;\n    case SICSLOWPAN_NHC_ETX_HDR_FRAG:\n      proto = UIP_PROTO_FRAG;\n      break;\n    case SICSLOWPAN_NHC_ETX_HDR_DESTO:\n      proto = UIP_PROTO_DESTO;\n      break;\n    default:\n      LOG_DBG(\"uncompression: error unsupported ext header\\n\");\n      return false;\n    }\n    *last_nextheader = proto;\n\n    /* Check that there is enough room to write the extension header. */\n    if((ip_payload - buf) + UIP_EXT_HDR_LEN + len > buf_size) {\n      LOG_WARN(\"uncompression: cannot write ext header beyond target buffer\\n\");\n      return false;\n    }\n\n    /* uncompress the extension header */\n    exthdr = (struct uip_ext_hdr *)ip_payload;\n    exthdr->len = (UIP_EXT_HDR_LEN + len) / 8;\n    if(exthdr->len == 0) {\n      LOG_WARN(\"Extension header length is below 8\\n\");\n      return false;\n    }\n    exthdr->len--;\n    exthdr->next = next;\n    last_nextheader = &exthdr->next;\n\n    CHECK_READ_SPACE(len);\n    memcpy((uint8_t *)exthdr + UIP_EXT_HDR_LEN, hc06_ptr, len);\n    hc06_ptr += len;\n\n    uncomp_hdr_len += (exthdr->len + 1) * 8;\n    ip_payload += (exthdr->len + 1) * 8;\n    ext_hdr_len += (exthdr->len + 1) * 8;\n\n    LOG_DBG(\"uncompression: %d len: %d exthdr len: %d (calc: %d)\\n\",\n            proto, len, exthdr->len, (exthdr->len + 1) * 8);\n  }\n\n  /* The next header is compressed, NHC is following */\n  CHECK_READ_SPACE(1);\n  if(nhc && (*hc06_ptr & SICSLOWPAN_NHC_UDP_MASK) == SICSLOWPAN_NHC_UDP_ID) {\n    struct uip_udp_hdr *udp_buf = (struct uip_udp_hdr *)ip_payload;\n    uint16_t udp_len;\n    uint8_t checksum_compressed;\n    *last_nextheader = UIP_PROTO_UDP;\n    checksum_compressed = *hc06_ptr & SICSLOWPAN_NHC_UDP_CHECKSUMC;\n    LOG_DBG(\"uncompression: incoming header value: %i\\n\", *hc06_ptr);\n    switch(*hc06_ptr & SICSLOWPAN_NHC_UDP_CS_P_11) {\n    case SICSLOWPAN_NHC_UDP_CS_P_00:\n      /* 1 byte for NHC, 4 byte for ports, 2 bytes chksum */\n      CHECK_READ_SPACE(5);\n      memcpy(&udp_buf->srcport, hc06_ptr + 1, 2);\n      memcpy(&udp_buf->destport, hc06_ptr + 3, 2);\n      LOG_DBG(\"uncompression: UDP ports (ptr+5): %x, %x\\n\",\n             UIP_HTONS(udp_buf->srcport),\n             UIP_HTONS(udp_buf->destport));\n      hc06_ptr += 5;\n      break;\n\n    case SICSLOWPAN_NHC_UDP_CS_P_01:\n      /* 1 byte for NHC + source 16bit inline, dest = 0xF0 + 8 bit inline */\n      LOG_DBG(\"uncompression: destination address\\n\");\n      CHECK_READ_SPACE(4);\n      memcpy(&udp_buf->srcport, hc06_ptr + 1, 2);\n      udp_buf->destport = UIP_HTONS(SICSLOWPAN_UDP_8_BIT_PORT_MIN + (*(hc06_ptr + 3)));\n      LOG_DBG(\"uncompression: UDP ports (ptr+4): %x, %x\\n\",\n             UIP_HTONS(udp_buf->srcport), UIP_HTONS(udp_buf->destport));\n      hc06_ptr += 4;\n      break;\n\n    case SICSLOWPAN_NHC_UDP_CS_P_10:\n      /* 1 byte for NHC + source = 0xF0 + 8bit inline, dest = 16 bit inline*/\n      LOG_DBG(\"uncompression: source address\\n\");\n      CHECK_READ_SPACE(4);\n      udp_buf->srcport = UIP_HTONS(SICSLOWPAN_UDP_8_BIT_PORT_MIN +\n                                   (*(hc06_ptr + 1)));\n      memcpy(&udp_buf->destport, hc06_ptr + 2, 2);\n      LOG_DBG(\"uncompression: UDP ports (ptr+4): %x, %x\\n\",\n             UIP_HTONS(udp_buf->srcport), UIP_HTONS(udp_buf->destport));\n      hc06_ptr += 4;\n      break;\n\n    case SICSLOWPAN_NHC_UDP_CS_P_11:\n      /* 1 byte for NHC, 1 byte for ports */\n      CHECK_READ_SPACE(2);\n      udp_buf->srcport = UIP_HTONS(SICSLOWPAN_UDP_4_BIT_PORT_MIN +\n                                   (*(hc06_ptr + 1) >> 4));\n      udp_buf->destport = UIP_HTONS(SICSLOWPAN_UDP_4_BIT_PORT_MIN +\n                                    ((*(hc06_ptr + 1)) & 0x0F));\n      LOG_DBG(\"uncompression: UDP ports (ptr+2): %x, %x\\n\",\n             UIP_HTONS(udp_buf->srcport), UIP_HTONS(udp_buf->destport));\n\n      hc06_ptr += 2;\n      break;\n    default:\n      LOG_DBG(\"uncompression: error unsupported UDP compression\\n\");\n      return false;\n    }\n    if(!checksum_compressed) { /* has_checksum, default  */\n      CHECK_READ_SPACE(2);\n      memcpy(&udp_buf->udpchksum, hc06_ptr, 2);\n      hc06_ptr += 2;\n      LOG_DBG(\"uncompression: checksum included\\n\");\n    } else {\n      LOG_DBG(\"uncompression: checksum *NOT* included\\n\");\n    }\n\n    /* length field in UDP header (8 byte header + payload) */\n    udp_len = 8 + packetbuf_datalen() - (hc06_ptr - packetbuf_ptr);\n    udp_buf->udplen = UIP_HTONS(ip_len == 0 ? udp_len :\n                                ip_len - UIP_IPH_LEN - ext_hdr_len);\n    LOG_DBG(\"uncompression: UDP length: %u (ext: %u) ip_len: %d udp_len: %d\\n\",\n           UIP_HTONS(udp_buf->udplen), ext_hdr_len, ip_len, udp_len);\n\n    uncomp_hdr_len += UIP_UDPH_LEN;\n  }\n\n  packetbuf_hdr_len = hc06_ptr - packetbuf_ptr;\n\n  /* IP length field. */\n  if(ip_len == 0) {\n    int len = packetbuf_datalen() - packetbuf_hdr_len + uncomp_hdr_len - UIP_IPH_LEN;\n    LOG_DBG(\"uncompression: IP payload length: %d. %u - %u + %u - %u\\n\", len,\n           packetbuf_datalen(), packetbuf_hdr_len, uncomp_hdr_len, UIP_IPH_LEN);\n\n    /* This is not a fragmented packet */\n    SICSLOWPAN_IP_BUF(buf)->len[0] = len >> 8;\n    SICSLOWPAN_IP_BUF(buf)->len[1] = len & 0x00FF;\n  } else {\n    /* This is a 1st fragment */\n    SICSLOWPAN_IP_BUF(buf)->len[0] = (ip_len - UIP_IPH_LEN) >> 8;\n    SICSLOWPAN_IP_BUF(buf)->len[1] = (ip_len - UIP_IPH_LEN) & 0x00FF;\n  }\n\n  return true;\n}",
  "abstract_func": "static bool\nuncompress_hdr_iphc(uint8_t *VAR_0, uint16_t VAR_1, uint16_t VAR_2)\n{\n  uint8_t VAR_3, VAR_4, VAR_5, VAR_6;\n  struct uip_ext_hdr *VAR_7;\n  uint8_t* VAR_8;\n  uint8_t* VAR_9;\n  uint8_t VAR_10 = 0;\n  uint16_t VAR_11;\n\n/* COMMENT_0 */\n                                                                  \n#define CHECK_READ_SPACE(VAR_12) \\\n  if((hc06_ptr - packetbuf_ptr) + (readlen) > cmpr_len) { \\\n    LOG_WARN(\"Not enough packetbuf space to decompress header (%u bytes, %u left). Aborting.\\n\", \\\n             (unsigned)(readlen), (unsigned)(cmpr_len - (hc06_ptr - packetbuf_ptr))); \\\n    return false; \\\n  }\n\n  /* COMMENT_2 */\n  VAR_11 = packetbuf_datalen();\n  if(VAR_11 < VAR_13 + 2) {\n    return false;\n  }\n  VAR_14 = VAR_15 + VAR_13 + 2;\n\n  VAR_4 = VAR_16[0];\n  VAR_5 = VAR_16[1];\n\n  /* COMMENT_3 */\n  if(VAR_5 & VAR_17) {\n    LOG_DBG(\"uncompression: CID flag set - increase header with one\\n\");\n    VAR_14++;\n  }\n\n  /* COMMENT_4 */\n    if((VAR_4 & VAR_18) == 0) {\n      /* COMMENT_5 */\n      if((VAR_4 & VAR_19) == 0) {\n        /* COMMENT_6 */\n        CHECK_READ_SPACE(4);\n        memcpy(&SICSLOWPAN_IP_BUF(VAR_0)->tcflow, VAR_14 + 1, 3);\n        VAR_3 = *VAR_14;\n        VAR_14 += 4;\n        /* COMMENT_7 */\n        /* COMMENT_8 */\n        SICSLOWPAN_IP_BUF(VAR_0)->vtc = 0x60 | ((VAR_3 >> 2) & 0x0f);\n        /* COMMENT_9 */\n        SICSLOWPAN_IP_BUF(VAR_0)->tcflow = ((VAR_3 >> 2) & 0x30) | (VAR_3 << 6) |\n          (SICSLOWPAN_IP_BUF(VAR_0)->tcflow & 0x0f);\n      } else {\n        /* COMMENT_10 */\n        SICSLOWPAN_IP_BUF(VAR_0)->vtc = 0x60;\n        /* COMMENT_11 */\n        CHECK_READ_SPACE(3);\n        SICSLOWPAN_IP_BUF(VAR_0)->tcflow = (*VAR_14 & 0x0F) | \n          ((*VAR_14 >> 2) & 0x30);\n        memcpy(&SICSLOWPAN_IP_BUF(VAR_0)->flow, VAR_14 + 1, 2);\n        VAR_14 += 3;\n      }\n    } else {\n      /* COMMENT_12 */\n      /* COMMENT_13 */\n      if((VAR_4 & VAR_19) == 0) {\n        /* COMMENT_14 */\n        CHECK_READ_SPACE(1);\n        SICSLOWPAN_IP_BUF(VAR_0)->vtc = 0x60 | ((*VAR_14 >> 2) & 0x0f);\n        SICSLOWPAN_IP_BUF(VAR_0)->tcflow = ((*VAR_14 << 6) & 0xC0) | ((*VAR_14 >> 2) & 0x30);\n        SICSLOWPAN_IP_BUF(VAR_0)->flow = 0;\n        VAR_14 += 1;\n      } else {\n        /* COMMENT_15 */\n        SICSLOWPAN_IP_BUF(VAR_0)->vtc = 0x60;\n        SICSLOWPAN_IP_BUF(VAR_0)->tcflow = 0;\n        SICSLOWPAN_IP_BUF(VAR_0)->flow = 0;\n      }\n    }\n\n  /* COMMENT_16 */\n  if((VAR_4 & VAR_20) == 0) {\n    /* COMMENT_17 */\n    CHECK_READ_SPACE(1);\n    SICSLOWPAN_IP_BUF(VAR_0)->proto = *VAR_14;\n    LOG_DBG(\"uncompression: next header inline: %d\\n\", SICSLOWPAN_IP_BUF(VAR_0)->proto);\n    VAR_14 += 1;\n  }\n\n  /* COMMENT_18 */\n  if((VAR_4 & 0x03) != VAR_21) {\n    SICSLOWPAN_IP_BUF(VAR_0)->ttl = VAR_22[VAR_4 & 0x03];\n  } else {\n    CHECK_READ_SPACE(1);\n    SICSLOWPAN_IP_BUF(VAR_0)->ttl = *VAR_14;\n    VAR_14 += 1;\n  }\n\n  /* COMMENT_19 */\n  VAR_3 = ((VAR_5 & VAR_23) >> VAR_24) & 0x03;\n\n  /* COMMENT_20 */\n  if(VAR_5 & VAR_25) {\n    uint8_t VAR_26 = (VAR_5 & VAR_17) ?\n      VAR_16[2] >> 4 : 0;\n\n    /* COMMENT_21 */\n    if (VAR_3 != 0) {\n      VAR_27 = addr_context_lookup_by_number(VAR_26);\n      if(VAR_27 == NULL) {\n        LOG_ERR(\"uncompression: error context not found\\n\");\n        return false;\n      }\n    }\n    /* COMMENT_22 */\n    uncompress_addr(&SICSLOWPAN_IP_BUF(VAR_0)->srcipaddr,\n                    VAR_3 != 0 ? VAR_27->prefix : NULL, VAR_28[VAR_3],\n                    (uip_lladdr_t *)packetbuf_addr(VAR_29));\n  } else {\n    /* COMMENT_23 */\n    uncompress_addr(&SICSLOWPAN_IP_BUF(VAR_0)->srcipaddr, VAR_30, VAR_31[VAR_3],\n                    (uip_lladdr_t *)packetbuf_addr(VAR_29));\n  }\n\n  /* COMMENT_24 */\n  /* COMMENT_25 */\n  VAR_3 = ((VAR_5 & VAR_32) >> VAR_33) & 0x03;\n\n  /* COMMENT_26 */\n  if(VAR_5 & VAR_34) {\n    /* COMMENT_27 */\n    if(VAR_5 & VAR_35) {\n      /* COMMENT_28 */\n    } else {\n      /* COMMENT_29 */\n      /* COMMENT_30 */\n      /* COMMENT_31 */\n      /* COMMENT_32 */\n      /* COMMENT_33 */\n      uint8_t VAR_36[] = {0xff, 0x02};\n      if(VAR_3 > 0 && VAR_3 < 3) {\n        CHECK_READ_SPACE(1);\n        VAR_36[1] = *VAR_14;\n        VAR_14++;\n      }\n\n      uncompress_addr(&SICSLOWPAN_IP_BUF(VAR_0)->destipaddr, VAR_36,\n                      VAR_37[VAR_3], NULL);\n    }\n  } else {\n    /* COMMENT_34 */\n    /* COMMENT_35 */\n    if(VAR_5 & VAR_35) {\n      uint8_t VAR_38 = (VAR_5 & VAR_17) ? VAR_16[2] & 0x0f : 0;\n      VAR_27 = addr_context_lookup_by_number(VAR_38);\n\n      /* COMMENT_36 */\n      if(VAR_27 == NULL) {\n        LOG_ERR(\"uncompression: error context not found\\n\");\n        return false;\n      }\n      uncompress_addr(&SICSLOWPAN_IP_BUF(VAR_0)->destipaddr, VAR_27->prefix,\n                      VAR_28[VAR_3],\n                      (uip_lladdr_t *)packetbuf_addr(VAR_39));\n    } else {\n      /* COMMENT_37 */\n      uncompress_addr(&SICSLOWPAN_IP_BUF(VAR_0)->destipaddr, VAR_30,\n                      VAR_31[VAR_3],\n                      (uip_lladdr_t *)packetbuf_addr(VAR_39));\n    }\n  }\n  VAR_40 += VAR_41;\n\n  /* COMMENT_38 */\n  VAR_6 = VAR_4 & VAR_20;\n  /* COMMENT_39 */\n  VAR_8 =  &SICSLOWPAN_IP_BUF(VAR_0)->proto;\n  VAR_9 = SICSLOWPAN_IPPAYLOAD_BUF(VAR_0);\n\n  while(VAR_6 && (*VAR_14 & VAR_42) == VAR_43) {\n    CHECK_READ_SPACE(1);\n    uint8_t VAR_44 = (*VAR_14 & 0x0e) >> 1;\n    /* COMMENT_40 */\n    uint8_t VAR_45 = (*VAR_14 & 0x01);\n    uint8_t VAR_46 = 0;\n    uint8_t VAR_47;\n    uint8_t VAR_48;\n\n    VAR_6 = VAR_45;\n\n    VAR_14++;\n    if(!VAR_45) {\n      CHECK_READ_SPACE(1);\n      VAR_46 = *VAR_14;\n      VAR_14++;\n      LOG_DBG(\"uncompression: next header is inlined. Next: %d\\n\", VAR_46);\n    }\n    CHECK_READ_SPACE(1);\n    VAR_47 = *VAR_14;\n    VAR_14++;\n\n    LOG_DBG(\"uncompression: found ext header id: %d next: %d len: %d\\n\", VAR_44, VAR_46, VAR_47);\n    switch(VAR_44) {\n    case VAR_49:\n      VAR_48 = VAR_50;\n      break;\n    case VAR_51:\n      VAR_48 = VAR_52;\n      break;\n    case VAR_53:\n      VAR_48 = VAR_54;\n      break;\n    case VAR_55:\n      VAR_48 = VAR_56;\n      break;\n    default:\n      LOG_DBG(\"uncompression: error unsupported ext header\\n\");\n      return false;\n    }\n    *VAR_8 = VAR_48;\n\n    /* COMMENT_41 */\n    if((VAR_9 - VAR_0) + VAR_57 + VAR_47 > VAR_1) {\n      LOG_WARN(\"uncompression: cannot write ext header beyond target buffer\\n\");\n      return false;\n    }\n\n    /* COMMENT_42 */\n    VAR_7 = (struct uip_ext_hdr *)VAR_9;\n    VAR_7->len = (VAR_57 + VAR_47) / 8;\n    if(VAR_7->len == 0) {\n      LOG_WARN(\"Extension header length is below 8\\n\");\n      return false;\n    }\n    VAR_7->len--;\n    VAR_7->next = VAR_46;\n    VAR_8 = &VAR_7->next;\n\n    CHECK_READ_SPACE(VAR_47);\n    memcpy((uint8_t *)VAR_7 + VAR_57, VAR_14, VAR_47);\n    VAR_14 += VAR_47;\n\n    VAR_40 += (VAR_7->len + 1) * 8;\n    VAR_9 += (VAR_7->len + 1) * 8;\n    VAR_10 += (VAR_7->len + 1) * 8;\n\n    LOG_DBG(\"uncompression: %d len: %d exthdr len: %d (calc: %d)\\n\",\n            VAR_48, VAR_47, VAR_7->len, (VAR_7->len + 1) * 8);\n  }\n\n  /* COMMENT_39 */\n  CHECK_READ_SPACE(1);\n  if(VAR_6 && (*VAR_14 & VAR_58) == VAR_59) {\n    struct uip_udp_hdr *VAR_60 = (struct uip_udp_hdr *)VAR_9;\n    uint16_t VAR_61;\n    uint8_t VAR_62;\n    *VAR_8 = VAR_63;\n    VAR_62 = *VAR_14 & VAR_64;\n    LOG_DBG(\"uncompression: incoming header value: %i\\n\", *VAR_14);\n    switch(*VAR_14 & VAR_65) {\n    case VAR_66:\n      /* COMMENT_43 */\n      CHECK_READ_SPACE(5);\n      memcpy(&VAR_60->srcport, VAR_14 + 1, 2);\n      memcpy(&VAR_60->destport, VAR_14 + 3, 2);\n      LOG_DBG(\"uncompression: UDP ports (ptr+5): %x, %x\\n\",\n             UIP_HTONS(VAR_60->srcport),\n             UIP_HTONS(VAR_60->destport));\n      VAR_14 += 5;\n      break;\n\n    case VAR_67:\n      /* COMMENT_44 */\n      LOG_DBG(\"uncompression: destination address\\n\");\n      CHECK_READ_SPACE(4);\n      memcpy(&VAR_60->srcport, VAR_14 + 1, 2);\n      VAR_60->destport = UIP_HTONS(VAR_68 + (*(VAR_14 + 3)));\n      LOG_DBG(\"uncompression: UDP ports (ptr+4): %x, %x\\n\",\n             UIP_HTONS(VAR_60->srcport), UIP_HTONS(VAR_60->destport));\n      VAR_14 += 4;\n      break;\n\n    case VAR_69:\n      /* COMMENT_45 */\n      LOG_DBG(\"uncompression: source address\\n\");\n      CHECK_READ_SPACE(4);\n      VAR_60->srcport = UIP_HTONS(VAR_68 +\n                                   (*(VAR_14 + 1)));\n      memcpy(&VAR_60->destport, VAR_14 + 2, 2);\n      LOG_DBG(\"uncompression: UDP ports (ptr+4): %x, %x\\n\",\n             UIP_HTONS(VAR_60->srcport), UIP_HTONS(VAR_60->destport));\n      VAR_14 += 4;\n      break;\n\n    case VAR_65:\n      /* COMMENT_46 */\n      CHECK_READ_SPACE(2);\n      VAR_60->srcport = UIP_HTONS(VAR_70 +\n                                   (*(VAR_14 + 1) >> 4));\n      VAR_60->destport = UIP_HTONS(VAR_70 +\n                                    ((*(VAR_14 + 1)) & 0x0F));\n      LOG_DBG(\"uncompression: UDP ports (ptr+2): %x, %x\\n\",\n             UIP_HTONS(VAR_60->srcport), UIP_HTONS(VAR_60->destport));\n\n      VAR_14 += 2;\n      break;\n    default:\n      LOG_DBG(\"uncompression: error unsupported UDP compression\\n\");\n      return false;\n    }\n    if(!VAR_62) { /* COMMENT_47 */\n      CHECK_READ_SPACE(2);\n      memcpy(&VAR_60->udpchksum, VAR_14, 2);\n      VAR_14 += 2;\n      LOG_DBG(\"uncompression: checksum included\\n\");\n    } else {\n      LOG_DBG(\"uncompression: checksum *NOT* included\\n\");\n    }\n\n    /* COMMENT_48 */\n    VAR_61 = 8 + packetbuf_datalen() - (VAR_14 - VAR_15);\n    VAR_60->udplen = UIP_HTONS(VAR_2 == 0 ? VAR_61 :\n                                VAR_2 - VAR_41 - VAR_10);\n    LOG_DBG(\"uncompression: UDP length: %u (ext: %u) ip_len: %d udp_len: %d\\n\",\n           UIP_HTONS(VAR_60->udplen), VAR_10, VAR_2, VAR_61);\n\n    VAR_40 += VAR_71;\n  }\n\n  VAR_13 = VAR_14 - VAR_15;\n\n  /* COMMENT_49 */\n  if(VAR_2 == 0) {\n    int VAR_47 = packetbuf_datalen() - VAR_13 + VAR_40 - VAR_41;\n    LOG_DBG(\"uncompression: IP payload length: %d. %u - %u + %u - %u\\n\", VAR_47,\n           packetbuf_datalen(), VAR_13, VAR_40, VAR_41);\n\n    /* COMMENT_50 */\n    SICSLOWPAN_IP_BUF(VAR_0)->len[0] = VAR_47 >> 8;\n    SICSLOWPAN_IP_BUF(VAR_0)->len[1] = VAR_47 & 0x00FF;\n  } else {\n    /* COMMENT_51 */\n    SICSLOWPAN_IP_BUF(VAR_0)->len[0] = (VAR_2 - VAR_41) >> 8;\n    SICSLOWPAN_IP_BUF(VAR_0)->len[1] = (VAR_2 - VAR_41) & 0x00FF;\n  }\n\n  return true;\n}",
  "func_graph_path": "contiki-ng/668f244058644c79752ef8a0d24d45721b510021/sicslowpan.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -6,8 +6,22 @@\n   uint8_t* last_nextheader;\n   uint8_t* ip_payload;\n   uint8_t ext_hdr_len = 0;\n+  uint16_t cmpr_len;\n+\n+/* Macro used only internally, during header uncompression. Checks if there\n+ * is sufficient space in packetbuf before reading any further. */\n+#define CHECK_READ_SPACE(readlen) \\\n+  if((hc06_ptr - packetbuf_ptr) + (readlen) > cmpr_len) { \\\n+    LOG_WARN(\"Not enough packetbuf space to decompress header (%u bytes, %u left). Aborting.\\n\", \\\n+             (unsigned)(readlen), (unsigned)(cmpr_len - (hc06_ptr - packetbuf_ptr))); \\\n+    return false; \\\n+  }\n \n   /* at least two byte will be used for the encoding */\n+  cmpr_len = packetbuf_datalen();\n+  if(cmpr_len < packetbuf_hdr_len + 2) {\n+    return false;\n+  }\n   hc06_ptr = packetbuf_ptr + packetbuf_hdr_len + 2;\n \n   iphc0 = PACKETBUF_IPHC_BUF[0];\n@@ -24,6 +38,7 @@\n       /* Flow label are carried inline */\n       if((iphc0 & SICSLOWPAN_IPHC_TC_C) == 0) {\n         /* Traffic class is carried inline */\n+        CHECK_READ_SPACE(4);\n         memcpy(&SICSLOWPAN_IP_BUF(buf)->tcflow, hc06_ptr + 1, 3);\n         tmp = *hc06_ptr;\n         hc06_ptr += 4;\n@@ -37,7 +52,8 @@\n         /* Traffic class is compressed (set version and no TC)*/\n         SICSLOWPAN_IP_BUF(buf)->vtc = 0x60;\n         /* highest flow label bits + ECN bits */\n-        SICSLOWPAN_IP_BUF(buf)->tcflow = (*hc06_ptr & 0x0F) |\n+        CHECK_READ_SPACE(3);\n+        SICSLOWPAN_IP_BUF(buf)->tcflow = (*hc06_ptr & 0x0F) | \n           ((*hc06_ptr >> 2) & 0x30);\n         memcpy(&SICSLOWPAN_IP_BUF(buf)->flow, hc06_ptr + 1, 2);\n         hc06_ptr += 3;\n@@ -47,10 +63,11 @@\n       /* Version and flow label are compressed */\n       if((iphc0 & SICSLOWPAN_IPHC_TC_C) == 0) {\n         /* Traffic class is inline */\n+        CHECK_READ_SPACE(1);\n         SICSLOWPAN_IP_BUF(buf)->vtc = 0x60 | ((*hc06_ptr >> 2) & 0x0f);\n-          SICSLOWPAN_IP_BUF(buf)->tcflow = ((*hc06_ptr << 6) & 0xC0) | ((*hc06_ptr >> 2) & 0x30);\n-          SICSLOWPAN_IP_BUF(buf)->flow = 0;\n-          hc06_ptr += 1;\n+        SICSLOWPAN_IP_BUF(buf)->tcflow = ((*hc06_ptr << 6) & 0xC0) | ((*hc06_ptr >> 2) & 0x30);\n+        SICSLOWPAN_IP_BUF(buf)->flow = 0;\n+        hc06_ptr += 1;\n       } else {\n         /* Traffic class is compressed */\n         SICSLOWPAN_IP_BUF(buf)->vtc = 0x60;\n@@ -62,6 +79,7 @@\n   /* Next Header */\n   if((iphc0 & SICSLOWPAN_IPHC_NH_C) == 0) {\n     /* Next header is carried inline */\n+    CHECK_READ_SPACE(1);\n     SICSLOWPAN_IP_BUF(buf)->proto = *hc06_ptr;\n     LOG_DBG(\"uncompression: next header inline: %d\\n\", SICSLOWPAN_IP_BUF(buf)->proto);\n     hc06_ptr += 1;\n@@ -71,6 +89,7 @@\n   if((iphc0 & 0x03) != SICSLOWPAN_IPHC_TTL_I) {\n     SICSLOWPAN_IP_BUF(buf)->ttl = ttl_values[iphc0 & 0x03];\n   } else {\n+    CHECK_READ_SPACE(1);\n     SICSLOWPAN_IP_BUF(buf)->ttl = *hc06_ptr;\n     hc06_ptr += 1;\n   }\n@@ -118,6 +137,7 @@\n       /* DAM_11:   8 bits FF02::00XX */\n       uint8_t prefix[] = {0xff, 0x02};\n       if(tmp > 0 && tmp < 3) {\n+        CHECK_READ_SPACE(1);\n         prefix[1] = *hc06_ptr;\n         hc06_ptr++;\n       }\n@@ -156,6 +176,7 @@\n   ip_payload = SICSLOWPAN_IPPAYLOAD_BUF(buf);\n \n   while(nhc && (*hc06_ptr & SICSLOWPAN_NHC_MASK) == SICSLOWPAN_NHC_EXT_HDR) {\n+    CHECK_READ_SPACE(1);\n     uint8_t eid = (*hc06_ptr & 0x0e) >> 1;\n     /* next header compression flag */\n     uint8_t nh = (*hc06_ptr & 0x01);\n@@ -167,10 +188,12 @@\n \n     hc06_ptr++;\n     if(!nh) {\n+      CHECK_READ_SPACE(1);\n       next = *hc06_ptr;\n       hc06_ptr++;\n       LOG_DBG(\"uncompression: next header is inlined. Next: %d\\n\", next);\n     }\n+    CHECK_READ_SPACE(1);\n     len = *hc06_ptr;\n     hc06_ptr++;\n \n@@ -210,9 +233,11 @@\n     exthdr->len--;\n     exthdr->next = next;\n     last_nextheader = &exthdr->next;\n+\n+    CHECK_READ_SPACE(len);\n     memcpy((uint8_t *)exthdr + UIP_EXT_HDR_LEN, hc06_ptr, len);\n-\n     hc06_ptr += len;\n+\n     uncomp_hdr_len += (exthdr->len + 1) * 8;\n     ip_payload += (exthdr->len + 1) * 8;\n     ext_hdr_len += (exthdr->len + 1) * 8;\n@@ -222,6 +247,7 @@\n   }\n \n   /* The next header is compressed, NHC is following */\n+  CHECK_READ_SPACE(1);\n   if(nhc && (*hc06_ptr & SICSLOWPAN_NHC_UDP_MASK) == SICSLOWPAN_NHC_UDP_ID) {\n     struct uip_udp_hdr *udp_buf = (struct uip_udp_hdr *)ip_payload;\n     uint16_t udp_len;\n@@ -232,6 +258,7 @@\n     switch(*hc06_ptr & SICSLOWPAN_NHC_UDP_CS_P_11) {\n     case SICSLOWPAN_NHC_UDP_CS_P_00:\n       /* 1 byte for NHC, 4 byte for ports, 2 bytes chksum */\n+      CHECK_READ_SPACE(5);\n       memcpy(&udp_buf->srcport, hc06_ptr + 1, 2);\n       memcpy(&udp_buf->destport, hc06_ptr + 3, 2);\n       LOG_DBG(\"uncompression: UDP ports (ptr+5): %x, %x\\n\",\n@@ -243,6 +270,7 @@\n     case SICSLOWPAN_NHC_UDP_CS_P_01:\n       /* 1 byte for NHC + source 16bit inline, dest = 0xF0 + 8 bit inline */\n       LOG_DBG(\"uncompression: destination address\\n\");\n+      CHECK_READ_SPACE(4);\n       memcpy(&udp_buf->srcport, hc06_ptr + 1, 2);\n       udp_buf->destport = UIP_HTONS(SICSLOWPAN_UDP_8_BIT_PORT_MIN + (*(hc06_ptr + 3)));\n       LOG_DBG(\"uncompression: UDP ports (ptr+4): %x, %x\\n\",\n@@ -253,6 +281,7 @@\n     case SICSLOWPAN_NHC_UDP_CS_P_10:\n       /* 1 byte for NHC + source = 0xF0 + 8bit inline, dest = 16 bit inline*/\n       LOG_DBG(\"uncompression: source address\\n\");\n+      CHECK_READ_SPACE(4);\n       udp_buf->srcport = UIP_HTONS(SICSLOWPAN_UDP_8_BIT_PORT_MIN +\n                                    (*(hc06_ptr + 1)));\n       memcpy(&udp_buf->destport, hc06_ptr + 2, 2);\n@@ -263,12 +292,14 @@\n \n     case SICSLOWPAN_NHC_UDP_CS_P_11:\n       /* 1 byte for NHC, 1 byte for ports */\n+      CHECK_READ_SPACE(2);\n       udp_buf->srcport = UIP_HTONS(SICSLOWPAN_UDP_4_BIT_PORT_MIN +\n                                    (*(hc06_ptr + 1) >> 4));\n       udp_buf->destport = UIP_HTONS(SICSLOWPAN_UDP_4_BIT_PORT_MIN +\n                                     ((*(hc06_ptr + 1)) & 0x0F));\n       LOG_DBG(\"uncompression: UDP ports (ptr+2): %x, %x\\n\",\n              UIP_HTONS(udp_buf->srcport), UIP_HTONS(udp_buf->destport));\n+\n       hc06_ptr += 2;\n       break;\n     default:\n@@ -276,6 +307,7 @@\n       return false;\n     }\n     if(!checksum_compressed) { /* has_checksum, default  */\n+      CHECK_READ_SPACE(2);\n       memcpy(&udp_buf->udpchksum, hc06_ptr, 2);\n       hc06_ptr += 2;\n       LOG_DBG(\"uncompression: checksum included\\n\");",
  "diff_line_info": {
    "deleted_lines": [
      "        SICSLOWPAN_IP_BUF(buf)->tcflow = (*hc06_ptr & 0x0F) |",
      "          SICSLOWPAN_IP_BUF(buf)->tcflow = ((*hc06_ptr << 6) & 0xC0) | ((*hc06_ptr >> 2) & 0x30);",
      "          SICSLOWPAN_IP_BUF(buf)->flow = 0;",
      "          hc06_ptr += 1;",
      ""
    ],
    "added_lines": [
      "  uint16_t cmpr_len;",
      "",
      "/* Macro used only internally, during header uncompression. Checks if there",
      " * is sufficient space in packetbuf before reading any further. */",
      "#define CHECK_READ_SPACE(readlen) \\",
      "  if((hc06_ptr - packetbuf_ptr) + (readlen) > cmpr_len) { \\",
      "    LOG_WARN(\"Not enough packetbuf space to decompress header (%u bytes, %u left). Aborting.\\n\", \\",
      "             (unsigned)(readlen), (unsigned)(cmpr_len - (hc06_ptr - packetbuf_ptr))); \\",
      "    return false; \\",
      "  }",
      "  cmpr_len = packetbuf_datalen();",
      "  if(cmpr_len < packetbuf_hdr_len + 2) {",
      "    return false;",
      "  }",
      "        CHECK_READ_SPACE(4);",
      "        CHECK_READ_SPACE(3);",
      "        SICSLOWPAN_IP_BUF(buf)->tcflow = (*hc06_ptr & 0x0F) | ",
      "        CHECK_READ_SPACE(1);",
      "        SICSLOWPAN_IP_BUF(buf)->tcflow = ((*hc06_ptr << 6) & 0xC0) | ((*hc06_ptr >> 2) & 0x30);",
      "        SICSLOWPAN_IP_BUF(buf)->flow = 0;",
      "        hc06_ptr += 1;",
      "    CHECK_READ_SPACE(1);",
      "    CHECK_READ_SPACE(1);",
      "        CHECK_READ_SPACE(1);",
      "    CHECK_READ_SPACE(1);",
      "      CHECK_READ_SPACE(1);",
      "    CHECK_READ_SPACE(1);",
      "",
      "    CHECK_READ_SPACE(len);",
      "",
      "  CHECK_READ_SPACE(1);",
      "      CHECK_READ_SPACE(5);",
      "      CHECK_READ_SPACE(4);",
      "      CHECK_READ_SPACE(4);",
      "      CHECK_READ_SPACE(2);",
      "",
      "      CHECK_READ_SPACE(2);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/contiki-ng/contiki-ng/pull/1482",
  "description": {
    "pr_info": {
      "title": "Added buffer boundary checks for 6LoWPAN decompression",
      "number": 1482
    },
    "comment": [
      "Unlike for the 6LoWPAN compression function, there are no boundary checks in the decompression function. Additionally, packets that are not decompressed correctly are passed on the to the upper layer because the IPHC decompression function does not return a value indicating whether the operation succeeded.\r\n\r\nThis PR addresses these two issues. Moreover, a packet that demonstrates the out-of-bounds read is added to the packet test, but the problem might be noticed only when compiled with an address sanitizer."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "The patch addresses buffer overflow issues by adding boundary checks, directly fixing a security vulnerability.\n\n**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95"
}