{
  "cve_id": "CVE-2014-7203",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "zeromq/libzmq",
  "commit_msg": "Problem: curve messages can be replayed\n\nSolution: ensure message short nonces are strictly increasing and validate them",
  "commit_hash": "0900a489213d74feb86fc0b343308fe7884a2a3c",
  "git_url": "https://github.com/zeromq/libzmq/commit/0900a489213d74feb86fc0b343308fe7884a2a3c",
  "file_path": "src/curve_server.cpp",
  "func_name": "zmq::curve_server_t::process_initiate",
  "func_before": "int zmq::curve_server_t::process_initiate (msg_t *msg_)\n{\n    if (msg_->size () < 257) {\n        //  Temporary support for security debugging\n        puts (\"CURVE I: client INITIATE is not correct size\");\n        errno = EPROTO;\n        return -1;\n    }\n\n    const uint8_t *initiate = static_cast <uint8_t *> (msg_->data ());\n    if (memcmp (initiate, \"\\x08INITIATE\", 9)) {\n        //  Temporary support for security debugging\n        puts (\"CURVE I: client INITIATE has invalid command name\");\n        errno = EPROTO;\n        return -1;\n    }\n\n    uint8_t cookie_nonce [crypto_secretbox_NONCEBYTES];\n    uint8_t cookie_plaintext [crypto_secretbox_ZEROBYTES + 64];\n    uint8_t cookie_box [crypto_secretbox_BOXZEROBYTES + 80];\n\n    //  Open Box [C' + s'](t)\n    memset (cookie_box, 0, crypto_secretbox_BOXZEROBYTES);\n    memcpy (cookie_box + crypto_secretbox_BOXZEROBYTES, initiate + 25, 80);\n\n    memcpy (cookie_nonce, \"COOKIE--\", 8);\n    memcpy (cookie_nonce + 8, initiate + 9, 16);\n\n    int rc = crypto_secretbox_open (cookie_plaintext, cookie_box,\n                                    sizeof cookie_box,\n                                    cookie_nonce, cookie_key);\n    if (rc != 0) {\n        //  Temporary support for security debugging\n        puts (\"CURVE I: cannot open client INITIATE cookie\");\n        errno = EPROTO;\n        return -1;\n    }\n\n    //  Check cookie plain text is as expected [C' + s']\n    if (memcmp (cookie_plaintext + crypto_secretbox_ZEROBYTES, cn_client, 32)\n    ||  memcmp (cookie_plaintext + crypto_secretbox_ZEROBYTES + 32, cn_secret, 32)) {\n        //  Temporary support for security debugging\n        puts (\"CURVE I: client INITIATE cookie is not valid\");\n        errno = EPROTO;\n        return -1;\n    }\n\n    const size_t clen = (msg_->size () - 113) + crypto_box_BOXZEROBYTES;\n\n    uint8_t initiate_nonce [crypto_box_NONCEBYTES];\n    uint8_t initiate_plaintext [crypto_box_ZEROBYTES + 128 + 256];\n    uint8_t initiate_box [crypto_box_BOXZEROBYTES + 144 + 256];\n\n    //  Open Box [C + vouch + metadata](C'->S')\n    memset (initiate_box, 0, crypto_box_BOXZEROBYTES);\n    memcpy (initiate_box + crypto_box_BOXZEROBYTES,\n            initiate + 113, clen - crypto_box_BOXZEROBYTES);\n\n    memcpy (initiate_nonce, \"CurveZMQINITIATE\", 16);\n    memcpy (initiate_nonce + 16, initiate + 105, 8);\n\n    rc = crypto_box_open (initiate_plaintext, initiate_box,\n                          clen, initiate_nonce, cn_client, cn_secret);\n    if (rc != 0) {\n        //  Temporary support for security debugging\n        puts (\"CURVE I: cannot open client INITIATE\");\n        errno = EPROTO;\n        return -1;\n    }\n\n    const uint8_t *client_key = initiate_plaintext + crypto_box_ZEROBYTES;\n\n    uint8_t vouch_nonce [crypto_box_NONCEBYTES];\n    uint8_t vouch_plaintext [crypto_box_ZEROBYTES + 64];\n    uint8_t vouch_box [crypto_box_BOXZEROBYTES + 80];\n\n    //  Open Box Box [C',S](C->S') and check contents\n    memset (vouch_box, 0, crypto_box_BOXZEROBYTES);\n    memcpy (vouch_box + crypto_box_BOXZEROBYTES,\n            initiate_plaintext + crypto_box_ZEROBYTES + 48, 80);\n\n    memcpy (vouch_nonce, \"VOUCH---\", 8);\n    memcpy (vouch_nonce + 8,\n            initiate_plaintext + crypto_box_ZEROBYTES + 32, 16);\n\n    rc = crypto_box_open (vouch_plaintext, vouch_box,\n                          sizeof vouch_box,\n                          vouch_nonce, client_key, cn_secret);\n    if (rc != 0) {\n        //  Temporary support for security debugging\n        puts (\"CURVE I: cannot open client INITIATE vouch\");\n        errno = EPROTO;\n        return -1;\n    }\n\n    //  What we decrypted must be the client's short-term public key\n    if (memcmp (vouch_plaintext + crypto_box_ZEROBYTES, cn_client, 32)) {\n        //  Temporary support for security debugging\n        puts (\"CURVE I: invalid handshake from client (public key)\");\n        errno = EPROTO;\n        return -1;\n    }\n\n    //  Precompute connection secret from client key\n    rc = crypto_box_beforenm (cn_precom, cn_client, cn_secret);\n    zmq_assert (rc == 0);\n\n    //  Use ZAP protocol (RFC 27) to authenticate the user.\n    rc = session->zap_connect ();\n    if (rc == 0) {\n        send_zap_request (client_key);\n        rc = receive_and_process_zap_reply ();\n        if (rc == 0)\n            state = status_code == \"200\"\n                ? send_ready\n                : send_error;\n        else\n        if (errno == EAGAIN)\n            state = expect_zap_reply;\n        else\n            return -1;\n    }\n    else\n        state = send_ready;\n\n    return parse_metadata (initiate_plaintext + crypto_box_ZEROBYTES + 128,\n                           clen - crypto_box_ZEROBYTES - 128);\n}",
  "abstract_func_before": "int zmq::curve_server_t::process_initiate (msg_t *VAR_0)\n{\n    if (VAR_0->size () < 257) {\n        /* COMMENT_0 */\n        puts (\"CURVE I: client INITIATE is not correct size\");\n        VAR_1 = VAR_2;\n        return -1;\n    }\n\n    const uint8_t *VAR_3 = VAR_4 <uint8_t *> (VAR_0->data ());\n    if (memcmp (VAR_3, \"\\x08INITIATE\", 9)) {\n        /* COMMENT_0 */\n        puts (\"CURVE I: client INITIATE has invalid command name\");\n        VAR_1 = VAR_2;\n        return -1;\n    }\n\n    uint8_t VAR_5 [VAR_6];\n    uint8_t VAR_7 [VAR_8 + 64];\n    uint8_t VAR_9 [VAR_10 + 80];\n\n    /* COMMENT_1 */\n    memset (VAR_9, 0, VAR_10);\n    memcpy (VAR_9 + VAR_10, VAR_3 + 25, 80);\n\n    memcpy (VAR_5, \"COOKIE--\", 8);\n    memcpy (VAR_5 + 8, VAR_3 + 9, 16);\n\n    int VAR_11 = crypto_secretbox_open (VAR_7, VAR_9,\n                                    sizeof VAR_9,\n                                    VAR_5, VAR_12);\n    if (VAR_11 != 0) {\n        /* COMMENT_0 */\n        puts (\"CURVE I: cannot open client INITIATE cookie\");\n        VAR_1 = VAR_2;\n        return -1;\n    }\n\n    /* COMMENT_2 */\n    if (memcmp (VAR_7 + VAR_8, VAR_13, 32)\n    ||  memcmp (VAR_7 + VAR_8 + 32, VAR_14, 32)) {\n        /* COMMENT_0 */\n        puts (\"CURVE I: client INITIATE cookie is not valid\");\n        VAR_1 = VAR_2;\n        return -1;\n    }\n\n    const size_t VAR_15 = (VAR_0->size () - 113) + VAR_16;\n\n    uint8_t VAR_17 [VAR_18];\n    uint8_t VAR_19 [VAR_20 + 128 + 256];\n    uint8_t VAR_21 [VAR_16 + 144 + 256];\n\n    /* COMMENT_3 */\n    memset (VAR_21, 0, VAR_16);\n    memcpy (VAR_21 + VAR_16,\n            VAR_3 + 113, VAR_15 - VAR_16);\n\n    memcpy (VAR_17, \"CurveZMQINITIATE\", 16);\n    memcpy (VAR_17 + 16, VAR_3 + 105, 8);\n\n    VAR_11 = crypto_box_open (VAR_19, VAR_21,\n                          VAR_15, VAR_17, VAR_13, VAR_14);\n    if (VAR_11 != 0) {\n        /* COMMENT_0 */\n        puts (\"CURVE I: cannot open client INITIATE\");\n        VAR_1 = VAR_2;\n        return -1;\n    }\n\n    const uint8_t *VAR_22 = VAR_19 + VAR_20;\n\n    uint8_t VAR_23 [VAR_18];\n    uint8_t VAR_24 [VAR_20 + 64];\n    uint8_t VAR_25 [VAR_16 + 80];\n\n    /* COMMENT_4 */\n    memset (VAR_25, 0, VAR_16);\n    memcpy (VAR_25 + VAR_16,\n            VAR_19 + VAR_20 + 48, 80);\n\n    memcpy (VAR_23, \"VOUCH---\", 8);\n    memcpy (VAR_23 + 8,\n            VAR_19 + VAR_20 + 32, 16);\n\n    VAR_11 = crypto_box_open (VAR_24, VAR_25,\n                          sizeof VAR_25,\n                          VAR_23, VAR_22, VAR_14);\n    if (VAR_11 != 0) {\n        /* COMMENT_0 */\n        puts (\"CURVE I: cannot open client INITIATE vouch\");\n        VAR_1 = VAR_2;\n        return -1;\n    }\n\n    /* COMMENT_5 */\n    if (memcmp (VAR_24 + VAR_20, VAR_13, 32)) {\n        /* COMMENT_0 */\n        puts (\"CURVE I: invalid handshake from client (public key)\");\n        VAR_1 = VAR_2;\n        return -1;\n    }\n\n    /* COMMENT_6 */\n    VAR_11 = crypto_box_beforenm (VAR_26, VAR_13, VAR_14);\n    zmq_assert (VAR_11 == 0);\n\n    /* COMMENT_7 */\n    VAR_11 = VAR_27->zap_connect ();\n    if (VAR_11 == 0) {\n        send_zap_request (VAR_22);\n        VAR_11 = receive_and_process_zap_reply ();\n        if (VAR_11 == 0)\n            VAR_28 = VAR_29 == \"200\"\n                ? VAR_30\n                : VAR_31;\n        else\n        if (VAR_1 == VAR_32)\n            VAR_28 = VAR_33;\n        else\n            return -1;\n    }\n    else\n        VAR_28 = VAR_30;\n\n    return parse_metadata (VAR_19 + VAR_20 + 128,\n                           VAR_15 - VAR_20 - 128);\n}",
  "func_graph_path_before": "zeromq/libzmq/0900a489213d74feb86fc0b343308fe7884a2a3c/curve_server.cpp/vul/before/3.json",
  "func": "int zmq::curve_server_t::process_initiate (msg_t *msg_)\n{\n    if (msg_->size () < 257) {\n        //  Temporary support for security debugging\n        puts (\"CURVE I: client INITIATE is not correct size\");\n        errno = EPROTO;\n        return -1;\n    }\n\n    const uint8_t *initiate = static_cast <uint8_t *> (msg_->data ());\n    if (memcmp (initiate, \"\\x08INITIATE\", 9)) {\n        //  Temporary support for security debugging\n        puts (\"CURVE I: client INITIATE has invalid command name\");\n        errno = EPROTO;\n        return -1;\n    }\n\n    uint8_t cookie_nonce [crypto_secretbox_NONCEBYTES];\n    uint8_t cookie_plaintext [crypto_secretbox_ZEROBYTES + 64];\n    uint8_t cookie_box [crypto_secretbox_BOXZEROBYTES + 80];\n\n    //  Open Box [C' + s'](t)\n    memset (cookie_box, 0, crypto_secretbox_BOXZEROBYTES);\n    memcpy (cookie_box + crypto_secretbox_BOXZEROBYTES, initiate + 25, 80);\n\n    memcpy (cookie_nonce, \"COOKIE--\", 8);\n    memcpy (cookie_nonce + 8, initiate + 9, 16);\n\n    int rc = crypto_secretbox_open (cookie_plaintext, cookie_box,\n                                    sizeof cookie_box,\n                                    cookie_nonce, cookie_key);\n    if (rc != 0) {\n        //  Temporary support for security debugging\n        puts (\"CURVE I: cannot open client INITIATE cookie\");\n        errno = EPROTO;\n        return -1;\n    }\n\n    //  Check cookie plain text is as expected [C' + s']\n    if (memcmp (cookie_plaintext + crypto_secretbox_ZEROBYTES, cn_client, 32)\n    ||  memcmp (cookie_plaintext + crypto_secretbox_ZEROBYTES + 32, cn_secret, 32)) {\n        //  Temporary support for security debugging\n        puts (\"CURVE I: client INITIATE cookie is not valid\");\n        errno = EPROTO;\n        return -1;\n    }\n\n    const size_t clen = (msg_->size () - 113) + crypto_box_BOXZEROBYTES;\n\n    uint8_t initiate_nonce [crypto_box_NONCEBYTES];\n    uint8_t initiate_plaintext [crypto_box_ZEROBYTES + 128 + 256];\n    uint8_t initiate_box [crypto_box_BOXZEROBYTES + 144 + 256];\n\n    //  Open Box [C + vouch + metadata](C'->S')\n    memset (initiate_box, 0, crypto_box_BOXZEROBYTES);\n    memcpy (initiate_box + crypto_box_BOXZEROBYTES,\n            initiate + 113, clen - crypto_box_BOXZEROBYTES);\n\n    memcpy (initiate_nonce, \"CurveZMQINITIATE\", 16);\n    memcpy (initiate_nonce + 16, initiate + 105, 8);\n    cn_peer_nonce = get_uint64(initiate + 105);\n\n    rc = crypto_box_open (initiate_plaintext, initiate_box,\n                          clen, initiate_nonce, cn_client, cn_secret);\n    if (rc != 0) {\n        //  Temporary support for security debugging\n        puts (\"CURVE I: cannot open client INITIATE\");\n        errno = EPROTO;\n        return -1;\n    }\n\n    const uint8_t *client_key = initiate_plaintext + crypto_box_ZEROBYTES;\n\n    uint8_t vouch_nonce [crypto_box_NONCEBYTES];\n    uint8_t vouch_plaintext [crypto_box_ZEROBYTES + 64];\n    uint8_t vouch_box [crypto_box_BOXZEROBYTES + 80];\n\n    //  Open Box Box [C',S](C->S') and check contents\n    memset (vouch_box, 0, crypto_box_BOXZEROBYTES);\n    memcpy (vouch_box + crypto_box_BOXZEROBYTES,\n            initiate_plaintext + crypto_box_ZEROBYTES + 48, 80);\n\n    memcpy (vouch_nonce, \"VOUCH---\", 8);\n    memcpy (vouch_nonce + 8,\n            initiate_plaintext + crypto_box_ZEROBYTES + 32, 16);\n\n    rc = crypto_box_open (vouch_plaintext, vouch_box,\n                          sizeof vouch_box,\n                          vouch_nonce, client_key, cn_secret);\n    if (rc != 0) {\n        //  Temporary support for security debugging\n        puts (\"CURVE I: cannot open client INITIATE vouch\");\n        errno = EPROTO;\n        return -1;\n    }\n\n    //  What we decrypted must be the client's short-term public key\n    if (memcmp (vouch_plaintext + crypto_box_ZEROBYTES, cn_client, 32)) {\n        //  Temporary support for security debugging\n        puts (\"CURVE I: invalid handshake from client (public key)\");\n        errno = EPROTO;\n        return -1;\n    }\n\n    //  Precompute connection secret from client key\n    rc = crypto_box_beforenm (cn_precom, cn_client, cn_secret);\n    zmq_assert (rc == 0);\n\n    //  Use ZAP protocol (RFC 27) to authenticate the user.\n    rc = session->zap_connect ();\n    if (rc == 0) {\n        send_zap_request (client_key);\n        rc = receive_and_process_zap_reply ();\n        if (rc == 0)\n            state = status_code == \"200\"\n                ? send_ready\n                : send_error;\n        else\n        if (errno == EAGAIN)\n            state = expect_zap_reply;\n        else\n            return -1;\n    }\n    else\n        state = send_ready;\n\n    return parse_metadata (initiate_plaintext + crypto_box_ZEROBYTES + 128,\n                           clen - crypto_box_ZEROBYTES - 128);\n}",
  "abstract_func": "int zmq::curve_server_t::process_initiate (msg_t *VAR_0)\n{\n    if (VAR_0->size () < 257) {\n        /* COMMENT_0 */\n        puts (\"CURVE I: client INITIATE is not correct size\");\n        VAR_1 = VAR_2;\n        return -1;\n    }\n\n    const uint8_t *VAR_3 = VAR_4 <uint8_t *> (VAR_0->data ());\n    if (memcmp (VAR_3, \"\\x08INITIATE\", 9)) {\n        /* COMMENT_0 */\n        puts (\"CURVE I: client INITIATE has invalid command name\");\n        VAR_1 = VAR_2;\n        return -1;\n    }\n\n    uint8_t VAR_5 [VAR_6];\n    uint8_t VAR_7 [VAR_8 + 64];\n    uint8_t VAR_9 [VAR_10 + 80];\n\n    /* COMMENT_1 */\n    memset (VAR_9, 0, VAR_10);\n    memcpy (VAR_9 + VAR_10, VAR_3 + 25, 80);\n\n    memcpy (VAR_5, \"COOKIE--\", 8);\n    memcpy (VAR_5 + 8, VAR_3 + 9, 16);\n\n    int VAR_11 = crypto_secretbox_open (VAR_7, VAR_9,\n                                    sizeof VAR_9,\n                                    VAR_5, VAR_12);\n    if (VAR_11 != 0) {\n        /* COMMENT_0 */\n        puts (\"CURVE I: cannot open client INITIATE cookie\");\n        VAR_1 = VAR_2;\n        return -1;\n    }\n\n    /* COMMENT_2 */\n    if (memcmp (VAR_7 + VAR_8, VAR_13, 32)\n    ||  memcmp (VAR_7 + VAR_8 + 32, VAR_14, 32)) {\n        /* COMMENT_0 */\n        puts (\"CURVE I: client INITIATE cookie is not valid\");\n        VAR_1 = VAR_2;\n        return -1;\n    }\n\n    const size_t VAR_15 = (VAR_0->size () - 113) + VAR_16;\n\n    uint8_t VAR_17 [VAR_18];\n    uint8_t VAR_19 [VAR_20 + 128 + 256];\n    uint8_t VAR_21 [VAR_16 + 144 + 256];\n\n    /* COMMENT_3 */\n    memset (VAR_21, 0, VAR_16);\n    memcpy (VAR_21 + VAR_16,\n            VAR_3 + 113, VAR_15 - VAR_16);\n\n    memcpy (VAR_17, \"CurveZMQINITIATE\", 16);\n    memcpy (VAR_17 + 16, VAR_3 + 105, 8);\n    VAR_22 = get_uint64(VAR_3 + 105);\n\n    VAR_11 = crypto_box_open (VAR_19, VAR_21,\n                          VAR_15, VAR_17, VAR_13, VAR_14);\n    if (VAR_11 != 0) {\n        /* COMMENT_0 */\n        puts (\"CURVE I: cannot open client INITIATE\");\n        VAR_1 = VAR_2;\n        return -1;\n    }\n\n    const uint8_t *VAR_23 = VAR_19 + VAR_20;\n\n    uint8_t VAR_24 [VAR_18];\n    uint8_t VAR_25 [VAR_20 + 64];\n    uint8_t VAR_26 [VAR_16 + 80];\n\n    /* COMMENT_4 */\n    memset (VAR_26, 0, VAR_16);\n    memcpy (VAR_26 + VAR_16,\n            VAR_19 + VAR_20 + 48, 80);\n\n    memcpy (VAR_24, \"VOUCH---\", 8);\n    memcpy (VAR_24 + 8,\n            VAR_19 + VAR_20 + 32, 16);\n\n    VAR_11 = crypto_box_open (VAR_25, VAR_26,\n                          sizeof VAR_26,\n                          VAR_24, VAR_23, VAR_14);\n    if (VAR_11 != 0) {\n        /* COMMENT_0 */\n        puts (\"CURVE I: cannot open client INITIATE vouch\");\n        VAR_1 = VAR_2;\n        return -1;\n    }\n\n    /* COMMENT_5 */\n    if (memcmp (VAR_25 + VAR_20, VAR_13, 32)) {\n        /* COMMENT_0 */\n        puts (\"CURVE I: invalid handshake from client (public key)\");\n        VAR_1 = VAR_2;\n        return -1;\n    }\n\n    /* COMMENT_6 */\n    VAR_11 = crypto_box_beforenm (VAR_27, VAR_13, VAR_14);\n    zmq_assert (VAR_11 == 0);\n\n    /* COMMENT_7 */\n    VAR_11 = VAR_28->zap_connect ();\n    if (VAR_11 == 0) {\n        send_zap_request (VAR_23);\n        VAR_11 = receive_and_process_zap_reply ();\n        if (VAR_11 == 0)\n            VAR_29 = VAR_30 == \"200\"\n                ? VAR_31\n                : VAR_32;\n        else\n        if (VAR_1 == VAR_33)\n            VAR_29 = VAR_34;\n        else\n            return -1;\n    }\n    else\n        VAR_29 = VAR_31;\n\n    return parse_metadata (VAR_19 + VAR_20 + 128,\n                           VAR_15 - VAR_20 - 128);\n}",
  "func_graph_path": "zeromq/libzmq/0900a489213d74feb86fc0b343308fe7884a2a3c/curve_server.cpp/vul/after/3.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -58,6 +58,7 @@\n \n     memcpy (initiate_nonce, \"CurveZMQINITIATE\", 16);\n     memcpy (initiate_nonce + 16, initiate + 105, 8);\n+    cn_peer_nonce = get_uint64(initiate + 105);\n \n     rc = crypto_box_open (initiate_plaintext, initiate_box,\n                           clen, initiate_nonce, cn_client, cn_secret);",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "    cn_peer_nonce = get_uint64(initiate + 105);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/zeromq/libzmq/pull/1189",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/zeromq/libzmq/pull/1189: 403 Client Error: Forbidden for url: https://api.github.com/repos/zeromq/libzmq/pulls/1189",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.9"
}