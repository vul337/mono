{
  "cve_id": "CVE-2017-7555",
  "cwe_ids": [
    "CWE-119"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "hercules-team/augeas",
  "commit_msg": "* src/pathx.c (parse_name): correctly handle trailing whitespace in names\n\nWhen a name ended in whitespace, we incorrectly assumed it was always ok to\ntrim that whitespace. That is not true if that whitespace is escaped,\ni.e. if the path expression is something like '/x\\ '. In that case, the\nname really needs to be literally 'x ', i.e., we can not trim that\nwhitespace.\n\nThe incorrect behavior led to turning '/x\\ ' first into 'x\\' and then,\nbecause we assume that '\\' is always followed by a character inside the\nstring, when we removed the escaping '\\', we would read beyond the end of\nthe intermediate string result; if we were lucky, that would lead to a\ncrash, otherwise we'd continue with junk.\n\nWe now make sure that escaped whitespace at the end of a string does not\nget stripped, avoiding all these headaches.\n\nFixes RHBZ https://bugzilla.redhat.com/show_bug.cgi?id=1475621",
  "commit_hash": "4cca923b732990bec0c699b2e69911c2221b2498",
  "git_url": "https://github.com/hercules-team/augeas/commit/4cca923b732990bec0c699b2e69911c2221b2498",
  "file_path": "src/pathx.c",
  "func_name": "parse_name",
  "func_before": "static char *parse_name(struct state *state) {\n    const char *s = state->pos;\n    char *result;\n\n    while (*state->pos != '\\0' && strchr(name_follow, *state->pos) == NULL) {\n        /* This is a hack: since we allow spaces in names, we need to avoid\n         * gobbling up stuff that is in follow(Name), e.g. 'or' so that\n         * things like [name1 or name2] still work.\n         */\n        if (STREQLEN(state->pos, \" or \", strlen(\" or \")) ||\n            STREQLEN(state->pos, \" and \", strlen(\" and \")))\n            break;\n\n        if (*state->pos == '\\\\') {\n            state->pos += 1;\n            if (*state->pos == '\\0') {\n                STATE_ERROR(state, PATHX_ENAME);\n                return NULL;\n            }\n        }\n        state->pos += 1;\n    }\n\n    /* Strip trailing white space */\n    if (state->pos > s) {\n        state->pos -= 1;\n        while (isspace(*state->pos) && state->pos >= s)\n            state->pos -= 1;\n        state->pos += 1;\n    }\n\n    if (state->pos == s) {\n        STATE_ERROR(state, PATHX_ENAME);\n        return NULL;\n    }\n\n    result = strndup(s, state->pos - s);\n    if (result == NULL) {\n        STATE_ENOMEM;\n        return NULL;\n    }\n\n    char *p = result;\n    for (char *t = result; *t != '\\0'; t++, p++) {\n        if (*t == '\\\\')\n            t += 1;\n        *p = *t;\n    }\n    *p = '\\0';\n\n    return result;\n}",
  "abstract_func_before": "static char *parse_name(struct state *state) {\n    const char *VAR_0 = state->pos;\n    char *VAR_1;\n\n    while (*state->pos != '\\0' && strchr(VAR_2, *state->pos) == NULL) {\n        /* COMMENT_0 */\n                                                                       \n                                                   \n           \n        if (STREQLEN(state->pos, \" or \", strlen(\" or \")) ||\n            STREQLEN(state->pos, \" and \", strlen(\" and \")))\n            break;\n\n        if (*state->pos == '\\\\') {\n            state->pos += 1;\n            if (*state->pos == '\\0') {\n                STATE_ERROR(state, VAR_3);\n                return NULL;\n            }\n        }\n        state->pos += 1;\n    }\n\n    /* COMMENT_4 */\n    if (state->pos > VAR_0) {\n        state->pos -= 1;\n        while (isspace(*state->pos) && state->pos >= VAR_0)\n            state->pos -= 1;\n        state->pos += 1;\n    }\n\n    if (state->pos == VAR_0) {\n        STATE_ERROR(state, VAR_3);\n        return NULL;\n    }\n\n    VAR_1 = strndup(VAR_0, state->pos - VAR_0);\n    if (VAR_1 == NULL) {\n        VAR_4;\n        return NULL;\n    }\n\n    char *VAR_5 = VAR_1;\n    for (char *VAR_6 = VAR_1; *VAR_6 != '\\0'; VAR_6++, VAR_5++) {\n        if (*VAR_6 == '\\\\')\n            VAR_6 += 1;\n        *VAR_5 = *VAR_6;\n    }\n    *VAR_5 = '\\0';\n\n    return VAR_1;\n}",
  "func_graph_path_before": "hercules-team/augeas/4cca923b732990bec0c699b2e69911c2221b2498/pathx.c/vul/before/0.json",
  "func": "static char *parse_name(struct state *state) {\n    const char *s = state->pos;\n    char *result;\n\n    /* Advance state->pos until it points to the first character that is\n     * not part of a name. */\n    while (*state->pos != '\\0' && strchr(name_follow, *state->pos) == NULL) {\n        /* Since we allow spaces in names, we need to avoid gobbling up\n         * stuff that is in follow(Name), e.g. 'or' so that things like\n         * [name1 or name2] still work. In other words, we'll parse 'x frob\n         * y' as one name, but for 'x or y', we consider 'x' a name in its\n         * own right. */\n        if (STREQLEN(state->pos, \" or \", strlen(\" or \")) ||\n            STREQLEN(state->pos, \" and \", strlen(\" and \")))\n            break;\n\n        if (*state->pos == '\\\\') {\n            state->pos += 1;\n            if (*state->pos == '\\0') {\n                STATE_ERROR(state, PATHX_ENAME);\n                return NULL;\n            }\n        }\n        state->pos += 1;\n    }\n\n    /* Strip trailing white space. Make sure we respect escaped whitespace\n     * and don't strip it as in \"x\\\\ \" */\n    if (state->pos > s) {\n        state->pos -= 1;\n        while (isspace(*state->pos) && state->pos > s\n               && !backslash_escaped(state->pos, s))\n            state->pos -= 1;\n        state->pos += 1;\n    }\n\n    if (state->pos == s) {\n        STATE_ERROR(state, PATHX_ENAME);\n        return NULL;\n    }\n\n    result = strndup(s, state->pos - s);\n    if (result == NULL) {\n        STATE_ENOMEM;\n        return NULL;\n    }\n\n    char *p = result;\n    for (char *t = result; *t != '\\0'; t++, p++) {\n        if (*t == '\\\\')\n            t += 1;\n        *p = *t;\n    }\n    *p = '\\0';\n\n    return result;\n}",
  "abstract_func": "static char *parse_name(struct state *state) {\n    const char *VAR_0 = state->pos;\n    char *VAR_1;\n\n    /* COMMENT_0 */\n                             \n    while (*state->pos != '\\0' && strchr(VAR_2, *state->pos) == NULL) {\n        /* COMMENT_2 */\n                                                                       \n                                                                           \n                                                                          \n                        \n        if (STREQLEN(state->pos, \" or \", strlen(\" or \")) ||\n            STREQLEN(state->pos, \" and \", strlen(\" and \")))\n            break;\n\n        if (*state->pos == '\\\\') {\n            state->pos += 1;\n            if (*state->pos == '\\0') {\n                STATE_ERROR(state, VAR_3);\n                return NULL;\n            }\n        }\n        state->pos += 1;\n    }\n\n    /* COMMENT_7 */\n                                         \n    if (state->pos > VAR_0) {\n        state->pos -= 1;\n        while (isspace(*state->pos) && state->pos > VAR_0\n               && !backslash_escaped(state->pos, VAR_0))\n            state->pos -= 1;\n        state->pos += 1;\n    }\n\n    if (state->pos == VAR_0) {\n        STATE_ERROR(state, VAR_3);\n        return NULL;\n    }\n\n    VAR_1 = strndup(VAR_0, state->pos - VAR_0);\n    if (VAR_1 == NULL) {\n        VAR_4;\n        return NULL;\n    }\n\n    char *VAR_5 = VAR_1;\n    for (char *VAR_6 = VAR_1; *VAR_6 != '\\0'; VAR_6++, VAR_5++) {\n        if (*VAR_6 == '\\\\')\n            VAR_6 += 1;\n        *VAR_5 = *VAR_6;\n    }\n    *VAR_5 = '\\0';\n\n    return VAR_1;\n}",
  "func_graph_path": "hercules-team/augeas/4cca923b732990bec0c699b2e69911c2221b2498/pathx.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -2,11 +2,14 @@\n     const char *s = state->pos;\n     char *result;\n \n+    /* Advance state->pos until it points to the first character that is\n+     * not part of a name. */\n     while (*state->pos != '\\0' && strchr(name_follow, *state->pos) == NULL) {\n-        /* This is a hack: since we allow spaces in names, we need to avoid\n-         * gobbling up stuff that is in follow(Name), e.g. 'or' so that\n-         * things like [name1 or name2] still work.\n-         */\n+        /* Since we allow spaces in names, we need to avoid gobbling up\n+         * stuff that is in follow(Name), e.g. 'or' so that things like\n+         * [name1 or name2] still work. In other words, we'll parse 'x frob\n+         * y' as one name, but for 'x or y', we consider 'x' a name in its\n+         * own right. */\n         if (STREQLEN(state->pos, \" or \", strlen(\" or \")) ||\n             STREQLEN(state->pos, \" and \", strlen(\" and \")))\n             break;\n@@ -21,10 +24,12 @@\n         state->pos += 1;\n     }\n \n-    /* Strip trailing white space */\n+    /* Strip trailing white space. Make sure we respect escaped whitespace\n+     * and don't strip it as in \"x\\\\ \" */\n     if (state->pos > s) {\n         state->pos -= 1;\n-        while (isspace(*state->pos) && state->pos >= s)\n+        while (isspace(*state->pos) && state->pos > s\n+               && !backslash_escaped(state->pos, s))\n             state->pos -= 1;\n         state->pos += 1;\n     }",
  "diff_line_info": {
    "deleted_lines": [
      "        /* This is a hack: since we allow spaces in names, we need to avoid",
      "         * gobbling up stuff that is in follow(Name), e.g. 'or' so that",
      "         * things like [name1 or name2] still work.",
      "         */",
      "    /* Strip trailing white space */",
      "        while (isspace(*state->pos) && state->pos >= s)"
    ],
    "added_lines": [
      "    /* Advance state->pos until it points to the first character that is",
      "     * not part of a name. */",
      "        /* Since we allow spaces in names, we need to avoid gobbling up",
      "         * stuff that is in follow(Name), e.g. 'or' so that things like",
      "         * [name1 or name2] still work. In other words, we'll parse 'x frob",
      "         * y' as one name, but for 'x or y', we consider 'x' a name in its",
      "         * own right. */",
      "    /* Strip trailing white space. Make sure we respect escaped whitespace",
      "     * and don't strip it as in \"x\\\\ \" */",
      "        while (isspace(*state->pos) && state->pos > s",
      "               && !backslash_escaped(state->pos, s))"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/hercules-team/augeas/pull/480",
  "description": {
    "pr_info": {
      "title": "* src/pathx.c (parse_name): correctly handle trailing whitespace in n…",
      "number": 480
    },
    "comment": [
      "…ames\r\n\r\nWhen a name ended in whitespace, we incorrectly assumed it was always ok to\r\ntrim that whitespace. That is not true if that whitespace is escaped,\r\ni.e. if the path expression is something like '/x\\ '. In that case, the\r\nname really needs to be literally 'x ', i.e., we can not trim that\r\nwhitespace.\r\n\r\nThe incorrect behavior led to turning '/x\\ ' first into 'x\\' and then,\r\nbecause we assume that '\\' is always followed by a character inside the\r\nstring, when we removed the escaping '\\', we would read beyond the end of\r\nthe intermediate string result; if we were lucky, that would lead to a\r\ncrash, otherwise we'd continue with junk.\r\n\r\nWe now make sure that escaped whitespace at the end of a string does not\r\nget stripped, avoiding all these headaches.\r\n\r\nFixes RHBZ https://bugzilla.redhat.com/show_bug.cgi?id=1475621",
      "This is CVE-2017-7555."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "The patch addresses a buffer overflow vulnerability caused by improper handling of escaped whitespace. The code changes correctly manage this to prevent crashes due to memory issues.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}