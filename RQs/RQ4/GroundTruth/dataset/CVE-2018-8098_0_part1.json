{
  "cve_id": "CVE-2018-8098",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "libgit2",
  "commit_msg": "index: fix out-of-bounds read with invalid index entry prefix length\n\nThe index format in version 4 has prefix-compressed entries, where every\nindex entry can compress its path by using a path prefix of the previous\nentry. Since implmenting support for this index format version in commit\n5625d86b9 (index: support index v4, 2016-05-17), though, we do not\ncorrectly verify that the prefix length that we want to reuse is\nactually smaller or equal to the amount of characters than the length of\nthe previous index entry's path. This can lead to a an integer underflow\nand subsequently to an out-of-bounds read.\n\nFix this by verifying that the prefix is actually smaller than the\nprevious entry's path length.\n\nReported-by: Krishna Ram Prakash R <krp@gtux.in>\nReported-by: Vivek Parikh <viv0411.parikh@gmail.com>",
  "commit_hash": "3207ddb0103543da8ad2139ec6539f590f9900c1",
  "git_url": "https://github.com/libgit2/libgit2/commit/3207ddb0103543da8ad2139ec6539f590f9900c1",
  "file_path": "src/index.c",
  "func_name": "read_entry",
  "func_before": "static int read_entry(\n\tgit_index_entry **out,\n\tsize_t *out_size,\n\tgit_index *index,\n\tconst void *buffer,\n\tsize_t buffer_size,\n\tconst char *last)\n{\n\tsize_t path_length, entry_size;\n\tconst char *path_ptr;\n\tstruct entry_short source;\n\tgit_index_entry entry = {{0}};\n\tbool compressed = index->version >= INDEX_VERSION_NUMBER_COMP;\n\tchar *tmp_path = NULL;\n\n\tif (INDEX_FOOTER_SIZE + minimal_entry_size > buffer_size)\n\t\treturn -1;\n\n\t/* buffer is not guaranteed to be aligned */\n\tmemcpy(&source, buffer, sizeof(struct entry_short));\n\n\tentry.ctime.seconds = (git_time_t)ntohl(source.ctime.seconds);\n\tentry.ctime.nanoseconds = ntohl(source.ctime.nanoseconds);\n\tentry.mtime.seconds = (git_time_t)ntohl(source.mtime.seconds);\n\tentry.mtime.nanoseconds = ntohl(source.mtime.nanoseconds);\n\tentry.dev = ntohl(source.dev);\n\tentry.ino = ntohl(source.ino);\n\tentry.mode = ntohl(source.mode);\n\tentry.uid = ntohl(source.uid);\n\tentry.gid = ntohl(source.gid);\n\tentry.file_size = ntohl(source.file_size);\n\tgit_oid_cpy(&entry.id, &source.oid);\n\tentry.flags = ntohs(source.flags);\n\n\tif (entry.flags & GIT_IDXENTRY_EXTENDED) {\n\t\tuint16_t flags_raw;\n\t\tsize_t flags_offset;\n\n\t\tflags_offset = offsetof(struct entry_long, flags_extended);\n\t\tmemcpy(&flags_raw, (const char *) buffer + flags_offset,\n\t\t\tsizeof(flags_raw));\n\t\tflags_raw = ntohs(flags_raw);\n\n\t\tmemcpy(&entry.flags_extended, &flags_raw, sizeof(flags_raw));\n\t\tpath_ptr = (const char *) buffer + offsetof(struct entry_long, path);\n\t} else\n\t\tpath_ptr = (const char *) buffer + offsetof(struct entry_short, path);\n\n\tif (!compressed) {\n\t\tpath_length = entry.flags & GIT_IDXENTRY_NAMEMASK;\n\n\t\t/* if this is a very long string, we must find its\n\t\t * real length without overflowing */\n\t\tif (path_length == 0xFFF) {\n\t\t\tconst char *path_end;\n\n\t\t\tpath_end = memchr(path_ptr, '\\0', buffer_size);\n\t\t\tif (path_end == NULL)\n\t\t\t\treturn -1;\n\n\t\t\tpath_length = path_end - path_ptr;\n\t\t}\n\n\t\tentry_size = index_entry_size(path_length, 0, entry.flags);\n\t\tentry.path = (char *)path_ptr;\n\t} else {\n\t\tsize_t varint_len;\n\t\tsize_t strip_len = git_decode_varint((const unsigned char *)path_ptr,\n\t\t\t\t\t\t     &varint_len);\n\t\tsize_t last_len = strlen(last);\n\t\tsize_t prefix_len = last_len - strip_len;\n\t\tsize_t suffix_len = strlen(path_ptr + varint_len);\n\t\tsize_t path_len;\n\n\t\tif (varint_len == 0)\n\t\t\treturn index_error_invalid(\"incorrect prefix length\");\n\n\t\tGITERR_CHECK_ALLOC_ADD(&path_len, prefix_len, suffix_len);\n\t\tGITERR_CHECK_ALLOC_ADD(&path_len, path_len, 1);\n\t\ttmp_path = git__malloc(path_len);\n\t\tGITERR_CHECK_ALLOC(tmp_path);\n\n\t\tmemcpy(tmp_path, last, prefix_len);\n\t\tmemcpy(tmp_path + prefix_len, path_ptr + varint_len, suffix_len + 1);\n\t\tentry_size = index_entry_size(suffix_len, varint_len, entry.flags);\n\t\tentry.path = tmp_path;\n\t}\n\n\tif (entry_size == 0)\n\t\treturn -1;\n\n\tif (INDEX_FOOTER_SIZE + entry_size > buffer_size)\n\t\treturn -1;\n\n\tif (index_entry_dup(out, index, &entry) < 0) {\n\t\tgit__free(tmp_path);\n\t\treturn -1;\n\t}\n\n\tgit__free(tmp_path);\n\t*out_size = entry_size;\n\treturn 0;\n}",
  "abstract_func_before": "static int read_entry(\n\tgit_index_entry **VAR_0,\n\tsize_t *VAR_1,\n\tgit_index *VAR_2,\n\tconst void *VAR_3,\n\tsize_t VAR_4,\n\tconst char *VAR_5)\n{\n\tsize_t VAR_6, VAR_7;\n\tconst char *VAR_8;\n\tstruct entry_short VAR_9;\n\tgit_index_entry VAR_10 = {{0}};\n\tbool VAR_11 = VAR_2->version >= VAR_12;\n\tchar *VAR_13 = NULL;\n\n\tif (VAR_14 + VAR_15 > VAR_4)\n\t\treturn -1;\n\n\t/* COMMENT_0 */\n\tmemcpy(&VAR_9, VAR_3, sizeof(struct entry_short));\n\n\tVAR_10.ctime.seconds = (git_time_t)ntohl(VAR_9.ctime.seconds);\n\tVAR_10.ctime.nanoseconds = ntohl(VAR_9.ctime.nanoseconds);\n\tVAR_10.mtime.seconds = (git_time_t)ntohl(VAR_9.mtime.seconds);\n\tVAR_10.mtime.nanoseconds = ntohl(VAR_9.mtime.nanoseconds);\n\tVAR_10.dev = ntohl(VAR_9.dev);\n\tVAR_10.ino = ntohl(VAR_9.ino);\n\tVAR_10.mode = ntohl(VAR_9.mode);\n\tVAR_10.uid = ntohl(VAR_9.uid);\n\tVAR_10.gid = ntohl(VAR_9.gid);\n\tVAR_10.file_size = ntohl(VAR_9.file_size);\n\tgit_oid_cpy(&VAR_10.id, &VAR_9.oid);\n\tVAR_10.flags = ntohs(VAR_9.flags);\n\n\tif (VAR_10.flags & VAR_16) {\n\t\tuint16_t VAR_17;\n\t\tsize_t VAR_18;\n\n\t\tVAR_18 = offsetof(struct VAR_19, VAR_20);\n\t\tmemcpy(&VAR_17, (const char *) VAR_3 + VAR_18,\n\t\t\tsizeof(VAR_17));\n\t\tVAR_17 = ntohs(VAR_17);\n\n\t\tmemcpy(&VAR_10.flags_extended, &VAR_17, sizeof(VAR_17));\n\t\tVAR_8 = (const char *) VAR_3 + offsetof(struct VAR_19, VAR_21);\n\t} else\n\t\tVAR_8 = (const char *) VAR_3 + offsetof(struct entry_short, VAR_21);\n\n\tif (!VAR_11) {\n\t\tVAR_6 = VAR_10.flags & VAR_22;\n\n\t\t/* COMMENT_1 */\n                                       \n\t\tif (VAR_6 == 0xFFF) {\n\t\t\tconst char *VAR_23;\n\n\t\t\tVAR_23 = memchr(VAR_8, '\\0', VAR_4);\n\t\t\tif (VAR_23 == NULL)\n\t\t\t\treturn -1;\n\n\t\t\tVAR_6 = VAR_23 - VAR_8;\n\t\t}\n\n\t\tVAR_7 = index_entry_size(VAR_6, 0, VAR_10.flags);\n\t\tVAR_10.path = (char *)VAR_8;\n\t} else {\n\t\tsize_t VAR_24;\n\t\tsize_t VAR_25 = git_decode_varint((const unsigned char *)VAR_8,\n\t\t\t\t\t\t     &VAR_24);\n\t\tsize_t VAR_26 = strlen(VAR_5);\n\t\tsize_t VAR_27 = VAR_26 - VAR_25;\n\t\tsize_t VAR_28 = strlen(VAR_8 + VAR_24);\n\t\tsize_t VAR_29;\n\n\t\tif (VAR_24 == 0)\n\t\t\treturn index_error_invalid(\"incorrect prefix length\");\n\n\t\tGITERR_CHECK_ALLOC_ADD(&VAR_29, VAR_27, VAR_28);\n\t\tGITERR_CHECK_ALLOC_ADD(&VAR_29, VAR_29, 1);\n\t\tVAR_13 = git__malloc(VAR_29);\n\t\tGITERR_CHECK_ALLOC(VAR_13);\n\n\t\tmemcpy(VAR_13, VAR_5, VAR_27);\n\t\tmemcpy(VAR_13 + VAR_27, VAR_8 + VAR_24, VAR_28 + 1);\n\t\tVAR_7 = index_entry_size(VAR_28, VAR_24, VAR_10.flags);\n\t\tVAR_10.path = VAR_13;\n\t}\n\n\tif (VAR_7 == 0)\n\t\treturn -1;\n\n\tif (VAR_14 + VAR_7 > VAR_4)\n\t\treturn -1;\n\n\tif (index_entry_dup(VAR_0, VAR_2, &VAR_10) < 0) {\n\t\tgit__free(VAR_13);\n\t\treturn -1;\n\t}\n\n\tgit__free(VAR_13);\n\t*VAR_1 = VAR_7;\n\treturn 0;\n}",
  "func_graph_path_before": "libgit2/3207ddb0103543da8ad2139ec6539f590f9900c1/index.c/vul/before/0.json",
  "func": "static int read_entry(\n\tgit_index_entry **out,\n\tsize_t *out_size,\n\tgit_index *index,\n\tconst void *buffer,\n\tsize_t buffer_size,\n\tconst char *last)\n{\n\tsize_t path_length, entry_size;\n\tconst char *path_ptr;\n\tstruct entry_short source;\n\tgit_index_entry entry = {{0}};\n\tbool compressed = index->version >= INDEX_VERSION_NUMBER_COMP;\n\tchar *tmp_path = NULL;\n\n\tif (INDEX_FOOTER_SIZE + minimal_entry_size > buffer_size)\n\t\treturn -1;\n\n\t/* buffer is not guaranteed to be aligned */\n\tmemcpy(&source, buffer, sizeof(struct entry_short));\n\n\tentry.ctime.seconds = (git_time_t)ntohl(source.ctime.seconds);\n\tentry.ctime.nanoseconds = ntohl(source.ctime.nanoseconds);\n\tentry.mtime.seconds = (git_time_t)ntohl(source.mtime.seconds);\n\tentry.mtime.nanoseconds = ntohl(source.mtime.nanoseconds);\n\tentry.dev = ntohl(source.dev);\n\tentry.ino = ntohl(source.ino);\n\tentry.mode = ntohl(source.mode);\n\tentry.uid = ntohl(source.uid);\n\tentry.gid = ntohl(source.gid);\n\tentry.file_size = ntohl(source.file_size);\n\tgit_oid_cpy(&entry.id, &source.oid);\n\tentry.flags = ntohs(source.flags);\n\n\tif (entry.flags & GIT_IDXENTRY_EXTENDED) {\n\t\tuint16_t flags_raw;\n\t\tsize_t flags_offset;\n\n\t\tflags_offset = offsetof(struct entry_long, flags_extended);\n\t\tmemcpy(&flags_raw, (const char *) buffer + flags_offset,\n\t\t\tsizeof(flags_raw));\n\t\tflags_raw = ntohs(flags_raw);\n\n\t\tmemcpy(&entry.flags_extended, &flags_raw, sizeof(flags_raw));\n\t\tpath_ptr = (const char *) buffer + offsetof(struct entry_long, path);\n\t} else\n\t\tpath_ptr = (const char *) buffer + offsetof(struct entry_short, path);\n\n\tif (!compressed) {\n\t\tpath_length = entry.flags & GIT_IDXENTRY_NAMEMASK;\n\n\t\t/* if this is a very long string, we must find its\n\t\t * real length without overflowing */\n\t\tif (path_length == 0xFFF) {\n\t\t\tconst char *path_end;\n\n\t\t\tpath_end = memchr(path_ptr, '\\0', buffer_size);\n\t\t\tif (path_end == NULL)\n\t\t\t\treturn -1;\n\n\t\t\tpath_length = path_end - path_ptr;\n\t\t}\n\n\t\tentry_size = index_entry_size(path_length, 0, entry.flags);\n\t\tentry.path = (char *)path_ptr;\n\t} else {\n\t\tsize_t varint_len, last_len, prefix_len, suffix_len, path_len;\n\t\tuintmax_t strip_len;\n\n\t\tstrip_len = git_decode_varint((const unsigned char *)path_ptr, &varint_len);\n\t\tlast_len = strlen(last);\n\n\t\tif (varint_len == 0 || last_len < strip_len)\n\t\t\treturn index_error_invalid(\"incorrect prefix length\");\n\n\t\tprefix_len = last_len - strip_len;\n\t\tsuffix_len = strlen(path_ptr + varint_len);\n\n\t\tGITERR_CHECK_ALLOC_ADD(&path_len, prefix_len, suffix_len);\n\t\tGITERR_CHECK_ALLOC_ADD(&path_len, path_len, 1);\n\t\ttmp_path = git__malloc(path_len);\n\t\tGITERR_CHECK_ALLOC(tmp_path);\n\n\t\tmemcpy(tmp_path, last, prefix_len);\n\t\tmemcpy(tmp_path + prefix_len, path_ptr + varint_len, suffix_len + 1);\n\t\tentry_size = index_entry_size(suffix_len, varint_len, entry.flags);\n\t\tentry.path = tmp_path;\n\t}\n\n\tif (entry_size == 0)\n\t\treturn -1;\n\n\tif (INDEX_FOOTER_SIZE + entry_size > buffer_size)\n\t\treturn -1;\n\n\tif (index_entry_dup(out, index, &entry) < 0) {\n\t\tgit__free(tmp_path);\n\t\treturn -1;\n\t}\n\n\tgit__free(tmp_path);\n\t*out_size = entry_size;\n\treturn 0;\n}",
  "abstract_func": "static int read_entry(\n\tgit_index_entry **VAR_0,\n\tsize_t *VAR_1,\n\tgit_index *VAR_2,\n\tconst void *VAR_3,\n\tsize_t VAR_4,\n\tconst char *VAR_5)\n{\n\tsize_t VAR_6, VAR_7;\n\tconst char *VAR_8;\n\tstruct entry_short VAR_9;\n\tgit_index_entry VAR_10 = {{0}};\n\tbool VAR_11 = VAR_2->version >= VAR_12;\n\tchar *VAR_13 = NULL;\n\n\tif (VAR_14 + VAR_15 > VAR_4)\n\t\treturn -1;\n\n\t/* COMMENT_0 */\n\tmemcpy(&VAR_9, VAR_3, sizeof(struct entry_short));\n\n\tVAR_10.ctime.seconds = (git_time_t)ntohl(VAR_9.ctime.seconds);\n\tVAR_10.ctime.nanoseconds = ntohl(VAR_9.ctime.nanoseconds);\n\tVAR_10.mtime.seconds = (git_time_t)ntohl(VAR_9.mtime.seconds);\n\tVAR_10.mtime.nanoseconds = ntohl(VAR_9.mtime.nanoseconds);\n\tVAR_10.dev = ntohl(VAR_9.dev);\n\tVAR_10.ino = ntohl(VAR_9.ino);\n\tVAR_10.mode = ntohl(VAR_9.mode);\n\tVAR_10.uid = ntohl(VAR_9.uid);\n\tVAR_10.gid = ntohl(VAR_9.gid);\n\tVAR_10.file_size = ntohl(VAR_9.file_size);\n\tgit_oid_cpy(&VAR_10.id, &VAR_9.oid);\n\tVAR_10.flags = ntohs(VAR_9.flags);\n\n\tif (VAR_10.flags & VAR_16) {\n\t\tuint16_t VAR_17;\n\t\tsize_t VAR_18;\n\n\t\tVAR_18 = offsetof(struct VAR_19, VAR_20);\n\t\tmemcpy(&VAR_17, (const char *) VAR_3 + VAR_18,\n\t\t\tsizeof(VAR_17));\n\t\tVAR_17 = ntohs(VAR_17);\n\n\t\tmemcpy(&VAR_10.flags_extended, &VAR_17, sizeof(VAR_17));\n\t\tVAR_8 = (const char *) VAR_3 + offsetof(struct VAR_19, VAR_21);\n\t} else\n\t\tVAR_8 = (const char *) VAR_3 + offsetof(struct entry_short, VAR_21);\n\n\tif (!VAR_11) {\n\t\tVAR_6 = VAR_10.flags & VAR_22;\n\n\t\t/* COMMENT_1 */\n                                       \n\t\tif (VAR_6 == 0xFFF) {\n\t\t\tconst char *VAR_23;\n\n\t\t\tVAR_23 = memchr(VAR_8, '\\0', VAR_4);\n\t\t\tif (VAR_23 == NULL)\n\t\t\t\treturn -1;\n\n\t\t\tVAR_6 = VAR_23 - VAR_8;\n\t\t}\n\n\t\tVAR_7 = index_entry_size(VAR_6, 0, VAR_10.flags);\n\t\tVAR_10.path = (char *)VAR_8;\n\t} else {\n\t\tsize_t VAR_24, VAR_25, VAR_26, VAR_27, VAR_28;\n\t\tuintmax_t VAR_29;\n\n\t\tVAR_29 = git_decode_varint((const unsigned char *)VAR_8, &VAR_24);\n\t\tVAR_25 = strlen(VAR_5);\n\n\t\tif (VAR_24 == 0 || VAR_25 < VAR_29)\n\t\t\treturn index_error_invalid(\"incorrect prefix length\");\n\n\t\tVAR_26 = VAR_25 - VAR_29;\n\t\tVAR_27 = strlen(VAR_8 + VAR_24);\n\n\t\tGITERR_CHECK_ALLOC_ADD(&VAR_28, VAR_26, VAR_27);\n\t\tGITERR_CHECK_ALLOC_ADD(&VAR_28, VAR_28, 1);\n\t\tVAR_13 = git__malloc(VAR_28);\n\t\tGITERR_CHECK_ALLOC(VAR_13);\n\n\t\tmemcpy(VAR_13, VAR_5, VAR_26);\n\t\tmemcpy(VAR_13 + VAR_26, VAR_8 + VAR_24, VAR_27 + 1);\n\t\tVAR_7 = index_entry_size(VAR_27, VAR_24, VAR_10.flags);\n\t\tVAR_10.path = VAR_13;\n\t}\n\n\tif (VAR_7 == 0)\n\t\treturn -1;\n\n\tif (VAR_14 + VAR_7 > VAR_4)\n\t\treturn -1;\n\n\tif (index_entry_dup(VAR_0, VAR_2, &VAR_10) < 0) {\n\t\tgit__free(VAR_13);\n\t\treturn -1;\n\t}\n\n\tgit__free(VAR_13);\n\t*VAR_1 = VAR_7;\n\treturn 0;\n}",
  "func_graph_path": "libgit2/3207ddb0103543da8ad2139ec6539f590f9900c1/index.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -64,16 +64,17 @@\n \t\tentry_size = index_entry_size(path_length, 0, entry.flags);\n \t\tentry.path = (char *)path_ptr;\n \t} else {\n-\t\tsize_t varint_len;\n-\t\tsize_t strip_len = git_decode_varint((const unsigned char *)path_ptr,\n-\t\t\t\t\t\t     &varint_len);\n-\t\tsize_t last_len = strlen(last);\n-\t\tsize_t prefix_len = last_len - strip_len;\n-\t\tsize_t suffix_len = strlen(path_ptr + varint_len);\n-\t\tsize_t path_len;\n+\t\tsize_t varint_len, last_len, prefix_len, suffix_len, path_len;\n+\t\tuintmax_t strip_len;\n \n-\t\tif (varint_len == 0)\n+\t\tstrip_len = git_decode_varint((const unsigned char *)path_ptr, &varint_len);\n+\t\tlast_len = strlen(last);\n+\n+\t\tif (varint_len == 0 || last_len < strip_len)\n \t\t\treturn index_error_invalid(\"incorrect prefix length\");\n+\n+\t\tprefix_len = last_len - strip_len;\n+\t\tsuffix_len = strlen(path_ptr + varint_len);\n \n \t\tGITERR_CHECK_ALLOC_ADD(&path_len, prefix_len, suffix_len);\n \t\tGITERR_CHECK_ALLOC_ADD(&path_len, path_len, 1);",
  "diff_line_info": {
    "deleted_lines": [
      "\t\tsize_t varint_len;",
      "\t\tsize_t strip_len = git_decode_varint((const unsigned char *)path_ptr,",
      "\t\t\t\t\t\t     &varint_len);",
      "\t\tsize_t last_len = strlen(last);",
      "\t\tsize_t prefix_len = last_len - strip_len;",
      "\t\tsize_t suffix_len = strlen(path_ptr + varint_len);",
      "\t\tsize_t path_len;",
      "\t\tif (varint_len == 0)"
    ],
    "added_lines": [
      "\t\tsize_t varint_len, last_len, prefix_len, suffix_len, path_len;",
      "\t\tuintmax_t strip_len;",
      "\t\tstrip_len = git_decode_varint((const unsigned char *)path_ptr, &varint_len);",
      "\t\tlast_len = strlen(last);",
      "",
      "\t\tif (varint_len == 0 || last_len < strip_len)",
      "",
      "\t\tprefix_len = last_len - strip_len;",
      "\t\tsuffix_len = strlen(path_ptr + varint_len);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libgit2/libgit2/pull/4575",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/libgit2/libgit2/pull/4575: 403 Client Error: Forbidden for url: https://api.github.com/repos/libgit2/libgit2/pulls/4575",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0  \nThe patch addresses an out-of-bounds read vulnerability, fixing a security issue with high confidence."
}