{
  "cve_id": "CVE-2020-24266",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "appneta/tcpreplay",
  "commit_msg": "Bug #620 apply get.c functions fixed in #617\n\nAdd safety and failure reporting for packet captures with\ncaplen too small.",
  "commit_hash": "21cce6b1d63a4b431fdc5f239cd23cb7a80d514f",
  "git_url": "https://github.com/appneta/tcpreplay/commit/21cce6b1d63a4b431fdc5f239cd23cb7a80d514f",
  "file_path": "src/send_packets.c",
  "func_name": "send_packets",
  "func_before": "void\nsend_packets(tcpreplay_t *ctx, pcap_t *pcap, int idx)\n{\n\n    struct timeval print_delta, now, last_pkt_ts;\n    tcpreplay_opt_t *options = ctx->options;\n    tcpreplay_stats_t *stats = &ctx->stats;\n    COUNTER packetnum = 0;\n    COUNTER limit_send = options->limit_send;\n    struct pcap_pkthdr pkthdr;\n    u_char *pktdata = NULL;\n    sendpacket_t *sp = ctx->intf1;\n    COUNTER pktlen;\n    packet_cache_t *cached_packet = NULL;\n    packet_cache_t **prev_packet = NULL;\n#if defined TCPREPLAY && defined TCPREPLAY_EDIT\n    struct pcap_pkthdr *pkthdr_ptr;\n#endif\n    int datalink = options->file_cache[idx].dlt;\n    COUNTER skip_length = 0;\n    COUNTER end_us;\n    bool preload = options->file_cache[idx].cached;\n    bool top_speed = (options->speed.mode == speed_topspeed ||\n            (options->speed.mode == speed_mbpsrate && options->speed.speed == 0));\n    bool now_is_now = true;\n\n    gettimeofday(&now, NULL);\n    if (!timerisset(&stats->start_time)) {\n        TIMEVAL_SET(&stats->start_time, &now);\n        if (ctx->options->stats >= 0) {\n            char buf[64];\n            if (format_date_time(&stats->start_time, buf, sizeof(buf)) > 0)\n                printf(\"Test start: %s ...\\n\", buf);\n        }\n    }\n\n    ctx->skip_packets = 0;\n    timerclear(&last_pkt_ts);\n    if (options->limit_time > 0)\n        end_us = TIMEVAL_TO_MICROSEC(&stats->start_time) +\n            SEC_TO_MICROSEC(options->limit_time);\n    else\n        end_us = 0;\n\n    if (options->preload_pcap) {\n        prev_packet = &cached_packet;\n    } else {\n        prev_packet = NULL;\n    }\n\n    /* MAIN LOOP \n     * Keep sending while we have packets or until\n     * we've sent enough packets\n     */\n    while (!ctx->abort &&\n            (pktdata = get_next_packet(ctx, pcap, &pkthdr, idx, prev_packet)) != NULL) {\n\n        now_is_now = false;\n        packetnum++;\n#if defined TCPREPLAY || defined TCPREPLAY_EDIT\n        /* do we use the snaplen (caplen) or the \"actual\" packet len? */\n        pktlen = options->use_pkthdr_len ? (COUNTER)pkthdr.len : (COUNTER)pkthdr.caplen;\n#elif TCPBRIDGE\n        pktlen = (COUNTER)pkthdr.caplen;\n#else\n#error WTF???  We should not be here!\n#endif\n\n        dbgx(2, \"packet \" COUNTER_SPEC \" caplen \" COUNTER_SPEC, packetnum, pktlen);\n\n        /* Dual nic processing */\n        if (ctx->intf2 != NULL) {\n            sp = (sendpacket_t *)cache_mode(ctx, options->cachedata, packetnum);\n\n            /* sometimes we should not send the packet */\n            if (sp == TCPR_DIR_NOSEND)\n                continue;\n        }\n\n#if defined TCPREPLAY && defined TCPREPLAY_EDIT\n        pkthdr_ptr = &pkthdr;\n        if (tcpedit_packet(tcpedit, &pkthdr_ptr, &pktdata, sp->cache_dir) == -1) {\n            errx(-1, \"Error editing packet #\" COUNTER_SPEC \": %s\", packetnum, tcpedit_geterr(tcpedit));\n        }\n        pktlen = options->use_pkthdr_len ? (COUNTER)pkthdr_ptr->len : (COUNTER)pkthdr_ptr->caplen;\n#endif\n\n        if (ctx->options->unique_ip && ctx->unique_iteration &&\n                ctx->unique_iteration > ctx->last_unique_iteration) {\n            /* edit packet to ensure every pass has unique IP addresses */\n            fast_edit_packet(&pkthdr, &pktdata, ctx->unique_iteration - 1,\n                    preload, datalink);\n        }\n\n        /* update flow stats */\n        if (options->flow_stats && !preload)\n            update_flow_stats(ctx,\n                    options->cache_packets ? sp : NULL, &pkthdr, pktdata, datalink);\n\n        /*\n         * this accelerator improves performance by avoiding expensive\n         * time stamps during periods where we have fallen behind in our\n         * sending\n         */\n        if (skip_length && pktlen < skip_length) {\n            skip_length -= pktlen;\n        } else if (ctx->skip_packets) {\n            --ctx->skip_packets;\n        } else {\n            /*\n             * time stamping is expensive, but now is the\n             * time to do it.\n             */\n            dbgx(4, \"This packet time: \" TIMEVAL_FORMAT, pkthdr.ts.tv_sec,\n                    pkthdr.ts.tv_usec);\n            skip_length = 0;\n            ctx->skip_packets = 0;\n\n            if (options->speed.mode == speed_multiplier) {\n                if (!timerisset(&last_pkt_ts)) {\n                    TIMEVAL_SET(&last_pkt_ts, &pkthdr.ts);\n                } else if (timercmp(&pkthdr.ts, &last_pkt_ts, >)) {\n                    struct timeval delta;\n\n                    timersub(&pkthdr.ts, &last_pkt_ts, &delta);\n                    timeradd(&stats->pkt_ts_delta, &delta, &stats->pkt_ts_delta);\n                    TIMEVAL_SET(&last_pkt_ts, &pkthdr.ts);\n                }\n\n                if (!timerisset(&stats->time_delta))\n                    TIMEVAL_SET(&stats->pkt_ts_delta, &stats->pkt_ts_delta);\n            }\n\n            if (!top_speed) {\n                now_is_now = true;\n                gettimeofday(&now, NULL);\n            }\n\n            /*\n             * Only if the current packet is not late.\n             *\n             * This also sets skip_length and skip_packets which will avoid\n             * timestamping for a given number of packets.\n             */\n            calc_sleep_time(ctx, &stats->pkt_ts_delta, &stats->time_delta,\n                    pktlen, sp, packetnum, &stats->end_time,\n                    TIMEVAL_TO_MICROSEC(&stats->start_time), &skip_length);\n\n            /*\n             * Track the time of the \"last packet sent\".\n             *\n             * A number of 3rd party tools generate bad timestamps which go backwards\n             * in time.  Hence, don't update the \"last\" unless pkthdr.ts > last\n             */\n            if (timercmp(&stats->time_delta, &stats->pkt_ts_delta, <))\n                TIMEVAL_SET(&stats->time_delta, &stats->pkt_ts_delta);\n\n            /*\n             * we know how long to sleep between sends, now do it.\n             */\n            if (!top_speed)\n                tcpr_sleep(ctx, sp, &ctx->nap, &now);\n        }\n\n#ifdef ENABLE_VERBOSE\n        /* do we need to print the packet via tcpdump? */\n        if (options->verbose)\n            tcpdump_print(options->tcpdump, &pkthdr, pktdata);\n#endif\n\n        dbgx(2, \"Sending packet #\" COUNTER_SPEC, packetnum);\n        /* write packet out on network */\n        if (sendpacket(sp, pktdata, pktlen, &pkthdr) < (int)pktlen) {\n            warnx(\"Unable to send packet: %s\", sendpacket_geterr(sp));\n            break;\n        }\n\n        /*\n         * Mark the time when we sent the last packet\n         */\n        TIMEVAL_SET(&stats->end_time, &now);\n\n#ifdef TIMESTAMP_TRACE\n        add_timestamp_trace_entry(pktlen, &stats->end_time, skip_length);\n#endif\n\n        stats->pkts_sent++;\n        stats->bytes_sent += pktlen;\n\n        /* print stats during the run? */\n        if (options->stats > 0) {\n            if (! timerisset(&stats->last_print)) {\n                TIMEVAL_SET(&stats->last_print, &now);\n            } else {\n                timersub(&now, &stats->last_print, &print_delta);\n                if (print_delta.tv_sec >= options->stats) {\n                    TIMEVAL_SET(&stats->end_time, &now);\n                    packet_stats(stats);\n                    TIMEVAL_SET(&stats->last_print, &now);\n                }\n            }\n        }\n\n#if defined HAVE_NETMAP\n        if (sp->first_packet || timesisset(&ctx->nap)) {\n            wake_send_queues(sp, options);\n            sp->first_packet = false;\n        }\n#endif\n        /* stop sending based on the duration limit... */\n        if ((end_us > 0 && (COUNTER)TIMEVAL_TO_MICROSEC(&now) > end_us) ||\n                /* ... or stop sending based on the limit -L? */\n                (limit_send > 0 && stats->pkts_sent >= limit_send)) {\n            ctx->abort = true;\n        }\n    } /* while */\n\n\n#ifdef HAVE_NETMAP\n    /* when completing test, wait until the last packet is sent */\n    if (options->netmap && (ctx->abort || options->loop == 1)) {\n        while (ctx->intf1 && !netmap_tx_queues_empty(ctx->intf1)) {\n            now_is_now = true;\n            gettimeofday(&now, NULL);\n        }\n\n        while (ctx->intf2 && !netmap_tx_queues_empty(ctx->intf2)) {\n            now_is_now = true;\n            gettimeofday(&now, NULL);\n        }\n    }\n#endif /* HAVE_NETMAP */\n\n    if (!now_is_now)\n        gettimeofday(&now, NULL);\n\n    TIMEVAL_SET(&stats->end_time, &now);\n\n    increment_iteration(ctx);\n}",
  "abstract_func_before": "void\nsend_packets(tcpreplay_t *VAR_0, pcap_t *VAR_1, int VAR_2)\n{\n\n    struct timeval VAR_3, VAR_4, VAR_5;\n    tcpreplay_opt_t *VAR_6 = VAR_0->options;\n    tcpreplay_stats_t *VAR_7 = &VAR_0->stats;\n    COUNTER VAR_8 = 0;\n    COUNTER VAR_9 = VAR_6->limit_send;\n    struct pcap_pkthdr VAR_10;\n    u_char *VAR_11 = NULL;\n    sendpacket_t *VAR_12 = VAR_0->intf1;\n    COUNTER VAR_13;\n    packet_cache_t *VAR_14 = NULL;\n    packet_cache_t **VAR_15 = NULL;\n#if defined VAR_16 && defined VAR_17\n    struct pcap_pkthdr *VAR_18;\n#endif\n    int VAR_19 = VAR_6->file_cache[VAR_2].dlt;\n    COUNTER VAR_20 = 0;\n    COUNTER VAR_21;\n    bool VAR_22 = VAR_6->file_cache[VAR_2].cached;\n    bool VAR_23 = (VAR_6->speed.mode == VAR_24 ||\n            (VAR_6->speed.mode == VAR_25 && VAR_6->speed.speed == 0));\n    bool VAR_26 = true;\n\n    gettimeofday(&VAR_4, NULL);\n    if (!timerisset(&VAR_7->start_time)) {\n        TIMEVAL_SET(&VAR_7->start_time, &VAR_4);\n        if (VAR_0->options->stats >= 0) {\n            char VAR_27[64];\n            if (format_date_time(&VAR_7->start_time, VAR_27, sizeof(VAR_27)) > 0)\n                printf(\"Test start: %s ...\\n\", VAR_27);\n        }\n    }\n\n    VAR_0->skip_packets = 0;\n    timerclear(&VAR_5);\n    if (VAR_6->limit_time > 0)\n        VAR_21 = TIMEVAL_TO_MICROSEC(&VAR_7->start_time) +\n            SEC_TO_MICROSEC(VAR_6->limit_time);\n    else\n        VAR_21 = 0;\n\n    if (VAR_6->preload_pcap) {\n        VAR_15 = &VAR_14;\n    } else {\n        VAR_15 = NULL;\n    }\n\n    /* COMMENT_0 */\n                                                  \n                                \n       \n    while (!VAR_0->abort &&\n            (VAR_11 = get_next_packet(VAR_0, VAR_1, &VAR_10, VAR_2, VAR_15)) != NULL) {\n\n        VAR_26 = false;\n        VAR_8++;\n#if defined VAR_16 || defined VAR_17\n        /* COMMENT_4 */\n        VAR_13 = VAR_6->use_pkthdr_len ? (COUNTER)VAR_10.len : (COUNTER)VAR_10.caplen;\n#elif VAR_28\n        VAR_13 = (COUNTER)VAR_10.caplen;\n#else\n#error WTF???  We should not be here!\n#endif\n\n        dbgx(2, \"packet \" VAR_29 \" caplen \" VAR_29, VAR_8, VAR_13);\n\n        /* COMMENT_5 */\n        if (VAR_0->intf2 != NULL) {\n            VAR_12 = (sendpacket_t *)cache_mode(VAR_0, VAR_6->cachedata, VAR_8);\n\n            /* COMMENT_6 */\n            if (VAR_12 == VAR_30)\n                continue;\n        }\n\n#if defined VAR_16 && defined VAR_17\n        VAR_18 = &VAR_10;\n        if (tcpedit_packet(VAR_31, &VAR_18, &VAR_11, VAR_12->cache_dir) == -1) {\n            errx(-1, \"Error editing packet #\" VAR_29 \": %s\", VAR_8, tcpedit_geterr(VAR_31));\n        }\n        VAR_13 = VAR_6->use_pkthdr_len ? (COUNTER)VAR_18->len : (COUNTER)VAR_18->caplen;\n#endif\n\n        if (VAR_0->options->unique_ip && VAR_0->unique_iteration &&\n                VAR_0->unique_iteration > VAR_0->last_unique_iteration) {\n            /* COMMENT_7 */\n            fast_edit_packet(&VAR_10, &VAR_11, VAR_0->unique_iteration - 1,\n                    VAR_22, VAR_19);\n        }\n\n        /* COMMENT_8 */\n        if (VAR_6->flow_stats && !VAR_22)\n            update_flow_stats(VAR_0,\n                    VAR_6->cache_packets ? VAR_12 : NULL, &VAR_10, VAR_11, VAR_19);\n\n        /* COMMENT_9 */\n                                                                      \n                                                                        \n                  \n           \n        if (VAR_20 && VAR_13 < VAR_20) {\n            VAR_20 -= VAR_13;\n        } else if (VAR_0->skip_packets) {\n            --VAR_0->skip_packets;\n        } else {\n            /* COMMENT_14 */\n                                                         \n                             \n               \n            dbgx(4, \"This packet time: \" VAR_32, VAR_10.ts.tv_sec,\n                    VAR_10.ts.tv_usec);\n            VAR_20 = 0;\n            VAR_0->skip_packets = 0;\n\n            if (VAR_6->speed.mode == VAR_33) {\n                if (!timerisset(&VAR_5)) {\n                    TIMEVAL_SET(&VAR_5, &VAR_10.ts);\n                } else if (timercmp(&VAR_10.ts, &VAR_5, >)) {\n                    struct timeval VAR_34;\n\n                    timersub(&VAR_10.ts, &VAR_5, &VAR_34);\n                    timeradd(&VAR_7->pkt_ts_delta, &VAR_34, &VAR_7->pkt_ts_delta);\n                    TIMEVAL_SET(&VAR_5, &VAR_10.ts);\n                }\n\n                if (!timerisset(&VAR_7->time_delta))\n                    TIMEVAL_SET(&VAR_7->pkt_ts_delta, &VAR_7->pkt_ts_delta);\n            }\n\n            if (!VAR_23) {\n                VAR_26 = true;\n                gettimeofday(&VAR_4, NULL);\n            }\n\n            /* COMMENT_18 */\n                                                      \n              \n                                                                           \n                                                          \n               \n            calc_sleep_time(VAR_0, &VAR_7->pkt_ts_delta, &VAR_7->time_delta,\n                    VAR_13, VAR_12, VAR_8, &VAR_7->end_time,\n                    TIMEVAL_TO_MICROSEC(&VAR_7->start_time), &VAR_20);\n\n            /* COMMENT_24 */\n                                                        \n              \n                                                                                     \n                                                                               \n               \n            if (timercmp(&VAR_7->time_delta, &VAR_7->pkt_ts_delta, <))\n                TIMEVAL_SET(&VAR_7->time_delta, &VAR_7->pkt_ts_delta);\n\n            /* COMMENT_30 */\n                                                                  \n               \n            if (!VAR_23)\n                tcpr_sleep(VAR_0, VAR_12, &VAR_0->nap, &VAR_4);\n        }\n\n#ifdef VAR_35\n        /* COMMENT_33 */\n        if (VAR_6->verbose)\n            tcpdump_print(VAR_6->tcpdump, &VAR_10, VAR_11);\n#endif\n\n        dbgx(2, \"Sending packet #\" VAR_29, VAR_8);\n        /* COMMENT_34 */\n        if (sendpacket(VAR_12, VAR_11, VAR_13, &VAR_10) < (int)VAR_13) {\n            warnx(\"Unable to send packet: %s\", sendpacket_geterr(VAR_12));\n            break;\n        }\n\n        /* COMMENT_35 */\n                                                     \n           \n        TIMEVAL_SET(&VAR_7->end_time, &VAR_4);\n\n#ifdef VAR_36\n        add_timestamp_trace_entry(VAR_13, &VAR_7->end_time, VAR_20);\n#endif\n\n        VAR_7->pkts_sent++;\n        VAR_7->bytes_sent += VAR_13;\n\n        /* COMMENT_38 */\n        if (VAR_6->stats > 0) {\n            if (! timerisset(&VAR_7->last_print)) {\n                TIMEVAL_SET(&VAR_7->last_print, &VAR_4);\n            } else {\n                timersub(&VAR_4, &VAR_7->last_print, &VAR_3);\n                if (VAR_3.tv_sec >= VAR_6->stats) {\n                    TIMEVAL_SET(&VAR_7->end_time, &VAR_4);\n                    packet_stats(VAR_7);\n                    TIMEVAL_SET(&VAR_7->last_print, &VAR_4);\n                }\n            }\n        }\n\n#if defined VAR_37\n        if (VAR_12->first_packet || timesisset(&VAR_0->nap)) {\n            wake_send_queues(VAR_12, VAR_6);\n            VAR_12->first_packet = false;\n        }\n#endif\n        /* COMMENT_39 */\n        if ((VAR_21 > 0 && (COUNTER)TIMEVAL_TO_MICROSEC(&VAR_4) > VAR_21) ||\n                /* COMMENT_40 */\n                (VAR_9 > 0 && VAR_7->pkts_sent >= VAR_9)) {\n            VAR_0->abort = true;\n        }\n    } /* COMMENT_41 */\n\n\n#ifdef VAR_37\n    /* COMMENT_42 */\n    if (VAR_6->netmap && (VAR_0->abort || VAR_6->loop == 1)) {\n        while (VAR_0->intf1 && !netmap_tx_queues_empty(VAR_0->intf1)) {\n            VAR_26 = true;\n            gettimeofday(&VAR_4, NULL);\n        }\n\n        while (VAR_0->intf2 && !netmap_tx_queues_empty(VAR_0->intf2)) {\n            VAR_26 = true;\n            gettimeofday(&VAR_4, NULL);\n        }\n    }\n#endif /* COMMENT_43 */\n\n    if (!VAR_26)\n        gettimeofday(&VAR_4, NULL);\n\n    TIMEVAL_SET(&VAR_7->end_time, &VAR_4);\n\n    increment_iteration(VAR_0);\n}",
  "func_graph_path_before": "appneta/tcpreplay/21cce6b1d63a4b431fdc5f239cd23cb7a80d514f/send_packets.c/vul/before/0.json",
  "func": "void\nsend_packets(tcpreplay_t *ctx, pcap_t *pcap, int idx)\n{\n\n    struct timeval print_delta, now, last_pkt_ts;\n    tcpreplay_opt_t *options = ctx->options;\n    tcpreplay_stats_t *stats = &ctx->stats;\n    COUNTER packetnum = 0;\n    COUNTER limit_send = options->limit_send;\n    struct pcap_pkthdr pkthdr;\n    u_char *pktdata = NULL;\n    sendpacket_t *sp = ctx->intf1;\n    COUNTER pktlen;\n    packet_cache_t *cached_packet = NULL;\n    packet_cache_t **prev_packet = NULL;\n#if defined TCPREPLAY && defined TCPREPLAY_EDIT\n    struct pcap_pkthdr *pkthdr_ptr;\n#endif\n    int datalink = options->file_cache[idx].dlt;\n    COUNTER skip_length = 0;\n    COUNTER end_us;\n    bool preload = options->file_cache[idx].cached;\n    bool top_speed = (options->speed.mode == speed_topspeed ||\n            (options->speed.mode == speed_mbpsrate && options->speed.speed == 0));\n    bool now_is_now = true;\n\n    gettimeofday(&now, NULL);\n    if (!timerisset(&stats->start_time)) {\n        TIMEVAL_SET(&stats->start_time, &now);\n        if (ctx->options->stats >= 0) {\n            char buf[64];\n            if (format_date_time(&stats->start_time, buf, sizeof(buf)) > 0)\n                printf(\"Test start: %s ...\\n\", buf);\n        }\n    }\n\n    ctx->skip_packets = 0;\n    timerclear(&last_pkt_ts);\n    if (options->limit_time > 0)\n        end_us = TIMEVAL_TO_MICROSEC(&stats->start_time) +\n            SEC_TO_MICROSEC(options->limit_time);\n    else\n        end_us = 0;\n\n    if (options->preload_pcap) {\n        prev_packet = &cached_packet;\n    } else {\n        prev_packet = NULL;\n    }\n\n    /* MAIN LOOP \n     * Keep sending while we have packets or until\n     * we've sent enough packets\n     */\n    while (!ctx->abort &&\n            (pktdata = get_next_packet(ctx, pcap, &pkthdr, idx, prev_packet)) != NULL) {\n\n        now_is_now = false;\n        packetnum++;\n#if defined TCPREPLAY || defined TCPREPLAY_EDIT\n        /* do we use the snaplen (caplen) or the \"actual\" packet len? */\n        pktlen = options->use_pkthdr_len ? (COUNTER)pkthdr.len : (COUNTER)pkthdr.caplen;\n#elif TCPBRIDGE\n        pktlen = (COUNTER)pkthdr.caplen;\n#else\n#error WTF???  We should not be here!\n#endif\n\n        dbgx(2, \"packet \" COUNTER_SPEC \" caplen \" COUNTER_SPEC, packetnum, pktlen);\n\n        /* Dual nic processing */\n        if (ctx->intf2 != NULL) {\n            sp = (sendpacket_t *)cache_mode(ctx, options->cachedata, packetnum);\n\n            /* sometimes we should not send the packet */\n            if (sp == TCPR_DIR_NOSEND)\n                continue;\n        }\n\n#if defined TCPREPLAY && defined TCPREPLAY_EDIT\n        pkthdr_ptr = &pkthdr;\n        if (tcpedit_packet(tcpedit, &pkthdr_ptr, &pktdata, sp->cache_dir) == -1) {\n            errx(-1, \"Error editing packet #\" COUNTER_SPEC \": %s\", packetnum, tcpedit_geterr(tcpedit));\n        }\n        pktlen = options->use_pkthdr_len ? (COUNTER)pkthdr_ptr->len : (COUNTER)pkthdr_ptr->caplen;\n#endif\n\n        if (ctx->options->unique_ip && ctx->unique_iteration &&\n                ctx->unique_iteration > ctx->last_unique_iteration) {\n            /* edit packet to ensure every pass has unique IP addresses */\n            if (fast_edit_packet(&pkthdr, &pktdata, ctx->unique_iteration - 1,\n                    preload, datalink) == -1) {\n                ++stats->failed;\n                continue;\n            }\n        }\n\n        /* update flow stats */\n        if (options->flow_stats && !preload)\n            update_flow_stats(ctx,\n                    options->cache_packets ? sp : NULL, &pkthdr, pktdata, datalink);\n\n        /*\n         * this accelerator improves performance by avoiding expensive\n         * time stamps during periods where we have fallen behind in our\n         * sending\n         */\n        if (skip_length && pktlen < skip_length) {\n            skip_length -= pktlen;\n        } else if (ctx->skip_packets) {\n            --ctx->skip_packets;\n        } else {\n            /*\n             * time stamping is expensive, but now is the\n             * time to do it.\n             */\n            dbgx(4, \"This packet time: \" TIMEVAL_FORMAT, pkthdr.ts.tv_sec,\n                    pkthdr.ts.tv_usec);\n            skip_length = 0;\n            ctx->skip_packets = 0;\n\n            if (options->speed.mode == speed_multiplier) {\n                if (!timerisset(&last_pkt_ts)) {\n                    TIMEVAL_SET(&last_pkt_ts, &pkthdr.ts);\n                } else if (timercmp(&pkthdr.ts, &last_pkt_ts, >)) {\n                    struct timeval delta;\n\n                    timersub(&pkthdr.ts, &last_pkt_ts, &delta);\n                    timeradd(&stats->pkt_ts_delta, &delta, &stats->pkt_ts_delta);\n                    TIMEVAL_SET(&last_pkt_ts, &pkthdr.ts);\n                }\n\n                if (!timerisset(&stats->time_delta))\n                    TIMEVAL_SET(&stats->pkt_ts_delta, &stats->pkt_ts_delta);\n            }\n\n            if (!top_speed) {\n                now_is_now = true;\n                gettimeofday(&now, NULL);\n            }\n\n            /*\n             * Only if the current packet is not late.\n             *\n             * This also sets skip_length and skip_packets which will avoid\n             * timestamping for a given number of packets.\n             */\n            calc_sleep_time(ctx, &stats->pkt_ts_delta, &stats->time_delta,\n                    pktlen, sp, packetnum, &stats->end_time,\n                    TIMEVAL_TO_MICROSEC(&stats->start_time), &skip_length);\n\n            /*\n             * Track the time of the \"last packet sent\".\n             *\n             * A number of 3rd party tools generate bad timestamps which go backwards\n             * in time.  Hence, don't update the \"last\" unless pkthdr.ts > last\n             */\n            if (timercmp(&stats->time_delta, &stats->pkt_ts_delta, <))\n                TIMEVAL_SET(&stats->time_delta, &stats->pkt_ts_delta);\n\n            /*\n             * we know how long to sleep between sends, now do it.\n             */\n            if (!top_speed)\n                tcpr_sleep(ctx, sp, &ctx->nap, &now);\n        }\n\n#ifdef ENABLE_VERBOSE\n        /* do we need to print the packet via tcpdump? */\n        if (options->verbose)\n            tcpdump_print(options->tcpdump, &pkthdr, pktdata);\n#endif\n\n        dbgx(2, \"Sending packet #\" COUNTER_SPEC, packetnum);\n        /* write packet out on network */\n        if (sendpacket(sp, pktdata, pktlen, &pkthdr) < (int)pktlen) {\n            warnx(\"Unable to send packet: %s\", sendpacket_geterr(sp));\n            break;\n        }\n\n        /*\n         * Mark the time when we sent the last packet\n         */\n        TIMEVAL_SET(&stats->end_time, &now);\n\n#ifdef TIMESTAMP_TRACE\n        add_timestamp_trace_entry(pktlen, &stats->end_time, skip_length);\n#endif\n\n        stats->pkts_sent++;\n        stats->bytes_sent += pktlen;\n\n        /* print stats during the run? */\n        if (options->stats > 0) {\n            if (! timerisset(&stats->last_print)) {\n                TIMEVAL_SET(&stats->last_print, &now);\n            } else {\n                timersub(&now, &stats->last_print, &print_delta);\n                if (print_delta.tv_sec >= options->stats) {\n                    TIMEVAL_SET(&stats->end_time, &now);\n                    packet_stats(stats);\n                    TIMEVAL_SET(&stats->last_print, &now);\n                }\n            }\n        }\n\n#if defined HAVE_NETMAP\n        if (sp->first_packet || timesisset(&ctx->nap)) {\n            wake_send_queues(sp, options);\n            sp->first_packet = false;\n        }\n#endif\n        /* stop sending based on the duration limit... */\n        if ((end_us > 0 && (COUNTER)TIMEVAL_TO_MICROSEC(&now) > end_us) ||\n                /* ... or stop sending based on the limit -L? */\n                (limit_send > 0 && stats->pkts_sent >= limit_send)) {\n            ctx->abort = true;\n        }\n    } /* while */\n\n\n#ifdef HAVE_NETMAP\n    /* when completing test, wait until the last packet is sent */\n    if (options->netmap && (ctx->abort || options->loop == 1)) {\n        while (ctx->intf1 && !netmap_tx_queues_empty(ctx->intf1)) {\n            now_is_now = true;\n            gettimeofday(&now, NULL);\n        }\n\n        while (ctx->intf2 && !netmap_tx_queues_empty(ctx->intf2)) {\n            now_is_now = true;\n            gettimeofday(&now, NULL);\n        }\n    }\n#endif /* HAVE_NETMAP */\n\n    if (!now_is_now)\n        gettimeofday(&now, NULL);\n\n    TIMEVAL_SET(&stats->end_time, &now);\n\n    increment_iteration(ctx);\n}",
  "abstract_func": "void\nsend_packets(tcpreplay_t *VAR_0, pcap_t *VAR_1, int VAR_2)\n{\n\n    struct timeval VAR_3, VAR_4, VAR_5;\n    tcpreplay_opt_t *VAR_6 = VAR_0->options;\n    tcpreplay_stats_t *VAR_7 = &VAR_0->stats;\n    COUNTER VAR_8 = 0;\n    COUNTER VAR_9 = VAR_6->limit_send;\n    struct pcap_pkthdr VAR_10;\n    u_char *VAR_11 = NULL;\n    sendpacket_t *VAR_12 = VAR_0->intf1;\n    COUNTER VAR_13;\n    packet_cache_t *VAR_14 = NULL;\n    packet_cache_t **VAR_15 = NULL;\n#if defined VAR_16 && defined VAR_17\n    struct pcap_pkthdr *VAR_18;\n#endif\n    int VAR_19 = VAR_6->file_cache[VAR_2].dlt;\n    COUNTER VAR_20 = 0;\n    COUNTER VAR_21;\n    bool VAR_22 = VAR_6->file_cache[VAR_2].cached;\n    bool VAR_23 = (VAR_6->speed.mode == VAR_24 ||\n            (VAR_6->speed.mode == VAR_25 && VAR_6->speed.speed == 0));\n    bool VAR_26 = true;\n\n    gettimeofday(&VAR_4, NULL);\n    if (!timerisset(&VAR_7->start_time)) {\n        TIMEVAL_SET(&VAR_7->start_time, &VAR_4);\n        if (VAR_0->options->stats >= 0) {\n            char VAR_27[64];\n            if (format_date_time(&VAR_7->start_time, VAR_27, sizeof(VAR_27)) > 0)\n                printf(\"Test start: %s ...\\n\", VAR_27);\n        }\n    }\n\n    VAR_0->skip_packets = 0;\n    timerclear(&VAR_5);\n    if (VAR_6->limit_time > 0)\n        VAR_21 = TIMEVAL_TO_MICROSEC(&VAR_7->start_time) +\n            SEC_TO_MICROSEC(VAR_6->limit_time);\n    else\n        VAR_21 = 0;\n\n    if (VAR_6->preload_pcap) {\n        VAR_15 = &VAR_14;\n    } else {\n        VAR_15 = NULL;\n    }\n\n    /* COMMENT_0 */\n                                                  \n                                \n       \n    while (!VAR_0->abort &&\n            (VAR_11 = get_next_packet(VAR_0, VAR_1, &VAR_10, VAR_2, VAR_15)) != NULL) {\n\n        VAR_26 = false;\n        VAR_8++;\n#if defined VAR_16 || defined VAR_17\n        /* COMMENT_4 */\n        VAR_13 = VAR_6->use_pkthdr_len ? (COUNTER)VAR_10.len : (COUNTER)VAR_10.caplen;\n#elif VAR_28\n        VAR_13 = (COUNTER)VAR_10.caplen;\n#else\n#error WTF???  We should not be here!\n#endif\n\n        dbgx(2, \"packet \" VAR_29 \" caplen \" VAR_29, VAR_8, VAR_13);\n\n        /* COMMENT_5 */\n        if (VAR_0->intf2 != NULL) {\n            VAR_12 = (sendpacket_t *)cache_mode(VAR_0, VAR_6->cachedata, VAR_8);\n\n            /* COMMENT_6 */\n            if (VAR_12 == VAR_30)\n                continue;\n        }\n\n#if defined VAR_16 && defined VAR_17\n        VAR_18 = &VAR_10;\n        if (tcpedit_packet(VAR_31, &VAR_18, &VAR_11, VAR_12->cache_dir) == -1) {\n            errx(-1, \"Error editing packet #\" VAR_29 \": %s\", VAR_8, tcpedit_geterr(VAR_31));\n        }\n        VAR_13 = VAR_6->use_pkthdr_len ? (COUNTER)VAR_18->len : (COUNTER)VAR_18->caplen;\n#endif\n\n        if (VAR_0->options->unique_ip && VAR_0->unique_iteration &&\n                VAR_0->unique_iteration > VAR_0->last_unique_iteration) {\n            /* COMMENT_7 */\n            if (fast_edit_packet(&VAR_10, &VAR_11, VAR_0->unique_iteration - 1,\n                    VAR_22, VAR_19) == -1) {\n                ++VAR_7->failed;\n                continue;\n            }\n        }\n\n        /* COMMENT_8 */\n        if (VAR_6->flow_stats && !VAR_22)\n            update_flow_stats(VAR_0,\n                    VAR_6->cache_packets ? VAR_12 : NULL, &VAR_10, VAR_11, VAR_19);\n\n        /* COMMENT_9 */\n                                                                      \n                                                                        \n                  \n           \n        if (VAR_20 && VAR_13 < VAR_20) {\n            VAR_20 -= VAR_13;\n        } else if (VAR_0->skip_packets) {\n            --VAR_0->skip_packets;\n        } else {\n            /* COMMENT_14 */\n                                                         \n                             \n               \n            dbgx(4, \"This packet time: \" VAR_32, VAR_10.ts.tv_sec,\n                    VAR_10.ts.tv_usec);\n            VAR_20 = 0;\n            VAR_0->skip_packets = 0;\n\n            if (VAR_6->speed.mode == VAR_33) {\n                if (!timerisset(&VAR_5)) {\n                    TIMEVAL_SET(&VAR_5, &VAR_10.ts);\n                } else if (timercmp(&VAR_10.ts, &VAR_5, >)) {\n                    struct timeval VAR_34;\n\n                    timersub(&VAR_10.ts, &VAR_5, &VAR_34);\n                    timeradd(&VAR_7->pkt_ts_delta, &VAR_34, &VAR_7->pkt_ts_delta);\n                    TIMEVAL_SET(&VAR_5, &VAR_10.ts);\n                }\n\n                if (!timerisset(&VAR_7->time_delta))\n                    TIMEVAL_SET(&VAR_7->pkt_ts_delta, &VAR_7->pkt_ts_delta);\n            }\n\n            if (!VAR_23) {\n                VAR_26 = true;\n                gettimeofday(&VAR_4, NULL);\n            }\n\n            /* COMMENT_18 */\n                                                      \n              \n                                                                           \n                                                          \n               \n            calc_sleep_time(VAR_0, &VAR_7->pkt_ts_delta, &VAR_7->time_delta,\n                    VAR_13, VAR_12, VAR_8, &VAR_7->end_time,\n                    TIMEVAL_TO_MICROSEC(&VAR_7->start_time), &VAR_20);\n\n            /* COMMENT_24 */\n                                                        \n              \n                                                                                     \n                                                                               \n               \n            if (timercmp(&VAR_7->time_delta, &VAR_7->pkt_ts_delta, <))\n                TIMEVAL_SET(&VAR_7->time_delta, &VAR_7->pkt_ts_delta);\n\n            /* COMMENT_30 */\n                                                                  \n               \n            if (!VAR_23)\n                tcpr_sleep(VAR_0, VAR_12, &VAR_0->nap, &VAR_4);\n        }\n\n#ifdef VAR_35\n        /* COMMENT_33 */\n        if (VAR_6->verbose)\n            tcpdump_print(VAR_6->tcpdump, &VAR_10, VAR_11);\n#endif\n\n        dbgx(2, \"Sending packet #\" VAR_29, VAR_8);\n        /* COMMENT_34 */\n        if (sendpacket(VAR_12, VAR_11, VAR_13, &VAR_10) < (int)VAR_13) {\n            warnx(\"Unable to send packet: %s\", sendpacket_geterr(VAR_12));\n            break;\n        }\n\n        /* COMMENT_35 */\n                                                     \n           \n        TIMEVAL_SET(&VAR_7->end_time, &VAR_4);\n\n#ifdef VAR_36\n        add_timestamp_trace_entry(VAR_13, &VAR_7->end_time, VAR_20);\n#endif\n\n        VAR_7->pkts_sent++;\n        VAR_7->bytes_sent += VAR_13;\n\n        /* COMMENT_38 */\n        if (VAR_6->stats > 0) {\n            if (! timerisset(&VAR_7->last_print)) {\n                TIMEVAL_SET(&VAR_7->last_print, &VAR_4);\n            } else {\n                timersub(&VAR_4, &VAR_7->last_print, &VAR_3);\n                if (VAR_3.tv_sec >= VAR_6->stats) {\n                    TIMEVAL_SET(&VAR_7->end_time, &VAR_4);\n                    packet_stats(VAR_7);\n                    TIMEVAL_SET(&VAR_7->last_print, &VAR_4);\n                }\n            }\n        }\n\n#if defined VAR_37\n        if (VAR_12->first_packet || timesisset(&VAR_0->nap)) {\n            wake_send_queues(VAR_12, VAR_6);\n            VAR_12->first_packet = false;\n        }\n#endif\n        /* COMMENT_39 */\n        if ((VAR_21 > 0 && (COUNTER)TIMEVAL_TO_MICROSEC(&VAR_4) > VAR_21) ||\n                /* COMMENT_40 */\n                (VAR_9 > 0 && VAR_7->pkts_sent >= VAR_9)) {\n            VAR_0->abort = true;\n        }\n    } /* COMMENT_41 */\n\n\n#ifdef VAR_37\n    /* COMMENT_42 */\n    if (VAR_6->netmap && (VAR_0->abort || VAR_6->loop == 1)) {\n        while (VAR_0->intf1 && !netmap_tx_queues_empty(VAR_0->intf1)) {\n            VAR_26 = true;\n            gettimeofday(&VAR_4, NULL);\n        }\n\n        while (VAR_0->intf2 && !netmap_tx_queues_empty(VAR_0->intf2)) {\n            VAR_26 = true;\n            gettimeofday(&VAR_4, NULL);\n        }\n    }\n#endif /* COMMENT_43 */\n\n    if (!VAR_26)\n        gettimeofday(&VAR_4, NULL);\n\n    TIMEVAL_SET(&VAR_7->end_time, &VAR_4);\n\n    increment_iteration(VAR_0);\n}",
  "func_graph_path": "appneta/tcpreplay/21cce6b1d63a4b431fdc5f239cd23cb7a80d514f/send_packets.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -88,8 +88,11 @@\n         if (ctx->options->unique_ip && ctx->unique_iteration &&\n                 ctx->unique_iteration > ctx->last_unique_iteration) {\n             /* edit packet to ensure every pass has unique IP addresses */\n-            fast_edit_packet(&pkthdr, &pktdata, ctx->unique_iteration - 1,\n-                    preload, datalink);\n+            if (fast_edit_packet(&pkthdr, &pktdata, ctx->unique_iteration - 1,\n+                    preload, datalink) == -1) {\n+                ++stats->failed;\n+                continue;\n+            }\n         }\n \n         /* update flow stats */",
  "diff_line_info": {
    "deleted_lines": [
      "            fast_edit_packet(&pkthdr, &pktdata, ctx->unique_iteration - 1,",
      "                    preload, datalink);"
    ],
    "added_lines": [
      "            if (fast_edit_packet(&pkthdr, &pktdata, ctx->unique_iteration - 1,",
      "                    preload, datalink) == -1) {",
      "                ++stats->failed;",
      "                continue;",
      "            }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/appneta/tcpreplay/pull/640",
  "description": {
    "pr_info": {
      "title": "Bug #620 apply get.c functions fixed in #617",
      "number": 640
    },
    "comment": [
      "Add safety and failure reporting for packet captures with\r\ncaplen too small."
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.9"
}