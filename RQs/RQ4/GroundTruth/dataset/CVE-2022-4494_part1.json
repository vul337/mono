{
  "cve_id": "CVE-2022-4494",
  "cwe_ids": [
    "CWE-22"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "bspkrs/MCPMappingViewer",
  "commit_msg": "vuln-fix: Zip Slip Vulnerability\n\nThis fixes a Zip-Slip vulnerability.\n\nThis change does one of two things. This change either\n\n1. Inserts a guard to protect against Zip Slip.\nOR\n2. Replaces `dir.getCanonicalPath().startsWith(parent.getCanonicalPath())`, which is vulnerable to partial path traversal attacks, with the more secure `dir.getCanonicalFile().toPath().startsWith(parent.getCanonicalFile().toPath())`.\n\nFor number 2, consider `\"/usr/outnot\".startsWith(\"/usr/out\")`.\nThe check is bypassed although `/outnot` is not under the `/out` directory.\nIt's important to understand that the terminating slash may be removed when using various `String` representations of the `File` object.\nFor example, on Linux, `println(new File(\"/var\"))` will print `/var`, but `println(new File(\"/var\", \"/\")` will print `/var/`;\nhowever, `println(new File(\"/var\", \"/\").getCanonicalPath())` will print `/var`.\n\nWeakness: CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nSeverity: High\nCVSSS: 7.4\nDetection: CodeQL (https://codeql.github.com/codeql-query-help/java/java-zipslip/) & OpenRewrite (https://public.moderne.io/recipes/org.openrewrite.java.security.ZipSlip)\n\nReported-by: Jonathan Leitschuh <Jonathan.Leitschuh@gmail.com>\nSigned-off-by: Jonathan Leitschuh <Jonathan.Leitschuh@gmail.com>\n\nBug-tracker: https://github.com/JLLeitschuh/security-research/issues/16\n\nCo-authored-by: Moderne <team@moderne.io>",
  "commit_hash": "6e602746c96b4756c271d080dae7d22ad804a1bd",
  "git_url": "https://github.com/bspkrs/MCPMappingViewer/commit/6e602746c96b4756c271d080dae7d22ad804a1bd",
  "file_path": "src/main/java/bspkrs/mmv/RemoteZipHandler.java",
  "func_name": "extractZip",
  "func_before": "public static void extractZip(File zipFile, File destDir) throws IOException\n    {\n        byte[] buffer = new byte[1024];\n        if (!destDir.exists())\n            destDir.mkdirs();\n\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(zipFile));\n        ZipEntry ze = zis.getNextEntry();\n        try\n        {\n            while (ze != null)\n            {\n                String fileName = ze.getName();\n                File newFile = new File(destDir, fileName);\n                if (ze.isDirectory())\n                {\n                    if (newFile.exists())\n                        deleteDirAndContents(newFile);\n                    newFile.mkdirs();\n                }\n                else\n                {\n                    if (newFile.exists())\n                        newFile.delete();\n                    if (newFile.getParentFile() != null && !newFile.getParentFile().exists())\n                        newFile.getParentFile().mkdirs();\n                    FileOutputStream fos = new FileOutputStream(newFile);\n                    int len;\n                    while ((len = zis.read(buffer)) > 0)\n                        fos.write(buffer, 0, len);\n\n                    fos.close();\n                }\n                ze = zis.getNextEntry();\n            }\n        }\n        finally\n        {\n            zis.closeEntry();\n            zis.close();\n        }\n    }",
  "abstract_func_before": "public static void extractZip(File VAR_0, File VAR_1) throws IOException\n    {\n        byte[] VAR_2 = new byte[1024];\n        if (!VAR_1.exists())\n            VAR_1.mkdirs();\n\n        ZipInputStream VAR_3 = new ZipInputStream(new FileInputStream(VAR_0));\n        ZipEntry VAR_4 = VAR_3.getNextEntry();\n        try\n        {\n            while (VAR_4 != null)\n            {\n                String VAR_5 = VAR_4.getName();\n                File VAR_6 = new File(VAR_1, VAR_5);\n                if (VAR_4.isDirectory())\n                {\n                    if (VAR_6.exists())\n                        deleteDirAndContents(VAR_6);\n                    VAR_6.mkdirs();\n                }\n                else\n                {\n                    if (VAR_6.exists())\n                        VAR_6.delete();\n                    if (VAR_6.getParentFile() != null && !VAR_6.getParentFile().exists())\n                        VAR_6.getParentFile().mkdirs();\n                    FileOutputStream VAR_7 = new FileOutputStream(VAR_6);\n                    int VAR_8;\n                    while ((VAR_8 = VAR_3.read(VAR_2)) > 0)\n                        VAR_7.write(VAR_2, 0, VAR_8);\n\n                    VAR_7.close();\n                }\n                VAR_4 = VAR_3.getNextEntry();\n            }\n        }\n        finally\n        {\n            VAR_3.closeEntry();\n            VAR_3.close();\n        }\n    }",
  "func_graph_path_before": "bspkrs/MCPMappingViewer/6e602746c96b4756c271d080dae7d22ad804a1bd/RemoteZipHandler.java/vul/before/0.json",
  "func": "public static void extractZip(File zipFile, File destDir) throws IOException\n    {\n        byte[] buffer = new byte[1024];\n        if (!destDir.exists())\n            destDir.mkdirs();\n\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(zipFile));\n        ZipEntry ze = zis.getNextEntry();\n        try\n        {\n            while (ze != null)\n            {\n                String fileName = ze.getName();\n                File newFile = new File(destDir, fileName);\n                if (!newFile.toPath().normalize().startsWith(destDir.toPath().normalize())) {\n                    throw new IOException(\"Bad zip entry\");\n                }\n                if (ze.isDirectory())\n                {\n                    if (newFile.exists())\n                        deleteDirAndContents(newFile);\n                    newFile.mkdirs();\n                }\n                else\n                {\n                    if (newFile.exists())\n                        newFile.delete();\n                    if (newFile.getParentFile() != null && !newFile.getParentFile().exists())\n                        newFile.getParentFile().mkdirs();\n                    FileOutputStream fos = new FileOutputStream(newFile);\n                    int len;\n                    while ((len = zis.read(buffer)) > 0)\n                        fos.write(buffer, 0, len);\n\n                    fos.close();\n                }\n                ze = zis.getNextEntry();\n            }\n        }\n        finally\n        {\n            zis.closeEntry();\n            zis.close();\n        }\n    }",
  "abstract_func": "public static void extractZip(File VAR_0, File VAR_1) throws IOException\n    {\n        byte[] VAR_2 = new byte[1024];\n        if (!VAR_1.exists())\n            VAR_1.mkdirs();\n\n        ZipInputStream VAR_3 = new ZipInputStream(new FileInputStream(VAR_0));\n        ZipEntry VAR_4 = VAR_3.getNextEntry();\n        try\n        {\n            while (VAR_4 != null)\n            {\n                String VAR_5 = VAR_4.getName();\n                File VAR_6 = new File(VAR_1, VAR_5);\n                if (!VAR_6.toPath().normalize().startsWith(VAR_1.toPath().normalize())) {\n                    throw new IOException(\"Bad zip entry\");\n                }\n                if (VAR_4.isDirectory())\n                {\n                    if (VAR_6.exists())\n                        deleteDirAndContents(VAR_6);\n                    VAR_6.mkdirs();\n                }\n                else\n                {\n                    if (VAR_6.exists())\n                        VAR_6.delete();\n                    if (VAR_6.getParentFile() != null && !VAR_6.getParentFile().exists())\n                        VAR_6.getParentFile().mkdirs();\n                    FileOutputStream VAR_7 = new FileOutputStream(VAR_6);\n                    int VAR_8;\n                    while ((VAR_8 = VAR_3.read(VAR_2)) > 0)\n                        VAR_7.write(VAR_2, 0, VAR_8);\n\n                    VAR_7.close();\n                }\n                VAR_4 = VAR_3.getNextEntry();\n            }\n        }\n        finally\n        {\n            VAR_3.closeEntry();\n            VAR_3.close();\n        }\n    }",
  "func_graph_path": "bspkrs/MCPMappingViewer/6e602746c96b4756c271d080dae7d22ad804a1bd/RemoteZipHandler.java/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -12,6 +12,9 @@\n             {\n                 String fileName = ze.getName();\n                 File newFile = new File(destDir, fileName);\n+                if (!newFile.toPath().normalize().startsWith(destDir.toPath().normalize())) {\n+                    throw new IOException(\"Bad zip entry\");\n+                }\n                 if (ze.isDirectory())\n                 {\n                     if (newFile.exists())",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "                if (!newFile.toPath().normalize().startsWith(destDir.toPath().normalize())) {",
      "                    throw new IOException(\"Bad zip entry\");",
      "                }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/bspkrs/MCPMappingViewer/pull/34",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/bspkrs/MCPMappingViewer/pull/34: 403 Client Error: Forbidden for url: https://api.github.com/repos/bspkrs/MCPMappingViewer/pulls/34",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0  \n\nThe patch is designed to fix the Zip Slip vulnerability, a known security issue. It adds a secure check to prevent file extraction outside the intended directory, aligning with the commit message and vulnerability description. The code changes directly address the security concern with clear and relevant fixes."
}