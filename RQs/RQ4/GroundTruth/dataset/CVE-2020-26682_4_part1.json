{
  "cve_id": "CVE-2020-26682",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "libass",
  "commit_msg": "outline: fix overflows in outline processing\n\nThis commit enforces strict invariant on ASS_Outline\nto contain point coordinates into predetermined range.\n\nFixes https://github.com/libass/libass/issues/431.",
  "commit_hash": "676f9dc5b52ef406c5527bdadbcb947f11392929",
  "git_url": "https://github.com/libass/libass/commit/676f9dc5b52ef406c5527bdadbcb947f11392929",
  "file_path": "libass/ass_outline.c",
  "func_name": "outline_scale_pow2",
  "func_before": "bool outline_scale_pow2(ASS_Outline *outline, const ASS_Outline *source,\n                        int scale_ord_x, int scale_ord_y)\n{\n    if (!source || !source->n_points) {\n        outline_clear(outline);\n        return true;\n    }\n\n    if (!outline_alloc(outline, source->n_points, source->n_segments))\n        return false;\n\n    int sx = scale_ord_x + 32;\n    int sy = scale_ord_y + 32;\n    const ASS_Vector *pt = source->points;\n    for (size_t i = 0; i < source->n_points; i++) {\n        // that's equivalent to pt[i].x << scale_ord_x,\n        // but works even for negative coordinate and/or shift amount\n        outline->points[i].x = pt[i].x * ((int64_t) 1 << sx) >> 32;\n        outline->points[i].y = pt[i].y * ((int64_t) 1 << sy) >> 32;\n    }\n    memcpy(outline->segments, source->segments, source->n_segments);\n    outline->n_points = source->n_points;\n    outline->n_segments = source->n_segments;\n    return true;\n}",
  "abstract_func_before": "bool outline_scale_pow2(ASS_Outline *VAR_0, const ASS_Outline *VAR_1,\n                        int VAR_2, int VAR_3)\n{\n    if (!VAR_1 || !VAR_1->n_points) {\n        outline_clear(VAR_0);\n        return true;\n    }\n\n    if (!outline_alloc(VAR_0, VAR_1->n_points, VAR_1->n_segments))\n        return false;\n\n    int VAR_4 = VAR_2 + 32;\n    int VAR_5 = VAR_3 + 32;\n    const ASS_Vector *VAR_6 = VAR_1->points;\n    for (size_t VAR_7 = 0; VAR_7 < VAR_1->n_points; VAR_7++) {\n        /* COMMENT_0 */\n        /* COMMENT_1 */\n        VAR_0->points[VAR_7].x = VAR_6[VAR_7].x * ((int64_t) 1 << VAR_4) >> 32;\n        VAR_0->points[VAR_7].y = VAR_6[VAR_7].y * ((int64_t) 1 << VAR_5) >> 32;\n    }\n    memcpy(VAR_0->segments, VAR_1->segments, VAR_1->n_segments);\n    VAR_0->n_points = VAR_1->n_points;\n    VAR_0->n_segments = VAR_1->n_segments;\n    return true;\n}",
  "func_graph_path_before": "libass/676f9dc5b52ef406c5527bdadbcb947f11392929/ass_outline.c/vul/before/5.json",
  "func": "bool outline_scale_pow2(ASS_Outline *outline, const ASS_Outline *source,\n                        int scale_ord_x, int scale_ord_y)\n{\n    if (!source || !source->n_points) {\n        outline_clear(outline);\n        return true;\n    }\n\n    int32_t lim_x = OUTLINE_MAX;\n    if (scale_ord_x > 0)\n        lim_x = scale_ord_x < 32 ? lim_x >> scale_ord_x : 0;\n    else\n        scale_ord_x = FFMAX(scale_ord_x, -32);\n\n    int32_t lim_y = OUTLINE_MAX;\n    if (scale_ord_y > 0)\n        lim_y = scale_ord_y < 32 ? lim_y >> scale_ord_y : 0;\n    else\n        scale_ord_y = FFMAX(scale_ord_y, -32);\n\n    if (!lim_x || !lim_y) {\n        outline_clear(outline);\n        return false;\n    }\n\n    if (!outline_alloc(outline, source->n_points, source->n_segments))\n        return false;\n\n    int sx = scale_ord_x + 32;\n    int sy = scale_ord_y + 32;\n    const ASS_Vector *pt = source->points;\n    for (size_t i = 0; i < source->n_points; i++) {\n        if (abs(pt[i].x) > lim_x || abs(pt[i].y) > lim_y) {\n            outline_free(outline);\n            return false;\n        }\n        // that's equivalent to pt[i].x << scale_ord_x,\n        // but works even for negative coordinate and/or shift amount\n        outline->points[i].x = pt[i].x * ((int64_t) 1 << sx) >> 32;\n        outline->points[i].y = pt[i].y * ((int64_t) 1 << sy) >> 32;\n    }\n    memcpy(outline->segments, source->segments, source->n_segments);\n    outline->n_points = source->n_points;\n    outline->n_segments = source->n_segments;\n    return true;\n}",
  "abstract_func": "bool outline_scale_pow2(ASS_Outline *VAR_0, const ASS_Outline *VAR_1,\n                        int VAR_2, int VAR_3)\n{\n    if (!VAR_1 || !VAR_1->n_points) {\n        outline_clear(VAR_0);\n        return true;\n    }\n\n    int32_t VAR_4 = VAR_5;\n    if (VAR_2 > 0)\n        VAR_4 = VAR_2 < 32 ? VAR_4 >> VAR_2 : 0;\n    else\n        VAR_2 = FFMAX(VAR_2, -32);\n\n    int32_t VAR_6 = VAR_5;\n    if (VAR_3 > 0)\n        VAR_6 = VAR_3 < 32 ? VAR_6 >> VAR_3 : 0;\n    else\n        VAR_3 = FFMAX(VAR_3, -32);\n\n    if (!VAR_4 || !VAR_6) {\n        outline_clear(VAR_0);\n        return false;\n    }\n\n    if (!outline_alloc(VAR_0, VAR_1->n_points, VAR_1->n_segments))\n        return false;\n\n    int VAR_7 = VAR_2 + 32;\n    int VAR_8 = VAR_3 + 32;\n    const ASS_Vector *VAR_9 = VAR_1->points;\n    for (size_t VAR_10 = 0; VAR_10 < VAR_1->n_points; VAR_10++) {\n        if (abs(VAR_9[VAR_10].x) > VAR_4 || abs(VAR_9[VAR_10].y) > VAR_6) {\n            outline_free(VAR_0);\n            return false;\n        }\n        /* COMMENT_0 */\n        /* COMMENT_1 */\n        VAR_0->points[VAR_10].x = VAR_9[VAR_10].x * ((int64_t) 1 << VAR_7) >> 32;\n        VAR_0->points[VAR_10].y = VAR_9[VAR_10].y * ((int64_t) 1 << VAR_8) >> 32;\n    }\n    memcpy(VAR_0->segments, VAR_1->segments, VAR_1->n_segments);\n    VAR_0->n_points = VAR_1->n_points;\n    VAR_0->n_segments = VAR_1->n_segments;\n    return true;\n}",
  "func_graph_path": "libass/676f9dc5b52ef406c5527bdadbcb947f11392929/ass_outline.c/vul/after/5.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,23 @@\n     if (!source || !source->n_points) {\n         outline_clear(outline);\n         return true;\n+    }\n+\n+    int32_t lim_x = OUTLINE_MAX;\n+    if (scale_ord_x > 0)\n+        lim_x = scale_ord_x < 32 ? lim_x >> scale_ord_x : 0;\n+    else\n+        scale_ord_x = FFMAX(scale_ord_x, -32);\n+\n+    int32_t lim_y = OUTLINE_MAX;\n+    if (scale_ord_y > 0)\n+        lim_y = scale_ord_y < 32 ? lim_y >> scale_ord_y : 0;\n+    else\n+        scale_ord_y = FFMAX(scale_ord_y, -32);\n+\n+    if (!lim_x || !lim_y) {\n+        outline_clear(outline);\n+        return false;\n     }\n \n     if (!outline_alloc(outline, source->n_points, source->n_segments))\n@@ -13,6 +30,10 @@\n     int sy = scale_ord_y + 32;\n     const ASS_Vector *pt = source->points;\n     for (size_t i = 0; i < source->n_points; i++) {\n+        if (abs(pt[i].x) > lim_x || abs(pt[i].y) > lim_y) {\n+            outline_free(outline);\n+            return false;\n+        }\n         // that's equivalent to pt[i].x << scale_ord_x,\n         // but works even for negative coordinate and/or shift amount\n         outline->points[i].x = pt[i].x * ((int64_t) 1 << sx) >> 32;",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "    }",
      "",
      "    int32_t lim_x = OUTLINE_MAX;",
      "    if (scale_ord_x > 0)",
      "        lim_x = scale_ord_x < 32 ? lim_x >> scale_ord_x : 0;",
      "    else",
      "        scale_ord_x = FFMAX(scale_ord_x, -32);",
      "",
      "    int32_t lim_y = OUTLINE_MAX;",
      "    if (scale_ord_y > 0)",
      "        lim_y = scale_ord_y < 32 ? lim_y >> scale_ord_y : 0;",
      "    else",
      "        scale_ord_y = FFMAX(scale_ord_y, -32);",
      "",
      "    if (!lim_x || !lim_y) {",
      "        outline_clear(outline);",
      "        return false;",
      "        if (abs(pt[i].x) > lim_x || abs(pt[i].y) > lim_y) {",
      "            outline_free(outline);",
      "            return false;",
      "        }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libass/libass/pull/432",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/libass/libass/pull/432: 403 Client Error: Forbidden for url: https://api.github.com/repos/libass/libass/pulls/432",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95"
}