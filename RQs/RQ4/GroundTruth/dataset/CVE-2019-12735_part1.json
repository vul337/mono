{
  "cve_id": "CVE-2019-12735",
  "cwe_ids": [
    "CWE-78"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:C/I:C/A:C",
  "cvss_is_v3": false,
  "repo_name": "neovim",
  "commit_msg": "vim-patch:8.1.1365: source command doesn't check for the sandbox\n\nProblem:    Source command doesn't check for the sandbox. (Armin Razmjou)\nSolution:   Check for the sandbox when sourcing a file.\nhttps://github.com/vim/vim/commit/53575521406739cf20bbe4e384d88e7dca11f040",
  "commit_hash": "5e611f32841e746932fbcbea292ca502ed9e694b",
  "git_url": "https://github.com/neovim/neovim/commit/5e611f32841e746932fbcbea292ca502ed9e694b",
  "file_path": "src/nvim/getchar.c",
  "func_name": "openscript",
  "func_before": "void \nopenscript (\n    char_u *name,\n    int directly                   /* when TRUE execute directly */\n)\n{\n  if (curscript + 1 == NSCRIPT) {\n    EMSG(_(e_nesting));\n    return;\n  }\n  if (ignore_script)\n    /* Not reading from script, also don't open one.  Warning message? */\n    return;\n\n  if (scriptin[curscript] != NULL)      /* already reading script */\n    ++curscript;\n  /* use NameBuff for expanded name */\n  expand_env(name, NameBuff, MAXPATHL);\n  int error;\n  if ((scriptin[curscript] = file_open_new(&error, (char *)NameBuff,\n                                           kFileReadOnly, 0)) == NULL) {\n    emsgf(_(e_notopen_2), name, os_strerror(error));\n    if (curscript) {\n      curscript--;\n    }\n    return;\n  }\n  save_typebuf();\n\n  /*\n   * Execute the commands from the file right now when using \":source!\"\n   * after \":global\" or \":argdo\" or in a loop.  Also when another command\n   * follows.  This means the display won't be updated.  Don't do this\n   * always, \"make test\" would fail.\n   */\n  if (directly) {\n    oparg_T oa;\n    int oldcurscript;\n    int save_State = State;\n    int save_restart_edit = restart_edit;\n    int save_insertmode = p_im;\n    int save_finish_op = finish_op;\n    int save_msg_scroll = msg_scroll;\n\n    State = NORMAL;\n    msg_scroll = FALSE;         /* no msg scrolling in Normal mode */\n    restart_edit = 0;           /* don't go to Insert mode */\n    p_im = FALSE;               /* don't use 'insertmode' */\n    clear_oparg(&oa);\n    finish_op = FALSE;\n\n    oldcurscript = curscript;\n    do {\n      update_topline_cursor();          /* update cursor position and topline */\n      normal_cmd(&oa, FALSE);           /* execute one command */\n      vpeekc();                         /* check for end of file */\n    } while (scriptin[oldcurscript] != NULL);\n\n    State = save_State;\n    msg_scroll = save_msg_scroll;\n    restart_edit = save_restart_edit;\n    p_im = save_insertmode;\n    finish_op = save_finish_op;\n  }\n}",
  "abstract_func_before": "void \nopenscript (\n    char_u *VAR_0,\n    int VAR_1                   /* COMMENT_0 */\n)\n{\n  if (VAR_2 + 1 == VAR_3) {\n    EMSG(_(VAR_4));\n    return;\n  }\n  if (VAR_5)\n    /* COMMENT_1 */\n    return;\n\n  if (VAR_6[VAR_2] != NULL)      /* COMMENT_2 */\n    ++VAR_2;\n  /* COMMENT_3 */\n  expand_env(VAR_0, VAR_7, VAR_8);\n  int VAR_9;\n  if ((VAR_6[VAR_2] = file_open_new(&VAR_9, (char *)VAR_7,\n                                           VAR_10, 0)) == NULL) {\n    emsgf(_(VAR_11), VAR_0, os_strerror(VAR_9));\n    if (VAR_2) {\n      VAR_2--;\n    }\n    return;\n  }\n  save_typebuf();\n\n  /* COMMENT_4 */\n                                                                       \n                                                                         \n                                                                      \n                                    \n     \n  if (VAR_1) {\n    oparg_T VAR_12;\n    int VAR_13;\n    int VAR_14 = VAR_15;\n    int VAR_16 = VAR_17;\n    int VAR_18 = VAR_19;\n    int VAR_20 = VAR_21;\n    int VAR_22 = VAR_23;\n\n    VAR_15 = VAR_24;\n    VAR_23 = FALSE;         /* COMMENT_10 */\n    VAR_17 = 0;           /* COMMENT_11 */\n    VAR_19 = FALSE;               /* COMMENT_12 */\n    clear_oparg(&VAR_12);\n    VAR_21 = FALSE;\n\n    VAR_13 = VAR_2;\n    do {\n      update_topline_cursor();          /* COMMENT_13 */\n      normal_cmd(&VAR_12, FALSE);           /* COMMENT_14 */\n      vpeekc();                         /* COMMENT_15 */\n    } while (VAR_6[VAR_13] != NULL);\n\n    VAR_15 = VAR_14;\n    VAR_23 = VAR_22;\n    VAR_17 = VAR_16;\n    VAR_19 = VAR_18;\n    VAR_21 = VAR_20;\n  }\n}",
  "func_graph_path_before": "neovim/5e611f32841e746932fbcbea292ca502ed9e694b/getchar.c/vul/before/0.json",
  "func": "void \nopenscript (\n    char_u *name,\n    int directly                   /* when TRUE execute directly */\n)\n{\n  if (curscript + 1 == NSCRIPT) {\n    EMSG(_(e_nesting));\n    return;\n  }\n\n  // Disallow sourcing a file in the sandbox, the commands would be executed\n  // later, possibly outside of the sandbox.\n  if (check_secure()) {\n    return;\n  }\n\n  if (ignore_script)\n    /* Not reading from script, also don't open one.  Warning message? */\n    return;\n\n  if (scriptin[curscript] != NULL)      /* already reading script */\n    ++curscript;\n  /* use NameBuff for expanded name */\n  expand_env(name, NameBuff, MAXPATHL);\n  int error;\n  if ((scriptin[curscript] = file_open_new(&error, (char *)NameBuff,\n                                           kFileReadOnly, 0)) == NULL) {\n    emsgf(_(e_notopen_2), name, os_strerror(error));\n    if (curscript) {\n      curscript--;\n    }\n    return;\n  }\n  save_typebuf();\n\n  /*\n   * Execute the commands from the file right now when using \":source!\"\n   * after \":global\" or \":argdo\" or in a loop.  Also when another command\n   * follows.  This means the display won't be updated.  Don't do this\n   * always, \"make test\" would fail.\n   */\n  if (directly) {\n    oparg_T oa;\n    int oldcurscript;\n    int save_State = State;\n    int save_restart_edit = restart_edit;\n    int save_insertmode = p_im;\n    int save_finish_op = finish_op;\n    int save_msg_scroll = msg_scroll;\n\n    State = NORMAL;\n    msg_scroll = FALSE;         /* no msg scrolling in Normal mode */\n    restart_edit = 0;           /* don't go to Insert mode */\n    p_im = FALSE;               /* don't use 'insertmode' */\n    clear_oparg(&oa);\n    finish_op = FALSE;\n\n    oldcurscript = curscript;\n    do {\n      update_topline_cursor();          /* update cursor position and topline */\n      normal_cmd(&oa, FALSE);           /* execute one command */\n      vpeekc();                         /* check for end of file */\n    } while (scriptin[oldcurscript] != NULL);\n\n    State = save_State;\n    msg_scroll = save_msg_scroll;\n    restart_edit = save_restart_edit;\n    p_im = save_insertmode;\n    finish_op = save_finish_op;\n  }\n}",
  "abstract_func": "void \nopenscript (\n    char_u *VAR_0,\n    int VAR_1                   /* COMMENT_0 */\n)\n{\n  if (VAR_2 + 1 == VAR_3) {\n    EMSG(_(VAR_4));\n    return;\n  }\n\n  /* COMMENT_1 */\n  /* COMMENT_2 */\n  if (check_secure()) {\n    return;\n  }\n\n  if (VAR_5)\n    /* COMMENT_3 */\n    return;\n\n  if (VAR_6[VAR_2] != NULL)      /* COMMENT_4 */\n    ++VAR_2;\n  /* COMMENT_5 */\n  expand_env(VAR_0, VAR_7, VAR_8);\n  int VAR_9;\n  if ((VAR_6[VAR_2] = file_open_new(&VAR_9, (char *)VAR_7,\n                                           VAR_10, 0)) == NULL) {\n    emsgf(_(VAR_11), VAR_0, os_strerror(VAR_9));\n    if (VAR_2) {\n      VAR_2--;\n    }\n    return;\n  }\n  save_typebuf();\n\n  /* COMMENT_6 */\n                                                                       \n                                                                         \n                                                                      \n                                    \n     \n  if (VAR_1) {\n    oparg_T VAR_12;\n    int VAR_13;\n    int VAR_14 = VAR_15;\n    int VAR_16 = VAR_17;\n    int VAR_18 = VAR_19;\n    int VAR_20 = VAR_21;\n    int VAR_22 = VAR_23;\n\n    VAR_15 = VAR_24;\n    VAR_23 = FALSE;         /* COMMENT_12 */\n    VAR_17 = 0;           /* COMMENT_13 */\n    VAR_19 = FALSE;               /* COMMENT_14 */\n    clear_oparg(&VAR_12);\n    VAR_21 = FALSE;\n\n    VAR_13 = VAR_2;\n    do {\n      update_topline_cursor();          /* COMMENT_15 */\n      normal_cmd(&VAR_12, FALSE);           /* COMMENT_16 */\n      vpeekc();                         /* COMMENT_17 */\n    } while (VAR_6[VAR_13] != NULL);\n\n    VAR_15 = VAR_14;\n    VAR_23 = VAR_22;\n    VAR_17 = VAR_16;\n    VAR_19 = VAR_18;\n    VAR_21 = VAR_20;\n  }\n}",
  "func_graph_path": "neovim/5e611f32841e746932fbcbea292ca502ed9e694b/getchar.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -8,6 +8,13 @@\n     EMSG(_(e_nesting));\n     return;\n   }\n+\n+  // Disallow sourcing a file in the sandbox, the commands would be executed\n+  // later, possibly outside of the sandbox.\n+  if (check_secure()) {\n+    return;\n+  }\n+\n   if (ignore_script)\n     /* Not reading from script, also don't open one.  Warning message? */\n     return;",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "",
      "  // Disallow sourcing a file in the sandbox, the commands would be executed",
      "  // later, possibly outside of the sandbox.",
      "  if (check_secure()) {",
      "    return;",
      "  }",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/neovim/neovim/pull/10082",
  "description": {
    "pr_info": {
      "title": "vim-patch:8.1.1365: :source should check sandbox",
      "number": 10082
    },
    "comment": [
      "Problem:    Source command doesn't check for the sandbox. (Armin Razmjou)\r\nSolution:   Check for the sandbox when sourcing a file.\r\nhttps://github.com/vim/vim/commit/53575521406739cf20bbe4e384d88e7dca11f040\r\n\r\nref #10052",
      "No tests?",
      "This is a backport to the maintenance branch. "
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "The patch addresses a security issue by adding a sandbox check before sourcing a file, which prevents unauthorized execution. \n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9"
}