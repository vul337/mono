{
  "cve_id": "CVE-2018-10958",
  "cwe_ids": [
    "CWE-Other",
    "CWE-119"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "Exiv2/exiv2",
  "commit_msg": "Prevent SIGABRT on excessive subBox length in jp2image.cpp\n\nThis fixes CVE-2018-9145",
  "commit_hash": "d01eb9905441d773c22c1b2473967e6309573252",
  "git_url": "https://github.com/Exiv2/exiv2/commit/d01eb9905441d773c22c1b2473967e6309573252",
  "file_path": "src/jp2image.cpp",
  "func_name": "Jp2Image::printStructure",
  "func_before": "void Jp2Image::printStructure(std::ostream& out, PrintStructureOption option,int depth)\n    {\n        if (io_->open() != 0) throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n\n        // Ensure that this is the correct image type\n        if (!isJp2Type(*io_, false)) {\n            if (io_->error() || io_->eof()) throw Error(kerFailedToReadImageData);\n            throw Error(kerNotAJpeg);\n        }\n\n        bool bPrint     = option == kpsBasic || option==kpsRecursive;\n        bool bRecursive = option == kpsRecursive;\n        bool bICC       = option == kpsIccProfile;\n        bool bXMP       = option == kpsXMP;\n        bool bIPTCErase = option == kpsIptcErase;\n\n        if ( bPrint ) {\n            out << \"STRUCTURE OF JPEG2000 FILE: \" << io_->path() << std::endl;\n            out << \" address |   length | box       | data\" << std::endl ;\n        }\n\n        if ( bPrint || bXMP || bICC || bIPTCErase ) {\n\n            long              position  = 0;\n            Jp2BoxHeader      box       = {1,1};\n            Jp2BoxHeader      subBox    = {1,1};\n            Jp2UuidBox        uuid      = {{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}};\n            bool              bLF       = false;\n\n            while (box.length && box.type != kJp2BoxTypeClose && io_->read((byte*)&box, sizeof(box)) == sizeof(box))\n            {\n                position   = io_->tell();\n                box.length = getLong((byte*)&box.length, bigEndian);\n                box.type   = getLong((byte*)&box.type, bigEndian);\n\n                if ( bPrint ) {\n                    out << Internal::stringFormat(\"%8ld | %8ld | \",position-sizeof(box),box.length) << toAscii(box.type) << \"      | \" ;\n                    bLF = true ;\n                    if ( box.type == kJp2BoxTypeClose ) lf(out,bLF);\n                }\n                if ( box.type == kJp2BoxTypeClose ) break;\n\n                switch(box.type)\n                {\n                    case kJp2BoxTypeJp2Header:\n                    {\n                        lf(out,bLF);\n\n                        while (io_->read((byte*)&subBox, sizeof(subBox)) == sizeof(subBox)\n                               && io_->tell() < position + (long) box.length) // don't read beyond the box!\n                        {\n                            int address = io_->tell() - sizeof(subBox);\n                            subBox.length = getLong((byte*)&subBox.length, bigEndian);\n                            subBox.type   = getLong((byte*)&subBox.type, bigEndian);\n\n                            DataBuf data(subBox.length-sizeof(box));\n                            io_->read(data.pData_,data.size_);\n                            if ( bPrint ) {\n                                out << Internal::stringFormat(\"%8ld | %8ld |  sub:\",address,subBox.length) << toAscii(subBox.type)\n                                <<\" | \" << Internal::binaryToString(data,30,0);\n                                bLF = true;\n                            }\n\n                            if(subBox.type == kJp2BoxTypeColorHeader)\n                            {\n                                long pad = 3 ; // don't know why there are 3 padding bytes\n                                if ( bPrint ) {\n                                    out << \" | pad:\" ;\n                                    for ( int i = 0 ; i < 3 ; i++ ) out<< \" \" << (int) data.pData_[i];\n                                }\n                                long    iccLength = getULong(data.pData_+pad, bigEndian);\n                                if ( bPrint ) {\n                                    out << \" | iccLength:\" << iccLength ;\n                                }\n                                if ( bICC ) {\n                                    out.write((const char*)data.pData_+pad,iccLength);\n                                }\n                            }\n                            lf(out,bLF);\n                        }\n                    } break;\n\n                    case kJp2BoxTypeUuid:\n                    {\n\n                        if (io_->read((byte*)&uuid, sizeof(uuid)) == sizeof(uuid))\n                        {\n                            bool    bIsExif = memcmp(uuid.uuid, kJp2UuidExif, sizeof(uuid))==0;\n                            bool    bIsIPTC = memcmp(uuid.uuid, kJp2UuidIptc, sizeof(uuid))==0;\n                            bool    bIsXMP  = memcmp(uuid.uuid, kJp2UuidXmp , sizeof(uuid))==0;\n\n                            bool    bUnknown= ! (bIsExif || bIsIPTC || bIsXMP);\n\n                            if ( bPrint ) {\n                                if ( bIsExif ) out << \"Exif: \" ;\n                                if ( bIsIPTC ) out << \"IPTC: \" ;\n                                if ( bIsXMP  ) out << \"XMP : \" ;\n                                if ( bUnknown) out << \"????: \" ;\n                            }\n\n                            DataBuf rawData;\n                            rawData.alloc(box.length-sizeof(uuid)-sizeof(box));\n                            long    bufRead = io_->read(rawData.pData_, rawData.size_);\n                            if (io_->error()) throw Error(kerFailedToReadImageData);\n                            if (bufRead != rawData.size_) throw Error(kerInputDataReadFailed);\n\n                            if ( bPrint ){\n                                out << Internal::binaryToString(rawData,40,0);\n                                out.flush();\n                            }\n                            lf(out,bLF);\n\n                            if(bIsExif && bRecursive && rawData.size_ > 0)\n                            {\n                                if ( (rawData.pData_[0]      == rawData.pData_[1])\n                                    &&   (rawData.pData_[0]=='I' || rawData.pData_[0]=='M' )\n                                    ) {\n                                    BasicIo::AutoPtr p = BasicIo::AutoPtr(new MemIo(rawData.pData_,rawData.size_));\n                                    printTiffStructure(*p,out,option,depth);\n                                }\n                            }\n\n                            if(bIsIPTC && bRecursive)\n                            {\n                                IptcData::printStructure(out,rawData.pData_,rawData.size_,depth);\n                            }\n\n                            if( bIsXMP && bXMP )\n                            {\n                                out.write((const char*)rawData.pData_,rawData.size_);\n                            }\n                        }\n                    } break;\n\n                    default: break;\n                }\n\n                // Move to the next box.\n                io_->seek(static_cast<long>(position - sizeof(box) + box.length), BasicIo::beg);\n                if (io_->error()) throw Error(kerFailedToReadImageData);\n                if ( bPrint ) lf(out,bLF);\n            }\n        }\n    }",
  "abstract_func_before": "void Jp2Image::printStructure(std::ostream& VAR_0, PrintStructureOption VAR_1,int VAR_2)\n    {\n        if (VAR_3->open() != 0) throw Error(VAR_4, VAR_3->path(), strError());\n\n        /* COMMENT_0 */\n        if (!isJp2Type(*VAR_3, false)) {\n            if (VAR_3->error() || VAR_3->eof()) throw Error(VAR_5);\n            throw Error(VAR_6);\n        }\n\n        bool VAR_7     = VAR_1 == VAR_8 || VAR_1==VAR_9;\n        bool VAR_10 = VAR_1 == VAR_9;\n        bool VAR_11       = VAR_1 == VAR_12;\n        bool VAR_13       = VAR_1 == VAR_14;\n        bool VAR_15 = VAR_1 == VAR_16;\n\n        if ( VAR_7 ) {\n            VAR_0 << \"STRUCTURE OF JPEG2000 FILE: \" << VAR_3->path() << std::endl;\n            VAR_0 << \" address |   length | box       | data\" << std::endl ;\n        }\n\n        if ( VAR_7 || VAR_13 || VAR_11 || VAR_15 ) {\n\n            long              VAR_17  = 0;\n            Jp2BoxHeader      VAR_18       = {1,1};\n            Jp2BoxHeader      VAR_19    = {1,1};\n            Jp2UuidBox        VAR_20      = {{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}};\n            bool              VAR_21       = false;\n\n            while (VAR_18.length && VAR_18.type != VAR_22 && VAR_3->read((byte*)&VAR_18, sizeof(VAR_18)) == sizeof(VAR_18))\n            {\n                VAR_17   = VAR_3->tell();\n                VAR_18.length = getLong((byte*)&VAR_18.length, VAR_23);\n                VAR_18.type   = getLong((byte*)&VAR_18.type, VAR_23);\n\n                if ( VAR_7 ) {\n                    VAR_0 << Internal::stringFormat(\"%8ld | %8ld | \",VAR_17-sizeof(VAR_18),VAR_18.length) << toAscii(VAR_18.type) << \"      | \" ;\n                    VAR_21 = true ;\n                    if ( VAR_18.type == VAR_22 ) lf(VAR_0,VAR_21);\n                }\n                if ( VAR_18.type == VAR_22 ) break;\n\n                switch(VAR_18.type)\n                {\n                    case VAR_24:\n                    {\n                        lf(VAR_0,VAR_21);\n\n                        while (VAR_3->read((byte*)&VAR_19, sizeof(VAR_19)) == sizeof(VAR_19)\n                               && VAR_3->tell() < VAR_17 + (long) VAR_18.length) /* COMMENT_1 */\n                        {\n                            int VAR_25 = VAR_3->tell() - sizeof(VAR_19);\n                            VAR_19.length = getLong((byte*)&VAR_19.length, VAR_23);\n                            VAR_19.type   = getLong((byte*)&VAR_19.type, VAR_23);\n\n                            DataBuf VAR_26(VAR_19.length-sizeof(VAR_18));\n                            VAR_3->read(VAR_26.pData_,VAR_26.size_);\n                            if ( VAR_7 ) {\n                                VAR_0 << Internal::stringFormat(\"%8ld | %8ld |  sub:\",VAR_25,VAR_19.length) << toAscii(VAR_19.type)\n                                <<\" | \" << Internal::binaryToString(VAR_26,30,0);\n                                VAR_21 = true;\n                            }\n\n                            if(VAR_19.type == VAR_27)\n                            {\n                                long VAR_28 = 3 ; /* COMMENT_2 */\n                                if ( VAR_7 ) {\n                                    VAR_0 << \" | pad:\" ;\n                                    for ( int VAR_29 = 0 ; VAR_29 < 3 ; VAR_29++ ) VAR_0<< \" \" << (int) VAR_26.pData_[VAR_29];\n                                }\n                                long    VAR_30 = getULong(VAR_26.pData_+VAR_28, VAR_23);\n                                if ( VAR_7 ) {\n                                    VAR_0 << \" | iccLength:\" << VAR_30 ;\n                                }\n                                if ( VAR_11 ) {\n                                    VAR_0.write((const char*)VAR_26.pData_+VAR_28,VAR_30);\n                                }\n                            }\n                            lf(VAR_0,VAR_21);\n                        }\n                    } break;\n\n                    case VAR_31:\n                    {\n\n                        if (VAR_3->read((byte*)&VAR_20, sizeof(VAR_20)) == sizeof(VAR_20))\n                        {\n                            bool    VAR_32 = memcmp(VAR_20.uuid, VAR_33, sizeof(VAR_20))==0;\n                            bool    VAR_34 = memcmp(VAR_20.uuid, VAR_35, sizeof(VAR_20))==0;\n                            bool    VAR_36  = memcmp(VAR_20.uuid, VAR_37 , sizeof(VAR_20))==0;\n\n                            bool    VAR_38= ! (VAR_32 || VAR_34 || VAR_36);\n\n                            if ( VAR_7 ) {\n                                if ( VAR_32 ) VAR_0 << \"Exif: \" ;\n                                if ( VAR_34 ) VAR_0 << \"IPTC: \" ;\n                                if ( VAR_36  ) VAR_0 << \"XMP : \" ;\n                                if ( VAR_38) VAR_0 << \"????: \" ;\n                            }\n\n                            DataBuf VAR_39;\n                            VAR_39.alloc(VAR_18.length-sizeof(VAR_20)-sizeof(VAR_18));\n                            long    VAR_40 = VAR_3->read(VAR_39.pData_, VAR_39.size_);\n                            if (VAR_3->error()) throw Error(VAR_5);\n                            if (VAR_40 != VAR_39.size_) throw Error(VAR_41);\n\n                            if ( VAR_7 ){\n                                VAR_0 << Internal::binaryToString(VAR_39,40,0);\n                                VAR_0.flush();\n                            }\n                            lf(VAR_0,VAR_21);\n\n                            if(VAR_32 && VAR_10 && VAR_39.size_ > 0)\n                            {\n                                if ( (VAR_39.pData_[0]      == VAR_39.pData_[1])\n                                    &&   (VAR_39.pData_[0]=='I' || VAR_39.pData_[0]=='M' )\n                                    ) {\n                                    BasicIo::AutoPtr VAR_42 = BasicIo::AutoPtr(new MemIo(VAR_39.pData_,VAR_39.size_));\n                                    printTiffStructure(*VAR_42,VAR_0,VAR_1,VAR_2);\n                                }\n                            }\n\n                            if(VAR_34 && VAR_10)\n                            {\n                                IptcData::printStructure(VAR_0,VAR_39.pData_,VAR_39.size_,VAR_2);\n                            }\n\n                            if( VAR_36 && VAR_13 )\n                            {\n                                VAR_0.write((const char*)VAR_39.pData_,VAR_39.size_);\n                            }\n                        }\n                    } break;\n\n                    default: break;\n                }\n\n                /* COMMENT_3 */\n                VAR_3->seek(VAR_43<long>(VAR_17 - sizeof(VAR_18) + VAR_18.length), BasicIo::beg);\n                if (VAR_3->error()) throw Error(VAR_5);\n                if ( VAR_7 ) lf(VAR_0,VAR_21);\n            }\n        }\n    }",
  "func_graph_path_before": "Exiv2/exiv2/d01eb9905441d773c22c1b2473967e6309573252/jp2image.cpp/vul/before/0.json",
  "func": "void Jp2Image::printStructure(std::ostream& out, PrintStructureOption option,int depth)\n    {\n        if (io_->open() != 0) throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n\n        // Ensure that this is the correct image type\n        if (!isJp2Type(*io_, false)) {\n            if (io_->error() || io_->eof()) throw Error(kerFailedToReadImageData);\n            throw Error(kerNotAJpeg);\n        }\n\n        bool bPrint     = option == kpsBasic || option==kpsRecursive;\n        bool bRecursive = option == kpsRecursive;\n        bool bICC       = option == kpsIccProfile;\n        bool bXMP       = option == kpsXMP;\n        bool bIPTCErase = option == kpsIptcErase;\n\n        if ( bPrint ) {\n            out << \"STRUCTURE OF JPEG2000 FILE: \" << io_->path() << std::endl;\n            out << \" address |   length | box       | data\" << std::endl ;\n        }\n\n        if ( bPrint || bXMP || bICC || bIPTCErase ) {\n\n            long              position  = 0;\n            Jp2BoxHeader      box       = {1,1};\n            Jp2BoxHeader      subBox    = {1,1};\n            Jp2UuidBox        uuid      = {{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}};\n            bool              bLF       = false;\n\n            while (box.length && box.type != kJp2BoxTypeClose && io_->read((byte*)&box, sizeof(box)) == sizeof(box))\n            {\n                position   = io_->tell();\n                box.length = getLong((byte*)&box.length, bigEndian);\n                box.type   = getLong((byte*)&box.type, bigEndian);\n\n                if ( bPrint ) {\n                    out << Internal::stringFormat(\"%8ld | %8ld | \",position-sizeof(box),box.length) << toAscii(box.type) << \"      | \" ;\n                    bLF = true ;\n                    if ( box.type == kJp2BoxTypeClose ) lf(out,bLF);\n                }\n                if ( box.type == kJp2BoxTypeClose ) break;\n\n                switch(box.type)\n                {\n                    case kJp2BoxTypeJp2Header:\n                    {\n                        lf(out,bLF);\n\n                        while (io_->read((byte*)&subBox, sizeof(subBox)) == sizeof(subBox)\n                               && io_->tell() < position + (long) box.length) // don't read beyond the box!\n                        {\n                            int address = io_->tell() - sizeof(subBox);\n                            subBox.length = getLong((byte*)&subBox.length, bigEndian);\n                            subBox.type   = getLong((byte*)&subBox.type, bigEndian);\n\n                            // subBox.length makes no sense if it is larger than the rest of the file\n                            if (subBox.length > io_->size() - io_->tell()) {\n                                throw Error(kerCorruptedMetadata);\n                            }\n                            DataBuf data(subBox.length-sizeof(box));\n                            io_->read(data.pData_,data.size_);\n                            if ( bPrint ) {\n                                out << Internal::stringFormat(\"%8ld | %8ld |  sub:\",address,subBox.length) << toAscii(subBox.type)\n                                <<\" | \" << Internal::binaryToString(data,30,0);\n                                bLF = true;\n                            }\n\n                            if(subBox.type == kJp2BoxTypeColorHeader)\n                            {\n                                long pad = 3 ; // don't know why there are 3 padding bytes\n                                if ( bPrint ) {\n                                    out << \" | pad:\" ;\n                                    for ( int i = 0 ; i < 3 ; i++ ) out<< \" \" << (int) data.pData_[i];\n                                }\n                                long    iccLength = getULong(data.pData_+pad, bigEndian);\n                                if ( bPrint ) {\n                                    out << \" | iccLength:\" << iccLength ;\n                                }\n                                if ( bICC ) {\n                                    out.write((const char*)data.pData_+pad,iccLength);\n                                }\n                            }\n                            lf(out,bLF);\n                        }\n                    } break;\n\n                    case kJp2BoxTypeUuid:\n                    {\n\n                        if (io_->read((byte*)&uuid, sizeof(uuid)) == sizeof(uuid))\n                        {\n                            bool    bIsExif = memcmp(uuid.uuid, kJp2UuidExif, sizeof(uuid))==0;\n                            bool    bIsIPTC = memcmp(uuid.uuid, kJp2UuidIptc, sizeof(uuid))==0;\n                            bool    bIsXMP  = memcmp(uuid.uuid, kJp2UuidXmp , sizeof(uuid))==0;\n\n                            bool    bUnknown= ! (bIsExif || bIsIPTC || bIsXMP);\n\n                            if ( bPrint ) {\n                                if ( bIsExif ) out << \"Exif: \" ;\n                                if ( bIsIPTC ) out << \"IPTC: \" ;\n                                if ( bIsXMP  ) out << \"XMP : \" ;\n                                if ( bUnknown) out << \"????: \" ;\n                            }\n\n                            DataBuf rawData;\n                            rawData.alloc(box.length-sizeof(uuid)-sizeof(box));\n                            long    bufRead = io_->read(rawData.pData_, rawData.size_);\n                            if (io_->error()) throw Error(kerFailedToReadImageData);\n                            if (bufRead != rawData.size_) throw Error(kerInputDataReadFailed);\n\n                            if ( bPrint ){\n                                out << Internal::binaryToString(rawData,40,0);\n                                out.flush();\n                            }\n                            lf(out,bLF);\n\n                            if(bIsExif && bRecursive && rawData.size_ > 0)\n                            {\n                                if ( (rawData.pData_[0]      == rawData.pData_[1])\n                                    &&   (rawData.pData_[0]=='I' || rawData.pData_[0]=='M' )\n                                    ) {\n                                    BasicIo::AutoPtr p = BasicIo::AutoPtr(new MemIo(rawData.pData_,rawData.size_));\n                                    printTiffStructure(*p,out,option,depth);\n                                }\n                            }\n\n                            if(bIsIPTC && bRecursive)\n                            {\n                                IptcData::printStructure(out,rawData.pData_,rawData.size_,depth);\n                            }\n\n                            if( bIsXMP && bXMP )\n                            {\n                                out.write((const char*)rawData.pData_,rawData.size_);\n                            }\n                        }\n                    } break;\n\n                    default: break;\n                }\n\n                // Move to the next box.\n                io_->seek(static_cast<long>(position - sizeof(box) + box.length), BasicIo::beg);\n                if (io_->error()) throw Error(kerFailedToReadImageData);\n                if ( bPrint ) lf(out,bLF);\n            }\n        }\n    }",
  "abstract_func": "void Jp2Image::printStructure(std::ostream& VAR_0, PrintStructureOption VAR_1,int VAR_2)\n    {\n        if (VAR_3->open() != 0) throw Error(VAR_4, VAR_3->path(), strError());\n\n        /* COMMENT_0 */\n        if (!isJp2Type(*VAR_3, false)) {\n            if (VAR_3->error() || VAR_3->eof()) throw Error(VAR_5);\n            throw Error(VAR_6);\n        }\n\n        bool VAR_7     = VAR_1 == VAR_8 || VAR_1==VAR_9;\n        bool VAR_10 = VAR_1 == VAR_9;\n        bool VAR_11       = VAR_1 == VAR_12;\n        bool VAR_13       = VAR_1 == VAR_14;\n        bool VAR_15 = VAR_1 == VAR_16;\n\n        if ( VAR_7 ) {\n            VAR_0 << \"STRUCTURE OF JPEG2000 FILE: \" << VAR_3->path() << std::endl;\n            VAR_0 << \" address |   length | box       | data\" << std::endl ;\n        }\n\n        if ( VAR_7 || VAR_13 || VAR_11 || VAR_15 ) {\n\n            long              VAR_17  = 0;\n            Jp2BoxHeader      VAR_18       = {1,1};\n            Jp2BoxHeader      VAR_19    = {1,1};\n            Jp2UuidBox        VAR_20      = {{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}};\n            bool              VAR_21       = false;\n\n            while (VAR_18.length && VAR_18.type != VAR_22 && VAR_3->read((byte*)&VAR_18, sizeof(VAR_18)) == sizeof(VAR_18))\n            {\n                VAR_17   = VAR_3->tell();\n                VAR_18.length = getLong((byte*)&VAR_18.length, VAR_23);\n                VAR_18.type   = getLong((byte*)&VAR_18.type, VAR_23);\n\n                if ( VAR_7 ) {\n                    VAR_0 << Internal::stringFormat(\"%8ld | %8ld | \",VAR_17-sizeof(VAR_18),VAR_18.length) << toAscii(VAR_18.type) << \"      | \" ;\n                    VAR_21 = true ;\n                    if ( VAR_18.type == VAR_22 ) lf(VAR_0,VAR_21);\n                }\n                if ( VAR_18.type == VAR_22 ) break;\n\n                switch(VAR_18.type)\n                {\n                    case VAR_24:\n                    {\n                        lf(VAR_0,VAR_21);\n\n                        while (VAR_3->read((byte*)&VAR_19, sizeof(VAR_19)) == sizeof(VAR_19)\n                               && VAR_3->tell() < VAR_17 + (long) VAR_18.length) /* COMMENT_1 */\n                        {\n                            int VAR_25 = VAR_3->tell() - sizeof(VAR_19);\n                            VAR_19.length = getLong((byte*)&VAR_19.length, VAR_23);\n                            VAR_19.type   = getLong((byte*)&VAR_19.type, VAR_23);\n\n                            /* COMMENT_2 */\n                            if (VAR_19.length > VAR_3->size() - VAR_3->tell()) {\n                                throw Error(VAR_26);\n                            }\n                            DataBuf VAR_27(VAR_19.length-sizeof(VAR_18));\n                            VAR_3->read(VAR_27.pData_,VAR_27.size_);\n                            if ( VAR_7 ) {\n                                VAR_0 << Internal::stringFormat(\"%8ld | %8ld |  sub:\",VAR_25,VAR_19.length) << toAscii(VAR_19.type)\n                                <<\" | \" << Internal::binaryToString(VAR_27,30,0);\n                                VAR_21 = true;\n                            }\n\n                            if(VAR_19.type == VAR_28)\n                            {\n                                long VAR_29 = 3 ; /* COMMENT_3 */\n                                if ( VAR_7 ) {\n                                    VAR_0 << \" | pad:\" ;\n                                    for ( int VAR_30 = 0 ; VAR_30 < 3 ; VAR_30++ ) VAR_0<< \" \" << (int) VAR_27.pData_[VAR_30];\n                                }\n                                long    VAR_31 = getULong(VAR_27.pData_+VAR_29, VAR_23);\n                                if ( VAR_7 ) {\n                                    VAR_0 << \" | iccLength:\" << VAR_31 ;\n                                }\n                                if ( VAR_11 ) {\n                                    VAR_0.write((const char*)VAR_27.pData_+VAR_29,VAR_31);\n                                }\n                            }\n                            lf(VAR_0,VAR_21);\n                        }\n                    } break;\n\n                    case VAR_32:\n                    {\n\n                        if (VAR_3->read((byte*)&VAR_20, sizeof(VAR_20)) == sizeof(VAR_20))\n                        {\n                            bool    VAR_33 = memcmp(VAR_20.uuid, VAR_34, sizeof(VAR_20))==0;\n                            bool    VAR_35 = memcmp(VAR_20.uuid, VAR_36, sizeof(VAR_20))==0;\n                            bool    VAR_37  = memcmp(VAR_20.uuid, VAR_38 , sizeof(VAR_20))==0;\n\n                            bool    VAR_39= ! (VAR_33 || VAR_35 || VAR_37);\n\n                            if ( VAR_7 ) {\n                                if ( VAR_33 ) VAR_0 << \"Exif: \" ;\n                                if ( VAR_35 ) VAR_0 << \"IPTC: \" ;\n                                if ( VAR_37  ) VAR_0 << \"XMP : \" ;\n                                if ( VAR_39) VAR_0 << \"????: \" ;\n                            }\n\n                            DataBuf VAR_40;\n                            VAR_40.alloc(VAR_18.length-sizeof(VAR_20)-sizeof(VAR_18));\n                            long    VAR_41 = VAR_3->read(VAR_40.pData_, VAR_40.size_);\n                            if (VAR_3->error()) throw Error(VAR_5);\n                            if (VAR_41 != VAR_40.size_) throw Error(VAR_42);\n\n                            if ( VAR_7 ){\n                                VAR_0 << Internal::binaryToString(VAR_40,40,0);\n                                VAR_0.flush();\n                            }\n                            lf(VAR_0,VAR_21);\n\n                            if(VAR_33 && VAR_10 && VAR_40.size_ > 0)\n                            {\n                                if ( (VAR_40.pData_[0]      == VAR_40.pData_[1])\n                                    &&   (VAR_40.pData_[0]=='I' || VAR_40.pData_[0]=='M' )\n                                    ) {\n                                    BasicIo::AutoPtr VAR_43 = BasicIo::AutoPtr(new MemIo(VAR_40.pData_,VAR_40.size_));\n                                    printTiffStructure(*VAR_43,VAR_0,VAR_1,VAR_2);\n                                }\n                            }\n\n                            if(VAR_35 && VAR_10)\n                            {\n                                IptcData::printStructure(VAR_0,VAR_40.pData_,VAR_40.size_,VAR_2);\n                            }\n\n                            if( VAR_37 && VAR_13 )\n                            {\n                                VAR_0.write((const char*)VAR_40.pData_,VAR_40.size_);\n                            }\n                        }\n                    } break;\n\n                    default: break;\n                }\n\n                /* COMMENT_4 */\n                VAR_3->seek(VAR_44<long>(VAR_17 - sizeof(VAR_18) + VAR_18.length), BasicIo::beg);\n                if (VAR_3->error()) throw Error(VAR_5);\n                if ( VAR_7 ) lf(VAR_0,VAR_21);\n            }\n        }\n    }",
  "func_graph_path": "Exiv2/exiv2/d01eb9905441d773c22c1b2473967e6309573252/jp2image.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -53,6 +53,10 @@\n                             subBox.length = getLong((byte*)&subBox.length, bigEndian);\n                             subBox.type   = getLong((byte*)&subBox.type, bigEndian);\n \n+                            // subBox.length makes no sense if it is larger than the rest of the file\n+                            if (subBox.length > io_->size() - io_->tell()) {\n+                                throw Error(kerCorruptedMetadata);\n+                            }\n                             DataBuf data(subBox.length-sizeof(box));\n                             io_->read(data.pData_,data.size_);\n                             if ( bPrint ) {",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "                            // subBox.length makes no sense if it is larger than the rest of the file",
      "                            if (subBox.length > io_->size() - io_->tell()) {",
      "                                throw Error(kerCorruptedMetadata);",
      "                            }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/Exiv2/exiv2/pull/470",
  "description": {
    "pr_info": {
      "title": "Prevent SIGABRT on excessive subBox length in jp2image.cpp",
      "number": 470
    },
    "comment": [
      "This fixes CVE-2018-9145\r\n\r\nI am working on analyzing CVEs for the Debian LTS team and I believe I have identified the fix for CVE-2018-9145.  Note that while I gave the MITRE URL in the test I added, the reproducer originates here: https://github.com/xiaoqx/pocs/tree/master/exiv2 (it is reproducer 4 that I used).\r\n\r\nThe fix that I applied in `jp2image.cpp` follows the same pattern as the length check at `jp2image.cpp:272`.\r\n\r\nAlso note that as a result of changes in Exiv2/exiv2#368 the reproducer produces the output `Uncaught exception: std::bad_alloc` at `exiv2.cpp:177` instead of a `SIGABRT`.\r\n\r\nIf I need to adjust anything in this pull request, please let me know.",
      "# [Codecov](https://codecov.io/gh/Exiv2/exiv2/pull/470?src=pr&el=h1) Report\n> Merging [#470](https://codecov.io/gh/Exiv2/exiv2/pull/470?src=pr&el=desc) into [master](https://codecov.io/gh/Exiv2/exiv2/commit/11e66c6c9eceeddd2263c3591af6317cbd05c1b6?src=pr&el=desc) will **increase** coverage by `0.22%`.\n> The diff coverage is `100%`.\n\n[![Impacted file tree graph](https://codecov.io/gh/Exiv2/exiv2/pull/470/graphs/tree.svg?width=650&token=O9G7Iswx26&height=150&src=pr)](https://codecov.io/gh/Exiv2/exiv2/pull/470?src=pr&el=tree)\n\n```diff\n@@            Coverage Diff             @@\n##           master     #470      +/-   ##\n==========================================\n+ Coverage   62.28%   62.51%   +0.22%     \n==========================================\n  Files         150      150              \n  Lines       20548    20550       +2     \n==========================================\n+ Hits        12798    12846      +48     \n+ Misses       7750     7704      -46\n```\n\n\n| [Impacted Files](https://codecov.io/gh/Exiv2/exiv2/pull/470?src=pr&el=tree) | Coverage Δ | |\n|---|---|---|\n| [src/jp2image.cpp](https://codecov.io/gh/Exiv2/exiv2/pull/470/diff?src=pr&el=tree#diff-c3JjL2pwMmltYWdlLmNwcA==) | `41.81% <100%> (+13.87%)` | :arrow_up: |\n\n------\n\n[Continue to review full report at Codecov](https://codecov.io/gh/Exiv2/exiv2/pull/470?src=pr&el=continue).\n> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)\n> `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`\n> Powered by [Codecov](https://codecov.io/gh/Exiv2/exiv2/pull/470?src=pr&el=footer). Last update [11e66c6...d01eb99](https://codecov.io/gh/Exiv2/exiv2/pull/470?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).\n",
      "@rcsanchez97 The url to the reproducer seems familiar to me, do you happen to know which issue tracks it?",
      "@D4N I searched the opened and closed issues, but I could not find one.  The only issues I found mentioning something similar issue #302 (which is a distinct issue that was fixed some time ago) and #303 (which is also a distinct issue and was closed as `not a bug`).",
      "@piponazo You are quite welcome."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}