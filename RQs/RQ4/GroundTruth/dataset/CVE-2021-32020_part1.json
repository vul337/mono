{
  "cve_id": "CVE-2021-32020",
  "cwe_ids": [
    "CWE-119"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "FreeRTOS/FreeRTOS-Kernel",
  "commit_msg": "Improve heap2 bounds checking (#224)\n\n* Improve heap bounds checking in pvPortMalloc",
  "commit_hash": "c7a9a01c94987082b223d3e59969ede64363da63",
  "git_url": "https://github.com/FreeRTOS/FreeRTOS-Kernel/commit/c7a9a01c94987082b223d3e59969ede64363da63",
  "file_path": "portable/MemMang/heap_2.c",
  "func_name": "pvPortMalloc",
  "func_before": "void * pvPortMalloc( size_t xWantedSize )\n{\n    BlockLink_t * pxBlock, * pxPreviousBlock, * pxNewBlockLink;\n    static BaseType_t xHeapHasBeenInitialised = pdFALSE;\n    void * pvReturn = NULL;\n\n    vTaskSuspendAll();\n    {\n        /* If this is the first call to malloc then the heap will require\n         * initialisation to setup the list of free blocks. */\n        if( xHeapHasBeenInitialised == pdFALSE )\n        {\n            prvHeapInit();\n            xHeapHasBeenInitialised = pdTRUE;\n        }\n\n        /* The wanted size is increased so it can contain a BlockLink_t\n         * structure in addition to the requested amount of bytes. */\n        if( xWantedSize > 0 )\n        {\n            xWantedSize += heapSTRUCT_SIZE;\n\n            /* Ensure that blocks are always aligned to the required number of bytes. */\n            if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0 )\n            {\n                /* Byte alignment required. */\n                xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );\n            }\n        }\n\n        if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )\n        {\n            /* Blocks are stored in byte order - traverse the list from the start\n             * (smallest) block until one of adequate size is found. */\n            pxPreviousBlock = &xStart;\n            pxBlock = xStart.pxNextFreeBlock;\n\n            while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )\n            {\n                pxPreviousBlock = pxBlock;\n                pxBlock = pxBlock->pxNextFreeBlock;\n            }\n\n            /* If we found the end marker then a block of adequate size was not found. */\n            if( pxBlock != &xEnd )\n            {\n                /* Return the memory space - jumping over the BlockLink_t structure\n                 * at its start. */\n                pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );\n\n                /* This block is being returned for use so must be taken out of the\n                 * list of free blocks. */\n                pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;\n\n                /* If the block is larger than required it can be split into two. */\n                if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )\n                {\n                    /* This block is to be split into two.  Create a new block\n                     * following the number of bytes requested. The void cast is\n                     * used to prevent byte alignment warnings from the compiler. */\n                    pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );\n\n                    /* Calculate the sizes of two blocks split from the single\n                     * block. */\n                    pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;\n                    pxBlock->xBlockSize = xWantedSize;\n\n                    /* Insert the new block into the list of free blocks. */\n                    prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );\n                }\n\n                xFreeBytesRemaining -= pxBlock->xBlockSize;\n            }\n        }\n\n        traceMALLOC( pvReturn, xWantedSize );\n    }\n    ( void ) xTaskResumeAll();\n\n    #if ( configUSE_MALLOC_FAILED_HOOK == 1 )\n        {\n            if( pvReturn == NULL )\n            {\n                extern void vApplicationMallocFailedHook( void );\n                vApplicationMallocFailedHook();\n            }\n        }\n    #endif\n\n    return pvReturn;\n}",
  "abstract_func_before": "void * pvPortMalloc( size_t VAR_0 )\n{\n    BlockLink_t * VAR_1, * VAR_2, * VAR_3;\n    static BaseType_t VAR_4 = VAR_5;\n    void * VAR_6 = NULL;\n\n    vTaskSuspendAll();\n    {\n        /* COMMENT_0 */\n                                                              \n        if( VAR_4 == VAR_5 )\n        {\n            prvHeapInit();\n            VAR_4 = VAR_7;\n        }\n\n        /* COMMENT_2 */\n                                                                     \n        if( VAR_0 > 0 )\n        {\n            VAR_0 += VAR_8;\n\n            /* COMMENT_4 */\n            if( ( VAR_0 & VAR_9 ) != 0 )\n            {\n                /* COMMENT_5 */\n                VAR_0 += ( VAR_10 - ( VAR_0 & VAR_9 ) );\n            }\n        }\n\n        if( ( VAR_0 > 0 ) && ( VAR_0 < VAR_11 ) )\n        {\n            /* COMMENT_6 */\n                                                                       \n            VAR_2 = &VAR_12;\n            VAR_1 = VAR_12.pxNextFreeBlock;\n\n            while( ( VAR_1->xBlockSize < VAR_0 ) && ( VAR_1->pxNextFreeBlock != NULL ) )\n            {\n                VAR_2 = VAR_1;\n                VAR_1 = VAR_1->pxNextFreeBlock;\n            }\n\n            /* COMMENT_8 */\n            if( VAR_1 != &VAR_13 )\n            {\n                /* COMMENT_9 */\n                                   \n                VAR_6 = ( void * ) ( ( ( uint8_t * ) VAR_2->pxNextFreeBlock ) + VAR_8 );\n\n                /* COMMENT_11 */\n                                          \n                VAR_2->pxNextFreeBlock = VAR_1->pxNextFreeBlock;\n\n                /* COMMENT_13 */\n                if( ( VAR_1->xBlockSize - VAR_0 ) > VAR_14 )\n                {\n                    /* COMMENT_14 */\n                                                                                \n                                                                                    \n                    VAR_3 = ( void * ) ( ( ( uint8_t * ) VAR_1 ) + VAR_0 );\n\n                    /* COMMENT_17 */\n                                \n                    VAR_3->xBlockSize = VAR_1->xBlockSize - VAR_0;\n                    VAR_1->xBlockSize = VAR_0;\n\n                    /* COMMENT_19 */\n                    prvInsertBlockIntoFreeList( ( VAR_3 ) );\n                }\n\n                VAR_15 -= VAR_1->xBlockSize;\n            }\n        }\n\n        traceMALLOC( VAR_6, VAR_0 );\n    }\n    ( void ) xTaskResumeAll();\n\n    #if ( VAR_16 == 1 )\n        {\n            if( VAR_6 == NULL )\n            {\n                extern void vApplicationMallocFailedHook( void );\n                vApplicationMallocFailedHook();\n            }\n        }\n    #endif\n\n    return VAR_6;\n}",
  "func_graph_path_before": "FreeRTOS/FreeRTOS-Kernel/c7a9a01c94987082b223d3e59969ede64363da63/heap_2.c/vul/before/0.json",
  "func": "void * pvPortMalloc( size_t xWantedSize )\n{\n    BlockLink_t * pxBlock, * pxPreviousBlock, * pxNewBlockLink;\n    static BaseType_t xHeapHasBeenInitialised = pdFALSE;\n    void * pvReturn = NULL;\n\n    vTaskSuspendAll();\n    {\n        /* If this is the first call to malloc then the heap will require\n         * initialisation to setup the list of free blocks. */\n        if( xHeapHasBeenInitialised == pdFALSE )\n        {\n            prvHeapInit();\n            xHeapHasBeenInitialised = pdTRUE;\n        }\n\n        /* The wanted size must be increased so it can contain a BlockLink_t\n         * structure in addition to the requested amount of bytes. */\n        if( ( xWantedSize > 0 ) && \n            ( ( xWantedSize + heapSTRUCT_SIZE ) >  xWantedSize ) ) /* Overflow check */\n        {\n            xWantedSize += heapSTRUCT_SIZE;\n\n            /* Byte alignment required. Check for overflow. */\n            if( ( xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ) \n                    > xWantedSize )\n            {\n                xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );\n                configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );\n            }\n            else\n            {\n                xWantedSize = 0;\n            }       \n        }\n        else \n        {\n            xWantedSize = 0; \n        }\n\n\n        if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )\n        {\n            /* Blocks are stored in byte order - traverse the list from the start\n             * (smallest) block until one of adequate size is found. */\n            pxPreviousBlock = &xStart;\n            pxBlock = xStart.pxNextFreeBlock;\n\n            while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )\n            {\n                pxPreviousBlock = pxBlock;\n                pxBlock = pxBlock->pxNextFreeBlock;\n            }\n\n            /* If we found the end marker then a block of adequate size was not found. */\n            if( pxBlock != &xEnd )\n            {\n                /* Return the memory space - jumping over the BlockLink_t structure\n                 * at its start. */\n                pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );\n\n                /* This block is being returned for use so must be taken out of the\n                 * list of free blocks. */\n                pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;\n\n                /* If the block is larger than required it can be split into two. */\n                if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )\n                {\n                    /* This block is to be split into two.  Create a new block\n                     * following the number of bytes requested. The void cast is\n                     * used to prevent byte alignment warnings from the compiler. */\n                    pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );\n\n                    /* Calculate the sizes of two blocks split from the single\n                     * block. */\n                    pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;\n                    pxBlock->xBlockSize = xWantedSize;\n\n                    /* Insert the new block into the list of free blocks. */\n                    prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );\n                }\n\n                xFreeBytesRemaining -= pxBlock->xBlockSize;\n            }\n        }\n\n        traceMALLOC( pvReturn, xWantedSize );\n    }\n    ( void ) xTaskResumeAll();\n\n    #if ( configUSE_MALLOC_FAILED_HOOK == 1 )\n        {\n            if( pvReturn == NULL )\n            {\n                extern void vApplicationMallocFailedHook( void );\n                vApplicationMallocFailedHook();\n            }\n        }\n    #endif\n\n    return pvReturn;\n}",
  "abstract_func": "void * pvPortMalloc( size_t VAR_0 )\n{\n    BlockLink_t * VAR_1, * VAR_2, * VAR_3;\n    static BaseType_t VAR_4 = VAR_5;\n    void * VAR_6 = NULL;\n\n    vTaskSuspendAll();\n    {\n        /* COMMENT_0 */\n                                                              \n        if( VAR_4 == VAR_5 )\n        {\n            prvHeapInit();\n            VAR_4 = VAR_7;\n        }\n\n        /* COMMENT_2 */\n                                                                     \n        if( ( VAR_0 > 0 ) && \n            ( ( VAR_0 + VAR_8 ) >  VAR_0 ) ) /* COMMENT_4 */\n        {\n            VAR_0 += VAR_8;\n\n            /* COMMENT_5 */\n            if( ( VAR_0 + ( VAR_9 - ( VAR_0 & VAR_10 ) ) ) \n                    > VAR_0 )\n            {\n                VAR_0 += ( VAR_9 - ( VAR_0 & VAR_10 ) );\n                configASSERT( ( VAR_0 & VAR_10 ) == 0 );\n            }\n            else\n            {\n                VAR_0 = 0;\n            }       \n        }\n        else \n        {\n            VAR_0 = 0; \n        }\n\n\n        if( ( VAR_0 > 0 ) && ( VAR_0 <= VAR_11 ) )\n        {\n            /* COMMENT_6 */\n                                                                       \n            VAR_2 = &VAR_12;\n            VAR_1 = VAR_12.pxNextFreeBlock;\n\n            while( ( VAR_1->xBlockSize < VAR_0 ) && ( VAR_1->pxNextFreeBlock != NULL ) )\n            {\n                VAR_2 = VAR_1;\n                VAR_1 = VAR_1->pxNextFreeBlock;\n            }\n\n            /* COMMENT_8 */\n            if( VAR_1 != &VAR_13 )\n            {\n                /* COMMENT_9 */\n                                   \n                VAR_6 = ( void * ) ( ( ( uint8_t * ) VAR_2->pxNextFreeBlock ) + VAR_8 );\n\n                /* COMMENT_11 */\n                                          \n                VAR_2->pxNextFreeBlock = VAR_1->pxNextFreeBlock;\n\n                /* COMMENT_13 */\n                if( ( VAR_1->xBlockSize - VAR_0 ) > VAR_14 )\n                {\n                    /* COMMENT_14 */\n                                                                                \n                                                                                    \n                    VAR_3 = ( void * ) ( ( ( uint8_t * ) VAR_1 ) + VAR_0 );\n\n                    /* COMMENT_17 */\n                                \n                    VAR_3->xBlockSize = VAR_1->xBlockSize - VAR_0;\n                    VAR_1->xBlockSize = VAR_0;\n\n                    /* COMMENT_19 */\n                    prvInsertBlockIntoFreeList( ( VAR_3 ) );\n                }\n\n                VAR_11 -= VAR_1->xBlockSize;\n            }\n        }\n\n        traceMALLOC( VAR_6, VAR_0 );\n    }\n    ( void ) xTaskResumeAll();\n\n    #if ( VAR_15 == 1 )\n        {\n            if( VAR_6 == NULL )\n            {\n                extern void vApplicationMallocFailedHook( void );\n                vApplicationMallocFailedHook();\n            }\n        }\n    #endif\n\n    return VAR_6;\n}",
  "func_graph_path": "FreeRTOS/FreeRTOS-Kernel/c7a9a01c94987082b223d3e59969ede64363da63/heap_2.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -14,21 +14,32 @@\n             xHeapHasBeenInitialised = pdTRUE;\n         }\n \n-        /* The wanted size is increased so it can contain a BlockLink_t\n+        /* The wanted size must be increased so it can contain a BlockLink_t\n          * structure in addition to the requested amount of bytes. */\n-        if( xWantedSize > 0 )\n+        if( ( xWantedSize > 0 ) && \n+            ( ( xWantedSize + heapSTRUCT_SIZE ) >  xWantedSize ) ) /* Overflow check */\n         {\n             xWantedSize += heapSTRUCT_SIZE;\n \n-            /* Ensure that blocks are always aligned to the required number of bytes. */\n-            if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0 )\n+            /* Byte alignment required. Check for overflow. */\n+            if( ( xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ) \n+                    > xWantedSize )\n             {\n-                /* Byte alignment required. */\n                 xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );\n+                configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );\n             }\n+            else\n+            {\n+                xWantedSize = 0;\n+            }       \n+        }\n+        else \n+        {\n+            xWantedSize = 0; \n         }\n \n-        if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )\n+\n+        if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )\n         {\n             /* Blocks are stored in byte order - traverse the list from the start\n              * (smallest) block until one of adequate size is found. */",
  "diff_line_info": {
    "deleted_lines": [
      "        /* The wanted size is increased so it can contain a BlockLink_t",
      "        if( xWantedSize > 0 )",
      "            /* Ensure that blocks are always aligned to the required number of bytes. */",
      "            if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0 )",
      "                /* Byte alignment required. */",
      "        if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )"
    ],
    "added_lines": [
      "        /* The wanted size must be increased so it can contain a BlockLink_t",
      "        if( ( xWantedSize > 0 ) && ",
      "            ( ( xWantedSize + heapSTRUCT_SIZE ) >  xWantedSize ) ) /* Overflow check */",
      "            /* Byte alignment required. Check for overflow. */",
      "            if( ( xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ) ",
      "                    > xWantedSize )",
      "                configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );",
      "            else",
      "            {",
      "                xWantedSize = 0;",
      "            }       ",
      "        }",
      "        else ",
      "        {",
      "            xWantedSize = 0; ",
      "",
      "        if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/FreeRTOS/FreeRTOS-Kernel/pull/224",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/FreeRTOS/FreeRTOS-Kernel/pull/224: 403 Client Error: Forbidden for url: https://api.github.com/repos/FreeRTOS/FreeRTOS-Kernel/pulls/224",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95"
}