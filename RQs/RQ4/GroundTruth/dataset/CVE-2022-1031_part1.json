{
  "cve_id": "CVE-2022-1031",
  "cwe_ids": [
    "CWE-416"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "radareorg/radare2",
  "commit_msg": "Fix UAF in aaaa on arm/thumb switching ##crash\n\n* Reported by @peacock-doris via huntr.dev\n* Reproducer tests_65185\n* This is a logic fix, but not the fully safe as changes in the code\n  can result on UAF again, to properly protect r2 from crashing we\n  need to break the ABI and add refcounting to RRegItem, which can't\n  happen in 5.6.x because of abi-compat rules",
  "commit_hash": "a7ce29647fcb38386d7439696375e16e093d6acb",
  "git_url": "https://github.com/radareorg/radare2/commit/a7ce29647fcb38386d7439696375e16e093d6acb",
  "file_path": "libr/anal/var.c",
  "func_name": "extract_arg",
  "func_before": "static void extract_arg(RAnal *anal, RAnalFunction *fcn, RAnalOp *op, const char *reg, const char *sign, char type) {\n\tst64 ptr = 0;\n\tchar *addr, *esil_buf = NULL;\n\tconst st64 maxstackframe = 1024 * 8; \n\n\tr_return_if_fail (anal && fcn && op && reg);\n\n\tsize_t i;\n\tfor (i = 0; i < R_ARRAY_SIZE (op->src); i++) {\n\t\tif (op->src[i] && op->src[i]->reg && op->src[i]->reg->name) {\n\t\t\tif (!strcmp (reg, op->src[i]->reg->name)) {\n\t\t\t\tst64 delta = op->src[i]->delta;\n\t\t\t\tif ((delta > 0 && *sign == '+') || (delta < 0 && *sign == '-')) {\n\t\t\t\t\tptr = R_ABS (op->src[i]->delta);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!ptr) {\n\t\tconst char *op_esil = r_strbuf_get (&op->esil);\n\t\tif (!op_esil) {\n\t\t\treturn;\n\t\t}\n\t\tesil_buf = strdup (op_esil);\n\t\tif (!esil_buf) {\n\t\t\treturn;\n\t\t}\n\t\tr_strf_var (esilexpr, 64, \",%s,%s,\", reg, sign);\n\t\tchar *ptr_end = strstr (esil_buf, esilexpr);\n\t\tif (!ptr_end) {\n\t\t\tfree (esil_buf);\n\t\t\treturn;\n\t\t}\n\t\t*ptr_end = 0;\n\t\taddr = ptr_end;\n\t\twhile ((addr[0] != '0' || addr[1] != 'x') && addr >= esil_buf + 1 && *addr != ',') {\n\t\t\taddr--;\n\t\t}\n\t\tif (strncmp (addr, \"0x\", 2)) {\n\t\t\t//XXX: This is a workaround for inconsistent esil\n\t\t\tif (!op->stackop && op->dst) {\n\t\t\t\tconst char *sp = r_reg_get_name (anal->reg, R_REG_NAME_SP);\n\t\t\t\tconst char *bp = r_reg_get_name (anal->reg, R_REG_NAME_BP);\n\t\t\t\tconst char *rn = op->dst->reg ? op->dst->reg->name : NULL;\n\t\t\t\tif (rn && ((bp && !strcmp (bp, rn)) || (sp && !strcmp (sp, rn)))) {\n\t\t\t\t\tif (anal->verbose) {\n\t\t\t\t\t\teprintf (\"Warning: Analysis didn't fill op->stackop for instruction that alters stack at 0x%\" PFMT64x \".\\n\", op->addr);\n\t\t\t\t\t}\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (*addr == ',') {\n\t\t\t\taddr++;\n\t\t\t}\n\t\t\tif (!op->stackop && op->type != R_ANAL_OP_TYPE_PUSH && op->type != R_ANAL_OP_TYPE_POP\n\t\t\t\t&& op->type != R_ANAL_OP_TYPE_RET && r_str_isnumber (addr)) {\n\t\t\t\tptr = (st64)r_num_get (NULL, addr);\n\t\t\t\tif (ptr && op->src[0] && ptr == op->src[0]->imm) {\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t} else if ((op->stackop == R_ANAL_STACK_SET) || (op->stackop == R_ANAL_STACK_GET)) {\n\t\t\t\tif (op->ptr % 4) {\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tptr = R_ABS (op->ptr);\n\t\t\t} else {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t} else {\n\t\t\tptr = (st64)r_num_get (NULL, addr);\n\t\t}\n\t}\n\n\tif (anal->verbose && (!op->src[0] || !op->dst)) {\n\t\teprintf (\"Warning: Analysis didn't fill op->src/dst at 0x%\" PFMT64x \".\\n\", op->addr);\n\t}\n\n\tint rw = (op->direction == R_ANAL_OP_DIR_WRITE) ? R_ANAL_VAR_ACCESS_TYPE_WRITE : R_ANAL_VAR_ACCESS_TYPE_READ;\n\tif (*sign == '+') {\n\t\tconst bool isarg = type == R_ANAL_VAR_KIND_SPV ? ptr >= fcn->stack : ptr >= fcn->bp_off;\n\t\tconst char *pfx = isarg ? ARGPREFIX : VARPREFIX;\n\t\tst64 frame_off;\n\t\tif (type == R_ANAL_VAR_KIND_SPV) {\n\t\t\tframe_off = ptr - fcn->stack;\n\t\t} else {\n\t\t\tframe_off = ptr - fcn->bp_off;\n\t\t}\n\t\tif (maxstackframe != 0 && (frame_off > maxstackframe || frame_off < -maxstackframe)) {\n\t\t\tgoto beach;\n\t\t}\n\t\tRAnalVar *var = get_stack_var (fcn, frame_off);\n\t\tif (var) {\n\t\t\tr_anal_var_set_access (var, reg, op->addr, rw, ptr);\n\t\t\tgoto beach;\n\t\t}\n\t\tchar *varname = NULL, *vartype = NULL;\n\t\tif (isarg) {\n\t\t\tconst char *place = fcn->cc ? r_anal_cc_arg (anal, fcn->cc, ST32_MAX) : NULL;\n\t\t\tbool stack_rev = place ? !strcmp (place, \"stack_rev\") : false;\n\t\t\tchar *fname = r_type_func_guess (anal->sdb_types, fcn->name);\n\t\t\tif (fname) {\n\t\t\t\tut64 sum_sz = 0;\n\t\t\t\tsize_t from, to, i;\n\t\t\t\tif (stack_rev) {\n\t\t\t\t\tconst size_t cnt = r_type_func_args_count (anal->sdb_types, fname);\n\t\t\t\t\tfrom = cnt ? cnt - 1 : cnt;\n\t\t\t\t\tto = fcn->cc ? r_anal_cc_max_arg (anal, fcn->cc) : 0;\n\t\t\t\t} else {\n\t\t\t\t\tfrom = fcn->cc ? r_anal_cc_max_arg (anal, fcn->cc) : 0;\n\t\t\t\t\tto = r_type_func_args_count (anal->sdb_types, fname);\n\t\t\t\t}\n\t\t\t\tconst int bytes = (fcn->bits ? fcn->bits : anal->bits) / 8;\n\t\t\t\tfor (i = from; stack_rev ? i >= to : i < to; stack_rev ? i-- : i++) {\n\t\t\t\t\tchar *tp = r_type_func_args_type (anal->sdb_types, fname, i);\n\t\t\t\t\tif (!tp) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (sum_sz == frame_off) {\n\t\t\t\t\t\tvartype = tp;\n\t\t\t\t\t\tvarname = strdup (r_type_func_args_name (anal->sdb_types, fname, i));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tut64 bit_sz = r_type_get_bitsize (anal->sdb_types, tp);\n\t\t\t\t\tsum_sz += bit_sz ? bit_sz / 8 : bytes;\n\t\t\t\t\tsum_sz = R_ROUND (sum_sz, bytes);\n\t\t\t\t\tfree (tp);\n\t\t\t\t}\n\t\t\t\tfree (fname);\n\t\t\t}\n\t\t}\n\t\tif (!varname) {\n\t\t\tif (anal->opt.varname_stack) {\n\t\t\t\tvarname = r_str_newf (\"%s_%\" PFMT64x \"h\", pfx, R_ABS (frame_off));\n\t\t\t} else {\n\t\t\t\tvarname = r_anal_function_autoname_var (fcn, type, pfx, ptr);\n\t\t\t}\n\t\t}\n\t\tif (varname) {\n#if 0\n\t\t\tif (isarg && frame_off > 48) {\n\t\t\t\tfree (varname);\n\t\t\t\tgoto beach;\n\t\t\t}\n#endif\n\t\t\tRAnalVar *var = r_anal_function_set_var (fcn, frame_off, type, vartype, anal->bits / 8, isarg, varname);\n\t\t\tif (var) {\n\t\t\t\tr_anal_var_set_access (var, reg, op->addr, rw, ptr);\n\t\t\t}\n\t\t\tfree (varname);\n\t\t}\n\t\tfree (vartype);\n\t} else {\n\t\tst64 frame_off = -(ptr + fcn->bp_off);\n\t\tif (maxstackframe != 0 && (frame_off > maxstackframe || frame_off < -maxstackframe)) {\n\t\t\tgoto beach;\n\t\t}\n\t\tRAnalVar *var = get_stack_var (fcn, frame_off);\n\t\tif (var) {\n\t\t\tr_anal_var_set_access (var, reg, op->addr, rw, -ptr);\n\t\t\tgoto beach;\n\t\t}\n\t\tchar *varname = anal->opt.varname_stack\n\t\t\t? r_str_newf (\"%s_%\" PFMT64x \"h\", VARPREFIX, R_ABS (frame_off))\n\t\t\t: r_anal_function_autoname_var (fcn, type, VARPREFIX, -ptr);\n\t\tif (varname) {\n\t\t\tRAnalVar *var = r_anal_function_set_var (fcn, frame_off, type, NULL, anal->bits / 8, false, varname);\n\t\t\tif (var) {\n\t\t\t\tr_anal_var_set_access (var, reg, op->addr, rw, -ptr);\n\t\t\t}\n\t\t\tfree (varname);\n\t\t}\n\t}\nbeach:\n\tfree (esil_buf);\n}",
  "abstract_func_before": "static void extract_arg(RAnal *VAR_0, RAnalFunction *VAR_1, RAnalOp *VAR_2, const char *VAR_3, const char *VAR_4, char VAR_5) {\n\tst64 VAR_6 = 0;\n\tchar *VAR_7, *VAR_8 = NULL;\n\tconst st64 VAR_9 = 1024 * 8; \n\n\tr_return_if_fail (VAR_0 && VAR_1 && VAR_2 && VAR_3);\n\n\tsize_t VAR_10;\n\tfor (VAR_10 = 0; VAR_10 < R_ARRAY_SIZE (VAR_2->src); VAR_10++) {\n\t\tif (VAR_2->src[VAR_10] && VAR_2->src[VAR_10]->reg && VAR_2->src[VAR_10]->reg->name) {\n\t\t\tif (!strcmp (VAR_3, VAR_2->src[VAR_10]->reg->name)) {\n\t\t\t\tst64 VAR_11 = VAR_2->src[VAR_10]->delta;\n\t\t\t\tif ((VAR_11 > 0 && *VAR_4 == '+') || (VAR_11 < 0 && *VAR_4 == '-')) {\n\t\t\t\t\tVAR_6 = R_ABS (VAR_2->src[VAR_10]->delta);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!VAR_6) {\n\t\tconst char *VAR_12 = r_strbuf_get (&VAR_2->esil);\n\t\tif (!VAR_12) {\n\t\t\treturn;\n\t\t}\n\t\tVAR_8 = strdup (VAR_12);\n\t\tif (!VAR_8) {\n\t\t\treturn;\n\t\t}\n\t\tr_strf_var (VAR_13, 64, \",%s,%s,\", VAR_3, VAR_4);\n\t\tchar *VAR_14 = strstr (VAR_8, VAR_13);\n\t\tif (!VAR_14) {\n\t\t\tfree (VAR_8);\n\t\t\treturn;\n\t\t}\n\t\t*VAR_14 = 0;\n\t\tVAR_7 = VAR_14;\n\t\twhile ((VAR_7[0] != '0' || VAR_7[1] != 'x') && VAR_7 >= VAR_8 + 1 && *VAR_7 != ',') {\n\t\t\tVAR_7--;\n\t\t}\n\t\tif (strncmp (VAR_7, \"0x\", 2)) {\n\t\t\t/* COMMENT_0 */\n\t\t\tif (!VAR_2->stackop && VAR_2->dst) {\n\t\t\t\tconst char *VAR_15 = r_reg_get_name (VAR_0->reg, VAR_16);\n\t\t\t\tconst char *VAR_17 = r_reg_get_name (VAR_0->reg, VAR_18);\n\t\t\t\tconst char *VAR_19 = VAR_2->dst->reg ? VAR_2->dst->reg->name : NULL;\n\t\t\t\tif (VAR_19 && ((VAR_17 && !strcmp (VAR_17, VAR_19)) || (VAR_15 && !strcmp (VAR_15, VAR_19)))) {\n\t\t\t\t\tif (VAR_0->verbose) {\n\t\t\t\t\t\teprintf (\"Warning: Analysis didn't fill op->stackop for instruction that alters stack at 0x%\" VAR_20 \".\\n\", VAR_2->addr);\n\t\t\t\t\t}\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (*VAR_7 == ',') {\n\t\t\t\tVAR_7++;\n\t\t\t}\n\t\t\tif (!VAR_2->stackop && VAR_2->type != VAR_21 && VAR_2->type != VAR_22\n\t\t\t\t&& VAR_2->type != VAR_23 && r_str_isnumber (VAR_7)) {\n\t\t\t\tVAR_6 = (st64)r_num_get (NULL, VAR_7);\n\t\t\t\tif (VAR_6 && VAR_2->src[0] && VAR_6 == VAR_2->src[0]->imm) {\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t} else if ((VAR_2->stackop == VAR_24) || (VAR_2->stackop == VAR_25)) {\n\t\t\t\tif (VAR_2->ptr % 4) {\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tVAR_6 = R_ABS (VAR_2->ptr);\n\t\t\t} else {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t} else {\n\t\t\tVAR_6 = (st64)r_num_get (NULL, VAR_7);\n\t\t}\n\t}\n\n\tif (VAR_0->verbose && (!VAR_2->src[0] || !VAR_2->dst)) {\n\t\teprintf (\"Warning: Analysis didn't fill op->src/dst at 0x%\" VAR_20 \".\\n\", VAR_2->addr);\n\t}\n\n\tint VAR_26 = (VAR_2->direction == VAR_27) ? VAR_28 : VAR_29;\n\tif (*VAR_4 == '+') {\n\t\tconst bool VAR_30 = VAR_5 == VAR_31 ? VAR_6 >= VAR_1->stack : VAR_6 >= VAR_1->bp_off;\n\t\tconst char *VAR_32 = VAR_30 ? VAR_33 : VAR_34;\n\t\tst64 VAR_35;\n\t\tif (VAR_5 == VAR_31) {\n\t\t\tVAR_35 = VAR_6 - VAR_1->stack;\n\t\t} else {\n\t\t\tVAR_35 = VAR_6 - VAR_1->bp_off;\n\t\t}\n\t\tif (VAR_9 != 0 && (VAR_35 > VAR_9 || VAR_35 < -VAR_9)) {\n\t\t\tgoto beach;\n\t\t}\n\t\tRAnalVar *VAR_36 = get_stack_var (VAR_1, VAR_35);\n\t\tif (VAR_36) {\n\t\t\tr_anal_var_set_access (VAR_36, VAR_3, VAR_2->addr, VAR_26, VAR_6);\n\t\t\tgoto beach;\n\t\t}\n\t\tchar *VAR_37 = NULL, *VAR_38 = NULL;\n\t\tif (VAR_30) {\n\t\t\tconst char *VAR_39 = VAR_1->cc ? r_anal_cc_arg (VAR_0, VAR_1->cc, VAR_40) : NULL;\n\t\t\tbool VAR_41 = VAR_39 ? !strcmp (VAR_39, \"stack_rev\") : false;\n\t\t\tchar *VAR_42 = r_type_func_guess (VAR_0->sdb_types, VAR_1->name);\n\t\t\tif (VAR_42) {\n\t\t\t\tut64 VAR_43 = 0;\n\t\t\t\tsize_t VAR_44, VAR_45, VAR_10;\n\t\t\t\tif (VAR_41) {\n\t\t\t\t\tconst size_t VAR_46 = r_type_func_args_count (VAR_0->sdb_types, VAR_42);\n\t\t\t\t\tVAR_44 = VAR_46 ? VAR_46 - 1 : VAR_46;\n\t\t\t\t\tVAR_45 = VAR_1->cc ? r_anal_cc_max_arg (VAR_0, VAR_1->cc) : 0;\n\t\t\t\t} else {\n\t\t\t\t\tVAR_44 = VAR_1->cc ? r_anal_cc_max_arg (VAR_0, VAR_1->cc) : 0;\n\t\t\t\t\tVAR_45 = r_type_func_args_count (VAR_0->sdb_types, VAR_42);\n\t\t\t\t}\n\t\t\t\tconst int VAR_47 = (VAR_1->bits ? VAR_1->bits : VAR_0->bits) / 8;\n\t\t\t\tfor (VAR_10 = VAR_44; VAR_41 ? VAR_10 >= VAR_45 : VAR_10 < VAR_45; VAR_41 ? VAR_10-- : VAR_10++) {\n\t\t\t\t\tchar *VAR_48 = r_type_func_args_type (VAR_0->sdb_types, VAR_42, VAR_10);\n\t\t\t\t\tif (!VAR_48) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (VAR_43 == VAR_35) {\n\t\t\t\t\t\tVAR_38 = VAR_48;\n\t\t\t\t\t\tVAR_37 = strdup (r_type_func_args_name (VAR_0->sdb_types, VAR_42, VAR_10));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tut64 VAR_49 = r_type_get_bitsize (VAR_0->sdb_types, VAR_48);\n\t\t\t\t\tVAR_43 += VAR_49 ? VAR_49 / 8 : VAR_47;\n\t\t\t\t\tVAR_43 = R_ROUND (VAR_43, VAR_47);\n\t\t\t\t\tfree (VAR_48);\n\t\t\t\t}\n\t\t\t\tfree (VAR_42);\n\t\t\t}\n\t\t}\n\t\tif (!VAR_37) {\n\t\t\tif (VAR_0->opt.varname_stack) {\n\t\t\t\tVAR_37 = r_str_newf (\"%s_%\" VAR_20 \"h\", VAR_32, R_ABS (VAR_35));\n\t\t\t} else {\n\t\t\t\tVAR_37 = r_anal_function_autoname_var (VAR_1, VAR_5, VAR_32, VAR_6);\n\t\t\t}\n\t\t}\n\t\tif (VAR_37) {\n#if 0\n\t\t\tif (VAR_30 && VAR_35 > 48) {\n\t\t\t\tfree (VAR_37);\n\t\t\t\tgoto beach;\n\t\t\t}\n#endif\n\t\t\tRAnalVar *VAR_36 = r_anal_function_set_var (VAR_1, VAR_35, VAR_5, VAR_38, VAR_0->bits / 8, VAR_30, VAR_37);\n\t\t\tif (VAR_36) {\n\t\t\t\tr_anal_var_set_access (VAR_36, VAR_3, VAR_2->addr, VAR_26, VAR_6);\n\t\t\t}\n\t\t\tfree (VAR_37);\n\t\t}\n\t\tfree (VAR_38);\n\t} else {\n\t\tst64 VAR_35 = -(VAR_6 + VAR_1->bp_off);\n\t\tif (VAR_9 != 0 && (VAR_35 > VAR_9 || VAR_35 < -VAR_9)) {\n\t\t\tgoto beach;\n\t\t}\n\t\tRAnalVar *VAR_36 = get_stack_var (VAR_1, VAR_35);\n\t\tif (VAR_36) {\n\t\t\tr_anal_var_set_access (VAR_36, VAR_3, VAR_2->addr, VAR_26, -VAR_6);\n\t\t\tgoto beach;\n\t\t}\n\t\tchar *VAR_37 = VAR_0->opt.varname_stack\n\t\t\t? r_str_newf (\"%s_%\" VAR_20 \"h\", VAR_34, R_ABS (VAR_35))\n\t\t\t: r_anal_function_autoname_var (VAR_1, VAR_5, VAR_34, -VAR_6);\n\t\tif (VAR_37) {\n\t\t\tRAnalVar *VAR_36 = r_anal_function_set_var (VAR_1, VAR_35, VAR_5, NULL, VAR_0->bits / 8, false, VAR_37);\n\t\t\tif (VAR_36) {\n\t\t\t\tr_anal_var_set_access (VAR_36, VAR_3, VAR_2->addr, VAR_26, -VAR_6);\n\t\t\t}\n\t\t\tfree (VAR_37);\n\t\t}\n\t}\nbeach:\n\tfree (VAR_8);\n}",
  "func_graph_path_before": "radareorg/radare2/a7ce29647fcb38386d7439696375e16e093d6acb/var.c/vul/before/0.json",
  "func": "static void extract_arg(RAnal *anal, RAnalFunction *fcn, RAnalOp *op, const char *reg, const char *sign, char type) {\n\tst64 ptr = 0;\n\tchar *addr, *esil_buf = NULL;\n\tconst st64 maxstackframe = 1024 * 8; \n\n\tr_return_if_fail (anal && fcn && op && reg);\n\n\tsize_t i;\n\tfor (i = 0; i < R_ARRAY_SIZE (op->src); i++) {\n\t\tif (op->src[i] && op->src[i]->reg && op->src[i]->reg->name) {\n\t\t\tif (!strcmp (reg, op->src[i]->reg->name)) {\n\t\t\t\tst64 delta = op->src[i]->delta;\n\t\t\t\tif ((delta > 0 && *sign == '+') || (delta < 0 && *sign == '-')) {\n\t\t\t\t\tptr = R_ABS (op->src[i]->delta);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!ptr) {\n\t\tconst char *op_esil = r_strbuf_get (&op->esil);\n\t\tif (!op_esil) {\n\t\t\treturn;\n\t\t}\n\t\tesil_buf = strdup (op_esil);\n\t\tif (!esil_buf) {\n\t\t\treturn;\n\t\t}\n\t\tr_strf_var (esilexpr, 64, \",%s,%s,\", reg, sign);\n\t\tchar *ptr_end = strstr (esil_buf, esilexpr);\n\t\tif (!ptr_end) {\n\t\t\tfree (esil_buf);\n\t\t\treturn;\n\t\t}\n\t\t*ptr_end = 0;\n\t\taddr = ptr_end;\n\t\twhile ((addr[0] != '0' || addr[1] != 'x') && addr >= esil_buf + 1 && *addr != ',') {\n\t\t\taddr--;\n\t\t}\n\t\tif (strncmp (addr, \"0x\", 2)) {\n\t\t\t//XXX: This is a workaround for inconsistent esil\n\t\t\tif (!op->stackop && op->dst) {\n\t\t\t\tconst char *sp = r_reg_get_name (anal->reg, R_REG_NAME_SP);\n\t\t\t\tconst char *bp = r_reg_get_name (anal->reg, R_REG_NAME_BP);\n\t\t\t\tconst char *rn = op->dst->reg ? op->dst->reg->name : NULL;\n\t\t\t\tif (rn && ((bp && !strcmp (bp, rn)) || (sp && !strcmp (sp, rn)))) {\n\t\t\t\t\tif (anal->verbose) {\n\t\t\t\t\t\teprintf (\"Warning: Analysis didn't fill op->stackop for instruction that alters stack at 0x%\" PFMT64x \".\\n\", op->addr);\n\t\t\t\t\t}\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (*addr == ',') {\n\t\t\t\taddr++;\n\t\t\t}\n\t\t\tif (!op->stackop && op->type != R_ANAL_OP_TYPE_PUSH && op->type != R_ANAL_OP_TYPE_POP\n\t\t\t\t&& op->type != R_ANAL_OP_TYPE_RET && r_str_isnumber (addr)) {\n\t\t\t\tptr = (st64)r_num_get (NULL, addr);\n\t\t\t\tif (ptr && op->src[0] && ptr == op->src[0]->imm) {\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t} else if ((op->stackop == R_ANAL_STACK_SET) || (op->stackop == R_ANAL_STACK_GET)) {\n\t\t\t\tif (op->ptr % 4) {\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tptr = R_ABS (op->ptr);\n\t\t\t} else {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t} else {\n\t\t\tptr = (st64)r_num_get (NULL, addr);\n\t\t}\n\t}\n\n\tif (anal->verbose && (!op->src[0] || !op->dst)) {\n\t\teprintf (\"Warning: Analysis didn't fill op->src/dst at 0x%\" PFMT64x \".\\n\", op->addr);\n\t}\n\n\tint rw = (op->direction == R_ANAL_OP_DIR_WRITE) ? R_ANAL_VAR_ACCESS_TYPE_WRITE : R_ANAL_VAR_ACCESS_TYPE_READ;\n\tif (*sign == '+') {\n\t\tconst bool isarg = type == R_ANAL_VAR_KIND_SPV ? ptr >= fcn->stack : ptr >= fcn->bp_off;\n\t\tconst char *pfx = isarg ? ARGPREFIX : VARPREFIX;\n\t\tst64 frame_off;\n\t\tif (type == R_ANAL_VAR_KIND_SPV) {\n\t\t\tframe_off = ptr - fcn->stack;\n\t\t} else {\n\t\t\tframe_off = ptr - fcn->bp_off;\n\t\t}\n\t\tif (maxstackframe != 0 && (frame_off > maxstackframe || frame_off < -maxstackframe)) {\n\t\t\tgoto beach;\n\t\t}\n\t\tRAnalVar *var = get_stack_var (fcn, frame_off);\n\t\tif (var) {\n\t\t\tr_anal_var_set_access (var, reg, op->addr, rw, ptr);\n\t\t\tgoto beach;\n\t\t}\n\t\tchar *varname = NULL, *vartype = NULL;\n\t\tif (isarg) {\n\t\t\tconst char *place = fcn->cc ? r_anal_cc_arg (anal, fcn->cc, ST32_MAX) : NULL;\n\t\t\tbool stack_rev = place ? !strcmp (place, \"stack_rev\") : false;\n\t\t\tchar *fname = r_type_func_guess (anal->sdb_types, fcn->name);\n\t\t\tif (fname) {\n\t\t\t\tut64 sum_sz = 0;\n\t\t\t\tsize_t from, to, i;\n\t\t\t\tif (stack_rev) {\n\t\t\t\t\tconst size_t cnt = r_type_func_args_count (anal->sdb_types, fname);\n\t\t\t\t\tfrom = cnt ? cnt - 1 : cnt;\n\t\t\t\t\tto = fcn->cc ? r_anal_cc_max_arg (anal, fcn->cc) : 0;\n\t\t\t\t} else {\n\t\t\t\t\tfrom = fcn->cc ? r_anal_cc_max_arg (anal, fcn->cc) : 0;\n\t\t\t\t\tto = r_type_func_args_count (anal->sdb_types, fname);\n\t\t\t\t}\n\t\t\t\tconst int bytes = (fcn->bits ? fcn->bits : anal->bits) / 8;\n\t\t\t\tfor (i = from; stack_rev ? i >= to : i < to; stack_rev ? i-- : i++) {\n\t\t\t\t\tchar *tp = r_type_func_args_type (anal->sdb_types, fname, i);\n\t\t\t\t\tif (!tp) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (sum_sz == frame_off) {\n\t\t\t\t\t\tvartype = tp;\n\t\t\t\t\t\tvarname = strdup (r_type_func_args_name (anal->sdb_types, fname, i));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tut64 bit_sz = r_type_get_bitsize (anal->sdb_types, tp);\n\t\t\t\t\tsum_sz += bit_sz ? bit_sz / 8 : bytes;\n\t\t\t\t\tsum_sz = R_ROUND (sum_sz, bytes);\n\t\t\t\t\tfree (tp);\n\t\t\t\t}\n\t\t\t\tfree (fname);\n\t\t\t}\n\t\t}\n\t\tif (!varname) {\n\t\t\tif (anal->opt.varname_stack) {\n\t\t\t\tvarname = r_str_newf (\"%s_%\" PFMT64x \"h\", pfx, R_ABS (frame_off));\n\t\t\t} else {\n\t\t\t\tvarname = r_anal_function_autoname_var (fcn, type, pfx, ptr);\n\t\t\t}\n\t\t}\n\t\tif (varname) {\n#if 0\n\t\t\tif (isarg && frame_off > 48) {\n\t\t\t\tfree (varname);\n\t\t\t\tgoto beach;\n\t\t\t}\n#endif\n\t\t\tRAnalVar *var = r_anal_function_set_var (fcn, frame_off, type, vartype, anal->bits / 8, isarg, varname);\n\t\t\tif (var) {\n\t\t\t\tr_anal_var_set_access (var, reg, op->addr, rw, ptr);\n\t\t\t}\n\t\t\tfree (varname);\n\t\t}\n\t\tfree (vartype);\n\t} else {\n\t\tst64 frame_off = -(ptr + fcn->bp_off);\n\t\tif (maxstackframe > 0 && (frame_off > maxstackframe || frame_off < -maxstackframe)) {\n\t\t\tgoto beach;\n\t\t}\n\t\tRAnalVar *var = get_stack_var (fcn, frame_off);\n\t\tif (var) {\n\t\t\tr_anal_var_set_access (var, reg, op->addr, rw, -ptr);\n\t\t\tgoto beach;\n\t\t}\n\t\tchar *varname = anal->opt.varname_stack\n\t\t\t? r_str_newf (\"%s_%\" PFMT64x \"h\", VARPREFIX, R_ABS (frame_off))\n\t\t\t: r_anal_function_autoname_var (fcn, type, VARPREFIX, -ptr);\n\t\tif (varname) {\n\t\t\tRAnalVar *var = r_anal_function_set_var (fcn, frame_off, type, NULL, anal->bits / 8, false, varname);\n\t\t\tif (var) {\n\t\t\t\tr_anal_var_set_access (var, reg, op->addr, rw, -ptr);\n\t\t\t}\n\t\t\tfree (varname);\n\t\t}\n\t}\nbeach:\n\tfree (esil_buf);\n}",
  "abstract_func": "static void extract_arg(RAnal *VAR_0, RAnalFunction *VAR_1, RAnalOp *VAR_2, const char *VAR_3, const char *VAR_4, char VAR_5) {\n\tst64 VAR_6 = 0;\n\tchar *VAR_7, *VAR_8 = NULL;\n\tconst st64 VAR_9 = 1024 * 8; \n\n\tr_return_if_fail (VAR_0 && VAR_1 && VAR_2 && VAR_3);\n\n\tsize_t VAR_10;\n\tfor (VAR_10 = 0; VAR_10 < R_ARRAY_SIZE (VAR_2->src); VAR_10++) {\n\t\tif (VAR_2->src[VAR_10] && VAR_2->src[VAR_10]->reg && VAR_2->src[VAR_10]->reg->name) {\n\t\t\tif (!strcmp (VAR_3, VAR_2->src[VAR_10]->reg->name)) {\n\t\t\t\tst64 VAR_11 = VAR_2->src[VAR_10]->delta;\n\t\t\t\tif ((VAR_11 > 0 && *VAR_4 == '+') || (VAR_11 < 0 && *VAR_4 == '-')) {\n\t\t\t\t\tVAR_6 = R_ABS (VAR_2->src[VAR_10]->delta);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!VAR_6) {\n\t\tconst char *VAR_12 = r_strbuf_get (&VAR_2->esil);\n\t\tif (!VAR_12) {\n\t\t\treturn;\n\t\t}\n\t\tVAR_8 = strdup (VAR_12);\n\t\tif (!VAR_8) {\n\t\t\treturn;\n\t\t}\n\t\tr_strf_var (VAR_13, 64, \",%s,%s,\", VAR_3, VAR_4);\n\t\tchar *VAR_14 = strstr (VAR_8, VAR_13);\n\t\tif (!VAR_14) {\n\t\t\tfree (VAR_8);\n\t\t\treturn;\n\t\t}\n\t\t*VAR_14 = 0;\n\t\tVAR_7 = VAR_14;\n\t\twhile ((VAR_7[0] != '0' || VAR_7[1] != 'x') && VAR_7 >= VAR_8 + 1 && *VAR_7 != ',') {\n\t\t\tVAR_7--;\n\t\t}\n\t\tif (strncmp (VAR_7, \"0x\", 2)) {\n\t\t\t/* COMMENT_0 */\n\t\t\tif (!VAR_2->stackop && VAR_2->dst) {\n\t\t\t\tconst char *VAR_15 = r_reg_get_name (VAR_0->reg, VAR_16);\n\t\t\t\tconst char *VAR_17 = r_reg_get_name (VAR_0->reg, VAR_18);\n\t\t\t\tconst char *VAR_19 = VAR_2->dst->reg ? VAR_2->dst->reg->name : NULL;\n\t\t\t\tif (VAR_19 && ((VAR_17 && !strcmp (VAR_17, VAR_19)) || (VAR_15 && !strcmp (VAR_15, VAR_19)))) {\n\t\t\t\t\tif (VAR_0->verbose) {\n\t\t\t\t\t\teprintf (\"Warning: Analysis didn't fill op->stackop for instruction that alters stack at 0x%\" VAR_20 \".\\n\", VAR_2->addr);\n\t\t\t\t\t}\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (*VAR_7 == ',') {\n\t\t\t\tVAR_7++;\n\t\t\t}\n\t\t\tif (!VAR_2->stackop && VAR_2->type != VAR_21 && VAR_2->type != VAR_22\n\t\t\t\t&& VAR_2->type != VAR_23 && r_str_isnumber (VAR_7)) {\n\t\t\t\tVAR_6 = (st64)r_num_get (NULL, VAR_7);\n\t\t\t\tif (VAR_6 && VAR_2->src[0] && VAR_6 == VAR_2->src[0]->imm) {\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t} else if ((VAR_2->stackop == VAR_24) || (VAR_2->stackop == VAR_25)) {\n\t\t\t\tif (VAR_2->ptr % 4) {\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tVAR_6 = R_ABS (VAR_2->ptr);\n\t\t\t} else {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t} else {\n\t\t\tVAR_6 = (st64)r_num_get (NULL, VAR_7);\n\t\t}\n\t}\n\n\tif (VAR_0->verbose && (!VAR_2->src[0] || !VAR_2->dst)) {\n\t\teprintf (\"Warning: Analysis didn't fill op->src/dst at 0x%\" VAR_20 \".\\n\", VAR_2->addr);\n\t}\n\n\tint VAR_26 = (VAR_2->direction == VAR_27) ? VAR_28 : VAR_29;\n\tif (*VAR_4 == '+') {\n\t\tconst bool VAR_30 = VAR_5 == VAR_31 ? VAR_6 >= VAR_1->stack : VAR_6 >= VAR_1->bp_off;\n\t\tconst char *VAR_32 = VAR_30 ? VAR_33 : VAR_34;\n\t\tst64 VAR_35;\n\t\tif (VAR_5 == VAR_31) {\n\t\t\tVAR_35 = VAR_6 - VAR_1->stack;\n\t\t} else {\n\t\t\tVAR_35 = VAR_6 - VAR_1->bp_off;\n\t\t}\n\t\tif (VAR_9 != 0 && (VAR_35 > VAR_9 || VAR_35 < -VAR_9)) {\n\t\t\tgoto beach;\n\t\t}\n\t\tRAnalVar *VAR_36 = get_stack_var (VAR_1, VAR_35);\n\t\tif (VAR_36) {\n\t\t\tr_anal_var_set_access (VAR_36, VAR_3, VAR_2->addr, VAR_26, VAR_6);\n\t\t\tgoto beach;\n\t\t}\n\t\tchar *VAR_37 = NULL, *VAR_38 = NULL;\n\t\tif (VAR_30) {\n\t\t\tconst char *VAR_39 = VAR_1->cc ? r_anal_cc_arg (VAR_0, VAR_1->cc, VAR_40) : NULL;\n\t\t\tbool VAR_41 = VAR_39 ? !strcmp (VAR_39, \"stack_rev\") : false;\n\t\t\tchar *VAR_42 = r_type_func_guess (VAR_0->sdb_types, VAR_1->name);\n\t\t\tif (VAR_42) {\n\t\t\t\tut64 VAR_43 = 0;\n\t\t\t\tsize_t VAR_44, VAR_45, VAR_10;\n\t\t\t\tif (VAR_41) {\n\t\t\t\t\tconst size_t VAR_46 = r_type_func_args_count (VAR_0->sdb_types, VAR_42);\n\t\t\t\t\tVAR_44 = VAR_46 ? VAR_46 - 1 : VAR_46;\n\t\t\t\t\tVAR_45 = VAR_1->cc ? r_anal_cc_max_arg (VAR_0, VAR_1->cc) : 0;\n\t\t\t\t} else {\n\t\t\t\t\tVAR_44 = VAR_1->cc ? r_anal_cc_max_arg (VAR_0, VAR_1->cc) : 0;\n\t\t\t\t\tVAR_45 = r_type_func_args_count (VAR_0->sdb_types, VAR_42);\n\t\t\t\t}\n\t\t\t\tconst int VAR_47 = (VAR_1->bits ? VAR_1->bits : VAR_0->bits) / 8;\n\t\t\t\tfor (VAR_10 = VAR_44; VAR_41 ? VAR_10 >= VAR_45 : VAR_10 < VAR_45; VAR_41 ? VAR_10-- : VAR_10++) {\n\t\t\t\t\tchar *VAR_48 = r_type_func_args_type (VAR_0->sdb_types, VAR_42, VAR_10);\n\t\t\t\t\tif (!VAR_48) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (VAR_43 == VAR_35) {\n\t\t\t\t\t\tVAR_38 = VAR_48;\n\t\t\t\t\t\tVAR_37 = strdup (r_type_func_args_name (VAR_0->sdb_types, VAR_42, VAR_10));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tut64 VAR_49 = r_type_get_bitsize (VAR_0->sdb_types, VAR_48);\n\t\t\t\t\tVAR_43 += VAR_49 ? VAR_49 / 8 : VAR_47;\n\t\t\t\t\tVAR_43 = R_ROUND (VAR_43, VAR_47);\n\t\t\t\t\tfree (VAR_48);\n\t\t\t\t}\n\t\t\t\tfree (VAR_42);\n\t\t\t}\n\t\t}\n\t\tif (!VAR_37) {\n\t\t\tif (VAR_0->opt.varname_stack) {\n\t\t\t\tVAR_37 = r_str_newf (\"%s_%\" VAR_20 \"h\", VAR_32, R_ABS (VAR_35));\n\t\t\t} else {\n\t\t\t\tVAR_37 = r_anal_function_autoname_var (VAR_1, VAR_5, VAR_32, VAR_6);\n\t\t\t}\n\t\t}\n\t\tif (VAR_37) {\n#if 0\n\t\t\tif (VAR_30 && VAR_35 > 48) {\n\t\t\t\tfree (VAR_37);\n\t\t\t\tgoto beach;\n\t\t\t}\n#endif\n\t\t\tRAnalVar *VAR_36 = r_anal_function_set_var (VAR_1, VAR_35, VAR_5, VAR_38, VAR_0->bits / 8, VAR_30, VAR_37);\n\t\t\tif (VAR_36) {\n\t\t\t\tr_anal_var_set_access (VAR_36, VAR_3, VAR_2->addr, VAR_26, VAR_6);\n\t\t\t}\n\t\t\tfree (VAR_37);\n\t\t}\n\t\tfree (VAR_38);\n\t} else {\n\t\tst64 VAR_35 = -(VAR_6 + VAR_1->bp_off);\n\t\tif (VAR_9 > 0 && (VAR_35 > VAR_9 || VAR_35 < -VAR_9)) {\n\t\t\tgoto beach;\n\t\t}\n\t\tRAnalVar *VAR_36 = get_stack_var (VAR_1, VAR_35);\n\t\tif (VAR_36) {\n\t\t\tr_anal_var_set_access (VAR_36, VAR_3, VAR_2->addr, VAR_26, -VAR_6);\n\t\t\tgoto beach;\n\t\t}\n\t\tchar *VAR_37 = VAR_0->opt.varname_stack\n\t\t\t? r_str_newf (\"%s_%\" VAR_20 \"h\", VAR_34, R_ABS (VAR_35))\n\t\t\t: r_anal_function_autoname_var (VAR_1, VAR_5, VAR_34, -VAR_6);\n\t\tif (VAR_37) {\n\t\t\tRAnalVar *VAR_36 = r_anal_function_set_var (VAR_1, VAR_35, VAR_5, NULL, VAR_0->bits / 8, false, VAR_37);\n\t\t\tif (VAR_36) {\n\t\t\t\tr_anal_var_set_access (VAR_36, VAR_3, VAR_2->addr, VAR_26, -VAR_6);\n\t\t\t}\n\t\t\tfree (VAR_37);\n\t\t}\n\t}\nbeach:\n\tfree (VAR_8);\n}",
  "func_graph_path": "radareorg/radare2/a7ce29647fcb38386d7439696375e16e093d6acb/var.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -153,7 +153,7 @@\n \t\tfree (vartype);\n \t} else {\n \t\tst64 frame_off = -(ptr + fcn->bp_off);\n-\t\tif (maxstackframe != 0 && (frame_off > maxstackframe || frame_off < -maxstackframe)) {\n+\t\tif (maxstackframe > 0 && (frame_off > maxstackframe || frame_off < -maxstackframe)) {\n \t\t\tgoto beach;\n \t\t}\n \t\tRAnalVar *var = get_stack_var (fcn, frame_off);",
  "diff_line_info": {
    "deleted_lines": [
      "\t\tif (maxstackframe != 0 && (frame_off > maxstackframe || frame_off < -maxstackframe)) {"
    ],
    "added_lines": [
      "\t\tif (maxstackframe > 0 && (frame_off > maxstackframe || frame_off < -maxstackframe)) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/radareorg/radare2/pull/19851",
  "description": {
    "pr_info": {
      "title": "Fix UAF in aaaa on arm/thumb switching ##crash",
      "number": 19851
    },
    "comment": [
      "* Reported by @peacock-doris via huntr.dev\r\n* Reproducer tests_65185\r\n* This is a logic fix, but not the fully safe as changes in the code\r\n  can result on UAF again, to properly protect r2 from crashing we\r\n  need to break the ABI and add refcounting to RRegItem, which can't\r\n  happen in 5.6.x because of abi-compat rules\r\n\r\n<!--\r\nRead https://github.com/radareorg/radare2/blob/master/DEVELOPERS.md\r\n* PR title must be capitalized, concise and use ##tags\r\n* If the PR is fixing a ticket use 'Fix #1234 - ..' in the commit message\r\n* Follow the coding style, add tests and documentation if necessary\r\n-->\r\n\r\n- [ ] Mark this if you consider it ready to merge\r\n- [ ] I've added tests (optional)\r\n- [ ] I wrote some lines in the [book](https://github.com/radareorg/radare2book) (optional)\r\n\r\n**Description**\r\n\r\n<!-- explain your changes if necessary -->\r\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "The commit addresses a Use-After-Free (UAF) issue, a security vulnerability. The code modification corrects a condition to prevent improper memory handling, aligning with the commit message.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9"
}