{
  "cve_id": "CVE-2021-36146",
  "cwe_ids": [
    "CWE-476"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "projectacrn/acrn-hypervisor",
  "commit_msg": "DM: xHCI: Check trb pointer before use it\n\nThe trb pointer may be NULL when get the address from user space, add\nthe pointer check before use the trb.\n\nTracked-On: #6172\nSigned-off-by: Liu Long <long.liu@intel.com>\nReviewed-by: Shuo A Liu <shuo.a.liu@intel.com>\nAcked-by: Yu Wang <yu1.wang@intel.com>",
  "commit_hash": "330359921e2e4c2f3f3a10b5bab86942d63c4428",
  "git_url": "https://github.com/projectacrn/acrn-hypervisor/commit/330359921e2e4c2f3f3a10b5bab86942d63c4428",
  "file_path": "devicemodel/hw/pci/xhci.c",
  "func_name": "pci_xhci_complete_commands",
  "func_before": "static int\npci_xhci_complete_commands(struct pci_xhci_vdev *xdev)\n{\n\tstruct xhci_trb\tevtrb;\n\tstruct xhci_trb\t*trb;\n\tuint64_t\tcrcr;\n\tuint32_t\tccs;\t\t/* cycle state (XHCI 4.9.2) */\n\tuint32_t\ttype;\n\tuint32_t\tslot;\n\tuint32_t\tcmderr;\n\n\txdev->opregs.crcr |= XHCI_CRCR_LO_CRR;\n\n\ttrb = xdev->opregs.cr_p;\n\tccs = xdev->opregs.crcr & XHCI_CRCR_LO_RCS;\n\tcrcr = xdev->opregs.crcr & ~0xF;\n\n\twhile (1) {\n\t\txdev->opregs.cr_p = trb;\n\n\t\ttype = XHCI_TRB_3_TYPE_GET(trb->dwTrb3);\n\n\t\tif ((trb->dwTrb3 & XHCI_TRB_3_CYCLE_BIT) !=\n\t\t    (ccs & XHCI_TRB_3_CYCLE_BIT))\n\t\t\tbreak;\n\n\t\tUPRINTF(LDBG, \"cmd type 0x%x, Trb0 x%016lx dwTrb2 x%08x\"\n\t\t\t\" dwTrb3 x%08x, TRB_CYCLE %u/ccs %u\\r\\n\",\n\t\t\ttype, trb->qwTrb0, trb->dwTrb2, trb->dwTrb3,\n\t\t\ttrb->dwTrb3 & XHCI_TRB_3_CYCLE_BIT, ccs);\n\n\t\tcmderr = XHCI_TRB_ERROR_SUCCESS;\n\t\tevtrb.dwTrb2 = 0;\n\t\tevtrb.dwTrb3 = (ccs & XHCI_TRB_3_CYCLE_BIT) |\n\t\t      XHCI_TRB_3_TYPE_SET(XHCI_TRB_EVENT_CMD_COMPLETE);\n\t\tslot = 0;\n\n\t\tswitch (type) {\n\t\tcase XHCI_TRB_TYPE_LINK:\t\t\t/* 0x06 */\n\t\t\tif (trb->dwTrb3 & XHCI_TRB_3_TC_BIT)\n\t\t\t\tccs ^= XHCI_CRCR_LO_RCS;\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_ENABLE_SLOT:\t\t\t/* 0x09 */\n\t\t\t/*\n\t\t\t *From xHCI spec 4.5.3.2, the only command that\n\t\t\t *software is allowed to issue for the slot in\n\t\t\t *disabled state is the Enable Slot Command.\n\t\t\t * */\n\t\t\tcmderr = pci_xhci_cmd_enable_slot(xdev, &slot);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_DISABLE_SLOT:\t\t/* 0x0A */\n\t\t\tXHCI_GET_SLOT(xdev, trb, slot, cmderr);\n\t\t\tif (slot)\n\t\t\t\tcmderr = pci_xhci_cmd_disable_slot(xdev, slot);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_ADDRESS_DEVICE:\t\t/* 0x0B */\n\t\t\tXHCI_GET_SLOT(xdev, trb, slot, cmderr);\n\t\t\tif (slot)\n\t\t\t\tcmderr = pci_xhci_cmd_address_device(xdev, slot, trb);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_CONFIGURE_EP:\t\t/* 0x0C */\n\t\t\tXHCI_GET_SLOT(xdev, trb, slot, cmderr);\n\t\t\tif (slot)\n\t\t\t\tcmderr = pci_xhci_cmd_config_ep(xdev, slot, trb);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_EVALUATE_CTX:\t\t/* 0x0D */\n\t\t\tXHCI_GET_SLOT(xdev, trb, slot, cmderr);\n\t\t\tif (slot)\n\t\t\t\tcmderr = pci_xhci_cmd_eval_ctx(xdev, slot, trb);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_RESET_EP:\t\t\t/* 0x0E */\n\t\t\tUPRINTF(LDBG, \"Reset Endpoint on slot %d\\r\\n\", slot);\n\t\t\tXHCI_GET_SLOT(xdev, trb, slot, cmderr);\n\t\t\tif (slot)\n\t\t\t\tcmderr = pci_xhci_cmd_reset_ep(xdev, slot, trb);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_STOP_EP:\t\t\t/* 0x0F */\n\t\t\tUPRINTF(LDBG, \"Stop Endpoint on slot %d\\r\\n\", slot);\n\t\t\tXHCI_GET_SLOT(xdev, trb, slot, cmderr);\n\t\t\tif (slot)\n\t\t\t\tcmderr = pci_xhci_cmd_reset_ep(xdev, slot, trb);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_SET_TR_DEQUEUE:\t\t/* 0x10 */\n\t\t\tXHCI_GET_SLOT(xdev, trb, slot, cmderr);\n\t\t\tif (slot)\n\t\t\t\tcmderr = pci_xhci_cmd_set_tr(xdev, slot, trb);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_RESET_DEVICE:\t\t/* 0x11 */\n\t\t\tXHCI_GET_SLOT(xdev, trb, slot, cmderr);\n\t\t\tif (slot)\n\t\t\t\tcmderr = pci_xhci_cmd_reset_device(xdev, slot);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_FORCE_EVENT:\t\t\t/* 0x12 */\n\t\t\t/* TODO: */\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_NEGOTIATE_BW:\t\t/* 0x13 */\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_SET_LATENCY_TOL:\t\t/* 0x14 */\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_GET_PORT_BW:\t\t\t/* 0x15 */\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_FORCE_HEADER:\t\t/* 0x16 */\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_NOOP_CMD:\t\t\t/* 0x17 */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tUPRINTF(LDBG, \"unsupported cmd %x\\r\\n\", type);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (type != XHCI_TRB_TYPE_LINK) {\n\t\t\t/*\n\t\t\t * insert command completion event and assert intr\n\t\t\t */\n\t\t\tevtrb.qwTrb0 = crcr;\n\t\t\tevtrb.dwTrb2 |= XHCI_TRB_2_ERROR_SET(cmderr);\n\t\t\tevtrb.dwTrb3 |= XHCI_TRB_3_SLOT_SET(slot);\n\t\t\tUPRINTF(LDBG, \"command 0x%x result: 0x%x\\r\\n\",\n\t\t\t\ttype, cmderr);\n\t\t\tif (pci_xhci_insert_event(xdev, &evtrb, 1) != 0) {\n\t\t\t\tUPRINTF(LFTL, \"Failed to inject command completion event!\\r\\n\");\n\t\t\t\treturn -ENAVAIL;\n\t\t\t}\n\t\t}\n\n\t\ttrb = pci_xhci_trb_next(xdev, trb, &crcr);\n\t\tif (!trb) {\n\t\t\tUPRINTF(LDBG, \"Get the invalid trb in %s!\\r\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\txdev->opregs.crcr = crcr | (xdev->opregs.crcr & XHCI_CRCR_LO_CA) | ccs;\n\txdev->opregs.crcr &= ~XHCI_CRCR_LO_CRR;\n\treturn 0;\n}",
  "abstract_func_before": "static int\npci_xhci_complete_commands(struct pci_xhci_vdev *VAR_0)\n{\n\tstruct xhci_trb\tVAR_1;\n\tstruct xhci_trb\t*VAR_2;\n\tuint64_t\tVAR_3;\n\tuint32_t\tVAR_4;\t\t/* COMMENT_0 */\n\tuint32_t\tVAR_5;\n\tuint32_t\tVAR_6;\n\tuint32_t\tVAR_7;\n\n\tVAR_0->opregs.crcr |= VAR_8;\n\n\tVAR_2 = VAR_0->opregs.cr_p;\n\tVAR_4 = VAR_0->opregs.crcr & VAR_9;\n\tVAR_3 = VAR_0->opregs.crcr & ~0xF;\n\n\twhile (1) {\n\t\tVAR_0->opregs.cr_p = VAR_2;\n\n\t\tVAR_5 = XHCI_TRB_3_TYPE_GET(VAR_2->dwTrb3);\n\n\t\tif ((VAR_2->dwTrb3 & VAR_10) !=\n\t\t    (VAR_4 & VAR_10))\n\t\t\tbreak;\n\n\t\tUPRINTF(VAR_11, \"cmd type 0x%x, Trb0 x%016lx dwTrb2 x%08x\"\n\t\t\t\" dwTrb3 x%08x, TRB_CYCLE %u/ccs %u\\r\\n\",\n\t\t\tVAR_5, VAR_2->qwTrb0, VAR_2->dwTrb2, VAR_2->dwTrb3,\n\t\t\tVAR_2->dwTrb3 & VAR_10, VAR_4);\n\n\t\tVAR_7 = VAR_12;\n\t\tVAR_1.dwTrb2 = 0;\n\t\tVAR_1.dwTrb3 = (VAR_4 & VAR_10) |\n\t\t      XHCI_TRB_3_TYPE_SET(VAR_13);\n\t\tVAR_6 = 0;\n\n\t\tswitch (VAR_5) {\n\t\tcase VAR_14:\t\t\t/* COMMENT_1 */\n\t\t\tif (VAR_2->dwTrb3 & VAR_15)\n\t\t\t\tVAR_4 ^= VAR_9;\n\t\t\tbreak;\n\n\t\tcase VAR_16:\t\t\t/* COMMENT_2 */\n\t\t\t/* COMMENT_3 */\n                                                  \n                                                 \n                                               \n        \n\t\t\tVAR_7 = pci_xhci_cmd_enable_slot(VAR_0, &VAR_6);\n\t\t\tbreak;\n\n\t\tcase VAR_17:\t\t/* COMMENT_8 */\n\t\t\tXHCI_GET_SLOT(VAR_0, VAR_2, VAR_6, VAR_7);\n\t\t\tif (VAR_6)\n\t\t\t\tVAR_7 = pci_xhci_cmd_disable_slot(VAR_0, VAR_6);\n\t\t\tbreak;\n\n\t\tcase VAR_18:\t\t/* COMMENT_9 */\n\t\t\tXHCI_GET_SLOT(VAR_0, VAR_2, VAR_6, VAR_7);\n\t\t\tif (VAR_6)\n\t\t\t\tVAR_7 = pci_xhci_cmd_address_device(VAR_0, VAR_6, VAR_2);\n\t\t\tbreak;\n\n\t\tcase VAR_19:\t\t/* COMMENT_10 */\n\t\t\tXHCI_GET_SLOT(VAR_0, VAR_2, VAR_6, VAR_7);\n\t\t\tif (VAR_6)\n\t\t\t\tVAR_7 = pci_xhci_cmd_config_ep(VAR_0, VAR_6, VAR_2);\n\t\t\tbreak;\n\n\t\tcase VAR_20:\t\t/* COMMENT_11 */\n\t\t\tXHCI_GET_SLOT(VAR_0, VAR_2, VAR_6, VAR_7);\n\t\t\tif (VAR_6)\n\t\t\t\tVAR_7 = pci_xhci_cmd_eval_ctx(VAR_0, VAR_6, VAR_2);\n\t\t\tbreak;\n\n\t\tcase VAR_21:\t\t\t/* COMMENT_12 */\n\t\t\tUPRINTF(VAR_11, \"Reset Endpoint on slot %d\\r\\n\", VAR_6);\n\t\t\tXHCI_GET_SLOT(VAR_0, VAR_2, VAR_6, VAR_7);\n\t\t\tif (VAR_6)\n\t\t\t\tVAR_7 = pci_xhci_cmd_reset_ep(VAR_0, VAR_6, VAR_2);\n\t\t\tbreak;\n\n\t\tcase VAR_22:\t\t\t/* COMMENT_13 */\n\t\t\tUPRINTF(VAR_11, \"Stop Endpoint on slot %d\\r\\n\", VAR_6);\n\t\t\tXHCI_GET_SLOT(VAR_0, VAR_2, VAR_6, VAR_7);\n\t\t\tif (VAR_6)\n\t\t\t\tVAR_7 = pci_xhci_cmd_reset_ep(VAR_0, VAR_6, VAR_2);\n\t\t\tbreak;\n\n\t\tcase VAR_23:\t\t/* COMMENT_14 */\n\t\t\tXHCI_GET_SLOT(VAR_0, VAR_2, VAR_6, VAR_7);\n\t\t\tif (VAR_6)\n\t\t\t\tVAR_7 = pci_xhci_cmd_set_tr(VAR_0, VAR_6, VAR_2);\n\t\t\tbreak;\n\n\t\tcase VAR_24:\t\t/* COMMENT_15 */\n\t\t\tXHCI_GET_SLOT(VAR_0, VAR_2, VAR_6, VAR_7);\n\t\t\tif (VAR_6)\n\t\t\t\tVAR_7 = pci_xhci_cmd_reset_device(VAR_0, VAR_6);\n\t\t\tbreak;\n\n\t\tcase VAR_25:\t\t\t/* COMMENT_16 */\n\t\t\t/* COMMENT_17 */\n\t\t\tbreak;\n\n\t\tcase VAR_26:\t\t/* COMMENT_18 */\n\t\t\tbreak;\n\n\t\tcase VAR_27:\t\t/* COMMENT_19 */\n\t\t\tbreak;\n\n\t\tcase VAR_28:\t\t\t/* COMMENT_20 */\n\t\t\tbreak;\n\n\t\tcase VAR_29:\t\t/* COMMENT_21 */\n\t\t\tbreak;\n\n\t\tcase VAR_30:\t\t\t/* COMMENT_22 */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tUPRINTF(VAR_11, \"unsupported cmd %x\\r\\n\", VAR_5);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (VAR_5 != VAR_14) {\n\t\t\t/* COMMENT_23 */\n                                                     \n      \n\t\t\tVAR_1.qwTrb0 = VAR_3;\n\t\t\tVAR_1.dwTrb2 |= XHCI_TRB_2_ERROR_SET(VAR_7);\n\t\t\tVAR_1.dwTrb3 |= XHCI_TRB_3_SLOT_SET(VAR_6);\n\t\t\tUPRINTF(VAR_11, \"command 0x%x result: 0x%x\\r\\n\",\n\t\t\t\tVAR_5, VAR_7);\n\t\t\tif (pci_xhci_insert_event(VAR_0, &VAR_1, 1) != 0) {\n\t\t\t\tUPRINTF(VAR_31, \"Failed to inject command completion event!\\r\\n\");\n\t\t\t\treturn -VAR_32;\n\t\t\t}\n\t\t}\n\n\t\tVAR_2 = pci_xhci_trb_next(VAR_0, VAR_2, &VAR_3);\n\t\tif (!VAR_2) {\n\t\t\tUPRINTF(VAR_11, \"Get the invalid trb in %s!\\r\\n\", VAR_33);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tVAR_0->opregs.crcr = VAR_3 | (VAR_0->opregs.crcr & VAR_34) | VAR_4;\n\tVAR_0->opregs.crcr &= ~VAR_8;\n\treturn 0;\n}",
  "func_graph_path_before": "projectacrn/acrn-hypervisor/330359921e2e4c2f3f3a10b5bab86942d63c4428/xhci.c/vul/before/0.json",
  "func": "static int\npci_xhci_complete_commands(struct pci_xhci_vdev *xdev)\n{\n\tstruct xhci_trb\tevtrb;\n\tstruct xhci_trb\t*trb;\n\tuint64_t\tcrcr;\n\tuint32_t\tccs;\t\t/* cycle state (XHCI 4.9.2) */\n\tuint32_t\ttype;\n\tuint32_t\tslot;\n\tuint32_t\tcmderr;\n\n\txdev->opregs.crcr |= XHCI_CRCR_LO_CRR;\n\n\ttrb = xdev->opregs.cr_p;\n\tccs = xdev->opregs.crcr & XHCI_CRCR_LO_RCS;\n\tcrcr = xdev->opregs.crcr & ~0xF;\n\tif (!trb) {\n\t\tUPRINTF(LDBG, \"Get the invalid guest address!\\r\\n\");\n\t\tgoto out;\n\t}\n\n\twhile (1) {\n\t\txdev->opregs.cr_p = trb;\n\n\t\ttype = XHCI_TRB_3_TYPE_GET(trb->dwTrb3);\n\n\t\tif ((trb->dwTrb3 & XHCI_TRB_3_CYCLE_BIT) !=\n\t\t    (ccs & XHCI_TRB_3_CYCLE_BIT))\n\t\t\tbreak;\n\n\t\tUPRINTF(LDBG, \"cmd type 0x%x, Trb0 x%016lx dwTrb2 x%08x\"\n\t\t\t\" dwTrb3 x%08x, TRB_CYCLE %u/ccs %u\\r\\n\",\n\t\t\ttype, trb->qwTrb0, trb->dwTrb2, trb->dwTrb3,\n\t\t\ttrb->dwTrb3 & XHCI_TRB_3_CYCLE_BIT, ccs);\n\n\t\tcmderr = XHCI_TRB_ERROR_SUCCESS;\n\t\tevtrb.dwTrb2 = 0;\n\t\tevtrb.dwTrb3 = (ccs & XHCI_TRB_3_CYCLE_BIT) |\n\t\t      XHCI_TRB_3_TYPE_SET(XHCI_TRB_EVENT_CMD_COMPLETE);\n\t\tslot = 0;\n\n\t\tswitch (type) {\n\t\tcase XHCI_TRB_TYPE_LINK:\t\t\t/* 0x06 */\n\t\t\tif (trb->dwTrb3 & XHCI_TRB_3_TC_BIT)\n\t\t\t\tccs ^= XHCI_CRCR_LO_RCS;\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_ENABLE_SLOT:\t\t\t/* 0x09 */\n\t\t\t/*\n\t\t\t *From xHCI spec 4.5.3.2, the only command that\n\t\t\t *software is allowed to issue for the slot in\n\t\t\t *disabled state is the Enable Slot Command.\n\t\t\t * */\n\t\t\tcmderr = pci_xhci_cmd_enable_slot(xdev, &slot);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_DISABLE_SLOT:\t\t/* 0x0A */\n\t\t\tXHCI_GET_SLOT(xdev, trb, slot, cmderr);\n\t\t\tif (slot)\n\t\t\t\tcmderr = pci_xhci_cmd_disable_slot(xdev, slot);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_ADDRESS_DEVICE:\t\t/* 0x0B */\n\t\t\tXHCI_GET_SLOT(xdev, trb, slot, cmderr);\n\t\t\tif (slot)\n\t\t\t\tcmderr = pci_xhci_cmd_address_device(xdev, slot, trb);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_CONFIGURE_EP:\t\t/* 0x0C */\n\t\t\tXHCI_GET_SLOT(xdev, trb, slot, cmderr);\n\t\t\tif (slot)\n\t\t\t\tcmderr = pci_xhci_cmd_config_ep(xdev, slot, trb);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_EVALUATE_CTX:\t\t/* 0x0D */\n\t\t\tXHCI_GET_SLOT(xdev, trb, slot, cmderr);\n\t\t\tif (slot)\n\t\t\t\tcmderr = pci_xhci_cmd_eval_ctx(xdev, slot, trb);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_RESET_EP:\t\t\t/* 0x0E */\n\t\t\tUPRINTF(LDBG, \"Reset Endpoint on slot %d\\r\\n\", slot);\n\t\t\tXHCI_GET_SLOT(xdev, trb, slot, cmderr);\n\t\t\tif (slot)\n\t\t\t\tcmderr = pci_xhci_cmd_reset_ep(xdev, slot, trb);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_STOP_EP:\t\t\t/* 0x0F */\n\t\t\tUPRINTF(LDBG, \"Stop Endpoint on slot %d\\r\\n\", slot);\n\t\t\tXHCI_GET_SLOT(xdev, trb, slot, cmderr);\n\t\t\tif (slot)\n\t\t\t\tcmderr = pci_xhci_cmd_reset_ep(xdev, slot, trb);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_SET_TR_DEQUEUE:\t\t/* 0x10 */\n\t\t\tXHCI_GET_SLOT(xdev, trb, slot, cmderr);\n\t\t\tif (slot)\n\t\t\t\tcmderr = pci_xhci_cmd_set_tr(xdev, slot, trb);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_RESET_DEVICE:\t\t/* 0x11 */\n\t\t\tXHCI_GET_SLOT(xdev, trb, slot, cmderr);\n\t\t\tif (slot)\n\t\t\t\tcmderr = pci_xhci_cmd_reset_device(xdev, slot);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_FORCE_EVENT:\t\t\t/* 0x12 */\n\t\t\t/* TODO: */\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_NEGOTIATE_BW:\t\t/* 0x13 */\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_SET_LATENCY_TOL:\t\t/* 0x14 */\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_GET_PORT_BW:\t\t\t/* 0x15 */\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_FORCE_HEADER:\t\t/* 0x16 */\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_NOOP_CMD:\t\t\t/* 0x17 */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tUPRINTF(LDBG, \"unsupported cmd %x\\r\\n\", type);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (type != XHCI_TRB_TYPE_LINK) {\n\t\t\t/*\n\t\t\t * insert command completion event and assert intr\n\t\t\t */\n\t\t\tevtrb.qwTrb0 = crcr;\n\t\t\tevtrb.dwTrb2 |= XHCI_TRB_2_ERROR_SET(cmderr);\n\t\t\tevtrb.dwTrb3 |= XHCI_TRB_3_SLOT_SET(slot);\n\t\t\tUPRINTF(LDBG, \"command 0x%x result: 0x%x\\r\\n\",\n\t\t\t\ttype, cmderr);\n\t\t\tif (pci_xhci_insert_event(xdev, &evtrb, 1) != 0) {\n\t\t\t\tUPRINTF(LFTL, \"Failed to inject command completion event!\\r\\n\");\n\t\t\t\treturn -ENAVAIL;\n\t\t\t}\n\t\t}\n\n\t\ttrb = pci_xhci_trb_next(xdev, trb, &crcr);\n\t\tif (!trb) {\n\t\t\tUPRINTF(LDBG, \"Get the invalid trb in %s!\\r\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\txdev->opregs.crcr = crcr | (xdev->opregs.crcr & XHCI_CRCR_LO_CA) | ccs;\n\txdev->opregs.crcr &= ~XHCI_CRCR_LO_CRR;\n\treturn 0;\n}",
  "abstract_func": "static int\npci_xhci_complete_commands(struct pci_xhci_vdev *VAR_0)\n{\n\tstruct xhci_trb\tVAR_1;\n\tstruct xhci_trb\t*VAR_2;\n\tuint64_t\tVAR_3;\n\tuint32_t\tVAR_4;\t\t/* COMMENT_0 */\n\tuint32_t\tVAR_5;\n\tuint32_t\tVAR_6;\n\tuint32_t\tVAR_7;\n\n\tVAR_0->opregs.crcr |= VAR_8;\n\n\tVAR_2 = VAR_0->opregs.cr_p;\n\tVAR_4 = VAR_0->opregs.crcr & VAR_9;\n\tVAR_3 = VAR_0->opregs.crcr & ~0xF;\n\tif (!VAR_2) {\n\t\tUPRINTF(VAR_10, \"Get the invalid guest address!\\r\\n\");\n\t\tgoto out;\n\t}\n\n\twhile (1) {\n\t\tVAR_0->opregs.cr_p = VAR_2;\n\n\t\tVAR_5 = XHCI_TRB_3_TYPE_GET(VAR_2->dwTrb3);\n\n\t\tif ((VAR_2->dwTrb3 & VAR_11) !=\n\t\t    (VAR_4 & VAR_11))\n\t\t\tbreak;\n\n\t\tUPRINTF(VAR_10, \"cmd type 0x%x, Trb0 x%016lx dwTrb2 x%08x\"\n\t\t\t\" dwTrb3 x%08x, TRB_CYCLE %u/ccs %u\\r\\n\",\n\t\t\tVAR_5, VAR_2->qwTrb0, VAR_2->dwTrb2, VAR_2->dwTrb3,\n\t\t\tVAR_2->dwTrb3 & VAR_11, VAR_4);\n\n\t\tVAR_7 = VAR_12;\n\t\tVAR_1.dwTrb2 = 0;\n\t\tVAR_1.dwTrb3 = (VAR_4 & VAR_11) |\n\t\t      XHCI_TRB_3_TYPE_SET(VAR_13);\n\t\tVAR_6 = 0;\n\n\t\tswitch (VAR_5) {\n\t\tcase VAR_14:\t\t\t/* COMMENT_1 */\n\t\t\tif (VAR_2->dwTrb3 & VAR_15)\n\t\t\t\tVAR_4 ^= VAR_9;\n\t\t\tbreak;\n\n\t\tcase VAR_16:\t\t\t/* COMMENT_2 */\n\t\t\t/* COMMENT_3 */\n                                                  \n                                                 \n                                               \n        \n\t\t\tVAR_7 = pci_xhci_cmd_enable_slot(VAR_0, &VAR_6);\n\t\t\tbreak;\n\n\t\tcase VAR_17:\t\t/* COMMENT_8 */\n\t\t\tXHCI_GET_SLOT(VAR_0, VAR_2, VAR_6, VAR_7);\n\t\t\tif (VAR_6)\n\t\t\t\tVAR_7 = pci_xhci_cmd_disable_slot(VAR_0, VAR_6);\n\t\t\tbreak;\n\n\t\tcase VAR_18:\t\t/* COMMENT_9 */\n\t\t\tXHCI_GET_SLOT(VAR_0, VAR_2, VAR_6, VAR_7);\n\t\t\tif (VAR_6)\n\t\t\t\tVAR_7 = pci_xhci_cmd_address_device(VAR_0, VAR_6, VAR_2);\n\t\t\tbreak;\n\n\t\tcase VAR_19:\t\t/* COMMENT_10 */\n\t\t\tXHCI_GET_SLOT(VAR_0, VAR_2, VAR_6, VAR_7);\n\t\t\tif (VAR_6)\n\t\t\t\tVAR_7 = pci_xhci_cmd_config_ep(VAR_0, VAR_6, VAR_2);\n\t\t\tbreak;\n\n\t\tcase VAR_20:\t\t/* COMMENT_11 */\n\t\t\tXHCI_GET_SLOT(VAR_0, VAR_2, VAR_6, VAR_7);\n\t\t\tif (VAR_6)\n\t\t\t\tVAR_7 = pci_xhci_cmd_eval_ctx(VAR_0, VAR_6, VAR_2);\n\t\t\tbreak;\n\n\t\tcase VAR_21:\t\t\t/* COMMENT_12 */\n\t\t\tUPRINTF(VAR_10, \"Reset Endpoint on slot %d\\r\\n\", VAR_6);\n\t\t\tXHCI_GET_SLOT(VAR_0, VAR_2, VAR_6, VAR_7);\n\t\t\tif (VAR_6)\n\t\t\t\tVAR_7 = pci_xhci_cmd_reset_ep(VAR_0, VAR_6, VAR_2);\n\t\t\tbreak;\n\n\t\tcase VAR_22:\t\t\t/* COMMENT_13 */\n\t\t\tUPRINTF(VAR_10, \"Stop Endpoint on slot %d\\r\\n\", VAR_6);\n\t\t\tXHCI_GET_SLOT(VAR_0, VAR_2, VAR_6, VAR_7);\n\t\t\tif (VAR_6)\n\t\t\t\tVAR_7 = pci_xhci_cmd_reset_ep(VAR_0, VAR_6, VAR_2);\n\t\t\tbreak;\n\n\t\tcase VAR_23:\t\t/* COMMENT_14 */\n\t\t\tXHCI_GET_SLOT(VAR_0, VAR_2, VAR_6, VAR_7);\n\t\t\tif (VAR_6)\n\t\t\t\tVAR_7 = pci_xhci_cmd_set_tr(VAR_0, VAR_6, VAR_2);\n\t\t\tbreak;\n\n\t\tcase VAR_24:\t\t/* COMMENT_15 */\n\t\t\tXHCI_GET_SLOT(VAR_0, VAR_2, VAR_6, VAR_7);\n\t\t\tif (VAR_6)\n\t\t\t\tVAR_7 = pci_xhci_cmd_reset_device(VAR_0, VAR_6);\n\t\t\tbreak;\n\n\t\tcase VAR_25:\t\t\t/* COMMENT_16 */\n\t\t\t/* COMMENT_17 */\n\t\t\tbreak;\n\n\t\tcase VAR_26:\t\t/* COMMENT_18 */\n\t\t\tbreak;\n\n\t\tcase VAR_27:\t\t/* COMMENT_19 */\n\t\t\tbreak;\n\n\t\tcase VAR_28:\t\t\t/* COMMENT_20 */\n\t\t\tbreak;\n\n\t\tcase VAR_29:\t\t/* COMMENT_21 */\n\t\t\tbreak;\n\n\t\tcase VAR_30:\t\t\t/* COMMENT_22 */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tUPRINTF(VAR_10, \"unsupported cmd %x\\r\\n\", VAR_5);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (VAR_5 != VAR_14) {\n\t\t\t/* COMMENT_23 */\n                                                     \n      \n\t\t\tVAR_1.qwTrb0 = VAR_3;\n\t\t\tVAR_1.dwTrb2 |= XHCI_TRB_2_ERROR_SET(VAR_7);\n\t\t\tVAR_1.dwTrb3 |= XHCI_TRB_3_SLOT_SET(VAR_6);\n\t\t\tUPRINTF(VAR_10, \"command 0x%x result: 0x%x\\r\\n\",\n\t\t\t\tVAR_5, VAR_7);\n\t\t\tif (pci_xhci_insert_event(VAR_0, &VAR_1, 1) != 0) {\n\t\t\t\tUPRINTF(VAR_31, \"Failed to inject command completion event!\\r\\n\");\n\t\t\t\treturn -VAR_32;\n\t\t\t}\n\t\t}\n\n\t\tVAR_2 = pci_xhci_trb_next(VAR_0, VAR_2, &VAR_3);\n\t\tif (!VAR_2) {\n\t\t\tUPRINTF(VAR_10, \"Get the invalid trb in %s!\\r\\n\", VAR_33);\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tVAR_0->opregs.crcr = VAR_3 | (VAR_0->opregs.crcr & VAR_34) | VAR_4;\n\tVAR_0->opregs.crcr &= ~VAR_8;\n\treturn 0;\n}",
  "func_graph_path": "projectacrn/acrn-hypervisor/330359921e2e4c2f3f3a10b5bab86942d63c4428/xhci.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -14,6 +14,10 @@\n \ttrb = xdev->opregs.cr_p;\n \tccs = xdev->opregs.crcr & XHCI_CRCR_LO_RCS;\n \tcrcr = xdev->opregs.crcr & ~0xF;\n+\tif (!trb) {\n+\t\tUPRINTF(LDBG, \"Get the invalid guest address!\\r\\n\");\n+\t\tgoto out;\n+\t}\n \n \twhile (1) {\n \t\txdev->opregs.cr_p = trb;\n@@ -146,6 +150,7 @@\n \t\t}\n \t}\n \n+out:\n \txdev->opregs.crcr = crcr | (xdev->opregs.crcr & XHCI_CRCR_LO_CA) | ccs;\n \txdev->opregs.crcr &= ~XHCI_CRCR_LO_CRR;\n \treturn 0;",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "\tif (!trb) {",
      "\t\tUPRINTF(LDBG, \"Get the invalid guest address!\\r\\n\");",
      "\t\tgoto out;",
      "\t}",
      "out:"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/projectacrn/acrn-hypervisor/pull/6173",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/projectacrn/acrn-hypervisor/pull/6173: 403 Client Error: Forbidden for url: https://api.github.com/repos/projectacrn/acrn-hypervisor/pulls/6173",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.9  \n\nThe patch addresses a potential null pointer dereference issue, which is a security concern. The added check prevents a crash from an invalid user-space address, indicating a security fix with high confidence."
}