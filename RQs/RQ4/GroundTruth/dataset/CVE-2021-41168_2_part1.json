{
  "cve_id": "CVE-2021-41168",
  "cwe_ids": [
    "CWE-407"
  ],
  "cvss_vector": "AV:N/AC:L/Au:S/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "reddit/snudown",
  "commit_msg": "Hash-collision denial-of-service vulnerabilities (#87)\n\n* Add case insensitive SipHash implementation\n* Replace ref hash function with SipHash\n* Add label to link_ref struct.\n* Update find_link_ref to compare link labels as well as hashes\n* Update add_link_ref to disallow duplicate entries.\n* cast to char from uint8_t for strncasecmp\n* update README markdown, remove TODO\n* add py2 wheel generation\n* fix: add logic for older glibc not having getrandom, impacting staging\n\nCo-authored-by: Nicolaas <nweidema@usc.edu>",
  "commit_hash": "1ac2c130b210539ee1e5d67a7bac93f9d8007c0e",
  "git_url": "https://github.com/reddit/snudown/commit/1ac2c130b210539ee1e5d67a7bac93f9d8007c0e",
  "file_path": "src/markdown.c",
  "func_name": "is_ref",
  "func_before": "static int\nis_ref(const uint8_t *data, size_t beg, size_t end, size_t *last, struct link_ref **refs)\n{\n/*\tint n; */\n\tsize_t i = 0;\n\tsize_t id_offset, id_end;\n\tsize_t link_offset, link_end;\n\tsize_t title_offset, title_end;\n\tsize_t line_end;\n\n\t/* up to 3 optional leading spaces */\n\tif (beg + 3 >= end) return 0;\n\tif (data[beg] == ' ') { i = 1;\n\tif (data[beg + 1] == ' ') { i = 2;\n\tif (data[beg + 2] == ' ') { i = 3;\n\tif (data[beg + 3] == ' ') return 0; } } }\n\ti += beg;\n\n\t/* id part: anything but a newline between brackets */\n\tif (data[i] != '[') return 0;\n\ti++;\n\tid_offset = i;\n\twhile (i < end && data[i] != '\\n' && data[i] != '\\r' && data[i] != ']')\n\t\ti++;\n\tif (i >= end || data[i] != ']') return 0;\n\tid_end = i;\n\n\t/* spacer: colon (space | tab)* newline? (space | tab)* */\n\ti++;\n\tif (i >= end || data[i] != ':') return 0;\n\ti++;\n\twhile (i < end && data[i] == ' ') i++;\n\tif (i < end && (data[i] == '\\n' || data[i] == '\\r')) {\n\t\ti++;\n\t\tif (i < end && data[i] == '\\r' && data[i - 1] == '\\n') i++; }\n\twhile (i < end && data[i] == ' ') i++;\n\tif (i >= end) return 0;\n\n\t/* link: whitespace-free sequence, optionally between angle brackets */\n\tif (data[i] == '<')\n\t\ti++;\n\n\tlink_offset = i;\n\n\twhile (i < end && data[i] != ' ' && data[i] != '\\n' && data[i] != '\\r')\n\t\ti++;\n\n\tif (data[i - 1] == '>') link_end = i - 1;\n\telse link_end = i;\n\n\t/* optional spacer: (space | tab)* (newline | '\\'' | '\"' | '(' ) */\n\twhile (i < end && data[i] == ' ') i++;\n\tif (i < end && data[i] != '\\n' && data[i] != '\\r'\n\t\t\t&& data[i] != '\\'' && data[i] != '\"' && data[i] != '(')\n\t\treturn 0;\n\tline_end = 0;\n\t/* computing end-of-line */\n\tif (i >= end || data[i] == '\\r' || data[i] == '\\n') line_end = i;\n\tif (i + 1 < end && data[i] == '\\n' && data[i + 1] == '\\r')\n\t\tline_end = i + 1;\n\n\t/* optional (space|tab)* spacer after a newline */\n\tif (line_end) {\n\t\ti = line_end + 1;\n\t\twhile (i < end && data[i] == ' ') i++; }\n\n\t/* optional title: any non-newline sequence enclosed in '\"()\n\t\t\t\t\talone on its line */\n\ttitle_offset = title_end = 0;\n\tif (i + 1 < end\n\t&& (data[i] == '\\'' || data[i] == '\"' || data[i] == '(')) {\n\t\ti++;\n\t\ttitle_offset = i;\n\t\t/* looking for EOL */\n\t\twhile (i < end && data[i] != '\\n' && data[i] != '\\r') i++;\n\t\tif (i + 1 < end && data[i] == '\\n' && data[i + 1] == '\\r')\n\t\t\ttitle_end = i + 1;\n\t\telse\ttitle_end = i;\n\t\t/* stepping back */\n\t\ti -= 1;\n\t\twhile (i > title_offset && data[i] == ' ')\n\t\t\ti -= 1;\n\t\tif (i > title_offset\n\t\t&& (data[i] == '\\'' || data[i] == '\"' || data[i] == ')')) {\n\t\t\tline_end = title_end;\n\t\t\ttitle_end = i; } }\n\n\tif (!line_end || link_end == link_offset)\n\t\treturn 0; /* garbage after the link empty link */\n\n\t/* a valid ref has been found, filling-in return structures */\n\tif (last)\n\t\t*last = line_end;\n\n\tif (refs) {\n\t\tstruct link_ref *ref;\n\n\t\tref = add_link_ref(refs, data + id_offset, id_end - id_offset);\n\t\tif (!ref)\n\t\t\treturn 0;\n\n\t\tref->link = bufnew(link_end - link_offset);\n\t\tbufput(ref->link, data + link_offset, link_end - link_offset);\n\n\t\tif (title_end > title_offset) {\n\t\t\tref->title = bufnew(title_end - title_offset);\n\t\t\tbufput(ref->title, data + title_offset, title_end - title_offset);\n\t\t}\n\t}\n\n\treturn 1;\n}",
  "abstract_func_before": "static int\nis_ref(const uint8_t *VAR_0, size_t VAR_1, size_t VAR_2, size_t *VAR_3, struct link_ref **VAR_4)\n{\n/* COMMENT_0 */\n\tsize_t VAR_5 = 0;\n\tsize_t VAR_6, VAR_7;\n\tsize_t VAR_8, VAR_9;\n\tsize_t VAR_10, VAR_11;\n\tsize_t VAR_12;\n\n\t/* COMMENT_1 */\n\tif (VAR_1 + 3 >= VAR_2) return 0;\n\tif (VAR_0[VAR_1] == ' ') { VAR_5 = 1;\n\tif (VAR_0[VAR_1 + 1] == ' ') { VAR_5 = 2;\n\tif (VAR_0[VAR_1 + 2] == ' ') { VAR_5 = 3;\n\tif (VAR_0[VAR_1 + 3] == ' ') return 0; } } }\n\tVAR_5 += VAR_1;\n\n\t/* COMMENT_2 */\n\tif (VAR_0[VAR_5] != '[') return 0;\n\tVAR_5++;\n\tVAR_6 = VAR_5;\n\twhile (VAR_5 < VAR_2 && VAR_0[VAR_5] != '\\n' && VAR_0[VAR_5] != '\\r' && VAR_0[VAR_5] != ']')\n\t\tVAR_5++;\n\tif (VAR_5 >= VAR_2 || VAR_0[VAR_5] != ']') return 0;\n\tVAR_7 = VAR_5;\n\n\t/* COMMENT_3 */\n\tVAR_5++;\n\tif (VAR_5 >= VAR_2 || VAR_0[VAR_5] != ':') return 0;\n\tVAR_5++;\n\twhile (VAR_5 < VAR_2 && VAR_0[VAR_5] == ' ') VAR_5++;\n\tif (VAR_5 < VAR_2 && (VAR_0[VAR_5] == '\\n' || VAR_0[VAR_5] == '\\r')) {\n\t\tVAR_5++;\n\t\tif (VAR_5 < VAR_2 && VAR_0[VAR_5] == '\\r' && VAR_0[VAR_5 - 1] == '\\n') VAR_5++; }\n\twhile (VAR_5 < VAR_2 && VAR_0[VAR_5] == ' ') VAR_5++;\n\tif (VAR_5 >= VAR_2) return 0;\n\n\t/* COMMENT_4 */\n\tif (VAR_0[VAR_5] == '<')\n\t\tVAR_5++;\n\n\tVAR_8 = VAR_5;\n\n\twhile (VAR_5 < VAR_2 && VAR_0[VAR_5] != ' ' && VAR_0[VAR_5] != '\\n' && VAR_0[VAR_5] != '\\r')\n\t\tVAR_5++;\n\n\tif (VAR_0[VAR_5 - 1] == '>') VAR_9 = VAR_5 - 1;\n\telse VAR_9 = VAR_5;\n\n\t/* COMMENT_5 */\n\twhile (VAR_5 < VAR_2 && VAR_0[VAR_5] == ' ') VAR_5++;\n\tif (VAR_5 < VAR_2 && VAR_0[VAR_5] != '\\n' && VAR_0[VAR_5] != '\\r'\n\t\t\t&& VAR_0[VAR_5] != '\\'' && VAR_0[VAR_5] != '\"' && VAR_0[VAR_5] != '(')\n\t\treturn 0;\n\tVAR_12 = 0;\n\t/* COMMENT_6 */\n\tif (VAR_5 >= VAR_2 || VAR_0[VAR_5] == '\\r' || VAR_0[VAR_5] == '\\n') VAR_12 = VAR_5;\n\tif (VAR_5 + 1 < VAR_2 && VAR_0[VAR_5] == '\\n' && VAR_0[VAR_5 + 1] == '\\r')\n\t\tVAR_12 = VAR_5 + 1;\n\n\t/* COMMENT_7 */\n\tif (VAR_12) {\n\t\tVAR_5 = VAR_12 + 1;\n\t\twhile (VAR_5 < VAR_2 && VAR_0[VAR_5] == ' ') VAR_5++; }\n\n\t/* COMMENT_8 */\n                         \n\tVAR_10 = VAR_11 = 0;\n\tif (VAR_5 + 1 < VAR_2\n\t&& (VAR_0[VAR_5] == '\\'' || VAR_0[VAR_5] == '\"' || VAR_0[VAR_5] == '(')) {\n\t\tVAR_5++;\n\t\tVAR_10 = VAR_5;\n\t\t/* COMMENT_10 */\n\t\twhile (VAR_5 < VAR_2 && VAR_0[VAR_5] != '\\n' && VAR_0[VAR_5] != '\\r') VAR_5++;\n\t\tif (VAR_5 + 1 < VAR_2 && VAR_0[VAR_5] == '\\n' && VAR_0[VAR_5 + 1] == '\\r')\n\t\t\tVAR_11 = VAR_5 + 1;\n\t\telse\tVAR_11 = VAR_5;\n\t\t/* COMMENT_11 */\n\t\tVAR_5 -= 1;\n\t\twhile (VAR_5 > VAR_10 && VAR_0[VAR_5] == ' ')\n\t\t\tVAR_5 -= 1;\n\t\tif (VAR_5 > VAR_10\n\t\t&& (VAR_0[VAR_5] == '\\'' || VAR_0[VAR_5] == '\"' || VAR_0[VAR_5] == ')')) {\n\t\t\tVAR_12 = VAR_11;\n\t\t\tVAR_11 = VAR_5; } }\n\n\tif (!VAR_12 || VAR_9 == VAR_8)\n\t\treturn 0; /* COMMENT_12 */\n\n\t/* COMMENT_13 */\n\tif (VAR_3)\n\t\t*VAR_3 = VAR_12;\n\n\tif (VAR_4) {\n\t\tstruct link_ref *VAR_13;\n\n\t\tVAR_13 = add_link_ref(VAR_4, VAR_0 + VAR_6, VAR_7 - VAR_6);\n\t\tif (!VAR_13)\n\t\t\treturn 0;\n\n\t\tVAR_13->link = bufnew(VAR_9 - VAR_8);\n\t\tbufput(VAR_13->link, VAR_0 + VAR_8, VAR_9 - VAR_8);\n\n\t\tif (VAR_11 > VAR_10) {\n\t\t\tVAR_13->title = bufnew(VAR_11 - VAR_10);\n\t\t\tbufput(VAR_13->title, VAR_0 + VAR_10, VAR_11 - VAR_10);\n\t\t}\n\t}\n\n\treturn 1;\n}",
  "func_graph_path_before": "reddit/snudown/1ac2c130b210539ee1e5d67a7bac93f9d8007c0e/markdown.c/vul/before/3.json",
  "func": "static int\nis_ref(const uint8_t *data, size_t beg, size_t end, size_t *last, struct link_ref **refs)\n{\n/*\tint n; */\n\tsize_t i = 0;\n\tsize_t id_offset, id_end;\n\tsize_t link_offset, link_end;\n\tsize_t title_offset, title_end;\n\tsize_t line_end;\n\n\t/* up to 3 optional leading spaces */\n\tif (beg + 3 >= end) return 0;\n\tif (data[beg] == ' ') { i = 1;\n\tif (data[beg + 1] == ' ') { i = 2;\n\tif (data[beg + 2] == ' ') { i = 3;\n\tif (data[beg + 3] == ' ') return 0; } } }\n\ti += beg;\n\n\t/* id part: anything but a newline between brackets */\n\tif (data[i] != '[') return 0;\n\ti++;\n\tid_offset = i;\n\twhile (i < end && data[i] != '\\n' && data[i] != '\\r' && data[i] != ']')\n\t\ti++;\n\tif (i >= end || data[i] != ']') return 0;\n\tid_end = i;\n\n\t/* spacer: colon (space | tab)* newline? (space | tab)* */\n\ti++;\n\tif (i >= end || data[i] != ':') return 0;\n\ti++;\n\twhile (i < end && data[i] == ' ') i++;\n\tif (i < end && (data[i] == '\\n' || data[i] == '\\r')) {\n\t\ti++;\n\t\tif (i < end && data[i] == '\\r' && data[i - 1] == '\\n') i++; }\n\twhile (i < end && data[i] == ' ') i++;\n\tif (i >= end) return 0;\n\n\t/* link: whitespace-free sequence, optionally between angle brackets */\n\tif (data[i] == '<')\n\t\ti++;\n\n\tlink_offset = i;\n\n\twhile (i < end && data[i] != ' ' && data[i] != '\\n' && data[i] != '\\r')\n\t\ti++;\n\n\tif (data[i - 1] == '>') link_end = i - 1;\n\telse link_end = i;\n\n\t/* optional spacer: (space | tab)* (newline | '\\'' | '\"' | '(' ) */\n\twhile (i < end && data[i] == ' ') i++;\n\tif (i < end && data[i] != '\\n' && data[i] != '\\r'\n\t\t\t&& data[i] != '\\'' && data[i] != '\"' && data[i] != '(')\n\t\treturn 0;\n\tline_end = 0;\n\t/* computing end-of-line */\n\tif (i >= end || data[i] == '\\r' || data[i] == '\\n') line_end = i;\n\tif (i + 1 < end && data[i] == '\\n' && data[i + 1] == '\\r')\n\t\tline_end = i + 1;\n\n\t/* optional (space|tab)* spacer after a newline */\n\tif (line_end) {\n\t\ti = line_end + 1;\n\t\twhile (i < end && data[i] == ' ') i++; }\n\n\t/* optional title: any non-newline sequence enclosed in '\"()\n\t\t\t\t\talone on its line */\n\ttitle_offset = title_end = 0;\n\tif (i + 1 < end\n\t&& (data[i] == '\\'' || data[i] == '\"' || data[i] == '(')) {\n\t\ti++;\n\t\ttitle_offset = i;\n\t\t/* looking for EOL */\n\t\twhile (i < end && data[i] != '\\n' && data[i] != '\\r') i++;\n\t\tif (i + 1 < end && data[i] == '\\n' && data[i + 1] == '\\r')\n\t\t\ttitle_end = i + 1;\n\t\telse\ttitle_end = i;\n\t\t/* stepping back */\n\t\ti -= 1;\n\t\twhile (i > title_offset && data[i] == ' ')\n\t\t\ti -= 1;\n\t\tif (i > title_offset\n\t\t&& (data[i] == '\\'' || data[i] == '\"' || data[i] == ')')) {\n\t\t\tline_end = title_end;\n\t\t\ttitle_end = i; } }\n\n\tif (!line_end || link_end == link_offset)\n\t\treturn 0; /* garbage after the link empty link */\n\n\t/* a valid ref has been found, filling-in return structures */\n\tif (last)\n\t\t*last = line_end;\n\n\tif (refs) {\n\t\tstruct link_ref *ref;\n\n\t\tref = add_link_ref(refs, data + id_offset, id_end - id_offset);\n\t\tif (!ref)\n\t\t\treturn 0;\n\n\t\tref->label = bufnew(id_end - id_offset);\n\t\tbufput(ref->label, data + id_offset, id_end - id_offset);\n\t\tref->link = bufnew(link_end - link_offset);\n\t\tbufput(ref->link, data + link_offset, link_end - link_offset);\n\n\t\tif (title_end > title_offset) {\n\t\t\tref->title = bufnew(title_end - title_offset);\n\t\t\tbufput(ref->title, data + title_offset, title_end - title_offset);\n\t\t}\n\t}\n\n\treturn 1;\n}",
  "abstract_func": "static int\nis_ref(const uint8_t *VAR_0, size_t VAR_1, size_t VAR_2, size_t *VAR_3, struct link_ref **VAR_4)\n{\n/* COMMENT_0 */\n\tsize_t VAR_5 = 0;\n\tsize_t VAR_6, VAR_7;\n\tsize_t VAR_8, VAR_9;\n\tsize_t VAR_10, VAR_11;\n\tsize_t VAR_12;\n\n\t/* COMMENT_1 */\n\tif (VAR_1 + 3 >= VAR_2) return 0;\n\tif (VAR_0[VAR_1] == ' ') { VAR_5 = 1;\n\tif (VAR_0[VAR_1 + 1] == ' ') { VAR_5 = 2;\n\tif (VAR_0[VAR_1 + 2] == ' ') { VAR_5 = 3;\n\tif (VAR_0[VAR_1 + 3] == ' ') return 0; } } }\n\tVAR_5 += VAR_1;\n\n\t/* COMMENT_2 */\n\tif (VAR_0[VAR_5] != '[') return 0;\n\tVAR_5++;\n\tVAR_6 = VAR_5;\n\twhile (VAR_5 < VAR_2 && VAR_0[VAR_5] != '\\n' && VAR_0[VAR_5] != '\\r' && VAR_0[VAR_5] != ']')\n\t\tVAR_5++;\n\tif (VAR_5 >= VAR_2 || VAR_0[VAR_5] != ']') return 0;\n\tVAR_7 = VAR_5;\n\n\t/* COMMENT_3 */\n\tVAR_5++;\n\tif (VAR_5 >= VAR_2 || VAR_0[VAR_5] != ':') return 0;\n\tVAR_5++;\n\twhile (VAR_5 < VAR_2 && VAR_0[VAR_5] == ' ') VAR_5++;\n\tif (VAR_5 < VAR_2 && (VAR_0[VAR_5] == '\\n' || VAR_0[VAR_5] == '\\r')) {\n\t\tVAR_5++;\n\t\tif (VAR_5 < VAR_2 && VAR_0[VAR_5] == '\\r' && VAR_0[VAR_5 - 1] == '\\n') VAR_5++; }\n\twhile (VAR_5 < VAR_2 && VAR_0[VAR_5] == ' ') VAR_5++;\n\tif (VAR_5 >= VAR_2) return 0;\n\n\t/* COMMENT_4 */\n\tif (VAR_0[VAR_5] == '<')\n\t\tVAR_5++;\n\n\tVAR_8 = VAR_5;\n\n\twhile (VAR_5 < VAR_2 && VAR_0[VAR_5] != ' ' && VAR_0[VAR_5] != '\\n' && VAR_0[VAR_5] != '\\r')\n\t\tVAR_5++;\n\n\tif (VAR_0[VAR_5 - 1] == '>') VAR_9 = VAR_5 - 1;\n\telse VAR_9 = VAR_5;\n\n\t/* COMMENT_5 */\n\twhile (VAR_5 < VAR_2 && VAR_0[VAR_5] == ' ') VAR_5++;\n\tif (VAR_5 < VAR_2 && VAR_0[VAR_5] != '\\n' && VAR_0[VAR_5] != '\\r'\n\t\t\t&& VAR_0[VAR_5] != '\\'' && VAR_0[VAR_5] != '\"' && VAR_0[VAR_5] != '(')\n\t\treturn 0;\n\tVAR_12 = 0;\n\t/* COMMENT_6 */\n\tif (VAR_5 >= VAR_2 || VAR_0[VAR_5] == '\\r' || VAR_0[VAR_5] == '\\n') VAR_12 = VAR_5;\n\tif (VAR_5 + 1 < VAR_2 && VAR_0[VAR_5] == '\\n' && VAR_0[VAR_5 + 1] == '\\r')\n\t\tVAR_12 = VAR_5 + 1;\n\n\t/* COMMENT_7 */\n\tif (VAR_12) {\n\t\tVAR_5 = VAR_12 + 1;\n\t\twhile (VAR_5 < VAR_2 && VAR_0[VAR_5] == ' ') VAR_5++; }\n\n\t/* COMMENT_8 */\n                         \n\tVAR_10 = VAR_11 = 0;\n\tif (VAR_5 + 1 < VAR_2\n\t&& (VAR_0[VAR_5] == '\\'' || VAR_0[VAR_5] == '\"' || VAR_0[VAR_5] == '(')) {\n\t\tVAR_5++;\n\t\tVAR_10 = VAR_5;\n\t\t/* COMMENT_10 */\n\t\twhile (VAR_5 < VAR_2 && VAR_0[VAR_5] != '\\n' && VAR_0[VAR_5] != '\\r') VAR_5++;\n\t\tif (VAR_5 + 1 < VAR_2 && VAR_0[VAR_5] == '\\n' && VAR_0[VAR_5 + 1] == '\\r')\n\t\t\tVAR_11 = VAR_5 + 1;\n\t\telse\tVAR_11 = VAR_5;\n\t\t/* COMMENT_11 */\n\t\tVAR_5 -= 1;\n\t\twhile (VAR_5 > VAR_10 && VAR_0[VAR_5] == ' ')\n\t\t\tVAR_5 -= 1;\n\t\tif (VAR_5 > VAR_10\n\t\t&& (VAR_0[VAR_5] == '\\'' || VAR_0[VAR_5] == '\"' || VAR_0[VAR_5] == ')')) {\n\t\t\tVAR_12 = VAR_11;\n\t\t\tVAR_11 = VAR_5; } }\n\n\tif (!VAR_12 || VAR_9 == VAR_8)\n\t\treturn 0; /* COMMENT_12 */\n\n\t/* COMMENT_13 */\n\tif (VAR_3)\n\t\t*VAR_3 = VAR_12;\n\n\tif (VAR_4) {\n\t\tstruct link_ref *VAR_13;\n\n\t\tVAR_13 = add_link_ref(VAR_4, VAR_0 + VAR_6, VAR_7 - VAR_6);\n\t\tif (!VAR_13)\n\t\t\treturn 0;\n\n\t\tVAR_13->label = bufnew(VAR_7 - VAR_6);\n\t\tbufput(VAR_13->label, VAR_0 + VAR_6, VAR_7 - VAR_6);\n\t\tVAR_13->link = bufnew(VAR_9 - VAR_8);\n\t\tbufput(VAR_13->link, VAR_0 + VAR_8, VAR_9 - VAR_8);\n\n\t\tif (VAR_11 > VAR_10) {\n\t\t\tVAR_13->title = bufnew(VAR_11 - VAR_10);\n\t\t\tbufput(VAR_13->title, VAR_0 + VAR_10, VAR_11 - VAR_10);\n\t\t}\n\t}\n\n\treturn 1;\n}",
  "func_graph_path": "reddit/snudown/1ac2c130b210539ee1e5d67a7bac93f9d8007c0e/markdown.c/vul/after/3.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -99,6 +99,8 @@\n \t\tif (!ref)\n \t\t\treturn 0;\n \n+\t\tref->label = bufnew(id_end - id_offset);\n+\t\tbufput(ref->label, data + id_offset, id_end - id_offset);\n \t\tref->link = bufnew(link_end - link_offset);\n \t\tbufput(ref->link, data + link_offset, link_end - link_offset);\n ",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "\t\tref->label = bufnew(id_end - id_offset);",
      "\t\tbufput(ref->label, data + id_offset, id_end - id_offset);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/reddit/snudown/pull/88",
  "description": {
    "pr_info": {
      "title": "Merge 1.7.0 into downstream github.com repo",
      "number": 88
    },
    "comment": [
      "Publishing internal repo of snudown (which had a 1.6.0 that is merged here as well). \r\n\r\nIn addition, this 1.7.0 branch includes fixes for a to-be-published security advisory (thanks to @NicolaasWeideman)"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95"
}