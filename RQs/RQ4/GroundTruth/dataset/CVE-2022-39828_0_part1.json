{
  "cve_id": "CVE-2022-39828",
  "cwe_ids": [
    "CWE-Other",
    "CWE-476"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "Samsung/mTower",
  "commit_msg": "Fixed: lacking a check for the return value and NULL Pointer Dereference\n\nSigned-off-by: Taras Drozdovskyi <t.drozdovsky@samsung.com>",
  "commit_hash": "b7dc202233026653c682c8fb4fe1251ca5056003",
  "git_url": "https://github.com/Samsung/mTower/commit/b7dc202233026653c682c8fb4fe1251ca5056003",
  "file_path": "tools/fwinfogen.c",
  "func_name": "sign_pFwInfo",
  "func_before": "static int sign_pFwInfo(FW_INFO_T *pFwInfo, ECC_KEY_T *ecdsa_key)\n{\n  int ret = -1;\n  EC_KEY *eckey = EC_KEY_new();\n  if (NULL == eckey) {\n    printf(\"Failed to create new EC Key\\n\");\n    return -1;\n  }\n\n  EC_GROUP *ecgroup = EC_GROUP_new_by_curve_name(NID_X9_62_prime256v1);\n  if (NULL == ecgroup) {\n    printf(\"Failed to create new EC Group\\n\");\n    goto exit;\n  }\n\n  if (EC_KEY_set_group(eckey, ecgroup) != 1) {\n    printf(\"Failed to set group for EC Key\\n\");\n    goto exit;\n  }\n\n  memcpy((void *) pFwInfo->pubkey.au32Key0, (void *) ecdsa_key->Qx, 32);\n  memcpy((void *) pFwInfo->pubkey.au32Key1, (void *) ecdsa_key->Qy, 32);\n\n  BIGNUM* x = BN_bin2bn((void *) ecdsa_key->Qx, 32, NULL);\n  BIGNUM* y = BN_bin2bn((void *) ecdsa_key->Qy, 32, NULL);\n  BIGNUM* d = BN_bin2bn((void *) ecdsa_key->d, 32, NULL);\n\n  EC_KEY_set_private_key(eckey, d);\n  EC_KEY_set_public_key_affine_coordinates(eckey, x, y);\n\n  uint32_t au32HeadHash[8];\n  unsigned int u32Size = sizeof(FW_INFO_T) - sizeof(ECDSA_SIGN_T);\n  sha256((unsigned char *) pFwInfo, u32Size, (unsigned char *) au32HeadHash);\n\n  ECDSA_SIG *signature = ECDSA_do_sign((unsigned char *) au32HeadHash, u32Size,\n      eckey);\n  if (NULL == signature) {\n    printf(\"Failed to generate EC Signature\\n\");\n  } else {\n    if (ECDSA_do_verify((unsigned char *) au32HeadHash, u32Size, signature,\n        eckey) != 1) {\n      printf(\"Failed to verify EC Signature\\n\");\n    } else {\n      BIGNUM *r, *s;\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n        ECDSA_SIG_get0(signature, &r, &s);\n#else\n        r = signature->r;\n        s = signature->s;\n#endif\n\n//      printf(\"d: %s\\n\", BN_bn2hex(d));\n//      printf(\"X: %s\\n\", BN_bn2hex(x));\n//      printf(\"Y: %s\\n\", BN_bn2hex(y));\n//      printf(\"R: %s\\n\", BN_bn2hex(r));\n//      printf(\"S: %s\\n\", BN_bn2hex(s));\n\n      BN_bn2bin(r, (unsigned char *) pFwInfo->sign.au32R);\n      BN_bn2bin(s, (unsigned char *) pFwInfo->sign.au32S);\n      BN_free(x);\n      BN_free(y);\n      BN_free(d);\n      BN_free(r);\n      BN_free(s);\n    }\n  }\n  ret = 0;\n  exit: EC_GROUP_free(ecgroup);\n  EC_KEY_free(eckey);\n\n  return ret;\n}",
  "abstract_func_before": "static int sign_pFwInfo(FW_INFO_T *VAR_0, ECC_KEY_T *VAR_1)\n{\n  int VAR_2 = -1;\n  EC_KEY *VAR_3 = EC_KEY_new();\n  if (NULL == VAR_3) {\n    printf(\"Failed to create new EC Key\\n\");\n    return -1;\n  }\n\n  EC_GROUP *VAR_4 = EC_GROUP_new_by_curve_name(VAR_5);\n  if (NULL == VAR_4) {\n    printf(\"Failed to create new EC Group\\n\");\n    goto exit;\n  }\n\n  if (EC_KEY_set_group(VAR_3, VAR_4) != 1) {\n    printf(\"Failed to set group for EC Key\\n\");\n    goto exit;\n  }\n\n  memcpy((void *) VAR_0->pubkey.au32Key0, (void *) VAR_1->Qx, 32);\n  memcpy((void *) VAR_0->pubkey.au32Key1, (void *) VAR_1->Qy, 32);\n\n  BIGNUM* VAR_6 = BN_bin2bn((void *) VAR_1->Qx, 32, NULL);\n  BIGNUM* VAR_7 = BN_bin2bn((void *) VAR_1->Qy, 32, NULL);\n  BIGNUM* VAR_8 = BN_bin2bn((void *) VAR_1->d, 32, NULL);\n\n  EC_KEY_set_private_key(VAR_3, VAR_8);\n  EC_KEY_set_public_key_affine_coordinates(VAR_3, VAR_6, VAR_7);\n\n  uint32_t VAR_9[8];\n  unsigned int VAR_10 = sizeof(FW_INFO_T) - sizeof(VAR_11);\n  sha256((unsigned char *) VAR_0, VAR_10, (unsigned char *) VAR_9);\n\n  ECDSA_SIG *VAR_12 = ECDSA_do_sign((unsigned char *) VAR_9, VAR_10,\n      VAR_3);\n  if (NULL == VAR_12) {\n    printf(\"Failed to generate EC Signature\\n\");\n  } else {\n    if (ECDSA_do_verify((unsigned char *) VAR_9, VAR_10, VAR_12,\n        VAR_3) != 1) {\n      printf(\"Failed to verify EC Signature\\n\");\n    } else {\n      BIGNUM *VAR_13, *VAR_14;\n#if VAR_15 >= 0x10100000L\n        ECDSA_SIG_get0(VAR_12, &VAR_13, &VAR_14);\n#else\n        VAR_13 = VAR_12->r;\n        VAR_14 = VAR_12->s;\n#endif\n\n/* COMMENT_0 */\n/* COMMENT_1 */\n/* COMMENT_2 */\n/* COMMENT_3 */\n/* COMMENT_4 */\n\n      BN_bn2bin(VAR_13, (unsigned char *) VAR_0->sign.au32R);\n      BN_bn2bin(VAR_14, (unsigned char *) VAR_0->sign.au32S);\n      BN_free(VAR_6);\n      BN_free(VAR_7);\n      BN_free(VAR_8);\n      BN_free(VAR_13);\n      BN_free(VAR_14);\n    }\n  }\n  VAR_2 = 0;\n  exit: EC_GROUP_free(VAR_4);\n  EC_KEY_free(VAR_3);\n\n  return VAR_2;\n}",
  "func_graph_path_before": "Samsung/mTower/b7dc202233026653c682c8fb4fe1251ca5056003/fwinfogen.c/vul/before/0.json",
  "func": "static int sign_pFwInfo(FW_INFO_T *pFwInfo, ECC_KEY_T *ecdsa_key)\n{\n  int ret = -1;\n  EC_KEY *eckey = EC_KEY_new();\n  if (NULL == eckey) {\n    printf(\"Failed to create new EC Key\\n\");\n    return -1;\n  }\n\n  EC_GROUP *ecgroup = EC_GROUP_new_by_curve_name(NID_X9_62_prime256v1);\n  if (NULL == ecgroup) {\n    printf(\"Failed to create new EC Group\\n\");\n    goto exit;\n  }\n\n  if (EC_KEY_set_group(eckey, ecgroup) != 1) {\n    printf(\"Failed to set group for EC Key\\n\");\n    goto exit;\n  }\n\n  memcpy((void *) pFwInfo->pubkey.au32Key0, (void *) ecdsa_key->Qx, 32);\n  memcpy((void *) pFwInfo->pubkey.au32Key1, (void *) ecdsa_key->Qy, 32);\n\n  BIGNUM* x = BN_bin2bn((void *) ecdsa_key->Qx, 32, NULL);\n  BIGNUM* y = BN_bin2bn((void *) ecdsa_key->Qy, 32, NULL);\n  BIGNUM* d = BN_bin2bn((void *) ecdsa_key->d, 32, NULL);\n\n  if(!EC_KEY_set_private_key(eckey, d)) {\n    printf(\"Failed to sets the private key\\n\");\n    goto exit;\n  }\n\n  if(!EC_KEY_set_public_key_affine_coordinates(eckey, x, y)) {\n    printf(\"Failed to sets the public key\\n\");\n    goto exit;\n  }\n\n  uint32_t au32HeadHash[8];\n  unsigned int u32Size = sizeof(FW_INFO_T) - sizeof(ECDSA_SIGN_T);\n  sha256((unsigned char *) pFwInfo, u32Size, (unsigned char *) au32HeadHash);\n\n  ECDSA_SIG *signature = ECDSA_do_sign((unsigned char *) au32HeadHash, u32Size,\n      eckey);\n  if (NULL == signature) {\n    printf(\"Failed to generate EC Signature\\n\");\n  } else {\n    if (ECDSA_do_verify((unsigned char *) au32HeadHash, u32Size, signature,\n        eckey) != 1) {\n      printf(\"Failed to verify EC Signature\\n\");\n    } else {\n      BIGNUM *r, *s;\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n        ECDSA_SIG_get0(signature, &r, &s);\n#else\n        r = signature->r;\n        s = signature->s;\n#endif\n\n//      printf(\"d: %s\\n\", BN_bn2hex(d));\n//      printf(\"X: %s\\n\", BN_bn2hex(x));\n//      printf(\"Y: %s\\n\", BN_bn2hex(y));\n//      printf(\"R: %s\\n\", BN_bn2hex(r));\n//      printf(\"S: %s\\n\", BN_bn2hex(s));\n\n      BN_bn2bin(r, (unsigned char *) pFwInfo->sign.au32R);\n      BN_bn2bin(s, (unsigned char *) pFwInfo->sign.au32S);\n      BN_free(x);\n      BN_free(y);\n      BN_free(d);\n      BN_free(r);\n      BN_free(s);\n    }\n  }\n  ret = 0;\n  exit: EC_GROUP_free(ecgroup);\n  EC_KEY_free(eckey);\n\n  return ret;\n}",
  "abstract_func": "static int sign_pFwInfo(FW_INFO_T *VAR_0, ECC_KEY_T *VAR_1)\n{\n  int VAR_2 = -1;\n  EC_KEY *VAR_3 = EC_KEY_new();\n  if (NULL == VAR_3) {\n    printf(\"Failed to create new EC Key\\n\");\n    return -1;\n  }\n\n  EC_GROUP *VAR_4 = EC_GROUP_new_by_curve_name(VAR_5);\n  if (NULL == VAR_4) {\n    printf(\"Failed to create new EC Group\\n\");\n    goto exit;\n  }\n\n  if (EC_KEY_set_group(VAR_3, VAR_4) != 1) {\n    printf(\"Failed to set group for EC Key\\n\");\n    goto exit;\n  }\n\n  memcpy((void *) VAR_0->pubkey.au32Key0, (void *) VAR_1->Qx, 32);\n  memcpy((void *) VAR_0->pubkey.au32Key1, (void *) VAR_1->Qy, 32);\n\n  BIGNUM* VAR_6 = BN_bin2bn((void *) VAR_1->Qx, 32, NULL);\n  BIGNUM* VAR_7 = BN_bin2bn((void *) VAR_1->Qy, 32, NULL);\n  BIGNUM* VAR_8 = BN_bin2bn((void *) VAR_1->d, 32, NULL);\n\n  if(!EC_KEY_set_private_key(VAR_3, VAR_8)) {\n    printf(\"Failed to sets the private key\\n\");\n    goto exit;\n  }\n\n  if(!EC_KEY_set_public_key_affine_coordinates(VAR_3, VAR_6, VAR_7)) {\n    printf(\"Failed to sets the public key\\n\");\n    goto exit;\n  }\n\n  uint32_t VAR_9[8];\n  unsigned int VAR_10 = sizeof(FW_INFO_T) - sizeof(VAR_11);\n  sha256((unsigned char *) VAR_0, VAR_10, (unsigned char *) VAR_9);\n\n  ECDSA_SIG *VAR_12 = ECDSA_do_sign((unsigned char *) VAR_9, VAR_10,\n      VAR_3);\n  if (NULL == VAR_12) {\n    printf(\"Failed to generate EC Signature\\n\");\n  } else {\n    if (ECDSA_do_verify((unsigned char *) VAR_9, VAR_10, VAR_12,\n        VAR_3) != 1) {\n      printf(\"Failed to verify EC Signature\\n\");\n    } else {\n      BIGNUM *VAR_13, *VAR_14;\n#if VAR_15 >= 0x10100000L\n        ECDSA_SIG_get0(VAR_12, &VAR_13, &VAR_14);\n#else\n        VAR_13 = VAR_12->r;\n        VAR_14 = VAR_12->s;\n#endif\n\n/* COMMENT_0 */\n/* COMMENT_1 */\n/* COMMENT_2 */\n/* COMMENT_3 */\n/* COMMENT_4 */\n\n      BN_bn2bin(VAR_13, (unsigned char *) VAR_0->sign.au32R);\n      BN_bn2bin(VAR_14, (unsigned char *) VAR_0->sign.au32S);\n      BN_free(VAR_6);\n      BN_free(VAR_7);\n      BN_free(VAR_8);\n      BN_free(VAR_13);\n      BN_free(VAR_14);\n    }\n  }\n  VAR_2 = 0;\n  exit: EC_GROUP_free(VAR_4);\n  EC_KEY_free(VAR_3);\n\n  return VAR_2;\n}",
  "func_graph_path": "Samsung/mTower/b7dc202233026653c682c8fb4fe1251ca5056003/fwinfogen.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -25,8 +25,15 @@\n   BIGNUM* y = BN_bin2bn((void *) ecdsa_key->Qy, 32, NULL);\n   BIGNUM* d = BN_bin2bn((void *) ecdsa_key->d, 32, NULL);\n \n-  EC_KEY_set_private_key(eckey, d);\n-  EC_KEY_set_public_key_affine_coordinates(eckey, x, y);\n+  if(!EC_KEY_set_private_key(eckey, d)) {\n+    printf(\"Failed to sets the private key\\n\");\n+    goto exit;\n+  }\n+\n+  if(!EC_KEY_set_public_key_affine_coordinates(eckey, x, y)) {\n+    printf(\"Failed to sets the public key\\n\");\n+    goto exit;\n+  }\n \n   uint32_t au32HeadHash[8];\n   unsigned int u32Size = sizeof(FW_INFO_T) - sizeof(ECDSA_SIGN_T);",
  "diff_line_info": {
    "deleted_lines": [
      "  EC_KEY_set_private_key(eckey, d);",
      "  EC_KEY_set_public_key_affine_coordinates(eckey, x, y);"
    ],
    "added_lines": [
      "  if(!EC_KEY_set_private_key(eckey, d)) {",
      "    printf(\"Failed to sets the private key\\n\");",
      "    goto exit;",
      "  }",
      "",
      "  if(!EC_KEY_set_public_key_affine_coordinates(eckey, x, y)) {",
      "    printf(\"Failed to sets the public key\\n\");",
      "    goto exit;",
      "  }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/Samsung/mTower/pull/78",
  "description": {
    "pr_info": {
      "title": "Fixed: lacking a check for the return value and NULL Pointer Dereference",
      "number": 78
    },
    "comment": [
      "Signed-off-by: Taras Drozdovskyi <t.drozdovsky@samsung.com>\r\n\r\n# Description\r\n\r\nFixed potential security vulnerabilities.\r\n\r\nFixes #75 #76 #77\r\n\r\n## Type of change\r\n\r\n- [x] Bug fix (non-breaking change which fixes an issue)\r\n\r\n# Checklist:\r\n\r\n- [x] My code follows the style guidelines of this project\r\n- [x] I have performed a self-review of my own code\r\n- [x] I have commented my code, particularly in hard-to-understand areas\r\n- [ ] I have made corresponding changes to the documentation\r\n- [x] My changes generate no new warnings\r\n- [ ] I have added tests that prove my fix is effective or that my feature works\r\n- [ ] New and existing unit tests pass locally with my changes\r\n- [ ] Any dependent changes have been merged and published in downstream modules"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Step-by-Step Explanation:**\n\n1. **Input Analysis:** The commit message and code diff focus on adding checks for function return values and addressing NULL pointer dereference, key indicators of a security fix.\n2. **Consistency Check:** The code changes exactly implement the described fixes, with added error handling in the two function calls.\n3. **Purpose Evaluation:** The changes directly address potential security issues, preventing crashes or potential exploits from function failures.\n4. **Security Assessment:** The patch fixes a potential NULL pointer dereference and improper return value handling, both significant security issues.\n5. **Classification:** This is a security fix as it addresses a clear security vulnerability. \n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}