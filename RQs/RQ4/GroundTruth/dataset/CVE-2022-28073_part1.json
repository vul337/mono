{
  "cve_id": "CVE-2022-28073",
  "cwe_ids": [
    "CWE-416"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "radareorg/radare2",
  "commit_msg": "Fix uaf crash in aaft (tests_64927) ##crash\n\nReported by giantbranch of NSFOCUS TIANJI Lab",
  "commit_hash": "59a9dfb60acf8b5c0312061cffd9693fc9526053",
  "git_url": "https://github.com/radareorg/radare2/commit/59a9dfb60acf8b5c0312061cffd9693fc9526053",
  "file_path": "libr/core/cmd_anal.c",
  "func_name": "cmd_anal_reg",
  "func_before": "void cmd_anal_reg(RCore *core, const char *str) {\n\tif (0) {\n\t\t/* enable this block when dr and ar use the same code but just using\n\t\t   core->dbg->reg or core->anal->reg and removing all the debugger\n\t\t   dependent code */\n\t\tRReg *reg = core->dbg->reg;\n\t\tcore->dbg->reg = core->anal->reg;\n\t\tcmd_debug_reg (core, str);\n\t\tcore->dbg->reg = reg;\n\t\treturn;\n\t}\n\n\tint size = 0, i, type = R_REG_TYPE_GPR;\n\tint bits = (core->anal->bits & R_SYS_BITS_64)? 64: 32;\n\tint use_colors = r_config_get_i (core->config, \"scr.color\");\n\tRRegItem *r;\n\tconst char *use_color;\n\tconst char *name;\n\tchar *arg;\n\n\tif (use_colors) {\n#define ConsP(x) (core->cons && core->cons->context->pal.x)? core->cons->context->pal.x\n\t\tuse_color = ConsP (creg)\n\t\t: Color_BWHITE;\n\t} else {\n\t\tuse_color = NULL;\n\t}\n\tswitch (str[0]) {\n\tcase 'l': // \"arl\"\n\t{\n\t\tconst bool use_json = str[1] == 'j';\n\t\tRRegSet *rs = r_reg_regset_get (core->anal->reg, R_REG_TYPE_GPR);\n\t\tif (rs) {\n\t\t\tRRegItem *r;\n\t\t\tRListIter *iter;\n\t\t\tPJ *pj = pj_new ();\n\t\t\tpj_a (pj);\n\t\t\tr_list_foreach (rs->regs, iter, r) {\n\t\t\t\tif (use_json) {\n\t\t\t\t\tpj_s (pj, r->name);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_println (r->name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (use_json) {\n\t\t\t\tpj_end (pj);\n\t\t\t\tconst char *s = pj_string (pj);\n\t\t\t\tr_cons_println (s);\n\t\t\t}\n\t\t\tpj_free (pj);\n\t\t}\n\t} break;\n\tcase ',': // \"ar,\"\n\t\t__tableRegList (core, core->anal->reg, str + 1);\n\t\tbreak;\n\tcase '0': // \"ar0\"\n\t\tr_reg_arena_zero (core->anal->reg);\n\t\tbreak;\n\tcase 'A': // \"arA\"\n\t\t{\n\t\t\tint nargs = 4;\n\t\t\tRReg *reg = core->anal->reg;\n\t\t\tfor (i = 0; i < nargs; i++) {\n\t\t\t\tconst char *name = r_reg_get_name (reg, r_reg_get_name_idx (sdb_fmt (\"A%d\", i)));\n\t\t\t\tut64 off = r_reg_getv (core->anal->reg, name);\n\t\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" \", off);\n\t\t\t\t// XXX very ugly hack\n\t\t\t\tchar *s = r_core_cmd_strf (core, \"pxr 32 @ 0x%08\"PFMT64x, off);\n\t\t\t\tif (s) {\n\t\t\t\t\tchar *nl = strchr (s, '\\n');\n\t\t\t\t\tif (nl) {\n\t\t\t\t\t\t*nl = 0;\n\t\t\t\t\t\tr_cons_printf (\"%s\\n\", s);\n\t\t\t\t\t}\n\t\t\t\t\tfree (s);\n\t\t\t\t}\n//\t\t\t\tr_core_cmd0 (core, \"ar A0,A1,A2,A3\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'C': // \"arC\"\n\t\tif (core->anal->reg->reg_profile_cmt) {\n\t\t\tr_cons_println (core->anal->reg->reg_profile_cmt);\n\t\t}\n\t\tbreak;\n\tcase 'w': // \"arw\"\n\t\tswitch (str[1]) {\n\t\tcase '?': {\n\t\t\tr_core_cmd_help (core, help_msg_arw);\n\t\t\tbreak;\n\t\t}\n\t\tcase ' ':\n\t\t\tr_reg_arena_set_bytes (core->anal->reg, str + 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_core_cmd_help (core, help_msg_arw);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'a': // \"ara\"\n\t\tswitch (str[1]) {\n\t\tcase '?': // \"ara?\"\n\t\t\tr_core_cmd_help (core, help_msg_ara);\n\t\t\tbreak;\n\t\tcase 's': // \"aras\"\n\t\t\tr_reg_arena_swap (core->anal->reg, false);\n\t\t\tbreak;\n\t\tcase '+': // \"ara+\"\n\t\t\tr_reg_arena_push (core->anal->reg);\n\t\t\tbreak;\n\t\tcase '-': // \"ara-\"\n\t\t\tr_reg_arena_pop (core->anal->reg);\n\t\t\tbreak;\n\t\tdefault: {\n\t\t\tint i, j;\n\t\t\tRRegArena *a;\n\t\t\tRListIter *iter;\n\t\t\tfor (i = 0; i < R_REG_TYPE_LAST; i++) {\n\t\t\t\tRRegSet *rs = &core->anal->reg->regset[i];\n\t\t\t\tj = 0;\n\t\t\t\tr_list_foreach (rs->pool, iter, a) {\n\t\t\t\t\tr_cons_printf (\"%s %p %d %d %s %d\\n\",\n\t\t\t\t\t\t(a == rs->arena)? \"*\": \".\", a,\n\t\t\t\t\t\ti, j, r_reg_get_type (i), a->size);\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t}\n\t\t} break;\n\t\t}\n\t\tbreak;\n\tcase '?': // \"ar?\"\n\t\tif (str[1]) {\n\t\t\tut64 off = r_reg_getv (core->anal->reg, str + 1);\n\t\t\tr_cons_printf (\"0x%08\" PFMT64x \"\\n\", off);\n\t\t} else {\n\t\t\tr_core_cmd_help (core, help_msg_ar);\n\t\t}\n\t\tbreak;\n\tcase 'r': // \"arr\"\n\t\tswitch (str[1]) {\n\t\tcase 'j': // \"arrj\"\n\t\t\tr_core_debug_rr (core, core->anal->reg, 'j');\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_core_debug_rr (core, core->anal->reg, 0);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'S': { // \"arS\"\n\t\tint sz;\n\t\tut8 *buf = r_reg_get_bytes (core->anal->reg, R_REG_TYPE_GPR, &sz);\n\t\tr_cons_printf (\"%d\\n\", sz);\n\t\tfree (buf);\n\t\t} break;\n\tcase 'b': { // \"arb\" WORK IN PROGRESS // DEBUG COMMAND\n\t\tint len, type = R_REG_TYPE_GPR;\n\t\targ = strchr (str, ' ');\n\t\tif (arg) {\n\t\t\tchar *string = r_str_trim_dup (arg + 1);\n\t\t\tif (string) {\n\t\t\t\ttype = r_reg_type_by_name (string);\n\t\t\t\tif (type == -1 && string[0] != 'a') {\n\t\t\t\t\ttype = R_REG_TYPE_GPR;\n\t\t\t\t}\n\t\t\t\tfree (string);\n\t\t\t}\n\t\t}\n\t\tut8 *buf = r_reg_get_bytes (core->dbg->reg, type, &len);\n\t\tif (buf) {\n\t\t\tr_print_hexdump (core->print, 0LL, buf, len, 32, 4, 1);\n\t\t\tfree (buf);\n\t\t}\n\t\t} break;\n\tcase 'c': // \"arc\"\n\t\t// TODO: set flag values with drc zf=1\n\t\tif (str[1] == 'q') { // \"arcq\"\n\t\t\tRRegFlags *rf = r_reg_cond_retrieve (core->dbg->reg, NULL);\n\t\t\tif (rf) {\n\t\t\t\tr_cons_printf (\"s:%d z:%d c:%d o:%d p:%d\\n\",\n\t\t\t\t\t\trf->s, rf->z, rf->c, rf->o, rf->p);\n\t\t\t\tfree (rf);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (str[1] == 'c') { // \"arcc\"\n\t\t\tchar *s = r_reg_profile_to_cc (core->anal->reg);\n\t\t\tif (s) {\n\t\t\t\tr_cons_printf (\"%s\\n\", s);\n\t\t\t\tfree (s);\n\t\t\t}\n\t\t} else {\n\t\t\tRRegItem *r;\n\t\t\tconst char *name = r_str_trim_head_ro (str + 1);\n\t\t\tif (*name && name[1]) {\n\t\t\t\tr = r_reg_cond_get (core->dbg->reg, name);\n\t\t\t\tif (r) {\n\t\t\t\t\tr_cons_println (r->name);\n\t\t\t\t} else {\n\t\t\t\t\tint id = r_reg_cond_from_string (name);\n\t\t\t\t\tRRegFlags *rf = r_reg_cond_retrieve (core->dbg->reg, NULL);\n\t\t\t\t\tif (rf) {\n\t\t\t\t\t\tint o = r_reg_cond_bits (core->dbg->reg, id, rf);\n\t\t\t\t\t\tcore->num->value = o;\n\t\t\t\t\t\t// ORLY?\n\t\t\t\t\t\tr_cons_printf (\"%d\\n\", o);\n\t\t\t\t\t\tfree (rf);\n\t\t\t\t\t} else {\n\t\t\t\t\t\teprintf (\"unknown conditional or flag register\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tRRegFlags *rf = r_reg_cond_retrieve (core->dbg->reg, NULL);\n\t\t\t\tif (rf) {\n\t\t\t\t\tr_cons_printf (\"| s:%d z:%d c:%d o:%d p:%d\\n\",\n\t\t\t\t\t\trf->s, rf->z, rf->c, rf->o, rf->p);\n\t\t\t\t\tif (*name == '=') {\n\t\t\t\t\t\tfor (i = 0; i < R_REG_COND_LAST; i++) {\n\t\t\t\t\t\t\tr_cons_printf (\"%s:%d \",\n\t\t\t\t\t\t\t\tr_reg_cond_to_string (i),\n\t\t\t\t\t\t\t\tr_reg_cond_bits (core->dbg->reg, i, rf));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_cons_newline ();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (i = 0; i < R_REG_COND_LAST; i++) {\n\t\t\t\t\t\t\tr_cons_printf (\"%d %s\\n\",\n\t\t\t\t\t\t\t\tr_reg_cond_bits (core->dbg->reg, i, rf),\n\t\t\t\t\t\t\t\tr_reg_cond_to_string (i));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree (rf);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 's': // \"ars\"\n\t\tswitch (str[1]) {\n\t\tcase '-': // \"ars-\"\n\t\t\tr_reg_arena_pop (core->dbg->reg);\n\t\t\t// restore debug registers if in debugger mode\n\t\t\tr_debug_reg_sync (core->dbg, R_REG_TYPE_GPR, true);\n\t\t\tbreak;\n\t\tcase '+': // \"ars+\"\n\t\t\tr_reg_arena_push (core->dbg->reg);\n\t\t\tbreak;\n\t\tcase '?': { // \"ars?\"\n\t\t\t// TODO #7967 help refactor: dup from drp\n\t\t\tconst char *help_msg[] = {\n\t\t\t\t\"Usage:\", \"drs\", \" # Register states commands\",\n\t\t\t\t\"drs\", \"\", \"List register stack\",\n\t\t\t\t\"drs+\", \"\", \"Push register state\",\n\t\t\t\t\"drs-\", \"\", \"Pop register state\",\n\t\t\t\tNULL };\n\t\t\tr_core_cmd_help (core, help_msg);\n\t\t} break;\n\t\tdefault:\n\t\t\t{\n\t\t\t\tvoid *p = core->dbg->reg->regset[0].pool;\n\t\t\t\tint len = p? r_list_length (p): 0;\n\t\t\t\tr_cons_printf (\"%d\\n\", len);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'p': // \"arp\"\n\t\t// XXX we have to break out .h for these cmd_xxx files.\n\t\tcmd_reg_profile (core, 'a', str);\n\t\tbreak;\n\tcase 't': // \"art\"\n\t\tfor (i = 0; (name = r_reg_get_type (i)); i++) {\n\t\t\tr_cons_println (name);\n\t\t}\n\t\tbreak;\n\tcase 'n': // \"arn\"\n\t\tif (*(str + 1) == '\\0') {\n\t\t\teprintf (\"Oops. try arn [PC|SP|BP|A0|A1|A2|A3|A4|R0|R1|ZF|SF|NF|OF]\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tname = r_reg_get_name (core->dbg->reg, r_reg_get_name_idx (str + 2));\n\t\tif (name && *name) {\n\t\t\tr_cons_println (name);\n\t\t} else {\n\t\t\teprintf (\"Oops. try arn [PC|SP|BP|A0|A1|A2|A3|A4|R0|R1|ZF|SF|NF|OF]\\n\");\n\t\t}\n\t\tbreak;\n\tcase 'd': // \"ard\"\n\t\tr_debug_reg_list (core->dbg, R_REG_TYPE_GPR, bits, NULL, 3, use_color); // XXX detect which one is current usage\n\t\tbreak;\n\tcase 'o': // \"aro\"\n\t\tr_reg_arena_swap (core->dbg->reg, false);\n\t\tr_debug_reg_list (core->dbg, R_REG_TYPE_GPR, bits, NULL, 0, use_color); // XXX detect which one is current usage\n\t\tr_reg_arena_swap (core->dbg->reg, false);\n\t\tbreak;\n\tcase '=': // \"ar=\"\n\t\t{\n\t\t\tchar *p = NULL;\n\t\t\tchar *bits = NULL;\n\t\t\tif (str[1]) {\n\t\t\t\tp = strdup (str + 1);\n\t\t\t\tif (str[1] != ':') {\n\t\t\t\t\t// Bits were specified\n\t\t\t\t\tbits = strtok (p, \":\");\n\t\t\t\t\tif (r_str_isnumber (bits)) {\n\t\t\t\t\t\tst64 sz = r_num_math (core->num, bits);\n\t\t\t\t\t\tif (sz > 0) {\n\t\t\t\t\t\t\tsize = sz;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_core_cmd_help (core, help_msg_ar);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint len = bits ? strlen (bits) : 0;\n\t\t\t\tif (str[len + 1] == ':') {\n\t\t\t\t\t// We have some regs\n\t\t\t\t\tchar *regs = bits ? strtok (NULL, \":\") : strtok ((char *)str + 1, \":\");\n\t\t\t\t\tchar *reg = strtok (regs, \" \");\n\t\t\t\t\tRList *q_regs = r_list_new ();\n\t\t\t\t\tif (q_regs) {\n\t\t\t\t\t\twhile (reg) {\n\t\t\t\t\t\t\tr_list_append (q_regs, reg);\n\t\t\t\t\t\t\treg = strtok (NULL, \" \");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcore->dbg->q_regs = q_regs;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t__anal_reg_list (core, type, size, str[0]);\n\t\t\tif (!r_list_empty (core->dbg->q_regs)) {\n\t\t\t\tr_list_free (core->dbg->q_regs);\n\t\t\t}\n\t\t\tcore->dbg->q_regs = NULL;\n\t\t\tfree (p);\n\t\t}\n\t\tbreak;\n\tcase '.': // \"ar.\"\n\tcase '-': // \"ar-\"\n\tcase '*': // \"ar*\"\n\tcase 'R': // \"arR\"\n\tcase 'j': // \"arj\"\n\tcase 'i': // \"ari\"\n\tcase '\\0': // \"ar\"\n\t\t__anal_reg_list (core, type, size, str[0]);\n\t\tbreak;\n\tcase ' ': { // \"ar \"\n\t\targ = strchr (str + 1, '=');\n\t\tif (arg) {\n\t\t\t*arg = 0;\n\t\t\tchar *ostr = r_str_trim_dup (str + 1);\n\t\t\tchar *regname = r_str_trim_nc (ostr);\n\t\t\tr = r_reg_get (core->dbg->reg, regname, -1);\n\t\t\tif (!r) {\n\t\t\t\tint role = r_reg_get_name_idx (regname);\n\t\t\t\tif (role != -1) {\n\t\t\t\t\tconst char *alias = r_reg_get_name (core->dbg->reg, role);\n\t\t\t\t\tif (alias) {\n\t\t\t\t\t\tr = r_reg_get (core->dbg->reg, alias, -1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (r) {\n\t\t\t\t//eprintf (\"%s 0x%08\"PFMT64x\" -> \", str,\n\t\t\t\t//\tr_reg_get_value (core->dbg->reg, r));\n\t\t\t\tr_reg_set_value (core->dbg->reg, r,\n\t\t\t\t\t\tr_num_math (core->num, arg + 1));\n\t\t\t\tr_debug_reg_sync (core->dbg, R_REG_TYPE_ALL, true);\n\t\t\t\t//eprintf (\"0x%08\"PFMT64x\"\\n\",\n\t\t\t\t//\tr_reg_get_value (core->dbg->reg, r));\n\t\t\t\tr_core_cmdf (core, \".dr*%d\", bits);\n\t\t\t} else {\n\t\t\t\teprintf (\"ar: Unknown register '%s'\\n\", regname);\n\t\t\t}\n\t\t\tfree (ostr);\n\t\t\treturn;\n\t\t}\n\t\tchar name[32];\n\t\tint i = 1, j;\n\t\twhile (str[i]) {\n\t\t\tif (str[i] == ',') {\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tfor (j = i; str[++j] && str[j] != ','; );\n\t\t\t\tif (j - i + 1 <= sizeof name) {\n\t\t\t\t\tr_str_ncpy (name, str + i, j - i + 1);\n\t\t\t\t\tif (IS_DIGIT (name[0])) { // e.g. ar 32\n\t\t\t\t\t\t__anal_reg_list (core, R_REG_TYPE_GPR, atoi (name), '\\0');\n\t\t\t\t\t} else if (showreg (core, name) > 0) { // e.g. ar rax\n\t\t\t\t\t} else { // e.g. ar gpr ; ar all\n\t\t\t\t\t\ttype = r_reg_type_by_name (name);\n\t\t\t\t\t\t// TODO differentiate ALL and illegal register types and print error message for the latter\n\t\t\t\t\t\t__anal_reg_list (core, type, -1, '\\0');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ti = j;\n\t\t\t}\n\t\t}\n\t}\n\t}\n}",
  "abstract_func_before": "void cmd_anal_reg(RCore *VAR_0, const char *VAR_1) {\n\tif (0) {\n\t\t/* COMMENT_0 */\n                                                                    \n                      \n\t\tRReg *VAR_2 = VAR_0->dbg->reg;\n\t\tVAR_0->dbg->reg = VAR_0->anal->reg;\n\t\tcmd_debug_reg (VAR_0, VAR_1);\n\t\tVAR_0->dbg->reg = VAR_2;\n\t\treturn;\n\t}\n\n\tint VAR_3 = 0, VAR_4, VAR_5 = VAR_6;\n\tint VAR_7 = (VAR_0->anal->bits & VAR_8)? 64: 32;\n\tint VAR_9 = r_config_get_i (VAR_0->config, \"scr.color\");\n\tRRegItem *VAR_10;\n\tconst char *VAR_11;\n\tconst char *VAR_12;\n\tchar *VAR_13;\n\n\tif (VAR_9) {\n#define ConsP(VAR_14) (core->cons && core->cons->context->pal.x)? core->cons->context->pal.x\n\t\tVAR_11 = ConsP (VAR_15)\n\t\t: VAR_16;\n\t} else {\n\t\tVAR_11 = NULL;\n\t}\n\tswitch (VAR_1[0]) {\n\tcase 'l': /* COMMENT_3 */\n\t{\n\t\tconst bool VAR_17 = VAR_1[1] == 'j';\n\t\tRRegSet *VAR_18 = r_reg_regset_get (VAR_0->anal->reg, VAR_6);\n\t\tif (VAR_18) {\n\t\t\tRRegItem *VAR_10;\n\t\t\tRListIter *VAR_19;\n\t\t\tPJ *VAR_20 = pj_new ();\n\t\t\tpj_a (VAR_20);\n\t\t\tr_list_foreach (VAR_18->regs, VAR_19, VAR_10) {\n\t\t\t\tif (VAR_17) {\n\t\t\t\t\tpj_s (VAR_20, VAR_10->name);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_println (VAR_10->name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (VAR_17) {\n\t\t\t\tpj_end (VAR_20);\n\t\t\t\tconst char *VAR_21 = pj_string (VAR_20);\n\t\t\t\tr_cons_println (VAR_21);\n\t\t\t}\n\t\t\tpj_free (VAR_20);\n\t\t}\n\t} break;\n\tcase ',': /* COMMENT_4 */\n\t\t__tableRegList (VAR_0, VAR_0->anal->reg, VAR_1 + 1);\n\t\tbreak;\n\tcase '0': /* COMMENT_5 */\n\t\tr_reg_arena_zero (VAR_0->anal->reg);\n\t\tbreak;\n\tcase 'A': /* COMMENT_6 */\n\t\t{\n\t\t\tint VAR_22 = 4;\n\t\t\tRReg *VAR_2 = VAR_0->anal->reg;\n\t\t\tfor (VAR_4 = 0; VAR_4 < VAR_22; VAR_4++) {\n\t\t\t\tconst char *VAR_12 = r_reg_get_name (VAR_2, r_reg_get_name_idx (sdb_fmt (\"A%d\", VAR_4)));\n\t\t\t\tut64 VAR_23 = r_reg_getv (VAR_0->anal->reg, VAR_12);\n\t\t\t\tr_cons_printf (\"0x%08\"VAR_24\" \", VAR_23);\n\t\t\t\t/* COMMENT_7 */\n\t\t\t\tchar *VAR_21 = r_core_cmd_strf (VAR_0, \"pxr 32 @ 0x%08\"VAR_24, VAR_23);\n\t\t\t\tif (VAR_21) {\n\t\t\t\t\tchar *VAR_25 = strchr (VAR_21, '\\n');\n\t\t\t\t\tif (VAR_25) {\n\t\t\t\t\t\t*VAR_25 = 0;\n\t\t\t\t\t\tr_cons_printf (\"%s\\n\", VAR_21);\n\t\t\t\t\t}\n\t\t\t\t\tfree (VAR_21);\n\t\t\t\t}\n/* COMMENT_8 */\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'C': /* COMMENT_9 */\n\t\tif (VAR_0->anal->reg->reg_profile_cmt) {\n\t\t\tr_cons_println (VAR_0->anal->reg->reg_profile_cmt);\n\t\t}\n\t\tbreak;\n\tcase 'w': /* COMMENT_10 */\n\t\tswitch (VAR_1[1]) {\n\t\tcase '?': {\n\t\t\tr_core_cmd_help (VAR_0, VAR_26);\n\t\t\tbreak;\n\t\t}\n\t\tcase ' ':\n\t\t\tr_reg_arena_set_bytes (VAR_0->anal->reg, VAR_1 + 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_core_cmd_help (VAR_0, VAR_26);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'a': /* COMMENT_11 */\n\t\tswitch (VAR_1[1]) {\n\t\tcase '?': /* COMMENT_12 */\n\t\t\tr_core_cmd_help (VAR_0, VAR_27);\n\t\t\tbreak;\n\t\tcase 's': /* COMMENT_13 */\n\t\t\tr_reg_arena_swap (VAR_0->anal->reg, false);\n\t\t\tbreak;\n\t\tcase '+': /* COMMENT_14 */\n\t\t\tr_reg_arena_push (VAR_0->anal->reg);\n\t\t\tbreak;\n\t\tcase '-': /* COMMENT_15 */\n\t\t\tr_reg_arena_pop (VAR_0->anal->reg);\n\t\t\tbreak;\n\t\tdefault: {\n\t\t\tint VAR_4, VAR_28;\n\t\t\tRRegArena *VAR_29;\n\t\t\tRListIter *VAR_19;\n\t\t\tfor (VAR_4 = 0; VAR_4 < VAR_30; VAR_4++) {\n\t\t\t\tRRegSet *VAR_18 = &VAR_0->anal->reg->regset[VAR_4];\n\t\t\t\tVAR_28 = 0;\n\t\t\t\tr_list_foreach (VAR_18->pool, VAR_19, VAR_29) {\n\t\t\t\t\tr_cons_printf (\"%s %p %d %d %s %d\\n\",\n\t\t\t\t\t\t(VAR_29 == VAR_18->arena)? \"*\": \".\", VAR_29,\n\t\t\t\t\t\tVAR_4, VAR_28, r_reg_get_type (VAR_4), VAR_29->size);\n\t\t\t\t\tVAR_28++;\n\t\t\t\t}\n\t\t\t}\n\t\t} break;\n\t\t}\n\t\tbreak;\n\tcase '?': /* COMMENT_16 */\n\t\tif (VAR_1[1]) {\n\t\t\tut64 VAR_23 = r_reg_getv (VAR_0->anal->reg, VAR_1 + 1);\n\t\t\tr_cons_printf (\"0x%08\" VAR_24 \"\\n\", VAR_23);\n\t\t} else {\n\t\t\tr_core_cmd_help (VAR_0, VAR_31);\n\t\t}\n\t\tbreak;\n\tcase 'r': /* COMMENT_17 */\n\t\tswitch (VAR_1[1]) {\n\t\tcase 'j': /* COMMENT_18 */\n\t\t\tr_core_debug_rr (VAR_0, VAR_0->anal->reg, 'j');\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_core_debug_rr (VAR_0, VAR_0->anal->reg, 0);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'S': { /* COMMENT_19 */\n\t\tint VAR_32;\n\t\tut8 *VAR_33 = r_reg_get_bytes (VAR_0->anal->reg, VAR_6, &VAR_32);\n\t\tr_cons_printf (\"%d\\n\", VAR_32);\n\t\tfree (VAR_33);\n\t\t} break;\n\tcase 'b': { /* COMMENT_20 */\n\t\tint VAR_34, VAR_5 = VAR_6;\n\t\tVAR_13 = strchr (VAR_1, ' ');\n\t\tif (VAR_13) {\n\t\t\tchar *VAR_35 = r_str_trim_dup (VAR_13 + 1);\n\t\t\tif (VAR_35) {\n\t\t\t\tVAR_5 = r_reg_type_by_name (VAR_35);\n\t\t\t\tif (VAR_5 == -1 && VAR_35[0] != 'a') {\n\t\t\t\t\tVAR_5 = VAR_6;\n\t\t\t\t}\n\t\t\t\tfree (VAR_35);\n\t\t\t}\n\t\t}\n\t\tut8 *VAR_33 = r_reg_get_bytes (VAR_0->dbg->reg, VAR_5, &VAR_34);\n\t\tif (VAR_33) {\n\t\t\tr_print_hexdump (VAR_0->print, 0LL, VAR_33, VAR_34, 32, 4, 1);\n\t\t\tfree (VAR_33);\n\t\t}\n\t\t} break;\n\tcase 'c': /* COMMENT_21 */\n\t\t/* COMMENT_22 */\n\t\tif (VAR_1[1] == 'q') { /* COMMENT_23 */\n\t\t\tRRegFlags *VAR_36 = r_reg_cond_retrieve (VAR_0->dbg->reg, NULL);\n\t\t\tif (VAR_36) {\n\t\t\t\tr_cons_printf (\"s:%d z:%d c:%d o:%d p:%d\\n\",\n\t\t\t\t\t\tVAR_36->s, VAR_36->z, VAR_36->c, VAR_36->o, VAR_36->p);\n\t\t\t\tfree (VAR_36);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (VAR_1[1] == 'c') { /* COMMENT_24 */\n\t\t\tchar *VAR_21 = r_reg_profile_to_cc (VAR_0->anal->reg);\n\t\t\tif (VAR_21) {\n\t\t\t\tr_cons_printf (\"%s\\n\", VAR_21);\n\t\t\t\tfree (VAR_21);\n\t\t\t}\n\t\t} else {\n\t\t\tRRegItem *VAR_10;\n\t\t\tconst char *VAR_12 = r_str_trim_head_ro (VAR_1 + 1);\n\t\t\tif (*VAR_12 && VAR_12[1]) {\n\t\t\t\tVAR_10 = r_reg_cond_get (VAR_0->dbg->reg, VAR_12);\n\t\t\t\tif (VAR_10) {\n\t\t\t\t\tr_cons_println (VAR_10->name);\n\t\t\t\t} else {\n\t\t\t\t\tint VAR_37 = r_reg_cond_from_string (VAR_12);\n\t\t\t\t\tRRegFlags *VAR_36 = r_reg_cond_retrieve (VAR_0->dbg->reg, NULL);\n\t\t\t\t\tif (VAR_36) {\n\t\t\t\t\t\tint VAR_38 = r_reg_cond_bits (VAR_0->dbg->reg, VAR_37, VAR_36);\n\t\t\t\t\t\tVAR_0->num->value = VAR_38;\n\t\t\t\t\t\t/* COMMENT_25 */\n\t\t\t\t\t\tr_cons_printf (\"%d\\n\", VAR_38);\n\t\t\t\t\t\tfree (VAR_36);\n\t\t\t\t\t} else {\n\t\t\t\t\t\teprintf (\"unknown conditional or flag register\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tRRegFlags *VAR_36 = r_reg_cond_retrieve (VAR_0->dbg->reg, NULL);\n\t\t\t\tif (VAR_36) {\n\t\t\t\t\tr_cons_printf (\"| s:%d z:%d c:%d o:%d p:%d\\n\",\n\t\t\t\t\t\tVAR_36->s, VAR_36->z, VAR_36->c, VAR_36->o, VAR_36->p);\n\t\t\t\t\tif (*VAR_12 == '=') {\n\t\t\t\t\t\tfor (VAR_4 = 0; VAR_4 < VAR_39; VAR_4++) {\n\t\t\t\t\t\t\tr_cons_printf (\"%s:%d \",\n\t\t\t\t\t\t\t\tr_reg_cond_to_string (VAR_4),\n\t\t\t\t\t\t\t\tr_reg_cond_bits (VAR_0->dbg->reg, VAR_4, VAR_36));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_cons_newline ();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (VAR_4 = 0; VAR_4 < VAR_39; VAR_4++) {\n\t\t\t\t\t\t\tr_cons_printf (\"%d %s\\n\",\n\t\t\t\t\t\t\t\tr_reg_cond_bits (VAR_0->dbg->reg, VAR_4, VAR_36),\n\t\t\t\t\t\t\t\tr_reg_cond_to_string (VAR_4));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree (VAR_36);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 's': /* COMMENT_26 */\n\t\tswitch (VAR_1[1]) {\n\t\tcase '-': /* COMMENT_27 */\n\t\t\tr_reg_arena_pop (VAR_0->dbg->reg);\n\t\t\t/* COMMENT_28 */\n\t\t\tr_debug_reg_sync (VAR_0->dbg, VAR_6, true);\n\t\t\tbreak;\n\t\tcase '+': /* COMMENT_29 */\n\t\t\tr_reg_arena_push (VAR_0->dbg->reg);\n\t\t\tbreak;\n\t\tcase '?': { /* COMMENT_30 */\n\t\t\t/* COMMENT_31 */\n\t\t\tconst char *VAR_40[] = {\n\t\t\t\t\"Usage:\", \"drs\", \" # Register states commands\",\n\t\t\t\t\"drs\", \"\", \"List register stack\",\n\t\t\t\t\"drs+\", \"\", \"Push register state\",\n\t\t\t\t\"drs-\", \"\", \"Pop register state\",\n\t\t\t\tNULL };\n\t\t\tr_core_cmd_help (VAR_0, VAR_40);\n\t\t} break;\n\t\tdefault:\n\t\t\t{\n\t\t\t\tvoid *VAR_41 = VAR_0->dbg->reg->regset[0].pool;\n\t\t\t\tint VAR_34 = VAR_41? r_list_length (VAR_41): 0;\n\t\t\t\tr_cons_printf (\"%d\\n\", VAR_34);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'p': /* COMMENT_32 */\n\t\t/* COMMENT_33 */\n\t\tcmd_reg_profile (VAR_0, 'a', VAR_1);\n\t\tbreak;\n\tcase 't': /* COMMENT_34 */\n\t\tfor (VAR_4 = 0; (VAR_12 = r_reg_get_type (VAR_4)); VAR_4++) {\n\t\t\tr_cons_println (VAR_12);\n\t\t}\n\t\tbreak;\n\tcase 'n': /* COMMENT_35 */\n\t\tif (*(VAR_1 + 1) == '\\0') {\n\t\t\teprintf (\"Oops. try arn [PC|SP|BP|A0|A1|A2|A3|A4|R0|R1|ZF|SF|NF|OF]\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tVAR_12 = r_reg_get_name (VAR_0->dbg->reg, r_reg_get_name_idx (VAR_1 + 2));\n\t\tif (VAR_12 && *VAR_12) {\n\t\t\tr_cons_println (VAR_12);\n\t\t} else {\n\t\t\teprintf (\"Oops. try arn [PC|SP|BP|A0|A1|A2|A3|A4|R0|R1|ZF|SF|NF|OF]\\n\");\n\t\t}\n\t\tbreak;\n\tcase 'd': /* COMMENT_36 */\n\t\tr_debug_reg_list (VAR_0->dbg, VAR_6, VAR_7, NULL, 3, VAR_11); /* COMMENT_37 */\n\t\tbreak;\n\tcase 'o': /* COMMENT_38 */\n\t\tr_reg_arena_swap (VAR_0->dbg->reg, false);\n\t\tr_debug_reg_list (VAR_0->dbg, VAR_6, VAR_7, NULL, 0, VAR_11); /* COMMENT_37 */\n\t\tr_reg_arena_swap (VAR_0->dbg->reg, false);\n\t\tbreak;\n\tcase '=': /* COMMENT_39 */\n\t\t{\n\t\t\tchar *VAR_41 = NULL;\n\t\t\tchar *VAR_7 = NULL;\n\t\t\tif (VAR_1[1]) {\n\t\t\t\tVAR_41 = strdup (VAR_1 + 1);\n\t\t\t\tif (VAR_1[1] != ':') {\n\t\t\t\t\t/* COMMENT_40 */\n\t\t\t\t\tVAR_7 = strtok (VAR_41, \":\");\n\t\t\t\t\tif (r_str_isnumber (VAR_7)) {\n\t\t\t\t\t\tst64 VAR_32 = r_num_math (VAR_0->num, VAR_7);\n\t\t\t\t\t\tif (VAR_32 > 0) {\n\t\t\t\t\t\t\tVAR_3 = VAR_32;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_core_cmd_help (VAR_0, VAR_31);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint VAR_34 = VAR_7 ? strlen (VAR_7) : 0;\n\t\t\t\tif (VAR_1[VAR_34 + 1] == ':') {\n\t\t\t\t\t/* COMMENT_41 */\n\t\t\t\t\tchar *VAR_42 = VAR_7 ? strtok (NULL, \":\") : strtok ((char *)VAR_1 + 1, \":\");\n\t\t\t\t\tchar *VAR_2 = strtok (VAR_42, \" \");\n\t\t\t\t\tRList *VAR_43 = r_list_new ();\n\t\t\t\t\tif (VAR_43) {\n\t\t\t\t\t\twhile (VAR_2) {\n\t\t\t\t\t\t\tr_list_append (VAR_43, VAR_2);\n\t\t\t\t\t\t\tVAR_2 = strtok (NULL, \" \");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tVAR_0->dbg->q_regs = VAR_43;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t__anal_reg_list (VAR_0, VAR_5, VAR_3, VAR_1[0]);\n\t\t\tif (!r_list_empty (VAR_0->dbg->q_regs)) {\n\t\t\t\tr_list_free (VAR_0->dbg->q_regs);\n\t\t\t}\n\t\t\tVAR_0->dbg->q_regs = NULL;\n\t\t\tfree (VAR_41);\n\t\t}\n\t\tbreak;\n\tcase '.': /* COMMENT_42 */\n\tcase '-': /* COMMENT_43 */\n\tcase '*': /* COMMENT_44 */\n\tcase 'R': /* COMMENT_45 */\n\tcase 'j': /* COMMENT_46 */\n\tcase 'i': /* COMMENT_47 */\n\tcase '\\0': /* COMMENT_48 */\n\t\t__anal_reg_list (VAR_0, VAR_5, VAR_3, VAR_1[0]);\n\t\tbreak;\n\tcase ' ': { /* COMMENT_49 */\n\t\tVAR_13 = strchr (VAR_1 + 1, '=');\n\t\tif (VAR_13) {\n\t\t\t*VAR_13 = 0;\n\t\t\tchar *VAR_44 = r_str_trim_dup (VAR_1 + 1);\n\t\t\tchar *VAR_45 = r_str_trim_nc (VAR_44);\n\t\t\tVAR_10 = r_reg_get (VAR_0->dbg->reg, VAR_45, -1);\n\t\t\tif (!VAR_10) {\n\t\t\t\tint VAR_46 = r_reg_get_name_idx (VAR_45);\n\t\t\t\tif (VAR_46 != -1) {\n\t\t\t\t\tconst char *VAR_47 = r_reg_get_name (VAR_0->dbg->reg, VAR_46);\n\t\t\t\t\tif (VAR_47) {\n\t\t\t\t\t\tVAR_10 = r_reg_get (VAR_0->dbg->reg, VAR_47, -1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (VAR_10) {\n\t\t\t\t/* COMMENT_50 */\n\t\t\t\t/* COMMENT_51 */\n\t\t\t\tr_reg_set_value (VAR_0->dbg->reg, VAR_10,\n\t\t\t\t\t\tr_num_math (VAR_0->num, VAR_13 + 1));\n\t\t\t\tr_debug_reg_sync (VAR_0->dbg, VAR_48, true);\n\t\t\t\t/* COMMENT_52 */\n\t\t\t\t/* COMMENT_51 */\n\t\t\t\tr_core_cmdf (VAR_0, \".dr*%d\", VAR_7);\n\t\t\t} else {\n\t\t\t\teprintf (\"ar: Unknown register '%s'\\n\", VAR_45);\n\t\t\t}\n\t\t\tfree (VAR_44);\n\t\t\treturn;\n\t\t}\n\t\tchar VAR_12[32];\n\t\tint VAR_4 = 1, VAR_28;\n\t\twhile (VAR_1[VAR_4]) {\n\t\t\tif (VAR_1[VAR_4] == ',') {\n\t\t\t\tVAR_4++;\n\t\t\t} else {\n\t\t\t\tfor (VAR_28 = VAR_4; VAR_1[++VAR_28] && VAR_1[VAR_28] != ','; );\n\t\t\t\tif (VAR_28 - VAR_4 + 1 <= sizeof VAR_12) {\n\t\t\t\t\tr_str_ncpy (VAR_12, VAR_1 + VAR_4, VAR_28 - VAR_4 + 1);\n\t\t\t\t\tif (IS_DIGIT (VAR_12[0])) { /* COMMENT_53 */\n\t\t\t\t\t\t__anal_reg_list (VAR_0, VAR_6, atoi (VAR_12), '\\0');\n\t\t\t\t\t} else if (showreg (VAR_0, VAR_12) > 0) { /* COMMENT_54 */\n\t\t\t\t\t} else { /* COMMENT_55 */\n\t\t\t\t\t\tVAR_5 = r_reg_type_by_name (VAR_12);\n\t\t\t\t\t\t/* COMMENT_56 */\n\t\t\t\t\t\t__anal_reg_list (VAR_0, VAR_5, -1, '\\0');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tVAR_4 = VAR_28;\n\t\t\t}\n\t\t}\n\t}\n\t}\n}",
  "func_graph_path_before": "radareorg/radare2/59a9dfb60acf8b5c0312061cffd9693fc9526053/cmd_anal.c/vul/before/0.json",
  "func": "void cmd_anal_reg(RCore *core, const char *str) {\n\tif (0) {\n\t\t/* enable this block when dr and ar use the same code but just using\n\t\t   core->dbg->reg or core->anal->reg and removing all the debugger\n\t\t   dependent code */\n\t\tRReg *reg = core->dbg->reg;\n\t\tcore->dbg->reg = core->anal->reg;\n\t\tcmd_debug_reg (core, str);\n\t\tcore->dbg->reg = reg;\n\t\treturn;\n\t}\n\n\tint size = 0, i, type = R_REG_TYPE_GPR;\n\tint bits = (core->anal->bits & R_SYS_BITS_64)? 64: 32;\n\tint use_colors = r_config_get_i (core->config, \"scr.color\");\n\tRRegItem *r = NULL;\n\tconst char *use_color;\n\tconst char *name;\n\tchar *arg;\n\n\tif (use_colors) {\n#define ConsP(x) (core->cons && core->cons->context->pal.x)? core->cons->context->pal.x\n\t\tuse_color = ConsP (creg)\n\t\t: Color_BWHITE;\n\t} else {\n\t\tuse_color = NULL;\n\t}\n\tswitch (str[0]) {\n\tcase 'l': // \"arl\"\n\t{\n\t\tconst bool use_json = str[1] == 'j';\n\t\tRRegSet *rs = r_reg_regset_get (core->anal->reg, R_REG_TYPE_GPR);\n\t\tif (rs) {\n\t\t\tRRegItem *r;\n\t\t\tRListIter *iter;\n\t\t\tPJ *pj = pj_new ();\n\t\t\tpj_a (pj);\n\t\t\tr_list_foreach (rs->regs, iter, r) {\n\t\t\t\tif (use_json) {\n\t\t\t\t\tpj_s (pj, r->name);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_println (r->name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (use_json) {\n\t\t\t\tpj_end (pj);\n\t\t\t\tconst char *s = pj_string (pj);\n\t\t\t\tr_cons_println (s);\n\t\t\t}\n\t\t\tpj_free (pj);\n\t\t}\n\t} break;\n\tcase ',': // \"ar,\"\n\t\t__tableRegList (core, core->anal->reg, str + 1);\n\t\tbreak;\n\tcase '0': // \"ar0\"\n\t\tr_reg_arena_zero (core->anal->reg);\n\t\tbreak;\n\tcase 'A': // \"arA\"\n\t\t{\n\t\t\tint nargs = 4;\n\t\t\tRReg *reg = core->anal->reg;\n\t\t\tfor (i = 0; i < nargs; i++) {\n\t\t\t\tconst char *name = r_reg_get_name (reg, r_reg_get_name_idx (sdb_fmt (\"A%d\", i)));\n\t\t\t\tut64 off = r_reg_getv (core->anal->reg, name);\n\t\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" \", off);\n\t\t\t\t// XXX very ugly hack\n\t\t\t\tchar *s = r_core_cmd_strf (core, \"pxr 32 @ 0x%08\"PFMT64x, off);\n\t\t\t\tif (s) {\n\t\t\t\t\tchar *nl = strchr (s, '\\n');\n\t\t\t\t\tif (nl) {\n\t\t\t\t\t\t*nl = 0;\n\t\t\t\t\t\tr_cons_printf (\"%s\\n\", s);\n\t\t\t\t\t}\n\t\t\t\t\tfree (s);\n\t\t\t\t}\n//\t\t\t\tr_core_cmd0 (core, \"ar A0,A1,A2,A3\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'C': // \"arC\"\n\t\tif (core->anal->reg->reg_profile_cmt) {\n\t\t\tr_cons_println (core->anal->reg->reg_profile_cmt);\n\t\t}\n\t\tbreak;\n\tcase 'w': // \"arw\"\n\t\tswitch (str[1]) {\n\t\tcase '?': {\n\t\t\tr_core_cmd_help (core, help_msg_arw);\n\t\t\tbreak;\n\t\t}\n\t\tcase ' ':\n\t\t\tr_reg_arena_set_bytes (core->anal->reg, str + 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_core_cmd_help (core, help_msg_arw);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'a': // \"ara\"\n\t\tswitch (str[1]) {\n\t\tcase '?': // \"ara?\"\n\t\t\tr_core_cmd_help (core, help_msg_ara);\n\t\t\tbreak;\n\t\tcase 's': // \"aras\"\n\t\t\tr_reg_arena_swap (core->anal->reg, false);\n\t\t\tbreak;\n\t\tcase '+': // \"ara+\"\n\t\t\tr_reg_arena_push (core->anal->reg);\n\t\t\tbreak;\n\t\tcase '-': // \"ara-\"\n\t\t\tr_reg_arena_pop (core->anal->reg);\n\t\t\tbreak;\n\t\tdefault: {\n\t\t\tint i, j;\n\t\t\tRRegArena *a;\n\t\t\tRListIter *iter;\n\t\t\tfor (i = 0; i < R_REG_TYPE_LAST; i++) {\n\t\t\t\tRRegSet *rs = &core->anal->reg->regset[i];\n\t\t\t\tj = 0;\n\t\t\t\tr_list_foreach (rs->pool, iter, a) {\n\t\t\t\t\tr_cons_printf (\"%s %p %d %d %s %d\\n\",\n\t\t\t\t\t\t(a == rs->arena)? \"*\": \".\", a,\n\t\t\t\t\t\ti, j, r_reg_get_type (i), a->size);\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t}\n\t\t} break;\n\t\t}\n\t\tbreak;\n\tcase '?': // \"ar?\"\n\t\tif (str[1]) {\n\t\t\tut64 off = r_reg_getv (core->anal->reg, str + 1);\n\t\t\tr_cons_printf (\"0x%08\" PFMT64x \"\\n\", off);\n\t\t} else {\n\t\t\tr_core_cmd_help (core, help_msg_ar);\n\t\t}\n\t\tbreak;\n\tcase 'r': // \"arr\"\n\t\tswitch (str[1]) {\n\t\tcase 'j': // \"arrj\"\n\t\t\tr_core_debug_rr (core, core->anal->reg, 'j');\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_core_debug_rr (core, core->anal->reg, 0);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'S': { // \"arS\"\n\t\tint sz;\n\t\tut8 *buf = r_reg_get_bytes (core->anal->reg, R_REG_TYPE_GPR, &sz);\n\t\tr_cons_printf (\"%d\\n\", sz);\n\t\tfree (buf);\n\t\t} break;\n\tcase 'b': { // \"arb\" WORK IN PROGRESS // DEBUG COMMAND\n\t\tint len, type = R_REG_TYPE_GPR;\n\t\targ = strchr (str, ' ');\n\t\tif (arg) {\n\t\t\tchar *string = r_str_trim_dup (arg + 1);\n\t\t\tif (string) {\n\t\t\t\ttype = r_reg_type_by_name (string);\n\t\t\t\tif (type == -1 && string[0] != 'a') {\n\t\t\t\t\ttype = R_REG_TYPE_GPR;\n\t\t\t\t}\n\t\t\t\tfree (string);\n\t\t\t}\n\t\t}\n\t\tut8 *buf = r_reg_get_bytes (core->dbg->reg, type, &len);\n\t\tif (buf) {\n\t\t\tr_print_hexdump (core->print, 0LL, buf, len, 32, 4, 1);\n\t\t\tfree (buf);\n\t\t}\n\t\t} break;\n\tcase 'c': // \"arc\"\n\t\t// TODO: set flag values with drc zf=1\n\t\tif (str[1] == 'q') { // \"arcq\"\n\t\t\tRRegFlags *rf = r_reg_cond_retrieve (core->dbg->reg, NULL);\n\t\t\tif (rf) {\n\t\t\t\tr_cons_printf (\"s:%d z:%d c:%d o:%d p:%d\\n\",\n\t\t\t\t\t\trf->s, rf->z, rf->c, rf->o, rf->p);\n\t\t\t\tfree (rf);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (str[1] == 'c') { // \"arcc\"\n\t\t\tchar *s = r_reg_profile_to_cc (core->anal->reg);\n\t\t\tif (s) {\n\t\t\t\tr_cons_printf (\"%s\\n\", s);\n\t\t\t\tfree (s);\n\t\t\t}\n\t\t} else {\n\t\t\tRRegItem *r;\n\t\t\tconst char *name = r_str_trim_head_ro (str + 1);\n\t\t\tif (*name && name[1]) {\n\t\t\t\tr = r_reg_cond_get (core->dbg->reg, name);\n\t\t\t\tif (r) {\n\t\t\t\t\tr_cons_println (r->name);\n\t\t\t\t} else {\n\t\t\t\t\tint id = r_reg_cond_from_string (name);\n\t\t\t\t\tRRegFlags *rf = r_reg_cond_retrieve (core->dbg->reg, NULL);\n\t\t\t\t\tif (rf) {\n\t\t\t\t\t\tint o = r_reg_cond_bits (core->dbg->reg, id, rf);\n\t\t\t\t\t\tcore->num->value = o;\n\t\t\t\t\t\t// ORLY?\n\t\t\t\t\t\tr_cons_printf (\"%d\\n\", o);\n\t\t\t\t\t\tfree (rf);\n\t\t\t\t\t} else {\n\t\t\t\t\t\teprintf (\"unknown conditional or flag register\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tRRegFlags *rf = r_reg_cond_retrieve (core->dbg->reg, NULL);\n\t\t\t\tif (rf) {\n\t\t\t\t\tr_cons_printf (\"| s:%d z:%d c:%d o:%d p:%d\\n\",\n\t\t\t\t\t\trf->s, rf->z, rf->c, rf->o, rf->p);\n\t\t\t\t\tif (*name == '=') {\n\t\t\t\t\t\tfor (i = 0; i < R_REG_COND_LAST; i++) {\n\t\t\t\t\t\t\tr_cons_printf (\"%s:%d \",\n\t\t\t\t\t\t\t\tr_reg_cond_to_string (i),\n\t\t\t\t\t\t\t\tr_reg_cond_bits (core->dbg->reg, i, rf));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_cons_newline ();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (i = 0; i < R_REG_COND_LAST; i++) {\n\t\t\t\t\t\t\tr_cons_printf (\"%d %s\\n\",\n\t\t\t\t\t\t\t\tr_reg_cond_bits (core->dbg->reg, i, rf),\n\t\t\t\t\t\t\t\tr_reg_cond_to_string (i));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree (rf);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 's': // \"ars\"\n\t\tswitch (str[1]) {\n\t\tcase '-': // \"ars-\"\n\t\t\tr_reg_arena_pop (core->dbg->reg);\n\t\t\t// restore debug registers if in debugger mode\n\t\t\tr_debug_reg_sync (core->dbg, R_REG_TYPE_GPR, true);\n\t\t\tbreak;\n\t\tcase '+': // \"ars+\"\n\t\t\tr_reg_arena_push (core->dbg->reg);\n\t\t\tbreak;\n\t\tcase '?': { // \"ars?\"\n\t\t\t// TODO #7967 help refactor: dup from drp\n\t\t\tconst char *help_msg[] = {\n\t\t\t\t\"Usage:\", \"drs\", \" # Register states commands\",\n\t\t\t\t\"drs\", \"\", \"List register stack\",\n\t\t\t\t\"drs+\", \"\", \"Push register state\",\n\t\t\t\t\"drs-\", \"\", \"Pop register state\",\n\t\t\t\tNULL };\n\t\t\tr_core_cmd_help (core, help_msg);\n\t\t} break;\n\t\tdefault:\n\t\t\t{\n\t\t\t\tvoid *p = core->dbg->reg->regset[0].pool;\n\t\t\t\tint len = p? r_list_length (p): 0;\n\t\t\t\tr_cons_printf (\"%d\\n\", len);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'p': // \"arp\"\n\t\t// XXX we have to break out .h for these cmd_xxx files.\n\t\tcmd_reg_profile (core, 'a', str);\n\t\tbreak;\n\tcase 't': // \"art\"\n\t\tfor (i = 0; (name = r_reg_get_type (i)); i++) {\n\t\t\tr_cons_println (name);\n\t\t}\n\t\tbreak;\n\tcase 'n': // \"arn\"\n\t\tif (*(str + 1) == '\\0') {\n\t\t\teprintf (\"Oops. try arn [PC|SP|BP|A0|A1|A2|A3|A4|R0|R1|ZF|SF|NF|OF]\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tname = r_reg_get_name (core->dbg->reg, r_reg_get_name_idx (str + 2));\n\t\tif (name && *name) {\n\t\t\tr_cons_println (name);\n\t\t} else {\n\t\t\teprintf (\"Oops. try arn [PC|SP|BP|A0|A1|A2|A3|A4|R0|R1|ZF|SF|NF|OF]\\n\");\n\t\t}\n\t\tbreak;\n\tcase 'd': // \"ard\"\n\t\tr_debug_reg_list (core->dbg, R_REG_TYPE_GPR, bits, NULL, 3, use_color); // XXX detect which one is current usage\n\t\tbreak;\n\tcase 'o': // \"aro\"\n\t\tr_reg_arena_swap (core->dbg->reg, false);\n\t\tr_debug_reg_list (core->dbg, R_REG_TYPE_GPR, bits, NULL, 0, use_color); // XXX detect which one is current usage\n\t\tr_reg_arena_swap (core->dbg->reg, false);\n\t\tbreak;\n\tcase '=': // \"ar=\"\n\t\t{\n\t\t\tchar *p = NULL;\n\t\t\tchar *bits = NULL;\n\t\t\tif (str[1]) {\n\t\t\t\tp = strdup (str + 1);\n\t\t\t\tif (str[1] != ':') {\n\t\t\t\t\t// Bits were specified\n\t\t\t\t\tbits = strtok (p, \":\");\n\t\t\t\t\tif (r_str_isnumber (bits)) {\n\t\t\t\t\t\tst64 sz = r_num_math (core->num, bits);\n\t\t\t\t\t\tif (sz > 0) {\n\t\t\t\t\t\t\tsize = sz;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_core_cmd_help (core, help_msg_ar);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint len = bits ? strlen (bits) : 0;\n\t\t\t\tif (str[len + 1] == ':') {\n\t\t\t\t\t// We have some regs\n\t\t\t\t\tchar *regs = bits ? strtok (NULL, \":\") : strtok ((char *)str + 1, \":\");\n\t\t\t\t\tchar *reg = strtok (regs, \" \");\n\t\t\t\t\tRList *q_regs = r_list_new ();\n\t\t\t\t\tif (q_regs) {\n\t\t\t\t\t\twhile (reg) {\n\t\t\t\t\t\t\tr_list_append (q_regs, reg);\n\t\t\t\t\t\t\treg = strtok (NULL, \" \");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcore->dbg->q_regs = q_regs;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t__anal_reg_list (core, type, size, str[0]);\n\t\t\tif (!r_list_empty (core->dbg->q_regs)) {\n\t\t\t\tr_list_free (core->dbg->q_regs);\n\t\t\t}\n\t\t\tcore->dbg->q_regs = NULL;\n\t\t\tfree (p);\n\t\t}\n\t\tbreak;\n\tcase '.': // \"ar.\"\n\tcase '-': // \"ar-\"\n\tcase '*': // \"ar*\"\n\tcase 'R': // \"arR\"\n\tcase 'j': // \"arj\"\n\tcase 'i': // \"ari\"\n\tcase '\\0': // \"ar\"\n\t\t__anal_reg_list (core, type, size, str[0]);\n\t\tbreak;\n\tcase ' ': { // \"ar \"\n\t\targ = strchr (str + 1, '=');\n\t\tif (arg) {\n\t\t\t*arg = 0;\n\t\t\tut64 n = r_num_math (core->num, arg + 1);\n\t\t\tchar *ostr = r_str_trim_dup (str + 1);\n\t\t\tchar *regname = r_str_trim_nc (ostr);\n\t\t\tr = r_reg_get (core->dbg->reg, regname, -1);\n\t\t\tif (!r) {\n\t\t\t\tint role = r_reg_get_name_idx (regname);\n\t\t\t\tif (role != -1) {\n\t\t\t\t\tconst char *alias = r_reg_get_name (core->dbg->reg, role);\n\t\t\t\t\tif (alias) {\n\t\t\t\t\t\tr = r_reg_get (core->dbg->reg, alias, -1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (r) {\n\t\t\t\t//eprintf (\"%s 0x%08\"PFMT64x\" -> \", str,\n\t\t\t\t//\tr_reg_get_value (core->dbg->reg, r));\n\t\t\t\tr_reg_set_value (core->dbg->reg, r, n); \n\t\t\t\tr_debug_reg_sync (core->dbg, R_REG_TYPE_ALL, true);\n\t\t\t\t//eprintf (\"0x%08\"PFMT64x\"\\n\",\n\t\t\t\t//\tr_reg_get_value (core->dbg->reg, r));\n\t\t\t\tr_core_cmdf (core, \".dr*%d\", bits);\n\t\t\t} else {\n\t\t\t\teprintf (\"ar: Unknown register '%s'\\n\", regname);\n\t\t\t}\n\t\t\tfree (ostr);\n\t\t\treturn;\n\t\t}\n\t\tchar name[32];\n\t\tint i = 1, j;\n\t\twhile (str[i]) {\n\t\t\tif (str[i] == ',') {\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tfor (j = i; str[++j] && str[j] != ','; );\n\t\t\t\tif (j - i + 1 <= sizeof name) {\n\t\t\t\t\tr_str_ncpy (name, str + i, j - i + 1);\n\t\t\t\t\tif (IS_DIGIT (name[0])) { // e.g. ar 32\n\t\t\t\t\t\t__anal_reg_list (core, R_REG_TYPE_GPR, atoi (name), '\\0');\n\t\t\t\t\t} else if (showreg (core, name) > 0) { // e.g. ar rax\n\t\t\t\t\t} else { // e.g. ar gpr ; ar all\n\t\t\t\t\t\ttype = r_reg_type_by_name (name);\n\t\t\t\t\t\t// TODO differentiate ALL and illegal register types and print error message for the latter\n\t\t\t\t\t\t__anal_reg_list (core, type, -1, '\\0');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ti = j;\n\t\t\t}\n\t\t}\n\t}\n\t}\n}",
  "abstract_func": "void cmd_anal_reg(RCore *VAR_0, const char *VAR_1) {\n\tif (0) {\n\t\t/* COMMENT_0 */\n                                                                    \n                      \n\t\tRReg *VAR_2 = VAR_0->dbg->reg;\n\t\tVAR_0->dbg->reg = VAR_0->anal->reg;\n\t\tcmd_debug_reg (VAR_0, VAR_1);\n\t\tVAR_0->dbg->reg = VAR_2;\n\t\treturn;\n\t}\n\n\tint VAR_3 = 0, VAR_4, VAR_5 = VAR_6;\n\tint VAR_7 = (VAR_0->anal->bits & VAR_8)? 64: 32;\n\tint VAR_9 = r_config_get_i (VAR_0->config, \"scr.color\");\n\tRRegItem *VAR_10 = NULL;\n\tconst char *VAR_11;\n\tconst char *VAR_12;\n\tchar *VAR_13;\n\n\tif (VAR_9) {\n#define ConsP(VAR_14) (core->cons && core->cons->context->pal.x)? core->cons->context->pal.x\n\t\tVAR_11 = ConsP (VAR_15)\n\t\t: VAR_16;\n\t} else {\n\t\tVAR_11 = NULL;\n\t}\n\tswitch (VAR_1[0]) {\n\tcase 'l': /* COMMENT_3 */\n\t{\n\t\tconst bool VAR_17 = VAR_1[1] == 'j';\n\t\tRRegSet *VAR_18 = r_reg_regset_get (VAR_0->anal->reg, VAR_6);\n\t\tif (VAR_18) {\n\t\t\tRRegItem *VAR_10;\n\t\t\tRListIter *VAR_19;\n\t\t\tPJ *VAR_20 = pj_new ();\n\t\t\tpj_a (VAR_20);\n\t\t\tr_list_foreach (VAR_18->regs, VAR_19, VAR_10) {\n\t\t\t\tif (VAR_17) {\n\t\t\t\t\tpj_s (VAR_20, VAR_10->name);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_println (VAR_10->name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (VAR_17) {\n\t\t\t\tpj_end (VAR_20);\n\t\t\t\tconst char *VAR_21 = pj_string (VAR_20);\n\t\t\t\tr_cons_println (VAR_21);\n\t\t\t}\n\t\t\tpj_free (VAR_20);\n\t\t}\n\t} break;\n\tcase ',': /* COMMENT_4 */\n\t\t__tableRegList (VAR_0, VAR_0->anal->reg, VAR_1 + 1);\n\t\tbreak;\n\tcase '0': /* COMMENT_5 */\n\t\tr_reg_arena_zero (VAR_0->anal->reg);\n\t\tbreak;\n\tcase 'A': /* COMMENT_6 */\n\t\t{\n\t\t\tint VAR_22 = 4;\n\t\t\tRReg *VAR_2 = VAR_0->anal->reg;\n\t\t\tfor (VAR_4 = 0; VAR_4 < VAR_22; VAR_4++) {\n\t\t\t\tconst char *VAR_12 = r_reg_get_name (VAR_2, r_reg_get_name_idx (sdb_fmt (\"A%d\", VAR_4)));\n\t\t\t\tut64 VAR_23 = r_reg_getv (VAR_0->anal->reg, VAR_12);\n\t\t\t\tr_cons_printf (\"0x%08\"VAR_24\" \", VAR_23);\n\t\t\t\t/* COMMENT_7 */\n\t\t\t\tchar *VAR_21 = r_core_cmd_strf (VAR_0, \"pxr 32 @ 0x%08\"VAR_24, VAR_23);\n\t\t\t\tif (VAR_21) {\n\t\t\t\t\tchar *VAR_25 = strchr (VAR_21, '\\n');\n\t\t\t\t\tif (VAR_25) {\n\t\t\t\t\t\t*VAR_25 = 0;\n\t\t\t\t\t\tr_cons_printf (\"%s\\n\", VAR_21);\n\t\t\t\t\t}\n\t\t\t\t\tfree (VAR_21);\n\t\t\t\t}\n/* COMMENT_8 */\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'C': /* COMMENT_9 */\n\t\tif (VAR_0->anal->reg->reg_profile_cmt) {\n\t\t\tr_cons_println (VAR_0->anal->reg->reg_profile_cmt);\n\t\t}\n\t\tbreak;\n\tcase 'w': /* COMMENT_10 */\n\t\tswitch (VAR_1[1]) {\n\t\tcase '?': {\n\t\t\tr_core_cmd_help (VAR_0, VAR_26);\n\t\t\tbreak;\n\t\t}\n\t\tcase ' ':\n\t\t\tr_reg_arena_set_bytes (VAR_0->anal->reg, VAR_1 + 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_core_cmd_help (VAR_0, VAR_26);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'a': /* COMMENT_11 */\n\t\tswitch (VAR_1[1]) {\n\t\tcase '?': /* COMMENT_12 */\n\t\t\tr_core_cmd_help (VAR_0, VAR_27);\n\t\t\tbreak;\n\t\tcase 's': /* COMMENT_13 */\n\t\t\tr_reg_arena_swap (VAR_0->anal->reg, false);\n\t\t\tbreak;\n\t\tcase '+': /* COMMENT_14 */\n\t\t\tr_reg_arena_push (VAR_0->anal->reg);\n\t\t\tbreak;\n\t\tcase '-': /* COMMENT_15 */\n\t\t\tr_reg_arena_pop (VAR_0->anal->reg);\n\t\t\tbreak;\n\t\tdefault: {\n\t\t\tint VAR_4, VAR_28;\n\t\t\tRRegArena *VAR_29;\n\t\t\tRListIter *VAR_19;\n\t\t\tfor (VAR_4 = 0; VAR_4 < VAR_30; VAR_4++) {\n\t\t\t\tRRegSet *VAR_18 = &VAR_0->anal->reg->regset[VAR_4];\n\t\t\t\tVAR_28 = 0;\n\t\t\t\tr_list_foreach (VAR_18->pool, VAR_19, VAR_29) {\n\t\t\t\t\tr_cons_printf (\"%s %p %d %d %s %d\\n\",\n\t\t\t\t\t\t(VAR_29 == VAR_18->arena)? \"*\": \".\", VAR_29,\n\t\t\t\t\t\tVAR_4, VAR_28, r_reg_get_type (VAR_4), VAR_29->size);\n\t\t\t\t\tVAR_28++;\n\t\t\t\t}\n\t\t\t}\n\t\t} break;\n\t\t}\n\t\tbreak;\n\tcase '?': /* COMMENT_16 */\n\t\tif (VAR_1[1]) {\n\t\t\tut64 VAR_23 = r_reg_getv (VAR_0->anal->reg, VAR_1 + 1);\n\t\t\tr_cons_printf (\"0x%08\" VAR_24 \"\\n\", VAR_23);\n\t\t} else {\n\t\t\tr_core_cmd_help (VAR_0, VAR_31);\n\t\t}\n\t\tbreak;\n\tcase 'r': /* COMMENT_17 */\n\t\tswitch (VAR_1[1]) {\n\t\tcase 'j': /* COMMENT_18 */\n\t\t\tr_core_debug_rr (VAR_0, VAR_0->anal->reg, 'j');\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_core_debug_rr (VAR_0, VAR_0->anal->reg, 0);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'S': { /* COMMENT_19 */\n\t\tint VAR_32;\n\t\tut8 *VAR_33 = r_reg_get_bytes (VAR_0->anal->reg, VAR_6, &VAR_32);\n\t\tr_cons_printf (\"%d\\n\", VAR_32);\n\t\tfree (VAR_33);\n\t\t} break;\n\tcase 'b': { /* COMMENT_20 */\n\t\tint VAR_34, VAR_5 = VAR_6;\n\t\tVAR_13 = strchr (VAR_1, ' ');\n\t\tif (VAR_13) {\n\t\t\tchar *VAR_35 = r_str_trim_dup (VAR_13 + 1);\n\t\t\tif (VAR_35) {\n\t\t\t\tVAR_5 = r_reg_type_by_name (VAR_35);\n\t\t\t\tif (VAR_5 == -1 && VAR_35[0] != 'a') {\n\t\t\t\t\tVAR_5 = VAR_6;\n\t\t\t\t}\n\t\t\t\tfree (VAR_35);\n\t\t\t}\n\t\t}\n\t\tut8 *VAR_33 = r_reg_get_bytes (VAR_0->dbg->reg, VAR_5, &VAR_34);\n\t\tif (VAR_33) {\n\t\t\tr_print_hexdump (VAR_0->print, 0LL, VAR_33, VAR_34, 32, 4, 1);\n\t\t\tfree (VAR_33);\n\t\t}\n\t\t} break;\n\tcase 'c': /* COMMENT_21 */\n\t\t/* COMMENT_22 */\n\t\tif (VAR_1[1] == 'q') { /* COMMENT_23 */\n\t\t\tRRegFlags *VAR_36 = r_reg_cond_retrieve (VAR_0->dbg->reg, NULL);\n\t\t\tif (VAR_36) {\n\t\t\t\tr_cons_printf (\"s:%d z:%d c:%d o:%d p:%d\\n\",\n\t\t\t\t\t\tVAR_36->s, VAR_36->z, VAR_36->c, VAR_36->o, VAR_36->p);\n\t\t\t\tfree (VAR_36);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (VAR_1[1] == 'c') { /* COMMENT_24 */\n\t\t\tchar *VAR_21 = r_reg_profile_to_cc (VAR_0->anal->reg);\n\t\t\tif (VAR_21) {\n\t\t\t\tr_cons_printf (\"%s\\n\", VAR_21);\n\t\t\t\tfree (VAR_21);\n\t\t\t}\n\t\t} else {\n\t\t\tRRegItem *VAR_10;\n\t\t\tconst char *VAR_12 = r_str_trim_head_ro (VAR_1 + 1);\n\t\t\tif (*VAR_12 && VAR_12[1]) {\n\t\t\t\tVAR_10 = r_reg_cond_get (VAR_0->dbg->reg, VAR_12);\n\t\t\t\tif (VAR_10) {\n\t\t\t\t\tr_cons_println (VAR_10->name);\n\t\t\t\t} else {\n\t\t\t\t\tint VAR_37 = r_reg_cond_from_string (VAR_12);\n\t\t\t\t\tRRegFlags *VAR_36 = r_reg_cond_retrieve (VAR_0->dbg->reg, NULL);\n\t\t\t\t\tif (VAR_36) {\n\t\t\t\t\t\tint VAR_38 = r_reg_cond_bits (VAR_0->dbg->reg, VAR_37, VAR_36);\n\t\t\t\t\t\tVAR_0->num->value = VAR_38;\n\t\t\t\t\t\t/* COMMENT_25 */\n\t\t\t\t\t\tr_cons_printf (\"%d\\n\", VAR_38);\n\t\t\t\t\t\tfree (VAR_36);\n\t\t\t\t\t} else {\n\t\t\t\t\t\teprintf (\"unknown conditional or flag register\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tRRegFlags *VAR_36 = r_reg_cond_retrieve (VAR_0->dbg->reg, NULL);\n\t\t\t\tif (VAR_36) {\n\t\t\t\t\tr_cons_printf (\"| s:%d z:%d c:%d o:%d p:%d\\n\",\n\t\t\t\t\t\tVAR_36->s, VAR_36->z, VAR_36->c, VAR_36->o, VAR_36->p);\n\t\t\t\t\tif (*VAR_12 == '=') {\n\t\t\t\t\t\tfor (VAR_4 = 0; VAR_4 < VAR_39; VAR_4++) {\n\t\t\t\t\t\t\tr_cons_printf (\"%s:%d \",\n\t\t\t\t\t\t\t\tr_reg_cond_to_string (VAR_4),\n\t\t\t\t\t\t\t\tr_reg_cond_bits (VAR_0->dbg->reg, VAR_4, VAR_36));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_cons_newline ();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (VAR_4 = 0; VAR_4 < VAR_39; VAR_4++) {\n\t\t\t\t\t\t\tr_cons_printf (\"%d %s\\n\",\n\t\t\t\t\t\t\t\tr_reg_cond_bits (VAR_0->dbg->reg, VAR_4, VAR_36),\n\t\t\t\t\t\t\t\tr_reg_cond_to_string (VAR_4));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree (VAR_36);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 's': /* COMMENT_26 */\n\t\tswitch (VAR_1[1]) {\n\t\tcase '-': /* COMMENT_27 */\n\t\t\tr_reg_arena_pop (VAR_0->dbg->reg);\n\t\t\t/* COMMENT_28 */\n\t\t\tr_debug_reg_sync (VAR_0->dbg, VAR_6, true);\n\t\t\tbreak;\n\t\tcase '+': /* COMMENT_29 */\n\t\t\tr_reg_arena_push (VAR_0->dbg->reg);\n\t\t\tbreak;\n\t\tcase '?': { /* COMMENT_30 */\n\t\t\t/* COMMENT_31 */\n\t\t\tconst char *VAR_40[] = {\n\t\t\t\t\"Usage:\", \"drs\", \" # Register states commands\",\n\t\t\t\t\"drs\", \"\", \"List register stack\",\n\t\t\t\t\"drs+\", \"\", \"Push register state\",\n\t\t\t\t\"drs-\", \"\", \"Pop register state\",\n\t\t\t\tNULL };\n\t\t\tr_core_cmd_help (VAR_0, VAR_40);\n\t\t} break;\n\t\tdefault:\n\t\t\t{\n\t\t\t\tvoid *VAR_41 = VAR_0->dbg->reg->regset[0].pool;\n\t\t\t\tint VAR_34 = VAR_41? r_list_length (VAR_41): 0;\n\t\t\t\tr_cons_printf (\"%d\\n\", VAR_34);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'p': /* COMMENT_32 */\n\t\t/* COMMENT_33 */\n\t\tcmd_reg_profile (VAR_0, 'a', VAR_1);\n\t\tbreak;\n\tcase 't': /* COMMENT_34 */\n\t\tfor (VAR_4 = 0; (VAR_12 = r_reg_get_type (VAR_4)); VAR_4++) {\n\t\t\tr_cons_println (VAR_12);\n\t\t}\n\t\tbreak;\n\tcase 'n': /* COMMENT_35 */\n\t\tif (*(VAR_1 + 1) == '\\0') {\n\t\t\teprintf (\"Oops. try arn [PC|SP|BP|A0|A1|A2|A3|A4|R0|R1|ZF|SF|NF|OF]\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tVAR_12 = r_reg_get_name (VAR_0->dbg->reg, r_reg_get_name_idx (VAR_1 + 2));\n\t\tif (VAR_12 && *VAR_12) {\n\t\t\tr_cons_println (VAR_12);\n\t\t} else {\n\t\t\teprintf (\"Oops. try arn [PC|SP|BP|A0|A1|A2|A3|A4|R0|R1|ZF|SF|NF|OF]\\n\");\n\t\t}\n\t\tbreak;\n\tcase 'd': /* COMMENT_36 */\n\t\tr_debug_reg_list (VAR_0->dbg, VAR_6, VAR_7, NULL, 3, VAR_11); /* COMMENT_37 */\n\t\tbreak;\n\tcase 'o': /* COMMENT_38 */\n\t\tr_reg_arena_swap (VAR_0->dbg->reg, false);\n\t\tr_debug_reg_list (VAR_0->dbg, VAR_6, VAR_7, NULL, 0, VAR_11); /* COMMENT_37 */\n\t\tr_reg_arena_swap (VAR_0->dbg->reg, false);\n\t\tbreak;\n\tcase '=': /* COMMENT_39 */\n\t\t{\n\t\t\tchar *VAR_41 = NULL;\n\t\t\tchar *VAR_7 = NULL;\n\t\t\tif (VAR_1[1]) {\n\t\t\t\tVAR_41 = strdup (VAR_1 + 1);\n\t\t\t\tif (VAR_1[1] != ':') {\n\t\t\t\t\t/* COMMENT_40 */\n\t\t\t\t\tVAR_7 = strtok (VAR_41, \":\");\n\t\t\t\t\tif (r_str_isnumber (VAR_7)) {\n\t\t\t\t\t\tst64 VAR_32 = r_num_math (VAR_0->num, VAR_7);\n\t\t\t\t\t\tif (VAR_32 > 0) {\n\t\t\t\t\t\t\tVAR_3 = VAR_32;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_core_cmd_help (VAR_0, VAR_31);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint VAR_34 = VAR_7 ? strlen (VAR_7) : 0;\n\t\t\t\tif (VAR_1[VAR_34 + 1] == ':') {\n\t\t\t\t\t/* COMMENT_41 */\n\t\t\t\t\tchar *VAR_42 = VAR_7 ? strtok (NULL, \":\") : strtok ((char *)VAR_1 + 1, \":\");\n\t\t\t\t\tchar *VAR_2 = strtok (VAR_42, \" \");\n\t\t\t\t\tRList *VAR_43 = r_list_new ();\n\t\t\t\t\tif (VAR_43) {\n\t\t\t\t\t\twhile (VAR_2) {\n\t\t\t\t\t\t\tr_list_append (VAR_43, VAR_2);\n\t\t\t\t\t\t\tVAR_2 = strtok (NULL, \" \");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tVAR_0->dbg->q_regs = VAR_43;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t__anal_reg_list (VAR_0, VAR_5, VAR_3, VAR_1[0]);\n\t\t\tif (!r_list_empty (VAR_0->dbg->q_regs)) {\n\t\t\t\tr_list_free (VAR_0->dbg->q_regs);\n\t\t\t}\n\t\t\tVAR_0->dbg->q_regs = NULL;\n\t\t\tfree (VAR_41);\n\t\t}\n\t\tbreak;\n\tcase '.': /* COMMENT_42 */\n\tcase '-': /* COMMENT_43 */\n\tcase '*': /* COMMENT_44 */\n\tcase 'R': /* COMMENT_45 */\n\tcase 'j': /* COMMENT_46 */\n\tcase 'i': /* COMMENT_47 */\n\tcase '\\0': /* COMMENT_48 */\n\t\t__anal_reg_list (VAR_0, VAR_5, VAR_3, VAR_1[0]);\n\t\tbreak;\n\tcase ' ': { /* COMMENT_49 */\n\t\tVAR_13 = strchr (VAR_1 + 1, '=');\n\t\tif (VAR_13) {\n\t\t\t*VAR_13 = 0;\n\t\t\tut64 VAR_44 = r_num_math (VAR_0->num, VAR_13 + 1);\n\t\t\tchar *VAR_45 = r_str_trim_dup (VAR_1 + 1);\n\t\t\tchar *VAR_46 = r_str_trim_nc (VAR_45);\n\t\t\tVAR_10 = r_reg_get (VAR_0->dbg->reg, VAR_46, -1);\n\t\t\tif (!VAR_10) {\n\t\t\t\tint VAR_47 = r_reg_get_name_idx (VAR_46);\n\t\t\t\tif (VAR_47 != -1) {\n\t\t\t\t\tconst char *VAR_48 = r_reg_get_name (VAR_0->dbg->reg, VAR_47);\n\t\t\t\t\tif (VAR_48) {\n\t\t\t\t\t\tVAR_10 = r_reg_get (VAR_0->dbg->reg, VAR_48, -1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (VAR_10) {\n\t\t\t\t/* COMMENT_50 */\n\t\t\t\t/* COMMENT_51 */\n\t\t\t\tr_reg_set_value (VAR_0->dbg->reg, VAR_10, VAR_44); \n\t\t\t\tr_debug_reg_sync (VAR_0->dbg, VAR_49, true);\n\t\t\t\t/* COMMENT_52 */\n\t\t\t\t/* COMMENT_51 */\n\t\t\t\tr_core_cmdf (VAR_0, \".dr*%d\", VAR_7);\n\t\t\t} else {\n\t\t\t\teprintf (\"ar: Unknown register '%s'\\n\", VAR_46);\n\t\t\t}\n\t\t\tfree (VAR_45);\n\t\t\treturn;\n\t\t}\n\t\tchar VAR_12[32];\n\t\tint VAR_4 = 1, VAR_28;\n\t\twhile (VAR_1[VAR_4]) {\n\t\t\tif (VAR_1[VAR_4] == ',') {\n\t\t\t\tVAR_4++;\n\t\t\t} else {\n\t\t\t\tfor (VAR_28 = VAR_4; VAR_1[++VAR_28] && VAR_1[VAR_28] != ','; );\n\t\t\t\tif (VAR_28 - VAR_4 + 1 <= sizeof VAR_12) {\n\t\t\t\t\tr_str_ncpy (VAR_12, VAR_1 + VAR_4, VAR_28 - VAR_4 + 1);\n\t\t\t\t\tif (IS_DIGIT (VAR_12[0])) { /* COMMENT_53 */\n\t\t\t\t\t\t__anal_reg_list (VAR_0, VAR_6, atoi (VAR_12), '\\0');\n\t\t\t\t\t} else if (showreg (VAR_0, VAR_12) > 0) { /* COMMENT_54 */\n\t\t\t\t\t} else { /* COMMENT_55 */\n\t\t\t\t\t\tVAR_5 = r_reg_type_by_name (VAR_12);\n\t\t\t\t\t\t/* COMMENT_56 */\n\t\t\t\t\t\t__anal_reg_list (VAR_0, VAR_5, -1, '\\0');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tVAR_4 = VAR_28;\n\t\t\t}\n\t\t}\n\t}\n\t}\n}",
  "func_graph_path": "radareorg/radare2/59a9dfb60acf8b5c0312061cffd9693fc9526053/cmd_anal.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -13,7 +13,7 @@\n \tint size = 0, i, type = R_REG_TYPE_GPR;\n \tint bits = (core->anal->bits & R_SYS_BITS_64)? 64: 32;\n \tint use_colors = r_config_get_i (core->config, \"scr.color\");\n-\tRRegItem *r;\n+\tRRegItem *r = NULL;\n \tconst char *use_color;\n \tconst char *name;\n \tchar *arg;\n@@ -345,6 +345,7 @@\n \t\targ = strchr (str + 1, '=');\n \t\tif (arg) {\n \t\t\t*arg = 0;\n+\t\t\tut64 n = r_num_math (core->num, arg + 1);\n \t\t\tchar *ostr = r_str_trim_dup (str + 1);\n \t\t\tchar *regname = r_str_trim_nc (ostr);\n \t\t\tr = r_reg_get (core->dbg->reg, regname, -1);\n@@ -360,8 +361,7 @@\n \t\t\tif (r) {\n \t\t\t\t//eprintf (\"%s 0x%08\"PFMT64x\" -> \", str,\n \t\t\t\t//\tr_reg_get_value (core->dbg->reg, r));\n-\t\t\t\tr_reg_set_value (core->dbg->reg, r,\n-\t\t\t\t\t\tr_num_math (core->num, arg + 1));\n+\t\t\t\tr_reg_set_value (core->dbg->reg, r, n); \n \t\t\t\tr_debug_reg_sync (core->dbg, R_REG_TYPE_ALL, true);\n \t\t\t\t//eprintf (\"0x%08\"PFMT64x\"\\n\",\n \t\t\t\t//\tr_reg_get_value (core->dbg->reg, r));",
  "diff_line_info": {
    "deleted_lines": [
      "\tRRegItem *r;",
      "\t\t\t\tr_reg_set_value (core->dbg->reg, r,",
      "\t\t\t\t\t\tr_num_math (core->num, arg + 1));"
    ],
    "added_lines": [
      "\tRRegItem *r = NULL;",
      "\t\t\tut64 n = r_num_math (core->num, arg + 1);",
      "\t\t\t\tr_reg_set_value (core->dbg->reg, r, n); "
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/radareorg/radare2/pull/19343",
  "description": {
    "pr_info": {
      "title": "Soft fixes2",
      "number": 19343
    },
    "comment": [
      "<!-- Please read the contributing guidelines:\r\n* https://github.com/radareorg/radare2/blob/master/DEVELOPERS.md\r\nIn short:\r\n* PR title must be capitalized, concise and use ##tags\r\n* Follow the coding style, add tests and documentation if necessary\r\n-->\r\n\r\n**Checklist**\r\n\r\n- [ ] Closing issues: #issue\r\n- [ ] Mark this if you consider it ready to merge\r\n- [ ] I've added tests (optional)\r\n- [ ] I wrote some lines in the [radare2book](https://github.com/radareorg/radare2book)\r\n\r\n**Description**\r\n\r\n<!-- Explain the **details** to understand the purpose of this contribution, with enough information to help us understand better the changes. -->\r\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9\n\n---\n\n**Step-by-Step Explanation:**\n\n1. **Input Analysis:** The commit message refers to fixing a \"uaf crash,\" which stands for Use-After-Free, a critical security vulnerability. The code changes show initialization of a pointer to NULL and computing a value before using it, preventing potential dangling pointer issues.\n\n2. **Consistency Check:** The commit message aligns with the code diff focusing on preventing a crash related to invalid memory access, confirming the intent to fix a security issue.\n\n3. **Purpose Evaluation:** The changes directly address a memory management bug, preventing a Use-After-Free scenario, which is a security risk.\n\n4. **Security Assessment:** The patch fixes a known security issue (Use-After-Free), a type of memory corruption vulnerability, making it a security fix.\n\n**Conclusion:** The patch is a security vulnerability fix with high confidence."
}