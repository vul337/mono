{
  "cve_id": "CVE-2022-37724",
  "cwe_ids": [
    "CWE-79"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N",
  "cvss_is_v3": true,
  "repo_name": "wocommunity/wonder",
  "commit_msg": "Updated the adaptors to have a config.h preproc definition which, if enabled, compiles the adaptors without the ability to check for invalid URL characters.",
  "commit_hash": "23c9775fb6afb7be1472944e02396f29771dc8e2",
  "git_url": "https://github.com/wocommunity/wonder/commit/23c9775fb6afb7be1472944e02396f29771dc8e2",
  "file_path": "Utilities/Adaptors/CGI/WebObjects.c",
  "func_name": "doit",
  "func_before": "int doit(int argc, char *argv[], char **envp) {\n#else\n   /*\n    * the request handler...\n    */\n   int main(int argc, char *argv[], char **envp) {\n#endif\n      HTTPRequest *req;\n      HTTPResponse *resp = NULL;\n      WOURLComponents wc = WOURLComponents_Initializer;\n      const char *qs;\n      unsigned int qs_len;\n      char *url;\n      const char *script_name, *path_info, *config_url, *username, *password, *config_options;\n      const char *reqerr;\n      WOURLError urlerr;\n      WOURLError charcheck;\n      strtbl *options = NULL;\n\n#ifdef WIN32\n      _setmode(_fileno(stdout), _O_BINARY);\n      _setmode(_fileno(stdin), _O_BINARY);\n#endif\n\n      if(argc == 2 && strcmp(argv[1], \"test\") == 0)\n      {\n\texit(do_tests());\n      }\n\n      script_name = getenv(CGI_SCRIPT_NAME);\n      path_info = getenv(CGI_PATH_INFO);\n\n      if (script_name == NULL)\n         die(INV_SCRIPT, HTTP_NOT_FOUND);\n      else if (path_info == NULL) {\n         path_info = \"/\";\n      }\n      /* Provide a hook via an environment variable to define the config URL */\n      config_url = getenv(WO_CONFIG_URL);\n      if (!config_url) {\n         /* Flat file URL */\n         /* config_url = \"file:///Local/Library/WebObjects/Configuration/WOConfig.xml\"; */\n         /* Local wotaskd */\n         /* config_url = \"http://localhost:1085\"; */\n         /* Multicast URL */\n         config_url = CONFIG_URL; /* Actually \"webobjects://239.128.14.2:1085\"; */\n      }\n      WOLog(WO_INFO,\"CGI: config url is %s\", config_url);\n      options = st_new(8);\n      st_add(options, WOCONFIG, config_url, 0);\n\n      /*\n         * If your webserver is configured to pass these environment variables, we use them to\n       * protect WOAdaptorInfo output.\n       */\n      username = getenv(WO_ADAPTOR_INFO_USERNAME);\n      if (username && strlen(username) != 0) {\n         st_add(options, WOUSERNAME, username, 0);\n         password = getenv(WO_ADAPTOR_INFO_PASSWORD);\n         if(password && strlen(password) != 0) {\n            st_add(options, WOPASSWORD, password, 0);\n         }\n      }\n\n      config_options = getenv(WO_CONFIG_OPTIONS);\n      if (config_options)\n         st_add(options, WOOPTIONS, config_options, 0);\n      /*\n       * SECURITY ALERT\n       *\n       * To disable WOAdaptorInfo, uncomment the next line.\n       * st_add(options, WOUSERNAME, \"disabled\", 0);\n       *\n       * To specify an WOAdaptorInfo username and password, uncomment the next two lines.\n       * st_add(options, WOUSERNAME, \"joe\", 0);\n       * st_add(options, WOPASSWORD, \"secret\", 0);\n       *\n       */\n\n      if (init_adaptor(options)) {\n          die(\"The request could not be completed due to a server error.\", HTTP_SERVER_ERROR);\n      }\n\n      /*\n       *  extract WebObjects application name from URI\n       */\n\n      url = WOMALLOC(strlen(path_info) + strlen(script_name) + 1);\n      strcpy(url, script_name);\n      strcat(url, path_info);\n      WOLog(WO_INFO,\"<CGI> new request: %s\",url);\n\n      // Make sure the URL does not contain forbidden characters (0x0D or 0x0A).\n      charcheck = WOValidateInitialURL( url );\n      if ( charcheck != WOURLOK ) {\n         WOLog(WO_INFO, \"Declining request due to forbidden URL characters.\");\n         const char* _urlerr;\n         _urlerr = WOURLstrerror( charcheck );\n         die( _urlerr, HTTP_BAD_REQUEST );\n      }\n\n      urlerr = WOParseApplicationName(&wc, url);\n      if (urlerr != WOURLOK) {\n         const char *_urlerr;\n         _urlerr = WOURLstrerror(urlerr);\n         WOLog(WO_INFO,\"URL Parsing Error: %s\", _urlerr);\n\n         if (urlerr == WOURLInvalidApplicationName) {\n             if (ac_authorizeAppListing(&wc)) {\n                 resp = WOAdaptorInfo(NULL, &wc);\n                 die_resp(resp);\n             } else {\n                 die(_urlerr, HTTP_NOT_FOUND);\n             }\n         }\n\n         die(_urlerr, HTTP_BAD_REQUEST);\n      }\n\n      /*\n       *  build the request...\n       */\n      req = req_new( getenv(\"REQUEST_METHOD\"), NULL);\n\n      /*\n       *  validate the method\n       */\n      reqerr = req_validateMethod(req);\n      if (reqerr) {\n          die(reqerr, HTTP_BAD_REQUEST);\n      }\n\n      /*\n       *  copy the headers.  This looks wierd... all we're doing is copying\n       *  *every* environment variable into our headers.  It may be beyond\n       *  the spec, but more information probably won't hurt.\n       */\n      while (envp && *envp) {\n         char *key, *value;\n         /* copy env. line. */\n         key = WOSTRDUP(*envp);\n\n         for (value = key; *value && !isspace((int)*value) && (*value != '='); value++) {}\n         if (*value) {\n            *value++ = '\\0';  /* null terminate 'key' */\n         }\n         while (*value && (isspace((int)*value) || (*value == '='))) {\n            value++;\n         }\n         /* BEGIN Support for getting the client's certificate. */\n         if (strcmp((const char *)key, \"SSL_CLIENT_CERTIFICATE\") == 0 || strcmp((const char *)key, \"SSL_SERVER_CERTIFICATE\") == 0 ) {\n             value = 0;\n             WOLog(WO_INFO,\"<CGI> DROPPING ENV VAR (DUPLICATE) = %s\", key);\n         }\n         if (strcmp((const char *)key, \"SSL_CLIENT_CERT\") == 0 || strcmp((const char *)key, \"SSL_SERVER_CERT\") == 0) {\n             value = make_cert_one_line(value);\n             //WOLog(WO_INFO,\"<CGI> PASSING %s = %s\", key, value);\n         }\n         /*  END Support for getting the client's certificate  */\n\n         if (key && *key && value && *value) {\n            /* must specify copy key and value because key translation might replace this key, and value lives in the same buffer */\n            req_addHeader(req, key, value, STR_COPYKEY|STR_COPYVALUE);\n         }\n\n         /*  BEGIN Support for getting the client's certificate  */\n         if (freeValueNeeded ) {\n             free(value);\n             freeValueNeeded=0;\n         }\n         /*  END Support for getting the client's certificate  */\n\n         WOFREE(key);\n         envp++;      /* next env variable */\n      }\n\n      /*\n       *  get form data if any\n       *  assume that POSTs with content length will be reformatted to GETs later\n       */\n      if (req->content_length > 0) {\n         req_allocateContent(req, req->content_length, 1);\n         req->getMoreContent = (req_getMoreContentCallback)readContentData;\n         if (req->content_buffer_size == 0)\n            die(ALLOCATION_FAILURE, HTTP_SERVER_ERROR);\n         if (readContentData(req, req->content, req->content_buffer_size, 1) == -1) {\n            die(WOURLstrerror(WOURLInvalidPostData), HTTP_BAD_REQUEST);\n         }\n      }\n\n      /* Always get the query string */\n      qs = getenv(\"QUERY_STRING\");\n      if (qs) {\n         qs_len = strlen(qs);\n      } else {\n         qs_len = 0;\n      }\n\n      if (qs_len > 0) {\n         wc.queryString.start = qs;\n         wc.queryString.length = qs_len;\n         WOLog(WO_INFO,\"<CGI> new request with Query String: %s\", qs);\n      }\n\n      /*\n       *  message the application & collect the response\n       */\n      resp = tr_handleRequest(req, url, &wc, getenv(CGI_SERVER_PROTOCOL), documentRoot());\n\n      if (resp != NULL) {\n         sendResponse(resp);\n         resp_free(resp);   /* dump the response */\n      }\n\n      WOFREE(url);\n      st_free(options);\n      req_free(req);\n      \n#if defined(FINDLEAKS)\n      showleaks();\n#endif\n      return 0;\n   }",
  "abstract_func_before": "int doit(int VAR_0, char *VAR_1[], char **VAR_2) {\n#else/* COMMENT_0 */\n     \n                            \n      \n   int main(int argc, char *argv[], char **envp) {\n#endif\n      HTTPRequest *req;\n      HTTPResponse *VAR_3 = NULL;\n      WOURLComponents VAR_4 = VAR_5;\n      const char *VAR_6;\n      unsigned int VAR_7;\n      char *VAR_8;\n      const char *VAR_9, *VAR_10, *VAR_11, *VAR_12, *VAR_13, *VAR_14;\n      const char *VAR_15;\n      WOURLError VAR_16;\n      WOURLError VAR_17;\n      strtbl *VAR_18 = NULL;\n\n#ifdef VAR_19\n      _setmode(_fileno(VAR_20), VAR_21);\n      _setmode(_fileno(VAR_22), VAR_21);\n#endif\n\n      if(VAR_0 == 2 && strcmp(VAR_1[1], \"test\") == 0)\n      {\n\texit(do_tests());\n      }\n\n      VAR_9 = getenv(VAR_23);\n      VAR_10 = getenv(VAR_24);\n\n      if (VAR_9 == NULL)\n         die(VAR_25, VAR_26);\n      else if (VAR_10 == NULL) {\n         VAR_10 = \"/\";\n      }\n      /* COMMENT_4 */\n      VAR_11 = getenv(VAR_27);\n      if (!VAR_11) {\n         /* COMMENT_5 */\n         /* COMMENT_6 */\n         /* COMMENT_7 */\n         /* COMMENT_8 */\n         /* COMMENT_9 */\n         VAR_11 = VAR_28; /* COMMENT_10 */\n      }\n      WOLog(VAR_29,\"CGI: config url is %s\", VAR_11);\n      VAR_18 = st_new(8);\n      st_add(VAR_18, VAR_30, VAR_11, 0);\n\n      /* COMMENT_11 */\n                                                                                              \n                                      \n         \n      VAR_12 = getenv(VAR_31);\n      if (VAR_12 && strlen(VAR_12) != 0) {\n         st_add(VAR_18, VAR_32, VAR_12, 0);\n         VAR_13 = getenv(VAR_33);\n         if(VAR_13 && strlen(VAR_13) != 0) {\n            st_add(VAR_18, VAR_34, VAR_13, 0);\n         }\n      }\n\n      VAR_14 = getenv(VAR_35);\n      if (VAR_14)\n         st_add(VAR_18, VAR_36, VAR_14, 0);\n      /* COMMENT_15 */\n                       \n        \n                                                           \n                                                    \n        \n                                                                                         \n                                               \n                                                  \n        \n         \n\n      if (init_adaptor(VAR_18)) {\n          die(\"The request could not be completed due to a server error.\", VAR_37);\n      }\n\n      /* COMMENT_24 */\n                                                      \n         \n\n      VAR_8 = WOMALLOC(strlen(VAR_10) + strlen(VAR_9) + 1);\n      strcpy(VAR_8, VAR_9);\n      strcat(VAR_8, VAR_10);\n      WOLog(VAR_29,\"<CGI> new request: %s\",VAR_8);\n\n      /* COMMENT_27 */\n      VAR_17 = WOValidateInitialURL( VAR_8 );\n      if ( VAR_17 != VAR_38 ) {\n         WOLog(VAR_29, \"Declining request due to forbidden URL characters.\");\n         const char* VAR_39;\n         VAR_39 = WOURLstrerror( VAR_17 );\n         die( VAR_39, VAR_40 );\n      }\n\n      VAR_16 = WOParseApplicationName(&VAR_4, VAR_8);\n      if (VAR_16 != VAR_38) {\n         const char *VAR_39;\n         VAR_39 = WOURLstrerror(VAR_16);\n         WOLog(VAR_29,\"URL Parsing Error: %s\", VAR_39);\n\n         if (VAR_16 == VAR_41) {\n             if (ac_authorizeAppListing(&VAR_4)) {\n                 VAR_3 = WOAdaptorInfo(NULL, &VAR_4);\n                 die_resp(VAR_3);\n             } else {\n                 die(VAR_39, VAR_26);\n             }\n         }\n\n         die(VAR_39, VAR_40);\n      }\n\n      /* COMMENT_28 */\n                              \n         \n      VAR_42 = req_new( getenv(\"REQUEST_METHOD\"), NULL);\n\n      /* COMMENT_31 */\n                             \n         \n      VAR_15 = req_validateMethod(VAR_42);\n      if (VAR_15) {\n          die(VAR_15, VAR_40);\n      }\n\n      /* COMMENT_34 */\n                                                                           \n                                                                          \n                                                             \n         \n      while (VAR_2 && *VAR_2) {\n         char *VAR_43, *VAR_44;\n         /* COMMENT_39 */\n         VAR_43 = WOSTRDUP(*VAR_2);\n\n         for (VAR_44 = VAR_43; *VAR_44 && !isspace((int)*VAR_44) && (*VAR_44 != '='); VAR_44++) {}\n         if (*VAR_44) {\n            *VAR_44++ = '\\0';  /* COMMENT_40 */\n         }\n         while (*VAR_44 && (isspace((int)*VAR_44) || (*VAR_44 == '='))) {\n            VAR_44++;\n         }\n         /* COMMENT_41 */\n         if (strcmp((const char *)VAR_43, \"SSL_CLIENT_CERTIFICATE\") == 0 || strcmp((const char *)VAR_43, \"SSL_SERVER_CERTIFICATE\") == 0 ) {\n             VAR_44 = 0;\n             WOLog(VAR_29,\"<CGI> DROPPING ENV VAR (DUPLICATE) = %s\", VAR_43);\n         }\n         if (strcmp((const char *)VAR_43, \"SSL_CLIENT_CERT\") == 0 || strcmp((const char *)VAR_43, \"SSL_SERVER_CERT\") == 0) {\n             VAR_44 = make_cert_one_line(VAR_44);\n             /* COMMENT_42 */\n         }\n         /* COMMENT_43 */\n\n         if (VAR_43 && *VAR_43 && VAR_44 && *VAR_44) {\n            /* COMMENT_44 */\n            req_addHeader(VAR_42, VAR_43, VAR_44, VAR_45|VAR_46);\n         }\n\n         /* COMMENT_45 */\n         if (VAR_47 ) {\n             free(VAR_44);\n             VAR_47=0;\n         }\n         /* COMMENT_43 */\n\n         WOFREE(VAR_43);\n         VAR_2++;      /* COMMENT_46 */\n      }\n\n      /* COMMENT_47 */\n                              \n                                                                                 \n         \n      if (VAR_42->content_length > 0) {\n         req_allocateContent(VAR_42, VAR_42->content_length, 1);\n         VAR_42->getMoreContent = (req_getMoreContentCallback)VAR_48;\n         if (VAR_42->content_buffer_size == 0)\n            die(VAR_49, VAR_37);\n         if (VAR_48(VAR_42, VAR_42->content, VAR_42->content_buffer_size, 1) == -1) {\n            die(WOURLstrerror(VAR_50), VAR_40);\n         }\n      }\n\n      /* COMMENT_51 */\n      VAR_6 = getenv(\"QUERY_STRING\");\n      if (VAR_6) {\n         VAR_7 = strlen(VAR_6);\n      } else {\n         VAR_7 = 0;\n      }\n\n      if (VAR_7 > 0) {\n         VAR_4.queryString.start = VAR_6;\n         VAR_4.queryString.length = VAR_7;\n         WOLog(VAR_29,\"<CGI> new request with Query String: %s\", VAR_6);\n      }\n\n      /* COMMENT_52 */\n                                                        \n         \n      VAR_3 = tr_handleRequest(VAR_42, VAR_8, &VAR_4, getenv(VAR_51), documentRoot());\n\n      if (VAR_3 != NULL) {\n         sendResponse(VAR_3);\n         resp_free(VAR_3);   /* COMMENT_55 */\n      }\n\n      WOFREE(VAR_8);\n      st_free(VAR_18);\n      req_free(VAR_42);\n      \n#if defined(VAR_52)\n      showleaks();\n#endif\n      return 0;\n   }",
  "func_graph_path_before": null,
  "func": "int doit(int argc, char *argv[], char **envp) {\n#else\n   /*\n    * the request handler...\n    */\n   int main(int argc, char *argv[], char **envp) {\n#endif\n      HTTPRequest *req;\n      HTTPResponse *resp = NULL;\n      WOURLComponents wc = WOURLComponents_Initializer;\n      const char *qs;\n      unsigned int qs_len;\n      char *url;\n      const char *script_name, *path_info, *config_url, *username, *password, *config_options;\n      const char *reqerr;\n      WOURLError urlerr;\n      WOURLError charcheck;\n      strtbl *options = NULL;\n\n#ifdef WIN32\n      _setmode(_fileno(stdout), _O_BINARY);\n      _setmode(_fileno(stdin), _O_BINARY);\n#endif\n\n      if(argc == 2 && strcmp(argv[1], \"test\") == 0)\n      {\n\texit(do_tests());\n      }\n\n      script_name = getenv(CGI_SCRIPT_NAME);\n      path_info = getenv(CGI_PATH_INFO);\n\n      if (script_name == NULL)\n         die(INV_SCRIPT, HTTP_NOT_FOUND);\n      else if (path_info == NULL) {\n         path_info = \"/\";\n      }\n      /* Provide a hook via an environment variable to define the config URL */\n      config_url = getenv(WO_CONFIG_URL);\n      if (!config_url) {\n         /* Flat file URL */\n         /* config_url = \"file:///Local/Library/WebObjects/Configuration/WOConfig.xml\"; */\n         /* Local wotaskd */\n         /* config_url = \"http://localhost:1085\"; */\n         /* Multicast URL */\n         config_url = CONFIG_URL; /* Actually \"webobjects://239.128.14.2:1085\"; */\n      }\n      WOLog(WO_INFO,\"CGI: config url is %s\", config_url);\n      options = st_new(8);\n      st_add(options, WOCONFIG, config_url, 0);\n\n      /*\n         * If your webserver is configured to pass these environment variables, we use them to\n       * protect WOAdaptorInfo output.\n       */\n      username = getenv(WO_ADAPTOR_INFO_USERNAME);\n      if (username && strlen(username) != 0) {\n         st_add(options, WOUSERNAME, username, 0);\n         password = getenv(WO_ADAPTOR_INFO_PASSWORD);\n         if(password && strlen(password) != 0) {\n            st_add(options, WOPASSWORD, password, 0);\n         }\n      }\n\n      config_options = getenv(WO_CONFIG_OPTIONS);\n      if (config_options)\n         st_add(options, WOOPTIONS, config_options, 0);\n      /*\n       * SECURITY ALERT\n       *\n       * To disable WOAdaptorInfo, uncomment the next line.\n       * st_add(options, WOUSERNAME, \"disabled\", 0);\n       *\n       * To specify an WOAdaptorInfo username and password, uncomment the next two lines.\n       * st_add(options, WOUSERNAME, \"joe\", 0);\n       * st_add(options, WOPASSWORD, \"secret\", 0);\n       *\n       */\n\n      if (init_adaptor(options)) {\n          die(\"The request could not be completed due to a server error.\", HTTP_SERVER_ERROR);\n      }\n\n      /*\n       *  extract WebObjects application name from URI\n       */\n\n      url = WOMALLOC(strlen(path_info) + strlen(script_name) + 1);\n      strcpy(url, script_name);\n      strcat(url, path_info);\n      WOLog(WO_INFO,\"<CGI> new request: %s\",url);\n\n#ifndef __PRESERVE_UNSAFE_URLS\n      // Make sure the URL does not contain forbidden characters (0x0D or 0x0A).\n      charcheck = WOValidateInitialURL( url );\n      if ( charcheck != WOURLOK ) {\n         WOLog(WO_INFO, \"Declining request due to forbidden URL characters.\");\n         const char* _urlerr;\n         _urlerr = WOURLstrerror( charcheck );\n         die( _urlerr, HTTP_BAD_REQUEST );\n      }\n#endif\n\n      urlerr = WOParseApplicationName(&wc, url);\n      if (urlerr != WOURLOK) {\n         const char *_urlerr;\n         _urlerr = WOURLstrerror(urlerr);\n         WOLog(WO_INFO,\"URL Parsing Error: %s\", _urlerr);\n\n         if (urlerr == WOURLInvalidApplicationName) {\n             if (ac_authorizeAppListing(&wc)) {\n                 resp = WOAdaptorInfo(NULL, &wc);\n                 die_resp(resp);\n             } else {\n                 die(_urlerr, HTTP_NOT_FOUND);\n             }\n         }\n\n         die(_urlerr, HTTP_BAD_REQUEST);\n      }\n\n      /*\n       *  build the request...\n       */\n      req = req_new( getenv(\"REQUEST_METHOD\"), NULL);\n\n      /*\n       *  validate the method\n       */\n      reqerr = req_validateMethod(req);\n      if (reqerr) {\n          die(reqerr, HTTP_BAD_REQUEST);\n      }\n\n      /*\n       *  copy the headers.  This looks wierd... all we're doing is copying\n       *  *every* environment variable into our headers.  It may be beyond\n       *  the spec, but more information probably won't hurt.\n       */\n      while (envp && *envp) {\n         char *key, *value;\n         /* copy env. line. */\n         key = WOSTRDUP(*envp);\n\n         for (value = key; *value && !isspace((int)*value) && (*value != '='); value++) {}\n         if (*value) {\n            *value++ = '\\0';  /* null terminate 'key' */\n         }\n         while (*value && (isspace((int)*value) || (*value == '='))) {\n            value++;\n         }\n         /* BEGIN Support for getting the client's certificate. */\n         if (strcmp((const char *)key, \"SSL_CLIENT_CERTIFICATE\") == 0 || strcmp((const char *)key, \"SSL_SERVER_CERTIFICATE\") == 0 ) {\n             value = 0;\n             WOLog(WO_INFO,\"<CGI> DROPPING ENV VAR (DUPLICATE) = %s\", key);\n         }\n         if (strcmp((const char *)key, \"SSL_CLIENT_CERT\") == 0 || strcmp((const char *)key, \"SSL_SERVER_CERT\") == 0) {\n             value = make_cert_one_line(value);\n             //WOLog(WO_INFO,\"<CGI> PASSING %s = %s\", key, value);\n         }\n         /*  END Support for getting the client's certificate  */\n\n         if (key && *key && value && *value) {\n            /* must specify copy key and value because key translation might replace this key, and value lives in the same buffer */\n            req_addHeader(req, key, value, STR_COPYKEY|STR_COPYVALUE);\n         }\n\n         /*  BEGIN Support for getting the client's certificate  */\n         if (freeValueNeeded ) {\n             free(value);\n             freeValueNeeded=0;\n         }\n         /*  END Support for getting the client's certificate  */\n\n         WOFREE(key);\n         envp++;      /* next env variable */\n      }\n\n      /*\n       *  get form data if any\n       *  assume that POSTs with content length will be reformatted to GETs later\n       */\n      if (req->content_length > 0) {\n         req_allocateContent(req, req->content_length, 1);\n         req->getMoreContent = (req_getMoreContentCallback)readContentData;\n         if (req->content_buffer_size == 0)\n            die(ALLOCATION_FAILURE, HTTP_SERVER_ERROR);\n         if (readContentData(req, req->content, req->content_buffer_size, 1) == -1) {\n            die(WOURLstrerror(WOURLInvalidPostData), HTTP_BAD_REQUEST);\n         }\n      }\n\n      /* Always get the query string */\n      qs = getenv(\"QUERY_STRING\");\n      if (qs) {\n         qs_len = strlen(qs);\n      } else {\n         qs_len = 0;\n      }\n\n      if (qs_len > 0) {\n         wc.queryString.start = qs;\n         wc.queryString.length = qs_len;\n         WOLog(WO_INFO,\"<CGI> new request with Query String: %s\", qs);\n      }\n\n      /*\n       *  message the application & collect the response\n       */\n      resp = tr_handleRequest(req, url, &wc, getenv(CGI_SERVER_PROTOCOL), documentRoot());\n\n      if (resp != NULL) {\n         sendResponse(resp);\n         resp_free(resp);   /* dump the response */\n      }\n\n      WOFREE(url);\n      st_free(options);\n      req_free(req);\n      \n#if defined(FINDLEAKS)\n      showleaks();\n#endif\n      return 0;\n   }",
  "abstract_func": "int doit(int VAR_0, char *VAR_1[], char **VAR_2) {\n#else/* COMMENT_0 */\n     \n                            \n      \n   int main(int argc, char *argv[], char **envp) {\n#endif\n      HTTPRequest *req;\n      HTTPResponse *VAR_3 = NULL;\n      WOURLComponents VAR_4 = VAR_5;\n      const char *VAR_6;\n      unsigned int VAR_7;\n      char *VAR_8;\n      const char *VAR_9, *VAR_10, *VAR_11, *VAR_12, *VAR_13, *VAR_14;\n      const char *VAR_15;\n      WOURLError VAR_16;\n      WOURLError VAR_17;\n      strtbl *VAR_18 = NULL;\n\n#ifdef VAR_19\n      _setmode(_fileno(VAR_20), VAR_21);\n      _setmode(_fileno(VAR_22), VAR_21);\n#endif\n\n      if(VAR_0 == 2 && strcmp(VAR_1[1], \"test\") == 0)\n      {\n\texit(do_tests());\n      }\n\n      VAR_9 = getenv(VAR_23);\n      VAR_10 = getenv(VAR_24);\n\n      if (VAR_9 == NULL)\n         die(VAR_25, VAR_26);\n      else if (VAR_10 == NULL) {\n         VAR_10 = \"/\";\n      }\n      /* COMMENT_4 */\n      VAR_11 = getenv(VAR_27);\n      if (!VAR_11) {\n         /* COMMENT_5 */\n         /* COMMENT_6 */\n         /* COMMENT_7 */\n         /* COMMENT_8 */\n         /* COMMENT_9 */\n         VAR_11 = VAR_28; /* COMMENT_10 */\n      }\n      WOLog(VAR_29,\"CGI: config url is %s\", VAR_11);\n      VAR_18 = st_new(8);\n      st_add(VAR_18, VAR_30, VAR_11, 0);\n\n      /* COMMENT_11 */\n                                                                                              \n                                      \n         \n      VAR_12 = getenv(VAR_31);\n      if (VAR_12 && strlen(VAR_12) != 0) {\n         st_add(VAR_18, VAR_32, VAR_12, 0);\n         VAR_13 = getenv(VAR_33);\n         if(VAR_13 && strlen(VAR_13) != 0) {\n            st_add(VAR_18, VAR_34, VAR_13, 0);\n         }\n      }\n\n      VAR_14 = getenv(VAR_35);\n      if (VAR_14)\n         st_add(VAR_18, VAR_36, VAR_14, 0);\n      /* COMMENT_15 */\n                       \n        \n                                                           \n                                                    \n        \n                                                                                         \n                                               \n                                                  \n        \n         \n\n      if (init_adaptor(VAR_18)) {\n          die(\"The request could not be completed due to a server error.\", VAR_37);\n      }\n\n      /* COMMENT_24 */\n                                                      \n         \n\n      VAR_8 = WOMALLOC(strlen(VAR_10) + strlen(VAR_9) + 1);\n      strcpy(VAR_8, VAR_9);\n      strcat(VAR_8, VAR_10);\n      WOLog(VAR_29,\"<CGI> new request: %s\",VAR_8);\n\n#ifndef VAR_38\n      /* COMMENT_27 */\n      VAR_17 = WOValidateInitialURL( VAR_8 );\n      if ( VAR_17 != VAR_39 ) {\n         WOLog(VAR_29, \"Declining request due to forbidden URL characters.\");\n         const char* VAR_40;\n         VAR_40 = WOURLstrerror( VAR_17 );\n         die( VAR_40, VAR_41 );\n      }\n#endif\n\n      VAR_16 = WOParseApplicationName(&VAR_4, VAR_8);\n      if (VAR_16 != VAR_39) {\n         const char *VAR_40;\n         VAR_40 = WOURLstrerror(VAR_16);\n         WOLog(VAR_29,\"URL Parsing Error: %s\", VAR_40);\n\n         if (VAR_16 == VAR_42) {\n             if (ac_authorizeAppListing(&VAR_4)) {\n                 VAR_3 = WOAdaptorInfo(NULL, &VAR_4);\n                 die_resp(VAR_3);\n             } else {\n                 die(VAR_40, VAR_26);\n             }\n         }\n\n         die(VAR_40, VAR_41);\n      }\n\n      /* COMMENT_28 */\n                              \n         \n      VAR_43 = req_new( getenv(\"REQUEST_METHOD\"), NULL);\n\n      /* COMMENT_31 */\n                             \n         \n      VAR_15 = req_validateMethod(VAR_43);\n      if (VAR_15) {\n          die(VAR_15, VAR_41);\n      }\n\n      /* COMMENT_34 */\n                                                                           \n                                                                          \n                                                             \n         \n      while (VAR_2 && *VAR_2) {\n         char *VAR_44, *VAR_45;\n         /* COMMENT_39 */\n         VAR_44 = WOSTRDUP(*VAR_2);\n\n         for (VAR_45 = VAR_44; *VAR_45 && !isspace((int)*VAR_45) && (*VAR_45 != '='); VAR_45++) {}\n         if (*VAR_45) {\n            *VAR_45++ = '\\0';  /* COMMENT_40 */\n         }\n         while (*VAR_45 && (isspace((int)*VAR_45) || (*VAR_45 == '='))) {\n            VAR_45++;\n         }\n         /* COMMENT_41 */\n         if (strcmp((const char *)VAR_44, \"SSL_CLIENT_CERTIFICATE\") == 0 || strcmp((const char *)VAR_44, \"SSL_SERVER_CERTIFICATE\") == 0 ) {\n             VAR_45 = 0;\n             WOLog(VAR_29,\"<CGI> DROPPING ENV VAR (DUPLICATE) = %s\", VAR_44);\n         }\n         if (strcmp((const char *)VAR_44, \"SSL_CLIENT_CERT\") == 0 || strcmp((const char *)VAR_44, \"SSL_SERVER_CERT\") == 0) {\n             VAR_45 = make_cert_one_line(VAR_45);\n             /* COMMENT_42 */\n         }\n         /* COMMENT_43 */\n\n         if (VAR_44 && *VAR_44 && VAR_45 && *VAR_45) {\n            /* COMMENT_44 */\n            req_addHeader(VAR_43, VAR_44, VAR_45, VAR_46|VAR_47);\n         }\n\n         /* COMMENT_45 */\n         if (VAR_48 ) {\n             free(VAR_45);\n             VAR_48=0;\n         }\n         /* COMMENT_43 */\n\n         WOFREE(VAR_44);\n         VAR_2++;      /* COMMENT_46 */\n      }\n\n      /* COMMENT_47 */\n                              \n                                                                                 \n         \n      if (VAR_43->content_length > 0) {\n         req_allocateContent(VAR_43, VAR_43->content_length, 1);\n         VAR_43->getMoreContent = (req_getMoreContentCallback)VAR_49;\n         if (VAR_43->content_buffer_size == 0)\n            die(VAR_50, VAR_37);\n         if (VAR_49(VAR_43, VAR_43->content, VAR_43->content_buffer_size, 1) == -1) {\n            die(WOURLstrerror(VAR_51), VAR_41);\n         }\n      }\n\n      /* COMMENT_51 */\n      VAR_6 = getenv(\"QUERY_STRING\");\n      if (VAR_6) {\n         VAR_7 = strlen(VAR_6);\n      } else {\n         VAR_7 = 0;\n      }\n\n      if (VAR_7 > 0) {\n         VAR_4.queryString.start = VAR_6;\n         VAR_4.queryString.length = VAR_7;\n         WOLog(VAR_29,\"<CGI> new request with Query String: %s\", VAR_6);\n      }\n\n      /* COMMENT_52 */\n                                                        \n         \n      VAR_3 = tr_handleRequest(VAR_43, VAR_8, &VAR_4, getenv(VAR_52), documentRoot());\n\n      if (VAR_3 != NULL) {\n         sendResponse(VAR_3);\n         resp_free(VAR_3);   /* COMMENT_55 */\n      }\n\n      WOFREE(VAR_8);\n      st_free(VAR_18);\n      req_free(VAR_43);\n      \n#if defined(VAR_53)\n      showleaks();\n#endif\n      return 0;\n   }",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -90,6 +90,7 @@\n       strcat(url, path_info);\n       WOLog(WO_INFO,\"<CGI> new request: %s\",url);\n \n+#ifndef __PRESERVE_UNSAFE_URLS\n       // Make sure the URL does not contain forbidden characters (0x0D or 0x0A).\n       charcheck = WOValidateInitialURL( url );\n       if ( charcheck != WOURLOK ) {\n@@ -98,6 +99,7 @@\n          _urlerr = WOURLstrerror( charcheck );\n          die( _urlerr, HTTP_BAD_REQUEST );\n       }\n+#endif\n \n       urlerr = WOParseApplicationName(&wc, url);\n       if (urlerr != WOURLOK) {",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "#ifndef __PRESERVE_UNSAFE_URLS",
      "#endif"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/wocommunity/wonder/pull/992",
  "description": {
    "pr_info": {
      "title": "WO Adaptor URL Sanitization Fixes",
      "number": 992
    },
    "comment": [
      "Added fix-ups to the `Utilities/Adaptors` subfolders specifically to address a vulnerability in parsing, whereby an adversary can directly inject their own headers and content into the web requests going to the application (WO) servers behind the adaptor.\r\n\r\nThe new code returns a `404` on any encounter of a `0x0D` (carriage-return) or a `0x0A` (line-feed) character in the adaptor `translate` functions, and the defined forbidden character set is written in such a way as to be expandable later as necessary. This behavior of returning a `404` error mimics Apache's mitigation of the use of `%2f` in request URLs.\r\n\r\n**IMPORTANTLY**: This URL cleanliness will not affect content within query strings usually, since those characters are not typically expanded by webserver software before reaching the adaptor interface.\r\n\r\nTested and operating in an active production scenario, filtering arbitrary HTTP header injection or URL-based reflection but maintaining normal operation as expected. The most recent commit addresses enabling the protection by default but provides the option to regress to the previous behavior in situations and deployments where it may be considered safe or necessary.\r\n\r\nFor more information about the problem being fixed, I will post a separate link to my blog for interested users.",
      "As stated, [here is the link to my article](https://xmit.xyz/security/webobjects-url-tomfoolery/) about the WebObjects adaptor vulnerability present in Project WONDER. If the link is inappropriate, please feel free to remove it or request such.\r\n\r\nThank you.",
      "Hi Zachary, somehow we failed to give this the proper attention when you first posted it. Reviewing your detailed article now.",
      "Reviewed the patch, and I approve merging it. I want to wait for people in other timezones to have a chance to chime in, though. Until then, we confirmed this to be mitigated by the following global apache config:\r\n\r\n```\r\nRewriteEngine On\r\nRewriteOptions InheritDown\r\nRewriteRule ^.*\\x0d\\x0a - [F,L,NC]\r\n```"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "The patch addresses a security vulnerability by adding URL validation to prevent injection attacks.\n\n**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}