{
  "cve_id": "CVE-2017-13693",
  "cwe_ids": [
    "CWE-200"
  ],
  "cvss_vector": "AV:L/AC:L/Au:N/C:C/I:N/A:N",
  "cvss_is_v3": false,
  "repo_name": "acpica",
  "commit_msg": "acpi: acpica: fix acpi operand cache leak in dswstate.c\n\nI found an ACPI cache leak in ACPI early termination and boot continuing case.\n\nWhen early termination occurs due to malicious ACPI table, Linux kernel\nterminates ACPI function and continues to boot process. While kernel terminates\nACPI function, kmem_cache_destroy() reports Acpi-Operand cache leak.\n\nBoot log of ACPI operand cache leak is as follows:\n>[    0.585957] ACPI: Added _OSI(Module Device)\n>[    0.587218] ACPI: Added _OSI(Processor Device)\n>[    0.588530] ACPI: Added _OSI(3.0 _SCP Extensions)\n>[    0.589790] ACPI: Added _OSI(Processor Aggregator Device)\n>[    0.591534] ACPI Error: Illegal I/O port address/length above 64K: C806E00000004002/0x2 (20170303/hwvalid-155)\n>[    0.594351] ACPI Exception: AE_LIMIT, Unable to initialize fixed events (20170303/evevent-88)\n>[    0.597858] ACPI: Unable to start the ACPI Interpreter\n>[    0.599162] ACPI Error: Could not remove SCI handler (20170303/evmisc-281)\n>[    0.601836] kmem_cache_destroy Acpi-Operand: Slab cache still has objects\n>[    0.603556] CPU: 0 PID: 1 Comm: swapper/0 Not tainted 4.12.0-rc5 #26\n>[    0.605159] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006\n>[    0.609177] Call Trace:\n>[    0.610063]  ? dump_stack+0x5c/0x81\n>[    0.611118]  ? kmem_cache_destroy+0x1aa/0x1c0\n>[    0.612632]  ? acpi_sleep_proc_init+0x27/0x27\n>[    0.613906]  ? acpi_os_delete_cache+0xa/0x10\n>[    0.617986]  ? acpi_ut_delete_caches+0x3f/0x7b\n>[    0.619293]  ? acpi_terminate+0xa/0x14\n>[    0.620394]  ? acpi_init+0x2af/0x34f\n>[    0.621616]  ? __class_create+0x4c/0x80\n>[    0.623412]  ? video_setup+0x7f/0x7f\n>[    0.624585]  ? acpi_sleep_proc_init+0x27/0x27\n>[    0.625861]  ? do_one_initcall+0x4e/0x1a0\n>[    0.627513]  ? kernel_init_freeable+0x19e/0x21f\n>[    0.628972]  ? rest_init+0x80/0x80\n>[    0.630043]  ? kernel_init+0xa/0x100\n>[    0.631084]  ? ret_from_fork+0x25/0x30\n>[    0.633343] vgaarb: loaded\n>[    0.635036] EDAC MC: Ver: 3.0.0\n>[    0.638601] PCI: Probing PCI hardware\n>[    0.639833] PCI host bridge to bus 0000:00\n>[    0.641031] pci_bus 0000:00: root bus resource [io  0x0000-0xffff]\n> ... Continue to boot and log is omitted ...\n\nI analyzed this memory leak in detail and found acpi_ds_obj_stack_pop_and_\ndelete() function miscalculated the top of the stack. acpi_ds_obj_stack_push()\nfunction uses walk_state->operand_index for start position of the top, but\nacpi_ds_obj_stack_pop_and_delete() function considers index 0 for it.\nTherefore, this causes acpi operand memory leak.\n\nThis cache leak causes a security threat because an old kernel (<= 4.9) shows\nmemory locations of kernel functions in stack dump. Some malicious users\ncould use this information to neutralize kernel ASLR.\n\nI made a patch to fix ACPI operand cache leak.\n\nSigned-off-by: Seunghun Han <kkamagui@gmail.com>",
  "commit_hash": "987a3b5cf7175916e2a4b6ea5b8e70f830dfe732",
  "git_url": "https://github.com/acpica/acpica/commit/987a3b5cf7175916e2a4b6ea5b8e70f830dfe732",
  "file_path": "source/components/dispatcher/dsutils.c",
  "func_name": "AcpiDsCreateOperands",
  "func_before": "ACPI_STATUS\nAcpiDsCreateOperands (\n    ACPI_WALK_STATE         *WalkState,\n    ACPI_PARSE_OBJECT       *FirstArg)\n{\n    ACPI_STATUS             Status = AE_OK;\n    ACPI_PARSE_OBJECT       *Arg;\n    ACPI_PARSE_OBJECT       *Arguments[ACPI_OBJ_NUM_OPERANDS];\n    UINT32                  ArgCount = 0;\n    UINT32                  Index = WalkState->NumOperands;\n    UINT32                  i;\n\n\n    ACPI_FUNCTION_TRACE_PTR (DsCreateOperands, FirstArg);\n\n\n    /* Get all arguments in the list */\n\n    Arg = FirstArg;\n    while (Arg)\n    {\n        if (Index >= ACPI_OBJ_NUM_OPERANDS)\n        {\n            return_ACPI_STATUS (AE_BAD_DATA);\n        }\n\n        Arguments[Index] = Arg;\n        WalkState->Operands [Index] = NULL;\n\n        /* Move on to next argument, if any */\n\n        Arg = Arg->Common.Next;\n        ArgCount++;\n        Index++;\n    }\n\n    ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,\n        \"NumOperands %d, ArgCount %d, Index %d\\n\",\n        WalkState->NumOperands, ArgCount, Index));\n\n    /* Create the interpreter arguments, in reverse order */\n\n    Index--;\n    for (i = 0; i < ArgCount; i++)\n    {\n        Arg = Arguments[Index];\n        WalkState->OperandIndex = (UINT8) Index;\n\n        Status = AcpiDsCreateOperand (WalkState, Arg, Index);\n        if (ACPI_FAILURE (Status))\n        {\n            goto Cleanup;\n        }\n\n        ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,\n            \"Created Arg #%u (%p) %u args total\\n\",\n            Index, Arg, ArgCount));\n        Index--;\n    }\n\n    return_ACPI_STATUS (Status);\n\n\nCleanup:\n    /*\n     * We must undo everything done above; meaning that we must\n     * pop everything off of the operand stack and delete those\n     * objects\n     */\n    AcpiDsObjStackPopAndDelete (ArgCount, WalkState);\n\n    ACPI_EXCEPTION ((AE_INFO, Status, \"While creating Arg %u\", Index));\n    return_ACPI_STATUS (Status);\n}",
  "abstract_func_before": "ACPI_STATUS\nAcpiDsCreateOperands (\n    ACPI_WALK_STATE         *VAR_0,\n    ACPI_PARSE_OBJECT       *VAR_1)\n{\n    ACPI_STATUS             VAR_2 = VAR_3;\n    ACPI_PARSE_OBJECT       *VAR_4;\n    ACPI_PARSE_OBJECT       *VAR_5[VAR_6];\n    UINT32                  VAR_7 = 0;\n    UINT32                  VAR_8 = VAR_0->NumOperands;\n    UINT32                  VAR_9;\n\n\n    ACPI_FUNCTION_TRACE_PTR (VAR_10, VAR_1);\n\n\n    /* COMMENT_0 */\n\n    VAR_4 = VAR_1;\n    while (VAR_4)\n    {\n        if (VAR_8 >= VAR_6)\n        {\n            return_ACPI_STATUS (VAR_11);\n        }\n\n        VAR_5[VAR_8] = VAR_4;\n        VAR_0->Operands [VAR_8] = NULL;\n\n        /* COMMENT_1 */\n\n        VAR_4 = VAR_4->Common.Next;\n        VAR_7++;\n        VAR_8++;\n    }\n\n    ACPI_DEBUG_PRINT ((VAR_12,\n        \"NumOperands %d, ArgCount %d, Index %d\\n\",\n        VAR_0->NumOperands, VAR_7, VAR_8));\n\n    /* COMMENT_2 */\n\n    VAR_8--;\n    for (VAR_9 = 0; VAR_9 < VAR_7; VAR_9++)\n    {\n        VAR_4 = VAR_5[VAR_8];\n        VAR_0->OperandIndex = (UINT8) VAR_8;\n\n        VAR_2 = AcpiDsCreateOperand (VAR_0, VAR_4, VAR_8);\n        if (ACPI_FAILURE (VAR_2))\n        {\n            goto Cleanup;\n        }\n\n        ACPI_DEBUG_PRINT ((VAR_12,\n            \"Created Arg #%u (%p) %u args total\\n\",\n            VAR_8, VAR_4, VAR_7));\n        VAR_8--;\n    }\n\n    return_ACPI_STATUS (VAR_2);\n\n\nCleanup:\n    /* COMMENT_3 */\n                                                               \n                                                               \n              \n       \n    AcpiDsObjStackPopAndDelete (VAR_7, VAR_0);\n\n    ACPI_EXCEPTION ((VAR_13, VAR_2, \"While creating Arg %u\", VAR_8));\n    return_ACPI_STATUS (VAR_2);\n}",
  "func_graph_path_before": "acpica/987a3b5cf7175916e2a4b6ea5b8e70f830dfe732/dsutils.c/vul/before/0.json",
  "func": "ACPI_STATUS\nAcpiDsCreateOperands (\n    ACPI_WALK_STATE         *WalkState,\n    ACPI_PARSE_OBJECT       *FirstArg)\n{\n    ACPI_STATUS             Status = AE_OK;\n    ACPI_PARSE_OBJECT       *Arg;\n    ACPI_PARSE_OBJECT       *Arguments[ACPI_OBJ_NUM_OPERANDS];\n    UINT32                  ArgCount = 0;\n    UINT32                  Index = WalkState->NumOperands;\n    UINT32                  PrevNumOperands = WalkState->NumOperands;\n    UINT32                  NewNumOperands;\n    UINT32                  i;\n\n\n    ACPI_FUNCTION_TRACE_PTR (DsCreateOperands, FirstArg);\n\n\n    /* Get all arguments in the list */\n\n    Arg = FirstArg;\n    while (Arg)\n    {\n        if (Index >= ACPI_OBJ_NUM_OPERANDS)\n        {\n            return_ACPI_STATUS (AE_BAD_DATA);\n        }\n\n        Arguments[Index] = Arg;\n        WalkState->Operands [Index] = NULL;\n\n        /* Move on to next argument, if any */\n\n        Arg = Arg->Common.Next;\n        ArgCount++;\n        Index++;\n    }\n\n    ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,\n        \"NumOperands %d, ArgCount %d, Index %d\\n\",\n        WalkState->NumOperands, ArgCount, Index));\n\n    /* Create the interpreter arguments, in reverse order */\n\n    NewNumOperands = Index;\n    Index--;\n    for (i = 0; i < ArgCount; i++)\n    {\n        Arg = Arguments[Index];\n        WalkState->OperandIndex = (UINT8) Index;\n\n        Status = AcpiDsCreateOperand (WalkState, Arg, Index);\n        if (ACPI_FAILURE (Status))\n        {\n            goto Cleanup;\n        }\n\n        ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,\n            \"Created Arg #%u (%p) %u args total\\n\",\n            Index, Arg, ArgCount));\n        Index--;\n    }\n\n    return_ACPI_STATUS (Status);\n\n\nCleanup:\n    /*\n     * We must undo everything done above; meaning that we must\n     * pop everything off of the operand stack and delete those\n     * objects\n     */\n    WalkState->NumOperands = i;\n    AcpiDsObjStackPopAndDelete (NewNumOperands, WalkState);\n\n    /* Restore operand count */\n    WalkState->NumOperands = PrevNumOperands;\n\n    ACPI_EXCEPTION ((AE_INFO, Status, \"While creating Arg %u\", Index));\n    return_ACPI_STATUS (Status);\n}",
  "abstract_func": "ACPI_STATUS\nAcpiDsCreateOperands (\n    ACPI_WALK_STATE         *VAR_0,\n    ACPI_PARSE_OBJECT       *VAR_1)\n{\n    ACPI_STATUS             VAR_2 = VAR_3;\n    ACPI_PARSE_OBJECT       *VAR_4;\n    ACPI_PARSE_OBJECT       *VAR_5[VAR_6];\n    UINT32                  VAR_7 = 0;\n    UINT32                  VAR_8 = VAR_0->NumOperands;\n    UINT32                  VAR_9 = VAR_0->NumOperands;\n    UINT32                  VAR_10;\n    UINT32                  VAR_11;\n\n\n    ACPI_FUNCTION_TRACE_PTR (VAR_12, VAR_1);\n\n\n    /* COMMENT_0 */\n\n    VAR_4 = VAR_1;\n    while (VAR_4)\n    {\n        if (VAR_8 >= VAR_6)\n        {\n            return_ACPI_STATUS (VAR_13);\n        }\n\n        VAR_5[VAR_8] = VAR_4;\n        VAR_0->Operands [VAR_8] = NULL;\n\n        /* COMMENT_1 */\n\n        VAR_4 = VAR_4->Common.Next;\n        VAR_7++;\n        VAR_8++;\n    }\n\n    ACPI_DEBUG_PRINT ((VAR_14,\n        \"NumOperands %d, ArgCount %d, Index %d\\n\",\n        VAR_0->NumOperands, VAR_7, VAR_8));\n\n    /* COMMENT_2 */\n\n    VAR_10 = VAR_8;\n    VAR_8--;\n    for (VAR_11 = 0; VAR_11 < VAR_7; VAR_11++)\n    {\n        VAR_4 = VAR_5[VAR_8];\n        VAR_0->OperandIndex = (UINT8) VAR_8;\n\n        VAR_2 = AcpiDsCreateOperand (VAR_0, VAR_4, VAR_8);\n        if (ACPI_FAILURE (VAR_2))\n        {\n            goto Cleanup;\n        }\n\n        ACPI_DEBUG_PRINT ((VAR_14,\n            \"Created Arg #%u (%p) %u args total\\n\",\n            VAR_8, VAR_4, VAR_7));\n        VAR_8--;\n    }\n\n    return_ACPI_STATUS (VAR_2);\n\n\nCleanup:\n    /* COMMENT_3 */\n                                                               \n                                                               \n              \n       \n    VAR_0->NumOperands = VAR_11;\n    AcpiDsObjStackPopAndDelete (VAR_10, VAR_0);\n\n    /* COMMENT_8 */\n    VAR_0->NumOperands = VAR_9;\n\n    ACPI_EXCEPTION ((VAR_15, VAR_2, \"While creating Arg %u\", VAR_8));\n    return_ACPI_STATUS (VAR_2);\n}",
  "func_graph_path": "acpica/987a3b5cf7175916e2a4b6ea5b8e70f830dfe732/dsutils.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -8,6 +8,8 @@\n     ACPI_PARSE_OBJECT       *Arguments[ACPI_OBJ_NUM_OPERANDS];\n     UINT32                  ArgCount = 0;\n     UINT32                  Index = WalkState->NumOperands;\n+    UINT32                  PrevNumOperands = WalkState->NumOperands;\n+    UINT32                  NewNumOperands;\n     UINT32                  i;\n \n \n@@ -40,6 +42,7 @@\n \n     /* Create the interpreter arguments, in reverse order */\n \n+    NewNumOperands = Index;\n     Index--;\n     for (i = 0; i < ArgCount; i++)\n     {\n@@ -67,7 +70,11 @@\n      * pop everything off of the operand stack and delete those\n      * objects\n      */\n-    AcpiDsObjStackPopAndDelete (ArgCount, WalkState);\n+    WalkState->NumOperands = i;\n+    AcpiDsObjStackPopAndDelete (NewNumOperands, WalkState);\n+\n+    /* Restore operand count */\n+    WalkState->NumOperands = PrevNumOperands;\n \n     ACPI_EXCEPTION ((AE_INFO, Status, \"While creating Arg %u\", Index));\n     return_ACPI_STATUS (Status);",
  "diff_line_info": {
    "deleted_lines": [
      "    AcpiDsObjStackPopAndDelete (ArgCount, WalkState);"
    ],
    "added_lines": [
      "    UINT32                  PrevNumOperands = WalkState->NumOperands;",
      "    UINT32                  NewNumOperands;",
      "    NewNumOperands = Index;",
      "    WalkState->NumOperands = i;",
      "    AcpiDsObjStackPopAndDelete (NewNumOperands, WalkState);",
      "",
      "    /* Restore operand count */",
      "    WalkState->NumOperands = PrevNumOperands;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/acpica/acpica/pull/295",
  "description": {
    "pr_info": {
      "title": "acpi: acpica: fix acpi operand cache leak in dsutils.c",
      "number": 295
    },
    "comment": [
      "I found an ACPI cache leak in ACPI early termination and boot continuing case.\r\n\r\nWhen early termination occurs due to malicious ACPI table, Linux kernel\r\nterminates ACPI function and continues to boot process. While kernel terminates\r\nACPI function, kmem_cache_destroy() reports Acpi-Operand cache leak.\r\n\r\nBoot log of ACPI operand cache leak is as follows:\r\n>[    0.585957] ACPI: Added _OSI(Module Device)\r\n>[    0.587218] ACPI: Added _OSI(Processor Device)\r\n>[    0.588530] ACPI: Added _OSI(3.0 _SCP Extensions)\r\n>[    0.589790] ACPI: Added _OSI(Processor Aggregator Device)\r\n>[    0.591534] ACPI Error: Illegal I/O port address/length above 64K: C806E00000004002/0x2 (20170303/hwvalid-155)\r\n>[    0.594351] ACPI Exception: AE_LIMIT, Unable to initialize fixed events (20170303/evevent-88)\r\n>[    0.597858] ACPI: Unable to start the ACPI Interpreter\r\n>[    0.599162] ACPI Error: Could not remove SCI handler (20170303/evmisc-281)\r\n>[    0.601836] kmem_cache_destroy Acpi-Operand: Slab cache still has objects\r\n>[    0.603556] CPU: 0 PID: 1 Comm: swapper/0 Not tainted 4.12.0-rc5 #26\r\n>[    0.605159] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006\r\n>[    0.609177] Call Trace:\r\n>[    0.610063]  ? dump_stack+0x5c/0x81\r\n>[    0.611118]  ? kmem_cache_destroy+0x1aa/0x1c0\r\n>[    0.612632]  ? acpi_sleep_proc_init+0x27/0x27\r\n>[    0.613906]  ? acpi_os_delete_cache+0xa/0x10\r\n>[    0.617986]  ? acpi_ut_delete_caches+0x3f/0x7b\r\n>[    0.619293]  ? acpi_terminate+0xa/0x14\r\n>[    0.620394]  ? acpi_init+0x2af/0x34f\r\n>[    0.621616]  ? __class_create+0x4c/0x80\r\n>[    0.623412]  ? video_setup+0x7f/0x7f\r\n>[    0.624585]  ? acpi_sleep_proc_init+0x27/0x27\r\n>[    0.625861]  ? do_one_initcall+0x4e/0x1a0\r\n>[    0.627513]  ? kernel_init_freeable+0x19e/0x21f\r\n>[    0.628972]  ? rest_init+0x80/0x80\r\n>[    0.630043]  ? kernel_init+0xa/0x100\r\n>[    0.631084]  ? ret_from_fork+0x25/0x30\r\n>[    0.633343] vgaarb: loaded\r\n>[    0.635036] EDAC MC: Ver: 3.0.0\r\n>[    0.638601] PCI: Probing PCI hardware\r\n>[    0.639833] PCI host bridge to bus 0000:00\r\n>[    0.641031] pci_bus 0000:00: root bus resource [io  0x0000-0xffff]\r\n> ... Continue to boot and log is omitted ...\r\n\r\nI analyzed this memory leak in detail and found acpi_ds_obj_stack_pop_and_\r\ndelete() function miscalculated the top of the stack. acpi_ds_obj_stack_push()\r\nfunction uses walk_state->operand_index for start position of the top, but\r\nacpi_ds_obj_stack_pop_and_delete() function considers index 0 for it.\r\nTherefore, this causes acpi operand memory leak.\r\n\r\nThis cache leak causes a security threat because an old kernel (<= 4.9) shows\r\nmemory locations of kernel functions in stack dump. Some malicious users\r\ncould use this information to neutralize kernel ASLR.\r\n\r\nI made a patch to fix ACPI operand cache leak.\r\n\r\nSigned-off-by: Seunghun Han <kkamagui@gmail.com>",
      "This looks like a slight issue that can be detected by coverity tools.\r\n\r\nIt looks AcpiDsObjStackPopAndDelete() only wants to revert what has been done in AcpiDsCreateOperands(). So can you fix the caller - AcpiDsCreateOperands()?",
      "Hello, Lv.\r\n\r\nAccording to your comment, I changed the caller, AcpiDsCreateOperands() and pushed again.\r\nPlease check my revised commit, https://github.com/acpica/acpica/pull/295/commits/987a3b5cf7175916e2a4b6ea5b8e70f830dfe732 .\r\n\r\nI tested it in my PC, and confirmed it works fine.\r\nIf you have any request, please let me know.\r\n\r\nBest regards.\r\nSeunghun.\r\n",
      "I'm wondering what exactly you mean by \"malicious ACPI table\"\r\n",
      "Hello, Robert.\r\n\r\nI have been researching on ACPI table and I assume that some malicious users can change the table using initrd.gz, firmware flashing, etc.\r\n\r\nAs you know, these attacks are well-known in security and I have been analyzing the effect of those attacks.\r\n\r\nBest regards.\r\n\r\nSeunghun.",
      "Hello, @timofonic .\r\n\r\nI consider that ACPI table tampering by a malicious user and ACPI table tampering by a malicious user are the same. Because they can make memory information leaks and these vulnerabilities could neutralize security features in the system.\r\n\r\nI have been cooperating with Intel for several months and I hope this patch is merged soon.\r\n\r\nBest regards.\r\n\r\nSeunghun.",
      "Is there any probability of this patch being merged?  It does appear to resolve a known, public security issue (CVE-2017-13693) yet it has stalled.  Two other pull requests (#295 and #296) are in exactly the same situation.\r\n\r\nIf these patches are not to be applied as they are, what would be needed to correct them?\r\n\r\nThanks. ",
      "Hello, Timofonic.\n\nACPI table has essential information and executable code, ASL.\n\nSo security researchers and attackers are interested in ACPI table and use\nit to do something malicious.\n\nThis is ACPI tampering.\n\nIf you have any request,\nplease let me know.\n\nBest regards.\n\nSeunghun.\n\n2018. 2. 6. 오후 11:58에 \"Timofonic\" <notifications@github.com>님이 작성:\n\n@kkamagui <https://github.com/kkamagui> I'm sorry. It seems I didn't\nunderstand the mean of this fix. What do you mean by \"ACPI table\ntampering\"? Excuse me for my ignorance!\n\n@ahs3 <https://github.com/ahs3> It would be nice if it fixed security\nissues, indeed.\n\n@acpibob <https://github.com/acpibob> ACPI Master, any news? ;)\n\n—\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\n<https://github.com/acpica/acpica/pull/295#issuecomment-363447801>, or mute\nthe thread\n<https://github.com/notifications/unsubscribe-auth/ABIObnKj2TgwpzagXx4ZBh1a46nstlGeks5tSGicgaJpZM4OcXF0>\n.\n",
      "Hi.\r\n\r\nFinally, I made a tool which can reproduce this memory leak report.\r\nPlease check my github below and your email.\r\nhttps://github.com/kkamagui/acpica/tree/linux_kernel_app\r\n\r\nI hope that my tool helps you.\r\nIf you have any further question, please let me know.\r\n\r\nBest regards.",
      "Looks good to me",
      "Hi all, \r\n\r\nWhy this patch still not be merged to mainline. Does there have any concern of this patch?\r\n\r\nThanks!",
      "I have filed a acpica bug against this CVE-2017-13693 patch:\r\nhttps://bugs.acpica.org/show_bug.cgi?id=1549\r\n\r\nemail:\r\nhttps://lists.acpica.org/hyperkitty/list/devel@acpica.org/thread/CZX3DW4ZFEDCU76FCMGGWOPCZGDQSTBQ/",
      "Is there still any interest in this patch? I can take it and merge it if that is what the majority prefers, after all the CVE exploits are no ordinary bugs to be ignored..... ",
      "> Is there still any interest in this patch? I can take it and merge it if that is what the majority prefers, after all the CVE exploits are no ordinary bugs to be ignored.....\r\n\r\nIt will be good if you can take the patch. Per my understood, this patch can fix CVE-2017-13693 which relates to KASLR. Any distro who enabled KASLR should cares it.",
      "> > Is there still any interest in this patch? I can take it and merge it if that is what the majority prefers, after all the CVE exploits are no ordinary bugs to be ignored.....\r\n> \r\n> It will be good if you can take the patch. Per my understood, this patch can fix [CVE-2017-13693](https://github.com/advisories/GHSA-8xw3-8jcr-ch76) which relates to KASLR. Any distro who enabled KASLR should cares it.\r\n\r\nWhat about PR #278 from the same author? Any comments on that or interest in general?",
      "> > > Is there still any interest in this patch? I can take it and merge it if that is what the majority prefers, after all the CVE exploits are no ordinary bugs to be ignored.....\r\n> > \r\n> > \r\n> > It will be good if you can take the patch. Per my understood, this patch can fix [CVE-2017-13693](https://github.com/advisories/GHSA-8xw3-8jcr-ch76) which relates to KASLR. Any distro who enabled KASLR should cares it.\r\n> \r\n> What about PR #278 from the same author? Any comments on that or interest in general?\r\n\r\nLooks PR #278 is similar with #295. Both of them can trigger stack dump to show kernel memory location (<= 4.9) when booting for neutralizing KASLR (CVE-2017-13694).  So my suggestion is that you can also take it.",
      "Thanks for the detailed response, I can merge them both if there are no conflicts! I can also update the CVE reports. ",
      "Fixed warnings related to UINT32 -> UINT8 conversion which could result in possible data loss. "
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95  \n\nThe patch addresses a memory leak in the ACPI subsystem that exposes kernel memory addresses, posing a security risk by potentially allowing ASLR bypass. The commit message, vulnerability details, and code changes clearly indicate a security fix."
}