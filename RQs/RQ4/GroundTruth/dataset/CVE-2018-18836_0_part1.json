{
  "cve_id": "CVE-2018-18836",
  "cwe_ids": [
    "CWE-113",
    "CWE-116",
    "CWE-94",
    "CWE-200"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "netdata",
  "commit_msg": "fixed vulnerabilities identified by red4sec.com (#4521)",
  "commit_hash": "92327c9ec211bd1616315abcb255861b130b97ca",
  "git_url": "https://github.com/netdata/netdata/commit/92327c9ec211bd1616315abcb255861b130b97ca",
  "file_path": "web/api/web_api_v1.c",
  "func_name": "web_client_api_request_v1_data",
  "func_before": "inline int web_client_api_request_v1_data(RRDHOST *host, struct web_client *w, char *url) {\n    debug(D_WEB_CLIENT, \"%llu: API v1 data with URL '%s'\", w->id, url);\n\n    int ret = 400;\n    BUFFER *dimensions = NULL;\n\n    buffer_flush(w->response.data);\n\n    char    *google_version = \"0.6\",\n            *google_reqId = \"0\",\n            *google_sig = \"0\",\n            *google_out = \"json\",\n            *responseHandler = NULL,\n            *outFileName = NULL;\n\n    time_t last_timestamp_in_data = 0, google_timestamp = 0;\n\n    char *chart = NULL\n    , *before_str = NULL\n    , *after_str = NULL\n    , *group_time_str = NULL\n    , *points_str = NULL;\n\n    int group = RRDR_GROUPING_AVERAGE;\n    uint32_t format = DATASOURCE_JSON;\n    uint32_t options = 0x00000000;\n\n    while(url) {\n        char *value = mystrsep(&url, \"?&\");\n        if(!value || !*value) continue;\n\n        char *name = mystrsep(&value, \"=\");\n        if(!name || !*name) continue;\n        if(!value || !*value) continue;\n\n        debug(D_WEB_CLIENT, \"%llu: API v1 data query param '%s' with value '%s'\", w->id, name, value);\n\n        // name and value are now the parameters\n        // they are not null and not empty\n\n        if(!strcmp(name, \"chart\")) chart = value;\n        else if(!strcmp(name, \"dimension\") || !strcmp(name, \"dim\") || !strcmp(name, \"dimensions\") || !strcmp(name, \"dims\")) {\n            if(!dimensions) dimensions = buffer_create(100);\n            buffer_strcat(dimensions, \"|\");\n            buffer_strcat(dimensions, value);\n        }\n        else if(!strcmp(name, \"after\")) after_str = value;\n        else if(!strcmp(name, \"before\")) before_str = value;\n        else if(!strcmp(name, \"points\")) points_str = value;\n        else if(!strcmp(name, \"gtime\")) group_time_str = value;\n        else if(!strcmp(name, \"group\")) {\n            group = web_client_api_request_v1_data_group(value, RRDR_GROUPING_AVERAGE);\n        }\n        else if(!strcmp(name, \"format\")) {\n            format = web_client_api_request_v1_data_format(value);\n        }\n        else if(!strcmp(name, \"options\")) {\n            options |= web_client_api_request_v1_data_options(value);\n        }\n        else if(!strcmp(name, \"callback\")) {\n            responseHandler = value;\n        }\n        else if(!strcmp(name, \"filename\")) {\n            outFileName = value;\n        }\n        else if(!strcmp(name, \"tqx\")) {\n            // parse Google Visualization API options\n            // https://developers.google.com/chart/interactive/docs/dev/implementing_data_source\n            char *tqx_name, *tqx_value;\n\n            while(value) {\n                tqx_value = mystrsep(&value, \";\");\n                if(!tqx_value || !*tqx_value) continue;\n\n                tqx_name = mystrsep(&tqx_value, \":\");\n                if(!tqx_name || !*tqx_name) continue;\n                if(!tqx_value || !*tqx_value) continue;\n\n                if(!strcmp(tqx_name, \"version\"))\n                    google_version = tqx_value;\n                else if(!strcmp(tqx_name, \"reqId\"))\n                    google_reqId = tqx_value;\n                else if(!strcmp(tqx_name, \"sig\")) {\n                    google_sig = tqx_value;\n                    google_timestamp = strtoul(google_sig, NULL, 0);\n                }\n                else if(!strcmp(tqx_name, \"out\")) {\n                    google_out = tqx_value;\n                    format = web_client_api_request_v1_data_google_format(google_out);\n                }\n                else if(!strcmp(tqx_name, \"responseHandler\"))\n                    responseHandler = tqx_value;\n                else if(!strcmp(tqx_name, \"outFileName\"))\n                    outFileName = tqx_value;\n            }\n        }\n    }\n\n    if(!chart || !*chart) {\n        buffer_sprintf(w->response.data, \"No chart id is given at the request.\");\n        goto cleanup;\n    }\n\n    RRDSET *st = rrdset_find(host, chart);\n    if(!st) st = rrdset_find_byname(host, chart);\n    if(!st) {\n        buffer_strcat(w->response.data, \"Chart is not found: \");\n        buffer_strcat_htmlescape(w->response.data, chart);\n        ret = 404;\n        goto cleanup;\n    }\n    st->last_accessed_time = now_realtime_sec();\n\n    long long before = (before_str && *before_str)?str2l(before_str):0;\n    long long after  = (after_str  && *after_str) ?str2l(after_str):0;\n    int       points = (points_str && *points_str)?str2i(points_str):0;\n    long      group_time = (group_time_str && *group_time_str)?str2l(group_time_str):0;\n\n    debug(D_WEB_CLIENT, \"%llu: API command 'data' for chart '%s', dimensions '%s', after '%lld', before '%lld', points '%d', group '%d', format '%u', options '0x%08x'\"\n          , w->id\n          , chart\n          , (dimensions)?buffer_tostring(dimensions):\"\"\n          , after\n          , before\n          , points\n          , group\n          , format\n          , options\n    );\n\n    if(outFileName && *outFileName) {\n        buffer_sprintf(w->response.header, \"Content-Disposition: attachment; filename=\\\"%s\\\"\\r\\n\", outFileName);\n        debug(D_WEB_CLIENT, \"%llu: generating outfilename header: '%s'\", w->id, outFileName);\n    }\n\n    if(format == DATASOURCE_DATATABLE_JSONP) {\n        if(responseHandler == NULL)\n            responseHandler = \"google.visualization.Query.setResponse\";\n\n        debug(D_WEB_CLIENT_ACCESS, \"%llu: GOOGLE JSON/JSONP: version = '%s', reqId = '%s', sig = '%s', out = '%s', responseHandler = '%s', outFileName = '%s'\",\n                w->id, google_version, google_reqId, google_sig, google_out, responseHandler, outFileName\n        );\n\n        buffer_sprintf(w->response.data,\n                \"%s({version:'%s',reqId:'%s',status:'ok',sig:'%ld',table:\",\n                responseHandler, google_version, google_reqId, st->last_updated.tv_sec);\n    }\n    else if(format == DATASOURCE_JSONP) {\n        if(responseHandler == NULL)\n            responseHandler = \"callback\";\n\n        buffer_strcat(w->response.data, responseHandler);\n        buffer_strcat(w->response.data, \"(\");\n    }\n\n    ret = rrdset2anything_api_v1(st, w->response.data, dimensions, format, points, after, before, group, group_time\n                                 , options, &last_timestamp_in_data);\n\n    if(format == DATASOURCE_DATATABLE_JSONP) {\n        if(google_timestamp < last_timestamp_in_data)\n            buffer_strcat(w->response.data, \"});\");\n\n        else {\n            // the client already has the latest data\n            buffer_flush(w->response.data);\n            buffer_sprintf(w->response.data,\n                    \"%s({version:'%s',reqId:'%s',status:'error',errors:[{reason:'not_modified',message:'Data not modified'}]});\",\n                    responseHandler, google_version, google_reqId);\n        }\n    }\n    else if(format == DATASOURCE_JSONP)\n        buffer_strcat(w->response.data, \");\");\n\n    cleanup:\n    buffer_free(dimensions);\n    return ret;\n}",
  "abstract_func_before": "inline int web_client_api_request_v1_data(RRDHOST *VAR_0, struct web_client *VAR_1, char *VAR_2) {\n    debug(VAR_3, \"%llu: API v1 data with URL '%s'\", VAR_1->id, VAR_2);\n\n    int VAR_4 = 400;\n    BUFFER *VAR_5 = NULL;\n\n    buffer_flush(VAR_1->response.data);\n\n    char    *VAR_6 = \"0.6\",\n            *VAR_7 = \"0\",\n            *VAR_8 = \"0\",\n            *VAR_9 = \"json\",\n            *VAR_10 = NULL,\n            *VAR_11 = NULL;\n\n    time_t VAR_12 = 0, VAR_13 = 0;\n\n    char *VAR_14 = NULL\n    , *VAR_15 = NULL\n    , *VAR_16 = NULL\n    , *VAR_17 = NULL\n    , *VAR_18 = NULL;\n\n    int VAR_19 = VAR_20;\n    uint32_t VAR_21 = VAR_22;\n    uint32_t VAR_23 = 0x00000000;\n\n    while(VAR_2) {\n        char *VAR_24 = mystrsep(&VAR_2, \"?&\");\n        if(!VAR_24 || !*VAR_24) continue;\n\n        char *VAR_25 = mystrsep(&VAR_24, \"=\");\n        if(!VAR_25 || !*VAR_25) continue;\n        if(!VAR_24 || !*VAR_24) continue;\n\n        debug(VAR_3, \"%llu: API v1 data query param '%s' with value '%s'\", VAR_1->id, VAR_25, VAR_24);\n\n        /* COMMENT_0 */\n        /* COMMENT_1 */\n\n        if(!strcmp(VAR_25, \"chart\")) VAR_14 = VAR_24;\n        else if(!strcmp(VAR_25, \"dimension\") || !strcmp(VAR_25, \"dim\") || !strcmp(VAR_25, \"dimensions\") || !strcmp(VAR_25, \"dims\")) {\n            if(!VAR_5) VAR_5 = buffer_create(100);\n            buffer_strcat(VAR_5, \"|\");\n            buffer_strcat(VAR_5, VAR_24);\n        }\n        else if(!strcmp(VAR_25, \"after\")) VAR_16 = VAR_24;\n        else if(!strcmp(VAR_25, \"before\")) VAR_15 = VAR_24;\n        else if(!strcmp(VAR_25, \"points\")) VAR_18 = VAR_24;\n        else if(!strcmp(VAR_25, \"gtime\")) VAR_17 = VAR_24;\n        else if(!strcmp(VAR_25, \"group\")) {\n            VAR_19 = web_client_api_request_v1_data_group(VAR_24, VAR_20);\n        }\n        else if(!strcmp(VAR_25, \"format\")) {\n            VAR_21 = web_client_api_request_v1_data_format(VAR_24);\n        }\n        else if(!strcmp(VAR_25, \"options\")) {\n            VAR_23 |= web_client_api_request_v1_data_options(VAR_24);\n        }\n        else if(!strcmp(VAR_25, \"callback\")) {\n            VAR_10 = VAR_24;\n        }\n        else if(!strcmp(VAR_25, \"filename\")) {\n            VAR_11 = VAR_24;\n        }\n        else if(!strcmp(VAR_25, \"tqx\")) {\n            /* COMMENT_2 */\n            /* COMMENT_3 */\n            char *VAR_26, *VAR_27;\n\n            while(VAR_24) {\n                VAR_27 = mystrsep(&VAR_24, \";\");\n                if(!VAR_27 || !*VAR_27) continue;\n\n                VAR_26 = mystrsep(&VAR_27, \":\");\n                if(!VAR_26 || !*VAR_26) continue;\n                if(!VAR_27 || !*VAR_27) continue;\n\n                if(!strcmp(VAR_26, \"version\"))\n                    VAR_6 = VAR_27;\n                else if(!strcmp(VAR_26, \"reqId\"))\n                    VAR_7 = VAR_27;\n                else if(!strcmp(VAR_26, \"sig\")) {\n                    VAR_8 = VAR_27;\n                    VAR_13 = strtoul(VAR_8, NULL, 0);\n                }\n                else if(!strcmp(VAR_26, \"out\")) {\n                    VAR_9 = VAR_27;\n                    VAR_21 = web_client_api_request_v1_data_google_format(VAR_9);\n                }\n                else if(!strcmp(VAR_26, \"responseHandler\"))\n                    VAR_10 = VAR_27;\n                else if(!strcmp(VAR_26, \"outFileName\"))\n                    VAR_11 = VAR_27;\n            }\n        }\n    }\n\n    if(!VAR_14 || !*VAR_14) {\n        buffer_sprintf(VAR_1->response.data, \"No chart id is given at the request.\");\n        goto cleanup;\n    }\n\n    RRDSET *VAR_28 = rrdset_find(VAR_0, VAR_14);\n    if(!VAR_28) VAR_28 = rrdset_find_byname(VAR_0, VAR_14);\n    if(!VAR_28) {\n        buffer_strcat(VAR_1->response.data, \"Chart is not found: \");\n        buffer_strcat_htmlescape(VAR_1->response.data, VAR_14);\n        VAR_4 = 404;\n        goto cleanup;\n    }\n    VAR_28->last_accessed_time = now_realtime_sec();\n\n    long long VAR_29 = (VAR_15 && *VAR_15)?str2l(VAR_15):0;\n    long long VAR_30  = (VAR_16  && *VAR_16) ?str2l(VAR_16):0;\n    int       VAR_31 = (VAR_18 && *VAR_18)?str2i(VAR_18):0;\n    long      VAR_32 = (VAR_17 && *VAR_17)?str2l(VAR_17):0;\n\n    debug(VAR_3, \"%llu: API command 'data' for chart '%s', dimensions '%s', after '%lld', before '%lld', points '%d', group '%d', format '%u', options '0x%08x'\"\n          , VAR_1->id\n          , VAR_14\n          , (VAR_5)?buffer_tostring(VAR_5):\"\"\n          , VAR_30\n          , VAR_29\n          , VAR_31\n          , VAR_19\n          , VAR_21\n          , VAR_23\n    );\n\n    if(VAR_11 && *VAR_11) {\n        buffer_sprintf(VAR_1->response.header, \"Content-Disposition: attachment; filename=\\\"%s\\\"\\r\\n\", VAR_11);\n        debug(VAR_3, \"%llu: generating outfilename header: '%s'\", VAR_1->id, VAR_11);\n    }\n\n    if(VAR_21 == VAR_33) {\n        if(VAR_10 == NULL)\n            VAR_10 = \"google.visualization.Query.setResponse\";\n\n        debug(VAR_34, \"%llu: GOOGLE JSON/JSONP: version = '%s', reqId = '%s', sig = '%s', out = '%s', responseHandler = '%s', outFileName = '%s'\",\n                VAR_1->id, VAR_6, VAR_7, VAR_8, VAR_9, VAR_10, VAR_11\n        );\n\n        buffer_sprintf(VAR_1->response.data,\n                \"%s({version:'%s',reqId:'%s',status:'ok',sig:'%ld',table:\",\n                VAR_10, VAR_6, VAR_7, VAR_28->last_updated.tv_sec);\n    }\n    else if(VAR_21 == VAR_35) {\n        if(VAR_10 == NULL)\n            VAR_10 = \"callback\";\n\n        buffer_strcat(VAR_1->response.data, VAR_10);\n        buffer_strcat(VAR_1->response.data, \"(\");\n    }\n\n    VAR_4 = rrdset2anything_api_v1(VAR_28, VAR_1->response.data, VAR_5, VAR_21, VAR_31, VAR_30, VAR_29, VAR_19, VAR_32\n                                 , VAR_23, &VAR_12);\n\n    if(VAR_21 == VAR_33) {\n        if(VAR_13 < VAR_12)\n            buffer_strcat(VAR_1->response.data, \"});\");\n\n        else {\n            /* COMMENT_4 */\n            buffer_flush(VAR_1->response.data);\n            buffer_sprintf(VAR_1->response.data,\n                    \"%s({version:'%s',reqId:'%s',status:'error',errors:[{reason:'not_modified',message:'Data not modified'}]});\",\n                    VAR_10, VAR_6, VAR_7);\n        }\n    }\n    else if(VAR_21 == VAR_35)\n        buffer_strcat(VAR_1->response.data, \");\");\n\n    cleanup:\n    buffer_free(VAR_5);\n    return VAR_4;\n}",
  "func_graph_path_before": "netdata/92327c9ec211bd1616315abcb255861b130b97ca/web_api_v1.c/vul/before/0.json",
  "func": "inline int web_client_api_request_v1_data(RRDHOST *host, struct web_client *w, char *url) {\n    debug(D_WEB_CLIENT, \"%llu: API v1 data with URL '%s'\", w->id, url);\n\n    int ret = 400;\n    BUFFER *dimensions = NULL;\n\n    buffer_flush(w->response.data);\n\n    char    *google_version = \"0.6\",\n            *google_reqId = \"0\",\n            *google_sig = \"0\",\n            *google_out = \"json\",\n            *responseHandler = NULL,\n            *outFileName = NULL;\n\n    time_t last_timestamp_in_data = 0, google_timestamp = 0;\n\n    char *chart = NULL\n    , *before_str = NULL\n    , *after_str = NULL\n    , *group_time_str = NULL\n    , *points_str = NULL;\n\n    int group = RRDR_GROUPING_AVERAGE;\n    uint32_t format = DATASOURCE_JSON;\n    uint32_t options = 0x00000000;\n\n    while(url) {\n        char *value = mystrsep(&url, \"?&\");\n        if(!value || !*value) continue;\n\n        char *name = mystrsep(&value, \"=\");\n        if(!name || !*name) continue;\n        if(!value || !*value) continue;\n\n        debug(D_WEB_CLIENT, \"%llu: API v1 data query param '%s' with value '%s'\", w->id, name, value);\n\n        // name and value are now the parameters\n        // they are not null and not empty\n\n        if(!strcmp(name, \"chart\")) chart = value;\n        else if(!strcmp(name, \"dimension\") || !strcmp(name, \"dim\") || !strcmp(name, \"dimensions\") || !strcmp(name, \"dims\")) {\n            if(!dimensions) dimensions = buffer_create(100);\n            buffer_strcat(dimensions, \"|\");\n            buffer_strcat(dimensions, value);\n        }\n        else if(!strcmp(name, \"after\")) after_str = value;\n        else if(!strcmp(name, \"before\")) before_str = value;\n        else if(!strcmp(name, \"points\")) points_str = value;\n        else if(!strcmp(name, \"gtime\")) group_time_str = value;\n        else if(!strcmp(name, \"group\")) {\n            group = web_client_api_request_v1_data_group(value, RRDR_GROUPING_AVERAGE);\n        }\n        else if(!strcmp(name, \"format\")) {\n            format = web_client_api_request_v1_data_format(value);\n        }\n        else if(!strcmp(name, \"options\")) {\n            options |= web_client_api_request_v1_data_options(value);\n        }\n        else if(!strcmp(name, \"callback\")) {\n            responseHandler = value;\n        }\n        else if(!strcmp(name, \"filename\")) {\n            outFileName = value;\n        }\n        else if(!strcmp(name, \"tqx\")) {\n            // parse Google Visualization API options\n            // https://developers.google.com/chart/interactive/docs/dev/implementing_data_source\n            char *tqx_name, *tqx_value;\n\n            while(value) {\n                tqx_value = mystrsep(&value, \";\");\n                if(!tqx_value || !*tqx_value) continue;\n\n                tqx_name = mystrsep(&tqx_value, \":\");\n                if(!tqx_name || !*tqx_name) continue;\n                if(!tqx_value || !*tqx_value) continue;\n\n                if(!strcmp(tqx_name, \"version\"))\n                    google_version = tqx_value;\n                else if(!strcmp(tqx_name, \"reqId\"))\n                    google_reqId = tqx_value;\n                else if(!strcmp(tqx_name, \"sig\")) {\n                    google_sig = tqx_value;\n                    google_timestamp = strtoul(google_sig, NULL, 0);\n                }\n                else if(!strcmp(tqx_name, \"out\")) {\n                    google_out = tqx_value;\n                    format = web_client_api_request_v1_data_google_format(google_out);\n                }\n                else if(!strcmp(tqx_name, \"responseHandler\"))\n                    responseHandler = tqx_value;\n                else if(!strcmp(tqx_name, \"outFileName\"))\n                    outFileName = tqx_value;\n            }\n        }\n    }\n\n    // validate the google parameters given\n    fix_google_param(google_out);\n    fix_google_param(google_sig);\n    fix_google_param(google_reqId);\n    fix_google_param(google_version);\n    fix_google_param(responseHandler);\n    fix_google_param(outFileName);\n\n    if(!chart || !*chart) {\n        buffer_sprintf(w->response.data, \"No chart id is given at the request.\");\n        goto cleanup;\n    }\n\n    RRDSET *st = rrdset_find(host, chart);\n    if(!st) st = rrdset_find_byname(host, chart);\n    if(!st) {\n        buffer_strcat(w->response.data, \"Chart is not found: \");\n        buffer_strcat_htmlescape(w->response.data, chart);\n        ret = 404;\n        goto cleanup;\n    }\n    st->last_accessed_time = now_realtime_sec();\n\n    long long before = (before_str && *before_str)?str2l(before_str):0;\n    long long after  = (after_str  && *after_str) ?str2l(after_str):0;\n    int       points = (points_str && *points_str)?str2i(points_str):0;\n    long      group_time = (group_time_str && *group_time_str)?str2l(group_time_str):0;\n\n    debug(D_WEB_CLIENT, \"%llu: API command 'data' for chart '%s', dimensions '%s', after '%lld', before '%lld', points '%d', group '%d', format '%u', options '0x%08x'\"\n          , w->id\n          , chart\n          , (dimensions)?buffer_tostring(dimensions):\"\"\n          , after\n          , before\n          , points\n          , group\n          , format\n          , options\n    );\n\n    if(outFileName && *outFileName) {\n        buffer_sprintf(w->response.header, \"Content-Disposition: attachment; filename=\\\"%s\\\"\\r\\n\", outFileName);\n        debug(D_WEB_CLIENT, \"%llu: generating outfilename header: '%s'\", w->id, outFileName);\n    }\n\n    if(format == DATASOURCE_DATATABLE_JSONP) {\n        if(responseHandler == NULL)\n            responseHandler = \"google.visualization.Query.setResponse\";\n\n        debug(D_WEB_CLIENT_ACCESS, \"%llu: GOOGLE JSON/JSONP: version = '%s', reqId = '%s', sig = '%s', out = '%s', responseHandler = '%s', outFileName = '%s'\",\n                w->id, google_version, google_reqId, google_sig, google_out, responseHandler, outFileName\n        );\n\n        buffer_sprintf(w->response.data,\n                \"%s({version:'%s',reqId:'%s',status:'ok',sig:'%ld',table:\",\n                responseHandler, google_version, google_reqId, st->last_updated.tv_sec);\n    }\n    else if(format == DATASOURCE_JSONP) {\n        if(responseHandler == NULL)\n            responseHandler = \"callback\";\n\n        buffer_strcat(w->response.data, responseHandler);\n        buffer_strcat(w->response.data, \"(\");\n    }\n\n    ret = rrdset2anything_api_v1(st, w->response.data, dimensions, format, points, after, before, group, group_time\n                                 , options, &last_timestamp_in_data);\n\n    if(format == DATASOURCE_DATATABLE_JSONP) {\n        if(google_timestamp < last_timestamp_in_data)\n            buffer_strcat(w->response.data, \"});\");\n\n        else {\n            // the client already has the latest data\n            buffer_flush(w->response.data);\n            buffer_sprintf(w->response.data,\n                    \"%s({version:'%s',reqId:'%s',status:'error',errors:[{reason:'not_modified',message:'Data not modified'}]});\",\n                    responseHandler, google_version, google_reqId);\n        }\n    }\n    else if(format == DATASOURCE_JSONP)\n        buffer_strcat(w->response.data, \");\");\n\n    cleanup:\n    buffer_free(dimensions);\n    return ret;\n}",
  "abstract_func": "inline int web_client_api_request_v1_data(RRDHOST *VAR_0, struct web_client *VAR_1, char *VAR_2) {\n    debug(VAR_3, \"%llu: API v1 data with URL '%s'\", VAR_1->id, VAR_2);\n\n    int VAR_4 = 400;\n    BUFFER *VAR_5 = NULL;\n\n    buffer_flush(VAR_1->response.data);\n\n    char    *VAR_6 = \"0.6\",\n            *VAR_7 = \"0\",\n            *VAR_8 = \"0\",\n            *VAR_9 = \"json\",\n            *VAR_10 = NULL,\n            *VAR_11 = NULL;\n\n    time_t VAR_12 = 0, VAR_13 = 0;\n\n    char *VAR_14 = NULL\n    , *VAR_15 = NULL\n    , *VAR_16 = NULL\n    , *VAR_17 = NULL\n    , *VAR_18 = NULL;\n\n    int VAR_19 = VAR_20;\n    uint32_t VAR_21 = VAR_22;\n    uint32_t VAR_23 = 0x00000000;\n\n    while(VAR_2) {\n        char *VAR_24 = mystrsep(&VAR_2, \"?&\");\n        if(!VAR_24 || !*VAR_24) continue;\n\n        char *VAR_25 = mystrsep(&VAR_24, \"=\");\n        if(!VAR_25 || !*VAR_25) continue;\n        if(!VAR_24 || !*VAR_24) continue;\n\n        debug(VAR_3, \"%llu: API v1 data query param '%s' with value '%s'\", VAR_1->id, VAR_25, VAR_24);\n\n        /* COMMENT_0 */\n        /* COMMENT_1 */\n\n        if(!strcmp(VAR_25, \"chart\")) VAR_14 = VAR_24;\n        else if(!strcmp(VAR_25, \"dimension\") || !strcmp(VAR_25, \"dim\") || !strcmp(VAR_25, \"dimensions\") || !strcmp(VAR_25, \"dims\")) {\n            if(!VAR_5) VAR_5 = buffer_create(100);\n            buffer_strcat(VAR_5, \"|\");\n            buffer_strcat(VAR_5, VAR_24);\n        }\n        else if(!strcmp(VAR_25, \"after\")) VAR_16 = VAR_24;\n        else if(!strcmp(VAR_25, \"before\")) VAR_15 = VAR_24;\n        else if(!strcmp(VAR_25, \"points\")) VAR_18 = VAR_24;\n        else if(!strcmp(VAR_25, \"gtime\")) VAR_17 = VAR_24;\n        else if(!strcmp(VAR_25, \"group\")) {\n            VAR_19 = web_client_api_request_v1_data_group(VAR_24, VAR_20);\n        }\n        else if(!strcmp(VAR_25, \"format\")) {\n            VAR_21 = web_client_api_request_v1_data_format(VAR_24);\n        }\n        else if(!strcmp(VAR_25, \"options\")) {\n            VAR_23 |= web_client_api_request_v1_data_options(VAR_24);\n        }\n        else if(!strcmp(VAR_25, \"callback\")) {\n            VAR_10 = VAR_24;\n        }\n        else if(!strcmp(VAR_25, \"filename\")) {\n            VAR_11 = VAR_24;\n        }\n        else if(!strcmp(VAR_25, \"tqx\")) {\n            /* COMMENT_2 */\n            /* COMMENT_3 */\n            char *VAR_26, *VAR_27;\n\n            while(VAR_24) {\n                VAR_27 = mystrsep(&VAR_24, \";\");\n                if(!VAR_27 || !*VAR_27) continue;\n\n                VAR_26 = mystrsep(&VAR_27, \":\");\n                if(!VAR_26 || !*VAR_26) continue;\n                if(!VAR_27 || !*VAR_27) continue;\n\n                if(!strcmp(VAR_26, \"version\"))\n                    VAR_6 = VAR_27;\n                else if(!strcmp(VAR_26, \"reqId\"))\n                    VAR_7 = VAR_27;\n                else if(!strcmp(VAR_26, \"sig\")) {\n                    VAR_8 = VAR_27;\n                    VAR_13 = strtoul(VAR_8, NULL, 0);\n                }\n                else if(!strcmp(VAR_26, \"out\")) {\n                    VAR_9 = VAR_27;\n                    VAR_21 = web_client_api_request_v1_data_google_format(VAR_9);\n                }\n                else if(!strcmp(VAR_26, \"responseHandler\"))\n                    VAR_10 = VAR_27;\n                else if(!strcmp(VAR_26, \"outFileName\"))\n                    VAR_11 = VAR_27;\n            }\n        }\n    }\n\n    /* COMMENT_4 */\n    fix_google_param(VAR_9);\n    fix_google_param(VAR_8);\n    fix_google_param(VAR_7);\n    fix_google_param(VAR_6);\n    fix_google_param(VAR_10);\n    fix_google_param(VAR_11);\n\n    if(!VAR_14 || !*VAR_14) {\n        buffer_sprintf(VAR_1->response.data, \"No chart id is given at the request.\");\n        goto cleanup;\n    }\n\n    RRDSET *VAR_28 = rrdset_find(VAR_0, VAR_14);\n    if(!VAR_28) VAR_28 = rrdset_find_byname(VAR_0, VAR_14);\n    if(!VAR_28) {\n        buffer_strcat(VAR_1->response.data, \"Chart is not found: \");\n        buffer_strcat_htmlescape(VAR_1->response.data, VAR_14);\n        VAR_4 = 404;\n        goto cleanup;\n    }\n    VAR_28->last_accessed_time = now_realtime_sec();\n\n    long long VAR_29 = (VAR_15 && *VAR_15)?str2l(VAR_15):0;\n    long long VAR_30  = (VAR_16  && *VAR_16) ?str2l(VAR_16):0;\n    int       VAR_31 = (VAR_18 && *VAR_18)?str2i(VAR_18):0;\n    long      VAR_32 = (VAR_17 && *VAR_17)?str2l(VAR_17):0;\n\n    debug(VAR_3, \"%llu: API command 'data' for chart '%s', dimensions '%s', after '%lld', before '%lld', points '%d', group '%d', format '%u', options '0x%08x'\"\n          , VAR_1->id\n          , VAR_14\n          , (VAR_5)?buffer_tostring(VAR_5):\"\"\n          , VAR_30\n          , VAR_29\n          , VAR_31\n          , VAR_19\n          , VAR_21\n          , VAR_23\n    );\n\n    if(VAR_11 && *VAR_11) {\n        buffer_sprintf(VAR_1->response.header, \"Content-Disposition: attachment; filename=\\\"%s\\\"\\r\\n\", VAR_11);\n        debug(VAR_3, \"%llu: generating outfilename header: '%s'\", VAR_1->id, VAR_11);\n    }\n\n    if(VAR_21 == VAR_33) {\n        if(VAR_10 == NULL)\n            VAR_10 = \"google.visualization.Query.setResponse\";\n\n        debug(VAR_34, \"%llu: GOOGLE JSON/JSONP: version = '%s', reqId = '%s', sig = '%s', out = '%s', responseHandler = '%s', outFileName = '%s'\",\n                VAR_1->id, VAR_6, VAR_7, VAR_8, VAR_9, VAR_10, VAR_11\n        );\n\n        buffer_sprintf(VAR_1->response.data,\n                \"%s({version:'%s',reqId:'%s',status:'ok',sig:'%ld',table:\",\n                VAR_10, VAR_6, VAR_7, VAR_28->last_updated.tv_sec);\n    }\n    else if(VAR_21 == VAR_35) {\n        if(VAR_10 == NULL)\n            VAR_10 = \"callback\";\n\n        buffer_strcat(VAR_1->response.data, VAR_10);\n        buffer_strcat(VAR_1->response.data, \"(\");\n    }\n\n    VAR_4 = rrdset2anything_api_v1(VAR_28, VAR_1->response.data, VAR_5, VAR_21, VAR_31, VAR_30, VAR_29, VAR_19, VAR_32\n                                 , VAR_23, &VAR_12);\n\n    if(VAR_21 == VAR_33) {\n        if(VAR_13 < VAR_12)\n            buffer_strcat(VAR_1->response.data, \"});\");\n\n        else {\n            /* COMMENT_5 */\n            buffer_flush(VAR_1->response.data);\n            buffer_sprintf(VAR_1->response.data,\n                    \"%s({version:'%s',reqId:'%s',status:'error',errors:[{reason:'not_modified',message:'Data not modified'}]});\",\n                    VAR_10, VAR_6, VAR_7);\n        }\n    }\n    else if(VAR_21 == VAR_35)\n        buffer_strcat(VAR_1->response.data, \");\");\n\n    cleanup:\n    buffer_free(VAR_5);\n    return VAR_4;\n}",
  "func_graph_path": "netdata/92327c9ec211bd1616315abcb255861b130b97ca/web_api_v1.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -96,6 +96,14 @@\n         }\n     }\n \n+    // validate the google parameters given\n+    fix_google_param(google_out);\n+    fix_google_param(google_sig);\n+    fix_google_param(google_reqId);\n+    fix_google_param(google_version);\n+    fix_google_param(responseHandler);\n+    fix_google_param(outFileName);\n+\n     if(!chart || !*chart) {\n         buffer_sprintf(w->response.data, \"No chart id is given at the request.\");\n         goto cleanup;",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "    // validate the google parameters given",
      "    fix_google_param(google_out);",
      "    fix_google_param(google_sig);",
      "    fix_google_param(google_reqId);",
      "    fix_google_param(google_version);",
      "    fix_google_param(responseHandler);",
      "    fix_google_param(outFileName);",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/netdata/netdata/pull/4521",
  "description": {
    "pr_info": {
      "title": "fixed vulnerabilities identified by red4sec.com",
      "number": 4521
    },
    "comment": [
      "##### Summary\r\n<!--- Describe the change below, including rationale and design decisions -->\r\n\r\nI received an email by Red4Sec.com that identified 4 security issues on the netdata web server:\r\n\r\n1. HTTP header injection (make the web server return a specific HTTP header)\r\n2. LOG injection (make the web server log a line at its logs)\r\n3. JSON injection (make the web server return a JSON response)\r\n4. Full Path Disclosure\r\n\r\nThis PR fixes the 3 first of them.\r\n\r\nThe 4th one is intentional.\r\n\r\n<!--- HINT: Include \"Fixes #nnn\" if you are fixing an existing issue -->\r\n\r\n##### Component Name\r\n<!--- Write the short name of the module or plugin below -->\r\n\r\ncore/webserver\r\n\r\n##### Additional Information\r\n<!--- Include additional information to help people understand the change here -->\r\n<!--- A step-by-step reproduction of the problem is helpful if there is no related issue -->\r\n\r\n<!--- Paste log output below, e.g. before and after your change -->\r\n```paste below\r\n\r\n```\r\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "The commit addresses security vulnerabilities by fixing injection issues through parameter validation, as indicated by the commit message, description, and code changes.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95"
}