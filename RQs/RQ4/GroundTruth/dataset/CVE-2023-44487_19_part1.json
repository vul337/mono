{
  "cve_id": "CVE-2023-44487",
  "cwe_ids": [
    "CWE-400"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "envoyproxy/envoy",
  "commit_msg": "Limit the number of HTTP requests processed from a connection in I/O cycle\n\nSigned-off-by: Yan Avlasov <yavlasov@google.com>\n\nSigned-off-by: Ryan Northey <ryan@synca.io>",
  "commit_hash": "cf687ac66b60f14a71e2a7e552943f138922a71d",
  "git_url": "https://github.com/envoyproxy/envoy/commit/cf687ac66b60f14a71e2a7e552943f138922a71d",
  "file_path": "source/common/http/conn_manager_impl.cc",
  "func_name": "ConnectionManagerImpl::ActiveStream::decodeHeaders",
  "func_before": "void ConnectionManagerImpl::ActiveStream::decodeHeaders(RequestHeaderMapSharedPtr&& headers,\n                                                        bool end_stream) {\n  ENVOY_STREAM_LOG(debug, \"request headers complete (end_stream={}):\\n{}\", *this, end_stream,\n                   *headers);\n  ScopeTrackerScopeState scope(this,\n                               connection_manager_.read_callbacks_->connection().dispatcher());\n  request_headers_ = std::move(headers);\n  filter_manager_.requestHeadersInitialized();\n  if (request_header_timer_ != nullptr) {\n    request_header_timer_->disableTimer();\n    request_header_timer_.reset();\n  }\n\n  // Both shouldDrainConnectionUponCompletion() and is_head_request_ affect local replies: set them\n  // as early as possible.\n  const Protocol protocol = connection_manager_.codec_->protocol();\n  if (Runtime::runtimeFeatureEnabled(\n          \"envoy.reloadable_features.http1_connection_close_header_in_redirect\")) {\n    if (HeaderUtility::shouldCloseConnection(protocol, *request_headers_)) {\n      // Only mark the connection to be closed if the request indicates so. The connection might\n      // already be marked so before this step, in which case if shouldCloseConnection() returns\n      // false, the stream info value shouldn't be overridden.\n      filter_manager_.streamInfo().setShouldDrainConnectionUponCompletion(true);\n    }\n  } else {\n    filter_manager_.streamInfo().setShouldDrainConnectionUponCompletion(\n        HeaderUtility::shouldCloseConnection(protocol, *request_headers_));\n  }\n\n  filter_manager_.streamInfo().protocol(protocol);\n\n  // We end the decode here to mark that the downstream stream is complete.\n  maybeEndDecode(end_stream);\n\n  if (!validateHeaders()) {\n    ENVOY_STREAM_LOG(debug, \"request headers validation failed\\n{}\", *this, *request_headers_);\n    return;\n  }\n\n  // We need to snap snapped_route_config_ here as it's used in mutateRequestHeaders later.\n  if (connection_manager_.config_.isRoutable()) {\n    if (connection_manager_.config_.routeConfigProvider() != nullptr) {\n      snapped_route_config_ = connection_manager_.config_.routeConfigProvider()->configCast();\n    } else if (connection_manager_.config_.scopedRouteConfigProvider() != nullptr &&\n               connection_manager_.config_.scopeKeyBuilder().has_value()) {\n      snapped_scoped_routes_config_ =\n          connection_manager_.config_.scopedRouteConfigProvider()->config<Router::ScopedConfig>();\n      snapScopedRouteConfig();\n    }\n  } else {\n    snapped_route_config_ = connection_manager_.config_.routeConfigProvider()->configCast();\n  }\n\n  // Drop new requests when overloaded as soon as we have decoded the headers.\n  const bool drop_request_due_to_overload =\n      (connection_manager_.accept_new_http_stream_ != nullptr &&\n       connection_manager_.accept_new_http_stream_->shouldShedLoad()) ||\n      connection_manager_.random_generator_.bernoulli(\n          connection_manager_.overload_stop_accepting_requests_ref_.value());\n\n  if (drop_request_due_to_overload) {\n    // In this one special case, do not create the filter chain. If there is a risk of memory\n    // overload it is more important to avoid unnecessary allocation than to create the filters.\n    filter_manager_.skipFilterChainCreation();\n    connection_manager_.stats_.named_.downstream_rq_overload_close_.inc();\n    sendLocalReply(Http::Code::ServiceUnavailable, \"envoy overloaded\", nullptr, absl::nullopt,\n                   StreamInfo::ResponseCodeDetails::get().Overload);\n    return;\n  }\n\n  if (!connection_manager_.config_.proxy100Continue() && request_headers_->Expect() &&\n      // The Expect field-value is case-insensitive.\n      // https://tools.ietf.org/html/rfc7231#section-5.1.1\n      absl::EqualsIgnoreCase((request_headers_->Expect()->value().getStringView()),\n                             Headers::get().ExpectValues._100Continue)) {\n    // Note in the case Envoy is handling 100-Continue complexity, it skips the filter chain\n    // and sends the 100-Continue directly to the encoder.\n    chargeStats(continueHeader());\n    response_encoder_->encode1xxHeaders(continueHeader());\n    // Remove the Expect header so it won't be handled again upstream.\n    request_headers_->removeExpect();\n  }\n\n  connection_manager_.user_agent_.initializeFromHeaders(*request_headers_,\n                                                        connection_manager_.stats_.prefixStatName(),\n                                                        connection_manager_.stats_.scope_);\n\n  if (!request_headers_->Host()) {\n    // Require host header. For HTTP/1.1 Host has already been translated to :authority.\n    sendLocalReply(Code::BadRequest, \"\", nullptr, absl::nullopt,\n                   StreamInfo::ResponseCodeDetails::get().MissingHost);\n    return;\n  }\n\n  // Apply header sanity checks.\n  absl::optional<std::reference_wrapper<const absl::string_view>> error =\n      HeaderUtility::requestHeadersValid(*request_headers_);\n  if (error != absl::nullopt) {\n    sendLocalReply(Code::BadRequest, \"\", nullptr, absl::nullopt, error.value().get());\n    if (!response_encoder_->streamErrorOnInvalidHttpMessage()) {\n      connection_manager_.handleCodecError(error.value().get());\n    }\n    return;\n  }\n\n  // Check for the existence of the :path header for non-CONNECT requests, or present-but-empty\n  // :path header for CONNECT requests. We expect the codec to have broken the path into pieces if\n  // applicable. NOTE: Currently the HTTP/1.1 codec only does this when the allow_absolute_url flag\n  // is enabled on the HCM.\n  if ((!HeaderUtility::isConnect(*request_headers_) || request_headers_->Path()) &&\n      request_headers_->getPathValue().empty()) {\n    sendLocalReply(Code::NotFound, \"\", nullptr, absl::nullopt,\n                   StreamInfo::ResponseCodeDetails::get().MissingPath);\n    return;\n  }\n\n  // Rewrites the host of CONNECT-UDP requests.\n  if (Runtime::runtimeFeatureEnabled(\"envoy.reloadable_features.enable_connect_udp_support\") &&\n      HeaderUtility::isConnectUdpRequest(*request_headers_) &&\n      !HeaderUtility::rewriteAuthorityForConnectUdp(*request_headers_)) {\n    sendLocalReply(Code::NotFound, \"The path is incorrect for CONNECT-UDP\", nullptr, absl::nullopt,\n                   StreamInfo::ResponseCodeDetails::get().InvalidPath);\n    return;\n  }\n\n  // Currently we only support relative paths at the application layer.\n  if (!request_headers_->getPathValue().empty() && request_headers_->getPathValue()[0] != '/') {\n    connection_manager_.stats_.named_.downstream_rq_non_relative_path_.inc();\n    sendLocalReply(Code::NotFound, \"\", nullptr, absl::nullopt,\n                   StreamInfo::ResponseCodeDetails::get().AbsolutePath);\n    return;\n  }\n\n#ifndef ENVOY_ENABLE_UHV\n  // In UHV mode path normalization is done in the UHV\n  // Path sanitization should happen before any path access other than the above sanity check.\n  const auto action =\n      ConnectionManagerUtility::maybeNormalizePath(*request_headers_, connection_manager_.config_);\n  // gRPC requests are rejected if Envoy is configured to redirect post-normalization. This is\n  // because gRPC clients do not support redirect.\n  if (action == ConnectionManagerUtility::NormalizePathAction::Reject ||\n      (action == ConnectionManagerUtility::NormalizePathAction::Redirect &&\n       Grpc::Common::hasGrpcContentType(*request_headers_))) {\n    connection_manager_.stats_.named_.downstream_rq_failed_path_normalization_.inc();\n    sendLocalReply(Code::BadRequest, \"\", nullptr, absl::nullopt,\n                   StreamInfo::ResponseCodeDetails::get().PathNormalizationFailed);\n    return;\n  } else if (action == ConnectionManagerUtility::NormalizePathAction::Redirect) {\n    connection_manager_.stats_.named_.downstream_rq_redirected_with_normalized_path_.inc();\n    sendLocalReply(\n        Code::TemporaryRedirect, \"\",\n        [new_path = request_headers_->Path()->value().getStringView()](\n            Http::ResponseHeaderMap& response_headers) -> void {\n          response_headers.addReferenceKey(Http::Headers::get().Location, new_path);\n        },\n        absl::nullopt, StreamInfo::ResponseCodeDetails::get().PathNormalizationFailed);\n    return;\n  }\n\n  ASSERT(action == ConnectionManagerUtility::NormalizePathAction::Continue);\n#endif\n  auto optional_port = ConnectionManagerUtility::maybeNormalizeHost(\n      *request_headers_, connection_manager_.config_, localPort());\n  if (optional_port.has_value() &&\n      requestWasConnect(request_headers_, connection_manager_.codec_->protocol())) {\n    filter_manager_.streamInfo().filterState()->setData(\n        Router::OriginalConnectPort::key(),\n        std::make_unique<Router::OriginalConnectPort>(optional_port.value()),\n        StreamInfo::FilterState::StateType::ReadOnly, StreamInfo::FilterState::LifeSpan::Request);\n  }\n\n  if (!state_.is_internally_created_) { // Only sanitize headers on first pass.\n    // Modify the downstream remote address depending on configuration and headers.\n    const auto mutate_result = ConnectionManagerUtility::mutateRequestHeaders(\n        *request_headers_, connection_manager_.read_callbacks_->connection(),\n        connection_manager_.config_, *snapped_route_config_, connection_manager_.local_info_,\n        filter_manager_.streamInfo());\n\n    // IP detection failed, reject the request.\n    if (mutate_result.reject_request.has_value()) {\n      const auto& reject_request_params = mutate_result.reject_request.value();\n      connection_manager_.stats_.named_.downstream_rq_rejected_via_ip_detection_.inc();\n      sendLocalReply(reject_request_params.response_code, reject_request_params.body, nullptr,\n                     absl::nullopt,\n                     StreamInfo::ResponseCodeDetails::get().OriginalIPDetectionFailed);\n      return;\n    }\n\n    filter_manager_.setDownstreamRemoteAddress(mutate_result.final_remote_address);\n  }\n  ASSERT(filter_manager_.streamInfo().downstreamAddressProvider().remoteAddress() != nullptr);\n\n  ASSERT(!cached_route_);\n  refreshCachedRoute();\n\n  if (!state_.is_internally_created_) { // Only mutate tracing headers on first pass.\n    filter_manager_.streamInfo().setTraceReason(\n        ConnectionManagerUtility::mutateTracingRequestHeader(\n            *request_headers_, connection_manager_.runtime_, connection_manager_.config_,\n            cached_route_.value().get()));\n  }\n\n  filter_manager_.streamInfo().setRequestHeaders(*request_headers_);\n\n  const bool upgrade_rejected = filter_manager_.createFilterChain() == false;\n\n  if (connection_manager_.config_.flushAccessLogOnNewRequest()) {\n    filter_manager_.log(AccessLog::AccessLogType::DownstreamStart);\n  }\n\n  // TODO if there are no filters when starting a filter iteration, the connection manager\n  // should return 404. The current returns no response if there is no router filter.\n  if (hasCachedRoute()) {\n    // Do not allow upgrades if the route does not support it.\n    if (upgrade_rejected) {\n      // While downstream servers should not send upgrade payload without the upgrade being\n      // accepted, err on the side of caution and refuse to process any further requests on this\n      // connection, to avoid a class of HTTP/1.1 smuggling bugs where Upgrade or CONNECT payload\n      // contains a smuggled HTTP request.\n      filter_manager_.streamInfo().setShouldDrainConnectionUponCompletion(true);\n      connection_manager_.stats_.named_.downstream_rq_ws_on_non_ws_route_.inc();\n      sendLocalReply(Code::Forbidden, \"\", nullptr, absl::nullopt,\n                     StreamInfo::ResponseCodeDetails::get().UpgradeFailed);\n      return;\n    }\n    // Allow non websocket requests to go through websocket enabled routes.\n  }\n\n  // Check if tracing is enabled.\n  if (connection_manager_tracing_config_.has_value()) {\n    traceRequest();\n  }\n\n  filter_manager_.decodeHeaders(*request_headers_, end_stream);\n\n  // Reset it here for both global and overridden cases.\n  resetIdleTimer();\n}",
  "abstract_func_before": "void ConnectionManagerImpl::ActiveStream::decodeHeaders(RequestHeaderMapSharedPtr&& VAR_0,\n                                                        bool VAR_1) {\n  ENVOY_STREAM_LOG(VAR_2, \"request headers complete (end_stream={}):\\n{}\", *this, VAR_1,\n                   *VAR_0);\n  ScopeTrackerScopeState VAR_3(this,\n                               VAR_4.read_callbacks_->connection().dispatcher());\n  VAR_5 = std::move(VAR_0);\n  VAR_6.requestHeadersInitialized();\n  if (VAR_7 != nullptr) {\n    VAR_7->disableTimer();\n    VAR_7.reset();\n  }\n\n  /* COMMENT_0 */\n  /* COMMENT_1 */\n  const Protocol VAR_8 = VAR_4.codec_->protocol();\n  if (Runtime::runtimeFeatureEnabled(\n          \"envoy.reloadable_features.http1_connection_close_header_in_redirect\")) {\n    if (HeaderUtility::shouldCloseConnection(VAR_8, *VAR_5)) {\n      /* COMMENT_2 */\n      /* COMMENT_3 */\n      /* COMMENT_4 */\n      VAR_6.streamInfo().setShouldDrainConnectionUponCompletion(true);\n    }\n  } else {\n    VAR_6.streamInfo().setShouldDrainConnectionUponCompletion(\n        HeaderUtility::shouldCloseConnection(VAR_8, *VAR_5));\n  }\n\n  VAR_6.streamInfo().protocol(VAR_8);\n\n  /* COMMENT_5 */\n  maybeEndDecode(VAR_1);\n\n  if (!validateHeaders()) {\n    ENVOY_STREAM_LOG(VAR_2, \"request headers validation failed\\n{}\", *this, *VAR_5);\n    return;\n  }\n\n  /* COMMENT_6 */\n  if (VAR_4.config_.isRoutable()) {\n    if (VAR_4.config_.routeConfigProvider() != nullptr) {\n      VAR_9 = VAR_4.config_.routeConfigProvider()->configCast();\n    } else if (VAR_4.config_.scopedRouteConfigProvider() != nullptr &&\n               VAR_4.config_.scopeKeyBuilder().has_value()) {\n      VAR_10 =\n          VAR_4.config_.scopedRouteConfigProvider()->config<Router::ScopedConfig>();\n      snapScopedRouteConfig();\n    }\n  } else {\n    VAR_9 = VAR_4.config_.routeConfigProvider()->configCast();\n  }\n\n  /* COMMENT_7 */\n  const bool VAR_11 =\n      (VAR_4.accept_new_http_stream_ != nullptr &&\n       VAR_4.accept_new_http_stream_->shouldShedLoad()) ||\n      VAR_4.random_generator_.bernoulli(\n          VAR_4.overload_stop_accepting_requests_ref_.value());\n\n  if (VAR_11) {\n    /* COMMENT_8 */\n    /* COMMENT_9 */\n    VAR_6.skipFilterChainCreation();\n    VAR_4.stats_.named_.downstream_rq_overload_close_.inc();\n    sendLocalReply(Http::Code::ServiceUnavailable, \"envoy overloaded\", nullptr, absl::nullopt,\n                   StreamInfo::ResponseCodeDetails::get().Overload);\n    return;\n  }\n\n  if (!VAR_4.config_.proxy100Continue() && VAR_5->Expect() &&\n      /* COMMENT_10 */\n      /* COMMENT_11 */\n      absl::EqualsIgnoreCase((VAR_5->Expect()->value().getStringView()),\n                             Headers::get().ExpectValues._100Continue)) {\n    /* COMMENT_12 */\n    /* COMMENT_13 */\n    chargeStats(continueHeader());\n    VAR_12->encode1xxHeaders(continueHeader());\n    /* COMMENT_14 */\n    VAR_5->removeExpect();\n  }\n\n  VAR_4.user_agent_.initializeFromHeaders(*VAR_5,\n                                                        VAR_4.stats_.prefixStatName(),\n                                                        VAR_4.stats_.scope_);\n\n  if (!VAR_5->Host()) {\n    /* COMMENT_15 */\n    sendLocalReply(Code::BadRequest, \"\", nullptr, absl::nullopt,\n                   StreamInfo::ResponseCodeDetails::get().MissingHost);\n    return;\n  }\n\n  /* COMMENT_16 */\n  absl::optional<std::reference_wrapper<const absl::string_view>> VAR_13 =\n      HeaderUtility::requestHeadersValid(*VAR_5);\n  if (VAR_13 != absl::nullopt) {\n    sendLocalReply(Code::BadRequest, \"\", nullptr, absl::nullopt, VAR_13.value().get());\n    if (!VAR_12->streamErrorOnInvalidHttpMessage()) {\n      VAR_4.handleCodecError(VAR_13.value().get());\n    }\n    return;\n  }\n\n  /* COMMENT_17 */\n  /* COMMENT_18 */\n  /* COMMENT_19 */\n  /* COMMENT_20 */\n  if ((!HeaderUtility::isConnect(*VAR_5) || VAR_5->Path()) &&\n      VAR_5->getPathValue().empty()) {\n    sendLocalReply(Code::NotFound, \"\", nullptr, absl::nullopt,\n                   StreamInfo::ResponseCodeDetails::get().MissingPath);\n    return;\n  }\n\n  /* COMMENT_21 */\n  if (Runtime::runtimeFeatureEnabled(\"envoy.reloadable_features.enable_connect_udp_support\") &&\n      HeaderUtility::isConnectUdpRequest(*VAR_5) &&\n      !HeaderUtility::rewriteAuthorityForConnectUdp(*VAR_5)) {\n    sendLocalReply(Code::NotFound, \"The path is incorrect for CONNECT-UDP\", nullptr, absl::nullopt,\n                   StreamInfo::ResponseCodeDetails::get().InvalidPath);\n    return;\n  }\n\n  /* COMMENT_22 */\n  if (!VAR_5->getPathValue().empty() && VAR_5->getPathValue()[0] != '/') {\n    VAR_4.stats_.named_.downstream_rq_non_relative_path_.inc();\n    sendLocalReply(Code::NotFound, \"\", nullptr, absl::nullopt,\n                   StreamInfo::ResponseCodeDetails::get().AbsolutePath);\n    return;\n  }\n\n#ifndef VAR_14\n  /* COMMENT_23 */\n  /* COMMENT_24 */\n  const auto VAR_15 =\n      ConnectionManagerUtility::maybeNormalizePath(*VAR_5, VAR_4.config_);\n  /* COMMENT_25 */\n  /* COMMENT_26 */\n  if (VAR_15 == ConnectionManagerUtility::NormalizePathAction::Reject ||\n      (VAR_15 == ConnectionManagerUtility::NormalizePathAction::Redirect &&\n       Grpc::Common::hasGrpcContentType(*VAR_5))) {\n    VAR_4.stats_.named_.downstream_rq_failed_path_normalization_.inc();\n    sendLocalReply(Code::BadRequest, \"\", nullptr, absl::nullopt,\n                   StreamInfo::ResponseCodeDetails::get().PathNormalizationFailed);\n    return;\n  } else if (VAR_15 == ConnectionManagerUtility::NormalizePathAction::Redirect) {\n    VAR_4.stats_.named_.downstream_rq_redirected_with_normalized_path_.inc();\n    sendLocalReply(\n        Code::TemporaryRedirect, \"\",\n        [VAR_16 = VAR_5->Path()->value().getStringView()](\n            Http::ResponseHeaderMap& VAR_17) -> void {\n          VAR_17.addReferenceKey(Http::Headers::get().Location, VAR_16);\n        },\n        absl::nullopt, StreamInfo::ResponseCodeDetails::get().PathNormalizationFailed);\n    return;\n  }\n\n  ASSERT(VAR_15 == ConnectionManagerUtility::NormalizePathAction::Continue);\n#endif\n  auto VAR_18 = ConnectionManagerUtility::maybeNormalizeHost(\n      *VAR_5, VAR_4.config_, localPort());\n  if (VAR_18.has_value() &&\n      requestWasConnect(VAR_5, VAR_4.codec_->protocol())) {\n    VAR_6.streamInfo().filterState()->setData(\n        Router::OriginalConnectPort::key(),\n        std::VAR_19<Router::OriginalConnectPort>(VAR_18.value()),\n        StreamInfo::FilterState::StateType::ReadOnly, StreamInfo::FilterState::LifeSpan::Request);\n  }\n\n  if (!VAR_20.is_internally_created_) { /* COMMENT_27 */\n    /* COMMENT_28 */\n    const auto VAR_21 = ConnectionManagerUtility::mutateRequestHeaders(\n        *VAR_5, VAR_4.read_callbacks_->connection(),\n        VAR_4.config_, *VAR_9, VAR_4.local_info_,\n        VAR_6.streamInfo());\n\n    /* COMMENT_29 */\n    if (VAR_21.reject_request.has_value()) {\n      const auto& VAR_22 = VAR_21.reject_request.value();\n      VAR_4.stats_.named_.downstream_rq_rejected_via_ip_detection_.inc();\n      sendLocalReply(VAR_22.response_code, VAR_22.body, nullptr,\n                     absl::nullopt,\n                     StreamInfo::ResponseCodeDetails::get().OriginalIPDetectionFailed);\n      return;\n    }\n\n    VAR_6.setDownstreamRemoteAddress(VAR_21.final_remote_address);\n  }\n  ASSERT(VAR_6.streamInfo().downstreamAddressProvider().remoteAddress() != nullptr);\n\n  ASSERT(!VAR_23);\n  refreshCachedRoute();\n\n  if (!VAR_20.is_internally_created_) { /* COMMENT_30 */\n    VAR_6.streamInfo().setTraceReason(\n        ConnectionManagerUtility::mutateTracingRequestHeader(\n            *VAR_5, VAR_4.runtime_, VAR_4.config_,\n            VAR_23.value().get()));\n  }\n\n  VAR_6.streamInfo().setRequestHeaders(*VAR_5);\n\n  const bool VAR_24 = VAR_6.createFilterChain() == false;\n\n  if (VAR_4.config_.flushAccessLogOnNewRequest()) {\n    VAR_6.log(AccessLog::AccessLogType::DownstreamStart);\n  }\n\n  /* COMMENT_31 */\n  /* COMMENT_32 */\n  if (hasCachedRoute()) {\n    /* COMMENT_33 */\n    if (VAR_24) {\n      /* COMMENT_34 */\n      /* COMMENT_35 */\n      /* COMMENT_36 */\n      /* COMMENT_37 */\n      VAR_6.streamInfo().setShouldDrainConnectionUponCompletion(true);\n      VAR_4.stats_.named_.downstream_rq_ws_on_non_ws_route_.inc();\n      sendLocalReply(Code::Forbidden, \"\", nullptr, absl::nullopt,\n                     StreamInfo::ResponseCodeDetails::get().UpgradeFailed);\n      return;\n    }\n    /* COMMENT_38 */\n  }\n\n  /* COMMENT_39 */\n  if (VAR_25.has_value()) {\n    traceRequest();\n  }\n\n  VAR_6.decodeHeaders(*VAR_5, VAR_1);\n\n  /* COMMENT_40 */\n  resetIdleTimer();\n}",
  "func_graph_path_before": "envoyproxy/envoy/cf687ac66b60f14a71e2a7e552943f138922a71d/conn_manager_impl.cc/vul/before/0.json",
  "func": "void ConnectionManagerImpl::ActiveStream::decodeHeaders(RequestHeaderMapSharedPtr&& headers,\n                                                        bool end_stream) {\n  ENVOY_STREAM_LOG(debug, \"request headers complete (end_stream={}):\\n{}\", *this, end_stream,\n                   *headers);\n  ScopeTrackerScopeState scope(this,\n                               connection_manager_.read_callbacks_->connection().dispatcher());\n  request_headers_ = std::move(headers);\n  filter_manager_.requestHeadersInitialized();\n  if (request_header_timer_ != nullptr) {\n    request_header_timer_->disableTimer();\n    request_header_timer_.reset();\n  }\n\n  // Both shouldDrainConnectionUponCompletion() and is_head_request_ affect local replies: set them\n  // as early as possible.\n  const Protocol protocol = connection_manager_.codec_->protocol();\n  if (Runtime::runtimeFeatureEnabled(\n          \"envoy.reloadable_features.http1_connection_close_header_in_redirect\")) {\n    if (HeaderUtility::shouldCloseConnection(protocol, *request_headers_)) {\n      // Only mark the connection to be closed if the request indicates so. The connection might\n      // already be marked so before this step, in which case if shouldCloseConnection() returns\n      // false, the stream info value shouldn't be overridden.\n      filter_manager_.streamInfo().setShouldDrainConnectionUponCompletion(true);\n    }\n  } else {\n    filter_manager_.streamInfo().setShouldDrainConnectionUponCompletion(\n        HeaderUtility::shouldCloseConnection(protocol, *request_headers_));\n  }\n\n  filter_manager_.streamInfo().protocol(protocol);\n\n  // We end the decode here to mark that the downstream stream is complete.\n  maybeEndDecode(end_stream);\n\n  if (!validateHeaders()) {\n    ENVOY_STREAM_LOG(debug, \"request headers validation failed\\n{}\", *this, *request_headers_);\n    return;\n  }\n\n  // We need to snap snapped_route_config_ here as it's used in mutateRequestHeaders later.\n  if (connection_manager_.config_.isRoutable()) {\n    if (connection_manager_.config_.routeConfigProvider() != nullptr) {\n      snapped_route_config_ = connection_manager_.config_.routeConfigProvider()->configCast();\n    } else if (connection_manager_.config_.scopedRouteConfigProvider() != nullptr &&\n               connection_manager_.config_.scopeKeyBuilder().has_value()) {\n      snapped_scoped_routes_config_ =\n          connection_manager_.config_.scopedRouteConfigProvider()->config<Router::ScopedConfig>();\n      snapScopedRouteConfig();\n    }\n  } else {\n    snapped_route_config_ = connection_manager_.config_.routeConfigProvider()->configCast();\n  }\n\n  // Drop new requests when overloaded as soon as we have decoded the headers.\n  const bool drop_request_due_to_overload =\n      (connection_manager_.accept_new_http_stream_ != nullptr &&\n       connection_manager_.accept_new_http_stream_->shouldShedLoad()) ||\n      connection_manager_.random_generator_.bernoulli(\n          connection_manager_.overload_stop_accepting_requests_ref_.value());\n\n  if (drop_request_due_to_overload) {\n    // In this one special case, do not create the filter chain. If there is a risk of memory\n    // overload it is more important to avoid unnecessary allocation than to create the filters.\n    filter_manager_.skipFilterChainCreation();\n    connection_manager_.stats_.named_.downstream_rq_overload_close_.inc();\n    sendLocalReply(Http::Code::ServiceUnavailable, \"envoy overloaded\", nullptr, absl::nullopt,\n                   StreamInfo::ResponseCodeDetails::get().Overload);\n    return;\n  }\n\n  if (!connection_manager_.config_.proxy100Continue() && request_headers_->Expect() &&\n      // The Expect field-value is case-insensitive.\n      // https://tools.ietf.org/html/rfc7231#section-5.1.1\n      absl::EqualsIgnoreCase((request_headers_->Expect()->value().getStringView()),\n                             Headers::get().ExpectValues._100Continue)) {\n    // Note in the case Envoy is handling 100-Continue complexity, it skips the filter chain\n    // and sends the 100-Continue directly to the encoder.\n    chargeStats(continueHeader());\n    response_encoder_->encode1xxHeaders(continueHeader());\n    // Remove the Expect header so it won't be handled again upstream.\n    request_headers_->removeExpect();\n  }\n\n  connection_manager_.user_agent_.initializeFromHeaders(*request_headers_,\n                                                        connection_manager_.stats_.prefixStatName(),\n                                                        connection_manager_.stats_.scope_);\n\n  if (!request_headers_->Host()) {\n    // Require host header. For HTTP/1.1 Host has already been translated to :authority.\n    sendLocalReply(Code::BadRequest, \"\", nullptr, absl::nullopt,\n                   StreamInfo::ResponseCodeDetails::get().MissingHost);\n    return;\n  }\n\n  // Apply header sanity checks.\n  absl::optional<std::reference_wrapper<const absl::string_view>> error =\n      HeaderUtility::requestHeadersValid(*request_headers_);\n  if (error != absl::nullopt) {\n    sendLocalReply(Code::BadRequest, \"\", nullptr, absl::nullopt, error.value().get());\n    if (!response_encoder_->streamErrorOnInvalidHttpMessage()) {\n      connection_manager_.handleCodecError(error.value().get());\n    }\n    return;\n  }\n\n  // Check for the existence of the :path header for non-CONNECT requests, or present-but-empty\n  // :path header for CONNECT requests. We expect the codec to have broken the path into pieces if\n  // applicable. NOTE: Currently the HTTP/1.1 codec only does this when the allow_absolute_url flag\n  // is enabled on the HCM.\n  if ((!HeaderUtility::isConnect(*request_headers_) || request_headers_->Path()) &&\n      request_headers_->getPathValue().empty()) {\n    sendLocalReply(Code::NotFound, \"\", nullptr, absl::nullopt,\n                   StreamInfo::ResponseCodeDetails::get().MissingPath);\n    return;\n  }\n\n  // Rewrites the host of CONNECT-UDP requests.\n  if (Runtime::runtimeFeatureEnabled(\"envoy.reloadable_features.enable_connect_udp_support\") &&\n      HeaderUtility::isConnectUdpRequest(*request_headers_) &&\n      !HeaderUtility::rewriteAuthorityForConnectUdp(*request_headers_)) {\n    sendLocalReply(Code::NotFound, \"The path is incorrect for CONNECT-UDP\", nullptr, absl::nullopt,\n                   StreamInfo::ResponseCodeDetails::get().InvalidPath);\n    return;\n  }\n\n  // Currently we only support relative paths at the application layer.\n  if (!request_headers_->getPathValue().empty() && request_headers_->getPathValue()[0] != '/') {\n    connection_manager_.stats_.named_.downstream_rq_non_relative_path_.inc();\n    sendLocalReply(Code::NotFound, \"\", nullptr, absl::nullopt,\n                   StreamInfo::ResponseCodeDetails::get().AbsolutePath);\n    return;\n  }\n\n#ifndef ENVOY_ENABLE_UHV\n  // In UHV mode path normalization is done in the UHV\n  // Path sanitization should happen before any path access other than the above sanity check.\n  const auto action =\n      ConnectionManagerUtility::maybeNormalizePath(*request_headers_, connection_manager_.config_);\n  // gRPC requests are rejected if Envoy is configured to redirect post-normalization. This is\n  // because gRPC clients do not support redirect.\n  if (action == ConnectionManagerUtility::NormalizePathAction::Reject ||\n      (action == ConnectionManagerUtility::NormalizePathAction::Redirect &&\n       Grpc::Common::hasGrpcContentType(*request_headers_))) {\n    connection_manager_.stats_.named_.downstream_rq_failed_path_normalization_.inc();\n    sendLocalReply(Code::BadRequest, \"\", nullptr, absl::nullopt,\n                   StreamInfo::ResponseCodeDetails::get().PathNormalizationFailed);\n    return;\n  } else if (action == ConnectionManagerUtility::NormalizePathAction::Redirect) {\n    connection_manager_.stats_.named_.downstream_rq_redirected_with_normalized_path_.inc();\n    sendLocalReply(\n        Code::TemporaryRedirect, \"\",\n        [new_path = request_headers_->Path()->value().getStringView()](\n            Http::ResponseHeaderMap& response_headers) -> void {\n          response_headers.addReferenceKey(Http::Headers::get().Location, new_path);\n        },\n        absl::nullopt, StreamInfo::ResponseCodeDetails::get().PathNormalizationFailed);\n    return;\n  }\n\n  ASSERT(action == ConnectionManagerUtility::NormalizePathAction::Continue);\n#endif\n  auto optional_port = ConnectionManagerUtility::maybeNormalizeHost(\n      *request_headers_, connection_manager_.config_, localPort());\n  if (optional_port.has_value() &&\n      requestWasConnect(request_headers_, connection_manager_.codec_->protocol())) {\n    filter_manager_.streamInfo().filterState()->setData(\n        Router::OriginalConnectPort::key(),\n        std::make_unique<Router::OriginalConnectPort>(optional_port.value()),\n        StreamInfo::FilterState::StateType::ReadOnly, StreamInfo::FilterState::LifeSpan::Request);\n  }\n\n  if (!state_.is_internally_created_) { // Only sanitize headers on first pass.\n    // Modify the downstream remote address depending on configuration and headers.\n    const auto mutate_result = ConnectionManagerUtility::mutateRequestHeaders(\n        *request_headers_, connection_manager_.read_callbacks_->connection(),\n        connection_manager_.config_, *snapped_route_config_, connection_manager_.local_info_,\n        filter_manager_.streamInfo());\n\n    // IP detection failed, reject the request.\n    if (mutate_result.reject_request.has_value()) {\n      const auto& reject_request_params = mutate_result.reject_request.value();\n      connection_manager_.stats_.named_.downstream_rq_rejected_via_ip_detection_.inc();\n      sendLocalReply(reject_request_params.response_code, reject_request_params.body, nullptr,\n                     absl::nullopt,\n                     StreamInfo::ResponseCodeDetails::get().OriginalIPDetectionFailed);\n      return;\n    }\n\n    filter_manager_.setDownstreamRemoteAddress(mutate_result.final_remote_address);\n  }\n  ASSERT(filter_manager_.streamInfo().downstreamAddressProvider().remoteAddress() != nullptr);\n\n  ASSERT(!cached_route_);\n  refreshCachedRoute();\n\n  if (!state_.is_internally_created_) { // Only mutate tracing headers on first pass.\n    filter_manager_.streamInfo().setTraceReason(\n        ConnectionManagerUtility::mutateTracingRequestHeader(\n            *request_headers_, connection_manager_.runtime_, connection_manager_.config_,\n            cached_route_.value().get()));\n  }\n\n  filter_manager_.streamInfo().setRequestHeaders(*request_headers_);\n\n  const bool upgrade_rejected = filter_manager_.createFilterChain() == false;\n\n  if (connection_manager_.config_.flushAccessLogOnNewRequest()) {\n    filter_manager_.log(AccessLog::AccessLogType::DownstreamStart);\n  }\n\n  // TODO if there are no filters when starting a filter iteration, the connection manager\n  // should return 404. The current returns no response if there is no router filter.\n  if (hasCachedRoute()) {\n    // Do not allow upgrades if the route does not support it.\n    if (upgrade_rejected) {\n      // While downstream servers should not send upgrade payload without the upgrade being\n      // accepted, err on the side of caution and refuse to process any further requests on this\n      // connection, to avoid a class of HTTP/1.1 smuggling bugs where Upgrade or CONNECT payload\n      // contains a smuggled HTTP request.\n      filter_manager_.streamInfo().setShouldDrainConnectionUponCompletion(true);\n      connection_manager_.stats_.named_.downstream_rq_ws_on_non_ws_route_.inc();\n      sendLocalReply(Code::Forbidden, \"\", nullptr, absl::nullopt,\n                     StreamInfo::ResponseCodeDetails::get().UpgradeFailed);\n      return;\n    }\n    // Allow non websocket requests to go through websocket enabled routes.\n  }\n\n  // Check if tracing is enabled.\n  if (connection_manager_tracing_config_.has_value()) {\n    traceRequest();\n  }\n\n  if (!connection_manager_.shouldDeferRequestProxyingToNextIoCycle()) {\n    filter_manager_.decodeHeaders(*request_headers_, end_stream);\n  } else {\n    state_.deferred_to_next_io_iteration_ = true;\n    state_.deferred_end_stream_ = end_stream;\n  }\n\n  // Reset it here for both global and overridden cases.\n  resetIdleTimer();\n}",
  "abstract_func": "void ConnectionManagerImpl::ActiveStream::decodeHeaders(RequestHeaderMapSharedPtr&& VAR_0,\n                                                        bool VAR_1) {\n  ENVOY_STREAM_LOG(VAR_2, \"request headers complete (end_stream={}):\\n{}\", *this, VAR_1,\n                   *VAR_0);\n  ScopeTrackerScopeState VAR_3(this,\n                               VAR_4.read_callbacks_->connection().dispatcher());\n  VAR_5 = std::move(VAR_0);\n  VAR_6.requestHeadersInitialized();\n  if (VAR_7 != nullptr) {\n    VAR_7->disableTimer();\n    VAR_7.reset();\n  }\n\n  /* COMMENT_0 */\n  /* COMMENT_1 */\n  const Protocol VAR_8 = VAR_4.codec_->protocol();\n  if (Runtime::runtimeFeatureEnabled(\n          \"envoy.reloadable_features.http1_connection_close_header_in_redirect\")) {\n    if (HeaderUtility::shouldCloseConnection(VAR_8, *VAR_5)) {\n      /* COMMENT_2 */\n      /* COMMENT_3 */\n      /* COMMENT_4 */\n      VAR_6.streamInfo().setShouldDrainConnectionUponCompletion(true);\n    }\n  } else {\n    VAR_6.streamInfo().setShouldDrainConnectionUponCompletion(\n        HeaderUtility::shouldCloseConnection(VAR_8, *VAR_5));\n  }\n\n  VAR_6.streamInfo().protocol(VAR_8);\n\n  /* COMMENT_5 */\n  maybeEndDecode(VAR_1);\n\n  if (!validateHeaders()) {\n    ENVOY_STREAM_LOG(VAR_2, \"request headers validation failed\\n{}\", *this, *VAR_5);\n    return;\n  }\n\n  /* COMMENT_6 */\n  if (VAR_4.config_.isRoutable()) {\n    if (VAR_4.config_.routeConfigProvider() != nullptr) {\n      VAR_9 = VAR_4.config_.routeConfigProvider()->configCast();\n    } else if (VAR_4.config_.scopedRouteConfigProvider() != nullptr &&\n               VAR_4.config_.scopeKeyBuilder().has_value()) {\n      VAR_10 =\n          VAR_4.config_.scopedRouteConfigProvider()->config<Router::ScopedConfig>();\n      snapScopedRouteConfig();\n    }\n  } else {\n    VAR_9 = VAR_4.config_.routeConfigProvider()->configCast();\n  }\n\n  /* COMMENT_7 */\n  const bool VAR_11 =\n      (VAR_4.accept_new_http_stream_ != nullptr &&\n       VAR_4.accept_new_http_stream_->shouldShedLoad()) ||\n      VAR_4.random_generator_.bernoulli(\n          VAR_4.overload_stop_accepting_requests_ref_.value());\n\n  if (VAR_11) {\n    /* COMMENT_8 */\n    /* COMMENT_9 */\n    VAR_6.skipFilterChainCreation();\n    VAR_4.stats_.named_.downstream_rq_overload_close_.inc();\n    sendLocalReply(Http::Code::ServiceUnavailable, \"envoy overloaded\", nullptr, absl::nullopt,\n                   StreamInfo::ResponseCodeDetails::get().Overload);\n    return;\n  }\n\n  if (!VAR_4.config_.proxy100Continue() && VAR_5->Expect() &&\n      /* COMMENT_10 */\n      /* COMMENT_11 */\n      absl::EqualsIgnoreCase((VAR_5->Expect()->value().getStringView()),\n                             Headers::get().ExpectValues._100Continue)) {\n    /* COMMENT_12 */\n    /* COMMENT_13 */\n    chargeStats(continueHeader());\n    VAR_12->encode1xxHeaders(continueHeader());\n    /* COMMENT_14 */\n    VAR_5->removeExpect();\n  }\n\n  VAR_4.user_agent_.initializeFromHeaders(*VAR_5,\n                                                        VAR_4.stats_.prefixStatName(),\n                                                        VAR_4.stats_.scope_);\n\n  if (!VAR_5->Host()) {\n    /* COMMENT_15 */\n    sendLocalReply(Code::BadRequest, \"\", nullptr, absl::nullopt,\n                   StreamInfo::ResponseCodeDetails::get().MissingHost);\n    return;\n  }\n\n  /* COMMENT_16 */\n  absl::optional<std::reference_wrapper<const absl::string_view>> VAR_13 =\n      HeaderUtility::requestHeadersValid(*VAR_5);\n  if (VAR_13 != absl::nullopt) {\n    sendLocalReply(Code::BadRequest, \"\", nullptr, absl::nullopt, VAR_13.value().get());\n    if (!VAR_12->streamErrorOnInvalidHttpMessage()) {\n      VAR_4.handleCodecError(VAR_13.value().get());\n    }\n    return;\n  }\n\n  /* COMMENT_17 */\n  /* COMMENT_18 */\n  /* COMMENT_19 */\n  /* COMMENT_20 */\n  if ((!HeaderUtility::isConnect(*VAR_5) || VAR_5->Path()) &&\n      VAR_5->getPathValue().empty()) {\n    sendLocalReply(Code::NotFound, \"\", nullptr, absl::nullopt,\n                   StreamInfo::ResponseCodeDetails::get().MissingPath);\n    return;\n  }\n\n  /* COMMENT_21 */\n  if (Runtime::runtimeFeatureEnabled(\"envoy.reloadable_features.enable_connect_udp_support\") &&\n      HeaderUtility::isConnectUdpRequest(*VAR_5) &&\n      !HeaderUtility::rewriteAuthorityForConnectUdp(*VAR_5)) {\n    sendLocalReply(Code::NotFound, \"The path is incorrect for CONNECT-UDP\", nullptr, absl::nullopt,\n                   StreamInfo::ResponseCodeDetails::get().InvalidPath);\n    return;\n  }\n\n  /* COMMENT_22 */\n  if (!VAR_5->getPathValue().empty() && VAR_5->getPathValue()[0] != '/') {\n    VAR_4.stats_.named_.downstream_rq_non_relative_path_.inc();\n    sendLocalReply(Code::NotFound, \"\", nullptr, absl::nullopt,\n                   StreamInfo::ResponseCodeDetails::get().AbsolutePath);\n    return;\n  }\n\n#ifndef VAR_14\n  /* COMMENT_23 */\n  /* COMMENT_24 */\n  const auto VAR_15 =\n      ConnectionManagerUtility::maybeNormalizePath(*VAR_5, VAR_4.config_);\n  /* COMMENT_25 */\n  /* COMMENT_26 */\n  if (VAR_15 == ConnectionManagerUtility::NormalizePathAction::Reject ||\n      (VAR_15 == ConnectionManagerUtility::NormalizePathAction::Redirect &&\n       Grpc::Common::hasGrpcContentType(*VAR_5))) {\n    VAR_4.stats_.named_.downstream_rq_failed_path_normalization_.inc();\n    sendLocalReply(Code::BadRequest, \"\", nullptr, absl::nullopt,\n                   StreamInfo::ResponseCodeDetails::get().PathNormalizationFailed);\n    return;\n  } else if (VAR_15 == ConnectionManagerUtility::NormalizePathAction::Redirect) {\n    VAR_4.stats_.named_.downstream_rq_redirected_with_normalized_path_.inc();\n    sendLocalReply(\n        Code::TemporaryRedirect, \"\",\n        [VAR_16 = VAR_5->Path()->value().getStringView()](\n            Http::ResponseHeaderMap& VAR_17) -> void {\n          VAR_17.addReferenceKey(Http::Headers::get().Location, VAR_16);\n        },\n        absl::nullopt, StreamInfo::ResponseCodeDetails::get().PathNormalizationFailed);\n    return;\n  }\n\n  ASSERT(VAR_15 == ConnectionManagerUtility::NormalizePathAction::Continue);\n#endif\n  auto VAR_18 = ConnectionManagerUtility::maybeNormalizeHost(\n      *VAR_5, VAR_4.config_, localPort());\n  if (VAR_18.has_value() &&\n      requestWasConnect(VAR_5, VAR_4.codec_->protocol())) {\n    VAR_6.streamInfo().filterState()->setData(\n        Router::OriginalConnectPort::key(),\n        std::VAR_19<Router::OriginalConnectPort>(VAR_18.value()),\n        StreamInfo::FilterState::StateType::ReadOnly, StreamInfo::FilterState::LifeSpan::Request);\n  }\n\n  if (!VAR_20.is_internally_created_) { /* COMMENT_27 */\n    /* COMMENT_28 */\n    const auto VAR_21 = ConnectionManagerUtility::mutateRequestHeaders(\n        *VAR_5, VAR_4.read_callbacks_->connection(),\n        VAR_4.config_, *VAR_9, VAR_4.local_info_,\n        VAR_6.streamInfo());\n\n    /* COMMENT_29 */\n    if (VAR_21.reject_request.has_value()) {\n      const auto& VAR_22 = VAR_21.reject_request.value();\n      VAR_4.stats_.named_.downstream_rq_rejected_via_ip_detection_.inc();\n      sendLocalReply(VAR_22.response_code, VAR_22.body, nullptr,\n                     absl::nullopt,\n                     StreamInfo::ResponseCodeDetails::get().OriginalIPDetectionFailed);\n      return;\n    }\n\n    VAR_6.setDownstreamRemoteAddress(VAR_21.final_remote_address);\n  }\n  ASSERT(VAR_6.streamInfo().downstreamAddressProvider().remoteAddress() != nullptr);\n\n  ASSERT(!VAR_23);\n  refreshCachedRoute();\n\n  if (!VAR_20.is_internally_created_) { /* COMMENT_30 */\n    VAR_6.streamInfo().setTraceReason(\n        ConnectionManagerUtility::mutateTracingRequestHeader(\n            *VAR_5, VAR_4.runtime_, VAR_4.config_,\n            VAR_23.value().get()));\n  }\n\n  VAR_6.streamInfo().setRequestHeaders(*VAR_5);\n\n  const bool VAR_24 = VAR_6.createFilterChain() == false;\n\n  if (VAR_4.config_.flushAccessLogOnNewRequest()) {\n    VAR_6.log(AccessLog::AccessLogType::DownstreamStart);\n  }\n\n  /* COMMENT_31 */\n  /* COMMENT_32 */\n  if (hasCachedRoute()) {\n    /* COMMENT_33 */\n    if (VAR_24) {\n      /* COMMENT_34 */\n      /* COMMENT_35 */\n      /* COMMENT_36 */\n      /* COMMENT_37 */\n      VAR_6.streamInfo().setShouldDrainConnectionUponCompletion(true);\n      VAR_4.stats_.named_.downstream_rq_ws_on_non_ws_route_.inc();\n      sendLocalReply(Code::Forbidden, \"\", nullptr, absl::nullopt,\n                     StreamInfo::ResponseCodeDetails::get().UpgradeFailed);\n      return;\n    }\n    /* COMMENT_38 */\n  }\n\n  /* COMMENT_39 */\n  if (VAR_25.has_value()) {\n    traceRequest();\n  }\n\n  if (!VAR_4.shouldDeferRequestProxyingToNextIoCycle()) {\n    VAR_6.decodeHeaders(*VAR_5, VAR_1);\n  } else {\n    VAR_20.deferred_to_next_io_iteration_ = true;\n    VAR_20.deferred_end_stream_ = VAR_1;\n  }\n\n  /* COMMENT_40 */\n  resetIdleTimer();\n}",
  "func_graph_path": "envoyproxy/envoy/cf687ac66b60f14a71e2a7e552943f138922a71d/conn_manager_impl.cc/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -231,7 +231,12 @@\n     traceRequest();\n   }\n \n-  filter_manager_.decodeHeaders(*request_headers_, end_stream);\n+  if (!connection_manager_.shouldDeferRequestProxyingToNextIoCycle()) {\n+    filter_manager_.decodeHeaders(*request_headers_, end_stream);\n+  } else {\n+    state_.deferred_to_next_io_iteration_ = true;\n+    state_.deferred_end_stream_ = end_stream;\n+  }\n \n   // Reset it here for both global and overridden cases.\n   resetIdleTimer();",
  "diff_line_info": {
    "deleted_lines": [
      "  filter_manager_.decodeHeaders(*request_headers_, end_stream);"
    ],
    "added_lines": [
      "  if (!connection_manager_.shouldDeferRequestProxyingToNextIoCycle()) {",
      "    filter_manager_.decodeHeaders(*request_headers_, end_stream);",
      "  } else {",
      "    state_.deferred_to_next_io_iteration_ = true;",
      "    state_.deferred_end_stream_ = end_stream;",
      "  }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/envoyproxy/envoy/pull/30055",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/envoyproxy/envoy/pull/30055: 403 Client Error: Forbidden for url: https://api.github.com/repos/envoyproxy/envoy/pulls/30055",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.6,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.6"
}