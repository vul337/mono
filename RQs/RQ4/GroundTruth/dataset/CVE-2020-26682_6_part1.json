{
  "cve_id": "CVE-2020-26682",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "libass",
  "commit_msg": "outline: fix overflows in outline processing\n\nThis commit enforces strict invariant on ASS_Outline\nto contain point coordinates into predetermined range.\n\nFixes https://github.com/libass/libass/issues/431.",
  "commit_hash": "676f9dc5b52ef406c5527bdadbcb947f11392929",
  "git_url": "https://github.com/libass/libass/commit/676f9dc5b52ef406c5527bdadbcb947f11392929",
  "file_path": "libass/ass_render.c",
  "func_name": "get_bitmap_glyph",
  "func_before": "static void\nget_bitmap_glyph(ASS_Renderer *render_priv, GlyphInfo *info,\n                 ASS_Vector *pos, ASS_Vector *pos_o,\n                 ASS_DVector *offset, bool first, int flags)\n{\n    if (!info->outline || info->symbol == '\\n' || info->symbol == 0 || info->skip) {\n        ass_cache_dec_ref(info->outline);\n        return;\n    }\n\n    double m1[3][3], m2[3][3], m[3][3];\n    const ASS_Transform *tr = &info->transform;\n    calc_transform_matrix(render_priv, info, m1);\n    for (int i = 0; i < 3; i++) {\n        m2[i][0] = m1[i][0] * tr->scale.x;\n        m2[i][1] = m1[i][1] * tr->scale.y;\n        m2[i][2] = m1[i][0] * tr->offset.x + m1[i][1] * tr->offset.y + m1[i][2];\n    }\n    memcpy(m, m2, sizeof(m));\n\n    BitmapHashKey key;\n    key.outline = info->outline;\n    if (!quantize_transform(m, pos, offset, first, &key)) {\n        ass_cache_dec_ref(info->outline);\n        return;\n    }\n    info->bm = ass_cache_get(render_priv->cache.bitmap_cache, &key, render_priv);\n    if (!info->bm || !info->bm->buffer) {\n        ass_cache_dec_ref(info->bm);\n        info->bm = NULL;\n    }\n    *pos_o = *pos;\n\n    OutlineHashKey ol_key;\n    if (flags & FILTER_BORDER_STYLE_3) {\n        if (!(flags & (FILTER_NONZERO_BORDER | FILTER_NONZERO_SHADOW)))\n            return;\n\n        ol_key.type = OUTLINE_BOX;\n\n        double w = 64 * render_priv->border_scale;\n        ASS_DVector bord = { info->border_x * w, info->border_y * w };\n        double width = info->hspacing_scaled + info->advance.x;\n        double height = info->asc + info->desc;\n\n        ASS_DVector orig_scale;\n        orig_scale.x = info->scale_x * info->scale_fix;\n        orig_scale.y = info->scale_y * info->scale_fix;\n\n        // Emulate the WTFish behavior of VSFilter, i.e. double-scale\n        // the sizes of the opaque box.\n        bord.x *= orig_scale.x;\n        bord.y *= orig_scale.y;\n        width  *= orig_scale.x;\n        height *= orig_scale.y;\n\n        // to avoid gaps\n        bord.x = FFMAX(64, bord.x);\n        bord.y = FFMAX(64, bord.y);\n\n        ASS_DVector scale = {\n            (width  + 2 * bord.x) / 64,\n            (height + 2 * bord.y) / 64,\n        };\n        ASS_DVector offset = { -bord.x, -bord.y - info->asc };\n        for (int i = 0; i < 3; i++) {\n            m[i][0] = m1[i][0] * scale.x;\n            m[i][1] = m1[i][1] * scale.y;\n            m[i][2] = m1[i][0] * offset.x + m1[i][1] * offset.y + m1[i][2];\n        }\n    } else {\n        if (!(flags & FILTER_NONZERO_BORDER))\n            return;\n\n        ol_key.type = OUTLINE_BORDER;\n        BorderHashKey *k = &ol_key.u.border;\n        k->outline = info->outline;\n\n        double w = 64 * render_priv->border_scale;\n        double bord_x = w * info->border_x / tr->scale.x;\n        double bord_y = w * info->border_y / tr->scale.y;\n\n        const ASS_Rect *bbox = &info->outline->cbox;\n        // Estimate bounding box half size after stroking\n        double dx = (bbox->x_max - bbox->x_min) / 2.0 + (bord_x + 64);\n        double dy = (bbox->y_max - bbox->y_min) / 2.0 + (bord_y + 64);\n\n        // Matrix after quantize_transform() has\n        // input and output origin at bounding box center.\n        double mxx = fabs(m[0][0]), mxy = fabs(m[0][1]);\n        double myx = fabs(m[1][0]), myy = fabs(m[1][1]);\n        double mzx = fabs(m[2][0]), mzy = fabs(m[2][1]);\n\n        double z0 = m[2][2] - mzx * dx - mzy * dy;\n        w = 1 / FFMAX(z0, m[2][2] / MAX_PERSP_SCALE);\n\n        // Notation from quantize_transform().\n        // Note that goal here is to estimate acceptable error for stroking, i. e. D(x) and D(y).\n        // Matrix coefficients are constants now, so D(m_??) = 0.\n\n        // D(z) <= |m_zx| * D(x) + |m_zy| * D(y),\n        // D(x_out) = D((m_xx * x + m_xy * y) / z)\n        //  <= (|m_xx| * D(x) + |m_xy| * D(y)) / z0 + x_lim * D(z) / z0^2\n        //  <= (|m_xx| / z0 + |m_zx| * x_lim / z0^2) * D(x)\n        //   + (|m_xy| / z0 + |m_zy| * x_lim / z0^2) * D(y),\n        // D(y_out) = D((m_yx * x + m_yy * y) / z)\n        //  <= (|m_yx| * D(x) + |m_yy| * D(y)) / z0 + y_lim * D(z) / z0^2\n        //  <= (|m_yx| / z0 + |m_zx| * y_lim / z0^2) * D(x)\n        //   + (|m_yy| / z0 + |m_zy| * y_lim / z0^2) * D(y).\n\n        // Quantization steps (ACCURACY ~ POSITION_PRECISION):\n        // STROKER_PRECISION / 2^scale_ord_x ~ D(x) ~ POSITION_PRECISION /\n        //   (max(|m_xx|, |m_yx|) / z0 + |m_zx| * max(x_lim, y_lim) / z0^2),\n        // STROKER_PRECISION / 2^scale_ord_y ~ D(y) ~ POSITION_PRECISION /\n        //   (max(|m_xy|, |m_yy|) / z0 + |m_zy| * max(x_lim, y_lim) / z0^2).\n\n        double x_lim = mxx * dx + mxy * dy;\n        double y_lim = myx * dx + myy * dy;\n        double rz = FFMAX(x_lim, y_lim) * w;\n\n        w *= STROKER_PRECISION / POSITION_PRECISION;\n        frexp(w * (FFMAX(mxx, myx) + mzx * rz), &k->scale_ord_x);\n        frexp(w * (FFMAX(mxy, myy) + mzy * rz), &k->scale_ord_y);\n        k->border.x = lrint(ldexp(bord_x, k->scale_ord_x) / STROKER_PRECISION);\n        k->border.y = lrint(ldexp(bord_y, k->scale_ord_y) / STROKER_PRECISION);\n        if (!k->border.x && !k->border.y) {\n            ass_cache_inc_ref(info->bm);\n            info->bm_o = info->bm;\n            return;\n        }\n\n        for (int i = 0; i < 3; i++) {\n            m[i][0] = ldexp(m2[i][0], -k->scale_ord_x);\n            m[i][1] = ldexp(m2[i][1], -k->scale_ord_y);\n            m[i][2] = m2[i][2];\n        }\n    }\n\n    key.outline = ass_cache_get(render_priv->cache.outline_cache, &ol_key, render_priv);\n    if (!key.outline || !key.outline->valid ||\n            !quantize_transform(m, pos_o, offset, false, &key)) {\n        ass_cache_dec_ref(key.outline);\n        return;\n    }\n    info->bm_o = ass_cache_get(render_priv->cache.bitmap_cache, &key, render_priv);\n    if (!info->bm_o || !info->bm_o->buffer) {\n        ass_cache_dec_ref(info->bm_o);\n        info->bm_o = NULL;\n        *pos_o = *pos;\n    } else if (!info->bm)\n        *pos = *pos_o;\n}",
  "abstract_func_before": "static void\nget_bitmap_glyph(ASS_Renderer *VAR_0, GlyphInfo *VAR_1,\n                 ASS_Vector *VAR_2, ASS_Vector *VAR_3,\n                 ASS_DVector *VAR_4, bool VAR_5, int VAR_6)\n{\n    if (!VAR_1->outline || VAR_1->symbol == '\\n' || VAR_1->symbol == 0 || VAR_1->skip) {\n        ass_cache_dec_ref(VAR_1->outline);\n        return;\n    }\n\n    double VAR_7[3][3], VAR_8[3][3], VAR_9[3][3];\n    const ASS_Transform *VAR_10 = &VAR_1->transform;\n    calc_transform_matrix(VAR_0, VAR_1, VAR_7);\n    for (int VAR_11 = 0; VAR_11 < 3; VAR_11++) {\n        VAR_8[VAR_11][0] = VAR_7[VAR_11][0] * VAR_10->scale.x;\n        VAR_8[VAR_11][1] = VAR_7[VAR_11][1] * VAR_10->scale.y;\n        VAR_8[VAR_11][2] = VAR_7[VAR_11][0] * VAR_10->offset.x + VAR_7[VAR_11][1] * VAR_10->offset.y + VAR_7[VAR_11][2];\n    }\n    memcpy(VAR_9, VAR_8, sizeof(VAR_9));\n\n    BitmapHashKey VAR_12;\n    VAR_12.outline = VAR_1->outline;\n    if (!quantize_transform(VAR_9, VAR_2, VAR_4, VAR_5, &VAR_12)) {\n        ass_cache_dec_ref(VAR_1->outline);\n        return;\n    }\n    VAR_1->bm = ass_cache_get(VAR_0->cache.bitmap_cache, &VAR_12, VAR_0);\n    if (!VAR_1->bm || !VAR_1->bm->buffer) {\n        ass_cache_dec_ref(VAR_1->bm);\n        VAR_1->bm = NULL;\n    }\n    *VAR_3 = *VAR_2;\n\n    OutlineHashKey VAR_13;\n    if (VAR_6 & VAR_14) {\n        if (!(VAR_6 & (VAR_15 | VAR_16)))\n            return;\n\n        VAR_13.type = VAR_17;\n\n        double VAR_18 = 64 * VAR_0->border_scale;\n        ASS_DVector VAR_19 = { VAR_1->border_x * VAR_18, VAR_1->border_y * VAR_18 };\n        double VAR_20 = VAR_1->hspacing_scaled + VAR_1->advance.x;\n        double VAR_21 = VAR_1->asc + VAR_1->desc;\n\n        ASS_DVector VAR_22;\n        VAR_22.x = VAR_1->scale_x * VAR_1->scale_fix;\n        VAR_22.y = VAR_1->scale_y * VAR_1->scale_fix;\n\n        /* COMMENT_0 */\n        /* COMMENT_1 */\n        VAR_19.x *= VAR_22.x;\n        VAR_19.y *= VAR_22.y;\n        VAR_20  *= VAR_22.x;\n        VAR_21 *= VAR_22.y;\n\n        /* COMMENT_2 */\n        VAR_19.x = FFMAX(64, VAR_19.x);\n        VAR_19.y = FFMAX(64, VAR_19.y);\n\n        ASS_DVector VAR_23 = {\n            (VAR_20  + 2 * VAR_19.x) / 64,\n            (VAR_21 + 2 * VAR_19.y) / 64,\n        };\n        ASS_DVector VAR_4 = { -VAR_19.x, -VAR_19.y - VAR_1->asc };\n        for (int VAR_11 = 0; VAR_11 < 3; VAR_11++) {\n            VAR_9[VAR_11][0] = VAR_7[VAR_11][0] * VAR_23.x;\n            VAR_9[VAR_11][1] = VAR_7[VAR_11][1] * VAR_23.y;\n            VAR_9[VAR_11][2] = VAR_7[VAR_11][0] * VAR_4.x + VAR_7[VAR_11][1] * VAR_4.y + VAR_7[VAR_11][2];\n        }\n    } else {\n        if (!(VAR_6 & VAR_15))\n            return;\n\n        VAR_13.type = VAR_24;\n        BorderHashKey *VAR_25 = &VAR_13.u.border;\n        VAR_25->outline = VAR_1->outline;\n\n        double VAR_18 = 64 * VAR_0->border_scale;\n        double VAR_26 = VAR_18 * VAR_1->border_x / VAR_10->scale.x;\n        double VAR_27 = VAR_18 * VAR_1->border_y / VAR_10->scale.y;\n\n        const ASS_Rect *VAR_28 = &VAR_1->outline->cbox;\n        /* COMMENT_3 */\n        double VAR_29 = (VAR_28->x_max - VAR_28->x_min) / 2.0 + (VAR_26 + 64);\n        double VAR_30 = (VAR_28->y_max - VAR_28->y_min) / 2.0 + (VAR_27 + 64);\n\n        /* COMMENT_4 */\n        /* COMMENT_5 */\n        double VAR_31 = fabs(VAR_9[0][0]), VAR_32 = fabs(VAR_9[0][1]);\n        double VAR_33 = fabs(VAR_9[1][0]), VAR_34 = fabs(VAR_9[1][1]);\n        double VAR_35 = fabs(VAR_9[2][0]), VAR_36 = fabs(VAR_9[2][1]);\n\n        double VAR_37 = VAR_9[2][2] - VAR_35 * VAR_29 - VAR_36 * VAR_30;\n        VAR_18 = 1 / FFMAX(VAR_37, VAR_9[2][2] / VAR_38);\n\n        /* COMMENT_6 */\n        /* COMMENT_7 */\n        /* COMMENT_8 */\n\n        /* COMMENT_9 */\n        /* COMMENT_10 */\n        /* COMMENT_11 */\n        /* COMMENT_12 */\n        /* COMMENT_13 */\n        /* COMMENT_14 */\n        /* COMMENT_15 */\n        /* COMMENT_16 */\n        /* COMMENT_17 */\n\n        /* COMMENT_18 */\n        /* COMMENT_19 */\n        /* COMMENT_20 */\n        /* COMMENT_21 */\n        /* COMMENT_22 */\n\n        double VAR_39 = VAR_31 * VAR_29 + VAR_32 * VAR_30;\n        double VAR_40 = VAR_33 * VAR_29 + VAR_34 * VAR_30;\n        double VAR_41 = FFMAX(VAR_39, VAR_40) * VAR_18;\n\n        VAR_18 *= VAR_42 / VAR_43;\n        frexp(VAR_18 * (FFMAX(VAR_31, VAR_33) + VAR_35 * VAR_41), &VAR_25->scale_ord_x);\n        frexp(VAR_18 * (FFMAX(VAR_32, VAR_34) + VAR_36 * VAR_41), &VAR_25->scale_ord_y);\n        VAR_25->border.x = lrint(ldexp(VAR_26, VAR_25->scale_ord_x) / VAR_42);\n        VAR_25->border.y = lrint(ldexp(VAR_27, VAR_25->scale_ord_y) / VAR_42);\n        if (!VAR_25->border.x && !VAR_25->border.y) {\n            ass_cache_inc_ref(VAR_1->bm);\n            VAR_1->bm_o = VAR_1->bm;\n            return;\n        }\n\n        for (int VAR_11 = 0; VAR_11 < 3; VAR_11++) {\n            VAR_9[VAR_11][0] = ldexp(VAR_8[VAR_11][0], -VAR_25->scale_ord_x);\n            VAR_9[VAR_11][1] = ldexp(VAR_8[VAR_11][1], -VAR_25->scale_ord_y);\n            VAR_9[VAR_11][2] = VAR_8[VAR_11][2];\n        }\n    }\n\n    VAR_12.outline = ass_cache_get(VAR_0->cache.outline_cache, &VAR_13, VAR_0);\n    if (!VAR_12.outline || !VAR_12.outline->valid ||\n            !quantize_transform(VAR_9, VAR_3, VAR_4, false, &VAR_12)) {\n        ass_cache_dec_ref(VAR_12.outline);\n        return;\n    }\n    VAR_1->bm_o = ass_cache_get(VAR_0->cache.bitmap_cache, &VAR_12, VAR_0);\n    if (!VAR_1->bm_o || !VAR_1->bm_o->buffer) {\n        ass_cache_dec_ref(VAR_1->bm_o);\n        VAR_1->bm_o = NULL;\n        *VAR_3 = *VAR_2;\n    } else if (!VAR_1->bm)\n        *VAR_2 = *VAR_3;\n}",
  "func_graph_path_before": "libass/676f9dc5b52ef406c5527bdadbcb947f11392929/ass_render.c/vul/before/0.json",
  "func": "static void\nget_bitmap_glyph(ASS_Renderer *render_priv, GlyphInfo *info,\n                 ASS_Vector *pos, ASS_Vector *pos_o,\n                 ASS_DVector *offset, bool first, int flags)\n{\n    if (!info->outline || info->symbol == '\\n' || info->symbol == 0 || info->skip) {\n        ass_cache_dec_ref(info->outline);\n        return;\n    }\n\n    double m1[3][3], m2[3][3], m[3][3];\n    const ASS_Transform *tr = &info->transform;\n    calc_transform_matrix(render_priv, info, m1);\n    for (int i = 0; i < 3; i++) {\n        m2[i][0] = m1[i][0] * tr->scale.x;\n        m2[i][1] = m1[i][1] * tr->scale.y;\n        m2[i][2] = m1[i][0] * tr->offset.x + m1[i][1] * tr->offset.y + m1[i][2];\n    }\n    memcpy(m, m2, sizeof(m));\n\n    BitmapHashKey key;\n    key.outline = info->outline;\n    if (!quantize_transform(m, pos, offset, first, &key)) {\n        ass_cache_dec_ref(info->outline);\n        return;\n    }\n    info->bm = ass_cache_get(render_priv->cache.bitmap_cache, &key, render_priv);\n    if (!info->bm || !info->bm->buffer) {\n        ass_cache_dec_ref(info->bm);\n        info->bm = NULL;\n    }\n    *pos_o = *pos;\n\n    OutlineHashKey ol_key;\n    if (flags & FILTER_BORDER_STYLE_3) {\n        if (!(flags & (FILTER_NONZERO_BORDER | FILTER_NONZERO_SHADOW)))\n            return;\n\n        ol_key.type = OUTLINE_BOX;\n\n        double w = 64 * render_priv->border_scale;\n        ASS_DVector bord = { info->border_x * w, info->border_y * w };\n        double width = info->hspacing_scaled + info->advance.x;\n        double height = info->asc + info->desc;\n\n        ASS_DVector orig_scale;\n        orig_scale.x = info->scale_x * info->scale_fix;\n        orig_scale.y = info->scale_y * info->scale_fix;\n\n        // Emulate the WTFish behavior of VSFilter, i.e. double-scale\n        // the sizes of the opaque box.\n        bord.x *= orig_scale.x;\n        bord.y *= orig_scale.y;\n        width  *= orig_scale.x;\n        height *= orig_scale.y;\n\n        // to avoid gaps\n        bord.x = FFMAX(64, bord.x);\n        bord.y = FFMAX(64, bord.y);\n\n        ASS_DVector scale = {\n            (width  + 2 * bord.x) / 64,\n            (height + 2 * bord.y) / 64,\n        };\n        ASS_DVector offset = { -bord.x, -bord.y - info->asc };\n        for (int i = 0; i < 3; i++) {\n            m[i][0] = m1[i][0] * scale.x;\n            m[i][1] = m1[i][1] * scale.y;\n            m[i][2] = m1[i][0] * offset.x + m1[i][1] * offset.y + m1[i][2];\n        }\n    } else {\n        if (!(flags & FILTER_NONZERO_BORDER))\n            return;\n\n        ol_key.type = OUTLINE_BORDER;\n        BorderHashKey *k = &ol_key.u.border;\n        k->outline = info->outline;\n\n        double w = 64 * render_priv->border_scale;\n        double bord_x = w * info->border_x / tr->scale.x;\n        double bord_y = w * info->border_y / tr->scale.y;\n\n        const ASS_Rect *bbox = &info->outline->cbox;\n        // Estimate bounding box half size after stroking\n        double dx = (bbox->x_max - bbox->x_min) / 2.0 + (bord_x + 64);\n        double dy = (bbox->y_max - bbox->y_min) / 2.0 + (bord_y + 64);\n\n        // Matrix after quantize_transform() has\n        // input and output origin at bounding box center.\n        double mxx = fabs(m[0][0]), mxy = fabs(m[0][1]);\n        double myx = fabs(m[1][0]), myy = fabs(m[1][1]);\n        double mzx = fabs(m[2][0]), mzy = fabs(m[2][1]);\n\n        double z0 = m[2][2] - mzx * dx - mzy * dy;\n        w = 1 / FFMAX(z0, m[2][2] / MAX_PERSP_SCALE);\n\n        // Notation from quantize_transform().\n        // Note that goal here is to estimate acceptable error for stroking, i. e. D(x) and D(y).\n        // Matrix coefficients are constants now, so D(m_??) = 0.\n\n        // D(z) <= |m_zx| * D(x) + |m_zy| * D(y),\n        // D(x_out) = D((m_xx * x + m_xy * y) / z)\n        //  <= (|m_xx| * D(x) + |m_xy| * D(y)) / z0 + x_lim * D(z) / z0^2\n        //  <= (|m_xx| / z0 + |m_zx| * x_lim / z0^2) * D(x)\n        //   + (|m_xy| / z0 + |m_zy| * x_lim / z0^2) * D(y),\n        // D(y_out) = D((m_yx * x + m_yy * y) / z)\n        //  <= (|m_yx| * D(x) + |m_yy| * D(y)) / z0 + y_lim * D(z) / z0^2\n        //  <= (|m_yx| / z0 + |m_zx| * y_lim / z0^2) * D(x)\n        //   + (|m_yy| / z0 + |m_zy| * y_lim / z0^2) * D(y).\n\n        // Quantization steps (ACCURACY ~ POSITION_PRECISION):\n        // STROKER_PRECISION / 2^scale_ord_x ~ D(x) ~ POSITION_PRECISION /\n        //   (max(|m_xx|, |m_yx|) / z0 + |m_zx| * max(x_lim, y_lim) / z0^2),\n        // STROKER_PRECISION / 2^scale_ord_y ~ D(y) ~ POSITION_PRECISION /\n        //   (max(|m_xy|, |m_yy|) / z0 + |m_zy| * max(x_lim, y_lim) / z0^2).\n\n        double x_lim = mxx * dx + mxy * dy;\n        double y_lim = myx * dx + myy * dy;\n        double rz = FFMAX(x_lim, y_lim) * w;\n\n        w *= STROKER_PRECISION / POSITION_PRECISION;\n        frexp(w * (FFMAX(mxx, myx) + mzx * rz), &k->scale_ord_x);\n        frexp(w * (FFMAX(mxy, myy) + mzy * rz), &k->scale_ord_y);\n        bord_x = ldexp(bord_x, k->scale_ord_x);\n        bord_y = ldexp(bord_y, k->scale_ord_y);\n        if (!(bord_x < OUTLINE_MAX && bord_y < OUTLINE_MAX))\n            return;\n        k->border.x = lrint(bord_x / STROKER_PRECISION);\n        k->border.y = lrint(bord_y / STROKER_PRECISION);\n        if (!k->border.x && !k->border.y) {\n            ass_cache_inc_ref(info->bm);\n            info->bm_o = info->bm;\n            return;\n        }\n\n        for (int i = 0; i < 3; i++) {\n            m[i][0] = ldexp(m2[i][0], -k->scale_ord_x);\n            m[i][1] = ldexp(m2[i][1], -k->scale_ord_y);\n            m[i][2] = m2[i][2];\n        }\n    }\n\n    key.outline = ass_cache_get(render_priv->cache.outline_cache, &ol_key, render_priv);\n    if (!key.outline || !key.outline->valid ||\n            !quantize_transform(m, pos_o, offset, false, &key)) {\n        ass_cache_dec_ref(key.outline);\n        return;\n    }\n    info->bm_o = ass_cache_get(render_priv->cache.bitmap_cache, &key, render_priv);\n    if (!info->bm_o || !info->bm_o->buffer) {\n        ass_cache_dec_ref(info->bm_o);\n        info->bm_o = NULL;\n        *pos_o = *pos;\n    } else if (!info->bm)\n        *pos = *pos_o;\n}",
  "abstract_func": "static void\nget_bitmap_glyph(ASS_Renderer *VAR_0, GlyphInfo *VAR_1,\n                 ASS_Vector *VAR_2, ASS_Vector *VAR_3,\n                 ASS_DVector *VAR_4, bool VAR_5, int VAR_6)\n{\n    if (!VAR_1->outline || VAR_1->symbol == '\\n' || VAR_1->symbol == 0 || VAR_1->skip) {\n        ass_cache_dec_ref(VAR_1->outline);\n        return;\n    }\n\n    double VAR_7[3][3], VAR_8[3][3], VAR_9[3][3];\n    const ASS_Transform *VAR_10 = &VAR_1->transform;\n    calc_transform_matrix(VAR_0, VAR_1, VAR_7);\n    for (int VAR_11 = 0; VAR_11 < 3; VAR_11++) {\n        VAR_8[VAR_11][0] = VAR_7[VAR_11][0] * VAR_10->scale.x;\n        VAR_8[VAR_11][1] = VAR_7[VAR_11][1] * VAR_10->scale.y;\n        VAR_8[VAR_11][2] = VAR_7[VAR_11][0] * VAR_10->offset.x + VAR_7[VAR_11][1] * VAR_10->offset.y + VAR_7[VAR_11][2];\n    }\n    memcpy(VAR_9, VAR_8, sizeof(VAR_9));\n\n    BitmapHashKey VAR_12;\n    VAR_12.outline = VAR_1->outline;\n    if (!quantize_transform(VAR_9, VAR_2, VAR_4, VAR_5, &VAR_12)) {\n        ass_cache_dec_ref(VAR_1->outline);\n        return;\n    }\n    VAR_1->bm = ass_cache_get(VAR_0->cache.bitmap_cache, &VAR_12, VAR_0);\n    if (!VAR_1->bm || !VAR_1->bm->buffer) {\n        ass_cache_dec_ref(VAR_1->bm);\n        VAR_1->bm = NULL;\n    }\n    *VAR_3 = *VAR_2;\n\n    OutlineHashKey VAR_13;\n    if (VAR_6 & VAR_14) {\n        if (!(VAR_6 & (VAR_15 | VAR_16)))\n            return;\n\n        VAR_13.type = VAR_17;\n\n        double VAR_18 = 64 * VAR_0->border_scale;\n        ASS_DVector VAR_19 = { VAR_1->border_x * VAR_18, VAR_1->border_y * VAR_18 };\n        double VAR_20 = VAR_1->hspacing_scaled + VAR_1->advance.x;\n        double VAR_21 = VAR_1->asc + VAR_1->desc;\n\n        ASS_DVector VAR_22;\n        VAR_22.x = VAR_1->scale_x * VAR_1->scale_fix;\n        VAR_22.y = VAR_1->scale_y * VAR_1->scale_fix;\n\n        /* COMMENT_0 */\n        /* COMMENT_1 */\n        VAR_19.x *= VAR_22.x;\n        VAR_19.y *= VAR_22.y;\n        VAR_20  *= VAR_22.x;\n        VAR_21 *= VAR_22.y;\n\n        /* COMMENT_2 */\n        VAR_19.x = FFMAX(64, VAR_19.x);\n        VAR_19.y = FFMAX(64, VAR_19.y);\n\n        ASS_DVector VAR_23 = {\n            (VAR_20  + 2 * VAR_19.x) / 64,\n            (VAR_21 + 2 * VAR_19.y) / 64,\n        };\n        ASS_DVector VAR_4 = { -VAR_19.x, -VAR_19.y - VAR_1->asc };\n        for (int VAR_11 = 0; VAR_11 < 3; VAR_11++) {\n            VAR_9[VAR_11][0] = VAR_7[VAR_11][0] * VAR_23.x;\n            VAR_9[VAR_11][1] = VAR_7[VAR_11][1] * VAR_23.y;\n            VAR_9[VAR_11][2] = VAR_7[VAR_11][0] * VAR_4.x + VAR_7[VAR_11][1] * VAR_4.y + VAR_7[VAR_11][2];\n        }\n    } else {\n        if (!(VAR_6 & VAR_15))\n            return;\n\n        VAR_13.type = VAR_24;\n        BorderHashKey *VAR_25 = &VAR_13.u.border;\n        VAR_25->outline = VAR_1->outline;\n\n        double VAR_18 = 64 * VAR_0->border_scale;\n        double VAR_26 = VAR_18 * VAR_1->border_x / VAR_10->scale.x;\n        double VAR_27 = VAR_18 * VAR_1->border_y / VAR_10->scale.y;\n\n        const ASS_Rect *VAR_28 = &VAR_1->outline->cbox;\n        /* COMMENT_3 */\n        double VAR_29 = (VAR_28->x_max - VAR_28->x_min) / 2.0 + (VAR_26 + 64);\n        double VAR_30 = (VAR_28->y_max - VAR_28->y_min) / 2.0 + (VAR_27 + 64);\n\n        /* COMMENT_4 */\n        /* COMMENT_5 */\n        double VAR_31 = fabs(VAR_9[0][0]), VAR_32 = fabs(VAR_9[0][1]);\n        double VAR_33 = fabs(VAR_9[1][0]), VAR_34 = fabs(VAR_9[1][1]);\n        double VAR_35 = fabs(VAR_9[2][0]), VAR_36 = fabs(VAR_9[2][1]);\n\n        double VAR_37 = VAR_9[2][2] - VAR_35 * VAR_29 - VAR_36 * VAR_30;\n        VAR_18 = 1 / FFMAX(VAR_37, VAR_9[2][2] / VAR_38);\n\n        /* COMMENT_6 */\n        /* COMMENT_7 */\n        /* COMMENT_8 */\n\n        /* COMMENT_9 */\n        /* COMMENT_10 */\n        /* COMMENT_11 */\n        /* COMMENT_12 */\n        /* COMMENT_13 */\n        /* COMMENT_14 */\n        /* COMMENT_15 */\n        /* COMMENT_16 */\n        /* COMMENT_17 */\n\n        /* COMMENT_18 */\n        /* COMMENT_19 */\n        /* COMMENT_20 */\n        /* COMMENT_21 */\n        /* COMMENT_22 */\n\n        double VAR_39 = VAR_31 * VAR_29 + VAR_32 * VAR_30;\n        double VAR_40 = VAR_33 * VAR_29 + VAR_34 * VAR_30;\n        double VAR_41 = FFMAX(VAR_39, VAR_40) * VAR_18;\n\n        VAR_18 *= VAR_42 / VAR_43;\n        frexp(VAR_18 * (FFMAX(VAR_31, VAR_33) + VAR_35 * VAR_41), &VAR_25->scale_ord_x);\n        frexp(VAR_18 * (FFMAX(VAR_32, VAR_34) + VAR_36 * VAR_41), &VAR_25->scale_ord_y);\n        VAR_26 = ldexp(VAR_26, VAR_25->scale_ord_x);\n        VAR_27 = ldexp(VAR_27, VAR_25->scale_ord_y);\n        if (!(VAR_26 < VAR_44 && VAR_27 < VAR_44))\n            return;\n        VAR_25->border.x = lrint(VAR_26 / VAR_42);\n        VAR_25->border.y = lrint(VAR_27 / VAR_42);\n        if (!VAR_25->border.x && !VAR_25->border.y) {\n            ass_cache_inc_ref(VAR_1->bm);\n            VAR_1->bm_o = VAR_1->bm;\n            return;\n        }\n\n        for (int VAR_11 = 0; VAR_11 < 3; VAR_11++) {\n            VAR_9[VAR_11][0] = ldexp(VAR_8[VAR_11][0], -VAR_25->scale_ord_x);\n            VAR_9[VAR_11][1] = ldexp(VAR_8[VAR_11][1], -VAR_25->scale_ord_y);\n            VAR_9[VAR_11][2] = VAR_8[VAR_11][2];\n        }\n    }\n\n    VAR_12.outline = ass_cache_get(VAR_0->cache.outline_cache, &VAR_13, VAR_0);\n    if (!VAR_12.outline || !VAR_12.outline->valid ||\n            !quantize_transform(VAR_9, VAR_3, VAR_4, false, &VAR_12)) {\n        ass_cache_dec_ref(VAR_12.outline);\n        return;\n    }\n    VAR_1->bm_o = ass_cache_get(VAR_0->cache.bitmap_cache, &VAR_12, VAR_0);\n    if (!VAR_1->bm_o || !VAR_1->bm_o->buffer) {\n        ass_cache_dec_ref(VAR_1->bm_o);\n        VAR_1->bm_o = NULL;\n        *VAR_3 = *VAR_2;\n    } else if (!VAR_1->bm)\n        *VAR_2 = *VAR_3;\n}",
  "func_graph_path": "libass/676f9dc5b52ef406c5527bdadbcb947f11392929/ass_render.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -121,8 +121,12 @@\n         w *= STROKER_PRECISION / POSITION_PRECISION;\n         frexp(w * (FFMAX(mxx, myx) + mzx * rz), &k->scale_ord_x);\n         frexp(w * (FFMAX(mxy, myy) + mzy * rz), &k->scale_ord_y);\n-        k->border.x = lrint(ldexp(bord_x, k->scale_ord_x) / STROKER_PRECISION);\n-        k->border.y = lrint(ldexp(bord_y, k->scale_ord_y) / STROKER_PRECISION);\n+        bord_x = ldexp(bord_x, k->scale_ord_x);\n+        bord_y = ldexp(bord_y, k->scale_ord_y);\n+        if (!(bord_x < OUTLINE_MAX && bord_y < OUTLINE_MAX))\n+            return;\n+        k->border.x = lrint(bord_x / STROKER_PRECISION);\n+        k->border.y = lrint(bord_y / STROKER_PRECISION);\n         if (!k->border.x && !k->border.y) {\n             ass_cache_inc_ref(info->bm);\n             info->bm_o = info->bm;",
  "diff_line_info": {
    "deleted_lines": [
      "        k->border.x = lrint(ldexp(bord_x, k->scale_ord_x) / STROKER_PRECISION);",
      "        k->border.y = lrint(ldexp(bord_y, k->scale_ord_y) / STROKER_PRECISION);"
    ],
    "added_lines": [
      "        bord_x = ldexp(bord_x, k->scale_ord_x);",
      "        bord_y = ldexp(bord_y, k->scale_ord_y);",
      "        if (!(bord_x < OUTLINE_MAX && bord_y < OUTLINE_MAX))",
      "            return;",
      "        k->border.x = lrint(bord_x / STROKER_PRECISION);",
      "        k->border.y = lrint(bord_y / STROKER_PRECISION);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libass/libass/pull/432",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/libass/libass/pull/432: 403 Client Error: Forbidden for url: https://api.github.com/repos/libass/libass/pulls/432",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "The patch addresses an overflow issue in outline processing by adding checks to prevent out-of-range coordinates, which is a clear security concern. The code modifications align with the commit message and effectively mitigate a potential security vulnerability.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9"
}