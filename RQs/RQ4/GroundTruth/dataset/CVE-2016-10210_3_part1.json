{
  "cve_id": "CVE-2016-10210",
  "cwe_ids": [
    "CWE-476"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "VirusTotal/yara",
  "commit_msg": "re_lexer: Make reading escape sequences more robust (#586)\n\n* Add test for issue #503\r\n\r\n* re_lexer: Make reading escape sequences more robust\r\n\r\nThis commit fixes parsing incomplete escape sequences at the end of a\r\nregular expression and parsing things like \\xxy (invalid hex digits)\r\nwhich before were silently turned into (char)255.\r\n\r\nClose #503\r\n\r\n* Update re_lexer.c",
  "commit_hash": "3119b232c9c453c98d8fa8b6ae4e37ba18117cd4",
  "git_url": "https://github.com/VirusTotal/yara/commit/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4",
  "file_path": "libyara/re_lexer.c",
  "func_name": "yyinput",
  "func_before": "static int yyinput (yyscan_t yyscanner)\n#else\n    static int input  (yyscan_t yyscanner)\n#endif\n\n{\n\tint c;\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n\t*yyg->yy_c_buf_p = yyg->yy_hold_char;\n\n\tif ( *yyg->yy_c_buf_p == YY_END_OF_BUFFER_CHAR )\n\t\t{\n\t\t/* yy_c_buf_p now points to the character we want to return.\n\t\t * If this occurs *before* the EOB characters, then it's a\n\t\t * valid NUL; if not, then we've hit the end of the buffer.\n\t\t */\n\t\tif ( yyg->yy_c_buf_p < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )\n\t\t\t/* This was really a NUL. */\n\t\t\t*yyg->yy_c_buf_p = '\\0';\n\n\t\telse\n\t\t\t{ /* need more input */\n\t\t\tyy_size_t offset = yyg->yy_c_buf_p - yyg->yytext_ptr;\n\t\t\t++yyg->yy_c_buf_p;\n\n\t\t\tswitch ( yy_get_next_buffer( yyscanner ) )\n\t\t\t\t{\n\t\t\t\tcase EOB_ACT_LAST_MATCH:\n\t\t\t\t\t/* This happens because yy_g_n_b()\n\t\t\t\t\t * sees that we've accumulated a\n\t\t\t\t\t * token and flags that we need to\n\t\t\t\t\t * try matching the token before\n\t\t\t\t\t * proceeding.  But for input(),\n\t\t\t\t\t * there's no matching to consider.\n\t\t\t\t\t * So convert the EOB_ACT_LAST_MATCH\n\t\t\t\t\t * to EOB_ACT_END_OF_FILE.\n\t\t\t\t\t */\n\n\t\t\t\t\t/* Reset buffer status. */\n\t\t\t\t\tre_yyrestart(yyin ,yyscanner);\n\n\t\t\t\t\t/*FALLTHROUGH*/\n\n\t\t\t\tcase EOB_ACT_END_OF_FILE:\n\t\t\t\t\t{\n\t\t\t\t\tif ( re_yywrap(yyscanner ) )\n\t\t\t\t\t\treturn EOF;\n\n\t\t\t\t\tif ( ! yyg->yy_did_buffer_switch_on_eof )\n\t\t\t\t\t\tYY_NEW_FILE;\n#ifdef __cplusplus\n\t\t\t\t\treturn yyinput(yyscanner);\n#else\n\t\t\t\t\treturn input(yyscanner);\n#endif\n\t\t\t\t\t}\n\n\t\t\t\tcase EOB_ACT_CONTINUE_SCAN:\n\t\t\t\t\tyyg->yy_c_buf_p = yyg->yytext_ptr + offset;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tc = *(unsigned char *) yyg->yy_c_buf_p;\t/* cast for 8-bit char's */\n\t*yyg->yy_c_buf_p = '\\0';\t/* preserve yytext */\n\tyyg->yy_hold_char = *++yyg->yy_c_buf_p;\n\n\tif ( c == '\\n' )\n\t\t   \n    do{ yylineno++;\n        yycolumn=0;\n    }while(0)\n;\n\n\treturn c;\n}",
  "abstract_func_before": "static int yyinput (yyscan_t VAR_0)\n#else\n    static int VAR_1  (yyscan_t VAR_0)\n#endif\n\n{\n\tint VAR_2;\n    struct yyguts_t * VAR_3 = (struct yyguts_t*)VAR_0;\n\n\t*VAR_3->yy_c_buf_p = VAR_3->yy_hold_char;\n\n\tif ( *VAR_3->yy_c_buf_p == VAR_4 )\n\t\t{\n\t\t/* COMMENT_0 */\n                                                            \n                                                             \n     \n\t\tif ( VAR_3->yy_c_buf_p < &VAR_5->yy_ch_buf[VAR_3->yy_n_chars] )\n\t\t\t/* COMMENT_4 */\n\t\t\t*VAR_3->yy_c_buf_p = '\\0';\n\n\t\telse\n\t\t\t{ /* COMMENT_5 */\n\t\t\tyy_size_t VAR_6 = VAR_3->yy_c_buf_p - VAR_3->yytext_ptr;\n\t\t\t++VAR_3->yy_c_buf_p;\n\n\t\t\tswitch ( yy_get_next_buffer( VAR_0 ) )\n\t\t\t\t{\n\t\t\t\tcase VAR_7:\n\t\t\t\t\t/* COMMENT_6 */\n                                     \n                                       \n                                     \n                                     \n                                        \n                                         \n                               \n        \n\n\t\t\t\t\t/* COMMENT_15 */\n\t\t\t\t\tre_yyrestart(VAR_8 ,VAR_0);\n\n\t\t\t\t\t/* COMMENT_16 */\n\n\t\t\t\tcase VAR_9:\n\t\t\t\t\t{\n\t\t\t\t\tif ( re_yywrap(VAR_0 ) )\n\t\t\t\t\t\treturn VAR_10;\n\n\t\t\t\t\tif ( ! VAR_3->yy_did_buffer_switch_on_eof )\n\t\t\t\t\t\tVAR_11;\n#ifdef VAR_12\n\t\t\t\t\treturn yyinput(VAR_0);\n#else\n\t\t\t\t\treturn VAR_1(VAR_0);\n#endif\n\t\t\t\t\t}\n\n\t\t\t\tcase VAR_13:\n\t\t\t\t\tVAR_3->yy_c_buf_p = VAR_3->yytext_ptr + VAR_6;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tVAR_2 = *(unsigned char *) VAR_3->yy_c_buf_p;\t/* COMMENT_17 */\n\t*VAR_3->yy_c_buf_p = '\\0';\t/* COMMENT_18 */\n\tVAR_3->yy_hold_char = *++VAR_3->yy_c_buf_p;\n\n\tif ( VAR_2 == '\\n' )\n\t\t   \n    do{ VAR_14++;\n        VAR_15=0;\n    }while(0)\n;\n\n\treturn VAR_2;\n}",
  "func_graph_path_before": null,
  "func": "static int yyinput (yyscan_t yyscanner)\n#else\n    static int input  (yyscan_t yyscanner)\n#endif\n\n{\n\tint c;\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n\t*yyg->yy_c_buf_p = yyg->yy_hold_char;\n\n\tif ( *yyg->yy_c_buf_p == YY_END_OF_BUFFER_CHAR )\n\t\t{\n\t\t/* yy_c_buf_p now points to the character we want to return.\n\t\t * If this occurs *before* the EOB characters, then it's a\n\t\t * valid NUL; if not, then we've hit the end of the buffer.\n\t\t */\n\t\tif ( yyg->yy_c_buf_p < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )\n\t\t\t/* This was really a NUL. */\n\t\t\t*yyg->yy_c_buf_p = '\\0';\n\n\t\telse\n\t\t\t{ /* need more input */\n\t\t\tyy_size_t offset = yyg->yy_c_buf_p - yyg->yytext_ptr;\n\t\t\t++yyg->yy_c_buf_p;\n\n\t\t\tswitch ( yy_get_next_buffer( yyscanner ) )\n\t\t\t\t{\n\t\t\t\tcase EOB_ACT_LAST_MATCH:\n\t\t\t\t\t/* This happens because yy_g_n_b()\n\t\t\t\t\t * sees that we've accumulated a\n\t\t\t\t\t * token and flags that we need to\n\t\t\t\t\t * try matching the token before\n\t\t\t\t\t * proceeding.  But for input(),\n\t\t\t\t\t * there's no matching to consider.\n\t\t\t\t\t * So convert the EOB_ACT_LAST_MATCH\n\t\t\t\t\t * to EOB_ACT_END_OF_FILE.\n\t\t\t\t\t */\n\n\t\t\t\t\t/* Reset buffer status. */\n\t\t\t\t\tre_yyrestart(yyin ,yyscanner);\n\n\t\t\t\t\t/*FALLTHROUGH*/\n\n\t\t\t\tcase EOB_ACT_END_OF_FILE:\n\t\t\t\t\t{\n\t\t\t\t\tif ( re_yywrap(yyscanner ) )\n\t\t\t\t\t\treturn EOF;\n\n\t\t\t\t\tif ( ! yyg->yy_did_buffer_switch_on_eof )\n\t\t\t\t\t\tYY_NEW_FILE;\n#ifdef __cplusplus\n\t\t\t\t\treturn yyinput(yyscanner);\n#else\n\t\t\t\t\treturn input(yyscanner);\n#endif\n\t\t\t\t\t}\n\n\t\t\t\tcase EOB_ACT_CONTINUE_SCAN:\n\t\t\t\t\tyyg->yy_c_buf_p = yyg->yytext_ptr + offset;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tc = *(unsigned char *) yyg->yy_c_buf_p;\t/* cast for 8-bit char's */\n\t*yyg->yy_c_buf_p = '\\0';\t/* preserve yytext */\n\tyyg->yy_hold_char = *++yyg->yy_c_buf_p;\n\n\tif ( c == '\\n' )\n\t\t\n    do{ yylineno++;\n        yycolumn=0;\n    }while(0)\n;\n\n\treturn c;\n}",
  "abstract_func": "static int yyinput (yyscan_t VAR_0)\n#else\n    static int VAR_1  (yyscan_t VAR_0)\n#endif\n\n{\n\tint VAR_2;\n    struct yyguts_t * VAR_3 = (struct yyguts_t*)VAR_0;\n\n\t*VAR_3->yy_c_buf_p = VAR_3->yy_hold_char;\n\n\tif ( *VAR_3->yy_c_buf_p == VAR_4 )\n\t\t{\n\t\t/* COMMENT_0 */\n                                                            \n                                                             \n     \n\t\tif ( VAR_3->yy_c_buf_p < &VAR_5->yy_ch_buf[VAR_3->yy_n_chars] )\n\t\t\t/* COMMENT_4 */\n\t\t\t*VAR_3->yy_c_buf_p = '\\0';\n\n\t\telse\n\t\t\t{ /* COMMENT_5 */\n\t\t\tyy_size_t VAR_6 = VAR_3->yy_c_buf_p - VAR_3->yytext_ptr;\n\t\t\t++VAR_3->yy_c_buf_p;\n\n\t\t\tswitch ( yy_get_next_buffer( VAR_0 ) )\n\t\t\t\t{\n\t\t\t\tcase VAR_7:\n\t\t\t\t\t/* COMMENT_6 */\n                                     \n                                       \n                                     \n                                     \n                                        \n                                         \n                               \n        \n\n\t\t\t\t\t/* COMMENT_15 */\n\t\t\t\t\tre_yyrestart(VAR_8 ,VAR_0);\n\n\t\t\t\t\t/* COMMENT_16 */\n\n\t\t\t\tcase VAR_9:\n\t\t\t\t\t{\n\t\t\t\t\tif ( re_yywrap(VAR_0 ) )\n\t\t\t\t\t\treturn VAR_10;\n\n\t\t\t\t\tif ( ! VAR_3->yy_did_buffer_switch_on_eof )\n\t\t\t\t\t\tVAR_11;\n#ifdef VAR_12\n\t\t\t\t\treturn yyinput(VAR_0);\n#else\n\t\t\t\t\treturn VAR_1(VAR_0);\n#endif\n\t\t\t\t\t}\n\n\t\t\t\tcase VAR_13:\n\t\t\t\t\tVAR_3->yy_c_buf_p = VAR_3->yytext_ptr + VAR_6;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tVAR_2 = *(unsigned char *) VAR_3->yy_c_buf_p;\t/* COMMENT_17 */\n\t*VAR_3->yy_c_buf_p = '\\0';\t/* COMMENT_18 */\n\tVAR_3->yy_hold_char = *++VAR_3->yy_c_buf_p;\n\n\tif ( VAR_2 == '\\n' )\n\t\t\n    do{ VAR_14++;\n        VAR_15=0;\n    }while(0)\n;\n\n\treturn VAR_2;\n}",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -68,7 +68,7 @@\n \tyyg->yy_hold_char = *++yyg->yy_c_buf_p;\n \n \tif ( c == '\\n' )\n-\t\t   \n+\t\t\n     do{ yylineno++;\n         yycolumn=0;\n     }while(0)",
  "diff_line_info": {
    "deleted_lines": [
      "\t\t   "
    ],
    "added_lines": [
      "\t\t"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/VirusTotal/yara/pull/586",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/VirusTotal/yara/pull/586: 403 Client Error: Forbidden for url: https://api.github.com/repos/VirusTotal/yara/pulls/586",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "Final Classification: Defect Remediation & Feature Upgrades; Confidence: 0.9"
}