{
  "cve_id": "CVE-2018-5702",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "transmission",
  "commit_msg": "mitigate dns rebinding attacks against daemon",
  "commit_hash": "cf7173df930cfa7ac1b1b0e9027c1deffd0b3c84",
  "git_url": "https://github.com/transmission/transmission/commit/cf7173df930cfa7ac1b1b0e9027c1deffd0b3c84",
  "file_path": "libtransmission/rpc-server.c",
  "func_name": "handle_request",
  "func_before": "static void handle_request(struct evhttp_request* req, void* arg)\n{\n    struct tr_rpc_server* server = arg;\n\n    if (req != NULL && req->evcon != NULL)\n    {\n        char const* auth;\n        char* user = NULL;\n        char* pass = NULL;\n\n        evhttp_add_header(req->output_headers, \"Server\", MY_REALM);\n\n        if (server->loginattempts == 100)\n        {\n            send_simple_response(req, 403, \"<p>Too many unsuccessful login attempts. Please restart transmission-daemon.</p>\");\n            return;\n        }\n\n        if (!isAddressAllowed(server, req->remote_host))\n        {\n            send_simple_response(req, 403,\n                \"<p>Unauthorized IP Address.</p>\"\n                \"<p>Either disable the IP address whitelist or add your address to it.</p>\"\n                \"<p>If you're editing settings.json, see the 'rpc-whitelist' and 'rpc-whitelist-enabled' entries.</p>\"\n                \"<p>If you're still using ACLs, use a whitelist instead. See the transmission-daemon manpage for details.</p>\");\n            return;\n        }\n\n        auth = evhttp_find_header(req->input_headers, \"Authorization\");\n\n        if (auth != NULL && evutil_ascii_strncasecmp(auth, \"basic \", 6) == 0)\n        {\n            size_t plen;\n            char* p = tr_base64_decode_str(auth + 6, &plen);\n\n            if (p != NULL)\n            {\n                if (plen > 0 && (pass = strchr(p, ':')) != NULL)\n                {\n                    user = p;\n                    *pass++ = '\\0';\n                }\n                else\n                {\n                    tr_free(p);\n                }\n            }\n        }\n\n        if (server->isPasswordEnabled && (pass == NULL || user == NULL || strcmp(server->username, user) != 0 ||\n            !tr_ssha1_matches(server->password, pass)))\n        {\n            evhttp_add_header(req->output_headers, \"WWW-Authenticate\", \"Basic realm=\\\"\" MY_REALM \"\\\"\");\n            server->loginattempts++;\n            char* unauthuser = tr_strdup_printf(\"<p>Unauthorized User. %d unsuccessful login attempts.</p>\", server->loginattempts);\n            send_simple_response(req, 401, unauthuser);\n            tr_free(unauthuser);\n            tr_free(user);\n            return;\n        }\n\n        server->loginattempts = 0;\n\n        if (strncmp(req->uri, server->url, strlen(server->url)) != 0)\n        {\n            char* location = tr_strdup_printf(\"%sweb/\", server->url);\n            evhttp_add_header(req->output_headers, \"Location\", location);\n            send_simple_response(req, HTTP_MOVEPERM, NULL);\n            tr_free(location);\n        }\n        else if (strncmp(req->uri + strlen(server->url), \"web/\", 4) == 0)\n        {\n            handle_web_client(req, server);\n        }\n        else if (strcmp(req->uri + strlen(server->url), \"upload\") == 0)\n        {\n            handle_upload(req, server);\n        }\n\n#ifdef REQUIRE_SESSION_ID\n\n        else if (!test_session_id(server, req))\n        {\n            char const* sessionId = get_current_session_id(server);\n            char* tmp = tr_strdup_printf(\n                \"<p>Your request had an invalid session-id header.</p>\"\n                \"<p>To fix this, follow these steps:\"\n                \"<ol><li> When reading a response, get its X-Transmission-Session-Id header and remember it\"\n                \"<li> Add the updated header to your outgoing requests\"\n                \"<li> When you get this 409 error message, resend your request with the updated header\"\n                \"</ol></p>\"\n                \"<p>This requirement has been added to help prevent \"\n                \"<a href=\\\"http://en.wikipedia.org/wiki/Cross-site_request_forgery\\\">CSRF</a> \"\n                \"attacks.</p>\"\n                \"<p><code>%s: %s</code></p>\",\n                TR_RPC_SESSION_ID_HEADER, sessionId);\n            evhttp_add_header(req->output_headers, TR_RPC_SESSION_ID_HEADER, sessionId);\n            send_simple_response(req, 409, tmp);\n            tr_free(tmp);\n        }\n\n#endif\n\n        else if (strncmp(req->uri + strlen(server->url), \"rpc\", 3) == 0)\n        {\n            handle_rpc(req, server);\n        }\n        else\n        {\n            send_simple_response(req, HTTP_NOTFOUND, req->uri);\n        }\n\n        tr_free(user);\n    }\n}",
  "abstract_func_before": "static void handle_request(struct evhttp_request* VAR_0, void* VAR_1)\n{\n    struct tr_rpc_server* VAR_2 = VAR_1;\n\n    if (VAR_0 != NULL && VAR_0->evcon != NULL)\n    {\n        char const* VAR_3;\n        char* VAR_4 = NULL;\n        char* VAR_5 = NULL;\n\n        evhttp_add_header(VAR_0->output_headers, \"Server\", VAR_6);\n\n        if (VAR_2->loginattempts == 100)\n        {\n            send_simple_response(VAR_0, 403, \"<p>Too many unsuccessful login attempts. Please restart transmission-daemon.</p>\");\n            return;\n        }\n\n        if (!isAddressAllowed(VAR_2, VAR_0->remote_host))\n        {\n            send_simple_response(VAR_0, 403,\n                \"<p>Unauthorized IP Address.</p>\"\n                \"<p>Either disable the IP address whitelist or add your address to it.</p>\"\n                \"<p>If you're editing settings.json, see the 'rpc-whitelist' and 'rpc-whitelist-enabled' entries.</p>\"\n                \"<p>If you're still using ACLs, use a whitelist instead. See the transmission-daemon manpage for details.</p>\");\n            return;\n        }\n\n        VAR_3 = evhttp_find_header(VAR_0->input_headers, \"Authorization\");\n\n        if (VAR_3 != NULL && evutil_ascii_strncasecmp(VAR_3, \"basic \", 6) == 0)\n        {\n            size_t VAR_7;\n            char* VAR_8 = tr_base64_decode_str(VAR_3 + 6, &VAR_7);\n\n            if (VAR_8 != NULL)\n            {\n                if (VAR_7 > 0 && (VAR_5 = strchr(VAR_8, ':')) != NULL)\n                {\n                    VAR_4 = VAR_8;\n                    *VAR_5++ = '\\0';\n                }\n                else\n                {\n                    tr_free(VAR_8);\n                }\n            }\n        }\n\n        if (VAR_2->isPasswordEnabled && (VAR_5 == NULL || VAR_4 == NULL || strcmp(VAR_2->username, VAR_4) != 0 ||\n            !tr_ssha1_matches(VAR_2->password, VAR_5)))\n        {\n            evhttp_add_header(VAR_0->output_headers, \"WWW-Authenticate\", \"Basic realm=\\\"\" VAR_6 \"\\\"\");\n            VAR_2->loginattempts++;\n            char* VAR_9 = tr_strdup_printf(\"<p>Unauthorized User. %d unsuccessful login attempts.</p>\", VAR_2->loginattempts);\n            send_simple_response(VAR_0, 401, VAR_9);\n            tr_free(VAR_9);\n            tr_free(VAR_4);\n            return;\n        }\n\n        VAR_2->loginattempts = 0;\n\n        if (strncmp(VAR_0->uri, VAR_2->url, strlen(VAR_2->url)) != 0)\n        {\n            char* VAR_10 = tr_strdup_printf(\"%sweb/\", VAR_2->url);\n            evhttp_add_header(VAR_0->output_headers, \"Location\", VAR_10);\n            send_simple_response(VAR_0, VAR_11, NULL);\n            tr_free(VAR_10);\n        }\n        else if (strncmp(VAR_0->uri + strlen(VAR_2->url), \"web/\", 4) == 0)\n        {\n            handle_web_client(VAR_0, VAR_2);\n        }\n        else if (strcmp(VAR_0->uri + strlen(VAR_2->url), \"upload\") == 0)\n        {\n            handle_upload(VAR_0, VAR_2);\n        }\n\n#ifdef VAR_12\n\n        else if (!test_session_id(server, req))\n        {\n            char const* VAR_13 = get_current_session_id(server);\n            char* VAR_14 = tr_strdup_printf(\n                \"<p>Your request had an invalid session-id header.</p>\"\n                \"<p>To fix this, follow these steps:\"\n                \"<ol><li> When reading a response, get its X-Transmission-Session-Id header and remember it\"\n                \"<li> Add the updated header to your outgoing requests\"\n                \"<li> When you get this 409 error message, resend your request with the updated header\"\n                \"</ol></p>\"\n                \"<p>This requirement has been added to help prevent \"\n                \"<a href=\\\"http://en.wikipedia.org/wiki/Cross-site_request_forgery\\\">CSRF</a> \"\n                \"attacks.</p>\"\n                \"<p><code>%s: %s</code></p>\",\n                VAR_15, VAR_13);\n            evhttp_add_header(req->output_headers, VAR_15, VAR_13);\n            send_simple_response(req, 409, VAR_14);\n            tr_free(VAR_14);\n        }\n\n#endif\n\n        else if (VAR_16(req->VAR_17 + strlen(server->url), \"rpc\", 3) == 0)\n        {\n            handle_rpc(req, server);\n        }\n        else\n        {\n            send_simple_response(req, VAR_18, req->uri);\n        }\n\n        tr_free(VAR_4);\n    }\n}",
  "func_graph_path_before": "transmission/cf7173df930cfa7ac1b1b0e9027c1deffd0b3c84/rpc-server.c/vul/before/1.json",
  "func": "static void handle_request(struct evhttp_request* req, void* arg)\n{\n    struct tr_rpc_server* server = arg;\n\n    if (req != NULL && req->evcon != NULL)\n    {\n        char const* auth;\n        char* user = NULL;\n        char* pass = NULL;\n\n        evhttp_add_header(req->output_headers, \"Server\", MY_REALM);\n\n        if (server->loginattempts == 100)\n        {\n            send_simple_response(req, 403, \"<p>Too many unsuccessful login attempts. Please restart transmission-daemon.</p>\");\n            return;\n        }\n\n        if (!isAddressAllowed(server, req->remote_host))\n        {\n            send_simple_response(req, 403,\n                \"<p>Unauthorized IP Address.</p>\"\n                \"<p>Either disable the IP address whitelist or add your address to it.</p>\"\n                \"<p>If you're editing settings.json, see the 'rpc-whitelist' and 'rpc-whitelist-enabled' entries.</p>\"\n                \"<p>If you're still using ACLs, use a whitelist instead. See the transmission-daemon manpage for details.</p>\");\n            return;\n        }\n\n        auth = evhttp_find_header(req->input_headers, \"Authorization\");\n\n        if (auth != NULL && evutil_ascii_strncasecmp(auth, \"basic \", 6) == 0)\n        {\n            size_t plen;\n            char* p = tr_base64_decode_str(auth + 6, &plen);\n\n            if (p != NULL)\n            {\n                if (plen > 0 && (pass = strchr(p, ':')) != NULL)\n                {\n                    user = p;\n                    *pass++ = '\\0';\n                }\n                else\n                {\n                    tr_free(p);\n                }\n            }\n        }\n\n        if (server->isPasswordEnabled && (pass == NULL || user == NULL || strcmp(server->username, user) != 0 ||\n            !tr_ssha1_matches(server->password, pass)))\n        {\n            evhttp_add_header(req->output_headers, \"WWW-Authenticate\", \"Basic realm=\\\"\" MY_REALM \"\\\"\");\n            server->loginattempts++;\n            char* unauthuser = tr_strdup_printf(\"<p>Unauthorized User. %d unsuccessful login attempts.</p>\", server->loginattempts);\n            send_simple_response(req, 401, unauthuser);\n            tr_free(unauthuser);\n            tr_free(user);\n            return;\n        }\n\n        server->loginattempts = 0;\n\n        if (strncmp(req->uri, server->url, strlen(server->url)) != 0)\n        {\n            char* location = tr_strdup_printf(\"%sweb/\", server->url);\n            evhttp_add_header(req->output_headers, \"Location\", location);\n            send_simple_response(req, HTTP_MOVEPERM, NULL);\n            tr_free(location);\n        }\n        else if (strncmp(req->uri + strlen(server->url), \"web/\", 4) == 0)\n        {\n            handle_web_client(req, server);\n        }\n        else if (strcmp(req->uri + strlen(server->url), \"upload\") == 0)\n        {\n            handle_upload(req, server);\n        }\n\n#ifdef REQUIRE_SESSION_ID\n\n        else if (!isHostnameAllowed(server, req))\n        {\n            char* const tmp = tr_strdup_printf(\n                \"<p>Transmission received your request, but the hostname was unrecognized.</p>\"\n                \"<p>To fix this, choose one of the following options:\"\n                \"<ul>\"\n                \"<li>Enable password authentication, then any hostname is allowed.</li>\"\n                \"<li>Add the hostname you want to use to the whitelist in settings.</li>\"\n                \"</ul></p>\"\n                \"<p>If you're editing settings.json, see the 'rpc-host-whitelist' and 'rpc-host-whitelist-enabled' entries.</p>\"\n                \"<p>This requirement has been added to help prevent \"\n                \"<a href=\\\"https://en.wikipedia.org/wiki/DNS_rebinding\\\">DNS Rebinding</a> \"\n                \"attacks.</p>\");\n            send_simple_response(req, 421, tmp);\n            tr_free(tmp);\n        }\n        else if (!test_session_id(server, req))\n        {\n            char const* sessionId = get_current_session_id(server);\n            char* tmp = tr_strdup_printf(\n                \"<p>Your request had an invalid session-id header.</p>\"\n                \"<p>To fix this, follow these steps:\"\n                \"<ol><li> When reading a response, get its X-Transmission-Session-Id header and remember it\"\n                \"<li> Add the updated header to your outgoing requests\"\n                \"<li> When you get this 409 error message, resend your request with the updated header\"\n                \"</ol></p>\"\n                \"<p>This requirement has been added to help prevent \"\n                \"<a href=\\\"https://en.wikipedia.org/wiki/Cross-site_request_forgery\\\">CSRF</a> \"\n                \"attacks.</p>\"\n                \"<p><code>%s: %s</code></p>\",\n                TR_RPC_SESSION_ID_HEADER, sessionId);\n            evhttp_add_header(req->output_headers, TR_RPC_SESSION_ID_HEADER, sessionId);\n            send_simple_response(req, 409, tmp);\n            tr_free(tmp);\n        }\n\n#endif\n\n        else if (strncmp(req->uri + strlen(server->url), \"rpc\", 3) == 0)\n        {\n            handle_rpc(req, server);\n        }\n        else\n        {\n            send_simple_response(req, HTTP_NOTFOUND, req->uri);\n        }\n\n        tr_free(user);\n    }\n}",
  "abstract_func": "static void handle_request(struct evhttp_request* VAR_0, void* VAR_1)\n{\n    struct tr_rpc_server* VAR_2 = VAR_1;\n\n    if (VAR_0 != NULL && VAR_0->evcon != NULL)\n    {\n        char const* VAR_3;\n        char* VAR_4 = NULL;\n        char* VAR_5 = NULL;\n\n        evhttp_add_header(VAR_0->output_headers, \"Server\", VAR_6);\n\n        if (VAR_2->loginattempts == 100)\n        {\n            send_simple_response(VAR_0, 403, \"<p>Too many unsuccessful login attempts. Please restart transmission-daemon.</p>\");\n            return;\n        }\n\n        if (!isAddressAllowed(VAR_2, VAR_0->remote_host))\n        {\n            send_simple_response(VAR_0, 403,\n                \"<p>Unauthorized IP Address.</p>\"\n                \"<p>Either disable the IP address whitelist or add your address to it.</p>\"\n                \"<p>If you're editing settings.json, see the 'rpc-whitelist' and 'rpc-whitelist-enabled' entries.</p>\"\n                \"<p>If you're still using ACLs, use a whitelist instead. See the transmission-daemon manpage for details.</p>\");\n            return;\n        }\n\n        VAR_3 = evhttp_find_header(VAR_0->input_headers, \"Authorization\");\n\n        if (VAR_3 != NULL && evutil_ascii_strncasecmp(VAR_3, \"basic \", 6) == 0)\n        {\n            size_t VAR_7;\n            char* VAR_8 = tr_base64_decode_str(VAR_3 + 6, &VAR_7);\n\n            if (VAR_8 != NULL)\n            {\n                if (VAR_7 > 0 && (VAR_5 = strchr(VAR_8, ':')) != NULL)\n                {\n                    VAR_4 = VAR_8;\n                    *VAR_5++ = '\\0';\n                }\n                else\n                {\n                    tr_free(VAR_8);\n                }\n            }\n        }\n\n        if (VAR_2->isPasswordEnabled && (VAR_5 == NULL || VAR_4 == NULL || strcmp(VAR_2->username, VAR_4) != 0 ||\n            !tr_ssha1_matches(VAR_2->password, VAR_5)))\n        {\n            evhttp_add_header(VAR_0->output_headers, \"WWW-Authenticate\", \"Basic realm=\\\"\" VAR_6 \"\\\"\");\n            VAR_2->loginattempts++;\n            char* VAR_9 = tr_strdup_printf(\"<p>Unauthorized User. %d unsuccessful login attempts.</p>\", VAR_2->loginattempts);\n            send_simple_response(VAR_0, 401, VAR_9);\n            tr_free(VAR_9);\n            tr_free(VAR_4);\n            return;\n        }\n\n        VAR_2->loginattempts = 0;\n\n        if (strncmp(VAR_0->uri, VAR_2->url, strlen(VAR_2->url)) != 0)\n        {\n            char* VAR_10 = tr_strdup_printf(\"%sweb/\", VAR_2->url);\n            evhttp_add_header(VAR_0->output_headers, \"Location\", VAR_10);\n            send_simple_response(VAR_0, VAR_11, NULL);\n            tr_free(VAR_10);\n        }\n        else if (strncmp(VAR_0->uri + strlen(VAR_2->url), \"web/\", 4) == 0)\n        {\n            handle_web_client(VAR_0, VAR_2);\n        }\n        else if (strcmp(VAR_0->uri + strlen(VAR_2->url), \"upload\") == 0)\n        {\n            handle_upload(VAR_0, VAR_2);\n        }\n\n#ifdef VAR_12\n\n        else if (!isHostnameAllowed(server, req))\n        {\n            char* const VAR_13 = tr_strdup_printf(\n                \"<p>Transmission received your request, but the hostname was unrecognized.</p>\"\n                \"<p>To fix this, choose one of the following options:\"\n                \"<ul>\"\n                \"<li>Enable password authentication, then any hostname is allowed.</li>\"\n                \"<li>Add the hostname you want to use to the whitelist in settings.</li>\"\n                \"</ul></p>\"\n                \"<p>If you're editing settings.json, see the 'rpc-host-whitelist' and 'rpc-host-whitelist-enabled' entries.</p>\"\n                \"<p>This requirement has been added to help prevent \"\n                \"<a href=\\\"https://en.wikipedia.org/wiki/DNS_rebinding\\\">DNS Rebinding</a> \"\n                \"attacks.</p>\");\n            send_simple_response(req, 421, VAR_13);\n            tr_free(VAR_13);\n        }\n        else if (!test_session_id(server, req))\n        {\n            char const* VAR_14 = get_current_session_id(server);\n            char* VAR_13 = tr_strdup_printf(\n                \"<p>Your request had an invalid session-id header.</p>\"\n                \"<p>To fix this, follow these steps:\"\n                \"<ol><li> When reading a response, get its X-Transmission-Session-Id header and remember it\"\n                \"<li> Add the updated header to your outgoing requests\"\n                \"<li> When you get this 409 error message, resend your request with the updated header\"\n                \"</ol></p>\"\n                \"<p>This requirement has been added to help prevent \"\n                \"<a href=\\\"https://en.wikipedia.org/wiki/Cross-site_request_forgery\\\">CSRF</a> \"\n                \"attacks.</p>\"\n                \"<p><code>%s: %s</code></p>\",\n                VAR_15, VAR_14);\n            evhttp_add_header(req->output_headers, VAR_15, VAR_14);\n            send_simple_response(req, 409, VAR_13);\n            tr_free(VAR_13);\n        }\n\n#endif\n\n        else if (VAR_16(req->VAR_17 + strlen(server->url), \"rpc\", 3) == 0)\n        {\n            handle_rpc(req, server);\n        }\n        else\n        {\n            send_simple_response(req, VAR_18, req->uri);\n        }\n\n        tr_free(VAR_4);\n    }\n}",
  "func_graph_path": "transmission/cf7173df930cfa7ac1b1b0e9027c1deffd0b3c84/rpc-server.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -79,6 +79,22 @@\n \n #ifdef REQUIRE_SESSION_ID\n \n+        else if (!isHostnameAllowed(server, req))\n+        {\n+            char* const tmp = tr_strdup_printf(\n+                \"<p>Transmission received your request, but the hostname was unrecognized.</p>\"\n+                \"<p>To fix this, choose one of the following options:\"\n+                \"<ul>\"\n+                \"<li>Enable password authentication, then any hostname is allowed.</li>\"\n+                \"<li>Add the hostname you want to use to the whitelist in settings.</li>\"\n+                \"</ul></p>\"\n+                \"<p>If you're editing settings.json, see the 'rpc-host-whitelist' and 'rpc-host-whitelist-enabled' entries.</p>\"\n+                \"<p>This requirement has been added to help prevent \"\n+                \"<a href=\\\"https://en.wikipedia.org/wiki/DNS_rebinding\\\">DNS Rebinding</a> \"\n+                \"attacks.</p>\");\n+            send_simple_response(req, 421, tmp);\n+            tr_free(tmp);\n+        }\n         else if (!test_session_id(server, req))\n         {\n             char const* sessionId = get_current_session_id(server);\n@@ -90,7 +106,7 @@\n                 \"<li> When you get this 409 error message, resend your request with the updated header\"\n                 \"</ol></p>\"\n                 \"<p>This requirement has been added to help prevent \"\n-                \"<a href=\\\"http://en.wikipedia.org/wiki/Cross-site_request_forgery\\\">CSRF</a> \"\n+                \"<a href=\\\"https://en.wikipedia.org/wiki/Cross-site_request_forgery\\\">CSRF</a> \"\n                 \"attacks.</p>\"\n                 \"<p><code>%s: %s</code></p>\",\n                 TR_RPC_SESSION_ID_HEADER, sessionId);",
  "diff_line_info": {
    "deleted_lines": [
      "                \"<a href=\\\"http://en.wikipedia.org/wiki/Cross-site_request_forgery\\\">CSRF</a> \""
    ],
    "added_lines": [
      "        else if (!isHostnameAllowed(server, req))",
      "        {",
      "            char* const tmp = tr_strdup_printf(",
      "                \"<p>Transmission received your request, but the hostname was unrecognized.</p>\"",
      "                \"<p>To fix this, choose one of the following options:\"",
      "                \"<ul>\"",
      "                \"<li>Enable password authentication, then any hostname is allowed.</li>\"",
      "                \"<li>Add the hostname you want to use to the whitelist in settings.</li>\"",
      "                \"</ul></p>\"",
      "                \"<p>If you're editing settings.json, see the 'rpc-host-whitelist' and 'rpc-host-whitelist-enabled' entries.</p>\"",
      "                \"<p>This requirement has been added to help prevent \"",
      "                \"<a href=\\\"https://en.wikipedia.org/wiki/DNS_rebinding\\\">DNS Rebinding</a> \"",
      "                \"attacks.</p>\");",
      "            send_simple_response(req, 421, tmp);",
      "            tr_free(tmp);",
      "        }",
      "                \"<a href=\\\"https://en.wikipedia.org/wiki/Cross-site_request_forgery\\\">CSRF</a> \""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/transmission/transmission/pull/468",
  "description": {
    "pr_info": {
      "title": "CVE-2018-5702: Mitigate dns rebinding attacks against daemon",
      "number": 468
    },
    "comment": [
      "_This [issue](https://bugs.chromium.org/p/project-zero/issues/detail?id=1447) was originally reported to the private transmission security list on November 30th 2017_\r\n\r\nTransmission uses a client/server architecture, the user interface is the client and a daemon runs in the background managing the downloading, seeding, etc.\r\n\r\nClients interact with the daemon using JSON RPC requests to a web server listening on port 9091. The daemon will only accept requests from localhost by default, but it's common to configure NAS devices to accept remote clients.\r\n\r\n**Note:** _I regularly encounter users who don't accept that websites can access services on localhost or their intranet. These users understand that services bound to localhost are only accessible to software running on the local machine, and that their browser is running on the local machine - but somehow believe that accessing a website \"transfers\" execution somewhere else. It doesn't work like that, but this is a common source of confusion._\r\n\r\nA sample RPC session looks like this:\r\n\r\n```\r\n$ curl -sI http://localhost:9091/transmission/rpc\r\nHTTP/1.1 409 Conflict\r\nServer: Transmission\r\nX-Transmission-Session-Id: JL641xTn2h53UsN6bVa0kJjRBLA6oX1Ayl06AJwuhHvSgE6H\r\nDate: Wed, 29 Nov 2017 21:37:41 GMT\r\n```\r\n```\r\n$ curl -H 'X-Transmission-Session-Id: JL641xTn2h53UsN6bVa0kJjRBLA6oX1Ayl06AJwuhHvSgE6H'  -d '{\"method\":\"session-set\",\"arguments\":{\"download-dir\":\"/home/user\"}}' -si http://localhost:9091/transmission/rpc\r\nHTTP/1.1 200 OK\r\nServer: Transmission\r\nContent-Type: application/json; charset=UTF-8\r\nDate: Wed, 29 Nov 2017 21:38:57 GMT\r\nContent-Length: 36\r\n\r\n{\"arguments\":{},\"result\":\"success\"}\r\n```\r\n\r\nAs with all HTTP RPC schemes like this, any website can send requests to the daemon listening on localhost with `XMLHttpRequest()`, but the theory is they will be ignored because clients must prove they can read and set a specific header, `X-Transmission-Session-Id`.\r\n\r\nUnfortunately, this design doesn't work because of an attack called \"[DNS rebinding](https://en.wikipedia.org/wiki/DNS_rebinding)\". Any website can simply create a dns name that they are authorized to communicate with, and then make it resolve to localhost.\r\n\r\nThe attack works like this:\r\n\r\n1. A user visits `http://attacker.com`, which has an `<iframe>` to a subdomain the attacker controls.\r\n2. The attacker configures their DNS server to respond alternately with `127.0.0.1` and `123.123.123.123` (an address they control) with a very low TTL.\r\n3. When the browser resolves to `123.123.123.123`, they serve HTML that waits for the DNS entry to expire (or force it to expire by flooding the cache with lookups), then they have permission to read and set headers.\r\n\r\nI have a domain I use for testing dns rebinding called `rbndr.us`, you can use this page to generate hostnames (source code is [here](https://github.com/taviso/rbndr)):\r\n\r\n[https://lock.cmpxchg8b.com/rebinder.html](https://lock.cmpxchg8b.com/rebinder.html)\r\n\r\nHere I want to alternate between `127.0.0.1` and `199.241.29.227`, so I use `7f000001.c7f11de3.rbndr.us`:\r\n\r\n```\r\n$ host 7f000001.c7f11de3.rbndr.us\r\n7f000001.c7f11de3.rbndr.us has address 127.0.0.1\r\n$ host 7f000001.c7f11de3.rbndr.us\r\n7f000001.c7f11de3.rbndr.us has address 199.241.29.227\r\n$ host 7f000001.c7f11de3.rbndr.us\r\n7f000001.c7f11de3.rbndr.us has address 127.0.0.1\r\n```\r\n\r\nHere you can see the resolution alternates between the two addresses I want (note that depending on caching it might take a while to switch, the TTL is set to minimum but some servers round up).\r\n\r\nI just wait for the cached response to expire, and then POST commands to the server.\r\n\r\nExploitation is simple, you could set `script-torrent-done-enabled` and run any command, or set `download-dir` to `/home/user/` and then upload a torrent for `.bashrc`. \r\n\r\nHere is my (simple) demo, it's slow, but could be made very fast:\r\n\r\n[http://lock.cmpxchg8b.com/Asoquu3e.html](http://lock.cmpxchg8b.com/Asoquu3e.html)\r\n\r\nI've verified it works on Chrome and Firefox on Windows and Linux (I tried Fedora and Ubuntu), I expect other platforms and browsers are affected. There are screenshots of how the attack is supposed to look below.\r\n\r\nThis Pull Request mitigates this attack by requiring a host whitelist for requests that cannot be proven to be secure, but it can be disabled if a user does not want security. I think users might not be find it intuitive that servers on `localhost` or their intranet are exposed to the web, but hopefully they will read the warning.\r\n\r\nHere are some screenshots demonstrating the attack:\r\n\r\nBefore the attack begins, the Download directory is set correctly:\r\n![fedora 64-bit-2017-11-29-16-25-19](https://user-images.githubusercontent.com/123814/34840911-5b671e56-f6bb-11e7-8c11-4e37d7a860bf.png) \r\n\r\nHere is how the exploit looks:\r\n![fedora 64-bit-2017-11-29-16-25-27](https://user-images.githubusercontent.com/123814/34840966-8c6cacc8-f6bb-11e7-86a5-5dd1c2423b01.png)\r\n\r\nHere is the exploit running:\r\n![fedora 64-bit-2017-11-29-16-25-48](https://user-images.githubusercontent.com/123814/34841014-a9b3c1fe-f6bb-11e7-934e-0fbdd815f395.png)\r\n\r\nThe attack succeeds:\r\n![fedora 64-bit-2017-11-29-16-30-12](https://user-images.githubusercontent.com/123814/34841025-b4018ed4-f6bb-11e7-8757-818b1f676106.png)\r\n\r\nAnd the result:\r\n![fedora 64-bit-2017-11-29-16-30-26](https://user-images.githubusercontent.com/123814/34841040-bdbc760a-f6bb-11e7-8bf5-3dcaf2aea922.png)\r\n",
      "I naively adapted the patch so it applies to the 2.92 release (attached).\r\n[transmission-fix-dns-rebinding-vuln.patch.txt](https://github.com/transmission/transmission/files/1624431/transmission-fix-dns-rebinding-vuln.patch.txt)\r\n\r\nAs the CI server shows, with these changes the ```quark-test``` fails with ```\r\nexit status: 29```.\r\n",
      "Has a CVE been assigned for this?",
      "I believe I've fixed the quark-test fail, the list wasn't ordered correctly.\r\n\r\n(I broke the merge, but I think it's fixed now)",
      "@woodsb02 No, but I've just requested one and will update when received.",
      "I've updated the 2.92 patch with the latest changes from @taviso. The tests do pass now.\r\n[transmission-fix-dns-rebinding-vuln.patch.txt](https://github.com/transmission/transmission/files/1624507/transmission-fix-dns-rebinding-vuln.patch.txt)\r\n",
      "@taviso the demo works, unless you load it over https. Mixed content. \r\n@EFForg HTTPS Everywhere ftw!;]",
      "@taviso and @lfam thank you.  I've adapted lfam's second 2.92 patch set to the OpenBSD port of transmission, which I maintain.  Testing underway.",
      "Just a naïve question for my own edification - this basically uses `Host` for header checking-based protection instead of relying on `X-Transmission-Session-Id`, because `Host` is a Fetch Standard [forbidden header name](https://fetch.spec.whatwg.org/#forbidden-header-name), and so not vulnerable to the same exploit, is that correct?",
      "@smithfred Yes, correct.",
      "If transmission is configured such that the daemon/web server requires authorization (user ID, password) does this mitigate this attack?",
      "@wfiveash Yes, but be aware that it's possible to guess the credentials, so make them strong.",
      "@jggimi Okay, let us know if you notice any problems.\r\n\r\nRemember I described my adaptation as \"naive\". I only made sure the patch applies and Transmission still works.",
      "In my setup, the settings.json file is re-written each time transmission-daemon is started, based on the command line arguments passed to it.\r\n\r\nCan we please add new command line arguments to transmission-daemon set the rpc-host-whitelist-enabled and rpc-host-whitelist parameters?",
      "cve requested at Mitre.org",
      "CVE-2018-5702",
      "> I've verified it works on Chrome and Firefox on Windows and Linux \r\n\r\nDoes this mean the MacOS version of Transmission isn't vulnerable, or just that you haven't tested it?",
      "@rmbleeker The macOS version is vulnerable if you have enabled [remote access](https://trac.transmissionbt.com/wiki/OSX/DesktopRemote).",
      "@slokhorst only if that is enabled? ",
      "@slokhorst Isn't the same true for linux distributions? Isn't the remote access disabled by default?\r\nI'm currently using Transmission 2.84 on Ubuntu 16.04.",
      "@OznipSlaugh yes\r\n\r\n@yanosh-k I believe remote access is disabled by default in all clients (Qt, GTK+, macOS). I think it's only enabled by default in the daemon (obviously...)\r\n\r\nYou can check if your vulnerable by going to http://localhost:9091/ If you then see the Transmission web interface, you're vulnerable.",
      "But what if the local DNS server supports [DNS Rebinding Protections](https://doc.pfsense.org/index.php/DNS_Rebinding_Protections) and all DNS traffic is forced through the local DNS server with that protection enabled. It seems in such a case that this hack is not applicable.",
      "Has the fix been applied to 2.92 and published to ubuntu repos? If I'm on 2.92 I'm safe, or do I have to wait 2.93?",
      "The [Ubuntu package](https://packages.ubuntu.com/artful/transmission) has not been updated [since 31 July 2017](http://changelogs.ubuntu.com/changelogs/pool/main/t/transmission/transmission_2.92-2ubuntu3/changelog), so it doesn't include this patch. \r\n\r\nI don't know if 2.93 will be released any time soon, there haven't been any Transmission releases for two years.",
      "Ah damn... I'll need to install the ppa I assume. I remember having troubles with that though",
      "You could also email the Ubuntu maintainers.. I'm sure they want to patch this. Maybe they've missed the CVE.",
      "Done, looks like patch has been backported to `2.84-3ubuntu3.1` on ubuntu and the package is already available.",
      "Great work here guys. I'd greatly appreciate it if someone made a follow-up PR to add support for IPv6 localhost address to the implicitly allowed list ;)",
      "@mikedld that's already covered by the bit below \"localhost or ipaddress is always acceptable.\" right?\r\n`tr_addressIsIP(hostname)` should return true for both `127.0.0.1` and `::1`.",
      "@slokhorst Oh, my apologies. For some reason it occured to me that the check allows 127.0.0.1 specifically and not any IP address :( Sorry for the noise.",
      "Thinking of it more, the use of `strcspn` is not ideal there. Given \"Host: [::1]:9091\", it'll return \"[\" as a name to be checked, and this is not a valid IP address. Will fix this myself in a bit."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Output:**  \n- **Final Classification:** Security Vulnerability Fix  \n- **Confidence:** 0.95  \n\n**Step-by-Step Explanation:**\n\n1. **Input Analysis:**  \n   - The commit message clearly states the intention to \"mitigate dns rebinding attacks,\" indicating a security concern.  \n   - The vulnerability description explains a critical security flaw (DNS rebinding) allowing remote code execution, which is a severe security issue.  \n   - The code changes introduce checks for allowed hostnames, enforcing a whitelist, and notify users about security measures, directly addressing the vulnerability.\n\n2. **Consistency Check:**  \n   - The commit message aligns perfectly with the code modifications, which implement a security fix against DNS rebinding attacks.  \n\n3. **Purpose Evaluation:**  \n   - The code changes are aimed at preventing a specific exploit (DNS rebinding) by enforcing hostname validation, which is a core security measure.  \n\n4. **Security Vulnerability Assessment:**  \n   - The patch directly addresses an external exploit (DNS rebinding) that allows unauthorized access, making it a security vulnerability fix.  \n\n5. **Confidence Scoring:**  \n   - The information is clear, and the code changes are consistent with the security fix described. There's a high level of confidence in this classification.  \n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95"
}