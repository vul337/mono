{
  "cve_id": "CVE-2018-16426",
  "cwe_ids": [
    "CWE-674"
  ],
  "cvss_vector": "AV:L/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "OpenSC",
  "commit_msg": "iasecc: fixed unbound recursion",
  "commit_hash": "03628449b75a93787eb2359412a3980365dda49b",
  "git_url": "https://github.com/OpenSC/OpenSC/commit/03628449b75a93787eb2359412a3980365dda49b",
  "file_path": "src/libopensc/card-iasecc.c",
  "func_name": "iasecc_select_file",
  "func_before": "static int\niasecc_select_file(struct sc_card *card, const struct sc_path *path,\n\t\t struct sc_file **file_out)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_path lpath;\n\tint cache_valid = card->cache.valid, df_from_cache = 0;\n\tint rv, ii;\n\n\tLOG_FUNC_CALLED(ctx);\n\tmemcpy(&lpath, path, sizeof(struct sc_path));\n\tif (file_out)\n\t\t*file_out = NULL;\n\n\tsc_log(ctx,\n\t       \"iasecc_select_file(card:%p) path.len %\"SC_FORMAT_LEN_SIZE_T\"u; path.type %i; aid_len %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t       card, path->len, path->type, path->aid.len);\n\tsc_log(ctx, \"iasecc_select_file() path:%s\", sc_print_path(path));\n\n\tsc_print_cache(card);\n\tif (lpath.len >= 2 && lpath.value[0] == 0x3F && lpath.value[1] == 0x00)   {\n\t\tsc_log(ctx, \"EF.ATR(aid:'%s')\", card->ef_atr ? sc_dump_hex(card->ef_atr->aid.value, card->ef_atr->aid.len) : \"\");\n\n\t\trv = iasecc_select_mf(card, file_out);\n\t\tLOG_TEST_RET(ctx, rv, \"MF selection error\");\n\n\t\tif (lpath.len >= 2 && lpath.value[0] == 0x3F && lpath.value[1] == 0x00)\t   {\n\t\t\tmemmove(&lpath.value[0], &lpath.value[2], lpath.len - 2);\n\t\t\tlpath.len -=  2;\n\t\t}\n\t}\n\n\tif (lpath.aid.len)\t{\n\t\tstruct sc_file *file = NULL;\n\t\tstruct sc_path ppath;\n\n\t\tsc_log(ctx,\n\t\t       \"iasecc_select_file() select parent AID:%p/%\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t       lpath.aid.value, lpath.aid.len);\n\t\tsc_log(ctx, \"iasecc_select_file() select parent AID:%s\", sc_dump_hex(lpath.aid.value, lpath.aid.len));\n\t\tmemset(&ppath, 0, sizeof(ppath));\n\t\tmemcpy(ppath.value, lpath.aid.value, lpath.aid.len);\n\t\tppath.len = lpath.aid.len;\n\t\tppath.type = SC_PATH_TYPE_DF_NAME;\n\n\t\tif (card->cache.valid && card->cache.current_df\n\t\t\t\t&& card->cache.current_df->path.len == lpath.aid.len\n\t\t\t\t&& !memcmp(card->cache.current_df->path.value, lpath.aid.value, lpath.aid.len))\n\t\t\tdf_from_cache = 1;\n\n\t\trv = iasecc_select_file(card, &ppath, &file);\n\t\tLOG_TEST_RET(ctx, rv, \"select AID path failed\");\n\n\t\tif (file_out)\n\t\t\t*file_out = file;\n\t\telse\n\t\t   sc_file_free(file);\n\n\t\tif (lpath.type == SC_PATH_TYPE_DF_NAME)\n\t\t\tlpath.type = SC_PATH_TYPE_FROM_CURRENT;\n\t}\n\n\tif (lpath.type == SC_PATH_TYPE_PATH)\n\t\tlpath.type = SC_PATH_TYPE_FROM_CURRENT;\n\n\tif (!lpath.len)\n\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\n\tsc_print_cache(card);\n\n\tif (card->cache.valid && card->cache.current_df && lpath.type == SC_PATH_TYPE_DF_NAME\n\t\t\t&& card->cache.current_df->path.len == lpath.len\n\t\t\t&& !memcmp(card->cache.current_df->path.value, lpath.value, lpath.len))   {\n\t\tsc_log(ctx, \"returns current DF path %s\", sc_print_path(&card->cache.current_df->path));\n\t\tif (file_out)   {\n\t\t\tsc_file_free(*file_out);\n\t\t\tsc_file_dup(file_out, card->cache.current_df);\n\t\t}\n\n\t\tsc_print_cache(card);\n\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\t}\n\n\tdo   {\n\t\tstruct sc_apdu apdu;\n\t\tstruct sc_file *file = NULL;\n\t\tunsigned char rbuf[SC_MAX_APDU_BUFFER_SIZE];\n\t\tint pathlen = lpath.len;\n\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0xA4, 0x00, 0x00);\n\n\t\tif (card->type != SC_CARD_TYPE_IASECC_GEMALTO\n\t\t\t\t&& card->type != SC_CARD_TYPE_IASECC_OBERTHUR\n\t\t\t\t&& card->type != SC_CARD_TYPE_IASECC_SAGEM\n\t\t\t\t&& card->type != SC_CARD_TYPE_IASECC_AMOS\n\t\t\t\t&& card->type != SC_CARD_TYPE_IASECC_MI\n\t\t\t\t&& card->type != SC_CARD_TYPE_IASECC_MI2)\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"Unsupported card\");\n\n\t\tif (lpath.type == SC_PATH_TYPE_FILE_ID)   {\n\t\t\tapdu.p1 = 0x02;\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_OBERTHUR)   {\n\t\t\t\tapdu.p1 = 0x01;\n\t\t\t\tapdu.p2 = 0x04;\n\t\t\t}\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_AMOS)\n\t\t\t\tapdu.p2 = 0x04;\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_MI)\n\t\t\t\tapdu.p2 = 0x04;\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_MI2)\n\t\t\t\tapdu.p2 = 0x04;\n\t\t}\n\t\telse if (lpath.type == SC_PATH_TYPE_FROM_CURRENT)  {\n\t\t\tapdu.p1 = 0x09;\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_OBERTHUR)\n\t\t\t\tapdu.p2 = 0x04;\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_AMOS)\n\t\t\t\tapdu.p2 = 0x04;\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_MI)\n\t\t\t\tapdu.p2 = 0x04;\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_MI2)\n\t\t\t\tapdu.p2 = 0x04;\n\t\t}\n\t\telse if (lpath.type == SC_PATH_TYPE_PARENT)   {\n\t\t\tapdu.p1 = 0x03;\n\t\t\tpathlen = 0;\n\t\t\tapdu.cse = SC_APDU_CASE_2_SHORT;\n\t\t}\n\t\telse if (lpath.type == SC_PATH_TYPE_DF_NAME)   {\n\t\t\tapdu.p1 = 0x04;\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_AMOS)\n\t\t\t\tapdu.p2 = 0x04;\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_MI2)\n\t\t\t\tapdu.p2 = 0x04;\n\t\t}\n\t\telse   {\n\t\t\tsc_log(ctx, \"Invalid PATH type: 0x%X\", lpath.type);\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"iasecc_select_file() invalid PATH type\");\n\t\t}\n\n\t\tfor (ii=0; ii<2; ii++)   {\n\t\t\tapdu.lc = pathlen;\n\t\t\tapdu.data = lpath.value;\n\t\t\tapdu.datalen = pathlen;\n\n\t\t\tapdu.resp = rbuf;\n\t\t\tapdu.resplen = sizeof(rbuf);\n\t\t\tapdu.le = 256;\n\n\t\t\trv = sc_transmit_apdu(card, &apdu);\n\t\t\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\t\t\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\t\tif (rv == SC_ERROR_INCORRECT_PARAMETERS &&\n\t\t\t\t\tlpath.type == SC_PATH_TYPE_DF_NAME && apdu.p2 == 0x00)   {\n\t\t\t\tapdu.p2 = 0x0C;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (ii)   {\n\t\t\t\t/* 'SELECT AID' do not returned FCP. Try to emulate. */\n\t\t\t\tapdu.resplen = sizeof(rbuf);\n\t\t\t\trv = iasecc_emulate_fcp(ctx, &apdu);\n\t\t\t\tLOG_TEST_RET(ctx, rv, \"Failed to emulate DF FCP\");\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Using of the cached DF and EF can cause problems in the multi-thread environment.\n\t\t * FIXME: introduce config. option that invalidates this cache outside the locked card session,\n\t\t *        (or invent something else)\n\t\t */\n\t\tif (rv == SC_ERROR_FILE_NOT_FOUND && cache_valid && df_from_cache)   {\n\t\t\tsc_invalidate_cache(card);\n\t\t\tsc_log(ctx, \"iasecc_select_file() file not found, retry without cached DF\");\n\t\t\tif (file_out)   {\n\t\t\t\tsc_file_free(*file_out);\n\t\t\t\t*file_out = NULL;\n\t\t\t}\n\t\t\trv = iasecc_select_file(card, path, file_out);\n\t\t\tLOG_FUNC_RETURN(ctx, rv);\n\t\t}\n\n\t\tLOG_TEST_RET(ctx, rv, \"iasecc_select_file() check SW failed\");\n\n\t\tsc_log(ctx,\n\t\t       \"iasecc_select_file() apdu.resp %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t       apdu.resplen);\n\t\tif (apdu.resplen)   {\n\t\t\tsc_log(ctx, \"apdu.resp %02X:%02X:%02X...\", apdu.resp[0], apdu.resp[1], apdu.resp[2]);\n\n\t\t\tswitch (apdu.resp[0]) {\n\t\t\tcase 0x62:\n\t\t\tcase 0x6F:\n\t\t\t\tfile = sc_file_new();\n\t\t\t\tif (file == NULL)\n\t\t\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY);\n\t\t\t\tfile->path = lpath;\n\n\t\t\t\trv = iasecc_process_fci(card, file, apdu.resp, apdu.resplen);\n\t\t\t\tif (rv)\n\t\t\t\t\tLOG_FUNC_RETURN(ctx, rv);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t\t\t}\n\n\t\t\tsc_log(ctx, \"FileType %i\", file->type);\n\t\t\tif (file->type == SC_FILE_TYPE_DF)   {\n\t\t\t\tif (card->cache.valid)\n\t\t\t\t\tsc_file_free(card->cache.current_df);\n\t\t\t\tcard->cache.current_df = NULL;\n\n\n\t\t\t\tif (card->cache.valid)\n\t\t\t\t\tsc_file_free(card->cache.current_ef);\n\t\t\t\tcard->cache.current_ef = NULL;\n\n\t\t\t\tsc_file_dup(&card->cache.current_df, file);\n\t\t\t\tcard->cache.valid = 1;\n\t\t\t}\n\t\t\telse   {\n\t\t\t\tif (card->cache.valid)\n\t\t\t\t\tsc_file_free(card->cache.current_ef);\n\n\t\t\t\tcard->cache.current_ef = NULL;\n\n\t\t\t\tsc_file_dup(&card->cache.current_ef, file);\n\t\t\t}\n\n\t\t\tif (file_out)   {\n\t\t\t\tsc_file_free(*file_out);\n\t\t\t\t*file_out = file;\n\t\t\t}\n\t\t\telse   {\n\t\t\t\tsc_file_free(file);\n\t\t\t}\n\t\t}\n\t\telse if (lpath.type == SC_PATH_TYPE_DF_NAME)   {\n\t\t\tsc_file_free(card->cache.current_df);\n\t\t\tcard->cache.current_df = NULL;\n\n\t\t\tsc_file_free(card->cache.current_ef);\n\t\t\tcard->cache.current_ef = NULL;\n\n\t\t\tcard->cache.valid = 1;\n\t\t}\n\t} while(0);\n\n\tsc_print_cache(card);\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}",
  "abstract_func_before": "static int\niasecc_select_file(struct sc_card *VAR_0, const struct sc_path *VAR_1,\n\t\t struct sc_file **VAR_2)\n{\n\tstruct sc_context *VAR_3 = VAR_0->ctx;\n\tstruct sc_path VAR_4;\n\tint VAR_5 = VAR_0->cache.valid, VAR_6 = 0;\n\tint VAR_7, VAR_8;\n\n\tLOG_FUNC_CALLED(VAR_3);\n\tmemcpy(&VAR_4, VAR_1, sizeof(struct sc_path));\n\tif (VAR_2)\n\t\t*VAR_2 = NULL;\n\n\tsc_log(VAR_3,\n\t       \"iasecc_select_file(card:%p) path.len %\"VAR_9\"u; path.type %i; aid_len %\"VAR_9\"u\",\n\t       VAR_0, VAR_1->len, VAR_1->type, VAR_1->aid.len);\n\tsc_log(VAR_3, \"iasecc_select_file() path:%s\", sc_print_path(VAR_1));\n\n\tsc_print_cache(VAR_0);\n\tif (VAR_4.len >= 2 && VAR_4.value[0] == 0x3F && VAR_4.value[1] == 0x00)   {\n\t\tsc_log(VAR_3, \"EF.ATR(aid:'%s')\", VAR_0->ef_atr ? sc_dump_hex(VAR_0->ef_atr->aid.value, VAR_0->ef_atr->aid.len) : \"\");\n\n\t\tVAR_7 = iasecc_select_mf(VAR_0, VAR_2);\n\t\tLOG_TEST_RET(VAR_3, VAR_7, \"MF selection error\");\n\n\t\tif (VAR_4.len >= 2 && VAR_4.value[0] == 0x3F && VAR_4.value[1] == 0x00)\t   {\n\t\t\tmemmove(&VAR_4.value[0], &VAR_4.value[2], VAR_4.len - 2);\n\t\t\tVAR_4.len -=  2;\n\t\t}\n\t}\n\n\tif (VAR_4.aid.len)\t{\n\t\tstruct sc_file *VAR_10 = NULL;\n\t\tstruct sc_path VAR_11;\n\n\t\tsc_log(VAR_3,\n\t\t       \"iasecc_select_file() select parent AID:%p/%\"VAR_9\"u\",\n\t\t       VAR_4.aid.value, VAR_4.aid.len);\n\t\tsc_log(VAR_3, \"iasecc_select_file() select parent AID:%s\", sc_dump_hex(VAR_4.aid.value, VAR_4.aid.len));\n\t\tmemset(&VAR_11, 0, sizeof(VAR_11));\n\t\tmemcpy(VAR_11.value, VAR_4.aid.value, VAR_4.aid.len);\n\t\tVAR_11.len = VAR_4.aid.len;\n\t\tVAR_11.type = VAR_12;\n\n\t\tif (VAR_0->cache.valid && VAR_0->cache.current_df\n\t\t\t\t&& VAR_0->cache.current_df->path.len == VAR_4.aid.len\n\t\t\t\t&& !memcmp(VAR_0->cache.current_df->path.value, VAR_4.aid.value, VAR_4.aid.len))\n\t\t\tVAR_6 = 1;\n\n\t\tVAR_7 = iasecc_select_file(VAR_0, &VAR_11, &VAR_10);\n\t\tLOG_TEST_RET(VAR_3, VAR_7, \"select AID path failed\");\n\n\t\tif (VAR_2)\n\t\t\t*VAR_2 = VAR_10;\n\t\telse\n\t\t   sc_file_free(VAR_10);\n\n\t\tif (VAR_4.type == VAR_12)\n\t\t\tVAR_4.type = VAR_13;\n\t}\n\n\tif (VAR_4.type == VAR_14)\n\t\tVAR_4.type = VAR_13;\n\n\tif (!VAR_4.len)\n\t\tLOG_FUNC_RETURN(VAR_3, VAR_15);\n\n\tsc_print_cache(VAR_0);\n\n\tif (VAR_0->cache.valid && VAR_0->cache.current_df && VAR_4.type == VAR_12\n\t\t\t&& VAR_0->cache.current_df->path.len == VAR_4.len\n\t\t\t&& !memcmp(VAR_0->cache.current_df->path.value, VAR_4.value, VAR_4.len))   {\n\t\tsc_log(VAR_3, \"returns current DF path %s\", sc_print_path(&VAR_0->cache.current_df->path));\n\t\tif (VAR_2)   {\n\t\t\tsc_file_free(*VAR_2);\n\t\t\tsc_file_dup(VAR_2, VAR_0->cache.current_df);\n\t\t}\n\n\t\tsc_print_cache(VAR_0);\n\t\tLOG_FUNC_RETURN(VAR_3, VAR_15);\n\t}\n\n\tdo   {\n\t\tstruct sc_apdu VAR_16;\n\t\tstruct sc_file *VAR_10 = NULL;\n\t\tunsigned char VAR_17[VAR_18];\n\t\tint VAR_19 = VAR_4.len;\n\n\t\tsc_format_apdu(VAR_0, &VAR_16, VAR_20, 0xA4, 0x00, 0x00);\n\n\t\tif (VAR_0->type != VAR_21\n\t\t\t\t&& VAR_0->type != VAR_22\n\t\t\t\t&& VAR_0->type != VAR_23\n\t\t\t\t&& VAR_0->type != VAR_24\n\t\t\t\t&& VAR_0->type != VAR_25\n\t\t\t\t&& VAR_0->type != VAR_26)\n\t\t\tLOG_TEST_RET(VAR_3, VAR_27, \"Unsupported card\");\n\n\t\tif (VAR_4.type == VAR_28)   {\n\t\t\tVAR_16.p1 = 0x02;\n\t\t\tif (VAR_0->type == VAR_22)   {\n\t\t\t\tVAR_16.p1 = 0x01;\n\t\t\t\tVAR_16.p2 = 0x04;\n\t\t\t}\n\t\t\tif (VAR_0->type == VAR_24)\n\t\t\t\tVAR_16.p2 = 0x04;\n\t\t\tif (VAR_0->type == VAR_25)\n\t\t\t\tVAR_16.p2 = 0x04;\n\t\t\tif (VAR_0->type == VAR_26)\n\t\t\t\tVAR_16.p2 = 0x04;\n\t\t}\n\t\telse if (VAR_4.type == VAR_13)  {\n\t\t\tVAR_16.p1 = 0x09;\n\t\t\tif (VAR_0->type == VAR_22)\n\t\t\t\tVAR_16.p2 = 0x04;\n\t\t\tif (VAR_0->type == VAR_24)\n\t\t\t\tVAR_16.p2 = 0x04;\n\t\t\tif (VAR_0->type == VAR_25)\n\t\t\t\tVAR_16.p2 = 0x04;\n\t\t\tif (VAR_0->type == VAR_26)\n\t\t\t\tVAR_16.p2 = 0x04;\n\t\t}\n\t\telse if (VAR_4.type == VAR_29)   {\n\t\t\tVAR_16.p1 = 0x03;\n\t\t\tVAR_19 = 0;\n\t\t\tVAR_16.cse = VAR_30;\n\t\t}\n\t\telse if (VAR_4.type == VAR_12)   {\n\t\t\tVAR_16.p1 = 0x04;\n\t\t\tif (VAR_0->type == VAR_24)\n\t\t\t\tVAR_16.p2 = 0x04;\n\t\t\tif (VAR_0->type == VAR_26)\n\t\t\t\tVAR_16.p2 = 0x04;\n\t\t}\n\t\telse   {\n\t\t\tsc_log(VAR_3, \"Invalid PATH type: 0x%X\", VAR_4.type);\n\t\t\tLOG_TEST_RET(VAR_3, VAR_27, \"iasecc_select_file() invalid PATH type\");\n\t\t}\n\n\t\tfor (VAR_8=0; VAR_8<2; VAR_8++)   {\n\t\t\tVAR_16.lc = VAR_19;\n\t\t\tVAR_16.data = VAR_4.value;\n\t\t\tVAR_16.datalen = VAR_19;\n\n\t\t\tVAR_16.resp = VAR_17;\n\t\t\tVAR_16.resplen = sizeof(VAR_17);\n\t\t\tVAR_16.le = 256;\n\n\t\t\tVAR_7 = sc_transmit_apdu(VAR_0, &VAR_16);\n\t\t\tLOG_TEST_RET(VAR_3, VAR_7, \"APDU transmit failed\");\n\t\t\tVAR_7 = sc_check_sw(VAR_0, VAR_16.sw1, VAR_16.sw2);\n\t\t\tif (VAR_7 == VAR_31 &&\n\t\t\t\t\tVAR_4.type == VAR_12 && VAR_16.p2 == 0x00)   {\n\t\t\t\tVAR_16.p2 = 0x0C;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (VAR_8)   {\n\t\t\t\t/* COMMENT_0 */\n\t\t\t\tVAR_16.resplen = sizeof(VAR_17);\n\t\t\t\tVAR_7 = iasecc_emulate_fcp(VAR_3, &VAR_16);\n\t\t\t\tLOG_TEST_RET(VAR_3, VAR_7, \"Failed to emulate DF FCP\");\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\t/* COMMENT_1 */\n                                                                                      \n                                                                                                 \n                                      \n     \n\t\tif (VAR_7 == VAR_32 && VAR_5 && VAR_6)   {\n\t\t\tsc_invalidate_cache(VAR_0);\n\t\t\tsc_log(VAR_3, \"iasecc_select_file() file not found, retry without cached DF\");\n\t\t\tif (VAR_2)   {\n\t\t\t\tsc_file_free(*VAR_2);\n\t\t\t\t*VAR_2 = NULL;\n\t\t\t}\n\t\t\tVAR_7 = iasecc_select_file(VAR_0, VAR_1, VAR_2);\n\t\t\tLOG_FUNC_RETURN(VAR_3, VAR_7);\n\t\t}\n\n\t\tLOG_TEST_RET(VAR_3, VAR_7, \"iasecc_select_file() check SW failed\");\n\n\t\tsc_log(VAR_3,\n\t\t       \"iasecc_select_file() apdu.resp %\"VAR_9\"u\",\n\t\t       VAR_16.resplen);\n\t\tif (VAR_16.resplen)   {\n\t\t\tsc_log(VAR_3, \"apdu.resp %02X:%02X:%02X...\", VAR_16.resp[0], VAR_16.resp[1], VAR_16.resp[2]);\n\n\t\t\tswitch (VAR_16.resp[0]) {\n\t\t\tcase 0x62:\n\t\t\tcase 0x6F:\n\t\t\t\tVAR_10 = sc_file_new();\n\t\t\t\tif (VAR_10 == NULL)\n\t\t\t\t\tLOG_FUNC_RETURN(VAR_3, VAR_33);\n\t\t\t\tVAR_10->path = VAR_4;\n\n\t\t\t\tVAR_7 = iasecc_process_fci(VAR_0, VAR_10, VAR_16.resp, VAR_16.resplen);\n\t\t\t\tif (VAR_7)\n\t\t\t\t\tLOG_FUNC_RETURN(VAR_3, VAR_7);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tLOG_FUNC_RETURN(VAR_3, VAR_34);\n\t\t\t}\n\n\t\t\tsc_log(VAR_3, \"FileType %i\", VAR_10->type);\n\t\t\tif (VAR_10->type == VAR_35)   {\n\t\t\t\tif (VAR_0->cache.valid)\n\t\t\t\t\tsc_file_free(VAR_0->cache.current_df);\n\t\t\t\tVAR_0->cache.current_df = NULL;\n\n\n\t\t\t\tif (VAR_0->cache.valid)\n\t\t\t\t\tsc_file_free(VAR_0->cache.current_ef);\n\t\t\t\tVAR_0->cache.current_ef = NULL;\n\n\t\t\t\tsc_file_dup(&VAR_0->cache.current_df, VAR_10);\n\t\t\t\tVAR_0->cache.valid = 1;\n\t\t\t}\n\t\t\telse   {\n\t\t\t\tif (VAR_0->cache.valid)\n\t\t\t\t\tsc_file_free(VAR_0->cache.current_ef);\n\n\t\t\t\tVAR_0->cache.current_ef = NULL;\n\n\t\t\t\tsc_file_dup(&VAR_0->cache.current_ef, VAR_10);\n\t\t\t}\n\n\t\t\tif (VAR_2)   {\n\t\t\t\tsc_file_free(*VAR_2);\n\t\t\t\t*VAR_2 = VAR_10;\n\t\t\t}\n\t\t\telse   {\n\t\t\t\tsc_file_free(VAR_10);\n\t\t\t}\n\t\t}\n\t\telse if (VAR_4.type == VAR_12)   {\n\t\t\tsc_file_free(VAR_0->cache.current_df);\n\t\t\tVAR_0->cache.current_df = NULL;\n\n\t\t\tsc_file_free(VAR_0->cache.current_ef);\n\t\t\tVAR_0->cache.current_ef = NULL;\n\n\t\t\tVAR_0->cache.valid = 1;\n\t\t}\n\t} while(0);\n\n\tsc_print_cache(VAR_0);\n\tLOG_FUNC_RETURN(VAR_3, VAR_15);\n}",
  "func_graph_path_before": "OpenSC/03628449b75a93787eb2359412a3980365dda49b/card-iasecc.c/vul/before/0.json",
  "func": "static int\niasecc_select_file(struct sc_card *card, const struct sc_path *path,\n\t\t struct sc_file **file_out)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_path lpath;\n\tint cache_valid = card->cache.valid, df_from_cache = 0;\n\tint rv, ii;\n\n\tLOG_FUNC_CALLED(ctx);\n\tmemcpy(&lpath, path, sizeof(struct sc_path));\n\tif (file_out)\n\t\t*file_out = NULL;\n\n\tsc_log(ctx,\n\t       \"iasecc_select_file(card:%p) path.len %\"SC_FORMAT_LEN_SIZE_T\"u; path.type %i; aid_len %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t       card, path->len, path->type, path->aid.len);\n\tsc_log(ctx, \"iasecc_select_file() path:%s\", sc_print_path(path));\n\n\tsc_print_cache(card);\n\tif (path->type != SC_PATH_TYPE_DF_NAME\n\t\t\t&& lpath.len >= 2\n\t\t\t&& lpath.value[0] == 0x3F && lpath.value[1] == 0x00)   {\n\t\tsc_log(ctx, \"EF.ATR(aid:'%s')\", card->ef_atr ? sc_dump_hex(card->ef_atr->aid.value, card->ef_atr->aid.len) : \"\");\n\n\t\trv = iasecc_select_mf(card, file_out);\n\t\tLOG_TEST_RET(ctx, rv, \"MF selection error\");\n\n\t\tmemmove(&lpath.value[0], &lpath.value[2], lpath.len - 2);\n\t\tlpath.len -=  2;\n\t}\n\n\tif (lpath.aid.len)\t{\n\t\tstruct sc_file *file = NULL;\n\t\tstruct sc_path ppath;\n\n\t\tsc_log(ctx,\n\t\t       \"iasecc_select_file() select parent AID:%p/%\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t       lpath.aid.value, lpath.aid.len);\n\t\tsc_log(ctx, \"iasecc_select_file() select parent AID:%s\", sc_dump_hex(lpath.aid.value, lpath.aid.len));\n\t\tmemset(&ppath, 0, sizeof(ppath));\n\t\tmemcpy(ppath.value, lpath.aid.value, lpath.aid.len);\n\t\tppath.len = lpath.aid.len;\n\t\tppath.type = SC_PATH_TYPE_DF_NAME;\n\n\t\tif (card->cache.valid && card->cache.current_df\n\t\t\t\t&& card->cache.current_df->path.len == lpath.aid.len\n\t\t\t\t&& !memcmp(card->cache.current_df->path.value, lpath.aid.value, lpath.aid.len))\n\t\t\tdf_from_cache = 1;\n\n\t\trv = iasecc_select_file(card, &ppath, &file);\n\t\tLOG_TEST_RET(ctx, rv, \"select AID path failed\");\n\n\t\tif (file_out)\n\t\t\t*file_out = file;\n\t\telse\n\t\t   sc_file_free(file);\n\n\t\tif (lpath.type == SC_PATH_TYPE_DF_NAME)\n\t\t\tlpath.type = SC_PATH_TYPE_FROM_CURRENT;\n\t}\n\n\tif (lpath.type == SC_PATH_TYPE_PATH)\n\t\tlpath.type = SC_PATH_TYPE_FROM_CURRENT;\n\n\tif (!lpath.len)\n\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\n\tsc_print_cache(card);\n\n\tif (card->cache.valid && card->cache.current_df && lpath.type == SC_PATH_TYPE_DF_NAME\n\t\t\t&& card->cache.current_df->path.len == lpath.len\n\t\t\t&& !memcmp(card->cache.current_df->path.value, lpath.value, lpath.len))   {\n\t\tsc_log(ctx, \"returns current DF path %s\", sc_print_path(&card->cache.current_df->path));\n\t\tif (file_out)   {\n\t\t\tsc_file_free(*file_out);\n\t\t\tsc_file_dup(file_out, card->cache.current_df);\n\t\t}\n\n\t\tsc_print_cache(card);\n\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\t}\n\n\tdo   {\n\t\tstruct sc_apdu apdu;\n\t\tstruct sc_file *file = NULL;\n\t\tunsigned char rbuf[SC_MAX_APDU_BUFFER_SIZE];\n\t\tint pathlen = lpath.len;\n\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0xA4, 0x00, 0x00);\n\n\t\tif (card->type != SC_CARD_TYPE_IASECC_GEMALTO\n\t\t\t\t&& card->type != SC_CARD_TYPE_IASECC_OBERTHUR\n\t\t\t\t&& card->type != SC_CARD_TYPE_IASECC_SAGEM\n\t\t\t\t&& card->type != SC_CARD_TYPE_IASECC_AMOS\n\t\t\t\t&& card->type != SC_CARD_TYPE_IASECC_MI\n\t\t\t\t&& card->type != SC_CARD_TYPE_IASECC_MI2)\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"Unsupported card\");\n\n\t\tif (lpath.type == SC_PATH_TYPE_FILE_ID)   {\n\t\t\tapdu.p1 = 0x02;\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_OBERTHUR)   {\n\t\t\t\tapdu.p1 = 0x01;\n\t\t\t\tapdu.p2 = 0x04;\n\t\t\t}\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_AMOS)\n\t\t\t\tapdu.p2 = 0x04;\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_MI)\n\t\t\t\tapdu.p2 = 0x04;\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_MI2)\n\t\t\t\tapdu.p2 = 0x04;\n\t\t}\n\t\telse if (lpath.type == SC_PATH_TYPE_FROM_CURRENT)  {\n\t\t\tapdu.p1 = 0x09;\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_OBERTHUR)\n\t\t\t\tapdu.p2 = 0x04;\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_AMOS)\n\t\t\t\tapdu.p2 = 0x04;\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_MI)\n\t\t\t\tapdu.p2 = 0x04;\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_MI2)\n\t\t\t\tapdu.p2 = 0x04;\n\t\t}\n\t\telse if (lpath.type == SC_PATH_TYPE_PARENT)   {\n\t\t\tapdu.p1 = 0x03;\n\t\t\tpathlen = 0;\n\t\t\tapdu.cse = SC_APDU_CASE_2_SHORT;\n\t\t}\n\t\telse if (lpath.type == SC_PATH_TYPE_DF_NAME)   {\n\t\t\tapdu.p1 = 0x04;\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_AMOS)\n\t\t\t\tapdu.p2 = 0x04;\n\t\t\tif (card->type == SC_CARD_TYPE_IASECC_MI2)\n\t\t\t\tapdu.p2 = 0x04;\n\t\t}\n\t\telse   {\n\t\t\tsc_log(ctx, \"Invalid PATH type: 0x%X\", lpath.type);\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"iasecc_select_file() invalid PATH type\");\n\t\t}\n\n\t\tfor (ii=0; ii<2; ii++)   {\n\t\t\tapdu.lc = pathlen;\n\t\t\tapdu.data = lpath.value;\n\t\t\tapdu.datalen = pathlen;\n\n\t\t\tapdu.resp = rbuf;\n\t\t\tapdu.resplen = sizeof(rbuf);\n\t\t\tapdu.le = 256;\n\n\t\t\trv = sc_transmit_apdu(card, &apdu);\n\t\t\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\t\t\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\t\tif (rv == SC_ERROR_INCORRECT_PARAMETERS &&\n\t\t\t\t\tlpath.type == SC_PATH_TYPE_DF_NAME && apdu.p2 == 0x00)   {\n\t\t\t\tapdu.p2 = 0x0C;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (ii)   {\n\t\t\t\t/* 'SELECT AID' do not returned FCP. Try to emulate. */\n\t\t\t\tapdu.resplen = sizeof(rbuf);\n\t\t\t\trv = iasecc_emulate_fcp(ctx, &apdu);\n\t\t\t\tLOG_TEST_RET(ctx, rv, \"Failed to emulate DF FCP\");\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Using of the cached DF and EF can cause problems in the multi-thread environment.\n\t\t * FIXME: introduce config. option that invalidates this cache outside the locked card session,\n\t\t *        (or invent something else)\n\t\t */\n\t\tif (rv == SC_ERROR_FILE_NOT_FOUND && cache_valid && df_from_cache)   {\n\t\t\tsc_invalidate_cache(card);\n\t\t\tsc_log(ctx, \"iasecc_select_file() file not found, retry without cached DF\");\n\t\t\tif (file_out)   {\n\t\t\t\tsc_file_free(*file_out);\n\t\t\t\t*file_out = NULL;\n\t\t\t}\n\t\t\trv = iasecc_select_file(card, path, file_out);\n\t\t\tLOG_FUNC_RETURN(ctx, rv);\n\t\t}\n\n\t\tLOG_TEST_RET(ctx, rv, \"iasecc_select_file() check SW failed\");\n\n\t\tsc_log(ctx,\n\t\t       \"iasecc_select_file() apdu.resp %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t       apdu.resplen);\n\t\tif (apdu.resplen)   {\n\t\t\tsc_log(ctx, \"apdu.resp %02X:%02X:%02X...\", apdu.resp[0], apdu.resp[1], apdu.resp[2]);\n\n\t\t\tswitch (apdu.resp[0]) {\n\t\t\tcase 0x62:\n\t\t\tcase 0x6F:\n\t\t\t\tfile = sc_file_new();\n\t\t\t\tif (file == NULL)\n\t\t\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY);\n\t\t\t\tfile->path = lpath;\n\n\t\t\t\trv = iasecc_process_fci(card, file, apdu.resp, apdu.resplen);\n\t\t\t\tif (rv)\n\t\t\t\t\tLOG_FUNC_RETURN(ctx, rv);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t\t\t}\n\n\t\t\tsc_log(ctx, \"FileType %i\", file->type);\n\t\t\tif (file->type == SC_FILE_TYPE_DF)   {\n\t\t\t\tif (card->cache.valid)\n\t\t\t\t\tsc_file_free(card->cache.current_df);\n\t\t\t\tcard->cache.current_df = NULL;\n\n\n\t\t\t\tif (card->cache.valid)\n\t\t\t\t\tsc_file_free(card->cache.current_ef);\n\t\t\t\tcard->cache.current_ef = NULL;\n\n\t\t\t\tsc_file_dup(&card->cache.current_df, file);\n\t\t\t\tcard->cache.valid = 1;\n\t\t\t}\n\t\t\telse   {\n\t\t\t\tif (card->cache.valid)\n\t\t\t\t\tsc_file_free(card->cache.current_ef);\n\n\t\t\t\tcard->cache.current_ef = NULL;\n\n\t\t\t\tsc_file_dup(&card->cache.current_ef, file);\n\t\t\t}\n\n\t\t\tif (file_out)   {\n\t\t\t\tsc_file_free(*file_out);\n\t\t\t\t*file_out = file;\n\t\t\t}\n\t\t\telse   {\n\t\t\t\tsc_file_free(file);\n\t\t\t}\n\t\t}\n\t\telse if (lpath.type == SC_PATH_TYPE_DF_NAME)   {\n\t\t\tsc_file_free(card->cache.current_df);\n\t\t\tcard->cache.current_df = NULL;\n\n\t\t\tsc_file_free(card->cache.current_ef);\n\t\t\tcard->cache.current_ef = NULL;\n\n\t\t\tcard->cache.valid = 1;\n\t\t}\n\t} while(0);\n\n\tsc_print_cache(card);\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}",
  "abstract_func": "static int\niasecc_select_file(struct sc_card *VAR_0, const struct sc_path *VAR_1,\n\t\t struct sc_file **VAR_2)\n{\n\tstruct sc_context *VAR_3 = VAR_0->ctx;\n\tstruct sc_path VAR_4;\n\tint VAR_5 = VAR_0->cache.valid, VAR_6 = 0;\n\tint VAR_7, VAR_8;\n\n\tLOG_FUNC_CALLED(VAR_3);\n\tmemcpy(&VAR_4, VAR_1, sizeof(struct sc_path));\n\tif (VAR_2)\n\t\t*VAR_2 = NULL;\n\n\tsc_log(VAR_3,\n\t       \"iasecc_select_file(card:%p) path.len %\"VAR_9\"u; path.type %i; aid_len %\"VAR_9\"u\",\n\t       VAR_0, VAR_1->len, VAR_1->type, VAR_1->aid.len);\n\tsc_log(VAR_3, \"iasecc_select_file() path:%s\", sc_print_path(VAR_1));\n\n\tsc_print_cache(VAR_0);\n\tif (VAR_1->type != VAR_10\n\t\t\t&& VAR_4.len >= 2\n\t\t\t&& VAR_4.value[0] == 0x3F && VAR_4.value[1] == 0x00)   {\n\t\tsc_log(VAR_3, \"EF.ATR(aid:'%s')\", VAR_0->ef_atr ? sc_dump_hex(VAR_0->ef_atr->aid.value, VAR_0->ef_atr->aid.len) : \"\");\n\n\t\tVAR_7 = iasecc_select_mf(VAR_0, VAR_2);\n\t\tLOG_TEST_RET(VAR_3, VAR_7, \"MF selection error\");\n\n\t\tmemmove(&VAR_4.value[0], &VAR_4.value[2], VAR_4.len - 2);\n\t\tVAR_4.len -=  2;\n\t}\n\n\tif (VAR_4.aid.len)\t{\n\t\tstruct sc_file *VAR_11 = NULL;\n\t\tstruct sc_path VAR_12;\n\n\t\tsc_log(VAR_3,\n\t\t       \"iasecc_select_file() select parent AID:%p/%\"VAR_9\"u\",\n\t\t       VAR_4.aid.value, VAR_4.aid.len);\n\t\tsc_log(VAR_3, \"iasecc_select_file() select parent AID:%s\", sc_dump_hex(VAR_4.aid.value, VAR_4.aid.len));\n\t\tmemset(&VAR_12, 0, sizeof(VAR_12));\n\t\tmemcpy(VAR_12.value, VAR_4.aid.value, VAR_4.aid.len);\n\t\tVAR_12.len = VAR_4.aid.len;\n\t\tVAR_12.type = VAR_10;\n\n\t\tif (VAR_0->cache.valid && VAR_0->cache.current_df\n\t\t\t\t&& VAR_0->cache.current_df->path.len == VAR_4.aid.len\n\t\t\t\t&& !memcmp(VAR_0->cache.current_df->path.value, VAR_4.aid.value, VAR_4.aid.len))\n\t\t\tVAR_6 = 1;\n\n\t\tVAR_7 = iasecc_select_file(VAR_0, &VAR_12, &VAR_11);\n\t\tLOG_TEST_RET(VAR_3, VAR_7, \"select AID path failed\");\n\n\t\tif (VAR_2)\n\t\t\t*VAR_2 = VAR_11;\n\t\telse\n\t\t   sc_file_free(VAR_11);\n\n\t\tif (VAR_4.type == VAR_10)\n\t\t\tVAR_4.type = VAR_13;\n\t}\n\n\tif (VAR_4.type == VAR_14)\n\t\tVAR_4.type = VAR_13;\n\n\tif (!VAR_4.len)\n\t\tLOG_FUNC_RETURN(VAR_3, VAR_15);\n\n\tsc_print_cache(VAR_0);\n\n\tif (VAR_0->cache.valid && VAR_0->cache.current_df && VAR_4.type == VAR_10\n\t\t\t&& VAR_0->cache.current_df->path.len == VAR_4.len\n\t\t\t&& !memcmp(VAR_0->cache.current_df->path.value, VAR_4.value, VAR_4.len))   {\n\t\tsc_log(VAR_3, \"returns current DF path %s\", sc_print_path(&VAR_0->cache.current_df->path));\n\t\tif (VAR_2)   {\n\t\t\tsc_file_free(*VAR_2);\n\t\t\tsc_file_dup(VAR_2, VAR_0->cache.current_df);\n\t\t}\n\n\t\tsc_print_cache(VAR_0);\n\t\tLOG_FUNC_RETURN(VAR_3, VAR_15);\n\t}\n\n\tdo   {\n\t\tstruct sc_apdu VAR_16;\n\t\tstruct sc_file *VAR_11 = NULL;\n\t\tunsigned char VAR_17[VAR_18];\n\t\tint VAR_19 = VAR_4.len;\n\n\t\tsc_format_apdu(VAR_0, &VAR_16, VAR_20, 0xA4, 0x00, 0x00);\n\n\t\tif (VAR_0->type != VAR_21\n\t\t\t\t&& VAR_0->type != VAR_22\n\t\t\t\t&& VAR_0->type != VAR_23\n\t\t\t\t&& VAR_0->type != VAR_24\n\t\t\t\t&& VAR_0->type != VAR_25\n\t\t\t\t&& VAR_0->type != VAR_26)\n\t\t\tLOG_TEST_RET(VAR_3, VAR_27, \"Unsupported card\");\n\n\t\tif (VAR_4.type == VAR_28)   {\n\t\t\tVAR_16.p1 = 0x02;\n\t\t\tif (VAR_0->type == VAR_22)   {\n\t\t\t\tVAR_16.p1 = 0x01;\n\t\t\t\tVAR_16.p2 = 0x04;\n\t\t\t}\n\t\t\tif (VAR_0->type == VAR_24)\n\t\t\t\tVAR_16.p2 = 0x04;\n\t\t\tif (VAR_0->type == VAR_25)\n\t\t\t\tVAR_16.p2 = 0x04;\n\t\t\tif (VAR_0->type == VAR_26)\n\t\t\t\tVAR_16.p2 = 0x04;\n\t\t}\n\t\telse if (VAR_4.type == VAR_13)  {\n\t\t\tVAR_16.p1 = 0x09;\n\t\t\tif (VAR_0->type == VAR_22)\n\t\t\t\tVAR_16.p2 = 0x04;\n\t\t\tif (VAR_0->type == VAR_24)\n\t\t\t\tVAR_16.p2 = 0x04;\n\t\t\tif (VAR_0->type == VAR_25)\n\t\t\t\tVAR_16.p2 = 0x04;\n\t\t\tif (VAR_0->type == VAR_26)\n\t\t\t\tVAR_16.p2 = 0x04;\n\t\t}\n\t\telse if (VAR_4.type == VAR_29)   {\n\t\t\tVAR_16.p1 = 0x03;\n\t\t\tVAR_19 = 0;\n\t\t\tVAR_16.cse = VAR_30;\n\t\t}\n\t\telse if (VAR_4.type == VAR_10)   {\n\t\t\tVAR_16.p1 = 0x04;\n\t\t\tif (VAR_0->type == VAR_24)\n\t\t\t\tVAR_16.p2 = 0x04;\n\t\t\tif (VAR_0->type == VAR_26)\n\t\t\t\tVAR_16.p2 = 0x04;\n\t\t}\n\t\telse   {\n\t\t\tsc_log(VAR_3, \"Invalid PATH type: 0x%X\", VAR_4.type);\n\t\t\tLOG_TEST_RET(VAR_3, VAR_27, \"iasecc_select_file() invalid PATH type\");\n\t\t}\n\n\t\tfor (VAR_8=0; VAR_8<2; VAR_8++)   {\n\t\t\tVAR_16.lc = VAR_19;\n\t\t\tVAR_16.data = VAR_4.value;\n\t\t\tVAR_16.datalen = VAR_19;\n\n\t\t\tVAR_16.resp = VAR_17;\n\t\t\tVAR_16.resplen = sizeof(VAR_17);\n\t\t\tVAR_16.le = 256;\n\n\t\t\tVAR_7 = sc_transmit_apdu(VAR_0, &VAR_16);\n\t\t\tLOG_TEST_RET(VAR_3, VAR_7, \"APDU transmit failed\");\n\t\t\tVAR_7 = sc_check_sw(VAR_0, VAR_16.sw1, VAR_16.sw2);\n\t\t\tif (VAR_7 == VAR_31 &&\n\t\t\t\t\tVAR_4.type == VAR_10 && VAR_16.p2 == 0x00)   {\n\t\t\t\tVAR_16.p2 = 0x0C;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (VAR_8)   {\n\t\t\t\t/* COMMENT_0 */\n\t\t\t\tVAR_16.resplen = sizeof(VAR_17);\n\t\t\t\tVAR_7 = iasecc_emulate_fcp(VAR_3, &VAR_16);\n\t\t\t\tLOG_TEST_RET(VAR_3, VAR_7, \"Failed to emulate DF FCP\");\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\t/* COMMENT_1 */\n                                                                                      \n                                                                                                 \n                                      \n     \n\t\tif (VAR_7 == VAR_32 && VAR_5 && VAR_6)   {\n\t\t\tsc_invalidate_cache(VAR_0);\n\t\t\tsc_log(VAR_3, \"iasecc_select_file() file not found, retry without cached DF\");\n\t\t\tif (VAR_2)   {\n\t\t\t\tsc_file_free(*VAR_2);\n\t\t\t\t*VAR_2 = NULL;\n\t\t\t}\n\t\t\tVAR_7 = iasecc_select_file(VAR_0, VAR_1, VAR_2);\n\t\t\tLOG_FUNC_RETURN(VAR_3, VAR_7);\n\t\t}\n\n\t\tLOG_TEST_RET(VAR_3, VAR_7, \"iasecc_select_file() check SW failed\");\n\n\t\tsc_log(VAR_3,\n\t\t       \"iasecc_select_file() apdu.resp %\"VAR_9\"u\",\n\t\t       VAR_16.resplen);\n\t\tif (VAR_16.resplen)   {\n\t\t\tsc_log(VAR_3, \"apdu.resp %02X:%02X:%02X...\", VAR_16.resp[0], VAR_16.resp[1], VAR_16.resp[2]);\n\n\t\t\tswitch (VAR_16.resp[0]) {\n\t\t\tcase 0x62:\n\t\t\tcase 0x6F:\n\t\t\t\tVAR_11 = sc_file_new();\n\t\t\t\tif (VAR_11 == NULL)\n\t\t\t\t\tLOG_FUNC_RETURN(VAR_3, VAR_33);\n\t\t\t\tVAR_11->path = VAR_4;\n\n\t\t\t\tVAR_7 = iasecc_process_fci(VAR_0, VAR_11, VAR_16.resp, VAR_16.resplen);\n\t\t\t\tif (VAR_7)\n\t\t\t\t\tLOG_FUNC_RETURN(VAR_3, VAR_7);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tLOG_FUNC_RETURN(VAR_3, VAR_34);\n\t\t\t}\n\n\t\t\tsc_log(VAR_3, \"FileType %i\", VAR_11->type);\n\t\t\tif (VAR_11->type == VAR_35)   {\n\t\t\t\tif (VAR_0->cache.valid)\n\t\t\t\t\tsc_file_free(VAR_0->cache.current_df);\n\t\t\t\tVAR_0->cache.current_df = NULL;\n\n\n\t\t\t\tif (VAR_0->cache.valid)\n\t\t\t\t\tsc_file_free(VAR_0->cache.current_ef);\n\t\t\t\tVAR_0->cache.current_ef = NULL;\n\n\t\t\t\tsc_file_dup(&VAR_0->cache.current_df, VAR_11);\n\t\t\t\tVAR_0->cache.valid = 1;\n\t\t\t}\n\t\t\telse   {\n\t\t\t\tif (VAR_0->cache.valid)\n\t\t\t\t\tsc_file_free(VAR_0->cache.current_ef);\n\n\t\t\t\tVAR_0->cache.current_ef = NULL;\n\n\t\t\t\tsc_file_dup(&VAR_0->cache.current_ef, VAR_11);\n\t\t\t}\n\n\t\t\tif (VAR_2)   {\n\t\t\t\tsc_file_free(*VAR_2);\n\t\t\t\t*VAR_2 = VAR_11;\n\t\t\t}\n\t\t\telse   {\n\t\t\t\tsc_file_free(VAR_11);\n\t\t\t}\n\t\t}\n\t\telse if (VAR_4.type == VAR_10)   {\n\t\t\tsc_file_free(VAR_0->cache.current_df);\n\t\t\tVAR_0->cache.current_df = NULL;\n\n\t\t\tsc_file_free(VAR_0->cache.current_ef);\n\t\t\tVAR_0->cache.current_ef = NULL;\n\n\t\t\tVAR_0->cache.valid = 1;\n\t\t}\n\t} while(0);\n\n\tsc_print_cache(VAR_0);\n\tLOG_FUNC_RETURN(VAR_3, VAR_15);\n}",
  "func_graph_path": "OpenSC/03628449b75a93787eb2359412a3980365dda49b/card-iasecc.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -18,16 +18,16 @@\n \tsc_log(ctx, \"iasecc_select_file() path:%s\", sc_print_path(path));\n \n \tsc_print_cache(card);\n-\tif (lpath.len >= 2 && lpath.value[0] == 0x3F && lpath.value[1] == 0x00)   {\n+\tif (path->type != SC_PATH_TYPE_DF_NAME\n+\t\t\t&& lpath.len >= 2\n+\t\t\t&& lpath.value[0] == 0x3F && lpath.value[1] == 0x00)   {\n \t\tsc_log(ctx, \"EF.ATR(aid:'%s')\", card->ef_atr ? sc_dump_hex(card->ef_atr->aid.value, card->ef_atr->aid.len) : \"\");\n \n \t\trv = iasecc_select_mf(card, file_out);\n \t\tLOG_TEST_RET(ctx, rv, \"MF selection error\");\n \n-\t\tif (lpath.len >= 2 && lpath.value[0] == 0x3F && lpath.value[1] == 0x00)\t   {\n-\t\t\tmemmove(&lpath.value[0], &lpath.value[2], lpath.len - 2);\n-\t\t\tlpath.len -=  2;\n-\t\t}\n+\t\tmemmove(&lpath.value[0], &lpath.value[2], lpath.len - 2);\n+\t\tlpath.len -=  2;\n \t}\n \n \tif (lpath.aid.len)\t{",
  "diff_line_info": {
    "deleted_lines": [
      "\tif (lpath.len >= 2 && lpath.value[0] == 0x3F && lpath.value[1] == 0x00)   {",
      "\t\tif (lpath.len >= 2 && lpath.value[0] == 0x3F && lpath.value[1] == 0x00)\t   {",
      "\t\t\tmemmove(&lpath.value[0], &lpath.value[2], lpath.len - 2);",
      "\t\t\tlpath.len -=  2;",
      "\t\t}"
    ],
    "added_lines": [
      "\tif (path->type != SC_PATH_TYPE_DF_NAME",
      "\t\t\t&& lpath.len >= 2",
      "\t\t\t&& lpath.value[0] == 0x3F && lpath.value[1] == 0x00)   {",
      "\t\tmemmove(&lpath.value[0], &lpath.value[2], lpath.len - 2);",
      "\t\tlpath.len -=  2;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/OpenSC/OpenSC/pull/1447",
  "description": {
    "pr_info": {
      "title": "Security issues identified by fuzzing",
      "number": 1447
    },
    "comment": [
      "This PR merges changes addressing issues identified by fuzzing OpenSC driver by Eric Sesterhenn. The separate commits are authored mostly by @frankmorgner, @dengert, Eric and me.\r\n\r\nFor more information, see the blog post:\r\n\r\nhttps://www.x41-dsec.de/lab/blog/smartcards/\r\n\r\nThe changes were tested to ensure they still work for the cards we have, but testing with more cards would be always appreciated.\r\n\r\n##### Checklist\r\n<!-- Remove items that do not apply. For completed items, change [ ] to [x]. -->\r\n- [X] PKCS#11 module is tested\r\n- [ ] Windows minidriver is tested\r\n- [ ] macOS tokend is tested\r\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "Final Classification: Security Vulnerability Fix; Confidence: 0.9\n\n**Step-by-Step Explanation:**\n\n1. **Input Analysis:** The commit message refers to fixing \"unbound recursion,\" which is a potential security issue. The vulnerability description mentions fuzzing, often used to find security bugs.\n\n2. **Consistency Check:** The code diff adjusts path handling, likely to prevent recursion issues, aligning with the commit message.\n\n3. **Purpose Evaluation:** The code changes modify how paths are processed, suggesting a fix for a bug that could cause security issues.\n\n4. **Security Assessment:** Fuzzing typically targets security flaws; the code addresses recursion, a known exploit vector, indicating a security fix.\n\n5. **Confidence Scoring:** The connection between the code change and security is strong, but without explicit security keywords, confidence is high but not absolute.\n\n**Final Answer:**  \n**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.9"
}