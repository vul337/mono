{
  "cve_id": "CVE-2019-3817",
  "cwe_ids": [
    "CWE-416"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "rpm-software-management/libcomps",
  "commit_msg": "Fix UAF in comps_objmrtree_unite function\n\nThe added field is not used at all in many places and it is probably the\nleft-over of some copy-paste.",
  "commit_hash": "e3a5d056633677959ad924a51758876d415e7046",
  "git_url": "https://github.com/rpm-software-management/libcomps/commit/e3a5d056633677959ad924a51758876d415e7046",
  "file_path": "libcomps/src/comps_radix.c",
  "func_name": "comps_rtree_unite",
  "func_before": "void comps_rtree_unite(COMPS_RTree *rt1, COMPS_RTree *rt2) {\n    COMPS_HSList *tmplist, *tmp_subnodes;\n    COMPS_HSListItem *it;\n    struct Pair {\n        COMPS_HSList * subnodes;\n        char * key;\n        char added;\n    } *pair, *parent_pair;\n\n    pair = malloc(sizeof(struct Pair));\n    pair->subnodes = rt2->subnodes;\n    pair->key = NULL;\n\n    tmplist = comps_hslist_create();\n    comps_hslist_init(tmplist, NULL, NULL, &free);\n    comps_hslist_append(tmplist, pair, 0);\n\n    while (tmplist->first != NULL) {\n        it = tmplist->first;\n        comps_hslist_remove(tmplist, tmplist->first);\n        tmp_subnodes = ((struct Pair*)it->data)->subnodes;\n        parent_pair = (struct Pair*) it->data;\n        free(it);\n\n        for (it = tmp_subnodes->first; it != NULL; it=it->next) {\n            pair = malloc(sizeof(struct Pair));\n            pair->subnodes = ((COMPS_RTreeData*)it->data)->subnodes;\n\n            if (parent_pair->key != NULL) {\n                pair->key = malloc(sizeof(char)\n                               * (strlen(((COMPS_RTreeData*)it->data)->key)\n                               + strlen(parent_pair->key) + 1));\n                memcpy(pair->key, parent_pair->key,\n                       sizeof(char) * strlen(parent_pair->key));\n                memcpy(pair->key + strlen(parent_pair->key),\n                       ((COMPS_RTreeData*)it->data)->key,\n                       sizeof(char)*(strlen(((COMPS_RTreeData*)it->data)->key)+1));\n            } else {\n                pair->key = malloc(sizeof(char)*\n                                (strlen(((COMPS_RTreeData*)it->data)->key) +1));\n                memcpy(pair->key, ((COMPS_RTreeData*)it->data)->key,\n                       sizeof(char)*(strlen(((COMPS_RTreeData*)it->data)->key)+1));\n            }\n            /* current node has data */\n            if (((COMPS_RTreeData*)it->data)->data != NULL) {\n                    comps_rtree_set(rt1,\n                                    pair->key,\n                        rt2->data_cloner(((COMPS_RTreeData*)it->data)->data));\n            }\n            if (((COMPS_RTreeData*)it->data)->subnodes->first) {\n                comps_hslist_append(tmplist, pair, 0);\n            } else {\n                free(pair->key);\n                free(pair);\n            }\n        }\n        free(parent_pair->key);\n        free(parent_pair);\n    }\n    comps_hslist_destroy(&tmplist);\n}",
  "abstract_func_before": "void comps_rtree_unite(COMPS_RTree *VAR_0, COMPS_RTree *VAR_1) {\n    COMPS_HSList *VAR_2, *VAR_3;\n    COMPS_HSListItem *VAR_4;\n    struct Pair {\n        COMPS_HSList * subnodes;\n        char * key;\n        char added;\n    } *VAR_5, *VAR_6;\n\n    VAR_5 = malloc(sizeof(struct Pair));\n    VAR_5->subnodes = VAR_1->subnodes;\n    VAR_5->key = NULL;\n\n    VAR_2 = comps_hslist_create();\n    comps_hslist_init(VAR_2, NULL, NULL, &VAR_7);\n    comps_hslist_append(VAR_2, VAR_5, 0);\n\n    while (VAR_2->first != NULL) {\n        VAR_4 = VAR_2->first;\n        comps_hslist_remove(VAR_2, VAR_2->first);\n        VAR_3 = ((struct Pair*)VAR_4->data)->subnodes;\n        VAR_6 = (struct Pair*) VAR_4->data;\n        VAR_7(VAR_4);\n\n        for (VAR_4 = VAR_3->first; VAR_4 != NULL; VAR_4=VAR_4->next) {\n            VAR_5 = malloc(sizeof(struct Pair));\n            VAR_5->subnodes = ((COMPS_RTreeData*)VAR_4->data)->subnodes;\n\n            if (VAR_6->key != NULL) {\n                VAR_5->key = malloc(sizeof(char)\n                               * (strlen(((COMPS_RTreeData*)VAR_4->data)->key)\n                               + strlen(VAR_6->key) + 1));\n                memcpy(VAR_5->key, VAR_6->key,\n                       sizeof(char) * strlen(VAR_6->key));\n                memcpy(VAR_5->key + strlen(VAR_6->key),\n                       ((COMPS_RTreeData*)VAR_4->data)->key,\n                       sizeof(char)*(strlen(((COMPS_RTreeData*)VAR_4->data)->key)+1));\n            } else {\n                VAR_5->key = malloc(sizeof(char)*\n                                (strlen(((COMPS_RTreeData*)VAR_4->data)->key) +1));\n                memcpy(VAR_5->key, ((COMPS_RTreeData*)VAR_4->data)->key,\n                       sizeof(char)*(strlen(((COMPS_RTreeData*)VAR_4->data)->key)+1));\n            }\n            /* COMMENT_0 */\n            if (((COMPS_RTreeData*)VAR_4->data)->data != NULL) {\n                    comps_rtree_set(VAR_0,\n                                    VAR_5->key,\n                        VAR_1->data_cloner(((COMPS_RTreeData*)VAR_4->data)->data));\n            }\n            if (((COMPS_RTreeData*)VAR_4->data)->subnodes->first) {\n                comps_hslist_append(VAR_2, VAR_5, 0);\n            } else {\n                VAR_7(VAR_5->key);\n                VAR_7(VAR_5);\n            }\n        }\n        VAR_7(VAR_6->key);\n        VAR_7(VAR_6);\n    }\n    comps_hslist_destroy(&VAR_2);\n}",
  "func_graph_path_before": "rpm-software-management/libcomps/e3a5d056633677959ad924a51758876d415e7046/comps_radix.c/vul/before/0.json",
  "func": "void comps_rtree_unite(COMPS_RTree *rt1, COMPS_RTree *rt2) {\n    COMPS_HSList *tmplist, *tmp_subnodes;\n    COMPS_HSListItem *it;\n    struct Pair {\n        COMPS_HSList * subnodes;\n        char * key;\n    } *pair, *parent_pair;\n\n    pair = malloc(sizeof(struct Pair));\n    pair->subnodes = rt2->subnodes;\n    pair->key = NULL;\n\n    tmplist = comps_hslist_create();\n    comps_hslist_init(tmplist, NULL, NULL, &free);\n    comps_hslist_append(tmplist, pair, 0);\n\n    while (tmplist->first != NULL) {\n        it = tmplist->first;\n        comps_hslist_remove(tmplist, tmplist->first);\n        tmp_subnodes = ((struct Pair*)it->data)->subnodes;\n        parent_pair = (struct Pair*) it->data;\n        free(it);\n\n        for (it = tmp_subnodes->first; it != NULL; it=it->next) {\n            pair = malloc(sizeof(struct Pair));\n            pair->subnodes = ((COMPS_RTreeData*)it->data)->subnodes;\n\n            if (parent_pair->key != NULL) {\n                pair->key = malloc(sizeof(char)\n                               * (strlen(((COMPS_RTreeData*)it->data)->key)\n                               + strlen(parent_pair->key) + 1));\n                memcpy(pair->key, parent_pair->key,\n                       sizeof(char) * strlen(parent_pair->key));\n                memcpy(pair->key + strlen(parent_pair->key),\n                       ((COMPS_RTreeData*)it->data)->key,\n                       sizeof(char)*(strlen(((COMPS_RTreeData*)it->data)->key)+1));\n            } else {\n                pair->key = malloc(sizeof(char)*\n                                (strlen(((COMPS_RTreeData*)it->data)->key) +1));\n                memcpy(pair->key, ((COMPS_RTreeData*)it->data)->key,\n                       sizeof(char)*(strlen(((COMPS_RTreeData*)it->data)->key)+1));\n            }\n            /* current node has data */\n            if (((COMPS_RTreeData*)it->data)->data != NULL) {\n                    comps_rtree_set(rt1,\n                                    pair->key,\n                        rt2->data_cloner(((COMPS_RTreeData*)it->data)->data));\n            }\n            if (((COMPS_RTreeData*)it->data)->subnodes->first) {\n                comps_hslist_append(tmplist, pair, 0);\n            } else {\n                free(pair->key);\n                free(pair);\n            }\n        }\n        free(parent_pair->key);\n        free(parent_pair);\n    }\n    comps_hslist_destroy(&tmplist);\n}",
  "abstract_func": "void comps_rtree_unite(COMPS_RTree *VAR_0, COMPS_RTree *VAR_1) {\n    COMPS_HSList *VAR_2, *VAR_3;\n    COMPS_HSListItem *VAR_4;\n    struct Pair {\n        COMPS_HSList * subnodes;\n        char * key;\n    } *VAR_5, *VAR_6;\n\n    VAR_5 = malloc(sizeof(struct Pair));\n    VAR_5->subnodes = VAR_1->subnodes;\n    VAR_5->key = NULL;\n\n    VAR_2 = comps_hslist_create();\n    comps_hslist_init(VAR_2, NULL, NULL, &VAR_7);\n    comps_hslist_append(VAR_2, VAR_5, 0);\n\n    while (VAR_2->first != NULL) {\n        VAR_4 = VAR_2->first;\n        comps_hslist_remove(VAR_2, VAR_2->first);\n        VAR_3 = ((struct Pair*)VAR_4->data)->subnodes;\n        VAR_6 = (struct Pair*) VAR_4->data;\n        VAR_7(VAR_4);\n\n        for (VAR_4 = VAR_3->first; VAR_4 != NULL; VAR_4=VAR_4->next) {\n            VAR_5 = malloc(sizeof(struct Pair));\n            VAR_5->subnodes = ((COMPS_RTreeData*)VAR_4->data)->subnodes;\n\n            if (VAR_6->key != NULL) {\n                VAR_5->key = malloc(sizeof(char)\n                               * (strlen(((COMPS_RTreeData*)VAR_4->data)->key)\n                               + strlen(VAR_6->key) + 1));\n                memcpy(VAR_5->key, VAR_6->key,\n                       sizeof(char) * strlen(VAR_6->key));\n                memcpy(VAR_5->key + strlen(VAR_6->key),\n                       ((COMPS_RTreeData*)VAR_4->data)->key,\n                       sizeof(char)*(strlen(((COMPS_RTreeData*)VAR_4->data)->key)+1));\n            } else {\n                VAR_5->key = malloc(sizeof(char)*\n                                (strlen(((COMPS_RTreeData*)VAR_4->data)->key) +1));\n                memcpy(VAR_5->key, ((COMPS_RTreeData*)VAR_4->data)->key,\n                       sizeof(char)*(strlen(((COMPS_RTreeData*)VAR_4->data)->key)+1));\n            }\n            /* COMMENT_0 */\n            if (((COMPS_RTreeData*)VAR_4->data)->data != NULL) {\n                    comps_rtree_set(VAR_0,\n                                    VAR_5->key,\n                        VAR_1->data_cloner(((COMPS_RTreeData*)VAR_4->data)->data));\n            }\n            if (((COMPS_RTreeData*)VAR_4->data)->subnodes->first) {\n                comps_hslist_append(VAR_2, VAR_5, 0);\n            } else {\n                VAR_7(VAR_5->key);\n                VAR_7(VAR_5);\n            }\n        }\n        VAR_7(VAR_6->key);\n        VAR_7(VAR_6);\n    }\n    comps_hslist_destroy(&VAR_2);\n}",
  "func_graph_path": "rpm-software-management/libcomps/e3a5d056633677959ad924a51758876d415e7046/comps_radix.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -4,7 +4,6 @@\n     struct Pair {\n         COMPS_HSList * subnodes;\n         char * key;\n-        char added;\n     } *pair, *parent_pair;\n \n     pair = malloc(sizeof(struct Pair));",
  "diff_line_info": {
    "deleted_lines": [
      "        char added;"
    ],
    "added_lines": []
  },
  "is_vul": true,
  "pr_url": "https://github.com/rpm-software-management/libcomps/pull/43",
  "description": {
    "pr_info": {
      "title": "Fix UAF in comps_objmrtree_unite function",
      "number": 43
    },
    "comment": [
      "The added field is not used at all in many places and it is probably the\r\nleft-over of some copy-paste.\r\n\r\nFixes https://github.com/rpm-software-management/libcomps/issues/41",
      "Thank"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}