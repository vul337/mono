{
  "cve_id": "CVE-2021-37621",
  "cwe_ids": [
    "CWE-835"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "Exiv2/exiv2",
  "commit_msg": "dirLength == 0 can cause an infinite loop.",
  "commit_hash": "191cd2690608f19335d82ed2be36c7ce8bdc60b9",
  "git_url": "https://github.com/Exiv2/exiv2/commit/191cd2690608f19335d82ed2be36c7ce8bdc60b9",
  "file_path": "src/image.cpp",
  "func_name": "Image::printIFDStructure",
  "func_before": "void Image::printIFDStructure(BasicIo& io, std::ostream& out, Exiv2::PrintStructureOption option,uint32_t start,bool bSwap,char c,int depth)\n    {\n        depth++;\n        if ( depth == 1 ) visits.clear();\n        bool bFirst  = true  ;\n\n        // buffer\n        const size_t dirSize = 32;\n        DataBuf  dir(dirSize);\n        bool bPrint = option == kpsBasic || option == kpsRecursive;\n\n        do {\n            // Read top of directory\n            const int seekSuccess = !io.seek(start,BasicIo::beg);\n            const long bytesRead = io.read(dir.pData_, 2);\n            if (!seekSuccess || bytesRead == 0) {\n                throw Error(kerCorruptedMetadata);\n            }\n            uint16_t   dirLength = byteSwap2(dir,0,bSwap);\n\n            bool tooBig = dirLength > 500;\n            if ( tooBig ) throw Error(kerTiffDirectoryTooLarge);\n\n            if ( bFirst && bPrint ) {\n                out << Internal::indent(depth) << Internal::stringFormat(\"STRUCTURE OF TIFF FILE (%c%c): \",c,c) << io.path() << std::endl;\n                if ( tooBig ) out << Internal::indent(depth) << \"dirLength = \" << dirLength << std::endl;\n            }\n\n            // Read the dictionary\n            for ( int i = 0 ; i < dirLength ; i ++ ) {\n                if ( visits.find(io.tell()) != visits.end()  ) { // #547\n                    throw Error(kerCorruptedMetadata);\n                }\n                visits.insert(io.tell());\n                \n                if ( bFirst && bPrint ) {\n                    out << Internal::indent(depth)\n                        << \" address |    tag                              |     \"\n                        << \" type |    count |    offset | value\\n\";\n                }\n                bFirst = false;\n\n                io.read(dir.pData_, 12);\n                uint16_t tag    = byteSwap2(dir,0,bSwap);\n                uint16_t type   = byteSwap2(dir,2,bSwap);\n                uint32_t count  = byteSwap4(dir,4,bSwap);\n                uint32_t offset = byteSwap4(dir,8,bSwap);\n\n                // Break for unknown tag types else we may segfault.\n                if ( !typeValid(type) ) {\n                    std::cerr << \"invalid type in tiff structure\" << type << std::endl;\n                    start = 0; // break from do loop\n                    throw Error(kerInvalidTypeValue);\n                }\n\n                std::string sp  = \"\" ; // output spacer\n\n                //prepare to print the value\n                uint32_t kount  = isPrintXMP(tag,option) ? count // haul in all the data\n                                : isPrintICC(tag,option) ? count // ditto\n                                : isStringType(type)     ? (count > 32 ? 32 : count) // restrict long arrays\n                                : count > 5              ? 5\n                                : count\n                                ;\n                uint32_t pad    = isStringType(type) ? 1 : 0;\n                uint32_t size   = isStringType(type) ? 1\n                                : is2ByteType(type)  ? 2\n                                : is4ByteType(type)  ? 4\n                                : is8ByteType(type)  ? 8\n                                : 1\n                                ;\n\n                // if ( offset > io.size() ) offset = 0; // Denial of service?\n\n                // #55 and #56 memory allocation crash test/data/POC8\n                long long allocate = (long long) size*count + pad+20;\n                if ( allocate > (long long) io.size() ) {\n                    throw Error(kerInvalidMalloc);\n                }\n                DataBuf  buf((long)allocate);  // allocate a buffer\n                std::memset(buf.pData_, 0, buf.size_);\n                std::memcpy(buf.pData_,dir.pData_+8,4);  // copy dir[8:11] into buffer (short strings)\n                const bool bOffsetIsPointer = count*size > 4;\n\n                if ( bOffsetIsPointer ) {         // read into buffer\n                    size_t   restore = io.tell();  // save\n                    io.seek(offset,BasicIo::beg);  // position\n                    io.read(buf.pData_,count*size);// read\n                    io.seek(restore,BasicIo::beg); // restore\n                }\n\n                if ( bPrint ) {\n                    const uint32_t address = start + 2 + i*12 ;\n                    const std::string offsetString = bOffsetIsPointer?\n                        Internal::stringFormat(\"%10u\", offset):\n                        \"\";\n\n                    out << Internal::indent(depth)\n                    << Internal::stringFormat(\"%8u | %#06x %-28s |%10s |%9u |%10s | \"\n                                              ,address,tag,tagName(tag).c_str(),typeName(type),count,offsetString.c_str());\n                    if ( isShortType(type) ){\n                        for ( size_t k = 0 ; k < kount ; k++ ) {\n                            out << sp << byteSwap2(buf,k*size,bSwap);\n                            sp = \" \";\n                        }\n                    } else if ( isLongType(type) ){\n                        for ( size_t k = 0 ; k < kount ; k++ ) {\n                            out << sp << byteSwap4(buf,k*size,bSwap);\n                            sp = \" \";\n                        }\n\n                    } else if ( isRationalType(type) ){\n                        for ( size_t k = 0 ; k < kount ; k++ ) {\n                            uint32_t a = byteSwap4(buf,k*size+0,bSwap);\n                            uint32_t b = byteSwap4(buf,k*size+4,bSwap);\n                            out << sp << a << \"/\" << b;\n                            sp = \" \";\n                        }\n                    } else if ( isStringType(type) ) {\n                        out << sp << Internal::binaryToString(makeSlice(buf, 0, kount));\n                    }\n\n                    sp = kount == count ? \"\" : \" ...\";\n                    out << sp << std::endl;\n\n                    if ( option == kpsRecursive && (tag == 0x8769 /* ExifTag */ || tag == 0x014a/*SubIFDs*/  || type == tiffIfd) ) {\n                        for ( size_t k = 0 ; k < count ; k++ ) {\n                            size_t   restore = io.tell();\n                            uint32_t offset = byteSwap4(buf,k*size,bSwap);\n                            printIFDStructure(io,out,option,offset,bSwap,c,depth);\n                            io.seek(restore,BasicIo::beg);\n                        }\n                    } else if ( option == kpsRecursive && tag == 0x83bb /* IPTCNAA */ ) {\n\n                        if (static_cast<size_t>(Safe::add(count, offset)) > io.size()) {\n                            throw Error(kerCorruptedMetadata);\n                        }\n\n                        const size_t restore = io.tell();\n                        io.seek(offset, BasicIo::beg);  // position\n                        std::vector<byte> bytes(count) ;  // allocate memory\n                        // TODO: once we have C++11 use bytes.data()\n                        const long read_bytes = io.read(&bytes[0], count);\n                        io.seek(restore, BasicIo::beg);\n                        // TODO: once we have C++11 use bytes.data()\n                        IptcData::printStructure(out, makeSliceUntil(&bytes[0], read_bytes), depth);\n\n                    }  else if ( option == kpsRecursive && tag == 0x927c /* MakerNote */ && count > 10) {\n                        size_t   restore = io.tell();  // save\n\n                        uint32_t jump= 10           ;\n                        byte     bytes[20]          ;\n                        const char* chars = (const char*) &bytes[0] ;\n                        io.seek(offset,BasicIo::beg);  // position\n                        io.read(bytes,jump    )     ;  // read\n                        bytes[jump]=0               ;\n                        if ( ::strcmp(\"Nikon\",chars) == 0 ) {\n                            // tag is an embedded tiff\n                            byte* bytes=new byte[count-jump] ;  // allocate memory\n                            io.read(bytes,count-jump)        ;  // read\n                            MemIo memIo(bytes,count-jump)    ;  // create a file\n                            printTiffStructure(memIo,out,option,depth);\n                            delete[] bytes                   ;  // free\n                        } else {\n                            // tag is an IFD\n                            io.seek(0,BasicIo::beg);  // position\n                            printIFDStructure(io,out,option,offset,bSwap,c,depth);\n                        }\n\n                        io.seek(restore,BasicIo::beg); // restore\n                    }\n                }\n\n                if ( isPrintXMP(tag,option) ) {\n                    buf.pData_[count]=0;\n                    out << (char*) buf.pData_;\n                }\n                if ( isPrintICC(tag,option) ) {\n                    out.write((const char*)buf.pData_,count);\n                }\n            }\n            if ( start ) {\n                io.read(dir.pData_, 4);\n                start = tooBig ? 0 : byteSwap4(dir,0,bSwap);\n            }\n        } while (start) ;\n\n        if ( bPrint ) {\n            out << Internal::indent(depth) << \"END \" << io.path() << std::endl;\n        }\n        out.flush();\n        depth--;\n    }",
  "abstract_func_before": "void Image::printIFDStructure(BasicIo& VAR_0, std::ostream& VAR_1, Exiv2::PrintStructureOption VAR_2,uint32_t VAR_3,bool VAR_4,char VAR_5,int VAR_6)\n    {\n        VAR_6++;\n        if ( VAR_6 == 1 ) VAR_7.clear();\n        bool VAR_8  = true  ;\n\n        /* COMMENT_0 */\n        const size_t VAR_9 = 32;\n        DataBuf  dir(dirSize);\n        bool VAR_10 = VAR_2 == VAR_11 || VAR_2 == VAR_12;\n\n        do {\n            /* COMMENT_1 */\n            const int VAR_13 = !VAR_0.seek(VAR_3,BasicIo::beg);\n            const long VAR_14 = VAR_0.read(VAR_15.pData_, 2);\n            if (!VAR_13 || VAR_14 == 0) {\n                throw Error(VAR_16);\n            }\n            uint16_t   VAR_17 = byteSwap2(VAR_15,0,VAR_4);\n\n            bool VAR_18 = VAR_17 > 500;\n            if ( VAR_18 ) throw Error(VAR_19);\n\n            if ( VAR_8 && VAR_10 ) {\n                VAR_1 << Internal::indent(VAR_6) << Internal::stringFormat(\"STRUCTURE OF TIFF FILE (%c%c): \",VAR_5,VAR_5) << VAR_0.path() << std::endl;\n                if ( VAR_18 ) VAR_1 << Internal::indent(VAR_6) << \"dirLength = \" << VAR_17 << std::endl;\n            }\n\n            /* COMMENT_2 */\n            for ( int VAR_20 = 0 ; VAR_20 < VAR_17 ; VAR_20 ++ ) {\n                if ( VAR_7.find(VAR_0.tell()) != VAR_7.end()  ) { /* COMMENT_3 */\n                    throw Error(VAR_16);\n                }\n                VAR_7.insert(VAR_0.tell());\n                \n                if ( VAR_8 && VAR_10 ) {\n                    VAR_1 << Internal::indent(VAR_6)\n                        << \" address |    tag                              |     \"\n                        << \" type |    count |    offset | value\\n\";\n                }\n                VAR_8 = false;\n\n                VAR_0.read(VAR_15.pData_, 12);\n                uint16_t VAR_21    = byteSwap2(VAR_15,0,VAR_4);\n                uint16_t VAR_22   = byteSwap2(VAR_15,2,VAR_4);\n                uint32_t VAR_23  = byteSwap4(VAR_15,4,VAR_4);\n                uint32_t VAR_24 = byteSwap4(VAR_15,8,VAR_4);\n\n                /* COMMENT_4 */\n                if ( !typeValid(VAR_22) ) {\n                    std::cerr << \"invalid type in tiff structure\" << VAR_22 << std::endl;\n                    VAR_3 = 0; /* COMMENT_5 */\n                    throw Error(VAR_25);\n                }\n\n                std::string VAR_26  = \"\" ; /* COMMENT_6 */\n\n                /* COMMENT_7 */\n                uint32_t VAR_27  = isPrintXMP(VAR_21,VAR_2) ? VAR_23 /* COMMENT_8 */\n                                : isPrintICC(VAR_21,VAR_2) ? VAR_23 /* COMMENT_9 */\n                                : isStringType(VAR_22)     ? (VAR_23 > 32 ? 32 : VAR_23) /* COMMENT_10 */\n                                : VAR_23 > 5              ? 5\n                                : VAR_23\n                                ;\n                uint32_t VAR_28    = isStringType(VAR_22) ? 1 : 0;\n                uint32_t VAR_29   = isStringType(VAR_22) ? 1\n                                : is2ByteType(VAR_22)  ? 2\n                                : is4ByteType(VAR_22)  ? 4\n                                : is8ByteType(VAR_22)  ? 8\n                                : 1\n                                ;\n\n                /* COMMENT_11 */\n\n                /* COMMENT_12 */\n                long long VAR_30 = (long long) VAR_29*VAR_23 + VAR_28+20;\n                if ( VAR_30 > (long long) VAR_0.size() ) {\n                    throw Error(VAR_31);\n                }\n                DataBuf  VAR_32((long)VAR_30);  /* COMMENT_13 */\n                std::memset(VAR_32.pData_, 0, VAR_32.size_);\n                std::memcpy(VAR_32.pData_,VAR_15.pData_+8,4);  /* COMMENT_14 */\n                const bool VAR_33 = VAR_23*VAR_29 > 4;\n\n                if ( VAR_33 ) {         /* COMMENT_15 */\n                    size_t   VAR_34 = VAR_0.tell();  /* COMMENT_16 */\n                    VAR_0.seek(VAR_24,BasicIo::beg);  /* COMMENT_17 */\n                    VAR_0.read(VAR_32.pData_,VAR_23*VAR_29);/* COMMENT_18 */\n                    VAR_0.seek(VAR_34,BasicIo::beg); /* COMMENT_19 */\n                }\n\n                if ( VAR_10 ) {\n                    const uint32_t VAR_35 = VAR_3 + 2 + VAR_20*12 ;\n                    const std::string VAR_36 = VAR_33?\n                        Internal::stringFormat(\"%10u\", VAR_24):\n                        \"\";\n\n                    VAR_1 << Internal::indent(VAR_6)\n                    << Internal::stringFormat(\"%8u | %#06x %-28s |%10s |%9u |%10s | \"\n                                              ,VAR_35,VAR_21,tagName(VAR_21).c_str(),typeName(VAR_22),VAR_23,VAR_36.c_str());\n                    if ( isShortType(VAR_22) ){\n                        for ( size_t VAR_37 = 0 ; VAR_37 < VAR_27 ; VAR_37++ ) {\n                            VAR_1 << VAR_26 << byteSwap2(VAR_32,VAR_37*VAR_29,VAR_4);\n                            VAR_26 = \" \";\n                        }\n                    } else if ( isLongType(VAR_22) ){\n                        for ( size_t VAR_37 = 0 ; VAR_37 < VAR_27 ; VAR_37++ ) {\n                            VAR_1 << VAR_26 << byteSwap4(VAR_32,VAR_37*VAR_29,VAR_4);\n                            VAR_26 = \" \";\n                        }\n\n                    } else if ( isRationalType(VAR_22) ){\n                        for ( size_t VAR_37 = 0 ; VAR_37 < VAR_27 ; VAR_37++ ) {\n                            uint32_t VAR_38 = byteSwap4(VAR_32,VAR_37*VAR_29+0,VAR_4);\n                            uint32_t VAR_39 = byteSwap4(VAR_32,VAR_37*VAR_29+4,VAR_4);\n                            VAR_1 << VAR_26 << VAR_38 << \"/\" << VAR_39;\n                            VAR_26 = \" \";\n                        }\n                    } else if ( isStringType(VAR_22) ) {\n                        VAR_1 << VAR_26 << Internal::binaryToString(makeSlice(VAR_32, 0, VAR_27));\n                    }\n\n                    VAR_26 = VAR_27 == VAR_23 ? \"\" : \" ...\";\n                    VAR_1 << VAR_26 << std::endl;\n\n                    if ( VAR_2 == VAR_12 && (VAR_21 == 0x8769 /* COMMENT_20 */ || VAR_21 == 0x014a/* COMMENT_21 */  || VAR_22 == VAR_40) ) {\n                        for ( size_t VAR_37 = 0 ; VAR_37 < VAR_23 ; VAR_37++ ) {\n                            size_t   VAR_34 = VAR_0.tell();\n                            uint32_t VAR_24 = byteSwap4(VAR_32,VAR_37*VAR_29,VAR_4);\n                            printIFDStructure(VAR_0,VAR_1,VAR_2,VAR_24,VAR_4,VAR_5,VAR_6);\n                            VAR_0.seek(VAR_34,BasicIo::beg);\n                        }\n                    } else if ( VAR_2 == VAR_12 && VAR_21 == 0x83bb /* COMMENT_22 */ ) {\n\n                        if (VAR_41<size_t>(Safe::add(VAR_23, VAR_24)) > VAR_0.size()) {\n                            throw Error(VAR_16);\n                        }\n\n                        const size_t VAR_34 = VAR_0.tell();\n                        VAR_0.seek(VAR_24, BasicIo::beg);  /* COMMENT_17 */\n                        std::vector<byte> bytes(count) ;  /* COMMENT_23 */\n                        /* COMMENT_24 */\n                        const long VAR_42 = VAR_0.read(&VAR_43[0], count);\n                        VAR_0.seek(VAR_34, BasicIo::beg);\n                        /* COMMENT_24 */\n                        IptcData::printStructure(VAR_1, makeSliceUntil(&VAR_43[0], VAR_42), VAR_6);\n\n                    }  else if ( VAR_2 == VAR_12 && VAR_21 == 0x927c /* COMMENT_25 */ && count > 10) {\n                        size_t   VAR_34 = VAR_0.tell();  /* COMMENT_16 */\n\n                        uint32_t VAR_44= 10           ;\n                        byte     VAR_43[20]          ;\n                        const char* VAR_45 = (const char*) &VAR_43[0] ;\n                        VAR_0.seek(VAR_24,BasicIo::beg);  /* COMMENT_17 */\n                        VAR_0.read(VAR_43,VAR_44    )     ;  /* COMMENT_18 */\n                        VAR_43[VAR_44]=0               ;\n                        if ( ::strcmp(\"Nikon\",VAR_45) == 0 ) {\n                            /* COMMENT_26 */\n                            byte* VAR_43=new byte[count-VAR_44] ;  /* COMMENT_23 */\n                            VAR_0.read(VAR_43,count-VAR_44)        ;  /* COMMENT_18 */\n                            MemIo VAR_46(VAR_43,count-VAR_44)    ;  /* COMMENT_27 */\n                            printTiffStructure(VAR_46,VAR_1,VAR_2,VAR_6);\n                            delete[] VAR_43                   ;  /* COMMENT_28 */\n                        } else {\n                            /* COMMENT_29 */\n                            VAR_0.seek(0,BasicIo::beg);  /* COMMENT_17 */\n                            printIFDStructure(VAR_0,VAR_1,VAR_2,VAR_24,VAR_4,VAR_5,VAR_6);\n                        }\n\n                        VAR_0.seek(VAR_34,BasicIo::beg); /* COMMENT_19 */\n                    }\n                }\n\n                if ( isPrintXMP(VAR_21,VAR_2) ) {\n                    VAR_32.pData_[count]=0;\n                    VAR_1 << (char*) VAR_32.pData_;\n                }\n                if ( isPrintICC(VAR_21,VAR_2) ) {\n                    VAR_1.write((const char*)VAR_32.pData_,count);\n                }\n            }\n            if ( VAR_3 ) {\n                VAR_0.read(VAR_15.pData_, 4);\n                VAR_3 = VAR_18 ? 0 : byteSwap4(VAR_15,0,VAR_4);\n            }\n        } while (VAR_3) ;\n\n        if ( VAR_10 ) {\n            VAR_1 << Internal::indent(VAR_6) << \"END \" << VAR_0.path() << std::endl;\n        }\n        VAR_1.flush();\n        VAR_6--;\n    }",
  "func_graph_path_before": "Exiv2/exiv2/191cd2690608f19335d82ed2be36c7ce8bdc60b9/image.cpp/vul/before/0.json",
  "func": "void Image::printIFDStructure(BasicIo& io, std::ostream& out, Exiv2::PrintStructureOption option,uint32_t start,bool bSwap,char c,int depth)\n    {\n        depth++;\n        if ( depth == 1 ) visits.clear();\n        bool bFirst  = true  ;\n\n        // buffer\n        const size_t dirSize = 32;\n        DataBuf  dir(dirSize);\n        bool bPrint = option == kpsBasic || option == kpsRecursive;\n\n        do {\n            // Read top of directory\n            const int seekSuccess = !io.seek(start,BasicIo::beg);\n            const long bytesRead = io.read(dir.pData_, 2);\n            if (!seekSuccess || bytesRead == 0) {\n                throw Error(kerCorruptedMetadata);\n            }\n            uint16_t   dirLength = byteSwap2(dir,0,bSwap);\n            // Prevent infinite loops. (GHSA-m479-7frc-gqqg)\n            enforce(dirLength > 0, kerCorruptedMetadata);\n\n            bool tooBig = dirLength > 500;\n            if ( tooBig ) throw Error(kerTiffDirectoryTooLarge);\n\n            if ( bFirst && bPrint ) {\n                out << Internal::indent(depth) << Internal::stringFormat(\"STRUCTURE OF TIFF FILE (%c%c): \",c,c) << io.path() << std::endl;\n                if ( tooBig ) out << Internal::indent(depth) << \"dirLength = \" << dirLength << std::endl;\n            }\n\n            // Read the dictionary\n            for ( int i = 0 ; i < dirLength ; i ++ ) {\n                if ( visits.find(io.tell()) != visits.end()  ) { // #547\n                    throw Error(kerCorruptedMetadata);\n                }\n                visits.insert(io.tell());\n                \n                if ( bFirst && bPrint ) {\n                    out << Internal::indent(depth)\n                        << \" address |    tag                              |     \"\n                        << \" type |    count |    offset | value\\n\";\n                }\n                bFirst = false;\n\n                io.read(dir.pData_, 12);\n                uint16_t tag    = byteSwap2(dir,0,bSwap);\n                uint16_t type   = byteSwap2(dir,2,bSwap);\n                uint32_t count  = byteSwap4(dir,4,bSwap);\n                uint32_t offset = byteSwap4(dir,8,bSwap);\n\n                // Break for unknown tag types else we may segfault.\n                if ( !typeValid(type) ) {\n                    std::cerr << \"invalid type in tiff structure\" << type << std::endl;\n                    start = 0; // break from do loop\n                    throw Error(kerInvalidTypeValue);\n                }\n\n                std::string sp  = \"\" ; // output spacer\n\n                //prepare to print the value\n                uint32_t kount  = isPrintXMP(tag,option) ? count // haul in all the data\n                                : isPrintICC(tag,option) ? count // ditto\n                                : isStringType(type)     ? (count > 32 ? 32 : count) // restrict long arrays\n                                : count > 5              ? 5\n                                : count\n                                ;\n                uint32_t pad    = isStringType(type) ? 1 : 0;\n                uint32_t size   = isStringType(type) ? 1\n                                : is2ByteType(type)  ? 2\n                                : is4ByteType(type)  ? 4\n                                : is8ByteType(type)  ? 8\n                                : 1\n                                ;\n\n                // if ( offset > io.size() ) offset = 0; // Denial of service?\n\n                // #55 and #56 memory allocation crash test/data/POC8\n                long long allocate = (long long) size*count + pad+20;\n                if ( allocate > (long long) io.size() ) {\n                    throw Error(kerInvalidMalloc);\n                }\n                DataBuf  buf((long)allocate);  // allocate a buffer\n                std::memset(buf.pData_, 0, buf.size_);\n                std::memcpy(buf.pData_,dir.pData_+8,4);  // copy dir[8:11] into buffer (short strings)\n                const bool bOffsetIsPointer = count*size > 4;\n\n                if ( bOffsetIsPointer ) {         // read into buffer\n                    size_t   restore = io.tell();  // save\n                    io.seek(offset,BasicIo::beg);  // position\n                    io.read(buf.pData_,count*size);// read\n                    io.seek(restore,BasicIo::beg); // restore\n                }\n\n                if ( bPrint ) {\n                    const uint32_t address = start + 2 + i*12 ;\n                    const std::string offsetString = bOffsetIsPointer?\n                        Internal::stringFormat(\"%10u\", offset):\n                        \"\";\n\n                    out << Internal::indent(depth)\n                    << Internal::stringFormat(\"%8u | %#06x %-28s |%10s |%9u |%10s | \"\n                                              ,address,tag,tagName(tag).c_str(),typeName(type),count,offsetString.c_str());\n                    if ( isShortType(type) ){\n                        for ( size_t k = 0 ; k < kount ; k++ ) {\n                            out << sp << byteSwap2(buf,k*size,bSwap);\n                            sp = \" \";\n                        }\n                    } else if ( isLongType(type) ){\n                        for ( size_t k = 0 ; k < kount ; k++ ) {\n                            out << sp << byteSwap4(buf,k*size,bSwap);\n                            sp = \" \";\n                        }\n\n                    } else if ( isRationalType(type) ){\n                        for ( size_t k = 0 ; k < kount ; k++ ) {\n                            uint32_t a = byteSwap4(buf,k*size+0,bSwap);\n                            uint32_t b = byteSwap4(buf,k*size+4,bSwap);\n                            out << sp << a << \"/\" << b;\n                            sp = \" \";\n                        }\n                    } else if ( isStringType(type) ) {\n                        out << sp << Internal::binaryToString(makeSlice(buf, 0, kount));\n                    }\n\n                    sp = kount == count ? \"\" : \" ...\";\n                    out << sp << std::endl;\n\n                    if ( option == kpsRecursive && (tag == 0x8769 /* ExifTag */ || tag == 0x014a/*SubIFDs*/  || type == tiffIfd) ) {\n                        for ( size_t k = 0 ; k < count ; k++ ) {\n                            size_t   restore = io.tell();\n                            uint32_t offset = byteSwap4(buf,k*size,bSwap);\n                            printIFDStructure(io,out,option,offset,bSwap,c,depth);\n                            io.seek(restore,BasicIo::beg);\n                        }\n                    } else if ( option == kpsRecursive && tag == 0x83bb /* IPTCNAA */ ) {\n\n                        if (static_cast<size_t>(Safe::add(count, offset)) > io.size()) {\n                            throw Error(kerCorruptedMetadata);\n                        }\n\n                        const size_t restore = io.tell();\n                        io.seek(offset, BasicIo::beg);  // position\n                        std::vector<byte> bytes(count) ;  // allocate memory\n                        // TODO: once we have C++11 use bytes.data()\n                        const long read_bytes = io.read(&bytes[0], count);\n                        io.seek(restore, BasicIo::beg);\n                        // TODO: once we have C++11 use bytes.data()\n                        IptcData::printStructure(out, makeSliceUntil(&bytes[0], read_bytes), depth);\n\n                    }  else if ( option == kpsRecursive && tag == 0x927c /* MakerNote */ && count > 10) {\n                        size_t   restore = io.tell();  // save\n\n                        uint32_t jump= 10           ;\n                        byte     bytes[20]          ;\n                        const char* chars = (const char*) &bytes[0] ;\n                        io.seek(offset,BasicIo::beg);  // position\n                        io.read(bytes,jump    )     ;  // read\n                        bytes[jump]=0               ;\n                        if ( ::strcmp(\"Nikon\",chars) == 0 ) {\n                            // tag is an embedded tiff\n                            byte* bytes=new byte[count-jump] ;  // allocate memory\n                            io.read(bytes,count-jump)        ;  // read\n                            MemIo memIo(bytes,count-jump)    ;  // create a file\n                            printTiffStructure(memIo,out,option,depth);\n                            delete[] bytes                   ;  // free\n                        } else {\n                            // tag is an IFD\n                            io.seek(0,BasicIo::beg);  // position\n                            printIFDStructure(io,out,option,offset,bSwap,c,depth);\n                        }\n\n                        io.seek(restore,BasicIo::beg); // restore\n                    }\n                }\n\n                if ( isPrintXMP(tag,option) ) {\n                    buf.pData_[count]=0;\n                    out << (char*) buf.pData_;\n                }\n                if ( isPrintICC(tag,option) ) {\n                    out.write((const char*)buf.pData_,count);\n                }\n            }\n            if ( start ) {\n                io.read(dir.pData_, 4);\n                start = tooBig ? 0 : byteSwap4(dir,0,bSwap);\n            }\n        } while (start) ;\n\n        if ( bPrint ) {\n            out << Internal::indent(depth) << \"END \" << io.path() << std::endl;\n        }\n        out.flush();\n        depth--;\n    }",
  "abstract_func": "void Image::printIFDStructure(BasicIo& VAR_0, std::ostream& VAR_1, Exiv2::PrintStructureOption VAR_2,uint32_t VAR_3,bool VAR_4,char VAR_5,int VAR_6)\n    {\n        VAR_6++;\n        if ( VAR_6 == 1 ) VAR_7.clear();\n        bool VAR_8  = true  ;\n\n        /* COMMENT_0 */\n        const size_t VAR_9 = 32;\n        DataBuf  dir(dirSize);\n        bool VAR_10 = VAR_2 == VAR_11 || VAR_2 == VAR_12;\n\n        do {\n            /* COMMENT_1 */\n            const int VAR_13 = !VAR_0.seek(VAR_3,BasicIo::beg);\n            const long VAR_14 = VAR_0.read(VAR_15.pData_, 2);\n            if (!VAR_13 || VAR_14 == 0) {\n                throw Error(VAR_16);\n            }\n            uint16_t   VAR_17 = byteSwap2(VAR_15,0,VAR_4);\n            /* COMMENT_2 */\n            enforce(VAR_17 > 0, VAR_16);\n\n            bool VAR_18 = VAR_17 > 500;\n            if ( VAR_18 ) throw Error(VAR_19);\n\n            if ( VAR_8 && VAR_10 ) {\n                VAR_1 << Internal::indent(VAR_6) << Internal::stringFormat(\"STRUCTURE OF TIFF FILE (%c%c): \",VAR_5,VAR_5) << VAR_0.path() << std::endl;\n                if ( VAR_18 ) VAR_1 << Internal::indent(VAR_6) << \"dirLength = \" << VAR_17 << std::endl;\n            }\n\n            /* COMMENT_3 */\n            for ( int VAR_20 = 0 ; VAR_20 < VAR_17 ; VAR_20 ++ ) {\n                if ( VAR_7.find(VAR_0.tell()) != VAR_7.end()  ) { /* COMMENT_4 */\n                    throw Error(VAR_16);\n                }\n                VAR_7.insert(VAR_0.tell());\n                \n                if ( VAR_8 && VAR_10 ) {\n                    VAR_1 << Internal::indent(VAR_6)\n                        << \" address |    tag                              |     \"\n                        << \" type |    count |    offset | value\\n\";\n                }\n                VAR_8 = false;\n\n                VAR_0.read(VAR_15.pData_, 12);\n                uint16_t VAR_21    = byteSwap2(VAR_15,0,VAR_4);\n                uint16_t VAR_22   = byteSwap2(VAR_15,2,VAR_4);\n                uint32_t VAR_23  = byteSwap4(VAR_15,4,VAR_4);\n                uint32_t VAR_24 = byteSwap4(VAR_15,8,VAR_4);\n\n                /* COMMENT_5 */\n                if ( !typeValid(VAR_22) ) {\n                    std::cerr << \"invalid type in tiff structure\" << VAR_22 << std::endl;\n                    VAR_3 = 0; /* COMMENT_6 */\n                    throw Error(VAR_25);\n                }\n\n                std::string VAR_26  = \"\" ; /* COMMENT_7 */\n\n                /* COMMENT_8 */\n                uint32_t VAR_27  = isPrintXMP(VAR_21,VAR_2) ? VAR_23 /* COMMENT_9 */\n                                : isPrintICC(VAR_21,VAR_2) ? VAR_23 /* COMMENT_10 */\n                                : isStringType(VAR_22)     ? (VAR_23 > 32 ? 32 : VAR_23) /* COMMENT_11 */\n                                : VAR_23 > 5              ? 5\n                                : VAR_23\n                                ;\n                uint32_t VAR_28    = isStringType(VAR_22) ? 1 : 0;\n                uint32_t VAR_29   = isStringType(VAR_22) ? 1\n                                : is2ByteType(VAR_22)  ? 2\n                                : is4ByteType(VAR_22)  ? 4\n                                : is8ByteType(VAR_22)  ? 8\n                                : 1\n                                ;\n\n                /* COMMENT_12 */\n\n                /* COMMENT_13 */\n                long long VAR_30 = (long long) VAR_29*VAR_23 + VAR_28+20;\n                if ( VAR_30 > (long long) VAR_0.size() ) {\n                    throw Error(VAR_31);\n                }\n                DataBuf  VAR_32((long)VAR_30);  /* COMMENT_14 */\n                std::memset(VAR_32.pData_, 0, VAR_32.size_);\n                std::memcpy(VAR_32.pData_,VAR_15.pData_+8,4);  /* COMMENT_15 */\n                const bool VAR_33 = VAR_23*VAR_29 > 4;\n\n                if ( VAR_33 ) {         /* COMMENT_16 */\n                    size_t   VAR_34 = VAR_0.tell();  /* COMMENT_17 */\n                    VAR_0.seek(VAR_24,BasicIo::beg);  /* COMMENT_18 */\n                    VAR_0.read(VAR_32.pData_,VAR_23*VAR_29);/* COMMENT_19 */\n                    VAR_0.seek(VAR_34,BasicIo::beg); /* COMMENT_20 */\n                }\n\n                if ( VAR_10 ) {\n                    const uint32_t VAR_35 = VAR_3 + 2 + VAR_20*12 ;\n                    const std::string VAR_36 = VAR_33?\n                        Internal::stringFormat(\"%10u\", VAR_24):\n                        \"\";\n\n                    VAR_1 << Internal::indent(VAR_6)\n                    << Internal::stringFormat(\"%8u | %#06x %-28s |%10s |%9u |%10s | \"\n                                              ,VAR_35,VAR_21,tagName(VAR_21).c_str(),typeName(VAR_22),VAR_23,VAR_36.c_str());\n                    if ( isShortType(VAR_22) ){\n                        for ( size_t VAR_37 = 0 ; VAR_37 < VAR_27 ; VAR_37++ ) {\n                            VAR_1 << VAR_26 << byteSwap2(VAR_32,VAR_37*VAR_29,VAR_4);\n                            VAR_26 = \" \";\n                        }\n                    } else if ( isLongType(VAR_22) ){\n                        for ( size_t VAR_37 = 0 ; VAR_37 < VAR_27 ; VAR_37++ ) {\n                            VAR_1 << VAR_26 << byteSwap4(VAR_32,VAR_37*VAR_29,VAR_4);\n                            VAR_26 = \" \";\n                        }\n\n                    } else if ( isRationalType(VAR_22) ){\n                        for ( size_t VAR_37 = 0 ; VAR_37 < VAR_27 ; VAR_37++ ) {\n                            uint32_t VAR_38 = byteSwap4(VAR_32,VAR_37*VAR_29+0,VAR_4);\n                            uint32_t VAR_39 = byteSwap4(VAR_32,VAR_37*VAR_29+4,VAR_4);\n                            VAR_1 << VAR_26 << VAR_38 << \"/\" << VAR_39;\n                            VAR_26 = \" \";\n                        }\n                    } else if ( isStringType(VAR_22) ) {\n                        VAR_1 << VAR_26 << Internal::binaryToString(makeSlice(VAR_32, 0, VAR_27));\n                    }\n\n                    VAR_26 = VAR_27 == VAR_23 ? \"\" : \" ...\";\n                    VAR_1 << VAR_26 << std::endl;\n\n                    if ( VAR_2 == VAR_12 && (VAR_21 == 0x8769 /* COMMENT_21 */ || VAR_21 == 0x014a/* COMMENT_22 */  || VAR_22 == VAR_40) ) {\n                        for ( size_t VAR_37 = 0 ; VAR_37 < VAR_23 ; VAR_37++ ) {\n                            size_t   VAR_34 = VAR_0.tell();\n                            uint32_t VAR_24 = byteSwap4(VAR_32,VAR_37*VAR_29,VAR_4);\n                            printIFDStructure(VAR_0,VAR_1,VAR_2,VAR_24,VAR_4,VAR_5,VAR_6);\n                            VAR_0.seek(VAR_34,BasicIo::beg);\n                        }\n                    } else if ( VAR_2 == VAR_12 && VAR_21 == 0x83bb /* COMMENT_23 */ ) {\n\n                        if (VAR_41<size_t>(Safe::add(VAR_23, VAR_24)) > VAR_0.size()) {\n                            throw Error(VAR_16);\n                        }\n\n                        const size_t VAR_34 = VAR_0.tell();\n                        VAR_0.seek(VAR_24, BasicIo::beg);  /* COMMENT_18 */\n                        std::vector<byte> bytes(count) ;  /* COMMENT_24 */\n                        /* COMMENT_25 */\n                        const long VAR_42 = VAR_0.read(&VAR_43[0], count);\n                        VAR_0.seek(VAR_34, BasicIo::beg);\n                        /* COMMENT_25 */\n                        IptcData::printStructure(VAR_1, makeSliceUntil(&VAR_43[0], VAR_42), VAR_6);\n\n                    }  else if ( VAR_2 == VAR_12 && VAR_21 == 0x927c /* COMMENT_26 */ && count > 10) {\n                        size_t   VAR_34 = VAR_0.tell();  /* COMMENT_17 */\n\n                        uint32_t VAR_44= 10           ;\n                        byte     VAR_43[20]          ;\n                        const char* VAR_45 = (const char*) &VAR_43[0] ;\n                        VAR_0.seek(VAR_24,BasicIo::beg);  /* COMMENT_18 */\n                        VAR_0.read(VAR_43,VAR_44    )     ;  /* COMMENT_19 */\n                        VAR_43[VAR_44]=0               ;\n                        if ( ::strcmp(\"Nikon\",VAR_45) == 0 ) {\n                            /* COMMENT_27 */\n                            byte* VAR_43=new byte[count-VAR_44] ;  /* COMMENT_24 */\n                            VAR_0.read(VAR_43,count-VAR_44)        ;  /* COMMENT_19 */\n                            MemIo VAR_46(VAR_43,count-VAR_44)    ;  /* COMMENT_28 */\n                            printTiffStructure(VAR_46,VAR_1,VAR_2,VAR_6);\n                            delete[] VAR_43                   ;  /* COMMENT_29 */\n                        } else {\n                            /* COMMENT_30 */\n                            VAR_0.seek(0,BasicIo::beg);  /* COMMENT_18 */\n                            printIFDStructure(VAR_0,VAR_1,VAR_2,VAR_24,VAR_4,VAR_5,VAR_6);\n                        }\n\n                        VAR_0.seek(VAR_34,BasicIo::beg); /* COMMENT_20 */\n                    }\n                }\n\n                if ( isPrintXMP(VAR_21,VAR_2) ) {\n                    VAR_32.pData_[count]=0;\n                    VAR_1 << (char*) VAR_32.pData_;\n                }\n                if ( isPrintICC(VAR_21,VAR_2) ) {\n                    VAR_1.write((const char*)VAR_32.pData_,count);\n                }\n            }\n            if ( VAR_3 ) {\n                VAR_0.read(VAR_15.pData_, 4);\n                VAR_3 = VAR_18 ? 0 : byteSwap4(VAR_15,0,VAR_4);\n            }\n        } while (VAR_3) ;\n\n        if ( VAR_10 ) {\n            VAR_1 << Internal::indent(VAR_6) << \"END \" << VAR_0.path() << std::endl;\n        }\n        VAR_1.flush();\n        VAR_6--;\n    }",
  "func_graph_path": "Exiv2/exiv2/191cd2690608f19335d82ed2be36c7ce8bdc60b9/image.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -17,6 +17,8 @@\n                 throw Error(kerCorruptedMetadata);\n             }\n             uint16_t   dirLength = byteSwap2(dir,0,bSwap);\n+            // Prevent infinite loops. (GHSA-m479-7frc-gqqg)\n+            enforce(dirLength > 0, kerCorruptedMetadata);\n \n             bool tooBig = dirLength > 500;\n             if ( tooBig ) throw Error(kerTiffDirectoryTooLarge);",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "            // Prevent infinite loops. (GHSA-m479-7frc-gqqg)",
      "            enforce(dirLength > 0, kerCorruptedMetadata);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/sridharb1/exiv2/pull/4",
  "description": {
    "pr_info": {
      "title": "0.27 maintenance",
      "number": 4
    },
    "comment": []
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.9"
}