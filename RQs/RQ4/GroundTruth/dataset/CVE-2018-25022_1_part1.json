{
  "cve_id": "CVE-2018-25022",
  "cwe_ids": [
    "CWE-200"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:N/A:N",
  "cvss_is_v3": false,
  "repo_name": "TokTok/c-toxcore",
  "commit_msg": "Restrict packet kinds that can be sent through onion path.",
  "commit_hash": "6b97acb773622f9abca5ef305cd55bdef1ecc484",
  "git_url": "https://github.com/TokTok/c-toxcore/commit/6b97acb773622f9abca5ef305cd55bdef1ecc484",
  "file_path": "toxcore/onion.c",
  "func_name": "handle_send_2",
  "func_before": "static int handle_send_2(void *object, IP_Port source, const uint8_t *packet, uint16_t length, void *userdata)\n{\n    Onion *onion = (Onion *)object;\n\n    if (length > ONION_MAX_PACKET_SIZE) {\n        return 1;\n    }\n\n    if (length <= 1 + SEND_3) {\n        return 1;\n    }\n\n    change_symmetric_key(onion);\n\n    uint8_t plain[ONION_MAX_PACKET_SIZE];\n    uint8_t shared_key[CRYPTO_SHARED_KEY_SIZE];\n    get_shared_key(&onion->shared_keys_3, shared_key, dht_get_self_secret_key(onion->dht), packet + 1 + CRYPTO_NONCE_SIZE);\n    int len = decrypt_data_symmetric(shared_key, packet + 1, packet + 1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE,\n                                     length - (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + RETURN_2), plain);\n\n    if (len != length - (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + RETURN_2 + CRYPTO_MAC_SIZE)) {\n        return 1;\n    }\n\n    IP_Port send_to;\n\n    if (ipport_unpack(&send_to, plain, len, 0) == -1) {\n        return 1;\n    }\n\n    uint8_t data[ONION_MAX_PACKET_SIZE];\n    memcpy(data, plain + SIZE_IPPORT, len - SIZE_IPPORT);\n    uint16_t data_len = (len - SIZE_IPPORT);\n    uint8_t *ret_part = data + (len - SIZE_IPPORT);\n    random_nonce(ret_part);\n    uint8_t ret_data[RETURN_2 + SIZE_IPPORT];\n    ipport_pack(ret_data, &source);\n    memcpy(ret_data + SIZE_IPPORT, packet + (length - RETURN_2), RETURN_2);\n    len = encrypt_data_symmetric(onion->secret_symmetric_key, ret_part, ret_data, sizeof(ret_data),\n                                 ret_part + CRYPTO_NONCE_SIZE);\n\n    if (len != RETURN_3 - CRYPTO_NONCE_SIZE) {\n        return 1;\n    }\n\n    data_len += RETURN_3;\n\n    if ((uint32_t)sendpacket(onion->net, send_to, data, data_len) != data_len) {\n        return 1;\n    }\n\n    return 0;\n}",
  "abstract_func_before": "static int handle_send_2(void *VAR_0, IP_Port VAR_1, const uint8_t *VAR_2, uint16_t VAR_3, void *VAR_4)\n{\n    Onion *VAR_5 = (Onion *)VAR_0;\n\n    if (VAR_3 > VAR_6) {\n        return 1;\n    }\n\n    if (VAR_3 <= 1 + VAR_7) {\n        return 1;\n    }\n\n    change_symmetric_key(VAR_5);\n\n    uint8_t VAR_8[VAR_6];\n    uint8_t VAR_9[VAR_10];\n    get_shared_key(&VAR_5->shared_keys_3, VAR_9, dht_get_self_secret_key(VAR_5->dht), VAR_2 + 1 + VAR_11);\n    int VAR_12 = decrypt_data_symmetric(VAR_9, VAR_2 + 1, VAR_2 + 1 + VAR_11 + VAR_13,\n                                     VAR_3 - (1 + VAR_11 + VAR_13 + VAR_14), VAR_8);\n\n    if (VAR_12 != VAR_3 - (1 + VAR_11 + VAR_13 + VAR_14 + VAR_15)) {\n        return 1;\n    }\n\n    IP_Port VAR_16;\n\n    if (ipport_unpack(&VAR_16, VAR_8, VAR_12, 0) == -1) {\n        return 1;\n    }\n\n    uint8_t VAR_17[VAR_6];\n    memcpy(VAR_17, VAR_8 + VAR_18, VAR_12 - VAR_18);\n    uint16_t VAR_19 = (VAR_12 - VAR_18);\n    uint8_t *VAR_20 = VAR_17 + (VAR_12 - VAR_18);\n    random_nonce(VAR_20);\n    uint8_t VAR_21[VAR_14 + VAR_18];\n    ipport_pack(VAR_21, &VAR_1);\n    memcpy(VAR_21 + VAR_18, VAR_2 + (VAR_3 - VAR_14), VAR_14);\n    VAR_12 = encrypt_data_symmetric(VAR_5->secret_symmetric_key, VAR_20, VAR_21, sizeof(VAR_21),\n                                 VAR_20 + VAR_11);\n\n    if (VAR_12 != VAR_22 - VAR_11) {\n        return 1;\n    }\n\n    VAR_19 += VAR_22;\n\n    if ((uint32_t)sendpacket(VAR_5->net, VAR_16, VAR_17, VAR_19) != VAR_19) {\n        return 1;\n    }\n\n    return 0;\n}",
  "func_graph_path_before": "TokTok/c-toxcore/6b97acb773622f9abca5ef305cd55bdef1ecc484/onion.c/vul/before/2.json",
  "func": "static int handle_send_2(void *object, IP_Port source, const uint8_t *packet, uint16_t length, void *userdata)\n{\n    Onion *onion = (Onion *)object;\n\n    if (length > ONION_MAX_PACKET_SIZE) {\n        return 1;\n    }\n\n    if (length <= 1 + SEND_3) {\n        return 1;\n    }\n\n    change_symmetric_key(onion);\n\n    uint8_t plain[ONION_MAX_PACKET_SIZE];\n    uint8_t shared_key[CRYPTO_SHARED_KEY_SIZE];\n    get_shared_key(&onion->shared_keys_3, shared_key, dht_get_self_secret_key(onion->dht), packet + 1 + CRYPTO_NONCE_SIZE);\n    int len = decrypt_data_symmetric(shared_key, packet + 1, packet + 1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE,\n                                     length - (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + RETURN_2), plain);\n\n    if (len != length - (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + RETURN_2 + CRYPTO_MAC_SIZE)) {\n        return 1;\n    }\n\n    if (len <= SIZE_IPPORT) {\n        return 1;\n    }\n\n    if (plain[SIZE_IPPORT] != NET_PACKET_ANNOUNCE_REQUEST &&\n            plain[SIZE_IPPORT] != NET_PACKET_ONION_DATA_REQUEST) {\n        return 1;\n    }\n\n    IP_Port send_to;\n\n    if (ipport_unpack(&send_to, plain, len, 0) == -1) {\n        return 1;\n    }\n\n    uint8_t data[ONION_MAX_PACKET_SIZE];\n    memcpy(data, plain + SIZE_IPPORT, len - SIZE_IPPORT);\n    uint16_t data_len = (len - SIZE_IPPORT);\n    uint8_t *ret_part = data + (len - SIZE_IPPORT);\n    random_nonce(ret_part);\n    uint8_t ret_data[RETURN_2 + SIZE_IPPORT];\n    ipport_pack(ret_data, &source);\n    memcpy(ret_data + SIZE_IPPORT, packet + (length - RETURN_2), RETURN_2);\n    len = encrypt_data_symmetric(onion->secret_symmetric_key, ret_part, ret_data, sizeof(ret_data),\n                                 ret_part + CRYPTO_NONCE_SIZE);\n\n    if (len != RETURN_3 - CRYPTO_NONCE_SIZE) {\n        return 1;\n    }\n\n    data_len += RETURN_3;\n\n    if ((uint32_t)sendpacket(onion->net, send_to, data, data_len) != data_len) {\n        return 1;\n    }\n\n    return 0;\n}",
  "abstract_func": "static int handle_send_2(void *VAR_0, IP_Port VAR_1, const uint8_t *VAR_2, uint16_t VAR_3, void *VAR_4)\n{\n    Onion *VAR_5 = (Onion *)VAR_0;\n\n    if (VAR_3 > VAR_6) {\n        return 1;\n    }\n\n    if (VAR_3 <= 1 + VAR_7) {\n        return 1;\n    }\n\n    change_symmetric_key(VAR_5);\n\n    uint8_t VAR_8[VAR_6];\n    uint8_t VAR_9[VAR_10];\n    get_shared_key(&VAR_5->shared_keys_3, VAR_9, dht_get_self_secret_key(VAR_5->dht), VAR_2 + 1 + VAR_11);\n    int VAR_12 = decrypt_data_symmetric(VAR_9, VAR_2 + 1, VAR_2 + 1 + VAR_11 + VAR_13,\n                                     VAR_3 - (1 + VAR_11 + VAR_13 + VAR_14), VAR_8);\n\n    if (VAR_12 != VAR_3 - (1 + VAR_11 + VAR_13 + VAR_14 + VAR_15)) {\n        return 1;\n    }\n\n    if (VAR_12 <= VAR_16) {\n        return 1;\n    }\n\n    if (VAR_8[VAR_16] != VAR_17 &&\n            VAR_8[VAR_16] != VAR_18) {\n        return 1;\n    }\n\n    IP_Port VAR_19;\n\n    if (ipport_unpack(&VAR_19, VAR_8, VAR_12, 0) == -1) {\n        return 1;\n    }\n\n    uint8_t VAR_20[VAR_6];\n    memcpy(VAR_20, VAR_8 + VAR_16, VAR_12 - VAR_16);\n    uint16_t VAR_21 = (VAR_12 - VAR_16);\n    uint8_t *VAR_22 = VAR_20 + (VAR_12 - VAR_16);\n    random_nonce(VAR_22);\n    uint8_t VAR_23[VAR_14 + VAR_16];\n    ipport_pack(VAR_23, &VAR_1);\n    memcpy(VAR_23 + VAR_16, VAR_2 + (VAR_3 - VAR_14), VAR_14);\n    VAR_12 = encrypt_data_symmetric(VAR_5->secret_symmetric_key, VAR_22, VAR_23, sizeof(VAR_23),\n                                 VAR_22 + VAR_11);\n\n    if (VAR_12 != VAR_24 - VAR_11) {\n        return 1;\n    }\n\n    VAR_21 += VAR_24;\n\n    if ((uint32_t)sendpacket(VAR_5->net, VAR_19, VAR_20, VAR_21) != VAR_21) {\n        return 1;\n    }\n\n    return 0;\n}",
  "func_graph_path": "TokTok/c-toxcore/6b97acb773622f9abca5ef305cd55bdef1ecc484/onion.c/vul/after/2.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -19,6 +19,15 @@\n                                      length - (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + RETURN_2), plain);\n \n     if (len != length - (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + RETURN_2 + CRYPTO_MAC_SIZE)) {\n+        return 1;\n+    }\n+\n+    if (len <= SIZE_IPPORT) {\n+        return 1;\n+    }\n+\n+    if (plain[SIZE_IPPORT] != NET_PACKET_ANNOUNCE_REQUEST &&\n+            plain[SIZE_IPPORT] != NET_PACKET_ONION_DATA_REQUEST) {\n         return 1;\n     }\n ",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "        return 1;",
      "    }",
      "",
      "    if (len <= SIZE_IPPORT) {",
      "        return 1;",
      "    }",
      "",
      "    if (plain[SIZE_IPPORT] != NET_PACKET_ANNOUNCE_REQUEST &&",
      "            plain[SIZE_IPPORT] != NET_PACKET_ONION_DATA_REQUEST) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/TokTok/c-toxcore/pull/872",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/TokTok/c-toxcore/pull/872: 403 Client Error: Forbidden for url: https://api.github.com/repos/TokTok/c-toxcore/pulls/872",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9  \n\nThe commit message and code changes clearly indicate the addition of security checks to restrict packet types, aligning with typical security fixes to prevent unauthorized access. The changes involve input validation and access control, key areas in security, supporting the classification as a security fix."
}