{
  "cve_id": "CVE-2022-29021",
  "cwe_ids": [
    "CWE-120"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "openrazer",
  "commit_msg": "Fix oob memcpy in matrix_custom_frame methods\n\nAdjust row_length if it exeeds the arguments array",
  "commit_hash": "7e8a04feb378a679f1bcdcae079a5100cc45663b",
  "git_url": "https://github.com/openrazer/openrazer/commit/7e8a04feb378a679f1bcdcae079a5100cc45663b",
  "file_path": "driver/razerchromacommon.c",
  "func_name": "razer_chroma_extended_matrix_set_custom_frame2",
  "func_before": "struct razer_report razer_chroma_extended_matrix_set_custom_frame2(unsigned char row_index, unsigned char start_col, unsigned char stop_col, unsigned char *rgb_data, size_t packetLength)\n{\n    const size_t row_length = (size_t) (((stop_col + 1) - start_col) * 3);\n    // Some devices need a specific packet length, most devices are happy with 0x47\n    // e.g. the Mamba Elite needs a \"row_length + 5\" packet length\n    const size_t data_length = (packetLength != 0) ? packetLength : row_length + 5;\n    struct razer_report report = get_razer_report(0x0F, 0x03, data_length);\n\n    report.transaction_id.id = 0x3F;\n\n    // printk(KERN_ALERT \"razerkbd: Row ID: %d, Start: %d, Stop: %d, row length: %d\\n\", row_index, start_col, stop_col, (unsigned char)row_length);\n\n    report.arguments[2] = row_index;\n    report.arguments[3] = start_col;\n    report.arguments[4] = stop_col;\n    memcpy(&report.arguments[5], rgb_data, row_length);\n\n    return report;\n}",
  "abstract_func_before": "struct razer_report razer_chroma_extended_matrix_set_custom_frame2(unsigned char VAR_0, unsigned char VAR_1, unsigned char VAR_2, unsigned char *VAR_3, size_t VAR_4)\n{\n    const size_t VAR_5 = (size_t) (((VAR_2 + 1) - VAR_1) * 3);\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n    const size_t VAR_6 = (VAR_4 != 0) ? VAR_4 : VAR_5 + 5;\n    struct razer_report VAR_7 = get_razer_report(0x0F, 0x03, VAR_6);\n\n    VAR_7.transaction_id.id = 0x3F;\n\n    /* COMMENT_2 */\n\n    VAR_7.arguments[2] = VAR_0;\n    VAR_7.arguments[3] = VAR_1;\n    VAR_7.arguments[4] = VAR_2;\n    memcpy(&VAR_7.arguments[5], VAR_3, VAR_5);\n\n    return VAR_7;\n}",
  "func_graph_path_before": "openrazer/7e8a04feb378a679f1bcdcae079a5100cc45663b/razerchromacommon.c/vul/before/2.json",
  "func": "struct razer_report razer_chroma_extended_matrix_set_custom_frame2(unsigned char row_index, unsigned char start_col, unsigned char stop_col, unsigned char *rgb_data, size_t packetLength)\n{\n    const size_t start_arg_offset = 5;\n    size_t data_length = 0;\n    struct razer_report report = {0};\n    size_t row_length = (size_t) (((stop_col + 1) - start_col) * 3);\n\n    if (row_length > sizeof(report.arguments) - start_arg_offset) {\n        printk(KERN_ALERT \"razerchroma: RGB data too long\\n\");\n        row_length = sizeof(report.arguments) - start_arg_offset;\n    }\n\n    // Some devices need a specific packet length, most devices are happy with 0x47\n    // e.g. the Mamba Elite needs a \"row_length + 5\" packet length\n    data_length = (packetLength != 0) ? packetLength : row_length + 5;\n    report = get_razer_report(0x0F, 0x03, data_length);\n\n    report.transaction_id.id = 0x3F;\n\n    // printk(KERN_ALERT \"razerkbd: Row ID: %d, Start: %d, Stop: %d, row length: %d\\n\", row_index, start_col, stop_col, (unsigned char)row_length);\n\n    report.arguments[2] = row_index;\n    report.arguments[3] = start_col;\n    report.arguments[4] = stop_col;\n    memcpy(&report.arguments[5], rgb_data, row_length);\n\n    return report;\n}",
  "abstract_func": "struct razer_report razer_chroma_extended_matrix_set_custom_frame2(unsigned char VAR_0, unsigned char VAR_1, unsigned char VAR_2, unsigned char *VAR_3, size_t VAR_4)\n{\n    const size_t VAR_5 = 5;\n    size_t VAR_6 = 0;\n    struct razer_report VAR_7 = {0};\n    size_t VAR_8 = (size_t) (((VAR_2 + 1) - VAR_1) * 3);\n\n    if (VAR_8 > sizeof(VAR_7.arguments) - VAR_5) {\n        printk(KERN_ALERT \"razerchroma: RGB data too long\\n\");\n        VAR_8 = sizeof(VAR_7.arguments) - VAR_5;\n    }\n\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n    VAR_6 = (VAR_4 != 0) ? VAR_4 : VAR_8 + 5;\n    VAR_7 = get_razer_report(0x0F, 0x03, VAR_6);\n\n    VAR_7.transaction_id.id = 0x3F;\n\n    /* COMMENT_2 */\n\n    VAR_7.arguments[2] = VAR_0;\n    VAR_7.arguments[3] = VAR_1;\n    VAR_7.arguments[4] = VAR_2;\n    memcpy(&VAR_7.arguments[5], VAR_3, VAR_8);\n\n    return VAR_7;\n}",
  "func_graph_path": "openrazer/7e8a04feb378a679f1bcdcae079a5100cc45663b/razerchromacommon.c/vul/after/2.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,10 +1,19 @@\n struct razer_report razer_chroma_extended_matrix_set_custom_frame2(unsigned char row_index, unsigned char start_col, unsigned char stop_col, unsigned char *rgb_data, size_t packetLength)\n {\n-    const size_t row_length = (size_t) (((stop_col + 1) - start_col) * 3);\n+    const size_t start_arg_offset = 5;\n+    size_t data_length = 0;\n+    struct razer_report report = {0};\n+    size_t row_length = (size_t) (((stop_col + 1) - start_col) * 3);\n+\n+    if (row_length > sizeof(report.arguments) - start_arg_offset) {\n+        printk(KERN_ALERT \"razerchroma: RGB data too long\\n\");\n+        row_length = sizeof(report.arguments) - start_arg_offset;\n+    }\n+\n     // Some devices need a specific packet length, most devices are happy with 0x47\n     // e.g. the Mamba Elite needs a \"row_length + 5\" packet length\n-    const size_t data_length = (packetLength != 0) ? packetLength : row_length + 5;\n-    struct razer_report report = get_razer_report(0x0F, 0x03, data_length);\n+    data_length = (packetLength != 0) ? packetLength : row_length + 5;\n+    report = get_razer_report(0x0F, 0x03, data_length);\n \n     report.transaction_id.id = 0x3F;\n ",
  "diff_line_info": {
    "deleted_lines": [
      "    const size_t row_length = (size_t) (((stop_col + 1) - start_col) * 3);",
      "    const size_t data_length = (packetLength != 0) ? packetLength : row_length + 5;",
      "    struct razer_report report = get_razer_report(0x0F, 0x03, data_length);"
    ],
    "added_lines": [
      "    const size_t start_arg_offset = 5;",
      "    size_t data_length = 0;",
      "    struct razer_report report = {0};",
      "    size_t row_length = (size_t) (((stop_col + 1) - start_col) * 3);",
      "",
      "    if (row_length > sizeof(report.arguments) - start_arg_offset) {",
      "        printk(KERN_ALERT \"razerchroma: RGB data too long\\n\");",
      "        row_length = sizeof(report.arguments) - start_arg_offset;",
      "    }",
      "",
      "    data_length = (packetLength != 0) ? packetLength : row_length + 5;",
      "    report = get_razer_report(0x0F, 0x03, data_length);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/openrazer/openrazer/pull/1790",
  "description": {
    "pr_info": {
      "title": "Fix oob memcpy matrix custom frame",
      "number": 1790
    },
    "comment": [
      "This PR fixes the OOB memcpy in the matrix_custom_frame for all 3 drivers (kbd, mouse, accessory)."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}