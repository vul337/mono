{
  "cve_id": "CVE-2017-17479",
  "cwe_ids": [
    "CWE-787",
    "CWE-476"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "uclouvain/openjpeg",
  "commit_msg": "jp3d/jpwl convert: fix write stack buffer overflow\n\nMissing buffer length formatter in fscanf call might lead to write\nstack buffer overflow.\n\nfixes #1044 (CVE-2017-17480)",
  "commit_hash": "0bc90e4062a5f9258c91eca018c019b179066c62",
  "git_url": "https://github.com/uclouvain/openjpeg/commit/0bc90e4062a5f9258c91eca018c019b179066c62",
  "file_path": "src/bin/jpwl/convert.c",
  "func_name": "pgxtovolume",
  "func_before": "opj_volume_t* pgxtovolume(char *relpath, opj_cparameters_t *parameters)\n{\n\n    FILE *f = NULL;\n    int w, h, prec;\n    unsigned long offset;\n    int i, s, numcomps, maxvalue, sliceno, slicepos, maxslice = 0;\n\n    OPJ_COLOR_SPACE color_space;\n    opj_volume_cmptparm_t cmptparm; /* maximum of 1 component */\n    opj_volume_t * volume = NULL;\n\n    char endian1, endian2, sign;\n    char signtmp[32];\n    char temp[32];\n    opj_volume_comp_t *comp = NULL;\n\n    DIR *dirp;\n    struct dirent *direntp;\n\n    char *tmp = NULL, *tmp2 = NULL,\n          *point = NULL, *pgx = NULL;\n    char tmpdirpath[MAX_PATH];\n    char dirpath[MAX_PATH];\n    char pattern[MAX_PATH];\n    char pgxfiles[MAX_SLICES][MAX_PATH];\n    int pgxslicepos[MAX_SLICES];\n    char tmpno[3];\n\n    numcomps = 1;\n    color_space = CLRSPC_GRAY;\n    sliceno = 0;\n    maxvalue = 0;\n    memset(pgxfiles, 0, MAX_SLICES * MAX_PATH * sizeof(char));\n    memset(&cmptparm, 0, sizeof(opj_volume_cmptparm_t));\n\n    /* Separación del caso de un único slice frente al de muchos */\n    if ((tmp = strrchr(relpath, '-')) == NULL) {\n        /*fprintf(stdout,\"[INFO] A volume of only one slice....\\n\");*/\n        sliceno = 1;\n        maxslice = 1;\n        strcpy(pgxfiles[0], relpath);\n\n    } else {\n        /*Fetch only the path */\n        strcpy(tmpdirpath, relpath);\n        if ((tmp = strrchr(tmpdirpath, '/')) != NULL) {\n            tmp++;\n            *tmp = '\\0';\n            strcpy(dirpath, tmpdirpath);\n        } else {\n            strcpy(dirpath, \"./\");\n        }\n\n        /*Fetch the pattern of the volume slices*/\n        if ((tmp = strrchr(relpath, '/')) != NULL) {\n            tmp++;\n        } else {\n            tmp = relpath;\n        }\n        if ((tmp2 = strrchr(tmp, '-')) != NULL) {\n            *tmp2 = '\\0';\n        } else {\n            fprintf(stdout, \"[ERROR] tmp2 ha dado null. no ha encontrado el * %s %s\", tmp,\n                    relpath);\n            return NULL;\n        }\n        strcpy(pattern, tmp);\n\n        dirp = opendir(dirpath);\n        if (dirp == NULL) {\n            fprintf(stdout,\n                    \"[ERROR] Infile must be a .pgx file or a directory that contain pgx files\");\n            return NULL;\n        }\n\n        /*Read all .pgx files of directory */\n        while ((direntp = readdir(dirp)) != NULL) {\n            /* Found a directory, but ignore . and .. */\n            if (strcmp(\".\", direntp->d_name) == 0 || strcmp(\"..\", direntp->d_name) == 0) {\n                continue;\n            }\n\n            if (((pgx = strstr(direntp->d_name, pattern)) != NULL) &&\n                    ((tmp2 = strstr(direntp->d_name, \".pgx\")) != NULL)) {\n\n                strcpy(tmp, dirpath);\n                tmp = strcat(tmp, direntp->d_name);\n\n                /*Obtenemos el index de la secuencia de slices*/\n                if ((tmp2 = strpbrk(direntp->d_name, \"0123456789\")) == NULL) {\n                    continue;\n                }\n                i = 0;\n                while (tmp2 != NULL) {\n                    tmpno[i++] = *tmp2;\n                    point = tmp2;\n                    tmp2 = strpbrk(tmp2 + 1, \"0123456789\");\n                }\n                tmpno[i] = '\\0';\n\n                /*Comprobamos que no estamos leyendo algo raro como pattern.jp3d*/\n                if ((point = strpbrk(point, \".\")) == NULL) {\n                    break;\n                }\n                /*Slicepos --> index de slice; Sliceno --> no de slices hasta el momento*/\n                slicepos = atoi(tmpno);\n                pgxslicepos[sliceno] = slicepos - 1;\n                sliceno++;\n                if (slicepos > maxslice) {\n                    maxslice = slicepos;\n                }\n\n                /*Colocamos el slices en su posicion correspondiente*/\n                strcpy(pgxfiles[slicepos - 1], tmp);\n            }\n        }\n\n    }/* else if pattern*.pgx */\n\n    if (!sliceno) {\n        fprintf(stdout,\n                \"[ERROR] No slices with this pattern founded !! Please check input volume name\\n\");\n        return NULL;\n    }\n    /*if ( maxslice != sliceno) {\n        fprintf(stdout,\"[ERROR] Slices are not sequentially numbered !! Please rename them accordingly\\n\");\n        return NULL;\n    }*/\n\n    for (s = 0; s < sliceno; s++) {\n        int pos = maxslice == sliceno ? s : pgxslicepos[s];\n        f = fopen(pgxfiles[pos], \"rb\");\n        if (!f) {\n            fprintf(stdout, \"[ERROR] Failed to open %s for reading !\\n\", pgxfiles[s]);\n            return NULL;\n        }\n        fprintf(stdout, \"[INFO] Loading %s \\n\", pgxfiles[pos]);\n\n        fseek(f, 0, SEEK_SET);\n        fscanf(f, \"PG%[ \\t]%c%c%[ \\t+-]%d%[ \\t]%d%[ \\t]%d\", temp, &endian1, &endian2,\n               signtmp, &prec, temp, &w, temp, &h);\n\n        i = 0;\n        sign = '+';\n        while (signtmp[i] != '\\0') {\n            if (signtmp[i] == '-') {\n                sign = '-';\n            }\n            i++;\n        }\n\n        fgetc(f);\n        if (endian1 == 'M' && endian2 == 'L') {\n            cmptparm.bigendian = 1;\n        } else if (endian2 == 'M' && endian1 == 'L') {\n            cmptparm.bigendian = 0;\n        } else {\n            fprintf(stdout, \"[ERROR] Bad pgx header, please check input file\\n\");\n            fclose(f);\n            return NULL;\n        }\n\n        if (s == 0) {\n            /* initialize volume component */\n\n            cmptparm.x0 = parameters->volume_offset_x0;\n            cmptparm.y0 = parameters->volume_offset_y0;\n            cmptparm.z0 = parameters->volume_offset_z0;\n            cmptparm.w = !cmptparm.x0 ? (w - 1) * parameters->subsampling_dx + 1 :\n                         cmptparm.x0 + (w - 1) * parameters->subsampling_dx + 1;\n            cmptparm.h = !cmptparm.y0 ? (h - 1) * parameters->subsampling_dy + 1 :\n                         cmptparm.y0 + (h - 1) * parameters->subsampling_dy + 1;\n            cmptparm.l = !cmptparm.z0 ? (sliceno - 1) * parameters->subsampling_dz + 1 :\n                         cmptparm.z0 + (sliceno - 1) * parameters->subsampling_dz + 1;\n\n            if (sign == '-') {\n                cmptparm.sgnd = 1;\n            } else {\n                cmptparm.sgnd = 0;\n            }\n            cmptparm.prec = prec;\n            cmptparm.bpp = prec;\n            cmptparm.dcoffset = parameters->dcoffset;\n            cmptparm.dx = parameters->subsampling_dx;\n            cmptparm.dy = parameters->subsampling_dy;\n            cmptparm.dz = parameters->subsampling_dz;\n\n            /* create the volume */\n            volume = opj_volume_create(numcomps, &cmptparm, color_space);\n            if (!volume) {\n                fclose(f);\n                return NULL;\n            }\n            /* set volume offset and reference grid */\n            volume->x0 = cmptparm.x0;\n            volume->y0 = cmptparm.y0;\n            volume->z0 = cmptparm.z0;\n            volume->x1 = cmptparm.w;\n            volume->y1 = cmptparm.h;\n            volume->z1 = cmptparm.l;\n\n            /* set volume data :only one component, that is a volume*/\n            comp = &volume->comps[0];\n\n        }/*if sliceno==1*/\n\n        offset = w * h * s;\n\n        for (i = 0; i < w * h; i++) {\n            int v;\n            if (comp->prec <= 8) {\n                if (!comp->sgnd) {\n                    v = readuchar(f);\n                } else {\n                    v = (char) readuchar(f);\n                }\n            } else if (comp->prec <= 16) {\n                if (!comp->sgnd) {\n                    v = readushort(f, cmptparm.bigendian);\n                } else {\n                    v = (short) readushort(f, cmptparm.bigendian);\n                }\n            } else {\n                if (!comp->sgnd) {\n                    v = readuint(f, cmptparm.bigendian);\n                } else {\n                    v = (int) readuint(f, cmptparm.bigendian);\n                }\n            }\n            if (v > maxvalue) {\n                maxvalue = v;\n            }\n            comp->data[i + offset] = v;\n\n        }\n        fclose(f);\n    } /* for s --> sliceno*/\n    comp->bpp = int_floorlog2(maxvalue) + 1;\n    if (sliceno != 1) {\n        closedir(dirp);\n    }\n    /*dump_volume(stdout, volume);*/\n    return volume;\n}",
  "abstract_func_before": "opj_volume_t* pgxtovolume(char *VAR_0, opj_cparameters_t *VAR_1)\n{\n\n    FILE *VAR_2 = NULL;\n    int VAR_3, VAR_4, VAR_5;\n    unsigned long VAR_6;\n    int VAR_7, VAR_8, VAR_9, VAR_10, VAR_11, VAR_12, VAR_13 = 0;\n\n    OPJ_COLOR_SPACE VAR_14;\n    opj_volume_cmptparm_t VAR_15; /* COMMENT_0 */\n    opj_volume_t * VAR_16 = NULL;\n\n    char VAR_17, VAR_18, VAR_19;\n    char VAR_20[32];\n    char VAR_21[32];\n    opj_volume_comp_t *VAR_22 = NULL;\n\n    DIR *VAR_23;\n    struct dirent *VAR_24;\n\n    char *VAR_25 = NULL, *VAR_26 = NULL,\n          *VAR_27 = NULL, *VAR_28 = NULL;\n    char VAR_29[VAR_30];\n    char VAR_31[VAR_30];\n    char VAR_32[VAR_30];\n    char VAR_33[VAR_34][VAR_30];\n    int VAR_35[VAR_34];\n    char VAR_36[3];\n\n    VAR_9 = 1;\n    VAR_14 = VAR_37;\n    VAR_11 = 0;\n    VAR_10 = 0;\n    memset(VAR_33, 0, VAR_34 * VAR_30 * sizeof(char));\n    memset(&VAR_15, 0, sizeof(opj_volume_cmptparm_t));\n\n    /* COMMENT_1 */\n    if ((VAR_25 = strrchr(VAR_0, '-')) == NULL) {\n        /* COMMENT_2 */\n        VAR_11 = 1;\n        VAR_13 = 1;\n        strcpy(VAR_33[0], VAR_0);\n\n    } else {\n        /* COMMENT_3 */\n        strcpy(VAR_29, VAR_0);\n        if ((VAR_25 = strrchr(VAR_29, '/')) != NULL) {\n            VAR_25++;\n            *VAR_25 = '\\0';\n            strcpy(VAR_31, VAR_29);\n        } else {\n            strcpy(VAR_31, \"./\");\n        }\n\n        /* COMMENT_4 */\n        if ((VAR_25 = strrchr(VAR_0, '/')) != NULL) {\n            VAR_25++;\n        } else {\n            VAR_25 = VAR_0;\n        }\n        if ((VAR_26 = strrchr(VAR_25, '-')) != NULL) {\n            *VAR_26 = '\\0';\n        } else {\n            fprintf(VAR_38, \"[ERROR] tmp2 ha dado null. no ha encontrado el * %s %s\", VAR_25,\n                    VAR_0);\n            return NULL;\n        }\n        strcpy(VAR_32, VAR_25);\n\n        VAR_23 = opendir(VAR_31);\n        if (VAR_23 == NULL) {\n            fprintf(VAR_38,\n                    \"[ERROR] Infile must be a .pgx file or a directory that contain pgx files\");\n            return NULL;\n        }\n\n        /* COMMENT_5 */\n        while ((VAR_24 = readdir(VAR_23)) != NULL) {\n            /* COMMENT_6 */\n            if (strcmp(\".\", VAR_24->d_name) == 0 || strcmp(\"..\", VAR_24->d_name) == 0) {\n                continue;\n            }\n\n            if (((VAR_28 = strstr(VAR_24->d_name, VAR_32)) != NULL) &&\n                    ((VAR_26 = strstr(VAR_24->d_name, \".pgx\")) != NULL)) {\n\n                strcpy(VAR_25, VAR_31);\n                VAR_25 = strcat(VAR_25, VAR_24->d_name);\n\n                /* COMMENT_7 */\n                if ((VAR_26 = strpbrk(VAR_24->d_name, \"0123456789\")) == NULL) {\n                    continue;\n                }\n                VAR_7 = 0;\n                while (VAR_26 != NULL) {\n                    VAR_36[VAR_7++] = *VAR_26;\n                    VAR_27 = VAR_26;\n                    VAR_26 = strpbrk(VAR_26 + 1, \"0123456789\");\n                }\n                VAR_36[VAR_7] = '\\0';\n\n                /* COMMENT_8 */\n                if ((VAR_27 = strpbrk(VAR_27, \".\")) == NULL) {\n                    break;\n                }\n                /* COMMENT_9 */\n                VAR_12 = atoi(VAR_36);\n                VAR_35[VAR_11] = VAR_12 - 1;\n                VAR_11++;\n                if (VAR_12 > VAR_13) {\n                    VAR_13 = VAR_12;\n                }\n\n                /* COMMENT_10 */\n                strcpy(VAR_33[VAR_12 - 1], VAR_25);\n            }\n        }\n\n    }/* COMMENT_11 */\n\n    if (!VAR_11) {\n        fprintf(VAR_38,\n                \"[ERROR] No slices with this pattern founded !! Please check input volume name\\n\");\n        return NULL;\n    }\n    /* COMMENT_12 */\n                                                                                                           \n                    \n       \n\n    for (VAR_8 = 0; VAR_8 < VAR_11; VAR_8++) {\n        int VAR_39 = VAR_13 == VAR_11 ? VAR_8 : VAR_35[VAR_8];\n        VAR_2 = fopen(VAR_33[VAR_39], \"rb\");\n        if (!VAR_2) {\n            fprintf(VAR_38, \"[ERROR] Failed to open %s for reading !\\n\", VAR_33[VAR_8]);\n            return NULL;\n        }\n        fprintf(VAR_38, \"[INFO] Loading %s \\n\", VAR_33[VAR_39]);\n\n        fseek(VAR_2, 0, VAR_40);\n        fscanf(VAR_2, \"PG%[ \\t]%c%c%[ \\t+-]%d%[ \\t]%d%[ \\t]%d\", VAR_21, &VAR_17, &VAR_18,\n               VAR_20, &VAR_5, VAR_21, &VAR_3, VAR_21, &VAR_4);\n\n        VAR_7 = 0;\n        VAR_19 = '+';\n        while (VAR_20[VAR_7] != '\\0') {\n            if (VAR_20[VAR_7] == '-') {\n                VAR_19 = '-';\n            }\n            VAR_7++;\n        }\n\n        fgetc(VAR_2);\n        if (VAR_17 == 'M' && VAR_18 == 'L') {\n            VAR_15.bigendian = 1;\n        } else if (VAR_18 == 'M' && VAR_17 == 'L') {\n            VAR_15.bigendian = 0;\n        } else {\n            fprintf(VAR_38, \"[ERROR] Bad pgx header, please check input file\\n\");\n            fclose(VAR_2);\n            return NULL;\n        }\n\n        if (VAR_8 == 0) {\n            /* COMMENT_16 */\n\n            VAR_15.x0 = VAR_1->volume_offset_x0;\n            VAR_15.y0 = VAR_1->volume_offset_y0;\n            VAR_15.z0 = VAR_1->volume_offset_z0;\n            VAR_15.w = !VAR_15.x0 ? (VAR_3 - 1) * VAR_1->subsampling_dx + 1 :\n                         VAR_15.x0 + (VAR_3 - 1) * VAR_1->subsampling_dx + 1;\n            VAR_15.h = !VAR_15.y0 ? (VAR_4 - 1) * VAR_1->subsampling_dy + 1 :\n                         VAR_15.y0 + (VAR_4 - 1) * VAR_1->subsampling_dy + 1;\n            VAR_15.l = !VAR_15.z0 ? (VAR_11 - 1) * VAR_1->subsampling_dz + 1 :\n                         VAR_15.z0 + (VAR_11 - 1) * VAR_1->subsampling_dz + 1;\n\n            if (VAR_19 == '-') {\n                VAR_15.sgnd = 1;\n            } else {\n                VAR_15.sgnd = 0;\n            }\n            VAR_15.prec = VAR_5;\n            VAR_15.bpp = VAR_5;\n            VAR_15.dcoffset = VAR_1->dcoffset;\n            VAR_15.dx = VAR_1->subsampling_dx;\n            VAR_15.dy = VAR_1->subsampling_dy;\n            VAR_15.dz = VAR_1->subsampling_dz;\n\n            /* COMMENT_17 */\n            VAR_16 = opj_volume_create(VAR_9, &VAR_15, VAR_14);\n            if (!VAR_16) {\n                fclose(VAR_2);\n                return NULL;\n            }\n            /* COMMENT_18 */\n            VAR_16->x0 = VAR_15.x0;\n            VAR_16->y0 = VAR_15.y0;\n            VAR_16->z0 = VAR_15.z0;\n            VAR_16->x1 = VAR_15.w;\n            VAR_16->y1 = VAR_15.h;\n            VAR_16->z1 = VAR_15.l;\n\n            /* COMMENT_19 */\n            VAR_22 = &VAR_16->comps[0];\n\n        }/* COMMENT_20 */\n\n        VAR_6 = VAR_3 * VAR_4 * VAR_8;\n\n        for (VAR_7 = 0; VAR_7 < VAR_3 * VAR_4; VAR_7++) {\n            int VAR_41;\n            if (VAR_22->prec <= 8) {\n                if (!VAR_22->sgnd) {\n                    VAR_41 = readuchar(VAR_2);\n                } else {\n                    VAR_41 = (char) readuchar(VAR_2);\n                }\n            } else if (VAR_22->prec <= 16) {\n                if (!VAR_22->sgnd) {\n                    VAR_41 = readushort(VAR_2, VAR_15.bigendian);\n                } else {\n                    VAR_41 = (short) readushort(VAR_2, VAR_15.bigendian);\n                }\n            } else {\n                if (!VAR_22->sgnd) {\n                    VAR_41 = readuint(VAR_2, VAR_15.bigendian);\n                } else {\n                    VAR_41 = (int) readuint(VAR_2, VAR_15.bigendian);\n                }\n            }\n            if (VAR_41 > VAR_10) {\n                VAR_10 = VAR_41;\n            }\n            VAR_22->data[VAR_7 + VAR_6] = VAR_41;\n\n        }\n        fclose(VAR_2);\n    } /* COMMENT_21 */\n    VAR_22->bpp = int_floorlog2(VAR_10) + 1;\n    if (VAR_11 != 1) {\n        closedir(VAR_23);\n    }\n    /* COMMENT_22 */\n    return VAR_16;\n}",
  "func_graph_path_before": "uclouvain/openjpeg/0bc90e4062a5f9258c91eca018c019b179066c62/convert.c/vul/before/0.json",
  "func": "opj_volume_t* pgxtovolume(char *relpath, opj_cparameters_t *parameters)\n{\n\n    FILE *f = NULL;\n    int w, h, prec;\n    unsigned long offset;\n    int i, s, numcomps, maxvalue, sliceno, slicepos, maxslice = 0;\n\n    OPJ_COLOR_SPACE color_space;\n    opj_volume_cmptparm_t cmptparm; /* maximum of 1 component */\n    opj_volume_t * volume = NULL;\n\n    char endian1, endian2, sign;\n    char signtmp[32];\n    char temp[32];\n    opj_volume_comp_t *comp = NULL;\n\n    DIR *dirp;\n    struct dirent *direntp;\n\n    char *tmp = NULL, *tmp2 = NULL,\n          *point = NULL, *pgx = NULL;\n    char tmpdirpath[MAX_PATH];\n    char dirpath[MAX_PATH];\n    char pattern[MAX_PATH];\n    char pgxfiles[MAX_SLICES][MAX_PATH];\n    int pgxslicepos[MAX_SLICES];\n    char tmpno[3];\n\n    numcomps = 1;\n    color_space = CLRSPC_GRAY;\n    sliceno = 0;\n    maxvalue = 0;\n    memset(pgxfiles, 0, MAX_SLICES * MAX_PATH * sizeof(char));\n    memset(&cmptparm, 0, sizeof(opj_volume_cmptparm_t));\n\n    /* Separación del caso de un único slice frente al de muchos */\n    if ((tmp = strrchr(relpath, '-')) == NULL) {\n        /*fprintf(stdout,\"[INFO] A volume of only one slice....\\n\");*/\n        sliceno = 1;\n        maxslice = 1;\n        strcpy(pgxfiles[0], relpath);\n\n    } else {\n        /*Fetch only the path */\n        strcpy(tmpdirpath, relpath);\n        if ((tmp = strrchr(tmpdirpath, '/')) != NULL) {\n            tmp++;\n            *tmp = '\\0';\n            strcpy(dirpath, tmpdirpath);\n        } else {\n            strcpy(dirpath, \"./\");\n        }\n\n        /*Fetch the pattern of the volume slices*/\n        if ((tmp = strrchr(relpath, '/')) != NULL) {\n            tmp++;\n        } else {\n            tmp = relpath;\n        }\n        if ((tmp2 = strrchr(tmp, '-')) != NULL) {\n            *tmp2 = '\\0';\n        } else {\n            fprintf(stdout, \"[ERROR] tmp2 ha dado null. no ha encontrado el * %s %s\", tmp,\n                    relpath);\n            return NULL;\n        }\n        strcpy(pattern, tmp);\n\n        dirp = opendir(dirpath);\n        if (dirp == NULL) {\n            fprintf(stdout,\n                    \"[ERROR] Infile must be a .pgx file or a directory that contain pgx files\");\n            return NULL;\n        }\n\n        /*Read all .pgx files of directory */\n        while ((direntp = readdir(dirp)) != NULL) {\n            /* Found a directory, but ignore . and .. */\n            if (strcmp(\".\", direntp->d_name) == 0 || strcmp(\"..\", direntp->d_name) == 0) {\n                continue;\n            }\n\n            if (((pgx = strstr(direntp->d_name, pattern)) != NULL) &&\n                    ((tmp2 = strstr(direntp->d_name, \".pgx\")) != NULL)) {\n\n                strcpy(tmp, dirpath);\n                tmp = strcat(tmp, direntp->d_name);\n\n                /*Obtenemos el index de la secuencia de slices*/\n                if ((tmp2 = strpbrk(direntp->d_name, \"0123456789\")) == NULL) {\n                    continue;\n                }\n                i = 0;\n                while (tmp2 != NULL) {\n                    tmpno[i++] = *tmp2;\n                    point = tmp2;\n                    tmp2 = strpbrk(tmp2 + 1, \"0123456789\");\n                }\n                tmpno[i] = '\\0';\n\n                /*Comprobamos que no estamos leyendo algo raro como pattern.jp3d*/\n                if ((point = strpbrk(point, \".\")) == NULL) {\n                    break;\n                }\n                /*Slicepos --> index de slice; Sliceno --> no de slices hasta el momento*/\n                slicepos = atoi(tmpno);\n                pgxslicepos[sliceno] = slicepos - 1;\n                sliceno++;\n                if (slicepos > maxslice) {\n                    maxslice = slicepos;\n                }\n\n                /*Colocamos el slices en su posicion correspondiente*/\n                strcpy(pgxfiles[slicepos - 1], tmp);\n            }\n        }\n\n    }/* else if pattern*.pgx */\n\n    if (!sliceno) {\n        fprintf(stdout,\n                \"[ERROR] No slices with this pattern founded !! Please check input volume name\\n\");\n        return NULL;\n    }\n    /*if ( maxslice != sliceno) {\n        fprintf(stdout,\"[ERROR] Slices are not sequentially numbered !! Please rename them accordingly\\n\");\n        return NULL;\n    }*/\n\n    for (s = 0; s < sliceno; s++) {\n        int pos = maxslice == sliceno ? s : pgxslicepos[s];\n        f = fopen(pgxfiles[pos], \"rb\");\n        if (!f) {\n            fprintf(stdout, \"[ERROR] Failed to open %s for reading !\\n\", pgxfiles[s]);\n            return NULL;\n        }\n        fprintf(stdout, \"[INFO] Loading %s \\n\", pgxfiles[pos]);\n\n        fseek(f, 0, SEEK_SET);\n        fscanf(f, \"PG%31[ \\t]%c%c%31[ \\t+-]%d%31[ \\t]%d%31[ \\t]%d\", temp, &endian1,\n               &endian2, signtmp, &prec, temp, &w, temp, &h);\n\n        i = 0;\n        sign = '+';\n        while (signtmp[i] != '\\0') {\n            if (signtmp[i] == '-') {\n                sign = '-';\n            }\n            i++;\n        }\n\n        fgetc(f);\n        if (endian1 == 'M' && endian2 == 'L') {\n            cmptparm.bigendian = 1;\n        } else if (endian2 == 'M' && endian1 == 'L') {\n            cmptparm.bigendian = 0;\n        } else {\n            fprintf(stdout, \"[ERROR] Bad pgx header, please check input file\\n\");\n            fclose(f);\n            return NULL;\n        }\n\n        if (s == 0) {\n            /* initialize volume component */\n\n            cmptparm.x0 = parameters->volume_offset_x0;\n            cmptparm.y0 = parameters->volume_offset_y0;\n            cmptparm.z0 = parameters->volume_offset_z0;\n            cmptparm.w = !cmptparm.x0 ? (w - 1) * parameters->subsampling_dx + 1 :\n                         cmptparm.x0 + (w - 1) * parameters->subsampling_dx + 1;\n            cmptparm.h = !cmptparm.y0 ? (h - 1) * parameters->subsampling_dy + 1 :\n                         cmptparm.y0 + (h - 1) * parameters->subsampling_dy + 1;\n            cmptparm.l = !cmptparm.z0 ? (sliceno - 1) * parameters->subsampling_dz + 1 :\n                         cmptparm.z0 + (sliceno - 1) * parameters->subsampling_dz + 1;\n\n            if (sign == '-') {\n                cmptparm.sgnd = 1;\n            } else {\n                cmptparm.sgnd = 0;\n            }\n            cmptparm.prec = prec;\n            cmptparm.bpp = prec;\n            cmptparm.dcoffset = parameters->dcoffset;\n            cmptparm.dx = parameters->subsampling_dx;\n            cmptparm.dy = parameters->subsampling_dy;\n            cmptparm.dz = parameters->subsampling_dz;\n\n            /* create the volume */\n            volume = opj_volume_create(numcomps, &cmptparm, color_space);\n            if (!volume) {\n                fclose(f);\n                return NULL;\n            }\n            /* set volume offset and reference grid */\n            volume->x0 = cmptparm.x0;\n            volume->y0 = cmptparm.y0;\n            volume->z0 = cmptparm.z0;\n            volume->x1 = cmptparm.w;\n            volume->y1 = cmptparm.h;\n            volume->z1 = cmptparm.l;\n\n            /* set volume data :only one component, that is a volume*/\n            comp = &volume->comps[0];\n\n        }/*if sliceno==1*/\n\n        offset = w * h * s;\n\n        for (i = 0; i < w * h; i++) {\n            int v;\n            if (comp->prec <= 8) {\n                if (!comp->sgnd) {\n                    v = readuchar(f);\n                } else {\n                    v = (char) readuchar(f);\n                }\n            } else if (comp->prec <= 16) {\n                if (!comp->sgnd) {\n                    v = readushort(f, cmptparm.bigendian);\n                } else {\n                    v = (short) readushort(f, cmptparm.bigendian);\n                }\n            } else {\n                if (!comp->sgnd) {\n                    v = readuint(f, cmptparm.bigendian);\n                } else {\n                    v = (int) readuint(f, cmptparm.bigendian);\n                }\n            }\n            if (v > maxvalue) {\n                maxvalue = v;\n            }\n            comp->data[i + offset] = v;\n\n        }\n        fclose(f);\n    } /* for s --> sliceno*/\n    comp->bpp = int_floorlog2(maxvalue) + 1;\n    if (sliceno != 1) {\n        closedir(dirp);\n    }\n    /*dump_volume(stdout, volume);*/\n    return volume;\n}",
  "abstract_func": "opj_volume_t* pgxtovolume(char *VAR_0, opj_cparameters_t *VAR_1)\n{\n\n    FILE *VAR_2 = NULL;\n    int VAR_3, VAR_4, VAR_5;\n    unsigned long VAR_6;\n    int VAR_7, VAR_8, VAR_9, VAR_10, VAR_11, VAR_12, VAR_13 = 0;\n\n    OPJ_COLOR_SPACE VAR_14;\n    opj_volume_cmptparm_t VAR_15; /* COMMENT_0 */\n    opj_volume_t * VAR_16 = NULL;\n\n    char VAR_17, VAR_18, VAR_19;\n    char VAR_20[32];\n    char VAR_21[32];\n    opj_volume_comp_t *VAR_22 = NULL;\n\n    DIR *VAR_23;\n    struct dirent *VAR_24;\n\n    char *VAR_25 = NULL, *VAR_26 = NULL,\n          *VAR_27 = NULL, *VAR_28 = NULL;\n    char VAR_29[VAR_30];\n    char VAR_31[VAR_30];\n    char VAR_32[VAR_30];\n    char VAR_33[VAR_34][VAR_30];\n    int VAR_35[VAR_34];\n    char VAR_36[3];\n\n    VAR_9 = 1;\n    VAR_14 = VAR_37;\n    VAR_11 = 0;\n    VAR_10 = 0;\n    memset(VAR_33, 0, VAR_34 * VAR_30 * sizeof(char));\n    memset(&VAR_15, 0, sizeof(opj_volume_cmptparm_t));\n\n    /* COMMENT_1 */\n    if ((VAR_25 = strrchr(VAR_0, '-')) == NULL) {\n        /* COMMENT_2 */\n        VAR_11 = 1;\n        VAR_13 = 1;\n        strcpy(VAR_33[0], VAR_0);\n\n    } else {\n        /* COMMENT_3 */\n        strcpy(VAR_29, VAR_0);\n        if ((VAR_25 = strrchr(VAR_29, '/')) != NULL) {\n            VAR_25++;\n            *VAR_25 = '\\0';\n            strcpy(VAR_31, VAR_29);\n        } else {\n            strcpy(VAR_31, \"./\");\n        }\n\n        /* COMMENT_4 */\n        if ((VAR_25 = strrchr(VAR_0, '/')) != NULL) {\n            VAR_25++;\n        } else {\n            VAR_25 = VAR_0;\n        }\n        if ((VAR_26 = strrchr(VAR_25, '-')) != NULL) {\n            *VAR_26 = '\\0';\n        } else {\n            fprintf(VAR_38, \"[ERROR] tmp2 ha dado null. no ha encontrado el * %s %s\", VAR_25,\n                    VAR_0);\n            return NULL;\n        }\n        strcpy(VAR_32, VAR_25);\n\n        VAR_23 = opendir(VAR_31);\n        if (VAR_23 == NULL) {\n            fprintf(VAR_38,\n                    \"[ERROR] Infile must be a .pgx file or a directory that contain pgx files\");\n            return NULL;\n        }\n\n        /* COMMENT_5 */\n        while ((VAR_24 = readdir(VAR_23)) != NULL) {\n            /* COMMENT_6 */\n            if (strcmp(\".\", VAR_24->d_name) == 0 || strcmp(\"..\", VAR_24->d_name) == 0) {\n                continue;\n            }\n\n            if (((VAR_28 = strstr(VAR_24->d_name, VAR_32)) != NULL) &&\n                    ((VAR_26 = strstr(VAR_24->d_name, \".pgx\")) != NULL)) {\n\n                strcpy(VAR_25, VAR_31);\n                VAR_25 = strcat(VAR_25, VAR_24->d_name);\n\n                /* COMMENT_7 */\n                if ((VAR_26 = strpbrk(VAR_24->d_name, \"0123456789\")) == NULL) {\n                    continue;\n                }\n                VAR_7 = 0;\n                while (VAR_26 != NULL) {\n                    VAR_36[VAR_7++] = *VAR_26;\n                    VAR_27 = VAR_26;\n                    VAR_26 = strpbrk(VAR_26 + 1, \"0123456789\");\n                }\n                VAR_36[VAR_7] = '\\0';\n\n                /* COMMENT_8 */\n                if ((VAR_27 = strpbrk(VAR_27, \".\")) == NULL) {\n                    break;\n                }\n                /* COMMENT_9 */\n                VAR_12 = atoi(VAR_36);\n                VAR_35[VAR_11] = VAR_12 - 1;\n                VAR_11++;\n                if (VAR_12 > VAR_13) {\n                    VAR_13 = VAR_12;\n                }\n\n                /* COMMENT_10 */\n                strcpy(VAR_33[VAR_12 - 1], VAR_25);\n            }\n        }\n\n    }/* COMMENT_11 */\n\n    if (!VAR_11) {\n        fprintf(VAR_38,\n                \"[ERROR] No slices with this pattern founded !! Please check input volume name\\n\");\n        return NULL;\n    }\n    /* COMMENT_12 */\n                                                                                                           \n                    \n       \n\n    for (VAR_8 = 0; VAR_8 < VAR_11; VAR_8++) {\n        int VAR_39 = VAR_13 == VAR_11 ? VAR_8 : VAR_35[VAR_8];\n        VAR_2 = fopen(VAR_33[VAR_39], \"rb\");\n        if (!VAR_2) {\n            fprintf(VAR_38, \"[ERROR] Failed to open %s for reading !\\n\", VAR_33[VAR_8]);\n            return NULL;\n        }\n        fprintf(VAR_38, \"[INFO] Loading %s \\n\", VAR_33[VAR_39]);\n\n        fseek(VAR_2, 0, VAR_40);\n        fscanf(VAR_2, \"PG%31[ \\t]%c%c%31[ \\t+-]%d%31[ \\t]%d%31[ \\t]%d\", VAR_21, &VAR_17,\n               &VAR_18, VAR_20, &VAR_5, VAR_21, &VAR_3, VAR_21, &VAR_4);\n\n        VAR_7 = 0;\n        VAR_19 = '+';\n        while (VAR_20[VAR_7] != '\\0') {\n            if (VAR_20[VAR_7] == '-') {\n                VAR_19 = '-';\n            }\n            VAR_7++;\n        }\n\n        fgetc(VAR_2);\n        if (VAR_17 == 'M' && VAR_18 == 'L') {\n            VAR_15.bigendian = 1;\n        } else if (VAR_18 == 'M' && VAR_17 == 'L') {\n            VAR_15.bigendian = 0;\n        } else {\n            fprintf(VAR_38, \"[ERROR] Bad pgx header, please check input file\\n\");\n            fclose(VAR_2);\n            return NULL;\n        }\n\n        if (VAR_8 == 0) {\n            /* COMMENT_16 */\n\n            VAR_15.x0 = VAR_1->volume_offset_x0;\n            VAR_15.y0 = VAR_1->volume_offset_y0;\n            VAR_15.z0 = VAR_1->volume_offset_z0;\n            VAR_15.w = !VAR_15.x0 ? (VAR_3 - 1) * VAR_1->subsampling_dx + 1 :\n                         VAR_15.x0 + (VAR_3 - 1) * VAR_1->subsampling_dx + 1;\n            VAR_15.h = !VAR_15.y0 ? (VAR_4 - 1) * VAR_1->subsampling_dy + 1 :\n                         VAR_15.y0 + (VAR_4 - 1) * VAR_1->subsampling_dy + 1;\n            VAR_15.l = !VAR_15.z0 ? (VAR_11 - 1) * VAR_1->subsampling_dz + 1 :\n                         VAR_15.z0 + (VAR_11 - 1) * VAR_1->subsampling_dz + 1;\n\n            if (VAR_19 == '-') {\n                VAR_15.sgnd = 1;\n            } else {\n                VAR_15.sgnd = 0;\n            }\n            VAR_15.prec = VAR_5;\n            VAR_15.bpp = VAR_5;\n            VAR_15.dcoffset = VAR_1->dcoffset;\n            VAR_15.dx = VAR_1->subsampling_dx;\n            VAR_15.dy = VAR_1->subsampling_dy;\n            VAR_15.dz = VAR_1->subsampling_dz;\n\n            /* COMMENT_17 */\n            VAR_16 = opj_volume_create(VAR_9, &VAR_15, VAR_14);\n            if (!VAR_16) {\n                fclose(VAR_2);\n                return NULL;\n            }\n            /* COMMENT_18 */\n            VAR_16->x0 = VAR_15.x0;\n            VAR_16->y0 = VAR_15.y0;\n            VAR_16->z0 = VAR_15.z0;\n            VAR_16->x1 = VAR_15.w;\n            VAR_16->y1 = VAR_15.h;\n            VAR_16->z1 = VAR_15.l;\n\n            /* COMMENT_19 */\n            VAR_22 = &VAR_16->comps[0];\n\n        }/* COMMENT_20 */\n\n        VAR_6 = VAR_3 * VAR_4 * VAR_8;\n\n        for (VAR_7 = 0; VAR_7 < VAR_3 * VAR_4; VAR_7++) {\n            int VAR_41;\n            if (VAR_22->prec <= 8) {\n                if (!VAR_22->sgnd) {\n                    VAR_41 = readuchar(VAR_2);\n                } else {\n                    VAR_41 = (char) readuchar(VAR_2);\n                }\n            } else if (VAR_22->prec <= 16) {\n                if (!VAR_22->sgnd) {\n                    VAR_41 = readushort(VAR_2, VAR_15.bigendian);\n                } else {\n                    VAR_41 = (short) readushort(VAR_2, VAR_15.bigendian);\n                }\n            } else {\n                if (!VAR_22->sgnd) {\n                    VAR_41 = readuint(VAR_2, VAR_15.bigendian);\n                } else {\n                    VAR_41 = (int) readuint(VAR_2, VAR_15.bigendian);\n                }\n            }\n            if (VAR_41 > VAR_10) {\n                VAR_10 = VAR_41;\n            }\n            VAR_22->data[VAR_7 + VAR_6] = VAR_41;\n\n        }\n        fclose(VAR_2);\n    } /* COMMENT_21 */\n    VAR_22->bpp = int_floorlog2(VAR_10) + 1;\n    if (VAR_11 != 1) {\n        closedir(VAR_23);\n    }\n    /* COMMENT_22 */\n    return VAR_16;\n}",
  "func_graph_path": "uclouvain/openjpeg/0bc90e4062a5f9258c91eca018c019b179066c62/convert.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -138,8 +138,8 @@\n         fprintf(stdout, \"[INFO] Loading %s \\n\", pgxfiles[pos]);\n \n         fseek(f, 0, SEEK_SET);\n-        fscanf(f, \"PG%[ \\t]%c%c%[ \\t+-]%d%[ \\t]%d%[ \\t]%d\", temp, &endian1, &endian2,\n-               signtmp, &prec, temp, &w, temp, &h);\n+        fscanf(f, \"PG%31[ \\t]%c%c%31[ \\t+-]%d%31[ \\t]%d%31[ \\t]%d\", temp, &endian1,\n+               &endian2, signtmp, &prec, temp, &w, temp, &h);\n \n         i = 0;\n         sign = '+';",
  "diff_line_info": {
    "deleted_lines": [
      "        fscanf(f, \"PG%[ \\t]%c%c%[ \\t+-]%d%[ \\t]%d%[ \\t]%d\", temp, &endian1, &endian2,",
      "               signtmp, &prec, temp, &w, temp, &h);"
    ],
    "added_lines": [
      "        fscanf(f, \"PG%31[ \\t]%c%c%31[ \\t+-]%d%31[ \\t]%d%31[ \\t]%d\", temp, &endian1,",
      "               &endian2, signtmp, &prec, temp, &w, temp, &h);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/uclouvain/openjpeg/pull/1160",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/uclouvain/openjpeg/pull/1160: 403 Client Error: Forbidden for url: https://api.github.com/repos/uclouvain/openjpeg/pulls/1160",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}