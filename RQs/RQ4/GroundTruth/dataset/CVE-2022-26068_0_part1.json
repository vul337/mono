{
  "cve_id": "CVE-2022-26068",
  "cwe_ids": [
    "CWE-22"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:N/A:N",
  "cvss_is_v3": false,
  "repo_name": "pistacheio/pistache",
  "commit_msg": "fix(swagger/security): ensure that the requested file is in the UI directory\n\nThe Rest::Swagger class didn't check if the file asked from the user was\ncontained in the UI directory, thus allowing users to access arbitrary\nfiles in the filesystem.\n\nThanks to Kirill Efimov (@Kirill89) and the Snyk Security team for\nfinding and reporting the vulnerability to the Pistache team.",
  "commit_hash": "4ba6da096611d11849aa37ee342c032a306ee885",
  "git_url": "https://github.com/pistacheio/pistache/commit/4ba6da096611d11849aa37ee342c032a306ee885",
  "file_path": "src/common/description.cc",
  "func_name": "Swagger::install",
  "func_before": "void Swagger::install(Rest::Router& router)\n    {\n\n        Route::Handler uiHandler = [=](const Rest::Request& req,\n                                       Http::ResponseWriter response) {\n            const auto& res = req.resource();\n\n            /*\n     * @Export might be useful for routing also. Make it public or merge it with\n     * the Fragment class\n     */\n\n            struct Path\n            {\n                explicit Path(const std::string& value)\n                    : value(value)\n                    , trailingSlashValue(value)\n                {\n                    if (trailingSlashValue.empty() || trailingSlashValue.back() != '/')\n                        trailingSlashValue += '/';\n                }\n\n                static bool hasTrailingSlash(const Rest::Request& req)\n                {\n                    auto res_ = req.resource();\n                    return res_.back() == '/';\n                }\n\n                std::string stripPrefix(const Rest::Request& req)\n                {\n                    auto res_ = req.resource();\n                    if (!res_.compare(0, value.size(), value))\n                    {\n                        return res_.substr(value.size());\n                    }\n                    return res_;\n                }\n\n                bool matches(const Rest::Request& req) const\n                {\n                    const auto& res_ = req.resource();\n                    if (value == res_)\n                        return true;\n\n                    if (res_ == trailingSlashValue)\n                        return true;\n\n                    return false;\n                }\n\n                bool isPrefix(const Rest::Request& req)\n                {\n                    const auto& res_ = req.resource();\n                    return !res_.compare(0, value.size(), value);\n                }\n\n                [[maybe_unused]] const std::string& withTrailingSlash() const\n                {\n                    return trailingSlashValue;\n                }\n\n                std::string join(const std::string& value) const\n                {\n                    std::string val;\n                    if (value[0] == '/')\n                        val = value.substr(1);\n                    else\n                        val = value;\n                    return trailingSlashValue + val;\n                }\n\n            private:\n                std::string value;\n                std::string trailingSlashValue;\n            };\n\n            Path ui(uiPath_);\n            Path uiDir(uiDirectory_);\n\n            if (ui.matches(req))\n            {\n                if (!Path::hasTrailingSlash(req))\n                {\n                    response.headers().add<Http::Header::Location>(uiPath_ + '/');\n\n                    response.send(Http::Code::Moved_Permanently);\n                }\n                else\n                {\n                    auto index = uiDir.join(\"index.html\");\n                    Http::serveFile(response, index);\n                }\n                return Route::Result::Ok;\n            }\n            else if (ui.isPrefix(req))\n            {\n                auto file = ui.stripPrefix(req);\n                auto path = uiDir.join(file);\n                Http::serveFile(response, path);\n                return Route::Result::Ok;\n            }\n\n            else if (res == apiPath_)\n            {\n                response.send(Http::Code::Ok, serializer_(description_),\n                              MIME(Application, Json));\n                return Route::Result::Ok;\n            }\n\n            return Route::Result::Failure;\n        };\n\n        router.addCustomHandler(uiHandler);\n    }",
  "abstract_func_before": "void Swagger::install(Rest::Router& VAR_0)\n    {\n\n        Route::Handler VAR_1 = [=](const Rest::Request& VAR_2,\n                                       Http::ResponseWriter VAR_3) {\n            const auto& VAR_4 = VAR_2.resource();\n\n            /* COMMENT_0 */\n                                                                                \n                         \n       \n\n            struct Path\n            {\n                explicit Path(const std::string& VAR_5)\n                    : value(VAR_5)\n                    , trailingSlashValue(VAR_5)\n                {\n                    if (VAR_6.empty() || VAR_6.back() != '/')\n                        VAR_6 += '/';\n                }\n\n                static bool hasTrailingSlash(const Rest::Request& VAR_2)\n                {\n                    auto VAR_7 = VAR_2.resource();\n                    return VAR_7.back() == '/';\n                }\n\n                std::string stripPrefix(const Rest::Request& VAR_2)\n                {\n                    auto VAR_7 = VAR_2.resource();\n                    if (!VAR_7.compare(0, VAR_5.size(), VAR_5))\n                    {\n                        return VAR_7.substr(VAR_5.size());\n                    }\n                    return VAR_7;\n                }\n\n                bool matches(const Rest::Request& VAR_2) const\n                {\n                    const auto& VAR_7 = VAR_2.resource();\n                    if (VAR_5 == VAR_7)\n                        return true;\n\n                    if (VAR_7 == VAR_6)\n                        return true;\n\n                    return false;\n                }\n\n                bool isPrefix(const Rest::Request& VAR_2)\n                {\n                    const auto& VAR_7 = VAR_2.resource();\n                    return !VAR_7.compare(0, VAR_5.size(), VAR_5);\n                }\n\n                [[VAR_8]] const std::string& withTrailingSlash() const\n                {\n                    return VAR_6;\n                }\n\n                std::string join(const std::string& VAR_5) const\n                {\n                    std::string VAR_9;\n                    if (VAR_5[0] == '/')\n                        VAR_9 = VAR_5.substr(1);\n                    else\n                        VAR_9 = VAR_5;\n                    return VAR_6 + VAR_9;\n                }\n\n            private:\n                std::string value;\n                std::string trailingSlashValue;\n            };\n\n            Path ui(uiPath_);\n            Path uiDir(uiDirectory_);\n\n            if (VAR_10.matches(VAR_2))\n            {\n                if (!Path::hasTrailingSlash(VAR_2))\n                {\n                    VAR_3.headers().add<Http::Header::Location>(uiPath_ + '/');\n\n                    VAR_3.send(Http::Code::Moved_Permanently);\n                }\n                else\n                {\n                    auto VAR_11 = VAR_12.join(\"index.html\");\n                    Http::serveFile(VAR_3, VAR_11);\n                }\n                return Route::Result::Ok;\n            }\n            else if (VAR_10.isPrefix(VAR_2))\n            {\n                auto VAR_13 = VAR_10.stripPrefix(VAR_2);\n                auto VAR_14 = VAR_12.join(VAR_13);\n                Http::serveFile(VAR_3, VAR_14);\n                return Route::Result::Ok;\n            }\n\n            else if (VAR_4 == VAR_15)\n            {\n                VAR_3.send(Http::Code::Ok, serializer_(VAR_16),\n                              MIME(VAR_17, VAR_18));\n                return Route::Result::Ok;\n            }\n\n            return Route::Result::Failure;\n        };\n\n        VAR_0.addCustomHandler(VAR_1);\n    }",
  "func_graph_path_before": "pistacheio/pistache/4ba6da096611d11849aa37ee342c032a306ee885/description.cc/vul/before/1.json",
  "func": "void Swagger::install(Rest::Router& router)\n    {\n\n        Route::Handler uiHandler = [=](const Rest::Request& req,\n                                       Http::ResponseWriter response) {\n            const auto& res = req.resource();\n\n            /*\n             * @Export might be useful for routing also. Make it public or merge it with\n             * the Fragment class\n             */\n\n            struct Path\n            {\n                explicit Path(const std::string& value)\n                    : value(value)\n                    , trailingSlashValue(value)\n                {\n                    if (trailingSlashValue.empty() || trailingSlashValue.back() != '/')\n                        trailingSlashValue += '/';\n                }\n\n                static bool hasTrailingSlash(const Rest::Request& req)\n                {\n                    auto res_ = req.resource();\n                    return res_.back() == '/';\n                }\n\n                std::string stripPrefix(const Rest::Request& req)\n                {\n                    auto res_ = req.resource();\n                    if (!res_.compare(0, value.size(), value))\n                    {\n                        return res_.substr(value.size());\n                    }\n                    return res_;\n                }\n\n                bool matches(const Rest::Request& req) const\n                {\n                    const auto& res_ = req.resource();\n                    if (value == res_)\n                        return true;\n\n                    if (res_ == trailingSlashValue)\n                        return true;\n\n                    return false;\n                }\n\n                bool isPrefix(const Rest::Request& req)\n                {\n                    const auto& res_ = req.resource();\n                    return !res_.compare(0, value.size(), value);\n                }\n\n                [[maybe_unused]] const std::string& withTrailingSlash() const\n                {\n                    return trailingSlashValue;\n                }\n\n                std::string join(const std::string& value) const\n                {\n                    std::string val;\n                    if (value[0] == '/')\n                        val = value.substr(1);\n                    else\n                        val = value;\n                    return trailingSlashValue + val;\n                }\n\n            private:\n                std::string value;\n                std::string trailingSlashValue;\n            };\n\n            Path ui(uiPath_);\n            Path uiDir(uiDirectory_);\n\n            if (ui.matches(req))\n            {\n                if (!Path::hasTrailingSlash(req))\n                {\n                    response.headers().add<Http::Header::Location>(uiPath_ + '/');\n\n                    response.send(Http::Code::Moved_Permanently);\n                }\n                else\n                {\n                    auto index = uiDir.join(\"index.html\");\n                    Http::serveFile(response, index);\n                }\n                return Route::Result::Ok;\n            }\n            else if (ui.isPrefix(req))\n            {\n                auto file = ui.stripPrefix(req);\n                auto path = std::filesystem::canonical(uiDir.join(file)).string();\n\n                // Check if the requested file is contained in the uiDirectory\n                // to prevent path traversal vulnerabilities.\n                // In C++20, use std::string::starts_with()\n                if (path.rfind(uiDirectory_, 0) == 0)\n                {\n                    Http::serveFile(response, path);\n                    return Route::Result::Ok;\n                }\n                else\n                {\n                    response.send(Http::Code::Not_Found);\n                    return Route::Result::Failure;\n                }\n            }\n\n            else if (res == apiPath_)\n            {\n                response.send(Http::Code::Ok, serializer_(description_),\n                              MIME(Application, Json));\n                return Route::Result::Ok;\n            }\n\n            return Route::Result::Failure;\n        };\n\n        router.addCustomHandler(uiHandler);\n    }",
  "abstract_func": "void Swagger::install(Rest::Router& VAR_0)\n    {\n\n        Route::Handler VAR_1 = [=](const Rest::Request& VAR_2,\n                                       Http::ResponseWriter VAR_3) {\n            const auto& VAR_4 = VAR_2.resource();\n\n            /* COMMENT_0 */\n                                                                                        \n                                 \n               \n\n            struct Path\n            {\n                explicit Path(const std::string& VAR_5)\n                    : value(VAR_5)\n                    , trailingSlashValue(VAR_5)\n                {\n                    if (VAR_6.empty() || VAR_6.back() != '/')\n                        VAR_6 += '/';\n                }\n\n                static bool hasTrailingSlash(const Rest::Request& VAR_2)\n                {\n                    auto VAR_7 = VAR_2.resource();\n                    return VAR_7.back() == '/';\n                }\n\n                std::string stripPrefix(const Rest::Request& VAR_2)\n                {\n                    auto VAR_7 = VAR_2.resource();\n                    if (!VAR_7.compare(0, VAR_5.size(), VAR_5))\n                    {\n                        return VAR_7.substr(VAR_5.size());\n                    }\n                    return VAR_7;\n                }\n\n                bool matches(const Rest::Request& VAR_2) const\n                {\n                    const auto& VAR_7 = VAR_2.resource();\n                    if (VAR_5 == VAR_7)\n                        return true;\n\n                    if (VAR_7 == VAR_6)\n                        return true;\n\n                    return false;\n                }\n\n                bool isPrefix(const Rest::Request& VAR_2)\n                {\n                    const auto& VAR_7 = VAR_2.resource();\n                    return !VAR_7.compare(0, VAR_5.size(), VAR_5);\n                }\n\n                [[VAR_8]] const std::string& withTrailingSlash() const\n                {\n                    return VAR_6;\n                }\n\n                std::string join(const std::string& VAR_5) const\n                {\n                    std::string VAR_9;\n                    if (VAR_5[0] == '/')\n                        VAR_9 = VAR_5.substr(1);\n                    else\n                        VAR_9 = VAR_5;\n                    return VAR_6 + VAR_9;\n                }\n\n            private:\n                std::string value;\n                std::string trailingSlashValue;\n            };\n\n            Path ui(uiPath_);\n            Path uiDir(uiDirectory_);\n\n            if (VAR_10.matches(VAR_2))\n            {\n                if (!Path::hasTrailingSlash(VAR_2))\n                {\n                    VAR_3.headers().add<Http::Header::Location>(uiPath_ + '/');\n\n                    VAR_3.send(Http::Code::Moved_Permanently);\n                }\n                else\n                {\n                    auto VAR_11 = VAR_12.join(\"index.html\");\n                    Http::serveFile(VAR_3, VAR_11);\n                }\n                return Route::Result::Ok;\n            }\n            else if (VAR_10.isPrefix(VAR_2))\n            {\n                auto VAR_13 = VAR_10.stripPrefix(VAR_2);\n                auto VAR_14 = std::filesystem::canonical(VAR_12.join(VAR_13)).string();\n\n                /* COMMENT_4 */\n                /* COMMENT_5 */\n                /* COMMENT_6 */\n                if (VAR_14.rfind(uiDirectory_, 0) == 0)\n                {\n                    Http::serveFile(VAR_3, VAR_14);\n                    return Route::Result::Ok;\n                }\n                else\n                {\n                    VAR_3.send(Http::Code::Not_Found);\n                    return Route::Result::Failure;\n                }\n            }\n\n            else if (VAR_4 == VAR_15)\n            {\n                VAR_3.send(Http::Code::Ok, serializer_(VAR_16),\n                              MIME(VAR_17, VAR_18));\n                return Route::Result::Ok;\n            }\n\n            return Route::Result::Failure;\n        };\n\n        VAR_0.addCustomHandler(VAR_1);\n    }",
  "func_graph_path": "pistacheio/pistache/4ba6da096611d11849aa37ee342c032a306ee885/description.cc/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -6,9 +6,9 @@\n             const auto& res = req.resource();\n \n             /*\n-     * @Export might be useful for routing also. Make it public or merge it with\n-     * the Fragment class\n-     */\n+             * @Export might be useful for routing also. Make it public or merge it with\n+             * the Fragment class\n+             */\n \n             struct Path\n             {\n@@ -95,9 +95,21 @@\n             else if (ui.isPrefix(req))\n             {\n                 auto file = ui.stripPrefix(req);\n-                auto path = uiDir.join(file);\n-                Http::serveFile(response, path);\n-                return Route::Result::Ok;\n+                auto path = std::filesystem::canonical(uiDir.join(file)).string();\n+\n+                // Check if the requested file is contained in the uiDirectory\n+                // to prevent path traversal vulnerabilities.\n+                // In C++20, use std::string::starts_with()\n+                if (path.rfind(uiDirectory_, 0) == 0)\n+                {\n+                    Http::serveFile(response, path);\n+                    return Route::Result::Ok;\n+                }\n+                else\n+                {\n+                    response.send(Http::Code::Not_Found);\n+                    return Route::Result::Failure;\n+                }\n             }\n \n             else if (res == apiPath_)",
  "diff_line_info": {
    "deleted_lines": [
      "     * @Export might be useful for routing also. Make it public or merge it with",
      "     * the Fragment class",
      "     */",
      "                auto path = uiDir.join(file);",
      "                Http::serveFile(response, path);",
      "                return Route::Result::Ok;"
    ],
    "added_lines": [
      "             * @Export might be useful for routing also. Make it public or merge it with",
      "             * the Fragment class",
      "             */",
      "                auto path = std::filesystem::canonical(uiDir.join(file)).string();",
      "",
      "                // Check if the requested file is contained in the uiDirectory",
      "                // to prevent path traversal vulnerabilities.",
      "                // In C++20, use std::string::starts_with()",
      "                if (path.rfind(uiDirectory_, 0) == 0)",
      "                {",
      "                    Http::serveFile(response, path);",
      "                    return Route::Result::Ok;",
      "                }",
      "                else",
      "                {",
      "                    response.send(Http::Code::Not_Found);",
      "                    return Route::Result::Failure;",
      "                }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/pistacheio/pistache/pull/1065",
  "description": {
    "pr_info": {
      "title": "fix(swagger/security): ensure that the requested file is in the UI directory",
      "number": 1065
    },
    "comment": [
      "The `Rest::Swagger` class didn't check if the file asked from the user was contained in the UI directory, thus allowing users to access arbitrary files in the filesystem.\r\n\r\nThanks to Kirill Efimov (@Kirill89) and the Snyk Security team (@snyk) for finding and reporting the vulnerability to the Pistache team.\r\n\r\nCloses #1064 ",
      "abidiff reports a potential ABI change, but that's probably related to the inclusion of `<filesystem>`. It exited with status 4, that according to the [manual](https://sourceware.org/libabigail/manual/abidiff.html#return-values) maps to `ABIDIFF_ABI_CHANGE`, meaning that the ABI changed but non necessarily in a breaking manner. As all the changes have been applied to internal code, I believe that this failure can be ignored.\r\n\r\nEdit: they seem template instantiations"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0  \n\n**Step-by-Step Explanation:**\n\n1. **Input Analysis:** Commit message and vulnerability description both clearly indicate a security issue related to file access. The code diff adds a security check.\n2. **Consistency Check:** The changes match the described vulnerability.\n3. **Purpose Evaluation:** The fix prevents unauthorized file access, a core security concern.\n4. **Security Assessment:** Explicit security fix for a known vulnerability.\n5. **Classification:** Confirmed as a security fix with high confidence.\n\n**Final Answer:**  \n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}