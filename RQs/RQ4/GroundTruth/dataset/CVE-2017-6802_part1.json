{
  "cve_id": "CVE-2017-6802",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "Yeraze/ytnef",
  "commit_msg": "Added safety check for Compressed RTF Streams\n\nYou could potentially overflow the input pointer.\n\nin response to #34",
  "commit_hash": "22f8346c8d4f0020a40d9f258fdb3bfc097359cc",
  "git_url": "https://github.com/Yeraze/ytnef/commit/22f8346c8d4f0020a40d9f258fdb3bfc097359cc",
  "file_path": "lib/ytnef.c",
  "func_name": "DecompressRTF",
  "func_before": "BYTE *DecompressRTF(variableLength *p, int *size) {\n  BYTE *dst; // destination for uncompressed bytes\n  BYTE *src;\n  unsigned int in;\n  unsigned int out;\n  variableLength comp_Prebuf;\n  ULONG compressedSize, uncompressedSize, magic;\n\n  comp_Prebuf.size = strlen(RTF_PREBUF);\n  comp_Prebuf.data = calloc(comp_Prebuf.size+1, 1);\n  ALLOCCHECK_CHAR(comp_Prebuf.data);\n  memcpy(comp_Prebuf.data, RTF_PREBUF, comp_Prebuf.size);\n\n  src = p->data;\n  in = 0;\n\n  if (p->size < 20) {\n    printf(\"File too small\\n\");\n    return(NULL);\n  }\n  compressedSize = (ULONG)SwapDWord((BYTE*)src + in, 4);\n  in += 4;\n  uncompressedSize = (ULONG)SwapDWord((BYTE*)src + in, 4);\n  in += 4;\n  magic = SwapDWord((BYTE*)src + in, 4);\n  in += 4;\n  in += 4;\n\n  // check size excluding the size field itself\n  if (compressedSize != p->size - 4) {\n    printf(\" Size Mismatch: %u != %i\\n\", compressedSize, p->size - 4);\n    free(comp_Prebuf.data);\n    return NULL;\n  }\n\n  // process the data\n  if (magic == 0x414c454d) {\n    // magic number that identifies the stream as a uncompressed stream\n    dst = calloc(uncompressedSize, 1);\n    ALLOCCHECK_CHAR(dst);\n    memcpy(dst, src + 4, uncompressedSize);\n  } else if (magic == 0x75465a4c) {\n    // magic number that identifies the stream as a compressed stream\n    int flagCount = 0;\n    int flags = 0;\n    // Prevent overflow on 32 Bit Systems\n    if (comp_Prebuf.size >= INT_MAX - uncompressedSize) {\n       printf(\"Corrupted file\\n\");\n       exit(-1);\n    }\n    dst = calloc(comp_Prebuf.size + uncompressedSize, 1);\n    ALLOCCHECK_CHAR(dst);\n    memcpy(dst, comp_Prebuf.data, comp_Prebuf.size);\n    out = comp_Prebuf.size;\n    while (out < (comp_Prebuf.size + uncompressedSize)) {\n      // each flag byte flags 8 literals/references, 1 per bit\n      flags = (flagCount++ % 8 == 0) ? src[in++] : flags >> 1;\n      if ((flags & 1) == 1) { // each flag bit is 1 for reference, 0 for literal\n        unsigned int offset = src[in++];\n        unsigned int length = src[in++];\n        unsigned int end;\n        offset = (offset << 4) | (length >> 4); // the offset relative to block start\n        length = (length & 0xF) + 2; // the number of bytes to copy\n        // the decompression buffer is supposed to wrap around back\n        // to the beginning when the end is reached. we save the\n        // need for such a buffer by pointing straight into the data\n        // buffer, and simulating this behaviour by modifying the\n        // pointers appropriately.\n        offset = (out / 4096) * 4096 + offset;\n        if (offset >= out) // take from previous block\n          offset -= 4096;\n        // note: can't use System.arraycopy, because the referenced\n        // bytes can cross through the current out position.\n        end = offset + length;\n        while ((offset < end) && (out < (comp_Prebuf.size + uncompressedSize))\n             && (offset < (comp_Prebuf.size + uncompressedSize)))\n          dst[out++] = dst[offset++];\n      } else { // literal\n        if ((out >= (comp_Prebuf.size + uncompressedSize)) ||\n            (in >= p->size)) {\n          printf(\"Corrupted stream\\n\");\n          exit(-1);\n        }\n        dst[out++] = src[in++];\n      }\n    }\n    // copy it back without the prebuffered data\n    src = dst;\n    dst = calloc(uncompressedSize, 1);\n    ALLOCCHECK_CHAR(dst);\n    memcpy(dst, src + comp_Prebuf.size, uncompressedSize);\n    free(src);\n    *size = uncompressedSize;\n    free(comp_Prebuf.data);\n    return dst;\n  } else { // unknown magic number\n    printf(\"Unknown compression type (magic number %x)\\n\", magic);\n  }\n  free(comp_Prebuf.data);\n  return NULL;\n}",
  "abstract_func_before": "BYTE *DecompressRTF(variableLength *VAR_0, int *VAR_1) {\n  BYTE *VAR_2; /* COMMENT_0 */\n  BYTE *VAR_3;\n  unsigned int VAR_4;\n  unsigned int VAR_5;\n  variableLength VAR_6;\n  ULONG VAR_7, VAR_8, VAR_9;\n\n  VAR_6.size = strlen(VAR_10);\n  VAR_6.data = calloc(VAR_6.size+1, 1);\n  ALLOCCHECK_CHAR(VAR_6.data);\n  memcpy(VAR_6.data, VAR_10, VAR_6.size);\n\n  VAR_3 = VAR_0->data;\n  VAR_4 = 0;\n\n  if (VAR_0->size < 20) {\n    printf(\"File too small\\n\");\n    return(NULL);\n  }\n  VAR_7 = (ULONG)SwapDWord((BYTE*)VAR_3 + VAR_4, 4);\n  VAR_4 += 4;\n  VAR_8 = (ULONG)SwapDWord((BYTE*)VAR_3 + VAR_4, 4);\n  VAR_4 += 4;\n  VAR_9 = SwapDWord((BYTE*)VAR_3 + VAR_4, 4);\n  VAR_4 += 4;\n  VAR_4 += 4;\n\n  /* COMMENT_1 */\n  if (VAR_7 != VAR_0->size - 4) {\n    printf(\" Size Mismatch: %u != %i\\n\", VAR_7, VAR_0->size - 4);\n    free(VAR_6.data);\n    return NULL;\n  }\n\n  /* COMMENT_2 */\n  if (VAR_9 == 0x414c454d) {\n    /* COMMENT_3 */\n    VAR_2 = calloc(VAR_8, 1);\n    ALLOCCHECK_CHAR(VAR_2);\n    memcpy(VAR_2, VAR_3 + 4, VAR_8);\n  } else if (VAR_9 == 0x75465a4c) {\n    /* COMMENT_4 */\n    int VAR_11 = 0;\n    int VAR_12 = 0;\n    /* COMMENT_5 */\n    if (VAR_6.size >= VAR_13 - VAR_8) {\n       printf(\"Corrupted file\\n\");\n       exit(-1);\n    }\n    VAR_2 = calloc(VAR_6.size + VAR_8, 1);\n    ALLOCCHECK_CHAR(VAR_2);\n    memcpy(VAR_2, VAR_6.data, VAR_6.size);\n    VAR_5 = VAR_6.size;\n    while (VAR_5 < (VAR_6.size + VAR_8)) {\n      /* COMMENT_6 */\n      VAR_12 = (VAR_11++ % 8 == 0) ? VAR_3[VAR_4++] : VAR_12 >> 1;\n      if ((VAR_12 & 1) == 1) { /* COMMENT_7 */\n        unsigned int VAR_14 = VAR_3[VAR_4++];\n        unsigned int VAR_15 = VAR_3[VAR_4++];\n        unsigned int VAR_16;\n        VAR_14 = (VAR_14 << 4) | (VAR_15 >> 4); /* COMMENT_8 */\n        VAR_15 = (VAR_15 & 0xF) + 2; /* COMMENT_9 */\n        /* COMMENT_10 */\n        /* COMMENT_11 */\n        /* COMMENT_12 */\n        /* COMMENT_13 */\n        /* COMMENT_14 */\n        VAR_14 = (VAR_5 / 4096) * 4096 + VAR_14;\n        if (VAR_14 >= VAR_5) /* COMMENT_15 */\n          VAR_14 -= 4096;\n        /* COMMENT_16 */\n        /* COMMENT_17 */\n        VAR_16 = VAR_14 + VAR_15;\n        while ((VAR_14 < VAR_16) && (VAR_5 < (VAR_6.size + VAR_8))\n             && (VAR_14 < (VAR_6.size + VAR_8)))\n          VAR_2[VAR_5++] = VAR_2[VAR_14++];\n      } else { /* COMMENT_18 */\n        if ((VAR_5 >= (VAR_6.size + VAR_8)) ||\n            (VAR_4 >= VAR_0->size)) {\n          printf(\"Corrupted stream\\n\");\n          exit(-1);\n        }\n        VAR_2[VAR_5++] = VAR_3[VAR_4++];\n      }\n    }\n    /* COMMENT_19 */\n    VAR_3 = VAR_2;\n    VAR_2 = calloc(VAR_8, 1);\n    ALLOCCHECK_CHAR(VAR_2);\n    memcpy(VAR_2, VAR_3 + VAR_6.size, VAR_8);\n    free(VAR_3);\n    *VAR_1 = VAR_8;\n    free(VAR_6.data);\n    return VAR_2;\n  } else { /* COMMENT_20 */\n    printf(\"Unknown compression type (magic number %x)\\n\", VAR_9);\n  }\n  free(VAR_6.data);\n  return NULL;\n}",
  "func_graph_path_before": "Yeraze/ytnef/22f8346c8d4f0020a40d9f258fdb3bfc097359cc/ytnef.c/vul/before/0.json",
  "func": "BYTE *DecompressRTF(variableLength *p, int *size) {\n  BYTE *dst; // destination for uncompressed bytes\n  BYTE *src;\n  unsigned int in;\n  unsigned int out;\n  variableLength comp_Prebuf;\n  ULONG compressedSize, uncompressedSize, magic;\n\n  comp_Prebuf.size = strlen(RTF_PREBUF);\n  comp_Prebuf.data = calloc(comp_Prebuf.size+1, 1);\n  ALLOCCHECK_CHAR(comp_Prebuf.data);\n  memcpy(comp_Prebuf.data, RTF_PREBUF, comp_Prebuf.size);\n\n  src = p->data;\n  in = 0;\n\n  if (p->size < 20) {\n    printf(\"File too small\\n\");\n    return(NULL);\n  }\n  compressedSize = (ULONG)SwapDWord((BYTE*)src + in, 4);\n  in += 4;\n  uncompressedSize = (ULONG)SwapDWord((BYTE*)src + in, 4);\n  in += 4;\n  magic = SwapDWord((BYTE*)src + in, 4);\n  in += 4;\n  in += 4;\n\n  // check size excluding the size field itself\n  if (compressedSize != p->size - 4) {\n    printf(\" Size Mismatch: %u != %i\\n\", compressedSize, p->size - 4);\n    free(comp_Prebuf.data);\n    return NULL;\n  }\n\n  // process the data\n  if (magic == 0x414c454d) {\n    // magic number that identifies the stream as a uncompressed stream\n    dst = calloc(uncompressedSize, 1);\n    ALLOCCHECK_CHAR(dst);\n    memcpy(dst, src + 4, uncompressedSize);\n  } else if (magic == 0x75465a4c) {\n    // magic number that identifies the stream as a compressed stream\n    int flagCount = 0;\n    int flags = 0;\n    // Prevent overflow on 32 Bit Systems\n    if (comp_Prebuf.size >= INT_MAX - uncompressedSize) {\n       printf(\"Corrupted file\\n\");\n       exit(-1);\n    }\n    dst = calloc(comp_Prebuf.size + uncompressedSize, 1);\n    ALLOCCHECK_CHAR(dst);\n    memcpy(dst, comp_Prebuf.data, comp_Prebuf.size);\n    out = comp_Prebuf.size;\n    while ((out < (comp_Prebuf.size + uncompressedSize)) && (in < p->size)) {\n      // each flag byte flags 8 literals/references, 1 per bit\n      flags = (flagCount++ % 8 == 0) ? src[in++] : flags >> 1;\n      if ((flags & 1) == 1) { // each flag bit is 1 for reference, 0 for literal\n        unsigned int offset = src[in++];\n        unsigned int length = src[in++];\n        unsigned int end;\n        offset = (offset << 4) | (length >> 4); // the offset relative to block start\n        length = (length & 0xF) + 2; // the number of bytes to copy\n        // the decompression buffer is supposed to wrap around back\n        // to the beginning when the end is reached. we save the\n        // need for such a buffer by pointing straight into the data\n        // buffer, and simulating this behaviour by modifying the\n        // pointers appropriately.\n        offset = (out / 4096) * 4096 + offset;\n        if (offset >= out) // take from previous block\n          offset -= 4096;\n        // note: can't use System.arraycopy, because the referenced\n        // bytes can cross through the current out position.\n        end = offset + length;\n        while ((offset < end) && (out < (comp_Prebuf.size + uncompressedSize))\n             && (offset < (comp_Prebuf.size + uncompressedSize)))\n          dst[out++] = dst[offset++];\n      } else { // literal\n        if ((out >= (comp_Prebuf.size + uncompressedSize)) ||\n            (in >= p->size)) {\n          printf(\"Corrupted stream\\n\");\n          exit(-1);\n        }\n        dst[out++] = src[in++];\n      }\n    }\n    // copy it back without the prebuffered data\n    src = dst;\n    dst = calloc(uncompressedSize, 1);\n    ALLOCCHECK_CHAR(dst);\n    memcpy(dst, src + comp_Prebuf.size, uncompressedSize);\n    free(src);\n    *size = uncompressedSize;\n    free(comp_Prebuf.data);\n    return dst;\n  } else { // unknown magic number\n    printf(\"Unknown compression type (magic number %x)\\n\", magic);\n  }\n  free(comp_Prebuf.data);\n  return NULL;\n}",
  "abstract_func": "BYTE *DecompressRTF(variableLength *VAR_0, int *VAR_1) {\n  BYTE *VAR_2; /* COMMENT_0 */\n  BYTE *VAR_3;\n  unsigned int VAR_4;\n  unsigned int VAR_5;\n  variableLength VAR_6;\n  ULONG VAR_7, VAR_8, VAR_9;\n\n  VAR_6.size = strlen(VAR_10);\n  VAR_6.data = calloc(VAR_6.size+1, 1);\n  ALLOCCHECK_CHAR(VAR_6.data);\n  memcpy(VAR_6.data, VAR_10, VAR_6.size);\n\n  VAR_3 = VAR_0->data;\n  VAR_4 = 0;\n\n  if (VAR_0->size < 20) {\n    printf(\"File too small\\n\");\n    return(NULL);\n  }\n  VAR_7 = (ULONG)SwapDWord((BYTE*)VAR_3 + VAR_4, 4);\n  VAR_4 += 4;\n  VAR_8 = (ULONG)SwapDWord((BYTE*)VAR_3 + VAR_4, 4);\n  VAR_4 += 4;\n  VAR_9 = SwapDWord((BYTE*)VAR_3 + VAR_4, 4);\n  VAR_4 += 4;\n  VAR_4 += 4;\n\n  /* COMMENT_1 */\n  if (VAR_7 != VAR_0->size - 4) {\n    printf(\" Size Mismatch: %u != %i\\n\", VAR_7, VAR_0->size - 4);\n    free(VAR_6.data);\n    return NULL;\n  }\n\n  /* COMMENT_2 */\n  if (VAR_9 == 0x414c454d) {\n    /* COMMENT_3 */\n    VAR_2 = calloc(VAR_8, 1);\n    ALLOCCHECK_CHAR(VAR_2);\n    memcpy(VAR_2, VAR_3 + 4, VAR_8);\n  } else if (VAR_9 == 0x75465a4c) {\n    /* COMMENT_4 */\n    int VAR_11 = 0;\n    int VAR_12 = 0;\n    /* COMMENT_5 */\n    if (VAR_6.size >= VAR_13 - VAR_8) {\n       printf(\"Corrupted file\\n\");\n       exit(-1);\n    }\n    VAR_2 = calloc(VAR_6.size + VAR_8, 1);\n    ALLOCCHECK_CHAR(VAR_2);\n    memcpy(VAR_2, VAR_6.data, VAR_6.size);\n    VAR_5 = VAR_6.size;\n    while ((VAR_5 < (VAR_6.size + VAR_8)) && (VAR_4 < VAR_0->size)) {\n      /* COMMENT_6 */\n      VAR_12 = (VAR_11++ % 8 == 0) ? VAR_3[VAR_4++] : VAR_12 >> 1;\n      if ((VAR_12 & 1) == 1) { /* COMMENT_7 */\n        unsigned int VAR_14 = VAR_3[VAR_4++];\n        unsigned int VAR_15 = VAR_3[VAR_4++];\n        unsigned int VAR_16;\n        VAR_14 = (VAR_14 << 4) | (VAR_15 >> 4); /* COMMENT_8 */\n        VAR_15 = (VAR_15 & 0xF) + 2; /* COMMENT_9 */\n        /* COMMENT_10 */\n        /* COMMENT_11 */\n        /* COMMENT_12 */\n        /* COMMENT_13 */\n        /* COMMENT_14 */\n        VAR_14 = (VAR_5 / 4096) * 4096 + VAR_14;\n        if (VAR_14 >= VAR_5) /* COMMENT_15 */\n          VAR_14 -= 4096;\n        /* COMMENT_16 */\n        /* COMMENT_17 */\n        VAR_16 = VAR_14 + VAR_15;\n        while ((VAR_14 < VAR_16) && (VAR_5 < (VAR_6.size + VAR_8))\n             && (VAR_14 < (VAR_6.size + VAR_8)))\n          VAR_2[VAR_5++] = VAR_2[VAR_14++];\n      } else { /* COMMENT_18 */\n        if ((VAR_5 >= (VAR_6.size + VAR_8)) ||\n            (VAR_4 >= VAR_0->size)) {\n          printf(\"Corrupted stream\\n\");\n          exit(-1);\n        }\n        VAR_2[VAR_5++] = VAR_3[VAR_4++];\n      }\n    }\n    /* COMMENT_19 */\n    VAR_3 = VAR_2;\n    VAR_2 = calloc(VAR_8, 1);\n    ALLOCCHECK_CHAR(VAR_2);\n    memcpy(VAR_2, VAR_3 + VAR_6.size, VAR_8);\n    free(VAR_3);\n    *VAR_1 = VAR_8;\n    free(VAR_6.data);\n    return VAR_2;\n  } else { /* COMMENT_20 */\n    printf(\"Unknown compression type (magic number %x)\\n\", VAR_9);\n  }\n  free(VAR_6.data);\n  return NULL;\n}",
  "func_graph_path": "Yeraze/ytnef/22f8346c8d4f0020a40d9f258fdb3bfc097359cc/ytnef.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -52,7 +52,7 @@\n     ALLOCCHECK_CHAR(dst);\n     memcpy(dst, comp_Prebuf.data, comp_Prebuf.size);\n     out = comp_Prebuf.size;\n-    while (out < (comp_Prebuf.size + uncompressedSize)) {\n+    while ((out < (comp_Prebuf.size + uncompressedSize)) && (in < p->size)) {\n       // each flag byte flags 8 literals/references, 1 per bit\n       flags = (flagCount++ % 8 == 0) ? src[in++] : flags >> 1;\n       if ((flags & 1) == 1) { // each flag bit is 1 for reference, 0 for literal",
  "diff_line_info": {
    "deleted_lines": [
      "    while (out < (comp_Prebuf.size + uncompressedSize)) {"
    ],
    "added_lines": [
      "    while ((out < (comp_Prebuf.size + uncompressedSize)) && (in < p->size)) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/Yeraze/ytnef/pull/32",
  "description": {
    "pr_info": {
      "title": "BugFix - data length error",
      "number": 32
    },
    "comment": [
      "Even tho this is a \"LONG\" type, it's actually only 4 bytes. Typecasting\r\nit to a long* caused a dereference beyond the end of the allocated\r\nregion.\r\n\r\nPotential fix for #28 .. @jmallach please review.",
      "The long -> int change looks reasonable to me, but I don't consider my C knowledge to be too good to actually act as a reviewer ;) \r\n\r\nWhat I do notice is the lack of warning reporting in general. You should use -Wall at the very least. In Debian I actually add -Wextra as well and the result is... interesting. Fedora has patches to silence all of these. ",
      "I do that myself regularly as a first-step static analysis (and I run cppcheck regularly).  All I see is some rather harmless 'unused parameters' and 'comparing int & unsigned int' warnings, nothing I consider too harmful.\r\n\r\nAre you seeing something more serious?",
      "Finally, these two new issues could probably get additional CVE numbers. I requested the others for you and can do these two as well, but you can do it using the mitre web form at https://cveform.mitre.org/",
      "Re: warnings, no. It's just I'm unused to seeing a project not using at least -Wall. I'm unsure if any of them are actually potentially dangerous or can cause problems. "
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}