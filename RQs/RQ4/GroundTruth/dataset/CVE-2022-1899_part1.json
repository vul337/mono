{
  "cve_id": "CVE-2022-1899",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "radareorg/radare2",
  "commit_msg": "Fix integer overflow in string search causing oobread ##crash\n\n* Reported by @greatergoodest via huntrdev\r\n* BountyID: 8a3dc5cb-08b3-4807-82b2-77f08c137a04\r\n* Reproducer bfileovf",
  "commit_hash": "193f4fe01d7f626e2ea937450f2e0c4604420e9d",
  "git_url": "https://github.com/radareorg/radare2/commit/193f4fe01d7f626e2ea937450f2e0c4604420e9d",
  "file_path": "libr/bin/bfile.c",
  "func_name": "string_scan_range",
  "func_before": "static int string_scan_range(RList *list, RBinFile *bf, int min,\n\t\t\t      const ut64 from, const ut64 to, int type, int raw, RBinSection *section) {\n\tRBin *bin = bf->rbin;\n\tut8 tmp[R_STRING_SCAN_BUFFER_SIZE];\n\tut64 str_start, needle = from;\n\tint count = 0, i, rc, runes;\n\tint str_type = R_STRING_TYPE_DETECT;\n\n\t// if list is null it means its gonna dump\n\tr_return_val_if_fail (bf, -1);\n\n\tif (type == -1) {\n\t\ttype = R_STRING_TYPE_DETECT;\n\t}\n\tif (from == to) {\n\t\treturn 0;\n\t}\n\tif (from > to) {\n\t\teprintf (\"Invalid range to find strings 0x%\"PFMT64x\" .. 0x%\"PFMT64x\"\\n\", from, to);\n\t\treturn -1;\n\t}\n\tst64 len = (st64)(to - from);\n\tif (len < 1 || len > ST32_MAX) {\n\t\teprintf (\"String scan range is invalid (%\"PFMT64d\" bytes)\\n\", len);\n\t\treturn -1;\n\t}\n\tut8 *buf = calloc (len, 1);\n\tif (!buf || !min) {\n\t\tfree (buf);\n\t\treturn -1;\n\t}\n\tst64 vdelta = 0, pdelta = 0;\n\tRBinSection *s = NULL;\n\tbool ascii_only = false;\n\tPJ *pj = NULL;\n\tif (bf->strmode == R_MODE_JSON && !list) {\n\t\tpj = pj_new ();\n\t\tif (pj) {\n\t\t\tpj_a (pj);\n\t\t}\n\t}\n\tr_buf_read_at (bf->buf, from, buf, len);\n\tchar *charset = r_sys_getenv (\"RABIN2_CHARSET\");\n\tif (!R_STR_ISEMPTY (charset)) {\n\t\tRCharset *ch = r_charset_new ();\n\t\tif (r_charset_use (ch, charset)) {\n\t\t\tint outlen = len * 4;\n\t\t\tut8 *out = calloc (len, 4);\n\t\t\tif (out) {\n\t\t\t\tint res = r_charset_encode_str (ch, out, outlen, buf, len);\n\t\t\t\tint i;\n\t\t\t\t// TODO unknown chars should be translated to null bytes\n\t\t\t\tfor (i = 0; i < res; i++) {\n\t\t\t\t\tif (out[i] == '?') {\n\t\t\t\t\t\tout[i] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlen = res;\n\t\t\t\tfree (buf);\n\t\t\t\tbuf = out;\n\t\t\t} else {\n\t\t\t\teprintf (\"Cannot allocate\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"Invalid value for RABIN2_CHARSET.\\n\");\n\t\t}\n\t\tr_charset_free (ch);\n\t}\n\tfree (charset);\n\tRConsIsBreaked is_breaked = (bin && bin->consb.is_breaked)? bin->consb.is_breaked: NULL;\n\t// may oobread\n\twhile (needle < to) {\n\t\tif (is_breaked && is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\t// smol optimization\n\t\tif (needle + 4 < to) {\n\t\t\tut32 n1 = r_read_le32 (buf + needle - from);\n\t\t\tif (!n1) {\n\t\t\t\tneedle += 4;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\trc = r_utf8_decode (buf + needle - from, to - needle, NULL);\n\t\tif (!rc) {\n\t\t\tneedle++;\n\t\t\tcontinue;\n\t\t}\n\t\tbool addr_aligned = !(needle % 4);\n\n\t\tif (type == R_STRING_TYPE_DETECT) {\n\t\t\tchar *w = (char *)buf + needle + rc - from;\n\t\t\tif (((to - needle) > 8 + rc)) {\n\t\t\t\t// TODO: support le and be\n\t\t\t\tbool is_wide32le = (needle + rc + 2 < to) && (!w[0] && !w[1] && !w[2] && w[3] && !w[4]);\n\t\t\t\t// reduce false positives\n\t\t\t\tif (is_wide32le) {\n\t\t\t\t\tif (!w[5] && !w[6] && w[7] && w[8]) {\n\t\t\t\t\t\tis_wide32le = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!addr_aligned) {\n\t\t\t\t\tis_wide32le = false;\n\t\t\t\t}\n\t\t\t\t///is_wide32be &= (n1 < 0xff && n11 < 0xff); // false; // n11 < 0xff;\n\t\t\t\tif (is_wide32le  && addr_aligned) {\n\t\t\t\t\tstr_type = R_STRING_TYPE_WIDE32; // asume big endian,is there little endian w32?\n\t\t\t\t} else {\n\t\t\t\t\t// bool is_wide = (n1 && n2 && n1 < 0xff && (!n2 || n2 < 0xff));\n\t\t\t\t\tbool is_wide = needle + rc + 4 < to && !w[0] && w[1] && !w[2] && w[3] && !w[4];\n\t\t\t\t\tstr_type = is_wide? R_STRING_TYPE_WIDE: R_STRING_TYPE_ASCII;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (rc > 1) {\n\t\t\t\t\tstr_type = R_STRING_TYPE_UTF8; // could be charset if set :?\n\t\t\t\t} else {\n\t\t\t\t\tstr_type = R_STRING_TYPE_ASCII;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (type == R_STRING_TYPE_UTF8) {\n\t\t\tstr_type = R_STRING_TYPE_ASCII; // initial assumption\n\t\t} else {\n\t\t\tstr_type = type;\n\t\t}\n\t\trunes = 0;\n\t\tstr_start = needle;\n\n\t\t/* Eat a whole C string */\n\t\tfor (i = 0; i < sizeof (tmp) - 4 && needle < to; i += rc) {\n\t\t\tRRune r = {0};\n\t\t\tif (str_type == R_STRING_TYPE_WIDE32) {\n\t\t\t\trc = r_utf32le_decode (buf + needle - from, to - needle, &r);\n\t\t\t\tif (rc) {\n\t\t\t\t\trc = 4;\n\t\t\t\t}\n\t\t\t} else if (str_type == R_STRING_TYPE_WIDE) {\n\t\t\t\trc = r_utf16le_decode (buf + needle - from, to - needle, &r);\n\t\t\t\tif (rc == 1) {\n\t\t\t\t\trc = 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trc = r_utf8_decode (buf + needle - from, to - needle, &r);\n\t\t\t\tif (rc > 1) {\n\t\t\t\t\tstr_type = R_STRING_TYPE_UTF8;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Invalid sequence detected */\n\t\t\tif (!rc || (ascii_only && r > 0x7f)) {\n\t\t\t\tneedle++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tneedle += rc;\n\n\t\t\tif (r_isprint (r) && r != '\\\\') {\n\t\t\t\tif (str_type == R_STRING_TYPE_WIDE32) {\n\t\t\t\t\tif (r == 0xff) {\n\t\t\t\t\t\tr = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trc = r_utf8_encode (tmp + i, r);\n\t\t\t\trunes++;\n\t\t\t\t/* Print the escape code */\n\t\t\t} else if (r && r < 0x100 && strchr (\"\\b\\v\\f\\n\\r\\t\\a\\033\\\\\", (char)r)) {\n\t\t\t\tif ((i + 32) < sizeof (tmp) && r < 93) {\n\t\t\t\t\ttmp[i + 0] = '\\\\';\n\t\t\t\t\ttmp[i + 1] = \"       abtnvfr             e  \"\n\t\t\t\t\t             \"                              \"\n\t\t\t\t\t             \"                              \"\n\t\t\t\t\t             \"  \\\\\"[r];\n\t\t\t\t} else {\n\t\t\t\t\t// string too long\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\trc = 2;\n\t\t\t\trunes++;\n\t\t\t} else {\n\t\t\t\t/* \\0 marks the end of C-strings */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\ttmp[i++] = '\\0';\n\n\t\tif (runes < min && runes >= 2 && str_type == R_STRING_TYPE_ASCII && needle < to) {\n\t\t\t// back up past the \\0 to the last char just in case it starts a wide string\n\t\t\tneedle -= 2;\n\t\t}\n\t\tif (runes >= min) {\n\t\t\t// reduce false positives\n\t\t\tint j, num_blocks, *block_list;\n\t\t\tint *freq_list = NULL, expected_ascii, actual_ascii, num_chars;\n\t\t\tif (str_type == R_STRING_TYPE_ASCII) {\n\t\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\t\tchar ch = tmp[j];\n\t\t\t\t\tif (ch != '\\n' && ch != '\\r' && ch != '\\t') {\n\t\t\t\t\t\tif (!IS_PRINTABLE (tmp[j])) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch (str_type) {\n\t\t\tcase R_STRING_TYPE_UTF8:\n\t\t\tcase R_STRING_TYPE_WIDE:\n\t\t\tcase R_STRING_TYPE_WIDE32:\n\t\t\t\tnum_blocks = 0;\n\t\t\t\tblock_list = r_utf_block_list ((const ut8*)tmp, i - 1,\n\t\t\t\t\t\tstr_type == R_STRING_TYPE_WIDE? &freq_list: NULL);\n\t\t\t\tif (block_list) {\n\t\t\t\t\tfor (j = 0; block_list[j] != -1; j++) {\n\t\t\t\t\t\tnum_blocks++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (freq_list) {\n\t\t\t\t\tnum_chars = 0;\n\t\t\t\t\tactual_ascii = 0;\n\t\t\t\t\tfor (j = 0; freq_list[j] != -1; j++) {\n\t\t\t\t\t\tnum_chars += freq_list[j];\n\t\t\t\t\t\tif (!block_list[j]) { // ASCII\n\t\t\t\t\t\t\tactual_ascii = freq_list[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree (freq_list);\n\t\t\t\t\texpected_ascii = num_blocks ? num_chars / num_blocks : 0;\n\t\t\t\t\tif (actual_ascii > expected_ascii) {\n\t\t\t\t\t\tascii_only = true;\n\t\t\t\t\t\tneedle = str_start;\n\t\t\t\t\t\tfree (block_list);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree (block_list);\n\t\t\t\tif (num_blocks > R_STRING_MAX_UNI_BLOCKS) {\n\t\t\t\t\tneedle++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tRBinString *bs = R_NEW0 (RBinString);\n\t\t\tif (!bs) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbs->type = str_type;\n\t\t\tbs->length = runes;\n\t\t\tbs->size = needle - str_start;\n\t\t\tbs->ordinal = count++;\n\t\t\t// TODO: move into adjust_offset\n\t\t\tswitch (str_type) {\n\t\t\tcase R_STRING_TYPE_WIDE:\n\t\t\t\tif (str_start - from > 1) {\n\t\t\t\t\tconst ut8 *p = buf + str_start - 2 - from;\n\t\t\t\t\tif (p[0] == 0xff && p[1] == 0xfe) {\n\t\t\t\t\t\tstr_start -= 2; // \\xff\\xfe\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase R_STRING_TYPE_WIDE32:\n\t\t\t\tif (str_start - from > 3) {\n\t\t\t\t\tconst ut8 *p = buf + str_start - 4 - from;\n\t\t\t\t\tif (p[0] == 0xff && p[1] == 0xfe) {\n\t\t\t\t\t\tstr_start -= 4; // \\xff\\xfe\\x00\\x00\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!s) {\n\t\t\t\tif (section) {\n\t\t\t\t\ts = section;\n\t\t\t\t} else if (bf->o) {\n\t\t\t\t\ts = r_bin_get_section_at (bf->o, str_start, false);\n\t\t\t\t}\n\t\t\t\tif (s) {\n\t\t\t\t\tvdelta = s->vaddr;\n\t\t\t\t\tpdelta = s->paddr;\n\t\t\t\t}\n\t\t\t}\n\t\t\tut64 baddr = bf->loadaddr && bf->o? bf->o->baddr: bf->loadaddr;\n\t\t\tbs->paddr = str_start + baddr;\n\t\t\tbs->vaddr = str_start - pdelta + vdelta + baddr;\n\t\t\tbs->string = r_str_ndup ((const char *)tmp, i);\n\t\t\tif (list) {\n\t\t\t\tr_list_append (list, bs);\n\t\t\t\tif (bf->o) {\n\t\t\t\t\tht_up_insert (bf->o->strings_db, bs->vaddr, bs);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprint_string (bf, bs, raw, pj);\n\t\t\t\tr_bin_string_free (bs);\n\t\t\t}\n\t\t\tif (from == 0 && to == bf->size) {\n\t\t\t\t/* force lookup section at the next one */\n\t\t\t\ts = NULL;\n\t\t\t}\n\t\t}\n\t\tascii_only = false;\n\t}\n\tfree (buf);\n\tif (pj) {\n\t\tpj_end (pj);\n\t\tif (bin) {\n\t\t\tRIO *io = bin->iob.io;\n\t\t\tif (io) {\n\t\t\t\tio->cb_printf (\"%s\", pj_string (pj));\n\t\t\t}\n\t\t}\n\t\tpj_free (pj);\n\t}\n\treturn count;\n}",
  "abstract_func_before": "static int string_scan_range(RList *VAR_0, RBinFile *VAR_1, int VAR_2,\n\t\t\t      const ut64 VAR_3, const ut64 VAR_4, int VAR_5, int VAR_6, RBinSection *VAR_7) {\n\tRBin *VAR_8 = VAR_1->rbin;\n\tut8 VAR_9[VAR_10];\n\tut64 VAR_11, VAR_12 = VAR_3;\n\tint VAR_13 = 0, VAR_14, VAR_15, VAR_16;\n\tint VAR_17 = VAR_18;\n\n\t/* COMMENT_0 */\n\tr_return_val_if_fail (VAR_1, -1);\n\n\tif (VAR_5 == -1) {\n\t\tVAR_5 = VAR_18;\n\t}\n\tif (VAR_3 == VAR_4) {\n\t\treturn 0;\n\t}\n\tif (VAR_3 > VAR_4) {\n\t\teprintf (\"Invalid range to find strings 0x%\"VAR_19\" .. 0x%\"VAR_19\"\\n\", VAR_3, VAR_4);\n\t\treturn -1;\n\t}\n\tst64 VAR_20 = (st64)(VAR_4 - VAR_3);\n\tif (VAR_20 < 1 || VAR_20 > VAR_21) {\n\t\teprintf (\"String scan range is invalid (%\"VAR_22\" bytes)\\n\", VAR_20);\n\t\treturn -1;\n\t}\n\tut8 *VAR_23 = calloc (VAR_20, 1);\n\tif (!VAR_23 || !VAR_2) {\n\t\tfree (VAR_23);\n\t\treturn -1;\n\t}\n\tst64 VAR_24 = 0, VAR_25 = 0;\n\tRBinSection *VAR_26 = NULL;\n\tbool VAR_27 = false;\n\tPJ *VAR_28 = NULL;\n\tif (VAR_1->strmode == VAR_29 && !VAR_0) {\n\t\tVAR_28 = pj_new ();\n\t\tif (VAR_28) {\n\t\t\tpj_a (VAR_28);\n\t\t}\n\t}\n\tr_buf_read_at (VAR_1->buf, VAR_3, VAR_23, VAR_20);\n\tchar *VAR_30 = r_sys_getenv (\"RABIN2_CHARSET\");\n\tif (!R_STR_ISEMPTY (VAR_30)) {\n\t\tRCharset *VAR_31 = r_charset_new ();\n\t\tif (r_charset_use (VAR_31, VAR_30)) {\n\t\t\tint VAR_32 = VAR_20 * 4;\n\t\t\tut8 *VAR_33 = calloc (VAR_20, 4);\n\t\t\tif (VAR_33) {\n\t\t\t\tint VAR_34 = r_charset_encode_str (VAR_31, VAR_33, VAR_32, VAR_23, VAR_20);\n\t\t\t\tint VAR_14;\n\t\t\t\t/* COMMENT_1 */\n\t\t\t\tfor (VAR_14 = 0; VAR_14 < VAR_34; VAR_14++) {\n\t\t\t\t\tif (VAR_33[VAR_14] == '?') {\n\t\t\t\t\t\tVAR_33[VAR_14] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tVAR_20 = VAR_34;\n\t\t\t\tfree (VAR_23);\n\t\t\t\tVAR_23 = VAR_33;\n\t\t\t} else {\n\t\t\t\teprintf (\"Cannot allocate\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"Invalid value for RABIN2_CHARSET.\\n\");\n\t\t}\n\t\tr_charset_free (VAR_31);\n\t}\n\tfree (VAR_30);\n\tRConsIsBreaked VAR_35 = (VAR_8 && VAR_8->consb.is_breaked)? VAR_8->consb.is_breaked: NULL;\n\t/* COMMENT_2 */\n\twhile (VAR_12 < VAR_4) {\n\t\tif (VAR_35 && VAR_35 ()) {\n\t\t\tbreak;\n\t\t}\n\t\t/* COMMENT_3 */\n\t\tif (VAR_12 + 4 < VAR_4) {\n\t\t\tut32 VAR_36 = r_read_le32 (VAR_23 + VAR_12 - VAR_3);\n\t\t\tif (!VAR_36) {\n\t\t\t\tVAR_12 += 4;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tVAR_15 = r_utf8_decode (VAR_23 + VAR_12 - VAR_3, VAR_4 - VAR_12, NULL);\n\t\tif (!VAR_15) {\n\t\t\tVAR_12++;\n\t\t\tcontinue;\n\t\t}\n\t\tbool VAR_37 = !(VAR_12 % 4);\n\n\t\tif (VAR_5 == VAR_18) {\n\t\t\tchar *VAR_38 = (char *)VAR_23 + VAR_12 + VAR_15 - VAR_3;\n\t\t\tif (((VAR_4 - VAR_12) > 8 + VAR_15)) {\n\t\t\t\t/* COMMENT_4 */\n\t\t\t\tbool VAR_39 = (VAR_12 + VAR_15 + 2 < VAR_4) && (!VAR_38[0] && !VAR_38[1] && !VAR_38[2] && VAR_38[3] && !VAR_38[4]);\n\t\t\t\t/* COMMENT_5 */\n\t\t\t\tif (VAR_39) {\n\t\t\t\t\tif (!VAR_38[5] && !VAR_38[6] && VAR_38[7] && VAR_38[8]) {\n\t\t\t\t\t\tVAR_39 = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!VAR_37) {\n\t\t\t\t\tVAR_39 = false;\n\t\t\t\t}\n\t\t\t\t/* COMMENT_6 */\n\t\t\t\tif (VAR_39  && VAR_37) {\n\t\t\t\t\tVAR_17 = VAR_40; /* COMMENT_7 */\n\t\t\t\t} else {\n\t\t\t\t\t/* COMMENT_8 */\n\t\t\t\t\tbool VAR_41 = VAR_12 + VAR_15 + 4 < VAR_4 && !VAR_38[0] && VAR_38[1] && !VAR_38[2] && VAR_38[3] && !VAR_38[4];\n\t\t\t\t\tVAR_17 = VAR_41? VAR_42: VAR_43;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (VAR_15 > 1) {\n\t\t\t\t\tVAR_17 = VAR_44; /* COMMENT_9 */\n\t\t\t\t} else {\n\t\t\t\t\tVAR_17 = VAR_43;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (VAR_5 == VAR_44) {\n\t\t\tVAR_17 = VAR_43; /* COMMENT_10 */\n\t\t} else {\n\t\t\tVAR_17 = VAR_5;\n\t\t}\n\t\tVAR_16 = 0;\n\t\tVAR_11 = VAR_12;\n\n\t\t/* COMMENT_11 */\n\t\tfor (VAR_14 = 0; VAR_14 < sizeof (VAR_9) - 4 && VAR_12 < VAR_4; VAR_14 += VAR_15) {\n\t\t\tRRune VAR_45 = {0};\n\t\t\tif (VAR_17 == VAR_40) {\n\t\t\t\tVAR_15 = r_utf32le_decode (VAR_23 + VAR_12 - VAR_3, VAR_4 - VAR_12, &VAR_45);\n\t\t\t\tif (VAR_15) {\n\t\t\t\t\tVAR_15 = 4;\n\t\t\t\t}\n\t\t\t} else if (VAR_17 == VAR_42) {\n\t\t\t\tVAR_15 = r_utf16le_decode (VAR_23 + VAR_12 - VAR_3, VAR_4 - VAR_12, &VAR_45);\n\t\t\t\tif (VAR_15 == 1) {\n\t\t\t\t\tVAR_15 = 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tVAR_15 = r_utf8_decode (VAR_23 + VAR_12 - VAR_3, VAR_4 - VAR_12, &VAR_45);\n\t\t\t\tif (VAR_15 > 1) {\n\t\t\t\t\tVAR_17 = VAR_44;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* COMMENT_12 */\n\t\t\tif (!VAR_15 || (VAR_27 && VAR_45 > 0x7f)) {\n\t\t\t\tVAR_12++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tVAR_12 += VAR_15;\n\n\t\t\tif (r_isprint (VAR_45) && VAR_45 != '\\\\') {\n\t\t\t\tif (VAR_17 == VAR_40) {\n\t\t\t\t\tif (VAR_45 == 0xff) {\n\t\t\t\t\t\tVAR_45 = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tVAR_15 = r_utf8_encode (VAR_9 + VAR_14, VAR_45);\n\t\t\t\tVAR_16++;\n\t\t\t\t/* COMMENT_13 */\n\t\t\t} else if (VAR_45 && VAR_45 < 0x100 && strchr (\"\\b\\v\\f\\n\\r\\t\\a\\033\\\\\", (char)VAR_45)) {\n\t\t\t\tif ((VAR_14 + 32) < sizeof (VAR_9) && VAR_45 < 93) {\n\t\t\t\t\tVAR_9[VAR_14 + 0] = '\\\\';\n\t\t\t\t\tVAR_9[VAR_14 + 1] = \"       abtnvfr             e  \"\n\t\t\t\t\t             \"                              \"\n\t\t\t\t\t             \"                              \"\n\t\t\t\t\t             \"  \\\\\"[VAR_45];\n\t\t\t\t} else {\n\t\t\t\t\t/* COMMENT_14 */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tVAR_15 = 2;\n\t\t\t\tVAR_16++;\n\t\t\t} else {\n\t\t\t\t/* COMMENT_15 */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tVAR_9[VAR_14++] = '\\0';\n\n\t\tif (VAR_16 < VAR_2 && VAR_16 >= 2 && VAR_17 == VAR_43 && VAR_12 < VAR_4) {\n\t\t\t/* COMMENT_16 */\n\t\t\tVAR_12 -= 2;\n\t\t}\n\t\tif (VAR_16 >= VAR_2) {\n\t\t\t/* COMMENT_5 */\n\t\t\tint VAR_46, VAR_47, *VAR_48;\n\t\t\tint *VAR_49 = NULL, VAR_50, VAR_51, VAR_52;\n\t\t\tif (VAR_17 == VAR_43) {\n\t\t\t\tfor (VAR_46 = 0; VAR_46 < VAR_14; VAR_46++) {\n\t\t\t\t\tchar VAR_31 = VAR_9[VAR_46];\n\t\t\t\t\tif (VAR_31 != '\\n' && VAR_31 != '\\r' && VAR_31 != '\\t') {\n\t\t\t\t\t\tif (!IS_PRINTABLE (VAR_9[VAR_46])) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch (VAR_17) {\n\t\t\tcase VAR_44:\n\t\t\tcase VAR_42:\n\t\t\tcase VAR_40:\n\t\t\t\tVAR_47 = 0;\n\t\t\t\tVAR_48 = r_utf_block_list ((const ut8*)VAR_9, VAR_14 - 1,\n\t\t\t\t\t\tVAR_17 == VAR_42? &VAR_49: NULL);\n\t\t\t\tif (VAR_48) {\n\t\t\t\t\tfor (VAR_46 = 0; VAR_48[VAR_46] != -1; VAR_46++) {\n\t\t\t\t\t\tVAR_47++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (VAR_49) {\n\t\t\t\t\tVAR_52 = 0;\n\t\t\t\t\tVAR_51 = 0;\n\t\t\t\t\tfor (VAR_46 = 0; VAR_49[VAR_46] != -1; VAR_46++) {\n\t\t\t\t\t\tVAR_52 += VAR_49[VAR_46];\n\t\t\t\t\t\tif (!VAR_48[VAR_46]) { /* COMMENT_17 */\n\t\t\t\t\t\t\tVAR_51 = VAR_49[VAR_46];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree (VAR_49);\n\t\t\t\t\tVAR_50 = VAR_47 ? VAR_52 / VAR_47 : 0;\n\t\t\t\t\tif (VAR_51 > VAR_50) {\n\t\t\t\t\t\tVAR_27 = true;\n\t\t\t\t\t\tVAR_12 = VAR_11;\n\t\t\t\t\t\tfree (VAR_48);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree (VAR_48);\n\t\t\t\tif (VAR_47 > VAR_53) {\n\t\t\t\t\tVAR_12++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tRBinString *VAR_54 = R_NEW0 (RBinString);\n\t\t\tif (!VAR_54) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tVAR_54->type = VAR_17;\n\t\t\tVAR_54->length = VAR_16;\n\t\t\tVAR_54->size = VAR_12 - VAR_11;\n\t\t\tVAR_54->ordinal = VAR_13++;\n\t\t\t/* COMMENT_18 */\n\t\t\tswitch (VAR_17) {\n\t\t\tcase VAR_42:\n\t\t\t\tif (VAR_11 - VAR_3 > 1) {\n\t\t\t\t\tconst ut8 *VAR_55 = VAR_23 + VAR_11 - 2 - VAR_3;\n\t\t\t\t\tif (VAR_55[0] == 0xff && VAR_55[1] == 0xfe) {\n\t\t\t\t\t\tVAR_11 -= 2; /* COMMENT_19 */\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase VAR_40:\n\t\t\t\tif (VAR_11 - VAR_3 > 3) {\n\t\t\t\t\tconst ut8 *VAR_55 = VAR_23 + VAR_11 - 4 - VAR_3;\n\t\t\t\t\tif (VAR_55[0] == 0xff && VAR_55[1] == 0xfe) {\n\t\t\t\t\t\tVAR_11 -= 4; /* COMMENT_20 */\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!VAR_26) {\n\t\t\t\tif (VAR_7) {\n\t\t\t\t\tVAR_26 = VAR_7;\n\t\t\t\t} else if (VAR_1->o) {\n\t\t\t\t\tVAR_26 = r_bin_get_section_at (VAR_1->o, VAR_11, false);\n\t\t\t\t}\n\t\t\t\tif (VAR_26) {\n\t\t\t\t\tVAR_24 = VAR_26->vaddr;\n\t\t\t\t\tVAR_25 = VAR_26->paddr;\n\t\t\t\t}\n\t\t\t}\n\t\t\tut64 VAR_56 = VAR_1->loadaddr && VAR_1->o? VAR_1->o->baddr: VAR_1->loadaddr;\n\t\t\tVAR_54->paddr = VAR_11 + VAR_56;\n\t\t\tVAR_54->vaddr = VAR_11 - VAR_25 + VAR_24 + VAR_56;\n\t\t\tVAR_54->string = r_str_ndup ((const char *)VAR_9, VAR_14);\n\t\t\tif (VAR_0) {\n\t\t\t\tr_list_append (VAR_0, VAR_54);\n\t\t\t\tif (VAR_1->o) {\n\t\t\t\t\tht_up_insert (VAR_1->o->strings_db, VAR_54->vaddr, VAR_54);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprint_string (VAR_1, VAR_54, VAR_6, VAR_28);\n\t\t\t\tr_bin_string_free (VAR_54);\n\t\t\t}\n\t\t\tif (VAR_3 == 0 && VAR_4 == VAR_1->size) {\n\t\t\t\t/* COMMENT_21 */\n\t\t\t\tVAR_26 = NULL;\n\t\t\t}\n\t\t}\n\t\tVAR_27 = false;\n\t}\n\tfree (VAR_23);\n\tif (VAR_28) {\n\t\tpj_end (VAR_28);\n\t\tif (VAR_8) {\n\t\t\tRIO *VAR_57 = VAR_8->iob.io;\n\t\t\tif (VAR_57) {\n\t\t\t\tVAR_57->cb_printf (\"%s\", pj_string (VAR_28));\n\t\t\t}\n\t\t}\n\t\tpj_free (VAR_28);\n\t}\n\treturn VAR_13;\n}",
  "func_graph_path_before": "radareorg/radare2/193f4fe01d7f626e2ea937450f2e0c4604420e9d/bfile.c/vul/before/0.json",
  "func": "static int string_scan_range(RList *list, RBinFile *bf, int min,\n\t\t\t      const ut64 from, const ut64 to, int type, int raw, RBinSection *section) {\n\tRBin *bin = bf->rbin;\n\tut8 tmp[R_STRING_SCAN_BUFFER_SIZE];\n\tut64 str_start, needle = from;\n\tint count = 0, i, rc, runes;\n\tint str_type = R_STRING_TYPE_DETECT;\n\n\t// if list is null it means its gonna dump\n\tr_return_val_if_fail (bf, -1);\n\n\tif (type == -1) {\n\t\ttype = R_STRING_TYPE_DETECT;\n\t}\n\tif (from == to) {\n\t\treturn 0;\n\t}\n\tif (from > to) {\n\t\teprintf (\"Invalid range to find strings 0x%\"PFMT64x\" .. 0x%\"PFMT64x\"\\n\", from, to);\n\t\treturn -1;\n\t}\n\tst64 len = (st64)(to - from);\n\tif (len < 1 || len > ST32_MAX) {\n\t\teprintf (\"String scan range is invalid (%\"PFMT64d\" bytes)\\n\", len);\n\t\treturn -1;\n\t}\n\tut8 *buf = calloc (len, 1);\n\tif (!buf || !min) {\n\t\tfree (buf);\n\t\treturn -1;\n\t}\n\tst64 vdelta = 0, pdelta = 0;\n\tRBinSection *s = NULL;\n\tbool ascii_only = false;\n\tPJ *pj = NULL;\n\tif (bf->strmode == R_MODE_JSON && !list) {\n\t\tpj = pj_new ();\n\t\tif (pj) {\n\t\t\tpj_a (pj);\n\t\t}\n\t}\n\tr_buf_read_at (bf->buf, from, buf, len);\n\tchar *charset = r_sys_getenv (\"RABIN2_CHARSET\");\n\tif (!R_STR_ISEMPTY (charset)) {\n\t\tRCharset *ch = r_charset_new ();\n\t\tif (r_charset_use (ch, charset)) {\n\t\t\tint outlen = len * 4;\n\t\t\tut8 *out = calloc (len, 4);\n\t\t\tif (out) {\n\t\t\t\tint res = r_charset_encode_str (ch, out, outlen, buf, len);\n\t\t\t\tint i;\n\t\t\t\t// TODO unknown chars should be translated to null bytes\n\t\t\t\tfor (i = 0; i < res; i++) {\n\t\t\t\t\tif (out[i] == '?') {\n\t\t\t\t\t\tout[i] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlen = res;\n\t\t\t\tfree (buf);\n\t\t\t\tbuf = out;\n\t\t\t} else {\n\t\t\t\teprintf (\"Cannot allocate\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"Invalid value for RABIN2_CHARSET.\\n\");\n\t\t}\n\t\tr_charset_free (ch);\n\t}\n\tfree (charset);\n\tRConsIsBreaked is_breaked = (bin && bin->consb.is_breaked)? bin->consb.is_breaked: NULL;\n\t// may oobread\n\twhile (needle < to && needle < UT64_MAX - 4) {\n\t\tif (is_breaked && is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\t// smol optimization\n\t\tif (needle < to - 4) {\n\t\t\tut32 n1 = r_read_le32 (buf + (needle - from));\n\t\t\tif (!n1) {\n\t\t\t\tneedle += 4;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\trc = r_utf8_decode (buf + (needle - from), to - needle, NULL);\n\t\tif (!rc) {\n\t\t\tneedle++;\n\t\t\tcontinue;\n\t\t}\n\t\tbool addr_aligned = !(needle % 4);\n\n\t\tif (type == R_STRING_TYPE_DETECT) {\n\t\t\tchar *w = (char *)buf + (needle + rc - from);\n\t\t\tif (((to - needle) > 8 + rc)) {\n\t\t\t\t// TODO: support le and be\n\t\t\t\tbool is_wide32le = (needle + rc + 2 < to) && (!w[0] && !w[1] && !w[2] && w[3] && !w[4]);\n\t\t\t\t// reduce false positives\n\t\t\t\tif (is_wide32le) {\n\t\t\t\t\tif (!w[5] && !w[6] && w[7] && w[8]) {\n\t\t\t\t\t\tis_wide32le = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!addr_aligned) {\n\t\t\t\t\tis_wide32le = false;\n\t\t\t\t}\n\t\t\t\t///is_wide32be &= (n1 < 0xff && n11 < 0xff); // false; // n11 < 0xff;\n\t\t\t\tif (is_wide32le  && addr_aligned) {\n\t\t\t\t\tstr_type = R_STRING_TYPE_WIDE32; // asume big endian,is there little endian w32?\n\t\t\t\t} else {\n\t\t\t\t\t// bool is_wide = (n1 && n2 && n1 < 0xff && (!n2 || n2 < 0xff));\n\t\t\t\t\tbool is_wide = needle + rc + 4 < to && !w[0] && w[1] && !w[2] && w[3] && !w[4];\n\t\t\t\t\tstr_type = is_wide? R_STRING_TYPE_WIDE: R_STRING_TYPE_ASCII;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (rc > 1) {\n\t\t\t\t\tstr_type = R_STRING_TYPE_UTF8; // could be charset if set :?\n\t\t\t\t} else {\n\t\t\t\t\tstr_type = R_STRING_TYPE_ASCII;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (type == R_STRING_TYPE_UTF8) {\n\t\t\tstr_type = R_STRING_TYPE_ASCII; // initial assumption\n\t\t} else {\n\t\t\tstr_type = type;\n\t\t}\n\t\trunes = 0;\n\t\tstr_start = needle;\n\n\t\t/* Eat a whole C string */\n\t\tfor (i = 0; i < sizeof (tmp) - 4 && needle < to; i += rc) {\n\t\t\tRRune r = {0};\n\t\t\tif (str_type == R_STRING_TYPE_WIDE32) {\n\t\t\t\trc = r_utf32le_decode (buf + needle - from, to - needle, &r);\n\t\t\t\tif (rc) {\n\t\t\t\t\trc = 4;\n\t\t\t\t}\n\t\t\t} else if (str_type == R_STRING_TYPE_WIDE) {\n\t\t\t\trc = r_utf16le_decode (buf + needle - from, to - needle, &r);\n\t\t\t\tif (rc == 1) {\n\t\t\t\t\trc = 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trc = r_utf8_decode (buf + (needle - from), to - needle, &r);\n\t\t\t\tif (rc > 1) {\n\t\t\t\t\tstr_type = R_STRING_TYPE_UTF8;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Invalid sequence detected */\n\t\t\tif (!rc || (ascii_only && r > 0x7f)) {\n\t\t\t\tneedle++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tneedle += rc;\n\n\t\t\tif (r_isprint (r) && r != '\\\\') {\n\t\t\t\tif (str_type == R_STRING_TYPE_WIDE32) {\n\t\t\t\t\tif (r == 0xff) {\n\t\t\t\t\t\tr = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trc = r_utf8_encode (tmp + i, r);\n\t\t\t\trunes++;\n\t\t\t\t/* Print the escape code */\n\t\t\t} else if (r && r < 0x100 && strchr (\"\\b\\v\\f\\n\\r\\t\\a\\033\\\\\", (char)r)) {\n\t\t\t\tif ((i + 32) < sizeof (tmp) && r < 93) {\n\t\t\t\t\ttmp[i + 0] = '\\\\';\n\t\t\t\t\ttmp[i + 1] = \"       abtnvfr             e  \"\n\t\t\t\t\t             \"                              \"\n\t\t\t\t\t             \"                              \"\n\t\t\t\t\t             \"  \\\\\"[r];\n\t\t\t\t} else {\n\t\t\t\t\t// string too long\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\trc = 2;\n\t\t\t\trunes++;\n\t\t\t} else {\n\t\t\t\t/* \\0 marks the end of C-strings */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\ttmp[i++] = '\\0';\n\n\t\tif (runes < min && runes >= 2 && str_type == R_STRING_TYPE_ASCII && needle < to) {\n\t\t\t// back up past the \\0 to the last char just in case it starts a wide string\n\t\t\tneedle -= 2;\n\t\t}\n\t\tif (runes >= min) {\n\t\t\t// reduce false positives\n\t\t\tint j, num_blocks, *block_list;\n\t\t\tint *freq_list = NULL, expected_ascii, actual_ascii, num_chars;\n\t\t\tif (str_type == R_STRING_TYPE_ASCII) {\n\t\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\t\tchar ch = tmp[j];\n\t\t\t\t\tif (ch != '\\n' && ch != '\\r' && ch != '\\t') {\n\t\t\t\t\t\tif (!IS_PRINTABLE (tmp[j])) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch (str_type) {\n\t\t\tcase R_STRING_TYPE_UTF8:\n\t\t\tcase R_STRING_TYPE_WIDE:\n\t\t\tcase R_STRING_TYPE_WIDE32:\n\t\t\t\tnum_blocks = 0;\n\t\t\t\tblock_list = r_utf_block_list ((const ut8*)tmp, i - 1,\n\t\t\t\t\t\tstr_type == R_STRING_TYPE_WIDE? &freq_list: NULL);\n\t\t\t\tif (block_list) {\n\t\t\t\t\tfor (j = 0; block_list[j] != -1; j++) {\n\t\t\t\t\t\tnum_blocks++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (freq_list) {\n\t\t\t\t\tnum_chars = 0;\n\t\t\t\t\tactual_ascii = 0;\n\t\t\t\t\tfor (j = 0; freq_list[j] != -1; j++) {\n\t\t\t\t\t\tnum_chars += freq_list[j];\n\t\t\t\t\t\tif (!block_list[j]) { // ASCII\n\t\t\t\t\t\t\tactual_ascii = freq_list[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree (freq_list);\n\t\t\t\t\texpected_ascii = num_blocks ? num_chars / num_blocks : 0;\n\t\t\t\t\tif (actual_ascii > expected_ascii) {\n\t\t\t\t\t\tascii_only = true;\n\t\t\t\t\t\tneedle = str_start;\n\t\t\t\t\t\tfree (block_list);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree (block_list);\n\t\t\t\tif (num_blocks > R_STRING_MAX_UNI_BLOCKS) {\n\t\t\t\t\tneedle++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tRBinString *bs = R_NEW0 (RBinString);\n\t\t\tif (!bs) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbs->type = str_type;\n\t\t\tbs->length = runes;\n\t\t\tbs->size = needle - str_start;\n\t\t\tbs->ordinal = count++;\n\t\t\t// TODO: move into adjust_offset\n\t\t\tswitch (str_type) {\n\t\t\tcase R_STRING_TYPE_WIDE:\n\t\t\t\tif (str_start - from > 1) {\n\t\t\t\t\tconst ut8 *p = buf + str_start - 2 - from;\n\t\t\t\t\tif (p[0] == 0xff && p[1] == 0xfe) {\n\t\t\t\t\t\tstr_start -= 2; // \\xff\\xfe\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase R_STRING_TYPE_WIDE32:\n\t\t\t\tif (str_start - from > 3) {\n\t\t\t\t\tconst ut8 *p = buf + str_start - 4 - from;\n\t\t\t\t\tif (p[0] == 0xff && p[1] == 0xfe) {\n\t\t\t\t\t\tstr_start -= 4; // \\xff\\xfe\\x00\\x00\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!s) {\n\t\t\t\tif (section) {\n\t\t\t\t\ts = section;\n\t\t\t\t} else if (bf->o) {\n\t\t\t\t\ts = r_bin_get_section_at (bf->o, str_start, false);\n\t\t\t\t}\n\t\t\t\tif (s) {\n\t\t\t\t\tvdelta = s->vaddr;\n\t\t\t\t\tpdelta = s->paddr;\n\t\t\t\t}\n\t\t\t}\n\t\t\tut64 baddr = bf->loadaddr && bf->o? bf->o->baddr: bf->loadaddr;\n\t\t\tbs->paddr = str_start + baddr;\n\t\t\tbs->vaddr = str_start - pdelta + vdelta + baddr;\n\t\t\tbs->string = r_str_ndup ((const char *)tmp, i);\n\t\t\tif (list) {\n\t\t\t\tr_list_append (list, bs);\n\t\t\t\tif (bf->o) {\n\t\t\t\t\tht_up_insert (bf->o->strings_db, bs->vaddr, bs);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprint_string (bf, bs, raw, pj);\n\t\t\t\tr_bin_string_free (bs);\n\t\t\t}\n\t\t\tif (from == 0 && to == bf->size) {\n\t\t\t\t/* force lookup section at the next one */\n\t\t\t\ts = NULL;\n\t\t\t}\n\t\t}\n\t\tascii_only = false;\n\t}\n\tfree (buf);\n\tif (pj) {\n\t\tpj_end (pj);\n\t\tif (bin) {\n\t\t\tRIO *io = bin->iob.io;\n\t\t\tif (io) {\n\t\t\t\tio->cb_printf (\"%s\", pj_string (pj));\n\t\t\t}\n\t\t}\n\t\tpj_free (pj);\n\t}\n\treturn count;\n}",
  "abstract_func": "static int string_scan_range(RList *VAR_0, RBinFile *VAR_1, int VAR_2,\n\t\t\t      const ut64 VAR_3, const ut64 VAR_4, int VAR_5, int VAR_6, RBinSection *VAR_7) {\n\tRBin *VAR_8 = VAR_1->rbin;\n\tut8 VAR_9[VAR_10];\n\tut64 VAR_11, VAR_12 = VAR_3;\n\tint VAR_13 = 0, VAR_14, VAR_15, VAR_16;\n\tint VAR_17 = VAR_18;\n\n\t/* COMMENT_0 */\n\tr_return_val_if_fail (VAR_1, -1);\n\n\tif (VAR_5 == -1) {\n\t\tVAR_5 = VAR_18;\n\t}\n\tif (VAR_3 == VAR_4) {\n\t\treturn 0;\n\t}\n\tif (VAR_3 > VAR_4) {\n\t\teprintf (\"Invalid range to find strings 0x%\"VAR_19\" .. 0x%\"VAR_19\"\\n\", VAR_3, VAR_4);\n\t\treturn -1;\n\t}\n\tst64 VAR_20 = (st64)(VAR_4 - VAR_3);\n\tif (VAR_20 < 1 || VAR_20 > VAR_21) {\n\t\teprintf (\"String scan range is invalid (%\"VAR_22\" bytes)\\n\", VAR_20);\n\t\treturn -1;\n\t}\n\tut8 *VAR_23 = calloc (VAR_20, 1);\n\tif (!VAR_23 || !VAR_2) {\n\t\tfree (VAR_23);\n\t\treturn -1;\n\t}\n\tst64 VAR_24 = 0, VAR_25 = 0;\n\tRBinSection *VAR_26 = NULL;\n\tbool VAR_27 = false;\n\tPJ *VAR_28 = NULL;\n\tif (VAR_1->strmode == VAR_29 && !VAR_0) {\n\t\tVAR_28 = pj_new ();\n\t\tif (VAR_28) {\n\t\t\tpj_a (VAR_28);\n\t\t}\n\t}\n\tr_buf_read_at (VAR_1->buf, VAR_3, VAR_23, VAR_20);\n\tchar *VAR_30 = r_sys_getenv (\"RABIN2_CHARSET\");\n\tif (!R_STR_ISEMPTY (VAR_30)) {\n\t\tRCharset *VAR_31 = r_charset_new ();\n\t\tif (r_charset_use (VAR_31, VAR_30)) {\n\t\t\tint VAR_32 = VAR_20 * 4;\n\t\t\tut8 *VAR_33 = calloc (VAR_20, 4);\n\t\t\tif (VAR_33) {\n\t\t\t\tint VAR_34 = r_charset_encode_str (VAR_31, VAR_33, VAR_32, VAR_23, VAR_20);\n\t\t\t\tint VAR_14;\n\t\t\t\t/* COMMENT_1 */\n\t\t\t\tfor (VAR_14 = 0; VAR_14 < VAR_34; VAR_14++) {\n\t\t\t\t\tif (VAR_33[VAR_14] == '?') {\n\t\t\t\t\t\tVAR_33[VAR_14] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tVAR_20 = VAR_34;\n\t\t\t\tfree (VAR_23);\n\t\t\t\tVAR_23 = VAR_33;\n\t\t\t} else {\n\t\t\t\teprintf (\"Cannot allocate\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"Invalid value for RABIN2_CHARSET.\\n\");\n\t\t}\n\t\tr_charset_free (VAR_31);\n\t}\n\tfree (VAR_30);\n\tRConsIsBreaked VAR_35 = (VAR_8 && VAR_8->consb.is_breaked)? VAR_8->consb.is_breaked: NULL;\n\t/* COMMENT_2 */\n\twhile (VAR_12 < VAR_4 && VAR_12 < VAR_36 - 4) {\n\t\tif (VAR_35 && VAR_35 ()) {\n\t\t\tbreak;\n\t\t}\n\t\t/* COMMENT_3 */\n\t\tif (VAR_12 < VAR_4 - 4) {\n\t\t\tut32 VAR_37 = r_read_le32 (VAR_23 + (VAR_12 - VAR_3));\n\t\t\tif (!VAR_37) {\n\t\t\t\tVAR_12 += 4;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tVAR_15 = r_utf8_decode (VAR_23 + (VAR_12 - VAR_3), VAR_4 - VAR_12, NULL);\n\t\tif (!VAR_15) {\n\t\t\tVAR_12++;\n\t\t\tcontinue;\n\t\t}\n\t\tbool VAR_38 = !(VAR_12 % 4);\n\n\t\tif (VAR_5 == VAR_18) {\n\t\t\tchar *VAR_39 = (char *)VAR_23 + (VAR_12 + VAR_15 - VAR_3);\n\t\t\tif (((VAR_4 - VAR_12) > 8 + VAR_15)) {\n\t\t\t\t/* COMMENT_4 */\n\t\t\t\tbool VAR_40 = (VAR_12 + VAR_15 + 2 < VAR_4) && (!VAR_39[0] && !VAR_39[1] && !VAR_39[2] && VAR_39[3] && !VAR_39[4]);\n\t\t\t\t/* COMMENT_5 */\n\t\t\t\tif (VAR_40) {\n\t\t\t\t\tif (!VAR_39[5] && !VAR_39[6] && VAR_39[7] && VAR_39[8]) {\n\t\t\t\t\t\tVAR_40 = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!VAR_38) {\n\t\t\t\t\tVAR_40 = false;\n\t\t\t\t}\n\t\t\t\t/* COMMENT_6 */\n\t\t\t\tif (VAR_40  && VAR_38) {\n\t\t\t\t\tVAR_17 = VAR_41; /* COMMENT_7 */\n\t\t\t\t} else {\n\t\t\t\t\t/* COMMENT_8 */\n\t\t\t\t\tbool VAR_42 = VAR_12 + VAR_15 + 4 < VAR_4 && !VAR_39[0] && VAR_39[1] && !VAR_39[2] && VAR_39[3] && !VAR_39[4];\n\t\t\t\t\tVAR_17 = VAR_42? VAR_43: VAR_44;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (VAR_15 > 1) {\n\t\t\t\t\tVAR_17 = VAR_45; /* COMMENT_9 */\n\t\t\t\t} else {\n\t\t\t\t\tVAR_17 = VAR_44;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (VAR_5 == VAR_45) {\n\t\t\tVAR_17 = VAR_44; /* COMMENT_10 */\n\t\t} else {\n\t\t\tVAR_17 = VAR_5;\n\t\t}\n\t\tVAR_16 = 0;\n\t\tVAR_11 = VAR_12;\n\n\t\t/* COMMENT_11 */\n\t\tfor (VAR_14 = 0; VAR_14 < sizeof (VAR_9) - 4 && VAR_12 < VAR_4; VAR_14 += VAR_15) {\n\t\t\tRRune VAR_46 = {0};\n\t\t\tif (VAR_17 == VAR_41) {\n\t\t\t\tVAR_15 = r_utf32le_decode (VAR_23 + VAR_12 - VAR_3, VAR_4 - VAR_12, &VAR_46);\n\t\t\t\tif (VAR_15) {\n\t\t\t\t\tVAR_15 = 4;\n\t\t\t\t}\n\t\t\t} else if (VAR_17 == VAR_43) {\n\t\t\t\tVAR_15 = r_utf16le_decode (VAR_23 + VAR_12 - VAR_3, VAR_4 - VAR_12, &VAR_46);\n\t\t\t\tif (VAR_15 == 1) {\n\t\t\t\t\tVAR_15 = 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tVAR_15 = r_utf8_decode (VAR_23 + (VAR_12 - VAR_3), VAR_4 - VAR_12, &VAR_46);\n\t\t\t\tif (VAR_15 > 1) {\n\t\t\t\t\tVAR_17 = VAR_45;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* COMMENT_12 */\n\t\t\tif (!VAR_15 || (VAR_27 && VAR_46 > 0x7f)) {\n\t\t\t\tVAR_12++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tVAR_12 += VAR_15;\n\n\t\t\tif (r_isprint (VAR_46) && VAR_46 != '\\\\') {\n\t\t\t\tif (VAR_17 == VAR_41) {\n\t\t\t\t\tif (VAR_46 == 0xff) {\n\t\t\t\t\t\tVAR_46 = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tVAR_15 = r_utf8_encode (VAR_9 + VAR_14, VAR_46);\n\t\t\t\tVAR_16++;\n\t\t\t\t/* COMMENT_13 */\n\t\t\t} else if (VAR_46 && VAR_46 < 0x100 && strchr (\"\\b\\v\\f\\n\\r\\t\\a\\033\\\\\", (char)VAR_46)) {\n\t\t\t\tif ((VAR_14 + 32) < sizeof (VAR_9) && VAR_46 < 93) {\n\t\t\t\t\tVAR_9[VAR_14 + 0] = '\\\\';\n\t\t\t\t\tVAR_9[VAR_14 + 1] = \"       abtnvfr             e  \"\n\t\t\t\t\t             \"                              \"\n\t\t\t\t\t             \"                              \"\n\t\t\t\t\t             \"  \\\\\"[VAR_46];\n\t\t\t\t} else {\n\t\t\t\t\t/* COMMENT_14 */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tVAR_15 = 2;\n\t\t\t\tVAR_16++;\n\t\t\t} else {\n\t\t\t\t/* COMMENT_15 */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tVAR_9[VAR_14++] = '\\0';\n\n\t\tif (VAR_16 < VAR_2 && VAR_16 >= 2 && VAR_17 == VAR_44 && VAR_12 < VAR_4) {\n\t\t\t/* COMMENT_16 */\n\t\t\tVAR_12 -= 2;\n\t\t}\n\t\tif (VAR_16 >= VAR_2) {\n\t\t\t/* COMMENT_5 */\n\t\t\tint VAR_47, VAR_48, *VAR_49;\n\t\t\tint *VAR_50 = NULL, VAR_51, VAR_52, VAR_53;\n\t\t\tif (VAR_17 == VAR_44) {\n\t\t\t\tfor (VAR_47 = 0; VAR_47 < VAR_14; VAR_47++) {\n\t\t\t\t\tchar VAR_31 = VAR_9[VAR_47];\n\t\t\t\t\tif (VAR_31 != '\\n' && VAR_31 != '\\r' && VAR_31 != '\\t') {\n\t\t\t\t\t\tif (!IS_PRINTABLE (VAR_9[VAR_47])) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch (VAR_17) {\n\t\t\tcase VAR_45:\n\t\t\tcase VAR_43:\n\t\t\tcase VAR_41:\n\t\t\t\tVAR_48 = 0;\n\t\t\t\tVAR_49 = r_utf_block_list ((const ut8*)VAR_9, VAR_14 - 1,\n\t\t\t\t\t\tVAR_17 == VAR_43? &VAR_50: NULL);\n\t\t\t\tif (VAR_49) {\n\t\t\t\t\tfor (VAR_47 = 0; VAR_49[VAR_47] != -1; VAR_47++) {\n\t\t\t\t\t\tVAR_48++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (VAR_50) {\n\t\t\t\t\tVAR_53 = 0;\n\t\t\t\t\tVAR_52 = 0;\n\t\t\t\t\tfor (VAR_47 = 0; VAR_50[VAR_47] != -1; VAR_47++) {\n\t\t\t\t\t\tVAR_53 += VAR_50[VAR_47];\n\t\t\t\t\t\tif (!VAR_49[VAR_47]) { /* COMMENT_17 */\n\t\t\t\t\t\t\tVAR_52 = VAR_50[VAR_47];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree (VAR_50);\n\t\t\t\t\tVAR_51 = VAR_48 ? VAR_53 / VAR_48 : 0;\n\t\t\t\t\tif (VAR_52 > VAR_51) {\n\t\t\t\t\t\tVAR_27 = true;\n\t\t\t\t\t\tVAR_12 = VAR_11;\n\t\t\t\t\t\tfree (VAR_49);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree (VAR_49);\n\t\t\t\tif (VAR_48 > VAR_54) {\n\t\t\t\t\tVAR_12++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tRBinString *VAR_55 = R_NEW0 (RBinString);\n\t\t\tif (!VAR_55) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tVAR_55->type = VAR_17;\n\t\t\tVAR_55->length = VAR_16;\n\t\t\tVAR_55->size = VAR_12 - VAR_11;\n\t\t\tVAR_55->ordinal = VAR_13++;\n\t\t\t/* COMMENT_18 */\n\t\t\tswitch (VAR_17) {\n\t\t\tcase VAR_43:\n\t\t\t\tif (VAR_11 - VAR_3 > 1) {\n\t\t\t\t\tconst ut8 *VAR_56 = VAR_23 + VAR_11 - 2 - VAR_3;\n\t\t\t\t\tif (VAR_56[0] == 0xff && VAR_56[1] == 0xfe) {\n\t\t\t\t\t\tVAR_11 -= 2; /* COMMENT_19 */\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase VAR_41:\n\t\t\t\tif (VAR_11 - VAR_3 > 3) {\n\t\t\t\t\tconst ut8 *VAR_56 = VAR_23 + VAR_11 - 4 - VAR_3;\n\t\t\t\t\tif (VAR_56[0] == 0xff && VAR_56[1] == 0xfe) {\n\t\t\t\t\t\tVAR_11 -= 4; /* COMMENT_20 */\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!VAR_26) {\n\t\t\t\tif (VAR_7) {\n\t\t\t\t\tVAR_26 = VAR_7;\n\t\t\t\t} else if (VAR_1->o) {\n\t\t\t\t\tVAR_26 = r_bin_get_section_at (VAR_1->o, VAR_11, false);\n\t\t\t\t}\n\t\t\t\tif (VAR_26) {\n\t\t\t\t\tVAR_24 = VAR_26->vaddr;\n\t\t\t\t\tVAR_25 = VAR_26->paddr;\n\t\t\t\t}\n\t\t\t}\n\t\t\tut64 VAR_57 = VAR_1->loadaddr && VAR_1->o? VAR_1->o->baddr: VAR_1->loadaddr;\n\t\t\tVAR_55->paddr = VAR_11 + VAR_57;\n\t\t\tVAR_55->vaddr = VAR_11 - VAR_25 + VAR_24 + VAR_57;\n\t\t\tVAR_55->string = r_str_ndup ((const char *)VAR_9, VAR_14);\n\t\t\tif (VAR_0) {\n\t\t\t\tr_list_append (VAR_0, VAR_55);\n\t\t\t\tif (VAR_1->o) {\n\t\t\t\t\tht_up_insert (VAR_1->o->strings_db, VAR_55->vaddr, VAR_55);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprint_string (VAR_1, VAR_55, VAR_6, VAR_28);\n\t\t\t\tr_bin_string_free (VAR_55);\n\t\t\t}\n\t\t\tif (VAR_3 == 0 && VAR_4 == VAR_1->size) {\n\t\t\t\t/* COMMENT_21 */\n\t\t\t\tVAR_26 = NULL;\n\t\t\t}\n\t\t}\n\t\tVAR_27 = false;\n\t}\n\tfree (VAR_23);\n\tif (VAR_28) {\n\t\tpj_end (VAR_28);\n\t\tif (VAR_8) {\n\t\t\tRIO *VAR_58 = VAR_8->iob.io;\n\t\t\tif (VAR_58) {\n\t\t\t\tVAR_58->cb_printf (\"%s\", pj_string (VAR_28));\n\t\t\t}\n\t\t}\n\t\tpj_free (VAR_28);\n\t}\n\treturn VAR_13;\n}",
  "func_graph_path": "radareorg/radare2/193f4fe01d7f626e2ea937450f2e0c4604420e9d/bfile.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -69,19 +69,19 @@\n \tfree (charset);\n \tRConsIsBreaked is_breaked = (bin && bin->consb.is_breaked)? bin->consb.is_breaked: NULL;\n \t// may oobread\n-\twhile (needle < to) {\n+\twhile (needle < to && needle < UT64_MAX - 4) {\n \t\tif (is_breaked && is_breaked ()) {\n \t\t\tbreak;\n \t\t}\n \t\t// smol optimization\n-\t\tif (needle + 4 < to) {\n-\t\t\tut32 n1 = r_read_le32 (buf + needle - from);\n+\t\tif (needle < to - 4) {\n+\t\t\tut32 n1 = r_read_le32 (buf + (needle - from));\n \t\t\tif (!n1) {\n \t\t\t\tneedle += 4;\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t}\n-\t\trc = r_utf8_decode (buf + needle - from, to - needle, NULL);\n+\t\trc = r_utf8_decode (buf + (needle - from), to - needle, NULL);\n \t\tif (!rc) {\n \t\t\tneedle++;\n \t\t\tcontinue;\n@@ -89,7 +89,7 @@\n \t\tbool addr_aligned = !(needle % 4);\n \n \t\tif (type == R_STRING_TYPE_DETECT) {\n-\t\t\tchar *w = (char *)buf + needle + rc - from;\n+\t\t\tchar *w = (char *)buf + (needle + rc - from);\n \t\t\tif (((to - needle) > 8 + rc)) {\n \t\t\t\t// TODO: support le and be\n \t\t\t\tbool is_wide32le = (needle + rc + 2 < to) && (!w[0] && !w[1] && !w[2] && w[3] && !w[4]);\n@@ -139,7 +139,7 @@\n \t\t\t\t\trc = 2;\n \t\t\t\t}\n \t\t\t} else {\n-\t\t\t\trc = r_utf8_decode (buf + needle - from, to - needle, &r);\n+\t\t\t\trc = r_utf8_decode (buf + (needle - from), to - needle, &r);\n \t\t\t\tif (rc > 1) {\n \t\t\t\t\tstr_type = R_STRING_TYPE_UTF8;\n \t\t\t\t}",
  "diff_line_info": {
    "deleted_lines": [
      "\twhile (needle < to) {",
      "\t\tif (needle + 4 < to) {",
      "\t\t\tut32 n1 = r_read_le32 (buf + needle - from);",
      "\t\trc = r_utf8_decode (buf + needle - from, to - needle, NULL);",
      "\t\t\tchar *w = (char *)buf + needle + rc - from;",
      "\t\t\t\trc = r_utf8_decode (buf + needle - from, to - needle, &r);"
    ],
    "added_lines": [
      "\twhile (needle < to && needle < UT64_MAX - 4) {",
      "\t\tif (needle < to - 4) {",
      "\t\t\tut32 n1 = r_read_le32 (buf + (needle - from));",
      "\t\trc = r_utf8_decode (buf + (needle - from), to - needle, NULL);",
      "\t\t\tchar *w = (char *)buf + (needle + rc - from);",
      "\t\t\t\trc = r_utf8_decode (buf + (needle - from), to - needle, &r);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/radareorg/radare2/pull/20168",
  "description": {
    "pr_info": {
      "title": "Ovf",
      "number": 20168
    },
    "comment": [
      "<!--\r\nRead https://github.com/radareorg/radare2/blob/master/DEVELOPERS.md\r\n* PR title must be capitalized, concise and use ##tags\r\n* If the PR is fixing a ticket use 'Fix #1234 - ..' in the commit message\r\n* Follow the coding style, add tests and documentation if necessary\r\n-->\r\n\r\n- [ ] Mark this if you consider it ready to merge\r\n- [ ] I've added tests (optional)\r\n- [ ] I wrote some lines in the [book](https://github.com/radareorg/radare2book) (optional)\r\n\r\n**Description**\r\n\r\n<!-- explain your changes if necessary -->\r\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}