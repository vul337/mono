{
  "cve_id": "CVE-2022-1052",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "AV:L/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "radareorg/radare2",
  "commit_msg": "Fix heap OOB read in macho.iterate_chained_fixups ##crash\n\n* Reported by peacock-doris via huntr.dev\r\n* Reproducer 'tests_65305'\r\n\r\nmrmacete:\r\n* Return early if segs_count is 0\r\n* Initialize segs_count also for reconstructed fixups\r\n\r\nCo-authored-by: pancake <pancake@nopcode.org>\r\nCo-authored-by: Francesco Tamagni <mrmacete@protonmail.ch>",
  "commit_hash": "0052500c1ed5bf8263b26b9fd7773dbdc6f170c4",
  "git_url": "https://github.com/radareorg/radare2/commit/0052500c1ed5bf8263b26b9fd7773dbdc6f170c4",
  "file_path": "libr/bin/format/mach0/mach0.c",
  "func_name": "reconstruct_chained_fixup",
  "func_before": "static bool reconstruct_chained_fixup(struct MACH0_(obj_t) *bin) {\n\tif (!bin->dyld_info) {\n\t\treturn false;\n\t}\n\tif (!bin->nsegs) {\n\t\treturn false;\n\t}\n\tbin->chained_starts = R_NEWS0 (struct r_dyld_chained_starts_in_segment *, bin->nsegs);\n\tif (!bin->chained_starts) {\n\t\treturn false;\n\t}\n\tsize_t wordsize = get_word_size (bin);\n\tut8 *p = NULL;\n\tsize_t j, count, skip, bind_size;\n\tint seg_idx = 0;\n\tut64 seg_off = 0;\n\tbind_size = bin->dyld_info->bind_size;\n\tif (!bind_size || bind_size < 1) {\n\t\treturn false;\n\t}\n\tif (bin->dyld_info->bind_off > bin->size) {\n\t\treturn false;\n\t}\n\tif (bin->dyld_info->bind_off + bind_size > bin->size) {\n\t\treturn false;\n\t}\n\tut8 *opcodes = calloc (1, bind_size + 1);\n\tif (!opcodes) {\n\t\treturn false;\n\t}\n\tif (r_buf_read_at (bin->b, bin->dyld_info->bind_off, opcodes, bind_size) != bind_size) {\n\t\tbprintf (\"Error: read (dyld_info bind) at 0x%08\"PFMT64x\"\\n\", (ut64)(size_t)bin->dyld_info->bind_off);\n\t\tR_FREE (opcodes);\n\t\treturn false;\n\t}\n\tstruct r_dyld_chained_starts_in_segment *cur_seg = NULL;\n\tsize_t cur_seg_idx = 0;\n\tut8 *end;\n\tbool done = false;\n\tfor (p = opcodes, end = opcodes + bind_size; !done && p < end;) {\n\t\tut8 imm = *p & BIND_IMMEDIATE_MASK, op = *p & BIND_OPCODE_MASK;\n\t\tp++;\n\t\tswitch (op) {\n\t\tcase BIND_OPCODE_DONE:\n\t\t\tdone = true;\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_THREADED: {\n\t\t\tswitch (imm) {\n\t\t\tcase BIND_SUBOPCODE_THREADED_SET_BIND_ORDINAL_TABLE_SIZE_ULEB: {\n\t\t\t\tread_uleb128 (&p, end);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase BIND_SUBOPCODE_THREADED_APPLY: {\n\t\t\t\tconst size_t ps = 0x1000;\n\t\t\t\tif (!cur_seg || cur_seg_idx != seg_idx) {\n\t\t\t\t\tcur_seg_idx = seg_idx;\n\t\t\t\t\tcur_seg = bin->chained_starts[seg_idx];\n\t\t\t\t\tif (!cur_seg) {\n\t\t\t\t\t\tcur_seg = R_NEW0 (struct r_dyld_chained_starts_in_segment);\n\t\t\t\t\t\tif (!cur_seg) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbin->chained_starts[seg_idx] = cur_seg;\n\t\t\t\t\t\tcur_seg->pointer_format = DYLD_CHAINED_PTR_ARM64E;\n\t\t\t\t\t\tcur_seg->page_size = ps;\n\t\t\t\t\t\tcur_seg->page_count = ((bin->segs[seg_idx].vmsize + (ps - 1)) & ~(ps - 1)) / ps;\n\t\t\t\t\t\tif (cur_seg->page_count > 0) {\n\t\t\t\t\t\t\tcur_seg->page_start = malloc (sizeof (ut16) * cur_seg->page_count);\n\t\t\t\t\t\t\tif (!cur_seg->page_start) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmemset (cur_seg->page_start, 0xff, sizeof (ut16) * cur_seg->page_count);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (cur_seg) {\n\t\t\t\t\tut32 page_index = (ut32)(seg_off / ps);\n\t\t\t\t\tsize_t maxsize = cur_seg->page_count * sizeof (ut16);\n\t\t\t\t\tif (page_index < maxsize && cur_seg->page_start) {\n\t\t\t\t\t\tcur_seg->page_start[page_index] = seg_off & 0xfff;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tbprintf (\"Error: Unexpected BIND_OPCODE_THREADED sub-opcode: 0x%x\\n\", imm);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase BIND_OPCODE_SET_DYLIB_ORDINAL_IMM:\n\t\tcase BIND_OPCODE_SET_DYLIB_SPECIAL_IMM:\n\t\tcase BIND_OPCODE_SET_TYPE_IMM:\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB:\n\t\t\tread_uleb128 (&p, end);\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM:\n\t\t\twhile (*p++ && p < end) {\n\t\t\t\t/* empty loop */\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_SET_ADDEND_SLEB:\n\t\t\tr_sleb128 ((const ut8 **)&p, end);\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB:\n\t\t\tseg_idx = imm;\n\t\t\tif (seg_idx >= bin->nsegs) {\n\t\t\t\tbprintf (\"Error: BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB\"\n\t\t\t\t\t\" has unexistent segment %d\\n\", seg_idx);\n\t\t\t\tR_FREE (opcodes);\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tseg_off = read_uleb128 (&p, end);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_ADD_ADDR_ULEB:\n\t\t\tseg_off += read_uleb128 (&p, end);\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_DO_BIND:\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB:\n\t\t\tseg_off += read_uleb128 (&p, end) + wordsize;\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED:\n\t\t\tseg_off += (ut64)imm * (ut64)wordsize + wordsize;\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB:\n\t\t\tcount = read_uleb128 (&p, end);\n\t\t\tskip = read_uleb128 (&p, end);\n\t\t\tfor (j = 0; j < count; j++) {\n\t\t\t\tseg_off += skip + wordsize;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbprintf (\"Error: unknown bind opcode 0x%02x in dyld_info\\n\", *p);\n\t\t\tR_FREE (opcodes);\n\t\t\treturn false;\n\t\t}\n\t}\n\tR_FREE (opcodes);\n\n\treturn true;\n}",
  "abstract_func_before": "static bool reconstruct_chained_fixup(struct MACH0_(obj_t) *VAR_0) {\n\tif (!VAR_0->dyld_info) {\n\t\treturn false;\n\t}\n\tif (!VAR_0->nsegs) {\n\t\treturn false;\n\t}\n\tVAR_0->chained_starts = R_NEWS0 (struct VAR_1 *, VAR_0->nsegs);\n\tif (!VAR_0->chained_starts) {\n\t\treturn false;\n\t}\n\tsize_t VAR_2 = get_word_size (VAR_0);\n\tut8 *VAR_3 = NULL;\n\tsize_t VAR_4, VAR_5, VAR_6, VAR_7;\n\tint VAR_8 = 0;\n\tut64 VAR_9 = 0;\n\tVAR_7 = VAR_0->dyld_info->bind_size;\n\tif (!VAR_7 || VAR_7 < 1) {\n\t\treturn false;\n\t}\n\tif (VAR_0->dyld_info->bind_off > VAR_0->size) {\n\t\treturn false;\n\t}\n\tif (VAR_0->dyld_info->bind_off + VAR_7 > VAR_0->size) {\n\t\treturn false;\n\t}\n\tut8 *VAR_10 = calloc (1, VAR_7 + 1);\n\tif (!VAR_10) {\n\t\treturn false;\n\t}\n\tif (r_buf_read_at (VAR_0->b, VAR_0->dyld_info->bind_off, VAR_10, VAR_7) != VAR_7) {\n\t\tbprintf (\"Error: read (dyld_info bind) at 0x%08\"VAR_11\"\\n\", (ut64)(size_t)VAR_0->dyld_info->bind_off);\n\t\tR_FREE (VAR_10);\n\t\treturn false;\n\t}\n\tstruct r_dyld_chained_starts_in_segment *VAR_12 = NULL;\n\tsize_t VAR_13 = 0;\n\tut8 *VAR_14;\n\tbool VAR_15 = false;\n\tfor (VAR_3 = VAR_10, VAR_14 = VAR_10 + VAR_7; !VAR_15 && VAR_3 < VAR_14;) {\n\t\tut8 VAR_16 = *VAR_3 & VAR_17, VAR_18 = *VAR_3 & VAR_19;\n\t\tVAR_3++;\n\t\tswitch (VAR_18) {\n\t\tcase VAR_20:\n\t\t\tVAR_15 = true;\n\t\t\tbreak;\n\t\tcase VAR_21: {\n\t\t\tswitch (VAR_16) {\n\t\t\tcase VAR_22: {\n\t\t\t\tread_uleb128 (&VAR_3, VAR_14);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase VAR_23: {\n\t\t\t\tconst size_t VAR_24 = 0x1000;\n\t\t\t\tif (!VAR_12 || VAR_13 != VAR_8) {\n\t\t\t\t\tVAR_13 = VAR_8;\n\t\t\t\t\tVAR_12 = VAR_0->chained_starts[VAR_8];\n\t\t\t\t\tif (!VAR_12) {\n\t\t\t\t\t\tVAR_12 = R_NEW0 (struct r_dyld_chained_starts_in_segment);\n\t\t\t\t\t\tif (!VAR_12) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tVAR_0->chained_starts[VAR_8] = VAR_12;\n\t\t\t\t\t\tVAR_12->pointer_format = VAR_25;\n\t\t\t\t\t\tVAR_12->page_size = VAR_24;\n\t\t\t\t\t\tVAR_12->page_count = ((VAR_0->segs[VAR_8].vmsize + (VAR_24 - 1)) & ~(VAR_24 - 1)) / VAR_24;\n\t\t\t\t\t\tif (VAR_12->page_count > 0) {\n\t\t\t\t\t\t\tVAR_12->page_start = malloc (sizeof (VAR_26) * VAR_12->page_count);\n\t\t\t\t\t\t\tif (!VAR_12->page_start) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmemset (VAR_12->page_start, 0xff, sizeof (VAR_26) * VAR_12->page_count);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (VAR_12) {\n\t\t\t\t\tut32 VAR_27 = (ut32)(VAR_9 / VAR_24);\n\t\t\t\t\tsize_t VAR_28 = VAR_12->page_count * sizeof (VAR_26);\n\t\t\t\t\tif (VAR_27 < VAR_28 && VAR_12->page_start) {\n\t\t\t\t\t\tVAR_12->page_start[VAR_27] = VAR_9 & 0xfff;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tbprintf (\"Error: Unexpected BIND_OPCODE_THREADED sub-opcode: 0x%x\\n\", VAR_16);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase VAR_29:\n\t\tcase VAR_30:\n\t\tcase VAR_31:\n\t\t\tbreak;\n\t\tcase VAR_32:\n\t\t\tread_uleb128 (&VAR_3, VAR_14);\n\t\t\tbreak;\n\t\tcase VAR_33:\n\t\t\twhile (*VAR_3++ && VAR_3 < VAR_14) {\n\t\t\t\t/* COMMENT_0 */\n\t\t\t}\n\t\t\tbreak;\n\t\tcase VAR_34:\n\t\t\tr_sleb128 ((const ut8 **)&VAR_3, VAR_14);\n\t\t\tbreak;\n\t\tcase VAR_35:\n\t\t\tVAR_8 = VAR_16;\n\t\t\tif (VAR_8 >= VAR_0->nsegs) {\n\t\t\t\tbprintf (\"Error: BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB\"\n\t\t\t\t\t\" has unexistent segment %d\\n\", VAR_8);\n\t\t\t\tR_FREE (VAR_10);\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tVAR_9 = read_uleb128 (&VAR_3, VAR_14);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase VAR_36:\n\t\t\tVAR_9 += read_uleb128 (&VAR_3, VAR_14);\n\t\t\tbreak;\n\t\tcase VAR_37:\n\t\t\tbreak;\n\t\tcase VAR_38:\n\t\t\tVAR_9 += read_uleb128 (&VAR_3, VAR_14) + VAR_2;\n\t\t\tbreak;\n\t\tcase VAR_39:\n\t\t\tVAR_9 += (ut64)VAR_16 * (ut64)VAR_2 + VAR_2;\n\t\t\tbreak;\n\t\tcase VAR_40:\n\t\t\tVAR_5 = read_uleb128 (&VAR_3, VAR_14);\n\t\t\tVAR_6 = read_uleb128 (&VAR_3, VAR_14);\n\t\t\tfor (VAR_4 = 0; VAR_4 < VAR_5; VAR_4++) {\n\t\t\t\tVAR_9 += VAR_6 + VAR_2;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbprintf (\"Error: unknown bind opcode 0x%02x in dyld_info\\n\", *VAR_3);\n\t\t\tR_FREE (VAR_10);\n\t\t\treturn false;\n\t\t}\n\t}\n\tR_FREE (VAR_10);\n\n\treturn true;\n}",
  "func_graph_path_before": null,
  "func": "static bool reconstruct_chained_fixup(struct MACH0_(obj_t) *bin) {\n\tif (!bin->dyld_info) {\n\t\treturn false;\n\t}\n\tif (!bin->nsegs) {\n\t\treturn false;\n\t}\n\tbin->chained_starts = R_NEWS0 (struct r_dyld_chained_starts_in_segment *, bin->nsegs);\n\tif (!bin->chained_starts) {\n\t\treturn false;\n\t}\n\tsize_t wordsize = get_word_size (bin);\n\tut8 *p = NULL;\n\tsize_t j, count, skip, bind_size;\n\tint seg_idx = 0;\n\tut64 seg_off = 0;\n\tbind_size = bin->dyld_info->bind_size;\n\tif (!bind_size || bind_size < 1) {\n\t\treturn false;\n\t}\n\tif (bin->dyld_info->bind_off > bin->size) {\n\t\treturn false;\n\t}\n\tif (bin->dyld_info->bind_off + bind_size > bin->size) {\n\t\treturn false;\n\t}\n\tut8 *opcodes = calloc (1, bind_size + 1);\n\tif (!opcodes) {\n\t\treturn false;\n\t}\n\tif (r_buf_read_at (bin->b, bin->dyld_info->bind_off, opcodes, bind_size) != bind_size) {\n\t\tbprintf (\"Error: read (dyld_info bind) at 0x%08\"PFMT64x\"\\n\", (ut64)(size_t)bin->dyld_info->bind_off);\n\t\tR_FREE (opcodes);\n\t\treturn false;\n\t}\n\tstruct r_dyld_chained_starts_in_segment *cur_seg = NULL;\n\tsize_t cur_seg_idx = 0;\n\tut8 *end;\n\tbool done = false;\n\tfor (p = opcodes, end = opcodes + bind_size; !done && p < end;) {\n\t\tut8 imm = *p & BIND_IMMEDIATE_MASK, op = *p & BIND_OPCODE_MASK;\n\t\tp++;\n\t\tswitch (op) {\n\t\tcase BIND_OPCODE_DONE:\n\t\t\tdone = true;\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_THREADED: {\n\t\t\tswitch (imm) {\n\t\t\tcase BIND_SUBOPCODE_THREADED_SET_BIND_ORDINAL_TABLE_SIZE_ULEB: {\n\t\t\t\tread_uleb128 (&p, end);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase BIND_SUBOPCODE_THREADED_APPLY: {\n\t\t\t\tconst size_t ps = 0x1000;\n\t\t\t\tif (!cur_seg || cur_seg_idx != seg_idx) {\n\t\t\t\t\tcur_seg_idx = seg_idx;\n\t\t\t\t\tcur_seg = bin->chained_starts[seg_idx];\n\t\t\t\t\tif (!cur_seg) {\n\t\t\t\t\t\tcur_seg = R_NEW0 (struct r_dyld_chained_starts_in_segment);\n\t\t\t\t\t\tif (!cur_seg) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbin->chained_starts[seg_idx] = cur_seg;\n\t\t\t\t\t\tcur_seg->pointer_format = DYLD_CHAINED_PTR_ARM64E;\n\t\t\t\t\t\tcur_seg->page_size = ps;\n\t\t\t\t\t\tcur_seg->page_count = ((bin->segs[seg_idx].vmsize + (ps - 1)) & ~(ps - 1)) / ps;\n\t\t\t\t\t\tif (cur_seg->page_count > 0) {\n\t\t\t\t\t\t\tcur_seg->page_start = malloc (sizeof (ut16) * cur_seg->page_count);\n\t\t\t\t\t\t\tif (!cur_seg->page_start) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmemset (cur_seg->page_start, 0xff, sizeof (ut16) * cur_seg->page_count);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (cur_seg) {\n\t\t\t\t\tut32 page_index = (ut32)(seg_off / ps);\n\t\t\t\t\tsize_t maxsize = cur_seg->page_count * sizeof (ut16);\n\t\t\t\t\tif (page_index < maxsize && cur_seg->page_start) {\n\t\t\t\t\t\tcur_seg->page_start[page_index] = seg_off & 0xfff;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tbprintf (\"Error: Unexpected BIND_OPCODE_THREADED sub-opcode: 0x%x\\n\", imm);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase BIND_OPCODE_SET_DYLIB_ORDINAL_IMM:\n\t\tcase BIND_OPCODE_SET_DYLIB_SPECIAL_IMM:\n\t\tcase BIND_OPCODE_SET_TYPE_IMM:\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB:\n\t\t\tread_uleb128 (&p, end);\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM:\n\t\t\twhile (*p++ && p < end) {\n\t\t\t\t/* empty loop */\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_SET_ADDEND_SLEB:\n\t\t\tr_sleb128 ((const ut8 **)&p, end);\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB:\n\t\t\tseg_idx = imm;\n\t\t\tif (seg_idx >= bin->nsegs) {\n\t\t\t\tbprintf (\"Error: BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB\"\n\t\t\t\t\t\" has unexistent segment %d\\n\", seg_idx);\n\t\t\t\tR_FREE (opcodes);\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tseg_off = read_uleb128 (&p, end);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_ADD_ADDR_ULEB:\n\t\t\tseg_off += read_uleb128 (&p, end);\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_DO_BIND:\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB:\n\t\t\tseg_off += read_uleb128 (&p, end) + wordsize;\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED:\n\t\t\tseg_off += (ut64)imm * (ut64)wordsize + wordsize;\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB:\n\t\t\tcount = read_uleb128 (&p, end);\n\t\t\tskip = read_uleb128 (&p, end);\n\t\t\tfor (j = 0; j < count; j++) {\n\t\t\t\tseg_off += skip + wordsize;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbprintf (\"Error: unknown bind opcode 0x%02x in dyld_info\\n\", *p);\n\t\t\tR_FREE (opcodes);\n\t\t\treturn false;\n\t\t}\n\t}\n\tR_FREE (opcodes);\n\n\tbin->segs_count = bin->nsegs;\n\treturn true;\n}",
  "abstract_func": "static bool reconstruct_chained_fixup(struct MACH0_(obj_t) *VAR_0) {\n\tif (!VAR_0->dyld_info) {\n\t\treturn false;\n\t}\n\tif (!VAR_0->nsegs) {\n\t\treturn false;\n\t}\n\tVAR_0->chained_starts = R_NEWS0 (struct VAR_1 *, VAR_0->nsegs);\n\tif (!VAR_0->chained_starts) {\n\t\treturn false;\n\t}\n\tsize_t VAR_2 = get_word_size (VAR_0);\n\tut8 *VAR_3 = NULL;\n\tsize_t VAR_4, VAR_5, VAR_6, VAR_7;\n\tint VAR_8 = 0;\n\tut64 VAR_9 = 0;\n\tVAR_7 = VAR_0->dyld_info->bind_size;\n\tif (!VAR_7 || VAR_7 < 1) {\n\t\treturn false;\n\t}\n\tif (VAR_0->dyld_info->bind_off > VAR_0->size) {\n\t\treturn false;\n\t}\n\tif (VAR_0->dyld_info->bind_off + VAR_7 > VAR_0->size) {\n\t\treturn false;\n\t}\n\tut8 *VAR_10 = calloc (1, VAR_7 + 1);\n\tif (!VAR_10) {\n\t\treturn false;\n\t}\n\tif (r_buf_read_at (VAR_0->b, VAR_0->dyld_info->bind_off, VAR_10, VAR_7) != VAR_7) {\n\t\tbprintf (\"Error: read (dyld_info bind) at 0x%08\"VAR_11\"\\n\", (ut64)(size_t)VAR_0->dyld_info->bind_off);\n\t\tR_FREE (VAR_10);\n\t\treturn false;\n\t}\n\tstruct r_dyld_chained_starts_in_segment *VAR_12 = NULL;\n\tsize_t VAR_13 = 0;\n\tut8 *VAR_14;\n\tbool VAR_15 = false;\n\tfor (VAR_3 = VAR_10, VAR_14 = VAR_10 + VAR_7; !VAR_15 && VAR_3 < VAR_14;) {\n\t\tut8 VAR_16 = *VAR_3 & VAR_17, VAR_18 = *VAR_3 & VAR_19;\n\t\tVAR_3++;\n\t\tswitch (VAR_18) {\n\t\tcase VAR_20:\n\t\t\tVAR_15 = true;\n\t\t\tbreak;\n\t\tcase VAR_21: {\n\t\t\tswitch (VAR_16) {\n\t\t\tcase VAR_22: {\n\t\t\t\tread_uleb128 (&VAR_3, VAR_14);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase VAR_23: {\n\t\t\t\tconst size_t VAR_24 = 0x1000;\n\t\t\t\tif (!VAR_12 || VAR_13 != VAR_8) {\n\t\t\t\t\tVAR_13 = VAR_8;\n\t\t\t\t\tVAR_12 = VAR_0->chained_starts[VAR_8];\n\t\t\t\t\tif (!VAR_12) {\n\t\t\t\t\t\tVAR_12 = R_NEW0 (struct r_dyld_chained_starts_in_segment);\n\t\t\t\t\t\tif (!VAR_12) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tVAR_0->chained_starts[VAR_8] = VAR_12;\n\t\t\t\t\t\tVAR_12->pointer_format = VAR_25;\n\t\t\t\t\t\tVAR_12->page_size = VAR_24;\n\t\t\t\t\t\tVAR_12->page_count = ((VAR_0->segs[VAR_8].vmsize + (VAR_24 - 1)) & ~(VAR_24 - 1)) / VAR_24;\n\t\t\t\t\t\tif (VAR_12->page_count > 0) {\n\t\t\t\t\t\t\tVAR_12->page_start = malloc (sizeof (VAR_26) * VAR_12->page_count);\n\t\t\t\t\t\t\tif (!VAR_12->page_start) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmemset (VAR_12->page_start, 0xff, sizeof (VAR_26) * VAR_12->page_count);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (VAR_12) {\n\t\t\t\t\tut32 VAR_27 = (ut32)(VAR_9 / VAR_24);\n\t\t\t\t\tsize_t VAR_28 = VAR_12->page_count * sizeof (VAR_26);\n\t\t\t\t\tif (VAR_27 < VAR_28 && VAR_12->page_start) {\n\t\t\t\t\t\tVAR_12->page_start[VAR_27] = VAR_9 & 0xfff;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tbprintf (\"Error: Unexpected BIND_OPCODE_THREADED sub-opcode: 0x%x\\n\", VAR_16);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase VAR_29:\n\t\tcase VAR_30:\n\t\tcase VAR_31:\n\t\t\tbreak;\n\t\tcase VAR_32:\n\t\t\tread_uleb128 (&VAR_3, VAR_14);\n\t\t\tbreak;\n\t\tcase VAR_33:\n\t\t\twhile (*VAR_3++ && VAR_3 < VAR_14) {\n\t\t\t\t/* COMMENT_0 */\n\t\t\t}\n\t\t\tbreak;\n\t\tcase VAR_34:\n\t\t\tr_sleb128 ((const ut8 **)&VAR_3, VAR_14);\n\t\t\tbreak;\n\t\tcase VAR_35:\n\t\t\tVAR_8 = VAR_16;\n\t\t\tif (VAR_8 >= VAR_0->nsegs) {\n\t\t\t\tbprintf (\"Error: BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB\"\n\t\t\t\t\t\" has unexistent segment %d\\n\", VAR_8);\n\t\t\t\tR_FREE (VAR_10);\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tVAR_9 = read_uleb128 (&VAR_3, VAR_14);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase VAR_36:\n\t\t\tVAR_9 += read_uleb128 (&VAR_3, VAR_14);\n\t\t\tbreak;\n\t\tcase VAR_37:\n\t\t\tbreak;\n\t\tcase VAR_38:\n\t\t\tVAR_9 += read_uleb128 (&VAR_3, VAR_14) + VAR_2;\n\t\t\tbreak;\n\t\tcase VAR_39:\n\t\t\tVAR_9 += (ut64)VAR_16 * (ut64)VAR_2 + VAR_2;\n\t\t\tbreak;\n\t\tcase VAR_40:\n\t\t\tVAR_5 = read_uleb128 (&VAR_3, VAR_14);\n\t\t\tVAR_6 = read_uleb128 (&VAR_3, VAR_14);\n\t\t\tfor (VAR_4 = 0; VAR_4 < VAR_5; VAR_4++) {\n\t\t\t\tVAR_9 += VAR_6 + VAR_2;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbprintf (\"Error: unknown bind opcode 0x%02x in dyld_info\\n\", *VAR_3);\n\t\t\tR_FREE (VAR_10);\n\t\t\treturn false;\n\t\t}\n\t}\n\tR_FREE (VAR_10);\n\n\tVAR_0->segs_count = VAR_0->nsegs;\n\treturn true;\n}",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -139,5 +139,6 @@\n \t}\n \tR_FREE (opcodes);\n \n+\tbin->segs_count = bin->nsegs;\n \treturn true;\n }",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "\tbin->segs_count = bin->nsegs;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/radareorg/radare2/pull/19859",
  "description": {
    "pr_info": {
      "title": "Fix heap OOB read in macho.iterate_chained_fixups ##crash",
      "number": 19859
    },
    "comment": [
      "* Reported by peacock-doris via huntr.dev\r\n* Reproducer 'tests_65305'\r\n\r\n<!--\r\nRead https://github.com/radareorg/radare2/blob/master/DEVELOPERS.md\r\n* PR title must be capitalized, concise and use ##tags\r\n* If the PR is fixing a ticket use 'Fix #1234 - ..' in the commit message\r\n* Follow the coding style, add tests and documentation if necessary\r\n-->\r\n\r\n- [ ] Mark this if you consider it ready to merge\r\n- [ ] I've added tests (optional)\r\n- [ ] I wrote some lines in the [book](https://github.com/radareorg/radare2book) (optional)\r\n\r\n**Description**\r\n\r\n<!-- explain your changes if necessary -->\r\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "The commit addresses a heap out-of-bounds read, a security issue, by correctly initializing segs_count to prevent invalid memory access.\n\n**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95"
}