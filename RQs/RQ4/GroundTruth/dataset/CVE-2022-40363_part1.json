{
  "cve_id": "CVE-2022-40363",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "flipperdevices/flipperzero-firmware",
  "commit_msg": "fix buffer overflow in mifar ul load",
  "commit_hash": "e77bf962323f98fc4edb4e94f392b06ab7790418",
  "git_url": "https://github.com/flipperdevices/flipperzero-firmware/commit/e77bf962323f98fc4edb4e94f392b06ab7790418",
  "file_path": "lib/nfc/nfc_device.c",
  "func_name": "nfc_device_load_mifare_ul_data",
  "func_before": "bool nfc_device_load_mifare_ul_data(FlipperFormat* file, NfcDevice* dev) {\n    bool parsed = false;\n    MfUltralightData* data = &dev->dev_data.mf_ul_data;\n    string_t temp_str;\n    string_init(temp_str);\n    uint32_t data_format_version = 0;\n\n    do {\n        // Read Mifare Ultralight format version\n        if(!flipper_format_read_uint32(file, \"Data format version\", &data_format_version, 1)) {\n            if(!flipper_format_rewind(file)) break;\n        }\n\n        // Read signature\n        if(!flipper_format_read_hex(file, \"Signature\", data->signature, sizeof(data->signature)))\n            break;\n        // Read Mifare version\n        if(!flipper_format_read_hex(\n               file, \"Mifare version\", (uint8_t*)&data->version, sizeof(data->version)))\n            break;\n        // Read counters and tearing flags\n        bool counters_parsed = true;\n        for(uint8_t i = 0; i < 3; i++) {\n            string_printf(temp_str, \"Counter %d\", i);\n            if(!flipper_format_read_uint32(file, string_get_cstr(temp_str), &data->counter[i], 1)) {\n                counters_parsed = false;\n                break;\n            }\n            string_printf(temp_str, \"Tearing %d\", i);\n            if(!flipper_format_read_hex(file, string_get_cstr(temp_str), &data->tearing[i], 1)) {\n                counters_parsed = false;\n                break;\n            }\n        }\n        if(!counters_parsed) break;\n        // Read pages\n        uint32_t pages_total = 0;\n        if(!flipper_format_read_uint32(file, \"Pages total\", &pages_total, 1)) break;\n        uint32_t pages_read = 0;\n        if(data_format_version < nfc_mifare_ultralight_data_format_version) {\n            pages_read = pages_total;\n        } else {\n            if(!flipper_format_read_uint32(file, \"Pages read\", &pages_read, 1)) break;\n        }\n        data->data_size = pages_total * 4;\n        data->data_read = pages_read * 4;\n        bool pages_parsed = true;\n        for(uint16_t i = 0; i < pages_total; i++) {\n            string_printf(temp_str, \"Page %d\", i);\n            if(!flipper_format_read_hex(file, string_get_cstr(temp_str), &data->data[i * 4], 4)) {\n                pages_parsed = false;\n                break;\n            }\n        }\n        if(!pages_parsed) break;\n\n        // Read authentication counter\n        uint32_t auth_counter;\n        if(!flipper_format_read_uint32(file, \"Failed authentication attempts\", &auth_counter, 1))\n            auth_counter = 0;\n\n        parsed = true;\n    } while(false);\n\n    string_clear(temp_str);\n    return parsed;\n}",
  "abstract_func_before": "bool nfc_device_load_mifare_ul_data(FlipperFormat* VAR_0, NfcDevice* VAR_1) {\n    bool VAR_2 = false;\n    MfUltralightData* VAR_3 = &VAR_1->dev_data.mf_ul_data;\n    string_t VAR_4;\n    string_init(VAR_4);\n    uint32_t VAR_5 = 0;\n\n    do {\n        /* COMMENT_0 */\n        if(!flipper_format_read_uint32(VAR_0, \"Data format version\", &VAR_5, 1)) {\n            if(!flipper_format_rewind(VAR_0)) break;\n        }\n\n        /* COMMENT_1 */\n        if(!flipper_format_read_hex(VAR_0, \"Signature\", VAR_3->signature, sizeof(VAR_3->signature)))\n            break;\n        /* COMMENT_2 */\n        if(!flipper_format_read_hex(\n               VAR_0, \"Mifare version\", (uint8_t*)&VAR_3->version, sizeof(VAR_3->version)))\n            break;\n        /* COMMENT_3 */\n        bool VAR_6 = true;\n        for(uint8_t VAR_7 = 0; VAR_7 < 3; VAR_7++) {\n            string_printf(VAR_4, \"Counter %d\", VAR_7);\n            if(!flipper_format_read_uint32(VAR_0, string_get_cstr(VAR_4), &VAR_3->counter[VAR_7], 1)) {\n                VAR_6 = false;\n                break;\n            }\n            string_printf(VAR_4, \"Tearing %d\", VAR_7);\n            if(!flipper_format_read_hex(VAR_0, string_get_cstr(VAR_4), &VAR_3->tearing[VAR_7], 1)) {\n                VAR_6 = false;\n                break;\n            }\n        }\n        if(!VAR_6) break;\n        /* COMMENT_4 */\n        uint32_t VAR_8 = 0;\n        if(!flipper_format_read_uint32(VAR_0, \"Pages total\", &VAR_8, 1)) break;\n        uint32_t VAR_9 = 0;\n        if(VAR_5 < VAR_10) {\n            VAR_9 = VAR_8;\n        } else {\n            if(!flipper_format_read_uint32(VAR_0, \"Pages read\", &VAR_9, 1)) break;\n        }\n        VAR_3->data_size = VAR_8 * 4;\n        VAR_3->data_read = VAR_9 * 4;\n        bool VAR_11 = true;\n        for(uint16_t VAR_7 = 0; VAR_7 < VAR_8; VAR_7++) {\n            string_printf(VAR_4, \"Page %d\", VAR_7);\n            if(!flipper_format_read_hex(VAR_0, string_get_cstr(VAR_4), &VAR_3->data[VAR_7 * 4], 4)) {\n                VAR_11 = false;\n                break;\n            }\n        }\n        if(!VAR_11) break;\n\n        /* COMMENT_5 */\n        uint32_t VAR_12;\n        if(!flipper_format_read_uint32(VAR_0, \"Failed authentication attempts\", &VAR_12, 1))\n            VAR_12 = 0;\n\n        VAR_2 = true;\n    } while(false);\n\n    string_clear(VAR_4);\n    return VAR_2;\n}",
  "func_graph_path_before": "flipperdevices/flipperzero-firmware/e77bf962323f98fc4edb4e94f392b06ab7790418/nfc_device.c/vul/before/0.json",
  "func": "bool nfc_device_load_mifare_ul_data(FlipperFormat* file, NfcDevice* dev) {\n    bool parsed = false;\n    MfUltralightData* data = &dev->dev_data.mf_ul_data;\n    string_t temp_str;\n    string_init(temp_str);\n    uint32_t data_format_version = 0;\n\n    do {\n        // Read Mifare Ultralight format version\n        if(!flipper_format_read_uint32(file, \"Data format version\", &data_format_version, 1)) {\n            if(!flipper_format_rewind(file)) break;\n        }\n\n        // Read signature\n        if(!flipper_format_read_hex(file, \"Signature\", data->signature, sizeof(data->signature)))\n            break;\n        // Read Mifare version\n        if(!flipper_format_read_hex(\n               file, \"Mifare version\", (uint8_t*)&data->version, sizeof(data->version)))\n            break;\n        // Read counters and tearing flags\n        bool counters_parsed = true;\n        for(uint8_t i = 0; i < 3; i++) {\n            string_printf(temp_str, \"Counter %d\", i);\n            if(!flipper_format_read_uint32(file, string_get_cstr(temp_str), &data->counter[i], 1)) {\n                counters_parsed = false;\n                break;\n            }\n            string_printf(temp_str, \"Tearing %d\", i);\n            if(!flipper_format_read_hex(file, string_get_cstr(temp_str), &data->tearing[i], 1)) {\n                counters_parsed = false;\n                break;\n            }\n        }\n        if(!counters_parsed) break;\n        // Read pages\n        uint32_t pages_total = 0;\n        if(!flipper_format_read_uint32(file, \"Pages total\", &pages_total, 1)) break;\n        uint32_t pages_read = 0;\n        if(data_format_version < nfc_mifare_ultralight_data_format_version) {\n            pages_read = pages_total;\n        } else {\n            if(!flipper_format_read_uint32(file, \"Pages read\", &pages_read, 1)) break;\n        }\n        data->data_size = pages_total * 4;\n        data->data_read = pages_read * 4;\n        if(data->data_size > MF_UL_MAX_DUMP_SIZE || data->data_read > MF_UL_MAX_DUMP_SIZE) break;\n        bool pages_parsed = true;\n        for(uint16_t i = 0; i < pages_total; i++) {\n            string_printf(temp_str, \"Page %d\", i);\n            if(!flipper_format_read_hex(file, string_get_cstr(temp_str), &data->data[i * 4], 4)) {\n                pages_parsed = false;\n                break;\n            }\n        }\n        if(!pages_parsed) break;\n\n        // Read authentication counter\n        uint32_t auth_counter;\n        if(!flipper_format_read_uint32(file, \"Failed authentication attempts\", &auth_counter, 1))\n            auth_counter = 0;\n\n        parsed = true;\n    } while(false);\n\n    string_clear(temp_str);\n    return parsed;\n}",
  "abstract_func": "bool nfc_device_load_mifare_ul_data(FlipperFormat* VAR_0, NfcDevice* VAR_1) {\n    bool VAR_2 = false;\n    MfUltralightData* VAR_3 = &VAR_1->dev_data.mf_ul_data;\n    string_t VAR_4;\n    string_init(VAR_4);\n    uint32_t VAR_5 = 0;\n\n    do {\n        /* COMMENT_0 */\n        if(!flipper_format_read_uint32(VAR_0, \"Data format version\", &VAR_5, 1)) {\n            if(!flipper_format_rewind(VAR_0)) break;\n        }\n\n        /* COMMENT_1 */\n        if(!flipper_format_read_hex(VAR_0, \"Signature\", VAR_3->signature, sizeof(VAR_3->signature)))\n            break;\n        /* COMMENT_2 */\n        if(!flipper_format_read_hex(\n               VAR_0, \"Mifare version\", (uint8_t*)&VAR_3->version, sizeof(VAR_3->version)))\n            break;\n        /* COMMENT_3 */\n        bool VAR_6 = true;\n        for(uint8_t VAR_7 = 0; VAR_7 < 3; VAR_7++) {\n            string_printf(VAR_4, \"Counter %d\", VAR_7);\n            if(!flipper_format_read_uint32(VAR_0, string_get_cstr(VAR_4), &VAR_3->counter[VAR_7], 1)) {\n                VAR_6 = false;\n                break;\n            }\n            string_printf(VAR_4, \"Tearing %d\", VAR_7);\n            if(!flipper_format_read_hex(VAR_0, string_get_cstr(VAR_4), &VAR_3->tearing[VAR_7], 1)) {\n                VAR_6 = false;\n                break;\n            }\n        }\n        if(!VAR_6) break;\n        /* COMMENT_4 */\n        uint32_t VAR_8 = 0;\n        if(!flipper_format_read_uint32(VAR_0, \"Pages total\", &VAR_8, 1)) break;\n        uint32_t VAR_9 = 0;\n        if(VAR_5 < VAR_10) {\n            VAR_9 = VAR_8;\n        } else {\n            if(!flipper_format_read_uint32(VAR_0, \"Pages read\", &VAR_9, 1)) break;\n        }\n        VAR_3->data_size = VAR_8 * 4;\n        VAR_3->data_read = VAR_9 * 4;\n        if(VAR_3->data_size > VAR_11 || VAR_3->data_read > VAR_11) break;\n        bool VAR_12 = true;\n        for(uint16_t VAR_7 = 0; VAR_7 < VAR_8; VAR_7++) {\n            string_printf(VAR_4, \"Page %d\", VAR_7);\n            if(!flipper_format_read_hex(VAR_0, string_get_cstr(VAR_4), &VAR_3->data[VAR_7 * 4], 4)) {\n                VAR_12 = false;\n                break;\n            }\n        }\n        if(!VAR_12) break;\n\n        /* COMMENT_5 */\n        uint32_t VAR_13;\n        if(!flipper_format_read_uint32(VAR_0, \"Failed authentication attempts\", &VAR_13, 1))\n            VAR_13 = 0;\n\n        VAR_2 = true;\n    } while(false);\n\n    string_clear(VAR_4);\n    return VAR_2;\n}",
  "func_graph_path": "flipperdevices/flipperzero-firmware/e77bf962323f98fc4edb4e94f392b06ab7790418/nfc_device.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -44,6 +44,7 @@\n         }\n         data->data_size = pages_total * 4;\n         data->data_read = pages_read * 4;\n+        if(data->data_size > MF_UL_MAX_DUMP_SIZE || data->data_read > MF_UL_MAX_DUMP_SIZE) break;\n         bool pages_parsed = true;\n         for(uint16_t i = 0; i < pages_total; i++) {\n             string_printf(temp_str, \"Page %d\", i);",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "        if(data->data_size > MF_UL_MAX_DUMP_SIZE || data->data_read > MF_UL_MAX_DUMP_SIZE) break;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/flipperdevices/flipperzero-firmware/pull/1697",
  "description": {
    "pr_info": {
      "title": "fix buffer overflow in mifare ul load",
      "number": 1697
    },
    "comment": [
      "# What's new\r\n\r\nA buffer overflow exists in `nfc_device_load_mifare_ul_data` when the `pages_total` value is greater than `MF_UL_MAX_DUMP_SIZE`. This occurs because `pages_total` is parsed from the nfc file and not checked against the max size of the buffer.  An nfc file with a page count greater than 2040 will result in an out of bounds write.\r\n\r\nThis may result in various crashes including a BusFault crash, and a NULL point exception. In some cases, this require re-flashing flipper firmware to recover the device :(\r\n\r\n<img width=\"825\" alt=\"CleanShot 2022-09-02 at 12 55 48@2x\" src=\"https://user-images.githubusercontent.com/46228229/188202328-cf434c9b-7bbf-477b-8e3d-7e2ecda047d6.png\">\r\n\r\nShout out to https://tmpout.sh/bggp/3/ for giving me a reason to look for bugs!!  Maybe more to come ;)\r\n\r\n# Verification \r\n\r\nUpload an nfc file containing more than 2040 pages. An example file (that will produce a null pointer deference) is provided here:\r\nhttps://gist.github.com/VVX7/c55b122846253e12f1647e2a85ab2775\r\n\r\nSteps:\r\n- Upload the nfc file\r\n- Navigate to `saved` nfc submenu and load the file\r\n- view file info to trigger the crash\r\n\r\nNote:\r\nLarger files will result in similar unexpected behaviour and may not require viewing file info to trigger crash.\r\n\r\n# Impact\r\n\r\nAn attacker could place a malicious Amiibo file in a repository like this: https://github.com/Gioman101/FlipperAmiibo/\r\n\r\n# Checklist (For Reviewer)\r\n\r\n- [x] PR has description of feature/bug or link to Confluence/Jira task\r\n- [x] Description contains actions to verify feature/bugfix\r\n- [x] I've built this code, uploaded it to the device and verified feature/bugfix\r\n",
      "Hello @VVX7 . Am I right that there is no actual NFC tag with so many pages? This file was made by hands?",
      "hiya @gornekich , that's right. The file was made by hand. The risk comes from someone inserting a malicious file into database of Amiibos or something similar as I linked above.\r\n\r\nMight also be able to emulate an NFC with unusually high page count using a proxmark or hydrabus, idk.  I should go poke at that..."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.97,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.97\n\n**Step-by-Step Explanation:**\n\n1. **Input Analysis:** The commit message explicitly mentions \"fix buffer overflow,\" and the code diff adds a bounds check. Vulnerability details confirm a security issue.\n2. **Purpose Evaluation:** The code change directly addresses an exploitable buffer overflow, a security risk.\n3. **Security Assessment:** The patch mitigates an external exploit, preventing crashes and potential system compromise.\n4. **Confidence Justification:** All elements clearly indicate a security fix with no ambiguities.\n\n**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.97"
}