{
  "cve_id": "CVE-2018-1000524",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "spheredev/neosphere",
  "commit_msg": "Fix integer overflow in layer_resize in map_engine.c (#268)\n\n* Fix integer overflow in layer_resize in map_engine.c\r\n\r\nThere's a buffer overflow bug in the function layer_resize. It allocates\r\na buffer `tilemap` with size `x_size * y_size * sizeof(struct map_tile)`.\r\nBut it didn't check for integer overflow, so if x_size and y_size are\r\nvery large, it's possible that the buffer size is smaller than needed,\r\ncausing a buffer overflow later.\r\n\r\nPoC: `SetLayerSize(0, 0x7FFFFFFF, 0x7FFFFFFF);`\r\n\r\n* move malloc to a separate line",
  "commit_hash": "252c1ca184cb38e1acb917aa0e451c5f08519996",
  "git_url": "https://github.com/spheredev/neosphere/commit/252c1ca184cb38e1acb917aa0e451c5f08519996",
  "file_path": "src/minisphere/map_engine.c",
  "func_name": "layer_resize",
  "func_before": "bool\nlayer_resize(int layer, int x_size, int y_size)\n{\n\tint                 old_height;\n\tint                 old_width;\n\tstruct map_tile*    tile;\n\tint                 tile_width;\n\tint                 tile_height;\n\tstruct map_tile*    tilemap;\n\tstruct map_trigger* trigger;\n\tstruct map_zone*    zone;\n\n\tint x, y, i;\n\n\told_width = s_map->layers[layer].width;\n\told_height = s_map->layers[layer].height;\n\n\t// allocate a new tilemap and copy the old layer tiles into it.  we can't simply realloc\n\t// because the tilemap is a 2D array.\n\tif (!(tilemap = malloc(x_size * y_size * sizeof(struct map_tile))))\n\t\treturn false;\n\tfor (x = 0; x < x_size; ++x) {\n\t\tfor (y = 0; y < y_size; ++y) {\n\t\t\tif (x < old_width && y < old_height) {\n\t\t\t\ttilemap[x + y * x_size] = s_map->layers[layer].tilemap[x + y * old_width];\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttile = &tilemap[x + y * x_size];\n\t\t\t\ttile->frames_left = tileset_get_delay(s_map->tileset, 0);\n\t\t\t\ttile->tile_index = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t// free the old tilemap and substitute the new one\n\tfree(s_map->layers[layer].tilemap);\n\ts_map->layers[layer].tilemap = tilemap;\n\ts_map->layers[layer].width = x_size;\n\ts_map->layers[layer].height = y_size;\n\n\t// if we resize the largest layer, the overall map size will change.\n\t// recalcuate it.\n\ttileset_get_size(s_map->tileset, &tile_width, &tile_height);\n\ts_map->width = 0;\n\ts_map->height = 0;\n\tfor (i = 0; i < s_map->num_layers; ++i) {\n\t\tif (!s_map->layers[i].is_parallax) {\n\t\t\ts_map->width = fmax(s_map->width, s_map->layers[i].width * tile_width);\n\t\t\ts_map->height = fmax(s_map->height, s_map->layers[i].height * tile_height);\n\t\t}\n\t}\n\n\t// ensure zones and triggers remain in-bounds.  if any are completely\n\t// out-of-bounds, delete them.\n\tfor (i = (int)vector_len(s_map->zones) - 1; i >= 0; --i) {\n\t\tzone = vector_get(s_map->zones, i);\n\t\tif (zone->bounds.x1 >= s_map->width || zone->bounds.y1 >= s_map->height)\n\t\t\tvector_remove(s_map->zones, i);\n\t\telse {\n\t\t\tif (zone->bounds.x2 > s_map->width)\n\t\t\t\tzone->bounds.x2 = s_map->width;\n\t\t\tif (zone->bounds.y2 > s_map->height)\n\t\t\t\tzone->bounds.y2 = s_map->height;\n\t\t}\n\t}\n\tfor (i = (int)vector_len(s_map->triggers) - 1; i >= 0; --i) {\n\t\ttrigger = vector_get(s_map->triggers, i);\n\t\tif (trigger->x >= s_map->width || trigger->y >= s_map->height)\n\t\t\tvector_remove(s_map->triggers, i);\n\t}\n\n\treturn true;\n}",
  "abstract_func_before": "bool\nlayer_resize(int VAR_0, int VAR_1, int VAR_2)\n{\n\tint                 VAR_3;\n\tint                 VAR_4;\n\tstruct map_tile*    VAR_5;\n\tint                 VAR_6;\n\tint                 VAR_7;\n\tstruct map_tile*    VAR_8;\n\tstruct map_trigger* VAR_9;\n\tstruct map_zone*    VAR_10;\n\n\tint VAR_11, VAR_12, VAR_13;\n\n\tVAR_4 = VAR_14->layers[VAR_0].width;\n\tVAR_3 = VAR_14->layers[VAR_0].height;\n\n\t/* COMMENT_0 */\n\t/* COMMENT_1 */\n\tif (!(VAR_8 = malloc(VAR_1 * VAR_2 * sizeof(struct map_tile))))\n\t\treturn false;\n\tfor (VAR_11 = 0; VAR_11 < VAR_1; ++VAR_11) {\n\t\tfor (VAR_12 = 0; VAR_12 < VAR_2; ++VAR_12) {\n\t\t\tif (VAR_11 < VAR_4 && VAR_12 < VAR_3) {\n\t\t\t\tVAR_8[VAR_11 + VAR_12 * VAR_1] = VAR_14->layers[VAR_0].tilemap[VAR_11 + VAR_12 * VAR_4];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tVAR_5 = &VAR_8[VAR_11 + VAR_12 * VAR_1];\n\t\t\t\tVAR_5->frames_left = tileset_get_delay(VAR_14->tileset, 0);\n\t\t\t\tVAR_5->tile_index = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* COMMENT_2 */\n\tfree(VAR_14->layers[VAR_0].tilemap);\n\tVAR_14->layers[VAR_0].tilemap = VAR_8;\n\tVAR_14->layers[VAR_0].width = VAR_1;\n\tVAR_14->layers[VAR_0].height = VAR_2;\n\n\t/* COMMENT_3 */\n\t/* COMMENT_4 */\n\ttileset_get_size(VAR_14->tileset, &VAR_6, &VAR_7);\n\tVAR_14->width = 0;\n\tVAR_14->height = 0;\n\tfor (VAR_13 = 0; VAR_13 < VAR_14->num_layers; ++VAR_13) {\n\t\tif (!VAR_14->layers[VAR_13].is_parallax) {\n\t\t\tVAR_14->width = fmax(VAR_14->width, VAR_14->layers[VAR_13].width * VAR_6);\n\t\t\tVAR_14->height = fmax(VAR_14->height, VAR_14->layers[VAR_13].height * VAR_7);\n\t\t}\n\t}\n\n\t/* COMMENT_5 */\n\t/* COMMENT_6 */\n\tfor (VAR_13 = (int)vector_len(VAR_14->zones) - 1; VAR_13 >= 0; --VAR_13) {\n\t\tVAR_10 = vector_get(VAR_14->zones, VAR_13);\n\t\tif (VAR_10->bounds.x1 >= VAR_14->width || VAR_10->bounds.y1 >= VAR_14->height)\n\t\t\tvector_remove(VAR_14->zones, VAR_13);\n\t\telse {\n\t\t\tif (VAR_10->bounds.x2 > VAR_14->width)\n\t\t\t\tVAR_10->bounds.x2 = VAR_14->width;\n\t\t\tif (VAR_10->bounds.y2 > VAR_14->height)\n\t\t\t\tVAR_10->bounds.y2 = VAR_14->height;\n\t\t}\n\t}\n\tfor (VAR_13 = (int)vector_len(VAR_14->triggers) - 1; VAR_13 >= 0; --VAR_13) {\n\t\tVAR_9 = vector_get(VAR_14->triggers, VAR_13);\n\t\tif (VAR_9->x >= VAR_14->width || VAR_9->y >= VAR_14->height)\n\t\t\tvector_remove(VAR_14->triggers, VAR_13);\n\t}\n\n\treturn true;\n}",
  "func_graph_path_before": "spheredev/neosphere/252c1ca184cb38e1acb917aa0e451c5f08519996/map_engine.c/vul/before/0.json",
  "func": "bool\nlayer_resize(int layer, int x_size, int y_size)\n{\n\tint                 old_height;\n\tint                 old_width;\n\tstruct map_tile*    tile;\n\tint                 tile_width;\n\tint                 tile_height;\n\tstruct map_tile*    tilemap;\n\tstruct map_trigger* trigger;\n\tstruct map_zone*    zone;\n\tsize_t              tilemap_size;\n\n\tint x, y, i;\n\n\told_width = s_map->layers[layer].width;\n\told_height = s_map->layers[layer].height;\n\n\t// allocate a new tilemap and copy the old layer tiles into it.  we can't simply realloc\n\t// because the tilemap is a 2D array.\n\ttilemap_size = x_size * y_size * sizeof(struct map_tile);\n\tif (x_size == 0 || tilemap_size / x_size / sizeof(struct map_tile) != y_size\n\t\t|| !(tilemap = malloc(tilemap_size)))\n\t\treturn false;\n\tfor (x = 0; x < x_size; ++x) {\n\t\tfor (y = 0; y < y_size; ++y) {\n\t\t\tif (x < old_width && y < old_height) {\n\t\t\t\ttilemap[x + y * x_size] = s_map->layers[layer].tilemap[x + y * old_width];\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttile = &tilemap[x + y * x_size];\n\t\t\t\ttile->frames_left = tileset_get_delay(s_map->tileset, 0);\n\t\t\t\ttile->tile_index = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t// free the old tilemap and substitute the new one\n\tfree(s_map->layers[layer].tilemap);\n\ts_map->layers[layer].tilemap = tilemap;\n\ts_map->layers[layer].width = x_size;\n\ts_map->layers[layer].height = y_size;\n\n\t// if we resize the largest layer, the overall map size will change.\n\t// recalcuate it.\n\ttileset_get_size(s_map->tileset, &tile_width, &tile_height);\n\ts_map->width = 0;\n\ts_map->height = 0;\n\tfor (i = 0; i < s_map->num_layers; ++i) {\n\t\tif (!s_map->layers[i].is_parallax) {\n\t\t\ts_map->width = fmax(s_map->width, s_map->layers[i].width * tile_width);\n\t\t\ts_map->height = fmax(s_map->height, s_map->layers[i].height * tile_height);\n\t\t}\n\t}\n\n\t// ensure zones and triggers remain in-bounds.  if any are completely\n\t// out-of-bounds, delete them.\n\tfor (i = (int)vector_len(s_map->zones) - 1; i >= 0; --i) {\n\t\tzone = vector_get(s_map->zones, i);\n\t\tif (zone->bounds.x1 >= s_map->width || zone->bounds.y1 >= s_map->height)\n\t\t\tvector_remove(s_map->zones, i);\n\t\telse {\n\t\t\tif (zone->bounds.x2 > s_map->width)\n\t\t\t\tzone->bounds.x2 = s_map->width;\n\t\t\tif (zone->bounds.y2 > s_map->height)\n\t\t\t\tzone->bounds.y2 = s_map->height;\n\t\t}\n\t}\n\tfor (i = (int)vector_len(s_map->triggers) - 1; i >= 0; --i) {\n\t\ttrigger = vector_get(s_map->triggers, i);\n\t\tif (trigger->x >= s_map->width || trigger->y >= s_map->height)\n\t\t\tvector_remove(s_map->triggers, i);\n\t}\n\n\treturn true;\n}",
  "abstract_func": "bool\nlayer_resize(int VAR_0, int VAR_1, int VAR_2)\n{\n\tint                 VAR_3;\n\tint                 VAR_4;\n\tstruct map_tile*    VAR_5;\n\tint                 VAR_6;\n\tint                 VAR_7;\n\tstruct map_tile*    VAR_8;\n\tstruct map_trigger* VAR_9;\n\tstruct map_zone*    VAR_10;\n\tsize_t              VAR_11;\n\n\tint VAR_12, VAR_13, VAR_14;\n\n\tVAR_4 = VAR_15->layers[VAR_0].width;\n\tVAR_3 = VAR_15->layers[VAR_0].height;\n\n\t/* COMMENT_0 */\n\t/* COMMENT_1 */\n\tVAR_11 = VAR_1 * VAR_2 * sizeof(struct map_tile);\n\tif (VAR_1 == 0 || VAR_11 / VAR_1 / sizeof(struct map_tile) != VAR_2\n\t\t|| !(VAR_8 = malloc(VAR_11)))\n\t\treturn false;\n\tfor (VAR_12 = 0; VAR_12 < VAR_1; ++VAR_12) {\n\t\tfor (VAR_13 = 0; VAR_13 < VAR_2; ++VAR_13) {\n\t\t\tif (VAR_12 < VAR_4 && VAR_13 < VAR_3) {\n\t\t\t\tVAR_8[VAR_12 + VAR_13 * VAR_1] = VAR_15->layers[VAR_0].tilemap[VAR_12 + VAR_13 * VAR_4];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tVAR_5 = &VAR_8[VAR_12 + VAR_13 * VAR_1];\n\t\t\t\tVAR_5->frames_left = tileset_get_delay(VAR_15->tileset, 0);\n\t\t\t\tVAR_5->tile_index = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* COMMENT_2 */\n\tfree(VAR_15->layers[VAR_0].tilemap);\n\tVAR_15->layers[VAR_0].tilemap = VAR_8;\n\tVAR_15->layers[VAR_0].width = VAR_1;\n\tVAR_15->layers[VAR_0].height = VAR_2;\n\n\t/* COMMENT_3 */\n\t/* COMMENT_4 */\n\ttileset_get_size(VAR_15->tileset, &VAR_6, &VAR_7);\n\tVAR_15->width = 0;\n\tVAR_15->height = 0;\n\tfor (VAR_14 = 0; VAR_14 < VAR_15->num_layers; ++VAR_14) {\n\t\tif (!VAR_15->layers[VAR_14].is_parallax) {\n\t\t\tVAR_15->width = fmax(VAR_15->width, VAR_15->layers[VAR_14].width * VAR_6);\n\t\t\tVAR_15->height = fmax(VAR_15->height, VAR_15->layers[VAR_14].height * VAR_7);\n\t\t}\n\t}\n\n\t/* COMMENT_5 */\n\t/* COMMENT_6 */\n\tfor (VAR_14 = (int)vector_len(VAR_15->zones) - 1; VAR_14 >= 0; --VAR_14) {\n\t\tVAR_10 = vector_get(VAR_15->zones, VAR_14);\n\t\tif (VAR_10->bounds.x1 >= VAR_15->width || VAR_10->bounds.y1 >= VAR_15->height)\n\t\t\tvector_remove(VAR_15->zones, VAR_14);\n\t\telse {\n\t\t\tif (VAR_10->bounds.x2 > VAR_15->width)\n\t\t\t\tVAR_10->bounds.x2 = VAR_15->width;\n\t\t\tif (VAR_10->bounds.y2 > VAR_15->height)\n\t\t\t\tVAR_10->bounds.y2 = VAR_15->height;\n\t\t}\n\t}\n\tfor (VAR_14 = (int)vector_len(VAR_15->triggers) - 1; VAR_14 >= 0; --VAR_14) {\n\t\tVAR_9 = vector_get(VAR_15->triggers, VAR_14);\n\t\tif (VAR_9->x >= VAR_15->width || VAR_9->y >= VAR_15->height)\n\t\t\tvector_remove(VAR_15->triggers, VAR_14);\n\t}\n\n\treturn true;\n}",
  "func_graph_path": "spheredev/neosphere/252c1ca184cb38e1acb917aa0e451c5f08519996/map_engine.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -9,6 +9,7 @@\n \tstruct map_tile*    tilemap;\n \tstruct map_trigger* trigger;\n \tstruct map_zone*    zone;\n+\tsize_t              tilemap_size;\n \n \tint x, y, i;\n \n@@ -17,7 +18,9 @@\n \n \t// allocate a new tilemap and copy the old layer tiles into it.  we can't simply realloc\n \t// because the tilemap is a 2D array.\n-\tif (!(tilemap = malloc(x_size * y_size * sizeof(struct map_tile))))\n+\ttilemap_size = x_size * y_size * sizeof(struct map_tile);\n+\tif (x_size == 0 || tilemap_size / x_size / sizeof(struct map_tile) != y_size\n+\t\t|| !(tilemap = malloc(tilemap_size)))\n \t\treturn false;\n \tfor (x = 0; x < x_size; ++x) {\n \t\tfor (y = 0; y < y_size; ++y) {",
  "diff_line_info": {
    "deleted_lines": [
      "\tif (!(tilemap = malloc(x_size * y_size * sizeof(struct map_tile))))"
    ],
    "added_lines": [
      "\tsize_t              tilemap_size;",
      "\ttilemap_size = x_size * y_size * sizeof(struct map_tile);",
      "\tif (x_size == 0 || tilemap_size / x_size / sizeof(struct map_tile) != y_size",
      "\t\t|| !(tilemap = malloc(tilemap_size)))"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/spheredev/neosphere/pull/268",
  "description": {
    "pr_info": {
      "title": "Fix integer overflow in layer_resize in map_engine.c",
      "number": 268
    },
    "comment": [
      "There's a buffer overflow bug in the function layer_resize. It allocates a buffer `tilemap` with size `x_size * y_size * sizeof(struct map_tile)`. But it didn't check for integer overflow, so if x_size and y_size are very large, it's possible that the buffer size is smaller than needed, causing a buffer overflow.\r\n\r\nPoC:\r\n`SetLayerSize(0, 0x7FFFFFFF, 0x7FFFFFFF);`",
      "There are probably more where this came from; I am admittedly pretty lazy about internal sanity checks.  Buffer overflows triggerable from script are no joke though, so thanks for fixing this. :+1:",
      "5.2.10 has been released containing this fix.  The buffer overflow described in this pull was in fact exploitable: all it requires is to make the engine load a specially-crafted map which calls SetLayerSize in its entry script to trigger the buffer overrun.\r\n\r\nI do note that by default, the engine is heavily sandboxed: games can only load their own bundled assets (which are trusted by definition).  However, it *is* possible to enable a `relaxed` mode for the sandbox which allows loading anything on the file system using an absolute path.\r\n\r\nSo this is indeed a security flaw.  The fix will therefore be backported to 5.0 and 5.1 as well.",
      "@fatcerberus Thanks for releasing the fix! Would you mind me applying for a CVE ID for this vulnerability?",
      "Sure.  I admittedly donâ€™t know how that whole process works so if you want to do it thatâ€™s fine by me. :smiley:\r\n\r\nminiSphere 5.0.3, 5.1.5, and 5.2.10 all contain this fix.",
      "Great! Actually the CVE ID can be obtained by filing a request on https://iwantacve.org. It can be done by either bug finder or project maintainer, so yes I just did it myself. I have a habit of collecting CVEs, so that's why I want to get one for this bug.\r\n\r\nAnd thank you again for the version info! ðŸ‘ ",
      "[CVE-2018-1000524](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-1000524) was assigned to this issue."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}