{
  "cve_id": "CVE-2023-38406",
  "cwe_ids": [
    "CWE-755"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "FRRouting/frr",
  "commit_msg": "bgpd: Flowspec overflow issue\n\nAccording to the flowspec RFC 8955 a flowspec nlri is <length, <nlri data>>\nSpecifying 0 as a length makes BGP get all warm on the inside.  Which\nin this case is not a good thing at all.  Prevent warmth, stay cold\non the inside.\n\nReported-by: Iggy Frankovic <iggyfran@amazon.com>\nSigned-off-by: Donald Sharp <sharpd@nvidia.com>",
  "commit_hash": "0b999c886e241c52bd1f7ef0066700e4b618ebb3",
  "git_url": "https://github.com/FRRouting/frr/commit/0b999c886e241c52bd1f7ef0066700e4b618ebb3",
  "file_path": "bgpd/bgp_flowspec.c",
  "func_name": "bgp_nlri_parse_flowspec",
  "func_before": "int bgp_nlri_parse_flowspec(struct peer *peer, struct attr *attr,\n\t\t\t    struct bgp_nlri *packet, int withdraw)\n{\n\tuint8_t *pnt;\n\tuint8_t *lim;\n\tafi_t afi;\n\tsafi_t safi;\n\tint psize = 0;\n\tstruct prefix p;\n\tvoid *temp;\n\n\t/* Start processing the NLRI - there may be multiple in the MP_REACH */\n\tpnt = packet->nlri;\n\tlim = pnt + packet->length;\n\tafi = packet->afi;\n\tsafi = packet->safi;\n\n\tif (packet->length >= FLOWSPEC_NLRI_SIZELIMIT_EXTENDED) {\n\t\tflog_err(EC_BGP_FLOWSPEC_PACKET,\n\t\t\t \"BGP flowspec nlri length maximum reached (%u)\",\n\t\t\t packet->length);\n\t\treturn BGP_NLRI_PARSE_ERROR_FLOWSPEC_NLRI_SIZELIMIT;\n\t}\n\n\tfor (; pnt < lim; pnt += psize) {\n\t\t/* Clear prefix structure. */\n\t\tmemset(&p, 0, sizeof(p));\n\n\t\t/* All FlowSpec NLRI begin with length. */\n\t\tif (pnt + 1 > lim)\n\t\t\treturn BGP_NLRI_PARSE_ERROR_PACKET_OVERFLOW;\n\n\t\tpsize = *pnt++;\n\t\tif (psize >= FLOWSPEC_NLRI_SIZELIMIT) {\n\t\t\tpsize &= 0x0f;\n\t\t\tpsize = psize << 8;\n\t\t\tpsize |= *pnt++;\n\t\t}\n\t\t/* When packet overflow occur return immediately. */\n\t\tif (pnt + psize > lim) {\n\t\t\tflog_err(\n\t\t\t\tEC_BGP_FLOWSPEC_PACKET,\n\t\t\t\t\"Flowspec NLRI length inconsistent ( size %u seen)\",\n\t\t\t\tpsize);\n\t\t\treturn BGP_NLRI_PARSE_ERROR_PACKET_OVERFLOW;\n\t\t}\n\t\tif (bgp_fs_nlri_validate(pnt, psize, afi) < 0) {\n\t\t\tflog_err(\n\t\t\t\tEC_BGP_FLOWSPEC_PACKET,\n\t\t\t\t\"Bad flowspec format or NLRI options not supported\");\n\t\t\treturn BGP_NLRI_PARSE_ERROR_FLOWSPEC_BAD_FORMAT;\n\t\t}\n\t\tp.family = AF_FLOWSPEC;\n\t\tp.prefixlen = 0;\n\t\t/* Flowspec encoding is in bytes */\n\t\tp.u.prefix_flowspec.prefixlen = psize;\n\t\tp.u.prefix_flowspec.family = afi2family(afi);\n\t\ttemp = XCALLOC(MTYPE_TMP, psize);\n\t\tmemcpy(temp, pnt, psize);\n\t\tp.u.prefix_flowspec.ptr = (uintptr_t) temp;\n\n\t\tif (BGP_DEBUG(flowspec, FLOWSPEC)) {\n\t\t\tchar return_string[BGP_FLOWSPEC_NLRI_STRING_MAX];\n\t\t\tchar local_string[BGP_FLOWSPEC_NLRI_STRING_MAX*2+16];\n\t\t\tchar ec_string[BGP_FLOWSPEC_NLRI_STRING_MAX];\n\t\t\tchar *s = NULL;\n\n\t\t\tbgp_fs_nlri_get_string((unsigned char *)\n\t\t\t\t\t       p.u.prefix_flowspec.ptr,\n\t\t\t\t\t       p.u.prefix_flowspec.prefixlen,\n\t\t\t\t\t       return_string,\n\t\t\t\t\t       NLRI_STRING_FORMAT_MIN, NULL,\n\t\t\t\t\t       afi);\n\t\t\tsnprintf(ec_string, sizeof(ec_string),\n\t\t\t\t \"EC{none}\");\n\t\t\tif (attr && bgp_attr_get_ecommunity(attr)) {\n\t\t\t\ts = ecommunity_ecom2str(\n\t\t\t\t\tbgp_attr_get_ecommunity(attr),\n\t\t\t\t\tECOMMUNITY_FORMAT_ROUTE_MAP, 0);\n\t\t\t\tsnprintf(ec_string, sizeof(ec_string),\n\t\t\t\t\t \"EC{%s}\",\n\t\t\t\t\ts == NULL ? \"none\" : s);\n\n\t\t\t\tif (s)\n\t\t\t\t\tecommunity_strfree(&s);\n\t\t\t}\n\t\t\tsnprintf(local_string, sizeof(local_string),\n\t\t\t\t \"FS Rx %s %s %s %s\", withdraw ?\n\t\t\t\t \"Withdraw\":\"Update\",\n\t\t\t\t afi2str(afi), return_string,\n\t\t\t\t attr != NULL ? ec_string : \"\");\n\t\t\tzlog_info(\"%s\", local_string);\n\t\t}\n\t\t/* Process the route. */\n\t\tif (!withdraw)\n\t\t\tbgp_update(peer, &p, 0, attr, afi, safi,\n\t\t\t\t   ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL, NULL,\n\t\t\t\t   NULL, 0, 0, NULL);\n\t\telse\n\t\t\tbgp_withdraw(peer, &p, 0, afi, safi, ZEBRA_ROUTE_BGP,\n\t\t\t\t     BGP_ROUTE_NORMAL, NULL, NULL, 0, NULL);\n\t}\n\treturn BGP_NLRI_PARSE_OK;\n}",
  "abstract_func_before": "int bgp_nlri_parse_flowspec(struct peer *peer, struct attr *attr,\n\t\t\t    struct bgp_nlri *VAR_0, int VAR_1)\n{\n\tuint8_t *VAR_2;\n\tuint8_t *VAR_3;\n\tafi_t VAR_4;\n\tsafi_t VAR_5;\n\tint VAR_6 = 0;\n\tstruct prefix VAR_7;\n\tvoid *VAR_8;\n\n\t/* COMMENT_0 */\n\tVAR_2 = VAR_0->nlri;\n\tVAR_3 = VAR_2 + VAR_0->length;\n\tVAR_4 = VAR_0->afi;\n\tVAR_5 = VAR_0->safi;\n\n\tif (VAR_0->length >= VAR_9) {\n\t\tflog_err(VAR_10,\n\t\t\t \"BGP flowspec nlri length maximum reached (%u)\",\n\t\t\t VAR_0->length);\n\t\treturn VAR_11;\n\t}\n\n\tfor (; VAR_2 < VAR_3; VAR_2 += VAR_6) {\n\t\t/* COMMENT_1 */\n\t\tmemset(&VAR_7, 0, sizeof(VAR_7));\n\n\t\t/* COMMENT_2 */\n\t\tif (VAR_2 + 1 > VAR_3)\n\t\t\treturn VAR_12;\n\n\t\tVAR_6 = *VAR_2++;\n\t\tif (VAR_6 >= VAR_13) {\n\t\t\tVAR_6 &= 0x0f;\n\t\t\tVAR_6 = VAR_6 << 8;\n\t\t\tVAR_6 |= *VAR_2++;\n\t\t}\n\t\t/* COMMENT_3 */\n\t\tif (VAR_2 + VAR_6 > VAR_3) {\n\t\t\tflog_err(\n\t\t\t\tVAR_10,\n\t\t\t\t\"Flowspec NLRI length inconsistent ( size %u seen)\",\n\t\t\t\tVAR_6);\n\t\t\treturn VAR_12;\n\t\t}\n\t\tif (bgp_fs_nlri_validate(VAR_2, VAR_6, VAR_4) < 0) {\n\t\t\tflog_err(\n\t\t\t\tVAR_10,\n\t\t\t\t\"Bad flowspec format or NLRI options not supported\");\n\t\t\treturn VAR_14;\n\t\t}\n\t\tVAR_7.family = VAR_15;\n\t\tVAR_7.prefixlen = 0;\n\t\t/* COMMENT_4 */\n\t\tVAR_7.u.prefix_flowspec.prefixlen = VAR_6;\n\t\tVAR_7.u.prefix_flowspec.family = afi2family(VAR_4);\n\t\tVAR_8 = XCALLOC(VAR_16, VAR_6);\n\t\tmemcpy(VAR_8, VAR_2, VAR_6);\n\t\tVAR_7.u.prefix_flowspec.ptr = (uintptr_t) VAR_8;\n\n\t\tif (BGP_DEBUG(VAR_17, VAR_18)) {\n\t\t\tchar VAR_19[VAR_20];\n\t\t\tchar VAR_21[VAR_20*2+16];\n\t\t\tchar VAR_22[VAR_20];\n\t\t\tchar *VAR_23 = NULL;\n\n\t\t\tbgp_fs_nlri_get_string((unsigned char *)\n\t\t\t\t\t       VAR_7.u.prefix_flowspec.ptr,\n\t\t\t\t\t       VAR_7.u.prefix_flowspec.prefixlen,\n\t\t\t\t\t       VAR_19,\n\t\t\t\t\t       VAR_24, NULL,\n\t\t\t\t\t       VAR_4);\n\t\t\tsnprintf(VAR_22, sizeof(VAR_22),\n\t\t\t\t \"EC{none}\");\n\t\t\tif (attr && bgp_attr_get_ecommunity(attr)) {\n\t\t\t\tVAR_23 = ecommunity_ecom2str(\n\t\t\t\t\tbgp_attr_get_ecommunity(attr),\n\t\t\t\t\tVAR_25, 0);\n\t\t\t\tsnprintf(VAR_22, sizeof(VAR_22),\n\t\t\t\t\t \"EC{%s}\",\n\t\t\t\t\tVAR_23 == NULL ? \"none\" : VAR_23);\n\n\t\t\t\tif (VAR_23)\n\t\t\t\t\tecommunity_strfree(&VAR_23);\n\t\t\t}\n\t\t\tsnprintf(VAR_21, sizeof(VAR_21),\n\t\t\t\t \"FS Rx %s %s %s %s\", VAR_1 ?\n\t\t\t\t \"Withdraw\":\"Update\",\n\t\t\t\t afi2str(VAR_4), VAR_19,\n\t\t\t\t attr != NULL ? VAR_22 : \"\");\n\t\t\tzlog_info(\"%s\", VAR_21);\n\t\t}\n\t\t/* COMMENT_5 */\n\t\tif (!VAR_1)\n\t\t\tbgp_update(peer, &VAR_7, 0, attr, VAR_4, VAR_5,\n\t\t\t\t   VAR_26, VAR_27, NULL,\n\t\t\t\t   NULL, 0, 0, NULL);\n\t\telse\n\t\t\tbgp_withdraw(peer, &VAR_7, 0, VAR_4, VAR_5, VAR_26,\n\t\t\t\t     VAR_27, NULL, NULL, 0, NULL);\n\t}\n\treturn VAR_28;\n}",
  "func_graph_path_before": "FRRouting/frr/0b999c886e241c52bd1f7ef0066700e4b618ebb3/bgp_flowspec.c/vul/before/0.json",
  "func": "int bgp_nlri_parse_flowspec(struct peer *peer, struct attr *attr,\n\t\t\t    struct bgp_nlri *packet, int withdraw)\n{\n\tuint8_t *pnt;\n\tuint8_t *lim;\n\tafi_t afi;\n\tsafi_t safi;\n\tint psize = 0;\n\tstruct prefix p;\n\tvoid *temp;\n\n\t/* Start processing the NLRI - there may be multiple in the MP_REACH */\n\tpnt = packet->nlri;\n\tlim = pnt + packet->length;\n\tafi = packet->afi;\n\tsafi = packet->safi;\n\n\tif (packet->length >= FLOWSPEC_NLRI_SIZELIMIT_EXTENDED) {\n\t\tflog_err(EC_BGP_FLOWSPEC_PACKET,\n\t\t\t \"BGP flowspec nlri length maximum reached (%u)\",\n\t\t\t packet->length);\n\t\treturn BGP_NLRI_PARSE_ERROR_FLOWSPEC_NLRI_SIZELIMIT;\n\t}\n\n\tfor (; pnt < lim; pnt += psize) {\n\t\t/* Clear prefix structure. */\n\t\tmemset(&p, 0, sizeof(p));\n\n\t\t/* All FlowSpec NLRI begin with length. */\n\t\tif (pnt + 1 > lim)\n\t\t\treturn BGP_NLRI_PARSE_ERROR_PACKET_OVERFLOW;\n\n\t\tpsize = *pnt++;\n\t\tif (psize >= FLOWSPEC_NLRI_SIZELIMIT) {\n\t\t\tpsize &= 0x0f;\n\t\t\tpsize = psize << 8;\n\t\t\tpsize |= *pnt++;\n\t\t}\n\t\t/* When packet overflow occur return immediately. */\n\t\tif (pnt + psize > lim) {\n\t\t\tflog_err(\n\t\t\t\tEC_BGP_FLOWSPEC_PACKET,\n\t\t\t\t\"Flowspec NLRI length inconsistent ( size %u seen)\",\n\t\t\t\tpsize);\n\t\t\treturn BGP_NLRI_PARSE_ERROR_PACKET_OVERFLOW;\n\t\t}\n\n\t\tif (psize == 0) {\n\t\t\tflog_err(EC_BGP_FLOWSPEC_PACKET,\n\t\t\t\t \"Flowspec NLRI length 0 which makes no sense\");\n\t\t\treturn BGP_NLRI_PARSE_ERROR_PACKET_OVERFLOW;\n\t\t}\n\n\t\tif (bgp_fs_nlri_validate(pnt, psize, afi) < 0) {\n\t\t\tflog_err(\n\t\t\t\tEC_BGP_FLOWSPEC_PACKET,\n\t\t\t\t\"Bad flowspec format or NLRI options not supported\");\n\t\t\treturn BGP_NLRI_PARSE_ERROR_FLOWSPEC_BAD_FORMAT;\n\t\t}\n\t\tp.family = AF_FLOWSPEC;\n\t\tp.prefixlen = 0;\n\t\t/* Flowspec encoding is in bytes */\n\t\tp.u.prefix_flowspec.prefixlen = psize;\n\t\tp.u.prefix_flowspec.family = afi2family(afi);\n\t\ttemp = XCALLOC(MTYPE_TMP, psize);\n\t\tmemcpy(temp, pnt, psize);\n\t\tp.u.prefix_flowspec.ptr = (uintptr_t) temp;\n\n\t\tif (BGP_DEBUG(flowspec, FLOWSPEC)) {\n\t\t\tchar return_string[BGP_FLOWSPEC_NLRI_STRING_MAX];\n\t\t\tchar local_string[BGP_FLOWSPEC_NLRI_STRING_MAX*2+16];\n\t\t\tchar ec_string[BGP_FLOWSPEC_NLRI_STRING_MAX];\n\t\t\tchar *s = NULL;\n\n\t\t\tbgp_fs_nlri_get_string((unsigned char *)\n\t\t\t\t\t       p.u.prefix_flowspec.ptr,\n\t\t\t\t\t       p.u.prefix_flowspec.prefixlen,\n\t\t\t\t\t       return_string,\n\t\t\t\t\t       NLRI_STRING_FORMAT_MIN, NULL,\n\t\t\t\t\t       afi);\n\t\t\tsnprintf(ec_string, sizeof(ec_string),\n\t\t\t\t \"EC{none}\");\n\t\t\tif (attr && bgp_attr_get_ecommunity(attr)) {\n\t\t\t\ts = ecommunity_ecom2str(\n\t\t\t\t\tbgp_attr_get_ecommunity(attr),\n\t\t\t\t\tECOMMUNITY_FORMAT_ROUTE_MAP, 0);\n\t\t\t\tsnprintf(ec_string, sizeof(ec_string),\n\t\t\t\t\t \"EC{%s}\",\n\t\t\t\t\ts == NULL ? \"none\" : s);\n\n\t\t\t\tif (s)\n\t\t\t\t\tecommunity_strfree(&s);\n\t\t\t}\n\t\t\tsnprintf(local_string, sizeof(local_string),\n\t\t\t\t \"FS Rx %s %s %s %s\", withdraw ?\n\t\t\t\t \"Withdraw\":\"Update\",\n\t\t\t\t afi2str(afi), return_string,\n\t\t\t\t attr != NULL ? ec_string : \"\");\n\t\t\tzlog_info(\"%s\", local_string);\n\t\t}\n\t\t/* Process the route. */\n\t\tif (!withdraw)\n\t\t\tbgp_update(peer, &p, 0, attr, afi, safi,\n\t\t\t\t   ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL, NULL,\n\t\t\t\t   NULL, 0, 0, NULL);\n\t\telse\n\t\t\tbgp_withdraw(peer, &p, 0, afi, safi, ZEBRA_ROUTE_BGP,\n\t\t\t\t     BGP_ROUTE_NORMAL, NULL, NULL, 0, NULL);\n\t}\n\treturn BGP_NLRI_PARSE_OK;\n}",
  "abstract_func": "int bgp_nlri_parse_flowspec(struct peer *peer, struct attr *attr,\n\t\t\t    struct bgp_nlri *VAR_0, int VAR_1)\n{\n\tuint8_t *VAR_2;\n\tuint8_t *VAR_3;\n\tafi_t VAR_4;\n\tsafi_t VAR_5;\n\tint VAR_6 = 0;\n\tstruct prefix VAR_7;\n\tvoid *VAR_8;\n\n\t/* COMMENT_0 */\n\tVAR_2 = VAR_0->nlri;\n\tVAR_3 = VAR_2 + VAR_0->length;\n\tVAR_4 = VAR_0->afi;\n\tVAR_5 = VAR_0->safi;\n\n\tif (VAR_0->length >= VAR_9) {\n\t\tflog_err(VAR_10,\n\t\t\t \"BGP flowspec nlri length maximum reached (%u)\",\n\t\t\t VAR_0->length);\n\t\treturn VAR_11;\n\t}\n\n\tfor (; VAR_2 < VAR_3; VAR_2 += VAR_6) {\n\t\t/* COMMENT_1 */\n\t\tmemset(&VAR_7, 0, sizeof(VAR_7));\n\n\t\t/* COMMENT_2 */\n\t\tif (VAR_2 + 1 > VAR_3)\n\t\t\treturn VAR_12;\n\n\t\tVAR_6 = *VAR_2++;\n\t\tif (VAR_6 >= VAR_13) {\n\t\t\tVAR_6 &= 0x0f;\n\t\t\tVAR_6 = VAR_6 << 8;\n\t\t\tVAR_6 |= *VAR_2++;\n\t\t}\n\t\t/* COMMENT_3 */\n\t\tif (VAR_2 + VAR_6 > VAR_3) {\n\t\t\tflog_err(\n\t\t\t\tVAR_10,\n\t\t\t\t\"Flowspec NLRI length inconsistent ( size %u seen)\",\n\t\t\t\tVAR_6);\n\t\t\treturn VAR_12;\n\t\t}\n\n\t\tif (VAR_6 == 0) {\n\t\t\tflog_err(VAR_10,\n\t\t\t\t \"Flowspec NLRI length 0 which makes no sense\");\n\t\t\treturn VAR_12;\n\t\t}\n\n\t\tif (bgp_fs_nlri_validate(VAR_2, VAR_6, VAR_4) < 0) {\n\t\t\tflog_err(\n\t\t\t\tVAR_10,\n\t\t\t\t\"Bad flowspec format or NLRI options not supported\");\n\t\t\treturn VAR_14;\n\t\t}\n\t\tVAR_7.family = VAR_15;\n\t\tVAR_7.prefixlen = 0;\n\t\t/* COMMENT_4 */\n\t\tVAR_7.u.prefix_flowspec.prefixlen = VAR_6;\n\t\tVAR_7.u.prefix_flowspec.family = afi2family(VAR_4);\n\t\tVAR_8 = XCALLOC(VAR_16, VAR_6);\n\t\tmemcpy(VAR_8, VAR_2, VAR_6);\n\t\tVAR_7.u.prefix_flowspec.ptr = (uintptr_t) VAR_8;\n\n\t\tif (BGP_DEBUG(VAR_17, VAR_18)) {\n\t\t\tchar VAR_19[VAR_20];\n\t\t\tchar VAR_21[VAR_20*2+16];\n\t\t\tchar VAR_22[VAR_20];\n\t\t\tchar *VAR_23 = NULL;\n\n\t\t\tbgp_fs_nlri_get_string((unsigned char *)\n\t\t\t\t\t       VAR_7.u.prefix_flowspec.ptr,\n\t\t\t\t\t       VAR_7.u.prefix_flowspec.prefixlen,\n\t\t\t\t\t       VAR_19,\n\t\t\t\t\t       VAR_24, NULL,\n\t\t\t\t\t       VAR_4);\n\t\t\tsnprintf(VAR_22, sizeof(VAR_22),\n\t\t\t\t \"EC{none}\");\n\t\t\tif (attr && bgp_attr_get_ecommunity(attr)) {\n\t\t\t\tVAR_23 = ecommunity_ecom2str(\n\t\t\t\t\tbgp_attr_get_ecommunity(attr),\n\t\t\t\t\tVAR_25, 0);\n\t\t\t\tsnprintf(VAR_22, sizeof(VAR_22),\n\t\t\t\t\t \"EC{%s}\",\n\t\t\t\t\tVAR_23 == NULL ? \"none\" : VAR_23);\n\n\t\t\t\tif (VAR_23)\n\t\t\t\t\tecommunity_strfree(&VAR_23);\n\t\t\t}\n\t\t\tsnprintf(VAR_21, sizeof(VAR_21),\n\t\t\t\t \"FS Rx %s %s %s %s\", VAR_1 ?\n\t\t\t\t \"Withdraw\":\"Update\",\n\t\t\t\t afi2str(VAR_4), VAR_19,\n\t\t\t\t attr != NULL ? VAR_22 : \"\");\n\t\t\tzlog_info(\"%s\", VAR_21);\n\t\t}\n\t\t/* COMMENT_5 */\n\t\tif (!VAR_1)\n\t\t\tbgp_update(peer, &VAR_7, 0, attr, VAR_4, VAR_5,\n\t\t\t\t   VAR_26, VAR_27, NULL,\n\t\t\t\t   NULL, 0, 0, NULL);\n\t\telse\n\t\t\tbgp_withdraw(peer, &VAR_7, 0, VAR_4, VAR_5, VAR_26,\n\t\t\t\t     VAR_27, NULL, NULL, 0, NULL);\n\t}\n\treturn VAR_28;\n}",
  "func_graph_path": "FRRouting/frr/0b999c886e241c52bd1f7ef0066700e4b618ebb3/bgp_flowspec.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -44,6 +44,13 @@\n \t\t\t\tpsize);\n \t\t\treturn BGP_NLRI_PARSE_ERROR_PACKET_OVERFLOW;\n \t\t}\n+\n+\t\tif (psize == 0) {\n+\t\t\tflog_err(EC_BGP_FLOWSPEC_PACKET,\n+\t\t\t\t \"Flowspec NLRI length 0 which makes no sense\");\n+\t\t\treturn BGP_NLRI_PARSE_ERROR_PACKET_OVERFLOW;\n+\t\t}\n+\n \t\tif (bgp_fs_nlri_validate(pnt, psize, afi) < 0) {\n \t\t\tflog_err(\n \t\t\t\tEC_BGP_FLOWSPEC_PACKET,",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "",
      "\t\tif (psize == 0) {",
      "\t\t\tflog_err(EC_BGP_FLOWSPEC_PACKET,",
      "\t\t\t\t \"Flowspec NLRI length 0 which makes no sense\");",
      "\t\t\treturn BGP_NLRI_PARSE_ERROR_PACKET_OVERFLOW;",
      "\t\t}",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/FRRouting/frr/pull/12884",
  "description": {
    "pr_info": {
      "title": "bgpd: Flowspec overflow issue",
      "number": 12884
    },
    "comment": [
      "According to the flowspec RFC 8955 a flowspec nlri is <length, <nlri data>> Specifying 0 as a length makes BGP get all warm on the inside.  Which in this case is not a good thing at all.  Prevent warmth, stay cold on the inside.\r\n\r\nReported-by: Iggy Frankovic <iggyfran@amazon.com>",
      "@mergifyio backport dev/8.5 stable/8.4 stable/8.3 stable/8.2 stable/8.1",
      "> backport dev/8.5 stable/8.4 stable/8.3 stable/8.2 stable/8.1\n\n#### âœ… Backports have been created\n\n<details>\n\n* [#12891 bgpd: Flowspec overflow issue (backport #12884)](https://github.com/FRRouting/frr/pull/12891) has been created for branch `dev/8.5`\n* [#12892 bgpd: Flowspec overflow issue (backport #12884)](https://github.com/FRRouting/frr/pull/12892) has been created for branch `stable/8.4`\n* [#12893 bgpd: Flowspec overflow issue (backport #12884)](https://github.com/FRRouting/frr/pull/12893) has been created for branch `stable/8.3`\n* [#12894 bgpd: Flowspec overflow issue (backport #12884)](https://github.com/FRRouting/frr/pull/12894) has been created for branch `stable/8.2`\n* [#12895 bgpd: Flowspec overflow issue (backport #12884)](https://github.com/FRRouting/frr/pull/12895) has been created for branch `stable/8.1`\n\n</details>\n\n\n<!---\nDO NOT EDIT\n-*- Mergify Payload -*-\n{\"command\": \"backport dev/8.5 stable/8.4 stable/8.3 stable/8.2 stable/8.1\", \"conclusion\": \"success\"}\n-*- Mergify Payload End -*-\n-->",
      "# Continuous Integration Result: SUCCESSFUL\n\nCongratulations, this patch passed basic tests\n\nTested-by: NetDEF / OpenSourceRouting.org CI System\n\nCI System Testrun URL: https://ci1.netdef.org/browse/FRR-PULLREQ2-9871/\n\nThis is a comment from an automated CI system.\nFor questions and feedback in regards to this CI system, please feel free to email\nMartin Winter - mwinter (at) opensourcerouting.org.\n\n\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95"
}