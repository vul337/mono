{
  "cve_id": "CVE-2018-7262",
  "cwe_ids": [
    "CWE-476"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "ceph",
  "commit_msg": "rgw:  make init env methods return an error\n\nSince web frontends may signal an error when requests are malformed or so, let\nus double check this and raise errors early. The current user of this is\ncivetweb frontend; which can potentially return null from `parse_http_headers`\nwhen a HTTP header without a \":\" is supplied at which point headers.value is\nnull which can lead to undefined behaviour later in RGW.\n\nFixes: http://tracker.ceph.com/issues/23039\nSigned-off-by: Abhishek Lekshmanan <abhishek@suse.com>",
  "commit_hash": "7872a831783e17dcc4d0aa70cffc256afb664f7a",
  "git_url": "https://github.com/ceph/ceph/commit/7872a831783e17dcc4d0aa70cffc256afb664f7a",
  "file_path": "src/rgw/rgw_process.cc",
  "func_name": "process_request",
  "func_before": "int process_request(RGWRados* const store,\n                    RGWREST* const rest,\n                    RGWRequest* const req,\n                    const std::string& frontend_prefix,\n                    const rgw_auth_registry_t& auth_registry,\n                    RGWRestfulIO* const client_io,\n                    OpsLogSocket* const olog,\n                    int* http_ret)\n{\n  int ret = 0;\n\n  client_io->init(g_ceph_context);\n\n  req->log_init();\n\n  dout(1) << \"====== starting new request req=\" << hex << req << dec\n\t  << \" =====\" << dendl;\n  perfcounter->inc(l_rgw_req);\n\n  RGWEnv& rgw_env = client_io->get_env();\n\n  RGWUserInfo userinfo;\n\n  struct req_state rstate(g_ceph_context, &rgw_env, &userinfo);\n  struct req_state *s = &rstate;\n\n  RGWObjectCtx rados_ctx(store, s);\n  s->obj_ctx = &rados_ctx;\n\n  s->req_id = store->unique_id(req->id);\n  s->trans_id = store->unique_trans_id(req->id);\n  s->host_id = store->host_id;\n\n  req->log_format(s, \"initializing for trans_id = %s\", s->trans_id.c_str());\n\n  RGWOp* op = NULL;\n  int init_error = 0;\n  bool should_log = false;\n  RGWRESTMgr *mgr;\n  RGWHandler_REST *handler = rest->get_handler(store, s,\n                                               auth_registry,\n                                               frontend_prefix,\n                                               client_io, &mgr, &init_error);\n  if (init_error != 0) {\n    abort_early(s, NULL, init_error, NULL);\n    goto done;\n  }\n  dout(10) << \"handler=\" << typeid(*handler).name() << dendl;\n\n  should_log = mgr->get_logging();\n\n  req->log_format(s, \"getting op %d\", s->op);\n  op = handler->get_op(store);\n  if (!op) {\n    abort_early(s, NULL, -ERR_METHOD_NOT_ALLOWED, handler);\n    goto done;\n  }\n\n  req->op = op;\n  dout(10) << \"op=\" << typeid(*op).name() << dendl;\n\n  s->op_type = op->get_type();\n\n  req->log(s, \"verifying requester\");\n  ret = op->verify_requester(auth_registry);\n  if (ret < 0) {\n    dout(10) << \"failed to authorize request\" << dendl;\n    abort_early(s, NULL, ret, handler);\n    goto done;\n  }\n\n  /* FIXME: remove this after switching all handlers to the new authentication\n   * infrastructure. */\n  if (nullptr == s->auth.identity) {\n    s->auth.identity = rgw::auth::transform_old_authinfo(s);\n  }\n\n  req->log(s, \"normalizing buckets and tenants\");\n  ret = handler->postauth_init();\n  if (ret < 0) {\n    dout(10) << \"failed to run post-auth init\" << dendl;\n    abort_early(s, op, ret, handler);\n    goto done;\n  }\n\n  if (s->user->suspended) {\n    dout(10) << \"user is suspended, uid=\" << s->user->user_id << dendl;\n    abort_early(s, op, -ERR_USER_SUSPENDED, handler);\n    goto done;\n  }\n\n  ret = rgw_process_authenticated(handler, op, req, s);\n  if (ret < 0) {\n    abort_early(s, op, ret, handler);\n    goto done;\n  }\ndone:\n  try {\n    client_io->complete_request();\n  } catch (rgw::io::Exception& e) {\n    dout(0) << \"ERROR: client_io->complete_request() returned \"\n            << e.what() << dendl;\n  }\n\n  if (should_log) {\n    rgw_log_op(store, rest, s, (op ? op->name() : \"unknown\"), olog);\n  }\n\n  if (http_ret != nullptr) {\n    *http_ret = s->err.http_ret;\n  }\n  int op_ret = 0;\n  if (op) {\n    op_ret = op->get_ret();\n  }\n\n  req->log_format(s, \"op status=%d\", op_ret);\n  req->log_format(s, \"http status=%d\", s->err.http_ret);\n\n  if (handler)\n    handler->put_op(op);\n  rest->put_handler(handler);\n\n  dout(1) << \"====== req done req=\" << hex << req << dec\n\t  << \" op status=\" << op_ret\n\t  << \" http_status=\" << s->err.http_ret\n\t  << \" ======\"\n\t  << dendl;\n\n  return (ret < 0 ? ret : s->err.ret);\n}",
  "abstract_func_before": "int process_request(RGWRados* const VAR_0,\n                    RGWREST* const VAR_1,\n                    RGWRequest* const VAR_2,\n                    const std::string& VAR_3,\n                    const rgw_auth_registry_t& VAR_4,\n                    RGWRestfulIO* const VAR_5,\n                    OpsLogSocket* const VAR_6,\n                    int* VAR_7)\n{\n  int VAR_8 = 0;\n\n  VAR_5->init(VAR_9);\n\n  VAR_2->log_init();\n\n  dout(1) << \"====== starting new request req=\" << VAR_10 << VAR_2 << VAR_11\n\t  << \" =====\" << VAR_12;\n  VAR_13->inc(VAR_14);\n\n  RGWEnv& VAR_15 = VAR_5->get_env();\n\n  RGWUserInfo VAR_16;\n\n  struct req_state VAR_17(VAR_9, &VAR_15, &VAR_16);\n  struct req_state *VAR_18 = &VAR_17;\n\n  RGWObjectCtx rados_ctx(store, s);\n  s->obj_ctx = &VAR_19;\n\n  s->req_id = store->unique_id(VAR_2->id);\n  s->trans_id = store->unique_trans_id(VAR_2->id);\n  s->host_id = store->host_id;\n\n  VAR_2->log_format(s, \"initializing for trans_id = %s\", s->trans_id.c_str());\n\n  RGWOp* VAR_20 = NULL;\n  int VAR_21 = 0;\n  bool VAR_22 = false;\n  RGWRESTMgr *VAR_23;\n  RGWHandler_REST *VAR_24 = VAR_1->get_handler(store, s,\n                                               VAR_4,\n                                               VAR_3,\n                                               VAR_5, &VAR_23, &VAR_21);\n  if (VAR_21 != 0) {\n    abort_early(s, NULL, VAR_21, NULL);\n    goto done;\n  }\n  dout(10) << \"handler=\" << typeid(*VAR_24).name() << VAR_12;\n\n  VAR_22 = VAR_23->get_logging();\n\n  VAR_2->log_format(s, \"getting op %d\", s->op);\n  VAR_20 = VAR_24->get_op(store);\n  if (!VAR_20) {\n    abort_early(s, NULL, -VAR_25, VAR_24);\n    goto done;\n  }\n\n  VAR_2->op = VAR_20;\n  dout(10) << \"op=\" << typeid(*VAR_20).name() << VAR_12;\n\n  s->op_type = VAR_20->get_type();\n\n  VAR_2->log(s, \"verifying requester\");\n  VAR_8 = VAR_20->verify_requester(VAR_4);\n  if (VAR_8 < 0) {\n    dout(10) << \"failed to authorize request\" << VAR_12;\n    abort_early(s, NULL, VAR_8, VAR_24);\n    goto done;\n  }\n\n  /* COMMENT_0 */\n                       \n  if (nullptr == s->auth.identity) {\n    s->auth.identity = rgw::auth::transform_old_authinfo(s);\n  }\n\n  VAR_2->log(s, \"normalizing buckets and tenants\");\n  VAR_8 = VAR_24->postauth_init();\n  if (VAR_8 < 0) {\n    dout(10) << \"failed to run post-auth init\" << VAR_12;\n    abort_early(s, VAR_20, VAR_8, VAR_24);\n    goto done;\n  }\n\n  if (s->user->suspended) {\n    dout(10) << \"user is suspended, uid=\" << s->user->user_id << VAR_12;\n    abort_early(s, VAR_20, -VAR_26, VAR_24);\n    goto done;\n  }\n\n  VAR_8 = rgw_process_authenticated(VAR_24, VAR_20, VAR_2, s);\n  if (VAR_8 < 0) {\n    abort_early(s, VAR_20, VAR_8, VAR_24);\n    goto done;\n  }\ndone:\n  try {\n    VAR_5->complete_request();\n  } catch (rgw::io::Exception& VAR_27) {\n    dout(0) << \"ERROR: client_io->complete_request() returned \"\n            << VAR_27.what() << VAR_12;\n  }\n\n  if (VAR_22) {\n    rgw_log_op(store, VAR_1, s, (VAR_20 ? VAR_20->name() : \"unknown\"), VAR_6);\n  }\n\n  if (VAR_7 != nullptr) {\n    *VAR_7 = s->err.http_ret;\n  }\n  int VAR_28 = 0;\n  if (VAR_20) {\n    VAR_28 = VAR_20->get_ret();\n  }\n\n  VAR_2->log_format(s, \"op status=%d\", VAR_28);\n  VAR_2->log_format(s, \"http status=%d\", s->err.http_ret);\n\n  if (VAR_24)\n    VAR_24->put_op(VAR_20);\n  VAR_1->put_handler(VAR_24);\n\n  dout(1) << \"====== req done req=\" << VAR_10 << VAR_2 << VAR_11\n\t  << \" op status=\" << VAR_28\n\t  << \" http_status=\" << s->err.http_ret\n\t  << \" ======\"\n\t  << VAR_12;\n\n  return (VAR_8 < 0 ? VAR_8 : s->err.ret);\n}",
  "func_graph_path_before": "ceph/7872a831783e17dcc4d0aa70cffc256afb664f7a/rgw_process.cc/vul/before/0.json",
  "func": "int process_request(RGWRados* const store,\n                    RGWREST* const rest,\n                    RGWRequest* const req,\n                    const std::string& frontend_prefix,\n                    const rgw_auth_registry_t& auth_registry,\n                    RGWRestfulIO* const client_io,\n                    OpsLogSocket* const olog,\n                    int* http_ret)\n{\n  int ret = client_io->init(g_ceph_context);\n\n  req->log_init();\n\n  dout(1) << \"====== starting new request req=\" << hex << req << dec\n\t  << \" =====\" << dendl;\n  perfcounter->inc(l_rgw_req);\n\n  RGWEnv& rgw_env = client_io->get_env();\n\n  RGWUserInfo userinfo;\n\n  struct req_state rstate(g_ceph_context, &rgw_env, &userinfo);\n  struct req_state *s = &rstate;\n\n  RGWObjectCtx rados_ctx(store, s);\n  s->obj_ctx = &rados_ctx;\n\n  if (ret < 0) {\n    s->cio = client_io;\n    abort_early(s, nullptr, ret, nullptr);\n    return ret;\n  }\n\n  s->req_id = store->unique_id(req->id);\n  s->trans_id = store->unique_trans_id(req->id);\n  s->host_id = store->host_id;\n\n  req->log_format(s, \"initializing for trans_id = %s\", s->trans_id.c_str());\n\n  RGWOp* op = nullptr;\n  int init_error = 0;\n  bool should_log = false;\n  RGWRESTMgr *mgr;\n  RGWHandler_REST *handler = rest->get_handler(store, s,\n                                               auth_registry,\n                                               frontend_prefix,\n                                               client_io, &mgr, &init_error);\n  if (init_error != 0) {\n    abort_early(s, nullptr, init_error, nullptr);\n    goto done;\n  }\n  dout(10) << \"handler=\" << typeid(*handler).name() << dendl;\n\n  should_log = mgr->get_logging();\n\n  req->log_format(s, \"getting op %d\", s->op);\n  op = handler->get_op(store);\n  if (!op) {\n    abort_early(s, NULL, -ERR_METHOD_NOT_ALLOWED, handler);\n    goto done;\n  }\n\n  req->op = op;\n  dout(10) << \"op=\" << typeid(*op).name() << dendl;\n\n  s->op_type = op->get_type();\n\n  req->log(s, \"verifying requester\");\n  ret = op->verify_requester(auth_registry);\n  if (ret < 0) {\n    dout(10) << \"failed to authorize request\" << dendl;\n    abort_early(s, NULL, ret, handler);\n    goto done;\n  }\n\n  /* FIXME: remove this after switching all handlers to the new authentication\n   * infrastructure. */\n  if (nullptr == s->auth.identity) {\n    s->auth.identity = rgw::auth::transform_old_authinfo(s);\n  }\n\n  req->log(s, \"normalizing buckets and tenants\");\n  ret = handler->postauth_init();\n  if (ret < 0) {\n    dout(10) << \"failed to run post-auth init\" << dendl;\n    abort_early(s, op, ret, handler);\n    goto done;\n  }\n\n  if (s->user->suspended) {\n    dout(10) << \"user is suspended, uid=\" << s->user->user_id << dendl;\n    abort_early(s, op, -ERR_USER_SUSPENDED, handler);\n    goto done;\n  }\n\n  ret = rgw_process_authenticated(handler, op, req, s);\n  if (ret < 0) {\n    abort_early(s, op, ret, handler);\n    goto done;\n  }\ndone:\n  try {\n    client_io->complete_request();\n  } catch (rgw::io::Exception& e) {\n    dout(0) << \"ERROR: client_io->complete_request() returned \"\n            << e.what() << dendl;\n  }\n\n  if (should_log) {\n    rgw_log_op(store, rest, s, (op ? op->name() : \"unknown\"), olog);\n  }\n\n  if (http_ret != nullptr) {\n    *http_ret = s->err.http_ret;\n  }\n  int op_ret = 0;\n  if (op) {\n    op_ret = op->get_ret();\n  }\n\n  req->log_format(s, \"op status=%d\", op_ret);\n  req->log_format(s, \"http status=%d\", s->err.http_ret);\n\n  if (handler)\n    handler->put_op(op);\n  rest->put_handler(handler);\n\n  dout(1) << \"====== req done req=\" << hex << req << dec\n\t  << \" op status=\" << op_ret\n\t  << \" http_status=\" << s->err.http_ret\n\t  << \" ======\"\n\t  << dendl;\n\n  return (ret < 0 ? ret : s->err.ret);\n}",
  "abstract_func": "int process_request(RGWRados* const VAR_0,\n                    RGWREST* const VAR_1,\n                    RGWRequest* const VAR_2,\n                    const std::string& VAR_3,\n                    const rgw_auth_registry_t& VAR_4,\n                    RGWRestfulIO* const VAR_5,\n                    OpsLogSocket* const VAR_6,\n                    int* VAR_7)\n{\n  int VAR_8 = VAR_5->init(VAR_9);\n\n  VAR_2->log_init();\n\n  dout(1) << \"====== starting new request req=\" << VAR_10 << VAR_2 << VAR_11\n\t  << \" =====\" << VAR_12;\n  VAR_13->inc(VAR_14);\n\n  RGWEnv& VAR_15 = VAR_5->get_env();\n\n  RGWUserInfo VAR_16;\n\n  struct req_state VAR_17(VAR_9, &VAR_15, &VAR_16);\n  struct req_state *VAR_18 = &VAR_17;\n\n  RGWObjectCtx rados_ctx(store, s);\n  s->obj_ctx = &VAR_19;\n\n  if (VAR_8 < 0) {\n    s->cio = VAR_5;\n    abort_early(s, nullptr, VAR_8, nullptr);\n    return VAR_8;\n  }\n\n  s->req_id = store->unique_id(VAR_2->id);\n  s->trans_id = store->unique_trans_id(VAR_2->id);\n  s->host_id = store->host_id;\n\n  VAR_2->log_format(s, \"initializing for trans_id = %s\", s->trans_id.c_str());\n\n  RGWOp* VAR_20 = nullptr;\n  int VAR_21 = 0;\n  bool VAR_22 = false;\n  RGWRESTMgr *VAR_23;\n  RGWHandler_REST *VAR_24 = VAR_1->get_handler(store, s,\n                                               VAR_4,\n                                               VAR_3,\n                                               VAR_5, &VAR_23, &VAR_21);\n  if (VAR_21 != 0) {\n    abort_early(s, nullptr, VAR_21, nullptr);\n    goto done;\n  }\n  dout(10) << \"handler=\" << typeid(*VAR_24).name() << VAR_12;\n\n  VAR_22 = VAR_23->get_logging();\n\n  VAR_2->log_format(s, \"getting op %d\", s->op);\n  VAR_20 = VAR_24->get_op(store);\n  if (!VAR_20) {\n    abort_early(s, NULL, -VAR_25, VAR_24);\n    goto done;\n  }\n\n  VAR_2->op = VAR_20;\n  dout(10) << \"op=\" << typeid(*VAR_20).name() << VAR_12;\n\n  s->op_type = VAR_20->get_type();\n\n  VAR_2->log(s, \"verifying requester\");\n  VAR_8 = VAR_20->verify_requester(VAR_4);\n  if (VAR_8 < 0) {\n    dout(10) << \"failed to authorize request\" << VAR_12;\n    abort_early(s, NULL, VAR_8, VAR_24);\n    goto done;\n  }\n\n  /* COMMENT_0 */\n                       \n  if (nullptr == s->auth.identity) {\n    s->auth.identity = rgw::auth::transform_old_authinfo(s);\n  }\n\n  VAR_2->log(s, \"normalizing buckets and tenants\");\n  VAR_8 = VAR_24->postauth_init();\n  if (VAR_8 < 0) {\n    dout(10) << \"failed to run post-auth init\" << VAR_12;\n    abort_early(s, VAR_20, VAR_8, VAR_24);\n    goto done;\n  }\n\n  if (s->user->suspended) {\n    dout(10) << \"user is suspended, uid=\" << s->user->user_id << VAR_12;\n    abort_early(s, VAR_20, -VAR_26, VAR_24);\n    goto done;\n  }\n\n  VAR_8 = rgw_process_authenticated(VAR_24, VAR_20, VAR_2, s);\n  if (VAR_8 < 0) {\n    abort_early(s, VAR_20, VAR_8, VAR_24);\n    goto done;\n  }\ndone:\n  try {\n    VAR_5->complete_request();\n  } catch (rgw::io::Exception& VAR_27) {\n    dout(0) << \"ERROR: client_io->complete_request() returned \"\n            << VAR_27.what() << VAR_12;\n  }\n\n  if (VAR_22) {\n    rgw_log_op(store, VAR_1, s, (VAR_20 ? VAR_20->name() : \"unknown\"), VAR_6);\n  }\n\n  if (VAR_7 != nullptr) {\n    *VAR_7 = s->err.http_ret;\n  }\n  int VAR_28 = 0;\n  if (VAR_20) {\n    VAR_28 = VAR_20->get_ret();\n  }\n\n  VAR_2->log_format(s, \"op status=%d\", VAR_28);\n  VAR_2->log_format(s, \"http status=%d\", s->err.http_ret);\n\n  if (VAR_24)\n    VAR_24->put_op(VAR_20);\n  VAR_1->put_handler(VAR_24);\n\n  dout(1) << \"====== req done req=\" << VAR_10 << VAR_2 << VAR_11\n\t  << \" op status=\" << VAR_28\n\t  << \" http_status=\" << s->err.http_ret\n\t  << \" ======\"\n\t  << VAR_12;\n\n  return (VAR_8 < 0 ? VAR_8 : s->err.ret);\n}",
  "func_graph_path": "ceph/7872a831783e17dcc4d0aa70cffc256afb664f7a/rgw_process.cc/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -7,9 +7,7 @@\n                     OpsLogSocket* const olog,\n                     int* http_ret)\n {\n-  int ret = 0;\n-\n-  client_io->init(g_ceph_context);\n+  int ret = client_io->init(g_ceph_context);\n \n   req->log_init();\n \n@@ -27,13 +25,19 @@\n   RGWObjectCtx rados_ctx(store, s);\n   s->obj_ctx = &rados_ctx;\n \n+  if (ret < 0) {\n+    s->cio = client_io;\n+    abort_early(s, nullptr, ret, nullptr);\n+    return ret;\n+  }\n+\n   s->req_id = store->unique_id(req->id);\n   s->trans_id = store->unique_trans_id(req->id);\n   s->host_id = store->host_id;\n \n   req->log_format(s, \"initializing for trans_id = %s\", s->trans_id.c_str());\n \n-  RGWOp* op = NULL;\n+  RGWOp* op = nullptr;\n   int init_error = 0;\n   bool should_log = false;\n   RGWRESTMgr *mgr;\n@@ -42,7 +46,7 @@\n                                                frontend_prefix,\n                                                client_io, &mgr, &init_error);\n   if (init_error != 0) {\n-    abort_early(s, NULL, init_error, NULL);\n+    abort_early(s, nullptr, init_error, nullptr);\n     goto done;\n   }\n   dout(10) << \"handler=\" << typeid(*handler).name() << dendl;",
  "diff_line_info": {
    "deleted_lines": [
      "  int ret = 0;",
      "",
      "  client_io->init(g_ceph_context);",
      "  RGWOp* op = NULL;",
      "    abort_early(s, NULL, init_error, NULL);"
    ],
    "added_lines": [
      "  int ret = client_io->init(g_ceph_context);",
      "  if (ret < 0) {",
      "    s->cio = client_io;",
      "    abort_early(s, nullptr, ret, nullptr);",
      "    return ret;",
      "  }",
      "",
      "  RGWOp* op = nullptr;",
      "    abort_early(s, nullptr, init_error, nullptr);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/ceph/ceph/pull/20488",
  "description": {
    "pr_info": {
      "title": "rgw:  make init env methods return an error",
      "number": 20488
    },
    "comment": [
      "Since web frontends may signal an error when requests are malformed or so, let\r\nus double check this and raise errors early. The current user of this is\r\ncivetweb frontend; which can potentially return null from `parse_http_headers`\r\nwhen a HTTP header without a \":\" is supplied at which point headers.value is\r\nnull which can lead to undefined behaviour later in RGW.\r\n\r\nFixes: http://tracker.ceph.com/issues/23039\r\nSigned-off-by: Abhishek Lekshmanan <abhishek@suse.com>",
      "changelog: \r\n- drop init_error variable in rgw_civetweb\r\n- raise -EINVAL if mg_request info isn't populated in rgw_civetweb.cc\r\n   this is a changed behaviour  from earlier where we return and fail at a much later stage in rgw process \r\n",
      "@yehudasa @cbodley do these changes look okay?",
      "was unable to reproduce the failures in manual testing :+1: "
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9\n\nThe patch addresses a situation where malformed HTTP headers could lead to undefined behavior, which is a security concern. The code changes include error handling to prevent such issues, consistent with the commit message and vulnerability description."
}