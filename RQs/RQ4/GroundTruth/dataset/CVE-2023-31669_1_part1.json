{
  "cve_id": "CVE-2023-31669",
  "cwe_ids": [
    "CWE-116"
  ],
  "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "WebAssembly/wabt",
  "commit_msg": "Improve lexing and parsing of invalid annotations (again)\n\nThis adds a bounds-check to WastLexer::GetText to handle the case when\nthe offset is earlier than token_start (e.g. because GetStringToken\nfound a newline in the string and reset token_start to point at it).\n\nAlso revises GetIdToken -> GetIdChars to stop skipping the initial char\nin an annotation delimiter, which is an idchar+ but not an id token.\n\nAlso fixes the WastParser to handle EOF when reading for the end of an\nannotation, both for code metadata annotations and other kinds.\nPreviously this produced an infinite loop (but only with\n--enable-annotations).\n\nFixes #2165",
  "commit_hash": "44491a4b0fdb2d2bd87a151fd169da3343954edd",
  "git_url": "https://github.com/WebAssembly/wabt/commit/44491a4b0fdb2d2bd87a151fd169da3343954edd",
  "file_path": "src/wast-lexer.cc",
  "func_name": "WastLexer::GetToken",
  "func_before": "Token WastLexer::GetToken() {\n  while (true) {\n    token_start_ = cursor_;\n    switch (PeekChar()) {\n      case kEof:\n        return BareToken(TokenType::Eof);\n\n      case '(':\n        if (MatchString(\"(;\")) {\n          if (ReadBlockComment()) {\n            continue;\n          }\n          return BareToken(TokenType::Eof);\n        } else if (MatchString(\"(@\")) {\n          GetIdToken();\n          // offset=2 to skip the \"(@\" prefix\n          return TextToken(TokenType::LparAnn, 2);\n        } else {\n          ReadChar();\n          return BareToken(TokenType::Lpar);\n        }\n        break;\n\n      case ')':\n        ReadChar();\n        return BareToken(TokenType::Rpar);\n\n      case ';':\n        if (MatchString(\";;\")) {\n          if (ReadLineComment()) {\n            continue;\n          }\n          return BareToken(TokenType::Eof);\n        } else {\n          ReadChar();\n          ERROR(\"unexpected char\");\n          continue;\n        }\n        break;\n\n      case ' ':\n      case '\\t':\n      case '\\r':\n      case '\\n':\n        ReadWhitespace();\n        continue;\n\n      case '\"':\n        return GetStringToken();\n\n      case '+':\n      case '-':\n        ReadChar();\n        switch (PeekChar()) {\n          case 'i':\n            return GetInfToken();\n\n          case 'n':\n            return GetNanToken();\n\n          case '0':\n            return MatchString(\"0x\") ? GetHexNumberToken(TokenType::Int)\n                                     : GetNumberToken(TokenType::Int);\n          case '1':\n          case '2':\n          case '3':\n          case '4':\n          case '5':\n          case '6':\n          case '7':\n          case '8':\n          case '9':\n            return GetNumberToken(TokenType::Int);\n\n          default:\n            return GetReservedToken();\n        }\n        break;\n\n      case '0':\n        return MatchString(\"0x\") ? GetHexNumberToken(TokenType::Nat)\n                                 : GetNumberToken(TokenType::Nat);\n\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n        return GetNumberToken(TokenType::Nat);\n\n      case '$':\n        return GetIdToken();\n\n      case 'a':\n        return GetNameEqNumToken(\"align=\", TokenType::AlignEqNat);\n\n      case 'i':\n        return GetInfToken();\n\n      case 'n':\n        return GetNanToken();\n\n      case 'o':\n        return GetNameEqNumToken(\"offset=\", TokenType::OffsetEqNat);\n\n      default:\n        if (IsKeyword(PeekChar())) {\n          return GetKeywordToken();\n        } else if (IsIdChar(PeekChar())) {\n          return GetReservedToken();\n        } else {\n          ReadChar();\n          ERROR(\"unexpected char\");\n          continue;\n        }\n    }\n  }\n}",
  "abstract_func_before": "Token WastLexer::GetToken() {\n  while (true) {\n    VAR_0 = VAR_1;\n    switch (PeekChar()) {\n      case VAR_2:\n        return BareToken(TokenType::Eof);\n\n      case '(':\n        if (MatchString(\"(;\")) {\n          if (ReadBlockComment()) {\n            continue;\n          }\n          return BareToken(TokenType::Eof);\n        } else if (MatchString(\"(@\")) {\n          GetIdToken();\n          /* COMMENT_0 */\n          return TextToken(TokenType::LparAnn, 2);\n        } else {\n          ReadChar();\n          return BareToken(TokenType::Lpar);\n        }\n        break;\n\n      case ')':\n        ReadChar();\n        return BareToken(TokenType::Rpar);\n\n      case ';':\n        if (MatchString(\";;\")) {\n          if (ReadLineComment()) {\n            continue;\n          }\n          return BareToken(TokenType::Eof);\n        } else {\n          ReadChar();\n          ERROR(\"unexpected char\");\n          continue;\n        }\n        break;\n\n      case ' ':\n      case '\\t':\n      case '\\r':\n      case '\\n':\n        ReadWhitespace();\n        continue;\n\n      case '\"':\n        return GetStringToken();\n\n      case '+':\n      case '-':\n        ReadChar();\n        switch (PeekChar()) {\n          case 'i':\n            return GetInfToken();\n\n          case 'n':\n            return GetNanToken();\n\n          case '0':\n            return MatchString(\"0x\") ? GetHexNumberToken(TokenType::Int)\n                                     : GetNumberToken(TokenType::Int);\n          case '1':\n          case '2':\n          case '3':\n          case '4':\n          case '5':\n          case '6':\n          case '7':\n          case '8':\n          case '9':\n            return GetNumberToken(TokenType::Int);\n\n          default:\n            return GetReservedToken();\n        }\n        break;\n\n      case '0':\n        return MatchString(\"0x\") ? GetHexNumberToken(TokenType::Nat)\n                                 : GetNumberToken(TokenType::Nat);\n\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n        return GetNumberToken(TokenType::Nat);\n\n      case '$':\n        return GetIdToken();\n\n      case 'a':\n        return GetNameEqNumToken(\"align=\", TokenType::AlignEqNat);\n\n      case 'i':\n        return GetInfToken();\n\n      case 'n':\n        return GetNanToken();\n\n      case 'o':\n        return GetNameEqNumToken(\"offset=\", TokenType::OffsetEqNat);\n\n      default:\n        if (IsKeyword(PeekChar())) {\n          return GetKeywordToken();\n        } else if (IsIdChar(PeekChar())) {\n          return GetReservedToken();\n        } else {\n          ReadChar();\n          ERROR(\"unexpected char\");\n          continue;\n        }\n    }\n  }\n}",
  "func_graph_path_before": "WebAssembly/wabt/44491a4b0fdb2d2bd87a151fd169da3343954edd/wast-lexer.cc/vul/before/0.json",
  "func": "Token WastLexer::GetToken() {\n  while (true) {\n    token_start_ = cursor_;\n    switch (PeekChar()) {\n      case kEof:\n        return BareToken(TokenType::Eof);\n\n      case '(':\n        if (MatchString(\"(;\")) {\n          if (ReadBlockComment()) {\n            continue;\n          }\n          return BareToken(TokenType::Eof);\n        } else if (MatchString(\"(@\")) {\n          GetIdChars();\n          // offset=2 to skip the \"(@\" prefix\n          return TextToken(TokenType::LparAnn, 2);\n        } else {\n          ReadChar();\n          return BareToken(TokenType::Lpar);\n        }\n        break;\n\n      case ')':\n        ReadChar();\n        return BareToken(TokenType::Rpar);\n\n      case ';':\n        if (MatchString(\";;\")) {\n          if (ReadLineComment()) {\n            continue;\n          }\n          return BareToken(TokenType::Eof);\n        } else {\n          ReadChar();\n          ERROR(\"unexpected char\");\n          continue;\n        }\n        break;\n\n      case ' ':\n      case '\\t':\n      case '\\r':\n      case '\\n':\n        ReadWhitespace();\n        continue;\n\n      case '\"':\n        return GetStringToken();\n\n      case '+':\n      case '-':\n        ReadChar();\n        switch (PeekChar()) {\n          case 'i':\n            return GetInfToken();\n\n          case 'n':\n            return GetNanToken();\n\n          case '0':\n            return MatchString(\"0x\") ? GetHexNumberToken(TokenType::Int)\n                                     : GetNumberToken(TokenType::Int);\n          case '1':\n          case '2':\n          case '3':\n          case '4':\n          case '5':\n          case '6':\n          case '7':\n          case '8':\n          case '9':\n            return GetNumberToken(TokenType::Int);\n\n          default:\n            return GetReservedToken();\n        }\n        break;\n\n      case '0':\n        return MatchString(\"0x\") ? GetHexNumberToken(TokenType::Nat)\n                                 : GetNumberToken(TokenType::Nat);\n\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n        return GetNumberToken(TokenType::Nat);\n\n      case '$':\n        return GetIdChars();  // Initial $ is idchar, so this produces id token\n\n      case 'a':\n        return GetNameEqNumToken(\"align=\", TokenType::AlignEqNat);\n\n      case 'i':\n        return GetInfToken();\n\n      case 'n':\n        return GetNanToken();\n\n      case 'o':\n        return GetNameEqNumToken(\"offset=\", TokenType::OffsetEqNat);\n\n      default:\n        if (IsKeyword(PeekChar())) {\n          return GetKeywordToken();\n        } else if (IsIdChar(PeekChar())) {\n          return GetReservedToken();\n        } else {\n          ReadChar();\n          ERROR(\"unexpected char\");\n          continue;\n        }\n    }\n  }\n}",
  "abstract_func": "Token WastLexer::GetToken() {\n  while (true) {\n    VAR_0 = VAR_1;\n    switch (PeekChar()) {\n      case VAR_2:\n        return BareToken(TokenType::Eof);\n\n      case '(':\n        if (MatchString(\"(;\")) {\n          if (ReadBlockComment()) {\n            continue;\n          }\n          return BareToken(TokenType::Eof);\n        } else if (MatchString(\"(@\")) {\n          GetIdChars();\n          /* COMMENT_0 */\n          return TextToken(TokenType::LparAnn, 2);\n        } else {\n          ReadChar();\n          return BareToken(TokenType::Lpar);\n        }\n        break;\n\n      case ')':\n        ReadChar();\n        return BareToken(TokenType::Rpar);\n\n      case ';':\n        if (MatchString(\";;\")) {\n          if (ReadLineComment()) {\n            continue;\n          }\n          return BareToken(TokenType::Eof);\n        } else {\n          ReadChar();\n          ERROR(\"unexpected char\");\n          continue;\n        }\n        break;\n\n      case ' ':\n      case '\\t':\n      case '\\r':\n      case '\\n':\n        ReadWhitespace();\n        continue;\n\n      case '\"':\n        return GetStringToken();\n\n      case '+':\n      case '-':\n        ReadChar();\n        switch (PeekChar()) {\n          case 'i':\n            return GetInfToken();\n\n          case 'n':\n            return GetNanToken();\n\n          case '0':\n            return MatchString(\"0x\") ? GetHexNumberToken(TokenType::Int)\n                                     : GetNumberToken(TokenType::Int);\n          case '1':\n          case '2':\n          case '3':\n          case '4':\n          case '5':\n          case '6':\n          case '7':\n          case '8':\n          case '9':\n            return GetNumberToken(TokenType::Int);\n\n          default:\n            return GetReservedToken();\n        }\n        break;\n\n      case '0':\n        return MatchString(\"0x\") ? GetHexNumberToken(TokenType::Nat)\n                                 : GetNumberToken(TokenType::Nat);\n\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n        return GetNumberToken(TokenType::Nat);\n\n      case '$':\n        return GetIdChars();  /* COMMENT_1 */\n\n      case 'a':\n        return GetNameEqNumToken(\"align=\", TokenType::AlignEqNat);\n\n      case 'i':\n        return GetInfToken();\n\n      case 'n':\n        return GetNanToken();\n\n      case 'o':\n        return GetNameEqNumToken(\"offset=\", TokenType::OffsetEqNat);\n\n      default:\n        if (IsKeyword(PeekChar())) {\n          return GetKeywordToken();\n        } else if (IsIdChar(PeekChar())) {\n          return GetReservedToken();\n        } else {\n          ReadChar();\n          ERROR(\"unexpected char\");\n          continue;\n        }\n    }\n  }\n}",
  "func_graph_path": "WebAssembly/wabt/44491a4b0fdb2d2bd87a151fd169da3343954edd/wast-lexer.cc/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -12,7 +12,7 @@\n           }\n           return BareToken(TokenType::Eof);\n         } else if (MatchString(\"(@\")) {\n-          GetIdToken();\n+          GetIdChars();\n           // offset=2 to skip the \"(@\" prefix\n           return TextToken(TokenType::LparAnn, 2);\n         } else {\n@@ -93,7 +93,7 @@\n         return GetNumberToken(TokenType::Nat);\n \n       case '$':\n-        return GetIdToken();\n+        return GetIdChars();  // Initial $ is idchar, so this produces id token\n \n       case 'a':\n         return GetNameEqNumToken(\"align=\", TokenType::AlignEqNat);",
  "diff_line_info": {
    "deleted_lines": [
      "          GetIdToken();",
      "        return GetIdToken();"
    ],
    "added_lines": [
      "          GetIdChars();",
      "        return GetIdChars();  // Initial $ is idchar, so this produces id token"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/WebAssembly/wabt/pull/2166",
  "description": {
    "pr_info": {
      "title": "Improve lexing and parsing of invalid annotations (again)",
      "number": 2166
    },
    "comment": [
      "This adds a bounds-check to WastLexer::GetText to handle the case when the offset is earlier than token_start (e.g. because GetStringToken found a newline in the string and reset token_start to point to it).\r\n\r\nAlso revises GetIdToken -> GetIdChars to stop skipping the initial char in an annotation delimiter, which is an idchar+ but not an id token.\r\n\r\nAlso fixes the WastParser to handle EOF when reading for the end of an annotation, both for code metadata annotation and other kinds. Previously this produced an infinite loop (but only when --enable-annotations was provided).\r\n\r\nFixes #2165 and adds some more regression tests.\r\n\r\nThis is sort of deja vu after #2150, sigh."
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.85,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.85"
}