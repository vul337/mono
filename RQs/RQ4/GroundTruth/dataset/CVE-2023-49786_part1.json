{
  "cve_id": "CVE-2023-49786",
  "cwe_ids": [
    "CWE-362"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "asterisk",
  "commit_msg": "res_rtp_asterisk.c: Check DTLS packets against ICE candidate list\n\nWhen ICE is in use, we can prevent a possible DOS attack by allowing\nDTLS protocol messages (client hello, etc) only from sources that\nare in the active remote candidates list.\n\nResolves: GHSA-hxj9-xwr8-w8pq",
  "commit_hash": "d7d7764cb07c8a1872804321302ef93bf62cba05",
  "git_url": "https://github.com/asterisk/asterisk/commit/d7d7764cb07c8a1872804321302ef93bf62cba05",
  "file_path": "res/res_rtp_asterisk.c",
  "func_name": "__rtp_recvfrom",
  "func_before": "static int __rtp_recvfrom(struct ast_rtp_instance *instance, void *buf, size_t size, int flags, struct ast_sockaddr *sa, int rtcp)\n{\n\tint len;\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\n\tchar *in = buf;\n#endif\n#ifdef HAVE_PJPROJECT\n\tstruct ast_sockaddr *loop = rtcp ? &rtp->rtcp_loop : &rtp->rtp_loop;\n#endif\n#ifdef TEST_FRAMEWORK\n\tstruct ast_rtp_engine_test *test = ast_rtp_instance_get_test(instance);\n#endif\n\n\tif ((len = ast_recvfrom(rtcp ? rtp->rtcp->s : rtp->s, buf, size, flags, sa)) < 0) {\n\t\treturn len;\n\t}\n\n#ifdef TEST_FRAMEWORK\n\tif (test && test->packets_to_drop > 0) {\n\t\ttest->packets_to_drop--;\n\t\treturn 0;\n\t}\n#endif\n\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\n\t/* If this is an SSL packet pass it to OpenSSL for processing. RFC section for first byte value:\n\t * https://tools.ietf.org/html/rfc5764#section-5.1.2 */\n\tif ((*in >= 20) && (*in <= 63)) {\n\t\tstruct dtls_details *dtls = !rtcp ? &rtp->dtls : &rtp->rtcp->dtls;\n\t\tint res = 0;\n\n\t\t/* If no SSL session actually exists terminate things */\n\t\tif (!dtls->ssl) {\n\t\t\tast_log(LOG_ERROR, \"Received SSL traffic on RTP instance '%p' without an SSL session\\n\",\n\t\t\t\tinstance);\n\t\t\treturn -1;\n\t\t}\n\n\t\tast_debug_dtls(3, \"(%p) DTLS - __rtp_recvfrom rtp=%p - Got SSL packet '%d'\\n\", instance, rtp, *in);\n\n\t\t/*\n\t\t * A race condition is prevented between dtls_perform_handshake()\n\t\t * and this function because both functions have to get the\n\t\t * instance lock before they can do anything.  The\n\t\t * dtls_perform_handshake() function needs to start the timer\n\t\t * before we stop it below.\n\t\t */\n\n\t\t/* Before we feed data into OpenSSL ensure that the timeout timer is either stopped or completed */\n\t\tao2_unlock(instance);\n\t\tdtls_srtp_stop_timeout_timer(instance, rtp, rtcp);\n\t\tao2_lock(instance);\n\n\t\t/* If we don't yet know if we are active or passive and we receive a packet... we are obviously passive */\n\t\tif (dtls->dtls_setup == AST_RTP_DTLS_SETUP_ACTPASS) {\n\t\t\tdtls->dtls_setup = AST_RTP_DTLS_SETUP_PASSIVE;\n\t\t\tSSL_set_accept_state(dtls->ssl);\n\t\t}\n\n\t\tBIO_write(dtls->read_bio, buf, len);\n\n\t\tlen = SSL_read(dtls->ssl, buf, len);\n\n\t\tif ((len < 0) && (SSL_get_error(dtls->ssl, len) == SSL_ERROR_SSL)) {\n\t\t\tunsigned long error = ERR_get_error();\n\t\t\tast_log(LOG_ERROR, \"DTLS failure occurred on RTP instance '%p' due to reason '%s', terminating\\n\",\n\t\t\t\tinstance, ERR_reason_error_string(error));\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (SSL_is_init_finished(dtls->ssl)) {\n\t\t\t/* Any further connections will be existing since this is now established */\n\t\t\tdtls->connection = AST_RTP_DTLS_CONNECTION_EXISTING;\n\t\t\t/* Use the keying material to set up key/salt information */\n\t\t\tif ((res = dtls_srtp_setup(rtp, instance, rtcp))) {\n\t\t\t\treturn res;\n\t\t\t}\n\t\t\t/* Notify that dtls has been established */\n\t\t\tres = RTP_DTLS_ESTABLISHED;\n\n\t\t\tast_debug_dtls(3, \"(%p) DTLS - __rtp_recvfrom rtp=%p - established'\\n\", instance, rtp);\n\t\t} else {\n\t\t\t/* Since we've sent additional traffic start the timeout timer for retransmission */\n\t\t\tdtls_srtp_start_timeout_timer(instance, rtp, rtcp);\n\t\t}\n\n\t\treturn res;\n\t}\n#endif\n\n#ifdef HAVE_PJPROJECT\n\tif (!ast_sockaddr_isnull(loop) && !ast_sockaddr_cmp(loop, sa)) {\n\t\t/* ICE traffic will have been handled in the TURN callback, so skip it but update the address\n\t\t * so it reflects the actual source and not the loopback\n\t\t */\n\t\tif (rtcp) {\n\t\t\tast_sockaddr_copy(sa, &rtp->rtcp->them);\n\t\t} else {\n\t\t\tast_rtp_instance_get_remote_address(instance, sa);\n\t\t}\n\t} else if (rtp->ice) {\n\t\tpj_str_t combined = pj_str(ast_sockaddr_stringify(sa));\n\t\tpj_sockaddr address;\n\t\tpj_status_t status;\n\t\tstruct ice_wrap *ice;\n\n\t\tpj_thread_register_check();\n\n\t\tpj_sockaddr_parse(pj_AF_UNSPEC(), 0, &combined, &address);\n\n\t\t/* Release the instance lock to avoid deadlock with PJPROJECT group lock */\n\t\tice = rtp->ice;\n\t\tao2_ref(ice, +1);\n\t\tao2_unlock(instance);\n\t\tstatus = pj_ice_sess_on_rx_pkt(ice->real_ice,\n\t\t\trtcp ? AST_RTP_ICE_COMPONENT_RTCP : AST_RTP_ICE_COMPONENT_RTP,\n\t\t\trtcp ? TRANSPORT_SOCKET_RTCP : TRANSPORT_SOCKET_RTP, buf, len, &address,\n\t\t\tpj_sockaddr_get_len(&address));\n\t\tao2_ref(ice, -1);\n\t\tao2_lock(instance);\n\t\tif (status != PJ_SUCCESS) {\n\t\t\tchar err_buf[100];\n\n\t\t\tpj_strerror(status, err_buf, sizeof(err_buf));\n\t\t\tast_log(LOG_WARNING, \"PJ ICE Rx error status code: %d '%s'.\\n\",\n\t\t\t\t(int)status, err_buf);\n\t\t\treturn -1;\n\t\t}\n\t\tif (!rtp->passthrough) {\n\t\t\t/* If a unidirectional ICE negotiation occurs then lock on to the source of the\n\t\t\t * ICE traffic and use it as the target. This will occur if the remote side only\n\t\t\t * wants to receive media but never send to us.\n\t\t\t */\n\t\t\tif (!rtp->ice_active_remote_candidates && !rtp->ice_proposed_remote_candidates) {\n\t\t\t\tif (rtcp) {\n\t\t\t\t\tast_sockaddr_copy(&rtp->rtcp->them, sa);\n\t\t\t\t} else {\n\t\t\t\t\tast_rtp_instance_set_remote_address(instance, sa);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\trtp->passthrough = 0;\n\t}\n#endif\n\n\treturn len;\n}",
  "abstract_func_before": "static int __rtp_recvfrom(struct ast_rtp_instance *VAR_0, void *VAR_1, size_t VAR_2, int VAR_3, struct ast_sockaddr *VAR_4, int VAR_5)\n{\n\tint VAR_6;\n\tstruct ast_rtp *VAR_7 = ast_rtp_instance_get_data(VAR_0);\n#if defined(VAR_8) && (VAR_9 >= 0x10001000L) && !defined(VAR_10)\n\tchar *VAR_11 = VAR_1;\n#endif\n#ifdef VAR_12\n\tstruct ast_sockaddr *VAR_13 = VAR_5 ? &VAR_7->rtcp_loop : &VAR_7->rtp_loop;\n#endif\n#ifdef VAR_14\n\tstruct ast_rtp_engine_test *VAR_15 = ast_rtp_instance_get_test(VAR_0);\n#endif\n\n\tif ((VAR_6 = ast_recvfrom(VAR_5 ? VAR_7->rtcp->s : VAR_7->s, VAR_1, VAR_2, VAR_3, VAR_4)) < 0) {\n\t\treturn VAR_6;\n\t}\n\n#ifdef VAR_14\n\tif (VAR_15 && VAR_15->packets_to_drop > 0) {\n\t\tVAR_15->packets_to_drop--;\n\t\treturn 0;\n\t}\n#endif\n\n#if defined(VAR_8) && (VAR_9 >= 0x10001000L) && !defined(VAR_10)\n\t/* COMMENT_0 */\n                                                        \n\tif ((*VAR_11 >= 20) && (*VAR_11 <= 63)) {\n\t\tstruct dtls_details *VAR_16 = !VAR_5 ? &VAR_7->dtls : &VAR_7->rtcp->dtls;\n\t\tint VAR_17 = 0;\n\n\t\t/* COMMENT_2 */\n\t\tif (!VAR_16->ssl) {\n\t\t\tast_log(VAR_18, \"Received SSL traffic on RTP instance '%p' without an SSL session\\n\",\n\t\t\t\tVAR_0);\n\t\t\treturn -1;\n\t\t}\n\n\t\tast_debug_dtls(3, \"(%p) DTLS - __rtp_recvfrom rtp=%p - Got SSL packet '%d'\\n\", VAR_0, VAR_7, *VAR_11);\n\n\t\t/* COMMENT_3 */\n                                                                   \n                                                             \n                                                    \n                                                               \n                             \n     \n\n\t\t/* COMMENT_10 */\n\t\tao2_unlock(VAR_0);\n\t\tdtls_srtp_stop_timeout_timer(VAR_0, VAR_7, VAR_5);\n\t\tao2_lock(VAR_0);\n\n\t\t/* COMMENT_11 */\n\t\tif (VAR_16->dtls_setup == VAR_19) {\n\t\t\tVAR_16->dtls_setup = VAR_20;\n\t\t\tSSL_set_accept_state(VAR_16->ssl);\n\t\t}\n\n\t\tBIO_write(VAR_16->read_bio, VAR_1, VAR_6);\n\n\t\tVAR_6 = SSL_read(VAR_16->ssl, VAR_1, VAR_6);\n\n\t\tif ((VAR_6 < 0) && (SSL_get_error(VAR_16->ssl, VAR_6) == VAR_21)) {\n\t\t\tunsigned long VAR_22 = ERR_get_error();\n\t\t\tast_log(VAR_18, \"DTLS failure occurred on RTP instance '%p' due to reason '%s', terminating\\n\",\n\t\t\t\tVAR_0, ERR_reason_error_string(VAR_22));\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (SSL_is_init_finished(VAR_16->ssl)) {\n\t\t\t/* COMMENT_12 */\n\t\t\tVAR_16->connection = VAR_23;\n\t\t\t/* COMMENT_13 */\n\t\t\tif ((VAR_17 = dtls_srtp_setup(VAR_7, VAR_0, VAR_5))) {\n\t\t\t\treturn VAR_17;\n\t\t\t}\n\t\t\t/* COMMENT_14 */\n\t\t\tVAR_17 = VAR_24;\n\n\t\t\tast_debug_dtls(3, \"(%p) DTLS - __rtp_recvfrom rtp=%p - established'\\n\", VAR_0, VAR_7);\n\t\t} else {\n\t\t\t/* COMMENT_15 */\n\t\t\tdtls_srtp_start_timeout_timer(VAR_0, VAR_7, VAR_5);\n\t\t}\n\n\t\treturn VAR_17;\n\t}\n#endif\n\n#ifdef VAR_12\n\tif (!ast_sockaddr_isnull(VAR_13) && !ast_sockaddr_cmp(VAR_13, VAR_4)) {\n\t\t/* COMMENT_16 */\n                                                          \n     \n\t\tif (VAR_5) {\n\t\t\tast_sockaddr_copy(VAR_4, &VAR_7->rtcp->them);\n\t\t} else {\n\t\t\tast_rtp_instance_get_remote_address(VAR_0, VAR_4);\n\t\t}\n\t} else if (VAR_7->ice) {\n\t\tpj_str_t VAR_25 = pj_str(ast_sockaddr_stringify(VAR_4));\n\t\tpj_sockaddr VAR_26;\n\t\tpj_status_t VAR_27;\n\t\tstruct ice_wrap *VAR_28;\n\n\t\tpj_thread_register_check();\n\n\t\tpj_sockaddr_parse(pj_AF_UNSPEC(), 0, &VAR_25, &VAR_26);\n\n\t\t/* COMMENT_19 */\n\t\tVAR_28 = VAR_7->ice;\n\t\tao2_ref(VAR_28, +1);\n\t\tao2_unlock(VAR_0);\n\t\tVAR_27 = pj_ice_sess_on_rx_pkt(VAR_28->real_ice,\n\t\t\tVAR_5 ? VAR_29 : VAR_30,\n\t\t\tVAR_5 ? VAR_31 : VAR_32, VAR_1, VAR_6, &VAR_26,\n\t\t\tpj_sockaddr_get_len(&VAR_26));\n\t\tao2_ref(VAR_28, -1);\n\t\tao2_lock(VAR_0);\n\t\tif (VAR_27 != VAR_33) {\n\t\t\tchar VAR_34[100];\n\n\t\t\tpj_strerror(VAR_27, VAR_34, sizeof(VAR_34));\n\t\t\tast_log(VAR_35, \"PJ ICE Rx error status code: %d '%s'.\\n\",\n\t\t\t\t(int)VAR_27, VAR_34);\n\t\t\treturn -1;\n\t\t}\n\t\tif (!VAR_7->passthrough) {\n\t\t\t/* COMMENT_20 */\n                                                                                   \n                                                  \n      \n\t\t\tif (!VAR_7->ice_active_remote_candidates && !VAR_7->ice_proposed_remote_candidates) {\n\t\t\t\tif (VAR_5) {\n\t\t\t\t\tast_sockaddr_copy(&VAR_7->rtcp->them, VAR_4);\n\t\t\t\t} else {\n\t\t\t\t\tast_rtp_instance_set_remote_address(VAR_0, VAR_4);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tVAR_7->passthrough = 0;\n\t}\n#endif\n\n\treturn VAR_6;\n}",
  "func_graph_path_before": "asterisk/d7d7764cb07c8a1872804321302ef93bf62cba05/res_rtp_asterisk.c/vul/before/0.json",
  "func": "static int __rtp_recvfrom(struct ast_rtp_instance *instance, void *buf, size_t size, int flags, struct ast_sockaddr *sa, int rtcp)\n{\n\tint len;\n\tstruct ast_rtp *rtp = ast_rtp_instance_get_data(instance);\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\n\tchar *in = buf;\n#endif\n#ifdef HAVE_PJPROJECT\n\tstruct ast_sockaddr *loop = rtcp ? &rtp->rtcp_loop : &rtp->rtp_loop;\n#endif\n#ifdef TEST_FRAMEWORK\n\tstruct ast_rtp_engine_test *test = ast_rtp_instance_get_test(instance);\n#endif\n\n\tif ((len = ast_recvfrom(rtcp ? rtp->rtcp->s : rtp->s, buf, size, flags, sa)) < 0) {\n\t\treturn len;\n\t}\n\n#ifdef TEST_FRAMEWORK\n\tif (test && test->packets_to_drop > 0) {\n\t\ttest->packets_to_drop--;\n\t\treturn 0;\n\t}\n#endif\n\n#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)\n\t/* If this is an SSL packet pass it to OpenSSL for processing. RFC section for first byte value:\n\t * https://tools.ietf.org/html/rfc5764#section-5.1.2 */\n\tif ((*in >= 20) && (*in <= 63)) {\n\t\tstruct dtls_details *dtls = !rtcp ? &rtp->dtls : &rtp->rtcp->dtls;\n\t\tint res = 0;\n\n\t\t/* If no SSL session actually exists terminate things */\n\t\tif (!dtls->ssl) {\n\t\t\tast_log(LOG_ERROR, \"Received SSL traffic on RTP instance '%p' without an SSL session\\n\",\n\t\t\t\tinstance);\n\t\t\treturn -1;\n\t\t}\n\n\t\tast_debug_dtls(3, \"(%p) DTLS - __rtp_recvfrom rtp=%p - Got SSL packet '%d'\\n\", instance, rtp, *in);\n\n\t\t/*\n\t\t * If ICE is in use, we can prevent a possible DOS attack\n\t\t * by allowing DTLS protocol messages (client hello, etc)\n\t\t * only from sources that are in the active remote\n\t\t * candidates list.\n\t\t */\n\n\t\tif (rtp->ice) {\n\t\t\tint pass_src_check = 0;\n\t\t\tstruct ao2_iterator i;\n\t\t\tstruct ast_rtp_engine_ice_candidate *candidate;\n\t\t\tint cand_cnt = 0;\n\n\t\t\t/*\n\t\t\t * You'd think that this check would cause a \"deadlock\"\n\t\t\t * because ast_rtp_ice_start_media calls dtls_perform_handshake\n\t\t\t * before it sets ice_media_started = 1 so how can we do a\n\t\t\t * handshake if we're dropping packets before we send them\n\t\t\t * to openssl.  Fortunately, dtls_perform_handshake just sets\n\t\t\t * up openssl to do the handshake and doesn't actually perform it\n\t\t\t * itself and the locking prevents __rtp_recvfrom from\n\t\t\t * running before the ice_media_started flag is set.  So only\n\t\t\t * unexpected DTLS packets can get dropped here.\n\t\t\t */\n\t\t\tif (!rtp->ice_media_started) {\n\t\t\t\tast_log(LOG_WARNING, \"%s: DTLS packet from %s dropped. ICE not completed yet.\\n\",\n\t\t\t\t\tast_rtp_instance_get_channel_id(instance),\n\t\t\t\t\tast_sockaddr_stringify(sa));\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If we got this far, then ice_active_remote_candidates\n\t\t\t * can't be NULL.\n\t\t\t */\n\t\t\ti = ao2_iterator_init(rtp->ice_active_remote_candidates, 0);\n\t\t\twhile ((candidate = ao2_iterator_next(&i)) && (cand_cnt < PJ_ICE_MAX_CAND)) {\n\t\t\t\tres = ast_sockaddr_cmp_addr(&candidate->address, sa);\n\t\t\t\tao2_ref(candidate, -1);\n\t\t\t\tif (res == 0) {\n\t\t\t\t\tpass_src_check = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcand_cnt++;\n\t\t\t}\n\t\t\tao2_iterator_destroy(&i);\n\n\t\t\tif (!pass_src_check) {\n\t\t\t\tast_log(LOG_WARNING, \"%s: DTLS packet from %s dropped. Source not in ICE active candidate list.\\n\",\n\t\t\t\t\tast_rtp_instance_get_channel_id(instance),\n\t\t\t\t\tast_sockaddr_stringify(sa));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * A race condition is prevented between dtls_perform_handshake()\n\t\t * and this function because both functions have to get the\n\t\t * instance lock before they can do anything.  The\n\t\t * dtls_perform_handshake() function needs to start the timer\n\t\t * before we stop it below.\n\t\t */\n\n\t\t/* Before we feed data into OpenSSL ensure that the timeout timer is either stopped or completed */\n\t\tao2_unlock(instance);\n\t\tdtls_srtp_stop_timeout_timer(instance, rtp, rtcp);\n\t\tao2_lock(instance);\n\n\t\t/* If we don't yet know if we are active or passive and we receive a packet... we are obviously passive */\n\t\tif (dtls->dtls_setup == AST_RTP_DTLS_SETUP_ACTPASS) {\n\t\t\tdtls->dtls_setup = AST_RTP_DTLS_SETUP_PASSIVE;\n\t\t\tSSL_set_accept_state(dtls->ssl);\n\t\t}\n\n\t\tBIO_write(dtls->read_bio, buf, len);\n\n\t\tlen = SSL_read(dtls->ssl, buf, len);\n\n\t\tif ((len < 0) && (SSL_get_error(dtls->ssl, len) == SSL_ERROR_SSL)) {\n\t\t\tunsigned long error = ERR_get_error();\n\t\t\tast_log(LOG_ERROR, \"DTLS failure occurred on RTP instance '%p' due to reason '%s', terminating\\n\",\n\t\t\t\tinstance, ERR_reason_error_string(error));\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (SSL_is_init_finished(dtls->ssl)) {\n\t\t\t/* Any further connections will be existing since this is now established */\n\t\t\tdtls->connection = AST_RTP_DTLS_CONNECTION_EXISTING;\n\t\t\t/* Use the keying material to set up key/salt information */\n\t\t\tif ((res = dtls_srtp_setup(rtp, instance, rtcp))) {\n\t\t\t\treturn res;\n\t\t\t}\n\t\t\t/* Notify that dtls has been established */\n\t\t\tres = RTP_DTLS_ESTABLISHED;\n\n\t\t\tast_debug_dtls(3, \"(%p) DTLS - __rtp_recvfrom rtp=%p - established'\\n\", instance, rtp);\n\t\t} else {\n\t\t\t/* Since we've sent additional traffic start the timeout timer for retransmission */\n\t\t\tdtls_srtp_start_timeout_timer(instance, rtp, rtcp);\n\t\t}\n\n\t\treturn res;\n\t}\n#endif\n\n#ifdef HAVE_PJPROJECT\n\tif (!ast_sockaddr_isnull(loop) && !ast_sockaddr_cmp(loop, sa)) {\n\t\t/* ICE traffic will have been handled in the TURN callback, so skip it but update the address\n\t\t * so it reflects the actual source and not the loopback\n\t\t */\n\t\tif (rtcp) {\n\t\t\tast_sockaddr_copy(sa, &rtp->rtcp->them);\n\t\t} else {\n\t\t\tast_rtp_instance_get_remote_address(instance, sa);\n\t\t}\n\t} else if (rtp->ice) {\n\t\tpj_str_t combined = pj_str(ast_sockaddr_stringify(sa));\n\t\tpj_sockaddr address;\n\t\tpj_status_t status;\n\t\tstruct ice_wrap *ice;\n\n\t\tpj_thread_register_check();\n\n\t\tpj_sockaddr_parse(pj_AF_UNSPEC(), 0, &combined, &address);\n\n\t\t/* Release the instance lock to avoid deadlock with PJPROJECT group lock */\n\t\tice = rtp->ice;\n\t\tao2_ref(ice, +1);\n\t\tao2_unlock(instance);\n\t\tstatus = pj_ice_sess_on_rx_pkt(ice->real_ice,\n\t\t\trtcp ? AST_RTP_ICE_COMPONENT_RTCP : AST_RTP_ICE_COMPONENT_RTP,\n\t\t\trtcp ? TRANSPORT_SOCKET_RTCP : TRANSPORT_SOCKET_RTP, buf, len, &address,\n\t\t\tpj_sockaddr_get_len(&address));\n\t\tao2_ref(ice, -1);\n\t\tao2_lock(instance);\n\t\tif (status != PJ_SUCCESS) {\n\t\t\tchar err_buf[100];\n\n\t\t\tpj_strerror(status, err_buf, sizeof(err_buf));\n\t\t\tast_log(LOG_WARNING, \"PJ ICE Rx error status code: %d '%s'.\\n\",\n\t\t\t\t(int)status, err_buf);\n\t\t\treturn -1;\n\t\t}\n\t\tif (!rtp->passthrough) {\n\t\t\t/* If a unidirectional ICE negotiation occurs then lock on to the source of the\n\t\t\t * ICE traffic and use it as the target. This will occur if the remote side only\n\t\t\t * wants to receive media but never send to us.\n\t\t\t */\n\t\t\tif (!rtp->ice_active_remote_candidates && !rtp->ice_proposed_remote_candidates) {\n\t\t\t\tif (rtcp) {\n\t\t\t\t\tast_sockaddr_copy(&rtp->rtcp->them, sa);\n\t\t\t\t} else {\n\t\t\t\t\tast_rtp_instance_set_remote_address(instance, sa);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\trtp->passthrough = 0;\n\t}\n#endif\n\n\treturn len;\n}",
  "abstract_func": "static int __rtp_recvfrom(struct ast_rtp_instance *VAR_0, void *VAR_1, size_t VAR_2, int VAR_3, struct ast_sockaddr *VAR_4, int VAR_5)\n{\n\tint VAR_6;\n\tstruct ast_rtp *VAR_7 = ast_rtp_instance_get_data(VAR_0);\n#if defined(VAR_8) && (VAR_9 >= 0x10001000L) && !defined(VAR_10)\n\tchar *VAR_11 = VAR_1;\n#endif\n#ifdef VAR_12\n\tstruct ast_sockaddr *VAR_13 = VAR_5 ? &VAR_7->rtcp_loop : &VAR_7->rtp_loop;\n#endif\n#ifdef VAR_14\n\tstruct ast_rtp_engine_test *VAR_15 = ast_rtp_instance_get_test(VAR_0);\n#endif\n\n\tif ((VAR_6 = ast_recvfrom(VAR_5 ? VAR_7->rtcp->s : VAR_7->s, VAR_1, VAR_2, VAR_3, VAR_4)) < 0) {\n\t\treturn VAR_6;\n\t}\n\n#ifdef VAR_14\n\tif (VAR_15 && VAR_15->packets_to_drop > 0) {\n\t\tVAR_15->packets_to_drop--;\n\t\treturn 0;\n\t}\n#endif\n\n#if defined(VAR_8) && (VAR_9 >= 0x10001000L) && !defined(VAR_10)\n\t/* COMMENT_0 */\n                                                        \n\tif ((*VAR_11 >= 20) && (*VAR_11 <= 63)) {\n\t\tstruct dtls_details *VAR_16 = !VAR_5 ? &VAR_7->dtls : &VAR_7->rtcp->dtls;\n\t\tint VAR_17 = 0;\n\n\t\t/* COMMENT_2 */\n\t\tif (!VAR_16->ssl) {\n\t\t\tast_log(VAR_18, \"Received SSL traffic on RTP instance '%p' without an SSL session\\n\",\n\t\t\t\tVAR_0);\n\t\t\treturn -1;\n\t\t}\n\n\t\tast_debug_dtls(3, \"(%p) DTLS - __rtp_recvfrom rtp=%p - Got SSL packet '%d'\\n\", VAR_0, VAR_7, *VAR_11);\n\n\t\t/* COMMENT_3 */\n                                                           \n                                                           \n                                                    \n                     \n     \n\n\t\tif (VAR_7->ice) {\n\t\t\tint VAR_19 = 0;\n\t\t\tstruct ao2_iterator VAR_20;\n\t\t\tstruct ast_rtp_engine_ice_candidate *VAR_21;\n\t\t\tint VAR_22 = 0;\n\n\t\t\t/* COMMENT_9 */\n                                                          \n                                                                  \n                                                             \n                                                             \n                                                                \n                                                                    \n                                                         \n                                                                \n                                                   \n      \n\t\t\tif (!VAR_7->ice_media_started) {\n\t\t\t\tast_log(VAR_23, \"%s: DTLS packet from %s dropped. ICE not completed yet.\\n\",\n\t\t\t\t\tast_rtp_instance_get_channel_id(VAR_0),\n\t\t\t\t\tast_sockaddr_stringify(VAR_4));\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/* COMMENT_20 */\n                                                           \n                    \n      \n\t\t\tVAR_20 = ao2_iterator_init(VAR_7->ice_active_remote_candidates, 0);\n\t\t\twhile ((VAR_21 = ao2_iterator_next(&VAR_20)) && (VAR_22 < VAR_24)) {\n\t\t\t\tVAR_17 = ast_sockaddr_cmp_addr(&VAR_21->address, VAR_4);\n\t\t\t\tao2_ref(VAR_21, -1);\n\t\t\t\tif (VAR_17 == 0) {\n\t\t\t\t\tVAR_19 = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tVAR_22++;\n\t\t\t}\n\t\t\tao2_iterator_destroy(&VAR_20);\n\n\t\t\tif (!VAR_19) {\n\t\t\t\tast_log(VAR_23, \"%s: DTLS packet from %s dropped. Source not in ICE active candidate list.\\n\",\n\t\t\t\t\tast_rtp_instance_get_channel_id(VAR_0),\n\t\t\t\t\tast_sockaddr_stringify(VAR_4));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\t/* COMMENT_24 */\n                                                                   \n                                                             \n                                                    \n                                                               \n                             \n     \n\n\t\t/* COMMENT_31 */\n\t\tao2_unlock(VAR_0);\n\t\tdtls_srtp_stop_timeout_timer(VAR_0, VAR_7, VAR_5);\n\t\tao2_lock(VAR_0);\n\n\t\t/* COMMENT_32 */\n\t\tif (VAR_16->dtls_setup == VAR_25) {\n\t\t\tVAR_16->dtls_setup = VAR_26;\n\t\t\tSSL_set_accept_state(VAR_16->ssl);\n\t\t}\n\n\t\tBIO_write(VAR_16->read_bio, VAR_1, VAR_6);\n\n\t\tVAR_6 = SSL_read(VAR_16->ssl, VAR_1, VAR_6);\n\n\t\tif ((VAR_6 < 0) && (SSL_get_error(VAR_16->ssl, VAR_6) == VAR_27)) {\n\t\t\tunsigned long VAR_28 = ERR_get_error();\n\t\t\tast_log(VAR_18, \"DTLS failure occurred on RTP instance '%p' due to reason '%s', terminating\\n\",\n\t\t\t\tVAR_0, ERR_reason_error_string(VAR_28));\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (SSL_is_init_finished(VAR_16->ssl)) {\n\t\t\t/* COMMENT_33 */\n\t\t\tVAR_16->connection = VAR_29;\n\t\t\t/* COMMENT_34 */\n\t\t\tif ((VAR_17 = dtls_srtp_setup(VAR_7, VAR_0, VAR_5))) {\n\t\t\t\treturn VAR_17;\n\t\t\t}\n\t\t\t/* COMMENT_35 */\n\t\t\tVAR_17 = VAR_30;\n\n\t\t\tast_debug_dtls(3, \"(%p) DTLS - __rtp_recvfrom rtp=%p - established'\\n\", VAR_0, VAR_7);\n\t\t} else {\n\t\t\t/* COMMENT_36 */\n\t\t\tdtls_srtp_start_timeout_timer(VAR_0, VAR_7, VAR_5);\n\t\t}\n\n\t\treturn VAR_17;\n\t}\n#endif\n\n#ifdef VAR_12\n\tif (!ast_sockaddr_isnull(VAR_13) && !ast_sockaddr_cmp(VAR_13, VAR_4)) {\n\t\t/* COMMENT_37 */\n                                                          \n     \n\t\tif (VAR_5) {\n\t\t\tast_sockaddr_copy(VAR_4, &VAR_7->rtcp->them);\n\t\t} else {\n\t\t\tast_rtp_instance_get_remote_address(VAR_0, VAR_4);\n\t\t}\n\t} else if (VAR_7->ice) {\n\t\tpj_str_t VAR_31 = pj_str(ast_sockaddr_stringify(VAR_4));\n\t\tpj_sockaddr VAR_32;\n\t\tpj_status_t VAR_33;\n\t\tstruct ice_wrap *VAR_34;\n\n\t\tpj_thread_register_check();\n\n\t\tpj_sockaddr_parse(pj_AF_UNSPEC(), 0, &VAR_31, &VAR_32);\n\n\t\t/* COMMENT_40 */\n\t\tVAR_34 = VAR_7->ice;\n\t\tao2_ref(VAR_34, +1);\n\t\tao2_unlock(VAR_0);\n\t\tVAR_33 = pj_ice_sess_on_rx_pkt(VAR_34->real_ice,\n\t\t\tVAR_5 ? VAR_35 : VAR_36,\n\t\t\tVAR_5 ? VAR_37 : VAR_38, VAR_1, VAR_6, &VAR_32,\n\t\t\tpj_sockaddr_get_len(&VAR_32));\n\t\tao2_ref(VAR_34, -1);\n\t\tao2_lock(VAR_0);\n\t\tif (VAR_33 != VAR_39) {\n\t\t\tchar VAR_40[100];\n\n\t\t\tpj_strerror(VAR_33, VAR_40, sizeof(VAR_40));\n\t\t\tast_log(VAR_23, \"PJ ICE Rx error status code: %d '%s'.\\n\",\n\t\t\t\t(int)VAR_33, VAR_40);\n\t\t\treturn -1;\n\t\t}\n\t\tif (!VAR_7->passthrough) {\n\t\t\t/* COMMENT_41 */\n                                                                                   \n                                                  \n      \n\t\t\tif (!VAR_7->ice_active_remote_candidates && !VAR_7->ice_proposed_remote_candidates) {\n\t\t\t\tif (VAR_5) {\n\t\t\t\t\tast_sockaddr_copy(&VAR_7->rtcp->them, VAR_4);\n\t\t\t\t} else {\n\t\t\t\t\tast_rtp_instance_set_remote_address(VAR_0, VAR_4);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tVAR_7->passthrough = 0;\n\t}\n#endif\n\n\treturn VAR_6;\n}",
  "func_graph_path": "asterisk/d7d7764cb07c8a1872804321302ef93bf62cba05/res_rtp_asterisk.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -38,6 +38,61 @@\n \t\t}\n \n \t\tast_debug_dtls(3, \"(%p) DTLS - __rtp_recvfrom rtp=%p - Got SSL packet '%d'\\n\", instance, rtp, *in);\n+\n+\t\t/*\n+\t\t * If ICE is in use, we can prevent a possible DOS attack\n+\t\t * by allowing DTLS protocol messages (client hello, etc)\n+\t\t * only from sources that are in the active remote\n+\t\t * candidates list.\n+\t\t */\n+\n+\t\tif (rtp->ice) {\n+\t\t\tint pass_src_check = 0;\n+\t\t\tstruct ao2_iterator i;\n+\t\t\tstruct ast_rtp_engine_ice_candidate *candidate;\n+\t\t\tint cand_cnt = 0;\n+\n+\t\t\t/*\n+\t\t\t * You'd think that this check would cause a \"deadlock\"\n+\t\t\t * because ast_rtp_ice_start_media calls dtls_perform_handshake\n+\t\t\t * before it sets ice_media_started = 1 so how can we do a\n+\t\t\t * handshake if we're dropping packets before we send them\n+\t\t\t * to openssl.  Fortunately, dtls_perform_handshake just sets\n+\t\t\t * up openssl to do the handshake and doesn't actually perform it\n+\t\t\t * itself and the locking prevents __rtp_recvfrom from\n+\t\t\t * running before the ice_media_started flag is set.  So only\n+\t\t\t * unexpected DTLS packets can get dropped here.\n+\t\t\t */\n+\t\t\tif (!rtp->ice_media_started) {\n+\t\t\t\tast_log(LOG_WARNING, \"%s: DTLS packet from %s dropped. ICE not completed yet.\\n\",\n+\t\t\t\t\tast_rtp_instance_get_channel_id(instance),\n+\t\t\t\t\tast_sockaddr_stringify(sa));\n+\t\t\t\treturn 0;\n+\t\t\t}\n+\n+\t\t\t/*\n+\t\t\t * If we got this far, then ice_active_remote_candidates\n+\t\t\t * can't be NULL.\n+\t\t\t */\n+\t\t\ti = ao2_iterator_init(rtp->ice_active_remote_candidates, 0);\n+\t\t\twhile ((candidate = ao2_iterator_next(&i)) && (cand_cnt < PJ_ICE_MAX_CAND)) {\n+\t\t\t\tres = ast_sockaddr_cmp_addr(&candidate->address, sa);\n+\t\t\t\tao2_ref(candidate, -1);\n+\t\t\t\tif (res == 0) {\n+\t\t\t\t\tpass_src_check = 1;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\tcand_cnt++;\n+\t\t\t}\n+\t\t\tao2_iterator_destroy(&i);\n+\n+\t\t\tif (!pass_src_check) {\n+\t\t\t\tast_log(LOG_WARNING, \"%s: DTLS packet from %s dropped. Source not in ICE active candidate list.\\n\",\n+\t\t\t\t\tast_rtp_instance_get_channel_id(instance),\n+\t\t\t\t\tast_sockaddr_stringify(sa));\n+\t\t\t\treturn 0;\n+\t\t\t}\n+\t\t}\n \n \t\t/*\n \t\t * A race condition is prevented between dtls_perform_handshake()",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "",
      "\t\t/*",
      "\t\t * If ICE is in use, we can prevent a possible DOS attack",
      "\t\t * by allowing DTLS protocol messages (client hello, etc)",
      "\t\t * only from sources that are in the active remote",
      "\t\t * candidates list.",
      "\t\t */",
      "",
      "\t\tif (rtp->ice) {",
      "\t\t\tint pass_src_check = 0;",
      "\t\t\tstruct ao2_iterator i;",
      "\t\t\tstruct ast_rtp_engine_ice_candidate *candidate;",
      "\t\t\tint cand_cnt = 0;",
      "",
      "\t\t\t/*",
      "\t\t\t * You'd think that this check would cause a \"deadlock\"",
      "\t\t\t * because ast_rtp_ice_start_media calls dtls_perform_handshake",
      "\t\t\t * before it sets ice_media_started = 1 so how can we do a",
      "\t\t\t * handshake if we're dropping packets before we send them",
      "\t\t\t * to openssl.  Fortunately, dtls_perform_handshake just sets",
      "\t\t\t * up openssl to do the handshake and doesn't actually perform it",
      "\t\t\t * itself and the locking prevents __rtp_recvfrom from",
      "\t\t\t * running before the ice_media_started flag is set.  So only",
      "\t\t\t * unexpected DTLS packets can get dropped here.",
      "\t\t\t */",
      "\t\t\tif (!rtp->ice_media_started) {",
      "\t\t\t\tast_log(LOG_WARNING, \"%s: DTLS packet from %s dropped. ICE not completed yet.\\n\",",
      "\t\t\t\t\tast_rtp_instance_get_channel_id(instance),",
      "\t\t\t\t\tast_sockaddr_stringify(sa));",
      "\t\t\t\treturn 0;",
      "\t\t\t}",
      "",
      "\t\t\t/*",
      "\t\t\t * If we got this far, then ice_active_remote_candidates",
      "\t\t\t * can't be NULL.",
      "\t\t\t */",
      "\t\t\ti = ao2_iterator_init(rtp->ice_active_remote_candidates, 0);",
      "\t\t\twhile ((candidate = ao2_iterator_next(&i)) && (cand_cnt < PJ_ICE_MAX_CAND)) {",
      "\t\t\t\tres = ast_sockaddr_cmp_addr(&candidate->address, sa);",
      "\t\t\t\tao2_ref(candidate, -1);",
      "\t\t\t\tif (res == 0) {",
      "\t\t\t\t\tpass_src_check = 1;",
      "\t\t\t\t\tbreak;",
      "\t\t\t\t}",
      "\t\t\t\tcand_cnt++;",
      "\t\t\t}",
      "\t\t\tao2_iterator_destroy(&i);",
      "",
      "\t\t\tif (!pass_src_check) {",
      "\t\t\t\tast_log(LOG_WARNING, \"%s: DTLS packet from %s dropped. Source not in ICE active candidate list.\\n\",",
      "\t\t\t\t\tast_rtp_instance_get_channel_id(instance),",
      "\t\t\t\t\tast_sockaddr_stringify(sa));",
      "\t\t\t\treturn 0;",
      "\t\t\t}",
      "\t\t}"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/asterisk/asterisk/pull/495",
  "description": {
    "pr_info": {
      "title": "res_rtp_asterisk.c: Check DTLS packets against ICE candidate list",
      "number": 495
    },
    "comment": [
      "When ICE is in use, we can prevent a possible DOS attack by allowing\nDTLS protocol messages (client hello, etc) only from sources that\nare in the active remote candidates list.\n\nResolves: GHSA-hxj9-xwr8-w8pq\n",
      "cherry-pick-to: 18\r\ncherry-pick-to: 20\r\ncherry-pick-to: 21\r\ncherry-pick-to: certified/18.9",
      "cherry-pick-test",
      "Successfully merged to branch master and cherry-picked to [\"18\",\"20\",\"21\",\"certified/18.9\"]"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0"
}