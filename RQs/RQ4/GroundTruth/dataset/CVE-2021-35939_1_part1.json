{
  "cve_id": "CVE-2021-35939",
  "cwe_ids": [
    "CWE-59"
  ],
  "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "rpm-software-management/rpm",
  "commit_msg": "Validate intermediate symlinks during installation, CVE-2021-35939\n\nWhenever directory changes during unpacking, walk the entire tree from\nstarting from / and validate any symlinks crossed, fail the install\non invalid links.\n\nThis is the first of step of many towards securing our file operations\nagainst local tamperers and besides plugging that one CVE, paves the way\nfor the next step by adding the necessary directory fd tracking.\nThis also bumps the rpm OS requirements to a whole new level by requiring\nthe *at() family of calls from POSIX-1.2008.\n\nThis necessarily does a whole lot of huffing and puffing we previously\ndid not do. It should be possible to cache secure (ie root-owned)\ndirectory structures to avoid validating everything a million times\nbut for now, just keeping things simple.",
  "commit_hash": "96ec957e281220f8e137a2d5eb23b83a6377d556",
  "git_url": "https://github.com/rpm-software-management/rpm/commit/96ec957e281220f8e137a2d5eb23b83a6377d556",
  "file_path": "lib/fsm.c",
  "func_name": "fsmMkdir",
  "func_before": "static int fsmMkdir(const char *path, mode_t mode)\n{\n    int rc = mkdir(path, (mode & 07777));\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s, 0%04o) %s\\n\", __func__,\n\t       path, (unsigned)(mode & 07777),\n\t       (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\trc = RPMERR_MKDIR_FAILED;\n    return rc;\n}",
  "abstract_func_before": "static int fsmMkdir(const char *VAR_0, mode_t VAR_1)\n{\n    int VAR_2 = mkdir(VAR_0, (VAR_1 & 07777));\n    if (VAR_3)\n\trpmlog(VAR_4, \" %8s (%s, 0%04o) %s\\n\", VAR_5,\n\t       VAR_0, (unsigned)(VAR_1 & 07777),\n\t       (VAR_2 < 0 ? strerror(VAR_6) : \"\"));\n    if (VAR_2 < 0)\tVAR_2 = VAR_7;\n    return VAR_2;\n}",
  "func_graph_path_before": "rpm-software-management/rpm/96ec957e281220f8e137a2d5eb23b83a6377d556/fsm.c/vul/before/2.json",
  "func": "static int fsmMkdir(int dirfd, const char *path, mode_t mode)\n{\n    int rc = mkdirat(dirfd, path, (mode & 07777));\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%d %s, 0%04o) %s\\n\", __func__,\n\t       dirfd, path, (unsigned)(mode & 07777),\n\t       (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\trc = RPMERR_MKDIR_FAILED;\n    return rc;\n}",
  "abstract_func": "static int fsmMkdir(int VAR_0, const char *VAR_1, mode_t VAR_2)\n{\n    int VAR_3 = mkdirat(VAR_0, VAR_1, (VAR_2 & 07777));\n    if (VAR_4)\n\trpmlog(VAR_5, \" %8s (%d %s, 0%04o) %s\\n\", VAR_6,\n\t       VAR_0, VAR_1, (unsigned)(VAR_2 & 07777),\n\t       (VAR_3 < 0 ? strerror(VAR_7) : \"\"));\n    if (VAR_3 < 0)\tVAR_3 = VAR_8;\n    return VAR_3;\n}",
  "func_graph_path": "rpm-software-management/rpm/96ec957e281220f8e137a2d5eb23b83a6377d556/fsm.c/vul/after/2.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,9 +1,9 @@\n-static int fsmMkdir(const char *path, mode_t mode)\n+static int fsmMkdir(int dirfd, const char *path, mode_t mode)\n {\n-    int rc = mkdir(path, (mode & 07777));\n+    int rc = mkdirat(dirfd, path, (mode & 07777));\n     if (_fsm_debug)\n-\trpmlog(RPMLOG_DEBUG, \" %8s (%s, 0%04o) %s\\n\", __func__,\n-\t       path, (unsigned)(mode & 07777),\n+\trpmlog(RPMLOG_DEBUG, \" %8s (%d %s, 0%04o) %s\\n\", __func__,\n+\t       dirfd, path, (unsigned)(mode & 07777),\n \t       (rc < 0 ? strerror(errno) : \"\"));\n     if (rc < 0)\trc = RPMERR_MKDIR_FAILED;\n     return rc;",
  "diff_line_info": {
    "deleted_lines": [
      "static int fsmMkdir(const char *path, mode_t mode)",
      "    int rc = mkdir(path, (mode & 07777));",
      "\trpmlog(RPMLOG_DEBUG, \" %8s (%s, 0%04o) %s\\n\", __func__,",
      "\t       path, (unsigned)(mode & 07777),"
    ],
    "added_lines": [
      "static int fsmMkdir(int dirfd, const char *path, mode_t mode)",
      "    int rc = mkdirat(dirfd, path, (mode & 07777));",
      "\trpmlog(RPMLOG_DEBUG, \" %8s (%d %s, 0%04o) %s\\n\", __func__,",
      "\t       dirfd, path, (unsigned)(mode & 07777),"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/rpm-software-management/rpm/pull/1919",
  "description": {
    "pr_info": {
      "title": "First steps towards fixing the symlink CVEs",
      "number": 1919
    },
    "comment": [
      "Details in commits, but basically fixes CVE-2021-35939 and lays down some necessary infrastructure for next steps in securing down our file operations.",
      "It should be noted (probably in the commit message too) that as these symlink CVE's overlap and interact in various ways, this does not fully fix CVE-2021-35939 as the directory tracking does not cover all our installation steps yet. Plugging all the holes requires converting *all* of FSM to the *at() family of calls plus fd-based ops where possible, so this really is just the first step of many to come.",
      "I'm quite aware of Linux having all manner of fancy extensions available.\r\nRpm is portable software and we need to fix this stuff using what's available in POSIX, utilizing non-portable extensions would only make things far more complicated rather than help. There's enough complexities to deal with as it is, thank you very much.",
      "This is now using fd or dirfd+basename for file ops within the fsm, as much as possible. Plugins pose special problems as external libraries generally dont support dirfd+basename style operation, but may still need to operate on symlinks so we're stuck with \"insecure\" absolute paths there, for now at least.\r\n\r\nI'm seeing a couple of install glitches on fresh chroot install still, but it's getting close now.\r\nOf course a change this big and drastic *will* have bugs in it initially, I have no illusions about that.\r\n\r\n(edit: hmph, the test-suite was passing just a minute ago...)",
      "Okay, test-suite + all my local tests (install to empty chroot etc) pass now :partying_face: ",
      "> This is now using fd or dirfd+basename for file ops within the fsm, as much as possible. Plugins pose special problems as external libraries generally dont support dirfd+basename style operation, but may still need to operate on symlinks so we're stuck with \"insecure\" absolute paths there, for now at least.\r\n\r\nCute (but non-portable) trick: use paths of the form `/dev/fd/$FDNUM/something`.  Works at least on Linux.",
      "Yeah once we have the basics working and optimized to a reasonable degree we can start looking at utilizing various OS-specific extensions. The gotcha with those is to find ways to provide extra functionality in the specific OS'es *without* introducing multiple codepaths (which will inevitably bitrot) to accomplish the same thing.",
      "Anyway...\r\n\r\nThere will inevitably be bugs in this all, and since the test-suite covers only so much the best way to find the rest is real-world testing. And sitting in a branch does little to achieve that, so I'm merging this as is now.\r\n\r\nDanger Will Robinson, if you're in the habbit of running rpm daily snapshots then you'll want to stay alert for a while.",
      "Oh, and to make it absolutely clear: we're nowhere *near* done with this, I just want to get this bulk of change over with so we can concentrate with the finer nuances.",
      "@pmatilai  Thanks for fixing these CVEs.  And I want to double check with you that \r\ndoes these 32 commits in this pull request fully fix CVE-2021-35937, CVE-2021-35938, CVE-2021-35939? \r\nAny plan to porting it to 4.17.x branch?",
      "There will be no backports."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95"
}