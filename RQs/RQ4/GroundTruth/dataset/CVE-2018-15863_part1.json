{
  "cve_id": "CVE-2018-15863",
  "cwe_ids": [
    "CWE-476"
  ],
  "cvss_vector": "AV:L/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "xkbcommon/libxkbcommon",
  "commit_msg": "xkbcomp: Don't crash on no-op modmask expressions\n\nIf we have an expression of the form 'l1' in an interp section, we\nunconditionally try to dereference its args, even if it has none.\n\nSigned-off-by: Daniel Stone <daniels@collabora.com>",
  "commit_hash": "96df3106d49438e442510c59acad306e94f3db4d",
  "git_url": "https://github.com/xkbcommon/libxkbcommon/commit/96df3106d49438e442510c59acad306e94f3db4d",
  "file_path": "src/xkbcomp/compat.c",
  "func_name": "ResolveStateAndPredicate",
  "func_before": "static bool\nResolveStateAndPredicate(ExprDef *expr, enum xkb_match_operation *pred_rtrn,\n                         xkb_mod_mask_t *mods_rtrn, CompatInfo *info)\n{\n    if (expr == NULL) {\n        *pred_rtrn = MATCH_ANY_OR_NONE;\n        *mods_rtrn = MOD_REAL_MASK_ALL;\n        return true;\n    }\n\n    *pred_rtrn = MATCH_EXACTLY;\n    if (expr->expr.op == EXPR_ACTION_DECL) {\n        const char *pred_txt = xkb_atom_text(info->ctx, expr->action.name);\n        if (!LookupString(symInterpretMatchMaskNames, pred_txt, pred_rtrn)) {\n            log_err(info->ctx,\n                    \"Illegal modifier predicate \\\"%s\\\"; Ignored\\n\", pred_txt);\n            return false;\n        }\n        expr = expr->action.args;\n    }\n    else if (expr->expr.op == EXPR_IDENT) {\n        const char *pred_txt = xkb_atom_text(info->ctx, expr->ident.ident);\n        if (pred_txt && istreq(pred_txt, \"any\")) {\n            *pred_rtrn = MATCH_ANY;\n            *mods_rtrn = MOD_REAL_MASK_ALL;\n            return true;\n        }\n    }\n\n    return ExprResolveModMask(info->ctx, expr, MOD_REAL, &info->mods,\n                              mods_rtrn);\n}",
  "abstract_func_before": "static bool\nResolveStateAndPredicate(ExprDef *VAR_0, enum xkb_match_operation *VAR_1,\n                         xkb_mod_mask_t *VAR_2, CompatInfo *VAR_3)\n{\n    if (VAR_0 == NULL) {\n        *VAR_1 = VAR_4;\n        *VAR_2 = VAR_5;\n        return true;\n    }\n\n    *VAR_1 = VAR_6;\n    if (VAR_0->expr.op == VAR_7) {\n        const char *VAR_8 = xkb_atom_text(VAR_3->ctx, VAR_0->action.name);\n        if (!LookupString(VAR_9, VAR_8, VAR_1)) {\n            log_err(VAR_3->ctx,\n                    \"Illegal modifier predicate \\\"%s\\\"; Ignored\\n\", VAR_8);\n            return false;\n        }\n        VAR_0 = VAR_0->action.args;\n    }\n    else if (VAR_0->expr.op == VAR_10) {\n        const char *VAR_8 = xkb_atom_text(VAR_3->ctx, VAR_0->ident.ident);\n        if (VAR_8 && istreq(VAR_8, \"any\")) {\n            *VAR_1 = VAR_11;\n            *VAR_2 = VAR_5;\n            return true;\n        }\n    }\n\n    return ExprResolveModMask(VAR_3->ctx, VAR_0, VAR_12, &VAR_3->mods,\n                              VAR_2);\n}",
  "func_graph_path_before": "xkbcommon/libxkbcommon/96df3106d49438e442510c59acad306e94f3db4d/compat.c/vul/before/0.json",
  "func": "static bool\nResolveStateAndPredicate(ExprDef *expr, enum xkb_match_operation *pred_rtrn,\n                         xkb_mod_mask_t *mods_rtrn, CompatInfo *info)\n{\n    if (expr == NULL) {\n        *pred_rtrn = MATCH_ANY_OR_NONE;\n        *mods_rtrn = MOD_REAL_MASK_ALL;\n        return true;\n    }\n\n    *pred_rtrn = MATCH_EXACTLY;\n    if (expr->expr.op == EXPR_ACTION_DECL) {\n        const char *pred_txt = xkb_atom_text(info->ctx, expr->action.name);\n        if (!LookupString(symInterpretMatchMaskNames, pred_txt, pred_rtrn) ||\n            !expr->action.args) {\n            log_err(info->ctx,\n                    \"Illegal modifier predicate \\\"%s\\\"; Ignored\\n\", pred_txt);\n            return false;\n        }\n        expr = expr->action.args;\n    }\n    else if (expr->expr.op == EXPR_IDENT) {\n        const char *pred_txt = xkb_atom_text(info->ctx, expr->ident.ident);\n        if (pred_txt && istreq(pred_txt, \"any\")) {\n            *pred_rtrn = MATCH_ANY;\n            *mods_rtrn = MOD_REAL_MASK_ALL;\n            return true;\n        }\n    }\n\n    return ExprResolveModMask(info->ctx, expr, MOD_REAL, &info->mods,\n                              mods_rtrn);\n}",
  "abstract_func": "static bool\nResolveStateAndPredicate(ExprDef *VAR_0, enum xkb_match_operation *VAR_1,\n                         xkb_mod_mask_t *VAR_2, CompatInfo *VAR_3)\n{\n    if (VAR_0 == NULL) {\n        *VAR_1 = VAR_4;\n        *VAR_2 = VAR_5;\n        return true;\n    }\n\n    *VAR_1 = VAR_6;\n    if (VAR_0->expr.op == VAR_7) {\n        const char *VAR_8 = xkb_atom_text(VAR_3->ctx, VAR_0->action.name);\n        if (!LookupString(VAR_9, VAR_8, VAR_1) ||\n            !VAR_0->action.args) {\n            log_err(VAR_3->ctx,\n                    \"Illegal modifier predicate \\\"%s\\\"; Ignored\\n\", VAR_8);\n            return false;\n        }\n        VAR_0 = VAR_0->action.args;\n    }\n    else if (VAR_0->expr.op == VAR_10) {\n        const char *VAR_8 = xkb_atom_text(VAR_3->ctx, VAR_0->ident.ident);\n        if (VAR_8 && istreq(VAR_8, \"any\")) {\n            *VAR_1 = VAR_11;\n            *VAR_2 = VAR_5;\n            return true;\n        }\n    }\n\n    return ExprResolveModMask(VAR_3->ctx, VAR_0, VAR_12, &VAR_3->mods,\n                              VAR_2);\n}",
  "func_graph_path": "xkbcommon/libxkbcommon/96df3106d49438e442510c59acad306e94f3db4d/compat.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -11,7 +11,8 @@\n     *pred_rtrn = MATCH_EXACTLY;\n     if (expr->expr.op == EXPR_ACTION_DECL) {\n         const char *pred_txt = xkb_atom_text(info->ctx, expr->action.name);\n-        if (!LookupString(symInterpretMatchMaskNames, pred_txt, pred_rtrn)) {\n+        if (!LookupString(symInterpretMatchMaskNames, pred_txt, pred_rtrn) ||\n+            !expr->action.args) {\n             log_err(info->ctx,\n                     \"Illegal modifier predicate \\\"%s\\\"; Ignored\\n\", pred_txt);\n             return false;",
  "diff_line_info": {
    "deleted_lines": [
      "        if (!LookupString(symInterpretMatchMaskNames, pred_txt, pred_rtrn)) {"
    ],
    "added_lines": [
      "        if (!LookupString(symInterpretMatchMaskNames, pred_txt, pred_rtrn) ||",
      "            !expr->action.args) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/xkbcommon/libxkbcommon/pull/67",
  "description": {
    "pr_info": {
      "title": "Fix more fuzz-testing fallout",
      "number": 67
    },
    "comment": [
      "Most of this was found quite a while ago but got lost.",
      "Thanks! They all look good to me. I'll make another release with these soon."
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.8\n\nThe patch addresses a crash due to a null pointer dereference, which is a bug fix without explicit security references."
}