{
  "cve_id": "CVE-2023-50245",
  "cwe_ids": [
    "CWE-120"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "afichet/openexr-viewer",
  "commit_msg": "Early catch potential overflow issue #43\n\n`m_width` and `m_height` are of `int` type in the OpenEXR library. We\ncurrently keep the same types in our class but this may case issue\nwhen mapping 1D memory. In the most favorable case, they are\nmultiplied together (Y framebuffer). For RGB(A) case, the required\nmemory can also be 4 time larger. We check if resp. `m_width *\nm_height` and `4 * m_width * m_heigh` stay within the `int` higher\nlimit. Thanks to @GAP-dev for bringing this issue.\n\nThis commit also cleans a bit raw memory allocation in favor of\n`std::vector` container.",
  "commit_hash": "d0a7e85dfeb519951fb8a8d70f73f30d41cdd3d9",
  "git_url": "https://github.com/afichet/openexr-viewer/commit/d0a7e85dfeb519951fb8a8d70f73f30d41cdd3d9",
  "file_path": "src/model/framebuffer/RGBFramebufferModel.cpp",
  "func_name": "RGBFramebufferModel::load",
  "func_before": "void RGBFramebufferModel::load(\n  Imf::MultiPartInputFile& file, int partId, bool hasAlpha)\n{\n    QFuture<void> imageLoading = QtConcurrent::run([this,\n                                                    &file,\n                                                    partId,\n                                                    hasAlpha]() {\n        try {\n            Imf::InputPart part(file, partId);\n\n            Imath::Box2i datW = part.header().dataWindow();\n            m_width           = datW.max.x - datW.min.x + 1;\n            m_height          = datW.max.y - datW.min.y + 1;\n\n            m_pixelAspectRatio = part.header().pixelAspectRatio();\n\n            m_dataWindow = QRect(datW.min.x, datW.min.y, m_width, m_height);\n\n            Imath::Box2i dispW = part.header().displayWindow();\n\n            int dispW_width  = dispW.max.x - dispW.min.x + 1;\n            int dispW_height = dispW.max.y - dispW.min.y + 1;\n\n            m_displayWindow\n              = QRect(dispW.min.x, dispW.min.y, dispW_width, dispW_height);\n\n            // Check if there is specific chromaticities tied to the color\n            // representation in this part.\n            const Imf::ChromaticitiesAttribute* c\n              = part.header().findTypedAttribute<Imf::ChromaticitiesAttribute>(\n                \"chromaticities\");\n\n            Imf::Chromaticities chromaticities;\n\n            if (c != nullptr) {\n                chromaticities = c->value();\n            }\n\n            m_pixelBuffer = new float[4 * m_width * m_height];\n\n            // Check if there is alpha channel\n            if (hasAlpha) {\n                std::string      aLayer = m_parentLayer + \"A\";\n                Imf::FrameBuffer framebuffer;\n\n                Imf::Slice aSlice = Imf::Slice::Make(\n                  Imf::PixelType::FLOAT,\n                  &m_pixelBuffer[3],\n                  datW,\n                  4 * sizeof(float),\n                  4 * m_width * sizeof(float));\n\n                framebuffer.insert(aLayer, aSlice);\n\n                part.setFrameBuffer(framebuffer);\n                part.readPixels(datW.min.y, datW.max.y);\n\n            } else {\n                for (int y = 0; y < m_height; y++) {\n                    for (int x = 0; x < m_width; x++) {\n                        m_pixelBuffer[4 * (y * m_width + x) + 3] = 1.f;\n                    }\n                }\n            }\n\n            switch (m_layerType) {\n                case Layer_RGB: {\n                    std::string rLayer = m_parentLayer + \"R\";\n                    std::string gLayer = m_parentLayer + \"G\";\n                    std::string bLayer = m_parentLayer + \"B\";\n\n                    Imf::FrameBuffer framebuffer;\n\n                    Imf::Slice rSlice = Imf::Slice::Make(\n                      Imf::PixelType::FLOAT,\n                      &m_pixelBuffer[0],\n                      datW,\n                      4 * sizeof(float),\n                      4 * m_width * sizeof(float));\n\n                    Imf::Slice gSlice = Imf::Slice::Make(\n                      Imf::PixelType::FLOAT,\n                      &m_pixelBuffer[1],\n                      datW,\n                      4 * sizeof(float),\n                      4 * m_width * sizeof(float));\n\n                    Imf::Slice bSlice = Imf::Slice::Make(\n                      Imf::PixelType::FLOAT,\n                      &m_pixelBuffer[2],\n                      datW,\n                      4 * sizeof(float),\n                      4 * m_width * sizeof(float));\n\n                    framebuffer.insert(rLayer, rSlice);\n                    framebuffer.insert(gLayer, gSlice);\n                    framebuffer.insert(bLayer, bSlice);\n\n                    part.setFrameBuffer(framebuffer);\n                    part.readPixels(datW.min.y, datW.max.y);\n\n                    // Handle custom chromaticities\n                    Imath::M44f RGB_XYZ = Imf::RGBtoXYZ(chromaticities, 1.f);\n                    Imath::M44f XYZ_RGB\n                      = Imf::XYZtoRGB(Imf::Chromaticities(), 1.f);\n\n                    Imath::M44f conversionMatrix = RGB_XYZ * XYZ_RGB;\n\n                    #pragma omp parallel for\n                    for (int y = 0; y < m_height; y++) {\n                        for (int x = 0; x < m_width; x++) {\n                            const float r\n                              = m_pixelBuffer[4 * (y * m_width + x) + 0];\n                            const float g\n                              = m_pixelBuffer[4 * (y * m_width + x) + 1];\n                            const float b\n                              = m_pixelBuffer[4 * (y * m_width + x) + 2];\n\n                            Imath::V3f rgb(r, g, b);\n                            rgb *= conversionMatrix;\n\n                            m_pixelBuffer[4 * (y * m_width + x) + 0] = rgb.x;\n                            m_pixelBuffer[4 * (y * m_width + x) + 1] = rgb.y;\n                            m_pixelBuffer[4 * (y * m_width + x) + 2] = rgb.z;\n                        }\n                    }\n                } break;\n\n                case Layer_YC: {\n                    std::string yLayer  = m_parentLayer + \"Y\";\n                    std::string ryLayer = m_parentLayer + \"RY\";\n                    std::string byLayer = m_parentLayer + \"BY\";\n\n                    Imf::FrameBuffer framebuffer;\n\n                    Imf::Rgba* buff1 = new Imf::Rgba[m_width * m_height];\n                    Imf::Rgba* buff2 = new Imf::Rgba[m_width * m_height];\n\n                    float* yBuffer  = new float[m_width * m_height];\n                    float* ryBuffer = new float[m_width / 2 * m_height / 2];\n                    float* byBuffer = new float[m_width / 2 * m_height / 2];\n\n                    Imf::Slice ySlice = Imf::Slice::Make(\n                      Imf::PixelType::FLOAT,\n                      &yBuffer[0],\n                      datW,\n                      sizeof(float),\n                      m_width * sizeof(float));\n\n                    Imf::Slice rySlice = Imf::Slice::Make(\n                      Imf::PixelType::FLOAT,\n                      &ryBuffer[0],\n                      datW,\n                      sizeof(float),\n                      m_width / 2 * sizeof(float),\n                      2,\n                      2);\n\n                    Imf::Slice bySlice = Imf::Slice::Make(\n                      Imf::PixelType::FLOAT,\n                      &byBuffer[0],\n                      datW,\n                      sizeof(float),\n                      m_width / 2 * sizeof(float),\n                      2,\n                      2);\n\n                    framebuffer.insert(yLayer, ySlice);\n                    framebuffer.insert(ryLayer, rySlice);\n                    framebuffer.insert(byLayer, bySlice);\n\n                    part.setFrameBuffer(framebuffer);\n                    part.readPixels(datW.min.y, datW.max.y);\n\n                    // Filling missing values for chroma in the image\n                    // TODO: now, naive reconstruction.\n                    // Use later Imf::RgbaYca::reconstructChromaHoriz and\n                    // Imf::RgbaYca::reconstructChromaVert to reconstruct missing\n                    // pixels\n                    #pragma omp parallel for\n                    for (int y = 0; y < m_height; y++) {\n                        for (int x = 0; x < m_width; x++) {\n                            const float l = yBuffer[y * m_width + x];\n\n                            /*\n                            float ry = 0, by = 0;\n\n                            if (y % 2 == 0) {\n                                if (x % 2 == 0) {\n                                    ry = ryBuffer[y / 2 * m_width / 2 + x / 2];\n                                    by = byBuffer[y / 2 * m_width / 2 + x / 2];\n                                } else {\n                                    ry = .5 * (ryBuffer[y / 2 * m_width / 2 + x / 2] + ryBuffer[y / 2 * m_width / 2 + x / 2 + 1]);\n                                    by = .5 * (byBuffer[y / 2 * m_width / 2 + x / 2] + byBuffer[y / 2 * m_width / 2 + x / 2 + 1]);\n                                }\n                            } else {\n                                if (x % 2 == 0) {\n                                    ry = .5 * (ryBuffer[y / 2 * m_width / 2 + x / 2] + ryBuffer[(y / 2 + 1) * m_width / 2 + x / 2]);\n                                    by = .5 * (byBuffer[y / 2 * m_width / 2 + x / 2] + byBuffer[(y / 2 + 1) * m_width / 2 + x / 2]);\n                                } else {\n                                    ry = .25 * (ryBuffer[y / 2 * m_width / 2 + x / 2] + ryBuffer[(y / 2 + 1) * m_width / 2 + x / 2] + ryBuffer[y / 2 * m_width / 2 + x / 2 + 1] + ryBuffer[(y / 2 + 1) * m_width / 2 + x / 2 + 1]);\n                                    by = .25 * (byBuffer[y / 2 * m_width / 2 + x / 2] + byBuffer[(y / 2 + 1) * m_width / 2 + x / 2] + byBuffer[y / 2 * m_width / 2 + x / 2 + 1] + byBuffer[(y / 2 + 1) * m_width / 2 + x / 2 + 1]);\n                                }\n                            }\n                            */\n\n                            const float ry\n                              = ryBuffer[y / 2 * m_width / 2 + x / 2];\n                            const float by\n                              = byBuffer[y / 2 * m_width / 2 + x / 2];\n\n                            buff1[y * m_width + x].r = ry;\n                            buff1[y * m_width + x].g = l;\n                            buff1[y * m_width + x].b = by;\n                            // Do not forget the alpha values read earlier\n                            buff1[y * m_width + x].a\n                              = m_pixelBuffer[4 * (y * m_width + x) + 3];\n                        }\n                    }\n\n                    Imath::V3f yw = Imf::RgbaYca::computeYw(chromaticities);\n\n                    // Proceed to the YCA -> RGBA conversion\n                    #pragma omp parallel for\n                    for (int y = 0; y < m_height; y++) {\n                        Imf::RgbaYca::YCAtoRGBA(\n                          yw,\n                          m_width,\n                          &buff1[y * m_width],\n                          &buff1[y * m_width]);\n                    }\n\n                    // Fix over saturated pixels\n                    #pragma omp parallel for\n                    for (int y = 0; y < m_height; y++) {\n                        const Imf::Rgba* scanlines[3];\n\n                        if (y == 0) {\n                            scanlines[0] = &buff1[(y + 1) * m_width];\n                        } else {\n                            scanlines[0] = &buff1[(y - 1) * m_width];\n                        }\n\n                        scanlines[1] = &buff1[y * m_width];\n\n                        if (y == m_height - 1) {\n                            scanlines[2] = &buff1[(y - 1) * m_width];\n                        } else {\n                            scanlines[2] = &buff1[(y + 1) * m_width];\n                        }\n\n                        Imf::RgbaYca::fixSaturation(\n                          yw,\n                          m_width,\n                          scanlines,\n                          &buff2[y * m_width]);\n                    }\n\n                    // Handle custom chromaticities\n                    Imath::M44f RGB_XYZ = Imf::RGBtoXYZ(chromaticities, 1.f);\n                    Imath::M44f XYZ_RGB\n                      = Imf::XYZtoRGB(Imf::Chromaticities(), 1.f);\n\n                    Imath::M44f conversionMatrix = RGB_XYZ * XYZ_RGB;\n\n                    #pragma omp parallel for\n                    for (int y = 0; y < m_height; y++) {\n                        for (int x = 0; x < m_width; x++) {\n                            Imath::V3f rgb(\n                              buff2[y * m_width + x].r,\n                              buff2[y * m_width + x].g,\n                              buff2[y * m_width + x].b);\n\n                            rgb = rgb * conversionMatrix;\n\n                            m_pixelBuffer[4 * (y * m_width + x) + 0] = rgb.x;\n                            m_pixelBuffer[4 * (y * m_width + x) + 1] = rgb.y;\n                            m_pixelBuffer[4 * (y * m_width + x) + 2] = rgb.z;\n                        }\n                    }\n\n                    delete[] yBuffer;\n                    delete[] ryBuffer;\n                    delete[] byBuffer;\n                    delete[] buff1;\n                    delete[] buff2;\n                }\n\n                break;\n\n                case Layer_Y: {\n                    std::string yLayer = m_parentLayer;\n\n                    Imf::FrameBuffer framebuffer;\n\n                    Imf::Slice ySlice = Imf::Slice::Make(\n                      Imf::PixelType::FLOAT,\n                      &m_pixelBuffer[0],\n                      datW,\n                      4 * sizeof(float),\n                      4 * m_width * sizeof(float));\n\n                    framebuffer.insert(yLayer, ySlice);\n\n                    part.setFrameBuffer(framebuffer);\n                    part.readPixels(datW.min.y, datW.max.y);\n\n                    #pragma omp parallel for\n                    for (int i = 0; i < m_height * m_width; i++) {\n                        m_pixelBuffer[4 * i + 1] = m_pixelBuffer[4 * i + 0];\n                        m_pixelBuffer[4 * i + 2] = m_pixelBuffer[4 * i + 0];\n                        m_pixelBuffer[4 * i + 3] = 1.f;\n                    }\n                } break;\n            }\n\n            m_image = QImage(m_width, m_height, QImage::Format_RGBA8888);\n            m_isImageLoaded = true;\n\n            emit imageLoaded();\n\n            updateImage();\n        } catch (std::exception& e) {\n            emit loadFailed(e.what());\n            return;\n        }\n    });\n\n    m_imageLoadingWatcher->setFuture(imageLoading);\n}",
  "abstract_func_before": "void RGBFramebufferModel::load(\n  Imf::MultiPartInputFile& VAR_0, int VAR_1, bool VAR_2)\n{\n    QFuture<void> VAR_3 = QtConcurrent::run([this,\n                                                    &VAR_0,\n                                                    VAR_1,\n                                                    VAR_2]() {\n        try {\n            Imf::InputPart part(file, partId);\n\n            Imath::Box2i VAR_4 = VAR_5.header().dataWindow();\n            VAR_6           = VAR_4.max.x - VAR_4.min.x + 1;\n            VAR_7          = VAR_4.max.y - VAR_4.min.y + 1;\n\n            VAR_8 = VAR_5.header().pixelAspectRatio();\n\n            VAR_9 = QRect(VAR_4.min.x, VAR_4.min.y, VAR_6, VAR_7);\n\n            Imath::Box2i VAR_10 = VAR_5.header().displayWindow();\n\n            int VAR_11  = VAR_10.max.x - VAR_10.min.x + 1;\n            int VAR_12 = VAR_10.max.y - VAR_10.min.y + 1;\n\n            VAR_13\n              = QRect(VAR_10.min.x, VAR_10.min.y, VAR_11, VAR_12);\n\n            /* COMMENT_0 */\n            /* COMMENT_1 */\n            const Imf::ChromaticitiesAttribute* VAR_14\n              = VAR_5.header().findTypedAttribute<Imf::ChromaticitiesAttribute>(\n                \"chromaticities\");\n\n            Imf::Chromaticities VAR_15;\n\n            if (VAR_14 != nullptr) {\n                VAR_15 = VAR_14->value();\n            }\n\n            VAR_16 = new float[4 * VAR_6 * VAR_7];\n\n            /* COMMENT_2 */\n            if (VAR_2) {\n                std::string      VAR_17 = VAR_18 + \"A\";\n                Imf::FrameBuffer VAR_19;\n\n                Imf::Slice VAR_20 = Imf::Slice::Make(\n                  Imf::PixelType::FLOAT,\n                  &VAR_16[3],\n                  VAR_4,\n                  4 * sizeof(float),\n                  4 * VAR_6 * sizeof(float));\n\n                VAR_19.insert(VAR_17, VAR_20);\n\n                VAR_5.setFrameBuffer(VAR_19);\n                VAR_5.readPixels(VAR_4.min.y, VAR_4.max.y);\n\n            } else {\n                for (int VAR_21 = 0; VAR_21 < VAR_7; VAR_21++) {\n                    for (int VAR_22 = 0; VAR_22 < VAR_6; VAR_22++) {\n                        VAR_16[4 * (VAR_21 * VAR_6 + VAR_22) + 3] = 1.f;\n                    }\n                }\n            }\n\n            switch (VAR_23) {\n                case VAR_24: {\n                    std::string VAR_25 = VAR_18 + \"R\";\n                    std::string VAR_26 = VAR_18 + \"G\";\n                    std::string VAR_27 = VAR_18 + \"B\";\n\n                    Imf::FrameBuffer VAR_19;\n\n                    Imf::Slice VAR_28 = Imf::Slice::Make(\n                      Imf::PixelType::FLOAT,\n                      &VAR_16[0],\n                      VAR_4,\n                      4 * sizeof(float),\n                      4 * VAR_6 * sizeof(float));\n\n                    Imf::Slice VAR_29 = Imf::Slice::Make(\n                      Imf::PixelType::FLOAT,\n                      &VAR_16[1],\n                      VAR_4,\n                      4 * sizeof(float),\n                      4 * VAR_6 * sizeof(float));\n\n                    Imf::Slice VAR_30 = Imf::Slice::Make(\n                      Imf::PixelType::FLOAT,\n                      &VAR_16[2],\n                      VAR_4,\n                      4 * sizeof(float),\n                      4 * VAR_6 * sizeof(float));\n\n                    VAR_19.insert(VAR_25, VAR_28);\n                    VAR_19.insert(VAR_26, VAR_29);\n                    VAR_19.insert(VAR_27, VAR_30);\n\n                    VAR_5.setFrameBuffer(VAR_19);\n                    VAR_5.readPixels(VAR_4.min.y, VAR_4.max.y);\n\n                    /* COMMENT_3 */\n                    Imath::M44f VAR_31 = Imf::RGBtoXYZ(VAR_15, 1.f);\n                    Imath::M44f VAR_32\n                      = Imf::XYZtoRGB(Imf::Chromaticities(), 1.f);\n\n                    Imath::M44f VAR_33 = VAR_31 * VAR_32;\n\n                    #pragma omp parallel for\n                    for (int VAR_21 = 0; VAR_21 < VAR_7; VAR_21++) {\n                        for (int VAR_22 = 0; VAR_22 < VAR_6; VAR_22++) {\n                            const float VAR_34\n                              = VAR_16[4 * (VAR_21 * VAR_6 + VAR_22) + 0];\n                            const float VAR_35\n                              = VAR_16[4 * (VAR_21 * VAR_6 + VAR_22) + 1];\n                            const float VAR_36\n                              = VAR_16[4 * (VAR_21 * VAR_6 + VAR_22) + 2];\n\n                            Imath::V3f rgb(r, g, b);\n                            VAR_37 *= VAR_33;\n\n                            VAR_16[4 * (VAR_21 * VAR_6 + VAR_22) + 0] = VAR_37.x;\n                            VAR_16[4 * (VAR_21 * VAR_6 + VAR_22) + 1] = VAR_37.y;\n                            VAR_16[4 * (VAR_21 * VAR_6 + VAR_22) + 2] = VAR_37.z;\n                        }\n                    }\n                } break;\n\n                case VAR_38: {\n                    std::string VAR_39  = VAR_18 + \"Y\";\n                    std::string VAR_40 = VAR_18 + \"RY\";\n                    std::string VAR_41 = VAR_18 + \"BY\";\n\n                    Imf::FrameBuffer VAR_19;\n\n                    Imf::Rgba* VAR_42 = new Imf::Rgba[VAR_6 * VAR_7];\n                    Imf::Rgba* VAR_43 = new Imf::Rgba[VAR_6 * VAR_7];\n\n                    float* VAR_44  = new float[VAR_6 * VAR_7];\n                    float* VAR_45 = new float[VAR_6 / 2 * VAR_7 / 2];\n                    float* VAR_46 = new float[VAR_6 / 2 * VAR_7 / 2];\n\n                    Imf::Slice VAR_47 = Imf::Slice::Make(\n                      Imf::PixelType::FLOAT,\n                      &VAR_44[0],\n                      VAR_4,\n                      sizeof(float),\n                      VAR_6 * sizeof(float));\n\n                    Imf::Slice VAR_48 = Imf::Slice::Make(\n                      Imf::PixelType::FLOAT,\n                      &VAR_45[0],\n                      VAR_4,\n                      sizeof(float),\n                      VAR_6 / 2 * sizeof(float),\n                      2,\n                      2);\n\n                    Imf::Slice VAR_49 = Imf::Slice::Make(\n                      Imf::PixelType::FLOAT,\n                      &VAR_46[0],\n                      VAR_4,\n                      sizeof(float),\n                      VAR_6 / 2 * sizeof(float),\n                      2,\n                      2);\n\n                    VAR_19.insert(VAR_39, VAR_47);\n                    VAR_19.insert(VAR_40, VAR_48);\n                    VAR_19.insert(VAR_41, VAR_49);\n\n                    VAR_5.setFrameBuffer(VAR_19);\n                    VAR_5.readPixels(VAR_4.min.y, VAR_4.max.y);\n\n                    /* COMMENT_4 */\n                    /* COMMENT_5 */\n                    /* COMMENT_6 */\n                    /* COMMENT_7 */\n                    /* COMMENT_8 */\n                    #pragma omp parallel for\n                    for (int VAR_21 = 0; VAR_21 < VAR_7; VAR_21++) {\n                        for (int VAR_22 = 0; VAR_22 < VAR_6; VAR_22++) {\n                            const float VAR_50 = VAR_44[VAR_21 * VAR_6 + VAR_22];\n\n                            /* COMMENT_9 */\n                                                 \n\n                                             \n                                                 \n                                                                               \n                                                                               \n                                        \n                                                                                                                                  \n                                                                                                                                  \n                                 \n                                    \n                                                 \n                                                                                                                                    \n                                                                                                                                    \n                                        \n                                                                                                                                                                                                                                   \n                                                                                                                                                                                                                                   \n                                 \n                             \n                              \n\n                            const float VAR_51\n                              = VAR_45[VAR_21 / 2 * VAR_6 / 2 + VAR_22 / 2];\n                            const float VAR_52\n                              = VAR_46[VAR_21 / 2 * VAR_6 / 2 + VAR_22 / 2];\n\n                            VAR_42[VAR_21 * VAR_6 + VAR_22].r = VAR_51;\n                            VAR_42[VAR_21 * VAR_6 + VAR_22].g = VAR_50;\n                            VAR_42[VAR_21 * VAR_6 + VAR_22].b = VAR_52;\n                            /* COMMENT_27 */\n                            VAR_42[VAR_21 * VAR_6 + VAR_22].a\n                              = VAR_16[4 * (VAR_21 * VAR_6 + VAR_22) + 3];\n                        }\n                    }\n\n                    Imath::V3f VAR_53 = Imf::RgbaYca::computeYw(VAR_15);\n\n                    /* COMMENT_28 */\n                    #pragma omp parallel for\n                    for (int VAR_21 = 0; VAR_21 < VAR_7; VAR_21++) {\n                        Imf::RgbaYca::YCAtoRGBA(\n                          VAR_53,\n                          VAR_6,\n                          &VAR_42[VAR_21 * VAR_6],\n                          &VAR_42[VAR_21 * VAR_6]);\n                    }\n\n                    /* COMMENT_29 */\n                    #pragma omp parallel for\n                    for (int VAR_21 = 0; VAR_21 < VAR_7; VAR_21++) {\n                        const Imf::Rgba* VAR_54[3];\n\n                        if (VAR_21 == 0) {\n                            VAR_54[0] = &VAR_42[(VAR_21 + 1) * VAR_6];\n                        } else {\n                            VAR_54[0] = &VAR_42[(VAR_21 - 1) * VAR_6];\n                        }\n\n                        VAR_54[1] = &VAR_42[VAR_21 * VAR_6];\n\n                        if (VAR_21 == VAR_7 - 1) {\n                            VAR_54[2] = &VAR_42[(VAR_21 - 1) * VAR_6];\n                        } else {\n                            VAR_54[2] = &VAR_42[(VAR_21 + 1) * VAR_6];\n                        }\n\n                        Imf::RgbaYca::fixSaturation(\n                          VAR_53,\n                          VAR_6,\n                          VAR_54,\n                          &VAR_43[VAR_21 * VAR_6]);\n                    }\n\n                    /* COMMENT_3 */\n                    Imath::M44f VAR_31 = Imf::RGBtoXYZ(VAR_15, 1.f);\n                    Imath::M44f VAR_32\n                      = Imf::XYZtoRGB(Imf::Chromaticities(), 1.f);\n\n                    Imath::M44f VAR_33 = VAR_31 * VAR_32;\n\n                    #pragma omp parallel for\n                    for (int VAR_21 = 0; VAR_21 < VAR_7; VAR_21++) {\n                        for (int VAR_22 = 0; VAR_22 < VAR_6; VAR_22++) {\n                            Imath::V3f VAR_37(\n                              VAR_43[VAR_21 * VAR_6 + VAR_22].r,\n                              VAR_43[VAR_21 * VAR_6 + VAR_22].g,\n                              VAR_43[VAR_21 * VAR_6 + VAR_22].b);\n\n                            VAR_37 = VAR_37 * VAR_33;\n\n                            VAR_16[4 * (VAR_21 * VAR_6 + VAR_22) + 0] = VAR_37.x;\n                            VAR_16[4 * (VAR_21 * VAR_6 + VAR_22) + 1] = VAR_37.y;\n                            VAR_16[4 * (VAR_21 * VAR_6 + VAR_22) + 2] = VAR_37.z;\n                        }\n                    }\n\n                    delete[] VAR_44;\n                    delete[] VAR_45;\n                    delete[] VAR_46;\n                    delete[] VAR_42;\n                    delete[] VAR_43;\n                }\n\n                break;\n\n                case VAR_55: {\n                    std::string VAR_39 = VAR_18;\n\n                    Imf::FrameBuffer VAR_19;\n\n                    Imf::Slice VAR_47 = Imf::Slice::Make(\n                      Imf::PixelType::FLOAT,\n                      &VAR_16[0],\n                      VAR_4,\n                      4 * sizeof(float),\n                      4 * VAR_6 * sizeof(float));\n\n                    VAR_19.insert(VAR_39, VAR_47);\n\n                    VAR_5.setFrameBuffer(VAR_19);\n                    VAR_5.readPixels(VAR_4.min.y, VAR_4.max.y);\n\n                    #pragma omp parallel for\n                    for (int VAR_56 = 0; VAR_56 < VAR_7 * VAR_6; VAR_56++) {\n                        VAR_16[4 * VAR_56 + 1] = VAR_16[4 * VAR_56 + 0];\n                        VAR_16[4 * VAR_56 + 2] = VAR_16[4 * VAR_56 + 0];\n                        VAR_16[4 * VAR_56 + 3] = 1.f;\n                    }\n                } break;\n            }\n\n            VAR_57 = QImage(VAR_6, VAR_7, QImage::Format_RGBA8888);\n            VAR_58 = true;\n\n            emit imageLoaded();\n\n            updateImage();\n        } catch (std::exception& VAR_59) {\n            emit VAR_60(VAR_59.what());\n            return;\n        }\n    });\n\n    VAR_61->setFuture(VAR_3);\n}",
  "func_graph_path_before": "afichet/openexr-viewer/d0a7e85dfeb519951fb8a8d70f73f30d41cdd3d9/RGBFramebufferModel.cpp/vul/before/0.json",
  "func": "void RGBFramebufferModel::load(\n  Imf::MultiPartInputFile& file, int partId, bool hasAlpha)\n{\n    QFuture<void> imageLoading = QtConcurrent::run([this,\n                                                    &file,\n                                                    partId,\n                                                    hasAlpha]() {\n        try {\n            Imf::InputPart part(file, partId);\n\n            Imath::Box2i datW = part.header().dataWindow();\n            m_width           = datW.max.x - datW.min.x + 1;\n            m_height          = datW.max.y - datW.min.y + 1;\n\n            m_pixelAspectRatio = part.header().pixelAspectRatio();\n\n            m_dataWindow = QRect(datW.min.x, datW.min.y, m_width, m_height);\n\n            Imath::Box2i dispW = part.header().displayWindow();\n\n            int dispW_width  = dispW.max.x - dispW.min.x + 1;\n            int dispW_height = dispW.max.y - dispW.min.y + 1;\n\n            m_displayWindow\n              = QRect(dispW.min.x, dispW.min.y, dispW_width, dispW_height);\n\n            // Check to avoid type overflow, width and height are 32bits int\n            // representing a 2 dimentional image. Can overflow the type when\n            // multiplied together.\n            // 0x1FFFFFFF is a save limit for 4 * 0x7FFFFFFF the max\n            // representable int since we need 4 channels.\n            // TODO: Use larger type when manipulating framebuffer\n            const uint64_t partial_size\n              = (uint64_t)m_width * (uint64_t)m_height;\n\n            if (partial_size > 0x1FFFFFFF) {\n                throw std::runtime_error(\n                  \"The total image size is too large. May be supported in a \"\n                  \"future revision.\");\n            }\n\n            m_pixelBuffer.resize(4 * m_width * m_height);\n\n            // Check if there is specific chromaticities tied to the color\n            // representation in this part.\n            const Imf::ChromaticitiesAttribute* c\n              = part.header().findTypedAttribute<Imf::ChromaticitiesAttribute>(\n                \"chromaticities\");\n\n            Imf::Chromaticities chromaticities;\n\n            if (c != nullptr) {\n                chromaticities = c->value();\n            }\n\n            // Check if there is alpha channel\n            if (hasAlpha) {\n                std::string      aLayer = m_parentLayer + \"A\";\n                Imf::FrameBuffer framebuffer;\n\n                Imf::Slice aSlice = Imf::Slice::Make(\n                  Imf::PixelType::FLOAT,\n                  &m_pixelBuffer[3],\n                  datW,\n                  4 * sizeof(float),\n                  4 * m_width * sizeof(float));\n\n                framebuffer.insert(aLayer, aSlice);\n\n                part.setFrameBuffer(framebuffer);\n                part.readPixels(datW.min.y, datW.max.y);\n\n            } else {\n                for (int y = 0; y < m_height; y++) {\n                    for (int x = 0; x < m_width; x++) {\n                        m_pixelBuffer[4 * (y * m_width + x) + 3] = 1.f;\n                    }\n                }\n            }\n\n            switch (m_layerType) {\n                case Layer_RGB: {\n                    std::string rLayer = m_parentLayer + \"R\";\n                    std::string gLayer = m_parentLayer + \"G\";\n                    std::string bLayer = m_parentLayer + \"B\";\n\n                    Imf::FrameBuffer framebuffer;\n\n                    Imf::Slice rSlice = Imf::Slice::Make(\n                      Imf::PixelType::FLOAT,\n                      &m_pixelBuffer[0],\n                      datW,\n                      4 * sizeof(float),\n                      4 * m_width * sizeof(float));\n\n                    Imf::Slice gSlice = Imf::Slice::Make(\n                      Imf::PixelType::FLOAT,\n                      &m_pixelBuffer[1],\n                      datW,\n                      4 * sizeof(float),\n                      4 * m_width * sizeof(float));\n\n                    Imf::Slice bSlice = Imf::Slice::Make(\n                      Imf::PixelType::FLOAT,\n                      &m_pixelBuffer[2],\n                      datW,\n                      4 * sizeof(float),\n                      4 * m_width * sizeof(float));\n\n                    framebuffer.insert(rLayer, rSlice);\n                    framebuffer.insert(gLayer, gSlice);\n                    framebuffer.insert(bLayer, bSlice);\n\n                    part.setFrameBuffer(framebuffer);\n                    part.readPixels(datW.min.y, datW.max.y);\n\n                    // Handle custom chromaticities\n                    Imath::M44f RGB_XYZ = Imf::RGBtoXYZ(chromaticities, 1.f);\n                    Imath::M44f XYZ_RGB\n                      = Imf::XYZtoRGB(Imf::Chromaticities(), 1.f);\n\n                    Imath::M44f conversionMatrix = RGB_XYZ * XYZ_RGB;\n\n                    #pragma omp parallel for\n                    for (int y = 0; y < m_height; y++) {\n                        for (int x = 0; x < m_width; x++) {\n                            const float r\n                              = m_pixelBuffer[4 * (y * m_width + x) + 0];\n                            const float g\n                              = m_pixelBuffer[4 * (y * m_width + x) + 1];\n                            const float b\n                              = m_pixelBuffer[4 * (y * m_width + x) + 2];\n\n                            Imath::V3f rgb(r, g, b);\n                            rgb *= conversionMatrix;\n\n                            m_pixelBuffer[4 * (y * m_width + x) + 0] = rgb.x;\n                            m_pixelBuffer[4 * (y * m_width + x) + 1] = rgb.y;\n                            m_pixelBuffer[4 * (y * m_width + x) + 2] = rgb.z;\n                        }\n                    }\n                } break;\n\n                case Layer_YC: {\n                    std::string yLayer  = m_parentLayer + \"Y\";\n                    std::string ryLayer = m_parentLayer + \"RY\";\n                    std::string byLayer = m_parentLayer + \"BY\";\n\n                    Imf::FrameBuffer framebuffer;\n\n                    std::vector<Imf::Rgba> buff1(m_width * m_height);\n                    std::vector<Imf::Rgba> buff2(m_width * m_height);\n\n                    std::vector<float> yBuffer(m_width * m_height);\n                    std::vector<float> ryBuffer(m_width / 2 * m_height / 2);\n                    std::vector<float> byBuffer(m_width / 2 * m_height / 2);\n\n                    Imf::Slice ySlice = Imf::Slice::Make(\n                      Imf::PixelType::FLOAT,\n                      &yBuffer[0],\n                      datW,\n                      sizeof(float),\n                      m_width * sizeof(float));\n\n                    Imf::Slice rySlice = Imf::Slice::Make(\n                      Imf::PixelType::FLOAT,\n                      &ryBuffer[0],\n                      datW,\n                      sizeof(float),\n                      m_width / 2 * sizeof(float),\n                      2,\n                      2);\n\n                    Imf::Slice bySlice = Imf::Slice::Make(\n                      Imf::PixelType::FLOAT,\n                      &byBuffer[0],\n                      datW,\n                      sizeof(float),\n                      m_width / 2 * sizeof(float),\n                      2,\n                      2);\n\n                    framebuffer.insert(yLayer, ySlice);\n                    framebuffer.insert(ryLayer, rySlice);\n                    framebuffer.insert(byLayer, bySlice);\n\n                    part.setFrameBuffer(framebuffer);\n                    part.readPixels(datW.min.y, datW.max.y);\n\n                    // Filling missing values for chroma in the image\n                    // TODO: now, naive reconstruction.\n                    // Use later Imf::RgbaYca::reconstructChromaHoriz and\n                    // Imf::RgbaYca::reconstructChromaVert to reconstruct missing\n                    // pixels\n                    #pragma omp parallel for\n                    for (int y = 0; y < m_height; y++) {\n                        for (int x = 0; x < m_width; x++) {\n                            const float l = yBuffer[y * m_width + x];\n\n                            /*\n                            float ry = 0, by = 0;\n\n                            if (y % 2 == 0) {\n                                if (x % 2 == 0) {\n                                    ry = ryBuffer[y / 2 * m_width / 2 + x / 2];\n                                    by = byBuffer[y / 2 * m_width / 2 + x / 2];\n                                } else {\n                                    ry = .5 * (ryBuffer[y / 2 * m_width / 2 + x / 2] + ryBuffer[y / 2 * m_width / 2 + x / 2 + 1]);\n                                    by = .5 * (byBuffer[y / 2 * m_width / 2 + x / 2] + byBuffer[y / 2 * m_width / 2 + x / 2 + 1]);\n                                }\n                            } else {\n                                if (x % 2 == 0) {\n                                    ry = .5 * (ryBuffer[y / 2 * m_width / 2 + x / 2] + ryBuffer[(y / 2 + 1) * m_width / 2 + x / 2]);\n                                    by = .5 * (byBuffer[y / 2 * m_width / 2 + x / 2] + byBuffer[(y / 2 + 1) * m_width / 2 + x / 2]);\n                                } else {\n                                    ry = .25 * (ryBuffer[y / 2 * m_width / 2 + x / 2] + ryBuffer[(y / 2 + 1) * m_width / 2 + x / 2] + ryBuffer[y / 2 * m_width / 2 + x / 2 + 1] + ryBuffer[(y / 2 + 1) * m_width / 2 + x / 2 + 1]);\n                                    by = .25 * (byBuffer[y / 2 * m_width / 2 + x / 2] + byBuffer[(y / 2 + 1) * m_width / 2 + x / 2] + byBuffer[y / 2 * m_width / 2 + x / 2 + 1] + byBuffer[(y / 2 + 1) * m_width / 2 + x / 2 + 1]);\n                                }\n                            }\n                            */\n\n                            const float ry\n                              = ryBuffer[y / 2 * m_width / 2 + x / 2];\n                            const float by\n                              = byBuffer[y / 2 * m_width / 2 + x / 2];\n\n                            buff1[y * m_width + x].r = ry;\n                            buff1[y * m_width + x].g = l;\n                            buff1[y * m_width + x].b = by;\n                            // Do not forget the alpha values read earlier\n                            buff1[y * m_width + x].a\n                              = m_pixelBuffer[4 * (y * m_width + x) + 3];\n                        }\n                    }\n\n                    Imath::V3f yw = Imf::RgbaYca::computeYw(chromaticities);\n\n                    // Proceed to the YCA -> RGBA conversion\n                    #pragma omp parallel for\n                    for (int y = 0; y < m_height; y++) {\n                        Imf::RgbaYca::YCAtoRGBA(\n                          yw,\n                          m_width,\n                          &buff1[y * m_width],\n                          &buff1[y * m_width]);\n                    }\n\n                    // Fix over saturated pixels\n                    #pragma omp parallel for\n                    for (int y = 0; y < m_height; y++) {\n                        const Imf::Rgba* scanlines[3];\n\n                        if (y == 0) {\n                            scanlines[0] = &buff1[(y + 1) * m_width];\n                        } else {\n                            scanlines[0] = &buff1[(y - 1) * m_width];\n                        }\n\n                        scanlines[1] = &buff1[y * m_width];\n\n                        if (y == m_height - 1) {\n                            scanlines[2] = &buff1[(y - 1) * m_width];\n                        } else {\n                            scanlines[2] = &buff1[(y + 1) * m_width];\n                        }\n\n                        Imf::RgbaYca::fixSaturation(\n                          yw,\n                          m_width,\n                          scanlines,\n                          &buff2[y * m_width]);\n                    }\n\n                    // Handle custom chromaticities\n                    Imath::M44f RGB_XYZ = Imf::RGBtoXYZ(chromaticities, 1.f);\n                    Imath::M44f XYZ_RGB\n                      = Imf::XYZtoRGB(Imf::Chromaticities(), 1.f);\n\n                    Imath::M44f conversionMatrix = RGB_XYZ * XYZ_RGB;\n\n                    #pragma omp parallel for\n                    for (int y = 0; y < m_height; y++) {\n                        for (int x = 0; x < m_width; x++) {\n                            Imath::V3f rgb(\n                              buff2[y * m_width + x].r,\n                              buff2[y * m_width + x].g,\n                              buff2[y * m_width + x].b);\n\n                            rgb = rgb * conversionMatrix;\n\n                            m_pixelBuffer[4 * (y * m_width + x) + 0] = rgb.x;\n                            m_pixelBuffer[4 * (y * m_width + x) + 1] = rgb.y;\n                            m_pixelBuffer[4 * (y * m_width + x) + 2] = rgb.z;\n                        }\n                    }\n                }\n\n                break;\n\n                case Layer_Y: {\n                    std::string yLayer = m_parentLayer;\n\n                    Imf::FrameBuffer framebuffer;\n\n                    Imf::Slice ySlice = Imf::Slice::Make(\n                      Imf::PixelType::FLOAT,\n                      &m_pixelBuffer[0],\n                      datW,\n                      4 * sizeof(float),\n                      4 * m_width * sizeof(float));\n\n                    framebuffer.insert(yLayer, ySlice);\n\n                    part.setFrameBuffer(framebuffer);\n                    part.readPixels(datW.min.y, datW.max.y);\n\n                    #pragma omp parallel for\n                    for (int i = 0; i < m_height * m_width; i++) {\n                        m_pixelBuffer[4 * i + 1] = m_pixelBuffer[4 * i + 0];\n                        m_pixelBuffer[4 * i + 2] = m_pixelBuffer[4 * i + 0];\n                        m_pixelBuffer[4 * i + 3] = 1.f;\n                    }\n                } break;\n            }\n\n            m_image = QImage(m_width, m_height, QImage::Format_RGBA8888);\n            m_isImageLoaded = true;\n\n            emit imageLoaded();\n\n            updateImage();\n        } catch (std::exception& e) {\n            emit loadFailed(e.what());\n            return;\n        }\n    });\n\n    m_imageLoadingWatcher->setFuture(imageLoading);\n}",
  "abstract_func": "void RGBFramebufferModel::load(\n  Imf::MultiPartInputFile& VAR_0, int VAR_1, bool VAR_2)\n{\n    QFuture<void> VAR_3 = QtConcurrent::run([this,\n                                                    &VAR_0,\n                                                    VAR_1,\n                                                    VAR_2]() {\n        try {\n            Imf::InputPart part(file, partId);\n\n            Imath::Box2i VAR_4 = VAR_5.header().dataWindow();\n            VAR_6           = VAR_4.max.x - VAR_4.min.x + 1;\n            VAR_7          = VAR_4.max.y - VAR_4.min.y + 1;\n\n            VAR_8 = VAR_5.header().pixelAspectRatio();\n\n            VAR_9 = QRect(VAR_4.min.x, VAR_4.min.y, VAR_6, VAR_7);\n\n            Imath::Box2i VAR_10 = VAR_5.header().displayWindow();\n\n            int VAR_11  = VAR_10.max.x - VAR_10.min.x + 1;\n            int VAR_12 = VAR_10.max.y - VAR_10.min.y + 1;\n\n            VAR_13\n              = QRect(VAR_10.min.x, VAR_10.min.y, VAR_11, VAR_12);\n\n            /* COMMENT_0 */\n            /* COMMENT_1 */\n            /* COMMENT_2 */\n            /* COMMENT_3 */\n            /* COMMENT_4 */\n            /* COMMENT_5 */\n            const uint64_t VAR_14\n              = (uint64_t)VAR_6 * (uint64_t)VAR_7;\n\n            if (VAR_14 > 0x1FFFFFFF) {\n                throw std::runtime_error(\n                  \"The total image size is too large. May be supported in a \"\n                  \"future revision.\");\n            }\n\n            VAR_15.resize(4 * VAR_6 * VAR_7);\n\n            /* COMMENT_6 */\n            /* COMMENT_7 */\n            const Imf::ChromaticitiesAttribute* VAR_16\n              = VAR_5.header().findTypedAttribute<Imf::ChromaticitiesAttribute>(\n                \"chromaticities\");\n\n            Imf::Chromaticities VAR_17;\n\n            if (VAR_16 != nullptr) {\n                VAR_17 = VAR_16->value();\n            }\n\n            /* COMMENT_8 */\n            if (VAR_2) {\n                std::string      VAR_18 = VAR_19 + \"A\";\n                Imf::FrameBuffer VAR_20;\n\n                Imf::Slice VAR_21 = Imf::Slice::Make(\n                  Imf::PixelType::FLOAT,\n                  &VAR_15[3],\n                  VAR_4,\n                  4 * sizeof(float),\n                  4 * VAR_6 * sizeof(float));\n\n                VAR_20.insert(VAR_18, VAR_21);\n\n                VAR_5.setFrameBuffer(VAR_20);\n                VAR_5.readPixels(VAR_4.min.y, VAR_4.max.y);\n\n            } else {\n                for (int VAR_22 = 0; VAR_22 < VAR_7; VAR_22++) {\n                    for (int VAR_23 = 0; VAR_23 < VAR_6; VAR_23++) {\n                        VAR_15[4 * (VAR_22 * VAR_6 + VAR_23) + 3] = 1.f;\n                    }\n                }\n            }\n\n            switch (VAR_24) {\n                case VAR_25: {\n                    std::string VAR_26 = VAR_19 + \"R\";\n                    std::string VAR_27 = VAR_19 + \"G\";\n                    std::string VAR_28 = VAR_19 + \"B\";\n\n                    Imf::FrameBuffer VAR_20;\n\n                    Imf::Slice VAR_29 = Imf::Slice::Make(\n                      Imf::PixelType::FLOAT,\n                      &VAR_15[0],\n                      VAR_4,\n                      4 * sizeof(float),\n                      4 * VAR_6 * sizeof(float));\n\n                    Imf::Slice VAR_30 = Imf::Slice::Make(\n                      Imf::PixelType::FLOAT,\n                      &VAR_15[1],\n                      VAR_4,\n                      4 * sizeof(float),\n                      4 * VAR_6 * sizeof(float));\n\n                    Imf::Slice VAR_31 = Imf::Slice::Make(\n                      Imf::PixelType::FLOAT,\n                      &VAR_15[2],\n                      VAR_4,\n                      4 * sizeof(float),\n                      4 * VAR_6 * sizeof(float));\n\n                    VAR_20.insert(VAR_26, VAR_29);\n                    VAR_20.insert(VAR_27, VAR_30);\n                    VAR_20.insert(VAR_28, VAR_31);\n\n                    VAR_5.setFrameBuffer(VAR_20);\n                    VAR_5.readPixels(VAR_4.min.y, VAR_4.max.y);\n\n                    /* COMMENT_9 */\n                    Imath::M44f VAR_32 = Imf::RGBtoXYZ(VAR_17, 1.f);\n                    Imath::M44f VAR_33\n                      = Imf::XYZtoRGB(Imf::Chromaticities(), 1.f);\n\n                    Imath::M44f VAR_34 = VAR_32 * VAR_33;\n\n                    #pragma omp parallel for\n                    for (int VAR_22 = 0; VAR_22 < VAR_7; VAR_22++) {\n                        for (int VAR_23 = 0; VAR_23 < VAR_6; VAR_23++) {\n                            const float VAR_35\n                              = VAR_15[4 * (VAR_22 * VAR_6 + VAR_23) + 0];\n                            const float VAR_36\n                              = VAR_15[4 * (VAR_22 * VAR_6 + VAR_23) + 1];\n                            const float VAR_37\n                              = VAR_15[4 * (VAR_22 * VAR_6 + VAR_23) + 2];\n\n                            Imath::V3f rgb(r, g, b);\n                            VAR_38 *= VAR_34;\n\n                            VAR_15[4 * (VAR_22 * VAR_6 + VAR_23) + 0] = VAR_38.x;\n                            VAR_15[4 * (VAR_22 * VAR_6 + VAR_23) + 1] = VAR_38.y;\n                            VAR_15[4 * (VAR_22 * VAR_6 + VAR_23) + 2] = VAR_38.z;\n                        }\n                    }\n                } break;\n\n                case VAR_39: {\n                    std::string VAR_40  = VAR_19 + \"Y\";\n                    std::string VAR_41 = VAR_19 + \"RY\";\n                    std::string VAR_42 = VAR_19 + \"BY\";\n\n                    Imf::FrameBuffer VAR_20;\n\n                    std::vector<Imf::Rgba> buff1(m_width * VAR_7);\n                    std::vector<Imf::Rgba> buff2(m_width * VAR_7);\n\n                    std::vector<float> yBuffer(m_width * VAR_7);\n                    std::vector<float> VAR_43(m_width / 2 * VAR_7 / 2);\n                    std::vector<float> VAR_44(m_width / 2 * VAR_7 / 2);\n\n                    Imf::Slice VAR_45 = Imf::Slice::Make(\n                      Imf::PixelType::FLOAT,\n                      &VAR_46[0],\n                      VAR_4,\n                      sizeof(float),\n                      m_width * sizeof(float));\n\n                    Imf::Slice VAR_47 = Imf::Slice::Make(\n                      Imf::PixelType::FLOAT,\n                      &VAR_43[0],\n                      VAR_4,\n                      sizeof(float),\n                      m_width / 2 * sizeof(float),\n                      2,\n                      2);\n\n                    Imf::Slice VAR_48 = Imf::Slice::Make(\n                      Imf::PixelType::FLOAT,\n                      &VAR_44[0],\n                      VAR_4,\n                      sizeof(float),\n                      m_width / 2 * sizeof(float),\n                      2,\n                      2);\n\n                    VAR_20.insert(VAR_40, VAR_45);\n                    VAR_20.insert(VAR_41, VAR_47);\n                    VAR_20.insert(VAR_42, VAR_48);\n\n                    VAR_5.setFrameBuffer(VAR_20);\n                    VAR_5.readPixels(VAR_4.min.y, VAR_4.max.y);\n\n                    /* COMMENT_10 */\n                    /* COMMENT_11 */\n                    /* COMMENT_12 */\n                    /* COMMENT_13 */\n                    /* COMMENT_14 */\n                    #pragma omp parallel for\n                    for (int VAR_22 = 0; VAR_22 < VAR_7; VAR_22++) {\n                        for (int VAR_23 = 0; VAR_23 < m_width; VAR_23++) {\n                            const float VAR_49 = VAR_46[VAR_22 * m_width + VAR_23];\n\n                            /* COMMENT_15 */\n                                                 \n\n                                             \n                                                 \n                                                                               \n                                                                               \n                                        \n                                                                                                                                  \n                                                                                                                                  \n                                 \n                                    \n                                                 \n                                                                                                                                    \n                                                                                                                                    \n                                        \n                                                                                                                                                                                                                                   \n                                                                                                                                                                                                                                   \n                                 \n                             \n                              \n\n                            const float VAR_50\n                              = VAR_43[VAR_22 / 2 * m_width / 2 + VAR_23 / 2];\n                            const float VAR_51\n                              = VAR_44[VAR_22 / 2 * m_width / 2 + VAR_23 / 2];\n\n                            VAR_52[VAR_22 * m_width + VAR_23].r = VAR_50;\n                            VAR_52[VAR_22 * m_width + VAR_23].g = VAR_49;\n                            VAR_52[VAR_22 * m_width + VAR_23].b = VAR_51;\n                            /* COMMENT_33 */\n                            VAR_52[VAR_22 * m_width + VAR_23].a\n                              = VAR_15[4 * (VAR_22 * m_width + VAR_23) + 3];\n                        }\n                    }\n\n                    Imath::V3f VAR_53 = Imf::RgbaYca::computeYw(VAR_17);\n\n                    /* COMMENT_34 */\n                    #pragma omp parallel for\n                    for (int VAR_22 = 0; VAR_22 < VAR_7; VAR_22++) {\n                        Imf::RgbaYca::YCAtoRGBA(\n                          VAR_53,\n                          m_width,\n                          &VAR_52[VAR_22 * m_width],\n                          &VAR_52[VAR_22 * m_width]);\n                    }\n\n                    /* COMMENT_35 */\n                    #pragma omp parallel for\n                    for (int VAR_22 = 0; VAR_22 < VAR_7; VAR_22++) {\n                        const Imf::Rgba* VAR_54[3];\n\n                        if (VAR_22 == 0) {\n                            VAR_54[0] = &VAR_52[(VAR_22 + 1) * m_width];\n                        } else {\n                            VAR_54[0] = &VAR_52[(VAR_22 - 1) * m_width];\n                        }\n\n                        VAR_54[1] = &VAR_52[VAR_22 * m_width];\n\n                        if (VAR_22 == VAR_7 - 1) {\n                            VAR_54[2] = &VAR_52[(VAR_22 - 1) * m_width];\n                        } else {\n                            VAR_54[2] = &VAR_52[(VAR_22 + 1) * m_width];\n                        }\n\n                        Imf::RgbaYca::fixSaturation(\n                          VAR_53,\n                          m_width,\n                          VAR_54,\n                          &VAR_55[VAR_22 * m_width]);\n                    }\n\n                    /* COMMENT_9 */\n                    Imath::M44f VAR_32 = Imf::RGBtoXYZ(VAR_17, 1.f);\n                    Imath::M44f VAR_33\n                      = Imf::XYZtoRGB(Imf::Chromaticities(), 1.f);\n\n                    Imath::M44f VAR_34 = VAR_32 * VAR_33;\n\n                    #pragma omp parallel for\n                    for (int VAR_22 = 0; VAR_22 < VAR_7; VAR_22++) {\n                        for (int VAR_23 = 0; VAR_23 < m_width; VAR_23++) {\n                            Imath::V3f VAR_38(\n                              VAR_55[VAR_22 * m_width + VAR_23].r,\n                              VAR_55[VAR_22 * m_width + VAR_23].g,\n                              VAR_55[VAR_22 * m_width + VAR_23].b);\n\n                            VAR_38 = VAR_38 * VAR_34;\n\n                            VAR_15[4 * (VAR_22 * m_width + VAR_23) + 0] = VAR_38.x;\n                            VAR_15[4 * (VAR_22 * m_width + VAR_23) + 1] = VAR_38.y;\n                            VAR_15[4 * (VAR_22 * m_width + VAR_23) + 2] = VAR_38.z;\n                        }\n                    }\n                }\n\n                break;\n\n                case VAR_56: {\n                    std::string VAR_40 = VAR_19;\n\n                    Imf::FrameBuffer VAR_20;\n\n                    Imf::Slice VAR_45 = Imf::Slice::Make(\n                      Imf::PixelType::FLOAT,\n                      &VAR_15[0],\n                      VAR_4,\n                      4 * sizeof(float),\n                      4 * m_width * sizeof(float));\n\n                    VAR_20.insert(VAR_40, VAR_45);\n\n                    VAR_5.setFrameBuffer(VAR_20);\n                    VAR_5.readPixels(VAR_4.min.y, VAR_4.max.y);\n\n                    #pragma omp parallel for\n                    for (int VAR_57 = 0; VAR_57 < VAR_7 * m_width; VAR_57++) {\n                        VAR_15[4 * VAR_57 + 1] = VAR_15[4 * VAR_57 + 0];\n                        VAR_15[4 * VAR_57 + 2] = VAR_15[4 * VAR_57 + 0];\n                        VAR_15[4 * VAR_57 + 3] = 1.f;\n                    }\n                } break;\n            }\n\n            VAR_58 = QImage(m_width, VAR_7, QImage::Format_RGBA8888);\n            VAR_59 = true;\n\n            emit imageLoaded();\n\n            updateImage();\n        } catch (std::exception& VAR_60) {\n            emit VAR_61(VAR_60.what());\n            return;\n        }\n    });\n\n    VAR_62->setFuture(VAR_3);\n}",
  "func_graph_path": "afichet/openexr-viewer/d0a7e85dfeb519951fb8a8d70f73f30d41cdd3d9/RGBFramebufferModel.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -24,6 +24,23 @@\n             m_displayWindow\n               = QRect(dispW.min.x, dispW.min.y, dispW_width, dispW_height);\n \n+            // Check to avoid type overflow, width and height are 32bits int\n+            // representing a 2 dimentional image. Can overflow the type when\n+            // multiplied together.\n+            // 0x1FFFFFFF is a save limit for 4 * 0x7FFFFFFF the max\n+            // representable int since we need 4 channels.\n+            // TODO: Use larger type when manipulating framebuffer\n+            const uint64_t partial_size\n+              = (uint64_t)m_width * (uint64_t)m_height;\n+\n+            if (partial_size > 0x1FFFFFFF) {\n+                throw std::runtime_error(\n+                  \"The total image size is too large. May be supported in a \"\n+                  \"future revision.\");\n+            }\n+\n+            m_pixelBuffer.resize(4 * m_width * m_height);\n+\n             // Check if there is specific chromaticities tied to the color\n             // representation in this part.\n             const Imf::ChromaticitiesAttribute* c\n@@ -35,8 +52,6 @@\n             if (c != nullptr) {\n                 chromaticities = c->value();\n             }\n-\n-            m_pixelBuffer = new float[4 * m_width * m_height];\n \n             // Check if there is alpha channel\n             if (hasAlpha) {\n@@ -133,12 +148,12 @@\n \n                     Imf::FrameBuffer framebuffer;\n \n-                    Imf::Rgba* buff1 = new Imf::Rgba[m_width * m_height];\n-                    Imf::Rgba* buff2 = new Imf::Rgba[m_width * m_height];\n-\n-                    float* yBuffer  = new float[m_width * m_height];\n-                    float* ryBuffer = new float[m_width / 2 * m_height / 2];\n-                    float* byBuffer = new float[m_width / 2 * m_height / 2];\n+                    std::vector<Imf::Rgba> buff1(m_width * m_height);\n+                    std::vector<Imf::Rgba> buff2(m_width * m_height);\n+\n+                    std::vector<float> yBuffer(m_width * m_height);\n+                    std::vector<float> ryBuffer(m_width / 2 * m_height / 2);\n+                    std::vector<float> byBuffer(m_width / 2 * m_height / 2);\n \n                     Imf::Slice ySlice = Imf::Slice::Make(\n                       Imf::PixelType::FLOAT,\n@@ -278,12 +293,6 @@\n                             m_pixelBuffer[4 * (y * m_width + x) + 2] = rgb.z;\n                         }\n                     }\n-\n-                    delete[] yBuffer;\n-                    delete[] ryBuffer;\n-                    delete[] byBuffer;\n-                    delete[] buff1;\n-                    delete[] buff2;\n                 }\n \n                 break;",
  "diff_line_info": {
    "deleted_lines": [
      "",
      "            m_pixelBuffer = new float[4 * m_width * m_height];",
      "                    Imf::Rgba* buff1 = new Imf::Rgba[m_width * m_height];",
      "                    Imf::Rgba* buff2 = new Imf::Rgba[m_width * m_height];",
      "",
      "                    float* yBuffer  = new float[m_width * m_height];",
      "                    float* ryBuffer = new float[m_width / 2 * m_height / 2];",
      "                    float* byBuffer = new float[m_width / 2 * m_height / 2];",
      "",
      "                    delete[] yBuffer;",
      "                    delete[] ryBuffer;",
      "                    delete[] byBuffer;",
      "                    delete[] buff1;",
      "                    delete[] buff2;"
    ],
    "added_lines": [
      "            // Check to avoid type overflow, width and height are 32bits int",
      "            // representing a 2 dimentional image. Can overflow the type when",
      "            // multiplied together.",
      "            // 0x1FFFFFFF is a save limit for 4 * 0x7FFFFFFF the max",
      "            // representable int since we need 4 channels.",
      "            // TODO: Use larger type when manipulating framebuffer",
      "            const uint64_t partial_size",
      "              = (uint64_t)m_width * (uint64_t)m_height;",
      "",
      "            if (partial_size > 0x1FFFFFFF) {",
      "                throw std::runtime_error(",
      "                  \"The total image size is too large. May be supported in a \"",
      "                  \"future revision.\");",
      "            }",
      "",
      "            m_pixelBuffer.resize(4 * m_width * m_height);",
      "",
      "                    std::vector<Imf::Rgba> buff1(m_width * m_height);",
      "                    std::vector<Imf::Rgba> buff2(m_width * m_height);",
      "",
      "                    std::vector<float> yBuffer(m_width * m_height);",
      "                    std::vector<float> ryBuffer(m_width / 2 * m_height / 2);",
      "                    std::vector<float> byBuffer(m_width / 2 * m_height / 2);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/afichet/openexr-viewer/pull/44",
  "description": {
    "pr_info": {
      "title": "Fix segfault",
      "number": 44
    },
    "comment": [
      "When the total memory required to store the whole image exceeds the upper int limit, in many places, there is memory violation #43.\r\n\r\nThis PR prevent this issue by performing an early check on the required memory size prior to allocation and access. Future revision shall handle such files by using larger types."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.9"
}