{
  "cve_id": "CVE-2016-10129",
  "cwe_ids": [
    "CWE-476"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "libgit2",
  "commit_msg": "smart_pkt: treat empty packet lines as error\n\nThe Git protocol does not specify what should happen in the case\nof an empty packet line (that is a packet line \"0004\"). We\ncurrently indicate success, but do not return a packet in the\ncase where we hit an empty line. The smart protocol was not\nprepared to handle such packets in all cases, though, resulting\nin a `NULL` pointer dereference.\n\nFix the issue by returning an error instead. As such kind of\npackets is not even specified by upstream, this is the right\nthing to do.",
  "commit_hash": "2fdef641fd0dd2828bd948234ae86de75221a11a",
  "git_url": "https://github.com/libgit2/libgit2/commit/2fdef641fd0dd2828bd948234ae86de75221a11a",
  "file_path": "src/transports/smart_protocol.c",
  "func_name": "add_push_report_sideband_pkt",
  "func_before": "static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *data_pkt_buf)\n{\n\tgit_pkt *pkt;\n\tconst char *line, *line_end = NULL;\n\tsize_t line_len;\n\tint error;\n\tint reading_from_buf = data_pkt_buf->size > 0;\n\n\tif (reading_from_buf) {\n\t\t/* We had an existing partial packet, so add the new\n\t\t * packet to the buffer and parse the whole thing */\n\t\tgit_buf_put(data_pkt_buf, data_pkt->data, data_pkt->len);\n\t\tline = data_pkt_buf->ptr;\n\t\tline_len = data_pkt_buf->size;\n\t}\n\telse {\n\t\tline = data_pkt->data;\n\t\tline_len = data_pkt->len;\n\t}\n\n\twhile (line_len > 0) {\n\t\terror = git_pkt_parse_line(&pkt, line, &line_end, line_len);\n\n\t\tif (error == GIT_EBUFS) {\n\t\t\t/* Buffer the data when the inner packet is split\n\t\t\t * across multiple sideband packets */\n\t\t\tif (!reading_from_buf)\n\t\t\t\tgit_buf_put(data_pkt_buf, line, line_len);\n\t\t\terror = 0;\n\t\t\tgoto done;\n\t\t}\n\t\telse if (error < 0)\n\t\t\tgoto done;\n\n\t\t/* Advance in the buffer */\n\t\tline_len -= (line_end - line);\n\t\tline = line_end;\n\n\t\t/* When a valid packet with no content has been\n\t\t * read, git_pkt_parse_line does not report an\n\t\t * error, but the pkt pointer has not been set.\n\t\t * Handle this by skipping over empty packets.\n\t\t */\n\t\tif (pkt == NULL)\n\t\t\tcontinue;\n\n\t\terror = add_push_report_pkt(push, pkt);\n\n\t\tgit_pkt_free(pkt);\n\n\t\tif (error < 0 && error != GIT_ITEROVER)\n\t\t\tgoto done;\n\t}\n\n\terror = 0;\n\ndone:\n\tif (reading_from_buf)\n\t\tgit_buf_consume(data_pkt_buf, line_end);\n\treturn error;\n}",
  "abstract_func_before": "static int add_push_report_sideband_pkt(git_push *VAR_0, git_pkt_data *VAR_1, git_buf *VAR_2)\n{\n\tgit_pkt *VAR_3;\n\tconst char *VAR_4, *VAR_5 = NULL;\n\tsize_t VAR_6;\n\tint VAR_7;\n\tint VAR_8 = VAR_2->size > 0;\n\n\tif (VAR_8) {\n\t\t/* COMMENT_0 */\n                                                      \n\t\tgit_buf_put(VAR_2, VAR_1->data, VAR_1->len);\n\t\tVAR_4 = VAR_2->ptr;\n\t\tVAR_6 = VAR_2->size;\n\t}\n\telse {\n\t\tVAR_4 = VAR_1->data;\n\t\tVAR_6 = VAR_1->len;\n\t}\n\n\twhile (VAR_6 > 0) {\n\t\tVAR_7 = git_pkt_parse_line(&VAR_3, VAR_4, &VAR_5, VAR_6);\n\n\t\tif (VAR_7 == VAR_9) {\n\t\t\t/* COMMENT_2 */\n                                         \n\t\t\tif (!VAR_8)\n\t\t\t\tgit_buf_put(VAR_2, VAR_4, VAR_6);\n\t\t\tVAR_7 = 0;\n\t\t\tgoto done;\n\t\t}\n\t\telse if (VAR_7 < 0)\n\t\t\tgoto done;\n\n\t\t/* COMMENT_4 */\n\t\tVAR_6 -= (VAR_5 - VAR_4);\n\t\tVAR_4 = VAR_5;\n\n\t\t/* COMMENT_5 */\n                                                \n                                                 \n                                                \n     \n\t\tif (VAR_3 == NULL)\n\t\t\tcontinue;\n\n\t\tVAR_7 = add_push_report_pkt(VAR_0, VAR_3);\n\n\t\tgit_pkt_free(VAR_3);\n\n\t\tif (VAR_7 < 0 && VAR_7 != VAR_10)\n\t\t\tgoto done;\n\t}\n\n\tVAR_7 = 0;\n\ndone:\n\tif (VAR_8)\n\t\tgit_buf_consume(VAR_2, VAR_5);\n\treturn VAR_7;\n}",
  "func_graph_path_before": "libgit2/2fdef641fd0dd2828bd948234ae86de75221a11a/smart_protocol.c/vul/before/1.json",
  "func": "static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *data_pkt_buf)\n{\n\tgit_pkt *pkt;\n\tconst char *line, *line_end = NULL;\n\tsize_t line_len;\n\tint error;\n\tint reading_from_buf = data_pkt_buf->size > 0;\n\n\tif (reading_from_buf) {\n\t\t/* We had an existing partial packet, so add the new\n\t\t * packet to the buffer and parse the whole thing */\n\t\tgit_buf_put(data_pkt_buf, data_pkt->data, data_pkt->len);\n\t\tline = data_pkt_buf->ptr;\n\t\tline_len = data_pkt_buf->size;\n\t}\n\telse {\n\t\tline = data_pkt->data;\n\t\tline_len = data_pkt->len;\n\t}\n\n\twhile (line_len > 0) {\n\t\terror = git_pkt_parse_line(&pkt, line, &line_end, line_len);\n\n\t\tif (error == GIT_EBUFS) {\n\t\t\t/* Buffer the data when the inner packet is split\n\t\t\t * across multiple sideband packets */\n\t\t\tif (!reading_from_buf)\n\t\t\t\tgit_buf_put(data_pkt_buf, line, line_len);\n\t\t\terror = 0;\n\t\t\tgoto done;\n\t\t}\n\t\telse if (error < 0)\n\t\t\tgoto done;\n\n\t\t/* Advance in the buffer */\n\t\tline_len -= (line_end - line);\n\t\tline = line_end;\n\n\t\terror = add_push_report_pkt(push, pkt);\n\n\t\tgit_pkt_free(pkt);\n\n\t\tif (error < 0 && error != GIT_ITEROVER)\n\t\t\tgoto done;\n\t}\n\n\terror = 0;\n\ndone:\n\tif (reading_from_buf)\n\t\tgit_buf_consume(data_pkt_buf, line_end);\n\treturn error;\n}",
  "abstract_func": "static int add_push_report_sideband_pkt(git_push *VAR_0, git_pkt_data *VAR_1, git_buf *VAR_2)\n{\n\tgit_pkt *VAR_3;\n\tconst char *VAR_4, *VAR_5 = NULL;\n\tsize_t VAR_6;\n\tint VAR_7;\n\tint VAR_8 = VAR_2->size > 0;\n\n\tif (VAR_8) {\n\t\t/* COMMENT_0 */\n                                                      \n\t\tgit_buf_put(VAR_2, VAR_1->data, VAR_1->len);\n\t\tVAR_4 = VAR_2->ptr;\n\t\tVAR_6 = VAR_2->size;\n\t}\n\telse {\n\t\tVAR_4 = VAR_1->data;\n\t\tVAR_6 = VAR_1->len;\n\t}\n\n\twhile (VAR_6 > 0) {\n\t\tVAR_7 = git_pkt_parse_line(&VAR_3, VAR_4, &VAR_5, VAR_6);\n\n\t\tif (VAR_7 == VAR_9) {\n\t\t\t/* COMMENT_2 */\n                                         \n\t\t\tif (!VAR_8)\n\t\t\t\tgit_buf_put(VAR_2, VAR_4, VAR_6);\n\t\t\tVAR_7 = 0;\n\t\t\tgoto done;\n\t\t}\n\t\telse if (VAR_7 < 0)\n\t\t\tgoto done;\n\n\t\t/* COMMENT_4 */\n\t\tVAR_6 -= (VAR_5 - VAR_4);\n\t\tVAR_4 = VAR_5;\n\n\t\tVAR_7 = add_push_report_pkt(VAR_0, VAR_3);\n\n\t\tgit_pkt_free(VAR_3);\n\n\t\tif (VAR_7 < 0 && VAR_7 != VAR_10)\n\t\t\tgoto done;\n\t}\n\n\tVAR_7 = 0;\n\ndone:\n\tif (VAR_8)\n\t\tgit_buf_consume(VAR_2, VAR_5);\n\treturn VAR_7;\n}",
  "func_graph_path": "libgit2/2fdef641fd0dd2828bd948234ae86de75221a11a/smart_protocol.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -36,14 +36,6 @@\n \t\tline_len -= (line_end - line);\n \t\tline = line_end;\n \n-\t\t/* When a valid packet with no content has been\n-\t\t * read, git_pkt_parse_line does not report an\n-\t\t * error, but the pkt pointer has not been set.\n-\t\t * Handle this by skipping over empty packets.\n-\t\t */\n-\t\tif (pkt == NULL)\n-\t\t\tcontinue;\n-\n \t\terror = add_push_report_pkt(push, pkt);\n \n \t\tgit_pkt_free(pkt);",
  "diff_line_info": {
    "deleted_lines": [
      "\t\t/* When a valid packet with no content has been",
      "\t\t * read, git_pkt_parse_line does not report an",
      "\t\t * error, but the pkt pointer has not been set.",
      "\t\t * Handle this by skipping over empty packets.",
      "\t\t */",
      "\t\tif (pkt == NULL)",
      "\t\t\tcontinue;",
      ""
    ],
    "added_lines": []
  },
  "is_vul": true,
  "pr_url": "https://github.com/libgit2/libgit2/pull/4076",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/libgit2/libgit2/pull/4076: 403 Client Error: Forbidden for url: https://api.github.com/repos/libgit2/libgit2/pulls/4076",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.9\n\nThe patch addresses a NULL pointer dereference issue caused by empty packet lines, which is a security vulnerability. The changes in the code fix the buffer boundary check error, confirming it's a security fix. The confidence is high (0.9) due to clear code modifications aligning with the commitment to fix a security risk."
}