{
  "cve_id": "CVE-2022-44262",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "ff4j",
  "commit_msg": "fix: Add assignable check to PropertiesParser, YamlParser and XmlParser (#624)",
  "commit_hash": "e915c026aef46b502934cb05a825ea2ea15eb9e6",
  "git_url": "https://github.com/ff4j/ff4j/commit/e915c026aef46b502934cb05a825ea2ea15eb9e6",
  "file_path": "ff4j-config-yaml/src/main/java/org/ff4j/parser/yaml/YamlParser.java",
  "func_name": "parseProperties",
  "func_before": "@SuppressWarnings(\"unchecked\")\n    private Map < String, Property<?>> parseProperties(List<Map<String, Object>> properties) {\n        Map < String, Property<?>> result = new HashMap<>();\n        if (null != properties) {\n            properties.forEach(property -> {\n                // Initiate with name and value\n                String name     = (String) property.get(PROPERTY_PARAMNAME);\n                if (null == name) { \n                    throw new IllegalArgumentException(\"Invalid YAML File: 'name' is expected for properties\");\n                }\n                \n                Object objValue = property.get(PROPERTY_PARAMVALUE);\n                if (null == objValue) {\n                    throw new IllegalArgumentException(\"Invalid YAML File: 'value' is expected for properties\");\n                }\n                // Convert as a String\n                String strValue = String.valueOf(objValue);\n                if (objValue instanceof Date) {\n                    strValue = SIMPLE_DATE_FORMAT.format((Date) objValue);\n                }\n                \n                Property<?> ap = new PropertyString(name, strValue);\n                String optionalType = (String) property.get(PROPERTY_PARAMTYPE);\n                // If specific type defined ?\n                if (null != optionalType) {\n                    // Substitution if relevant (e.g. 'int' -> 'org.ff4j.property.PropertyInt')\n                    optionalType = MappingUtil.mapPropertyType(optionalType);\n                    try {\n                        // Constructor (String, String) is mandatory in Property interface\n                        Constructor<?> constr = Class.forName(optionalType).getConstructor(String.class, String.class);\n                        ap = (Property<?>) constr.newInstance(name, strValue);\n                    } catch (Exception e) {\n                        throw new IllegalArgumentException(\"Cannot instantiate '\" + optionalType + \"' check default constructor\", e);\n                    }\n                }\n                // Description\n                String description = (String) property.get(PROPERTY_PARAMDESCRIPTION);\n                if (null != description) {\n                    ap.setDescription(description);\n                } \n                // Fixed Values\n                List<Object> fixedValues = (List<Object>) property.get(PROPERTY_PARAMFIXED_VALUES);\n                if (null != fixedValues && fixedValues.size() > 0) {\n                    fixedValues.stream().map(Object::toString).forEach(ap::add2FixedValueFromString);\n                }\n                // Check fixed value\n                if (ap.getFixedValues() != null &&  \n                   !ap.getFixedValues().isEmpty() && \n                   !ap.getFixedValues().contains(ap.getValue())) {\n                    throw new IllegalArgumentException(\"Cannot create property <\" + ap.getName() + \n                            \"> invalid value <\" + ap.getValue() + \n                            \"> expected one of \" + ap.getFixedValues());\n                }\n                result.put(ap.getName(), ap);\n            });\n        }\n        return result;\n    }",
  "abstract_func_before": "@SuppressWarnings(\"unchecked\")\n    private Map < String, Property<?>> parseProperties(List<Map<String, Object>> VAR_0) {\n        Map < String, Property<?>> VAR_1 = new HashMap<>();\n        if (null != VAR_0) {\n            VAR_0.forEach(VAR_2 -> {\n                /* COMMENT_0 */\n                String VAR_3     = (String) VAR_2.get(VAR_4);\n                if (null == VAR_3) { \n                    throw new IllegalArgumentException(\"Invalid YAML File: 'name' is expected for properties\");\n                }\n                \n                Object VAR_5 = VAR_2.get(VAR_6);\n                if (null == VAR_5) {\n                    throw new IllegalArgumentException(\"Invalid YAML File: 'value' is expected for properties\");\n                }\n                /* COMMENT_1 */\n                String VAR_7 = VAR_8.valueOf(VAR_5);\n                if (VAR_5 instanceof Date) {\n                    VAR_7 = VAR_9.format((Date) VAR_5);\n                }\n                \n                Property<?> VAR_10 = new PropertyString(VAR_3, VAR_7);\n                String VAR_11 = (String) VAR_2.get(VAR_12);\n                /* COMMENT_2 */\n                if (null != VAR_11) {\n                    /* COMMENT_3 */\n                    VAR_11 = VAR_13.mapPropertyType(VAR_11);\n                    try {\n                        /* COMMENT_4 */\n                        Constructor<?> VAR_14 = VAR_15.forName(VAR_11).getConstructor(String.class, String.class);\n                        VAR_10 = (Property<?>) VAR_14.newInstance(VAR_3, VAR_7);\n                    } catch (Exception VAR_16) {\n                        throw new IllegalArgumentException(\"Cannot instantiate '\" + VAR_11 + \"' check default constructor\", VAR_16);\n                    }\n                }\n                /* COMMENT_5 */\n                String VAR_17 = (String) VAR_2.get(VAR_18);\n                if (null != VAR_17) {\n                    VAR_10.setDescription(VAR_17);\n                } \n                /* COMMENT_6 */\n                List<Object> VAR_19 = (List<Object>) VAR_2.get(VAR_20);\n                if (null != VAR_19 && VAR_19.size() > 0) {\n                    VAR_19.stream().map(VAR_21::VAR_22).forEach(VAR_10::VAR_23);\n                }\n                /* COMMENT_7 */\n                if (VAR_10.getFixedValues() != null &&  \n                   !VAR_10.getFixedValues().isEmpty() && \n                   !VAR_10.getFixedValues().contains(VAR_10.getValue())) {\n                    throw new IllegalArgumentException(\"Cannot create property <\" + VAR_10.getName() + \n                            \"> invalid value <\" + VAR_10.getValue() + \n                            \"> expected one of \" + VAR_10.getFixedValues());\n                }\n                VAR_1.put(VAR_10.getName(), VAR_10);\n            });\n        }\n        return VAR_1;\n    }",
  "func_graph_path_before": "ff4j/e915c026aef46b502934cb05a825ea2ea15eb9e6/YamlParser.java/vul/before/0.json",
  "func": "@SuppressWarnings(\"unchecked\")\n    private Map < String, Property<?>> parseProperties(List<Map<String, Object>> properties) {\n        Map < String, Property<?>> result = new HashMap<>();\n        if (null != properties) {\n            properties.forEach(property -> {\n                // Initiate with name and value\n                String name     = (String) property.get(PROPERTY_PARAMNAME);\n                if (null == name) { \n                    throw new IllegalArgumentException(\"Invalid YAML File: 'name' is expected for properties\");\n                }\n                \n                Object objValue = property.get(PROPERTY_PARAMVALUE);\n                if (null == objValue) {\n                    throw new IllegalArgumentException(\"Invalid YAML File: 'value' is expected for properties\");\n                }\n                // Convert as a String\n                String strValue = String.valueOf(objValue);\n                if (objValue instanceof Date) {\n                    strValue = SIMPLE_DATE_FORMAT.format((Date) objValue);\n                }\n                \n                Property<?> ap = new PropertyString(name, strValue);\n                String optionalType = (String) property.get(PROPERTY_PARAMTYPE);\n                // If specific type defined ?\n                if (null != optionalType) {\n                    // Substitution if relevant (e.g. 'int' -> 'org.ff4j.property.PropertyInt')\n                    optionalType = MappingUtil.mapPropertyType(optionalType);\n                    try {\n                        // Constructor (String, String) is mandatory in Property interface\n                        Class<?> typeClass = Class.forName(optionalType);\n                        if (!Property.class.isAssignableFrom(typeClass)) {\n                            throw new IllegalArgumentException(\"Cannot create property <\" + name + \"> invalid type <\" + optionalType + \">\");\n                        }\n                        Constructor<?> constr = typeClass.getConstructor(String.class, String.class);\n                        ap = (Property<?>) constr.newInstance(name, strValue);\n                    } catch (Exception e) {\n                        throw new IllegalArgumentException(\"Cannot instantiate '\" + optionalType + \"' check default constructor\", e);\n                    }\n                }\n                // Description\n                String description = (String) property.get(PROPERTY_PARAMDESCRIPTION);\n                if (null != description) {\n                    ap.setDescription(description);\n                } \n                // Fixed Values\n                List<Object> fixedValues = (List<Object>) property.get(PROPERTY_PARAMFIXED_VALUES);\n                if (null != fixedValues && fixedValues.size() > 0) {\n                    fixedValues.stream().map(Object::toString).forEach(ap::add2FixedValueFromString);\n                }\n                // Check fixed value\n                if (ap.getFixedValues() != null &&  \n                   !ap.getFixedValues().isEmpty() && \n                   !ap.getFixedValues().contains(ap.getValue())) {\n                    throw new IllegalArgumentException(\"Cannot create property <\" + ap.getName() + \n                            \"> invalid value <\" + ap.getValue() + \n                            \"> expected one of \" + ap.getFixedValues());\n                }\n                result.put(ap.getName(), ap);\n            });\n        }\n        return result;\n    }",
  "abstract_func": "@SuppressWarnings(\"unchecked\")\n    private Map < String, Property<?>> parseProperties(List<Map<String, Object>> VAR_0) {\n        Map < String, Property<?>> VAR_1 = new HashMap<>();\n        if (null != VAR_0) {\n            VAR_0.forEach(VAR_2 -> {\n                /* COMMENT_0 */\n                String VAR_3     = (String) VAR_2.get(VAR_4);\n                if (null == VAR_3) { \n                    throw new IllegalArgumentException(\"Invalid YAML File: 'name' is expected for properties\");\n                }\n                \n                Object VAR_5 = VAR_2.get(VAR_6);\n                if (null == VAR_5) {\n                    throw new IllegalArgumentException(\"Invalid YAML File: 'value' is expected for properties\");\n                }\n                /* COMMENT_1 */\n                String VAR_7 = VAR_8.valueOf(VAR_5);\n                if (VAR_5 instanceof Date) {\n                    VAR_7 = VAR_9.format((Date) VAR_5);\n                }\n                \n                Property<?> VAR_10 = new PropertyString(VAR_3, VAR_7);\n                String VAR_11 = (String) VAR_2.get(VAR_12);\n                /* COMMENT_2 */\n                if (null != VAR_11) {\n                    /* COMMENT_3 */\n                    VAR_11 = VAR_13.mapPropertyType(VAR_11);\n                    try {\n                        /* COMMENT_4 */\n                        Class<?> VAR_14 = VAR_15.forName(VAR_11);\n                        if (!Property.class.isAssignableFrom(VAR_14)) {\n                            throw new IllegalArgumentException(\"Cannot create property <\" + VAR_3 + \"> invalid type <\" + VAR_11 + \">\");\n                        }\n                        Constructor<?> VAR_16 = VAR_14.getConstructor(String.class, String.class);\n                        VAR_10 = (Property<?>) VAR_16.newInstance(VAR_3, VAR_7);\n                    } catch (Exception VAR_17) {\n                        throw new IllegalArgumentException(\"Cannot instantiate '\" + VAR_11 + \"' check default constructor\", VAR_17);\n                    }\n                }\n                /* COMMENT_5 */\n                String VAR_18 = (String) VAR_2.get(VAR_19);\n                if (null != VAR_18) {\n                    VAR_10.setDescription(VAR_18);\n                } \n                /* COMMENT_6 */\n                List<Object> VAR_20 = (List<Object>) VAR_2.get(VAR_21);\n                if (null != VAR_20 && VAR_20.size() > 0) {\n                    VAR_20.stream().map(VAR_22::VAR_23).forEach(VAR_10::VAR_24);\n                }\n                /* COMMENT_7 */\n                if (VAR_10.getFixedValues() != null &&  \n                   !VAR_10.getFixedValues().isEmpty() && \n                   !VAR_10.getFixedValues().contains(VAR_10.getValue())) {\n                    throw new IllegalArgumentException(\"Cannot create property <\" + VAR_10.getName() + \n                            \"> invalid value <\" + VAR_10.getValue() + \n                            \"> expected one of \" + VAR_10.getFixedValues());\n                }\n                VAR_1.put(VAR_10.getName(), VAR_10);\n            });\n        }\n        return VAR_1;\n    }",
  "func_graph_path": "ff4j/e915c026aef46b502934cb05a825ea2ea15eb9e6/YamlParser.java/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -27,7 +27,11 @@\n                     optionalType = MappingUtil.mapPropertyType(optionalType);\n                     try {\n                         // Constructor (String, String) is mandatory in Property interface\n-                        Constructor<?> constr = Class.forName(optionalType).getConstructor(String.class, String.class);\n+                        Class<?> typeClass = Class.forName(optionalType);\n+                        if (!Property.class.isAssignableFrom(typeClass)) {\n+                            throw new IllegalArgumentException(\"Cannot create property <\" + name + \"> invalid type <\" + optionalType + \">\");\n+                        }\n+                        Constructor<?> constr = typeClass.getConstructor(String.class, String.class);\n                         ap = (Property<?>) constr.newInstance(name, strValue);\n                     } catch (Exception e) {\n                         throw new IllegalArgumentException(\"Cannot instantiate '\" + optionalType + \"' check default constructor\", e);",
  "diff_line_info": {
    "deleted_lines": [
      "                        Constructor<?> constr = Class.forName(optionalType).getConstructor(String.class, String.class);"
    ],
    "added_lines": [
      "                        Class<?> typeClass = Class.forName(optionalType);",
      "                        if (!Property.class.isAssignableFrom(typeClass)) {",
      "                            throw new IllegalArgumentException(\"Cannot create property <\" + name + \"> invalid type <\" + optionalType + \">\");",
      "                        }",
      "                        Constructor<?> constr = typeClass.getConstructor(String.class, String.class);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/ff4j/ff4j/pull/625",
  "description": {
    "pr_info": {
      "title": "fix: CVE-2022-44262 (#624)",
      "number": 625
    },
    "comment": [
      "Fixes #624 \r\n\r\nThis asserts that the Property being constructed extends `org.ff4j.property.Property`\r\n\r\n```\r\nConstructor<?> constr = Class.forName(optionalType).getConstructor(String.class, String.class);\r\nap = (Property<?>) constr.newInstance(name, strValue);\r\n```\r\n\r\nThis seems to be what is happening in the above code:\r\n\r\n1.`Class.forName(optionalType)` retrieves the target class\r\n2. `.getConstructor(String.class, String.class)` finds a constructor on the target class that accepts two String parameters\r\n3. `constr.newInstance(name, strValue)` constructs the instance (where the side effect happens)\r\n4. `(Property<?>)` type casts the new instance of the class. This throws an IllegalArgumentException, but the instance has been created already.",
      "the RCE is present in different points of the FF4j project.\r\nAll inputs must be validated with the proper \"isAssignableFrom\" method before executing \"newInstance\" of Class.forName(\"someinputstring\")\r\nThis applies to both property and strategy parsing/creating.\r\n\r\nExamples: \r\nff4j-core:\r\norg.ff4j.utils.MappingUtil line 183\r\norg.ff4j.conf.XmlParser line 387\r\n\r\nff4j-config-yaml:\r\norg.ff4j.parser.yaml.YamlParser line 175\r\n\r\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9\n\nThe patch addresses a security vulnerability by adding a type check to ensure only valid Property classes are instantiated, preventing potential exploitation through reflection."
}