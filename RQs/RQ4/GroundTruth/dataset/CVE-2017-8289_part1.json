{
  "cve_id": "CVE-2017-8289",
  "cwe_ids": [
    "CWE-119"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "RIOT-OS/RIOT",
  "commit_msg": "ipv6_addr: provide fix for off-by-x error",
  "commit_hash": "eef90c06fb36ed08f82b1176bf6d1c9c8615be86",
  "git_url": "https://github.com/RIOT-OS/RIOT/commit/eef90c06fb36ed08f82b1176bf6d1c9c8615be86",
  "file_path": "sys/net/network_layer/ipv6/addr/ipv6_addr_from_str.c",
  "func_name": "ipv6_addr_from_str",
  "func_before": "ipv6_addr_t *ipv6_addr_from_str(ipv6_addr_t *result, const char *addr)\n{\n    uint8_t *colonp = 0;\n#ifdef MODULE_IPV4_ADDR\n    const char *curtok = addr;\n#endif\n    uint32_t val = 0;\n    char ch;\n    uint8_t saw_xdigit = 0;\n    uint8_t i = 0;\n\n    if ((result == NULL) || (addr == NULL)) {\n        return NULL;\n    }\n\n    ipv6_addr_set_unspecified(result);\n\n    /* Leading :: requires some special handling. */\n    if (*addr == ':') {\n        if (*++addr != ':') {\n            return NULL;\n        }\n    }\n\n    while ((ch = *addr++) != '\\0') {\n        const char *pch;\n        const char *xdigits;\n\n        if ((pch = strchr((xdigits = HEX_L), ch)) == NULL) {\n            pch = strchr((xdigits = HEX_U), ch);\n        }\n\n        if (pch != NULL) {\n            val <<= 4;\n            val |= (pch - xdigits);\n\n            if (val > 0xffff) {\n                return NULL;\n            }\n\n            saw_xdigit = 1;\n            continue;\n        }\n\n        if (ch == ':') {\n#ifdef MODULE_IPV4_ADDR\n            curtok = addr;\n#endif\n\n            if (!saw_xdigit) {\n                if (colonp != NULL) {\n                    return NULL;\n                }\n\n                colonp = &(result->u8[i]);\n                continue;\n            }\n\n            if (i > sizeof(ipv6_addr_t)) {\n                return NULL;\n            }\n\n            result->u8[i++] = (uint8_t)(val >> 8) & 0xff;\n            result->u8[i++] = (uint8_t) val & 0xff;\n            saw_xdigit = 0;\n            val = 0;\n            continue;\n        }\n\n#ifdef MODULE_IPV4_ADDR\n        if (ch == '.' && (i <= sizeof(ipv6_addr_t)) &&\n            ipv4_addr_from_str((ipv4_addr_t *)(&(result->u8[i])),\n                               curtok) != NULL) {\n            i += sizeof(ipv4_addr_t);\n            saw_xdigit = 0;\n            break;  /* '\\0' was seen by ipv4_addr_from_str(). */\n        }\n#endif\n\n        return NULL;\n    }\n\n    if (saw_xdigit) {\n        if (i + sizeof(uint16_t) > sizeof(ipv6_addr_t)) {\n            return NULL;\n        }\n\n        result->u8[i++] = (uint8_t)(val >> 8) & 0xff;\n        result->u8[i++] = (uint8_t) val & 0xff;\n    }\n\n    if (colonp != NULL) {\n        /*\n         * Since some memmove()'s erroneously fail to handle\n         * overlapping regions, we'll do the shift by hand.\n         */\n        const int32_t n = &(result->u8[i++]) - colonp;\n\n        for (int32_t j = 1; j <= n; j++) {\n            result->u8[sizeof(ipv6_addr_t) - j] = colonp[n - j];\n            colonp[n - j] = 0;\n        }\n\n        i = sizeof(ipv6_addr_t);\n    }\n\n    if (i != sizeof(ipv6_addr_t)) {\n        return NULL;\n    }\n\n    return result;\n}",
  "abstract_func_before": "ipv6_addr_t *ipv6_addr_from_str(ipv6_addr_t *VAR_0, const char *VAR_1)\n{\n    uint8_t *VAR_2 = 0;\n#ifdef VAR_3\n    const char *VAR_4 = VAR_1;\n#endif\n    uint32_t VAR_5 = 0;\n    char VAR_6;\n    uint8_t VAR_7 = 0;\n    uint8_t VAR_8 = 0;\n\n    if ((VAR_0 == NULL) || (VAR_1 == NULL)) {\n        return NULL;\n    }\n\n    ipv6_addr_set_unspecified(VAR_0);\n\n    /* COMMENT_0 */\n    if (*VAR_1 == ':') {\n        if (*++VAR_1 != ':') {\n            return NULL;\n        }\n    }\n\n    while ((VAR_6 = *VAR_1++) != '\\0') {\n        const char *VAR_9;\n        const char *VAR_10;\n\n        if ((VAR_9 = strchr((VAR_10 = VAR_11), VAR_6)) == NULL) {\n            VAR_9 = strchr((VAR_10 = VAR_12), VAR_6);\n        }\n\n        if (VAR_9 != NULL) {\n            VAR_5 <<= 4;\n            VAR_5 |= (VAR_9 - VAR_10);\n\n            if (VAR_5 > 0xffff) {\n                return NULL;\n            }\n\n            VAR_7 = 1;\n            continue;\n        }\n\n        if (VAR_6 == ':') {\n#ifdef VAR_3\n            VAR_4 = VAR_1;\n#endif\n\n            if (!VAR_7) {\n                if (VAR_2 != NULL) {\n                    return NULL;\n                }\n\n                VAR_2 = &(VAR_0->u8[VAR_8]);\n                continue;\n            }\n\n            if (VAR_8 > sizeof(ipv6_addr_t)) {\n                return NULL;\n            }\n\n            VAR_0->u8[VAR_8++] = (uint8_t)(VAR_5 >> 8) & 0xff;\n            VAR_0->u8[VAR_8++] = (uint8_t) VAR_5 & 0xff;\n            VAR_7 = 0;\n            VAR_5 = 0;\n            continue;\n        }\n\n#ifdef VAR_3\n        if (VAR_6 == '.' && (VAR_8 <= sizeof(ipv6_addr_t)) &&\n            ipv4_addr_from_str((ipv4_addr_t *)(&(VAR_0->u8[VAR_8])),\n                               VAR_4) != NULL) {\n            VAR_8 += sizeof(ipv4_addr_t);\n            VAR_7 = 0;\n            break;  /* COMMENT_1 */\n        }\n#endif\n\n        return NULL;\n    }\n\n    if (VAR_7) {\n        if (VAR_8 + sizeof(uint16_t) > sizeof(ipv6_addr_t)) {\n            return NULL;\n        }\n\n        VAR_0->u8[VAR_8++] = (uint8_t)(VAR_5 >> 8) & 0xff;\n        VAR_0->u8[VAR_8++] = (uint8_t) VAR_5 & 0xff;\n    }\n\n    if (VAR_2 != NULL) {\n        /* COMMENT_2 */\n                                                            \n                                                           \n           \n        const int32_t VAR_13 = &(VAR_0->u8[VAR_8++]) - VAR_2;\n\n        for (int32_t VAR_14 = 1; VAR_14 <= VAR_13; VAR_14++) {\n            VAR_0->u8[sizeof(ipv6_addr_t) - VAR_14] = VAR_2[VAR_13 - VAR_14];\n            VAR_2[VAR_13 - VAR_14] = 0;\n        }\n\n        VAR_8 = sizeof(ipv6_addr_t);\n    }\n\n    if (VAR_8 != sizeof(ipv6_addr_t)) {\n        return NULL;\n    }\n\n    return VAR_0;\n}",
  "func_graph_path_before": "RIOT-OS/RIOT/eef90c06fb36ed08f82b1176bf6d1c9c8615be86/ipv6_addr_from_str.c/vul/before/0.json",
  "func": "ipv6_addr_t *ipv6_addr_from_str(ipv6_addr_t *result, const char *addr)\n{\n    uint8_t *colonp = 0;\n#ifdef MODULE_IPV4_ADDR\n    const char *curtok = addr;\n#endif\n    uint32_t val = 0;\n    char ch;\n    uint8_t saw_xdigit = 0;\n    uint8_t i = 0;\n\n    if ((result == NULL) || (addr == NULL)) {\n        return NULL;\n    }\n\n    ipv6_addr_set_unspecified(result);\n\n    /* Leading :: requires some special handling. */\n    if (*addr == ':') {\n        if (*++addr != ':') {\n            return NULL;\n        }\n    }\n\n    while ((ch = *addr++) != '\\0') {\n        const char *pch;\n        const char *xdigits;\n\n        if ((pch = strchr((xdigits = HEX_L), ch)) == NULL) {\n            pch = strchr((xdigits = HEX_U), ch);\n        }\n\n        if (pch != NULL) {\n            val <<= 4;\n            val |= (pch - xdigits);\n\n            if (val > 0xffff) {\n                return NULL;\n            }\n\n            saw_xdigit = 1;\n            continue;\n        }\n\n        if (ch == ':') {\n#ifdef MODULE_IPV4_ADDR\n            curtok = addr;\n#endif\n\n            if (!saw_xdigit) {\n                if (colonp != NULL) {\n                    return NULL;\n                }\n\n                colonp = &(result->u8[i]);\n                continue;\n            }\n\n            if ((i + sizeof(uint16_t)) > sizeof(ipv6_addr_t)) {\n                return NULL;\n            }\n\n            result->u8[i++] = (uint8_t)(val >> 8) & 0xff;\n            result->u8[i++] = (uint8_t) val & 0xff;\n            saw_xdigit = 0;\n            val = 0;\n            continue;\n        }\n\n#ifdef MODULE_IPV4_ADDR\n        if (ch == '.' && ((i + sizeof(ipv4_addr_t)) <= sizeof(ipv6_addr_t)) &&\n            ipv4_addr_from_str((ipv4_addr_t *)(&(result->u8[i])),\n                               curtok) != NULL) {\n            i += sizeof(ipv4_addr_t);\n            saw_xdigit = 0;\n            break;  /* '\\0' was seen by ipv4_addr_from_str(). */\n        }\n#endif\n\n        return NULL;\n    }\n\n    if (saw_xdigit) {\n        if (i + sizeof(uint16_t) > sizeof(ipv6_addr_t)) {\n            return NULL;\n        }\n\n        result->u8[i++] = (uint8_t)(val >> 8) & 0xff;\n        result->u8[i++] = (uint8_t) val & 0xff;\n    }\n\n    if (colonp != NULL) {\n        /*\n         * Since some memmove()'s erroneously fail to handle\n         * overlapping regions, we'll do the shift by hand.\n         */\n        const int32_t n = &(result->u8[i++]) - colonp;\n\n        for (int32_t j = 1; j <= n; j++) {\n            result->u8[sizeof(ipv6_addr_t) - j] = colonp[n - j];\n            colonp[n - j] = 0;\n        }\n\n        i = sizeof(ipv6_addr_t);\n    }\n\n    if (i != sizeof(ipv6_addr_t)) {\n        return NULL;\n    }\n\n    return result;\n}",
  "abstract_func": "ipv6_addr_t *ipv6_addr_from_str(ipv6_addr_t *VAR_0, const char *VAR_1)\n{\n    uint8_t *VAR_2 = 0;\n#ifdef VAR_3\n    const char *VAR_4 = VAR_1;\n#endif\n    uint32_t VAR_5 = 0;\n    char VAR_6;\n    uint8_t VAR_7 = 0;\n    uint8_t VAR_8 = 0;\n\n    if ((VAR_0 == NULL) || (VAR_1 == NULL)) {\n        return NULL;\n    }\n\n    ipv6_addr_set_unspecified(VAR_0);\n\n    /* COMMENT_0 */\n    if (*VAR_1 == ':') {\n        if (*++VAR_1 != ':') {\n            return NULL;\n        }\n    }\n\n    while ((VAR_6 = *VAR_1++) != '\\0') {\n        const char *VAR_9;\n        const char *VAR_10;\n\n        if ((VAR_9 = strchr((VAR_10 = VAR_11), VAR_6)) == NULL) {\n            VAR_9 = strchr((VAR_10 = VAR_12), VAR_6);\n        }\n\n        if (VAR_9 != NULL) {\n            VAR_5 <<= 4;\n            VAR_5 |= (VAR_9 - VAR_10);\n\n            if (VAR_5 > 0xffff) {\n                return NULL;\n            }\n\n            VAR_7 = 1;\n            continue;\n        }\n\n        if (VAR_6 == ':') {\n#ifdef VAR_3\n            VAR_4 = VAR_1;\n#endif\n\n            if (!VAR_7) {\n                if (VAR_2 != NULL) {\n                    return NULL;\n                }\n\n                VAR_2 = &(VAR_0->u8[VAR_8]);\n                continue;\n            }\n\n            if ((VAR_8 + sizeof(uint16_t)) > sizeof(ipv6_addr_t)) {\n                return NULL;\n            }\n\n            VAR_0->u8[VAR_8++] = (uint8_t)(VAR_5 >> 8) & 0xff;\n            VAR_0->u8[VAR_8++] = (uint8_t) VAR_5 & 0xff;\n            VAR_7 = 0;\n            VAR_5 = 0;\n            continue;\n        }\n\n#ifdef VAR_3\n        if (VAR_6 == '.' && ((VAR_8 + sizeof(VAR_13)) <= sizeof(ipv6_addr_t)) &&\n            ipv4_addr_from_str((ipv4_addr_t *)(&(VAR_0->u8[VAR_8])),\n                               VAR_4) != NULL) {\n            VAR_8 += sizeof(ipv4_addr_t);\n            VAR_7 = 0;\n            break;  /* COMMENT_1 */\n        }\n#endif\n\n        return NULL;\n    }\n\n    if (VAR_7) {\n        if (VAR_8 + sizeof(uint16_t) > sizeof(ipv6_addr_t)) {\n            return NULL;\n        }\n\n        VAR_0->u8[VAR_8++] = (uint8_t)(VAR_5 >> 8) & 0xff;\n        VAR_0->u8[VAR_8++] = (uint8_t) VAR_5 & 0xff;\n    }\n\n    if (VAR_2 != NULL) {\n        /* COMMENT_2 */\n                                                            \n                                                           \n           \n        const int32_t VAR_14 = &(VAR_0->u8[VAR_8++]) - VAR_2;\n\n        for (int32_t VAR_15 = 1; VAR_15 <= VAR_14; VAR_15++) {\n            VAR_0->u8[sizeof(ipv6_addr_t) - VAR_15] = VAR_2[VAR_14 - VAR_15];\n            VAR_2[VAR_14 - VAR_15] = 0;\n        }\n\n        VAR_8 = sizeof(ipv6_addr_t);\n    }\n\n    if (VAR_8 != sizeof(ipv6_addr_t)) {\n        return NULL;\n    }\n\n    return VAR_0;\n}",
  "func_graph_path": "RIOT-OS/RIOT/eef90c06fb36ed08f82b1176bf6d1c9c8615be86/ipv6_addr_from_str.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -56,7 +56,7 @@\n                 continue;\n             }\n \n-            if (i > sizeof(ipv6_addr_t)) {\n+            if ((i + sizeof(uint16_t)) > sizeof(ipv6_addr_t)) {\n                 return NULL;\n             }\n \n@@ -68,7 +68,7 @@\n         }\n \n #ifdef MODULE_IPV4_ADDR\n-        if (ch == '.' && (i <= sizeof(ipv6_addr_t)) &&\n+        if (ch == '.' && ((i + sizeof(ipv4_addr_t)) <= sizeof(ipv6_addr_t)) &&\n             ipv4_addr_from_str((ipv4_addr_t *)(&(result->u8[i])),\n                                curtok) != NULL) {\n             i += sizeof(ipv4_addr_t);",
  "diff_line_info": {
    "deleted_lines": [
      "            if (i > sizeof(ipv6_addr_t)) {",
      "        if (ch == '.' && (i <= sizeof(ipv6_addr_t)) &&"
    ],
    "added_lines": [
      "            if ((i + sizeof(uint16_t)) > sizeof(ipv6_addr_t)) {",
      "        if (ch == '.' && ((i + sizeof(ipv4_addr_t)) <= sizeof(ipv6_addr_t)) &&"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/RIOT-OS/RIOT/pull/6961",
  "description": {
    "pr_info": {
      "title": "ipv6_addr: provide fix for off-by-x error",
      "number": 6961
    },
    "comment": [
      "Provides a fix and test cases for an off-by-one (actually an off-by-2 and off-by-4) error in the string-to-ipv6-address-conversion.",
      "Backport provided at #6962."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "Final Classification: Security Vulnerability Fix; Confidence: 0.9"
}