{
  "cve_id": "CVE-2018-19535",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "Exiv2/exiv2",
  "commit_msg": "Fix more issues in PngChunk::readRawProfile",
  "commit_hash": "cf3ba049a2792ec2a4a877e343f5dd9654da53dc",
  "git_url": "https://github.com/Exiv2/exiv2/commit/cf3ba049a2792ec2a4a877e343f5dd9654da53dc",
  "file_path": "src/pngchunk_int.cpp",
  "func_name": "PngChunk::readRawProfile",
  "func_before": "DataBuf PngChunk::readRawProfile(const DataBuf& text,bool iTXt)\n    {\n        DataBuf                 info;\n        register long           i;\n        register unsigned char *dp;\n        const char             *sp;\n        unsigned int            nibbles;\n        long                    length;\n        unsigned char           unhex[103]={0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,\n                                            0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,\n                                            0,0,0,0,0,0,0,0,0,1, 2,3,4,5,6,7,8,9,0,0,\n                                            0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,\n                                            0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,10,11,12,\n                                            13,14,15};\n        if (text.size_ == 0) {\n            return DataBuf();\n        }\n\n        if ( iTXt ) {\n            info.alloc(text.size_);\n            ::memcpy(info.pData_,text.pData_,text.size_);\n            return  info;\n        }\n\n\n        sp = (char*)text.pData_+1;\n        int pointerPos = 1;\n\n        // Look for newline\n        while (*sp != '\\n' && pointerPos < (text.size_ - 1))\n        {\n            sp++;\n            pointerPos++;\n        }\n\n        if (pointerPos == (text.size_ - 1))\n        {\n            return DataBuf();\n        }\n\n        // Look for length\n\n        while (*sp == '\\0' || *sp == ' ' || *sp == '\\n')\n            sp++;\n\n        length = (long) atol(sp);\n\n        while (*sp != ' ' && *sp != '\\n')\n            sp++;\n\n        // Allocate space\n\n        if (length == 0)\n        {\n#ifdef DEBUG\n            std::cerr << \"Exiv2::PngChunk::readRawProfile: Unable To Copy Raw Profile: invalid profile length\\n\";\n#endif\n        }\n\n        info.alloc(length);\n\n        if (info.size_ != length)\n        {\n#ifdef DEBUG\n            std::cerr << \"Exiv2::PngChunk::readRawProfile: Unable To Copy Raw Profile: cannot allocate memory\\n\";\n#endif\n            return DataBuf();\n        }\n\n        // Copy profile, skipping white space and column 1 \"=\" signs\n\n        dp      = (unsigned char*)info.pData_;\n        nibbles = length * 2;\n\n        for (i = 0; i < (long) nibbles; i++)\n        {\n            while (*sp < '0' || (*sp > '9' && *sp < 'a') || *sp > 'f')\n            {\n                if (*sp == '\\0')\n                {\n#ifdef DEBUG\n                    std::cerr << \"Exiv2::PngChunk::readRawProfile: Unable To Copy Raw Profile: ran out of data\\n\";\n#endif\n                    return DataBuf();\n                }\n\n                sp++;\n            }\n\n            if (i%2 == 0)\n                *dp = (unsigned char) (16*unhex[(int) *sp++]);\n            else\n                (*dp++) += unhex[(int) *sp++];\n        }\n\n        return info;\n\n    }",
  "abstract_func_before": "DataBuf PngChunk::readRawProfile(const DataBuf& VAR_0,bool VAR_1)\n    {\n        DataBuf                 VAR_2;\n        register long           VAR_3;\n        register unsigned char *VAR_4;\n        const char             *VAR_5;\n        unsigned int            VAR_6;\n        long                    VAR_7;\n        unsigned char           VAR_8[103]={0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,\n                                            0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,\n                                            0,0,0,0,0,0,0,0,0,1, 2,3,4,5,6,7,8,9,0,0,\n                                            0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,\n                                            0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,10,11,12,\n                                            13,14,15};\n        if (VAR_0.size_ == 0) {\n            return DataBuf();\n        }\n\n        if ( VAR_1 ) {\n            VAR_2.alloc(VAR_0.size_);\n            ::memcpy(VAR_2.pData_,VAR_0.pData_,VAR_0.size_);\n            return  VAR_2;\n        }\n\n\n        VAR_5 = (char*)VAR_0.pData_+1;\n        int VAR_9 = 1;\n\n        /* COMMENT_0 */\n        while (*VAR_5 != '\\n' && VAR_9 < (VAR_0.size_ - 1))\n        {\n            VAR_5++;\n            VAR_9++;\n        }\n\n        if (VAR_9 == (VAR_0.size_ - 1))\n        {\n            return DataBuf();\n        }\n\n        /* COMMENT_1 */\n\n        while (*VAR_5 == '\\0' || *VAR_5 == ' ' || *VAR_5 == '\\n')\n            VAR_5++;\n\n        VAR_7 = (long) atol(VAR_5);\n\n        while (*VAR_5 != ' ' && *VAR_5 != '\\n')\n            VAR_5++;\n\n        /* COMMENT_2 */\n\n        if (VAR_7 == 0)\n        {\n#ifdef VAR_10\n            std::cerr << \"Exiv2::PngChunk::readRawProfile: Unable To Copy Raw Profile: invalid profile length\\n\";\n#endif\n        }\n\n        VAR_2.alloc(VAR_7);\n\n        if (VAR_2.size_ != VAR_7)\n        {\n#ifdef VAR_10\n            std::cerr << \"Exiv2::PngChunk::readRawProfile: Unable To Copy Raw Profile: cannot allocate memory\\n\";\n#endif\n            return DataBuf();\n        }\n\n        /* COMMENT_3 */\n\n        VAR_4      = (unsigned char*)VAR_2.pData_;\n        VAR_6 = VAR_7 * 2;\n\n        for (VAR_3 = 0; VAR_3 < (long) VAR_6; VAR_3++)\n        {\n            while (*VAR_5 < '0' || (*VAR_5 > '9' && *VAR_5 < 'a') || *VAR_5 > 'f')\n            {\n                if (*VAR_5 == '\\0')\n                {\n#ifdef VAR_10\n                    std::cerr << \"Exiv2::PngChunk::readRawProfile: Unable To Copy Raw Profile: ran out of data\\n\";\n#endif\n                    return DataBuf();\n                }\n\n                VAR_5++;\n            }\n\n            if (VAR_3%2 == 0)\n                *VAR_4 = (unsigned char) (16*VAR_8[(int) *VAR_5++]);\n            else\n                (*VAR_4++) += VAR_8[(int) *VAR_5++];\n        }\n\n        return VAR_2;\n\n    }",
  "func_graph_path_before": "Exiv2/exiv2/cf3ba049a2792ec2a4a877e343f5dd9654da53dc/pngchunk_int.cpp/vul/before/0.json",
  "func": "DataBuf PngChunk::readRawProfile(const DataBuf& text,bool iTXt)\n    {\n        DataBuf                 info;\n        unsigned char           unhex[103]={0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,\n                                            0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,\n                                            0,0,0,0,0,0,0,0,0,1, 2,3,4,5,6,7,8,9,0,0,\n                                            0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,\n                                            0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,10,11,12,\n                                            13,14,15};\n        if (text.size_ == 0) {\n            return DataBuf();\n        }\n\n        if ( iTXt ) {\n            info.alloc(text.size_);\n            ::memcpy(info.pData_,text.pData_,text.size_);\n            return  info;\n        }\n\n        const char *sp = (char*)text.pData_+1;\n        int pointerPos = 1;\n\n        // Look for newline\n        while (*sp != '\\n' && pointerPos < (text.size_ - 1))\n        {\n            sp++;\n            pointerPos++;\n        }\n\n        // Look for length\n        while ((*sp == '\\0' || *sp == ' ' || *sp == '\\n') && pointerPos < (text.size_ - 1))\n        {\n            sp++;\n            pointerPos++;\n        }\n\n        if (pointerPos == (text.size_ - 1))\n        {\n            return DataBuf();\n        }\n\n        long length = (long) atol(sp);\n\n        while (*sp != ' ' && *sp != '\\n' && pointerPos < (text.size_ - 1))\n        {\n            sp++;\n            pointerPos++;\n        }\n\n        if (pointerPos == (text.size_ - 1))\n        {\n            return DataBuf();\n        }\n\n        // Allocate space\n\n        if (length == 0)\n        {\n#ifdef DEBUG\n            std::cerr << \"Exiv2::PngChunk::readRawProfile: Unable To Copy Raw Profile: invalid profile length\\n\";\n#endif\n        }\n\n        info.alloc(length);\n\n        if (info.size_ != length)\n        {\n#ifdef DEBUG\n            std::cerr << \"Exiv2::PngChunk::readRawProfile: Unable To Copy Raw Profile: cannot allocate memory\\n\";\n#endif\n            return DataBuf();\n        }\n\n        // Copy profile, skipping white space and column 1 \"=\" signs\n\n        unsigned char *dp = (unsigned char*)info.pData_;\n        unsigned int nibbles = length * 2;\n\n        for (long i = 0; i < (long) nibbles; i++)\n        {\n            while (*sp < '0' || (*sp > '9' && *sp < 'a') || *sp > 'f')\n            {\n                if (*sp == '\\0')\n                {\n#ifdef DEBUG\n                    std::cerr << \"Exiv2::PngChunk::readRawProfile: Unable To Copy Raw Profile: ran out of data\\n\";\n#endif\n                    return DataBuf();\n                }\n\n                sp++;\n            }\n\n            if (i%2 == 0)\n                *dp = (unsigned char) (16*unhex[(int) *sp++]);\n            else\n                (*dp++) += unhex[(int) *sp++];\n        }\n\n        return info;\n\n    }",
  "abstract_func": "DataBuf PngChunk::readRawProfile(const DataBuf& VAR_0,bool VAR_1)\n    {\n        DataBuf                 VAR_2;\n        unsigned char           VAR_3[103]={0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,\n                                            0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,\n                                            0,0,0,0,0,0,0,0,0,1, 2,3,4,5,6,7,8,9,0,0,\n                                            0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,\n                                            0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,10,11,12,\n                                            13,14,15};\n        if (VAR_0.size_ == 0) {\n            return DataBuf();\n        }\n\n        if ( VAR_1 ) {\n            VAR_2.alloc(VAR_0.size_);\n            ::memcpy(VAR_2.pData_,VAR_0.pData_,VAR_0.size_);\n            return  VAR_2;\n        }\n\n        const char *VAR_4 = (char*)VAR_0.pData_+1;\n        int VAR_5 = 1;\n\n        /* COMMENT_0 */\n        while (*VAR_4 != '\\n' && VAR_5 < (VAR_0.size_ - 1))\n        {\n            VAR_4++;\n            VAR_5++;\n        }\n\n        /* COMMENT_1 */\n        while ((*VAR_4 == '\\0' || *VAR_4 == ' ' || *VAR_4 == '\\n') && VAR_5 < (VAR_0.size_ - 1))\n        {\n            VAR_4++;\n            VAR_5++;\n        }\n\n        if (VAR_5 == (VAR_0.size_ - 1))\n        {\n            return DataBuf();\n        }\n\n        long VAR_6 = (long) atol(VAR_4);\n\n        while (*VAR_4 != ' ' && *VAR_4 != '\\n' && VAR_5 < (VAR_0.size_ - 1))\n        {\n            VAR_4++;\n            VAR_5++;\n        }\n\n        if (VAR_5 == (VAR_0.size_ - 1))\n        {\n            return DataBuf();\n        }\n\n        /* COMMENT_2 */\n\n        if (VAR_6 == 0)\n        {\n#ifdef VAR_7\n            std::cerr << \"Exiv2::PngChunk::readRawProfile: Unable To Copy Raw Profile: invalid profile length\\n\";\n#endif\n        }\n\n        VAR_2.alloc(VAR_6);\n\n        if (VAR_2.size_ != VAR_6)\n        {\n#ifdef VAR_7\n            std::cerr << \"Exiv2::PngChunk::readRawProfile: Unable To Copy Raw Profile: cannot allocate memory\\n\";\n#endif\n            return DataBuf();\n        }\n\n        /* COMMENT_3 */\n\n        unsigned char *VAR_8 = (unsigned char*)VAR_2.pData_;\n        unsigned int VAR_9 = VAR_6 * 2;\n\n        for (long VAR_10 = 0; VAR_10 < (long) VAR_9; VAR_10++)\n        {\n            while (*VAR_4 < '0' || (*VAR_4 > '9' && *VAR_4 < 'a') || *VAR_4 > 'f')\n            {\n                if (*VAR_4 == '\\0')\n                {\n#ifdef VAR_7\n                    std::cerr << \"Exiv2::PngChunk::readRawProfile: Unable To Copy Raw Profile: ran out of data\\n\";\n#endif\n                    return DataBuf();\n                }\n\n                VAR_4++;\n            }\n\n            if (VAR_10%2 == 0)\n                *VAR_8 = (unsigned char) (16*VAR_3[(int) *VAR_4++]);\n            else\n                (*VAR_8++) += VAR_3[(int) *VAR_4++];\n        }\n\n        return VAR_2;\n\n    }",
  "func_graph_path": "Exiv2/exiv2/cf3ba049a2792ec2a4a877e343f5dd9654da53dc/pngchunk_int.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,11 +1,6 @@\n DataBuf PngChunk::readRawProfile(const DataBuf& text,bool iTXt)\n     {\n         DataBuf                 info;\n-        register long           i;\n-        register unsigned char *dp;\n-        const char             *sp;\n-        unsigned int            nibbles;\n-        long                    length;\n         unsigned char           unhex[103]={0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,\n                                             0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,\n                                             0,0,0,0,0,0,0,0,0,1, 2,3,4,5,6,7,8,9,0,0,\n@@ -22,12 +17,18 @@\n             return  info;\n         }\n \n-\n-        sp = (char*)text.pData_+1;\n+        const char *sp = (char*)text.pData_+1;\n         int pointerPos = 1;\n \n         // Look for newline\n         while (*sp != '\\n' && pointerPos < (text.size_ - 1))\n+        {\n+            sp++;\n+            pointerPos++;\n+        }\n+\n+        // Look for length\n+        while ((*sp == '\\0' || *sp == ' ' || *sp == '\\n') && pointerPos < (text.size_ - 1))\n         {\n             sp++;\n             pointerPos++;\n@@ -38,15 +39,18 @@\n             return DataBuf();\n         }\n \n-        // Look for length\n+        long length = (long) atol(sp);\n \n-        while (*sp == '\\0' || *sp == ' ' || *sp == '\\n')\n+        while (*sp != ' ' && *sp != '\\n' && pointerPos < (text.size_ - 1))\n+        {\n             sp++;\n+            pointerPos++;\n+        }\n \n-        length = (long) atol(sp);\n-\n-        while (*sp != ' ' && *sp != '\\n')\n-            sp++;\n+        if (pointerPos == (text.size_ - 1))\n+        {\n+            return DataBuf();\n+        }\n \n         // Allocate space\n \n@@ -69,10 +73,10 @@\n \n         // Copy profile, skipping white space and column 1 \"=\" signs\n \n-        dp      = (unsigned char*)info.pData_;\n-        nibbles = length * 2;\n+        unsigned char *dp = (unsigned char*)info.pData_;\n+        unsigned int nibbles = length * 2;\n \n-        for (i = 0; i < (long) nibbles; i++)\n+        for (long i = 0; i < (long) nibbles; i++)\n         {\n             while (*sp < '0' || (*sp > '9' && *sp < 'a') || *sp > 'f')\n             {",
  "diff_line_info": {
    "deleted_lines": [
      "        register long           i;",
      "        register unsigned char *dp;",
      "        const char             *sp;",
      "        unsigned int            nibbles;",
      "        long                    length;",
      "",
      "        sp = (char*)text.pData_+1;",
      "        // Look for length",
      "        while (*sp == '\\0' || *sp == ' ' || *sp == '\\n')",
      "        length = (long) atol(sp);",
      "",
      "        while (*sp != ' ' && *sp != '\\n')",
      "            sp++;",
      "        dp      = (unsigned char*)info.pData_;",
      "        nibbles = length * 2;",
      "        for (i = 0; i < (long) nibbles; i++)"
    ],
    "added_lines": [
      "        const char *sp = (char*)text.pData_+1;",
      "        {",
      "            sp++;",
      "            pointerPos++;",
      "        }",
      "",
      "        // Look for length",
      "        while ((*sp == '\\0' || *sp == ' ' || *sp == '\\n') && pointerPos < (text.size_ - 1))",
      "        long length = (long) atol(sp);",
      "        while (*sp != ' ' && *sp != '\\n' && pointerPos < (text.size_ - 1))",
      "        {",
      "            pointerPos++;",
      "        }",
      "        if (pointerPos == (text.size_ - 1))",
      "        {",
      "            return DataBuf();",
      "        }",
      "        unsigned char *dp = (unsigned char*)info.pData_;",
      "        unsigned int nibbles = length * 2;",
      "        for (long i = 0; i < (long) nibbles; i++)"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/Exiv2/exiv2/pull/430",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/Exiv2/exiv2/pull/430: 403 Client Error: Forbidden for url: https://api.github.com/repos/Exiv2/exiv2/pulls/430",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.7,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.7"
}