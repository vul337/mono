{
  "cve_id": "CVE-2018-1000618",
  "cwe_ids": [
    "CWE-674"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "EOSIO/eos",
  "commit_msg": "Pass recursion_depth to binary_to_variant and variant_to_binary",
  "commit_hash": "cc5722858cc24808f7bd4fa699718eec0240b3a2",
  "git_url": "https://github.com/EOSIO/eos/commit/cc5722858cc24808f7bd4fa699718eec0240b3a2",
  "file_path": "libraries/chain/include/eosio/chain/abi_serializer.hpp",
  "func_name": "extract",
  "func_before": "static void extract( const variant& v, action& act, Resolver resolver, size_t recursion_depth )\n      {\n         FC_ASSERT( ++recursion_depth < abi_serializer::max_recursion_depth, \"recursive definition, max_recursion_depth\" );\n         const variant_object& vo = v.get_object();\n         EOS_ASSERT(vo.contains(\"account\"), packed_transaction_type_exception, \"Missing account\");\n         EOS_ASSERT(vo.contains(\"name\"), packed_transaction_type_exception, \"Missing name\");\n         from_variant(vo[\"account\"], act.account);\n         from_variant(vo[\"name\"], act.name);\n\n         if (vo.contains(\"authorization\")) {\n            from_variant(vo[\"authorization\"], act.authorization);\n         }\n\n         bool valid_empty_data = false;\n         if( vo.contains( \"data\" ) ) {\n            const auto& data = vo[\"data\"];\n            if( data.is_string() ) {\n               from_variant(data, act.data);\n               valid_empty_data = act.data.empty();\n            } else if ( data.is_object() ) {\n               auto abi = resolver(act.account);\n               if (abi.valid()) {\n                  auto type = abi->get_action_type(act.name);\n                  if (!type.empty()) {\n                     act.data = std::move( abi->variant_to_binary( type, data ));\n                     valid_empty_data = act.data.empty();\n                  }\n               }\n            }\n         }\n\n         if( !valid_empty_data && act.data.empty() ) {\n            if( vo.contains( \"hex_data\" ) ) {\n               const auto& data = vo[\"hex_data\"];\n               if( data.is_string() ) {\n                  from_variant(data, act.data);\n               }\n            }\n         }\n\n         EOS_ASSERT(valid_empty_data || !act.data.empty(), packed_transaction_type_exception,\n                    \"Failed to deserialize data for ${account}:${name}\", (\"account\", act.account)(\"name\", act.name));\n      }",
  "abstract_func_before": "static void extract( const variant& VAR_0, action& VAR_1, Resolver VAR_2, size_t VAR_3 )\n      {\n         FC_ASSERT( ++VAR_3 < abi_serializer::max_recursion_depth, \"recursive definition, max_recursion_depth\" );\n         const variant_object& VAR_4 = VAR_0.get_object();\n         EOS_ASSERT(VAR_4.contains(\"account\"), VAR_5, \"Missing account\");\n         EOS_ASSERT(VAR_4.contains(\"name\"), VAR_5, \"Missing name\");\n         from_variant(VAR_4[\"account\"], VAR_1.account);\n         from_variant(VAR_4[\"name\"], VAR_1.name);\n\n         if (VAR_4.contains(\"authorization\")) {\n            from_variant(VAR_4[\"authorization\"], VAR_1.authorization);\n         }\n\n         bool VAR_6 = false;\n         if( VAR_4.contains( \"data\" ) ) {\n            const auto& VAR_7 = VAR_4[\"data\"];\n            if( VAR_7.is_string() ) {\n               from_variant(VAR_7, VAR_1.data);\n               VAR_6 = VAR_1.data.empty();\n            } else if ( VAR_7.is_object() ) {\n               auto VAR_8 = VAR_2(VAR_1.account);\n               if (VAR_8.valid()) {\n                  auto VAR_9 = VAR_8->get_action_type(VAR_1.name);\n                  if (!VAR_9.empty()) {\n                     VAR_1.data = std::move( VAR_8->variant_to_binary( VAR_9, VAR_7 ));\n                     VAR_6 = VAR_1.data.empty();\n                  }\n               }\n            }\n         }\n\n         if( !VAR_6 && VAR_1.data.empty() ) {\n            if( VAR_4.contains( \"hex_data\" ) ) {\n               const auto& VAR_7 = VAR_4[\"hex_data\"];\n               if( VAR_7.is_string() ) {\n                  from_variant(VAR_7, VAR_1.data);\n               }\n            }\n         }\n\n         EOS_ASSERT(VAR_6 || !VAR_1.data.empty(), VAR_5,\n                    \"Failed to deserialize data for ${account}:${name}\", (\"account\", VAR_1.account)(\"name\", VAR_1.name));\n      }",
  "func_graph_path_before": "EOSIO/eos/cc5722858cc24808f7bd4fa699718eec0240b3a2/abi_serializer.hpp/vul/before/0.json",
  "func": "static void extract( const variant& v, action& act, Resolver resolver, size_t recursion_depth )\n      {\n         FC_ASSERT( ++recursion_depth < abi_serializer::max_recursion_depth, \"recursive definition, max_recursion_depth\" );\n         const variant_object& vo = v.get_object();\n         EOS_ASSERT(vo.contains(\"account\"), packed_transaction_type_exception, \"Missing account\");\n         EOS_ASSERT(vo.contains(\"name\"), packed_transaction_type_exception, \"Missing name\");\n         from_variant(vo[\"account\"], act.account);\n         from_variant(vo[\"name\"], act.name);\n\n         if (vo.contains(\"authorization\")) {\n            from_variant(vo[\"authorization\"], act.authorization);\n         }\n\n         bool valid_empty_data = false;\n         if( vo.contains( \"data\" ) ) {\n            const auto& data = vo[\"data\"];\n            if( data.is_string() ) {\n               from_variant(data, act.data);\n               valid_empty_data = act.data.empty();\n            } else if ( data.is_object() ) {\n               auto abi = resolver(act.account);\n               if (abi.valid()) {\n                  auto type = abi->get_action_type(act.name);\n                  if (!type.empty()) {\n                     act.data = std::move( abi->_variant_to_binary( type, data, recursion_depth ));\n                     valid_empty_data = act.data.empty();\n                  }\n               }\n            }\n         }\n\n         if( !valid_empty_data && act.data.empty() ) {\n            if( vo.contains( \"hex_data\" ) ) {\n               const auto& data = vo[\"hex_data\"];\n               if( data.is_string() ) {\n                  from_variant(data, act.data);\n               }\n            }\n         }\n\n         EOS_ASSERT(valid_empty_data || !act.data.empty(), packed_transaction_type_exception,\n                    \"Failed to deserialize data for ${account}:${name}\", (\"account\", act.account)(\"name\", act.name));\n      }",
  "abstract_func": "static void extract( const variant& VAR_0, action& VAR_1, Resolver VAR_2, size_t VAR_3 )\n      {\n         FC_ASSERT( ++VAR_3 < abi_serializer::max_recursion_depth, \"recursive definition, max_recursion_depth\" );\n         const variant_object& VAR_4 = VAR_0.get_object();\n         EOS_ASSERT(VAR_4.contains(\"account\"), VAR_5, \"Missing account\");\n         EOS_ASSERT(VAR_4.contains(\"name\"), VAR_5, \"Missing name\");\n         from_variant(VAR_4[\"account\"], VAR_1.account);\n         from_variant(VAR_4[\"name\"], VAR_1.name);\n\n         if (VAR_4.contains(\"authorization\")) {\n            from_variant(VAR_4[\"authorization\"], VAR_1.authorization);\n         }\n\n         bool VAR_6 = false;\n         if( VAR_4.contains( \"data\" ) ) {\n            const auto& VAR_7 = VAR_4[\"data\"];\n            if( VAR_7.is_string() ) {\n               from_variant(VAR_7, VAR_1.data);\n               VAR_6 = VAR_1.data.empty();\n            } else if ( VAR_7.is_object() ) {\n               auto VAR_8 = VAR_2(VAR_1.account);\n               if (VAR_8.valid()) {\n                  auto VAR_9 = VAR_8->get_action_type(VAR_1.name);\n                  if (!VAR_9.empty()) {\n                     VAR_1.data = std::move( VAR_8->_variant_to_binary( VAR_9, VAR_7, VAR_3 ));\n                     VAR_6 = VAR_1.data.empty();\n                  }\n               }\n            }\n         }\n\n         if( !VAR_6 && VAR_1.data.empty() ) {\n            if( VAR_4.contains( \"hex_data\" ) ) {\n               const auto& VAR_7 = VAR_4[\"hex_data\"];\n               if( VAR_7.is_string() ) {\n                  from_variant(VAR_7, VAR_1.data);\n               }\n            }\n         }\n\n         EOS_ASSERT(VAR_6 || !VAR_1.data.empty(), VAR_5,\n                    \"Failed to deserialize data for ${account}:${name}\", (\"account\", VAR_1.account)(\"name\", VAR_1.name));\n      }",
  "func_graph_path": "EOSIO/eos/cc5722858cc24808f7bd4fa699718eec0240b3a2/abi_serializer.hpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -22,7 +22,7 @@\n                if (abi.valid()) {\n                   auto type = abi->get_action_type(act.name);\n                   if (!type.empty()) {\n-                     act.data = std::move( abi->variant_to_binary( type, data ));\n+                     act.data = std::move( abi->_variant_to_binary( type, data, recursion_depth ));\n                      valid_empty_data = act.data.empty();\n                   }\n                }",
  "diff_line_info": {
    "deleted_lines": [
      "                     act.data = std::move( abi->variant_to_binary( type, data ));"
    ],
    "added_lines": [
      "                     act.data = std::move( abi->_variant_to_binary( type, data, recursion_depth ));"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/EOSIO/eos/pull/4112",
  "description": {
    "pr_info": {
      "title": "Pretty print transactions",
      "number": 4112
    },
    "comment": [
      "Enhanced the abi_serializer to be able to deserialize transactions even if they have invalid abi set on the contract. So even with invalid abi the transaction can still be pretty-printed. In the case of invalid abi the action data is left in hex since there is no way to deserialize it. This allows indexers like the mongodb plugin to serialize the parts of transaction that are serializable without the user provided abi.\r\n\r\nI suspect this will fix issue #4111 that was just submitted.",
      "@heifner My issue is still there. [issue#4111](https://github.com/EOSIO/eos/issues/4111)\r\nThis is the error I'm getting:\r\nInvalid packed transaction\r\npivot != std::string::npos: No delimiter in string, cannot determine type: EOSK59ovuuemzcGX1QKATF4pEVg2AmUT2rjQAH8MrC52SpmBZ59YPVYMFYTBg7XNgCDQcX18vMyDsjEp4SbyDnkcUvruZ94BX\r\nFailed to deserialize variant",
      "This is the command I'm using and getting error:\r\ncleos -H node1.eosphere.io --wallet-host localhost --wallet-port 8888 set contract eosuser build/contracts/eosio.token -p eosuser\r\n\r\nGetting same error for every contract\r\n\r\ncleos version client: 15953cc1\r\n\r\nPlease, help me to fix this.\r\nThanks",
      "@heifner The problem is coming from here /eos/libraries/fc/src/crypto/signature.cpp:\r\n const auto pivot = base58str.find('_');\r\n      FC_ASSERT(pivot != std::string::npos, \"No delimiter in string, cannot determine type: ${str}\", (\"str\", base58str));\r\n"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades;  \n**Confidence:** 0.8  \n\nThe patch addresses a functional issue with handling invalid ABIs by enhancing the deserialization process, but no security vulnerability is indicated."
}