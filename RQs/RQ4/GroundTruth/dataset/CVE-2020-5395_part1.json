{
  "cve_id": "CVE-2020-5395",
  "cwe_ids": [
    "CWE-416"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "fontforge",
  "commit_msg": "Fix for #4084 Use-after-free (heap) in the SFD_GetFontMetaData() function\nFix for #4086 NULL pointer dereference in the SFDGetSpiros() function\nFix for #4088 NULL pointer dereference in the SFD_AssignLookups() function\nAdd empty sf->fontname string if it isn't set, fixing #4089 #4090 and many\n  other potential issues (many downstream calls to strlen() on the value).",
  "commit_hash": "8da6d56bf7af2d25f779e52edef61b2fd4557b3c",
  "git_url": "https://github.com/fontforge/fontforge/commit/8da6d56bf7af2d25f779e52edef61b2fd4557b3c",
  "file_path": "fontforge/sfd.c",
  "func_name": "SFD_GetFont",
  "func_before": "static SplineFont *SFD_GetFont( FILE *sfd,SplineFont *cidmaster,char *tok,\n\t\t\t\tint fromdir, char *dirname, float sfdversion )\n{\n    SplineFont *sf;\n    int realcnt, i, eof, mappos=-1, ch;\n    struct table_ordering *lastord = NULL;\n    struct axismap *lastaxismap = NULL;\n    struct named_instance *lastnamedinstance = NULL;\n    int pushedbacktok = false;\n    Encoding *enc = &custom;\n    struct remap *remap = NULL;\n    int haddupenc;\n    int old_style_order2 = false;\n    int had_layer_cnt=false;\n\n    orig_pos = 0;\t\t/* Only used for compatibility with extremely old sfd files */\n\n    sf = SplineFontEmpty();\n    if ( sfdversion>0 && sfdversion<2 ) {\n\t/* If it's an old style sfd file with old style features we need some */\n\t/*  extra data space to do the conversion from old to new */\n\tsf = realloc(sf,sizeof(SplineFont1));\n\tmemset(((uint8 *) sf) + sizeof(SplineFont),0,sizeof(SplineFont1)-sizeof(SplineFont));\n    }\n    sf->sfd_version = sfdversion;\n    sf->cidmaster = cidmaster;\n    sf->uni_interp = ui_unset;\n\tSFD_GetFontMetaDataData d;\n\tSFD_GetFontMetaDataData_Init( &d );\n    while ( 1 ) {\n\tif ( pushedbacktok )\n\t    pushedbacktok = false;\n\telse if ( (eof = getname(sfd,tok))!=1 ) {\n\t    if ( eof==-1 )\n    break;\n\t    geteol(sfd,tok);\n    continue;\n\t}\n\n\n\tbool wasMetadata = SFD_GetFontMetaData( sfd, tok, sf, &d );\n\thad_layer_cnt = d.had_layer_cnt;\n        if( wasMetadata )\n        {\n            // we have handled the token entirely\n            // inside SFD_GetFontMetaData() move to next token.\n            continue;\n        }\n        \n        \n\tif ( strmatch(tok,\"DisplaySize:\")==0 )\n\t{\n\t    getint(sfd,&sf->display_size);\n\t}\n\telse if ( strmatch(tok,\"DisplayLayer:\")==0 )\n\t{\n\t    getint(sfd,&sf->display_layer);\n\t}\n\telse if ( strmatch(tok,\"ExtremaBound:\")==0 )\n\t{\n\t    getint(sfd,&sf->extrema_bound);\n\t}\n\telse if ( strmatch(tok,\"WidthSeparation:\")==0 )\n\t{\n\t    getint(sfd,&sf->width_separation);\n\t}\n\telse if ( strmatch(tok,\"WinInfo:\")==0 )\n\t{\n\t    int temp1, temp2;\n\t    getint(sfd,&sf->top_enc);\n\t    getint(sfd,&temp1);\n\t    getint(sfd,&temp2);\n\t    if ( sf->top_enc<=0 ) sf->top_enc=-1;\n\t    if ( temp1<=0 ) temp1 = 16;\n\t    if ( temp2<=0 ) temp2 = 4;\n\t    sf->desired_col_cnt = temp1;\n\t    sf->desired_row_cnt = temp2;\n\t}\n\telse if ( strmatch(tok,\"AntiAlias:\")==0 )\n\t{\n\t    int temp;\n\t    getint(sfd,&temp);\n\t    sf->display_antialias = temp;\n\t}\n\telse if ( strmatch(tok,\"FitToEm:\")==0 )\n\t{\n\t    int temp;\n\t    getint(sfd,&temp);\n\t    sf->display_bbsized = temp;\n\t}\n\telse if ( strmatch(tok,\"OnlyBitmaps:\")==0 )\n\t{\n\t    int temp;\n\t    getint(sfd,&temp);\n\t    sf->onlybitmaps = temp;\n\t}\n\telse if ( strmatch(tok,\"Order2:\")==0 )\n\t{\n\t    getint(sfd,&old_style_order2);\n\t    sf->grid.order2 = old_style_order2;\n\t    sf->layers[ly_back].order2 = old_style_order2;\n\t    sf->layers[ly_fore].order2 = old_style_order2;\n\t}\n\telse if ( strmatch(tok,\"GridOrder2:\")==0 )\n\t{\n\t    int o2;\n\t    getint(sfd,&o2);\n\t    sf->grid.order2 = o2;\n\t}\n\telse if ( strmatch(tok,\"Encoding:\")==0 )\n\t{\n\t    enc = SFDGetEncoding(sfd,tok);\n\t    if ( sf->map!=NULL ) sf->map->enc = enc;\n\t}\n\telse if ( strmatch(tok,\"OldEncoding:\")==0 )\n\t{\n\t    /* old_encname =*/ (void) SFDGetEncoding(sfd,tok);\n\t}\n\telse if ( strmatch(tok,\"UnicodeInterp:\")==0 )\n\t{\n\t    sf->uni_interp = SFDGetUniInterp(sfd,tok,sf);\n\t}\n\telse if ( strmatch(tok,\"NameList:\")==0 )\n\t{\n\t    SFDGetNameList(sfd,tok,sf);\n\t}\n\telse if ( strmatch(tok,\"Compacted:\")==0 )\n\t{\n\t    int temp;\n\t    getint(sfd,&temp);\n\t    sf->compacted = temp;\n\t}\n\telse if ( strmatch(tok,\"Registry:\")==0 )\n\t{\n\t    geteol(sfd,tok);\n\t    sf->cidregistry = copy(tok);\n\t}\n\n\n\t//////////\n\n\n\telse if ( strmatch(tok,\"Ordering:\")==0 ) {\n\t    geteol(sfd,tok);\n\t    sf->ordering = copy(tok);\n\t} else if ( strmatch(tok,\"Supplement:\")==0 ) {\n\t    getint(sfd,&sf->supplement);\n\t} else if ( strmatch(tok,\"RemapN:\")==0 ) {\n\t    int n;\n\t    getint(sfd,&n);\n\t    remap = calloc(n+1,sizeof(struct remap));\n\t    remap[n].infont = -1;\n\t    mappos = 0;\n\t    if ( sf->map!=NULL ) sf->map->remap = remap;\n\t} else if ( strmatch(tok,\"Remap:\")==0 ) {\n\t    uint32 f, l; int p;\n\t    gethex(sfd,&f);\n\t    gethex(sfd,&l);\n\t    getint(sfd,&p);\n\t    if ( remap!=NULL && remap[mappos].infont!=-1 ) {\n\t\tremap[mappos].firstenc = f;\n\t\tremap[mappos].lastenc = l;\n\t\tremap[mappos].infont = p;\n\t\tmappos++;\n\t    }\n\t} else if ( strmatch(tok,\"CIDVersion:\")==0 ) {\n\t    real temp;\n\t    getreal(sfd,&temp);\n\t    sf->cidversion = temp;\n\t} else if ( strmatch(tok,\"Grid\")==0 ) {\n\t    sf->grid.splines = SFDGetSplineSet(sfd,sf->grid.order2);\n\t} else if ( strmatch(tok,\"ScriptLang:\")==0 ) {\n\t    int i,j,k;\n\t    int imax, jmax, kmax;\n\t    if ( sf->sfd_version==0 || sf->sfd_version>=2 ) {\n\t\tIError( \"Script lang lists should not happen in version 2 sfd files.\" );\n                SplineFontFree(sf);\n                return NULL;\n\t    }\n\t    getint(sfd,&imax);\n\t    ((SplineFont1 *) sf)->sli_cnt = imax;\n\t    ((SplineFont1 *) sf)->script_lang = malloc((imax+1)*sizeof(struct script_record *));\n\t    ((SplineFont1 *) sf)->script_lang[imax] = NULL;\n\t    for ( i=0; i<imax; ++i ) {\n\t\tgetint(sfd,&jmax);\n\t\t((SplineFont1 *) sf)->script_lang[i] = malloc((jmax+1)*sizeof(struct script_record));\n\t\t((SplineFont1 *) sf)->script_lang[i][jmax].script = 0;\n\t\tfor ( j=0; j<jmax; ++j ) {\n\t\t    ((SplineFont1 *) sf)->script_lang[i][j].script = gettag(sfd);\n\t\t    getint(sfd,&kmax);\n\t\t    ((SplineFont1 *) sf)->script_lang[i][j].langs = malloc((kmax+1)*sizeof(uint32));\n\t\t    ((SplineFont1 *) sf)->script_lang[i][j].langs[kmax] = 0;\n\t\t    for ( k=0; k<kmax; ++k ) {\n\t\t\t((SplineFont1 *) sf)->script_lang[i][j].langs[k] = gettag(sfd);\n\t\t    }\n\t\t}\n\t    }\n\t} else if ( strmatch(tok,\"TeXData:\")==0 ) {\n\t    int temp;\n\t    getint(sfd,&temp);\n\t    sf->texdata.type = temp;\n\t    getint(sfd, &temp);\n\t    if ( sf->design_size==0 ) {\n\t    \tsf->design_size = (5*temp+(1<<18))>>19;\n\t    }\n\t    for ( i=0; i<22; ++i ) {\n\t\tint foo;\n\t\tgetint(sfd,&foo);\n\t\tsf->texdata.params[i]=foo;\n\t    }\n\t} else if ( strnmatch(tok,\"AnchorClass\",11)==0 ) {\n\t    char *name;\n\t    AnchorClass *lastan = NULL, *an;\n\t    int old = strchr(tok,'2')==NULL;\n\t    while ( (name=SFDReadUTF7Str(sfd))!=NULL ) {\n\t\tan = chunkalloc(old ? sizeof(AnchorClass1) : sizeof(AnchorClass));\n\t\tan->name = name;\n\t\tif ( old ) {\n\t\t    getname(sfd,tok);\n\t\t    if ( tok[0]=='0' && tok[1]=='\\0' )\n\t\t\t((AnchorClass1 *) an)->feature_tag = 0;\n\t\t    else {\n\t\t\tif ( tok[1]=='\\0' ) { tok[1]=' '; tok[2] = 0; }\n\t\t\tif ( tok[2]=='\\0' ) { tok[2]=' '; tok[3] = 0; }\n\t\t\tif ( tok[3]=='\\0' ) { tok[3]=' '; tok[4] = 0; }\n\t\t\t((AnchorClass1 *) an)->feature_tag = (tok[0]<<24) | (tok[1]<<16) | (tok[2]<<8) | tok[3];\n\t\t    }\n\t\t    while ( (ch=nlgetc(sfd))==' ' || ch=='\\t' );\n\t\t    ungetc(ch,sfd);\n\t\t    if ( isdigit(ch)) {\n\t\t\tint temp;\n\t\t\tgetint(sfd,&temp);\n\t\t\t((AnchorClass1 *) an)->flags = temp;\n\t\t    }\n\t\t    while ( (ch=nlgetc(sfd))==' ' || ch=='\\t' );\n\t\t    ungetc(ch,sfd);\n\t\t    if ( isdigit(ch)) {\n\t\t\tint temp;\n\t\t\tgetint(sfd,&temp);\n\t\t\t((AnchorClass1 *) an)->script_lang_index = temp;\n\t\t    } else\n\t\t\t((AnchorClass1 *) an)->script_lang_index = 0xffff;\t\t/* Will be fixed up later */\n\t\t    while ( (ch=nlgetc(sfd))==' ' || ch=='\\t' );\n\t\t    ungetc(ch,sfd);\n\t\t    if ( isdigit(ch)) {\n\t\t\tint temp;\n\t\t\tgetint(sfd,&temp);\n\t\t\t((AnchorClass1 *) an)->merge_with = temp;\n\t\t    } else\n\t\t\t((AnchorClass1 *) an)->merge_with = 0xffff;\t\t\t/* Will be fixed up later */\n\t\t} else {\n                    char *subtable_name = SFDReadUTF7Str(sfd);\n                    if ( subtable_name!=NULL)                                           /* subtable is optional */\n\t\t        an->subtable = SFFindLookupSubtableAndFreeName(sf,subtable_name);\n                }\n\t\twhile ( (ch=nlgetc(sfd))==' ' || ch=='\\t' );\n\t\tungetc(ch,sfd);\n\t\tif ( isdigit(ch) ) {\n\t\t    /* Early versions of SfdFormat 2 had a number here */\n\t\t    int temp;\n\t\t    getint(sfd,&temp);\n\t\t    an->type = temp;\n\t\t} else if ( old ) {\n\t\t    if ( ((AnchorClass1 *) an)->feature_tag==CHR('c','u','r','s'))\n\t\t\tan->type = act_curs;\n\t\t    else if ( ((AnchorClass1 *) an)->feature_tag==CHR('m','k','m','k'))\n\t\t\tan->type = act_mkmk;\n\t\t    else\n\t\t\tan->type = act_mark;\n\t\t} else {\n\t\t    an->type = act_mark;\n\t\t    if( an->subtable && an->subtable->lookup )\n\t\t    {\n\t\t\tswitch ( an->subtable->lookup->lookup_type )\n\t\t\t{\n\t\t\tcase gpos_cursive:\n\t\t\t    an->type = act_curs;\n\t\t\t    break;\n\t\t\tcase gpos_mark2base:\n\t\t\t    an->type = act_mark;\n\t\t\t    break;\n\t\t\tcase gpos_mark2ligature:\n\t\t\t    an->type = act_mklg;\n\t\t\t    break;\n\t\t\tcase gpos_mark2mark:\n\t\t\t    an->type = act_mkmk;\n\t\t\t    break;\n\t\t\tdefault:\n\t\t\t    an->type = act_mark;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif ( lastan==NULL )\n\t\t    sf->anchor = an;\n\t\telse\n\t\t    lastan->next = an;\n\t\tlastan = an;\n\t    }\n\t} else if ( strncmp(tok,\"MATH:\",5)==0 ) {\n\t    SFDParseMathItem(sfd,sf,tok);\n\t} else if ( strmatch(tok,\"TableOrder:\")==0 ) {\n\t    int temp;\n\t    struct table_ordering *ord;\n\t    if ( sfdversion==0 || sfdversion>=2 ) {\n\t\tIError(\"Table ordering specified in version 2 sfd file.\\n\" );\n                SplineFontFree(sf);\n                return NULL;\n\t    }\n\t    ord = chunkalloc(sizeof(struct table_ordering));\n\t    ord->table_tag = gettag(sfd);\n\t    getint(sfd,&temp);\n\t    ord->ordered_features = malloc((temp+1)*sizeof(uint32));\n\t    ord->ordered_features[temp] = 0;\n\t    for ( i=0; i<temp; ++i ) {\n\t\twhile ( isspace((ch=nlgetc(sfd))) );\n\t\tif ( ch=='\\'' ) {\n\t\t    ungetc(ch,sfd);\n\t\t    ord->ordered_features[i] = gettag(sfd);\n\t\t} else if ( ch=='<' ) {\n\t\t    int f,s;\n\t\t    fscanf(sfd,\"%d,%d>\", &f, &s );\n\t\t    ord->ordered_features[i] = (f<<16)|s;\n\t\t}\n\t    }\n\t    if ( lastord==NULL )\n\t\t((SplineFont1 *) sf)->orders = ord;\n\t    else\n\t\tlastord->next = ord;\n\t    lastord = ord;\n\t} else if ( strmatch(tok,\"BeginPrivate:\")==0 ) {\n\t    SFDGetPrivate(sfd,sf);\n\t} else if ( strmatch(tok,\"BeginSubrs:\")==0 ) {\t/* leave in so we don't croak on old sfd files */\n\t    SFDGetSubrs(sfd);\n\t} else if ( strmatch(tok,\"PickledData:\")==0 ) {\n\t    if (sf->python_persistent != NULL) {\n#if defined(_NO_PYTHON)\n\t      free( sf->python_persistent );\t/* It's a string of pickled data which we leave as a string */\n#else\n\t      PyFF_FreePythonPersistent(sf->python_persistent);\n#endif\n\t      sf->python_persistent = NULL;\n\t    }\n\t    sf->python_persistent = SFDUnPickle(sfd, 0);\n\t    sf->python_persistent_has_lists = 0;\n\t} else if ( strmatch(tok,\"PickledDataWithLists:\")==0 ) {\n\t    if (sf->python_persistent != NULL) {\n#if defined(_NO_PYTHON)\n\t      free( sf->python_persistent );\t/* It's a string of pickled data which we leave as a string */\n#else\n\t      PyFF_FreePythonPersistent(sf->python_persistent);\n#endif\n\t      sf->python_persistent = NULL;\n\t    }\n\t    sf->python_persistent = SFDUnPickle(sfd, 1);\n\t    sf->python_persistent_has_lists = 1;\n\t} else if ( strmatch(tok,\"MMCounts:\")==0 ) {\n\t    MMSet *mm = sf->mm = chunkalloc(sizeof(MMSet));\n\t    getint(sfd,&mm->instance_count);\n\t    getint(sfd,&mm->axis_count);\n\t    ch = nlgetc(sfd);\n\t    if ( ch!=' ' )\n\t\tungetc(ch,sfd);\n\t    else { int temp;\n\t\tgetint(sfd,&temp);\n\t\tmm->apple = temp;\n\t\tgetint(sfd,&mm->named_instance_count);\n\t    }\n\t    mm->instances = calloc(mm->instance_count,sizeof(SplineFont *));\n\t    mm->positions = malloc(mm->instance_count*mm->axis_count*sizeof(real));\n\t    mm->defweights = malloc(mm->instance_count*sizeof(real));\n\t    mm->axismaps = calloc(mm->axis_count,sizeof(struct axismap));\n\t    if ( mm->named_instance_count!=0 )\n\t\tmm->named_instances = calloc(mm->named_instance_count,sizeof(struct named_instance));\n\t} else if ( strmatch(tok,\"MMAxis:\")==0 ) {\n\t    MMSet *mm = sf->mm;\n\t    if ( mm!=NULL ) {\n\t\tfor ( i=0; i<mm->axis_count; ++i ) {\n\t\t    getname(sfd,tok);\n\t\t    mm->axes[i] = copy(tok);\n\t\t}\n\t    }\n\t} else if ( strmatch(tok,\"MMPositions:\")==0 ) {\n\t    MMSet *mm = sf->mm;\n\t    if ( mm!=NULL ) {\n\t\tfor ( i=0; i<mm->axis_count*mm->instance_count; ++i )\n\t\t    getreal(sfd,&mm->positions[i]);\n\t    }\n\t} else if ( strmatch(tok,\"MMWeights:\")==0 ) {\n\t    MMSet *mm = sf->mm;\n\t    if ( mm!=NULL ) {\n\t\tfor ( i=0; i<mm->instance_count; ++i )\n\t\t    getreal(sfd,&mm->defweights[i]);\n\t    }\n\t} else if ( strmatch(tok,\"MMAxisMap:\")==0 ) {\n\t    MMSet *mm = sf->mm;\n\t    if ( mm!=NULL ) {\n\t\tint index, points;\n\t\tgetint(sfd,&index); getint(sfd,&points);\n\t\tmm->axismaps[index].points = points;\n\t\tmm->axismaps[index].blends = malloc(points*sizeof(real));\n\t\tmm->axismaps[index].designs = malloc(points*sizeof(real));\n\t\tfor ( i=0; i<points; ++i ) {\n\t\t    getreal(sfd,&mm->axismaps[index].blends[i]);\n\t\t    while ( (ch=nlgetc(sfd))!=EOF && isspace(ch));\n\t\t    ungetc(ch,sfd);\n\t\t    if ( (ch=nlgetc(sfd))!='=' )\n\t\t\tungetc(ch,sfd);\n\t\t    else if ( (ch=nlgetc(sfd))!='>' )\n\t\t\tungetc(ch,sfd);\n\t\t    getreal(sfd,&mm->axismaps[index].designs[i]);\n\t\t}\n\t\tlastaxismap = &mm->axismaps[index];\n\t\tlastnamedinstance = NULL;\n\t    }\n\t} else if ( strmatch(tok,\"MMNamedInstance:\")==0 ) {\n\t    MMSet *mm = sf->mm;\n\t    if ( mm!=NULL ) {\n\t\tint index;\n\t\tgetint(sfd,&index);\n\t\tmm->named_instances[index].coords = malloc(mm->axis_count*sizeof(real));\n\t\tfor ( i=0; i<mm->axis_count; ++i )\n\t\t    getreal(sfd,&mm->named_instances[index].coords[i]);\n\t\tlastnamedinstance = &mm->named_instances[index];\n\t\tlastaxismap = NULL;\n\t    }\n\t} else if ( strmatch(tok,\"MacName:\")==0 ) {\n\t    struct macname *names = SFDParseMacNames(sfd,tok);\n\t    if ( lastaxismap!=NULL )\n\t\tlastaxismap->axisnames = names;\n\t    else if ( lastnamedinstance !=NULL )\n\t\tlastnamedinstance->names = names;\n\t    pushedbacktok = true;\n\t} else if ( strmatch(tok,\"MMCDV:\")==0 ) {\n\t    MMSet *mm = sf->mm;\n\t    if ( mm!=NULL )\n\t\tmm->cdv = SFDParseMMSubroutine(sfd);\n\t} else if ( strmatch(tok,\"MMNDV:\")==0 ) {\n\t    MMSet *mm = sf->mm;\n\t    if ( mm!=NULL )\n\t\tmm->ndv = SFDParseMMSubroutine(sfd);\n\t} else if ( strmatch(tok,\"BeginMMFonts:\")==0 ) {\n\t    int cnt;\n\t    getint(sfd,&cnt);\n\t    getint(sfd,&realcnt);\n\t    ff_progress_change_stages(cnt);\n\t    ff_progress_change_total(realcnt);\n\t    MMInferStuff(sf->mm);\n    break;\n\t} else if ( strmatch(tok,\"BeginSubFonts:\")==0 ) {\n\t    getint(sfd,&sf->subfontcnt);\n\t    sf->subfonts = calloc(sf->subfontcnt,sizeof(SplineFont *));\n\t    getint(sfd,&realcnt);\n\t    sf->map = EncMap1to1(realcnt);\n\t    ff_progress_change_stages(2);\n\t    ff_progress_change_total(realcnt);\n    break;\n\t} else if ( strmatch(tok,\"BeginChars:\")==0 ) {\n\t    int charcnt;\n\t    getint(sfd,&charcnt);\n\t    if (charcnt<enc->char_cnt) {\n\t\tIError(\"SFD file specifies too few slots for its encoding.\\n\" );\nexit( 1 );\n\t    }\n\t    if ( getint(sfd,&realcnt)!=1 || realcnt==-1 )\n\t\trealcnt = charcnt;\n\t    else\n\t\t++realcnt;\t\t/* value saved is max glyph, not glyph cnt */\n\t    ff_progress_change_total(realcnt);\n\t    sf->glyphcnt = sf->glyphmax = realcnt;\n\t    sf->glyphs = calloc(realcnt,sizeof(SplineChar *));\n\t    if ( cidmaster!=NULL ) {\n\t\tsf->map = cidmaster->map;\n\t    } else {\n\t\tsf->map = EncMapNew(charcnt,realcnt,enc);\n\t\tsf->map->remap = remap;\n\t    }\n\t    SFDSizeMap(sf->map,sf->glyphcnt,charcnt);\n    break;\n#if HANYANG\n\t} else if ( strmatch(tok,\"BeginCompositionRules\")==0 ) {\n\t    sf->rules = SFDReadCompositionRules(sfd);\n#endif\n\t} else {\n\t    /* If we don't understand it, skip it */\n\t    geteol(sfd,tok);\n\t}\n    }\n\n    if ( fromdir )\n\tsf = SFD_FigureDirType(sf,tok,dirname,enc,remap,had_layer_cnt);\n    else if ( sf->subfontcnt!=0 ) {\n\tff_progress_change_stages(2*sf->subfontcnt);\n\tfor ( i=0; i<sf->subfontcnt; ++i ) {\n\t    if ( i!=0 )\n\t\tff_progress_next_stage();\n\t    sf->subfonts[i] = SFD_GetFont(sfd,sf,tok,fromdir,dirname,sfdversion);\n\t}\n    } else if ( sf->mm!=NULL ) {\n\tMMSet *mm = sf->mm;\n\tff_progress_change_stages(2*(mm->instance_count+1));\n\tfor ( i=0; i<mm->instance_count; ++i ) {\n\t    if ( i!=0 )\n\t\tff_progress_next_stage();\n\t    mm->instances[i] = SFD_GetFont(sfd,NULL,tok,fromdir,dirname,sfdversion);\n\t    EncMapFree(mm->instances[i]->map); mm->instances[i]->map=NULL;\n\t    mm->instances[i]->mm = mm;\n\t}\n\tff_progress_next_stage();\n\tmm->normal = SFD_GetFont(sfd,NULL,tok,fromdir,dirname,sfdversion);\n\tmm->normal->mm = mm;\n\tsf->mm = NULL;\n\tSplineFontFree(sf);\n\tsf = mm->normal;\n\tif ( sf->map->enc!=&custom ) {\n\t    EncMap *map;\n\t    MMMatchGlyphs(mm);\t\t/* sfd files from before the encoding change can have mismatched orig pos */\n\t    map = EncMapFromEncoding(sf,sf->map->enc);\n\t    EncMapFree(sf->map);\n\t    sf->map = map;\n\t}\n    } else {\n\twhile ( SFDGetChar(sfd,sf,had_layer_cnt)!=NULL ) {\n\t    ff_progress_next();\n\t}\n\tff_progress_next_stage();\n    }\n    haddupenc = false;\n    while ( getname(sfd,tok)==1 ) {\n\tif ( strcmp(tok,\"EndSplineFont\")==0 || strcmp(tok,\"EndSubSplineFont\")==0 )\n    break;\n\telse if ( strcmp(tok,\"BitmapFont:\")==0 )\n\t    SFDGetBitmapFont(sfd,sf,false,NULL);\n\telse if ( strmatch(tok,\"DupEnc:\")==0 ) {\n\t    int enc, orig;\n\t    haddupenc = true;\n\t    if ( getint(sfd,&enc) && getint(sfd,&orig) && sf->map!=NULL ) {\n\t\tSFDSetEncMap(sf,orig,enc);\n\t    }\n\t}\n    }\n    if ( sf->cidmaster==NULL )\n\tSFDFixupRefs(sf);\n\n    if ( !haddupenc )\n\tSFD_DoAltUnis(sf);\n    else\n\tAltUniFigure(sf,sf->map,true);\n    if ( sf->sfd_version<2 )\n\tSFD_AssignLookups((SplineFont1 *) sf);\n    if ( !d.hadtimes )\n\tSFTimesFromFile(sf,sfd);\n    // Make a blank encoding if there are no characters so as to avoid crashes later.\n    if (sf->map == NULL) sf->map = EncMapNew(sf->glyphcnt,sf->glyphcnt,&custom);\n\n    SFDFixupUndoRefs(sf);\nreturn( sf );\n}",
  "abstract_func_before": "static SplineFont *SFD_GetFont( FILE *VAR_0,SplineFont *VAR_1,char *VAR_2,\n\t\t\t\tint VAR_3, char *VAR_4, float VAR_5 )\n{\n    SplineFont *VAR_6;\n    int VAR_7, VAR_8, VAR_9, VAR_10=-1, VAR_11;\n    struct table_ordering *VAR_12 = NULL;\n    struct axismap *VAR_13 = NULL;\n    struct named_instance *VAR_14 = NULL;\n    int VAR_15 = false;\n    Encoding *VAR_16 = &VAR_17;\n    struct remap *remap = NULL;\n    int VAR_18;\n    int VAR_19 = false;\n    int VAR_20=false;\n\n    VAR_21 = 0;\t\t/* COMMENT_0 */\n\n    VAR_6 = SplineFontEmpty();\n    if ( VAR_5>0 && VAR_5<2 ) {\n\t/* COMMENT_1 */\n\t/* COMMENT_2 */\n\tVAR_6 = realloc(VAR_6,sizeof(VAR_22));\n\tmemset(((uint8 *) VAR_6) + sizeof(SplineFont),0,sizeof(VAR_22)-sizeof(SplineFont));\n    }\n    VAR_6->sfd_version = VAR_5;\n    VAR_6->cidmaster = VAR_1;\n    VAR_6->uni_interp = VAR_23;\n\tSFD_GetFontMetaDataData VAR_24;\n\tSFD_GetFontMetaDataData_Init( &VAR_24 );\n    while ( 1 ) {\n\tif ( VAR_15 )\n\t    VAR_15 = false;\n\telse if ( (VAR_9 = getname(VAR_0,VAR_2))!=1 ) {\n\t    if ( VAR_9==-1 )\n    break;\n\t    geteol(VAR_0,VAR_2);\n    continue;\n\t}\n\n\n\tbool VAR_25 = SFD_GetFontMetaData( VAR_0, VAR_2, VAR_6, &VAR_24 );\n\tVAR_20 = VAR_24.had_layer_cnt;\n        if( VAR_25 )\n        {\n            /* COMMENT_3 */\n            /* COMMENT_4 */\n            continue;\n        }\n        \n        \n\tif ( strmatch(VAR_2,\"DisplaySize:\")==0 )\n\t{\n\t    getint(VAR_0,&VAR_6->display_size);\n\t}\n\telse if ( strmatch(VAR_2,\"DisplayLayer:\")==0 )\n\t{\n\t    getint(VAR_0,&VAR_6->display_layer);\n\t}\n\telse if ( strmatch(VAR_2,\"ExtremaBound:\")==0 )\n\t{\n\t    getint(VAR_0,&VAR_6->extrema_bound);\n\t}\n\telse if ( strmatch(VAR_2,\"WidthSeparation:\")==0 )\n\t{\n\t    getint(VAR_0,&VAR_6->width_separation);\n\t}\n\telse if ( strmatch(VAR_2,\"WinInfo:\")==0 )\n\t{\n\t    int VAR_26, VAR_27;\n\t    getint(VAR_0,&VAR_6->top_enc);\n\t    getint(VAR_0,&VAR_26);\n\t    getint(VAR_0,&VAR_27);\n\t    if ( VAR_6->top_enc<=0 ) VAR_6->top_enc=-1;\n\t    if ( VAR_26<=0 ) VAR_26 = 16;\n\t    if ( VAR_27<=0 ) VAR_27 = 4;\n\t    VAR_6->desired_col_cnt = VAR_26;\n\t    VAR_6->desired_row_cnt = VAR_27;\n\t}\n\telse if ( strmatch(VAR_2,\"AntiAlias:\")==0 )\n\t{\n\t    int VAR_28;\n\t    getint(VAR_0,&VAR_28);\n\t    VAR_6->display_antialias = VAR_28;\n\t}\n\telse if ( strmatch(VAR_2,\"FitToEm:\")==0 )\n\t{\n\t    int VAR_28;\n\t    getint(VAR_0,&VAR_28);\n\t    VAR_6->display_bbsized = VAR_28;\n\t}\n\telse if ( strmatch(VAR_2,\"OnlyBitmaps:\")==0 )\n\t{\n\t    int VAR_28;\n\t    getint(VAR_0,&VAR_28);\n\t    VAR_6->onlybitmaps = VAR_28;\n\t}\n\telse if ( strmatch(VAR_2,\"Order2:\")==0 )\n\t{\n\t    getint(VAR_0,&VAR_19);\n\t    VAR_6->grid.order2 = VAR_19;\n\t    VAR_6->layers[VAR_29].order2 = VAR_19;\n\t    VAR_6->layers[VAR_30].order2 = VAR_19;\n\t}\n\telse if ( strmatch(VAR_2,\"GridOrder2:\")==0 )\n\t{\n\t    int VAR_31;\n\t    getint(VAR_0,&VAR_31);\n\t    VAR_6->grid.order2 = VAR_31;\n\t}\n\telse if ( strmatch(VAR_2,\"Encoding:\")==0 )\n\t{\n\t    VAR_16 = SFDGetEncoding(VAR_0,VAR_2);\n\t    if ( VAR_6->map!=NULL ) VAR_6->map->enc = VAR_16;\n\t}\n\telse if ( strmatch(VAR_2,\"OldEncoding:\")==0 )\n\t{\n\t    /* COMMENT_5 */ (void) SFDGetEncoding(VAR_0,VAR_2);\n\t}\n\telse if ( strmatch(VAR_2,\"UnicodeInterp:\")==0 )\n\t{\n\t    VAR_6->uni_interp = SFDGetUniInterp(VAR_0,VAR_2,VAR_6);\n\t}\n\telse if ( strmatch(VAR_2,\"NameList:\")==0 )\n\t{\n\t    SFDGetNameList(VAR_0,VAR_2,VAR_6);\n\t}\n\telse if ( strmatch(VAR_2,\"Compacted:\")==0 )\n\t{\n\t    int VAR_28;\n\t    getint(VAR_0,&VAR_28);\n\t    VAR_6->compacted = VAR_28;\n\t}\n\telse if ( strmatch(VAR_2,\"Registry:\")==0 )\n\t{\n\t    geteol(VAR_0,VAR_2);\n\t    VAR_6->cidregistry = copy(VAR_2);\n\t}\n\n\n\t/* COMMENT_6 */\n\n\n\telse if ( strmatch(VAR_2,\"Ordering:\")==0 ) {\n\t    geteol(VAR_0,VAR_2);\n\t    VAR_6->ordering = copy(VAR_2);\n\t} else if ( strmatch(VAR_2,\"Supplement:\")==0 ) {\n\t    getint(VAR_0,&VAR_6->supplement);\n\t} else if ( strmatch(VAR_2,\"RemapN:\")==0 ) {\n\t    int VAR_32;\n\t    getint(VAR_0,&VAR_32);\n\t    remap = calloc(VAR_32+1,sizeof(struct remap));\n\t    remap[VAR_32].infont = -1;\n\t    VAR_10 = 0;\n\t    if ( VAR_6->map!=NULL ) VAR_6->map->remap = remap;\n\t} else if ( strmatch(VAR_2,\"Remap:\")==0 ) {\n\t    uint32 VAR_33, VAR_34; int VAR_35;\n\t    gethex(VAR_0,&VAR_33);\n\t    gethex(VAR_0,&VAR_34);\n\t    getint(VAR_0,&VAR_35);\n\t    if ( remap!=NULL && remap[VAR_10].infont!=-1 ) {\n\t\tremap[VAR_10].firstenc = VAR_33;\n\t\tremap[VAR_10].lastenc = VAR_34;\n\t\tremap[VAR_10].infont = VAR_35;\n\t\tVAR_10++;\n\t    }\n\t} else if ( strmatch(VAR_2,\"CIDVersion:\")==0 ) {\n\t    real VAR_28;\n\t    getreal(VAR_0,&VAR_28);\n\t    VAR_6->cidversion = VAR_28;\n\t} else if ( strmatch(VAR_2,\"Grid\")==0 ) {\n\t    VAR_6->grid.splines = SFDGetSplineSet(VAR_0,VAR_6->grid.order2);\n\t} else if ( strmatch(VAR_2,\"ScriptLang:\")==0 ) {\n\t    int VAR_8,VAR_36,VAR_37;\n\t    int VAR_38, VAR_39, VAR_40;\n\t    if ( VAR_6->sfd_version==0 || VAR_6->sfd_version>=2 ) {\n\t\tIError( \"Script lang lists should not happen in version 2 sfd files.\" );\n                SplineFontFree(VAR_6);\n                return NULL;\n\t    }\n\t    getint(VAR_0,&VAR_38);\n\t    ((SplineFont1 *) VAR_6)->sli_cnt = VAR_38;\n\t    ((SplineFont1 *) VAR_6)->script_lang = malloc((VAR_38+1)*sizeof(struct script_record *));\n\t    ((SplineFont1 *) VAR_6)->script_lang[VAR_38] = NULL;\n\t    for ( VAR_8=0; VAR_8<VAR_38; ++VAR_8 ) {\n\t\tgetint(VAR_0,&VAR_39);\n\t\t((SplineFont1 *) VAR_6)->script_lang[VAR_8] = malloc((VAR_39+1)*sizeof(struct script_record));\n\t\t((SplineFont1 *) VAR_6)->script_lang[VAR_8][VAR_39].script = 0;\n\t\tfor ( VAR_36=0; VAR_36<VAR_39; ++VAR_36 ) {\n\t\t    ((SplineFont1 *) VAR_6)->script_lang[VAR_8][VAR_36].script = gettag(VAR_0);\n\t\t    getint(VAR_0,&VAR_40);\n\t\t    ((SplineFont1 *) VAR_6)->script_lang[VAR_8][VAR_36].langs = malloc((VAR_40+1)*sizeof(uint32));\n\t\t    ((SplineFont1 *) VAR_6)->script_lang[VAR_8][VAR_36].langs[VAR_40] = 0;\n\t\t    for ( VAR_37=0; VAR_37<VAR_40; ++VAR_37 ) {\n\t\t\t((SplineFont1 *) VAR_6)->script_lang[VAR_8][VAR_36].langs[VAR_37] = gettag(VAR_0);\n\t\t    }\n\t\t}\n\t    }\n\t} else if ( strmatch(VAR_2,\"TeXData:\")==0 ) {\n\t    int VAR_28;\n\t    getint(VAR_0,&VAR_28);\n\t    VAR_6->texdata.type = VAR_28;\n\t    getint(VAR_0, &VAR_28);\n\t    if ( VAR_6->design_size==0 ) {\n\t    \tVAR_6->design_size = (5*VAR_28+(1<<18))>>19;\n\t    }\n\t    for ( VAR_8=0; VAR_8<22; ++VAR_8 ) {\n\t\tint VAR_41;\n\t\tgetint(VAR_0,&VAR_41);\n\t\tVAR_6->texdata.params[VAR_8]=VAR_41;\n\t    }\n\t} else if ( strnmatch(VAR_2,\"AnchorClass\",11)==0 ) {\n\t    char *VAR_42;\n\t    AnchorClass *VAR_43 = NULL, *VAR_44;\n\t    int VAR_45 = strchr(VAR_2,'2')==NULL;\n\t    while ( (VAR_42=SFDReadUTF7Str(VAR_0))!=NULL ) {\n\t\tVAR_44 = chunkalloc(VAR_45 ? sizeof(VAR_46) : sizeof(AnchorClass));\n\t\tVAR_44->name = VAR_42;\n\t\tif ( VAR_45 ) {\n\t\t    getname(VAR_0,VAR_2);\n\t\t    if ( VAR_2[0]=='0' && VAR_2[1]=='\\0' )\n\t\t\t((AnchorClass1 *) VAR_44)->feature_tag = 0;\n\t\t    else {\n\t\t\tif ( VAR_2[1]=='\\0' ) { VAR_2[1]=' '; VAR_2[2] = 0; }\n\t\t\tif ( VAR_2[2]=='\\0' ) { VAR_2[2]=' '; VAR_2[3] = 0; }\n\t\t\tif ( VAR_2[3]=='\\0' ) { VAR_2[3]=' '; VAR_2[4] = 0; }\n\t\t\t((AnchorClass1 *) VAR_44)->feature_tag = (VAR_2[0]<<24) | (VAR_2[1]<<16) | (VAR_2[2]<<8) | VAR_2[3];\n\t\t    }\n\t\t    while ( (VAR_11=nlgetc(VAR_0))==' ' || VAR_11=='\\t' );\n\t\t    ungetc(VAR_11,VAR_0);\n\t\t    if ( isdigit(VAR_11)) {\n\t\t\tint VAR_28;\n\t\t\tgetint(VAR_0,&VAR_28);\n\t\t\t((AnchorClass1 *) VAR_44)->flags = VAR_28;\n\t\t    }\n\t\t    while ( (VAR_11=nlgetc(VAR_0))==' ' || VAR_11=='\\t' );\n\t\t    ungetc(VAR_11,VAR_0);\n\t\t    if ( isdigit(VAR_11)) {\n\t\t\tint VAR_28;\n\t\t\tgetint(VAR_0,&VAR_28);\n\t\t\t((AnchorClass1 *) VAR_44)->script_lang_index = VAR_28;\n\t\t    } else\n\t\t\t((AnchorClass1 *) VAR_44)->script_lang_index = 0xffff;\t\t/* COMMENT_7 */\n\t\t    while ( (VAR_11=nlgetc(VAR_0))==' ' || VAR_11=='\\t' );\n\t\t    ungetc(VAR_11,VAR_0);\n\t\t    if ( isdigit(VAR_11)) {\n\t\t\tint VAR_28;\n\t\t\tgetint(VAR_0,&VAR_28);\n\t\t\t((AnchorClass1 *) VAR_44)->merge_with = VAR_28;\n\t\t    } else\n\t\t\t((AnchorClass1 *) VAR_44)->merge_with = 0xffff;\t\t\t/* COMMENT_7 */\n\t\t} else {\n                    char *VAR_47 = SFDReadUTF7Str(VAR_0);\n                    if ( VAR_47!=NULL)                                           /* COMMENT_8 */\n\t\t        VAR_44->subtable = SFFindLookupSubtableAndFreeName(VAR_6,VAR_47);\n                }\n\t\twhile ( (VAR_11=nlgetc(VAR_0))==' ' || VAR_11=='\\t' );\n\t\tungetc(VAR_11,VAR_0);\n\t\tif ( isdigit(VAR_11) ) {\n\t\t    /* COMMENT_9 */\n\t\t    int VAR_28;\n\t\t    getint(VAR_0,&VAR_28);\n\t\t    VAR_44->type = VAR_28;\n\t\t} else if ( VAR_45 ) {\n\t\t    if ( ((AnchorClass1 *) VAR_44)->feature_tag==CHR('c','u','r','s'))\n\t\t\tVAR_44->type = VAR_48;\n\t\t    else if ( ((AnchorClass1 *) VAR_44)->feature_tag==CHR('m','k','m','k'))\n\t\t\tVAR_44->type = VAR_49;\n\t\t    else\n\t\t\tVAR_44->type = VAR_50;\n\t\t} else {\n\t\t    VAR_44->type = VAR_50;\n\t\t    if( VAR_44->subtable && VAR_44->subtable->lookup )\n\t\t    {\n\t\t\tswitch ( VAR_44->subtable->lookup->lookup_type )\n\t\t\t{\n\t\t\tcase VAR_51:\n\t\t\t    VAR_44->type = VAR_48;\n\t\t\t    break;\n\t\t\tcase VAR_52:\n\t\t\t    VAR_44->type = VAR_50;\n\t\t\t    break;\n\t\t\tcase VAR_53:\n\t\t\t    VAR_44->type = VAR_54;\n\t\t\t    break;\n\t\t\tcase VAR_55:\n\t\t\t    VAR_44->type = VAR_49;\n\t\t\t    break;\n\t\t\tdefault:\n\t\t\t    VAR_44->type = VAR_50;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif ( VAR_43==NULL )\n\t\t    VAR_6->anchor = VAR_44;\n\t\telse\n\t\t    VAR_43->next = VAR_44;\n\t\tVAR_43 = VAR_44;\n\t    }\n\t} else if ( strncmp(VAR_2,\"MATH:\",5)==0 ) {\n\t    SFDParseMathItem(VAR_0,VAR_6,VAR_2);\n\t} else if ( strmatch(VAR_2,\"TableOrder:\")==0 ) {\n\t    int VAR_28;\n\t    struct table_ordering *VAR_56;\n\t    if ( VAR_5==0 || VAR_5>=2 ) {\n\t\tIError(\"Table ordering specified in version 2 sfd file.\\n\" );\n                SplineFontFree(VAR_6);\n                return NULL;\n\t    }\n\t    VAR_56 = chunkalloc(sizeof(struct table_ordering));\n\t    VAR_56->table_tag = gettag(VAR_0);\n\t    getint(VAR_0,&VAR_28);\n\t    VAR_56->ordered_features = malloc((VAR_28+1)*sizeof(uint32));\n\t    VAR_56->ordered_features[VAR_28] = 0;\n\t    for ( VAR_8=0; VAR_8<VAR_28; ++VAR_8 ) {\n\t\twhile ( isspace((VAR_11=nlgetc(VAR_0))) );\n\t\tif ( VAR_11=='\\'' ) {\n\t\t    ungetc(VAR_11,VAR_0);\n\t\t    VAR_56->ordered_features[VAR_8] = gettag(VAR_0);\n\t\t} else if ( VAR_11=='<' ) {\n\t\t    int VAR_33,VAR_57;\n\t\t    fscanf(VAR_0,\"%d,%d>\", &VAR_33, &VAR_57 );\n\t\t    VAR_56->ordered_features[VAR_8] = (VAR_33<<16)|VAR_57;\n\t\t}\n\t    }\n\t    if ( VAR_12==NULL )\n\t\t((SplineFont1 *) VAR_6)->orders = VAR_56;\n\t    else\n\t\tVAR_12->next = VAR_56;\n\t    VAR_12 = VAR_56;\n\t} else if ( strmatch(VAR_2,\"BeginPrivate:\")==0 ) {\n\t    SFDGetPrivate(VAR_0,VAR_6);\n\t} else if ( strmatch(VAR_2,\"BeginSubrs:\")==0 ) {\t/* COMMENT_10 */\n\t    SFDGetSubrs(VAR_0);\n\t} else if ( strmatch(VAR_2,\"PickledData:\")==0 ) {\n\t    if (VAR_6->python_persistent != NULL) {\n#if defined(VAR_58)\n\t      free( VAR_6->python_persistent );\t/* COMMENT_11 */\n#else\n\t      PyFF_FreePythonPersistent(VAR_6->python_persistent);\n#endif\n\t      VAR_6->python_persistent = NULL;\n\t    }\n\t    VAR_6->python_persistent = SFDUnPickle(VAR_0, 0);\n\t    VAR_6->python_persistent_has_lists = 0;\n\t} else if ( strmatch(VAR_2,\"PickledDataWithLists:\")==0 ) {\n\t    if (VAR_6->python_persistent != NULL) {\n#if defined(VAR_58)\n\t      free( VAR_6->python_persistent );\t/* COMMENT_11 */\n#else\n\t      PyFF_FreePythonPersistent(VAR_6->python_persistent);\n#endif\n\t      VAR_6->python_persistent = NULL;\n\t    }\n\t    VAR_6->python_persistent = SFDUnPickle(VAR_0, 1);\n\t    VAR_6->python_persistent_has_lists = 1;\n\t} else if ( strmatch(VAR_2,\"MMCounts:\")==0 ) {\n\t    MMSet *VAR_59 = VAR_6->mm = chunkalloc(sizeof(MMSet));\n\t    getint(VAR_0,&VAR_59->instance_count);\n\t    getint(VAR_0,&VAR_59->axis_count);\n\t    VAR_11 = nlgetc(VAR_0);\n\t    if ( VAR_11!=' ' )\n\t\tungetc(VAR_11,VAR_0);\n\t    else { int VAR_28;\n\t\tgetint(VAR_0,&VAR_28);\n\t\tVAR_59->apple = VAR_28;\n\t\tgetint(VAR_0,&VAR_59->named_instance_count);\n\t    }\n\t    VAR_59->instances = calloc(VAR_59->instance_count,sizeof(SplineFont *));\n\t    VAR_59->positions = malloc(VAR_59->instance_count*VAR_59->axis_count*sizeof(real));\n\t    VAR_59->defweights = malloc(VAR_59->instance_count*sizeof(real));\n\t    VAR_59->axismaps = calloc(VAR_59->axis_count,sizeof(struct axismap));\n\t    if ( VAR_59->named_instance_count!=0 )\n\t\tVAR_59->named_instances = calloc(VAR_59->named_instance_count,sizeof(struct named_instance));\n\t} else if ( strmatch(VAR_2,\"MMAxis:\")==0 ) {\n\t    MMSet *VAR_59 = VAR_6->mm;\n\t    if ( VAR_59!=NULL ) {\n\t\tfor ( VAR_8=0; VAR_8<VAR_59->axis_count; ++VAR_8 ) {\n\t\t    getname(VAR_0,VAR_2);\n\t\t    VAR_59->axes[VAR_8] = copy(VAR_2);\n\t\t}\n\t    }\n\t} else if ( strmatch(VAR_2,\"MMPositions:\")==0 ) {\n\t    MMSet *VAR_59 = VAR_6->mm;\n\t    if ( VAR_59!=NULL ) {\n\t\tfor ( VAR_8=0; VAR_8<VAR_59->axis_count*VAR_59->instance_count; ++VAR_8 )\n\t\t    getreal(VAR_0,&VAR_59->positions[VAR_8]);\n\t    }\n\t} else if ( strmatch(VAR_2,\"MMWeights:\")==0 ) {\n\t    MMSet *VAR_59 = VAR_6->mm;\n\t    if ( VAR_59!=NULL ) {\n\t\tfor ( VAR_8=0; VAR_8<VAR_59->instance_count; ++VAR_8 )\n\t\t    getreal(VAR_0,&VAR_59->defweights[VAR_8]);\n\t    }\n\t} else if ( strmatch(VAR_2,\"MMAxisMap:\")==0 ) {\n\t    MMSet *VAR_59 = VAR_6->mm;\n\t    if ( VAR_59!=NULL ) {\n\t\tint VAR_60, VAR_61;\n\t\tgetint(VAR_0,&VAR_60); getint(VAR_0,&VAR_61);\n\t\tVAR_59->axismaps[VAR_60].points = VAR_61;\n\t\tVAR_59->axismaps[VAR_60].blends = malloc(VAR_61*sizeof(real));\n\t\tVAR_59->axismaps[VAR_60].designs = malloc(VAR_61*sizeof(real));\n\t\tfor ( VAR_8=0; VAR_8<VAR_61; ++VAR_8 ) {\n\t\t    getreal(VAR_0,&VAR_59->axismaps[VAR_60].blends[VAR_8]);\n\t\t    while ( (VAR_11=nlgetc(VAR_0))!=VAR_62 && isspace(VAR_11));\n\t\t    ungetc(VAR_11,VAR_0);\n\t\t    if ( (VAR_11=nlgetc(VAR_0))!='=' )\n\t\t\tungetc(VAR_11,VAR_0);\n\t\t    else if ( (VAR_11=nlgetc(VAR_0))!='>' )\n\t\t\tungetc(VAR_11,VAR_0);\n\t\t    getreal(VAR_0,&VAR_59->axismaps[VAR_60].designs[VAR_8]);\n\t\t}\n\t\tVAR_13 = &VAR_59->axismaps[VAR_60];\n\t\tVAR_14 = NULL;\n\t    }\n\t} else if ( strmatch(VAR_2,\"MMNamedInstance:\")==0 ) {\n\t    MMSet *VAR_59 = VAR_6->mm;\n\t    if ( VAR_59!=NULL ) {\n\t\tint VAR_60;\n\t\tgetint(VAR_0,&VAR_60);\n\t\tVAR_59->named_instances[VAR_60].coords = malloc(VAR_59->axis_count*sizeof(real));\n\t\tfor ( VAR_8=0; VAR_8<VAR_59->axis_count; ++VAR_8 )\n\t\t    getreal(VAR_0,&VAR_59->named_instances[VAR_60].coords[VAR_8]);\n\t\tVAR_14 = &VAR_59->named_instances[VAR_60];\n\t\tVAR_13 = NULL;\n\t    }\n\t} else if ( strmatch(VAR_2,\"MacName:\")==0 ) {\n\t    struct macname *VAR_63 = SFDParseMacNames(VAR_0,VAR_2);\n\t    if ( VAR_13!=NULL )\n\t\tVAR_13->axisnames = VAR_63;\n\t    else if ( VAR_14 !=NULL )\n\t\tVAR_14->names = VAR_63;\n\t    VAR_15 = true;\n\t} else if ( strmatch(VAR_2,\"MMCDV:\")==0 ) {\n\t    MMSet *VAR_59 = VAR_6->mm;\n\t    if ( VAR_59!=NULL )\n\t\tVAR_59->cdv = SFDParseMMSubroutine(VAR_0);\n\t} else if ( strmatch(VAR_2,\"MMNDV:\")==0 ) {\n\t    MMSet *VAR_59 = VAR_6->mm;\n\t    if ( VAR_59!=NULL )\n\t\tVAR_59->ndv = SFDParseMMSubroutine(VAR_0);\n\t} else if ( strmatch(VAR_2,\"BeginMMFonts:\")==0 ) {\n\t    int VAR_64;\n\t    getint(VAR_0,&VAR_64);\n\t    getint(VAR_0,&VAR_7);\n\t    ff_progress_change_stages(VAR_64);\n\t    ff_progress_change_total(VAR_7);\n\t    MMInferStuff(VAR_6->mm);\n    break;\n\t} else if ( strmatch(VAR_2,\"BeginSubFonts:\")==0 ) {\n\t    getint(VAR_0,&VAR_6->subfontcnt);\n\t    VAR_6->subfonts = calloc(VAR_6->subfontcnt,sizeof(SplineFont *));\n\t    getint(VAR_0,&VAR_7);\n\t    VAR_6->map = EncMap1to1(VAR_7);\n\t    ff_progress_change_stages(2);\n\t    ff_progress_change_total(VAR_7);\n    break;\n\t} else if ( strmatch(VAR_2,\"BeginChars:\")==0 ) {\n\t    int VAR_65;\n\t    getint(VAR_0,&VAR_65);\n\t    if (VAR_65<VAR_16->char_cnt) {\n\t\tIError(\"SFD file specifies too few slots for its encoding.\\n\" );\nexit( 1 );\n\t    }\n\t    if ( getint(VAR_0,&VAR_7)!=1 || VAR_7==-1 )\n\t\tVAR_7 = VAR_65;\n\t    else\n\t\t++VAR_7;\t\t/* COMMENT_12 */\n\t    ff_progress_change_total(VAR_7);\n\t    VAR_6->glyphcnt = VAR_6->glyphmax = VAR_7;\n\t    VAR_6->glyphs = calloc(VAR_7,sizeof(SplineChar *));\n\t    if ( VAR_1!=NULL ) {\n\t\tVAR_6->map = VAR_1->map;\n\t    } else {\n\t\tVAR_6->map = EncMapNew(VAR_65,VAR_7,VAR_16);\n\t\tVAR_6->map->remap = remap;\n\t    }\n\t    SFDSizeMap(VAR_6->map,VAR_6->glyphcnt,VAR_65);\n    break;\n#if VAR_66\n\t} else if ( strmatch(VAR_2,\"BeginCompositionRules\")==0 ) {\n\t    VAR_6->rules = SFDReadCompositionRules(VAR_0);\n#endif\n\t} else {\n\t    /* COMMENT_13 */\n\t    geteol(VAR_0,VAR_2);\n\t}\n    }\n\n    if ( VAR_3 )\n\tVAR_6 = SFD_FigureDirType(VAR_6,VAR_2,VAR_4,VAR_16,remap,VAR_20);\n    else if ( VAR_6->subfontcnt!=0 ) {\n\tff_progress_change_stages(2*VAR_6->subfontcnt);\n\tfor ( VAR_8=0; VAR_8<VAR_6->subfontcnt; ++VAR_8 ) {\n\t    if ( VAR_8!=0 )\n\t\tff_progress_next_stage();\n\t    VAR_6->subfonts[VAR_8] = SFD_GetFont(VAR_0,VAR_6,VAR_2,VAR_3,VAR_4,VAR_5);\n\t}\n    } else if ( VAR_6->mm!=NULL ) {\n\tMMSet *VAR_59 = VAR_6->mm;\n\tff_progress_change_stages(2*(VAR_59->instance_count+1));\n\tfor ( VAR_8=0; VAR_8<VAR_59->instance_count; ++VAR_8 ) {\n\t    if ( VAR_8!=0 )\n\t\tff_progress_next_stage();\n\t    VAR_59->instances[VAR_8] = SFD_GetFont(VAR_0,NULL,VAR_2,VAR_3,VAR_4,VAR_5);\n\t    EncMapFree(VAR_59->instances[VAR_8]->map); VAR_59->instances[VAR_8]->map=NULL;\n\t    VAR_59->instances[VAR_8]->mm = VAR_59;\n\t}\n\tff_progress_next_stage();\n\tVAR_59->normal = SFD_GetFont(VAR_0,NULL,VAR_2,VAR_3,VAR_4,VAR_5);\n\tVAR_59->normal->mm = VAR_59;\n\tVAR_6->mm = NULL;\n\tSplineFontFree(VAR_6);\n\tVAR_6 = VAR_59->normal;\n\tif ( VAR_6->map->enc!=&VAR_17 ) {\n\t    EncMap *VAR_67;\n\t    MMMatchGlyphs(VAR_59);\t\t/* COMMENT_14 */\n\t    VAR_67 = EncMapFromEncoding(VAR_6,VAR_6->map->enc);\n\t    EncMapFree(VAR_6->map);\n\t    VAR_6->map = VAR_67;\n\t}\n    } else {\n\twhile ( SFDGetChar(VAR_0,VAR_6,VAR_20)!=NULL ) {\n\t    ff_progress_next();\n\t}\n\tff_progress_next_stage();\n    }\n    VAR_18 = false;\n    while ( getname(VAR_0,VAR_2)==1 ) {\n\tif ( strcmp(VAR_2,\"EndSplineFont\")==0 || strcmp(VAR_2,\"EndSubSplineFont\")==0 )\n    break;\n\telse if ( strcmp(VAR_2,\"BitmapFont:\")==0 )\n\t    SFDGetBitmapFont(VAR_0,VAR_6,false,NULL);\n\telse if ( strmatch(VAR_2,\"DupEnc:\")==0 ) {\n\t    int VAR_16, VAR_68;\n\t    VAR_18 = true;\n\t    if ( getint(VAR_0,&VAR_16) && getint(VAR_0,&VAR_68) && VAR_6->map!=NULL ) {\n\t\tSFDSetEncMap(VAR_6,VAR_68,VAR_16);\n\t    }\n\t}\n    }\n    if ( VAR_6->cidmaster==NULL )\n\tSFDFixupRefs(VAR_6);\n\n    if ( !VAR_18 )\n\tSFD_DoAltUnis(VAR_6);\n    else\n\tAltUniFigure(VAR_6,VAR_6->map,true);\n    if ( VAR_6->sfd_version<2 )\n\tSFD_AssignLookups((SplineFont1 *) VAR_6);\n    if ( !VAR_24.hadtimes )\n\tSFTimesFromFile(VAR_6,VAR_0);\n    /* COMMENT_15 */\n    if (VAR_6->map == NULL) VAR_6->map = EncMapNew(VAR_6->glyphcnt,VAR_6->glyphcnt,&VAR_17);\n\n    SFDFixupUndoRefs(VAR_6);\nreturn( VAR_6 );\n}",
  "func_graph_path_before": "fontforge/8da6d56bf7af2d25f779e52edef61b2fd4557b3c/sfd.c/vul/before/0.json",
  "func": "static SplineFont *SFD_GetFont( FILE *sfd,SplineFont *cidmaster,char *tok,\n\t\t\t\tint fromdir, char *dirname, float sfdversion )\n{\n    SplineFont *sf;\n    int realcnt, i, eof, mappos=-1, ch;\n    struct table_ordering *lastord = NULL;\n    struct axismap *lastaxismap = NULL;\n    struct named_instance *lastnamedinstance = NULL;\n    int pushedbacktok = false;\n    Encoding *enc = &custom;\n    struct remap *remap = NULL;\n    int haddupenc;\n    int old_style_order2 = false;\n    int had_layer_cnt=false;\n\n    orig_pos = 0;\t\t/* Only used for compatibility with extremely old sfd files */\n\n    sf = SplineFontEmpty();\n    if ( sfdversion>0 && sfdversion<2 ) {\n\t/* If it's an old style sfd file with old style features we need some */\n\t/*  extra data space to do the conversion from old to new */\n\tsf = realloc(sf,sizeof(SplineFont1));\n\tmemset(((uint8 *) sf) + sizeof(SplineFont),0,sizeof(SplineFont1)-sizeof(SplineFont));\n    }\n    sf->sfd_version = sfdversion;\n    sf->cidmaster = cidmaster;\n    sf->uni_interp = ui_unset;\n\tSFD_GetFontMetaDataData d;\n\tSFD_GetFontMetaDataData_Init( &d );\n    while ( 1 ) {\n\tif ( pushedbacktok )\n\t    pushedbacktok = false;\n\telse if ( (eof = getname(sfd,tok))!=1 ) {\n\t    if ( eof==-1 )\n    break;\n\t    geteol(sfd,tok);\n    continue;\n\t}\n\n\n\tbool wasMetadata = SFD_GetFontMetaData( sfd, tok, sf, &d );\n\thad_layer_cnt = d.had_layer_cnt;\n        if( wasMetadata )\n        {\n            // we have handled the token entirely\n            // inside SFD_GetFontMetaData() move to next token.\n            continue;\n        }\n        \n        \n\tif ( strmatch(tok,\"DisplaySize:\")==0 )\n\t{\n\t    getint(sfd,&sf->display_size);\n\t}\n\telse if ( strmatch(tok,\"DisplayLayer:\")==0 )\n\t{\n\t    getint(sfd,&sf->display_layer);\n\t}\n\telse if ( strmatch(tok,\"ExtremaBound:\")==0 )\n\t{\n\t    getint(sfd,&sf->extrema_bound);\n\t}\n\telse if ( strmatch(tok,\"WidthSeparation:\")==0 )\n\t{\n\t    getint(sfd,&sf->width_separation);\n\t}\n\telse if ( strmatch(tok,\"WinInfo:\")==0 )\n\t{\n\t    int temp1, temp2;\n\t    getint(sfd,&sf->top_enc);\n\t    getint(sfd,&temp1);\n\t    getint(sfd,&temp2);\n\t    if ( sf->top_enc<=0 ) sf->top_enc=-1;\n\t    if ( temp1<=0 ) temp1 = 16;\n\t    if ( temp2<=0 ) temp2 = 4;\n\t    sf->desired_col_cnt = temp1;\n\t    sf->desired_row_cnt = temp2;\n\t}\n\telse if ( strmatch(tok,\"AntiAlias:\")==0 )\n\t{\n\t    int temp;\n\t    getint(sfd,&temp);\n\t    sf->display_antialias = temp;\n\t}\n\telse if ( strmatch(tok,\"FitToEm:\")==0 )\n\t{\n\t    int temp;\n\t    getint(sfd,&temp);\n\t    sf->display_bbsized = temp;\n\t}\n\telse if ( strmatch(tok,\"OnlyBitmaps:\")==0 )\n\t{\n\t    int temp;\n\t    getint(sfd,&temp);\n\t    sf->onlybitmaps = temp;\n\t}\n\telse if ( strmatch(tok,\"Order2:\")==0 )\n\t{\n\t    getint(sfd,&old_style_order2);\n\t    sf->grid.order2 = old_style_order2;\n\t    sf->layers[ly_back].order2 = old_style_order2;\n\t    sf->layers[ly_fore].order2 = old_style_order2;\n\t}\n\telse if ( strmatch(tok,\"GridOrder2:\")==0 )\n\t{\n\t    int o2;\n\t    getint(sfd,&o2);\n\t    sf->grid.order2 = o2;\n\t}\n\telse if ( strmatch(tok,\"Encoding:\")==0 )\n\t{\n\t    enc = SFDGetEncoding(sfd,tok);\n\t    if ( sf->map!=NULL ) sf->map->enc = enc;\n\t}\n\telse if ( strmatch(tok,\"OldEncoding:\")==0 )\n\t{\n\t    /* old_encname =*/ (void) SFDGetEncoding(sfd,tok);\n\t}\n\telse if ( strmatch(tok,\"UnicodeInterp:\")==0 )\n\t{\n\t    sf->uni_interp = SFDGetUniInterp(sfd,tok,sf);\n\t}\n\telse if ( strmatch(tok,\"NameList:\")==0 )\n\t{\n\t    SFDGetNameList(sfd,tok,sf);\n\t}\n\telse if ( strmatch(tok,\"Compacted:\")==0 )\n\t{\n\t    int temp;\n\t    getint(sfd,&temp);\n\t    sf->compacted = temp;\n\t}\n\telse if ( strmatch(tok,\"Registry:\")==0 )\n\t{\n\t    geteol(sfd,tok);\n\t    sf->cidregistry = copy(tok);\n\t}\n\n\n\t//////////\n\n\n\telse if ( strmatch(tok,\"Ordering:\")==0 ) {\n\t    geteol(sfd,tok);\n\t    sf->ordering = copy(tok);\n\t} else if ( strmatch(tok,\"Supplement:\")==0 ) {\n\t    getint(sfd,&sf->supplement);\n\t} else if ( strmatch(tok,\"RemapN:\")==0 ) {\n\t    int n;\n\t    getint(sfd,&n);\n\t    remap = calloc(n+1,sizeof(struct remap));\n\t    remap[n].infont = -1;\n\t    mappos = 0;\n\t    if ( sf->map!=NULL ) sf->map->remap = remap;\n\t} else if ( strmatch(tok,\"Remap:\")==0 ) {\n\t    uint32 f, l; int p;\n\t    gethex(sfd,&f);\n\t    gethex(sfd,&l);\n\t    getint(sfd,&p);\n\t    if ( remap!=NULL && remap[mappos].infont!=-1 ) {\n\t\tremap[mappos].firstenc = f;\n\t\tremap[mappos].lastenc = l;\n\t\tremap[mappos].infont = p;\n\t\tmappos++;\n\t    }\n\t} else if ( strmatch(tok,\"CIDVersion:\")==0 ) {\n\t    real temp;\n\t    getreal(sfd,&temp);\n\t    sf->cidversion = temp;\n\t} else if ( strmatch(tok,\"Grid\")==0 ) {\n\t    sf->grid.splines = SFDGetSplineSet(sfd,sf->grid.order2);\n\t} else if ( strmatch(tok,\"ScriptLang:\")==0 ) {\n\t    int i,j,k;\n\t    int imax, jmax, kmax;\n\t    if ( sf->sfd_version==0 || sf->sfd_version>=2 ) {\n\t\tIError( \"Script lang lists should not happen in version 2 sfd files.\" );\n                SplineFontFree(sf);\n                return NULL;\n\t    }\n\t    getint(sfd,&imax);\n\t    ((SplineFont1 *) sf)->sli_cnt = imax;\n\t    ((SplineFont1 *) sf)->script_lang = malloc((imax+1)*sizeof(struct script_record *));\n\t    ((SplineFont1 *) sf)->script_lang[imax] = NULL;\n\t    for ( i=0; i<imax; ++i ) {\n\t\tgetint(sfd,&jmax);\n\t\t((SplineFont1 *) sf)->script_lang[i] = malloc((jmax+1)*sizeof(struct script_record));\n\t\t((SplineFont1 *) sf)->script_lang[i][jmax].script = 0;\n\t\tfor ( j=0; j<jmax; ++j ) {\n\t\t    ((SplineFont1 *) sf)->script_lang[i][j].script = gettag(sfd);\n\t\t    getint(sfd,&kmax);\n\t\t    ((SplineFont1 *) sf)->script_lang[i][j].langs = malloc((kmax+1)*sizeof(uint32));\n\t\t    ((SplineFont1 *) sf)->script_lang[i][j].langs[kmax] = 0;\n\t\t    for ( k=0; k<kmax; ++k ) {\n\t\t\t((SplineFont1 *) sf)->script_lang[i][j].langs[k] = gettag(sfd);\n\t\t    }\n\t\t}\n\t    }\n\t} else if ( strmatch(tok,\"TeXData:\")==0 ) {\n\t    int temp;\n\t    getint(sfd,&temp);\n\t    sf->texdata.type = temp;\n\t    getint(sfd, &temp);\n\t    if ( sf->design_size==0 ) {\n\t    \tsf->design_size = (5*temp+(1<<18))>>19;\n\t    }\n\t    for ( i=0; i<22; ++i ) {\n\t\tint foo;\n\t\tgetint(sfd,&foo);\n\t\tsf->texdata.params[i]=foo;\n\t    }\n\t} else if ( strnmatch(tok,\"AnchorClass\",11)==0 ) {\n\t    char *name;\n\t    AnchorClass *lastan = NULL, *an;\n\t    int old = strchr(tok,'2')==NULL;\n\t    while ( (name=SFDReadUTF7Str(sfd))!=NULL ) {\n\t\tan = chunkalloc(old ? sizeof(AnchorClass1) : sizeof(AnchorClass));\n\t\tan->name = name;\n\t\tif ( old ) {\n\t\t    getname(sfd,tok);\n\t\t    if ( tok[0]=='0' && tok[1]=='\\0' )\n\t\t\t((AnchorClass1 *) an)->feature_tag = 0;\n\t\t    else {\n\t\t\tif ( tok[1]=='\\0' ) { tok[1]=' '; tok[2] = 0; }\n\t\t\tif ( tok[2]=='\\0' ) { tok[2]=' '; tok[3] = 0; }\n\t\t\tif ( tok[3]=='\\0' ) { tok[3]=' '; tok[4] = 0; }\n\t\t\t((AnchorClass1 *) an)->feature_tag = (tok[0]<<24) | (tok[1]<<16) | (tok[2]<<8) | tok[3];\n\t\t    }\n\t\t    while ( (ch=nlgetc(sfd))==' ' || ch=='\\t' );\n\t\t    ungetc(ch,sfd);\n\t\t    if ( isdigit(ch)) {\n\t\t\tint temp;\n\t\t\tgetint(sfd,&temp);\n\t\t\t((AnchorClass1 *) an)->flags = temp;\n\t\t    }\n\t\t    while ( (ch=nlgetc(sfd))==' ' || ch=='\\t' );\n\t\t    ungetc(ch,sfd);\n\t\t    if ( isdigit(ch)) {\n\t\t\tint temp;\n\t\t\tgetint(sfd,&temp);\n\t\t\t((AnchorClass1 *) an)->script_lang_index = temp;\n\t\t    } else\n\t\t\t((AnchorClass1 *) an)->script_lang_index = 0xffff;\t\t/* Will be fixed up later */\n\t\t    while ( (ch=nlgetc(sfd))==' ' || ch=='\\t' );\n\t\t    ungetc(ch,sfd);\n\t\t    if ( isdigit(ch)) {\n\t\t\tint temp;\n\t\t\tgetint(sfd,&temp);\n\t\t\t((AnchorClass1 *) an)->merge_with = temp;\n\t\t    } else\n\t\t\t((AnchorClass1 *) an)->merge_with = 0xffff;\t\t\t/* Will be fixed up later */\n\t\t} else {\n                    char *subtable_name = SFDReadUTF7Str(sfd);\n                    if ( subtable_name!=NULL)                                           /* subtable is optional */\n\t\t        an->subtable = SFFindLookupSubtableAndFreeName(sf,subtable_name);\n                }\n\t\twhile ( (ch=nlgetc(sfd))==' ' || ch=='\\t' );\n\t\tungetc(ch,sfd);\n\t\tif ( isdigit(ch) ) {\n\t\t    /* Early versions of SfdFormat 2 had a number here */\n\t\t    int temp;\n\t\t    getint(sfd,&temp);\n\t\t    an->type = temp;\n\t\t} else if ( old ) {\n\t\t    if ( ((AnchorClass1 *) an)->feature_tag==CHR('c','u','r','s'))\n\t\t\tan->type = act_curs;\n\t\t    else if ( ((AnchorClass1 *) an)->feature_tag==CHR('m','k','m','k'))\n\t\t\tan->type = act_mkmk;\n\t\t    else\n\t\t\tan->type = act_mark;\n\t\t} else {\n\t\t    an->type = act_mark;\n\t\t    if( an->subtable && an->subtable->lookup )\n\t\t    {\n\t\t\tswitch ( an->subtable->lookup->lookup_type )\n\t\t\t{\n\t\t\tcase gpos_cursive:\n\t\t\t    an->type = act_curs;\n\t\t\t    break;\n\t\t\tcase gpos_mark2base:\n\t\t\t    an->type = act_mark;\n\t\t\t    break;\n\t\t\tcase gpos_mark2ligature:\n\t\t\t    an->type = act_mklg;\n\t\t\t    break;\n\t\t\tcase gpos_mark2mark:\n\t\t\t    an->type = act_mkmk;\n\t\t\t    break;\n\t\t\tdefault:\n\t\t\t    an->type = act_mark;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif ( lastan==NULL )\n\t\t    sf->anchor = an;\n\t\telse\n\t\t    lastan->next = an;\n\t\tlastan = an;\n\t    }\n\t} else if ( strncmp(tok,\"MATH:\",5)==0 ) {\n\t    SFDParseMathItem(sfd,sf,tok);\n\t} else if ( strmatch(tok,\"TableOrder:\")==0 ) {\n\t    int temp;\n\t    struct table_ordering *ord;\n\t    if ( sfdversion==0 || sfdversion>=2 ) {\n\t\tIError(\"Table ordering specified in version 2 sfd file.\\n\" );\n                SplineFontFree(sf);\n                return NULL;\n\t    }\n\t    ord = chunkalloc(sizeof(struct table_ordering));\n\t    ord->table_tag = gettag(sfd);\n\t    getint(sfd,&temp);\n\t    ord->ordered_features = malloc((temp+1)*sizeof(uint32));\n\t    ord->ordered_features[temp] = 0;\n\t    for ( i=0; i<temp; ++i ) {\n\t\twhile ( isspace((ch=nlgetc(sfd))) );\n\t\tif ( ch=='\\'' ) {\n\t\t    ungetc(ch,sfd);\n\t\t    ord->ordered_features[i] = gettag(sfd);\n\t\t} else if ( ch=='<' ) {\n\t\t    int f,s;\n\t\t    fscanf(sfd,\"%d,%d>\", &f, &s );\n\t\t    ord->ordered_features[i] = (f<<16)|s;\n\t\t}\n\t    }\n\t    if ( lastord==NULL )\n\t\t((SplineFont1 *) sf)->orders = ord;\n\t    else\n\t\tlastord->next = ord;\n\t    lastord = ord;\n\t} else if ( strmatch(tok,\"BeginPrivate:\")==0 ) {\n\t    SFDGetPrivate(sfd,sf);\n\t} else if ( strmatch(tok,\"BeginSubrs:\")==0 ) {\t/* leave in so we don't croak on old sfd files */\n\t    SFDGetSubrs(sfd);\n\t} else if ( strmatch(tok,\"PickledData:\")==0 ) {\n\t    if (sf->python_persistent != NULL) {\n#if defined(_NO_PYTHON)\n\t      free( sf->python_persistent );\t/* It's a string of pickled data which we leave as a string */\n#else\n\t      PyFF_FreePythonPersistent(sf->python_persistent);\n#endif\n\t      sf->python_persistent = NULL;\n\t    }\n\t    sf->python_persistent = SFDUnPickle(sfd, 0);\n\t    sf->python_persistent_has_lists = 0;\n\t} else if ( strmatch(tok,\"PickledDataWithLists:\")==0 ) {\n\t    if (sf->python_persistent != NULL) {\n#if defined(_NO_PYTHON)\n\t      free( sf->python_persistent );\t/* It's a string of pickled data which we leave as a string */\n#else\n\t      PyFF_FreePythonPersistent(sf->python_persistent);\n#endif\n\t      sf->python_persistent = NULL;\n\t    }\n\t    sf->python_persistent = SFDUnPickle(sfd, 1);\n\t    sf->python_persistent_has_lists = 1;\n\t} else if ( strmatch(tok,\"MMCounts:\")==0 ) {\n\t    MMSet *mm = sf->mm = chunkalloc(sizeof(MMSet));\n\t    getint(sfd,&mm->instance_count);\n\t    getint(sfd,&mm->axis_count);\n\t    ch = nlgetc(sfd);\n\t    if ( ch!=' ' )\n\t\tungetc(ch,sfd);\n\t    else { int temp;\n\t\tgetint(sfd,&temp);\n\t\tmm->apple = temp;\n\t\tgetint(sfd,&mm->named_instance_count);\n\t    }\n\t    mm->instances = calloc(mm->instance_count,sizeof(SplineFont *));\n\t    mm->positions = malloc(mm->instance_count*mm->axis_count*sizeof(real));\n\t    mm->defweights = malloc(mm->instance_count*sizeof(real));\n\t    mm->axismaps = calloc(mm->axis_count,sizeof(struct axismap));\n\t    if ( mm->named_instance_count!=0 )\n\t\tmm->named_instances = calloc(mm->named_instance_count,sizeof(struct named_instance));\n\t} else if ( strmatch(tok,\"MMAxis:\")==0 ) {\n\t    MMSet *mm = sf->mm;\n\t    if ( mm!=NULL ) {\n\t\tfor ( i=0; i<mm->axis_count; ++i ) {\n\t\t    getname(sfd,tok);\n\t\t    mm->axes[i] = copy(tok);\n\t\t}\n\t    }\n\t} else if ( strmatch(tok,\"MMPositions:\")==0 ) {\n\t    MMSet *mm = sf->mm;\n\t    if ( mm!=NULL ) {\n\t\tfor ( i=0; i<mm->axis_count*mm->instance_count; ++i )\n\t\t    getreal(sfd,&mm->positions[i]);\n\t    }\n\t} else if ( strmatch(tok,\"MMWeights:\")==0 ) {\n\t    MMSet *mm = sf->mm;\n\t    if ( mm!=NULL ) {\n\t\tfor ( i=0; i<mm->instance_count; ++i )\n\t\t    getreal(sfd,&mm->defweights[i]);\n\t    }\n\t} else if ( strmatch(tok,\"MMAxisMap:\")==0 ) {\n\t    MMSet *mm = sf->mm;\n\t    if ( mm!=NULL ) {\n\t\tint index, points;\n\t\tgetint(sfd,&index); getint(sfd,&points);\n\t\tmm->axismaps[index].points = points;\n\t\tmm->axismaps[index].blends = malloc(points*sizeof(real));\n\t\tmm->axismaps[index].designs = malloc(points*sizeof(real));\n\t\tfor ( i=0; i<points; ++i ) {\n\t\t    getreal(sfd,&mm->axismaps[index].blends[i]);\n\t\t    while ( (ch=nlgetc(sfd))!=EOF && isspace(ch));\n\t\t    ungetc(ch,sfd);\n\t\t    if ( (ch=nlgetc(sfd))!='=' )\n\t\t\tungetc(ch,sfd);\n\t\t    else if ( (ch=nlgetc(sfd))!='>' )\n\t\t\tungetc(ch,sfd);\n\t\t    getreal(sfd,&mm->axismaps[index].designs[i]);\n\t\t}\n\t\tlastaxismap = &mm->axismaps[index];\n\t\tlastnamedinstance = NULL;\n\t    }\n\t} else if ( strmatch(tok,\"MMNamedInstance:\")==0 ) {\n\t    MMSet *mm = sf->mm;\n\t    if ( mm!=NULL ) {\n\t\tint index;\n\t\tgetint(sfd,&index);\n\t\tmm->named_instances[index].coords = malloc(mm->axis_count*sizeof(real));\n\t\tfor ( i=0; i<mm->axis_count; ++i )\n\t\t    getreal(sfd,&mm->named_instances[index].coords[i]);\n\t\tlastnamedinstance = &mm->named_instances[index];\n\t\tlastaxismap = NULL;\n\t    }\n\t} else if ( strmatch(tok,\"MacName:\")==0 ) {\n\t    struct macname *names = SFDParseMacNames(sfd,tok);\n\t    if ( lastaxismap!=NULL )\n\t\tlastaxismap->axisnames = names;\n\t    else if ( lastnamedinstance !=NULL )\n\t\tlastnamedinstance->names = names;\n\t    pushedbacktok = true;\n\t} else if ( strmatch(tok,\"MMCDV:\")==0 ) {\n\t    MMSet *mm = sf->mm;\n\t    if ( mm!=NULL )\n\t\tmm->cdv = SFDParseMMSubroutine(sfd);\n\t} else if ( strmatch(tok,\"MMNDV:\")==0 ) {\n\t    MMSet *mm = sf->mm;\n\t    if ( mm!=NULL )\n\t\tmm->ndv = SFDParseMMSubroutine(sfd);\n\t} else if ( strmatch(tok,\"BeginMMFonts:\")==0 ) {\n\t    int cnt;\n\t    getint(sfd,&cnt);\n\t    getint(sfd,&realcnt);\n\t    ff_progress_change_stages(cnt);\n\t    ff_progress_change_total(realcnt);\n\t    MMInferStuff(sf->mm);\n    break;\n\t} else if ( strmatch(tok,\"BeginSubFonts:\")==0 ) {\n\t    getint(sfd,&sf->subfontcnt);\n\t    sf->subfonts = calloc(sf->subfontcnt,sizeof(SplineFont *));\n\t    getint(sfd,&realcnt);\n\t    sf->map = EncMap1to1(realcnt);\n\t    ff_progress_change_stages(2);\n\t    ff_progress_change_total(realcnt);\n    break;\n\t} else if ( strmatch(tok,\"BeginChars:\")==0 ) {\n\t    int charcnt;\n\t    getint(sfd,&charcnt);\n\t    if (charcnt<enc->char_cnt) {\n\t\tIError(\"SFD file specifies too few slots for its encoding.\\n\" );\nexit( 1 );\n\t    }\n\t    if ( getint(sfd,&realcnt)!=1 || realcnt==-1 )\n\t\trealcnt = charcnt;\n\t    else\n\t\t++realcnt;\t\t/* value saved is max glyph, not glyph cnt */\n\t    ff_progress_change_total(realcnt);\n\t    sf->glyphcnt = sf->glyphmax = realcnt;\n\t    sf->glyphs = calloc(realcnt,sizeof(SplineChar *));\n\t    if ( cidmaster!=NULL ) {\n\t\tsf->map = cidmaster->map;\n\t    } else {\n\t\tsf->map = EncMapNew(charcnt,realcnt,enc);\n\t\tsf->map->remap = remap;\n\t    }\n\t    SFDSizeMap(sf->map,sf->glyphcnt,charcnt);\n    break;\n#if HANYANG\n\t} else if ( strmatch(tok,\"BeginCompositionRules\")==0 ) {\n\t    sf->rules = SFDReadCompositionRules(sfd);\n#endif\n\t} else {\n\t    /* If we don't understand it, skip it */\n\t    geteol(sfd,tok);\n\t}\n    }\n\n    // Many downstream functions assume this isn't NULL (use strlen, etc.)\n    if ( sf->fontname==NULL)\n\tsf->fontname = copy(\"\");\n\n    if ( fromdir )\n\tsf = SFD_FigureDirType(sf,tok,dirname,enc,remap,had_layer_cnt);\n    else if ( sf->subfontcnt!=0 ) {\n\tff_progress_change_stages(2*sf->subfontcnt);\n\tfor ( i=0; i<sf->subfontcnt; ++i ) {\n\t    if ( i!=0 )\n\t\tff_progress_next_stage();\n\t    sf->subfonts[i] = SFD_GetFont(sfd,sf,tok,fromdir,dirname,sfdversion);\n\t}\n    } else if ( sf->mm!=NULL ) {\n\tMMSet *mm = sf->mm;\n\tff_progress_change_stages(2*(mm->instance_count+1));\n\tfor ( i=0; i<mm->instance_count; ++i ) {\n\t    if ( i!=0 )\n\t\tff_progress_next_stage();\n\t    mm->instances[i] = SFD_GetFont(sfd,NULL,tok,fromdir,dirname,sfdversion);\n\t    EncMapFree(mm->instances[i]->map); mm->instances[i]->map=NULL;\n\t    mm->instances[i]->mm = mm;\n\t}\n\tff_progress_next_stage();\n\tmm->normal = SFD_GetFont(sfd,NULL,tok,fromdir,dirname,sfdversion);\n\tmm->normal->mm = mm;\n\tsf->mm = NULL;\n\tSplineFontFree(sf);\n\tsf = mm->normal;\n\tif ( sf->map->enc!=&custom ) {\n\t    EncMap *map;\n\t    MMMatchGlyphs(mm);\t\t/* sfd files from before the encoding change can have mismatched orig pos */\n\t    map = EncMapFromEncoding(sf,sf->map->enc);\n\t    EncMapFree(sf->map);\n\t    sf->map = map;\n\t}\n    } else {\n\twhile ( SFDGetChar(sfd,sf,had_layer_cnt)!=NULL ) {\n\t    ff_progress_next();\n\t}\n\tff_progress_next_stage();\n    }\n    haddupenc = false;\n    while ( getname(sfd,tok)==1 ) {\n\tif ( strcmp(tok,\"EndSplineFont\")==0 || strcmp(tok,\"EndSubSplineFont\")==0 )\n    break;\n\telse if ( strcmp(tok,\"BitmapFont:\")==0 )\n\t    SFDGetBitmapFont(sfd,sf,false,NULL);\n\telse if ( strmatch(tok,\"DupEnc:\")==0 ) {\n\t    int enc, orig;\n\t    haddupenc = true;\n\t    if ( getint(sfd,&enc) && getint(sfd,&orig) && sf->map!=NULL ) {\n\t\tSFDSetEncMap(sf,orig,enc);\n\t    }\n\t}\n    }\n    if ( sf->cidmaster==NULL )\n\tSFDFixupRefs(sf);\n\n    if ( !haddupenc )\n\tSFD_DoAltUnis(sf);\n    else\n\tAltUniFigure(sf,sf->map,true);\n    if ( sf->sfd_version<2 )\n\tSFD_AssignLookups((SplineFont1 *) sf);\n    if ( !d.hadtimes )\n\tSFTimesFromFile(sf,sfd);\n    // Make a blank encoding if there are no characters so as to avoid crashes later.\n    if (sf->map == NULL) sf->map = EncMapNew(sf->glyphcnt,sf->glyphcnt,&custom);\n\n    SFDFixupUndoRefs(sf);\nreturn( sf );\n}",
  "abstract_func": "static SplineFont *SFD_GetFont( FILE *VAR_0,SplineFont *VAR_1,char *VAR_2,\n\t\t\t\tint VAR_3, char *VAR_4, float VAR_5 )\n{\n    SplineFont *VAR_6;\n    int VAR_7, VAR_8, VAR_9, VAR_10=-1, VAR_11;\n    struct table_ordering *VAR_12 = NULL;\n    struct axismap *VAR_13 = NULL;\n    struct named_instance *VAR_14 = NULL;\n    int VAR_15 = false;\n    Encoding *VAR_16 = &VAR_17;\n    struct remap *remap = NULL;\n    int VAR_18;\n    int VAR_19 = false;\n    int VAR_20=false;\n\n    VAR_21 = 0;\t\t/* COMMENT_0 */\n\n    VAR_6 = SplineFontEmpty();\n    if ( VAR_5>0 && VAR_5<2 ) {\n\t/* COMMENT_1 */\n\t/* COMMENT_2 */\n\tVAR_6 = realloc(VAR_6,sizeof(VAR_22));\n\tmemset(((uint8 *) VAR_6) + sizeof(SplineFont),0,sizeof(VAR_22)-sizeof(SplineFont));\n    }\n    VAR_6->sfd_version = VAR_5;\n    VAR_6->cidmaster = VAR_1;\n    VAR_6->uni_interp = VAR_23;\n\tSFD_GetFontMetaDataData VAR_24;\n\tSFD_GetFontMetaDataData_Init( &VAR_24 );\n    while ( 1 ) {\n\tif ( VAR_15 )\n\t    VAR_15 = false;\n\telse if ( (VAR_9 = getname(VAR_0,VAR_2))!=1 ) {\n\t    if ( VAR_9==-1 )\n    break;\n\t    geteol(VAR_0,VAR_2);\n    continue;\n\t}\n\n\n\tbool VAR_25 = SFD_GetFontMetaData( VAR_0, VAR_2, VAR_6, &VAR_24 );\n\tVAR_20 = VAR_24.had_layer_cnt;\n        if( VAR_25 )\n        {\n            /* COMMENT_3 */\n            /* COMMENT_4 */\n            continue;\n        }\n        \n        \n\tif ( strmatch(VAR_2,\"DisplaySize:\")==0 )\n\t{\n\t    getint(VAR_0,&VAR_6->display_size);\n\t}\n\telse if ( strmatch(VAR_2,\"DisplayLayer:\")==0 )\n\t{\n\t    getint(VAR_0,&VAR_6->display_layer);\n\t}\n\telse if ( strmatch(VAR_2,\"ExtremaBound:\")==0 )\n\t{\n\t    getint(VAR_0,&VAR_6->extrema_bound);\n\t}\n\telse if ( strmatch(VAR_2,\"WidthSeparation:\")==0 )\n\t{\n\t    getint(VAR_0,&VAR_6->width_separation);\n\t}\n\telse if ( strmatch(VAR_2,\"WinInfo:\")==0 )\n\t{\n\t    int VAR_26, VAR_27;\n\t    getint(VAR_0,&VAR_6->top_enc);\n\t    getint(VAR_0,&VAR_26);\n\t    getint(VAR_0,&VAR_27);\n\t    if ( VAR_6->top_enc<=0 ) VAR_6->top_enc=-1;\n\t    if ( VAR_26<=0 ) VAR_26 = 16;\n\t    if ( VAR_27<=0 ) VAR_27 = 4;\n\t    VAR_6->desired_col_cnt = VAR_26;\n\t    VAR_6->desired_row_cnt = VAR_27;\n\t}\n\telse if ( strmatch(VAR_2,\"AntiAlias:\")==0 )\n\t{\n\t    int VAR_28;\n\t    getint(VAR_0,&VAR_28);\n\t    VAR_6->display_antialias = VAR_28;\n\t}\n\telse if ( strmatch(VAR_2,\"FitToEm:\")==0 )\n\t{\n\t    int VAR_28;\n\t    getint(VAR_0,&VAR_28);\n\t    VAR_6->display_bbsized = VAR_28;\n\t}\n\telse if ( strmatch(VAR_2,\"OnlyBitmaps:\")==0 )\n\t{\n\t    int VAR_28;\n\t    getint(VAR_0,&VAR_28);\n\t    VAR_6->onlybitmaps = VAR_28;\n\t}\n\telse if ( strmatch(VAR_2,\"Order2:\")==0 )\n\t{\n\t    getint(VAR_0,&VAR_19);\n\t    VAR_6->grid.order2 = VAR_19;\n\t    VAR_6->layers[VAR_29].order2 = VAR_19;\n\t    VAR_6->layers[VAR_30].order2 = VAR_19;\n\t}\n\telse if ( strmatch(VAR_2,\"GridOrder2:\")==0 )\n\t{\n\t    int VAR_31;\n\t    getint(VAR_0,&VAR_31);\n\t    VAR_6->grid.order2 = VAR_31;\n\t}\n\telse if ( strmatch(VAR_2,\"Encoding:\")==0 )\n\t{\n\t    VAR_16 = SFDGetEncoding(VAR_0,VAR_2);\n\t    if ( VAR_6->map!=NULL ) VAR_6->map->enc = VAR_16;\n\t}\n\telse if ( strmatch(VAR_2,\"OldEncoding:\")==0 )\n\t{\n\t    /* COMMENT_5 */ (void) SFDGetEncoding(VAR_0,VAR_2);\n\t}\n\telse if ( strmatch(VAR_2,\"UnicodeInterp:\")==0 )\n\t{\n\t    VAR_6->uni_interp = SFDGetUniInterp(VAR_0,VAR_2,VAR_6);\n\t}\n\telse if ( strmatch(VAR_2,\"NameList:\")==0 )\n\t{\n\t    SFDGetNameList(VAR_0,VAR_2,VAR_6);\n\t}\n\telse if ( strmatch(VAR_2,\"Compacted:\")==0 )\n\t{\n\t    int VAR_28;\n\t    getint(VAR_0,&VAR_28);\n\t    VAR_6->compacted = VAR_28;\n\t}\n\telse if ( strmatch(VAR_2,\"Registry:\")==0 )\n\t{\n\t    geteol(VAR_0,VAR_2);\n\t    VAR_6->cidregistry = copy(VAR_2);\n\t}\n\n\n\t/* COMMENT_6 */\n\n\n\telse if ( strmatch(VAR_2,\"Ordering:\")==0 ) {\n\t    geteol(VAR_0,VAR_2);\n\t    VAR_6->ordering = copy(VAR_2);\n\t} else if ( strmatch(VAR_2,\"Supplement:\")==0 ) {\n\t    getint(VAR_0,&VAR_6->supplement);\n\t} else if ( strmatch(VAR_2,\"RemapN:\")==0 ) {\n\t    int VAR_32;\n\t    getint(VAR_0,&VAR_32);\n\t    remap = calloc(VAR_32+1,sizeof(struct remap));\n\t    remap[VAR_32].infont = -1;\n\t    VAR_10 = 0;\n\t    if ( VAR_6->map!=NULL ) VAR_6->map->remap = remap;\n\t} else if ( strmatch(VAR_2,\"Remap:\")==0 ) {\n\t    uint32 VAR_33, VAR_34; int VAR_35;\n\t    gethex(VAR_0,&VAR_33);\n\t    gethex(VAR_0,&VAR_34);\n\t    getint(VAR_0,&VAR_35);\n\t    if ( remap!=NULL && remap[VAR_10].infont!=-1 ) {\n\t\tremap[VAR_10].firstenc = VAR_33;\n\t\tremap[VAR_10].lastenc = VAR_34;\n\t\tremap[VAR_10].infont = VAR_35;\n\t\tVAR_10++;\n\t    }\n\t} else if ( strmatch(VAR_2,\"CIDVersion:\")==0 ) {\n\t    real VAR_28;\n\t    getreal(VAR_0,&VAR_28);\n\t    VAR_6->cidversion = VAR_28;\n\t} else if ( strmatch(VAR_2,\"Grid\")==0 ) {\n\t    VAR_6->grid.splines = SFDGetSplineSet(VAR_0,VAR_6->grid.order2);\n\t} else if ( strmatch(VAR_2,\"ScriptLang:\")==0 ) {\n\t    int VAR_8,VAR_36,VAR_37;\n\t    int VAR_38, VAR_39, VAR_40;\n\t    if ( VAR_6->sfd_version==0 || VAR_6->sfd_version>=2 ) {\n\t\tIError( \"Script lang lists should not happen in version 2 sfd files.\" );\n                SplineFontFree(VAR_6);\n                return NULL;\n\t    }\n\t    getint(VAR_0,&VAR_38);\n\t    ((SplineFont1 *) VAR_6)->sli_cnt = VAR_38;\n\t    ((SplineFont1 *) VAR_6)->script_lang = malloc((VAR_38+1)*sizeof(struct script_record *));\n\t    ((SplineFont1 *) VAR_6)->script_lang[VAR_38] = NULL;\n\t    for ( VAR_8=0; VAR_8<VAR_38; ++VAR_8 ) {\n\t\tgetint(VAR_0,&VAR_39);\n\t\t((SplineFont1 *) VAR_6)->script_lang[VAR_8] = malloc((VAR_39+1)*sizeof(struct script_record));\n\t\t((SplineFont1 *) VAR_6)->script_lang[VAR_8][VAR_39].script = 0;\n\t\tfor ( VAR_36=0; VAR_36<VAR_39; ++VAR_36 ) {\n\t\t    ((SplineFont1 *) VAR_6)->script_lang[VAR_8][VAR_36].script = gettag(VAR_0);\n\t\t    getint(VAR_0,&VAR_40);\n\t\t    ((SplineFont1 *) VAR_6)->script_lang[VAR_8][VAR_36].langs = malloc((VAR_40+1)*sizeof(uint32));\n\t\t    ((SplineFont1 *) VAR_6)->script_lang[VAR_8][VAR_36].langs[VAR_40] = 0;\n\t\t    for ( VAR_37=0; VAR_37<VAR_40; ++VAR_37 ) {\n\t\t\t((SplineFont1 *) VAR_6)->script_lang[VAR_8][VAR_36].langs[VAR_37] = gettag(VAR_0);\n\t\t    }\n\t\t}\n\t    }\n\t} else if ( strmatch(VAR_2,\"TeXData:\")==0 ) {\n\t    int VAR_28;\n\t    getint(VAR_0,&VAR_28);\n\t    VAR_6->texdata.type = VAR_28;\n\t    getint(VAR_0, &VAR_28);\n\t    if ( VAR_6->design_size==0 ) {\n\t    \tVAR_6->design_size = (5*VAR_28+(1<<18))>>19;\n\t    }\n\t    for ( VAR_8=0; VAR_8<22; ++VAR_8 ) {\n\t\tint VAR_41;\n\t\tgetint(VAR_0,&VAR_41);\n\t\tVAR_6->texdata.params[VAR_8]=VAR_41;\n\t    }\n\t} else if ( strnmatch(VAR_2,\"AnchorClass\",11)==0 ) {\n\t    char *VAR_42;\n\t    AnchorClass *VAR_43 = NULL, *VAR_44;\n\t    int VAR_45 = strchr(VAR_2,'2')==NULL;\n\t    while ( (VAR_42=SFDReadUTF7Str(VAR_0))!=NULL ) {\n\t\tVAR_44 = chunkalloc(VAR_45 ? sizeof(VAR_46) : sizeof(AnchorClass));\n\t\tVAR_44->name = VAR_42;\n\t\tif ( VAR_45 ) {\n\t\t    getname(VAR_0,VAR_2);\n\t\t    if ( VAR_2[0]=='0' && VAR_2[1]=='\\0' )\n\t\t\t((AnchorClass1 *) VAR_44)->feature_tag = 0;\n\t\t    else {\n\t\t\tif ( VAR_2[1]=='\\0' ) { VAR_2[1]=' '; VAR_2[2] = 0; }\n\t\t\tif ( VAR_2[2]=='\\0' ) { VAR_2[2]=' '; VAR_2[3] = 0; }\n\t\t\tif ( VAR_2[3]=='\\0' ) { VAR_2[3]=' '; VAR_2[4] = 0; }\n\t\t\t((AnchorClass1 *) VAR_44)->feature_tag = (VAR_2[0]<<24) | (VAR_2[1]<<16) | (VAR_2[2]<<8) | VAR_2[3];\n\t\t    }\n\t\t    while ( (VAR_11=nlgetc(VAR_0))==' ' || VAR_11=='\\t' );\n\t\t    ungetc(VAR_11,VAR_0);\n\t\t    if ( isdigit(VAR_11)) {\n\t\t\tint VAR_28;\n\t\t\tgetint(VAR_0,&VAR_28);\n\t\t\t((AnchorClass1 *) VAR_44)->flags = VAR_28;\n\t\t    }\n\t\t    while ( (VAR_11=nlgetc(VAR_0))==' ' || VAR_11=='\\t' );\n\t\t    ungetc(VAR_11,VAR_0);\n\t\t    if ( isdigit(VAR_11)) {\n\t\t\tint VAR_28;\n\t\t\tgetint(VAR_0,&VAR_28);\n\t\t\t((AnchorClass1 *) VAR_44)->script_lang_index = VAR_28;\n\t\t    } else\n\t\t\t((AnchorClass1 *) VAR_44)->script_lang_index = 0xffff;\t\t/* COMMENT_7 */\n\t\t    while ( (VAR_11=nlgetc(VAR_0))==' ' || VAR_11=='\\t' );\n\t\t    ungetc(VAR_11,VAR_0);\n\t\t    if ( isdigit(VAR_11)) {\n\t\t\tint VAR_28;\n\t\t\tgetint(VAR_0,&VAR_28);\n\t\t\t((AnchorClass1 *) VAR_44)->merge_with = VAR_28;\n\t\t    } else\n\t\t\t((AnchorClass1 *) VAR_44)->merge_with = 0xffff;\t\t\t/* COMMENT_7 */\n\t\t} else {\n                    char *VAR_47 = SFDReadUTF7Str(VAR_0);\n                    if ( VAR_47!=NULL)                                           /* COMMENT_8 */\n\t\t        VAR_44->subtable = SFFindLookupSubtableAndFreeName(VAR_6,VAR_47);\n                }\n\t\twhile ( (VAR_11=nlgetc(VAR_0))==' ' || VAR_11=='\\t' );\n\t\tungetc(VAR_11,VAR_0);\n\t\tif ( isdigit(VAR_11) ) {\n\t\t    /* COMMENT_9 */\n\t\t    int VAR_28;\n\t\t    getint(VAR_0,&VAR_28);\n\t\t    VAR_44->type = VAR_28;\n\t\t} else if ( VAR_45 ) {\n\t\t    if ( ((AnchorClass1 *) VAR_44)->feature_tag==CHR('c','u','r','s'))\n\t\t\tVAR_44->type = VAR_48;\n\t\t    else if ( ((AnchorClass1 *) VAR_44)->feature_tag==CHR('m','k','m','k'))\n\t\t\tVAR_44->type = VAR_49;\n\t\t    else\n\t\t\tVAR_44->type = VAR_50;\n\t\t} else {\n\t\t    VAR_44->type = VAR_50;\n\t\t    if( VAR_44->subtable && VAR_44->subtable->lookup )\n\t\t    {\n\t\t\tswitch ( VAR_44->subtable->lookup->lookup_type )\n\t\t\t{\n\t\t\tcase VAR_51:\n\t\t\t    VAR_44->type = VAR_48;\n\t\t\t    break;\n\t\t\tcase VAR_52:\n\t\t\t    VAR_44->type = VAR_50;\n\t\t\t    break;\n\t\t\tcase VAR_53:\n\t\t\t    VAR_44->type = VAR_54;\n\t\t\t    break;\n\t\t\tcase VAR_55:\n\t\t\t    VAR_44->type = VAR_49;\n\t\t\t    break;\n\t\t\tdefault:\n\t\t\t    VAR_44->type = VAR_50;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif ( VAR_43==NULL )\n\t\t    VAR_6->anchor = VAR_44;\n\t\telse\n\t\t    VAR_43->next = VAR_44;\n\t\tVAR_43 = VAR_44;\n\t    }\n\t} else if ( strncmp(VAR_2,\"MATH:\",5)==0 ) {\n\t    SFDParseMathItem(VAR_0,VAR_6,VAR_2);\n\t} else if ( strmatch(VAR_2,\"TableOrder:\")==0 ) {\n\t    int VAR_28;\n\t    struct table_ordering *VAR_56;\n\t    if ( VAR_5==0 || VAR_5>=2 ) {\n\t\tIError(\"Table ordering specified in version 2 sfd file.\\n\" );\n                SplineFontFree(VAR_6);\n                return NULL;\n\t    }\n\t    VAR_56 = chunkalloc(sizeof(struct table_ordering));\n\t    VAR_56->table_tag = gettag(VAR_0);\n\t    getint(VAR_0,&VAR_28);\n\t    VAR_56->ordered_features = malloc((VAR_28+1)*sizeof(uint32));\n\t    VAR_56->ordered_features[VAR_28] = 0;\n\t    for ( VAR_8=0; VAR_8<VAR_28; ++VAR_8 ) {\n\t\twhile ( isspace((VAR_11=nlgetc(VAR_0))) );\n\t\tif ( VAR_11=='\\'' ) {\n\t\t    ungetc(VAR_11,VAR_0);\n\t\t    VAR_56->ordered_features[VAR_8] = gettag(VAR_0);\n\t\t} else if ( VAR_11=='<' ) {\n\t\t    int VAR_33,VAR_57;\n\t\t    fscanf(VAR_0,\"%d,%d>\", &VAR_33, &VAR_57 );\n\t\t    VAR_56->ordered_features[VAR_8] = (VAR_33<<16)|VAR_57;\n\t\t}\n\t    }\n\t    if ( VAR_12==NULL )\n\t\t((SplineFont1 *) VAR_6)->orders = VAR_56;\n\t    else\n\t\tVAR_12->next = VAR_56;\n\t    VAR_12 = VAR_56;\n\t} else if ( strmatch(VAR_2,\"BeginPrivate:\")==0 ) {\n\t    SFDGetPrivate(VAR_0,VAR_6);\n\t} else if ( strmatch(VAR_2,\"BeginSubrs:\")==0 ) {\t/* COMMENT_10 */\n\t    SFDGetSubrs(VAR_0);\n\t} else if ( strmatch(VAR_2,\"PickledData:\")==0 ) {\n\t    if (VAR_6->python_persistent != NULL) {\n#if defined(VAR_58)\n\t      free( VAR_6->python_persistent );\t/* COMMENT_11 */\n#else\n\t      PyFF_FreePythonPersistent(VAR_6->python_persistent);\n#endif\n\t      VAR_6->python_persistent = NULL;\n\t    }\n\t    VAR_6->python_persistent = SFDUnPickle(VAR_0, 0);\n\t    VAR_6->python_persistent_has_lists = 0;\n\t} else if ( strmatch(VAR_2,\"PickledDataWithLists:\")==0 ) {\n\t    if (VAR_6->python_persistent != NULL) {\n#if defined(VAR_58)\n\t      free( VAR_6->python_persistent );\t/* COMMENT_11 */\n#else\n\t      PyFF_FreePythonPersistent(VAR_6->python_persistent);\n#endif\n\t      VAR_6->python_persistent = NULL;\n\t    }\n\t    VAR_6->python_persistent = SFDUnPickle(VAR_0, 1);\n\t    VAR_6->python_persistent_has_lists = 1;\n\t} else if ( strmatch(VAR_2,\"MMCounts:\")==0 ) {\n\t    MMSet *VAR_59 = VAR_6->mm = chunkalloc(sizeof(MMSet));\n\t    getint(VAR_0,&VAR_59->instance_count);\n\t    getint(VAR_0,&VAR_59->axis_count);\n\t    VAR_11 = nlgetc(VAR_0);\n\t    if ( VAR_11!=' ' )\n\t\tungetc(VAR_11,VAR_0);\n\t    else { int VAR_28;\n\t\tgetint(VAR_0,&VAR_28);\n\t\tVAR_59->apple = VAR_28;\n\t\tgetint(VAR_0,&VAR_59->named_instance_count);\n\t    }\n\t    VAR_59->instances = calloc(VAR_59->instance_count,sizeof(SplineFont *));\n\t    VAR_59->positions = malloc(VAR_59->instance_count*VAR_59->axis_count*sizeof(real));\n\t    VAR_59->defweights = malloc(VAR_59->instance_count*sizeof(real));\n\t    VAR_59->axismaps = calloc(VAR_59->axis_count,sizeof(struct axismap));\n\t    if ( VAR_59->named_instance_count!=0 )\n\t\tVAR_59->named_instances = calloc(VAR_59->named_instance_count,sizeof(struct named_instance));\n\t} else if ( strmatch(VAR_2,\"MMAxis:\")==0 ) {\n\t    MMSet *VAR_59 = VAR_6->mm;\n\t    if ( VAR_59!=NULL ) {\n\t\tfor ( VAR_8=0; VAR_8<VAR_59->axis_count; ++VAR_8 ) {\n\t\t    getname(VAR_0,VAR_2);\n\t\t    VAR_59->axes[VAR_8] = copy(VAR_2);\n\t\t}\n\t    }\n\t} else if ( strmatch(VAR_2,\"MMPositions:\")==0 ) {\n\t    MMSet *VAR_59 = VAR_6->mm;\n\t    if ( VAR_59!=NULL ) {\n\t\tfor ( VAR_8=0; VAR_8<VAR_59->axis_count*VAR_59->instance_count; ++VAR_8 )\n\t\t    getreal(VAR_0,&VAR_59->positions[VAR_8]);\n\t    }\n\t} else if ( strmatch(VAR_2,\"MMWeights:\")==0 ) {\n\t    MMSet *VAR_59 = VAR_6->mm;\n\t    if ( VAR_59!=NULL ) {\n\t\tfor ( VAR_8=0; VAR_8<VAR_59->instance_count; ++VAR_8 )\n\t\t    getreal(VAR_0,&VAR_59->defweights[VAR_8]);\n\t    }\n\t} else if ( strmatch(VAR_2,\"MMAxisMap:\")==0 ) {\n\t    MMSet *VAR_59 = VAR_6->mm;\n\t    if ( VAR_59!=NULL ) {\n\t\tint VAR_60, VAR_61;\n\t\tgetint(VAR_0,&VAR_60); getint(VAR_0,&VAR_61);\n\t\tVAR_59->axismaps[VAR_60].points = VAR_61;\n\t\tVAR_59->axismaps[VAR_60].blends = malloc(VAR_61*sizeof(real));\n\t\tVAR_59->axismaps[VAR_60].designs = malloc(VAR_61*sizeof(real));\n\t\tfor ( VAR_8=0; VAR_8<VAR_61; ++VAR_8 ) {\n\t\t    getreal(VAR_0,&VAR_59->axismaps[VAR_60].blends[VAR_8]);\n\t\t    while ( (VAR_11=nlgetc(VAR_0))!=VAR_62 && isspace(VAR_11));\n\t\t    ungetc(VAR_11,VAR_0);\n\t\t    if ( (VAR_11=nlgetc(VAR_0))!='=' )\n\t\t\tungetc(VAR_11,VAR_0);\n\t\t    else if ( (VAR_11=nlgetc(VAR_0))!='>' )\n\t\t\tungetc(VAR_11,VAR_0);\n\t\t    getreal(VAR_0,&VAR_59->axismaps[VAR_60].designs[VAR_8]);\n\t\t}\n\t\tVAR_13 = &VAR_59->axismaps[VAR_60];\n\t\tVAR_14 = NULL;\n\t    }\n\t} else if ( strmatch(VAR_2,\"MMNamedInstance:\")==0 ) {\n\t    MMSet *VAR_59 = VAR_6->mm;\n\t    if ( VAR_59!=NULL ) {\n\t\tint VAR_60;\n\t\tgetint(VAR_0,&VAR_60);\n\t\tVAR_59->named_instances[VAR_60].coords = malloc(VAR_59->axis_count*sizeof(real));\n\t\tfor ( VAR_8=0; VAR_8<VAR_59->axis_count; ++VAR_8 )\n\t\t    getreal(VAR_0,&VAR_59->named_instances[VAR_60].coords[VAR_8]);\n\t\tVAR_14 = &VAR_59->named_instances[VAR_60];\n\t\tVAR_13 = NULL;\n\t    }\n\t} else if ( strmatch(VAR_2,\"MacName:\")==0 ) {\n\t    struct macname *VAR_63 = SFDParseMacNames(VAR_0,VAR_2);\n\t    if ( VAR_13!=NULL )\n\t\tVAR_13->axisnames = VAR_63;\n\t    else if ( VAR_14 !=NULL )\n\t\tVAR_14->names = VAR_63;\n\t    VAR_15 = true;\n\t} else if ( strmatch(VAR_2,\"MMCDV:\")==0 ) {\n\t    MMSet *VAR_59 = VAR_6->mm;\n\t    if ( VAR_59!=NULL )\n\t\tVAR_59->cdv = SFDParseMMSubroutine(VAR_0);\n\t} else if ( strmatch(VAR_2,\"MMNDV:\")==0 ) {\n\t    MMSet *VAR_59 = VAR_6->mm;\n\t    if ( VAR_59!=NULL )\n\t\tVAR_59->ndv = SFDParseMMSubroutine(VAR_0);\n\t} else if ( strmatch(VAR_2,\"BeginMMFonts:\")==0 ) {\n\t    int VAR_64;\n\t    getint(VAR_0,&VAR_64);\n\t    getint(VAR_0,&VAR_7);\n\t    ff_progress_change_stages(VAR_64);\n\t    ff_progress_change_total(VAR_7);\n\t    MMInferStuff(VAR_6->mm);\n    break;\n\t} else if ( strmatch(VAR_2,\"BeginSubFonts:\")==0 ) {\n\t    getint(VAR_0,&VAR_6->subfontcnt);\n\t    VAR_6->subfonts = calloc(VAR_6->subfontcnt,sizeof(SplineFont *));\n\t    getint(VAR_0,&VAR_7);\n\t    VAR_6->map = EncMap1to1(VAR_7);\n\t    ff_progress_change_stages(2);\n\t    ff_progress_change_total(VAR_7);\n    break;\n\t} else if ( strmatch(VAR_2,\"BeginChars:\")==0 ) {\n\t    int VAR_65;\n\t    getint(VAR_0,&VAR_65);\n\t    if (VAR_65<VAR_16->char_cnt) {\n\t\tIError(\"SFD file specifies too few slots for its encoding.\\n\" );\nexit( 1 );\n\t    }\n\t    if ( getint(VAR_0,&VAR_7)!=1 || VAR_7==-1 )\n\t\tVAR_7 = VAR_65;\n\t    else\n\t\t++VAR_7;\t\t/* COMMENT_12 */\n\t    ff_progress_change_total(VAR_7);\n\t    VAR_6->glyphcnt = VAR_6->glyphmax = VAR_7;\n\t    VAR_6->glyphs = calloc(VAR_7,sizeof(SplineChar *));\n\t    if ( VAR_1!=NULL ) {\n\t\tVAR_6->map = VAR_1->map;\n\t    } else {\n\t\tVAR_6->map = EncMapNew(VAR_65,VAR_7,VAR_16);\n\t\tVAR_6->map->remap = remap;\n\t    }\n\t    SFDSizeMap(VAR_6->map,VAR_6->glyphcnt,VAR_65);\n    break;\n#if VAR_66\n\t} else if ( strmatch(VAR_2,\"BeginCompositionRules\")==0 ) {\n\t    VAR_6->rules = SFDReadCompositionRules(VAR_0);\n#endif\n\t} else {\n\t    /* COMMENT_13 */\n\t    geteol(VAR_0,VAR_2);\n\t}\n    }\n\n    /* COMMENT_14 */\n    if ( VAR_6->fontname==NULL)\n\tVAR_6->fontname = copy(\"\");\n\n    if ( VAR_3 )\n\tVAR_6 = SFD_FigureDirType(VAR_6,VAR_2,VAR_4,VAR_16,remap,VAR_20);\n    else if ( VAR_6->subfontcnt!=0 ) {\n\tff_progress_change_stages(2*VAR_6->subfontcnt);\n\tfor ( VAR_8=0; VAR_8<VAR_6->subfontcnt; ++VAR_8 ) {\n\t    if ( VAR_8!=0 )\n\t\tff_progress_next_stage();\n\t    VAR_6->subfonts[VAR_8] = SFD_GetFont(VAR_0,VAR_6,VAR_2,VAR_3,VAR_4,VAR_5);\n\t}\n    } else if ( VAR_6->mm!=NULL ) {\n\tMMSet *VAR_59 = VAR_6->mm;\n\tff_progress_change_stages(2*(VAR_59->instance_count+1));\n\tfor ( VAR_8=0; VAR_8<VAR_59->instance_count; ++VAR_8 ) {\n\t    if ( VAR_8!=0 )\n\t\tff_progress_next_stage();\n\t    VAR_59->instances[VAR_8] = SFD_GetFont(VAR_0,NULL,VAR_2,VAR_3,VAR_4,VAR_5);\n\t    EncMapFree(VAR_59->instances[VAR_8]->map); VAR_59->instances[VAR_8]->map=NULL;\n\t    VAR_59->instances[VAR_8]->mm = VAR_59;\n\t}\n\tff_progress_next_stage();\n\tVAR_59->normal = SFD_GetFont(VAR_0,NULL,VAR_2,VAR_3,VAR_4,VAR_5);\n\tVAR_59->normal->mm = VAR_59;\n\tVAR_6->mm = NULL;\n\tSplineFontFree(VAR_6);\n\tVAR_6 = VAR_59->normal;\n\tif ( VAR_6->map->enc!=&VAR_17 ) {\n\t    EncMap *VAR_67;\n\t    MMMatchGlyphs(VAR_59);\t\t/* COMMENT_15 */\n\t    VAR_67 = EncMapFromEncoding(VAR_6,VAR_6->map->enc);\n\t    EncMapFree(VAR_6->map);\n\t    VAR_6->map = VAR_67;\n\t}\n    } else {\n\twhile ( SFDGetChar(VAR_0,VAR_6,VAR_20)!=NULL ) {\n\t    ff_progress_next();\n\t}\n\tff_progress_next_stage();\n    }\n    VAR_18 = false;\n    while ( getname(VAR_0,VAR_2)==1 ) {\n\tif ( strcmp(VAR_2,\"EndSplineFont\")==0 || strcmp(VAR_2,\"EndSubSplineFont\")==0 )\n    break;\n\telse if ( strcmp(VAR_2,\"BitmapFont:\")==0 )\n\t    SFDGetBitmapFont(VAR_0,VAR_6,false,NULL);\n\telse if ( strmatch(VAR_2,\"DupEnc:\")==0 ) {\n\t    int VAR_16, VAR_68;\n\t    VAR_18 = true;\n\t    if ( getint(VAR_0,&VAR_16) && getint(VAR_0,&VAR_68) && VAR_6->map!=NULL ) {\n\t\tSFDSetEncMap(VAR_6,VAR_68,VAR_16);\n\t    }\n\t}\n    }\n    if ( VAR_6->cidmaster==NULL )\n\tSFDFixupRefs(VAR_6);\n\n    if ( !VAR_18 )\n\tSFD_DoAltUnis(VAR_6);\n    else\n\tAltUniFigure(VAR_6,VAR_6->map,true);\n    if ( VAR_6->sfd_version<2 )\n\tSFD_AssignLookups((SplineFont1 *) VAR_6);\n    if ( !VAR_24.hadtimes )\n\tSFTimesFromFile(VAR_6,VAR_0);\n    /* COMMENT_16 */\n    if (VAR_6->map == NULL) VAR_6->map = EncMapNew(VAR_6->glyphcnt,VAR_6->glyphcnt,&VAR_17);\n\n    SFDFixupUndoRefs(VAR_6);\nreturn( VAR_6 );\n}",
  "func_graph_path": "fontforge/8da6d56bf7af2d25f779e52edef61b2fd4557b3c/sfd.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -487,6 +487,10 @@\n \t}\n     }\n \n+    // Many downstream functions assume this isn't NULL (use strlen, etc.)\n+    if ( sf->fontname==NULL)\n+\tsf->fontname = copy(\"\");\n+\n     if ( fromdir )\n \tsf = SFD_FigureDirType(sf,tok,dirname,enc,remap,had_layer_cnt);\n     else if ( sf->subfontcnt!=0 ) {",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "    // Many downstream functions assume this isn't NULL (use strlen, etc.)",
      "    if ( sf->fontname==NULL)",
      "\tsf->fontname = copy(\"\");",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/fontforge/fontforge/pull/4091",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/fontforge/fontforge/pull/4091: 403 Client Error: Forbidden for url: https://api.github.com/repos/fontforge/fontforge/pulls/4091",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0\n\nThe patch addresses multiple security issues, including use-after-free and NULL pointer dereferences, which are known security vulnerabilities. The code changes specifically fix these issues by preventing accesses to null pointers and ensuring proper initialization, clearly indicating a security vulnerability fix. \n\n**Confidence:** 1.0 - All information is clear, and the code modifications directly address known security issues."
}