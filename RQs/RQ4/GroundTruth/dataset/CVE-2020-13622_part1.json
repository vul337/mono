{
  "cve_id": "CVE-2020-13622",
  "cwe_ids": [
    "CWE-617"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "jerryscript-project/jerryscript",
  "commit_msg": "Improve property key query for Proxy objects\n\nProperty key query for Proxy objects always returned all keys\neven if no symbols were requested symbols were present in the\nresulting array.\n\nJerryScript-DCO-1.0-Signed-off-by: Peter Gal pgal.usz@partner.samsung.com",
  "commit_hash": "2ac4c4a4c52f81a5c9a3eb33215f325b778f8b94",
  "git_url": "https://github.com/jerryscript-project/jerryscript/commit/2ac4c4a4c52f81a5c9a3eb33215f325b778f8b94",
  "file_path": "jerry-core/ecma/operations/ecma-objects.c",
  "func_name": "ecma_op_object_get_property_names",
  "func_before": "ecma_collection_t *\necma_op_object_get_property_names (ecma_object_t *obj_p, /**< object */\n                                   uint32_t opts) /**< any combination of ecma_list_properties_options_t values  */\n{\n  JERRY_ASSERT (obj_p != NULL\n                && !ecma_is_lexical_environment (obj_p));\n\n#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)\n  if (ECMA_OBJECT_IS_PROXY (obj_p))\n  {\n    return ecma_proxy_object_own_property_keys (obj_p);\n  }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */\n\n  if (ecma_op_object_is_fast_array (obj_p))\n  {\n    return ecma_fast_array_get_property_names (obj_p, opts);\n  }\n\n  ecma_collection_t *ret_p = ecma_new_collection ();\n  ecma_collection_t *skipped_non_enumerable_p = ecma_new_collection ();\n\n  const bool is_enumerable_only = (opts & ECMA_LIST_ENUMERABLE) != 0;\n  const bool is_array_indices_only = (opts & ECMA_LIST_ARRAY_INDICES) != 0;\n  const bool is_with_prototype_chain = (opts & ECMA_LIST_PROTOTYPE) != 0;\n#if ENABLED (JERRY_ES2015)\n  const bool is_symbols = (opts & ECMA_LIST_SYMBOLS) != 0;\n  const bool is_symbols_only = (opts & ECMA_LIST_SYMBOLS_ONLY) != 0;\n#endif /* ENABLED (JERRY_ES2015) */\n\n  const size_t bitmap_row_size = sizeof (uint32_t) * JERRY_BITSINBYTE;\n  const size_t names_hashes_bitmap_size = ECMA_OBJECT_HASH_BITMAP_SIZE / bitmap_row_size;\n  JERRY_VLA (uint32_t, names_hashes_bitmap, names_hashes_bitmap_size);\n\n  memset (names_hashes_bitmap, 0, names_hashes_bitmap_size * sizeof (names_hashes_bitmap[0]));\n\n  while (true)\n  {\n    const ecma_object_type_t type = ecma_get_object_type (obj_p);\n    const bool obj_is_builtin = ecma_get_object_is_builtin (obj_p);\n    ecma_length_t string_named_properties_count = 0;\n    ecma_length_t array_index_named_properties_count = 0;\n#if ENABLED (JERRY_ES2015)\n    ecma_length_t symbol_named_properties_count = 0;\n#endif /* ENABLED (JERRY_ES2015) */\n    ecma_collection_t *prop_names_p = ecma_new_collection ();\n\n#if ENABLED (JERRY_ES2015)\n    if (JERRY_LIKELY (!is_symbols_only))\n    {\n#endif /* ENABLED (JERRY_ES2015) */\n\n      if (obj_is_builtin)\n      {\n        if (type == ECMA_OBJECT_TYPE_FUNCTION && ecma_builtin_function_is_routine (obj_p))\n        {\n          ecma_builtin_routine_list_lazy_property_names (obj_p,\n                                                          opts,\n                                                          prop_names_p,\n                                                          skipped_non_enumerable_p);\n        }\n        else\n        {\n          ecma_builtin_list_lazy_property_names (obj_p,\n                                                 opts,\n                                                 prop_names_p,\n                                                 skipped_non_enumerable_p);\n        }\n      }\n      else\n      {\n        switch (type)\n        {\n          case ECMA_OBJECT_TYPE_PSEUDO_ARRAY:\n          {\n  #if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY)\n            if (ecma_object_is_typedarray (obj_p))\n            {\n              ecma_op_typedarray_list_lazy_property_names (obj_p, prop_names_p);\n            }\n  #endif /* ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */\n            break;\n          }\n          case ECMA_OBJECT_TYPE_FUNCTION:\n          {\n            if (!is_array_indices_only)\n            {\n              ecma_op_function_list_lazy_property_names (obj_p,\n                                                         opts,\n                                                         prop_names_p,\n                                                         skipped_non_enumerable_p);\n            }\n            break;\n          }\n          case ECMA_OBJECT_TYPE_EXTERNAL_FUNCTION:\n          {\n            if (!is_array_indices_only)\n            {\n              ecma_op_external_function_list_lazy_property_names (obj_p,\n                                                                  opts,\n                                                                  prop_names_p,\n                                                                  skipped_non_enumerable_p);\n            }\n            break;\n          }\n          case ECMA_OBJECT_TYPE_BOUND_FUNCTION:\n          {\n            if (!is_array_indices_only)\n            {\n              ecma_op_bound_function_list_lazy_property_names (obj_p,\n                                                               opts,\n                                                               prop_names_p,\n                                                               skipped_non_enumerable_p);\n            }\n            break;\n          }\n          case ECMA_OBJECT_TYPE_CLASS:\n          {\n            ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;\n\n            if (ext_object_p->u.class_prop.class_id == LIT_MAGIC_STRING_STRING_UL)\n            {\n              ecma_op_string_list_lazy_property_names (obj_p,\n                                                       opts,\n                                                       prop_names_p,\n                                                       skipped_non_enumerable_p);\n            }\n\n            break;\n          }\n          case ECMA_OBJECT_TYPE_ARRAY:\n          {\n            ecma_op_array_list_lazy_property_names (obj_p,\n                                                    opts,\n                                                    prop_names_p,\n                                                    skipped_non_enumerable_p);\n            break;\n          }\n          default:\n          {\n            JERRY_ASSERT (type == ECMA_OBJECT_TYPE_GENERAL);\n\n            break;\n          }\n        }\n      }\n#if ENABLED (JERRY_ES2015)\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n\n    ecma_value_t *buffer_p = prop_names_p->buffer_p;\n    uint32_t lazy_prop_name_count = prop_names_p->item_count;\n\n    const size_t own_names_hashes_bitmap_size = ECMA_OBJECT_HASH_BITMAP_SIZE / bitmap_row_size;\n    JERRY_VLA (uint32_t, own_names_hashes_bitmap, own_names_hashes_bitmap_size);\n    memset (own_names_hashes_bitmap, 0, own_names_hashes_bitmap_size * sizeof (own_names_hashes_bitmap[0]));\n\n    for (uint32_t i = 0; i < prop_names_p->item_count; i++)\n    {\n      ecma_string_t *name_p = ecma_get_string_from_value (buffer_p[i]);\n\n      if (ecma_string_get_array_index (name_p) != ECMA_STRING_NOT_ARRAY_INDEX)\n      {\n        array_index_named_properties_count++;\n      }\n#if ENABLED (JERRY_ES2015)\n      else if (ecma_prop_name_is_symbol (name_p))\n      {\n        symbol_named_properties_count++;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n      else\n      {\n        string_named_properties_count++;\n      }\n\n#if ENABLED (JERRY_ES2015)\n      /* Symbols are never lazy listed */\n      JERRY_ASSERT (!ecma_prop_name_is_symbol (name_p));\n#endif /* ENABLED (JERRY_ES2015) */\n\n      uint8_t hash = (uint8_t) ecma_string_hash (name_p);\n      uint32_t bitmap_row = (uint32_t) (hash / bitmap_row_size);\n      uint32_t bitmap_column = (uint32_t) (hash % bitmap_row_size);\n\n      if ((own_names_hashes_bitmap[bitmap_row] & (1u << bitmap_column)) == 0)\n      {\n        own_names_hashes_bitmap[bitmap_row] |= (1u << bitmap_column);\n      }\n    }\n\n    jmem_cpointer_t prop_iter_cp = obj_p->u1.property_list_cp;\n\n    if (ecma_op_object_is_fast_array (obj_p) && prop_iter_cp != JMEM_CP_NULL)\n    {\n      ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;\n\n      uint32_t length = ext_obj_p->u.array.length;\n      array_index_named_properties_count = length - ecma_fast_array_get_hole_count (obj_p);\n\n      ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, prop_iter_cp);\n\n      for (uint32_t i = 0; i < length; i++)\n      {\n        if (ecma_is_value_array_hole (values_p[i]))\n        {\n          continue;\n        }\n\n        ecma_string_t *index_str_p = ecma_new_ecma_string_from_uint32 (i);\n\n        uint8_t hash = (uint8_t) ecma_string_hash (index_str_p);\n        uint32_t bitmap_row = (uint32_t) (hash / bitmap_row_size);\n        uint32_t bitmap_column = (uint32_t) (hash % bitmap_row_size);\n\n        bool is_add = true;\n\n        if ((own_names_hashes_bitmap[bitmap_row] & (1u << bitmap_column)) != 0)\n        {\n          buffer_p = prop_names_p->buffer_p;\n\n          for (uint32_t j = 0; j < prop_names_p->item_count; j++)\n          {\n            ecma_string_t *current_name_p = ecma_get_prop_name_from_value (buffer_p[j]);\n\n            if (ecma_compare_ecma_strings (index_str_p, current_name_p))\n            {\n              is_add = false;\n              break;\n            }\n          }\n        }\n\n        if (is_add)\n        {\n          own_names_hashes_bitmap[bitmap_row] |= (1u << bitmap_column);\n\n          ecma_collection_push_back (prop_names_p, ecma_make_string_value (index_str_p));\n        }\n      }\n    }\n    else\n    {\n#if ENABLED (JERRY_PROPRETY_HASHMAP)\n      if (prop_iter_cp != JMEM_CP_NULL)\n      {\n        ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);\n\n        if (prop_iter_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)\n        {\n          prop_iter_cp = prop_iter_p->next_property_cp;\n        }\n      }\n  #endif /* ENABLED (JERRY_PROPRETY_HASHMAP) */\n\n      while (prop_iter_cp != JMEM_CP_NULL)\n      {\n        ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);\n        JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (prop_iter_p));\n\n        for (int i = 0; i < ECMA_PROPERTY_PAIR_ITEM_COUNT; i++)\n        {\n          ecma_property_t *property_p = prop_iter_p->types + i;\n\n          if (ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDDATA\n              || ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDACCESSOR)\n          {\n            ecma_property_pair_t *prop_pair_p = (ecma_property_pair_t *) prop_iter_p;\n\n            if (ECMA_PROPERTY_GET_NAME_TYPE (*property_p) == ECMA_DIRECT_STRING_MAGIC\n                && prop_pair_p->names_cp[i] >= LIT_NON_INTERNAL_MAGIC_STRING__COUNT\n                && prop_pair_p->names_cp[i] < LIT_MAGIC_STRING__COUNT)\n            {\n              /* Internal properties are never enumerated. */\n              continue;\n            }\n\n            ecma_string_t *name_p = ecma_string_from_property_name (*property_p,\n                                                                    prop_pair_p->names_cp[i]);\n\n            if (!(is_enumerable_only && !ecma_is_property_enumerable (*property_p)))\n            {\n  #if ENABLED (JERRY_ES2015)\n              /* We skip the current property in the following cases:\n                 1. We don't want to list symbols (is_symbols and is_symbols_only are false)\n                    and the current property is a symbol.\n                 2. We only want to list symbols (is_symbols_only is true) and the current\n                    property is NOT a symbol. */\n              bool is_symbol = ecma_prop_name_is_symbol (name_p);\n              if ((!(is_symbols || is_symbols_only) && is_symbol) || (is_symbols_only && !is_symbol))\n              {\n                ecma_deref_ecma_string (name_p);\n                continue;\n              }\n  #endif /* ENABLED (JERRY_ES2015) */\n\n              uint8_t hash = (uint8_t) ecma_string_hash (name_p);\n              uint32_t bitmap_row = (uint32_t) (hash / bitmap_row_size);\n              uint32_t bitmap_column = (uint32_t) (hash % bitmap_row_size);\n\n              bool is_add = true;\n\n              if ((own_names_hashes_bitmap[bitmap_row] & (1u << bitmap_column)) != 0)\n              {\n                buffer_p = prop_names_p->buffer_p;\n\n                for (uint32_t j = 0; j < prop_names_p->item_count; j++)\n                {\n                  ecma_string_t *current_name_p = ecma_get_prop_name_from_value (buffer_p[j]);\n\n                  if (ecma_compare_ecma_strings (name_p, current_name_p))\n                  {\n                    is_add = false;\n                    break;\n                  }\n                }\n              }\n\n              if (is_add)\n              {\n                if (ecma_string_get_array_index (name_p) != ECMA_STRING_NOT_ARRAY_INDEX)\n                {\n                  /* The name is a valid array index. */\n                  array_index_named_properties_count++;\n                }\n                else if (!is_array_indices_only)\n                {\n  #if ENABLED (JERRY_ES2015)\n                  if (ecma_prop_name_is_symbol (name_p))\n                  {\n                    symbol_named_properties_count++;\n                  }\n                  else\n                  {\n  #endif /* ENABLED (JERRY_ES2015) */\n                    string_named_properties_count++;\n  #if ENABLED (JERRY_ES2015)\n                  }\n  #endif /* ENABLED (JERRY_ES2015) */\n                }\n                else\n                {\n                  ecma_deref_ecma_string (name_p);\n                  continue;\n                }\n\n                own_names_hashes_bitmap[bitmap_row] |= (1u << bitmap_column);\n\n                ecma_collection_push_back (prop_names_p, ecma_make_prop_name_value (name_p));\n              }\n              else\n              {\n                ecma_deref_ecma_string (name_p);\n              }\n            }\n            else\n            {\n              JERRY_ASSERT (is_enumerable_only && !ecma_is_property_enumerable (*property_p));\n\n              ecma_collection_push_back (skipped_non_enumerable_p, ecma_make_prop_name_value (name_p));\n            }\n          }\n        }\n\n        prop_iter_cp = prop_iter_p->next_property_cp;\n      }\n    }\n\n    ecma_length_t all_properties_count = array_index_named_properties_count + string_named_properties_count;\n\n#if ENABLED (JERRY_ES2015)\n    all_properties_count += symbol_named_properties_count;\n#endif /* ENABLED (JERRY_ES2015) */\n\n    /* Second pass: collecting property names into an array. */\n    JMEM_DEFINE_LOCAL_ARRAY (names_p, all_properties_count, ecma_string_t *);\n\n    ecma_string_t **string_names_p = names_p + array_index_named_properties_count;\n#if ENABLED (JERRY_ES2015)\n    ecma_string_t **symbol_names_p = string_names_p + string_named_properties_count;\n#endif /* ENABLED (JERRY_ES2015) */\n\n    uint32_t array_index_name_pos = 0;\n    uint32_t string_name_pos = string_named_properties_count;\n    uint32_t lazy_string_name_pos = 0;\n#if ENABLED (JERRY_ES2015)\n    uint32_t symbol_name_pos = symbol_named_properties_count;\n#endif /* ENABLED (JERRY_ES2015) */\n\n    buffer_p = prop_names_p->buffer_p;\n\n    for (uint32_t i = 0; i < prop_names_p->item_count; i++)\n    {\n      ecma_string_t *name_p = ecma_get_prop_name_from_value (buffer_p[i]);\n      ecma_ref_ecma_string (name_p);\n\n      uint32_t index = ecma_string_get_array_index (name_p);\n\n      if (index != ECMA_STRING_NOT_ARRAY_INDEX)\n      {\n        JERRY_ASSERT (array_index_name_pos < array_index_named_properties_count);\n\n        uint32_t insertion_pos = 0;\n        while (insertion_pos < array_index_name_pos\n               && index > ecma_string_get_array_index (names_p[insertion_pos]))\n        {\n          insertion_pos++;\n        }\n\n        if (insertion_pos == array_index_name_pos)\n        {\n          names_p[array_index_name_pos++] = name_p;\n        }\n        else\n        {\n          JERRY_ASSERT (insertion_pos < array_index_name_pos);\n          JERRY_ASSERT (index <= ecma_string_get_array_index (names_p[insertion_pos]));\n\n          uint32_t move_pos = array_index_name_pos++;\n\n          while (move_pos > insertion_pos)\n          {\n            names_p[move_pos] = names_p[move_pos - 1u];\n\n            move_pos--;\n          }\n\n          names_p[insertion_pos] = name_p;\n        }\n      }\n#if ENABLED (JERRY_ES2015)\n      else if (ecma_prop_name_is_symbol (name_p))\n      {\n        // Put in the symbols in reverse order.\n        JERRY_ASSERT (symbol_name_pos > 0);\n        JERRY_ASSERT (symbol_name_pos <= symbol_named_properties_count);\n\n        symbol_names_p[--symbol_name_pos] = name_p;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n      else\n      {\n        // Put in the strings in reverse order.\n        JERRY_ASSERT (string_name_pos > 0);\n        JERRY_ASSERT (string_name_pos <= string_named_properties_count);\n\n        if (i < lazy_prop_name_count)\n        {\n          string_names_p[lazy_string_name_pos++] = name_p;\n        }\n        else\n        {\n          string_names_p[--string_name_pos] = name_p;\n        }\n      }\n    }\n\n    JERRY_ASSERT (array_index_name_pos == array_index_named_properties_count);\n    JERRY_ASSERT (string_name_pos - lazy_string_name_pos == 0);\n#if ENABLED (JERRY_ES2015)\n    JERRY_ASSERT (symbol_name_pos == 0);\n#endif /* ENABLED (JERRY_ES2015) */\n\n    ecma_collection_free (prop_names_p);\n\n    /* Third pass:\n     *   embedding own property names of current object of prototype chain to aggregate property names collection */\n    for (uint32_t i = 0; i < all_properties_count; i++)\n    {\n      bool is_append = true;\n\n      ecma_string_t *name_p = names_p[i];\n\n      uint8_t hash = (uint8_t) ecma_string_hash (name_p);\n      uint32_t bitmap_row = (uint32_t) (hash / bitmap_row_size);\n      uint32_t bitmap_column = (uint32_t) (hash % bitmap_row_size);\n\n      if ((names_hashes_bitmap[bitmap_row] & (1u << bitmap_column)) == 0)\n      {\n        /* This hash has not been used before (for non-skipped). */\n        names_hashes_bitmap[bitmap_row] |= (1u << bitmap_column);\n      }\n      else\n      {\n        /* Name with same hash has already occured. */\n        buffer_p = ret_p->buffer_p;\n\n        for (uint32_t j = 0; j < ret_p->item_count; j++)\n        {\n          ecma_string_t *current_name_p = ecma_get_prop_name_from_value (buffer_p[j]);\n\n          if (ecma_compare_ecma_strings (name_p, current_name_p))\n          {\n            is_append = false;\n            break;\n          }\n        }\n      }\n\n      if (is_append)\n      {\n        buffer_p = skipped_non_enumerable_p->buffer_p;\n\n        for (uint32_t j = 0; j < skipped_non_enumerable_p->item_count; j++)\n        {\n          ecma_string_t *current_name_p = ecma_get_prop_name_from_value (buffer_p[j]);\n\n          if (ecma_compare_ecma_strings (name_p, current_name_p))\n          {\n            is_append = false;\n            break;\n          }\n        }\n      }\n\n      if (is_append)\n      {\n        JERRY_ASSERT ((names_hashes_bitmap[bitmap_row] & (1u << bitmap_column)) != 0);\n\n        ecma_collection_push_back (ret_p, ecma_make_prop_name_value (name_p));\n      }\n      else\n      {\n        ecma_deref_ecma_string (name_p);\n      }\n\n    }\n\n    JMEM_FINALIZE_LOCAL_ARRAY (names_p);\n\n    if (!is_with_prototype_chain || obj_p->u2.prototype_cp == JMEM_CP_NULL)\n    {\n      break;\n    }\n\n    obj_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, obj_p->u2.prototype_cp);\n  }\n\n  ecma_collection_free (skipped_non_enumerable_p);\n\n  return ret_p;\n}",
  "abstract_func_before": "ecma_collection_t *\necma_op_object_get_property_names (ecma_object_t *VAR_0, /* COMMENT_0 */\n                                   uint32_t VAR_1) /* COMMENT_1 */\n{\n  JERRY_ASSERT (VAR_0 != NULL\n                && !ecma_is_lexical_environment (VAR_0));\n\n#if ENABLED (VAR_2)\n  if (ECMA_OBJECT_IS_PROXY (VAR_0))\n  {\n    return ecma_proxy_object_own_property_keys (VAR_0);\n  }\n#endif /* COMMENT_2 */\n\n  if (ecma_op_object_is_fast_array (VAR_0))\n  {\n    return ecma_fast_array_get_property_names (VAR_0, VAR_1);\n  }\n\n  ecma_collection_t *VAR_3 = ecma_new_collection ();\n  ecma_collection_t *VAR_4 = ecma_new_collection ();\n\n  const bool VAR_5 = (VAR_1 & VAR_6) != 0;\n  const bool VAR_7 = (VAR_1 & VAR_8) != 0;\n  const bool VAR_9 = (VAR_1 & VAR_10) != 0;\n#if ENABLED (VAR_11)\n  const bool VAR_12 = (VAR_1 & VAR_13) != 0;\n  const bool VAR_14 = (VAR_1 & VAR_15) != 0;\n#endif /* COMMENT_3 */\n\n  const size_t VAR_16 = sizeof (uint32_t) * VAR_17;\n  const size_t VAR_18 = VAR_19 / VAR_16;\n  JERRY_VLA (uint32_t, VAR_20, VAR_18);\n\n  memset (VAR_20, 0, VAR_18 * sizeof (VAR_20[0]));\n\n  while (true)\n  {\n    const ecma_object_type_t VAR_21 = ecma_get_object_type (VAR_0);\n    const bool VAR_22 = ecma_get_object_is_builtin (VAR_0);\n    ecma_length_t VAR_23 = 0;\n    ecma_length_t VAR_24 = 0;\n#if ENABLED (VAR_11)\n    ecma_length_t VAR_25 = 0;\n#endif /* COMMENT_3 */\n    ecma_collection_t *VAR_26 = ecma_new_collection ();\n\n#if ENABLED (VAR_11)\n    if (JERRY_LIKELY (!VAR_14))\n    {\n#endif/* COMMENT_4 */\n\n      if (obj_is_builtin)\n      {\n        if (VAR_21 == VAR_27 && ecma_builtin_function_is_routine (VAR_0))\n        {\n          ecma_builtin_routine_list_lazy_property_names (VAR_0,\n                                                          VAR_1,\n                                                          VAR_26,\n                                                          VAR_4);\n        }\n        else\n        {\n          ecma_builtin_list_lazy_property_names (VAR_0,\n                                                 VAR_1,\n                                                 VAR_26,\n                                                 VAR_4);\n        }\n      }\n      else\n      {\n        switch (VAR_21)\n        {\n          case VAR_28:\n          {\n  #if ENABLED (VAR_29)\n            if (ecma_object_is_typedarray (VAR_0))\n            {\n              ecma_op_typedarray_list_lazy_property_names (VAR_0, VAR_26);\n            }\n  #endif /* COMMENT_5 */\n            break;\n          }\n          case VAR_27:\n          {\n            if (!VAR_7)\n            {\n              ecma_op_function_list_lazy_property_names (VAR_0,\n                                                         VAR_1,\n                                                         VAR_26,\n                                                         VAR_4);\n            }\n            break;\n          }\n          case VAR_30:\n          {\n            if (!VAR_7)\n            {\n              ecma_op_external_function_list_lazy_property_names (VAR_0,\n                                                                  VAR_1,\n                                                                  VAR_26,\n                                                                  VAR_4);\n            }\n            break;\n          }\n          case VAR_31:\n          {\n            if (!VAR_7)\n            {\n              ecma_op_bound_function_list_lazy_property_names (VAR_0,\n                                                               VAR_1,\n                                                               VAR_26,\n                                                               VAR_4);\n            }\n            break;\n          }\n          case VAR_32:\n          {\n            ecma_extended_object_t *VAR_33 = (ecma_extended_object_t *) VAR_0;\n\n            if (VAR_33->u.class_prop.class_id == VAR_34)\n            {\n              ecma_op_string_list_lazy_property_names (VAR_0,\n                                                       VAR_1,\n                                                       VAR_26,\n                                                       VAR_4);\n            }\n\n            break;\n          }\n          case VAR_35:\n          {\n            ecma_op_array_list_lazy_property_names (VAR_0,\n                                                    VAR_1,\n                                                    VAR_26,\n                                                    VAR_4);\n            break;\n          }\n          default:\n          {\n            JERRY_ASSERT (VAR_21 == VAR_36);\n\n            break;\n          }\n        }\n      }\n#if ENABLED (VAR_11)\n    }\n#endif /* COMMENT_3 */\n\n    ecma_value_t *VAR_37 = VAR_26->buffer_p;\n    uint32_t VAR_38 = VAR_26->item_count;\n\n    const size_t VAR_39 = VAR_19 / VAR_16;\n    JERRY_VLA (uint32_t, VAR_40, VAR_39);\n    memset (VAR_40, 0, VAR_39 * sizeof (VAR_40[0]));\n\n    for (uint32_t VAR_41 = 0; VAR_41 < VAR_26->item_count; VAR_41++)\n    {\n      ecma_string_t *VAR_42 = ecma_get_string_from_value (VAR_37[VAR_41]);\n\n      if (ecma_string_get_array_index (VAR_42) != VAR_43)\n      {\n        VAR_24++;\n      }\n#if ENABLED (VAR_11)\n      else if (ecma_prop_name_is_symbol (name_p))\n      {\n        VAR_25++;\n      }\n#endif /* COMMENT_3 */\n      else\n      {\n        VAR_23++;\n      }\n\n#if ENABLED (VAR_11)\n      /* COMMENT_6 */\n      JERRY_ASSERT (!ecma_prop_name_is_symbol (name_p));\n#endif /* COMMENT_3 */\n\n      uint8_t VAR_44 = (uint8_t) ecma_string_hash (name_p);\n      uint32_t VAR_45 = (uint32_t) (VAR_44 / VAR_16);\n      uint32_t VAR_46 = (uint32_t) (VAR_44 % VAR_16);\n\n      if ((VAR_40[VAR_45] & (1u << VAR_46)) == 0)\n      {\n        VAR_40[VAR_45] |= (1u << VAR_46);\n      }\n    }\n\n    jmem_cpointer_t VAR_47 = VAR_0->u1.property_list_cp;\n\n    if (ecma_op_object_is_fast_array (VAR_0) && VAR_47 != VAR_48)\n    {\n      ecma_extended_object_t *VAR_49 = (ecma_extended_object_t *) VAR_0;\n\n      uint32_t VAR_50 = VAR_49->u.array.length;\n      VAR_24 = VAR_50 - ecma_fast_array_get_hole_count (VAR_0);\n\n      ecma_value_t *VAR_51 = ECMA_GET_NON_NULL_POINTER (ecma_value_t, VAR_47);\n\n      for (uint32_t VAR_41 = 0; VAR_41 < VAR_50; VAR_41++)\n      {\n        if (ecma_is_value_array_hole (VAR_51[VAR_41]))\n        {\n          continue;\n        }\n\n        ecma_string_t *VAR_52 = ecma_new_ecma_string_from_uint32 (VAR_41);\n\n        uint8_t VAR_44 = (uint8_t) ecma_string_hash (VAR_52);\n        uint32_t VAR_45 = (uint32_t) (VAR_44 / VAR_16);\n        uint32_t VAR_46 = (uint32_t) (VAR_44 % VAR_16);\n\n        bool VAR_53 = true;\n\n        if ((VAR_40[VAR_45] & (1u << VAR_46)) != 0)\n        {\n          VAR_37 = VAR_26->buffer_p;\n\n          for (uint32_t VAR_54 = 0; VAR_54 < VAR_26->item_count; VAR_54++)\n          {\n            ecma_string_t *VAR_55 = ecma_get_prop_name_from_value (VAR_37[VAR_54]);\n\n            if (ecma_compare_ecma_strings (VAR_52, VAR_55))\n            {\n              VAR_53 = false;\n              break;\n            }\n          }\n        }\n\n        if (VAR_53)\n        {\n          VAR_40[VAR_45] |= (1u << VAR_46);\n\n          ecma_collection_push_back (VAR_26, ecma_make_string_value (VAR_52));\n        }\n      }\n    }\n    else\n    {\n#if ENABLED (VAR_56)\n      if (VAR_47 != VAR_48)\n      {\n        ecma_property_header_t *VAR_57 = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, VAR_47);\n\n        if (VAR_57->types[0] == VAR_58)\n        {\n          VAR_47 = VAR_57->next_property_cp;\n        }\n      }\n  #endif /* COMMENT_7 */\n\n      while (VAR_47 != VAR_48)\n      {\n        ecma_property_header_t *VAR_57 = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, VAR_47);\n        JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (VAR_57));\n\n        for (int VAR_41 = 0; VAR_41 < VAR_59; VAR_41++)\n        {\n          ecma_property_t *VAR_60 = VAR_57->types + VAR_41;\n\n          if (ECMA_PROPERTY_GET_TYPE (*VAR_60) == VAR_61\n              || ECMA_PROPERTY_GET_TYPE (*VAR_60) == VAR_62)\n          {\n            ecma_property_pair_t *VAR_63 = (ecma_property_pair_t *) VAR_57;\n\n            if (ECMA_PROPERTY_GET_NAME_TYPE (*VAR_60) == VAR_64\n                && VAR_63->names_cp[VAR_41] >= VAR_65\n                && VAR_63->names_cp[VAR_41] < VAR_66)\n            {\n              /* COMMENT_8 */\n              continue;\n            }\n\n            ecma_string_t *name_p = ecma_string_from_property_name (*VAR_60,\n                                                                    VAR_63->names_cp[VAR_41]);\n\n            if (!(VAR_5 && !ecma_is_property_enumerable (*VAR_60)))\n            {\n  #if ENABLED (VAR_11)\n              /* COMMENT_9 */\n                                                                                            \n                                                         \n                                                                                          \n                                                \n              bool VAR_67 = ecma_prop_name_is_symbol (name_p);\n              if ((!(VAR_12 || VAR_14) && VAR_67) || (VAR_14 && !VAR_67))\n              {\n                ecma_deref_ecma_string (name_p);\n                continue;\n              }\n  #endif /* COMMENT_3 */\n\n              uint8_t VAR_44 = (uint8_t) ecma_string_hash (name_p);\n              uint32_t VAR_45 = (uint32_t) (VAR_44 / VAR_16);\n              uint32_t VAR_46 = (uint32_t) (VAR_44 % VAR_16);\n\n              bool VAR_53 = true;\n\n              if ((VAR_40[VAR_45] & (1u << VAR_46)) != 0)\n              {\n                VAR_37 = VAR_26->buffer_p;\n\n                for (uint32_t VAR_54 = 0; VAR_54 < VAR_26->item_count; VAR_54++)\n                {\n                  ecma_string_t *VAR_55 = ecma_get_prop_name_from_value (VAR_37[VAR_54]);\n\n                  if (ecma_compare_ecma_strings (name_p, VAR_55))\n                  {\n                    VAR_53 = false;\n                    break;\n                  }\n                }\n              }\n\n              if (VAR_53)\n              {\n                if (ecma_string_get_array_index (name_p) != VAR_43)\n                {\n                  /* COMMENT_14 */\n                  VAR_24++;\n                }\n                else if (!VAR_7)\n                {\n  #if ENABLED (VAR_11)\n                  if (ecma_prop_name_is_symbol (name_p))\n                  {\n                    VAR_25++;\n                  }\n                  else\n                  {\n  #endif/* COMMENT_4 */\n                    string_named_properties_count++;\n  #if ENABLED (VAR_11)\n                  }\n  #endif /* COMMENT_3 */\n                }\n                else\n                {\n                  ecma_deref_ecma_string (name_p);\n                  continue;\n                }\n\n                VAR_40[VAR_45] |= (1u << VAR_46);\n\n                ecma_collection_push_back (VAR_26, ecma_make_prop_name_value (name_p));\n              }\n              else\n              {\n                ecma_deref_ecma_string (name_p);\n              }\n            }\n            else\n            {\n              JERRY_ASSERT (VAR_5 && !ecma_is_property_enumerable (*VAR_60));\n\n              ecma_collection_push_back (VAR_4, ecma_make_prop_name_value (name_p));\n            }\n          }\n        }\n\n        VAR_47 = VAR_57->next_property_cp;\n      }\n    }\n\n    ecma_length_t VAR_68 = VAR_24 + VAR_23;\n\n#if ENABLED (VAR_11)\n    VAR_68 += VAR_25;\n#endif /* COMMENT_3 */\n\n    /* COMMENT_15 */\n    JMEM_DEFINE_LOCAL_ARRAY (VAR_69, VAR_68, ecma_string_t *);\n\n    ecma_string_t **VAR_70 = VAR_69 + VAR_24;\n#if ENABLED (VAR_11)\n    ecma_string_t **VAR_71 = VAR_70 + VAR_23;\n#endif /* COMMENT_3 */\n\n    uint32_t VAR_72 = 0;\n    uint32_t VAR_73 = VAR_23;\n    uint32_t VAR_74 = 0;\n#if ENABLED (VAR_11)\n    uint32_t VAR_75 = VAR_25;\n#endif /* COMMENT_3 */\n\n    VAR_37 = VAR_26->buffer_p;\n\n    for (uint32_t VAR_41 = 0; VAR_41 < VAR_26->item_count; VAR_41++)\n    {\n      ecma_string_t *name_p = ecma_get_prop_name_from_value (VAR_37[VAR_41]);\n      ecma_ref_ecma_string (name_p);\n\n      uint32_t VAR_76 = ecma_string_get_array_index (name_p);\n\n      if (VAR_76 != VAR_43)\n      {\n        JERRY_ASSERT (VAR_72 < VAR_24);\n\n        uint32_t VAR_77 = 0;\n        while (VAR_77 < VAR_72\n               && VAR_76 > ecma_string_get_array_index (VAR_69[VAR_77]))\n        {\n          VAR_77++;\n        }\n\n        if (VAR_77 == VAR_72)\n        {\n          VAR_69[VAR_72++] = name_p;\n        }\n        else\n        {\n          JERRY_ASSERT (VAR_77 < VAR_72);\n          JERRY_ASSERT (VAR_76 <= ecma_string_get_array_index (VAR_69[VAR_77]));\n\n          uint32_t VAR_78 = VAR_72++;\n\n          while (VAR_78 > VAR_77)\n          {\n            VAR_69[VAR_78] = VAR_69[VAR_78 - 1u];\n\n            VAR_78--;\n          }\n\n          VAR_69[VAR_77] = name_p;\n        }\n      }\n#if ENABLED (VAR_11)\n      else if (ecma_prop_name_is_symbol (name_p))\n      {\n        /* COMMENT_16 */\n        JERRY_ASSERT (VAR_75 > 0);\n        JERRY_ASSERT (VAR_75 <= VAR_25);\n\n        VAR_71[--VAR_75] = name_p;\n      }\n#endif /* COMMENT_3 */\n      else\n      {\n        /* COMMENT_17 */\n        JERRY_ASSERT (VAR_73 > 0);\n        JERRY_ASSERT (VAR_73 <= VAR_23);\n\n        if (VAR_41 < VAR_38)\n        {\n          VAR_70[VAR_74++] = name_p;\n        }\n        else\n        {\n          VAR_70[--VAR_73] = name_p;\n        }\n      }\n    }\n\n    JERRY_ASSERT (VAR_72 == VAR_24);\n    JERRY_ASSERT (VAR_73 - VAR_74 == 0);\n#if ENABLED (VAR_11)\n    JERRY_ASSERT (VAR_75 == 0);\n#endif /* COMMENT_3 */\n\n    ecma_collection_free (VAR_26);\n\n    /* COMMENT_18 */\n                                                                                                                    \n    for (uint32_t VAR_41 = 0; VAR_41 < VAR_68; VAR_41++)\n    {\n      bool VAR_79 = true;\n\n      ecma_string_t *name_p = VAR_69[VAR_41];\n\n      uint8_t VAR_44 = (uint8_t) ecma_string_hash (name_p);\n      uint32_t VAR_45 = (uint32_t) (VAR_44 / VAR_16);\n      uint32_t VAR_46 = (uint32_t) (VAR_44 % VAR_16);\n\n      if ((VAR_20[VAR_45] & (1u << VAR_46)) == 0)\n      {\n        /* COMMENT_20 */\n        VAR_20[VAR_45] |= (1u << VAR_46);\n      }\n      else\n      {\n        /* COMMENT_21 */\n        VAR_37 = VAR_3->buffer_p;\n\n        for (uint32_t VAR_54 = 0; VAR_54 < VAR_3->item_count; VAR_54++)\n        {\n          ecma_string_t *VAR_55 = ecma_get_prop_name_from_value (VAR_37[VAR_54]);\n\n          if (ecma_compare_ecma_strings (name_p, VAR_55))\n          {\n            VAR_79 = false;\n            break;\n          }\n        }\n      }\n\n      if (VAR_79)\n      {\n        VAR_37 = VAR_4->buffer_p;\n\n        for (uint32_t VAR_54 = 0; VAR_54 < VAR_4->item_count; VAR_54++)\n        {\n          ecma_string_t *VAR_55 = ecma_get_prop_name_from_value (VAR_37[VAR_54]);\n\n          if (ecma_compare_ecma_strings (name_p, VAR_55))\n          {\n            VAR_79 = false;\n            break;\n          }\n        }\n      }\n\n      if (VAR_79)\n      {\n        JERRY_ASSERT ((VAR_20[VAR_45] & (1u << VAR_46)) != 0);\n\n        ecma_collection_push_back (VAR_3, ecma_make_prop_name_value (name_p));\n      }\n      else\n      {\n        ecma_deref_ecma_string (name_p);\n      }\n\n    }\n\n    JMEM_FINALIZE_LOCAL_ARRAY (VAR_69);\n\n    if (!VAR_9 || VAR_0->u2.prototype_cp == VAR_48)\n    {\n      break;\n    }\n\n    VAR_0 = ECMA_GET_NON_NULL_POINTER (ecma_object_t, VAR_0->u2.prototype_cp);\n  }\n\n  ecma_collection_free (VAR_4);\n\n  return VAR_3;\n}",
  "func_graph_path_before": "jerryscript-project/jerryscript/2ac4c4a4c52f81a5c9a3eb33215f325b778f8b94/ecma-objects.c/vul/before/0.json",
  "func": "ecma_collection_t *\necma_op_object_get_property_names (ecma_object_t *obj_p, /**< object */\n                                   uint32_t opts) /**< any combination of ecma_list_properties_options_t values  */\n{\n  JERRY_ASSERT (obj_p != NULL\n                && !ecma_is_lexical_environment (obj_p));\n\n#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)\n  if (ECMA_OBJECT_IS_PROXY (obj_p))\n  {\n    /* Integrated a part of ECMA 262 v6 7.3.21 EnumerableOwnNames operation. */\n    ecma_collection_t *proxy_keys = ecma_proxy_object_own_property_keys (obj_p);\n    if (JERRY_UNLIKELY (proxy_keys == NULL))\n    {\n      return proxy_keys;\n    }\n    ecma_collection_t *return_keys = ecma_new_collection ();\n\n    /* Move valid elements to the output collection */\n    for (uint32_t i = 0; i < proxy_keys->item_count; i++)\n    {\n      ecma_value_t entry = proxy_keys->buffer_p[i];\n      ecma_string_t *prop_name_p = ecma_get_prop_name_from_value (entry);\n      bool prop_is_symbol = ecma_prop_name_is_symbol (prop_name_p);\n\n      if (prop_is_symbol && ((opts & (ECMA_LIST_SYMBOLS | ECMA_LIST_SYMBOLS_ONLY)) != 0))\n      {\n        ecma_collection_push_back (return_keys, entry);\n      }\n      else if (!prop_is_symbol && (opts & ECMA_LIST_SYMBOLS_ONLY) == 0)\n      {\n        ecma_collection_push_back (return_keys, entry);\n      }\n      else\n      {\n        ecma_free_value (entry);\n      }\n    }\n\n    ecma_collection_destroy (proxy_keys);\n    return return_keys;\n  }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */\n\n  if (ecma_op_object_is_fast_array (obj_p))\n  {\n    return ecma_fast_array_get_property_names (obj_p, opts);\n  }\n\n  ecma_collection_t *ret_p = ecma_new_collection ();\n  ecma_collection_t *skipped_non_enumerable_p = ecma_new_collection ();\n\n  const bool is_enumerable_only = (opts & ECMA_LIST_ENUMERABLE) != 0;\n  const bool is_array_indices_only = (opts & ECMA_LIST_ARRAY_INDICES) != 0;\n  const bool is_with_prototype_chain = (opts & ECMA_LIST_PROTOTYPE) != 0;\n#if ENABLED (JERRY_ES2015)\n  const bool is_symbols = (opts & ECMA_LIST_SYMBOLS) != 0;\n  const bool is_symbols_only = (opts & ECMA_LIST_SYMBOLS_ONLY) != 0;\n#endif /* ENABLED (JERRY_ES2015) */\n\n  const size_t bitmap_row_size = sizeof (uint32_t) * JERRY_BITSINBYTE;\n  const size_t names_hashes_bitmap_size = ECMA_OBJECT_HASH_BITMAP_SIZE / bitmap_row_size;\n  JERRY_VLA (uint32_t, names_hashes_bitmap, names_hashes_bitmap_size);\n\n  memset (names_hashes_bitmap, 0, names_hashes_bitmap_size * sizeof (names_hashes_bitmap[0]));\n\n  while (true)\n  {\n    const ecma_object_type_t type = ecma_get_object_type (obj_p);\n    const bool obj_is_builtin = ecma_get_object_is_builtin (obj_p);\n    ecma_length_t string_named_properties_count = 0;\n    ecma_length_t array_index_named_properties_count = 0;\n#if ENABLED (JERRY_ES2015)\n    ecma_length_t symbol_named_properties_count = 0;\n#endif /* ENABLED (JERRY_ES2015) */\n    ecma_collection_t *prop_names_p = ecma_new_collection ();\n\n#if ENABLED (JERRY_ES2015)\n    if (JERRY_LIKELY (!is_symbols_only))\n    {\n#endif /* ENABLED (JERRY_ES2015) */\n\n      if (obj_is_builtin)\n      {\n        if (type == ECMA_OBJECT_TYPE_FUNCTION && ecma_builtin_function_is_routine (obj_p))\n        {\n          ecma_builtin_routine_list_lazy_property_names (obj_p,\n                                                          opts,\n                                                          prop_names_p,\n                                                          skipped_non_enumerable_p);\n        }\n        else\n        {\n          ecma_builtin_list_lazy_property_names (obj_p,\n                                                 opts,\n                                                 prop_names_p,\n                                                 skipped_non_enumerable_p);\n        }\n      }\n      else\n      {\n        switch (type)\n        {\n          case ECMA_OBJECT_TYPE_PSEUDO_ARRAY:\n          {\n  #if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY)\n            if (ecma_object_is_typedarray (obj_p))\n            {\n              ecma_op_typedarray_list_lazy_property_names (obj_p, prop_names_p);\n            }\n  #endif /* ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */\n            break;\n          }\n          case ECMA_OBJECT_TYPE_FUNCTION:\n          {\n            if (!is_array_indices_only)\n            {\n              ecma_op_function_list_lazy_property_names (obj_p,\n                                                         opts,\n                                                         prop_names_p,\n                                                         skipped_non_enumerable_p);\n            }\n            break;\n          }\n          case ECMA_OBJECT_TYPE_EXTERNAL_FUNCTION:\n          {\n            if (!is_array_indices_only)\n            {\n              ecma_op_external_function_list_lazy_property_names (obj_p,\n                                                                  opts,\n                                                                  prop_names_p,\n                                                                  skipped_non_enumerable_p);\n            }\n            break;\n          }\n          case ECMA_OBJECT_TYPE_BOUND_FUNCTION:\n          {\n            if (!is_array_indices_only)\n            {\n              ecma_op_bound_function_list_lazy_property_names (obj_p,\n                                                               opts,\n                                                               prop_names_p,\n                                                               skipped_non_enumerable_p);\n            }\n            break;\n          }\n          case ECMA_OBJECT_TYPE_CLASS:\n          {\n            ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;\n\n            if (ext_object_p->u.class_prop.class_id == LIT_MAGIC_STRING_STRING_UL)\n            {\n              ecma_op_string_list_lazy_property_names (obj_p,\n                                                       opts,\n                                                       prop_names_p,\n                                                       skipped_non_enumerable_p);\n            }\n\n            break;\n          }\n          case ECMA_OBJECT_TYPE_ARRAY:\n          {\n            ecma_op_array_list_lazy_property_names (obj_p,\n                                                    opts,\n                                                    prop_names_p,\n                                                    skipped_non_enumerable_p);\n            break;\n          }\n          default:\n          {\n            JERRY_ASSERT (type == ECMA_OBJECT_TYPE_GENERAL);\n\n            break;\n          }\n        }\n      }\n#if ENABLED (JERRY_ES2015)\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n\n    ecma_value_t *buffer_p = prop_names_p->buffer_p;\n    uint32_t lazy_prop_name_count = prop_names_p->item_count;\n\n    const size_t own_names_hashes_bitmap_size = ECMA_OBJECT_HASH_BITMAP_SIZE / bitmap_row_size;\n    JERRY_VLA (uint32_t, own_names_hashes_bitmap, own_names_hashes_bitmap_size);\n    memset (own_names_hashes_bitmap, 0, own_names_hashes_bitmap_size * sizeof (own_names_hashes_bitmap[0]));\n\n    for (uint32_t i = 0; i < prop_names_p->item_count; i++)\n    {\n      ecma_string_t *name_p = ecma_get_string_from_value (buffer_p[i]);\n\n      if (ecma_string_get_array_index (name_p) != ECMA_STRING_NOT_ARRAY_INDEX)\n      {\n        array_index_named_properties_count++;\n      }\n#if ENABLED (JERRY_ES2015)\n      else if (ecma_prop_name_is_symbol (name_p))\n      {\n        symbol_named_properties_count++;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n      else\n      {\n        string_named_properties_count++;\n      }\n\n#if ENABLED (JERRY_ES2015)\n      /* Symbols are never lazy listed */\n      JERRY_ASSERT (!ecma_prop_name_is_symbol (name_p));\n#endif /* ENABLED (JERRY_ES2015) */\n\n      uint8_t hash = (uint8_t) ecma_string_hash (name_p);\n      uint32_t bitmap_row = (uint32_t) (hash / bitmap_row_size);\n      uint32_t bitmap_column = (uint32_t) (hash % bitmap_row_size);\n\n      if ((own_names_hashes_bitmap[bitmap_row] & (1u << bitmap_column)) == 0)\n      {\n        own_names_hashes_bitmap[bitmap_row] |= (1u << bitmap_column);\n      }\n    }\n\n    jmem_cpointer_t prop_iter_cp = obj_p->u1.property_list_cp;\n\n    if (ecma_op_object_is_fast_array (obj_p) && prop_iter_cp != JMEM_CP_NULL)\n    {\n      ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;\n\n      uint32_t length = ext_obj_p->u.array.length;\n      array_index_named_properties_count = length - ecma_fast_array_get_hole_count (obj_p);\n\n      ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, prop_iter_cp);\n\n      for (uint32_t i = 0; i < length; i++)\n      {\n        if (ecma_is_value_array_hole (values_p[i]))\n        {\n          continue;\n        }\n\n        ecma_string_t *index_str_p = ecma_new_ecma_string_from_uint32 (i);\n\n        uint8_t hash = (uint8_t) ecma_string_hash (index_str_p);\n        uint32_t bitmap_row = (uint32_t) (hash / bitmap_row_size);\n        uint32_t bitmap_column = (uint32_t) (hash % bitmap_row_size);\n\n        bool is_add = true;\n\n        if ((own_names_hashes_bitmap[bitmap_row] & (1u << bitmap_column)) != 0)\n        {\n          buffer_p = prop_names_p->buffer_p;\n\n          for (uint32_t j = 0; j < prop_names_p->item_count; j++)\n          {\n            ecma_string_t *current_name_p = ecma_get_prop_name_from_value (buffer_p[j]);\n\n            if (ecma_compare_ecma_strings (index_str_p, current_name_p))\n            {\n              is_add = false;\n              break;\n            }\n          }\n        }\n\n        if (is_add)\n        {\n          own_names_hashes_bitmap[bitmap_row] |= (1u << bitmap_column);\n\n          ecma_collection_push_back (prop_names_p, ecma_make_string_value (index_str_p));\n        }\n      }\n    }\n    else\n    {\n#if ENABLED (JERRY_PROPRETY_HASHMAP)\n      if (prop_iter_cp != JMEM_CP_NULL)\n      {\n        ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);\n\n        if (prop_iter_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)\n        {\n          prop_iter_cp = prop_iter_p->next_property_cp;\n        }\n      }\n  #endif /* ENABLED (JERRY_PROPRETY_HASHMAP) */\n\n      while (prop_iter_cp != JMEM_CP_NULL)\n      {\n        ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);\n        JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (prop_iter_p));\n\n        for (int i = 0; i < ECMA_PROPERTY_PAIR_ITEM_COUNT; i++)\n        {\n          ecma_property_t *property_p = prop_iter_p->types + i;\n\n          if (ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDDATA\n              || ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDACCESSOR)\n          {\n            ecma_property_pair_t *prop_pair_p = (ecma_property_pair_t *) prop_iter_p;\n\n            if (ECMA_PROPERTY_GET_NAME_TYPE (*property_p) == ECMA_DIRECT_STRING_MAGIC\n                && prop_pair_p->names_cp[i] >= LIT_NON_INTERNAL_MAGIC_STRING__COUNT\n                && prop_pair_p->names_cp[i] < LIT_MAGIC_STRING__COUNT)\n            {\n              /* Internal properties are never enumerated. */\n              continue;\n            }\n\n            ecma_string_t *name_p = ecma_string_from_property_name (*property_p,\n                                                                    prop_pair_p->names_cp[i]);\n\n            if (!(is_enumerable_only && !ecma_is_property_enumerable (*property_p)))\n            {\n  #if ENABLED (JERRY_ES2015)\n              /* We skip the current property in the following cases:\n                 1. We don't want to list symbols (is_symbols and is_symbols_only are false)\n                    and the current property is a symbol.\n                 2. We only want to list symbols (is_symbols_only is true) and the current\n                    property is NOT a symbol. */\n              bool is_symbol = ecma_prop_name_is_symbol (name_p);\n              if ((!(is_symbols || is_symbols_only) && is_symbol) || (is_symbols_only && !is_symbol))\n              {\n                ecma_deref_ecma_string (name_p);\n                continue;\n              }\n  #endif /* ENABLED (JERRY_ES2015) */\n\n              uint8_t hash = (uint8_t) ecma_string_hash (name_p);\n              uint32_t bitmap_row = (uint32_t) (hash / bitmap_row_size);\n              uint32_t bitmap_column = (uint32_t) (hash % bitmap_row_size);\n\n              bool is_add = true;\n\n              if ((own_names_hashes_bitmap[bitmap_row] & (1u << bitmap_column)) != 0)\n              {\n                buffer_p = prop_names_p->buffer_p;\n\n                for (uint32_t j = 0; j < prop_names_p->item_count; j++)\n                {\n                  ecma_string_t *current_name_p = ecma_get_prop_name_from_value (buffer_p[j]);\n\n                  if (ecma_compare_ecma_strings (name_p, current_name_p))\n                  {\n                    is_add = false;\n                    break;\n                  }\n                }\n              }\n\n              if (is_add)\n              {\n                if (ecma_string_get_array_index (name_p) != ECMA_STRING_NOT_ARRAY_INDEX)\n                {\n                  /* The name is a valid array index. */\n                  array_index_named_properties_count++;\n                }\n                else if (!is_array_indices_only)\n                {\n  #if ENABLED (JERRY_ES2015)\n                  if (ecma_prop_name_is_symbol (name_p))\n                  {\n                    symbol_named_properties_count++;\n                  }\n                  else\n                  {\n  #endif /* ENABLED (JERRY_ES2015) */\n                    string_named_properties_count++;\n  #if ENABLED (JERRY_ES2015)\n                  }\n  #endif /* ENABLED (JERRY_ES2015) */\n                }\n                else\n                {\n                  ecma_deref_ecma_string (name_p);\n                  continue;\n                }\n\n                own_names_hashes_bitmap[bitmap_row] |= (1u << bitmap_column);\n\n                ecma_collection_push_back (prop_names_p, ecma_make_prop_name_value (name_p));\n              }\n              else\n              {\n                ecma_deref_ecma_string (name_p);\n              }\n            }\n            else\n            {\n              JERRY_ASSERT (is_enumerable_only && !ecma_is_property_enumerable (*property_p));\n\n              ecma_collection_push_back (skipped_non_enumerable_p, ecma_make_prop_name_value (name_p));\n            }\n          }\n        }\n\n        prop_iter_cp = prop_iter_p->next_property_cp;\n      }\n    }\n\n    ecma_length_t all_properties_count = array_index_named_properties_count + string_named_properties_count;\n\n#if ENABLED (JERRY_ES2015)\n    all_properties_count += symbol_named_properties_count;\n#endif /* ENABLED (JERRY_ES2015) */\n\n    /* Second pass: collecting property names into an array. */\n    JMEM_DEFINE_LOCAL_ARRAY (names_p, all_properties_count, ecma_string_t *);\n\n    ecma_string_t **string_names_p = names_p + array_index_named_properties_count;\n#if ENABLED (JERRY_ES2015)\n    ecma_string_t **symbol_names_p = string_names_p + string_named_properties_count;\n#endif /* ENABLED (JERRY_ES2015) */\n\n    uint32_t array_index_name_pos = 0;\n    uint32_t string_name_pos = string_named_properties_count;\n    uint32_t lazy_string_name_pos = 0;\n#if ENABLED (JERRY_ES2015)\n    uint32_t symbol_name_pos = symbol_named_properties_count;\n#endif /* ENABLED (JERRY_ES2015) */\n\n    buffer_p = prop_names_p->buffer_p;\n\n    for (uint32_t i = 0; i < prop_names_p->item_count; i++)\n    {\n      ecma_string_t *name_p = ecma_get_prop_name_from_value (buffer_p[i]);\n      ecma_ref_ecma_string (name_p);\n\n      uint32_t index = ecma_string_get_array_index (name_p);\n\n      if (index != ECMA_STRING_NOT_ARRAY_INDEX)\n      {\n        JERRY_ASSERT (array_index_name_pos < array_index_named_properties_count);\n\n        uint32_t insertion_pos = 0;\n        while (insertion_pos < array_index_name_pos\n               && index > ecma_string_get_array_index (names_p[insertion_pos]))\n        {\n          insertion_pos++;\n        }\n\n        if (insertion_pos == array_index_name_pos)\n        {\n          names_p[array_index_name_pos++] = name_p;\n        }\n        else\n        {\n          JERRY_ASSERT (insertion_pos < array_index_name_pos);\n          JERRY_ASSERT (index <= ecma_string_get_array_index (names_p[insertion_pos]));\n\n          uint32_t move_pos = array_index_name_pos++;\n\n          while (move_pos > insertion_pos)\n          {\n            names_p[move_pos] = names_p[move_pos - 1u];\n\n            move_pos--;\n          }\n\n          names_p[insertion_pos] = name_p;\n        }\n      }\n#if ENABLED (JERRY_ES2015)\n      else if (ecma_prop_name_is_symbol (name_p))\n      {\n        // Put in the symbols in reverse order.\n        JERRY_ASSERT (symbol_name_pos > 0);\n        JERRY_ASSERT (symbol_name_pos <= symbol_named_properties_count);\n\n        symbol_names_p[--symbol_name_pos] = name_p;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n      else\n      {\n        // Put in the strings in reverse order.\n        JERRY_ASSERT (string_name_pos > 0);\n        JERRY_ASSERT (string_name_pos <= string_named_properties_count);\n\n        if (i < lazy_prop_name_count)\n        {\n          string_names_p[lazy_string_name_pos++] = name_p;\n        }\n        else\n        {\n          string_names_p[--string_name_pos] = name_p;\n        }\n      }\n    }\n\n    JERRY_ASSERT (array_index_name_pos == array_index_named_properties_count);\n    JERRY_ASSERT (string_name_pos - lazy_string_name_pos == 0);\n#if ENABLED (JERRY_ES2015)\n    JERRY_ASSERT (symbol_name_pos == 0);\n#endif /* ENABLED (JERRY_ES2015) */\n\n    ecma_collection_free (prop_names_p);\n\n    /* Third pass:\n     *   embedding own property names of current object of prototype chain to aggregate property names collection */\n    for (uint32_t i = 0; i < all_properties_count; i++)\n    {\n      bool is_append = true;\n\n      ecma_string_t *name_p = names_p[i];\n\n      uint8_t hash = (uint8_t) ecma_string_hash (name_p);\n      uint32_t bitmap_row = (uint32_t) (hash / bitmap_row_size);\n      uint32_t bitmap_column = (uint32_t) (hash % bitmap_row_size);\n\n      if ((names_hashes_bitmap[bitmap_row] & (1u << bitmap_column)) == 0)\n      {\n        /* This hash has not been used before (for non-skipped). */\n        names_hashes_bitmap[bitmap_row] |= (1u << bitmap_column);\n      }\n      else\n      {\n        /* Name with same hash has already occured. */\n        buffer_p = ret_p->buffer_p;\n\n        for (uint32_t j = 0; j < ret_p->item_count; j++)\n        {\n          ecma_string_t *current_name_p = ecma_get_prop_name_from_value (buffer_p[j]);\n\n          if (ecma_compare_ecma_strings (name_p, current_name_p))\n          {\n            is_append = false;\n            break;\n          }\n        }\n      }\n\n      if (is_append)\n      {\n        buffer_p = skipped_non_enumerable_p->buffer_p;\n\n        for (uint32_t j = 0; j < skipped_non_enumerable_p->item_count; j++)\n        {\n          ecma_string_t *current_name_p = ecma_get_prop_name_from_value (buffer_p[j]);\n\n          if (ecma_compare_ecma_strings (name_p, current_name_p))\n          {\n            is_append = false;\n            break;\n          }\n        }\n      }\n\n      if (is_append)\n      {\n        JERRY_ASSERT ((names_hashes_bitmap[bitmap_row] & (1u << bitmap_column)) != 0);\n\n        ecma_collection_push_back (ret_p, ecma_make_prop_name_value (name_p));\n      }\n      else\n      {\n        ecma_deref_ecma_string (name_p);\n      }\n\n    }\n\n    JMEM_FINALIZE_LOCAL_ARRAY (names_p);\n\n    if (!is_with_prototype_chain || obj_p->u2.prototype_cp == JMEM_CP_NULL)\n    {\n      break;\n    }\n\n    obj_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, obj_p->u2.prototype_cp);\n  }\n\n  ecma_collection_free (skipped_non_enumerable_p);\n\n  return ret_p;\n}",
  "abstract_func": "ecma_collection_t *\necma_op_object_get_property_names (ecma_object_t *VAR_0, /* COMMENT_0 */\n                                   uint32_t VAR_1) /* COMMENT_1 */\n{\n  JERRY_ASSERT (VAR_0 != NULL\n                && !ecma_is_lexical_environment (VAR_0));\n\n#if ENABLED (VAR_2)\n  if (ECMA_OBJECT_IS_PROXY (VAR_0))\n  {\n    /* COMMENT_2 */\n    ecma_collection_t *VAR_3 = ecma_proxy_object_own_property_keys (VAR_0);\n    if (JERRY_UNLIKELY (VAR_3 == NULL))\n    {\n      return VAR_3;\n    }\n    ecma_collection_t *VAR_4 = ecma_new_collection ();\n\n    /* COMMENT_3 */\n    for (uint32_t VAR_5 = 0; VAR_5 < VAR_3->item_count; VAR_5++)\n    {\n      ecma_value_t VAR_6 = VAR_3->buffer_p[VAR_5];\n      ecma_string_t *VAR_7 = ecma_get_prop_name_from_value (VAR_6);\n      bool VAR_8 = ecma_prop_name_is_symbol (VAR_7);\n\n      if (VAR_8 && ((VAR_1 & (VAR_9 | VAR_10)) != 0))\n      {\n        ecma_collection_push_back (VAR_4, VAR_6);\n      }\n      else if (!VAR_8 && (VAR_1 & VAR_10) == 0)\n      {\n        ecma_collection_push_back (VAR_4, VAR_6);\n      }\n      else\n      {\n        ecma_free_value (VAR_6);\n      }\n    }\n\n    ecma_collection_destroy (VAR_3);\n    return VAR_4;\n  }\n#endif /* COMMENT_4 */\n\n  if (ecma_op_object_is_fast_array (VAR_0))\n  {\n    return ecma_fast_array_get_property_names (VAR_0, VAR_1);\n  }\n\n  ecma_collection_t *VAR_11 = ecma_new_collection ();\n  ecma_collection_t *VAR_12 = ecma_new_collection ();\n\n  const bool VAR_13 = (VAR_1 & VAR_14) != 0;\n  const bool VAR_15 = (VAR_1 & VAR_16) != 0;\n  const bool VAR_17 = (VAR_1 & VAR_18) != 0;\n#if ENABLED (VAR_19)\n  const bool VAR_20 = (VAR_1 & VAR_9) != 0;\n  const bool VAR_21 = (VAR_1 & VAR_10) != 0;\n#endif /* COMMENT_5 */\n\n  const size_t VAR_22 = sizeof (uint32_t) * VAR_23;\n  const size_t VAR_24 = VAR_25 / VAR_22;\n  JERRY_VLA (uint32_t, VAR_26, VAR_24);\n\n  memset (VAR_26, 0, VAR_24 * sizeof (VAR_26[0]));\n\n  while (true)\n  {\n    const ecma_object_type_t VAR_27 = ecma_get_object_type (VAR_0);\n    const bool VAR_28 = ecma_get_object_is_builtin (VAR_0);\n    ecma_length_t VAR_29 = 0;\n    ecma_length_t VAR_30 = 0;\n#if ENABLED (VAR_19)\n    ecma_length_t VAR_31 = 0;\n#endif /* COMMENT_5 */\n    ecma_collection_t *VAR_32 = ecma_new_collection ();\n\n#if ENABLED (VAR_19)\n    if (JERRY_LIKELY (!VAR_21))\n    {\n#endif/* COMMENT_6 */\n\n      if (obj_is_builtin)\n      {\n        if (VAR_27 == VAR_33 && ecma_builtin_function_is_routine (VAR_0))\n        {\n          ecma_builtin_routine_list_lazy_property_names (VAR_0,\n                                                          VAR_1,\n                                                          VAR_32,\n                                                          VAR_12);\n        }\n        else\n        {\n          ecma_builtin_list_lazy_property_names (VAR_0,\n                                                 VAR_1,\n                                                 VAR_32,\n                                                 VAR_12);\n        }\n      }\n      else\n      {\n        switch (VAR_27)\n        {\n          case VAR_34:\n          {\n  #if ENABLED (VAR_35)\n            if (ecma_object_is_typedarray (VAR_0))\n            {\n              ecma_op_typedarray_list_lazy_property_names (VAR_0, VAR_32);\n            }\n  #endif /* COMMENT_7 */\n            break;\n          }\n          case VAR_33:\n          {\n            if (!VAR_15)\n            {\n              ecma_op_function_list_lazy_property_names (VAR_0,\n                                                         VAR_1,\n                                                         VAR_32,\n                                                         VAR_12);\n            }\n            break;\n          }\n          case VAR_36:\n          {\n            if (!VAR_15)\n            {\n              ecma_op_external_function_list_lazy_property_names (VAR_0,\n                                                                  VAR_1,\n                                                                  VAR_32,\n                                                                  VAR_12);\n            }\n            break;\n          }\n          case VAR_37:\n          {\n            if (!VAR_15)\n            {\n              ecma_op_bound_function_list_lazy_property_names (VAR_0,\n                                                               VAR_1,\n                                                               VAR_32,\n                                                               VAR_12);\n            }\n            break;\n          }\n          case VAR_38:\n          {\n            ecma_extended_object_t *VAR_39 = (ecma_extended_object_t *) VAR_0;\n\n            if (VAR_39->u.class_prop.class_id == VAR_40)\n            {\n              ecma_op_string_list_lazy_property_names (VAR_0,\n                                                       VAR_1,\n                                                       VAR_32,\n                                                       VAR_12);\n            }\n\n            break;\n          }\n          case VAR_41:\n          {\n            ecma_op_array_list_lazy_property_names (VAR_0,\n                                                    VAR_1,\n                                                    VAR_32,\n                                                    VAR_12);\n            break;\n          }\n          default:\n          {\n            JERRY_ASSERT (VAR_27 == VAR_42);\n\n            break;\n          }\n        }\n      }\n#if ENABLED (VAR_19)\n    }\n#endif /* COMMENT_5 */\n\n    ecma_value_t *VAR_43 = VAR_32->buffer_p;\n    uint32_t VAR_44 = VAR_32->item_count;\n\n    const size_t VAR_45 = VAR_25 / VAR_22;\n    JERRY_VLA (uint32_t, VAR_46, VAR_45);\n    memset (VAR_46, 0, VAR_45 * sizeof (VAR_46[0]));\n\n    for (uint32_t VAR_5 = 0; VAR_5 < VAR_32->item_count; VAR_5++)\n    {\n      ecma_string_t *VAR_47 = ecma_get_string_from_value (VAR_43[VAR_5]);\n\n      if (ecma_string_get_array_index (VAR_47) != VAR_48)\n      {\n        VAR_30++;\n      }\n#if ENABLED (VAR_19)\n      else if (ecma_prop_name_is_symbol (name_p))\n      {\n        VAR_31++;\n      }\n#endif /* COMMENT_5 */\n      else\n      {\n        VAR_29++;\n      }\n\n#if ENABLED (VAR_19)\n      /* COMMENT_8 */\n      JERRY_ASSERT (!ecma_prop_name_is_symbol (name_p));\n#endif /* COMMENT_5 */\n\n      uint8_t VAR_49 = (uint8_t) ecma_string_hash (name_p);\n      uint32_t VAR_50 = (uint32_t) (VAR_49 / VAR_22);\n      uint32_t VAR_51 = (uint32_t) (VAR_49 % VAR_22);\n\n      if ((VAR_46[VAR_50] & (1u << VAR_51)) == 0)\n      {\n        VAR_46[VAR_50] |= (1u << VAR_51);\n      }\n    }\n\n    jmem_cpointer_t VAR_52 = VAR_0->u1.property_list_cp;\n\n    if (ecma_op_object_is_fast_array (VAR_0) && VAR_52 != VAR_53)\n    {\n      ecma_extended_object_t *VAR_54 = (ecma_extended_object_t *) VAR_0;\n\n      uint32_t VAR_55 = VAR_54->u.array.length;\n      VAR_30 = VAR_55 - ecma_fast_array_get_hole_count (VAR_0);\n\n      ecma_value_t *VAR_56 = ECMA_GET_NON_NULL_POINTER (ecma_value_t, VAR_52);\n\n      for (uint32_t VAR_5 = 0; VAR_5 < VAR_55; VAR_5++)\n      {\n        if (ecma_is_value_array_hole (VAR_56[VAR_5]))\n        {\n          continue;\n        }\n\n        ecma_string_t *VAR_57 = ecma_new_ecma_string_from_uint32 (VAR_5);\n\n        uint8_t VAR_49 = (uint8_t) ecma_string_hash (VAR_57);\n        uint32_t VAR_50 = (uint32_t) (VAR_49 / VAR_22);\n        uint32_t VAR_51 = (uint32_t) (VAR_49 % VAR_22);\n\n        bool VAR_58 = true;\n\n        if ((VAR_46[VAR_50] & (1u << VAR_51)) != 0)\n        {\n          VAR_43 = VAR_32->buffer_p;\n\n          for (uint32_t VAR_59 = 0; VAR_59 < VAR_32->item_count; VAR_59++)\n          {\n            ecma_string_t *VAR_60 = ecma_get_prop_name_from_value (VAR_43[VAR_59]);\n\n            if (ecma_compare_ecma_strings (VAR_57, VAR_60))\n            {\n              VAR_58 = false;\n              break;\n            }\n          }\n        }\n\n        if (VAR_58)\n        {\n          VAR_46[VAR_50] |= (1u << VAR_51);\n\n          ecma_collection_push_back (VAR_32, ecma_make_string_value (VAR_57));\n        }\n      }\n    }\n    else\n    {\n#if ENABLED (VAR_61)\n      if (VAR_52 != VAR_53)\n      {\n        ecma_property_header_t *VAR_62 = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, VAR_52);\n\n        if (VAR_62->types[0] == VAR_63)\n        {\n          VAR_52 = VAR_62->next_property_cp;\n        }\n      }\n  #endif /* COMMENT_9 */\n\n      while (VAR_52 != VAR_53)\n      {\n        ecma_property_header_t *VAR_62 = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, VAR_52);\n        JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (VAR_62));\n\n        for (int VAR_5 = 0; VAR_5 < VAR_64; VAR_5++)\n        {\n          ecma_property_t *VAR_65 = VAR_62->types + VAR_5;\n\n          if (ECMA_PROPERTY_GET_TYPE (*VAR_65) == VAR_66\n              || ECMA_PROPERTY_GET_TYPE (*VAR_65) == VAR_67)\n          {\n            ecma_property_pair_t *VAR_68 = (ecma_property_pair_t *) VAR_62;\n\n            if (ECMA_PROPERTY_GET_NAME_TYPE (*VAR_65) == VAR_69\n                && VAR_68->names_cp[VAR_5] >= VAR_70\n                && VAR_68->names_cp[VAR_5] < VAR_71)\n            {\n              /* COMMENT_10 */\n              continue;\n            }\n\n            ecma_string_t *name_p = ecma_string_from_property_name (*VAR_65,\n                                                                    VAR_68->names_cp[VAR_5]);\n\n            if (!(VAR_13 && !ecma_is_property_enumerable (*VAR_65)))\n            {\n  #if ENABLED (VAR_19)\n              /* COMMENT_11 */\n                                                                                            \n                                                         \n                                                                                          \n                                                \n              bool VAR_72 = ecma_prop_name_is_symbol (name_p);\n              if ((!(VAR_20 || VAR_21) && VAR_72) || (VAR_21 && !VAR_72))\n              {\n                ecma_deref_ecma_string (name_p);\n                continue;\n              }\n  #endif /* COMMENT_5 */\n\n              uint8_t VAR_49 = (uint8_t) ecma_string_hash (name_p);\n              uint32_t VAR_50 = (uint32_t) (VAR_49 / VAR_22);\n              uint32_t VAR_51 = (uint32_t) (VAR_49 % VAR_22);\n\n              bool VAR_58 = true;\n\n              if ((VAR_46[VAR_50] & (1u << VAR_51)) != 0)\n              {\n                VAR_43 = VAR_32->buffer_p;\n\n                for (uint32_t VAR_59 = 0; VAR_59 < VAR_32->item_count; VAR_59++)\n                {\n                  ecma_string_t *VAR_60 = ecma_get_prop_name_from_value (VAR_43[VAR_59]);\n\n                  if (ecma_compare_ecma_strings (name_p, VAR_60))\n                  {\n                    VAR_58 = false;\n                    break;\n                  }\n                }\n              }\n\n              if (VAR_58)\n              {\n                if (ecma_string_get_array_index (name_p) != VAR_48)\n                {\n                  /* COMMENT_16 */\n                  VAR_30++;\n                }\n                else if (!VAR_15)\n                {\n  #if ENABLED (VAR_19)\n                  if (ecma_prop_name_is_symbol (name_p))\n                  {\n                    VAR_31++;\n                  }\n                  else\n                  {\n  #endif/* COMMENT_6 */\n                    string_named_properties_count++;\n  #if ENABLED (VAR_19)\n                  }\n  #endif /* COMMENT_5 */\n                }\n                else\n                {\n                  ecma_deref_ecma_string (name_p);\n                  continue;\n                }\n\n                VAR_46[VAR_50] |= (1u << VAR_51);\n\n                ecma_collection_push_back (VAR_32, ecma_make_prop_name_value (name_p));\n              }\n              else\n              {\n                ecma_deref_ecma_string (name_p);\n              }\n            }\n            else\n            {\n              JERRY_ASSERT (VAR_13 && !ecma_is_property_enumerable (*VAR_65));\n\n              ecma_collection_push_back (VAR_12, ecma_make_prop_name_value (name_p));\n            }\n          }\n        }\n\n        VAR_52 = VAR_62->next_property_cp;\n      }\n    }\n\n    ecma_length_t VAR_73 = VAR_30 + VAR_29;\n\n#if ENABLED (VAR_19)\n    VAR_73 += VAR_31;\n#endif /* COMMENT_5 */\n\n    /* COMMENT_17 */\n    JMEM_DEFINE_LOCAL_ARRAY (VAR_74, VAR_73, ecma_string_t *);\n\n    ecma_string_t **VAR_75 = VAR_74 + VAR_30;\n#if ENABLED (VAR_19)\n    ecma_string_t **VAR_76 = VAR_75 + VAR_29;\n#endif /* COMMENT_5 */\n\n    uint32_t VAR_77 = 0;\n    uint32_t VAR_78 = VAR_29;\n    uint32_t VAR_79 = 0;\n#if ENABLED (VAR_19)\n    uint32_t VAR_80 = VAR_31;\n#endif /* COMMENT_5 */\n\n    VAR_43 = VAR_32->buffer_p;\n\n    for (uint32_t VAR_5 = 0; VAR_5 < VAR_32->item_count; VAR_5++)\n    {\n      ecma_string_t *name_p = ecma_get_prop_name_from_value (VAR_43[VAR_5]);\n      ecma_ref_ecma_string (name_p);\n\n      uint32_t VAR_81 = ecma_string_get_array_index (name_p);\n\n      if (VAR_81 != VAR_48)\n      {\n        JERRY_ASSERT (VAR_77 < VAR_30);\n\n        uint32_t VAR_82 = 0;\n        while (VAR_82 < VAR_77\n               && VAR_81 > ecma_string_get_array_index (VAR_74[VAR_82]))\n        {\n          VAR_82++;\n        }\n\n        if (VAR_82 == VAR_77)\n        {\n          VAR_74[VAR_77++] = name_p;\n        }\n        else\n        {\n          JERRY_ASSERT (VAR_82 < VAR_77);\n          JERRY_ASSERT (VAR_81 <= ecma_string_get_array_index (VAR_74[VAR_82]));\n\n          uint32_t VAR_83 = VAR_77++;\n\n          while (VAR_83 > VAR_82)\n          {\n            VAR_74[VAR_83] = VAR_74[VAR_83 - 1u];\n\n            VAR_83--;\n          }\n\n          VAR_74[VAR_82] = name_p;\n        }\n      }\n#if ENABLED (VAR_19)\n      else if (ecma_prop_name_is_symbol (name_p))\n      {\n        /* COMMENT_18 */\n        JERRY_ASSERT (VAR_80 > 0);\n        JERRY_ASSERT (VAR_80 <= VAR_31);\n\n        VAR_76[--VAR_80] = name_p;\n      }\n#endif /* COMMENT_5 */\n      else\n      {\n        /* COMMENT_19 */\n        JERRY_ASSERT (VAR_78 > 0);\n        JERRY_ASSERT (VAR_78 <= VAR_29);\n\n        if (VAR_5 < VAR_44)\n        {\n          VAR_75[VAR_79++] = name_p;\n        }\n        else\n        {\n          VAR_75[--VAR_78] = name_p;\n        }\n      }\n    }\n\n    JERRY_ASSERT (VAR_77 == VAR_30);\n    JERRY_ASSERT (VAR_78 - VAR_79 == 0);\n#if ENABLED (VAR_19)\n    JERRY_ASSERT (VAR_80 == 0);\n#endif /* COMMENT_5 */\n\n    ecma_collection_free (VAR_32);\n\n    /* COMMENT_20 */\n                                                                                                                    \n    for (uint32_t VAR_5 = 0; VAR_5 < VAR_73; VAR_5++)\n    {\n      bool VAR_84 = true;\n\n      ecma_string_t *name_p = VAR_74[VAR_5];\n\n      uint8_t VAR_49 = (uint8_t) ecma_string_hash (name_p);\n      uint32_t VAR_50 = (uint32_t) (VAR_49 / VAR_22);\n      uint32_t VAR_51 = (uint32_t) (VAR_49 % VAR_22);\n\n      if ((VAR_26[VAR_50] & (1u << VAR_51)) == 0)\n      {\n        /* COMMENT_22 */\n        VAR_26[VAR_50] |= (1u << VAR_51);\n      }\n      else\n      {\n        /* COMMENT_23 */\n        VAR_43 = VAR_11->buffer_p;\n\n        for (uint32_t VAR_59 = 0; VAR_59 < VAR_11->item_count; VAR_59++)\n        {\n          ecma_string_t *VAR_60 = ecma_get_prop_name_from_value (VAR_43[VAR_59]);\n\n          if (ecma_compare_ecma_strings (name_p, VAR_60))\n          {\n            VAR_84 = false;\n            break;\n          }\n        }\n      }\n\n      if (VAR_84)\n      {\n        VAR_43 = VAR_12->buffer_p;\n\n        for (uint32_t VAR_59 = 0; VAR_59 < VAR_12->item_count; VAR_59++)\n        {\n          ecma_string_t *VAR_60 = ecma_get_prop_name_from_value (VAR_43[VAR_59]);\n\n          if (ecma_compare_ecma_strings (name_p, VAR_60))\n          {\n            VAR_84 = false;\n            break;\n          }\n        }\n      }\n\n      if (VAR_84)\n      {\n        JERRY_ASSERT ((VAR_26[VAR_50] & (1u << VAR_51)) != 0);\n\n        ecma_collection_push_back (VAR_11, ecma_make_prop_name_value (name_p));\n      }\n      else\n      {\n        ecma_deref_ecma_string (name_p);\n      }\n\n    }\n\n    JMEM_FINALIZE_LOCAL_ARRAY (VAR_74);\n\n    if (!VAR_17 || VAR_0->u2.prototype_cp == VAR_53)\n    {\n      break;\n    }\n\n    VAR_0 = ECMA_GET_NON_NULL_POINTER (ecma_object_t, VAR_0->u2.prototype_cp);\n  }\n\n  ecma_collection_free (VAR_12);\n\n  return VAR_11;\n}",
  "func_graph_path": "jerryscript-project/jerryscript/2ac4c4a4c52f81a5c9a3eb33215f325b778f8b94/ecma-objects.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -8,7 +8,37 @@\n #if ENABLED (JERRY_ES2015_BUILTIN_PROXY)\n   if (ECMA_OBJECT_IS_PROXY (obj_p))\n   {\n-    return ecma_proxy_object_own_property_keys (obj_p);\n+    /* Integrated a part of ECMA 262 v6 7.3.21 EnumerableOwnNames operation. */\n+    ecma_collection_t *proxy_keys = ecma_proxy_object_own_property_keys (obj_p);\n+    if (JERRY_UNLIKELY (proxy_keys == NULL))\n+    {\n+      return proxy_keys;\n+    }\n+    ecma_collection_t *return_keys = ecma_new_collection ();\n+\n+    /* Move valid elements to the output collection */\n+    for (uint32_t i = 0; i < proxy_keys->item_count; i++)\n+    {\n+      ecma_value_t entry = proxy_keys->buffer_p[i];\n+      ecma_string_t *prop_name_p = ecma_get_prop_name_from_value (entry);\n+      bool prop_is_symbol = ecma_prop_name_is_symbol (prop_name_p);\n+\n+      if (prop_is_symbol && ((opts & (ECMA_LIST_SYMBOLS | ECMA_LIST_SYMBOLS_ONLY)) != 0))\n+      {\n+        ecma_collection_push_back (return_keys, entry);\n+      }\n+      else if (!prop_is_symbol && (opts & ECMA_LIST_SYMBOLS_ONLY) == 0)\n+      {\n+        ecma_collection_push_back (return_keys, entry);\n+      }\n+      else\n+      {\n+        ecma_free_value (entry);\n+      }\n+    }\n+\n+    ecma_collection_destroy (proxy_keys);\n+    return return_keys;\n   }\n #endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */\n ",
  "diff_line_info": {
    "deleted_lines": [
      "    return ecma_proxy_object_own_property_keys (obj_p);"
    ],
    "added_lines": [
      "    /* Integrated a part of ECMA 262 v6 7.3.21 EnumerableOwnNames operation. */",
      "    ecma_collection_t *proxy_keys = ecma_proxy_object_own_property_keys (obj_p);",
      "    if (JERRY_UNLIKELY (proxy_keys == NULL))",
      "    {",
      "      return proxy_keys;",
      "    }",
      "    ecma_collection_t *return_keys = ecma_new_collection ();",
      "",
      "    /* Move valid elements to the output collection */",
      "    for (uint32_t i = 0; i < proxy_keys->item_count; i++)",
      "    {",
      "      ecma_value_t entry = proxy_keys->buffer_p[i];",
      "      ecma_string_t *prop_name_p = ecma_get_prop_name_from_value (entry);",
      "      bool prop_is_symbol = ecma_prop_name_is_symbol (prop_name_p);",
      "",
      "      if (prop_is_symbol && ((opts & (ECMA_LIST_SYMBOLS | ECMA_LIST_SYMBOLS_ONLY)) != 0))",
      "      {",
      "        ecma_collection_push_back (return_keys, entry);",
      "      }",
      "      else if (!prop_is_symbol && (opts & ECMA_LIST_SYMBOLS_ONLY) == 0)",
      "      {",
      "        ecma_collection_push_back (return_keys, entry);",
      "      }",
      "      else",
      "      {",
      "        ecma_free_value (entry);",
      "      }",
      "    }",
      "",
      "    ecma_collection_destroy (proxy_keys);",
      "    return return_keys;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/jerryscript-project/jerryscript/pull/3797",
  "description": {
    "pr_info": {
      "title": "Improve property key query for Proxy objects",
      "number": 3797
    },
    "comment": [
      "Property key query for Proxy objects always returned all keys\r\neven if no symbols were requested symbols were present in the\r\nresulting array.\r\n\r\nFixes: #3787 "
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.95\n\n**Step-by-Step Explanation:**\n\n1. **Input Analysis:** The commit message describes a fix where Proxy objects returned all property keys, including symbols when they shouldn't have. The code diff modifies how property keys are collected and includes logic to exclude certain symbols based on options.\n\n2. **Consistency Check:** The commit message accurately reflects the code changes, which adjust the logic for returning property keys.\n\n3. **Purpose Evaluation:** The change fixes a bug in the core functionality, specifically how Proxy objects handle property keys, improving correctness without any security context.\n\n4. **Security Vulnerability Assessment:** There's no mention of security terms or known vulnerabilities, and the code changes don't address any security risks.\n\n5. **Non-Security Classification:** The fix addresses a bug in core functionality, fitting under Defect Remediation & Feature Upgrades.\n\n6. **Confidence Scoring:** High confidence due to the clear, consistent fix without security implications."
}