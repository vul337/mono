{
  "cve_id": "CVE-2022-28070",
  "cwe_ids": [
    "CWE-476"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "radareorg/radare2",
  "commit_msg": "Fix oobread crash in the analysis loop with corrupted ELFs (tests_64928) ##crash\n\nReported by giantbranch of NSFOCUS TIANJI Lab",
  "commit_hash": "4aff1bb00224de4f5bc118f987dfd5d2fe3450d0",
  "git_url": "https://github.com/radareorg/radare2/commit/4aff1bb00224de4f5bc118f987dfd5d2fe3450d0",
  "file_path": "libr/core/canal.c",
  "func_name": "__core_anal_fcn",
  "func_before": "static bool __core_anal_fcn(RCore *core, ut64 at, ut64 from, int reftype, int depth) {\n\tif (depth < 0) {\n//\t\tprintf (\"Too deep for 0x%08\"PFMT64x\"\\n\", at);\n//\t\tr_sys_backtrace ();\n\t\treturn false;\n\t}\n\tint has_next = r_config_get_i (core->config, \"anal.hasnext\");\n\tRAnalHint *hint = NULL;\n\tint i, nexti = 0;\n\tut64 *next = NULL;\n\tint fcnlen;\n\tRAnalFunction *fcn = r_anal_function_new (core->anal);\n\tr_warn_if_fail (fcn);\n\tconst char *fcnpfx = r_config_get (core->config, \"anal.fcnprefix\");\n\tif (!fcnpfx) {\n\t\tfcnpfx = \"fcn\";\n\t}\n\tconst char *cc = r_anal_cc_default (core->anal);\n\tif (!cc) {\n\t\tif (r_anal_cc_once (core->anal)) {\n\t\t\teprintf (\"Warning: set your favourite calling convention in `e anal.cc=?`\\n\");\n\t\t}\n\t\tcc = \"reg\";\n\t}\n\tfcn->cc = r_str_constpool_get (&core->anal->constpool, cc);\n\tr_warn_if_fail (fcn->cc);\n\thint = r_anal_hint_get (core->anal, at);\n\tif (hint && hint->bits == 16) {\n\t\t// expand 16bit for function\n\t\tfcn->bits = 16;\n\t} else {\n\t\tfcn->bits = core->anal->bits;\n\t}\n\tfcn->addr = at;\n\tfcn->name = get_function_name (core, at);\n\n\tif (!fcn->name) {\n\t\tfcn->name = r_str_newf (\"%s.%08\"PFMT64x, fcnpfx, at);\n\t}\n\tr_anal_fcn_invalidate_read_ahead_cache ();\n\tdo {\n\t\tRFlagItem *f;\n\t\tut64 delta = r_anal_function_linear_size (fcn);\n\t\tif (!r_io_is_valid_offset (core->io, at + delta, !core->anal->opt.noncode)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (r_cons_is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\tfcnlen = r_anal_function(core->anal, fcn, at + delta, core->anal->opt.bb_max_size, reftype);\n\t\tif (core->anal->opt.searchstringrefs) {\n\t\t\tr_anal_set_stringrefs (core, fcn);\n\t\t}\n\t\tif (fcnlen == 0) {\n\t\t\tif (core->anal->verbose) {\n\t\t\t\teprintf (\"Analyzed function size is 0 at 0x%08\"PFMT64x\"\\n\", at + delta);\n\t\t\t}\n\t\t\tgoto error;\n\t\t}\n\t\tif (fcnlen < 0) {\n\t\t\tswitch (fcnlen) {\n\t\t\tcase R_ANAL_RET_ERROR:\n\t\t\tcase R_ANAL_RET_NEW:\n\t\t\tcase R_ANAL_RET_DUP:\n\t\t\tcase R_ANAL_RET_END:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\teprintf (\"Oops. Negative fcnsize at 0x%08\"PFMT64x\" (%d)\\n\", at, fcnlen);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tf = r_core_flag_get_by_spaces (core->flags, fcn->addr);\n\t\tset_fcn_name_from_flag (fcn, f, fcnpfx);\n\n\t\tif (fcnlen == R_ANAL_RET_ERROR ||\n\t\t\t(fcnlen == R_ANAL_RET_END && !r_anal_function_realsize (fcn))) { /* Error analyzing function */\n\t\t\tif (core->anal->opt.followbrokenfcnsrefs) {\n\t\t\t\tr_anal_analyze_fcn_refs (core, fcn, depth);\n\t\t\t}\n\t\t\tgoto error;\n\t\t} else if (fcnlen == R_ANAL_RET_END) { /* Function analysis complete */\n\t\t\tf = r_core_flag_get_by_spaces (core->flags, fcn->addr);\n\t\t\tif (f && f->name && strncmp (f->name, \"sect\", 4)) { /* Check if it's already flagged */\n\t\t\t\tchar *new_name = strdup (f->name);\n\t\t\t\tif (is_entry_flag (f)) {\n\t\t\t\t\tRListIter *iter;\n\t\t\t\t\tRBinSymbol *sym;\n\t\t\t\t\tconst RList *syms = r_bin_get_symbols (core->bin);\n\t\t\t\t\tut64 baddr = r_config_get_i (core->config, \"bin.baddr\");\n\t\t\t\t\tr_list_foreach (syms, iter, sym) {\n\t\t\t\t\t\tif ((sym->paddr + baddr) == fcn->addr && !strcmp (sym->type, R_BIN_TYPE_FUNC_STR)) {\n\t\t\t\t\t\t\tfree (new_name);\n\t\t\t\t\t\t\tnew_name = r_str_newf (\"sym.%s\", sym->name);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree (fcn->name);\n\t\t\t\tfcn->name = new_name;\n\t\t\t} else {\n\t\t\t\tR_FREE (fcn->name);\n\t\t\t\tconst char *fcnpfx = r_anal_fcntype_tostring (fcn->type);\n\t\t\t\tif (!fcnpfx || !*fcnpfx || !strcmp (fcnpfx, \"fcn\")) {\n\t\t\t\t\tfcnpfx = r_config_get (core->config, \"anal.fcnprefix\");\n\t\t\t\t}\n\t\t\t\tfcn->name = r_str_newf (\"%s.%08\"PFMT64x, fcnpfx, fcn->addr);\n\t\t\t\tautoname_imp_trampoline (core, fcn);\n\t\t\t\t/* Add flag */\n\t\t\t\tr_flag_space_push (core->flags, R_FLAGS_FS_FUNCTIONS);\n\t\t\t\tr_flag_set (core->flags, fcn->name, fcn->addr, r_anal_function_linear_size (fcn));\n\t\t\t\tr_flag_space_pop (core->flags);\n\t\t\t}\n\n\t\t\t/* New function: Add initial xref */\n\t\t\tif (from != UT64_MAX) {\n\t\t\t\tr_anal_xrefs_set (core->anal, from, fcn->addr, reftype);\n\t\t\t}\n\t\t\t// XXX: this is wrong. See CID 1134565\n\t\t\tr_anal_add_function (core->anal, fcn);\n\t\t\tif (has_next) {\n\t\t\t\tut64 addr = r_anal_function_max_addr (fcn);\n\t\t\t\tRIOMap *map = r_io_map_get_at (core->io, addr);\n\t\t\t\t// only get next if found on an executable section\n\t\t\t\tif (!map || (map && map->perm & R_PERM_X)) {\n\t\t\t\t\tfor (i = 0; i < nexti; i++) {\n\t\t\t\t\t\tif (next[i] == addr) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (i == nexti) {\n\t\t\t\t\t\tut64 at = r_anal_function_max_addr (fcn);\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tut64 size;\n\t\t\t\t\t\t\tRAnalMetaItem *mi = r_meta_get_at (core->anal, at, R_META_TYPE_ANY, &size);\n\t\t\t\t\t\t\tif (!mi) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tat += size;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// TODO: ensure next address is function after padding (nop or trap or wat)\n\t\t\t\t\t\t// XXX noisy for test cases because we want to clear the stderr\n\t\t\t\t\t\tr_cons_clear_line (1);\n\t\t\t\t\t\tloganal (fcn->addr, at, 10000 - depth);\n\t\t\t\t\t\tnext = next_append (next, &nexti, at);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!r_anal_analyze_fcn_refs (core, fcn, depth)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t} while (fcnlen != R_ANAL_RET_END);\n\tr_list_free (core->anal->leaddrs);\n\tcore->anal->leaddrs = NULL;\n\tif (has_next) {\n\t\tfor (i = 0; i < nexti; i++) {\n\t\t\tif (!next[i] || r_anal_get_fcn_in (core->anal, next[i], 0)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tr_core_anal_fcn (core, next[i], from, 0, depth - 1);\n\t\t}\n\t\tfree (next);\n\t}\n\tif (core->anal->cur && core->anal->cur->arch && !strcmp (core->anal->cur->arch, \"x86\")) {\n\t\tr_anal_function_check_bp_use (fcn);\n\t\tif (fcn && !fcn->bp_frame) {\n\t\t\tr_anal_function_delete_vars_by_kind (fcn, R_ANAL_VAR_KIND_BPV);\n\t\t}\n\t}\n\tr_anal_hint_free (hint);\n\treturn true;\n\nerror:\n\tr_list_free (core->anal->leaddrs);\n\tcore->anal->leaddrs = NULL;\n\t// ugly hack to free fcn\n\tif (fcn) {\n\t\tif (!r_anal_function_realsize (fcn) || fcn->addr == UT64_MAX) {\n\t\t\tr_anal_function_free (fcn);\n\t\t\tfcn = NULL;\n\t\t} else {\n\t\t\t// TODO: mark this function as not properly analyzed\n\t\t\tif (!fcn->name) {\n\t\t\t\t// XXX dupped code.\n\t\t\t\tfcn->name = r_str_newf (\n\t\t\t\t\t\"%s.%08\" PFMT64x,\n\t\t\t\t\tr_anal_fcntype_tostring (fcn->type),\n\t\t\t\t\tat);\n\t\t\t\t/* Add flag */\n\t\t\t\tr_flag_space_push (core->flags, R_FLAGS_FS_FUNCTIONS);\n\t\t\t\tr_flag_set (core->flags, fcn->name, at, r_anal_function_linear_size (fcn));\n\t\t\t\tr_flag_space_pop (core->flags);\n\t\t\t}\n\t\t\tr_anal_add_function (core->anal, fcn);\n\t\t}\n\t\tif (fcn && has_next) {\n\t\t\tut64 newaddr = r_anal_function_max_addr (fcn);\n\t\t\tRIOMap *map = r_io_map_get_at (core->io, newaddr);\n\t\t\tif (!map || (map && (map->perm & R_PERM_X))) {\n\t\t\t\tnext = next_append (next, &nexti, newaddr);\n\t\t\t\tfor (i = 0; i < nexti; i++) {\n\t\t\t\t\tif (!next[i]) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tr_core_anal_fcn (core, next[i], next[i], 0, depth - 1);\n\t\t\t\t}\n\t\t\t\tfree (next);\n\t\t\t}\n\t\t}\n\t}\n\tif (fcn && core->anal->cur && core->anal->cur->arch && !strcmp (core->anal->cur->arch, \"x86\")) {\n\t\tr_anal_function_check_bp_use (fcn);\n\t\tif (!fcn->bp_frame) {\n\t\t\tr_anal_function_delete_vars_by_kind (fcn, R_ANAL_VAR_KIND_BPV);\n\t\t}\n\t}\n\tr_anal_hint_free (hint);\n\treturn false;\n}",
  "abstract_func_before": "static bool __core_anal_fcn(RCore *VAR_0, ut64 VAR_1, ut64 VAR_2, int VAR_3, int VAR_4) {\n\tif (VAR_4 < 0) {\n/* COMMENT_0 */\n/* COMMENT_1 */\n\t\treturn false;\n\t}\n\tint VAR_5 = r_config_get_i (VAR_0->config, \"anal.hasnext\");\n\tRAnalHint *VAR_6 = NULL;\n\tint VAR_7, VAR_8 = 0;\n\tut64 *VAR_9 = NULL;\n\tint VAR_10;\n\tRAnalFunction *VAR_11 = r_anal_function_new (VAR_0->anal);\n\tr_warn_if_fail (VAR_11);\n\tconst char *VAR_12 = r_config_get (VAR_0->config, \"anal.fcnprefix\");\n\tif (!VAR_12) {\n\t\tVAR_12 = \"fcn\";\n\t}\n\tconst char *VAR_13 = r_anal_cc_default (VAR_0->anal);\n\tif (!VAR_13) {\n\t\tif (r_anal_cc_once (VAR_0->anal)) {\n\t\t\teprintf (\"Warning: set your favourite calling convention in `e anal.cc=?`\\n\");\n\t\t}\n\t\tVAR_13 = \"reg\";\n\t}\n\tVAR_11->cc = r_str_constpool_get (&VAR_0->anal->constpool, VAR_13);\n\tr_warn_if_fail (VAR_11->cc);\n\tVAR_6 = r_anal_hint_get (VAR_0->anal, VAR_1);\n\tif (VAR_6 && VAR_6->bits == 16) {\n\t\t/* COMMENT_2 */\n\t\tVAR_11->bits = 16;\n\t} else {\n\t\tVAR_11->bits = VAR_0->anal->bits;\n\t}\n\tVAR_11->addr = VAR_1;\n\tVAR_11->name = get_function_name (VAR_0, VAR_1);\n\n\tif (!VAR_11->name) {\n\t\tVAR_11->name = r_str_newf (\"%s.%08\"VAR_14, VAR_12, VAR_1);\n\t}\n\tr_anal_fcn_invalidate_read_ahead_cache ();\n\tdo {\n\t\tRFlagItem *VAR_15;\n\t\tut64 VAR_16 = r_anal_function_linear_size (VAR_11);\n\t\tif (!r_io_is_valid_offset (VAR_0->io, VAR_1 + VAR_16, !VAR_0->anal->opt.noncode)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (r_cons_is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\tVAR_10 = r_anal_function(VAR_0->anal, VAR_11, VAR_1 + VAR_16, VAR_0->anal->opt.bb_max_size, VAR_3);\n\t\tif (VAR_0->anal->opt.searchstringrefs) {\n\t\t\tr_anal_set_stringrefs (VAR_0, VAR_11);\n\t\t}\n\t\tif (VAR_10 == 0) {\n\t\t\tif (VAR_0->anal->verbose) {\n\t\t\t\teprintf (\"Analyzed function size is 0 at 0x%08\"VAR_14\"\\n\", VAR_1 + VAR_16);\n\t\t\t}\n\t\t\tgoto error;\n\t\t}\n\t\tif (VAR_10 < 0) {\n\t\t\tswitch (VAR_10) {\n\t\t\tcase VAR_17:\n\t\t\tcase VAR_18:\n\t\t\tcase VAR_19:\n\t\t\tcase VAR_20:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\teprintf (\"Oops. Negative fcnsize at 0x%08\"VAR_14\" (%d)\\n\", VAR_1, VAR_10);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tVAR_15 = r_core_flag_get_by_spaces (VAR_0->flags, VAR_11->addr);\n\t\tset_fcn_name_from_flag (VAR_11, VAR_15, VAR_12);\n\n\t\tif (VAR_10 == VAR_17 ||\n\t\t\t(VAR_10 == VAR_20 && !r_anal_function_realsize (VAR_11))) { /* COMMENT_3 */\n\t\t\tif (VAR_0->anal->opt.followbrokenfcnsrefs) {\n\t\t\t\tr_anal_analyze_fcn_refs (VAR_0, VAR_11, VAR_4);\n\t\t\t}\n\t\t\tgoto error;\n\t\t} else if (VAR_10 == VAR_20) { /* COMMENT_4 */\n\t\t\tVAR_15 = r_core_flag_get_by_spaces (VAR_0->flags, VAR_11->addr);\n\t\t\tif (VAR_15 && VAR_15->name && strncmp (VAR_15->name, \"sect\", 4)) { /* COMMENT_5 */\n\t\t\t\tchar *VAR_21 = strdup (VAR_15->name);\n\t\t\t\tif (is_entry_flag (VAR_15)) {\n\t\t\t\t\tRListIter *VAR_22;\n\t\t\t\t\tRBinSymbol *VAR_23;\n\t\t\t\t\tconst RList *VAR_24 = r_bin_get_symbols (VAR_0->bin);\n\t\t\t\t\tut64 VAR_25 = r_config_get_i (VAR_0->config, \"bin.baddr\");\n\t\t\t\t\tr_list_foreach (VAR_24, VAR_22, VAR_23) {\n\t\t\t\t\t\tif ((VAR_23->paddr + VAR_25) == VAR_11->addr && !strcmp (VAR_23->type, VAR_26)) {\n\t\t\t\t\t\t\tfree (VAR_21);\n\t\t\t\t\t\t\tVAR_21 = r_str_newf (\"sym.%s\", VAR_23->name);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree (VAR_11->name);\n\t\t\t\tVAR_11->name = VAR_21;\n\t\t\t} else {\n\t\t\t\tR_FREE (VAR_11->name);\n\t\t\t\tconst char *VAR_12 = r_anal_fcntype_tostring (VAR_11->type);\n\t\t\t\tif (!VAR_12 || !*VAR_12 || !strcmp (VAR_12, \"fcn\")) {\n\t\t\t\t\tVAR_12 = r_config_get (VAR_0->config, \"anal.fcnprefix\");\n\t\t\t\t}\n\t\t\t\tVAR_11->name = r_str_newf (\"%s.%08\"VAR_14, VAR_12, VAR_11->addr);\n\t\t\t\tautoname_imp_trampoline (VAR_0, VAR_11);\n\t\t\t\t/* COMMENT_6 */\n\t\t\t\tr_flag_space_push (VAR_0->flags, VAR_27);\n\t\t\t\tr_flag_set (VAR_0->flags, VAR_11->name, VAR_11->addr, r_anal_function_linear_size (VAR_11));\n\t\t\t\tr_flag_space_pop (VAR_0->flags);\n\t\t\t}\n\n\t\t\t/* COMMENT_7 */\n\t\t\tif (VAR_2 != VAR_28) {\n\t\t\t\tr_anal_xrefs_set (VAR_0->anal, VAR_2, VAR_11->addr, VAR_3);\n\t\t\t}\n\t\t\t/* COMMENT_8 */\n\t\t\tr_anal_add_function (VAR_0->anal, VAR_11);\n\t\t\tif (VAR_5) {\n\t\t\t\tut64 VAR_29 = r_anal_function_max_addr (VAR_11);\n\t\t\t\tRIOMap *VAR_30 = r_io_map_get_at (VAR_0->io, VAR_29);\n\t\t\t\t/* COMMENT_9 */\n\t\t\t\tif (!VAR_30 || (VAR_30 && VAR_30->perm & VAR_31)) {\n\t\t\t\t\tfor (VAR_7 = 0; VAR_7 < VAR_8; VAR_7++) {\n\t\t\t\t\t\tif (VAR_9[VAR_7] == VAR_29) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (VAR_7 == VAR_8) {\n\t\t\t\t\t\tut64 VAR_1 = r_anal_function_max_addr (VAR_11);\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tut64 VAR_32;\n\t\t\t\t\t\t\tRAnalMetaItem *VAR_33 = r_meta_get_at (VAR_0->anal, VAR_1, VAR_34, &VAR_32);\n\t\t\t\t\t\t\tif (!VAR_33) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tVAR_1 += VAR_32;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* COMMENT_10 */\n\t\t\t\t\t\t/* COMMENT_11 */\n\t\t\t\t\t\tr_cons_clear_line (1);\n\t\t\t\t\t\tloganal (VAR_11->addr, VAR_1, 10000 - VAR_4);\n\t\t\t\t\t\tVAR_9 = next_append (VAR_9, &VAR_8, VAR_1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!r_anal_analyze_fcn_refs (VAR_0, VAR_11, VAR_4)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t} while (VAR_10 != VAR_20);\n\tr_list_free (VAR_0->anal->leaddrs);\n\tVAR_0->anal->leaddrs = NULL;\n\tif (VAR_5) {\n\t\tfor (VAR_7 = 0; VAR_7 < VAR_8; VAR_7++) {\n\t\t\tif (!VAR_9[VAR_7] || r_anal_get_fcn_in (VAR_0->anal, VAR_9[VAR_7], 0)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tr_core_anal_fcn (VAR_0, VAR_9[VAR_7], VAR_2, 0, VAR_4 - 1);\n\t\t}\n\t\tfree (VAR_9);\n\t}\n\tif (VAR_0->anal->cur && VAR_0->anal->cur->arch && !strcmp (VAR_0->anal->cur->arch, \"x86\")) {\n\t\tr_anal_function_check_bp_use (VAR_11);\n\t\tif (VAR_11 && !VAR_11->bp_frame) {\n\t\t\tr_anal_function_delete_vars_by_kind (VAR_11, VAR_35);\n\t\t}\n\t}\n\tr_anal_hint_free (VAR_6);\n\treturn true;\n\nerror:\n\tr_list_free (VAR_0->anal->leaddrs);\n\tVAR_0->anal->leaddrs = NULL;\n\t/* COMMENT_12 */\n\tif (VAR_11) {\n\t\tif (!r_anal_function_realsize (VAR_11) || VAR_11->addr == VAR_28) {\n\t\t\tr_anal_function_free (VAR_11);\n\t\t\tVAR_11 = NULL;\n\t\t} else {\n\t\t\t/* COMMENT_13 */\n\t\t\tif (!VAR_11->name) {\n\t\t\t\t/* COMMENT_14 */\n\t\t\t\tVAR_11->name = r_str_newf (\n\t\t\t\t\t\"%s.%08\" VAR_14,\n\t\t\t\t\tr_anal_fcntype_tostring (VAR_11->type),\n\t\t\t\t\tVAR_1);\n\t\t\t\t/* COMMENT_6 */\n\t\t\t\tr_flag_space_push (VAR_0->flags, VAR_27);\n\t\t\t\tr_flag_set (VAR_0->flags, VAR_11->name, VAR_1, r_anal_function_linear_size (VAR_11));\n\t\t\t\tr_flag_space_pop (VAR_0->flags);\n\t\t\t}\n\t\t\tr_anal_add_function (VAR_0->anal, VAR_11);\n\t\t}\n\t\tif (VAR_11 && VAR_5) {\n\t\t\tut64 VAR_36 = r_anal_function_max_addr (VAR_11);\n\t\t\tRIOMap *VAR_30 = r_io_map_get_at (VAR_0->io, VAR_36);\n\t\t\tif (!VAR_30 || (VAR_30 && (VAR_30->perm & VAR_31))) {\n\t\t\t\tVAR_9 = next_append (VAR_9, &VAR_8, VAR_36);\n\t\t\t\tfor (VAR_7 = 0; VAR_7 < VAR_8; VAR_7++) {\n\t\t\t\t\tif (!VAR_9[VAR_7]) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tr_core_anal_fcn (VAR_0, VAR_9[VAR_7], VAR_9[VAR_7], 0, VAR_4 - 1);\n\t\t\t\t}\n\t\t\t\tfree (VAR_9);\n\t\t\t}\n\t\t}\n\t}\n\tif (VAR_11 && VAR_0->anal->cur && VAR_0->anal->cur->arch && !strcmp (VAR_0->anal->cur->arch, \"x86\")) {\n\t\tr_anal_function_check_bp_use (VAR_11);\n\t\tif (!VAR_11->bp_frame) {\n\t\t\tr_anal_function_delete_vars_by_kind (VAR_11, VAR_35);\n\t\t}\n\t}\n\tr_anal_hint_free (VAR_6);\n\treturn false;\n}",
  "func_graph_path_before": "radareorg/radare2/4aff1bb00224de4f5bc118f987dfd5d2fe3450d0/canal.c/vul/before/0.json",
  "func": "static bool __core_anal_fcn(RCore *core, ut64 at, ut64 from, int reftype, int depth) {\n\tif (depth < 0) {\n//\t\tprintf (\"Too deep for 0x%08\"PFMT64x\"\\n\", at);\n//\t\tr_sys_backtrace ();\n\t\treturn false;\n\t}\n\tint has_next = r_config_get_i (core->config, \"anal.hasnext\");\n\tRAnalHint *hint = NULL;\n\tint i, nexti = 0;\n\tut64 *next = NULL;\n\tint fcnlen;\n\tRAnalFunction *fcn = r_anal_function_new (core->anal);\n\tr_warn_if_fail (fcn);\n\tconst char *fcnpfx = r_config_get (core->config, \"anal.fcnprefix\");\n\tif (!fcnpfx) {\n\t\tfcnpfx = \"fcn\";\n\t}\n\tconst char *cc = r_anal_cc_default (core->anal);\n\tif (!cc) {\n\t\tif (r_anal_cc_once (core->anal)) {\n\t\t\teprintf (\"Warning: set your favourite calling convention in `e anal.cc=?`\\n\");\n\t\t}\n\t\tcc = \"reg\";\n\t}\n\tfcn->cc = r_str_constpool_get (&core->anal->constpool, cc);\n\tr_warn_if_fail (fcn->cc);\n\thint = r_anal_hint_get (core->anal, at);\n\tif (hint && hint->bits == 16) {\n\t\t// expand 16bit for function\n\t\tfcn->bits = 16;\n\t} else {\n\t\tfcn->bits = core->anal->bits;\n\t}\n\tfcn->addr = at;\n\tfcn->name = get_function_name (core, at);\n\n\tif (!fcn->name) {\n\t\tfcn->name = r_str_newf (\"%s.%08\"PFMT64x, fcnpfx, at);\n\t}\n\tr_anal_fcn_invalidate_read_ahead_cache ();\n\tdo {\n\t\tRFlagItem *f;\n\t\tut64 delta = r_anal_function_linear_size (fcn);\n\t\tif (!r_io_is_valid_offset (core->io, at + delta, !core->anal->opt.noncode)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (r_cons_is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\tfcnlen = r_anal_function(core->anal, fcn, at + delta, core->anal->opt.bb_max_size, reftype);\n\t\tif (core->anal->opt.searchstringrefs) {\n\t\t\tr_anal_set_stringrefs (core, fcn);\n\t\t}\n\t\tif (fcnlen == 0) {\n\t\t\tif (core->anal->verbose) {\n\t\t\t\teprintf (\"Analyzed function size is 0 at 0x%08\"PFMT64x\"\\n\", at + delta);\n\t\t\t}\n\t\t\tgoto error;\n\t\t}\n\t\tif (fcnlen < 0) {\n\t\t\tswitch (fcnlen) {\n\t\t\tcase R_ANAL_RET_ERROR:\n\t\t\tcase R_ANAL_RET_NEW:\n\t\t\tcase R_ANAL_RET_DUP:\n\t\t\tcase R_ANAL_RET_END:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\teprintf (\"Oops. Negative fcnsize at 0x%08\"PFMT64x\" (%d)\\n\", at, fcnlen);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tf = r_core_flag_get_by_spaces (core->flags, fcn->addr);\n\t\tset_fcn_name_from_flag (fcn, f, fcnpfx);\n\n\t\tif (fcnlen == R_ANAL_RET_ERROR ||\n\t\t\t(fcnlen == R_ANAL_RET_END && !r_anal_function_realsize (fcn))) { /* Error analyzing function */\n\t\t\tif (core->anal->opt.followbrokenfcnsrefs) {\n\t\t\t\tr_anal_analyze_fcn_refs (core, fcn, depth);\n\t\t\t}\n\t\t\tgoto error;\n\t\t} else if (fcnlen == R_ANAL_RET_END) { /* Function analysis complete */\n\t\t\tf = r_core_flag_get_by_spaces (core->flags, fcn->addr);\n\t\t\tif (f && f->name && strncmp (f->name, \"sect\", 4)) { /* Check if it's already flagged */\n\t\t\t\tchar *new_name = strdup (f->name);\n\t\t\t\tif (is_entry_flag (f)) {\n\t\t\t\t\tRListIter *iter;\n\t\t\t\t\tRBinSymbol *sym;\n\t\t\t\t\tconst RList *syms = r_bin_get_symbols (core->bin);\n\t\t\t\t\tut64 baddr = r_config_get_i (core->config, \"bin.baddr\");\n\t\t\t\t\tr_list_foreach (syms, iter, sym) {\n\t\t\t\t\t\tif (sym->type && (sym->paddr + baddr) == fcn->addr && !strcmp (sym->type, R_BIN_TYPE_FUNC_STR)) {\n\t\t\t\t\t\t\tfree (new_name);\n\t\t\t\t\t\t\tnew_name = r_str_newf (\"sym.%s\", sym->name);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree (fcn->name);\n\t\t\t\tfcn->name = new_name;\n\t\t\t} else {\n\t\t\t\tR_FREE (fcn->name);\n\t\t\t\tconst char *fcnpfx = r_anal_fcntype_tostring (fcn->type);\n\t\t\t\tif (!fcnpfx || !*fcnpfx || !strcmp (fcnpfx, \"fcn\")) {\n\t\t\t\t\tfcnpfx = r_config_get (core->config, \"anal.fcnprefix\");\n\t\t\t\t}\n\t\t\t\tfcn->name = r_str_newf (\"%s.%08\"PFMT64x, fcnpfx, fcn->addr);\n\t\t\t\tautoname_imp_trampoline (core, fcn);\n\t\t\t\t/* Add flag */\n\t\t\t\tr_flag_space_push (core->flags, R_FLAGS_FS_FUNCTIONS);\n\t\t\t\tr_flag_set (core->flags, fcn->name, fcn->addr, r_anal_function_linear_size (fcn));\n\t\t\t\tr_flag_space_pop (core->flags);\n\t\t\t}\n\n\t\t\t/* New function: Add initial xref */\n\t\t\tif (from != UT64_MAX) {\n\t\t\t\tr_anal_xrefs_set (core->anal, from, fcn->addr, reftype);\n\t\t\t}\n\t\t\t// XXX: this is wrong. See CID 1134565\n\t\t\tr_anal_add_function (core->anal, fcn);\n\t\t\tif (has_next) {\n\t\t\t\tut64 addr = r_anal_function_max_addr (fcn);\n\t\t\t\tRIOMap *map = r_io_map_get_at (core->io, addr);\n\t\t\t\t// only get next if found on an executable section\n\t\t\t\tif (!map || (map && map->perm & R_PERM_X)) {\n\t\t\t\t\tfor (i = 0; i < nexti; i++) {\n\t\t\t\t\t\tif (next[i] == addr) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (i == nexti) {\n\t\t\t\t\t\tut64 at = r_anal_function_max_addr (fcn);\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tut64 size;\n\t\t\t\t\t\t\tRAnalMetaItem *mi = r_meta_get_at (core->anal, at, R_META_TYPE_ANY, &size);\n\t\t\t\t\t\t\tif (!mi) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tat += size;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// TODO: ensure next address is function after padding (nop or trap or wat)\n\t\t\t\t\t\t// XXX noisy for test cases because we want to clear the stderr\n\t\t\t\t\t\tr_cons_clear_line (1);\n\t\t\t\t\t\tloganal (fcn->addr, at, 10000 - depth);\n\t\t\t\t\t\tnext = next_append (next, &nexti, at);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!r_anal_analyze_fcn_refs (core, fcn, depth)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t} while (fcnlen != R_ANAL_RET_END);\n\tr_list_free (core->anal->leaddrs);\n\tcore->anal->leaddrs = NULL;\n\tif (has_next) {\n\t\tfor (i = 0; i < nexti; i++) {\n\t\t\tif (!next[i] || r_anal_get_fcn_in (core->anal, next[i], 0)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tr_core_anal_fcn (core, next[i], from, 0, depth - 1);\n\t\t}\n\t\tfree (next);\n\t}\n\tif (core->anal->cur && core->anal->cur->arch && !strcmp (core->anal->cur->arch, \"x86\")) {\n\t\tr_anal_function_check_bp_use (fcn);\n\t\tif (fcn && !fcn->bp_frame) {\n\t\t\tr_anal_function_delete_vars_by_kind (fcn, R_ANAL_VAR_KIND_BPV);\n\t\t}\n\t}\n\tr_anal_hint_free (hint);\n\treturn true;\n\nerror:\n\tr_list_free (core->anal->leaddrs);\n\tcore->anal->leaddrs = NULL;\n\t// ugly hack to free fcn\n\tif (fcn) {\n\t\tif (!r_anal_function_realsize (fcn) || fcn->addr == UT64_MAX) {\n\t\t\tr_anal_function_free (fcn);\n\t\t\tfcn = NULL;\n\t\t} else {\n\t\t\t// TODO: mark this function as not properly analyzed\n\t\t\tif (!fcn->name) {\n\t\t\t\t// XXX dupped code.\n\t\t\t\tfcn->name = r_str_newf (\n\t\t\t\t\t\"%s.%08\" PFMT64x,\n\t\t\t\t\tr_anal_fcntype_tostring (fcn->type),\n\t\t\t\t\tat);\n\t\t\t\t/* Add flag */\n\t\t\t\tr_flag_space_push (core->flags, R_FLAGS_FS_FUNCTIONS);\n\t\t\t\tr_flag_set (core->flags, fcn->name, at, r_anal_function_linear_size (fcn));\n\t\t\t\tr_flag_space_pop (core->flags);\n\t\t\t}\n\t\t\tr_anal_add_function (core->anal, fcn);\n\t\t}\n\t\tif (fcn && has_next) {\n\t\t\tut64 newaddr = r_anal_function_max_addr (fcn);\n\t\t\tRIOMap *map = r_io_map_get_at (core->io, newaddr);\n\t\t\tif (!map || (map && (map->perm & R_PERM_X))) {\n\t\t\t\tnext = next_append (next, &nexti, newaddr);\n\t\t\t\tfor (i = 0; i < nexti; i++) {\n\t\t\t\t\tif (!next[i]) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tr_core_anal_fcn (core, next[i], next[i], 0, depth - 1);\n\t\t\t\t}\n\t\t\t\tfree (next);\n\t\t\t}\n\t\t}\n\t}\n\tif (fcn && core->anal->cur && core->anal->cur->arch && !strcmp (core->anal->cur->arch, \"x86\")) {\n\t\tr_anal_function_check_bp_use (fcn);\n\t\tif (!fcn->bp_frame) {\n\t\t\tr_anal_function_delete_vars_by_kind (fcn, R_ANAL_VAR_KIND_BPV);\n\t\t}\n\t}\n\tr_anal_hint_free (hint);\n\treturn false;\n}",
  "abstract_func": "static bool __core_anal_fcn(RCore *VAR_0, ut64 VAR_1, ut64 VAR_2, int VAR_3, int VAR_4) {\n\tif (VAR_4 < 0) {\n/* COMMENT_0 */\n/* COMMENT_1 */\n\t\treturn false;\n\t}\n\tint VAR_5 = r_config_get_i (VAR_0->config, \"anal.hasnext\");\n\tRAnalHint *VAR_6 = NULL;\n\tint VAR_7, VAR_8 = 0;\n\tut64 *VAR_9 = NULL;\n\tint VAR_10;\n\tRAnalFunction *VAR_11 = r_anal_function_new (VAR_0->anal);\n\tr_warn_if_fail (VAR_11);\n\tconst char *VAR_12 = r_config_get (VAR_0->config, \"anal.fcnprefix\");\n\tif (!VAR_12) {\n\t\tVAR_12 = \"fcn\";\n\t}\n\tconst char *VAR_13 = r_anal_cc_default (VAR_0->anal);\n\tif (!VAR_13) {\n\t\tif (r_anal_cc_once (VAR_0->anal)) {\n\t\t\teprintf (\"Warning: set your favourite calling convention in `e anal.cc=?`\\n\");\n\t\t}\n\t\tVAR_13 = \"reg\";\n\t}\n\tVAR_11->cc = r_str_constpool_get (&VAR_0->anal->constpool, VAR_13);\n\tr_warn_if_fail (VAR_11->cc);\n\tVAR_6 = r_anal_hint_get (VAR_0->anal, VAR_1);\n\tif (VAR_6 && VAR_6->bits == 16) {\n\t\t/* COMMENT_2 */\n\t\tVAR_11->bits = 16;\n\t} else {\n\t\tVAR_11->bits = VAR_0->anal->bits;\n\t}\n\tVAR_11->addr = VAR_1;\n\tVAR_11->name = get_function_name (VAR_0, VAR_1);\n\n\tif (!VAR_11->name) {\n\t\tVAR_11->name = r_str_newf (\"%s.%08\"VAR_14, VAR_12, VAR_1);\n\t}\n\tr_anal_fcn_invalidate_read_ahead_cache ();\n\tdo {\n\t\tRFlagItem *VAR_15;\n\t\tut64 VAR_16 = r_anal_function_linear_size (VAR_11);\n\t\tif (!r_io_is_valid_offset (VAR_0->io, VAR_1 + VAR_16, !VAR_0->anal->opt.noncode)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (r_cons_is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\tVAR_10 = r_anal_function(VAR_0->anal, VAR_11, VAR_1 + VAR_16, VAR_0->anal->opt.bb_max_size, VAR_3);\n\t\tif (VAR_0->anal->opt.searchstringrefs) {\n\t\t\tr_anal_set_stringrefs (VAR_0, VAR_11);\n\t\t}\n\t\tif (VAR_10 == 0) {\n\t\t\tif (VAR_0->anal->verbose) {\n\t\t\t\teprintf (\"Analyzed function size is 0 at 0x%08\"VAR_14\"\\n\", VAR_1 + VAR_16);\n\t\t\t}\n\t\t\tgoto error;\n\t\t}\n\t\tif (VAR_10 < 0) {\n\t\t\tswitch (VAR_10) {\n\t\t\tcase VAR_17:\n\t\t\tcase VAR_18:\n\t\t\tcase VAR_19:\n\t\t\tcase VAR_20:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\teprintf (\"Oops. Negative fcnsize at 0x%08\"VAR_14\" (%d)\\n\", VAR_1, VAR_10);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tVAR_15 = r_core_flag_get_by_spaces (VAR_0->flags, VAR_11->addr);\n\t\tset_fcn_name_from_flag (VAR_11, VAR_15, VAR_12);\n\n\t\tif (VAR_10 == VAR_17 ||\n\t\t\t(VAR_10 == VAR_20 && !r_anal_function_realsize (VAR_11))) { /* COMMENT_3 */\n\t\t\tif (VAR_0->anal->opt.followbrokenfcnsrefs) {\n\t\t\t\tr_anal_analyze_fcn_refs (VAR_0, VAR_11, VAR_4);\n\t\t\t}\n\t\t\tgoto error;\n\t\t} else if (VAR_10 == VAR_20) { /* COMMENT_4 */\n\t\t\tVAR_15 = r_core_flag_get_by_spaces (VAR_0->flags, VAR_11->addr);\n\t\t\tif (VAR_15 && VAR_15->name && strncmp (VAR_15->name, \"sect\", 4)) { /* COMMENT_5 */\n\t\t\t\tchar *VAR_21 = strdup (VAR_15->name);\n\t\t\t\tif (is_entry_flag (VAR_15)) {\n\t\t\t\t\tRListIter *VAR_22;\n\t\t\t\t\tRBinSymbol *VAR_23;\n\t\t\t\t\tconst RList *VAR_24 = r_bin_get_symbols (VAR_0->bin);\n\t\t\t\t\tut64 VAR_25 = r_config_get_i (VAR_0->config, \"bin.baddr\");\n\t\t\t\t\tr_list_foreach (VAR_24, VAR_22, VAR_23) {\n\t\t\t\t\t\tif (VAR_23->type && (VAR_23->paddr + VAR_25) == VAR_11->addr && !strcmp (VAR_23->type, VAR_26)) {\n\t\t\t\t\t\t\tfree (VAR_21);\n\t\t\t\t\t\t\tVAR_21 = r_str_newf (\"sym.%s\", VAR_23->name);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree (VAR_11->name);\n\t\t\t\tVAR_11->name = VAR_21;\n\t\t\t} else {\n\t\t\t\tR_FREE (VAR_11->name);\n\t\t\t\tconst char *VAR_12 = r_anal_fcntype_tostring (VAR_11->type);\n\t\t\t\tif (!VAR_12 || !*VAR_12 || !strcmp (VAR_12, \"fcn\")) {\n\t\t\t\t\tVAR_12 = r_config_get (VAR_0->config, \"anal.fcnprefix\");\n\t\t\t\t}\n\t\t\t\tVAR_11->name = r_str_newf (\"%s.%08\"VAR_14, VAR_12, VAR_11->addr);\n\t\t\t\tautoname_imp_trampoline (VAR_0, VAR_11);\n\t\t\t\t/* COMMENT_6 */\n\t\t\t\tr_flag_space_push (VAR_0->flags, VAR_27);\n\t\t\t\tr_flag_set (VAR_0->flags, VAR_11->name, VAR_11->addr, r_anal_function_linear_size (VAR_11));\n\t\t\t\tr_flag_space_pop (VAR_0->flags);\n\t\t\t}\n\n\t\t\t/* COMMENT_7 */\n\t\t\tif (VAR_2 != VAR_28) {\n\t\t\t\tr_anal_xrefs_set (VAR_0->anal, VAR_2, VAR_11->addr, VAR_3);\n\t\t\t}\n\t\t\t/* COMMENT_8 */\n\t\t\tr_anal_add_function (VAR_0->anal, VAR_11);\n\t\t\tif (VAR_5) {\n\t\t\t\tut64 VAR_29 = r_anal_function_max_addr (VAR_11);\n\t\t\t\tRIOMap *VAR_30 = r_io_map_get_at (VAR_0->io, VAR_29);\n\t\t\t\t/* COMMENT_9 */\n\t\t\t\tif (!VAR_30 || (VAR_30 && VAR_30->perm & VAR_31)) {\n\t\t\t\t\tfor (VAR_7 = 0; VAR_7 < VAR_8; VAR_7++) {\n\t\t\t\t\t\tif (VAR_9[VAR_7] == VAR_29) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (VAR_7 == VAR_8) {\n\t\t\t\t\t\tut64 VAR_1 = r_anal_function_max_addr (VAR_11);\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tut64 VAR_32;\n\t\t\t\t\t\t\tRAnalMetaItem *VAR_33 = r_meta_get_at (VAR_0->anal, VAR_1, VAR_34, &VAR_32);\n\t\t\t\t\t\t\tif (!VAR_33) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tVAR_1 += VAR_32;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* COMMENT_10 */\n\t\t\t\t\t\t/* COMMENT_11 */\n\t\t\t\t\t\tr_cons_clear_line (1);\n\t\t\t\t\t\tloganal (VAR_11->addr, VAR_1, 10000 - VAR_4);\n\t\t\t\t\t\tVAR_9 = next_append (VAR_9, &VAR_8, VAR_1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!r_anal_analyze_fcn_refs (VAR_0, VAR_11, VAR_4)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t} while (VAR_10 != VAR_20);\n\tr_list_free (VAR_0->anal->leaddrs);\n\tVAR_0->anal->leaddrs = NULL;\n\tif (VAR_5) {\n\t\tfor (VAR_7 = 0; VAR_7 < VAR_8; VAR_7++) {\n\t\t\tif (!VAR_9[VAR_7] || r_anal_get_fcn_in (VAR_0->anal, VAR_9[VAR_7], 0)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tr_core_anal_fcn (VAR_0, VAR_9[VAR_7], VAR_2, 0, VAR_4 - 1);\n\t\t}\n\t\tfree (VAR_9);\n\t}\n\tif (VAR_0->anal->cur && VAR_0->anal->cur->arch && !strcmp (VAR_0->anal->cur->arch, \"x86\")) {\n\t\tr_anal_function_check_bp_use (VAR_11);\n\t\tif (VAR_11 && !VAR_11->bp_frame) {\n\t\t\tr_anal_function_delete_vars_by_kind (VAR_11, VAR_35);\n\t\t}\n\t}\n\tr_anal_hint_free (VAR_6);\n\treturn true;\n\nerror:\n\tr_list_free (VAR_0->anal->leaddrs);\n\tVAR_0->anal->leaddrs = NULL;\n\t/* COMMENT_12 */\n\tif (VAR_11) {\n\t\tif (!r_anal_function_realsize (VAR_11) || VAR_11->addr == VAR_28) {\n\t\t\tr_anal_function_free (VAR_11);\n\t\t\tVAR_11 = NULL;\n\t\t} else {\n\t\t\t/* COMMENT_13 */\n\t\t\tif (!VAR_11->name) {\n\t\t\t\t/* COMMENT_14 */\n\t\t\t\tVAR_11->name = r_str_newf (\n\t\t\t\t\t\"%s.%08\" VAR_14,\n\t\t\t\t\tr_anal_fcntype_tostring (VAR_11->type),\n\t\t\t\t\tVAR_1);\n\t\t\t\t/* COMMENT_6 */\n\t\t\t\tr_flag_space_push (VAR_0->flags, VAR_27);\n\t\t\t\tr_flag_set (VAR_0->flags, VAR_11->name, VAR_1, r_anal_function_linear_size (VAR_11));\n\t\t\t\tr_flag_space_pop (VAR_0->flags);\n\t\t\t}\n\t\t\tr_anal_add_function (VAR_0->anal, VAR_11);\n\t\t}\n\t\tif (VAR_11 && VAR_5) {\n\t\t\tut64 VAR_36 = r_anal_function_max_addr (VAR_11);\n\t\t\tRIOMap *VAR_30 = r_io_map_get_at (VAR_0->io, VAR_36);\n\t\t\tif (!VAR_30 || (VAR_30 && (VAR_30->perm & VAR_31))) {\n\t\t\t\tVAR_9 = next_append (VAR_9, &VAR_8, VAR_36);\n\t\t\t\tfor (VAR_7 = 0; VAR_7 < VAR_8; VAR_7++) {\n\t\t\t\t\tif (!VAR_9[VAR_7]) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tr_core_anal_fcn (VAR_0, VAR_9[VAR_7], VAR_9[VAR_7], 0, VAR_4 - 1);\n\t\t\t\t}\n\t\t\t\tfree (VAR_9);\n\t\t\t}\n\t\t}\n\t}\n\tif (VAR_11 && VAR_0->anal->cur && VAR_0->anal->cur->arch && !strcmp (VAR_0->anal->cur->arch, \"x86\")) {\n\t\tr_anal_function_check_bp_use (VAR_11);\n\t\tif (!VAR_11->bp_frame) {\n\t\t\tr_anal_function_delete_vars_by_kind (VAR_11, VAR_35);\n\t\t}\n\t}\n\tr_anal_hint_free (VAR_6);\n\treturn false;\n}",
  "func_graph_path": "radareorg/radare2/4aff1bb00224de4f5bc118f987dfd5d2fe3450d0/canal.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -88,7 +88,7 @@\n \t\t\t\t\tconst RList *syms = r_bin_get_symbols (core->bin);\n \t\t\t\t\tut64 baddr = r_config_get_i (core->config, \"bin.baddr\");\n \t\t\t\t\tr_list_foreach (syms, iter, sym) {\n-\t\t\t\t\t\tif ((sym->paddr + baddr) == fcn->addr && !strcmp (sym->type, R_BIN_TYPE_FUNC_STR)) {\n+\t\t\t\t\t\tif (sym->type && (sym->paddr + baddr) == fcn->addr && !strcmp (sym->type, R_BIN_TYPE_FUNC_STR)) {\n \t\t\t\t\t\t\tfree (new_name);\n \t\t\t\t\t\t\tnew_name = r_str_newf (\"sym.%s\", sym->name);\n \t\t\t\t\t\t\tbreak;",
  "diff_line_info": {
    "deleted_lines": [
      "\t\t\t\t\t\tif ((sym->paddr + baddr) == fcn->addr && !strcmp (sym->type, R_BIN_TYPE_FUNC_STR)) {"
    ],
    "added_lines": [
      "\t\t\t\t\t\tif (sym->type && (sym->paddr + baddr) == fcn->addr && !strcmp (sym->type, R_BIN_TYPE_FUNC_STR)) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/radareorg/radare2/pull/19343",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/radareorg/radare2/pull/19343: 403 Client Error: Forbidden for url: https://api.github.com/repos/radareorg/radare2/pulls/19343",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.7,
  "Bug Filter Response": "Final Classification: Defect Remediation & Feature Upgrades; Confidence: 0.7\n\n**Step-by-Step Explanation:**\n\n1. **Input Analysis:** The commit message references a crash fix related to corrupted ELFs, indicating a bug fix. The code diff adds a null check, preventing a potential crash.\n\n2. **Consistency Check:** The code change aligns with the commit message, addressing a crash issue.\n\n3. **Purpose Evaluation:** The fix is a core logic modification to prevent a crash, not related to testing or configuration.\n\n4. **Security Assessment:** While the crash could have security implications, there's no explicit mention of security, making it less certain as a security fix.\n\n5. **Classification:** As a bug fix without clear security context, it falls under \"Defect Remediation & Feature Upgrades.\"\n\n6. **Confidence Score:** 0.7 due to the potential security implication ambiguity, despite clear bug fix intent."
}