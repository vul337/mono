{
  "cve_id": "CVE-2023-44487",
  "cwe_ids": [
    "CWE-400"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "envoyproxy/envoy",
  "commit_msg": "Limit the number of HTTP requests processed from a connection in I/O cycle\n\nSigned-off-by: Yan Avlasov <yavlasov@google.com>\n\nSigned-off-by: Ryan Northey <ryan@synca.io>",
  "commit_hash": "cf687ac66b60f14a71e2a7e552943f138922a71d",
  "git_url": "https://github.com/envoyproxy/envoy/commit/cf687ac66b60f14a71e2a7e552943f138922a71d",
  "file_path": "source/common/http/conn_manager_impl.cc",
  "func_name": "ConnectionManagerImpl::onData",
  "func_before": "Network::FilterStatus ConnectionManagerImpl::onData(Buffer::Instance& data, bool) {\n  if (!codec_) {\n    // Http3 codec should have been instantiated by now.\n    createCodec(data);\n  }\n\n  bool redispatch;\n  do {\n    redispatch = false;\n\n    const Status status = codec_->dispatch(data);\n\n    if (isBufferFloodError(status) || isInboundFramesWithEmptyPayloadError(status)) {\n      handleCodecError(status.message());\n      return Network::FilterStatus::StopIteration;\n    } else if (isCodecProtocolError(status)) {\n      stats_.named_.downstream_cx_protocol_error_.inc();\n      handleCodecError(status.message());\n      return Network::FilterStatus::StopIteration;\n    } else if (isEnvoyOverloadError(status)) {\n      // The other codecs aren't wired to send this status.\n      ASSERT(codec_->protocol() < Protocol::Http2,\n             \"Expected only HTTP1.1 and below to send overload error.\");\n      stats_.named_.downstream_rq_overload_close_.inc();\n      handleCodecOverloadError(status.message());\n      return Network::FilterStatus::StopIteration;\n    }\n    ASSERT(status.ok());\n\n    // Processing incoming data may release outbound data so check for closure here as well.\n    checkForDeferredClose(false);\n\n    // The HTTP/1 codec will pause dispatch after a single message is complete. We want to\n    // either redispatch if there are no streams and we have more data. If we have a single\n    // complete non-WebSocket stream but have not responded yet we will pause socket reads\n    // to apply back pressure.\n    if (codec_->protocol() < Protocol::Http2) {\n      if (read_callbacks_->connection().state() == Network::Connection::State::Open &&\n          data.length() > 0 && streams_.empty()) {\n        redispatch = true;\n      }\n    }\n  } while (redispatch);\n\n  if (!read_callbacks_->connection().streamInfo().protocol()) {\n    read_callbacks_->connection().streamInfo().protocol(codec_->protocol());\n  }\n\n  return Network::FilterStatus::StopIteration;\n}",
  "abstract_func_before": "Network::FilterStatus ConnectionManagerImpl::onData(Buffer::Instance& VAR_0, bool) {\n  if (!VAR_1) {\n    /* COMMENT_0 */\n    createCodec(VAR_0);\n  }\n\n  bool VAR_2;\n  do {\n    VAR_2 = false;\n\n    const Status VAR_3 = VAR_1->dispatch(VAR_0);\n\n    if (isBufferFloodError(VAR_3) || isInboundFramesWithEmptyPayloadError(VAR_3)) {\n      handleCodecError(VAR_3.message());\n      return Network::FilterStatus::StopIteration;\n    } else if (isCodecProtocolError(VAR_3)) {\n      VAR_4.named_.downstream_cx_protocol_error_.inc();\n      handleCodecError(VAR_3.message());\n      return Network::FilterStatus::StopIteration;\n    } else if (isEnvoyOverloadError(VAR_3)) {\n      /* COMMENT_1 */\n      ASSERT(VAR_1->protocol() < Protocol::Http2,\n             \"Expected only HTTP1.1 and below to send overload error.\");\n      VAR_4.named_.downstream_rq_overload_close_.inc();\n      handleCodecOverloadError(VAR_3.message());\n      return Network::FilterStatus::StopIteration;\n    }\n    ASSERT(VAR_3.ok());\n\n    /* COMMENT_2 */\n    checkForDeferredClose(false);\n\n    /* COMMENT_3 */\n    /* COMMENT_4 */\n    /* COMMENT_5 */\n    /* COMMENT_6 */\n    if (VAR_1->protocol() < Protocol::Http2) {\n      if (VAR_5->connection().state() == Network::Connection::State::Open &&\n          VAR_0.length() > 0 && VAR_6.empty()) {\n        VAR_2 = true;\n      }\n    }\n  } while (VAR_2);\n\n  if (!VAR_5->connection().streamInfo().protocol()) {\n    VAR_5->connection().streamInfo().protocol(VAR_1->protocol());\n  }\n\n  return Network::FilterStatus::StopIteration;\n}",
  "func_graph_path_before": "envoyproxy/envoy/cf687ac66b60f14a71e2a7e552943f138922a71d/conn_manager_impl.cc/vul/before/1.json",
  "func": "Network::FilterStatus ConnectionManagerImpl::onData(Buffer::Instance& data, bool) {\n  requests_during_dispatch_count_ = 0;\n  if (!codec_) {\n    // Http3 codec should have been instantiated by now.\n    createCodec(data);\n  }\n\n  bool redispatch;\n  do {\n    redispatch = false;\n\n    const Status status = codec_->dispatch(data);\n\n    if (isBufferFloodError(status) || isInboundFramesWithEmptyPayloadError(status)) {\n      handleCodecError(status.message());\n      return Network::FilterStatus::StopIteration;\n    } else if (isCodecProtocolError(status)) {\n      stats_.named_.downstream_cx_protocol_error_.inc();\n      handleCodecError(status.message());\n      return Network::FilterStatus::StopIteration;\n    } else if (isEnvoyOverloadError(status)) {\n      // The other codecs aren't wired to send this status.\n      ASSERT(codec_->protocol() < Protocol::Http2,\n             \"Expected only HTTP1.1 and below to send overload error.\");\n      stats_.named_.downstream_rq_overload_close_.inc();\n      handleCodecOverloadError(status.message());\n      return Network::FilterStatus::StopIteration;\n    }\n    ASSERT(status.ok());\n\n    // Processing incoming data may release outbound data so check for closure here as well.\n    checkForDeferredClose(false);\n\n    // The HTTP/1 codec will pause dispatch after a single message is complete. We want to\n    // either redispatch if there are no streams and we have more data. If we have a single\n    // complete non-WebSocket stream but have not responded yet we will pause socket reads\n    // to apply back pressure.\n    if (codec_->protocol() < Protocol::Http2) {\n      if (read_callbacks_->connection().state() == Network::Connection::State::Open &&\n          data.length() > 0 && streams_.empty()) {\n        redispatch = true;\n      }\n    }\n  } while (redispatch);\n\n  if (!read_callbacks_->connection().streamInfo().protocol()) {\n    read_callbacks_->connection().streamInfo().protocol(codec_->protocol());\n  }\n\n  return Network::FilterStatus::StopIteration;\n}",
  "abstract_func": "Network::FilterStatus ConnectionManagerImpl::onData(Buffer::Instance& VAR_0, bool) {\n  VAR_1 = 0;\n  if (!VAR_2) {\n    /* COMMENT_0 */\n    createCodec(VAR_0);\n  }\n\n  bool VAR_3;\n  do {\n    VAR_3 = false;\n\n    const Status VAR_4 = VAR_2->dispatch(VAR_0);\n\n    if (isBufferFloodError(VAR_4) || isInboundFramesWithEmptyPayloadError(VAR_4)) {\n      handleCodecError(VAR_4.message());\n      return Network::FilterStatus::StopIteration;\n    } else if (isCodecProtocolError(VAR_4)) {\n      VAR_5.named_.downstream_cx_protocol_error_.inc();\n      handleCodecError(VAR_4.message());\n      return Network::FilterStatus::StopIteration;\n    } else if (isEnvoyOverloadError(VAR_4)) {\n      /* COMMENT_1 */\n      ASSERT(VAR_2->protocol() < Protocol::Http2,\n             \"Expected only HTTP1.1 and below to send overload error.\");\n      VAR_5.named_.downstream_rq_overload_close_.inc();\n      handleCodecOverloadError(VAR_4.message());\n      return Network::FilterStatus::StopIteration;\n    }\n    ASSERT(VAR_4.ok());\n\n    /* COMMENT_2 */\n    checkForDeferredClose(false);\n\n    /* COMMENT_3 */\n    /* COMMENT_4 */\n    /* COMMENT_5 */\n    /* COMMENT_6 */\n    if (VAR_2->protocol() < Protocol::Http2) {\n      if (VAR_6->connection().state() == Network::Connection::State::Open &&\n          VAR_0.length() > 0 && VAR_7.empty()) {\n        VAR_3 = true;\n      }\n    }\n  } while (VAR_3);\n\n  if (!VAR_6->connection().streamInfo().protocol()) {\n    VAR_6->connection().streamInfo().protocol(VAR_2->protocol());\n  }\n\n  return Network::FilterStatus::StopIteration;\n}",
  "func_graph_path": "envoyproxy/envoy/cf687ac66b60f14a71e2a7e552943f138922a71d/conn_manager_impl.cc/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,5 @@\n Network::FilterStatus ConnectionManagerImpl::onData(Buffer::Instance& data, bool) {\n+  requests_during_dispatch_count_ = 0;\n   if (!codec_) {\n     // Http3 codec should have been instantiated by now.\n     createCodec(data);",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "  requests_during_dispatch_count_ = 0;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/envoyproxy/envoy/pull/30055",
  "description": {
    "pr_info": {
      "title": "http: Fix CVE CVE-2023-44487",
      "number": 30055
    },
    "comment": [
      "<!--\r\n!!!ATTENTION!!!\r\n\r\nIf you are fixing *any* crash or *any* potential security issue, *do not*\r\nopen a pull request in this repo. Please report the issue via emailing\r\nenvoy-security@googlegroups.com where the issue will be triaged appropriately.\r\nThank you in advance for helping to keep Envoy secure.\r\n\r\n!!!ATTENTION!!!\r\n\r\nFor an explanation of how to fill out the fields, please see the relevant section\r\nin [PULL_REQUESTS.md](https://github.com/envoyproxy/envoy/blob/main/PULL_REQUESTS.md)\r\n-->\r\n\r\nCommit Message:\r\nAdditional Description:\r\nRisk Level:\r\nTesting:\r\nDocs Changes:\r\nRelease Notes:\r\nPlatform Specific Features:\r\n[Optional Runtime guard:]\r\n[Optional Fixes #Issue]\r\n[Optional Fixes commit #PR or SHA]\r\n[Optional Deprecated:]\r\n[Optional [API Considerations](https://github.com/envoyproxy/envoy/blob/main/api/review_checklist.md):]\r\n",
      "CC @envoyproxy/runtime-guard-changes: FYI only for changes made to `(source/common/runtime/runtime_features.cc)`.\n\n\n<details>\n\t<summary>:cat:</summary>\n\nCaused by: https://github.com/envoyproxy/envoy/pull/30055 was opened by phlax.\n\nsee: [more](https://github.com/envoyproxy/envoy/pull/30055), [trace](https://prod.repokitteh.app/traces/ui/envoyproxy/envoy/ae59df20-6764-11ee-8d82-8654fbd73ccb).\n</details>",
      "should we document the stats in `docs/root/configuration/http/http_conn_man/stats.rst`? I need to blame to find this commit to get more sense on `http.downstream_rq_too_many_premature_resets`",
      "Hi,\r\n\r\nI'm trying to analyze the impact from our users perspective what these new parameters are introducing for them.\r\n\r\n`overload.premature_reset_min_stream_lifetime_seconds` and `overload.premature_reset_total_stream_count` as I understood are for identifying that rapid reset attack is happening. Or if not the actual attack then some misbehavior of client. [Rapid reset](https://github.com/envoyproxy/envoy/security/advisories/GHSA-jhv4-f7mr-xx76)\r\n\r\nAnd `http.max_requests_per_io_cycle` is to help serving requests that are not related to the attack.\r\n\r\nBut in practice what does this mean:\r\n - If we set http.max_requests_per_io_cycle to 1 than Envoy will switch between TCP sockets after it processes 1 request in each?\r\n - Is this switch expected to be costly CPU wise?\r\n - how does Envoy work without setting these parameters? \r\n\r\nAlso I couldn't find definition in your repo on what I/O cycle means for you. Can you please explain?\r\n\r\nThanks in advance!"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Step-by-Step Explanation:**\n\n1. **Input Analysis:** The commit addresses limiting HTTP requests in I/O, with code reseting a counter. No security terms.\n\n2. **Consistency Check:** Commit aligns with code change; introduction of counter reset.\n\n3. **Purpose Evaluation:** Modifies core logic to manage requests, likely a feature upgrade.\n\n4. **Security Assessment:** No mention of security issues or CVEs; changes are functional.\n\n5. **Classification:** Defect Remediation & Feature Upgrades (modifies core logic).\n\n6. **Confidence:** 0.9 (clear purpose, no security context).\n\n**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.9"
}