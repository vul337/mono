{
  "cve_id": "CVE-2021-35939",
  "cwe_ids": [
    "CWE-59"
  ],
  "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "rpm-software-management/rpm",
  "commit_msg": "Validate intermediate symlinks during installation, CVE-2021-35939\n\nWhenever directory changes during unpacking, walk the entire tree from\nstarting from / and validate any symlinks crossed, fail the install\non invalid links.\n\nThis is the first of step of many towards securing our file operations\nagainst local tamperers and besides plugging that one CVE, paves the way\nfor the next step by adding the necessary directory fd tracking.\nThis also bumps the rpm OS requirements to a whole new level by requiring\nthe *at() family of calls from POSIX-1.2008.\n\nThis necessarily does a whole lot of huffing and puffing we previously\ndid not do. It should be possible to cache secure (ie root-owned)\ndirectory structures to avoid validating everything a million times\nbut for now, just keeping things simple.",
  "commit_hash": "96ec957e281220f8e137a2d5eb23b83a6377d556",
  "git_url": "https://github.com/rpm-software-management/rpm/commit/96ec957e281220f8e137a2d5eb23b83a6377d556",
  "file_path": "lib/fsm.c",
  "func_name": "rpmPackageFilesInstall",
  "func_before": "int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,\n              rpmpsm psm, char ** failedFile)\n{\n    FD_t payload = rpmtePayload(te);\n    rpmfi fi = NULL;\n    rpmfs fs = rpmteGetFileStates(te);\n    rpmPlugins plugins = rpmtsPlugins(ts);\n    int rc = 0;\n    int fx = -1;\n    int fc = rpmfilesFC(files);\n    int nodigest = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOFILEDIGEST) ? 1 : 0;\n    int nofcaps = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOCAPS) ? 1 : 0;\n    FD_t firstlinkfile = NULL;\n    char *tid = NULL;\n    struct filedata_s *fdata = xcalloc(fc, sizeof(*fdata));\n    struct filedata_s *firstlink = NULL;\n\n    /* transaction id used for temporary path suffix while installing */\n    rasprintf(&tid, \";%08x\", (unsigned)rpmtsGetTid(ts));\n\n    /* Collect state data for the whole operation */\n    fi = rpmfilesIter(files, RPMFI_ITER_FWD);\n    while (!rc && (fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\tif (rpmfiFFlags(fi) & RPMFILE_GHOST)\n            fp->action = FA_SKIP;\n\telse\n\t    fp->action = rpmfsGetAction(fs, fx);\n\tfp->skip = XFA_SKIPPING(fp->action);\n\tfp->setmeta = 1;\n\tif (XFA_CREATING(fp->action) && !S_ISDIR(rpmfiFMode(fi)))\n\t    fp->suffix = tid;\n\tfp->fpath = fsmFsPath(fi, fp->suffix);\n\n\t/* Remap file perms, owner, and group. */\n\trc = rpmfiStat(fi, 1, &fp->sb);\n\n\tsetFileState(fs, fx);\n\tfsmDebug(fp->fpath, fp->action, &fp->sb);\n\n\t/* Run fsm file pre hook for all plugins */\n\trc = rpmpluginsCallFsmFilePre(plugins, fi, fp->fpath,\n\t\t\t\t      fp->sb.st_mode, fp->action);\n\tfp->stage = FILE_PRE;\n    }\n    fi = rpmfiFree(fi);\n\n    if (rc)\n\tgoto exit;\n\n    if (rpmteType(te) == TR_ADDED)\n\tfi = rpmfiNewArchiveReader(payload, files, RPMFI_ITER_READ_ARCHIVE);\n    else\n\tfi = rpmfilesIter(files, RPMFI_ITER_FWD);\n    if (fi == NULL) {\n        rc = RPMERR_BAD_MAGIC;\n        goto exit;\n    }\n\n    /* Detect and create directories not explicitly in package. */\n    if (!rc)\n\trc = fsmMkdirs(files, fs, plugins);\n\n    /* Process the payload */\n    while (!rc && (fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\n        if (!fp->skip) {\n\t    /* Directories replacing something need early backup */\n\t    if (!fp->suffix) {\n\t\trc = fsmBackup(fi, fp->action);\n\t    }\n\t    /* Assume file does't exist when tmp suffix is in use */\n\t    if (!fp->suffix) {\n\t\tif (fp->action == FA_TOUCH) {\n\t\t    struct stat sb;\n\t\t    rc = fsmStat(fp->fpath, 1, &sb);\n\t\t} else {\n\t\t    rc = fsmVerify(fp->fpath, fi);\n\t\t}\n\t    } else {\n\t\trc = RPMERR_ENOENT;\n\t    }\n\n\t    /* See if the file was removed while our attention was elsewhere */\n\t    if (rc == RPMERR_ENOENT && fp->action == FA_TOUCH) {\n\t\trpmlog(RPMLOG_DEBUG, \"file %s vanished unexpectedly\\n\",\n\t\t\tfp->fpath);\n\t\tfp->action = FA_CREATE;\n\t\tfsmDebug(fp->fpath, fp->action, &fp->sb);\n\t    }\n\n\t    /* When touching we don't need any of this... */\n\t    if (fp->action == FA_TOUCH)\n\t\tcontinue;\n\n            if (S_ISREG(fp->sb.st_mode)) {\n\t\tif (rc == RPMERR_ENOENT) {\n\t\t    rc = fsmMkfile(fi, fp, files, psm, nodigest,\n\t\t\t\t   &firstlink, &firstlinkfile);\n\t\t}\n            } else if (S_ISDIR(fp->sb.st_mode)) {\n                if (rc == RPMERR_ENOENT) {\n                    mode_t mode = fp->sb.st_mode;\n                    mode &= ~07777;\n                    mode |=  00700;\n                    rc = fsmMkdir(fp->fpath, mode);\n                }\n            } else if (S_ISLNK(fp->sb.st_mode)) {\n\t\tif (rc == RPMERR_ENOENT) {\n\t\t    rc = fsmSymlink(rpmfiFLink(fi), fp->fpath);\n\t\t}\n            } else if (S_ISFIFO(fp->sb.st_mode)) {\n                /* This mimics cpio S_ISSOCK() behavior but probably isn't right */\n                if (rc == RPMERR_ENOENT) {\n                    rc = fsmMkfifo(fp->fpath, 0000);\n                }\n            } else if (S_ISCHR(fp->sb.st_mode) ||\n                       S_ISBLK(fp->sb.st_mode) ||\n                       S_ISSOCK(fp->sb.st_mode))\n            {\n                if (rc == RPMERR_ENOENT) {\n                    rc = fsmMknod(fp->fpath, fp->sb.st_mode, fp->sb.st_rdev);\n                }\n            } else {\n                /* XXX Special case /dev/log, which shouldn't be packaged anyways */\n                if (!IS_DEV_LOG(fp->fpath))\n                    rc = RPMERR_UNKNOWN_FILETYPE;\n            }\n\t} else if (firstlink && rpmfiArchiveHasContent(fi)) {\n\t    /*\n\t     * Tricksy case: this file is a being skipped, but it's part of\n\t     * a hardlinked set and has the actual content linked with it.\n\t     * Write the content to the first non-skipped file of the set\n\t     * instead.\n\t     */\n\t    rc = fsmMkfile(fi, firstlink, files, psm, nodigest,\n\t\t\t   &firstlink, &firstlinkfile);\n\t}\n\n\t/* Notify on success. */\n\tif (rc)\n\t    *failedFile = xstrdup(fp->fpath);\n\telse\n\t    rpmpsmNotify(psm, RPMCALLBACK_INST_PROGRESS, rpmfiArchiveTell(fi));\n\tfp->stage = FILE_UNPACK;\n    }\n    fi = rpmfiFree(fi);\n\n    if (!rc && fx < 0 && fx != RPMERR_ITER_END)\n\trc = fx;\n\n    /* Set permissions, timestamps etc for non-hardlink entries */\n    fi = rpmfilesIter(files, RPMFI_ITER_FWD);\n    while (!rc && (fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\tif (!fp->skip && fp->setmeta) {\n\t    rc = fsmSetmeta(fp->fpath, fi, plugins, fp->action,\n\t\t\t    &fp->sb, nofcaps);\n\t}\n\tif (rc)\n\t    *failedFile = xstrdup(fp->fpath);\n\tfp->stage = FILE_PREP;\n    }\n    fi = rpmfiFree(fi);\n\n    /* If all went well, commit files to final destination */\n    fi = rpmfilesIter(files, RPMFI_ITER_FWD);\n    while (!rc && (fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\n\tif (!fp->skip) {\n\t    /* Backup file if needed. Directories are handled earlier */\n\t    if (!rc && fp->suffix)\n\t\trc = fsmBackup(fi, fp->action);\n\n\t    if (!rc)\n\t\trc = fsmCommit(&fp->fpath, fi, fp->action, fp->suffix);\n\n\t    if (!rc)\n\t\tfp->stage = FILE_COMMIT;\n\t    else\n\t\t*failedFile = xstrdup(fp->fpath);\n\t}\n    }\n    fi = rpmfiFree(fi);\n\n    /* Walk backwards in case we need to erase */\n    fi = rpmfilesIter(files, RPMFI_ITER_BACK);\n    while ((fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\t/* Run fsm file post hook for all plugins for all processed files */\n\tif (fp->stage) {\n\t    rpmpluginsCallFsmFilePost(plugins, fi, fp->fpath,\n\t\t\t\t      fp->sb.st_mode, fp->action, rc);\n\t}\n\n\t/* On failure, erase non-committed files */\n\tif (rc && fp->stage > FILE_NONE && !fp->skip) {\n\t    (void) fsmRemove(fp->fpath, fp->sb.st_mode);\n\t}\n    }\n\n    rpmswAdd(rpmtsOp(ts, RPMTS_OP_UNCOMPRESS), fdOp(payload, FDSTAT_READ));\n    rpmswAdd(rpmtsOp(ts, RPMTS_OP_DIGEST), fdOp(payload, FDSTAT_DIGEST));\n\nexit:\n    fi = rpmfiFree(fi);\n    Fclose(payload);\n    free(tid);\n    for (int i = 0; i < fc; i++)\n\tfree(fdata[i].fpath);\n    free(fdata);\n\n    return rc;\n}",
  "abstract_func_before": "int rpmPackageFilesInstall(rpmts VAR_0, rpmte VAR_1, rpmfiles VAR_2,\n              rpmpsm VAR_3, char ** VAR_4)\n{\n    FD_t VAR_5 = rpmtePayload(VAR_1);\n    rpmfi VAR_6 = NULL;\n    rpmfs VAR_7 = rpmteGetFileStates(VAR_1);\n    rpmPlugins VAR_8 = rpmtsPlugins(VAR_0);\n    int VAR_9 = 0;\n    int VAR_10 = -1;\n    int VAR_11 = rpmfilesFC(VAR_2);\n    int VAR_12 = (rpmtsFlags(VAR_0) & VAR_13) ? 1 : 0;\n    int VAR_14 = (rpmtsFlags(VAR_0) & VAR_15) ? 1 : 0;\n    FD_t VAR_16 = NULL;\n    char *VAR_17 = NULL;\n    struct filedata_s *VAR_18 = xcalloc(VAR_11, sizeof(*VAR_18));\n    struct filedata_s *VAR_19 = NULL;\n\n    /* COMMENT_0 */\n    rasprintf(&VAR_17, \";%08x\", (unsigned)rpmtsGetTid(VAR_0));\n\n    /* COMMENT_1 */\n    VAR_6 = rpmfilesIter(VAR_2, VAR_20);\n    while (!VAR_9 && (VAR_10 = rpmfiNext(VAR_6)) >= 0) {\n\tstruct filedata_s *VAR_21 = &VAR_18[VAR_10];\n\tif (rpmfiFFlags(VAR_6) & VAR_22)\n            VAR_21->action = VAR_23;\n\telse\n\t    VAR_21->action = rpmfsGetAction(VAR_7, VAR_10);\n\tVAR_21->skip = XFA_SKIPPING(VAR_21->action);\n\tVAR_21->setmeta = 1;\n\tif (XFA_CREATING(VAR_21->action) && !S_ISDIR(rpmfiFMode(VAR_6)))\n\t    VAR_21->suffix = VAR_17;\n\tVAR_21->fpath = fsmFsPath(VAR_6, VAR_21->suffix);\n\n\t/* COMMENT_2 */\n\tVAR_9 = rpmfiStat(VAR_6, 1, &VAR_21->sb);\n\n\tsetFileState(VAR_7, VAR_10);\n\tfsmDebug(VAR_21->fpath, VAR_21->action, &VAR_21->sb);\n\n\t/* COMMENT_3 */\n\tVAR_9 = rpmpluginsCallFsmFilePre(VAR_8, VAR_6, VAR_21->fpath,\n\t\t\t\t      VAR_21->sb.st_mode, VAR_21->action);\n\tVAR_21->stage = VAR_24;\n    }\n    VAR_6 = rpmfiFree(VAR_6);\n\n    if (VAR_9)\n\tgoto exit;\n\n    if (rpmteType(VAR_1) == VAR_25)\n\tVAR_6 = rpmfiNewArchiveReader(VAR_5, VAR_2, VAR_26);\n    else\n\tVAR_6 = rpmfilesIter(VAR_2, VAR_20);\n    if (VAR_6 == NULL) {\n        VAR_9 = VAR_27;\n        goto exit;\n    }\n\n    /* COMMENT_4 */\n    if (!VAR_9)\n\tVAR_9 = fsmMkdirs(VAR_2, VAR_7, VAR_8);\n\n    /* COMMENT_5 */\n    while (!VAR_9 && (VAR_10 = rpmfiNext(VAR_6)) >= 0) {\n\tstruct filedata_s *VAR_21 = &VAR_18[VAR_10];\n\n        if (!VAR_21->skip) {\n\t    /* COMMENT_6 */\n\t    if (!VAR_21->suffix) {\n\t\tVAR_9 = fsmBackup(VAR_6, VAR_21->action);\n\t    }\n\t    /* COMMENT_7 */\n\t    if (!VAR_21->suffix) {\n\t\tif (VAR_21->action == VAR_28) {\n\t\t    struct stat VAR_29;\n\t\t    VAR_9 = fsmStat(VAR_21->fpath, 1, &VAR_29);\n\t\t} else {\n\t\t    VAR_9 = fsmVerify(VAR_21->fpath, VAR_6);\n\t\t}\n\t    } else {\n\t\tVAR_9 = VAR_30;\n\t    }\n\n\t    /* COMMENT_8 */\n\t    if (VAR_9 == VAR_30 && VAR_21->action == VAR_28) {\n\t\trpmlog(VAR_31, \"file %s vanished unexpectedly\\n\",\n\t\t\tVAR_21->fpath);\n\t\tVAR_21->action = VAR_32;\n\t\tfsmDebug(VAR_21->fpath, VAR_21->action, &VAR_21->sb);\n\t    }\n\n\t    /* COMMENT_9 */\n\t    if (VAR_21->action == VAR_28)\n\t\tcontinue;\n\n            if (S_ISREG(VAR_21->sb.st_mode)) {\n\t\tif (VAR_9 == VAR_30) {\n\t\t    VAR_9 = fsmMkfile(VAR_6, VAR_21, VAR_2, VAR_3, VAR_12,\n\t\t\t\t   &VAR_19, &VAR_16);\n\t\t}\n            } else if (S_ISDIR(VAR_21->sb.st_mode)) {\n                if (VAR_9 == VAR_30) {\n                    mode_t VAR_33 = VAR_21->sb.st_mode;\n                    VAR_33 &= ~07777;\n                    VAR_33 |=  00700;\n                    VAR_9 = fsmMkdir(VAR_21->fpath, VAR_33);\n                }\n            } else if (S_ISLNK(VAR_21->sb.st_mode)) {\n\t\tif (VAR_9 == VAR_30) {\n\t\t    VAR_9 = fsmSymlink(rpmfiFLink(VAR_6), VAR_21->fpath);\n\t\t}\n            } else if (S_ISFIFO(VAR_21->sb.st_mode)) {\n                /* COMMENT_10 */\n                if (VAR_9 == VAR_30) {\n                    VAR_9 = fsmMkfifo(VAR_21->fpath, 0000);\n                }\n            } else if (S_ISCHR(VAR_21->sb.st_mode) ||\n                       S_ISBLK(VAR_21->sb.st_mode) ||\n                       S_ISSOCK(VAR_21->sb.st_mode))\n            {\n                if (VAR_9 == VAR_30) {\n                    VAR_9 = fsmMknod(VAR_21->fpath, VAR_21->sb.st_mode, VAR_21->sb.st_rdev);\n                }\n            } else {\n                /* COMMENT_11 */\n                if (!IS_DEV_LOG(VAR_21->fpath))\n                    VAR_9 = VAR_34;\n            }\n\t} else if (VAR_19 && rpmfiArchiveHasContent(VAR_6)) {\n\t    /* COMMENT_12 */\n                                                                    \n                                                                   \n                                                                  \n                \n        \n\t    VAR_9 = fsmMkfile(VAR_6, VAR_19, VAR_2, VAR_3, VAR_12,\n\t\t\t   &VAR_19, &VAR_16);\n\t}\n\n\t/* COMMENT_18 */\n\tif (VAR_9)\n\t    *VAR_4 = xstrdup(VAR_21->fpath);\n\telse\n\t    rpmpsmNotify(VAR_3, VAR_35, rpmfiArchiveTell(VAR_6));\n\tVAR_21->stage = VAR_36;\n    }\n    VAR_6 = rpmfiFree(VAR_6);\n\n    if (!VAR_9 && VAR_10 < 0 && VAR_10 != VAR_37)\n\tVAR_9 = VAR_10;\n\n    /* COMMENT_19 */\n    VAR_6 = rpmfilesIter(VAR_2, VAR_20);\n    while (!VAR_9 && (VAR_10 = rpmfiNext(VAR_6)) >= 0) {\n\tstruct filedata_s *VAR_21 = &VAR_18[VAR_10];\n\tif (!VAR_21->skip && VAR_21->setmeta) {\n\t    VAR_9 = fsmSetmeta(VAR_21->fpath, VAR_6, VAR_8, VAR_21->action,\n\t\t\t    &VAR_21->sb, VAR_14);\n\t}\n\tif (VAR_9)\n\t    *VAR_4 = xstrdup(VAR_21->fpath);\n\tVAR_21->stage = VAR_38;\n    }\n    VAR_6 = rpmfiFree(VAR_6);\n\n    /* COMMENT_20 */\n    VAR_6 = rpmfilesIter(VAR_2, VAR_20);\n    while (!VAR_9 && (VAR_10 = rpmfiNext(VAR_6)) >= 0) {\n\tstruct filedata_s *VAR_21 = &VAR_18[VAR_10];\n\n\tif (!VAR_21->skip) {\n\t    /* COMMENT_21 */\n\t    if (!VAR_9 && VAR_21->suffix)\n\t\tVAR_9 = fsmBackup(VAR_6, VAR_21->action);\n\n\t    if (!VAR_9)\n\t\tVAR_9 = fsmCommit(&VAR_21->fpath, VAR_6, VAR_21->action, VAR_21->suffix);\n\n\t    if (!VAR_9)\n\t\tVAR_21->stage = VAR_39;\n\t    else\n\t\t*VAR_4 = xstrdup(VAR_21->fpath);\n\t}\n    }\n    VAR_6 = rpmfiFree(VAR_6);\n\n    /* COMMENT_22 */\n    VAR_6 = rpmfilesIter(VAR_2, VAR_40);\n    while ((VAR_10 = rpmfiNext(VAR_6)) >= 0) {\n\tstruct filedata_s *VAR_21 = &VAR_18[VAR_10];\n\t/* COMMENT_23 */\n\tif (VAR_21->stage) {\n\t    rpmpluginsCallFsmFilePost(VAR_8, VAR_6, VAR_21->fpath,\n\t\t\t\t      VAR_21->sb.st_mode, VAR_21->action, VAR_9);\n\t}\n\n\t/* COMMENT_24 */\n\tif (VAR_9 && VAR_21->stage > VAR_41 && !VAR_21->skip) {\n\t    (void) fsmRemove(VAR_21->fpath, VAR_21->sb.st_mode);\n\t}\n    }\n\n    rpmswAdd(rpmtsOp(VAR_0, VAR_42), fdOp(VAR_5, VAR_43));\n    rpmswAdd(rpmtsOp(VAR_0, VAR_44), fdOp(VAR_5, VAR_45));\n\nexit:\n    VAR_6 = rpmfiFree(VAR_6);\n    Fclose(VAR_5);\n    free(VAR_17);\n    for (int VAR_46 = 0; VAR_46 < VAR_11; VAR_46++)\n\tfree(VAR_18[VAR_46].fpath);\n    free(VAR_18);\n\n    return VAR_9;\n}",
  "func_graph_path_before": "rpm-software-management/rpm/96ec957e281220f8e137a2d5eb23b83a6377d556/fsm.c/vul/before/0.json",
  "func": "int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,\n              rpmpsm psm, char ** failedFile)\n{\n    FD_t payload = rpmtePayload(te);\n    rpmfi fi = NULL;\n    rpmfs fs = rpmteGetFileStates(te);\n    rpmPlugins plugins = rpmtsPlugins(ts);\n    int rc = 0;\n    int fx = -1;\n    int fc = rpmfilesFC(files);\n    int nodigest = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOFILEDIGEST) ? 1 : 0;\n    int nofcaps = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOCAPS) ? 1 : 0;\n    FD_t firstlinkfile = NULL;\n    char *tid = NULL;\n    struct filedata_s *fdata = xcalloc(fc, sizeof(*fdata));\n    struct filedata_s *firstlink = NULL;\n    struct diriter_s di = { -1 };\n\n    /* transaction id used for temporary path suffix while installing */\n    rasprintf(&tid, \";%08x\", (unsigned)rpmtsGetTid(ts));\n\n    /* Collect state data for the whole operation */\n    fi = rpmfilesIter(files, RPMFI_ITER_FWD);\n    while (!rc && (fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\tif (rpmfiFFlags(fi) & RPMFILE_GHOST)\n            fp->action = FA_SKIP;\n\telse\n\t    fp->action = rpmfsGetAction(fs, fx);\n\tfp->skip = XFA_SKIPPING(fp->action);\n\tfp->setmeta = 1;\n\tif (XFA_CREATING(fp->action) && !S_ISDIR(rpmfiFMode(fi)))\n\t    fp->suffix = tid;\n\tfp->fpath = fsmFsPath(fi, fp->suffix);\n\n\t/* Remap file perms, owner, and group. */\n\trc = rpmfiStat(fi, 1, &fp->sb);\n\n\tsetFileState(fs, fx);\n\tfsmDebug(fp->fpath, fp->action, &fp->sb);\n\n\t/* Run fsm file pre hook for all plugins */\n\trc = rpmpluginsCallFsmFilePre(plugins, fi, fp->fpath,\n\t\t\t\t      fp->sb.st_mode, fp->action);\n\tfp->stage = FILE_PRE;\n    }\n    fi = rpmfiFree(fi);\n\n    if (rc)\n\tgoto exit;\n\n    if (rpmteType(te) == TR_ADDED)\n\tfi = rpmfiNewArchiveReader(payload, files, RPMFI_ITER_READ_ARCHIVE);\n    else\n\tfi = rpmfilesIter(files, RPMFI_ITER_FWD);\n    if (fi == NULL) {\n        rc = RPMERR_BAD_MAGIC;\n        goto exit;\n    }\n    rpmfiSetOnChdir(fi, onChdir, &di);\n\n    /* Detect and create directories not explicitly in package. */\n    if (!rc)\n\trc = fsmMkdirs(files, fs, plugins);\n\n    /* Process the payload */\n    while (!rc && (fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\n        if (!fp->skip) {\n\t    /* Directories replacing something need early backup */\n\t    if (!fp->suffix) {\n\t\trc = fsmBackup(fi, fp->action);\n\t    }\n\n\t    if (di.dirfd == -1) {\n\t\tdi.dirfd = ensureDir(plugins, rpmfiDN(fi), 0,\n\t\t\t\t    (fp->action == FA_CREATE));\n\t\tif (di.dirfd == -1) {\n\t\t    rc = RPMERR_OPEN_FAILED;\n\t\t    break;\n\t\t}\n\t    }\n\n\t    /* Assume file does't exist when tmp suffix is in use */\n\t    if (!fp->suffix) {\n\t\tif (fp->action == FA_TOUCH) {\n\t\t    struct stat sb;\n\t\t    rc = fsmStat(fp->fpath, 1, &sb);\n\t\t} else {\n\t\t    rc = fsmVerify(fp->fpath, fi);\n\t\t}\n\t    } else {\n\t\trc = RPMERR_ENOENT;\n\t    }\n\n\t    /* See if the file was removed while our attention was elsewhere */\n\t    if (rc == RPMERR_ENOENT && fp->action == FA_TOUCH) {\n\t\trpmlog(RPMLOG_DEBUG, \"file %s vanished unexpectedly\\n\",\n\t\t\tfp->fpath);\n\t\tfp->action = FA_CREATE;\n\t\tfsmDebug(fp->fpath, fp->action, &fp->sb);\n\t    }\n\n\t    /* When touching we don't need any of this... */\n\t    if (fp->action == FA_TOUCH)\n\t\tcontinue;\n\n            if (S_ISREG(fp->sb.st_mode)) {\n\t\tif (rc == RPMERR_ENOENT) {\n\t\t    rc = fsmMkfile(fi, fp, files, psm, nodigest,\n\t\t\t\t   &firstlink, &firstlinkfile);\n\t\t}\n            } else if (S_ISDIR(fp->sb.st_mode)) {\n                if (rc == RPMERR_ENOENT) {\n                    mode_t mode = fp->sb.st_mode;\n                    mode &= ~07777;\n                    mode |=  00700;\n                    rc = fsmMkdir(di.dirfd, fp->fpath, mode);\n                }\n            } else if (S_ISLNK(fp->sb.st_mode)) {\n\t\tif (rc == RPMERR_ENOENT) {\n\t\t    rc = fsmSymlink(rpmfiFLink(fi), fp->fpath);\n\t\t}\n            } else if (S_ISFIFO(fp->sb.st_mode)) {\n                /* This mimics cpio S_ISSOCK() behavior but probably isn't right */\n                if (rc == RPMERR_ENOENT) {\n                    rc = fsmMkfifo(fp->fpath, 0000);\n                }\n            } else if (S_ISCHR(fp->sb.st_mode) ||\n                       S_ISBLK(fp->sb.st_mode) ||\n                       S_ISSOCK(fp->sb.st_mode))\n            {\n                if (rc == RPMERR_ENOENT) {\n                    rc = fsmMknod(fp->fpath, fp->sb.st_mode, fp->sb.st_rdev);\n                }\n            } else {\n                /* XXX Special case /dev/log, which shouldn't be packaged anyways */\n                if (!IS_DEV_LOG(fp->fpath))\n                    rc = RPMERR_UNKNOWN_FILETYPE;\n            }\n\t} else if (firstlink && rpmfiArchiveHasContent(fi)) {\n\t    /*\n\t     * Tricksy case: this file is a being skipped, but it's part of\n\t     * a hardlinked set and has the actual content linked with it.\n\t     * Write the content to the first non-skipped file of the set\n\t     * instead.\n\t     */\n\t    rc = fsmMkfile(fi, firstlink, files, psm, nodigest,\n\t\t\t   &firstlink, &firstlinkfile);\n\t}\n\n\t/* Notify on success. */\n\tif (rc)\n\t    *failedFile = xstrdup(fp->fpath);\n\telse\n\t    rpmpsmNotify(psm, RPMCALLBACK_INST_PROGRESS, rpmfiArchiveTell(fi));\n\tfp->stage = FILE_UNPACK;\n    }\n    fi = rpmfiFree(fi);\n    close(di.dirfd);\n    di.dirfd = -1;\n\n    if (!rc && fx < 0 && fx != RPMERR_ITER_END)\n\trc = fx;\n\n    /* Set permissions, timestamps etc for non-hardlink entries */\n    fi = rpmfilesIter(files, RPMFI_ITER_FWD);\n    while (!rc && (fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\tif (!fp->skip && fp->setmeta) {\n\t    rc = fsmSetmeta(fp->fpath, fi, plugins, fp->action,\n\t\t\t    &fp->sb, nofcaps);\n\t}\n\tif (rc)\n\t    *failedFile = xstrdup(fp->fpath);\n\tfp->stage = FILE_PREP;\n    }\n    fi = rpmfiFree(fi);\n\n    /* If all went well, commit files to final destination */\n    fi = rpmfilesIter(files, RPMFI_ITER_FWD);\n    while (!rc && (fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\n\tif (!fp->skip) {\n\t    /* Backup file if needed. Directories are handled earlier */\n\t    if (!rc && fp->suffix)\n\t\trc = fsmBackup(fi, fp->action);\n\n\t    if (!rc)\n\t\trc = fsmCommit(&fp->fpath, fi, fp->action, fp->suffix);\n\n\t    if (!rc)\n\t\tfp->stage = FILE_COMMIT;\n\t    else\n\t\t*failedFile = xstrdup(fp->fpath);\n\t}\n    }\n    fi = rpmfiFree(fi);\n\n    /* Walk backwards in case we need to erase */\n    fi = rpmfilesIter(files, RPMFI_ITER_BACK);\n    while ((fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\t/* Run fsm file post hook for all plugins for all processed files */\n\tif (fp->stage) {\n\t    rpmpluginsCallFsmFilePost(plugins, fi, fp->fpath,\n\t\t\t\t      fp->sb.st_mode, fp->action, rc);\n\t}\n\n\t/* On failure, erase non-committed files */\n\tif (rc && fp->stage > FILE_NONE && !fp->skip) {\n\t    (void) fsmRemove(fp->fpath, fp->sb.st_mode);\n\t}\n    }\n\n    rpmswAdd(rpmtsOp(ts, RPMTS_OP_UNCOMPRESS), fdOp(payload, FDSTAT_READ));\n    rpmswAdd(rpmtsOp(ts, RPMTS_OP_DIGEST), fdOp(payload, FDSTAT_DIGEST));\n\nexit:\n    fi = rpmfiFree(fi);\n    Fclose(payload);\n    free(tid);\n    for (int i = 0; i < fc; i++)\n\tfree(fdata[i].fpath);\n    free(fdata);\n\n    return rc;\n}",
  "abstract_func": "int rpmPackageFilesInstall(rpmts VAR_0, rpmte VAR_1, rpmfiles VAR_2,\n              rpmpsm VAR_3, char ** VAR_4)\n{\n    FD_t VAR_5 = rpmtePayload(VAR_1);\n    rpmfi VAR_6 = NULL;\n    rpmfs VAR_7 = rpmteGetFileStates(VAR_1);\n    rpmPlugins VAR_8 = rpmtsPlugins(VAR_0);\n    int VAR_9 = 0;\n    int VAR_10 = -1;\n    int VAR_11 = rpmfilesFC(VAR_2);\n    int VAR_12 = (rpmtsFlags(VAR_0) & VAR_13) ? 1 : 0;\n    int VAR_14 = (rpmtsFlags(VAR_0) & VAR_15) ? 1 : 0;\n    FD_t VAR_16 = NULL;\n    char *VAR_17 = NULL;\n    struct filedata_s *VAR_18 = xcalloc(VAR_11, sizeof(*VAR_18));\n    struct filedata_s *VAR_19 = NULL;\n    struct diriter_s VAR_20 = { -1 };\n\n    /* COMMENT_0 */\n    rasprintf(&VAR_17, \";%08x\", (unsigned)rpmtsGetTid(VAR_0));\n\n    /* COMMENT_1 */\n    VAR_6 = rpmfilesIter(VAR_2, VAR_21);\n    while (!VAR_9 && (VAR_10 = rpmfiNext(VAR_6)) >= 0) {\n\tstruct filedata_s *VAR_22 = &VAR_18[VAR_10];\n\tif (rpmfiFFlags(VAR_6) & VAR_23)\n            VAR_22->action = VAR_24;\n\telse\n\t    VAR_22->action = rpmfsGetAction(VAR_7, VAR_10);\n\tVAR_22->skip = XFA_SKIPPING(VAR_22->action);\n\tVAR_22->setmeta = 1;\n\tif (XFA_CREATING(VAR_22->action) && !S_ISDIR(rpmfiFMode(VAR_6)))\n\t    VAR_22->suffix = VAR_17;\n\tVAR_22->fpath = fsmFsPath(VAR_6, VAR_22->suffix);\n\n\t/* COMMENT_2 */\n\tVAR_9 = rpmfiStat(VAR_6, 1, &VAR_22->sb);\n\n\tsetFileState(VAR_7, VAR_10);\n\tfsmDebug(VAR_22->fpath, VAR_22->action, &VAR_22->sb);\n\n\t/* COMMENT_3 */\n\tVAR_9 = rpmpluginsCallFsmFilePre(VAR_8, VAR_6, VAR_22->fpath,\n\t\t\t\t      VAR_22->sb.st_mode, VAR_22->action);\n\tVAR_22->stage = VAR_25;\n    }\n    VAR_6 = rpmfiFree(VAR_6);\n\n    if (VAR_9)\n\tgoto exit;\n\n    if (rpmteType(VAR_1) == VAR_26)\n\tVAR_6 = rpmfiNewArchiveReader(VAR_5, VAR_2, VAR_27);\n    else\n\tVAR_6 = rpmfilesIter(VAR_2, VAR_21);\n    if (VAR_6 == NULL) {\n        VAR_9 = VAR_28;\n        goto exit;\n    }\n    rpmfiSetOnChdir(VAR_6, VAR_29, &VAR_20);\n\n    /* COMMENT_4 */\n    if (!VAR_9)\n\tVAR_9 = fsmMkdirs(VAR_2, VAR_7, VAR_8);\n\n    /* COMMENT_5 */\n    while (!VAR_9 && (VAR_10 = rpmfiNext(VAR_6)) >= 0) {\n\tstruct filedata_s *VAR_22 = &VAR_18[VAR_10];\n\n        if (!VAR_22->skip) {\n\t    /* COMMENT_6 */\n\t    if (!VAR_22->suffix) {\n\t\tVAR_9 = fsmBackup(VAR_6, VAR_22->action);\n\t    }\n\n\t    if (VAR_20.dirfd == -1) {\n\t\tVAR_20.dirfd = ensureDir(VAR_8, rpmfiDN(VAR_6), 0,\n\t\t\t\t    (VAR_22->action == VAR_30));\n\t\tif (VAR_20.dirfd == -1) {\n\t\t    VAR_9 = VAR_31;\n\t\t    break;\n\t\t}\n\t    }\n\n\t    /* COMMENT_7 */\n\t    if (!VAR_22->suffix) {\n\t\tif (VAR_22->action == VAR_32) {\n\t\t    struct stat VAR_33;\n\t\t    VAR_9 = fsmStat(VAR_22->fpath, 1, &VAR_33);\n\t\t} else {\n\t\t    VAR_9 = fsmVerify(VAR_22->fpath, VAR_6);\n\t\t}\n\t    } else {\n\t\tVAR_9 = VAR_34;\n\t    }\n\n\t    /* COMMENT_8 */\n\t    if (VAR_9 == VAR_34 && VAR_22->action == VAR_32) {\n\t\trpmlog(VAR_35, \"file %s vanished unexpectedly\\n\",\n\t\t\tVAR_22->fpath);\n\t\tVAR_22->action = VAR_30;\n\t\tfsmDebug(VAR_22->fpath, VAR_22->action, &VAR_22->sb);\n\t    }\n\n\t    /* COMMENT_9 */\n\t    if (VAR_22->action == VAR_32)\n\t\tcontinue;\n\n            if (S_ISREG(VAR_22->sb.st_mode)) {\n\t\tif (VAR_9 == VAR_34) {\n\t\t    VAR_9 = fsmMkfile(VAR_6, VAR_22, VAR_2, VAR_3, VAR_12,\n\t\t\t\t   &VAR_19, &VAR_16);\n\t\t}\n            } else if (S_ISDIR(VAR_22->sb.st_mode)) {\n                if (VAR_9 == VAR_34) {\n                    mode_t VAR_36 = VAR_22->sb.st_mode;\n                    VAR_36 &= ~07777;\n                    VAR_36 |=  00700;\n                    VAR_9 = fsmMkdir(VAR_20.dirfd, VAR_22->fpath, VAR_36);\n                }\n            } else if (S_ISLNK(VAR_22->sb.st_mode)) {\n\t\tif (VAR_9 == VAR_34) {\n\t\t    VAR_9 = fsmSymlink(rpmfiFLink(VAR_6), VAR_22->fpath);\n\t\t}\n            } else if (S_ISFIFO(VAR_22->sb.st_mode)) {\n                /* COMMENT_10 */\n                if (VAR_9 == VAR_34) {\n                    VAR_9 = fsmMkfifo(VAR_22->fpath, 0000);\n                }\n            } else if (S_ISCHR(VAR_22->sb.st_mode) ||\n                       S_ISBLK(VAR_22->sb.st_mode) ||\n                       S_ISSOCK(VAR_22->sb.st_mode))\n            {\n                if (VAR_9 == VAR_34) {\n                    VAR_9 = fsmMknod(VAR_22->fpath, VAR_22->sb.st_mode, VAR_22->sb.st_rdev);\n                }\n            } else {\n                /* COMMENT_11 */\n                if (!IS_DEV_LOG(VAR_22->fpath))\n                    VAR_9 = VAR_37;\n            }\n\t} else if (VAR_19 && rpmfiArchiveHasContent(VAR_6)) {\n\t    /* COMMENT_12 */\n                                                                    \n                                                                   \n                                                                  \n                \n        \n\t    VAR_9 = fsmMkfile(VAR_6, VAR_19, VAR_2, VAR_3, VAR_12,\n\t\t\t   &VAR_19, &VAR_16);\n\t}\n\n\t/* COMMENT_18 */\n\tif (VAR_9)\n\t    *VAR_4 = xstrdup(VAR_22->fpath);\n\telse\n\t    rpmpsmNotify(VAR_3, VAR_38, rpmfiArchiveTell(VAR_6));\n\tVAR_22->stage = VAR_39;\n    }\n    VAR_6 = rpmfiFree(VAR_6);\n    close(VAR_20.dirfd);\n    VAR_20.dirfd = -1;\n\n    if (!VAR_9 && VAR_10 < 0 && VAR_10 != VAR_40)\n\tVAR_9 = VAR_10;\n\n    /* COMMENT_19 */\n    VAR_6 = rpmfilesIter(VAR_2, VAR_21);\n    while (!VAR_9 && (VAR_10 = rpmfiNext(VAR_6)) >= 0) {\n\tstruct filedata_s *VAR_22 = &VAR_18[VAR_10];\n\tif (!VAR_22->skip && VAR_22->setmeta) {\n\t    VAR_9 = fsmSetmeta(VAR_22->fpath, VAR_6, VAR_8, VAR_22->action,\n\t\t\t    &VAR_22->sb, VAR_14);\n\t}\n\tif (VAR_9)\n\t    *VAR_4 = xstrdup(VAR_22->fpath);\n\tVAR_22->stage = VAR_41;\n    }\n    VAR_6 = rpmfiFree(VAR_6);\n\n    /* COMMENT_20 */\n    VAR_6 = rpmfilesIter(VAR_2, VAR_21);\n    while (!VAR_9 && (VAR_10 = rpmfiNext(VAR_6)) >= 0) {\n\tstruct filedata_s *VAR_22 = &VAR_18[VAR_10];\n\n\tif (!VAR_22->skip) {\n\t    /* COMMENT_21 */\n\t    if (!VAR_9 && VAR_22->suffix)\n\t\tVAR_9 = fsmBackup(VAR_6, VAR_22->action);\n\n\t    if (!VAR_9)\n\t\tVAR_9 = fsmCommit(&VAR_22->fpath, VAR_6, VAR_22->action, VAR_22->suffix);\n\n\t    if (!VAR_9)\n\t\tVAR_22->stage = VAR_42;\n\t    else\n\t\t*VAR_4 = xstrdup(VAR_22->fpath);\n\t}\n    }\n    VAR_6 = rpmfiFree(VAR_6);\n\n    /* COMMENT_22 */\n    VAR_6 = rpmfilesIter(VAR_2, VAR_43);\n    while ((VAR_10 = rpmfiNext(VAR_6)) >= 0) {\n\tstruct filedata_s *VAR_22 = &VAR_18[VAR_10];\n\t/* COMMENT_23 */\n\tif (VAR_22->stage) {\n\t    rpmpluginsCallFsmFilePost(VAR_8, VAR_6, VAR_22->fpath,\n\t\t\t\t      VAR_22->sb.st_mode, VAR_22->action, VAR_9);\n\t}\n\n\t/* COMMENT_24 */\n\tif (VAR_9 && VAR_22->stage > VAR_44 && !VAR_22->skip) {\n\t    (void) fsmRemove(VAR_22->fpath, VAR_22->sb.st_mode);\n\t}\n    }\n\n    rpmswAdd(rpmtsOp(VAR_0, VAR_45), fdOp(VAR_5, VAR_46));\n    rpmswAdd(rpmtsOp(VAR_0, VAR_47), fdOp(VAR_5, VAR_48));\n\nexit:\n    VAR_6 = rpmfiFree(VAR_6);\n    Fclose(VAR_5);\n    free(VAR_17);\n    for (int VAR_49 = 0; VAR_49 < VAR_11; VAR_49++)\n\tfree(VAR_18[VAR_49].fpath);\n    free(VAR_18);\n\n    return VAR_9;\n}",
  "func_graph_path": "rpm-software-management/rpm/96ec957e281220f8e137a2d5eb23b83a6377d556/fsm.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -14,6 +14,7 @@\n     char *tid = NULL;\n     struct filedata_s *fdata = xcalloc(fc, sizeof(*fdata));\n     struct filedata_s *firstlink = NULL;\n+    struct diriter_s di = { -1 };\n \n     /* transaction id used for temporary path suffix while installing */\n     rasprintf(&tid, \";%08x\", (unsigned)rpmtsGetTid(ts));\n@@ -56,6 +57,7 @@\n         rc = RPMERR_BAD_MAGIC;\n         goto exit;\n     }\n+    rpmfiSetOnChdir(fi, onChdir, &di);\n \n     /* Detect and create directories not explicitly in package. */\n     if (!rc)\n@@ -70,6 +72,16 @@\n \t    if (!fp->suffix) {\n \t\trc = fsmBackup(fi, fp->action);\n \t    }\n+\n+\t    if (di.dirfd == -1) {\n+\t\tdi.dirfd = ensureDir(plugins, rpmfiDN(fi), 0,\n+\t\t\t\t    (fp->action == FA_CREATE));\n+\t\tif (di.dirfd == -1) {\n+\t\t    rc = RPMERR_OPEN_FAILED;\n+\t\t    break;\n+\t\t}\n+\t    }\n+\n \t    /* Assume file does't exist when tmp suffix is in use */\n \t    if (!fp->suffix) {\n \t\tif (fp->action == FA_TOUCH) {\n@@ -104,7 +116,7 @@\n                     mode_t mode = fp->sb.st_mode;\n                     mode &= ~07777;\n                     mode |=  00700;\n-                    rc = fsmMkdir(fp->fpath, mode);\n+                    rc = fsmMkdir(di.dirfd, fp->fpath, mode);\n                 }\n             } else if (S_ISLNK(fp->sb.st_mode)) {\n \t\tif (rc == RPMERR_ENOENT) {\n@@ -146,6 +158,8 @@\n \tfp->stage = FILE_UNPACK;\n     }\n     fi = rpmfiFree(fi);\n+    close(di.dirfd);\n+    di.dirfd = -1;\n \n     if (!rc && fx < 0 && fx != RPMERR_ITER_END)\n \trc = fx;",
  "diff_line_info": {
    "deleted_lines": [
      "                    rc = fsmMkdir(fp->fpath, mode);"
    ],
    "added_lines": [
      "    struct diriter_s di = { -1 };",
      "    rpmfiSetOnChdir(fi, onChdir, &di);",
      "",
      "\t    if (di.dirfd == -1) {",
      "\t\tdi.dirfd = ensureDir(plugins, rpmfiDN(fi), 0,",
      "\t\t\t\t    (fp->action == FA_CREATE));",
      "\t\tif (di.dirfd == -1) {",
      "\t\t    rc = RPMERR_OPEN_FAILED;",
      "\t\t    break;",
      "\t\t}",
      "\t    }",
      "",
      "                    rc = fsmMkdir(di.dirfd, fp->fpath, mode);",
      "    close(di.dirfd);",
      "    di.dirfd = -1;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/rpm-software-management/rpm/pull/1919",
  "description": {
    "pr_info": {
      "title": "First steps towards fixing the symlink CVEs",
      "number": 1919
    },
    "comment": [
      "Details in commits, but basically fixes CVE-2021-35939 and lays down some necessary infrastructure for next steps in securing down our file operations.",
      "It should be noted (probably in the commit message too) that as these symlink CVE's overlap and interact in various ways, this does not fully fix CVE-2021-35939 as the directory tracking does not cover all our installation steps yet. Plugging all the holes requires converting *all* of FSM to the *at() family of calls plus fd-based ops where possible, so this really is just the first step of many to come.",
      "I'm quite aware of Linux having all manner of fancy extensions available.\r\nRpm is portable software and we need to fix this stuff using what's available in POSIX, utilizing non-portable extensions would only make things far more complicated rather than help. There's enough complexities to deal with as it is, thank you very much.",
      "This is now using fd or dirfd+basename for file ops within the fsm, as much as possible. Plugins pose special problems as external libraries generally dont support dirfd+basename style operation, but may still need to operate on symlinks so we're stuck with \"insecure\" absolute paths there, for now at least.\r\n\r\nI'm seeing a couple of install glitches on fresh chroot install still, but it's getting close now.\r\nOf course a change this big and drastic *will* have bugs in it initially, I have no illusions about that.\r\n\r\n(edit: hmph, the test-suite was passing just a minute ago...)",
      "Okay, test-suite + all my local tests (install to empty chroot etc) pass now :partying_face: ",
      "> This is now using fd or dirfd+basename for file ops within the fsm, as much as possible. Plugins pose special problems as external libraries generally dont support dirfd+basename style operation, but may still need to operate on symlinks so we're stuck with \"insecure\" absolute paths there, for now at least.\r\n\r\nCute (but non-portable) trick: use paths of the form `/dev/fd/$FDNUM/something`.  Works at least on Linux.",
      "Yeah once we have the basics working and optimized to a reasonable degree we can start looking at utilizing various OS-specific extensions. The gotcha with those is to find ways to provide extra functionality in the specific OS'es *without* introducing multiple codepaths (which will inevitably bitrot) to accomplish the same thing.",
      "Anyway...\r\n\r\nThere will inevitably be bugs in this all, and since the test-suite covers only so much the best way to find the rest is real-world testing. And sitting in a branch does little to achieve that, so I'm merging this as is now.\r\n\r\nDanger Will Robinson, if you're in the habbit of running rpm daily snapshots then you'll want to stay alert for a while.",
      "Oh, and to make it absolutely clear: we're nowhere *near* done with this, I just want to get this bulk of change over with so we can concentrate with the finer nuances.",
      "@pmatilai  Thanks for fixing these CVEs.  And I want to double check with you that \r\ndoes these 32 commits in this pull request fully fix CVE-2021-35937, CVE-2021-35938, CVE-2021-35939? \r\nAny plan to porting it to 4.17.x branch?",
      "There will be no backports."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0  \n\nThe patch addresses CVE-2021-35939 by adding symlink validation, consistent with its security intent and code modifications for safer file operations."
}