{
  "cve_id": "CVE-2020-24265",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "appneta/tcpreplay",
  "commit_msg": "Bug #616 add checks for datalen for DLT_JUNIPER_ETHER\n\nAlso did some fixes to Juniper Ethernet protocols to fix some bugs\nand support various types of Juniper Ethernet protocol types. Used\nWireshark sources to figure out all the different packet types that\nJuniper uses.\n\nUnable to test all types because of lack of JNPER DLT pcaps.\n\nAlso applied a fix for DLT_RAW to prevent similar issues.",
  "commit_hash": "8323a7fe1e47d562ebf384aa99633e3df74a01c4",
  "git_url": "https://github.com/appneta/tcpreplay/commit/8323a7fe1e47d562ebf384aa99633e3df74a01c4",
  "file_path": "src/common/get.c",
  "func_name": "get_l2len",
  "func_before": "int\nget_l2len(const u_char *pktdata, const int datalen, const int datalink)\n{\n    int l2_len = 0;\n\n    assert(pktdata);\n    assert(datalen);\n\n    switch (datalink) {\n    case DLT_RAW:\n        /* pktdata IS the ip header! */\n        break;\n\n    case DLT_JUNIPER_ETHER:\n        if (datalen >= 5) {\n            l2_len = -1;\n            break;\n        }\n\n        if (memcmp(pktdata, \"MGC\", 3))\n            warnx(\"No Magic Number found: %s (0x%x)\",\n                 pcap_datalink_val_to_description(datalink), datalink);\n\n        if ((pktdata[3] & 0x80) == 0x80) {\n            l2_len = ntohs(*((uint16_t*)&pktdata[4]));\n            l2_len += 6;\n        } else {\n            l2_len = 4; /* no header extensions */\n        }\n\n        /* fallthrough */\n    case DLT_EN10MB:\n        if ((size_t)datalen >= sizeof(eth_hdr_t) + l2_len) {\n            uint16_t ether_type = ntohs(((eth_hdr_t*)(pktdata + l2_len))->ether_type);\n\n            l2_len += sizeof(eth_hdr_t);\n            while (ether_type == ETHERTYPE_VLAN) {\n                if ((size_t)datalen < sizeof(vlan_hdr_t) + l2_len) {\n                    l2_len = -1;\n                    break;\n                }\n                vlan_hdr_t *vlan_hdr = (vlan_hdr_t *)(pktdata + l2_len);\n                ether_type = ntohs(vlan_hdr->vlan_tpid);\n                l2_len += 4;\n            }\n        }\n\n        if (datalen < l2_len)\n            l2_len = -1;\n\n        break;\n\n    case DLT_PPP_SERIAL:\n        if (datalen >= 4) {\n            l2_len = 4;\n        }\n        break;\n\n    case DLT_C_HDLC:\n        if (datalen >= CISCO_HDLC_LEN) {\n            l2_len = CISCO_HDLC_LEN;\n        }\n        break;\n\n    case DLT_LINUX_SLL:\n        if (datalen >= SLL_HDR_LEN) {\n            l2_len = SLL_HDR_LEN;\n        }\n        break;\n\n    default:\n        errx(-1, \"Unable to process unsupported DLT type: %s (0x%x)\", \n             pcap_datalink_val_to_description(datalink), datalink);\n        return -1; /* we shouldn't get here */\n    }\n\n    return l2_len;\n}",
  "abstract_func_before": "int\nget_l2len(const u_char *VAR_0, const int VAR_1, const int VAR_2)\n{\n    int VAR_3 = 0;\n\n    assert(VAR_0);\n    assert(VAR_1);\n\n    switch (VAR_2) {\n    case VAR_4:\n        /* COMMENT_0 */\n        break;\n\n    case VAR_5:\n        if (VAR_1 >= 5) {\n            VAR_3 = -1;\n            break;\n        }\n\n        if (memcmp(VAR_0, \"MGC\", 3))\n            warnx(\"No Magic Number found: %s (0x%x)\",\n                 pcap_datalink_val_to_description(VAR_2), VAR_2);\n\n        if ((VAR_0[3] & 0x80) == 0x80) {\n            VAR_3 = ntohs(*((uint16_t*)&VAR_0[4]));\n            VAR_3 += 6;\n        } else {\n            VAR_3 = 4; /* COMMENT_1 */\n        }\n\n        /* COMMENT_2 */\n    case VAR_6:\n        if ((size_t)VAR_1 >= sizeof(VAR_7) + VAR_3) {\n            uint16_t VAR_8 = ntohs(((eth_hdr_t*)(VAR_0 + VAR_3))->ether_type);\n\n            VAR_3 += sizeof(eth_hdr_t);\n            while (VAR_8 == VAR_9) {\n                if ((size_t)VAR_1 < sizeof(VAR_10) + VAR_3) {\n                    VAR_3 = -1;\n                    break;\n                }\n                vlan_hdr_t *VAR_11 = (vlan_hdr_t *)(VAR_0 + VAR_3);\n                VAR_8 = ntohs(VAR_11->vlan_tpid);\n                VAR_3 += 4;\n            }\n        }\n\n        if (VAR_1 < VAR_3)\n            VAR_3 = -1;\n\n        break;\n\n    case VAR_12:\n        if (VAR_1 >= 4) {\n            VAR_3 = 4;\n        }\n        break;\n\n    case VAR_13:\n        if (VAR_1 >= VAR_14) {\n            VAR_3 = VAR_14;\n        }\n        break;\n\n    case VAR_15:\n        if (VAR_1 >= VAR_16) {\n            VAR_3 = VAR_16;\n        }\n        break;\n\n    default:\n        errx(-1, \"Unable to process unsupported DLT type: %s (0x%x)\", \n             pcap_datalink_val_to_description(VAR_2), VAR_2);\n        return -1; /* COMMENT_3 */\n    }\n\n    return VAR_3;\n}",
  "func_graph_path_before": "appneta/tcpreplay/8323a7fe1e47d562ebf384aa99633e3df74a01c4/get.c/vul/before/1.json",
  "func": "int\nget_l2len(const u_char *pktdata, const int datalen, const int datalink)\n{\n    int l2_len = 0;\n\n    assert(pktdata);\n    assert(datalen);\n\n    switch (datalink) {\n    case DLT_RAW:\n        /* pktdata IS the ip header! */\n        break;\n\n    case DLT_JUNIPER_ETHER:\n        if (datalen < 4) {\n            l2_len = -1;\n            break;\n        }\n\n        if (memcmp(pktdata, JUNIPER_PCAP_MAGIC, 3)) {\n            warnx(\"No Magic Number found during L2 lookup: %s (0x%x)\",\n                  pcap_datalink_val_to_description(datalink), datalink);\n            l2_len = -1;\n            break;\n        }\n\n        if ((pktdata[3] & JUNIPER_FLAG_NO_L2) == JUNIPER_FLAG_NO_L2) {\n            /* no L2 header present */\n            l2_len = 0;\n            break;\n        }\n\n        if ((pktdata[3] & JUNIPER_FLAG_EXT) == JUNIPER_FLAG_EXT) {\n            if (datalen < 6) {\n                /* datalen too short */\n                l2_len = -1;\n                break;\n            }\n            l2_len = ntohs(*((uint16_t*)&pktdata[4]));\n            l2_len += 6;        /* MGC + flags + ext_total_len */\n        } else {\n            l2_len = 4;         /* MGC + flags */\n        }\n        /* fall through */\n    case DLT_EN10MB:\n        if ((size_t)datalen >= sizeof(eth_hdr_t) + l2_len) {\n            uint16_t ether_type = ntohs(((eth_hdr_t*)(pktdata + l2_len))->ether_type);\n\n            l2_len += sizeof(eth_hdr_t);\n            while (ether_type == ETHERTYPE_VLAN) {\n                if ((size_t)datalen < sizeof(vlan_hdr_t) + l2_len) {\n                    l2_len = -1;\n                    break;\n                }\n                vlan_hdr_t *vlan_hdr = (vlan_hdr_t *)(pktdata + l2_len);\n                ether_type = ntohs(vlan_hdr->vlan_tpid);\n                l2_len += 4;\n            }\n        }\n\n        if (datalen < l2_len)\n            l2_len = -1;\n\n        break;\n\n    case DLT_PPP_SERIAL:\n        if (datalen >= 4) {\n            l2_len = 4;\n        }\n        break;\n\n    case DLT_C_HDLC:\n        if (datalen >= CISCO_HDLC_LEN) {\n            l2_len = CISCO_HDLC_LEN;\n        }\n        break;\n\n    case DLT_LINUX_SLL:\n        if (datalen >= SLL_HDR_LEN) {\n            l2_len = SLL_HDR_LEN;\n        }\n        break;\n\n    default:\n        errx(-1, \"Unable to process unsupported DLT type: %s (0x%x)\", \n             pcap_datalink_val_to_description(datalink), datalink);\n        return -1; /* we shouldn't get here */\n    }\n\n    return l2_len;\n}",
  "abstract_func": "int\nget_l2len(const u_char *VAR_0, const int VAR_1, const int VAR_2)\n{\n    int VAR_3 = 0;\n\n    assert(VAR_0);\n    assert(VAR_1);\n\n    switch (VAR_2) {\n    case VAR_4:\n        /* COMMENT_0 */\n        break;\n\n    case VAR_5:\n        if (VAR_1 < 4) {\n            VAR_3 = -1;\n            break;\n        }\n\n        if (memcmp(VAR_0, VAR_6, 3)) {\n            warnx(\"No Magic Number found during L2 lookup: %s (0x%x)\",\n                  pcap_datalink_val_to_description(VAR_2), VAR_2);\n            VAR_3 = -1;\n            break;\n        }\n\n        if ((VAR_0[3] & VAR_7) == VAR_7) {\n            /* COMMENT_1 */\n            VAR_3 = 0;\n            break;\n        }\n\n        if ((VAR_0[3] & VAR_8) == VAR_8) {\n            if (VAR_1 < 6) {\n                /* COMMENT_2 */\n                VAR_3 = -1;\n                break;\n            }\n            VAR_3 = ntohs(*((uint16_t*)&VAR_0[4]));\n            VAR_3 += 6;        /* COMMENT_3 */\n        } else {\n            VAR_3 = 4;         /* COMMENT_4 */\n        }\n        /* COMMENT_5 */\n    case VAR_9:\n        if ((size_t)VAR_1 >= sizeof(VAR_10) + VAR_3) {\n            uint16_t VAR_11 = ntohs(((eth_hdr_t*)(VAR_0 + VAR_3))->ether_type);\n\n            VAR_3 += sizeof(eth_hdr_t);\n            while (VAR_11 == VAR_12) {\n                if ((size_t)VAR_1 < sizeof(VAR_13) + VAR_3) {\n                    VAR_3 = -1;\n                    break;\n                }\n                vlan_hdr_t *VAR_14 = (vlan_hdr_t *)(VAR_0 + VAR_3);\n                VAR_11 = ntohs(VAR_14->vlan_tpid);\n                VAR_3 += 4;\n            }\n        }\n\n        if (VAR_1 < VAR_3)\n            VAR_3 = -1;\n\n        break;\n\n    case VAR_15:\n        if (VAR_1 >= 4) {\n            VAR_3 = 4;\n        }\n        break;\n\n    case VAR_16:\n        if (VAR_1 >= VAR_17) {\n            VAR_3 = VAR_17;\n        }\n        break;\n\n    case VAR_18:\n        if (VAR_1 >= VAR_19) {\n            VAR_3 = VAR_19;\n        }\n        break;\n\n    default:\n        errx(-1, \"Unable to process unsupported DLT type: %s (0x%x)\", \n             pcap_datalink_val_to_description(VAR_2), VAR_2);\n        return -1; /* COMMENT_6 */\n    }\n\n    return VAR_3;\n}",
  "func_graph_path": "appneta/tcpreplay/8323a7fe1e47d562ebf384aa99633e3df74a01c4/get.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -12,23 +12,36 @@\n         break;\n \n     case DLT_JUNIPER_ETHER:\n-        if (datalen >= 5) {\n+        if (datalen < 4) {\n             l2_len = -1;\n             break;\n         }\n \n-        if (memcmp(pktdata, \"MGC\", 3))\n-            warnx(\"No Magic Number found: %s (0x%x)\",\n-                 pcap_datalink_val_to_description(datalink), datalink);\n-\n-        if ((pktdata[3] & 0x80) == 0x80) {\n-            l2_len = ntohs(*((uint16_t*)&pktdata[4]));\n-            l2_len += 6;\n-        } else {\n-            l2_len = 4; /* no header extensions */\n+        if (memcmp(pktdata, JUNIPER_PCAP_MAGIC, 3)) {\n+            warnx(\"No Magic Number found during L2 lookup: %s (0x%x)\",\n+                  pcap_datalink_val_to_description(datalink), datalink);\n+            l2_len = -1;\n+            break;\n         }\n \n-        /* fallthrough */\n+        if ((pktdata[3] & JUNIPER_FLAG_NO_L2) == JUNIPER_FLAG_NO_L2) {\n+            /* no L2 header present */\n+            l2_len = 0;\n+            break;\n+        }\n+\n+        if ((pktdata[3] & JUNIPER_FLAG_EXT) == JUNIPER_FLAG_EXT) {\n+            if (datalen < 6) {\n+                /* datalen too short */\n+                l2_len = -1;\n+                break;\n+            }\n+            l2_len = ntohs(*((uint16_t*)&pktdata[4]));\n+            l2_len += 6;        /* MGC + flags + ext_total_len */\n+        } else {\n+            l2_len = 4;         /* MGC + flags */\n+        }\n+        /* fall through */\n     case DLT_EN10MB:\n         if ((size_t)datalen >= sizeof(eth_hdr_t) + l2_len) {\n             uint16_t ether_type = ntohs(((eth_hdr_t*)(pktdata + l2_len))->ether_type);",
  "diff_line_info": {
    "deleted_lines": [
      "        if (datalen >= 5) {",
      "        if (memcmp(pktdata, \"MGC\", 3))",
      "            warnx(\"No Magic Number found: %s (0x%x)\",",
      "                 pcap_datalink_val_to_description(datalink), datalink);",
      "",
      "        if ((pktdata[3] & 0x80) == 0x80) {",
      "            l2_len = ntohs(*((uint16_t*)&pktdata[4]));",
      "            l2_len += 6;",
      "        } else {",
      "            l2_len = 4; /* no header extensions */",
      "        /* fallthrough */"
    ],
    "added_lines": [
      "        if (datalen < 4) {",
      "        if (memcmp(pktdata, JUNIPER_PCAP_MAGIC, 3)) {",
      "            warnx(\"No Magic Number found during L2 lookup: %s (0x%x)\",",
      "                  pcap_datalink_val_to_description(datalink), datalink);",
      "            l2_len = -1;",
      "            break;",
      "        if ((pktdata[3] & JUNIPER_FLAG_NO_L2) == JUNIPER_FLAG_NO_L2) {",
      "            /* no L2 header present */",
      "            l2_len = 0;",
      "            break;",
      "        }",
      "",
      "        if ((pktdata[3] & JUNIPER_FLAG_EXT) == JUNIPER_FLAG_EXT) {",
      "            if (datalen < 6) {",
      "                /* datalen too short */",
      "                l2_len = -1;",
      "                break;",
      "            }",
      "            l2_len = ntohs(*((uint16_t*)&pktdata[4]));",
      "            l2_len += 6;        /* MGC + flags + ext_total_len */",
      "        } else {",
      "            l2_len = 4;         /* MGC + flags */",
      "        }",
      "        /* fall through */"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/appneta/tcpreplay/pull/637",
  "description": {
    "pr_info": {
      "title": "Bug #616 Add checks for datalen for DLT_JUNIPER_ETHER",
      "number": 637
    },
    "comment": [
      "Also did some fixes to Juniper Ethernet protocols to fix some bugs\r\nand support various types of Juniper Ethernet protocol types. Used\r\nWireshark sources to figure out all the different packet types that\r\nJuniper uses.\r\n\r\nUnable to test all types because of lack of JNPER DLT pcaps.\r\n\r\nAlso applied a fix for DLT_RAW to prevent similar issues."
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "Final Classification: Defect Remediation & Feature Upgrades; Confidence: 0.9\n\n**Step-by-Step Explanation:**\n\n1. **Input Analysis:** The commit message and vulnerability description focus on fixing Juniper Ethernet protocol bugs and improving support for various packet types. The code diff modifies the function to include additional checks and handling for different packet structures, indicating functional improvements rather than security fixes.\n\n2. **Consistency Check:** The commit message aligns with the code changes, which address parsing and handling of data link types, without any security-related terms or identifiers.\n\n3. **Purpose Evaluation:** The changes improve core functionality by correctly parsing and handling different packet types, which is a defect remediation and feature upgrade.\n\n4. **Security Assessment:** No evidence of security-related issues or exploits being fixed; the focus is on correct handling of packet data.\n\n5. **Non-Security Classification:** The patch addresses core functionality bugs and enhances features, so it falls under Defect Remediation & Feature Upgrades.\n\n6. **Confidence Scoring:** High confidence due to clear alignment between description and code changes, and no security indicators.\n\n**Final Output:**  \n**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.9"
}