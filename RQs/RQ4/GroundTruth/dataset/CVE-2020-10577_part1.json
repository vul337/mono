{
  "cve_id": "CVE-2020-10577",
  "cwe_ids": [
    "CWE-362"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "meetecho/janus-gateway",
  "commit_msg": "Fix rare race condition when claiming sessions",
  "commit_hash": "bc319056603295953f4a70999bc4553785c6e5ef",
  "git_url": "https://github.com/meetecho/janus-gateway/commit/bc319056603295953f4a70999bc4553785c6e5ef",
  "file_path": "janus.c",
  "func_name": "janus_process_incoming_request",
  "func_before": "int janus_process_incoming_request(janus_request *request) {\n\tint ret = -1;\n\tif(request == NULL) {\n\t\tJANUS_LOG(LOG_ERR, \"Missing request or payload to process, giving up...\\n\");\n\t\treturn ret;\n\t}\n\tint error_code = 0;\n\tchar error_cause[100];\n\tjson_t *root = request->message;\n\t/* Ok, let's start with the ids */\n\tguint64 session_id = 0, handle_id = 0;\n\tjson_t *s = json_object_get(root, \"session_id\");\n\tif(s && json_is_integer(s))\n\t\tsession_id = json_integer_value(s);\n\tjson_t *h = json_object_get(root, \"handle_id\");\n\tif(h && json_is_integer(h))\n\t\thandle_id = json_integer_value(h);\n\n\tjanus_session *session = NULL;\n\tjanus_ice_handle *handle = NULL;\n\n\t/* Get transaction and message request */\n\tJANUS_VALIDATE_JSON_OBJECT(root, incoming_request_parameters,\n\t\terror_code, error_cause, FALSE,\n\t\tJANUS_ERROR_MISSING_MANDATORY_ELEMENT, JANUS_ERROR_INVALID_ELEMENT_TYPE);\n\tif(error_code != 0) {\n\t\tret = janus_process_error_string(request, session_id, NULL, error_code, error_cause);\n\t\tgoto jsondone;\n\t}\n\tjson_t *transaction = json_object_get(root, \"transaction\");\n\tconst gchar *transaction_text = json_string_value(transaction);\n\tjson_t *message = json_object_get(root, \"janus\");\n\tconst gchar *message_text = json_string_value(message);\n\n\tif(session_id == 0 && handle_id == 0) {\n\t\t/* Can only be a 'Create new session', a 'Get info' or a 'Ping/Pong' request */\n\t\tif(!strcasecmp(message_text, \"info\")) {\n\t\t\tret = janus_process_success(request, janus_info(transaction_text));\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(!strcasecmp(message_text, \"ping\")) {\n\t\t\t/* Prepare JSON reply */\n\t\t\tjson_t *reply = janus_create_message(\"pong\", 0, transaction_text);\n\t\t\tret = janus_process_success(request, reply);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(strcasecmp(message_text, \"create\")) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_REQUEST_PATH, \"Unhandled request '%s' at this path\", message_text);\n\t\t\tgoto jsondone;\n\t\t}\n\t\t/* Make sure we're accepting new sessions */\n\t\tif(!accept_new_sessions) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_NOT_ACCEPTING_SESSIONS, NULL);\n\t\t\tgoto jsondone;\n\t\t}\n\t\t/* Any secret/token to check? */\n\t\tret = janus_request_check_secret(request, session_id, transaction_text);\n\t\tif(ret != 0) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNAUTHORIZED, NULL);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tsession_id = 0;\n\t\tjson_t *id = json_object_get(root, \"id\");\n\t\tif(id != NULL) {\n\t\t\t/* The application provided the session ID to use */\n\t\t\tsession_id = json_integer_value(id);\n\t\t\tif(session_id > 0 && (session = janus_session_find(session_id)) != NULL) {\n\t\t\t\t/* Session ID already taken */\n\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_SESSION_CONFLICT, \"Session ID already in use\");\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t}\n\t\t/* Handle it */\n\t\tsession = janus_session_create(session_id);\n\t\tif(session == NULL) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNKNOWN, \"Memory error\");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tsession_id = session->session_id;\n\t\t/* We increase the counter as this request is using the session */\n\t\tjanus_refcount_increase(&session->ref);\n\t\t/* Take note of the request source that originated this session (HTTP, WebSockets, RabbitMQ?) */\n\t\tsession->source = janus_request_new(request->transport, request->instance, NULL, FALSE, NULL);\n\t\t/* Notify the source that a new session has been created */\n\t\trequest->transport->session_created(request->instance, session->session_id);\n\t\t/* Notify event handlers */\n\t\tif(janus_events_is_enabled()) {\n\t\t\t/* Session created, add info on the transport that originated it */\n\t\t\tjson_t *transport = json_object();\n\t\t\tjson_object_set_new(transport, \"transport\", json_string(session->source->transport->get_package()));\n\t\t\tchar id[32];\n\t\t\tmemset(id, 0, sizeof(id));\n\t\t\tg_snprintf(id, sizeof(id), \"%p\", session->source->instance);\n\t\t\tjson_object_set_new(transport, \"id\", json_string(id));\n\t\t\tjanus_events_notify_handlers(JANUS_EVENT_TYPE_SESSION, JANUS_EVENT_SUBTYPE_NONE,\n\t\t\t\tsession_id, \"created\", transport);\n\t\t}\n\t\t/* Prepare JSON reply */\n\t\tjson_t *reply = janus_create_message(\"success\", 0, transaction_text);\n\t\tjson_t *data = json_object();\n\t\tjson_object_set_new(data, \"id\", json_integer(session_id));\n\t\tjson_object_set_new(reply, \"data\", data);\n\t\t/* Send the success reply */\n\t\tret = janus_process_success(request, reply);\n\t\tgoto jsondone;\n\t}\n\tif(session_id < 1) {\n\t\tJANUS_LOG(LOG_ERR, \"Invalid session\\n\");\n\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_SESSION_NOT_FOUND, NULL);\n\t\tgoto jsondone;\n\t}\n\tif(h && handle_id < 1) {\n\t\tJANUS_LOG(LOG_ERR, \"Invalid handle\\n\");\n\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_SESSION_NOT_FOUND, NULL);\n\t\tgoto jsondone;\n\t}\n\n\t/* Go on with the processing */\n\tret = janus_request_check_secret(request, session_id, transaction_text);\n\tif(ret != 0) {\n\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNAUTHORIZED, NULL);\n\t\tgoto jsondone;\n\t}\n\n\t/* If we got here, make sure we have a session (and/or a handle) */\n\tsession = janus_session_find(session_id);\n\tif(!session) {\n\t\tJANUS_LOG(LOG_ERR, \"Couldn't find any session %\"SCNu64\"...\\n\", session_id);\n\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_SESSION_NOT_FOUND, \"No such session %\"SCNu64\"\", session_id);\n\t\tgoto jsondone;\n\t}\n\t/* Update the last activity timer */\n\tsession->last_activity = janus_get_monotonic_time();\n\thandle = NULL;\n\tif(handle_id > 0) {\n\t\thandle = janus_session_handles_find(session, handle_id);\n\t\tif(!handle) {\n\t\t\tJANUS_LOG(LOG_ERR, \"Couldn't find any handle %\"SCNu64\" in session %\"SCNu64\"...\\n\", handle_id, session_id);\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_HANDLE_NOT_FOUND, \"No such handle %\"SCNu64\" in session %\"SCNu64\"\", handle_id, session_id);\n\t\t\tgoto jsondone;\n\t\t}\n\t}\n\n\t/* What is this? */\n\tif(!strcasecmp(message_text, \"keepalive\")) {\n\t\t/* Just a keep-alive message, reply with an ack */\n\t\tJANUS_LOG(LOG_VERB, \"Got a keep-alive on session %\"SCNu64\"\\n\", session_id);\n\t\tjson_t *reply = janus_create_message(\"ack\", session_id, transaction_text);\n\t\t/* Send the success reply */\n\t\tret = janus_process_success(request, reply);\n\t} else if(!strcasecmp(message_text, \"attach\")) {\n\t\tif(handle != NULL) {\n\t\t\t/* Attach is a session-level command */\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_REQUEST_PATH, \"Unhandled request '%s' at this path\", message_text);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tJANUS_VALIDATE_JSON_OBJECT(root, attach_parameters,\n\t\t\terror_code, error_cause, FALSE,\n\t\t\tJANUS_ERROR_MISSING_MANDATORY_ELEMENT, JANUS_ERROR_INVALID_ELEMENT_TYPE);\n\t\tif(error_code != 0) {\n\t\t\tret = janus_process_error_string(request, session_id, transaction_text, error_code, error_cause);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjson_t *plugin = json_object_get(root, \"plugin\");\n\t\tconst gchar *plugin_text = json_string_value(plugin);\n\t\tjanus_plugin *plugin_t = janus_plugin_find(plugin_text);\n\t\tif(plugin_t == NULL) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_NOT_FOUND, \"No such plugin '%s'\", plugin_text);\n\t\t\tgoto jsondone;\n\t\t}\n\t\t/* If the auth token mechanism is enabled, we should check if this token can access this plugin */\n\t\tif(janus_auth_is_enabled()) {\n\t\t\tjson_t *token = json_object_get(root, \"token\");\n\t\t\tif(token != NULL) {\n\t\t\t\tconst char *token_value = json_string_value(token);\n\t\t\t\tif(token_value && !janus_auth_check_plugin(token_value, plugin_t)) {\n\t\t\t\t\tJANUS_LOG(LOG_ERR, \"Token '%s' can't access plugin '%s'\\n\", token_value, plugin_text);\n\t\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNAUTHORIZED_PLUGIN, \"Provided token can't access plugin '%s'\", plugin_text);\n\t\t\t\t\tgoto jsondone;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tjson_t *opaque = json_object_get(root, \"opaque_id\");\n\t\tconst char *opaque_id = opaque ? json_string_value(opaque) : NULL;\n\t\t/* Create handle */\n\t\thandle = janus_ice_handle_create(session, opaque_id);\n\t\tif(handle == NULL) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNKNOWN, \"Memory error\");\n\t\t\tgoto jsondone;\n\t\t}\n\t\thandle_id = handle->handle_id;\n\t\t/* We increase the counter as this request is using the handle */\n\t\tjanus_refcount_increase(&handle->ref);\n\t\t/* Attach to the plugin */\n\t\tint error = 0;\n\t\tif((error = janus_ice_handle_attach_plugin(session, handle, plugin_t)) != 0) {\n\t\t\t/* TODO Make error struct to pass verbose information */\n\t\t\tjanus_session_handles_remove(session, handle);\n\t\t\tJANUS_LOG(LOG_ERR, \"Couldn't attach to plugin '%s', error '%d'\\n\", plugin_text, error);\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_ATTACH, \"Couldn't attach to plugin: error '%d'\", error);\n\t\t\tgoto jsondone;\n\t\t}\n\t\t/* Prepare JSON reply */\n\t\tjson_t *reply = janus_create_message(\"success\", session_id, transaction_text);\n\t\tjson_t *data = json_object();\n\t\tjson_object_set_new(data, \"id\", json_integer(handle_id));\n\t\tjson_object_set_new(reply, \"data\", data);\n\t\t/* Send the success reply */\n\t\tret = janus_process_success(request, reply);\n\t} else if(!strcasecmp(message_text, \"destroy\")) {\n\t\tif(handle != NULL) {\n\t\t\t/* Query is a session-level command */\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_REQUEST_PATH, \"Unhandled request '%s' at this path\", message_text);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjanus_mutex_lock(&sessions_mutex);\n\t\tg_hash_table_remove(sessions, &session->session_id);\n\t\tjanus_mutex_unlock(&sessions_mutex);\n\t\t/* Notify the source that the session has been destroyed */\n\t\tif(session->source && session->source->transport) {\n\t\t\tsession->source->transport->session_over(session->source->instance, session->session_id, FALSE, FALSE);\n\t\t}\n\t\t/* Schedule the session for deletion */\n\t\tjanus_session_destroy(session);\n\n\t\t/* Prepare JSON reply */\n\t\tjson_t *reply = janus_create_message(\"success\", session_id, transaction_text);\n\t\t/* Send the success reply */\n\t\tret = janus_process_success(request, reply);\n\t\t/* Notify event handlers as well */\n\t\tif(janus_events_is_enabled())\n\t\t\tjanus_events_notify_handlers(JANUS_EVENT_TYPE_SESSION, JANUS_EVENT_SUBTYPE_NONE,\n\t\t\t\tsession_id, \"destroyed\", NULL);\n\t} else if(!strcasecmp(message_text, \"detach\")) {\n\t\tif(handle == NULL) {\n\t\t\t/* Query is an handle-level command */\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_REQUEST_PATH, \"Unhandled request '%s' at this path\", message_text);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(handle->app == NULL || handle->app_handle == NULL) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_DETACH, \"No plugin to detach from\");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tint error = janus_session_handles_remove(session, handle);\n\t\tif(error != 0) {\n\t\t\t/* TODO Make error struct to pass verbose information */\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_DETACH, \"Couldn't detach from plugin: error '%d'\", error);\n\t\t\t/* TODO Delete handle instance */\n\t\t\tgoto jsondone;\n\t\t}\n\t\t/* Prepare JSON reply */\n\t\tjson_t *reply = janus_create_message(\"success\", session_id, transaction_text);\n\t\t/* Send the success reply */\n\t\tret = janus_process_success(request, reply);\n\t} else if(!strcasecmp(message_text, \"hangup\")) {\n\t\tif(handle == NULL) {\n\t\t\t/* Query is an handle-level command */\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_REQUEST_PATH, \"Unhandled request '%s' at this path\", message_text);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(handle->app == NULL || handle->app_handle == NULL) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_DETACH, \"No plugin attached\");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjanus_ice_webrtc_hangup(handle, \"Janus API\");\n\t\t/* Prepare JSON reply */\n\t\tjson_t *reply = janus_create_message(\"success\", session_id, transaction_text);\n\t\t/* Send the success reply */\n\t\tret = janus_process_success(request, reply);\n\t} else if(!strcasecmp(message_text, \"claim\")) {\n\t\tjanus_mutex_lock(&session->mutex);\n\t\tif(session->source != NULL) {\n\t\t\t/* Notify the old transport that this session is over for them, but has been reclaimed */\n\t\t\tsession->source->transport->session_over(session->source->instance, session->session_id, FALSE, TRUE);\n\t\t\tjanus_request_destroy(session->source);\n\t\t\tsession->source = NULL;\n\t\t}\n\t\tsession->source = janus_request_new(request->transport, request->instance, NULL, FALSE, NULL);\n\t\t/* Notify the new transport that it has claimed a session */\n\t\tsession->source->transport->session_claimed(session->source->instance, session->session_id);\n\t\t/* Previous transport may be gone, clear flag. */\n\t\tg_atomic_int_set(&session->transport_gone, 0);\n\t\tjanus_mutex_unlock(&session->mutex);\n\t\t/* Prepare JSON reply */\n\t\tjson_t *reply = json_object();\n\t\tjson_object_set_new(reply, \"janus\", json_string(\"success\"));\n\t\tjson_object_set_new(reply, \"session_id\", json_integer(session_id));\n\t\tjson_object_set_new(reply, \"transaction\", json_string(transaction_text));\n\t\t/* Send the success reply */\n\t\tret = janus_process_success(request, reply);\n\t} else if(!strcasecmp(message_text, \"message\")) {\n\t\tif(handle == NULL) {\n\t\t\t/* Query is an handle-level command */\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_REQUEST_PATH, \"Unhandled request '%s' at this path\", message_text);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(handle->app == NULL || handle->app_handle == NULL) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_MESSAGE, \"No plugin to handle this message\");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjanus_plugin *plugin_t = (janus_plugin *)handle->app;\n\t\tJANUS_LOG(LOG_VERB, \"[%\"SCNu64\"] There's a message for %s\\n\", handle->handle_id, plugin_t->get_name());\n\t\tJANUS_VALIDATE_JSON_OBJECT(root, body_parameters,\n\t\t\terror_code, error_cause, FALSE,\n\t\t\tJANUS_ERROR_MISSING_MANDATORY_ELEMENT, JANUS_ERROR_INVALID_ELEMENT_TYPE);\n\t\tif(error_code != 0) {\n\t\t\tret = janus_process_error_string(request, session_id, transaction_text, error_code, error_cause);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjson_t *body = json_object_get(root, \"body\");\n\t\t/* Is there an SDP attached? */\n\t\tjson_t *jsep = json_object_get(root, \"jsep\");\n\t\tchar *jsep_type = NULL;\n\t\tchar *jsep_sdp = NULL, *jsep_sdp_stripped = NULL;\n\t\tgboolean renegotiation = FALSE;\n\t\tif(jsep != NULL) {\n\t\t\tif(!json_is_object(jsep)) {\n\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_JSON_OBJECT, \"Invalid jsep object\");\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\tJANUS_VALIDATE_JSON_OBJECT_FORMAT(\"JSEP error: missing mandatory element (%s)\",\n\t\t\t\t\"JSEP error: invalid element type (%s should be %s)\",\n\t\t\t\tjsep, jsep_parameters, error_code, error_cause, FALSE,\n\t\t\t\tJANUS_ERROR_MISSING_MANDATORY_ELEMENT, JANUS_ERROR_INVALID_ELEMENT_TYPE);\n\t\t\tif(error_code != 0) {\n\t\t\t\tret = janus_process_error_string(request, session_id, transaction_text, error_code, error_cause);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\tjson_t *type = json_object_get(jsep, \"type\");\n\t\t\tjsep_type = g_strdup(json_string_value(type));\n\t\t\ttype = NULL;\n\t\t\tgboolean do_trickle = TRUE;\n\t\t\tjson_t *jsep_trickle = json_object_get(jsep, \"trickle\");\n\t\t\tdo_trickle = jsep_trickle ? json_is_true(jsep_trickle) : TRUE;\n\t\t\t/* Are we still cleaning up from a previous media session? */\n\t\t\tif(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_CLEANING)) {\n\t\t\t\tJANUS_LOG(LOG_VERB, \"[%\"SCNu64\"] Still cleaning up from a previous media session, let's wait a bit...\\n\", handle->handle_id);\n\t\t\t\tgint64 waited = 0;\n\t\t\t\twhile(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_CLEANING)) {\n\t\t\t\t\tg_usleep(100000);\n\t\t\t\t\twaited += 100000;\n\t\t\t\t\tif(waited >= 3*G_USEC_PER_SEC) {\n\t\t\t\t\t\tJANUS_LOG(LOG_VERB, \"[%\"SCNu64\"]   -- Waited 3 seconds, that's enough!\\n\", handle->handle_id);\n\t\t\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_WEBRTC_STATE, \"Still cleaning a previous session\");\n\t\t\t\t\t\tgoto jsondone;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Check if we're renegotiating (if we have an answer, we did an offer/answer round already) */\n\t\t\trenegotiation = janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_NEGOTIATED);\n\t\t\t/* Check the JSEP type */\n\t\t\tjanus_mutex_lock(&handle->mutex);\n\t\t\tint offer = 0;\n\t\t\tif(!strcasecmp(jsep_type, \"offer\")) {\n\t\t\t\toffer = 1;\n\t\t\t\tjanus_flags_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t\t\tjanus_flags_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_OFFER);\n\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_ANSWER);\n\t\t\t} else if(!strcasecmp(jsep_type, \"answer\")) {\n\t\t\t\tjanus_flags_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_ANSWER);\n\t\t\t\tif(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_OFFER))\n\t\t\t\t\tjanus_flags_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_NEGOTIATED);\n\t\t\t\toffer = 0;\n\t\t\t} else {\n\t\t\t\t/* TODO Handle other message types as well */\n\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_JSEP_UNKNOWN_TYPE, \"JSEP error: unknown message type '%s'\", jsep_type);\n\t\t\t\tg_free(jsep_type);\n\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\tjson_t *sdp = json_object_get(jsep, \"sdp\");\n\t\t\tjsep_sdp = (char *)json_string_value(sdp);\n\t\t\tJANUS_LOG(LOG_VERB, \"[%\"SCNu64\"] Remote SDP:\\n%s\", handle->handle_id, jsep_sdp);\n\t\t\t/* Is this valid SDP? */\n\t\t\tchar error_str[512];\n\t\t\tint audio = 0, video = 0, data = 0;\n\t\t\tjanus_sdp *parsed_sdp = janus_sdp_preparse(handle, jsep_sdp, error_str, sizeof(error_str), &audio, &video, &data);\n\t\t\tif(parsed_sdp == NULL) {\n\t\t\t\t/* Invalid SDP */\n\t\t\t\tret = janus_process_error_string(request, session_id, transaction_text, JANUS_ERROR_JSEP_INVALID_SDP, error_str);\n\t\t\t\tg_free(jsep_type);\n\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\t/* Notify event handlers */\n\t\t\tif(janus_events_is_enabled()) {\n\t\t\t\tjanus_events_notify_handlers(JANUS_EVENT_TYPE_JSEP, JANUS_EVENT_SUBTYPE_NONE,\n\t\t\t\t\tsession_id, handle_id, handle->opaque_id, \"remote\", jsep_type, jsep_sdp);\n\t\t\t}\n\t\t\t/* FIXME We're only handling single audio/video lines for now... */\n\t\t\tJANUS_LOG(LOG_VERB, \"[%\"SCNu64\"] Audio %s been negotiated, Video %s been negotiated, SCTP/DataChannels %s been negotiated\\n\",\n\t\t\t                    handle->handle_id,\n\t\t\t                    audio ? \"has\" : \"has NOT\",\n\t\t\t                    video ? \"has\" : \"has NOT\",\n\t\t\t                    data ? \"have\" : \"have NOT\");\n\t\t\tif(audio > 1) {\n\t\t\t\tJANUS_LOG(LOG_WARN, \"[%\"SCNu64\"] More than one audio line? only going to negotiate one...\\n\", handle->handle_id);\n\t\t\t}\n\t\t\tif(video > 1) {\n\t\t\t\tJANUS_LOG(LOG_WARN, \"[%\"SCNu64\"] More than one video line? only going to negotiate one...\\n\", handle->handle_id);\n\t\t\t}\n\t\t\tif(data > 1) {\n\t\t\t\tJANUS_LOG(LOG_WARN, \"[%\"SCNu64\"] More than one data line? only going to negotiate one...\\n\", handle->handle_id);\n\t\t\t}\n#ifndef HAVE_SCTP\n\t\t\tif(data) {\n\t\t\t\tJANUS_LOG(LOG_WARN, \"[%\"SCNu64\"]   -- DataChannels have been negotiated, but support for them has not been compiled...\\n\", handle->handle_id);\n\t\t\t}\n#endif\n\t\t\t/* We behave differently if it's a new session or an update... */\n\t\t\tif(!renegotiation) {\n\t\t\t\t/* New session */\n\t\t\t\tif(offer) {\n\t\t\t\t\t/* Setup ICE locally (we received an offer) */\n\t\t\t\t\tif(janus_ice_setup_local(handle, offer, audio, video, data, do_trickle) < 0) {\n\t\t\t\t\t\tJANUS_LOG(LOG_ERR, \"Error setting ICE locally\\n\");\n\t\t\t\t\t\tjanus_sdp_destroy(parsed_sdp);\n\t\t\t\t\t\tg_free(jsep_type);\n\t\t\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNKNOWN, \"Error setting ICE locally\");\n\t\t\t\t\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t\t\t\t\tgoto jsondone;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t/* Make sure we're waiting for an ANSWER in the first place */\n\t\t\t\t\tif(!handle->agent) {\n\t\t\t\t\t\tJANUS_LOG(LOG_ERR, \"Unexpected ANSWER (did we offer?)\\n\");\n\t\t\t\t\t\tjanus_sdp_destroy(parsed_sdp);\n\t\t\t\t\t\tg_free(jsep_type);\n\t\t\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNEXPECTED_ANSWER, \"Unexpected ANSWER (did we offer?)\");\n\t\t\t\t\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t\t\t\t\tgoto jsondone;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(janus_sdp_process(handle, parsed_sdp, FALSE) < 0) {\n\t\t\t\t\tJANUS_LOG(LOG_ERR, \"Error processing SDP\\n\");\n\t\t\t\t\tjanus_sdp_destroy(parsed_sdp);\n\t\t\t\t\tg_free(jsep_type);\n\t\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_JSEP_INVALID_SDP, \"Error processing SDP\");\n\t\t\t\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t\t\t\tgoto jsondone;\n\t\t\t\t}\n\t\t\t\tif(!offer) {\n\t\t\t\t\t/* Set remote candidates now (we received an answer) */\n\t\t\t\t\tif(do_trickle) {\n\t\t\t\t\t\tjanus_flags_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_TRICKLE);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_TRICKLE);\n\t\t\t\t\t}\n\t\t\t\t\tjanus_request_ice_handle_answer(handle, audio, video, data, jsep_sdp);\n\t\t\t\t} else {\n\t\t\t\t\t/* Check if the mid RTP extension is being negotiated */\n\t\t\t\t\thandle->stream->mid_ext_id = janus_rtp_header_extension_get_id(jsep_sdp, JANUS_RTP_EXTMAP_MID);\n\t\t\t\t\t/* Check if the RTP Stream ID extension is being negotiated */\n\t\t\t\t\thandle->stream->rid_ext_id = janus_rtp_header_extension_get_id(jsep_sdp, JANUS_RTP_EXTMAP_RID);\n\t\t\t\t\thandle->stream->ridrtx_ext_id = janus_rtp_header_extension_get_id(jsep_sdp, JANUS_RTP_EXTMAP_REPAIRED_RID);\n\t\t\t\t\t/* Check if the audio level ID extension is being negotiated */\n\t\t\t\t\thandle->stream->audiolevel_ext_id = janus_rtp_header_extension_get_id(jsep_sdp, JANUS_RTP_EXTMAP_AUDIO_LEVEL);\n\t\t\t\t\t/* Check if the video orientation ID extension is being negotiated */\n\t\t\t\t\thandle->stream->videoorientation_ext_id = janus_rtp_header_extension_get_id(jsep_sdp, JANUS_RTP_EXTMAP_VIDEO_ORIENTATION);\n\t\t\t\t\t/* Check if the frame marking ID extension is being negotiated */\n\t\t\t\t\thandle->stream->framemarking_ext_id = janus_rtp_header_extension_get_id(jsep_sdp, JANUS_RTP_EXTMAP_FRAME_MARKING);\n\t\t\t\t\t/* Check if transport wide CC is supported */\n\t\t\t\t\tint transport_wide_cc_ext_id = janus_rtp_header_extension_get_id(jsep_sdp, JANUS_RTP_EXTMAP_TRANSPORT_WIDE_CC);\n\t\t\t\t\thandle->stream->do_transport_wide_cc = transport_wide_cc_ext_id > 0 ? TRUE : FALSE;\n\t\t\t\t\thandle->stream->transport_wide_cc_ext_id = transport_wide_cc_ext_id;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* FIXME This is a renegotiation: we can currently only handle simple changes in media\n\t\t\t\t * direction and ICE restarts: anything more complex than that will result in an error */\n\t\t\t\tJANUS_LOG(LOG_INFO, \"[%\"SCNu64\"] Negotiation update, checking what changed...\\n\", handle->handle_id);\n\t\t\t\tif(janus_sdp_process(handle, parsed_sdp, TRUE) < 0) {\n\t\t\t\t\tJANUS_LOG(LOG_ERR, \"Error processing SDP\\n\");\n\t\t\t\t\tjanus_sdp_destroy(parsed_sdp);\n\t\t\t\t\tg_free(jsep_type);\n\t\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNEXPECTED_ANSWER, \"Error processing SDP\");\n\t\t\t\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t\t\t\tgoto jsondone;\n\t\t\t\t}\n\t\t\t\tif(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_ICE_RESTART)) {\n\t\t\t\t\tJANUS_LOG(LOG_INFO, \"[%\"SCNu64\"] Restarting ICE...\\n\", handle->handle_id);\n\t\t\t\t\t/* Update remote credentials for ICE */\n\t\t\t\t\tif(handle->stream) {\n\t\t\t\t\t\tnice_agent_set_remote_credentials(handle->agent, handle->stream->stream_id,\n\t\t\t\t\t\t\thandle->stream->ruser, handle->stream->rpass);\n\t\t\t\t\t}\n\t\t\t\t\t/* FIXME We only need to do that for offers: if it's an answer, we did that already */\n\t\t\t\t\tif(offer) {\n\t\t\t\t\t\tjanus_ice_restart(handle);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_ICE_RESTART);\n\t\t\t\t\t}\n\t\t\t\t\t/* If we're full-trickling, we'll need to resend the candidates later */\n\t\t\t\t\tif(janus_ice_is_full_trickle_enabled()) {\n\t\t\t\t\t\tjanus_flags_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_RESEND_TRICKLES);\n\t\t\t\t\t}\n\t\t\t\t}\n#ifdef HAVE_SCTP\n\t\t\t\tif(!offer) {\n\t\t\t\t\t/* Were datachannels just added? */\n\t\t\t\t\tif(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_DATA_CHANNELS)) {\n\t\t\t\t\t\tjanus_ice_stream *stream = handle->stream;\n\t\t\t\t\t\tif(stream != NULL && stream->component != NULL\n\t\t\t\t\t\t\t\t&& stream->component->dtls != NULL && stream->component->dtls->sctp == NULL) {\n\t\t\t\t\t\t\t/* Create SCTP association as well */\n\t\t\t\t\t\t\tJANUS_LOG(LOG_WARN, \"[%\"SCNu64\"] Creating datachannels...\\n\", handle->handle_id);\n\t\t\t\t\t\t\tjanus_dtls_srtp_create_sctp(stream->component->dtls);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t\tchar *tmp = handle->remote_sdp;\n\t\t\thandle->remote_sdp = g_strdup(jsep_sdp);\n\t\t\tg_free(tmp);\n\t\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t\t/* Anonymize SDP */\n\t\t\tif(janus_sdp_anonymize(parsed_sdp) < 0) {\n\t\t\t\t/* Invalid SDP */\n\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_JSEP_INVALID_SDP, \"JSEP error: invalid SDP\");\n\t\t\t\tjanus_sdp_destroy(parsed_sdp);\n\t\t\t\tg_free(jsep_type);\n\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\tjsep_sdp_stripped = janus_sdp_write(parsed_sdp);\n\t\t\tjanus_sdp_destroy(parsed_sdp);\n\t\t\tsdp = NULL;\n\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t}\n\n\t\t/* Make sure the app handle is still valid */\n\t\tif(handle->app == NULL || !janus_plugin_session_is_alive(handle->app_handle)) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_MESSAGE, \"No plugin to handle this message\");\n\t\t\tg_free(jsep_type);\n\t\t\tg_free(jsep_sdp_stripped);\n\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t\tgoto jsondone;\n\t\t}\n\n\t\t/* Send the message to the plugin (which must eventually free transaction_text and unref the two objects, body and jsep) */\n\t\tjson_incref(body);\n\t\tjson_t *body_jsep = NULL;\n\t\tif(jsep_sdp_stripped) {\n\t\t\tbody_jsep = json_pack(\"{ssss}\", \"type\", jsep_type, \"sdp\", jsep_sdp_stripped);\n\t\t\t/* Check if simulcasting is enabled */\n\t\t\tif(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_HAS_VIDEO)) {\n\t\t\t\tif(handle->stream && (handle->stream->rid[0] || handle->stream->video_ssrc_peer[1])) {\n\t\t\t\t\tjson_t *simulcast = json_object();\n\t\t\t\t\t/* If we have rids, pass those, otherwise pass the SSRCs */\n\t\t\t\t\tif(handle->stream->rid[0]) {\n\t\t\t\t\t\tjson_t *rids = json_array();\n\t\t\t\t\t\tjson_array_append_new(rids, json_string(handle->stream->rid[0]));\n\t\t\t\t\t\tif(handle->stream->rid[1])\n\t\t\t\t\t\t\tjson_array_append_new(rids, json_string(handle->stream->rid[1]));\n\t\t\t\t\t\tif(handle->stream->rid[2])\n\t\t\t\t\t\t\tjson_array_append_new(rids, json_string(handle->stream->rid[2]));\n\t\t\t\t\t\tjson_object_set_new(simulcast, \"rids\", rids);\n\t\t\t\t\t\tjson_object_set_new(simulcast, \"rid-ext\", json_integer(handle->stream->rid_ext_id));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tjson_t *ssrcs = json_array();\n\t\t\t\t\t\tjson_array_append_new(ssrcs, json_integer(handle->stream->video_ssrc_peer[0]));\n\t\t\t\t\t\tif(handle->stream->video_ssrc_peer[1])\n\t\t\t\t\t\t\tjson_array_append_new(ssrcs, json_integer(handle->stream->video_ssrc_peer[1]));\n\t\t\t\t\t\tif(handle->stream->video_ssrc_peer[2])\n\t\t\t\t\t\t\tjson_array_append_new(ssrcs, json_integer(handle->stream->video_ssrc_peer[2]));\n\t\t\t\t\t\tjson_object_set_new(simulcast, \"ssrcs\", ssrcs);\n\t\t\t\t\t}\n\t\t\t\t\tif(handle->stream->framemarking_ext_id > 0)\n\t\t\t\t\t\tjson_object_set_new(simulcast, \"framemarking-ext\", json_integer(handle->stream->framemarking_ext_id));\n\t\t\t\t\tjson_object_set_new(body_jsep, \"simulcast\", simulcast);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Check if this is a renegotiation or update */\n\t\t\tif(renegotiation)\n\t\t\t\tjson_object_set_new(body_jsep, \"update\", json_true());\n\t\t}\n\t\tjanus_plugin_result *result = plugin_t->handle_message(handle->app_handle,\n\t\t\tg_strdup((char *)transaction_text), body, body_jsep);\n\t\tg_free(jsep_type);\n\t\tg_free(jsep_sdp_stripped);\n\t\tif(result == NULL) {\n\t\t\t/* Something went horribly wrong! */\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_MESSAGE, \"Plugin didn't give a result\");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(result->type == JANUS_PLUGIN_OK) {\n\t\t\t/* The plugin gave a result already (synchronous request/response) */\n\t\t\tif(result->content == NULL || !json_is_object(result->content)) {\n\t\t\t\t/* Missing content, or not a JSON object */\n\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_MESSAGE,\n\t\t\t\t\tresult->content == NULL ?\n\t\t\t\t\t\t\"Plugin didn't provide any content for this synchronous response\" :\n\t\t\t\t\t\t\"Plugin returned an invalid JSON response\");\n\t\t\t\tjanus_plugin_result_destroy(result);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\t/* Reference the content, as destroying the result instance will decref it */\n\t\t\tjson_incref(result->content);\n\t\t\t/* Prepare JSON response */\n\t\t\tjson_t *reply = janus_create_message(\"success\", session->session_id, transaction_text);\n\t\t\tjson_object_set_new(reply, \"sender\", json_integer(handle->handle_id));\n\t\t\tif(janus_is_opaqueid_in_api_enabled() && handle->opaque_id != NULL)\n\t\t\t\tjson_object_set_new(reply, \"opaque_id\", json_string(handle->opaque_id));\n\t\t\tjson_t *plugin_data = json_object();\n\t\t\tjson_object_set_new(plugin_data, \"plugin\", json_string(plugin_t->get_package()));\n\t\t\tjson_object_set_new(plugin_data, \"data\", result->content);\n\t\t\tjson_object_set_new(reply, \"plugindata\", plugin_data);\n\t\t\t/* Send the success reply */\n\t\t\tret = janus_process_success(request, reply);\n\t\t} else if(result->type == JANUS_PLUGIN_OK_WAIT) {\n\t\t\t/* The plugin received the request but didn't process it yet, send an ack (asynchronous notifications may follow) */\n\t\t\tjson_t *reply = janus_create_message(\"ack\", session_id, transaction_text);\n\t\t\tif(result->text)\n\t\t\t\tjson_object_set_new(reply, \"hint\", json_string(result->text));\n\t\t\t/* Send the success reply */\n\t\t\tret = janus_process_success(request, reply);\n\t\t} else {\n\t\t\t/* Something went horribly wrong! */\n\t\t\tret = janus_process_error_string(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_MESSAGE,\n\t\t\t\t(char *)(result->text ? result->text : \"Plugin returned a severe (unknown) error\"));\n\t\t\tjanus_plugin_result_destroy(result);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjanus_plugin_result_destroy(result);\n\t} else if(!strcasecmp(message_text, \"trickle\")) {\n\t\tif(handle == NULL) {\n\t\t\t/* Trickle is an handle-level command */\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_REQUEST_PATH, \"Unhandled request '%s' at this path\", message_text);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(handle->app == NULL || !janus_plugin_session_is_alive(handle->app_handle)) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_MESSAGE, \"No plugin to handle this trickle candidate\");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjson_t *candidate = json_object_get(root, \"candidate\");\n\t\tjson_t *candidates = json_object_get(root, \"candidates\");\n\t\tif(candidate == NULL && candidates == NULL) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_MISSING_MANDATORY_ELEMENT, \"Missing mandatory element (candidate|candidates)\");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(candidate != NULL && candidates != NULL) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_JSON, \"Can't have both candidate and candidates\");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_CLEANING)) {\n\t\t\tJANUS_LOG(LOG_ERR, \"[%\"SCNu64\"] Received a trickle, but still cleaning a previous session\\n\", handle->handle_id);\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_WEBRTC_STATE, \"Still cleaning a previous session\");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjanus_mutex_lock(&handle->mutex);\n\t\tif(!janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_TRICKLE)) {\n\t\t\t/* It looks like this peer supports Trickle, after all */\n\t\t\tJANUS_LOG(LOG_VERB, \"Handle %\"SCNu64\" supports trickle even if it didn't negotiate it...\\n\", handle->handle_id);\n\t\t\tjanus_flags_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_TRICKLE);\n\t\t}\n\t\t/* Is there any stream ready? this trickle may get here before the SDP it relates to */\n\t\tif(handle->stream == NULL) {\n\t\t\tJANUS_LOG(LOG_WARN, \"[%\"SCNu64\"] No stream, queueing this trickle as it got here before the SDP...\\n\", handle->handle_id);\n\t\t\t/* Enqueue this trickle candidate(s), we'll process this later */\n\t\t\tjanus_ice_trickle *early_trickle = janus_ice_trickle_new(transaction_text, candidate ? candidate : candidates);\n\t\t\thandle->pending_trickles = g_list_append(handle->pending_trickles, early_trickle);\n\t\t\t/* Send the ack right away, an event will tell the application if the candidate(s) failed */\n\t\t\tgoto trickledone;\n\t\t}\n\t\t/* Is the ICE stack ready already? */\n\t\tif(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER) ||\n\t\t\t\t!janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_OFFER) ||\n\t\t\t\t!janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_ANSWER)) {\n\t\t\tconst char *cause = NULL;\n\t\t\tif(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER))\n\t\t\t\tcause = \"processing the offer\";\n\t\t\telse if(!janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_ANSWER))\n\t\t\t\tcause = \"waiting for the answer\";\n\t\t\telse if(!janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_OFFER))\n\t\t\t\tcause = \"waiting for the offer\";\n\t\t\tJANUS_LOG(LOG_VERB, \"[%\"SCNu64\"] Still %s, queueing this trickle to wait until we're done there...\\n\",\n\t\t\t\thandle->handle_id, cause);\n\t\t\t/* Enqueue this trickle candidate(s), we'll process this later */\n\t\t\tjanus_ice_trickle *early_trickle = janus_ice_trickle_new(transaction_text, candidate ? candidate : candidates);\n\t\t\thandle->pending_trickles = g_list_append(handle->pending_trickles, early_trickle);\n\t\t\t/* Send the ack right away, an event will tell the application if the candidate(s) failed */\n\t\t\tgoto trickledone;\n\t\t}\n\t\tif(candidate != NULL) {\n\t\t\t/* We got a single candidate */\n\t\t\tint error = 0;\n\t\t\tconst char *error_string = NULL;\n\t\t\tif((error = janus_ice_trickle_parse(handle, candidate, &error_string)) != 0) {\n\t\t\t\tret = janus_process_error(request, session_id, transaction_text, error, \"%s\", error_string);\n\t\t\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t} else {\n\t\t\t/* We got multiple candidates in an array */\n\t\t\tif(!json_is_array(candidates)) {\n\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_ELEMENT_TYPE, \"candidates is not an array\");\n\t\t\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\tJANUS_LOG(LOG_VERB, \"Got multiple candidates (%zu)\\n\", json_array_size(candidates));\n\t\t\tif(json_array_size(candidates) > 0) {\n\t\t\t\t/* Handle remote candidates */\n\t\t\t\tsize_t i = 0;\n\t\t\t\tfor(i=0; i<json_array_size(candidates); i++) {\n\t\t\t\t\tjson_t *c = json_array_get(candidates, i);\n\t\t\t\t\t/* FIXME We don't care if any trickle fails to parse */\n\t\t\t\t\tjanus_ice_trickle_parse(handle, c, NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\ntrickledone:\n\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t/* We reply right away, not to block the web server... */\n\t\tjson_t *reply = janus_create_message(\"ack\", session_id, transaction_text);\n\t\t/* Send the success reply */\n\t\tret = janus_process_success(request, reply);\n\t} else {\n\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNKNOWN_REQUEST, \"Unknown request '%s'\", message_text);\n\t}\n\njsondone:\n\t/* Done processing */\n\tif(handle != NULL)\n\t\tjanus_refcount_decrease(&handle->ref);\n\tif(session != NULL)\n\t\tjanus_refcount_decrease(&session->ref);\n\treturn ret;\n}",
  "abstract_func_before": "int janus_process_incoming_request(janus_request *VAR_0) {\n\tint VAR_1 = -1;\n\tif(VAR_0 == NULL) {\n\t\tJANUS_LOG(VAR_2, \"Missing request or payload to process, giving up...\\n\");\n\t\treturn VAR_1;\n\t}\n\tint VAR_3 = 0;\n\tchar VAR_4[100];\n\tjson_t *VAR_5 = VAR_0->message;\n\t/* COMMENT_0 */\n\tguint64 VAR_6 = 0, VAR_7 = 0;\n\tjson_t *VAR_8 = json_object_get(VAR_5, \"session_id\");\n\tif(VAR_8 && json_is_integer(VAR_8))\n\t\tVAR_6 = json_integer_value(VAR_8);\n\tjson_t *VAR_9 = json_object_get(VAR_5, \"handle_id\");\n\tif(VAR_9 && json_is_integer(VAR_9))\n\t\tVAR_7 = json_integer_value(VAR_9);\n\n\tjanus_session *VAR_10 = NULL;\n\tjanus_ice_handle *VAR_11 = NULL;\n\n\t/* COMMENT_1 */\n\tJANUS_VALIDATE_JSON_OBJECT(VAR_5, VAR_12,\n\t\tVAR_3, VAR_4, FALSE,\n\t\tVAR_13, VAR_14);\n\tif(VAR_3 != 0) {\n\t\tVAR_1 = janus_process_error_string(VAR_0, VAR_6, NULL, VAR_3, VAR_4);\n\t\tgoto jsondone;\n\t}\n\tjson_t *VAR_15 = json_object_get(VAR_5, \"transaction\");\n\tconst gchar *VAR_16 = json_string_value(VAR_15);\n\tjson_t *VAR_17 = json_object_get(VAR_5, \"janus\");\n\tconst gchar *VAR_18 = json_string_value(VAR_17);\n\n\tif(VAR_6 == 0 && VAR_7 == 0) {\n\t\t/* COMMENT_2 */\n\t\tif(!strcasecmp(VAR_18, \"info\")) {\n\t\t\tVAR_1 = janus_process_success(VAR_0, janus_info(VAR_16));\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(!strcasecmp(VAR_18, \"ping\")) {\n\t\t\t/* COMMENT_3 */\n\t\t\tjson_t *VAR_19 = janus_create_message(\"pong\", 0, VAR_16);\n\t\t\tVAR_1 = janus_process_success(VAR_0, VAR_19);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(strcasecmp(VAR_18, \"create\")) {\n\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_20, \"Unhandled request '%s' at this path\", VAR_18);\n\t\t\tgoto jsondone;\n\t\t}\n\t\t/* COMMENT_4 */\n\t\tif(!VAR_21) {\n\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_22, NULL);\n\t\t\tgoto jsondone;\n\t\t}\n\t\t/* COMMENT_5 */\n\t\tVAR_1 = janus_request_check_secret(VAR_0, VAR_6, VAR_16);\n\t\tif(VAR_1 != 0) {\n\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_23, NULL);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tVAR_6 = 0;\n\t\tjson_t *VAR_24 = json_object_get(VAR_5, \"id\");\n\t\tif(VAR_24 != NULL) {\n\t\t\t/* COMMENT_6 */\n\t\t\tVAR_6 = json_integer_value(VAR_24);\n\t\t\tif(VAR_6 > 0 && (VAR_10 = janus_session_find(VAR_6)) != NULL) {\n\t\t\t\t/* COMMENT_7 */\n\t\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_25, \"Session ID already in use\");\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t}\n\t\t/* COMMENT_8 */\n\t\tVAR_10 = janus_session_create(VAR_6);\n\t\tif(VAR_10 == NULL) {\n\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_26, \"Memory error\");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tVAR_6 = VAR_10->session_id;\n\t\t/* COMMENT_9 */\n\t\tjanus_refcount_increase(&VAR_10->ref);\n\t\t/* COMMENT_10 */\n\t\tVAR_10->source = janus_request_new(VAR_0->transport, VAR_0->instance, NULL, FALSE, NULL);\n\t\t/* COMMENT_11 */\n\t\tVAR_0->transport->session_created(VAR_0->instance, VAR_10->session_id);\n\t\t/* COMMENT_12 */\n\t\tif(janus_events_is_enabled()) {\n\t\t\t/* COMMENT_13 */\n\t\t\tjson_t *VAR_27 = json_object();\n\t\t\tjson_object_set_new(VAR_27, \"transport\", json_string(VAR_10->source->transport->get_package()));\n\t\t\tchar VAR_24[32];\n\t\t\tmemset(VAR_24, 0, sizeof(VAR_24));\n\t\t\tg_snprintf(VAR_24, sizeof(VAR_24), \"%p\", VAR_10->source->instance);\n\t\t\tjson_object_set_new(VAR_27, \"id\", json_string(VAR_24));\n\t\t\tjanus_events_notify_handlers(VAR_28, VAR_29,\n\t\t\t\tVAR_6, \"created\", VAR_27);\n\t\t}\n\t\t/* COMMENT_3 */\n\t\tjson_t *VAR_19 = janus_create_message(\"success\", 0, VAR_16);\n\t\tjson_t *VAR_30 = json_object();\n\t\tjson_object_set_new(VAR_30, \"id\", json_integer(VAR_6));\n\t\tjson_object_set_new(VAR_19, \"data\", VAR_30);\n\t\t/* COMMENT_14 */\n\t\tVAR_1 = janus_process_success(VAR_0, VAR_19);\n\t\tgoto jsondone;\n\t}\n\tif(VAR_6 < 1) {\n\t\tJANUS_LOG(VAR_2, \"Invalid session\\n\");\n\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_31, NULL);\n\t\tgoto jsondone;\n\t}\n\tif(VAR_9 && VAR_7 < 1) {\n\t\tJANUS_LOG(VAR_2, \"Invalid handle\\n\");\n\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_31, NULL);\n\t\tgoto jsondone;\n\t}\n\n\t/* COMMENT_15 */\n\tVAR_1 = janus_request_check_secret(VAR_0, VAR_6, VAR_16);\n\tif(VAR_1 != 0) {\n\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_23, NULL);\n\t\tgoto jsondone;\n\t}\n\n\t/* COMMENT_16 */\n\tVAR_10 = janus_session_find(VAR_6);\n\tif(!VAR_10) {\n\t\tJANUS_LOG(VAR_2, \"Couldn't find any session %\"VAR_32\"...\\n\", VAR_6);\n\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_31, \"No such session %\"VAR_32\"\", VAR_6);\n\t\tgoto jsondone;\n\t}\n\t/* COMMENT_17 */\n\tVAR_10->last_activity = janus_get_monotonic_time();\n\tVAR_11 = NULL;\n\tif(VAR_7 > 0) {\n\t\tVAR_11 = janus_session_handles_find(VAR_10, VAR_7);\n\t\tif(!VAR_11) {\n\t\t\tJANUS_LOG(VAR_2, \"Couldn't find any handle %\"VAR_32\" in session %\"VAR_32\"...\\n\", VAR_7, VAR_6);\n\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_33, \"No such handle %\"VAR_32\" in session %\"VAR_32\"\", VAR_7, VAR_6);\n\t\t\tgoto jsondone;\n\t\t}\n\t}\n\n\t/* COMMENT_18 */\n\tif(!strcasecmp(VAR_18, \"keepalive\")) {\n\t\t/* COMMENT_19 */\n\t\tJANUS_LOG(VAR_34, \"Got a keep-alive on session %\"VAR_32\"\\n\", VAR_6);\n\t\tjson_t *VAR_19 = janus_create_message(\"ack\", VAR_6, VAR_16);\n\t\t/* COMMENT_14 */\n\t\tVAR_1 = janus_process_success(VAR_0, VAR_19);\n\t} else if(!strcasecmp(VAR_18, \"attach\")) {\n\t\tif(VAR_11 != NULL) {\n\t\t\t/* COMMENT_20 */\n\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_20, \"Unhandled request '%s' at this path\", VAR_18);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tJANUS_VALIDATE_JSON_OBJECT(VAR_5, VAR_35,\n\t\t\tVAR_3, VAR_4, FALSE,\n\t\t\tVAR_13, VAR_14);\n\t\tif(VAR_3 != 0) {\n\t\t\tVAR_1 = janus_process_error_string(VAR_0, VAR_6, VAR_16, VAR_3, VAR_4);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjson_t *VAR_36 = json_object_get(VAR_5, \"plugin\");\n\t\tconst gchar *VAR_37 = json_string_value(VAR_36);\n\t\tjanus_plugin *VAR_38 = janus_plugin_find(VAR_37);\n\t\tif(VAR_38 == NULL) {\n\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_39, \"No such plugin '%s'\", VAR_37);\n\t\t\tgoto jsondone;\n\t\t}\n\t\t/* COMMENT_21 */\n\t\tif(janus_auth_is_enabled()) {\n\t\t\tjson_t *VAR_40 = json_object_get(VAR_5, \"token\");\n\t\t\tif(VAR_40 != NULL) {\n\t\t\t\tconst char *VAR_41 = json_string_value(VAR_40);\n\t\t\t\tif(VAR_41 && !janus_auth_check_plugin(VAR_41, VAR_38)) {\n\t\t\t\t\tJANUS_LOG(VAR_2, \"Token '%s' can't access plugin '%s'\\n\", VAR_41, VAR_37);\n\t\t\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_42, \"Provided token can't access plugin '%s'\", VAR_37);\n\t\t\t\t\tgoto jsondone;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tjson_t *VAR_43 = json_object_get(VAR_5, \"opaque_id\");\n\t\tconst char *VAR_44 = VAR_43 ? json_string_value(VAR_43) : NULL;\n\t\t/* COMMENT_22 */\n\t\tVAR_11 = janus_ice_handle_create(VAR_10, VAR_44);\n\t\tif(VAR_11 == NULL) {\n\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_26, \"Memory error\");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tVAR_7 = VAR_11->handle_id;\n\t\t/* COMMENT_23 */\n\t\tjanus_refcount_increase(&VAR_11->ref);\n\t\t/* COMMENT_24 */\n\t\tint VAR_45 = 0;\n\t\tif((VAR_45 = janus_ice_handle_attach_plugin(VAR_10, VAR_11, VAR_38)) != 0) {\n\t\t\t/* COMMENT_25 */\n\t\t\tjanus_session_handles_remove(VAR_10, VAR_11);\n\t\t\tJANUS_LOG(VAR_2, \"Couldn't attach to plugin '%s', error '%d'\\n\", VAR_37, VAR_45);\n\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_46, \"Couldn't attach to plugin: error '%d'\", VAR_45);\n\t\t\tgoto jsondone;\n\t\t}\n\t\t/* COMMENT_3 */\n\t\tjson_t *VAR_19 = janus_create_message(\"success\", VAR_6, VAR_16);\n\t\tjson_t *VAR_30 = json_object();\n\t\tjson_object_set_new(VAR_30, \"id\", json_integer(VAR_7));\n\t\tjson_object_set_new(VAR_19, \"data\", VAR_30);\n\t\t/* COMMENT_14 */\n\t\tVAR_1 = janus_process_success(VAR_0, VAR_19);\n\t} else if(!strcasecmp(VAR_18, \"destroy\")) {\n\t\tif(VAR_11 != NULL) {\n\t\t\t/* COMMENT_26 */\n\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_20, \"Unhandled request '%s' at this path\", VAR_18);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjanus_mutex_lock(&VAR_47);\n\t\tg_hash_table_remove(VAR_48, &VAR_10->session_id);\n\t\tjanus_mutex_unlock(&VAR_47);\n\t\t/* COMMENT_27 */\n\t\tif(VAR_10->source && VAR_10->source->transport) {\n\t\t\tVAR_10->source->transport->session_over(VAR_10->source->instance, VAR_10->session_id, FALSE, FALSE);\n\t\t}\n\t\t/* COMMENT_28 */\n\t\tjanus_session_destroy(VAR_10);\n\n\t\t/* COMMENT_3 */\n\t\tjson_t *VAR_19 = janus_create_message(\"success\", VAR_6, VAR_16);\n\t\t/* COMMENT_14 */\n\t\tVAR_1 = janus_process_success(VAR_0, VAR_19);\n\t\t/* COMMENT_29 */\n\t\tif(janus_events_is_enabled())\n\t\t\tjanus_events_notify_handlers(VAR_28, VAR_29,\n\t\t\t\tVAR_6, \"destroyed\", NULL);\n\t} else if(!strcasecmp(VAR_18, \"detach\")) {\n\t\tif(VAR_11 == NULL) {\n\t\t\t/* COMMENT_30 */\n\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_20, \"Unhandled request '%s' at this path\", VAR_18);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(VAR_11->app == NULL || VAR_11->app_handle == NULL) {\n\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_49, \"No plugin to detach from\");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tint VAR_45 = janus_session_handles_remove(VAR_10, VAR_11);\n\t\tif(VAR_45 != 0) {\n\t\t\t/* COMMENT_25 */\n\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_49, \"Couldn't detach from plugin: error '%d'\", VAR_45);\n\t\t\t/* COMMENT_31 */\n\t\t\tgoto jsondone;\n\t\t}\n\t\t/* COMMENT_3 */\n\t\tjson_t *VAR_19 = janus_create_message(\"success\", VAR_6, VAR_16);\n\t\t/* COMMENT_14 */\n\t\tVAR_1 = janus_process_success(VAR_0, VAR_19);\n\t} else if(!strcasecmp(VAR_18, \"hangup\")) {\n\t\tif(VAR_11 == NULL) {\n\t\t\t/* COMMENT_30 */\n\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_20, \"Unhandled request '%s' at this path\", VAR_18);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(VAR_11->app == NULL || VAR_11->app_handle == NULL) {\n\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_49, \"No plugin attached\");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjanus_ice_webrtc_hangup(VAR_11, \"Janus API\");\n\t\t/* COMMENT_3 */\n\t\tjson_t *VAR_19 = janus_create_message(\"success\", VAR_6, VAR_16);\n\t\t/* COMMENT_14 */\n\t\tVAR_1 = janus_process_success(VAR_0, VAR_19);\n\t} else if(!strcasecmp(VAR_18, \"claim\")) {\n\t\tjanus_mutex_lock(&VAR_10->mutex);\n\t\tif(VAR_10->source != NULL) {\n\t\t\t/* COMMENT_32 */\n\t\t\tVAR_10->source->transport->session_over(VAR_10->source->instance, VAR_10->session_id, FALSE, TRUE);\n\t\t\tjanus_request_destroy(VAR_10->source);\n\t\t\tVAR_10->source = NULL;\n\t\t}\n\t\tVAR_10->source = janus_request_new(VAR_0->transport, VAR_0->instance, NULL, FALSE, NULL);\n\t\t/* COMMENT_33 */\n\t\tVAR_10->source->transport->session_claimed(VAR_10->source->instance, VAR_10->session_id);\n\t\t/* COMMENT_34 */\n\t\tg_atomic_int_set(&VAR_10->transport_gone, 0);\n\t\tjanus_mutex_unlock(&VAR_10->mutex);\n\t\t/* COMMENT_3 */\n\t\tjson_t *VAR_19 = json_object();\n\t\tjson_object_set_new(VAR_19, \"janus\", json_string(\"success\"));\n\t\tjson_object_set_new(VAR_19, \"session_id\", json_integer(VAR_6));\n\t\tjson_object_set_new(VAR_19, \"transaction\", json_string(VAR_16));\n\t\t/* COMMENT_14 */\n\t\tVAR_1 = janus_process_success(VAR_0, VAR_19);\n\t} else if(!strcasecmp(VAR_18, \"message\")) {\n\t\tif(VAR_11 == NULL) {\n\t\t\t/* COMMENT_30 */\n\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_20, \"Unhandled request '%s' at this path\", VAR_18);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(VAR_11->app == NULL || VAR_11->app_handle == NULL) {\n\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_50, \"No plugin to handle this message\");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjanus_plugin *VAR_38 = (janus_plugin *)VAR_11->app;\n\t\tJANUS_LOG(VAR_34, \"[%\"VAR_32\"] There's a message for %s\\n\", VAR_11->handle_id, VAR_38->get_name());\n\t\tJANUS_VALIDATE_JSON_OBJECT(VAR_5, VAR_51,\n\t\t\tVAR_3, VAR_4, FALSE,\n\t\t\tVAR_13, VAR_14);\n\t\tif(VAR_3 != 0) {\n\t\t\tVAR_1 = janus_process_error_string(VAR_0, VAR_6, VAR_16, VAR_3, VAR_4);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjson_t *VAR_52 = json_object_get(VAR_5, \"body\");\n\t\t/* COMMENT_35 */\n\t\tjson_t *VAR_53 = json_object_get(VAR_5, \"jsep\");\n\t\tchar *VAR_54 = NULL;\n\t\tchar *VAR_55 = NULL, *VAR_56 = NULL;\n\t\tgboolean VAR_57 = FALSE;\n\t\tif(VAR_53 != NULL) {\n\t\t\tif(!json_is_object(VAR_53)) {\n\t\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_58, \"Invalid jsep object\");\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\tJANUS_VALIDATE_JSON_OBJECT_FORMAT(\"JSEP error: missing mandatory element (%s)\",\n\t\t\t\t\"JSEP error: invalid element type (%s should be %s)\",\n\t\t\t\tVAR_53, VAR_59, VAR_3, VAR_4, FALSE,\n\t\t\t\tVAR_13, VAR_14);\n\t\t\tif(VAR_3 != 0) {\n\t\t\t\tVAR_1 = janus_process_error_string(VAR_0, VAR_6, VAR_16, VAR_3, VAR_4);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\tjson_t *VAR_60 = json_object_get(VAR_53, \"type\");\n\t\t\tVAR_54 = g_strdup(json_string_value(VAR_60));\n\t\t\tVAR_60 = NULL;\n\t\t\tgboolean VAR_61 = TRUE;\n\t\t\tjson_t *VAR_62 = json_object_get(VAR_53, \"trickle\");\n\t\t\tVAR_61 = VAR_62 ? json_is_true(VAR_62) : TRUE;\n\t\t\t/* COMMENT_36 */\n\t\t\tif(janus_flags_is_set(&VAR_11->webrtc_flags, VAR_63)) {\n\t\t\t\tJANUS_LOG(VAR_34, \"[%\"VAR_32\"] Still cleaning up from a previous media session, let's wait a bit...\\n\", VAR_11->handle_id);\n\t\t\t\tgint64 VAR_64 = 0;\n\t\t\t\twhile(janus_flags_is_set(&VAR_11->webrtc_flags, VAR_63)) {\n\t\t\t\t\tg_usleep(100000);\n\t\t\t\t\tVAR_64 += 100000;\n\t\t\t\t\tif(VAR_64 >= 3*VAR_65) {\n\t\t\t\t\t\tJANUS_LOG(VAR_34, \"[%\"VAR_32\"]   -- Waited 3 seconds, that's enough!\\n\", VAR_11->handle_id);\n\t\t\t\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_66, \"Still cleaning a previous session\");\n\t\t\t\t\t\tgoto jsondone;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* COMMENT_37 */\n\t\t\tVAR_57 = janus_flags_is_set(&VAR_11->webrtc_flags, VAR_67);\n\t\t\t/* COMMENT_38 */\n\t\t\tjanus_mutex_lock(&VAR_11->mutex);\n\t\t\tint VAR_68 = 0;\n\t\t\tif(!strcasecmp(VAR_54, \"offer\")) {\n\t\t\t\tVAR_68 = 1;\n\t\t\t\tjanus_flags_set(&VAR_11->webrtc_flags, VAR_69);\n\t\t\t\tjanus_flags_set(&VAR_11->webrtc_flags, VAR_70);\n\t\t\t\tjanus_flags_clear(&VAR_11->webrtc_flags, VAR_71);\n\t\t\t} else if(!strcasecmp(VAR_54, \"answer\")) {\n\t\t\t\tjanus_flags_set(&VAR_11->webrtc_flags, VAR_71);\n\t\t\t\tif(janus_flags_is_set(&VAR_11->webrtc_flags, VAR_70))\n\t\t\t\t\tjanus_flags_set(&VAR_11->webrtc_flags, VAR_67);\n\t\t\t\tVAR_68 = 0;\n\t\t\t} else {\n\t\t\t\t/* COMMENT_39 */\n\t\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_72, \"JSEP error: unknown message type '%s'\", VAR_54);\n\t\t\t\tg_free(VAR_54);\n\t\t\t\tjanus_flags_clear(&VAR_11->webrtc_flags, VAR_69);\n\t\t\t\tjanus_mutex_unlock(&VAR_11->mutex);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\tjson_t *VAR_73 = json_object_get(VAR_53, \"sdp\");\n\t\t\tVAR_55 = (char *)json_string_value(VAR_73);\n\t\t\tJANUS_LOG(VAR_34, \"[%\"VAR_32\"] Remote SDP:\\n%s\", VAR_11->handle_id, VAR_55);\n\t\t\t/* COMMENT_40 */\n\t\t\tchar VAR_74[512];\n\t\t\tint VAR_75 = 0, VAR_76 = 0, VAR_30 = 0;\n\t\t\tjanus_sdp *VAR_77 = janus_sdp_preparse(VAR_11, VAR_55, VAR_74, sizeof(VAR_74), &VAR_75, &VAR_76, &VAR_30);\n\t\t\tif(VAR_77 == NULL) {\n\t\t\t\t/* COMMENT_41 */\n\t\t\t\tVAR_1 = janus_process_error_string(VAR_0, VAR_6, VAR_16, VAR_78, VAR_74);\n\t\t\t\tg_free(VAR_54);\n\t\t\t\tjanus_flags_clear(&VAR_11->webrtc_flags, VAR_69);\n\t\t\t\tjanus_mutex_unlock(&VAR_11->mutex);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\t/* COMMENT_12 */\n\t\t\tif(janus_events_is_enabled()) {\n\t\t\t\tjanus_events_notify_handlers(VAR_79, VAR_29,\n\t\t\t\t\tVAR_6, VAR_7, VAR_11->opaque_id, \"remote\", VAR_54, VAR_55);\n\t\t\t}\n\t\t\t/* COMMENT_42 */\n\t\t\tJANUS_LOG(VAR_34, \"[%\"VAR_32\"] Audio %s been negotiated, Video %s been negotiated, SCTP/DataChannels %s been negotiated\\n\",\n\t\t\t                    VAR_11->handle_id,\n\t\t\t                    VAR_75 ? \"has\" : \"has NOT\",\n\t\t\t                    VAR_76 ? \"has\" : \"has NOT\",\n\t\t\t                    VAR_30 ? \"have\" : \"have NOT\");\n\t\t\tif(VAR_75 > 1) {\n\t\t\t\tJANUS_LOG(VAR_80, \"[%\"VAR_32\"] More than one audio line? only going to negotiate one...\\n\", VAR_11->handle_id);\n\t\t\t}\n\t\t\tif(VAR_76 > 1) {\n\t\t\t\tJANUS_LOG(VAR_80, \"[%\"VAR_32\"] More than one video line? only going to negotiate one...\\n\", VAR_11->handle_id);\n\t\t\t}\n\t\t\tif(VAR_30 > 1) {\n\t\t\t\tJANUS_LOG(VAR_80, \"[%\"VAR_32\"] More than one data line? only going to negotiate one...\\n\", VAR_11->handle_id);\n\t\t\t}\n#ifndef VAR_81\n\t\t\tif(VAR_30) {\n\t\t\t\tJANUS_LOG(VAR_80, \"[%\"VAR_32\"]   -- DataChannels have been negotiated, but support for them has not been compiled...\\n\", VAR_11->handle_id);\n\t\t\t}\n#endif\n\t\t\t/* COMMENT_43 */\n\t\t\tif(!VAR_57) {\n\t\t\t\t/* COMMENT_44 */\n\t\t\t\tif(VAR_68) {\n\t\t\t\t\t/* COMMENT_45 */\n\t\t\t\t\tif(janus_ice_setup_local(VAR_11, VAR_68, VAR_75, VAR_76, VAR_30, VAR_61) < 0) {\n\t\t\t\t\t\tJANUS_LOG(VAR_2, \"Error setting ICE locally\\n\");\n\t\t\t\t\t\tjanus_sdp_destroy(VAR_77);\n\t\t\t\t\t\tg_free(VAR_54);\n\t\t\t\t\t\tjanus_flags_clear(&VAR_11->webrtc_flags, VAR_69);\n\t\t\t\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_26, \"Error setting ICE locally\");\n\t\t\t\t\t\tjanus_mutex_unlock(&VAR_11->mutex);\n\t\t\t\t\t\tgoto jsondone;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t/* COMMENT_46 */\n\t\t\t\t\tif(!VAR_11->agent) {\n\t\t\t\t\t\tJANUS_LOG(VAR_2, \"Unexpected ANSWER (did we offer?)\\n\");\n\t\t\t\t\t\tjanus_sdp_destroy(VAR_77);\n\t\t\t\t\t\tg_free(VAR_54);\n\t\t\t\t\t\tjanus_flags_clear(&VAR_11->webrtc_flags, VAR_69);\n\t\t\t\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_82, \"Unexpected ANSWER (did we offer?)\");\n\t\t\t\t\t\tjanus_mutex_unlock(&VAR_11->mutex);\n\t\t\t\t\t\tgoto jsondone;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(janus_sdp_process(VAR_11, VAR_77, FALSE) < 0) {\n\t\t\t\t\tJANUS_LOG(VAR_2, \"Error processing SDP\\n\");\n\t\t\t\t\tjanus_sdp_destroy(VAR_77);\n\t\t\t\t\tg_free(VAR_54);\n\t\t\t\t\tjanus_flags_clear(&VAR_11->webrtc_flags, VAR_69);\n\t\t\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_78, \"Error processing SDP\");\n\t\t\t\t\tjanus_mutex_unlock(&VAR_11->mutex);\n\t\t\t\t\tgoto jsondone;\n\t\t\t\t}\n\t\t\t\tif(!VAR_68) {\n\t\t\t\t\t/* COMMENT_47 */\n\t\t\t\t\tif(VAR_61) {\n\t\t\t\t\t\tjanus_flags_set(&VAR_11->webrtc_flags, VAR_83);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tjanus_flags_clear(&VAR_11->webrtc_flags, VAR_83);\n\t\t\t\t\t}\n\t\t\t\t\tjanus_request_ice_handle_answer(VAR_11, VAR_75, VAR_76, VAR_30, VAR_55);\n\t\t\t\t} else {\n\t\t\t\t\t/* COMMENT_48 */\n\t\t\t\t\tVAR_11->stream->mid_ext_id = janus_rtp_header_extension_get_id(VAR_55, VAR_84);\n\t\t\t\t\t/* COMMENT_49 */\n\t\t\t\t\tVAR_11->stream->rid_ext_id = janus_rtp_header_extension_get_id(VAR_55, VAR_85);\n\t\t\t\t\tVAR_11->stream->ridrtx_ext_id = janus_rtp_header_extension_get_id(VAR_55, VAR_86);\n\t\t\t\t\t/* COMMENT_50 */\n\t\t\t\t\tVAR_11->stream->audiolevel_ext_id = janus_rtp_header_extension_get_id(VAR_55, VAR_87);\n\t\t\t\t\t/* COMMENT_51 */\n\t\t\t\t\tVAR_11->stream->videoorientation_ext_id = janus_rtp_header_extension_get_id(VAR_55, VAR_88);\n\t\t\t\t\t/* COMMENT_52 */\n\t\t\t\t\tVAR_11->stream->framemarking_ext_id = janus_rtp_header_extension_get_id(VAR_55, VAR_89);\n\t\t\t\t\t/* COMMENT_53 */\n\t\t\t\t\tint VAR_90 = janus_rtp_header_extension_get_id(VAR_55, VAR_91);\n\t\t\t\t\tVAR_11->stream->do_transport_wide_cc = VAR_90 > 0 ? TRUE : FALSE;\n\t\t\t\t\tVAR_11->stream->transport_wide_cc_ext_id = VAR_90;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* COMMENT_54 */\n                                                                                             \n\t\t\t\tJANUS_LOG(VAR_92, \"[%\"VAR_32\"] Negotiation update, checking what changed...\\n\", VAR_11->handle_id);\n\t\t\t\tif(janus_sdp_process(VAR_11, VAR_77, TRUE) < 0) {\n\t\t\t\t\tJANUS_LOG(VAR_2, \"Error processing SDP\\n\");\n\t\t\t\t\tjanus_sdp_destroy(VAR_77);\n\t\t\t\t\tg_free(VAR_54);\n\t\t\t\t\tjanus_flags_clear(&VAR_11->webrtc_flags, VAR_69);\n\t\t\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_82, \"Error processing SDP\");\n\t\t\t\t\tjanus_mutex_unlock(&VAR_11->mutex);\n\t\t\t\t\tgoto jsondone;\n\t\t\t\t}\n\t\t\t\tif(janus_flags_is_set(&VAR_11->webrtc_flags, VAR_93)) {\n\t\t\t\t\tJANUS_LOG(VAR_92, \"[%\"VAR_32\"] Restarting ICE...\\n\", VAR_11->handle_id);\n\t\t\t\t\t/* COMMENT_56 */\n\t\t\t\t\tif(VAR_11->stream) {\n\t\t\t\t\t\tnice_agent_set_remote_credentials(VAR_11->agent, VAR_11->stream->stream_id,\n\t\t\t\t\t\t\tVAR_11->stream->ruser, VAR_11->stream->rpass);\n\t\t\t\t\t}\n\t\t\t\t\t/* COMMENT_57 */\n\t\t\t\t\tif(VAR_68) {\n\t\t\t\t\t\tjanus_ice_restart(VAR_11);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tjanus_flags_clear(&VAR_11->webrtc_flags, VAR_93);\n\t\t\t\t\t}\n\t\t\t\t\t/* COMMENT_58 */\n\t\t\t\t\tif(janus_ice_is_full_trickle_enabled()) {\n\t\t\t\t\t\tjanus_flags_set(&VAR_11->webrtc_flags, VAR_94);\n\t\t\t\t\t}\n\t\t\t\t}\n#ifdef VAR_81\n\t\t\t\tif(!VAR_68) {\n\t\t\t\t\t/* COMMENT_59 */\n\t\t\t\t\tif(janus_flags_is_set(&VAR_11->webrtc_flags, VAR_95)) {\n\t\t\t\t\t\tjanus_ice_stream *VAR_96 = VAR_11->stream;\n\t\t\t\t\t\tif(VAR_96 != NULL && VAR_96->component != NULL\n\t\t\t\t\t\t\t\t&& VAR_96->component->dtls != NULL && VAR_96->component->dtls->sctp == NULL) {\n\t\t\t\t\t\t\t/* COMMENT_60 */\n\t\t\t\t\t\t\tJANUS_LOG(VAR_80, \"[%\"VAR_32\"] Creating datachannels...\\n\", VAR_11->handle_id);\n\t\t\t\t\t\t\tjanus_dtls_srtp_create_sctp(VAR_96->component->dtls);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t\tchar *VAR_97 = VAR_11->remote_sdp;\n\t\t\tVAR_11->remote_sdp = g_strdup(VAR_55);\n\t\t\tg_free(VAR_97);\n\t\t\tjanus_mutex_unlock(&VAR_11->mutex);\n\t\t\t/* COMMENT_61 */\n\t\t\tif(janus_sdp_anonymize(VAR_77) < 0) {\n\t\t\t\t/* COMMENT_41 */\n\t\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_78, \"JSEP error: invalid SDP\");\n\t\t\t\tjanus_sdp_destroy(VAR_77);\n\t\t\t\tg_free(VAR_54);\n\t\t\t\tjanus_flags_clear(&VAR_11->webrtc_flags, VAR_69);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\tVAR_56 = janus_sdp_write(VAR_77);\n\t\t\tjanus_sdp_destroy(VAR_77);\n\t\t\tVAR_73 = NULL;\n\t\t\tjanus_flags_clear(&VAR_11->webrtc_flags, VAR_69);\n\t\t}\n\n\t\t/* COMMENT_62 */\n\t\tif(VAR_11->app == NULL || !janus_plugin_session_is_alive(VAR_11->app_handle)) {\n\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_50, \"No plugin to handle this message\");\n\t\t\tg_free(VAR_54);\n\t\t\tg_free(VAR_56);\n\t\t\tjanus_flags_clear(&VAR_11->webrtc_flags, VAR_69);\n\t\t\tgoto jsondone;\n\t\t}\n\n\t\t/* COMMENT_63 */\n\t\tjson_incref(VAR_52);\n\t\tjson_t *VAR_98 = NULL;\n\t\tif(VAR_56) {\n\t\t\tVAR_98 = json_pack(\"{ssss}\", \"type\", VAR_54, \"sdp\", VAR_56);\n\t\t\t/* COMMENT_64 */\n\t\t\tif(janus_flags_is_set(&VAR_11->webrtc_flags, VAR_99)) {\n\t\t\t\tif(VAR_11->stream && (VAR_11->stream->rid[0] || VAR_11->stream->video_ssrc_peer[1])) {\n\t\t\t\t\tjson_t *VAR_100 = json_object();\n\t\t\t\t\t/* COMMENT_65 */\n\t\t\t\t\tif(VAR_11->stream->rid[0]) {\n\t\t\t\t\t\tjson_t *VAR_101 = json_array();\n\t\t\t\t\t\tjson_array_append_new(VAR_101, json_string(VAR_11->stream->rid[0]));\n\t\t\t\t\t\tif(VAR_11->stream->rid[1])\n\t\t\t\t\t\t\tjson_array_append_new(VAR_101, json_string(VAR_11->stream->rid[1]));\n\t\t\t\t\t\tif(VAR_11->stream->rid[2])\n\t\t\t\t\t\t\tjson_array_append_new(VAR_101, json_string(VAR_11->stream->rid[2]));\n\t\t\t\t\t\tjson_object_set_new(VAR_100, \"rids\", VAR_101);\n\t\t\t\t\t\tjson_object_set_new(VAR_100, \"rid-ext\", json_integer(VAR_11->stream->rid_ext_id));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tjson_t *VAR_102 = json_array();\n\t\t\t\t\t\tjson_array_append_new(VAR_102, json_integer(VAR_11->stream->video_ssrc_peer[0]));\n\t\t\t\t\t\tif(VAR_11->stream->video_ssrc_peer[1])\n\t\t\t\t\t\t\tjson_array_append_new(VAR_102, json_integer(VAR_11->stream->video_ssrc_peer[1]));\n\t\t\t\t\t\tif(VAR_11->stream->video_ssrc_peer[2])\n\t\t\t\t\t\t\tjson_array_append_new(VAR_102, json_integer(VAR_11->stream->video_ssrc_peer[2]));\n\t\t\t\t\t\tjson_object_set_new(VAR_100, \"ssrcs\", VAR_102);\n\t\t\t\t\t}\n\t\t\t\t\tif(VAR_11->stream->framemarking_ext_id > 0)\n\t\t\t\t\t\tjson_object_set_new(VAR_100, \"framemarking-ext\", json_integer(VAR_11->stream->framemarking_ext_id));\n\t\t\t\t\tjson_object_set_new(VAR_98, \"simulcast\", VAR_100);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* COMMENT_66 */\n\t\t\tif(VAR_57)\n\t\t\t\tjson_object_set_new(VAR_98, \"update\", json_true());\n\t\t}\n\t\tjanus_plugin_result *VAR_103 = VAR_38->handle_message(VAR_11->app_handle,\n\t\t\tg_strdup((char *)VAR_16), VAR_52, VAR_98);\n\t\tg_free(VAR_54);\n\t\tg_free(VAR_56);\n\t\tif(VAR_103 == NULL) {\n\t\t\t/* COMMENT_67 */\n\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_50, \"Plugin didn't give a result\");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(VAR_103->type == VAR_104) {\n\t\t\t/* COMMENT_68 */\n\t\t\tif(VAR_103->content == NULL || !json_is_object(VAR_103->content)) {\n\t\t\t\t/* COMMENT_69 */\n\t\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_50,\n\t\t\t\t\tVAR_103->content == NULL ?\n\t\t\t\t\t\t\"Plugin didn't provide any content for this synchronous response\" :\n\t\t\t\t\t\t\"Plugin returned an invalid JSON response\");\n\t\t\t\tjanus_plugin_result_destroy(VAR_103);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\t/* COMMENT_70 */\n\t\t\tjson_incref(VAR_103->content);\n\t\t\t/* COMMENT_71 */\n\t\t\tjson_t *VAR_19 = janus_create_message(\"success\", VAR_10->session_id, VAR_16);\n\t\t\tjson_object_set_new(VAR_19, \"sender\", json_integer(VAR_11->handle_id));\n\t\t\tif(janus_is_opaqueid_in_api_enabled() && VAR_11->opaque_id != NULL)\n\t\t\t\tjson_object_set_new(VAR_19, \"opaque_id\", json_string(VAR_11->opaque_id));\n\t\t\tjson_t *VAR_105 = json_object();\n\t\t\tjson_object_set_new(VAR_105, \"plugin\", json_string(VAR_38->get_package()));\n\t\t\tjson_object_set_new(VAR_105, \"data\", VAR_103->content);\n\t\t\tjson_object_set_new(VAR_19, \"plugindata\", VAR_105);\n\t\t\t/* COMMENT_14 */\n\t\t\tVAR_1 = janus_process_success(VAR_0, VAR_19);\n\t\t} else if(VAR_103->type == VAR_106) {\n\t\t\t/* COMMENT_72 */\n\t\t\tjson_t *VAR_19 = janus_create_message(\"ack\", VAR_6, VAR_16);\n\t\t\tif(VAR_103->text)\n\t\t\t\tjson_object_set_new(VAR_19, \"hint\", json_string(VAR_103->text));\n\t\t\t/* COMMENT_14 */\n\t\t\tVAR_1 = janus_process_success(VAR_0, VAR_19);\n\t\t} else {\n\t\t\t/* COMMENT_67 */\n\t\t\tVAR_1 = janus_process_error_string(VAR_0, VAR_6, VAR_16, VAR_50,\n\t\t\t\t(char *)(VAR_103->text ? VAR_103->text : \"Plugin returned a severe (unknown) error\"));\n\t\t\tjanus_plugin_result_destroy(VAR_103);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjanus_plugin_result_destroy(VAR_103);\n\t} else if(!strcasecmp(VAR_18, \"trickle\")) {\n\t\tif(VAR_11 == NULL) {\n\t\t\t/* COMMENT_73 */\n\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_20, \"Unhandled request '%s' at this path\", VAR_18);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(VAR_11->app == NULL || !janus_plugin_session_is_alive(VAR_11->app_handle)) {\n\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_50, \"No plugin to handle this trickle candidate\");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjson_t *VAR_107 = json_object_get(VAR_5, \"candidate\");\n\t\tjson_t *VAR_108 = json_object_get(VAR_5, \"candidates\");\n\t\tif(VAR_107 == NULL && VAR_108 == NULL) {\n\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_13, \"Missing mandatory element (candidate|candidates)\");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(VAR_107 != NULL && VAR_108 != NULL) {\n\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_109, \"Can't have both candidate and candidates\");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(janus_flags_is_set(&VAR_11->webrtc_flags, VAR_63)) {\n\t\t\tJANUS_LOG(VAR_2, \"[%\"VAR_32\"] Received a trickle, but still cleaning a previous session\\n\", VAR_11->handle_id);\n\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_66, \"Still cleaning a previous session\");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjanus_mutex_lock(&VAR_11->mutex);\n\t\tif(!janus_flags_is_set(&VAR_11->webrtc_flags, VAR_83)) {\n\t\t\t/* COMMENT_74 */\n\t\t\tJANUS_LOG(VAR_34, \"Handle %\"VAR_32\" supports trickle even if it didn't negotiate it...\\n\", VAR_11->handle_id);\n\t\t\tjanus_flags_set(&VAR_11->webrtc_flags, VAR_83);\n\t\t}\n\t\t/* COMMENT_75 */\n\t\tif(VAR_11->stream == NULL) {\n\t\t\tJANUS_LOG(VAR_80, \"[%\"VAR_32\"] No stream, queueing this trickle as it got here before the SDP...\\n\", VAR_11->handle_id);\n\t\t\t/* COMMENT_76 */\n\t\t\tjanus_ice_trickle *VAR_110 = janus_ice_trickle_new(VAR_16, VAR_107 ? VAR_107 : VAR_108);\n\t\t\tVAR_11->pending_trickles = g_list_append(VAR_11->pending_trickles, VAR_110);\n\t\t\t/* COMMENT_77 */\n\t\t\tgoto trickledone;\n\t\t}\n\t\t/* COMMENT_78 */\n\t\tif(janus_flags_is_set(&VAR_11->webrtc_flags, VAR_69) ||\n\t\t\t\t!janus_flags_is_set(&VAR_11->webrtc_flags, VAR_70) ||\n\t\t\t\t!janus_flags_is_set(&VAR_11->webrtc_flags, VAR_71)) {\n\t\t\tconst char *VAR_111 = NULL;\n\t\t\tif(janus_flags_is_set(&VAR_11->webrtc_flags, VAR_69))\n\t\t\t\tVAR_111 = \"processing the offer\";\n\t\t\telse if(!janus_flags_is_set(&VAR_11->webrtc_flags, VAR_71))\n\t\t\t\tVAR_111 = \"waiting for the answer\";\n\t\t\telse if(!janus_flags_is_set(&VAR_11->webrtc_flags, VAR_70))\n\t\t\t\tVAR_111 = \"waiting for the offer\";\n\t\t\tJANUS_LOG(VAR_34, \"[%\"VAR_32\"] Still %s, queueing this trickle to wait until we're done there...\\n\",\n\t\t\t\tVAR_11->handle_id, VAR_111);\n\t\t\t/* COMMENT_76 */\n\t\t\tjanus_ice_trickle *VAR_110 = janus_ice_trickle_new(VAR_16, VAR_107 ? VAR_107 : VAR_108);\n\t\t\tVAR_11->pending_trickles = g_list_append(VAR_11->pending_trickles, VAR_110);\n\t\t\t/* COMMENT_77 */\n\t\t\tgoto trickledone;\n\t\t}\n\t\tif(VAR_107 != NULL) {\n\t\t\t/* COMMENT_79 */\n\t\t\tint VAR_45 = 0;\n\t\t\tconst char *VAR_112 = NULL;\n\t\t\tif((VAR_45 = janus_ice_trickle_parse(VAR_11, VAR_107, &VAR_112)) != 0) {\n\t\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_45, \"%s\", VAR_112);\n\t\t\t\tjanus_mutex_unlock(&VAR_11->mutex);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t} else {\n\t\t\t/* COMMENT_80 */\n\t\t\tif(!json_is_array(VAR_108)) {\n\t\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_14, \"candidates is not an array\");\n\t\t\t\tjanus_mutex_unlock(&VAR_11->mutex);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\tJANUS_LOG(VAR_34, \"Got multiple candidates (%zu)\\n\", json_array_size(VAR_108));\n\t\t\tif(json_array_size(VAR_108) > 0) {\n\t\t\t\t/* COMMENT_81 */\n\t\t\t\tsize_t VAR_113 = 0;\n\t\t\t\tfor(VAR_113=0; VAR_113<json_array_size(VAR_108); VAR_113++) {\n\t\t\t\t\tjson_t *VAR_114 = json_array_get(VAR_108, VAR_113);\n\t\t\t\t\t/* COMMENT_82 */\n\t\t\t\t\tjanus_ice_trickle_parse(VAR_11, VAR_114, NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\ntrickledone:\n\t\tjanus_mutex_unlock(&VAR_11->mutex);\n\t\t/* COMMENT_83 */\n\t\tjson_t *VAR_19 = janus_create_message(\"ack\", VAR_6, VAR_16);\n\t\t/* COMMENT_14 */\n\t\tVAR_1 = janus_process_success(VAR_0, VAR_19);\n\t} else {\n\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_115, \"Unknown request '%s'\", VAR_18);\n\t}\n\njsondone:\n\t/* COMMENT_84 */\n\tif(VAR_11 != NULL)\n\t\tjanus_refcount_decrease(&VAR_11->ref);\n\tif(VAR_10 != NULL)\n\t\tjanus_refcount_decrease(&VAR_10->ref);\n\treturn VAR_1;\n}",
  "func_graph_path_before": "meetecho/janus-gateway/bc319056603295953f4a70999bc4553785c6e5ef/janus.c/vul/before/0.json",
  "func": "int janus_process_incoming_request(janus_request *request) {\n\tint ret = -1;\n\tif(request == NULL) {\n\t\tJANUS_LOG(LOG_ERR, \"Missing request or payload to process, giving up...\\n\");\n\t\treturn ret;\n\t}\n\tint error_code = 0;\n\tchar error_cause[100];\n\tjson_t *root = request->message;\n\t/* Ok, let's start with the ids */\n\tguint64 session_id = 0, handle_id = 0;\n\tjson_t *s = json_object_get(root, \"session_id\");\n\tif(s && json_is_integer(s))\n\t\tsession_id = json_integer_value(s);\n\tjson_t *h = json_object_get(root, \"handle_id\");\n\tif(h && json_is_integer(h))\n\t\thandle_id = json_integer_value(h);\n\n\tjanus_session *session = NULL;\n\tjanus_ice_handle *handle = NULL;\n\n\t/* Get transaction and message request */\n\tJANUS_VALIDATE_JSON_OBJECT(root, incoming_request_parameters,\n\t\terror_code, error_cause, FALSE,\n\t\tJANUS_ERROR_MISSING_MANDATORY_ELEMENT, JANUS_ERROR_INVALID_ELEMENT_TYPE);\n\tif(error_code != 0) {\n\t\tret = janus_process_error_string(request, session_id, NULL, error_code, error_cause);\n\t\tgoto jsondone;\n\t}\n\tjson_t *transaction = json_object_get(root, \"transaction\");\n\tconst gchar *transaction_text = json_string_value(transaction);\n\tjson_t *message = json_object_get(root, \"janus\");\n\tconst gchar *message_text = json_string_value(message);\n\n\tif(session_id == 0 && handle_id == 0) {\n\t\t/* Can only be a 'Create new session', a 'Get info' or a 'Ping/Pong' request */\n\t\tif(!strcasecmp(message_text, \"info\")) {\n\t\t\tret = janus_process_success(request, janus_info(transaction_text));\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(!strcasecmp(message_text, \"ping\")) {\n\t\t\t/* Prepare JSON reply */\n\t\t\tjson_t *reply = janus_create_message(\"pong\", 0, transaction_text);\n\t\t\tret = janus_process_success(request, reply);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(strcasecmp(message_text, \"create\")) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_REQUEST_PATH, \"Unhandled request '%s' at this path\", message_text);\n\t\t\tgoto jsondone;\n\t\t}\n\t\t/* Make sure we're accepting new sessions */\n\t\tif(!accept_new_sessions) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_NOT_ACCEPTING_SESSIONS, NULL);\n\t\t\tgoto jsondone;\n\t\t}\n\t\t/* Any secret/token to check? */\n\t\tret = janus_request_check_secret(request, session_id, transaction_text);\n\t\tif(ret != 0) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNAUTHORIZED, NULL);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tsession_id = 0;\n\t\tjson_t *id = json_object_get(root, \"id\");\n\t\tif(id != NULL) {\n\t\t\t/* The application provided the session ID to use */\n\t\t\tsession_id = json_integer_value(id);\n\t\t\tif(session_id > 0 && (session = janus_session_find(session_id)) != NULL) {\n\t\t\t\t/* Session ID already taken */\n\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_SESSION_CONFLICT, \"Session ID already in use\");\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t}\n\t\t/* Handle it */\n\t\tsession = janus_session_create(session_id);\n\t\tif(session == NULL) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNKNOWN, \"Memory error\");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tsession_id = session->session_id;\n\t\t/* We increase the counter as this request is using the session */\n\t\tjanus_refcount_increase(&session->ref);\n\t\t/* Take note of the request source that originated this session (HTTP, WebSockets, RabbitMQ?) */\n\t\tsession->source = janus_request_new(request->transport, request->instance, NULL, FALSE, NULL);\n\t\t/* Notify the source that a new session has been created */\n\t\trequest->transport->session_created(request->instance, session->session_id);\n\t\t/* Notify event handlers */\n\t\tif(janus_events_is_enabled()) {\n\t\t\t/* Session created, add info on the transport that originated it */\n\t\t\tjson_t *transport = json_object();\n\t\t\tjson_object_set_new(transport, \"transport\", json_string(session->source->transport->get_package()));\n\t\t\tchar id[32];\n\t\t\tmemset(id, 0, sizeof(id));\n\t\t\tg_snprintf(id, sizeof(id), \"%p\", session->source->instance);\n\t\t\tjson_object_set_new(transport, \"id\", json_string(id));\n\t\t\tjanus_events_notify_handlers(JANUS_EVENT_TYPE_SESSION, JANUS_EVENT_SUBTYPE_NONE,\n\t\t\t\tsession_id, \"created\", transport);\n\t\t}\n\t\t/* Prepare JSON reply */\n\t\tjson_t *reply = janus_create_message(\"success\", 0, transaction_text);\n\t\tjson_t *data = json_object();\n\t\tjson_object_set_new(data, \"id\", json_integer(session_id));\n\t\tjson_object_set_new(reply, \"data\", data);\n\t\t/* Send the success reply */\n\t\tret = janus_process_success(request, reply);\n\t\tgoto jsondone;\n\t}\n\tif(session_id < 1) {\n\t\tJANUS_LOG(LOG_ERR, \"Invalid session\\n\");\n\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_SESSION_NOT_FOUND, NULL);\n\t\tgoto jsondone;\n\t}\n\tif(h && handle_id < 1) {\n\t\tJANUS_LOG(LOG_ERR, \"Invalid handle\\n\");\n\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_SESSION_NOT_FOUND, NULL);\n\t\tgoto jsondone;\n\t}\n\n\t/* Go on with the processing */\n\tret = janus_request_check_secret(request, session_id, transaction_text);\n\tif(ret != 0) {\n\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNAUTHORIZED, NULL);\n\t\tgoto jsondone;\n\t}\n\n\t/* If we got here, make sure we have a session (and/or a handle) */\n\tsession = janus_session_find(session_id);\n\tif(!session) {\n\t\tJANUS_LOG(LOG_ERR, \"Couldn't find any session %\"SCNu64\"...\\n\", session_id);\n\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_SESSION_NOT_FOUND, \"No such session %\"SCNu64\"\", session_id);\n\t\tgoto jsondone;\n\t}\n\t/* Update the last activity timer */\n\tsession->last_activity = janus_get_monotonic_time();\n\thandle = NULL;\n\tif(handle_id > 0) {\n\t\thandle = janus_session_handles_find(session, handle_id);\n\t\tif(!handle) {\n\t\t\tJANUS_LOG(LOG_ERR, \"Couldn't find any handle %\"SCNu64\" in session %\"SCNu64\"...\\n\", handle_id, session_id);\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_HANDLE_NOT_FOUND, \"No such handle %\"SCNu64\" in session %\"SCNu64\"\", handle_id, session_id);\n\t\t\tgoto jsondone;\n\t\t}\n\t}\n\n\t/* What is this? */\n\tif(!strcasecmp(message_text, \"keepalive\")) {\n\t\t/* Just a keep-alive message, reply with an ack */\n\t\tJANUS_LOG(LOG_VERB, \"Got a keep-alive on session %\"SCNu64\"\\n\", session_id);\n\t\tjson_t *reply = janus_create_message(\"ack\", session_id, transaction_text);\n\t\t/* Send the success reply */\n\t\tret = janus_process_success(request, reply);\n\t} else if(!strcasecmp(message_text, \"attach\")) {\n\t\tif(handle != NULL) {\n\t\t\t/* Attach is a session-level command */\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_REQUEST_PATH, \"Unhandled request '%s' at this path\", message_text);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tJANUS_VALIDATE_JSON_OBJECT(root, attach_parameters,\n\t\t\terror_code, error_cause, FALSE,\n\t\t\tJANUS_ERROR_MISSING_MANDATORY_ELEMENT, JANUS_ERROR_INVALID_ELEMENT_TYPE);\n\t\tif(error_code != 0) {\n\t\t\tret = janus_process_error_string(request, session_id, transaction_text, error_code, error_cause);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjson_t *plugin = json_object_get(root, \"plugin\");\n\t\tconst gchar *plugin_text = json_string_value(plugin);\n\t\tjanus_plugin *plugin_t = janus_plugin_find(plugin_text);\n\t\tif(plugin_t == NULL) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_NOT_FOUND, \"No such plugin '%s'\", plugin_text);\n\t\t\tgoto jsondone;\n\t\t}\n\t\t/* If the auth token mechanism is enabled, we should check if this token can access this plugin */\n\t\tif(janus_auth_is_enabled()) {\n\t\t\tjson_t *token = json_object_get(root, \"token\");\n\t\t\tif(token != NULL) {\n\t\t\t\tconst char *token_value = json_string_value(token);\n\t\t\t\tif(token_value && !janus_auth_check_plugin(token_value, plugin_t)) {\n\t\t\t\t\tJANUS_LOG(LOG_ERR, \"Token '%s' can't access plugin '%s'\\n\", token_value, plugin_text);\n\t\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNAUTHORIZED_PLUGIN, \"Provided token can't access plugin '%s'\", plugin_text);\n\t\t\t\t\tgoto jsondone;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tjson_t *opaque = json_object_get(root, \"opaque_id\");\n\t\tconst char *opaque_id = opaque ? json_string_value(opaque) : NULL;\n\t\t/* Create handle */\n\t\thandle = janus_ice_handle_create(session, opaque_id);\n\t\tif(handle == NULL) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNKNOWN, \"Memory error\");\n\t\t\tgoto jsondone;\n\t\t}\n\t\thandle_id = handle->handle_id;\n\t\t/* We increase the counter as this request is using the handle */\n\t\tjanus_refcount_increase(&handle->ref);\n\t\t/* Attach to the plugin */\n\t\tint error = 0;\n\t\tif((error = janus_ice_handle_attach_plugin(session, handle, plugin_t)) != 0) {\n\t\t\t/* TODO Make error struct to pass verbose information */\n\t\t\tjanus_session_handles_remove(session, handle);\n\t\t\tJANUS_LOG(LOG_ERR, \"Couldn't attach to plugin '%s', error '%d'\\n\", plugin_text, error);\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_ATTACH, \"Couldn't attach to plugin: error '%d'\", error);\n\t\t\tgoto jsondone;\n\t\t}\n\t\t/* Prepare JSON reply */\n\t\tjson_t *reply = janus_create_message(\"success\", session_id, transaction_text);\n\t\tjson_t *data = json_object();\n\t\tjson_object_set_new(data, \"id\", json_integer(handle_id));\n\t\tjson_object_set_new(reply, \"data\", data);\n\t\t/* Send the success reply */\n\t\tret = janus_process_success(request, reply);\n\t} else if(!strcasecmp(message_text, \"destroy\")) {\n\t\tif(handle != NULL) {\n\t\t\t/* Query is a session-level command */\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_REQUEST_PATH, \"Unhandled request '%s' at this path\", message_text);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjanus_mutex_lock(&sessions_mutex);\n\t\tg_hash_table_remove(sessions, &session->session_id);\n\t\tjanus_mutex_unlock(&sessions_mutex);\n\t\t/* Notify the source that the session has been destroyed */\n\t\tjanus_mutex_lock(&session->mutex);\n\t\tif(session->source && session->source->transport)\n\t\t\tsession->source->transport->session_over(session->source->instance, session->session_id, FALSE, FALSE);\n\t\tjanus_mutex_unlock(&session->mutex);\n\t\t/* Schedule the session for deletion */\n\t\tjanus_session_destroy(session);\n\n\t\t/* Prepare JSON reply */\n\t\tjson_t *reply = janus_create_message(\"success\", session_id, transaction_text);\n\t\t/* Send the success reply */\n\t\tret = janus_process_success(request, reply);\n\t\t/* Notify event handlers as well */\n\t\tif(janus_events_is_enabled())\n\t\t\tjanus_events_notify_handlers(JANUS_EVENT_TYPE_SESSION, JANUS_EVENT_SUBTYPE_NONE,\n\t\t\t\tsession_id, \"destroyed\", NULL);\n\t} else if(!strcasecmp(message_text, \"detach\")) {\n\t\tif(handle == NULL) {\n\t\t\t/* Query is an handle-level command */\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_REQUEST_PATH, \"Unhandled request '%s' at this path\", message_text);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(handle->app == NULL || handle->app_handle == NULL) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_DETACH, \"No plugin to detach from\");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tint error = janus_session_handles_remove(session, handle);\n\t\tif(error != 0) {\n\t\t\t/* TODO Make error struct to pass verbose information */\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_DETACH, \"Couldn't detach from plugin: error '%d'\", error);\n\t\t\t/* TODO Delete handle instance */\n\t\t\tgoto jsondone;\n\t\t}\n\t\t/* Prepare JSON reply */\n\t\tjson_t *reply = janus_create_message(\"success\", session_id, transaction_text);\n\t\t/* Send the success reply */\n\t\tret = janus_process_success(request, reply);\n\t} else if(!strcasecmp(message_text, \"hangup\")) {\n\t\tif(handle == NULL) {\n\t\t\t/* Query is an handle-level command */\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_REQUEST_PATH, \"Unhandled request '%s' at this path\", message_text);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(handle->app == NULL || handle->app_handle == NULL) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_DETACH, \"No plugin attached\");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjanus_ice_webrtc_hangup(handle, \"Janus API\");\n\t\t/* Prepare JSON reply */\n\t\tjson_t *reply = janus_create_message(\"success\", session_id, transaction_text);\n\t\t/* Send the success reply */\n\t\tret = janus_process_success(request, reply);\n\t} else if(!strcasecmp(message_text, \"claim\")) {\n\t\tjanus_mutex_lock(&session->mutex);\n\t\tif(session->source != NULL) {\n\t\t\t/* Notify the old transport that this session is over for them, but has been reclaimed */\n\t\t\tsession->source->transport->session_over(session->source->instance, session->session_id, FALSE, TRUE);\n\t\t\tjanus_request_destroy(session->source);\n\t\t\tsession->source = NULL;\n\t\t}\n\t\tsession->source = janus_request_new(request->transport, request->instance, NULL, FALSE, NULL);\n\t\t/* Notify the new transport that it has claimed a session */\n\t\tsession->source->transport->session_claimed(session->source->instance, session->session_id);\n\t\t/* Previous transport may be gone, clear flag. */\n\t\tg_atomic_int_set(&session->transport_gone, 0);\n\t\tjanus_mutex_unlock(&session->mutex);\n\t\t/* Prepare JSON reply */\n\t\tjson_t *reply = json_object();\n\t\tjson_object_set_new(reply, \"janus\", json_string(\"success\"));\n\t\tjson_object_set_new(reply, \"session_id\", json_integer(session_id));\n\t\tjson_object_set_new(reply, \"transaction\", json_string(transaction_text));\n\t\t/* Send the success reply */\n\t\tret = janus_process_success(request, reply);\n\t} else if(!strcasecmp(message_text, \"message\")) {\n\t\tif(handle == NULL) {\n\t\t\t/* Query is an handle-level command */\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_REQUEST_PATH, \"Unhandled request '%s' at this path\", message_text);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(handle->app == NULL || handle->app_handle == NULL) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_MESSAGE, \"No plugin to handle this message\");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjanus_plugin *plugin_t = (janus_plugin *)handle->app;\n\t\tJANUS_LOG(LOG_VERB, \"[%\"SCNu64\"] There's a message for %s\\n\", handle->handle_id, plugin_t->get_name());\n\t\tJANUS_VALIDATE_JSON_OBJECT(root, body_parameters,\n\t\t\terror_code, error_cause, FALSE,\n\t\t\tJANUS_ERROR_MISSING_MANDATORY_ELEMENT, JANUS_ERROR_INVALID_ELEMENT_TYPE);\n\t\tif(error_code != 0) {\n\t\t\tret = janus_process_error_string(request, session_id, transaction_text, error_code, error_cause);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjson_t *body = json_object_get(root, \"body\");\n\t\t/* Is there an SDP attached? */\n\t\tjson_t *jsep = json_object_get(root, \"jsep\");\n\t\tchar *jsep_type = NULL;\n\t\tchar *jsep_sdp = NULL, *jsep_sdp_stripped = NULL;\n\t\tgboolean renegotiation = FALSE;\n\t\tif(jsep != NULL) {\n\t\t\tif(!json_is_object(jsep)) {\n\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_JSON_OBJECT, \"Invalid jsep object\");\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\tJANUS_VALIDATE_JSON_OBJECT_FORMAT(\"JSEP error: missing mandatory element (%s)\",\n\t\t\t\t\"JSEP error: invalid element type (%s should be %s)\",\n\t\t\t\tjsep, jsep_parameters, error_code, error_cause, FALSE,\n\t\t\t\tJANUS_ERROR_MISSING_MANDATORY_ELEMENT, JANUS_ERROR_INVALID_ELEMENT_TYPE);\n\t\t\tif(error_code != 0) {\n\t\t\t\tret = janus_process_error_string(request, session_id, transaction_text, error_code, error_cause);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\tjson_t *type = json_object_get(jsep, \"type\");\n\t\t\tjsep_type = g_strdup(json_string_value(type));\n\t\t\ttype = NULL;\n\t\t\tgboolean do_trickle = TRUE;\n\t\t\tjson_t *jsep_trickle = json_object_get(jsep, \"trickle\");\n\t\t\tdo_trickle = jsep_trickle ? json_is_true(jsep_trickle) : TRUE;\n\t\t\t/* Are we still cleaning up from a previous media session? */\n\t\t\tif(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_CLEANING)) {\n\t\t\t\tJANUS_LOG(LOG_VERB, \"[%\"SCNu64\"] Still cleaning up from a previous media session, let's wait a bit...\\n\", handle->handle_id);\n\t\t\t\tgint64 waited = 0;\n\t\t\t\twhile(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_CLEANING)) {\n\t\t\t\t\tg_usleep(100000);\n\t\t\t\t\twaited += 100000;\n\t\t\t\t\tif(waited >= 3*G_USEC_PER_SEC) {\n\t\t\t\t\t\tJANUS_LOG(LOG_VERB, \"[%\"SCNu64\"]   -- Waited 3 seconds, that's enough!\\n\", handle->handle_id);\n\t\t\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_WEBRTC_STATE, \"Still cleaning a previous session\");\n\t\t\t\t\t\tgoto jsondone;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Check if we're renegotiating (if we have an answer, we did an offer/answer round already) */\n\t\t\trenegotiation = janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_NEGOTIATED);\n\t\t\t/* Check the JSEP type */\n\t\t\tjanus_mutex_lock(&handle->mutex);\n\t\t\tint offer = 0;\n\t\t\tif(!strcasecmp(jsep_type, \"offer\")) {\n\t\t\t\toffer = 1;\n\t\t\t\tjanus_flags_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t\t\tjanus_flags_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_OFFER);\n\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_ANSWER);\n\t\t\t} else if(!strcasecmp(jsep_type, \"answer\")) {\n\t\t\t\tjanus_flags_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_ANSWER);\n\t\t\t\tif(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_OFFER))\n\t\t\t\t\tjanus_flags_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_NEGOTIATED);\n\t\t\t\toffer = 0;\n\t\t\t} else {\n\t\t\t\t/* TODO Handle other message types as well */\n\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_JSEP_UNKNOWN_TYPE, \"JSEP error: unknown message type '%s'\", jsep_type);\n\t\t\t\tg_free(jsep_type);\n\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\tjson_t *sdp = json_object_get(jsep, \"sdp\");\n\t\t\tjsep_sdp = (char *)json_string_value(sdp);\n\t\t\tJANUS_LOG(LOG_VERB, \"[%\"SCNu64\"] Remote SDP:\\n%s\", handle->handle_id, jsep_sdp);\n\t\t\t/* Is this valid SDP? */\n\t\t\tchar error_str[512];\n\t\t\tint audio = 0, video = 0, data = 0;\n\t\t\tjanus_sdp *parsed_sdp = janus_sdp_preparse(handle, jsep_sdp, error_str, sizeof(error_str), &audio, &video, &data);\n\t\t\tif(parsed_sdp == NULL) {\n\t\t\t\t/* Invalid SDP */\n\t\t\t\tret = janus_process_error_string(request, session_id, transaction_text, JANUS_ERROR_JSEP_INVALID_SDP, error_str);\n\t\t\t\tg_free(jsep_type);\n\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\t/* Notify event handlers */\n\t\t\tif(janus_events_is_enabled()) {\n\t\t\t\tjanus_events_notify_handlers(JANUS_EVENT_TYPE_JSEP, JANUS_EVENT_SUBTYPE_NONE,\n\t\t\t\t\tsession_id, handle_id, handle->opaque_id, \"remote\", jsep_type, jsep_sdp);\n\t\t\t}\n\t\t\t/* FIXME We're only handling single audio/video lines for now... */\n\t\t\tJANUS_LOG(LOG_VERB, \"[%\"SCNu64\"] Audio %s been negotiated, Video %s been negotiated, SCTP/DataChannels %s been negotiated\\n\",\n\t\t\t                    handle->handle_id,\n\t\t\t                    audio ? \"has\" : \"has NOT\",\n\t\t\t                    video ? \"has\" : \"has NOT\",\n\t\t\t                    data ? \"have\" : \"have NOT\");\n\t\t\tif(audio > 1) {\n\t\t\t\tJANUS_LOG(LOG_WARN, \"[%\"SCNu64\"] More than one audio line? only going to negotiate one...\\n\", handle->handle_id);\n\t\t\t}\n\t\t\tif(video > 1) {\n\t\t\t\tJANUS_LOG(LOG_WARN, \"[%\"SCNu64\"] More than one video line? only going to negotiate one...\\n\", handle->handle_id);\n\t\t\t}\n\t\t\tif(data > 1) {\n\t\t\t\tJANUS_LOG(LOG_WARN, \"[%\"SCNu64\"] More than one data line? only going to negotiate one...\\n\", handle->handle_id);\n\t\t\t}\n#ifndef HAVE_SCTP\n\t\t\tif(data) {\n\t\t\t\tJANUS_LOG(LOG_WARN, \"[%\"SCNu64\"]   -- DataChannels have been negotiated, but support for them has not been compiled...\\n\", handle->handle_id);\n\t\t\t}\n#endif\n\t\t\t/* We behave differently if it's a new session or an update... */\n\t\t\tif(!renegotiation) {\n\t\t\t\t/* New session */\n\t\t\t\tif(offer) {\n\t\t\t\t\t/* Setup ICE locally (we received an offer) */\n\t\t\t\t\tif(janus_ice_setup_local(handle, offer, audio, video, data, do_trickle) < 0) {\n\t\t\t\t\t\tJANUS_LOG(LOG_ERR, \"Error setting ICE locally\\n\");\n\t\t\t\t\t\tjanus_sdp_destroy(parsed_sdp);\n\t\t\t\t\t\tg_free(jsep_type);\n\t\t\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNKNOWN, \"Error setting ICE locally\");\n\t\t\t\t\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t\t\t\t\tgoto jsondone;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t/* Make sure we're waiting for an ANSWER in the first place */\n\t\t\t\t\tif(!handle->agent) {\n\t\t\t\t\t\tJANUS_LOG(LOG_ERR, \"Unexpected ANSWER (did we offer?)\\n\");\n\t\t\t\t\t\tjanus_sdp_destroy(parsed_sdp);\n\t\t\t\t\t\tg_free(jsep_type);\n\t\t\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNEXPECTED_ANSWER, \"Unexpected ANSWER (did we offer?)\");\n\t\t\t\t\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t\t\t\t\tgoto jsondone;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(janus_sdp_process(handle, parsed_sdp, FALSE) < 0) {\n\t\t\t\t\tJANUS_LOG(LOG_ERR, \"Error processing SDP\\n\");\n\t\t\t\t\tjanus_sdp_destroy(parsed_sdp);\n\t\t\t\t\tg_free(jsep_type);\n\t\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_JSEP_INVALID_SDP, \"Error processing SDP\");\n\t\t\t\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t\t\t\tgoto jsondone;\n\t\t\t\t}\n\t\t\t\tif(!offer) {\n\t\t\t\t\t/* Set remote candidates now (we received an answer) */\n\t\t\t\t\tif(do_trickle) {\n\t\t\t\t\t\tjanus_flags_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_TRICKLE);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_TRICKLE);\n\t\t\t\t\t}\n\t\t\t\t\tjanus_request_ice_handle_answer(handle, audio, video, data, jsep_sdp);\n\t\t\t\t} else {\n\t\t\t\t\t/* Check if the mid RTP extension is being negotiated */\n\t\t\t\t\thandle->stream->mid_ext_id = janus_rtp_header_extension_get_id(jsep_sdp, JANUS_RTP_EXTMAP_MID);\n\t\t\t\t\t/* Check if the RTP Stream ID extension is being negotiated */\n\t\t\t\t\thandle->stream->rid_ext_id = janus_rtp_header_extension_get_id(jsep_sdp, JANUS_RTP_EXTMAP_RID);\n\t\t\t\t\thandle->stream->ridrtx_ext_id = janus_rtp_header_extension_get_id(jsep_sdp, JANUS_RTP_EXTMAP_REPAIRED_RID);\n\t\t\t\t\t/* Check if the audio level ID extension is being negotiated */\n\t\t\t\t\thandle->stream->audiolevel_ext_id = janus_rtp_header_extension_get_id(jsep_sdp, JANUS_RTP_EXTMAP_AUDIO_LEVEL);\n\t\t\t\t\t/* Check if the video orientation ID extension is being negotiated */\n\t\t\t\t\thandle->stream->videoorientation_ext_id = janus_rtp_header_extension_get_id(jsep_sdp, JANUS_RTP_EXTMAP_VIDEO_ORIENTATION);\n\t\t\t\t\t/* Check if the frame marking ID extension is being negotiated */\n\t\t\t\t\thandle->stream->framemarking_ext_id = janus_rtp_header_extension_get_id(jsep_sdp, JANUS_RTP_EXTMAP_FRAME_MARKING);\n\t\t\t\t\t/* Check if transport wide CC is supported */\n\t\t\t\t\tint transport_wide_cc_ext_id = janus_rtp_header_extension_get_id(jsep_sdp, JANUS_RTP_EXTMAP_TRANSPORT_WIDE_CC);\n\t\t\t\t\thandle->stream->do_transport_wide_cc = transport_wide_cc_ext_id > 0 ? TRUE : FALSE;\n\t\t\t\t\thandle->stream->transport_wide_cc_ext_id = transport_wide_cc_ext_id;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* FIXME This is a renegotiation: we can currently only handle simple changes in media\n\t\t\t\t * direction and ICE restarts: anything more complex than that will result in an error */\n\t\t\t\tJANUS_LOG(LOG_INFO, \"[%\"SCNu64\"] Negotiation update, checking what changed...\\n\", handle->handle_id);\n\t\t\t\tif(janus_sdp_process(handle, parsed_sdp, TRUE) < 0) {\n\t\t\t\t\tJANUS_LOG(LOG_ERR, \"Error processing SDP\\n\");\n\t\t\t\t\tjanus_sdp_destroy(parsed_sdp);\n\t\t\t\t\tg_free(jsep_type);\n\t\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNEXPECTED_ANSWER, \"Error processing SDP\");\n\t\t\t\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t\t\t\tgoto jsondone;\n\t\t\t\t}\n\t\t\t\tif(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_ICE_RESTART)) {\n\t\t\t\t\tJANUS_LOG(LOG_INFO, \"[%\"SCNu64\"] Restarting ICE...\\n\", handle->handle_id);\n\t\t\t\t\t/* Update remote credentials for ICE */\n\t\t\t\t\tif(handle->stream) {\n\t\t\t\t\t\tnice_agent_set_remote_credentials(handle->agent, handle->stream->stream_id,\n\t\t\t\t\t\t\thandle->stream->ruser, handle->stream->rpass);\n\t\t\t\t\t}\n\t\t\t\t\t/* FIXME We only need to do that for offers: if it's an answer, we did that already */\n\t\t\t\t\tif(offer) {\n\t\t\t\t\t\tjanus_ice_restart(handle);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_ICE_RESTART);\n\t\t\t\t\t}\n\t\t\t\t\t/* If we're full-trickling, we'll need to resend the candidates later */\n\t\t\t\t\tif(janus_ice_is_full_trickle_enabled()) {\n\t\t\t\t\t\tjanus_flags_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_RESEND_TRICKLES);\n\t\t\t\t\t}\n\t\t\t\t}\n#ifdef HAVE_SCTP\n\t\t\t\tif(!offer) {\n\t\t\t\t\t/* Were datachannels just added? */\n\t\t\t\t\tif(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_DATA_CHANNELS)) {\n\t\t\t\t\t\tjanus_ice_stream *stream = handle->stream;\n\t\t\t\t\t\tif(stream != NULL && stream->component != NULL\n\t\t\t\t\t\t\t\t&& stream->component->dtls != NULL && stream->component->dtls->sctp == NULL) {\n\t\t\t\t\t\t\t/* Create SCTP association as well */\n\t\t\t\t\t\t\tJANUS_LOG(LOG_WARN, \"[%\"SCNu64\"] Creating datachannels...\\n\", handle->handle_id);\n\t\t\t\t\t\t\tjanus_dtls_srtp_create_sctp(stream->component->dtls);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t\tchar *tmp = handle->remote_sdp;\n\t\t\thandle->remote_sdp = g_strdup(jsep_sdp);\n\t\t\tg_free(tmp);\n\t\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t\t/* Anonymize SDP */\n\t\t\tif(janus_sdp_anonymize(parsed_sdp) < 0) {\n\t\t\t\t/* Invalid SDP */\n\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_JSEP_INVALID_SDP, \"JSEP error: invalid SDP\");\n\t\t\t\tjanus_sdp_destroy(parsed_sdp);\n\t\t\t\tg_free(jsep_type);\n\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\tjsep_sdp_stripped = janus_sdp_write(parsed_sdp);\n\t\t\tjanus_sdp_destroy(parsed_sdp);\n\t\t\tsdp = NULL;\n\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t}\n\n\t\t/* Make sure the app handle is still valid */\n\t\tif(handle->app == NULL || !janus_plugin_session_is_alive(handle->app_handle)) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_MESSAGE, \"No plugin to handle this message\");\n\t\t\tg_free(jsep_type);\n\t\t\tg_free(jsep_sdp_stripped);\n\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t\tgoto jsondone;\n\t\t}\n\n\t\t/* Send the message to the plugin (which must eventually free transaction_text and unref the two objects, body and jsep) */\n\t\tjson_incref(body);\n\t\tjson_t *body_jsep = NULL;\n\t\tif(jsep_sdp_stripped) {\n\t\t\tbody_jsep = json_pack(\"{ssss}\", \"type\", jsep_type, \"sdp\", jsep_sdp_stripped);\n\t\t\t/* Check if simulcasting is enabled */\n\t\t\tif(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_HAS_VIDEO)) {\n\t\t\t\tif(handle->stream && (handle->stream->rid[0] || handle->stream->video_ssrc_peer[1])) {\n\t\t\t\t\tjson_t *simulcast = json_object();\n\t\t\t\t\t/* If we have rids, pass those, otherwise pass the SSRCs */\n\t\t\t\t\tif(handle->stream->rid[0]) {\n\t\t\t\t\t\tjson_t *rids = json_array();\n\t\t\t\t\t\tjson_array_append_new(rids, json_string(handle->stream->rid[0]));\n\t\t\t\t\t\tif(handle->stream->rid[1])\n\t\t\t\t\t\t\tjson_array_append_new(rids, json_string(handle->stream->rid[1]));\n\t\t\t\t\t\tif(handle->stream->rid[2])\n\t\t\t\t\t\t\tjson_array_append_new(rids, json_string(handle->stream->rid[2]));\n\t\t\t\t\t\tjson_object_set_new(simulcast, \"rids\", rids);\n\t\t\t\t\t\tjson_object_set_new(simulcast, \"rid-ext\", json_integer(handle->stream->rid_ext_id));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tjson_t *ssrcs = json_array();\n\t\t\t\t\t\tjson_array_append_new(ssrcs, json_integer(handle->stream->video_ssrc_peer[0]));\n\t\t\t\t\t\tif(handle->stream->video_ssrc_peer[1])\n\t\t\t\t\t\t\tjson_array_append_new(ssrcs, json_integer(handle->stream->video_ssrc_peer[1]));\n\t\t\t\t\t\tif(handle->stream->video_ssrc_peer[2])\n\t\t\t\t\t\t\tjson_array_append_new(ssrcs, json_integer(handle->stream->video_ssrc_peer[2]));\n\t\t\t\t\t\tjson_object_set_new(simulcast, \"ssrcs\", ssrcs);\n\t\t\t\t\t}\n\t\t\t\t\tif(handle->stream->framemarking_ext_id > 0)\n\t\t\t\t\t\tjson_object_set_new(simulcast, \"framemarking-ext\", json_integer(handle->stream->framemarking_ext_id));\n\t\t\t\t\tjson_object_set_new(body_jsep, \"simulcast\", simulcast);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Check if this is a renegotiation or update */\n\t\t\tif(renegotiation)\n\t\t\t\tjson_object_set_new(body_jsep, \"update\", json_true());\n\t\t}\n\t\tjanus_plugin_result *result = plugin_t->handle_message(handle->app_handle,\n\t\t\tg_strdup((char *)transaction_text), body, body_jsep);\n\t\tg_free(jsep_type);\n\t\tg_free(jsep_sdp_stripped);\n\t\tif(result == NULL) {\n\t\t\t/* Something went horribly wrong! */\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_MESSAGE, \"Plugin didn't give a result\");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(result->type == JANUS_PLUGIN_OK) {\n\t\t\t/* The plugin gave a result already (synchronous request/response) */\n\t\t\tif(result->content == NULL || !json_is_object(result->content)) {\n\t\t\t\t/* Missing content, or not a JSON object */\n\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_MESSAGE,\n\t\t\t\t\tresult->content == NULL ?\n\t\t\t\t\t\t\"Plugin didn't provide any content for this synchronous response\" :\n\t\t\t\t\t\t\"Plugin returned an invalid JSON response\");\n\t\t\t\tjanus_plugin_result_destroy(result);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\t/* Reference the content, as destroying the result instance will decref it */\n\t\t\tjson_incref(result->content);\n\t\t\t/* Prepare JSON response */\n\t\t\tjson_t *reply = janus_create_message(\"success\", session->session_id, transaction_text);\n\t\t\tjson_object_set_new(reply, \"sender\", json_integer(handle->handle_id));\n\t\t\tif(janus_is_opaqueid_in_api_enabled() && handle->opaque_id != NULL)\n\t\t\t\tjson_object_set_new(reply, \"opaque_id\", json_string(handle->opaque_id));\n\t\t\tjson_t *plugin_data = json_object();\n\t\t\tjson_object_set_new(plugin_data, \"plugin\", json_string(plugin_t->get_package()));\n\t\t\tjson_object_set_new(plugin_data, \"data\", result->content);\n\t\t\tjson_object_set_new(reply, \"plugindata\", plugin_data);\n\t\t\t/* Send the success reply */\n\t\t\tret = janus_process_success(request, reply);\n\t\t} else if(result->type == JANUS_PLUGIN_OK_WAIT) {\n\t\t\t/* The plugin received the request but didn't process it yet, send an ack (asynchronous notifications may follow) */\n\t\t\tjson_t *reply = janus_create_message(\"ack\", session_id, transaction_text);\n\t\t\tif(result->text)\n\t\t\t\tjson_object_set_new(reply, \"hint\", json_string(result->text));\n\t\t\t/* Send the success reply */\n\t\t\tret = janus_process_success(request, reply);\n\t\t} else {\n\t\t\t/* Something went horribly wrong! */\n\t\t\tret = janus_process_error_string(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_MESSAGE,\n\t\t\t\t(char *)(result->text ? result->text : \"Plugin returned a severe (unknown) error\"));\n\t\t\tjanus_plugin_result_destroy(result);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjanus_plugin_result_destroy(result);\n\t} else if(!strcasecmp(message_text, \"trickle\")) {\n\t\tif(handle == NULL) {\n\t\t\t/* Trickle is an handle-level command */\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_REQUEST_PATH, \"Unhandled request '%s' at this path\", message_text);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(handle->app == NULL || !janus_plugin_session_is_alive(handle->app_handle)) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_MESSAGE, \"No plugin to handle this trickle candidate\");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjson_t *candidate = json_object_get(root, \"candidate\");\n\t\tjson_t *candidates = json_object_get(root, \"candidates\");\n\t\tif(candidate == NULL && candidates == NULL) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_MISSING_MANDATORY_ELEMENT, \"Missing mandatory element (candidate|candidates)\");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(candidate != NULL && candidates != NULL) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_JSON, \"Can't have both candidate and candidates\");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_CLEANING)) {\n\t\t\tJANUS_LOG(LOG_ERR, \"[%\"SCNu64\"] Received a trickle, but still cleaning a previous session\\n\", handle->handle_id);\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_WEBRTC_STATE, \"Still cleaning a previous session\");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjanus_mutex_lock(&handle->mutex);\n\t\tif(!janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_TRICKLE)) {\n\t\t\t/* It looks like this peer supports Trickle, after all */\n\t\t\tJANUS_LOG(LOG_VERB, \"Handle %\"SCNu64\" supports trickle even if it didn't negotiate it...\\n\", handle->handle_id);\n\t\t\tjanus_flags_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_TRICKLE);\n\t\t}\n\t\t/* Is there any stream ready? this trickle may get here before the SDP it relates to */\n\t\tif(handle->stream == NULL) {\n\t\t\tJANUS_LOG(LOG_WARN, \"[%\"SCNu64\"] No stream, queueing this trickle as it got here before the SDP...\\n\", handle->handle_id);\n\t\t\t/* Enqueue this trickle candidate(s), we'll process this later */\n\t\t\tjanus_ice_trickle *early_trickle = janus_ice_trickle_new(transaction_text, candidate ? candidate : candidates);\n\t\t\thandle->pending_trickles = g_list_append(handle->pending_trickles, early_trickle);\n\t\t\t/* Send the ack right away, an event will tell the application if the candidate(s) failed */\n\t\t\tgoto trickledone;\n\t\t}\n\t\t/* Is the ICE stack ready already? */\n\t\tif(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER) ||\n\t\t\t\t!janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_OFFER) ||\n\t\t\t\t!janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_ANSWER)) {\n\t\t\tconst char *cause = NULL;\n\t\t\tif(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER))\n\t\t\t\tcause = \"processing the offer\";\n\t\t\telse if(!janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_ANSWER))\n\t\t\t\tcause = \"waiting for the answer\";\n\t\t\telse if(!janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_OFFER))\n\t\t\t\tcause = \"waiting for the offer\";\n\t\t\tJANUS_LOG(LOG_VERB, \"[%\"SCNu64\"] Still %s, queueing this trickle to wait until we're done there...\\n\",\n\t\t\t\thandle->handle_id, cause);\n\t\t\t/* Enqueue this trickle candidate(s), we'll process this later */\n\t\t\tjanus_ice_trickle *early_trickle = janus_ice_trickle_new(transaction_text, candidate ? candidate : candidates);\n\t\t\thandle->pending_trickles = g_list_append(handle->pending_trickles, early_trickle);\n\t\t\t/* Send the ack right away, an event will tell the application if the candidate(s) failed */\n\t\t\tgoto trickledone;\n\t\t}\n\t\tif(candidate != NULL) {\n\t\t\t/* We got a single candidate */\n\t\t\tint error = 0;\n\t\t\tconst char *error_string = NULL;\n\t\t\tif((error = janus_ice_trickle_parse(handle, candidate, &error_string)) != 0) {\n\t\t\t\tret = janus_process_error(request, session_id, transaction_text, error, \"%s\", error_string);\n\t\t\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t} else {\n\t\t\t/* We got multiple candidates in an array */\n\t\t\tif(!json_is_array(candidates)) {\n\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_ELEMENT_TYPE, \"candidates is not an array\");\n\t\t\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\tJANUS_LOG(LOG_VERB, \"Got multiple candidates (%zu)\\n\", json_array_size(candidates));\n\t\t\tif(json_array_size(candidates) > 0) {\n\t\t\t\t/* Handle remote candidates */\n\t\t\t\tsize_t i = 0;\n\t\t\t\tfor(i=0; i<json_array_size(candidates); i++) {\n\t\t\t\t\tjson_t *c = json_array_get(candidates, i);\n\t\t\t\t\t/* FIXME We don't care if any trickle fails to parse */\n\t\t\t\t\tjanus_ice_trickle_parse(handle, c, NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\ntrickledone:\n\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t/* We reply right away, not to block the web server... */\n\t\tjson_t *reply = janus_create_message(\"ack\", session_id, transaction_text);\n\t\t/* Send the success reply */\n\t\tret = janus_process_success(request, reply);\n\t} else {\n\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNKNOWN_REQUEST, \"Unknown request '%s'\", message_text);\n\t}\n\njsondone:\n\t/* Done processing */\n\tif(handle != NULL)\n\t\tjanus_refcount_decrease(&handle->ref);\n\tif(session != NULL)\n\t\tjanus_refcount_decrease(&session->ref);\n\treturn ret;\n}",
  "abstract_func": "int janus_process_incoming_request(janus_request *VAR_0) {\n\tint VAR_1 = -1;\n\tif(VAR_0 == NULL) {\n\t\tJANUS_LOG(VAR_2, \"Missing request or payload to process, giving up...\\n\");\n\t\treturn VAR_1;\n\t}\n\tint VAR_3 = 0;\n\tchar VAR_4[100];\n\tjson_t *VAR_5 = VAR_0->message;\n\t/* COMMENT_0 */\n\tguint64 VAR_6 = 0, VAR_7 = 0;\n\tjson_t *VAR_8 = json_object_get(VAR_5, \"session_id\");\n\tif(VAR_8 && json_is_integer(VAR_8))\n\t\tVAR_6 = json_integer_value(VAR_8);\n\tjson_t *VAR_9 = json_object_get(VAR_5, \"handle_id\");\n\tif(VAR_9 && json_is_integer(VAR_9))\n\t\tVAR_7 = json_integer_value(VAR_9);\n\n\tjanus_session *VAR_10 = NULL;\n\tjanus_ice_handle *VAR_11 = NULL;\n\n\t/* COMMENT_1 */\n\tJANUS_VALIDATE_JSON_OBJECT(VAR_5, VAR_12,\n\t\tVAR_3, VAR_4, FALSE,\n\t\tVAR_13, VAR_14);\n\tif(VAR_3 != 0) {\n\t\tVAR_1 = janus_process_error_string(VAR_0, VAR_6, NULL, VAR_3, VAR_4);\n\t\tgoto jsondone;\n\t}\n\tjson_t *VAR_15 = json_object_get(VAR_5, \"transaction\");\n\tconst gchar *VAR_16 = json_string_value(VAR_15);\n\tjson_t *VAR_17 = json_object_get(VAR_5, \"janus\");\n\tconst gchar *VAR_18 = json_string_value(VAR_17);\n\n\tif(VAR_6 == 0 && VAR_7 == 0) {\n\t\t/* COMMENT_2 */\n\t\tif(!strcasecmp(VAR_18, \"info\")) {\n\t\t\tVAR_1 = janus_process_success(VAR_0, janus_info(VAR_16));\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(!strcasecmp(VAR_18, \"ping\")) {\n\t\t\t/* COMMENT_3 */\n\t\t\tjson_t *VAR_19 = janus_create_message(\"pong\", 0, VAR_16);\n\t\t\tVAR_1 = janus_process_success(VAR_0, VAR_19);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(strcasecmp(VAR_18, \"create\")) {\n\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_20, \"Unhandled request '%s' at this path\", VAR_18);\n\t\t\tgoto jsondone;\n\t\t}\n\t\t/* COMMENT_4 */\n\t\tif(!VAR_21) {\n\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_22, NULL);\n\t\t\tgoto jsondone;\n\t\t}\n\t\t/* COMMENT_5 */\n\t\tVAR_1 = janus_request_check_secret(VAR_0, VAR_6, VAR_16);\n\t\tif(VAR_1 != 0) {\n\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_23, NULL);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tVAR_6 = 0;\n\t\tjson_t *VAR_24 = json_object_get(VAR_5, \"id\");\n\t\tif(VAR_24 != NULL) {\n\t\t\t/* COMMENT_6 */\n\t\t\tVAR_6 = json_integer_value(VAR_24);\n\t\t\tif(VAR_6 > 0 && (VAR_10 = janus_session_find(VAR_6)) != NULL) {\n\t\t\t\t/* COMMENT_7 */\n\t\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_25, \"Session ID already in use\");\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t}\n\t\t/* COMMENT_8 */\n\t\tVAR_10 = janus_session_create(VAR_6);\n\t\tif(VAR_10 == NULL) {\n\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_26, \"Memory error\");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tVAR_6 = VAR_10->session_id;\n\t\t/* COMMENT_9 */\n\t\tjanus_refcount_increase(&VAR_10->ref);\n\t\t/* COMMENT_10 */\n\t\tVAR_10->source = janus_request_new(VAR_0->transport, VAR_0->instance, NULL, FALSE, NULL);\n\t\t/* COMMENT_11 */\n\t\tVAR_0->transport->session_created(VAR_0->instance, VAR_10->session_id);\n\t\t/* COMMENT_12 */\n\t\tif(janus_events_is_enabled()) {\n\t\t\t/* COMMENT_13 */\n\t\t\tjson_t *VAR_27 = json_object();\n\t\t\tjson_object_set_new(VAR_27, \"transport\", json_string(VAR_10->source->transport->get_package()));\n\t\t\tchar VAR_24[32];\n\t\t\tmemset(VAR_24, 0, sizeof(VAR_24));\n\t\t\tg_snprintf(VAR_24, sizeof(VAR_24), \"%p\", VAR_10->source->instance);\n\t\t\tjson_object_set_new(VAR_27, \"id\", json_string(VAR_24));\n\t\t\tjanus_events_notify_handlers(VAR_28, VAR_29,\n\t\t\t\tVAR_6, \"created\", VAR_27);\n\t\t}\n\t\t/* COMMENT_3 */\n\t\tjson_t *VAR_19 = janus_create_message(\"success\", 0, VAR_16);\n\t\tjson_t *VAR_30 = json_object();\n\t\tjson_object_set_new(VAR_30, \"id\", json_integer(VAR_6));\n\t\tjson_object_set_new(VAR_19, \"data\", VAR_30);\n\t\t/* COMMENT_14 */\n\t\tVAR_1 = janus_process_success(VAR_0, VAR_19);\n\t\tgoto jsondone;\n\t}\n\tif(VAR_6 < 1) {\n\t\tJANUS_LOG(VAR_2, \"Invalid session\\n\");\n\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_31, NULL);\n\t\tgoto jsondone;\n\t}\n\tif(VAR_9 && VAR_7 < 1) {\n\t\tJANUS_LOG(VAR_2, \"Invalid handle\\n\");\n\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_31, NULL);\n\t\tgoto jsondone;\n\t}\n\n\t/* COMMENT_15 */\n\tVAR_1 = janus_request_check_secret(VAR_0, VAR_6, VAR_16);\n\tif(VAR_1 != 0) {\n\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_23, NULL);\n\t\tgoto jsondone;\n\t}\n\n\t/* COMMENT_16 */\n\tVAR_10 = janus_session_find(VAR_6);\n\tif(!VAR_10) {\n\t\tJANUS_LOG(VAR_2, \"Couldn't find any session %\"VAR_32\"...\\n\", VAR_6);\n\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_31, \"No such session %\"VAR_32\"\", VAR_6);\n\t\tgoto jsondone;\n\t}\n\t/* COMMENT_17 */\n\tVAR_10->last_activity = janus_get_monotonic_time();\n\tVAR_11 = NULL;\n\tif(VAR_7 > 0) {\n\t\tVAR_11 = janus_session_handles_find(VAR_10, VAR_7);\n\t\tif(!VAR_11) {\n\t\t\tJANUS_LOG(VAR_2, \"Couldn't find any handle %\"VAR_32\" in session %\"VAR_32\"...\\n\", VAR_7, VAR_6);\n\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_33, \"No such handle %\"VAR_32\" in session %\"VAR_32\"\", VAR_7, VAR_6);\n\t\t\tgoto jsondone;\n\t\t}\n\t}\n\n\t/* COMMENT_18 */\n\tif(!strcasecmp(VAR_18, \"keepalive\")) {\n\t\t/* COMMENT_19 */\n\t\tJANUS_LOG(VAR_34, \"Got a keep-alive on session %\"VAR_32\"\\n\", VAR_6);\n\t\tjson_t *VAR_19 = janus_create_message(\"ack\", VAR_6, VAR_16);\n\t\t/* COMMENT_14 */\n\t\tVAR_1 = janus_process_success(VAR_0, VAR_19);\n\t} else if(!strcasecmp(VAR_18, \"attach\")) {\n\t\tif(VAR_11 != NULL) {\n\t\t\t/* COMMENT_20 */\n\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_20, \"Unhandled request '%s' at this path\", VAR_18);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tJANUS_VALIDATE_JSON_OBJECT(VAR_5, VAR_35,\n\t\t\tVAR_3, VAR_4, FALSE,\n\t\t\tVAR_13, VAR_14);\n\t\tif(VAR_3 != 0) {\n\t\t\tVAR_1 = janus_process_error_string(VAR_0, VAR_6, VAR_16, VAR_3, VAR_4);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjson_t *VAR_36 = json_object_get(VAR_5, \"plugin\");\n\t\tconst gchar *VAR_37 = json_string_value(VAR_36);\n\t\tjanus_plugin *VAR_38 = janus_plugin_find(VAR_37);\n\t\tif(VAR_38 == NULL) {\n\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_39, \"No such plugin '%s'\", VAR_37);\n\t\t\tgoto jsondone;\n\t\t}\n\t\t/* COMMENT_21 */\n\t\tif(janus_auth_is_enabled()) {\n\t\t\tjson_t *VAR_40 = json_object_get(VAR_5, \"token\");\n\t\t\tif(VAR_40 != NULL) {\n\t\t\t\tconst char *VAR_41 = json_string_value(VAR_40);\n\t\t\t\tif(VAR_41 && !janus_auth_check_plugin(VAR_41, VAR_38)) {\n\t\t\t\t\tJANUS_LOG(VAR_2, \"Token '%s' can't access plugin '%s'\\n\", VAR_41, VAR_37);\n\t\t\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_42, \"Provided token can't access plugin '%s'\", VAR_37);\n\t\t\t\t\tgoto jsondone;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tjson_t *VAR_43 = json_object_get(VAR_5, \"opaque_id\");\n\t\tconst char *VAR_44 = VAR_43 ? json_string_value(VAR_43) : NULL;\n\t\t/* COMMENT_22 */\n\t\tVAR_11 = janus_ice_handle_create(VAR_10, VAR_44);\n\t\tif(VAR_11 == NULL) {\n\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_26, \"Memory error\");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tVAR_7 = VAR_11->handle_id;\n\t\t/* COMMENT_23 */\n\t\tjanus_refcount_increase(&VAR_11->ref);\n\t\t/* COMMENT_24 */\n\t\tint VAR_45 = 0;\n\t\tif((VAR_45 = janus_ice_handle_attach_plugin(VAR_10, VAR_11, VAR_38)) != 0) {\n\t\t\t/* COMMENT_25 */\n\t\t\tjanus_session_handles_remove(VAR_10, VAR_11);\n\t\t\tJANUS_LOG(VAR_2, \"Couldn't attach to plugin '%s', error '%d'\\n\", VAR_37, VAR_45);\n\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_46, \"Couldn't attach to plugin: error '%d'\", VAR_45);\n\t\t\tgoto jsondone;\n\t\t}\n\t\t/* COMMENT_3 */\n\t\tjson_t *VAR_19 = janus_create_message(\"success\", VAR_6, VAR_16);\n\t\tjson_t *VAR_30 = json_object();\n\t\tjson_object_set_new(VAR_30, \"id\", json_integer(VAR_7));\n\t\tjson_object_set_new(VAR_19, \"data\", VAR_30);\n\t\t/* COMMENT_14 */\n\t\tVAR_1 = janus_process_success(VAR_0, VAR_19);\n\t} else if(!strcasecmp(VAR_18, \"destroy\")) {\n\t\tif(VAR_11 != NULL) {\n\t\t\t/* COMMENT_26 */\n\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_20, \"Unhandled request '%s' at this path\", VAR_18);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjanus_mutex_lock(&VAR_47);\n\t\tg_hash_table_remove(VAR_48, &VAR_10->session_id);\n\t\tjanus_mutex_unlock(&VAR_47);\n\t\t/* COMMENT_27 */\n\t\tjanus_mutex_lock(&VAR_10->mutex);\n\t\tif(VAR_10->source && VAR_10->source->transport)\n\t\t\tVAR_10->source->transport->session_over(VAR_10->source->instance, VAR_10->session_id, FALSE, FALSE);\n\t\tjanus_mutex_unlock(&VAR_10->mutex);\n\t\t/* COMMENT_28 */\n\t\tjanus_session_destroy(VAR_10);\n\n\t\t/* COMMENT_3 */\n\t\tjson_t *VAR_19 = janus_create_message(\"success\", VAR_6, VAR_16);\n\t\t/* COMMENT_14 */\n\t\tVAR_1 = janus_process_success(VAR_0, VAR_19);\n\t\t/* COMMENT_29 */\n\t\tif(janus_events_is_enabled())\n\t\t\tjanus_events_notify_handlers(VAR_28, VAR_29,\n\t\t\t\tVAR_6, \"destroyed\", NULL);\n\t} else if(!strcasecmp(VAR_18, \"detach\")) {\n\t\tif(VAR_11 == NULL) {\n\t\t\t/* COMMENT_30 */\n\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_20, \"Unhandled request '%s' at this path\", VAR_18);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(VAR_11->app == NULL || VAR_11->app_handle == NULL) {\n\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_49, \"No plugin to detach from\");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tint VAR_45 = janus_session_handles_remove(VAR_10, VAR_11);\n\t\tif(VAR_45 != 0) {\n\t\t\t/* COMMENT_25 */\n\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_49, \"Couldn't detach from plugin: error '%d'\", VAR_45);\n\t\t\t/* COMMENT_31 */\n\t\t\tgoto jsondone;\n\t\t}\n\t\t/* COMMENT_3 */\n\t\tjson_t *VAR_19 = janus_create_message(\"success\", VAR_6, VAR_16);\n\t\t/* COMMENT_14 */\n\t\tVAR_1 = janus_process_success(VAR_0, VAR_19);\n\t} else if(!strcasecmp(VAR_18, \"hangup\")) {\n\t\tif(VAR_11 == NULL) {\n\t\t\t/* COMMENT_30 */\n\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_20, \"Unhandled request '%s' at this path\", VAR_18);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(VAR_11->app == NULL || VAR_11->app_handle == NULL) {\n\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_49, \"No plugin attached\");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjanus_ice_webrtc_hangup(VAR_11, \"Janus API\");\n\t\t/* COMMENT_3 */\n\t\tjson_t *VAR_19 = janus_create_message(\"success\", VAR_6, VAR_16);\n\t\t/* COMMENT_14 */\n\t\tVAR_1 = janus_process_success(VAR_0, VAR_19);\n\t} else if(!strcasecmp(VAR_18, \"claim\")) {\n\t\tjanus_mutex_lock(&VAR_10->mutex);\n\t\tif(VAR_10->source != NULL) {\n\t\t\t/* COMMENT_32 */\n\t\t\tVAR_10->source->transport->session_over(VAR_10->source->instance, VAR_10->session_id, FALSE, TRUE);\n\t\t\tjanus_request_destroy(VAR_10->source);\n\t\t\tVAR_10->source = NULL;\n\t\t}\n\t\tVAR_10->source = janus_request_new(VAR_0->transport, VAR_0->instance, NULL, FALSE, NULL);\n\t\t/* COMMENT_33 */\n\t\tVAR_10->source->transport->session_claimed(VAR_10->source->instance, VAR_10->session_id);\n\t\t/* COMMENT_34 */\n\t\tg_atomic_int_set(&VAR_10->transport_gone, 0);\n\t\tjanus_mutex_unlock(&VAR_10->mutex);\n\t\t/* COMMENT_3 */\n\t\tjson_t *VAR_19 = json_object();\n\t\tjson_object_set_new(VAR_19, \"janus\", json_string(\"success\"));\n\t\tjson_object_set_new(VAR_19, \"session_id\", json_integer(VAR_6));\n\t\tjson_object_set_new(VAR_19, \"transaction\", json_string(VAR_16));\n\t\t/* COMMENT_14 */\n\t\tVAR_1 = janus_process_success(VAR_0, VAR_19);\n\t} else if(!strcasecmp(VAR_18, \"message\")) {\n\t\tif(VAR_11 == NULL) {\n\t\t\t/* COMMENT_30 */\n\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_20, \"Unhandled request '%s' at this path\", VAR_18);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(VAR_11->app == NULL || VAR_11->app_handle == NULL) {\n\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_50, \"No plugin to handle this message\");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjanus_plugin *VAR_38 = (janus_plugin *)VAR_11->app;\n\t\tJANUS_LOG(VAR_34, \"[%\"VAR_32\"] There's a message for %s\\n\", VAR_11->handle_id, VAR_38->get_name());\n\t\tJANUS_VALIDATE_JSON_OBJECT(VAR_5, VAR_51,\n\t\t\tVAR_3, VAR_4, FALSE,\n\t\t\tVAR_13, VAR_14);\n\t\tif(VAR_3 != 0) {\n\t\t\tVAR_1 = janus_process_error_string(VAR_0, VAR_6, VAR_16, VAR_3, VAR_4);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjson_t *VAR_52 = json_object_get(VAR_5, \"body\");\n\t\t/* COMMENT_35 */\n\t\tjson_t *VAR_53 = json_object_get(VAR_5, \"jsep\");\n\t\tchar *VAR_54 = NULL;\n\t\tchar *VAR_55 = NULL, *VAR_56 = NULL;\n\t\tgboolean VAR_57 = FALSE;\n\t\tif(VAR_53 != NULL) {\n\t\t\tif(!json_is_object(VAR_53)) {\n\t\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_58, \"Invalid jsep object\");\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\tJANUS_VALIDATE_JSON_OBJECT_FORMAT(\"JSEP error: missing mandatory element (%s)\",\n\t\t\t\t\"JSEP error: invalid element type (%s should be %s)\",\n\t\t\t\tVAR_53, VAR_59, VAR_3, VAR_4, FALSE,\n\t\t\t\tVAR_13, VAR_14);\n\t\t\tif(VAR_3 != 0) {\n\t\t\t\tVAR_1 = janus_process_error_string(VAR_0, VAR_6, VAR_16, VAR_3, VAR_4);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\tjson_t *VAR_60 = json_object_get(VAR_53, \"type\");\n\t\t\tVAR_54 = g_strdup(json_string_value(VAR_60));\n\t\t\tVAR_60 = NULL;\n\t\t\tgboolean VAR_61 = TRUE;\n\t\t\tjson_t *VAR_62 = json_object_get(VAR_53, \"trickle\");\n\t\t\tVAR_61 = VAR_62 ? json_is_true(VAR_62) : TRUE;\n\t\t\t/* COMMENT_36 */\n\t\t\tif(janus_flags_is_set(&VAR_11->webrtc_flags, VAR_63)) {\n\t\t\t\tJANUS_LOG(VAR_34, \"[%\"VAR_32\"] Still cleaning up from a previous media session, let's wait a bit...\\n\", VAR_11->handle_id);\n\t\t\t\tgint64 VAR_64 = 0;\n\t\t\t\twhile(janus_flags_is_set(&VAR_11->webrtc_flags, VAR_63)) {\n\t\t\t\t\tg_usleep(100000);\n\t\t\t\t\tVAR_64 += 100000;\n\t\t\t\t\tif(VAR_64 >= 3*VAR_65) {\n\t\t\t\t\t\tJANUS_LOG(VAR_34, \"[%\"VAR_32\"]   -- Waited 3 seconds, that's enough!\\n\", VAR_11->handle_id);\n\t\t\t\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_66, \"Still cleaning a previous session\");\n\t\t\t\t\t\tgoto jsondone;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* COMMENT_37 */\n\t\t\tVAR_57 = janus_flags_is_set(&VAR_11->webrtc_flags, VAR_67);\n\t\t\t/* COMMENT_38 */\n\t\t\tjanus_mutex_lock(&VAR_11->mutex);\n\t\t\tint VAR_68 = 0;\n\t\t\tif(!strcasecmp(VAR_54, \"offer\")) {\n\t\t\t\tVAR_68 = 1;\n\t\t\t\tjanus_flags_set(&VAR_11->webrtc_flags, VAR_69);\n\t\t\t\tjanus_flags_set(&VAR_11->webrtc_flags, VAR_70);\n\t\t\t\tjanus_flags_clear(&VAR_11->webrtc_flags, VAR_71);\n\t\t\t} else if(!strcasecmp(VAR_54, \"answer\")) {\n\t\t\t\tjanus_flags_set(&VAR_11->webrtc_flags, VAR_71);\n\t\t\t\tif(janus_flags_is_set(&VAR_11->webrtc_flags, VAR_70))\n\t\t\t\t\tjanus_flags_set(&VAR_11->webrtc_flags, VAR_67);\n\t\t\t\tVAR_68 = 0;\n\t\t\t} else {\n\t\t\t\t/* COMMENT_39 */\n\t\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_72, \"JSEP error: unknown message type '%s'\", VAR_54);\n\t\t\t\tg_free(VAR_54);\n\t\t\t\tjanus_flags_clear(&VAR_11->webrtc_flags, VAR_69);\n\t\t\t\tjanus_mutex_unlock(&VAR_11->mutex);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\tjson_t *VAR_73 = json_object_get(VAR_53, \"sdp\");\n\t\t\tVAR_55 = (char *)json_string_value(VAR_73);\n\t\t\tJANUS_LOG(VAR_34, \"[%\"VAR_32\"] Remote SDP:\\n%s\", VAR_11->handle_id, VAR_55);\n\t\t\t/* COMMENT_40 */\n\t\t\tchar VAR_74[512];\n\t\t\tint VAR_75 = 0, VAR_76 = 0, VAR_30 = 0;\n\t\t\tjanus_sdp *VAR_77 = janus_sdp_preparse(VAR_11, VAR_55, VAR_74, sizeof(VAR_74), &VAR_75, &VAR_76, &VAR_30);\n\t\t\tif(VAR_77 == NULL) {\n\t\t\t\t/* COMMENT_41 */\n\t\t\t\tVAR_1 = janus_process_error_string(VAR_0, VAR_6, VAR_16, VAR_78, VAR_74);\n\t\t\t\tg_free(VAR_54);\n\t\t\t\tjanus_flags_clear(&VAR_11->webrtc_flags, VAR_69);\n\t\t\t\tjanus_mutex_unlock(&VAR_11->mutex);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\t/* COMMENT_12 */\n\t\t\tif(janus_events_is_enabled()) {\n\t\t\t\tjanus_events_notify_handlers(VAR_79, VAR_29,\n\t\t\t\t\tVAR_6, VAR_7, VAR_11->opaque_id, \"remote\", VAR_54, VAR_55);\n\t\t\t}\n\t\t\t/* COMMENT_42 */\n\t\t\tJANUS_LOG(VAR_34, \"[%\"VAR_32\"] Audio %s been negotiated, Video %s been negotiated, SCTP/DataChannels %s been negotiated\\n\",\n\t\t\t                    VAR_11->handle_id,\n\t\t\t                    VAR_75 ? \"has\" : \"has NOT\",\n\t\t\t                    VAR_76 ? \"has\" : \"has NOT\",\n\t\t\t                    VAR_30 ? \"have\" : \"have NOT\");\n\t\t\tif(VAR_75 > 1) {\n\t\t\t\tJANUS_LOG(VAR_80, \"[%\"VAR_32\"] More than one audio line? only going to negotiate one...\\n\", VAR_11->handle_id);\n\t\t\t}\n\t\t\tif(VAR_76 > 1) {\n\t\t\t\tJANUS_LOG(VAR_80, \"[%\"VAR_32\"] More than one video line? only going to negotiate one...\\n\", VAR_11->handle_id);\n\t\t\t}\n\t\t\tif(VAR_30 > 1) {\n\t\t\t\tJANUS_LOG(VAR_80, \"[%\"VAR_32\"] More than one data line? only going to negotiate one...\\n\", VAR_11->handle_id);\n\t\t\t}\n#ifndef VAR_81\n\t\t\tif(VAR_30) {\n\t\t\t\tJANUS_LOG(VAR_80, \"[%\"VAR_32\"]   -- DataChannels have been negotiated, but support for them has not been compiled...\\n\", VAR_11->handle_id);\n\t\t\t}\n#endif\n\t\t\t/* COMMENT_43 */\n\t\t\tif(!VAR_57) {\n\t\t\t\t/* COMMENT_44 */\n\t\t\t\tif(VAR_68) {\n\t\t\t\t\t/* COMMENT_45 */\n\t\t\t\t\tif(janus_ice_setup_local(VAR_11, VAR_68, VAR_75, VAR_76, VAR_30, VAR_61) < 0) {\n\t\t\t\t\t\tJANUS_LOG(VAR_2, \"Error setting ICE locally\\n\");\n\t\t\t\t\t\tjanus_sdp_destroy(VAR_77);\n\t\t\t\t\t\tg_free(VAR_54);\n\t\t\t\t\t\tjanus_flags_clear(&VAR_11->webrtc_flags, VAR_69);\n\t\t\t\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_26, \"Error setting ICE locally\");\n\t\t\t\t\t\tjanus_mutex_unlock(&VAR_11->mutex);\n\t\t\t\t\t\tgoto jsondone;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t/* COMMENT_46 */\n\t\t\t\t\tif(!VAR_11->agent) {\n\t\t\t\t\t\tJANUS_LOG(VAR_2, \"Unexpected ANSWER (did we offer?)\\n\");\n\t\t\t\t\t\tjanus_sdp_destroy(VAR_77);\n\t\t\t\t\t\tg_free(VAR_54);\n\t\t\t\t\t\tjanus_flags_clear(&VAR_11->webrtc_flags, VAR_69);\n\t\t\t\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_82, \"Unexpected ANSWER (did we offer?)\");\n\t\t\t\t\t\tjanus_mutex_unlock(&VAR_11->mutex);\n\t\t\t\t\t\tgoto jsondone;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(janus_sdp_process(VAR_11, VAR_77, FALSE) < 0) {\n\t\t\t\t\tJANUS_LOG(VAR_2, \"Error processing SDP\\n\");\n\t\t\t\t\tjanus_sdp_destroy(VAR_77);\n\t\t\t\t\tg_free(VAR_54);\n\t\t\t\t\tjanus_flags_clear(&VAR_11->webrtc_flags, VAR_69);\n\t\t\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_78, \"Error processing SDP\");\n\t\t\t\t\tjanus_mutex_unlock(&VAR_11->mutex);\n\t\t\t\t\tgoto jsondone;\n\t\t\t\t}\n\t\t\t\tif(!VAR_68) {\n\t\t\t\t\t/* COMMENT_47 */\n\t\t\t\t\tif(VAR_61) {\n\t\t\t\t\t\tjanus_flags_set(&VAR_11->webrtc_flags, VAR_83);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tjanus_flags_clear(&VAR_11->webrtc_flags, VAR_83);\n\t\t\t\t\t}\n\t\t\t\t\tjanus_request_ice_handle_answer(VAR_11, VAR_75, VAR_76, VAR_30, VAR_55);\n\t\t\t\t} else {\n\t\t\t\t\t/* COMMENT_48 */\n\t\t\t\t\tVAR_11->stream->mid_ext_id = janus_rtp_header_extension_get_id(VAR_55, VAR_84);\n\t\t\t\t\t/* COMMENT_49 */\n\t\t\t\t\tVAR_11->stream->rid_ext_id = janus_rtp_header_extension_get_id(VAR_55, VAR_85);\n\t\t\t\t\tVAR_11->stream->ridrtx_ext_id = janus_rtp_header_extension_get_id(VAR_55, VAR_86);\n\t\t\t\t\t/* COMMENT_50 */\n\t\t\t\t\tVAR_11->stream->audiolevel_ext_id = janus_rtp_header_extension_get_id(VAR_55, VAR_87);\n\t\t\t\t\t/* COMMENT_51 */\n\t\t\t\t\tVAR_11->stream->videoorientation_ext_id = janus_rtp_header_extension_get_id(VAR_55, VAR_88);\n\t\t\t\t\t/* COMMENT_52 */\n\t\t\t\t\tVAR_11->stream->framemarking_ext_id = janus_rtp_header_extension_get_id(VAR_55, VAR_89);\n\t\t\t\t\t/* COMMENT_53 */\n\t\t\t\t\tint VAR_90 = janus_rtp_header_extension_get_id(VAR_55, VAR_91);\n\t\t\t\t\tVAR_11->stream->do_transport_wide_cc = VAR_90 > 0 ? TRUE : FALSE;\n\t\t\t\t\tVAR_11->stream->transport_wide_cc_ext_id = VAR_90;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* COMMENT_54 */\n                                                                                             \n\t\t\t\tJANUS_LOG(VAR_92, \"[%\"VAR_32\"] Negotiation update, checking what changed...\\n\", VAR_11->handle_id);\n\t\t\t\tif(janus_sdp_process(VAR_11, VAR_77, TRUE) < 0) {\n\t\t\t\t\tJANUS_LOG(VAR_2, \"Error processing SDP\\n\");\n\t\t\t\t\tjanus_sdp_destroy(VAR_77);\n\t\t\t\t\tg_free(VAR_54);\n\t\t\t\t\tjanus_flags_clear(&VAR_11->webrtc_flags, VAR_69);\n\t\t\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_82, \"Error processing SDP\");\n\t\t\t\t\tjanus_mutex_unlock(&VAR_11->mutex);\n\t\t\t\t\tgoto jsondone;\n\t\t\t\t}\n\t\t\t\tif(janus_flags_is_set(&VAR_11->webrtc_flags, VAR_93)) {\n\t\t\t\t\tJANUS_LOG(VAR_92, \"[%\"VAR_32\"] Restarting ICE...\\n\", VAR_11->handle_id);\n\t\t\t\t\t/* COMMENT_56 */\n\t\t\t\t\tif(VAR_11->stream) {\n\t\t\t\t\t\tnice_agent_set_remote_credentials(VAR_11->agent, VAR_11->stream->stream_id,\n\t\t\t\t\t\t\tVAR_11->stream->ruser, VAR_11->stream->rpass);\n\t\t\t\t\t}\n\t\t\t\t\t/* COMMENT_57 */\n\t\t\t\t\tif(VAR_68) {\n\t\t\t\t\t\tjanus_ice_restart(VAR_11);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tjanus_flags_clear(&VAR_11->webrtc_flags, VAR_93);\n\t\t\t\t\t}\n\t\t\t\t\t/* COMMENT_58 */\n\t\t\t\t\tif(janus_ice_is_full_trickle_enabled()) {\n\t\t\t\t\t\tjanus_flags_set(&VAR_11->webrtc_flags, VAR_94);\n\t\t\t\t\t}\n\t\t\t\t}\n#ifdef VAR_81\n\t\t\t\tif(!VAR_68) {\n\t\t\t\t\t/* COMMENT_59 */\n\t\t\t\t\tif(janus_flags_is_set(&VAR_11->webrtc_flags, VAR_95)) {\n\t\t\t\t\t\tjanus_ice_stream *VAR_96 = VAR_11->stream;\n\t\t\t\t\t\tif(VAR_96 != NULL && VAR_96->component != NULL\n\t\t\t\t\t\t\t\t&& VAR_96->component->dtls != NULL && VAR_96->component->dtls->sctp == NULL) {\n\t\t\t\t\t\t\t/* COMMENT_60 */\n\t\t\t\t\t\t\tJANUS_LOG(VAR_80, \"[%\"VAR_32\"] Creating datachannels...\\n\", VAR_11->handle_id);\n\t\t\t\t\t\t\tjanus_dtls_srtp_create_sctp(VAR_96->component->dtls);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t\tchar *VAR_97 = VAR_11->remote_sdp;\n\t\t\tVAR_11->remote_sdp = g_strdup(VAR_55);\n\t\t\tg_free(VAR_97);\n\t\t\tjanus_mutex_unlock(&VAR_11->mutex);\n\t\t\t/* COMMENT_61 */\n\t\t\tif(janus_sdp_anonymize(VAR_77) < 0) {\n\t\t\t\t/* COMMENT_41 */\n\t\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_78, \"JSEP error: invalid SDP\");\n\t\t\t\tjanus_sdp_destroy(VAR_77);\n\t\t\t\tg_free(VAR_54);\n\t\t\t\tjanus_flags_clear(&VAR_11->webrtc_flags, VAR_69);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\tVAR_56 = janus_sdp_write(VAR_77);\n\t\t\tjanus_sdp_destroy(VAR_77);\n\t\t\tVAR_73 = NULL;\n\t\t\tjanus_flags_clear(&VAR_11->webrtc_flags, VAR_69);\n\t\t}\n\n\t\t/* COMMENT_62 */\n\t\tif(VAR_11->app == NULL || !janus_plugin_session_is_alive(VAR_11->app_handle)) {\n\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_50, \"No plugin to handle this message\");\n\t\t\tg_free(VAR_54);\n\t\t\tg_free(VAR_56);\n\t\t\tjanus_flags_clear(&VAR_11->webrtc_flags, VAR_69);\n\t\t\tgoto jsondone;\n\t\t}\n\n\t\t/* COMMENT_63 */\n\t\tjson_incref(VAR_52);\n\t\tjson_t *VAR_98 = NULL;\n\t\tif(VAR_56) {\n\t\t\tVAR_98 = json_pack(\"{ssss}\", \"type\", VAR_54, \"sdp\", VAR_56);\n\t\t\t/* COMMENT_64 */\n\t\t\tif(janus_flags_is_set(&VAR_11->webrtc_flags, VAR_99)) {\n\t\t\t\tif(VAR_11->stream && (VAR_11->stream->rid[0] || VAR_11->stream->video_ssrc_peer[1])) {\n\t\t\t\t\tjson_t *VAR_100 = json_object();\n\t\t\t\t\t/* COMMENT_65 */\n\t\t\t\t\tif(VAR_11->stream->rid[0]) {\n\t\t\t\t\t\tjson_t *VAR_101 = json_array();\n\t\t\t\t\t\tjson_array_append_new(VAR_101, json_string(VAR_11->stream->rid[0]));\n\t\t\t\t\t\tif(VAR_11->stream->rid[1])\n\t\t\t\t\t\t\tjson_array_append_new(VAR_101, json_string(VAR_11->stream->rid[1]));\n\t\t\t\t\t\tif(VAR_11->stream->rid[2])\n\t\t\t\t\t\t\tjson_array_append_new(VAR_101, json_string(VAR_11->stream->rid[2]));\n\t\t\t\t\t\tjson_object_set_new(VAR_100, \"rids\", VAR_101);\n\t\t\t\t\t\tjson_object_set_new(VAR_100, \"rid-ext\", json_integer(VAR_11->stream->rid_ext_id));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tjson_t *VAR_102 = json_array();\n\t\t\t\t\t\tjson_array_append_new(VAR_102, json_integer(VAR_11->stream->video_ssrc_peer[0]));\n\t\t\t\t\t\tif(VAR_11->stream->video_ssrc_peer[1])\n\t\t\t\t\t\t\tjson_array_append_new(VAR_102, json_integer(VAR_11->stream->video_ssrc_peer[1]));\n\t\t\t\t\t\tif(VAR_11->stream->video_ssrc_peer[2])\n\t\t\t\t\t\t\tjson_array_append_new(VAR_102, json_integer(VAR_11->stream->video_ssrc_peer[2]));\n\t\t\t\t\t\tjson_object_set_new(VAR_100, \"ssrcs\", VAR_102);\n\t\t\t\t\t}\n\t\t\t\t\tif(VAR_11->stream->framemarking_ext_id > 0)\n\t\t\t\t\t\tjson_object_set_new(VAR_100, \"framemarking-ext\", json_integer(VAR_11->stream->framemarking_ext_id));\n\t\t\t\t\tjson_object_set_new(VAR_98, \"simulcast\", VAR_100);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* COMMENT_66 */\n\t\t\tif(VAR_57)\n\t\t\t\tjson_object_set_new(VAR_98, \"update\", json_true());\n\t\t}\n\t\tjanus_plugin_result *VAR_103 = VAR_38->handle_message(VAR_11->app_handle,\n\t\t\tg_strdup((char *)VAR_16), VAR_52, VAR_98);\n\t\tg_free(VAR_54);\n\t\tg_free(VAR_56);\n\t\tif(VAR_103 == NULL) {\n\t\t\t/* COMMENT_67 */\n\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_50, \"Plugin didn't give a result\");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(VAR_103->type == VAR_104) {\n\t\t\t/* COMMENT_68 */\n\t\t\tif(VAR_103->content == NULL || !json_is_object(VAR_103->content)) {\n\t\t\t\t/* COMMENT_69 */\n\t\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_50,\n\t\t\t\t\tVAR_103->content == NULL ?\n\t\t\t\t\t\t\"Plugin didn't provide any content for this synchronous response\" :\n\t\t\t\t\t\t\"Plugin returned an invalid JSON response\");\n\t\t\t\tjanus_plugin_result_destroy(VAR_103);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\t/* COMMENT_70 */\n\t\t\tjson_incref(VAR_103->content);\n\t\t\t/* COMMENT_71 */\n\t\t\tjson_t *VAR_19 = janus_create_message(\"success\", VAR_10->session_id, VAR_16);\n\t\t\tjson_object_set_new(VAR_19, \"sender\", json_integer(VAR_11->handle_id));\n\t\t\tif(janus_is_opaqueid_in_api_enabled() && VAR_11->opaque_id != NULL)\n\t\t\t\tjson_object_set_new(VAR_19, \"opaque_id\", json_string(VAR_11->opaque_id));\n\t\t\tjson_t *VAR_105 = json_object();\n\t\t\tjson_object_set_new(VAR_105, \"plugin\", json_string(VAR_38->get_package()));\n\t\t\tjson_object_set_new(VAR_105, \"data\", VAR_103->content);\n\t\t\tjson_object_set_new(VAR_19, \"plugindata\", VAR_105);\n\t\t\t/* COMMENT_14 */\n\t\t\tVAR_1 = janus_process_success(VAR_0, VAR_19);\n\t\t} else if(VAR_103->type == VAR_106) {\n\t\t\t/* COMMENT_72 */\n\t\t\tjson_t *VAR_19 = janus_create_message(\"ack\", VAR_6, VAR_16);\n\t\t\tif(VAR_103->text)\n\t\t\t\tjson_object_set_new(VAR_19, \"hint\", json_string(VAR_103->text));\n\t\t\t/* COMMENT_14 */\n\t\t\tVAR_1 = janus_process_success(VAR_0, VAR_19);\n\t\t} else {\n\t\t\t/* COMMENT_67 */\n\t\t\tVAR_1 = janus_process_error_string(VAR_0, VAR_6, VAR_16, VAR_50,\n\t\t\t\t(char *)(VAR_103->text ? VAR_103->text : \"Plugin returned a severe (unknown) error\"));\n\t\t\tjanus_plugin_result_destroy(VAR_103);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjanus_plugin_result_destroy(VAR_103);\n\t} else if(!strcasecmp(VAR_18, \"trickle\")) {\n\t\tif(VAR_11 == NULL) {\n\t\t\t/* COMMENT_73 */\n\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_20, \"Unhandled request '%s' at this path\", VAR_18);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(VAR_11->app == NULL || !janus_plugin_session_is_alive(VAR_11->app_handle)) {\n\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_50, \"No plugin to handle this trickle candidate\");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjson_t *VAR_107 = json_object_get(VAR_5, \"candidate\");\n\t\tjson_t *VAR_108 = json_object_get(VAR_5, \"candidates\");\n\t\tif(VAR_107 == NULL && VAR_108 == NULL) {\n\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_13, \"Missing mandatory element (candidate|candidates)\");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(VAR_107 != NULL && VAR_108 != NULL) {\n\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_109, \"Can't have both candidate and candidates\");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(janus_flags_is_set(&VAR_11->webrtc_flags, VAR_63)) {\n\t\t\tJANUS_LOG(VAR_2, \"[%\"VAR_32\"] Received a trickle, but still cleaning a previous session\\n\", VAR_11->handle_id);\n\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_66, \"Still cleaning a previous session\");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjanus_mutex_lock(&VAR_11->mutex);\n\t\tif(!janus_flags_is_set(&VAR_11->webrtc_flags, VAR_83)) {\n\t\t\t/* COMMENT_74 */\n\t\t\tJANUS_LOG(VAR_34, \"Handle %\"VAR_32\" supports trickle even if it didn't negotiate it...\\n\", VAR_11->handle_id);\n\t\t\tjanus_flags_set(&VAR_11->webrtc_flags, VAR_83);\n\t\t}\n\t\t/* COMMENT_75 */\n\t\tif(VAR_11->stream == NULL) {\n\t\t\tJANUS_LOG(VAR_80, \"[%\"VAR_32\"] No stream, queueing this trickle as it got here before the SDP...\\n\", VAR_11->handle_id);\n\t\t\t/* COMMENT_76 */\n\t\t\tjanus_ice_trickle *VAR_110 = janus_ice_trickle_new(VAR_16, VAR_107 ? VAR_107 : VAR_108);\n\t\t\tVAR_11->pending_trickles = g_list_append(VAR_11->pending_trickles, VAR_110);\n\t\t\t/* COMMENT_77 */\n\t\t\tgoto trickledone;\n\t\t}\n\t\t/* COMMENT_78 */\n\t\tif(janus_flags_is_set(&VAR_11->webrtc_flags, VAR_69) ||\n\t\t\t\t!janus_flags_is_set(&VAR_11->webrtc_flags, VAR_70) ||\n\t\t\t\t!janus_flags_is_set(&VAR_11->webrtc_flags, VAR_71)) {\n\t\t\tconst char *VAR_111 = NULL;\n\t\t\tif(janus_flags_is_set(&VAR_11->webrtc_flags, VAR_69))\n\t\t\t\tVAR_111 = \"processing the offer\";\n\t\t\telse if(!janus_flags_is_set(&VAR_11->webrtc_flags, VAR_71))\n\t\t\t\tVAR_111 = \"waiting for the answer\";\n\t\t\telse if(!janus_flags_is_set(&VAR_11->webrtc_flags, VAR_70))\n\t\t\t\tVAR_111 = \"waiting for the offer\";\n\t\t\tJANUS_LOG(VAR_34, \"[%\"VAR_32\"] Still %s, queueing this trickle to wait until we're done there...\\n\",\n\t\t\t\tVAR_11->handle_id, VAR_111);\n\t\t\t/* COMMENT_76 */\n\t\t\tjanus_ice_trickle *VAR_110 = janus_ice_trickle_new(VAR_16, VAR_107 ? VAR_107 : VAR_108);\n\t\t\tVAR_11->pending_trickles = g_list_append(VAR_11->pending_trickles, VAR_110);\n\t\t\t/* COMMENT_77 */\n\t\t\tgoto trickledone;\n\t\t}\n\t\tif(VAR_107 != NULL) {\n\t\t\t/* COMMENT_79 */\n\t\t\tint VAR_45 = 0;\n\t\t\tconst char *VAR_112 = NULL;\n\t\t\tif((VAR_45 = janus_ice_trickle_parse(VAR_11, VAR_107, &VAR_112)) != 0) {\n\t\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_45, \"%s\", VAR_112);\n\t\t\t\tjanus_mutex_unlock(&VAR_11->mutex);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t} else {\n\t\t\t/* COMMENT_80 */\n\t\t\tif(!json_is_array(VAR_108)) {\n\t\t\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_14, \"candidates is not an array\");\n\t\t\t\tjanus_mutex_unlock(&VAR_11->mutex);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\tJANUS_LOG(VAR_34, \"Got multiple candidates (%zu)\\n\", json_array_size(VAR_108));\n\t\t\tif(json_array_size(VAR_108) > 0) {\n\t\t\t\t/* COMMENT_81 */\n\t\t\t\tsize_t VAR_113 = 0;\n\t\t\t\tfor(VAR_113=0; VAR_113<json_array_size(VAR_108); VAR_113++) {\n\t\t\t\t\tjson_t *VAR_114 = json_array_get(VAR_108, VAR_113);\n\t\t\t\t\t/* COMMENT_82 */\n\t\t\t\t\tjanus_ice_trickle_parse(VAR_11, VAR_114, NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\ntrickledone:\n\t\tjanus_mutex_unlock(&VAR_11->mutex);\n\t\t/* COMMENT_83 */\n\t\tjson_t *VAR_19 = janus_create_message(\"ack\", VAR_6, VAR_16);\n\t\t/* COMMENT_14 */\n\t\tVAR_1 = janus_process_success(VAR_0, VAR_19);\n\t} else {\n\t\tVAR_1 = janus_process_error(VAR_0, VAR_6, VAR_16, VAR_115, \"Unknown request '%s'\", VAR_18);\n\t}\n\njsondone:\n\t/* COMMENT_84 */\n\tif(VAR_11 != NULL)\n\t\tjanus_refcount_decrease(&VAR_11->ref);\n\tif(VAR_10 != NULL)\n\t\tjanus_refcount_decrease(&VAR_10->ref);\n\treturn VAR_1;\n}",
  "func_graph_path": "meetecho/janus-gateway/bc319056603295953f4a70999bc4553785c6e5ef/janus.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -217,9 +217,10 @@\n \t\tg_hash_table_remove(sessions, &session->session_id);\n \t\tjanus_mutex_unlock(&sessions_mutex);\n \t\t/* Notify the source that the session has been destroyed */\n-\t\tif(session->source && session->source->transport) {\n+\t\tjanus_mutex_lock(&session->mutex);\n+\t\tif(session->source && session->source->transport)\n \t\t\tsession->source->transport->session_over(session->source->instance, session->session_id, FALSE, FALSE);\n-\t\t}\n+\t\tjanus_mutex_unlock(&session->mutex);\n \t\t/* Schedule the session for deletion */\n \t\tjanus_session_destroy(session);\n ",
  "diff_line_info": {
    "deleted_lines": [
      "\t\tif(session->source && session->source->transport) {",
      "\t\t}"
    ],
    "added_lines": [
      "\t\tjanus_mutex_lock(&session->mutex);",
      "\t\tif(session->source && session->source->transport)",
      "\t\tjanus_mutex_unlock(&session->mutex);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/meetecho/janus-gateway/pull/1990",
  "description": {
    "pr_info": {
      "title": "Fix rare race condition when claiming sessions",
      "number": 1990
    },
    "comment": [
      "Ref: CVE-2020-10577\r\n\r\nWe've been notified about a rare race condition that can occur when claiming sessions, specifically when a \"claim\" request for a session happens at the same time as an event pushed by a plugin to a handle belonging to the session itself. The root cause is that the `source` property of `session` (which contains the info to relate a session to a transport instance) is used by different threads concurrently, and only some parts of the code are locking it properly: specifically, the code for \"claim\" does, while the code that notifies the event doesn't.\r\n\r\nLooking at the code, I found other instances where `source` was accessed without a lock, so this patch makes sure they're all fixed. The only place where this doesn't happen is `janus_check_sessions`, as when `source` is accessed there a session has already timed out, meaning no conflicts are likely to take place. The patch also makes \"claim\" do nothing if you're trying to claim a session you already own (meaning \"claim\" comes from the same transport instance that is managing the session already): before we were replacing it with itself, which made little sense and made the issue easier to replicate.\r\n\r\nI don't expect this to cause issues, as I've followed the core/transports interaction for the calls that are invoked from within the lock, and I didn't find any way transports can go back to the core and try to lock the same mutex. As such, I'm planning to merge soon, but feedback that might prove me wrong is more than welcome.",
      "> The implementation of `send_message` is up to the transport, so it might be blocking for a long time, this is not known ahead of time.\r\n\r\nFair point: we should be safe with the existing transports, though. All transports just add to a queue, right now, with the exception of MQTT which uses `MQTTAsync_sendMessage` that is asynchronous anyway. We'll probably want to add something to the documentation that says `send_message` should not be blocking, for people interested in contributing a new transport.",
      "Merging."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Step-by-Step Explanation:**\n\n1. **Input Analysis:**  \n   - The commit message clearly states it's fixing a race condition, which is a concurrency issue.\n   - The vulnerability description references a CVE (CVE-2020-10577) and explains a race condition in session claiming involving the `source` property.\n   - The code diff shows added mutex locks around accessing `session->source`, which is a standard fix for race conditions.\n\n2. **Consistency Check:**  \n   - The commit message matches the code changes. Both address the same issue of unsynchronized access to `session->source`.\n\n3. **Purpose Evaluation:**  \n   - The patch modifies core logic related to session handling and concurrency, specifically to fix a bug that could lead to security issues.\n\n4. **Security Vulnerability Assessment:**  \n   - The issue is a known security vulnerability (CVE-2020-10577). The fix resolves a race condition that could allow multiple threads to access shared data without proper synchronization, potentially leading to exploitation.\n\n5. **Non-Security Classification:**  \n   - Not applicable; the patch is a security fix.\n\n6. **Confidence Scoring:**  \n   - The information is clear, and the code changes directly address the security issue. All components align perfectly.\n\n**Final Classification:** Security Vulnerability Fix;  \n**Confidence:** 1.0"
}