{
  "cve_id": "CVE-2023-31438",
  "cwe_ids": [
    "CWE-354"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N",
  "cvss_is_v3": true,
  "repo_name": "systemd",
  "commit_msg": "journalctl: verify sealed log epochs are continuous\n\nCurrently empty epochs are not sealed. This allows an attacker to truncate\na sealed log and continue it without any problems showing when verifying the\nlog.\n\nThis partially addresses CVE-2023-31438. One way to extend this change to\naddress CVE-2023-31438 completely, would be to verify that there is exactly\none seal per epoch (and not sealing when the epoch has not ended yet).\n\nthe change also adds a journal-file flag: HEADER_COMPATIBLE_SEALED_CONTINUOUS\nthis flag indicates that a journal file is sealed continuously and decides whether\nany missing crypto epochs should trigger a warning or an error.",
  "commit_hash": "8d7b0958cdb505047e5a66029468b8d12b8a7add",
  "git_url": "https://github.com/systemd/systemd/commit/8d7b0958cdb505047e5a66029468b8d12b8a7add",
  "file_path": "src/libsystemd/sd-journal/journal-authenticate.c",
  "func_name": "journal_file_append_tag",
  "func_before": "int journal_file_append_tag(JournalFile *f) {\n        Object *o;\n        uint64_t p;\n        int r;\n\n        assert(f);\n\n        if (!JOURNAL_HEADER_SEALED(f->header))\n                return 0;\n\n        if (!f->hmac_running)\n                return 0;\n\n        assert(f->hmac);\n\n        r = journal_file_append_object(f, OBJECT_TAG, sizeof(struct TagObject), &o, &p);\n        if (r < 0)\n                return r;\n\n        o->tag.seqnum = htole64(journal_file_tag_seqnum(f));\n        o->tag.epoch = htole64(FSPRG_GetEpoch(f->fsprg_state));\n\n        log_debug(\"Writing tag %\"PRIu64\" for epoch %\"PRIu64\"\",\n                  le64toh(o->tag.seqnum),\n                  FSPRG_GetEpoch(f->fsprg_state));\n\n        /* Add the tag object itself, so that we can protect its\n         * header. This will exclude the actual hash value in it */\n        r = journal_file_hmac_put_object(f, OBJECT_TAG, o, p);\n        if (r < 0)\n                return r;\n\n        /* Get the HMAC tag and store it in the object */\n        memcpy(o->tag.tag, gcry_md_read(f->hmac, 0), TAG_LENGTH);\n        f->hmac_running = false;\n\n        return 0;\n}",
  "abstract_func_before": "int journal_file_append_tag(JournalFile *VAR_0) {\n        Object *VAR_1;\n        uint64_t VAR_2;\n        int VAR_3;\n\n        assert(VAR_0);\n\n        if (!JOURNAL_HEADER_SEALED(VAR_0->header))\n                return 0;\n\n        if (!VAR_0->hmac_running)\n                return 0;\n\n        assert(VAR_0->hmac);\n\n        VAR_3 = journal_file_append_object(VAR_0, VAR_4, sizeof(struct TagObject), &VAR_1, &VAR_2);\n        if (VAR_3 < 0)\n                return VAR_3;\n\n        VAR_1->tag.seqnum = htole64(journal_file_tag_seqnum(VAR_0));\n        VAR_1->tag.epoch = htole64(FSPRG_GetEpoch(VAR_0->fsprg_state));\n\n        log_debug(\"Writing tag %\"VAR_5\" for epoch %\"VAR_5\"\",\n                  le64toh(VAR_1->tag.seqnum),\n                  FSPRG_GetEpoch(VAR_0->fsprg_state));\n\n        /* COMMENT_0 */\n                                                                   \n        VAR_3 = journal_file_hmac_put_object(VAR_0, VAR_4, VAR_1, VAR_2);\n        if (VAR_3 < 0)\n                return VAR_3;\n\n        /* COMMENT_2 */\n        memcpy(VAR_1->tag.tag, gcry_md_read(VAR_0->hmac, 0), VAR_6);\n        VAR_0->hmac_running = false;\n\n        return 0;\n}",
  "func_graph_path_before": "systemd/8d7b0958cdb505047e5a66029468b8d12b8a7add/journal-authenticate.c/vul/before/0.json",
  "func": "int journal_file_append_tag(JournalFile *f) {\n        Object *o;\n        uint64_t p;\n        int r;\n\n        assert(f);\n\n        if (!JOURNAL_HEADER_SEALED(f->header))\n                return 0;\n\n        if (!f->hmac_running) {\n                r = journal_file_hmac_start(f);\n                if (r < 0)\n                        return r;\n        }\n\n        assert(f->hmac);\n\n        r = journal_file_append_object(f, OBJECT_TAG, sizeof(struct TagObject), &o, &p);\n        if (r < 0)\n                return r;\n\n        o->tag.seqnum = htole64(journal_file_tag_seqnum(f));\n        o->tag.epoch = htole64(FSPRG_GetEpoch(f->fsprg_state));\n\n        log_debug(\"Writing tag %\"PRIu64\" for epoch %\"PRIu64\"\",\n                  le64toh(o->tag.seqnum),\n                  FSPRG_GetEpoch(f->fsprg_state));\n\n        /* Add the tag object itself, so that we can protect its\n         * header. This will exclude the actual hash value in it */\n        r = journal_file_hmac_put_object(f, OBJECT_TAG, o, p);\n        if (r < 0)\n                return r;\n\n        /* Get the HMAC tag and store it in the object */\n        memcpy(o->tag.tag, gcry_md_read(f->hmac, 0), TAG_LENGTH);\n        f->hmac_running = false;\n\n        return 0;\n}",
  "abstract_func": "int journal_file_append_tag(JournalFile *VAR_0) {\n        Object *VAR_1;\n        uint64_t VAR_2;\n        int VAR_3;\n\n        assert(VAR_0);\n\n        if (!JOURNAL_HEADER_SEALED(VAR_0->header))\n                return 0;\n\n        if (!VAR_0->hmac_running) {\n                VAR_3 = journal_file_hmac_start(VAR_0);\n                if (VAR_3 < 0)\n                        return VAR_3;\n        }\n\n        assert(VAR_0->hmac);\n\n        VAR_3 = journal_file_append_object(VAR_0, VAR_4, sizeof(struct TagObject), &VAR_1, &VAR_2);\n        if (VAR_3 < 0)\n                return VAR_3;\n\n        VAR_1->tag.seqnum = htole64(journal_file_tag_seqnum(VAR_0));\n        VAR_1->tag.epoch = htole64(FSPRG_GetEpoch(VAR_0->fsprg_state));\n\n        log_debug(\"Writing tag %\"VAR_5\" for epoch %\"VAR_5\"\",\n                  le64toh(VAR_1->tag.seqnum),\n                  FSPRG_GetEpoch(VAR_0->fsprg_state));\n\n        /* COMMENT_0 */\n                                                                   \n        VAR_3 = journal_file_hmac_put_object(VAR_0, VAR_4, VAR_1, VAR_2);\n        if (VAR_3 < 0)\n                return VAR_3;\n\n        /* COMMENT_2 */\n        memcpy(VAR_1->tag.tag, gcry_md_read(VAR_0->hmac, 0), VAR_6);\n        VAR_0->hmac_running = false;\n\n        return 0;\n}",
  "func_graph_path": "systemd/8d7b0958cdb505047e5a66029468b8d12b8a7add/journal-authenticate.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -8,8 +8,11 @@\n         if (!JOURNAL_HEADER_SEALED(f->header))\n                 return 0;\n \n-        if (!f->hmac_running)\n-                return 0;\n+        if (!f->hmac_running) {\n+                r = journal_file_hmac_start(f);\n+                if (r < 0)\n+                        return r;\n+        }\n \n         assert(f->hmac);\n ",
  "diff_line_info": {
    "deleted_lines": [
      "        if (!f->hmac_running)",
      "                return 0;"
    ],
    "added_lines": [
      "        if (!f->hmac_running) {",
      "                r = journal_file_hmac_start(f);",
      "                if (r < 0)",
      "                        return r;",
      "        }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/systemd/systemd/pull/28886",
  "description": {
    "pr_info": {
      "title": "journalctl: verify sealed log epochs are continuous",
      "number": 28886
    },
    "comment": [
      "Currently empty epochs are not sealed. This allows an attacker to truncate a sealed log and continue it without any problems showing when verifying the log.\r\n\r\nThis partially addresses CVE-2023-31438. One way to extend this change to address CVE-2023-31438 completely, would be to verify that there is exactly one seal per epoch (and not sealing when the epoch has not ended yet). I didn't remove the premature sealing, as it is implemented purposefully although I don't understand the purpose.\r\nSee https://github.com/kastel-security/Journald/blob/main/journald-publication.pdf for more background.\r\n\r\nThis change adjusts what journald writes into a log file but is compatible in the sense that old `journalctl` versions will successfully verify new journals, but the new `journalctl --verify` will refuse to accept a journal created with old journald if there are gaps in the sealed epochs.\r\n\r\nSee also #28433\n\n<!-- devel-freezer = {\"comment-id\":\"1801865051\",\"freezing-tag\":\"v255-rc1\"} -->",
      "looks good, but i am a bit concerned about the compat with this, see comment above",
      "Good idea. I added a draft version of a `SEALED_CONTINOUS`-flag to change the error message to a warning. Thinking more closely about it: We cannot guarantee completeness for old journal files regardless of whether the epochs are continuous or not, due to the fact that journald seals an epoch prematurely when closed. Because that allows an attacker to drop the second seal, when the epoch actually ended, and claim the premature seal is the only correct one.\r\n\r\nSo I think we should drop premature sealing and then this should be the behavior:\r\nWhen not `SEALED_CONTINOUS` we should issue a warning, that we cannot guarantee consistency, unconditionally. (And for the rest of the verification, fall back to verifying the more loose constraint).\r\n\r\nWould you be fine with dropping premature sealing, that is this block:\r\nhttps://github.com/systemd/systemd/blob/1ffa5cfb38b3d30d269259c531300fc629816ea9/src/journal/managed-journal-file.c#L395\r\nor can you tell my why it is needed?",
      "I've gone ahead and removed the premature sealing. The only remaining gap is now between rotated journal files.",
      "Please rebase and squash commits.",
      "So @yuwata you do not want to do a final review and merge this, but we let it sit again until someone else picks it up?",
      "lgtm. just some minor things.",
      "An -rc1 tag has been created and a release is being prepared, so please note that PRs introducing new features and APIs will be held back until the new version has been released.\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95\n\nThe patch addresses CVE-2023-31438 by ensuring that empty epochs are properly sealed, preventing attackers from truncating logs undetected. The code modifications support this security fix, making it a clear security vulnerability resolution."
}