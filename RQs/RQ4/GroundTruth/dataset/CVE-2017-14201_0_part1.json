{
  "cve_id": "CVE-2017-14201",
  "cwe_ids": [
    "CWE-416"
  ],
  "cvss_vector": "AV:L/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "zephyrproject-rtos/zephyr",
  "commit_msg": "net: shell: dns: Properly manage lifetime of callback data\n\nDNS callback needs \"struct shell *shell\" data structure to pass as\na parameter to shell print. How it was achieved previously is that\nit was packaged together with cosmetic \"bool first\" param into\n\"struct net_shell_user_data\" on the stack, and passed to the\ncallback. The problem was that the original command handler then\nreturned, so the \"struct net_shell_user_data\" on the stack was\noverwritten, and the callback crashed on accessing it.\n\nAn obvious solution was to make that structure static, but that would\nleave to issues still, as turns out we allow system shell to be run\nas more than one concurrent instances.\n\nNext solution was to keep this structure on the stack, but block the\ncommand handler until callback is finished. However, that hit a\ndeadlock due to not well thought out use of a mutex in the shell\nprinting routines.\n\nThe solution presented here is due to @nordic-krch, who noticed that\n\"bool first\" param is indeed cosmetic and not really required. Then\nwe have only \"struct shell *shell\" to pass to the callback, and can\ndo that in callback's pointer param directly, ditching\n\"struct net_shell_user_data\" which needs to be stored on the stack.\n\nSigned-off-by: Paul Sokolovsky <paul.sokolovsky@linaro.org>",
  "commit_hash": "c55722b22e58c5337c36cc21159330735cb64603",
  "git_url": "https://github.com/zephyrproject-rtos/zephyr/commit/c55722b22e58c5337c36cc21159330735cb64603",
  "file_path": "subsys/net/ip/net_shell.c",
  "func_name": "cmd_net_dns_query",
  "func_before": "static int cmd_net_dns_query(const struct shell *shell, size_t argc,\n\t\t\t     char *argv[])\n{\n\n#if defined(CONFIG_DNS_RESOLVER)\n#define DNS_TIMEOUT K_MSEC(2000) /* ms */\n\tstruct net_shell_user_data user_data;\n\tenum dns_query_type qtype = DNS_QUERY_TYPE_A;\n\tchar *host, *type = NULL;\n\tbool first = true;\n\tint ret, arg = 1;\n\n\thost = argv[arg++];\n\tif (!host) {\n\t\tPR_WARNING(\"Hostname not specified.\\n\");\n\t\treturn -ENOEXEC;\n\t}\n\n\tif (argv[arg]) {\n\t\ttype = argv[arg];\n\t}\n\n\tif (type) {\n\t\tif (strcmp(type, \"A\") == 0) {\n\t\t\tqtype = DNS_QUERY_TYPE_A;\n\t\t\tPR(\"IPv4 address type\\n\");\n\t\t} else if (strcmp(type, \"AAAA\") == 0) {\n\t\t\tqtype = DNS_QUERY_TYPE_AAAA;\n\t\t\tPR(\"IPv6 address type\\n\");\n\t\t} else {\n\t\t\tPR_WARNING(\"Unknown query type, specify either \"\n\t\t\t\t   \"A or AAAA\\n\");\n\t\t\treturn -ENOEXEC;\n\t\t}\n\t}\n\n\tuser_data.shell = shell;\n\tuser_data.user_data = &first;\n\n\tret = dns_get_addr_info(host, qtype, NULL, dns_result_cb, &user_data,\n\t\t\t\tDNS_TIMEOUT);\n\tif (ret < 0) {\n\t\tPR_WARNING(\"Cannot resolve '%s' (%d)\\n\", host, ret);\n\t} else {\n\t\tPR(\"Query for '%s' sent.\\n\", host);\n\t}\n#else\n\tPR_INFO(\"DNS resolver not supported. Set CONFIG_DNS_RESOLVER to \"\n\t\t\"enable it.\\n\");\n#endif\n\n\treturn 0;\n}",
  "abstract_func_before": "static int cmd_net_dns_query(const struct shell *shell, size_t VAR_0,\n\t\t\t     char *VAR_1[])\n{\n\n#if defined(VAR_2)\n#define VAR_3 K_MSEC(2000) /* ms */\n\tstruct net_shell_user_data VAR_4;\n\tenum dns_query_type VAR_5 = VAR_6;\n\tchar *VAR_7, *VAR_8 = NULL;\n\tbool VAR_9 = true;\n\tint VAR_10, VAR_11 = 1;\n\n\tVAR_7 = VAR_1[VAR_11++];\n\tif (!VAR_7) {\n\t\tPR_WARNING(\"Hostname not specified.\\n\");\n\t\treturn -VAR_12;\n\t}\n\n\tif (VAR_1[VAR_11]) {\n\t\tVAR_8 = VAR_1[VAR_11];\n\t}\n\n\tif (VAR_8) {\n\t\tif (strcmp(VAR_8, \"A\") == 0) {\n\t\t\tVAR_5 = VAR_6;\n\t\t\tPR(\"IPv4 address type\\n\");\n\t\t} else if (strcmp(VAR_8, \"AAAA\") == 0) {\n\t\t\tVAR_5 = VAR_13;\n\t\t\tPR(\"IPv6 address type\\n\");\n\t\t} else {\n\t\t\tPR_WARNING(\"Unknown query type, specify either \"\n\t\t\t\t   \"A or AAAA\\n\");\n\t\t\treturn -VAR_12;\n\t\t}\n\t}\n\n\tVAR_4.shell = shell;\n\tVAR_4.user_data = &VAR_9;\n\n\tVAR_10 = dns_get_addr_info(VAR_7, VAR_5, NULL, VAR_14, &VAR_4,\n\t\t\t\tVAR_3);\n\tif (VAR_10 < 0) {\n\t\tPR_WARNING(\"Cannot resolve '%s' (%d)\\n\", VAR_7, VAR_10);\n\t} else {\n\t\tPR(\"Query for '%s' sent.\\n\", VAR_7);\n\t}\n#else\n\tPR_INFO(\"DNS resolver not supported. Set CONFIG_DNS_RESOLVER to \"\n\t\t\"enable it.\\n\");\n#endif\n\n\treturn 0;\n}",
  "func_graph_path_before": "zephyrproject-rtos/zephyr/c55722b22e58c5337c36cc21159330735cb64603/net_shell.c/vul/before/1.json",
  "func": "static int cmd_net_dns_query(const struct shell *shell, size_t argc,\n\t\t\t     char *argv[])\n{\n\n#if defined(CONFIG_DNS_RESOLVER)\n#define DNS_TIMEOUT K_MSEC(2000) /* ms */\n\tenum dns_query_type qtype = DNS_QUERY_TYPE_A;\n\tchar *host, *type = NULL;\n\tint ret, arg = 1;\n\n\thost = argv[arg++];\n\tif (!host) {\n\t\tPR_WARNING(\"Hostname not specified.\\n\");\n\t\treturn -ENOEXEC;\n\t}\n\n\tif (argv[arg]) {\n\t\ttype = argv[arg];\n\t}\n\n\tif (type) {\n\t\tif (strcmp(type, \"A\") == 0) {\n\t\t\tqtype = DNS_QUERY_TYPE_A;\n\t\t\tPR(\"IPv4 address type\\n\");\n\t\t} else if (strcmp(type, \"AAAA\") == 0) {\n\t\t\tqtype = DNS_QUERY_TYPE_AAAA;\n\t\t\tPR(\"IPv6 address type\\n\");\n\t\t} else {\n\t\t\tPR_WARNING(\"Unknown query type, specify either \"\n\t\t\t\t   \"A or AAAA\\n\");\n\t\t\treturn -ENOEXEC;\n\t\t}\n\t}\n\n\tret = dns_get_addr_info(host, qtype, NULL, dns_result_cb,\n\t\t\t\t(void *)shell, DNS_TIMEOUT);\n\tif (ret < 0) {\n\t\tPR_WARNING(\"Cannot resolve '%s' (%d)\\n\", host, ret);\n\t} else {\n\t\tPR(\"Query for '%s' sent.\\n\", host);\n\t}\n#else\n\tPR_INFO(\"DNS resolver not supported. Set CONFIG_DNS_RESOLVER to \"\n\t\t\"enable it.\\n\");\n#endif\n\n\treturn 0;\n}",
  "abstract_func": "static int cmd_net_dns_query(const struct shell *shell, size_t VAR_0,\n\t\t\t     char *VAR_1[])\n{\n\n#if defined(VAR_2)\n#define VAR_3 K_MSEC(2000) /* ms */\n\tenum dns_query_type VAR_4 = VAR_5;\n\tchar *VAR_6, *VAR_7 = NULL;\n\tint VAR_8, VAR_9 = 1;\n\n\tVAR_6 = VAR_1[VAR_9++];\n\tif (!VAR_6) {\n\t\tPR_WARNING(\"Hostname not specified.\\n\");\n\t\treturn -VAR_10;\n\t}\n\n\tif (VAR_1[VAR_9]) {\n\t\tVAR_7 = VAR_1[VAR_9];\n\t}\n\n\tif (VAR_7) {\n\t\tif (strcmp(VAR_7, \"A\") == 0) {\n\t\t\tVAR_4 = VAR_5;\n\t\t\tPR(\"IPv4 address type\\n\");\n\t\t} else if (strcmp(VAR_7, \"AAAA\") == 0) {\n\t\t\tVAR_4 = VAR_11;\n\t\t\tPR(\"IPv6 address type\\n\");\n\t\t} else {\n\t\t\tPR_WARNING(\"Unknown query type, specify either \"\n\t\t\t\t   \"A or AAAA\\n\");\n\t\t\treturn -VAR_10;\n\t\t}\n\t}\n\n\tVAR_8 = dns_get_addr_info(VAR_6, VAR_4, NULL, VAR_12,\n\t\t\t\t(void *)shell, VAR_3);\n\tif (VAR_8 < 0) {\n\t\tPR_WARNING(\"Cannot resolve '%s' (%d)\\n\", VAR_6, VAR_8);\n\t} else {\n\t\tPR(\"Query for '%s' sent.\\n\", VAR_6);\n\t}\n#else\n\tPR_INFO(\"DNS resolver not supported. Set CONFIG_DNS_RESOLVER to \"\n\t\t\"enable it.\\n\");\n#endif\n\n\treturn 0;\n}",
  "func_graph_path": "zephyrproject-rtos/zephyr/c55722b22e58c5337c36cc21159330735cb64603/net_shell.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -4,10 +4,8 @@\n \n #if defined(CONFIG_DNS_RESOLVER)\n #define DNS_TIMEOUT K_MSEC(2000) /* ms */\n-\tstruct net_shell_user_data user_data;\n \tenum dns_query_type qtype = DNS_QUERY_TYPE_A;\n \tchar *host, *type = NULL;\n-\tbool first = true;\n \tint ret, arg = 1;\n \n \thost = argv[arg++];\n@@ -34,11 +32,8 @@\n \t\t}\n \t}\n \n-\tuser_data.shell = shell;\n-\tuser_data.user_data = &first;\n-\n-\tret = dns_get_addr_info(host, qtype, NULL, dns_result_cb, &user_data,\n-\t\t\t\tDNS_TIMEOUT);\n+\tret = dns_get_addr_info(host, qtype, NULL, dns_result_cb,\n+\t\t\t\t(void *)shell, DNS_TIMEOUT);\n \tif (ret < 0) {\n \t\tPR_WARNING(\"Cannot resolve '%s' (%d)\\n\", host, ret);\n \t} else {",
  "diff_line_info": {
    "deleted_lines": [
      "\tstruct net_shell_user_data user_data;",
      "\tbool first = true;",
      "\tuser_data.shell = shell;",
      "\tuser_data.user_data = &first;",
      "",
      "\tret = dns_get_addr_info(host, qtype, NULL, dns_result_cb, &user_data,",
      "\t\t\t\tDNS_TIMEOUT);"
    ],
    "added_lines": [
      "\tret = dns_get_addr_info(host, qtype, NULL, dns_result_cb,",
      "\t\t\t\t(void *)shell, DNS_TIMEOUT);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/zephyrproject-rtos/zephyr/pull/13260",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/zephyrproject-rtos/zephyr/pull/13260: 403 Client Error: Forbidden for url: https://api.github.com/repos/zephyrproject-rtos/zephyr/pulls/13260",
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence:** 0.9"
}