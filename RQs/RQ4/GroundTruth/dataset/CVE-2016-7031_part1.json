{
  "cve_id": "CVE-2016-7031",
  "cwe_ids": [
    "CWE-254",
    "CWE-200"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:N/A:N",
  "cvss_is_v3": false,
  "repo_name": "ceph",
  "commit_msg": "13207: Rados Gateway: Anonymous user is able to read bucket with authenticated read ACL\n\nSigned-off-by: root <rahul.1aggarwal@gmail.com>",
  "commit_hash": "99ba6610a8f437604cadf68cbe9969def893e870",
  "git_url": "https://github.com/ceph/ceph/commit/99ba6610a8f437604cadf68cbe9969def893e870",
  "file_path": "src/rgw/rgw_op.cc",
  "func_name": "rgw_build_policies",
  "func_before": "static int rgw_build_policies(RGWRados *store, struct req_state *s, bool only_bucket, bool prefetch_data)\n{\n  int ret = 0;\n  rgw_obj_key obj;\n  RGWUserInfo bucket_owner_info;\n  RGWObjectCtx& obj_ctx = *static_cast<RGWObjectCtx *>(s->obj_ctx);\n\n  string bi = s->info.args.get(RGW_SYS_PARAM_PREFIX \"bucket-instance\");\n  if (!bi.empty()) {\n    int shard_id;\n    ret = rgw_bucket_parse_bucket_instance(bi, &s->bucket_instance_id, &shard_id);\n    if (ret < 0) {\n      return ret;\n    }\n  }\n\n  s->bucket_acl = new RGWAccessControlPolicy(s->cct);\n\n  if (s->copy_source) { /* check if copy source is within the current domain */\n    const char *src = s->copy_source;\n    if (*src == '/')\n      ++src;\n    string copy_source_str(src);\n\n    int pos = copy_source_str.find('/');\n    if (pos > 0)\n      copy_source_str = copy_source_str.substr(0, pos);\n\n    RGWBucketInfo source_info;\n\n    ret = store->get_bucket_info(obj_ctx, copy_source_str, source_info, NULL);\n    if (ret == 0) {\n      string& region = source_info.region;\n      s->local_source = store->region.equals(region);\n    }\n  }\n\n  if (!s->bucket_name_str.empty()) {\n    s->bucket_exists = true;\n    if (s->bucket_instance_id.empty()) {\n      ret = store->get_bucket_info(obj_ctx, s->bucket_name_str, s->bucket_info, NULL, &s->bucket_attrs);\n    } else {\n      ret = store->get_bucket_instance_info(obj_ctx, s->bucket_instance_id, s->bucket_info, NULL, &s->bucket_attrs);\n    }\n    if (ret < 0) {\n      if (ret != -ENOENT) {\n        ldout(s->cct, 0) << \"NOTICE: couldn't get bucket from bucket_name (name=\" << s->bucket_name_str << \")\" << dendl;\n        return ret;\n      }\n      s->bucket_exists = false;\n    }\n    s->bucket = s->bucket_info.bucket;\n\n    if (s->bucket_exists) {\n      rgw_obj_key no_obj;\n      ret = read_policy(store, s, s->bucket_info, s->bucket_attrs, s->bucket_acl, s->bucket, no_obj);\n    } else {\n      s->bucket_acl->create_default(s->user.user_id, s->user.display_name);\n      ret = -ERR_NO_SUCH_BUCKET;\n    }\n\n    s->bucket_owner = s->bucket_acl->get_owner();\n\n    string& region = s->bucket_info.region;\n    map<string, RGWRegion>::iterator dest_region = store->region_map.regions.find(region);\n    if (dest_region != store->region_map.regions.end() && !dest_region->second.endpoints.empty()) {\n      s->region_endpoint = dest_region->second.endpoints.front();\n    }\n    if (s->bucket_exists && !store->region.equals(region)) {\n      ldout(s->cct, 0) << \"NOTICE: request for data in a different region (\" << region << \" != \" << store->region.name << \")\" << dendl;\n      /* we now need to make sure that the operation actually requires copy source, that is\n       * it's a copy operation\n       */\n      if (store->region.is_master && s->op == OP_DELETE && s->system_request) {\n        /*If the operation is delete and if this is the master, don't redirect*/\n      } else if (!s->local_source ||\n          (s->op != OP_PUT && s->op != OP_COPY) ||\n          s->object.empty()) {\n        return -ERR_PERMANENT_REDIRECT;\n      }\n    }\n  }\n\n  /* we're passed only_bucket = true when we specifically need the bucket's\n     acls, that happens on write operations */\n  if (!only_bucket && !s->object.empty()) {\n    if (!s->bucket_exists) {\n      return -ERR_NO_SUCH_BUCKET;\n    }\n    s->object_acl = new RGWAccessControlPolicy(s->cct);\n\n    rgw_obj obj(s->bucket, s->object);\n    store->set_atomic(s->obj_ctx, obj);\n    if (prefetch_data) {\n      store->set_prefetch_data(s->obj_ctx, obj);\n    }\n    ret = read_policy(store, s, s->bucket_info, s->bucket_attrs, s->object_acl, s->bucket, s->object);\n  }\n\n  return ret;\n}",
  "abstract_func_before": "static int rgw_build_policies(RGWRados *VAR_0, struct req_state *VAR_1, bool VAR_2, bool VAR_3)\n{\n  int VAR_4 = 0;\n  rgw_obj_key VAR_5;\n  RGWUserInfo VAR_6;\n  RGWObjectCtx& VAR_7 = *VAR_8<RGWObjectCtx *>(VAR_1->obj_ctx);\n\n  string VAR_9 = VAR_1->info.args.get(VAR_10 \"bucket-instance\");\n  if (!VAR_9.empty()) {\n    int VAR_11;\n    VAR_4 = rgw_bucket_parse_bucket_instance(VAR_9, &VAR_1->bucket_instance_id, &VAR_11);\n    if (VAR_4 < 0) {\n      return VAR_4;\n    }\n  }\n\n  VAR_1->bucket_acl = new RGWAccessControlPolicy(VAR_1->cct);\n\n  if (VAR_1->copy_source) { /* COMMENT_0 */\n    const char *VAR_12 = VAR_1->copy_source;\n    if (*VAR_12 == '/')\n      ++VAR_12;\n    string copy_source_str(src);\n\n    int VAR_13 = VAR_14.find('/');\n    if (VAR_13 > 0)\n      VAR_14 = VAR_14.substr(0, VAR_13);\n\n    RGWBucketInfo VAR_15;\n\n    VAR_4 = VAR_0->get_bucket_info(VAR_7, VAR_14, VAR_15, NULL);\n    if (VAR_4 == 0) {\n      string& VAR_16 = VAR_15.region;\n      VAR_1->local_source = VAR_0->region.equals(VAR_16);\n    }\n  }\n\n  if (!VAR_1->bucket_name_str.empty()) {\n    VAR_1->bucket_exists = true;\n    if (VAR_1->bucket_instance_id.empty()) {\n      VAR_4 = VAR_0->get_bucket_info(VAR_7, VAR_1->bucket_name_str, VAR_1->bucket_info, NULL, &VAR_1->bucket_attrs);\n    } else {\n      VAR_4 = VAR_0->get_bucket_instance_info(VAR_7, VAR_1->bucket_instance_id, VAR_1->bucket_info, NULL, &VAR_1->bucket_attrs);\n    }\n    if (VAR_4 < 0) {\n      if (VAR_4 != -VAR_17) {\n        ldout(VAR_1->cct, 0) << \"NOTICE: couldn't get bucket from bucket_name (name=\" << VAR_1->bucket_name_str << \")\" << VAR_18;\n        return VAR_4;\n      }\n      VAR_1->bucket_exists = false;\n    }\n    VAR_1->bucket = VAR_1->bucket_info.bucket;\n\n    if (VAR_1->bucket_exists) {\n      rgw_obj_key VAR_19;\n      VAR_4 = read_policy(VAR_0, VAR_1, VAR_1->bucket_info, VAR_1->bucket_attrs, VAR_1->bucket_acl, VAR_1->bucket, VAR_19);\n    } else {\n      VAR_1->bucket_acl->create_default(VAR_1->user.user_id, VAR_1->user.display_name);\n      VAR_4 = -VAR_20;\n    }\n\n    VAR_1->bucket_owner = VAR_1->bucket_acl->get_owner();\n\n    string& VAR_16 = VAR_1->bucket_info.region;\n    map<string, RGWRegion>::iterator VAR_21 = VAR_0->region_map.regions.find(VAR_16);\n    if (VAR_21 != VAR_0->region_map.regions.end() && !VAR_21->second.endpoints.empty()) {\n      VAR_1->region_endpoint = VAR_21->second.endpoints.front();\n    }\n    if (VAR_1->bucket_exists && !VAR_0->region.equals(VAR_16)) {\n      ldout(VAR_1->cct, 0) << \"NOTICE: request for data in a different region (\" << VAR_16 << \" != \" << VAR_0->region.name << \")\" << VAR_18;\n      /* COMMENT_1 */\n                              \n         \n      if (VAR_0->region.is_master && VAR_1->op == VAR_22 && VAR_1->system_request) {\n        /* COMMENT_4 */\n      } else if (!VAR_1->local_source ||\n          (VAR_1->op != VAR_23 && VAR_1->op != VAR_24) ||\n          VAR_1->object.empty()) {\n        return -VAR_25;\n      }\n    }\n  }\n\n  /* COMMENT_5 */\n                                              \n  if (!VAR_2 && !VAR_1->object.empty()) {\n    if (!VAR_1->bucket_exists) {\n      return -VAR_20;\n    }\n    VAR_1->object_acl = new RGWAccessControlPolicy(VAR_1->cct);\n\n    rgw_obj VAR_5(VAR_1->bucket, VAR_1->object);\n    VAR_0->set_atomic(VAR_1->obj_ctx, VAR_5);\n    if (VAR_3) {\n      VAR_0->set_prefetch_data(VAR_1->obj_ctx, VAR_5);\n    }\n    VAR_4 = read_policy(VAR_0, VAR_1, VAR_1->bucket_info, VAR_1->bucket_attrs, VAR_1->object_acl, VAR_1->bucket, VAR_1->object);\n  }\n\n  return VAR_4;\n}",
  "func_graph_path_before": "ceph/99ba6610a8f437604cadf68cbe9969def893e870/rgw_op.cc/vul/before/0.json",
  "func": "static int rgw_build_policies(RGWRados *store, struct req_state *s, bool only_bucket, bool prefetch_data)\n{\n  int ret = 0;\n  rgw_obj_key obj;\n  RGWUserInfo bucket_owner_info;\n  RGWObjectCtx& obj_ctx = *static_cast<RGWObjectCtx *>(s->obj_ctx);\n\n  string bi = s->info.args.get(RGW_SYS_PARAM_PREFIX \"bucket-instance\");\n  if (!bi.empty()) {\n    int shard_id;\n    ret = rgw_bucket_parse_bucket_instance(bi, &s->bucket_instance_id, &shard_id);\n    if (ret < 0) {\n      return ret;\n    }\n  }\n\n  if(s->dialect.compare(\"s3\") == 0) {\n    s->bucket_acl = new RGWAccessControlPolicy_S3(s->cct);\n  } else if(s->dialect.compare(\"swift\")  == 0) {\n    s->bucket_acl = new RGWAccessControlPolicy_SWIFT(s->cct);\n  } else {\n    s->bucket_acl = new RGWAccessControlPolicy(s->cct);\n  }\n\n  if (s->copy_source) { /* check if copy source is within the current domain */\n    const char *src = s->copy_source;\n    if (*src == '/')\n      ++src;\n    string copy_source_str(src);\n\n    int pos = copy_source_str.find('/');\n    if (pos > 0)\n      copy_source_str = copy_source_str.substr(0, pos);\n\n    RGWBucketInfo source_info;\n\n    ret = store->get_bucket_info(obj_ctx, copy_source_str, source_info, NULL);\n    if (ret == 0) {\n      string& region = source_info.region;\n      s->local_source = store->region.equals(region);\n    }\n  }\n\n  if (!s->bucket_name_str.empty()) {\n    s->bucket_exists = true;\n    if (s->bucket_instance_id.empty()) {\n      ret = store->get_bucket_info(obj_ctx, s->bucket_name_str, s->bucket_info, NULL, &s->bucket_attrs);\n    } else {\n      ret = store->get_bucket_instance_info(obj_ctx, s->bucket_instance_id, s->bucket_info, NULL, &s->bucket_attrs);\n    }\n    if (ret < 0) {\n      if (ret != -ENOENT) {\n        ldout(s->cct, 0) << \"NOTICE: couldn't get bucket from bucket_name (name=\" << s->bucket_name_str << \")\" << dendl;\n        return ret;\n      }\n      s->bucket_exists = false;\n    }\n    s->bucket = s->bucket_info.bucket;\n\n    if (s->bucket_exists) {\n      rgw_obj_key no_obj;\n      ret = read_policy(store, s, s->bucket_info, s->bucket_attrs, s->bucket_acl, s->bucket, no_obj);\n    } else {\n      s->bucket_acl->create_default(s->user.user_id, s->user.display_name);\n      ret = -ERR_NO_SUCH_BUCKET;\n    }\n\n    s->bucket_owner = s->bucket_acl->get_owner();\n\n    string& region = s->bucket_info.region;\n    map<string, RGWRegion>::iterator dest_region = store->region_map.regions.find(region);\n    if (dest_region != store->region_map.regions.end() && !dest_region->second.endpoints.empty()) {\n      s->region_endpoint = dest_region->second.endpoints.front();\n    }\n    if (s->bucket_exists && !store->region.equals(region)) {\n      ldout(s->cct, 0) << \"NOTICE: request for data in a different region (\" << region << \" != \" << store->region.name << \")\" << dendl;\n      /* we now need to make sure that the operation actually requires copy source, that is\n       * it's a copy operation\n       */\n      if (store->region.is_master && s->op == OP_DELETE && s->system_request) {\n        /*If the operation is delete and if this is the master, don't redirect*/\n      } else if (!s->local_source ||\n          (s->op != OP_PUT && s->op != OP_COPY) ||\n          s->object.empty()) {\n        return -ERR_PERMANENT_REDIRECT;\n      }\n    }\n  }\n\n  /* we're passed only_bucket = true when we specifically need the bucket's\n     acls, that happens on write operations */\n  if (!only_bucket && !s->object.empty()) {\n    if (!s->bucket_exists) {\n      return -ERR_NO_SUCH_BUCKET;\n    }\n    s->object_acl = new RGWAccessControlPolicy(s->cct);\n\n    rgw_obj obj(s->bucket, s->object);\n    store->set_atomic(s->obj_ctx, obj);\n    if (prefetch_data) {\n      store->set_prefetch_data(s->obj_ctx, obj);\n    }\n    ret = read_policy(store, s, s->bucket_info, s->bucket_attrs, s->object_acl, s->bucket, s->object);\n  }\n\n  return ret;\n}",
  "abstract_func": "static int rgw_build_policies(RGWRados *VAR_0, struct req_state *VAR_1, bool VAR_2, bool VAR_3)\n{\n  int VAR_4 = 0;\n  rgw_obj_key VAR_5;\n  RGWUserInfo VAR_6;\n  RGWObjectCtx& VAR_7 = *VAR_8<RGWObjectCtx *>(VAR_1->obj_ctx);\n\n  string VAR_9 = VAR_1->info.args.get(VAR_10 \"bucket-instance\");\n  if (!VAR_9.empty()) {\n    int VAR_11;\n    VAR_4 = rgw_bucket_parse_bucket_instance(VAR_9, &VAR_1->bucket_instance_id, &VAR_11);\n    if (VAR_4 < 0) {\n      return VAR_4;\n    }\n  }\n\n  if(VAR_1->dialect.compare(\"s3\") == 0) {\n    VAR_1->bucket_acl = new RGWAccessControlPolicy_S3(VAR_1->cct);\n  } else if(VAR_1->dialect.compare(\"swift\")  == 0) {\n    VAR_1->bucket_acl = new RGWAccessControlPolicy_SWIFT(VAR_1->cct);\n  } else {\n    VAR_1->bucket_acl = new RGWAccessControlPolicy(VAR_1->cct);\n  }\n\n  if (VAR_1->copy_source) { /* COMMENT_0 */\n    const char *VAR_12 = VAR_1->copy_source;\n    if (*VAR_12 == '/')\n      ++VAR_12;\n    string copy_source_str(src);\n\n    int VAR_13 = VAR_14.find('/');\n    if (VAR_13 > 0)\n      VAR_14 = VAR_14.substr(0, VAR_13);\n\n    RGWBucketInfo VAR_15;\n\n    VAR_4 = VAR_0->get_bucket_info(VAR_7, VAR_14, VAR_15, NULL);\n    if (VAR_4 == 0) {\n      string& VAR_16 = VAR_15.region;\n      VAR_1->local_source = VAR_0->region.equals(VAR_16);\n    }\n  }\n\n  if (!VAR_1->bucket_name_str.empty()) {\n    VAR_1->bucket_exists = true;\n    if (VAR_1->bucket_instance_id.empty()) {\n      VAR_4 = VAR_0->get_bucket_info(VAR_7, VAR_1->bucket_name_str, VAR_1->bucket_info, NULL, &VAR_1->bucket_attrs);\n    } else {\n      VAR_4 = VAR_0->get_bucket_instance_info(VAR_7, VAR_1->bucket_instance_id, VAR_1->bucket_info, NULL, &VAR_1->bucket_attrs);\n    }\n    if (VAR_4 < 0) {\n      if (VAR_4 != -VAR_17) {\n        ldout(VAR_1->cct, 0) << \"NOTICE: couldn't get bucket from bucket_name (name=\" << VAR_1->bucket_name_str << \")\" << VAR_18;\n        return VAR_4;\n      }\n      VAR_1->bucket_exists = false;\n    }\n    VAR_1->bucket = VAR_1->bucket_info.bucket;\n\n    if (VAR_1->bucket_exists) {\n      rgw_obj_key VAR_19;\n      VAR_4 = read_policy(VAR_0, VAR_1, VAR_1->bucket_info, VAR_1->bucket_attrs, VAR_1->bucket_acl, VAR_1->bucket, VAR_19);\n    } else {\n      VAR_1->bucket_acl->create_default(VAR_1->user.user_id, VAR_1->user.display_name);\n      VAR_4 = -VAR_20;\n    }\n\n    VAR_1->bucket_owner = VAR_1->bucket_acl->get_owner();\n\n    string& VAR_16 = VAR_1->bucket_info.region;\n    map<string, RGWRegion>::iterator VAR_21 = VAR_0->region_map.regions.find(VAR_16);\n    if (VAR_21 != VAR_0->region_map.regions.end() && !VAR_21->second.endpoints.empty()) {\n      VAR_1->region_endpoint = VAR_21->second.endpoints.front();\n    }\n    if (VAR_1->bucket_exists && !VAR_0->region.equals(VAR_16)) {\n      ldout(VAR_1->cct, 0) << \"NOTICE: request for data in a different region (\" << VAR_16 << \" != \" << VAR_0->region.name << \")\" << VAR_18;\n      /* COMMENT_1 */\n                              \n         \n      if (VAR_0->region.is_master && VAR_1->op == VAR_22 && VAR_1->system_request) {\n        /* COMMENT_4 */\n      } else if (!VAR_1->local_source ||\n          (VAR_1->op != VAR_23 && VAR_1->op != VAR_24) ||\n          VAR_1->object.empty()) {\n        return -VAR_25;\n      }\n    }\n  }\n\n  /* COMMENT_5 */\n                                              \n  if (!VAR_2 && !VAR_1->object.empty()) {\n    if (!VAR_1->bucket_exists) {\n      return -VAR_20;\n    }\n    VAR_1->object_acl = new RGWAccessControlPolicy(VAR_1->cct);\n\n    rgw_obj VAR_5(VAR_1->bucket, VAR_1->object);\n    VAR_0->set_atomic(VAR_1->obj_ctx, VAR_5);\n    if (VAR_3) {\n      VAR_0->set_prefetch_data(VAR_1->obj_ctx, VAR_5);\n    }\n    VAR_4 = read_policy(VAR_0, VAR_1, VAR_1->bucket_info, VAR_1->bucket_attrs, VAR_1->object_acl, VAR_1->bucket, VAR_1->object);\n  }\n\n  return VAR_4;\n}",
  "func_graph_path": "ceph/99ba6610a8f437604cadf68cbe9969def893e870/rgw_op.cc/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -14,7 +14,13 @@\n     }\n   }\n \n-  s->bucket_acl = new RGWAccessControlPolicy(s->cct);\n+  if(s->dialect.compare(\"s3\") == 0) {\n+    s->bucket_acl = new RGWAccessControlPolicy_S3(s->cct);\n+  } else if(s->dialect.compare(\"swift\")  == 0) {\n+    s->bucket_acl = new RGWAccessControlPolicy_SWIFT(s->cct);\n+  } else {\n+    s->bucket_acl = new RGWAccessControlPolicy(s->cct);\n+  }\n \n   if (s->copy_source) { /* check if copy source is within the current domain */\n     const char *src = s->copy_source;",
  "diff_line_info": {
    "deleted_lines": [
      "  s->bucket_acl = new RGWAccessControlPolicy(s->cct);"
    ],
    "added_lines": [
      "  if(s->dialect.compare(\"s3\") == 0) {",
      "    s->bucket_acl = new RGWAccessControlPolicy_S3(s->cct);",
      "  } else if(s->dialect.compare(\"swift\")  == 0) {",
      "    s->bucket_acl = new RGWAccessControlPolicy_SWIFT(s->cct);",
      "  } else {",
      "    s->bucket_acl = new RGWAccessControlPolicy(s->cct);",
      "  }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/ceph/ceph/pull/6057",
  "description": {
    "pr_info": {
      "title": "Bug #13207:  Rados Gateway: Anonymous user is able to read bucket with authenticated read ACL",
      "number": 6057
    },
    "comment": [
      "Fix for http://tracker.ceph.com/issues/13207\n\nThe public user id in rados gateway is \"anonymous\" defined by RGW_USER_ANON_ID\nDuring a public read of a bucket (for example by generating a public url and accessing it), the method to know whether the user is public or not, the id is being compared with the public user group's uri and not with RGW_USER_ANON_ID. This led to the public user being considered as an authenticated user and hence read of a bucket is working even when the canned acl for the bucket is set to \"authenticated-read\".\nAlso, the bucket_acl  object is always being created of the base type RGWAccessControlPolicy while it should be created based on the dialect of the the request (s3 or swift)\n",
      "@yehudasa \nWhen \"authenticated-read\" ACL is applied on a bucket; anonymous user is also able to read (eg. list) the bucket. But as per S3 documentation only authenticated users should be allowed to access the bucket.\nThis commit tries to fix this problem. A testcase is listed in the bug at http://tracker.ceph.com/issues/13207 \nPlease let me know if this sounds like a genuine issue\n",
      "@rahul1aggarwal I understand. My question was about the specific lines change in rgw_op.cc.\n",
      "SUCCESS: http://jenkins.ceph.dachary.org/job/ceph/7986/\n- SUCCESS http://jenkins.ceph.dachary.org/job/ceph/LABELS=centos-7&&x86_64/7986/\n",
      "SUCCESS: http://jenkins.ceph.dachary.org/job/ceph/7987/\n- SUCCESS http://jenkins.ceph.dachary.org/job/ceph/LABELS=centos-7&&x86_64/7987/\n",
      "@rahul1aggarwal ,\ncan you please remove the merge commit and sign the commits.\n",
      "SUCCESS: http://jenkins.ceph.dachary.org/job/ceph/9426/\n- SUCCESS http://jenkins.ceph.dachary.org/job/ceph/LABELS=centos-7&&x86_64/9426/\n",
      "@oritwas ,\nremoved the merge commit and signed the commit. thanks\n",
      "SUCCESS: http://jenkins.ceph.dachary.org/job/ceph/9427/\n- SUCCESS http://jenkins.ceph.dachary.org/job/ceph/LABELS=centos-7&&x86_64/9427/\n",
      "SUCCESS: http://jenkins.ceph.dachary.org/job/ceph/9428/\n- SUCCESS http://jenkins.ceph.dachary.org/job/ceph/LABELS=centos-7&&x86_64/9428/\n",
      "@oritwas\nthanks for merging\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "Final Classification: Security Vulnerability Fix; Confidence: 1.0"
}