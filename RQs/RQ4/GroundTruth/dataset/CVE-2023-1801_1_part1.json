{
  "cve_id": "CVE-2023-1801",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "the-tcpdump-group/tcpdump",
  "commit_msg": "Have a common routine for converting dates and times to strings.\n\nHave a routine that takes a buffer, a strftime format, and a struct tm *\nas arguments, and:\n\n* checks whether the struct tm * is null and, if so, returns a string\nindicating that the date and time couldn't be converted;\n\n* otherwise, passes it to strftime(), along with the buffer and the\nformat argument and, if strftime() returns 0, meaning the string didn't\nfit into the buffer and thus that the buffer's contents are undefined,\nreturns a string indicating that the date and time didn't fit into the\nbuffer;\n\n* otherwise, returns a pointer to the buffer.\n\nCall that routine instead of directly calling strftime() in printers;\nthat prevents printing a buffer with undefined data if the buffer isn't\nbig enough for the string.\n\nAlso, when generating file names using an strftime format, check the\nreturn value of strftime() to make sure the buffer didn't overflow.",
  "commit_hash": "7578e1c04ee280dda50c4c2813e7d55f539c6501",
  "git_url": "https://github.com/the-tcpdump-group/tcpdump/commit/7578e1c04ee280dda50c4c2813e7d55f539c6501",
  "file_path": "tcpdump.c",
  "func_name": "MakeFilename",
  "func_before": "static void\nMakeFilename(char *buffer, char *orig_name, int cnt, int max_chars)\n{\n        char *filename = malloc(PATH_MAX + 1);\n        if (filename == NULL)\n            error(\"%s: malloc\", __func__);\n\n        /* Process with strftime if Gflag is set. */\n        if (Gflag != 0) {\n          struct tm *local_tm;\n\n          /* Convert Gflag_time to a usable format */\n          if ((local_tm = localtime(&Gflag_time)) == NULL) {\n                  error(\"%s: localtime\", __func__);\n          }\n\n          /* There's no good way to detect an error in strftime since a return\n           * value of 0 isn't necessarily failure.\n           */\n          strftime(filename, PATH_MAX, orig_name, local_tm);\n        } else {\n          strncpy(filename, orig_name, PATH_MAX);\n        }\n\n\tif (cnt == 0 && max_chars == 0)\n\t\tstrncpy(buffer, filename, PATH_MAX + 1);\n\telse\n\t\tif (snprintf(buffer, PATH_MAX + 1, \"%s%0*d\", filename, max_chars, cnt) > PATH_MAX)\n                  /* Report an error if the filename is too large */\n                  error(\"too many output files or filename is too long (> %d)\", PATH_MAX);\n        free(filename);\n}",
  "abstract_func_before": "static void\nMakeFilename(char *VAR_0, char *VAR_1, int VAR_2, int VAR_3)\n{\n        char *VAR_4 = malloc(VAR_5 + 1);\n        if (VAR_4 == NULL)\n            error(\"%s: malloc\", VAR_6);\n\n        /* COMMENT_0 */\n        if (VAR_7 != 0) {\n          struct tm *VAR_8;\n\n          /* COMMENT_1 */\n          if ((VAR_8 = localtime(&VAR_9)) == NULL) {\n                  error(\"%s: localtime\", VAR_6);\n          }\n\n          /* COMMENT_2 */\n                                                  \n             \n          strftime(VAR_4, VAR_5, VAR_1, VAR_8);\n        } else {\n          strncpy(VAR_4, VAR_1, VAR_5);\n        }\n\n\tif (VAR_2 == 0 && VAR_3 == 0)\n\t\tstrncpy(VAR_0, VAR_4, VAR_5 + 1);\n\telse\n\t\tif (snprintf(VAR_0, VAR_5 + 1, \"%s%0*d\", VAR_4, VAR_3, VAR_2) > VAR_5)\n                  /* COMMENT_5 */\n                  error(\"too many output files or filename is too long (> %d)\", VAR_5);\n        free(VAR_4);\n}",
  "func_graph_path_before": "the-tcpdump-group/tcpdump/7578e1c04ee280dda50c4c2813e7d55f539c6501/tcpdump.c/vul/before/0.json",
  "func": "static void\nMakeFilename(char *buffer, char *orig_name, int cnt, int max_chars)\n{\n        char *filename = malloc(PATH_MAX + 1);\n        if (filename == NULL)\n            error(\"%s: malloc\", __func__);\n        if (strlen(orig_name) == 0)\n            error(\"an empty string is not a valid file name\");\n\n        /* Process with strftime if Gflag is set. */\n        if (Gflag != 0) {\n          struct tm *local_tm;\n\n          /* Convert Gflag_time to a usable format */\n          if ((local_tm = localtime(&Gflag_time)) == NULL) {\n                  error(\"%s: localtime\", __func__);\n          }\n\n          /* There's no good way to detect an error in strftime since a return\n           * value of 0 isn't necessarily failure; if orig_name is an empty\n           * string, the formatted string will be empty.\n           *\n           * However, the C90 standard says that, if there *is* a\n           * buffer overflow, the content of the buffer is undefined,\n           * so we must check for a buffer overflow.\n           *\n           * So we check above for an empty orig_name, and only call\n           * strftime() if it's non-empty, in which case the return\n           * value will only be 0 if the formatted date doesn't fit\n           * in the buffer.\n           *\n           * (We check above because, even if we don't use -G, we\n           * want a better error message than \"tcpdump: : No such\n           * file or directory\" for this case.)\n           */\n          if (strftime(filename, PATH_MAX, orig_name, local_tm) == 0) {\n            error(\"%s: strftime\", __func__);\n          }\n        } else {\n          strncpy(filename, orig_name, PATH_MAX);\n        }\n\n\tif (cnt == 0 && max_chars == 0)\n\t\tstrncpy(buffer, filename, PATH_MAX + 1);\n\telse\n\t\tif (snprintf(buffer, PATH_MAX + 1, \"%s%0*d\", filename, max_chars, cnt) > PATH_MAX)\n                  /* Report an error if the filename is too large */\n                  error(\"too many output files or filename is too long (> %d)\", PATH_MAX);\n        free(filename);\n}",
  "abstract_func": "static void\nMakeFilename(char *VAR_0, char *VAR_1, int VAR_2, int VAR_3)\n{\n        char *VAR_4 = malloc(VAR_5 + 1);\n        if (VAR_4 == NULL)\n            error(\"%s: malloc\", VAR_6);\n        if (strlen(VAR_1) == 0)\n            error(\"an empty string is not a valid file name\");\n\n        /* COMMENT_0 */\n        if (VAR_7 != 0) {\n          struct tm *VAR_8;\n\n          /* COMMENT_1 */\n          if ((VAR_8 = localtime(&VAR_9)) == NULL) {\n                  error(\"%s: localtime\", VAR_6);\n          }\n\n          /* COMMENT_2 */\n                                                                           \n                                                        \n            \n                                                                 \n                                                                     \n                                                    \n            \n                                                                    \n                                                                   \n                                                                   \n                           \n            \n                                                                 \n                                                                 \n                                               \n             \n          if (strftime(VAR_4, VAR_5, VAR_1, VAR_8) == 0) {\n            error(\"%s: strftime\", VAR_6);\n          }\n        } else {\n          strncpy(VAR_4, VAR_1, VAR_5);\n        }\n\n\tif (VAR_2 == 0 && VAR_3 == 0)\n\t\tstrncpy(VAR_0, VAR_4, VAR_5 + 1);\n\telse\n\t\tif (snprintf(VAR_0, VAR_5 + 1, \"%s%0*d\", VAR_4, VAR_3, VAR_2) > VAR_5)\n                  /* COMMENT_17 */\n                  error(\"too many output files or filename is too long (> %d)\", VAR_5);\n        free(VAR_4);\n}",
  "func_graph_path": "the-tcpdump-group/tcpdump/7578e1c04ee280dda50c4c2813e7d55f539c6501/tcpdump.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,8 @@\n         char *filename = malloc(PATH_MAX + 1);\n         if (filename == NULL)\n             error(\"%s: malloc\", __func__);\n+        if (strlen(orig_name) == 0)\n+            error(\"an empty string is not a valid file name\");\n \n         /* Process with strftime if Gflag is set. */\n         if (Gflag != 0) {\n@@ -15,9 +17,25 @@\n           }\n \n           /* There's no good way to detect an error in strftime since a return\n-           * value of 0 isn't necessarily failure.\n+           * value of 0 isn't necessarily failure; if orig_name is an empty\n+           * string, the formatted string will be empty.\n+           *\n+           * However, the C90 standard says that, if there *is* a\n+           * buffer overflow, the content of the buffer is undefined,\n+           * so we must check for a buffer overflow.\n+           *\n+           * So we check above for an empty orig_name, and only call\n+           * strftime() if it's non-empty, in which case the return\n+           * value will only be 0 if the formatted date doesn't fit\n+           * in the buffer.\n+           *\n+           * (We check above because, even if we don't use -G, we\n+           * want a better error message than \"tcpdump: : No such\n+           * file or directory\" for this case.)\n            */\n-          strftime(filename, PATH_MAX, orig_name, local_tm);\n+          if (strftime(filename, PATH_MAX, orig_name, local_tm) == 0) {\n+            error(\"%s: strftime\", __func__);\n+          }\n         } else {\n           strncpy(filename, orig_name, PATH_MAX);\n         }",
  "diff_line_info": {
    "deleted_lines": [
      "           * value of 0 isn't necessarily failure.",
      "          strftime(filename, PATH_MAX, orig_name, local_tm);"
    ],
    "added_lines": [
      "        if (strlen(orig_name) == 0)",
      "            error(\"an empty string is not a valid file name\");",
      "           * value of 0 isn't necessarily failure; if orig_name is an empty",
      "           * string, the formatted string will be empty.",
      "           *",
      "           * However, the C90 standard says that, if there *is* a",
      "           * buffer overflow, the content of the buffer is undefined,",
      "           * so we must check for a buffer overflow.",
      "           *",
      "           * So we check above for an empty orig_name, and only call",
      "           * strftime() if it's non-empty, in which case the return",
      "           * value will only be 0 if the formatted date doesn't fit",
      "           * in the buffer.",
      "           *",
      "           * (We check above because, even if we don't use -G, we",
      "           * want a better error message than \"tcpdump: : No such",
      "           * file or directory\" for this case.)",
      "          if (strftime(filename, PATH_MAX, orig_name, local_tm) == 0) {",
      "            error(\"%s: strftime\", __func__);",
      "          }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/the-tcpdump-group/tcpdump/pull/1032",
  "description": {
    "pr_info": {
      "title": "Have a common routine for converting dates and times to strings.",
      "number": 1032
    },
    "comment": [
      "Have a routine that takes a buffer, a strftime format, and a struct tm * as arguments, and:\r\n\r\n* checks whether the struct tm * is null and, if so, returns a string indicating that the date and time couldn't be converted;\r\n\r\n* otherwise, passes it to strftime(), along with the buffer and the format argument and, if strftime() returns 0, meaning the string didn't fit into the buffer and thus that the buffer's contents are undefined, returns a string indicating that the date and time didn't fit into the buffer;\r\n\r\n* otherwise, returns a pointer to the buffer.\r\n\r\nCall this routine instead of directly calling strftime() in printers; that prevents printing a buffer with undefined data if the buffer isn't big enough for the string.\r\n\r\nAlso, when generating file names using an strftime format, check the return value of strftime() to make sure the buffer didn't overflow.",
      "(The failure on netbsd-mips64 was due to a compiler segfault, rebuilding now.)",
      "Also the commit message has two typos (\"::\" and \"inticating\").",
      "> Also the commit message has two typos (\"::\" and \"inticating\").\r\n\r\nFixed.",
      "Getting a pull request merged in this project can be remarkably difficult.",
      "> Getting a pull request merged in this project can be remarkably difficult.\r\n\r\n\"Difficult\" as in \"a lot of people point out problems with the code\", or \"difficult\" as in \"the mechanisms provided by Git and GitHub make it overly complicated\"? The former is arguably a feature; the latter is helped, on my side, with some scripts wherein, after I've set up my forked repository, I can do:\r\n\r\n- `git reviewbranch <branch name>` to create a branch for the changes;\r\n- `git doreview` after committing those changes or committing updates with `git commit --amend`;\r\n- `git reviewdone` when the change has been committed to the main repository.\r\n\r\nThey were originally developed when Wireshark moved to GitLab, but it turned out the basic commands they do work the same with GitHub.",
      "That was my attempt of a philosophical remark about software criticism. These changes certainly deserve another review round after a good sleep.",
      "Message on  CI netbsd-mips64 host:\r\n```\r\n/home/buildbot-worker/netbsd-mips64/tmpfs/tcpdump-netbsd-mips64/build/print-radius.c: In function ‘print_attr_string’:\r\n/home/buildbot-worker/netbsd-mips64/tmpfs/tcpdump-netbsd-mips64/build/print-radius.c:831:7: internal compiler error: Segmentation fault\r\n  831 |       nd_print_trunc(ndo);\r\n      |       ^~~~~~~~~~~~~~\r\nno stack trace because unwind library not available\r\nPlease submit a full bug report,\r\nwith preprocessed source if appropriate.\r\nSee <http://www.NetBSD.org/support/send-pr.html> for instructions.\r\n*** [CMakeFiles/netdissect.dir/print-radius.c.o] Error code 1\r\n```",
      "(Rebased on master.)",
      "GCC segfaults on that host from time to time, I have restarted that build. I do not have a better solution for this problem now.",
      "\"no stack trace because unwind library not available\"\r\nPerhaps the installation of this library could give some indication.",
      "If there is anything else that prevents these changes from going into the master branch, I cannot see it.",
      "(Rebased on master.)",
      "Fix patch line 211: space before tab in indent.",
      "It seems good.",
      "Thanks to everyone.",
      "Thank you!",
      "This should probably be backported to 4.99.",
      "> This should probably be backported to 4.99.\r\n\r\nAgreed."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95"
}