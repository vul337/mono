{
  "cve_id": "CVE-2021-37491",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
  "cvss_is_v3": true,
  "repo_name": "bitcoin",
  "commit_msg": "shuffle selected coins before transaction finalization",
  "commit_hash": "2fb9c1e6681370478e24a19172ed6d78d95d50d3",
  "git_url": "https://github.com/bitcoin/bitcoin/commit/2fb9c1e6681370478e24a19172ed6d78d95d50d3",
  "file_path": "src/wallet/wallet.cpp",
  "func_name": "CWallet::CreateTransaction",
  "func_before": "bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CTransactionRef& tx, CReserveKey& reservekey, CAmount& nFeeRet,\n                                int& nChangePosInOut, std::string& strFailReason, const CCoinControl& coin_control, bool sign)\n{\n    CAmount nValue = 0;\n    int nChangePosRequest = nChangePosInOut;\n    unsigned int nSubtractFeeFromAmount = 0;\n    for (const auto& recipient : vecSend)\n    {\n        if (nValue < 0 || recipient.nAmount < 0)\n        {\n            strFailReason = _(\"Transaction amounts must not be negative\");\n            return false;\n        }\n        nValue += recipient.nAmount;\n\n        if (recipient.fSubtractFeeFromAmount)\n            nSubtractFeeFromAmount++;\n    }\n    if (vecSend.empty())\n    {\n        strFailReason = _(\"Transaction must have at least one recipient\");\n        return false;\n    }\n\n    CMutableTransaction txNew;\n\n    // Discourage fee sniping.\n    //\n    // For a large miner the value of the transactions in the best block and\n    // the mempool can exceed the cost of deliberately attempting to mine two\n    // blocks to orphan the current best block. By setting nLockTime such that\n    // only the next block can include the transaction, we discourage this\n    // practice as the height restricted and limited blocksize gives miners\n    // considering fee sniping fewer options for pulling off this attack.\n    //\n    // A simple way to think about this is from the wallet's point of view we\n    // always want the blockchain to move forward. By setting nLockTime this\n    // way we're basically making the statement that we only want this\n    // transaction to appear in the next block; we don't want to potentially\n    // encourage reorgs by allowing transactions to appear at lower heights\n    // than the next block in forks of the best chain.\n    //\n    // Of course, the subsidy is high enough, and transaction volume low\n    // enough, that fee sniping isn't a problem yet, but by implementing a fix\n    // now we ensure code won't be written that makes assumptions about\n    // nLockTime that preclude a fix later.\n    txNew.nLockTime = chainActive.Height();\n\n    // Secondly occasionally randomly pick a nLockTime even further back, so\n    // that transactions that are delayed after signing for whatever reason,\n    // e.g. high-latency mix networks and some CoinJoin implementations, have\n    // better privacy.\n    if (GetRandInt(10) == 0)\n        txNew.nLockTime = std::max(0, (int)txNew.nLockTime - GetRandInt(100));\n\n    assert(txNew.nLockTime <= (unsigned int)chainActive.Height());\n    assert(txNew.nLockTime < LOCKTIME_THRESHOLD);\n    FeeCalculation feeCalc;\n    CAmount nFeeNeeded;\n    int nBytes;\n    {\n        std::set<CInputCoin> setCoins;\n        LOCK2(cs_main, cs_wallet);\n        {\n            std::vector<COutput> vAvailableCoins;\n            AvailableCoins(vAvailableCoins, true, &coin_control);\n            CoinSelectionParams coin_selection_params; // Parameters for coin selection, init with dummy\n\n            // Create change script that will be used if we need change\n            // TODO: pass in scriptChange instead of reservekey so\n            // change transaction isn't always pay-to-bitcoin-address\n            CScript scriptChange;\n\n            // coin control: send change to custom address\n            if (!boost::get<CNoDestination>(&coin_control.destChange)) {\n                scriptChange = GetScriptForDestination(coin_control.destChange);\n            } else { // no coin control: send change to newly generated address\n                // Note: We use a new key here to keep it from being obvious which side is the change.\n                //  The drawback is that by not reusing a previous key, the change may be lost if a\n                //  backup is restored, if the backup doesn't have the new private key for the change.\n                //  If we reused the old key, it would be possible to add code to look for and\n                //  rediscover unknown transactions that were written with keys of ours to recover\n                //  post-backup change.\n\n                // Reserve a new key pair from key pool\n                CPubKey vchPubKey;\n                bool ret;\n                ret = reservekey.GetReservedKey(vchPubKey, true);\n                if (!ret)\n                {\n                    strFailReason = _(\"Keypool ran out, please call keypoolrefill first\");\n                    return false;\n                }\n\n                const OutputType change_type = TransactionChangeType(coin_control.m_change_type ? *coin_control.m_change_type : m_default_change_type, vecSend);\n\n                LearnRelatedScripts(vchPubKey, change_type);\n                scriptChange = GetScriptForDestination(GetDestinationForKey(vchPubKey, change_type));\n            }\n            CTxOut change_prototype_txout(0, scriptChange);\n            coin_selection_params.change_output_size = GetSerializeSize(change_prototype_txout, SER_DISK, 0);\n\n            CFeeRate discard_rate = GetDiscardRate(::feeEstimator);\n\n            // Get the fee rate to use effective values in coin selection\n            CFeeRate nFeeRateNeeded = GetMinimumFeeRate(coin_control, ::mempool, ::feeEstimator, &feeCalc);\n\n            nFeeRet = 0;\n            bool pick_new_inputs = true;\n            CAmount nValueIn = 0;\n\n            // BnB selector is the only selector used when this is true.\n            // That should only happen on the first pass through the loop.\n            coin_selection_params.use_bnb = nSubtractFeeFromAmount == 0; // If we are doing subtract fee from recipient, then don't use BnB\n            // Start with no fee and loop until there is enough fee\n            while (true)\n            {\n                nChangePosInOut = nChangePosRequest;\n                txNew.vin.clear();\n                txNew.vout.clear();\n                bool fFirst = true;\n\n                CAmount nValueToSelect = nValue;\n                if (nSubtractFeeFromAmount == 0)\n                    nValueToSelect += nFeeRet;\n\n                // vouts to the payees\n                coin_selection_params.tx_noinputs_size = 11; // Static vsize overhead + outputs vsize. 4 nVersion, 4 nLocktime, 1 input count, 1 output count, 1 witness overhead (dummy, flag, stack size)\n                for (const auto& recipient : vecSend)\n                {\n                    CTxOut txout(recipient.nAmount, recipient.scriptPubKey);\n\n                    if (recipient.fSubtractFeeFromAmount)\n                    {\n                        assert(nSubtractFeeFromAmount != 0);\n                        txout.nValue -= nFeeRet / nSubtractFeeFromAmount; // Subtract fee equally from each selected recipient\n\n                        if (fFirst) // first receiver pays the remainder not divisible by output count\n                        {\n                            fFirst = false;\n                            txout.nValue -= nFeeRet % nSubtractFeeFromAmount;\n                        }\n                    }\n                    // Include the fee cost for outputs. Note this is only used for BnB right now\n                    coin_selection_params.tx_noinputs_size += ::GetSerializeSize(txout, SER_NETWORK, PROTOCOL_VERSION);\n\n                    if (IsDust(txout, ::dustRelayFee))\n                    {\n                        if (recipient.fSubtractFeeFromAmount && nFeeRet > 0)\n                        {\n                            if (txout.nValue < 0)\n                                strFailReason = _(\"The transaction amount is too small to pay the fee\");\n                            else\n                                strFailReason = _(\"The transaction amount is too small to send after the fee has been deducted\");\n                        }\n                        else\n                            strFailReason = _(\"Transaction amount too small\");\n                        return false;\n                    }\n                    txNew.vout.push_back(txout);\n                }\n\n                // Choose coins to use\n                bool bnb_used;\n                if (pick_new_inputs) {\n                    nValueIn = 0;\n                    setCoins.clear();\n                    coin_selection_params.change_spend_size = CalculateMaximumSignedInputSize(change_prototype_txout, this);\n                    coin_selection_params.effective_fee = nFeeRateNeeded;\n                    if (!SelectCoins(vAvailableCoins, nValueToSelect, setCoins, nValueIn, coin_control, coin_selection_params, bnb_used))\n                    {\n                        // If BnB was used, it was the first pass. No longer the first pass and continue loop with knapsack.\n                        if (bnb_used) {\n                            coin_selection_params.use_bnb = false;\n                            continue;\n                        }\n                        else {\n                            strFailReason = _(\"Insufficient funds\");\n                            return false;\n                        }\n                    }\n                }\n\n                const CAmount nChange = nValueIn - nValueToSelect;\n                if (nChange > 0)\n                {\n                    // Fill a vout to ourself\n                    CTxOut newTxOut(nChange, scriptChange);\n\n                    // Never create dust outputs; if we would, just\n                    // add the dust to the fee.\n                    // The nChange when BnB is used is always going to go to fees.\n                    if (IsDust(newTxOut, discard_rate) || bnb_used)\n                    {\n                        nChangePosInOut = -1;\n                        nFeeRet += nChange;\n                    }\n                    else\n                    {\n                        if (nChangePosInOut == -1)\n                        {\n                            // Insert change txn at random position:\n                            nChangePosInOut = GetRandInt(txNew.vout.size()+1);\n                        }\n                        else if ((unsigned int)nChangePosInOut > txNew.vout.size())\n                        {\n                            strFailReason = _(\"Change index out of range\");\n                            return false;\n                        }\n\n                        std::vector<CTxOut>::iterator position = txNew.vout.begin()+nChangePosInOut;\n                        txNew.vout.insert(position, newTxOut);\n                    }\n                } else {\n                    nChangePosInOut = -1;\n                }\n\n                // Fill vin\n                //\n                // Note how the sequence number is set to non-maxint so that\n                // the nLockTime set above actually works.\n                //\n                // BIP125 defines opt-in RBF as any nSequence < maxint-1, so\n                // we use the highest possible value in that range (maxint-2)\n                // to avoid conflicting with other possible uses of nSequence,\n                // and in the spirit of \"smallest possible change from prior\n                // behavior.\"\n                const uint32_t nSequence = coin_control.signalRbf ? MAX_BIP125_RBF_SEQUENCE : (CTxIn::SEQUENCE_FINAL - 1);\n                for (const auto& coin : setCoins)\n                    txNew.vin.push_back(CTxIn(coin.outpoint,CScript(),\n                                              nSequence));\n\n                nBytes = CalculateMaximumSignedTxSize(txNew, this);\n                if (nBytes < 0) {\n                    strFailReason = _(\"Signing transaction failed\");\n                    return false;\n                }\n\n                nFeeNeeded = GetMinimumFee(nBytes, coin_control, ::mempool, ::feeEstimator, &feeCalc);\n                if (feeCalc.reason == FeeReason::FALLBACK && !g_wallet_allow_fallback_fee) {\n                    // eventually allow a fallback fee\n                    strFailReason = _(\"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n                    return false;\n                }\n\n                // If we made it here and we aren't even able to meet the relay fee on the next pass, give up\n                // because we must be at the maximum allowed fee.\n                if (nFeeNeeded < ::minRelayTxFee.GetFee(nBytes))\n                {\n                    strFailReason = _(\"Transaction too large for fee policy\");\n                    return false;\n                }\n\n                if (nFeeRet >= nFeeNeeded) {\n                    // Reduce fee to only the needed amount if possible. This\n                    // prevents potential overpayment in fees if the coins\n                    // selected to meet nFeeNeeded result in a transaction that\n                    // requires less fee than the prior iteration.\n\n                    // If we have no change and a big enough excess fee, then\n                    // try to construct transaction again only without picking\n                    // new inputs. We now know we only need the smaller fee\n                    // (because of reduced tx size) and so we should add a\n                    // change output. Only try this once.\n                    if (nChangePosInOut == -1 && nSubtractFeeFromAmount == 0 && pick_new_inputs) {\n                        unsigned int tx_size_with_change = nBytes + coin_selection_params.change_output_size + 2; // Add 2 as a buffer in case increasing # of outputs changes compact size\n                        CAmount fee_needed_with_change = GetMinimumFee(tx_size_with_change, coin_control, ::mempool, ::feeEstimator, nullptr);\n                        CAmount minimum_value_for_change = GetDustThreshold(change_prototype_txout, discard_rate);\n                        if (nFeeRet >= fee_needed_with_change + minimum_value_for_change) {\n                            pick_new_inputs = false;\n                            nFeeRet = fee_needed_with_change;\n                            continue;\n                        }\n                    }\n\n                    // If we have change output already, just increase it\n                    if (nFeeRet > nFeeNeeded && nChangePosInOut != -1 && nSubtractFeeFromAmount == 0) {\n                        CAmount extraFeePaid = nFeeRet - nFeeNeeded;\n                        std::vector<CTxOut>::iterator change_position = txNew.vout.begin()+nChangePosInOut;\n                        change_position->nValue += extraFeePaid;\n                        nFeeRet -= extraFeePaid;\n                    }\n                    break; // Done, enough fee included.\n                }\n                else if (!pick_new_inputs) {\n                    // This shouldn't happen, we should have had enough excess\n                    // fee to pay for the new output and still meet nFeeNeeded\n                    // Or we should have just subtracted fee from recipients and\n                    // nFeeNeeded should not have changed\n                    strFailReason = _(\"Transaction fee and change calculation failed\");\n                    return false;\n                }\n\n                // Try to reduce change to include necessary fee\n                if (nChangePosInOut != -1 && nSubtractFeeFromAmount == 0) {\n                    CAmount additionalFeeNeeded = nFeeNeeded - nFeeRet;\n                    std::vector<CTxOut>::iterator change_position = txNew.vout.begin()+nChangePosInOut;\n                    // Only reduce change if remaining amount is still a large enough output.\n                    if (change_position->nValue >= MIN_FINAL_CHANGE + additionalFeeNeeded) {\n                        change_position->nValue -= additionalFeeNeeded;\n                        nFeeRet += additionalFeeNeeded;\n                        break; // Done, able to increase fee from change\n                    }\n                }\n\n                // If subtracting fee from recipients, we now know what fee we\n                // need to subtract, we have no reason to reselect inputs\n                if (nSubtractFeeFromAmount > 0) {\n                    pick_new_inputs = false;\n                }\n\n                // Include more fee and try again.\n                nFeeRet = nFeeNeeded;\n                coin_selection_params.use_bnb = false;\n                continue;\n            }\n        }\n\n        if (nChangePosInOut == -1) reservekey.ReturnKey(); // Return any reserved key if we don't have change\n\n        if (sign)\n        {\n            CTransaction txNewConst(txNew);\n            int nIn = 0;\n            for (const auto& coin : setCoins)\n            {\n                const CScript& scriptPubKey = coin.txout.scriptPubKey;\n                SignatureData sigdata;\n\n                if (!ProduceSignature(TransactionSignatureCreator(this, &txNewConst, nIn, coin.txout.nValue, SIGHASH_ALL), scriptPubKey, sigdata))\n                {\n                    strFailReason = _(\"Signing transaction failed\");\n                    return false;\n                } else {\n                    UpdateTransaction(txNew, nIn, sigdata);\n                }\n\n                nIn++;\n            }\n        }\n\n        // Return the constructed transaction data.\n        tx = MakeTransactionRef(std::move(txNew));\n\n        // Limit size\n        if (GetTransactionWeight(*tx) >= MAX_STANDARD_TX_WEIGHT)\n        {\n            strFailReason = _(\"Transaction too large\");\n            return false;\n        }\n    }\n\n    if (gArgs.GetBoolArg(\"-walletrejectlongchains\", DEFAULT_WALLET_REJECT_LONG_CHAINS)) {\n        // Lastly, ensure this tx will pass the mempool's chain limits\n        LockPoints lp;\n        CTxMemPoolEntry entry(tx, 0, 0, 0, false, 0, lp);\n        CTxMemPool::setEntries setAncestors;\n        size_t nLimitAncestors = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n        size_t nLimitAncestorSize = gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000;\n        size_t nLimitDescendants = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n        size_t nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000;\n        std::string errString;\n        if (!mempool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize, nLimitDescendants, nLimitDescendantSize, errString)) {\n            strFailReason = _(\"Transaction has too long of a mempool chain\");\n            return false;\n        }\n    }\n\n    LogPrintf(\"Fee Calculation: Fee:%d Bytes:%u Needed:%d Tgt:%d (requested %d) Reason:\\\"%s\\\" Decay %.5f: Estimation: (%g - %g) %.2f%% %.1f/(%.1f %d mem %.1f out) Fail: (%g - %g) %.2f%% %.1f/(%.1f %d mem %.1f out)\\n\",\n              nFeeRet, nBytes, nFeeNeeded, feeCalc.returnedTarget, feeCalc.desiredTarget, StringForFeeReason(feeCalc.reason), feeCalc.est.decay,\n              feeCalc.est.pass.start, feeCalc.est.pass.end,\n              100 * feeCalc.est.pass.withinTarget / (feeCalc.est.pass.totalConfirmed + feeCalc.est.pass.inMempool + feeCalc.est.pass.leftMempool),\n              feeCalc.est.pass.withinTarget, feeCalc.est.pass.totalConfirmed, feeCalc.est.pass.inMempool, feeCalc.est.pass.leftMempool,\n              feeCalc.est.fail.start, feeCalc.est.fail.end,\n              100 * feeCalc.est.fail.withinTarget / (feeCalc.est.fail.totalConfirmed + feeCalc.est.fail.inMempool + feeCalc.est.fail.leftMempool),\n              feeCalc.est.fail.withinTarget, feeCalc.est.fail.totalConfirmed, feeCalc.est.fail.inMempool, feeCalc.est.fail.leftMempool);\n    return true;\n}",
  "abstract_func_before": "bool CWallet::CreateTransaction(const std::vector<CRecipient>& VAR_0, CTransactionRef& VAR_1, CReserveKey& VAR_2, CAmount& VAR_3,\n                                int& VAR_4, std::string& VAR_5, const CCoinControl& VAR_6, bool VAR_7)\n{\n    CAmount VAR_8 = 0;\n    int VAR_9 = VAR_4;\n    unsigned int VAR_10 = 0;\n    for (const auto& VAR_11 : VAR_0)\n    {\n        if (VAR_8 < 0 || VAR_11.nAmount < 0)\n        {\n            VAR_5 = _(\"Transaction amounts must not be negative\");\n            return false;\n        }\n        VAR_8 += VAR_11.nAmount;\n\n        if (VAR_11.fSubtractFeeFromAmount)\n            VAR_10++;\n    }\n    if (VAR_0.empty())\n    {\n        VAR_5 = _(\"Transaction must have at least one recipient\");\n        return false;\n    }\n\n    CMutableTransaction VAR_12;\n\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n    /* COMMENT_3 */\n    /* COMMENT_4 */\n    /* COMMENT_5 */\n    /* COMMENT_6 */\n    /* COMMENT_7 */\n    /* COMMENT_1 */\n    /* COMMENT_8 */\n    /* COMMENT_9 */\n    /* COMMENT_10 */\n    /* COMMENT_11 */\n    /* COMMENT_12 */\n    /* COMMENT_13 */\n    /* COMMENT_1 */\n    /* COMMENT_14 */\n    /* COMMENT_15 */\n    /* COMMENT_16 */\n    /* COMMENT_17 */\n    VAR_12.nLockTime = VAR_13.Height();\n\n    /* COMMENT_18 */\n    /* COMMENT_19 */\n    /* COMMENT_20 */\n    /* COMMENT_21 */\n    if (GetRandInt(10) == 0)\n        VAR_12.nLockTime = std::max(0, (int)VAR_12.nLockTime - GetRandInt(100));\n\n    assert(VAR_12.nLockTime <= (unsigned int)VAR_13.Height());\n    assert(VAR_12.nLockTime < VAR_14);\n    FeeCalculation VAR_15;\n    CAmount VAR_16;\n    int VAR_17;\n    {\n        std::set<CInputCoin> VAR_18;\n        LOCK2(VAR_19, VAR_20);\n        {\n            std::vector<COutput> VAR_21;\n            AvailableCoins(VAR_21, true, &VAR_6);\n            CoinSelectionParams VAR_22; /* COMMENT_22 */\n\n            /* COMMENT_23 */\n            /* COMMENT_24 */\n            /* COMMENT_25 */\n            CScript VAR_23;\n\n            /* COMMENT_26 */\n            if (!boost::VAR_24<CNoDestination>(&VAR_6.destChange)) {\n                VAR_23 = GetScriptForDestination(VAR_6.destChange);\n            } else { /* COMMENT_27 */\n                /* COMMENT_28 */\n                /* COMMENT_29 */\n                /* COMMENT_30 */\n                /* COMMENT_31 */\n                /* COMMENT_32 */\n                /* COMMENT_33 */\n\n                /* COMMENT_34 */\n                CPubKey VAR_25;\n                bool VAR_26;\n                VAR_26 = VAR_2.GetReservedKey(VAR_25, true);\n                if (!VAR_26)\n                {\n                    VAR_5 = _(\"Keypool ran out, please call keypoolrefill first\");\n                    return false;\n                }\n\n                const OutputType VAR_27 = TransactionChangeType(VAR_6.m_change_type ? *VAR_6.m_change_type : VAR_28, VAR_0);\n\n                LearnRelatedScripts(VAR_25, VAR_27);\n                VAR_23 = GetScriptForDestination(GetDestinationForKey(VAR_25, VAR_27));\n            }\n            CTxOut VAR_29(0, VAR_23);\n            VAR_22.change_output_size = GetSerializeSize(VAR_29, VAR_30, 0);\n\n            CFeeRate VAR_31 = GetDiscardRate(::feeEstimator);\n\n            /* COMMENT_35 */\n            CFeeRate VAR_32 = GetMinimumFeeRate(VAR_6, ::mempool, ::feeEstimator, &VAR_15);\n\n            VAR_3 = 0;\n            bool VAR_33 = true;\n            CAmount VAR_34 = 0;\n\n            /* COMMENT_36 */\n            /* COMMENT_37 */\n            VAR_22.use_bnb = VAR_10 == 0; /* COMMENT_38 */\n            /* COMMENT_39 */\n            while (true)\n            {\n                VAR_4 = VAR_9;\n                VAR_12.vin.clear();\n                VAR_12.vout.clear();\n                bool VAR_35 = true;\n\n                CAmount VAR_36 = VAR_8;\n                if (VAR_10 == 0)\n                    VAR_36 += VAR_3;\n\n                /* COMMENT_40 */\n                VAR_22.tx_noinputs_size = 11; /* COMMENT_41 */\n                for (const auto& VAR_11 : VAR_0)\n                {\n                    CTxOut VAR_37(VAR_11.nAmount, VAR_11.scriptPubKey);\n\n                    if (VAR_11.fSubtractFeeFromAmount)\n                    {\n                        assert(VAR_10 != 0);\n                        VAR_37.nValue -= VAR_3 / VAR_10; /* COMMENT_42 */\n\n                        if (VAR_35) /* COMMENT_43 */\n                        {\n                            VAR_35 = false;\n                            VAR_37.nValue -= VAR_3 % VAR_10;\n                        }\n                    }\n                    /* COMMENT_44 */\n                    VAR_22.tx_noinputs_size += ::GetSerializeSize(VAR_37, VAR_38, VAR_39);\n\n                    if (IsDust(VAR_37, ::dustRelayFee))\n                    {\n                        if (VAR_11.fSubtractFeeFromAmount && VAR_3 > 0)\n                        {\n                            if (VAR_37.nValue < 0)\n                                VAR_5 = _(\"The transaction amount is too small to pay the fee\");\n                            else\n                                VAR_5 = _(\"The transaction amount is too small to send after the fee has been deducted\");\n                        }\n                        else\n                            VAR_5 = _(\"Transaction amount too small\");\n                        return false;\n                    }\n                    VAR_12.vout.push_back(VAR_37);\n                }\n\n                /* COMMENT_45 */\n                bool VAR_40;\n                if (VAR_33) {\n                    VAR_34 = 0;\n                    VAR_18.clear();\n                    VAR_22.change_spend_size = CalculateMaximumSignedInputSize(VAR_29, this);\n                    VAR_22.effective_fee = VAR_32;\n                    if (!SelectCoins(VAR_21, VAR_36, VAR_18, VAR_34, VAR_6, VAR_22, VAR_40))\n                    {\n                        /* COMMENT_46 */\n                        if (VAR_40) {\n                            VAR_22.use_bnb = false;\n                            continue;\n                        }\n                        else {\n                            VAR_5 = _(\"Insufficient funds\");\n                            return false;\n                        }\n                    }\n                }\n\n                const CAmount VAR_41 = VAR_34 - VAR_36;\n                if (VAR_41 > 0)\n                {\n                    /* COMMENT_47 */\n                    CTxOut newTxOut(nChange, scriptChange);\n\n                    /* COMMENT_48 */\n                    /* COMMENT_49 */\n                    /* COMMENT_50 */\n                    if (IsDust(VAR_42, VAR_31) || VAR_40)\n                    {\n                        VAR_4 = -1;\n                        VAR_3 += nChange;\n                    }\n                    else\n                    {\n                        if (VAR_4 == -1)\n                        {\n                            /* COMMENT_51 */\n                            VAR_4 = GetRandInt(VAR_12.vout.size()+1);\n                        }\n                        else if ((unsigned int)VAR_4 > VAR_12.vout.size())\n                        {\n                            VAR_5 = _(\"Change index out of range\");\n                            return false;\n                        }\n\n                        std::vector<CTxOut>::iterator VAR_43 = VAR_12.vout.begin()+VAR_4;\n                        VAR_12.vout.insert(VAR_43, VAR_42);\n                    }\n                } else {\n                    VAR_4 = -1;\n                }\n\n                /* COMMENT_52 */\n                /* COMMENT_1 */\n                /* COMMENT_53 */\n                /* COMMENT_54 */\n                /* COMMENT_1 */\n                /* COMMENT_55 */\n                /* COMMENT_56 */\n                /* COMMENT_57 */\n                /* COMMENT_58 */\n                /* COMMENT_59 */\n                const uint32_t VAR_44 = VAR_6.signalRbf ? VAR_45 : (CTxIn::SEQUENCE_FINAL - 1);\n                for (const auto& VAR_46 : VAR_18)\n                    VAR_12.vin.push_back(CTxIn(VAR_46.outpoint,CScript(),\n                                              VAR_44));\n\n                VAR_17 = CalculateMaximumSignedTxSize(VAR_12, this);\n                if (VAR_17 < 0) {\n                    VAR_5 = _(\"Signing transaction failed\");\n                    return false;\n                }\n\n                VAR_16 = GetMinimumFee(VAR_17, VAR_6, ::mempool, ::feeEstimator, &VAR_15);\n                if (VAR_15.reason == FeeReason::FALLBACK && !VAR_47) {\n                    /* COMMENT_60 */\n                    VAR_5 = _(\"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n                    return false;\n                }\n\n                /* COMMENT_61 */\n                /* COMMENT_62 */\n                if (VAR_16 < ::minRelayTxFee.GetFee(VAR_17))\n                {\n                    VAR_5 = _(\"Transaction too large for fee policy\");\n                    return false;\n                }\n\n                if (VAR_3 >= VAR_16) {\n                    /* COMMENT_63 */\n                    /* COMMENT_64 */\n                    /* COMMENT_65 */\n                    /* COMMENT_66 */\n\n                    /* COMMENT_67 */\n                    /* COMMENT_68 */\n                    /* COMMENT_69 */\n                    /* COMMENT_70 */\n                    /* COMMENT_71 */\n                    if (VAR_4 == -1 && VAR_10 == 0 && VAR_33) {\n                        unsigned int VAR_48 = VAR_17 + VAR_22.change_output_size + 2; /* COMMENT_72 */\n                        CAmount VAR_49 = GetMinimumFee(VAR_48, VAR_6, ::mempool, ::feeEstimator, nullptr);\n                        CAmount VAR_50 = GetDustThreshold(VAR_29, VAR_31);\n                        if (VAR_3 >= VAR_49 + VAR_50) {\n                            VAR_33 = false;\n                            VAR_3 = VAR_49;\n                            continue;\n                        }\n                    }\n\n                    /* COMMENT_73 */\n                    if (VAR_3 > VAR_16 && VAR_4 != -1 && VAR_10 == 0) {\n                        CAmount VAR_51 = VAR_3 - VAR_16;\n                        std::vector<CTxOut>::iterator VAR_52 = VAR_12.vout.begin()+VAR_4;\n                        VAR_52->nValue += VAR_51;\n                        VAR_3 -= VAR_51;\n                    }\n                    break; /* COMMENT_74 */\n                }\n                else if (!VAR_33) {\n                    /* COMMENT_75 */\n                    /* COMMENT_76 */\n                    /* COMMENT_77 */\n                    /* COMMENT_78 */\n                    VAR_5 = _(\"Transaction fee and change calculation failed\");\n                    return false;\n                }\n\n                /* COMMENT_79 */\n                if (VAR_4 != -1 && VAR_10 == 0) {\n                    CAmount VAR_53 = VAR_16 - VAR_3;\n                    std::vector<CTxOut>::iterator VAR_52 = VAR_12.vout.begin()+VAR_4;\n                    /* COMMENT_80 */\n                    if (VAR_52->nValue >= VAR_54 + VAR_53) {\n                        VAR_52->nValue -= VAR_53;\n                        VAR_3 += VAR_53;\n                        break; /* COMMENT_81 */\n                    }\n                }\n\n                /* COMMENT_82 */\n                /* COMMENT_83 */\n                if (VAR_10 > 0) {\n                    VAR_33 = false;\n                }\n\n                /* COMMENT_84 */\n                VAR_3 = VAR_16;\n                VAR_22.use_bnb = false;\n                continue;\n            }\n        }\n\n        if (VAR_4 == -1) VAR_2.ReturnKey(); /* COMMENT_85 */\n\n        if (VAR_7)\n        {\n            CTransaction txNewConst(txNew);\n            int VAR_55 = 0;\n            for (const auto& VAR_46 : VAR_18)\n            {\n                const CScript& VAR_56 = VAR_46.txout.scriptPubKey;\n                SignatureData VAR_57;\n\n                if (!ProduceSignature(TransactionSignatureCreator(this, &VAR_58, VAR_55, VAR_46.txout.nValue, VAR_59), VAR_56, VAR_57))\n                {\n                    VAR_5 = _(\"Signing transaction failed\");\n                    return false;\n                } else {\n                    UpdateTransaction(txNew, VAR_55, VAR_57);\n                }\n\n                VAR_55++;\n            }\n        }\n\n        /* COMMENT_86 */\n        VAR_1 = MakeTransactionRef(std::move(txNew));\n\n        /* COMMENT_87 */\n        if (GetTransactionWeight(*VAR_1) >= VAR_60)\n        {\n            VAR_5 = _(\"Transaction too large\");\n            return false;\n        }\n    }\n\n    if (VAR_61.GetBoolArg(\"-walletrejectlongchains\", VAR_62)) {\n        /* COMMENT_88 */\n        LockPoints VAR_63;\n        CTxMemPoolEntry VAR_64(VAR_1, 0, 0, 0, false, 0, VAR_63);\n        CTxMemPool::setEntries VAR_65;\n        size_t VAR_66 = VAR_61.GetArg(\"-limitancestorcount\", VAR_67);\n        size_t VAR_68 = VAR_61.GetArg(\"-limitancestorsize\", VAR_69)*1000;\n        size_t VAR_70 = VAR_61.GetArg(\"-limitdescendantcount\", VAR_71);\n        size_t VAR_72 = VAR_61.GetArg(\"-limitdescendantsize\", VAR_73)*1000;\n        std::string VAR_74;\n        if (!VAR_75.CalculateMemPoolAncestors(VAR_64, VAR_65, VAR_66, VAR_68, VAR_70, VAR_72, VAR_74)) {\n            VAR_5 = _(\"Transaction has too long of a mempool chain\");\n            return false;\n        }\n    }\n\n    LogPrintf(\"Fee Calculation: Fee:%d Bytes:%u Needed:%d Tgt:%d (requested %d) Reason:\\\"%s\\\" Decay %.5f: Estimation: (%g - %g) %.2f%% %.1f/(%.1f %d mem %.1f out) Fail: (%g - %g) %.2f%% %.1f/(%.1f %d mem %.1f out)\\n\",\n              VAR_3, VAR_17, VAR_16, VAR_15.returnedTarget, VAR_15.desiredTarget, StringForFeeReason(VAR_15.reason), VAR_15.est.decay,\n              VAR_15.est.pass.start, VAR_15.est.pass.end,\n              100 * VAR_15.est.pass.withinTarget / (VAR_15.est.pass.totalConfirmed + VAR_15.est.pass.inMempool + VAR_15.est.pass.leftMempool),\n              VAR_15.est.pass.withinTarget, VAR_15.est.pass.totalConfirmed, VAR_15.est.pass.inMempool, VAR_15.est.pass.leftMempool,\n              VAR_15.est.fail.start, VAR_15.est.fail.end,\n              100 * VAR_15.est.fail.withinTarget / (VAR_15.est.fail.totalConfirmed + VAR_15.est.fail.inMempool + VAR_15.est.fail.leftMempool),\n              VAR_15.est.fail.withinTarget, VAR_15.est.fail.totalConfirmed, VAR_15.est.fail.inMempool, VAR_15.est.fail.leftMempool);\n    return true;\n}",
  "func_graph_path_before": "bitcoin/2fb9c1e6681370478e24a19172ed6d78d95d50d3/wallet.cpp/vul/before/0.json",
  "func": "bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CTransactionRef& tx, CReserveKey& reservekey, CAmount& nFeeRet,\n                                int& nChangePosInOut, std::string& strFailReason, const CCoinControl& coin_control, bool sign)\n{\n    CAmount nValue = 0;\n    int nChangePosRequest = nChangePosInOut;\n    unsigned int nSubtractFeeFromAmount = 0;\n    for (const auto& recipient : vecSend)\n    {\n        if (nValue < 0 || recipient.nAmount < 0)\n        {\n            strFailReason = _(\"Transaction amounts must not be negative\");\n            return false;\n        }\n        nValue += recipient.nAmount;\n\n        if (recipient.fSubtractFeeFromAmount)\n            nSubtractFeeFromAmount++;\n    }\n    if (vecSend.empty())\n    {\n        strFailReason = _(\"Transaction must have at least one recipient\");\n        return false;\n    }\n\n    CMutableTransaction txNew;\n\n    // Discourage fee sniping.\n    //\n    // For a large miner the value of the transactions in the best block and\n    // the mempool can exceed the cost of deliberately attempting to mine two\n    // blocks to orphan the current best block. By setting nLockTime such that\n    // only the next block can include the transaction, we discourage this\n    // practice as the height restricted and limited blocksize gives miners\n    // considering fee sniping fewer options for pulling off this attack.\n    //\n    // A simple way to think about this is from the wallet's point of view we\n    // always want the blockchain to move forward. By setting nLockTime this\n    // way we're basically making the statement that we only want this\n    // transaction to appear in the next block; we don't want to potentially\n    // encourage reorgs by allowing transactions to appear at lower heights\n    // than the next block in forks of the best chain.\n    //\n    // Of course, the subsidy is high enough, and transaction volume low\n    // enough, that fee sniping isn't a problem yet, but by implementing a fix\n    // now we ensure code won't be written that makes assumptions about\n    // nLockTime that preclude a fix later.\n    txNew.nLockTime = chainActive.Height();\n\n    // Secondly occasionally randomly pick a nLockTime even further back, so\n    // that transactions that are delayed after signing for whatever reason,\n    // e.g. high-latency mix networks and some CoinJoin implementations, have\n    // better privacy.\n    if (GetRandInt(10) == 0)\n        txNew.nLockTime = std::max(0, (int)txNew.nLockTime - GetRandInt(100));\n\n    assert(txNew.nLockTime <= (unsigned int)chainActive.Height());\n    assert(txNew.nLockTime < LOCKTIME_THRESHOLD);\n    FeeCalculation feeCalc;\n    CAmount nFeeNeeded;\n    int nBytes;\n    {\n        std::set<CInputCoin> setCoins;\n        LOCK2(cs_main, cs_wallet);\n        {\n            std::vector<COutput> vAvailableCoins;\n            AvailableCoins(vAvailableCoins, true, &coin_control);\n            CoinSelectionParams coin_selection_params; // Parameters for coin selection, init with dummy\n\n            // Create change script that will be used if we need change\n            // TODO: pass in scriptChange instead of reservekey so\n            // change transaction isn't always pay-to-bitcoin-address\n            CScript scriptChange;\n\n            // coin control: send change to custom address\n            if (!boost::get<CNoDestination>(&coin_control.destChange)) {\n                scriptChange = GetScriptForDestination(coin_control.destChange);\n            } else { // no coin control: send change to newly generated address\n                // Note: We use a new key here to keep it from being obvious which side is the change.\n                //  The drawback is that by not reusing a previous key, the change may be lost if a\n                //  backup is restored, if the backup doesn't have the new private key for the change.\n                //  If we reused the old key, it would be possible to add code to look for and\n                //  rediscover unknown transactions that were written with keys of ours to recover\n                //  post-backup change.\n\n                // Reserve a new key pair from key pool\n                CPubKey vchPubKey;\n                bool ret;\n                ret = reservekey.GetReservedKey(vchPubKey, true);\n                if (!ret)\n                {\n                    strFailReason = _(\"Keypool ran out, please call keypoolrefill first\");\n                    return false;\n                }\n\n                const OutputType change_type = TransactionChangeType(coin_control.m_change_type ? *coin_control.m_change_type : m_default_change_type, vecSend);\n\n                LearnRelatedScripts(vchPubKey, change_type);\n                scriptChange = GetScriptForDestination(GetDestinationForKey(vchPubKey, change_type));\n            }\n            CTxOut change_prototype_txout(0, scriptChange);\n            coin_selection_params.change_output_size = GetSerializeSize(change_prototype_txout, SER_DISK, 0);\n\n            CFeeRate discard_rate = GetDiscardRate(::feeEstimator);\n\n            // Get the fee rate to use effective values in coin selection\n            CFeeRate nFeeRateNeeded = GetMinimumFeeRate(coin_control, ::mempool, ::feeEstimator, &feeCalc);\n\n            nFeeRet = 0;\n            bool pick_new_inputs = true;\n            CAmount nValueIn = 0;\n\n            // BnB selector is the only selector used when this is true.\n            // That should only happen on the first pass through the loop.\n            coin_selection_params.use_bnb = nSubtractFeeFromAmount == 0; // If we are doing subtract fee from recipient, then don't use BnB\n            // Start with no fee and loop until there is enough fee\n            while (true)\n            {\n                nChangePosInOut = nChangePosRequest;\n                txNew.vin.clear();\n                txNew.vout.clear();\n                bool fFirst = true;\n\n                CAmount nValueToSelect = nValue;\n                if (nSubtractFeeFromAmount == 0)\n                    nValueToSelect += nFeeRet;\n\n                // vouts to the payees\n                coin_selection_params.tx_noinputs_size = 11; // Static vsize overhead + outputs vsize. 4 nVersion, 4 nLocktime, 1 input count, 1 output count, 1 witness overhead (dummy, flag, stack size)\n                for (const auto& recipient : vecSend)\n                {\n                    CTxOut txout(recipient.nAmount, recipient.scriptPubKey);\n\n                    if (recipient.fSubtractFeeFromAmount)\n                    {\n                        assert(nSubtractFeeFromAmount != 0);\n                        txout.nValue -= nFeeRet / nSubtractFeeFromAmount; // Subtract fee equally from each selected recipient\n\n                        if (fFirst) // first receiver pays the remainder not divisible by output count\n                        {\n                            fFirst = false;\n                            txout.nValue -= nFeeRet % nSubtractFeeFromAmount;\n                        }\n                    }\n                    // Include the fee cost for outputs. Note this is only used for BnB right now\n                    coin_selection_params.tx_noinputs_size += ::GetSerializeSize(txout, SER_NETWORK, PROTOCOL_VERSION);\n\n                    if (IsDust(txout, ::dustRelayFee))\n                    {\n                        if (recipient.fSubtractFeeFromAmount && nFeeRet > 0)\n                        {\n                            if (txout.nValue < 0)\n                                strFailReason = _(\"The transaction amount is too small to pay the fee\");\n                            else\n                                strFailReason = _(\"The transaction amount is too small to send after the fee has been deducted\");\n                        }\n                        else\n                            strFailReason = _(\"Transaction amount too small\");\n                        return false;\n                    }\n                    txNew.vout.push_back(txout);\n                }\n\n                // Choose coins to use\n                bool bnb_used;\n                if (pick_new_inputs) {\n                    nValueIn = 0;\n                    setCoins.clear();\n                    coin_selection_params.change_spend_size = CalculateMaximumSignedInputSize(change_prototype_txout, this);\n                    coin_selection_params.effective_fee = nFeeRateNeeded;\n                    if (!SelectCoins(vAvailableCoins, nValueToSelect, setCoins, nValueIn, coin_control, coin_selection_params, bnb_used))\n                    {\n                        // If BnB was used, it was the first pass. No longer the first pass and continue loop with knapsack.\n                        if (bnb_used) {\n                            coin_selection_params.use_bnb = false;\n                            continue;\n                        }\n                        else {\n                            strFailReason = _(\"Insufficient funds\");\n                            return false;\n                        }\n                    }\n                }\n\n                const CAmount nChange = nValueIn - nValueToSelect;\n                if (nChange > 0)\n                {\n                    // Fill a vout to ourself\n                    CTxOut newTxOut(nChange, scriptChange);\n\n                    // Never create dust outputs; if we would, just\n                    // add the dust to the fee.\n                    // The nChange when BnB is used is always going to go to fees.\n                    if (IsDust(newTxOut, discard_rate) || bnb_used)\n                    {\n                        nChangePosInOut = -1;\n                        nFeeRet += nChange;\n                    }\n                    else\n                    {\n                        if (nChangePosInOut == -1)\n                        {\n                            // Insert change txn at random position:\n                            nChangePosInOut = GetRandInt(txNew.vout.size()+1);\n                        }\n                        else if ((unsigned int)nChangePosInOut > txNew.vout.size())\n                        {\n                            strFailReason = _(\"Change index out of range\");\n                            return false;\n                        }\n\n                        std::vector<CTxOut>::iterator position = txNew.vout.begin()+nChangePosInOut;\n                        txNew.vout.insert(position, newTxOut);\n                    }\n                } else {\n                    nChangePosInOut = -1;\n                }\n\n                // Dummy fill vin for maximum size estimation\n                //\n                for (const auto& coin : setCoins) {\n                    txNew.vin.push_back(CTxIn(coin.outpoint,CScript()));\n                }\n\n                nBytes = CalculateMaximumSignedTxSize(txNew, this);\n                if (nBytes < 0) {\n                    strFailReason = _(\"Signing transaction failed\");\n                    return false;\n                }\n\n                nFeeNeeded = GetMinimumFee(nBytes, coin_control, ::mempool, ::feeEstimator, &feeCalc);\n                if (feeCalc.reason == FeeReason::FALLBACK && !g_wallet_allow_fallback_fee) {\n                    // eventually allow a fallback fee\n                    strFailReason = _(\"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n                    return false;\n                }\n\n                // If we made it here and we aren't even able to meet the relay fee on the next pass, give up\n                // because we must be at the maximum allowed fee.\n                if (nFeeNeeded < ::minRelayTxFee.GetFee(nBytes))\n                {\n                    strFailReason = _(\"Transaction too large for fee policy\");\n                    return false;\n                }\n\n                if (nFeeRet >= nFeeNeeded) {\n                    // Reduce fee to only the needed amount if possible. This\n                    // prevents potential overpayment in fees if the coins\n                    // selected to meet nFeeNeeded result in a transaction that\n                    // requires less fee than the prior iteration.\n\n                    // If we have no change and a big enough excess fee, then\n                    // try to construct transaction again only without picking\n                    // new inputs. We now know we only need the smaller fee\n                    // (because of reduced tx size) and so we should add a\n                    // change output. Only try this once.\n                    if (nChangePosInOut == -1 && nSubtractFeeFromAmount == 0 && pick_new_inputs) {\n                        unsigned int tx_size_with_change = nBytes + coin_selection_params.change_output_size + 2; // Add 2 as a buffer in case increasing # of outputs changes compact size\n                        CAmount fee_needed_with_change = GetMinimumFee(tx_size_with_change, coin_control, ::mempool, ::feeEstimator, nullptr);\n                        CAmount minimum_value_for_change = GetDustThreshold(change_prototype_txout, discard_rate);\n                        if (nFeeRet >= fee_needed_with_change + minimum_value_for_change) {\n                            pick_new_inputs = false;\n                            nFeeRet = fee_needed_with_change;\n                            continue;\n                        }\n                    }\n\n                    // If we have change output already, just increase it\n                    if (nFeeRet > nFeeNeeded && nChangePosInOut != -1 && nSubtractFeeFromAmount == 0) {\n                        CAmount extraFeePaid = nFeeRet - nFeeNeeded;\n                        std::vector<CTxOut>::iterator change_position = txNew.vout.begin()+nChangePosInOut;\n                        change_position->nValue += extraFeePaid;\n                        nFeeRet -= extraFeePaid;\n                    }\n                    break; // Done, enough fee included.\n                }\n                else if (!pick_new_inputs) {\n                    // This shouldn't happen, we should have had enough excess\n                    // fee to pay for the new output and still meet nFeeNeeded\n                    // Or we should have just subtracted fee from recipients and\n                    // nFeeNeeded should not have changed\n                    strFailReason = _(\"Transaction fee and change calculation failed\");\n                    return false;\n                }\n\n                // Try to reduce change to include necessary fee\n                if (nChangePosInOut != -1 && nSubtractFeeFromAmount == 0) {\n                    CAmount additionalFeeNeeded = nFeeNeeded - nFeeRet;\n                    std::vector<CTxOut>::iterator change_position = txNew.vout.begin()+nChangePosInOut;\n                    // Only reduce change if remaining amount is still a large enough output.\n                    if (change_position->nValue >= MIN_FINAL_CHANGE + additionalFeeNeeded) {\n                        change_position->nValue -= additionalFeeNeeded;\n                        nFeeRet += additionalFeeNeeded;\n                        break; // Done, able to increase fee from change\n                    }\n                }\n\n                // If subtracting fee from recipients, we now know what fee we\n                // need to subtract, we have no reason to reselect inputs\n                if (nSubtractFeeFromAmount > 0) {\n                    pick_new_inputs = false;\n                }\n\n                // Include more fee and try again.\n                nFeeRet = nFeeNeeded;\n                coin_selection_params.use_bnb = false;\n                continue;\n            }\n        }\n\n        if (nChangePosInOut == -1) reservekey.ReturnKey(); // Return any reserved key if we don't have change\n\n        // Shuffle selected coins and fill in final vin\n        txNew.vin.clear();\n        std::vector<CInputCoin> selected_coins(setCoins.begin(), setCoins.end());\n        std::shuffle(selected_coins.begin(), selected_coins.end(), FastRandomContext());\n\n        // Note how the sequence number is set to non-maxint so that\n        // the nLockTime set above actually works.\n        //\n        // BIP125 defines opt-in RBF as any nSequence < maxint-1, so\n        // we use the highest possible value in that range (maxint-2)\n        // to avoid conflicting with other possible uses of nSequence,\n        // and in the spirit of \"smallest possible change from prior\n        // behavior.\"\n        const uint32_t nSequence = coin_control.signalRbf ? MAX_BIP125_RBF_SEQUENCE : (CTxIn::SEQUENCE_FINAL - 1);\n        for (const auto& coin : selected_coins) {\n            txNew.vin.push_back(CTxIn(coin.outpoint, CScript(), nSequence));\n        }\n\n        if (sign)\n        {\n            CTransaction txNewConst(txNew);\n            int nIn = 0;\n            for (const auto& coin : selected_coins)\n            {\n                const CScript& scriptPubKey = coin.txout.scriptPubKey;\n                SignatureData sigdata;\n\n                if (!ProduceSignature(TransactionSignatureCreator(this, &txNewConst, nIn, coin.txout.nValue, SIGHASH_ALL), scriptPubKey, sigdata))\n                {\n                    strFailReason = _(\"Signing transaction failed\");\n                    return false;\n                } else {\n                    UpdateTransaction(txNew, nIn, sigdata);\n                }\n\n                nIn++;\n            }\n        }\n\n        // Return the constructed transaction data.\n        tx = MakeTransactionRef(std::move(txNew));\n\n        // Limit size\n        if (GetTransactionWeight(*tx) >= MAX_STANDARD_TX_WEIGHT)\n        {\n            strFailReason = _(\"Transaction too large\");\n            return false;\n        }\n    }\n\n    if (gArgs.GetBoolArg(\"-walletrejectlongchains\", DEFAULT_WALLET_REJECT_LONG_CHAINS)) {\n        // Lastly, ensure this tx will pass the mempool's chain limits\n        LockPoints lp;\n        CTxMemPoolEntry entry(tx, 0, 0, 0, false, 0, lp);\n        CTxMemPool::setEntries setAncestors;\n        size_t nLimitAncestors = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n        size_t nLimitAncestorSize = gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000;\n        size_t nLimitDescendants = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n        size_t nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000;\n        std::string errString;\n        if (!mempool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize, nLimitDescendants, nLimitDescendantSize, errString)) {\n            strFailReason = _(\"Transaction has too long of a mempool chain\");\n            return false;\n        }\n    }\n\n    LogPrintf(\"Fee Calculation: Fee:%d Bytes:%u Needed:%d Tgt:%d (requested %d) Reason:\\\"%s\\\" Decay %.5f: Estimation: (%g - %g) %.2f%% %.1f/(%.1f %d mem %.1f out) Fail: (%g - %g) %.2f%% %.1f/(%.1f %d mem %.1f out)\\n\",\n              nFeeRet, nBytes, nFeeNeeded, feeCalc.returnedTarget, feeCalc.desiredTarget, StringForFeeReason(feeCalc.reason), feeCalc.est.decay,\n              feeCalc.est.pass.start, feeCalc.est.pass.end,\n              100 * feeCalc.est.pass.withinTarget / (feeCalc.est.pass.totalConfirmed + feeCalc.est.pass.inMempool + feeCalc.est.pass.leftMempool),\n              feeCalc.est.pass.withinTarget, feeCalc.est.pass.totalConfirmed, feeCalc.est.pass.inMempool, feeCalc.est.pass.leftMempool,\n              feeCalc.est.fail.start, feeCalc.est.fail.end,\n              100 * feeCalc.est.fail.withinTarget / (feeCalc.est.fail.totalConfirmed + feeCalc.est.fail.inMempool + feeCalc.est.fail.leftMempool),\n              feeCalc.est.fail.withinTarget, feeCalc.est.fail.totalConfirmed, feeCalc.est.fail.inMempool, feeCalc.est.fail.leftMempool);\n    return true;\n}",
  "abstract_func": "bool CWallet::CreateTransaction(const std::vector<CRecipient>& VAR_0, CTransactionRef& VAR_1, CReserveKey& VAR_2, CAmount& VAR_3,\n                                int& VAR_4, std::string& VAR_5, const CCoinControl& VAR_6, bool VAR_7)\n{\n    CAmount VAR_8 = 0;\n    int VAR_9 = VAR_4;\n    unsigned int VAR_10 = 0;\n    for (const auto& VAR_11 : VAR_0)\n    {\n        if (VAR_8 < 0 || VAR_11.nAmount < 0)\n        {\n            VAR_5 = _(\"Transaction amounts must not be negative\");\n            return false;\n        }\n        VAR_8 += VAR_11.nAmount;\n\n        if (VAR_11.fSubtractFeeFromAmount)\n            VAR_10++;\n    }\n    if (VAR_0.empty())\n    {\n        VAR_5 = _(\"Transaction must have at least one recipient\");\n        return false;\n    }\n\n    CMutableTransaction VAR_12;\n\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n    /* COMMENT_3 */\n    /* COMMENT_4 */\n    /* COMMENT_5 */\n    /* COMMENT_6 */\n    /* COMMENT_7 */\n    /* COMMENT_1 */\n    /* COMMENT_8 */\n    /* COMMENT_9 */\n    /* COMMENT_10 */\n    /* COMMENT_11 */\n    /* COMMENT_12 */\n    /* COMMENT_13 */\n    /* COMMENT_1 */\n    /* COMMENT_14 */\n    /* COMMENT_15 */\n    /* COMMENT_16 */\n    /* COMMENT_17 */\n    VAR_12.nLockTime = VAR_13.Height();\n\n    /* COMMENT_18 */\n    /* COMMENT_19 */\n    /* COMMENT_20 */\n    /* COMMENT_21 */\n    if (GetRandInt(10) == 0)\n        VAR_12.nLockTime = std::max(0, (int)VAR_12.nLockTime - GetRandInt(100));\n\n    assert(VAR_12.nLockTime <= (unsigned int)VAR_13.Height());\n    assert(VAR_12.nLockTime < VAR_14);\n    FeeCalculation VAR_15;\n    CAmount VAR_16;\n    int VAR_17;\n    {\n        std::set<CInputCoin> VAR_18;\n        LOCK2(VAR_19, VAR_20);\n        {\n            std::vector<COutput> VAR_21;\n            AvailableCoins(VAR_21, true, &VAR_6);\n            CoinSelectionParams VAR_22; /* COMMENT_22 */\n\n            /* COMMENT_23 */\n            /* COMMENT_24 */\n            /* COMMENT_25 */\n            CScript VAR_23;\n\n            /* COMMENT_26 */\n            if (!boost::VAR_24<CNoDestination>(&VAR_6.destChange)) {\n                VAR_23 = GetScriptForDestination(VAR_6.destChange);\n            } else { /* COMMENT_27 */\n                /* COMMENT_28 */\n                /* COMMENT_29 */\n                /* COMMENT_30 */\n                /* COMMENT_31 */\n                /* COMMENT_32 */\n                /* COMMENT_33 */\n\n                /* COMMENT_34 */\n                CPubKey VAR_25;\n                bool VAR_26;\n                VAR_26 = VAR_2.GetReservedKey(VAR_25, true);\n                if (!VAR_26)\n                {\n                    VAR_5 = _(\"Keypool ran out, please call keypoolrefill first\");\n                    return false;\n                }\n\n                const OutputType VAR_27 = TransactionChangeType(VAR_6.m_change_type ? *VAR_6.m_change_type : VAR_28, VAR_0);\n\n                LearnRelatedScripts(VAR_25, VAR_27);\n                VAR_23 = GetScriptForDestination(GetDestinationForKey(VAR_25, VAR_27));\n            }\n            CTxOut VAR_29(0, VAR_23);\n            VAR_22.change_output_size = GetSerializeSize(VAR_29, VAR_30, 0);\n\n            CFeeRate VAR_31 = GetDiscardRate(::feeEstimator);\n\n            /* COMMENT_35 */\n            CFeeRate VAR_32 = GetMinimumFeeRate(VAR_6, ::mempool, ::feeEstimator, &VAR_15);\n\n            VAR_3 = 0;\n            bool VAR_33 = true;\n            CAmount VAR_34 = 0;\n\n            /* COMMENT_36 */\n            /* COMMENT_37 */\n            VAR_22.use_bnb = VAR_10 == 0; /* COMMENT_38 */\n            /* COMMENT_39 */\n            while (true)\n            {\n                VAR_4 = VAR_9;\n                VAR_12.vin.clear();\n                VAR_12.vout.clear();\n                bool VAR_35 = true;\n\n                CAmount VAR_36 = VAR_8;\n                if (VAR_10 == 0)\n                    VAR_36 += VAR_3;\n\n                /* COMMENT_40 */\n                VAR_22.tx_noinputs_size = 11; /* COMMENT_41 */\n                for (const auto& VAR_11 : VAR_0)\n                {\n                    CTxOut VAR_37(VAR_11.nAmount, VAR_11.scriptPubKey);\n\n                    if (VAR_11.fSubtractFeeFromAmount)\n                    {\n                        assert(VAR_10 != 0);\n                        VAR_37.nValue -= VAR_3 / VAR_10; /* COMMENT_42 */\n\n                        if (VAR_35) /* COMMENT_43 */\n                        {\n                            VAR_35 = false;\n                            VAR_37.nValue -= VAR_3 % VAR_10;\n                        }\n                    }\n                    /* COMMENT_44 */\n                    VAR_22.tx_noinputs_size += ::GetSerializeSize(VAR_37, VAR_38, VAR_39);\n\n                    if (IsDust(VAR_37, ::dustRelayFee))\n                    {\n                        if (VAR_11.fSubtractFeeFromAmount && VAR_3 > 0)\n                        {\n                            if (VAR_37.nValue < 0)\n                                VAR_5 = _(\"The transaction amount is too small to pay the fee\");\n                            else\n                                VAR_5 = _(\"The transaction amount is too small to send after the fee has been deducted\");\n                        }\n                        else\n                            VAR_5 = _(\"Transaction amount too small\");\n                        return false;\n                    }\n                    VAR_12.vout.push_back(VAR_37);\n                }\n\n                /* COMMENT_45 */\n                bool VAR_40;\n                if (VAR_33) {\n                    VAR_34 = 0;\n                    VAR_18.clear();\n                    VAR_22.change_spend_size = CalculateMaximumSignedInputSize(VAR_29, this);\n                    VAR_22.effective_fee = VAR_32;\n                    if (!SelectCoins(VAR_21, VAR_36, VAR_18, VAR_34, VAR_6, VAR_22, VAR_40))\n                    {\n                        /* COMMENT_46 */\n                        if (VAR_40) {\n                            VAR_22.use_bnb = false;\n                            continue;\n                        }\n                        else {\n                            VAR_5 = _(\"Insufficient funds\");\n                            return false;\n                        }\n                    }\n                }\n\n                const CAmount VAR_41 = VAR_34 - VAR_36;\n                if (VAR_41 > 0)\n                {\n                    /* COMMENT_47 */\n                    CTxOut newTxOut(nChange, scriptChange);\n\n                    /* COMMENT_48 */\n                    /* COMMENT_49 */\n                    /* COMMENT_50 */\n                    if (IsDust(VAR_42, VAR_31) || VAR_40)\n                    {\n                        VAR_4 = -1;\n                        VAR_3 += nChange;\n                    }\n                    else\n                    {\n                        if (VAR_4 == -1)\n                        {\n                            /* COMMENT_51 */\n                            VAR_4 = GetRandInt(VAR_12.vout.size()+1);\n                        }\n                        else if ((unsigned int)VAR_4 > VAR_12.vout.size())\n                        {\n                            VAR_5 = _(\"Change index out of range\");\n                            return false;\n                        }\n\n                        std::vector<CTxOut>::iterator VAR_43 = VAR_12.vout.begin()+VAR_4;\n                        VAR_12.vout.insert(VAR_43, VAR_42);\n                    }\n                } else {\n                    VAR_4 = -1;\n                }\n\n                /* COMMENT_52 */\n                /* COMMENT_1 */\n                for (const auto& VAR_44 : VAR_18) {\n                    VAR_12.vin.push_back(CTxIn(VAR_44.outpoint,CScript()));\n                }\n\n                VAR_17 = CalculateMaximumSignedTxSize(VAR_12, this);\n                if (VAR_17 < 0) {\n                    VAR_5 = _(\"Signing transaction failed\");\n                    return false;\n                }\n\n                VAR_16 = GetMinimumFee(VAR_17, VAR_6, ::mempool, ::feeEstimator, &VAR_15);\n                if (VAR_15.reason == FeeReason::FALLBACK && !VAR_45) {\n                    /* COMMENT_53 */\n                    VAR_5 = _(\"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n                    return false;\n                }\n\n                /* COMMENT_54 */\n                /* COMMENT_55 */\n                if (VAR_16 < ::minRelayTxFee.GetFee(VAR_17))\n                {\n                    VAR_5 = _(\"Transaction too large for fee policy\");\n                    return false;\n                }\n\n                if (VAR_3 >= VAR_16) {\n                    /* COMMENT_56 */\n                    /* COMMENT_57 */\n                    /* COMMENT_58 */\n                    /* COMMENT_59 */\n\n                    /* COMMENT_60 */\n                    /* COMMENT_61 */\n                    /* COMMENT_62 */\n                    /* COMMENT_63 */\n                    /* COMMENT_64 */\n                    if (VAR_4 == -1 && VAR_10 == 0 && VAR_33) {\n                        unsigned int VAR_46 = VAR_17 + VAR_22.change_output_size + 2; /* COMMENT_65 */\n                        CAmount VAR_47 = GetMinimumFee(VAR_46, VAR_6, ::mempool, ::feeEstimator, nullptr);\n                        CAmount VAR_48 = GetDustThreshold(VAR_29, VAR_31);\n                        if (VAR_3 >= VAR_47 + VAR_48) {\n                            VAR_33 = false;\n                            VAR_3 = VAR_47;\n                            continue;\n                        }\n                    }\n\n                    /* COMMENT_66 */\n                    if (VAR_3 > VAR_16 && VAR_4 != -1 && VAR_10 == 0) {\n                        CAmount VAR_49 = VAR_3 - VAR_16;\n                        std::vector<CTxOut>::iterator VAR_50 = VAR_12.vout.begin()+VAR_4;\n                        VAR_50->nValue += VAR_49;\n                        VAR_3 -= VAR_49;\n                    }\n                    break; /* COMMENT_67 */\n                }\n                else if (!VAR_33) {\n                    /* COMMENT_68 */\n                    /* COMMENT_69 */\n                    /* COMMENT_70 */\n                    /* COMMENT_71 */\n                    VAR_5 = _(\"Transaction fee and change calculation failed\");\n                    return false;\n                }\n\n                /* COMMENT_72 */\n                if (VAR_4 != -1 && VAR_10 == 0) {\n                    CAmount VAR_51 = VAR_16 - VAR_3;\n                    std::vector<CTxOut>::iterator VAR_50 = VAR_12.vout.begin()+VAR_4;\n                    /* COMMENT_73 */\n                    if (VAR_50->nValue >= VAR_52 + VAR_51) {\n                        VAR_50->nValue -= VAR_51;\n                        VAR_3 += VAR_51;\n                        break; /* COMMENT_74 */\n                    }\n                }\n\n                /* COMMENT_75 */\n                /* COMMENT_76 */\n                if (VAR_10 > 0) {\n                    VAR_33 = false;\n                }\n\n                /* COMMENT_77 */\n                VAR_3 = VAR_16;\n                VAR_22.use_bnb = false;\n                continue;\n            }\n        }\n\n        if (VAR_4 == -1) VAR_2.ReturnKey(); /* COMMENT_78 */\n\n        /* COMMENT_79 */\n        VAR_12.vin.clear();\n        std::vector<CInputCoin> VAR_53(VAR_18.begin(), VAR_18.end());\n        std::shuffle(VAR_53.begin(), VAR_53.end(), FastRandomContext());\n\n        /* COMMENT_80 */\n        /* COMMENT_81 */\n        /* COMMENT_1 */\n        /* COMMENT_82 */\n        /* COMMENT_83 */\n        /* COMMENT_84 */\n        /* COMMENT_85 */\n        /* COMMENT_86 */\n        const uint32_t VAR_54 = VAR_6.signalRbf ? VAR_55 : (CTxIn::SEQUENCE_FINAL - 1);\n        for (const auto& VAR_44 : VAR_53) {\n            VAR_12.vin.push_back(CTxIn(VAR_44.outpoint, CScript(), VAR_54));\n        }\n\n        if (VAR_7)\n        {\n            CTransaction txNewConst(txNew);\n            int VAR_56 = 0;\n            for (const auto& VAR_44 : VAR_53)\n            {\n                const CScript& VAR_57 = VAR_44.txout.scriptPubKey;\n                SignatureData VAR_58;\n\n                if (!ProduceSignature(TransactionSignatureCreator(this, &VAR_59, VAR_56, VAR_44.txout.nValue, VAR_60), VAR_57, VAR_58))\n                {\n                    VAR_5 = _(\"Signing transaction failed\");\n                    return false;\n                } else {\n                    UpdateTransaction(txNew, VAR_56, VAR_58);\n                }\n\n                VAR_56++;\n            }\n        }\n\n        /* COMMENT_87 */\n        VAR_1 = MakeTransactionRef(std::move(txNew));\n\n        /* COMMENT_88 */\n        if (GetTransactionWeight(*VAR_1) >= VAR_61)\n        {\n            VAR_5 = _(\"Transaction too large\");\n            return false;\n        }\n    }\n\n    if (VAR_62.GetBoolArg(\"-walletrejectlongchains\", VAR_63)) {\n        /* COMMENT_89 */\n        LockPoints VAR_64;\n        CTxMemPoolEntry VAR_65(VAR_1, 0, 0, 0, false, 0, VAR_64);\n        CTxMemPool::setEntries VAR_66;\n        size_t VAR_67 = VAR_62.GetArg(\"-limitancestorcount\", VAR_68);\n        size_t VAR_69 = VAR_62.GetArg(\"-limitancestorsize\", VAR_70)*1000;\n        size_t VAR_71 = VAR_62.GetArg(\"-limitdescendantcount\", VAR_72);\n        size_t VAR_73 = VAR_62.GetArg(\"-limitdescendantsize\", VAR_74)*1000;\n        std::string VAR_75;\n        if (!VAR_76.CalculateMemPoolAncestors(VAR_65, VAR_66, VAR_67, VAR_69, VAR_71, VAR_73, VAR_75)) {\n            VAR_5 = _(\"Transaction has too long of a mempool chain\");\n            return false;\n        }\n    }\n\n    LogPrintf(\"Fee Calculation: Fee:%d Bytes:%u Needed:%d Tgt:%d (requested %d) Reason:\\\"%s\\\" Decay %.5f: Estimation: (%g - %g) %.2f%% %.1f/(%.1f %d mem %.1f out) Fail: (%g - %g) %.2f%% %.1f/(%.1f %d mem %.1f out)\\n\",\n              VAR_3, VAR_17, VAR_16, VAR_15.returnedTarget, VAR_15.desiredTarget, StringForFeeReason(VAR_15.reason), VAR_15.est.decay,\n              VAR_15.est.pass.start, VAR_15.est.pass.end,\n              100 * VAR_15.est.pass.withinTarget / (VAR_15.est.pass.totalConfirmed + VAR_15.est.pass.inMempool + VAR_15.est.pass.leftMempool),\n              VAR_15.est.pass.withinTarget, VAR_15.est.pass.totalConfirmed, VAR_15.est.pass.inMempool, VAR_15.est.pass.leftMempool,\n              VAR_15.est.fail.start, VAR_15.est.fail.end,\n              100 * VAR_15.est.fail.withinTarget / (VAR_15.est.fail.totalConfirmed + VAR_15.est.fail.inMempool + VAR_15.est.fail.leftMempool),\n              VAR_15.est.fail.withinTarget, VAR_15.est.fail.totalConfirmed, VAR_15.est.fail.inMempool, VAR_15.est.fail.leftMempool);\n    return true;\n}",
  "func_graph_path": "bitcoin/2fb9c1e6681370478e24a19172ed6d78d95d50d3/wallet.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -215,20 +215,11 @@\n                     nChangePosInOut = -1;\n                 }\n \n-                // Fill vin\n+                // Dummy fill vin for maximum size estimation\n                 //\n-                // Note how the sequence number is set to non-maxint so that\n-                // the nLockTime set above actually works.\n-                //\n-                // BIP125 defines opt-in RBF as any nSequence < maxint-1, so\n-                // we use the highest possible value in that range (maxint-2)\n-                // to avoid conflicting with other possible uses of nSequence,\n-                // and in the spirit of \"smallest possible change from prior\n-                // behavior.\"\n-                const uint32_t nSequence = coin_control.signalRbf ? MAX_BIP125_RBF_SEQUENCE : (CTxIn::SEQUENCE_FINAL - 1);\n-                for (const auto& coin : setCoins)\n-                    txNew.vin.push_back(CTxIn(coin.outpoint,CScript(),\n-                                              nSequence));\n+                for (const auto& coin : setCoins) {\n+                    txNew.vin.push_back(CTxIn(coin.outpoint,CScript()));\n+                }\n \n                 nBytes = CalculateMaximumSignedTxSize(txNew, this);\n                 if (nBytes < 0) {\n@@ -318,11 +309,29 @@\n \n         if (nChangePosInOut == -1) reservekey.ReturnKey(); // Return any reserved key if we don't have change\n \n+        // Shuffle selected coins and fill in final vin\n+        txNew.vin.clear();\n+        std::vector<CInputCoin> selected_coins(setCoins.begin(), setCoins.end());\n+        std::shuffle(selected_coins.begin(), selected_coins.end(), FastRandomContext());\n+\n+        // Note how the sequence number is set to non-maxint so that\n+        // the nLockTime set above actually works.\n+        //\n+        // BIP125 defines opt-in RBF as any nSequence < maxint-1, so\n+        // we use the highest possible value in that range (maxint-2)\n+        // to avoid conflicting with other possible uses of nSequence,\n+        // and in the spirit of \"smallest possible change from prior\n+        // behavior.\"\n+        const uint32_t nSequence = coin_control.signalRbf ? MAX_BIP125_RBF_SEQUENCE : (CTxIn::SEQUENCE_FINAL - 1);\n+        for (const auto& coin : selected_coins) {\n+            txNew.vin.push_back(CTxIn(coin.outpoint, CScript(), nSequence));\n+        }\n+\n         if (sign)\n         {\n             CTransaction txNewConst(txNew);\n             int nIn = 0;\n-            for (const auto& coin : setCoins)\n+            for (const auto& coin : selected_coins)\n             {\n                 const CScript& scriptPubKey = coin.txout.scriptPubKey;\n                 SignatureData sigdata;",
  "diff_line_info": {
    "deleted_lines": [
      "                // Fill vin",
      "                // Note how the sequence number is set to non-maxint so that",
      "                // the nLockTime set above actually works.",
      "                //",
      "                // BIP125 defines opt-in RBF as any nSequence < maxint-1, so",
      "                // we use the highest possible value in that range (maxint-2)",
      "                // to avoid conflicting with other possible uses of nSequence,",
      "                // and in the spirit of \"smallest possible change from prior",
      "                // behavior.\"",
      "                const uint32_t nSequence = coin_control.signalRbf ? MAX_BIP125_RBF_SEQUENCE : (CTxIn::SEQUENCE_FINAL - 1);",
      "                for (const auto& coin : setCoins)",
      "                    txNew.vin.push_back(CTxIn(coin.outpoint,CScript(),",
      "                                              nSequence));",
      "            for (const auto& coin : setCoins)"
    ],
    "added_lines": [
      "                // Dummy fill vin for maximum size estimation",
      "                for (const auto& coin : setCoins) {",
      "                    txNew.vin.push_back(CTxIn(coin.outpoint,CScript()));",
      "                }",
      "        // Shuffle selected coins and fill in final vin",
      "        txNew.vin.clear();",
      "        std::vector<CInputCoin> selected_coins(setCoins.begin(), setCoins.end());",
      "        std::shuffle(selected_coins.begin(), selected_coins.end(), FastRandomContext());",
      "",
      "        // Note how the sequence number is set to non-maxint so that",
      "        // the nLockTime set above actually works.",
      "        //",
      "        // BIP125 defines opt-in RBF as any nSequence < maxint-1, so",
      "        // we use the highest possible value in that range (maxint-2)",
      "        // to avoid conflicting with other possible uses of nSequence,",
      "        // and in the spirit of \"smallest possible change from prior",
      "        // behavior.\"",
      "        const uint32_t nSequence = coin_control.signalRbf ? MAX_BIP125_RBF_SEQUENCE : (CTxIn::SEQUENCE_FINAL - 1);",
      "        for (const auto& coin : selected_coins) {",
      "            txNew.vin.push_back(CTxIn(coin.outpoint, CScript(), nSequence));",
      "        }",
      "",
      "            for (const auto& coin : selected_coins)"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/bitcoin/bitcoin/pull/12699",
  "description": {
    "pr_info": {
      "title": "[wallet] Shuffle transaction inputs before signing",
      "number": 12699
    },
    "comment": [
      "Currently inputs are ordered based on COutPoint ordering, which while doesn't leak additional internal wallet state, likely further fingerprints the wallet as a Core wallet to observers.\r\n\r\nNote: This slightly changed behavior of `fundrawtransaction` in that the newly-appended inputs will now be shuffled rather than in outpoint-order. This does not break API compatibility. \r\n\r\nSimple shuffling of the coins being returned will hopefully allow the wallet to blend in a bit more, in lieu of additional data to find what other wallets are doing, or another standard, ala @gmaxwell's suggested of ordering via scriptPubKey.",
      "Concept ACK - haven't reviewed yet but this looks like a lot of changes for just an additional input shuffle step?",
      "Ok, I can make this smaller. ~~Just realized that the inner-use of the inputs doesn't actually require proper ordering for transaction size estimation, so it should just be a single shuffle before signing.~~\r\n\r\nA bit annoying due to inner-loop behavior, but I'll see what I can do.",
      "Related discussion: https://botbot.me/freenode/bitcoin-core-dev/msg/97851598/",
      "Maybe just use the same ordering as [BIP-69](https://github.com/bitcoin/bips/blob/master/bip-0069.mediawiki#Transaction_Inputs)?",
      "@Sjors I'd prefer to something slightly less bad now, and converge on a standard later. I have some quibbles with BIP69, which I think are out of scope for this thread.",
      "TIL the Core wallet doesn't use BIP-69 (which is a separate discussion), so that does weaken the case for using it here. (and TIL coin selection function also determines the order, not just the set)\r\n\r\nSee also #12457",
      "Smaller changeset now, had to move the final input creation further output to avoid storing shuffle ordering.",
      "Turns out that we're ~this far away(in master) from having the input part compliant with BIP69:\r\n\r\n>struct bip69_compare {\r\n>    bool operator() (const uint256& lhs, const uint256& rhs) const\r\n>    {\r\n>        uint256 lhs_hash = rhs;\r\n>        uint256 rhs_hash = lhs;\r\n>        std::reverse(lhs_hash.begin(), lhs_hash.end());\r\n>        std::reverse(rhs_hash.begin(), rhs_hash.end());\r\n>        return rhs_hash < lhs_hash;\r\n>    }\r\n>};`\r\n\r\nThe inputs are being sorted by BE rather than LE as per the BIP.\r\n\r\nWe also currently aren't really shuffling outputs randomly(except the case of 2 outputs, 1 destination and 1 change. This is fixed by a single shuffle line. BIP69 compliance would be another comparison struct.\r\n\r\nI still prefer this changeset for the time being, due to ease of implementation and complementary nature with #12709",
      "BIP 69 contradicts SIGHASH_SINGLE usage, and its concerns seem unrealistic (if you use malicious closed source wallet software, you're already compromised regardless). Randomising seems fine.",
      "utACK https://github.com/bitcoin/bitcoin/pull/12699/commits/8712bbd6f0f643359b5e6dd090cf247bee3dd087",
      "rebased onto https://github.com/bitcoin/bitcoin/pull/12742 to avoid code churn",
      "utACK 2fb9c1e6681370478e24a19172ed6d78d95d50d3",
      "If you want to remove the erroneous diff from the GitHub web view:\r\n\r\n```sh\r\nEDITOR=true git commit --allow-empty -m empty && git push git@github.com:instagibbs/bitcoin.git shuffleinputs && git reset --hard 2fb9c1e && git push git@github.com:instagibbs/bitcoin.git shuffleinputs -f",
      "utACK 2fb9c1e6681370478e24a19172ed6d78d95d50d3",
      "utACK 2fb9c1e, looks good.\r\n\r\n> This slightly changed behavior of fundrawtransaction in that the newly-appended inputs will now be shuffled rather than in outpoint-order. \r\n\r\nAt least the test framework doesn't rely on the order.",
      "PR title seems outdated now (the shuffle happens after `SelectCoins` returns).",
      "updated title",
      "utACK https://github.com/bitcoin/bitcoin/pull/12699/commits/2fb9c1e6681370478e24a19172ed6d78d95d50d3"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.9"
}