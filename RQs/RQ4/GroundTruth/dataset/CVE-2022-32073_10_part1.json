{
  "cve_id": "CVE-2022-32073",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "wolfSSL/wolfssh",
  "commit_msg": "ASAN SFTP Fixes\nWhen decoding SFTP messages, fix the size checks so they don't wrap. (ZD12766)",
  "commit_hash": "edb272e35ee57e7b89f3e127222c6981b6a1e730",
  "git_url": "https://github.com/wolfSSL/wolfssh/commit/edb272e35ee57e7b89f3e127222c6981b6a1e730",
  "file_path": "src/wolfsftp.c",
  "func_name": "wolfSSH_SFTP_RecvRealPath",
  "func_before": "static int wolfSSH_SFTP_RecvRealPath(WOLFSSH* ssh, int reqId, byte* data,\n        int maxSz)\n{\n    WS_SFTP_FILEATRB atr;\n    char  r[WOLFSSH_MAX_FILENAME];\n    word32 rSz;\n    word32 lidx = 0;\n    word32 i;\n    int    ret;\n    byte* out;\n    word32 outSz = 0;\n\n    WLOG(WS_LOG_SFTP, \"Receiving WOLFSSH_FTP_REALPATH\");\n\n    if (ssh == NULL) {\n        WLOG(WS_LOG_SFTP, \"Bad argument passed in\");\n        return WS_BAD_ARGUMENT;\n    }\n\n    if (maxSz < UINT32_SZ) {\n        /* not enough for an ato32 call */\n        return WS_BUFFER_E;\n    }\n\n    ato32(data + lidx, &rSz);\n    if (rSz > WOLFSSH_MAX_FILENAME || (int)(rSz + UINT32_SZ) > maxSz) {\n        return WS_BUFFER_E;\n    }\n    lidx += UINT32_SZ;\n    WMEMCPY(r, data + lidx, rSz);\n    r[rSz] = '\\0';\n\n    /* get working directory in the case of receiving non absolute path */\n    if (r[0] != '/' && r[1] != ':') {\n        char wd[WOLFSSH_MAX_FILENAME];\n\n        WMEMSET(wd, 0, WOLFSSH_MAX_FILENAME);\n        if (ssh->sftpDefaultPath) {\n            XSTRNCPY(wd, ssh->sftpDefaultPath, WOLFSSH_MAX_FILENAME - 1);\n        }\n        else {\n        #ifndef USE_WINDOWS_API\n            if (WGETCWD(ssh->fs, wd, WOLFSSH_MAX_FILENAME) == NULL) {\n                WLOG(WS_LOG_SFTP, \"Unable to get current working directory\");\n                if (wolfSSH_SFTP_CreateStatus(ssh, WOLFSSH_FTP_FAILURE, reqId,\n                        \"Directory error\", \"English\", NULL, &outSz)\n                        != WS_SIZE_ONLY) {\n                    return WS_FATAL_ERROR;\n                }\n                out = (byte*) WMALLOC(outSz, ssh->ctx->heap, DYNTYPE_BUFFER);\n                if (out == NULL) {\n                    return WS_MEMORY_E;\n                }\n                if (wolfSSH_SFTP_CreateStatus(ssh, WOLFSSH_FTP_FAILURE, reqId,\n                        \"Directory error\", \"English\", out, &outSz)\n                        != WS_SUCCESS) {\n                    WFREE(out, ssh->ctx->heap, DYNTYPE_BUFFER);\n                    return WS_FATAL_ERROR;\n                }\n                /* take over control of buffer */\n                wolfSSH_SFTP_RecvSetSend(ssh, out, outSz);\n                return WS_BAD_FILE_E;\n            }\n        #endif\n        }\n        WSTRNCAT(wd, \"/\", WOLFSSH_MAX_FILENAME);\n        WSTRNCAT(wd, r, WOLFSSH_MAX_FILENAME);\n        WMEMCPY(r, wd, WOLFSSH_MAX_FILENAME);\n    }\n\n    if ((ret = wolfSSH_CleanPath(ssh, r)) < 0) {\n        return WS_FATAL_ERROR;\n    }\n    rSz = (word32)ret;\n\n    /* For real path remove ending case of /.\n     * Lots of peers send a '.' wanting a return of the current absolute path\n     * not the absolute path + .\n     */\n    if (r[rSz - 2] == WS_DELIM && r[rSz - 1] == '.') {\n        r[rSz - 1] = '\\0';\n        rSz -= 1;\n    }\n\n    /* for real path always send '/' chars */\n    for (i = 0; i < rSz; i++) {\n        if (r[i] == WS_DELIM) r[i] = '/';\n    }\n    WLOG(WS_LOG_SFTP, \"Real Path Directory = %s\", r);\n\n    /* send response */\n    outSz = WOLFSSH_SFTP_HEADER + (UINT32_SZ * 3) + (rSz * 2);\n    WMEMSET(&atr, 0, sizeof(WS_SFTP_FILEATRB));\n    outSz += SFTP_AtributesSz(ssh, &atr);\n    lidx = 0;\n\n    /* reuse state buffer if large enough */\n    out = (outSz > (word32)maxSz)?\n            (byte*)WMALLOC(outSz, ssh->ctx->heap, DYNTYPE_BUFFER) :\n            wolfSSH_SFTP_RecvGetData(ssh);\n    if (out == NULL) {\n        return WS_MEMORY_E;\n    }\n\n    SFTP_SetHeader(ssh, reqId, WOLFSSH_FTP_NAME,\n            outSz - WOLFSSH_SFTP_HEADER, out);\n    lidx += WOLFSSH_SFTP_HEADER;\n\n    /* set number of files */\n    c32toa(1, out + lidx); lidx += UINT32_SZ; /* only sending one file name */\n\n    /* set file name size and string */\n    c32toa(rSz, out + lidx); lidx += UINT32_SZ;\n    WMEMCPY(out + lidx, r, rSz); lidx += rSz;\n\n    /* set long name size and string */\n    c32toa(rSz, out + lidx); lidx += UINT32_SZ;\n    WMEMCPY(out + lidx, r, rSz); lidx += rSz;\n\n    /* set attributes */\n    SFTP_SetAttributes(ssh, out + lidx, outSz - lidx, &atr);\n\n    /* set send out buffer, \"out\" buffer is taken over by \"ssh\" */\n    wolfSSH_SFTP_RecvSetSend(ssh, out, outSz);\n    return WS_SUCCESS;\n}",
  "abstract_func_before": "static int wolfSSH_SFTP_RecvRealPath(WOLFSSH* VAR_0, int VAR_1, byte* VAR_2,\n        int VAR_3)\n{\n    WS_SFTP_FILEATRB VAR_4;\n    char  VAR_5[VAR_6];\n    word32 VAR_7;\n    word32 VAR_8 = 0;\n    word32 VAR_9;\n    int    VAR_10;\n    byte* VAR_11;\n    word32 VAR_12 = 0;\n\n    WLOG(VAR_13, \"Receiving WOLFSSH_FTP_REALPATH\");\n\n    if (VAR_0 == NULL) {\n        WLOG(VAR_13, \"Bad argument passed in\");\n        return VAR_14;\n    }\n\n    if (VAR_3 < VAR_15) {\n        /* COMMENT_0 */\n        return VAR_16;\n    }\n\n    ato32(VAR_2 + VAR_8, &VAR_7);\n    if (VAR_7 > VAR_6 || (int)(VAR_7 + VAR_15) > VAR_3) {\n        return VAR_16;\n    }\n    VAR_8 += VAR_15;\n    WMEMCPY(VAR_5, VAR_2 + VAR_8, VAR_7);\n    VAR_5[VAR_7] = '\\0';\n\n    /* COMMENT_1 */\n    if (VAR_5[0] != '/' && VAR_5[1] != ':') {\n        char VAR_17[VAR_6];\n\n        WMEMSET(VAR_17, 0, VAR_6);\n        if (VAR_0->sftpDefaultPath) {\n            XSTRNCPY(VAR_17, VAR_0->sftpDefaultPath, VAR_6 - 1);\n        }\n        else {\n        #ifndef VAR_18\n            if (WGETCWD(VAR_0->fs, VAR_17, VAR_6) == NULL) {\n                WLOG(VAR_13, \"Unable to get current working directory\");\n                if (wolfSSH_SFTP_CreateStatus(VAR_0, VAR_19, VAR_1,\n                        \"Directory error\", \"English\", NULL, &VAR_12)\n                        != VAR_20) {\n                    return VAR_21;\n                }\n                VAR_11 = (byte*) WMALLOC(VAR_12, VAR_0->ctx->heap, VAR_22);\n                if (VAR_11 == NULL) {\n                    return VAR_23;\n                }\n                if (wolfSSH_SFTP_CreateStatus(VAR_0, VAR_19, VAR_1,\n                        \"Directory error\", \"English\", VAR_11, &VAR_12)\n                        != VAR_24) {\n                    WFREE(VAR_11, VAR_0->ctx->heap, VAR_22);\n                    return VAR_21;\n                }\n                /* COMMENT_2 */\n                wolfSSH_SFTP_RecvSetSend(VAR_0, VAR_11, VAR_12);\n                return VAR_25;\n            }\n        #endif\n        }\n        WSTRNCAT(VAR_17, \"/\", VAR_6);\n        WSTRNCAT(VAR_17, VAR_5, VAR_6);\n        WMEMCPY(VAR_5, VAR_17, VAR_6);\n    }\n\n    if ((VAR_10 = wolfSSH_CleanPath(VAR_0, VAR_5)) < 0) {\n        return VAR_21;\n    }\n    VAR_7 = (word32)VAR_10;\n\n    /* COMMENT_3 */\n                                                                             \n                                \n       \n    if (VAR_5[VAR_7 - 2] == VAR_26 && VAR_5[VAR_7 - 1] == '.') {\n        VAR_5[VAR_7 - 1] = '\\0';\n        VAR_7 -= 1;\n    }\n\n    /* COMMENT_7 */\n    for (VAR_9 = 0; VAR_9 < VAR_7; VAR_9++) {\n        if (VAR_5[VAR_9] == VAR_26) VAR_5[VAR_9] = '/';\n    }\n    WLOG(VAR_13, \"Real Path Directory = %s\", VAR_5);\n\n    /* COMMENT_8 */\n    VAR_12 = VAR_27 + (VAR_15 * 3) + (VAR_7 * 2);\n    WMEMSET(&VAR_4, 0, sizeof(WS_SFTP_FILEATRB));\n    VAR_12 += SFTP_AtributesSz(VAR_0, &VAR_4);\n    VAR_8 = 0;\n\n    /* COMMENT_9 */\n    VAR_11 = (VAR_12 > (word32)VAR_3)?\n            (byte*)WMALLOC(VAR_12, VAR_0->ctx->heap, VAR_22) :\n            wolfSSH_SFTP_RecvGetData(VAR_0);\n    if (VAR_11 == NULL) {\n        return VAR_23;\n    }\n\n    SFTP_SetHeader(VAR_0, VAR_1, VAR_28,\n            VAR_12 - VAR_27, VAR_11);\n    VAR_8 += VAR_27;\n\n    /* COMMENT_10 */\n    c32toa(1, VAR_11 + VAR_8); VAR_8 += VAR_15; /* COMMENT_11 */\n\n    /* COMMENT_12 */\n    c32toa(VAR_7, VAR_11 + VAR_8); VAR_8 += VAR_15;\n    WMEMCPY(VAR_11 + VAR_8, VAR_5, VAR_7); VAR_8 += VAR_7;\n\n    /* COMMENT_13 */\n    c32toa(VAR_7, VAR_11 + VAR_8); VAR_8 += VAR_15;\n    WMEMCPY(VAR_11 + VAR_8, VAR_5, VAR_7); VAR_8 += VAR_7;\n\n    /* COMMENT_14 */\n    SFTP_SetAttributes(VAR_0, VAR_11 + VAR_8, VAR_12 - VAR_8, &VAR_4);\n\n    /* COMMENT_15 */\n    wolfSSH_SFTP_RecvSetSend(VAR_0, VAR_11, VAR_12);\n    return VAR_24;\n}",
  "func_graph_path_before": "wolfSSL/wolfssh/edb272e35ee57e7b89f3e127222c6981b6a1e730/wolfsftp.c/vul/before/11.json",
  "func": "static int wolfSSH_SFTP_RecvRealPath(WOLFSSH* ssh, int reqId, byte* data,\n        int maxSz)\n{\n    WS_SFTP_FILEATRB atr;\n    char  r[WOLFSSH_MAX_FILENAME];\n    word32 rSz;\n    word32 lidx = 0;\n    word32 i;\n    int    ret;\n    byte* out;\n    word32 outSz = 0;\n\n    WLOG(WS_LOG_SFTP, \"Receiving WOLFSSH_FTP_REALPATH\");\n\n    if (ssh == NULL) {\n        WLOG(WS_LOG_SFTP, \"Bad argument passed in\");\n        return WS_BAD_ARGUMENT;\n    }\n\n    if (maxSz < UINT32_SZ) {\n        /* not enough for an ato32 call */\n        return WS_BUFFER_E;\n    }\n\n    ato32(data + lidx, &rSz);\n    if (rSz >= WOLFSSH_MAX_FILENAME || (int)(rSz + UINT32_SZ) > maxSz) {\n        return WS_BUFFER_E;\n    }\n    lidx += UINT32_SZ;\n    WMEMCPY(r, data + lidx, rSz);\n    r[rSz] = '\\0';\n\n    /* get working directory in the case of receiving non absolute path */\n    if (r[0] != '/' && r[1] != ':') {\n        char wd[WOLFSSH_MAX_FILENAME];\n\n        WMEMSET(wd, 0, WOLFSSH_MAX_FILENAME);\n        if (ssh->sftpDefaultPath) {\n            XSTRNCPY(wd, ssh->sftpDefaultPath, WOLFSSH_MAX_FILENAME - 1);\n        }\n        else {\n        #ifndef USE_WINDOWS_API\n            if (WGETCWD(ssh->fs, wd, WOLFSSH_MAX_FILENAME) == NULL) {\n                WLOG(WS_LOG_SFTP, \"Unable to get current working directory\");\n                if (wolfSSH_SFTP_CreateStatus(ssh, WOLFSSH_FTP_FAILURE, reqId,\n                        \"Directory error\", \"English\", NULL, &outSz)\n                        != WS_SIZE_ONLY) {\n                    return WS_FATAL_ERROR;\n                }\n                out = (byte*) WMALLOC(outSz, ssh->ctx->heap, DYNTYPE_BUFFER);\n                if (out == NULL) {\n                    return WS_MEMORY_E;\n                }\n                if (wolfSSH_SFTP_CreateStatus(ssh, WOLFSSH_FTP_FAILURE, reqId,\n                        \"Directory error\", \"English\", out, &outSz)\n                        != WS_SUCCESS) {\n                    WFREE(out, ssh->ctx->heap, DYNTYPE_BUFFER);\n                    return WS_FATAL_ERROR;\n                }\n                /* take over control of buffer */\n                wolfSSH_SFTP_RecvSetSend(ssh, out, outSz);\n                return WS_BAD_FILE_E;\n            }\n        #endif\n        }\n        WSTRNCAT(wd, \"/\", WOLFSSH_MAX_FILENAME);\n        WSTRNCAT(wd, r, WOLFSSH_MAX_FILENAME);\n        WMEMCPY(r, wd, WOLFSSH_MAX_FILENAME);\n    }\n\n    if ((ret = wolfSSH_CleanPath(ssh, r)) < 0) {\n        return WS_FATAL_ERROR;\n    }\n    rSz = (word32)ret;\n\n    /* For real path remove ending case of /.\n     * Lots of peers send a '.' wanting a return of the current absolute path\n     * not the absolute path + .\n     */\n    if (r[rSz - 2] == WS_DELIM && r[rSz - 1] == '.') {\n        r[rSz - 1] = '\\0';\n        rSz -= 1;\n    }\n\n    /* for real path always send '/' chars */\n    for (i = 0; i < rSz; i++) {\n        if (r[i] == WS_DELIM) r[i] = '/';\n    }\n    WLOG(WS_LOG_SFTP, \"Real Path Directory = %s\", r);\n\n    /* send response */\n    outSz = WOLFSSH_SFTP_HEADER + (UINT32_SZ * 3) + (rSz * 2);\n    WMEMSET(&atr, 0, sizeof(WS_SFTP_FILEATRB));\n    outSz += SFTP_AtributesSz(ssh, &atr);\n    lidx = 0;\n\n    /* reuse state buffer if large enough */\n    out = (outSz > (word32)maxSz)?\n            (byte*)WMALLOC(outSz, ssh->ctx->heap, DYNTYPE_BUFFER) :\n            wolfSSH_SFTP_RecvGetData(ssh);\n    if (out == NULL) {\n        return WS_MEMORY_E;\n    }\n\n    SFTP_SetHeader(ssh, reqId, WOLFSSH_FTP_NAME,\n            outSz - WOLFSSH_SFTP_HEADER, out);\n    lidx += WOLFSSH_SFTP_HEADER;\n\n    /* set number of files */\n    c32toa(1, out + lidx); lidx += UINT32_SZ; /* only sending one file name */\n\n    /* set file name size and string */\n    c32toa(rSz, out + lidx); lidx += UINT32_SZ;\n    WMEMCPY(out + lidx, r, rSz); lidx += rSz;\n\n    /* set long name size and string */\n    c32toa(rSz, out + lidx); lidx += UINT32_SZ;\n    WMEMCPY(out + lidx, r, rSz); lidx += rSz;\n\n    /* set attributes */\n    SFTP_SetAttributes(ssh, out + lidx, outSz - lidx, &atr);\n\n    /* set send out buffer, \"out\" buffer is taken over by \"ssh\" */\n    wolfSSH_SFTP_RecvSetSend(ssh, out, outSz);\n    return WS_SUCCESS;\n}",
  "abstract_func": "static int wolfSSH_SFTP_RecvRealPath(WOLFSSH* VAR_0, int VAR_1, byte* VAR_2,\n        int VAR_3)\n{\n    WS_SFTP_FILEATRB VAR_4;\n    char  VAR_5[VAR_6];\n    word32 VAR_7;\n    word32 VAR_8 = 0;\n    word32 VAR_9;\n    int    VAR_10;\n    byte* VAR_11;\n    word32 VAR_12 = 0;\n\n    WLOG(VAR_13, \"Receiving WOLFSSH_FTP_REALPATH\");\n\n    if (VAR_0 == NULL) {\n        WLOG(VAR_13, \"Bad argument passed in\");\n        return VAR_14;\n    }\n\n    if (VAR_3 < VAR_15) {\n        /* COMMENT_0 */\n        return VAR_16;\n    }\n\n    ato32(VAR_2 + VAR_8, &VAR_7);\n    if (VAR_7 >= VAR_6 || (int)(VAR_7 + VAR_15) > VAR_3) {\n        return VAR_16;\n    }\n    VAR_8 += VAR_15;\n    WMEMCPY(VAR_5, VAR_2 + VAR_8, VAR_7);\n    VAR_5[VAR_7] = '\\0';\n\n    /* COMMENT_1 */\n    if (VAR_5[0] != '/' && VAR_5[1] != ':') {\n        char VAR_17[VAR_6];\n\n        WMEMSET(VAR_17, 0, VAR_6);\n        if (VAR_0->sftpDefaultPath) {\n            XSTRNCPY(VAR_17, VAR_0->sftpDefaultPath, VAR_6 - 1);\n        }\n        else {\n        #ifndef VAR_18\n            if (WGETCWD(VAR_0->fs, VAR_17, VAR_6) == NULL) {\n                WLOG(VAR_13, \"Unable to get current working directory\");\n                if (wolfSSH_SFTP_CreateStatus(VAR_0, VAR_19, VAR_1,\n                        \"Directory error\", \"English\", NULL, &VAR_12)\n                        != VAR_20) {\n                    return VAR_21;\n                }\n                VAR_11 = (byte*) WMALLOC(VAR_12, VAR_0->ctx->heap, VAR_22);\n                if (VAR_11 == NULL) {\n                    return VAR_23;\n                }\n                if (wolfSSH_SFTP_CreateStatus(VAR_0, VAR_19, VAR_1,\n                        \"Directory error\", \"English\", VAR_11, &VAR_12)\n                        != VAR_24) {\n                    WFREE(VAR_11, VAR_0->ctx->heap, VAR_22);\n                    return VAR_21;\n                }\n                /* COMMENT_2 */\n                wolfSSH_SFTP_RecvSetSend(VAR_0, VAR_11, VAR_12);\n                return VAR_25;\n            }\n        #endif\n        }\n        WSTRNCAT(VAR_17, \"/\", VAR_6);\n        WSTRNCAT(VAR_17, VAR_5, VAR_6);\n        WMEMCPY(VAR_5, VAR_17, VAR_6);\n    }\n\n    if ((VAR_10 = wolfSSH_CleanPath(VAR_0, VAR_5)) < 0) {\n        return VAR_21;\n    }\n    VAR_7 = (word32)VAR_10;\n\n    /* COMMENT_3 */\n                                                                             \n                                \n       \n    if (VAR_5[VAR_7 - 2] == VAR_26 && VAR_5[VAR_7 - 1] == '.') {\n        VAR_5[VAR_7 - 1] = '\\0';\n        VAR_7 -= 1;\n    }\n\n    /* COMMENT_7 */\n    for (VAR_9 = 0; VAR_9 < VAR_7; VAR_9++) {\n        if (VAR_5[VAR_9] == VAR_26) VAR_5[VAR_9] = '/';\n    }\n    WLOG(VAR_13, \"Real Path Directory = %s\", VAR_5);\n\n    /* COMMENT_8 */\n    VAR_12 = VAR_27 + (VAR_15 * 3) + (VAR_7 * 2);\n    WMEMSET(&VAR_4, 0, sizeof(WS_SFTP_FILEATRB));\n    VAR_12 += SFTP_AtributesSz(VAR_0, &VAR_4);\n    VAR_8 = 0;\n\n    /* COMMENT_9 */\n    VAR_11 = (VAR_12 > (word32)VAR_3)?\n            (byte*)WMALLOC(VAR_12, VAR_0->ctx->heap, VAR_22) :\n            wolfSSH_SFTP_RecvGetData(VAR_0);\n    if (VAR_11 == NULL) {\n        return VAR_23;\n    }\n\n    SFTP_SetHeader(VAR_0, VAR_1, VAR_28,\n            VAR_12 - VAR_27, VAR_11);\n    VAR_8 += VAR_27;\n\n    /* COMMENT_10 */\n    c32toa(1, VAR_11 + VAR_8); VAR_8 += VAR_15; /* COMMENT_11 */\n\n    /* COMMENT_12 */\n    c32toa(VAR_7, VAR_11 + VAR_8); VAR_8 += VAR_15;\n    WMEMCPY(VAR_11 + VAR_8, VAR_5, VAR_7); VAR_8 += VAR_7;\n\n    /* COMMENT_13 */\n    c32toa(VAR_7, VAR_11 + VAR_8); VAR_8 += VAR_15;\n    WMEMCPY(VAR_11 + VAR_8, VAR_5, VAR_7); VAR_8 += VAR_7;\n\n    /* COMMENT_14 */\n    SFTP_SetAttributes(VAR_0, VAR_11 + VAR_8, VAR_12 - VAR_8, &VAR_4);\n\n    /* COMMENT_15 */\n    wolfSSH_SFTP_RecvSetSend(VAR_0, VAR_11, VAR_12);\n    return VAR_24;\n}",
  "func_graph_path": "wolfSSL/wolfssh/edb272e35ee57e7b89f3e127222c6981b6a1e730/wolfsftp.c/vul/after/11.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -23,7 +23,7 @@\n     }\n \n     ato32(data + lidx, &rSz);\n-    if (rSz > WOLFSSH_MAX_FILENAME || (int)(rSz + UINT32_SZ) > maxSz) {\n+    if (rSz >= WOLFSSH_MAX_FILENAME || (int)(rSz + UINT32_SZ) > maxSz) {\n         return WS_BUFFER_E;\n     }\n     lidx += UINT32_SZ;",
  "diff_line_info": {
    "deleted_lines": [
      "    if (rSz > WOLFSSH_MAX_FILENAME || (int)(rSz + UINT32_SZ) > maxSz) {"
    ],
    "added_lines": [
      "    if (rSz >= WOLFSSH_MAX_FILENAME || (int)(rSz + UINT32_SZ) > maxSz) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/wolfSSL/wolfssh/pull/360",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/wolfSSL/wolfssh/pull/360: 403 Client Error: Forbidden for url: https://api.github.com/repos/wolfSSL/wolfssh/pulls/360",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "The patch modifies a size check in an SFTP message decoding function, likely to prevent a buffer overflow. This is indicative of addressing a security vulnerability. \n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95"
}