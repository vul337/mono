{
  "cve_id": "CVE-2021-32728",
  "cwe_ids": [
    "CWE-295"
  ],
  "cvss_vector": "AV:N/AC:L/Au:S/C:P/I:N/A:N",
  "cvss_is_v3": false,
  "repo_name": "nextcloud/desktop",
  "commit_msg": "check e2ee public key against private one\n\nshould ensure we have matching private/public keys\n\nSigned-off-by: Matthieu Gallien <matthieu_gallien@yahoo.fr>",
  "commit_hash": "7fb09a81632de6066e55def20308d6e61cadbc48",
  "git_url": "https://github.com/nextcloud/desktop/commit/7fb09a81632de6066e55def20308d6e61cadbc48",
  "file_path": "src/libsync/clientsideencryption.cpp",
  "func_name": "ClientSideEncryption::decryptPrivateKey",
  "func_before": "void ClientSideEncryption::decryptPrivateKey(const AccountPtr &account, const QByteArray &key) {\n    QString msg = tr(\"Please enter your end to end encryption passphrase:<br>\"\n                     \"<br>\"\n                     \"User: %2<br>\"\n                     \"Account: %3<br>\")\n                      .arg(Utility::escape(account->credentials()->user()),\n                           Utility::escape(account->displayName()));\n\n    QInputDialog dialog;\n    dialog.setWindowTitle(tr(\"Enter E2E passphrase\"));\n    dialog.setLabelText(msg);\n    dialog.setTextEchoMode(QLineEdit::Normal);\n\n    QString prev;\n\n    while(true) {\n        if (!prev.isEmpty()) {\n            dialog.setTextValue(prev);\n        }\n        bool ok = dialog.exec();\n        if (ok) {\n            qCInfo(lcCse()) << \"Got mnemonic:\" << dialog.textValue();\n            prev = dialog.textValue();\n\n            _mnemonic = prev;\n            QString mnemonic = prev.split(\" \").join(QString()).toLower();\n            qCInfo(lcCse()) << \"mnemonic:\" << mnemonic;\n\n            // split off salt\n            const auto salt = EncryptionHelper::extractPrivateKeySalt(key);\n\n            auto pass = EncryptionHelper::generatePassword(mnemonic, salt);\n            qCInfo(lcCse()) << \"Generated key:\" << pass;\n\n            QByteArray privateKey = EncryptionHelper::decryptPrivateKey(pass, key);\n            //_privateKey = QSslKey(privateKey, QSsl::Rsa, QSsl::Pem, QSsl::PrivateKey);\n            _privateKey = privateKey;\n\n            qCInfo(lcCse()) << \"Private key: \" << _privateKey;\n\n            if (!_privateKey.isNull()) {\n                writePrivateKey(account);\n                writeCertificate(account);\n                writeMnemonic(account);\n                break;\n            }\n        } else {\n            _mnemonic = QString();\n            _privateKey = QByteArray();\n            qCInfo(lcCse()) << \"Cancelled\";\n            break;\n        }\n    }\n\n    emit initializationFinished();\n}",
  "abstract_func_before": "void ClientSideEncryption::decryptPrivateKey(const AccountPtr &VAR_0, const QByteArray &VAR_1) {\n    QString VAR_2 = tr(\"Please enter your end to end encryption passphrase:<br>\"\n                     \"<br>\"\n                     \"User: %2<br>\"\n                     \"Account: %3<br>\")\n                      .arg(Utility::escape(VAR_0->credentials()->user()),\n                           Utility::escape(VAR_0->displayName()));\n\n    QInputDialog VAR_3;\n    VAR_3.setWindowTitle(tr(\"Enter E2E passphrase\"));\n    VAR_3.setLabelText(VAR_2);\n    VAR_3.setTextEchoMode(QLineEdit::Normal);\n\n    QString VAR_4;\n\n    while(true) {\n        if (!VAR_4.isEmpty()) {\n            VAR_3.setTextValue(VAR_4);\n        }\n        bool VAR_5 = VAR_3.exec();\n        if (VAR_5) {\n            qCInfo(lcCse()) << \"Got mnemonic:\" << VAR_3.textValue();\n            VAR_4 = VAR_3.textValue();\n\n            VAR_6 = VAR_4;\n            QString VAR_7 = VAR_4.split(\" \").join(QString()).toLower();\n            qCInfo(lcCse()) << \"mnemonic:\" << VAR_7;\n\n            /* COMMENT_0 */\n            const auto VAR_8 = EncryptionHelper::extractPrivateKeySalt(VAR_1);\n\n            auto VAR_9 = EncryptionHelper::generatePassword(VAR_7, VAR_8);\n            qCInfo(lcCse()) << \"Generated key:\" << VAR_9;\n\n            QByteArray VAR_10 = EncryptionHelper::decryptPrivateKey(VAR_9, VAR_1);\n            /* COMMENT_1 */\n            VAR_11 = VAR_10;\n\n            qCInfo(lcCse()) << \"Private key: \" << VAR_11;\n\n            if (!VAR_11.isNull()) {\n                writePrivateKey(VAR_0);\n                writeCertificate(VAR_0);\n                writeMnemonic(VAR_0);\n                break;\n            }\n        } else {\n            VAR_6 = QString();\n            VAR_11 = QByteArray();\n            qCInfo(lcCse()) << \"Cancelled\";\n            break;\n        }\n    }\n\n    emit initializationFinished();\n}",
  "func_graph_path_before": "nextcloud/desktop/7fb09a81632de6066e55def20308d6e61cadbc48/clientsideencryption.cpp/vul/before/0.json",
  "func": "void ClientSideEncryption::decryptPrivateKey(const AccountPtr &account, const QByteArray &key) {\n    QString msg = tr(\"Please enter your end to end encryption passphrase:<br>\"\n                     \"<br>\"\n                     \"User: %2<br>\"\n                     \"Account: %3<br>\")\n                      .arg(Utility::escape(account->credentials()->user()),\n                           Utility::escape(account->displayName()));\n\n    QInputDialog dialog;\n    dialog.setWindowTitle(tr(\"Enter E2E passphrase\"));\n    dialog.setLabelText(msg);\n    dialog.setTextEchoMode(QLineEdit::Normal);\n\n    QString prev;\n\n    while(true) {\n        if (!prev.isEmpty()) {\n            dialog.setTextValue(prev);\n        }\n        bool ok = dialog.exec();\n        if (ok) {\n            qCInfo(lcCse()) << \"Got mnemonic:\" << dialog.textValue();\n            prev = dialog.textValue();\n\n            _mnemonic = prev;\n            QString mnemonic = prev.split(\" \").join(QString()).toLower();\n            qCInfo(lcCse()) << \"mnemonic:\" << mnemonic;\n\n            // split off salt\n            const auto salt = EncryptionHelper::extractPrivateKeySalt(key);\n\n            auto pass = EncryptionHelper::generatePassword(mnemonic, salt);\n            qCInfo(lcCse()) << \"Generated key:\" << pass;\n\n            QByteArray privateKey = EncryptionHelper::decryptPrivateKey(pass, key);\n            //_privateKey = QSslKey(privateKey, QSsl::Rsa, QSsl::Pem, QSsl::PrivateKey);\n            _privateKey = privateKey;\n\n            qCInfo(lcCse()) << \"Private key: \" << _privateKey;\n\n            if (!_privateKey.isNull() && checkPublicKeyValidity(account)) {\n                writePrivateKey(account);\n                writeCertificate(account);\n                writeMnemonic(account);\n                break;\n            }\n        } else {\n            _mnemonic = QString();\n            _privateKey = QByteArray();\n            qCInfo(lcCse()) << \"Cancelled\";\n            break;\n        }\n    }\n\n    emit initializationFinished();\n}",
  "abstract_func": "void ClientSideEncryption::decryptPrivateKey(const AccountPtr &VAR_0, const QByteArray &VAR_1) {\n    QString VAR_2 = tr(\"Please enter your end to end encryption passphrase:<br>\"\n                     \"<br>\"\n                     \"User: %2<br>\"\n                     \"Account: %3<br>\")\n                      .arg(Utility::escape(VAR_0->credentials()->user()),\n                           Utility::escape(VAR_0->displayName()));\n\n    QInputDialog VAR_3;\n    VAR_3.setWindowTitle(tr(\"Enter E2E passphrase\"));\n    VAR_3.setLabelText(VAR_2);\n    VAR_3.setTextEchoMode(QLineEdit::Normal);\n\n    QString VAR_4;\n\n    while(true) {\n        if (!VAR_4.isEmpty()) {\n            VAR_3.setTextValue(VAR_4);\n        }\n        bool VAR_5 = VAR_3.exec();\n        if (VAR_5) {\n            qCInfo(lcCse()) << \"Got mnemonic:\" << VAR_3.textValue();\n            VAR_4 = VAR_3.textValue();\n\n            VAR_6 = VAR_4;\n            QString VAR_7 = VAR_4.split(\" \").join(QString()).toLower();\n            qCInfo(lcCse()) << \"mnemonic:\" << VAR_7;\n\n            /* COMMENT_0 */\n            const auto VAR_8 = EncryptionHelper::extractPrivateKeySalt(VAR_1);\n\n            auto VAR_9 = EncryptionHelper::generatePassword(VAR_7, VAR_8);\n            qCInfo(lcCse()) << \"Generated key:\" << VAR_9;\n\n            QByteArray VAR_10 = EncryptionHelper::decryptPrivateKey(VAR_9, VAR_1);\n            /* COMMENT_1 */\n            VAR_11 = VAR_10;\n\n            qCInfo(lcCse()) << \"Private key: \" << VAR_11;\n\n            if (!VAR_11.isNull() && checkPublicKeyValidity(VAR_0)) {\n                writePrivateKey(VAR_0);\n                writeCertificate(VAR_0);\n                writeMnemonic(VAR_0);\n                break;\n            }\n        } else {\n            VAR_6 = QString();\n            VAR_11 = QByteArray();\n            qCInfo(lcCse()) << \"Cancelled\";\n            break;\n        }\n    }\n\n    emit initializationFinished();\n}",
  "func_graph_path": "nextcloud/desktop/7fb09a81632de6066e55def20308d6e61cadbc48/clientsideencryption.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -38,7 +38,7 @@\n \n             qCInfo(lcCse()) << \"Private key: \" << _privateKey;\n \n-            if (!_privateKey.isNull()) {\n+            if (!_privateKey.isNull() && checkPublicKeyValidity(account)) {\n                 writePrivateKey(account);\n                 writeCertificate(account);\n                 writeMnemonic(account);",
  "diff_line_info": {
    "deleted_lines": [
      "            if (!_privateKey.isNull()) {"
    ],
    "added_lines": [
      "            if (!_privateKey.isNull() && checkPublicKeyValidity(account)) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/nextcloud/desktop/pull/3338",
  "description": {
    "pr_info": {
      "title": "check e2ee public key against private one",
      "number": 3338
    },
    "comment": [
      "should ensure we have matching private/public keys\r\n\r\nSigned-off-by: Matthieu Gallien <matthieu_gallien@yahoo.fr>\r\n\r\n<!-- \r\nThanks for opening a pull request on the Nextcloud desktop client.\r\n\r\nInstead of a Contributor License Agreement (CLA) we use a Developer Certificate of Origin (DCO).\r\nhttps://en.wikipedia.org/wiki/Developer_Certificate_of_Origin\r\n\r\nTo accept that DCO, please make sure that you add a line like\r\nSigned-off-by: Random Developer <random@developer.example.org>\r\nat the end of each commit message.\r\n\r\nThis Signed-off-by trailer can be added automatically by git if you pass --signoff or -s to git commit.\r\nSee also:\r\nhttps://git-scm.com/docs/git-commit#Documentation/git-commit.txt---no-signoff\r\n-->\r\n",
      "/rebase",
      "/rebase",
      "/rebase",
      "AppImage file: [Nextcloud-PR-3338-7fb09a81632de6066e55def20308d6e61cadbc48-x86_64.AppImage](https://github.com/nextcloud-desktop-bot/ci-builds/releases/download/PR-3338/Nextcloud-PR-3338-7fb09a81632de6066e55def20308d6e61cadbc48-x86_64.AppImage) <br/><br/>To test this change/fix you can simply download above AppImage file and test it. <br/><br/>Please make sure to quit your existing Nextcloud app and backup your data. "
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.95"
}