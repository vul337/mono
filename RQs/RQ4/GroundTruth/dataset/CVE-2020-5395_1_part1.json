{
  "cve_id": "CVE-2020-5395",
  "cwe_ids": [
    "CWE-416"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "fontforge",
  "commit_msg": "Fix for #4084 Use-after-free (heap) in the SFD_GetFontMetaData() function\nFix for #4086 NULL pointer dereference in the SFDGetSpiros() function\nFix for #4088 NULL pointer dereference in the SFD_AssignLookups() function\nAdd empty sf->fontname string if it isn't set, fixing #4089 #4090 and many\n  other potential issues (many downstream calls to strlen() on the value).",
  "commit_hash": "8da6d56bf7af2d25f779e52edef61b2fd4557b3c",
  "git_url": "https://github.com/fontforge/fontforge/commit/8da6d56bf7af2d25f779e52edef61b2fd4557b3c",
  "file_path": "fontforge/sfd1.c",
  "func_name": "SFD_AssignLookups",
  "func_before": "void SFD_AssignLookups(SplineFont1 *sf) {\n    PST1 *pst, *pst2;\n    int isv;\n    KernPair1 *kp, *kp2;\n    KernClass1 *kc, *kc2;\n    FPST1 *fpst;\n    ASM1 *sm;\n    AnchorClass1 *ac, *ac2;\n    int gid, gid2, cnt, i, k, isgpos;\n    SplineFont1 *subsf;\n    SplineChar *sc, *sc2;\n    OTLookup *otl, **all;\n    struct lookup_subtable *sub;\n\n    /* Fix up some gunk from really old versions of the sfd format */\n    SFDCleanupAnchorClasses(&sf->sf);\n    if ( sf->sf.uni_interp==ui_unset )\n\tsf->sf.uni_interp = interp_from_encoding(sf->sf.map->enc,ui_none);\n\n    /* Fixup for an old bug */\n    if ( sf->sf.pfminfo.os2_winascent < sf->sf.ascent/4 && !sf->sf.pfminfo.winascent_add ) {\n\tsf->sf.pfminfo.winascent_add = true;\n\tsf->sf.pfminfo.os2_winascent = 0;\n\tsf->sf.pfminfo.windescent_add = true;\n\tsf->sf.pfminfo.os2_windescent = 0;\n    }\n\n    /* First handle the PSTs, no complications here */\n    k=0;\n    do {\n\tsubsf = sf->sf.subfontcnt==0 ? sf : (SplineFont1 *) (sf->sf.subfonts[k]);\n\tfor ( gid=0; gid<subsf->sf.glyphcnt; ++gid ) if ( (sc=subsf->sf.glyphs[gid])!=NULL ) {\n\t    for ( pst = (PST1 *) (sc->possub); pst!=NULL; pst = (PST1*) (pst->pst.next) ) {\n\t\tif ( pst->pst.type == pst_lcaret || pst->pst.subtable!=NULL )\n\t    continue;\t\t/* Nothing to do, or already done */\n\t\totl = CreateLookup(sf,pst->tag,pst->script_lang_index,pst->flags,pst->pst.type);\n\t\tsub = CreateSubtable(otl,sf);\n\t\t/* There might be another PST with the same flags on this glyph */\n\t\t/* And we must fixup the current pst */\n\t\tfor ( pst2=pst ; pst2!=NULL; pst2 = (PST1 *) (pst2->pst.next) ) {\n\t\t    if ( pst2->tag==pst->tag &&\n\t\t\t    pst2->script_lang_index==pst->script_lang_index &&\n\t\t\t    pst2->flags==pst->flags &&\n\t\t\t    pst2->pst.type==pst->pst.type )\n\t\t\tpst2->pst.subtable = sub;\n\t\t}\n\t\tfor ( gid2=gid+1; gid2<subsf->sf.glyphcnt; ++gid2 ) if ( (sc2=subsf->sf.glyphs[gid2])!=NULL ) {\n\t\t    for ( pst2 = (PST1 *) (sc2->possub); pst2!=NULL; pst2 = (PST1 *) (pst2->pst.next) ) {\n\t\t\tif ( pst2->tag==pst->tag &&\n\t\t\t\tpst2->script_lang_index==pst->script_lang_index &&\n\t\t\t\tpst2->flags==pst->flags &&\n\t\t\t\tpst2->pst.type==pst->pst.type )\n\t\t\t    pst2->pst.subtable = sub;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\t++k;\n    } while ( k<sf->sf.subfontcnt );\n\n\t/* Now kerns. May need to merge kernclasses to kernpair lookups (different subtables, of course */\n    for ( isv=0; isv<2; ++isv ) {\n\tk=0;\n\tdo {\n\t    subsf = sf->sf.subfontcnt==0 ? sf : (SplineFont1 *) (sf->sf.subfonts[k]);\n\t    for ( gid=0; gid<subsf->sf.glyphcnt; ++gid ) if ( (sc=subsf->sf.glyphs[gid])!=NULL ) {\n\t\tfor ( kp = (KernPair1 *) (isv ? sc->vkerns : sc->kerns); kp!=NULL; kp = (KernPair1 *) (kp->kp.next) ) {\n\t\t    if ( kp->kp.subtable!=NULL )\n\t\tcontinue;\t\t/* already done */\n\t\t    otl = CreateLookup(sf,isv ? CHR('v','k','r','n') : CHR('k','e','r','n'),\n\t\t\t    kp->sli,kp->flags,pst_pair);\n\t\t    sub = CreateSubtable(otl,sf);\n\t\t    /* There might be another kp with the same flags on this glyph */\n\t\t    /* And we must fixup the current kp */\n\t\t    for ( kp2=kp ; kp2!=NULL; kp2 = (KernPair1 *) (kp2->kp.next) ) {\n\t\t\tif ( kp2->sli==kp->sli && kp2->flags==kp->flags )\n\t\t\t    kp2->kp.subtable = sub;\n\t\t    }\n\t\t    for ( gid2=gid+1; gid2<subsf->sf.glyphcnt; ++gid2 ) if ( (sc2=subsf->sf.glyphs[gid2])!=NULL ) {\n\t\t\tfor ( kp2 = (KernPair1 *) (isv ? sc2->vkerns : sc2->kerns); kp2!=NULL; kp2 = (KernPair1 *) (kp2->kp.next) ) {\n\t\t\t    if ( kp2->sli==kp->sli && kp2->flags==kp->flags )\n\t\t\t\tkp2->kp.subtable = sub;\n\t\t\t}\n\t\t    }\n\t\t    /* And there might be a kerning class... */\n\t\t    for ( kc=(KernClass1 *) (isv ? sf->sf.vkerns : sf->sf.kerns); kc!=NULL;\n\t\t\t    kc = (KernClass1 *) (kc->kc.next) ) {\n\t\t\tif ( kc->sli == kp->sli && kc->flags == kp->flags && kc->kc.subtable==NULL) {\n\t\t\t    sub = CreateSubtable(otl,sf);\n\t\t\t    sub->per_glyph_pst_or_kern = false;\n\t\t\t    sub->kc = &kc->kc;\n\t\t\t    kc->kc.subtable = sub;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    ++k;\n\t} while ( k<sf->sf.subfontcnt );\n\t/* Or there might be a kerning class all by its lonesome */\n\tfor ( kc=(KernClass1 *) (isv ? sf->sf.vkerns : sf->sf.kerns); kc!=NULL;\n\t\tkc = (KernClass1 *) (kc->kc.next) ) {\n\t    if ( kc->kc.subtable==NULL) {\n\t\totl = CreateLookup(sf,isv ? CHR('v','k','r','n') : CHR('k','e','r','n'),\n\t\t\tkc->sli,kc->flags,pst_pair);\n\t\tfor ( kc2=kc; kc2!=NULL; kc2=(KernClass1 *) (kc2->kc.next) ) {\n\t\t    if ( kc->sli == kc2->sli && kc->flags == kc2->flags && kc2->kc.subtable==NULL) {\n\t\t\tsub = CreateSubtable(otl,sf);\n\t\t\tsub->per_glyph_pst_or_kern = false;\n\t\t\tsub->kc = &kc2->kc;\n\t\t\tkc2->kc.subtable = sub;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n\n    /* Every FPST and ASM lives in its own lookup with one subtable */\n    /* But the old format refered to nested lookups by tag, and now we refer */\n    /*  to the lookup itself, so fix that up */\n    for ( fpst=(FPST1 *) sf->sf.possub; fpst!=NULL; fpst=((FPST1 *) fpst->fpst.next) ) {\n\totl = CreateLookup(sf,fpst->tag, fpst->script_lang_index,\n\t\tfpst->flags,fpst->fpst.type);\n\tsub = CreateSubtable(otl,sf);\n\tsub->per_glyph_pst_or_kern = false;\n\tsub->fpst = &fpst->fpst;\n\tfpst->fpst.subtable = sub;\n\tFPSTReplaceTagsWithLookups(&fpst->fpst,sf);\n    }\n    for ( sm=(ASM1 *) sf->sf.sm; sm!=NULL; sm=((ASM1 *) sm->sm.next) ) {\n\totl = CreateMacLookup(sf,sm);\n\tsub = CreateSubtable(otl,sf);\n\tsub->per_glyph_pst_or_kern = false;\n\tsub->sm = &sm->sm;\n\tsm->sm.subtable = sub;\n\tif ( sm->sm.type==asm_context )\n\t    ASMReplaceTagsWithLookups(&sm->sm,sf);\n    }\n\n    /* We retained the old nested feature tags so we could do the above conversion */\n    /*  of tag to lookup. Get rid of them now */\n    for ( isgpos=0; isgpos<2; ++isgpos ) {\n\tfor ( otl = isgpos ? sf->sf.gpos_lookups : sf->sf.gsub_lookups ;\n\t\totl != NULL; otl=otl->next ) {\n\t    if ( otl->features!=NULL && otl->features->scripts==NULL ) {\n\t\tchunkfree(otl->features,sizeof(FeatureScriptLangList));\n\t\totl->features = NULL;\n\t    }\n\t}\n    }\n\n    /* Anchor classes are complicated, because I foolishly failed to distinguish */\n    /*  between mark to base and mark to ligature classes. So one AC might have */\n    /*  both. If so we need to turn it into two ACs, and have separate lookups */\n    /*  for each */\n    for ( ac=(AnchorClass1 *) (sf->sf.anchor); ac!=NULL; ac=(AnchorClass1 *) ac->ac.next ) {\n\tACHasBaseLig(sf,ac);\n\tif ( ac->has_ligatures && !ac->has_bases )\n\t    ac->ac.type = act_mklg;\n\telse if ( ac->has_ligatures && ac->has_bases )\n\t    ACDisassociateLigatures(sf,ac);\n    }\n    for ( ac=(AnchorClass1 *) (sf->sf.anchor); ac!=NULL; ac=(AnchorClass1 *) ac->ac.next ) {\n\tif ( ac->ac.subtable==NULL ) {\n\t    otl = CreateACLookup(sf,ac);\n\t    sub = CreateSubtable(otl,sf);\n\t    for ( ac2=ac; ac2!=NULL; ac2 = (AnchorClass1 *) ac2->ac.next ) {\n\t\tif ( ac2->feature_tag == ac->feature_tag &&\n\t\t\tac2->script_lang_index == ac->script_lang_index &&\n\t\t\tac2->flags == ac->flags &&\n\t\t\tac2->ac.type == ac->ac.type &&\n\t\t\tac2->merge_with == ac->merge_with )\n\t\t    ac2->ac.subtable = sub;\n\t    }\n\t}\n    }\n\n    /* Now I want to order the gsub lookups. I shan't bother with the gpos */\n    /*  lookups because I didn't before */\n    for ( otl=sf->sf.gsub_lookups, cnt=0; otl!=NULL; otl=otl->next, ++cnt );\n    if ( cnt!=0 ) {\n\tall = malloc(cnt*sizeof(OTLookup *));\n\tfor ( otl=sf->sf.gsub_lookups, cnt=0; otl!=NULL; otl=otl->next, ++cnt ) {\n\t    all[cnt] = otl;\n\t    otl->lookup_index = GSubOrder(sf,otl->features);\n\t}\n\tqsort(all,cnt,sizeof(OTLookup *),order_lookups);\n\tsf->sf.gsub_lookups = all[0];\n\tfor ( i=1; i<cnt; ++i )\n\t    all[i-1]->next = all[i];\n\tall[cnt-1]->next = NULL;\n\tfree( all );\n    }\n\n    for ( isgpos=0; isgpos<2; ++isgpos ) {\n\tfor ( otl = isgpos ? sf->sf.gpos_lookups : sf->sf.gsub_lookups , cnt=0;\n\t\totl!=NULL; otl = otl->next ) {\n\t    otl->lookup_index = cnt++;\n\t    NameOTLookup(otl,&sf->sf);\n\t}\n    }\n}",
  "abstract_func_before": "void SFD_AssignLookups(SplineFont1 *VAR_0) {\n    PST1 *VAR_1, *VAR_2;\n    int VAR_3;\n    KernPair1 *VAR_4, *VAR_5;\n    KernClass1 *VAR_6, *VAR_7;\n    FPST1 *VAR_8;\n    ASM1 *VAR_9;\n    AnchorClass1 *VAR_10, *VAR_11;\n    int VAR_12, VAR_13, VAR_14, VAR_15, VAR_16, VAR_17;\n    SplineFont1 *VAR_18;\n    SplineChar *VAR_19, *VAR_20;\n    OTLookup *VAR_21, **VAR_22;\n    struct lookup_subtable *VAR_23;\n\n    /* COMMENT_0 */\n    SFDCleanupAnchorClasses(&VAR_0->sf);\n    if ( VAR_0->sf.uni_interp==VAR_24 )\n\tVAR_0->sf.uni_interp = interp_from_encoding(VAR_0->sf.map->enc,VAR_25);\n\n    /* COMMENT_1 */\n    if ( VAR_0->sf.pfminfo.os2_winascent < VAR_0->sf.ascent/4 && !VAR_0->sf.pfminfo.winascent_add ) {\n\tVAR_0->sf.pfminfo.winascent_add = true;\n\tVAR_0->sf.pfminfo.os2_winascent = 0;\n\tVAR_0->sf.pfminfo.windescent_add = true;\n\tVAR_0->sf.pfminfo.os2_windescent = 0;\n    }\n\n    /* COMMENT_2 */\n    VAR_16=0;\n    do {\n\tVAR_18 = VAR_0->sf.subfontcnt==0 ? VAR_0 : (SplineFont1 *) (VAR_0->sf.subfonts[VAR_16]);\n\tfor ( VAR_12=0; VAR_12<VAR_18->sf.glyphcnt; ++VAR_12 ) if ( (VAR_19=VAR_18->sf.glyphs[VAR_12])!=NULL ) {\n\t    for ( VAR_1 = (PST1 *) (VAR_19->possub); VAR_1!=NULL; VAR_1 = (PST1*) (VAR_1->pst.next) ) {\n\t\tif ( VAR_1->pst.type == VAR_26 || VAR_1->pst.subtable!=NULL )\n\t    continue;\t\t/* COMMENT_3 */\n\t\tVAR_21 = CreateLookup(VAR_0,VAR_1->tag,VAR_1->script_lang_index,VAR_1->flags,VAR_1->pst.type);\n\t\tVAR_23 = CreateSubtable(VAR_21,VAR_0);\n\t\t/* COMMENT_4 */\n\t\t/* COMMENT_5 */\n\t\tfor ( VAR_2=VAR_1 ; VAR_2!=NULL; VAR_2 = (PST1 *) (VAR_2->pst.next) ) {\n\t\t    if ( VAR_2->tag==VAR_1->tag &&\n\t\t\t    VAR_2->script_lang_index==VAR_1->script_lang_index &&\n\t\t\t    VAR_2->flags==VAR_1->flags &&\n\t\t\t    VAR_2->pst.type==VAR_1->pst.type )\n\t\t\tVAR_2->pst.subtable = VAR_23;\n\t\t}\n\t\tfor ( VAR_13=VAR_12+1; VAR_13<VAR_18->sf.glyphcnt; ++VAR_13 ) if ( (VAR_20=VAR_18->sf.glyphs[VAR_13])!=NULL ) {\n\t\t    for ( VAR_2 = (PST1 *) (VAR_20->possub); VAR_2!=NULL; VAR_2 = (PST1 *) (VAR_2->pst.next) ) {\n\t\t\tif ( VAR_2->tag==VAR_1->tag &&\n\t\t\t\tVAR_2->script_lang_index==VAR_1->script_lang_index &&\n\t\t\t\tVAR_2->flags==VAR_1->flags &&\n\t\t\t\tVAR_2->pst.type==VAR_1->pst.type )\n\t\t\t    VAR_2->pst.subtable = VAR_23;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\t++VAR_16;\n    } while ( VAR_16<VAR_0->sf.subfontcnt );\n\n\t/* COMMENT_6 */\n    for ( VAR_3=0; VAR_3<2; ++VAR_3 ) {\n\tVAR_16=0;\n\tdo {\n\t    VAR_18 = VAR_0->sf.subfontcnt==0 ? VAR_0 : (SplineFont1 *) (VAR_0->sf.subfonts[VAR_16]);\n\t    for ( VAR_12=0; VAR_12<VAR_18->sf.glyphcnt; ++VAR_12 ) if ( (VAR_19=VAR_18->sf.glyphs[VAR_12])!=NULL ) {\n\t\tfor ( VAR_4 = (KernPair1 *) (VAR_3 ? VAR_19->vkerns : VAR_19->kerns); VAR_4!=NULL; VAR_4 = (KernPair1 *) (VAR_4->kp.next) ) {\n\t\t    if ( VAR_4->kp.subtable!=NULL )\n\t\tcontinue;\t\t/* COMMENT_7 */\n\t\t    VAR_21 = CreateLookup(VAR_0,VAR_3 ? CHR('v','k','r','n') : CHR('k','e','r','n'),\n\t\t\t    VAR_4->sli,VAR_4->flags,VAR_27);\n\t\t    VAR_23 = CreateSubtable(VAR_21,VAR_0);\n\t\t    /* COMMENT_8 */\n\t\t    /* COMMENT_9 */\n\t\t    for ( VAR_5=VAR_4 ; VAR_5!=NULL; VAR_5 = (KernPair1 *) (VAR_5->kp.next) ) {\n\t\t\tif ( VAR_5->sli==VAR_4->sli && VAR_5->flags==VAR_4->flags )\n\t\t\t    VAR_5->kp.subtable = VAR_23;\n\t\t    }\n\t\t    for ( VAR_13=VAR_12+1; VAR_13<VAR_18->sf.glyphcnt; ++VAR_13 ) if ( (VAR_20=VAR_18->sf.glyphs[VAR_13])!=NULL ) {\n\t\t\tfor ( VAR_5 = (KernPair1 *) (VAR_3 ? VAR_20->vkerns : VAR_20->kerns); VAR_5!=NULL; VAR_5 = (KernPair1 *) (VAR_5->kp.next) ) {\n\t\t\t    if ( VAR_5->sli==VAR_4->sli && VAR_5->flags==VAR_4->flags )\n\t\t\t\tVAR_5->kp.subtable = VAR_23;\n\t\t\t}\n\t\t    }\n\t\t    /* COMMENT_10 */\n\t\t    for ( VAR_6=(KernClass1 *) (VAR_3 ? VAR_0->sf.vkerns : VAR_0->sf.kerns); VAR_6!=NULL;\n\t\t\t    VAR_6 = (KernClass1 *) (VAR_6->kc.next) ) {\n\t\t\tif ( VAR_6->sli == VAR_4->sli && VAR_6->flags == VAR_4->flags && VAR_6->kc.subtable==NULL) {\n\t\t\t    VAR_23 = CreateSubtable(VAR_21,VAR_0);\n\t\t\t    VAR_23->per_glyph_pst_or_kern = false;\n\t\t\t    VAR_23->kc = &VAR_6->kc;\n\t\t\t    VAR_6->kc.subtable = VAR_23;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    ++VAR_16;\n\t} while ( VAR_16<VAR_0->sf.subfontcnt );\n\t/* COMMENT_11 */\n\tfor ( VAR_6=(KernClass1 *) (VAR_3 ? VAR_0->sf.vkerns : VAR_0->sf.kerns); VAR_6!=NULL;\n\t\tVAR_6 = (KernClass1 *) (VAR_6->kc.next) ) {\n\t    if ( VAR_6->kc.subtable==NULL) {\n\t\tVAR_21 = CreateLookup(VAR_0,VAR_3 ? CHR('v','k','r','n') : CHR('k','e','r','n'),\n\t\t\tVAR_6->sli,VAR_6->flags,VAR_27);\n\t\tfor ( VAR_7=VAR_6; VAR_7!=NULL; VAR_7=(KernClass1 *) (VAR_7->kc.next) ) {\n\t\t    if ( VAR_6->sli == VAR_7->sli && VAR_6->flags == VAR_7->flags && VAR_7->kc.subtable==NULL) {\n\t\t\tVAR_23 = CreateSubtable(VAR_21,VAR_0);\n\t\t\tVAR_23->per_glyph_pst_or_kern = false;\n\t\t\tVAR_23->kc = &VAR_7->kc;\n\t\t\tVAR_7->kc.subtable = VAR_23;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n\n    /* COMMENT_12 */\n    /* COMMENT_13 */\n    /* COMMENT_14 */\n    for ( VAR_8=(FPST1 *) VAR_0->sf.possub; VAR_8!=NULL; VAR_8=((FPST1 *) VAR_8->fpst.next) ) {\n\tVAR_21 = CreateLookup(VAR_0,VAR_8->tag, VAR_8->script_lang_index,\n\t\tVAR_8->flags,VAR_8->fpst.type);\n\tVAR_23 = CreateSubtable(VAR_21,VAR_0);\n\tVAR_23->per_glyph_pst_or_kern = false;\n\tVAR_23->fpst = &VAR_8->fpst;\n\tVAR_8->fpst.subtable = VAR_23;\n\tFPSTReplaceTagsWithLookups(&VAR_8->fpst,VAR_0);\n    }\n    for ( VAR_9=(ASM1 *) VAR_0->sf.sm; VAR_9!=NULL; VAR_9=((ASM1 *) VAR_9->sm.next) ) {\n\tVAR_21 = CreateMacLookup(VAR_0,VAR_9);\n\tVAR_23 = CreateSubtable(VAR_21,VAR_0);\n\tVAR_23->per_glyph_pst_or_kern = false;\n\tVAR_23->sm = &VAR_9->sm;\n\tVAR_9->sm.subtable = VAR_23;\n\tif ( VAR_9->sm.type==VAR_28 )\n\t    ASMReplaceTagsWithLookups(&VAR_9->sm,VAR_0);\n    }\n\n    /* COMMENT_15 */\n    /* COMMENT_16 */\n    for ( VAR_17=0; VAR_17<2; ++VAR_17 ) {\n\tfor ( VAR_21 = VAR_17 ? VAR_0->sf.gpos_lookups : VAR_0->sf.gsub_lookups ;\n\t\tVAR_21 != NULL; VAR_21=VAR_21->next ) {\n\t    if ( VAR_21->features!=NULL && VAR_21->features->scripts==NULL ) {\n\t\tchunkfree(VAR_21->features,sizeof(VAR_29));\n\t\tVAR_21->features = NULL;\n\t    }\n\t}\n    }\n\n    /* COMMENT_17 */\n    /* COMMENT_18 */\n    /* COMMENT_19 */\n    /* COMMENT_20 */\n    for ( VAR_10=(AnchorClass1 *) (VAR_0->sf.anchor); VAR_10!=NULL; VAR_10=(AnchorClass1 *) VAR_10->ac.next ) {\n\tACHasBaseLig(VAR_0,VAR_10);\n\tif ( VAR_10->has_ligatures && !VAR_10->has_bases )\n\t    VAR_10->ac.type = VAR_30;\n\telse if ( VAR_10->has_ligatures && VAR_10->has_bases )\n\t    ACDisassociateLigatures(VAR_0,VAR_10);\n    }\n    for ( VAR_10=(AnchorClass1 *) (VAR_0->sf.anchor); VAR_10!=NULL; VAR_10=(AnchorClass1 *) VAR_10->ac.next ) {\n\tif ( VAR_10->ac.subtable==NULL ) {\n\t    VAR_21 = CreateACLookup(VAR_0,VAR_10);\n\t    VAR_23 = CreateSubtable(VAR_21,VAR_0);\n\t    for ( VAR_11=VAR_10; VAR_11!=NULL; VAR_11 = (AnchorClass1 *) VAR_11->ac.next ) {\n\t\tif ( VAR_11->feature_tag == VAR_10->feature_tag &&\n\t\t\tVAR_11->script_lang_index == VAR_10->script_lang_index &&\n\t\t\tVAR_11->flags == VAR_10->flags &&\n\t\t\tVAR_11->ac.type == VAR_10->ac.type &&\n\t\t\tVAR_11->merge_with == VAR_10->merge_with )\n\t\t    VAR_11->ac.subtable = VAR_23;\n\t    }\n\t}\n    }\n\n    /* COMMENT_21 */\n    /* COMMENT_22 */\n    for ( VAR_21=VAR_0->sf.gsub_lookups, VAR_14=0; VAR_21!=NULL; VAR_21=VAR_21->next, ++VAR_14 );\n    if ( VAR_14!=0 ) {\n\tVAR_22 = malloc(VAR_14*sizeof(OTLookup *));\n\tfor ( VAR_21=VAR_0->sf.gsub_lookups, VAR_14=0; VAR_21!=NULL; VAR_21=VAR_21->next, ++VAR_14 ) {\n\t    VAR_22[VAR_14] = VAR_21;\n\t    VAR_21->lookup_index = GSubOrder(VAR_0,VAR_21->features);\n\t}\n\tqsort(VAR_22,VAR_14,sizeof(OTLookup *),VAR_31);\n\tVAR_0->sf.gsub_lookups = VAR_22[0];\n\tfor ( VAR_15=1; VAR_15<VAR_14; ++VAR_15 )\n\t    VAR_22[VAR_15-1]->next = VAR_22[VAR_15];\n\tVAR_22[VAR_14-1]->next = NULL;\n\tfree( VAR_22 );\n    }\n\n    for ( VAR_17=0; VAR_17<2; ++VAR_17 ) {\n\tfor ( VAR_21 = VAR_17 ? VAR_0->sf.gpos_lookups : VAR_0->sf.gsub_lookups , VAR_14=0;\n\t\tVAR_21!=NULL; VAR_21 = VAR_21->next ) {\n\t    VAR_21->lookup_index = VAR_14++;\n\t    NameOTLookup(VAR_21,&VAR_0->sf);\n\t}\n    }\n}",
  "func_graph_path_before": "fontforge/8da6d56bf7af2d25f779e52edef61b2fd4557b3c/sfd1.c/vul/before/0.json",
  "func": "void SFD_AssignLookups(SplineFont1 *sf) {\n    PST1 *pst, *pst2;\n    int isv;\n    KernPair1 *kp, *kp2;\n    KernClass1 *kc, *kc2;\n    FPST1 *fpst;\n    ASM1 *sm;\n    AnchorClass1 *ac, *ac2;\n    int gid, gid2, cnt, i, k, isgpos;\n    SplineFont1 *subsf;\n    SplineChar *sc, *sc2;\n    OTLookup *otl, **all;\n    struct lookup_subtable *sub;\n\n    /* Fix up some gunk from really old versions of the sfd format */\n    SFDCleanupAnchorClasses(&sf->sf);\n    if ( sf->sf.uni_interp==ui_unset && sf->sf.map!=NULL )\n\tsf->sf.uni_interp = interp_from_encoding(sf->sf.map->enc,ui_none);\n\n    /* Fixup for an old bug */\n    if ( sf->sf.pfminfo.os2_winascent < sf->sf.ascent/4 && !sf->sf.pfminfo.winascent_add ) {\n\tsf->sf.pfminfo.winascent_add = true;\n\tsf->sf.pfminfo.os2_winascent = 0;\n\tsf->sf.pfminfo.windescent_add = true;\n\tsf->sf.pfminfo.os2_windescent = 0;\n    }\n\n    /* First handle the PSTs, no complications here */\n    k=0;\n    do {\n\tsubsf = sf->sf.subfontcnt==0 ? sf : (SplineFont1 *) (sf->sf.subfonts[k]);\n\tfor ( gid=0; gid<subsf->sf.glyphcnt; ++gid ) if ( (sc=subsf->sf.glyphs[gid])!=NULL ) {\n\t    for ( pst = (PST1 *) (sc->possub); pst!=NULL; pst = (PST1*) (pst->pst.next) ) {\n\t\tif ( pst->pst.type == pst_lcaret || pst->pst.subtable!=NULL )\n\t    continue;\t\t/* Nothing to do, or already done */\n\t\totl = CreateLookup(sf,pst->tag,pst->script_lang_index,pst->flags,pst->pst.type);\n\t\tsub = CreateSubtable(otl,sf);\n\t\t/* There might be another PST with the same flags on this glyph */\n\t\t/* And we must fixup the current pst */\n\t\tfor ( pst2=pst ; pst2!=NULL; pst2 = (PST1 *) (pst2->pst.next) ) {\n\t\t    if ( pst2->tag==pst->tag &&\n\t\t\t    pst2->script_lang_index==pst->script_lang_index &&\n\t\t\t    pst2->flags==pst->flags &&\n\t\t\t    pst2->pst.type==pst->pst.type )\n\t\t\tpst2->pst.subtable = sub;\n\t\t}\n\t\tfor ( gid2=gid+1; gid2<subsf->sf.glyphcnt; ++gid2 ) if ( (sc2=subsf->sf.glyphs[gid2])!=NULL ) {\n\t\t    for ( pst2 = (PST1 *) (sc2->possub); pst2!=NULL; pst2 = (PST1 *) (pst2->pst.next) ) {\n\t\t\tif ( pst2->tag==pst->tag &&\n\t\t\t\tpst2->script_lang_index==pst->script_lang_index &&\n\t\t\t\tpst2->flags==pst->flags &&\n\t\t\t\tpst2->pst.type==pst->pst.type )\n\t\t\t    pst2->pst.subtable = sub;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\t++k;\n    } while ( k<sf->sf.subfontcnt );\n\n\t/* Now kerns. May need to merge kernclasses to kernpair lookups (different subtables, of course */\n    for ( isv=0; isv<2; ++isv ) {\n\tk=0;\n\tdo {\n\t    subsf = sf->sf.subfontcnt==0 ? sf : (SplineFont1 *) (sf->sf.subfonts[k]);\n\t    for ( gid=0; gid<subsf->sf.glyphcnt; ++gid ) if ( (sc=subsf->sf.glyphs[gid])!=NULL ) {\n\t\tfor ( kp = (KernPair1 *) (isv ? sc->vkerns : sc->kerns); kp!=NULL; kp = (KernPair1 *) (kp->kp.next) ) {\n\t\t    if ( kp->kp.subtable!=NULL )\n\t\tcontinue;\t\t/* already done */\n\t\t    otl = CreateLookup(sf,isv ? CHR('v','k','r','n') : CHR('k','e','r','n'),\n\t\t\t    kp->sli,kp->flags,pst_pair);\n\t\t    sub = CreateSubtable(otl,sf);\n\t\t    /* There might be another kp with the same flags on this glyph */\n\t\t    /* And we must fixup the current kp */\n\t\t    for ( kp2=kp ; kp2!=NULL; kp2 = (KernPair1 *) (kp2->kp.next) ) {\n\t\t\tif ( kp2->sli==kp->sli && kp2->flags==kp->flags )\n\t\t\t    kp2->kp.subtable = sub;\n\t\t    }\n\t\t    for ( gid2=gid+1; gid2<subsf->sf.glyphcnt; ++gid2 ) if ( (sc2=subsf->sf.glyphs[gid2])!=NULL ) {\n\t\t\tfor ( kp2 = (KernPair1 *) (isv ? sc2->vkerns : sc2->kerns); kp2!=NULL; kp2 = (KernPair1 *) (kp2->kp.next) ) {\n\t\t\t    if ( kp2->sli==kp->sli && kp2->flags==kp->flags )\n\t\t\t\tkp2->kp.subtable = sub;\n\t\t\t}\n\t\t    }\n\t\t    /* And there might be a kerning class... */\n\t\t    for ( kc=(KernClass1 *) (isv ? sf->sf.vkerns : sf->sf.kerns); kc!=NULL;\n\t\t\t    kc = (KernClass1 *) (kc->kc.next) ) {\n\t\t\tif ( kc->sli == kp->sli && kc->flags == kp->flags && kc->kc.subtable==NULL) {\n\t\t\t    sub = CreateSubtable(otl,sf);\n\t\t\t    sub->per_glyph_pst_or_kern = false;\n\t\t\t    sub->kc = &kc->kc;\n\t\t\t    kc->kc.subtable = sub;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    ++k;\n\t} while ( k<sf->sf.subfontcnt );\n\t/* Or there might be a kerning class all by its lonesome */\n\tfor ( kc=(KernClass1 *) (isv ? sf->sf.vkerns : sf->sf.kerns); kc!=NULL;\n\t\tkc = (KernClass1 *) (kc->kc.next) ) {\n\t    if ( kc->kc.subtable==NULL) {\n\t\totl = CreateLookup(sf,isv ? CHR('v','k','r','n') : CHR('k','e','r','n'),\n\t\t\tkc->sli,kc->flags,pst_pair);\n\t\tfor ( kc2=kc; kc2!=NULL; kc2=(KernClass1 *) (kc2->kc.next) ) {\n\t\t    if ( kc->sli == kc2->sli && kc->flags == kc2->flags && kc2->kc.subtable==NULL) {\n\t\t\tsub = CreateSubtable(otl,sf);\n\t\t\tsub->per_glyph_pst_or_kern = false;\n\t\t\tsub->kc = &kc2->kc;\n\t\t\tkc2->kc.subtable = sub;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n\n    /* Every FPST and ASM lives in its own lookup with one subtable */\n    /* But the old format refered to nested lookups by tag, and now we refer */\n    /*  to the lookup itself, so fix that up */\n    for ( fpst=(FPST1 *) sf->sf.possub; fpst!=NULL; fpst=((FPST1 *) fpst->fpst.next) ) {\n\totl = CreateLookup(sf,fpst->tag, fpst->script_lang_index,\n\t\tfpst->flags,fpst->fpst.type);\n\tsub = CreateSubtable(otl,sf);\n\tsub->per_glyph_pst_or_kern = false;\n\tsub->fpst = &fpst->fpst;\n\tfpst->fpst.subtable = sub;\n\tFPSTReplaceTagsWithLookups(&fpst->fpst,sf);\n    }\n    for ( sm=(ASM1 *) sf->sf.sm; sm!=NULL; sm=((ASM1 *) sm->sm.next) ) {\n\totl = CreateMacLookup(sf,sm);\n\tsub = CreateSubtable(otl,sf);\n\tsub->per_glyph_pst_or_kern = false;\n\tsub->sm = &sm->sm;\n\tsm->sm.subtable = sub;\n\tif ( sm->sm.type==asm_context )\n\t    ASMReplaceTagsWithLookups(&sm->sm,sf);\n    }\n\n    /* We retained the old nested feature tags so we could do the above conversion */\n    /*  of tag to lookup. Get rid of them now */\n    for ( isgpos=0; isgpos<2; ++isgpos ) {\n\tfor ( otl = isgpos ? sf->sf.gpos_lookups : sf->sf.gsub_lookups ;\n\t\totl != NULL; otl=otl->next ) {\n\t    if ( otl->features!=NULL && otl->features->scripts==NULL ) {\n\t\tchunkfree(otl->features,sizeof(FeatureScriptLangList));\n\t\totl->features = NULL;\n\t    }\n\t}\n    }\n\n    /* Anchor classes are complicated, because I foolishly failed to distinguish */\n    /*  between mark to base and mark to ligature classes. So one AC might have */\n    /*  both. If so we need to turn it into two ACs, and have separate lookups */\n    /*  for each */\n    for ( ac=(AnchorClass1 *) (sf->sf.anchor); ac!=NULL; ac=(AnchorClass1 *) ac->ac.next ) {\n\tACHasBaseLig(sf,ac);\n\tif ( ac->has_ligatures && !ac->has_bases )\n\t    ac->ac.type = act_mklg;\n\telse if ( ac->has_ligatures && ac->has_bases )\n\t    ACDisassociateLigatures(sf,ac);\n    }\n    for ( ac=(AnchorClass1 *) (sf->sf.anchor); ac!=NULL; ac=(AnchorClass1 *) ac->ac.next ) {\n\tif ( ac->ac.subtable==NULL ) {\n\t    otl = CreateACLookup(sf,ac);\n\t    sub = CreateSubtable(otl,sf);\n\t    for ( ac2=ac; ac2!=NULL; ac2 = (AnchorClass1 *) ac2->ac.next ) {\n\t\tif ( ac2->feature_tag == ac->feature_tag &&\n\t\t\tac2->script_lang_index == ac->script_lang_index &&\n\t\t\tac2->flags == ac->flags &&\n\t\t\tac2->ac.type == ac->ac.type &&\n\t\t\tac2->merge_with == ac->merge_with )\n\t\t    ac2->ac.subtable = sub;\n\t    }\n\t}\n    }\n\n    /* Now I want to order the gsub lookups. I shan't bother with the gpos */\n    /*  lookups because I didn't before */\n    for ( otl=sf->sf.gsub_lookups, cnt=0; otl!=NULL; otl=otl->next, ++cnt );\n    if ( cnt!=0 ) {\n\tall = malloc(cnt*sizeof(OTLookup *));\n\tfor ( otl=sf->sf.gsub_lookups, cnt=0; otl!=NULL; otl=otl->next, ++cnt ) {\n\t    all[cnt] = otl;\n\t    otl->lookup_index = GSubOrder(sf,otl->features);\n\t}\n\tqsort(all,cnt,sizeof(OTLookup *),order_lookups);\n\tsf->sf.gsub_lookups = all[0];\n\tfor ( i=1; i<cnt; ++i )\n\t    all[i-1]->next = all[i];\n\tall[cnt-1]->next = NULL;\n\tfree( all );\n    }\n\n    for ( isgpos=0; isgpos<2; ++isgpos ) {\n\tfor ( otl = isgpos ? sf->sf.gpos_lookups : sf->sf.gsub_lookups , cnt=0;\n\t\totl!=NULL; otl = otl->next ) {\n\t    otl->lookup_index = cnt++;\n\t    NameOTLookup(otl,&sf->sf);\n\t}\n    }\n}",
  "abstract_func": "void SFD_AssignLookups(SplineFont1 *VAR_0) {\n    PST1 *VAR_1, *VAR_2;\n    int VAR_3;\n    KernPair1 *VAR_4, *VAR_5;\n    KernClass1 *VAR_6, *VAR_7;\n    FPST1 *VAR_8;\n    ASM1 *VAR_9;\n    AnchorClass1 *VAR_10, *VAR_11;\n    int VAR_12, VAR_13, VAR_14, VAR_15, VAR_16, VAR_17;\n    SplineFont1 *VAR_18;\n    SplineChar *VAR_19, *VAR_20;\n    OTLookup *VAR_21, **VAR_22;\n    struct lookup_subtable *VAR_23;\n\n    /* COMMENT_0 */\n    SFDCleanupAnchorClasses(&VAR_0->sf);\n    if ( VAR_0->sf.uni_interp==VAR_24 && VAR_0->sf.map!=NULL )\n\tVAR_0->sf.uni_interp = interp_from_encoding(VAR_0->sf.map->enc,VAR_25);\n\n    /* COMMENT_1 */\n    if ( VAR_0->sf.pfminfo.os2_winascent < VAR_0->sf.ascent/4 && !VAR_0->sf.pfminfo.winascent_add ) {\n\tVAR_0->sf.pfminfo.winascent_add = true;\n\tVAR_0->sf.pfminfo.os2_winascent = 0;\n\tVAR_0->sf.pfminfo.windescent_add = true;\n\tVAR_0->sf.pfminfo.os2_windescent = 0;\n    }\n\n    /* COMMENT_2 */\n    VAR_16=0;\n    do {\n\tVAR_18 = VAR_0->sf.subfontcnt==0 ? VAR_0 : (SplineFont1 *) (VAR_0->sf.subfonts[VAR_16]);\n\tfor ( VAR_12=0; VAR_12<VAR_18->sf.glyphcnt; ++VAR_12 ) if ( (VAR_19=VAR_18->sf.glyphs[VAR_12])!=NULL ) {\n\t    for ( VAR_1 = (PST1 *) (VAR_19->possub); VAR_1!=NULL; VAR_1 = (PST1*) (VAR_1->pst.next) ) {\n\t\tif ( VAR_1->pst.type == VAR_26 || VAR_1->pst.subtable!=NULL )\n\t    continue;\t\t/* COMMENT_3 */\n\t\tVAR_21 = CreateLookup(VAR_0,VAR_1->tag,VAR_1->script_lang_index,VAR_1->flags,VAR_1->pst.type);\n\t\tVAR_23 = CreateSubtable(VAR_21,VAR_0);\n\t\t/* COMMENT_4 */\n\t\t/* COMMENT_5 */\n\t\tfor ( VAR_2=VAR_1 ; VAR_2!=NULL; VAR_2 = (PST1 *) (VAR_2->pst.next) ) {\n\t\t    if ( VAR_2->tag==VAR_1->tag &&\n\t\t\t    VAR_2->script_lang_index==VAR_1->script_lang_index &&\n\t\t\t    VAR_2->flags==VAR_1->flags &&\n\t\t\t    VAR_2->pst.type==VAR_1->pst.type )\n\t\t\tVAR_2->pst.subtable = VAR_23;\n\t\t}\n\t\tfor ( VAR_13=VAR_12+1; VAR_13<VAR_18->sf.glyphcnt; ++VAR_13 ) if ( (VAR_20=VAR_18->sf.glyphs[VAR_13])!=NULL ) {\n\t\t    for ( VAR_2 = (PST1 *) (VAR_20->possub); VAR_2!=NULL; VAR_2 = (PST1 *) (VAR_2->pst.next) ) {\n\t\t\tif ( VAR_2->tag==VAR_1->tag &&\n\t\t\t\tVAR_2->script_lang_index==VAR_1->script_lang_index &&\n\t\t\t\tVAR_2->flags==VAR_1->flags &&\n\t\t\t\tVAR_2->pst.type==VAR_1->pst.type )\n\t\t\t    VAR_2->pst.subtable = VAR_23;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\t++VAR_16;\n    } while ( VAR_16<VAR_0->sf.subfontcnt );\n\n\t/* COMMENT_6 */\n    for ( VAR_3=0; VAR_3<2; ++VAR_3 ) {\n\tVAR_16=0;\n\tdo {\n\t    VAR_18 = VAR_0->sf.subfontcnt==0 ? VAR_0 : (SplineFont1 *) (VAR_0->sf.subfonts[VAR_16]);\n\t    for ( VAR_12=0; VAR_12<VAR_18->sf.glyphcnt; ++VAR_12 ) if ( (VAR_19=VAR_18->sf.glyphs[VAR_12])!=NULL ) {\n\t\tfor ( VAR_4 = (KernPair1 *) (VAR_3 ? VAR_19->vkerns : VAR_19->kerns); VAR_4!=NULL; VAR_4 = (KernPair1 *) (VAR_4->kp.next) ) {\n\t\t    if ( VAR_4->kp.subtable!=NULL )\n\t\tcontinue;\t\t/* COMMENT_7 */\n\t\t    VAR_21 = CreateLookup(VAR_0,VAR_3 ? CHR('v','k','r','n') : CHR('k','e','r','n'),\n\t\t\t    VAR_4->sli,VAR_4->flags,VAR_27);\n\t\t    VAR_23 = CreateSubtable(VAR_21,VAR_0);\n\t\t    /* COMMENT_8 */\n\t\t    /* COMMENT_9 */\n\t\t    for ( VAR_5=VAR_4 ; VAR_5!=NULL; VAR_5 = (KernPair1 *) (VAR_5->kp.next) ) {\n\t\t\tif ( VAR_5->sli==VAR_4->sli && VAR_5->flags==VAR_4->flags )\n\t\t\t    VAR_5->kp.subtable = VAR_23;\n\t\t    }\n\t\t    for ( VAR_13=VAR_12+1; VAR_13<VAR_18->sf.glyphcnt; ++VAR_13 ) if ( (VAR_20=VAR_18->sf.glyphs[VAR_13])!=NULL ) {\n\t\t\tfor ( VAR_5 = (KernPair1 *) (VAR_3 ? VAR_20->vkerns : VAR_20->kerns); VAR_5!=NULL; VAR_5 = (KernPair1 *) (VAR_5->kp.next) ) {\n\t\t\t    if ( VAR_5->sli==VAR_4->sli && VAR_5->flags==VAR_4->flags )\n\t\t\t\tVAR_5->kp.subtable = VAR_23;\n\t\t\t}\n\t\t    }\n\t\t    /* COMMENT_10 */\n\t\t    for ( VAR_6=(KernClass1 *) (VAR_3 ? VAR_0->sf.vkerns : VAR_0->sf.kerns); VAR_6!=NULL;\n\t\t\t    VAR_6 = (KernClass1 *) (VAR_6->kc.next) ) {\n\t\t\tif ( VAR_6->sli == VAR_4->sli && VAR_6->flags == VAR_4->flags && VAR_6->kc.subtable==NULL) {\n\t\t\t    VAR_23 = CreateSubtable(VAR_21,VAR_0);\n\t\t\t    VAR_23->per_glyph_pst_or_kern = false;\n\t\t\t    VAR_23->kc = &VAR_6->kc;\n\t\t\t    VAR_6->kc.subtable = VAR_23;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    ++VAR_16;\n\t} while ( VAR_16<VAR_0->sf.subfontcnt );\n\t/* COMMENT_11 */\n\tfor ( VAR_6=(KernClass1 *) (VAR_3 ? VAR_0->sf.vkerns : VAR_0->sf.kerns); VAR_6!=NULL;\n\t\tVAR_6 = (KernClass1 *) (VAR_6->kc.next) ) {\n\t    if ( VAR_6->kc.subtable==NULL) {\n\t\tVAR_21 = CreateLookup(VAR_0,VAR_3 ? CHR('v','k','r','n') : CHR('k','e','r','n'),\n\t\t\tVAR_6->sli,VAR_6->flags,VAR_27);\n\t\tfor ( VAR_7=VAR_6; VAR_7!=NULL; VAR_7=(KernClass1 *) (VAR_7->kc.next) ) {\n\t\t    if ( VAR_6->sli == VAR_7->sli && VAR_6->flags == VAR_7->flags && VAR_7->kc.subtable==NULL) {\n\t\t\tVAR_23 = CreateSubtable(VAR_21,VAR_0);\n\t\t\tVAR_23->per_glyph_pst_or_kern = false;\n\t\t\tVAR_23->kc = &VAR_7->kc;\n\t\t\tVAR_7->kc.subtable = VAR_23;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n\n    /* COMMENT_12 */\n    /* COMMENT_13 */\n    /* COMMENT_14 */\n    for ( VAR_8=(FPST1 *) VAR_0->sf.possub; VAR_8!=NULL; VAR_8=((FPST1 *) VAR_8->fpst.next) ) {\n\tVAR_21 = CreateLookup(VAR_0,VAR_8->tag, VAR_8->script_lang_index,\n\t\tVAR_8->flags,VAR_8->fpst.type);\n\tVAR_23 = CreateSubtable(VAR_21,VAR_0);\n\tVAR_23->per_glyph_pst_or_kern = false;\n\tVAR_23->fpst = &VAR_8->fpst;\n\tVAR_8->fpst.subtable = VAR_23;\n\tFPSTReplaceTagsWithLookups(&VAR_8->fpst,VAR_0);\n    }\n    for ( VAR_9=(ASM1 *) VAR_0->sf.sm; VAR_9!=NULL; VAR_9=((ASM1 *) VAR_9->sm.next) ) {\n\tVAR_21 = CreateMacLookup(VAR_0,VAR_9);\n\tVAR_23 = CreateSubtable(VAR_21,VAR_0);\n\tVAR_23->per_glyph_pst_or_kern = false;\n\tVAR_23->sm = &VAR_9->sm;\n\tVAR_9->sm.subtable = VAR_23;\n\tif ( VAR_9->sm.type==VAR_28 )\n\t    ASMReplaceTagsWithLookups(&VAR_9->sm,VAR_0);\n    }\n\n    /* COMMENT_15 */\n    /* COMMENT_16 */\n    for ( VAR_17=0; VAR_17<2; ++VAR_17 ) {\n\tfor ( VAR_21 = VAR_17 ? VAR_0->sf.gpos_lookups : VAR_0->sf.gsub_lookups ;\n\t\tVAR_21 != NULL; VAR_21=VAR_21->next ) {\n\t    if ( VAR_21->features!=NULL && VAR_21->features->scripts==NULL ) {\n\t\tchunkfree(VAR_21->features,sizeof(VAR_29));\n\t\tVAR_21->features = NULL;\n\t    }\n\t}\n    }\n\n    /* COMMENT_17 */\n    /* COMMENT_18 */\n    /* COMMENT_19 */\n    /* COMMENT_20 */\n    for ( VAR_10=(AnchorClass1 *) (VAR_0->sf.anchor); VAR_10!=NULL; VAR_10=(AnchorClass1 *) VAR_10->ac.next ) {\n\tACHasBaseLig(VAR_0,VAR_10);\n\tif ( VAR_10->has_ligatures && !VAR_10->has_bases )\n\t    VAR_10->ac.type = VAR_30;\n\telse if ( VAR_10->has_ligatures && VAR_10->has_bases )\n\t    ACDisassociateLigatures(VAR_0,VAR_10);\n    }\n    for ( VAR_10=(AnchorClass1 *) (VAR_0->sf.anchor); VAR_10!=NULL; VAR_10=(AnchorClass1 *) VAR_10->ac.next ) {\n\tif ( VAR_10->ac.subtable==NULL ) {\n\t    VAR_21 = CreateACLookup(VAR_0,VAR_10);\n\t    VAR_23 = CreateSubtable(VAR_21,VAR_0);\n\t    for ( VAR_11=VAR_10; VAR_11!=NULL; VAR_11 = (AnchorClass1 *) VAR_11->ac.next ) {\n\t\tif ( VAR_11->feature_tag == VAR_10->feature_tag &&\n\t\t\tVAR_11->script_lang_index == VAR_10->script_lang_index &&\n\t\t\tVAR_11->flags == VAR_10->flags &&\n\t\t\tVAR_11->ac.type == VAR_10->ac.type &&\n\t\t\tVAR_11->merge_with == VAR_10->merge_with )\n\t\t    VAR_11->ac.subtable = VAR_23;\n\t    }\n\t}\n    }\n\n    /* COMMENT_21 */\n    /* COMMENT_22 */\n    for ( VAR_21=VAR_0->sf.gsub_lookups, VAR_14=0; VAR_21!=NULL; VAR_21=VAR_21->next, ++VAR_14 );\n    if ( VAR_14!=0 ) {\n\tVAR_22 = malloc(VAR_14*sizeof(OTLookup *));\n\tfor ( VAR_21=VAR_0->sf.gsub_lookups, VAR_14=0; VAR_21!=NULL; VAR_21=VAR_21->next, ++VAR_14 ) {\n\t    VAR_22[VAR_14] = VAR_21;\n\t    VAR_21->lookup_index = GSubOrder(VAR_0,VAR_21->features);\n\t}\n\tqsort(VAR_22,VAR_14,sizeof(OTLookup *),VAR_31);\n\tVAR_0->sf.gsub_lookups = VAR_22[0];\n\tfor ( VAR_15=1; VAR_15<VAR_14; ++VAR_15 )\n\t    VAR_22[VAR_15-1]->next = VAR_22[VAR_15];\n\tVAR_22[VAR_14-1]->next = NULL;\n\tfree( VAR_22 );\n    }\n\n    for ( VAR_17=0; VAR_17<2; ++VAR_17 ) {\n\tfor ( VAR_21 = VAR_17 ? VAR_0->sf.gpos_lookups : VAR_0->sf.gsub_lookups , VAR_14=0;\n\t\tVAR_21!=NULL; VAR_21 = VAR_21->next ) {\n\t    VAR_21->lookup_index = VAR_14++;\n\t    NameOTLookup(VAR_21,&VAR_0->sf);\n\t}\n    }\n}",
  "func_graph_path": "fontforge/8da6d56bf7af2d25f779e52edef61b2fd4557b3c/sfd1.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -14,7 +14,7 @@\n \n     /* Fix up some gunk from really old versions of the sfd format */\n     SFDCleanupAnchorClasses(&sf->sf);\n-    if ( sf->sf.uni_interp==ui_unset )\n+    if ( sf->sf.uni_interp==ui_unset && sf->sf.map!=NULL )\n \tsf->sf.uni_interp = interp_from_encoding(sf->sf.map->enc,ui_none);\n \n     /* Fixup for an old bug */",
  "diff_line_info": {
    "deleted_lines": [
      "    if ( sf->sf.uni_interp==ui_unset )"
    ],
    "added_lines": [
      "    if ( sf->sf.uni_interp==ui_unset && sf->sf.map!=NULL )"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/fontforge/fontforge/pull/4091",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/fontforge/fontforge/pull/4091: 403 Client Error: Forbidden for url: https://api.github.com/repos/fontforge/fontforge/pulls/4091",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}