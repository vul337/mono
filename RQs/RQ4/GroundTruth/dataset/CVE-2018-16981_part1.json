{
  "cve_id": "CVE-2018-16981",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "nothings/stb",
  "commit_msg": "stb_image: Make GIF reader validate image size.\n\nI must've missed it when I did this for the other image loaders.\nEither way, combined with the previous checkin, this should fix\nissue #614 properly.\n\nFixes issue #614.",
  "commit_hash": "6570d6a825e2982a4f1c9ae7173a737eed4dd6f0",
  "git_url": "https://github.com/nothings/stb/commit/6570d6a825e2982a4f1c9ae7173a737eed4dd6f0",
  "file_path": "stb_image.h",
  "func_name": "stbi__gif_load_next",
  "func_before": "static stbi_uc *stbi__gif_load_next(stbi__context *s, stbi__gif *g, int *comp, int req_comp, stbi_uc *two_back)\n{\n   int dispose; \n   int first_frame; \n   int pi; \n   int pcount; \n   STBI_NOTUSED(req_comp);\n\n   // on first frame, any non-written pixels get the background colour (non-transparent)\n   first_frame = 0; \n   if (g->out == 0) {\n      if (!stbi__gif_header(s, g, comp,0))     return 0; // stbi__g_failure_reason set by stbi__gif_header\n      g->out = (stbi_uc *) stbi__malloc(4 * g->w * g->h);\n      g->background = (stbi_uc *) stbi__malloc(4 * g->w * g->h); \n      g->history = (stbi_uc *) stbi__malloc(g->w * g->h); \n      if (!g->out || !g->background || !g->history)\n         return stbi__errpuc(\"outofmem\", \"Out of memory\");\n\n      // image is treated as \"transparent\" at the start - ie, nothing overwrites the current background; \n      // background colour is only used for pixels that are not rendered first frame, after that \"background\"\n      // color refers to the color that was there the previous frame. \n      memset( g->out, 0x00, 4 * g->w * g->h ); \n      memset( g->background, 0x00, 4 * g->w * g->h ); // state of the background (starts transparent)\n      memset( g->history, 0x00, g->w * g->h );        // pixels that were affected previous frame\n      first_frame = 1; \n   } else {\n      // second frame - how do we dispoase of the previous one?\n      dispose = (g->eflags & 0x1C) >> 2; \n      pcount = g->w * g->h; \n\n      if ((dispose == 3) && (two_back == 0)) {\n         dispose = 2; // if I don't have an image to revert back to, default to the old background\n      }\n\n      if (dispose == 3) { // use previous graphic\n         for (pi = 0; pi < pcount; ++pi) {\n            if (g->history[pi]) {\n               memcpy( &g->out[pi * 4], &two_back[pi * 4], 4 ); \n            }\n         }\n      } else if (dispose == 2) { \n         // restore what was changed last frame to background before that frame; \n         for (pi = 0; pi < pcount; ++pi) {\n            if (g->history[pi]) {\n               memcpy( &g->out[pi * 4], &g->background[pi * 4], 4 ); \n            }\n         }\n      } else {\n         // This is a non-disposal case eithe way, so just \n         // leave the pixels as is, and they will become the new background\n         // 1: do not dispose\n         // 0:  not specified.\n      }\n\n      // background is what out is after the undoing of the previou frame; \n      memcpy( g->background, g->out, 4 * g->w * g->h ); \n   }\n\n   // clear my history; \n   memset( g->history, 0x00, g->w * g->h );        // pixels that were affected previous frame\n\n   for (;;) {\n      int tag = stbi__get8(s); \n      switch (tag) {\n         case 0x2C: /* Image Descriptor */\n         {\n            stbi__int32 x, y, w, h;\n            stbi_uc *o;\n\n            x = stbi__get16le(s);\n            y = stbi__get16le(s);\n            w = stbi__get16le(s);\n            h = stbi__get16le(s);\n            if (((x + w) > (g->w)) || ((y + h) > (g->h)))\n               return stbi__errpuc(\"bad Image Descriptor\", \"Corrupt GIF\");\n\n            g->line_size = g->w * 4;\n            g->start_x = x * 4;\n            g->start_y = y * g->line_size;\n            g->max_x   = g->start_x + w * 4;\n            g->max_y   = g->start_y + h * g->line_size;\n            g->cur_x   = g->start_x;\n            g->cur_y   = g->start_y;\n\n            // if the width of the specified rectangle is 0, that means\n            // we may not see *any* pixels or the image is malformed;\n            // to make sure this is caught, move the current y down to\n            // max_y (which is what out_gif_code checks).\n            if (w == 0)\n               g->cur_y = g->max_y;\n\n            g->lflags = stbi__get8(s);\n\n            if (g->lflags & 0x40) {\n               g->step = 8 * g->line_size; // first interlaced spacing\n               g->parse = 3;\n            } else {\n               g->step = g->line_size;\n               g->parse = 0;\n            }\n\n            if (g->lflags & 0x80) {\n               stbi__gif_parse_colortable(s,g->lpal, 2 << (g->lflags & 7), g->eflags & 0x01 ? g->transparent : -1);\n               g->color_table = (stbi_uc *) g->lpal;\n            } else if (g->flags & 0x80) {\n               g->color_table = (stbi_uc *) g->pal;\n            } else\n               return stbi__errpuc(\"missing color table\", \"Corrupt GIF\");            \n            \n            o = stbi__process_gif_raster(s, g);\n            if (!o) return NULL;\n\n            // if this was the first frame, \n            pcount = g->w * g->h; \n            if (first_frame && (g->bgindex > 0)) {\n               // if first frame, any pixel not drawn to gets the background color\n               for (pi = 0; pi < pcount; ++pi) {\n                  if (g->history[pi] == 0) {\n                     g->pal[g->bgindex][3] = 255; // just in case it was made transparent, undo that; It will be reset next frame if need be; \n                     memcpy( &g->out[pi * 4], &g->pal[g->bgindex], 4 ); \n                  }\n               }\n            }\n\n            return o;\n         }\n\n         case 0x21: // Comment Extension.\n         {\n            int len;\n            int ext = stbi__get8(s); \n            if (ext == 0xF9) { // Graphic Control Extension.\n               len = stbi__get8(s);\n               if (len == 4) {\n                  g->eflags = stbi__get8(s);\n                  g->delay = 10 * stbi__get16le(s); // delay - 1/100th of a second, saving as 1/1000ths.\n\n                  // unset old transparent\n                  if (g->transparent >= 0) {\n                     g->pal[g->transparent][3] = 255; \n                  } \n                  if (g->eflags & 0x01) {\n                     g->transparent = stbi__get8(s);\n                     if (g->transparent >= 0) {\n                        g->pal[g->transparent][3] = 0; \n                     }\n                  } else {\n                     // don't need transparent\n                     stbi__skip(s, 1); \n                     g->transparent = -1; \n                  }\n               } else {\n                  stbi__skip(s, len);\n                  break;\n               }\n            } \n            while ((len = stbi__get8(s)) != 0) {\n               stbi__skip(s, len);\n            }\n            break;\n         }\n\n         case 0x3B: // gif stream termination code\n            return (stbi_uc *) s; // using '1' causes warning on some compilers\n\n         default:\n            return stbi__errpuc(\"unknown code\", \"Corrupt GIF\");\n      }\n   }\n}",
  "abstract_func_before": "static stbi_uc *stbi__gif_load_next(stbi__context *VAR_0, stbi__gif *VAR_1, int *VAR_2, int VAR_3, stbi_uc *VAR_4)\n{\n   int VAR_5; \n   int VAR_6; \n   int VAR_7; \n   int VAR_8; \n   STBI_NOTUSED(VAR_3);\n\n   /* COMMENT_0 */\n   VAR_6 = 0; \n   if (VAR_1->out == 0) {\n      if (!stbi__gif_header(VAR_0, VAR_1, VAR_2,0))     return 0; /* COMMENT_1 */\n      VAR_1->out = (stbi_uc *) stbi__malloc(4 * VAR_1->w * VAR_1->h);\n      VAR_1->background = (stbi_uc *) stbi__malloc(4 * VAR_1->w * VAR_1->h); \n      VAR_1->history = (stbi_uc *) stbi__malloc(VAR_1->w * VAR_1->h); \n      if (!VAR_1->out || !VAR_1->background || !VAR_1->history)\n         return stbi__errpuc(\"outofmem\", \"Out of memory\");\n\n      /* COMMENT_2 */\n      /* COMMENT_3 */\n      /* COMMENT_4 */\n      memset( VAR_1->out, 0x00, 4 * VAR_1->w * VAR_1->h ); \n      memset( VAR_1->background, 0x00, 4 * VAR_1->w * VAR_1->h ); /* COMMENT_5 */\n      memset( VAR_1->history, 0x00, VAR_1->w * VAR_1->h );        /* COMMENT_6 */\n      VAR_6 = 1; \n   } else {\n      /* COMMENT_7 */\n      VAR_5 = (VAR_1->eflags & 0x1C) >> 2; \n      VAR_8 = VAR_1->w * VAR_1->h; \n\n      if ((VAR_5 == 3) && (VAR_4 == 0)) {\n         VAR_5 = 2; /* COMMENT_8 */\n      }\n\n      if (VAR_5 == 3) { /* COMMENT_9 */\n         for (VAR_7 = 0; VAR_7 < VAR_8; ++VAR_7) {\n            if (VAR_1->history[VAR_7]) {\n               memcpy( &VAR_1->out[VAR_7 * 4], &VAR_4[VAR_7 * 4], 4 ); \n            }\n         }\n      } else if (VAR_5 == 2) { \n         /* COMMENT_10 */\n         for (VAR_7 = 0; VAR_7 < VAR_8; ++VAR_7) {\n            if (VAR_1->history[VAR_7]) {\n               memcpy( &VAR_1->out[VAR_7 * 4], &VAR_1->background[VAR_7 * 4], 4 ); \n            }\n         }\n      } else {\n         /* COMMENT_11 */\n         /* COMMENT_12 */\n         /* COMMENT_13 */\n         /* COMMENT_14 */\n      }\n\n      /* COMMENT_15 */\n      memcpy( VAR_1->background, VAR_1->out, 4 * VAR_1->w * VAR_1->h ); \n   }\n\n   /* COMMENT_16 */\n   memset( VAR_1->history, 0x00, VAR_1->w * VAR_1->h );        /* COMMENT_6 */\n\n   for (;;) {\n      int VAR_9 = stbi__get8(VAR_0); \n      switch (VAR_9) {\n         case 0x2C: /* COMMENT_17 */\n         {\n            stbi__int32 VAR_10, VAR_11, VAR_12, VAR_13;\n            stbi_uc *VAR_14;\n\n            VAR_10 = stbi__get16le(VAR_0);\n            VAR_11 = stbi__get16le(VAR_0);\n            VAR_12 = stbi__get16le(VAR_0);\n            VAR_13 = stbi__get16le(VAR_0);\n            if (((VAR_10 + VAR_12) > (VAR_1->w)) || ((VAR_11 + VAR_13) > (VAR_1->h)))\n               return stbi__errpuc(\"bad Image Descriptor\", \"Corrupt GIF\");\n\n            VAR_1->line_size = VAR_1->w * 4;\n            VAR_1->start_x = VAR_10 * 4;\n            VAR_1->start_y = VAR_11 * VAR_1->line_size;\n            VAR_1->max_x   = VAR_1->start_x + VAR_12 * 4;\n            VAR_1->max_y   = VAR_1->start_y + VAR_13 * VAR_1->line_size;\n            VAR_1->cur_x   = VAR_1->start_x;\n            VAR_1->cur_y   = VAR_1->start_y;\n\n            /* COMMENT_18 */\n            /* COMMENT_19 */\n            /* COMMENT_20 */\n            /* COMMENT_21 */\n            if (VAR_12 == 0)\n               VAR_1->cur_y = VAR_1->max_y;\n\n            VAR_1->lflags = stbi__get8(VAR_0);\n\n            if (VAR_1->lflags & 0x40) {\n               VAR_1->step = 8 * VAR_1->line_size; /* COMMENT_22 */\n               VAR_1->parse = 3;\n            } else {\n               VAR_1->step = VAR_1->line_size;\n               VAR_1->parse = 0;\n            }\n\n            if (VAR_1->lflags & 0x80) {\n               stbi__gif_parse_colortable(VAR_0,VAR_1->lpal, 2 << (VAR_1->lflags & 7), VAR_1->eflags & 0x01 ? VAR_1->transparent : -1);\n               VAR_1->color_table = (stbi_uc *) VAR_1->lpal;\n            } else if (VAR_1->flags & 0x80) {\n               VAR_1->color_table = (stbi_uc *) VAR_1->pal;\n            } else\n               return stbi__errpuc(\"missing color table\", \"Corrupt GIF\");            \n            \n            VAR_14 = stbi__process_gif_raster(VAR_0, VAR_1);\n            if (!VAR_14) return NULL;\n\n            /* COMMENT_23 */\n            VAR_8 = VAR_1->w * VAR_1->h; \n            if (VAR_6 && (VAR_1->bgindex > 0)) {\n               /* COMMENT_24 */\n               for (VAR_7 = 0; VAR_7 < VAR_8; ++VAR_7) {\n                  if (VAR_1->history[VAR_7] == 0) {\n                     VAR_1->pal[VAR_1->bgindex][3] = 255; /* COMMENT_25 */\n                     memcpy( &VAR_1->out[VAR_7 * 4], &VAR_1->pal[VAR_1->bgindex], 4 ); \n                  }\n               }\n            }\n\n            return VAR_14;\n         }\n\n         case 0x21: /* COMMENT_26 */\n         {\n            int VAR_15;\n            int VAR_16 = stbi__get8(VAR_0); \n            if (VAR_16 == 0xF9) { /* COMMENT_27 */\n               VAR_15 = stbi__get8(VAR_0);\n               if (VAR_15 == 4) {\n                  VAR_1->eflags = stbi__get8(VAR_0);\n                  VAR_1->delay = 10 * stbi__get16le(VAR_0); /* COMMENT_28 */\n\n                  /* COMMENT_29 */\n                  if (VAR_1->transparent >= 0) {\n                     VAR_1->pal[VAR_1->transparent][3] = 255; \n                  } \n                  if (VAR_1->eflags & 0x01) {\n                     VAR_1->transparent = stbi__get8(VAR_0);\n                     if (VAR_1->transparent >= 0) {\n                        VAR_1->pal[VAR_1->transparent][3] = 0; \n                     }\n                  } else {\n                     /* COMMENT_30 */\n                     stbi__skip(VAR_0, 1); \n                     VAR_1->transparent = -1; \n                  }\n               } else {\n                  stbi__skip(VAR_0, VAR_15);\n                  break;\n               }\n            } \n            while ((VAR_15 = stbi__get8(VAR_0)) != 0) {\n               stbi__skip(VAR_0, VAR_15);\n            }\n            break;\n         }\n\n         case 0x3B: /* COMMENT_31 */\n            return (stbi_uc *) VAR_0; /* COMMENT_32 */\n\n         default:\n            return stbi__errpuc(\"unknown code\", \"Corrupt GIF\");\n      }\n   }\n}",
  "func_graph_path_before": "nothings/stb/6570d6a825e2982a4f1c9ae7173a737eed4dd6f0/stb_image.h/vul/before/0.json",
  "func": "static stbi_uc *stbi__gif_load_next(stbi__context *s, stbi__gif *g, int *comp, int req_comp, stbi_uc *two_back)\n{\n   int dispose; \n   int first_frame; \n   int pi; \n   int pcount; \n   STBI_NOTUSED(req_comp);\n\n   // on first frame, any non-written pixels get the background colour (non-transparent)\n   first_frame = 0; \n   if (g->out == 0) {\n      if (!stbi__gif_header(s, g, comp,0)) return 0; // stbi__g_failure_reason set by stbi__gif_header\n      if (!stbi__mad3sizes_valid(4, g->w, g->h, 0))\n         return stbi__errpuc(\"too large\", \"GIF image is too large\");\n      pcount = g->w * g->h;\n      g->out = (stbi_uc *) stbi__malloc(4 * pcount);\n      g->background = (stbi_uc *) stbi__malloc(4 * pcount);\n      g->history = (stbi_uc *) stbi__malloc(pcount);\n      if (!g->out || !g->background || !g->history)\n         return stbi__errpuc(\"outofmem\", \"Out of memory\");\n\n      // image is treated as \"transparent\" at the start - ie, nothing overwrites the current background; \n      // background colour is only used for pixels that are not rendered first frame, after that \"background\"\n      // color refers to the color that was there the previous frame. \n      memset(g->out, 0x00, 4 * pcount);\n      memset(g->background, 0x00, 4 * pcount); // state of the background (starts transparent)\n      memset(g->history, 0x00, pcount);        // pixels that were affected previous frame\n      first_frame = 1; \n   } else {\n      // second frame - how do we dispoase of the previous one?\n      dispose = (g->eflags & 0x1C) >> 2; \n      pcount = g->w * g->h; \n\n      if ((dispose == 3) && (two_back == 0)) {\n         dispose = 2; // if I don't have an image to revert back to, default to the old background\n      }\n\n      if (dispose == 3) { // use previous graphic\n         for (pi = 0; pi < pcount; ++pi) {\n            if (g->history[pi]) {\n               memcpy( &g->out[pi * 4], &two_back[pi * 4], 4 ); \n            }\n         }\n      } else if (dispose == 2) { \n         // restore what was changed last frame to background before that frame; \n         for (pi = 0; pi < pcount; ++pi) {\n            if (g->history[pi]) {\n               memcpy( &g->out[pi * 4], &g->background[pi * 4], 4 ); \n            }\n         }\n      } else {\n         // This is a non-disposal case eithe way, so just \n         // leave the pixels as is, and they will become the new background\n         // 1: do not dispose\n         // 0:  not specified.\n      }\n\n      // background is what out is after the undoing of the previou frame; \n      memcpy( g->background, g->out, 4 * g->w * g->h ); \n   }\n\n   // clear my history; \n   memset( g->history, 0x00, g->w * g->h );        // pixels that were affected previous frame\n\n   for (;;) {\n      int tag = stbi__get8(s); \n      switch (tag) {\n         case 0x2C: /* Image Descriptor */\n         {\n            stbi__int32 x, y, w, h;\n            stbi_uc *o;\n\n            x = stbi__get16le(s);\n            y = stbi__get16le(s);\n            w = stbi__get16le(s);\n            h = stbi__get16le(s);\n            if (((x + w) > (g->w)) || ((y + h) > (g->h)))\n               return stbi__errpuc(\"bad Image Descriptor\", \"Corrupt GIF\");\n\n            g->line_size = g->w * 4;\n            g->start_x = x * 4;\n            g->start_y = y * g->line_size;\n            g->max_x   = g->start_x + w * 4;\n            g->max_y   = g->start_y + h * g->line_size;\n            g->cur_x   = g->start_x;\n            g->cur_y   = g->start_y;\n\n            // if the width of the specified rectangle is 0, that means\n            // we may not see *any* pixels or the image is malformed;\n            // to make sure this is caught, move the current y down to\n            // max_y (which is what out_gif_code checks).\n            if (w == 0)\n               g->cur_y = g->max_y;\n\n            g->lflags = stbi__get8(s);\n\n            if (g->lflags & 0x40) {\n               g->step = 8 * g->line_size; // first interlaced spacing\n               g->parse = 3;\n            } else {\n               g->step = g->line_size;\n               g->parse = 0;\n            }\n\n            if (g->lflags & 0x80) {\n               stbi__gif_parse_colortable(s,g->lpal, 2 << (g->lflags & 7), g->eflags & 0x01 ? g->transparent : -1);\n               g->color_table = (stbi_uc *) g->lpal;\n            } else if (g->flags & 0x80) {\n               g->color_table = (stbi_uc *) g->pal;\n            } else\n               return stbi__errpuc(\"missing color table\", \"Corrupt GIF\");            \n            \n            o = stbi__process_gif_raster(s, g);\n            if (!o) return NULL;\n\n            // if this was the first frame, \n            pcount = g->w * g->h; \n            if (first_frame && (g->bgindex > 0)) {\n               // if first frame, any pixel not drawn to gets the background color\n               for (pi = 0; pi < pcount; ++pi) {\n                  if (g->history[pi] == 0) {\n                     g->pal[g->bgindex][3] = 255; // just in case it was made transparent, undo that; It will be reset next frame if need be; \n                     memcpy( &g->out[pi * 4], &g->pal[g->bgindex], 4 ); \n                  }\n               }\n            }\n\n            return o;\n         }\n\n         case 0x21: // Comment Extension.\n         {\n            int len;\n            int ext = stbi__get8(s); \n            if (ext == 0xF9) { // Graphic Control Extension.\n               len = stbi__get8(s);\n               if (len == 4) {\n                  g->eflags = stbi__get8(s);\n                  g->delay = 10 * stbi__get16le(s); // delay - 1/100th of a second, saving as 1/1000ths.\n\n                  // unset old transparent\n                  if (g->transparent >= 0) {\n                     g->pal[g->transparent][3] = 255; \n                  } \n                  if (g->eflags & 0x01) {\n                     g->transparent = stbi__get8(s);\n                     if (g->transparent >= 0) {\n                        g->pal[g->transparent][3] = 0; \n                     }\n                  } else {\n                     // don't need transparent\n                     stbi__skip(s, 1); \n                     g->transparent = -1; \n                  }\n               } else {\n                  stbi__skip(s, len);\n                  break;\n               }\n            } \n            while ((len = stbi__get8(s)) != 0) {\n               stbi__skip(s, len);\n            }\n            break;\n         }\n\n         case 0x3B: // gif stream termination code\n            return (stbi_uc *) s; // using '1' causes warning on some compilers\n\n         default:\n            return stbi__errpuc(\"unknown code\", \"Corrupt GIF\");\n      }\n   }\n}",
  "abstract_func": "static stbi_uc *stbi__gif_load_next(stbi__context *VAR_0, stbi__gif *VAR_1, int *VAR_2, int VAR_3, stbi_uc *VAR_4)\n{\n   int VAR_5; \n   int VAR_6; \n   int VAR_7; \n   int VAR_8; \n   STBI_NOTUSED(VAR_3);\n\n   /* COMMENT_0 */\n   VAR_6 = 0; \n   if (VAR_1->out == 0) {\n      if (!stbi__gif_header(VAR_0, VAR_1, VAR_2,0)) return 0; /* COMMENT_1 */\n      if (!stbi__mad3sizes_valid(4, VAR_1->w, VAR_1->h, 0))\n         return stbi__errpuc(\"too large\", \"GIF image is too large\");\n      VAR_8 = VAR_1->w * VAR_1->h;\n      VAR_1->out = (stbi_uc *) stbi__malloc(4 * VAR_8);\n      VAR_1->background = (stbi_uc *) stbi__malloc(4 * VAR_8);\n      VAR_1->history = (stbi_uc *) stbi__malloc(VAR_8);\n      if (!VAR_1->out || !VAR_1->background || !VAR_1->history)\n         return stbi__errpuc(\"outofmem\", \"Out of memory\");\n\n      /* COMMENT_2 */\n      /* COMMENT_3 */\n      /* COMMENT_4 */\n      memset(VAR_1->out, 0x00, 4 * VAR_8);\n      memset(VAR_1->background, 0x00, 4 * VAR_8); /* COMMENT_5 */\n      memset(VAR_1->history, 0x00, VAR_8);        /* COMMENT_6 */\n      VAR_6 = 1; \n   } else {\n      /* COMMENT_7 */\n      VAR_5 = (VAR_1->eflags & 0x1C) >> 2; \n      VAR_8 = VAR_1->w * VAR_1->h; \n\n      if ((VAR_5 == 3) && (VAR_4 == 0)) {\n         VAR_5 = 2; /* COMMENT_8 */\n      }\n\n      if (VAR_5 == 3) { /* COMMENT_9 */\n         for (VAR_7 = 0; VAR_7 < VAR_8; ++VAR_7) {\n            if (VAR_1->history[VAR_7]) {\n               memcpy( &VAR_1->out[VAR_7 * 4], &VAR_4[VAR_7 * 4], 4 ); \n            }\n         }\n      } else if (VAR_5 == 2) { \n         /* COMMENT_10 */\n         for (VAR_7 = 0; VAR_7 < VAR_8; ++VAR_7) {\n            if (VAR_1->history[VAR_7]) {\n               memcpy( &VAR_1->out[VAR_7 * 4], &VAR_1->background[VAR_7 * 4], 4 ); \n            }\n         }\n      } else {\n         /* COMMENT_11 */\n         /* COMMENT_12 */\n         /* COMMENT_13 */\n         /* COMMENT_14 */\n      }\n\n      /* COMMENT_15 */\n      memcpy( VAR_1->background, VAR_1->out, 4 * VAR_1->w * VAR_1->h ); \n   }\n\n   /* COMMENT_16 */\n   memset( VAR_1->history, 0x00, VAR_1->w * VAR_1->h );        /* COMMENT_6 */\n\n   for (;;) {\n      int VAR_9 = stbi__get8(VAR_0); \n      switch (VAR_9) {\n         case 0x2C: /* COMMENT_17 */\n         {\n            stbi__int32 VAR_10, VAR_11, VAR_12, VAR_13;\n            stbi_uc *VAR_14;\n\n            VAR_10 = stbi__get16le(VAR_0);\n            VAR_11 = stbi__get16le(VAR_0);\n            VAR_12 = stbi__get16le(VAR_0);\n            VAR_13 = stbi__get16le(VAR_0);\n            if (((VAR_10 + VAR_12) > (VAR_1->w)) || ((VAR_11 + VAR_13) > (VAR_1->h)))\n               return stbi__errpuc(\"bad Image Descriptor\", \"Corrupt GIF\");\n\n            VAR_1->line_size = VAR_1->w * 4;\n            VAR_1->start_x = VAR_10 * 4;\n            VAR_1->start_y = VAR_11 * VAR_1->line_size;\n            VAR_1->max_x   = VAR_1->start_x + VAR_12 * 4;\n            VAR_1->max_y   = VAR_1->start_y + VAR_13 * VAR_1->line_size;\n            VAR_1->cur_x   = VAR_1->start_x;\n            VAR_1->cur_y   = VAR_1->start_y;\n\n            /* COMMENT_18 */\n            /* COMMENT_19 */\n            /* COMMENT_20 */\n            /* COMMENT_21 */\n            if (VAR_12 == 0)\n               VAR_1->cur_y = VAR_1->max_y;\n\n            VAR_1->lflags = stbi__get8(VAR_0);\n\n            if (VAR_1->lflags & 0x40) {\n               VAR_1->step = 8 * VAR_1->line_size; /* COMMENT_22 */\n               VAR_1->parse = 3;\n            } else {\n               VAR_1->step = VAR_1->line_size;\n               VAR_1->parse = 0;\n            }\n\n            if (VAR_1->lflags & 0x80) {\n               stbi__gif_parse_colortable(VAR_0,VAR_1->lpal, 2 << (VAR_1->lflags & 7), VAR_1->eflags & 0x01 ? VAR_1->transparent : -1);\n               VAR_1->color_table = (stbi_uc *) VAR_1->lpal;\n            } else if (VAR_1->flags & 0x80) {\n               VAR_1->color_table = (stbi_uc *) VAR_1->pal;\n            } else\n               return stbi__errpuc(\"missing color table\", \"Corrupt GIF\");            \n            \n            VAR_14 = stbi__process_gif_raster(VAR_0, VAR_1);\n            if (!VAR_14) return NULL;\n\n            /* COMMENT_23 */\n            VAR_8 = VAR_1->w * VAR_1->h; \n            if (VAR_6 && (VAR_1->bgindex > 0)) {\n               /* COMMENT_24 */\n               for (VAR_7 = 0; VAR_7 < VAR_8; ++VAR_7) {\n                  if (VAR_1->history[VAR_7] == 0) {\n                     VAR_1->pal[VAR_1->bgindex][3] = 255; /* COMMENT_25 */\n                     memcpy( &VAR_1->out[VAR_7 * 4], &VAR_1->pal[VAR_1->bgindex], 4 ); \n                  }\n               }\n            }\n\n            return VAR_14;\n         }\n\n         case 0x21: /* COMMENT_26 */\n         {\n            int VAR_15;\n            int VAR_16 = stbi__get8(VAR_0); \n            if (VAR_16 == 0xF9) { /* COMMENT_27 */\n               VAR_15 = stbi__get8(VAR_0);\n               if (VAR_15 == 4) {\n                  VAR_1->eflags = stbi__get8(VAR_0);\n                  VAR_1->delay = 10 * stbi__get16le(VAR_0); /* COMMENT_28 */\n\n                  /* COMMENT_29 */\n                  if (VAR_1->transparent >= 0) {\n                     VAR_1->pal[VAR_1->transparent][3] = 255; \n                  } \n                  if (VAR_1->eflags & 0x01) {\n                     VAR_1->transparent = stbi__get8(VAR_0);\n                     if (VAR_1->transparent >= 0) {\n                        VAR_1->pal[VAR_1->transparent][3] = 0; \n                     }\n                  } else {\n                     /* COMMENT_30 */\n                     stbi__skip(VAR_0, 1); \n                     VAR_1->transparent = -1; \n                  }\n               } else {\n                  stbi__skip(VAR_0, VAR_15);\n                  break;\n               }\n            } \n            while ((VAR_15 = stbi__get8(VAR_0)) != 0) {\n               stbi__skip(VAR_0, VAR_15);\n            }\n            break;\n         }\n\n         case 0x3B: /* COMMENT_31 */\n            return (stbi_uc *) VAR_0; /* COMMENT_32 */\n\n         default:\n            return stbi__errpuc(\"unknown code\", \"Corrupt GIF\");\n      }\n   }\n}",
  "func_graph_path": "nothings/stb/6570d6a825e2982a4f1c9ae7173a737eed4dd6f0/stb_image.h/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -9,19 +9,22 @@\n    // on first frame, any non-written pixels get the background colour (non-transparent)\n    first_frame = 0; \n    if (g->out == 0) {\n-      if (!stbi__gif_header(s, g, comp,0))     return 0; // stbi__g_failure_reason set by stbi__gif_header\n-      g->out = (stbi_uc *) stbi__malloc(4 * g->w * g->h);\n-      g->background = (stbi_uc *) stbi__malloc(4 * g->w * g->h); \n-      g->history = (stbi_uc *) stbi__malloc(g->w * g->h); \n+      if (!stbi__gif_header(s, g, comp,0)) return 0; // stbi__g_failure_reason set by stbi__gif_header\n+      if (!stbi__mad3sizes_valid(4, g->w, g->h, 0))\n+         return stbi__errpuc(\"too large\", \"GIF image is too large\");\n+      pcount = g->w * g->h;\n+      g->out = (stbi_uc *) stbi__malloc(4 * pcount);\n+      g->background = (stbi_uc *) stbi__malloc(4 * pcount);\n+      g->history = (stbi_uc *) stbi__malloc(pcount);\n       if (!g->out || !g->background || !g->history)\n          return stbi__errpuc(\"outofmem\", \"Out of memory\");\n \n       // image is treated as \"transparent\" at the start - ie, nothing overwrites the current background; \n       // background colour is only used for pixels that are not rendered first frame, after that \"background\"\n       // color refers to the color that was there the previous frame. \n-      memset( g->out, 0x00, 4 * g->w * g->h ); \n-      memset( g->background, 0x00, 4 * g->w * g->h ); // state of the background (starts transparent)\n-      memset( g->history, 0x00, g->w * g->h );        // pixels that were affected previous frame\n+      memset(g->out, 0x00, 4 * pcount);\n+      memset(g->background, 0x00, 4 * pcount); // state of the background (starts transparent)\n+      memset(g->history, 0x00, pcount);        // pixels that were affected previous frame\n       first_frame = 1; \n    } else {\n       // second frame - how do we dispoase of the previous one?",
  "diff_line_info": {
    "deleted_lines": [
      "      if (!stbi__gif_header(s, g, comp,0))     return 0; // stbi__g_failure_reason set by stbi__gif_header",
      "      g->out = (stbi_uc *) stbi__malloc(4 * g->w * g->h);",
      "      g->background = (stbi_uc *) stbi__malloc(4 * g->w * g->h); ",
      "      g->history = (stbi_uc *) stbi__malloc(g->w * g->h); ",
      "      memset( g->out, 0x00, 4 * g->w * g->h ); ",
      "      memset( g->background, 0x00, 4 * g->w * g->h ); // state of the background (starts transparent)",
      "      memset( g->history, 0x00, g->w * g->h );        // pixels that were affected previous frame"
    ],
    "added_lines": [
      "      if (!stbi__gif_header(s, g, comp,0)) return 0; // stbi__g_failure_reason set by stbi__gif_header",
      "      if (!stbi__mad3sizes_valid(4, g->w, g->h, 0))",
      "         return stbi__errpuc(\"too large\", \"GIF image is too large\");",
      "      pcount = g->w * g->h;",
      "      g->out = (stbi_uc *) stbi__malloc(4 * pcount);",
      "      g->background = (stbi_uc *) stbi__malloc(4 * pcount);",
      "      g->history = (stbi_uc *) stbi__malloc(pcount);",
      "      memset(g->out, 0x00, 4 * pcount);",
      "      memset(g->background, 0x00, 4 * pcount); // state of the background (starts transparent)",
      "      memset(g->history, 0x00, pcount);        // pixels that were affected previous frame"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/nothings/stb/pull/725",
  "description": {
    "pr_info": {
      "title": "stb_image: Fix multiple bugs in GIF decoder.",
      "number": 725
    },
    "comment": [
      "1. Check not just g->out allocation for failure; also make sure\r\n   that the image allocs don't overflow.\r\n2. If an image descriptor specified a 0-width image, this could be\r\n   used to produce an out-of-bounds write.\r\n3. Fix memory leak in case an error occurs during decoding.\r\n\r\nFixes issue #614.\r\nFixes issue #656.\r\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "The patch adds validation checks for GIF image sizes to prevent buffer overflows and fixes a memory leak, indicating a security vulnerability fix.\n\n**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.9\n\nThe commit addresses buffer overflow and memory leak issues, which are security concerns. The code changes validate image size and handle memory correctly, confirming it's a security fix. The high confidence reflects the clear alignment between the description and code.\n\n**Final Output:**  \n**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9"
}