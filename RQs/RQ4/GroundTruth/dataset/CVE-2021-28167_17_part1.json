{
  "cve_id": "CVE-2021-28167",
  "cwe_ids": [
    "CWE-909"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "eclipse-openj9/openj9",
  "commit_msg": "Correctly load/initialize classes when using ConstantPool\n\n- do not load classes in the \"ifLoaded\" calls\n- never intitialize classes in the natives\n- do not update the constant pool when querying from the natives\n\nFixes: #12016\n\n[ci skip]\n\nSigned-off-by: Graham Chapman <graham_chapman@ca.ibm.com>",
  "commit_hash": "840f3af31a5b8d2d395d9367c826ed756e380fb9",
  "git_url": "https://github.com/eclipse-openj9/openj9/commit/840f3af31a5b8d2d395d9367c826ed756e380fb9",
  "file_path": "runtime/vm/resolvesupport.cpp",
  "func_name": "resolveStaticSplitMethodRef",
  "func_before": "J9Method *   \nresolveStaticSplitMethodRef(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA splitTableIndex, UDATA resolveFlags)\n{\n\tJ9RAMStaticMethodRef *ramStaticMethodRef = (J9RAMStaticMethodRef *)&vmStruct->floatTemp1;\n\tU_16 cpIndex = *(J9ROMCLASS_STATICSPLITMETHODREFINDEXES(ramCP->ramClass->romClass) + splitTableIndex);\n\tJ9Method *method = ramCP->ramClass->staticSplitMethodTable[splitTableIndex];\n\n\tif (method == (J9Method*)vmStruct->javaVM->initialMethods.initialStaticMethod) {\n\t\tmethod = resolveStaticMethodRefInto(vmStruct, ramCP, cpIndex, resolveFlags, ramStaticMethodRef);\n\n\t\tif (NULL != method) {\n\t\t\t/* Check for <clinit> case. */\n\t\t\tif (((resolveFlags & J9_RESOLVE_FLAG_CHECK_CLINIT) == J9_RESOLVE_FLAG_CHECK_CLINIT)\n\t\t\t\t&& (J9_CLASS_FROM_METHOD(method)->initializeStatus == (UDATA)vmStruct)\n\t\t\t) {\n\t\t\t\treturn (J9Method *) -1;\n\t\t\t} else {\n\t\t\t\tramCP->ramClass->staticSplitMethodTable[splitTableIndex] = method;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn method;\n}",
  "abstract_func_before": "J9Method *   \nresolveStaticSplitMethodRef(J9VMThread *VAR_0, J9ConstantPool *VAR_1, UDATA VAR_2, UDATA VAR_3)\n{\n\tJ9RAMStaticMethodRef *VAR_4 = (J9RAMStaticMethodRef *)&VAR_0->floatTemp1;\n\tU_16 VAR_5 = *(J9ROMCLASS_STATICSPLITMETHODREFINDEXES(VAR_1->ramClass->romClass) + VAR_2);\n\tJ9Method *VAR_6 = VAR_1->ramClass->staticSplitMethodTable[VAR_2];\n\n\tif (VAR_6 == (J9Method*)VAR_0->javaVM->initialMethods.initialStaticMethod) {\n\t\tVAR_6 = resolveStaticMethodRefInto(VAR_0, VAR_1, VAR_5, VAR_3, VAR_4);\n\n\t\tif (NULL != VAR_6) {\n\t\t\t/* COMMENT_0 */\n\t\t\tif (((VAR_3 & VAR_7) == VAR_7)\n\t\t\t\t&& (J9_CLASS_FROM_METHOD(VAR_6)->initializeStatus == (UDATA)VAR_0)\n\t\t\t) {\n\t\t\t\treturn (J9Method *) -1;\n\t\t\t} else {\n\t\t\t\tVAR_1->ramClass->staticSplitMethodTable[VAR_2] = VAR_6;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn VAR_6;\n}",
  "func_graph_path_before": "eclipse-openj9/openj9/840f3af31a5b8d2d395d9367c826ed756e380fb9/resolvesupport.cpp/vul/before/9.json",
  "func": "J9Method *   \nresolveStaticSplitMethodRef(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA splitTableIndex, UDATA resolveFlags)\n{\n\tJ9RAMStaticMethodRef *ramStaticMethodRef = (J9RAMStaticMethodRef *)&vmStruct->floatTemp1;\n\tU_16 cpIndex = *(J9ROMCLASS_STATICSPLITMETHODREFINDEXES(ramCP->ramClass->romClass) + splitTableIndex);\n\tJ9Method *method = ramCP->ramClass->staticSplitMethodTable[splitTableIndex];\n\n\tif (method == (J9Method*)vmStruct->javaVM->initialMethods.initialStaticMethod) {\n\t\tmethod = resolveStaticMethodRefInto(vmStruct, ramCP, cpIndex, resolveFlags, ramStaticMethodRef);\n\n\t\tif (NULL != method) {\n\t\t\t/* Check for <clinit> case. */\n\t\t\tif (((resolveFlags & J9_RESOLVE_FLAG_CHECK_CLINIT) == J9_RESOLVE_FLAG_CHECK_CLINIT)\n\t\t\t\t&& (J9_CLASS_FROM_METHOD(method)->initializeStatus == (UDATA)vmStruct)\n\t\t\t) {\n\t\t\t\treturn (J9Method *) -1;\n\t\t\t} else if (J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\t\t\t\n\t\t\t\tramCP->ramClass->staticSplitMethodTable[splitTableIndex] = method;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn method;\n}",
  "abstract_func": "J9Method *   \nresolveStaticSplitMethodRef(J9VMThread *VAR_0, J9ConstantPool *VAR_1, UDATA VAR_2, UDATA VAR_3)\n{\n\tJ9RAMStaticMethodRef *VAR_4 = (J9RAMStaticMethodRef *)&VAR_0->floatTemp1;\n\tU_16 VAR_5 = *(J9ROMCLASS_STATICSPLITMETHODREFINDEXES(VAR_1->ramClass->romClass) + VAR_2);\n\tJ9Method *VAR_6 = VAR_1->ramClass->staticSplitMethodTable[VAR_2];\n\n\tif (VAR_6 == (J9Method*)VAR_0->javaVM->initialMethods.initialStaticMethod) {\n\t\tVAR_6 = resolveStaticMethodRefInto(VAR_0, VAR_1, VAR_5, VAR_3, VAR_4);\n\n\t\tif (NULL != VAR_6) {\n\t\t\t/* COMMENT_0 */\n\t\t\tif (((VAR_3 & VAR_7) == VAR_7)\n\t\t\t\t&& (J9_CLASS_FROM_METHOD(VAR_6)->initializeStatus == (UDATA)VAR_0)\n\t\t\t) {\n\t\t\t\treturn (J9Method *) -1;\n\t\t\t} else if (J9_ARE_NO_BITS_SET(VAR_3, VAR_8)) {\t\t\t\n\t\t\t\tVAR_1->ramClass->staticSplitMethodTable[VAR_2] = VAR_6;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn VAR_6;\n}",
  "func_graph_path": "eclipse-openj9/openj9/840f3af31a5b8d2d395d9367c826ed756e380fb9/resolvesupport.cpp/vul/after/9.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -14,7 +14,7 @@\n \t\t\t\t&& (J9_CLASS_FROM_METHOD(method)->initializeStatus == (UDATA)vmStruct)\n \t\t\t) {\n \t\t\t\treturn (J9Method *) -1;\n-\t\t\t} else {\n+\t\t\t} else if (J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\t\t\t\n \t\t\t\tramCP->ramClass->staticSplitMethodTable[splitTableIndex] = method;\n \t\t\t}\n \t\t}",
  "diff_line_info": {
    "deleted_lines": [
      "\t\t\t} else {"
    ],
    "added_lines": [
      "\t\t\t} else if (J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\t\t\t"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/eclipse-openj9/openj9/pull/12148",
  "description": {
    "pr_info": {
      "title": "Correctly load/initialize classes when using ConstantPool",
      "number": 12148
    },
    "comment": [
      "- do not load classes in the \"ifLoaded\" calls\r\n- never intitialize classes in the natives\r\n- do not update the constant pool when querying from the natives\r\n\r\nFixes: #12016\r\n\r\n[ci skip]\r\n\r\nSigned-off-by: Graham Chapman <graham_chapman@ca.ibm.com>",
      "jenkins test sanity,extended zlinux jdk11",
      "jenkins compile win jdk8",
      "@gacholio can you please open another PR for the 0.26 stream",
      "https://github.com/eclipse/openj9/pull/12164"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "Final Classification: Defect Remediation & Feature Upgrades\nConfidence: 0.9 \n\nThe patch addresses internal class loading and initialization issues, indicating a non-security defect fix. Changes target proper handling of classes and constant pool, enhancing core functionality rather than security."
}