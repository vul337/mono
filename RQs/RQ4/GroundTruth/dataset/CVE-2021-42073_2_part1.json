{
  "cve_id": "CVE-2021-42073",
  "cwe_ids": [
    "CWE-384"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "debauchee/barrier",
  "commit_msg": "Implement client identity verification\n\nThis commit fixes two security vulnerabilities: CVE-2021-42072 and\nCVE-2021-42073.\n\nThe issues have been reported by Matthias Gerstner <mgerstner@suse.de>.",
  "commit_hash": "229abab99f39f11624e5651f819e7f1f8eddedcc",
  "git_url": "https://github.com/debauchee/barrier/commit/229abab99f39f11624e5651f819e7f1f8eddedcc",
  "file_path": "src/lib/net/SecureSocket.cpp",
  "func_name": "SecureSocket::verify_cert_fingerprint",
  "func_before": "bool SecureSocket::verify_cert_fingerprint(const barrier::fs::path& fingerprint_db_path)\n{\n    // calculate received certificate fingerprint\n    barrier::FingerprintData fingerprint_sha1, fingerprint_sha256;\n    try {\n        auto* cert = SSL_get_peer_certificate(m_ssl->m_ssl);\n        fingerprint_sha1 = barrier::get_ssl_cert_fingerprint(cert,\n                                                             barrier::FingerprintType::SHA1);\n        fingerprint_sha256 = barrier::get_ssl_cert_fingerprint(cert,\n                                                               barrier::FingerprintType::SHA256);\n    } catch (const std::exception& e) {\n        LOG((CLOG_ERR \"%s\", e.what()));\n        return false;\n    }\n\n    // note: the GUI parses the following two lines of logs, don't change unnecessarily\n    LOG((CLOG_NOTE \"server fingerprint (SHA1): %s (SHA256): %s\",\n         barrier::format_ssl_fingerprint(fingerprint_sha1.data).c_str(),\n         barrier::format_ssl_fingerprint(fingerprint_sha256.data).c_str()));\n\n    // Provide debug hint as to what file is being used to verify fingerprint trust\n    LOG((CLOG_NOTE \"fingerprint_db_path: %s\", fingerprint_db_path.u8string().c_str()));\n\n    barrier::FingerprintDatabase db;\n    db.read(fingerprint_db_path);\n\n    if (!db.fingerprints().empty()) {\n        LOG((CLOG_NOTE \"Read %d fingerprints from: %s\", db.fingerprints().size(),\n             fingerprint_db_path.u8string().c_str()));\n    } else {\n        LOG((CLOG_NOTE \"Could not read fingerprints from: %s\",\n             fingerprint_db_path.u8string().c_str()));\n    }\n\n    if (db.is_trusted(fingerprint_sha256)) {\n        LOG((CLOG_NOTE \"Fingerprint matches trusted fingerprint\"));\n        return true;\n    } else {\n        LOG((CLOG_NOTE \"Fingerprint does not match trusted fingerprint\"));\n        return false;\n    }\n}",
  "abstract_func_before": "bool SecureSocket::verify_cert_fingerprint(const barrier::fs::path& VAR_0)\n{\n    /* COMMENT_0 */\n    barrier::FingerprintData VAR_1, VAR_2;\n    try {\n        auto* VAR_3 = SSL_get_peer_certificate(VAR_4->m_ssl);\n        VAR_1 = barrier::get_ssl_cert_fingerprint(VAR_3,\n                                                             barrier::FingerprintType::SHA1);\n        VAR_2 = barrier::get_ssl_cert_fingerprint(VAR_3,\n                                                               barrier::FingerprintType::SHA256);\n    } catch (const std::exception& VAR_5) {\n        LOG((VAR_6 \"%s\", VAR_5.what()));\n        return false;\n    }\n\n    /* COMMENT_1 */\n    LOG((VAR_7 \"server fingerprint (SHA1): %s (SHA256): %s\",\n         barrier::format_ssl_fingerprint(VAR_1.data).c_str(),\n         barrier::format_ssl_fingerprint(VAR_2.data).c_str()));\n\n    /* COMMENT_2 */\n    LOG((VAR_7 \"fingerprint_db_path: %s\", VAR_0.u8string().c_str()));\n\n    barrier::FingerprintDatabase VAR_8;\n    VAR_8.read(VAR_0);\n\n    if (!VAR_8.fingerprints().empty()) {\n        LOG((VAR_7 \"Read %d fingerprints from: %s\", VAR_8.fingerprints().size(),\n             VAR_0.u8string().c_str()));\n    } else {\n        LOG((VAR_7 \"Could not read fingerprints from: %s\",\n             VAR_0.u8string().c_str()));\n    }\n\n    if (VAR_8.is_trusted(VAR_2)) {\n        LOG((VAR_7 \"Fingerprint matches trusted fingerprint\"));\n        return true;\n    } else {\n        LOG((VAR_7 \"Fingerprint does not match trusted fingerprint\"));\n        return false;\n    }\n}",
  "func_graph_path_before": "debauchee/barrier/229abab99f39f11624e5651f819e7f1f8eddedcc/SecureSocket.cpp/vul/before/0.json",
  "func": "bool SecureSocket::verify_cert_fingerprint(const barrier::fs::path& fingerprint_db_path)\n{\n    // calculate received certificate fingerprint\n    barrier::FingerprintData fingerprint_sha1, fingerprint_sha256;\n    try {\n        auto* cert = SSL_get_peer_certificate(m_ssl->m_ssl);\n        fingerprint_sha1 = barrier::get_ssl_cert_fingerprint(cert,\n                                                             barrier::FingerprintType::SHA1);\n        fingerprint_sha256 = barrier::get_ssl_cert_fingerprint(cert,\n                                                               barrier::FingerprintType::SHA256);\n    } catch (const std::exception& e) {\n        LOG((CLOG_ERR \"%s\", e.what()));\n        return false;\n    }\n\n    // note: the GUI parses the following two lines of logs, don't change unnecessarily\n    LOG((CLOG_NOTE \"peer fingerprint (SHA1): %s (SHA256): %s\",\n         barrier::format_ssl_fingerprint(fingerprint_sha1.data).c_str(),\n         barrier::format_ssl_fingerprint(fingerprint_sha256.data).c_str()));\n\n    // Provide debug hint as to what file is being used to verify fingerprint trust\n    LOG((CLOG_NOTE \"fingerprint_db_path: %s\", fingerprint_db_path.u8string().c_str()));\n\n    barrier::FingerprintDatabase db;\n    db.read(fingerprint_db_path);\n\n    if (!db.fingerprints().empty()) {\n        LOG((CLOG_NOTE \"Read %d fingerprints from: %s\", db.fingerprints().size(),\n             fingerprint_db_path.u8string().c_str()));\n    } else {\n        LOG((CLOG_NOTE \"Could not read fingerprints from: %s\",\n             fingerprint_db_path.u8string().c_str()));\n    }\n\n    if (db.is_trusted(fingerprint_sha256)) {\n        LOG((CLOG_NOTE \"Fingerprint matches trusted fingerprint\"));\n        return true;\n    } else {\n        LOG((CLOG_NOTE \"Fingerprint does not match trusted fingerprint\"));\n        return false;\n    }\n}",
  "abstract_func": "bool SecureSocket::verify_cert_fingerprint(const barrier::fs::path& VAR_0)\n{\n    /* COMMENT_0 */\n    barrier::FingerprintData VAR_1, VAR_2;\n    try {\n        auto* VAR_3 = SSL_get_peer_certificate(VAR_4->m_ssl);\n        VAR_1 = barrier::get_ssl_cert_fingerprint(VAR_3,\n                                                             barrier::FingerprintType::SHA1);\n        VAR_2 = barrier::get_ssl_cert_fingerprint(VAR_3,\n                                                               barrier::FingerprintType::SHA256);\n    } catch (const std::exception& VAR_5) {\n        LOG((VAR_6 \"%s\", VAR_5.what()));\n        return false;\n    }\n\n    /* COMMENT_1 */\n    LOG((VAR_7 \"peer fingerprint (SHA1): %s (SHA256): %s\",\n         barrier::format_ssl_fingerprint(VAR_1.data).c_str(),\n         barrier::format_ssl_fingerprint(VAR_2.data).c_str()));\n\n    /* COMMENT_2 */\n    LOG((VAR_7 \"fingerprint_db_path: %s\", VAR_0.u8string().c_str()));\n\n    barrier::FingerprintDatabase VAR_8;\n    VAR_8.read(VAR_0);\n\n    if (!VAR_8.fingerprints().empty()) {\n        LOG((VAR_7 \"Read %d fingerprints from: %s\", VAR_8.fingerprints().size(),\n             VAR_0.u8string().c_str()));\n    } else {\n        LOG((VAR_7 \"Could not read fingerprints from: %s\",\n             VAR_0.u8string().c_str()));\n    }\n\n    if (VAR_8.is_trusted(VAR_2)) {\n        LOG((VAR_7 \"Fingerprint matches trusted fingerprint\"));\n        return true;\n    } else {\n        LOG((VAR_7 \"Fingerprint does not match trusted fingerprint\"));\n        return false;\n    }\n}",
  "func_graph_path": "debauchee/barrier/229abab99f39f11624e5651f819e7f1f8eddedcc/SecureSocket.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -14,7 +14,7 @@\n     }\n \n     // note: the GUI parses the following two lines of logs, don't change unnecessarily\n-    LOG((CLOG_NOTE \"server fingerprint (SHA1): %s (SHA256): %s\",\n+    LOG((CLOG_NOTE \"peer fingerprint (SHA1): %s (SHA256): %s\",\n          barrier::format_ssl_fingerprint(fingerprint_sha1.data).c_str(),\n          barrier::format_ssl_fingerprint(fingerprint_sha256.data).c_str()));\n ",
  "diff_line_info": {
    "deleted_lines": [
      "    LOG((CLOG_NOTE \"server fingerprint (SHA1): %s (SHA256): %s\","
    ],
    "added_lines": [
      "    LOG((CLOG_NOTE \"peer fingerprint (SHA1): %s (SHA256): %s\","
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/debauchee/barrier/pull/1346",
  "description": {
    "pr_info": {
      "title": "Implement client identity verification [SECURITY VULNERABILITIES CVE-2021-42072, CVE-2021-42073]",
      "number": 1346
    },
    "comment": [
      "This PR implements client identity verification. Essentially server gets the same process of accepting and rejecting clients like the clients can accept or reject the server. This is important because even though the client can't move the mouse on the server, it can still receive input and potentially set the clipboard.\r\n\r\nThis PR fixes the following security vulnerabilities:\r\n\r\n - CVE-2021-42072 server does not verify client identity (certificate fingerprint)\r\n - CVE-2021-42073 By guessing/listening in on valid client names server clipboard content can be manipulated.\r\n\r\nThe issues have been reported by Matthias Gerstner <mgerstner@suse.de> @mgerstner. Matthias also provided insights into how best to fix the issues, precise reproduction steps and any used tools and made the maintainer's life as pleasant as possible. Thank you!"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95\n\nThe patch clearly addresses specific CVEs by modifying code to verify client identities, which directly enhances security against known exploits."
}