{
  "cve_id": "CVE-2021-42863",
  "cwe_ids": [
    "CWE-120"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "jerryscript-project/jerryscript",
  "commit_msg": "Force value conversion in case of TypedArray filter method\n\nDuring the execution of the TypedArray filter method it is possible\nto have a different sized output TypedArray than the input one.\nWhen copying the data to the output array the values must be\ncorrectly converted to the output TypedArray's value range.\n\nFixes: #4793\n\nJerryScript-DCO-1.0-Signed-off-by: Peter Gal pgal.usz@partner.samsung.com",
  "commit_hash": "6a21f4069a0e792dc38154b2b3aaf57a83924a61",
  "git_url": "https://github.com/jerryscript-project/jerryscript/commit/6a21f4069a0e792dc38154b2b3aaf57a83924a61",
  "file_path": "jerry-core/ecma/builtin-objects/typedarray/ecma-builtin-typedarray-prototype.c",
  "func_name": "ecma_builtin_typedarray_prototype_filter",
  "func_before": "static ecma_value_t\necma_builtin_typedarray_prototype_filter (ecma_value_t this_arg, /**< this object */\n                                          ecma_typedarray_info_t *info_p, /**< object info */\n                                          ecma_value_t cb_func_val, /**< callback function */\n                                          ecma_value_t cb_this_arg) /**< 'this' of the callback function */\n{\n  ecma_typedarray_getter_fn_t getter_cb = ecma_get_typedarray_getter_fn (info_p->id);\n\n  ecma_object_t *func_object_p = ecma_get_object_from_value (cb_func_val);\n  ecma_value_t ret_value = ECMA_VALUE_ERROR;\n\n  // TODO: 22.2.3.9, 7-8.\n  if (info_p->length == 0)\n  {\n    return ecma_op_create_typedarray_with_type_and_length (info_p->id, 0);\n  }\n\n  JMEM_DEFINE_LOCAL_ARRAY (pass_value_list_p, info_p->length * info_p->element_size, lit_utf8_byte_t);\n\n  lit_utf8_byte_t *pass_value_p = pass_value_list_p;\n  uint32_t byte_pos = 0;\n\n  for (uint32_t index = 0; index < info_p->length; index++)\n  {\n    ecma_value_t current_index = ecma_make_uint32_value (index);\n    ecma_value_t get_value = getter_cb (info_p->buffer_p + byte_pos);\n\n    JERRY_ASSERT (ecma_is_value_number (get_value) || ecma_is_value_bigint (get_value));\n\n    ecma_value_t call_args[] = { get_value, current_index, this_arg };\n\n    ecma_value_t call_value = ecma_op_function_call (func_object_p, cb_this_arg, call_args, 3);\n\n    ecma_fast_free_value (current_index);\n    ecma_fast_free_value (get_value);\n\n    if (ECMA_IS_VALUE_ERROR (call_value))\n    {\n      goto cleanup;\n    }\n\n    if (ecma_arraybuffer_is_detached (info_p->array_buffer_p))\n    {\n      ecma_free_value (call_value);\n      ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_arraybuffer_is_detached));\n      goto cleanup;\n    }\n\n    if (ecma_op_to_boolean (call_value))\n    {\n      memcpy (pass_value_p, info_p->buffer_p + byte_pos, info_p->element_size);\n      pass_value_p += info_p->element_size;\n    }\n\n    byte_pos += info_p->element_size;\n\n    ecma_free_value (call_value);\n  }\n\n  uint32_t pass_num = (uint32_t) ((pass_value_p - pass_value_list_p) >> info_p->shift);\n\n  ecma_value_t collected = ecma_make_number_value (pass_num);\n  ret_value = ecma_typedarray_species_create (this_arg, &collected, 1);\n  ecma_free_value (collected);\n\n  if (!ECMA_IS_VALUE_ERROR (ret_value))\n  {\n    ecma_object_t *obj_p = ecma_get_object_from_value (ret_value);\n\n    JERRY_ASSERT (ecma_typedarray_get_offset (obj_p) == 0);\n\n    memcpy (ecma_typedarray_get_buffer (obj_p),\n            pass_value_list_p,\n            (size_t) (pass_value_p - pass_value_list_p));\n  }\n\ncleanup:\n  JMEM_FINALIZE_LOCAL_ARRAY (pass_value_list_p);\n\n  return ret_value;\n}",
  "abstract_func_before": "static ecma_value_t\necma_builtin_typedarray_prototype_filter (ecma_value_t VAR_0, /* COMMENT_0 */\n                                          ecma_typedarray_info_t *VAR_1, /* COMMENT_1 */\n                                          ecma_value_t VAR_2, /* COMMENT_2 */\n                                          ecma_value_t VAR_3) /* COMMENT_3 */\n{\n  ecma_typedarray_getter_fn_t VAR_4 = ecma_get_typedarray_getter_fn (VAR_1->id);\n\n  ecma_object_t *VAR_5 = ecma_get_object_from_value (VAR_2);\n  ecma_value_t VAR_6 = VAR_7;\n\n  /* COMMENT_4 */\n  if (VAR_1->length == 0)\n  {\n    return ecma_op_create_typedarray_with_type_and_length (VAR_1->id, 0);\n  }\n\n  JMEM_DEFINE_LOCAL_ARRAY (VAR_8, VAR_1->length * VAR_1->element_size, VAR_9);\n\n  lit_utf8_byte_t *VAR_10 = VAR_8;\n  uint32_t VAR_11 = 0;\n\n  for (uint32_t VAR_12 = 0; VAR_12 < VAR_1->length; VAR_12++)\n  {\n    ecma_value_t VAR_13 = ecma_make_uint32_value (VAR_12);\n    ecma_value_t VAR_14 = VAR_4 (VAR_1->buffer_p + VAR_11);\n\n    JERRY_ASSERT (ecma_is_value_number (VAR_14) || ecma_is_value_bigint (VAR_14));\n\n    ecma_value_t VAR_15[] = { VAR_14, VAR_13, VAR_0 };\n\n    ecma_value_t VAR_16 = ecma_op_function_call (VAR_5, VAR_3, VAR_15, 3);\n\n    ecma_fast_free_value (VAR_13);\n    ecma_fast_free_value (VAR_14);\n\n    if (ECMA_IS_VALUE_ERROR (VAR_16))\n    {\n      goto cleanup;\n    }\n\n    if (ecma_arraybuffer_is_detached (VAR_1->array_buffer_p))\n    {\n      ecma_free_value (VAR_16);\n      ecma_raise_type_error (ECMA_ERR_MSG (VAR_17));\n      goto cleanup;\n    }\n\n    if (ecma_op_to_boolean (VAR_16))\n    {\n      memcpy (VAR_10, VAR_1->buffer_p + VAR_11, VAR_1->element_size);\n      VAR_10 += VAR_1->element_size;\n    }\n\n    VAR_11 += VAR_1->element_size;\n\n    ecma_free_value (VAR_16);\n  }\n\n  uint32_t VAR_18 = (uint32_t) ((VAR_10 - VAR_8) >> VAR_1->shift);\n\n  ecma_value_t VAR_19 = ecma_make_number_value (VAR_18);\n  VAR_6 = ecma_typedarray_species_create (VAR_0, &VAR_19, 1);\n  ecma_free_value (VAR_19);\n\n  if (!ECMA_IS_VALUE_ERROR (VAR_6))\n  {\n    ecma_object_t *VAR_20 = ecma_get_object_from_value (VAR_6);\n\n    JERRY_ASSERT (ecma_typedarray_get_offset (VAR_20) == 0);\n\n    memcpy (ecma_typedarray_get_buffer (VAR_20),\n            VAR_8,\n            (size_t) (VAR_10 - VAR_8));\n  }\n\ncleanup:\n  JMEM_FINALIZE_LOCAL_ARRAY (VAR_8);\n\n  return VAR_6;\n}",
  "func_graph_path_before": "jerryscript-project/jerryscript/6a21f4069a0e792dc38154b2b3aaf57a83924a61/ecma-builtin-typedarray-prototype.c/vul/before/0.json",
  "func": "static ecma_value_t\necma_builtin_typedarray_prototype_filter (ecma_value_t this_arg, /**< this object */\n                                          ecma_typedarray_info_t *info_p, /**< object info */\n                                          ecma_value_t cb_func_val, /**< callback function */\n                                          ecma_value_t cb_this_arg) /**< 'this' of the callback function */\n{\n  ecma_typedarray_getter_fn_t getter_cb = ecma_get_typedarray_getter_fn (info_p->id);\n\n  ecma_object_t *func_object_p = ecma_get_object_from_value (cb_func_val);\n  ecma_value_t ret_value = ECMA_VALUE_ERROR;\n\n  // TODO: 22.2.3.9, 7-8.\n  if (info_p->length == 0)\n  {\n    return ecma_op_create_typedarray_with_type_and_length (info_p->id, 0);\n  }\n\n  ecma_collection_t *collected_p = ecma_new_collection ();\n  uint32_t byte_pos = 0;\n\n  for (uint32_t index = 0; index < info_p->length; index++)\n  {\n    ecma_value_t current_index = ecma_make_uint32_value (index);\n    ecma_value_t get_value = getter_cb (info_p->buffer_p + byte_pos);\n\n    JERRY_ASSERT (ecma_is_value_number (get_value) || ecma_is_value_bigint (get_value));\n\n    ecma_value_t call_args[] = { get_value, current_index, this_arg };\n\n    ecma_value_t call_value = ecma_op_function_call (func_object_p, cb_this_arg, call_args, 3);\n\n    ecma_fast_free_value (current_index);\n\n    if (ECMA_IS_VALUE_ERROR (call_value))\n    {\n      ecma_fast_free_value (get_value);\n      goto cleanup;\n    }\n\n    if (ecma_arraybuffer_is_detached (info_p->array_buffer_p))\n    {\n      ecma_free_value (call_value);\n      ecma_fast_free_value (get_value);\n      ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_arraybuffer_is_detached));\n      goto cleanup;\n    }\n\n    if (ecma_op_to_boolean (call_value))\n    {\n      ecma_collection_push_back (collected_p, get_value);\n    }\n    else\n    {\n      ecma_fast_free_value (get_value);\n    }\n\n    byte_pos += info_p->element_size;\n    ecma_fast_free_value (call_value);\n  }\n\n  ecma_value_t collected = ecma_make_number_value (collected_p->item_count);\n  ret_value = ecma_typedarray_species_create (this_arg, &collected, 1);\n  ecma_free_value (collected);\n\n  if (!ECMA_IS_VALUE_ERROR (ret_value))\n  {\n    ecma_object_t *obj_p = ecma_get_object_from_value (ret_value);\n    ecma_typedarray_info_t target_info = ecma_typedarray_get_info (obj_p);\n\n    JERRY_ASSERT (target_info.offset == 0);\n\n    ecma_typedarray_setter_fn_t target_typedarray_setter_cb = ecma_get_typedarray_setter_fn (target_info.id);\n    uint32_t target_byte_index = 0;\n    for (uint32_t idx = 0; idx < collected_p->item_count; idx++)\n    {\n      ecma_value_t set_element = target_typedarray_setter_cb (target_info.buffer_p + target_byte_index,\n                                                              collected_p->buffer_p[idx]);\n\n      if (ECMA_IS_VALUE_ERROR (set_element))\n      {\n        goto cleanup;\n      }\n\n      target_byte_index += target_info.element_size;\n    }\n  }\n\ncleanup:\n  ecma_collection_free (collected_p);\n\n  return ret_value;\n}",
  "abstract_func": "static ecma_value_t\necma_builtin_typedarray_prototype_filter (ecma_value_t VAR_0, /* COMMENT_0 */\n                                          ecma_typedarray_info_t *VAR_1, /* COMMENT_1 */\n                                          ecma_value_t VAR_2, /* COMMENT_2 */\n                                          ecma_value_t VAR_3) /* COMMENT_3 */\n{\n  ecma_typedarray_getter_fn_t VAR_4 = ecma_get_typedarray_getter_fn (VAR_1->id);\n\n  ecma_object_t *VAR_5 = ecma_get_object_from_value (VAR_2);\n  ecma_value_t VAR_6 = VAR_7;\n\n  /* COMMENT_4 */\n  if (VAR_1->length == 0)\n  {\n    return ecma_op_create_typedarray_with_type_and_length (VAR_1->id, 0);\n  }\n\n  ecma_collection_t *VAR_8 = ecma_new_collection ();\n  uint32_t VAR_9 = 0;\n\n  for (uint32_t VAR_10 = 0; VAR_10 < VAR_1->length; VAR_10++)\n  {\n    ecma_value_t VAR_11 = ecma_make_uint32_value (VAR_10);\n    ecma_value_t VAR_12 = VAR_4 (VAR_1->buffer_p + VAR_9);\n\n    JERRY_ASSERT (ecma_is_value_number (VAR_12) || ecma_is_value_bigint (VAR_12));\n\n    ecma_value_t VAR_13[] = { VAR_12, VAR_11, VAR_0 };\n\n    ecma_value_t VAR_14 = ecma_op_function_call (VAR_5, VAR_3, VAR_13, 3);\n\n    ecma_fast_free_value (VAR_11);\n\n    if (ECMA_IS_VALUE_ERROR (VAR_14))\n    {\n      ecma_fast_free_value (VAR_12);\n      goto cleanup;\n    }\n\n    if (ecma_arraybuffer_is_detached (VAR_1->array_buffer_p))\n    {\n      ecma_free_value (VAR_14);\n      ecma_fast_free_value (VAR_12);\n      ecma_raise_type_error (ECMA_ERR_MSG (VAR_15));\n      goto cleanup;\n    }\n\n    if (ecma_op_to_boolean (VAR_14))\n    {\n      ecma_collection_push_back (VAR_8, VAR_12);\n    }\n    else\n    {\n      ecma_fast_free_value (VAR_12);\n    }\n\n    VAR_9 += VAR_1->element_size;\n    ecma_fast_free_value (VAR_14);\n  }\n\n  ecma_value_t VAR_16 = ecma_make_number_value (VAR_8->item_count);\n  VAR_6 = ecma_typedarray_species_create (VAR_0, &VAR_16, 1);\n  ecma_free_value (VAR_16);\n\n  if (!ECMA_IS_VALUE_ERROR (VAR_6))\n  {\n    ecma_object_t *VAR_17 = ecma_get_object_from_value (VAR_6);\n    ecma_typedarray_info_t VAR_18 = ecma_typedarray_get_info (VAR_17);\n\n    JERRY_ASSERT (VAR_18.offset == 0);\n\n    ecma_typedarray_setter_fn_t VAR_19 = ecma_get_typedarray_setter_fn (VAR_18.id);\n    uint32_t VAR_20 = 0;\n    for (uint32_t VAR_21 = 0; VAR_21 < VAR_8->item_count; VAR_21++)\n    {\n      ecma_value_t VAR_22 = VAR_19 (VAR_18.buffer_p + VAR_20,\n                                                              VAR_8->buffer_p[VAR_21]);\n\n      if (ECMA_IS_VALUE_ERROR (VAR_22))\n      {\n        goto cleanup;\n      }\n\n      VAR_20 += VAR_18.element_size;\n    }\n  }\n\ncleanup:\n  ecma_collection_free (VAR_8);\n\n  return VAR_6;\n}",
  "func_graph_path": "jerryscript-project/jerryscript/6a21f4069a0e792dc38154b2b3aaf57a83924a61/ecma-builtin-typedarray-prototype.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -15,9 +15,7 @@\n     return ecma_op_create_typedarray_with_type_and_length (info_p->id, 0);\n   }\n \n-  JMEM_DEFINE_LOCAL_ARRAY (pass_value_list_p, info_p->length * info_p->element_size, lit_utf8_byte_t);\n-\n-  lit_utf8_byte_t *pass_value_p = pass_value_list_p;\n+  ecma_collection_t *collected_p = ecma_new_collection ();\n   uint32_t byte_pos = 0;\n \n   for (uint32_t index = 0; index < info_p->length; index++)\n@@ -32,50 +30,63 @@\n     ecma_value_t call_value = ecma_op_function_call (func_object_p, cb_this_arg, call_args, 3);\n \n     ecma_fast_free_value (current_index);\n-    ecma_fast_free_value (get_value);\n \n     if (ECMA_IS_VALUE_ERROR (call_value))\n     {\n+      ecma_fast_free_value (get_value);\n       goto cleanup;\n     }\n \n     if (ecma_arraybuffer_is_detached (info_p->array_buffer_p))\n     {\n       ecma_free_value (call_value);\n+      ecma_fast_free_value (get_value);\n       ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_arraybuffer_is_detached));\n       goto cleanup;\n     }\n \n     if (ecma_op_to_boolean (call_value))\n     {\n-      memcpy (pass_value_p, info_p->buffer_p + byte_pos, info_p->element_size);\n-      pass_value_p += info_p->element_size;\n+      ecma_collection_push_back (collected_p, get_value);\n+    }\n+    else\n+    {\n+      ecma_fast_free_value (get_value);\n     }\n \n     byte_pos += info_p->element_size;\n-\n-    ecma_free_value (call_value);\n+    ecma_fast_free_value (call_value);\n   }\n \n-  uint32_t pass_num = (uint32_t) ((pass_value_p - pass_value_list_p) >> info_p->shift);\n-\n-  ecma_value_t collected = ecma_make_number_value (pass_num);\n+  ecma_value_t collected = ecma_make_number_value (collected_p->item_count);\n   ret_value = ecma_typedarray_species_create (this_arg, &collected, 1);\n   ecma_free_value (collected);\n \n   if (!ECMA_IS_VALUE_ERROR (ret_value))\n   {\n     ecma_object_t *obj_p = ecma_get_object_from_value (ret_value);\n+    ecma_typedarray_info_t target_info = ecma_typedarray_get_info (obj_p);\n \n-    JERRY_ASSERT (ecma_typedarray_get_offset (obj_p) == 0);\n+    JERRY_ASSERT (target_info.offset == 0);\n \n-    memcpy (ecma_typedarray_get_buffer (obj_p),\n-            pass_value_list_p,\n-            (size_t) (pass_value_p - pass_value_list_p));\n+    ecma_typedarray_setter_fn_t target_typedarray_setter_cb = ecma_get_typedarray_setter_fn (target_info.id);\n+    uint32_t target_byte_index = 0;\n+    for (uint32_t idx = 0; idx < collected_p->item_count; idx++)\n+    {\n+      ecma_value_t set_element = target_typedarray_setter_cb (target_info.buffer_p + target_byte_index,\n+                                                              collected_p->buffer_p[idx]);\n+\n+      if (ECMA_IS_VALUE_ERROR (set_element))\n+      {\n+        goto cleanup;\n+      }\n+\n+      target_byte_index += target_info.element_size;\n+    }\n   }\n \n cleanup:\n-  JMEM_FINALIZE_LOCAL_ARRAY (pass_value_list_p);\n+  ecma_collection_free (collected_p);\n \n   return ret_value;\n }",
  "diff_line_info": {
    "deleted_lines": [
      "  JMEM_DEFINE_LOCAL_ARRAY (pass_value_list_p, info_p->length * info_p->element_size, lit_utf8_byte_t);",
      "",
      "  lit_utf8_byte_t *pass_value_p = pass_value_list_p;",
      "    ecma_fast_free_value (get_value);",
      "      memcpy (pass_value_p, info_p->buffer_p + byte_pos, info_p->element_size);",
      "      pass_value_p += info_p->element_size;",
      "",
      "    ecma_free_value (call_value);",
      "  uint32_t pass_num = (uint32_t) ((pass_value_p - pass_value_list_p) >> info_p->shift);",
      "",
      "  ecma_value_t collected = ecma_make_number_value (pass_num);",
      "    JERRY_ASSERT (ecma_typedarray_get_offset (obj_p) == 0);",
      "    memcpy (ecma_typedarray_get_buffer (obj_p),",
      "            pass_value_list_p,",
      "            (size_t) (pass_value_p - pass_value_list_p));",
      "  JMEM_FINALIZE_LOCAL_ARRAY (pass_value_list_p);"
    ],
    "added_lines": [
      "  ecma_collection_t *collected_p = ecma_new_collection ();",
      "      ecma_fast_free_value (get_value);",
      "      ecma_fast_free_value (get_value);",
      "      ecma_collection_push_back (collected_p, get_value);",
      "    }",
      "    else",
      "    {",
      "      ecma_fast_free_value (get_value);",
      "    ecma_fast_free_value (call_value);",
      "  ecma_value_t collected = ecma_make_number_value (collected_p->item_count);",
      "    ecma_typedarray_info_t target_info = ecma_typedarray_get_info (obj_p);",
      "    JERRY_ASSERT (target_info.offset == 0);",
      "    ecma_typedarray_setter_fn_t target_typedarray_setter_cb = ecma_get_typedarray_setter_fn (target_info.id);",
      "    uint32_t target_byte_index = 0;",
      "    for (uint32_t idx = 0; idx < collected_p->item_count; idx++)",
      "    {",
      "      ecma_value_t set_element = target_typedarray_setter_cb (target_info.buffer_p + target_byte_index,",
      "                                                              collected_p->buffer_p[idx]);",
      "",
      "      if (ECMA_IS_VALUE_ERROR (set_element))",
      "      {",
      "        goto cleanup;",
      "      }",
      "",
      "      target_byte_index += target_info.element_size;",
      "    }",
      "  ecma_collection_free (collected_p);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/jerryscript-project/jerryscript/pull/4794",
  "description": {
    "pr_info": {
      "title": "Force value conversion in case of TypedArray filter method",
      "number": 4794
    },
    "comment": [
      "During the execution of the TypedArray filter method it is possible\r\nto have a different sized output TypedArray than the input one.\r\nWhen copying the data to the output array the values must be\r\ncorrectly converted to the output TypedArray's value range.\r\n\r\nFixes: #4793"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "**Final Classification:** Defect Remediation & Feature Upgrades; **Confidence:** 0.95\n\nThe changes address a bug in the TypedArray filter method by correctly converting values for the output array. The commit message and code changes align, and there are no security-related terms or implications. The fix is a core logic improvement, hence falls under Defect Remediation with high confidence."
}