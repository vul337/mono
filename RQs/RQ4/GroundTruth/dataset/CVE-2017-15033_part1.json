{
  "cve_id": "CVE-2017-15033",
  "cwe_ids": [
    "CWE-772"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "ImageMagick",
  "commit_msg": "fix multiple memory leak in ReadYUVImage",
  "commit_hash": "ef8f40689ac452398026c07da41656a7c87e4683",
  "git_url": "https://github.com/ImageMagick/ImageMagick/commit/ef8f40689ac452398026c07da41656a7c87e4683",
  "file_path": "coders/yuv.c",
  "func_name": "ReadYUVImage",
  "func_before": "static Image *ReadYUVImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *chroma_image,\n    *image,\n    *resize_image;\n\n  InterlaceType\n    interlace;\n\n  MagickBooleanType\n    status;\n\n  register const Quantum\n    *chroma_pixels;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  register unsigned char\n    *p;\n\n  ssize_t\n    count,\n    horizontal_factor,\n    vertical_factor,\n    y;\n\n  size_t\n    length,\n    quantum;\n\n  unsigned char\n    *scanline;\n\n  /*\n    Allocate image structure.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  if ((image->columns == 0) || (image->rows == 0))\n    ThrowReaderException(OptionError,\"MustSpecifyImageSize\");\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  quantum=(ssize_t) (image->depth <= 8 ? 1 : 2);\n  interlace=image_info->interlace;\n  horizontal_factor=2;\n  vertical_factor=2;\n  if (image_info->sampling_factor != (char *) NULL)\n    {\n      GeometryInfo\n        geometry_info;\n\n      MagickStatusType\n        flags;\n\n      flags=ParseGeometry(image_info->sampling_factor,&geometry_info);\n      horizontal_factor=(ssize_t) geometry_info.rho;\n      vertical_factor=(ssize_t) geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        vertical_factor=horizontal_factor;\n      if ((horizontal_factor != 1) && (horizontal_factor != 2) &&\n          (vertical_factor != 1) && (vertical_factor != 2))\n        ThrowReaderException(CorruptImageError,\"UnexpectedSamplingFactor\");\n    }\n  if ((interlace == UndefinedInterlace) ||\n      ((interlace == NoInterlace) && (vertical_factor == 2)))\n    {\n      interlace=NoInterlace;    /* CCIR 4:2:2 */\n      if (vertical_factor == 2)\n        interlace=PlaneInterlace; /* CCIR 4:1:1 */\n    }\n  if (interlace != PartitionInterlace)\n    {\n      /*\n        Open image file.\n      */\n      status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n      if (status == MagickFalse)\n        {\n          image=DestroyImageList(image);\n          return((Image *) NULL);\n        }\n      if (DiscardBlobBytes(image,(MagickSizeType) image->offset) == MagickFalse)\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n    }\n  /*\n    Allocate memory for a scanline.\n  */\n  if (interlace == NoInterlace)\n    scanline=(unsigned char *) AcquireQuantumMemory((size_t) (2UL*\n      image->columns+2UL),(size_t) quantum*sizeof(*scanline));\n  else\n    scanline=(unsigned char *) AcquireQuantumMemory(image->columns,\n      (size_t) quantum*sizeof(*scanline));\n  if (scanline == (unsigned char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  status=MagickTrue;\n  do\n  {\n    chroma_image=CloneImage(image,(image->columns+horizontal_factor-1)/\n      horizontal_factor,(image->rows+vertical_factor-1)/vertical_factor,\n      MagickTrue,exception);\n    if (chroma_image == (Image *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    /*\n      Convert raster image to pixel packets.\n    */\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      break;\n    if (interlace == PartitionInterlace)\n      {\n        AppendImageFormat(\"Y\",image->filename);\n        status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n        if (status == MagickFalse)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n      }\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      register Quantum\n        *chroma_pixels;\n\n      if (interlace == NoInterlace)\n        {\n          if ((y > 0) || (GetPreviousImageInList(image) == (Image *) NULL))\n            {\n              length=2*quantum*image->columns;\n              count=ReadBlob(image,length,scanline);\n              if (count != (ssize_t) length)\n                {\n                  status=MagickFalse;\n                  ThrowFileException(exception,CorruptImageError,\n                    \"UnexpectedEndOfFile\",image->filename);\n                  break;\n                }\n            }\n          p=scanline;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          chroma_pixels=QueueAuthenticPixels(chroma_image,0,y,\n            chroma_image->columns,1,exception);\n          if (chroma_pixels == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x+=2)\n          {\n            SetPixelRed(chroma_image,0,chroma_pixels);\n            if (quantum == 1)\n              SetPixelGreen(chroma_image,ScaleCharToQuantum(*p++),\n                chroma_pixels);\n            else\n              {\n                SetPixelGreen(chroma_image,ScaleShortToQuantum(((*p) << 8) |\n                  *(p+1)),chroma_pixels);\n                p+=2;\n              }\n            if (quantum == 1)\n              SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n            else\n              {\n                SetPixelRed(image,ScaleShortToQuantum(((*p) << 8) | *(p+1)),q);\n                p+=2;\n              }\n            SetPixelGreen(image,0,q);\n            SetPixelBlue(image,0,q);\n            q+=GetPixelChannels(image);\n            SetPixelGreen(image,0,q);\n            SetPixelBlue(image,0,q);\n            if (quantum == 1)\n              SetPixelBlue(chroma_image,ScaleCharToQuantum(*p++),chroma_pixels);\n            else\n              {\n                SetPixelBlue(chroma_image,ScaleShortToQuantum(((*p) << 8) |\n                  *(p+1)),chroma_pixels);\n                p+=2;\n              }\n            if (quantum == 1)\n              SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n            else\n              {\n                SetPixelRed(image,ScaleShortToQuantum(((*p) << 8) | *(p+1)),q);\n                p+=2;\n              }\n            chroma_pixels+=GetPixelChannels(chroma_image);\n            q+=GetPixelChannels(image);\n          }\n        }\n      else\n        {\n          if ((y > 0) || (GetPreviousImageInList(image) == (Image *) NULL))\n            {\n              length=quantum*image->columns;\n              count=ReadBlob(image,length,scanline);\n              if (count != (ssize_t) length)\n                {\n                  status=MagickFalse;\n                  ThrowFileException(exception,CorruptImageError,\n                    \"UnexpectedEndOfFile\",image->filename);\n                  break;\n                }\n            }\n          p=scanline;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            if (quantum == 1)\n              SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n            else\n              {\n                SetPixelRed(image,ScaleShortToQuantum(((*p) << 8) | *(p+1)),q);\n                p+=2;\n              }\n            SetPixelGreen(image,0,q);\n            SetPixelBlue(image,0,q);\n            q+=GetPixelChannels(image);\n          }\n        }\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        break;\n      if (interlace == NoInterlace)\n        if (SyncAuthenticPixels(chroma_image,exception) == MagickFalse)\n          break;\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    if (interlace == PartitionInterlace)\n      {\n        (void) CloseBlob(image);\n        AppendImageFormat(\"U\",image->filename);\n        status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n        if (status == MagickFalse)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n      }\n    if (interlace != NoInterlace)\n      {\n        for (y=0; y < (ssize_t) chroma_image->rows; y++)\n        {\n          length=quantum*chroma_image->columns;\n          count=ReadBlob(image,length,scanline);\n          if (count != (ssize_t) length)\n            {\n              status=MagickFalse;\n              ThrowFileException(exception,CorruptImageError,\n                \"UnexpectedEndOfFile\",image->filename);\n              break;\n            }\n          p=scanline;\n          q=QueueAuthenticPixels(chroma_image,0,y,chroma_image->columns,1,\n            exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) chroma_image->columns; x++)\n          {\n            SetPixelRed(chroma_image,0,q);\n            if (quantum == 1)\n              SetPixelGreen(chroma_image,ScaleCharToQuantum(*p++),q);\n            else\n              {\n                SetPixelGreen(chroma_image,ScaleShortToQuantum(((*p) << 8) |\n                  *(p+1)),q);\n                p+=2;\n              }\n            SetPixelBlue(chroma_image,0,q);\n            q+=GetPixelChannels(chroma_image);\n          }\n          if (SyncAuthenticPixels(chroma_image,exception) == MagickFalse)\n            break;\n        }\n      if (interlace == PartitionInterlace)\n        {\n          (void) CloseBlob(image);\n          AppendImageFormat(\"V\",image->filename);\n          status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n          if (status == MagickFalse)\n            {\n              image=DestroyImageList(image);\n              return((Image *) NULL);\n            }\n        }\n      for (y=0; y < (ssize_t) chroma_image->rows; y++)\n      {\n        length=quantum*chroma_image->columns;\n        count=ReadBlob(image,length,scanline);\n        if (count != (ssize_t) length)\n          {\n            status=MagickFalse;\n            ThrowFileException(exception,CorruptImageError,\n              \"UnexpectedEndOfFile\",image->filename);\n            break;\n          }\n        p=scanline;\n        q=GetAuthenticPixels(chroma_image,0,y,chroma_image->columns,1,\n          exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < (ssize_t) chroma_image->columns; x++)\n        {\n          if (quantum == 1)\n            SetPixelBlue(chroma_image,ScaleCharToQuantum(*p++),q);\n          else\n            {\n              SetPixelBlue(chroma_image,ScaleShortToQuantum(((*p) << 8) |\n                *(p+1)),q);\n              p+=2;\n            }\n          q+=GetPixelChannels(chroma_image);\n        }\n        if (SyncAuthenticPixels(chroma_image,exception) == MagickFalse)\n          break;\n      }\n    }\n    /*\n      Scale image.\n    */\n    resize_image=ResizeImage(chroma_image,image->columns,image->rows,\n      TriangleFilter,exception);\n    chroma_image=DestroyImage(chroma_image);\n    if (resize_image == (Image *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n      chroma_pixels=GetVirtualPixels(resize_image,0,y,resize_image->columns,1,\n        exception);\n      if ((q == (Quantum *) NULL) ||\n          (chroma_pixels == (const Quantum *) NULL))\n        break;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        SetPixelGreen(image,GetPixelGreen(resize_image,chroma_pixels),q);\n        SetPixelBlue(image,GetPixelBlue(resize_image,chroma_pixels),q);\n        chroma_pixels+=GetPixelChannels(resize_image);\n        q+=GetPixelChannels(image);\n      }\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        break;\n    }\n    resize_image=DestroyImage(resize_image);\n    if (SetImageColorspace(image,YCbCrColorspace,exception) == MagickFalse)\n      break;\n    if (interlace == PartitionInterlace)\n      (void) CopyMagickString(image->filename,image_info->filename,\n        MagickPathExtent);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if (interlace == NoInterlace)\n      count=ReadBlob(image,(size_t) (2*quantum*image->columns),scanline);\n    else\n      count=ReadBlob(image,(size_t) quantum*image->columns,scanline);\n    if (count != 0)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (count != 0);\n  scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n  (void) CloseBlob(image);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  return(GetFirstImageInList(image));\n}",
  "abstract_func_before": "static Image *ReadYUVImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)\n{\n  Image\n    *VAR_2,\n    *VAR_3,\n    *VAR_4;\n\n  InterlaceType\n    VAR_5;\n\n  MagickBooleanType\n    VAR_6;\n\n  register const Quantum\n    *VAR_7;\n\n  register ssize_t\n    VAR_8;\n\n  register Quantum\n    *VAR_9;\n\n  register unsigned char\n    *VAR_10;\n\n  ssize_t\n    VAR_11,\n    VAR_12,\n    VAR_13,\n    VAR_14;\n\n  size_t\n    VAR_15,\n    VAR_16;\n\n  unsigned char\n    *VAR_17;\n\n  /* COMMENT_0 */\n                             \n    \n  assert(VAR_0 != (const ImageInfo *) NULL);\n  assert(VAR_0->signature == VAR_18);\n  if (VAR_0->debug != VAR_19)\n    (void) LogMagickEvent(VAR_20,GetMagickModule(),\"%s\",\n      VAR_0->filename);\n  assert(VAR_1 != (ExceptionInfo *) NULL);\n  assert(VAR_1->signature == VAR_18);\n  VAR_3=AcquireImage(VAR_0,VAR_1);\n  if ((VAR_3->columns == 0) || (VAR_3->rows == 0))\n    ThrowReaderException(VAR_21,\"MustSpecifyImageSize\");\n  VAR_6=SetImageExtent(VAR_3,VAR_3->columns,VAR_3->rows,VAR_1);\n  if (VAR_6 == VAR_19)\n    return(DestroyImageList(VAR_3));\n  VAR_16=(ssize_t) (VAR_3->depth <= 8 ? 1 : 2);\n  VAR_5=VAR_0->interlace;\n  VAR_12=2;\n  VAR_13=2;\n  if (VAR_0->sampling_factor != (char *) NULL)\n    {\n      GeometryInfo\n        VAR_22;\n\n      MagickStatusType\n        VAR_23;\n\n      VAR_23=ParseGeometry(VAR_0->sampling_factor,&VAR_22);\n      VAR_12=(ssize_t) VAR_22.rho;\n      VAR_13=(ssize_t) VAR_22.sigma;\n      if ((VAR_23 & VAR_24) == 0)\n        VAR_13=VAR_12;\n      if ((VAR_12 != 1) && (VAR_12 != 2) &&\n          (VAR_13 != 1) && (VAR_13 != 2))\n        ThrowReaderException(VAR_25,\"UnexpectedSamplingFactor\");\n    }\n  if ((VAR_5 == VAR_26) ||\n      ((VAR_5 == VAR_27) && (VAR_13 == 2)))\n    {\n      VAR_5=VAR_27;    /* COMMENT_3 */\n      if (VAR_13 == 2)\n        VAR_5=VAR_28; /* COMMENT_4 */\n    }\n  if (VAR_5 != VAR_29)\n    {\n      /* COMMENT_5 */\n                        \n        \n      VAR_6=OpenBlob(VAR_0,VAR_3,VAR_30,VAR_1);\n      if (VAR_6 == VAR_19)\n        {\n          VAR_3=DestroyImageList(VAR_3);\n          return((Image *) NULL);\n        }\n      if (DiscardBlobBytes(VAR_3,(MagickSizeType) VAR_3->offset) == VAR_19)\n        ThrowFileException(VAR_1,VAR_25,\"UnexpectedEndOfFile\",\n          VAR_3->filename);\n    }\n  /* COMMENT_8 */\n                                   \n    \n  if (VAR_5 == VAR_27)\n    VAR_17=(unsigned char *) AcquireQuantumMemory((size_t) (2UL*\n      VAR_3->columns+2UL),(size_t) VAR_16*sizeof(*VAR_17));\n  else\n    VAR_17=(unsigned char *) AcquireQuantumMemory(VAR_3->columns,\n      (size_t) VAR_16*sizeof(*VAR_17));\n  if (VAR_17 == (unsigned char *) NULL)\n    ThrowReaderException(VAR_31,\"MemoryAllocationFailed\");\n  VAR_6=VAR_32;\n  do\n  {\n    VAR_2=CloneImage(VAR_3,(VAR_3->columns+VAR_12-1)/\n      VAR_12,(VAR_3->rows+VAR_13-1)/VAR_13,\n      VAR_32,VAR_1);\n    if (VAR_2 == (Image *) NULL)\n      ThrowReaderException(VAR_31,\"MemoryAllocationFailed\");\n    /* COMMENT_11 */\n                                            \n      \n    if ((VAR_0->ping != VAR_19) && (VAR_0->number_scenes != 0))\n      if (VAR_3->scene >= (VAR_0->scene+VAR_0->number_scenes-1))\n        break;\n    VAR_6=SetImageExtent(VAR_3,VAR_3->columns,VAR_3->rows,VAR_1);\n    if (VAR_6 == VAR_19)\n      break;\n    if (VAR_5 == VAR_29)\n      {\n        AppendImageFormat(\"Y\",VAR_3->filename);\n        VAR_6=OpenBlob(VAR_0,VAR_3,VAR_30,VAR_1);\n        if (VAR_6 == VAR_19)\n          {\n            VAR_3=DestroyImageList(VAR_3);\n            return((Image *) NULL);\n          }\n      }\n    for (VAR_14=0; VAR_14 < (ssize_t) VAR_3->rows; VAR_14++)\n    {\n      register Quantum\n        *VAR_7;\n\n      if (VAR_5 == VAR_27)\n        {\n          if ((VAR_14 > 0) || (GetPreviousImageInList(VAR_3) == (Image *) NULL))\n            {\n              VAR_15=2*VAR_16*VAR_3->columns;\n              VAR_11=ReadBlob(VAR_3,VAR_15,VAR_17);\n              if (VAR_11 != (ssize_t) VAR_15)\n                {\n                  VAR_6=VAR_19;\n                  ThrowFileException(VAR_1,VAR_25,\n                    \"UnexpectedEndOfFile\",VAR_3->filename);\n                  break;\n                }\n            }\n          VAR_10=VAR_17;\n          VAR_9=QueueAuthenticPixels(VAR_3,0,VAR_14,VAR_3->columns,1,VAR_1);\n          if (VAR_9 == (Quantum *) NULL)\n            break;\n          VAR_7=QueueAuthenticPixels(VAR_2,0,VAR_14,\n            VAR_2->columns,1,VAR_1);\n          if (VAR_7 == (Quantum *) NULL)\n            break;\n          for (VAR_8=0; VAR_8 < (ssize_t) VAR_3->columns; VAR_8+=2)\n          {\n            SetPixelRed(VAR_2,0,VAR_7);\n            if (VAR_16 == 1)\n              SetPixelGreen(VAR_2,ScaleCharToQuantum(*VAR_10++),\n                VAR_7);\n            else\n              {\n                SetPixelGreen(VAR_2,ScaleShortToQuantum(((*VAR_10) << 8) |\n                  *(VAR_10+1)),VAR_7);\n                VAR_10+=2;\n              }\n            if (VAR_16 == 1)\n              SetPixelRed(VAR_3,ScaleCharToQuantum(*VAR_10++),VAR_9);\n            else\n              {\n                SetPixelRed(VAR_3,ScaleShortToQuantum(((*VAR_10) << 8) | *(VAR_10+1)),VAR_9);\n                VAR_10+=2;\n              }\n            SetPixelGreen(VAR_3,0,VAR_9);\n            SetPixelBlue(VAR_3,0,VAR_9);\n            VAR_9+=GetPixelChannels(VAR_3);\n            SetPixelGreen(VAR_3,0,VAR_9);\n            SetPixelBlue(VAR_3,0,VAR_9);\n            if (VAR_16 == 1)\n              SetPixelBlue(VAR_2,ScaleCharToQuantum(*VAR_10++),VAR_7);\n            else\n              {\n                SetPixelBlue(VAR_2,ScaleShortToQuantum(((*VAR_10) << 8) |\n                  *(VAR_10+1)),VAR_7);\n                VAR_10+=2;\n              }\n            if (VAR_16 == 1)\n              SetPixelRed(VAR_3,ScaleCharToQuantum(*VAR_10++),VAR_9);\n            else\n              {\n                SetPixelRed(VAR_3,ScaleShortToQuantum(((*VAR_10) << 8) | *(VAR_10+1)),VAR_9);\n                VAR_10+=2;\n              }\n            VAR_7+=GetPixelChannels(VAR_2);\n            VAR_9+=GetPixelChannels(VAR_3);\n          }\n        }\n      else\n        {\n          if ((VAR_14 > 0) || (GetPreviousImageInList(VAR_3) == (Image *) NULL))\n            {\n              VAR_15=VAR_16*VAR_3->columns;\n              VAR_11=ReadBlob(VAR_3,VAR_15,VAR_17);\n              if (VAR_11 != (ssize_t) VAR_15)\n                {\n                  VAR_6=VAR_19;\n                  ThrowFileException(VAR_1,VAR_25,\n                    \"UnexpectedEndOfFile\",VAR_3->filename);\n                  break;\n                }\n            }\n          VAR_10=VAR_17;\n          VAR_9=QueueAuthenticPixels(VAR_3,0,VAR_14,VAR_3->columns,1,VAR_1);\n          if (VAR_9 == (Quantum *) NULL)\n            break;\n          for (VAR_8=0; VAR_8 < (ssize_t) VAR_3->columns; VAR_8++)\n          {\n            if (VAR_16 == 1)\n              SetPixelRed(VAR_3,ScaleCharToQuantum(*VAR_10++),VAR_9);\n            else\n              {\n                SetPixelRed(VAR_3,ScaleShortToQuantum(((*VAR_10) << 8) | *(VAR_10+1)),VAR_9);\n                VAR_10+=2;\n              }\n            SetPixelGreen(VAR_3,0,VAR_9);\n            SetPixelBlue(VAR_3,0,VAR_9);\n            VAR_9+=GetPixelChannels(VAR_3);\n          }\n        }\n      if (SyncAuthenticPixels(VAR_3,VAR_1) == VAR_19)\n        break;\n      if (VAR_5 == VAR_27)\n        if (SyncAuthenticPixels(VAR_2,VAR_1) == VAR_19)\n          break;\n      if (VAR_3->previous == (Image *) NULL)\n        {\n          VAR_6=SetImageProgress(VAR_3,VAR_33,(MagickOffsetType) VAR_14,\n            VAR_3->rows);\n          if (VAR_6 == VAR_19)\n            break;\n        }\n    }\n    if (VAR_5 == VAR_29)\n      {\n        (void) CloseBlob(VAR_3);\n        AppendImageFormat(\"U\",VAR_3->filename);\n        VAR_6=OpenBlob(VAR_0,VAR_3,VAR_30,VAR_1);\n        if (VAR_6 == VAR_19)\n          {\n            VAR_3=DestroyImageList(VAR_3);\n            return((Image *) NULL);\n          }\n      }\n    if (VAR_5 != VAR_27)\n      {\n        for (VAR_14=0; VAR_14 < (ssize_t) VAR_2->rows; VAR_14++)\n        {\n          VAR_15=VAR_16*VAR_2->columns;\n          VAR_11=ReadBlob(VAR_3,VAR_15,VAR_17);\n          if (VAR_11 != (ssize_t) VAR_15)\n            {\n              VAR_6=VAR_19;\n              ThrowFileException(VAR_1,VAR_25,\n                \"UnexpectedEndOfFile\",VAR_3->filename);\n              break;\n            }\n          VAR_10=VAR_17;\n          VAR_9=QueueAuthenticPixels(VAR_2,0,VAR_14,VAR_2->columns,1,\n            VAR_1);\n          if (VAR_9 == (Quantum *) NULL)\n            break;\n          for (VAR_8=0; VAR_8 < (ssize_t) VAR_2->columns; VAR_8++)\n          {\n            SetPixelRed(VAR_2,0,VAR_9);\n            if (VAR_16 == 1)\n              SetPixelGreen(VAR_2,ScaleCharToQuantum(*VAR_10++),VAR_9);\n            else\n              {\n                SetPixelGreen(VAR_2,ScaleShortToQuantum(((*VAR_10) << 8) |\n                  *(VAR_10+1)),VAR_9);\n                VAR_10+=2;\n              }\n            SetPixelBlue(VAR_2,0,VAR_9);\n            VAR_9+=GetPixelChannels(VAR_2);\n          }\n          if (SyncAuthenticPixels(VAR_2,VAR_1) == VAR_19)\n            break;\n        }\n      if (VAR_5 == VAR_29)\n        {\n          (void) CloseBlob(VAR_3);\n          AppendImageFormat(\"V\",VAR_3->filename);\n          VAR_6=OpenBlob(VAR_0,VAR_3,VAR_30,VAR_1);\n          if (VAR_6 == VAR_19)\n            {\n              VAR_3=DestroyImageList(VAR_3);\n              return((Image *) NULL);\n            }\n        }\n      for (VAR_14=0; VAR_14 < (ssize_t) VAR_2->rows; VAR_14++)\n      {\n        VAR_15=VAR_16*VAR_2->columns;\n        VAR_11=ReadBlob(VAR_3,VAR_15,VAR_17);\n        if (VAR_11 != (ssize_t) VAR_15)\n          {\n            VAR_6=VAR_19;\n            ThrowFileException(VAR_1,VAR_25,\n              \"UnexpectedEndOfFile\",VAR_3->filename);\n            break;\n          }\n        VAR_10=VAR_17;\n        VAR_9=GetAuthenticPixels(VAR_2,0,VAR_14,VAR_2->columns,1,\n          VAR_1);\n        if (VAR_9 == (Quantum *) NULL)\n          break;\n        for (VAR_8=0; VAR_8 < (ssize_t) VAR_2->columns; VAR_8++)\n        {\n          if (VAR_16 == 1)\n            SetPixelBlue(VAR_2,ScaleCharToQuantum(*VAR_10++),VAR_9);\n          else\n            {\n              SetPixelBlue(VAR_2,ScaleShortToQuantum(((*VAR_10) << 8) |\n                *(VAR_10+1)),VAR_9);\n              VAR_10+=2;\n            }\n          VAR_9+=GetPixelChannels(VAR_2);\n        }\n        if (SyncAuthenticPixels(VAR_2,VAR_1) == VAR_19)\n          break;\n      }\n    }\n    /* COMMENT_14 */\n                  \n      \n    VAR_4=ResizeImage(VAR_2,VAR_3->columns,VAR_3->rows,\n      VAR_34,VAR_1);\n    VAR_2=DestroyImage(VAR_2);\n    if (VAR_4 == (Image *) NULL)\n      ThrowReaderException(VAR_31,\"MemoryAllocationFailed\");\n    for (VAR_14=0; VAR_14 < (ssize_t) VAR_3->rows; VAR_14++)\n    {\n      VAR_9=GetAuthenticPixels(VAR_3,0,VAR_14,VAR_3->columns,1,VAR_1);\n      VAR_7=GetVirtualPixels(VAR_4,0,VAR_14,VAR_4->columns,1,\n        VAR_1);\n      if ((VAR_9 == (Quantum *) NULL) ||\n          (VAR_7 == (const Quantum *) NULL))\n        break;\n      for (VAR_8=0; VAR_8 < (ssize_t) VAR_3->columns; VAR_8++)\n      {\n        SetPixelGreen(VAR_3,GetPixelGreen(VAR_4,VAR_7),VAR_9);\n        SetPixelBlue(VAR_3,GetPixelBlue(VAR_4,VAR_7),VAR_9);\n        VAR_7+=GetPixelChannels(VAR_4);\n        VAR_9+=GetPixelChannels(VAR_3);\n      }\n      if (SyncAuthenticPixels(VAR_3,VAR_1) == VAR_19)\n        break;\n    }\n    VAR_4=DestroyImage(VAR_4);\n    if (SetImageColorspace(VAR_3,VAR_35,VAR_1) == VAR_19)\n      break;\n    if (VAR_5 == VAR_29)\n      (void) CopyMagickString(VAR_3->filename,VAR_0->filename,\n        VAR_36);\n    if (EOFBlob(VAR_3) != VAR_19)\n      {\n        ThrowFileException(VAR_1,VAR_25,\"UnexpectedEndOfFile\",\n          VAR_3->filename);\n        break;\n      }\n    /* COMMENT_17 */\n                            \n      \n    if (VAR_0->number_scenes != 0)\n      if (VAR_3->scene >= (VAR_0->scene+VAR_0->number_scenes-1))\n        break;\n    if (VAR_5 == VAR_27)\n      VAR_11=ReadBlob(VAR_3,(size_t) (2*VAR_16*VAR_3->columns),VAR_17);\n    else\n      VAR_11=ReadBlob(VAR_3,(size_t) VAR_16*VAR_3->columns,VAR_17);\n    if (VAR_11 != 0)\n      {\n        /* COMMENT_20 */\n                                        \n          \n        AcquireNextImage(VAR_0,VAR_3,VAR_1);\n        if (GetNextImageInList(VAR_3) == (Image *) NULL)\n          {\n            VAR_3=DestroyImageList(VAR_3);\n            return((Image *) NULL);\n          }\n        VAR_3=SyncNextImageInList(VAR_3);\n        VAR_6=SetImageProgress(VAR_3,VAR_37,TellBlob(VAR_3),\n          GetBlobSize(VAR_3));\n        if (VAR_6 == VAR_19)\n          break;\n      }\n  } while (VAR_11 != 0);\n  VAR_17=(unsigned char *) RelinquishMagickMemory(VAR_17);\n  (void) CloseBlob(VAR_3);\n  if (VAR_6 == VAR_19)\n    return(DestroyImageList(VAR_3));\n  return(GetFirstImageInList(VAR_3));\n}",
  "func_graph_path_before": "ImageMagick/ef8f40689ac452398026c07da41656a7c87e4683/yuv.c/vul/before/0.json",
  "func": "static Image *ReadYUVImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *chroma_image,\n    *image,\n    *resize_image;\n\n  InterlaceType\n    interlace;\n\n  MagickBooleanType\n    status;\n\n  register const Quantum\n    *chroma_pixels;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  register unsigned char\n    *p;\n\n  ssize_t\n    count,\n    horizontal_factor,\n    vertical_factor,\n    y;\n\n  size_t\n    length,\n    quantum;\n\n  unsigned char\n    *scanline;\n\n  /*\n    Allocate image structure.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  if ((image->columns == 0) || (image->rows == 0))\n    ThrowReaderException(OptionError,\"MustSpecifyImageSize\");\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  quantum=(ssize_t) (image->depth <= 8 ? 1 : 2);\n  interlace=image_info->interlace;\n  horizontal_factor=2;\n  vertical_factor=2;\n  if (image_info->sampling_factor != (char *) NULL)\n    {\n      GeometryInfo\n        geometry_info;\n\n      MagickStatusType\n        flags;\n\n      flags=ParseGeometry(image_info->sampling_factor,&geometry_info);\n      horizontal_factor=(ssize_t) geometry_info.rho;\n      vertical_factor=(ssize_t) geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        vertical_factor=horizontal_factor;\n      if ((horizontal_factor != 1) && (horizontal_factor != 2) &&\n          (vertical_factor != 1) && (vertical_factor != 2))\n        ThrowReaderException(CorruptImageError,\"UnexpectedSamplingFactor\");\n    }\n  if ((interlace == UndefinedInterlace) ||\n      ((interlace == NoInterlace) && (vertical_factor == 2)))\n    {\n      interlace=NoInterlace;    /* CCIR 4:2:2 */\n      if (vertical_factor == 2)\n        interlace=PlaneInterlace; /* CCIR 4:1:1 */\n    }\n  if (interlace != PartitionInterlace)\n    {\n      /*\n        Open image file.\n      */\n      status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n      if (status == MagickFalse)\n        {\n          image=DestroyImageList(image);\n          return((Image *) NULL);\n        }\n      if (DiscardBlobBytes(image,(MagickSizeType) image->offset) == MagickFalse)\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n    }\n  /*\n    Allocate memory for a scanline.\n  */\n  if (interlace == NoInterlace)\n    scanline=(unsigned char *) AcquireQuantumMemory((size_t) (2UL*\n      image->columns+2UL),(size_t) quantum*sizeof(*scanline));\n  else\n    scanline=(unsigned char *) AcquireQuantumMemory(image->columns,\n      (size_t) quantum*sizeof(*scanline));\n  if (scanline == (unsigned char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  status=MagickTrue;\n  do\n  {\n    chroma_image=CloneImage(image,(image->columns+horizontal_factor-1)/\n      horizontal_factor,(image->rows+vertical_factor-1)/vertical_factor,\n      MagickTrue,exception);\n    if (chroma_image == (Image *) NULL)\n      {\n        scanline=(unsigned char *) RelinquishMagickMemory(scanline); \n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    /*\n      Convert raster image to pixel packets.\n    */\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      break;\n    if (interlace == PartitionInterlace)\n      {\n        AppendImageFormat(\"Y\",image->filename);\n        status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n        if (status == MagickFalse)\n          {\n            scanline=(unsigned char *) RelinquishMagickMemory(scanline); \n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n      }\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      register Quantum\n        *chroma_pixels;\n\n      if (interlace == NoInterlace)\n        {\n          if ((y > 0) || (GetPreviousImageInList(image) == (Image *) NULL))\n            {\n              length=2*quantum*image->columns;\n              count=ReadBlob(image,length,scanline);\n              if (count != (ssize_t) length)\n                {\n                  status=MagickFalse;\n                  ThrowFileException(exception,CorruptImageError,\n                    \"UnexpectedEndOfFile\",image->filename);\n                  break;\n                }\n            }\n          p=scanline;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          chroma_pixels=QueueAuthenticPixels(chroma_image,0,y,\n            chroma_image->columns,1,exception);\n          if (chroma_pixels == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x+=2)\n          {\n            SetPixelRed(chroma_image,0,chroma_pixels);\n            if (quantum == 1)\n              SetPixelGreen(chroma_image,ScaleCharToQuantum(*p++),\n                chroma_pixels);\n            else\n              {\n                SetPixelGreen(chroma_image,ScaleShortToQuantum(((*p) << 8) |\n                  *(p+1)),chroma_pixels);\n                p+=2;\n              }\n            if (quantum == 1)\n              SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n            else\n              {\n                SetPixelRed(image,ScaleShortToQuantum(((*p) << 8) | *(p+1)),q);\n                p+=2;\n              }\n            SetPixelGreen(image,0,q);\n            SetPixelBlue(image,0,q);\n            q+=GetPixelChannels(image);\n            SetPixelGreen(image,0,q);\n            SetPixelBlue(image,0,q);\n            if (quantum == 1)\n              SetPixelBlue(chroma_image,ScaleCharToQuantum(*p++),chroma_pixels);\n            else\n              {\n                SetPixelBlue(chroma_image,ScaleShortToQuantum(((*p) << 8) |\n                  *(p+1)),chroma_pixels);\n                p+=2;\n              }\n            if (quantum == 1)\n              SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n            else\n              {\n                SetPixelRed(image,ScaleShortToQuantum(((*p) << 8) | *(p+1)),q);\n                p+=2;\n              }\n            chroma_pixels+=GetPixelChannels(chroma_image);\n            q+=GetPixelChannels(image);\n          }\n        }\n      else\n        {\n          if ((y > 0) || (GetPreviousImageInList(image) == (Image *) NULL))\n            {\n              length=quantum*image->columns;\n              count=ReadBlob(image,length,scanline);\n              if (count != (ssize_t) length)\n                {\n                  status=MagickFalse;\n                  ThrowFileException(exception,CorruptImageError,\n                    \"UnexpectedEndOfFile\",image->filename);\n                  break;\n                }\n            }\n          p=scanline;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            if (quantum == 1)\n              SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n            else\n              {\n                SetPixelRed(image,ScaleShortToQuantum(((*p) << 8) | *(p+1)),q);\n                p+=2;\n              }\n            SetPixelGreen(image,0,q);\n            SetPixelBlue(image,0,q);\n            q+=GetPixelChannels(image);\n          }\n        }\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        break;\n      if (interlace == NoInterlace)\n        if (SyncAuthenticPixels(chroma_image,exception) == MagickFalse)\n          break;\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    if (interlace == PartitionInterlace)\n      {\n        (void) CloseBlob(image);\n        AppendImageFormat(\"U\",image->filename);\n        status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n        if (status == MagickFalse)\n          {\n            scanline=(unsigned char *) RelinquishMagickMemory(scanline); \n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n      }\n    if (interlace != NoInterlace)\n      {\n        for (y=0; y < (ssize_t) chroma_image->rows; y++)\n        {\n          length=quantum*chroma_image->columns;\n          count=ReadBlob(image,length,scanline);\n          if (count != (ssize_t) length)\n            {\n              status=MagickFalse;\n              ThrowFileException(exception,CorruptImageError,\n                \"UnexpectedEndOfFile\",image->filename);\n              break;\n            }\n          p=scanline;\n          q=QueueAuthenticPixels(chroma_image,0,y,chroma_image->columns,1,\n            exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) chroma_image->columns; x++)\n          {\n            SetPixelRed(chroma_image,0,q);\n            if (quantum == 1)\n              SetPixelGreen(chroma_image,ScaleCharToQuantum(*p++),q);\n            else\n              {\n                SetPixelGreen(chroma_image,ScaleShortToQuantum(((*p) << 8) |\n                  *(p+1)),q);\n                p+=2;\n              }\n            SetPixelBlue(chroma_image,0,q);\n            q+=GetPixelChannels(chroma_image);\n          }\n          if (SyncAuthenticPixels(chroma_image,exception) == MagickFalse)\n            break;\n        }\n      if (interlace == PartitionInterlace)\n        {\n          (void) CloseBlob(image);\n          AppendImageFormat(\"V\",image->filename);\n          status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n          if (status == MagickFalse)\n            {\n              scanline=(unsigned char *) RelinquishMagickMemory(scanline); \n              image=DestroyImageList(image);\n              return((Image *) NULL);\n            }\n        }\n      for (y=0; y < (ssize_t) chroma_image->rows; y++)\n      {\n        length=quantum*chroma_image->columns;\n        count=ReadBlob(image,length,scanline);\n        if (count != (ssize_t) length)\n          {\n            status=MagickFalse;\n            ThrowFileException(exception,CorruptImageError,\n              \"UnexpectedEndOfFile\",image->filename);\n            break;\n          }\n        p=scanline;\n        q=GetAuthenticPixels(chroma_image,0,y,chroma_image->columns,1,\n          exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < (ssize_t) chroma_image->columns; x++)\n        {\n          if (quantum == 1)\n            SetPixelBlue(chroma_image,ScaleCharToQuantum(*p++),q);\n          else\n            {\n              SetPixelBlue(chroma_image,ScaleShortToQuantum(((*p) << 8) |\n                *(p+1)),q);\n              p+=2;\n            }\n          q+=GetPixelChannels(chroma_image);\n        }\n        if (SyncAuthenticPixels(chroma_image,exception) == MagickFalse)\n          break;\n      }\n    }\n    /*\n      Scale image.\n    */\n    resize_image=ResizeImage(chroma_image,image->columns,image->rows,\n      TriangleFilter,exception);\n    chroma_image=DestroyImage(chroma_image);\n    if (resize_image == (Image *) NULL)\n      {\n        scanline=(unsigned char *) RelinquishMagickMemory(scanline);   \n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n      chroma_pixels=GetVirtualPixels(resize_image,0,y,resize_image->columns,1,\n        exception);\n      if ((q == (Quantum *) NULL) ||\n          (chroma_pixels == (const Quantum *) NULL))\n        break;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        SetPixelGreen(image,GetPixelGreen(resize_image,chroma_pixels),q);\n        SetPixelBlue(image,GetPixelBlue(resize_image,chroma_pixels),q);\n        chroma_pixels+=GetPixelChannels(resize_image);\n        q+=GetPixelChannels(image);\n      }\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        break;\n    }\n    resize_image=DestroyImage(resize_image);\n    if (SetImageColorspace(image,YCbCrColorspace,exception) == MagickFalse)\n      break;\n    if (interlace == PartitionInterlace)\n      (void) CopyMagickString(image->filename,image_info->filename,\n        MagickPathExtent);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if (interlace == NoInterlace)\n      count=ReadBlob(image,(size_t) (2*quantum*image->columns),scanline);\n    else\n      count=ReadBlob(image,(size_t) quantum*image->columns,scanline);\n    if (count != 0)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            scanline=(unsigned char *) RelinquishMagickMemory(scanline); \n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (count != 0);\n  scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n  (void) CloseBlob(image);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  return(GetFirstImageInList(image));\n}",
  "abstract_func": "static Image *ReadYUVImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)\n{\n  Image\n    *VAR_2,\n    *VAR_3,\n    *VAR_4;\n\n  InterlaceType\n    VAR_5;\n\n  MagickBooleanType\n    VAR_6;\n\n  register const Quantum\n    *VAR_7;\n\n  register ssize_t\n    VAR_8;\n\n  register Quantum\n    *VAR_9;\n\n  register unsigned char\n    *VAR_10;\n\n  ssize_t\n    VAR_11,\n    VAR_12,\n    VAR_13,\n    VAR_14;\n\n  size_t\n    VAR_15,\n    VAR_16;\n\n  unsigned char\n    *VAR_17;\n\n  /* COMMENT_0 */\n                             \n    \n  assert(VAR_0 != (const ImageInfo *) NULL);\n  assert(VAR_0->signature == VAR_18);\n  if (VAR_0->debug != VAR_19)\n    (void) LogMagickEvent(VAR_20,GetMagickModule(),\"%s\",\n      VAR_0->filename);\n  assert(VAR_1 != (ExceptionInfo *) NULL);\n  assert(VAR_1->signature == VAR_18);\n  VAR_3=AcquireImage(VAR_0,VAR_1);\n  if ((VAR_3->columns == 0) || (VAR_3->rows == 0))\n    ThrowReaderException(VAR_21,\"MustSpecifyImageSize\");\n  VAR_6=SetImageExtent(VAR_3,VAR_3->columns,VAR_3->rows,VAR_1);\n  if (VAR_6 == VAR_19)\n    return(DestroyImageList(VAR_3));\n  VAR_16=(ssize_t) (VAR_3->depth <= 8 ? 1 : 2);\n  VAR_5=VAR_0->interlace;\n  VAR_12=2;\n  VAR_13=2;\n  if (VAR_0->sampling_factor != (char *) NULL)\n    {\n      GeometryInfo\n        VAR_22;\n\n      MagickStatusType\n        VAR_23;\n\n      VAR_23=ParseGeometry(VAR_0->sampling_factor,&VAR_22);\n      VAR_12=(ssize_t) VAR_22.rho;\n      VAR_13=(ssize_t) VAR_22.sigma;\n      if ((VAR_23 & VAR_24) == 0)\n        VAR_13=VAR_12;\n      if ((VAR_12 != 1) && (VAR_12 != 2) &&\n          (VAR_13 != 1) && (VAR_13 != 2))\n        ThrowReaderException(VAR_25,\"UnexpectedSamplingFactor\");\n    }\n  if ((VAR_5 == VAR_26) ||\n      ((VAR_5 == VAR_27) && (VAR_13 == 2)))\n    {\n      VAR_5=VAR_27;    /* COMMENT_3 */\n      if (VAR_13 == 2)\n        VAR_5=VAR_28; /* COMMENT_4 */\n    }\n  if (VAR_5 != VAR_29)\n    {\n      /* COMMENT_5 */\n                        \n        \n      VAR_6=OpenBlob(VAR_0,VAR_3,VAR_30,VAR_1);\n      if (VAR_6 == VAR_19)\n        {\n          VAR_3=DestroyImageList(VAR_3);\n          return((Image *) NULL);\n        }\n      if (DiscardBlobBytes(VAR_3,(MagickSizeType) VAR_3->offset) == VAR_19)\n        ThrowFileException(VAR_1,VAR_25,\"UnexpectedEndOfFile\",\n          VAR_3->filename);\n    }\n  /* COMMENT_8 */\n                                   \n    \n  if (VAR_5 == VAR_27)\n    VAR_17=(unsigned char *) AcquireQuantumMemory((size_t) (2UL*\n      VAR_3->columns+2UL),(size_t) VAR_16*sizeof(*VAR_17));\n  else\n    VAR_17=(unsigned char *) AcquireQuantumMemory(VAR_3->columns,\n      (size_t) VAR_16*sizeof(*VAR_17));\n  if (VAR_17 == (unsigned char *) NULL)\n    ThrowReaderException(VAR_31,\"MemoryAllocationFailed\");\n  VAR_6=VAR_32;\n  do\n  {\n    VAR_2=CloneImage(VAR_3,(VAR_3->columns+VAR_12-1)/\n      VAR_12,(VAR_3->rows+VAR_13-1)/VAR_13,\n      VAR_32,VAR_1);\n    if (VAR_2 == (Image *) NULL)\n      {\n        VAR_17=(unsigned char *) RelinquishMagickMemory(VAR_17); \n        ThrowReaderException(VAR_31,\"MemoryAllocationFailed\");\n      }\n    /* COMMENT_11 */\n                                            \n      \n    if ((VAR_0->ping != VAR_19) && (VAR_0->number_scenes != 0))\n      if (VAR_3->scene >= (VAR_0->scene+VAR_0->number_scenes-1))\n        break;\n    VAR_6=SetImageExtent(VAR_3,VAR_3->columns,VAR_3->rows,VAR_1);\n    if (VAR_6 == VAR_19)\n      break;\n    if (VAR_5 == VAR_29)\n      {\n        AppendImageFormat(\"Y\",VAR_3->filename);\n        VAR_6=OpenBlob(VAR_0,VAR_3,VAR_30,VAR_1);\n        if (VAR_6 == VAR_19)\n          {\n            VAR_17=(unsigned char *) RelinquishMagickMemory(VAR_17); \n            VAR_3=DestroyImageList(VAR_3);\n            return((Image *) NULL);\n          }\n      }\n    for (VAR_14=0; VAR_14 < (ssize_t) VAR_3->rows; VAR_14++)\n    {\n      register Quantum\n        *VAR_7;\n\n      if (VAR_5 == VAR_27)\n        {\n          if ((VAR_14 > 0) || (GetPreviousImageInList(VAR_3) == (Image *) NULL))\n            {\n              VAR_15=2*VAR_16*VAR_3->columns;\n              VAR_11=ReadBlob(VAR_3,VAR_15,VAR_17);\n              if (VAR_11 != (ssize_t) VAR_15)\n                {\n                  VAR_6=VAR_19;\n                  ThrowFileException(VAR_1,VAR_25,\n                    \"UnexpectedEndOfFile\",VAR_3->filename);\n                  break;\n                }\n            }\n          VAR_10=VAR_17;\n          VAR_9=QueueAuthenticPixels(VAR_3,0,VAR_14,VAR_3->columns,1,VAR_1);\n          if (VAR_9 == (Quantum *) NULL)\n            break;\n          VAR_7=QueueAuthenticPixels(VAR_2,0,VAR_14,\n            VAR_2->columns,1,VAR_1);\n          if (VAR_7 == (Quantum *) NULL)\n            break;\n          for (VAR_8=0; VAR_8 < (ssize_t) VAR_3->columns; VAR_8+=2)\n          {\n            SetPixelRed(VAR_2,0,VAR_7);\n            if (VAR_16 == 1)\n              SetPixelGreen(VAR_2,ScaleCharToQuantum(*VAR_10++),\n                VAR_7);\n            else\n              {\n                SetPixelGreen(VAR_2,ScaleShortToQuantum(((*VAR_10) << 8) |\n                  *(VAR_10+1)),VAR_7);\n                VAR_10+=2;\n              }\n            if (VAR_16 == 1)\n              SetPixelRed(VAR_3,ScaleCharToQuantum(*VAR_10++),VAR_9);\n            else\n              {\n                SetPixelRed(VAR_3,ScaleShortToQuantum(((*VAR_10) << 8) | *(VAR_10+1)),VAR_9);\n                VAR_10+=2;\n              }\n            SetPixelGreen(VAR_3,0,VAR_9);\n            SetPixelBlue(VAR_3,0,VAR_9);\n            VAR_9+=GetPixelChannels(VAR_3);\n            SetPixelGreen(VAR_3,0,VAR_9);\n            SetPixelBlue(VAR_3,0,VAR_9);\n            if (VAR_16 == 1)\n              SetPixelBlue(VAR_2,ScaleCharToQuantum(*VAR_10++),VAR_7);\n            else\n              {\n                SetPixelBlue(VAR_2,ScaleShortToQuantum(((*VAR_10) << 8) |\n                  *(VAR_10+1)),VAR_7);\n                VAR_10+=2;\n              }\n            if (VAR_16 == 1)\n              SetPixelRed(VAR_3,ScaleCharToQuantum(*VAR_10++),VAR_9);\n            else\n              {\n                SetPixelRed(VAR_3,ScaleShortToQuantum(((*VAR_10) << 8) | *(VAR_10+1)),VAR_9);\n                VAR_10+=2;\n              }\n            VAR_7+=GetPixelChannels(VAR_2);\n            VAR_9+=GetPixelChannels(VAR_3);\n          }\n        }\n      else\n        {\n          if ((VAR_14 > 0) || (GetPreviousImageInList(VAR_3) == (Image *) NULL))\n            {\n              VAR_15=VAR_16*VAR_3->columns;\n              VAR_11=ReadBlob(VAR_3,VAR_15,VAR_17);\n              if (VAR_11 != (ssize_t) VAR_15)\n                {\n                  VAR_6=VAR_19;\n                  ThrowFileException(VAR_1,VAR_25,\n                    \"UnexpectedEndOfFile\",VAR_3->filename);\n                  break;\n                }\n            }\n          VAR_10=VAR_17;\n          VAR_9=QueueAuthenticPixels(VAR_3,0,VAR_14,VAR_3->columns,1,VAR_1);\n          if (VAR_9 == (Quantum *) NULL)\n            break;\n          for (VAR_8=0; VAR_8 < (ssize_t) VAR_3->columns; VAR_8++)\n          {\n            if (VAR_16 == 1)\n              SetPixelRed(VAR_3,ScaleCharToQuantum(*VAR_10++),VAR_9);\n            else\n              {\n                SetPixelRed(VAR_3,ScaleShortToQuantum(((*VAR_10) << 8) | *(VAR_10+1)),VAR_9);\n                VAR_10+=2;\n              }\n            SetPixelGreen(VAR_3,0,VAR_9);\n            SetPixelBlue(VAR_3,0,VAR_9);\n            VAR_9+=GetPixelChannels(VAR_3);\n          }\n        }\n      if (SyncAuthenticPixels(VAR_3,VAR_1) == VAR_19)\n        break;\n      if (VAR_5 == VAR_27)\n        if (SyncAuthenticPixels(VAR_2,VAR_1) == VAR_19)\n          break;\n      if (VAR_3->previous == (Image *) NULL)\n        {\n          VAR_6=SetImageProgress(VAR_3,VAR_33,(MagickOffsetType) VAR_14,\n            VAR_3->rows);\n          if (VAR_6 == VAR_19)\n            break;\n        }\n    }\n    if (VAR_5 == VAR_29)\n      {\n        (void) CloseBlob(VAR_3);\n        AppendImageFormat(\"U\",VAR_3->filename);\n        VAR_6=OpenBlob(VAR_0,VAR_3,VAR_30,VAR_1);\n        if (VAR_6 == VAR_19)\n          {\n            VAR_17=(unsigned char *) RelinquishMagickMemory(VAR_17); \n            VAR_3=DestroyImageList(VAR_3);\n            return((Image *) NULL);\n          }\n      }\n    if (VAR_5 != VAR_27)\n      {\n        for (VAR_14=0; VAR_14 < (ssize_t) VAR_2->rows; VAR_14++)\n        {\n          VAR_15=VAR_16*VAR_2->columns;\n          VAR_11=ReadBlob(VAR_3,VAR_15,VAR_17);\n          if (VAR_11 != (ssize_t) VAR_15)\n            {\n              VAR_6=VAR_19;\n              ThrowFileException(VAR_1,VAR_25,\n                \"UnexpectedEndOfFile\",VAR_3->filename);\n              break;\n            }\n          VAR_10=VAR_17;\n          VAR_9=QueueAuthenticPixels(VAR_2,0,VAR_14,VAR_2->columns,1,\n            VAR_1);\n          if (VAR_9 == (Quantum *) NULL)\n            break;\n          for (VAR_8=0; VAR_8 < (ssize_t) VAR_2->columns; VAR_8++)\n          {\n            SetPixelRed(VAR_2,0,VAR_9);\n            if (VAR_16 == 1)\n              SetPixelGreen(VAR_2,ScaleCharToQuantum(*VAR_10++),VAR_9);\n            else\n              {\n                SetPixelGreen(VAR_2,ScaleShortToQuantum(((*VAR_10) << 8) |\n                  *(VAR_10+1)),VAR_9);\n                VAR_10+=2;\n              }\n            SetPixelBlue(VAR_2,0,VAR_9);\n            VAR_9+=GetPixelChannels(VAR_2);\n          }\n          if (SyncAuthenticPixels(VAR_2,VAR_1) == VAR_19)\n            break;\n        }\n      if (VAR_5 == VAR_29)\n        {\n          (void) CloseBlob(VAR_3);\n          AppendImageFormat(\"V\",VAR_3->filename);\n          VAR_6=OpenBlob(VAR_0,VAR_3,VAR_30,VAR_1);\n          if (VAR_6 == VAR_19)\n            {\n              VAR_17=(unsigned char *) RelinquishMagickMemory(VAR_17); \n              VAR_3=DestroyImageList(VAR_3);\n              return((Image *) NULL);\n            }\n        }\n      for (VAR_14=0; VAR_14 < (ssize_t) VAR_2->rows; VAR_14++)\n      {\n        VAR_15=VAR_16*VAR_2->columns;\n        VAR_11=ReadBlob(VAR_3,VAR_15,VAR_17);\n        if (VAR_11 != (ssize_t) VAR_15)\n          {\n            VAR_6=VAR_19;\n            ThrowFileException(VAR_1,VAR_25,\n              \"UnexpectedEndOfFile\",VAR_3->filename);\n            break;\n          }\n        VAR_10=VAR_17;\n        VAR_9=GetAuthenticPixels(VAR_2,0,VAR_14,VAR_2->columns,1,\n          VAR_1);\n        if (VAR_9 == (Quantum *) NULL)\n          break;\n        for (VAR_8=0; VAR_8 < (ssize_t) VAR_2->columns; VAR_8++)\n        {\n          if (VAR_16 == 1)\n            SetPixelBlue(VAR_2,ScaleCharToQuantum(*VAR_10++),VAR_9);\n          else\n            {\n              SetPixelBlue(VAR_2,ScaleShortToQuantum(((*VAR_10) << 8) |\n                *(VAR_10+1)),VAR_9);\n              VAR_10+=2;\n            }\n          VAR_9+=GetPixelChannels(VAR_2);\n        }\n        if (SyncAuthenticPixels(VAR_2,VAR_1) == VAR_19)\n          break;\n      }\n    }\n    /* COMMENT_14 */\n                  \n      \n    VAR_4=ResizeImage(VAR_2,VAR_3->columns,VAR_3->rows,\n      VAR_34,VAR_1);\n    VAR_2=DestroyImage(VAR_2);\n    if (VAR_4 == (Image *) NULL)\n      {\n        VAR_17=(unsigned char *) RelinquishMagickMemory(VAR_17);   \n        ThrowReaderException(VAR_31,\"MemoryAllocationFailed\");\n      }\n    for (VAR_14=0; VAR_14 < (ssize_t) VAR_3->rows; VAR_14++)\n    {\n      VAR_9=GetAuthenticPixels(VAR_3,0,VAR_14,VAR_3->columns,1,VAR_1);\n      VAR_7=GetVirtualPixels(VAR_4,0,VAR_14,VAR_4->columns,1,\n        VAR_1);\n      if ((VAR_9 == (Quantum *) NULL) ||\n          (VAR_7 == (const Quantum *) NULL))\n        break;\n      for (VAR_8=0; VAR_8 < (ssize_t) VAR_3->columns; VAR_8++)\n      {\n        SetPixelGreen(VAR_3,GetPixelGreen(VAR_4,VAR_7),VAR_9);\n        SetPixelBlue(VAR_3,GetPixelBlue(VAR_4,VAR_7),VAR_9);\n        VAR_7+=GetPixelChannels(VAR_4);\n        VAR_9+=GetPixelChannels(VAR_3);\n      }\n      if (SyncAuthenticPixels(VAR_3,VAR_1) == VAR_19)\n        break;\n    }\n    VAR_4=DestroyImage(VAR_4);\n    if (SetImageColorspace(VAR_3,VAR_35,VAR_1) == VAR_19)\n      break;\n    if (VAR_5 == VAR_29)\n      (void) CopyMagickString(VAR_3->filename,VAR_0->filename,\n        VAR_36);\n    if (EOFBlob(VAR_3) != VAR_19)\n      {\n        ThrowFileException(VAR_1,VAR_25,\"UnexpectedEndOfFile\",\n          VAR_3->filename);\n        break;\n      }\n    /* COMMENT_17 */\n                            \n      \n    if (VAR_0->number_scenes != 0)\n      if (VAR_3->scene >= (VAR_0->scene+VAR_0->number_scenes-1))\n        break;\n    if (VAR_5 == VAR_27)\n      VAR_11=ReadBlob(VAR_3,(size_t) (2*VAR_16*VAR_3->columns),VAR_17);\n    else\n      VAR_11=ReadBlob(VAR_3,(size_t) VAR_16*VAR_3->columns,VAR_17);\n    if (VAR_11 != 0)\n      {\n        /* COMMENT_20 */\n                                        \n          \n        AcquireNextImage(VAR_0,VAR_3,VAR_1);\n        if (GetNextImageInList(VAR_3) == (Image *) NULL)\n          {\n            VAR_17=(unsigned char *) RelinquishMagickMemory(VAR_17); \n            VAR_3=DestroyImageList(VAR_3);\n            return((Image *) NULL);\n          }\n        VAR_3=SyncNextImageInList(VAR_3);\n        VAR_6=SetImageProgress(VAR_3,VAR_37,TellBlob(VAR_3),\n          GetBlobSize(VAR_3));\n        if (VAR_6 == VAR_19)\n          break;\n      }\n  } while (VAR_11 != 0);\n  VAR_17=(unsigned char *) RelinquishMagickMemory(VAR_17);\n  (void) CloseBlob(VAR_3);\n  if (VAR_6 == VAR_19)\n    return(DestroyImageList(VAR_3));\n  return(GetFirstImageInList(VAR_3));\n}",
  "func_graph_path": "ImageMagick/ef8f40689ac452398026c07da41656a7c87e4683/yuv.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -113,7 +113,10 @@\n       horizontal_factor,(image->rows+vertical_factor-1)/vertical_factor,\n       MagickTrue,exception);\n     if (chroma_image == (Image *) NULL)\n-      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n+      {\n+        scanline=(unsigned char *) RelinquishMagickMemory(scanline); \n+        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n+      }\n     /*\n       Convert raster image to pixel packets.\n     */\n@@ -129,6 +132,7 @@\n         status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n         if (status == MagickFalse)\n           {\n+            scanline=(unsigned char *) RelinquishMagickMemory(scanline); \n             image=DestroyImageList(image);\n             return((Image *) NULL);\n           }\n@@ -255,6 +259,7 @@\n         status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n         if (status == MagickFalse)\n           {\n+            scanline=(unsigned char *) RelinquishMagickMemory(scanline); \n             image=DestroyImageList(image);\n             return((Image *) NULL);\n           }\n@@ -301,6 +306,7 @@\n           status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n           if (status == MagickFalse)\n             {\n+              scanline=(unsigned char *) RelinquishMagickMemory(scanline); \n               image=DestroyImageList(image);\n               return((Image *) NULL);\n             }\n@@ -344,7 +350,10 @@\n       TriangleFilter,exception);\n     chroma_image=DestroyImage(chroma_image);\n     if (resize_image == (Image *) NULL)\n-      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n+      {\n+        scanline=(unsigned char *) RelinquishMagickMemory(scanline);   \n+        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n+      }\n     for (y=0; y < (ssize_t) image->rows; y++)\n     {\n       q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n@@ -393,6 +402,7 @@\n         AcquireNextImage(image_info,image,exception);\n         if (GetNextImageInList(image) == (Image *) NULL)\n           {\n+            scanline=(unsigned char *) RelinquishMagickMemory(scanline); \n             image=DestroyImageList(image);\n             return((Image *) NULL);\n           }",
  "diff_line_info": {
    "deleted_lines": [
      "      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");",
      "      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");"
    ],
    "added_lines": [
      "      {",
      "        scanline=(unsigned char *) RelinquishMagickMemory(scanline); ",
      "        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");",
      "      }",
      "            scanline=(unsigned char *) RelinquishMagickMemory(scanline); ",
      "            scanline=(unsigned char *) RelinquishMagickMemory(scanline); ",
      "              scanline=(unsigned char *) RelinquishMagickMemory(scanline); ",
      "      {",
      "        scanline=(unsigned char *) RelinquishMagickMemory(scanline);   ",
      "        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");",
      "      }",
      "            scanline=(unsigned char *) RelinquishMagickMemory(scanline); "
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/ImageMagick/ImageMagick/pull/756",
  "description": {
    "pr_info": {
      "title": "fix multiple memory leak in ReadYUVImage",
      "number": 756
    },
    "comment": [
      "We found that there is multiple memory leak vulnerability in ReadYUVImage because no memory free on exception condition. And we create patch here.\r\n\r\nCredit: ADLab of Venustech",
      "Thanks for this pull request could you also make one fro the IM6 branch?",
      "@dlemstra i will test im6 later",
      "This was assigned CVE-2017-15033."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 1.0  \n\nThe commit fixes multiple memory leaks in ReadYUVImage by ensuring memory is freed on exception conditions, directly addressing a security vulnerability. The changes are consistent with both the commit message and vulnerability description, confirming it's a security fix."
}