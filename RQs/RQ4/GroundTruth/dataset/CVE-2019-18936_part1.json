{
  "cve_id": "CVE-2019-18936",
  "cwe_ids": [
    "CWE-674"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "jgarzik/univalue",
  "commit_msg": "UniValue::read(): Clear internal state upon error\n\nAvoid parsing edge cases that leave the class internal data in an\ninconsistent state, when the parser encounters an input data error.\n\nThis is a rewrite of PR #39 by @awemany.",
  "commit_hash": "07aa635c034f3a2accfe4e20a8148c366bccf5bf",
  "git_url": "https://github.com/jgarzik/univalue/commit/07aa635c034f3a2accfe4e20a8148c366bccf5bf",
  "file_path": "lib/univalue_read.cpp",
  "func_name": "UniValue::read",
  "func_before": "bool UniValue::read(const char *raw, size_t size)\n{\n    clear();\n\n    uint32_t expectMask = 0;\n    std::vector<UniValue*> stack;\n\n    std::string tokenVal;\n    unsigned int consumed;\n    enum jtokentype tok = JTOK_NONE;\n    enum jtokentype last_tok = JTOK_NONE;\n    const char* end = raw + size;\n    do {\n        last_tok = tok;\n\n        tok = getJsonToken(tokenVal, consumed, raw, end);\n        if (tok == JTOK_NONE || tok == JTOK_ERR)\n            return false;\n        raw += consumed;\n\n        bool isValueOpen = jsonTokenIsValue(tok) ||\n            tok == JTOK_OBJ_OPEN || tok == JTOK_ARR_OPEN;\n\n        if (expect(VALUE)) {\n            if (!isValueOpen)\n                return false;\n            clearExpect(VALUE);\n\n        } else if (expect(ARR_VALUE)) {\n            bool isArrValue = isValueOpen || (tok == JTOK_ARR_CLOSE);\n            if (!isArrValue)\n                return false;\n\n            clearExpect(ARR_VALUE);\n\n        } else if (expect(OBJ_NAME)) {\n            bool isObjName = (tok == JTOK_OBJ_CLOSE || tok == JTOK_STRING);\n            if (!isObjName)\n                return false;\n\n        } else if (expect(COLON)) {\n            if (tok != JTOK_COLON)\n                return false;\n            clearExpect(COLON);\n\n        } else if (!expect(COLON) && (tok == JTOK_COLON)) {\n            return false;\n        }\n\n        if (expect(NOT_VALUE)) {\n            if (isValueOpen)\n                return false;\n            clearExpect(NOT_VALUE);\n        }\n\n        switch (tok) {\n\n        case JTOK_OBJ_OPEN:\n        case JTOK_ARR_OPEN: {\n            VType utyp = (tok == JTOK_OBJ_OPEN ? VOBJ : VARR);\n            if (!stack.size()) {\n                if (utyp == VOBJ)\n                    setObject();\n                else\n                    setArray();\n                stack.push_back(this);\n            } else {\n                UniValue tmpVal(utyp);\n                UniValue *top = stack.back();\n                top->values.push_back(tmpVal);\n\n                UniValue *newTop = &(top->values.back());\n                stack.push_back(newTop);\n            }\n\n            if (utyp == VOBJ)\n                setExpect(OBJ_NAME);\n            else\n                setExpect(ARR_VALUE);\n            break;\n            }\n\n        case JTOK_OBJ_CLOSE:\n        case JTOK_ARR_CLOSE: {\n            if (!stack.size() || (last_tok == JTOK_COMMA))\n                return false;\n\n            VType utyp = (tok == JTOK_OBJ_CLOSE ? VOBJ : VARR);\n            UniValue *top = stack.back();\n            if (utyp != top->getType())\n                return false;\n\n            stack.pop_back();\n            clearExpect(OBJ_NAME);\n            setExpect(NOT_VALUE);\n            break;\n            }\n\n        case JTOK_COLON: {\n            if (!stack.size())\n                return false;\n\n            UniValue *top = stack.back();\n            if (top->getType() != VOBJ)\n                return false;\n\n            setExpect(VALUE);\n            break;\n            }\n\n        case JTOK_COMMA: {\n            if (!stack.size() ||\n                (last_tok == JTOK_COMMA) || (last_tok == JTOK_ARR_OPEN))\n                return false;\n\n            UniValue *top = stack.back();\n            if (top->getType() == VOBJ)\n                setExpect(OBJ_NAME);\n            else\n                setExpect(ARR_VALUE);\n            break;\n            }\n\n        case JTOK_KW_NULL:\n        case JTOK_KW_TRUE:\n        case JTOK_KW_FALSE: {\n            UniValue tmpVal;\n            switch (tok) {\n            case JTOK_KW_NULL:\n                // do nothing more\n                break;\n            case JTOK_KW_TRUE:\n                tmpVal.setBool(true);\n                break;\n            case JTOK_KW_FALSE:\n                tmpVal.setBool(false);\n                break;\n            default: /* impossible */ break;\n            }\n\n            if (!stack.size()) {\n                *this = tmpVal;\n                break;\n            }\n\n            UniValue *top = stack.back();\n            top->values.push_back(tmpVal);\n\n            setExpect(NOT_VALUE);\n            break;\n            }\n\n        case JTOK_NUMBER: {\n            UniValue tmpVal(VNUM, tokenVal);\n            if (!stack.size()) {\n                *this = tmpVal;\n                break;\n            }\n\n            UniValue *top = stack.back();\n            top->values.push_back(tmpVal);\n\n            setExpect(NOT_VALUE);\n            break;\n            }\n\n        case JTOK_STRING: {\n            if (expect(OBJ_NAME)) {\n                UniValue *top = stack.back();\n                top->keys.push_back(tokenVal);\n                clearExpect(OBJ_NAME);\n                setExpect(COLON);\n            } else {\n                UniValue tmpVal(VSTR, tokenVal);\n                if (!stack.size()) {\n                    *this = tmpVal;\n                    break;\n                }\n                UniValue *top = stack.back();\n                top->values.push_back(tmpVal);\n            }\n\n            setExpect(NOT_VALUE);\n            break;\n            }\n\n        default:\n            return false;\n        }\n    } while (!stack.empty ());\n\n    /* Check that nothing follows the initial construct (parsed above).  */\n    tok = getJsonToken(tokenVal, consumed, raw, end);\n    if (tok != JTOK_NONE)\n        return false;\n\n    return true;\n}",
  "abstract_func_before": "bool UniValue::read(const char *VAR_0, size_t VAR_1)\n{\n    clear();\n\n    uint32_t VAR_2 = 0;\n    std::vector<UniValue*> VAR_3;\n\n    std::string VAR_4;\n    unsigned int VAR_5;\n    enum jtokentype VAR_6 = VAR_7;\n    enum jtokentype VAR_8 = VAR_7;\n    const char* VAR_9 = VAR_0 + VAR_1;\n    do {\n        VAR_8 = VAR_6;\n\n        VAR_6 = getJsonToken(VAR_4, VAR_5, VAR_0, VAR_9);\n        if (VAR_6 == VAR_7 || VAR_6 == VAR_10)\n            return false;\n        VAR_0 += VAR_5;\n\n        bool VAR_11 = jsonTokenIsValue(VAR_6) ||\n            VAR_6 == VAR_12 || VAR_6 == VAR_13;\n\n        if (expect(VAR_14)) {\n            if (!VAR_11)\n                return false;\n            clearExpect(VAR_14);\n\n        } else if (expect(VAR_15)) {\n            bool VAR_16 = VAR_11 || (VAR_6 == VAR_17);\n            if (!VAR_16)\n                return false;\n\n            clearExpect(VAR_15);\n\n        } else if (expect(VAR_18)) {\n            bool VAR_19 = (VAR_6 == VAR_20 || VAR_6 == VAR_21);\n            if (!VAR_19)\n                return false;\n\n        } else if (expect(VAR_22)) {\n            if (VAR_6 != VAR_23)\n                return false;\n            clearExpect(VAR_22);\n\n        } else if (!expect(VAR_22) && (VAR_6 == VAR_23)) {\n            return false;\n        }\n\n        if (expect(VAR_24)) {\n            if (VAR_11)\n                return false;\n            clearExpect(VAR_24);\n        }\n\n        switch (VAR_6) {\n\n        case VAR_12:\n        case VAR_13: {\n            VType VAR_25 = (VAR_6 == VAR_12 ? VAR_26 : VAR_27);\n            if (!VAR_3.size()) {\n                if (VAR_25 == VAR_26)\n                    setObject();\n                else\n                    setArray();\n                VAR_3.push_back(this);\n            } else {\n                UniValue tmpVal(utyp);\n                UniValue *VAR_28 = VAR_3.back();\n                VAR_28->values.push_back(VAR_29);\n\n                UniValue *VAR_30 = &(VAR_28->values.back());\n                VAR_3.push_back(VAR_30);\n            }\n\n            if (utyp == VAR_26)\n                setExpect(VAR_18);\n            else\n                setExpect(VAR_15);\n            break;\n            }\n\n        case VAR_20:\n        case VAR_17: {\n            if (!VAR_3.size() || (VAR_8 == VAR_31))\n                return false;\n\n            VType utyp = (VAR_6 == VAR_20 ? VAR_26 : VAR_27);\n            UniValue *VAR_28 = VAR_3.back();\n            if (utyp != VAR_28->getType())\n                return false;\n\n            VAR_3.pop_back();\n            clearExpect(VAR_18);\n            setExpect(VAR_24);\n            break;\n            }\n\n        case VAR_23: {\n            if (!VAR_3.size())\n                return false;\n\n            UniValue *VAR_28 = VAR_3.back();\n            if (VAR_28->getType() != VAR_26)\n                return false;\n\n            setExpect(VAR_14);\n            break;\n            }\n\n        case VAR_31: {\n            if (!VAR_3.size() ||\n                (VAR_8 == VAR_31) || (VAR_8 == VAR_13))\n                return false;\n\n            UniValue *VAR_28 = VAR_3.back();\n            if (VAR_28->getType() == VAR_26)\n                setExpect(VAR_18);\n            else\n                setExpect(VAR_15);\n            break;\n            }\n\n        case VAR_32:\n        case VAR_33:\n        case VAR_34: {\n            UniValue VAR_29;\n            switch (VAR_6) {\n            case VAR_32:\n                /* COMMENT_0 */\n                break;\n            case VAR_33:\n                VAR_29.setBool(true);\n                break;\n            case VAR_34:\n                VAR_29.setBool(false);\n                break;\n            default: /* COMMENT_1 */ break;\n            }\n\n            if (!VAR_3.size()) {\n                *this = VAR_29;\n                break;\n            }\n\n            UniValue *VAR_28 = VAR_3.back();\n            VAR_28->values.push_back(VAR_29);\n\n            setExpect(VAR_24);\n            break;\n            }\n\n        case VAR_35: {\n            UniValue tmpVal(VNUM, tokenVal);\n            if (!VAR_3.size()) {\n                *this = VAR_29;\n                break;\n            }\n\n            UniValue *VAR_28 = VAR_3.back();\n            VAR_28->values.push_back(VAR_29);\n\n            setExpect(VAR_24);\n            break;\n            }\n\n        case VAR_21: {\n            if (expect(VAR_18)) {\n                UniValue *VAR_28 = VAR_3.back();\n                VAR_28->keys.push_back(tokenVal);\n                clearExpect(VAR_18);\n                setExpect(VAR_22);\n            } else {\n                UniValue tmpVal(VSTR, tokenVal);\n                if (!VAR_3.size()) {\n                    *this = VAR_29;\n                    break;\n                }\n                UniValue *VAR_28 = VAR_3.back();\n                VAR_28->values.push_back(VAR_29);\n            }\n\n            setExpect(VAR_24);\n            break;\n            }\n\n        default:\n            return false;\n        }\n    } while (!VAR_3.empty ());\n\n    /* COMMENT_2 */\n    VAR_6 = getJsonToken(tokenVal, VAR_5, VAR_0, VAR_9);\n    if (VAR_6 != VAR_7)\n        return false;\n\n    return true;\n}",
  "func_graph_path_before": "jgarzik/univalue/07aa635c034f3a2accfe4e20a8148c366bccf5bf/univalue_read.cpp/vul/before/0.json",
  "func": "bool UniValue::read(const char *raw, size_t size)\n{\n    clear();\n\n    uint32_t expectMask = 0;\n    std::vector<UniValue*> stack;\n\n    std::string tokenVal;\n    unsigned int consumed;\n    enum jtokentype tok = JTOK_NONE;\n    enum jtokentype last_tok = JTOK_NONE;\n    const char* end = raw + size;\n    do {\n        last_tok = tok;\n\n        tok = getJsonToken(tokenVal, consumed, raw, end);\n        if (tok == JTOK_NONE || tok == JTOK_ERR)\n            goto return_fail;\n        raw += consumed;\n\n        bool isValueOpen = jsonTokenIsValue(tok) ||\n            tok == JTOK_OBJ_OPEN || tok == JTOK_ARR_OPEN;\n\n        if (expect(VALUE)) {\n            if (!isValueOpen)\n                goto return_fail;\n            clearExpect(VALUE);\n\n        } else if (expect(ARR_VALUE)) {\n            bool isArrValue = isValueOpen || (tok == JTOK_ARR_CLOSE);\n            if (!isArrValue)\n                goto return_fail;\n\n            clearExpect(ARR_VALUE);\n\n        } else if (expect(OBJ_NAME)) {\n            bool isObjName = (tok == JTOK_OBJ_CLOSE || tok == JTOK_STRING);\n            if (!isObjName)\n                goto return_fail;\n\n        } else if (expect(COLON)) {\n            if (tok != JTOK_COLON)\n                goto return_fail;\n            clearExpect(COLON);\n\n        } else if (!expect(COLON) && (tok == JTOK_COLON)) {\n            goto return_fail;\n        }\n\n        if (expect(NOT_VALUE)) {\n            if (isValueOpen)\n                goto return_fail;\n            clearExpect(NOT_VALUE);\n        }\n\n        switch (tok) {\n\n        case JTOK_OBJ_OPEN:\n        case JTOK_ARR_OPEN: {\n            VType utyp = (tok == JTOK_OBJ_OPEN ? VOBJ : VARR);\n            if (!stack.size()) {\n                if (utyp == VOBJ)\n                    setObject();\n                else\n                    setArray();\n                stack.push_back(this);\n            } else {\n                UniValue tmpVal(utyp);\n                UniValue *top = stack.back();\n                top->values.push_back(tmpVal);\n\n                UniValue *newTop = &(top->values.back());\n                stack.push_back(newTop);\n            }\n\n            if (utyp == VOBJ)\n                setExpect(OBJ_NAME);\n            else\n                setExpect(ARR_VALUE);\n            break;\n            }\n\n        case JTOK_OBJ_CLOSE:\n        case JTOK_ARR_CLOSE: {\n            if (!stack.size() || (last_tok == JTOK_COMMA))\n                goto return_fail;\n\n            VType utyp = (tok == JTOK_OBJ_CLOSE ? VOBJ : VARR);\n            UniValue *top = stack.back();\n            if (utyp != top->getType())\n                goto return_fail;\n\n            stack.pop_back();\n            clearExpect(OBJ_NAME);\n            setExpect(NOT_VALUE);\n            break;\n            }\n\n        case JTOK_COLON: {\n            if (!stack.size())\n                goto return_fail;\n\n            UniValue *top = stack.back();\n            if (top->getType() != VOBJ)\n                goto return_fail;\n\n            setExpect(VALUE);\n            break;\n            }\n\n        case JTOK_COMMA: {\n            if (!stack.size() ||\n                (last_tok == JTOK_COMMA) || (last_tok == JTOK_ARR_OPEN))\n                goto return_fail;\n\n            UniValue *top = stack.back();\n            if (top->getType() == VOBJ)\n                setExpect(OBJ_NAME);\n            else\n                setExpect(ARR_VALUE);\n            break;\n            }\n\n        case JTOK_KW_NULL:\n        case JTOK_KW_TRUE:\n        case JTOK_KW_FALSE: {\n            UniValue tmpVal;\n            switch (tok) {\n            case JTOK_KW_NULL:\n                // do nothing more\n                break;\n            case JTOK_KW_TRUE:\n                tmpVal.setBool(true);\n                break;\n            case JTOK_KW_FALSE:\n                tmpVal.setBool(false);\n                break;\n            default: /* impossible */ break;\n            }\n\n            if (!stack.size()) {\n                *this = tmpVal;\n                break;\n            }\n\n            UniValue *top = stack.back();\n            top->values.push_back(tmpVal);\n\n            setExpect(NOT_VALUE);\n            break;\n            }\n\n        case JTOK_NUMBER: {\n            UniValue tmpVal(VNUM, tokenVal);\n            if (!stack.size()) {\n                *this = tmpVal;\n                break;\n            }\n\n            UniValue *top = stack.back();\n            top->values.push_back(tmpVal);\n\n            setExpect(NOT_VALUE);\n            break;\n            }\n\n        case JTOK_STRING: {\n            if (expect(OBJ_NAME)) {\n                UniValue *top = stack.back();\n                top->keys.push_back(tokenVal);\n                clearExpect(OBJ_NAME);\n                setExpect(COLON);\n            } else {\n                UniValue tmpVal(VSTR, tokenVal);\n                if (!stack.size()) {\n                    *this = tmpVal;\n                    break;\n                }\n                UniValue *top = stack.back();\n                top->values.push_back(tmpVal);\n            }\n\n            setExpect(NOT_VALUE);\n            break;\n            }\n\n        default:\n            goto return_fail;\n        }\n    } while (!stack.empty ());\n\n    /* Check that nothing follows the initial construct (parsed above).  */\n    tok = getJsonToken(tokenVal, consumed, raw, end);\n    if (tok != JTOK_NONE)\n        goto return_fail;\n\n    return true;\n\nreturn_fail:\n    clear();\n    return false;\n}",
  "abstract_func": "bool UniValue::read(const char *VAR_0, size_t VAR_1)\n{\n    clear();\n\n    uint32_t VAR_2 = 0;\n    std::vector<UniValue*> VAR_3;\n\n    std::string VAR_4;\n    unsigned int VAR_5;\n    enum jtokentype VAR_6 = VAR_7;\n    enum jtokentype VAR_8 = VAR_7;\n    const char* VAR_9 = VAR_0 + VAR_1;\n    do {\n        VAR_8 = VAR_6;\n\n        VAR_6 = getJsonToken(VAR_4, VAR_5, VAR_0, VAR_9);\n        if (VAR_6 == VAR_7 || VAR_6 == VAR_10)\n            goto return_fail;\n        VAR_0 += VAR_5;\n\n        bool VAR_11 = jsonTokenIsValue(VAR_6) ||\n            VAR_6 == VAR_12 || VAR_6 == VAR_13;\n\n        if (expect(VAR_14)) {\n            if (!VAR_11)\n                goto return_fail;\n            clearExpect(VAR_14);\n\n        } else if (expect(VAR_15)) {\n            bool VAR_16 = VAR_11 || (VAR_6 == VAR_17);\n            if (!VAR_16)\n                goto return_fail;\n\n            clearExpect(VAR_15);\n\n        } else if (expect(VAR_18)) {\n            bool VAR_19 = (VAR_6 == VAR_20 || VAR_6 == VAR_21);\n            if (!VAR_19)\n                goto return_fail;\n\n        } else if (expect(VAR_22)) {\n            if (VAR_6 != VAR_23)\n                goto return_fail;\n            clearExpect(VAR_22);\n\n        } else if (!expect(VAR_22) && (VAR_6 == VAR_23)) {\n            goto return_fail;\n        }\n\n        if (expect(VAR_24)) {\n            if (VAR_11)\n                goto return_fail;\n            clearExpect(VAR_24);\n        }\n\n        switch (VAR_6) {\n\n        case VAR_12:\n        case VAR_13: {\n            VType VAR_25 = (VAR_6 == VAR_12 ? VAR_26 : VAR_27);\n            if (!VAR_3.size()) {\n                if (VAR_25 == VAR_26)\n                    setObject();\n                else\n                    setArray();\n                VAR_3.push_back(this);\n            } else {\n                UniValue tmpVal(utyp);\n                UniValue *VAR_28 = VAR_3.back();\n                VAR_28->values.push_back(VAR_29);\n\n                UniValue *VAR_30 = &(VAR_28->values.back());\n                VAR_3.push_back(VAR_30);\n            }\n\n            if (utyp == VAR_26)\n                setExpect(VAR_18);\n            else\n                setExpect(VAR_15);\n            break;\n            }\n\n        case VAR_20:\n        case VAR_17: {\n            if (!VAR_3.size() || (VAR_8 == VAR_31))\n                goto return_fail;\n\n            VType utyp = (VAR_6 == VAR_20 ? VAR_26 : VAR_27);\n            UniValue *VAR_28 = VAR_3.back();\n            if (utyp != VAR_28->getType())\n                goto return_fail;\n\n            VAR_3.pop_back();\n            clearExpect(VAR_18);\n            setExpect(VAR_24);\n            break;\n            }\n\n        case VAR_23: {\n            if (!VAR_3.size())\n                goto return_fail;\n\n            UniValue *VAR_28 = VAR_3.back();\n            if (VAR_28->getType() != VAR_26)\n                goto return_fail;\n\n            setExpect(VAR_14);\n            break;\n            }\n\n        case VAR_31: {\n            if (!VAR_3.size() ||\n                (VAR_8 == VAR_31) || (VAR_8 == VAR_13))\n                goto return_fail;\n\n            UniValue *VAR_28 = VAR_3.back();\n            if (VAR_28->getType() == VAR_26)\n                setExpect(VAR_18);\n            else\n                setExpect(VAR_15);\n            break;\n            }\n\n        case VAR_32:\n        case VAR_33:\n        case VAR_34: {\n            UniValue VAR_29;\n            switch (VAR_6) {\n            case VAR_32:\n                /* COMMENT_0 */\n                break;\n            case VAR_33:\n                VAR_29.setBool(true);\n                break;\n            case VAR_34:\n                VAR_29.setBool(false);\n                break;\n            default: /* COMMENT_1 */ break;\n            }\n\n            if (!VAR_3.size()) {\n                *this = VAR_29;\n                break;\n            }\n\n            UniValue *VAR_28 = VAR_3.back();\n            VAR_28->values.push_back(VAR_29);\n\n            setExpect(VAR_24);\n            break;\n            }\n\n        case VAR_35: {\n            UniValue tmpVal(VNUM, tokenVal);\n            if (!VAR_3.size()) {\n                *this = VAR_29;\n                break;\n            }\n\n            UniValue *VAR_28 = VAR_3.back();\n            VAR_28->values.push_back(VAR_29);\n\n            setExpect(VAR_24);\n            break;\n            }\n\n        case VAR_21: {\n            if (expect(VAR_18)) {\n                UniValue *VAR_28 = VAR_3.back();\n                VAR_28->keys.push_back(tokenVal);\n                clearExpect(VAR_18);\n                setExpect(VAR_22);\n            } else {\n                UniValue tmpVal(VSTR, tokenVal);\n                if (!VAR_3.size()) {\n                    *this = VAR_29;\n                    break;\n                }\n                UniValue *VAR_28 = VAR_3.back();\n                VAR_28->values.push_back(VAR_29);\n            }\n\n            setExpect(VAR_24);\n            break;\n            }\n\n        default:\n            goto return_fail;\n        }\n    } while (!VAR_3.empty ());\n\n    /* COMMENT_2 */\n    VAR_6 = getJsonToken(tokenVal, VAR_5, VAR_0, VAR_9);\n    if (VAR_6 != VAR_7)\n        goto return_fail;\n\n    return true;\n\nreturn_fail:\n    clear();\n    return false;\n}",
  "func_graph_path": "jgarzik/univalue/07aa635c034f3a2accfe4e20a8148c366bccf5bf/univalue_read.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -15,7 +15,7 @@\n \n         tok = getJsonToken(tokenVal, consumed, raw, end);\n         if (tok == JTOK_NONE || tok == JTOK_ERR)\n-            return false;\n+            goto return_fail;\n         raw += consumed;\n \n         bool isValueOpen = jsonTokenIsValue(tok) ||\n@@ -23,33 +23,33 @@\n \n         if (expect(VALUE)) {\n             if (!isValueOpen)\n-                return false;\n+                goto return_fail;\n             clearExpect(VALUE);\n \n         } else if (expect(ARR_VALUE)) {\n             bool isArrValue = isValueOpen || (tok == JTOK_ARR_CLOSE);\n             if (!isArrValue)\n-                return false;\n+                goto return_fail;\n \n             clearExpect(ARR_VALUE);\n \n         } else if (expect(OBJ_NAME)) {\n             bool isObjName = (tok == JTOK_OBJ_CLOSE || tok == JTOK_STRING);\n             if (!isObjName)\n-                return false;\n+                goto return_fail;\n \n         } else if (expect(COLON)) {\n             if (tok != JTOK_COLON)\n-                return false;\n+                goto return_fail;\n             clearExpect(COLON);\n \n         } else if (!expect(COLON) && (tok == JTOK_COLON)) {\n-            return false;\n+            goto return_fail;\n         }\n \n         if (expect(NOT_VALUE)) {\n             if (isValueOpen)\n-                return false;\n+                goto return_fail;\n             clearExpect(NOT_VALUE);\n         }\n \n@@ -83,12 +83,12 @@\n         case JTOK_OBJ_CLOSE:\n         case JTOK_ARR_CLOSE: {\n             if (!stack.size() || (last_tok == JTOK_COMMA))\n-                return false;\n+                goto return_fail;\n \n             VType utyp = (tok == JTOK_OBJ_CLOSE ? VOBJ : VARR);\n             UniValue *top = stack.back();\n             if (utyp != top->getType())\n-                return false;\n+                goto return_fail;\n \n             stack.pop_back();\n             clearExpect(OBJ_NAME);\n@@ -98,11 +98,11 @@\n \n         case JTOK_COLON: {\n             if (!stack.size())\n-                return false;\n+                goto return_fail;\n \n             UniValue *top = stack.back();\n             if (top->getType() != VOBJ)\n-                return false;\n+                goto return_fail;\n \n             setExpect(VALUE);\n             break;\n@@ -111,7 +111,7 @@\n         case JTOK_COMMA: {\n             if (!stack.size() ||\n                 (last_tok == JTOK_COMMA) || (last_tok == JTOK_ARR_OPEN))\n-                return false;\n+                goto return_fail;\n \n             UniValue *top = stack.back();\n             if (top->getType() == VOBJ)\n@@ -185,14 +185,18 @@\n             }\n \n         default:\n-            return false;\n+            goto return_fail;\n         }\n     } while (!stack.empty ());\n \n     /* Check that nothing follows the initial construct (parsed above).  */\n     tok = getJsonToken(tokenVal, consumed, raw, end);\n     if (tok != JTOK_NONE)\n-        return false;\n+        goto return_fail;\n \n     return true;\n+\n+return_fail:\n+    clear();\n+    return false;\n }",
  "diff_line_info": {
    "deleted_lines": [
      "            return false;",
      "                return false;",
      "                return false;",
      "                return false;",
      "                return false;",
      "            return false;",
      "                return false;",
      "                return false;",
      "                return false;",
      "                return false;",
      "                return false;",
      "                return false;",
      "            return false;",
      "        return false;"
    ],
    "added_lines": [
      "            goto return_fail;",
      "                goto return_fail;",
      "                goto return_fail;",
      "                goto return_fail;",
      "                goto return_fail;",
      "            goto return_fail;",
      "                goto return_fail;",
      "                goto return_fail;",
      "                goto return_fail;",
      "                goto return_fail;",
      "                goto return_fail;",
      "                goto return_fail;",
      "            goto return_fail;",
      "        goto return_fail;",
      "",
      "return_fail:",
      "    clear();",
      "    return false;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/jgarzik/univalue/pull/58",
  "description": "Failed to get PR details: HTTP Request Error for PR https://github.com/jgarzik/univalue/pull/58: 403 Client Error: Forbidden for url: https://api.github.com/repos/jgarzik/univalue/pulls/58",
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix  \n**Confidence:** 0.9"
}