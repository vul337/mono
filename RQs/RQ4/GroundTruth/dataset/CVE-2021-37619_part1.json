{
  "cve_id": "CVE-2021-37619",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "Exiv2/exiv2",
  "commit_msg": "Fix incorrect loop condition.",
  "commit_hash": "9be257340193dbe3fb810aa33531c40ae9df6414",
  "git_url": "https://github.com/Exiv2/exiv2/commit/9be257340193dbe3fb810aa33531c40ae9df6414",
  "file_path": "src/jp2image.cpp",
  "func_name": "Jp2Image::encodeJp2Header",
  "func_before": "void Jp2Image::encodeJp2Header(const DataBuf& boxBuf,DataBuf& outBuf)\n    {\n        DataBuf output(boxBuf.size_ + iccProfile_.size_ + 100); // allocate sufficient space\n        long    outlen = sizeof(Jp2BoxHeader) ; // now many bytes have we written to output?\n        long    inlen = sizeof(Jp2BoxHeader) ; // how many bytes have we read from boxBuf?\n        enforce(sizeof(Jp2BoxHeader) <= static_cast<size_t>(output.size_), Exiv2::kerCorruptedMetadata);\n        Jp2BoxHeader* pBox   = (Jp2BoxHeader*) boxBuf.pData_;\n        uint32_t      length = getLong((byte*)&pBox->length, bigEndian);\n        enforce(length <= static_cast<size_t>(output.size_), Exiv2::kerCorruptedMetadata);\n        uint32_t      count  = sizeof (Jp2BoxHeader);\n        char*         p      = (char*) boxBuf.pData_;\n        bool          bWroteColor = false ;\n\n        while ( count < length || !bWroteColor ) {\n            enforce(sizeof(Jp2BoxHeader) <= length - count, Exiv2::kerCorruptedMetadata);\n            Jp2BoxHeader* pSubBox = (Jp2BoxHeader*) (p+count) ;\n\n            // copy data.  pointer could be into a memory mapped file which we will decode!\n            Jp2BoxHeader   subBox = *pSubBox ;\n            Jp2BoxHeader   newBox =  subBox;\n\n            if ( count < length ) {\n                subBox.length = getLong((byte*)&subBox.length, bigEndian);\n                subBox.type   = getLong((byte*)&subBox.type  , bigEndian);\n#ifdef EXIV2_DEBUG_MESSAGES\n                std::cout << \"Jp2Image::encodeJp2Header subbox: \"<< toAscii(subBox.type) << \" length = \" << subBox.length << std::endl;\n#endif\n                enforce(subBox.length > 0, Exiv2::kerCorruptedMetadata);\n                enforce(subBox.length <= length - count, Exiv2::kerCorruptedMetadata);\n                count        += subBox.length;\n                newBox.type   = subBox.type;\n            } else {\n                subBox.length=0;\n                newBox.type = kJp2BoxTypeColorHeader;\n                count = length;\n            }\n\n            uint32_t newlen = subBox.length;\n            if ( newBox.type == kJp2BoxTypeColorHeader ) {\n                bWroteColor = true ;\n                if ( ! iccProfileDefined() ) {\n                    const char* pad   = \"\\x01\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x05\\x1cuuid\";\n                    uint32_t    psize = 15;\n                    newlen            = sizeof(newBox) + psize ;\n                    enforce(newlen <= static_cast<size_t>(output.size_ - outlen), Exiv2::kerCorruptedMetadata);\n                    ul2Data((byte*)&newBox.length,psize      ,bigEndian);\n                    ul2Data((byte*)&newBox.type  ,newBox.type,bigEndian);\n                    ::memcpy(output.pData_+outlen                     ,&newBox            ,sizeof(newBox));\n                    ::memcpy(output.pData_+outlen+sizeof(newBox)      ,pad                ,psize         );\n                } else {\n                    const char* pad   = \"\\x02\\x00\\x00\";\n                    uint32_t    psize = 3;\n                    newlen            = sizeof(newBox) + psize + iccProfile_.size_;\n                    enforce(newlen <= static_cast<size_t>(output.size_ - outlen), Exiv2::kerCorruptedMetadata);\n                    ul2Data((byte*)&newBox.length,newlen,bigEndian);\n                    ul2Data((byte*)&newBox.type,newBox.type,bigEndian);\n                    ::memcpy(output.pData_+outlen                     ,&newBox            ,sizeof(newBox)  );\n                    ::memcpy(output.pData_+outlen+sizeof(newBox)      , pad               ,psize           );\n                    ::memcpy(output.pData_+outlen+sizeof(newBox)+psize,iccProfile_.pData_,iccProfile_.size_);\n                }\n            } else {\n                enforce(newlen <= static_cast<size_t>(output.size_ - outlen), Exiv2::kerCorruptedMetadata);\n                ::memcpy(output.pData_+outlen,boxBuf.pData_+inlen,subBox.length);\n            }\n\n            outlen += newlen;\n            inlen  += subBox.length;\n        }\n\n        // allocate the correct number of bytes, copy the data and update the box header\n        outBuf.alloc(outlen);\n        ::memcpy(outBuf.pData_,output.pData_,outlen);\n        pBox   = (Jp2BoxHeader*) outBuf.pData_;\n        ul2Data((byte*)&pBox->type,kJp2BoxTypeJp2Header,bigEndian);\n        ul2Data((byte*)&pBox->length,outlen,bigEndian);\n    }",
  "abstract_func_before": "void Jp2Image::encodeJp2Header(const DataBuf& VAR_0,DataBuf& VAR_1)\n    {\n        DataBuf VAR_2(VAR_0.size_ + VAR_3.size_ + 100); /* COMMENT_0 */\n        long    VAR_4 = sizeof(VAR_5) ; /* COMMENT_1 */\n        long    VAR_6 = sizeof(VAR_5) ; /* COMMENT_2 */\n        enforce(sizeof(VAR_5) <= VAR_7<size_t>(VAR_2.size_), Exiv2::kerCorruptedMetadata);\n        Jp2BoxHeader* VAR_8   = (Jp2BoxHeader*) VAR_0.pData_;\n        uint32_t      VAR_9 = getLong((byte*)&VAR_8->length, VAR_10);\n        enforce(VAR_9 <= VAR_7<size_t>(VAR_2.size_), Exiv2::kerCorruptedMetadata);\n        uint32_t      VAR_11  = sizeof (Jp2BoxHeader);\n        char*         VAR_12      = (char*) VAR_0.pData_;\n        bool          VAR_13 = false ;\n\n        while ( VAR_11 < VAR_9 || !VAR_13 ) {\n            enforce(sizeof(Jp2BoxHeader) <= VAR_9 - VAR_11, Exiv2::kerCorruptedMetadata);\n            Jp2BoxHeader* VAR_14 = (Jp2BoxHeader*) (VAR_12+VAR_11) ;\n\n            /* COMMENT_3 */\n            Jp2BoxHeader   VAR_15 = *VAR_14 ;\n            Jp2BoxHeader   VAR_16 =  VAR_15;\n\n            if ( VAR_11 < VAR_9 ) {\n                VAR_15.length = getLong((byte*)&VAR_15.length, VAR_10);\n                VAR_15.type   = getLong((byte*)&VAR_15.type  , VAR_10);\n#ifdef VAR_17\n                std::cout << \"Jp2Image::encodeJp2Header subbox: \"<< toAscii(VAR_15.type) << \" length = \" << VAR_15.length << std::endl;\n#endif\n                enforce(VAR_15.length > 0, Exiv2::kerCorruptedMetadata);\n                enforce(VAR_15.length <= VAR_9 - VAR_11, Exiv2::kerCorruptedMetadata);\n                VAR_11        += VAR_15.length;\n                VAR_16.type   = VAR_15.type;\n            } else {\n                VAR_15.length=0;\n                VAR_16.type = VAR_18;\n                VAR_11 = VAR_9;\n            }\n\n            uint32_t VAR_19 = VAR_15.length;\n            if ( VAR_16.type == VAR_18 ) {\n                VAR_13 = true ;\n                if ( ! iccProfileDefined() ) {\n                    const char* VAR_20   = \"\\x01\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x05\\x1cuuid\";\n                    uint32_t    VAR_21 = 15;\n                    VAR_19            = sizeof(VAR_16) + VAR_21 ;\n                    enforce(VAR_19 <= VAR_7<size_t>(VAR_2.size_ - VAR_4), Exiv2::kerCorruptedMetadata);\n                    ul2Data((byte*)&VAR_16.length,VAR_21      ,VAR_10);\n                    ul2Data((byte*)&VAR_16.type  ,VAR_16.type,VAR_10);\n                    ::memcpy(VAR_2.pData_+VAR_4                     ,&VAR_16            ,sizeof(VAR_16));\n                    ::memcpy(VAR_2.pData_+VAR_4+sizeof(VAR_16)      ,VAR_20                ,VAR_21         );\n                } else {\n                    const char* VAR_20   = \"\\x02\\x00\\x00\";\n                    uint32_t    VAR_21 = 3;\n                    VAR_19            = sizeof(VAR_16) + VAR_21 + VAR_3.size_;\n                    enforce(VAR_19 <= VAR_7<size_t>(VAR_2.size_ - VAR_4), Exiv2::kerCorruptedMetadata);\n                    ul2Data((byte*)&VAR_16.length,VAR_19,VAR_10);\n                    ul2Data((byte*)&VAR_16.type,VAR_16.type,VAR_10);\n                    ::memcpy(VAR_2.pData_+VAR_4                     ,&VAR_16            ,sizeof(VAR_16)  );\n                    ::memcpy(VAR_2.pData_+VAR_4+sizeof(VAR_16)      , VAR_20               ,VAR_21           );\n                    ::memcpy(VAR_2.pData_+VAR_4+sizeof(VAR_16)+VAR_21,VAR_3.pData_,VAR_3.size_);\n                }\n            } else {\n                enforce(VAR_19 <= VAR_7<size_t>(VAR_2.size_ - VAR_4), Exiv2::kerCorruptedMetadata);\n                ::memcpy(VAR_2.pData_+VAR_4,VAR_0.pData_+VAR_6,VAR_15.length);\n            }\n\n            VAR_4 += VAR_19;\n            VAR_6  += VAR_15.length;\n        }\n\n        /* COMMENT_4 */\n        VAR_1.alloc(VAR_4);\n        ::memcpy(VAR_1.pData_,VAR_2.pData_,VAR_4);\n        VAR_8   = (Jp2BoxHeader*) VAR_1.pData_;\n        ul2Data((byte*)&VAR_8->type,VAR_22,VAR_10);\n        ul2Data((byte*)&VAR_8->length,VAR_4,VAR_10);\n    }",
  "func_graph_path_before": "Exiv2/exiv2/9be257340193dbe3fb810aa33531c40ae9df6414/jp2image.cpp/vul/before/0.json",
  "func": "void Jp2Image::encodeJp2Header(const DataBuf& boxBuf,DataBuf& outBuf)\n    {\n        DataBuf output(boxBuf.size_ + iccProfile_.size_ + 100); // allocate sufficient space\n        long    outlen = sizeof(Jp2BoxHeader) ; // now many bytes have we written to output?\n        long    inlen = sizeof(Jp2BoxHeader) ; // how many bytes have we read from boxBuf?\n        enforce(sizeof(Jp2BoxHeader) <= static_cast<size_t>(output.size_), Exiv2::kerCorruptedMetadata);\n        Jp2BoxHeader* pBox   = (Jp2BoxHeader*) boxBuf.pData_;\n        uint32_t      length = getLong((byte*)&pBox->length, bigEndian);\n        enforce(length <= static_cast<size_t>(output.size_), Exiv2::kerCorruptedMetadata);\n        uint32_t      count  = sizeof (Jp2BoxHeader);\n        char*         p      = (char*) boxBuf.pData_;\n        bool          bWroteColor = false ;\n\n        while ( count < length && !bWroteColor ) {\n            enforce(sizeof(Jp2BoxHeader) <= length - count, Exiv2::kerCorruptedMetadata);\n            Jp2BoxHeader* pSubBox = (Jp2BoxHeader*) (p+count) ;\n\n            // copy data.  pointer could be into a memory mapped file which we will decode!\n            // pSubBox isn't always an aligned pointer, so use memcpy to do the copy.\n            Jp2BoxHeader   subBox;\n            memcpy(&subBox, pSubBox, sizeof(Jp2BoxHeader));\n            Jp2BoxHeader   newBox =  subBox;\n\n            if ( count < length ) {\n                subBox.length = getLong((byte*)&subBox.length, bigEndian);\n                subBox.type   = getLong((byte*)&subBox.type  , bigEndian);\n#ifdef EXIV2_DEBUG_MESSAGES\n                std::cout << \"Jp2Image::encodeJp2Header subbox: \"<< toAscii(subBox.type) << \" length = \" << subBox.length << std::endl;\n#endif\n                enforce(subBox.length > 0, Exiv2::kerCorruptedMetadata);\n                enforce(subBox.length <= length - count, Exiv2::kerCorruptedMetadata);\n                count        += subBox.length;\n                newBox.type   = subBox.type;\n            } else {\n                subBox.length=0;\n                newBox.type = kJp2BoxTypeColorHeader;\n                count = length;\n            }\n\n            uint32_t newlen = subBox.length;\n            if ( newBox.type == kJp2BoxTypeColorHeader ) {\n                bWroteColor = true ;\n                if ( ! iccProfileDefined() ) {\n                    const char* pad   = \"\\x01\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x05\\x1cuuid\";\n                    uint32_t    psize = 15;\n                    newlen            = sizeof(newBox) + psize ;\n                    enforce(newlen <= static_cast<size_t>(output.size_ - outlen), Exiv2::kerCorruptedMetadata);\n                    ul2Data((byte*)&newBox.length,psize      ,bigEndian);\n                    ul2Data((byte*)&newBox.type  ,newBox.type,bigEndian);\n                    ::memcpy(output.pData_+outlen                     ,&newBox            ,sizeof(newBox));\n                    ::memcpy(output.pData_+outlen+sizeof(newBox)      ,pad                ,psize         );\n                } else {\n                    const char* pad   = \"\\x02\\x00\\x00\";\n                    uint32_t    psize = 3;\n                    newlen            = sizeof(newBox) + psize + iccProfile_.size_;\n                    enforce(newlen <= static_cast<size_t>(output.size_ - outlen), Exiv2::kerCorruptedMetadata);\n                    ul2Data((byte*)&newBox.length,newlen,bigEndian);\n                    ul2Data((byte*)&newBox.type,newBox.type,bigEndian);\n                    ::memcpy(output.pData_+outlen                     ,&newBox            ,sizeof(newBox)  );\n                    ::memcpy(output.pData_+outlen+sizeof(newBox)      , pad               ,psize           );\n                    ::memcpy(output.pData_+outlen+sizeof(newBox)+psize,iccProfile_.pData_,iccProfile_.size_);\n                }\n            } else {\n                enforce(newlen <= static_cast<size_t>(output.size_ - outlen), Exiv2::kerCorruptedMetadata);\n                ::memcpy(output.pData_+outlen,boxBuf.pData_+inlen,subBox.length);\n            }\n\n            outlen += newlen;\n            inlen  += subBox.length;\n        }\n\n        // allocate the correct number of bytes, copy the data and update the box header\n        outBuf.alloc(outlen);\n        ::memcpy(outBuf.pData_,output.pData_,outlen);\n        pBox   = (Jp2BoxHeader*) outBuf.pData_;\n        ul2Data((byte*)&pBox->type,kJp2BoxTypeJp2Header,bigEndian);\n        ul2Data((byte*)&pBox->length,outlen,bigEndian);\n    }",
  "abstract_func": "void Jp2Image::encodeJp2Header(const DataBuf& VAR_0,DataBuf& VAR_1)\n    {\n        DataBuf VAR_2(VAR_0.size_ + VAR_3.size_ + 100); /* COMMENT_0 */\n        long    VAR_4 = sizeof(VAR_5) ; /* COMMENT_1 */\n        long    VAR_6 = sizeof(VAR_5) ; /* COMMENT_2 */\n        enforce(sizeof(VAR_5) <= VAR_7<size_t>(VAR_2.size_), Exiv2::kerCorruptedMetadata);\n        Jp2BoxHeader* VAR_8   = (Jp2BoxHeader*) VAR_0.pData_;\n        uint32_t      VAR_9 = getLong((byte*)&VAR_8->length, VAR_10);\n        enforce(VAR_9 <= VAR_7<size_t>(VAR_2.size_), Exiv2::kerCorruptedMetadata);\n        uint32_t      VAR_11  = sizeof (Jp2BoxHeader);\n        char*         VAR_12      = (char*) VAR_0.pData_;\n        bool          VAR_13 = false ;\n\n        while ( VAR_11 < VAR_9 && !VAR_13 ) {\n            enforce(sizeof(Jp2BoxHeader) <= VAR_9 - VAR_11, Exiv2::kerCorruptedMetadata);\n            Jp2BoxHeader* VAR_14 = (Jp2BoxHeader*) (VAR_12+VAR_11) ;\n\n            /* COMMENT_3 */\n            /* COMMENT_4 */\n            Jp2BoxHeader   VAR_15;\n            memcpy(&VAR_15, VAR_14, sizeof(Jp2BoxHeader));\n            Jp2BoxHeader   VAR_16 =  VAR_15;\n\n            if ( VAR_11 < VAR_9 ) {\n                VAR_15.length = getLong((byte*)&VAR_15.length, VAR_10);\n                VAR_15.type   = getLong((byte*)&VAR_15.type  , VAR_10);\n#ifdef VAR_17\n                std::cout << \"Jp2Image::encodeJp2Header subbox: \"<< toAscii(VAR_15.type) << \" length = \" << VAR_15.length << std::endl;\n#endif\n                enforce(VAR_15.length > 0, Exiv2::kerCorruptedMetadata);\n                enforce(VAR_15.length <= VAR_9 - VAR_11, Exiv2::kerCorruptedMetadata);\n                VAR_11        += VAR_15.length;\n                VAR_16.type   = VAR_15.type;\n            } else {\n                VAR_15.length=0;\n                VAR_16.type = VAR_18;\n                VAR_11 = VAR_9;\n            }\n\n            uint32_t VAR_19 = VAR_15.length;\n            if ( VAR_16.type == VAR_18 ) {\n                VAR_13 = true ;\n                if ( ! iccProfileDefined() ) {\n                    const char* VAR_20   = \"\\x01\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x05\\x1cuuid\";\n                    uint32_t    VAR_21 = 15;\n                    VAR_19            = sizeof(VAR_16) + VAR_21 ;\n                    enforce(VAR_19 <= VAR_7<size_t>(VAR_2.size_ - VAR_4), Exiv2::kerCorruptedMetadata);\n                    ul2Data((byte*)&VAR_16.length,VAR_21      ,VAR_10);\n                    ul2Data((byte*)&VAR_16.type  ,VAR_16.type,VAR_10);\n                    ::memcpy(VAR_2.pData_+VAR_4                     ,&VAR_16            ,sizeof(VAR_16));\n                    ::memcpy(VAR_2.pData_+VAR_4+sizeof(VAR_16)      ,VAR_20                ,VAR_21         );\n                } else {\n                    const char* VAR_20   = \"\\x02\\x00\\x00\";\n                    uint32_t    VAR_21 = 3;\n                    VAR_19            = sizeof(VAR_16) + VAR_21 + VAR_3.size_;\n                    enforce(VAR_19 <= VAR_7<size_t>(VAR_2.size_ - VAR_4), Exiv2::kerCorruptedMetadata);\n                    ul2Data((byte*)&VAR_16.length,VAR_19,VAR_10);\n                    ul2Data((byte*)&VAR_16.type,VAR_16.type,VAR_10);\n                    ::memcpy(VAR_2.pData_+VAR_4                     ,&VAR_16            ,sizeof(VAR_16)  );\n                    ::memcpy(VAR_2.pData_+VAR_4+sizeof(VAR_16)      , VAR_20               ,VAR_21           );\n                    ::memcpy(VAR_2.pData_+VAR_4+sizeof(VAR_16)+VAR_21,VAR_3.pData_,VAR_3.size_);\n                }\n            } else {\n                enforce(VAR_19 <= VAR_7<size_t>(VAR_2.size_ - VAR_4), Exiv2::kerCorruptedMetadata);\n                ::memcpy(VAR_2.pData_+VAR_4,VAR_0.pData_+VAR_6,VAR_15.length);\n            }\n\n            VAR_4 += VAR_19;\n            VAR_6  += VAR_15.length;\n        }\n\n        /* COMMENT_5 */\n        VAR_1.alloc(VAR_4);\n        ::memcpy(VAR_1.pData_,VAR_2.pData_,VAR_4);\n        VAR_8   = (Jp2BoxHeader*) VAR_1.pData_;\n        ul2Data((byte*)&VAR_8->type,VAR_22,VAR_10);\n        ul2Data((byte*)&VAR_8->length,VAR_4,VAR_10);\n    }",
  "func_graph_path": "Exiv2/exiv2/9be257340193dbe3fb810aa33531c40ae9df6414/jp2image.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -11,12 +11,14 @@\n         char*         p      = (char*) boxBuf.pData_;\n         bool          bWroteColor = false ;\n \n-        while ( count < length || !bWroteColor ) {\n+        while ( count < length && !bWroteColor ) {\n             enforce(sizeof(Jp2BoxHeader) <= length - count, Exiv2::kerCorruptedMetadata);\n             Jp2BoxHeader* pSubBox = (Jp2BoxHeader*) (p+count) ;\n \n             // copy data.  pointer could be into a memory mapped file which we will decode!\n-            Jp2BoxHeader   subBox = *pSubBox ;\n+            // pSubBox isn't always an aligned pointer, so use memcpy to do the copy.\n+            Jp2BoxHeader   subBox;\n+            memcpy(&subBox, pSubBox, sizeof(Jp2BoxHeader));\n             Jp2BoxHeader   newBox =  subBox;\n \n             if ( count < length ) {",
  "diff_line_info": {
    "deleted_lines": [
      "        while ( count < length || !bWroteColor ) {",
      "            Jp2BoxHeader   subBox = *pSubBox ;"
    ],
    "added_lines": [
      "        while ( count < length && !bWroteColor ) {",
      "            // pSubBox isn't always an aligned pointer, so use memcpy to do the copy.",
      "            Jp2BoxHeader   subBox;",
      "            memcpy(&subBox, pSubBox, sizeof(Jp2BoxHeader));"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/Exiv2/exiv2/pull/1752",
  "description": {
    "pr_info": {
      "title": "Fix incorrect loop condition",
      "number": 1752
    },
    "comment": [
      "Fixes https://github.com/Exiv2/exiv2/security/advisories/GHSA-mxw9-qx4c-6m8v\r\n\r\nThe problem here is caused by `bWroteColor`. It is `false` by default, but if it becomes `true` then it can never revert back to `false`. When it becomes `true`, the loop becomes infinite: it can only terminate by throwing an exception or by crashing. I am not completely sure what the intended logic was here, but my best guess is that the loop condition should use `&&` rather than `||`.\r\n\r\nI also fixed an unaligned pointer dereference that was causing an ASAN error."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "**Final Classification:** Security Vulnerability Fix; **Confidence:** 1.0"
}