{
  "cve_id": "CVE-2020-36309",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "openresty/lua-nginx-module",
  "commit_msg": "bugfix: ensured arguments of APIs mutating uri or request/response headers do not contain unsafe characters.\n\nSigned-off-by: Thibault Charbonnier <thibaultcha@me.com>",
  "commit_hash": "041d7d1c8539f92062c2a79cf18f550542bccc2e",
  "git_url": "https://github.com/openresty/lua-nginx-module/commit/041d7d1c8539f92062c2a79cf18f550542bccc2e",
  "file_path": "src/ngx_http_lua_headers_in.c",
  "func_name": "ngx_http_lua_set_input_header",
  "func_before": "ngx_int_t\nngx_http_lua_set_input_header(ngx_http_request_t *r, ngx_str_t key,\n    ngx_str_t value, unsigned override)\n{\n    ngx_http_lua_header_val_t         hv;\n    ngx_http_lua_set_header_t        *handlers = ngx_http_lua_set_handlers;\n\n    ngx_uint_t                        i;\n\n    dd(\"set header value: %.*s\", (int) value.len, value.data);\n\n    hv.hash = ngx_hash_key_lc(key.data, key.len);\n    hv.key = key;\n\n    hv.offset = 0;\n    hv.no_override = !override;\n    hv.handler = NULL;\n\n    for (i = 0; handlers[i].name.len; i++) {\n        if (hv.key.len != handlers[i].name.len\n            || ngx_strncasecmp(hv.key.data, handlers[i].name.data,\n                               handlers[i].name.len) != 0)\n        {\n            dd(\"hv key comparison: %s <> %s\", handlers[i].name.data,\n               hv.key.data);\n\n            continue;\n        }\n\n        dd(\"Matched handler: %s %s\", handlers[i].name.data, hv.key.data);\n\n        hv.offset = handlers[i].offset;\n        hv.handler = handlers[i].handler;\n\n        break;\n    }\n\n    if (handlers[i].name.len == 0 && handlers[i].handler) {\n        hv.offset = handlers[i].offset;\n        hv.handler = handlers[i].handler;\n    }\n\n#if 1\n    if (hv.handler == NULL) {\n        return NGX_ERROR;\n    }\n#endif\n\n    if (r->headers_out.status == 400 || r->headers_in.headers.last == NULL) {\n        /* must be a 400 Bad Request */\n        return NGX_OK;\n    }\n\n    return hv.handler(r, &hv, &value);\n}",
  "abstract_func_before": "ngx_int_t\nngx_http_lua_set_input_header(ngx_http_request_t *VAR_0, ngx_str_t VAR_1,\n    ngx_str_t VAR_2, unsigned VAR_3)\n{\n    ngx_http_lua_header_val_t         VAR_4;\n    ngx_http_lua_set_header_t        *VAR_5 = VAR_6;\n\n    ngx_uint_t                        VAR_7;\n\n    dd(\"set header value: %.*s\", (int) VAR_2.len, VAR_2.data);\n\n    VAR_4.hash = ngx_hash_key_lc(VAR_1.data, VAR_1.len);\n    VAR_4.key = VAR_1;\n\n    VAR_4.offset = 0;\n    VAR_4.no_override = !VAR_3;\n    VAR_4.handler = NULL;\n\n    for (VAR_7 = 0; VAR_5[VAR_7].name.len; VAR_7++) {\n        if (VAR_4.key.len != VAR_5[VAR_7].name.len\n            || ngx_strncasecmp(VAR_4.key.data, VAR_5[VAR_7].name.data,\n                               VAR_5[VAR_7].name.len) != 0)\n        {\n            dd(\"hv key comparison: %s <> %s\", VAR_5[VAR_7].name.data,\n               VAR_4.key.data);\n\n            continue;\n        }\n\n        dd(\"Matched handler: %s %s\", VAR_5[VAR_7].name.data, VAR_4.key.data);\n\n        VAR_4.offset = VAR_5[VAR_7].offset;\n        VAR_4.handler = VAR_5[VAR_7].handler;\n\n        break;\n    }\n\n    if (VAR_5[VAR_7].name.len == 0 && VAR_5[VAR_7].handler) {\n        VAR_4.offset = VAR_5[VAR_7].offset;\n        VAR_4.handler = VAR_5[VAR_7].handler;\n    }\n\n#if 1\n    if (VAR_4.handler == NULL) {\n        return VAR_8;\n    }\n#endif\n\n    if (VAR_0->headers_out.status == 400 || VAR_0->headers_in.headers.last == NULL) {\n        /* COMMENT_0 */\n        return VAR_9;\n    }\n\n    return VAR_4.handler(VAR_0, &VAR_4, &VAR_2);\n}",
  "func_graph_path_before": "openresty/lua-nginx-module/041d7d1c8539f92062c2a79cf18f550542bccc2e/ngx_http_lua_headers_in.c/vul/before/0.json",
  "func": "ngx_int_t\nngx_http_lua_set_input_header(ngx_http_request_t *r, ngx_str_t key,\n    ngx_str_t value, unsigned override)\n{\n    ngx_http_lua_header_val_t         hv;\n    ngx_http_lua_set_header_t        *handlers = ngx_http_lua_set_handlers;\n\n    ngx_uint_t                        i;\n\n    dd(\"set header value: %.*s\", (int) value.len, value.data);\n\n    if (ngx_http_lua_check_header_safe(r, key.data, key.len) != NGX_OK\n        || ngx_http_lua_check_header_safe(r, value.data, value.len) != NGX_OK)\n    {\n        return NGX_ERROR;\n    }\n\n    hv.hash = ngx_hash_key_lc(key.data, key.len);\n    hv.key = key;\n\n    hv.offset = 0;\n    hv.no_override = !override;\n    hv.handler = NULL;\n\n    for (i = 0; handlers[i].name.len; i++) {\n        if (hv.key.len != handlers[i].name.len\n            || ngx_strncasecmp(hv.key.data, handlers[i].name.data,\n                               handlers[i].name.len) != 0)\n        {\n            dd(\"hv key comparison: %s <> %s\", handlers[i].name.data,\n               hv.key.data);\n\n            continue;\n        }\n\n        dd(\"Matched handler: %s %s\", handlers[i].name.data, hv.key.data);\n\n        hv.offset = handlers[i].offset;\n        hv.handler = handlers[i].handler;\n\n        break;\n    }\n\n    if (handlers[i].name.len == 0 && handlers[i].handler) {\n        hv.offset = handlers[i].offset;\n        hv.handler = handlers[i].handler;\n    }\n\n#if 1\n    if (hv.handler == NULL) {\n        return NGX_ERROR;\n    }\n#endif\n\n    if (r->headers_out.status == 400 || r->headers_in.headers.last == NULL) {\n        /* must be a 400 Bad Request */\n        return NGX_OK;\n    }\n\n    return hv.handler(r, &hv, &value);\n}",
  "abstract_func": "ngx_int_t\nngx_http_lua_set_input_header(ngx_http_request_t *VAR_0, ngx_str_t VAR_1,\n    ngx_str_t VAR_2, unsigned VAR_3)\n{\n    ngx_http_lua_header_val_t         VAR_4;\n    ngx_http_lua_set_header_t        *VAR_5 = VAR_6;\n\n    ngx_uint_t                        VAR_7;\n\n    dd(\"set header value: %.*s\", (int) VAR_2.len, VAR_2.data);\n\n    if (ngx_http_lua_check_header_safe(VAR_0, VAR_1.data, VAR_1.len) != VAR_8\n        || ngx_http_lua_check_header_safe(VAR_0, VAR_2.data, VAR_2.len) != VAR_8)\n    {\n        return VAR_9;\n    }\n\n    VAR_4.hash = ngx_hash_key_lc(VAR_1.data, VAR_1.len);\n    VAR_4.key = VAR_1;\n\n    VAR_4.offset = 0;\n    VAR_4.no_override = !VAR_3;\n    VAR_4.handler = NULL;\n\n    for (VAR_7 = 0; VAR_5[VAR_7].name.len; VAR_7++) {\n        if (VAR_4.key.len != VAR_5[VAR_7].name.len\n            || ngx_strncasecmp(VAR_4.key.data, VAR_5[VAR_7].name.data,\n                               VAR_5[VAR_7].name.len) != 0)\n        {\n            dd(\"hv key comparison: %s <> %s\", VAR_5[VAR_7].name.data,\n               VAR_4.key.data);\n\n            continue;\n        }\n\n        dd(\"Matched handler: %s %s\", VAR_5[VAR_7].name.data, VAR_4.key.data);\n\n        VAR_4.offset = VAR_5[VAR_7].offset;\n        VAR_4.handler = VAR_5[VAR_7].handler;\n\n        break;\n    }\n\n    if (VAR_5[VAR_7].name.len == 0 && VAR_5[VAR_7].handler) {\n        VAR_4.offset = VAR_5[VAR_7].offset;\n        VAR_4.handler = VAR_5[VAR_7].handler;\n    }\n\n#if 1\n    if (VAR_4.handler == NULL) {\n        return VAR_9;\n    }\n#endif\n\n    if (VAR_0->headers_out.status == 400 || VAR_0->headers_in.headers.last == NULL) {\n        /* COMMENT_0 */\n        return VAR_8;\n    }\n\n    return VAR_4.handler(VAR_0, &VAR_4, &VAR_2);\n}",
  "func_graph_path": "openresty/lua-nginx-module/041d7d1c8539f92062c2a79cf18f550542bccc2e/ngx_http_lua_headers_in.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -8,6 +8,12 @@\n     ngx_uint_t                        i;\n \n     dd(\"set header value: %.*s\", (int) value.len, value.data);\n+\n+    if (ngx_http_lua_check_header_safe(r, key.data, key.len) != NGX_OK\n+        || ngx_http_lua_check_header_safe(r, value.data, value.len) != NGX_OK)\n+    {\n+        return NGX_ERROR;\n+    }\n \n     hv.hash = ngx_hash_key_lc(key.data, key.len);\n     hv.key = key;",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "",
      "    if (ngx_http_lua_check_header_safe(r, key.data, key.len) != NGX_OK",
      "        || ngx_http_lua_check_header_safe(r, value.data, value.len) != NGX_OK)",
      "    {",
      "        return NGX_ERROR;",
      "    }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/openresty/lua-nginx-module/pull/1654",
  "description": {
    "pr_info": {
      "title": "bugfix: ensured arguments of APIs mutating uri or request/response headers do not contain unsafe characters.",
      "number": 1654
    },
    "comment": [
      "I hereby granted the copyright of the changes in this pull request\nto the authors of this lua-nginx-module project.",
      "(Rebased on top of master due to a newly failing tests caused by changes in openresty.org's accepted ciphers)",
      "Just pushed an additional commit with more fixes."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "The patch addresses a potential security vulnerability by adding checks to prevent unsafe characters in HTTP headers. The confidence is high due to the clear alignment between the commit message and the code changes.\n\n**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95"
}