{
  "cve_id": "CVE-2022-32073",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "wolfSSL/wolfssh",
  "commit_msg": "ASAN SFTP Fixes\nWhen decoding SFTP messages, fix the size checks so they don't wrap. (ZD12766)",
  "commit_hash": "edb272e35ee57e7b89f3e127222c6981b6a1e730",
  "git_url": "https://github.com/wolfSSL/wolfssh/commit/edb272e35ee57e7b89f3e127222c6981b6a1e730",
  "file_path": "src/wolfsftp.c",
  "func_name": "wolfSSH_SFTP_RecvOpen",
  "func_before": "int wolfSSH_SFTP_RecvOpen(WOLFSSH* ssh, int reqId, byte* data, word32 maxSz)\n#ifndef USE_WINDOWS_API\n{\n    WS_SFTP_FILEATRB atr;\n    WFD    fd;\n    word32 sz;\n    char*  dir;\n    word32 reason;\n    word32 idx = 0;\n    int m = 0;\n    int ret = WS_SUCCESS;\n\n    word32 outSz = sizeof(WFD) + UINT32_SZ + WOLFSSH_SFTP_HEADER;\n    byte*  out = NULL;\n\n    char* res   = NULL;\n    char  ier[] = \"Internal Failure\";\n    char  oer[] = \"Open File Error\";\n\n    if (ssh == NULL) {\n        return WS_BAD_ARGUMENT;\n    }\n\n    WLOG(WS_LOG_SFTP, \"Receiving WOLFSSH_FTP_OPEN\");\n\n    if (sizeof(WFD) > WOLFSSH_MAX_HANDLE) {\n        WLOG(WS_LOG_SFTP, \"Handle size is too large\");\n        return WS_FATAL_ERROR;\n    }\n\n    ato32(data + idx, &sz); idx += UINT32_SZ;\n    if (sz + idx > maxSz) {\n        return WS_BUFFER_E;\n    }\n\n    /* plus one to make sure is null terminated */\n    dir = (char*)WMALLOC(sz + 1, ssh->ctx->heap, DYNTYPE_BUFFER);\n    if (dir == NULL) {\n        return WS_MEMORY_E;\n    }\n    WMEMCPY(dir, data + idx, sz);\n    dir[sz] = '\\0';\n    idx += sz;\n\n    /* get reason for opening file */\n    ato32(data + idx, &reason); idx += UINT32_SZ;\n\n    /* @TODO handle attributes */\n    SFTP_ParseAtributes_buffer(ssh, &atr, data, &idx, maxSz);\n    if ((reason & WOLFSSH_FXF_READ) && (reason & WOLFSSH_FXF_WRITE)) {\n        m |= WOLFSSH_O_RDWR;\n    }\n    else {\n        if (reason & WOLFSSH_FXF_READ) {\n            m |= WOLFSSH_O_RDONLY;\n        }\n        if (reason & WOLFSSH_FXF_WRITE) {\n            m |= WOLFSSH_O_WRONLY;\n        }\n    }\n\n    if (reason & WOLFSSH_FXF_APPEND) {\n        m |= WOLFSSH_O_APPEND;\n    }\n    if (reason & WOLFSSH_FXF_CREAT) {\n        m |= WOLFSSH_O_CREAT;\n    }\n    if (reason & WOLFSSH_FXF_TRUNC) {\n        m |= WOLFSSH_O_TRUNC;\n    }\n    if (reason & WOLFSSH_FXF_EXCL) {\n        m |= WOLFSSH_O_EXCL;\n    }\n\n    /* if file permissions not set then use default */\n    if (!(atr.flags & WOLFSSH_FILEATRB_PERM)) {\n        atr.per = 0644;\n    }\n\n    if (wolfSSH_CleanPath(ssh, dir) < 0) {\n        WFREE(dir, ssh->ctx->heap, DYNTYPE_BUFFER);\n        return WS_FATAL_ERROR;\n    }\n    fd = WOPEN(dir, m, atr.per);\n    if (fd < 0) {\n        WLOG(WS_LOG_SFTP, \"Error opening file %s\", dir);\n        res = oer;\n        if (wolfSSH_SFTP_CreateStatus(ssh, WOLFSSH_FTP_FAILURE, reqId, res,\n                \"English\", NULL, &outSz) != WS_SIZE_ONLY) {\n            WFREE(dir, ssh->ctx->heap, DYNTYPE_BUFFER);\n            return WS_FATAL_ERROR;\n        }\n        ret = WS_BAD_FILE_E;\n    }\n\n#ifdef WOLFSSH_STOREHANDLE\n    if (ret == WS_SUCCESS) {\n        if ((ret = SFTP_AddHandleNode(ssh, (byte*)&fd, sizeof(WFD), dir)) != WS_SUCCESS) {\n            WLOG(WS_LOG_SFTP, \"Unable to store handle\");\n            res = ier;\n            if (wolfSSH_SFTP_CreateStatus(ssh, WOLFSSH_FTP_FAILURE, reqId, res,\n                \"English\", NULL, &outSz) != WS_SIZE_ONLY) {\n                WFREE(dir, ssh->ctx->heap, DYNTYPE_BUFFER);\n                return WS_FATAL_ERROR;\n            }\n            ret = WS_FATAL_ERROR;\n        }\n    }\n#endif\n    WFREE(dir, ssh->ctx->heap, DYNTYPE_BUFFER);\n\n    /* create packet */\n    out = (byte*)WMALLOC(outSz, ssh->ctx->heap, DYNTYPE_BUFFER);\n    if (out == NULL) {\n        return WS_MEMORY_E;\n    }\n    if (ret == WS_SUCCESS) {\n        if (SFTP_CreatePacket(ssh, WOLFSSH_FTP_HANDLE, out, outSz,\n            (byte*)&fd, sizeof(WFD)) != WS_SUCCESS) {\n            return WS_FATAL_ERROR;\n        }\n    }\n    else {\n        if (wolfSSH_SFTP_CreateStatus(ssh, WOLFSSH_FTP_FAILURE, reqId, res,\n                \"English\", out, &outSz) != WS_SUCCESS) {\n            WFREE(out, ssh->ctx->heap, DYNTYPE_BUFFER);\n            return WS_FATAL_ERROR;\n        }\n    }\n\n    /* set send out buffer, \"out\" is taken by ssh  */\n    wolfSSH_SFTP_RecvSetSend(ssh, out, outSz);\n\n    (void)ier;\n    return ret;\n}",
  "abstract_func_before": "int wolfSSH_SFTP_RecvOpen(WOLFSSH* VAR_0, int VAR_1, byte* VAR_2, word32 VAR_3)\n#ifndef VAR_4\n{\n    WS_SFTP_FILEATRB VAR_5;\n    WFD    VAR_6;\n    word32 VAR_7;\n    char*  VAR_8;\n    word32 VAR_9;\n    word32 VAR_10 = 0;\n    int VAR_11 = 0;\n    int VAR_12 = VAR_13;\n\n    word32 VAR_14 = sizeof(WFD) + VAR_15 + VAR_16;\n    byte*  VAR_17 = NULL;\n\n    char* VAR_18   = NULL;\n    char  VAR_19[] = \"Internal Failure\";\n    char  VAR_20[] = \"Open File Error\";\n\n    if (VAR_0 == NULL) {\n        return VAR_21;\n    }\n\n    WLOG(VAR_22, \"Receiving WOLFSSH_FTP_OPEN\");\n\n    if (sizeof(WFD) > VAR_23) {\n        WLOG(VAR_22, \"Handle size is too large\");\n        return VAR_24;\n    }\n\n    ato32(VAR_2 + VAR_10, &VAR_7); VAR_10 += VAR_15;\n    if (VAR_7 + VAR_10 > VAR_3) {\n        return VAR_25;\n    }\n\n    /* COMMENT_0 */\n    VAR_8 = (char*)WMALLOC(VAR_7 + 1, VAR_0->ctx->heap, VAR_26);\n    if (VAR_8 == NULL) {\n        return VAR_27;\n    }\n    WMEMCPY(VAR_8, VAR_2 + VAR_10, VAR_7);\n    VAR_8[VAR_7] = '\\0';\n    VAR_10 += VAR_7;\n\n    /* COMMENT_1 */\n    ato32(VAR_2 + VAR_10, &VAR_9); VAR_10 += VAR_15;\n\n    /* COMMENT_2 */\n    SFTP_ParseAtributes_buffer(VAR_0, &VAR_5, VAR_2, &VAR_10, VAR_3);\n    if ((VAR_9 & VAR_28) && (VAR_9 & VAR_29)) {\n        VAR_11 |= VAR_30;\n    }\n    else {\n        if (VAR_9 & VAR_28) {\n            VAR_11 |= VAR_31;\n        }\n        if (VAR_9 & VAR_29) {\n            VAR_11 |= VAR_32;\n        }\n    }\n\n    if (VAR_9 & VAR_33) {\n        VAR_11 |= VAR_34;\n    }\n    if (VAR_9 & VAR_35) {\n        VAR_11 |= VAR_36;\n    }\n    if (VAR_9 & VAR_37) {\n        VAR_11 |= VAR_38;\n    }\n    if (VAR_9 & VAR_39) {\n        VAR_11 |= VAR_40;\n    }\n\n    /* COMMENT_3 */\n    if (!(VAR_5.flags & VAR_41)) {\n        VAR_5.per = 0644;\n    }\n\n    if (wolfSSH_CleanPath(VAR_0, VAR_8) < 0) {\n        WFREE(VAR_8, VAR_0->ctx->heap, VAR_26);\n        return VAR_24;\n    }\n    VAR_6 = WOPEN(VAR_8, VAR_11, VAR_5.per);\n    if (VAR_6 < 0) {\n        WLOG(VAR_22, \"Error opening file %s\", VAR_8);\n        VAR_18 = VAR_20;\n        if (wolfSSH_SFTP_CreateStatus(VAR_0, VAR_42, VAR_1, VAR_18,\n                \"English\", NULL, &VAR_14) != VAR_43) {\n            WFREE(VAR_8, VAR_0->ctx->heap, VAR_26);\n            return VAR_24;\n        }\n        VAR_12 = VAR_44;\n    }\n\n#ifdef VAR_45\n    if (VAR_12 == VAR_13) {\n        if ((VAR_12 = SFTP_AddHandleNode(VAR_0, (byte*)&VAR_6, sizeof(WFD), VAR_8)) != VAR_13) {\n            WLOG(VAR_22, \"Unable to store handle\");\n            VAR_18 = VAR_19;\n            if (wolfSSH_SFTP_CreateStatus(VAR_0, VAR_42, VAR_1, VAR_18,\n                \"English\", NULL, &VAR_14) != VAR_43) {\n                WFREE(VAR_8, VAR_0->ctx->heap, VAR_26);\n                return VAR_24;\n            }\n            VAR_12 = VAR_24;\n        }\n    }\n#endif\n    WFREE(VAR_8, VAR_0->ctx->heap, VAR_26);\n\n    /* COMMENT_4 */\n    VAR_17 = (byte*)WMALLOC(VAR_14, VAR_0->ctx->heap, VAR_26);\n    if (VAR_17 == NULL) {\n        return VAR_27;\n    }\n    if (VAR_12 == VAR_13) {\n        if (SFTP_CreatePacket(VAR_0, VAR_46, VAR_17, VAR_14,\n            (byte*)&VAR_6, sizeof(WFD)) != VAR_13) {\n            return VAR_24;\n        }\n    }\n    else {\n        if (wolfSSH_SFTP_CreateStatus(VAR_0, VAR_42, VAR_1, VAR_18,\n                \"English\", VAR_17, &VAR_14) != VAR_13) {\n            WFREE(VAR_17, VAR_0->ctx->heap, VAR_26);\n            return VAR_24;\n        }\n    }\n\n    /* COMMENT_5 */\n    wolfSSH_SFTP_RecvSetSend(VAR_0, VAR_17, VAR_14);\n\n    (void)VAR_19;\n    return VAR_12;\n}",
  "func_graph_path_before": "wolfSSL/wolfssh/edb272e35ee57e7b89f3e127222c6981b6a1e730/wolfsftp.c/vul/before/6.json",
  "func": "int wolfSSH_SFTP_RecvOpen(WOLFSSH* ssh, int reqId, byte* data, word32 maxSz)\n#ifndef USE_WINDOWS_API\n{\n    WS_SFTP_FILEATRB atr;\n    WFD    fd;\n    word32 sz;\n    char*  dir;\n    word32 reason;\n    word32 idx = 0;\n    int m = 0;\n    int ret = WS_SUCCESS;\n\n    word32 outSz = sizeof(WFD) + UINT32_SZ + WOLFSSH_SFTP_HEADER;\n    byte*  out = NULL;\n\n    char* res   = NULL;\n    char  ier[] = \"Internal Failure\";\n    char  oer[] = \"Open File Error\";\n\n    if (ssh == NULL) {\n        return WS_BAD_ARGUMENT;\n    }\n\n    WLOG(WS_LOG_SFTP, \"Receiving WOLFSSH_FTP_OPEN\");\n\n    if (sizeof(WFD) > WOLFSSH_MAX_HANDLE) {\n        WLOG(WS_LOG_SFTP, \"Handle size is too large\");\n        return WS_FATAL_ERROR;\n    }\n\n    ato32(data + idx, &sz); idx += UINT32_SZ;\n    if (sz > maxSz - idx) {\n        return WS_BUFFER_E;\n    }\n\n    /* plus one to make sure is null terminated */\n    dir = (char*)WMALLOC(sz + 1, ssh->ctx->heap, DYNTYPE_BUFFER);\n    if (dir == NULL) {\n        return WS_MEMORY_E;\n    }\n    WMEMCPY(dir, data + idx, sz);\n    dir[sz] = '\\0';\n    idx += sz;\n\n    /* get reason for opening file */\n    ato32(data + idx, &reason); idx += UINT32_SZ;\n\n    /* @TODO handle attributes */\n    SFTP_ParseAtributes_buffer(ssh, &atr, data, &idx, maxSz);\n    if ((reason & WOLFSSH_FXF_READ) && (reason & WOLFSSH_FXF_WRITE)) {\n        m |= WOLFSSH_O_RDWR;\n    }\n    else {\n        if (reason & WOLFSSH_FXF_READ) {\n            m |= WOLFSSH_O_RDONLY;\n        }\n        if (reason & WOLFSSH_FXF_WRITE) {\n            m |= WOLFSSH_O_WRONLY;\n        }\n    }\n\n    if (reason & WOLFSSH_FXF_APPEND) {\n        m |= WOLFSSH_O_APPEND;\n    }\n    if (reason & WOLFSSH_FXF_CREAT) {\n        m |= WOLFSSH_O_CREAT;\n    }\n    if (reason & WOLFSSH_FXF_TRUNC) {\n        m |= WOLFSSH_O_TRUNC;\n    }\n    if (reason & WOLFSSH_FXF_EXCL) {\n        m |= WOLFSSH_O_EXCL;\n    }\n\n    /* if file permissions not set then use default */\n    if (!(atr.flags & WOLFSSH_FILEATRB_PERM)) {\n        atr.per = 0644;\n    }\n\n    if (wolfSSH_CleanPath(ssh, dir) < 0) {\n        WFREE(dir, ssh->ctx->heap, DYNTYPE_BUFFER);\n        return WS_FATAL_ERROR;\n    }\n    fd = WOPEN(dir, m, atr.per);\n    if (fd < 0) {\n        WLOG(WS_LOG_SFTP, \"Error opening file %s\", dir);\n        res = oer;\n        if (wolfSSH_SFTP_CreateStatus(ssh, WOLFSSH_FTP_FAILURE, reqId, res,\n                \"English\", NULL, &outSz) != WS_SIZE_ONLY) {\n            WFREE(dir, ssh->ctx->heap, DYNTYPE_BUFFER);\n            return WS_FATAL_ERROR;\n        }\n        ret = WS_BAD_FILE_E;\n    }\n\n#ifdef WOLFSSH_STOREHANDLE\n    if (ret == WS_SUCCESS) {\n        if ((ret = SFTP_AddHandleNode(ssh, (byte*)&fd, sizeof(WFD), dir)) != WS_SUCCESS) {\n            WLOG(WS_LOG_SFTP, \"Unable to store handle\");\n            res = ier;\n            if (wolfSSH_SFTP_CreateStatus(ssh, WOLFSSH_FTP_FAILURE, reqId, res,\n                \"English\", NULL, &outSz) != WS_SIZE_ONLY) {\n                WFREE(dir, ssh->ctx->heap, DYNTYPE_BUFFER);\n                return WS_FATAL_ERROR;\n            }\n            ret = WS_FATAL_ERROR;\n        }\n    }\n#endif\n    WFREE(dir, ssh->ctx->heap, DYNTYPE_BUFFER);\n\n    /* create packet */\n    out = (byte*)WMALLOC(outSz, ssh->ctx->heap, DYNTYPE_BUFFER);\n    if (out == NULL) {\n        return WS_MEMORY_E;\n    }\n    if (ret == WS_SUCCESS) {\n        if (SFTP_CreatePacket(ssh, WOLFSSH_FTP_HANDLE, out, outSz,\n            (byte*)&fd, sizeof(WFD)) != WS_SUCCESS) {\n            return WS_FATAL_ERROR;\n        }\n    }\n    else {\n        if (wolfSSH_SFTP_CreateStatus(ssh, WOLFSSH_FTP_FAILURE, reqId, res,\n                \"English\", out, &outSz) != WS_SUCCESS) {\n            WFREE(out, ssh->ctx->heap, DYNTYPE_BUFFER);\n            return WS_FATAL_ERROR;\n        }\n    }\n\n    /* set send out buffer, \"out\" is taken by ssh  */\n    wolfSSH_SFTP_RecvSetSend(ssh, out, outSz);\n\n    (void)ier;\n    return ret;\n}",
  "abstract_func": "int wolfSSH_SFTP_RecvOpen(WOLFSSH* VAR_0, int VAR_1, byte* VAR_2, word32 VAR_3)\n#ifndef VAR_4\n{\n    WS_SFTP_FILEATRB VAR_5;\n    WFD    VAR_6;\n    word32 VAR_7;\n    char*  VAR_8;\n    word32 VAR_9;\n    word32 VAR_10 = 0;\n    int VAR_11 = 0;\n    int VAR_12 = VAR_13;\n\n    word32 VAR_14 = sizeof(WFD) + VAR_15 + VAR_16;\n    byte*  VAR_17 = NULL;\n\n    char* VAR_18   = NULL;\n    char  VAR_19[] = \"Internal Failure\";\n    char  VAR_20[] = \"Open File Error\";\n\n    if (VAR_0 == NULL) {\n        return VAR_21;\n    }\n\n    WLOG(VAR_22, \"Receiving WOLFSSH_FTP_OPEN\");\n\n    if (sizeof(WFD) > VAR_23) {\n        WLOG(VAR_22, \"Handle size is too large\");\n        return VAR_24;\n    }\n\n    ato32(VAR_2 + VAR_10, &VAR_7); VAR_10 += VAR_15;\n    if (VAR_7 > VAR_3 - VAR_10) {\n        return VAR_25;\n    }\n\n    /* COMMENT_0 */\n    VAR_8 = (char*)WMALLOC(VAR_7 + 1, VAR_0->ctx->heap, VAR_26);\n    if (VAR_8 == NULL) {\n        return VAR_27;\n    }\n    WMEMCPY(VAR_8, VAR_2 + VAR_10, VAR_7);\n    VAR_8[VAR_7] = '\\0';\n    VAR_10 += VAR_7;\n\n    /* COMMENT_1 */\n    ato32(VAR_2 + VAR_10, &VAR_9); VAR_10 += VAR_15;\n\n    /* COMMENT_2 */\n    SFTP_ParseAtributes_buffer(VAR_0, &VAR_5, VAR_2, &VAR_10, VAR_3);\n    if ((VAR_9 & VAR_28) && (VAR_9 & VAR_29)) {\n        VAR_11 |= VAR_30;\n    }\n    else {\n        if (VAR_9 & VAR_28) {\n            VAR_11 |= VAR_31;\n        }\n        if (VAR_9 & VAR_29) {\n            VAR_11 |= VAR_32;\n        }\n    }\n\n    if (VAR_9 & VAR_33) {\n        VAR_11 |= VAR_34;\n    }\n    if (VAR_9 & VAR_35) {\n        VAR_11 |= VAR_36;\n    }\n    if (VAR_9 & VAR_37) {\n        VAR_11 |= VAR_38;\n    }\n    if (VAR_9 & VAR_39) {\n        VAR_11 |= VAR_40;\n    }\n\n    /* COMMENT_3 */\n    if (!(VAR_5.flags & VAR_41)) {\n        VAR_5.per = 0644;\n    }\n\n    if (wolfSSH_CleanPath(VAR_0, VAR_8) < 0) {\n        WFREE(VAR_8, VAR_0->ctx->heap, VAR_26);\n        return VAR_24;\n    }\n    VAR_6 = WOPEN(VAR_8, VAR_11, VAR_5.per);\n    if (VAR_6 < 0) {\n        WLOG(VAR_22, \"Error opening file %s\", VAR_8);\n        VAR_18 = VAR_20;\n        if (wolfSSH_SFTP_CreateStatus(VAR_0, VAR_42, VAR_1, VAR_18,\n                \"English\", NULL, &VAR_14) != VAR_43) {\n            WFREE(VAR_8, VAR_0->ctx->heap, VAR_26);\n            return VAR_24;\n        }\n        VAR_12 = VAR_44;\n    }\n\n#ifdef VAR_45\n    if (VAR_12 == VAR_13) {\n        if ((VAR_12 = SFTP_AddHandleNode(VAR_0, (byte*)&VAR_6, sizeof(WFD), VAR_8)) != VAR_13) {\n            WLOG(VAR_22, \"Unable to store handle\");\n            VAR_18 = VAR_19;\n            if (wolfSSH_SFTP_CreateStatus(VAR_0, VAR_42, VAR_1, VAR_18,\n                \"English\", NULL, &VAR_14) != VAR_43) {\n                WFREE(VAR_8, VAR_0->ctx->heap, VAR_26);\n                return VAR_24;\n            }\n            VAR_12 = VAR_24;\n        }\n    }\n#endif\n    WFREE(VAR_8, VAR_0->ctx->heap, VAR_26);\n\n    /* COMMENT_4 */\n    VAR_17 = (byte*)WMALLOC(VAR_14, VAR_0->ctx->heap, VAR_26);\n    if (VAR_17 == NULL) {\n        return VAR_27;\n    }\n    if (VAR_12 == VAR_13) {\n        if (SFTP_CreatePacket(VAR_0, VAR_46, VAR_17, VAR_14,\n            (byte*)&VAR_6, sizeof(WFD)) != VAR_13) {\n            return VAR_24;\n        }\n    }\n    else {\n        if (wolfSSH_SFTP_CreateStatus(VAR_0, VAR_42, VAR_1, VAR_18,\n                \"English\", VAR_17, &VAR_14) != VAR_13) {\n            WFREE(VAR_17, VAR_0->ctx->heap, VAR_26);\n            return VAR_24;\n        }\n    }\n\n    /* COMMENT_5 */\n    wolfSSH_SFTP_RecvSetSend(VAR_0, VAR_17, VAR_14);\n\n    (void)VAR_19;\n    return VAR_12;\n}",
  "func_graph_path": "wolfSSL/wolfssh/edb272e35ee57e7b89f3e127222c6981b6a1e730/wolfsftp.c/vul/after/6.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -29,7 +29,7 @@\n     }\n \n     ato32(data + idx, &sz); idx += UINT32_SZ;\n-    if (sz + idx > maxSz) {\n+    if (sz > maxSz - idx) {\n         return WS_BUFFER_E;\n     }\n ",
  "diff_line_info": {
    "deleted_lines": [
      "    if (sz + idx > maxSz) {"
    ],
    "added_lines": [
      "    if (sz > maxSz - idx) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/wolfSSL/wolfssh/pull/360",
  "description": {
    "pr_info": {
      "title": "ASAN SFTP Fixes",
      "number": 360
    },
    "comment": [
      "When decoding SFTP messages, fix the size checks so they don't wrap. (ZD12766)"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "Final Classification: Security Vulnerability Fix; Confidence: 0.95\n\n**Step-by-Step Explanation:**\n\n1. **Commit Message Analysis:** Mentions \"ASAN SFTP Fixes\" and \"size checks\", indicating potential overflow issues.\n2. **Code Change:** Adjusts the size check to prevent integer overflow, a critical security fix.\n3. **Function Context:** Involves decoding SFTP messages, which is a protocol used for file transfers, making the security implications clear.\n4. **Vulnerability Type:** Likely integer overflow, which can lead to buffer overflows and is a common security vulnerability.\n5. **Confidence:** High due to clear indicators and context pointing to a security fix.\n\n**Final Answer:**  \n**Final Classification:** Security Vulnerability Fix; **Confidence:** 0.95"
}