{
  "cve_id": "CVE-2021-20302",
  "cwe_ids": [
    "CWE-20"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:C",
  "cvss_is_v3": false,
  "repo_name": "AcademySoftwareFoundation/openexr",
  "commit_msg": "add exrcheck binary and function in IlmImfUtil\n\nSigned-off-by: Peter Hillman <peterh@wetafx.co.nz>",
  "commit_hash": "f044caeed5c0f1566d804f37cbddb2d5ccfd75ea",
  "git_url": "https://github.com/AcademySoftwareFoundation/openexr/commit/f044caeed5c0f1566d804f37cbddb2d5ccfd75ea",
  "file_path": "OpenEXR/IlmImf/ImfInputFile.cpp",
  "func_name": "bufferedReadPixels",
  "func_before": "void\nbufferedReadPixels (InputFile::Data* ifd, int scanLine1, int scanLine2)\n{\n    //\n    // bufferedReadPixels reads each row of tiles that intersect the\n    // scan-line range (scanLine1 to scanLine2). The previous row of\n    // tiles is cached in order to prevent redundent tile reads when\n    // accessing scanlines sequentially.\n    //\n\n    int minY = std::min (scanLine1, scanLine2);\n    int maxY = std::max (scanLine1, scanLine2);\n\n    if (minY < ifd->minY || maxY >  ifd->maxY)\n    {\n        throw IEX_NAMESPACE::ArgExc (\"Tried to read scan line outside \"\n\t\t\t   \"the image file's data window.\");\n    }\n\n    //\n    // The minimum and maximum y tile coordinates that intersect this\n    // scanline range\n    //\n\n    int minDy = (minY - ifd->minY) / ifd->tFile->tileYSize();\n    int maxDy = (maxY - ifd->minY) / ifd->tFile->tileYSize();\n\n    //\n    // Figure out which one is first in the file so we can read without seeking\n    //\n\n    int yStart, yEnd, yStep;\n\n    if (ifd->lineOrder == DECREASING_Y)\n    {\n        yStart = maxDy;\n        yEnd = minDy - 1;\n        yStep = -1;\n    }\n    else\n    {\n        yStart = minDy;\n        yEnd = maxDy + 1;\n        yStep = 1;\n    }\n\n    //\n    // the number of pixels in a row of tiles\n    //\n\n    Box2i levelRange = ifd->tFile->dataWindowForLevel(0);\n    \n    //\n    // Read the tiles into our temporary framebuffer and copy them into\n    // the user's buffer\n    //\n\n    for (int j = yStart; j != yEnd; j += yStep)\n    {\n        Box2i tileRange = ifd->tFile->dataWindowForTile (0, j, 0);\n\n        int minYThisRow = std::max (minY, tileRange.min.y);\n        int maxYThisRow = std::min (maxY, tileRange.max.y);\n\n        if (j != ifd->cachedTileY)\n        {\n            //\n            // We don't have any valid buffered info, so we need to read in\n            // from the file.\n            // if no channels are being read that are present in file, cachedBuffer will be empty\n            //\n\n            if (ifd->cachedBuffer->begin() != ifd->cachedBuffer->end())\n            {\n                ifd->tFile->readTiles (0, ifd->tFile->numXTiles (0) - 1, j, j);\n            }\n\n            ifd->cachedTileY = j;\n        }\n\n        //\n        // Copy the data from our cached framebuffer into the user's\n        // framebuffer.\n        //\n\n        for (FrameBuffer::ConstIterator k = ifd->tFileBuffer.begin();\n             k != ifd->tFileBuffer.end();\n             ++k)\n        {\n\n\n            Slice toSlice = k.slice();\t\t// slice to read from\n            char* toPtr;\n\n            int xStart = levelRange.min.x;\n            int yStart = minYThisRow;\n\n            while (modp (xStart, toSlice.xSampling) != 0)\n                ++xStart;\n\n            while (modp (yStart, toSlice.ySampling) != 0)\n                ++yStart;\n\n            FrameBuffer::ConstIterator c = ifd->cachedBuffer->find(k.name());\n            intptr_t toBase = reinterpret_cast<intptr_t>(toSlice.base);\n\n\n            if( c!=ifd->cachedBuffer->end())\n            {\n                //\n                // output channel was read from source image: copy to output slice\n                //\n                Slice fromSlice = c.slice();\t// slice to write to\n                intptr_t fromBase = reinterpret_cast<intptr_t>(fromSlice.base);\n\n                int size = pixelTypeSize (toSlice.type);\n                char* fromPtr;\n\n                for (int y = yStart;\n                    y <= maxYThisRow;\n                    y += toSlice.ySampling)\n                {\n                    //\n                    // Set the pointers to the start of the y scanline in\n                    // this row of tiles\n                    //\n\n                    fromPtr = reinterpret_cast<char*> (fromBase  +\n                            (y - tileRange.min.y) * fromSlice.yStride +\n                            xStart * fromSlice.xStride);\n\n                    toPtr = reinterpret_cast<char*> (toBase +\n                            divp (y, toSlice.ySampling) * toSlice.yStride +\n                            divp (xStart, toSlice.xSampling) * toSlice.xStride);\n\n                    //\n                    // Copy all pixels for the scanline in this row of tiles\n                    //\n\n                    for (int x = xStart;\n                        x <= levelRange.max.x;\n                        x += toSlice.xSampling)\n                    {\n                        for (int i = 0; i < size; ++i)\n                            toPtr[i] = fromPtr[i];\n\n                        fromPtr += fromSlice.xStride * toSlice.xSampling;\n                        toPtr += toSlice.xStride;\n                    }\n                }\n            }\n            else\n            {\n\n                //\n                // channel wasn't present in source file: fill output slice\n                //\n                for (int y = yStart;\n                    y <= maxYThisRow;\n                    y += toSlice.ySampling)\n                {\n\n                    toPtr = reinterpret_cast<char*> (toBase+\n                            divp (y, toSlice.ySampling) * toSlice.yStride +\n                            divp (xStart, toSlice.xSampling) * toSlice.xStride);\n\n                    //\n                    // Copy all pixels for the scanline in this row of tiles\n                    //\n\n                    switch ( toSlice.type)\n                    {\n                        case UINT:\n                        {\n                            unsigned int fill = toSlice.fillValue;\n                            for (int x = xStart;\n                                x <= levelRange.max.x;\n                                x += toSlice.xSampling)\n                            {\n                                * reinterpret_cast<unsigned int*>(toPtr) = fill;\n                                toPtr += toSlice.xStride;\n                            }\n                            break;\n                        }\n                        case HALF :\n                        {\n                            half fill = toSlice.fillValue;\n                            for (int x = xStart;\n                                x <= levelRange.max.x;\n                                x += toSlice.xSampling)\n                            {\n                                * reinterpret_cast<half*>(toPtr) = fill;\n                                toPtr += toSlice.xStride;\n                            }\n                            break;\n                        }\n                        case FLOAT :\n                        {\n                            float fill = toSlice.fillValue;\n                            for (int x = xStart;\n                                x <= levelRange.max.x;\n                                x += toSlice.xSampling)\n                            {\n                                * reinterpret_cast<float*>(toPtr) = fill;\n                                toPtr += toSlice.xStride;\n                            }\n                            break;\n                        }\n                        case NUM_PIXELTYPES :\n                        {\n                            break;\n                        }\n\n                    }\n                }\n            }\n        }\n    }\n}",
  "abstract_func_before": "void\nbufferedReadPixels (InputFile::Data* VAR_0, int VAR_1, int VAR_2)\n{\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n    /* COMMENT_3 */\n    /* COMMENT_4 */\n    /* COMMENT_0 */\n\n    int VAR_3 = std::min (VAR_1, VAR_2);\n    int VAR_4 = std::max (VAR_1, VAR_2);\n\n    if (VAR_3 < VAR_0->minY || VAR_4 >  VAR_0->maxY)\n    {\n        throw IEX_NAMESPACE::ArgExc (\"Tried to read scan line outside \"\n\t\t\t   \"the image file's data window.\");\n    }\n\n    /* COMMENT_0 */\n    /* COMMENT_5 */\n    /* COMMENT_6 */\n    /* COMMENT_0 */\n\n    int VAR_5 = (VAR_3 - VAR_0->minY) / VAR_0->tFile->tileYSize();\n    int VAR_6 = (VAR_4 - VAR_0->minY) / VAR_0->tFile->tileYSize();\n\n    /* COMMENT_0 */\n    /* COMMENT_7 */\n    /* COMMENT_0 */\n\n    int VAR_7, VAR_8, VAR_9;\n\n    if (VAR_0->lineOrder == VAR_10)\n    {\n        VAR_7 = VAR_6;\n        VAR_8 = VAR_5 - 1;\n        VAR_9 = -1;\n    }\n    else\n    {\n        VAR_7 = VAR_5;\n        VAR_8 = VAR_6 + 1;\n        VAR_9 = 1;\n    }\n\n    /* COMMENT_0 */\n    /* COMMENT_8 */\n    /* COMMENT_0 */\n\n    Box2i VAR_11 = VAR_0->tFile->dataWindowForLevel(0);\n    \n    /* COMMENT_0 */\n    /* COMMENT_9 */\n    /* COMMENT_10 */\n    /* COMMENT_0 */\n\n    for (int VAR_12 = VAR_7; VAR_12 != VAR_8; VAR_12 += VAR_9)\n    {\n        Box2i VAR_13 = VAR_0->tFile->dataWindowForTile (0, VAR_12, 0);\n\n        int VAR_14 = std::max (VAR_3, VAR_13.min.y);\n        int VAR_15 = std::min (VAR_4, VAR_13.max.y);\n\n        if (VAR_12 != VAR_0->cachedTileY)\n        {\n            /* COMMENT_0 */\n            /* COMMENT_11 */\n            /* COMMENT_12 */\n            /* COMMENT_13 */\n            /* COMMENT_0 */\n\n            if (VAR_0->cachedBuffer->begin() != VAR_0->cachedBuffer->end())\n            {\n                VAR_0->tFile->readTiles (0, VAR_0->tFile->numXTiles (0) - 1, VAR_12, VAR_12);\n            }\n\n            VAR_0->cachedTileY = VAR_12;\n        }\n\n        /* COMMENT_0 */\n        /* COMMENT_14 */\n        /* COMMENT_15 */\n        /* COMMENT_0 */\n\n        for (FrameBuffer::ConstIterator VAR_16 = VAR_0->tFileBuffer.begin();\n             VAR_16 != VAR_0->tFileBuffer.end();\n             ++VAR_16)\n        {\n\n\n            Slice VAR_17 = VAR_16.slice();\t\t/* COMMENT_16 */\n            char* VAR_18;\n\n            int VAR_19 = VAR_11.min.x;\n            int VAR_7 = VAR_14;\n\n            while (modp (VAR_19, VAR_17.xSampling) != 0)\n                ++VAR_19;\n\n            while (modp (VAR_7, VAR_17.ySampling) != 0)\n                ++VAR_7;\n\n            FrameBuffer::ConstIterator VAR_20 = VAR_0->cachedBuffer->find(VAR_16.name());\n            intptr_t VAR_21 = VAR_22<intptr_t>(VAR_17.base);\n\n\n            if( VAR_20!=VAR_0->cachedBuffer->end())\n            {\n                /* COMMENT_0 */\n                /* COMMENT_17 */\n                /* COMMENT_0 */\n                Slice VAR_23 = VAR_20.slice();\t/* COMMENT_18 */\n                intptr_t VAR_24 = VAR_22<intptr_t>(VAR_23.base);\n\n                int VAR_25 = pixelTypeSize (VAR_17.type);\n                char* VAR_26;\n\n                for (int VAR_27 = VAR_7;\n                    VAR_27 <= VAR_15;\n                    VAR_27 += VAR_17.ySampling)\n                {\n                    /* COMMENT_0 */\n                    /* COMMENT_19 */\n                    /* COMMENT_20 */\n                    /* COMMENT_0 */\n\n                    VAR_26 = VAR_22<char*> (VAR_24  +\n                            (VAR_27 - VAR_13.min.y) * VAR_23.yStride +\n                            VAR_19 * VAR_23.xStride);\n\n                    VAR_18 = VAR_22<char*> (VAR_21 +\n                            divp (VAR_27, VAR_17.ySampling) * VAR_17.yStride +\n                            divp (VAR_19, VAR_17.xSampling) * VAR_17.xStride);\n\n                    /* COMMENT_0 */\n                    /* COMMENT_21 */\n                    /* COMMENT_0 */\n\n                    for (int VAR_28 = VAR_19;\n                        VAR_28 <= VAR_11.max.x;\n                        VAR_28 += VAR_17.xSampling)\n                    {\n                        for (int VAR_29 = 0; VAR_29 < VAR_25; ++VAR_29)\n                            VAR_18[VAR_29] = VAR_26[VAR_29];\n\n                        VAR_26 += VAR_23.xStride * VAR_17.xSampling;\n                        VAR_18 += VAR_17.xStride;\n                    }\n                }\n            }\n            else\n            {\n\n                /* COMMENT_0 */\n                /* COMMENT_22 */\n                /* COMMENT_0 */\n                for (int VAR_27 = VAR_7;\n                    VAR_27 <= VAR_15;\n                    VAR_27 += VAR_17.ySampling)\n                {\n\n                    VAR_18 = VAR_22<char*> (VAR_21+\n                            divp (VAR_27, VAR_17.ySampling) * VAR_17.yStride +\n                            divp (VAR_19, VAR_17.xSampling) * VAR_17.xStride);\n\n                    /* COMMENT_0 */\n                    /* COMMENT_21 */\n                    /* COMMENT_0 */\n\n                    switch ( VAR_17.type)\n                    {\n                        case VAR_30:\n                        {\n                            unsigned int VAR_31 = VAR_17.fillValue;\n                            for (int VAR_28 = VAR_19;\n                                VAR_28 <= VAR_11.max.x;\n                                VAR_28 += VAR_17.xSampling)\n                            {\n                                * VAR_22<unsigned int*>(VAR_18) = VAR_31;\n                                VAR_18 += VAR_17.xStride;\n                            }\n                            break;\n                        }\n                        case VAR_32 :\n                        {\n                            half VAR_31 = VAR_17.fillValue;\n                            for (int VAR_28 = VAR_19;\n                                VAR_28 <= VAR_11.max.x;\n                                VAR_28 += VAR_17.xSampling)\n                            {\n                                * VAR_22<half*>(VAR_18) = VAR_31;\n                                VAR_18 += VAR_17.xStride;\n                            }\n                            break;\n                        }\n                        case VAR_33 :\n                        {\n                            float VAR_31 = VAR_17.fillValue;\n                            for (int VAR_28 = VAR_19;\n                                VAR_28 <= VAR_11.max.x;\n                                VAR_28 += VAR_17.xSampling)\n                            {\n                                * VAR_22<float*>(VAR_18) = VAR_31;\n                                VAR_18 += VAR_17.xStride;\n                            }\n                            break;\n                        }\n                        case VAR_34 :\n                        {\n                            break;\n                        }\n\n                    }\n                }\n            }\n        }\n    }\n}",
  "func_graph_path_before": "AcademySoftwareFoundation/openexr/f044caeed5c0f1566d804f37cbddb2d5ccfd75ea/ImfInputFile.cpp/vul/before/0.json",
  "func": "void\nbufferedReadPixels (InputFile::Data* ifd, int scanLine1, int scanLine2)\n{\n    //\n    // bufferedReadPixels reads each row of tiles that intersect the\n    // scan-line range (scanLine1 to scanLine2). The previous row of\n    // tiles is cached in order to prevent redundent tile reads when\n    // accessing scanlines sequentially.\n    //\n\n    int minY = std::min (scanLine1, scanLine2);\n    int maxY = std::max (scanLine1, scanLine2);\n\n    if (minY < ifd->minY || maxY >  ifd->maxY)\n    {\n        throw IEX_NAMESPACE::ArgExc (\"Tried to read scan line outside \"\n\t\t\t   \"the image file's data window.\");\n    }\n\n    //\n    // The minimum and maximum y tile coordinates that intersect this\n    // scanline range\n    //\n\n    int minDy = (minY - ifd->minY) / ifd->tFile->tileYSize();\n    int maxDy = (maxY - ifd->minY) / ifd->tFile->tileYSize();\n\n    //\n    // Figure out which one is first in the file so we can read without seeking\n    //\n\n    int yStart, yEnd, yStep;\n\n    if (ifd->lineOrder == DECREASING_Y)\n    {\n        yStart = maxDy;\n        yEnd = minDy - 1;\n        yStep = -1;\n    }\n    else\n    {\n        yStart = minDy;\n        yEnd = maxDy + 1;\n        yStep = 1;\n    }\n\n    //\n    // the number of pixels in a row of tiles\n    //\n\n    Box2i levelRange = ifd->tFile->dataWindowForLevel(0);\n    \n    //\n    // Read the tiles into our temporary framebuffer and copy them into\n    // the user's buffer\n    //\n\n    for (int j = yStart; j != yEnd; j += yStep)\n    {\n        Box2i tileRange = ifd->tFile->dataWindowForTile (0, j, 0);\n\n        int minYThisRow = std::max (minY, tileRange.min.y);\n        int maxYThisRow = std::min (maxY, tileRange.max.y);\n\n        if (j != ifd->cachedTileY)\n        {\n            //\n            // We don't have any valid buffered info, so we need to read in\n            // from the file.\n            // if no channels are being read that are present in file, cachedBuffer will be empty\n            //\n\n            if (ifd->cachedBuffer && ifd->cachedBuffer->begin() != ifd->cachedBuffer->end())\n            {\n                ifd->tFile->readTiles (0, ifd->tFile->numXTiles (0) - 1, j, j);\n            }\n\n            ifd->cachedTileY = j;\n        }\n\n        //\n        // Copy the data from our cached framebuffer into the user's\n        // framebuffer.\n        //\n\n        for (FrameBuffer::ConstIterator k = ifd->tFileBuffer.begin();\n             k != ifd->tFileBuffer.end();\n             ++k)\n        {\n\n\n            Slice toSlice = k.slice();\t\t// slice to read from\n            char* toPtr;\n\n            int xStart = levelRange.min.x;\n            int yStart = minYThisRow;\n\n            while (modp (xStart, toSlice.xSampling) != 0)\n                ++xStart;\n\n            while (modp (yStart, toSlice.ySampling) != 0)\n                ++yStart;\n\n            FrameBuffer::ConstIterator c = ifd->cachedBuffer->find(k.name());\n            intptr_t toBase = reinterpret_cast<intptr_t>(toSlice.base);\n\n\n            if( c!=ifd->cachedBuffer->end())\n            {\n                //\n                // output channel was read from source image: copy to output slice\n                //\n                Slice fromSlice = c.slice();\t// slice to write to\n                intptr_t fromBase = reinterpret_cast<intptr_t>(fromSlice.base);\n\n                int size = pixelTypeSize (toSlice.type);\n                char* fromPtr;\n\n                for (int y = yStart;\n                    y <= maxYThisRow;\n                    y += toSlice.ySampling)\n                {\n                    //\n                    // Set the pointers to the start of the y scanline in\n                    // this row of tiles\n                    //\n\n                    fromPtr = reinterpret_cast<char*> (fromBase  +\n                            (y - tileRange.min.y) * fromSlice.yStride +\n                            xStart * fromSlice.xStride);\n\n                    toPtr = reinterpret_cast<char*> (toBase +\n                            divp (y, toSlice.ySampling) * toSlice.yStride +\n                            divp (xStart, toSlice.xSampling) * toSlice.xStride);\n\n                    //\n                    // Copy all pixels for the scanline in this row of tiles\n                    //\n\n                    for (int x = xStart;\n                        x <= levelRange.max.x;\n                        x += toSlice.xSampling)\n                    {\n                        for (int i = 0; i < size; ++i)\n                            toPtr[i] = fromPtr[i];\n\n                        fromPtr += fromSlice.xStride * toSlice.xSampling;\n                        toPtr += toSlice.xStride;\n                    }\n                }\n            }\n            else\n            {\n\n                //\n                // channel wasn't present in source file: fill output slice\n                //\n                for (int y = yStart;\n                    y <= maxYThisRow;\n                    y += toSlice.ySampling)\n                {\n\n                    toPtr = reinterpret_cast<char*> (toBase+\n                            divp (y, toSlice.ySampling) * toSlice.yStride +\n                            divp (xStart, toSlice.xSampling) * toSlice.xStride);\n\n                    //\n                    // Copy all pixels for the scanline in this row of tiles\n                    //\n\n                    switch ( toSlice.type)\n                    {\n                        case UINT:\n                        {\n                            unsigned int fill = toSlice.fillValue;\n                            for (int x = xStart;\n                                x <= levelRange.max.x;\n                                x += toSlice.xSampling)\n                            {\n                                * reinterpret_cast<unsigned int*>(toPtr) = fill;\n                                toPtr += toSlice.xStride;\n                            }\n                            break;\n                        }\n                        case HALF :\n                        {\n                            half fill = toSlice.fillValue;\n                            for (int x = xStart;\n                                x <= levelRange.max.x;\n                                x += toSlice.xSampling)\n                            {\n                                * reinterpret_cast<half*>(toPtr) = fill;\n                                toPtr += toSlice.xStride;\n                            }\n                            break;\n                        }\n                        case FLOAT :\n                        {\n                            float fill = toSlice.fillValue;\n                            for (int x = xStart;\n                                x <= levelRange.max.x;\n                                x += toSlice.xSampling)\n                            {\n                                * reinterpret_cast<float*>(toPtr) = fill;\n                                toPtr += toSlice.xStride;\n                            }\n                            break;\n                        }\n                        case NUM_PIXELTYPES :\n                        {\n                            break;\n                        }\n\n                    }\n                }\n            }\n        }\n    }\n}",
  "abstract_func": "void\nbufferedReadPixels (InputFile::Data* VAR_0, int VAR_1, int VAR_2)\n{\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n    /* COMMENT_3 */\n    /* COMMENT_4 */\n    /* COMMENT_0 */\n\n    int VAR_3 = std::min (VAR_1, VAR_2);\n    int VAR_4 = std::max (VAR_1, VAR_2);\n\n    if (VAR_3 < VAR_0->minY || VAR_4 >  VAR_0->maxY)\n    {\n        throw IEX_NAMESPACE::ArgExc (\"Tried to read scan line outside \"\n\t\t\t   \"the image file's data window.\");\n    }\n\n    /* COMMENT_0 */\n    /* COMMENT_5 */\n    /* COMMENT_6 */\n    /* COMMENT_0 */\n\n    int VAR_5 = (VAR_3 - VAR_0->minY) / VAR_0->tFile->tileYSize();\n    int VAR_6 = (VAR_4 - VAR_0->minY) / VAR_0->tFile->tileYSize();\n\n    /* COMMENT_0 */\n    /* COMMENT_7 */\n    /* COMMENT_0 */\n\n    int VAR_7, VAR_8, VAR_9;\n\n    if (VAR_0->lineOrder == VAR_10)\n    {\n        VAR_7 = VAR_6;\n        VAR_8 = VAR_5 - 1;\n        VAR_9 = -1;\n    }\n    else\n    {\n        VAR_7 = VAR_5;\n        VAR_8 = VAR_6 + 1;\n        VAR_9 = 1;\n    }\n\n    /* COMMENT_0 */\n    /* COMMENT_8 */\n    /* COMMENT_0 */\n\n    Box2i VAR_11 = VAR_0->tFile->dataWindowForLevel(0);\n    \n    /* COMMENT_0 */\n    /* COMMENT_9 */\n    /* COMMENT_10 */\n    /* COMMENT_0 */\n\n    for (int VAR_12 = VAR_7; VAR_12 != VAR_8; VAR_12 += VAR_9)\n    {\n        Box2i VAR_13 = VAR_0->tFile->dataWindowForTile (0, VAR_12, 0);\n\n        int VAR_14 = std::max (VAR_3, VAR_13.min.y);\n        int VAR_15 = std::min (VAR_4, VAR_13.max.y);\n\n        if (VAR_12 != VAR_0->cachedTileY)\n        {\n            /* COMMENT_0 */\n            /* COMMENT_11 */\n            /* COMMENT_12 */\n            /* COMMENT_13 */\n            /* COMMENT_0 */\n\n            if (VAR_0->cachedBuffer && VAR_0->cachedBuffer->begin() != VAR_0->cachedBuffer->end())\n            {\n                VAR_0->tFile->readTiles (0, VAR_0->tFile->numXTiles (0) - 1, VAR_12, VAR_12);\n            }\n\n            VAR_0->cachedTileY = VAR_12;\n        }\n\n        /* COMMENT_0 */\n        /* COMMENT_14 */\n        /* COMMENT_15 */\n        /* COMMENT_0 */\n\n        for (FrameBuffer::ConstIterator VAR_16 = VAR_0->tFileBuffer.begin();\n             VAR_16 != VAR_0->tFileBuffer.end();\n             ++VAR_16)\n        {\n\n\n            Slice VAR_17 = VAR_16.slice();\t\t/* COMMENT_16 */\n            char* VAR_18;\n\n            int VAR_19 = VAR_11.min.x;\n            int VAR_7 = VAR_14;\n\n            while (modp (VAR_19, VAR_17.xSampling) != 0)\n                ++VAR_19;\n\n            while (modp (VAR_7, VAR_17.ySampling) != 0)\n                ++VAR_7;\n\n            FrameBuffer::ConstIterator VAR_20 = VAR_0->cachedBuffer->find(VAR_16.name());\n            intptr_t VAR_21 = VAR_22<intptr_t>(VAR_17.base);\n\n\n            if( VAR_20!=VAR_0->cachedBuffer->end())\n            {\n                /* COMMENT_0 */\n                /* COMMENT_17 */\n                /* COMMENT_0 */\n                Slice VAR_23 = VAR_20.slice();\t/* COMMENT_18 */\n                intptr_t VAR_24 = VAR_22<intptr_t>(VAR_23.base);\n\n                int VAR_25 = pixelTypeSize (VAR_17.type);\n                char* VAR_26;\n\n                for (int VAR_27 = VAR_7;\n                    VAR_27 <= VAR_15;\n                    VAR_27 += VAR_17.ySampling)\n                {\n                    /* COMMENT_0 */\n                    /* COMMENT_19 */\n                    /* COMMENT_20 */\n                    /* COMMENT_0 */\n\n                    VAR_26 = VAR_22<char*> (VAR_24  +\n                            (VAR_27 - VAR_13.min.y) * VAR_23.yStride +\n                            VAR_19 * VAR_23.xStride);\n\n                    VAR_18 = VAR_22<char*> (VAR_21 +\n                            divp (VAR_27, VAR_17.ySampling) * VAR_17.yStride +\n                            divp (VAR_19, VAR_17.xSampling) * VAR_17.xStride);\n\n                    /* COMMENT_0 */\n                    /* COMMENT_21 */\n                    /* COMMENT_0 */\n\n                    for (int VAR_28 = VAR_19;\n                        VAR_28 <= VAR_11.max.x;\n                        VAR_28 += VAR_17.xSampling)\n                    {\n                        for (int VAR_29 = 0; VAR_29 < VAR_25; ++VAR_29)\n                            VAR_18[VAR_29] = VAR_26[VAR_29];\n\n                        VAR_26 += VAR_23.xStride * VAR_17.xSampling;\n                        VAR_18 += VAR_17.xStride;\n                    }\n                }\n            }\n            else\n            {\n\n                /* COMMENT_0 */\n                /* COMMENT_22 */\n                /* COMMENT_0 */\n                for (int VAR_27 = VAR_7;\n                    VAR_27 <= VAR_15;\n                    VAR_27 += VAR_17.ySampling)\n                {\n\n                    VAR_18 = VAR_22<char*> (VAR_21+\n                            divp (VAR_27, VAR_17.ySampling) * VAR_17.yStride +\n                            divp (VAR_19, VAR_17.xSampling) * VAR_17.xStride);\n\n                    /* COMMENT_0 */\n                    /* COMMENT_21 */\n                    /* COMMENT_0 */\n\n                    switch ( VAR_17.type)\n                    {\n                        case VAR_30:\n                        {\n                            unsigned int VAR_31 = VAR_17.fillValue;\n                            for (int VAR_28 = VAR_19;\n                                VAR_28 <= VAR_11.max.x;\n                                VAR_28 += VAR_17.xSampling)\n                            {\n                                * VAR_22<unsigned int*>(VAR_18) = VAR_31;\n                                VAR_18 += VAR_17.xStride;\n                            }\n                            break;\n                        }\n                        case VAR_32 :\n                        {\n                            half VAR_31 = VAR_17.fillValue;\n                            for (int VAR_28 = VAR_19;\n                                VAR_28 <= VAR_11.max.x;\n                                VAR_28 += VAR_17.xSampling)\n                            {\n                                * VAR_22<half*>(VAR_18) = VAR_31;\n                                VAR_18 += VAR_17.xStride;\n                            }\n                            break;\n                        }\n                        case VAR_33 :\n                        {\n                            float VAR_31 = VAR_17.fillValue;\n                            for (int VAR_28 = VAR_19;\n                                VAR_28 <= VAR_11.max.x;\n                                VAR_28 += VAR_17.xSampling)\n                            {\n                                * VAR_22<float*>(VAR_18) = VAR_31;\n                                VAR_18 += VAR_17.xStride;\n                            }\n                            break;\n                        }\n                        case VAR_34 :\n                        {\n                            break;\n                        }\n\n                    }\n                }\n            }\n        }\n    }\n}",
  "func_graph_path": "AcademySoftwareFoundation/openexr/f044caeed5c0f1566d804f37cbddb2d5ccfd75ea/ImfInputFile.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -70,7 +70,7 @@\n             // if no channels are being read that are present in file, cachedBuffer will be empty\n             //\n \n-            if (ifd->cachedBuffer->begin() != ifd->cachedBuffer->end())\n+            if (ifd->cachedBuffer && ifd->cachedBuffer->begin() != ifd->cachedBuffer->end())\n             {\n                 ifd->tFile->readTiles (0, ifd->tFile->numXTiles (0) - 1, j, j);\n             }",
  "diff_line_info": {
    "deleted_lines": [
      "            if (ifd->cachedBuffer->begin() != ifd->cachedBuffer->end())"
    ],
    "added_lines": [
      "            if (ifd->cachedBuffer && ifd->cachedBuffer->begin() != ifd->cachedBuffer->end())"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/AcademySoftwareFoundation/openexr/pull/842",
  "description": {
    "pr_info": {
      "title": "add exrcheck utility and hooks for fuzz testing",
      "number": 842
    },
    "comment": [
      "This adds an `exrcheck` binary (not installed by default) that can be used to check for bad files, as well as looking for issues in the OpenEXR library. This wraps a new API call in IlmImfUtil: checkOpenEXRFile()\r\n\r\nA hook to call this function with the [oss-fuzz](https://github.com/google/oss-fuzz) project has also been added in IlmImfFuzzTest. This file is to be compiled by that project\r\n\r\nOpenEXR's internal fuzz tests could also be adapted to use checkOpenEXRFile instead of their own function. This would allow for more exhaustive testing.\r\n\r\nA few other additions to the API:\r\n\r\n- For this to work efficiently, missing functionality is added to open (single part) DeepScanLineInputFiles via a stream interface. This was the only API missing that functionality\r\n- MultiPartInputFile::flushPartCache method is required to switch between part readers (Tiled files can be read either as TiledInputPart or InputPart. flushPartCache must be called to change the reader type within the same object)\r\n\r\nOther bugfixes to address issues found while testing against the 'Damaged' file list that were required to properly test `exrcheck`:\r\n\r\n- DeepScanLineInputFile had a 32 bit integer overflow accessing the sample count table with very large values of dataWindow.min.x\r\n- InputFile could crash when reading tiled files as scanlines in 'readPixels' if 'setFrameBuffer' was called with an empty frame buffer\r\n- Single part non-image files would not be detected in the TiledInputFile. Attempting to read anything which isn't a tiled regular image with this call now throws an exception. This should also address https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=25892 and https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=25894"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\nAnalysis: The patch introduces a new utility (exrcheck) for file validation and includes several bug fixes aimed at preventing crashes and overflows, which could be exploited. The code changes add necessary null checks and address issues found during security testing.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 0.95"
}