{
  "cve_id": "CVE-2016-10210",
  "cwe_ids": [
    "CWE-476"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "VirusTotal/yara",
  "commit_msg": "re_lexer: Make reading escape sequences more robust (#586)\n\n* Add test for issue #503\r\n\r\n* re_lexer: Make reading escape sequences more robust\r\n\r\nThis commit fixes parsing incomplete escape sequences at the end of a\r\nregular expression and parsing things like \\xxy (invalid hex digits)\r\nwhich before were silently turned into (char)255.\r\n\r\nClose #503\r\n\r\n* Update re_lexer.c",
  "commit_hash": "3119b232c9c453c98d8fa8b6ae4e37ba18117cd4",
  "git_url": "https://github.com/VirusTotal/yara/commit/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4",
  "file_path": "libyara/re_lexer.c",
  "func_name": "re_yyensure_buffer_stack",
  "func_before": "static void re_yyensure_buffer_stack (yyscan_t yyscanner)\n{\n\tyy_size_t num_to_alloc;\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n\tif (!yyg->yy_buffer_stack) {\n\n\t\t/* First allocation is just for 2 elements, since we don't know if this\n\t\t * scanner will even need a stack. We use 2 instead of 1 to avoid an\n\t\t * immediate realloc on the next call.\n         */\n\t\tnum_to_alloc = 1; // After all that talk, this was set to 1 anyways...\n\t\tyyg->yy_buffer_stack = (struct yy_buffer_state**)re_yyalloc\n\t\t\t\t\t\t\t\t(num_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t, yyscanner);\n\t\tif ( ! yyg->yy_buffer_stack )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in re_yyensure_buffer_stack()\" );\n\t\t\t\t\t\t\t\t  \n\t\tmemset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));\n\t\t\t\t\n\t\tyyg->yy_buffer_stack_max = num_to_alloc;\n\t\tyyg->yy_buffer_stack_top = 0;\n\t\treturn;\n\t}\n\n\tif (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){\n\n\t\t/* Increase the buffer to prepare for a possible push. */\n\t\tyy_size_t grow_size = 8 /* arbitrary grow size */;\n\n\t\tnum_to_alloc = yyg->yy_buffer_stack_max + grow_size;\n\t\tyyg->yy_buffer_stack = (struct yy_buffer_state**)re_yyrealloc\n\t\t\t\t\t\t\t\t(yyg->yy_buffer_stack,\n\t\t\t\t\t\t\t\tnum_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t, yyscanner);\n\t\tif ( ! yyg->yy_buffer_stack )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in re_yyensure_buffer_stack()\" );\n\n\t\t/* zero only the new slots.*/\n\t\tmemset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));\n\t\tyyg->yy_buffer_stack_max = num_to_alloc;\n\t}\n}",
  "abstract_func_before": "static void re_yyensure_buffer_stack (yyscan_t VAR_0)\n{\n\tyy_size_t VAR_1;\n    struct yyguts_t * VAR_2 = (struct yyguts_t*)VAR_0;\n\n\tif (!VAR_2->yy_buffer_stack) {\n\n\t\t/* COMMENT_0 */\n                                                                      \n                                        \n           \n\t\tVAR_1 = 1; /* COMMENT_4 */\n\t\tVAR_2->yy_buffer_stack = (struct yy_buffer_state**)re_yyalloc\n\t\t\t\t\t\t\t\t(VAR_1 * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t, VAR_0);\n\t\tif ( ! VAR_2->yy_buffer_stack )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in re_yyensure_buffer_stack()\" );\n\t\t\t\t\t\t\t\t  \n\t\tmemset(VAR_2->yy_buffer_stack, 0, VAR_1 * sizeof(struct yy_buffer_state*));\n\t\t\t\t\n\t\tVAR_2->yy_buffer_stack_max = VAR_1;\n\t\tVAR_2->yy_buffer_stack_top = 0;\n\t\treturn;\n\t}\n\n\tif (VAR_2->yy_buffer_stack_top >= (VAR_2->yy_buffer_stack_max) - 1){\n\n\t\t/* COMMENT_5 */\n\t\tyy_size_t VAR_3 = 8 /* COMMENT_6 */;\n\n\t\tVAR_1 = VAR_2->yy_buffer_stack_max + VAR_3;\n\t\tVAR_2->yy_buffer_stack = (struct yy_buffer_state**)re_yyrealloc\n\t\t\t\t\t\t\t\t(VAR_2->yy_buffer_stack,\n\t\t\t\t\t\t\t\tVAR_1 * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t, VAR_0);\n\t\tif ( ! VAR_2->yy_buffer_stack )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in re_yyensure_buffer_stack()\" );\n\n\t\t/* COMMENT_7 */\n\t\tmemset(VAR_2->yy_buffer_stack + VAR_2->yy_buffer_stack_max, 0, VAR_3 * sizeof(struct yy_buffer_state*));\n\t\tVAR_2->yy_buffer_stack_max = VAR_1;\n\t}\n}",
  "func_graph_path_before": "VirusTotal/yara/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4/re_lexer.c/vul/before/5.json",
  "func": "static void re_yyensure_buffer_stack (yyscan_t yyscanner)\n{\n\tyy_size_t num_to_alloc;\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n\tif (!yyg->yy_buffer_stack) {\n\n\t\t/* First allocation is just for 2 elements, since we don't know if this\n\t\t * scanner will even need a stack. We use 2 instead of 1 to avoid an\n\t\t * immediate realloc on the next call.\n         */\n\t\tnum_to_alloc = 1; // After all that talk, this was set to 1 anyways...\n\t\tyyg->yy_buffer_stack = (struct yy_buffer_state**)re_yyalloc\n\t\t\t\t\t\t\t\t(num_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t, yyscanner);\n\t\tif ( ! yyg->yy_buffer_stack )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in re_yyensure_buffer_stack()\" );\n\n\t\tmemset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));\n\n\t\tyyg->yy_buffer_stack_max = num_to_alloc;\n\t\tyyg->yy_buffer_stack_top = 0;\n\t\treturn;\n\t}\n\n\tif (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){\n\n\t\t/* Increase the buffer to prepare for a possible push. */\n\t\tyy_size_t grow_size = 8 /* arbitrary grow size */;\n\n\t\tnum_to_alloc = yyg->yy_buffer_stack_max + grow_size;\n\t\tyyg->yy_buffer_stack = (struct yy_buffer_state**)re_yyrealloc\n\t\t\t\t\t\t\t\t(yyg->yy_buffer_stack,\n\t\t\t\t\t\t\t\tnum_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t, yyscanner);\n\t\tif ( ! yyg->yy_buffer_stack )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in re_yyensure_buffer_stack()\" );\n\n\t\t/* zero only the new slots.*/\n\t\tmemset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));\n\t\tyyg->yy_buffer_stack_max = num_to_alloc;\n\t}\n}",
  "abstract_func": "static void re_yyensure_buffer_stack (yyscan_t VAR_0)\n{\n\tyy_size_t VAR_1;\n    struct yyguts_t * VAR_2 = (struct yyguts_t*)VAR_0;\n\n\tif (!VAR_2->yy_buffer_stack) {\n\n\t\t/* COMMENT_0 */\n                                                                      \n                                        \n           \n\t\tVAR_1 = 1; /* COMMENT_4 */\n\t\tVAR_2->yy_buffer_stack = (struct yy_buffer_state**)re_yyalloc\n\t\t\t\t\t\t\t\t(VAR_1 * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t, VAR_0);\n\t\tif ( ! VAR_2->yy_buffer_stack )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in re_yyensure_buffer_stack()\" );\n\n\t\tmemset(VAR_2->yy_buffer_stack, 0, VAR_1 * sizeof(struct yy_buffer_state*));\n\n\t\tVAR_2->yy_buffer_stack_max = VAR_1;\n\t\tVAR_2->yy_buffer_stack_top = 0;\n\t\treturn;\n\t}\n\n\tif (VAR_2->yy_buffer_stack_top >= (VAR_2->yy_buffer_stack_max) - 1){\n\n\t\t/* COMMENT_5 */\n\t\tyy_size_t VAR_3 = 8 /* COMMENT_6 */;\n\n\t\tVAR_1 = VAR_2->yy_buffer_stack_max + VAR_3;\n\t\tVAR_2->yy_buffer_stack = (struct yy_buffer_state**)re_yyrealloc\n\t\t\t\t\t\t\t\t(VAR_2->yy_buffer_stack,\n\t\t\t\t\t\t\t\tVAR_1 * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t, VAR_0);\n\t\tif ( ! VAR_2->yy_buffer_stack )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in re_yyensure_buffer_stack()\" );\n\n\t\t/* COMMENT_7 */\n\t\tmemset(VAR_2->yy_buffer_stack + VAR_2->yy_buffer_stack_max, 0, VAR_3 * sizeof(struct yy_buffer_state*));\n\t\tVAR_2->yy_buffer_stack_max = VAR_1;\n\t}\n}",
  "func_graph_path": "VirusTotal/yara/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4/re_lexer.c/vul/after/5.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -15,9 +15,9 @@\n \t\t\t\t\t\t\t\t, yyscanner);\n \t\tif ( ! yyg->yy_buffer_stack )\n \t\t\tYY_FATAL_ERROR( \"out of dynamic memory in re_yyensure_buffer_stack()\" );\n-\t\t\t\t\t\t\t\t  \n+\n \t\tmemset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));\n-\t\t\t\t\n+\n \t\tyyg->yy_buffer_stack_max = num_to_alloc;\n \t\tyyg->yy_buffer_stack_top = 0;\n \t\treturn;",
  "diff_line_info": {
    "deleted_lines": [
      "\t\t\t\t\t\t\t\t  ",
      "\t\t\t\t"
    ],
    "added_lines": [
      "",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/VirusTotal/yara/pull/586",
  "description": {
    "pr_info": {
      "title": "re_lexer: Make reading escape sequences more robust",
      "number": 586
    },
    "comment": [
      "This is actually more like the easy way out. As I mentioned in #503, one might want to change the `yr_re_parse_*` functions to accept a SIZED_STRING argument and use `yy_scan_bytes` instead."
    ]
  },
  "Bug Filter": "Supporting & Non-Core Improvements",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "\n\n**Final Output:**\nAnalysis: The commit aims to improve escape sequence parsing, but the code changes focus on buffer initialization, not security. The changes don't address a security vulnerability but enhance supporting functions.\n\nFinal Classification: Supporting & Non-Core Improvements\nConfidence Score: 0.8"
}