{
  "cve_id": "CVE-2017-9431",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "grpc",
  "commit_msg": "Fix error overflow bug",
  "commit_hash": "c6ec1155d026c91b1badb07ef1605bb747cff064",
  "git_url": "https://github.com/grpc/grpc/commit/c6ec1155d026c91b1badb07ef1605bb747cff064",
  "file_path": "src/core/lib/iomgr/error.c",
  "func_name": "internal_add_error",
  "func_before": "static void internal_add_error(grpc_error **err, grpc_error *new) {\n  grpc_linked_error new_last = {new, UINT8_MAX};\n  uint8_t slot = get_placement(err, sizeof(grpc_linked_error));\n  if ((*err)->first_err == UINT8_MAX) {\n    GPR_ASSERT((*err)->last_err == UINT8_MAX);\n    (*err)->last_err = slot;\n    (*err)->first_err = slot;\n  } else {\n    GPR_ASSERT((*err)->last_err != UINT8_MAX);\n    grpc_linked_error *old_last =\n        (grpc_linked_error *)((*err)->arena + (*err)->last_err);\n    old_last->next = slot;\n    (*err)->last_err = slot;\n  }\n  memcpy((*err)->arena + slot, &new_last, sizeof(grpc_linked_error));\n}",
  "abstract_func_before": "static void internal_add_error(grpc_error **VAR_0, grpc_error *VAR_1) {\n  grpc_linked_error VAR_2 = {VAR_1, VAR_3};\n  uint8_t VAR_4 = get_placement(VAR_0, sizeof(grpc_linked_error));\n  if ((*VAR_0)->first_err == VAR_3) {\n    GPR_ASSERT((*VAR_0)->last_err == VAR_3);\n    (*VAR_0)->last_err = VAR_4;\n    (*VAR_0)->first_err = VAR_4;\n  } else {\n    GPR_ASSERT((*VAR_0)->last_err != VAR_3);\n    grpc_linked_error *VAR_5 =\n        (grpc_linked_error *)((*VAR_0)->arena + (*VAR_0)->last_err);\n    VAR_5->next = VAR_4;\n    (*VAR_0)->last_err = VAR_4;\n  }\n  memcpy((*VAR_0)->arena + VAR_4, &VAR_2, sizeof(grpc_linked_error));\n}",
  "func_graph_path_before": "grpc/c6ec1155d026c91b1badb07ef1605bb747cff064/error.c/vul/before/1.json",
  "func": "static void internal_add_error(grpc_error **err, grpc_error *new) {\n  grpc_linked_error new_last = {new, UINT8_MAX};\n  uint8_t slot = get_placement(err, sizeof(grpc_linked_error));\n  if (slot == UINT8_MAX) {\n    gpr_log(GPR_ERROR, \"Error %p is full, dropping error %p = %s\", *err, new,\n            grpc_error_string(new));\n    GRPC_ERROR_UNREF(new);\n    return;\n  }\n  if ((*err)->first_err == UINT8_MAX) {\n    GPR_ASSERT((*err)->last_err == UINT8_MAX);\n    (*err)->last_err = slot;\n    (*err)->first_err = slot;\n  } else {\n    GPR_ASSERT((*err)->last_err != UINT8_MAX);\n    grpc_linked_error *old_last =\n        (grpc_linked_error *)((*err)->arena + (*err)->last_err);\n    old_last->next = slot;\n    (*err)->last_err = slot;\n  }\n  memcpy((*err)->arena + slot, &new_last, sizeof(grpc_linked_error));\n}",
  "abstract_func": "static void internal_add_error(grpc_error **VAR_0, grpc_error *VAR_1) {\n  grpc_linked_error VAR_2 = {VAR_1, VAR_3};\n  uint8_t VAR_4 = get_placement(VAR_0, sizeof(grpc_linked_error));\n  if (VAR_4 == VAR_3) {\n    gpr_log(VAR_5, \"Error %p is full, dropping error %p = %s\", *VAR_0, VAR_1,\n            grpc_error_string(VAR_1));\n    GRPC_ERROR_UNREF(VAR_1);\n    return;\n  }\n  if ((*VAR_0)->first_err == VAR_3) {\n    GPR_ASSERT((*VAR_0)->last_err == VAR_3);\n    (*VAR_0)->last_err = VAR_4;\n    (*VAR_0)->first_err = VAR_4;\n  } else {\n    GPR_ASSERT((*VAR_0)->last_err != VAR_3);\n    grpc_linked_error *VAR_6 =\n        (grpc_linked_error *)((*VAR_0)->arena + (*VAR_0)->last_err);\n    VAR_6->next = VAR_4;\n    (*VAR_0)->last_err = VAR_4;\n  }\n  memcpy((*VAR_0)->arena + VAR_4, &VAR_2, sizeof(grpc_linked_error));\n}",
  "func_graph_path": "grpc/c6ec1155d026c91b1badb07ef1605bb747cff064/error.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,12 @@\n static void internal_add_error(grpc_error **err, grpc_error *new) {\n   grpc_linked_error new_last = {new, UINT8_MAX};\n   uint8_t slot = get_placement(err, sizeof(grpc_linked_error));\n+  if (slot == UINT8_MAX) {\n+    gpr_log(GPR_ERROR, \"Error %p is full, dropping error %p = %s\", *err, new,\n+            grpc_error_string(new));\n+    GRPC_ERROR_UNREF(new);\n+    return;\n+  }\n   if ((*err)->first_err == UINT8_MAX) {\n     GPR_ASSERT((*err)->last_err == UINT8_MAX);\n     (*err)->last_err = slot;",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "  if (slot == UINT8_MAX) {",
      "    gpr_log(GPR_ERROR, \"Error %p is full, dropping error %p = %s\", *err, new,",
      "            grpc_error_string(new));",
      "    GRPC_ERROR_UNREF(new);",
      "    return;",
      "  }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/grpc/grpc/pull/10492",
  "description": {
    "pr_info": {
      "title": "Fix Error Overflow Bug",
      "number": 10492
    },
    "comment": [
      "Errors now drop and log data when they are too full. Added the fuzzer that caught this. Also added a new test case to error_test to hit some of this new functionality.",
      "This fixes: https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=1018",
      "```\nNo significant performance differences\n```",
      "```\nNo significant performance differences\n```",
      "Failures: #9804, Docker python flake"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix\n\nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\nThe patch addresses an overflow bug by adding checks to prevent errors when the error structure is full. This fix is crucial for preventing potential security issues like denial of service attacks.\n\n**Final Output:**\nAnalysis: The patch fixes an overflow bug by adding checks to prevent errors when the error structure is full. This change is critical for preventing potential security issues such as denial of service attacks.\n\nFinal Classification: Security Vulnerability Fix\n\nConfidence Score: 0.95"
}