{
  "cve_id": "CVE-2019-15788",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "NVIDIA-Genomics-Research/GenomeWorks",
  "commit_msg": "[cudapoa] replace size_t with int64_t",
  "commit_hash": "8524f2c0c690ff594a9ebc6d729351b07a1fc5f0",
  "git_url": "https://github.com/NVIDIA-Genomics-Research/GenomeWorks/commit/8524f2c0c690ff594a9ebc6d729351b07a1fc5f0",
  "file_path": "cudapoa/src/allocate_block.cpp",
  "func_name": "BatchBlock::calculate_space_per_poa",
  "func_before": "std::tuple<size_t, size_t, size_t, size_t> BatchBlock::calculate_space_per_poa()\n{\n    const int32_t poa_count = 1;\n\n    size_t host_size_fixed = 0, device_size_fixed = 0;\n    size_t host_size_per_poa = 0, device_size_per_poa = 0;\n\n    size_t input_size_per_poa  = max_sequences_per_poa_ * CUDAPOA_MAX_SEQUENCE_SIZE * poa_count;\n    size_t output_size_per_poa = CUDAPOA_MAX_CONSENSUS_SIZE * poa_count;\n\n    // for output - host\n    host_size_fixed += sizeof(OutputDetails);                                                                                   // output_details_h_\n    host_size_per_poa += output_size_per_poa * sizeof(uint8_t);                                                                 // output_details_h_->consensus\n    host_size_per_poa += (output_mask_ & OutputType::consensus) ? output_size_per_poa * sizeof(uint16_t) : 0;                   // output_details_h_->coverage\n    host_size_per_poa += (output_mask_ & OutputType::msa) ? output_size_per_poa * max_sequences_per_poa_ * sizeof(uint8_t) : 0; // output_details_h_->multiple_sequence_alignments\n    host_size_per_poa += sizeof(OutputDetails);                                                                                 // output_details_d_\n    // for output - device\n    device_size_per_poa += output_size_per_poa * sizeof(uint8_t);                                                                 // output_details_d_->consensus\n    device_size_per_poa += (output_mask_ & OutputType::consensus) ? output_size_per_poa * sizeof(uint16_t) : 0;                   // output_details_d_->coverage\n    device_size_per_poa += (output_mask_ & OutputType::msa) ? output_size_per_poa * max_sequences_per_poa_ * sizeof(uint8_t) : 0; // output_details_d_->multiple_sequence_alignments\n\n    // for input - host\n    host_size_fixed += sizeof(InputDetails);                                                                           // input_details_h_\n    host_size_per_poa += input_size_per_poa * sizeof(uint8_t);                                                         // input_details_h_->sequences\n    host_size_per_poa += input_size_per_poa * sizeof(int8_t);                                                          // input_details_h_->base_weights\n    host_size_per_poa += poa_count * max_sequences_per_poa_ * sizeof(uint16_t);                                        // input_details_h_->sequence_lengths\n    host_size_per_poa += poa_count * sizeof(WindowDetails);                                                            // input_details_h_->window_details\n    host_size_per_poa += (output_mask_ & OutputType::msa) ? poa_count * max_sequences_per_poa_ * sizeof(uint16_t) : 0; // input_details_h_->sequence_begin_nodes_ids\n\n    host_size_fixed += sizeof(InputDetails); // input_details_d_\n    // for input - device\n    device_size_per_poa += input_size_per_poa * sizeof(uint8_t);                                                         // input_details_d_->sequences\n    device_size_per_poa += input_size_per_poa * sizeof(int8_t);                                                          // input_details_d_->base_weights\n    device_size_per_poa += poa_count * max_sequences_per_poa_ * sizeof(uint16_t);                                        // input_details_d_->sequence_lengths\n    device_size_per_poa += poa_count * sizeof(WindowDetails);                                                            // input_details_d_->window_details\n    device_size_per_poa += (output_mask_ & OutputType::msa) ? poa_count * max_sequences_per_poa_ * sizeof(uint16_t) : 0; // input_details_d_->sequence_begin_nodes_ids\n\n    // for graph - host\n    host_size_fixed += sizeof(GraphDetails); // graph_details_d_\n    // for graph - device\n    device_size_per_poa += sizeof(uint8_t) * max_nodes_per_window_ * poa_count;                                                                                           // graph_details_d_->nodes\n    device_size_per_poa += sizeof(uint16_t) * max_nodes_per_window_ * CUDAPOA_MAX_NODE_ALIGNMENTS * poa_count;                                                            // graph_details_d_->node_alignments\n    device_size_per_poa += sizeof(uint16_t) * max_nodes_per_window_ * poa_count;                                                                                          // graph_details_d_->node_alignment_count\n    device_size_per_poa += sizeof(uint16_t) * max_nodes_per_window_ * CUDAPOA_MAX_NODE_EDGES * poa_count;                                                                 // graph_details_d_->incoming_edges\n    device_size_per_poa += sizeof(uint16_t) * max_nodes_per_window_ * poa_count;                                                                                          // graph_details_d_->incoming_edge_count\n    device_size_per_poa += sizeof(uint16_t) * max_nodes_per_window_ * CUDAPOA_MAX_NODE_EDGES * poa_count;                                                                 // graph_details_d_->outgoing_edges\n    device_size_per_poa += sizeof(uint16_t) * max_nodes_per_window_ * poa_count;                                                                                          // graph_details_d_->outgoing_edge_count\n    device_size_per_poa += sizeof(uint16_t) * max_nodes_per_window_ * CUDAPOA_MAX_NODE_EDGES * poa_count;                                                                 // graph_details_d_->incoming_edge_weights\n    device_size_per_poa += sizeof(uint16_t) * max_nodes_per_window_ * CUDAPOA_MAX_NODE_EDGES * poa_count;                                                                 // graph_details_d_->outgoing_edge_weights\n    device_size_per_poa += sizeof(uint16_t) * max_nodes_per_window_ * poa_count;                                                                                          // graph_details_d_->sorted_poa\n    device_size_per_poa += sizeof(uint16_t) * max_nodes_per_window_ * poa_count;                                                                                          // graph_details_d_->sorted_poa_node_map\n    device_size_per_poa += sizeof(uint16_t) * max_nodes_per_window_ * poa_count;                                                                                          // graph_details_d_->sorted_poa_local_edge_count\n    device_size_per_poa += (output_mask_ & OutputType::consensus) ? sizeof(int32_t) * max_nodes_per_window_ * poa_count : 0;                                              // graph_details_d_->consensus_scores\n    device_size_per_poa += (output_mask_ & OutputType::consensus) ? sizeof(int16_t) * max_nodes_per_window_ * poa_count : 0;                                              // graph_details_d_->consensus_predecessors\n    device_size_per_poa += sizeof(int8_t) * max_nodes_per_window_ * poa_count;                                                                                            // graph_details_d_->node_marks\n    device_size_per_poa += sizeof(bool) * max_nodes_per_window_ * poa_count;                                                                                              // graph_details_d_->check_aligned_nodes\n    device_size_per_poa += sizeof(uint16_t) * max_nodes_per_window_ * poa_count;                                                                                          // graph_details_d_->nodes_to_visit\n    device_size_per_poa += sizeof(uint16_t) * max_nodes_per_window_ * poa_count;                                                                                          // graph_details_d_->node_coverage_counts\n    device_size_per_poa += (output_mask_ & OutputType::msa) ? sizeof(uint16_t) * max_nodes_per_window_ * CUDAPOA_MAX_NODE_EDGES * max_sequences_per_poa_ * poa_count : 0; // graph_details_d_->outgoing_edges_coverage\n    device_size_per_poa += (output_mask_ & OutputType::msa) ? sizeof(uint16_t) * max_nodes_per_window_ * CUDAPOA_MAX_NODE_EDGES * poa_count : 0;                          // graph_details_d_->outgoing_edges_coverage_count\n    device_size_per_poa += (output_mask_ & OutputType::msa) ? sizeof(int16_t) * max_nodes_per_window_ * poa_count : 0;                                                    // graph_details_d_->node_id_to_msa_pos\n\n    // for alignment - host\n    host_size_fixed += sizeof(AlignmentDetails); // alignment_details_d_\n    // for alignment - device\n    device_size_per_poa += sizeof(int16_t) * max_graph_dimension_ * poa_count; // alignment_details_d_->alignment_graph\n    device_size_per_poa += sizeof(int16_t) * max_graph_dimension_ * poa_count; // alignment_details_d_->alignment_read\n\n    return std::make_tuple(host_size_fixed, device_size_fixed, host_size_per_poa, device_size_per_poa);\n}",
  "abstract_func_before": "std::tuple<size_t, size_t, size_t, size_t> BatchBlock::calculate_space_per_poa()\n{\n    const int32_t VAR_0 = 1;\n\n    size_t VAR_1 = 0, VAR_2 = 0;\n    size_t VAR_3 = 0, VAR_4 = 0;\n\n    size_t VAR_5  = VAR_6 * VAR_7 * VAR_0;\n    size_t VAR_8 = VAR_9 * VAR_0;\n\n    /* COMMENT_0 */\n    VAR_1 += sizeof(VAR_10);                                                                                   /* COMMENT_1 */\n    VAR_3 += VAR_8 * sizeof(uint8_t);                                                                 /* COMMENT_2 */\n    VAR_3 += (VAR_11 & OutputType::consensus) ? VAR_8 * sizeof(uint16_t) : 0;                   /* COMMENT_3 */\n    VAR_3 += (VAR_11 & OutputType::msa) ? VAR_8 * VAR_6 * sizeof(uint8_t) : 0; /* COMMENT_4 */\n    VAR_3 += sizeof(VAR_10);                                                                                 /* COMMENT_5 */\n    /* COMMENT_6 */\n    VAR_4 += VAR_8 * sizeof(uint8_t);                                                                 /* COMMENT_7 */\n    VAR_4 += (VAR_11 & OutputType::consensus) ? VAR_8 * sizeof(uint16_t) : 0;                   /* COMMENT_8 */\n    VAR_4 += (VAR_11 & OutputType::msa) ? VAR_8 * VAR_6 * sizeof(uint8_t) : 0; /* COMMENT_9 */\n\n    /* COMMENT_10 */\n    VAR_1 += sizeof(VAR_12);                                                                           /* COMMENT_11 */\n    VAR_3 += VAR_5 * sizeof(uint8_t);                                                         /* COMMENT_12 */\n    VAR_3 += VAR_5 * sizeof(int8_t);                                                          /* COMMENT_13 */\n    VAR_3 += VAR_0 * VAR_6 * sizeof(uint16_t);                                        /* COMMENT_14 */\n    VAR_3 += VAR_0 * sizeof(VAR_13);                                                            /* COMMENT_15 */\n    VAR_3 += (VAR_11 & OutputType::msa) ? VAR_0 * VAR_6 * sizeof(uint16_t) : 0; /* COMMENT_16 */\n\n    VAR_1 += sizeof(VAR_12); /* COMMENT_17 */\n    /* COMMENT_18 */\n    VAR_4 += VAR_5 * sizeof(uint8_t);                                                         /* COMMENT_19 */\n    VAR_4 += VAR_5 * sizeof(int8_t);                                                          /* COMMENT_20 */\n    VAR_4 += VAR_0 * VAR_6 * sizeof(uint16_t);                                        /* COMMENT_21 */\n    VAR_4 += VAR_0 * sizeof(VAR_13);                                                            /* COMMENT_22 */\n    VAR_4 += (VAR_11 & OutputType::msa) ? VAR_0 * VAR_6 * sizeof(uint16_t) : 0; /* COMMENT_23 */\n\n    /* COMMENT_24 */\n    VAR_1 += sizeof(VAR_14); /* COMMENT_25 */\n    /* COMMENT_26 */\n    VAR_4 += sizeof(uint8_t) * VAR_15 * VAR_0;                                                                                           /* COMMENT_27 */\n    VAR_4 += sizeof(uint16_t) * VAR_15 * VAR_16 * VAR_0;                                                            /* COMMENT_28 */\n    VAR_4 += sizeof(uint16_t) * VAR_15 * VAR_0;                                                                                          /* COMMENT_29 */\n    VAR_4 += sizeof(uint16_t) * VAR_15 * VAR_17 * VAR_0;                                                                 /* COMMENT_30 */\n    VAR_4 += sizeof(uint16_t) * VAR_15 * VAR_0;                                                                                          /* COMMENT_31 */\n    VAR_4 += sizeof(uint16_t) * VAR_15 * VAR_17 * VAR_0;                                                                 /* COMMENT_32 */\n    VAR_4 += sizeof(uint16_t) * VAR_15 * VAR_0;                                                                                          /* COMMENT_33 */\n    VAR_4 += sizeof(uint16_t) * VAR_15 * VAR_17 * VAR_0;                                                                 /* COMMENT_34 */\n    VAR_4 += sizeof(uint16_t) * VAR_15 * VAR_17 * VAR_0;                                                                 /* COMMENT_35 */\n    VAR_4 += sizeof(uint16_t) * VAR_15 * VAR_0;                                                                                          /* COMMENT_36 */\n    VAR_4 += sizeof(uint16_t) * VAR_15 * VAR_0;                                                                                          /* COMMENT_37 */\n    VAR_4 += sizeof(uint16_t) * VAR_15 * VAR_0;                                                                                          /* COMMENT_38 */\n    VAR_4 += (VAR_11 & OutputType::consensus) ? sizeof(int32_t) * VAR_15 * VAR_0 : 0;                                              /* COMMENT_39 */\n    VAR_4 += (VAR_11 & OutputType::consensus) ? sizeof(int16_t) * VAR_15 * VAR_0 : 0;                                              /* COMMENT_40 */\n    VAR_4 += sizeof(int8_t) * VAR_15 * VAR_0;                                                                                            /* COMMENT_41 */\n    VAR_4 += sizeof(bool) * VAR_15 * VAR_0;                                                                                              /* COMMENT_42 */\n    VAR_4 += sizeof(uint16_t) * VAR_15 * VAR_0;                                                                                          /* COMMENT_43 */\n    VAR_4 += sizeof(uint16_t) * VAR_15 * VAR_0;                                                                                          /* COMMENT_44 */\n    VAR_4 += (VAR_11 & OutputType::msa) ? sizeof(uint16_t) * VAR_15 * VAR_17 * VAR_6 * VAR_0 : 0; /* COMMENT_45 */\n    VAR_4 += (VAR_11 & OutputType::msa) ? sizeof(uint16_t) * VAR_15 * VAR_17 * VAR_0 : 0;                          /* COMMENT_46 */\n    VAR_4 += (VAR_11 & OutputType::msa) ? sizeof(int16_t) * VAR_15 * VAR_0 : 0;                                                    /* COMMENT_47 */\n\n    /* COMMENT_48 */\n    VAR_1 += sizeof(VAR_18); /* COMMENT_49 */\n    /* COMMENT_50 */\n    VAR_4 += sizeof(int16_t) * VAR_19 * VAR_0; /* COMMENT_51 */\n    VAR_4 += sizeof(int16_t) * VAR_19 * VAR_0; /* COMMENT_52 */\n\n    return std::make_tuple(VAR_1, VAR_2, VAR_3, VAR_4);\n}",
  "func_graph_path_before": "NVIDIA-Genomics-Research/GenomeWorks/8524f2c0c690ff594a9ebc6d729351b07a1fc5f0/allocate_block.cpp/vul/before/5.json",
  "func": "std::tuple<int64_t, int64_t, int64_t, int64_t> BatchBlock::calculate_space_per_poa()\n{\n    const int32_t poa_count = 1;\n\n    int64_t host_size_fixed = 0, device_size_fixed = 0;\n    int64_t host_size_per_poa = 0, device_size_per_poa = 0;\n\n    int64_t input_size_per_poa  = max_sequences_per_poa_ * CUDAPOA_MAX_SEQUENCE_SIZE * poa_count;\n    int64_t output_size_per_poa = CUDAPOA_MAX_CONSENSUS_SIZE * poa_count;\n\n    // for output - host\n    host_size_fixed += sizeof(OutputDetails);                                                                                   // output_details_h_\n    host_size_per_poa += output_size_per_poa * sizeof(uint8_t);                                                                 // output_details_h_->consensus\n    host_size_per_poa += (output_mask_ & OutputType::consensus) ? output_size_per_poa * sizeof(uint16_t) : 0;                   // output_details_h_->coverage\n    host_size_per_poa += (output_mask_ & OutputType::msa) ? output_size_per_poa * max_sequences_per_poa_ * sizeof(uint8_t) : 0; // output_details_h_->multiple_sequence_alignments\n    host_size_per_poa += sizeof(OutputDetails);                                                                                 // output_details_d_\n    // for output - device\n    device_size_per_poa += output_size_per_poa * sizeof(uint8_t);                                                                 // output_details_d_->consensus\n    device_size_per_poa += (output_mask_ & OutputType::consensus) ? output_size_per_poa * sizeof(uint16_t) : 0;                   // output_details_d_->coverage\n    device_size_per_poa += (output_mask_ & OutputType::msa) ? output_size_per_poa * max_sequences_per_poa_ * sizeof(uint8_t) : 0; // output_details_d_->multiple_sequence_alignments\n\n    // for input - host\n    host_size_fixed += sizeof(InputDetails);                                                                           // input_details_h_\n    host_size_per_poa += input_size_per_poa * sizeof(uint8_t);                                                         // input_details_h_->sequences\n    host_size_per_poa += input_size_per_poa * sizeof(int8_t);                                                          // input_details_h_->base_weights\n    host_size_per_poa += poa_count * max_sequences_per_poa_ * sizeof(uint16_t);                                        // input_details_h_->sequence_lengths\n    host_size_per_poa += poa_count * sizeof(WindowDetails);                                                            // input_details_h_->window_details\n    host_size_per_poa += (output_mask_ & OutputType::msa) ? poa_count * max_sequences_per_poa_ * sizeof(uint16_t) : 0; // input_details_h_->sequence_begin_nodes_ids\n\n    host_size_fixed += sizeof(InputDetails); // input_details_d_\n    // for input - device\n    device_size_per_poa += input_size_per_poa * sizeof(uint8_t);                                                         // input_details_d_->sequences\n    device_size_per_poa += input_size_per_poa * sizeof(int8_t);                                                          // input_details_d_->base_weights\n    device_size_per_poa += poa_count * max_sequences_per_poa_ * sizeof(uint16_t);                                        // input_details_d_->sequence_lengths\n    device_size_per_poa += poa_count * sizeof(WindowDetails);                                                            // input_details_d_->window_details\n    device_size_per_poa += (output_mask_ & OutputType::msa) ? poa_count * max_sequences_per_poa_ * sizeof(uint16_t) : 0; // input_details_d_->sequence_begin_nodes_ids\n\n    // for graph - host\n    host_size_fixed += sizeof(GraphDetails); // graph_details_d_\n    // for graph - device\n    device_size_per_poa += sizeof(uint8_t) * max_nodes_per_window_ * poa_count;                                                                                           // graph_details_d_->nodes\n    device_size_per_poa += sizeof(uint16_t) * max_nodes_per_window_ * CUDAPOA_MAX_NODE_ALIGNMENTS * poa_count;                                                            // graph_details_d_->node_alignments\n    device_size_per_poa += sizeof(uint16_t) * max_nodes_per_window_ * poa_count;                                                                                          // graph_details_d_->node_alignment_count\n    device_size_per_poa += sizeof(uint16_t) * max_nodes_per_window_ * CUDAPOA_MAX_NODE_EDGES * poa_count;                                                                 // graph_details_d_->incoming_edges\n    device_size_per_poa += sizeof(uint16_t) * max_nodes_per_window_ * poa_count;                                                                                          // graph_details_d_->incoming_edge_count\n    device_size_per_poa += sizeof(uint16_t) * max_nodes_per_window_ * CUDAPOA_MAX_NODE_EDGES * poa_count;                                                                 // graph_details_d_->outgoing_edges\n    device_size_per_poa += sizeof(uint16_t) * max_nodes_per_window_ * poa_count;                                                                                          // graph_details_d_->outgoing_edge_count\n    device_size_per_poa += sizeof(uint16_t) * max_nodes_per_window_ * CUDAPOA_MAX_NODE_EDGES * poa_count;                                                                 // graph_details_d_->incoming_edge_weights\n    device_size_per_poa += sizeof(uint16_t) * max_nodes_per_window_ * CUDAPOA_MAX_NODE_EDGES * poa_count;                                                                 // graph_details_d_->outgoing_edge_weights\n    device_size_per_poa += sizeof(uint16_t) * max_nodes_per_window_ * poa_count;                                                                                          // graph_details_d_->sorted_poa\n    device_size_per_poa += sizeof(uint16_t) * max_nodes_per_window_ * poa_count;                                                                                          // graph_details_d_->sorted_poa_node_map\n    device_size_per_poa += sizeof(uint16_t) * max_nodes_per_window_ * poa_count;                                                                                          // graph_details_d_->sorted_poa_local_edge_count\n    device_size_per_poa += (output_mask_ & OutputType::consensus) ? sizeof(int32_t) * max_nodes_per_window_ * poa_count : 0;                                              // graph_details_d_->consensus_scores\n    device_size_per_poa += (output_mask_ & OutputType::consensus) ? sizeof(int16_t) * max_nodes_per_window_ * poa_count : 0;                                              // graph_details_d_->consensus_predecessors\n    device_size_per_poa += sizeof(int8_t) * max_nodes_per_window_ * poa_count;                                                                                            // graph_details_d_->node_marks\n    device_size_per_poa += sizeof(bool) * max_nodes_per_window_ * poa_count;                                                                                              // graph_details_d_->check_aligned_nodes\n    device_size_per_poa += sizeof(uint16_t) * max_nodes_per_window_ * poa_count;                                                                                          // graph_details_d_->nodes_to_visit\n    device_size_per_poa += sizeof(uint16_t) * max_nodes_per_window_ * poa_count;                                                                                          // graph_details_d_->node_coverage_counts\n    device_size_per_poa += (output_mask_ & OutputType::msa) ? sizeof(uint16_t) * max_nodes_per_window_ * CUDAPOA_MAX_NODE_EDGES * max_sequences_per_poa_ * poa_count : 0; // graph_details_d_->outgoing_edges_coverage\n    device_size_per_poa += (output_mask_ & OutputType::msa) ? sizeof(uint16_t) * max_nodes_per_window_ * CUDAPOA_MAX_NODE_EDGES * poa_count : 0;                          // graph_details_d_->outgoing_edges_coverage_count\n    device_size_per_poa += (output_mask_ & OutputType::msa) ? sizeof(int16_t) * max_nodes_per_window_ * poa_count : 0;                                                    // graph_details_d_->node_id_to_msa_pos\n\n    // for alignment - host\n    host_size_fixed += sizeof(AlignmentDetails); // alignment_details_d_\n    // for alignment - device\n    device_size_per_poa += sizeof(int16_t) * max_graph_dimension_ * poa_count; // alignment_details_d_->alignment_graph\n    device_size_per_poa += sizeof(int16_t) * max_graph_dimension_ * poa_count; // alignment_details_d_->alignment_read\n\n    return std::make_tuple(host_size_fixed, device_size_fixed, host_size_per_poa, device_size_per_poa);\n}",
  "abstract_func": "std::tuple<int64_t, int64_t, int64_t, int64_t> BatchBlock::calculate_space_per_poa()\n{\n    const int32_t VAR_0 = 1;\n\n    int64_t VAR_1 = 0, VAR_2 = 0;\n    int64_t VAR_3 = 0, VAR_4 = 0;\n\n    int64_t VAR_5  = VAR_6 * VAR_7 * VAR_0;\n    int64_t VAR_8 = VAR_9 * VAR_0;\n\n    /* COMMENT_0 */\n    VAR_1 += sizeof(VAR_10);                                                                                   /* COMMENT_1 */\n    VAR_3 += VAR_8 * sizeof(uint8_t);                                                                 /* COMMENT_2 */\n    VAR_3 += (VAR_11 & OutputType::consensus) ? VAR_8 * sizeof(uint16_t) : 0;                   /* COMMENT_3 */\n    VAR_3 += (VAR_11 & OutputType::msa) ? VAR_8 * VAR_6 * sizeof(uint8_t) : 0; /* COMMENT_4 */\n    VAR_3 += sizeof(VAR_10);                                                                                 /* COMMENT_5 */\n    /* COMMENT_6 */\n    VAR_4 += VAR_8 * sizeof(uint8_t);                                                                 /* COMMENT_7 */\n    VAR_4 += (VAR_11 & OutputType::consensus) ? VAR_8 * sizeof(uint16_t) : 0;                   /* COMMENT_8 */\n    VAR_4 += (VAR_11 & OutputType::msa) ? VAR_8 * VAR_6 * sizeof(uint8_t) : 0; /* COMMENT_9 */\n\n    /* COMMENT_10 */\n    VAR_1 += sizeof(VAR_12);                                                                           /* COMMENT_11 */\n    VAR_3 += VAR_5 * sizeof(uint8_t);                                                         /* COMMENT_12 */\n    VAR_3 += VAR_5 * sizeof(int8_t);                                                          /* COMMENT_13 */\n    VAR_3 += VAR_0 * VAR_6 * sizeof(uint16_t);                                        /* COMMENT_14 */\n    VAR_3 += VAR_0 * sizeof(VAR_13);                                                            /* COMMENT_15 */\n    VAR_3 += (VAR_11 & OutputType::msa) ? VAR_0 * VAR_6 * sizeof(uint16_t) : 0; /* COMMENT_16 */\n\n    VAR_1 += sizeof(VAR_12); /* COMMENT_17 */\n    /* COMMENT_18 */\n    VAR_4 += VAR_5 * sizeof(uint8_t);                                                         /* COMMENT_19 */\n    VAR_4 += VAR_5 * sizeof(int8_t);                                                          /* COMMENT_20 */\n    VAR_4 += VAR_0 * VAR_6 * sizeof(uint16_t);                                        /* COMMENT_21 */\n    VAR_4 += VAR_0 * sizeof(VAR_13);                                                            /* COMMENT_22 */\n    VAR_4 += (VAR_11 & OutputType::msa) ? VAR_0 * VAR_6 * sizeof(uint16_t) : 0; /* COMMENT_23 */\n\n    /* COMMENT_24 */\n    VAR_1 += sizeof(VAR_14); /* COMMENT_25 */\n    /* COMMENT_26 */\n    VAR_4 += sizeof(uint8_t) * VAR_15 * VAR_0;                                                                                           /* COMMENT_27 */\n    VAR_4 += sizeof(uint16_t) * VAR_15 * VAR_16 * VAR_0;                                                            /* COMMENT_28 */\n    VAR_4 += sizeof(uint16_t) * VAR_15 * VAR_0;                                                                                          /* COMMENT_29 */\n    VAR_4 += sizeof(uint16_t) * VAR_15 * VAR_17 * VAR_0;                                                                 /* COMMENT_30 */\n    VAR_4 += sizeof(uint16_t) * VAR_15 * VAR_0;                                                                                          /* COMMENT_31 */\n    VAR_4 += sizeof(uint16_t) * VAR_15 * VAR_17 * VAR_0;                                                                 /* COMMENT_32 */\n    VAR_4 += sizeof(uint16_t) * VAR_15 * VAR_0;                                                                                          /* COMMENT_33 */\n    VAR_4 += sizeof(uint16_t) * VAR_15 * VAR_17 * VAR_0;                                                                 /* COMMENT_34 */\n    VAR_4 += sizeof(uint16_t) * VAR_15 * VAR_17 * VAR_0;                                                                 /* COMMENT_35 */\n    VAR_4 += sizeof(uint16_t) * VAR_15 * VAR_0;                                                                                          /* COMMENT_36 */\n    VAR_4 += sizeof(uint16_t) * VAR_15 * VAR_0;                                                                                          /* COMMENT_37 */\n    VAR_4 += sizeof(uint16_t) * VAR_15 * VAR_0;                                                                                          /* COMMENT_38 */\n    VAR_4 += (VAR_11 & OutputType::consensus) ? sizeof(int32_t) * VAR_15 * VAR_0 : 0;                                              /* COMMENT_39 */\n    VAR_4 += (VAR_11 & OutputType::consensus) ? sizeof(int16_t) * VAR_15 * VAR_0 : 0;                                              /* COMMENT_40 */\n    VAR_4 += sizeof(int8_t) * VAR_15 * VAR_0;                                                                                            /* COMMENT_41 */\n    VAR_4 += sizeof(bool) * VAR_15 * VAR_0;                                                                                              /* COMMENT_42 */\n    VAR_4 += sizeof(uint16_t) * VAR_15 * VAR_0;                                                                                          /* COMMENT_43 */\n    VAR_4 += sizeof(uint16_t) * VAR_15 * VAR_0;                                                                                          /* COMMENT_44 */\n    VAR_4 += (VAR_11 & OutputType::msa) ? sizeof(uint16_t) * VAR_15 * VAR_17 * VAR_6 * VAR_0 : 0; /* COMMENT_45 */\n    VAR_4 += (VAR_11 & OutputType::msa) ? sizeof(uint16_t) * VAR_15 * VAR_17 * VAR_0 : 0;                          /* COMMENT_46 */\n    VAR_4 += (VAR_11 & OutputType::msa) ? sizeof(int16_t) * VAR_15 * VAR_0 : 0;                                                    /* COMMENT_47 */\n\n    /* COMMENT_48 */\n    VAR_1 += sizeof(VAR_18); /* COMMENT_49 */\n    /* COMMENT_50 */\n    VAR_4 += sizeof(int16_t) * VAR_19 * VAR_0; /* COMMENT_51 */\n    VAR_4 += sizeof(int16_t) * VAR_19 * VAR_0; /* COMMENT_52 */\n\n    return std::make_tuple(VAR_1, VAR_2, VAR_3, VAR_4);\n}",
  "func_graph_path": "NVIDIA-Genomics-Research/GenomeWorks/8524f2c0c690ff594a9ebc6d729351b07a1fc5f0/allocate_block.cpp/vul/after/5.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,12 +1,12 @@\n-std::tuple<size_t, size_t, size_t, size_t> BatchBlock::calculate_space_per_poa()\n+std::tuple<int64_t, int64_t, int64_t, int64_t> BatchBlock::calculate_space_per_poa()\n {\n     const int32_t poa_count = 1;\n \n-    size_t host_size_fixed = 0, device_size_fixed = 0;\n-    size_t host_size_per_poa = 0, device_size_per_poa = 0;\n+    int64_t host_size_fixed = 0, device_size_fixed = 0;\n+    int64_t host_size_per_poa = 0, device_size_per_poa = 0;\n \n-    size_t input_size_per_poa  = max_sequences_per_poa_ * CUDAPOA_MAX_SEQUENCE_SIZE * poa_count;\n-    size_t output_size_per_poa = CUDAPOA_MAX_CONSENSUS_SIZE * poa_count;\n+    int64_t input_size_per_poa  = max_sequences_per_poa_ * CUDAPOA_MAX_SEQUENCE_SIZE * poa_count;\n+    int64_t output_size_per_poa = CUDAPOA_MAX_CONSENSUS_SIZE * poa_count;\n \n     // for output - host\n     host_size_fixed += sizeof(OutputDetails);                                                                                   // output_details_h_",
  "diff_line_info": {
    "deleted_lines": [
      "std::tuple<size_t, size_t, size_t, size_t> BatchBlock::calculate_space_per_poa()",
      "    size_t host_size_fixed = 0, device_size_fixed = 0;",
      "    size_t host_size_per_poa = 0, device_size_per_poa = 0;",
      "    size_t input_size_per_poa  = max_sequences_per_poa_ * CUDAPOA_MAX_SEQUENCE_SIZE * poa_count;",
      "    size_t output_size_per_poa = CUDAPOA_MAX_CONSENSUS_SIZE * poa_count;"
    ],
    "added_lines": [
      "std::tuple<int64_t, int64_t, int64_t, int64_t> BatchBlock::calculate_space_per_poa()",
      "    int64_t host_size_fixed = 0, device_size_fixed = 0;",
      "    int64_t host_size_per_poa = 0, device_size_per_poa = 0;",
      "    int64_t input_size_per_poa  = max_sequences_per_poa_ * CUDAPOA_MAX_SEQUENCE_SIZE * poa_count;",
      "    int64_t output_size_per_poa = CUDAPOA_MAX_CONSENSUS_SIZE * poa_count;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/NVIDIA-Genomics-Research/GenomeWorks/pull/70",
  "description": {
    "pr_info": {
      "title": "[cudapoa] fix integer overflow",
      "number": 70
    },
    "comment": [
      "1. Re-enable disabled cudapoa python test\r\n2. Fix integer overflow issue in cudapoa memory management"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix\nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\nThe patch addresses an integer overflow issue in memory management, which is a security concern. The code changes from size_t to int64_t prevent overflow, a known security vulnerability.\n\n**Final Output:**\nAnalysis: The patch changes data types from size_t to int64_t to fix an integer overflow issue in memory management, indicating a security vulnerability fix.\nFinal Classification: Security Vulnerability Fix\nConfidence Score: 0.95"
}