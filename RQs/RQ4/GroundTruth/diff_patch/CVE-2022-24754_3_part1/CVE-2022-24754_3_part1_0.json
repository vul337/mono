{
  "cve_id": "CVE-2022-24754",
  "cwe_ids": [
    "CWE-120"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "pjsip/pjproject",
  "commit_msg": "Use PJ_ASSERT_RETURN() on pjsip_auth_create_digest() and pjsua_init_tpselector() (#3009)\n\n* Use PJ_ASSERT_RETURN on pjsip_auth_create_digest\r\n\r\n* Use PJ_ASSERT_RETURN on pjsua_init_tpselector()\r\n\r\n* Fix incorrect check.\r\n\r\n* Add return value to pjsip_auth_create_digest() and pjsip_auth_create_digestSHA256()\r\n\r\n* Modification based on comments.",
  "commit_hash": "d27f79da11df7bc8bb56c2f291d71e54df8d2c47",
  "git_url": "https://github.com/pjsip/pjproject/commit/d27f79da11df7bc8bb56c2f291d71e54df8d2c47",
  "file_path": "pjsip/src/pjsip/sip_auth_client.c",
  "func_name": "pjsip_auth_create_digestSHA256",
  "func_before": "PJ_DEF(void) pjsip_auth_create_digestSHA256(pj_str_t *result,\n\t\t\t\t\t    const pj_str_t *nonce,\n\t\t\t\t\t    const pj_str_t *nc,\n\t\t\t\t\t    const pj_str_t *cnonce,\n\t\t\t\t\t    const pj_str_t *qop,\n\t\t\t\t\t    const pj_str_t *uri,\n\t\t\t\t\t    const pj_str_t *realm,\n\t\t\t\t\t    const pjsip_cred_info *cred_info,\n\t\t\t\t\t    const pj_str_t *method)\n{\n#if PJSIP_AUTH_HAS_DIGEST_SHA256\n\n    char ha1[PJSIP_SHA256STRLEN];\n    char ha2[PJSIP_SHA256STRLEN];\n    unsigned char digest[32];\n    SHA256_CTX pms;\n\n    pj_assert(result->slen >= PJSIP_SHA256STRLEN);\n\n    AUTH_TRACE_((THIS_FILE, \"Begin creating digest\"));\n\n    if ((cred_info->data_type & PASSWD_MASK) == PJSIP_CRED_DATA_PLAIN_PASSWD)\n    {\n\t/***\n\t *** ha1 = SHA256(username \":\" realm \":\" password)\n\t ***/\n\tSHA256_Init(&pms);\n\tSHA256_Update( &pms, cred_info->username.ptr,\n\t\t       cred_info->username.slen);\n\tSHA256_Update( &pms, \":\", 1);\n\tSHA256_Update( &pms, realm->ptr, realm->slen);\n\tSHA256_Update( &pms, \":\", 1);\n\tSHA256_Update( &pms, cred_info->data.ptr, cred_info->data.slen);\n\tSHA256_Final(digest, &pms);\n\n\tdigestNtoStr(digest, 32, ha1);\n\n    } else if ((cred_info->data_type & PASSWD_MASK) == PJSIP_CRED_DATA_DIGEST)\n    {\n\tpj_assert(cred_info->data.slen == 32);\n\tpj_memcpy( ha1, cred_info->data.ptr, cred_info->data.slen );\n    } else {\n\tpj_assert(!\"Invalid data_type\");\n    }\n\n    AUTH_TRACE_((THIS_FILE, \" ha1=%.64s\", ha1));\n\n    /***\n     *** ha2 = SHA256(method \":\" req_uri)\n     ***/\n    SHA256_Init(&pms);\n    SHA256_Update( &pms, method->ptr, method->slen);\n    SHA256_Update( &pms, \":\", 1);\n    SHA256_Update( &pms, uri->ptr, uri->slen);\n    SHA256_Final( digest, &pms);\n    digestNtoStr(digest, 32, ha2);\n\n    AUTH_TRACE_((THIS_FILE, \" ha2=%.64s\", ha2));\n\n    /***\n     *** When qop is not used:\n     ***   response = SHA256(ha1 \":\" nonce \":\" ha2)\n     ***\n     *** When qop=auth is used:\n     ***   response = SHA256(ha1 \":\" nonce \":\" nc \":\" cnonce \":\" qop \":\" ha2)\n     ***/\n    SHA256_Init(&pms);\n    SHA256_Update( &pms, ha1, PJSIP_SHA256STRLEN);\n    SHA256_Update( &pms, \":\", 1);\n    SHA256_Update( &pms, nonce->ptr, nonce->slen);\n    if (qop && qop->slen != 0) {\n\tSHA256_Update( &pms, \":\", 1);\n\tSHA256_Update( &pms, nc->ptr, nc->slen);\n\tSHA256_Update( &pms, \":\", 1);\n\tSHA256_Update( &pms, cnonce->ptr, cnonce->slen);\n\tSHA256_Update( &pms, \":\", 1);\n\tSHA256_Update( &pms, qop->ptr, qop->slen);\n    }\n    SHA256_Update( &pms, \":\", 1);\n    SHA256_Update( &pms, ha2, PJSIP_SHA256STRLEN);\n\n    /* This is the final response digest. */\n    SHA256_Final(digest, &pms);\n\n    /* Convert digest to string and store in chal->response. */\n    result->slen = PJSIP_SHA256STRLEN;\n    digestNtoStr(digest, 32, result->ptr);\n\n    AUTH_TRACE_((THIS_FILE, \" digest=%.64s\", result->ptr));\n    AUTH_TRACE_((THIS_FILE, \"Digest created\"));\n\n#else\n    PJ_UNUSED_ARG(result);\n    PJ_UNUSED_ARG(nonce);\n    PJ_UNUSED_ARG(nc);\n    PJ_UNUSED_ARG(cnonce);\n    PJ_UNUSED_ARG(qop);\n    PJ_UNUSED_ARG(uri);\n    PJ_UNUSED_ARG(realm);\n    PJ_UNUSED_ARG(cred_info);\n    PJ_UNUSED_ARG(method);\n#endif\n}",
  "abstract_func_before": "VAR_0(void) pjsip_auth_create_digestSHA256(pj_str_t *VAR_1,\n\t\t\t\t\t    const pj_str_t *VAR_2,\n\t\t\t\t\t    const pj_str_t *VAR_3,\n\t\t\t\t\t    const pj_str_t *VAR_4,\n\t\t\t\t\t    const pj_str_t *VAR_5,\n\t\t\t\t\t    const pj_str_t *VAR_6,\n\t\t\t\t\t    const pj_str_t *VAR_7,\n\t\t\t\t\t    const pjsip_cred_info *VAR_8,\n\t\t\t\t\t    const pj_str_t *VAR_9)\n{\n#if VAR_10\n\n    char VAR_11[VAR_12];\n    char VAR_13[VAR_12];\n    unsigned char VAR_14[32];\n    SHA256_CTX VAR_15;\n\n    pj_assert(VAR_1->slen >= VAR_12);\n\n    AUTH_TRACE_((VAR_16, \"Begin creating digest\"));\n\n    if ((VAR_8->data_type & VAR_17) == VAR_18)\n    {\n\t/* COMMENT_0 */\n                                                   \n      \n\tSHA256_Init(&VAR_15);\n\tSHA256_Update( &VAR_15, VAR_8->username.ptr,\n\t\t       VAR_8->username.slen);\n\tSHA256_Update( &VAR_15, \":\", 1);\n\tSHA256_Update( &VAR_15, VAR_7->ptr, VAR_7->slen);\n\tSHA256_Update( &VAR_15, \":\", 1);\n\tSHA256_Update( &VAR_15, VAR_8->data.ptr, VAR_8->data.slen);\n\tSHA256_Final(VAR_14, &VAR_15);\n\n\tdigestNtoStr(VAR_14, 32, VAR_11);\n\n    } else if ((VAR_8->data_type & VAR_17) == VAR_19)\n    {\n\tpj_assert(VAR_8->data.slen == 32);\n\tpj_memcpy( VAR_11, VAR_8->data.ptr, VAR_8->data.slen );\n    } else {\n\tpj_assert(!\"Invalid data_type\");\n    }\n\n    AUTH_TRACE_((VAR_16, \" ha1=%.64s\", VAR_11));\n\n    /* COMMENT_3 */\n                                         \n         \n    SHA256_Init(&VAR_15);\n    SHA256_Update( &VAR_15, VAR_9->ptr, VAR_9->slen);\n    SHA256_Update( &VAR_15, \":\", 1);\n    SHA256_Update( &VAR_15, VAR_6->ptr, VAR_6->slen);\n    SHA256_Final( VAR_14, &VAR_15);\n    digestNtoStr(VAR_14, 32, VAR_13);\n\n    AUTH_TRACE_((VAR_16, \" ha2=%.64s\", VAR_13));\n\n    /* COMMENT_6 */\n                              \n                                                   \n        \n                               \n                                                                             \n         \n    SHA256_Init(&VAR_15);\n    SHA256_Update( &VAR_15, VAR_11, VAR_12);\n    SHA256_Update( &VAR_15, \":\", 1);\n    SHA256_Update( &VAR_15, VAR_2->ptr, VAR_2->slen);\n    if (VAR_5 && VAR_5->slen != 0) {\n\tSHA256_Update( &VAR_15, \":\", 1);\n\tSHA256_Update( &VAR_15, VAR_3->ptr, VAR_3->slen);\n\tSHA256_Update( &VAR_15, \":\", 1);\n\tSHA256_Update( &VAR_15, VAR_4->ptr, VAR_4->slen);\n\tSHA256_Update( &VAR_15, \":\", 1);\n\tSHA256_Update( &VAR_15, VAR_5->ptr, VAR_5->slen);\n    }\n    SHA256_Update( &VAR_15, \":\", 1);\n    SHA256_Update( &VAR_15, VAR_13, VAR_12);\n\n    /* COMMENT_13 */\n    SHA256_Final(VAR_14, &VAR_15);\n\n    /* COMMENT_14 */\n    VAR_1->slen = VAR_12;\n    digestNtoStr(VAR_14, 32, VAR_1->ptr);\n\n    AUTH_TRACE_((VAR_16, \" digest=%.64s\", VAR_1->ptr));\n    AUTH_TRACE_((VAR_16, \"Digest created\"));\n\n#else\n    PJ_UNUSED_ARG(VAR_1);\n    PJ_UNUSED_ARG(VAR_2);\n    PJ_UNUSED_ARG(VAR_3);\n    PJ_UNUSED_ARG(VAR_4);\n    PJ_UNUSED_ARG(VAR_5);\n    PJ_UNUSED_ARG(VAR_6);\n    PJ_UNUSED_ARG(VAR_7);\n    PJ_UNUSED_ARG(VAR_8);\n    PJ_UNUSED_ARG(VAR_9);\n#endif\n}",
  "func_graph_path_before": null,
  "func": "PJ_DEF(pj_status_t) pjsip_auth_create_digestSHA256(pj_str_t *result,\n\t\t\t\t\t    const pj_str_t *nonce,\n\t\t\t\t\t    const pj_str_t *nc,\n\t\t\t\t\t    const pj_str_t *cnonce,\n\t\t\t\t\t    const pj_str_t *qop,\n\t\t\t\t\t    const pj_str_t *uri,\n\t\t\t\t\t    const pj_str_t *realm,\n\t\t\t\t\t    const pjsip_cred_info *cred_info,\n\t\t\t\t\t    const pj_str_t *method)\n{\n#if PJSIP_AUTH_HAS_DIGEST_SHA256\n\n    char ha1[PJSIP_SHA256STRLEN];\n    char ha2[PJSIP_SHA256STRLEN];\n    unsigned char digest[32];\n    SHA256_CTX pms;\n\n    pj_assert(result->slen >= PJSIP_SHA256STRLEN);\n\n    AUTH_TRACE_((THIS_FILE, \"Begin creating digest\"));\n\n    if ((cred_info->data_type & PASSWD_MASK) == PJSIP_CRED_DATA_PLAIN_PASSWD)\n    {\n\t/***\n\t *** ha1 = SHA256(username \":\" realm \":\" password)\n\t ***/\n\tSHA256_Init(&pms);\n\tSHA256_Update( &pms, cred_info->username.ptr,\n\t\t       cred_info->username.slen);\n\tSHA256_Update( &pms, \":\", 1);\n\tSHA256_Update( &pms, realm->ptr, realm->slen);\n\tSHA256_Update( &pms, \":\", 1);\n\tSHA256_Update( &pms, cred_info->data.ptr, cred_info->data.slen);\n\tSHA256_Final(digest, &pms);\n\n\tdigestNtoStr(digest, 32, ha1);\n\n    } else if ((cred_info->data_type & PASSWD_MASK) == PJSIP_CRED_DATA_DIGEST)\n    {\n\tif (cred_info->data.slen != 64) {\n\t    pj_assert(!\"Invalid cred_info data length\");\n\t    pj_bzero(result->ptr, result->slen);\n\t    result->slen = 0;\n\t    return PJ_EINVAL;\n\t}\n\tpj_memcpy( ha1, cred_info->data.ptr, cred_info->data.slen );\n    } else {\n\tpj_assert(!\"Invalid data_type\");\n\tpj_bzero(result->ptr, result->slen);\n\tresult->slen = 0;\n\treturn PJ_EINVAL;\n    }\n\n    AUTH_TRACE_((THIS_FILE, \" ha1=%.64s\", ha1));\n\n    /***\n     *** ha2 = SHA256(method \":\" req_uri)\n     ***/\n    SHA256_Init(&pms);\n    SHA256_Update( &pms, method->ptr, method->slen);\n    SHA256_Update( &pms, \":\", 1);\n    SHA256_Update( &pms, uri->ptr, uri->slen);\n    SHA256_Final( digest, &pms);\n    digestNtoStr(digest, 32, ha2);\n\n    AUTH_TRACE_((THIS_FILE, \" ha2=%.64s\", ha2));\n\n    /***\n     *** When qop is not used:\n     ***   response = SHA256(ha1 \":\" nonce \":\" ha2)\n     ***\n     *** When qop=auth is used:\n     ***   response = SHA256(ha1 \":\" nonce \":\" nc \":\" cnonce \":\" qop \":\" ha2)\n     ***/\n    SHA256_Init(&pms);\n    SHA256_Update( &pms, ha1, PJSIP_SHA256STRLEN);\n    SHA256_Update( &pms, \":\", 1);\n    SHA256_Update( &pms, nonce->ptr, nonce->slen);\n    if (qop && qop->slen != 0) {\n\tSHA256_Update( &pms, \":\", 1);\n\tSHA256_Update( &pms, nc->ptr, nc->slen);\n\tSHA256_Update( &pms, \":\", 1);\n\tSHA256_Update( &pms, cnonce->ptr, cnonce->slen);\n\tSHA256_Update( &pms, \":\", 1);\n\tSHA256_Update( &pms, qop->ptr, qop->slen);\n    }\n    SHA256_Update( &pms, \":\", 1);\n    SHA256_Update( &pms, ha2, PJSIP_SHA256STRLEN);\n\n    /* This is the final response digest. */\n    SHA256_Final(digest, &pms);\n\n    /* Convert digest to string and store in chal->response. */\n    result->slen = PJSIP_SHA256STRLEN;\n    digestNtoStr(digest, 32, result->ptr);\n\n    AUTH_TRACE_((THIS_FILE, \" digest=%.64s\", result->ptr));\n    AUTH_TRACE_((THIS_FILE, \"Digest created\"));\n\n#else\n    PJ_UNUSED_ARG(result);\n    PJ_UNUSED_ARG(nonce);\n    PJ_UNUSED_ARG(nc);\n    PJ_UNUSED_ARG(cnonce);\n    PJ_UNUSED_ARG(qop);\n    PJ_UNUSED_ARG(uri);\n    PJ_UNUSED_ARG(realm);\n    PJ_UNUSED_ARG(cred_info);\n    PJ_UNUSED_ARG(method);\n#endif\n    return PJ_SUCCESS;\n}",
  "abstract_func": "VAR_0(pj_status_t) pjsip_auth_create_digestSHA256(pj_str_t *VAR_1,\n\t\t\t\t\t    const pj_str_t *VAR_2,\n\t\t\t\t\t    const pj_str_t *VAR_3,\n\t\t\t\t\t    const pj_str_t *VAR_4,\n\t\t\t\t\t    const pj_str_t *VAR_5,\n\t\t\t\t\t    const pj_str_t *VAR_6,\n\t\t\t\t\t    const pj_str_t *VAR_7,\n\t\t\t\t\t    const pjsip_cred_info *VAR_8,\n\t\t\t\t\t    const pj_str_t *VAR_9)\n{\n#if VAR_10\n\n    char VAR_11[VAR_12];\n    char VAR_13[VAR_12];\n    unsigned char VAR_14[32];\n    SHA256_CTX VAR_15;\n\n    pj_assert(VAR_1->slen >= VAR_12);\n\n    AUTH_TRACE_((VAR_16, \"Begin creating digest\"));\n\n    if ((VAR_8->data_type & VAR_17) == VAR_18)\n    {\n\t/* COMMENT_0 */\n                                                   \n      \n\tSHA256_Init(&VAR_15);\n\tSHA256_Update( &VAR_15, VAR_8->username.ptr,\n\t\t       VAR_8->username.slen);\n\tSHA256_Update( &VAR_15, \":\", 1);\n\tSHA256_Update( &VAR_15, VAR_7->ptr, VAR_7->slen);\n\tSHA256_Update( &VAR_15, \":\", 1);\n\tSHA256_Update( &VAR_15, VAR_8->data.ptr, VAR_8->data.slen);\n\tSHA256_Final(VAR_14, &VAR_15);\n\n\tdigestNtoStr(VAR_14, 32, VAR_11);\n\n    } else if ((VAR_8->data_type & VAR_17) == VAR_19)\n    {\n\tif (VAR_8->data.slen != 64) {\n\t    pj_assert(!\"Invalid cred_info data length\");\n\t    pj_bzero(VAR_1->ptr, VAR_1->slen);\n\t    VAR_1->slen = 0;\n\t    return VAR_20;\n\t}\n\tpj_memcpy( VAR_11, VAR_8->data.ptr, VAR_8->data.slen );\n    } else {\n\tpj_assert(!\"Invalid data_type\");\n\tpj_bzero(VAR_1->ptr, VAR_1->slen);\n\tVAR_1->slen = 0;\n\treturn VAR_20;\n    }\n\n    AUTH_TRACE_((VAR_16, \" ha1=%.64s\", VAR_11));\n\n    /* COMMENT_3 */\n                                         \n         \n    SHA256_Init(&VAR_15);\n    SHA256_Update( &VAR_15, VAR_9->ptr, VAR_9->slen);\n    SHA256_Update( &VAR_15, \":\", 1);\n    SHA256_Update( &VAR_15, VAR_6->ptr, VAR_6->slen);\n    SHA256_Final( VAR_14, &VAR_15);\n    digestNtoStr(VAR_14, 32, VAR_13);\n\n    AUTH_TRACE_((VAR_16, \" ha2=%.64s\", VAR_13));\n\n    /* COMMENT_6 */\n                              \n                                                   \n        \n                               \n                                                                             \n         \n    SHA256_Init(&VAR_15);\n    SHA256_Update( &VAR_15, VAR_11, VAR_12);\n    SHA256_Update( &VAR_15, \":\", 1);\n    SHA256_Update( &VAR_15, VAR_2->ptr, VAR_2->slen);\n    if (VAR_5 && VAR_5->slen != 0) {\n\tSHA256_Update( &VAR_15, \":\", 1);\n\tSHA256_Update( &VAR_15, VAR_3->ptr, VAR_3->slen);\n\tSHA256_Update( &VAR_15, \":\", 1);\n\tSHA256_Update( &VAR_15, VAR_4->ptr, VAR_4->slen);\n\tSHA256_Update( &VAR_15, \":\", 1);\n\tSHA256_Update( &VAR_15, VAR_5->ptr, VAR_5->slen);\n    }\n    SHA256_Update( &VAR_15, \":\", 1);\n    SHA256_Update( &VAR_15, VAR_13, VAR_12);\n\n    /* COMMENT_13 */\n    SHA256_Final(VAR_14, &VAR_15);\n\n    /* COMMENT_14 */\n    VAR_1->slen = VAR_12;\n    digestNtoStr(VAR_14, 32, VAR_1->ptr);\n\n    AUTH_TRACE_((VAR_16, \" digest=%.64s\", VAR_1->ptr));\n    AUTH_TRACE_((VAR_16, \"Digest created\"));\n\n#else\n    PJ_UNUSED_ARG(VAR_1);\n    PJ_UNUSED_ARG(VAR_2);\n    PJ_UNUSED_ARG(VAR_3);\n    PJ_UNUSED_ARG(VAR_4);\n    PJ_UNUSED_ARG(VAR_5);\n    PJ_UNUSED_ARG(VAR_6);\n    PJ_UNUSED_ARG(VAR_7);\n    PJ_UNUSED_ARG(VAR_8);\n    PJ_UNUSED_ARG(VAR_9);\n#endif\n    return VAR_21;\n}",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-PJ_DEF(void) pjsip_auth_create_digestSHA256(pj_str_t *result,\n+PJ_DEF(pj_status_t) pjsip_auth_create_digestSHA256(pj_str_t *result,\n \t\t\t\t\t    const pj_str_t *nonce,\n \t\t\t\t\t    const pj_str_t *nc,\n \t\t\t\t\t    const pj_str_t *cnonce,\n@@ -37,10 +37,18 @@\n \n     } else if ((cred_info->data_type & PASSWD_MASK) == PJSIP_CRED_DATA_DIGEST)\n     {\n-\tpj_assert(cred_info->data.slen == 32);\n+\tif (cred_info->data.slen != 64) {\n+\t    pj_assert(!\"Invalid cred_info data length\");\n+\t    pj_bzero(result->ptr, result->slen);\n+\t    result->slen = 0;\n+\t    return PJ_EINVAL;\n+\t}\n \tpj_memcpy( ha1, cred_info->data.ptr, cred_info->data.slen );\n     } else {\n \tpj_assert(!\"Invalid data_type\");\n+\tpj_bzero(result->ptr, result->slen);\n+\tresult->slen = 0;\n+\treturn PJ_EINVAL;\n     }\n \n     AUTH_TRACE_((THIS_FILE, \" ha1=%.64s\", ha1));\n@@ -100,4 +108,5 @@\n     PJ_UNUSED_ARG(cred_info);\n     PJ_UNUSED_ARG(method);\n #endif\n+    return PJ_SUCCESS;\n }",
  "diff_line_info": {
    "deleted_lines": [
      "PJ_DEF(void) pjsip_auth_create_digestSHA256(pj_str_t *result,",
      "\tpj_assert(cred_info->data.slen == 32);"
    ],
    "added_lines": [
      "PJ_DEF(pj_status_t) pjsip_auth_create_digestSHA256(pj_str_t *result,",
      "\tif (cred_info->data.slen != 64) {",
      "\t    pj_assert(!\"Invalid cred_info data length\");",
      "\t    pj_bzero(result->ptr, result->slen);",
      "\t    result->slen = 0;",
      "\t    return PJ_EINVAL;",
      "\t}",
      "\tpj_bzero(result->ptr, result->slen);",
      "\tresult->slen = 0;",
      "\treturn PJ_EINVAL;",
      "    return PJ_SUCCESS;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/pjsip/pjproject/pull/3009",
  "description": {
    "pr_info": {
      "title": "Check potential buffer overflow in `pjsip_auth_create_digest()`",
      "number": 3009
    },
    "comment": [
      "Related commit of https://github.com/pjsip/pjproject/commit/d27f79da11df7bc8bb56c2f291d71e54df8d2c47 of [GHSA-73f7-48m9-w662](https://github.com/pjsip/pjproject/security/advisories/GHSA-73f7-48m9-w662) : fix potential buffer overflow in `pjsip_auth_create_digest()`",
      "I'm having a hard time figuring out whether `pjsip_auth_create_digest` is part of the public API and therefore whether applying this patch would be API/ABI-breaking."
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "\n\n**Final Output:**\nAnalysis: The patch modifies error handling in the function pjsip_auth_create_digestSHA256 by replacing assertions with proper error returns, improving robustness but not addressing a security exploit.\n\nFinal Classification: Defect Remediation & Feature Upgrades  \nConfidence Score: 0.9"
}