{
  "cve_id": "CVE-2018-20750",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "LibVNC/libvncserver",
  "commit_msg": "Limit lenght to INT_MAX bytes in rfbProcessFileTransferReadBuffer()\n\nThis ammends 15bb719c03cc70f14c36a843dcb16ed69b405707 fix for a heap\nout-of-bound write access in rfbProcessFileTransferReadBuffer() when\nreading a transfered file content in a server. The former fix did not\nwork on platforms with a 32-bit int type (expected by rfbReadExact()).\n\nCVE-2018-15127\n<https://github.com/LibVNC/libvncserver/issues/243>\n<https://github.com/LibVNC/libvncserver/issues/273>",
  "commit_hash": "09e8fc02f59f16e2583b34fe1a270c238bd9ffec",
  "git_url": "https://github.com/LibVNC/libvncserver/commit/09e8fc02f59f16e2583b34fe1a270c238bd9ffec",
  "file_path": "libvncserver/rfbserver.c",
  "func_name": "rfbProcessFileTransferReadBuffer",
  "func_before": "char *rfbProcessFileTransferReadBuffer(rfbClientPtr cl, uint32_t length)\n{\n    char *buffer=NULL;\n    int   n=0;\n\n    FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN(\"\", cl, NULL);\n\n    /*\n       We later alloc length+1, which might wrap around on 32-bit systems if length equals\n       0XFFFFFFFF, i.e. SIZE_MAX for 32-bit systems. On 64-bit systems, a length of 0XFFFFFFFF\n       will safely be allocated since this check will never trigger and malloc() can digest length+1\n       without problems as length is a uint32_t.\n    */\n    if(length == SIZE_MAX) {\n\trfbErr(\"rfbProcessFileTransferReadBuffer: too big file transfer length requested: %u\", (unsigned int)length);\n\trfbCloseClient(cl);\n\treturn NULL;\n    }\n\n    if (length>0) {\n        buffer=malloc((size_t)length+1);\n        if (buffer!=NULL) {\n            if ((n = rfbReadExact(cl, (char *)buffer, length)) <= 0) {\n                if (n != 0)\n                    rfbLogPerror(\"rfbProcessFileTransferReadBuffer: read\");\n                rfbCloseClient(cl);\n                /* NOTE: don't forget to free(buffer) if you return early! */\n                if (buffer!=NULL) free(buffer);\n                return NULL;\n            }\n            /* Null Terminate */\n            buffer[length]=0;\n        }\n    }\n    return buffer;\n}",
  "abstract_func_before": "char *rfbProcessFileTransferReadBuffer(rfbClientPtr VAR_0, uint32_t VAR_1)\n{\n    char *VAR_2=NULL;\n    int   VAR_3=0;\n\n    FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN(\"\", VAR_0, NULL);\n\n    /* COMMENT_0 */\n                                                                                          \n                                                                                              \n                                                                                                    \n                                                \n      \n    if(VAR_1 == VAR_4) {\n\trfbErr(\"rfbProcessFileTransferReadBuffer: too big file transfer length requested: %u\", (unsigned int)VAR_1);\n\trfbCloseClient(VAR_0);\n\treturn NULL;\n    }\n\n    if (VAR_1>0) {\n        VAR_2=malloc((size_t)VAR_1+1);\n        if (VAR_2!=NULL) {\n            if ((VAR_3 = rfbReadExact(VAR_0, (char *)VAR_2, VAR_1)) <= 0) {\n                if (VAR_3 != 0)\n                    rfbLogPerror(\"rfbProcessFileTransferReadBuffer: read\");\n                rfbCloseClient(VAR_0);\n                /* COMMENT_6 */\n                if (VAR_2!=NULL) free(VAR_2);\n                return NULL;\n            }\n            /* COMMENT_7 */\n            VAR_2[VAR_1]=0;\n        }\n    }\n    return VAR_2;\n}",
  "func_graph_path_before": "LibVNC/libvncserver/09e8fc02f59f16e2583b34fe1a270c238bd9ffec/rfbserver.c/vul/before/0.json",
  "func": "char *rfbProcessFileTransferReadBuffer(rfbClientPtr cl, uint32_t length)\n{\n    char *buffer=NULL;\n    int   n=0;\n\n    FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN(\"\", cl, NULL);\n\n    /*\n       We later alloc length+1, which might wrap around on 32-bit systems if length equals\n       0XFFFFFFFF, i.e. SIZE_MAX for 32-bit systems. On 64-bit systems, a length of 0XFFFFFFFF\n       will safely be allocated since this check will never trigger and malloc() can digest length+1\n       without problems as length is a uint32_t.\n       We also later pass length to rfbReadExact() that expects a signed int type and\n       that might wrap on platforms with a 32-bit int type if length is bigger\n       than 0X7FFFFFFF.\n    */\n    if(length == SIZE_MAX || length > INT_MAX) {\n\trfbErr(\"rfbProcessFileTransferReadBuffer: too big file transfer length requested: %u\", (unsigned int)length);\n\trfbCloseClient(cl);\n\treturn NULL;\n    }\n\n    if (length>0) {\n        buffer=malloc((size_t)length+1);\n        if (buffer!=NULL) {\n            if ((n = rfbReadExact(cl, (char *)buffer, length)) <= 0) {\n                if (n != 0)\n                    rfbLogPerror(\"rfbProcessFileTransferReadBuffer: read\");\n                rfbCloseClient(cl);\n                /* NOTE: don't forget to free(buffer) if you return early! */\n                if (buffer!=NULL) free(buffer);\n                return NULL;\n            }\n            /* Null Terminate */\n            buffer[length]=0;\n        }\n    }\n    return buffer;\n}",
  "abstract_func": "char *rfbProcessFileTransferReadBuffer(rfbClientPtr VAR_0, uint32_t VAR_1)\n{\n    char *VAR_2=NULL;\n    int   VAR_3=0;\n\n    FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN(\"\", VAR_0, NULL);\n\n    /* COMMENT_0 */\n                                                                                          \n                                                                                              \n                                                                                                    \n                                                \n                                                                                     \n                                                                              \n                       \n      \n    if(VAR_1 == VAR_4 || VAR_1 > VAR_5) {\n\trfbErr(\"rfbProcessFileTransferReadBuffer: too big file transfer length requested: %u\", (unsigned int)VAR_1);\n\trfbCloseClient(VAR_0);\n\treturn NULL;\n    }\n\n    if (VAR_1>0) {\n        VAR_2=malloc((size_t)VAR_1+1);\n        if (VAR_2!=NULL) {\n            if ((VAR_3 = rfbReadExact(VAR_0, (char *)VAR_2, VAR_1)) <= 0) {\n                if (VAR_3 != 0)\n                    rfbLogPerror(\"rfbProcessFileTransferReadBuffer: read\");\n                rfbCloseClient(VAR_0);\n                /* COMMENT_9 */\n                if (VAR_2!=NULL) free(VAR_2);\n                return NULL;\n            }\n            /* COMMENT_10 */\n            VAR_2[VAR_1]=0;\n        }\n    }\n    return VAR_2;\n}",
  "func_graph_path": "LibVNC/libvncserver/09e8fc02f59f16e2583b34fe1a270c238bd9ffec/rfbserver.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -10,8 +10,11 @@\n        0XFFFFFFFF, i.e. SIZE_MAX for 32-bit systems. On 64-bit systems, a length of 0XFFFFFFFF\n        will safely be allocated since this check will never trigger and malloc() can digest length+1\n        without problems as length is a uint32_t.\n+       We also later pass length to rfbReadExact() that expects a signed int type and\n+       that might wrap on platforms with a 32-bit int type if length is bigger\n+       than 0X7FFFFFFF.\n     */\n-    if(length == SIZE_MAX) {\n+    if(length == SIZE_MAX || length > INT_MAX) {\n \trfbErr(\"rfbProcessFileTransferReadBuffer: too big file transfer length requested: %u\", (unsigned int)length);\n \trfbCloseClient(cl);\n \treturn NULL;",
  "diff_line_info": {
    "deleted_lines": [
      "    if(length == SIZE_MAX) {"
    ],
    "added_lines": [
      "       We also later pass length to rfbReadExact() that expects a signed int type and",
      "       that might wrap on platforms with a 32-bit int type if length is bigger",
      "       than 0X7FFFFFFF.",
      "    if(length == SIZE_MAX || length > INT_MAX) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/LibVNC/libvncserver/pull/276",
  "description": {
    "pr_info": {
      "title": "Limit lenght to INT_MAX bytes in rfbProcessFileTransferReadBuffer()",
      "number": 276
    },
    "comment": [
      "This ammends 15bb719c03cc70f14c36a843dcb16ed69b405707 fix for a heap\r\nout-of-bound write access in rfbProcessFileTransferReadBuffer() when\r\nreading a transfered file content in a server. The former fix did not\r\nwork on platforms with a 32-bit int type (expected by rfbReadExact()).\r\n\r\nCVE-2018-15127\r\n<https://github.com/LibVNC/libvncserver/issues/243>\r\n<https://github.com/LibVNC/libvncserver/issues/273>",
      "I added the comment in 09e8fc02f59f16e2583b34fe1a270c238bd9ffec commit.\n",
      "For the record: we cannot safely maintain that SIZE_MAX > INT_MAX is always true as per https://stackoverflow.com/questions/46508831/is-the-max-value-of-size-t-size-max-defined-relative-to-the-other-integer-type. I was wondering if we could simplify the check..."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix\nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\nThe patch addresses a security vulnerability by fixing a heap overflow issue in the file transfer process. The changes limit the file length to INT_MAX, preventing potential buffer overflow attacks.\n\n**Final Output:**\nAnalysis: The patch fixes a heap out-of-bound write vulnerability by ensuring the file transfer length does not exceed INT_MAX, thus preventing buffer overflow attacks. The commit message and code changes clearly indicate a security fix.\nFinal Classification: Security Vulnerability Fix\nConfidence Score: 1.0"
}