{
  "cve_id": "CVE-2015-0278",
  "cwe_ids": [
    "CWE-273"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:C/I:C/A:C",
  "cvss_is_v3": false,
  "repo_name": "libuv",
  "commit_msg": "unix: call setgoups before calling setuid/setgid\n\nPartial fix for #1093",
  "commit_hash": "66ab38918c911bcff025562cf06237d7fedaba0c",
  "git_url": "https://github.com/libuv/libuv/commit/66ab38918c911bcff025562cf06237d7fedaba0c",
  "file_path": "src/unix/process.c",
  "func_name": "uv__process_child_init",
  "func_before": "static void uv__process_child_init(const uv_process_options_t* options,\n                                   int stdio_count,\n                                   int (*pipes)[2],\n                                   int error_fd) {\n  int close_fd;\n  int use_fd;\n  int fd;\n\n  if (options->flags & UV_PROCESS_DETACHED)\n    setsid();\n\n  for (fd = 0; fd < stdio_count; fd++) {\n    close_fd = pipes[fd][0];\n    use_fd = pipes[fd][1];\n\n    if (use_fd < 0) {\n      if (fd >= 3)\n        continue;\n      else {\n        /* redirect stdin, stdout and stderr to /dev/null even if UV_IGNORE is\n         * set\n         */\n        use_fd = open(\"/dev/null\", fd == 0 ? O_RDONLY : O_RDWR);\n        close_fd = use_fd;\n\n        if (use_fd == -1) {\n        uv__write_int(error_fd, -errno);\n          perror(\"failed to open stdio\");\n          _exit(127);\n        }\n      }\n    }\n\n    if (fd == use_fd)\n      uv__cloexec(use_fd, 0);\n    else\n      dup2(use_fd, fd);\n\n    if (fd <= 2)\n      uv__nonblock(fd, 0);\n\n    if (close_fd != -1)\n      uv__close(close_fd);\n  }\n\n  for (fd = 0; fd < stdio_count; fd++) {\n    use_fd = pipes[fd][1];\n\n    if (use_fd >= 0 && fd != use_fd)\n      close(use_fd);\n  }\n\n  if (options->cwd != NULL && chdir(options->cwd)) {\n    uv__write_int(error_fd, -errno);\n    perror(\"chdir()\");\n    _exit(127);\n  }\n\n  if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {\n    uv__write_int(error_fd, -errno);\n    perror(\"setgid()\");\n    _exit(127);\n  }\n\n  if ((options->flags & UV_PROCESS_SETUID) && setuid(options->uid)) {\n    uv__write_int(error_fd, -errno);\n    perror(\"setuid()\");\n    _exit(127);\n  }\n\n  if (options->env != NULL) {\n    environ = options->env;\n  }\n\n  execvp(options->file, options->args);\n  uv__write_int(error_fd, -errno);\n  perror(\"execvp()\");\n  _exit(127);\n}",
  "abstract_func_before": "static void uv__process_child_init(const uv_process_options_t* VAR_0,\n                                   int VAR_1,\n                                   int (*VAR_2)[2],\n                                   int VAR_3) {\n  int VAR_4;\n  int VAR_5;\n  int VAR_6;\n\n  if (VAR_0->flags & VAR_7)\n    setsid();\n\n  for (VAR_6 = 0; VAR_6 < VAR_1; VAR_6++) {\n    VAR_4 = VAR_2[VAR_6][0];\n    VAR_5 = VAR_2[VAR_6][1];\n\n    if (VAR_5 < 0) {\n      if (VAR_6 >= 3)\n        continue;\n      else {\n        /* COMMENT_0 */\n              \n           \n        VAR_5 = open(\"/dev/null\", VAR_6 == 0 ? VAR_8 : VAR_9);\n        VAR_4 = VAR_5;\n\n        if (VAR_5 == -1) {\n        uv__write_int(VAR_3, -VAR_10);\n          perror(\"failed to open stdio\");\n          _exit(127);\n        }\n      }\n    }\n\n    if (VAR_6 == VAR_5)\n      uv__cloexec(VAR_5, 0);\n    else\n      dup2(VAR_5, VAR_6);\n\n    if (VAR_6 <= 2)\n      uv__nonblock(VAR_6, 0);\n\n    if (VAR_4 != -1)\n      uv__close(VAR_4);\n  }\n\n  for (VAR_6 = 0; VAR_6 < VAR_1; VAR_6++) {\n    VAR_5 = VAR_2[VAR_6][1];\n\n    if (VAR_5 >= 0 && VAR_6 != VAR_5)\n      close(VAR_5);\n  }\n\n  if (VAR_0->cwd != NULL && chdir(VAR_0->cwd)) {\n    uv__write_int(VAR_3, -VAR_10);\n    perror(\"chdir()\");\n    _exit(127);\n  }\n\n  if ((VAR_0->flags & VAR_11) && setgid(VAR_0->gid)) {\n    uv__write_int(VAR_3, -VAR_10);\n    perror(\"setgid()\");\n    _exit(127);\n  }\n\n  if ((VAR_0->flags & VAR_12) && setuid(VAR_0->uid)) {\n    uv__write_int(VAR_3, -VAR_10);\n    perror(\"setuid()\");\n    _exit(127);\n  }\n\n  if (VAR_0->env != NULL) {\n    VAR_13 = VAR_0->env;\n  }\n\n  execvp(VAR_0->file, VAR_0->args);\n  uv__write_int(VAR_3, -VAR_10);\n  perror(\"execvp()\");\n  _exit(127);\n}",
  "func_graph_path_before": "libuv/66ab38918c911bcff025562cf06237d7fedaba0c/process.c/vul/before/0.json",
  "func": "static void uv__process_child_init(const uv_process_options_t* options,\n                                   int stdio_count,\n                                   int (*pipes)[2],\n                                   int error_fd) {\n  int close_fd;\n  int use_fd;\n  int fd;\n\n  if (options->flags & UV_PROCESS_DETACHED)\n    setsid();\n\n  for (fd = 0; fd < stdio_count; fd++) {\n    close_fd = pipes[fd][0];\n    use_fd = pipes[fd][1];\n\n    if (use_fd < 0) {\n      if (fd >= 3)\n        continue;\n      else {\n        /* redirect stdin, stdout and stderr to /dev/null even if UV_IGNORE is\n         * set\n         */\n        use_fd = open(\"/dev/null\", fd == 0 ? O_RDONLY : O_RDWR);\n        close_fd = use_fd;\n\n        if (use_fd == -1) {\n        uv__write_int(error_fd, -errno);\n          perror(\"failed to open stdio\");\n          _exit(127);\n        }\n      }\n    }\n\n    if (fd == use_fd)\n      uv__cloexec(use_fd, 0);\n    else\n      dup2(use_fd, fd);\n\n    if (fd <= 2)\n      uv__nonblock(fd, 0);\n\n    if (close_fd != -1)\n      uv__close(close_fd);\n  }\n\n  for (fd = 0; fd < stdio_count; fd++) {\n    use_fd = pipes[fd][1];\n\n    if (use_fd >= 0 && fd != use_fd)\n      close(use_fd);\n  }\n\n  if (options->cwd != NULL && chdir(options->cwd)) {\n    uv__write_int(error_fd, -errno);\n    perror(\"chdir()\");\n    _exit(127);\n  }\n\n  if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {\n    /* When dropping privileges from root, the `setgroups` call will\n     * remove any extraneous groups. If we don't call this, then\n     * even though our uid has dropped, we may still have groups\n     * that enable us to do super-user things. This will fail if we\n     * aren't root, so don't bother checking the return value, this\n     * is just done as an optimistic privilege dropping function.\n     */\n    SAVE_ERRNO(setgroups(0, NULL));\n  }\n\n  if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {\n    uv__write_int(error_fd, -errno);\n    perror(\"setgid()\");\n    _exit(127);\n  }\n\n  if ((options->flags & UV_PROCESS_SETUID) && setuid(options->uid)) {\n    uv__write_int(error_fd, -errno);\n    perror(\"setuid()\");\n    _exit(127);\n  }\n\n  if (options->env != NULL) {\n    environ = options->env;\n  }\n\n  execvp(options->file, options->args);\n  uv__write_int(error_fd, -errno);\n  perror(\"execvp()\");\n  _exit(127);\n}",
  "abstract_func": "static void uv__process_child_init(const uv_process_options_t* VAR_0,\n                                   int VAR_1,\n                                   int (*VAR_2)[2],\n                                   int VAR_3) {\n  int VAR_4;\n  int VAR_5;\n  int VAR_6;\n\n  if (VAR_0->flags & VAR_7)\n    setsid();\n\n  for (VAR_6 = 0; VAR_6 < VAR_1; VAR_6++) {\n    VAR_4 = VAR_2[VAR_6][0];\n    VAR_5 = VAR_2[VAR_6][1];\n\n    if (VAR_5 < 0) {\n      if (VAR_6 >= 3)\n        continue;\n      else {\n        /* COMMENT_0 */\n              \n           \n        VAR_5 = open(\"/dev/null\", VAR_6 == 0 ? VAR_8 : VAR_9);\n        VAR_4 = VAR_5;\n\n        if (VAR_5 == -1) {\n        uv__write_int(VAR_3, -VAR_10);\n          perror(\"failed to open stdio\");\n          _exit(127);\n        }\n      }\n    }\n\n    if (VAR_6 == VAR_5)\n      uv__cloexec(VAR_5, 0);\n    else\n      dup2(VAR_5, VAR_6);\n\n    if (VAR_6 <= 2)\n      uv__nonblock(VAR_6, 0);\n\n    if (VAR_4 != -1)\n      uv__close(VAR_4);\n  }\n\n  for (VAR_6 = 0; VAR_6 < VAR_1; VAR_6++) {\n    VAR_5 = VAR_2[VAR_6][1];\n\n    if (VAR_5 >= 0 && VAR_6 != VAR_5)\n      close(VAR_5);\n  }\n\n  if (VAR_0->cwd != NULL && chdir(VAR_0->cwd)) {\n    uv__write_int(VAR_3, -VAR_10);\n    perror(\"chdir()\");\n    _exit(127);\n  }\n\n  if (VAR_0->flags & (VAR_11 | VAR_12)) {\n    /* COMMENT_3 */\n                                                                \n                                                                \n                                                                   \n                                                                   \n                                                                 \n       \n    SAVE_ERRNO(setgroups(0, NULL));\n  }\n\n  if ((VAR_0->flags & VAR_12) && setgid(VAR_0->gid)) {\n    uv__write_int(VAR_3, -VAR_10);\n    perror(\"setgid()\");\n    _exit(127);\n  }\n\n  if ((VAR_0->flags & VAR_11) && setuid(VAR_0->uid)) {\n    uv__write_int(VAR_3, -VAR_10);\n    perror(\"setuid()\");\n    _exit(127);\n  }\n\n  if (VAR_0->env != NULL) {\n    VAR_13 = VAR_0->env;\n  }\n\n  execvp(VAR_0->file, VAR_0->args);\n  uv__write_int(VAR_3, -VAR_10);\n  perror(\"execvp()\");\n  _exit(127);\n}",
  "func_graph_path": "libuv/66ab38918c911bcff025562cf06237d7fedaba0c/process.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -56,6 +56,17 @@\n     _exit(127);\n   }\n \n+  if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {\n+    /* When dropping privileges from root, the `setgroups` call will\n+     * remove any extraneous groups. If we don't call this, then\n+     * even though our uid has dropped, we may still have groups\n+     * that enable us to do super-user things. This will fail if we\n+     * aren't root, so don't bother checking the return value, this\n+     * is just done as an optimistic privilege dropping function.\n+     */\n+    SAVE_ERRNO(setgroups(0, NULL));\n+  }\n+\n   if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {\n     uv__write_int(error_fd, -errno);\n     perror(\"setgid()\");",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "  if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {",
      "    /* When dropping privileges from root, the `setgroups` call will",
      "     * remove any extraneous groups. If we don't call this, then",
      "     * even though our uid has dropped, we may still have groups",
      "     * that enable us to do super-user things. This will fail if we",
      "     * aren't root, so don't bother checking the return value, this",
      "     * is just done as an optimistic privilege dropping function.",
      "     */",
      "    SAVE_ERRNO(setgroups(0, NULL));",
      "  }",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libuv/libuv/pull/41",
  "description": {
    "pr_info": {
      "title": "Merge v0.10 into v1.x",
      "number": 41
    },
    "comment": [
      "R=@saghul\n\nThis breaks the fs_fstat test on Linux and only in the gyp build because neither _BSD_SOURCE, _SVID_SOURCE or _XOPEN_SOURCE seem to be defined.  Still investigating that.\n\n```\n$ out/Debug/run-tests fs_fstat fs_fstat\nAssertion failed in ../test/test-fs.c on line 1081: s->st_atim.tv_nsec == t.st_atim.tv_nsec\nAborted (core dumped)\n```\n",
      "> This breaks the fs_fstat test on Linux and only in the gyp build because neither _BSD_SOURCE, _SVID_SOURCE or _XOPEN_SOURCE seem to be defined. Still investigating that.\n\nI was wrong: the test also fails when I revert to dfdcfc0, it's not a regression caused by this PR.  I'll file an issue.  (edit: see #43.)\n",
      "LGTM then!\nOn Dec 5, 2014 7:36 PM, \"Ben Noordhuis\" notifications@github.com wrote:\n\n> This breaks the fs_fstat test on Linux and only in the gyp build because\n> neither _BSD_SOURCE, _SVID_SOURCE or _XOPEN_SOURCE seem to be defined.\n> Still investigating that.\n> \n> I was wrong: the test also fails when I revert to dfdcfc0\n> https://github.com/libuv/libuv/commit/dfdcfc0c4dc0a1bf8c49aba7e53b5ec590d1c71d,\n> it's not a regression caused by this PR. I'll file an issue.\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/libuv/libuv/pull/41#issuecomment-65833812.\n",
      "Maybe we should release a 0.10.x\nOn Dec 5, 2014 7:36 PM, \"Ben Noordhuis\" notifications@github.com wrote:\n\n> This breaks the fs_fstat test on Linux and only in the gyp build because\n> neither _BSD_SOURCE, _SVID_SOURCE or _XOPEN_SOURCE seem to be defined.\n> Still investigating that.\n> \n> I was wrong: the test also fails when I revert to dfdcfc0\n> https://github.com/libuv/libuv/commit/dfdcfc0c4dc0a1bf8c49aba7e53b5ec590d1c71d,\n> it's not a regression caused by this PR. I'll file an issue.\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/libuv/libuv/pull/41#issuecomment-65833812.\n",
      "> Maybe we should release a 0.10.x\n\nThat's a good idea.  I'll give it a try tomorrow, when you are around.\n",
      "> That's a good idea. I'll give it a try tomorrow, when you are around.\n\nKewl, ping me on IRC then.\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\nAnalysis: The patch modifies the process initialization to call setgroups before changing UID/GID, ensuring that extraneous groups are removed, thus preventing potential privilege escalation.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 0.95"
}