{
  "cve_id": "CVE-2019-3817",
  "cwe_ids": [
    "CWE-416"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "rpm-software-management/libcomps",
  "commit_msg": "Fix UAF in comps_objmrtree_unite function\n\nThe added field is not used at all in many places and it is probably the\nleft-over of some copy-paste.",
  "commit_hash": "e3a5d056633677959ad924a51758876d415e7046",
  "git_url": "https://github.com/rpm-software-management/libcomps/commit/e3a5d056633677959ad924a51758876d415e7046",
  "file_path": "libcomps/src/comps_objmradix.c",
  "func_name": "comps_objmrtree_unite",
  "func_before": "void comps_objmrtree_unite(COMPS_ObjMRTree *rt1, COMPS_ObjMRTree *rt2) {\n    COMPS_HSList *tmplist, *tmp_subnodes;\n    COMPS_HSListItem *it;\n    COMPS_ObjListIt *it2;\n    struct Pair {\n        COMPS_HSList * subnodes;\n        char * key;\n        char added;\n    } *pair, *parent_pair;\n\n    pair = malloc(sizeof(struct Pair));\n    pair->subnodes = rt2->subnodes;\n    pair->key = NULL;\n\n    tmplist = comps_hslist_create();\n    comps_hslist_init(tmplist, NULL, NULL, &free);\n    comps_hslist_append(tmplist, pair, 0);\n\n    while (tmplist->first != NULL) {\n        it = tmplist->first;\n        comps_hslist_remove(tmplist, tmplist->first);\n        tmp_subnodes = ((struct Pair*)it->data)->subnodes;\n        parent_pair = (struct Pair*) it->data;\n        free(it);\n\n        pair->added = 0;\n        for (it = tmp_subnodes->first; it != NULL; it=it->next) {\n            pair = malloc(sizeof(struct Pair));\n            pair->subnodes = ((COMPS_ObjMRTreeData*)it->data)->subnodes;\n\n            if (parent_pair->key != NULL) {\n                pair->key =\n                    malloc(sizeof(char)\n                           * (strlen(((COMPS_ObjMRTreeData*)it->data)->key)\n                           + strlen(parent_pair->key) + 1));\n                memcpy(pair->key, parent_pair->key,\n                       sizeof(char) * strlen(parent_pair->key));\n                memcpy(pair->key+strlen(parent_pair->key),\n                       ((COMPS_ObjMRTreeData*)it->data)->key,\n                       sizeof(char)*(strlen(((COMPS_ObjMRTreeData*)it->data)->key)+1));\n            } else {\n                pair->key = malloc(sizeof(char)*\n                                (strlen(((COMPS_ObjMRTreeData*)it->data)->key) +\n                                1));\n                memcpy(pair->key, ((COMPS_ObjMRTreeData*)it->data)->key,\n                       sizeof(char)*(strlen(((COMPS_ObjMRTreeData*)it->data)->key)+1));\n            }\n            /* current node has data */\n            if (((COMPS_ObjMRTreeData*)it->data)->data->first != NULL) {\n                for (it2 = ((COMPS_ObjMRTreeData*)it->data)->data->first;\n                     it2 != NULL; it2 = it2->next) {\n                    comps_objmrtree_set(rt1, pair->key, it2->comps_obj);\n                }\n\n                if (((COMPS_ObjMRTreeData*)it->data)->subnodes->first) {\n                    comps_hslist_append(tmplist, pair, 0);\n                } else {\n                    free(pair->key);\n                    free(pair);\n                }\n            /* current node hasn't data */\n            } else {\n                if (((COMPS_ObjMRTreeData*)it->data)->subnodes->first) {\n                    comps_hslist_append(tmplist, pair, 0);\n                } else {\n                    free(pair->key);\n                    free(pair);\n                }\n            }\n        }\n        free(parent_pair->key);\n        free(parent_pair);\n    }\n    comps_hslist_destroy(&tmplist);\n}",
  "abstract_func_before": "void comps_objmrtree_unite(COMPS_ObjMRTree *VAR_0, COMPS_ObjMRTree *VAR_1) {\n    COMPS_HSList *VAR_2, *VAR_3;\n    COMPS_HSListItem *VAR_4;\n    COMPS_ObjListIt *VAR_5;\n    struct Pair {\n        COMPS_HSList * subnodes;\n        char * key;\n        char added;\n    } *VAR_6, *VAR_7;\n\n    VAR_6 = malloc(sizeof(struct Pair));\n    VAR_6->subnodes = VAR_1->subnodes;\n    VAR_6->key = NULL;\n\n    VAR_2 = comps_hslist_create();\n    comps_hslist_init(VAR_2, NULL, NULL, &VAR_8);\n    comps_hslist_append(VAR_2, VAR_6, 0);\n\n    while (VAR_2->first != NULL) {\n        VAR_4 = VAR_2->first;\n        comps_hslist_remove(VAR_2, VAR_2->first);\n        VAR_3 = ((struct Pair*)VAR_4->data)->subnodes;\n        VAR_7 = (struct Pair*) VAR_4->data;\n        VAR_8(VAR_4);\n\n        VAR_6->added = 0;\n        for (VAR_4 = VAR_3->first; VAR_4 != NULL; VAR_4=VAR_4->next) {\n            VAR_6 = malloc(sizeof(struct Pair));\n            VAR_6->subnodes = ((COMPS_ObjMRTreeData*)VAR_4->data)->subnodes;\n\n            if (VAR_7->key != NULL) {\n                VAR_6->key =\n                    malloc(sizeof(char)\n                           * (strlen(((COMPS_ObjMRTreeData*)VAR_4->data)->key)\n                           + strlen(VAR_7->key) + 1));\n                memcpy(VAR_6->key, VAR_7->key,\n                       sizeof(char) * strlen(VAR_7->key));\n                memcpy(VAR_6->key+strlen(VAR_7->key),\n                       ((COMPS_ObjMRTreeData*)VAR_4->data)->key,\n                       sizeof(char)*(strlen(((COMPS_ObjMRTreeData*)VAR_4->data)->key)+1));\n            } else {\n                VAR_6->key = malloc(sizeof(char)*\n                                (strlen(((COMPS_ObjMRTreeData*)VAR_4->data)->key) +\n                                1));\n                memcpy(VAR_6->key, ((COMPS_ObjMRTreeData*)VAR_4->data)->key,\n                       sizeof(char)*(strlen(((COMPS_ObjMRTreeData*)VAR_4->data)->key)+1));\n            }\n            /* COMMENT_0 */\n            if (((COMPS_ObjMRTreeData*)VAR_4->data)->data->first != NULL) {\n                for (VAR_5 = ((COMPS_ObjMRTreeData*)VAR_4->data)->data->first;\n                     VAR_5 != NULL; VAR_5 = VAR_5->next) {\n                    comps_objmrtree_set(VAR_0, VAR_6->key, VAR_5->comps_obj);\n                }\n\n                if (((COMPS_ObjMRTreeData*)VAR_4->data)->subnodes->first) {\n                    comps_hslist_append(VAR_2, VAR_6, 0);\n                } else {\n                    VAR_8(VAR_6->key);\n                    VAR_8(VAR_6);\n                }\n            /* COMMENT_1 */\n            } else {\n                if (((COMPS_ObjMRTreeData*)VAR_4->data)->subnodes->first) {\n                    comps_hslist_append(VAR_2, VAR_6, 0);\n                } else {\n                    VAR_8(VAR_6->key);\n                    VAR_8(VAR_6);\n                }\n            }\n        }\n        VAR_8(VAR_7->key);\n        VAR_8(VAR_7);\n    }\n    comps_hslist_destroy(&VAR_2);\n}",
  "func_graph_path_before": "rpm-software-management/libcomps/e3a5d056633677959ad924a51758876d415e7046/comps_objmradix.c/vul/before/0.json",
  "func": "void comps_objmrtree_unite(COMPS_ObjMRTree *rt1, COMPS_ObjMRTree *rt2) {\n    COMPS_HSList *tmplist, *tmp_subnodes;\n    COMPS_HSListItem *it;\n    COMPS_ObjListIt *it2;\n    struct Pair {\n        COMPS_HSList * subnodes;\n        char * key;\n    } *pair, *parent_pair;\n\n    pair = malloc(sizeof(struct Pair));\n    pair->subnodes = rt2->subnodes;\n    pair->key = NULL;\n\n    tmplist = comps_hslist_create();\n    comps_hslist_init(tmplist, NULL, NULL, &free);\n    comps_hslist_append(tmplist, pair, 0);\n\n    while (tmplist->first != NULL) {\n        it = tmplist->first;\n        comps_hslist_remove(tmplist, tmplist->first);\n        tmp_subnodes = ((struct Pair*)it->data)->subnodes;\n        parent_pair = (struct Pair*) it->data;\n        free(it);\n\n        for (it = tmp_subnodes->first; it != NULL; it=it->next) {\n            pair = malloc(sizeof(struct Pair));\n            pair->subnodes = ((COMPS_ObjMRTreeData*)it->data)->subnodes;\n\n            if (parent_pair->key != NULL) {\n                pair->key =\n                    malloc(sizeof(char)\n                           * (strlen(((COMPS_ObjMRTreeData*)it->data)->key)\n                           + strlen(parent_pair->key) + 1));\n                memcpy(pair->key, parent_pair->key,\n                       sizeof(char) * strlen(parent_pair->key));\n                memcpy(pair->key+strlen(parent_pair->key),\n                       ((COMPS_ObjMRTreeData*)it->data)->key,\n                       sizeof(char)*(strlen(((COMPS_ObjMRTreeData*)it->data)->key)+1));\n            } else {\n                pair->key = malloc(sizeof(char)*\n                                (strlen(((COMPS_ObjMRTreeData*)it->data)->key) +\n                                1));\n                memcpy(pair->key, ((COMPS_ObjMRTreeData*)it->data)->key,\n                       sizeof(char)*(strlen(((COMPS_ObjMRTreeData*)it->data)->key)+1));\n            }\n            /* current node has data */\n            if (((COMPS_ObjMRTreeData*)it->data)->data->first != NULL) {\n                for (it2 = ((COMPS_ObjMRTreeData*)it->data)->data->first;\n                     it2 != NULL; it2 = it2->next) {\n                    comps_objmrtree_set(rt1, pair->key, it2->comps_obj);\n                }\n\n                if (((COMPS_ObjMRTreeData*)it->data)->subnodes->first) {\n                    comps_hslist_append(tmplist, pair, 0);\n                } else {\n                    free(pair->key);\n                    free(pair);\n                }\n            /* current node hasn't data */\n            } else {\n                if (((COMPS_ObjMRTreeData*)it->data)->subnodes->first) {\n                    comps_hslist_append(tmplist, pair, 0);\n                } else {\n                    free(pair->key);\n                    free(pair);\n                }\n            }\n        }\n        free(parent_pair->key);\n        free(parent_pair);\n    }\n    comps_hslist_destroy(&tmplist);\n}",
  "abstract_func": "void comps_objmrtree_unite(COMPS_ObjMRTree *VAR_0, COMPS_ObjMRTree *VAR_1) {\n    COMPS_HSList *VAR_2, *VAR_3;\n    COMPS_HSListItem *VAR_4;\n    COMPS_ObjListIt *VAR_5;\n    struct Pair {\n        COMPS_HSList * subnodes;\n        char * key;\n    } *VAR_6, *VAR_7;\n\n    VAR_6 = malloc(sizeof(struct Pair));\n    VAR_6->subnodes = VAR_1->subnodes;\n    VAR_6->key = NULL;\n\n    VAR_2 = comps_hslist_create();\n    comps_hslist_init(VAR_2, NULL, NULL, &VAR_8);\n    comps_hslist_append(VAR_2, VAR_6, 0);\n\n    while (VAR_2->first != NULL) {\n        VAR_4 = VAR_2->first;\n        comps_hslist_remove(VAR_2, VAR_2->first);\n        VAR_3 = ((struct Pair*)VAR_4->data)->subnodes;\n        VAR_7 = (struct Pair*) VAR_4->data;\n        VAR_8(VAR_4);\n\n        for (VAR_4 = VAR_3->first; VAR_4 != NULL; VAR_4=VAR_4->next) {\n            VAR_6 = malloc(sizeof(struct Pair));\n            VAR_6->subnodes = ((COMPS_ObjMRTreeData*)VAR_4->data)->subnodes;\n\n            if (VAR_7->key != NULL) {\n                VAR_6->key =\n                    malloc(sizeof(char)\n                           * (strlen(((COMPS_ObjMRTreeData*)VAR_4->data)->key)\n                           + strlen(VAR_7->key) + 1));\n                memcpy(VAR_6->key, VAR_7->key,\n                       sizeof(char) * strlen(VAR_7->key));\n                memcpy(VAR_6->key+strlen(VAR_7->key),\n                       ((COMPS_ObjMRTreeData*)VAR_4->data)->key,\n                       sizeof(char)*(strlen(((COMPS_ObjMRTreeData*)VAR_4->data)->key)+1));\n            } else {\n                VAR_6->key = malloc(sizeof(char)*\n                                (strlen(((COMPS_ObjMRTreeData*)VAR_4->data)->key) +\n                                1));\n                memcpy(VAR_6->key, ((COMPS_ObjMRTreeData*)VAR_4->data)->key,\n                       sizeof(char)*(strlen(((COMPS_ObjMRTreeData*)VAR_4->data)->key)+1));\n            }\n            /* COMMENT_0 */\n            if (((COMPS_ObjMRTreeData*)VAR_4->data)->data->first != NULL) {\n                for (VAR_5 = ((COMPS_ObjMRTreeData*)VAR_4->data)->data->first;\n                     VAR_5 != NULL; VAR_5 = VAR_5->next) {\n                    comps_objmrtree_set(VAR_0, VAR_6->key, VAR_5->comps_obj);\n                }\n\n                if (((COMPS_ObjMRTreeData*)VAR_4->data)->subnodes->first) {\n                    comps_hslist_append(VAR_2, VAR_6, 0);\n                } else {\n                    VAR_8(VAR_6->key);\n                    VAR_8(VAR_6);\n                }\n            /* COMMENT_1 */\n            } else {\n                if (((COMPS_ObjMRTreeData*)VAR_4->data)->subnodes->first) {\n                    comps_hslist_append(VAR_2, VAR_6, 0);\n                } else {\n                    VAR_8(VAR_6->key);\n                    VAR_8(VAR_6);\n                }\n            }\n        }\n        VAR_8(VAR_7->key);\n        VAR_8(VAR_7);\n    }\n    comps_hslist_destroy(&VAR_2);\n}",
  "func_graph_path": "rpm-software-management/libcomps/e3a5d056633677959ad924a51758876d415e7046/comps_objmradix.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,6 @@\n     struct Pair {\n         COMPS_HSList * subnodes;\n         char * key;\n-        char added;\n     } *pair, *parent_pair;\n \n     pair = malloc(sizeof(struct Pair));\n@@ -23,7 +22,6 @@\n         parent_pair = (struct Pair*) it->data;\n         free(it);\n \n-        pair->added = 0;\n         for (it = tmp_subnodes->first; it != NULL; it=it->next) {\n             pair = malloc(sizeof(struct Pair));\n             pair->subnodes = ((COMPS_ObjMRTreeData*)it->data)->subnodes;",
  "diff_line_info": {
    "deleted_lines": [
      "        char added;",
      "        pair->added = 0;"
    ],
    "added_lines": []
  },
  "is_vul": true,
  "pr_url": "https://github.com/rpm-software-management/libcomps/pull/43",
  "description": {
    "pr_info": {
      "title": "Fix UAF in comps_objmrtree_unite function",
      "number": 43
    },
    "comment": [
      "The added field is not used at all in many places and it is probably the\r\nleft-over of some copy-paste.\r\n\r\nFixes https://github.com/rpm-software-management/libcomps/issues/41",
      "Thank"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\nThe patch addresses a Use After Free (UAF) vulnerability by removing an unused field, preventing potential security exploitation.\n\n**Final Output:**\nAnalysis: The patch removes an unused 'added' field in the struct Pair, fixing a UAF issue. This prevents potential memory corruption and security exploitation. The commit message and code changes indicate a security vulnerability fix.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 0.95"
}