{
  "cve_id": "CVE-2018-7262",
  "cwe_ids": [
    "CWE-476"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "ceph",
  "commit_msg": "rgw:  make init env methods return an error\n\nSince web frontends may signal an error when requests are malformed or so, let\nus double check this and raise errors early. The current user of this is\ncivetweb frontend; which can potentially return null from `parse_http_headers`\nwhen a HTTP header without a \":\" is supplied at which point headers.value is\nnull which can lead to undefined behaviour later in RGW.\n\nFixes: http://tracker.ceph.com/issues/23039\nSigned-off-by: Abhishek Lekshmanan <abhishek@suse.com>",
  "commit_hash": "7872a831783e17dcc4d0aa70cffc256afb664f7a",
  "git_url": "https://github.com/ceph/ceph/commit/7872a831783e17dcc4d0aa70cffc256afb664f7a",
  "file_path": "src/rgw/rgw_civetweb.cc",
  "func_name": "RGWCivetWeb::init_env",
  "func_before": "void RGWCivetWeb::init_env(CephContext *cct)\n{\n  env.init(cct);\n  const struct mg_request_info* info = mg_get_request_info(conn);\n\n  if (! info) {\n    return;\n  }\n\n  for (int i = 0; i < info->num_headers; i++) {\n    const struct mg_request_info::mg_header* header = &info->http_headers[i];\n    const boost::string_ref name(header->name);\n    const auto& value = header->value;\n\n    if (boost::algorithm::iequals(name, \"content-length\")) {\n      env.set(\"CONTENT_LENGTH\", value);\n      continue;\n    }\n    if (boost::algorithm::iequals(name, \"content-type\")) {\n      env.set(\"CONTENT_TYPE\", value);\n      continue;\n    }\n    if (boost::algorithm::iequals(name, \"connection\")) {\n      explicit_keepalive = boost::algorithm::iequals(value, \"keep-alive\");\n      explicit_conn_close = boost::algorithm::iequals(value, \"close\");\n    }\n\n    static const boost::string_ref HTTP_{\"HTTP_\"};\n\n    char buf[name.size() + HTTP_.size() + 1];\n    auto dest = std::copy(std::begin(HTTP_), std::end(HTTP_), buf);\n    for (auto src = name.begin(); src != name.end(); ++src, ++dest) {\n      if (*src == '-') {\n        *dest = '_';\n      } else {\n        *dest = std::toupper(*src);\n      }\n    }\n    *dest = '\\0';\n\n    env.set(buf, value);\n  }\n\n  env.set(\"REMOTE_ADDR\", info->remote_addr);\n  env.set(\"REQUEST_METHOD\", info->request_method);\n  env.set(\"HTTP_VERSION\", info->http_version);\n  env.set(\"REQUEST_URI\", info->request_uri); // get the full uri, we anyway handle abs uris later\n  env.set(\"SCRIPT_URI\", info->uri); /* FIXME */\n  if (info->query_string) {\n    env.set(\"QUERY_STRING\", info->query_string);\n  }\n  if (info->remote_user) {\n    env.set(\"REMOTE_USER\", info->remote_user);\n  }\n\n  if (port <= 0)\n    lderr(cct) << \"init_env: bug: invalid port number\" << dendl;\n  char port_buf[16];\n  snprintf(port_buf, sizeof(port_buf), \"%d\", port);\n  env.set(\"SERVER_PORT\", port_buf);\n  if (info->is_ssl) {\n    env.set(\"SERVER_PORT_SECURE\", port_buf);\n  }\n}",
  "abstract_func_before": "void RGWCivetWeb::init_env(CephContext *VAR_0)\n{\n  VAR_1.init(VAR_0);\n  const struct mg_request_info* VAR_2 = mg_get_request_info(VAR_3);\n\n  if (! VAR_2) {\n    return;\n  }\n\n  for (int VAR_4 = 0; VAR_4 < VAR_2->num_headers; VAR_4++) {\n    const struct mg_request_info::mg_header* VAR_5 = &VAR_2->http_headers[VAR_4];\n    const boost::string_ref VAR_6(VAR_5->name);\n    const auto& VAR_7 = VAR_5->value;\n\n    if (boost::algorithm::iequals(VAR_6, \"content-length\")) {\n      VAR_1.set(\"CONTENT_LENGTH\", VAR_7);\n      continue;\n    }\n    if (boost::algorithm::iequals(VAR_6, \"content-type\")) {\n      VAR_1.set(\"CONTENT_TYPE\", VAR_7);\n      continue;\n    }\n    if (boost::algorithm::iequals(VAR_6, \"connection\")) {\n      VAR_8 = boost::algorithm::iequals(VAR_7, \"keep-alive\");\n      VAR_9 = boost::algorithm::iequals(VAR_7, \"close\");\n    }\n\n    static const boost::string_ref VAR_10{\"HTTP_\"};\n\n    char VAR_11[VAR_6.size() + VAR_10.size() + 1];\n    auto VAR_12 = std::copy(std::begin(VAR_10), std::end(VAR_10), VAR_11);\n    for (auto VAR_13 = VAR_6.begin(); VAR_13 != VAR_6.end(); ++VAR_13, ++VAR_12) {\n      if (*VAR_13 == '-') {\n        *VAR_12 = '_';\n      } else {\n        *VAR_12 = std::toupper(*VAR_13);\n      }\n    }\n    *VAR_12 = '\\0';\n\n    VAR_1.set(VAR_11, VAR_7);\n  }\n\n  VAR_1.set(\"REMOTE_ADDR\", VAR_2->remote_addr);\n  VAR_1.set(\"REQUEST_METHOD\", VAR_2->request_method);\n  VAR_1.set(\"HTTP_VERSION\", VAR_2->http_version);\n  VAR_1.set(\"REQUEST_URI\", VAR_2->request_uri); /* COMMENT_0 */\n  VAR_1.set(\"SCRIPT_URI\", VAR_2->uri); /* COMMENT_1 */\n  if (VAR_2->query_string) {\n    VAR_1.set(\"QUERY_STRING\", VAR_2->query_string);\n  }\n  if (VAR_2->remote_user) {\n    VAR_1.set(\"REMOTE_USER\", VAR_2->remote_user);\n  }\n\n  if (VAR_14 <= 0)\n    lderr(VAR_0) << \"init_env: bug: invalid port number\" << VAR_15;\n  char VAR_16[16];\n  snprintf(VAR_16, sizeof(VAR_16), \"%d\", VAR_14);\n  VAR_1.set(\"SERVER_PORT\", VAR_16);\n  if (VAR_2->is_ssl) {\n    VAR_1.set(\"SERVER_PORT_SECURE\", VAR_16);\n  }\n}",
  "func_graph_path_before": "ceph/7872a831783e17dcc4d0aa70cffc256afb664f7a/rgw_civetweb.cc/vul/before/0.json",
  "func": "int RGWCivetWeb::init_env(CephContext *cct)\n{\n  env.init(cct);\n  const struct mg_request_info* info = mg_get_request_info(conn);\n\n  if (! info) {\n    // request info is NULL; we have no info about the connection\n    return -EINVAL;\n  }\n\n  for (int i = 0; i < info->num_headers; i++) {\n    const struct mg_request_info::mg_header* header = &info->http_headers[i];\n\n    if (header->name == nullptr || header->value==nullptr) {\n      lderr(cct) << \"client supplied malformatted headers\" << dendl;\n      return -EINVAL;\n    }\n\n    const boost::string_ref name(header->name);\n    const auto& value = header->value;\n\n    if (boost::algorithm::iequals(name, \"content-length\")) {\n      env.set(\"CONTENT_LENGTH\", value);\n      continue;\n    }\n    if (boost::algorithm::iequals(name, \"content-type\")) {\n      env.set(\"CONTENT_TYPE\", value);\n      continue;\n    }\n    if (boost::algorithm::iequals(name, \"connection\")) {\n      explicit_keepalive = boost::algorithm::iequals(value, \"keep-alive\");\n      explicit_conn_close = boost::algorithm::iequals(value, \"close\");\n    }\n\n    static const boost::string_ref HTTP_{\"HTTP_\"};\n\n    char buf[name.size() + HTTP_.size() + 1];\n    auto dest = std::copy(std::begin(HTTP_), std::end(HTTP_), buf);\n    for (auto src = name.begin(); src != name.end(); ++src, ++dest) {\n      if (*src == '-') {\n        *dest = '_';\n      } else {\n        *dest = std::toupper(*src);\n      }\n    }\n    *dest = '\\0';\n\n    env.set(buf, value);\n  }\n\n  env.set(\"REMOTE_ADDR\", info->remote_addr);\n  env.set(\"REQUEST_METHOD\", info->request_method);\n  env.set(\"HTTP_VERSION\", info->http_version);\n  env.set(\"REQUEST_URI\", info->request_uri); // get the full uri, we anyway handle abs uris later\n  env.set(\"SCRIPT_URI\", info->uri); /* FIXME */\n  if (info->query_string) {\n    env.set(\"QUERY_STRING\", info->query_string);\n  }\n  if (info->remote_user) {\n    env.set(\"REMOTE_USER\", info->remote_user);\n  }\n\n  if (port <= 0)\n    lderr(cct) << \"init_env: bug: invalid port number\" << dendl;\n  char port_buf[16];\n  snprintf(port_buf, sizeof(port_buf), \"%d\", port);\n  env.set(\"SERVER_PORT\", port_buf);\n  if (info->is_ssl) {\n    env.set(\"SERVER_PORT_SECURE\", port_buf);\n  }\n  return 0;\n}",
  "abstract_func": "int RGWCivetWeb::init_env(CephContext *VAR_0)\n{\n  VAR_1.init(VAR_0);\n  const struct mg_request_info* VAR_2 = mg_get_request_info(VAR_3);\n\n  if (! VAR_2) {\n    /* COMMENT_0 */\n    return -VAR_4;\n  }\n\n  for (int VAR_5 = 0; VAR_5 < VAR_2->num_headers; VAR_5++) {\n    const struct mg_request_info::mg_header* VAR_6 = &VAR_2->http_headers[VAR_5];\n\n    if (VAR_6->name == nullptr || VAR_6->value==nullptr) {\n      lderr(VAR_0) << \"client supplied malformatted headers\" << VAR_7;\n      return -VAR_4;\n    }\n\n    const boost::string_ref VAR_8(VAR_6->name);\n    const auto& VAR_9 = VAR_6->value;\n\n    if (boost::algorithm::iequals(VAR_8, \"content-length\")) {\n      VAR_1.set(\"CONTENT_LENGTH\", VAR_9);\n      continue;\n    }\n    if (boost::algorithm::iequals(VAR_8, \"content-type\")) {\n      VAR_1.set(\"CONTENT_TYPE\", VAR_9);\n      continue;\n    }\n    if (boost::algorithm::iequals(VAR_8, \"connection\")) {\n      VAR_10 = boost::algorithm::iequals(VAR_9, \"keep-alive\");\n      VAR_11 = boost::algorithm::iequals(VAR_9, \"close\");\n    }\n\n    static const boost::string_ref VAR_12{\"HTTP_\"};\n\n    char VAR_13[VAR_8.size() + VAR_12.size() + 1];\n    auto VAR_14 = std::copy(std::begin(VAR_12), std::end(VAR_12), VAR_13);\n    for (auto VAR_15 = VAR_8.begin(); VAR_15 != VAR_8.end(); ++VAR_15, ++VAR_14) {\n      if (*VAR_15 == '-') {\n        *VAR_14 = '_';\n      } else {\n        *VAR_14 = std::toupper(*VAR_15);\n      }\n    }\n    *VAR_14 = '\\0';\n\n    VAR_1.set(VAR_13, VAR_9);\n  }\n\n  VAR_1.set(\"REMOTE_ADDR\", VAR_2->remote_addr);\n  VAR_1.set(\"REQUEST_METHOD\", VAR_2->request_method);\n  VAR_1.set(\"HTTP_VERSION\", VAR_2->http_version);\n  VAR_1.set(\"REQUEST_URI\", VAR_2->request_uri); /* COMMENT_1 */\n  VAR_1.set(\"SCRIPT_URI\", VAR_2->uri); /* COMMENT_2 */\n  if (VAR_2->query_string) {\n    VAR_1.set(\"QUERY_STRING\", VAR_2->query_string);\n  }\n  if (VAR_2->remote_user) {\n    VAR_1.set(\"REMOTE_USER\", VAR_2->remote_user);\n  }\n\n  if (VAR_16 <= 0)\n    lderr(VAR_0) << \"init_env: bug: invalid port number\" << VAR_7;\n  char VAR_17[16];\n  snprintf(VAR_17, sizeof(VAR_17), \"%d\", VAR_16);\n  VAR_1.set(\"SERVER_PORT\", VAR_17);\n  if (VAR_2->is_ssl) {\n    VAR_1.set(\"SERVER_PORT_SECURE\", VAR_17);\n  }\n  return 0;\n}",
  "func_graph_path": "ceph/7872a831783e17dcc4d0aa70cffc256afb664f7a/rgw_civetweb.cc/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,14 +1,21 @@\n-void RGWCivetWeb::init_env(CephContext *cct)\n+int RGWCivetWeb::init_env(CephContext *cct)\n {\n   env.init(cct);\n   const struct mg_request_info* info = mg_get_request_info(conn);\n \n   if (! info) {\n-    return;\n+    // request info is NULL; we have no info about the connection\n+    return -EINVAL;\n   }\n \n   for (int i = 0; i < info->num_headers; i++) {\n     const struct mg_request_info::mg_header* header = &info->http_headers[i];\n+\n+    if (header->name == nullptr || header->value==nullptr) {\n+      lderr(cct) << \"client supplied malformatted headers\" << dendl;\n+      return -EINVAL;\n+    }\n+\n     const boost::string_ref name(header->name);\n     const auto& value = header->value;\n \n@@ -61,4 +68,5 @@\n   if (info->is_ssl) {\n     env.set(\"SERVER_PORT_SECURE\", port_buf);\n   }\n+  return 0;\n }",
  "diff_line_info": {
    "deleted_lines": [
      "void RGWCivetWeb::init_env(CephContext *cct)",
      "    return;"
    ],
    "added_lines": [
      "int RGWCivetWeb::init_env(CephContext *cct)",
      "    // request info is NULL; we have no info about the connection",
      "    return -EINVAL;",
      "",
      "    if (header->name == nullptr || header->value==nullptr) {",
      "      lderr(cct) << \"client supplied malformatted headers\" << dendl;",
      "      return -EINVAL;",
      "    }",
      "",
      "  return 0;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/ceph/ceph/pull/20488",
  "description": {
    "pr_info": {
      "title": "rgw:  make init env methods return an error",
      "number": 20488
    },
    "comment": [
      "Since web frontends may signal an error when requests are malformed or so, let\r\nus double check this and raise errors early. The current user of this is\r\ncivetweb frontend; which can potentially return null from `parse_http_headers`\r\nwhen a HTTP header without a \":\" is supplied at which point headers.value is\r\nnull which can lead to undefined behaviour later in RGW.\r\n\r\nFixes: http://tracker.ceph.com/issues/23039\r\nSigned-off-by: Abhishek Lekshmanan <abhishek@suse.com>",
      "changelog: \r\n- drop init_error variable in rgw_civetweb\r\n- raise -EINVAL if mg_request info isn't populated in rgw_civetweb.cc\r\n   this is a changed behaviour  from earlier where we return and fail at a much later stage in rgw process \r\n",
      "@yehudasa @cbodley do these changes look okay?",
      "was unable to reproduce the failures in manual testing :+1: "
    ]
  },
  "Bug Filter": "** Security Vulnerability Fix  \n**Confidence Score:** 0.95\n\n**Analysis:**\n- The patch addresses malformed HTTP headers, a potential attack vector.\n- It prevents undefined behavior, which could lead to security issues.\n- The changes are aimed at enhancing security by proper error handling.",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\nThe patch modifies the `RGWCivetWeb::init_env` method to return an error when handling malformed HTTP headers. It adds checks for null header values, preventing undefined behavior that could be exploited.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 0.95\n\n**Analysis:**\n- The patch addresses malformed HTTP headers, a potential attack vector.\n- It prevents undefined behavior, which could lead to security issues.\n- The changes are aimed at enhancing security by proper error handling."
}