{
  "cve_id": "CVE-2020-7105",
  "cwe_ids": [
    "CWE-476"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "redis/hiredis",
  "commit_msg": "Rename allocation wrappers and add license info\n\nSee #752, #747",
  "commit_hash": "70e73a31ad5edb6c457658c0a0b6752b06cc6a25",
  "git_url": "https://github.com/redis/hiredis/commit/70e73a31ad5edb6c457658c0a0b6752b06cc6a25",
  "file_path": "adapters/libev.h",
  "func_name": "redisLibevAttach",
  "func_before": "static int redisLibevAttach(EV_P_ redisAsyncContext *ac) {\n    redisContext *c = &(ac->c);\n    redisLibevEvents *e;\n\n    /* Nothing should be attached when something is already attached */\n    if (ac->ev.data != NULL)\n        return REDIS_ERR;\n\n    /* Create container for context and r/w events */\n    e = (redisLibevEvents*)hiredis_safe_malloc(sizeof(*e));\n    e->context = ac;\n#if EV_MULTIPLICITY\n    e->loop = loop;\n#else\n    e->loop = NULL;\n#endif\n    e->reading = e->writing = 0;\n    e->rev.data = e;\n    e->wev.data = e;\n\n    /* Register functions to start/stop listening for events */\n    ac->ev.addRead = redisLibevAddRead;\n    ac->ev.delRead = redisLibevDelRead;\n    ac->ev.addWrite = redisLibevAddWrite;\n    ac->ev.delWrite = redisLibevDelWrite;\n    ac->ev.cleanup = redisLibevCleanup;\n    ac->ev.data = e;\n\n    /* Initialize read/write events */\n    ev_io_init(&e->rev,redisLibevReadEvent,c->fd,EV_READ);\n    ev_io_init(&e->wev,redisLibevWriteEvent,c->fd,EV_WRITE);\n    return REDIS_OK;\n}",
  "abstract_func_before": "static int redisLibevAttach(EV_P_ VAR_0 *VAR_1) {\n    redisContext *VAR_2 = &(VAR_1->c);\n    redisLibevEvents *VAR_3;\n\n    /* COMMENT_0 */\n    if (VAR_1->ev.data != NULL)\n        return VAR_4;\n\n    /* COMMENT_1 */\n    VAR_3 = (redisLibevEvents*)hiredis_safe_malloc(sizeof(*VAR_3));\n    VAR_3->context = VAR_1;\n#if VAR_5\n    VAR_3->loop = VAR_6;\n#else\n    VAR_3->loop = NULL;\n#endif\n    VAR_3->reading = VAR_3->writing = 0;\n    VAR_3->rev.data = VAR_3;\n    VAR_3->wev.data = VAR_3;\n\n    /* COMMENT_2 */\n    VAR_1->ev.addRead = VAR_7;\n    VAR_1->ev.delRead = VAR_8;\n    VAR_1->ev.addWrite = VAR_9;\n    VAR_1->ev.delWrite = VAR_10;\n    VAR_1->ev.cleanup = VAR_11;\n    VAR_1->ev.data = VAR_3;\n\n    /* COMMENT_3 */\n    ev_io_init(&VAR_3->rev,VAR_12,VAR_2->fd,VAR_13);\n    ev_io_init(&VAR_3->wev,VAR_14,VAR_2->fd,VAR_15);\n    return VAR_16;\n}",
  "func_graph_path_before": null,
  "func": "static int redisLibevAttach(EV_P_ redisAsyncContext *ac) {\n    redisContext *c = &(ac->c);\n    redisLibevEvents *e;\n\n    /* Nothing should be attached when something is already attached */\n    if (ac->ev.data != NULL)\n        return REDIS_ERR;\n\n    /* Create container for context and r/w events */\n    e = (redisLibevEvents*)hi_malloc(sizeof(*e));\n    e->context = ac;\n#if EV_MULTIPLICITY\n    e->loop = loop;\n#else\n    e->loop = NULL;\n#endif\n    e->reading = e->writing = 0;\n    e->rev.data = e;\n    e->wev.data = e;\n\n    /* Register functions to start/stop listening for events */\n    ac->ev.addRead = redisLibevAddRead;\n    ac->ev.delRead = redisLibevDelRead;\n    ac->ev.addWrite = redisLibevAddWrite;\n    ac->ev.delWrite = redisLibevDelWrite;\n    ac->ev.cleanup = redisLibevCleanup;\n    ac->ev.data = e;\n\n    /* Initialize read/write events */\n    ev_io_init(&e->rev,redisLibevReadEvent,c->fd,EV_READ);\n    ev_io_init(&e->wev,redisLibevWriteEvent,c->fd,EV_WRITE);\n    return REDIS_OK;\n}",
  "abstract_func": "static int redisLibevAttach(EV_P_ VAR_0 *VAR_1) {\n    redisContext *VAR_2 = &(VAR_1->c);\n    redisLibevEvents *VAR_3;\n\n    /* COMMENT_0 */\n    if (VAR_1->ev.data != NULL)\n        return VAR_4;\n\n    /* COMMENT_1 */\n    VAR_3 = (redisLibevEvents*)hi_malloc(sizeof(*VAR_3));\n    VAR_3->context = VAR_1;\n#if VAR_5\n    VAR_3->loop = VAR_6;\n#else\n    VAR_3->loop = NULL;\n#endif\n    VAR_3->reading = VAR_3->writing = 0;\n    VAR_3->rev.data = VAR_3;\n    VAR_3->wev.data = VAR_3;\n\n    /* COMMENT_2 */\n    VAR_1->ev.addRead = VAR_7;\n    VAR_1->ev.delRead = VAR_8;\n    VAR_1->ev.addWrite = VAR_9;\n    VAR_1->ev.delWrite = VAR_10;\n    VAR_1->ev.cleanup = VAR_11;\n    VAR_1->ev.data = VAR_3;\n\n    /* COMMENT_3 */\n    ev_io_init(&VAR_3->rev,VAR_12,VAR_2->fd,VAR_13);\n    ev_io_init(&VAR_3->wev,VAR_14,VAR_2->fd,VAR_15);\n    return VAR_16;\n}",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -7,7 +7,7 @@\n         return REDIS_ERR;\n \n     /* Create container for context and r/w events */\n-    e = (redisLibevEvents*)hiredis_safe_malloc(sizeof(*e));\n+    e = (redisLibevEvents*)hi_malloc(sizeof(*e));\n     e->context = ac;\n #if EV_MULTIPLICITY\n     e->loop = loop;",
  "diff_line_info": {
    "deleted_lines": [
      "    e = (redisLibevEvents*)hiredis_safe_malloc(sizeof(*e));"
    ],
    "added_lines": [
      "    e = (redisLibevEvents*)hi_malloc(sizeof(*e));"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/redis/hiredis/pull/754",
  "description": {
    "pr_info": {
      "title": "Safe allocation wrappers",
      "number": 754
    },
    "comment": [
      "Adds allocation wrappers that invokes a defined OOM handler.\r\n\r\nMy goal was the smallest surface area of changes possible.  Once we merge this it might be prudent to replace every `malloc`/`free` call with our wrappers.",
      "Just quoting the [last parts of the conversation in a merged PR](https://github.com/redis/hiredis/pull/752#issuecomment-577429138) from @michael-grunder \r\n\r\n>  @lamby I totally understand not wanting such a huge change just for a patch.\r\n\r\nThanks... and I think the changes in this PR would work for me. :+1: ",
      "Would be great to get some more eyes on this. :)",
      "> are we using asprintf and friends anywhere?\r\n\r\nNo, but `sds` has something similar (e.g. [sdscatfmt](https://github.com/redis/hiredis/blob/0501c623c91344e54cb2775a91509650960789b1/sds.c#L582)) although it appears that we're testing for NULL after every allocation/reallocation. \r\n\r\n",
      "Merged, thanks everyone!"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix\n\nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch introduces allocation wrappers to handle memory allocation failures, preventing potential security issues like null pointer dereferences. The code change replaces standard memory functions with custom wrappers that include OOM handling, enhancing memory safety.\n\nFinal Classification: Security Vulnerability Fix\n\nConfidence Score: 0.95"
}