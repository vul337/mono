{
  "cve_id": "CVE-2023-48795",
  "cwe_ids": [
    "CWE-354"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:H/A:N",
  "cvss_is_v3": true,
  "repo_name": "janmojzis/tinyssh",
  "commit_msg": "implementation kex-strict-s-v00@openssh.com",
  "commit_hash": "12ec08d24e43e382cb6d9b61facd87685f99eae0",
  "git_url": "https://github.com/janmojzis/tinyssh/commit/12ec08d24e43e382cb6d9b61facd87685f99eae0",
  "file_path": "tinyssh/packet_kexdh.c",
  "func_name": "packet_kexdh",
  "func_before": "int packet_kexdh(const char *keydir, struct buf *b1, struct buf *b2) {\n\n    unsigned char clientpk[sshcrypto_kem_PUBLICKEYMAX];\n    unsigned char serverpk[sshcrypto_kem_CIPHERTEXTMAX];\n    unsigned char sharedsecret[sshcrypto_kem_MAX];\n    unsigned char sm[sshcrypto_sign_MAX];\n    unsigned char key[sshcrypto_cipher_KEYMAX];\n    unsigned char hash[sshcrypto_hash_MAX];\n    long long pos = 0;\n    crypto_uint8 ch;\n    crypto_uint32 len;\n    long long i;\n\n    if (packet.kex_packet_follows && !packet.kex_guess) {\n        buf_purge(b1);\n        if (!packet_getall(b1, SSH_MSG_KEXDH_INIT)) return 0;\n    }\n\n    buf_purge(b1);\n    if (!packet_getall(b1, SSH_MSG_KEXDH_INIT)) return 0;\n    pos = packetparser_uint8(b1->buf, b1->len, pos, &ch);           /* byte      SSH_MSG_KEXDH_INIT */\n    if (ch != SSH_MSG_KEXDH_INIT) bug_proto();\n    pos = packetparser_uint32(b1->buf, b1->len, pos, &len);         /* string    client's public key */\n    if (len != sshcrypto_kem_publickeybytes) bug_proto();\n    pos = packetparser_copy(b1->buf, b1->len, pos, clientpk, len);\n    pos = packetparser_end(b1->buf, b1->len, pos);\n    buf_purge(b1);\n\n    /* generate key and compute shared secret */\n    do { \n        /* XXX - workaroud for bug in OpenSSH 6.5 - 6.6 */\n        if (sshcrypto_enc(serverpk, sharedsecret, clientpk) != 0) bug_proto();\n    } while(sharedsecret[0] == 0 && sshcrypto_kem_publickeybytes == 32);\n\n    /* create hash */\n    buf_purge(&packet.hashbuf);\n    buf_putstringlen(&packet.hashbuf, packet.helloreceive.buf, packet.helloreceive.len);\n    buf_putstringlen(&packet.hashbuf, packet.hellosend.buf, packet.hellosend.len);\n    buf_putstringlen(&packet.hashbuf, packet.kexrecv.buf, packet.kexrecv.len);\n    buf_putstringlen(&packet.hashbuf, packet.kexsend.buf, packet.kexsend.len);\n    sshcrypto_buf_putsignpk(&packet.hashbuf, sshcrypto_sign_publickey);\n    buf_putstringlen(&packet.hashbuf, clientpk, sshcrypto_kem_publickeybytes);\n    buf_putstringlen(&packet.hashbuf, serverpk, sshcrypto_kem_ciphertextbytes);\n    sshcrypto_buf_putkemkey(&packet.hashbuf, sharedsecret);\n    sshcrypto_hash(hash, packet.hashbuf.buf, packet.hashbuf.len);\n\n    /* session id */\n    if (!packet.flagrekeying) byte_copy(packet.sessionid, sshcrypto_hash_bytes, hash);\n    packet.flagrekeying = 1;\n\n    /* signature */\n    if (subprocess_sign(sm, sshcrypto_sign_bytes, keydir, hash, sshcrypto_hash_bytes) != 0) return 0;\n    buf_purge(b1); buf_purge(b2);\n\n    /* send server kex_ecdh_reply */\n    buf_putnum8(b2, SSH_MSG_KEXDH_REPLY);                           /* SSH_MSG_KEXDH_REPLY */\n    sshcrypto_buf_putsignpk(b2, sshcrypto_sign_publickey);          /* public key */\n    buf_putstringlen(b2, serverpk, sshcrypto_kem_ciphertextbytes);  /* servers's public key */\n    sshcrypto_buf_putsignature(b2, sm);                             /* signature */\n    packet_put(b2);\n\n    /* send server newkeys */\n    buf_purge(b2);\n    buf_putnum8(b2, SSH_MSG_NEWKEYS);\n    packet_put(b2);\n    if (!packet_sendall()) return 0;\n\n    /* receive new keys */\n    do {\n        buf_purge(b2);\n        if (!packet_getall(b2, 0)) return 0;\n    } while (b2->buf[0] != SSH_MSG_NEWKEYS);\n\n    /* key derivation */\n    for(i = 0; i < 6; ++i) {\n        buf_purge(b1);\n        sshcrypto_buf_putkemkey(b1, sharedsecret);\n        buf_put(b1, hash, sshcrypto_hash_bytes);\n        buf_putnum8(b1, 'A' + i);\n        buf_put(b1, packet.sessionid, sshcrypto_hash_bytes);\n        sshcrypto_hash(key, b1->buf, b1->len);\n\n        /* one extend */\n        buf_purge(b1);\n        sshcrypto_buf_putkemkey(b1, sharedsecret);\n        buf_put(b1, hash, sshcrypto_hash_bytes);\n        buf_put(b1, key, sshcrypto_hash_bytes);\n        sshcrypto_hash(key + sshcrypto_hash_bytes, b1->buf, b1->len);\n\n        if (i == 0) byte_copy(packet.clientnonce, sshcrypto_cipher_KEYMAX, key);\n        if (i == 1) byte_copy(packet.servernonce, sshcrypto_cipher_KEYMAX, key);\n        if (i == 2) byte_copy(packet.clientkey, sshcrypto_cipher_KEYMAX, key);\n        if (i == 3) byte_copy(packet.serverkey, sshcrypto_cipher_KEYMAX, key);\n        if (i == 4) byte_copy(packet.clientmackey, sshcrypto_cipher_KEYMAX, key);\n        if (i == 5) byte_copy(packet.servermackey, sshcrypto_cipher_KEYMAX, key);\n    }\n\n    purge(clientpk, sizeof clientpk);\n    purge(serverpk, sizeof serverpk);\n    purge(sharedsecret, sizeof sharedsecret);\n    purge(sm, sizeof sm);\n    purge(key, sizeof key);\n    purge(hash, sizeof hash);\n    return 1;\n}",
  "abstract_func_before": "int packet_kexdh(const char *VAR_0, struct buf *VAR_1, struct buf *VAR_2) {\n\n    unsigned char VAR_3[VAR_4];\n    unsigned char VAR_5[VAR_6];\n    unsigned char VAR_7[VAR_8];\n    unsigned char VAR_9[VAR_10];\n    unsigned char VAR_11[VAR_12];\n    unsigned char VAR_13[VAR_14];\n    long long VAR_15 = 0;\n    crypto_uint8 VAR_16;\n    crypto_uint32 VAR_17;\n    long long VAR_18;\n\n    if (VAR_19.kex_packet_follows && !VAR_19.kex_guess) {\n        buf_purge(VAR_1);\n        if (!packet_getall(VAR_1, VAR_20)) return 0;\n    }\n\n    buf_purge(VAR_1);\n    if (!packet_getall(VAR_1, VAR_20)) return 0;\n    VAR_15 = packetparser_uint8(VAR_1->buf, VAR_1->len, VAR_15, &VAR_16);           /* COMMENT_0 */\n    if (VAR_16 != VAR_20) bug_proto();\n    VAR_15 = packetparser_uint32(VAR_1->buf, VAR_1->len, VAR_15, &VAR_17);         /* COMMENT_1 */\n    if (VAR_17 != VAR_21) bug_proto();\n    VAR_15 = packetparser_copy(VAR_1->buf, VAR_1->len, VAR_15, VAR_3, VAR_17);\n    VAR_15 = packetparser_end(VAR_1->buf, VAR_1->len, VAR_15);\n    buf_purge(VAR_1);\n\n    /* COMMENT_2 */\n    do { \n        /* COMMENT_3 */\n        if (sshcrypto_enc(VAR_5, VAR_7, VAR_3) != 0) bug_proto();\n    } while(VAR_7[0] == 0 && VAR_21 == 32);\n\n    /* COMMENT_4 */\n    buf_purge(&VAR_19.hashbuf);\n    buf_putstringlen(&VAR_19.hashbuf, VAR_19.helloreceive.buf, VAR_19.helloreceive.len);\n    buf_putstringlen(&VAR_19.hashbuf, VAR_19.hellosend.buf, VAR_19.hellosend.len);\n    buf_putstringlen(&VAR_19.hashbuf, VAR_19.kexrecv.buf, VAR_19.kexrecv.len);\n    buf_putstringlen(&VAR_19.hashbuf, VAR_19.kexsend.buf, VAR_19.kexsend.len);\n    sshcrypto_buf_putsignpk(&VAR_19.hashbuf, VAR_22);\n    buf_putstringlen(&VAR_19.hashbuf, VAR_3, VAR_21);\n    buf_putstringlen(&VAR_19.hashbuf, VAR_5, VAR_23);\n    sshcrypto_buf_putkemkey(&VAR_19.hashbuf, VAR_7);\n    sshcrypto_hash(VAR_13, VAR_19.hashbuf.buf, VAR_19.hashbuf.len);\n\n    /* COMMENT_5 */\n    if (!VAR_19.flagrekeying) byte_copy(VAR_19.sessionid, VAR_24, VAR_13);\n    VAR_19.flagrekeying = 1;\n\n    /* COMMENT_6 */\n    if (subprocess_sign(VAR_9, VAR_25, VAR_0, VAR_13, VAR_24) != 0) return 0;\n    buf_purge(VAR_1); buf_purge(VAR_2);\n\n    /* COMMENT_7 */\n    buf_putnum8(VAR_2, VAR_26);                           /* COMMENT_8 */\n    sshcrypto_buf_putsignpk(VAR_2, VAR_22);          /* COMMENT_9 */\n    buf_putstringlen(VAR_2, VAR_5, VAR_23);  /* COMMENT_10 */\n    sshcrypto_buf_putsignature(VAR_2, VAR_9);                             /* COMMENT_6 */\n    packet_put(VAR_2);\n\n    /* COMMENT_11 */\n    buf_purge(VAR_2);\n    buf_putnum8(VAR_2, VAR_27);\n    packet_put(VAR_2);\n    if (!packet_sendall()) return 0;\n\n    /* COMMENT_12 */\n    do {\n        buf_purge(VAR_2);\n        if (!packet_getall(VAR_2, 0)) return 0;\n    } while (VAR_2->buf[0] != VAR_27);\n\n    /* COMMENT_13 */\n    for(VAR_18 = 0; VAR_18 < 6; ++VAR_18) {\n        buf_purge(VAR_1);\n        sshcrypto_buf_putkemkey(VAR_1, VAR_7);\n        buf_put(VAR_1, VAR_13, VAR_24);\n        buf_putnum8(VAR_1, 'A' + VAR_18);\n        buf_put(VAR_1, VAR_19.sessionid, VAR_24);\n        sshcrypto_hash(VAR_11, VAR_1->buf, VAR_1->len);\n\n        /* COMMENT_14 */\n        buf_purge(VAR_1);\n        sshcrypto_buf_putkemkey(VAR_1, VAR_7);\n        buf_put(VAR_1, VAR_13, VAR_24);\n        buf_put(VAR_1, VAR_11, VAR_24);\n        sshcrypto_hash(VAR_11 + VAR_24, VAR_1->buf, VAR_1->len);\n\n        if (VAR_18 == 0) byte_copy(VAR_19.clientnonce, VAR_12, VAR_11);\n        if (VAR_18 == 1) byte_copy(VAR_19.servernonce, VAR_12, VAR_11);\n        if (VAR_18 == 2) byte_copy(VAR_19.clientkey, VAR_12, VAR_11);\n        if (VAR_18 == 3) byte_copy(VAR_19.serverkey, VAR_12, VAR_11);\n        if (VAR_18 == 4) byte_copy(VAR_19.clientmackey, VAR_12, VAR_11);\n        if (VAR_18 == 5) byte_copy(VAR_19.servermackey, VAR_12, VAR_11);\n    }\n\n    purge(VAR_3, sizeof VAR_3);\n    purge(VAR_5, sizeof VAR_5);\n    purge(VAR_7, sizeof VAR_7);\n    purge(VAR_9, sizeof VAR_9);\n    purge(VAR_11, sizeof VAR_11);\n    purge(VAR_13, sizeof VAR_13);\n    return 1;\n}",
  "func_graph_path_before": "janmojzis/tinyssh/12ec08d24e43e382cb6d9b61facd87685f99eae0/packet_kexdh.c/vul/before/0.json",
  "func": "int packet_kexdh(const char *keydir, struct buf *b1, struct buf *b2) {\n\n    unsigned char clientpk[sshcrypto_kem_PUBLICKEYMAX];\n    unsigned char serverpk[sshcrypto_kem_CIPHERTEXTMAX];\n    unsigned char sharedsecret[sshcrypto_kem_MAX];\n    unsigned char sm[sshcrypto_sign_MAX];\n    unsigned char key[sshcrypto_cipher_KEYMAX];\n    unsigned char hash[sshcrypto_hash_MAX];\n    long long pos = 0;\n    crypto_uint8 ch;\n    crypto_uint32 len;\n    long long i;\n\n    if (packet.kex_packet_follows && !packet.kex_guess) {\n        buf_purge(b1);\n        if (!packet_getall(b1, SSH_MSG_KEXDH_INIT)) return 0;\n    }\n\n    buf_purge(b1);\n    if (!packet_getall(b1, SSH_MSG_KEXDH_INIT)) return 0;\n    pos = packetparser_uint8(b1->buf, b1->len, pos, &ch);           /* byte      SSH_MSG_KEXDH_INIT */\n    if (ch != SSH_MSG_KEXDH_INIT) bug_proto();\n    pos = packetparser_uint32(b1->buf, b1->len, pos, &len);         /* string    client's public key */\n    if (len != sshcrypto_kem_publickeybytes) bug_proto();\n    pos = packetparser_copy(b1->buf, b1->len, pos, clientpk, len);\n    pos = packetparser_end(b1->buf, b1->len, pos);\n    buf_purge(b1);\n\n    /* generate key and compute shared secret */\n    do { \n        /* XXX - workaroud for bug in OpenSSH 6.5 - 6.6 */\n        if (sshcrypto_enc(serverpk, sharedsecret, clientpk) != 0) bug_proto();\n    } while(sharedsecret[0] == 0 && sshcrypto_kem_publickeybytes == 32);\n\n    /* create hash */\n    buf_purge(&packet.hashbuf);\n    buf_putstringlen(&packet.hashbuf, packet.helloreceive.buf, packet.helloreceive.len);\n    buf_putstringlen(&packet.hashbuf, packet.hellosend.buf, packet.hellosend.len);\n    buf_putstringlen(&packet.hashbuf, packet.kexrecv.buf, packet.kexrecv.len);\n    buf_putstringlen(&packet.hashbuf, packet.kexsend.buf, packet.kexsend.len);\n    sshcrypto_buf_putsignpk(&packet.hashbuf, sshcrypto_sign_publickey);\n    buf_putstringlen(&packet.hashbuf, clientpk, sshcrypto_kem_publickeybytes);\n    buf_putstringlen(&packet.hashbuf, serverpk, sshcrypto_kem_ciphertextbytes);\n    sshcrypto_buf_putkemkey(&packet.hashbuf, sharedsecret);\n    sshcrypto_hash(hash, packet.hashbuf.buf, packet.hashbuf.len);\n\n    /* session id */\n    if (!packet.flagrekeying) byte_copy(packet.sessionid, sshcrypto_hash_bytes, hash);\n    packet.flagrekeying = 1;\n\n    /* signature */\n    if (subprocess_sign(sm, sshcrypto_sign_bytes, keydir, hash, sshcrypto_hash_bytes) != 0) return 0;\n    buf_purge(b1); buf_purge(b2);\n\n    /* send server kex_ecdh_reply */\n    buf_putnum8(b2, SSH_MSG_KEXDH_REPLY);                           /* SSH_MSG_KEXDH_REPLY */\n    sshcrypto_buf_putsignpk(b2, sshcrypto_sign_publickey);          /* public key */\n    buf_putstringlen(b2, serverpk, sshcrypto_kem_ciphertextbytes);  /* servers's public key */\n    sshcrypto_buf_putsignature(b2, sm);                             /* signature */\n    packet_put(b2);\n\n    /* send server newkeys */\n    buf_purge(b2);\n    buf_putnum8(b2, SSH_MSG_NEWKEYS);\n    packet_put(b2);\n    if (!packet_sendall()) return 0;\n\n    /* receive new keys */\n    do {\n        buf_purge(b2);\n        if (!packet_getall(b2, 0)) return 0;\n    } while (b2->buf[0] != SSH_MSG_NEWKEYS);\n\n\n    /* key derivation */\n    for(i = 0; i < 6; ++i) {\n        buf_purge(b1);\n        sshcrypto_buf_putkemkey(b1, sharedsecret);\n        buf_put(b1, hash, sshcrypto_hash_bytes);\n        buf_putnum8(b1, 'A' + i);\n        buf_put(b1, packet.sessionid, sshcrypto_hash_bytes);\n        sshcrypto_hash(key, b1->buf, b1->len);\n\n        /* one extend */\n        buf_purge(b1);\n        sshcrypto_buf_putkemkey(b1, sharedsecret);\n        buf_put(b1, hash, sshcrypto_hash_bytes);\n        buf_put(b1, key, sshcrypto_hash_bytes);\n        sshcrypto_hash(key + sshcrypto_hash_bytes, b1->buf, b1->len);\n\n        if (i == 0) byte_copy(packet.clientnonce, sshcrypto_cipher_KEYMAX, key);\n        if (i == 1) byte_copy(packet.servernonce, sshcrypto_cipher_KEYMAX, key);\n        if (i == 2) byte_copy(packet.clientkey, sshcrypto_cipher_KEYMAX, key);\n        if (i == 3) byte_copy(packet.serverkey, sshcrypto_cipher_KEYMAX, key);\n        if (i == 4) byte_copy(packet.clientmackey, sshcrypto_cipher_KEYMAX, key);\n        if (i == 5) byte_copy(packet.servermackey, sshcrypto_cipher_KEYMAX, key);\n    }\n\n    purge(clientpk, sizeof clientpk);\n    purge(serverpk, sizeof serverpk);\n    purge(sharedsecret, sizeof sharedsecret);\n    purge(sm, sizeof sm);\n    purge(key, sizeof key);\n    purge(hash, sizeof hash);\n    return 1;\n}",
  "abstract_func": "int packet_kexdh(const char *VAR_0, struct buf *VAR_1, struct buf *VAR_2) {\n\n    unsigned char VAR_3[VAR_4];\n    unsigned char VAR_5[VAR_6];\n    unsigned char VAR_7[VAR_8];\n    unsigned char VAR_9[VAR_10];\n    unsigned char VAR_11[VAR_12];\n    unsigned char VAR_13[VAR_14];\n    long long VAR_15 = 0;\n    crypto_uint8 VAR_16;\n    crypto_uint32 VAR_17;\n    long long VAR_18;\n\n    if (VAR_19.kex_packet_follows && !VAR_19.kex_guess) {\n        buf_purge(VAR_1);\n        if (!packet_getall(VAR_1, VAR_20)) return 0;\n    }\n\n    buf_purge(VAR_1);\n    if (!packet_getall(VAR_1, VAR_20)) return 0;\n    VAR_15 = packetparser_uint8(VAR_1->buf, VAR_1->len, VAR_15, &VAR_16);           /* COMMENT_0 */\n    if (VAR_16 != VAR_20) bug_proto();\n    VAR_15 = packetparser_uint32(VAR_1->buf, VAR_1->len, VAR_15, &VAR_17);         /* COMMENT_1 */\n    if (VAR_17 != VAR_21) bug_proto();\n    VAR_15 = packetparser_copy(VAR_1->buf, VAR_1->len, VAR_15, VAR_3, VAR_17);\n    VAR_15 = packetparser_end(VAR_1->buf, VAR_1->len, VAR_15);\n    buf_purge(VAR_1);\n\n    /* COMMENT_2 */\n    do { \n        /* COMMENT_3 */\n        if (sshcrypto_enc(VAR_5, VAR_7, VAR_3) != 0) bug_proto();\n    } while(VAR_7[0] == 0 && VAR_21 == 32);\n\n    /* COMMENT_4 */\n    buf_purge(&VAR_19.hashbuf);\n    buf_putstringlen(&VAR_19.hashbuf, VAR_19.helloreceive.buf, VAR_19.helloreceive.len);\n    buf_putstringlen(&VAR_19.hashbuf, VAR_19.hellosend.buf, VAR_19.hellosend.len);\n    buf_putstringlen(&VAR_19.hashbuf, VAR_19.kexrecv.buf, VAR_19.kexrecv.len);\n    buf_putstringlen(&VAR_19.hashbuf, VAR_19.kexsend.buf, VAR_19.kexsend.len);\n    sshcrypto_buf_putsignpk(&VAR_19.hashbuf, VAR_22);\n    buf_putstringlen(&VAR_19.hashbuf, VAR_3, VAR_21);\n    buf_putstringlen(&VAR_19.hashbuf, VAR_5, VAR_23);\n    sshcrypto_buf_putkemkey(&VAR_19.hashbuf, VAR_7);\n    sshcrypto_hash(VAR_13, VAR_19.hashbuf.buf, VAR_19.hashbuf.len);\n\n    /* COMMENT_5 */\n    if (!VAR_19.flagrekeying) byte_copy(VAR_19.sessionid, VAR_24, VAR_13);\n    VAR_19.flagrekeying = 1;\n\n    /* COMMENT_6 */\n    if (subprocess_sign(VAR_9, VAR_25, VAR_0, VAR_13, VAR_24) != 0) return 0;\n    buf_purge(VAR_1); buf_purge(VAR_2);\n\n    /* COMMENT_7 */\n    buf_putnum8(VAR_2, VAR_26);                           /* COMMENT_8 */\n    sshcrypto_buf_putsignpk(VAR_2, VAR_22);          /* COMMENT_9 */\n    buf_putstringlen(VAR_2, VAR_5, VAR_23);  /* COMMENT_10 */\n    sshcrypto_buf_putsignature(VAR_2, VAR_9);                             /* COMMENT_6 */\n    packet_put(VAR_2);\n\n    /* COMMENT_11 */\n    buf_purge(VAR_2);\n    buf_putnum8(VAR_2, VAR_27);\n    packet_put(VAR_2);\n    if (!packet_sendall()) return 0;\n\n    /* COMMENT_12 */\n    do {\n        buf_purge(VAR_2);\n        if (!packet_getall(VAR_2, 0)) return 0;\n    } while (VAR_2->buf[0] != VAR_27);\n\n\n    /* COMMENT_13 */\n    for(VAR_18 = 0; VAR_18 < 6; ++VAR_18) {\n        buf_purge(VAR_1);\n        sshcrypto_buf_putkemkey(VAR_1, VAR_7);\n        buf_put(VAR_1, VAR_13, VAR_24);\n        buf_putnum8(VAR_1, 'A' + VAR_18);\n        buf_put(VAR_1, VAR_19.sessionid, VAR_24);\n        sshcrypto_hash(VAR_11, VAR_1->buf, VAR_1->len);\n\n        /* COMMENT_14 */\n        buf_purge(VAR_1);\n        sshcrypto_buf_putkemkey(VAR_1, VAR_7);\n        buf_put(VAR_1, VAR_13, VAR_24);\n        buf_put(VAR_1, VAR_11, VAR_24);\n        sshcrypto_hash(VAR_11 + VAR_24, VAR_1->buf, VAR_1->len);\n\n        if (VAR_18 == 0) byte_copy(VAR_19.clientnonce, VAR_12, VAR_11);\n        if (VAR_18 == 1) byte_copy(VAR_19.servernonce, VAR_12, VAR_11);\n        if (VAR_18 == 2) byte_copy(VAR_19.clientkey, VAR_12, VAR_11);\n        if (VAR_18 == 3) byte_copy(VAR_19.serverkey, VAR_12, VAR_11);\n        if (VAR_18 == 4) byte_copy(VAR_19.clientmackey, VAR_12, VAR_11);\n        if (VAR_18 == 5) byte_copy(VAR_19.servermackey, VAR_12, VAR_11);\n    }\n\n    purge(VAR_3, sizeof VAR_3);\n    purge(VAR_5, sizeof VAR_5);\n    purge(VAR_7, sizeof VAR_7);\n    purge(VAR_9, sizeof VAR_9);\n    purge(VAR_11, sizeof VAR_11);\n    purge(VAR_13, sizeof VAR_13);\n    return 1;\n}",
  "func_graph_path": "janmojzis/tinyssh/12ec08d24e43e382cb6d9b61facd87685f99eae0/packet_kexdh.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -71,6 +71,7 @@\n         if (!packet_getall(b2, 0)) return 0;\n     } while (b2->buf[0] != SSH_MSG_NEWKEYS);\n \n+\n     /* key derivation */\n     for(i = 0; i < 6; ++i) {\n         buf_purge(b1);",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/janmojzis/tinyssh/pull/82",
  "description": {
    "pr_info": {
      "title": "implementation kex-strict-s-v00@openssh.com",
      "number": 82
    },
    "comment": [
      "Add new KEX kex-strict-s-v00@openssh.com protocol.\r\n'Terrapin Attack'  mitigation CVE-2023-48795.\r\nFixes https://github.com/janmojzis/tinyssh/issues/81\r\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix\nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\nThe patch introduces a new KEX protocol to mitigate a known security vulnerability, specifically addressing CVE-2023-48795. The code changes are functional and directly aimed at enhancing security by preventing the \"Terrapin Attack.\"\n\n**Final Output:**\nAnalysis: The patch implements a new key exchange protocol to address a security vulnerability (CVE-2023-48795), indicating a security fix.\nFinal Classification: Security Vulnerability Fix\nConfidence Score: 0.95"
}