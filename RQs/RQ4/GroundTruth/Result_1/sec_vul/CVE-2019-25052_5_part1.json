{
  "cve_id": "CVE-2019-25052",
  "cwe_ids": [
    "CWE-327"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "OP-TEE/optee_os",
  "commit_msg": "cryp: prevent direct calls to update and final functions\n\nWith inconsistent or malformed data it has been possible to call\n\"update\" and \"final\" crypto functions directly. Using a fuzzer tool [1]\nwe have seen that this results in asserts, i.e., a crash that\npotentially could leak sensitive information.\n\nBy setting the state (initialized) in the crypto context (i.e., the\ntee_cryp_state) at the end of all syscall_*_init functions and then add\na check of the state at the beginning of all update and final functions,\n  we prevent direct entrance to the \"update\" and \"final\" functions.\n\n[1] https://github.com/MartijnB/optee_fuzzer\n\nFixes: OP-TEE-2019-0021\n\nSigned-off-by: Joakim Bech <joakim.bech@linaro.org>\nReported-by: Martijn Bogaard <bogaard@riscure.com>\nAcked-by: Jerome Forissier <jerome.forissier@linaro.org>\nReviewed-by: Jens Wiklander <jens.wiklander@linaro.org>",
  "commit_hash": "34a08bec755670ea0490cb53bbc68058cafc69b6",
  "git_url": "https://github.com/OP-TEE/optee_os/commit/34a08bec755670ea0490cb53bbc68058cafc69b6",
  "file_path": "core/tee/tee_svc_cryp.c",
  "func_name": "syscall_hash_final",
  "func_before": "TEE_Result syscall_hash_final(unsigned long state, const void *chunk,\n\t\t\tsize_t chunk_size, void *hash, uint64_t *hash_len)\n{\n\tTEE_Result res, res2;\n\tsize_t hash_size;\n\tsize_t hlen = 0;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\n\t/* No data, but size provided isn't valid parameters. */\n\tif (!chunk && chunk_size)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)chunk, chunk_size);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = get_user_u64_as_size_t(&hlen, hash_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)hash, hlen);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tswitch (TEE_ALG_GET_CLASS(cs->algo)) {\n\tcase TEE_OPERATION_DIGEST:\n\t\tres = tee_hash_get_digest_size(cs->algo, &hash_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tif (hlen < hash_size) {\n\t\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (chunk_size) {\n\t\t\tres = crypto_hash_update(cs->ctx, cs->algo, chunk,\n\t\t\t\t\t\t chunk_size);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t}\n\n\t\tres = crypto_hash_final(cs->ctx, cs->algo, hash, hash_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\n\tcase TEE_OPERATION_MAC:\n\t\tres = tee_mac_get_digest_size(cs->algo, &hash_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tif (hlen < hash_size) {\n\t\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (chunk_size) {\n\t\t\tres = crypto_mac_update(cs->ctx, cs->algo, chunk,\n\t\t\t\t\t\tchunk_size);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t}\n\n\t\tres = crypto_mac_final(cs->ctx, cs->algo, hash, hash_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\n\tdefault:\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\nout:\n\tres2 = put_user_u64(hash_len, hash_size);\n\tif (res2 != TEE_SUCCESS)\n\t\treturn res2;\n\treturn res;\n}",
  "abstract_func_before": "TEE_Result syscall_hash_final(unsigned long VAR_0, const void *VAR_1,\n\t\t\tsize_t VAR_2, void *VAR_3, uint64_t *VAR_4)\n{\n\tTEE_Result VAR_5, VAR_6;\n\tsize_t VAR_7;\n\tsize_t VAR_8 = 0;\n\tstruct tee_cryp_state *VAR_9;\n\tstruct tee_ta_session *VAR_10;\n\n\t/* COMMENT_0 */\n\tif (!VAR_1 && VAR_2)\n\t\treturn VAR_11;\n\n\tVAR_5 = tee_ta_get_current_session(&VAR_10);\n\tif (VAR_5 != VAR_12)\n\t\treturn VAR_5;\n\n\tVAR_5 = tee_mmu_check_access_rights(to_user_ta_ctx(VAR_10->ctx),\n\t\t\t\t\t  VAR_13 |\n\t\t\t\t\t  VAR_14,\n\t\t\t\t\t  (uaddr_t)VAR_1, VAR_2);\n\tif (VAR_5 != VAR_12)\n\t\treturn VAR_5;\n\n\tVAR_5 = get_user_u64_as_size_t(&VAR_8, VAR_4);\n\tif (VAR_5 != VAR_12)\n\t\treturn VAR_5;\n\n\tVAR_5 = tee_mmu_check_access_rights(to_user_ta_ctx(VAR_10->ctx),\n\t\t\t\t\t  VAR_13 |\n\t\t\t\t\t  VAR_15 |\n\t\t\t\t\t  VAR_14,\n\t\t\t\t\t  (uaddr_t)VAR_3, VAR_8);\n\tif (VAR_5 != VAR_12)\n\t\treturn VAR_5;\n\n\tVAR_5 = tee_svc_cryp_get_state(VAR_10, tee_svc_uref_to_vaddr(VAR_0), &VAR_9);\n\tif (VAR_5 != VAR_12)\n\t\treturn VAR_5;\n\n\tswitch (TEE_ALG_GET_CLASS(VAR_9->algo)) {\n\tcase VAR_16:\n\t\tVAR_5 = tee_hash_get_digest_size(VAR_9->algo, &VAR_7);\n\t\tif (VAR_5 != VAR_12)\n\t\t\treturn VAR_5;\n\t\tif (VAR_8 < VAR_7) {\n\t\t\tVAR_5 = VAR_17;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (VAR_2) {\n\t\t\tVAR_5 = crypto_hash_update(VAR_9->ctx, VAR_9->algo, VAR_1,\n\t\t\t\t\t\t VAR_2);\n\t\t\tif (VAR_5 != VAR_12)\n\t\t\t\treturn VAR_5;\n\t\t}\n\n\t\tVAR_5 = crypto_hash_final(VAR_9->ctx, VAR_9->algo, VAR_3, VAR_7);\n\t\tif (VAR_5 != VAR_12)\n\t\t\treturn VAR_5;\n\t\tbreak;\n\n\tcase VAR_18:\n\t\tVAR_5 = tee_mac_get_digest_size(VAR_9->algo, &VAR_7);\n\t\tif (VAR_5 != VAR_12)\n\t\t\treturn VAR_5;\n\t\tif (VAR_8 < VAR_7) {\n\t\t\tVAR_5 = VAR_17;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (VAR_2) {\n\t\t\tVAR_5 = crypto_mac_update(VAR_9->ctx, VAR_9->algo, VAR_1,\n\t\t\t\t\t\tVAR_2);\n\t\t\tif (VAR_5 != VAR_12)\n\t\t\t\treturn VAR_5;\n\t\t}\n\n\t\tVAR_5 = crypto_mac_final(VAR_9->ctx, VAR_9->algo, VAR_3, VAR_7);\n\t\tif (VAR_5 != VAR_12)\n\t\t\treturn VAR_5;\n\t\tbreak;\n\n\tdefault:\n\t\treturn VAR_11;\n\t}\nout:\n\tVAR_6 = put_user_u64(VAR_4, VAR_7);\n\tif (VAR_6 != VAR_12)\n\t\treturn VAR_6;\n\treturn VAR_5;\n}",
  "func_graph_path_before": "OP-TEE/optee_os/34a08bec755670ea0490cb53bbc68058cafc69b6/tee_svc_cryp.c/vul/before/6.json",
  "func": "TEE_Result syscall_hash_final(unsigned long state, const void *chunk,\n\t\t\tsize_t chunk_size, void *hash, uint64_t *hash_len)\n{\n\tTEE_Result res, res2;\n\tsize_t hash_size;\n\tsize_t hlen = 0;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\n\t/* No data, but size provided isn't valid parameters. */\n\tif (!chunk && chunk_size)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)chunk, chunk_size);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = get_user_u64_as_size_t(&hlen, hash_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)hash, hlen);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (cs->state != CRYP_STATE_INITIALIZED)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tswitch (TEE_ALG_GET_CLASS(cs->algo)) {\n\tcase TEE_OPERATION_DIGEST:\n\t\tres = tee_hash_get_digest_size(cs->algo, &hash_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tif (hlen < hash_size) {\n\t\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (chunk_size) {\n\t\t\tres = crypto_hash_update(cs->ctx, cs->algo, chunk,\n\t\t\t\t\t\t chunk_size);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t}\n\n\t\tres = crypto_hash_final(cs->ctx, cs->algo, hash, hash_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\n\tcase TEE_OPERATION_MAC:\n\t\tres = tee_mac_get_digest_size(cs->algo, &hash_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tif (hlen < hash_size) {\n\t\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (chunk_size) {\n\t\t\tres = crypto_mac_update(cs->ctx, cs->algo, chunk,\n\t\t\t\t\t\tchunk_size);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t}\n\n\t\tres = crypto_mac_final(cs->ctx, cs->algo, hash, hash_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\n\tdefault:\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\nout:\n\tres2 = put_user_u64(hash_len, hash_size);\n\tif (res2 != TEE_SUCCESS)\n\t\treturn res2;\n\treturn res;\n}",
  "abstract_func": "TEE_Result syscall_hash_final(unsigned long VAR_0, const void *VAR_1,\n\t\t\tsize_t VAR_2, void *VAR_3, uint64_t *VAR_4)\n{\n\tTEE_Result VAR_5, VAR_6;\n\tsize_t VAR_7;\n\tsize_t VAR_8 = 0;\n\tstruct tee_cryp_state *VAR_9;\n\tstruct tee_ta_session *VAR_10;\n\n\t/* COMMENT_0 */\n\tif (!VAR_1 && VAR_2)\n\t\treturn VAR_11;\n\n\tVAR_5 = tee_ta_get_current_session(&VAR_10);\n\tif (VAR_5 != VAR_12)\n\t\treturn VAR_5;\n\n\tVAR_5 = tee_mmu_check_access_rights(to_user_ta_ctx(VAR_10->ctx),\n\t\t\t\t\t  VAR_13 |\n\t\t\t\t\t  VAR_14,\n\t\t\t\t\t  (uaddr_t)VAR_1, VAR_2);\n\tif (VAR_5 != VAR_12)\n\t\treturn VAR_5;\n\n\tVAR_5 = get_user_u64_as_size_t(&VAR_8, VAR_4);\n\tif (VAR_5 != VAR_12)\n\t\treturn VAR_5;\n\n\tVAR_5 = tee_mmu_check_access_rights(to_user_ta_ctx(VAR_10->ctx),\n\t\t\t\t\t  VAR_13 |\n\t\t\t\t\t  VAR_15 |\n\t\t\t\t\t  VAR_14,\n\t\t\t\t\t  (uaddr_t)VAR_3, VAR_8);\n\tif (VAR_5 != VAR_12)\n\t\treturn VAR_5;\n\n\tVAR_5 = tee_svc_cryp_get_state(VAR_10, tee_svc_uref_to_vaddr(VAR_0), &VAR_9);\n\tif (VAR_5 != VAR_12)\n\t\treturn VAR_5;\n\n\tif (VAR_9->state != VAR_16)\n\t\treturn VAR_17;\n\n\tswitch (TEE_ALG_GET_CLASS(VAR_9->algo)) {\n\tcase VAR_18:\n\t\tVAR_5 = tee_hash_get_digest_size(VAR_9->algo, &VAR_7);\n\t\tif (VAR_5 != VAR_12)\n\t\t\treturn VAR_5;\n\t\tif (VAR_8 < VAR_7) {\n\t\t\tVAR_5 = VAR_19;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (VAR_2) {\n\t\t\tVAR_5 = crypto_hash_update(VAR_9->ctx, VAR_9->algo, VAR_1,\n\t\t\t\t\t\t VAR_2);\n\t\t\tif (VAR_5 != VAR_12)\n\t\t\t\treturn VAR_5;\n\t\t}\n\n\t\tVAR_5 = crypto_hash_final(VAR_9->ctx, VAR_9->algo, VAR_3, VAR_7);\n\t\tif (VAR_5 != VAR_12)\n\t\t\treturn VAR_5;\n\t\tbreak;\n\n\tcase VAR_20:\n\t\tVAR_5 = tee_mac_get_digest_size(VAR_9->algo, &VAR_7);\n\t\tif (VAR_5 != VAR_12)\n\t\t\treturn VAR_5;\n\t\tif (VAR_8 < VAR_7) {\n\t\t\tVAR_5 = VAR_19;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (VAR_2) {\n\t\t\tVAR_5 = crypto_mac_update(VAR_9->ctx, VAR_9->algo, VAR_1,\n\t\t\t\t\t\tVAR_2);\n\t\t\tif (VAR_5 != VAR_12)\n\t\t\t\treturn VAR_5;\n\t\t}\n\n\t\tVAR_5 = crypto_mac_final(VAR_9->ctx, VAR_9->algo, VAR_3, VAR_7);\n\t\tif (VAR_5 != VAR_12)\n\t\t\treturn VAR_5;\n\t\tbreak;\n\n\tdefault:\n\t\treturn VAR_11;\n\t}\nout:\n\tVAR_6 = put_user_u64(VAR_4, VAR_7);\n\tif (VAR_6 != VAR_12)\n\t\treturn VAR_6;\n\treturn VAR_5;\n}",
  "func_graph_path": "OP-TEE/optee_os/34a08bec755670ea0490cb53bbc68058cafc69b6/tee_svc_cryp.c/vul/after/6.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -37,6 +37,9 @@\n \tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n \tif (res != TEE_SUCCESS)\n \t\treturn res;\n+\n+\tif (cs->state != CRYP_STATE_INITIALIZED)\n+\t\treturn TEE_ERROR_BAD_STATE;\n \n \tswitch (TEE_ALG_GET_CLASS(cs->algo)) {\n \tcase TEE_OPERATION_DIGEST:",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "",
      "\tif (cs->state != CRYP_STATE_INITIALIZED)",
      "\t\treturn TEE_ERROR_BAD_STATE;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/OP-TEE/optee_os/pull/3316",
  "description": {
    "pr_info": {
      "title": "Riscure fuzzer vuln",
      "number": 3316
    },
    "comment": [
      "Fixes for potential security issues found by Riscure's fuzzer tool.\r\n\r\nI've tested this in QEMU v7, no regressions seen.\r\n```bash\r\n24105 subtests of which 0 failed\r\n96 test cases of which 0 failed\r\n0 test cases were skipped\r\nTEE test application done!\r\n```",
      "Squashed, rebased and tag(s) applied (should be) ready for merge! Thanks!"
    ]
  },
  "Bug Filter": "** Security Vulnerability Fix  \n**Confidence Score:** 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\nThe patch addresses a security issue where direct calls to crypto functions could cause crashes and information leaks. The added state check prevents unauthorized access to these functions, mitigating a security vulnerability.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 0.95"
}