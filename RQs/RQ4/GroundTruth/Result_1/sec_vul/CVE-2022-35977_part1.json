{
  "cve_id": "CVE-2022-35977",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "redis",
  "commit_msg": "Avoid integer overflows in SETRANGE and SORT (CVE-2022-35977) (#11720)\n\nAuthenticated users issuing specially crafted SETRANGE and SORT(_RO)\r\ncommands can trigger an integer overflow, resulting with Redis attempting\r\nto allocate impossible amounts of memory and abort with an OOM panic.",
  "commit_hash": "1ec82e6e97e1db06a72ca505f9fbf6b981f31ef7",
  "git_url": "https://github.com/redis/redis/commit/1ec82e6e97e1db06a72ca505f9fbf6b981f31ef7",
  "file_path": "src/t_string.c",
  "func_name": "appendCommand",
  "func_before": "void appendCommand(client *c) {\n    size_t totlen;\n    robj *o, *append;\n\n    o = lookupKeyWrite(c->db,c->argv[1]);\n    if (o == NULL) {\n        /* Create the key */\n        c->argv[2] = tryObjectEncoding(c->argv[2]);\n        dbAdd(c->db,c->argv[1],c->argv[2]);\n        incrRefCount(c->argv[2]);\n        totlen = stringObjectLen(c->argv[2]);\n    } else {\n        /* Key exists, check type */\n        if (checkType(c,o,OBJ_STRING))\n            return;\n\n        /* \"append\" is an argument, so always an sds */\n        append = c->argv[2];\n        totlen = stringObjectLen(o)+sdslen(append->ptr);\n        if (checkStringLength(c,totlen) != C_OK)\n            return;\n\n        /* Append the value */\n        o = dbUnshareStringValue(c->db,c->argv[1],o);\n        o->ptr = sdscatlen(o->ptr,append->ptr,sdslen(append->ptr));\n        totlen = sdslen(o->ptr);\n    }\n    signalModifiedKey(c,c->db,c->argv[1]);\n    notifyKeyspaceEvent(NOTIFY_STRING,\"append\",c->argv[1],c->db->id);\n    server.dirty++;\n    addReplyLongLong(c,totlen);\n}",
  "abstract_func_before": "void appendCommand(client *VAR_0) {\n    size_t VAR_1;\n    robj *VAR_2, *VAR_3;\n\n    VAR_2 = lookupKeyWrite(VAR_0->db,VAR_0->argv[1]);\n    if (VAR_2 == NULL) {\n        /* COMMENT_0 */\n        VAR_0->argv[2] = tryObjectEncoding(VAR_0->argv[2]);\n        dbAdd(VAR_0->db,VAR_0->argv[1],VAR_0->argv[2]);\n        incrRefCount(VAR_0->argv[2]);\n        VAR_1 = stringObjectLen(VAR_0->argv[2]);\n    } else {\n        /* COMMENT_1 */\n        if (checkType(VAR_0,VAR_2,VAR_4))\n            return;\n\n        /* COMMENT_2 */\n        VAR_3 = VAR_0->argv[2];\n        VAR_1 = stringObjectLen(VAR_2)+sdslen(VAR_3->ptr);\n        if (checkStringLength(VAR_0,VAR_1) != VAR_5)\n            return;\n\n        /* COMMENT_3 */\n        VAR_2 = dbUnshareStringValue(VAR_0->db,VAR_0->argv[1],VAR_2);\n        VAR_2->ptr = sdscatlen(VAR_2->ptr,VAR_3->ptr,sdslen(VAR_3->ptr));\n        VAR_1 = sdslen(VAR_2->ptr);\n    }\n    signalModifiedKey(VAR_0,VAR_0->db,VAR_0->argv[1]);\n    notifyKeyspaceEvent(VAR_6,\"append\",VAR_0->argv[1],VAR_0->db->id);\n    VAR_7.dirty++;\n    addReplyLongLong(VAR_0,VAR_1);\n}",
  "func_graph_path_before": "redis/1ec82e6e97e1db06a72ca505f9fbf6b981f31ef7/t_string.c/vul/before/0.json",
  "func": "void appendCommand(client *c) {\n    size_t totlen;\n    robj *o, *append;\n\n    o = lookupKeyWrite(c->db,c->argv[1]);\n    if (o == NULL) {\n        /* Create the key */\n        c->argv[2] = tryObjectEncoding(c->argv[2]);\n        dbAdd(c->db,c->argv[1],c->argv[2]);\n        incrRefCount(c->argv[2]);\n        totlen = stringObjectLen(c->argv[2]);\n    } else {\n        /* Key exists, check type */\n        if (checkType(c,o,OBJ_STRING))\n            return;\n\n        /* \"append\" is an argument, so always an sds */\n        append = c->argv[2];\n        if (checkStringLength(c,stringObjectLen(o),sdslen(append->ptr)) != C_OK)\n            return;\n\n        /* Append the value */\n        o = dbUnshareStringValue(c->db,c->argv[1],o);\n        o->ptr = sdscatlen(o->ptr,append->ptr,sdslen(append->ptr));\n        totlen = sdslen(o->ptr);\n    }\n    signalModifiedKey(c,c->db,c->argv[1]);\n    notifyKeyspaceEvent(NOTIFY_STRING,\"append\",c->argv[1],c->db->id);\n    server.dirty++;\n    addReplyLongLong(c,totlen);\n}",
  "abstract_func": "void appendCommand(client *VAR_0) {\n    size_t VAR_1;\n    robj *VAR_2, *VAR_3;\n\n    VAR_2 = lookupKeyWrite(VAR_0->db,VAR_0->argv[1]);\n    if (VAR_2 == NULL) {\n        /* COMMENT_0 */\n        VAR_0->argv[2] = tryObjectEncoding(VAR_0->argv[2]);\n        dbAdd(VAR_0->db,VAR_0->argv[1],VAR_0->argv[2]);\n        incrRefCount(VAR_0->argv[2]);\n        VAR_1 = stringObjectLen(VAR_0->argv[2]);\n    } else {\n        /* COMMENT_1 */\n        if (checkType(VAR_0,VAR_2,VAR_4))\n            return;\n\n        /* COMMENT_2 */\n        VAR_3 = VAR_0->argv[2];\n        if (checkStringLength(VAR_0,stringObjectLen(VAR_2),sdslen(VAR_3->ptr)) != VAR_5)\n            return;\n\n        /* COMMENT_3 */\n        VAR_2 = dbUnshareStringValue(VAR_0->db,VAR_0->argv[1],VAR_2);\n        VAR_2->ptr = sdscatlen(VAR_2->ptr,VAR_3->ptr,sdslen(VAR_3->ptr));\n        VAR_1 = sdslen(VAR_2->ptr);\n    }\n    signalModifiedKey(VAR_0,VAR_0->db,VAR_0->argv[1]);\n    notifyKeyspaceEvent(VAR_6,\"append\",VAR_0->argv[1],VAR_0->db->id);\n    VAR_7.dirty++;\n    addReplyLongLong(VAR_0,VAR_1);\n}",
  "func_graph_path": "redis/1ec82e6e97e1db06a72ca505f9fbf6b981f31ef7/t_string.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -16,8 +16,7 @@\n \n         /* \"append\" is an argument, so always an sds */\n         append = c->argv[2];\n-        totlen = stringObjectLen(o)+sdslen(append->ptr);\n-        if (checkStringLength(c,totlen) != C_OK)\n+        if (checkStringLength(c,stringObjectLen(o),sdslen(append->ptr)) != C_OK)\n             return;\n \n         /* Append the value */",
  "diff_line_info": {
    "deleted_lines": [
      "        totlen = stringObjectLen(o)+sdslen(append->ptr);",
      "        if (checkStringLength(c,totlen) != C_OK)"
    ],
    "added_lines": [
      "        if (checkStringLength(c,stringObjectLen(o),sdslen(append->ptr)) != C_OK)"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/redis/redis/pull/11720",
  "description": {
    "pr_info": {
      "title": "Avoid integer overflows in SETRANGE and SORT (CVE-2022-35977)",
      "number": 11720
    },
    "comment": [
      "Authenticated users issuing specially crafted SETRANGE and SORT(_RO) commands can trigger an integer overflow, resulting with Redis attempting to allocate impossible amounts of memory and abort with an OOM panic."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses an integer overflow vulnerability in Redis by modifying how string lengths are checked. This prevents memory allocation issues that could cause a crash, impacting system availability.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 1.0"
}