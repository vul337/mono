{
  "cve_id": "CVE-2021-21257",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "contiki-ng",
  "commit_msg": "Validate the calculated address pointer based on the source routing header.",
  "commit_hash": "99a9257421ca5305ef6a360c02f63561e63ecc60",
  "git_url": "https://github.com/contiki-ng/contiki-ng/commit/99a9257421ca5305ef6a360c02f63561e63ecc60",
  "file_path": "os/net/routing/rpl-lite/rpl-ext-header.c",
  "func_name": "rpl_ext_header_srh_update",
  "func_before": "int\nrpl_ext_header_srh_update(void)\n{\n#if RPL_WITH_NON_STORING\n  struct uip_routing_hdr *rh_header;\n  struct uip_rpl_srh_hdr *srh_header;\n\n  /* Look for routing ext header */\n  rh_header = (struct uip_routing_hdr *)uipbuf_search_header(uip_buf, uip_len, UIP_PROTO_ROUTING);\n\n  if(rh_header != NULL && rh_header->routing_type == RPL_RH_TYPE_SRH) {\n    /* SRH found, now look for next hop */\n    uint8_t cmpri, cmpre;\n    uint8_t ext_len;\n    uint8_t padding;\n    uint8_t path_len;\n    uint8_t segments_left;\n    uip_ipaddr_t current_dest_addr;\n\n    srh_header = (struct uip_rpl_srh_hdr *)(((uint8_t *)rh_header) + RPL_RH_LEN);\n    segments_left = rh_header->seg_left;\n    ext_len = rh_header->len * 8 + 8;\n    cmpri = srh_header->cmpr >> 4;\n    cmpre = srh_header->cmpr & 0x0f;\n    padding = srh_header->pad >> 4;\n    path_len = ((ext_len - padding - RPL_RH_LEN - RPL_SRH_LEN - (16 - cmpre)) / (16 - cmpri)) + 1;\n    (void)path_len;\n\n    LOG_DBG(\"read SRH, path len %u, segments left %u, Cmpri %u, Cmpre %u, ext len %u (padding %u)\\n\",\n        path_len, segments_left, cmpri, cmpre, ext_len, padding);\n\n    if(segments_left == 0) {\n      /* We are the final destination, do nothing */\n    } else if(segments_left > path_len) {\n      /* Discard the packet because of a parameter problem. */\n      LOG_ERR(\"SRH with too many segments left (%u > %u)\\n\",\n              segments_left, path_len);\n      return 0;\n    } else {\n      uint8_t i = path_len - segments_left; /* The index of the next address to be visited */\n      uint8_t *addr_ptr = ((uint8_t *)rh_header) + RPL_RH_LEN + RPL_SRH_LEN + (i * (16 - cmpri));\n      uint8_t cmpr = segments_left == 1 ? cmpre : cmpri;\n\n      /* As per RFC6554: swap the IPv6 destination address and address[i] */\n\n      /* First, copy the current IPv6 destination address */\n      uip_ipaddr_copy(&current_dest_addr, &UIP_IP_BUF->destipaddr);\n      /* Second, update the IPv6 destination address with addresses[i] */\n      memcpy(((uint8_t *)&UIP_IP_BUF->destipaddr) + cmpr, addr_ptr, 16 - cmpr);\n      /* Third, write current_dest_addr to addresses[i] */\n      memcpy(addr_ptr, ((uint8_t *)&current_dest_addr) + cmpr, 16 - cmpr);\n\n      /* Update segments left field */\n      rh_header->seg_left--;\n\n      LOG_INFO(\"SRH next hop \");\n      LOG_INFO_6ADDR(&UIP_IP_BUF->destipaddr);\n      LOG_INFO_(\"\\n\");\n    }\n    return 1;\n  }\n\n  return 0;\n#else /* RPL_WITH_NON_STORING */\n  return 0; /* SRH not found */\n#endif /* RPL_WITH_NON_STORING */\n}",
  "abstract_func_before": "int\nrpl_ext_header_srh_update(void)\n{\n#if VAR_0\n  struct uip_routing_hdr *VAR_1;\n  struct uip_rpl_srh_hdr *VAR_2;\n\n  /* COMMENT_0 */\n  VAR_1 = (struct uip_routing_hdr *)uipbuf_search_header(VAR_3, VAR_4, VAR_5);\n\n  if(VAR_1 != NULL && VAR_1->routing_type == VAR_6) {\n    /* COMMENT_1 */\n    uint8_t VAR_7, VAR_8;\n    uint8_t VAR_9;\n    uint8_t VAR_10;\n    uint8_t VAR_11;\n    uint8_t VAR_12;\n    uip_ipaddr_t VAR_13;\n\n    VAR_2 = (struct uip_rpl_srh_hdr *)(((uint8_t *)VAR_1) + VAR_14);\n    VAR_12 = VAR_1->seg_left;\n    VAR_9 = VAR_1->len * 8 + 8;\n    VAR_7 = VAR_2->cmpr >> 4;\n    VAR_8 = VAR_2->cmpr & 0x0f;\n    VAR_10 = VAR_2->pad >> 4;\n    VAR_11 = ((VAR_9 - VAR_10 - VAR_14 - VAR_15 - (16 - VAR_8)) / (16 - VAR_7)) + 1;\n    (void)VAR_11;\n\n    LOG_DBG(\"read SRH, path len %u, segments left %u, Cmpri %u, Cmpre %u, ext len %u (padding %u)\\n\",\n        VAR_11, VAR_12, VAR_7, VAR_8, VAR_9, VAR_10);\n\n    if(VAR_12 == 0) {\n      /* COMMENT_2 */\n    } else if(VAR_12 > VAR_11) {\n      /* COMMENT_3 */\n      LOG_ERR(\"SRH with too many segments left (%u > %u)\\n\",\n              VAR_12, VAR_11);\n      return 0;\n    } else {\n      uint8_t VAR_16 = VAR_11 - VAR_12; /* COMMENT_4 */\n      uint8_t *VAR_17 = ((uint8_t *)VAR_1) + VAR_14 + VAR_15 + (VAR_16 * (16 - VAR_7));\n      uint8_t VAR_18 = VAR_12 == 1 ? VAR_8 : VAR_7;\n\n      /* COMMENT_5 */\n\n      /* COMMENT_6 */\n      uip_ipaddr_copy(&VAR_13, &VAR_19->destipaddr);\n      /* COMMENT_7 */\n      memcpy(((uint8_t *)&VAR_19->destipaddr) + VAR_18, VAR_17, 16 - VAR_18);\n      /* COMMENT_8 */\n      memcpy(VAR_17, ((uint8_t *)&VAR_13) + VAR_18, 16 - VAR_18);\n\n      /* COMMENT_9 */\n      VAR_1->seg_left--;\n\n      LOG_INFO(\"SRH next hop \");\n      LOG_INFO_6ADDR(&VAR_19->destipaddr);\n      LOG_INFO_(\"\\n\");\n    }\n    return 1;\n  }\n\n  return 0;\n#else /* COMMENT_10 */\n  return 0; /* COMMENT_11 */\n#endif /* COMMENT_10 */\n}",
  "func_graph_path_before": "contiki-ng/99a9257421ca5305ef6a360c02f63561e63ecc60/rpl-ext-header.c/vul/before/0.json",
  "func": "int\nrpl_ext_header_srh_update(void)\n{\n#if RPL_WITH_NON_STORING\n  struct uip_routing_hdr *rh_header;\n  struct uip_rpl_srh_hdr *srh_header;\n\n  /* Look for routing ext header */\n  rh_header = (struct uip_routing_hdr *)uipbuf_search_header(uip_buf, uip_len, UIP_PROTO_ROUTING);\n\n  if(rh_header != NULL && rh_header->routing_type == RPL_RH_TYPE_SRH) {\n    /* SRH found, now look for next hop */\n    uint8_t cmpri, cmpre;\n    uint8_t ext_len;\n    uint8_t padding;\n    uint8_t path_len;\n    uint8_t segments_left;\n    uip_ipaddr_t current_dest_addr;\n\n    srh_header = (struct uip_rpl_srh_hdr *)(((uint8_t *)rh_header) + RPL_RH_LEN);\n    segments_left = rh_header->seg_left;\n    ext_len = rh_header->len * 8 + 8;\n    cmpri = srh_header->cmpr >> 4;\n    cmpre = srh_header->cmpr & 0x0f;\n    padding = srh_header->pad >> 4;\n    path_len = ((ext_len - padding - RPL_RH_LEN - RPL_SRH_LEN - (16 - cmpre)) / (16 - cmpri)) + 1;\n    (void)path_len;\n\n    LOG_DBG(\"read SRH, path len %u, segments left %u, Cmpri %u, Cmpre %u, ext len %u (padding %u)\\n\",\n        path_len, segments_left, cmpri, cmpre, ext_len, padding);\n\n    if(segments_left == 0) {\n      /* We are the final destination, do nothing */\n    } else if(segments_left > path_len) {\n      /* Discard the packet because of a parameter problem. */\n      LOG_ERR(\"SRH with too many segments left (%u > %u)\\n\",\n              segments_left, path_len);\n      return 0;\n    } else {\n      uint8_t i = path_len - segments_left; /* The index of the next address to be visited */\n      uint8_t cmpr = segments_left == 1 ? cmpre : cmpri;\n      ptrdiff_t rh_offset = (uint8_t *)rh_header - uip_buf;\n      size_t addr_offset = RPL_RH_LEN + RPL_SRH_LEN + (i * (16 - cmpri));\n\n      if(rh_offset + addr_offset + 16 - cmpr > UIP_BUFSIZE) {\n        LOG_ERR(\"Invalid SRH address pointer\\n\");\n        return 0;\n      }\n\n      uint8_t *addr_ptr = ((uint8_t *)rh_header) + addr_offset;\n\n      /* As per RFC6554: swap the IPv6 destination address and address[i] */\n\n      /* First, copy the current IPv6 destination address */\n      uip_ipaddr_copy(&current_dest_addr, &UIP_IP_BUF->destipaddr);\n      /* Second, update the IPv6 destination address with addresses[i] */\n      memcpy(((uint8_t *)&UIP_IP_BUF->destipaddr) + cmpr, addr_ptr, 16 - cmpr);\n      /* Third, write current_dest_addr to addresses[i] */\n      memcpy(addr_ptr, ((uint8_t *)&current_dest_addr) + cmpr, 16 - cmpr);\n\n      /* Update segments left field */\n      rh_header->seg_left--;\n\n      LOG_INFO(\"SRH next hop \");\n      LOG_INFO_6ADDR(&UIP_IP_BUF->destipaddr);\n      LOG_INFO_(\"\\n\");\n    }\n    return 1;\n  }\n\n  return 0;\n#else /* RPL_WITH_NON_STORING */\n  return 0; /* SRH not found */\n#endif /* RPL_WITH_NON_STORING */\n}",
  "abstract_func": "int\nrpl_ext_header_srh_update(void)\n{\n#if VAR_0\n  struct uip_routing_hdr *VAR_1;\n  struct uip_rpl_srh_hdr *VAR_2;\n\n  /* COMMENT_0 */\n  VAR_1 = (struct uip_routing_hdr *)uipbuf_search_header(VAR_3, VAR_4, VAR_5);\n\n  if(VAR_1 != NULL && VAR_1->routing_type == VAR_6) {\n    /* COMMENT_1 */\n    uint8_t VAR_7, VAR_8;\n    uint8_t VAR_9;\n    uint8_t VAR_10;\n    uint8_t VAR_11;\n    uint8_t VAR_12;\n    uip_ipaddr_t VAR_13;\n\n    VAR_2 = (struct uip_rpl_srh_hdr *)(((uint8_t *)VAR_1) + VAR_14);\n    VAR_12 = VAR_1->seg_left;\n    VAR_9 = VAR_1->len * 8 + 8;\n    VAR_7 = VAR_2->cmpr >> 4;\n    VAR_8 = VAR_2->cmpr & 0x0f;\n    VAR_10 = VAR_2->pad >> 4;\n    VAR_11 = ((VAR_9 - VAR_10 - VAR_14 - VAR_15 - (16 - VAR_8)) / (16 - VAR_7)) + 1;\n    (void)VAR_11;\n\n    LOG_DBG(\"read SRH, path len %u, segments left %u, Cmpri %u, Cmpre %u, ext len %u (padding %u)\\n\",\n        VAR_11, VAR_12, VAR_7, VAR_8, VAR_9, VAR_10);\n\n    if(VAR_12 == 0) {\n      /* COMMENT_2 */\n    } else if(VAR_12 > VAR_11) {\n      /* COMMENT_3 */\n      LOG_ERR(\"SRH with too many segments left (%u > %u)\\n\",\n              VAR_12, VAR_11);\n      return 0;\n    } else {\n      uint8_t VAR_16 = VAR_11 - VAR_12; /* COMMENT_4 */\n      uint8_t VAR_17 = VAR_12 == 1 ? VAR_8 : VAR_7;\n      ptrdiff_t VAR_18 = (uint8_t *)VAR_1 - VAR_3;\n      size_t VAR_19 = VAR_14 + VAR_15 + (VAR_16 * (16 - VAR_7));\n\n      if(VAR_18 + VAR_19 + 16 - VAR_17 > VAR_20) {\n        LOG_ERR(\"Invalid SRH address pointer\\n\");\n        return 0;\n      }\n\n      uint8_t *VAR_21 = ((uint8_t *)VAR_1) + VAR_19;\n\n      /* COMMENT_5 */\n\n      /* COMMENT_6 */\n      uip_ipaddr_copy(&VAR_13, &VAR_22->destipaddr);\n      /* COMMENT_7 */\n      memcpy(((uint8_t *)&VAR_22->destipaddr) + VAR_17, VAR_21, 16 - VAR_17);\n      /* COMMENT_8 */\n      memcpy(VAR_21, ((uint8_t *)&VAR_13) + VAR_17, 16 - VAR_17);\n\n      /* COMMENT_9 */\n      VAR_1->seg_left--;\n\n      LOG_INFO(\"SRH next hop \");\n      LOG_INFO_6ADDR(&VAR_22->destipaddr);\n      LOG_INFO_(\"\\n\");\n    }\n    return 1;\n  }\n\n  return 0;\n#else /* COMMENT_10 */\n  return 0; /* COMMENT_11 */\n#endif /* COMMENT_10 */\n}",
  "func_graph_path": "contiki-ng/99a9257421ca5305ef6a360c02f63561e63ecc60/rpl-ext-header.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -38,8 +38,16 @@\n       return 0;\n     } else {\n       uint8_t i = path_len - segments_left; /* The index of the next address to be visited */\n-      uint8_t *addr_ptr = ((uint8_t *)rh_header) + RPL_RH_LEN + RPL_SRH_LEN + (i * (16 - cmpri));\n       uint8_t cmpr = segments_left == 1 ? cmpre : cmpri;\n+      ptrdiff_t rh_offset = (uint8_t *)rh_header - uip_buf;\n+      size_t addr_offset = RPL_RH_LEN + RPL_SRH_LEN + (i * (16 - cmpri));\n+\n+      if(rh_offset + addr_offset + 16 - cmpr > UIP_BUFSIZE) {\n+        LOG_ERR(\"Invalid SRH address pointer\\n\");\n+        return 0;\n+      }\n+\n+      uint8_t *addr_ptr = ((uint8_t *)rh_header) + addr_offset;\n \n       /* As per RFC6554: swap the IPv6 destination address and address[i] */\n ",
  "diff_line_info": {
    "deleted_lines": [
      "      uint8_t *addr_ptr = ((uint8_t *)rh_header) + RPL_RH_LEN + RPL_SRH_LEN + (i * (16 - cmpri));"
    ],
    "added_lines": [
      "      ptrdiff_t rh_offset = (uint8_t *)rh_header - uip_buf;",
      "      size_t addr_offset = RPL_RH_LEN + RPL_SRH_LEN + (i * (16 - cmpri));",
      "",
      "      if(rh_offset + addr_offset + 16 - cmpr > UIP_BUFSIZE) {",
      "        LOG_ERR(\"Invalid SRH address pointer\\n\");",
      "        return 0;",
      "      }",
      "",
      "      uint8_t *addr_ptr = ((uint8_t *)rh_header) + addr_offset;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/contiki-ng/contiki-ng/pull/1431",
  "description": {
    "pr_info": {
      "title": "Validate the address pointer in the source routing header",
      "number": 1431
    },
    "comment": [
      "It is possible that the line <code>memcpy(addr_ptr, ((uint8_t *)&current_dest_addr) + cmpr, 16 - cmpr);</code> causes a write outside the uip buffer because addr_ptr is not validated. This PR contains such a check and a test packet to demonstrate the behavior that can lead to a segmentation fault."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch adds a validation check to prevent an out-of-bounds memory access, addressing a buffer overflow issue that could lead to a segmentation fault. This resolves a security vulnerability.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 1.0"
}