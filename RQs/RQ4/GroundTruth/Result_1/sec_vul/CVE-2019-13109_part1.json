{
  "cve_id": "CVE-2019-13109",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "Exiv2/exiv2",
  "commit_msg": "Avoid negative integer overflow when `iccOffset > chunkLength`.\n\nThis fixes #790.\n\n(cherry picked from commit 6fa2e31206127bd8bcac0269311f3775a8d6ea21)",
  "commit_hash": "491c3ebe3b3faa6d8f75fb28146186792c2439da",
  "git_url": "https://github.com/Exiv2/exiv2/commit/491c3ebe3b3faa6d8f75fb28146186792c2439da",
  "file_path": "src/pngimage.cpp",
  "func_name": "PngImage::readMetadata",
  "func_before": "void PngImage::readMetadata()\n    {\n#ifdef DEBUG\n        std::cerr << \"Exiv2::PngImage::readMetadata: Reading PNG file \" << io_->path() << std::endl;\n#endif\n        if (io_->open() != 0) {\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        }\n        IoCloser closer(*io_);\n        if (!isPngType(*io_, true)) {\n            throw Error(kerNotAnImage, \"PNG\");\n        }\n        clearMetadata();\n\n        const long imgSize = (long)io_->size();\n        DataBuf cheaderBuf(8);  // Chunk header: 4 bytes (data size) + 4 bytes (chunk type).\n\n        while (!io_->eof()) {\n            std::memset(cheaderBuf.pData_, 0x0, cheaderBuf.size_);\n            readChunk(cheaderBuf, *io_);  // Read chunk header.\n\n            // Decode chunk data length.\n            uint32_t chunkLength = Exiv2::getULong(cheaderBuf.pData_, Exiv2::bigEndian);\n            long pos = io_->tell();\n            if (pos == -1 || chunkLength > uint32_t(0x7FFFFFFF) || static_cast<long>(chunkLength) > imgSize - pos) {\n                throw Exiv2::Error(kerFailedToReadImageData);\n            }\n\n            std::string chunkType(reinterpret_cast<char*>(cheaderBuf.pData_) + 4, 4);\n#ifdef DEBUG\n            std::cout << \"Exiv2::PngImage::readMetadata: chunk type: \" << chunkType << \" length: \" << chunkLength\n                      << std::endl;\n#endif\n\n            /// \\todo analyse remaining chunks of the standard\n            // Perform a chunk triage for item that we need.\n            if (chunkType == \"IEND\" || chunkType == \"IHDR\" || chunkType == \"tEXt\" || chunkType == \"zTXt\" ||\n                chunkType == \"iTXt\" || chunkType == \"iCCP\") {\n                DataBuf chunkData(chunkLength);\n                readChunk(chunkData, *io_);  // Extract chunk data.\n\n                if (chunkType == \"IEND\") {\n                    return;  // Last chunk found: we stop parsing.\n                } else if (chunkType == \"IHDR\" && chunkData.size_ >= 8) {\n                    Internal::PngImageHeader header;\n                    PngChunk::decodeIHDRChunk(chunkData, header);\n                    pixelWidth_ = header.width;\n                    pixelHeight_ = header.height;\n                    /// \\todo handle rest of data\n                } else if (chunkType == \"tEXt\") {\n                    PngChunk::decodeTXTChunk(this, chunkData, PngChunk::tEXt_Chunk);\n                } else if (chunkType == \"zTXt\") {\n                    PngChunk::decodeTXTChunk(this, chunkData, PngChunk::zTXt_Chunk);\n                } else if (chunkType == \"iTXt\") {\n                    PngChunk::decodeTXTChunk(this, chunkData, PngChunk::iTXt_Chunk);\n                } else if (chunkType == \"iCCP\") {\n                    // The ICC profile name can vary from 1-79 characters.\n                    uint32_t iccOffset = 0;\n                    while (iccOffset < 80 && iccOffset < chunkLength) {\n                        if (chunkData.pData_[iccOffset++] == 0x00) {\n                            break;\n                        }\n                    }\n                    profileName_ = std::string(reinterpret_cast<char*>(chunkData.pData_), iccOffset - 1);\n                    ++iccOffset;  // +1 = 'compressed' flag\n\n                    zlibToDataBuf(chunkData.pData_ + iccOffset, chunkLength - iccOffset, iccProfile_);\n#ifdef DEBUG\n                    std::cout << \"Exiv2::PngImage::readMetadata: profile name: \" << profileName_ << std::endl;\n                    std::cout << \"Exiv2::PngImage::readMetadata: iccProfile.size_ (uncompressed) : \"\n                              << iccProfile_.size_ << std::endl;\n#endif\n                }\n\n                // Set chunkLength to 0 in case we have read a supported chunk type. Otherwise, we need to seek the\n                // file to the next chunk position.\n                chunkLength = 0;\n            }\n\n            // Move to the next chunk: chunk data size + 4 CRC bytes.\n#ifdef DEBUG\n            std::cout << \"Exiv2::PngImage::readMetadata: Seek to offset: \" << chunkLength + 4 << std::endl;\n#endif\n            io_->seek(chunkLength + 4, BasicIo::cur);\n            if (io_->error() || io_->eof()) {\n                throw Error(kerFailedToReadImageData);\n            }\n        }\n    }",
  "abstract_func_before": "void PngImage::readMetadata()\n    {\n#ifdef VAR_0\n        std::cerr << \"Exiv2::PngImage::readMetadata: Reading PNG file \" << VAR_1->path() << std::endl;\n#endif\n        if (VAR_1->open() != 0) {\n            throw Error(VAR_2, VAR_1->path(), strError());\n        }\n        IoCloser VAR_3(*VAR_1);\n        if (!isPngType(*VAR_1, true)) {\n            throw Error(VAR_4, \"PNG\");\n        }\n        clearMetadata();\n\n        const long VAR_5 = (long)VAR_1->size();\n        DataBuf VAR_6(8);  /* COMMENT_0 */\n\n        while (!VAR_1->eof()) {\n            std::memset(VAR_6.pData_, 0x0, VAR_6.size_);\n            readChunk(VAR_6, *VAR_1);  /* COMMENT_1 */\n\n            /* COMMENT_2 */\n            uint32_t VAR_7 = Exiv2::getULong(VAR_6.pData_, Exiv2::bigEndian);\n            long VAR_8 = VAR_1->tell();\n            if (VAR_8 == -1 || VAR_7 > uint32_t(0x7FFFFFFF) || VAR_9<long>(VAR_7) > VAR_5 - VAR_8) {\n                throw Exiv2::Error(VAR_10);\n            }\n\n            std::string VAR_11(VAR_12<char*>(VAR_6.pData_) + 4, 4);\n#ifdef VAR_0\n            std::cout << \"Exiv2::PngImage::readMetadata: chunk type: \" << VAR_11 << \" length: \" << VAR_7\n                      << std::endl;\n#endif\n\n            /* COMMENT_3 */\n            /* COMMENT_4 */\n            if (VAR_11 == \"IEND\" || VAR_11 == \"IHDR\" || VAR_11 == \"tEXt\" || VAR_11 == \"zTXt\" ||\n                VAR_11 == \"iTXt\" || VAR_11 == \"iCCP\") {\n                DataBuf chunkData(chunkLength);\n                readChunk(VAR_13, *VAR_1);  /* COMMENT_5 */\n\n                if (VAR_11 == \"IEND\") {\n                    return;  /* COMMENT_6 */\n                } else if (VAR_11 == \"IHDR\" && VAR_13.size_ >= 8) {\n                    Internal::PngImageHeader VAR_14;\n                    PngChunk::decodeIHDRChunk(VAR_13, VAR_14);\n                    VAR_15 = VAR_14.width;\n                    VAR_16 = VAR_14.height;\n                    /* COMMENT_7 */\n                } else if (VAR_11 == \"tEXt\") {\n                    PngChunk::decodeTXTChunk(this, VAR_13, PngChunk::tEXt_Chunk);\n                } else if (VAR_11 == \"zTXt\") {\n                    PngChunk::decodeTXTChunk(this, VAR_13, PngChunk::zTXt_Chunk);\n                } else if (VAR_11 == \"iTXt\") {\n                    PngChunk::decodeTXTChunk(this, VAR_13, PngChunk::iTXt_Chunk);\n                } else if (VAR_11 == \"iCCP\") {\n                    /* COMMENT_8 */\n                    uint32_t VAR_17 = 0;\n                    while (VAR_17 < 80 && VAR_17 < chunkLength) {\n                        if (VAR_13.pData_[VAR_17++] == 0x00) {\n                            break;\n                        }\n                    }\n                    VAR_18 = std::string(VAR_12<char*>(VAR_13.pData_), VAR_17 - 1);\n                    ++VAR_17;  /* COMMENT_9 */\n\n                    zlibToDataBuf(VAR_13.pData_ + VAR_17, chunkLength - VAR_17, VAR_19);\n#ifdef VAR_0\n                    std::cout << \"Exiv2::PngImage::readMetadata: profile name: \" << VAR_18 << std::endl;\n                    std::cout << \"Exiv2::PngImage::readMetadata: iccProfile.size_ (uncompressed) : \"\n                              << VAR_19.size_ << std::endl;\n#endif\n                }\n\n                /* COMMENT_10 */\n                /* COMMENT_11 */\n                chunkLength = 0;\n            }\n\n            /* COMMENT_12 */\n#ifdef VAR_0\n            std::cout << \"Exiv2::PngImage::readMetadata: Seek to offset: \" << chunkLength + 4 << std::endl;\n#endif\n            VAR_1->seek(chunkLength + 4, BasicIo::cur);\n            if (VAR_1->error() || VAR_1->eof()) {\n                throw Error(VAR_10);\n            }\n        }\n    }",
  "func_graph_path_before": "Exiv2/exiv2/491c3ebe3b3faa6d8f75fb28146186792c2439da/pngimage.cpp/vul/before/0.json",
  "func": "void PngImage::readMetadata()\n    {\n#ifdef DEBUG\n        std::cerr << \"Exiv2::PngImage::readMetadata: Reading PNG file \" << io_->path() << std::endl;\n#endif\n        if (io_->open() != 0) {\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        }\n        IoCloser closer(*io_);\n        if (!isPngType(*io_, true)) {\n            throw Error(kerNotAnImage, \"PNG\");\n        }\n        clearMetadata();\n\n        const long imgSize = (long)io_->size();\n        DataBuf cheaderBuf(8);  // Chunk header: 4 bytes (data size) + 4 bytes (chunk type).\n\n        while (!io_->eof()) {\n            std::memset(cheaderBuf.pData_, 0x0, cheaderBuf.size_);\n            readChunk(cheaderBuf, *io_);  // Read chunk header.\n\n            // Decode chunk data length.\n            uint32_t chunkLength = Exiv2::getULong(cheaderBuf.pData_, Exiv2::bigEndian);\n            long pos = io_->tell();\n            if (pos == -1 || chunkLength > uint32_t(0x7FFFFFFF) || static_cast<long>(chunkLength) > imgSize - pos) {\n                throw Exiv2::Error(kerFailedToReadImageData);\n            }\n\n            std::string chunkType(reinterpret_cast<char*>(cheaderBuf.pData_) + 4, 4);\n#ifdef DEBUG\n            std::cout << \"Exiv2::PngImage::readMetadata: chunk type: \" << chunkType << \" length: \" << chunkLength\n                      << std::endl;\n#endif\n\n            /// \\todo analyse remaining chunks of the standard\n            // Perform a chunk triage for item that we need.\n            if (chunkType == \"IEND\" || chunkType == \"IHDR\" || chunkType == \"tEXt\" || chunkType == \"zTXt\" ||\n                chunkType == \"iTXt\" || chunkType == \"iCCP\") {\n                DataBuf chunkData(chunkLength);\n                readChunk(chunkData, *io_);  // Extract chunk data.\n\n                if (chunkType == \"IEND\") {\n                    return;  // Last chunk found: we stop parsing.\n                } else if (chunkType == \"IHDR\" && chunkData.size_ >= 8) {\n                    Internal::PngImageHeader header;\n                    PngChunk::decodeIHDRChunk(chunkData, header);\n                    pixelWidth_ = header.width;\n                    pixelHeight_ = header.height;\n                    /// \\todo handle rest of data\n                } else if (chunkType == \"tEXt\") {\n                    PngChunk::decodeTXTChunk(this, chunkData, PngChunk::tEXt_Chunk);\n                } else if (chunkType == \"zTXt\") {\n                    PngChunk::decodeTXTChunk(this, chunkData, PngChunk::zTXt_Chunk);\n                } else if (chunkType == \"iTXt\") {\n                    PngChunk::decodeTXTChunk(this, chunkData, PngChunk::iTXt_Chunk);\n                } else if (chunkType == \"iCCP\") {\n                    // The ICC profile name can vary from 1-79 characters.\n                    uint32_t iccOffset = 0;\n                    while (iccOffset < 80 && iccOffset < chunkLength) {\n                        if (chunkData.pData_[iccOffset++] == 0x00) {\n                            break;\n                        }\n                    }\n                    profileName_ = std::string(reinterpret_cast<char*>(chunkData.pData_), iccOffset - 1);\n                    ++iccOffset;  // +1 = 'compressed' flag\n                    enforce(iccOffset <= chunkLength, Exiv2::kerCorruptedMetadata);\n\n                    zlibToDataBuf(chunkData.pData_ + iccOffset, chunkLength - iccOffset, iccProfile_);\n#ifdef DEBUG\n                    std::cout << \"Exiv2::PngImage::readMetadata: profile name: \" << profileName_ << std::endl;\n                    std::cout << \"Exiv2::PngImage::readMetadata: iccProfile.size_ (uncompressed) : \"\n                              << iccProfile_.size_ << std::endl;\n#endif\n                }\n\n                // Set chunkLength to 0 in case we have read a supported chunk type. Otherwise, we need to seek the\n                // file to the next chunk position.\n                chunkLength = 0;\n            }\n\n            // Move to the next chunk: chunk data size + 4 CRC bytes.\n#ifdef DEBUG\n            std::cout << \"Exiv2::PngImage::readMetadata: Seek to offset: \" << chunkLength + 4 << std::endl;\n#endif\n            io_->seek(chunkLength + 4, BasicIo::cur);\n            if (io_->error() || io_->eof()) {\n                throw Error(kerFailedToReadImageData);\n            }\n        }\n    }",
  "abstract_func": "void PngImage::readMetadata()\n    {\n#ifdef VAR_0\n        std::cerr << \"Exiv2::PngImage::readMetadata: Reading PNG file \" << VAR_1->path() << std::endl;\n#endif\n        if (VAR_1->open() != 0) {\n            throw Error(VAR_2, VAR_1->path(), strError());\n        }\n        IoCloser VAR_3(*VAR_1);\n        if (!isPngType(*VAR_1, true)) {\n            throw Error(VAR_4, \"PNG\");\n        }\n        clearMetadata();\n\n        const long VAR_5 = (long)VAR_1->size();\n        DataBuf VAR_6(8);  /* COMMENT_0 */\n\n        while (!VAR_1->eof()) {\n            std::memset(VAR_6.pData_, 0x0, VAR_6.size_);\n            readChunk(VAR_6, *VAR_1);  /* COMMENT_1 */\n\n            /* COMMENT_2 */\n            uint32_t VAR_7 = Exiv2::getULong(VAR_6.pData_, Exiv2::bigEndian);\n            long VAR_8 = VAR_1->tell();\n            if (VAR_8 == -1 || VAR_7 > uint32_t(0x7FFFFFFF) || VAR_9<long>(VAR_7) > VAR_5 - VAR_8) {\n                throw Exiv2::Error(VAR_10);\n            }\n\n            std::string VAR_11(VAR_12<char*>(VAR_6.pData_) + 4, 4);\n#ifdef VAR_0\n            std::cout << \"Exiv2::PngImage::readMetadata: chunk type: \" << VAR_11 << \" length: \" << VAR_7\n                      << std::endl;\n#endif\n\n            /* COMMENT_3 */\n            /* COMMENT_4 */\n            if (VAR_11 == \"IEND\" || VAR_11 == \"IHDR\" || VAR_11 == \"tEXt\" || VAR_11 == \"zTXt\" ||\n                VAR_11 == \"iTXt\" || VAR_11 == \"iCCP\") {\n                DataBuf chunkData(chunkLength);\n                readChunk(VAR_13, *VAR_1);  /* COMMENT_5 */\n\n                if (VAR_11 == \"IEND\") {\n                    return;  /* COMMENT_6 */\n                } else if (VAR_11 == \"IHDR\" && VAR_13.size_ >= 8) {\n                    Internal::PngImageHeader VAR_14;\n                    PngChunk::decodeIHDRChunk(VAR_13, VAR_14);\n                    VAR_15 = VAR_14.width;\n                    VAR_16 = VAR_14.height;\n                    /* COMMENT_7 */\n                } else if (VAR_11 == \"tEXt\") {\n                    PngChunk::decodeTXTChunk(this, VAR_13, PngChunk::tEXt_Chunk);\n                } else if (VAR_11 == \"zTXt\") {\n                    PngChunk::decodeTXTChunk(this, VAR_13, PngChunk::zTXt_Chunk);\n                } else if (VAR_11 == \"iTXt\") {\n                    PngChunk::decodeTXTChunk(this, VAR_13, PngChunk::iTXt_Chunk);\n                } else if (VAR_11 == \"iCCP\") {\n                    /* COMMENT_8 */\n                    uint32_t VAR_17 = 0;\n                    while (VAR_17 < 80 && VAR_17 < chunkLength) {\n                        if (VAR_13.pData_[VAR_17++] == 0x00) {\n                            break;\n                        }\n                    }\n                    VAR_18 = std::string(VAR_12<char*>(VAR_13.pData_), VAR_17 - 1);\n                    ++VAR_17;  /* COMMENT_9 */\n                    enforce(VAR_17 <= chunkLength, Exiv2::kerCorruptedMetadata);\n\n                    zlibToDataBuf(VAR_13.pData_ + VAR_17, chunkLength - VAR_17, VAR_19);\n#ifdef VAR_0\n                    std::cout << \"Exiv2::PngImage::readMetadata: profile name: \" << VAR_18 << std::endl;\n                    std::cout << \"Exiv2::PngImage::readMetadata: iccProfile.size_ (uncompressed) : \"\n                              << VAR_19.size_ << std::endl;\n#endif\n                }\n\n                /* COMMENT_10 */\n                /* COMMENT_11 */\n                chunkLength = 0;\n            }\n\n            /* COMMENT_12 */\n#ifdef VAR_0\n            std::cout << \"Exiv2::PngImage::readMetadata: Seek to offset: \" << chunkLength + 4 << std::endl;\n#endif\n            VAR_1->seek(chunkLength + 4, BasicIo::cur);\n            if (VAR_1->error() || VAR_1->eof()) {\n                throw Error(VAR_10);\n            }\n        }\n    }",
  "func_graph_path": "Exiv2/exiv2/491c3ebe3b3faa6d8f75fb28146186792c2439da/pngimage.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -63,6 +63,7 @@\n                     }\n                     profileName_ = std::string(reinterpret_cast<char*>(chunkData.pData_), iccOffset - 1);\n                     ++iccOffset;  // +1 = 'compressed' flag\n+                    enforce(iccOffset <= chunkLength, Exiv2::kerCorruptedMetadata);\n \n                     zlibToDataBuf(chunkData.pData_ + iccOffset, chunkLength - iccOffset, iccProfile_);\n #ifdef DEBUG",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "                    enforce(iccOffset <= chunkLength, Exiv2::kerCorruptedMetadata);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/Exiv2/exiv2/pull/898",
  "description": {
    "pr_info": {
      "title": "Add Safe::cast<T>",
      "number": 898
    },
    "comment": [
      "This PR adds a new function into the `Safe` namespace: `cast<T>`. It is intended to convert a integer from one type to the other without causing over- or underflows.\r\n\r\nThanks to some ternary operator abuse it is even completely `constexpr` even with C++11, although readability suffers a little.\r\n\r\nPlease review this PR with more care, I've created it in a pretty sleep deprived state.",
      "# [Codecov](https://codecov.io/gh/Exiv2/exiv2/pull/898?src=pr&el=h1) Report\n> Merging [#898](https://codecov.io/gh/Exiv2/exiv2/pull/898?src=pr&el=desc) into [master](https://codecov.io/gh/Exiv2/exiv2/commit/98e63e4bb4d78ee9dec2ba9dca2aa1785278e51c?src=pr&el=desc) will **increase** coverage by `0.03%`.\n> The diff coverage is `100%`.\n\n[![Impacted file tree graph](https://codecov.io/gh/Exiv2/exiv2/pull/898/graphs/tree.svg?width=650&token=O9G7Iswx26&height=150&src=pr)](https://codecov.io/gh/Exiv2/exiv2/pull/898?src=pr&el=tree)\n\n```diff\n@@            Coverage Diff             @@\n##           master     #898      +/-   ##\n==========================================\n+ Coverage   71.09%   71.12%   +0.03%     \n==========================================\n  Files         148      148              \n  Lines       19376    19400      +24     \n==========================================\n+ Hits        13775    13799      +24     \n  Misses       5601     5601\n```\n\n\n| [Impacted Files](https://codecov.io/gh/Exiv2/exiv2/pull/898?src=pr&el=tree) | Coverage Δ | |\n|---|---|---|\n| [src/safe\\_op.hpp](https://codecov.io/gh/Exiv2/exiv2/pull/898/diff?src=pr&el=tree#diff-c3JjL3NhZmVfb3AuaHBw) | `100% <100%> (ø)` | :arrow_up: |\n| [unitTests/test\\_safe\\_op.cpp](https://codecov.io/gh/Exiv2/exiv2/pull/898/diff?src=pr&el=tree#diff-dW5pdFRlc3RzL3Rlc3Rfc2FmZV9vcC5jcHA=) | `100% <100%> (ø)` | :arrow_up: |\n\n------\n\n[Continue to review full report at Codecov](https://codecov.io/gh/Exiv2/exiv2/pull/898?src=pr&el=continue).\n> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)\n> `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`\n> Powered by [Codecov](https://codecov.io/gh/Exiv2/exiv2/pull/898?src=pr&el=footer). Last update [98e63e4...65591ca](https://codecov.io/gh/Exiv2/exiv2/pull/898?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).\n",
      "Gosh, Dan.  That's amazing code and I have no idea what it does!\r\n\r\nI'm going to leave it to @piponazo to approve (although I will approve if you ask me).\r\n\r\nI got it to built and pass the test suite with msvc 2017/Release and 2019/Release (with a little code change).\r\n\r\nWhen I built, I got this error:\r\n```\r\n  pngchunk_int.cpp                                                                                                                                                                                                                               \r\nc:\\msys64\\home\\rmills\\gnu\\github\\exiv2\\master\\src\\safe_op.hpp(347): error C2064: term does not evaluate to a function taking 0 arguments (compiling source file C:\\msys64\\home\\rmills\\gnu\\github\\exiv2\\master\\src\\pngchunk_int.cpp) [C:\\msys64\\h \r\nome\\rmills\\gnu\\github\\exiv2\\master\\build\\src\\exiv2lib_int.vcxproj]                                                                                                                                                                               \r\nc:\\msys64\\home\\rmills\\gnu\\github\\exiv2\\master\\src\\safe_op.hpp(348): error C2064: term does not evaluate to a function taking 0 arguments (compiling source file C:\\msys64\\home\\rmills\\gnu\\github\\exiv2\\master\\src\\pngchunk_int.cpp) [C:\\msys64\\h \r\nome\\rmills\\gnu\\github\\exiv2\\master\\build\\src\\exiv2lib_int.vcxproj]                                                                                                                                                                               \r\nc:\\msys64\\home\\rmills\\gnu\\github\\exiv2\\master\\src\\safe_op.hpp(348): error C2039: 'type': is not a member of 'std::enable_if<false,void>' (compiling source file C:\\msys64\\home\\rmills\\gnu\\github\\exiv2\\master\\src\\pngchunk_int.cpp) [C:\\msys64\\h \r\nome\\rmills\\gnu\\github\\exiv2\\master\\build\\src\\exiv2lib_int.vcxproj]                                                                                                                                                                               \r\n  C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\type_traits(227): note: see declaration of 'std::enable_if<false,void>' (compiling source file C:\\msys64\\home\\rmills\\gnu\\github\\exiv2\\master\\src\\pngchunk_int.cpp)                                                                                                                                                                                                                           \r\nc:\\msys64\\home\\rmills\\gnu\\github\\exiv2\\master\\src\\safe_op.hpp(348): error C2146: syntax error: missing '>' before identifier 'type' (compiling source file C:\\msys64\\home\\rmills\\gnu\\github\\exiv2\\master\\src\\pngchunk_int.cpp) [C:\\msys64\\home\\r \r\nmills\\gnu\\github\\exiv2\\master\\build\\src\\exiv2lib_int.vcxproj]  \r\n```\r\n\r\nMy \"fix\" is to comment off some code in safe_op.hpp\r\n\r\n```\r\n    namespace Internal\r\n    {\r\n        template <typename from, typename to, typename = void>\r\n        struct is_safely_convertible : std::false_type\r\n        {\r\n            static_assert(std::is_integral<from>::value&& std::is_integral<to>::value,\r\n                          \"from and to must both be integral types\");\r\n        };\r\n/*\r\n        template <typename from, typename to>\r\n        struct is_safely_convertible<\r\n            from, to,\r\n            typename std::enable_if<((std::numeric_limits<from>::max() <= std::numeric_limits<to>::max()) &&\r\n                                     (std::numeric_limits<from>::min() >= std::numeric_limits<to>::min()))>::type>\r\n            : std::true_type\r\n        {\r\n        };\r\n*/\r\n```\r\n\r\n#### My reason to try this\r\n\r\nYou have two definitions for the template:\r\n```\r\ntemplate <typename from, typename to, typename = void>\r\nand\r\ntemplate <typename from, typename to>\r\n```\r\nThis might be ambiguous.\r\n\r\n#### Other ideas:\r\n\r\nI tried some other guesses and none of them compiled.  For example, I changed `::type` to `::typename` because it complained:\r\n\r\n```\r\nsafe_op.hpp(348): error C2146: syntax error: missing '>' before identifier 'type'\r\n``` \r\n\r\n#### My Suggestions\r\n\r\n1) is `type` correct on line 348?  For sure, I don't know what it means and apparently the compiler doesn't either!\r\n\r\n2) Only compile `template <typename from, typename to> .... };` for `#ifndef _MSC_VER`.  You'll loose safety for MSVC builds.  It could be a compiler bug that goes away in the future.  However it's there with both 2017 and 2019.\r\n\r\n3) It could be an SDK issue.  For both 2017 and 2019, CMake reports:\r\n```\r\nSelecting Windows SDK version 10.0.17763.0 to target Windows 10.0.17134.\r\n```\r\nI suspect a lot of the template voodoo comes from the SDK and not the compiler.  As CMake's announcing the SDK, it's likely that we could force him to use a different SDK with different consequences.",
      "Robin Mills <notifications@github.com> writes:\n\n> Gosh, Dan.  That's amazing code and I have no idea what it does!\n\nThat's usually a bad sign.\n\n>\n> I'm going to leave it to @piponazo to approve (although I will approve if you ask me).\n>\n> I got it to built and pass the test suite with msvc 2017/Release and 2019/Release (with a little code change).\n>\n> When I built, I got this error:\n> ```\n>   pngchunk_int.cpp                                                                                                                                                                                                                               \n> c:\\msys64\\home\\rmills\\gnu\\github\\exiv2\\master\\src\\safe_op.hpp(347): error C2064: term does not evaluate to a function taking 0 arguments (compiling source file C:\\msys64\\home\\rmills\\gnu\\github\\exiv2\\master\\src\\pngchunk_int.cpp) [C:\\msys64\\h \n> ome\\rmills\\gnu\\github\\exiv2\\master\\build\\src\\exiv2lib_int.vcxproj]                                                                                                                                                                               \n> c:\\msys64\\home\\rmills\\gnu\\github\\exiv2\\master\\src\\safe_op.hpp(348): error C2064: term does not evaluate to a function taking 0 arguments (compiling source file C:\\msys64\\home\\rmills\\gnu\\github\\exiv2\\master\\src\\pngchunk_int.cpp) [C:\\msys64\\h \n> ome\\rmills\\gnu\\github\\exiv2\\master\\build\\src\\exiv2lib_int.vcxproj]                                                                                                                                                                               \n> c:\\msys64\\home\\rmills\\gnu\\github\\exiv2\\master\\src\\safe_op.hpp(348): error C2039: 'type': is not a member of 'std::enable_if<false,void>' (compiling source file C:\\msys64\\home\\rmills\\gnu\\github\\exiv2\\master\\src\\pngchunk_int.cpp) [C:\\msys64\\h \n> ome\\rmills\\gnu\\github\\exiv2\\master\\build\\src\\exiv2lib_int.vcxproj]                                                                                                                                                                               \n>   C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\type_traits(227): note: see declaration of 'std::enable_if<false,void>' (compiling source file C:\\msys64\\home\\rmills\\gnu\\github\\exiv2\\master\\src\\pngchunk_int.cpp)                                                                                                                                                                                                                           \n> c:\\msys64\\home\\rmills\\gnu\\github\\exiv2\\master\\src\\safe_op.hpp(348): error C2146: syntax error: missing '>' before identifier 'type' (compiling source file C:\\msys64\\home\\rmills\\gnu\\github\\exiv2\\master\\src\\pngchunk_int.cpp) [C:\\msys64\\home\\r \n> mills\\gnu\\github\\exiv2\\master\\build\\src\\exiv2lib_int.vcxproj]  \n> ```\n>\n> My \"fix\" is to comment off some code in safe_op.hpp\n>\n> ```\n>     namespace Internal\n>     {\n>         template <typename from, typename to, typename = void>\n>         struct is_safely_convertible : std::false_type\n>         {\n>             static_assert(std::is_integral<from>::value&& std::is_integral<to>::value,\n>                           \"from and to must both be integral types\");\n>         };\n> /*\n>         template <typename from, typename to>\n>         struct is_safely_convertible<\n>             from, to,\n>             typename std::enable_if<((std::numeric_limits<from>::max() <= std::numeric_limits<to>::max()) &&\n>                                      (std::numeric_limits<from>::min() >= std::numeric_limits<to>::min()))>::type>\n>             : std::true_type\n>         {\n>         };\n> */\n> ```\n\nThis is unfortunately not really a fix, as it just comments out the\nproblematic part. The compiler error goes away, but the intended\nfunctionality is lost.\n\n>\n> #### My reason to try this\n>\n> You have two definitions for the template:\n> ```\n> template <typename from, typename to, typename = void>\n> and\n> template <typename from, typename to>\n> ```\n> This might be ambiguous.\n\nThat's kind of the point. What I'm doing here is called SFINAE\n(Substitution Failure Is Not An Error), which means that the compiler\ndoes not error out immediately when fails to insert a type in a template\noverload.\n\nLet's say you have two template overloads of the function foo:\n\ntemplate <typename T, typename = void>\nvoid foo()\n\nand\n\ntemplate <typename T>\nvoid foo<T, typename something_that_depends_on_T<T>::type>()\n\n\nWhen you instantiate foo, the compiler will start inserting the template\nparameters starting with the most specialized overload (here the second\none). It will insert T and then try to find out what\n`something_that_depends_on_T<T>::type` is. If the resolution of this\ntype results in an error, then this is **not** fatal. The compiler\nsimply tries the next less specialized template overload.\n\n\nYou can use this in conjunction with \"dummy\" template parameters\n(template parameters that have a unused default value and are not\nactually used in the template) to have multiple specializations of the\nsame function. You then provide a conditional type\n(`something_that_depends_on_T<T>::type` in the above example) that\nresolves only in the case when you want the overload and doesn't either.\n\n\n>\n> #### Other ideas:\n>\n> I tried some other guesses and none of them compiled.  For example, I changed `::type` to `::typename` because it complained:\n>\n> ```\n> safe_op.hpp(348): error C2146: syntax error: missing '>' before identifier 'type'\n> ```\n\nYes, that cannot work, because type is a public member of\nstd::enable_if.\n\n>\n> #### My Suggestions\n>\n> 1) is `type` correct on line 348?  For sure, I don't know what it means and apparently the compiler doesn't either!\n>\n\nIt is definitely correct. GCC and clang don't complain about this and\nwork without problems.\n\n> 2) Only compile `template <typename from, typename to> .... };` for `#ifndef _MSC_VER`.  You'll loose safety for MSVC builds.  It could be a compiler bug that goes away in the future.  However it's there with both 2017 and 2019.\n>\n\nNot including the overload for MSVC seriously cripples the overall\nusefulness of the whole code. I'd prefer not to do that unless MSVC\nreally doesn't cooperate.\n\n> 3) It could be an SDK issue.  For both 2017 and 2019, CMake reports:\n> ```\n> Selecting Windows SDK version 10.0.17763.0 to target Windows 10.0.17134.\n> ```\n> I suspect a lot of the template voodoo comes from the SDK and not the compiler.  As CMake's announcing the SDK, it's likely that we could force him to use a different SDK with different consequences.\n>\n\nUnlikely, as this uses only std::enable_if and std::numeric_limits (the\nformer can be implemented in ~5 lines of code and the latter is also\nvery simple, albeit requiring a lot of boilerplate code).\n\n> -- \n> You are receiving this because you authored the thread.\n> Reply to this email directly or view it on GitHub:\n> https://github.com/Exiv2/exiv2/pull/898#issuecomment-500241656\n",
      "Let's see if we can get this magic into v1.00."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\nAnalysis: The patch introduces an `enforce` statement to prevent negative integer overflow when `iccOffset` exceeds `chunkLength`, which could lead to undefined behavior or buffer overflow. The commit references issue #790, which likely involves a security-related defect. The code changes aim to mitigate a potential overflow, which could be exploited to cause system instability or data corruption.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 0.95"
}