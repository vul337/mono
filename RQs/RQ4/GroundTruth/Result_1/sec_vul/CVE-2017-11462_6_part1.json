{
  "cve_id": "CVE-2017-11462",
  "cwe_ids": [
    "CWE-415"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "krb5",
  "commit_msg": "Preserve GSS context on init/accept failure\n\nAfter gss_init_sec_context() or gss_accept_sec_context() has created a\ncontext, don't delete the mechglue context on failures from subsequent\ncalls, even if the mechanism deletes the mech-specific context (which\nis allowed by RFC 2744 but not preferred).  Check for union contexts\nwith no mechanism context in each GSS function which accepts a\ngss_ctx_id_t.\n\nCVE-2017-11462:\n\nRFC 2744 permits a GSS-API implementation to delete an existing\nsecurity context on a second or subsequent call to\ngss_init_sec_context() or gss_accept_sec_context() if the call results\nin an error.  This API behavior has been found to be dangerous,\nleading to the possibility of memory errors in some callers.  For\nsafety, GSS-API implementations should instead preserve existing\nsecurity contexts on error until the caller deletes them.\n\nAll versions of MIT krb5 prior to this change may delete acceptor\ncontexts on error.  Versions 1.13.4 through 1.13.7, 1.14.1 through\n1.14.5, and 1.15 through 1.15.1 may also delete initiator contexts on\nerror.\n\nticket: 8598 (new)\ntarget_version: 1.15-next\ntarget_version: 1.14-next\ntags: pullup",
  "commit_hash": "56f7b1bc95a2a3eeb420e069e7655fb181ade5cf",
  "git_url": "https://github.com/krb5/krb5/commit/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf",
  "file_path": "src/lib/gssapi/mechglue/g_prf.c",
  "func_name": "gss_pseudo_random",
  "func_before": "OM_uint32 KRB5_CALLCONV\ngss_pseudo_random (OM_uint32 *minor_status,\n\t           gss_ctx_id_t context_handle,\n\t           int prf_key,\n\t           const gss_buffer_t prf_in,\n\t           ssize_t desired_output_len,\n\t           gss_buffer_t prf_out)\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n\n    if (minor_status == NULL)\n\treturn GSS_S_CALL_INACCESSIBLE_WRITE;\n\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT;\n\n    if (prf_in == GSS_C_NO_BUFFER)\n\treturn GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT;\n\n    if (prf_out == GSS_C_NO_BUFFER)\n\treturn GSS_S_CALL_INACCESSIBLE_WRITE | GSS_S_NO_CONTEXT;\n\n    prf_out->length = 0;\n    prf_out->value = NULL;\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) context_handle;\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (mech != NULL) {\n\tif (mech->gss_pseudo_random != NULL) {\n\t    status = mech->gss_pseudo_random(minor_status,\n\t\t\t\t\t     ctx->internal_ctx_id,\n\t\t\t\t\t     prf_key,\n\t\t\t\t\t     prf_in,\n\t\t\t\t\t     desired_output_len,\n\t\t\t\t\t     prf_out);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\n\treturn status;\n    }\n\n    return GSS_S_BAD_MECH;\n}",
  "abstract_func_before": "OM_uint32 VAR_0\ngss_pseudo_random (OM_uint32 *VAR_1,\n\t           gss_ctx_id_t VAR_2,\n\t           int VAR_3,\n\t           const gss_buffer_t VAR_4,\n\t           ssize_t VAR_5,\n\t           gss_buffer_t VAR_6)\n{\n    OM_uint32\t\tVAR_7;\n    gss_union_ctx_id_t\tVAR_8;\n    gss_mechanism\tVAR_9;\n\n    if (VAR_1 == NULL)\n\treturn VAR_10;\n\n    if (VAR_2 == VAR_11)\n\treturn VAR_12 | VAR_13;\n\n    if (VAR_4 == VAR_14)\n\treturn VAR_12 | VAR_13;\n\n    if (VAR_6 == VAR_14)\n\treturn VAR_10 | VAR_13;\n\n    VAR_6->length = 0;\n    VAR_6->value = NULL;\n\n    /* COMMENT_0 */\n                                                             \n               \n       \n\n    VAR_8 = (gss_union_ctx_id_t) VAR_2;\n    VAR_9 = gssint_get_mechanism (VAR_8->mech_type);\n\n    if (VAR_9 != NULL) {\n\tif (VAR_9->gss_pseudo_random != NULL) {\n\t    VAR_7 = VAR_9->gss_pseudo_random(VAR_1,\n\t\t\t\t\t     VAR_8->internal_ctx_id,\n\t\t\t\t\t     VAR_3,\n\t\t\t\t\t     VAR_4,\n\t\t\t\t\t     VAR_5,\n\t\t\t\t\t     VAR_6);\n\t    if (VAR_7 != VAR_15)\n\t\tmap_error(VAR_1, VAR_9);\n\t} else\n\t    VAR_7 = VAR_16;\n\n\treturn VAR_7;\n    }\n\n    return VAR_17;\n}",
  "func_graph_path_before": null,
  "func": "OM_uint32 KRB5_CALLCONV\ngss_pseudo_random (OM_uint32 *minor_status,\n\t           gss_ctx_id_t context_handle,\n\t           int prf_key,\n\t           const gss_buffer_t prf_in,\n\t           ssize_t desired_output_len,\n\t           gss_buffer_t prf_out)\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n\n    if (minor_status == NULL)\n\treturn GSS_S_CALL_INACCESSIBLE_WRITE;\n\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT;\n\n    if (prf_in == GSS_C_NO_BUFFER)\n\treturn GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT;\n\n    if (prf_out == GSS_C_NO_BUFFER)\n\treturn GSS_S_CALL_INACCESSIBLE_WRITE | GSS_S_NO_CONTEXT;\n\n    prf_out->length = 0;\n    prf_out->value = NULL;\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn GSS_S_NO_CONTEXT;\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (mech != NULL) {\n\tif (mech->gss_pseudo_random != NULL) {\n\t    status = mech->gss_pseudo_random(minor_status,\n\t\t\t\t\t     ctx->internal_ctx_id,\n\t\t\t\t\t     prf_key,\n\t\t\t\t\t     prf_in,\n\t\t\t\t\t     desired_output_len,\n\t\t\t\t\t     prf_out);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\n\treturn status;\n    }\n\n    return GSS_S_BAD_MECH;\n}",
  "abstract_func": "OM_uint32 VAR_0\ngss_pseudo_random (OM_uint32 *VAR_1,\n\t           gss_ctx_id_t VAR_2,\n\t           int VAR_3,\n\t           const gss_buffer_t VAR_4,\n\t           ssize_t VAR_5,\n\t           gss_buffer_t VAR_6)\n{\n    OM_uint32\t\tVAR_7;\n    gss_union_ctx_id_t\tVAR_8;\n    gss_mechanism\tVAR_9;\n\n    if (VAR_1 == NULL)\n\treturn VAR_10;\n\n    if (VAR_2 == VAR_11)\n\treturn VAR_12 | VAR_13;\n\n    if (VAR_4 == VAR_14)\n\treturn VAR_12 | VAR_13;\n\n    if (VAR_6 == VAR_14)\n\treturn VAR_10 | VAR_13;\n\n    VAR_6->length = 0;\n    VAR_6->value = NULL;\n\n    /* COMMENT_0 */\n                                                             \n               \n       \n\n    VAR_8 = (gss_union_ctx_id_t) VAR_2;\n    if (VAR_8->internal_ctx_id == VAR_11)\n\treturn VAR_13;\n    VAR_9 = gssint_get_mechanism (VAR_8->mech_type);\n\n    if (VAR_9 != NULL) {\n\tif (VAR_9->gss_pseudo_random != NULL) {\n\t    VAR_7 = VAR_9->gss_pseudo_random(VAR_1,\n\t\t\t\t\t     VAR_8->internal_ctx_id,\n\t\t\t\t\t     VAR_3,\n\t\t\t\t\t     VAR_4,\n\t\t\t\t\t     VAR_5,\n\t\t\t\t\t     VAR_6);\n\t    if (VAR_7 != VAR_15)\n\t\tmap_error(VAR_1, VAR_9);\n\t} else\n\t    VAR_7 = VAR_16;\n\n\treturn VAR_7;\n    }\n\n    return VAR_17;\n}",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -31,6 +31,8 @@\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech != NULL) {",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)",
      "\treturn GSS_S_NO_CONTEXT;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/krb5/krb5/pull/677",
  "description": {
    "pr_info": {
      "title": "Preserve GSS context on init/accept failure",
      "number": 677
    },
    "comment": [
      "[@frozencemetery: please run interposer tests against this PR]\r\n\r\nAfter gss_init_sec_context() or gss_accept_sec_context() has created a\r\ncontext, don't delete the mechglue context on failures from subsequent\r\ncalls, even if the mechanism deletes the mech-specific context (which\r\nis allowed by RFC 2744 but not preferred).  Check for union contexts\r\nwith no mechanism context in each GSS function which accepts a\r\ngss_ctx_id_t.\r\n",
      "Interposer tests and gssproxy tests passing.  Will try to review in a bit."
    ]
  },
  "Bug Filter": "**\n   - The patch addresses a security vulnerability by preventing improper context deletion, which could be exploited to cause memory issues and unauthorized access.\n\n**Final Classification: Security Vulnerability Fix**\n\n**Confidence Score: 0.95**\n\nThe patch clearly targets a security issue (CVE-2017-11462) with a direct code fix, indicating high confidence in its classification as a security vulnerability fix.",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Analysis:**\n\n1. **Patch Analysis:**\n   - The commit message and code diff indicate that the patch addresses an issue where GSS contexts might be improperly deleted upon failure, leading to potential memory errors. This is identified as CVE-2017-11462.\n\n2. **Security Vulnerability Assessment:**\n   - The patch modifies the `gss_pseudo_random` function to check for a `GSS_C_NO_CONTEXT` condition, preventing improper deletion of contexts. This directly mitigates a known security vulnerability (CVE-2017-11462) that could lead to memory errors and unauthorized access.\n\n3. **Classification:**\n   - The patch addresses a security vulnerability by preventing improper context deletion, which could be exploited to cause memory issues and unauthorized access.\n\n**Final Classification: Security Vulnerability Fix**\n\n**Confidence Score: 0.95**\n\nThe patch clearly targets a security issue (CVE-2017-11462) with a direct code fix, indicating high confidence in its classification as a security vulnerability fix."
}