{
  "cve_id": "CVE-2024-24806",
  "cwe_ids": [
    "CWE-918"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L",
  "cvss_is_v3": true,
  "repo_name": "libuv",
  "commit_msg": "fix: always zero-terminate idna output\n\nFixes: https://github.com/libuv/libuv/security/advisories/GHSA-f74f-cvh7-c6q6",
  "commit_hash": "0f2d7e784a256b54b2385043438848047bc2a629",
  "git_url": "https://github.com/libuv/libuv/commit/0f2d7e784a256b54b2385043438848047bc2a629",
  "file_path": "src/idna.c",
  "func_name": "uv__idna_toascii",
  "func_before": "ssize_t uv__idna_toascii(const char* s, const char* se, char* d, char* de) {\n  const char* si;\n  const char* st;\n  unsigned c;\n  char* ds;\n  int rc;\n\n  ds = d;\n\n  si = s;\n  while (si < se) {\n    st = si;\n    c = uv__utf8_decode1(&si, se);\n\n    if (c == UINT_MAX)\n      return UV_EINVAL;\n\n    if (c != '.')\n      if (c != 0x3002)  /* 。 */\n        if (c != 0xFF0E)  /* ． */\n          if (c != 0xFF61)  /* ｡ */\n            continue;\n\n    rc = uv__idna_toascii_label(s, st, &d, de);\n\n    if (rc < 0)\n      return rc;\n\n    if (d < de)\n      *d++ = '.';\n\n    s = si;\n  }\n\n  if (s < se) {\n    rc = uv__idna_toascii_label(s, se, &d, de);\n\n    if (rc < 0)\n      return rc;\n  }\n\n  if (d < de)\n    *d++ = '\\0';\n\n  return d - ds;  /* Number of bytes written. */\n}",
  "abstract_func_before": "ssize_t uv__idna_toascii(const char* VAR_0, const char* VAR_1, char* VAR_2, char* VAR_3) {\n  const char* VAR_4;\n  const char* VAR_5;\n  unsigned VAR_6;\n  char* VAR_7;\n  int VAR_8;\n\n  VAR_7 = VAR_2;\n\n  VAR_4 = VAR_0;\n  while (VAR_4 < VAR_1) {\n    VAR_5 = VAR_4;\n    VAR_6 = uv__utf8_decode1(&VAR_4, VAR_1);\n\n    if (VAR_6 == VAR_9)\n      return VAR_10;\n\n    if (VAR_6 != '.')\n      if (VAR_6 != 0x3002)  /* COMMENT_0 */\n        if (VAR_6 != 0xFF0E)  /* COMMENT_1 */\n          if (VAR_6 != 0xFF61)  /* COMMENT_2 */\n            continue;\n\n    VAR_8 = uv__idna_toascii_label(VAR_0, VAR_5, &VAR_2, VAR_3);\n\n    if (VAR_8 < 0)\n      return VAR_8;\n\n    if (VAR_2 < VAR_3)\n      *VAR_2++ = '.';\n\n    VAR_0 = VAR_4;\n  }\n\n  if (VAR_0 < VAR_1) {\n    VAR_8 = uv__idna_toascii_label(VAR_0, VAR_1, &VAR_2, VAR_3);\n\n    if (VAR_8 < 0)\n      return VAR_8;\n  }\n\n  if (VAR_2 < VAR_3)\n    *VAR_2++ = '\\0';\n\n  return VAR_2 - VAR_7;  /* COMMENT_3 */\n}",
  "func_graph_path_before": "libuv/0f2d7e784a256b54b2385043438848047bc2a629/idna.c/vul/before/0.json",
  "func": "ssize_t uv__idna_toascii(const char* s, const char* se, char* d, char* de) {\n  const char* si;\n  const char* st;\n  unsigned c;\n  char* ds;\n  int rc;\n\n  ds = d;\n\n  si = s;\n  while (si < se) {\n    st = si;\n    c = uv__utf8_decode1(&si, se);\n\n    if (c == UINT_MAX)\n      return UV_EINVAL;\n\n    if (c != '.')\n      if (c != 0x3002)  /* 。 */\n        if (c != 0xFF0E)  /* ． */\n          if (c != 0xFF61)  /* ｡ */\n            continue;\n\n    rc = uv__idna_toascii_label(s, st, &d, de);\n\n    if (rc < 0)\n      return rc;\n\n    if (d < de)\n      *d++ = '.';\n\n    s = si;\n  }\n\n  if (s < se) {\n    rc = uv__idna_toascii_label(s, se, &d, de);\n\n    if (rc < 0)\n      return rc;\n  }\n\n  if (d >= de)\n    return UV_EINVAL;\n\n  *d++ = '\\0';\n  return d - ds;  /* Number of bytes written. */\n}",
  "abstract_func": "ssize_t uv__idna_toascii(const char* VAR_0, const char* VAR_1, char* VAR_2, char* VAR_3) {\n  const char* VAR_4;\n  const char* VAR_5;\n  unsigned VAR_6;\n  char* VAR_7;\n  int VAR_8;\n\n  VAR_7 = VAR_2;\n\n  VAR_4 = VAR_0;\n  while (VAR_4 < VAR_1) {\n    VAR_5 = VAR_4;\n    VAR_6 = uv__utf8_decode1(&VAR_4, VAR_1);\n\n    if (VAR_6 == VAR_9)\n      return VAR_10;\n\n    if (VAR_6 != '.')\n      if (VAR_6 != 0x3002)  /* COMMENT_0 */\n        if (VAR_6 != 0xFF0E)  /* COMMENT_1 */\n          if (VAR_6 != 0xFF61)  /* COMMENT_2 */\n            continue;\n\n    VAR_8 = uv__idna_toascii_label(VAR_0, VAR_5, &VAR_2, VAR_3);\n\n    if (VAR_8 < 0)\n      return VAR_8;\n\n    if (VAR_2 < VAR_3)\n      *VAR_2++ = '.';\n\n    VAR_0 = VAR_4;\n  }\n\n  if (VAR_0 < VAR_1) {\n    VAR_8 = uv__idna_toascii_label(VAR_0, VAR_1, &VAR_2, VAR_3);\n\n    if (VAR_8 < 0)\n      return VAR_8;\n  }\n\n  if (VAR_2 >= VAR_3)\n    return VAR_10;\n\n  *VAR_2++ = '\\0';\n  return VAR_2 - VAR_7;  /* COMMENT_3 */\n}",
  "func_graph_path": "libuv/0f2d7e784a256b54b2385043438848047bc2a629/idna.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -39,8 +39,9 @@\n       return rc;\n   }\n \n-  if (d < de)\n-    *d++ = '\\0';\n+  if (d >= de)\n+    return UV_EINVAL;\n \n+  *d++ = '\\0';\n   return d - ds;  /* Number of bytes written. */\n }",
  "diff_line_info": {
    "deleted_lines": [
      "  if (d < de)",
      "    *d++ = '\\0';"
    ],
    "added_lines": [
      "  if (d >= de)",
      "    return UV_EINVAL;",
      "  *d++ = '\\0';"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libuv/libuv/pull/4305",
  "description": {
    "pr_info": {
      "title": "Merge 1.48.0 to master",
      "number": 4305
    },
    "comment": [
      "Mostly clean merge. The usual fixup commit visible here that I will squash into the merge itself before pushing this to master once @bnoordhuis gives the RSLGTM"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix\n\nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses a security vulnerability by ensuring proper null-termination of the IDNA output, preventing potential buffer overflows.\n\nFinal Classification: Security Vulnerability Fix\n\nConfidence Score: 0.95"
}