{
  "cve_id": "CVE-2018-16391",
  "cwe_ids": [
    "CWE-415",
    "CWE-119"
  ],
  "cvss_vector": "AV:L/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "OpenSC",
  "commit_msg": "fixed out of bounds writes\n\nThanks to Eric Sesterhenn from X41 D-SEC GmbH\nfor reporting the problems.",
  "commit_hash": "360e95d45ac4123255a4c796db96337f332160ad",
  "git_url": "https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad",
  "file_path": "src/libopensc/card-epass2003.c",
  "func_name": "decrypt_response",
  "func_before": "static int\ndecrypt_response(struct sc_card *card, unsigned char *in, size_t inlen, unsigned char *out, size_t * out_len)\n{\n\tsize_t cipher_len;\n\tsize_t i;\n\tunsigned char iv[16] = { 0 };\n\tunsigned char plaintext[4096] = { 0 };\n\tepass2003_exdata *exdata = NULL;\n\n\tif (!card->drv_data) \n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\texdata = (epass2003_exdata *)card->drv_data;\n\n\t/* no cipher */\n\tif (in[0] == 0x99)\n\t\treturn 0;\n\n\t/* parse cipher length */\n\tif (0x01 == in[2] && 0x82 != in[1]) {\n\t\tcipher_len = in[1];\n\t\ti = 3;\n\t}\n\telse if (0x01 == in[3] && 0x81 == in[1]) {\n\t\tcipher_len = in[2];\n\t\ti = 4;\n\t}\n\telse if (0x01 == in[4] && 0x82 == in[1]) {\n\t\tcipher_len = in[2] * 0x100;\n\t\tcipher_len += in[3];\n\t\ti = 5;\n\t}\n\telse {\n\t\treturn -1;\n\t}\n\n\tif (cipher_len < 2 || i+cipher_len > inlen || cipher_len > sizeof plaintext)\n\t\treturn -1;\n\n\t/* decrypt */\n\tif (KEY_TYPE_AES == exdata->smtype)\n\t\taes128_decrypt_cbc(exdata->sk_enc, 16, iv, &in[i], cipher_len - 1, plaintext);\n\telse\n\t\tdes3_decrypt_cbc(exdata->sk_enc, 16, iv, &in[i], cipher_len - 1, plaintext);\n\n\t/* unpadding */\n\twhile (0x80 != plaintext[cipher_len - 2] && (cipher_len - 2 > 0))\n\t\tcipher_len--;\n\n\tif (2 == cipher_len)\n\t\treturn -1;\n\n\tmemcpy(out, plaintext, cipher_len - 2);\n\t*out_len = cipher_len - 2;\n\treturn 0;\n}",
  "abstract_func_before": "static int\ndecrypt_response(struct sc_card *VAR_0, unsigned char *VAR_1, size_t VAR_2, unsigned char *VAR_3, size_t * VAR_4)\n{\n\tsize_t VAR_5;\n\tsize_t VAR_6;\n\tunsigned char VAR_7[16] = { 0 };\n\tunsigned char VAR_8[4096] = { 0 };\n\tepass2003_exdata *VAR_9 = NULL;\n\n\tif (!VAR_0->drv_data) \n\t\treturn VAR_10;\n\n\tVAR_9 = (epass2003_exdata *)VAR_0->drv_data;\n\n\t/* COMMENT_0 */\n\tif (VAR_1[0] == 0x99)\n\t\treturn 0;\n\n\t/* COMMENT_1 */\n\tif (0x01 == VAR_1[2] && 0x82 != VAR_1[1]) {\n\t\tVAR_5 = VAR_1[1];\n\t\tVAR_6 = 3;\n\t}\n\telse if (0x01 == VAR_1[3] && 0x81 == VAR_1[1]) {\n\t\tVAR_5 = VAR_1[2];\n\t\tVAR_6 = 4;\n\t}\n\telse if (0x01 == VAR_1[4] && 0x82 == VAR_1[1]) {\n\t\tVAR_5 = VAR_1[2] * 0x100;\n\t\tVAR_5 += VAR_1[3];\n\t\tVAR_6 = 5;\n\t}\n\telse {\n\t\treturn -1;\n\t}\n\n\tif (VAR_5 < 2 || VAR_6+VAR_5 > VAR_2 || VAR_5 > sizeof VAR_8)\n\t\treturn -1;\n\n\t/* COMMENT_2 */\n\tif (VAR_11 == VAR_9->smtype)\n\t\taes128_decrypt_cbc(VAR_9->sk_enc, 16, VAR_7, &VAR_1[VAR_6], VAR_5 - 1, VAR_8);\n\telse\n\t\tdes3_decrypt_cbc(VAR_9->sk_enc, 16, VAR_7, &VAR_1[VAR_6], VAR_5 - 1, VAR_8);\n\n\t/* COMMENT_3 */\n\twhile (0x80 != VAR_8[VAR_5 - 2] && (VAR_5 - 2 > 0))\n\t\tVAR_5--;\n\n\tif (2 == VAR_5)\n\t\treturn -1;\n\n\tmemcpy(VAR_3, VAR_8, VAR_5 - 2);\n\t*VAR_4 = VAR_5 - 2;\n\treturn 0;\n}",
  "func_graph_path_before": "OpenSC/360e95d45ac4123255a4c796db96337f332160ad/card-epass2003.c/vul/before/0.json",
  "func": "static int\ndecrypt_response(struct sc_card *card, unsigned char *in, size_t inlen, unsigned char *out, size_t * out_len)\n{\n\tsize_t cipher_len;\n\tsize_t i;\n\tunsigned char iv[16] = { 0 };\n\tunsigned char plaintext[4096] = { 0 };\n\tepass2003_exdata *exdata = NULL;\n\n\tif (!card->drv_data) \n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\texdata = (epass2003_exdata *)card->drv_data;\n\n\t/* no cipher */\n\tif (in[0] == 0x99)\n\t\treturn 0;\n\n\t/* parse cipher length */\n\tif (0x01 == in[2] && 0x82 != in[1]) {\n\t\tcipher_len = in[1];\n\t\ti = 3;\n\t}\n\telse if (0x01 == in[3] && 0x81 == in[1]) {\n\t\tcipher_len = in[2];\n\t\ti = 4;\n\t}\n\telse if (0x01 == in[4] && 0x82 == in[1]) {\n\t\tcipher_len = in[2] * 0x100;\n\t\tcipher_len += in[3];\n\t\ti = 5;\n\t}\n\telse {\n\t\treturn -1;\n\t}\n\n\tif (cipher_len < 2 || i+cipher_len > inlen || cipher_len > sizeof plaintext)\n\t\treturn -1;\n\n\t/* decrypt */\n\tif (KEY_TYPE_AES == exdata->smtype)\n\t\taes128_decrypt_cbc(exdata->sk_enc, 16, iv, &in[i], cipher_len - 1, plaintext);\n\telse\n\t\tdes3_decrypt_cbc(exdata->sk_enc, 16, iv, &in[i], cipher_len - 1, plaintext);\n\n\t/* unpadding */\n\twhile (0x80 != plaintext[cipher_len - 2] && (cipher_len - 2 > 0))\n\t\tcipher_len--;\n\n\tif (2 == cipher_len || *out_len < cipher_len - 2)\n\t\treturn -1;\n\n\tmemcpy(out, plaintext, cipher_len - 2);\n\t*out_len = cipher_len - 2;\n\treturn 0;\n}",
  "abstract_func": "static int\ndecrypt_response(struct sc_card *VAR_0, unsigned char *VAR_1, size_t VAR_2, unsigned char *VAR_3, size_t * VAR_4)\n{\n\tsize_t VAR_5;\n\tsize_t VAR_6;\n\tunsigned char VAR_7[16] = { 0 };\n\tunsigned char VAR_8[4096] = { 0 };\n\tepass2003_exdata *VAR_9 = NULL;\n\n\tif (!VAR_0->drv_data) \n\t\treturn VAR_10;\n\n\tVAR_9 = (epass2003_exdata *)VAR_0->drv_data;\n\n\t/* COMMENT_0 */\n\tif (VAR_1[0] == 0x99)\n\t\treturn 0;\n\n\t/* COMMENT_1 */\n\tif (0x01 == VAR_1[2] && 0x82 != VAR_1[1]) {\n\t\tVAR_5 = VAR_1[1];\n\t\tVAR_6 = 3;\n\t}\n\telse if (0x01 == VAR_1[3] && 0x81 == VAR_1[1]) {\n\t\tVAR_5 = VAR_1[2];\n\t\tVAR_6 = 4;\n\t}\n\telse if (0x01 == VAR_1[4] && 0x82 == VAR_1[1]) {\n\t\tVAR_5 = VAR_1[2] * 0x100;\n\t\tVAR_5 += VAR_1[3];\n\t\tVAR_6 = 5;\n\t}\n\telse {\n\t\treturn -1;\n\t}\n\n\tif (VAR_5 < 2 || VAR_6+VAR_5 > VAR_2 || VAR_5 > sizeof VAR_8)\n\t\treturn -1;\n\n\t/* COMMENT_2 */\n\tif (VAR_11 == VAR_9->smtype)\n\t\taes128_decrypt_cbc(VAR_9->sk_enc, 16, VAR_7, &VAR_1[VAR_6], VAR_5 - 1, VAR_8);\n\telse\n\t\tdes3_decrypt_cbc(VAR_9->sk_enc, 16, VAR_7, &VAR_1[VAR_6], VAR_5 - 1, VAR_8);\n\n\t/* COMMENT_3 */\n\twhile (0x80 != VAR_8[VAR_5 - 2] && (VAR_5 - 2 > 0))\n\t\tVAR_5--;\n\n\tif (2 == VAR_5 || *VAR_4 < VAR_5 - 2)\n\t\treturn -1;\n\n\tmemcpy(VAR_3, VAR_8, VAR_5 - 2);\n\t*VAR_4 = VAR_5 - 2;\n\treturn 0;\n}",
  "func_graph_path": "OpenSC/360e95d45ac4123255a4c796db96337f332160ad/card-epass2003.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -47,7 +47,7 @@\n \twhile (0x80 != plaintext[cipher_len - 2] && (cipher_len - 2 > 0))\n \t\tcipher_len--;\n \n-\tif (2 == cipher_len)\n+\tif (2 == cipher_len || *out_len < cipher_len - 2)\n \t\treturn -1;\n \n \tmemcpy(out, plaintext, cipher_len - 2);",
  "diff_line_info": {
    "deleted_lines": [
      "\tif (2 == cipher_len)"
    ],
    "added_lines": [
      "\tif (2 == cipher_len || *out_len < cipher_len - 2)"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/OpenSC/OpenSC/pull/1447",
  "description": {
    "pr_info": {
      "title": "Security issues identified by fuzzing",
      "number": 1447
    },
    "comment": [
      "This PR merges changes addressing issues identified by fuzzing OpenSC driver by Eric Sesterhenn. The separate commits are authored mostly by @frankmorgner, @dengert, Eric and me.\r\n\r\nFor more information, see the blog post:\r\n\r\nhttps://www.x41-dsec.de/lab/blog/smartcards/\r\n\r\nThe changes were tested to ensure they still work for the cards we have, but testing with more cards would be always appreciated.\r\n\r\n##### Checklist\r\n<!-- Remove items that do not apply. For completed items, change [ ] to [x]. -->\r\n- [X] PKCS#11 module is tested\r\n- [ ] Windows minidriver is tested\r\n- [ ] macOS tokend is tested\r\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses an out-of-bounds write vulnerability, which is a security issue. The code change ensures that the output buffer is large enough, preventing potential buffer overflow attacks. This is a clear security vulnerability fix.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 1.0"
}