{
  "cve_id": "CVE-2016-4301",
  "cwe_ids": [
    "CWE-119"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "libarchive",
  "commit_msg": "Fix libarchive/archive_read_support_format_mtree.c:1388:11: error: array subscript is above array bounds",
  "commit_hash": "a550daeecf6bc689ade371349892ea17b5b97c77",
  "git_url": "https://github.com/libarchive/libarchive/commit/a550daeecf6bc689ade371349892ea17b5b97c77",
  "file_path": "libarchive/archive_read_support_format_mtree.c",
  "func_name": "parse_device",
  "func_before": "static int\nparse_device(dev_t *pdev, struct archive *a, char *val)\n{\n#define MAX_PACK_ARGS 3\n\tunsigned long numbers[MAX_PACK_ARGS];\n\tchar *p, *dev;\n\tint argc;\n\tpack_t *pack;\n\tdev_t result;\n\tconst char *error = NULL;\n\n\tmemset(pdev, 0, sizeof(*pdev));\n\tif ((dev = strchr(val, ',')) != NULL) {\n\t\t/*\n\t\t * Device's major/minor are given in a specified format.\n\t\t * Decode and pack it accordingly.\n\t\t */\n\t\t*dev++ = '\\0';\n\t\tif ((pack = pack_find(val)) == NULL) {\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Unknown format `%s'\", val);\n\t\t\treturn ARCHIVE_WARN;\n\t\t}\n\t\targc = 0;\n\t\twhile ((p = la_strsep(&dev, \",\")) != NULL) {\n\t\t\tif (*p == '\\0') {\n\t\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Missing number\");\n\t\t\t\treturn ARCHIVE_WARN;\n\t\t\t}\n\t\t\tnumbers[argc++] = (unsigned long)mtree_atol(&p);\n\t\t\tif (argc > MAX_PACK_ARGS) {\n\t\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Too many arguments\");\n\t\t\t\treturn ARCHIVE_WARN;\n\t\t\t}\n\t\t}\n\t\tif (argc < 2) {\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Not enough arguments\");\n\t\t\treturn ARCHIVE_WARN;\n\t\t}\n\t\tresult = (*pack)(argc, numbers, &error);\n\t\tif (error != NULL) {\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"%s\", error);\n\t\t\treturn ARCHIVE_WARN;\n\t\t}\n\t} else {\n\t\t/* file system raw value. */\n\t\tresult = (dev_t)mtree_atol(&val);\n\t}\n\t*pdev = result;\n\treturn ARCHIVE_OK;\n#undef MAX_PACK_ARGS\n}",
  "abstract_func_before": "static int\nparse_device(dev_t *VAR_0, struct archive *VAR_1, char *VAR_2)\n{\n#define VAR_3 3\n\tunsigned long VAR_4[VAR_3];\n\tchar *VAR_5, *VAR_6;\n\tint VAR_7;\n\tpack_t *VAR_8;\n\tdev_t VAR_9;\n\tconst char *VAR_10 = NULL;\n\n\tmemset(VAR_0, 0, sizeof(*VAR_0));\n\tif ((VAR_6 = strchr(VAR_2, ',')) != NULL) {\n\t\t/* COMMENT_0 */\n                                                          \n                                    \n     \n\t\t*VAR_6++ = '\\0';\n\t\tif ((VAR_8 = pack_find(VAR_2)) == NULL) {\n\t\t\tarchive_set_error(VAR_1, VAR_11,\n\t\t\t    \"Unknown format `%s'\", VAR_2);\n\t\t\treturn VAR_12;\n\t\t}\n\t\tVAR_7 = 0;\n\t\twhile ((VAR_5 = la_strsep(&VAR_6, \",\")) != NULL) {\n\t\t\tif (*VAR_5 == '\\0') {\n\t\t\t\tarchive_set_error(VAR_1, VAR_11,\n\t\t\t\t    \"Missing number\");\n\t\t\t\treturn VAR_12;\n\t\t\t}\n\t\t\tVAR_4[VAR_7++] = (unsigned long)mtree_atol(&VAR_5);\n\t\t\tif (VAR_7 > VAR_3) {\n\t\t\t\tarchive_set_error(VAR_1, VAR_11,\n\t\t\t\t    \"Too many arguments\");\n\t\t\t\treturn VAR_12;\n\t\t\t}\n\t\t}\n\t\tif (VAR_7 < 2) {\n\t\t\tarchive_set_error(VAR_1, VAR_11,\n\t\t\t    \"Not enough arguments\");\n\t\t\treturn VAR_12;\n\t\t}\n\t\tVAR_9 = (*VAR_8)(VAR_7, VAR_4, &VAR_10);\n\t\tif (VAR_10 != NULL) {\n\t\t\tarchive_set_error(VAR_1, VAR_11,\n\t\t\t    \"%s\", VAR_10);\n\t\t\treturn VAR_12;\n\t\t}\n\t} else {\n\t\t/* COMMENT_4 */\n\t\tVAR_9 = (dev_t)mtree_atol(&VAR_2);\n\t}\n\t*VAR_0 = VAR_9;\n\treturn VAR_13;\n#undef MAX_PACK_ARGS\n}",
  "func_graph_path_before": "libarchive/a550daeecf6bc689ade371349892ea17b5b97c77/archive_read_support_format_mtree.c/vul/before/0.json",
  "func": "static int\nparse_device(dev_t *pdev, struct archive *a, char *val)\n{\n#define MAX_PACK_ARGS 3\n\tunsigned long numbers[MAX_PACK_ARGS];\n\tchar *p, *dev;\n\tint argc;\n\tpack_t *pack;\n\tdev_t result;\n\tconst char *error = NULL;\n\n\tmemset(pdev, 0, sizeof(*pdev));\n\tif ((dev = strchr(val, ',')) != NULL) {\n\t\t/*\n\t\t * Device's major/minor are given in a specified format.\n\t\t * Decode and pack it accordingly.\n\t\t */\n\t\t*dev++ = '\\0';\n\t\tif ((pack = pack_find(val)) == NULL) {\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Unknown format `%s'\", val);\n\t\t\treturn ARCHIVE_WARN;\n\t\t}\n\t\targc = 0;\n\t\twhile ((p = la_strsep(&dev, \",\")) != NULL) {\n\t\t\tif (*p == '\\0') {\n\t\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Missing number\");\n\t\t\t\treturn ARCHIVE_WARN;\n\t\t\t}\n\t\t\tif (argc >= MAX_PACK_ARGS) {\n\t\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Too many arguments\");\n\t\t\t\treturn ARCHIVE_WARN;\n\t\t\t}\n\t\t\tnumbers[argc++] = (unsigned long)mtree_atol(&p);\n\t\t}\n\t\tif (argc < 2) {\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Not enough arguments\");\n\t\t\treturn ARCHIVE_WARN;\n\t\t}\n\t\tresult = (*pack)(argc, numbers, &error);\n\t\tif (error != NULL) {\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"%s\", error);\n\t\t\treturn ARCHIVE_WARN;\n\t\t}\n\t} else {\n\t\t/* file system raw value. */\n\t\tresult = (dev_t)mtree_atol(&val);\n\t}\n\t*pdev = result;\n\treturn ARCHIVE_OK;\n#undef MAX_PACK_ARGS\n}",
  "abstract_func": "static int\nparse_device(dev_t *VAR_0, struct archive *VAR_1, char *VAR_2)\n{\n#define VAR_3 3\n\tunsigned long VAR_4[VAR_3];\n\tchar *VAR_5, *VAR_6;\n\tint VAR_7;\n\tpack_t *VAR_8;\n\tdev_t VAR_9;\n\tconst char *VAR_10 = NULL;\n\n\tmemset(VAR_0, 0, sizeof(*VAR_0));\n\tif ((VAR_6 = strchr(VAR_2, ',')) != NULL) {\n\t\t/* COMMENT_0 */\n                                                          \n                                    \n     \n\t\t*VAR_6++ = '\\0';\n\t\tif ((VAR_8 = pack_find(VAR_2)) == NULL) {\n\t\t\tarchive_set_error(VAR_1, VAR_11,\n\t\t\t    \"Unknown format `%s'\", VAR_2);\n\t\t\treturn VAR_12;\n\t\t}\n\t\tVAR_7 = 0;\n\t\twhile ((VAR_5 = la_strsep(&VAR_6, \",\")) != NULL) {\n\t\t\tif (*VAR_5 == '\\0') {\n\t\t\t\tarchive_set_error(VAR_1, VAR_11,\n\t\t\t\t    \"Missing number\");\n\t\t\t\treturn VAR_12;\n\t\t\t}\n\t\t\tif (VAR_7 >= VAR_3) {\n\t\t\t\tarchive_set_error(VAR_1, VAR_11,\n\t\t\t\t    \"Too many arguments\");\n\t\t\t\treturn VAR_12;\n\t\t\t}\n\t\t\tVAR_4[VAR_7++] = (unsigned long)mtree_atol(&VAR_5);\n\t\t}\n\t\tif (VAR_7 < 2) {\n\t\t\tarchive_set_error(VAR_1, VAR_11,\n\t\t\t    \"Not enough arguments\");\n\t\t\treturn VAR_12;\n\t\t}\n\t\tVAR_9 = (*VAR_8)(VAR_7, VAR_4, &VAR_10);\n\t\tif (VAR_10 != NULL) {\n\t\t\tarchive_set_error(VAR_1, VAR_11,\n\t\t\t    \"%s\", VAR_10);\n\t\t\treturn VAR_12;\n\t\t}\n\t} else {\n\t\t/* COMMENT_4 */\n\t\tVAR_9 = (dev_t)mtree_atol(&VAR_2);\n\t}\n\t*VAR_0 = VAR_9;\n\treturn VAR_13;\n#undef MAX_PACK_ARGS\n}",
  "func_graph_path": "libarchive/a550daeecf6bc689ade371349892ea17b5b97c77/archive_read_support_format_mtree.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -28,12 +28,12 @@\n \t\t\t\t    \"Missing number\");\n \t\t\t\treturn ARCHIVE_WARN;\n \t\t\t}\n-\t\t\tnumbers[argc++] = (unsigned long)mtree_atol(&p);\n-\t\t\tif (argc > MAX_PACK_ARGS) {\n+\t\t\tif (argc >= MAX_PACK_ARGS) {\n \t\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n \t\t\t\t    \"Too many arguments\");\n \t\t\t\treturn ARCHIVE_WARN;\n \t\t\t}\n+\t\t\tnumbers[argc++] = (unsigned long)mtree_atol(&p);\n \t\t}\n \t\tif (argc < 2) {\n \t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,",
  "diff_line_info": {
    "deleted_lines": [
      "\t\t\tnumbers[argc++] = (unsigned long)mtree_atol(&p);",
      "\t\t\tif (argc > MAX_PACK_ARGS) {"
    ],
    "added_lines": [
      "\t\t\tif (argc >= MAX_PACK_ARGS) {",
      "\t\t\tnumbers[argc++] = (unsigned long)mtree_atol(&p);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libarchive/libarchive/pull/715",
  "description": {
    "pr_info": {
      "title": "Fix libarchive/archive_read_support_format_mtree.c:1388:11: error: arâ€¦",
      "number": 715
    },
    "comment": [
      " Version of libarchive: libarchive-3.2.0\n How you obtained it:  Source from git release  libarchive-3.2.0.tar.gz\n Operating system and version: Ubuntu 14.04\n What compiler and/or IDE you are using (include version): arm-none-linux-gnueabi\n\nThis patch fix a bug (see below) that we found while crosscompiling libarchive-3.2.0 to build opkg for arm platform. \n\n```\nmake  all-am\nmake[1]: Entering directory `/mnt/host/libarchive-3.2.0'\n  CC       libarchive/archive_read_support_format_mtree.lo\ncc1: warnings being treated as errors\nlibarchive/archive_read_support_format_mtree.c: In function 'parse_device':\nlibarchive/archive_read_support_format_mtree.c:1388:11: error: array subscript is above array bounds\nmake[1]: *** [libarchive/archive_read_support_format_mtree.lo] Error 1\nmake[1]: Leaving directory `/mnt/host/libarchive-3.2.0'\nmake: *** [all] Error \n```\n",
      "Thank you!\n",
      "[TALOS-2016-0153](http://www.talosintel.com/reports/TALOS-2016-0153)\nCVE-2016-4301\n",
      "Looking at the git history, this issue seem to have been introduced in git commit 4e002d9a92ecd7cec0fb98b0bedbace8aad81f6e , and was introduced between version 3.1.2 and 3.2.0.  It was present in the version tagged with v3.1.900a in git.\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix\n\nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses an array out-of-bounds issue, which is a common security vulnerability. The presence of a CVE number (CVE-2016-4301) indicates that this fix is for a security vulnerability. The code change modifies the bounds check to prevent accessing the array beyond its allocated size, which could lead to crashes or potential exploitation.\n\nFinal Classification: Security Vulnerability Fix\n\nConfidence Score: 1.0"
}