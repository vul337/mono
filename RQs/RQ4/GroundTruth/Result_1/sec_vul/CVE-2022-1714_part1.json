{
  "cve_id": "CVE-2022-1714",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:L/AC:L/Au:N/C:P/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "radareorg/radare2",
  "commit_msg": "Fix 4 byte oobread in msp430 disassembler ##crash\n\n* Only crashes with asan builds\n* Add missing =SN register\n* Reported by cnitlrt via huntrdev\n* BountyID: 1c22055b-b015-47a8-a57b-4982978751d0",
  "commit_hash": "3ecdbf8e21186a9c5a4d3cfa3b1e9fd27045340e",
  "git_url": "https://github.com/radareorg/radare2/commit/3ecdbf8e21186a9c5a4d3cfa3b1e9fd27045340e",
  "file_path": "libr/anal/p/anal_msp430.c",
  "func_name": "msp430_op",
  "func_before": "static int msp430_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *buf, int len, RAnalOpMask mask) {\n\tint ret;\n\tstruct msp430_cmd cmd;\n\n\tmemset (&cmd, 0, sizeof (cmd));\n\t//op->id = ???;\n\top->size = -1;\n\top->nopcode = 1;\n\top->type = R_ANAL_OP_TYPE_UNK;\n\top->family = R_ANAL_OP_FAMILY_CPU;\n\n\tret = op->size = msp430_decode_command (buf, len, &cmd);\n\tif (mask & R_ANAL_OP_MASK_DISASM) {\n\t\tif (ret < 1) {\n\t\t\top->mnemonic = strdup (\"invalid\");\n\t\t} else if (ret > 0) {\n\t\t\tif (cmd.operands[0]) {\n\t\t\t\top->mnemonic = r_str_newf (\"%s %s\",cmd.instr, cmd.operands);\n\t\t\t} else {\n\t\t\t\top->mnemonic = strdup (cmd.instr);\n\t\t\t}\n\t\t}\n\t\t{ // if (a->syntax != R_ASM_SYNTAX_ATT)\n\t\t\tchar *ba = op->mnemonic;\n\t\t\tr_str_replace_ch (ba, '#', 0, 1);\n\t\t\t// r_str_replace_ch (ba, \"$\", \"$$\", 1);\n\t\t\tr_str_replace_ch (ba, '&', 0, 1);\n\t\t\tr_str_replace_ch (ba, '%', 0, 1);\n\t\t}\n\t}\n\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\top->addr = addr;\n\n\tswitch (cmd.type) {\n\tcase MSP430_ONEOP:\n\t\tswitch (cmd.opcode) {\n\t\tcase MSP430_RRA:\n\t\tcase MSP430_RRC:\n\t\t\top->type = R_ANAL_OP_TYPE_ROR;\n\t\t\tbreak;\n\t\tcase MSP430_PUSH:\n\t\t\top->type = R_ANAL_OP_TYPE_PUSH;\n\t\t\tbreak;\n\t\tcase MSP430_CALL:\n\t\t\top->type = R_ANAL_OP_TYPE_CALL;\n\t\t\top->fail = addr + op->size;\n\t\t\top->jump = r_read_at_le16 (buf, 2);\n\t\t\tbreak;\n\t\tcase MSP430_RETI:\n\t\t\top->type = R_ANAL_OP_TYPE_RET;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase MSP430_TWOOP:\n\t\tswitch (cmd.opcode) {\n\t\tcase MSP430_BIT:\n\t\tcase MSP430_BIC:\n\t\tcase MSP430_BIS:\n\t\tcase MSP430_MOV:\n\t\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\t\tif ((cmd.instr)[0] == 'b' && (cmd.instr)[1] == 'r') {\n\t\t\t\t// Emulated branch instruction, moves source operand to PC register.\n\t\t\t\top->type = R_ANAL_OP_TYPE_UJMP;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MSP430_DADD:\n\t\tcase MSP430_ADDC:\n\t\tcase MSP430_ADD: op->type = R_ANAL_OP_TYPE_ADD; break;\n\t\tcase MSP430_SUBC:\n\t\tcase MSP430_SUB: op->type = R_ANAL_OP_TYPE_SUB; break;\n\t\tcase MSP430_CMP: op->type = R_ANAL_OP_TYPE_CMP; break;\n\t\tcase MSP430_XOR: op->type = R_ANAL_OP_TYPE_XOR; break;\n\t\tcase MSP430_AND: op->type = R_ANAL_OP_TYPE_AND; break;\n\t\t}\n\t\tbreak;\n\tcase MSP430_JUMP:\n\t\tif (cmd.jmp_cond == MSP430_JMP) {\n\t\t\top->type = R_ANAL_OP_TYPE_JMP;\n\t\t} else {\n\t\t\top->type = R_ANAL_OP_TYPE_CJMP;\n\t\t}\n\t\top->jump = addr + cmd.jmp_addr;\n\t\top->fail = addr + 2;\n\t\tbreak;\n\tcase MSP430_INV:\n\t\top->type = R_ANAL_OP_TYPE_ILL;\n\t\tbreak;\n\tdefault:\n\t\top->type = R_ANAL_OP_TYPE_UNK;\n\t\tbreak;\n\t}\n\treturn ret;\n}",
  "abstract_func_before": "static int msp430_op(RAnal *VAR_0, RAnalOp *VAR_1, ut64 VAR_2, const ut8 *VAR_3, int VAR_4, RAnalOpMask VAR_5) {\n\tint VAR_6;\n\tstruct msp430_cmd VAR_7;\n\n\tmemset (&VAR_7, 0, sizeof (VAR_7));\n\t/* COMMENT_0 */\n\tVAR_1->size = -1;\n\tVAR_1->nopcode = 1;\n\tVAR_1->type = VAR_8;\n\tVAR_1->family = VAR_9;\n\n\tVAR_6 = VAR_1->size = msp430_decode_command (VAR_3, VAR_4, &VAR_7);\n\tif (VAR_5 & VAR_10) {\n\t\tif (VAR_6 < 1) {\n\t\t\tVAR_1->mnemonic = strdup (\"invalid\");\n\t\t} else if (VAR_6 > 0) {\n\t\t\tif (VAR_7.operands[0]) {\n\t\t\t\tVAR_1->mnemonic = r_str_newf (\"%s %s\",VAR_7.instr, VAR_7.operands);\n\t\t\t} else {\n\t\t\t\tVAR_1->mnemonic = strdup (VAR_7.instr);\n\t\t\t}\n\t\t}\n\t\t{ /* COMMENT_1 */\n\t\t\tchar *VAR_11 = VAR_1->mnemonic;\n\t\t\tr_str_replace_ch (VAR_11, '#', 0, 1);\n\t\t\t/* COMMENT_2 */\n\t\t\tr_str_replace_ch (VAR_11, '&', 0, 1);\n\t\t\tr_str_replace_ch (VAR_11, '%', 0, 1);\n\t\t}\n\t}\n\n\tif (VAR_6 < 0) {\n\t\treturn VAR_6;\n\t}\n\n\tVAR_1->addr = VAR_2;\n\n\tswitch (VAR_7.type) {\n\tcase VAR_12:\n\t\tswitch (VAR_7.opcode) {\n\t\tcase VAR_13:\n\t\tcase VAR_14:\n\t\t\tVAR_1->type = VAR_15;\n\t\t\tbreak;\n\t\tcase VAR_16:\n\t\t\tVAR_1->type = VAR_17;\n\t\t\tbreak;\n\t\tcase VAR_18:\n\t\t\tVAR_1->type = VAR_19;\n\t\t\tVAR_1->fail = VAR_2 + VAR_1->size;\n\t\t\tVAR_1->jump = r_read_at_le16 (VAR_3, 2);\n\t\t\tbreak;\n\t\tcase VAR_20:\n\t\t\tVAR_1->type = VAR_21;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase VAR_22:\n\t\tswitch (VAR_7.opcode) {\n\t\tcase VAR_23:\n\t\tcase VAR_24:\n\t\tcase VAR_25:\n\t\tcase VAR_26:\n\t\t\tVAR_1->type = VAR_27;\n\t\t\tif ((VAR_7.instr)[0] == 'b' && (VAR_7.instr)[1] == 'r') {\n\t\t\t\t/* COMMENT_3 */\n\t\t\t\tVAR_1->type = VAR_28;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase VAR_29:\n\t\tcase VAR_30:\n\t\tcase VAR_31: VAR_1->type = VAR_32; break;\n\t\tcase VAR_33:\n\t\tcase VAR_34: VAR_1->type = VAR_35; break;\n\t\tcase VAR_36: VAR_1->type = VAR_37; break;\n\t\tcase VAR_38: VAR_1->type = VAR_39; break;\n\t\tcase VAR_40: VAR_1->type = VAR_41; break;\n\t\t}\n\t\tbreak;\n\tcase VAR_42:\n\t\tif (VAR_7.jmp_cond == VAR_43) {\n\t\t\tVAR_1->type = VAR_44;\n\t\t} else {\n\t\t\tVAR_1->type = VAR_45;\n\t\t}\n\t\tVAR_1->jump = VAR_2 + VAR_7.jmp_addr;\n\t\tVAR_1->fail = VAR_2 + 2;\n\t\tbreak;\n\tcase VAR_46:\n\t\tVAR_1->type = VAR_47;\n\t\tbreak;\n\tdefault:\n\t\tVAR_1->type = VAR_8;\n\t\tbreak;\n\t}\n\treturn VAR_6;\n}",
  "func_graph_path_before": "radareorg/radare2/3ecdbf8e21186a9c5a4d3cfa3b1e9fd27045340e/anal_msp430.c/vul/before/0.json",
  "func": "static int msp430_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *buf, int len, RAnalOpMask mask) {\n\tstruct msp430_cmd cmd = {0};\n\top->size = -1;\n\top->nopcode = 1;\n\top->type = R_ANAL_OP_TYPE_UNK;\n\top->family = R_ANAL_OP_FAMILY_CPU;\n\n\tint ret = op->size = msp430_decode_command (buf, len, &cmd);\n\tif (mask & R_ANAL_OP_MASK_DISASM) {\n\t\tif (ret < 1) {\n\t\t\top->mnemonic = strdup (\"invalid\");\n\t\t} else if (ret > 0) {\n\t\t\tif (cmd.operands[0]) {\n\t\t\t\top->mnemonic = r_str_newf (\"%s %s\",cmd.instr, cmd.operands);\n\t\t\t} else {\n\t\t\t\top->mnemonic = strdup (cmd.instr);\n\t\t\t}\n\t\t}\n\t\t{ // if (a->syntax != R_ASM_SYNTAX_ATT)\n\t\t\tchar *ba = op->mnemonic;\n\t\t\tr_str_replace_ch (ba, '#', 0, 1);\n\t\t\t// r_str_replace_ch (ba, \"$\", \"$$\", 1);\n\t\t\tr_str_replace_ch (ba, '&', 0, 1);\n\t\t\tr_str_replace_ch (ba, '%', 0, 1);\n\t\t}\n\t}\n\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\top->addr = addr;\n\n\tswitch (cmd.type) {\n\tcase MSP430_ONEOP:\n\t\tswitch (cmd.opcode) {\n\t\tcase MSP430_RRA:\n\t\tcase MSP430_RRC:\n\t\t\top->type = R_ANAL_OP_TYPE_ROR;\n\t\t\tbreak;\n\t\tcase MSP430_PUSH:\n\t\t\top->type = R_ANAL_OP_TYPE_PUSH;\n\t\t\tbreak;\n\t\tcase MSP430_CALL:\n\t\t\top->type = R_ANAL_OP_TYPE_CALL;\n\t\t\top->fail = addr + op->size;\n\t\t\tif (len > 4) {\n\t\t\t\top->jump = r_read_at_le16 (buf, 2);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MSP430_RETI:\n\t\t\top->type = R_ANAL_OP_TYPE_RET;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase MSP430_TWOOP:\n\t\tswitch (cmd.opcode) {\n\t\tcase MSP430_BIT:\n\t\tcase MSP430_BIC:\n\t\tcase MSP430_BIS:\n\t\tcase MSP430_MOV:\n\t\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\t\tif ((cmd.instr)[0] == 'b' && (cmd.instr)[1] == 'r') {\n\t\t\t\t// Emulated branch instruction, moves source operand to PC register.\n\t\t\t\top->type = R_ANAL_OP_TYPE_UJMP;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MSP430_DADD:\n\t\tcase MSP430_ADDC:\n\t\tcase MSP430_ADD: op->type = R_ANAL_OP_TYPE_ADD; break;\n\t\tcase MSP430_SUBC:\n\t\tcase MSP430_SUB: op->type = R_ANAL_OP_TYPE_SUB; break;\n\t\tcase MSP430_CMP: op->type = R_ANAL_OP_TYPE_CMP; break;\n\t\tcase MSP430_XOR: op->type = R_ANAL_OP_TYPE_XOR; break;\n\t\tcase MSP430_AND: op->type = R_ANAL_OP_TYPE_AND; break;\n\t\t}\n\t\tbreak;\n\tcase MSP430_JUMP:\n\t\tif (cmd.jmp_cond == MSP430_JMP) {\n\t\t\top->type = R_ANAL_OP_TYPE_JMP;\n\t\t} else {\n\t\t\top->type = R_ANAL_OP_TYPE_CJMP;\n\t\t}\n\t\top->jump = addr + cmd.jmp_addr;\n\t\top->fail = addr + 2;\n\t\tbreak;\n\tcase MSP430_INV:\n\t\top->type = R_ANAL_OP_TYPE_ILL;\n\t\tbreak;\n\tdefault:\n\t\top->type = R_ANAL_OP_TYPE_UNK;\n\t\tbreak;\n\t}\n\treturn ret;\n}",
  "abstract_func": "static int msp430_op(RAnal *VAR_0, RAnalOp *VAR_1, ut64 VAR_2, const ut8 *VAR_3, int VAR_4, RAnalOpMask VAR_5) {\n\tstruct msp430_cmd VAR_6 = {0};\n\tVAR_1->size = -1;\n\tVAR_1->nopcode = 1;\n\tVAR_1->type = VAR_7;\n\tVAR_1->family = VAR_8;\n\n\tint VAR_9 = VAR_1->size = msp430_decode_command (VAR_3, VAR_4, &VAR_6);\n\tif (VAR_5 & VAR_10) {\n\t\tif (VAR_9 < 1) {\n\t\t\tVAR_1->mnemonic = strdup (\"invalid\");\n\t\t} else if (VAR_9 > 0) {\n\t\t\tif (VAR_6.operands[0]) {\n\t\t\t\tVAR_1->mnemonic = r_str_newf (\"%s %s\",VAR_6.instr, VAR_6.operands);\n\t\t\t} else {\n\t\t\t\tVAR_1->mnemonic = strdup (VAR_6.instr);\n\t\t\t}\n\t\t}\n\t\t{ /* COMMENT_0 */\n\t\t\tchar *VAR_11 = VAR_1->mnemonic;\n\t\t\tr_str_replace_ch (VAR_11, '#', 0, 1);\n\t\t\t/* COMMENT_1 */\n\t\t\tr_str_replace_ch (VAR_11, '&', 0, 1);\n\t\t\tr_str_replace_ch (VAR_11, '%', 0, 1);\n\t\t}\n\t}\n\n\tif (VAR_9 < 0) {\n\t\treturn VAR_9;\n\t}\n\n\tVAR_1->addr = VAR_2;\n\n\tswitch (VAR_6.type) {\n\tcase VAR_12:\n\t\tswitch (VAR_6.opcode) {\n\t\tcase VAR_13:\n\t\tcase VAR_14:\n\t\t\tVAR_1->type = VAR_15;\n\t\t\tbreak;\n\t\tcase VAR_16:\n\t\t\tVAR_1->type = VAR_17;\n\t\t\tbreak;\n\t\tcase VAR_18:\n\t\t\tVAR_1->type = VAR_19;\n\t\t\tVAR_1->fail = VAR_2 + VAR_1->size;\n\t\t\tif (VAR_4 > 4) {\n\t\t\t\tVAR_1->jump = r_read_at_le16 (VAR_3, 2);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase VAR_20:\n\t\t\tVAR_1->type = VAR_21;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase VAR_22:\n\t\tswitch (VAR_6.opcode) {\n\t\tcase VAR_23:\n\t\tcase VAR_24:\n\t\tcase VAR_25:\n\t\tcase VAR_26:\n\t\t\tVAR_1->type = VAR_27;\n\t\t\tif ((VAR_6.instr)[0] == 'b' && (VAR_6.instr)[1] == 'r') {\n\t\t\t\t/* COMMENT_2 */\n\t\t\t\tVAR_1->type = VAR_28;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase VAR_29:\n\t\tcase VAR_30:\n\t\tcase VAR_31: VAR_1->type = VAR_32; break;\n\t\tcase VAR_33:\n\t\tcase VAR_34: VAR_1->type = VAR_35; break;\n\t\tcase VAR_36: VAR_1->type = VAR_37; break;\n\t\tcase VAR_38: VAR_1->type = VAR_39; break;\n\t\tcase VAR_40: VAR_1->type = VAR_41; break;\n\t\t}\n\t\tbreak;\n\tcase VAR_42:\n\t\tif (VAR_6.jmp_cond == VAR_43) {\n\t\t\tVAR_1->type = VAR_44;\n\t\t} else {\n\t\t\tVAR_1->type = VAR_45;\n\t\t}\n\t\tVAR_1->jump = VAR_2 + VAR_6.jmp_addr;\n\t\tVAR_1->fail = VAR_2 + 2;\n\t\tbreak;\n\tcase VAR_46:\n\t\tVAR_1->type = VAR_47;\n\t\tbreak;\n\tdefault:\n\t\tVAR_1->type = VAR_7;\n\t\tbreak;\n\t}\n\treturn VAR_9;\n}",
  "func_graph_path": "radareorg/radare2/3ecdbf8e21186a9c5a4d3cfa3b1e9fd27045340e/anal_msp430.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,15 +1,11 @@\n static int msp430_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *buf, int len, RAnalOpMask mask) {\n-\tint ret;\n-\tstruct msp430_cmd cmd;\n-\n-\tmemset (&cmd, 0, sizeof (cmd));\n-\t//op->id = ???;\n+\tstruct msp430_cmd cmd = {0};\n \top->size = -1;\n \top->nopcode = 1;\n \top->type = R_ANAL_OP_TYPE_UNK;\n \top->family = R_ANAL_OP_FAMILY_CPU;\n \n-\tret = op->size = msp430_decode_command (buf, len, &cmd);\n+\tint ret = op->size = msp430_decode_command (buf, len, &cmd);\n \tif (mask & R_ANAL_OP_MASK_DISASM) {\n \t\tif (ret < 1) {\n \t\t\top->mnemonic = strdup (\"invalid\");\n@@ -48,7 +44,9 @@\n \t\tcase MSP430_CALL:\n \t\t\top->type = R_ANAL_OP_TYPE_CALL;\n \t\t\top->fail = addr + op->size;\n-\t\t\top->jump = r_read_at_le16 (buf, 2);\n+\t\t\tif (len > 4) {\n+\t\t\t\top->jump = r_read_at_le16 (buf, 2);\n+\t\t\t}\n \t\t\tbreak;\n \t\tcase MSP430_RETI:\n \t\t\top->type = R_ANAL_OP_TYPE_RET;",
  "diff_line_info": {
    "deleted_lines": [
      "\tint ret;",
      "\tstruct msp430_cmd cmd;",
      "",
      "\tmemset (&cmd, 0, sizeof (cmd));",
      "\t//op->id = ???;",
      "\tret = op->size = msp430_decode_command (buf, len, &cmd);",
      "\t\t\top->jump = r_read_at_le16 (buf, 2);"
    ],
    "added_lines": [
      "\tstruct msp430_cmd cmd = {0};",
      "\tint ret = op->size = msp430_decode_command (buf, len, &cmd);",
      "\t\t\tif (len > 4) {",
      "\t\t\t\top->jump = r_read_at_le16 (buf, 2);",
      "\t\t\t}"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/radareorg/radare2/pull/20097",
  "description": {
    "pr_info": {
      "title": "Fix 4 byte oobread in msp430 disassembler ##crash",
      "number": 20097
    },
    "comment": [
      "* Only crashes with asan builds\r\n* Add missing =SN register\r\n* Reported by cnitlrt via huntrdev\r\n* BountyID: 1c22055b-b015-47a8-a57b-4982978751d0\r\n\r\n<!--\r\nRead https://github.com/radareorg/radare2/blob/master/DEVELOPERS.md\r\n* PR title must be capitalized, concise and use ##tags\r\n* If the PR is fixing a ticket use 'Fix #1234 - ..' in the commit message\r\n* Follow the coding style, add tests and documentation if necessary\r\n-->\r\n\r\n- [ ] Mark this if you consider it ready to merge\r\n- [ ] I've added tests (optional)\r\n- [ ] I wrote some lines in the [book](https://github.com/radareorg/radare2book) (optional)\r\n\r\n**Description**\r\n\r\n<!-- explain your changes if necessary -->\r\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix\n\nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses an out-of-bounds read vulnerability in the msp430 disassembler, which can cause crashes and potential exploitation. The code changes include adding bounds checks to prevent such issues.\n\nFinal Classification: Security Vulnerability Fix\n\nConfidence Score: 0.95"
}