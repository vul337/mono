{
  "cve_id": "CVE-2021-29338",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "uclouvain/openjpeg",
  "commit_msg": "Fix integer overflow in num_images\n\nIncludes the fix for CVE-2021-29338\nCredit to @kaniini based on #1346\nFixes #1338",
  "commit_hash": "f0727df07c4d944d7d1c5002451cfbc9545d3288",
  "git_url": "https://github.com/uclouvain/openjpeg/commit/f0727df07c4d944d7d1c5002451cfbc9545d3288",
  "file_path": "src/bin/jp2/opj_decompress.c",
  "func_name": "main",
  "func_before": "int main(int argc, char **argv)\n{\n    opj_decompress_parameters parameters;           /* decompression parameters */\n\n    OPJ_INT32 num_images, imageno;\n    img_fol_t img_fol;\n    dircnt_t *dirptr = NULL;\n    int failed = 0;\n    OPJ_FLOAT64 t, tCumulative = 0;\n    OPJ_UINT32 numDecompressedImages = 0;\n    OPJ_UINT32 cp_reduce;\n\n    /* set decoding parameters to default values */\n    set_default_parameters(&parameters);\n\n    /* Initialize img_fol */\n    memset(&img_fol, 0, sizeof(img_fol_t));\n\n    /* parse input and get user encoding parameters */\n    if (parse_cmdline_decoder(argc, argv, &parameters, &img_fol) == 1) {\n        failed = 1;\n        goto fin;\n    }\n\n    cp_reduce = parameters.core.cp_reduce;\n    if (getenv(\"USE_OPJ_SET_DECODED_RESOLUTION_FACTOR\") != NULL) {\n        /* For debugging/testing purposes, do not set the cp_reduce member */\n        /* if USE_OPJ_SET_DECODED_RESOLUTION_FACTOR is defined, but used */\n        /* the opj_set_decoded_resolution_factor() API instead */\n        parameters.core.cp_reduce = 0;\n    }\n\n\n    /* Initialize reading of directory */\n    if (img_fol.set_imgdir == 1) {\n        int it_image;\n        num_images = get_num_images(img_fol.imgdirpath);\n\n        dirptr = (dircnt_t*)calloc(1, sizeof(dircnt_t));\n        if (!dirptr) {\n            destroy_parameters(&parameters);\n            return EXIT_FAILURE;\n        }\n        /* Stores at max 10 image file names */\n        dirptr->filename_buf = (char*)malloc(sizeof(char) *\n                                             (size_t)num_images * OPJ_PATH_LEN);\n        if (!dirptr->filename_buf) {\n            failed = 1;\n            goto fin;\n        }\n\n        dirptr->filename = (char**) malloc((size_t)num_images * sizeof(char*));\n\n        if (!dirptr->filename) {\n            failed = 1;\n            goto fin;\n        }\n        for (it_image = 0; it_image < num_images; it_image++) {\n            dirptr->filename[it_image] = dirptr->filename_buf + it_image * OPJ_PATH_LEN;\n        }\n\n        if (load_images(dirptr, img_fol.imgdirpath) == 1) {\n            failed = 1;\n            goto fin;\n        }\n        if (num_images == 0) {\n            fprintf(stderr, \"Folder is empty\\n\");\n            failed = 1;\n            goto fin;\n        }\n    } else {\n        num_images = 1;\n    }\n\n    /*Decoding image one by one*/\n    for (imageno = 0; imageno < num_images ; imageno++)  {\n        opj_image_t* image = NULL;\n        opj_stream_t *l_stream = NULL;              /* Stream */\n        opj_codec_t* l_codec = NULL;                /* Handle to a decompressor */\n        opj_codestream_index_t* cstr_index = NULL;\n\n        if (!parameters.quiet) {\n            fprintf(stderr, \"\\n\");\n        }\n\n        if (img_fol.set_imgdir == 1) {\n            if (get_next_file(imageno, dirptr, &img_fol, &parameters)) {\n                fprintf(stderr, \"skipping file...\\n\");\n                destroy_parameters(&parameters);\n                continue;\n            }\n        }\n\n        /* read the input file and put it in memory */\n        /* ---------------------------------------- */\n\n        l_stream = opj_stream_create_default_file_stream(parameters.infile, 1);\n        if (!l_stream) {\n            fprintf(stderr, \"ERROR -> failed to create the stream from the file %s\\n\",\n                    parameters.infile);\n            failed = 1;\n            goto fin;\n        }\n\n        /* decode the JPEG2000 stream */\n        /* ---------------------- */\n\n        switch (parameters.decod_format) {\n        case J2K_CFMT: { /* JPEG-2000 codestream */\n            /* Get a decoder handle */\n            l_codec = opj_create_decompress(OPJ_CODEC_J2K);\n            break;\n        }\n        case JP2_CFMT: { /* JPEG 2000 compressed image data */\n            /* Get a decoder handle */\n            l_codec = opj_create_decompress(OPJ_CODEC_JP2);\n            break;\n        }\n        case JPT_CFMT: { /* JPEG 2000, JPIP */\n            /* Get a decoder handle */\n            l_codec = opj_create_decompress(OPJ_CODEC_JPT);\n            break;\n        }\n        default:\n            fprintf(stderr, \"skipping file..\\n\");\n            destroy_parameters(&parameters);\n            opj_stream_destroy(l_stream);\n            continue;\n        }\n\n        if (parameters.quiet) {\n            /* Set all callbacks to quiet */\n            opj_set_info_handler(l_codec, quiet_callback, 00);\n            opj_set_warning_handler(l_codec, quiet_callback, 00);\n            opj_set_error_handler(l_codec, quiet_callback, 00);\n        } else {\n            /* catch events using our callbacks and give a local context */\n            opj_set_info_handler(l_codec, info_callback, 00);\n            opj_set_warning_handler(l_codec, warning_callback, 00);\n            opj_set_error_handler(l_codec, error_callback, 00);\n        }\n\n\n        t = opj_clock();\n\n        /* Setup the decoder decoding parameters using user parameters */\n        if (!opj_setup_decoder(l_codec, &(parameters.core))) {\n            fprintf(stderr, \"ERROR -> opj_decompress: failed to setup the decoder\\n\");\n            opj_stream_destroy(l_stream);\n            opj_destroy_codec(l_codec);\n            failed = 1;\n            goto fin;\n        }\n\n        if (parameters.num_threads >= 1 &&\n                !opj_codec_set_threads(l_codec, parameters.num_threads)) {\n            fprintf(stderr, \"ERROR -> opj_decompress: failed to set number of threads\\n\");\n            opj_stream_destroy(l_stream);\n            opj_destroy_codec(l_codec);\n            failed = 1;\n            goto fin;\n        }\n\n        /* Read the main header of the codestream and if necessary the JP2 boxes*/\n        if (! opj_read_header(l_stream, l_codec, &image)) {\n            fprintf(stderr, \"ERROR -> opj_decompress: failed to read the header\\n\");\n            opj_stream_destroy(l_stream);\n            opj_destroy_codec(l_codec);\n            opj_image_destroy(image);\n            failed = 1;\n            goto fin;\n        }\n\n        if (parameters.numcomps) {\n            if (! opj_set_decoded_components(l_codec,\n                                             parameters.numcomps,\n                                             parameters.comps_indices,\n                                             OPJ_FALSE)) {\n                fprintf(stderr,\n                        \"ERROR -> opj_decompress: failed to set the component indices!\\n\");\n                opj_destroy_codec(l_codec);\n                opj_stream_destroy(l_stream);\n                opj_image_destroy(image);\n                failed = 1;\n                goto fin;\n            }\n        }\n\n        if (getenv(\"USE_OPJ_SET_DECODED_RESOLUTION_FACTOR\") != NULL) {\n            /* For debugging/testing purposes, and also an illustration on how to */\n            /* use the alternative API opj_set_decoded_resolution_factor() instead */\n            /* of setting parameters.cp_reduce */\n            if (! opj_set_decoded_resolution_factor(l_codec, cp_reduce)) {\n                fprintf(stderr,\n                        \"ERROR -> opj_decompress: failed to set the resolution factor tile!\\n\");\n                opj_destroy_codec(l_codec);\n                opj_stream_destroy(l_stream);\n                opj_image_destroy(image);\n                failed = 1;\n                goto fin;\n            }\n        }\n\n        if (!parameters.nb_tile_to_decode) {\n            if (getenv(\"SKIP_OPJ_SET_DECODE_AREA\") != NULL &&\n                    parameters.DA_x0 == 0 &&\n                    parameters.DA_y0 == 0 &&\n                    parameters.DA_x1 == 0 &&\n                    parameters.DA_y1 == 0) {\n                /* For debugging/testing purposes, */\n                /* do nothing if SKIP_OPJ_SET_DECODE_AREA env variable */\n                /* is defined and no decoded area has been set */\n            }\n            /* Optional if you want decode the entire image */\n            else if (!opj_set_decode_area(l_codec, image, (OPJ_INT32)parameters.DA_x0,\n                                          (OPJ_INT32)parameters.DA_y0, (OPJ_INT32)parameters.DA_x1,\n                                          (OPJ_INT32)parameters.DA_y1)) {\n                fprintf(stderr, \"ERROR -> opj_decompress: failed to set the decoded area\\n\");\n                opj_stream_destroy(l_stream);\n                opj_destroy_codec(l_codec);\n                opj_image_destroy(image);\n                failed = 1;\n                goto fin;\n            }\n\n            /* Get the decoded image */\n            if (!(opj_decode(l_codec, l_stream, image) &&\n                    opj_end_decompress(l_codec,   l_stream))) {\n                fprintf(stderr, \"ERROR -> opj_decompress: failed to decode image!\\n\");\n                opj_destroy_codec(l_codec);\n                opj_stream_destroy(l_stream);\n                opj_image_destroy(image);\n                failed = 1;\n                goto fin;\n            }\n        } else {\n            if (!(parameters.DA_x0 == 0 &&\n                    parameters.DA_y0 == 0 &&\n                    parameters.DA_x1 == 0 &&\n                    parameters.DA_y1 == 0)) {\n                if (!(parameters.quiet)) {\n                    fprintf(stderr, \"WARNING: -d option ignored when used together with -t\\n\");\n                }\n            }\n\n            if (!opj_get_decoded_tile(l_codec, l_stream, image, parameters.tile_index)) {\n                fprintf(stderr, \"ERROR -> opj_decompress: failed to decode tile!\\n\");\n                opj_destroy_codec(l_codec);\n                opj_stream_destroy(l_stream);\n                opj_image_destroy(image);\n                failed = 1;\n                goto fin;\n            }\n            if (!(parameters.quiet)) {\n                fprintf(stdout, \"tile %d is decoded!\\n\\n\", parameters.tile_index);\n            }\n        }\n\n        tCumulative += opj_clock() - t;\n        numDecompressedImages++;\n\n        /* Close the byte stream */\n        opj_stream_destroy(l_stream);\n\n        if (image->color_space != OPJ_CLRSPC_SYCC\n                && image->numcomps == 3 && image->comps[0].dx == image->comps[0].dy\n                && image->comps[1].dx != 1) {\n            image->color_space = OPJ_CLRSPC_SYCC;\n        } else if (image->numcomps <= 2) {\n            image->color_space = OPJ_CLRSPC_GRAY;\n        }\n\n        if (image->color_space == OPJ_CLRSPC_SYCC) {\n            color_sycc_to_rgb(image);\n        } else if ((image->color_space == OPJ_CLRSPC_CMYK) &&\n                   (parameters.cod_format != TIF_DFMT)) {\n            color_cmyk_to_rgb(image);\n        } else if (image->color_space == OPJ_CLRSPC_EYCC) {\n            color_esycc_to_rgb(image);\n        }\n\n        if (image->icc_profile_buf) {\n#if defined(OPJ_HAVE_LIBLCMS1) || defined(OPJ_HAVE_LIBLCMS2)\n            if (image->icc_profile_len) {\n                color_apply_icc_profile(image);\n            } else {\n                color_cielab_to_rgb(image);\n            }\n#endif\n            free(image->icc_profile_buf);\n            image->icc_profile_buf = NULL;\n            image->icc_profile_len = 0;\n        }\n\n        /* Force output precision */\n        /* ---------------------- */\n        if (parameters.precision != NULL) {\n            OPJ_UINT32 compno;\n            for (compno = 0; compno < image->numcomps; ++compno) {\n                OPJ_UINT32 precno = compno;\n                OPJ_UINT32 prec;\n\n                if (precno >= parameters.nb_precision) {\n                    precno = parameters.nb_precision - 1U;\n                }\n\n                prec = parameters.precision[precno].prec;\n                if (prec == 0) {\n                    prec = image->comps[compno].prec;\n                }\n\n                switch (parameters.precision[precno].mode) {\n                case OPJ_PREC_MODE_CLIP:\n                    clip_component(&(image->comps[compno]), prec);\n                    break;\n                case OPJ_PREC_MODE_SCALE:\n                    scale_component(&(image->comps[compno]), prec);\n                    break;\n                default:\n                    break;\n                }\n\n            }\n        }\n\n        /* Upsample components */\n        /* ------------------- */\n        if (parameters.upsample) {\n            image = upsample_image_components(image);\n            if (image == NULL) {\n                fprintf(stderr,\n                        \"ERROR -> opj_decompress: failed to upsample image components!\\n\");\n                opj_destroy_codec(l_codec);\n                failed = 1;\n                goto fin;\n            }\n        }\n\n        /* Force RGB output */\n        /* ---------------- */\n        if (parameters.force_rgb) {\n            switch (image->color_space) {\n            case OPJ_CLRSPC_SRGB:\n                break;\n            case OPJ_CLRSPC_GRAY:\n                image = convert_gray_to_rgb(image);\n                break;\n            default:\n                fprintf(stderr,\n                        \"ERROR -> opj_decompress: don't know how to convert image to RGB colorspace!\\n\");\n                opj_image_destroy(image);\n                image = NULL;\n                break;\n            }\n            if (image == NULL) {\n                fprintf(stderr, \"ERROR -> opj_decompress: failed to convert to RGB image!\\n\");\n                opj_destroy_codec(l_codec);\n                failed = 1;\n                goto fin;\n            }\n        }\n\n        /* create output image */\n        /* ------------------- */\n        switch (parameters.cod_format) {\n        case PXM_DFMT:          /* PNM PGM PPM */\n            if (imagetopnm(image, parameters.outfile, parameters.split_pnm)) {\n                fprintf(stderr, \"[ERROR] Outfile %s not generated\\n\", parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n\n        case PGX_DFMT:          /* PGX */\n            if (imagetopgx(image, parameters.outfile)) {\n                fprintf(stderr, \"[ERROR] Outfile %s not generated\\n\", parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n\n        case BMP_DFMT:          /* BMP */\n            if (imagetobmp(image, parameters.outfile)) {\n                fprintf(stderr, \"[ERROR] Outfile %s not generated\\n\", parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n#ifdef OPJ_HAVE_LIBTIFF\n        case TIF_DFMT:          /* TIF(F) */\n            if (imagetotif(image, parameters.outfile)) {\n                fprintf(stderr, \"[ERROR] Outfile %s not generated\\n\", parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n#endif /* OPJ_HAVE_LIBTIFF */\n        case RAW_DFMT:          /* RAW */\n            if (imagetoraw(image, parameters.outfile)) {\n                fprintf(stderr,\n                        \"[ERROR] Error generating raw or yuv file. Outfile %s not generated\\n\",\n                        parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n\n        case RAWL_DFMT:         /* RAWL */\n            if (imagetorawl(image, parameters.outfile)) {\n                fprintf(stderr,\n                        \"[ERROR] Error generating rawl file. Outfile %s not generated\\n\",\n                        parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n\n        case TGA_DFMT:          /* TGA */\n            if (imagetotga(image, parameters.outfile)) {\n                fprintf(stderr, \"[ERROR] Error generating tga file. Outfile %s not generated\\n\",\n                        parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n#ifdef OPJ_HAVE_LIBPNG\n        case PNG_DFMT:          /* PNG */\n            if (imagetopng(image, parameters.outfile)) {\n                fprintf(stderr, \"[ERROR] Error generating png file. Outfile %s not generated\\n\",\n                        parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n#endif /* OPJ_HAVE_LIBPNG */\n        /* Can happen if output file is TIF(F) or PNG\n         * and OPJ_HAVE_LIBTIF or OPJ_HAVE_LIBPNG is undefined\n        */\n        default:\n            fprintf(stderr, \"[ERROR] Outfile %s not generated\\n\", parameters.outfile);\n            failed = 1;\n        }\n\n        /* free remaining structures */\n        if (l_codec) {\n            opj_destroy_codec(l_codec);\n        }\n\n\n        /* free image data structure */\n        opj_image_destroy(image);\n\n        /* destroy the codestream index */\n        opj_destroy_cstr_index(&cstr_index);\n\n        if (failed) {\n            (void)remove(parameters.outfile);    /* ignore return value */\n        }\n    }\nfin:\n    destroy_parameters(&parameters);\n    if (failed && img_fol.imgdirpath) {\n        free(img_fol.imgdirpath);\n    }\n    if (dirptr) {\n        if (dirptr->filename) {\n            free(dirptr->filename);\n        }\n        if (dirptr->filename_buf) {\n            free(dirptr->filename_buf);\n        }\n        free(dirptr);\n    }\n    if (numDecompressedImages && !failed && !(parameters.quiet)) {\n        fprintf(stdout, \"decode time: %d ms\\n\",\n                (int)((tCumulative * 1000.0) / (OPJ_FLOAT64)numDecompressedImages));\n    }\n    return failed ? EXIT_FAILURE : EXIT_SUCCESS;\n}",
  "abstract_func_before": "int main(int VAR_0, char **VAR_1)\n{\n    opj_decompress_parameters VAR_2;           /* COMMENT_0 */\n\n    OPJ_INT32 VAR_3, VAR_4;\n    img_fol_t VAR_5;\n    dircnt_t *VAR_6 = NULL;\n    int VAR_7 = 0;\n    OPJ_FLOAT64 VAR_8, VAR_9 = 0;\n    OPJ_UINT32 VAR_10 = 0;\n    OPJ_UINT32 VAR_11;\n\n    /* COMMENT_1 */\n    set_default_parameters(&VAR_2);\n\n    /* COMMENT_2 */\n    memset(&VAR_5, 0, sizeof(img_fol_t));\n\n    /* COMMENT_3 */\n    if (parse_cmdline_decoder(VAR_0, VAR_1, &VAR_2, &VAR_5) == 1) {\n        VAR_7 = 1;\n        goto fin;\n    }\n\n    VAR_11 = VAR_2.core.cp_reduce;\n    if (getenv(\"USE_OPJ_SET_DECODED_RESOLUTION_FACTOR\") != NULL) {\n        /* COMMENT_4 */\n        /* COMMENT_5 */\n        /* COMMENT_6 */\n        VAR_2.core.cp_reduce = 0;\n    }\n\n\n    /* COMMENT_7 */\n    if (VAR_5.set_imgdir == 1) {\n        int VAR_12;\n        VAR_3 = get_num_images(VAR_5.imgdirpath);\n\n        VAR_6 = (dircnt_t*)calloc(1, sizeof(dircnt_t));\n        if (!VAR_6) {\n            destroy_parameters(&VAR_2);\n            return VAR_13;\n        }\n        /* COMMENT_8 */\n        VAR_6->filename_buf = (char*)malloc(sizeof(char) *\n                                             (size_t)VAR_3 * VAR_14);\n        if (!VAR_6->filename_buf) {\n            VAR_7 = 1;\n            goto fin;\n        }\n\n        VAR_6->filename = (char**) malloc((size_t)VAR_3 * sizeof(char*));\n\n        if (!VAR_6->filename) {\n            VAR_7 = 1;\n            goto fin;\n        }\n        for (VAR_12 = 0; VAR_12 < VAR_3; VAR_12++) {\n            VAR_6->filename[VAR_12] = VAR_6->filename_buf + VAR_12 * VAR_14;\n        }\n\n        if (load_images(VAR_6, VAR_5.imgdirpath) == 1) {\n            VAR_7 = 1;\n            goto fin;\n        }\n        if (VAR_3 == 0) {\n            fprintf(VAR_15, \"Folder is empty\\n\");\n            VAR_7 = 1;\n            goto fin;\n        }\n    } else {\n        VAR_3 = 1;\n    }\n\n    /* COMMENT_9 */\n    for (VAR_4 = 0; VAR_4 < VAR_3 ; VAR_4++)  {\n        opj_image_t* VAR_16 = NULL;\n        opj_stream_t *VAR_17 = NULL;              /* COMMENT_10 */\n        opj_codec_t* VAR_18 = NULL;                /* COMMENT_11 */\n        opj_codestream_index_t* VAR_19 = NULL;\n\n        if (!VAR_2.quiet) {\n            fprintf(VAR_15, \"\\n\");\n        }\n\n        if (VAR_5.set_imgdir == 1) {\n            if (get_next_file(VAR_4, VAR_6, &VAR_5, &VAR_2)) {\n                fprintf(VAR_15, \"skipping file...\\n\");\n                destroy_parameters(&VAR_2);\n                continue;\n            }\n        }\n\n        /* COMMENT_12 */\n        /* COMMENT_13 */\n\n        VAR_17 = opj_stream_create_default_file_stream(VAR_2.infile, 1);\n        if (!VAR_17) {\n            fprintf(VAR_15, \"ERROR -> failed to create the stream from the file %s\\n\",\n                    VAR_2.infile);\n            VAR_7 = 1;\n            goto fin;\n        }\n\n        /* COMMENT_14 */\n        /* COMMENT_15 */\n\n        switch (VAR_2.decod_format) {\n        case VAR_20: { /* COMMENT_16 */\n            /* COMMENT_17 */\n            VAR_18 = opj_create_decompress(VAR_21);\n            break;\n        }\n        case VAR_22: { /* COMMENT_18 */\n            /* COMMENT_17 */\n            VAR_18 = opj_create_decompress(VAR_23);\n            break;\n        }\n        case VAR_24: { /* COMMENT_19 */\n            /* COMMENT_17 */\n            VAR_18 = opj_create_decompress(VAR_25);\n            break;\n        }\n        default:\n            fprintf(VAR_15, \"skipping file..\\n\");\n            destroy_parameters(&VAR_2);\n            opj_stream_destroy(VAR_17);\n            continue;\n        }\n\n        if (VAR_2.quiet) {\n            /* COMMENT_20 */\n            opj_set_info_handler(VAR_18, VAR_26, 00);\n            opj_set_warning_handler(VAR_18, VAR_26, 00);\n            opj_set_error_handler(VAR_18, VAR_26, 00);\n        } else {\n            /* COMMENT_21 */\n            opj_set_info_handler(VAR_18, VAR_27, 00);\n            opj_set_warning_handler(VAR_18, VAR_28, 00);\n            opj_set_error_handler(VAR_18, VAR_29, 00);\n        }\n\n\n        VAR_8 = opj_clock();\n\n        /* COMMENT_22 */\n        if (!opj_setup_decoder(VAR_18, &(VAR_2.core))) {\n            fprintf(VAR_15, \"ERROR -> opj_decompress: failed to setup the decoder\\n\");\n            opj_stream_destroy(VAR_17);\n            opj_destroy_codec(VAR_18);\n            VAR_7 = 1;\n            goto fin;\n        }\n\n        if (VAR_2.num_threads >= 1 &&\n                !opj_codec_set_threads(VAR_18, VAR_2.num_threads)) {\n            fprintf(VAR_15, \"ERROR -> opj_decompress: failed to set number of threads\\n\");\n            opj_stream_destroy(VAR_17);\n            opj_destroy_codec(VAR_18);\n            VAR_7 = 1;\n            goto fin;\n        }\n\n        /* COMMENT_23 */\n        if (! opj_read_header(VAR_17, VAR_18, &VAR_16)) {\n            fprintf(VAR_15, \"ERROR -> opj_decompress: failed to read the header\\n\");\n            opj_stream_destroy(VAR_17);\n            opj_destroy_codec(VAR_18);\n            opj_image_destroy(VAR_16);\n            VAR_7 = 1;\n            goto fin;\n        }\n\n        if (VAR_2.numcomps) {\n            if (! opj_set_decoded_components(VAR_18,\n                                             VAR_2.numcomps,\n                                             VAR_2.comps_indices,\n                                             VAR_30)) {\n                fprintf(VAR_15,\n                        \"ERROR -> opj_decompress: failed to set the component indices!\\n\");\n                opj_destroy_codec(VAR_18);\n                opj_stream_destroy(VAR_17);\n                opj_image_destroy(VAR_16);\n                VAR_7 = 1;\n                goto fin;\n            }\n        }\n\n        if (getenv(\"USE_OPJ_SET_DECODED_RESOLUTION_FACTOR\") != NULL) {\n            /* COMMENT_24 */\n            /* COMMENT_25 */\n            /* COMMENT_26 */\n            if (! opj_set_decoded_resolution_factor(VAR_18, VAR_11)) {\n                fprintf(VAR_15,\n                        \"ERROR -> opj_decompress: failed to set the resolution factor tile!\\n\");\n                opj_destroy_codec(VAR_18);\n                opj_stream_destroy(VAR_17);\n                opj_image_destroy(VAR_16);\n                VAR_7 = 1;\n                goto fin;\n            }\n        }\n\n        if (!VAR_2.nb_tile_to_decode) {\n            if (getenv(\"SKIP_OPJ_SET_DECODE_AREA\") != NULL &&\n                    VAR_2.DA_x0 == 0 &&\n                    VAR_2.DA_y0 == 0 &&\n                    VAR_2.DA_x1 == 0 &&\n                    VAR_2.DA_y1 == 0) {\n                /* COMMENT_27 */\n                /* COMMENT_28 */\n                /* COMMENT_29 */\n            }\n            /* COMMENT_30 */\n            else if (!opj_set_decode_area(VAR_18, VAR_16, (OPJ_INT32)VAR_2.DA_x0,\n                                          (OPJ_INT32)VAR_2.DA_y0, (OPJ_INT32)VAR_2.DA_x1,\n                                          (OPJ_INT32)VAR_2.DA_y1)) {\n                fprintf(VAR_15, \"ERROR -> opj_decompress: failed to set the decoded area\\n\");\n                opj_stream_destroy(VAR_17);\n                opj_destroy_codec(VAR_18);\n                opj_image_destroy(VAR_16);\n                VAR_7 = 1;\n                goto fin;\n            }\n\n            /* COMMENT_31 */\n            if (!(opj_decode(VAR_18, VAR_17, VAR_16) &&\n                    opj_end_decompress(VAR_18,   VAR_17))) {\n                fprintf(VAR_15, \"ERROR -> opj_decompress: failed to decode image!\\n\");\n                opj_destroy_codec(VAR_18);\n                opj_stream_destroy(VAR_17);\n                opj_image_destroy(VAR_16);\n                VAR_7 = 1;\n                goto fin;\n            }\n        } else {\n            if (!(VAR_2.DA_x0 == 0 &&\n                    VAR_2.DA_y0 == 0 &&\n                    VAR_2.DA_x1 == 0 &&\n                    VAR_2.DA_y1 == 0)) {\n                if (!(VAR_2.quiet)) {\n                    fprintf(VAR_15, \"WARNING: -d option ignored when used together with -t\\n\");\n                }\n            }\n\n            if (!opj_get_decoded_tile(VAR_18, VAR_17, VAR_16, VAR_2.tile_index)) {\n                fprintf(VAR_15, \"ERROR -> opj_decompress: failed to decode tile!\\n\");\n                opj_destroy_codec(VAR_18);\n                opj_stream_destroy(VAR_17);\n                opj_image_destroy(VAR_16);\n                VAR_7 = 1;\n                goto fin;\n            }\n            if (!(VAR_2.quiet)) {\n                fprintf(VAR_31, \"tile %d is decoded!\\n\\n\", VAR_2.tile_index);\n            }\n        }\n\n        VAR_9 += opj_clock() - VAR_8;\n        VAR_10++;\n\n        /* COMMENT_32 */\n        opj_stream_destroy(VAR_17);\n\n        if (VAR_16->color_space != VAR_32\n                && VAR_16->numcomps == 3 && VAR_16->comps[0].dx == VAR_16->comps[0].dy\n                && VAR_16->comps[1].dx != 1) {\n            VAR_16->color_space = VAR_32;\n        } else if (VAR_16->numcomps <= 2) {\n            VAR_16->color_space = VAR_33;\n        }\n\n        if (VAR_16->color_space == VAR_32) {\n            color_sycc_to_rgb(VAR_16);\n        } else if ((VAR_16->color_space == VAR_34) &&\n                   (VAR_2.cod_format != VAR_35)) {\n            color_cmyk_to_rgb(VAR_16);\n        } else if (VAR_16->color_space == VAR_36) {\n            color_esycc_to_rgb(VAR_16);\n        }\n\n        if (VAR_16->icc_profile_buf) {\n#if defined(VAR_37) || defined(VAR_38)\n            if (VAR_16->icc_profile_len) {\n                color_apply_icc_profile(VAR_16);\n            } else {\n                color_cielab_to_rgb(VAR_16);\n            }\n#endif\n            free(VAR_16->icc_profile_buf);\n            VAR_16->icc_profile_buf = NULL;\n            VAR_16->icc_profile_len = 0;\n        }\n\n        /* COMMENT_33 */\n        /* COMMENT_15 */\n        if (VAR_2.precision != NULL) {\n            OPJ_UINT32 VAR_39;\n            for (VAR_39 = 0; VAR_39 < VAR_16->numcomps; ++VAR_39) {\n                OPJ_UINT32 VAR_40 = VAR_39;\n                OPJ_UINT32 VAR_41;\n\n                if (VAR_40 >= VAR_2.nb_precision) {\n                    VAR_40 = VAR_2.nb_precision - 1U;\n                }\n\n                VAR_41 = VAR_2.precision[VAR_40].prec;\n                if (VAR_41 == 0) {\n                    VAR_41 = VAR_16->comps[VAR_39].prec;\n                }\n\n                switch (VAR_2.precision[VAR_40].mode) {\n                case VAR_42:\n                    clip_component(&(VAR_16->comps[VAR_39]), VAR_41);\n                    break;\n                case VAR_43:\n                    scale_component(&(VAR_16->comps[VAR_39]), VAR_41);\n                    break;\n                default:\n                    break;\n                }\n\n            }\n        }\n\n        /* COMMENT_34 */\n        /* COMMENT_35 */\n        if (VAR_2.upsample) {\n            VAR_16 = upsample_image_components(VAR_16);\n            if (VAR_16 == NULL) {\n                fprintf(VAR_15,\n                        \"ERROR -> opj_decompress: failed to upsample image components!\\n\");\n                opj_destroy_codec(VAR_18);\n                VAR_7 = 1;\n                goto fin;\n            }\n        }\n\n        /* COMMENT_36 */\n        /* COMMENT_37 */\n        if (VAR_2.force_rgb) {\n            switch (VAR_16->color_space) {\n            case VAR_44:\n                break;\n            case VAR_33:\n                VAR_16 = convert_gray_to_rgb(VAR_16);\n                break;\n            default:\n                fprintf(VAR_15,\n                        \"ERROR -> opj_decompress: don't know how to convert image to RGB colorspace!\\n\");\n                opj_image_destroy(VAR_16);\n                VAR_16 = NULL;\n                break;\n            }\n            if (VAR_16 == NULL) {\n                fprintf(VAR_15, \"ERROR -> opj_decompress: failed to convert to RGB image!\\n\");\n                opj_destroy_codec(VAR_18);\n                VAR_7 = 1;\n                goto fin;\n            }\n        }\n\n        /* COMMENT_38 */\n        /* COMMENT_35 */\n        switch (VAR_2.cod_format) {\n        case VAR_45:          /* COMMENT_39 */\n            if (imagetopnm(VAR_16, VAR_2.outfile, VAR_2.split_pnm)) {\n                fprintf(VAR_15, \"[ERROR] Outfile %s not generated\\n\", VAR_2.outfile);\n                VAR_7 = 1;\n            } else if (!(VAR_2.quiet)) {\n                fprintf(VAR_31, \"[INFO] Generated Outfile %s\\n\", VAR_2.outfile);\n            }\n            break;\n\n        case VAR_46:          /* COMMENT_40 */\n            if (imagetopgx(VAR_16, VAR_2.outfile)) {\n                fprintf(VAR_15, \"[ERROR] Outfile %s not generated\\n\", VAR_2.outfile);\n                VAR_7 = 1;\n            } else if (!(VAR_2.quiet)) {\n                fprintf(VAR_31, \"[INFO] Generated Outfile %s\\n\", VAR_2.outfile);\n            }\n            break;\n\n        case VAR_47:          /* COMMENT_41 */\n            if (imagetobmp(VAR_16, VAR_2.outfile)) {\n                fprintf(VAR_15, \"[ERROR] Outfile %s not generated\\n\", VAR_2.outfile);\n                VAR_7 = 1;\n            } else if (!(VAR_2.quiet)) {\n                fprintf(VAR_31, \"[INFO] Generated Outfile %s\\n\", VAR_2.outfile);\n            }\n            break;\n#ifdef VAR_48\n        case VAR_35:          /* COMMENT_42 */\n            if (imagetotif(VAR_16, VAR_2.outfile)) {\n                fprintf(VAR_15, \"[ERROR] Outfile %s not generated\\n\", VAR_2.outfile);\n                VAR_7 = 1;\n            } else if (!(VAR_2.quiet)) {\n                fprintf(VAR_31, \"[INFO] Generated Outfile %s\\n\", VAR_2.outfile);\n            }\n            break;\n#endif /* COMMENT_43 */\n        case VAR_49:          /* COMMENT_44 */\n            if (imagetoraw(VAR_16, VAR_2.outfile)) {\n                fprintf(VAR_15,\n                        \"[ERROR] Error generating raw or yuv file. Outfile %s not generated\\n\",\n                        VAR_2.outfile);\n                VAR_7 = 1;\n            } else if (!(VAR_2.quiet)) {\n                fprintf(VAR_31, \"[INFO] Generated Outfile %s\\n\", VAR_2.outfile);\n            }\n            break;\n\n        case VAR_50:         /* COMMENT_45 */\n            if (imagetorawl(VAR_16, VAR_2.outfile)) {\n                fprintf(VAR_15,\n                        \"[ERROR] Error generating rawl file. Outfile %s not generated\\n\",\n                        VAR_2.outfile);\n                VAR_7 = 1;\n            } else if (!(VAR_2.quiet)) {\n                fprintf(VAR_31, \"[INFO] Generated Outfile %s\\n\", VAR_2.outfile);\n            }\n            break;\n\n        case VAR_51:          /* COMMENT_46 */\n            if (imagetotga(VAR_16, VAR_2.outfile)) {\n                fprintf(VAR_15, \"[ERROR] Error generating tga file. Outfile %s not generated\\n\",\n                        VAR_2.outfile);\n                VAR_7 = 1;\n            } else if (!(VAR_2.quiet)) {\n                fprintf(VAR_31, \"[INFO] Generated Outfile %s\\n\", VAR_2.outfile);\n            }\n            break;\n#ifdef VAR_52\n        case VAR_53:          /* COMMENT_47 */\n            if (imagetopng(VAR_16, VAR_2.outfile)) {\n                fprintf(VAR_15, \"[ERROR] Error generating png file. Outfile %s not generated\\n\",\n                        VAR_2.outfile);\n                VAR_7 = 1;\n            } else if (!(VAR_2.quiet)) {\n                fprintf(VAR_31, \"[INFO] Generated Outfile %s\\n\", VAR_2.outfile);\n            }\n            break;\n#endif /* COMMENT_48 */\n        /* COMMENT_49 */\n                                                              \n          \n        default:\n            fprintf(VAR_15, \"[ERROR] Outfile %s not generated\\n\", VAR_2.outfile);\n            VAR_7 = 1;\n        }\n\n        /* COMMENT_52 */\n        if (VAR_18) {\n            opj_destroy_codec(VAR_18);\n        }\n\n\n        /* COMMENT_53 */\n        opj_image_destroy(VAR_16);\n\n        /* COMMENT_54 */\n        opj_destroy_cstr_index(&VAR_19);\n\n        if (VAR_7) {\n            (void)remove(VAR_2.outfile);    /* COMMENT_55 */\n        }\n    }\nfin:\n    destroy_parameters(&VAR_2);\n    if (VAR_7 && VAR_5.imgdirpath) {\n        free(VAR_5.imgdirpath);\n    }\n    if (VAR_6) {\n        if (VAR_6->filename) {\n            free(VAR_6->filename);\n        }\n        if (VAR_6->filename_buf) {\n            free(VAR_6->filename_buf);\n        }\n        free(VAR_6);\n    }\n    if (VAR_10 && !VAR_7 && !(VAR_2.quiet)) {\n        fprintf(VAR_31, \"decode time: %d ms\\n\",\n                (int)((VAR_9 * 1000.0) / (OPJ_FLOAT64)VAR_10));\n    }\n    return VAR_7 ? VAR_13 : VAR_54;\n}",
  "func_graph_path_before": "uclouvain/openjpeg/f0727df07c4d944d7d1c5002451cfbc9545d3288/opj_decompress.c/vul/before/0.json",
  "func": "int main(int argc, char **argv)\n{\n    opj_decompress_parameters parameters;           /* decompression parameters */\n\n    OPJ_INT32 num_images, imageno;\n    img_fol_t img_fol;\n    dircnt_t *dirptr = NULL;\n    int failed = 0;\n    OPJ_FLOAT64 t, tCumulative = 0;\n    OPJ_UINT32 numDecompressedImages = 0;\n    OPJ_UINT32 cp_reduce;\n\n    /* set decoding parameters to default values */\n    set_default_parameters(&parameters);\n\n    /* Initialize img_fol */\n    memset(&img_fol, 0, sizeof(img_fol_t));\n\n    /* parse input and get user encoding parameters */\n    if (parse_cmdline_decoder(argc, argv, &parameters, &img_fol) == 1) {\n        failed = 1;\n        goto fin;\n    }\n\n    cp_reduce = parameters.core.cp_reduce;\n    if (getenv(\"USE_OPJ_SET_DECODED_RESOLUTION_FACTOR\") != NULL) {\n        /* For debugging/testing purposes, do not set the cp_reduce member */\n        /* if USE_OPJ_SET_DECODED_RESOLUTION_FACTOR is defined, but used */\n        /* the opj_set_decoded_resolution_factor() API instead */\n        parameters.core.cp_reduce = 0;\n    }\n\n\n    /* Initialize reading of directory */\n    if (img_fol.set_imgdir == 1) {\n        int it_image;\n        num_images = get_num_images(img_fol.imgdirpath);\n\n        dirptr = (dircnt_t*)calloc(1, sizeof(dircnt_t));\n        if (!dirptr) {\n            destroy_parameters(&parameters);\n            return EXIT_FAILURE;\n        }\n        /* Stores at max 10 image file names */\n        dirptr->filename_buf = calloc((size_t) num_images, sizeof(char) * OPJ_PATH_LEN);\n        if (!dirptr->filename_buf) {\n            failed = 1;\n            goto fin;\n        }\n\n        dirptr->filename = (char**) calloc((size_t) num_images, sizeof(char*));\n\n        if (!dirptr->filename) {\n            failed = 1;\n            goto fin;\n        }\n        for (it_image = 0; it_image < num_images; it_image++) {\n            dirptr->filename[it_image] = dirptr->filename_buf + it_image * OPJ_PATH_LEN;\n        }\n\n        if (load_images(dirptr, img_fol.imgdirpath) == 1) {\n            failed = 1;\n            goto fin;\n        }\n        if (num_images == 0) {\n            fprintf(stderr, \"Folder is empty\\n\");\n            failed = 1;\n            goto fin;\n        }\n    } else {\n        num_images = 1;\n    }\n\n    /*Decoding image one by one*/\n    for (imageno = 0; imageno < num_images ; imageno++)  {\n        opj_image_t* image = NULL;\n        opj_stream_t *l_stream = NULL;              /* Stream */\n        opj_codec_t* l_codec = NULL;                /* Handle to a decompressor */\n        opj_codestream_index_t* cstr_index = NULL;\n\n        if (!parameters.quiet) {\n            fprintf(stderr, \"\\n\");\n        }\n\n        if (img_fol.set_imgdir == 1) {\n            if (get_next_file(imageno, dirptr, &img_fol, &parameters)) {\n                fprintf(stderr, \"skipping file...\\n\");\n                destroy_parameters(&parameters);\n                continue;\n            }\n        }\n\n        /* read the input file and put it in memory */\n        /* ---------------------------------------- */\n\n        l_stream = opj_stream_create_default_file_stream(parameters.infile, 1);\n        if (!l_stream) {\n            fprintf(stderr, \"ERROR -> failed to create the stream from the file %s\\n\",\n                    parameters.infile);\n            failed = 1;\n            goto fin;\n        }\n\n        /* decode the JPEG2000 stream */\n        /* ---------------------- */\n\n        switch (parameters.decod_format) {\n        case J2K_CFMT: { /* JPEG-2000 codestream */\n            /* Get a decoder handle */\n            l_codec = opj_create_decompress(OPJ_CODEC_J2K);\n            break;\n        }\n        case JP2_CFMT: { /* JPEG 2000 compressed image data */\n            /* Get a decoder handle */\n            l_codec = opj_create_decompress(OPJ_CODEC_JP2);\n            break;\n        }\n        case JPT_CFMT: { /* JPEG 2000, JPIP */\n            /* Get a decoder handle */\n            l_codec = opj_create_decompress(OPJ_CODEC_JPT);\n            break;\n        }\n        default:\n            fprintf(stderr, \"skipping file..\\n\");\n            destroy_parameters(&parameters);\n            opj_stream_destroy(l_stream);\n            continue;\n        }\n\n        if (parameters.quiet) {\n            /* Set all callbacks to quiet */\n            opj_set_info_handler(l_codec, quiet_callback, 00);\n            opj_set_warning_handler(l_codec, quiet_callback, 00);\n            opj_set_error_handler(l_codec, quiet_callback, 00);\n        } else {\n            /* catch events using our callbacks and give a local context */\n            opj_set_info_handler(l_codec, info_callback, 00);\n            opj_set_warning_handler(l_codec, warning_callback, 00);\n            opj_set_error_handler(l_codec, error_callback, 00);\n        }\n\n\n        t = opj_clock();\n\n        /* Setup the decoder decoding parameters using user parameters */\n        if (!opj_setup_decoder(l_codec, &(parameters.core))) {\n            fprintf(stderr, \"ERROR -> opj_decompress: failed to setup the decoder\\n\");\n            opj_stream_destroy(l_stream);\n            opj_destroy_codec(l_codec);\n            failed = 1;\n            goto fin;\n        }\n\n        if (parameters.num_threads >= 1 &&\n                !opj_codec_set_threads(l_codec, parameters.num_threads)) {\n            fprintf(stderr, \"ERROR -> opj_decompress: failed to set number of threads\\n\");\n            opj_stream_destroy(l_stream);\n            opj_destroy_codec(l_codec);\n            failed = 1;\n            goto fin;\n        }\n\n        /* Read the main header of the codestream and if necessary the JP2 boxes*/\n        if (! opj_read_header(l_stream, l_codec, &image)) {\n            fprintf(stderr, \"ERROR -> opj_decompress: failed to read the header\\n\");\n            opj_stream_destroy(l_stream);\n            opj_destroy_codec(l_codec);\n            opj_image_destroy(image);\n            failed = 1;\n            goto fin;\n        }\n\n        if (parameters.numcomps) {\n            if (! opj_set_decoded_components(l_codec,\n                                             parameters.numcomps,\n                                             parameters.comps_indices,\n                                             OPJ_FALSE)) {\n                fprintf(stderr,\n                        \"ERROR -> opj_decompress: failed to set the component indices!\\n\");\n                opj_destroy_codec(l_codec);\n                opj_stream_destroy(l_stream);\n                opj_image_destroy(image);\n                failed = 1;\n                goto fin;\n            }\n        }\n\n        if (getenv(\"USE_OPJ_SET_DECODED_RESOLUTION_FACTOR\") != NULL) {\n            /* For debugging/testing purposes, and also an illustration on how to */\n            /* use the alternative API opj_set_decoded_resolution_factor() instead */\n            /* of setting parameters.cp_reduce */\n            if (! opj_set_decoded_resolution_factor(l_codec, cp_reduce)) {\n                fprintf(stderr,\n                        \"ERROR -> opj_decompress: failed to set the resolution factor tile!\\n\");\n                opj_destroy_codec(l_codec);\n                opj_stream_destroy(l_stream);\n                opj_image_destroy(image);\n                failed = 1;\n                goto fin;\n            }\n        }\n\n        if (!parameters.nb_tile_to_decode) {\n            if (getenv(\"SKIP_OPJ_SET_DECODE_AREA\") != NULL &&\n                    parameters.DA_x0 == 0 &&\n                    parameters.DA_y0 == 0 &&\n                    parameters.DA_x1 == 0 &&\n                    parameters.DA_y1 == 0) {\n                /* For debugging/testing purposes, */\n                /* do nothing if SKIP_OPJ_SET_DECODE_AREA env variable */\n                /* is defined and no decoded area has been set */\n            }\n            /* Optional if you want decode the entire image */\n            else if (!opj_set_decode_area(l_codec, image, (OPJ_INT32)parameters.DA_x0,\n                                          (OPJ_INT32)parameters.DA_y0, (OPJ_INT32)parameters.DA_x1,\n                                          (OPJ_INT32)parameters.DA_y1)) {\n                fprintf(stderr, \"ERROR -> opj_decompress: failed to set the decoded area\\n\");\n                opj_stream_destroy(l_stream);\n                opj_destroy_codec(l_codec);\n                opj_image_destroy(image);\n                failed = 1;\n                goto fin;\n            }\n\n            /* Get the decoded image */\n            if (!(opj_decode(l_codec, l_stream, image) &&\n                    opj_end_decompress(l_codec,   l_stream))) {\n                fprintf(stderr, \"ERROR -> opj_decompress: failed to decode image!\\n\");\n                opj_destroy_codec(l_codec);\n                opj_stream_destroy(l_stream);\n                opj_image_destroy(image);\n                failed = 1;\n                goto fin;\n            }\n        } else {\n            if (!(parameters.DA_x0 == 0 &&\n                    parameters.DA_y0 == 0 &&\n                    parameters.DA_x1 == 0 &&\n                    parameters.DA_y1 == 0)) {\n                if (!(parameters.quiet)) {\n                    fprintf(stderr, \"WARNING: -d option ignored when used together with -t\\n\");\n                }\n            }\n\n            if (!opj_get_decoded_tile(l_codec, l_stream, image, parameters.tile_index)) {\n                fprintf(stderr, \"ERROR -> opj_decompress: failed to decode tile!\\n\");\n                opj_destroy_codec(l_codec);\n                opj_stream_destroy(l_stream);\n                opj_image_destroy(image);\n                failed = 1;\n                goto fin;\n            }\n            if (!(parameters.quiet)) {\n                fprintf(stdout, \"tile %d is decoded!\\n\\n\", parameters.tile_index);\n            }\n        }\n\n        tCumulative += opj_clock() - t;\n        numDecompressedImages++;\n\n        /* Close the byte stream */\n        opj_stream_destroy(l_stream);\n\n        if (image->color_space != OPJ_CLRSPC_SYCC\n                && image->numcomps == 3 && image->comps[0].dx == image->comps[0].dy\n                && image->comps[1].dx != 1) {\n            image->color_space = OPJ_CLRSPC_SYCC;\n        } else if (image->numcomps <= 2) {\n            image->color_space = OPJ_CLRSPC_GRAY;\n        }\n\n        if (image->color_space == OPJ_CLRSPC_SYCC) {\n            color_sycc_to_rgb(image);\n        } else if ((image->color_space == OPJ_CLRSPC_CMYK) &&\n                   (parameters.cod_format != TIF_DFMT)) {\n            color_cmyk_to_rgb(image);\n        } else if (image->color_space == OPJ_CLRSPC_EYCC) {\n            color_esycc_to_rgb(image);\n        }\n\n        if (image->icc_profile_buf) {\n#if defined(OPJ_HAVE_LIBLCMS1) || defined(OPJ_HAVE_LIBLCMS2)\n            if (image->icc_profile_len) {\n                color_apply_icc_profile(image);\n            } else {\n                color_cielab_to_rgb(image);\n            }\n#endif\n            free(image->icc_profile_buf);\n            image->icc_profile_buf = NULL;\n            image->icc_profile_len = 0;\n        }\n\n        /* Force output precision */\n        /* ---------------------- */\n        if (parameters.precision != NULL) {\n            OPJ_UINT32 compno;\n            for (compno = 0; compno < image->numcomps; ++compno) {\n                OPJ_UINT32 precno = compno;\n                OPJ_UINT32 prec;\n\n                if (precno >= parameters.nb_precision) {\n                    precno = parameters.nb_precision - 1U;\n                }\n\n                prec = parameters.precision[precno].prec;\n                if (prec == 0) {\n                    prec = image->comps[compno].prec;\n                }\n\n                switch (parameters.precision[precno].mode) {\n                case OPJ_PREC_MODE_CLIP:\n                    clip_component(&(image->comps[compno]), prec);\n                    break;\n                case OPJ_PREC_MODE_SCALE:\n                    scale_component(&(image->comps[compno]), prec);\n                    break;\n                default:\n                    break;\n                }\n\n            }\n        }\n\n        /* Upsample components */\n        /* ------------------- */\n        if (parameters.upsample) {\n            image = upsample_image_components(image);\n            if (image == NULL) {\n                fprintf(stderr,\n                        \"ERROR -> opj_decompress: failed to upsample image components!\\n\");\n                opj_destroy_codec(l_codec);\n                failed = 1;\n                goto fin;\n            }\n        }\n\n        /* Force RGB output */\n        /* ---------------- */\n        if (parameters.force_rgb) {\n            switch (image->color_space) {\n            case OPJ_CLRSPC_SRGB:\n                break;\n            case OPJ_CLRSPC_GRAY:\n                image = convert_gray_to_rgb(image);\n                break;\n            default:\n                fprintf(stderr,\n                        \"ERROR -> opj_decompress: don't know how to convert image to RGB colorspace!\\n\");\n                opj_image_destroy(image);\n                image = NULL;\n                break;\n            }\n            if (image == NULL) {\n                fprintf(stderr, \"ERROR -> opj_decompress: failed to convert to RGB image!\\n\");\n                opj_destroy_codec(l_codec);\n                failed = 1;\n                goto fin;\n            }\n        }\n\n        /* create output image */\n        /* ------------------- */\n        switch (parameters.cod_format) {\n        case PXM_DFMT:          /* PNM PGM PPM */\n            if (imagetopnm(image, parameters.outfile, parameters.split_pnm)) {\n                fprintf(stderr, \"[ERROR] Outfile %s not generated\\n\", parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n\n        case PGX_DFMT:          /* PGX */\n            if (imagetopgx(image, parameters.outfile)) {\n                fprintf(stderr, \"[ERROR] Outfile %s not generated\\n\", parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n\n        case BMP_DFMT:          /* BMP */\n            if (imagetobmp(image, parameters.outfile)) {\n                fprintf(stderr, \"[ERROR] Outfile %s not generated\\n\", parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n#ifdef OPJ_HAVE_LIBTIFF\n        case TIF_DFMT:          /* TIF(F) */\n            if (imagetotif(image, parameters.outfile)) {\n                fprintf(stderr, \"[ERROR] Outfile %s not generated\\n\", parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n#endif /* OPJ_HAVE_LIBTIFF */\n        case RAW_DFMT:          /* RAW */\n            if (imagetoraw(image, parameters.outfile)) {\n                fprintf(stderr,\n                        \"[ERROR] Error generating raw or yuv file. Outfile %s not generated\\n\",\n                        parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n\n        case RAWL_DFMT:         /* RAWL */\n            if (imagetorawl(image, parameters.outfile)) {\n                fprintf(stderr,\n                        \"[ERROR] Error generating rawl file. Outfile %s not generated\\n\",\n                        parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n\n        case TGA_DFMT:          /* TGA */\n            if (imagetotga(image, parameters.outfile)) {\n                fprintf(stderr, \"[ERROR] Error generating tga file. Outfile %s not generated\\n\",\n                        parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n#ifdef OPJ_HAVE_LIBPNG\n        case PNG_DFMT:          /* PNG */\n            if (imagetopng(image, parameters.outfile)) {\n                fprintf(stderr, \"[ERROR] Error generating png file. Outfile %s not generated\\n\",\n                        parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n#endif /* OPJ_HAVE_LIBPNG */\n        /* Can happen if output file is TIF(F) or PNG\n         * and OPJ_HAVE_LIBTIF or OPJ_HAVE_LIBPNG is undefined\n        */\n        default:\n            fprintf(stderr, \"[ERROR] Outfile %s not generated\\n\", parameters.outfile);\n            failed = 1;\n        }\n\n        /* free remaining structures */\n        if (l_codec) {\n            opj_destroy_codec(l_codec);\n        }\n\n\n        /* free image data structure */\n        opj_image_destroy(image);\n\n        /* destroy the codestream index */\n        opj_destroy_cstr_index(&cstr_index);\n\n        if (failed) {\n            (void)remove(parameters.outfile);    /* ignore return value */\n        }\n    }\nfin:\n    destroy_parameters(&parameters);\n    if (failed && img_fol.imgdirpath) {\n        free(img_fol.imgdirpath);\n    }\n    if (dirptr) {\n        if (dirptr->filename) {\n            free(dirptr->filename);\n        }\n        if (dirptr->filename_buf) {\n            free(dirptr->filename_buf);\n        }\n        free(dirptr);\n    }\n    if (numDecompressedImages && !failed && !(parameters.quiet)) {\n        fprintf(stdout, \"decode time: %d ms\\n\",\n                (int)((tCumulative * 1000.0) / (OPJ_FLOAT64)numDecompressedImages));\n    }\n    return failed ? EXIT_FAILURE : EXIT_SUCCESS;\n}",
  "abstract_func": "int main(int VAR_0, char **VAR_1)\n{\n    opj_decompress_parameters VAR_2;           /* COMMENT_0 */\n\n    OPJ_INT32 VAR_3, VAR_4;\n    img_fol_t VAR_5;\n    dircnt_t *VAR_6 = NULL;\n    int VAR_7 = 0;\n    OPJ_FLOAT64 VAR_8, VAR_9 = 0;\n    OPJ_UINT32 VAR_10 = 0;\n    OPJ_UINT32 VAR_11;\n\n    /* COMMENT_1 */\n    set_default_parameters(&VAR_2);\n\n    /* COMMENT_2 */\n    memset(&VAR_5, 0, sizeof(img_fol_t));\n\n    /* COMMENT_3 */\n    if (parse_cmdline_decoder(VAR_0, VAR_1, &VAR_2, &VAR_5) == 1) {\n        VAR_7 = 1;\n        goto fin;\n    }\n\n    VAR_11 = VAR_2.core.cp_reduce;\n    if (getenv(\"USE_OPJ_SET_DECODED_RESOLUTION_FACTOR\") != NULL) {\n        /* COMMENT_4 */\n        /* COMMENT_5 */\n        /* COMMENT_6 */\n        VAR_2.core.cp_reduce = 0;\n    }\n\n\n    /* COMMENT_7 */\n    if (VAR_5.set_imgdir == 1) {\n        int VAR_12;\n        VAR_3 = get_num_images(VAR_5.imgdirpath);\n\n        VAR_6 = (dircnt_t*)calloc(1, sizeof(dircnt_t));\n        if (!VAR_6) {\n            destroy_parameters(&VAR_2);\n            return VAR_13;\n        }\n        /* COMMENT_8 */\n        VAR_6->filename_buf = calloc((size_t) VAR_3, sizeof(char) * VAR_14);\n        if (!VAR_6->filename_buf) {\n            VAR_7 = 1;\n            goto fin;\n        }\n\n        VAR_6->filename = (char**) calloc((size_t) VAR_3, sizeof(char*));\n\n        if (!VAR_6->filename) {\n            VAR_7 = 1;\n            goto fin;\n        }\n        for (VAR_12 = 0; VAR_12 < VAR_3; VAR_12++) {\n            VAR_6->filename[VAR_12] = VAR_6->filename_buf + VAR_12 * VAR_14;\n        }\n\n        if (load_images(VAR_6, VAR_5.imgdirpath) == 1) {\n            VAR_7 = 1;\n            goto fin;\n        }\n        if (VAR_3 == 0) {\n            fprintf(VAR_15, \"Folder is empty\\n\");\n            VAR_7 = 1;\n            goto fin;\n        }\n    } else {\n        VAR_3 = 1;\n    }\n\n    /* COMMENT_9 */\n    for (VAR_4 = 0; VAR_4 < VAR_3 ; VAR_4++)  {\n        opj_image_t* VAR_16 = NULL;\n        opj_stream_t *VAR_17 = NULL;              /* COMMENT_10 */\n        opj_codec_t* VAR_18 = NULL;                /* COMMENT_11 */\n        opj_codestream_index_t* VAR_19 = NULL;\n\n        if (!VAR_2.quiet) {\n            fprintf(VAR_15, \"\\n\");\n        }\n\n        if (VAR_5.set_imgdir == 1) {\n            if (get_next_file(VAR_4, VAR_6, &VAR_5, &VAR_2)) {\n                fprintf(VAR_15, \"skipping file...\\n\");\n                destroy_parameters(&VAR_2);\n                continue;\n            }\n        }\n\n        /* COMMENT_12 */\n        /* COMMENT_13 */\n\n        VAR_17 = opj_stream_create_default_file_stream(VAR_2.infile, 1);\n        if (!VAR_17) {\n            fprintf(VAR_15, \"ERROR -> failed to create the stream from the file %s\\n\",\n                    VAR_2.infile);\n            VAR_7 = 1;\n            goto fin;\n        }\n\n        /* COMMENT_14 */\n        /* COMMENT_15 */\n\n        switch (VAR_2.decod_format) {\n        case VAR_20: { /* COMMENT_16 */\n            /* COMMENT_17 */\n            VAR_18 = opj_create_decompress(VAR_21);\n            break;\n        }\n        case VAR_22: { /* COMMENT_18 */\n            /* COMMENT_17 */\n            VAR_18 = opj_create_decompress(VAR_23);\n            break;\n        }\n        case VAR_24: { /* COMMENT_19 */\n            /* COMMENT_17 */\n            VAR_18 = opj_create_decompress(VAR_25);\n            break;\n        }\n        default:\n            fprintf(VAR_15, \"skipping file..\\n\");\n            destroy_parameters(&VAR_2);\n            opj_stream_destroy(VAR_17);\n            continue;\n        }\n\n        if (VAR_2.quiet) {\n            /* COMMENT_20 */\n            opj_set_info_handler(VAR_18, VAR_26, 00);\n            opj_set_warning_handler(VAR_18, VAR_26, 00);\n            opj_set_error_handler(VAR_18, VAR_26, 00);\n        } else {\n            /* COMMENT_21 */\n            opj_set_info_handler(VAR_18, VAR_27, 00);\n            opj_set_warning_handler(VAR_18, VAR_28, 00);\n            opj_set_error_handler(VAR_18, VAR_29, 00);\n        }\n\n\n        VAR_8 = opj_clock();\n\n        /* COMMENT_22 */\n        if (!opj_setup_decoder(VAR_18, &(VAR_2.core))) {\n            fprintf(VAR_15, \"ERROR -> opj_decompress: failed to setup the decoder\\n\");\n            opj_stream_destroy(VAR_17);\n            opj_destroy_codec(VAR_18);\n            VAR_7 = 1;\n            goto fin;\n        }\n\n        if (VAR_2.num_threads >= 1 &&\n                !opj_codec_set_threads(VAR_18, VAR_2.num_threads)) {\n            fprintf(VAR_15, \"ERROR -> opj_decompress: failed to set number of threads\\n\");\n            opj_stream_destroy(VAR_17);\n            opj_destroy_codec(VAR_18);\n            VAR_7 = 1;\n            goto fin;\n        }\n\n        /* COMMENT_23 */\n        if (! opj_read_header(VAR_17, VAR_18, &VAR_16)) {\n            fprintf(VAR_15, \"ERROR -> opj_decompress: failed to read the header\\n\");\n            opj_stream_destroy(VAR_17);\n            opj_destroy_codec(VAR_18);\n            opj_image_destroy(VAR_16);\n            VAR_7 = 1;\n            goto fin;\n        }\n\n        if (VAR_2.numcomps) {\n            if (! opj_set_decoded_components(VAR_18,\n                                             VAR_2.numcomps,\n                                             VAR_2.comps_indices,\n                                             VAR_30)) {\n                fprintf(VAR_15,\n                        \"ERROR -> opj_decompress: failed to set the component indices!\\n\");\n                opj_destroy_codec(VAR_18);\n                opj_stream_destroy(VAR_17);\n                opj_image_destroy(VAR_16);\n                VAR_7 = 1;\n                goto fin;\n            }\n        }\n\n        if (getenv(\"USE_OPJ_SET_DECODED_RESOLUTION_FACTOR\") != NULL) {\n            /* COMMENT_24 */\n            /* COMMENT_25 */\n            /* COMMENT_26 */\n            if (! opj_set_decoded_resolution_factor(VAR_18, VAR_11)) {\n                fprintf(VAR_15,\n                        \"ERROR -> opj_decompress: failed to set the resolution factor tile!\\n\");\n                opj_destroy_codec(VAR_18);\n                opj_stream_destroy(VAR_17);\n                opj_image_destroy(VAR_16);\n                VAR_7 = 1;\n                goto fin;\n            }\n        }\n\n        if (!VAR_2.nb_tile_to_decode) {\n            if (getenv(\"SKIP_OPJ_SET_DECODE_AREA\") != NULL &&\n                    VAR_2.DA_x0 == 0 &&\n                    VAR_2.DA_y0 == 0 &&\n                    VAR_2.DA_x1 == 0 &&\n                    VAR_2.DA_y1 == 0) {\n                /* COMMENT_27 */\n                /* COMMENT_28 */\n                /* COMMENT_29 */\n            }\n            /* COMMENT_30 */\n            else if (!opj_set_decode_area(VAR_18, VAR_16, (OPJ_INT32)VAR_2.DA_x0,\n                                          (OPJ_INT32)VAR_2.DA_y0, (OPJ_INT32)VAR_2.DA_x1,\n                                          (OPJ_INT32)VAR_2.DA_y1)) {\n                fprintf(VAR_15, \"ERROR -> opj_decompress: failed to set the decoded area\\n\");\n                opj_stream_destroy(VAR_17);\n                opj_destroy_codec(VAR_18);\n                opj_image_destroy(VAR_16);\n                VAR_7 = 1;\n                goto fin;\n            }\n\n            /* COMMENT_31 */\n            if (!(opj_decode(VAR_18, VAR_17, VAR_16) &&\n                    opj_end_decompress(VAR_18,   VAR_17))) {\n                fprintf(VAR_15, \"ERROR -> opj_decompress: failed to decode image!\\n\");\n                opj_destroy_codec(VAR_18);\n                opj_stream_destroy(VAR_17);\n                opj_image_destroy(VAR_16);\n                VAR_7 = 1;\n                goto fin;\n            }\n        } else {\n            if (!(VAR_2.DA_x0 == 0 &&\n                    VAR_2.DA_y0 == 0 &&\n                    VAR_2.DA_x1 == 0 &&\n                    VAR_2.DA_y1 == 0)) {\n                if (!(VAR_2.quiet)) {\n                    fprintf(VAR_15, \"WARNING: -d option ignored when used together with -t\\n\");\n                }\n            }\n\n            if (!opj_get_decoded_tile(VAR_18, VAR_17, VAR_16, VAR_2.tile_index)) {\n                fprintf(VAR_15, \"ERROR -> opj_decompress: failed to decode tile!\\n\");\n                opj_destroy_codec(VAR_18);\n                opj_stream_destroy(VAR_17);\n                opj_image_destroy(VAR_16);\n                VAR_7 = 1;\n                goto fin;\n            }\n            if (!(VAR_2.quiet)) {\n                fprintf(VAR_31, \"tile %d is decoded!\\n\\n\", VAR_2.tile_index);\n            }\n        }\n\n        VAR_9 += opj_clock() - VAR_8;\n        VAR_10++;\n\n        /* COMMENT_32 */\n        opj_stream_destroy(VAR_17);\n\n        if (VAR_16->color_space != VAR_32\n                && VAR_16->numcomps == 3 && VAR_16->comps[0].dx == VAR_16->comps[0].dy\n                && VAR_16->comps[1].dx != 1) {\n            VAR_16->color_space = VAR_32;\n        } else if (VAR_16->numcomps <= 2) {\n            VAR_16->color_space = VAR_33;\n        }\n\n        if (VAR_16->color_space == VAR_32) {\n            color_sycc_to_rgb(VAR_16);\n        } else if ((VAR_16->color_space == VAR_34) &&\n                   (VAR_2.cod_format != VAR_35)) {\n            color_cmyk_to_rgb(VAR_16);\n        } else if (VAR_16->color_space == VAR_36) {\n            color_esycc_to_rgb(VAR_16);\n        }\n\n        if (VAR_16->icc_profile_buf) {\n#if defined(VAR_37) || defined(VAR_38)\n            if (VAR_16->icc_profile_len) {\n                color_apply_icc_profile(VAR_16);\n            } else {\n                color_cielab_to_rgb(VAR_16);\n            }\n#endif\n            free(VAR_16->icc_profile_buf);\n            VAR_16->icc_profile_buf = NULL;\n            VAR_16->icc_profile_len = 0;\n        }\n\n        /* COMMENT_33 */\n        /* COMMENT_15 */\n        if (VAR_2.precision != NULL) {\n            OPJ_UINT32 VAR_39;\n            for (VAR_39 = 0; VAR_39 < VAR_16->numcomps; ++VAR_39) {\n                OPJ_UINT32 VAR_40 = VAR_39;\n                OPJ_UINT32 VAR_41;\n\n                if (VAR_40 >= VAR_2.nb_precision) {\n                    VAR_40 = VAR_2.nb_precision - 1U;\n                }\n\n                VAR_41 = VAR_2.precision[VAR_40].prec;\n                if (VAR_41 == 0) {\n                    VAR_41 = VAR_16->comps[VAR_39].prec;\n                }\n\n                switch (VAR_2.precision[VAR_40].mode) {\n                case VAR_42:\n                    clip_component(&(VAR_16->comps[VAR_39]), VAR_41);\n                    break;\n                case VAR_43:\n                    scale_component(&(VAR_16->comps[VAR_39]), VAR_41);\n                    break;\n                default:\n                    break;\n                }\n\n            }\n        }\n\n        /* COMMENT_34 */\n        /* COMMENT_35 */\n        if (VAR_2.upsample) {\n            VAR_16 = upsample_image_components(VAR_16);\n            if (VAR_16 == NULL) {\n                fprintf(VAR_15,\n                        \"ERROR -> opj_decompress: failed to upsample image components!\\n\");\n                opj_destroy_codec(VAR_18);\n                VAR_7 = 1;\n                goto fin;\n            }\n        }\n\n        /* COMMENT_36 */\n        /* COMMENT_37 */\n        if (VAR_2.force_rgb) {\n            switch (VAR_16->color_space) {\n            case VAR_44:\n                break;\n            case VAR_33:\n                VAR_16 = convert_gray_to_rgb(VAR_16);\n                break;\n            default:\n                fprintf(VAR_15,\n                        \"ERROR -> opj_decompress: don't know how to convert image to RGB colorspace!\\n\");\n                opj_image_destroy(VAR_16);\n                VAR_16 = NULL;\n                break;\n            }\n            if (VAR_16 == NULL) {\n                fprintf(VAR_15, \"ERROR -> opj_decompress: failed to convert to RGB image!\\n\");\n                opj_destroy_codec(VAR_18);\n                VAR_7 = 1;\n                goto fin;\n            }\n        }\n\n        /* COMMENT_38 */\n        /* COMMENT_35 */\n        switch (VAR_2.cod_format) {\n        case VAR_45:          /* COMMENT_39 */\n            if (imagetopnm(VAR_16, VAR_2.outfile, VAR_2.split_pnm)) {\n                fprintf(VAR_15, \"[ERROR] Outfile %s not generated\\n\", VAR_2.outfile);\n                VAR_7 = 1;\n            } else if (!(VAR_2.quiet)) {\n                fprintf(VAR_31, \"[INFO] Generated Outfile %s\\n\", VAR_2.outfile);\n            }\n            break;\n\n        case VAR_46:          /* COMMENT_40 */\n            if (imagetopgx(VAR_16, VAR_2.outfile)) {\n                fprintf(VAR_15, \"[ERROR] Outfile %s not generated\\n\", VAR_2.outfile);\n                VAR_7 = 1;\n            } else if (!(VAR_2.quiet)) {\n                fprintf(VAR_31, \"[INFO] Generated Outfile %s\\n\", VAR_2.outfile);\n            }\n            break;\n\n        case VAR_47:          /* COMMENT_41 */\n            if (imagetobmp(VAR_16, VAR_2.outfile)) {\n                fprintf(VAR_15, \"[ERROR] Outfile %s not generated\\n\", VAR_2.outfile);\n                VAR_7 = 1;\n            } else if (!(VAR_2.quiet)) {\n                fprintf(VAR_31, \"[INFO] Generated Outfile %s\\n\", VAR_2.outfile);\n            }\n            break;\n#ifdef VAR_48\n        case VAR_35:          /* COMMENT_42 */\n            if (imagetotif(VAR_16, VAR_2.outfile)) {\n                fprintf(VAR_15, \"[ERROR] Outfile %s not generated\\n\", VAR_2.outfile);\n                VAR_7 = 1;\n            } else if (!(VAR_2.quiet)) {\n                fprintf(VAR_31, \"[INFO] Generated Outfile %s\\n\", VAR_2.outfile);\n            }\n            break;\n#endif /* COMMENT_43 */\n        case VAR_49:          /* COMMENT_44 */\n            if (imagetoraw(VAR_16, VAR_2.outfile)) {\n                fprintf(VAR_15,\n                        \"[ERROR] Error generating raw or yuv file. Outfile %s not generated\\n\",\n                        VAR_2.outfile);\n                VAR_7 = 1;\n            } else if (!(VAR_2.quiet)) {\n                fprintf(VAR_31, \"[INFO] Generated Outfile %s\\n\", VAR_2.outfile);\n            }\n            break;\n\n        case VAR_50:         /* COMMENT_45 */\n            if (imagetorawl(VAR_16, VAR_2.outfile)) {\n                fprintf(VAR_15,\n                        \"[ERROR] Error generating rawl file. Outfile %s not generated\\n\",\n                        VAR_2.outfile);\n                VAR_7 = 1;\n            } else if (!(VAR_2.quiet)) {\n                fprintf(VAR_31, \"[INFO] Generated Outfile %s\\n\", VAR_2.outfile);\n            }\n            break;\n\n        case VAR_51:          /* COMMENT_46 */\n            if (imagetotga(VAR_16, VAR_2.outfile)) {\n                fprintf(VAR_15, \"[ERROR] Error generating tga file. Outfile %s not generated\\n\",\n                        VAR_2.outfile);\n                VAR_7 = 1;\n            } else if (!(VAR_2.quiet)) {\n                fprintf(VAR_31, \"[INFO] Generated Outfile %s\\n\", VAR_2.outfile);\n            }\n            break;\n#ifdef VAR_52\n        case VAR_53:          /* COMMENT_47 */\n            if (imagetopng(VAR_16, VAR_2.outfile)) {\n                fprintf(VAR_15, \"[ERROR] Error generating png file. Outfile %s not generated\\n\",\n                        VAR_2.outfile);\n                VAR_7 = 1;\n            } else if (!(VAR_2.quiet)) {\n                fprintf(VAR_31, \"[INFO] Generated Outfile %s\\n\", VAR_2.outfile);\n            }\n            break;\n#endif /* COMMENT_48 */\n        /* COMMENT_49 */\n                                                              \n          \n        default:\n            fprintf(VAR_15, \"[ERROR] Outfile %s not generated\\n\", VAR_2.outfile);\n            VAR_7 = 1;\n        }\n\n        /* COMMENT_52 */\n        if (VAR_18) {\n            opj_destroy_codec(VAR_18);\n        }\n\n\n        /* COMMENT_53 */\n        opj_image_destroy(VAR_16);\n\n        /* COMMENT_54 */\n        opj_destroy_cstr_index(&VAR_19);\n\n        if (VAR_7) {\n            (void)remove(VAR_2.outfile);    /* COMMENT_55 */\n        }\n    }\nfin:\n    destroy_parameters(&VAR_2);\n    if (VAR_7 && VAR_5.imgdirpath) {\n        free(VAR_5.imgdirpath);\n    }\n    if (VAR_6) {\n        if (VAR_6->filename) {\n            free(VAR_6->filename);\n        }\n        if (VAR_6->filename_buf) {\n            free(VAR_6->filename_buf);\n        }\n        free(VAR_6);\n    }\n    if (VAR_10 && !VAR_7 && !(VAR_2.quiet)) {\n        fprintf(VAR_31, \"decode time: %d ms\\n\",\n                (int)((VAR_9 * 1000.0) / (OPJ_FLOAT64)VAR_10));\n    }\n    return VAR_7 ? VAR_13 : VAR_54;\n}",
  "func_graph_path": "uclouvain/openjpeg/f0727df07c4d944d7d1c5002451cfbc9545d3288/opj_decompress.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -42,14 +42,13 @@\n             return EXIT_FAILURE;\n         }\n         /* Stores at max 10 image file names */\n-        dirptr->filename_buf = (char*)malloc(sizeof(char) *\n-                                             (size_t)num_images * OPJ_PATH_LEN);\n+        dirptr->filename_buf = calloc((size_t) num_images, sizeof(char) * OPJ_PATH_LEN);\n         if (!dirptr->filename_buf) {\n             failed = 1;\n             goto fin;\n         }\n \n-        dirptr->filename = (char**) malloc((size_t)num_images * sizeof(char*));\n+        dirptr->filename = (char**) calloc((size_t) num_images, sizeof(char*));\n \n         if (!dirptr->filename) {\n             failed = 1;",
  "diff_line_info": {
    "deleted_lines": [
      "        dirptr->filename_buf = (char*)malloc(sizeof(char) *",
      "                                             (size_t)num_images * OPJ_PATH_LEN);",
      "        dirptr->filename = (char**) malloc((size_t)num_images * sizeof(char*));"
    ],
    "added_lines": [
      "        dirptr->filename_buf = calloc((size_t) num_images, sizeof(char) * OPJ_PATH_LEN);",
      "        dirptr->filename = (char**) calloc((size_t) num_images, sizeof(char*));"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/uclouvain/openjpeg/pull/1395",
  "description": {
    "pr_info": {
      "title": "Fix integer overflow in num_images",
      "number": 1395
    },
    "comment": [
      "Includes the fix for CVE-2021-29338\r\nCredit to @kaniini based on #1346\r\nFixes #1338",
      "It's not clear to me if the `OPJ_PATH_LEN * 2` changes from #1346 are also necessary since f0629cb was merged into master. Can you help confirm @rouault ?",
      "> It's not clear to me if the `OPJ_PATH_LEN * 2` changes from #1346 are also necessary since [f0629cb](https://github.com/uclouvain/openjpeg/commit/f0629cb1c4c485d905936413556deb2872ac51e5) was merged into master. Can you help confirm @rouault ?\r\n\r\nI don't think they are necessary since we have other checks that should prevent buffer overflow",
      "Thanks for taking care of this @baparham!"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix\n\nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The commit addresses an integer overflow in `num_images`, which could lead to a buffer overflow. The fix uses `calloc` to properly allocate memory, preventing overflow. The reference to CVE-2021-29338 indicates a security issue.\n\nFinal Classification: Security Vulnerability Fix\n\nConfidence Score: 0.95"
}