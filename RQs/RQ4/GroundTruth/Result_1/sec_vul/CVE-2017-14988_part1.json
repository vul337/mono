{
  "cve_id": "CVE-2017-14988",
  "cwe_ids": [
    "CWE-400"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "AcademySoftwareFoundation/openexr",
  "commit_msg": "specific check for bad size field in header attributes (related to #248)",
  "commit_hash": "4c146c50e952655bc193567224c2a081c7da5e98",
  "git_url": "https://github.com/AcademySoftwareFoundation/openexr/commit/4c146c50e952655bc193567224c2a081c7da5e98",
  "file_path": "OpenEXR/IlmImf/ImfHeader.cpp",
  "func_name": "Header::readFrom",
  "func_before": "void\nHeader::readFrom (OPENEXR_IMF_INTERNAL_NAMESPACE::IStream &is, int &version)\n{\n    //\n    // Read all attributes.\n    //\n\n    int attrCount = 0;\n\n    while (true)\n    {\n\t//\n\t// Read the name of the attribute.\n\t// A zero-length attribute name indicates the end of the header.\n\t//\n\n\tchar name[Name::SIZE];\n\tOPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, Name::MAX_LENGTH, name);\n\n\tif (name[0] == 0)\n\t{\n\t    if (attrCount == 0) _readsNothing = true;\n\t    else                _readsNothing = false;\n\t    break;\n\t}\n\n\tattrCount++;\n\n\tcheckIsNullTerminated (name, \"attribute name\");\n\n\t//\n\t// Read the attribute type and the size of the attribute value.\n\t//\n\n\tchar typeName[Name::SIZE];\n\tint size;\n\n\tOPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, Name::MAX_LENGTH, typeName);\n\tcheckIsNullTerminated (typeName, \"attribute type name\");\n\tOPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, size);\n\n\tAttributeMap::iterator i = _map.find (name);\n\n\tif (i != _map.end())\n\t{\n\t    //\n\t    // The attribute already exists (for example,\n\t    // because it is a predefined attribute).\n\t    // Read the attribute's new value from the file.\n\t    //\n\n\t    if (strncmp (i->second->typeName(), typeName, sizeof (typeName)))\n\t\tTHROW (IEX_NAMESPACE::InputExc, \"Unexpected type for image attribute \"\n\t\t\t\t      \"\\\"\" << name << \"\\\".\");\n\n\t    i->second->readValueFrom (is, size, version);\n\t}\n\telse\n\t{\n\t    //\n\t    // The new attribute does not exist yet.\n\t    // If the attribute type is of a known type,\n\t    // read the attribute value.  If the attribute\n\t    // is of an unknown type, read its value and\n\t    // store it as an OpaqueAttribute.\n\t    //\n\n\t    Attribute *attr;\n\n\t    if (Attribute::knownType (typeName))\n\t\tattr = Attribute::newAttribute (typeName);\n\t    else\n\t\tattr = new OpaqueAttribute (typeName);\n\n\t    try\n\t    {\n\t\tattr->readValueFrom (is, size, version);\n\t\t_map[name] = attr;\n\t    }\n\t    catch (...)\n\t    {\n\t\tdelete attr;\n\t\tthrow;\n\t    }\n\t}\n    }\n}",
  "abstract_func_before": "void\nHeader::readFrom (OPENEXR_IMF_INTERNAL_NAMESPACE::IStream &VAR_0, int &VAR_1)\n{\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n    /* COMMENT_0 */\n\n    int VAR_2 = 0;\n\n    while (true)\n    {\n\t/* COMMENT_0 */\n\t/* COMMENT_2 */\n\t/* COMMENT_3 */\n\t/* COMMENT_0 */\n\n\tchar VAR_3[Name::SIZE];\n\tOPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::VAR_4 <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (VAR_0, Name::MAX_LENGTH, VAR_3);\n\n\tif (VAR_3[0] == 0)\n\t{\n\t    if (VAR_2 == 0) VAR_5 = true;\n\t    else                VAR_5 = false;\n\t    break;\n\t}\n\n\tVAR_2++;\n\n\tcheckIsNullTerminated (VAR_3, \"attribute name\");\n\n\t/* COMMENT_0 */\n\t/* COMMENT_4 */\n\t/* COMMENT_0 */\n\n\tchar VAR_6[Name::SIZE];\n\tint VAR_7;\n\n\tOPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::VAR_4 <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (VAR_0, Name::MAX_LENGTH, VAR_6);\n\tcheckIsNullTerminated (VAR_6, \"attribute type name\");\n\tOPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::VAR_4 <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (VAR_0, VAR_7);\n\n\tAttributeMap::iterator VAR_8 = VAR_9.find (VAR_3);\n\n\tif (VAR_8 != VAR_9.end())\n\t{\n\t    /* COMMENT_0 */\n\t    /* COMMENT_5 */\n\t    /* COMMENT_6 */\n\t    /* COMMENT_7 */\n\t    /* COMMENT_0 */\n\n\t    if (strncmp (VAR_8->second->typeName(), VAR_6, sizeof (VAR_6)))\n\t\tTHROW (IEX_NAMESPACE::InputExc, \"Unexpected type for image attribute \"\n\t\t\t\t      \"\\\"\" << VAR_3 << \"\\\".\");\n\n\t    VAR_8->second->readValueFrom (VAR_0, VAR_7, VAR_1);\n\t}\n\telse\n\t{\n\t    /* COMMENT_0 */\n\t    /* COMMENT_8 */\n\t    /* COMMENT_9 */\n\t    /* COMMENT_10 */\n\t    /* COMMENT_11 */\n\t    /* COMMENT_12 */\n\t    /* COMMENT_0 */\n\n\t    Attribute *VAR_10;\n\n\t    if (Attribute::knownType (VAR_6))\n\t\tVAR_10 = Attribute::newAttribute (VAR_6);\n\t    else\n\t\tVAR_10 = new OpaqueAttribute (VAR_6);\n\n\t    try\n\t    {\n\t\tVAR_10->readValueFrom (VAR_0, VAR_7, VAR_1);\n\t\tVAR_9[VAR_3] = VAR_10;\n\t    }\n\t    catch (...)\n\t    {\n\t\tdelete VAR_10;\n\t\tthrow;\n\t    }\n\t}\n    }\n}",
  "func_graph_path_before": null,
  "func": "void\nHeader::readFrom (OPENEXR_IMF_INTERNAL_NAMESPACE::IStream &is, int &version)\n{\n    //\n    // Read all attributes.\n    //\n\n    int attrCount = 0;\n\n    while (true)\n    {\n\t//\n\t// Read the name of the attribute.\n\t// A zero-length attribute name indicates the end of the header.\n\t//\n\n\tchar name[Name::SIZE];\n\tOPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, Name::MAX_LENGTH, name);\n\n\tif (name[0] == 0)\n\t{\n\t    if (attrCount == 0) _readsNothing = true;\n\t    else                _readsNothing = false;\n\t    break;\n\t}\n\n\tattrCount++;\n\n\tcheckIsNullTerminated (name, \"attribute name\");\n\n\t//\n\t// Read the attribute type and the size of the attribute value.\n\t//\n\n\tchar typeName[Name::SIZE];\n\tint size;\n\n\tOPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, Name::MAX_LENGTH, typeName);\n\tcheckIsNullTerminated (typeName, \"attribute type name\");\n\tOPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, size);\n\n    if( size < 0 )\n    {\n        throw IEX_NAMESPACE::InputExc(\"Invalid size field in header attribute\");\n    }\n\n\tAttributeMap::iterator i = _map.find (name);\n\n\tif (i != _map.end())\n\t{\n\t    //\n\t    // The attribute already exists (for example,\n\t    // because it is a predefined attribute).\n\t    // Read the attribute's new value from the file.\n\t    //\n\n\t    if (strncmp (i->second->typeName(), typeName, sizeof (typeName)))\n\t\tTHROW (IEX_NAMESPACE::InputExc, \"Unexpected type for image attribute \"\n\t\t\t\t      \"\\\"\" << name << \"\\\".\");\n\n\t    i->second->readValueFrom (is, size, version);\n\t}\n\telse\n\t{\n\t    //\n\t    // The new attribute does not exist yet.\n\t    // If the attribute type is of a known type,\n\t    // read the attribute value.  If the attribute\n\t    // is of an unknown type, read its value and\n\t    // store it as an OpaqueAttribute.\n\t    //\n\n\t    Attribute *attr;\n\n\t    if (Attribute::knownType (typeName))\n\t\tattr = Attribute::newAttribute (typeName);\n\t    else\n\t\tattr = new OpaqueAttribute (typeName);\n\n\t    try\n\t    {\n\t\tattr->readValueFrom (is, size, version);\n\t\t_map[name] = attr;\n\t    }\n\t    catch (...)\n\t    {\n\t\tdelete attr;\n\t\tthrow;\n\t    }\n\t}\n    }\n}",
  "abstract_func": "void\nHeader::readFrom (OPENEXR_IMF_INTERNAL_NAMESPACE::IStream &VAR_0, int &VAR_1)\n{\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n    /* COMMENT_0 */\n\n    int VAR_2 = 0;\n\n    while (true)\n    {\n\t/* COMMENT_0 */\n\t/* COMMENT_2 */\n\t/* COMMENT_3 */\n\t/* COMMENT_0 */\n\n\tchar VAR_3[Name::SIZE];\n\tOPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::VAR_4 <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (VAR_0, Name::MAX_LENGTH, VAR_3);\n\n\tif (VAR_3[0] == 0)\n\t{\n\t    if (VAR_2 == 0) VAR_5 = true;\n\t    else                VAR_5 = false;\n\t    break;\n\t}\n\n\tVAR_2++;\n\n\tcheckIsNullTerminated (VAR_3, \"attribute name\");\n\n\t/* COMMENT_0 */\n\t/* COMMENT_4 */\n\t/* COMMENT_0 */\n\n\tchar VAR_6[Name::SIZE];\n\tint VAR_7;\n\n\tOPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::VAR_4 <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (VAR_0, Name::MAX_LENGTH, VAR_6);\n\tcheckIsNullTerminated (VAR_6, \"attribute type name\");\n\tOPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::VAR_4 <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (VAR_0, VAR_7);\n\n    if( VAR_7 < 0 )\n    {\n        throw IEX_NAMESPACE::InputExc(\"Invalid size field in header attribute\");\n    }\n\n\tAttributeMap::iterator VAR_8 = VAR_9.find (VAR_3);\n\n\tif (VAR_8 != VAR_9.end())\n\t{\n\t    /* COMMENT_0 */\n\t    /* COMMENT_5 */\n\t    /* COMMENT_6 */\n\t    /* COMMENT_7 */\n\t    /* COMMENT_0 */\n\n\t    if (strncmp (VAR_8->second->typeName(), VAR_6, sizeof (VAR_6)))\n\t\tTHROW (IEX_NAMESPACE::InputExc, \"Unexpected type for image attribute \"\n\t\t\t\t      \"\\\"\" << VAR_3 << \"\\\".\");\n\n\t    VAR_8->second->readValueFrom (VAR_0, VAR_7, VAR_1);\n\t}\n\telse\n\t{\n\t    /* COMMENT_0 */\n\t    /* COMMENT_8 */\n\t    /* COMMENT_9 */\n\t    /* COMMENT_10 */\n\t    /* COMMENT_11 */\n\t    /* COMMENT_12 */\n\t    /* COMMENT_0 */\n\n\t    Attribute *VAR_10;\n\n\t    if (Attribute::knownType (VAR_6))\n\t\tVAR_10 = Attribute::newAttribute (VAR_6);\n\t    else\n\t\tVAR_10 = new OpaqueAttribute (VAR_6);\n\n\t    try\n\t    {\n\t\tVAR_10->readValueFrom (VAR_0, VAR_7, VAR_1);\n\t\tVAR_9[VAR_3] = VAR_10;\n\t    }\n\t    catch (...)\n\t    {\n\t\tdelete VAR_10;\n\t\tthrow;\n\t    }\n\t}\n    }\n}",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -38,6 +38,11 @@\n \tOPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, Name::MAX_LENGTH, typeName);\n \tcheckIsNullTerminated (typeName, \"attribute type name\");\n \tOPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, size);\n+\n+    if( size < 0 )\n+    {\n+        throw IEX_NAMESPACE::InputExc(\"Invalid size field in header attribute\");\n+    }\n \n \tAttributeMap::iterator i = _map.find (name);\n ",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "",
      "    if( size < 0 )",
      "    {",
      "        throw IEX_NAMESPACE::InputExc(\"Invalid size field in header attribute\");",
      "    }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/AcademySoftwareFoundation/openexr/pull/436",
  "description": {
    "pr_info": {
      "title": "specific check for bad size field in header attributes (related to #248)",
      "number": 436
    },
    "comment": [
      "Throws a more intuitive error message if the size field of a header attribute is negative when reading the OpenEXR Header. On x86_64 architectures, all negative sizes previously caused a std::bad_alloc exception to be thrown, since negative values are treated as positive values bigger than the maximum addressable space. This change throws a clearer message."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis:\n- The commit message indicates a fix for a specific issue related to a bad size field in header attributes.\n- The code diff adds a check for a negative `size` value, throwing an exception if detected.\n- Before the patch, negative `size` values caused `std::bad_alloc`, which could be exploited to crash the system.\n- The fix prevents this by validating the `size` field, addressing a security vulnerability.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 1.0"
}