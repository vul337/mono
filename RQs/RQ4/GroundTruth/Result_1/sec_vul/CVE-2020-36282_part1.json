{
  "cve_id": "CVE-2020-36282",
  "cwe_ids": [
    "CWE-502"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "rabbitmq/rabbitmq-jms-client",
  "commit_msg": "Use trusted packages in StreamMessage\n\nStreamMessage now uses the same \"white list\" mechanism as\nObjectMessage to avoid some arbitrary code execution on deserialization.\n\nEven though StreamMessage is supposed to handle only primitive types,\nit is still to possible to send a message that contains an arbitrary\nserializable instance. The consuming application application may\nthen execute code from this class on deserialization.\n\nThe fix consists in using the list of trusted packages that can be\nset at the connection factory level.\n\nFixes #135",
  "commit_hash": "f647e5dbfe055a2ca8cbb16dd70f9d50d888b638",
  "git_url": "https://github.com/rabbitmq/rabbitmq-jms-client/commit/f647e5dbfe055a2ca8cbb16dd70f9d50d888b638",
  "file_path": "src/main/java/com/rabbitmq/jms/client/RMQMessage.java",
  "func_name": "instantiateRmqMessage",
  "func_before": "private static RMQMessage instantiateRmqMessage(String messageClass, List<String> trustedPackages) throws RMQJMSException {\n        if(isRmqObjectMessageClass(messageClass)) {\n            return instantiateRmqObjectMessageWithTrustedPackages(trustedPackages);\n        } else {\n            try {\n                // instantiate the message object with the thread context classloader\n                return (RMQMessage) Class.forName(messageClass, true, Thread.currentThread().getContextClassLoader()).getDeclaredConstructor().newInstance();\n            } catch (InstantiationException e) {\n                throw new RMQJMSException(e);\n            } catch (IllegalAccessException e) {\n                throw new RMQJMSException(e);\n            } catch (ClassNotFoundException e) {\n                throw new RMQJMSException(e);\n            } catch (NoSuchMethodException e) {\n                throw new RMQJMSException(e);\n            } catch (InvocationTargetException e) {\n                throw new RMQJMSException(e);\n            }\n        }\n    }",
  "abstract_func_before": "private static RMQMessage instantiateRmqMessage(String VAR_0, List<String> VAR_1) throws RMQJMSException {\n        if(isRmqObjectMessageClass(VAR_0)) {\n            return instantiateRmqObjectMessageWithTrustedPackages(VAR_1);\n        } else {\n            try {\n                /* COMMENT_0 */\n                return (RMQMessage) VAR_2.forName(VAR_0, true, VAR_3.currentThread().getContextClassLoader()).getDeclaredConstructor().newInstance();\n            } catch (InstantiationException VAR_4) {\n                throw new RMQJMSException(VAR_4);\n            } catch (IllegalAccessException VAR_4) {\n                throw new RMQJMSException(VAR_4);\n            } catch (ClassNotFoundException VAR_4) {\n                throw new RMQJMSException(VAR_4);\n            } catch (NoSuchMethodException VAR_4) {\n                throw new RMQJMSException(VAR_4);\n            } catch (InvocationTargetException VAR_4) {\n                throw new RMQJMSException(VAR_4);\n            }\n        }\n    }",
  "func_graph_path_before": "rabbitmq/rabbitmq-jms-client/f647e5dbfe055a2ca8cbb16dd70f9d50d888b638/RMQMessage.java/vul/before/0.json",
  "func": "private static RMQMessage instantiateRmqMessage(String messageClass, List<String> trustedPackages) throws RMQJMSException {\n        if(isRmqObjectMessageClass(messageClass)) {\n            return instantiateRmqObjectMessageWithTrustedPackages(trustedPackages);\n        } else if (isRmqStreamMessageClass(messageClass)) {\n            return instantiateRmqStreamMessageWithTrustedPackages(trustedPackages);\n        } else {\n            try {\n                // instantiate the message object with the thread context classloader\n                return (RMQMessage) Class.forName(messageClass, true, Thread.currentThread().getContextClassLoader()).getDeclaredConstructor().newInstance();\n            } catch (InstantiationException e) {\n                throw new RMQJMSException(e);\n            } catch (IllegalAccessException e) {\n                throw new RMQJMSException(e);\n            } catch (ClassNotFoundException e) {\n                throw new RMQJMSException(e);\n            } catch (NoSuchMethodException e) {\n                throw new RMQJMSException(e);\n            } catch (InvocationTargetException e) {\n                throw new RMQJMSException(e);\n            }\n        }\n    }",
  "abstract_func": "private static RMQMessage instantiateRmqMessage(String VAR_0, List<String> VAR_1) throws RMQJMSException {\n        if(isRmqObjectMessageClass(VAR_0)) {\n            return instantiateRmqObjectMessageWithTrustedPackages(VAR_1);\n        } else if (isRmqStreamMessageClass(VAR_0)) {\n            return instantiateRmqStreamMessageWithTrustedPackages(VAR_1);\n        } else {\n            try {\n                /* COMMENT_0 */\n                return (RMQMessage) VAR_2.forName(VAR_0, true, VAR_3.currentThread().getContextClassLoader()).getDeclaredConstructor().newInstance();\n            } catch (InstantiationException VAR_4) {\n                throw new RMQJMSException(VAR_4);\n            } catch (IllegalAccessException VAR_4) {\n                throw new RMQJMSException(VAR_4);\n            } catch (ClassNotFoundException VAR_4) {\n                throw new RMQJMSException(VAR_4);\n            } catch (NoSuchMethodException VAR_4) {\n                throw new RMQJMSException(VAR_4);\n            } catch (InvocationTargetException VAR_4) {\n                throw new RMQJMSException(VAR_4);\n            }\n        }\n    }",
  "func_graph_path": "rabbitmq/rabbitmq-jms-client/f647e5dbfe055a2ca8cbb16dd70f9d50d888b638/RMQMessage.java/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,8 @@\n private static RMQMessage instantiateRmqMessage(String messageClass, List<String> trustedPackages) throws RMQJMSException {\n         if(isRmqObjectMessageClass(messageClass)) {\n             return instantiateRmqObjectMessageWithTrustedPackages(trustedPackages);\n+        } else if (isRmqStreamMessageClass(messageClass)) {\n+            return instantiateRmqStreamMessageWithTrustedPackages(trustedPackages);\n         } else {\n             try {\n                 // instantiate the message object with the thread context classloader",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "        } else if (isRmqStreamMessageClass(messageClass)) {",
      "            return instantiateRmqStreamMessageWithTrustedPackages(trustedPackages);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/rabbitmq/rabbitmq-jms-client/pull/136",
  "description": {
    "pr_info": {
      "title": "Use trusted packages in StreamMessage",
      "number": 136
    },
    "comment": [
      "StreamMessage now uses the same \"white list\" mechanism as\r\nObjectMessage to avoid some arbitrary code execution on deserialization.\r\n\r\nEven though StreamMessage is supposed to handle only primitive types,\r\nit is still to possible to send a message that contains an arbitrary\r\nserializable instance. The consuming application application may\r\nthen execute code from this class on deserialization.\r\n\r\nThe fix consists in using the list of trusted packages that can be\r\nset at the connection factory level.\r\n\r\nFixes #135"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch modifies the StreamMessage class to use a whitelist mechanism, preventing arbitrary code execution during deserialization. The code change introduces a check for trusted packages, addressing a security vulnerability where untrusted serialized objects could execute malicious code.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 0.95"
}