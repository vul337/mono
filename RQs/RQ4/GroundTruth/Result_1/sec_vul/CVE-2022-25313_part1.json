{
  "cve_id": "CVE-2022-25313",
  "cwe_ids": [
    "CWE-674"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "libexpat",
  "commit_msg": "Prevent stack exhaustion in build_model\n\nIt is possible to trigger stack exhaustion in build_model function if\ndepth of nested children in DTD element is large enough. This happens\nbecause build_node is a recursively called function within build_model.\n\nThe code has been adjusted to run iteratively. It uses the already\nallocated heap space as temporary stack (growing from top to bottom).\n\nOutput is identical to recursive version. No new fields in data\nstructures were added, i.e. it keeps full API and ABI compatibility.\nInstead the numchildren variable is used to temporarily keep the\nindex of items (uint vs int).\n\nDocumentation and readability improvements kindly added by Sebastian.\n\nProof of Concept:\n\n1. Compile poc binary which parses XML file line by line\n\n```\ncat > poc.c << EOF\n #include <err.h>\n #include <expat.h>\n #include <stdio.h>\n\n XML_Parser parser;\n\n static void XMLCALL\n dummy_element_decl_handler(void *userData, const XML_Char *name,\n                            XML_Content *model) {\n   XML_FreeContentModel(parser, model);\n }\n\n int main(int argc, char *argv[]) {\n   FILE *fp;\n   char *p = NULL;\n   size_t s = 0;\n   ssize_t l;\n   if (argc != 2)\n     errx(1, \"usage: poc poc.xml\");\n   if ((parser = XML_ParserCreate(NULL)) == NULL)\n     errx(1, \"XML_ParserCreate\");\n   XML_SetElementDeclHandler(parser, dummy_element_decl_handler);\n   if ((fp = fopen(argv[1], \"r\")) == NULL)\n     err(1, \"fopen\");\n   while ((l = getline(&p, &s, fp)) > 0)\n     if (XML_Parse(parser, p, (int)l, XML_FALSE) != XML_STATUS_OK)\n       errx(1, \"XML_Parse\");\n   XML_ParserFree(parser);\n   free(p);\n   fclose(fp);\n   return 0;\n }\nEOF\ncc -std=c11 -D_POSIX_C_SOURCE=200809L -lexpat -o poc poc.c\n```\n\n2. Create XML file with a lot of nested groups in DTD element\n\n```\ncat > poc.xml.zst.b64 << EOF\nKLUv/aQkACAAPAEA+DwhRE9DVFlQRSB1d3UgWwo8IUVMRU1FTlQgdXd1CigBAHv/58AJAgAQKAIA\nECgCABAoAgAQKAIAECgCABAoAgAQKHwAAChvd28KKQIA2/8gV24XBAIAECkCABApAgAQKQIAECkC\nABApAgAQKQIAEClVAAAgPl0+CgEA4A4I2VwwnQ==\nEOF\nbase64 -d poc.xml.zst.b64 | zstd -d > poc.xml\n```\n\n3. Run Proof of Concept\n\n```\n./poc poc.xml\n```\n\nCo-authored-by: Sebastian Pipping <sebastian@pipping.org>",
  "commit_hash": "9b4ce651b26557f16103c3a366c91934ecd439ab",
  "git_url": "https://github.com/libexpat/libexpat/commit/9b4ce651b26557f16103c3a366c91934ecd439ab",
  "file_path": "expat/lib/xmlparse.c",
  "func_name": "build_model",
  "func_before": "static XML_Content *\nbuild_model(XML_Parser parser) {\n  DTD *const dtd = parser->m_dtd; /* save one level of indirection */\n  XML_Content *ret;\n  XML_Content *cpos;\n  XML_Char *str;\n\n  /* Detect and prevent integer overflow.\n   * The preprocessor guard addresses the \"always false\" warning\n   * from -Wtype-limits on platforms where\n   * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */\n#if UINT_MAX >= SIZE_MAX\n  if (dtd->scaffCount > (size_t)(-1) / sizeof(XML_Content)) {\n    return NULL;\n  }\n  if (dtd->contentStringLen > (size_t)(-1) / sizeof(XML_Char)) {\n    return NULL;\n  }\n#endif\n  if (dtd->scaffCount * sizeof(XML_Content)\n      > (size_t)(-1) - dtd->contentStringLen * sizeof(XML_Char)) {\n    return NULL;\n  }\n\n  const size_t allocsize = (dtd->scaffCount * sizeof(XML_Content)\n                            + (dtd->contentStringLen * sizeof(XML_Char)));\n\n  ret = (XML_Content *)MALLOC(parser, allocsize);\n  if (! ret)\n    return NULL;\n\n  str = (XML_Char *)(&ret[dtd->scaffCount]);\n  cpos = &ret[1];\n\n  build_node(parser, 0, ret, &cpos, &str);\n  return ret;\n}",
  "abstract_func_before": "static XML_Content *\nbuild_model(XML_Parser VAR_0) {\n  DTD *const VAR_1 = VAR_0->m_dtd; /* COMMENT_0 */\n  XML_Content *VAR_2;\n  XML_Content *VAR_3;\n  XML_Char *VAR_4;\n\n  /* COMMENT_1 */\n                                                                \n                                          \n                                                              \n#if VAR_5 >= VAR_6\n  if (VAR_1->scaffCount > (size_t)(-1) / sizeof(XML_Content)) {\n    return NULL;\n  }\n  if (VAR_1->contentStringLen > (size_t)(-1) / sizeof(XML_Char)) {\n    return NULL;\n  }\n#endif\n  if (VAR_1->scaffCount * sizeof(XML_Content)\n      > (size_t)(-1) - VAR_1->contentStringLen * sizeof(XML_Char)) {\n    return NULL;\n  }\n\n  const size_t VAR_7 = (VAR_1->scaffCount * sizeof(XML_Content)\n                            + (VAR_1->contentStringLen * sizeof(XML_Char)));\n\n  VAR_2 = (XML_Content *)MALLOC(VAR_0, VAR_7);\n  if (! VAR_2)\n    return NULL;\n\n  VAR_4 = (XML_Char *)(&VAR_2[VAR_1->scaffCount]);\n  VAR_3 = &VAR_2[1];\n\n  build_node(VAR_0, 0, VAR_2, &VAR_3, &VAR_4);\n  return VAR_2;\n}",
  "func_graph_path_before": "libexpat/9b4ce651b26557f16103c3a366c91934ecd439ab/xmlparse.c/vul/before/0.json",
  "func": "static XML_Content *\nbuild_model(XML_Parser parser) {\n  /* Function build_model transforms the existing parser->m_dtd->scaffold\n   * array of CONTENT_SCAFFOLD tree nodes into a new array of\n   * XML_Content tree nodes followed by a gapless list of zero-terminated\n   * strings. */\n  DTD *const dtd = parser->m_dtd; /* save one level of indirection */\n  XML_Content *ret;\n  XML_Char *str; /* the current string writing location */\n\n  /* Detect and prevent integer overflow.\n   * The preprocessor guard addresses the \"always false\" warning\n   * from -Wtype-limits on platforms where\n   * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */\n#if UINT_MAX >= SIZE_MAX\n  if (dtd->scaffCount > (size_t)(-1) / sizeof(XML_Content)) {\n    return NULL;\n  }\n  if (dtd->contentStringLen > (size_t)(-1) / sizeof(XML_Char)) {\n    return NULL;\n  }\n#endif\n  if (dtd->scaffCount * sizeof(XML_Content)\n      > (size_t)(-1) - dtd->contentStringLen * sizeof(XML_Char)) {\n    return NULL;\n  }\n\n  const size_t allocsize = (dtd->scaffCount * sizeof(XML_Content)\n                            + (dtd->contentStringLen * sizeof(XML_Char)));\n\n  ret = (XML_Content *)MALLOC(parser, allocsize);\n  if (! ret)\n    return NULL;\n\n  /* What follows is an iterative implementation (of what was previously done\n   * recursively in a dedicated function called \"build_node\".  The old recursive\n   * build_node could be forced into stack exhaustion from input as small as a\n   * few megabyte, and so that was a security issue.  Hence, a function call\n   * stack is avoided now by resolving recursion.)\n   *\n   * The iterative approach works as follows:\n   *\n   * - We use space in the target array for building a temporary stack structure\n   *   while that space is still unused.\n   *   The stack grows from the array's end downwards and the \"actual data\"\n   *   grows from the start upwards, sequentially.\n   *   (Because stack grows downwards, pushing onto the stack is a decrement\n   *   while popping off the stack is an increment.)\n   *\n   * - A stack element appears as a regular XML_Content node on the outside,\n   *   but only uses a single field -- numchildren -- to store the source\n   *   tree node array index.  These are the breadcrumbs leading the way back\n   *   during pre-order (node first) depth-first traversal.\n   *\n   * - The reason we know the stack will never grow into (or overlap with)\n   *   the area with data of value at the start of the array is because\n   *   the overall number of elements to process matches the size of the array,\n   *   and the sum of fully processed nodes and yet-to-be processed nodes\n   *   on the stack, cannot be more than the total number of nodes.\n   *   It is possible for the top of the stack and the about-to-write node\n   *   to meet, but that is safe because we get the source index out\n   *   before doing any writes on that node.\n   */\n  XML_Content *dest = ret; /* tree node writing location, moves upwards */\n  XML_Content *const destLimit = &ret[dtd->scaffCount];\n  XML_Content *const stackBottom = &ret[dtd->scaffCount];\n  XML_Content *stackTop = stackBottom; /* i.e. stack is initially empty */\n  str = (XML_Char *)&ret[dtd->scaffCount];\n\n  /* Push source tree root node index onto the stack */\n  (--stackTop)->numchildren = 0;\n\n  for (; dest < destLimit; dest++) {\n    /* Pop source tree node index off the stack */\n    const int src_node = (int)(stackTop++)->numchildren;\n\n    /* Convert item */\n    dest->type = dtd->scaffold[src_node].type;\n    dest->quant = dtd->scaffold[src_node].quant;\n    if (dest->type == XML_CTYPE_NAME) {\n      const XML_Char *src;\n      dest->name = str;\n      src = dtd->scaffold[src_node].name;\n      for (;;) {\n        *str++ = *src;\n        if (! *src)\n          break;\n        src++;\n      }\n      dest->numchildren = 0;\n      dest->children = NULL;\n    } else {\n      unsigned int i;\n      int cn;\n      dest->name = NULL;\n      dest->numchildren = dtd->scaffold[src_node].childcnt;\n      dest->children = &dest[1];\n\n      /* Push children to the stack\n       * in a way where the first child ends up at the top of the\n       * (downwards growing) stack, in order to be processed first. */\n      stackTop -= dest->numchildren;\n      for (i = 0, cn = dtd->scaffold[src_node].firstchild;\n           i < dest->numchildren; i++, cn = dtd->scaffold[cn].nextsib) {\n        (stackTop + i)->numchildren = (unsigned int)cn;\n      }\n    }\n  }\n\n  return ret;\n}",
  "abstract_func": "static XML_Content *\nbuild_model(XML_Parser VAR_0) {\n  /* COMMENT_0 */\n                                                             \n                                                                         \n                \n  DTD *const VAR_1 = VAR_0->m_dtd; /* COMMENT_4 */\n  XML_Content *VAR_2;\n  XML_Char *VAR_3; /* COMMENT_5 */\n\n  /* COMMENT_6 */\n                                                                \n                                          \n                                                              \n#if VAR_4 >= VAR_5\n  if (VAR_1->scaffCount > (size_t)(-1) / sizeof(XML_Content)) {\n    return NULL;\n  }\n  if (VAR_1->contentStringLen > (size_t)(-1) / sizeof(XML_Char)) {\n    return NULL;\n  }\n#endif\n  if (VAR_1->scaffCount * sizeof(XML_Content)\n      > (size_t)(-1) - VAR_1->contentStringLen * sizeof(XML_Char)) {\n    return NULL;\n  }\n\n  const size_t VAR_6 = (VAR_1->scaffCount * sizeof(XML_Content)\n                            + (VAR_1->contentStringLen * sizeof(XML_Char)));\n\n  VAR_2 = (XML_Content *)MALLOC(VAR_0, VAR_6);\n  if (! VAR_2)\n    return NULL;\n\n  /* COMMENT_10 */\n                                                                                \n                                                                              \n                                                                            \n                                                  \n    \n                                             \n    \n                                                                                \n                                        \n                                                                           \n                                                  \n                                                                            \n                                                    \n    \n                                                                            \n                                                                         \n                                                                             \n                                                           \n    \n                                                                          \n                                                                       \n                                                                               \n                                                                         \n                                                                   \n                                                                          \n                                                                    \n                                            \n     \n  XML_Content *VAR_7 = VAR_2; /* COMMENT_36 */\n  XML_Content *const VAR_8 = &VAR_2[VAR_1->scaffCount];\n  XML_Content *const VAR_9 = &VAR_2[VAR_1->scaffCount];\n  XML_Content *VAR_10 = VAR_9; /* COMMENT_37 */\n  VAR_3 = (XML_Char *)&VAR_2[VAR_1->scaffCount];\n\n  /* COMMENT_38 */\n  (--VAR_10)->numchildren = 0;\n\n  for (; VAR_7 < VAR_8; VAR_7++) {\n    /* COMMENT_39 */\n    const int VAR_11 = (int)(VAR_10++)->numchildren;\n\n    /* COMMENT_40 */\n    VAR_7->type = VAR_1->scaffold[VAR_11].type;\n    VAR_7->quant = VAR_1->scaffold[VAR_11].quant;\n    if (VAR_7->type == VAR_12) {\n      const XML_Char *VAR_13;\n      VAR_7->name = VAR_3;\n      VAR_13 = VAR_1->scaffold[VAR_11].name;\n      for (;;) {\n        *VAR_3++ = *VAR_13;\n        if (! *VAR_13)\n          break;\n        VAR_13++;\n      }\n      VAR_7->numchildren = 0;\n      VAR_7->children = NULL;\n    } else {\n      unsigned int VAR_14;\n      int VAR_15;\n      VAR_7->name = NULL;\n      VAR_7->numchildren = VAR_1->scaffold[VAR_11].childcnt;\n      VAR_7->children = &VAR_7[1];\n\n      /* COMMENT_41 */\n                                                                 \n                                                                      \n      VAR_10 -= VAR_7->numchildren;\n      for (VAR_14 = 0, VAR_15 = VAR_1->scaffold[VAR_11].firstchild;\n           VAR_14 < VAR_7->numchildren; VAR_14++, VAR_15 = VAR_1->scaffold[VAR_15].nextsib) {\n        (VAR_10 + VAR_14)->numchildren = (unsigned int)VAR_15;\n      }\n    }\n  }\n\n  return VAR_2;\n}",
  "func_graph_path": "libexpat/9b4ce651b26557f16103c3a366c91934ecd439ab/xmlparse.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,9 +1,12 @@\n static XML_Content *\n build_model(XML_Parser parser) {\n+  /* Function build_model transforms the existing parser->m_dtd->scaffold\n+   * array of CONTENT_SCAFFOLD tree nodes into a new array of\n+   * XML_Content tree nodes followed by a gapless list of zero-terminated\n+   * strings. */\n   DTD *const dtd = parser->m_dtd; /* save one level of indirection */\n   XML_Content *ret;\n-  XML_Content *cpos;\n-  XML_Char *str;\n+  XML_Char *str; /* the current string writing location */\n \n   /* Detect and prevent integer overflow.\n    * The preprocessor guard addresses the \"always false\" warning\n@@ -29,9 +32,80 @@\n   if (! ret)\n     return NULL;\n \n-  str = (XML_Char *)(&ret[dtd->scaffCount]);\n-  cpos = &ret[1];\n+  /* What follows is an iterative implementation (of what was previously done\n+   * recursively in a dedicated function called \"build_node\".  The old recursive\n+   * build_node could be forced into stack exhaustion from input as small as a\n+   * few megabyte, and so that was a security issue.  Hence, a function call\n+   * stack is avoided now by resolving recursion.)\n+   *\n+   * The iterative approach works as follows:\n+   *\n+   * - We use space in the target array for building a temporary stack structure\n+   *   while that space is still unused.\n+   *   The stack grows from the array's end downwards and the \"actual data\"\n+   *   grows from the start upwards, sequentially.\n+   *   (Because stack grows downwards, pushing onto the stack is a decrement\n+   *   while popping off the stack is an increment.)\n+   *\n+   * - A stack element appears as a regular XML_Content node on the outside,\n+   *   but only uses a single field -- numchildren -- to store the source\n+   *   tree node array index.  These are the breadcrumbs leading the way back\n+   *   during pre-order (node first) depth-first traversal.\n+   *\n+   * - The reason we know the stack will never grow into (or overlap with)\n+   *   the area with data of value at the start of the array is because\n+   *   the overall number of elements to process matches the size of the array,\n+   *   and the sum of fully processed nodes and yet-to-be processed nodes\n+   *   on the stack, cannot be more than the total number of nodes.\n+   *   It is possible for the top of the stack and the about-to-write node\n+   *   to meet, but that is safe because we get the source index out\n+   *   before doing any writes on that node.\n+   */\n+  XML_Content *dest = ret; /* tree node writing location, moves upwards */\n+  XML_Content *const destLimit = &ret[dtd->scaffCount];\n+  XML_Content *const stackBottom = &ret[dtd->scaffCount];\n+  XML_Content *stackTop = stackBottom; /* i.e. stack is initially empty */\n+  str = (XML_Char *)&ret[dtd->scaffCount];\n \n-  build_node(parser, 0, ret, &cpos, &str);\n+  /* Push source tree root node index onto the stack */\n+  (--stackTop)->numchildren = 0;\n+\n+  for (; dest < destLimit; dest++) {\n+    /* Pop source tree node index off the stack */\n+    const int src_node = (int)(stackTop++)->numchildren;\n+\n+    /* Convert item */\n+    dest->type = dtd->scaffold[src_node].type;\n+    dest->quant = dtd->scaffold[src_node].quant;\n+    if (dest->type == XML_CTYPE_NAME) {\n+      const XML_Char *src;\n+      dest->name = str;\n+      src = dtd->scaffold[src_node].name;\n+      for (;;) {\n+        *str++ = *src;\n+        if (! *src)\n+          break;\n+        src++;\n+      }\n+      dest->numchildren = 0;\n+      dest->children = NULL;\n+    } else {\n+      unsigned int i;\n+      int cn;\n+      dest->name = NULL;\n+      dest->numchildren = dtd->scaffold[src_node].childcnt;\n+      dest->children = &dest[1];\n+\n+      /* Push children to the stack\n+       * in a way where the first child ends up at the top of the\n+       * (downwards growing) stack, in order to be processed first. */\n+      stackTop -= dest->numchildren;\n+      for (i = 0, cn = dtd->scaffold[src_node].firstchild;\n+           i < dest->numchildren; i++, cn = dtd->scaffold[cn].nextsib) {\n+        (stackTop + i)->numchildren = (unsigned int)cn;\n+      }\n+    }\n+  }\n+\n   return ret;\n }",
  "diff_line_info": {
    "deleted_lines": [
      "  XML_Content *cpos;",
      "  XML_Char *str;",
      "  str = (XML_Char *)(&ret[dtd->scaffCount]);",
      "  cpos = &ret[1];",
      "  build_node(parser, 0, ret, &cpos, &str);"
    ],
    "added_lines": [
      "  /* Function build_model transforms the existing parser->m_dtd->scaffold",
      "   * array of CONTENT_SCAFFOLD tree nodes into a new array of",
      "   * XML_Content tree nodes followed by a gapless list of zero-terminated",
      "   * strings. */",
      "  XML_Char *str; /* the current string writing location */",
      "  /* What follows is an iterative implementation (of what was previously done",
      "   * recursively in a dedicated function called \"build_node\".  The old recursive",
      "   * build_node could be forced into stack exhaustion from input as small as a",
      "   * few megabyte, and so that was a security issue.  Hence, a function call",
      "   * stack is avoided now by resolving recursion.)",
      "   *",
      "   * The iterative approach works as follows:",
      "   *",
      "   * - We use space in the target array for building a temporary stack structure",
      "   *   while that space is still unused.",
      "   *   The stack grows from the array's end downwards and the \"actual data\"",
      "   *   grows from the start upwards, sequentially.",
      "   *   (Because stack grows downwards, pushing onto the stack is a decrement",
      "   *   while popping off the stack is an increment.)",
      "   *",
      "   * - A stack element appears as a regular XML_Content node on the outside,",
      "   *   but only uses a single field -- numchildren -- to store the source",
      "   *   tree node array index.  These are the breadcrumbs leading the way back",
      "   *   during pre-order (node first) depth-first traversal.",
      "   *",
      "   * - The reason we know the stack will never grow into (or overlap with)",
      "   *   the area with data of value at the start of the array is because",
      "   *   the overall number of elements to process matches the size of the array,",
      "   *   and the sum of fully processed nodes and yet-to-be processed nodes",
      "   *   on the stack, cannot be more than the total number of nodes.",
      "   *   It is possible for the top of the stack and the about-to-write node",
      "   *   to meet, but that is safe because we get the source index out",
      "   *   before doing any writes on that node.",
      "   */",
      "  XML_Content *dest = ret; /* tree node writing location, moves upwards */",
      "  XML_Content *const destLimit = &ret[dtd->scaffCount];",
      "  XML_Content *const stackBottom = &ret[dtd->scaffCount];",
      "  XML_Content *stackTop = stackBottom; /* i.e. stack is initially empty */",
      "  str = (XML_Char *)&ret[dtd->scaffCount];",
      "  /* Push source tree root node index onto the stack */",
      "  (--stackTop)->numchildren = 0;",
      "",
      "  for (; dest < destLimit; dest++) {",
      "    /* Pop source tree node index off the stack */",
      "    const int src_node = (int)(stackTop++)->numchildren;",
      "",
      "    /* Convert item */",
      "    dest->type = dtd->scaffold[src_node].type;",
      "    dest->quant = dtd->scaffold[src_node].quant;",
      "    if (dest->type == XML_CTYPE_NAME) {",
      "      const XML_Char *src;",
      "      dest->name = str;",
      "      src = dtd->scaffold[src_node].name;",
      "      for (;;) {",
      "        *str++ = *src;",
      "        if (! *src)",
      "          break;",
      "        src++;",
      "      }",
      "      dest->numchildren = 0;",
      "      dest->children = NULL;",
      "    } else {",
      "      unsigned int i;",
      "      int cn;",
      "      dest->name = NULL;",
      "      dest->numchildren = dtd->scaffold[src_node].childcnt;",
      "      dest->children = &dest[1];",
      "",
      "      /* Push children to the stack",
      "       * in a way where the first child ends up at the top of the",
      "       * (downwards growing) stack, in order to be processed first. */",
      "      stackTop -= dest->numchildren;",
      "      for (i = 0, cn = dtd->scaffold[src_node].firstchild;",
      "           i < dest->numchildren; i++, cn = dtd->scaffold[cn].nextsib) {",
      "        (stackTop + i)->numchildren = (unsigned int)cn;",
      "      }",
      "    }",
      "  }",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libexpat/libexpat/pull/558",
  "description": {
    "pr_info": {
      "title": "[CVE-2022-25313] lib: Prevent stack exhaustion in build_model",
      "number": 558
    },
    "comment": [
      "It is possible to trigger stack exhaustion in build_model function if\r\ndepth of nested children in DTD element is large enough. This happens\r\nbecause build_node is a recursively called function within build_model.\r\n\r\nThe code has been adjusted to run iteratively. It uses the already\r\nallocated heap space as temporary stack (growing from top to bottom).\r\n\r\nOutput is identical to recursive version. No new fields in data\r\nstructures were added, i.e. it keeps full API and ABI compatibility.\r\nInstead the numchildren variable is used to temporarily keep the\r\nindex of items (uint vs int).\r\n\r\nDocumentation and readability improvements kindly added by Sebastian.\r\n\r\nProof of Concept:\r\n\r\n1. Compile poc binary which parses XML file line by line\r\n\r\n```\r\ncat > poc.c << EOF\r\n #include <err.h>\r\n #include <expat.h>\r\n #include <stdio.h>\r\n\r\n XML_Parser parser;\r\n\r\n static void XMLCALL\r\n dummy_element_decl_handler(void *userData, const XML_Char *name,\r\n                            XML_Content *model) {\r\n   XML_FreeContentModel(parser, model);\r\n }\r\n\r\n int main(int argc, char *argv[]) {\r\n   FILE *fp;\r\n   char *p = NULL;\r\n   size_t s = 0;\r\n   ssize_t l;\r\n   if (argc != 2)\r\n     errx(1, \"usage: poc poc.xml\");\r\n   if ((parser = XML_ParserCreate(NULL)) == NULL)\r\n     errx(1, \"XML_ParserCreate\");\r\n   XML_SetElementDeclHandler(parser, dummy_element_decl_handler);\r\n   if ((fp = fopen(argv[1], \"r\")) == NULL)\r\n     err(1, \"fopen\");\r\n   while ((l = getline(&p, &s, fp)) > 0)\r\n     if (XML_Parse(parser, p, (int)l, XML_FALSE) != XML_STATUS_OK)\r\n       errx(1, \"XML_Parse\");\r\n   XML_ParserFree(parser);\r\n   free(p);\r\n   fclose(fp);\r\n   return 0;\r\n }\r\nEOF\r\ncc -std=c11 -D_POSIX_C_SOURCE=200809L -lexpat -o poc poc.c\r\n```\r\n\r\n2. Create XML file with a lot of nested groups in DTD element\r\n\r\n```\r\ncat > poc.xml.zst.b64 << EOF\r\nKLUv/aQkACAAPAEA+DwhRE9DVFlQRSB1d3UgWwo8IUVMRU1FTlQgdXd1CigBAHv/58AJAgAQKAIA\r\nECgCABAoAgAQKAIAECgCABAoAgAQKHwAAChvd28KKQIA2/8gV24XBAIAECkCABApAgAQKQIAECkC\r\nABApAgAQKQIAEClVAAAgPl0+CgEA4A4I2VwwnQ==\r\nEOF\r\nbase64 -d poc.xml.zst.b64 | zstd -d > poc.xml\r\n```\r\n\r\n3. Run Proof of Concept\r\n\r\n```\r\n./poc poc.xml\r\n```\r\n\r\nCo-authored-by: Sebastian Pipping <sebastian@pipping.org>",
      "This appears to be [CVE-2022-25313](https://www.cve.org/CVERecord?id=CVE-2022-25313)"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix\n\nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch modifies the `build_model` function to prevent stack exhaustion caused by deep recursion when handling nested XML elements. The fix replaces recursion with an iterative approach using heap space as a temporary stack, addressing a denial-of-service vulnerability. The proof of concept provided demonstrates exploitability, confirming the security relevance.\n\nFinal Classification: Security Vulnerability Fix\n\nConfidence Score: 0.95"
}