{
  "cve_id": "CVE-2022-24301",
  "cwe_ids": [
    "CWE-276"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "minetest",
  "commit_msg": "Prevent players accessing inventories of other players (#10341)",
  "commit_hash": "3693b6871eba268ecc79b3f52d00d3cefe761131",
  "git_url": "https://github.com/minetest/minetest/commit/3693b6871eba268ecc79b3f52d00d3cefe761131",
  "file_path": "src/network/serverpackethandler.cpp",
  "func_name": "Server::handleCommand_InventoryAction",
  "func_before": "void Server::handleCommand_InventoryAction(NetworkPacket* pkt)\n{\n\tsession_t peer_id = pkt->getPeerId();\n\tRemotePlayer *player = m_env->getPlayer(peer_id);\n\n\tif (player == NULL) {\n\t\terrorstream <<\n\t\t\t\"Server::ProcessData(): Canceling: No player for peer_id=\" <<\n\t\t\tpeer_id << \" disconnecting peer!\" << std::endl;\n\t\tDisconnectPeer(peer_id);\n\t\treturn;\n\t}\n\n\tPlayerSAO *playersao = player->getPlayerSAO();\n\tif (playersao == NULL) {\n\t\terrorstream <<\n\t\t\t\"Server::ProcessData(): Canceling: No player object for peer_id=\" <<\n\t\t\tpeer_id << \" disconnecting peer!\" << std::endl;\n\t\tDisconnectPeer(peer_id);\n\t\treturn;\n\t}\n\n\t// Strip command and create a stream\n\tstd::string datastring(pkt->getString(0), pkt->getSize());\n\tverbosestream << \"TOSERVER_INVENTORY_ACTION: data=\" << datastring\n\t\t<< std::endl;\n\tstd::istringstream is(datastring, std::ios_base::binary);\n\t// Create an action\n\tInventoryAction *a = InventoryAction::deSerialize(is);\n\tif (!a) {\n\t\tinfostream << \"TOSERVER_INVENTORY_ACTION: \"\n\t\t\t\t<< \"InventoryAction::deSerialize() returned NULL\"\n\t\t\t\t<< std::endl;\n\t\treturn;\n\t}\n\n\t// If something goes wrong, this player is to blame\n\tRollbackScopeActor rollback_scope(m_rollback,\n\t\t\tstd::string(\"player:\")+player->getName());\n\n\t/*\n\t\tNote: Always set inventory not sent, to repair cases\n\t\twhere the client made a bad prediction.\n\t*/\n\n\t/*\n\t\tHandle restrictions and special cases of the move action\n\t*/\n\tif (a->getType() == IAction::Move) {\n\t\tIMoveAction *ma = (IMoveAction*)a;\n\n\t\tma->from_inv.applyCurrentPlayer(player->getName());\n\t\tma->to_inv.applyCurrentPlayer(player->getName());\n\n\t\tm_inventory_mgr->setInventoryModified(ma->from_inv);\n\t\tif (ma->from_inv != ma->to_inv)\n\t\t\tm_inventory_mgr->setInventoryModified(ma->to_inv);\n\n\t\tbool from_inv_is_current_player =\n\t\t\t(ma->from_inv.type == InventoryLocation::PLAYER) &&\n\t\t\t(ma->from_inv.name == player->getName());\n\n\t\tbool to_inv_is_current_player =\n\t\t\t(ma->to_inv.type == InventoryLocation::PLAYER) &&\n\t\t\t(ma->to_inv.name == player->getName());\n\n\t\tInventoryLocation *remote = from_inv_is_current_player ?\n\t\t\t&ma->to_inv : &ma->from_inv;\n\n\t\t// Check for out-of-range interaction\n\t\tif (remote->type == InventoryLocation::NODEMETA) {\n\t\t\tv3f node_pos   = intToFloat(remote->p, BS);\n\t\t\tv3f player_pos = player->getPlayerSAO()->getEyePosition();\n\t\t\tf32 d = player_pos.getDistanceFrom(node_pos);\n\t\t\tif (!checkInteractDistance(player, d, \"inventory\"))\n\t\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t\tDisable moving items out of craftpreview\n\t\t*/\n\t\tif (ma->from_list == \"craftpreview\") {\n\t\t\tinfostream << \"Ignoring IMoveAction from \"\n\t\t\t\t\t<< (ma->from_inv.dump()) << \":\" << ma->from_list\n\t\t\t\t\t<< \" to \" << (ma->to_inv.dump()) << \":\" << ma->to_list\n\t\t\t\t\t<< \" because src is \" << ma->from_list << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t\tDisable moving items into craftresult and craftpreview\n\t\t*/\n\t\tif (ma->to_list == \"craftpreview\" || ma->to_list == \"craftresult\") {\n\t\t\tinfostream << \"Ignoring IMoveAction from \"\n\t\t\t\t\t<< (ma->from_inv.dump()) << \":\" << ma->from_list\n\t\t\t\t\t<< \" to \" << (ma->to_inv.dump()) << \":\" << ma->to_list\n\t\t\t\t\t<< \" because dst is \" << ma->to_list << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\n\t\t// Disallow moving items in elsewhere than player's inventory\n\t\t// if not allowed to interact\n\t\tif (!checkPriv(player->getName(), \"interact\") &&\n\t\t\t\t(!from_inv_is_current_player ||\n\t\t\t\t!to_inv_is_current_player)) {\n\t\t\tinfostream << \"Cannot move outside of player's inventory: \"\n\t\t\t\t\t<< \"No interact privilege\" << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\t}\n\t/*\n\t\tHandle restrictions and special cases of the drop action\n\t*/\n\telse if (a->getType() == IAction::Drop) {\n\t\tIDropAction *da = (IDropAction*)a;\n\n\t\tda->from_inv.applyCurrentPlayer(player->getName());\n\n\t\tm_inventory_mgr->setInventoryModified(da->from_inv);\n\n\t\t/*\n\t\t\tDisable dropping items out of craftpreview\n\t\t*/\n\t\tif (da->from_list == \"craftpreview\") {\n\t\t\tinfostream << \"Ignoring IDropAction from \"\n\t\t\t\t\t<< (da->from_inv.dump()) << \":\" << da->from_list\n\t\t\t\t\t<< \" because src is \" << da->from_list << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\n\t\t// Disallow dropping items if not allowed to interact\n\t\tif (!checkPriv(player->getName(), \"interact\")) {\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\n\t\t// Disallow dropping items if dead\n\t\tif (playersao->isDead()) {\n\t\t\tinfostream << \"Ignoring IDropAction from \"\n\t\t\t\t\t<< (da->from_inv.dump()) << \":\" << da->from_list\n\t\t\t\t\t<< \" because player is dead.\" << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\t}\n\t/*\n\t\tHandle restrictions and special cases of the craft action\n\t*/\n\telse if (a->getType() == IAction::Craft) {\n\t\tICraftAction *ca = (ICraftAction*)a;\n\n\t\tca->craft_inv.applyCurrentPlayer(player->getName());\n\n\t\tm_inventory_mgr->setInventoryModified(ca->craft_inv);\n\n\t\t//bool craft_inv_is_current_player =\n\t\t//\t(ca->craft_inv.type == InventoryLocation::PLAYER) &&\n\t\t//\t(ca->craft_inv.name == player->getName());\n\n\t\t// Disallow crafting if not allowed to interact\n\t\tif (!checkPriv(player->getName(), \"interact\")) {\n\t\t\tinfostream << \"Cannot craft: \"\n\t\t\t\t\t<< \"No interact privilege\" << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// Do the action\n\ta->apply(m_inventory_mgr.get(), playersao, this);\n\t// Eat the action\n\tdelete a;\n}",
  "abstract_func_before": "void Server::handleCommand_InventoryAction(NetworkPacket* VAR_0)\n{\n\tsession_t VAR_1 = VAR_0->getPeerId();\n\tRemotePlayer *VAR_2 = VAR_3->getPlayer(VAR_1);\n\n\tif (VAR_2 == NULL) {\n\t\tVAR_4 <<\n\t\t\t\"Server::ProcessData(): Canceling: No player for peer_id=\" <<\n\t\t\tVAR_1 << \" disconnecting peer!\" << std::endl;\n\t\tDisconnectPeer(VAR_1);\n\t\treturn;\n\t}\n\n\tPlayerSAO *VAR_5 = VAR_2->getPlayerSAO();\n\tif (VAR_5 == NULL) {\n\t\tVAR_4 <<\n\t\t\t\"Server::ProcessData(): Canceling: No player object for peer_id=\" <<\n\t\t\tVAR_1 << \" disconnecting peer!\" << std::endl;\n\t\tDisconnectPeer(VAR_1);\n\t\treturn;\n\t}\n\n\t/* COMMENT_0 */\n\tstd::string VAR_6(VAR_0->getString(0), VAR_0->getSize());\n\tVAR_7 << \"TOSERVER_INVENTORY_ACTION: data=\" << VAR_6\n\t\t<< std::endl;\n\tstd::istringstream is(datastring, std::ios_base::binary);\n\t/* COMMENT_1 */\n\tInventoryAction *VAR_8 = InventoryAction::deSerialize(VAR_9);\n\tif (!VAR_8) {\n\t\tVAR_10 << \"TOSERVER_INVENTORY_ACTION: \"\n\t\t\t\t<< \"InventoryAction::deSerialize() returned NULL\"\n\t\t\t\t<< std::endl;\n\t\treturn;\n\t}\n\n\t/* COMMENT_2 */\n\tRollbackScopeActor VAR_11(VAR_12,\n\t\t\tstd::string(\"player:\")+VAR_2->getName());\n\n\t/* COMMENT_3 */\n                                                      \n                                         \n   \n\n\t/* COMMENT_7 */\n                                                          \n   \n\tif (VAR_8->getType() == IAction::Move) {\n\t\tIMoveAction *VAR_13 = (IMoveAction*)VAR_8;\n\n\t\tVAR_13->from_inv.applyCurrentPlayer(VAR_2->getName());\n\t\tVAR_13->to_inv.applyCurrentPlayer(VAR_2->getName());\n\n\t\tVAR_14->setInventoryModified(VAR_13->from_inv);\n\t\tif (VAR_13->from_inv != VAR_13->to_inv)\n\t\t\tVAR_14->setInventoryModified(VAR_13->to_inv);\n\n\t\tbool VAR_15 =\n\t\t\t(VAR_13->from_inv.type == InventoryLocation::PLAYER) &&\n\t\t\t(VAR_13->from_inv.name == VAR_2->getName());\n\n\t\tbool VAR_16 =\n\t\t\t(VAR_13->to_inv.type == InventoryLocation::PLAYER) &&\n\t\t\t(VAR_13->to_inv.name == VAR_2->getName());\n\n\t\tInventoryLocation *VAR_17 = VAR_15 ?\n\t\t\t&VAR_13->to_inv : &VAR_13->from_inv;\n\n\t\t/* COMMENT_10 */\n\t\tif (VAR_17->type == InventoryLocation::NODEMETA) {\n\t\t\tv3f VAR_18   = intToFloat(VAR_17->p, VAR_19);\n\t\t\tv3f VAR_20 = VAR_2->getPlayerSAO()->getEyePosition();\n\t\t\tf32 VAR_21 = VAR_20.getDistanceFrom(VAR_18);\n\t\t\tif (!checkInteractDistance(VAR_2, VAR_21, \"inventory\"))\n\t\t\t\treturn;\n\t\t}\n\n\t\t/* COMMENT_11 */\n                                           \n    \n\t\tif (VAR_13->from_list == \"craftpreview\") {\n\t\t\tVAR_10 << \"Ignoring IMoveAction from \"\n\t\t\t\t\t<< (VAR_13->from_inv.dump()) << \":\" << VAR_13->from_list\n\t\t\t\t\t<< \" to \" << (VAR_13->to_inv.dump()) << \":\" << VAR_13->to_list\n\t\t\t\t\t<< \" because src is \" << VAR_13->from_list << std::endl;\n\t\t\tdelete VAR_8;\n\t\t\treturn;\n\t\t}\n\n\t\t/* COMMENT_14 */\n                                                         \n    \n\t\tif (VAR_13->to_list == \"craftpreview\" || VAR_13->to_list == \"craftresult\") {\n\t\t\tVAR_10 << \"Ignoring IMoveAction from \"\n\t\t\t\t\t<< (VAR_13->from_inv.dump()) << \":\" << VAR_13->from_list\n\t\t\t\t\t<< \" to \" << (VAR_13->to_inv.dump()) << \":\" << VAR_13->to_list\n\t\t\t\t\t<< \" because dst is \" << VAR_13->to_list << std::endl;\n\t\t\tdelete VAR_8;\n\t\t\treturn;\n\t\t}\n\n\t\t/* COMMENT_17 */\n\t\t/* COMMENT_18 */\n\t\tif (!checkPriv(VAR_2->getName(), \"interact\") &&\n\t\t\t\t(!VAR_15 ||\n\t\t\t\t!VAR_16)) {\n\t\t\tVAR_10 << \"Cannot move outside of player's inventory: \"\n\t\t\t\t\t<< \"No interact privilege\" << std::endl;\n\t\t\tdelete VAR_8;\n\t\t\treturn;\n\t\t}\n\t}\n\t/* COMMENT_19 */\n                                                          \n   \n\telse if (VAR_8->getType() == IAction::Drop) {\n\t\tIDropAction *VAR_22 = (IDropAction*)VAR_8;\n\n\t\tVAR_22->from_inv.applyCurrentPlayer(VAR_2->getName());\n\n\t\tVAR_14->setInventoryModified(VAR_22->from_inv);\n\n\t\t/* COMMENT_22 */\n                                             \n    \n\t\tif (VAR_22->from_list == \"craftpreview\") {\n\t\t\tVAR_10 << \"Ignoring IDropAction from \"\n\t\t\t\t\t<< (VAR_22->from_inv.dump()) << \":\" << VAR_22->from_list\n\t\t\t\t\t<< \" because src is \" << VAR_22->from_list << std::endl;\n\t\t\tdelete VAR_8;\n\t\t\treturn;\n\t\t}\n\n\t\t/* COMMENT_25 */\n\t\tif (!checkPriv(VAR_2->getName(), \"interact\")) {\n\t\t\tdelete VAR_8;\n\t\t\treturn;\n\t\t}\n\n\t\t/* COMMENT_26 */\n\t\tif (VAR_5->isDead()) {\n\t\t\tVAR_10 << \"Ignoring IDropAction from \"\n\t\t\t\t\t<< (VAR_22->from_inv.dump()) << \":\" << VAR_22->from_list\n\t\t\t\t\t<< \" because player is dead.\" << std::endl;\n\t\t\tdelete VAR_8;\n\t\t\treturn;\n\t\t}\n\t}\n\t/* COMMENT_27 */\n                                                           \n   \n\telse if (VAR_8->getType() == IAction::Craft) {\n\t\tICraftAction *VAR_23 = (ICraftAction*)VAR_8;\n\n\t\tVAR_23->craft_inv.applyCurrentPlayer(VAR_2->getName());\n\n\t\tVAR_14->setInventoryModified(VAR_23->craft_inv);\n\n\t\t/* COMMENT_30 */\n\t\t/* COMMENT_31 */\n\t\t/* COMMENT_32 */\n\n\t\t/* COMMENT_33 */\n\t\tif (!checkPriv(VAR_2->getName(), \"interact\")) {\n\t\t\tVAR_10 << \"Cannot craft: \"\n\t\t\t\t\t<< \"No interact privilege\" << std::endl;\n\t\t\tdelete VAR_8;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* COMMENT_34 */\n\tVAR_8->apply(VAR_14.get(), VAR_5, this);\n\t/* COMMENT_35 */\n\tdelete VAR_8;\n}",
  "func_graph_path_before": "minetest/3693b6871eba268ecc79b3f52d00d3cefe761131/serverpackethandler.cpp/vul/before/0.json",
  "func": "void Server::handleCommand_InventoryAction(NetworkPacket* pkt)\n{\n\tsession_t peer_id = pkt->getPeerId();\n\tRemotePlayer *player = m_env->getPlayer(peer_id);\n\n\tif (player == NULL) {\n\t\terrorstream <<\n\t\t\t\"Server::ProcessData(): Canceling: No player for peer_id=\" <<\n\t\t\tpeer_id << \" disconnecting peer!\" << std::endl;\n\t\tDisconnectPeer(peer_id);\n\t\treturn;\n\t}\n\n\tPlayerSAO *playersao = player->getPlayerSAO();\n\tif (playersao == NULL) {\n\t\terrorstream <<\n\t\t\t\"Server::ProcessData(): Canceling: No player object for peer_id=\" <<\n\t\t\tpeer_id << \" disconnecting peer!\" << std::endl;\n\t\tDisconnectPeer(peer_id);\n\t\treturn;\n\t}\n\n\t// Strip command and create a stream\n\tstd::string datastring(pkt->getString(0), pkt->getSize());\n\tverbosestream << \"TOSERVER_INVENTORY_ACTION: data=\" << datastring\n\t\t<< std::endl;\n\tstd::istringstream is(datastring, std::ios_base::binary);\n\t// Create an action\n\tInventoryAction *a = InventoryAction::deSerialize(is);\n\tif (!a) {\n\t\tinfostream << \"TOSERVER_INVENTORY_ACTION: \"\n\t\t\t\t<< \"InventoryAction::deSerialize() returned NULL\"\n\t\t\t\t<< std::endl;\n\t\treturn;\n\t}\n\n\t// If something goes wrong, this player is to blame\n\tRollbackScopeActor rollback_scope(m_rollback,\n\t\t\tstd::string(\"player:\")+player->getName());\n\n\t/*\n\t\tNote: Always set inventory not sent, to repair cases\n\t\twhere the client made a bad prediction.\n\t*/\n\n\t/*\n\t\tHandle restrictions and special cases of the move action\n\t*/\n\tif (a->getType() == IAction::Move) {\n\t\tIMoveAction *ma = (IMoveAction*)a;\n\n\t\tma->from_inv.applyCurrentPlayer(player->getName());\n\t\tma->to_inv.applyCurrentPlayer(player->getName());\n\n\t\tm_inventory_mgr->setInventoryModified(ma->from_inv);\n\t\tif (ma->from_inv != ma->to_inv)\n\t\t\tm_inventory_mgr->setInventoryModified(ma->to_inv);\n\n\t\tbool from_inv_is_current_player = false;\n\t\tif (ma->from_inv.type == InventoryLocation::PLAYER) {\n\t\t\tif (ma->from_inv.name != player->getName())\n\t\t\t\treturn;\n\t\t\tfrom_inv_is_current_player = true;\n\t\t}\n\t\t\n\t\tbool to_inv_is_current_player = false;\n\t\tif (ma->to_inv.type == InventoryLocation::PLAYER) {\n\t\t\tif (ma->to_inv.name != player->getName())\n\t\t\t\treturn;\n\t\t\tto_inv_is_current_player = true;\n\t\t}\n\n\t\tInventoryLocation *remote = from_inv_is_current_player ?\n\t\t\t&ma->to_inv : &ma->from_inv;\n\n\t\t// Check for out-of-range interaction\n\t\tif (remote->type == InventoryLocation::NODEMETA) {\n\t\t\tv3f node_pos   = intToFloat(remote->p, BS);\n\t\t\tv3f player_pos = player->getPlayerSAO()->getEyePosition();\n\t\t\tf32 d = player_pos.getDistanceFrom(node_pos);\n\t\t\tif (!checkInteractDistance(player, d, \"inventory\"))\n\t\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t\tDisable moving items out of craftpreview\n\t\t*/\n\t\tif (ma->from_list == \"craftpreview\") {\n\t\t\tinfostream << \"Ignoring IMoveAction from \"\n\t\t\t\t\t<< (ma->from_inv.dump()) << \":\" << ma->from_list\n\t\t\t\t\t<< \" to \" << (ma->to_inv.dump()) << \":\" << ma->to_list\n\t\t\t\t\t<< \" because src is \" << ma->from_list << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t\tDisable moving items into craftresult and craftpreview\n\t\t*/\n\t\tif (ma->to_list == \"craftpreview\" || ma->to_list == \"craftresult\") {\n\t\t\tinfostream << \"Ignoring IMoveAction from \"\n\t\t\t\t\t<< (ma->from_inv.dump()) << \":\" << ma->from_list\n\t\t\t\t\t<< \" to \" << (ma->to_inv.dump()) << \":\" << ma->to_list\n\t\t\t\t\t<< \" because dst is \" << ma->to_list << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\n\t\t// Disallow moving items in elsewhere than player's inventory\n\t\t// if not allowed to interact\n\t\tif (!checkPriv(player->getName(), \"interact\") &&\n\t\t\t\t(!from_inv_is_current_player ||\n\t\t\t\t!to_inv_is_current_player)) {\n\t\t\tinfostream << \"Cannot move outside of player's inventory: \"\n\t\t\t\t\t<< \"No interact privilege\" << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\t}\n\t/*\n\t\tHandle restrictions and special cases of the drop action\n\t*/\n\telse if (a->getType() == IAction::Drop) {\n\t\tIDropAction *da = (IDropAction*)a;\n\n\t\tda->from_inv.applyCurrentPlayer(player->getName());\n\n\t\tm_inventory_mgr->setInventoryModified(da->from_inv);\n\n\t\t/*\n\t\t\tDisable dropping items out of craftpreview\n\t\t*/\n\t\tif (da->from_list == \"craftpreview\") {\n\t\t\tinfostream << \"Ignoring IDropAction from \"\n\t\t\t\t\t<< (da->from_inv.dump()) << \":\" << da->from_list\n\t\t\t\t\t<< \" because src is \" << da->from_list << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\n\t\t// Disallow dropping items if not allowed to interact\n\t\tif (!checkPriv(player->getName(), \"interact\")) {\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\n\t\t// Disallow dropping items if dead\n\t\tif (playersao->isDead()) {\n\t\t\tinfostream << \"Ignoring IDropAction from \"\n\t\t\t\t\t<< (da->from_inv.dump()) << \":\" << da->from_list\n\t\t\t\t\t<< \" because player is dead.\" << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\t}\n\t/*\n\t\tHandle restrictions and special cases of the craft action\n\t*/\n\telse if (a->getType() == IAction::Craft) {\n\t\tICraftAction *ca = (ICraftAction*)a;\n\n\t\tca->craft_inv.applyCurrentPlayer(player->getName());\n\n\t\tm_inventory_mgr->setInventoryModified(ca->craft_inv);\n\n\t\t//bool craft_inv_is_current_player =\n\t\t//\t(ca->craft_inv.type == InventoryLocation::PLAYER) &&\n\t\t//\t(ca->craft_inv.name == player->getName());\n\n\t\t// Disallow crafting if not allowed to interact\n\t\tif (!checkPriv(player->getName(), \"interact\")) {\n\t\t\tinfostream << \"Cannot craft: \"\n\t\t\t\t\t<< \"No interact privilege\" << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// Do the action\n\ta->apply(m_inventory_mgr.get(), playersao, this);\n\t// Eat the action\n\tdelete a;\n}",
  "abstract_func": "void Server::handleCommand_InventoryAction(NetworkPacket* VAR_0)\n{\n\tsession_t VAR_1 = VAR_0->getPeerId();\n\tRemotePlayer *VAR_2 = VAR_3->getPlayer(VAR_1);\n\n\tif (VAR_2 == NULL) {\n\t\tVAR_4 <<\n\t\t\t\"Server::ProcessData(): Canceling: No player for peer_id=\" <<\n\t\t\tVAR_1 << \" disconnecting peer!\" << std::endl;\n\t\tDisconnectPeer(VAR_1);\n\t\treturn;\n\t}\n\n\tPlayerSAO *VAR_5 = VAR_2->getPlayerSAO();\n\tif (VAR_5 == NULL) {\n\t\tVAR_4 <<\n\t\t\t\"Server::ProcessData(): Canceling: No player object for peer_id=\" <<\n\t\t\tVAR_1 << \" disconnecting peer!\" << std::endl;\n\t\tDisconnectPeer(VAR_1);\n\t\treturn;\n\t}\n\n\t/* COMMENT_0 */\n\tstd::string VAR_6(VAR_0->getString(0), VAR_0->getSize());\n\tVAR_7 << \"TOSERVER_INVENTORY_ACTION: data=\" << VAR_6\n\t\t<< std::endl;\n\tstd::istringstream is(datastring, std::ios_base::binary);\n\t/* COMMENT_1 */\n\tInventoryAction *VAR_8 = InventoryAction::deSerialize(VAR_9);\n\tif (!VAR_8) {\n\t\tVAR_10 << \"TOSERVER_INVENTORY_ACTION: \"\n\t\t\t\t<< \"InventoryAction::deSerialize() returned NULL\"\n\t\t\t\t<< std::endl;\n\t\treturn;\n\t}\n\n\t/* COMMENT_2 */\n\tRollbackScopeActor VAR_11(VAR_12,\n\t\t\tstd::string(\"player:\")+VAR_2->getName());\n\n\t/* COMMENT_3 */\n                                                      \n                                         \n   \n\n\t/* COMMENT_7 */\n                                                          \n   \n\tif (VAR_8->getType() == IAction::Move) {\n\t\tIMoveAction *VAR_13 = (IMoveAction*)VAR_8;\n\n\t\tVAR_13->from_inv.applyCurrentPlayer(VAR_2->getName());\n\t\tVAR_13->to_inv.applyCurrentPlayer(VAR_2->getName());\n\n\t\tVAR_14->setInventoryModified(VAR_13->from_inv);\n\t\tif (VAR_13->from_inv != VAR_13->to_inv)\n\t\t\tVAR_14->setInventoryModified(VAR_13->to_inv);\n\n\t\tbool VAR_15 = false;\n\t\tif (VAR_13->from_inv.type == InventoryLocation::PLAYER) {\n\t\t\tif (VAR_13->from_inv.name != VAR_2->getName())\n\t\t\t\treturn;\n\t\t\tVAR_15 = true;\n\t\t}\n\t\t\n\t\tbool VAR_16 = false;\n\t\tif (VAR_13->to_inv.type == InventoryLocation::PLAYER) {\n\t\t\tif (VAR_13->to_inv.name != VAR_2->getName())\n\t\t\t\treturn;\n\t\t\tVAR_16 = true;\n\t\t}\n\n\t\tInventoryLocation *VAR_17 = VAR_15 ?\n\t\t\t&VAR_13->to_inv : &VAR_13->from_inv;\n\n\t\t/* COMMENT_10 */\n\t\tif (VAR_17->type == InventoryLocation::NODEMETA) {\n\t\t\tv3f VAR_18   = intToFloat(VAR_17->p, VAR_19);\n\t\t\tv3f VAR_20 = VAR_2->getPlayerSAO()->getEyePosition();\n\t\t\tf32 VAR_21 = VAR_20.getDistanceFrom(VAR_18);\n\t\t\tif (!checkInteractDistance(VAR_2, VAR_21, \"inventory\"))\n\t\t\t\treturn;\n\t\t}\n\n\t\t/* COMMENT_11 */\n                                           \n    \n\t\tif (VAR_13->from_list == \"craftpreview\") {\n\t\t\tVAR_10 << \"Ignoring IMoveAction from \"\n\t\t\t\t\t<< (VAR_13->from_inv.dump()) << \":\" << VAR_13->from_list\n\t\t\t\t\t<< \" to \" << (VAR_13->to_inv.dump()) << \":\" << VAR_13->to_list\n\t\t\t\t\t<< \" because src is \" << VAR_13->from_list << std::endl;\n\t\t\tdelete VAR_8;\n\t\t\treturn;\n\t\t}\n\n\t\t/* COMMENT_14 */\n                                                         \n    \n\t\tif (VAR_13->to_list == \"craftpreview\" || VAR_13->to_list == \"craftresult\") {\n\t\t\tVAR_10 << \"Ignoring IMoveAction from \"\n\t\t\t\t\t<< (VAR_13->from_inv.dump()) << \":\" << VAR_13->from_list\n\t\t\t\t\t<< \" to \" << (VAR_13->to_inv.dump()) << \":\" << VAR_13->to_list\n\t\t\t\t\t<< \" because dst is \" << VAR_13->to_list << std::endl;\n\t\t\tdelete VAR_8;\n\t\t\treturn;\n\t\t}\n\n\t\t/* COMMENT_17 */\n\t\t/* COMMENT_18 */\n\t\tif (!checkPriv(VAR_2->getName(), \"interact\") &&\n\t\t\t\t(!VAR_15 ||\n\t\t\t\t!VAR_16)) {\n\t\t\tVAR_10 << \"Cannot move outside of player's inventory: \"\n\t\t\t\t\t<< \"No interact privilege\" << std::endl;\n\t\t\tdelete VAR_8;\n\t\t\treturn;\n\t\t}\n\t}\n\t/* COMMENT_19 */\n                                                          \n   \n\telse if (VAR_8->getType() == IAction::Drop) {\n\t\tIDropAction *VAR_22 = (IDropAction*)VAR_8;\n\n\t\tVAR_22->from_inv.applyCurrentPlayer(VAR_2->getName());\n\n\t\tVAR_14->setInventoryModified(VAR_22->from_inv);\n\n\t\t/* COMMENT_22 */\n                                             \n    \n\t\tif (VAR_22->from_list == \"craftpreview\") {\n\t\t\tVAR_10 << \"Ignoring IDropAction from \"\n\t\t\t\t\t<< (VAR_22->from_inv.dump()) << \":\" << VAR_22->from_list\n\t\t\t\t\t<< \" because src is \" << VAR_22->from_list << std::endl;\n\t\t\tdelete VAR_8;\n\t\t\treturn;\n\t\t}\n\n\t\t/* COMMENT_25 */\n\t\tif (!checkPriv(VAR_2->getName(), \"interact\")) {\n\t\t\tdelete VAR_8;\n\t\t\treturn;\n\t\t}\n\n\t\t/* COMMENT_26 */\n\t\tif (VAR_5->isDead()) {\n\t\t\tVAR_10 << \"Ignoring IDropAction from \"\n\t\t\t\t\t<< (VAR_22->from_inv.dump()) << \":\" << VAR_22->from_list\n\t\t\t\t\t<< \" because player is dead.\" << std::endl;\n\t\t\tdelete VAR_8;\n\t\t\treturn;\n\t\t}\n\t}\n\t/* COMMENT_27 */\n                                                           \n   \n\telse if (VAR_8->getType() == IAction::Craft) {\n\t\tICraftAction *VAR_23 = (ICraftAction*)VAR_8;\n\n\t\tVAR_23->craft_inv.applyCurrentPlayer(VAR_2->getName());\n\n\t\tVAR_14->setInventoryModified(VAR_23->craft_inv);\n\n\t\t/* COMMENT_30 */\n\t\t/* COMMENT_31 */\n\t\t/* COMMENT_32 */\n\n\t\t/* COMMENT_33 */\n\t\tif (!checkPriv(VAR_2->getName(), \"interact\")) {\n\t\t\tVAR_10 << \"Cannot craft: \"\n\t\t\t\t\t<< \"No interact privilege\" << std::endl;\n\t\t\tdelete VAR_8;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* COMMENT_34 */\n\tVAR_8->apply(VAR_14.get(), VAR_5, this);\n\t/* COMMENT_35 */\n\tdelete VAR_8;\n}",
  "func_graph_path": "minetest/3693b6871eba268ecc79b3f52d00d3cefe761131/serverpackethandler.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -56,13 +56,19 @@\n \t\tif (ma->from_inv != ma->to_inv)\n \t\t\tm_inventory_mgr->setInventoryModified(ma->to_inv);\n \n-\t\tbool from_inv_is_current_player =\n-\t\t\t(ma->from_inv.type == InventoryLocation::PLAYER) &&\n-\t\t\t(ma->from_inv.name == player->getName());\n-\n-\t\tbool to_inv_is_current_player =\n-\t\t\t(ma->to_inv.type == InventoryLocation::PLAYER) &&\n-\t\t\t(ma->to_inv.name == player->getName());\n+\t\tbool from_inv_is_current_player = false;\n+\t\tif (ma->from_inv.type == InventoryLocation::PLAYER) {\n+\t\t\tif (ma->from_inv.name != player->getName())\n+\t\t\t\treturn;\n+\t\t\tfrom_inv_is_current_player = true;\n+\t\t}\n+\t\t\n+\t\tbool to_inv_is_current_player = false;\n+\t\tif (ma->to_inv.type == InventoryLocation::PLAYER) {\n+\t\t\tif (ma->to_inv.name != player->getName())\n+\t\t\t\treturn;\n+\t\t\tto_inv_is_current_player = true;\n+\t\t}\n \n \t\tInventoryLocation *remote = from_inv_is_current_player ?\n \t\t\t&ma->to_inv : &ma->from_inv;",
  "diff_line_info": {
    "deleted_lines": [
      "\t\tbool from_inv_is_current_player =",
      "\t\t\t(ma->from_inv.type == InventoryLocation::PLAYER) &&",
      "\t\t\t(ma->from_inv.name == player->getName());",
      "",
      "\t\tbool to_inv_is_current_player =",
      "\t\t\t(ma->to_inv.type == InventoryLocation::PLAYER) &&",
      "\t\t\t(ma->to_inv.name == player->getName());"
    ],
    "added_lines": [
      "\t\tbool from_inv_is_current_player = false;",
      "\t\tif (ma->from_inv.type == InventoryLocation::PLAYER) {",
      "\t\t\tif (ma->from_inv.name != player->getName())",
      "\t\t\t\treturn;",
      "\t\t\tfrom_inv_is_current_player = true;",
      "\t\t}",
      "\t\t",
      "\t\tbool to_inv_is_current_player = false;",
      "\t\tif (ma->to_inv.type == InventoryLocation::PLAYER) {",
      "\t\t\tif (ma->to_inv.name != player->getName())",
      "\t\t\t\treturn;",
      "\t\t\tto_inv_is_current_player = true;",
      "\t\t}"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/luanti-org/luanti/pull/10341",
  "description": {
    "pr_info": {
      "title": "Prevent players accessing inventories of other players",
      "number": 10341
    },
    "comment": [
      "Title says it all. Fixes this cheat. Unfortunately also requires invhack mods to implement workarounds, but they seem to already be doing this.\r\n",
      "Nice, that's another cheat from my hackclient patched (see #10340 )",
      "Player inventories are only sent to the correct player. I see this is needed, but not how you'd get that inventory list in first place.\r\nEDIT: Drop and craft might also need the same guards.",
      "> Player inventories are only sent to the correct player. I see this is needed, but not how you'd get that inventory list in first place.\r\n\r\nYou don't need to have that list, you can guess where items are\r\n\r\nThis is a classic example of a Time of Check is not Time of Use vulnerability - the inventory owner is checked when sending inventories (kinda), but not on inventory actions",
      "My approval still stands",
      "Nice, the inventory exploit I found is patched.",
      "We'd be grateful for reports in the future, I know that's less fun :D",
      "> We'd be grateful for reports in the future, I know that's less fun :D\r\n\r\nI emailed a core dev about it instead of reporting it publicly because I didn't want somebody seeing the issue and wiping everyone's inventories on servers. But it seems the email wasn't noticed. Is there a way to report bugs privately that gets noticed?",
      "Talking to a core developer privately on IRC is another option, when you get a reply you can be sure your report was seen.",
      "Ah ok, thanks for that - we need to work on our communication",
      "https://github.com/minetest/minetest/security/policy\r\n\r\nThought that tab allowed in-Github reports, guess not",
      "Oh nice, you can draft the advisory privately and then publish it",
      "Needs to be done for detached inventorys as well.\r\n3d_armor has a workaround but they should be safe by the engine.",
      "> Needs to be done for detached inventorys as well.\r\n> 3d_armor has a workaround but they should be safe by the engine.\r\n\r\nImpossible. Detached inventories are meant to be accessible. Only mods can and have to implement meaningful restrictions, such as range or ownership.",
      "I'm referring to detached inventorys which were specifically meant for only one player. These are also only sent to this one.\r\nSure public detached inventorys should still be accessible.",
      "#11035"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses a security vulnerability by preventing unauthorized access to other players' inventories, specifically fixing a TOCTOU issue. The code changes enforce strict access checks, and the commit message and comments confirm it's a security fix.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 1.0"
}