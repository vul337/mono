{
  "cve_id": "CVE-2020-10232",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "sleuthkit",
  "commit_msg": "Fix stack buffer overflow in yaffsfs_istat\n\nPrevent a stack buffer overflow in yaffsfs_istat by increasing the buffer size to the size required by tsk_fs_time_to_str.",
  "commit_hash": "459ae818fc8dae717549810150de4d191ce158f1",
  "git_url": "https://github.com/sleuthkit/sleuthkit/commit/459ae818fc8dae717549810150de4d191ce158f1",
  "file_path": "tsk/fs/yaffs.cpp",
  "func_name": "yaffsfs_istat",
  "func_before": "static uint8_t\n    yaffsfs_istat(TSK_FS_INFO *fs, TSK_FS_ISTAT_FLAG_ENUM flags, FILE * hFile, TSK_INUM_T inum,\n    TSK_DADDR_T numblock, int32_t sec_skew)\n{\n    TSK_FS_META *fs_meta;\n    TSK_FS_FILE *fs_file;\n    YAFFSFS_INFO *yfs = (YAFFSFS_INFO *)fs;\n    char ls[12];\n    YAFFSFS_PRINT_ADDR print;\n    char timeBuf[32];\n    YaffsCacheObject * obj = NULL;\n    YaffsCacheVersion * version = NULL;\n    YaffsHeader * header = NULL;\n\n    yaffscache_version_find_by_inode(yfs, inum, &version, &obj);\n\n    if ((fs_file = tsk_fs_file_open_meta(fs, NULL, inum)) == NULL) {\n        return 1;\n    }\n    fs_meta = fs_file->meta;\n\n    tsk_fprintf(hFile, \"inode: %\" PRIuINUM \"\\n\", inum);\n    tsk_fprintf(hFile, \"%sAllocated\\n\",\n        (fs_meta->flags & TSK_FS_META_FLAG_ALLOC) ? \"\" : \"Not \");\n\n    if (fs_meta->link)\n        tsk_fprintf(hFile, \"symbolic link to: %s\\n\", fs_meta->link);\n\n    tsk_fprintf(hFile, \"uid / gid: %\" PRIuUID \" / %\" PRIuGID \"\\n\",\n        fs_meta->uid, fs_meta->gid);\n\n    tsk_fs_meta_make_ls(fs_meta, ls, sizeof(ls));\n    tsk_fprintf(hFile, \"mode: %s\\n\", ls);\n\n    tsk_fprintf(hFile, \"size: %\" PRIdOFF \"\\n\", fs_meta->size);\n    tsk_fprintf(hFile, \"num of links: %d\\n\", fs_meta->nlink);\n\n    if(version != NULL){\n        yaffsfs_read_header(yfs, &header, version->ycv_header_chunk->ycc_offset);\n        if(header != NULL){\n            tsk_fprintf(hFile, \"Name: %s\\n\", header->name);\n        }\n    }\n\n    if (sec_skew != 0) {\n        tsk_fprintf(hFile, \"\\nAdjusted Inode Times:\\n\");\n        fs_meta->mtime -= sec_skew;\n        fs_meta->atime -= sec_skew;\n        fs_meta->ctime -= sec_skew;\n\n        tsk_fprintf(hFile, \"Accessed:\\t%s\\n\",\n            tsk_fs_time_to_str(fs_meta->atime, timeBuf));\n        tsk_fprintf(hFile, \"File Modified:\\t%s\\n\",\n            tsk_fs_time_to_str(fs_meta->mtime, timeBuf));\n        tsk_fprintf(hFile, \"Inode Modified:\\t%s\\n\",\n            tsk_fs_time_to_str(fs_meta->ctime, timeBuf));\n\n        fs_meta->mtime += sec_skew;\n        fs_meta->atime += sec_skew;\n        fs_meta->ctime += sec_skew;\n\n        tsk_fprintf(hFile, \"\\nOriginal Inode Times:\\n\");\n    }\n    else {\n        tsk_fprintf(hFile, \"\\nInode Times:\\n\");\n    }\n\n    tsk_fprintf(hFile, \"Accessed:\\t%s\\n\",\n        tsk_fs_time_to_str(fs_meta->atime, timeBuf));\n    tsk_fprintf(hFile, \"File Modified:\\t%s\\n\",\n        tsk_fs_time_to_str(fs_meta->mtime, timeBuf));\n    tsk_fprintf(hFile, \"Inode Modified:\\t%s\\n\",\n        tsk_fs_time_to_str(fs_meta->ctime, timeBuf));\n\n    if(version != NULL){\n        tsk_fprintf(hFile, \"\\nHeader Chunk:\\n\");\n        tsk_fprintf(hFile, \"%\" PRIuDADDR \"\\n\", (version->ycv_header_chunk->ycc_offset / (yfs->page_size + yfs->spare_size)));\n    }\n\n    if (numblock > 0) {\n        TSK_OFF_T lower_size = numblock * fs->block_size;\n        fs_meta->size = (lower_size < fs_meta->size)?(lower_size):(fs_meta->size);\n    }\n    tsk_fprintf(hFile, \"\\nData Chunks:\\n\");\n\n\n    if (flags & TSK_FS_ISTAT_RUNLIST){\n        const TSK_FS_ATTR *fs_attr_default =\n            tsk_fs_file_attr_get_type(fs_file,\n                TSK_FS_ATTR_TYPE_DEFAULT, 0, 0);\n        if (fs_attr_default && (fs_attr_default->flags & TSK_FS_ATTR_NONRES)) {\n            if (tsk_fs_attr_print(fs_attr_default, hFile)) {\n                tsk_fprintf(hFile, \"\\nError creating run lists  \");\n                tsk_error_print(hFile);\n                tsk_error_reset();\n            }\n        }\n    }\n    else {\n        print.idx = 0;\n        print.hFile = hFile;\n\n        if (tsk_fs_file_walk(fs_file, TSK_FS_FILE_WALK_FLAG_AONLY,\n            (TSK_FS_FILE_WALK_CB)print_addr_act, (void *)&print)) {\n            tsk_fprintf(hFile, \"\\nError reading file:  \");\n            tsk_error_print(hFile);\n            tsk_error_reset();\n        }\n        else if (print.idx != 0) {\n            tsk_fprintf(hFile, \"\\n\");\n        }\n    }\n\n    tsk_fs_file_close(fs_file);\n\n    return 0;\n}",
  "abstract_func_before": "static uint8_t\n    yaffsfs_istat(TSK_FS_INFO *VAR_0, TSK_FS_ISTAT_FLAG_ENUM VAR_1, FILE * VAR_2, TSK_INUM_T VAR_3,\n    TSK_DADDR_T VAR_4, int32_t VAR_5)\n{\n    TSK_FS_META *VAR_6;\n    TSK_FS_FILE *VAR_7;\n    YAFFSFS_INFO *VAR_8 = (YAFFSFS_INFO *)VAR_0;\n    char VAR_9[12];\n    YAFFSFS_PRINT_ADDR VAR_10;\n    char VAR_11[32];\n    YaffsCacheObject * VAR_12 = NULL;\n    YaffsCacheVersion * VAR_13 = NULL;\n    YaffsHeader * VAR_14 = NULL;\n\n    yaffscache_version_find_by_inode(VAR_8, VAR_3, &VAR_13, &VAR_12);\n\n    if ((VAR_7 = tsk_fs_file_open_meta(VAR_0, NULL, VAR_3)) == NULL) {\n        return 1;\n    }\n    VAR_6 = VAR_7->meta;\n\n    tsk_fprintf(VAR_2, \"inode: %\" VAR_15 \"\\n\", VAR_3);\n    tsk_fprintf(VAR_2, \"%sAllocated\\n\",\n        (VAR_6->flags & VAR_16) ? \"\" : \"Not \");\n\n    if (VAR_6->link)\n        tsk_fprintf(VAR_2, \"symbolic link to: %s\\n\", VAR_6->link);\n\n    tsk_fprintf(VAR_2, \"uid / gid: %\" VAR_17 \" / %\" VAR_18 \"\\n\",\n        VAR_6->uid, VAR_6->gid);\n\n    tsk_fs_meta_make_ls(VAR_6, VAR_9, sizeof(VAR_9));\n    tsk_fprintf(VAR_2, \"mode: %s\\n\", VAR_9);\n\n    tsk_fprintf(VAR_2, \"size: %\" VAR_19 \"\\n\", VAR_6->size);\n    tsk_fprintf(VAR_2, \"num of links: %d\\n\", VAR_6->nlink);\n\n    if(VAR_13 != NULL){\n        yaffsfs_read_header(VAR_8, &VAR_14, VAR_13->ycv_header_chunk->ycc_offset);\n        if(VAR_14 != NULL){\n            tsk_fprintf(VAR_2, \"Name: %s\\n\", VAR_14->name);\n        }\n    }\n\n    if (VAR_5 != 0) {\n        tsk_fprintf(VAR_2, \"\\nAdjusted Inode Times:\\n\");\n        VAR_6->mtime -= VAR_5;\n        VAR_6->atime -= VAR_5;\n        VAR_6->ctime -= VAR_5;\n\n        tsk_fprintf(VAR_2, \"Accessed:\\t%s\\n\",\n            tsk_fs_time_to_str(VAR_6->atime, VAR_11));\n        tsk_fprintf(VAR_2, \"File Modified:\\t%s\\n\",\n            tsk_fs_time_to_str(VAR_6->mtime, VAR_11));\n        tsk_fprintf(VAR_2, \"Inode Modified:\\t%s\\n\",\n            tsk_fs_time_to_str(VAR_6->ctime, VAR_11));\n\n        VAR_6->mtime += VAR_5;\n        VAR_6->atime += VAR_5;\n        VAR_6->ctime += VAR_5;\n\n        tsk_fprintf(VAR_2, \"\\nOriginal Inode Times:\\n\");\n    }\n    else {\n        tsk_fprintf(VAR_2, \"\\nInode Times:\\n\");\n    }\n\n    tsk_fprintf(VAR_2, \"Accessed:\\t%s\\n\",\n        tsk_fs_time_to_str(VAR_6->atime, VAR_11));\n    tsk_fprintf(VAR_2, \"File Modified:\\t%s\\n\",\n        tsk_fs_time_to_str(VAR_6->mtime, VAR_11));\n    tsk_fprintf(VAR_2, \"Inode Modified:\\t%s\\n\",\n        tsk_fs_time_to_str(VAR_6->ctime, VAR_11));\n\n    if(VAR_13 != NULL){\n        tsk_fprintf(VAR_2, \"\\nHeader Chunk:\\n\");\n        tsk_fprintf(VAR_2, \"%\" VAR_20 \"\\n\", (VAR_13->ycv_header_chunk->ycc_offset / (VAR_8->page_size + VAR_8->spare_size)));\n    }\n\n    if (VAR_4 > 0) {\n        TSK_OFF_T VAR_21 = VAR_4 * VAR_0->block_size;\n        VAR_6->size = (VAR_21 < VAR_6->size)?(VAR_21):(VAR_6->size);\n    }\n    tsk_fprintf(VAR_2, \"\\nData Chunks:\\n\");\n\n\n    if (VAR_1 & VAR_22){\n        const TSK_FS_ATTR *VAR_23 =\n            tsk_fs_file_attr_get_type(VAR_7,\n                VAR_24, 0, 0);\n        if (VAR_23 && (VAR_23->flags & VAR_25)) {\n            if (tsk_fs_attr_print(VAR_23, VAR_2)) {\n                tsk_fprintf(VAR_2, \"\\nError creating run lists  \");\n                tsk_error_print(VAR_2);\n                tsk_error_reset();\n            }\n        }\n    }\n    else {\n        VAR_10.idx = 0;\n        VAR_10.hFile = VAR_2;\n\n        if (tsk_fs_file_walk(VAR_7, VAR_26,\n            (TSK_FS_FILE_WALK_CB)VAR_27, (void *)&VAR_10)) {\n            tsk_fprintf(VAR_2, \"\\nError reading file:  \");\n            tsk_error_print(VAR_2);\n            tsk_error_reset();\n        }\n        else if (VAR_10.idx != 0) {\n            tsk_fprintf(VAR_2, \"\\n\");\n        }\n    }\n\n    tsk_fs_file_close(VAR_7);\n\n    return 0;\n}",
  "func_graph_path_before": "sleuthkit/459ae818fc8dae717549810150de4d191ce158f1/yaffs.cpp/vul/before/0.json",
  "func": "static uint8_t\n    yaffsfs_istat(TSK_FS_INFO *fs, TSK_FS_ISTAT_FLAG_ENUM flags, FILE * hFile, TSK_INUM_T inum,\n    TSK_DADDR_T numblock, int32_t sec_skew)\n{\n    TSK_FS_META *fs_meta;\n    TSK_FS_FILE *fs_file;\n    YAFFSFS_INFO *yfs = (YAFFSFS_INFO *)fs;\n    char ls[12];\n    YAFFSFS_PRINT_ADDR print;\n    char timeBuf[128];\n    YaffsCacheObject * obj = NULL;\n    YaffsCacheVersion * version = NULL;\n    YaffsHeader * header = NULL;\n\n    yaffscache_version_find_by_inode(yfs, inum, &version, &obj);\n\n    if ((fs_file = tsk_fs_file_open_meta(fs, NULL, inum)) == NULL) {\n        return 1;\n    }\n    fs_meta = fs_file->meta;\n\n    tsk_fprintf(hFile, \"inode: %\" PRIuINUM \"\\n\", inum);\n    tsk_fprintf(hFile, \"%sAllocated\\n\",\n        (fs_meta->flags & TSK_FS_META_FLAG_ALLOC) ? \"\" : \"Not \");\n\n    if (fs_meta->link)\n        tsk_fprintf(hFile, \"symbolic link to: %s\\n\", fs_meta->link);\n\n    tsk_fprintf(hFile, \"uid / gid: %\" PRIuUID \" / %\" PRIuGID \"\\n\",\n        fs_meta->uid, fs_meta->gid);\n\n    tsk_fs_meta_make_ls(fs_meta, ls, sizeof(ls));\n    tsk_fprintf(hFile, \"mode: %s\\n\", ls);\n\n    tsk_fprintf(hFile, \"size: %\" PRIdOFF \"\\n\", fs_meta->size);\n    tsk_fprintf(hFile, \"num of links: %d\\n\", fs_meta->nlink);\n\n    if(version != NULL){\n        yaffsfs_read_header(yfs, &header, version->ycv_header_chunk->ycc_offset);\n        if(header != NULL){\n            tsk_fprintf(hFile, \"Name: %s\\n\", header->name);\n        }\n    }\n\n    if (sec_skew != 0) {\n        tsk_fprintf(hFile, \"\\nAdjusted Inode Times:\\n\");\n        fs_meta->mtime -= sec_skew;\n        fs_meta->atime -= sec_skew;\n        fs_meta->ctime -= sec_skew;\n\n        tsk_fprintf(hFile, \"Accessed:\\t%s\\n\",\n            tsk_fs_time_to_str(fs_meta->atime, timeBuf));\n        tsk_fprintf(hFile, \"File Modified:\\t%s\\n\",\n            tsk_fs_time_to_str(fs_meta->mtime, timeBuf));\n        tsk_fprintf(hFile, \"Inode Modified:\\t%s\\n\",\n            tsk_fs_time_to_str(fs_meta->ctime, timeBuf));\n\n        fs_meta->mtime += sec_skew;\n        fs_meta->atime += sec_skew;\n        fs_meta->ctime += sec_skew;\n\n        tsk_fprintf(hFile, \"\\nOriginal Inode Times:\\n\");\n    }\n    else {\n        tsk_fprintf(hFile, \"\\nInode Times:\\n\");\n    }\n\n    tsk_fprintf(hFile, \"Accessed:\\t%s\\n\",\n        tsk_fs_time_to_str(fs_meta->atime, timeBuf));\n    tsk_fprintf(hFile, \"File Modified:\\t%s\\n\",\n        tsk_fs_time_to_str(fs_meta->mtime, timeBuf));\n    tsk_fprintf(hFile, \"Inode Modified:\\t%s\\n\",\n        tsk_fs_time_to_str(fs_meta->ctime, timeBuf));\n\n    if(version != NULL){\n        tsk_fprintf(hFile, \"\\nHeader Chunk:\\n\");\n        tsk_fprintf(hFile, \"%\" PRIuDADDR \"\\n\", (version->ycv_header_chunk->ycc_offset / (yfs->page_size + yfs->spare_size)));\n    }\n\n    if (numblock > 0) {\n        TSK_OFF_T lower_size = numblock * fs->block_size;\n        fs_meta->size = (lower_size < fs_meta->size)?(lower_size):(fs_meta->size);\n    }\n    tsk_fprintf(hFile, \"\\nData Chunks:\\n\");\n\n\n    if (flags & TSK_FS_ISTAT_RUNLIST){\n        const TSK_FS_ATTR *fs_attr_default =\n            tsk_fs_file_attr_get_type(fs_file,\n                TSK_FS_ATTR_TYPE_DEFAULT, 0, 0);\n        if (fs_attr_default && (fs_attr_default->flags & TSK_FS_ATTR_NONRES)) {\n            if (tsk_fs_attr_print(fs_attr_default, hFile)) {\n                tsk_fprintf(hFile, \"\\nError creating run lists  \");\n                tsk_error_print(hFile);\n                tsk_error_reset();\n            }\n        }\n    }\n    else {\n        print.idx = 0;\n        print.hFile = hFile;\n\n        if (tsk_fs_file_walk(fs_file, TSK_FS_FILE_WALK_FLAG_AONLY,\n            (TSK_FS_FILE_WALK_CB)print_addr_act, (void *)&print)) {\n            tsk_fprintf(hFile, \"\\nError reading file:  \");\n            tsk_error_print(hFile);\n            tsk_error_reset();\n        }\n        else if (print.idx != 0) {\n            tsk_fprintf(hFile, \"\\n\");\n        }\n    }\n\n    tsk_fs_file_close(fs_file);\n\n    return 0;\n}",
  "abstract_func": "static uint8_t\n    yaffsfs_istat(TSK_FS_INFO *VAR_0, TSK_FS_ISTAT_FLAG_ENUM VAR_1, FILE * VAR_2, TSK_INUM_T VAR_3,\n    TSK_DADDR_T VAR_4, int32_t VAR_5)\n{\n    TSK_FS_META *VAR_6;\n    TSK_FS_FILE *VAR_7;\n    YAFFSFS_INFO *VAR_8 = (YAFFSFS_INFO *)VAR_0;\n    char VAR_9[12];\n    YAFFSFS_PRINT_ADDR VAR_10;\n    char VAR_11[128];\n    YaffsCacheObject * VAR_12 = NULL;\n    YaffsCacheVersion * VAR_13 = NULL;\n    YaffsHeader * VAR_14 = NULL;\n\n    yaffscache_version_find_by_inode(VAR_8, VAR_3, &VAR_13, &VAR_12);\n\n    if ((VAR_7 = tsk_fs_file_open_meta(VAR_0, NULL, VAR_3)) == NULL) {\n        return 1;\n    }\n    VAR_6 = VAR_7->meta;\n\n    tsk_fprintf(VAR_2, \"inode: %\" VAR_15 \"\\n\", VAR_3);\n    tsk_fprintf(VAR_2, \"%sAllocated\\n\",\n        (VAR_6->flags & VAR_16) ? \"\" : \"Not \");\n\n    if (VAR_6->link)\n        tsk_fprintf(VAR_2, \"symbolic link to: %s\\n\", VAR_6->link);\n\n    tsk_fprintf(VAR_2, \"uid / gid: %\" VAR_17 \" / %\" VAR_18 \"\\n\",\n        VAR_6->uid, VAR_6->gid);\n\n    tsk_fs_meta_make_ls(VAR_6, VAR_9, sizeof(VAR_9));\n    tsk_fprintf(VAR_2, \"mode: %s\\n\", VAR_9);\n\n    tsk_fprintf(VAR_2, \"size: %\" VAR_19 \"\\n\", VAR_6->size);\n    tsk_fprintf(VAR_2, \"num of links: %d\\n\", VAR_6->nlink);\n\n    if(VAR_13 != NULL){\n        yaffsfs_read_header(VAR_8, &VAR_14, VAR_13->ycv_header_chunk->ycc_offset);\n        if(VAR_14 != NULL){\n            tsk_fprintf(VAR_2, \"Name: %s\\n\", VAR_14->name);\n        }\n    }\n\n    if (VAR_5 != 0) {\n        tsk_fprintf(VAR_2, \"\\nAdjusted Inode Times:\\n\");\n        VAR_6->mtime -= VAR_5;\n        VAR_6->atime -= VAR_5;\n        VAR_6->ctime -= VAR_5;\n\n        tsk_fprintf(VAR_2, \"Accessed:\\t%s\\n\",\n            tsk_fs_time_to_str(VAR_6->atime, VAR_11));\n        tsk_fprintf(VAR_2, \"File Modified:\\t%s\\n\",\n            tsk_fs_time_to_str(VAR_6->mtime, VAR_11));\n        tsk_fprintf(VAR_2, \"Inode Modified:\\t%s\\n\",\n            tsk_fs_time_to_str(VAR_6->ctime, VAR_11));\n\n        VAR_6->mtime += VAR_5;\n        VAR_6->atime += VAR_5;\n        VAR_6->ctime += VAR_5;\n\n        tsk_fprintf(VAR_2, \"\\nOriginal Inode Times:\\n\");\n    }\n    else {\n        tsk_fprintf(VAR_2, \"\\nInode Times:\\n\");\n    }\n\n    tsk_fprintf(VAR_2, \"Accessed:\\t%s\\n\",\n        tsk_fs_time_to_str(VAR_6->atime, VAR_11));\n    tsk_fprintf(VAR_2, \"File Modified:\\t%s\\n\",\n        tsk_fs_time_to_str(VAR_6->mtime, VAR_11));\n    tsk_fprintf(VAR_2, \"Inode Modified:\\t%s\\n\",\n        tsk_fs_time_to_str(VAR_6->ctime, VAR_11));\n\n    if(VAR_13 != NULL){\n        tsk_fprintf(VAR_2, \"\\nHeader Chunk:\\n\");\n        tsk_fprintf(VAR_2, \"%\" VAR_20 \"\\n\", (VAR_13->ycv_header_chunk->ycc_offset / (VAR_8->page_size + VAR_8->spare_size)));\n    }\n\n    if (VAR_4 > 0) {\n        TSK_OFF_T VAR_21 = VAR_4 * VAR_0->block_size;\n        VAR_6->size = (VAR_21 < VAR_6->size)?(VAR_21):(VAR_6->size);\n    }\n    tsk_fprintf(VAR_2, \"\\nData Chunks:\\n\");\n\n\n    if (VAR_1 & VAR_22){\n        const TSK_FS_ATTR *VAR_23 =\n            tsk_fs_file_attr_get_type(VAR_7,\n                VAR_24, 0, 0);\n        if (VAR_23 && (VAR_23->flags & VAR_25)) {\n            if (tsk_fs_attr_print(VAR_23, VAR_2)) {\n                tsk_fprintf(VAR_2, \"\\nError creating run lists  \");\n                tsk_error_print(VAR_2);\n                tsk_error_reset();\n            }\n        }\n    }\n    else {\n        VAR_10.idx = 0;\n        VAR_10.hFile = VAR_2;\n\n        if (tsk_fs_file_walk(VAR_7, VAR_26,\n            (TSK_FS_FILE_WALK_CB)VAR_27, (void *)&VAR_10)) {\n            tsk_fprintf(VAR_2, \"\\nError reading file:  \");\n            tsk_error_print(VAR_2);\n            tsk_error_reset();\n        }\n        else if (VAR_10.idx != 0) {\n            tsk_fprintf(VAR_2, \"\\n\");\n        }\n    }\n\n    tsk_fs_file_close(VAR_7);\n\n    return 0;\n}",
  "func_graph_path": "sleuthkit/459ae818fc8dae717549810150de4d191ce158f1/yaffs.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -7,7 +7,7 @@\n     YAFFSFS_INFO *yfs = (YAFFSFS_INFO *)fs;\n     char ls[12];\n     YAFFSFS_PRINT_ADDR print;\n-    char timeBuf[32];\n+    char timeBuf[128];\n     YaffsCacheObject * obj = NULL;\n     YaffsCacheVersion * version = NULL;\n     YaffsHeader * header = NULL;",
  "diff_line_info": {
    "deleted_lines": [
      "    char timeBuf[32];"
    ],
    "added_lines": [
      "    char timeBuf[128];"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/sleuthkit/sleuthkit/pull/1836",
  "description": {
    "pr_info": {
      "title": "Fix stack buffer overflow in yaffsfs_istat",
      "number": 1836
    },
    "comment": [
      "Prevent a stack buffer overflow in yaffsfs_istat by increasing the buffer size to the size required by tsk_fs_time_to_str.\r\n\r\nThis is potentially exploitable by an attacker creating a file in a yaffs image with abnormally large time values.",
      "If possible, I would like to create a security advisory for this on GitHub to request a CVE and inform other projects that import this functionality.",
      "Any way that a maintainer can create a draft security advisory for this vulnerability? Iâ€™m happy to fill in the details, but a maintainer will need to create the draft and publish it once completed.",
      "This appears to be [CVE-2020-10232](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-10232)."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses a stack buffer overflow in the `yaffsfs_istat` function by increasing the buffer size. This prevents potential exploitation by attackers creating files with large time values. The code change directly targets a security vulnerability, as indicated by the commit message and the associated CVE reference.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 1.0"
}