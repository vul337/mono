{
  "cve_id": "CVE-2021-45884",
  "cwe_ids": [
    "CWE-200"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:N/A:N",
  "cvss_is_v3": false,
  "repo_name": "brave/brave-core",
  "commit_msg": "disable CNAME uncloaking when a proxy extension with a socks fallback is enabled",
  "commit_hash": "133af65c89c035b2934ca3532f8442c719c5b471",
  "git_url": "https://github.com/brave/brave-core/commit/133af65c89c035b2934ca3532f8442c719c5b471",
  "file_path": "browser/net/brave_ad_block_tp_network_delegate_helper.cc",
  "func_name": "ProxySettingsAllowUncloaking",
  "func_before": "bool ProxySettingsAllowUncloaking(content::BrowserContext* browser_context) {\n  DCHECK(browser_context);\n\n  bool can_uncloak = true;\n\n  Profile* profile = Profile::FromBrowserContext(browser_context);\n\n  std::unique_ptr<PrefProxyConfigTracker> config_tracker =\n      ProxyServiceFactory::CreatePrefProxyConfigTrackerOfProfile(\n          profile->GetPrefs(), nullptr);\n  std::unique_ptr<net::ProxyConfigService> proxy_config_service =\n      ProxyServiceFactory::CreateProxyConfigService(config_tracker.get());\n\n  net::ProxyConfigWithAnnotation config;\n  net::ProxyConfigService::ConfigAvailability availability =\n      proxy_config_service->GetLatestProxyConfig(&config);\n\n  if (availability ==\n      net::ProxyConfigService::ConfigAvailability::CONFIG_VALID) {\n    // PROXY_LIST corresponds to SingleProxy mode.\n    if (config.value().proxy_rules().type ==\n        net::ProxyConfig::ProxyRules::Type::PROXY_LIST) {\n      can_uncloak = false;\n    }\n  }\n\n  config_tracker->DetachFromPrefService();\n\n  return can_uncloak;\n}",
  "abstract_func_before": "bool ProxySettingsAllowUncloaking(content::BrowserContext* VAR_0) {\n  DCHECK(VAR_0);\n\n  bool VAR_1 = true;\n\n  Profile* VAR_2 = Profile::FromBrowserContext(VAR_0);\n\n  std::unique_ptr<PrefProxyConfigTracker> VAR_3 =\n      ProxyServiceFactory::CreatePrefProxyConfigTrackerOfProfile(\n          VAR_2->GetPrefs(), nullptr);\n  std::unique_ptr<net::ProxyConfigService> VAR_4 =\n      ProxyServiceFactory::CreateProxyConfigService(VAR_3.get());\n\n  net::ProxyConfigWithAnnotation VAR_5;\n  net::ProxyConfigService::ConfigAvailability VAR_6 =\n      VAR_4->GetLatestProxyConfig(&VAR_5);\n\n  if (VAR_6 ==\n      net::ProxyConfigService::ConfigAvailability::CONFIG_VALID) {\n    /* COMMENT_0 */\n    if (VAR_5.value().proxy_rules().type ==\n        net::ProxyConfig::ProxyRules::Type::PROXY_LIST) {\n      VAR_1 = false;\n    }\n  }\n\n  VAR_3->DetachFromPrefService();\n\n  return VAR_1;\n}",
  "func_graph_path_before": "brave/brave-core/133af65c89c035b2934ca3532f8442c719c5b471/brave_ad_block_tp_network_delegate_helper.cc/vul/before/0.json",
  "func": "bool ProxySettingsAllowUncloaking(content::BrowserContext* browser_context) {\n  DCHECK(browser_context);\n\n  bool can_uncloak = true;\n\n  Profile* profile = Profile::FromBrowserContext(browser_context);\n\n  std::unique_ptr<PrefProxyConfigTracker> config_tracker =\n      ProxyServiceFactory::CreatePrefProxyConfigTrackerOfProfile(\n          profile->GetPrefs(), nullptr);\n  std::unique_ptr<net::ProxyConfigService> proxy_config_service =\n      ProxyServiceFactory::CreateProxyConfigService(config_tracker.get());\n\n  net::ProxyConfigWithAnnotation config;\n  net::ProxyConfigService::ConfigAvailability availability =\n      proxy_config_service->GetLatestProxyConfig(&config);\n\n  if (availability ==\n      net::ProxyConfigService::ConfigAvailability::CONFIG_VALID) {\n    // PROXY_LIST corresponds to SingleProxy mode.\n    if (config.value().proxy_rules().type ==\n            net::ProxyConfig::ProxyRules::Type::PROXY_LIST ||\n        (config.value().proxy_rules().type ==\n             net::ProxyConfig::ProxyRules::Type::PROXY_LIST_PER_SCHEME &&\n         !config.value().proxy_rules().fallback_proxies.IsEmpty())) {\n      can_uncloak = false;\n    }\n  }\n\n  config_tracker->DetachFromPrefService();\n\n  return can_uncloak;\n}",
  "abstract_func": "bool ProxySettingsAllowUncloaking(content::BrowserContext* VAR_0) {\n  DCHECK(VAR_0);\n\n  bool VAR_1 = true;\n\n  Profile* VAR_2 = Profile::FromBrowserContext(VAR_0);\n\n  std::unique_ptr<PrefProxyConfigTracker> VAR_3 =\n      ProxyServiceFactory::CreatePrefProxyConfigTrackerOfProfile(\n          VAR_2->GetPrefs(), nullptr);\n  std::unique_ptr<net::ProxyConfigService> VAR_4 =\n      ProxyServiceFactory::CreateProxyConfigService(VAR_3.get());\n\n  net::ProxyConfigWithAnnotation VAR_5;\n  net::ProxyConfigService::ConfigAvailability VAR_6 =\n      VAR_4->GetLatestProxyConfig(&VAR_5);\n\n  if (VAR_6 ==\n      net::ProxyConfigService::ConfigAvailability::CONFIG_VALID) {\n    /* COMMENT_0 */\n    if (VAR_5.value().proxy_rules().type ==\n            net::ProxyConfig::ProxyRules::Type::PROXY_LIST ||\n        (VAR_5.value().proxy_rules().type ==\n             net::ProxyConfig::ProxyRules::Type::PROXY_LIST_PER_SCHEME &&\n         !VAR_5.value().proxy_rules().fallback_proxies.IsEmpty())) {\n      VAR_1 = false;\n    }\n  }\n\n  VAR_3->DetachFromPrefService();\n\n  return VAR_1;\n}",
  "func_graph_path": "brave/brave-core/133af65c89c035b2934ca3532f8442c719c5b471/brave_ad_block_tp_network_delegate_helper.cc/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -19,7 +19,10 @@\n       net::ProxyConfigService::ConfigAvailability::CONFIG_VALID) {\n     // PROXY_LIST corresponds to SingleProxy mode.\n     if (config.value().proxy_rules().type ==\n-        net::ProxyConfig::ProxyRules::Type::PROXY_LIST) {\n+            net::ProxyConfig::ProxyRules::Type::PROXY_LIST ||\n+        (config.value().proxy_rules().type ==\n+             net::ProxyConfig::ProxyRules::Type::PROXY_LIST_PER_SCHEME &&\n+         !config.value().proxy_rules().fallback_proxies.IsEmpty())) {\n       can_uncloak = false;\n     }\n   }",
  "diff_line_info": {
    "deleted_lines": [
      "        net::ProxyConfig::ProxyRules::Type::PROXY_LIST) {"
    ],
    "added_lines": [
      "            net::ProxyConfig::ProxyRules::Type::PROXY_LIST ||",
      "        (config.value().proxy_rules().type ==",
      "             net::ProxyConfig::ProxyRules::Type::PROXY_LIST_PER_SCHEME &&",
      "         !config.value().proxy_rules().fallback_proxies.IsEmpty())) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/brave/brave-core/pull/10742",
  "description": {
    "pr_info": {
      "title": "Disable CNAME uncloaking when a proxy extension with a socks fallback is enabled",
      "number": 10742
    },
    "comment": [
      "<!-- Add brave-browser issue bellow that this PR will resolve -->\r\nResolves https://github.com/brave/brave-browser/issues/19070\r\n\r\n## Submitter Checklist:\r\n\r\n- [x] I confirm that no security/privacy review [is needed](https://github.com/brave/brave-browser/wiki/Security-reviews), or that I have [requested](https://github.com/brave/security/issues/new/choose) one\r\n- [x] There is a [ticket](https://github.com/brave/brave-browser/issues) for my issue\r\n- [x] Used Github [auto-closing keywords](https://docs.github.com/en/github/managing-your-work-on-github/linking-a-pull-request-to-an-issue) in the PR description above\r\n- [x] Wrote a good [PR/commit description](https://google.github.io/eng-practices/review/developer/cl-descriptions.html)\r\n- [x] Added appropriate labels (`QA/Yes` or `QA/No`; `release-notes/include` or `release-notes/exclude`; `OS/...`) to the associated issue\r\n- [x] Checked the PR locally: `npm run test -- brave_browser_tests`, `npm run test -- brave_unit_tests`, `npm run lint`, `npm run gn_check`, `npm run tslint`\r\n- [ ] Ran `git rebase master` (if needed)\r\n\r\n## Reviewer Checklist:\r\n\r\n- [ ] A security review [is not needed](https://github.com/brave/brave-browser/wiki/Security-reviews), or a link to one is included in the PR description\r\n- [ ] New files have MPL-2.0 license header\r\n- [ ] Adequate test coverage exists to prevent regressions\r\n- [ ] Major classes, functions and non-trivial code blocks are well-commented\r\n- [ ] Changes in component dependencies are properly reflected in `gn`\r\n- [ ] Code follows the [style guide](https://chromium.googlesource.com/chromium/src/+/HEAD/styleguide/c++/c++.md)\r\n- [ ] Test plan is specified in PR before merging\r\n\r\n## After-merge Checklist:\r\n\r\n- [ ] The associated issue milestone is set to the smallest version that the\r\n  changes has landed on\r\n- [ ] All relevant documentation has been updated, for instance:\r\n  - [ ] https://github.com/brave/brave-browser/wiki/Deviations-from-Chromium-(features-we-disable-or-remove)\r\n  - [ ] https://github.com/brave/brave-browser/wiki/Proxy-redirected-URLs\r\n  - [ ] https://github.com/brave/brave-browser/wiki/Fingerprinting-Protections\r\n  - [ ] https://github.com/brave/brave-browser/wiki/Brave%E2%80%99s-Use-of-Referral-Codes\r\n  - [ ] https://github.com/brave/brave-browser/wiki/Custom-Headers\r\n  - [ ] https://github.com/brave/brave-browser/wiki/Web-Compatibility-Exceptions-in-Brave\r\n  - [ ] https://github.com/brave/brave-browser/wiki/QA-Guide\r\n  - [ ] https://github.com/brave/brave-browser/wiki/P3A\r\n\r\n## Test Plan:\r\n\r\n1. Install the [Proxy SwitchyOmega](https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif) extension\r\n1. In the extension settings page, set the Proxy Servers section to have a single entry, as follows:\r\n   |Scheme|Protocol|Server|Port|\r\n   |------|--------|------|----|\r\n   |(default)|SOCKS5|127.0.0.1|8081|\r\n1. Clear the \"Bypass List\" section in the extension settings page\r\n1. Ensure the above changes are applied by clicking the \"Apply changes\" button in the left column\r\n1. Start a SOCKS5 proxy server on the device. This can be done by entering `ssh 127.0.0.1 -D 8081` on Linux and probably macOS. You're welcome to run it on a different device, but the Proxy Servers setting above will need to be modified accordingly.\r\n1. Add the following line to the `Custom filters` section in brave://adblock:\r\n   ```\r\n   ||dev-pages.brave.software/static/images/test.jpg\r\n   ```\r\n1. Visit https://test-cname.brave.software/cname-uncloaking.html\r\n1. Use the Proxy SwitchyOmega icon in the \"puzzle piece\" extensions menu to enable `proxy` mode (should be the 3rd option).\r\n1. Press the `Run test` button\r\n1. The request should be `allowed` (green).\r\n1. In the \"puzzle piece\" extensions menu, change to `[System Proxy]` and run the test again. The request should be `blocked` (red).\r\n1. In the \"puzzle piece\" extensions menu, change to `[Direct]` and run the test again. The request should be `blocked` (red).",
      "agree that we need a follow-up with tests"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 0.8",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis:\n1. The commit message indicates disabling CNAME uncloaking under specific proxy conditions, suggesting a security-related adjustment.\n2. The code change modifies proxy settings to prevent uncloaking when a SOCKS fallback is present, which could mitigate DNS-related security risks.\n3. The test plan focuses on verifying the behavior under these proxy settings, indicating a functional adjustment with potential security implications.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 0.8"
}