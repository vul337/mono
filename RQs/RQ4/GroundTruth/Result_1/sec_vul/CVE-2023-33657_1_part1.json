{
  "cve_id": "CVE-2023-33657",
  "cwe_ids": [
    "CWE-416"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "nanomq",
  "commit_msg": "* FIX [security] avoid data racing by clone retain msg",
  "commit_hash": "5f57ef45ccfd0f47d815eb62f5f2a619ba7d0633",
  "git_url": "https://github.com/nanomq/nanomq/commit/5f57ef45ccfd0f47d815eb62f5f2a619ba7d0633",
  "file_path": "nanomq/sub_handler.c",
  "func_name": "sub_ctx_handle",
  "func_before": "int\nsub_ctx_handle(nano_work *work)\n{\n\tif (!work->sub_pkt || !work->sub_pkt->node) {\n\t\treturn -1;\n\t}\n\ttopic_node *tn = work->sub_pkt->node;\n\n\tchar *topic_str = NULL;\n\tint   topic_len = 0, topic_exist = 0;\n\n\tif (work->sub_pkt->packet_id == 0) {\n\t\treturn -2;\n\t}\n\n#ifdef STATISTICS\n\t// TODO\n#endif\n\n\tdbtree_retain_msg **r = NULL;\n\n\twhile (tn) {\n\t\ttopic_len = tn->topic.len;\n\t\ttopic_str = tn->topic.body;\n\t\tlog_debug(\"topicLen: [%d] body: [%s]\", topic_len, topic_str);\n\n\t\tif (!topic_str)\n\t\t\tgoto next;\n#ifdef ACL_SUPP\n\t\t/* Add items which not included in dbhash */\n\t\tif (work->config->acl.enable) {\n\t\t\tbool auth_result = auth_acl(\n\t\t\t    work->config, ACL_SUB, work->cparam, topic_str);\n\t\t\tif (!auth_result) {\n\t\t\t\tlog_warn(\"acl deny\");\n\t\t\t\ttn->reason_code = NMQ_AUTH_SUB_ERROR;\n\t\t\t\tif (work->config->acl_deny_action ==\n\t\t\t\t    ACL_DISCONNECT) {\n\t\t\t\t\tlog_warn(\n\t\t\t\t\t    \"acl deny, disconnect client\");\n\t\t\t\t\t// TODO disconnect client or return\n\t\t\t\t\t// error code\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlog_info(\"acl allow\");\n\t\t\t}\n\t\t}\n#endif\n\n\t\ttopic_exist = dbhash_check_topic(work->pid.id, topic_str);\n\t\tif (!topic_exist) {\n\t\t\tdbtree_insert_client(\n\t\t\t    work->db, topic_str, work->pid.id);\n\n\t\t\tdbhash_insert_topic(work->pid.id, topic_str, tn->qos);\n\t\t}\n\n\t\t// Note.\n\t\t// if topic already exists then update sub options.\n\t\t// qos, retain handling, no local (already did in protocol\n\t\t// layer)\n\n\t\t// Retain msg\n\t\tuint8_t rh = tn->retain_handling;\n\n#if defined(NNG_SUPP_SQLITE)\n\t\tif (work->config->sqlite.enable && work->sqlite_db != NULL) {\n\t\t\tif (rh == 0 || (rh == 1 && !topic_exist)) {\n\t\t\t\tnng_msg **msg_vec =\n\t\t\t\t    nng_mqtt_qos_db_find_retain(\n\t\t\t\t        work->sqlite_db, topic_str);\n\n\t\t\t\tif (msg_vec != NULL) {\n\t\t\t\t\tfor (size_t i = 0;\n\t\t\t\t\t     i < cvector_size(msg_vec); i++) {\n\t\t\t\t\t\tif (msg_vec[i] != NULL) {\n\t\t\t\t\t\t\tcvector_push_back(\n\t\t\t\t\t\t\t    work->msg_ret,\n\t\t\t\t\t\t\t    msg_vec[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcvector_free(msg_vec);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgoto next;\n\t\t}\n#endif\n\t\tif (rh == 0 || (rh == 1 && !topic_exist))\n\t\t\tr = dbtree_find_retain(work->db_ret, topic_str);\n\n\t\tif (!r)\n\t\t\tgoto next;\n\n\t\tfor (size_t i = 0; i < cvector_size(r); i++) {\n\t\t\tif (!r[i])\n\t\t\t\tcontinue;\n\t\t\tcvector_push_back(work->msg_ret, r[i]->message);\n\t\t}\n\t\tcvector_free(r);\n\t\tr = NULL;\n\n\tnext:\n\t\ttn = tn->next;\n\t}\n\n#ifdef DEBUG\n\tdbtree_print(work->db);\n#endif\n\tlog_debug(\"end of sub ctx handle.\\n\");\n\treturn 0;\n}",
  "abstract_func_before": "int\nsub_ctx_handle(nano_work *VAR_0)\n{\n\tif (!VAR_0->sub_pkt || !VAR_0->sub_pkt->node) {\n\t\treturn -1;\n\t}\n\ttopic_node *VAR_1 = VAR_0->sub_pkt->node;\n\n\tchar *VAR_2 = NULL;\n\tint   VAR_3 = 0, VAR_4 = 0;\n\n\tif (VAR_0->sub_pkt->packet_id == 0) {\n\t\treturn -2;\n\t}\n\n#ifdef VAR_5\n\t/* COMMENT_0 */\n#endif\n\n\tdbtree_retain_msg **VAR_6 = NULL;\n\n\twhile (VAR_1) {\n\t\tVAR_3 = VAR_1->topic.len;\n\t\tVAR_2 = VAR_1->topic.body;\n\t\tlog_debug(\"topicLen: [%d] body: [%s]\", VAR_3, VAR_2);\n\n\t\tif (!VAR_2)\n\t\t\tgoto next;\n#ifdef VAR_7\n\t\t/* COMMENT_1 */\n\t\tif (VAR_0->config->acl.enable) {\n\t\t\tbool VAR_8 = auth_acl(\n\t\t\t    VAR_0->config, VAR_9, VAR_0->cparam, VAR_2);\n\t\t\tif (!VAR_8) {\n\t\t\t\tlog_warn(\"acl deny\");\n\t\t\t\tVAR_1->reason_code = VAR_10;\n\t\t\t\tif (VAR_0->config->acl_deny_action ==\n\t\t\t\t    VAR_11) {\n\t\t\t\t\tlog_warn(\n\t\t\t\t\t    \"acl deny, disconnect client\");\n\t\t\t\t\t/* COMMENT_2 */\n\t\t\t\t\t/* COMMENT_3 */\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlog_info(\"acl allow\");\n\t\t\t}\n\t\t}\n#endif\n\n\t\tVAR_4 = dbhash_check_topic(VAR_0->pid.id, VAR_2);\n\t\tif (!VAR_4) {\n\t\t\tdbtree_insert_client(\n\t\t\t    VAR_0->db, VAR_2, VAR_0->pid.id);\n\n\t\t\tdbhash_insert_topic(VAR_0->pid.id, VAR_2, VAR_1->qos);\n\t\t}\n\n\t\t/* COMMENT_4 */\n\t\t/* COMMENT_5 */\n\t\t/* COMMENT_6 */\n\t\t/* COMMENT_7 */\n\n\t\t/* COMMENT_8 */\n\t\tuint8_t VAR_12 = VAR_1->retain_handling;\n\n#if defined(VAR_13)\n\t\tif (VAR_0->config->sqlite.enable && VAR_0->sqlite_db != NULL) {\n\t\t\tif (VAR_12 == 0 || (VAR_12 == 1 && !VAR_4)) {\n\t\t\t\tnng_msg **VAR_14 =\n\t\t\t\t    nng_mqtt_qos_db_find_retain(\n\t\t\t\t        VAR_0->sqlite_db, VAR_2);\n\n\t\t\t\tif (VAR_14 != NULL) {\n\t\t\t\t\tfor (size_t VAR_15 = 0;\n\t\t\t\t\t     VAR_15 < cvector_size(VAR_14); VAR_15++) {\n\t\t\t\t\t\tif (VAR_14[VAR_15] != NULL) {\n\t\t\t\t\t\t\tcvector_push_back(\n\t\t\t\t\t\t\t    VAR_0->msg_ret,\n\t\t\t\t\t\t\t    VAR_14[VAR_15]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcvector_free(VAR_14);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgoto next;\n\t\t}\n#endif\n\t\tif (VAR_12 == 0 || (VAR_12 == 1 && !VAR_4))\n\t\t\tVAR_6 = dbtree_find_retain(VAR_0->db_ret, VAR_2);\n\n\t\tif (!VAR_6)\n\t\t\tgoto next;\n\n\t\tfor (size_t VAR_15 = 0; VAR_15 < cvector_size(VAR_6); VAR_15++) {\n\t\t\tif (!VAR_6[VAR_15])\n\t\t\t\tcontinue;\n\t\t\tcvector_push_back(VAR_0->msg_ret, VAR_6[VAR_15]->message);\n\t\t}\n\t\tcvector_free(VAR_6);\n\t\tVAR_6 = NULL;\n\n\tnext:\n\t\tVAR_1 = VAR_1->next;\n\t}\n\n#ifdef VAR_16\n\tdbtree_print(VAR_0->db);\n#endif\n\tlog_debug(\"end of sub ctx handle.\\n\");\n\treturn 0;\n}",
  "func_graph_path_before": "nanomq/5f57ef45ccfd0f47d815eb62f5f2a619ba7d0633/sub_handler.c/vul/before/0.json",
  "func": "int\nsub_ctx_handle(nano_work *work)\n{\n\tif (!work->sub_pkt || !work->sub_pkt->node) {\n\t\treturn -1;\n\t}\n\ttopic_node *tn = work->sub_pkt->node;\n\n\tchar *topic_str = NULL;\n\tint   topic_len = 0, topic_exist = 0;\n\n\tif (work->sub_pkt->packet_id == 0) {\n\t\treturn -2;\n\t}\n\n#ifdef STATISTICS\n\t// TODO\n#endif\n\n\tdbtree_retain_msg **r = NULL;\n\n\twhile (tn) {\n\t\ttopic_len = tn->topic.len;\n\t\ttopic_str = tn->topic.body;\n\t\tlog_debug(\"topicLen: [%d] body: [%s]\", topic_len, topic_str);\n\n\t\tif (!topic_str)\n\t\t\tgoto next;\n#ifdef ACL_SUPP\n\t\t/* Add items which not included in dbhash */\n\t\tif (work->config->acl.enable) {\n\t\t\tbool auth_result = auth_acl(\n\t\t\t    work->config, ACL_SUB, work->cparam, topic_str);\n\t\t\tif (!auth_result) {\n\t\t\t\tlog_warn(\"acl deny\");\n\t\t\t\ttn->reason_code = NMQ_AUTH_SUB_ERROR;\n\t\t\t\tif (work->config->acl_deny_action ==\n\t\t\t\t    ACL_DISCONNECT) {\n\t\t\t\t\tlog_warn(\n\t\t\t\t\t    \"acl deny, disconnect client\");\n\t\t\t\t\t// TODO disconnect client or return\n\t\t\t\t\t// error code\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlog_info(\"acl allow\");\n\t\t\t}\n\t\t}\n#endif\n\n\t\ttopic_exist = dbhash_check_topic(work->pid.id, topic_str);\n\t\tif (!topic_exist) {\n\t\t\tdbtree_insert_client(\n\t\t\t    work->db, topic_str, work->pid.id);\n\n\t\t\tdbhash_insert_topic(work->pid.id, topic_str, tn->qos);\n\t\t}\n\n\t\t// Note.\n\t\t// if topic already exists then update sub options.\n\t\t// qos, retain handling, no local (already did in protocol\n\t\t// layer)\n\n\t\t// Retain msg\n\t\tuint8_t rh = tn->retain_handling;\n\n#if defined(NNG_SUPP_SQLITE)\n\t\tif (work->config->sqlite.enable && work->sqlite_db != NULL) {\n\t\t\tif (rh == 0 || (rh == 1 && !topic_exist)) {\n\t\t\t\tnng_msg **msg_vec =\n\t\t\t\t    nng_mqtt_qos_db_find_retain(\n\t\t\t\t        work->sqlite_db, topic_str);\n\n\t\t\t\tif (msg_vec != NULL) {\n\t\t\t\t\tfor (size_t i = 0;\n\t\t\t\t\t     i < cvector_size(msg_vec); i++) {\n\t\t\t\t\t\tif (msg_vec[i] != NULL) {\n\t\t\t\t\t\t\tcvector_push_back(\n\t\t\t\t\t\t\t    work->msg_ret,\n\t\t\t\t\t\t\t    msg_vec[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcvector_free(msg_vec);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgoto next;\n\t\t}\n#endif\n\t\tif (rh == 0 || (rh == 1 && !topic_exist))\n\t\t\tr = dbtree_find_retain(work->db_ret, topic_str);\n\n\t\tif (!r)\n\t\t\tgoto next;\n\n\t\tfor (size_t i = 0; i < cvector_size(r); i++) {\n\t\t\tif (!r[i])\n\t\t\t\tcontinue;\n\t\t\tnng_msg_clone(r[i]->message);\n\t\t\tcvector_push_back(work->msg_ret, r[i]->message);\n\t\t}\n\t\tcvector_free(r);\n\t\tr = NULL;\n\n\tnext:\n\t\ttn = tn->next;\n\t}\n\n#ifdef DEBUG\n\tdbtree_print(work->db);\n#endif\n\tlog_debug(\"end of sub ctx handle.\\n\");\n\treturn 0;\n}",
  "abstract_func": "int\nsub_ctx_handle(nano_work *VAR_0)\n{\n\tif (!VAR_0->sub_pkt || !VAR_0->sub_pkt->node) {\n\t\treturn -1;\n\t}\n\ttopic_node *VAR_1 = VAR_0->sub_pkt->node;\n\n\tchar *VAR_2 = NULL;\n\tint   VAR_3 = 0, VAR_4 = 0;\n\n\tif (VAR_0->sub_pkt->packet_id == 0) {\n\t\treturn -2;\n\t}\n\n#ifdef VAR_5\n\t/* COMMENT_0 */\n#endif\n\n\tdbtree_retain_msg **VAR_6 = NULL;\n\n\twhile (VAR_1) {\n\t\tVAR_3 = VAR_1->topic.len;\n\t\tVAR_2 = VAR_1->topic.body;\n\t\tlog_debug(\"topicLen: [%d] body: [%s]\", VAR_3, VAR_2);\n\n\t\tif (!VAR_2)\n\t\t\tgoto next;\n#ifdef VAR_7\n\t\t/* COMMENT_1 */\n\t\tif (VAR_0->config->acl.enable) {\n\t\t\tbool VAR_8 = auth_acl(\n\t\t\t    VAR_0->config, VAR_9, VAR_0->cparam, VAR_2);\n\t\t\tif (!VAR_8) {\n\t\t\t\tlog_warn(\"acl deny\");\n\t\t\t\tVAR_1->reason_code = VAR_10;\n\t\t\t\tif (VAR_0->config->acl_deny_action ==\n\t\t\t\t    VAR_11) {\n\t\t\t\t\tlog_warn(\n\t\t\t\t\t    \"acl deny, disconnect client\");\n\t\t\t\t\t/* COMMENT_2 */\n\t\t\t\t\t/* COMMENT_3 */\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlog_info(\"acl allow\");\n\t\t\t}\n\t\t}\n#endif\n\n\t\tVAR_4 = dbhash_check_topic(VAR_0->pid.id, VAR_2);\n\t\tif (!VAR_4) {\n\t\t\tdbtree_insert_client(\n\t\t\t    VAR_0->db, VAR_2, VAR_0->pid.id);\n\n\t\t\tdbhash_insert_topic(VAR_0->pid.id, VAR_2, VAR_1->qos);\n\t\t}\n\n\t\t/* COMMENT_4 */\n\t\t/* COMMENT_5 */\n\t\t/* COMMENT_6 */\n\t\t/* COMMENT_7 */\n\n\t\t/* COMMENT_8 */\n\t\tuint8_t VAR_12 = VAR_1->retain_handling;\n\n#if defined(VAR_13)\n\t\tif (VAR_0->config->sqlite.enable && VAR_0->sqlite_db != NULL) {\n\t\t\tif (VAR_12 == 0 || (VAR_12 == 1 && !VAR_4)) {\n\t\t\t\tnng_msg **VAR_14 =\n\t\t\t\t    nng_mqtt_qos_db_find_retain(\n\t\t\t\t        VAR_0->sqlite_db, VAR_2);\n\n\t\t\t\tif (VAR_14 != NULL) {\n\t\t\t\t\tfor (size_t VAR_15 = 0;\n\t\t\t\t\t     VAR_15 < cvector_size(VAR_14); VAR_15++) {\n\t\t\t\t\t\tif (VAR_14[VAR_15] != NULL) {\n\t\t\t\t\t\t\tcvector_push_back(\n\t\t\t\t\t\t\t    VAR_0->msg_ret,\n\t\t\t\t\t\t\t    VAR_14[VAR_15]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcvector_free(VAR_14);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgoto next;\n\t\t}\n#endif\n\t\tif (VAR_12 == 0 || (VAR_12 == 1 && !VAR_4))\n\t\t\tVAR_6 = dbtree_find_retain(VAR_0->db_ret, VAR_2);\n\n\t\tif (!VAR_6)\n\t\t\tgoto next;\n\n\t\tfor (size_t VAR_15 = 0; VAR_15 < cvector_size(VAR_6); VAR_15++) {\n\t\t\tif (!VAR_6[VAR_15])\n\t\t\t\tcontinue;\n\t\t\tnng_msg_clone(VAR_6[VAR_15]->message);\n\t\t\tcvector_push_back(VAR_0->msg_ret, VAR_6[VAR_15]->message);\n\t\t}\n\t\tcvector_free(VAR_6);\n\t\tVAR_6 = NULL;\n\n\tnext:\n\t\tVAR_1 = VAR_1->next;\n\t}\n\n#ifdef VAR_16\n\tdbtree_print(VAR_0->db);\n#endif\n\tlog_debug(\"end of sub ctx handle.\\n\");\n\treturn 0;\n}",
  "func_graph_path": "nanomq/5f57ef45ccfd0f47d815eb62f5f2a619ba7d0633/sub_handler.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -95,6 +95,7 @@\n \t\tfor (size_t i = 0; i < cvector_size(r); i++) {\n \t\t\tif (!r[i])\n \t\t\t\tcontinue;\n+\t\t\tnng_msg_clone(r[i]->message);\n \t\t\tcvector_push_back(work->msg_ret, r[i]->message);\n \t\t}\n \t\tcvector_free(r);",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "\t\t\tnng_msg_clone(r[i]->message);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/nanomq/nanomq/pull/1187",
  "description": {
    "pr_info": {
      "title": "Fix data racing on retain msg",
      "number": 1187
    },
    "comment": [
      "This is a rarely triggered issue, hardly seen in real business scenario"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix\n\nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\nThe patch addresses a data race by cloning messages to prevent concurrency issues, which is a security concern. The commit message explicitly states it's a security fix, and the code change is a known method to mitigate such vulnerabilities.\n\n**Final Output:**\n\nAnalysis: The patch fixes a data race by cloning messages, preventing potential concurrency issues that could be exploited. The commit message confirms it's a security fix.\n\nFinal Classification: Security Vulnerability Fix\n\nConfidence Score: 0.95"
}