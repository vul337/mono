{
  "cve_id": "CVE-2021-36088",
  "cwe_ids": [
    "CWE-415"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "fluent/fluent-bit",
  "commit_msg": "parser: json: fix double-free (#3453)\n\nSigned-off-by: davkor <david@adalogics.com>",
  "commit_hash": "22346a74c07ceb90296be872be2d53eb92252a54",
  "git_url": "https://github.com/fluent/fluent-bit/commit/22346a74c07ceb90296be872be2d53eb92252a54",
  "file_path": "src/flb_parser_json.c",
  "func_name": "flb_parser_json_do",
  "func_before": "int flb_parser_json_do(struct flb_parser *parser,\n                       const char *in_buf, size_t in_size,\n                       void **out_buf, size_t *out_size,\n                       struct flb_time *out_time)\n{\n    int i;\n    int skip;\n    int ret;\n    int slen;\n    int root_type;\n    int records;\n    double tmfrac = 0;\n    char *mp_buf = NULL;\n    char *time_key;\n    char *tmp_out_buf = NULL;\n    char tmp[255];\n    size_t tmp_out_size = 0;\n    size_t off = 0;\n    size_t map_size;\n    size_t mp_size;\n    size_t len;\n    msgpack_sbuffer mp_sbuf;\n    msgpack_packer  mp_pck;\n    msgpack_unpacked result;\n    msgpack_object map;\n    msgpack_object *k = NULL;\n    msgpack_object *v = NULL;\n    time_t time_lookup;\n    struct tm tm = {0};\n    struct flb_time *t;\n\n    /* Convert incoming in_buf JSON message to message pack format */\n    ret = flb_pack_json_recs(in_buf, in_size, &mp_buf, &mp_size, &root_type,\n                             &records);\n    if (ret != 0) {\n        return -1;\n    }\n\n    if (records != 1) {\n        flb_free(mp_buf);\n        return -1;\n    }\n\n    /* Make sure object is a map */\n    msgpack_unpacked_init(&result);\n    if (msgpack_unpack_next(&result, mp_buf, mp_size, &off) == MSGPACK_UNPACK_SUCCESS) {\n        map = result.data;\n        if (map.type != MSGPACK_OBJECT_MAP) {\n            flb_free(mp_buf);\n            msgpack_unpacked_destroy(&result);\n            return -1;\n        }\n    }\n    else {\n        if (mp_size > 0) {\n            flb_free(mp_buf);\n        }\n        msgpack_unpacked_destroy(&result);\n        return -1;\n    }\n\n    /* Export results (might change later) */\n    tmp_out_buf = mp_buf;\n    tmp_out_size = mp_size;\n\n    /* Do we have some decoders set ? */\n    if (parser->decoders) {\n        ret = flb_parser_decoder_do(parser->decoders,\n                                    mp_buf, mp_size,\n                                    &tmp_out_buf, &tmp_out_size);\n        if (ret == 0) {\n            /* re-process the unpack context */\n            off = 0;\n            msgpack_unpacked_destroy(&result);\n            msgpack_unpacked_init(&result);\n            msgpack_unpack_next(&result, tmp_out_buf, tmp_out_size, &off);\n            map = result.data;\n        }\n    }\n\n    /* Set the possible outgoing buffer */\n    *out_buf = tmp_out_buf;\n    *out_size = tmp_out_size;\n    if (mp_buf != tmp_out_buf) {\n        flb_free(mp_buf);\n    }\n\n    /* Do time resolution ? */\n    if (!parser->time_fmt) {\n        msgpack_unpacked_destroy(&result);\n        return *out_size;\n    }\n\n    if (parser->time_key) {\n        time_key = parser->time_key;\n    }\n    else {\n        time_key = \"time\";\n    }\n    slen = strlen(time_key);\n\n    /* Lookup time field */\n    map_size = map.via.map.size;\n    skip = map_size;\n    for (i = 0; i < map_size; i++) {\n        k = &map.via.map.ptr[i].key;\n        v = &map.via.map.ptr[i].val;\n\n        if (k->via.str.size != slen) {\n            continue;\n        }\n\n        /* Ensure the pointer we are about to read is not NULL */\n        if (k->via.str.ptr == NULL) {\n            flb_free(mp_buf);\n            *out_buf = NULL;\n            msgpack_unpacked_destroy(&result);\n            return -1;\n        }\n\n        if (strncmp(k->via.str.ptr, time_key, k->via.str.size) == 0) {\n            /* We found the key, break the loop and keep the index */\n            if (parser->time_keep == FLB_FALSE) {\n                skip = i;\n                break;\n            }\n            else {\n                skip = -1;\n            }\n            break;\n        }\n\n        k = NULL;\n        v = NULL;\n    }\n\n    /* No time_key field found */\n    if (i >= map_size || !k || !v) {\n        msgpack_unpacked_destroy(&result);\n        return *out_size;\n    }\n\n    /* Ensure we have an accurate type */\n    if (v->type != MSGPACK_OBJECT_STR) {\n        msgpack_unpacked_destroy(&result);\n        return *out_size;\n    }\n\n    /* Lookup time */\n    ret = flb_parser_time_lookup(v->via.str.ptr, v->via.str.size,\n                                 0, parser, &tm, &tmfrac);\n    if (ret == -1) {\n        len = v->via.str.size;\n        if (len > sizeof(tmp) - 1) {\n            len = sizeof(tmp) - 1;\n        }\n        memcpy(tmp, v->via.str.ptr, len);\n        tmp[len] = '\\0';\n        flb_warn(\"[parser:%s] invalid time format %s for '%s'\",\n                 parser->name, parser->time_fmt_full, tmp);\n        time_lookup = 0;\n    }\n    else {\n        time_lookup = flb_parser_tm2time(&tm);\n    }\n\n    /* Compose a new map without the time_key field */\n    msgpack_sbuffer_init(&mp_sbuf);\n    msgpack_packer_init(&mp_pck, &mp_sbuf, msgpack_sbuffer_write);\n\n    if (parser->time_keep == FLB_FALSE) {\n        msgpack_pack_map(&mp_pck, map_size - 1);\n    }\n    else {\n        msgpack_pack_map(&mp_pck, map_size);\n    }\n\n    for (i = 0; i < map_size; i++) {\n        if (i == skip) {\n            continue;\n        }\n        msgpack_pack_object(&mp_pck, map.via.map.ptr[i].key);\n        msgpack_pack_object(&mp_pck, map.via.map.ptr[i].val);\n    }\n\n    /* Export the proper buffer */\n    flb_free(tmp_out_buf);\n    *out_buf = mp_sbuf.data;\n    *out_size = mp_sbuf.size;\n\n    t = out_time;\n    t->tm.tv_sec  = time_lookup;\n    t->tm.tv_nsec = (tmfrac * 1000000000);\n\n    msgpack_unpacked_destroy(&result);\n    return *out_size;\n}",
  "abstract_func_before": "int flb_parser_json_do(struct flb_parser *VAR_0,\n                       const char *VAR_1, size_t VAR_2,\n                       void **VAR_3, size_t *VAR_4,\n                       struct flb_time *VAR_5)\n{\n    int VAR_6;\n    int VAR_7;\n    int VAR_8;\n    int VAR_9;\n    int VAR_10;\n    int VAR_11;\n    double VAR_12 = 0;\n    char *VAR_13 = NULL;\n    char *VAR_14;\n    char *VAR_15 = NULL;\n    char VAR_16[255];\n    size_t VAR_17 = 0;\n    size_t VAR_18 = 0;\n    size_t VAR_19;\n    size_t VAR_20;\n    size_t VAR_21;\n    msgpack_sbuffer VAR_22;\n    msgpack_packer  VAR_23;\n    msgpack_unpacked VAR_24;\n    msgpack_object VAR_25;\n    msgpack_object *VAR_26 = NULL;\n    msgpack_object *VAR_27 = NULL;\n    time_t VAR_28;\n    struct tm tm = {0};\n    struct flb_time *VAR_29;\n\n    /* COMMENT_0 */\n    VAR_8 = flb_pack_json_recs(VAR_1, VAR_2, &VAR_13, &VAR_20, &VAR_10,\n                             &VAR_11);\n    if (VAR_8 != 0) {\n        return -1;\n    }\n\n    if (VAR_11 != 1) {\n        flb_free(VAR_13);\n        return -1;\n    }\n\n    /* COMMENT_1 */\n    msgpack_unpacked_init(&VAR_24);\n    if (msgpack_unpack_next(&VAR_24, VAR_13, VAR_20, &VAR_18) == VAR_30) {\n        VAR_25 = VAR_24.data;\n        if (VAR_25.type != VAR_31) {\n            flb_free(VAR_13);\n            msgpack_unpacked_destroy(&VAR_24);\n            return -1;\n        }\n    }\n    else {\n        if (VAR_20 > 0) {\n            flb_free(VAR_13);\n        }\n        msgpack_unpacked_destroy(&VAR_24);\n        return -1;\n    }\n\n    /* COMMENT_2 */\n    VAR_15 = VAR_13;\n    VAR_17 = VAR_20;\n\n    /* COMMENT_3 */\n    if (VAR_0->decoders) {\n        VAR_8 = flb_parser_decoder_do(VAR_0->decoders,\n                                    VAR_13, VAR_20,\n                                    &VAR_15, &VAR_17);\n        if (VAR_8 == 0) {\n            /* COMMENT_4 */\n            VAR_18 = 0;\n            msgpack_unpacked_destroy(&VAR_24);\n            msgpack_unpacked_init(&VAR_24);\n            msgpack_unpack_next(&VAR_24, VAR_15, VAR_17, &VAR_18);\n            VAR_25 = VAR_24.data;\n        }\n    }\n\n    /* COMMENT_5 */\n    *VAR_3 = VAR_15;\n    *VAR_4 = VAR_17;\n    if (VAR_13 != VAR_15) {\n        flb_free(VAR_13);\n    }\n\n    /* COMMENT_6 */\n    if (!VAR_0->time_fmt) {\n        msgpack_unpacked_destroy(&VAR_24);\n        return *VAR_4;\n    }\n\n    if (VAR_0->time_key) {\n        VAR_14 = VAR_0->time_key;\n    }\n    else {\n        VAR_14 = \"time\";\n    }\n    VAR_9 = strlen(VAR_14);\n\n    /* COMMENT_7 */\n    VAR_19 = VAR_25.via.map.size;\n    VAR_7 = VAR_19;\n    for (VAR_6 = 0; VAR_6 < VAR_19; VAR_6++) {\n        VAR_26 = &VAR_25.via.map.ptr[VAR_6].key;\n        VAR_27 = &VAR_25.via.map.ptr[VAR_6].val;\n\n        if (VAR_26->via.str.size != VAR_9) {\n            continue;\n        }\n\n        /* COMMENT_8 */\n        if (VAR_26->via.str.ptr == NULL) {\n            flb_free(VAR_13);\n            *VAR_3 = NULL;\n            msgpack_unpacked_destroy(&VAR_24);\n            return -1;\n        }\n\n        if (strncmp(VAR_26->via.str.ptr, VAR_14, VAR_26->via.str.size) == 0) {\n            /* COMMENT_9 */\n            if (VAR_0->time_keep == VAR_32) {\n                VAR_7 = VAR_6;\n                break;\n            }\n            else {\n                VAR_7 = -1;\n            }\n            break;\n        }\n\n        VAR_26 = NULL;\n        VAR_27 = NULL;\n    }\n\n    /* COMMENT_10 */\n    if (VAR_6 >= VAR_19 || !VAR_26 || !VAR_27) {\n        msgpack_unpacked_destroy(&VAR_24);\n        return *VAR_4;\n    }\n\n    /* COMMENT_11 */\n    if (VAR_27->type != VAR_33) {\n        msgpack_unpacked_destroy(&VAR_24);\n        return *VAR_4;\n    }\n\n    /* COMMENT_12 */\n    VAR_8 = flb_parser_time_lookup(VAR_27->via.str.ptr, VAR_27->via.str.size,\n                                 0, VAR_0, &tm, &VAR_12);\n    if (VAR_8 == -1) {\n        VAR_21 = VAR_27->via.str.size;\n        if (VAR_21 > sizeof(VAR_16) - 1) {\n            VAR_21 = sizeof(VAR_16) - 1;\n        }\n        memcpy(VAR_16, VAR_27->via.str.ptr, VAR_21);\n        VAR_16[VAR_21] = '\\0';\n        flb_warn(\"[parser:%s] invalid time format %s for '%s'\",\n                 VAR_0->name, VAR_0->time_fmt_full, VAR_16);\n        VAR_28 = 0;\n    }\n    else {\n        VAR_28 = flb_parser_tm2time(&tm);\n    }\n\n    /* COMMENT_13 */\n    msgpack_sbuffer_init(&VAR_22);\n    msgpack_packer_init(&VAR_23, &VAR_22, VAR_34);\n\n    if (VAR_0->time_keep == VAR_32) {\n        msgpack_pack_map(&VAR_23, VAR_19 - 1);\n    }\n    else {\n        msgpack_pack_map(&VAR_23, VAR_19);\n    }\n\n    for (VAR_6 = 0; VAR_6 < VAR_19; VAR_6++) {\n        if (VAR_6 == VAR_7) {\n            continue;\n        }\n        msgpack_pack_object(&VAR_23, VAR_25.via.map.ptr[VAR_6].key);\n        msgpack_pack_object(&VAR_23, VAR_25.via.map.ptr[VAR_6].val);\n    }\n\n    /* COMMENT_14 */\n    flb_free(VAR_15);\n    *VAR_3 = VAR_22.data;\n    *VAR_4 = VAR_22.size;\n\n    VAR_29 = VAR_5;\n    VAR_29->tm.tv_sec  = VAR_28;\n    VAR_29->tm.tv_nsec = (VAR_12 * 1000000000);\n\n    msgpack_unpacked_destroy(&VAR_24);\n    return *VAR_4;\n}",
  "func_graph_path_before": "fluent/fluent-bit/22346a74c07ceb90296be872be2d53eb92252a54/flb_parser_json.c/vul/before/0.json",
  "func": "int flb_parser_json_do(struct flb_parser *parser,\n                       const char *in_buf, size_t in_size,\n                       void **out_buf, size_t *out_size,\n                       struct flb_time *out_time)\n{\n    int i;\n    int skip;\n    int ret;\n    int slen;\n    int root_type;\n    int records;\n    double tmfrac = 0;\n    char *mp_buf = NULL;\n    char *time_key;\n    char *tmp_out_buf = NULL;\n    char tmp[255];\n    size_t tmp_out_size = 0;\n    size_t off = 0;\n    size_t map_size;\n    size_t mp_size;\n    size_t len;\n    msgpack_sbuffer mp_sbuf;\n    msgpack_packer  mp_pck;\n    msgpack_unpacked result;\n    msgpack_object map;\n    msgpack_object *k = NULL;\n    msgpack_object *v = NULL;\n    time_t time_lookup;\n    struct tm tm = {0};\n    struct flb_time *t;\n\n    /* Convert incoming in_buf JSON message to message pack format */\n    ret = flb_pack_json_recs(in_buf, in_size, &mp_buf, &mp_size, &root_type,\n                             &records);\n    if (ret != 0) {\n        return -1;\n    }\n\n    if (records != 1) {\n        flb_free(mp_buf);\n        return -1;\n    }\n\n    /* Make sure object is a map */\n    msgpack_unpacked_init(&result);\n    if (msgpack_unpack_next(&result, mp_buf, mp_size, &off) == MSGPACK_UNPACK_SUCCESS) {\n        map = result.data;\n        if (map.type != MSGPACK_OBJECT_MAP) {\n            flb_free(mp_buf);\n            msgpack_unpacked_destroy(&result);\n            return -1;\n        }\n    }\n    else {\n        if (mp_size > 0) {\n            flb_free(mp_buf);\n        }\n        msgpack_unpacked_destroy(&result);\n        return -1;\n    }\n\n    /* Export results (might change later) */\n    tmp_out_buf = mp_buf;\n    tmp_out_size = mp_size;\n\n    /* Do we have some decoders set ? */\n    if (parser->decoders) {\n        ret = flb_parser_decoder_do(parser->decoders,\n                                    mp_buf, mp_size,\n                                    &tmp_out_buf, &tmp_out_size);\n        if (ret == 0) {\n            /* re-process the unpack context */\n            off = 0;\n            msgpack_unpacked_destroy(&result);\n            msgpack_unpacked_init(&result);\n            msgpack_unpack_next(&result, tmp_out_buf, tmp_out_size, &off);\n            map = result.data;\n        }\n    }\n\n    /* Set the possible outgoing buffer */\n    *out_buf = tmp_out_buf;\n    *out_size = tmp_out_size;\n    if (mp_buf != tmp_out_buf) {\n        flb_free(mp_buf);\n        mp_buf = NULL;\n    }\n\n    /* Do time resolution ? */\n    if (!parser->time_fmt) {\n        msgpack_unpacked_destroy(&result);\n        return *out_size;\n    }\n\n    if (parser->time_key) {\n        time_key = parser->time_key;\n    }\n    else {\n        time_key = \"time\";\n    }\n    slen = strlen(time_key);\n\n    /* Lookup time field */\n    map_size = map.via.map.size;\n    skip = map_size;\n    for (i = 0; i < map_size; i++) {\n        k = &map.via.map.ptr[i].key;\n        v = &map.via.map.ptr[i].val;\n\n        if (k->via.str.size != slen) {\n            continue;\n        }\n\n        /* Ensure the pointer we are about to read is not NULL */\n        if (k->via.str.ptr == NULL) {\n            flb_free(mp_buf);\n            flb_free(tmp_out_buf);\n            *out_buf = NULL;\n            msgpack_unpacked_destroy(&result);\n            return -1;\n        }\n\n        if (strncmp(k->via.str.ptr, time_key, k->via.str.size) == 0) {\n            /* We found the key, break the loop and keep the index */\n            if (parser->time_keep == FLB_FALSE) {\n                skip = i;\n                break;\n            }\n            else {\n                skip = -1;\n            }\n            break;\n        }\n\n        k = NULL;\n        v = NULL;\n    }\n\n    /* No time_key field found */\n    if (i >= map_size || !k || !v) {\n        msgpack_unpacked_destroy(&result);\n        return *out_size;\n    }\n\n    /* Ensure we have an accurate type */\n    if (v->type != MSGPACK_OBJECT_STR) {\n        msgpack_unpacked_destroy(&result);\n        return *out_size;\n    }\n\n    /* Lookup time */\n    ret = flb_parser_time_lookup(v->via.str.ptr, v->via.str.size,\n                                 0, parser, &tm, &tmfrac);\n    if (ret == -1) {\n        len = v->via.str.size;\n        if (len > sizeof(tmp) - 1) {\n            len = sizeof(tmp) - 1;\n        }\n        memcpy(tmp, v->via.str.ptr, len);\n        tmp[len] = '\\0';\n        flb_warn(\"[parser:%s] invalid time format %s for '%s'\",\n                 parser->name, parser->time_fmt_full, tmp);\n        time_lookup = 0;\n    }\n    else {\n        time_lookup = flb_parser_tm2time(&tm);\n    }\n\n    /* Compose a new map without the time_key field */\n    msgpack_sbuffer_init(&mp_sbuf);\n    msgpack_packer_init(&mp_pck, &mp_sbuf, msgpack_sbuffer_write);\n\n    if (parser->time_keep == FLB_FALSE) {\n        msgpack_pack_map(&mp_pck, map_size - 1);\n    }\n    else {\n        msgpack_pack_map(&mp_pck, map_size);\n    }\n\n    for (i = 0; i < map_size; i++) {\n        if (i == skip) {\n            continue;\n        }\n        msgpack_pack_object(&mp_pck, map.via.map.ptr[i].key);\n        msgpack_pack_object(&mp_pck, map.via.map.ptr[i].val);\n    }\n\n    /* Export the proper buffer */\n    flb_free(tmp_out_buf);\n    *out_buf = mp_sbuf.data;\n    *out_size = mp_sbuf.size;\n\n    t = out_time;\n    t->tm.tv_sec  = time_lookup;\n    t->tm.tv_nsec = (tmfrac * 1000000000);\n\n    msgpack_unpacked_destroy(&result);\n    return *out_size;\n}",
  "abstract_func": "int flb_parser_json_do(struct flb_parser *VAR_0,\n                       const char *VAR_1, size_t VAR_2,\n                       void **VAR_3, size_t *VAR_4,\n                       struct flb_time *VAR_5)\n{\n    int VAR_6;\n    int VAR_7;\n    int VAR_8;\n    int VAR_9;\n    int VAR_10;\n    int VAR_11;\n    double VAR_12 = 0;\n    char *VAR_13 = NULL;\n    char *VAR_14;\n    char *VAR_15 = NULL;\n    char VAR_16[255];\n    size_t VAR_17 = 0;\n    size_t VAR_18 = 0;\n    size_t VAR_19;\n    size_t VAR_20;\n    size_t VAR_21;\n    msgpack_sbuffer VAR_22;\n    msgpack_packer  VAR_23;\n    msgpack_unpacked VAR_24;\n    msgpack_object VAR_25;\n    msgpack_object *VAR_26 = NULL;\n    msgpack_object *VAR_27 = NULL;\n    time_t VAR_28;\n    struct tm tm = {0};\n    struct flb_time *VAR_29;\n\n    /* COMMENT_0 */\n    VAR_8 = flb_pack_json_recs(VAR_1, VAR_2, &VAR_13, &VAR_20, &VAR_10,\n                             &VAR_11);\n    if (VAR_8 != 0) {\n        return -1;\n    }\n\n    if (VAR_11 != 1) {\n        flb_free(VAR_13);\n        return -1;\n    }\n\n    /* COMMENT_1 */\n    msgpack_unpacked_init(&VAR_24);\n    if (msgpack_unpack_next(&VAR_24, VAR_13, VAR_20, &VAR_18) == VAR_30) {\n        VAR_25 = VAR_24.data;\n        if (VAR_25.type != VAR_31) {\n            flb_free(VAR_13);\n            msgpack_unpacked_destroy(&VAR_24);\n            return -1;\n        }\n    }\n    else {\n        if (VAR_20 > 0) {\n            flb_free(VAR_13);\n        }\n        msgpack_unpacked_destroy(&VAR_24);\n        return -1;\n    }\n\n    /* COMMENT_2 */\n    VAR_15 = VAR_13;\n    VAR_17 = VAR_20;\n\n    /* COMMENT_3 */\n    if (VAR_0->decoders) {\n        VAR_8 = flb_parser_decoder_do(VAR_0->decoders,\n                                    VAR_13, VAR_20,\n                                    &VAR_15, &VAR_17);\n        if (VAR_8 == 0) {\n            /* COMMENT_4 */\n            VAR_18 = 0;\n            msgpack_unpacked_destroy(&VAR_24);\n            msgpack_unpacked_init(&VAR_24);\n            msgpack_unpack_next(&VAR_24, VAR_15, VAR_17, &VAR_18);\n            VAR_25 = VAR_24.data;\n        }\n    }\n\n    /* COMMENT_5 */\n    *VAR_3 = VAR_15;\n    *VAR_4 = VAR_17;\n    if (VAR_13 != VAR_15) {\n        flb_free(VAR_13);\n        VAR_13 = NULL;\n    }\n\n    /* COMMENT_6 */\n    if (!VAR_0->time_fmt) {\n        msgpack_unpacked_destroy(&VAR_24);\n        return *VAR_4;\n    }\n\n    if (VAR_0->time_key) {\n        VAR_14 = VAR_0->time_key;\n    }\n    else {\n        VAR_14 = \"time\";\n    }\n    VAR_9 = strlen(VAR_14);\n\n    /* COMMENT_7 */\n    VAR_19 = VAR_25.via.map.size;\n    VAR_7 = VAR_19;\n    for (VAR_6 = 0; VAR_6 < VAR_19; VAR_6++) {\n        VAR_26 = &VAR_25.via.map.ptr[VAR_6].key;\n        VAR_27 = &VAR_25.via.map.ptr[VAR_6].val;\n\n        if (VAR_26->via.str.size != VAR_9) {\n            continue;\n        }\n\n        /* COMMENT_8 */\n        if (VAR_26->via.str.ptr == NULL) {\n            flb_free(VAR_13);\n            flb_free(VAR_15);\n            *VAR_3 = NULL;\n            msgpack_unpacked_destroy(&VAR_24);\n            return -1;\n        }\n\n        if (strncmp(VAR_26->via.str.ptr, VAR_14, VAR_26->via.str.size) == 0) {\n            /* COMMENT_9 */\n            if (VAR_0->time_keep == VAR_32) {\n                VAR_7 = VAR_6;\n                break;\n            }\n            else {\n                VAR_7 = -1;\n            }\n            break;\n        }\n\n        VAR_26 = NULL;\n        VAR_27 = NULL;\n    }\n\n    /* COMMENT_10 */\n    if (VAR_6 >= VAR_19 || !VAR_26 || !VAR_27) {\n        msgpack_unpacked_destroy(&VAR_24);\n        return *VAR_4;\n    }\n\n    /* COMMENT_11 */\n    if (VAR_27->type != VAR_33) {\n        msgpack_unpacked_destroy(&VAR_24);\n        return *VAR_4;\n    }\n\n    /* COMMENT_12 */\n    VAR_8 = flb_parser_time_lookup(VAR_27->via.str.ptr, VAR_27->via.str.size,\n                                 0, VAR_0, &tm, &VAR_12);\n    if (VAR_8 == -1) {\n        VAR_21 = VAR_27->via.str.size;\n        if (VAR_21 > sizeof(VAR_16) - 1) {\n            VAR_21 = sizeof(VAR_16) - 1;\n        }\n        memcpy(VAR_16, VAR_27->via.str.ptr, VAR_21);\n        VAR_16[VAR_21] = '\\0';\n        flb_warn(\"[parser:%s] invalid time format %s for '%s'\",\n                 VAR_0->name, VAR_0->time_fmt_full, VAR_16);\n        VAR_28 = 0;\n    }\n    else {\n        VAR_28 = flb_parser_tm2time(&tm);\n    }\n\n    /* COMMENT_13 */\n    msgpack_sbuffer_init(&VAR_22);\n    msgpack_packer_init(&VAR_23, &VAR_22, VAR_34);\n\n    if (VAR_0->time_keep == VAR_32) {\n        msgpack_pack_map(&VAR_23, VAR_19 - 1);\n    }\n    else {\n        msgpack_pack_map(&VAR_23, VAR_19);\n    }\n\n    for (VAR_6 = 0; VAR_6 < VAR_19; VAR_6++) {\n        if (VAR_6 == VAR_7) {\n            continue;\n        }\n        msgpack_pack_object(&VAR_23, VAR_25.via.map.ptr[VAR_6].key);\n        msgpack_pack_object(&VAR_23, VAR_25.via.map.ptr[VAR_6].val);\n    }\n\n    /* COMMENT_14 */\n    flb_free(VAR_15);\n    *VAR_3 = VAR_22.data;\n    *VAR_4 = VAR_22.size;\n\n    VAR_29 = VAR_5;\n    VAR_29->tm.tv_sec  = VAR_28;\n    VAR_29->tm.tv_nsec = (VAR_12 * 1000000000);\n\n    msgpack_unpacked_destroy(&VAR_24);\n    return *VAR_4;\n}",
  "func_graph_path": "fluent/fluent-bit/22346a74c07ceb90296be872be2d53eb92252a54/flb_parser_json.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -83,6 +83,7 @@\n     *out_size = tmp_out_size;\n     if (mp_buf != tmp_out_buf) {\n         flb_free(mp_buf);\n+        mp_buf = NULL;\n     }\n \n     /* Do time resolution ? */\n@@ -113,6 +114,7 @@\n         /* Ensure the pointer we are about to read is not NULL */\n         if (k->via.str.ptr == NULL) {\n             flb_free(mp_buf);\n+            flb_free(tmp_out_buf);\n             *out_buf = NULL;\n             msgpack_unpacked_destroy(&result);\n             return -1;",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "        mp_buf = NULL;",
      "            flb_free(tmp_out_buf);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/fluent/fluent-bit/pull/3453",
  "description": {
    "pr_info": {
      "title": "flb: parse-json: fix double-free",
      "number": 3453
    },
    "comment": [
      "Signed-off-by: davkor <david@adalogics.com>\r\n\r\n<!-- Provide summary of changes -->\r\nFixes a double free:\r\n- Bug tracker: https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=33750\r\n- OSS-Fuzz report: https://oss-fuzz.com/testcase-detail/5216297967288320\r\n<!-- Issue number, if available. E.g. \"Fixes #31\", \"Addresses #42, #77\" -->\r\n\r\n----\r\nEnter `[N/A]` in the box, if an item is not applicable to your change.\r\n\r\n**Testing**\r\nBefore we can approve your change; please submit the following in a comment:\r\n- [N/A ] Example configuration file for the change\r\n- [N/A ] Debug log output from testing the change\r\n<!-- Invoke Fluent Bit and Valgrind as: $ valgrind ./bin/fluent-bit <args> -->\r\n- [N/A ] Attached [Valgrind](https://valgrind.org/docs/manual/quick-start.html) output that shows no leaks or memory corruption was found\r\n\r\n**Documentation**\r\n<!-- Docs can be edited at https://github.com/fluent/fluent-bit-docs -->\r\n- [N/A ] Documentation required for this feature\r\n\r\n<!--  Doc PR (not required but highly recommended) -->\r\n\r\n----\r\n\r\nFluent Bit is licensed under Apache 2.0, by submitting this pull request I understand that this code will be released under the terms of that license.\r\n",
      "@edsiper @nokute78 it seems the CI is failing due to issues unrelated to the PR. ",
      "thanks"
    ]
  },
  "Bug Filter": "** Security Vulnerability Fix  \n**Confidence Score:** 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\nThe patch addresses a double-free vulnerability, which can lead to memory corruption and potential security exploits. The code changes prevent freeing the same memory twice by correctly managing pointers and ensuring proper cleanup.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 1.0"
}