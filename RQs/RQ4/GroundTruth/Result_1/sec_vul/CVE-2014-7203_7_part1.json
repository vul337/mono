{
  "cve_id": "CVE-2014-7203",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "zeromq/libzmq",
  "commit_msg": "Problem: curve messages can be replayed\n\nSolution: ensure message short nonces are strictly increasing and validate them",
  "commit_hash": "0900a489213d74feb86fc0b343308fe7884a2a3c",
  "git_url": "https://github.com/zeromq/libzmq/commit/0900a489213d74feb86fc0b343308fe7884a2a3c",
  "file_path": "src/curve_server.cpp",
  "func_name": "zmq::curve_server_t::decode",
  "func_before": "int zmq::curve_server_t::decode (msg_t *msg_)\n{\n    zmq_assert (state == connected);\n\n    if (msg_->size () < 33) {\n        //  Temporary support for security debugging\n        puts (\"CURVE I: invalid CURVE client, sent malformed command\");\n        errno = EPROTO;\n        return -1;\n    }\n\n    const uint8_t *message = static_cast <uint8_t *> (msg_->data ());\n    if (memcmp (message, \"\\x07MESSAGE\", 8)) {\n        //  Temporary support for security debugging\n        puts (\"CURVE I: invalid CURVE client, did not send MESSAGE\");\n        errno = EPROTO;\n        return -1;\n    }\n\n    uint8_t message_nonce [crypto_box_NONCEBYTES];\n    memcpy (message_nonce, \"CurveZMQMESSAGEC\", 16);\n    memcpy (message_nonce + 16, message + 8, 8);\n\n    const size_t clen = crypto_box_BOXZEROBYTES + msg_->size () - 16;\n\n    uint8_t *message_plaintext = static_cast <uint8_t *> (malloc (clen));\n    alloc_assert (message_plaintext);\n\n    uint8_t *message_box = static_cast <uint8_t *> (malloc (clen));\n    alloc_assert (message_box);\n\n    memset (message_box, 0, crypto_box_BOXZEROBYTES);\n    memcpy (message_box + crypto_box_BOXZEROBYTES,\n            message + 16, msg_->size () - 16);\n\n    int rc = crypto_box_open_afternm (message_plaintext, message_box,\n                                      clen, message_nonce, cn_precom);\n    if (rc == 0) {\n        rc = msg_->close ();\n        zmq_assert (rc == 0);\n\n        rc = msg_->init_size (clen - 1 - crypto_box_ZEROBYTES);\n        zmq_assert (rc == 0);\n\n        const uint8_t flags = message_plaintext [crypto_box_ZEROBYTES];\n        if (flags & 0x01)\n            msg_->set_flags (msg_t::more);\n\n        memcpy (msg_->data (),\n                message_plaintext + crypto_box_ZEROBYTES + 1,\n                msg_->size ());\n    }\n    else {\n        //  Temporary support for security debugging\n        puts (\"CURVE I: connection key used for MESSAGE is wrong\");\n        errno = EPROTO;\n    }\n    free (message_plaintext);\n    free (message_box);\n\n    return rc;\n}",
  "abstract_func_before": "int zmq::curve_server_t::decode (msg_t *VAR_0)\n{\n    zmq_assert (VAR_1 == VAR_2);\n\n    if (VAR_0->size () < 33) {\n        /* COMMENT_0 */\n        puts (\"CURVE I: invalid CURVE client, sent malformed command\");\n        VAR_3 = VAR_4;\n        return -1;\n    }\n\n    const uint8_t *VAR_5 = VAR_6 <uint8_t *> (VAR_0->data ());\n    if (memcmp (VAR_5, \"\\x07MESSAGE\", 8)) {\n        /* COMMENT_0 */\n        puts (\"CURVE I: invalid CURVE client, did not send MESSAGE\");\n        VAR_3 = VAR_4;\n        return -1;\n    }\n\n    uint8_t VAR_7 [VAR_8];\n    memcpy (VAR_7, \"CurveZMQMESSAGEC\", 16);\n    memcpy (VAR_7 + 16, VAR_5 + 8, 8);\n\n    const size_t VAR_9 = VAR_10 + VAR_0->size () - 16;\n\n    uint8_t *VAR_11 = VAR_6 <uint8_t *> (malloc (VAR_9));\n    alloc_assert (VAR_11);\n\n    uint8_t *VAR_12 = VAR_6 <uint8_t *> (malloc (VAR_9));\n    alloc_assert (VAR_12);\n\n    memset (VAR_12, 0, VAR_10);\n    memcpy (VAR_12 + VAR_10,\n            VAR_5 + 16, VAR_0->size () - 16);\n\n    int VAR_13 = crypto_box_open_afternm (VAR_11, VAR_12,\n                                      VAR_9, VAR_7, VAR_14);\n    if (VAR_13 == 0) {\n        VAR_13 = VAR_0->close ();\n        zmq_assert (VAR_13 == 0);\n\n        VAR_13 = VAR_0->init_size (VAR_9 - 1 - VAR_15);\n        zmq_assert (VAR_13 == 0);\n\n        const uint8_t VAR_16 = VAR_11 [VAR_15];\n        if (VAR_16 & 0x01)\n            VAR_0->set_flags (msg_t::more);\n\n        memcpy (VAR_0->data (),\n                VAR_11 + VAR_15 + 1,\n                VAR_0->size ());\n    }\n    else {\n        /* COMMENT_0 */\n        puts (\"CURVE I: connection key used for MESSAGE is wrong\");\n        VAR_3 = VAR_4;\n    }\n    free (VAR_11);\n    free (VAR_12);\n\n    return VAR_13;\n}",
  "func_graph_path_before": "zeromq/libzmq/0900a489213d74feb86fc0b343308fe7884a2a3c/curve_server.cpp/vul/before/2.json",
  "func": "int zmq::curve_server_t::decode (msg_t *msg_)\n{\n    zmq_assert (state == connected);\n\n    if (msg_->size () < 33) {\n        //  Temporary support for security debugging\n        puts (\"CURVE I: invalid CURVE client, sent malformed command\");\n        errno = EPROTO;\n        return -1;\n    }\n\n    const uint8_t *message = static_cast <uint8_t *> (msg_->data ());\n    if (memcmp (message, \"\\x07MESSAGE\", 8)) {\n        //  Temporary support for security debugging\n        puts (\"CURVE I: invalid CURVE client, did not send MESSAGE\");\n        errno = EPROTO;\n        return -1;\n    }\n\n    uint8_t message_nonce [crypto_box_NONCEBYTES];\n    memcpy (message_nonce, \"CurveZMQMESSAGEC\", 16);\n    memcpy (message_nonce + 16, message + 8, 8);\n    uint64_t nonce = get_uint64(message + 8);\n    if (nonce <= cn_peer_nonce) {\n        errno = EPROTO;\n        return -1;\n    }\n    cn_peer_nonce = nonce;\n\n    const size_t clen = crypto_box_BOXZEROBYTES + msg_->size () - 16;\n\n    uint8_t *message_plaintext = static_cast <uint8_t *> (malloc (clen));\n    alloc_assert (message_plaintext);\n\n    uint8_t *message_box = static_cast <uint8_t *> (malloc (clen));\n    alloc_assert (message_box);\n\n    memset (message_box, 0, crypto_box_BOXZEROBYTES);\n    memcpy (message_box + crypto_box_BOXZEROBYTES,\n            message + 16, msg_->size () - 16);\n\n    int rc = crypto_box_open_afternm (message_plaintext, message_box,\n                                      clen, message_nonce, cn_precom);\n    if (rc == 0) {\n        rc = msg_->close ();\n        zmq_assert (rc == 0);\n\n        rc = msg_->init_size (clen - 1 - crypto_box_ZEROBYTES);\n        zmq_assert (rc == 0);\n\n        const uint8_t flags = message_plaintext [crypto_box_ZEROBYTES];\n        if (flags & 0x01)\n            msg_->set_flags (msg_t::more);\n\n        memcpy (msg_->data (),\n                message_plaintext + crypto_box_ZEROBYTES + 1,\n                msg_->size ());\n    }\n    else {\n        //  Temporary support for security debugging\n        puts (\"CURVE I: connection key used for MESSAGE is wrong\");\n        errno = EPROTO;\n    }\n    free (message_plaintext);\n    free (message_box);\n\n    return rc;\n}",
  "abstract_func": "int zmq::curve_server_t::decode (msg_t *VAR_0)\n{\n    zmq_assert (VAR_1 == VAR_2);\n\n    if (VAR_0->size () < 33) {\n        /* COMMENT_0 */\n        puts (\"CURVE I: invalid CURVE client, sent malformed command\");\n        VAR_3 = VAR_4;\n        return -1;\n    }\n\n    const uint8_t *VAR_5 = VAR_6 <uint8_t *> (VAR_0->data ());\n    if (memcmp (VAR_5, \"\\x07MESSAGE\", 8)) {\n        /* COMMENT_0 */\n        puts (\"CURVE I: invalid CURVE client, did not send MESSAGE\");\n        VAR_3 = VAR_4;\n        return -1;\n    }\n\n    uint8_t VAR_7 [VAR_8];\n    memcpy (VAR_7, \"CurveZMQMESSAGEC\", 16);\n    memcpy (VAR_7 + 16, VAR_5 + 8, 8);\n    uint64_t VAR_9 = get_uint64(VAR_5 + 8);\n    if (VAR_9 <= VAR_10) {\n        VAR_3 = VAR_4;\n        return -1;\n    }\n    VAR_10 = VAR_9;\n\n    const size_t VAR_11 = VAR_12 + VAR_0->size () - 16;\n\n    uint8_t *VAR_13 = VAR_6 <uint8_t *> (malloc (VAR_11));\n    alloc_assert (VAR_13);\n\n    uint8_t *VAR_14 = VAR_6 <uint8_t *> (malloc (VAR_11));\n    alloc_assert (VAR_14);\n\n    memset (VAR_14, 0, VAR_12);\n    memcpy (VAR_14 + VAR_12,\n            VAR_5 + 16, VAR_0->size () - 16);\n\n    int VAR_15 = crypto_box_open_afternm (VAR_13, VAR_14,\n                                      VAR_11, VAR_7, VAR_16);\n    if (VAR_15 == 0) {\n        VAR_15 = VAR_0->close ();\n        zmq_assert (VAR_15 == 0);\n\n        VAR_15 = VAR_0->init_size (VAR_11 - 1 - VAR_17);\n        zmq_assert (VAR_15 == 0);\n\n        const uint8_t VAR_18 = VAR_13 [VAR_17];\n        if (VAR_18 & 0x01)\n            VAR_0->set_flags (msg_t::more);\n\n        memcpy (VAR_0->data (),\n                VAR_13 + VAR_17 + 1,\n                VAR_0->size ());\n    }\n    else {\n        /* COMMENT_0 */\n        puts (\"CURVE I: connection key used for MESSAGE is wrong\");\n        VAR_3 = VAR_4;\n    }\n    free (VAR_13);\n    free (VAR_14);\n\n    return VAR_15;\n}",
  "func_graph_path": "zeromq/libzmq/0900a489213d74feb86fc0b343308fe7884a2a3c/curve_server.cpp/vul/after/2.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -20,6 +20,12 @@\n     uint8_t message_nonce [crypto_box_NONCEBYTES];\n     memcpy (message_nonce, \"CurveZMQMESSAGEC\", 16);\n     memcpy (message_nonce + 16, message + 8, 8);\n+    uint64_t nonce = get_uint64(message + 8);\n+    if (nonce <= cn_peer_nonce) {\n+        errno = EPROTO;\n+        return -1;\n+    }\n+    cn_peer_nonce = nonce;\n \n     const size_t clen = crypto_box_BOXZEROBYTES + msg_->size () - 16;\n ",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "    uint64_t nonce = get_uint64(message + 8);",
      "    if (nonce <= cn_peer_nonce) {",
      "        errno = EPROTO;",
      "        return -1;",
      "    }",
      "    cn_peer_nonce = nonce;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/zeromq/libzmq/pull/1189",
  "description": {
    "pr_info": {
      "title": "Problem: curve messages can be replayed",
      "number": 1189
    },
    "comment": [
      "Solution: ensure message short nonces are strictly increasing and validate them\n",
      "Fixes #1191.\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix\n\nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses a security issue where curve messages could be replayed. The code changes enforce a strict nonce increment to prevent replay attacks, which could lead to unauthorized access or denial of service.\n\nFinal Classification: Security Vulnerability Fix\n\nConfidence Score: 1.0"
}