{
  "cve_id": "CVE-2022-38667",
  "cwe_ids": [
    "CWE-416"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "CrowCpp/Crow",
  "commit_msg": "Prevent HTTP pipelining which Crow doesn't support.",
  "commit_hash": "fba01dc76d6ea940ad7c8392e8f39f9647241d8e",
  "git_url": "https://github.com/CrowCpp/Crow/commit/fba01dc76d6ea940ad7c8392e8f39f9647241d8e",
  "file_path": "include/crow/http_connection.h",
  "func_name": "do_write_general",
  "func_before": "void do_write_general()\n        {\n            if (res.body.length() < res_stream_threshold_)\n            {\n                res_body_copy_.swap(res.body);\n                buffers_.emplace_back(res_body_copy_.data(), res_body_copy_.size());\n\n                do_write();\n\n                if (need_to_start_read_after_complete_)\n                {\n                    need_to_start_read_after_complete_ = false;\n                    start_deadline();\n                    do_read();\n                }\n            }\n            else\n            {\n                is_writing = true;\n                asio::write(adaptor_.socket(), buffers_); // Write the response start / headers\n                cancel_deadline_timer();\n                if (res.body.length() > 0)\n                {\n                    std::string buf;\n                    std::vector<asio::const_buffer> buffers;\n\n                    while (res.body.length() > 16384)\n                    {\n                        //buf.reserve(16385);\n                        buf = res.body.substr(0, 16384);\n                        res.body = res.body.substr(16384);\n                        buffers.clear();\n                        buffers.push_back(asio::buffer(buf));\n                        do_write_sync(buffers);\n                    }\n                    // Collect whatever is left (less than 16KB) and send it down the socket\n                    // buf.reserve(is.length());\n                    buf = res.body;\n                    res.body.clear();\n\n                    buffers.clear();\n                    buffers.push_back(asio::buffer(buf));\n                    do_write_sync(buffers);\n                }\n                is_writing = false;\n                if (close_connection_)\n                {\n                    adaptor_.shutdown_readwrite();\n                    adaptor_.close();\n                    CROW_LOG_DEBUG << this << \" from write (res_stream)\";\n                    check_destroy();\n                }\n\n                res.end();\n                res.clear();\n                buffers_.clear();\n            }\n        }",
  "abstract_func_before": "void do_write_general()\n        {\n            if (VAR_0.body.length() < VAR_1)\n            {\n                VAR_2.swap(VAR_0.body);\n                VAR_3.emplace_back(VAR_2.data(), VAR_2.size());\n\n                do_write();\n\n                if (VAR_4)\n                {\n                    VAR_4 = false;\n                    start_deadline();\n                    do_read();\n                }\n            }\n            else\n            {\n                VAR_5 = true;\n                asio::write(VAR_6.socket(), VAR_3); /* COMMENT_0 */\n                cancel_deadline_timer();\n                if (VAR_0.body.length() > 0)\n                {\n                    std::string VAR_7;\n                    std::vector<asio::const_buffer> VAR_8;\n\n                    while (VAR_0.body.length() > 16384)\n                    {\n                        /* COMMENT_1 */\n                        VAR_7 = VAR_0.body.substr(0, 16384);\n                        VAR_0.body = VAR_0.body.substr(16384);\n                        VAR_8.clear();\n                        VAR_8.push_back(asio::buffer(VAR_7));\n                        do_write_sync(VAR_8);\n                    }\n                    /* COMMENT_2 */\n                    /* COMMENT_3 */\n                    VAR_7 = VAR_0.body;\n                    VAR_0.body.clear();\n\n                    VAR_8.clear();\n                    VAR_8.push_back(asio::buffer(VAR_7));\n                    do_write_sync(VAR_8);\n                }\n                VAR_5 = false;\n                if (VAR_9)\n                {\n                    VAR_6.shutdown_readwrite();\n                    VAR_6.close();\n                    VAR_10 << this << \" from write (res_stream)\";\n                    check_destroy();\n                }\n\n                VAR_0.end();\n                VAR_0.clear();\n                VAR_3.clear();\n            }\n        }",
  "func_graph_path_before": "CrowCpp/Crow/fba01dc76d6ea940ad7c8392e8f39f9647241d8e/http_connection.h/vul/before/0.json",
  "func": "void do_write_general()\n        {\n            if (res.body.length() < res_stream_threshold_)\n            {\n                res_body_copy_.swap(res.body);\n                buffers_.emplace_back(res_body_copy_.data(), res_body_copy_.size());\n\n                do_write();\n\n                if (need_to_start_read_after_complete_)\n                {\n                    need_to_start_read_after_complete_ = false;\n                    start_deadline();\n                    do_read();\n                }\n            }\n            else\n            {\n                is_writing = true;\n                asio::write(adaptor_.socket(), buffers_); // Write the response start / headers\n                cancel_deadline_timer();\n                if (res.body.length() > 0)\n                {\n                    std::string buf;\n                    std::vector<asio::const_buffer> buffers;\n\n                    while (res.body.length() > 16384)\n                    {\n                        //buf.reserve(16385);\n                        buf = res.body.substr(0, 16384);\n                        res.body = res.body.substr(16384);\n                        buffers.clear();\n                        buffers.push_back(asio::buffer(buf));\n                        do_write_sync(buffers);\n                    }\n                    // Collect whatever is left (less than 16KB) and send it down the socket\n                    // buf.reserve(is.length());\n                    buf = res.body;\n                    res.body.clear();\n\n                    buffers.clear();\n                    buffers.push_back(asio::buffer(buf));\n                    do_write_sync(buffers);\n                }\n                is_writing = false;\n                if (close_connection_)\n                {\n                    adaptor_.shutdown_readwrite();\n                    adaptor_.close();\n                    CROW_LOG_DEBUG << this << \" from write (res_stream)\";\n                    check_destroy();\n                }\n\n                res.end();\n                res.clear();\n                buffers_.clear();\n                parser_.clear();\n            }\n        }",
  "abstract_func": "void do_write_general()\n        {\n            if (VAR_0.body.length() < VAR_1)\n            {\n                VAR_2.swap(VAR_0.body);\n                VAR_3.emplace_back(VAR_2.data(), VAR_2.size());\n\n                do_write();\n\n                if (VAR_4)\n                {\n                    VAR_4 = false;\n                    start_deadline();\n                    do_read();\n                }\n            }\n            else\n            {\n                VAR_5 = true;\n                asio::write(VAR_6.socket(), VAR_3); /* COMMENT_0 */\n                cancel_deadline_timer();\n                if (VAR_0.body.length() > 0)\n                {\n                    std::string VAR_7;\n                    std::vector<asio::const_buffer> VAR_8;\n\n                    while (VAR_0.body.length() > 16384)\n                    {\n                        /* COMMENT_1 */\n                        VAR_7 = VAR_0.body.substr(0, 16384);\n                        VAR_0.body = VAR_0.body.substr(16384);\n                        VAR_8.clear();\n                        VAR_8.push_back(asio::buffer(VAR_7));\n                        do_write_sync(VAR_8);\n                    }\n                    /* COMMENT_2 */\n                    /* COMMENT_3 */\n                    VAR_7 = VAR_0.body;\n                    VAR_0.body.clear();\n\n                    VAR_8.clear();\n                    VAR_8.push_back(asio::buffer(VAR_7));\n                    do_write_sync(VAR_8);\n                }\n                VAR_5 = false;\n                if (VAR_9)\n                {\n                    VAR_6.shutdown_readwrite();\n                    VAR_6.close();\n                    VAR_10 << this << \" from write (res_stream)\";\n                    check_destroy();\n                }\n\n                VAR_0.end();\n                VAR_0.clear();\n                VAR_3.clear();\n                VAR_11.clear();\n            }\n        }",
  "func_graph_path": "CrowCpp/Crow/fba01dc76d6ea940ad7c8392e8f39f9647241d8e/http_connection.h/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -54,5 +54,6 @@\n                 res.end();\n                 res.clear();\n                 buffers_.clear();\n+                parser_.clear();\n             }\n         }",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "                parser_.clear();"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/CrowCpp/Crow/pull/524",
  "description": {
    "pr_info": {
      "title": "Prevent HTTP pipelining",
      "number": 524
    },
    "comment": [
      "Fixes a potential use-after-free vulnerability where using HTTP pipelining could cause Crow to execute code related to a connection after deleting it.\r\n\r\nIt also fixes a small bug where websocket connections could be established with invalid HTTP requests (ones that don't have a `Host` header)\r\n\r\nThanks to hebi Gynvael Coldwind for discovering and reporting the vulnerability."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\nThe patch addresses a security vulnerability by preventing a use-after-free condition in HTTP pipelining, thus securing the system against potential exploitation.\n\n**Final Output:**\nAnalysis: The patch resolves a use-after-free vulnerability in HTTP pipelining, preventing code execution after connection deletion. It also fixes an issue with websocket connections. The code changes directly address the security issue.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 1.0"
}