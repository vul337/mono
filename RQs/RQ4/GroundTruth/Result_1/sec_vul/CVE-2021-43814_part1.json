{
  "cve_id": "CVE-2021-43814",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "rizinorg/rizin",
  "commit_msg": "Fix oob write for dwarf with abbrev with count 0 (Fix #2083) (#2086)",
  "commit_hash": "aa6917772d2f32e5a7daab25a46c72df0b5ea406",
  "git_url": "https://github.com/rizinorg/rizin/commit/aa6917772d2f32e5a7daab25a46c72df0b5ea406",
  "file_path": "librz/bin/dwarf.c",
  "func_name": "parse_die",
  "func_before": "static const ut8 *parse_die(const ut8 *buf, const ut8 *buf_end, RzBinDwarfDebugInfo *info, RzBinDwarfAbbrevDecl *abbrev,\n\tRzBinDwarfCompUnitHdr *hdr, RzBinDwarfDie *die, const ut8 *debug_str, size_t debug_str_len, bool big_endian) {\n\tsize_t i;\n\tconst char *comp_dir = NULL;\n\tut64 line_info_offset = UT64_MAX;\n\tfor (i = 0; i < abbrev->count - 1; i++) {\n\t\tmemset(&die->attr_values[i], 0, sizeof(die->attr_values[i]));\n\n\t\tbuf = parse_attr_value(buf, buf_end - buf, &abbrev->defs[i],\n\t\t\t&die->attr_values[i], hdr, debug_str, debug_str_len, big_endian);\n\n\t\tRzBinDwarfAttrValue *attribute = &die->attr_values[i];\n\n\t\tif (attribute->attr_name == DW_AT_comp_dir && (attribute->attr_form == DW_FORM_strp || attribute->attr_form == DW_FORM_string) && attribute->string.content) {\n\t\t\tcomp_dir = attribute->string.content;\n\t\t}\n\t\tif (attribute->attr_name == DW_AT_stmt_list) {\n\t\t\tif (attribute->kind == DW_AT_KIND_CONSTANT) {\n\t\t\t\tline_info_offset = attribute->uconstant;\n\t\t\t} else if (attribute->kind == DW_AT_KIND_REFERENCE) {\n\t\t\t\tline_info_offset = attribute->reference;\n\t\t\t}\n\t\t}\n\t\tdie->count++;\n\t}\n\n\t// If this is a compilation unit dir attribute, we want to cache it so the line info parsing\n\t// which will need this info can quickly look it up.\n\tif (comp_dir && line_info_offset != UT64_MAX) {\n\t\tchar *name = strdup(comp_dir);\n\t\tif (name) {\n\t\t\tif (!ht_up_insert(info->line_info_offset_comp_dir, line_info_offset, name)) {\n\t\t\t\tfree(name);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn buf;\n}",
  "abstract_func_before": "static const ut8 *parse_die(const ut8 *VAR_0, const ut8 *VAR_1, RzBinDwarfDebugInfo *VAR_2, RzBinDwarfAbbrevDecl *VAR_3,\n\tRzBinDwarfCompUnitHdr *VAR_4, RzBinDwarfDie *VAR_5, const ut8 *VAR_6, size_t VAR_7, bool VAR_8) {\n\tsize_t VAR_9;\n\tconst char *VAR_10 = NULL;\n\tut64 VAR_11 = VAR_12;\n\tfor (VAR_9 = 0; VAR_9 < VAR_3->count - 1; VAR_9++) {\n\t\tmemset(&VAR_5->attr_values[VAR_9], 0, sizeof(VAR_5->attr_values[VAR_9]));\n\n\t\tVAR_0 = parse_attr_value(VAR_0, VAR_1 - VAR_0, &VAR_3->defs[VAR_9],\n\t\t\t&VAR_5->attr_values[VAR_9], VAR_4, VAR_6, VAR_7, VAR_8);\n\n\t\tRzBinDwarfAttrValue *VAR_13 = &VAR_5->attr_values[VAR_9];\n\n\t\tif (VAR_13->attr_name == VAR_14 && (VAR_13->attr_form == VAR_15 || VAR_13->attr_form == VAR_16) && VAR_13->string.content) {\n\t\t\tVAR_10 = VAR_13->string.content;\n\t\t}\n\t\tif (VAR_13->attr_name == VAR_17) {\n\t\t\tif (VAR_13->kind == VAR_18) {\n\t\t\t\tVAR_11 = VAR_13->uconstant;\n\t\t\t} else if (VAR_13->kind == VAR_19) {\n\t\t\t\tVAR_11 = VAR_13->reference;\n\t\t\t}\n\t\t}\n\t\tVAR_5->count++;\n\t}\n\n\t/* COMMENT_0 */\n\t/* COMMENT_1 */\n\tif (VAR_10 && VAR_11 != VAR_12) {\n\t\tchar *VAR_20 = strdup(VAR_10);\n\t\tif (VAR_20) {\n\t\t\tif (!ht_up_insert(VAR_2->line_info_offset_comp_dir, VAR_11, VAR_20)) {\n\t\t\t\tfree(VAR_20);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn VAR_0;\n}",
  "func_graph_path_before": "rizinorg/rizin/aa6917772d2f32e5a7daab25a46c72df0b5ea406/dwarf.c/vul/before/0.json",
  "func": "static const ut8 *parse_die(const ut8 *buf, const ut8 *buf_end, RzBinDwarfDebugInfo *info, RzBinDwarfAbbrevDecl *abbrev,\n\tRzBinDwarfCompUnitHdr *hdr, RzBinDwarfDie *die, const ut8 *debug_str, size_t debug_str_len, bool big_endian) {\n\tsize_t i;\n\tconst char *comp_dir = NULL;\n\tut64 line_info_offset = UT64_MAX;\n\tif (abbrev->count) {\n\t\tfor (i = 0; i < abbrev->count - 1; i++) {\n\t\t\tmemset(&die->attr_values[i], 0, sizeof(die->attr_values[i]));\n\n\t\t\tbuf = parse_attr_value(buf, buf_end - buf, &abbrev->defs[i],\n\t\t\t\t&die->attr_values[i], hdr, debug_str, debug_str_len, big_endian);\n\n\t\t\tRzBinDwarfAttrValue *attribute = &die->attr_values[i];\n\n\t\t\tif (attribute->attr_name == DW_AT_comp_dir && (attribute->attr_form == DW_FORM_strp || attribute->attr_form == DW_FORM_string) && attribute->string.content) {\n\t\t\t\tcomp_dir = attribute->string.content;\n\t\t\t}\n\t\t\tif (attribute->attr_name == DW_AT_stmt_list) {\n\t\t\t\tif (attribute->kind == DW_AT_KIND_CONSTANT) {\n\t\t\t\t\tline_info_offset = attribute->uconstant;\n\t\t\t\t} else if (attribute->kind == DW_AT_KIND_REFERENCE) {\n\t\t\t\t\tline_info_offset = attribute->reference;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdie->count++;\n\t\t}\n\t}\n\n\t// If this is a compilation unit dir attribute, we want to cache it so the line info parsing\n\t// which will need this info can quickly look it up.\n\tif (comp_dir && line_info_offset != UT64_MAX) {\n\t\tchar *name = strdup(comp_dir);\n\t\tif (name) {\n\t\t\tif (!ht_up_insert(info->line_info_offset_comp_dir, line_info_offset, name)) {\n\t\t\t\tfree(name);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn buf;\n}",
  "abstract_func": "static const ut8 *parse_die(const ut8 *VAR_0, const ut8 *VAR_1, RzBinDwarfDebugInfo *VAR_2, RzBinDwarfAbbrevDecl *VAR_3,\n\tRzBinDwarfCompUnitHdr *VAR_4, RzBinDwarfDie *VAR_5, const ut8 *VAR_6, size_t VAR_7, bool VAR_8) {\n\tsize_t VAR_9;\n\tconst char *VAR_10 = NULL;\n\tut64 VAR_11 = VAR_12;\n\tif (VAR_3->count) {\n\t\tfor (VAR_9 = 0; VAR_9 < VAR_3->count - 1; VAR_9++) {\n\t\t\tmemset(&VAR_5->attr_values[VAR_9], 0, sizeof(VAR_5->attr_values[VAR_9]));\n\n\t\t\tVAR_0 = parse_attr_value(VAR_0, VAR_1 - VAR_0, &VAR_3->defs[VAR_9],\n\t\t\t\t&VAR_5->attr_values[VAR_9], VAR_4, VAR_6, VAR_7, VAR_8);\n\n\t\t\tRzBinDwarfAttrValue *VAR_13 = &VAR_5->attr_values[VAR_9];\n\n\t\t\tif (VAR_13->attr_name == VAR_14 && (VAR_13->attr_form == VAR_15 || VAR_13->attr_form == VAR_16) && VAR_13->string.content) {\n\t\t\t\tVAR_10 = VAR_13->string.content;\n\t\t\t}\n\t\t\tif (VAR_13->attr_name == VAR_17) {\n\t\t\t\tif (VAR_13->kind == VAR_18) {\n\t\t\t\t\tVAR_11 = VAR_13->uconstant;\n\t\t\t\t} else if (VAR_13->kind == VAR_19) {\n\t\t\t\t\tVAR_11 = VAR_13->reference;\n\t\t\t\t}\n\t\t\t}\n\t\t\tVAR_5->count++;\n\t\t}\n\t}\n\n\t/* COMMENT_0 */\n\t/* COMMENT_1 */\n\tif (VAR_10 && VAR_11 != VAR_12) {\n\t\tchar *VAR_20 = strdup(VAR_10);\n\t\tif (VAR_20) {\n\t\t\tif (!ht_up_insert(VAR_2->line_info_offset_comp_dir, VAR_11, VAR_20)) {\n\t\t\t\tfree(VAR_20);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn VAR_0;\n}",
  "func_graph_path": "rizinorg/rizin/aa6917772d2f32e5a7daab25a46c72df0b5ea406/dwarf.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -3,25 +3,27 @@\n \tsize_t i;\n \tconst char *comp_dir = NULL;\n \tut64 line_info_offset = UT64_MAX;\n-\tfor (i = 0; i < abbrev->count - 1; i++) {\n-\t\tmemset(&die->attr_values[i], 0, sizeof(die->attr_values[i]));\n+\tif (abbrev->count) {\n+\t\tfor (i = 0; i < abbrev->count - 1; i++) {\n+\t\t\tmemset(&die->attr_values[i], 0, sizeof(die->attr_values[i]));\n \n-\t\tbuf = parse_attr_value(buf, buf_end - buf, &abbrev->defs[i],\n-\t\t\t&die->attr_values[i], hdr, debug_str, debug_str_len, big_endian);\n+\t\t\tbuf = parse_attr_value(buf, buf_end - buf, &abbrev->defs[i],\n+\t\t\t\t&die->attr_values[i], hdr, debug_str, debug_str_len, big_endian);\n \n-\t\tRzBinDwarfAttrValue *attribute = &die->attr_values[i];\n+\t\t\tRzBinDwarfAttrValue *attribute = &die->attr_values[i];\n \n-\t\tif (attribute->attr_name == DW_AT_comp_dir && (attribute->attr_form == DW_FORM_strp || attribute->attr_form == DW_FORM_string) && attribute->string.content) {\n-\t\t\tcomp_dir = attribute->string.content;\n+\t\t\tif (attribute->attr_name == DW_AT_comp_dir && (attribute->attr_form == DW_FORM_strp || attribute->attr_form == DW_FORM_string) && attribute->string.content) {\n+\t\t\t\tcomp_dir = attribute->string.content;\n+\t\t\t}\n+\t\t\tif (attribute->attr_name == DW_AT_stmt_list) {\n+\t\t\t\tif (attribute->kind == DW_AT_KIND_CONSTANT) {\n+\t\t\t\t\tline_info_offset = attribute->uconstant;\n+\t\t\t\t} else if (attribute->kind == DW_AT_KIND_REFERENCE) {\n+\t\t\t\t\tline_info_offset = attribute->reference;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tdie->count++;\n \t\t}\n-\t\tif (attribute->attr_name == DW_AT_stmt_list) {\n-\t\t\tif (attribute->kind == DW_AT_KIND_CONSTANT) {\n-\t\t\t\tline_info_offset = attribute->uconstant;\n-\t\t\t} else if (attribute->kind == DW_AT_KIND_REFERENCE) {\n-\t\t\t\tline_info_offset = attribute->reference;\n-\t\t\t}\n-\t\t}\n-\t\tdie->count++;\n \t}\n \n \t// If this is a compilation unit dir attribute, we want to cache it so the line info parsing",
  "diff_line_info": {
    "deleted_lines": [
      "\tfor (i = 0; i < abbrev->count - 1; i++) {",
      "\t\tmemset(&die->attr_values[i], 0, sizeof(die->attr_values[i]));",
      "\t\tbuf = parse_attr_value(buf, buf_end - buf, &abbrev->defs[i],",
      "\t\t\t&die->attr_values[i], hdr, debug_str, debug_str_len, big_endian);",
      "\t\tRzBinDwarfAttrValue *attribute = &die->attr_values[i];",
      "\t\tif (attribute->attr_name == DW_AT_comp_dir && (attribute->attr_form == DW_FORM_strp || attribute->attr_form == DW_FORM_string) && attribute->string.content) {",
      "\t\t\tcomp_dir = attribute->string.content;",
      "\t\tif (attribute->attr_name == DW_AT_stmt_list) {",
      "\t\t\tif (attribute->kind == DW_AT_KIND_CONSTANT) {",
      "\t\t\t\tline_info_offset = attribute->uconstant;",
      "\t\t\t} else if (attribute->kind == DW_AT_KIND_REFERENCE) {",
      "\t\t\t\tline_info_offset = attribute->reference;",
      "\t\t\t}",
      "\t\t}",
      "\t\tdie->count++;"
    ],
    "added_lines": [
      "\tif (abbrev->count) {",
      "\t\tfor (i = 0; i < abbrev->count - 1; i++) {",
      "\t\t\tmemset(&die->attr_values[i], 0, sizeof(die->attr_values[i]));",
      "\t\t\tbuf = parse_attr_value(buf, buf_end - buf, &abbrev->defs[i],",
      "\t\t\t\t&die->attr_values[i], hdr, debug_str, debug_str_len, big_endian);",
      "\t\t\tRzBinDwarfAttrValue *attribute = &die->attr_values[i];",
      "\t\t\tif (attribute->attr_name == DW_AT_comp_dir && (attribute->attr_form == DW_FORM_strp || attribute->attr_form == DW_FORM_string) && attribute->string.content) {",
      "\t\t\t\tcomp_dir = attribute->string.content;",
      "\t\t\t}",
      "\t\t\tif (attribute->attr_name == DW_AT_stmt_list) {",
      "\t\t\t\tif (attribute->kind == DW_AT_KIND_CONSTANT) {",
      "\t\t\t\t\tline_info_offset = attribute->uconstant;",
      "\t\t\t\t} else if (attribute->kind == DW_AT_KIND_REFERENCE) {",
      "\t\t\t\t\tline_info_offset = attribute->reference;",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t\tdie->count++;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/rizinorg/rizin/pull/2086",
  "description": {
    "pr_info": {
      "title": "Fix oob write for dwarf with abbrev with count 0 (Fix #2083)",
      "number": 2086
    },
    "comment": [
      " <!-- Filling this template is mandatory -->\r\n\r\n**Your checklist for this pull request**\r\n- [x] I've read the [guidelines for contributing](https://github.com/rizinorg/rizin/blob/master/DEVELOPERS.md) to this repository\r\n- [x] I made sure to follow the project's [coding style](https://github.com/rizinorg/rizin/blob/master/DEVELOPERS.md#code-style)\r\n- [ ] I've documented or updated the documentation of every function and struct this PR changes. If not so I've explained why.\r\n- [x] I've added tests that prove my fix is effective or that my feature works (if possible)\r\n- [ ] I've updated the [rizin book](https://github.com/rizinorg/book) with the relevant information (if needed)\r\n\r\nFix #2083\r\n\r\n**Detailed description**\r\n\r\nThis is described in #2083."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix\nConfidence Score: 0.95\n\n**Step-by-Step Explanation:**\n\n1. **Patch Analysis:** The commit addresses an out-of-bounds write (oob write) in the Dwarf parsing function. The code change adds a check for `abbrev->count` to prevent the loop from running when the count is zero, thus avoiding accessing invalid memory.\n\n2. **Security Assessment:** The issue is a security vulnerability because an out-of-bounds write can lead to buffer overflow, allowing unauthorized access or code execution.\n\n3. **Classification:** The fix resolves a security issue, making it a 'Security Vulnerability Fix'.\n\n4. **Confidence:** High confidence due to the explicit mention of a security issue and the clear code fix addressing it.\n\n**Final Answer:**\nAnalysis: The patch fixes an out-of-bounds write issue in the Dwarf parser, preventing potential memory corruption and security risks.\nFinal Classification: Security Vulnerability Fix\nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\nThe patch addresses an out-of-bounds write issue in the Dwarf parsing code, which is a security vulnerability. The fix ensures that the loop doesn't execute when the count is zero, preventing memory corruption and potential security exploits.\n\n**Final Output:**\nAnalysis: The patch fixes an out-of-bounds write issue in the Dwarf parser, preventing potential memory corruption and security risks.\nFinal Classification: Security Vulnerability Fix\nConfidence Score: 0.95\n\n**Step-by-Step Explanation:**\n\n1. **Patch Analysis:** The commit addresses an out-of-bounds write (oob write) in the Dwarf parsing function. The code change adds a check for `abbrev->count` to prevent the loop from running when the count is zero, thus avoiding accessing invalid memory.\n\n2. **Security Assessment:** The issue is a security vulnerability because an out-of-bounds write can lead to buffer overflow, allowing unauthorized access or code execution.\n\n3. **Classification:** The fix resolves a security issue, making it a 'Security Vulnerability Fix'.\n\n4. **Confidence:** High confidence due to the explicit mention of a security issue and the clear code fix addressing it.\n\n**Final Answer:**\nAnalysis: The patch fixes an out-of-bounds write issue in the Dwarf parser, preventing potential memory corruption and security risks.\nFinal Classification: Security Vulnerability Fix\nConfidence Score: 0.95"
}