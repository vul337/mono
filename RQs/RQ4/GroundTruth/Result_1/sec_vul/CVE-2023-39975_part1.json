{
  "cve_id": "CVE-2023-39975",
  "cwe_ids": [
    "CWE-415"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "krb5",
  "commit_msg": "Fix double-free in KDC TGS processing\n\nWhen issuing a ticket for a TGS renew or validate request, copy only\nthe server field from the outer part of the header ticket to the new\nticket.  Copying the whole structure causes the enc_part pointer to be\naliased to the header ticket until krb5_encrypt_tkt_part() is called,\nresulting in a double-free if handle_authdata() fails.\n\n[ghudson@mit.edu: changed the fix to avoid aliasing enc_part rather\nthan check for aliasing before freeing; rewrote commit message]\n\nCVE-2023-39975:\n\nIn MIT krb5 release 1.21, an authenticated attacker can cause a KDC to\nfree the same pointer twice if it can induce a failure in\nauthorization data handling.\n\nticket: 9101 (new)\ntags: pullup\ntarget_version: 1.21-next",
  "commit_hash": "88a1701b423c13991a8064feeb26952d3641d840",
  "git_url": "https://github.com/krb5/krb5/commit/88a1701b423c13991a8064feeb26952d3641d840",
  "file_path": "src/kdc/do_tgs_req.c",
  "func_name": "tgs_issue_ticket",
  "func_before": "static krb5_error_code\ntgs_issue_ticket(kdc_realm_t *realm, struct tgs_req_info *t,\n                 krb5_flags tktflags, krb5_ticket_times *times, krb5_data *pkt,\n                 const krb5_fulladdr *from,\n                 struct kdc_request_state *fast_state,\n                 krb5_audit_state *au_state, const char **status,\n                 krb5_data **response)\n{\n    krb5_context context = realm->realm_context;\n    krb5_error_code ret;\n    krb5_keyblock session_key = { 0 }, server_key = { 0 };\n    krb5_keyblock *ticket_encrypting_key, *subject_key;\n    krb5_keyblock *initial_reply_key, *fast_reply_key = NULL;\n    krb5_enc_tkt_part enc_tkt_reply = { 0 };\n    krb5_ticket ticket_reply = { 0 };\n    krb5_enc_kdc_rep_part reply_encpart = { 0 };\n    krb5_kdc_rep reply = { 0 };\n    krb5_pac subject_pac;\n    krb5_db_entry *subject_server;\n    krb5_enc_tkt_part *header_enc_tkt = t->header_tkt->enc_part2;\n    krb5_last_req_entry nolrentry = { KV5M_LAST_REQ_ENTRY, KRB5_LRQ_NONE, 0 };\n    krb5_last_req_entry *nolrarray[2] = { &nolrentry, NULL };\n\n    au_state->stage = ISSUE_TKT;\n\n    ret = gen_session_key(context, t->req, t->server, &session_key, status);\n    if (ret)\n        goto cleanup;\n\n    if (t->flags & KRB5_KDB_FLAG_CONSTRAINED_DELEGATION) {\n        subject_pac = t->stkt_pac;\n        subject_server = t->stkt_server;\n        subject_key = t->stkt_server_key;\n    } else {\n        subject_pac = t->header_pac;\n        subject_server = t->header_server;\n        subject_key = t->header_key;\n    }\n\n    initial_reply_key = (t->subkey != NULL) ? t->subkey :\n        t->header_tkt->enc_part2->session;\n\n    if (t->req->kdc_options & KDC_OPT_ENC_TKT_IN_SKEY) {\n        /* For user-to-user, encrypt the ticket with the second ticket's\n         * session key. */\n        ticket_encrypting_key = t->stkt->enc_part2->session;\n    } else {\n        /* Otherwise encrypt the ticket with the server entry's first long-term\n         * key. */\n        ret = get_first_current_key(context, t->server, &server_key);\n        if (ret) {\n            *status = \"FINDING_SERVER_KEY\";\n            goto cleanup;\n        }\n        ticket_encrypting_key = &server_key;\n    }\n\n    if (t->req->kdc_options & (KDC_OPT_VALIDATE | KDC_OPT_RENEW)) {\n        /* Copy the whole header ticket except for authorization data. */\n        ticket_reply = *t->header_tkt;\n        enc_tkt_reply = *t->header_tkt->enc_part2;\n        enc_tkt_reply.authorization_data = NULL;\n    } else {\n        if (t->req->kdc_options & (KDC_OPT_FORWARDED | KDC_OPT_PROXY)) {\n            /* Include the requested addresses in the ticket and reply. */\n            enc_tkt_reply.caddrs = t->req->addresses;\n            reply_encpart.caddrs = t->req->addresses;\n        } else {\n            /* Use the header ticket addresses and omit them from the reply. */\n            enc_tkt_reply.caddrs = header_enc_tkt->caddrs;\n            reply_encpart.caddrs = NULL;\n        }\n\n        ticket_reply.server = t->is_referral ? t->sprinc : t->req->server;\n    }\n\n    enc_tkt_reply.flags = tktflags;\n    enc_tkt_reply.times = *times;\n    enc_tkt_reply.client = t->tkt_client;\n    enc_tkt_reply.session = &session_key;\n    enc_tkt_reply.transited = t->transited;\n\n    ret = handle_authdata(realm, t->flags, t->client, t->server,\n                          subject_server, t->local_tgt, &t->local_tgt_key,\n                          initial_reply_key, ticket_encrypting_key,\n                          subject_key, NULL, pkt, t->req, t->s4u_cprinc,\n                          subject_pac, t->subject_tkt, &t->auth_indicators,\n                          &enc_tkt_reply);\n    if (ret) {\n        krb5_klog_syslog(LOG_INFO, _(\"TGS_REQ : handle_authdata (%d)\"), ret);\n        *status = \"HANDLE_AUTHDATA\";\n        goto cleanup;\n    }\n\n    ticket_reply.enc_part2 = &enc_tkt_reply;\n\n    ret = krb5_encrypt_tkt_part(context, ticket_encrypting_key, &ticket_reply);\n    if (ret)\n        goto cleanup;\n\n    if (t->req->kdc_options & KDC_OPT_ENC_TKT_IN_SKEY) {\n        ticket_reply.enc_part.kvno = 0;\n        kau_u2u(context, TRUE, au_state);\n    } else {\n        ticket_reply.enc_part.kvno = current_kvno(t->server);\n    }\n\n    au_state->stage = ENCR_REP;\n\n    if (t->s4u2self != NULL &&\n        krb5int_find_pa_data(context, t->req->padata,\n                             KRB5_PADATA_S4U_X509_USER) != NULL) {\n        /* Add an S4U2Self response to the encrypted padata (skipped if the\n         * request only included PA-FOR-USER padata). */\n        ret = kdc_make_s4u2self_rep(context, t->subkey,\n                                    t->header_tkt->enc_part2->session,\n                                    t->s4u2self, &reply, &reply_encpart);\n        if (ret)\n            goto cleanup;\n    }\n\n    reply_encpart.session = &session_key;\n    reply_encpart.nonce = t->req->nonce;\n    reply_encpart.times = enc_tkt_reply.times;\n    reply_encpart.last_req = nolrarray;\n    reply_encpart.key_exp = 0;\n    reply_encpart.flags = enc_tkt_reply.flags;\n    reply_encpart.server = ticket_reply.server;\n\n    reply.msg_type = KRB5_TGS_REP;\n    reply.client = enc_tkt_reply.client;\n    reply.ticket = &ticket_reply;\n    reply.enc_part.kvno = 0;\n    reply.enc_part.enctype = initial_reply_key->enctype;\n    ret = kdc_fast_response_handle_padata(fast_state, t->req, &reply,\n                                          initial_reply_key->enctype);\n    if (ret)\n        goto cleanup;\n    ret = kdc_fast_handle_reply_key(fast_state, initial_reply_key,\n                                    &fast_reply_key);\n    if (ret)\n        goto cleanup;\n    ret = return_enc_padata(context, pkt, t->req, fast_reply_key, t->server,\n                            &reply_encpart,\n                            t->is_referral &&\n                            (t->req->kdc_options & KDC_OPT_CANONICALIZE));\n    if (ret) {\n        *status = \"KDC_RETURN_ENC_PADATA\";\n        goto cleanup;\n    }\n\n    ret = kau_make_tkt_id(context, &ticket_reply, &au_state->tkt_out_id);\n    if (ret)\n        goto cleanup;\n\n    if (kdc_fast_hide_client(fast_state))\n        reply.client = (krb5_principal)krb5_anonymous_principal();\n    ret = krb5_encode_kdc_rep(context, KRB5_TGS_REP, &reply_encpart,\n                              t->subkey != NULL, fast_reply_key, &reply,\n                              response);\n    if (ret)\n        goto cleanup;\n\n    log_tgs_req(context, from, t->req, &reply, t->cprinc, t->sprinc,\n                t->s4u_cprinc, t->authtime, t->flags, \"ISSUE\", 0, NULL);\n    au_state->status = \"ISSUE\";\n    au_state->reply = &reply;\n    if (t->flags & KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)\n        kau_s4u2proxy(context, TRUE, au_state);\n    kau_tgs_req(context, TRUE, au_state);\n    au_state->reply = NULL;\n\ncleanup:\n    zapfree(ticket_reply.enc_part.ciphertext.data,\n            ticket_reply.enc_part.ciphertext.length);\n    zapfree(reply.enc_part.ciphertext.data, reply.enc_part.ciphertext.length);\n    krb5_free_pa_data(context, reply.padata);\n    krb5_free_pa_data(context, reply_encpart.enc_padata);\n    krb5_free_authdata(context, enc_tkt_reply.authorization_data);\n    krb5_free_keyblock_contents(context, &session_key);\n    krb5_free_keyblock_contents(context, &server_key);\n    krb5_free_keyblock(context, fast_reply_key);\n    return ret;\n}",
  "abstract_func_before": "static krb5_error_code\ntgs_issue_ticket(kdc_realm_t *VAR_0, struct tgs_req_info *VAR_1,\n                 krb5_flags VAR_2, krb5_ticket_times *VAR_3, krb5_data *VAR_4,\n                 const krb5_fulladdr *VAR_5,\n                 struct kdc_request_state *VAR_6,\n                 krb5_audit_state *VAR_7, const char **VAR_8,\n                 krb5_data **VAR_9)\n{\n    krb5_context VAR_10 = VAR_0->realm_context;\n    krb5_error_code VAR_11;\n    krb5_keyblock VAR_12 = { 0 }, VAR_13 = { 0 };\n    krb5_keyblock *VAR_14, *VAR_15;\n    krb5_keyblock *VAR_16, *VAR_17 = NULL;\n    krb5_enc_tkt_part VAR_18 = { 0 };\n    krb5_ticket VAR_19 = { 0 };\n    krb5_enc_kdc_rep_part VAR_20 = { 0 };\n    krb5_kdc_rep VAR_21 = { 0 };\n    krb5_pac VAR_22;\n    krb5_db_entry *VAR_23;\n    krb5_enc_tkt_part *VAR_24 = VAR_1->header_tkt->enc_part2;\n    krb5_last_req_entry VAR_25 = { VAR_26, VAR_27, 0 };\n    krb5_last_req_entry *VAR_28[2] = { &VAR_25, NULL };\n\n    VAR_7->stage = VAR_29;\n\n    VAR_11 = gen_session_key(VAR_10, VAR_1->req, VAR_1->server, &VAR_12, VAR_8);\n    if (VAR_11)\n        goto cleanup;\n\n    if (VAR_1->flags & VAR_30) {\n        VAR_22 = VAR_1->stkt_pac;\n        VAR_23 = VAR_1->stkt_server;\n        VAR_15 = VAR_1->stkt_server_key;\n    } else {\n        VAR_22 = VAR_1->header_pac;\n        VAR_23 = VAR_1->header_server;\n        VAR_15 = VAR_1->header_key;\n    }\n\n    VAR_16 = (VAR_1->subkey != NULL) ? VAR_1->subkey :\n        VAR_1->header_tkt->enc_part2->session;\n\n    if (VAR_1->req->kdc_options & VAR_31) {\n        /* COMMENT_0 */\n                          \n        VAR_14 = VAR_1->stkt->enc_part2->session;\n    } else {\n        /* COMMENT_2 */\n                  \n        VAR_11 = get_first_current_key(VAR_10, VAR_1->server, &VAR_13);\n        if (VAR_11) {\n            *VAR_8 = \"FINDING_SERVER_KEY\";\n            goto cleanup;\n        }\n        VAR_14 = &VAR_13;\n    }\n\n    if (VAR_1->req->kdc_options & (VAR_32 | VAR_33)) {\n        /* COMMENT_4 */\n        VAR_19 = *VAR_1->header_tkt;\n        VAR_18 = *VAR_1->header_tkt->enc_part2;\n        VAR_18.authorization_data = NULL;\n    } else {\n        if (VAR_1->req->kdc_options & (VAR_34 | VAR_35)) {\n            /* COMMENT_5 */\n            VAR_18.caddrs = VAR_1->req->addresses;\n            VAR_20.caddrs = VAR_1->req->addresses;\n        } else {\n            /* COMMENT_6 */\n            VAR_18.caddrs = VAR_24->caddrs;\n            VAR_20.caddrs = NULL;\n        }\n\n        VAR_19.server = VAR_1->is_referral ? VAR_1->sprinc : VAR_1->req->server;\n    }\n\n    VAR_18.flags = VAR_2;\n    VAR_18.times = *VAR_3;\n    VAR_18.client = VAR_1->tkt_client;\n    VAR_18.session = &VAR_12;\n    VAR_18.transited = VAR_1->transited;\n\n    VAR_11 = handle_authdata(VAR_0, VAR_1->flags, VAR_1->client, VAR_1->server,\n                          VAR_23, VAR_1->local_tgt, &VAR_1->local_tgt_key,\n                          VAR_16, VAR_14,\n                          VAR_15, NULL, VAR_4, VAR_1->req, VAR_1->s4u_cprinc,\n                          VAR_22, VAR_1->subject_tkt, &VAR_1->auth_indicators,\n                          &VAR_18);\n    if (VAR_11) {\n        krb5_klog_syslog(VAR_36, _(\"TGS_REQ : handle_authdata (%d)\"), VAR_11);\n        *VAR_8 = \"HANDLE_AUTHDATA\";\n        goto cleanup;\n    }\n\n    VAR_19.enc_part2 = &VAR_18;\n\n    VAR_11 = krb5_encrypt_tkt_part(VAR_10, VAR_14, &VAR_19);\n    if (VAR_11)\n        goto cleanup;\n\n    if (VAR_1->req->kdc_options & VAR_31) {\n        VAR_19.enc_part.kvno = 0;\n        kau_u2u(VAR_10, TRUE, VAR_7);\n    } else {\n        VAR_19.enc_part.kvno = current_kvno(VAR_1->server);\n    }\n\n    VAR_7->stage = VAR_37;\n\n    if (VAR_1->s4u2self != NULL &&\n        krb5int_find_pa_data(VAR_10, VAR_1->req->padata,\n                             VAR_38) != NULL) {\n        /* COMMENT_7 */\n                                                        \n        VAR_11 = kdc_make_s4u2self_rep(VAR_10, VAR_1->subkey,\n                                    VAR_1->header_tkt->enc_part2->session,\n                                    VAR_1->s4u2self, &VAR_21, &VAR_20);\n        if (VAR_11)\n            goto cleanup;\n    }\n\n    VAR_20.session = &VAR_12;\n    VAR_20.nonce = VAR_1->req->nonce;\n    VAR_20.times = VAR_18.times;\n    VAR_20.last_req = VAR_28;\n    VAR_20.key_exp = 0;\n    VAR_20.flags = VAR_18.flags;\n    VAR_20.server = VAR_19.server;\n\n    VAR_21.msg_type = VAR_39;\n    VAR_21.client = VAR_18.client;\n    VAR_21.ticket = &VAR_19;\n    VAR_21.enc_part.kvno = 0;\n    VAR_21.enc_part.enctype = VAR_16->enctype;\n    VAR_11 = kdc_fast_response_handle_padata(VAR_6, VAR_1->req, &VAR_21,\n                                          VAR_16->enctype);\n    if (VAR_11)\n        goto cleanup;\n    VAR_11 = kdc_fast_handle_reply_key(VAR_6, VAR_16,\n                                    &VAR_17);\n    if (VAR_11)\n        goto cleanup;\n    VAR_11 = return_enc_padata(VAR_10, VAR_4, VAR_1->req, VAR_17, VAR_1->server,\n                            &VAR_20,\n                            VAR_1->is_referral &&\n                            (VAR_1->req->kdc_options & VAR_40));\n    if (VAR_11) {\n        *VAR_8 = \"KDC_RETURN_ENC_PADATA\";\n        goto cleanup;\n    }\n\n    VAR_11 = kau_make_tkt_id(VAR_10, &VAR_19, &VAR_7->tkt_out_id);\n    if (VAR_11)\n        goto cleanup;\n\n    if (kdc_fast_hide_client(VAR_6))\n        VAR_21.client = (krb5_principal)krb5_anonymous_principal();\n    VAR_11 = krb5_encode_kdc_rep(VAR_10, VAR_39, &VAR_20,\n                              VAR_1->subkey != NULL, VAR_17, &VAR_21,\n                              VAR_9);\n    if (VAR_11)\n        goto cleanup;\n\n    log_tgs_req(VAR_10, VAR_5, VAR_1->req, &VAR_21, VAR_1->cprinc, VAR_1->sprinc,\n                VAR_1->s4u_cprinc, VAR_1->authtime, VAR_1->flags, \"ISSUE\", 0, NULL);\n    VAR_7->status = \"ISSUE\";\n    VAR_7->reply = &VAR_21;\n    if (VAR_1->flags & VAR_30)\n        kau_s4u2proxy(VAR_10, TRUE, VAR_7);\n    kau_tgs_req(VAR_10, TRUE, VAR_7);\n    VAR_7->reply = NULL;\n\ncleanup:\n    zapfree(VAR_19.enc_part.ciphertext.data,\n            VAR_19.enc_part.ciphertext.length);\n    zapfree(VAR_21.enc_part.ciphertext.data, VAR_21.enc_part.ciphertext.length);\n    krb5_free_pa_data(VAR_10, VAR_21.padata);\n    krb5_free_pa_data(VAR_10, VAR_20.enc_padata);\n    krb5_free_authdata(VAR_10, VAR_18.authorization_data);\n    krb5_free_keyblock_contents(VAR_10, &VAR_12);\n    krb5_free_keyblock_contents(VAR_10, &VAR_13);\n    krb5_free_keyblock(VAR_10, VAR_17);\n    return VAR_11;\n}",
  "func_graph_path_before": "krb5/88a1701b423c13991a8064feeb26952d3641d840/do_tgs_req.c/vul/before/0.json",
  "func": "static krb5_error_code\ntgs_issue_ticket(kdc_realm_t *realm, struct tgs_req_info *t,\n                 krb5_flags tktflags, krb5_ticket_times *times, krb5_data *pkt,\n                 const krb5_fulladdr *from,\n                 struct kdc_request_state *fast_state,\n                 krb5_audit_state *au_state, const char **status,\n                 krb5_data **response)\n{\n    krb5_context context = realm->realm_context;\n    krb5_error_code ret;\n    krb5_keyblock session_key = { 0 }, server_key = { 0 };\n    krb5_keyblock *ticket_encrypting_key, *subject_key;\n    krb5_keyblock *initial_reply_key, *fast_reply_key = NULL;\n    krb5_enc_tkt_part enc_tkt_reply = { 0 };\n    krb5_ticket ticket_reply = { 0 };\n    krb5_enc_kdc_rep_part reply_encpart = { 0 };\n    krb5_kdc_rep reply = { 0 };\n    krb5_pac subject_pac;\n    krb5_db_entry *subject_server;\n    krb5_enc_tkt_part *header_enc_tkt = t->header_tkt->enc_part2;\n    krb5_last_req_entry nolrentry = { KV5M_LAST_REQ_ENTRY, KRB5_LRQ_NONE, 0 };\n    krb5_last_req_entry *nolrarray[2] = { &nolrentry, NULL };\n\n    au_state->stage = ISSUE_TKT;\n\n    ret = gen_session_key(context, t->req, t->server, &session_key, status);\n    if (ret)\n        goto cleanup;\n\n    if (t->flags & KRB5_KDB_FLAG_CONSTRAINED_DELEGATION) {\n        subject_pac = t->stkt_pac;\n        subject_server = t->stkt_server;\n        subject_key = t->stkt_server_key;\n    } else {\n        subject_pac = t->header_pac;\n        subject_server = t->header_server;\n        subject_key = t->header_key;\n    }\n\n    initial_reply_key = (t->subkey != NULL) ? t->subkey :\n        t->header_tkt->enc_part2->session;\n\n    if (t->req->kdc_options & KDC_OPT_ENC_TKT_IN_SKEY) {\n        /* For user-to-user, encrypt the ticket with the second ticket's\n         * session key. */\n        ticket_encrypting_key = t->stkt->enc_part2->session;\n    } else {\n        /* Otherwise encrypt the ticket with the server entry's first long-term\n         * key. */\n        ret = get_first_current_key(context, t->server, &server_key);\n        if (ret) {\n            *status = \"FINDING_SERVER_KEY\";\n            goto cleanup;\n        }\n        ticket_encrypting_key = &server_key;\n    }\n\n    if (t->req->kdc_options & (KDC_OPT_VALIDATE | KDC_OPT_RENEW)) {\n        /* Copy the header ticket server and all enc-part fields except for\n         * authorization data. */\n        ticket_reply.server = t->header_tkt->server;\n        enc_tkt_reply = *t->header_tkt->enc_part2;\n        enc_tkt_reply.authorization_data = NULL;\n    } else {\n        if (t->req->kdc_options & (KDC_OPT_FORWARDED | KDC_OPT_PROXY)) {\n            /* Include the requested addresses in the ticket and reply. */\n            enc_tkt_reply.caddrs = t->req->addresses;\n            reply_encpart.caddrs = t->req->addresses;\n        } else {\n            /* Use the header ticket addresses and omit them from the reply. */\n            enc_tkt_reply.caddrs = header_enc_tkt->caddrs;\n            reply_encpart.caddrs = NULL;\n        }\n\n        ticket_reply.server = t->is_referral ? t->sprinc : t->req->server;\n    }\n\n    enc_tkt_reply.flags = tktflags;\n    enc_tkt_reply.times = *times;\n    enc_tkt_reply.client = t->tkt_client;\n    enc_tkt_reply.session = &session_key;\n    enc_tkt_reply.transited = t->transited;\n\n    ret = handle_authdata(realm, t->flags, t->client, t->server,\n                          subject_server, t->local_tgt, &t->local_tgt_key,\n                          initial_reply_key, ticket_encrypting_key,\n                          subject_key, NULL, pkt, t->req, t->s4u_cprinc,\n                          subject_pac, t->subject_tkt, &t->auth_indicators,\n                          &enc_tkt_reply);\n    if (ret) {\n        krb5_klog_syslog(LOG_INFO, _(\"TGS_REQ : handle_authdata (%d)\"), ret);\n        *status = \"HANDLE_AUTHDATA\";\n        goto cleanup;\n    }\n\n    ticket_reply.enc_part2 = &enc_tkt_reply;\n\n    ret = krb5_encrypt_tkt_part(context, ticket_encrypting_key, &ticket_reply);\n    if (ret)\n        goto cleanup;\n\n    if (t->req->kdc_options & KDC_OPT_ENC_TKT_IN_SKEY) {\n        ticket_reply.enc_part.kvno = 0;\n        kau_u2u(context, TRUE, au_state);\n    } else {\n        ticket_reply.enc_part.kvno = current_kvno(t->server);\n    }\n\n    au_state->stage = ENCR_REP;\n\n    if (t->s4u2self != NULL &&\n        krb5int_find_pa_data(context, t->req->padata,\n                             KRB5_PADATA_S4U_X509_USER) != NULL) {\n        /* Add an S4U2Self response to the encrypted padata (skipped if the\n         * request only included PA-FOR-USER padata). */\n        ret = kdc_make_s4u2self_rep(context, t->subkey,\n                                    t->header_tkt->enc_part2->session,\n                                    t->s4u2self, &reply, &reply_encpart);\n        if (ret)\n            goto cleanup;\n    }\n\n    reply_encpart.session = &session_key;\n    reply_encpart.nonce = t->req->nonce;\n    reply_encpart.times = enc_tkt_reply.times;\n    reply_encpart.last_req = nolrarray;\n    reply_encpart.key_exp = 0;\n    reply_encpart.flags = enc_tkt_reply.flags;\n    reply_encpart.server = ticket_reply.server;\n\n    reply.msg_type = KRB5_TGS_REP;\n    reply.client = enc_tkt_reply.client;\n    reply.ticket = &ticket_reply;\n    reply.enc_part.kvno = 0;\n    reply.enc_part.enctype = initial_reply_key->enctype;\n    ret = kdc_fast_response_handle_padata(fast_state, t->req, &reply,\n                                          initial_reply_key->enctype);\n    if (ret)\n        goto cleanup;\n    ret = kdc_fast_handle_reply_key(fast_state, initial_reply_key,\n                                    &fast_reply_key);\n    if (ret)\n        goto cleanup;\n    ret = return_enc_padata(context, pkt, t->req, fast_reply_key, t->server,\n                            &reply_encpart,\n                            t->is_referral &&\n                            (t->req->kdc_options & KDC_OPT_CANONICALIZE));\n    if (ret) {\n        *status = \"KDC_RETURN_ENC_PADATA\";\n        goto cleanup;\n    }\n\n    ret = kau_make_tkt_id(context, &ticket_reply, &au_state->tkt_out_id);\n    if (ret)\n        goto cleanup;\n\n    if (kdc_fast_hide_client(fast_state))\n        reply.client = (krb5_principal)krb5_anonymous_principal();\n    ret = krb5_encode_kdc_rep(context, KRB5_TGS_REP, &reply_encpart,\n                              t->subkey != NULL, fast_reply_key, &reply,\n                              response);\n    if (ret)\n        goto cleanup;\n\n    log_tgs_req(context, from, t->req, &reply, t->cprinc, t->sprinc,\n                t->s4u_cprinc, t->authtime, t->flags, \"ISSUE\", 0, NULL);\n    au_state->status = \"ISSUE\";\n    au_state->reply = &reply;\n    if (t->flags & KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)\n        kau_s4u2proxy(context, TRUE, au_state);\n    kau_tgs_req(context, TRUE, au_state);\n    au_state->reply = NULL;\n\ncleanup:\n    zapfree(ticket_reply.enc_part.ciphertext.data,\n            ticket_reply.enc_part.ciphertext.length);\n    zapfree(reply.enc_part.ciphertext.data, reply.enc_part.ciphertext.length);\n    krb5_free_pa_data(context, reply.padata);\n    krb5_free_pa_data(context, reply_encpart.enc_padata);\n    krb5_free_authdata(context, enc_tkt_reply.authorization_data);\n    krb5_free_keyblock_contents(context, &session_key);\n    krb5_free_keyblock_contents(context, &server_key);\n    krb5_free_keyblock(context, fast_reply_key);\n    return ret;\n}",
  "abstract_func": "static krb5_error_code\ntgs_issue_ticket(kdc_realm_t *VAR_0, struct tgs_req_info *VAR_1,\n                 krb5_flags VAR_2, krb5_ticket_times *VAR_3, krb5_data *VAR_4,\n                 const krb5_fulladdr *VAR_5,\n                 struct kdc_request_state *VAR_6,\n                 krb5_audit_state *VAR_7, const char **VAR_8,\n                 krb5_data **VAR_9)\n{\n    krb5_context VAR_10 = VAR_0->realm_context;\n    krb5_error_code VAR_11;\n    krb5_keyblock VAR_12 = { 0 }, VAR_13 = { 0 };\n    krb5_keyblock *VAR_14, *VAR_15;\n    krb5_keyblock *VAR_16, *VAR_17 = NULL;\n    krb5_enc_tkt_part VAR_18 = { 0 };\n    krb5_ticket VAR_19 = { 0 };\n    krb5_enc_kdc_rep_part VAR_20 = { 0 };\n    krb5_kdc_rep VAR_21 = { 0 };\n    krb5_pac VAR_22;\n    krb5_db_entry *VAR_23;\n    krb5_enc_tkt_part *VAR_24 = VAR_1->header_tkt->enc_part2;\n    krb5_last_req_entry VAR_25 = { VAR_26, VAR_27, 0 };\n    krb5_last_req_entry *VAR_28[2] = { &VAR_25, NULL };\n\n    VAR_7->stage = VAR_29;\n\n    VAR_11 = gen_session_key(VAR_10, VAR_1->req, VAR_1->server, &VAR_12, VAR_8);\n    if (VAR_11)\n        goto cleanup;\n\n    if (VAR_1->flags & VAR_30) {\n        VAR_22 = VAR_1->stkt_pac;\n        VAR_23 = VAR_1->stkt_server;\n        VAR_15 = VAR_1->stkt_server_key;\n    } else {\n        VAR_22 = VAR_1->header_pac;\n        VAR_23 = VAR_1->header_server;\n        VAR_15 = VAR_1->header_key;\n    }\n\n    VAR_16 = (VAR_1->subkey != NULL) ? VAR_1->subkey :\n        VAR_1->header_tkt->enc_part2->session;\n\n    if (VAR_1->req->kdc_options & VAR_31) {\n        /* COMMENT_0 */\n                          \n        VAR_14 = VAR_1->stkt->enc_part2->session;\n    } else {\n        /* COMMENT_2 */\n                  \n        VAR_11 = get_first_current_key(VAR_10, VAR_1->server, &VAR_13);\n        if (VAR_11) {\n            *VAR_8 = \"FINDING_SERVER_KEY\";\n            goto cleanup;\n        }\n        VAR_14 = &VAR_13;\n    }\n\n    if (VAR_1->req->kdc_options & (VAR_32 | VAR_33)) {\n        /* COMMENT_4 */\n                                 \n        VAR_19.server = VAR_1->header_tkt->server;\n        VAR_18 = *VAR_1->header_tkt->enc_part2;\n        VAR_18.authorization_data = NULL;\n    } else {\n        if (VAR_1->req->kdc_options & (VAR_34 | VAR_35)) {\n            /* COMMENT_6 */\n            VAR_18.caddrs = VAR_1->req->addresses;\n            VAR_20.caddrs = VAR_1->req->addresses;\n        } else {\n            /* COMMENT_7 */\n            VAR_18.caddrs = VAR_24->caddrs;\n            VAR_20.caddrs = NULL;\n        }\n\n        VAR_19.server = VAR_1->is_referral ? VAR_1->sprinc : VAR_1->req->server;\n    }\n\n    VAR_18.flags = VAR_2;\n    VAR_18.times = *VAR_3;\n    VAR_18.client = VAR_1->tkt_client;\n    VAR_18.session = &VAR_12;\n    VAR_18.transited = VAR_1->transited;\n\n    VAR_11 = handle_authdata(VAR_0, VAR_1->flags, VAR_1->client, VAR_1->server,\n                          VAR_23, VAR_1->local_tgt, &VAR_1->local_tgt_key,\n                          VAR_16, VAR_14,\n                          VAR_15, NULL, VAR_4, VAR_1->req, VAR_1->s4u_cprinc,\n                          VAR_22, VAR_1->subject_tkt, &VAR_1->auth_indicators,\n                          &VAR_18);\n    if (VAR_11) {\n        krb5_klog_syslog(VAR_36, _(\"TGS_REQ : handle_authdata (%d)\"), VAR_11);\n        *VAR_8 = \"HANDLE_AUTHDATA\";\n        goto cleanup;\n    }\n\n    VAR_19.enc_part2 = &VAR_18;\n\n    VAR_11 = krb5_encrypt_tkt_part(VAR_10, VAR_14, &VAR_19);\n    if (VAR_11)\n        goto cleanup;\n\n    if (VAR_1->req->kdc_options & VAR_31) {\n        VAR_19.enc_part.kvno = 0;\n        kau_u2u(VAR_10, TRUE, VAR_7);\n    } else {\n        VAR_19.enc_part.kvno = current_kvno(VAR_1->server);\n    }\n\n    VAR_7->stage = VAR_37;\n\n    if (VAR_1->s4u2self != NULL &&\n        krb5int_find_pa_data(VAR_10, VAR_1->req->padata,\n                             VAR_38) != NULL) {\n        /* COMMENT_8 */\n                                                        \n        VAR_11 = kdc_make_s4u2self_rep(VAR_10, VAR_1->subkey,\n                                    VAR_1->header_tkt->enc_part2->session,\n                                    VAR_1->s4u2self, &VAR_21, &VAR_20);\n        if (VAR_11)\n            goto cleanup;\n    }\n\n    VAR_20.session = &VAR_12;\n    VAR_20.nonce = VAR_1->req->nonce;\n    VAR_20.times = VAR_18.times;\n    VAR_20.last_req = VAR_28;\n    VAR_20.key_exp = 0;\n    VAR_20.flags = VAR_18.flags;\n    VAR_20.server = VAR_19.server;\n\n    VAR_21.msg_type = VAR_39;\n    VAR_21.client = VAR_18.client;\n    VAR_21.ticket = &VAR_19;\n    VAR_21.enc_part.kvno = 0;\n    VAR_21.enc_part.enctype = VAR_16->enctype;\n    VAR_11 = kdc_fast_response_handle_padata(VAR_6, VAR_1->req, &VAR_21,\n                                          VAR_16->enctype);\n    if (VAR_11)\n        goto cleanup;\n    VAR_11 = kdc_fast_handle_reply_key(VAR_6, VAR_16,\n                                    &VAR_17);\n    if (VAR_11)\n        goto cleanup;\n    VAR_11 = return_enc_padata(VAR_10, VAR_4, VAR_1->req, VAR_17, VAR_1->server,\n                            &VAR_20,\n                            VAR_1->is_referral &&\n                            (VAR_1->req->kdc_options & VAR_40));\n    if (VAR_11) {\n        *VAR_8 = \"KDC_RETURN_ENC_PADATA\";\n        goto cleanup;\n    }\n\n    VAR_11 = kau_make_tkt_id(VAR_10, &VAR_19, &VAR_7->tkt_out_id);\n    if (VAR_11)\n        goto cleanup;\n\n    if (kdc_fast_hide_client(VAR_6))\n        VAR_21.client = (krb5_principal)krb5_anonymous_principal();\n    VAR_11 = krb5_encode_kdc_rep(VAR_10, VAR_39, &VAR_20,\n                              VAR_1->subkey != NULL, VAR_17, &VAR_21,\n                              VAR_9);\n    if (VAR_11)\n        goto cleanup;\n\n    log_tgs_req(VAR_10, VAR_5, VAR_1->req, &VAR_21, VAR_1->cprinc, VAR_1->sprinc,\n                VAR_1->s4u_cprinc, VAR_1->authtime, VAR_1->flags, \"ISSUE\", 0, NULL);\n    VAR_7->status = \"ISSUE\";\n    VAR_7->reply = &VAR_21;\n    if (VAR_1->flags & VAR_30)\n        kau_s4u2proxy(VAR_10, TRUE, VAR_7);\n    kau_tgs_req(VAR_10, TRUE, VAR_7);\n    VAR_7->reply = NULL;\n\ncleanup:\n    zapfree(VAR_19.enc_part.ciphertext.data,\n            VAR_19.enc_part.ciphertext.length);\n    zapfree(VAR_21.enc_part.ciphertext.data, VAR_21.enc_part.ciphertext.length);\n    krb5_free_pa_data(VAR_10, VAR_21.padata);\n    krb5_free_pa_data(VAR_10, VAR_20.enc_padata);\n    krb5_free_authdata(VAR_10, VAR_18.authorization_data);\n    krb5_free_keyblock_contents(VAR_10, &VAR_12);\n    krb5_free_keyblock_contents(VAR_10, &VAR_13);\n    krb5_free_keyblock(VAR_10, VAR_17);\n    return VAR_11;\n}",
  "func_graph_path": "krb5/88a1701b423c13991a8064feeb26952d3641d840/do_tgs_req.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -56,8 +56,9 @@\n     }\n \n     if (t->req->kdc_options & (KDC_OPT_VALIDATE | KDC_OPT_RENEW)) {\n-        /* Copy the whole header ticket except for authorization data. */\n-        ticket_reply = *t->header_tkt;\n+        /* Copy the header ticket server and all enc-part fields except for\n+         * authorization data. */\n+        ticket_reply.server = t->header_tkt->server;\n         enc_tkt_reply = *t->header_tkt->enc_part2;\n         enc_tkt_reply.authorization_data = NULL;\n     } else {",
  "diff_line_info": {
    "deleted_lines": [
      "        /* Copy the whole header ticket except for authorization data. */",
      "        ticket_reply = *t->header_tkt;"
    ],
    "added_lines": [
      "        /* Copy the header ticket server and all enc-part fields except for",
      "         * authorization data. */",
      "        ticket_reply.server = t->header_tkt->server;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/krb5/krb5/pull/1312",
  "description": {
    "pr_info": {
      "title": "kdc: Fix double free in free_req_info()",
      "number": 1312
    },
    "comment": [
      "Reproducer in Samba:\r\n`make test TESTS=samba.tests.krb5.kdc_tgs_tests`\r\n\r\n```\r\n/usr/sbin/krb5kdc: ================================================================= /usr/sbin/krb5kdc: ==6492==ERROR: AddressSanitizer: attempting double-free on 0x61a00025e080 in thread T0:\r\n/usr/sbin/krb5kdc:     #0 0x7f5c932dad08  (/usr/lib64/libasan.so.8.0.0+0xdad08) (BuildId: a24a20df2a1331371c666de9135abab342429d43)\r\n/usr/sbin/krb5kdc:     #1 0x7f5c9317df72 in krb5_free_ticket krb/kfree.c:455\r\n/usr/sbin/krb5kdc:     #2 0x7f5c9317df72 in krb5_free_ticket krb/kfree.c:450\r\n/usr/sbin/krb5kdc:     #3 0x417fb6 in free_req_info ../../src/kdc/do_tgs_req.c:1144\r\n/usr/sbin/krb5kdc:     #4 0x417fb6 in process_tgs_req ../../src/kdc/do_tgs_req.c:1225\r\n/usr/sbin/krb5kdc:     #5 0x40c35f in dispatch ../../src/kdc/dispatch.c:163\r\n/usr/sbin/krb5kdc:     #6 0x449411 in process_tcp_connection_read ../../../src/lib/apputils/net-server.c:1363\r\n/usr/sbin/krb5kdc:     #7 0x7f5c931053a7 in verto_fire (/lib64/libverto.so.1+0x43a7) (BuildId: dce5099f3ddd23bf63050ec1bd9f959814a709ee)\r\n/usr/sbin/krb5kdc:     #8 0x7f5c8d8f9625 in ev_invoke_pending (/lib64/libev.so.4+0x5625) (BuildId: db2a80899176970d5ae46767b5ba351c27607fd5)\r\n/usr/sbin/krb5kdc:     #9 0x7f5c8d8fd1cb in ev_run (/lib64/libev.so.4+0x91cb) (BuildId: db2a80899176970d5ae46767b5ba351c27607fd5)\r\n/usr/sbin/krb5kdc:     #10 0x4344a5 in main ../../src/kdc/main.c:1039\r\n/usr/sbin/krb5kdc:     #11 0x7f5c92a2abef in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58\r\n/usr/sbin/krb5kdc:     #12 0x7f5c92a2acb8 in __libc_start_main_impl ../csu/libc-start.c:360\r\n/usr/sbin/krb5kdc:     #13 0x4097a4 in _start ../sysdeps/x86_64/start.S:115\r\n/usr/sbin/krb5kdc:\r\n/usr/sbin/krb5kdc: 0x61a00025e080 is located 0 bytes inside of 1188-byte region [0x61a00025e080,0x61a00025e524)\r\n/usr/sbin/krb5kdc: freed by thread T0 here:\r\n/usr/sbin/krb5kdc:     #0 0x7f5c932dad08  (/usr/lib64/libasan.so.8.0.0+0xdad08) (BuildId: a24a20df2a1331371c666de9135abab342429d43)\r\n/usr/sbin/krb5kdc:     #1 0x4170ce in zapfree ../../src/include/k5-int.h:664\r\n/usr/sbin/krb5kdc:     #2 0x4170ce in tgs_issue_ticket ../../src/kdc/do_tgs_req.c:1128\r\n/usr/sbin/krb5kdc:     #3 0x4170ce in process_tgs_req ../../src/kdc/do_tgs_req.c:1195\r\n/usr/sbin/krb5kdc:     #4 0x40c35f in dispatch ../../src/kdc/dispatch.c:163\r\n/usr/sbin/krb5kdc:     #5 0x449411 in process_tcp_connection_read ../../../src/lib/apputils/net-server.c:1363\r\n/usr/sbin/krb5kdc:     #6 0x7f5c931053a7 in verto_fire (/lib64/libverto.so.1+0x43a7) (BuildId: dce5099f3ddd23bf63050ec1bd9f959814a709ee)\r\n/usr/sbin/krb5kdc:\r\n/usr/sbin/krb5kdc: previously allocated by thread T0 here:\r\n/usr/sbin/krb5kdc:     #0 0x7f5c932dc03f in malloc (/usr/lib64/libasan.so.8.0.0+0xdc03f) (BuildId: a24a20df2a1331371c666de9135abab342429d43)\r\n/usr/sbin/krb5kdc:     #1 0x7f5c93158f5d in k5_asn1_decode_bytestring asn.1/asn1_encode.c:232\r\n/usr/sbin/krb5kdc:     #2 0x6030000aaeef  (<unknown module>)\r\n/usr/sbin/krb5kdc:\r\n/usr/sbin/krb5kdc: SUMMARY: AddressSanitizer: double-free (/usr/lib64/libasan.so.8.0.0+0xdad08) (BuildId: a24a20df2a1331371c666de9135abab342429d43)\r\n/usr/sbin/krb5kdc: ==6492==ABORTING\r\n```",
      "I pushed an alternative fix.  Please let me know if it fares any worse on tests for you.\r\n",
      "Looks fine for me, tests are passing and AddressSanitizer has nothing to complain."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix\n\nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses a double-free vulnerability in the KDC TGS processing, which could be exploited by an authenticated attacker to cause a crash or execute arbitrary code. The code changes prevent pointer aliasing, thus fixing the security issue.\n\nFinal Classification: Security Vulnerability Fix\n\nConfidence Score: 1.0"
}