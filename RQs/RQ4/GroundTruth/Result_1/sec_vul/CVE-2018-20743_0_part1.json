{
  "cve_id": "CVE-2018-20743",
  "cwe_ids": [
    "CWE-20"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "mumble-voip/mumble",
  "commit_msg": "Prevent instability and crash due to message flood\n\nThis patch adds a rate limiting to selected patches. The underlying rate limiter\nused is the Leaky-Bucket algorithm. It allows for a burst of messages, but\nlimits them after a specified amount of messages within a time frame.",
  "commit_hash": "0daec57f5cfc4225aa4527b537b4ec4fbbc35635",
  "git_url": "https://github.com/mumble-voip/mumble/commit/0daec57f5cfc4225aa4527b537b4ec4fbbc35635",
  "file_path": "src/murmur/Messages.cpp",
  "func_name": "Server::msgChannelState",
  "func_before": "void Server::msgChannelState(ServerUser *uSource, MumbleProto::ChannelState &msg) {\n\tMSG_SETUP(ServerUser::Authenticated);\n\n\tChannel *c = NULL;\n\tChannel *p = NULL;\n\n\t// If this message relates to an existing channel check if the id is really valid\n\tif (msg.has_channel_id()) {\n\t\tc = qhChannels.value(msg.channel_id());\n\t\tif (! c)\n\t\t\treturn;\n\t}\n\n\t// Check if the parent exists\n\tif (msg.has_parent()) {\n\t\tp = qhChannels.value(msg.parent());\n\t\tif (! p)\n\t\t\treturn;\n\t}\n\n\tmsg.clear_links();\n\n\tQString qsName;\n\tQString qsDesc;\n\tif (msg.has_description()) {\n\t\tqsDesc = u8(msg.description());\n\t\tbool changed = false;\n\t\tif (! isTextAllowed(qsDesc, changed)) {\n\t\t\tPERM_DENIED_TYPE(TextTooLong);\n\t\t\treturn;\n\t\t}\n\t\tif (changed)\n\t\t\tmsg.set_description(u8(qsDesc));\n\t}\n\n\tif (msg.has_name()) {\n\t\t// If we are sent a channel name this means we want to create this channel so\n\t\t// check if the name is valid and not already in use.\n\t\tqsName = u8(msg.name());\n\n\t\tif (! validateChannelName(qsName)) {\n\t\t\tPERM_DENIED_TYPE(ChannelName);\n\t\t\treturn;\n\t\t}\n\n\t\tif (qsName.length() == 0) {\n\t\t\tPERM_DENIED_TYPE(ChannelName);\n\t\t\treturn;\n\t\t}\n\n\t\tif (p || (c && c->iId != 0)) {\n\t\t\tChannel *cp = p ? p : c->cParent;\n\t\t\tforeach(Channel *sibling, cp->qlChannels) {\n\t\t\t\tif (sibling->qsName == qsName) {\n\t\t\t\t\tPERM_DENIED_TYPE(ChannelName);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(p) {\n\t\t// Having a parent channel given means we either want to create\n\t\t// a channel in or move a channel into this parent.\n\n\t\tif (!canNest(p, c)) {\n\t\t\tPERM_DENIED_FALLBACK(NestingLimit, 0x010204, QLatin1String(\"Channel nesting limit reached\"));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (! c) {\n\t\t// If we don't have a channel handle up to now we want to create a new channel\n\t\t// so check if the user has enough rights and we got everything we need.\n\t\tif (! p || qsName.isNull())\n\t\t\treturn;\n\n\t\tif (iChannelCountLimit != 0 && qhChannels.count() >= iChannelCountLimit) {\n\t\t\tPERM_DENIED_FALLBACK(ChannelCountLimit, 0x010300, QLatin1String(\"Channel count limit reached\"));\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tChanACL::Perm perm = msg.temporary() ? ChanACL::MakeTempChannel : ChanACL::MakeChannel;\n\t\tif (! hasPermission(uSource, p, perm)) {\n\t\t\tPERM_DENIED(uSource, p, perm);\n\t\t\treturn;\n\t\t}\n\n\t\tif ((uSource->iId < 0) && uSource->qsHash.isEmpty()) {\n\t\t\tPERM_DENIED_HASH(uSource);\n\t\t\treturn;\n\t\t}\n\n\t\tif (p->bTemporary) {\n\t\t\tPERM_DENIED_TYPE(TemporaryChannel);\n\t\t\treturn;\n\t\t}\n\n\t\tc = addChannel(p, qsName, msg.temporary(), msg.position(), msg.max_users());\n\t\thashAssign(c->qsDesc, c->qbaDescHash, qsDesc);\n\n\t\tif (uSource->iId >= 0) {\n\t\t\tGroup *g = new Group(c, \"admin\");\n\t\t\tg->qsAdd << uSource->iId;\n\t\t}\n\n\t\tif (! hasPermission(uSource, c, ChanACL::Write)) {\n\t\t\tChanACL *a = new ChanACL(c);\n\t\t\ta->bApplyHere=true;\n\t\t\ta->bApplySubs=false;\n\t\t\tif (uSource->iId >= 0)\n\t\t\t\ta->iUserId=uSource->iId;\n\t\t\telse\n\t\t\t\ta->qsGroup=QLatin1Char('$') + uSource->qsHash;\n\t\t\ta->pDeny=ChanACL::None;\n\t\t\ta->pAllow=ChanACL::Write | ChanACL::Traverse;\n\n\t\t\tclearACLCache();\n\t\t}\n\t\tupdateChannel(c);\n\n\t\tmsg.set_channel_id(c->iId);\n\t\tlog(uSource, QString(\"Added channel %1 under %2\").arg(QString(*c), QString(*p)));\n\t\temit channelCreated(c);\n\n\t\tsendAll(msg, ~ 0x010202);\n\t\tif (! c->qbaDescHash.isEmpty()) {\n\t\t\tmsg.clear_description();\n\t\t\tmsg.set_description_hash(blob(c->qbaDescHash));\n\t\t}\n\t\tsendAll(msg, 0x010202);\n\n\t\tif (c->bTemporary) {\n\t\t\t// If a temporary channel has been created move the creator right in there\n\t\t\tMumbleProto::UserState mpus;\n\t\t\tmpus.set_session(uSource->uiSession);\n\t\t\tmpus.set_channel_id(c->iId);\n\t\t\tuserEnterChannel(uSource, c, mpus);\n\t\t\tsendAll(mpus);\n\t\t\temit userStateChanged(uSource);\n\t\t}\n\t} else {\n\t\t// The message is related to an existing channel c so check if the user is allowed to modify it\n\t\t// and perform the modifications\n\t\tif (! qsName.isNull()) {\n\t\t\tif (! hasPermission(uSource, c, ChanACL::Write) || (c->iId == 0)) {\n\t\t\t\tPERM_DENIED(uSource, c, ChanACL::Write);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (! qsDesc.isNull()) {\n\t\t\tif (! hasPermission(uSource, c, ChanACL::Write)) {\n\t\t\t\tPERM_DENIED(uSource, c, ChanACL::Write);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (msg.has_position()) {\n\t\t\tif (! hasPermission(uSource, c, ChanACL::Write)) {\n\t\t\t\tPERM_DENIED(uSource, c, ChanACL::Write);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (p) {\n\t\t\t// If we received a parent channel check if it differs from the old one and is not\n\t\t\t// Temporary. If that is the case check if the user has enough rights and if the\n\t\t\t// channel name is not used in the target location. Abort otherwise.\n\t\t\tif (p == c->cParent)\n\t\t\t\treturn;\n\n\t\t\tChannel *ip = p;\n\t\t\twhile (ip) {\n\t\t\t\tif (ip == c)\n\t\t\t\t\treturn;\n\t\t\t\tip = ip->cParent;\n\t\t\t}\n\n\t\t\tif (p->bTemporary) {\n\t\t\t\tPERM_DENIED_TYPE(TemporaryChannel);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (! hasPermission(uSource, c, ChanACL::Write)) {\n\t\t\t\tPERM_DENIED(uSource, c, ChanACL::Write);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (! hasPermission(uSource, p, ChanACL::MakeChannel)) {\n\t\t\t\tPERM_DENIED(uSource, p, ChanACL::MakeChannel);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tQString name = qsName.isNull() ? c->qsName : qsName;\n\n\t\t\tforeach(Channel *sibling, p->qlChannels) {\n\t\t\t\tif (sibling->qsName == name) {\n\t\t\t\t\tPERM_DENIED_TYPE(ChannelName);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tQList<Channel *> qlAdd;\n\t\tQList<Channel *> qlRemove;\n\n\t\tif (msg.links_add_size() || msg.links_remove_size()) {\n\t\t\tif (! hasPermission(uSource, c, ChanACL::LinkChannel)) {\n\t\t\t\tPERM_DENIED(uSource, c, ChanACL::LinkChannel);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (msg.links_remove_size()) {\n\t\t\t\tfor (int i=0;i < msg.links_remove_size(); ++i) {\n\t\t\t\t\tunsigned int link = msg.links_remove(i);\n\t\t\t\t\tChannel *l = qhChannels.value(link);\n\t\t\t\t\tif (! l)\n\t\t\t\t\t\treturn;\n\t\t\t\t\tqlRemove << l;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (msg.links_add_size()) {\n\t\t\t\tfor (int i=0;i < msg.links_add_size(); ++i) {\n\t\t\t\t\tunsigned int link = msg.links_add(i);\n\t\t\t\t\tChannel *l = qhChannels.value(link);\n\t\t\t\t\tif (! l)\n\t\t\t\t\t\treturn;\n\t\t\t\t\tif (! hasPermission(uSource, l, ChanACL::LinkChannel)) {\n\t\t\t\t\t\tPERM_DENIED(uSource, l, ChanACL::LinkChannel);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tqlAdd << l;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// All permission checks done -- the update is good.\n\n\t\tif (p) {\n\t\t\tlog(uSource, QString(\"Moved channel %1 from %2 to %3\").arg(QString(*c),\n\t\t\t        QString(* c->cParent),\n\t\t\t        QString(*p)));\n\n\t\t\t{\n\t\t\t\tQWriteLocker wl(&qrwlVoiceThread);\n\t\t\t\tc->cParent->removeChannel(c);\n\t\t\t\tp->addChannel(c);\n\t\t\t}\n\t\t}\n\t\tif (! qsName.isNull()) {\n\t\t\tlog(uSource, QString(\"Renamed channel %1 to %2\").arg(QString(*c),\n\t\t\t        QString(qsName)));\n\t\t\tc->qsName = qsName;\n\t\t}\n\t\tif (! qsDesc.isNull())\n\t\t\thashAssign(c->qsDesc, c->qbaDescHash, qsDesc);\n\n\t\tif (msg.has_position())\n\t\t\tc->iPosition = msg.position();\n\n\t\tforeach(Channel *l, qlAdd) {\n\t\t\taddLink(c, l);\n\t\t}\n\t\tforeach(Channel *l, qlRemove) {\n\t\t\tremoveLink(c, l);\n\t\t}\n\n\t\tif (msg.has_max_users())\n\t\t\tc->uiMaxUsers = msg.max_users();\n\n\t\tupdateChannel(c);\n\t\temit channelStateChanged(c);\n\n\t\tsendAll(msg, ~ 0x010202);\n\t\tif (msg.has_description() && ! c->qbaDescHash.isEmpty()) {\n\t\t\tmsg.clear_description();\n\t\t\tmsg.set_description_hash(blob(c->qbaDescHash));\n\t\t}\n\t\tsendAll(msg, 0x010202);\n\t}\n}",
  "abstract_func_before": "void Server::msgChannelState(ServerUser *VAR_0, MumbleProto::ChannelState &VAR_1) {\n\tMSG_SETUP(ServerUser::Authenticated);\n\n\tChannel *VAR_2 = NULL;\n\tChannel *VAR_3 = NULL;\n\n\t/* COMMENT_0 */\n\tif (VAR_1.has_channel_id()) {\n\t\tVAR_2 = VAR_4.value(VAR_1.channel_id());\n\t\tif (! VAR_2)\n\t\t\treturn;\n\t}\n\n\t/* COMMENT_1 */\n\tif (VAR_1.has_parent()) {\n\t\tVAR_3 = VAR_4.value(VAR_1.parent());\n\t\tif (! VAR_3)\n\t\t\treturn;\n\t}\n\n\tVAR_1.clear_links();\n\n\tQString VAR_5;\n\tQString VAR_6;\n\tif (VAR_1.has_description()) {\n\t\tVAR_6 = u8(VAR_1.description());\n\t\tbool VAR_7 = false;\n\t\tif (! isTextAllowed(VAR_6, VAR_7)) {\n\t\t\tPERM_DENIED_TYPE(VAR_8);\n\t\t\treturn;\n\t\t}\n\t\tif (VAR_7)\n\t\t\tVAR_1.set_description(u8(VAR_6));\n\t}\n\n\tif (VAR_1.has_name()) {\n\t\t/* COMMENT_2 */\n\t\t/* COMMENT_3 */\n\t\tVAR_5 = u8(VAR_1.name());\n\n\t\tif (! validateChannelName(VAR_5)) {\n\t\t\tPERM_DENIED_TYPE(VAR_9);\n\t\t\treturn;\n\t\t}\n\n\t\tif (VAR_5.length() == 0) {\n\t\t\tPERM_DENIED_TYPE(VAR_9);\n\t\t\treturn;\n\t\t}\n\n\t\tif (VAR_3 || (VAR_2 && VAR_2->iId != 0)) {\n\t\t\tChannel *VAR_10 = VAR_3 ? VAR_3 : VAR_2->cParent;\n\t\t\tforeach(Channel *VAR_11, VAR_10->qlChannels) {\n\t\t\t\tif (VAR_11->qsName == VAR_5) {\n\t\t\t\t\tPERM_DENIED_TYPE(VAR_9);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(VAR_3) {\n\t\t/* COMMENT_4 */\n\t\t/* COMMENT_5 */\n\n\t\tif (!canNest(VAR_3, VAR_2)) {\n\t\t\tPERM_DENIED_FALLBACK(VAR_12, 0x010204, QLatin1String(\"Channel nesting limit reached\"));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (! VAR_2) {\n\t\t/* COMMENT_6 */\n\t\t/* COMMENT_7 */\n\t\tif (! VAR_3 || VAR_5.isNull())\n\t\t\treturn;\n\n\t\tif (VAR_13 != 0 && VAR_4.count() >= VAR_13) {\n\t\t\tPERM_DENIED_FALLBACK(VAR_14, 0x010300, QLatin1String(\"Channel count limit reached\"));\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tChanACL::Perm VAR_15 = VAR_1.temporary() ? ChanACL::MakeTempChannel : ChanACL::MakeChannel;\n\t\tif (! hasPermission(VAR_0, VAR_3, VAR_15)) {\n\t\t\tPERM_DENIED(VAR_0, VAR_3, VAR_15);\n\t\t\treturn;\n\t\t}\n\n\t\tif ((VAR_0->iId < 0) && VAR_0->qsHash.isEmpty()) {\n\t\t\tPERM_DENIED_HASH(VAR_0);\n\t\t\treturn;\n\t\t}\n\n\t\tif (VAR_3->bTemporary) {\n\t\t\tPERM_DENIED_TYPE(VAR_16);\n\t\t\treturn;\n\t\t}\n\n\t\tVAR_2 = addChannel(VAR_3, VAR_5, VAR_1.temporary(), VAR_1.position(), VAR_1.max_users());\n\t\thashAssign(VAR_2->qsDesc, VAR_2->qbaDescHash, VAR_6);\n\n\t\tif (VAR_0->iId >= 0) {\n\t\t\tGroup *VAR_17 = new Group(VAR_2, \"admin\");\n\t\t\tVAR_17->qsAdd << VAR_0->iId;\n\t\t}\n\n\t\tif (! hasPermission(VAR_0, VAR_2, ChanACL::Write)) {\n\t\t\tChanACL *VAR_18 = new ChanACL(VAR_2);\n\t\t\tVAR_18->bApplyHere=true;\n\t\t\tVAR_18->bApplySubs=false;\n\t\t\tif (VAR_0->iId >= 0)\n\t\t\t\tVAR_18->iUserId=VAR_0->iId;\n\t\t\telse\n\t\t\t\tVAR_18->qsGroup=QLatin1Char('$') + VAR_0->qsHash;\n\t\t\tVAR_18->pDeny=ChanACL::None;\n\t\t\tVAR_18->pAllow=ChanACL::Write | ChanACL::Traverse;\n\n\t\t\tclearACLCache();\n\t\t}\n\t\tupdateChannel(VAR_2);\n\n\t\tVAR_1.set_channel_id(VAR_2->iId);\n\t\tlog(VAR_0, QString(\"Added channel %1 under %2\").arg(QString(*VAR_2), QString(*VAR_3)));\n\t\temit channelCreated(c);\n\n\t\tsendAll(VAR_1, ~ 0x010202);\n\t\tif (! c->qbaDescHash.isEmpty()) {\n\t\t\tVAR_1.clear_description();\n\t\t\tVAR_1.set_description_hash(blob(c->qbaDescHash));\n\t\t}\n\t\tsendAll(VAR_1, 0x010202);\n\n\t\tif (c->bTemporary) {\n\t\t\t/* COMMENT_8 */\n\t\t\tMumbleProto::UserState VAR_19;\n\t\t\tVAR_19.set_session(VAR_0->uiSession);\n\t\t\tVAR_19.set_channel_id(c->iId);\n\t\t\tuserEnterChannel(VAR_0, c, VAR_19);\n\t\t\tsendAll(VAR_19);\n\t\t\temit userStateChanged(uSource);\n\t\t}\n\t} else {\n\t\t/* COMMENT_9 */\n\t\t/* COMMENT_10 */\n\t\tif (! VAR_5.isNull()) {\n\t\t\tif (! hasPermission(uSource, c, ChanACL::Write) || (c->iId == 0)) {\n\t\t\t\tPERM_DENIED(uSource, c, ChanACL::Write);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (! VAR_6.isNull()) {\n\t\t\tif (! hasPermission(uSource, c, ChanACL::Write)) {\n\t\t\t\tPERM_DENIED(uSource, c, ChanACL::Write);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (VAR_1.has_position()) {\n\t\t\tif (! hasPermission(uSource, c, ChanACL::Write)) {\n\t\t\t\tPERM_DENIED(uSource, c, ChanACL::Write);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (VAR_3) {\n\t\t\t/* COMMENT_11 */\n\t\t\t/* COMMENT_12 */\n\t\t\t/* COMMENT_13 */\n\t\t\tif (VAR_3 == c->cParent)\n\t\t\t\treturn;\n\n\t\t\tChannel *VAR_20 = VAR_3;\n\t\t\twhile (VAR_20) {\n\t\t\t\tif (VAR_20 == c)\n\t\t\t\t\treturn;\n\t\t\t\tVAR_20 = VAR_20->cParent;\n\t\t\t}\n\n\t\t\tif (VAR_3->bTemporary) {\n\t\t\t\tPERM_DENIED_TYPE(VAR_16);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (! hasPermission(uSource, c, ChanACL::Write)) {\n\t\t\t\tPERM_DENIED(uSource, c, ChanACL::Write);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (! hasPermission(uSource, VAR_3, ChanACL::MakeChannel)) {\n\t\t\t\tPERM_DENIED(uSource, VAR_3, ChanACL::MakeChannel);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tQString VAR_21 = VAR_5.isNull() ? c->qsName : VAR_5;\n\n\t\t\tforeach(Channel *VAR_11, VAR_3->qlChannels) {\n\t\t\t\tif (VAR_11->qsName == VAR_21) {\n\t\t\t\t\tPERM_DENIED_TYPE(VAR_9);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tQList<Channel *> VAR_22;\n\t\tQList<Channel *> VAR_23;\n\n\t\tif (VAR_1.links_add_size() || VAR_1.links_remove_size()) {\n\t\t\tif (! hasPermission(uSource, c, ChanACL::LinkChannel)) {\n\t\t\t\tPERM_DENIED(uSource, c, ChanACL::LinkChannel);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (VAR_1.links_remove_size()) {\n\t\t\t\tfor (int VAR_24=0;VAR_24 < VAR_1.links_remove_size(); ++VAR_24) {\n\t\t\t\t\tunsigned int VAR_25 = VAR_1.links_remove(VAR_24);\n\t\t\t\t\tChannel *VAR_26 = VAR_4.value(VAR_25);\n\t\t\t\t\tif (! VAR_26)\n\t\t\t\t\t\treturn;\n\t\t\t\t\tVAR_23 << VAR_26;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (VAR_1.links_add_size()) {\n\t\t\t\tfor (int VAR_24=0;VAR_24 < VAR_1.links_add_size(); ++VAR_24) {\n\t\t\t\t\tunsigned int VAR_25 = VAR_1.links_add(VAR_24);\n\t\t\t\t\tChannel *VAR_26 = VAR_4.value(VAR_25);\n\t\t\t\t\tif (! VAR_26)\n\t\t\t\t\t\treturn;\n\t\t\t\t\tif (! hasPermission(uSource, VAR_26, ChanACL::LinkChannel)) {\n\t\t\t\t\t\tPERM_DENIED(uSource, VAR_26, ChanACL::LinkChannel);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tVAR_22 << VAR_26;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* COMMENT_14 */\n\n\t\tif (VAR_3) {\n\t\t\tlog(uSource, QString(\"Moved channel %1 from %2 to %3\").arg(QString(*c),\n\t\t\t        QString(* c->cParent),\n\t\t\t        QString(*VAR_3)));\n\n\t\t\t{\n\t\t\t\tQWriteLocker VAR_27(&VAR_28);\n\t\t\t\tc->cParent->removeChannel(c);\n\t\t\t\tVAR_3->addChannel(c);\n\t\t\t}\n\t\t}\n\t\tif (! VAR_5.isNull()) {\n\t\t\tlog(uSource, QString(\"Renamed channel %1 to %2\").arg(QString(*c),\n\t\t\t        QString(VAR_5)));\n\t\t\tc->qsName = VAR_5;\n\t\t}\n\t\tif (! VAR_6.isNull())\n\t\t\thashAssign(c->qsDesc, c->qbaDescHash, VAR_6);\n\n\t\tif (VAR_1.has_position())\n\t\t\tc->iPosition = VAR_1.position();\n\n\t\tforeach(Channel *VAR_26, qlAdd) {\n\t\t\taddLink(c, VAR_26);\n\t\t}\n\t\tforeach(Channel *VAR_26, qlRemove) {\n\t\t\tremoveLink(c, VAR_26);\n\t\t}\n\n\t\tif (VAR_1.has_max_users())\n\t\t\tc->uiMaxUsers = VAR_1.max_users();\n\n\t\tupdateChannel(c);\n\t\temit channelStateChanged(c);\n\n\t\tsendAll(VAR_1, ~ 0x010202);\n\t\tif (VAR_1.has_description() && ! c->qbaDescHash.isEmpty()) {\n\t\t\tVAR_1.clear_description();\n\t\t\tVAR_1.set_description_hash(blob(c->qbaDescHash));\n\t\t}\n\t\tsendAll(VAR_1, 0x010202);\n\t}\n}",
  "func_graph_path_before": "mumble-voip/mumble/0daec57f5cfc4225aa4527b537b4ec4fbbc35635/Messages.cpp/vul/before/1.json",
  "func": "void Server::msgChannelState(ServerUser *uSource, MumbleProto::ChannelState &msg) {\n\tMSG_SETUP(ServerUser::Authenticated);\n\n\tChannel *c = NULL;\n\tChannel *p = NULL;\n\n\t// If this message relates to an existing channel check if the id is really valid\n\tif (msg.has_channel_id()) {\n\t\tc = qhChannels.value(msg.channel_id());\n\t\tif (! c)\n\t\t\treturn;\n\t} else {\n\t\tRATELIMIT(uSource);\n\t}\n\n\t// Check if the parent exists\n\tif (msg.has_parent()) {\n\t\tp = qhChannels.value(msg.parent());\n\t\tif (! p)\n\t\t\treturn;\n\t}\n\n\tmsg.clear_links();\n\n\tQString qsName;\n\tQString qsDesc;\n\tif (msg.has_description()) {\n\t\tqsDesc = u8(msg.description());\n\t\tbool changed = false;\n\t\tif (! isTextAllowed(qsDesc, changed)) {\n\t\t\tPERM_DENIED_TYPE(TextTooLong);\n\t\t\treturn;\n\t\t}\n\t\tif (changed)\n\t\t\tmsg.set_description(u8(qsDesc));\n\t}\n\n\tif (msg.has_name()) {\n\t\t// If we are sent a channel name this means we want to create this channel so\n\t\t// check if the name is valid and not already in use.\n\t\tqsName = u8(msg.name());\n\n\t\tif (! validateChannelName(qsName)) {\n\t\t\tPERM_DENIED_TYPE(ChannelName);\n\t\t\treturn;\n\t\t}\n\n\t\tif (qsName.length() == 0) {\n\t\t\tPERM_DENIED_TYPE(ChannelName);\n\t\t\treturn;\n\t\t}\n\n\t\tif (p || (c && c->iId != 0)) {\n\t\t\tChannel *cp = p ? p : c->cParent;\n\t\t\tforeach(Channel *sibling, cp->qlChannels) {\n\t\t\t\tif (sibling->qsName == qsName) {\n\t\t\t\t\tPERM_DENIED_TYPE(ChannelName);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(p) {\n\t\t// Having a parent channel given means we either want to create\n\t\t// a channel in or move a channel into this parent.\n\n\t\tif (!canNest(p, c)) {\n\t\t\tPERM_DENIED_FALLBACK(NestingLimit, 0x010204, QLatin1String(\"Channel nesting limit reached\"));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (! c) {\n\t\t// If we don't have a channel handle up to now we want to create a new channel\n\t\t// so check if the user has enough rights and we got everything we need.\n\t\tif (! p || qsName.isNull())\n\t\t\treturn;\n\n\t\tif (iChannelCountLimit != 0 && qhChannels.count() >= iChannelCountLimit) {\n\t\t\tPERM_DENIED_FALLBACK(ChannelCountLimit, 0x010300, QLatin1String(\"Channel count limit reached\"));\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tChanACL::Perm perm = msg.temporary() ? ChanACL::MakeTempChannel : ChanACL::MakeChannel;\n\t\tif (! hasPermission(uSource, p, perm)) {\n\t\t\tPERM_DENIED(uSource, p, perm);\n\t\t\treturn;\n\t\t}\n\n\t\tif ((uSource->iId < 0) && uSource->qsHash.isEmpty()) {\n\t\t\tPERM_DENIED_HASH(uSource);\n\t\t\treturn;\n\t\t}\n\n\t\tif (p->bTemporary) {\n\t\t\tPERM_DENIED_TYPE(TemporaryChannel);\n\t\t\treturn;\n\t\t}\n\n\t\tc = addChannel(p, qsName, msg.temporary(), msg.position(), msg.max_users());\n\t\thashAssign(c->qsDesc, c->qbaDescHash, qsDesc);\n\n\t\tif (uSource->iId >= 0) {\n\t\t\tGroup *g = new Group(c, \"admin\");\n\t\t\tg->qsAdd << uSource->iId;\n\t\t}\n\n\t\tif (! hasPermission(uSource, c, ChanACL::Write)) {\n\t\t\tChanACL *a = new ChanACL(c);\n\t\t\ta->bApplyHere=true;\n\t\t\ta->bApplySubs=false;\n\t\t\tif (uSource->iId >= 0)\n\t\t\t\ta->iUserId=uSource->iId;\n\t\t\telse\n\t\t\t\ta->qsGroup=QLatin1Char('$') + uSource->qsHash;\n\t\t\ta->pDeny=ChanACL::None;\n\t\t\ta->pAllow=ChanACL::Write | ChanACL::Traverse;\n\n\t\t\tclearACLCache();\n\t\t}\n\t\tupdateChannel(c);\n\n\t\tmsg.set_channel_id(c->iId);\n\t\tlog(uSource, QString(\"Added channel %1 under %2\").arg(QString(*c), QString(*p)));\n\t\temit channelCreated(c);\n\n\t\tsendAll(msg, ~ 0x010202);\n\t\tif (! c->qbaDescHash.isEmpty()) {\n\t\t\tmsg.clear_description();\n\t\t\tmsg.set_description_hash(blob(c->qbaDescHash));\n\t\t}\n\t\tsendAll(msg, 0x010202);\n\n\t\tif (c->bTemporary) {\n\t\t\t// If a temporary channel has been created move the creator right in there\n\t\t\tMumbleProto::UserState mpus;\n\t\t\tmpus.set_session(uSource->uiSession);\n\t\t\tmpus.set_channel_id(c->iId);\n\t\t\tuserEnterChannel(uSource, c, mpus);\n\t\t\tsendAll(mpus);\n\t\t\temit userStateChanged(uSource);\n\t\t}\n\t} else {\n\t\t// The message is related to an existing channel c so check if the user is allowed to modify it\n\t\t// and perform the modifications\n\t\tif (! qsName.isNull()) {\n\t\t\tif (! hasPermission(uSource, c, ChanACL::Write) || (c->iId == 0)) {\n\t\t\t\tPERM_DENIED(uSource, c, ChanACL::Write);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (! qsDesc.isNull()) {\n\t\t\tif (! hasPermission(uSource, c, ChanACL::Write)) {\n\t\t\t\tPERM_DENIED(uSource, c, ChanACL::Write);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (msg.has_position()) {\n\t\t\tif (! hasPermission(uSource, c, ChanACL::Write)) {\n\t\t\t\tPERM_DENIED(uSource, c, ChanACL::Write);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (p) {\n\t\t\t// If we received a parent channel check if it differs from the old one and is not\n\t\t\t// Temporary. If that is the case check if the user has enough rights and if the\n\t\t\t// channel name is not used in the target location. Abort otherwise.\n\t\t\tif (p == c->cParent)\n\t\t\t\treturn;\n\n\t\t\tChannel *ip = p;\n\t\t\twhile (ip) {\n\t\t\t\tif (ip == c)\n\t\t\t\t\treturn;\n\t\t\t\tip = ip->cParent;\n\t\t\t}\n\n\t\t\tif (p->bTemporary) {\n\t\t\t\tPERM_DENIED_TYPE(TemporaryChannel);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (! hasPermission(uSource, c, ChanACL::Write)) {\n\t\t\t\tPERM_DENIED(uSource, c, ChanACL::Write);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (! hasPermission(uSource, p, ChanACL::MakeChannel)) {\n\t\t\t\tPERM_DENIED(uSource, p, ChanACL::MakeChannel);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tQString name = qsName.isNull() ? c->qsName : qsName;\n\n\t\t\tforeach(Channel *sibling, p->qlChannels) {\n\t\t\t\tif (sibling->qsName == name) {\n\t\t\t\t\tPERM_DENIED_TYPE(ChannelName);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tQList<Channel *> qlAdd;\n\t\tQList<Channel *> qlRemove;\n\n\t\tif (msg.links_add_size() || msg.links_remove_size()) {\n\t\t\tif (! hasPermission(uSource, c, ChanACL::LinkChannel)) {\n\t\t\t\tPERM_DENIED(uSource, c, ChanACL::LinkChannel);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (msg.links_remove_size()) {\n\t\t\t\tfor (int i=0;i < msg.links_remove_size(); ++i) {\n\t\t\t\t\tunsigned int link = msg.links_remove(i);\n\t\t\t\t\tChannel *l = qhChannels.value(link);\n\t\t\t\t\tif (! l)\n\t\t\t\t\t\treturn;\n\t\t\t\t\tqlRemove << l;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (msg.links_add_size()) {\n\t\t\t\tfor (int i=0;i < msg.links_add_size(); ++i) {\n\t\t\t\t\tunsigned int link = msg.links_add(i);\n\t\t\t\t\tChannel *l = qhChannels.value(link);\n\t\t\t\t\tif (! l)\n\t\t\t\t\t\treturn;\n\t\t\t\t\tif (! hasPermission(uSource, l, ChanACL::LinkChannel)) {\n\t\t\t\t\t\tPERM_DENIED(uSource, l, ChanACL::LinkChannel);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tqlAdd << l;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// All permission checks done -- the update is good.\n\n\t\tif (p) {\n\t\t\tlog(uSource, QString(\"Moved channel %1 from %2 to %3\").arg(QString(*c),\n\t\t\t        QString(* c->cParent),\n\t\t\t        QString(*p)));\n\n\t\t\t{\n\t\t\t\tQWriteLocker wl(&qrwlVoiceThread);\n\t\t\t\tc->cParent->removeChannel(c);\n\t\t\t\tp->addChannel(c);\n\t\t\t}\n\t\t}\n\t\tif (! qsName.isNull()) {\n\t\t\tlog(uSource, QString(\"Renamed channel %1 to %2\").arg(QString(*c),\n\t\t\t        QString(qsName)));\n\t\t\tc->qsName = qsName;\n\t\t}\n\t\tif (! qsDesc.isNull())\n\t\t\thashAssign(c->qsDesc, c->qbaDescHash, qsDesc);\n\n\t\tif (msg.has_position())\n\t\t\tc->iPosition = msg.position();\n\n\t\tforeach(Channel *l, qlAdd) {\n\t\t\taddLink(c, l);\n\t\t}\n\t\tforeach(Channel *l, qlRemove) {\n\t\t\tremoveLink(c, l);\n\t\t}\n\n\t\tif (msg.has_max_users())\n\t\t\tc->uiMaxUsers = msg.max_users();\n\n\t\tupdateChannel(c);\n\t\temit channelStateChanged(c);\n\n\t\tsendAll(msg, ~ 0x010202);\n\t\tif (msg.has_description() && ! c->qbaDescHash.isEmpty()) {\n\t\t\tmsg.clear_description();\n\t\t\tmsg.set_description_hash(blob(c->qbaDescHash));\n\t\t}\n\t\tsendAll(msg, 0x010202);\n\t}\n}",
  "abstract_func": "void Server::msgChannelState(ServerUser *VAR_0, MumbleProto::ChannelState &VAR_1) {\n\tMSG_SETUP(ServerUser::Authenticated);\n\n\tChannel *VAR_2 = NULL;\n\tChannel *VAR_3 = NULL;\n\n\t/* COMMENT_0 */\n\tif (VAR_1.has_channel_id()) {\n\t\tVAR_2 = VAR_4.value(VAR_1.channel_id());\n\t\tif (! VAR_2)\n\t\t\treturn;\n\t} else {\n\t\tRATELIMIT(VAR_0);\n\t}\n\n\t/* COMMENT_1 */\n\tif (VAR_1.has_parent()) {\n\t\tVAR_3 = VAR_4.value(VAR_1.parent());\n\t\tif (! VAR_3)\n\t\t\treturn;\n\t}\n\n\tVAR_1.clear_links();\n\n\tQString VAR_5;\n\tQString VAR_6;\n\tif (VAR_1.has_description()) {\n\t\tVAR_6 = u8(VAR_1.description());\n\t\tbool VAR_7 = false;\n\t\tif (! isTextAllowed(VAR_6, VAR_7)) {\n\t\t\tPERM_DENIED_TYPE(VAR_8);\n\t\t\treturn;\n\t\t}\n\t\tif (VAR_7)\n\t\t\tVAR_1.set_description(u8(VAR_6));\n\t}\n\n\tif (VAR_1.has_name()) {\n\t\t/* COMMENT_2 */\n\t\t/* COMMENT_3 */\n\t\tVAR_5 = u8(VAR_1.name());\n\n\t\tif (! validateChannelName(VAR_5)) {\n\t\t\tPERM_DENIED_TYPE(VAR_9);\n\t\t\treturn;\n\t\t}\n\n\t\tif (VAR_5.length() == 0) {\n\t\t\tPERM_DENIED_TYPE(VAR_9);\n\t\t\treturn;\n\t\t}\n\n\t\tif (VAR_3 || (VAR_2 && VAR_2->iId != 0)) {\n\t\t\tChannel *VAR_10 = VAR_3 ? VAR_3 : VAR_2->cParent;\n\t\t\tforeach(Channel *VAR_11, VAR_10->qlChannels) {\n\t\t\t\tif (VAR_11->qsName == VAR_5) {\n\t\t\t\t\tPERM_DENIED_TYPE(VAR_9);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(VAR_3) {\n\t\t/* COMMENT_4 */\n\t\t/* COMMENT_5 */\n\n\t\tif (!canNest(VAR_3, VAR_2)) {\n\t\t\tPERM_DENIED_FALLBACK(VAR_12, 0x010204, QLatin1String(\"Channel nesting limit reached\"));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (! VAR_2) {\n\t\t/* COMMENT_6 */\n\t\t/* COMMENT_7 */\n\t\tif (! VAR_3 || VAR_5.isNull())\n\t\t\treturn;\n\n\t\tif (VAR_13 != 0 && VAR_4.count() >= VAR_13) {\n\t\t\tPERM_DENIED_FALLBACK(VAR_14, 0x010300, QLatin1String(\"Channel count limit reached\"));\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tChanACL::Perm VAR_15 = VAR_1.temporary() ? ChanACL::MakeTempChannel : ChanACL::MakeChannel;\n\t\tif (! hasPermission(VAR_0, VAR_3, VAR_15)) {\n\t\t\tPERM_DENIED(VAR_0, VAR_3, VAR_15);\n\t\t\treturn;\n\t\t}\n\n\t\tif ((VAR_0->iId < 0) && VAR_0->qsHash.isEmpty()) {\n\t\t\tPERM_DENIED_HASH(VAR_0);\n\t\t\treturn;\n\t\t}\n\n\t\tif (VAR_3->bTemporary) {\n\t\t\tPERM_DENIED_TYPE(VAR_16);\n\t\t\treturn;\n\t\t}\n\n\t\tVAR_2 = addChannel(VAR_3, VAR_5, VAR_1.temporary(), VAR_1.position(), VAR_1.max_users());\n\t\thashAssign(VAR_2->qsDesc, VAR_2->qbaDescHash, VAR_6);\n\n\t\tif (VAR_0->iId >= 0) {\n\t\t\tGroup *VAR_17 = new Group(VAR_2, \"admin\");\n\t\t\tVAR_17->qsAdd << VAR_0->iId;\n\t\t}\n\n\t\tif (! hasPermission(VAR_0, VAR_2, ChanACL::Write)) {\n\t\t\tChanACL *VAR_18 = new ChanACL(VAR_2);\n\t\t\tVAR_18->bApplyHere=true;\n\t\t\tVAR_18->bApplySubs=false;\n\t\t\tif (VAR_0->iId >= 0)\n\t\t\t\tVAR_18->iUserId=VAR_0->iId;\n\t\t\telse\n\t\t\t\tVAR_18->qsGroup=QLatin1Char('$') + VAR_0->qsHash;\n\t\t\tVAR_18->pDeny=ChanACL::None;\n\t\t\tVAR_18->pAllow=ChanACL::Write | ChanACL::Traverse;\n\n\t\t\tclearACLCache();\n\t\t}\n\t\tupdateChannel(VAR_2);\n\n\t\tVAR_1.set_channel_id(VAR_2->iId);\n\t\tlog(VAR_0, QString(\"Added channel %1 under %2\").arg(QString(*VAR_2), QString(*VAR_3)));\n\t\temit channelCreated(c);\n\n\t\tsendAll(VAR_1, ~ 0x010202);\n\t\tif (! c->qbaDescHash.isEmpty()) {\n\t\t\tVAR_1.clear_description();\n\t\t\tVAR_1.set_description_hash(blob(c->qbaDescHash));\n\t\t}\n\t\tsendAll(VAR_1, 0x010202);\n\n\t\tif (c->bTemporary) {\n\t\t\t/* COMMENT_8 */\n\t\t\tMumbleProto::UserState VAR_19;\n\t\t\tVAR_19.set_session(VAR_0->uiSession);\n\t\t\tVAR_19.set_channel_id(c->iId);\n\t\t\tuserEnterChannel(VAR_0, c, VAR_19);\n\t\t\tsendAll(VAR_19);\n\t\t\temit userStateChanged(uSource);\n\t\t}\n\t} else {\n\t\t/* COMMENT_9 */\n\t\t/* COMMENT_10 */\n\t\tif (! VAR_5.isNull()) {\n\t\t\tif (! hasPermission(uSource, c, ChanACL::Write) || (c->iId == 0)) {\n\t\t\t\tPERM_DENIED(uSource, c, ChanACL::Write);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (! VAR_6.isNull()) {\n\t\t\tif (! hasPermission(uSource, c, ChanACL::Write)) {\n\t\t\t\tPERM_DENIED(uSource, c, ChanACL::Write);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (VAR_1.has_position()) {\n\t\t\tif (! hasPermission(uSource, c, ChanACL::Write)) {\n\t\t\t\tPERM_DENIED(uSource, c, ChanACL::Write);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (VAR_3) {\n\t\t\t/* COMMENT_11 */\n\t\t\t/* COMMENT_12 */\n\t\t\t/* COMMENT_13 */\n\t\t\tif (VAR_3 == c->cParent)\n\t\t\t\treturn;\n\n\t\t\tChannel *VAR_20 = VAR_3;\n\t\t\twhile (VAR_20) {\n\t\t\t\tif (VAR_20 == c)\n\t\t\t\t\treturn;\n\t\t\t\tVAR_20 = VAR_20->cParent;\n\t\t\t}\n\n\t\t\tif (VAR_3->bTemporary) {\n\t\t\t\tPERM_DENIED_TYPE(VAR_16);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (! hasPermission(uSource, c, ChanACL::Write)) {\n\t\t\t\tPERM_DENIED(uSource, c, ChanACL::Write);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (! hasPermission(uSource, VAR_3, ChanACL::MakeChannel)) {\n\t\t\t\tPERM_DENIED(uSource, VAR_3, ChanACL::MakeChannel);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tQString VAR_21 = VAR_5.isNull() ? c->qsName : VAR_5;\n\n\t\t\tforeach(Channel *VAR_11, VAR_3->qlChannels) {\n\t\t\t\tif (VAR_11->qsName == VAR_21) {\n\t\t\t\t\tPERM_DENIED_TYPE(VAR_9);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tQList<Channel *> VAR_22;\n\t\tQList<Channel *> VAR_23;\n\n\t\tif (VAR_1.links_add_size() || VAR_1.links_remove_size()) {\n\t\t\tif (! hasPermission(uSource, c, ChanACL::LinkChannel)) {\n\t\t\t\tPERM_DENIED(uSource, c, ChanACL::LinkChannel);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (VAR_1.links_remove_size()) {\n\t\t\t\tfor (int VAR_24=0;VAR_24 < VAR_1.links_remove_size(); ++VAR_24) {\n\t\t\t\t\tunsigned int VAR_25 = VAR_1.links_remove(VAR_24);\n\t\t\t\t\tChannel *VAR_26 = VAR_4.value(VAR_25);\n\t\t\t\t\tif (! VAR_26)\n\t\t\t\t\t\treturn;\n\t\t\t\t\tVAR_23 << VAR_26;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (VAR_1.links_add_size()) {\n\t\t\t\tfor (int VAR_24=0;VAR_24 < VAR_1.links_add_size(); ++VAR_24) {\n\t\t\t\t\tunsigned int VAR_25 = VAR_1.links_add(VAR_24);\n\t\t\t\t\tChannel *VAR_26 = VAR_4.value(VAR_25);\n\t\t\t\t\tif (! VAR_26)\n\t\t\t\t\t\treturn;\n\t\t\t\t\tif (! hasPermission(uSource, VAR_26, ChanACL::LinkChannel)) {\n\t\t\t\t\t\tPERM_DENIED(uSource, VAR_26, ChanACL::LinkChannel);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tVAR_22 << VAR_26;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* COMMENT_14 */\n\n\t\tif (VAR_3) {\n\t\t\tlog(uSource, QString(\"Moved channel %1 from %2 to %3\").arg(QString(*c),\n\t\t\t        QString(* c->cParent),\n\t\t\t        QString(*VAR_3)));\n\n\t\t\t{\n\t\t\t\tQWriteLocker VAR_27(&VAR_28);\n\t\t\t\tc->cParent->removeChannel(c);\n\t\t\t\tVAR_3->addChannel(c);\n\t\t\t}\n\t\t}\n\t\tif (! VAR_5.isNull()) {\n\t\t\tlog(uSource, QString(\"Renamed channel %1 to %2\").arg(QString(*c),\n\t\t\t        QString(VAR_5)));\n\t\t\tc->qsName = VAR_5;\n\t\t}\n\t\tif (! VAR_6.isNull())\n\t\t\thashAssign(c->qsDesc, c->qbaDescHash, VAR_6);\n\n\t\tif (VAR_1.has_position())\n\t\t\tc->iPosition = VAR_1.position();\n\n\t\tforeach(Channel *VAR_26, qlAdd) {\n\t\t\taddLink(c, VAR_26);\n\t\t}\n\t\tforeach(Channel *VAR_26, qlRemove) {\n\t\t\tremoveLink(c, VAR_26);\n\t\t}\n\n\t\tif (VAR_1.has_max_users())\n\t\t\tc->uiMaxUsers = VAR_1.max_users();\n\n\t\tupdateChannel(c);\n\t\temit channelStateChanged(c);\n\n\t\tsendAll(VAR_1, ~ 0x010202);\n\t\tif (VAR_1.has_description() && ! c->qbaDescHash.isEmpty()) {\n\t\t\tVAR_1.clear_description();\n\t\t\tVAR_1.set_description_hash(blob(c->qbaDescHash));\n\t\t}\n\t\tsendAll(VAR_1, 0x010202);\n\t}\n}",
  "func_graph_path": "mumble-voip/mumble/0daec57f5cfc4225aa4527b537b4ec4fbbc35635/Messages.cpp/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -9,6 +9,8 @@\n \t\tc = qhChannels.value(msg.channel_id());\n \t\tif (! c)\n \t\t\treturn;\n+\t} else {\n+\t\tRATELIMIT(uSource);\n \t}\n \n \t// Check if the parent exists",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "\t} else {",
      "\t\tRATELIMIT(uSource);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/mumble-voip/mumble/pull/3510",
  "description": {
    "pr_info": {
      "title": "Prevent instability and crash due to message flood",
      "number": 3510
    },
    "comment": [
      "This patch adds a rate limiting to selected patches. The underlying rate limiter\r\nused is the Leaky-Bucket algorithm. It allows for a burst of messages, but\r\nlimits them after a specified amount of messages within a time frame.\r\nIf the ratelimit hits the messages are simply ignored.\r\n\r\nFor now its set to a burst of 30 allowed messages and a subsequent limit of 4 messages per second, which seems to do the trick without inconveniencing normal users.\r\n\r\nIt should to some extend prevent the recent issues with bots decribed in #3505.\r\n\r\nWhat was tested with the patch:\r\n\r\n- Joining (works)\r\n- Talking with UDP and TCP mode (works)\r\n- Switching channels (works)\r\n- Bringing down the server with a bot, tested with two different bots (does not work)\r\n\r\nI'm thanking the Zom.bi community for testing and @Natenom for some insight into the problem.\r\n\r\nI'm open to any suggestions.",
      "@davidebeatrici May I ask what priority/P0 entails?",
      "From https://wiki.mumble.info/wiki/Issue_Priorities:\r\n> MUST be fixed ASAP. Issues that prevent further development; legal issues; serious data loss issues; build issues for platforms we provide binaries for.",
      "@davidebeatrici How may I understand this? Is it my patch that \"MUST be fixed ASAP\" or does the patch fix something that \"MUST be fixed ASAP\"?",
      "The patch fixes something that \"MUST be fixed ASAP\".",
      "Qt 4 builds failing because:\r\n```c++\r\nIn file included from /usr/include/c++/4.8/chrono:35:0,\r\n                 from ./ServerUser.h:17,\r\n                 from ../ACL.cpp:14:\r\n/usr/include/c++/4.8/bits/c++0x_warning.h:32:2: error: #error This file requires compiler and library support for the ISO C++ 2011 standard. This support is currently experimental, and must be enabled with the -std=c++11 or -std=gnu++11 compiler options.\r\n #error This file requires compiler and library support for the \\\r\n  ^\r\n```\r\n\r\nMinGW builds failing because:\r\n```c++\r\nServerUser.h:106:36: error: comparison between signed and unsigned integer expressions [-Werror=sign-compare]\r\n   bool limit = this->currentTokens > (MAX_TOKENS - tokens);\r\n                                    ^\r\n```",
      "Alright, I can work with that. The first problem should be fixable by relying on pre-C++11 means to measure time if the software is not build using at least a C++11 compiler, unless we can have this as a requirement for building.\r\n\r\nThe second problem I didn't have, but it is easily fixable.",
      "After landing we should also put this into 1.2.",
      "I think that we shouldn't create another 1.2.x release.",
      "This edit to the patch should allow for pre-C++11 builds and fixes the warning with the unsigned signed comparison.\r\n\r\nEdit: Is it normal that the CI job is pending for such a long time? It seems to be finished according to the \"Details\" link.",
      "I hope you don't mind that I squashed them, so the history looks nicer. :+1: ",
      "No problem, we usually prefer commits to be squashed if they're all related.",
      "Perfect. Now do the last changes solve the problems you mentioned early? I'm sadly not able to easily try compiling it with Qt4 or MinGW.",
      "Builds succeeded.\r\n\r\nFeel free to review my changes and squash the commits.",
      "I separated the now and millisecondsBetween methods from the LeakyBucket class, as they were neither operating directly on the object nor public. And I added static inline to each to encourage the compile to inline them.\r\n\r\nAlso I moved a comment.\r\n\r\nPlease look at it again to see if you're okay with that.",
      "Thank you very much for your contribution!"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis:\n- The patch addresses a message flood issue causing instability and crashes by implementing rate limiting using the Leaky-Bucket algorithm.\n- The code modification introduces a rate limiter to prevent excessive messages, tested and effective against bot-induced crashes.\n- This resolves a security concern by mitigating potential DoS attacks, enhancing system availability.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 0.95"
}