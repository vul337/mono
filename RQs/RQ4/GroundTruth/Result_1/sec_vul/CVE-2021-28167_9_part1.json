{
  "cve_id": "CVE-2021-28167",
  "cwe_ids": [
    "CWE-909"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "eclipse-openj9/openj9",
  "commit_msg": "Correctly load/initialize classes when using ConstantPool\n\n- do not load classes in the \"ifLoaded\" calls\n- never intitialize classes in the natives\n- do not update the constant pool when querying from the natives\n\nFixes: #12016\n\n[ci skip]\n\nSigned-off-by: Graham Chapman <graham_chapman@ca.ibm.com>",
  "commit_hash": "840f3af31a5b8d2d395d9367c826ed756e380fb9",
  "git_url": "https://github.com/eclipse-openj9/openj9/commit/840f3af31a5b8d2d395d9367c826ed756e380fb9",
  "file_path": "runtime/vm/resolvesupport.cpp",
  "func_name": "resolveMethodTypeRefInto",
  "func_before": "j9object_t   \nresolveMethodTypeRefInto(J9VMThread *vmThread, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags, J9RAMMethodTypeRef *ramCPEntry) {\n\tj9object_t methodType;\n\tJ9ROMMethodTypeRef *romMethodTypeRef = NULL;\n\tJ9UTF8 *lookupSig = NULL;\n\tbool jitCompileTimeResolve = J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_JIT_COMPILE_TIME);\n\tbool canRunJavaCode = !jitCompileTimeResolve && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_REDEFINE_CLASS);\n\tbool throwException = canRunJavaCode && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);\n\tUDATA lookupOptions = 0;\n\tif (canRunJavaCode) {\n\t\tif (!throwException) {\n\t\t\tlookupOptions = J9_LOOK_NO_THROW;\t\t\t\n\t\t}\n\t} else {\n\t\tlookupOptions = J9_LOOK_NO_JAVA;\n\t}\n\n\tTrc_VM_sendResolveMethodTypeRefInto_Entry(vmThread, ramCP, cpIndex, resolveFlags);\n\n\t/* Check if already resolved */\n\tif (ramCPEntry->type != NULL) {\n\t\treturn ramCPEntry->type;\n\t}\n\n\t/* Return NULL if not able to run java code. The only way to resolve\n\t * a MethodType object is to call-in using MethodType.fromMethodDescriptorString()\n\t * which runs Java code.\n\t */\n\tif (!canRunJavaCode) {\n\t\treturn NULL;\n\t}\n\n\t/* Call VM Entry point to create the MethodType - Result is put into the\n\t * vmThread->returnValue as entry points don't \"return\" in the expected way\n\t */\n\tromMethodTypeRef = ((J9ROMMethodTypeRef *) &(J9_ROM_CP_FROM_CP(ramCP)[cpIndex]));\n\tlookupSig = J9ROMMETHODTYPEREF_SIGNATURE(romMethodTypeRef);\n\tsendFromMethodDescriptorString(vmThread, lookupSig, J9_CLASS_FROM_CP(ramCP)->classLoader, NULL);\n\tmethodType = (j9object_t) vmThread->returnValue;\n\n\t/* check if an exception is already pending */\n\tif (threadEventsPending(vmThread)) {\n\t\t/* Already a pending exception */\n\t\tmethodType = NULL;\n\t} else if (methodType == NULL) {\n\t\t/* Resolved MethodType was null - throw NPE that includes the lookupSignature from the NaS */\n\t\tj9object_t lookupSigString = vmThread->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(vmThread, J9UTF8_DATA(lookupSig), J9UTF8_LENGTH(lookupSig), 0);\n\t\tif (throwException) {\n\t\t\tif (NULL == vmThread->currentException) {\n\t\t\t\tsetCurrentException(vmThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, (UDATA*)lookupSigString);\n\t\t\t}\n\t\t} else {\n\t\t\tVM_VMHelpers::clearException(vmThread);\n\t\t}\n\t}\n\n\t/* perform visibility checks for the returnType and all parameters */\n\tif (NULL != methodType) {\n\t\t/* check returnType */\n\t\tJ9Class *senderClass = ramCP->ramClass;\n\t\tJ9Class *returnTypeClass = J9VM_J9CLASS_FROM_HEAPCLASS(vmThread, J9VMJAVALANGINVOKEMETHODTYPE_RTYPE(vmThread, methodType));\n\t\tJ9Class *illegalClass = NULL;\n\t\tIDATA visibilityReturnCode = 0;\n\n\t\tif (J9ROMCLASS_IS_ARRAY(senderClass->romClass)) {\n\t\t\tsenderClass = ((J9ArrayClass *)senderClass)->leafComponentType;\n\t\t}\n\t\tif (J9ROMCLASS_IS_ARRAY(returnTypeClass->romClass)) {\n\t\t\treturnTypeClass = ((J9ArrayClass *)returnTypeClass)->leafComponentType;\n\t\t}\n\n\t\tvisibilityReturnCode = checkVisibility(vmThread, senderClass, returnTypeClass, returnTypeClass->romClass->modifiers, lookupOptions);\n\n\t\tif (J9_VISIBILITY_ALLOWED != visibilityReturnCode) {\n\t\t\tillegalClass = returnTypeClass;\n\t\t} else {\n\t\t\t/* check paramTypes */\n\t\t\tj9object_t argTypesObject = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(vmThread, methodType);\n\t\t\tU_32 typeCount = J9INDEXABLEOBJECT_SIZE(vmThread, argTypesObject);\n\n\t\t\tfor (UDATA i = 0; i < typeCount; i++) {\n\t\t\t\tJ9Class *paramClass = J9VM_J9CLASS_FROM_HEAPCLASS(vmThread, J9JAVAARRAYOFOBJECT_LOAD(vmThread, argTypesObject, i));\n\n\t\t\t\tif (J9ROMCLASS_IS_ARRAY(paramClass->romClass)) {\n\t\t\t\t\tparamClass = ((J9ArrayClass *)paramClass)->leafComponentType;\n\t\t\t\t}\n\n\t\t\t\tvisibilityReturnCode = checkVisibility(vmThread, senderClass, paramClass, paramClass->romClass->modifiers, lookupOptions);\n\n\t\t\t\tif (J9_VISIBILITY_ALLOWED != visibilityReturnCode) {\n\t\t\t\t\tillegalClass = paramClass;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (NULL != illegalClass) {\n\t\t\tif (throwException) {\n\t\t\t\tchar *errorMsg = illegalAccessMessage(vmThread, illegalClass->romClass->modifiers, senderClass, illegalClass, visibilityReturnCode);\n\t\t\t\tif (NULL == errorMsg) {\n\t\t\t\t\tsetNativeOutOfMemoryError(vmThread, 0, 0);\n\t\t\t\t} else {\n\t\t\t\t\tsetCurrentExceptionUTF(vmThread, J9VMCONSTANTPOOL_JAVALANGILLEGALACCESSERROR, errorMsg);\n\t\t\t\t}\n\t\t\t}\n\t\t\tTrc_VM_sendResolveMethodTypeRefInto_Exception(vmThread, senderClass, illegalClass, visibilityReturnCode);\n\t\t\tmethodType = NULL;\n\t\t}\n\t}\n\n\t/* Only write the value in if its not null */\n\tif (NULL != methodType ) {\n\t\tJ9Class *clazz = J9_CLASS_FROM_CP(ramCP);\n\t\tj9object_t *methodTypeObjectP = &ramCPEntry->type;\n\t\t/* Overwriting NULL with an immortal pointer, so no exception can occur */\n\t\tJ9STATIC_OBJECT_STORE(vmThread, clazz, methodTypeObjectP, methodType);\n\t}\n\n\tTrc_VM_sendResolveMethodTypeRefInto_Exit(vmThread, methodType);\n\n\treturn methodType;\n}",
  "abstract_func_before": "j9object_t   \nresolveMethodTypeRefInto(J9VMThread *VAR_0, J9ConstantPool *VAR_1, UDATA VAR_2, UDATA VAR_3, J9RAMMethodTypeRef *VAR_4) {\n\tj9object_t VAR_5;\n\tJ9ROMMethodTypeRef *VAR_6 = NULL;\n\tJ9UTF8 *VAR_7 = NULL;\n\tbool VAR_8 = J9_ARE_ANY_BITS_SET(VAR_3, VAR_9);\n\tbool VAR_10 = !VAR_8 && J9_ARE_NO_BITS_SET(VAR_3, VAR_11);\n\tbool VAR_12 = VAR_10 && J9_ARE_NO_BITS_SET(VAR_3, VAR_13);\n\tUDATA VAR_14 = 0;\n\tif (VAR_10) {\n\t\tif (!VAR_12) {\n\t\t\tVAR_14 = VAR_15;\t\t\t\n\t\t}\n\t} else {\n\t\tVAR_14 = VAR_16;\n\t}\n\n\tTrc_VM_sendResolveMethodTypeRefInto_Entry(VAR_0, VAR_1, VAR_2, VAR_3);\n\n\t/* COMMENT_0 */\n\tif (VAR_4->type != NULL) {\n\t\treturn VAR_4->type;\n\t}\n\n\t/* COMMENT_1 */\n                                                                                   \n                         \n    \n\tif (!VAR_10) {\n\t\treturn NULL;\n\t}\n\n\t/* COMMENT_5 */\n                                                                            \n    \n\tVAR_6 = ((J9ROMMethodTypeRef *) &(J9_ROM_CP_FROM_CP(VAR_1)[VAR_2]));\n\tVAR_7 = J9ROMMETHODTYPEREF_SIGNATURE(VAR_6);\n\tsendFromMethodDescriptorString(VAR_0, VAR_7, J9_CLASS_FROM_CP(VAR_1)->classLoader, NULL);\n\tVAR_5 = (j9object_t) VAR_0->returnValue;\n\n\t/* COMMENT_8 */\n\tif (threadEventsPending(VAR_0)) {\n\t\t/* COMMENT_9 */\n\t\tVAR_5 = NULL;\n\t} else if (VAR_5 == NULL) {\n\t\t/* COMMENT_10 */\n\t\tj9object_t VAR_17 = VAR_0->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(VAR_0, J9UTF8_DATA(VAR_7), J9UTF8_LENGTH(VAR_7), 0);\n\t\tif (VAR_12) {\n\t\t\tif (NULL == VAR_0->currentException) {\n\t\t\t\tsetCurrentException(VAR_0, VAR_18, (UDATA*)VAR_17);\n\t\t\t}\n\t\t} else {\n\t\t\tVM_VMHelpers::clearException(VAR_0);\n\t\t}\n\t}\n\n\t/* COMMENT_11 */\n\tif (NULL != VAR_5) {\n\t\t/* COMMENT_12 */\n\t\tJ9Class *VAR_19 = VAR_1->ramClass;\n\t\tJ9Class *VAR_20 = J9VM_J9CLASS_FROM_HEAPCLASS(VAR_0, J9VMJAVALANGINVOKEMETHODTYPE_RTYPE(VAR_0, VAR_5));\n\t\tJ9Class *VAR_21 = NULL;\n\t\tIDATA VAR_22 = 0;\n\n\t\tif (J9ROMCLASS_IS_ARRAY(VAR_19->romClass)) {\n\t\t\tVAR_19 = ((J9ArrayClass *)VAR_19)->leafComponentType;\n\t\t}\n\t\tif (J9ROMCLASS_IS_ARRAY(VAR_20->romClass)) {\n\t\t\tVAR_20 = ((J9ArrayClass *)VAR_20)->leafComponentType;\n\t\t}\n\n\t\tVAR_22 = checkVisibility(VAR_0, VAR_19, VAR_20, VAR_20->romClass->modifiers, VAR_14);\n\n\t\tif (VAR_23 != VAR_22) {\n\t\t\tVAR_21 = VAR_20;\n\t\t} else {\n\t\t\t/* COMMENT_13 */\n\t\t\tj9object_t VAR_24 = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(VAR_0, VAR_5);\n\t\t\tU_32 VAR_25 = J9INDEXABLEOBJECT_SIZE(VAR_0, VAR_24);\n\n\t\t\tfor (UDATA VAR_26 = 0; VAR_26 < VAR_25; VAR_26++) {\n\t\t\t\tJ9Class *VAR_27 = J9VM_J9CLASS_FROM_HEAPCLASS(VAR_0, J9JAVAARRAYOFOBJECT_LOAD(VAR_0, VAR_24, VAR_26));\n\n\t\t\t\tif (J9ROMCLASS_IS_ARRAY(VAR_27->romClass)) {\n\t\t\t\t\tVAR_27 = ((J9ArrayClass *)VAR_27)->leafComponentType;\n\t\t\t\t}\n\n\t\t\t\tVAR_22 = checkVisibility(VAR_0, VAR_19, VAR_27, VAR_27->romClass->modifiers, VAR_14);\n\n\t\t\t\tif (VAR_23 != VAR_22) {\n\t\t\t\t\tVAR_21 = VAR_27;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (NULL != VAR_21) {\n\t\t\tif (VAR_12) {\n\t\t\t\tchar *VAR_28 = illegalAccessMessage(VAR_0, VAR_21->romClass->modifiers, VAR_19, VAR_21, VAR_22);\n\t\t\t\tif (NULL == VAR_28) {\n\t\t\t\t\tsetNativeOutOfMemoryError(VAR_0, 0, 0);\n\t\t\t\t} else {\n\t\t\t\t\tsetCurrentExceptionUTF(VAR_0, VAR_29, VAR_28);\n\t\t\t\t}\n\t\t\t}\n\t\t\tTrc_VM_sendResolveMethodTypeRefInto_Exception(VAR_0, VAR_19, VAR_21, VAR_22);\n\t\t\tVAR_5 = NULL;\n\t\t}\n\t}\n\n\t/* COMMENT_14 */\n\tif (NULL != VAR_5 ) {\n\t\tJ9Class *VAR_30 = J9_CLASS_FROM_CP(VAR_1);\n\t\tj9object_t *VAR_31 = &VAR_4->type;\n\t\t/* COMMENT_15 */\n\t\tJ9STATIC_OBJECT_STORE(VAR_0, VAR_30, VAR_31, VAR_5);\n\t}\n\n\tTrc_VM_sendResolveMethodTypeRefInto_Exit(VAR_0, VAR_5);\n\n\treturn VAR_5;\n}",
  "func_graph_path_before": "eclipse-openj9/openj9/840f3af31a5b8d2d395d9367c826ed756e380fb9/resolvesupport.cpp/vul/before/1.json",
  "func": "j9object_t   \nresolveMethodTypeRefInto(J9VMThread *vmThread, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags, J9RAMMethodTypeRef *ramCPEntry) {\n\tj9object_t methodType;\n\tJ9ROMMethodTypeRef *romMethodTypeRef = NULL;\n\tJ9UTF8 *lookupSig = NULL;\n\tbool jitCompileTimeResolve = J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_JIT_COMPILE_TIME);\n\tbool canRunJavaCode = !jitCompileTimeResolve && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_REDEFINE_CLASS);\n\tbool throwException = canRunJavaCode && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);\n\tUDATA lookupOptions = 0;\n\tif (canRunJavaCode) {\n\t\tif (!throwException) {\n\t\t\tlookupOptions = J9_LOOK_NO_THROW;\t\t\t\n\t\t}\n\t} else {\n\t\tlookupOptions = J9_LOOK_NO_JAVA;\n\t}\n\n\tTrc_VM_sendResolveMethodTypeRefInto_Entry(vmThread, ramCP, cpIndex, resolveFlags);\n\n\t/* Check if already resolved */\n\tif (ramCPEntry->type != NULL) {\n\t\treturn ramCPEntry->type;\n\t}\n\n\t/* Return NULL if not able to run java code. The only way to resolve\n\t * a MethodType object is to call-in using MethodType.fromMethodDescriptorString()\n\t * which runs Java code.\n\t */\n\tif (!canRunJavaCode) {\n\t\treturn NULL;\n\t}\n\n\t/* Call VM Entry point to create the MethodType - Result is put into the\n\t * vmThread->returnValue as entry points don't \"return\" in the expected way\n\t */\n\tromMethodTypeRef = ((J9ROMMethodTypeRef *) &(J9_ROM_CP_FROM_CP(ramCP)[cpIndex]));\n\tlookupSig = J9ROMMETHODTYPEREF_SIGNATURE(romMethodTypeRef);\n\tsendFromMethodDescriptorString(vmThread, lookupSig, J9_CLASS_FROM_CP(ramCP)->classLoader, NULL);\n\tmethodType = (j9object_t) vmThread->returnValue;\n\n\t/* check if an exception is already pending */\n\tif (threadEventsPending(vmThread)) {\n\t\t/* Already a pending exception */\n\t\tmethodType = NULL;\n\t} else if (methodType == NULL) {\n\t\t/* Resolved MethodType was null - throw NPE that includes the lookupSignature from the NaS */\n\t\tj9object_t lookupSigString = vmThread->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(vmThread, J9UTF8_DATA(lookupSig), J9UTF8_LENGTH(lookupSig), 0);\n\t\tif (throwException) {\n\t\t\tif (NULL == vmThread->currentException) {\n\t\t\t\tsetCurrentException(vmThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, (UDATA*)lookupSigString);\n\t\t\t}\n\t\t} else {\n\t\t\tVM_VMHelpers::clearException(vmThread);\n\t\t}\n\t}\n\n\t/* perform visibility checks for the returnType and all parameters */\n\tif (NULL != methodType) {\n\t\t/* check returnType */\n\t\tJ9Class *senderClass = ramCP->ramClass;\n\t\tJ9Class *returnTypeClass = J9VM_J9CLASS_FROM_HEAPCLASS(vmThread, J9VMJAVALANGINVOKEMETHODTYPE_RTYPE(vmThread, methodType));\n\t\tJ9Class *illegalClass = NULL;\n\t\tIDATA visibilityReturnCode = 0;\n\n\t\tif (J9ROMCLASS_IS_ARRAY(senderClass->romClass)) {\n\t\t\tsenderClass = ((J9ArrayClass *)senderClass)->leafComponentType;\n\t\t}\n\t\tif (J9ROMCLASS_IS_ARRAY(returnTypeClass->romClass)) {\n\t\t\treturnTypeClass = ((J9ArrayClass *)returnTypeClass)->leafComponentType;\n\t\t}\n\n\t\tvisibilityReturnCode = checkVisibility(vmThread, senderClass, returnTypeClass, returnTypeClass->romClass->modifiers, lookupOptions);\n\n\t\tif (J9_VISIBILITY_ALLOWED != visibilityReturnCode) {\n\t\t\tillegalClass = returnTypeClass;\n\t\t} else {\n\t\t\t/* check paramTypes */\n\t\t\tj9object_t argTypesObject = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(vmThread, methodType);\n\t\t\tU_32 typeCount = J9INDEXABLEOBJECT_SIZE(vmThread, argTypesObject);\n\n\t\t\tfor (UDATA i = 0; i < typeCount; i++) {\n\t\t\t\tJ9Class *paramClass = J9VM_J9CLASS_FROM_HEAPCLASS(vmThread, J9JAVAARRAYOFOBJECT_LOAD(vmThread, argTypesObject, i));\n\n\t\t\t\tif (J9ROMCLASS_IS_ARRAY(paramClass->romClass)) {\n\t\t\t\t\tparamClass = ((J9ArrayClass *)paramClass)->leafComponentType;\n\t\t\t\t}\n\n\t\t\t\tvisibilityReturnCode = checkVisibility(vmThread, senderClass, paramClass, paramClass->romClass->modifiers, lookupOptions);\n\n\t\t\t\tif (J9_VISIBILITY_ALLOWED != visibilityReturnCode) {\n\t\t\t\t\tillegalClass = paramClass;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (NULL != illegalClass) {\n\t\t\tif (throwException) {\n\t\t\t\tchar *errorMsg = illegalAccessMessage(vmThread, illegalClass->romClass->modifiers, senderClass, illegalClass, visibilityReturnCode);\n\t\t\t\tif (NULL == errorMsg) {\n\t\t\t\t\tsetNativeOutOfMemoryError(vmThread, 0, 0);\n\t\t\t\t} else {\n\t\t\t\t\tsetCurrentExceptionUTF(vmThread, J9VMCONSTANTPOOL_JAVALANGILLEGALACCESSERROR, errorMsg);\n\t\t\t\t}\n\t\t\t}\n\t\t\tTrc_VM_sendResolveMethodTypeRefInto_Exception(vmThread, senderClass, illegalClass, visibilityReturnCode);\n\t\t\tmethodType = NULL;\n\t\t}\n\t}\n\n\t/* Only write the value in if its not null */\n\tif ((NULL != methodType) && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\n\t\tJ9Class *clazz = J9_CLASS_FROM_CP(ramCP);\n\t\tj9object_t *methodTypeObjectP = &ramCPEntry->type;\n\t\t/* Overwriting NULL with an immortal pointer, so no exception can occur */\n\t\tJ9STATIC_OBJECT_STORE(vmThread, clazz, methodTypeObjectP, methodType);\n\t}\n\n\tTrc_VM_sendResolveMethodTypeRefInto_Exit(vmThread, methodType);\n\n\treturn methodType;\n}",
  "abstract_func": "j9object_t   \nresolveMethodTypeRefInto(J9VMThread *VAR_0, J9ConstantPool *VAR_1, UDATA VAR_2, UDATA VAR_3, J9RAMMethodTypeRef *VAR_4) {\n\tj9object_t VAR_5;\n\tJ9ROMMethodTypeRef *VAR_6 = NULL;\n\tJ9UTF8 *VAR_7 = NULL;\n\tbool VAR_8 = J9_ARE_ANY_BITS_SET(VAR_3, VAR_9);\n\tbool VAR_10 = !VAR_8 && J9_ARE_NO_BITS_SET(VAR_3, VAR_11);\n\tbool VAR_12 = VAR_10 && J9_ARE_NO_BITS_SET(VAR_3, VAR_13);\n\tUDATA VAR_14 = 0;\n\tif (VAR_10) {\n\t\tif (!VAR_12) {\n\t\t\tVAR_14 = VAR_15;\t\t\t\n\t\t}\n\t} else {\n\t\tVAR_14 = VAR_16;\n\t}\n\n\tTrc_VM_sendResolveMethodTypeRefInto_Entry(VAR_0, VAR_1, VAR_2, VAR_3);\n\n\t/* COMMENT_0 */\n\tif (VAR_4->type != NULL) {\n\t\treturn VAR_4->type;\n\t}\n\n\t/* COMMENT_1 */\n                                                                                   \n                         \n    \n\tif (!VAR_10) {\n\t\treturn NULL;\n\t}\n\n\t/* COMMENT_5 */\n                                                                            \n    \n\tVAR_6 = ((J9ROMMethodTypeRef *) &(J9_ROM_CP_FROM_CP(VAR_1)[VAR_2]));\n\tVAR_7 = J9ROMMETHODTYPEREF_SIGNATURE(VAR_6);\n\tsendFromMethodDescriptorString(VAR_0, VAR_7, J9_CLASS_FROM_CP(VAR_1)->classLoader, NULL);\n\tVAR_5 = (j9object_t) VAR_0->returnValue;\n\n\t/* COMMENT_8 */\n\tif (threadEventsPending(VAR_0)) {\n\t\t/* COMMENT_9 */\n\t\tVAR_5 = NULL;\n\t} else if (VAR_5 == NULL) {\n\t\t/* COMMENT_10 */\n\t\tj9object_t VAR_17 = VAR_0->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(VAR_0, J9UTF8_DATA(VAR_7), J9UTF8_LENGTH(VAR_7), 0);\n\t\tif (VAR_12) {\n\t\t\tif (NULL == VAR_0->currentException) {\n\t\t\t\tsetCurrentException(VAR_0, VAR_18, (UDATA*)VAR_17);\n\t\t\t}\n\t\t} else {\n\t\t\tVM_VMHelpers::clearException(VAR_0);\n\t\t}\n\t}\n\n\t/* COMMENT_11 */\n\tif (NULL != VAR_5) {\n\t\t/* COMMENT_12 */\n\t\tJ9Class *VAR_19 = VAR_1->ramClass;\n\t\tJ9Class *VAR_20 = J9VM_J9CLASS_FROM_HEAPCLASS(VAR_0, J9VMJAVALANGINVOKEMETHODTYPE_RTYPE(VAR_0, VAR_5));\n\t\tJ9Class *VAR_21 = NULL;\n\t\tIDATA VAR_22 = 0;\n\n\t\tif (J9ROMCLASS_IS_ARRAY(VAR_19->romClass)) {\n\t\t\tVAR_19 = ((J9ArrayClass *)VAR_19)->leafComponentType;\n\t\t}\n\t\tif (J9ROMCLASS_IS_ARRAY(VAR_20->romClass)) {\n\t\t\tVAR_20 = ((J9ArrayClass *)VAR_20)->leafComponentType;\n\t\t}\n\n\t\tVAR_22 = checkVisibility(VAR_0, VAR_19, VAR_20, VAR_20->romClass->modifiers, VAR_14);\n\n\t\tif (VAR_23 != VAR_22) {\n\t\t\tVAR_21 = VAR_20;\n\t\t} else {\n\t\t\t/* COMMENT_13 */\n\t\t\tj9object_t VAR_24 = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(VAR_0, VAR_5);\n\t\t\tU_32 VAR_25 = J9INDEXABLEOBJECT_SIZE(VAR_0, VAR_24);\n\n\t\t\tfor (UDATA VAR_26 = 0; VAR_26 < VAR_25; VAR_26++) {\n\t\t\t\tJ9Class *VAR_27 = J9VM_J9CLASS_FROM_HEAPCLASS(VAR_0, J9JAVAARRAYOFOBJECT_LOAD(VAR_0, VAR_24, VAR_26));\n\n\t\t\t\tif (J9ROMCLASS_IS_ARRAY(VAR_27->romClass)) {\n\t\t\t\t\tVAR_27 = ((J9ArrayClass *)VAR_27)->leafComponentType;\n\t\t\t\t}\n\n\t\t\t\tVAR_22 = checkVisibility(VAR_0, VAR_19, VAR_27, VAR_27->romClass->modifiers, VAR_14);\n\n\t\t\t\tif (VAR_23 != VAR_22) {\n\t\t\t\t\tVAR_21 = VAR_27;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (NULL != VAR_21) {\n\t\t\tif (VAR_12) {\n\t\t\t\tchar *VAR_28 = illegalAccessMessage(VAR_0, VAR_21->romClass->modifiers, VAR_19, VAR_21, VAR_22);\n\t\t\t\tif (NULL == VAR_28) {\n\t\t\t\t\tsetNativeOutOfMemoryError(VAR_0, 0, 0);\n\t\t\t\t} else {\n\t\t\t\t\tsetCurrentExceptionUTF(VAR_0, VAR_29, VAR_28);\n\t\t\t\t}\n\t\t\t}\n\t\t\tTrc_VM_sendResolveMethodTypeRefInto_Exception(VAR_0, VAR_19, VAR_21, VAR_22);\n\t\t\tVAR_5 = NULL;\n\t\t}\n\t}\n\n\t/* COMMENT_14 */\n\tif ((NULL != VAR_5) && J9_ARE_NO_BITS_SET(VAR_3, VAR_30)) {\n\t\tJ9Class *VAR_31 = J9_CLASS_FROM_CP(VAR_1);\n\t\tj9object_t *VAR_32 = &VAR_4->type;\n\t\t/* COMMENT_15 */\n\t\tJ9STATIC_OBJECT_STORE(VAR_0, VAR_31, VAR_32, VAR_5);\n\t}\n\n\tTrc_VM_sendResolveMethodTypeRefInto_Exit(VAR_0, VAR_5);\n\n\treturn VAR_5;\n}",
  "func_graph_path": "eclipse-openj9/openj9/840f3af31a5b8d2d395d9367c826ed756e380fb9/resolvesupport.cpp/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -108,7 +108,7 @@\n \t}\n \n \t/* Only write the value in if its not null */\n-\tif (NULL != methodType ) {\n+\tif ((NULL != methodType) && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\n \t\tJ9Class *clazz = J9_CLASS_FROM_CP(ramCP);\n \t\tj9object_t *methodTypeObjectP = &ramCPEntry->type;\n \t\t/* Overwriting NULL with an immortal pointer, so no exception can occur */",
  "diff_line_info": {
    "deleted_lines": [
      "\tif (NULL != methodType ) {"
    ],
    "added_lines": [
      "\tif ((NULL != methodType) && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/eclipse-openj9/openj9/pull/12148",
  "description": {
    "pr_info": {
      "title": "Correctly load/initialize classes when using ConstantPool",
      "number": 12148
    },
    "comment": [
      "- do not load classes in the \"ifLoaded\" calls\r\n- never intitialize classes in the natives\r\n- do not update the constant pool when querying from the natives\r\n\r\nFixes: #12016\r\n\r\n[ci skip]\r\n\r\nSigned-off-by: Graham Chapman <graham_chapman@ca.ibm.com>",
      "jenkins test sanity,extended zlinux jdk11",
      "jenkins compile win jdk8",
      "@gacholio can you please open another PR for the 0.26 stream",
      "https://github.com/eclipse/openj9/pull/12164"
    ]
  },
  "Bug Filter": "** Security Vulnerability Fix  \n**Confidence Score:** 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\nThe patch modifies how classes are loaded and initializes the constant pool, preventing unauthorized operations that could be exploited. \n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 0.95"
}