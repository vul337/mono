{
  "cve_id": "CVE-2017-14199",
  "cwe_ids": [
    "CWE-119"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "zephyrproject-rtos/zephyr",
  "commit_msg": "net: sockets: getaddrinfo() buffer overflow, etc. fixes\n\nThe existing implementation assumed DNS resolv callback will be\ncalled just once, but that's not always the case (apparently,\nfor multi-homes hosts or something). So, apply array bounds\nchecking (and do pointer arithmetic only after it, as the C\nstandard otherwise warns of \"undefined behavior\"). In such a case,\nthe port number wasn't set in each entry too, so rework how it's\ndone.\n\nThe issues discovered while resolving archive.ubuntu.com.\n\nSigned-off-by: Paul Sokolovsky <paul.sokolovsky@linaro.org>",
  "commit_hash": "3953714a9b8508aca72ab93991e8468ba508aa4b",
  "git_url": "https://github.com/zephyrproject-rtos/zephyr/commit/3953714a9b8508aca72ab93991e8468ba508aa4b",
  "file_path": "subsys/net/lib/sockets/getaddrinfo.c",
  "func_name": "zsock_getaddrinfo",
  "func_before": "int zsock_getaddrinfo(const char *host, const char *service,\n\t\t      const struct zsock_addrinfo *hints,\n\t\t      struct zsock_addrinfo **res)\n{\n\tint family = AF_UNSPEC;\n\tlong int port;\n\tint st1 = DNS_EAI_ADDRFAMILY, st2 = DNS_EAI_ADDRFAMILY;\n\n\tif (hints) {\n\t\tfamily = hints->ai_family;\n\t}\n\n\tport = strtol(service, NULL, 10);\n\tif (port < 1 || port > 65535) {\n\t\treturn DNS_EAI_NONAME;\n\t}\n\n\tai_state.hints = hints;\n\tai_state.idx = 0;\n\tk_sem_init(&ai_state.sem, 0, UINT_MAX);\n\n\t/* Link entries in advance */\n\tai_arr[0].ai_next = &ai_arr[1];\n\n\t/* Execute if AF_UNSPEC or AF_INET4 */\n\tif (family != AF_INET6) {\n\t\tdns_get_addr_info(host, DNS_QUERY_TYPE_A, NULL,\n\t\t\t\t  dns_resolve_cb, &ai_state, 1000);\n\t\tk_sem_take(&ai_state.sem, K_FOREVER);\n\t\tnet_sin(&ai_arr[ai_state.idx - 1]._ai_addr)->sin_port =\n\t\t\t\t\t\t\t\thtons(port);\n\t\tst1 = ai_state.status;\n\t}\n\n\t/* Execute if AF_UNSPEC or AF_INET6 */\n\tif (family != AF_INET) {\n\t\tdns_get_addr_info(host, DNS_QUERY_TYPE_AAAA, NULL,\n\t\t\t\t  dns_resolve_cb, &ai_state, 1000);\n\t\tk_sem_take(&ai_state.sem, K_FOREVER);\n\t\tnet_sin6(&ai_arr[ai_state.idx - 1]._ai_addr)->sin6_port =\n\t\t\t\t\t\t\t\thtons(port);\n\t\tst2 = ai_state.status;\n\t}\n\n\t/* If both attempts failed, it's error */\n\tif (st1 && st2) {\n\t\tif (st1 != DNS_EAI_ADDRFAMILY) {\n\t\t\treturn st1;\n\t\t}\n\t\treturn st2;\n\t}\n\n\t/* Mark entry as last */\n\tai_arr[ai_state.idx - 1].ai_next = NULL;\n\n\t*res = ai_arr;\n\n\treturn 0;\n}",
  "abstract_func_before": "int zsock_getaddrinfo(const char *VAR_0, const char *VAR_1,\n\t\t      const struct zsock_addrinfo *VAR_2,\n\t\t      struct zsock_addrinfo **VAR_3)\n{\n\tint VAR_4 = VAR_5;\n\tlong int VAR_6;\n\tint VAR_7 = VAR_8, VAR_9 = VAR_8;\n\n\tif (VAR_2) {\n\t\tVAR_4 = VAR_2->ai_family;\n\t}\n\n\tVAR_6 = strtol(VAR_1, NULL, 10);\n\tif (VAR_6 < 1 || VAR_6 > 65535) {\n\t\treturn VAR_10;\n\t}\n\n\tVAR_11.hints = VAR_2;\n\tVAR_11.idx = 0;\n\tk_sem_init(&VAR_11.sem, 0, VAR_12);\n\n\t/* COMMENT_0 */\n\tVAR_13[0].ai_next = &VAR_13[1];\n\n\t/* COMMENT_1 */\n\tif (VAR_4 != VAR_14) {\n\t\tdns_get_addr_info(VAR_0, VAR_15, NULL,\n\t\t\t\t  VAR_16, &VAR_11, 1000);\n\t\tk_sem_take(&VAR_11.sem, VAR_17);\n\t\tnet_sin(&VAR_13[VAR_11.idx - 1]._ai_addr)->sin_port =\n\t\t\t\t\t\t\t\thtons(VAR_6);\n\t\tVAR_7 = VAR_11.status;\n\t}\n\n\t/* COMMENT_2 */\n\tif (VAR_4 != VAR_18) {\n\t\tdns_get_addr_info(VAR_0, VAR_19, NULL,\n\t\t\t\t  VAR_16, &VAR_11, 1000);\n\t\tk_sem_take(&VAR_11.sem, VAR_17);\n\t\tnet_sin6(&VAR_13[VAR_11.idx - 1]._ai_addr)->sin6_port =\n\t\t\t\t\t\t\t\thtons(VAR_6);\n\t\tVAR_9 = VAR_11.status;\n\t}\n\n\t/* COMMENT_3 */\n\tif (VAR_7 && VAR_9) {\n\t\tif (VAR_7 != VAR_8) {\n\t\t\treturn VAR_7;\n\t\t}\n\t\treturn VAR_9;\n\t}\n\n\t/* COMMENT_4 */\n\tVAR_13[VAR_11.idx - 1].ai_next = NULL;\n\n\t*VAR_3 = VAR_13;\n\n\treturn 0;\n}",
  "func_graph_path_before": "zephyrproject-rtos/zephyr/3953714a9b8508aca72ab93991e8468ba508aa4b/getaddrinfo.c/vul/before/1.json",
  "func": "int zsock_getaddrinfo(const char *host, const char *service,\n\t\t      const struct zsock_addrinfo *hints,\n\t\t      struct zsock_addrinfo **res)\n{\n\tint family = AF_UNSPEC;\n\tlong int port;\n\tint st1 = DNS_EAI_ADDRFAMILY, st2 = DNS_EAI_ADDRFAMILY;\n\n\tif (hints) {\n\t\tfamily = hints->ai_family;\n\t}\n\n\tport = strtol(service, NULL, 10);\n\tif (port < 1 || port > 65535) {\n\t\treturn DNS_EAI_NONAME;\n\t}\n\n\tai_state.hints = hints;\n\tai_state.idx = 0;\n\tai_state.port = htons(port);\n\tk_sem_init(&ai_state.sem, 0, UINT_MAX);\n\n\t/* Link entries in advance */\n\tai_arr[0].ai_next = &ai_arr[1];\n\n\t/* Execute if AF_UNSPEC or AF_INET4 */\n\tif (family != AF_INET6) {\n\t\tdns_get_addr_info(host, DNS_QUERY_TYPE_A, NULL,\n\t\t\t\t  dns_resolve_cb, &ai_state, 1000);\n\t\tk_sem_take(&ai_state.sem, K_FOREVER);\n\t\tnet_sin(&ai_arr[ai_state.idx - 1]._ai_addr)->sin_port =\n\t\t\t\t\t\t\t\thtons(port);\n\t\tst1 = ai_state.status;\n\t}\n\n\t/* Execute if AF_UNSPEC or AF_INET6 */\n\tif (family != AF_INET) {\n\t\tdns_get_addr_info(host, DNS_QUERY_TYPE_AAAA, NULL,\n\t\t\t\t  dns_resolve_cb, &ai_state, 1000);\n\t\tk_sem_take(&ai_state.sem, K_FOREVER);\n\t\tnet_sin6(&ai_arr[ai_state.idx - 1]._ai_addr)->sin6_port =\n\t\t\t\t\t\t\t\thtons(port);\n\t\tst2 = ai_state.status;\n\t}\n\n\t/* If both attempts failed, it's error */\n\tif (st1 && st2) {\n\t\tif (st1 != DNS_EAI_ADDRFAMILY) {\n\t\t\treturn st1;\n\t\t}\n\t\treturn st2;\n\t}\n\n\t/* Mark entry as last */\n\tai_arr[ai_state.idx - 1].ai_next = NULL;\n\n\t*res = ai_arr;\n\n\treturn 0;\n}",
  "abstract_func": "int zsock_getaddrinfo(const char *VAR_0, const char *VAR_1,\n\t\t      const struct zsock_addrinfo *VAR_2,\n\t\t      struct zsock_addrinfo **VAR_3)\n{\n\tint VAR_4 = VAR_5;\n\tlong int VAR_6;\n\tint VAR_7 = VAR_8, VAR_9 = VAR_8;\n\n\tif (VAR_2) {\n\t\tVAR_4 = VAR_2->ai_family;\n\t}\n\n\tVAR_6 = strtol(VAR_1, NULL, 10);\n\tif (VAR_6 < 1 || VAR_6 > 65535) {\n\t\treturn VAR_10;\n\t}\n\n\tVAR_11.hints = VAR_2;\n\tVAR_11.idx = 0;\n\tVAR_11.port = htons(VAR_6);\n\tk_sem_init(&VAR_11.sem, 0, VAR_12);\n\n\t/* COMMENT_0 */\n\tVAR_13[0].ai_next = &VAR_13[1];\n\n\t/* COMMENT_1 */\n\tif (VAR_4 != VAR_14) {\n\t\tdns_get_addr_info(VAR_0, VAR_15, NULL,\n\t\t\t\t  VAR_16, &VAR_11, 1000);\n\t\tk_sem_take(&VAR_11.sem, VAR_17);\n\t\tnet_sin(&VAR_13[VAR_11.idx - 1]._ai_addr)->sin_port =\n\t\t\t\t\t\t\t\thtons(VAR_6);\n\t\tVAR_7 = VAR_11.status;\n\t}\n\n\t/* COMMENT_2 */\n\tif (VAR_4 != VAR_18) {\n\t\tdns_get_addr_info(VAR_0, VAR_19, NULL,\n\t\t\t\t  VAR_16, &VAR_11, 1000);\n\t\tk_sem_take(&VAR_11.sem, VAR_17);\n\t\tnet_sin6(&VAR_13[VAR_11.idx - 1]._ai_addr)->sin6_port =\n\t\t\t\t\t\t\t\thtons(VAR_6);\n\t\tVAR_9 = VAR_11.status;\n\t}\n\n\t/* COMMENT_3 */\n\tif (VAR_7 && VAR_9) {\n\t\tif (VAR_7 != VAR_8) {\n\t\t\treturn VAR_7;\n\t\t}\n\t\treturn VAR_9;\n\t}\n\n\t/* COMMENT_4 */\n\tVAR_13[VAR_11.idx - 1].ai_next = NULL;\n\n\t*VAR_3 = VAR_13;\n\n\treturn 0;\n}",
  "func_graph_path": "zephyrproject-rtos/zephyr/3953714a9b8508aca72ab93991e8468ba508aa4b/getaddrinfo.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -17,6 +17,7 @@\n \n \tai_state.hints = hints;\n \tai_state.idx = 0;\n+\tai_state.port = htons(port);\n \tk_sem_init(&ai_state.sem, 0, UINT_MAX);\n \n \t/* Link entries in advance */",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "\tai_state.port = htons(port);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/zephyrproject-rtos/zephyr/pull/6158",
  "description": {
    "pr_info": {
      "title": "net: sockets: getaddrinfo() buffer overflow, etc. fixes",
      "number": 6158
    },
    "comment": [
      "The existing implementation assumed DNS resolv callback will be\r\ncalled just once, but that's not always the case (apparently,\r\nfor multi-homes hosts or something). So, apply array bounds\r\nchecking. In this case, port number wasn't set in each entry too,\r\nso rework how it's done.\r\n\r\nThe issues discovered while resolving archive.ubuntu.com.\r\n\r\nSigned-off-by: Paul Sokolovsky <paul.sokolovsky@linaro.org>",
      "# [Codecov](https://codecov.io/gh/zephyrproject-rtos/zephyr/pull/6158?src=pr&el=h1) Report\n> Merging [#6158](https://codecov.io/gh/zephyrproject-rtos/zephyr/pull/6158?src=pr&el=desc) into [master](https://codecov.io/gh/zephyrproject-rtos/zephyr/commit/d0c2be7c8a22409507817f8206b4d631b7520bad?src=pr&el=desc) will **decrease** coverage by `<.01%`.\n> The diff coverage is `0%`.\n\n[![Impacted file tree graph](https://codecov.io/gh/zephyrproject-rtos/zephyr/pull/6158/graphs/tree.svg?token=ftaqgO8OOj&width=650&height=150&src=pr)](https://codecov.io/gh/zephyrproject-rtos/zephyr/pull/6158?src=pr&el=tree)\n\n```diff\n@@            Coverage Diff             @@\n##           master    #6158      +/-   ##\n==========================================\n- Coverage   52.88%   52.87%   -0.01%     \n==========================================\n  Files         412      412              \n  Lines       40274    40278       +4     \n  Branches     7801     7802       +1     \n==========================================\n  Hits        21297    21297              \n- Misses      15761    15765       +4     \n  Partials     3216     3216\n```\n\n\n| [Impacted Files](https://codecov.io/gh/zephyrproject-rtos/zephyr/pull/6158?src=pr&el=tree) | Coverage Δ | |\n|---|---|---|\n| [subsys/net/lib/sockets/getaddrinfo.c](https://codecov.io/gh/zephyrproject-rtos/zephyr/pull/6158/diff?src=pr&el=tree#diff-c3Vic3lzL25ldC9saWIvc29ja2V0cy9nZXRhZGRyaW5mby5j) | `0% <0%> (ø)` | :arrow_up: |\n\n------\n\n[Continue to review full report at Codecov](https://codecov.io/gh/zephyrproject-rtos/zephyr/pull/6158?src=pr&el=continue).\n> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)\n> `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`\n> Powered by [Codecov](https://codecov.io/gh/zephyrproject-rtos/zephyr/pull/6158?src=pr&el=footer). Last update [d0c2be7...3953714](https://codecov.io/gh/zephyrproject-rtos/zephyr/pull/6158?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).\n",
      "> the pointer isn't even calculated if state->idx is out of bounds (it's undefined behavior);\r\n\r\nAre you sure that calculation is undefined behavior? Maybe accessing a pointer calculated in such a manner is undefined behavior?\r\n",
      "Yes, I'm sure. The only exception is calculating the pointer to one element past the end of an array (so it's possible to loop through an array using pointers rather than indices).\r\n\r\nSee the [C11 text](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1548.pdf), 6.5.6.8:\r\n\r\n> If  both  the  pointer operand  and  the  result  point  to  elements  of  the  same  array  object,  or  \r\n> one  past  the  last element of the array object, the evaluation shall not produce an overflow; \r\n> otherwise, the behavior is undefined. ",
      "Updated as suggested.\r\n",
      "Note for whoever is merging this: this should be backported to 1.10.",
      "@pfalcon can you backport and submit to 1.10 branch?",
      "> can you backport and submit to 1.10 branch?\r\n\r\nSubmitted as https://github.com/zephyrproject-rtos/zephyr/pull/6169, thanks."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix\n\nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses a buffer overflow issue in the getaddrinfo() function, which could lead to unauthorized access or data corruption. The code changes include bounds checking and proper pointer arithmetic to prevent undefined behavior. This indicates a security vulnerability fix.\n\nFinal Classification: Security Vulnerability Fix\n\nConfidence Score: 1.0"
}