{
  "cve_id": "CVE-2017-3733",
  "cwe_ids": [
    "CWE-20"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "openssl",
  "commit_msg": "Don't change the state of the ETM flags until CCS processing\n\nChanging the ciphersuite during a renegotiation can result in a crash\nleading to a DoS attack. ETM has not been implemented in 1.1.0 for DTLS\nso this is TLS only.\n\nThe problem is caused by changing the flag indicating whether to use ETM\nor not immediately on negotiation of ETM, rather than at CCS. Therefore,\nduring a renegotiation, if the ETM state is changing (usually due to a\nchange of ciphersuite), then an error/crash will occur.\n\nDue to the fact that there are separate CCS messages for read and write\nwe actually now need two flags to determine whether to use ETM or not.\n\nCVE-2017-3733\n\nReviewed-by: Richard Levitte <levitte@openssl.org>",
  "commit_hash": "4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2",
  "git_url": "https://github.com/openssl/openssl/commit/4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2",
  "file_path": "ssl/record/ssl3_record.c",
  "func_name": "ssl3_get_record",
  "func_before": "int ssl3_get_record(SSL *s)\n{\n    int ssl_major, ssl_minor, al;\n    int enc_err, n, i, ret = -1;\n    SSL3_RECORD *rr;\n    SSL3_BUFFER *rbuf;\n    SSL_SESSION *sess;\n    unsigned char *p;\n    unsigned char md[EVP_MAX_MD_SIZE];\n    short version;\n    unsigned mac_size;\n    unsigned int num_recs = 0;\n    unsigned int max_recs;\n    unsigned int j;\n\n    rr = RECORD_LAYER_get_rrec(&s->rlayer);\n    rbuf = RECORD_LAYER_get_rbuf(&s->rlayer);\n    max_recs = s->max_pipelines;\n    if (max_recs == 0)\n        max_recs = 1;\n    sess = s->session;\n\n    do {\n        /* check if we have the header */\n        if ((RECORD_LAYER_get_rstate(&s->rlayer) != SSL_ST_READ_BODY) ||\n            (RECORD_LAYER_get_packet_length(&s->rlayer)\n             < SSL3_RT_HEADER_LENGTH)) {\n            n = ssl3_read_n(s, SSL3_RT_HEADER_LENGTH,\n                            SSL3_BUFFER_get_len(rbuf), 0,\n                            num_recs == 0 ? 1 : 0);\n            if (n <= 0)\n                return (n);     /* error or non-blocking */\n            RECORD_LAYER_set_rstate(&s->rlayer, SSL_ST_READ_BODY);\n\n            p = RECORD_LAYER_get_packet(&s->rlayer);\n\n            /*\n             * The first record received by the server may be a V2ClientHello.\n             */\n            if (s->server && RECORD_LAYER_is_first_record(&s->rlayer)\n                && (p[0] & 0x80) && (p[2] == SSL2_MT_CLIENT_HELLO)) {\n                /*\n                 *  SSLv2 style record\n                 *\n                 * |num_recs| here will actually always be 0 because\n                 * |num_recs > 0| only ever occurs when we are processing\n                 * multiple app data records - which we know isn't the case here\n                 * because it is an SSLv2ClientHello. We keep it using\n                 * |num_recs| for the sake of consistency\n                 */\n                rr[num_recs].type = SSL3_RT_HANDSHAKE;\n                rr[num_recs].rec_version = SSL2_VERSION;\n\n                rr[num_recs].length = ((p[0] & 0x7f) << 8) | p[1];\n\n                if (rr[num_recs].length > SSL3_BUFFER_get_len(rbuf)\n                    - SSL2_RT_HEADER_LENGTH) {\n                    al = SSL_AD_RECORD_OVERFLOW;\n                    SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_PACKET_LENGTH_TOO_LONG);\n                    goto f_err;\n                }\n\n                if (rr[num_recs].length < MIN_SSL2_RECORD_LEN) {\n                    al = SSL_AD_HANDSHAKE_FAILURE;\n                    SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_LENGTH_TOO_SHORT);\n                    goto f_err;\n                }\n            } else {\n                /* SSLv3+ style record */\n                if (s->msg_callback)\n                    s->msg_callback(0, 0, SSL3_RT_HEADER, p, 5, s,\n                                    s->msg_callback_arg);\n\n                /* Pull apart the header into the SSL3_RECORD */\n                rr[num_recs].type = *(p++);\n                ssl_major = *(p++);\n                ssl_minor = *(p++);\n                version = (ssl_major << 8) | ssl_minor;\n                rr[num_recs].rec_version = version;\n                n2s(p, rr[num_recs].length);\n\n                /* Lets check version */\n                if (!s->first_packet && version != s->version) {\n                    SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_WRONG_VERSION_NUMBER);\n                    if ((s->version & 0xFF00) == (version & 0xFF00)\n                        && !s->enc_write_ctx && !s->write_hash) {\n                        if (rr->type == SSL3_RT_ALERT) {\n                            /*\n                             * The record is using an incorrect version number,\n                             * but what we've got appears to be an alert. We\n                             * haven't read the body yet to check whether its a\n                             * fatal or not - but chances are it is. We probably\n                             * shouldn't send a fatal alert back. We'll just\n                             * end.\n                             */\n                            goto err;\n                        }\n                        /*\n                         * Send back error using their minor version number :-)\n                         */\n                        s->version = (unsigned short)version;\n                    }\n                    al = SSL_AD_PROTOCOL_VERSION;\n                    goto f_err;\n                }\n\n                if ((version >> 8) != SSL3_VERSION_MAJOR) {\n                    if (RECORD_LAYER_is_first_record(&s->rlayer)) {\n                        /* Go back to start of packet, look at the five bytes\n                         * that we have. */\n                        p = RECORD_LAYER_get_packet(&s->rlayer);\n                        if (strncmp((char *)p, \"GET \", 4) == 0 ||\n                            strncmp((char *)p, \"POST \", 5) == 0 ||\n                            strncmp((char *)p, \"HEAD \", 5) == 0 ||\n                            strncmp((char *)p, \"PUT \", 4) == 0) {\n                            SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_HTTP_REQUEST);\n                            goto err;\n                        } else if (strncmp((char *)p, \"CONNE\", 5) == 0) {\n                            SSLerr(SSL_F_SSL3_GET_RECORD,\n                                   SSL_R_HTTPS_PROXY_REQUEST);\n                            goto err;\n                        }\n\n                        /* Doesn't look like TLS - don't send an alert */\n                        SSLerr(SSL_F_SSL3_GET_RECORD,\n                               SSL_R_WRONG_VERSION_NUMBER);\n                        goto err;\n                    } else {\n                        SSLerr(SSL_F_SSL3_GET_RECORD,\n                               SSL_R_WRONG_VERSION_NUMBER);\n                        al = SSL_AD_PROTOCOL_VERSION;\n                        goto f_err;\n                    }\n                }\n\n                if (rr[num_recs].length >\n                    SSL3_BUFFER_get_len(rbuf) - SSL3_RT_HEADER_LENGTH) {\n                    al = SSL_AD_RECORD_OVERFLOW;\n                    SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_PACKET_LENGTH_TOO_LONG);\n                    goto f_err;\n                }\n            }\n\n            /* now s->rlayer.rstate == SSL_ST_READ_BODY */\n        }\n\n        /*\n         * s->rlayer.rstate == SSL_ST_READ_BODY, get and decode the data.\n         * Calculate how much more data we need to read for the rest of the\n         * record\n         */\n        if (rr[num_recs].rec_version == SSL2_VERSION) {\n            i = rr[num_recs].length + SSL2_RT_HEADER_LENGTH\n                - SSL3_RT_HEADER_LENGTH;\n        } else {\n            i = rr[num_recs].length;\n        }\n        if (i > 0) {\n            /* now s->packet_length == SSL3_RT_HEADER_LENGTH */\n\n            n = ssl3_read_n(s, i, i, 1, 0);\n            if (n <= 0)\n                return (n);     /* error or non-blocking io */\n        }\n\n        /* set state for later operations */\n        RECORD_LAYER_set_rstate(&s->rlayer, SSL_ST_READ_HEADER);\n\n        /*\n         * At this point, s->packet_length == SSL3_RT_HEADER_LENGTH + rr->length,\n         * or s->packet_length == SSL2_RT_HEADER_LENGTH + rr->length\n         * and we have that many bytes in s->packet\n         */\n        if (rr[num_recs].rec_version == SSL2_VERSION) {\n            rr[num_recs].input =\n                &(RECORD_LAYER_get_packet(&s->rlayer)[SSL2_RT_HEADER_LENGTH]);\n        } else {\n            rr[num_recs].input =\n                &(RECORD_LAYER_get_packet(&s->rlayer)[SSL3_RT_HEADER_LENGTH]);\n        }\n\n        /*\n         * ok, we can now read from 's->packet' data into 'rr' rr->input points\n         * at rr->length bytes, which need to be copied into rr->data by either\n         * the decryption or by the decompression When the data is 'copied' into\n         * the rr->data buffer, rr->input will be pointed at the new buffer\n         */\n\n        /*\n         * We now have - encrypted [ MAC [ compressed [ plain ] ] ] rr->length\n         * bytes of encrypted compressed stuff.\n         */\n\n        /* check is not needed I believe */\n        if (rr[num_recs].length > SSL3_RT_MAX_ENCRYPTED_LENGTH) {\n            al = SSL_AD_RECORD_OVERFLOW;\n            SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_ENCRYPTED_LENGTH_TOO_LONG);\n            goto f_err;\n        }\n\n        /* decrypt in place in 'rr->input' */\n        rr[num_recs].data = rr[num_recs].input;\n        rr[num_recs].orig_len = rr[num_recs].length;\n\n        /* Mark this record as not read by upper layers yet */\n        rr[num_recs].read = 0;\n\n        num_recs++;\n\n        /* we have pulled in a full packet so zero things */\n        RECORD_LAYER_reset_packet_length(&s->rlayer);\n        RECORD_LAYER_clear_first_record(&s->rlayer);\n    } while (num_recs < max_recs\n             && rr[num_recs - 1].type == SSL3_RT_APPLICATION_DATA\n             && SSL_USE_EXPLICIT_IV(s)\n             && s->enc_read_ctx != NULL\n             && (EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(s->enc_read_ctx))\n                 & EVP_CIPH_FLAG_PIPELINE)\n             && ssl3_record_app_data_waiting(s));\n\n    /*\n     * If in encrypt-then-mac mode calculate mac from encrypted record. All\n     * the details below are public so no timing details can leak.\n     */\n    if (SSL_USE_ETM(s) && s->read_hash) {\n        unsigned char *mac;\n        mac_size = EVP_MD_CTX_size(s->read_hash);\n        OPENSSL_assert(mac_size <= EVP_MAX_MD_SIZE);\n        for (j = 0; j < num_recs; j++) {\n            if (rr[j].length < mac_size) {\n                al = SSL_AD_DECODE_ERROR;\n                SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_LENGTH_TOO_SHORT);\n                goto f_err;\n            }\n            rr[j].length -= mac_size;\n            mac = rr[j].data + rr[j].length;\n            i = s->method->ssl3_enc->mac(s, &rr[j], md, 0 /* not send */ );\n            if (i < 0 || CRYPTO_memcmp(md, mac, (size_t)mac_size) != 0) {\n                al = SSL_AD_BAD_RECORD_MAC;\n                SSLerr(SSL_F_SSL3_GET_RECORD,\n                       SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC);\n                goto f_err;\n            }\n        }\n    }\n\n    enc_err = s->method->ssl3_enc->enc(s, rr, num_recs, 0);\n    /*-\n     * enc_err is:\n     *    0: (in non-constant time) if the record is publically invalid.\n     *    1: if the padding is valid\n     *    -1: if the padding is invalid\n     */\n    if (enc_err == 0) {\n        al = SSL_AD_DECRYPTION_FAILED;\n        SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_BLOCK_CIPHER_PAD_IS_WRONG);\n        goto f_err;\n    }\n#ifdef SSL_DEBUG\n    printf(\"dec %d\\n\", rr->length);\n    {\n        unsigned int z;\n        for (z = 0; z < rr->length; z++)\n            printf(\"%02X%c\", rr->data[z], ((z + 1) % 16) ? ' ' : '\\n');\n    }\n    printf(\"\\n\");\n#endif\n\n    /* r->length is now the compressed data plus mac */\n    if ((sess != NULL) &&\n        (s->enc_read_ctx != NULL) &&\n        (EVP_MD_CTX_md(s->read_hash) != NULL) && !SSL_USE_ETM(s)) {\n        /* s->read_hash != NULL => mac_size != -1 */\n        unsigned char *mac = NULL;\n        unsigned char mac_tmp[EVP_MAX_MD_SIZE];\n\n        mac_size = EVP_MD_CTX_size(s->read_hash);\n        OPENSSL_assert(mac_size <= EVP_MAX_MD_SIZE);\n\n        for (j = 0; j < num_recs; j++) {\n            /*\n             * orig_len is the length of the record before any padding was\n             * removed. This is public information, as is the MAC in use,\n             * therefore we can safely process the record in a different amount\n             * of time if it's too short to possibly contain a MAC.\n             */\n            if (rr[j].orig_len < mac_size ||\n                /* CBC records must have a padding length byte too. */\n                (EVP_CIPHER_CTX_mode(s->enc_read_ctx) == EVP_CIPH_CBC_MODE &&\n                 rr[j].orig_len < mac_size + 1)) {\n                al = SSL_AD_DECODE_ERROR;\n                SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_LENGTH_TOO_SHORT);\n                goto f_err;\n            }\n\n            if (EVP_CIPHER_CTX_mode(s->enc_read_ctx) == EVP_CIPH_CBC_MODE) {\n                /*\n                 * We update the length so that the TLS header bytes can be\n                 * constructed correctly but we need to extract the MAC in\n                 * constant time from within the record, without leaking the\n                 * contents of the padding bytes.\n                 */\n                mac = mac_tmp;\n                ssl3_cbc_copy_mac(mac_tmp, &rr[j], mac_size);\n                rr[j].length -= mac_size;\n            } else {\n                /*\n                 * In this case there's no padding, so |rec->orig_len| equals\n                 * |rec->length| and we checked that there's enough bytes for\n                 * |mac_size| above.\n                 */\n                rr[j].length -= mac_size;\n                mac = &rr[j].data[rr[j].length];\n            }\n\n            i = s->method->ssl3_enc->mac(s, &rr[j], md, 0 /* not send */ );\n            if (i < 0 || mac == NULL\n                || CRYPTO_memcmp(md, mac, (size_t)mac_size) != 0)\n                enc_err = -1;\n            if (rr->length > SSL3_RT_MAX_COMPRESSED_LENGTH + mac_size)\n                enc_err = -1;\n        }\n    }\n\n    if (enc_err < 0) {\n        /*\n         * A separate 'decryption_failed' alert was introduced with TLS 1.0,\n         * SSL 3.0 only has 'bad_record_mac'.  But unless a decryption\n         * failure is directly visible from the ciphertext anyway, we should\n         * not reveal which kind of error occurred -- this might become\n         * visible to an attacker (e.g. via a logfile)\n         */\n        al = SSL_AD_BAD_RECORD_MAC;\n        SSLerr(SSL_F_SSL3_GET_RECORD,\n               SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC);\n        goto f_err;\n    }\n\n    for (j = 0; j < num_recs; j++) {\n        /* rr[j].length is now just compressed */\n        if (s->expand != NULL) {\n            if (rr[j].length > SSL3_RT_MAX_COMPRESSED_LENGTH) {\n                al = SSL_AD_RECORD_OVERFLOW;\n                SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_COMPRESSED_LENGTH_TOO_LONG);\n                goto f_err;\n            }\n            if (!ssl3_do_uncompress(s, &rr[j])) {\n                al = SSL_AD_DECOMPRESSION_FAILURE;\n                SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_BAD_DECOMPRESSION);\n                goto f_err;\n            }\n        }\n\n        if (rr[j].length > SSL3_RT_MAX_PLAIN_LENGTH) {\n            al = SSL_AD_RECORD_OVERFLOW;\n            SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_DATA_LENGTH_TOO_LONG);\n            goto f_err;\n        }\n\n        rr[j].off = 0;\n        /*-\n         * So at this point the following is true\n         * rr[j].type   is the type of record\n         * rr[j].length == number of bytes in record\n         * rr[j].off    == offset to first valid byte\n         * rr[j].data   == where to take bytes from, increment after use :-).\n         */\n\n        /* just read a 0 length packet */\n        if (rr[j].length == 0) {\n            RECORD_LAYER_inc_empty_record_count(&s->rlayer);\n            if (RECORD_LAYER_get_empty_record_count(&s->rlayer)\n                > MAX_EMPTY_RECORDS) {\n                al = SSL_AD_UNEXPECTED_MESSAGE;\n                SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_RECORD_TOO_SMALL);\n                goto f_err;\n            }\n        } else {\n            RECORD_LAYER_reset_empty_record_count(&s->rlayer);\n        }\n    }\n\n    RECORD_LAYER_set_numrpipes(&s->rlayer, num_recs);\n    return 1;\n\n f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n err:\n    return ret;\n}",
  "abstract_func_before": "int ssl3_get_record(SSL *VAR_0)\n{\n    int VAR_1, VAR_2, VAR_3;\n    int VAR_4, VAR_5, VAR_6, VAR_7 = -1;\n    SSL3_RECORD *VAR_8;\n    SSL3_BUFFER *VAR_9;\n    SSL_SESSION *VAR_10;\n    unsigned char *VAR_11;\n    unsigned char VAR_12[VAR_13];\n    short VAR_14;\n    unsigned VAR_15;\n    unsigned int VAR_16 = 0;\n    unsigned int VAR_17;\n    unsigned int VAR_18;\n\n    VAR_8 = RECORD_LAYER_get_rrec(&VAR_0->rlayer);\n    VAR_9 = RECORD_LAYER_get_rbuf(&VAR_0->rlayer);\n    VAR_17 = VAR_0->max_pipelines;\n    if (VAR_17 == 0)\n        VAR_17 = 1;\n    VAR_10 = VAR_0->session;\n\n    do {\n        /* COMMENT_0 */\n        if ((RECORD_LAYER_get_rstate(&VAR_0->rlayer) != VAR_19) ||\n            (RECORD_LAYER_get_packet_length(&VAR_0->rlayer)\n             < VAR_20)) {\n            VAR_5 = ssl3_read_n(VAR_0, VAR_20,\n                            SSL3_BUFFER_get_len(VAR_9), 0,\n                            VAR_16 == 0 ? 1 : 0);\n            if (VAR_5 <= 0)\n                return (VAR_5);     /* COMMENT_1 */\n            RECORD_LAYER_set_rstate(&VAR_0->rlayer, VAR_19);\n\n            VAR_11 = RECORD_LAYER_get_packet(&VAR_0->rlayer);\n\n            /* COMMENT_2 */\n                                                                              \n               \n            if (VAR_0->server && RECORD_LAYER_is_first_record(&VAR_0->rlayer)\n                && (VAR_11[0] & 0x80) && (VAR_11[2] == VAR_21)) {\n                /* COMMENT_5 */\n                                      \n                  \n                                                                    \n                                                                         \n                                                                                \n                                                                      \n                                                         \n                   \n                VAR_8[VAR_16].type = VAR_22;\n                VAR_8[VAR_16].rec_version = VAR_23;\n\n                VAR_8[VAR_16].length = ((VAR_11[0] & 0x7f) << 8) | VAR_11[1];\n\n                if (VAR_8[VAR_16].length > SSL3_BUFFER_get_len(VAR_9)\n                    - VAR_24) {\n                    VAR_3 = VAR_25;\n                    SSLerr(VAR_26, VAR_27);\n                    goto f_err;\n                }\n\n                if (VAR_8[VAR_16].length < VAR_28) {\n                    VAR_3 = VAR_29;\n                    SSLerr(VAR_26, VAR_30);\n                    goto f_err;\n                }\n            } else {\n                /* COMMENT_14 */\n                if (VAR_0->msg_callback)\n                    VAR_0->msg_callback(0, 0, VAR_31, VAR_11, 5, VAR_0,\n                                    VAR_0->msg_callback_arg);\n\n                /* COMMENT_15 */\n                VAR_8[VAR_16].type = *(VAR_11++);\n                VAR_1 = *(VAR_11++);\n                VAR_2 = *(VAR_11++);\n                VAR_14 = (VAR_1 << 8) | VAR_2;\n                VAR_8[VAR_16].rec_version = VAR_14;\n                n2s(VAR_11, VAR_8[VAR_16].length);\n\n                /* COMMENT_16 */\n                if (!VAR_0->first_packet && VAR_14 != VAR_0->version) {\n                    SSLerr(VAR_26, VAR_32);\n                    if ((VAR_0->version & 0xFF00) == (VAR_14 & 0xFF00)\n                        && !VAR_0->enc_write_ctx && !VAR_0->write_hash) {\n                        if (VAR_8->type == VAR_33) {\n                            /* COMMENT_17 */\n                                                                               \n                                                                            \n                                                                               \n                                                                                \n                                                                            \n                                   \n                               \n                            goto err;\n                        }\n                        /* COMMENT_25 */\n                                                                               \n                           \n                        VAR_0->version = (unsigned short)VAR_14;\n                    }\n                    VAR_3 = VAR_34;\n                    goto f_err;\n                }\n\n                if ((VAR_14 >> 8) != VAR_35) {\n                    if (RECORD_LAYER_is_first_record(&VAR_0->rlayer)) {\n                        /* COMMENT_28 */\n                                           \n                        VAR_11 = RECORD_LAYER_get_packet(&VAR_0->rlayer);\n                        if (strncmp((char *)VAR_11, \"GET \", 4) == 0 ||\n                            strncmp((char *)VAR_11, \"POST \", 5) == 0 ||\n                            strncmp((char *)VAR_11, \"HEAD \", 5) == 0 ||\n                            strncmp((char *)VAR_11, \"PUT \", 4) == 0) {\n                            SSLerr(VAR_26, VAR_36);\n                            goto err;\n                        } else if (strncmp((char *)VAR_11, \"CONNE\", 5) == 0) {\n                            SSLerr(VAR_26,\n                                   VAR_37);\n                            goto err;\n                        }\n\n                        /* COMMENT_30 */\n                        SSLerr(VAR_26,\n                               VAR_32);\n                        goto err;\n                    } else {\n                        SSLerr(VAR_26,\n                               VAR_32);\n                        VAR_3 = VAR_34;\n                        goto f_err;\n                    }\n                }\n\n                if (VAR_8[VAR_16].length >\n                    SSL3_BUFFER_get_len(VAR_9) - VAR_20) {\n                    VAR_3 = VAR_25;\n                    SSLerr(VAR_26, VAR_27);\n                    goto f_err;\n                }\n            }\n\n            /* COMMENT_31 */\n        }\n\n        /* COMMENT_32 */\n                                                                         \n                                                                           \n                 \n           \n        if (VAR_8[VAR_16].rec_version == VAR_23) {\n            VAR_6 = VAR_8[VAR_16].length + VAR_24\n                - VAR_20;\n        } else {\n            VAR_6 = VAR_8[VAR_16].length;\n        }\n        if (VAR_6 > 0) {\n            /* COMMENT_37 */\n\n            VAR_5 = ssl3_read_n(VAR_0, VAR_6, VAR_6, 1, 0);\n            if (VAR_5 <= 0)\n                return (VAR_5);     /* COMMENT_38 */\n        }\n\n        /* COMMENT_39 */\n        RECORD_LAYER_set_rstate(&VAR_0->rlayer, VAR_38);\n\n        /* COMMENT_40 */\n                                                                                 \n                                                                    \n                                                   \n           \n        if (VAR_8[VAR_16].rec_version == VAR_23) {\n            VAR_8[VAR_16].input =\n                &(RECORD_LAYER_get_packet(&VAR_0->rlayer)[VAR_24]);\n        } else {\n            VAR_8[VAR_16].input =\n                &(RECORD_LAYER_get_packet(&VAR_0->rlayer)[VAR_20]);\n        }\n\n        /* COMMENT_45 */\n                                                                               \n                                                                               \n                                                                                \n                                                                           \n           \n\n        /* COMMENT_51 */\n                                                                              \n                                               \n           \n\n        /* COMMENT_55 */\n        if (VAR_8[VAR_16].length > VAR_39) {\n            VAR_3 = VAR_25;\n            SSLerr(VAR_26, VAR_40);\n            goto f_err;\n        }\n\n        /* COMMENT_56 */\n        VAR_8[VAR_16].data = VAR_8[VAR_16].input;\n        VAR_8[VAR_16].orig_len = VAR_8[VAR_16].length;\n\n        /* COMMENT_57 */\n        VAR_8[VAR_16].read = 0;\n\n        VAR_16++;\n\n        /* COMMENT_58 */\n        RECORD_LAYER_reset_packet_length(&VAR_0->rlayer);\n        RECORD_LAYER_clear_first_record(&VAR_0->rlayer);\n    } while (VAR_16 < VAR_17\n             && VAR_8[VAR_16 - 1].type == VAR_41\n             && SSL_USE_EXPLICIT_IV(VAR_0)\n             && VAR_0->enc_read_ctx != NULL\n             && (EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(VAR_0->enc_read_ctx))\n                 & VAR_42)\n             && ssl3_record_app_data_waiting(VAR_0));\n\n    /* COMMENT_59 */\n                                                                           \n                                                                  \n       \n    if (SSL_USE_ETM(VAR_0) && VAR_0->read_hash) {\n        unsigned char *VAR_43;\n        VAR_15 = EVP_MD_CTX_size(VAR_0->read_hash);\n        OPENSSL_assert(VAR_15 <= VAR_13);\n        for (VAR_18 = 0; VAR_18 < VAR_16; VAR_18++) {\n            if (VAR_8[VAR_18].length < VAR_15) {\n                VAR_3 = VAR_44;\n                SSLerr(VAR_26, VAR_30);\n                goto f_err;\n            }\n            VAR_8[VAR_18].length -= VAR_15;\n            VAR_43 = VAR_8[VAR_18].data + VAR_8[VAR_18].length;\n            VAR_6 = VAR_0->method->ssl3_enc->mac(VAR_0, &VAR_8[VAR_18], VAR_12, 0 /* COMMENT_63 */ );\n            if (VAR_6 < 0 || CRYPTO_memcmp(VAR_12, VAR_43, (size_t)VAR_15) != 0) {\n                VAR_3 = VAR_45;\n                SSLerr(VAR_26,\n                       VAR_46);\n                goto f_err;\n            }\n        }\n    }\n\n    VAR_4 = VAR_0->method->ssl3_enc->enc(VAR_0, VAR_8, VAR_16, 0);\n    /* COMMENT_64 */\n                  \n                                                                        \n                                    \n                                       \n       \n    if (VAR_4 == 0) {\n        VAR_3 = VAR_47;\n        SSLerr(VAR_26, VAR_48);\n        goto f_err;\n    }\n#ifdef VAR_49\n    printf(\"dec %d\\n\", VAR_8->length);\n    {\n        unsigned int VAR_50;\n        for (VAR_50 = 0; VAR_50 < VAR_8->length; VAR_50++)\n            printf(\"%02X%c\", VAR_8->data[VAR_50], ((VAR_50 + 1) % 16) ? ' ' : '\\n');\n    }\n    printf(\"\\n\");\n#endif\n\n    /* COMMENT_70 */\n    if ((VAR_10 != NULL) &&\n        (VAR_0->enc_read_ctx != NULL) &&\n        (EVP_MD_CTX_md(VAR_0->read_hash) != NULL) && !SSL_USE_ETM(VAR_0)) {\n        /* COMMENT_71 */\n        unsigned char *VAR_43 = NULL;\n        unsigned char VAR_51[VAR_13];\n\n        VAR_15 = EVP_MD_CTX_size(VAR_0->read_hash);\n        OPENSSL_assert(VAR_15 <= VAR_13);\n\n        for (VAR_18 = 0; VAR_18 < VAR_16; VAR_18++) {\n            /* COMMENT_72 */\n                                                                          \n                                                                         \n                                                                               \n                                                                   \n               \n            if (VAR_8[VAR_18].orig_len < VAR_15 ||\n                /* COMMENT_78 */\n                (EVP_CIPHER_CTX_mode(VAR_0->enc_read_ctx) == VAR_52 &&\n                 VAR_8[VAR_18].orig_len < VAR_15 + 1)) {\n                VAR_3 = VAR_44;\n                SSLerr(VAR_26, VAR_30);\n                goto f_err;\n            }\n\n            if (EVP_CIPHER_CTX_mode(VAR_0->enc_read_ctx) == VAR_52) {\n                /* COMMENT_79 */\n                                                                           \n                                                                          \n                                                                            \n                                                 \n                   \n                VAR_43 = VAR_51;\n                ssl3_cbc_copy_mac(VAR_51, &VAR_8[VAR_18], VAR_15);\n                VAR_8[VAR_18].length -= VAR_15;\n            } else {\n                /* COMMENT_85 */\n                                                                             \n                                                                             \n                                    \n                   \n                VAR_8[VAR_18].length -= VAR_15;\n                VAR_43 = &VAR_8[VAR_18].data[VAR_8[VAR_18].length];\n            }\n\n            VAR_6 = VAR_0->method->ssl3_enc->mac(VAR_0, &VAR_8[VAR_18], VAR_12, 0 /* COMMENT_63 */ );\n            if (VAR_6 < 0 || VAR_43 == NULL\n                || CRYPTO_memcmp(VAR_12, VAR_43, (size_t)VAR_15) != 0)\n                VAR_4 = -1;\n            if (VAR_8->length > VAR_53 + VAR_15)\n                VAR_4 = -1;\n        }\n    }\n\n    if (VAR_4 < 0) {\n        /* COMMENT_90 */\n                                                                            \n                                                                      \n                                                                            \n                                                                       \n                                                      \n           \n        VAR_3 = VAR_45;\n        SSLerr(VAR_26,\n               VAR_46);\n        goto f_err;\n    }\n\n    for (VAR_18 = 0; VAR_18 < VAR_16; VAR_18++) {\n        /* COMMENT_97 */\n        if (VAR_0->expand != NULL) {\n            if (VAR_8[VAR_18].length > VAR_53) {\n                VAR_3 = VAR_25;\n                SSLerr(VAR_26, VAR_54);\n                goto f_err;\n            }\n            if (!ssl3_do_uncompress(VAR_0, &VAR_8[VAR_18])) {\n                VAR_3 = VAR_55;\n                SSLerr(VAR_26, VAR_56);\n                goto f_err;\n            }\n        }\n\n        if (VAR_8[VAR_18].length > VAR_57) {\n            VAR_3 = VAR_25;\n            SSLerr(VAR_26, VAR_58);\n            goto f_err;\n        }\n\n        VAR_8[VAR_18].off = 0;\n        /* COMMENT_98 */\n                                                 \n                                             \n                                                    \n                                                     \n                                                                             \n           \n\n        /* COMMENT_105 */\n        if (VAR_8[VAR_18].length == 0) {\n            RECORD_LAYER_inc_empty_record_count(&VAR_0->rlayer);\n            if (RECORD_LAYER_get_empty_record_count(&VAR_0->rlayer)\n                > VAR_59) {\n                VAR_3 = VAR_60;\n                SSLerr(VAR_26, VAR_61);\n                goto f_err;\n            }\n        } else {\n            RECORD_LAYER_reset_empty_record_count(&VAR_0->rlayer);\n        }\n    }\n\n    RECORD_LAYER_set_numrpipes(&VAR_0->rlayer, VAR_16);\n    return 1;\n\n f_err:\n    ssl3_send_alert(VAR_0, VAR_62, VAR_3);\n err:\n    return VAR_7;\n}",
  "func_graph_path_before": "openssl/4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2/ssl3_record.c/vul/before/1.json",
  "func": "int ssl3_get_record(SSL *s)\n{\n    int ssl_major, ssl_minor, al;\n    int enc_err, n, i, ret = -1;\n    SSL3_RECORD *rr;\n    SSL3_BUFFER *rbuf;\n    SSL_SESSION *sess;\n    unsigned char *p;\n    unsigned char md[EVP_MAX_MD_SIZE];\n    short version;\n    unsigned mac_size;\n    unsigned int num_recs = 0;\n    unsigned int max_recs;\n    unsigned int j;\n\n    rr = RECORD_LAYER_get_rrec(&s->rlayer);\n    rbuf = RECORD_LAYER_get_rbuf(&s->rlayer);\n    max_recs = s->max_pipelines;\n    if (max_recs == 0)\n        max_recs = 1;\n    sess = s->session;\n\n    do {\n        /* check if we have the header */\n        if ((RECORD_LAYER_get_rstate(&s->rlayer) != SSL_ST_READ_BODY) ||\n            (RECORD_LAYER_get_packet_length(&s->rlayer)\n             < SSL3_RT_HEADER_LENGTH)) {\n            n = ssl3_read_n(s, SSL3_RT_HEADER_LENGTH,\n                            SSL3_BUFFER_get_len(rbuf), 0,\n                            num_recs == 0 ? 1 : 0);\n            if (n <= 0)\n                return (n);     /* error or non-blocking */\n            RECORD_LAYER_set_rstate(&s->rlayer, SSL_ST_READ_BODY);\n\n            p = RECORD_LAYER_get_packet(&s->rlayer);\n\n            /*\n             * The first record received by the server may be a V2ClientHello.\n             */\n            if (s->server && RECORD_LAYER_is_first_record(&s->rlayer)\n                && (p[0] & 0x80) && (p[2] == SSL2_MT_CLIENT_HELLO)) {\n                /*\n                 *  SSLv2 style record\n                 *\n                 * |num_recs| here will actually always be 0 because\n                 * |num_recs > 0| only ever occurs when we are processing\n                 * multiple app data records - which we know isn't the case here\n                 * because it is an SSLv2ClientHello. We keep it using\n                 * |num_recs| for the sake of consistency\n                 */\n                rr[num_recs].type = SSL3_RT_HANDSHAKE;\n                rr[num_recs].rec_version = SSL2_VERSION;\n\n                rr[num_recs].length = ((p[0] & 0x7f) << 8) | p[1];\n\n                if (rr[num_recs].length > SSL3_BUFFER_get_len(rbuf)\n                    - SSL2_RT_HEADER_LENGTH) {\n                    al = SSL_AD_RECORD_OVERFLOW;\n                    SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_PACKET_LENGTH_TOO_LONG);\n                    goto f_err;\n                }\n\n                if (rr[num_recs].length < MIN_SSL2_RECORD_LEN) {\n                    al = SSL_AD_HANDSHAKE_FAILURE;\n                    SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_LENGTH_TOO_SHORT);\n                    goto f_err;\n                }\n            } else {\n                /* SSLv3+ style record */\n                if (s->msg_callback)\n                    s->msg_callback(0, 0, SSL3_RT_HEADER, p, 5, s,\n                                    s->msg_callback_arg);\n\n                /* Pull apart the header into the SSL3_RECORD */\n                rr[num_recs].type = *(p++);\n                ssl_major = *(p++);\n                ssl_minor = *(p++);\n                version = (ssl_major << 8) | ssl_minor;\n                rr[num_recs].rec_version = version;\n                n2s(p, rr[num_recs].length);\n\n                /* Lets check version */\n                if (!s->first_packet && version != s->version) {\n                    SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_WRONG_VERSION_NUMBER);\n                    if ((s->version & 0xFF00) == (version & 0xFF00)\n                        && !s->enc_write_ctx && !s->write_hash) {\n                        if (rr->type == SSL3_RT_ALERT) {\n                            /*\n                             * The record is using an incorrect version number,\n                             * but what we've got appears to be an alert. We\n                             * haven't read the body yet to check whether its a\n                             * fatal or not - but chances are it is. We probably\n                             * shouldn't send a fatal alert back. We'll just\n                             * end.\n                             */\n                            goto err;\n                        }\n                        /*\n                         * Send back error using their minor version number :-)\n                         */\n                        s->version = (unsigned short)version;\n                    }\n                    al = SSL_AD_PROTOCOL_VERSION;\n                    goto f_err;\n                }\n\n                if ((version >> 8) != SSL3_VERSION_MAJOR) {\n                    if (RECORD_LAYER_is_first_record(&s->rlayer)) {\n                        /* Go back to start of packet, look at the five bytes\n                         * that we have. */\n                        p = RECORD_LAYER_get_packet(&s->rlayer);\n                        if (strncmp((char *)p, \"GET \", 4) == 0 ||\n                            strncmp((char *)p, \"POST \", 5) == 0 ||\n                            strncmp((char *)p, \"HEAD \", 5) == 0 ||\n                            strncmp((char *)p, \"PUT \", 4) == 0) {\n                            SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_HTTP_REQUEST);\n                            goto err;\n                        } else if (strncmp((char *)p, \"CONNE\", 5) == 0) {\n                            SSLerr(SSL_F_SSL3_GET_RECORD,\n                                   SSL_R_HTTPS_PROXY_REQUEST);\n                            goto err;\n                        }\n\n                        /* Doesn't look like TLS - don't send an alert */\n                        SSLerr(SSL_F_SSL3_GET_RECORD,\n                               SSL_R_WRONG_VERSION_NUMBER);\n                        goto err;\n                    } else {\n                        SSLerr(SSL_F_SSL3_GET_RECORD,\n                               SSL_R_WRONG_VERSION_NUMBER);\n                        al = SSL_AD_PROTOCOL_VERSION;\n                        goto f_err;\n                    }\n                }\n\n                if (rr[num_recs].length >\n                    SSL3_BUFFER_get_len(rbuf) - SSL3_RT_HEADER_LENGTH) {\n                    al = SSL_AD_RECORD_OVERFLOW;\n                    SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_PACKET_LENGTH_TOO_LONG);\n                    goto f_err;\n                }\n            }\n\n            /* now s->rlayer.rstate == SSL_ST_READ_BODY */\n        }\n\n        /*\n         * s->rlayer.rstate == SSL_ST_READ_BODY, get and decode the data.\n         * Calculate how much more data we need to read for the rest of the\n         * record\n         */\n        if (rr[num_recs].rec_version == SSL2_VERSION) {\n            i = rr[num_recs].length + SSL2_RT_HEADER_LENGTH\n                - SSL3_RT_HEADER_LENGTH;\n        } else {\n            i = rr[num_recs].length;\n        }\n        if (i > 0) {\n            /* now s->packet_length == SSL3_RT_HEADER_LENGTH */\n\n            n = ssl3_read_n(s, i, i, 1, 0);\n            if (n <= 0)\n                return (n);     /* error or non-blocking io */\n        }\n\n        /* set state for later operations */\n        RECORD_LAYER_set_rstate(&s->rlayer, SSL_ST_READ_HEADER);\n\n        /*\n         * At this point, s->packet_length == SSL3_RT_HEADER_LENGTH + rr->length,\n         * or s->packet_length == SSL2_RT_HEADER_LENGTH + rr->length\n         * and we have that many bytes in s->packet\n         */\n        if (rr[num_recs].rec_version == SSL2_VERSION) {\n            rr[num_recs].input =\n                &(RECORD_LAYER_get_packet(&s->rlayer)[SSL2_RT_HEADER_LENGTH]);\n        } else {\n            rr[num_recs].input =\n                &(RECORD_LAYER_get_packet(&s->rlayer)[SSL3_RT_HEADER_LENGTH]);\n        }\n\n        /*\n         * ok, we can now read from 's->packet' data into 'rr' rr->input points\n         * at rr->length bytes, which need to be copied into rr->data by either\n         * the decryption or by the decompression When the data is 'copied' into\n         * the rr->data buffer, rr->input will be pointed at the new buffer\n         */\n\n        /*\n         * We now have - encrypted [ MAC [ compressed [ plain ] ] ] rr->length\n         * bytes of encrypted compressed stuff.\n         */\n\n        /* check is not needed I believe */\n        if (rr[num_recs].length > SSL3_RT_MAX_ENCRYPTED_LENGTH) {\n            al = SSL_AD_RECORD_OVERFLOW;\n            SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_ENCRYPTED_LENGTH_TOO_LONG);\n            goto f_err;\n        }\n\n        /* decrypt in place in 'rr->input' */\n        rr[num_recs].data = rr[num_recs].input;\n        rr[num_recs].orig_len = rr[num_recs].length;\n\n        /* Mark this record as not read by upper layers yet */\n        rr[num_recs].read = 0;\n\n        num_recs++;\n\n        /* we have pulled in a full packet so zero things */\n        RECORD_LAYER_reset_packet_length(&s->rlayer);\n        RECORD_LAYER_clear_first_record(&s->rlayer);\n    } while (num_recs < max_recs\n             && rr[num_recs - 1].type == SSL3_RT_APPLICATION_DATA\n             && SSL_USE_EXPLICIT_IV(s)\n             && s->enc_read_ctx != NULL\n             && (EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(s->enc_read_ctx))\n                 & EVP_CIPH_FLAG_PIPELINE)\n             && ssl3_record_app_data_waiting(s));\n\n    /*\n     * If in encrypt-then-mac mode calculate mac from encrypted record. All\n     * the details below are public so no timing details can leak.\n     */\n    if (SSL_READ_ETM(s) && s->read_hash) {\n        unsigned char *mac;\n        mac_size = EVP_MD_CTX_size(s->read_hash);\n        OPENSSL_assert(mac_size <= EVP_MAX_MD_SIZE);\n        for (j = 0; j < num_recs; j++) {\n            if (rr[j].length < mac_size) {\n                al = SSL_AD_DECODE_ERROR;\n                SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_LENGTH_TOO_SHORT);\n                goto f_err;\n            }\n            rr[j].length -= mac_size;\n            mac = rr[j].data + rr[j].length;\n            i = s->method->ssl3_enc->mac(s, &rr[j], md, 0 /* not send */ );\n            if (i < 0 || CRYPTO_memcmp(md, mac, (size_t)mac_size) != 0) {\n                al = SSL_AD_BAD_RECORD_MAC;\n                SSLerr(SSL_F_SSL3_GET_RECORD,\n                       SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC);\n                goto f_err;\n            }\n        }\n    }\n\n    enc_err = s->method->ssl3_enc->enc(s, rr, num_recs, 0);\n    /*-\n     * enc_err is:\n     *    0: (in non-constant time) if the record is publically invalid.\n     *    1: if the padding is valid\n     *    -1: if the padding is invalid\n     */\n    if (enc_err == 0) {\n        al = SSL_AD_DECRYPTION_FAILED;\n        SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_BLOCK_CIPHER_PAD_IS_WRONG);\n        goto f_err;\n    }\n#ifdef SSL_DEBUG\n    printf(\"dec %d\\n\", rr->length);\n    {\n        unsigned int z;\n        for (z = 0; z < rr->length; z++)\n            printf(\"%02X%c\", rr->data[z], ((z + 1) % 16) ? ' ' : '\\n');\n    }\n    printf(\"\\n\");\n#endif\n\n    /* r->length is now the compressed data plus mac */\n    if ((sess != NULL) &&\n        (s->enc_read_ctx != NULL) &&\n        (!SSL_READ_ETM(s) && EVP_MD_CTX_md(s->read_hash) != NULL)) {\n        /* s->read_hash != NULL => mac_size != -1 */\n        unsigned char *mac = NULL;\n        unsigned char mac_tmp[EVP_MAX_MD_SIZE];\n\n        mac_size = EVP_MD_CTX_size(s->read_hash);\n        OPENSSL_assert(mac_size <= EVP_MAX_MD_SIZE);\n\n        for (j = 0; j < num_recs; j++) {\n            /*\n             * orig_len is the length of the record before any padding was\n             * removed. This is public information, as is the MAC in use,\n             * therefore we can safely process the record in a different amount\n             * of time if it's too short to possibly contain a MAC.\n             */\n            if (rr[j].orig_len < mac_size ||\n                /* CBC records must have a padding length byte too. */\n                (EVP_CIPHER_CTX_mode(s->enc_read_ctx) == EVP_CIPH_CBC_MODE &&\n                 rr[j].orig_len < mac_size + 1)) {\n                al = SSL_AD_DECODE_ERROR;\n                SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_LENGTH_TOO_SHORT);\n                goto f_err;\n            }\n\n            if (EVP_CIPHER_CTX_mode(s->enc_read_ctx) == EVP_CIPH_CBC_MODE) {\n                /*\n                 * We update the length so that the TLS header bytes can be\n                 * constructed correctly but we need to extract the MAC in\n                 * constant time from within the record, without leaking the\n                 * contents of the padding bytes.\n                 */\n                mac = mac_tmp;\n                ssl3_cbc_copy_mac(mac_tmp, &rr[j], mac_size);\n                rr[j].length -= mac_size;\n            } else {\n                /*\n                 * In this case there's no padding, so |rec->orig_len| equals\n                 * |rec->length| and we checked that there's enough bytes for\n                 * |mac_size| above.\n                 */\n                rr[j].length -= mac_size;\n                mac = &rr[j].data[rr[j].length];\n            }\n\n            i = s->method->ssl3_enc->mac(s, &rr[j], md, 0 /* not send */ );\n            if (i < 0 || mac == NULL\n                || CRYPTO_memcmp(md, mac, (size_t)mac_size) != 0)\n                enc_err = -1;\n            if (rr->length > SSL3_RT_MAX_COMPRESSED_LENGTH + mac_size)\n                enc_err = -1;\n        }\n    }\n\n    if (enc_err < 0) {\n        /*\n         * A separate 'decryption_failed' alert was introduced with TLS 1.0,\n         * SSL 3.0 only has 'bad_record_mac'.  But unless a decryption\n         * failure is directly visible from the ciphertext anyway, we should\n         * not reveal which kind of error occurred -- this might become\n         * visible to an attacker (e.g. via a logfile)\n         */\n        al = SSL_AD_BAD_RECORD_MAC;\n        SSLerr(SSL_F_SSL3_GET_RECORD,\n               SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC);\n        goto f_err;\n    }\n\n    for (j = 0; j < num_recs; j++) {\n        /* rr[j].length is now just compressed */\n        if (s->expand != NULL) {\n            if (rr[j].length > SSL3_RT_MAX_COMPRESSED_LENGTH) {\n                al = SSL_AD_RECORD_OVERFLOW;\n                SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_COMPRESSED_LENGTH_TOO_LONG);\n                goto f_err;\n            }\n            if (!ssl3_do_uncompress(s, &rr[j])) {\n                al = SSL_AD_DECOMPRESSION_FAILURE;\n                SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_BAD_DECOMPRESSION);\n                goto f_err;\n            }\n        }\n\n        if (rr[j].length > SSL3_RT_MAX_PLAIN_LENGTH) {\n            al = SSL_AD_RECORD_OVERFLOW;\n            SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_DATA_LENGTH_TOO_LONG);\n            goto f_err;\n        }\n\n        rr[j].off = 0;\n        /*-\n         * So at this point the following is true\n         * rr[j].type   is the type of record\n         * rr[j].length == number of bytes in record\n         * rr[j].off    == offset to first valid byte\n         * rr[j].data   == where to take bytes from, increment after use :-).\n         */\n\n        /* just read a 0 length packet */\n        if (rr[j].length == 0) {\n            RECORD_LAYER_inc_empty_record_count(&s->rlayer);\n            if (RECORD_LAYER_get_empty_record_count(&s->rlayer)\n                > MAX_EMPTY_RECORDS) {\n                al = SSL_AD_UNEXPECTED_MESSAGE;\n                SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_RECORD_TOO_SMALL);\n                goto f_err;\n            }\n        } else {\n            RECORD_LAYER_reset_empty_record_count(&s->rlayer);\n        }\n    }\n\n    RECORD_LAYER_set_numrpipes(&s->rlayer, num_recs);\n    return 1;\n\n f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n err:\n    return ret;\n}",
  "abstract_func": "int ssl3_get_record(SSL *VAR_0)\n{\n    int VAR_1, VAR_2, VAR_3;\n    int VAR_4, VAR_5, VAR_6, VAR_7 = -1;\n    SSL3_RECORD *VAR_8;\n    SSL3_BUFFER *VAR_9;\n    SSL_SESSION *VAR_10;\n    unsigned char *VAR_11;\n    unsigned char VAR_12[VAR_13];\n    short VAR_14;\n    unsigned VAR_15;\n    unsigned int VAR_16 = 0;\n    unsigned int VAR_17;\n    unsigned int VAR_18;\n\n    VAR_8 = RECORD_LAYER_get_rrec(&VAR_0->rlayer);\n    VAR_9 = RECORD_LAYER_get_rbuf(&VAR_0->rlayer);\n    VAR_17 = VAR_0->max_pipelines;\n    if (VAR_17 == 0)\n        VAR_17 = 1;\n    VAR_10 = VAR_0->session;\n\n    do {\n        /* COMMENT_0 */\n        if ((RECORD_LAYER_get_rstate(&VAR_0->rlayer) != VAR_19) ||\n            (RECORD_LAYER_get_packet_length(&VAR_0->rlayer)\n             < VAR_20)) {\n            VAR_5 = ssl3_read_n(VAR_0, VAR_20,\n                            SSL3_BUFFER_get_len(VAR_9), 0,\n                            VAR_16 == 0 ? 1 : 0);\n            if (VAR_5 <= 0)\n                return (VAR_5);     /* COMMENT_1 */\n            RECORD_LAYER_set_rstate(&VAR_0->rlayer, VAR_19);\n\n            VAR_11 = RECORD_LAYER_get_packet(&VAR_0->rlayer);\n\n            /* COMMENT_2 */\n                                                                              \n               \n            if (VAR_0->server && RECORD_LAYER_is_first_record(&VAR_0->rlayer)\n                && (VAR_11[0] & 0x80) && (VAR_11[2] == VAR_21)) {\n                /* COMMENT_5 */\n                                      \n                  \n                                                                    \n                                                                         \n                                                                                \n                                                                      \n                                                         \n                   \n                VAR_8[VAR_16].type = VAR_22;\n                VAR_8[VAR_16].rec_version = VAR_23;\n\n                VAR_8[VAR_16].length = ((VAR_11[0] & 0x7f) << 8) | VAR_11[1];\n\n                if (VAR_8[VAR_16].length > SSL3_BUFFER_get_len(VAR_9)\n                    - VAR_24) {\n                    VAR_3 = VAR_25;\n                    SSLerr(VAR_26, VAR_27);\n                    goto f_err;\n                }\n\n                if (VAR_8[VAR_16].length < VAR_28) {\n                    VAR_3 = VAR_29;\n                    SSLerr(VAR_26, VAR_30);\n                    goto f_err;\n                }\n            } else {\n                /* COMMENT_14 */\n                if (VAR_0->msg_callback)\n                    VAR_0->msg_callback(0, 0, VAR_31, VAR_11, 5, VAR_0,\n                                    VAR_0->msg_callback_arg);\n\n                /* COMMENT_15 */\n                VAR_8[VAR_16].type = *(VAR_11++);\n                VAR_1 = *(VAR_11++);\n                VAR_2 = *(VAR_11++);\n                VAR_14 = (VAR_1 << 8) | VAR_2;\n                VAR_8[VAR_16].rec_version = VAR_14;\n                n2s(VAR_11, VAR_8[VAR_16].length);\n\n                /* COMMENT_16 */\n                if (!VAR_0->first_packet && VAR_14 != VAR_0->version) {\n                    SSLerr(VAR_26, VAR_32);\n                    if ((VAR_0->version & 0xFF00) == (VAR_14 & 0xFF00)\n                        && !VAR_0->enc_write_ctx && !VAR_0->write_hash) {\n                        if (VAR_8->type == VAR_33) {\n                            /* COMMENT_17 */\n                                                                               \n                                                                            \n                                                                               \n                                                                                \n                                                                            \n                                   \n                               \n                            goto err;\n                        }\n                        /* COMMENT_25 */\n                                                                               \n                           \n                        VAR_0->version = (unsigned short)VAR_14;\n                    }\n                    VAR_3 = VAR_34;\n                    goto f_err;\n                }\n\n                if ((VAR_14 >> 8) != VAR_35) {\n                    if (RECORD_LAYER_is_first_record(&VAR_0->rlayer)) {\n                        /* COMMENT_28 */\n                                           \n                        VAR_11 = RECORD_LAYER_get_packet(&VAR_0->rlayer);\n                        if (strncmp((char *)VAR_11, \"GET \", 4) == 0 ||\n                            strncmp((char *)VAR_11, \"POST \", 5) == 0 ||\n                            strncmp((char *)VAR_11, \"HEAD \", 5) == 0 ||\n                            strncmp((char *)VAR_11, \"PUT \", 4) == 0) {\n                            SSLerr(VAR_26, VAR_36);\n                            goto err;\n                        } else if (strncmp((char *)VAR_11, \"CONNE\", 5) == 0) {\n                            SSLerr(VAR_26,\n                                   VAR_37);\n                            goto err;\n                        }\n\n                        /* COMMENT_30 */\n                        SSLerr(VAR_26,\n                               VAR_32);\n                        goto err;\n                    } else {\n                        SSLerr(VAR_26,\n                               VAR_32);\n                        VAR_3 = VAR_34;\n                        goto f_err;\n                    }\n                }\n\n                if (VAR_8[VAR_16].length >\n                    SSL3_BUFFER_get_len(VAR_9) - VAR_20) {\n                    VAR_3 = VAR_25;\n                    SSLerr(VAR_26, VAR_27);\n                    goto f_err;\n                }\n            }\n\n            /* COMMENT_31 */\n        }\n\n        /* COMMENT_32 */\n                                                                         \n                                                                           \n                 \n           \n        if (VAR_8[VAR_16].rec_version == VAR_23) {\n            VAR_6 = VAR_8[VAR_16].length + VAR_24\n                - VAR_20;\n        } else {\n            VAR_6 = VAR_8[VAR_16].length;\n        }\n        if (VAR_6 > 0) {\n            /* COMMENT_37 */\n\n            VAR_5 = ssl3_read_n(VAR_0, VAR_6, VAR_6, 1, 0);\n            if (VAR_5 <= 0)\n                return (VAR_5);     /* COMMENT_38 */\n        }\n\n        /* COMMENT_39 */\n        RECORD_LAYER_set_rstate(&VAR_0->rlayer, VAR_38);\n\n        /* COMMENT_40 */\n                                                                                 \n                                                                    \n                                                   \n           \n        if (VAR_8[VAR_16].rec_version == VAR_23) {\n            VAR_8[VAR_16].input =\n                &(RECORD_LAYER_get_packet(&VAR_0->rlayer)[VAR_24]);\n        } else {\n            VAR_8[VAR_16].input =\n                &(RECORD_LAYER_get_packet(&VAR_0->rlayer)[VAR_20]);\n        }\n\n        /* COMMENT_45 */\n                                                                               \n                                                                               \n                                                                                \n                                                                           \n           \n\n        /* COMMENT_51 */\n                                                                              \n                                               \n           \n\n        /* COMMENT_55 */\n        if (VAR_8[VAR_16].length > VAR_39) {\n            VAR_3 = VAR_25;\n            SSLerr(VAR_26, VAR_40);\n            goto f_err;\n        }\n\n        /* COMMENT_56 */\n        VAR_8[VAR_16].data = VAR_8[VAR_16].input;\n        VAR_8[VAR_16].orig_len = VAR_8[VAR_16].length;\n\n        /* COMMENT_57 */\n        VAR_8[VAR_16].read = 0;\n\n        VAR_16++;\n\n        /* COMMENT_58 */\n        RECORD_LAYER_reset_packet_length(&VAR_0->rlayer);\n        RECORD_LAYER_clear_first_record(&VAR_0->rlayer);\n    } while (VAR_16 < VAR_17\n             && VAR_8[VAR_16 - 1].type == VAR_41\n             && SSL_USE_EXPLICIT_IV(VAR_0)\n             && VAR_0->enc_read_ctx != NULL\n             && (EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(VAR_0->enc_read_ctx))\n                 & VAR_42)\n             && ssl3_record_app_data_waiting(VAR_0));\n\n    /* COMMENT_59 */\n                                                                           \n                                                                  \n       \n    if (SSL_READ_ETM(VAR_0) && VAR_0->read_hash) {\n        unsigned char *VAR_43;\n        VAR_15 = EVP_MD_CTX_size(VAR_0->read_hash);\n        OPENSSL_assert(VAR_15 <= VAR_13);\n        for (VAR_18 = 0; VAR_18 < VAR_16; VAR_18++) {\n            if (VAR_8[VAR_18].length < VAR_15) {\n                VAR_3 = VAR_44;\n                SSLerr(VAR_26, VAR_30);\n                goto f_err;\n            }\n            VAR_8[VAR_18].length -= VAR_15;\n            VAR_43 = VAR_8[VAR_18].data + VAR_8[VAR_18].length;\n            VAR_6 = VAR_0->method->ssl3_enc->mac(VAR_0, &VAR_8[VAR_18], VAR_12, 0 /* COMMENT_63 */ );\n            if (VAR_6 < 0 || CRYPTO_memcmp(VAR_12, VAR_43, (size_t)VAR_15) != 0) {\n                VAR_3 = VAR_45;\n                SSLerr(VAR_26,\n                       VAR_46);\n                goto f_err;\n            }\n        }\n    }\n\n    VAR_4 = VAR_0->method->ssl3_enc->enc(VAR_0, VAR_8, VAR_16, 0);\n    /* COMMENT_64 */\n                  \n                                                                        \n                                    \n                                       \n       \n    if (VAR_4 == 0) {\n        VAR_3 = VAR_47;\n        SSLerr(VAR_26, VAR_48);\n        goto f_err;\n    }\n#ifdef VAR_49\n    printf(\"dec %d\\n\", VAR_8->length);\n    {\n        unsigned int VAR_50;\n        for (VAR_50 = 0; VAR_50 < VAR_8->length; VAR_50++)\n            printf(\"%02X%c\", VAR_8->data[VAR_50], ((VAR_50 + 1) % 16) ? ' ' : '\\n');\n    }\n    printf(\"\\n\");\n#endif\n\n    /* COMMENT_70 */\n    if ((VAR_10 != NULL) &&\n        (VAR_0->enc_read_ctx != NULL) &&\n        (!SSL_READ_ETM(VAR_0) && EVP_MD_CTX_md(VAR_0->read_hash) != NULL)) {\n        /* COMMENT_71 */\n        unsigned char *VAR_43 = NULL;\n        unsigned char VAR_51[VAR_13];\n\n        VAR_15 = EVP_MD_CTX_size(VAR_0->read_hash);\n        OPENSSL_assert(VAR_15 <= VAR_13);\n\n        for (VAR_18 = 0; VAR_18 < VAR_16; VAR_18++) {\n            /* COMMENT_72 */\n                                                                          \n                                                                         \n                                                                               \n                                                                   \n               \n            if (VAR_8[VAR_18].orig_len < VAR_15 ||\n                /* COMMENT_78 */\n                (EVP_CIPHER_CTX_mode(VAR_0->enc_read_ctx) == VAR_52 &&\n                 VAR_8[VAR_18].orig_len < VAR_15 + 1)) {\n                VAR_3 = VAR_44;\n                SSLerr(VAR_26, VAR_30);\n                goto f_err;\n            }\n\n            if (EVP_CIPHER_CTX_mode(VAR_0->enc_read_ctx) == VAR_52) {\n                /* COMMENT_79 */\n                                                                           \n                                                                          \n                                                                            \n                                                 \n                   \n                VAR_43 = VAR_51;\n                ssl3_cbc_copy_mac(VAR_51, &VAR_8[VAR_18], VAR_15);\n                VAR_8[VAR_18].length -= VAR_15;\n            } else {\n                /* COMMENT_85 */\n                                                                             \n                                                                             \n                                    \n                   \n                VAR_8[VAR_18].length -= VAR_15;\n                VAR_43 = &VAR_8[VAR_18].data[VAR_8[VAR_18].length];\n            }\n\n            VAR_6 = VAR_0->method->ssl3_enc->mac(VAR_0, &VAR_8[VAR_18], VAR_12, 0 /* COMMENT_63 */ );\n            if (VAR_6 < 0 || VAR_43 == NULL\n                || CRYPTO_memcmp(VAR_12, VAR_43, (size_t)VAR_15) != 0)\n                VAR_4 = -1;\n            if (VAR_8->length > VAR_53 + VAR_15)\n                VAR_4 = -1;\n        }\n    }\n\n    if (VAR_4 < 0) {\n        /* COMMENT_90 */\n                                                                            \n                                                                      \n                                                                            \n                                                                       \n                                                      \n           \n        VAR_3 = VAR_45;\n        SSLerr(VAR_26,\n               VAR_46);\n        goto f_err;\n    }\n\n    for (VAR_18 = 0; VAR_18 < VAR_16; VAR_18++) {\n        /* COMMENT_97 */\n        if (VAR_0->expand != NULL) {\n            if (VAR_8[VAR_18].length > VAR_53) {\n                VAR_3 = VAR_25;\n                SSLerr(VAR_26, VAR_54);\n                goto f_err;\n            }\n            if (!ssl3_do_uncompress(VAR_0, &VAR_8[VAR_18])) {\n                VAR_3 = VAR_55;\n                SSLerr(VAR_26, VAR_56);\n                goto f_err;\n            }\n        }\n\n        if (VAR_8[VAR_18].length > VAR_57) {\n            VAR_3 = VAR_25;\n            SSLerr(VAR_26, VAR_58);\n            goto f_err;\n        }\n\n        VAR_8[VAR_18].off = 0;\n        /* COMMENT_98 */\n                                                 \n                                             \n                                                    \n                                                     \n                                                                             \n           \n\n        /* COMMENT_105 */\n        if (VAR_8[VAR_18].length == 0) {\n            RECORD_LAYER_inc_empty_record_count(&VAR_0->rlayer);\n            if (RECORD_LAYER_get_empty_record_count(&VAR_0->rlayer)\n                > VAR_59) {\n                VAR_3 = VAR_60;\n                SSLerr(VAR_26, VAR_61);\n                goto f_err;\n            }\n        } else {\n            RECORD_LAYER_reset_empty_record_count(&VAR_0->rlayer);\n        }\n    }\n\n    RECORD_LAYER_set_numrpipes(&VAR_0->rlayer, VAR_16);\n    return 1;\n\n f_err:\n    ssl3_send_alert(VAR_0, VAR_62, VAR_3);\n err:\n    return VAR_7;\n}",
  "func_graph_path": "openssl/4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2/ssl3_record.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -222,7 +222,7 @@\n      * If in encrypt-then-mac mode calculate mac from encrypted record. All\n      * the details below are public so no timing details can leak.\n      */\n-    if (SSL_USE_ETM(s) && s->read_hash) {\n+    if (SSL_READ_ETM(s) && s->read_hash) {\n         unsigned char *mac;\n         mac_size = EVP_MD_CTX_size(s->read_hash);\n         OPENSSL_assert(mac_size <= EVP_MAX_MD_SIZE);\n@@ -269,7 +269,7 @@\n     /* r->length is now the compressed data plus mac */\n     if ((sess != NULL) &&\n         (s->enc_read_ctx != NULL) &&\n-        (EVP_MD_CTX_md(s->read_hash) != NULL) && !SSL_USE_ETM(s)) {\n+        (!SSL_READ_ETM(s) && EVP_MD_CTX_md(s->read_hash) != NULL)) {\n         /* s->read_hash != NULL => mac_size != -1 */\n         unsigned char *mac = NULL;\n         unsigned char mac_tmp[EVP_MAX_MD_SIZE];",
  "diff_line_info": {
    "deleted_lines": [
      "    if (SSL_USE_ETM(s) && s->read_hash) {",
      "        (EVP_MD_CTX_md(s->read_hash) != NULL) && !SSL_USE_ETM(s)) {"
    ],
    "added_lines": [
      "    if (SSL_READ_ETM(s) && s->read_hash) {",
      "        (!SSL_READ_ETM(s) && EVP_MD_CTX_md(s->read_hash) != NULL)) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/EktapopaT/openssl/pull/1",
  "description": {
    "pr_info": {
      "title": "Open ssl 1 1 0 stable",
      "number": 1
    },
    "comment": [
      "<!--\r\nThank you for your pull request. Please review below requirements.\r\n\r\nContributors guide: https://github.com/openssl/openssl/blob/master/CONTRIBUTING\r\n-->\r\n\r\n##### Checklist\r\n<!-- Remove items that do not apply. For completed items, change [ ] to [x]. -->\r\n- [ ] documentation is added or updated\r\n- [ ] tests are added or updated\r\n- [ ] CLA is signed\r\n\r\n##### Description of change\r\n<!-- Provide a description of the changes.\r\n\r\nIf it fixes a github issue, add Fixes #XXXX.\r\n-->\r\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses a security vulnerability (CVE-2017-3733) causing a DoS attack through a crash during renegotiation. The code changes modify ETM flag checks to prevent the crash, impacting system availability.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 0.95"
}