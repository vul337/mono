{
  "cve_id": "CVE-2021-34335",
  "cwe_ids": [
    "CWE-369"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "Exiv2/exiv2",
  "commit_msg": "Defensive coding to avoid 0x80000000/0xFFFFFFFF FPE.",
  "commit_hash": "2d8d44e47b1500030e5b249bffbaf1e80aa74815",
  "git_url": "https://github.com/Exiv2/exiv2/commit/2d8d44e47b1500030e5b249bffbaf1e80aa74815",
  "file_path": "include/exiv2/value.hpp",
  "func_name": "ValueType<T>::read",
  "func_before": "int ValueType<T>::read(const byte* buf, long len, ByteOrder byteOrder)\n    {\n        value_.clear();\n        long ts = TypeInfo::typeSize(typeId());\n        if (ts != 0)\n            if (len % ts != 0) len = (len / ts) * ts;\n        for (long i = 0; i < len; i += ts) {\n            value_.push_back(getValue<T>(buf + i, byteOrder));\n        }\n        return 0;\n    }",
  "abstract_func_before": "int ValueType<T>::read(const byte* VAR_0, long VAR_1, ByteOrder VAR_2)\n    {\n        VAR_3.clear();\n        long VAR_4 = TypeInfo::typeSize(typeId());\n        if (VAR_4 != 0)\n            if (VAR_1 % VAR_4 != 0) VAR_1 = (VAR_1 / VAR_4) * VAR_4;\n        for (long VAR_5 = 0; VAR_5 < VAR_1; VAR_5 += VAR_4) {\n            VAR_3.push_back(VAR_6<T>(VAR_0 + VAR_5, VAR_2));\n        }\n        return 0;\n    }",
  "func_graph_path_before": "Exiv2/exiv2/2d8d44e47b1500030e5b249bffbaf1e80aa74815/value.hpp/vul/before/1.json",
  "func": "int ValueType<T>::read(const byte* buf, long len, ByteOrder byteOrder)\n    {\n        value_.clear();\n        long ts = TypeInfo::typeSize(typeId());\n        if (ts > 0)\n            if (len % ts != 0) len = (len / ts) * ts;\n        for (long i = 0; i < len; i += ts) {\n            value_.push_back(getValue<T>(buf + i, byteOrder));\n        }\n        return 0;\n    }",
  "abstract_func": "int ValueType<T>::read(const byte* VAR_0, long VAR_1, ByteOrder VAR_2)\n    {\n        VAR_3.clear();\n        long VAR_4 = TypeInfo::typeSize(typeId());\n        if (VAR_4 > 0)\n            if (VAR_1 % VAR_4 != 0) VAR_1 = (VAR_1 / VAR_4) * VAR_4;\n        for (long VAR_5 = 0; VAR_5 < VAR_1; VAR_5 += VAR_4) {\n            VAR_3.push_back(VAR_6<T>(VAR_0 + VAR_5, VAR_2));\n        }\n        return 0;\n    }",
  "func_graph_path": "Exiv2/exiv2/2d8d44e47b1500030e5b249bffbaf1e80aa74815/value.hpp/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -2,7 +2,7 @@\n     {\n         value_.clear();\n         long ts = TypeInfo::typeSize(typeId());\n-        if (ts != 0)\n+        if (ts > 0)\n             if (len % ts != 0) len = (len / ts) * ts;\n         for (long i = 0; i < len; i += ts) {\n             value_.push_back(getValue<T>(buf + i, byteOrder));",
  "diff_line_info": {
    "deleted_lines": [
      "        if (ts != 0)"
    ],
    "added_lines": [
      "        if (ts > 0)"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/Exiv2/exiv2/pull/1750",
  "description": {
    "pr_info": {
      "title": "Avoid integer divide by zero",
      "number": 1750
    },
    "comment": [
      "The main change here is to fix an integer divide by zero in [`src/minoltamn_int.cpp`](https://github.com/Exiv2/exiv2/blob/ab58026cff0e5edebc026261e9dc4b7db05b802d/src/minoltamn_int.cpp#L2176).\r\n\r\nI also added some defensive coding to avoid the FPE that could be caused by `0x80000000/0xFFFFFFFF`: rather than checking that the denominator is not zero, check that the denominator is greater than zero. I doubt that we are ever deliberately using negative denominators, so I think it should be a safe change.",
      "This is the CodeQL query that I used to search for integer divide operations:\r\n\r\n```\r\nimport cpp\r\nimport semmle.code.cpp.rangeanalysis.SimpleRangeAnalysis\r\n\r\nfrom DivExpr div, Expr rhs\r\nwhere\r\n  rhs = div.getRightOperand() and\r\n  div.getType() instanceof IntegralType and\r\n  not (lowerBound(rhs) > 0 or upperBound(rhs) < 0) and\r\n  not rhs instanceof SizeofOperator and\r\n  exists(rhs.getLocation().getFile().getRelativePath())\r\nselect rhs, rhs.getType()\r\n```"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix\n\nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch modifies a condition to prevent a division by zero, which could cause a floating-point exception. This addresses a potential security vulnerability by mitigating a crash condition.\n\nFinal Classification: Security Vulnerability Fix\n\nConfidence Score: 0.95"
}