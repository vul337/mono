{
  "cve_id": "CVE-2022-36044",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "rizinorg/rizin",
  "commit_msg": "fix oob read on luac",
  "commit_hash": "07b43bc8aa1ffebd9b68d60624c9610cf7e460c7",
  "git_url": "https://github.com/rizinorg/rizin/commit/07b43bc8aa1ffebd9b68d60624c9610cf7e460c7",
  "file_path": "librz/bin/format/luac/luac_bin.c",
  "func_name": "_luac_build_info",
  "func_before": "void _luac_build_info(LuaProto *proto, LuacBinInfo *info) {\n\t/* process proto header info */\n\tchar *section_name;\n\tchar *symbol_name;\n\tchar *proto_name;\n\tchar **upvalue_names = NULL;\n\tRzListIter *iter;\n\tint i = 0; // iter\n\n\tut64 current_offset;\n\tut64 current_size;\n\n\t// 0. check if stripped (proto name is lost)\n\tif (proto->name_size == 0 || proto->proto_name == NULL) {\n\t\t// replace name with current offset\n\t\tproto_name = rz_str_newf(\"fcn.%08llx\", proto->offset);\n\t} else {\n\t\tproto_name = rz_str_new((char *)proto->proto_name);\n\t}\n\n\t// 1.1 set section name as function_name.header\n\tcurrent_offset = proto->offset;\n\tcurrent_size = proto->size;\n\tsection_name = rz_str_newf(\"%s.header\", proto_name);\n\tluac_add_section(info->section_list, section_name, current_offset, current_size, false);\n\tRZ_FREE(section_name);\n\n\t// 1.2 set section name as function_name.code\n\tcurrent_offset = proto->code_offset;\n\tcurrent_size = proto->code_size;\n\tsection_name = rz_str_newf(\"%s.code\", proto_name);\n\tluac_add_section(info->section_list, section_name, current_offset, current_size, true);\n\tRZ_FREE(section_name);\n\n\t// 1.3 set const section\n\tcurrent_offset = proto->const_offset;\n\tcurrent_size = proto->const_size;\n\tsection_name = rz_str_newf(\"%s.const\", proto_name);\n\tluac_add_section(info->section_list, section_name, current_offset, current_size, false);\n\tRZ_FREE(section_name);\n\n\t// 1.4 upvalue section\n\tcurrent_offset = proto->upvalue_offset;\n\tcurrent_size = proto->upvalue_size;\n\tsection_name = rz_str_newf(\"%s.upvalues\", proto_name);\n\tluac_add_section(info->section_list, section_name, current_offset, current_size, false);\n\tRZ_FREE(section_name);\n\n\t// 1.5 inner protos section\n\tcurrent_offset = proto->inner_proto_offset;\n\tcurrent_size = proto->inner_proto_size;\n\tsection_name = rz_str_newf(\"%s.protos\", proto_name);\n\tluac_add_section(info->section_list, section_name, current_offset, current_size, false);\n\tRZ_FREE(section_name);\n\n\t// 1.6 debug section\n\tcurrent_offset = proto->debug_offset;\n\tcurrent_size = proto->debug_size;\n\tsection_name = rz_str_newf(\"%s.debug\", proto_name);\n\tluac_add_section(info->section_list, section_name, current_offset, current_size, false);\n\tRZ_FREE(section_name);\n\n\t// 2.1 parse local var info\n\tLuaLocalVarEntry *local_var_entry;\n\trz_list_foreach (proto->local_var_info_entries, iter, local_var_entry) {\n\t\tluac_add_string(\n\t\t\tinfo->string_list,\n\t\t\t(char *)local_var_entry->varname,\n\t\t\tlocal_var_entry->offset,\n\t\t\tlocal_var_entry->varname_len);\n\t}\n\n\t// 2.2 parse debug_upvalues\n\tsize_t real_upvalue_cnt = rz_list_length(proto->upvalue_entries);\n\tif (real_upvalue_cnt > 0) {\n\t\tLuaDbgUpvalueEntry *debug_upv_entry;\n\t\tupvalue_names = RZ_NEWS0(char *, real_upvalue_cnt);\n\t\tif (!upvalue_names) {\n\t\t\tfree(proto_name);\n\t\t\treturn;\n\t\t}\n\n\t\ti = 0;\n\t\trz_list_foreach (proto->dbg_upvalue_entries, iter, debug_upv_entry) {\n\t\t\tupvalue_names[i] = (char *)debug_upv_entry->upvalue_name;\n\t\t\tluac_add_string(\n\t\t\t\tinfo->string_list,\n\t\t\t\tupvalue_names[i],\n\t\t\t\tdebug_upv_entry->offset,\n\t\t\t\tdebug_upv_entry->name_len);\n\t\t\ti++;\n\t\t}\n\t}\n\n\t// 3.1 construct constant symbols\n\tLuaConstEntry *const_entry;\n\trz_list_foreach (proto->const_entries, iter, const_entry) {\n\t\tsymbol_name = get_constant_symbol_name(proto_name, const_entry);\n\t\tluac_add_symbol(\n\t\t\tinfo->symbol_list,\n\t\t\tsymbol_name,\n\t\t\tconst_entry->offset,\n\t\t\tconst_entry->data_len,\n\t\t\tget_tag_string(const_entry->tag));\n\t\tif (const_entry->tag == LUA_VLNGSTR || const_entry->tag == LUA_VSHRSTR) {\n\t\t\tluac_add_string(\n\t\t\t\tinfo->string_list,\n\t\t\t\t(char *)const_entry->data,\n\t\t\t\tconst_entry->offset,\n\t\t\t\tconst_entry->data_len);\n\t\t}\n\t\tRZ_FREE(symbol_name);\n\t}\n\n\t// 3.2 construct upvalue symbols\n\tLuaUpvalueEntry *upvalue_entry;\n\ti = 0;\n\trz_list_foreach (proto->upvalue_entries, iter, upvalue_entry) {\n\t\tsymbol_name = get_upvalue_symbol_name(proto_name, upvalue_entry, upvalue_names[i++]);\n\t\tluac_add_symbol(\n\t\t\tinfo->symbol_list,\n\t\t\tsymbol_name,\n\t\t\tupvalue_entry->offset,\n\t\t\t3,\n\t\t\t\"UPVALUE\");\n\t\tRZ_FREE(symbol_name);\n\t}\n\n\t// 4. parse sub proto\n\tLuaProto *sub_proto;\n\trz_list_foreach (proto->proto_entries, iter, sub_proto) {\n\t\t_luac_build_info(sub_proto, info);\n\t}\n\n\tfree(upvalue_names);\n\tfree(proto_name);\n}",
  "abstract_func_before": "void _luac_build_info(LuaProto *VAR_0, LuacBinInfo *VAR_1) {\n\t/* COMMENT_0 */\n\tchar *VAR_2;\n\tchar *VAR_3;\n\tchar *VAR_4;\n\tchar **VAR_5 = NULL;\n\tRzListIter *VAR_6;\n\tint VAR_7 = 0; /* COMMENT_1 */\n\n\tut64 VAR_8;\n\tut64 VAR_9;\n\n\t/* COMMENT_2 */\n\tif (VAR_0->name_size == 0 || VAR_0->proto_name == NULL) {\n\t\t/* COMMENT_3 */\n\t\tVAR_4 = rz_str_newf(\"fcn.%08llx\", VAR_0->offset);\n\t} else {\n\t\tVAR_4 = rz_str_new((char *)VAR_0->proto_name);\n\t}\n\n\t/* COMMENT_4 */\n\tVAR_8 = VAR_0->offset;\n\tVAR_9 = VAR_0->size;\n\tVAR_2 = rz_str_newf(\"%s.header\", VAR_4);\n\tluac_add_section(VAR_1->section_list, VAR_2, VAR_8, VAR_9, false);\n\tRZ_FREE(VAR_2);\n\n\t/* COMMENT_5 */\n\tVAR_8 = VAR_0->code_offset;\n\tVAR_9 = VAR_0->code_size;\n\tVAR_2 = rz_str_newf(\"%s.code\", VAR_4);\n\tluac_add_section(VAR_1->section_list, VAR_2, VAR_8, VAR_9, true);\n\tRZ_FREE(VAR_2);\n\n\t/* COMMENT_6 */\n\tVAR_8 = VAR_0->const_offset;\n\tVAR_9 = VAR_0->const_size;\n\tVAR_2 = rz_str_newf(\"%s.const\", VAR_4);\n\tluac_add_section(VAR_1->section_list, VAR_2, VAR_8, VAR_9, false);\n\tRZ_FREE(VAR_2);\n\n\t/* COMMENT_7 */\n\tVAR_8 = VAR_0->upvalue_offset;\n\tVAR_9 = VAR_0->upvalue_size;\n\tVAR_2 = rz_str_newf(\"%s.upvalues\", VAR_4);\n\tluac_add_section(VAR_1->section_list, VAR_2, VAR_8, VAR_9, false);\n\tRZ_FREE(VAR_2);\n\n\t/* COMMENT_8 */\n\tVAR_8 = VAR_0->inner_proto_offset;\n\tVAR_9 = VAR_0->inner_proto_size;\n\tVAR_2 = rz_str_newf(\"%s.protos\", VAR_4);\n\tluac_add_section(VAR_1->section_list, VAR_2, VAR_8, VAR_9, false);\n\tRZ_FREE(VAR_2);\n\n\t/* COMMENT_9 */\n\tVAR_8 = VAR_0->debug_offset;\n\tVAR_9 = VAR_0->debug_size;\n\tVAR_2 = rz_str_newf(\"%s.debug\", VAR_4);\n\tluac_add_section(VAR_1->section_list, VAR_2, VAR_8, VAR_9, false);\n\tRZ_FREE(VAR_2);\n\n\t/* COMMENT_10 */\n\tLuaLocalVarEntry *VAR_10;\n\trz_list_foreach (VAR_0->local_var_info_entries, VAR_6, VAR_10) {\n\t\tluac_add_string(\n\t\t\tVAR_1->string_list,\n\t\t\t(char *)VAR_10->varname,\n\t\t\tVAR_10->offset,\n\t\t\tVAR_10->varname_len);\n\t}\n\n\t/* COMMENT_11 */\n\tsize_t VAR_11 = rz_list_length(VAR_0->upvalue_entries);\n\tif (VAR_11 > 0) {\n\t\tLuaDbgUpvalueEntry *VAR_12;\n\t\tVAR_5 = RZ_NEWS0(char *, VAR_11);\n\t\tif (!VAR_5) {\n\t\t\tfree(VAR_4);\n\t\t\treturn;\n\t\t}\n\n\t\tVAR_7 = 0;\n\t\trz_list_foreach (VAR_0->dbg_upvalue_entries, VAR_6, VAR_12) {\n\t\t\tVAR_5[VAR_7] = (char *)VAR_12->upvalue_name;\n\t\t\tluac_add_string(\n\t\t\t\tVAR_1->string_list,\n\t\t\t\tVAR_5[VAR_7],\n\t\t\t\tVAR_12->offset,\n\t\t\t\tVAR_12->name_len);\n\t\t\tVAR_7++;\n\t\t}\n\t}\n\n\t/* COMMENT_12 */\n\tLuaConstEntry *VAR_13;\n\trz_list_foreach (VAR_0->const_entries, VAR_6, VAR_13) {\n\t\tVAR_3 = get_constant_symbol_name(VAR_4, VAR_13);\n\t\tluac_add_symbol(\n\t\t\tVAR_1->symbol_list,\n\t\t\tVAR_3,\n\t\t\tVAR_13->offset,\n\t\t\tVAR_13->data_len,\n\t\t\tget_tag_string(VAR_13->tag));\n\t\tif (VAR_13->tag == VAR_14 || VAR_13->tag == VAR_15) {\n\t\t\tluac_add_string(\n\t\t\t\tVAR_1->string_list,\n\t\t\t\t(char *)VAR_13->data,\n\t\t\t\tVAR_13->offset,\n\t\t\t\tVAR_13->data_len);\n\t\t}\n\t\tRZ_FREE(VAR_3);\n\t}\n\n\t/* COMMENT_13 */\n\tLuaUpvalueEntry *VAR_16;\n\tVAR_7 = 0;\n\trz_list_foreach (VAR_0->upvalue_entries, VAR_6, VAR_16) {\n\t\tVAR_3 = get_upvalue_symbol_name(VAR_4, VAR_16, VAR_5[VAR_7++]);\n\t\tluac_add_symbol(\n\t\t\tVAR_1->symbol_list,\n\t\t\tVAR_3,\n\t\t\tVAR_16->offset,\n\t\t\t3,\n\t\t\t\"UPVALUE\");\n\t\tRZ_FREE(VAR_3);\n\t}\n\n\t/* COMMENT_14 */\n\tLuaProto *VAR_17;\n\trz_list_foreach (VAR_0->proto_entries, VAR_6, VAR_17) {\n\t\t_luac_build_info(VAR_17, VAR_1);\n\t}\n\n\tfree(VAR_5);\n\tfree(VAR_4);\n}",
  "func_graph_path_before": "rizinorg/rizin/07b43bc8aa1ffebd9b68d60624c9610cf7e460c7/luac_bin.c/vul/before/0.json",
  "func": "void _luac_build_info(LuaProto *proto, LuacBinInfo *info) {\n\t/* process proto header info */\n\tchar *section_name;\n\tchar *symbol_name;\n\tchar *proto_name;\n\tchar **upvalue_names = NULL;\n\tRzListIter *iter;\n\tint i = 0; // iter\n\n\tut64 current_offset;\n\tut64 current_size;\n\n\t// 0. check if stripped (proto name is lost)\n\tif (proto->name_size == 0 || proto->proto_name == NULL) {\n\t\t// replace name with current offset\n\t\tproto_name = rz_str_newf(\"fcn.%08llx\", proto->offset);\n\t} else {\n\t\tproto_name = rz_str_new((char *)proto->proto_name);\n\t}\n\n\t// 1.1 set section name as function_name.header\n\tcurrent_offset = proto->offset;\n\tcurrent_size = proto->size;\n\tsection_name = rz_str_newf(\"%s.header\", proto_name);\n\tluac_add_section(info->section_list, section_name, current_offset, current_size, false);\n\tRZ_FREE(section_name);\n\n\t// 1.2 set section name as function_name.code\n\tcurrent_offset = proto->code_offset;\n\tcurrent_size = proto->code_size;\n\tsection_name = rz_str_newf(\"%s.code\", proto_name);\n\tluac_add_section(info->section_list, section_name, current_offset, current_size, true);\n\tRZ_FREE(section_name);\n\n\t// 1.3 set const section\n\tcurrent_offset = proto->const_offset;\n\tcurrent_size = proto->const_size;\n\tsection_name = rz_str_newf(\"%s.const\", proto_name);\n\tluac_add_section(info->section_list, section_name, current_offset, current_size, false);\n\tRZ_FREE(section_name);\n\n\t// 1.4 upvalue section\n\tcurrent_offset = proto->upvalue_offset;\n\tcurrent_size = proto->upvalue_size;\n\tsection_name = rz_str_newf(\"%s.upvalues\", proto_name);\n\tluac_add_section(info->section_list, section_name, current_offset, current_size, false);\n\tRZ_FREE(section_name);\n\n\t// 1.5 inner protos section\n\tcurrent_offset = proto->inner_proto_offset;\n\tcurrent_size = proto->inner_proto_size;\n\tsection_name = rz_str_newf(\"%s.protos\", proto_name);\n\tluac_add_section(info->section_list, section_name, current_offset, current_size, false);\n\tRZ_FREE(section_name);\n\n\t// 1.6 debug section\n\tcurrent_offset = proto->debug_offset;\n\tcurrent_size = proto->debug_size;\n\tsection_name = rz_str_newf(\"%s.debug\", proto_name);\n\tluac_add_section(info->section_list, section_name, current_offset, current_size, false);\n\tRZ_FREE(section_name);\n\n\t// 2.1 parse local var info\n\tLuaLocalVarEntry *local_var_entry;\n\trz_list_foreach (proto->local_var_info_entries, iter, local_var_entry) {\n\t\tluac_add_string(\n\t\t\tinfo->string_list,\n\t\t\t(char *)local_var_entry->varname,\n\t\t\tlocal_var_entry->offset,\n\t\t\tlocal_var_entry->varname_len);\n\t}\n\n\t// 2.2 parse debug_upvalues\n\tsize_t real_upvalue_cnt = RZ_MAX(rz_list_length(proto->upvalue_entries), rz_list_length(proto->dbg_upvalue_entries));\n\tif (real_upvalue_cnt > 0) {\n\t\tLuaDbgUpvalueEntry *debug_upv_entry;\n\t\tupvalue_names = RZ_NEWS0(char *, real_upvalue_cnt);\n\t\tif (!upvalue_names) {\n\t\t\tfree(proto_name);\n\t\t\treturn;\n\t\t}\n\n\t\ti = 0;\n\t\trz_list_foreach (proto->dbg_upvalue_entries, iter, debug_upv_entry) {\n\t\t\tupvalue_names[i] = (char *)debug_upv_entry->upvalue_name;\n\t\t\tluac_add_string(\n\t\t\t\tinfo->string_list,\n\t\t\t\tupvalue_names[i],\n\t\t\t\tdebug_upv_entry->offset,\n\t\t\t\tdebug_upv_entry->name_len);\n\t\t\ti++;\n\t\t}\n\t}\n\n\t// 3.1 construct constant symbols\n\tLuaConstEntry *const_entry;\n\trz_list_foreach (proto->const_entries, iter, const_entry) {\n\t\tsymbol_name = get_constant_symbol_name(proto_name, const_entry);\n\t\tif (!symbol_name) {\n\t\t\tcontinue;\n\t\t}\n\t\tluac_add_symbol(\n\t\t\tinfo->symbol_list,\n\t\t\tsymbol_name,\n\t\t\tconst_entry->offset,\n\t\t\tconst_entry->data_len,\n\t\t\tget_tag_string(const_entry->tag));\n\t\tif (const_entry->tag == LUA_VLNGSTR || const_entry->tag == LUA_VSHRSTR) {\n\t\t\tluac_add_string(\n\t\t\t\tinfo->string_list,\n\t\t\t\t(char *)const_entry->data,\n\t\t\t\tconst_entry->offset,\n\t\t\t\tconst_entry->data_len);\n\t\t}\n\t\tRZ_FREE(symbol_name);\n\t}\n\n\t// 3.2 construct upvalue symbols\n\tLuaUpvalueEntry *upvalue_entry;\n\ti = 0;\n\trz_list_foreach (proto->upvalue_entries, iter, upvalue_entry) {\n\t\tsymbol_name = get_upvalue_symbol_name(proto_name, upvalue_entry, upvalue_names[i++]);\n\t\tluac_add_symbol(\n\t\t\tinfo->symbol_list,\n\t\t\tsymbol_name,\n\t\t\tupvalue_entry->offset,\n\t\t\t3,\n\t\t\t\"UPVALUE\");\n\t\tRZ_FREE(symbol_name);\n\t}\n\n\t// 4. parse sub proto\n\tLuaProto *sub_proto;\n\trz_list_foreach (proto->proto_entries, iter, sub_proto) {\n\t\t_luac_build_info(sub_proto, info);\n\t}\n\n\tfree(upvalue_names);\n\tfree(proto_name);\n}",
  "abstract_func": "void _luac_build_info(LuaProto *VAR_0, LuacBinInfo *VAR_1) {\n\t/* COMMENT_0 */\n\tchar *VAR_2;\n\tchar *VAR_3;\n\tchar *VAR_4;\n\tchar **VAR_5 = NULL;\n\tRzListIter *VAR_6;\n\tint VAR_7 = 0; /* COMMENT_1 */\n\n\tut64 VAR_8;\n\tut64 VAR_9;\n\n\t/* COMMENT_2 */\n\tif (VAR_0->name_size == 0 || VAR_0->proto_name == NULL) {\n\t\t/* COMMENT_3 */\n\t\tVAR_4 = rz_str_newf(\"fcn.%08llx\", VAR_0->offset);\n\t} else {\n\t\tVAR_4 = rz_str_new((char *)VAR_0->proto_name);\n\t}\n\n\t/* COMMENT_4 */\n\tVAR_8 = VAR_0->offset;\n\tVAR_9 = VAR_0->size;\n\tVAR_2 = rz_str_newf(\"%s.header\", VAR_4);\n\tluac_add_section(VAR_1->section_list, VAR_2, VAR_8, VAR_9, false);\n\tRZ_FREE(VAR_2);\n\n\t/* COMMENT_5 */\n\tVAR_8 = VAR_0->code_offset;\n\tVAR_9 = VAR_0->code_size;\n\tVAR_2 = rz_str_newf(\"%s.code\", VAR_4);\n\tluac_add_section(VAR_1->section_list, VAR_2, VAR_8, VAR_9, true);\n\tRZ_FREE(VAR_2);\n\n\t/* COMMENT_6 */\n\tVAR_8 = VAR_0->const_offset;\n\tVAR_9 = VAR_0->const_size;\n\tVAR_2 = rz_str_newf(\"%s.const\", VAR_4);\n\tluac_add_section(VAR_1->section_list, VAR_2, VAR_8, VAR_9, false);\n\tRZ_FREE(VAR_2);\n\n\t/* COMMENT_7 */\n\tVAR_8 = VAR_0->upvalue_offset;\n\tVAR_9 = VAR_0->upvalue_size;\n\tVAR_2 = rz_str_newf(\"%s.upvalues\", VAR_4);\n\tluac_add_section(VAR_1->section_list, VAR_2, VAR_8, VAR_9, false);\n\tRZ_FREE(VAR_2);\n\n\t/* COMMENT_8 */\n\tVAR_8 = VAR_0->inner_proto_offset;\n\tVAR_9 = VAR_0->inner_proto_size;\n\tVAR_2 = rz_str_newf(\"%s.protos\", VAR_4);\n\tluac_add_section(VAR_1->section_list, VAR_2, VAR_8, VAR_9, false);\n\tRZ_FREE(VAR_2);\n\n\t/* COMMENT_9 */\n\tVAR_8 = VAR_0->debug_offset;\n\tVAR_9 = VAR_0->debug_size;\n\tVAR_2 = rz_str_newf(\"%s.debug\", VAR_4);\n\tluac_add_section(VAR_1->section_list, VAR_2, VAR_8, VAR_9, false);\n\tRZ_FREE(VAR_2);\n\n\t/* COMMENT_10 */\n\tLuaLocalVarEntry *VAR_10;\n\trz_list_foreach (VAR_0->local_var_info_entries, VAR_6, VAR_10) {\n\t\tluac_add_string(\n\t\t\tVAR_1->string_list,\n\t\t\t(char *)VAR_10->varname,\n\t\t\tVAR_10->offset,\n\t\t\tVAR_10->varname_len);\n\t}\n\n\t/* COMMENT_11 */\n\tsize_t VAR_11 = RZ_MAX(rz_list_length(VAR_0->upvalue_entries), rz_list_length(VAR_0->dbg_upvalue_entries));\n\tif (VAR_11 > 0) {\n\t\tLuaDbgUpvalueEntry *VAR_12;\n\t\tVAR_5 = RZ_NEWS0(char *, VAR_11);\n\t\tif (!VAR_5) {\n\t\t\tfree(VAR_4);\n\t\t\treturn;\n\t\t}\n\n\t\tVAR_7 = 0;\n\t\trz_list_foreach (VAR_0->dbg_upvalue_entries, VAR_6, VAR_12) {\n\t\t\tVAR_5[VAR_7] = (char *)VAR_12->upvalue_name;\n\t\t\tluac_add_string(\n\t\t\t\tVAR_1->string_list,\n\t\t\t\tVAR_5[VAR_7],\n\t\t\t\tVAR_12->offset,\n\t\t\t\tVAR_12->name_len);\n\t\t\tVAR_7++;\n\t\t}\n\t}\n\n\t/* COMMENT_12 */\n\tLuaConstEntry *VAR_13;\n\trz_list_foreach (VAR_0->const_entries, VAR_6, VAR_13) {\n\t\tVAR_3 = get_constant_symbol_name(VAR_4, VAR_13);\n\t\tif (!VAR_3) {\n\t\t\tcontinue;\n\t\t}\n\t\tluac_add_symbol(\n\t\t\tVAR_1->symbol_list,\n\t\t\tVAR_3,\n\t\t\tVAR_13->offset,\n\t\t\tVAR_13->data_len,\n\t\t\tget_tag_string(VAR_13->tag));\n\t\tif (VAR_13->tag == VAR_14 || VAR_13->tag == VAR_15) {\n\t\t\tluac_add_string(\n\t\t\t\tVAR_1->string_list,\n\t\t\t\t(char *)VAR_13->data,\n\t\t\t\tVAR_13->offset,\n\t\t\t\tVAR_13->data_len);\n\t\t}\n\t\tRZ_FREE(VAR_3);\n\t}\n\n\t/* COMMENT_13 */\n\tLuaUpvalueEntry *VAR_16;\n\tVAR_7 = 0;\n\trz_list_foreach (VAR_0->upvalue_entries, VAR_6, VAR_16) {\n\t\tVAR_3 = get_upvalue_symbol_name(VAR_4, VAR_16, VAR_5[VAR_7++]);\n\t\tluac_add_symbol(\n\t\t\tVAR_1->symbol_list,\n\t\t\tVAR_3,\n\t\t\tVAR_16->offset,\n\t\t\t3,\n\t\t\t\"UPVALUE\");\n\t\tRZ_FREE(VAR_3);\n\t}\n\n\t/* COMMENT_14 */\n\tLuaProto *VAR_17;\n\trz_list_foreach (VAR_0->proto_entries, VAR_6, VAR_17) {\n\t\t_luac_build_info(VAR_17, VAR_1);\n\t}\n\n\tfree(VAR_5);\n\tfree(VAR_4);\n}",
  "func_graph_path": "rizinorg/rizin/07b43bc8aa1ffebd9b68d60624c9610cf7e460c7/luac_bin.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -71,7 +71,7 @@\n \t}\n \n \t// 2.2 parse debug_upvalues\n-\tsize_t real_upvalue_cnt = rz_list_length(proto->upvalue_entries);\n+\tsize_t real_upvalue_cnt = RZ_MAX(rz_list_length(proto->upvalue_entries), rz_list_length(proto->dbg_upvalue_entries));\n \tif (real_upvalue_cnt > 0) {\n \t\tLuaDbgUpvalueEntry *debug_upv_entry;\n \t\tupvalue_names = RZ_NEWS0(char *, real_upvalue_cnt);\n@@ -96,6 +96,9 @@\n \tLuaConstEntry *const_entry;\n \trz_list_foreach (proto->const_entries, iter, const_entry) {\n \t\tsymbol_name = get_constant_symbol_name(proto_name, const_entry);\n+\t\tif (!symbol_name) {\n+\t\t\tcontinue;\n+\t\t}\n \t\tluac_add_symbol(\n \t\t\tinfo->symbol_list,\n \t\t\tsymbol_name,",
  "diff_line_info": {
    "deleted_lines": [
      "\tsize_t real_upvalue_cnt = rz_list_length(proto->upvalue_entries);"
    ],
    "added_lines": [
      "\tsize_t real_upvalue_cnt = RZ_MAX(rz_list_length(proto->upvalue_entries), rz_list_length(proto->dbg_upvalue_entries));",
      "\t\tif (!symbol_name) {",
      "\t\t\tcontinue;",
      "\t\t}"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/rizinorg/rizin/pull/2940",
  "description": {
    "pr_info": {
      "title": "Fix 2935 and 2936",
      "number": 2940
    },
    "comment": [
      "# DO NOT SQUASH\r\n\r\n**Your checklist for this pull request**\r\n- [ ] I've read the [guidelines for contributing](https://github.com/rizinorg/rizin/blob/master/DEVELOPERS.md) to this repository\r\n- [ ] I made sure to follow the project's [coding style](https://github.com/rizinorg/rizin/blob/master/DEVELOPERS.md#code-style)\r\n- [ ] I've documented or updated the documentation of every function and struct this PR changes. If not so I've explained why.\r\n- [ ] I've added tests that prove my fix is effective or that my feature works (if possible)\r\n- [ ] I've updated the [rizin book](https://github.com/rizinorg/book) with the relevant information (if needed)\r\n\r\n**Detailed description**\r\n\r\nFix #2935 \r\nFix #2936",
      "@kobrineli i cannot reproduce the heap overflow after i have fixed the integer overflow, but please confirm it if you can.",
      "@wargio Can't reproduce issue #2935, but still can reproduce out of bounds on `memmove` from #2936 on the same input that I sent to you by email.",
      "> @wargio Can't reproduce issue #2935, but still can reproduce out of bounds on `memmove` from #2936 on the same input that I sent to you by email.\r\n\r\nI cannot\r\n![image](https://user-images.githubusercontent.com/561184/185769291-0e080668-7476-4579-9a23-e99d9392a66e.png)\r\n",
      "I have refactored bin_sym plugin since it was a bit messy and added some checks. try again with these changes.",
      "Your fix will be beneficial also for https://github.com/rizinorg/rizin/issues/297",
      "@wargio Checked, now it works fine"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses an out-of-bounds read vulnerability in the `luac_build_info` function. The code changes ensure that the count of upvalue entries is correctly calculated to prevent accessing memory beyond its allocated bounds, which could lead to data corruption or crashes. The additional null check prevents potential null pointer dereferences. Both changes are aimed at fixing security issues.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 1.0"
}