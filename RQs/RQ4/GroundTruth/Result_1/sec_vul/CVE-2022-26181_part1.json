{
  "cve_id": "CVE-2022-26181",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "dropbox/lepton",
  "commit_msg": "Fix wild free.\n\n`huffdata` is initially allocated using `aligned_dealloc` but can be\nreplaced with `data2` which is allocated using `custom_calloc`.\nThis can cause a wild free when `aligned_dealloc(huffdata)` is called.\nFix by replacing allocation sites with aligned_alloc.\n\nNoticed and fixed a similar problem with `hdrdata`.",
  "commit_hash": "4e591ffd0127ac064c4749e523458a923b29cc75",
  "git_url": "https://github.com/dropbox/lepton/commit/4e591ffd0127ac064c4749e523458a923b29cc75",
  "file_path": "src/lepton/bitops.cc",
  "func_name": "abitwriter::abitwriter",
  "func_before": "abitwriter::abitwriter( int size , int max_file_size)\n{\n    size_bound = max_file_size;\n    if (size_bound) {\n        size_bound += 8; // 64 bits of padding on the end\n    }\n    fillbit = 1;\n    adds    = 65536;\n    cbyte2   = 0;\n    cbit2    = 64;\n    buf = 0;\n\n    error = false;\n    fmem  = true;\n    dsize = ( size > 0 ) ? size : adds;\n    data2 = ( unsigned char* ) custom_calloc (dsize);\n    if ( data2 == NULL ) {\n        error = true;\n        custom_exit(ExitCode::MALLOCED_NULL);\n        return;\n    }\n\t// for ( int i = 0; i < dsize; i++ ) data[i] = 0;\n}",
  "abstract_func_before": "abitwriter::abitwriter( int VAR_0 , int VAR_1)\n{\n    VAR_2 = VAR_1;\n    if (VAR_2) {\n        VAR_2 += 8; /* COMMENT_0 */\n    }\n    VAR_3 = 1;\n    VAR_4    = 65536;\n    VAR_5   = 0;\n    VAR_6    = 64;\n    VAR_7 = 0;\n\n    VAR_8 = false;\n    VAR_9  = true;\n    VAR_10 = ( VAR_0 > 0 ) ? VAR_0 : VAR_4;\n    VAR_11 = ( unsigned char* ) custom_calloc (VAR_10);\n    if ( VAR_11 == NULL ) {\n        VAR_8 = true;\n        custom_exit(ExitCode::MALLOCED_NULL);\n        return;\n    }\n\t/* COMMENT_1 */\n}",
  "func_graph_path_before": "dropbox/lepton/4e591ffd0127ac064c4749e523458a923b29cc75/bitops.cc/vul/before/0.json",
  "func": "abitwriter::abitwriter( int size , int max_file_size)\n{\n    size_bound = max_file_size;\n    if (size_bound) {\n        size_bound += 8; // 64 bits of padding on the end\n    }\n    fillbit = 1;\n    adds    = 65536;\n    cbyte2   = 0;\n    cbit2    = 64;\n    buf = 0;\n\n    error = false;\n    fmem  = true;\n    dsize = ( size > 0 ) ? size : adds;\n    data2 = aligned_alloc(dsize);\n    if ( data2 == NULL ) {\n        error = true;\n        custom_exit(ExitCode::MALLOCED_NULL);\n        return;\n    }\n\t// for ( int i = 0; i < dsize; i++ ) data[i] = 0;\n}",
  "abstract_func": "abitwriter::abitwriter( int VAR_0 , int VAR_1)\n{\n    VAR_2 = VAR_1;\n    if (VAR_2) {\n        VAR_2 += 8; /* COMMENT_0 */\n    }\n    VAR_3 = 1;\n    VAR_4    = 65536;\n    VAR_5   = 0;\n    VAR_6    = 64;\n    VAR_7 = 0;\n\n    VAR_8 = false;\n    VAR_9  = true;\n    VAR_10 = ( VAR_0 > 0 ) ? VAR_0 : VAR_4;\n    VAR_11 = aligned_alloc(VAR_10);\n    if ( VAR_11 == NULL ) {\n        VAR_8 = true;\n        custom_exit(ExitCode::MALLOCED_NULL);\n        return;\n    }\n\t/* COMMENT_1 */\n}",
  "func_graph_path": "dropbox/lepton/4e591ffd0127ac064c4749e523458a923b29cc75/bitops.cc/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -13,7 +13,7 @@\n     error = false;\n     fmem  = true;\n     dsize = ( size > 0 ) ? size : adds;\n-    data2 = ( unsigned char* ) custom_calloc (dsize);\n+    data2 = aligned_alloc(dsize);\n     if ( data2 == NULL ) {\n         error = true;\n         custom_exit(ExitCode::MALLOCED_NULL);",
  "diff_line_info": {
    "deleted_lines": [
      "    data2 = ( unsigned char* ) custom_calloc (dsize);"
    ],
    "added_lines": [
      "    data2 = aligned_alloc(dsize);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/dropbox/lepton/pull/155",
  "description": {
    "pr_info": {
      "title": "Fix wild free.",
      "number": 155
    },
    "comment": [
      "`huffdata` is initially allocated using `aligned_dealloc` but can be\r\nreplaced with `data2` which is allocated using `custom_calloc`.\r\nThis can cause a wild free when `aligned_dealloc(huffdata)` is called.\r\nFix by replacing allocation sites with aligned_alloc.\r\n\r\nNoticed and fixed a similar problem with `hdrdata`.\r\n\r\nFixes #154."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix\n\nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses a memory corruption issue where a wild free could occur due to mismatched allocation and deallocation methods. The fix ensures proper memory management by aligning allocation methods, preventing potential security exploits.\n\nFinal Classification: Security Vulnerability Fix\n\nConfidence Score: 1.0"
}