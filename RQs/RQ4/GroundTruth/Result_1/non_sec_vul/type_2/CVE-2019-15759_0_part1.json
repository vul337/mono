{
  "cve_id": "CVE-2019-15759",
  "cwe_ids": [
    "CWE-476"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "WebAssembly/binaryen",
  "commit_msg": "Copying fixes (#2289)\n\nWe didn't have an OverriddenVisitor in the copying code, and sadly unimplemented visitors just return null. That explains the crash in #2288\r\n\r\nThe missing visitors were push and pop.",
  "commit_hash": "ab3a1f65fb9d2e4ec7e2640daca0b3953a030da6",
  "git_url": "https://github.com/WebAssembly/binaryen/commit/ab3a1f65fb9d2e4ec7e2640daca0b3953a030da6",
  "file_path": "src/ir/ExpressionManipulator.cpp",
  "func_name": "flexibleCopy",
  "func_before": "Expression*\nflexibleCopy(Expression* original, Module& wasm, CustomCopier custom) {\n  struct Copier : public Visitor<Copier, Expression*> {\n    Module& wasm;\n    CustomCopier custom;\n\n    Builder builder;\n\n    Copier(Module& wasm, CustomCopier custom)\n      : wasm(wasm), custom(custom), builder(wasm) {}\n\n    Expression* copy(Expression* curr) {\n      if (!curr) {\n        return nullptr;\n      }\n      auto* ret = custom(curr);\n      if (ret) {\n        return ret;\n      }\n      return Visitor<Copier, Expression*>::visit(curr);\n    }\n\n    Expression* visitBlock(Block* curr) {\n      ExpressionList list(wasm.allocator);\n      for (Index i = 0; i < curr->list.size(); i++) {\n        list.push_back(copy(curr->list[i]));\n      }\n      return builder.makeBlock(curr->name, list, curr->type);\n    }\n    Expression* visitIf(If* curr) {\n      return builder.makeIf(copy(curr->condition),\n                            copy(curr->ifTrue),\n                            copy(curr->ifFalse),\n                            curr->type);\n    }\n    Expression* visitLoop(Loop* curr) {\n      return builder.makeLoop(curr->name, copy(curr->body));\n    }\n    Expression* visitBreak(Break* curr) {\n      return builder.makeBreak(\n        curr->name, copy(curr->value), copy(curr->condition));\n    }\n    Expression* visitSwitch(Switch* curr) {\n      return builder.makeSwitch(curr->targets,\n                                curr->default_,\n                                copy(curr->condition),\n                                copy(curr->value));\n    }\n    Expression* visitCall(Call* curr) {\n      auto* ret =\n        builder.makeCall(curr->target, {}, curr->type, curr->isReturn);\n      for (Index i = 0; i < curr->operands.size(); i++) {\n        ret->operands.push_back(copy(curr->operands[i]));\n      }\n      return ret;\n    }\n    Expression* visitCallIndirect(CallIndirect* curr) {\n      auto* ret = builder.makeCallIndirect(\n        curr->fullType, copy(curr->target), {}, curr->type, curr->isReturn);\n      for (Index i = 0; i < curr->operands.size(); i++) {\n        ret->operands.push_back(copy(curr->operands[i]));\n      }\n      return ret;\n    }\n    Expression* visitLocalGet(LocalGet* curr) {\n      return builder.makeLocalGet(curr->index, curr->type);\n    }\n    Expression* visitLocalSet(LocalSet* curr) {\n      if (curr->isTee()) {\n        return builder.makeLocalTee(curr->index, copy(curr->value));\n      } else {\n        return builder.makeLocalSet(curr->index, copy(curr->value));\n      }\n    }\n    Expression* visitGlobalGet(GlobalGet* curr) {\n      return builder.makeGlobalGet(curr->name, curr->type);\n    }\n    Expression* visitGlobalSet(GlobalSet* curr) {\n      return builder.makeGlobalSet(curr->name, copy(curr->value));\n    }\n    Expression* visitLoad(Load* curr) {\n      if (curr->isAtomic) {\n        return builder.makeAtomicLoad(\n          curr->bytes, curr->offset, copy(curr->ptr), curr->type);\n      }\n      return builder.makeLoad(curr->bytes,\n                              LoadUtils::isSignRelevant(curr) ? curr->signed_\n                                                              : false,\n                              curr->offset,\n                              curr->align,\n                              copy(curr->ptr),\n                              curr->type);\n    }\n    Expression* visitStore(Store* curr) {\n      if (curr->isAtomic) {\n        return builder.makeAtomicStore(curr->bytes,\n                                       curr->offset,\n                                       copy(curr->ptr),\n                                       copy(curr->value),\n                                       curr->valueType);\n      }\n      return builder.makeStore(curr->bytes,\n                               curr->offset,\n                               curr->align,\n                               copy(curr->ptr),\n                               copy(curr->value),\n                               curr->valueType);\n    }\n    Expression* visitAtomicRMW(AtomicRMW* curr) {\n      return builder.makeAtomicRMW(curr->op,\n                                   curr->bytes,\n                                   curr->offset,\n                                   copy(curr->ptr),\n                                   copy(curr->value),\n                                   curr->type);\n    }\n    Expression* visitAtomicCmpxchg(AtomicCmpxchg* curr) {\n      return builder.makeAtomicCmpxchg(curr->bytes,\n                                       curr->offset,\n                                       copy(curr->ptr),\n                                       copy(curr->expected),\n                                       copy(curr->replacement),\n                                       curr->type);\n    }\n    Expression* visitAtomicWait(AtomicWait* curr) {\n      return builder.makeAtomicWait(copy(curr->ptr),\n                                    copy(curr->expected),\n                                    copy(curr->timeout),\n                                    curr->expectedType,\n                                    curr->offset);\n    }\n    Expression* visitAtomicNotify(AtomicNotify* curr) {\n      return builder.makeAtomicNotify(\n        copy(curr->ptr), copy(curr->notifyCount), curr->offset);\n    }\n    Expression* visitSIMDExtract(SIMDExtract* curr) {\n      return builder.makeSIMDExtract(curr->op, copy(curr->vec), curr->index);\n    }\n    Expression* visitSIMDReplace(SIMDReplace* curr) {\n      return builder.makeSIMDReplace(\n        curr->op, copy(curr->vec), curr->index, copy(curr->value));\n    }\n    Expression* visitSIMDShuffle(SIMDShuffle* curr) {\n      return builder.makeSIMDShuffle(\n        copy(curr->left), copy(curr->right), curr->mask);\n    }\n    Expression* visitSIMDBitselect(SIMDBitselect* curr) {\n      return builder.makeSIMDBitselect(\n        copy(curr->left), copy(curr->right), copy(curr->cond));\n    }\n    Expression* visitSIMDShift(SIMDShift* curr) {\n      return builder.makeSIMDShift(\n        curr->op, copy(curr->vec), copy(curr->shift));\n    }\n    Expression* visitConst(Const* curr) {\n      return builder.makeConst(curr->value);\n    }\n    Expression* visitMemoryInit(MemoryInit* curr) {\n      return builder.makeMemoryInit(\n        curr->segment, copy(curr->dest), copy(curr->offset), copy(curr->size));\n    }\n    Expression* visitDataDrop(DataDrop* curr) {\n      return builder.makeDataDrop(curr->segment);\n    }\n    Expression* visitMemoryCopy(MemoryCopy* curr) {\n      return builder.makeMemoryCopy(\n        copy(curr->dest), copy(curr->source), copy(curr->size));\n    }\n    Expression* visitMemoryFill(MemoryFill* curr) {\n      return builder.makeMemoryFill(\n        copy(curr->dest), copy(curr->value), copy(curr->size));\n    }\n    Expression* visitUnary(Unary* curr) {\n      return builder.makeUnary(curr->op, copy(curr->value));\n    }\n    Expression* visitBinary(Binary* curr) {\n      return builder.makeBinary(curr->op, copy(curr->left), copy(curr->right));\n    }\n    Expression* visitSelect(Select* curr) {\n      return builder.makeSelect(\n        copy(curr->condition), copy(curr->ifTrue), copy(curr->ifFalse));\n    }\n    Expression* visitDrop(Drop* curr) {\n      return builder.makeDrop(copy(curr->value));\n    }\n    Expression* visitReturn(Return* curr) {\n      return builder.makeReturn(copy(curr->value));\n    }\n    Expression* visitHost(Host* curr) {\n      std::vector<Expression*> operands;\n      for (Index i = 0; i < curr->operands.size(); i++) {\n        operands.push_back(copy(curr->operands[i]));\n      }\n      auto* ret =\n        builder.makeHost(curr->op, curr->nameOperand, std::move(operands));\n      return ret;\n    }\n    Expression* visitNop(Nop* curr) { return builder.makeNop(); }\n    Expression* visitUnreachable(Unreachable* curr) {\n      return builder.makeUnreachable();\n    }\n  };\n\n  Copier copier(wasm, custom);\n  return copier.copy(original);\n}",
  "abstract_func_before": "Expression*\nflexibleCopy(Expression* VAR_0, Module& VAR_1, CustomCopier VAR_2) {\n  struct Copier : public Visitor<Copier, Expression*> {\n    Module& wasm;\n    CustomCopier custom;\n\n    Builder builder;\n\n    Copier(Module& VAR_1, CustomCopier VAR_2)\n      : wasm(VAR_1), custom(VAR_2), builder(VAR_1) {}\n\n    Expression* copy(Expression* VAR_3) {\n      if (!VAR_3) {\n        return nullptr;\n      }\n      auto* VAR_4 = VAR_2(VAR_3);\n      if (VAR_4) {\n        return VAR_4;\n      }\n      return Visitor<Copier, Expression*>::visit(VAR_3);\n    }\n\n    Expression* visitBlock(Block* VAR_3) {\n      ExpressionList VAR_5(VAR_1.allocator);\n      for (Index VAR_6 = 0; VAR_6 < VAR_3->list.size(); VAR_6++) {\n        VAR_5.push_back(copy(VAR_3->list[VAR_6]));\n      }\n      return VAR_7.makeBlock(VAR_3->name, VAR_5, VAR_3->type);\n    }\n    Expression* visitIf(If* VAR_3) {\n      return VAR_7.makeIf(copy(VAR_3->condition),\n                            copy(VAR_3->ifTrue),\n                            copy(VAR_3->ifFalse),\n                            VAR_3->type);\n    }\n    Expression* visitLoop(Loop* VAR_3) {\n      return VAR_7.makeLoop(VAR_3->name, copy(VAR_3->body));\n    }\n    Expression* visitBreak(Break* VAR_3) {\n      return VAR_7.makeBreak(\n        VAR_3->name, copy(VAR_3->value), copy(VAR_3->condition));\n    }\n    Expression* visitSwitch(Switch* VAR_3) {\n      return VAR_7.makeSwitch(VAR_3->targets,\n                                VAR_3->default_,\n                                copy(VAR_3->condition),\n                                copy(VAR_3->value));\n    }\n    Expression* visitCall(Call* VAR_3) {\n      auto* VAR_4 =\n        VAR_7.makeCall(VAR_3->target, {}, VAR_3->type, VAR_3->isReturn);\n      for (Index VAR_6 = 0; VAR_6 < VAR_3->operands.size(); VAR_6++) {\n        VAR_4->operands.push_back(copy(VAR_3->operands[VAR_6]));\n      }\n      return VAR_4;\n    }\n    Expression* visitCallIndirect(CallIndirect* VAR_3) {\n      auto* VAR_4 = VAR_7.makeCallIndirect(\n        VAR_3->fullType, copy(VAR_3->target), {}, VAR_3->type, VAR_3->isReturn);\n      for (Index VAR_6 = 0; VAR_6 < VAR_3->operands.size(); VAR_6++) {\n        VAR_4->operands.push_back(copy(VAR_3->operands[VAR_6]));\n      }\n      return VAR_4;\n    }\n    Expression* visitLocalGet(LocalGet* VAR_3) {\n      return VAR_7.makeLocalGet(VAR_3->index, VAR_3->type);\n    }\n    Expression* visitLocalSet(LocalSet* VAR_3) {\n      if (VAR_3->isTee()) {\n        return VAR_7.makeLocalTee(VAR_3->index, copy(VAR_3->value));\n      } else {\n        return VAR_7.makeLocalSet(VAR_3->index, copy(VAR_3->value));\n      }\n    }\n    Expression* visitGlobalGet(GlobalGet* VAR_3) {\n      return VAR_7.makeGlobalGet(VAR_3->name, VAR_3->type);\n    }\n    Expression* visitGlobalSet(GlobalSet* VAR_3) {\n      return VAR_7.makeGlobalSet(VAR_3->name, copy(VAR_3->value));\n    }\n    Expression* visitLoad(Load* VAR_3) {\n      if (VAR_3->isAtomic) {\n        return VAR_7.makeAtomicLoad(\n          VAR_3->bytes, VAR_3->offset, copy(VAR_3->ptr), VAR_3->type);\n      }\n      return VAR_7.makeLoad(VAR_3->bytes,\n                              LoadUtils::isSignRelevant(VAR_3) ? VAR_3->signed_\n                                                              : false,\n                              VAR_3->offset,\n                              VAR_3->align,\n                              copy(VAR_3->ptr),\n                              VAR_3->type);\n    }\n    Expression* visitStore(Store* VAR_3) {\n      if (VAR_3->isAtomic) {\n        return VAR_7.makeAtomicStore(VAR_3->bytes,\n                                       VAR_3->offset,\n                                       copy(VAR_3->ptr),\n                                       copy(VAR_3->value),\n                                       VAR_3->valueType);\n      }\n      return VAR_7.makeStore(VAR_3->bytes,\n                               VAR_3->offset,\n                               VAR_3->align,\n                               copy(VAR_3->ptr),\n                               copy(VAR_3->value),\n                               VAR_3->valueType);\n    }\n    Expression* visitAtomicRMW(AtomicRMW* VAR_3) {\n      return VAR_7.makeAtomicRMW(VAR_3->op,\n                                   VAR_3->bytes,\n                                   VAR_3->offset,\n                                   copy(VAR_3->ptr),\n                                   copy(VAR_3->value),\n                                   VAR_3->type);\n    }\n    Expression* visitAtomicCmpxchg(AtomicCmpxchg* VAR_3) {\n      return VAR_7.makeAtomicCmpxchg(VAR_3->bytes,\n                                       VAR_3->offset,\n                                       copy(VAR_3->ptr),\n                                       copy(VAR_3->expected),\n                                       copy(VAR_3->replacement),\n                                       VAR_3->type);\n    }\n    Expression* visitAtomicWait(AtomicWait* VAR_3) {\n      return VAR_7.makeAtomicWait(copy(VAR_3->ptr),\n                                    copy(VAR_3->expected),\n                                    copy(VAR_3->timeout),\n                                    VAR_3->expectedType,\n                                    VAR_3->offset);\n    }\n    Expression* visitAtomicNotify(AtomicNotify* VAR_3) {\n      return VAR_7.makeAtomicNotify(\n        copy(VAR_3->ptr), copy(VAR_3->notifyCount), VAR_3->offset);\n    }\n    Expression* visitSIMDExtract(SIMDExtract* VAR_3) {\n      return VAR_7.makeSIMDExtract(VAR_3->op, copy(VAR_3->vec), VAR_3->index);\n    }\n    Expression* visitSIMDReplace(SIMDReplace* VAR_3) {\n      return VAR_7.makeSIMDReplace(\n        VAR_3->op, copy(VAR_3->vec), VAR_3->index, copy(VAR_3->value));\n    }\n    Expression* visitSIMDShuffle(SIMDShuffle* VAR_3) {\n      return VAR_7.makeSIMDShuffle(\n        copy(VAR_3->left), copy(VAR_3->right), VAR_3->mask);\n    }\n    Expression* visitSIMDBitselect(SIMDBitselect* VAR_3) {\n      return VAR_7.makeSIMDBitselect(\n        copy(VAR_3->left), copy(VAR_3->right), copy(VAR_3->cond));\n    }\n    Expression* visitSIMDShift(SIMDShift* VAR_3) {\n      return VAR_7.makeSIMDShift(\n        VAR_3->op, copy(VAR_3->vec), copy(VAR_3->shift));\n    }\n    Expression* visitConst(Const* VAR_3) {\n      return VAR_7.makeConst(VAR_3->value);\n    }\n    Expression* visitMemoryInit(MemoryInit* VAR_3) {\n      return VAR_7.makeMemoryInit(\n        VAR_3->segment, copy(VAR_3->dest), copy(VAR_3->offset), copy(VAR_3->size));\n    }\n    Expression* visitDataDrop(DataDrop* VAR_3) {\n      return VAR_7.makeDataDrop(VAR_3->segment);\n    }\n    Expression* visitMemoryCopy(MemoryCopy* VAR_3) {\n      return VAR_7.makeMemoryCopy(\n        copy(VAR_3->dest), copy(VAR_3->source), copy(VAR_3->size));\n    }\n    Expression* visitMemoryFill(MemoryFill* VAR_3) {\n      return VAR_7.makeMemoryFill(\n        copy(VAR_3->dest), copy(VAR_3->value), copy(VAR_3->size));\n    }\n    Expression* visitUnary(Unary* VAR_3) {\n      return VAR_7.makeUnary(VAR_3->op, copy(VAR_3->value));\n    }\n    Expression* visitBinary(Binary* VAR_3) {\n      return VAR_7.makeBinary(VAR_3->op, copy(VAR_3->left), copy(VAR_3->right));\n    }\n    Expression* visitSelect(Select* VAR_3) {\n      return VAR_7.makeSelect(\n        copy(VAR_3->condition), copy(VAR_3->ifTrue), copy(VAR_3->ifFalse));\n    }\n    Expression* visitDrop(Drop* VAR_3) {\n      return VAR_7.makeDrop(copy(VAR_3->value));\n    }\n    Expression* visitReturn(Return* VAR_3) {\n      return VAR_7.makeReturn(copy(VAR_3->value));\n    }\n    Expression* visitHost(Host* VAR_3) {\n      std::vector<Expression*> VAR_8;\n      for (Index VAR_6 = 0; VAR_6 < VAR_3->operands.size(); VAR_6++) {\n        VAR_8.push_back(copy(VAR_3->operands[VAR_6]));\n      }\n      auto* VAR_4 =\n        VAR_7.makeHost(VAR_3->op, VAR_3->nameOperand, std::move(VAR_8));\n      return VAR_4;\n    }\n    Expression* visitNop(Nop* VAR_3) { return VAR_7.makeNop(); }\n    Expression* visitUnreachable(Unreachable* VAR_3) {\n      return VAR_7.makeUnreachable();\n    }\n  };\n\n  Copier copier(wasm, custom);\n  return VAR_9.copy(VAR_0);\n}",
  "func_graph_path_before": "WebAssembly/binaryen/ab3a1f65fb9d2e4ec7e2640daca0b3953a030da6/ExpressionManipulator.cpp/vul/before/0.json",
  "func": "Expression*\nflexibleCopy(Expression* original, Module& wasm, CustomCopier custom) {\n  struct Copier : public OverriddenVisitor<Copier, Expression*> {\n    Module& wasm;\n    CustomCopier custom;\n\n    Builder builder;\n\n    Copier(Module& wasm, CustomCopier custom)\n      : wasm(wasm), custom(custom), builder(wasm) {}\n\n    Expression* copy(Expression* curr) {\n      if (!curr) {\n        return nullptr;\n      }\n      auto* ret = custom(curr);\n      if (ret) {\n        return ret;\n      }\n      return OverriddenVisitor<Copier, Expression*>::visit(curr);\n    }\n\n    Expression* visitBlock(Block* curr) {\n      ExpressionList list(wasm.allocator);\n      for (Index i = 0; i < curr->list.size(); i++) {\n        list.push_back(copy(curr->list[i]));\n      }\n      return builder.makeBlock(curr->name, list, curr->type);\n    }\n    Expression* visitIf(If* curr) {\n      return builder.makeIf(copy(curr->condition),\n                            copy(curr->ifTrue),\n                            copy(curr->ifFalse),\n                            curr->type);\n    }\n    Expression* visitLoop(Loop* curr) {\n      return builder.makeLoop(curr->name, copy(curr->body));\n    }\n    Expression* visitBreak(Break* curr) {\n      return builder.makeBreak(\n        curr->name, copy(curr->value), copy(curr->condition));\n    }\n    Expression* visitSwitch(Switch* curr) {\n      return builder.makeSwitch(curr->targets,\n                                curr->default_,\n                                copy(curr->condition),\n                                copy(curr->value));\n    }\n    Expression* visitCall(Call* curr) {\n      auto* ret =\n        builder.makeCall(curr->target, {}, curr->type, curr->isReturn);\n      for (Index i = 0; i < curr->operands.size(); i++) {\n        ret->operands.push_back(copy(curr->operands[i]));\n      }\n      return ret;\n    }\n    Expression* visitCallIndirect(CallIndirect* curr) {\n      auto* ret = builder.makeCallIndirect(\n        curr->fullType, copy(curr->target), {}, curr->type, curr->isReturn);\n      for (Index i = 0; i < curr->operands.size(); i++) {\n        ret->operands.push_back(copy(curr->operands[i]));\n      }\n      return ret;\n    }\n    Expression* visitLocalGet(LocalGet* curr) {\n      return builder.makeLocalGet(curr->index, curr->type);\n    }\n    Expression* visitLocalSet(LocalSet* curr) {\n      if (curr->isTee()) {\n        return builder.makeLocalTee(curr->index, copy(curr->value));\n      } else {\n        return builder.makeLocalSet(curr->index, copy(curr->value));\n      }\n    }\n    Expression* visitGlobalGet(GlobalGet* curr) {\n      return builder.makeGlobalGet(curr->name, curr->type);\n    }\n    Expression* visitGlobalSet(GlobalSet* curr) {\n      return builder.makeGlobalSet(curr->name, copy(curr->value));\n    }\n    Expression* visitLoad(Load* curr) {\n      if (curr->isAtomic) {\n        return builder.makeAtomicLoad(\n          curr->bytes, curr->offset, copy(curr->ptr), curr->type);\n      }\n      return builder.makeLoad(curr->bytes,\n                              LoadUtils::isSignRelevant(curr) ? curr->signed_\n                                                              : false,\n                              curr->offset,\n                              curr->align,\n                              copy(curr->ptr),\n                              curr->type);\n    }\n    Expression* visitStore(Store* curr) {\n      if (curr->isAtomic) {\n        return builder.makeAtomicStore(curr->bytes,\n                                       curr->offset,\n                                       copy(curr->ptr),\n                                       copy(curr->value),\n                                       curr->valueType);\n      }\n      return builder.makeStore(curr->bytes,\n                               curr->offset,\n                               curr->align,\n                               copy(curr->ptr),\n                               copy(curr->value),\n                               curr->valueType);\n    }\n    Expression* visitAtomicRMW(AtomicRMW* curr) {\n      return builder.makeAtomicRMW(curr->op,\n                                   curr->bytes,\n                                   curr->offset,\n                                   copy(curr->ptr),\n                                   copy(curr->value),\n                                   curr->type);\n    }\n    Expression* visitAtomicCmpxchg(AtomicCmpxchg* curr) {\n      return builder.makeAtomicCmpxchg(curr->bytes,\n                                       curr->offset,\n                                       copy(curr->ptr),\n                                       copy(curr->expected),\n                                       copy(curr->replacement),\n                                       curr->type);\n    }\n    Expression* visitAtomicWait(AtomicWait* curr) {\n      return builder.makeAtomicWait(copy(curr->ptr),\n                                    copy(curr->expected),\n                                    copy(curr->timeout),\n                                    curr->expectedType,\n                                    curr->offset);\n    }\n    Expression* visitAtomicNotify(AtomicNotify* curr) {\n      return builder.makeAtomicNotify(\n        copy(curr->ptr), copy(curr->notifyCount), curr->offset);\n    }\n    Expression* visitSIMDExtract(SIMDExtract* curr) {\n      return builder.makeSIMDExtract(curr->op, copy(curr->vec), curr->index);\n    }\n    Expression* visitSIMDReplace(SIMDReplace* curr) {\n      return builder.makeSIMDReplace(\n        curr->op, copy(curr->vec), curr->index, copy(curr->value));\n    }\n    Expression* visitSIMDShuffle(SIMDShuffle* curr) {\n      return builder.makeSIMDShuffle(\n        copy(curr->left), copy(curr->right), curr->mask);\n    }\n    Expression* visitSIMDBitselect(SIMDBitselect* curr) {\n      return builder.makeSIMDBitselect(\n        copy(curr->left), copy(curr->right), copy(curr->cond));\n    }\n    Expression* visitSIMDShift(SIMDShift* curr) {\n      return builder.makeSIMDShift(\n        curr->op, copy(curr->vec), copy(curr->shift));\n    }\n    Expression* visitConst(Const* curr) {\n      return builder.makeConst(curr->value);\n    }\n    Expression* visitMemoryInit(MemoryInit* curr) {\n      return builder.makeMemoryInit(\n        curr->segment, copy(curr->dest), copy(curr->offset), copy(curr->size));\n    }\n    Expression* visitDataDrop(DataDrop* curr) {\n      return builder.makeDataDrop(curr->segment);\n    }\n    Expression* visitMemoryCopy(MemoryCopy* curr) {\n      return builder.makeMemoryCopy(\n        copy(curr->dest), copy(curr->source), copy(curr->size));\n    }\n    Expression* visitMemoryFill(MemoryFill* curr) {\n      return builder.makeMemoryFill(\n        copy(curr->dest), copy(curr->value), copy(curr->size));\n    }\n    Expression* visitUnary(Unary* curr) {\n      return builder.makeUnary(curr->op, copy(curr->value));\n    }\n    Expression* visitBinary(Binary* curr) {\n      return builder.makeBinary(curr->op, copy(curr->left), copy(curr->right));\n    }\n    Expression* visitSelect(Select* curr) {\n      return builder.makeSelect(\n        copy(curr->condition), copy(curr->ifTrue), copy(curr->ifFalse));\n    }\n    Expression* visitDrop(Drop* curr) {\n      return builder.makeDrop(copy(curr->value));\n    }\n    Expression* visitReturn(Return* curr) {\n      return builder.makeReturn(copy(curr->value));\n    }\n    Expression* visitHost(Host* curr) {\n      std::vector<Expression*> operands;\n      for (Index i = 0; i < curr->operands.size(); i++) {\n        operands.push_back(copy(curr->operands[i]));\n      }\n      auto* ret =\n        builder.makeHost(curr->op, curr->nameOperand, std::move(operands));\n      return ret;\n    }\n    Expression* visitNop(Nop* curr) { return builder.makeNop(); }\n    Expression* visitUnreachable(Unreachable* curr) {\n      return builder.makeUnreachable();\n    }\n    Expression* visitPush(Push* curr) { return builder.makePush(curr->value); }\n    Expression* visitPop(Pop* curr) { return builder.makePop(curr->type); }\n  };\n\n  Copier copier(wasm, custom);\n  return copier.copy(original);\n}",
  "abstract_func": "Expression*\nflexibleCopy(Expression* VAR_0, Module& VAR_1, CustomCopier VAR_2) {\n  struct Copier : public OverriddenVisitor<Copier, Expression*> {\n    Module& wasm;\n    CustomCopier custom;\n\n    Builder builder;\n\n    Copier(Module& VAR_1, CustomCopier VAR_2)\n      : wasm(VAR_1), custom(VAR_2), builder(VAR_1) {}\n\n    Expression* copy(Expression* VAR_3) {\n      if (!VAR_3) {\n        return nullptr;\n      }\n      auto* VAR_4 = VAR_2(VAR_3);\n      if (VAR_4) {\n        return VAR_4;\n      }\n      return OverriddenVisitor<Copier, Expression*>::visit(VAR_3);\n    }\n\n    Expression* visitBlock(Block* VAR_3) {\n      ExpressionList VAR_5(VAR_1.allocator);\n      for (Index VAR_6 = 0; VAR_6 < VAR_3->list.size(); VAR_6++) {\n        VAR_5.push_back(copy(VAR_3->list[VAR_6]));\n      }\n      return VAR_7.makeBlock(VAR_3->name, VAR_5, VAR_3->type);\n    }\n    Expression* visitIf(If* VAR_3) {\n      return VAR_7.makeIf(copy(VAR_3->condition),\n                            copy(VAR_3->ifTrue),\n                            copy(VAR_3->ifFalse),\n                            VAR_3->type);\n    }\n    Expression* visitLoop(Loop* VAR_3) {\n      return VAR_7.makeLoop(VAR_3->name, copy(VAR_3->body));\n    }\n    Expression* visitBreak(Break* VAR_3) {\n      return VAR_7.makeBreak(\n        VAR_3->name, copy(VAR_3->value), copy(VAR_3->condition));\n    }\n    Expression* visitSwitch(Switch* VAR_3) {\n      return VAR_7.makeSwitch(VAR_3->targets,\n                                VAR_3->default_,\n                                copy(VAR_3->condition),\n                                copy(VAR_3->value));\n    }\n    Expression* visitCall(Call* VAR_3) {\n      auto* VAR_4 =\n        VAR_7.makeCall(VAR_3->target, {}, VAR_3->type, VAR_3->isReturn);\n      for (Index VAR_6 = 0; VAR_6 < VAR_3->operands.size(); VAR_6++) {\n        VAR_4->operands.push_back(copy(VAR_3->operands[VAR_6]));\n      }\n      return VAR_4;\n    }\n    Expression* visitCallIndirect(CallIndirect* VAR_3) {\n      auto* VAR_4 = VAR_7.makeCallIndirect(\n        VAR_3->fullType, copy(VAR_3->target), {}, VAR_3->type, VAR_3->isReturn);\n      for (Index VAR_6 = 0; VAR_6 < VAR_3->operands.size(); VAR_6++) {\n        VAR_4->operands.push_back(copy(VAR_3->operands[VAR_6]));\n      }\n      return VAR_4;\n    }\n    Expression* visitLocalGet(LocalGet* VAR_3) {\n      return VAR_7.makeLocalGet(VAR_3->index, VAR_3->type);\n    }\n    Expression* visitLocalSet(LocalSet* VAR_3) {\n      if (VAR_3->isTee()) {\n        return VAR_7.makeLocalTee(VAR_3->index, copy(VAR_3->value));\n      } else {\n        return VAR_7.makeLocalSet(VAR_3->index, copy(VAR_3->value));\n      }\n    }\n    Expression* visitGlobalGet(GlobalGet* VAR_3) {\n      return VAR_7.makeGlobalGet(VAR_3->name, VAR_3->type);\n    }\n    Expression* visitGlobalSet(GlobalSet* VAR_3) {\n      return VAR_7.makeGlobalSet(VAR_3->name, copy(VAR_3->value));\n    }\n    Expression* visitLoad(Load* VAR_3) {\n      if (VAR_3->isAtomic) {\n        return VAR_7.makeAtomicLoad(\n          VAR_3->bytes, VAR_3->offset, copy(VAR_3->ptr), VAR_3->type);\n      }\n      return VAR_7.makeLoad(VAR_3->bytes,\n                              LoadUtils::isSignRelevant(VAR_3) ? VAR_3->signed_\n                                                              : false,\n                              VAR_3->offset,\n                              VAR_3->align,\n                              copy(VAR_3->ptr),\n                              VAR_3->type);\n    }\n    Expression* visitStore(Store* VAR_3) {\n      if (VAR_3->isAtomic) {\n        return VAR_7.makeAtomicStore(VAR_3->bytes,\n                                       VAR_3->offset,\n                                       copy(VAR_3->ptr),\n                                       copy(VAR_3->value),\n                                       VAR_3->valueType);\n      }\n      return VAR_7.makeStore(VAR_3->bytes,\n                               VAR_3->offset,\n                               VAR_3->align,\n                               copy(VAR_3->ptr),\n                               copy(VAR_3->value),\n                               VAR_3->valueType);\n    }\n    Expression* visitAtomicRMW(AtomicRMW* VAR_3) {\n      return VAR_7.makeAtomicRMW(VAR_3->op,\n                                   VAR_3->bytes,\n                                   VAR_3->offset,\n                                   copy(VAR_3->ptr),\n                                   copy(VAR_3->value),\n                                   VAR_3->type);\n    }\n    Expression* visitAtomicCmpxchg(AtomicCmpxchg* VAR_3) {\n      return VAR_7.makeAtomicCmpxchg(VAR_3->bytes,\n                                       VAR_3->offset,\n                                       copy(VAR_3->ptr),\n                                       copy(VAR_3->expected),\n                                       copy(VAR_3->replacement),\n                                       VAR_3->type);\n    }\n    Expression* visitAtomicWait(AtomicWait* VAR_3) {\n      return VAR_7.makeAtomicWait(copy(VAR_3->ptr),\n                                    copy(VAR_3->expected),\n                                    copy(VAR_3->timeout),\n                                    VAR_3->expectedType,\n                                    VAR_3->offset);\n    }\n    Expression* visitAtomicNotify(AtomicNotify* VAR_3) {\n      return VAR_7.makeAtomicNotify(\n        copy(VAR_3->ptr), copy(VAR_3->notifyCount), VAR_3->offset);\n    }\n    Expression* visitSIMDExtract(SIMDExtract* VAR_3) {\n      return VAR_7.makeSIMDExtract(VAR_3->op, copy(VAR_3->vec), VAR_3->index);\n    }\n    Expression* visitSIMDReplace(SIMDReplace* VAR_3) {\n      return VAR_7.makeSIMDReplace(\n        VAR_3->op, copy(VAR_3->vec), VAR_3->index, copy(VAR_3->value));\n    }\n    Expression* visitSIMDShuffle(SIMDShuffle* VAR_3) {\n      return VAR_7.makeSIMDShuffle(\n        copy(VAR_3->left), copy(VAR_3->right), VAR_3->mask);\n    }\n    Expression* visitSIMDBitselect(SIMDBitselect* VAR_3) {\n      return VAR_7.makeSIMDBitselect(\n        copy(VAR_3->left), copy(VAR_3->right), copy(VAR_3->cond));\n    }\n    Expression* visitSIMDShift(SIMDShift* VAR_3) {\n      return VAR_7.makeSIMDShift(\n        VAR_3->op, copy(VAR_3->vec), copy(VAR_3->shift));\n    }\n    Expression* visitConst(Const* VAR_3) {\n      return VAR_7.makeConst(VAR_3->value);\n    }\n    Expression* visitMemoryInit(MemoryInit* VAR_3) {\n      return VAR_7.makeMemoryInit(\n        VAR_3->segment, copy(VAR_3->dest), copy(VAR_3->offset), copy(VAR_3->size));\n    }\n    Expression* visitDataDrop(DataDrop* VAR_3) {\n      return VAR_7.makeDataDrop(VAR_3->segment);\n    }\n    Expression* visitMemoryCopy(MemoryCopy* VAR_3) {\n      return VAR_7.makeMemoryCopy(\n        copy(VAR_3->dest), copy(VAR_3->source), copy(VAR_3->size));\n    }\n    Expression* visitMemoryFill(MemoryFill* VAR_3) {\n      return VAR_7.makeMemoryFill(\n        copy(VAR_3->dest), copy(VAR_3->value), copy(VAR_3->size));\n    }\n    Expression* visitUnary(Unary* VAR_3) {\n      return VAR_7.makeUnary(VAR_3->op, copy(VAR_3->value));\n    }\n    Expression* visitBinary(Binary* VAR_3) {\n      return VAR_7.makeBinary(VAR_3->op, copy(VAR_3->left), copy(VAR_3->right));\n    }\n    Expression* visitSelect(Select* VAR_3) {\n      return VAR_7.makeSelect(\n        copy(VAR_3->condition), copy(VAR_3->ifTrue), copy(VAR_3->ifFalse));\n    }\n    Expression* visitDrop(Drop* VAR_3) {\n      return VAR_7.makeDrop(copy(VAR_3->value));\n    }\n    Expression* visitReturn(Return* VAR_3) {\n      return VAR_7.makeReturn(copy(VAR_3->value));\n    }\n    Expression* visitHost(Host* VAR_3) {\n      std::vector<Expression*> VAR_8;\n      for (Index VAR_6 = 0; VAR_6 < VAR_3->operands.size(); VAR_6++) {\n        VAR_8.push_back(copy(VAR_3->operands[VAR_6]));\n      }\n      auto* VAR_4 =\n        VAR_7.makeHost(VAR_3->op, VAR_3->nameOperand, std::move(VAR_8));\n      return VAR_4;\n    }\n    Expression* visitNop(Nop* VAR_3) { return VAR_7.makeNop(); }\n    Expression* visitUnreachable(Unreachable* VAR_3) {\n      return VAR_7.makeUnreachable();\n    }\n    Expression* visitPush(Push* VAR_3) { return VAR_7.makePush(VAR_3->value); }\n    Expression* visitPop(Pop* VAR_3) { return VAR_7.makePop(VAR_3->type); }\n  };\n\n  Copier copier(wasm, custom);\n  return VAR_9.copy(VAR_0);\n}",
  "func_graph_path": "WebAssembly/binaryen/ab3a1f65fb9d2e4ec7e2640daca0b3953a030da6/ExpressionManipulator.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n Expression*\n flexibleCopy(Expression* original, Module& wasm, CustomCopier custom) {\n-  struct Copier : public Visitor<Copier, Expression*> {\n+  struct Copier : public OverriddenVisitor<Copier, Expression*> {\n     Module& wasm;\n     CustomCopier custom;\n \n@@ -17,7 +17,7 @@\n       if (ret) {\n         return ret;\n       }\n-      return Visitor<Copier, Expression*>::visit(curr);\n+      return OverriddenVisitor<Copier, Expression*>::visit(curr);\n     }\n \n     Expression* visitBlock(Block* curr) {\n@@ -199,6 +199,8 @@\n     Expression* visitUnreachable(Unreachable* curr) {\n       return builder.makeUnreachable();\n     }\n+    Expression* visitPush(Push* curr) { return builder.makePush(curr->value); }\n+    Expression* visitPop(Pop* curr) { return builder.makePop(curr->type); }\n   };\n \n   Copier copier(wasm, custom);",
  "diff_line_info": {
    "deleted_lines": [
      "  struct Copier : public Visitor<Copier, Expression*> {",
      "      return Visitor<Copier, Expression*>::visit(curr);"
    ],
    "added_lines": [
      "  struct Copier : public OverriddenVisitor<Copier, Expression*> {",
      "      return OverriddenVisitor<Copier, Expression*>::visit(curr);",
      "    Expression* visitPush(Push* curr) { return builder.makePush(curr->value); }",
      "    Expression* visitPop(Pop* curr) { return builder.makePop(curr->type); }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/WebAssembly/binaryen/pull/2289",
  "description": {
    "pr_info": {
      "title": "Copying fixes",
      "number": 2289
    },
    "comment": [
      "We didn't have an OverriddenVisitor in the copying code, and sadly unimplemented visitors just return null. That explains the crash in https://github.com/WebAssembly/binaryen/issues/2288\r\n\r\nThe missing visitors were push and pop.\r\n"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "\n\nThe patch addresses a crash caused by missing visitor implementations, which was leading to null returns. While it's a bug fix, there's no explicit evidence that it resolves a security vulnerability.\n\n**Final Output:**\n\nAnalysis: The patch fixes a crash caused by missing visitor implementations, which were returning null. It changes the visitor type and adds the missing methods. The crash could potentially be triggered by certain inputs but isn't explicitly a security issue.\n\nFinal Classification: Defect Remediation & Feature Upgrades\nConfidence Score: 0.8"
}