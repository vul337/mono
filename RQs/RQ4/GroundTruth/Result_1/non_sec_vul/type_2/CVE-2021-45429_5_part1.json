{
  "cve_id": "CVE-2021-45429",
  "cwe_ids": [
    "CWE-120"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "VirusTotal/yara",
  "commit_msg": "Fix issue #1616\n\nThis is a more comprehensive fix than #1617, it adds new functions to the API for getting/setting uint32 and uint64 settings.  Using these functions is preferable over calling `yr_(get|set)_configuration` directly.",
  "commit_hash": "b34b7e74c862c129b801832b6b85401fbada2b01",
  "git_url": "https://github.com/VirusTotal/yara/commit/b34b7e74c862c129b801832b6b85401fbada2b01",
  "file_path": "libyara/proc/openbsd.c",
  "func_name": "yr_process_get_next_memory_block",
  "func_before": "YR_API YR_MEMORY_BLOCK* yr_process_get_next_memory_block(\n    YR_MEMORY_BLOCK_ITERATOR* iterator)\n{\n  YR_PROC_ITERATOR_CTX* context = (YR_PROC_ITERATOR_CTX*) iterator->context;\n  YR_PROC_INFO* proc_info = (YR_PROC_INFO*) context->proc_info;\n\n  int mib[] = {CTL_KERN, KERN_PROC_VMMAP, proc_info->pid};\n  size_t len = sizeof(struct kinfo_vmentry);\n\n  iterator->last_error = ERROR_SUCCESS;\n\n  uint64_t current_begin = context->current_block.base +\n                           context->current_block.size;\n\n  uint64_t max_process_memory_chunk;\n\n  yr_get_configuration(\n      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, (void*) &max_process_memory_chunk);\n\n  if (proc_info->old_end <= current_begin)\n  {\n    if (sysctl(mib, 3, &proc_info->vm_entry, &len, NULL, 0) < 0)\n      return NULL;\n\n    // no more blocks\n    if (proc_info->old_end == proc_info->vm_entry.kve_end)\n      return NULL;\n\n    current_begin = proc_info->vm_entry.kve_start;\n    proc_info->old_end = proc_info->vm_entry.kve_end;\n\n    proc_info->vm_entry.kve_start = proc_info->vm_entry.kve_start + 1;\n  }\n\n  context->current_block.base = current_begin;\n  context->current_block.size = yr_min(\n      proc_info->old_end - current_begin, max_process_memory_chunk);\n\n  assert(context->current_block.size > 0);\n\n  return &context->current_block;\n}",
  "abstract_func_before": "YR_API VAR_0* yr_process_get_next_memory_block(\n    YR_MEMORY_BLOCK_ITERATOR* VAR_1)\n{\n  YR_PROC_ITERATOR_CTX* VAR_2 = (YR_PROC_ITERATOR_CTX*) VAR_1->context;\n  YR_PROC_INFO* VAR_3 = (YR_PROC_INFO*) VAR_2->proc_info;\n\n  int VAR_4[] = {VAR_5, VAR_6, VAR_3->pid};\n  size_t VAR_7 = sizeof(struct kinfo_vmentry);\n\n  VAR_1->last_error = VAR_8;\n\n  uint64_t VAR_9 = VAR_2->current_block.base +\n                           VAR_2->current_block.size;\n\n  uint64_t VAR_10;\n\n  yr_get_configuration(\n      VAR_11, (void*) &VAR_10);\n\n  if (VAR_3->old_end <= VAR_9)\n  {\n    if (sysctl(VAR_4, 3, &VAR_3->vm_entry, &VAR_7, NULL, 0) < 0)\n      return NULL;\n\n    /* COMMENT_0 */\n    if (VAR_3->old_end == VAR_3->vm_entry.kve_end)\n      return NULL;\n\n    VAR_9 = VAR_3->vm_entry.kve_start;\n    VAR_3->old_end = VAR_3->vm_entry.kve_end;\n\n    VAR_3->vm_entry.kve_start = VAR_3->vm_entry.kve_start + 1;\n  }\n\n  VAR_2->current_block.base = VAR_9;\n  VAR_2->current_block.size = yr_min(\n      VAR_3->old_end - VAR_9, VAR_10);\n\n  assert(VAR_2->current_block.size > 0);\n\n  return &VAR_2->current_block;\n}",
  "func_graph_path_before": null,
  "func": "YR_API YR_MEMORY_BLOCK* yr_process_get_next_memory_block(\n    YR_MEMORY_BLOCK_ITERATOR* iterator)\n{\n  YR_PROC_ITERATOR_CTX* context = (YR_PROC_ITERATOR_CTX*) iterator->context;\n  YR_PROC_INFO* proc_info = (YR_PROC_INFO*) context->proc_info;\n\n  int mib[] = {CTL_KERN, KERN_PROC_VMMAP, proc_info->pid};\n  size_t len = sizeof(struct kinfo_vmentry);\n\n  iterator->last_error = ERROR_SUCCESS;\n\n  uint64_t current_begin = context->current_block.base +\n                           context->current_block.size;\n\n  uint64_t max_process_memory_chunk;\n\n  yr_get_configuration_uint64(\n      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, &max_process_memory_chunk);\n\n  if (proc_info->old_end <= current_begin)\n  {\n    if (sysctl(mib, 3, &proc_info->vm_entry, &len, NULL, 0) < 0)\n      return NULL;\n\n    // no more blocks\n    if (proc_info->old_end == proc_info->vm_entry.kve_end)\n      return NULL;\n\n    current_begin = proc_info->vm_entry.kve_start;\n    proc_info->old_end = proc_info->vm_entry.kve_end;\n\n    proc_info->vm_entry.kve_start = proc_info->vm_entry.kve_start + 1;\n  }\n\n  context->current_block.base = current_begin;\n  context->current_block.size = yr_min(\n      proc_info->old_end - current_begin, max_process_memory_chunk);\n\n  assert(context->current_block.size > 0);\n\n  return &context->current_block;\n}",
  "abstract_func": "YR_API VAR_0* yr_process_get_next_memory_block(\n    YR_MEMORY_BLOCK_ITERATOR* VAR_1)\n{\n  YR_PROC_ITERATOR_CTX* VAR_2 = (YR_PROC_ITERATOR_CTX*) VAR_1->context;\n  YR_PROC_INFO* VAR_3 = (YR_PROC_INFO*) VAR_2->proc_info;\n\n  int VAR_4[] = {VAR_5, VAR_6, VAR_3->pid};\n  size_t VAR_7 = sizeof(struct kinfo_vmentry);\n\n  VAR_1->last_error = VAR_8;\n\n  uint64_t VAR_9 = VAR_2->current_block.base +\n                           VAR_2->current_block.size;\n\n  uint64_t VAR_10;\n\n  yr_get_configuration_uint64(\n      VAR_11, &VAR_10);\n\n  if (VAR_3->old_end <= VAR_9)\n  {\n    if (sysctl(VAR_4, 3, &VAR_3->vm_entry, &VAR_7, NULL, 0) < 0)\n      return NULL;\n\n    /* COMMENT_0 */\n    if (VAR_3->old_end == VAR_3->vm_entry.kve_end)\n      return NULL;\n\n    VAR_9 = VAR_3->vm_entry.kve_start;\n    VAR_3->old_end = VAR_3->vm_entry.kve_end;\n\n    VAR_3->vm_entry.kve_start = VAR_3->vm_entry.kve_start + 1;\n  }\n\n  VAR_2->current_block.base = VAR_9;\n  VAR_2->current_block.size = yr_min(\n      VAR_3->old_end - VAR_9, VAR_10);\n\n  assert(VAR_2->current_block.size > 0);\n\n  return &VAR_2->current_block;\n}",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -14,8 +14,8 @@\n \n   uint64_t max_process_memory_chunk;\n \n-  yr_get_configuration(\n-      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, (void*) &max_process_memory_chunk);\n+  yr_get_configuration_uint64(\n+      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, &max_process_memory_chunk);\n \n   if (proc_info->old_end <= current_begin)\n   {",
  "diff_line_info": {
    "deleted_lines": [
      "  yr_get_configuration(",
      "      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, (void*) &max_process_memory_chunk);"
    ],
    "added_lines": [
      "  yr_get_configuration_uint64(",
      "      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, &max_process_memory_chunk);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/VirusTotal/yara/pull/1621",
  "description": {
    "pr_info": {
      "title": "Fix issue #1616",
      "number": 1621
    },
    "comment": [
      "This is a more comprehensive fix than #1617, it adds new functions to the API for getting/setting uint32 and uint64 settings.  Using these functions is preferable over calling `yr_(get|set)_configuration` directly."
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.85,
  "Bug Filter Response": "\n\nThe patch introduces new API functions to handle uint32 and uint64 settings, enhancing type safety and preventing potential issues like buffer overflows. While it improves security aspects, the commit message doesn't indicate a specific security vulnerability being addressed. Therefore, it's classified under defect remediation.\n\n**Final Output:**\nAnalysis: The patch enhances API functions for better type handling, improving code safety but without explicit security issue mention.\nFinal Classification: Defect Remediation & Feature Upgrades\nConfidence Score: 0.85"
}