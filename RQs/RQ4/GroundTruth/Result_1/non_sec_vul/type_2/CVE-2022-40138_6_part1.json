{
  "cve_id": "CVE-2022-40138",
  "cwe_ids": [
    "CWE-681"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "facebook/hermes",
  "commit_msg": "Re-sync with internal repository (#822)\n\nCo-authored-by: Facebook Community Bot <6422482+facebook-github-bot@users.noreply.github.com>",
  "commit_hash": "6aa825e480d48127b480b08d13adf70033237097",
  "git_url": "https://github.com/facebook/hermes/commit/6aa825e480d48127b480b08d13adf70033237097",
  "file_path": "lib/VM/CodeBlock.cpp",
  "func_name": "CodeBlock::lazyCompileImpl",
  "func_before": "void CodeBlock::lazyCompileImpl(Runtime &runtime) {\n  assert(isLazy() && \"Laziness has not been checked\");\n  PerfSection perf(\"Lazy function compilation\");\n  auto *provider = (hbc::BCProviderLazy *)runtimeModule_->getBytecode();\n  auto *func = provider->getBytecodeFunction();\n  auto *lazyData = func->getLazyCompilationData();\n  auto bcModule = compileLazyFunction(lazyData);\n\n  runtimeModule_->initializeLazyMayAllocate(\n      hbc::BCProviderFromSrc::createBCProviderFromSrc(std::move(bcModule)));\n  // Reset all meta lazyData of the CodeBlock to point to the newly\n  // generated bytecode module.\n  functionID_ = runtimeModule_->getBytecode()->getGlobalFunctionIndex();\n  functionHeader_ =\n      runtimeModule_->getBytecode()->getFunctionHeader(functionID_);\n  bytecode_ = runtimeModule_->getBytecode()->getBytecode(functionID_);\n}",
  "abstract_func_before": "void CodeBlock::lazyCompileImpl(Runtime &VAR_0) {\n  assert(isLazy() && \"Laziness has not been checked\");\n  PerfSection VAR_1(\"Lazy function compilation\");\n  auto *VAR_2 = (hbc::BCProviderLazy *)VAR_3->getBytecode();\n  auto *VAR_4 = VAR_2->getBytecodeFunction();\n  auto *VAR_5 = VAR_4->getLazyCompilationData();\n  auto VAR_6 = compileLazyFunction(VAR_5);\n\n  VAR_3->initializeLazyMayAllocate(\n      hbc::BCProviderFromSrc::createBCProviderFromSrc(std::move(VAR_6)));\n  /* COMMENT_0 */\n  /* COMMENT_1 */\n  VAR_7 = VAR_3->getBytecode()->getGlobalFunctionIndex();\n  VAR_8 =\n      VAR_3->getBytecode()->getFunctionHeader(VAR_7);\n  VAR_9 = VAR_3->getBytecode()->getBytecode(VAR_7);\n}",
  "func_graph_path_before": "facebook/hermes/6aa825e480d48127b480b08d13adf70033237097/CodeBlock.cpp/vul/before/0.json",
  "func": "ExecutionStatus CodeBlock::lazyCompileImpl(Runtime &runtime) {\n  assert(isLazy() && \"Laziness has not been checked\");\n  PerfSection perf(\"Lazy function compilation\");\n  auto *provider = (hbc::BCProviderLazy *)runtimeModule_->getBytecode();\n  auto *func = provider->getBytecodeFunction();\n  auto *lazyData = func->getLazyCompilationData();\n  SourceErrorManager &manager = lazyData->context->getSourceErrorManager();\n  SimpleDiagHandlerRAII outputManager{manager};\n  auto bcModule = compileLazyFunction(lazyData);\n\n  if (manager.getErrorCount()) {\n    // Raise a SyntaxError to be consistent with eval().\n    return runtime.raiseSyntaxError(\n        llvh::StringRef{outputManager.getErrorString()});\n  }\n\n  assert(bcModule && \"No errors, yet no bcModule\");\n\n  runtimeModule_->initializeLazyMayAllocate(\n      hbc::BCProviderFromSrc::createBCProviderFromSrc(std::move(bcModule)));\n  // Reset all meta lazyData of the CodeBlock to point to the newly\n  // generated bytecode module.\n  functionID_ = runtimeModule_->getBytecode()->getGlobalFunctionIndex();\n  functionHeader_ =\n      runtimeModule_->getBytecode()->getFunctionHeader(functionID_);\n  bytecode_ = runtimeModule_->getBytecode()->getBytecode(functionID_);\n\n  return ExecutionStatus::RETURNED;\n}",
  "abstract_func": "ExecutionStatus CodeBlock::lazyCompileImpl(Runtime &VAR_0) {\n  assert(isLazy() && \"Laziness has not been checked\");\n  PerfSection VAR_1(\"Lazy function compilation\");\n  auto *VAR_2 = (hbc::BCProviderLazy *)VAR_3->getBytecode();\n  auto *VAR_4 = VAR_2->getBytecodeFunction();\n  auto *VAR_5 = VAR_4->getLazyCompilationData();\n  SourceErrorManager &VAR_6 = VAR_5->context->getSourceErrorManager();\n  SimpleDiagHandlerRAII VAR_7{VAR_6};\n  auto VAR_8 = compileLazyFunction(VAR_5);\n\n  if (VAR_6.getErrorCount()) {\n    /* COMMENT_0 */\n    return VAR_0.raiseSyntaxError(\n        llvh::StringRef{VAR_7.getErrorString()});\n  }\n\n  assert(VAR_8 && \"No errors, yet no bcModule\");\n\n  VAR_3->initializeLazyMayAllocate(\n      hbc::BCProviderFromSrc::createBCProviderFromSrc(std::move(VAR_8)));\n  /* COMMENT_1 */\n  /* COMMENT_2 */\n  VAR_9 = VAR_3->getBytecode()->getGlobalFunctionIndex();\n  VAR_10 =\n      VAR_3->getBytecode()->getFunctionHeader(VAR_9);\n  VAR_11 = VAR_3->getBytecode()->getBytecode(VAR_9);\n\n  return ExecutionStatus::RETURNED;\n}",
  "func_graph_path": "facebook/hermes/6aa825e480d48127b480b08d13adf70033237097/CodeBlock.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,10 +1,20 @@\n-void CodeBlock::lazyCompileImpl(Runtime &runtime) {\n+ExecutionStatus CodeBlock::lazyCompileImpl(Runtime &runtime) {\n   assert(isLazy() && \"Laziness has not been checked\");\n   PerfSection perf(\"Lazy function compilation\");\n   auto *provider = (hbc::BCProviderLazy *)runtimeModule_->getBytecode();\n   auto *func = provider->getBytecodeFunction();\n   auto *lazyData = func->getLazyCompilationData();\n+  SourceErrorManager &manager = lazyData->context->getSourceErrorManager();\n+  SimpleDiagHandlerRAII outputManager{manager};\n   auto bcModule = compileLazyFunction(lazyData);\n+\n+  if (manager.getErrorCount()) {\n+    // Raise a SyntaxError to be consistent with eval().\n+    return runtime.raiseSyntaxError(\n+        llvh::StringRef{outputManager.getErrorString()});\n+  }\n+\n+  assert(bcModule && \"No errors, yet no bcModule\");\n \n   runtimeModule_->initializeLazyMayAllocate(\n       hbc::BCProviderFromSrc::createBCProviderFromSrc(std::move(bcModule)));\n@@ -14,4 +24,6 @@\n   functionHeader_ =\n       runtimeModule_->getBytecode()->getFunctionHeader(functionID_);\n   bytecode_ = runtimeModule_->getBytecode()->getBytecode(functionID_);\n+\n+  return ExecutionStatus::RETURNED;\n }",
  "diff_line_info": {
    "deleted_lines": [
      "void CodeBlock::lazyCompileImpl(Runtime &runtime) {"
    ],
    "added_lines": [
      "ExecutionStatus CodeBlock::lazyCompileImpl(Runtime &runtime) {",
      "  SourceErrorManager &manager = lazyData->context->getSourceErrorManager();",
      "  SimpleDiagHandlerRAII outputManager{manager};",
      "",
      "  if (manager.getErrorCount()) {",
      "    // Raise a SyntaxError to be consistent with eval().",
      "    return runtime.raiseSyntaxError(",
      "        llvh::StringRef{outputManager.getErrorString()});",
      "  }",
      "",
      "  assert(bcModule && \"No errors, yet no bcModule\");",
      "",
      "  return ExecutionStatus::RETURNED;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/facebook/hermes/pull/822",
  "description": {
    "pr_info": {
      "title": "Re-sync with internal repository",
      "number": 822
    },
    "comment": [
      "The internal and external repositories are out of sync. This attempts to brings them back in sync by patching the GitHub repository. Please carefully review this patch. You must disable ShipIt for your project in order to merge this pull request. DO NOT IMPORT this pull request. Instead, merge it directly on GitHub using the MERGE BUTTON. Re-enable ShipIt after merging."
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch modifies the `lazyCompileImpl` function to include error handling, returning an `ExecutionStatus`. It adds checks for compilation errors and raises a `SyntaxError` if any occur. This prevents crashes and ensures proper error handling but doesn't address a security exploit.\n\nFinal Classification: Defect Remediation & Feature Upgrades\n\nConfidence Score: 0.9"
}