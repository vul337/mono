{
  "cve_id": "CVE-2021-45928",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "AV:L/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "libjxl",
  "commit_msg": "fix use_full_image==false case",
  "commit_hash": "7634712307110325630eb41188cec77bc4a91233",
  "git_url": "https://github.com/libjxl/libjxl/commit/7634712307110325630eb41188cec77bc4a91233",
  "file_path": "lib/jxl/dec_modular.cc",
  "func_name": "ModularFrameDecoder::DecodeGroup",
  "func_before": "Status ModularFrameDecoder::DecodeGroup(const Rect& rect, BitReader* reader,\n                                        int minShift, int maxShift,\n                                        const ModularStreamId& stream,\n                                        bool zerofill,\n                                        PassesDecoderState* dec_state,\n                                        ImageBundle* output) {\n  JXL_DASSERT(stream.kind == ModularStreamId::kModularDC ||\n              stream.kind == ModularStreamId::kModularAC);\n  const size_t xsize = rect.xsize();\n  const size_t ysize = rect.ysize();\n  Image gi(xsize, ysize, full_image.bitdepth, 0);\n  // start at the first bigger-than-groupsize non-metachannel\n  size_t c = full_image.nb_meta_channels;\n  for (; c < full_image.channel.size(); c++) {\n    Channel& fc = full_image.channel[c];\n    if (fc.w > frame_dim.group_dim || fc.h > frame_dim.group_dim) break;\n  }\n  size_t beginc = c;\n  for (; c < full_image.channel.size(); c++) {\n    Channel& fc = full_image.channel[c];\n    int shift = std::min(fc.hshift, fc.vshift);\n    if (shift > maxShift) continue;\n    if (shift < minShift) continue;\n    Rect r(rect.x0() >> fc.hshift, rect.y0() >> fc.vshift,\n           rect.xsize() >> fc.hshift, rect.ysize() >> fc.vshift, fc.w, fc.h);\n    if (r.xsize() == 0 || r.ysize() == 0) continue;\n    Channel gc(r.xsize(), r.ysize());\n    gc.hshift = fc.hshift;\n    gc.vshift = fc.vshift;\n    gi.channel.emplace_back(std::move(gc));\n  }\n  if (zerofill) {\n    int gic = 0;\n    for (c = beginc; c < full_image.channel.size(); c++) {\n      Channel& fc = full_image.channel[c];\n      int shift = std::min(fc.hshift, fc.vshift);\n      if (shift > maxShift) continue;\n      if (shift < minShift) continue;\n      Rect r(rect.x0() >> fc.hshift, rect.y0() >> fc.vshift,\n             rect.xsize() >> fc.hshift, rect.ysize() >> fc.vshift, fc.w, fc.h);\n      if (r.xsize() == 0 || r.ysize() == 0) continue;\n      for (size_t y = 0; y < r.ysize(); ++y) {\n        pixel_type* const JXL_RESTRICT row_out = r.Row(&fc.plane, y);\n        memset(row_out, 0, r.xsize() * sizeof(*row_out));\n      }\n      gic++;\n    }\n    return true;\n  }\n  ModularOptions options;\n  if (!ModularGenericDecompress(\n          reader, gi, /*header=*/nullptr, stream.ID(frame_dim), &options,\n          /*undo_transforms=*/-1, &tree, &code, &context_map))\n    return JXL_FAILURE(\"Failed to decode modular group\");\n  if (minShift == 0) {\n    // Undo global transforms that have been pushed to the group level\n    for (auto t : global_transform) {\n      JXL_RETURN_IF_ERROR(t.Inverse(gi, global_header.wp_header));\n    }\n    if (!use_full_image) {\n      JXL_RETURN_IF_ERROR(ModularImageToDecodedRect(\n          gi, dec_state, nullptr, output, rect.Crop(dec_state->decoded)));\n      return true;\n    }\n  }\n  int gic = 0;\n  for (c = beginc; c < full_image.channel.size(); c++) {\n    Channel& fc = full_image.channel[c];\n    int shift = std::min(fc.hshift, fc.vshift);\n    if (shift > maxShift) continue;\n    if (shift < minShift) continue;\n    Rect r(rect.x0() >> fc.hshift, rect.y0() >> fc.vshift,\n           rect.xsize() >> fc.hshift, rect.ysize() >> fc.vshift, fc.w, fc.h);\n    if (r.xsize() == 0 || r.ysize() == 0) continue;\n    CopyImageTo(/*rect_from=*/Rect(0, 0, r.xsize(), r.ysize()),\n                /*from=*/gi.channel[gic].plane,\n                /*rect_to=*/r, /*to=*/&fc.plane);\n    gic++;\n  }\n  return true;\n}",
  "abstract_func_before": "Status ModularFrameDecoder::DecodeGroup(const Rect& VAR_0, BitReader* VAR_1,\n                                        int VAR_2, int VAR_3,\n                                        const ModularStreamId& VAR_4,\n                                        bool VAR_5,\n                                        PassesDecoderState* VAR_6,\n                                        ImageBundle* VAR_7) {\n  JXL_DASSERT(VAR_4.kind == ModularStreamId::kModularDC ||\n              VAR_4.kind == ModularStreamId::kModularAC);\n  const size_t VAR_8 = VAR_0.xsize();\n  const size_t VAR_9 = VAR_0.ysize();\n  Image VAR_10(VAR_8, VAR_9, VAR_11.bitdepth, 0);\n  /* COMMENT_0 */\n  size_t VAR_12 = VAR_11.nb_meta_channels;\n  for (; VAR_12 < VAR_11.channel.size(); VAR_12++) {\n    Channel& VAR_13 = VAR_11.channel[VAR_12];\n    if (VAR_13.w > VAR_14.group_dim || VAR_13.h > VAR_14.group_dim) break;\n  }\n  size_t VAR_15 = VAR_12;\n  for (; VAR_12 < VAR_11.channel.size(); VAR_12++) {\n    Channel& VAR_13 = VAR_11.channel[VAR_12];\n    int VAR_16 = std::min(VAR_13.hshift, VAR_13.vshift);\n    if (VAR_16 > VAR_3) continue;\n    if (VAR_16 < VAR_2) continue;\n    Rect VAR_17(VAR_0.x0() >> VAR_13.hshift, VAR_0.y0() >> VAR_13.vshift,\n           VAR_0.xsize() >> VAR_13.hshift, VAR_0.ysize() >> VAR_13.vshift, VAR_13.w, VAR_13.h);\n    if (VAR_17.xsize() == 0 || VAR_17.ysize() == 0) continue;\n    Channel VAR_18(VAR_17.xsize(), VAR_17.ysize());\n    VAR_18.hshift = VAR_13.hshift;\n    VAR_18.vshift = VAR_13.vshift;\n    VAR_10.channel.emplace_back(std::move(VAR_18));\n  }\n  if (VAR_5) {\n    int VAR_19 = 0;\n    for (VAR_12 = VAR_15; VAR_12 < VAR_11.channel.size(); VAR_12++) {\n      Channel& VAR_13 = VAR_11.channel[VAR_12];\n      int VAR_16 = std::min(VAR_13.hshift, VAR_13.vshift);\n      if (VAR_16 > VAR_3) continue;\n      if (VAR_16 < VAR_2) continue;\n      Rect VAR_17(VAR_0.x0() >> VAR_13.hshift, VAR_0.y0() >> VAR_13.vshift,\n             VAR_0.xsize() >> VAR_13.hshift, VAR_0.ysize() >> VAR_13.vshift, VAR_13.w, VAR_13.h);\n      if (VAR_17.xsize() == 0 || VAR_17.ysize() == 0) continue;\n      for (size_t VAR_20 = 0; VAR_20 < VAR_17.ysize(); ++VAR_20) {\n        pixel_type* const VAR_21 VAR_22 = VAR_17.Row(&VAR_13.plane, VAR_20);\n        memset(VAR_22, 0, VAR_17.xsize() * sizeof(*VAR_22));\n      }\n      VAR_19++;\n    }\n    return true;\n  }\n  ModularOptions VAR_23;\n  if (!ModularGenericDecompress(\n          VAR_1, VAR_10, /* COMMENT_1 */nullptr, VAR_4.ID(VAR_14), &VAR_23,\n          /* COMMENT_2 */-1, &VAR_24, &VAR_25, &VAR_26))\n    return JXL_FAILURE(\"Failed to decode modular group\");\n  if (VAR_2 == 0) {\n    /* COMMENT_3 */\n    for (auto VAR_27 : VAR_28) {\n      JXL_RETURN_IF_ERROR(VAR_27.Inverse(VAR_10, VAR_29.wp_header));\n    }\n    if (!VAR_30) {\n      JXL_RETURN_IF_ERROR(ModularImageToDecodedRect(\n          VAR_10, VAR_6, nullptr, VAR_7, VAR_0.Crop(VAR_6->decoded)));\n      return true;\n    }\n  }\n  int VAR_19 = 0;\n  for (VAR_12 = VAR_15; VAR_12 < VAR_11.channel.size(); VAR_12++) {\n    Channel& VAR_13 = VAR_11.channel[VAR_12];\n    int VAR_16 = std::min(VAR_13.hshift, VAR_13.vshift);\n    if (VAR_16 > VAR_3) continue;\n    if (VAR_16 < VAR_2) continue;\n    Rect VAR_17(VAR_0.x0() >> VAR_13.hshift, VAR_0.y0() >> VAR_13.vshift,\n           VAR_0.xsize() >> VAR_13.hshift, VAR_0.ysize() >> VAR_13.vshift, VAR_13.w, VAR_13.h);\n    if (VAR_17.xsize() == 0 || VAR_17.ysize() == 0) continue;\n    CopyImageTo(/* COMMENT_4 */Rect(0, 0, VAR_17.xsize(), VAR_17.ysize()),\n                /* COMMENT_5 */VAR_10.channel[VAR_19].plane,\n                /* COMMENT_6 */VAR_17, /* COMMENT_7 */&VAR_13.plane);\n    VAR_19++;\n  }\n  return true;\n}",
  "func_graph_path_before": "libjxl/7634712307110325630eb41188cec77bc4a91233/dec_modular.cc/vul/before/0.json",
  "func": "Status ModularFrameDecoder::DecodeGroup(const Rect& rect, BitReader* reader,\n                                        int minShift, int maxShift,\n                                        const ModularStreamId& stream,\n                                        bool zerofill,\n                                        PassesDecoderState* dec_state,\n                                        ImageBundle* output) {\n  JXL_DASSERT(stream.kind == ModularStreamId::kModularDC ||\n              stream.kind == ModularStreamId::kModularAC);\n  const size_t xsize = rect.xsize();\n  const size_t ysize = rect.ysize();\n  Image gi(xsize, ysize, full_image.bitdepth, 0);\n  // start at the first bigger-than-groupsize non-metachannel\n  size_t c = full_image.nb_meta_channels;\n  for (; c < full_image.channel.size(); c++) {\n    Channel& fc = full_image.channel[c];\n    if (fc.w > frame_dim.group_dim || fc.h > frame_dim.group_dim) break;\n  }\n  size_t beginc = c;\n  for (; c < full_image.channel.size(); c++) {\n    Channel& fc = full_image.channel[c];\n    int shift = std::min(fc.hshift, fc.vshift);\n    if (shift > maxShift) continue;\n    if (shift < minShift) continue;\n    Rect r(rect.x0() >> fc.hshift, rect.y0() >> fc.vshift,\n           rect.xsize() >> fc.hshift, rect.ysize() >> fc.vshift, fc.w, fc.h);\n    if (r.xsize() == 0 || r.ysize() == 0) continue;\n    if (zerofill && use_full_image) {\n      for (size_t y = 0; y < r.ysize(); ++y) {\n        pixel_type* const JXL_RESTRICT row_out = r.Row(&fc.plane, y);\n        memset(row_out, 0, r.xsize() * sizeof(*row_out));\n      }\n    } else {\n      Channel gc(r.xsize(), r.ysize());\n      if (zerofill) ZeroFillImage(&gc.plane);\n      gc.hshift = fc.hshift;\n      gc.vshift = fc.vshift;\n      gi.channel.emplace_back(std::move(gc));\n    }\n  }\n  if (zerofill && use_full_image) return true;\n  ModularOptions options;\n  if (!zerofill) {\n    if (!ModularGenericDecompress(\n            reader, gi, /*header=*/nullptr, stream.ID(frame_dim), &options,\n            /*undo_transforms=*/-1, &tree, &code, &context_map)) {\n      return JXL_FAILURE(\"Failed to decode modular group\");\n    }\n  }\n  // Undo global transforms that have been pushed to the group level\n  if (!use_full_image) {\n    for (auto t : global_transform) {\n      JXL_RETURN_IF_ERROR(t.Inverse(gi, global_header.wp_header));\n    }\n    JXL_RETURN_IF_ERROR(ModularImageToDecodedRect(\n        gi, dec_state, nullptr, output, rect.Crop(dec_state->decoded)));\n    return true;\n  }\n  int gic = 0;\n  for (c = beginc; c < full_image.channel.size(); c++) {\n    Channel& fc = full_image.channel[c];\n    int shift = std::min(fc.hshift, fc.vshift);\n    if (shift > maxShift) continue;\n    if (shift < minShift) continue;\n    Rect r(rect.x0() >> fc.hshift, rect.y0() >> fc.vshift,\n           rect.xsize() >> fc.hshift, rect.ysize() >> fc.vshift, fc.w, fc.h);\n    if (r.xsize() == 0 || r.ysize() == 0) continue;\n    JXL_ASSERT(use_full_image);\n    CopyImageTo(/*rect_from=*/Rect(0, 0, r.xsize(), r.ysize()),\n                /*from=*/gi.channel[gic].plane,\n                /*rect_to=*/r, /*to=*/&fc.plane);\n    gic++;\n  }\n  return true;\n}",
  "abstract_func": "Status ModularFrameDecoder::DecodeGroup(const Rect& VAR_0, BitReader* VAR_1,\n                                        int VAR_2, int VAR_3,\n                                        const ModularStreamId& VAR_4,\n                                        bool VAR_5,\n                                        PassesDecoderState* VAR_6,\n                                        ImageBundle* VAR_7) {\n  JXL_DASSERT(VAR_4.kind == ModularStreamId::kModularDC ||\n              VAR_4.kind == ModularStreamId::kModularAC);\n  const size_t VAR_8 = VAR_0.xsize();\n  const size_t VAR_9 = VAR_0.ysize();\n  Image VAR_10(VAR_8, VAR_9, VAR_11.bitdepth, 0);\n  /* COMMENT_0 */\n  size_t VAR_12 = VAR_11.nb_meta_channels;\n  for (; VAR_12 < VAR_11.channel.size(); VAR_12++) {\n    Channel& VAR_13 = VAR_11.channel[VAR_12];\n    if (VAR_13.w > VAR_14.group_dim || VAR_13.h > VAR_14.group_dim) break;\n  }\n  size_t VAR_15 = VAR_12;\n  for (; VAR_12 < VAR_11.channel.size(); VAR_12++) {\n    Channel& VAR_13 = VAR_11.channel[VAR_12];\n    int VAR_16 = std::min(VAR_13.hshift, VAR_13.vshift);\n    if (VAR_16 > VAR_3) continue;\n    if (VAR_16 < VAR_2) continue;\n    Rect VAR_17(VAR_0.x0() >> VAR_13.hshift, VAR_0.y0() >> VAR_13.vshift,\n           VAR_0.xsize() >> VAR_13.hshift, VAR_0.ysize() >> VAR_13.vshift, VAR_13.w, VAR_13.h);\n    if (VAR_17.xsize() == 0 || VAR_17.ysize() == 0) continue;\n    if (VAR_5 && VAR_18) {\n      for (size_t VAR_19 = 0; VAR_19 < VAR_17.ysize(); ++VAR_19) {\n        pixel_type* const VAR_20 VAR_21 = VAR_17.Row(&VAR_13.plane, VAR_19);\n        memset(VAR_21, 0, VAR_17.xsize() * sizeof(*VAR_21));\n      }\n    } else {\n      Channel VAR_22(VAR_17.xsize(), VAR_17.ysize());\n      if (VAR_5) ZeroFillImage(&VAR_22.plane);\n      VAR_22.hshift = VAR_13.hshift;\n      VAR_22.vshift = VAR_13.vshift;\n      VAR_10.channel.emplace_back(std::move(VAR_22));\n    }\n  }\n  if (VAR_5 && VAR_18) return true;\n  ModularOptions VAR_23;\n  if (!VAR_5) {\n    if (!ModularGenericDecompress(\n            VAR_1, VAR_10, /* COMMENT_1 */nullptr, VAR_4.ID(VAR_14), &VAR_23,\n            /* COMMENT_2 */-1, &VAR_24, &VAR_25, &VAR_26)) {\n      return JXL_FAILURE(\"Failed to decode modular group\");\n    }\n  }\n  /* COMMENT_3 */\n  if (!VAR_18) {\n    for (auto VAR_27 : VAR_28) {\n      JXL_RETURN_IF_ERROR(VAR_27.Inverse(VAR_10, VAR_29.wp_header));\n    }\n    JXL_RETURN_IF_ERROR(ModularImageToDecodedRect(\n        VAR_10, VAR_6, nullptr, VAR_7, VAR_0.Crop(VAR_6->decoded)));\n    return true;\n  }\n  int VAR_30 = 0;\n  for (VAR_12 = VAR_15; VAR_12 < VAR_11.channel.size(); VAR_12++) {\n    Channel& VAR_13 = VAR_11.channel[VAR_12];\n    int VAR_16 = std::min(VAR_13.hshift, VAR_13.vshift);\n    if (VAR_16 > VAR_3) continue;\n    if (VAR_16 < VAR_2) continue;\n    Rect VAR_17(VAR_0.x0() >> VAR_13.hshift, VAR_0.y0() >> VAR_13.vshift,\n           VAR_0.xsize() >> VAR_13.hshift, VAR_0.ysize() >> VAR_13.vshift, VAR_13.w, VAR_13.h);\n    if (VAR_17.xsize() == 0 || VAR_17.ysize() == 0) continue;\n    JXL_ASSERT(VAR_18);\n    CopyImageTo(/* COMMENT_4 */Rect(0, 0, VAR_17.xsize(), VAR_17.ysize()),\n                /* COMMENT_5 */VAR_10.channel[VAR_30].plane,\n                /* COMMENT_6 */VAR_17, /* COMMENT_7 */&VAR_13.plane);\n    VAR_30++;\n  }\n  return true;\n}",
  "func_graph_path": "libjxl/7634712307110325630eb41188cec77bc4a91233/dec_modular.cc/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -24,44 +24,36 @@\n     Rect r(rect.x0() >> fc.hshift, rect.y0() >> fc.vshift,\n            rect.xsize() >> fc.hshift, rect.ysize() >> fc.vshift, fc.w, fc.h);\n     if (r.xsize() == 0 || r.ysize() == 0) continue;\n-    Channel gc(r.xsize(), r.ysize());\n-    gc.hshift = fc.hshift;\n-    gc.vshift = fc.vshift;\n-    gi.channel.emplace_back(std::move(gc));\n-  }\n-  if (zerofill) {\n-    int gic = 0;\n-    for (c = beginc; c < full_image.channel.size(); c++) {\n-      Channel& fc = full_image.channel[c];\n-      int shift = std::min(fc.hshift, fc.vshift);\n-      if (shift > maxShift) continue;\n-      if (shift < minShift) continue;\n-      Rect r(rect.x0() >> fc.hshift, rect.y0() >> fc.vshift,\n-             rect.xsize() >> fc.hshift, rect.ysize() >> fc.vshift, fc.w, fc.h);\n-      if (r.xsize() == 0 || r.ysize() == 0) continue;\n+    if (zerofill && use_full_image) {\n       for (size_t y = 0; y < r.ysize(); ++y) {\n         pixel_type* const JXL_RESTRICT row_out = r.Row(&fc.plane, y);\n         memset(row_out, 0, r.xsize() * sizeof(*row_out));\n       }\n-      gic++;\n+    } else {\n+      Channel gc(r.xsize(), r.ysize());\n+      if (zerofill) ZeroFillImage(&gc.plane);\n+      gc.hshift = fc.hshift;\n+      gc.vshift = fc.vshift;\n+      gi.channel.emplace_back(std::move(gc));\n     }\n-    return true;\n   }\n+  if (zerofill && use_full_image) return true;\n   ModularOptions options;\n-  if (!ModularGenericDecompress(\n-          reader, gi, /*header=*/nullptr, stream.ID(frame_dim), &options,\n-          /*undo_transforms=*/-1, &tree, &code, &context_map))\n-    return JXL_FAILURE(\"Failed to decode modular group\");\n-  if (minShift == 0) {\n-    // Undo global transforms that have been pushed to the group level\n+  if (!zerofill) {\n+    if (!ModularGenericDecompress(\n+            reader, gi, /*header=*/nullptr, stream.ID(frame_dim), &options,\n+            /*undo_transforms=*/-1, &tree, &code, &context_map)) {\n+      return JXL_FAILURE(\"Failed to decode modular group\");\n+    }\n+  }\n+  // Undo global transforms that have been pushed to the group level\n+  if (!use_full_image) {\n     for (auto t : global_transform) {\n       JXL_RETURN_IF_ERROR(t.Inverse(gi, global_header.wp_header));\n     }\n-    if (!use_full_image) {\n-      JXL_RETURN_IF_ERROR(ModularImageToDecodedRect(\n-          gi, dec_state, nullptr, output, rect.Crop(dec_state->decoded)));\n-      return true;\n-    }\n+    JXL_RETURN_IF_ERROR(ModularImageToDecodedRect(\n+        gi, dec_state, nullptr, output, rect.Crop(dec_state->decoded)));\n+    return true;\n   }\n   int gic = 0;\n   for (c = beginc; c < full_image.channel.size(); c++) {\n@@ -72,6 +64,7 @@\n     Rect r(rect.x0() >> fc.hshift, rect.y0() >> fc.vshift,\n            rect.xsize() >> fc.hshift, rect.ysize() >> fc.vshift, fc.w, fc.h);\n     if (r.xsize() == 0 || r.ysize() == 0) continue;\n+    JXL_ASSERT(use_full_image);\n     CopyImageTo(/*rect_from=*/Rect(0, 0, r.xsize(), r.ysize()),\n                 /*from=*/gi.channel[gic].plane,\n                 /*rect_to=*/r, /*to=*/&fc.plane);",
  "diff_line_info": {
    "deleted_lines": [
      "    Channel gc(r.xsize(), r.ysize());",
      "    gc.hshift = fc.hshift;",
      "    gc.vshift = fc.vshift;",
      "    gi.channel.emplace_back(std::move(gc));",
      "  }",
      "  if (zerofill) {",
      "    int gic = 0;",
      "    for (c = beginc; c < full_image.channel.size(); c++) {",
      "      Channel& fc = full_image.channel[c];",
      "      int shift = std::min(fc.hshift, fc.vshift);",
      "      if (shift > maxShift) continue;",
      "      if (shift < minShift) continue;",
      "      Rect r(rect.x0() >> fc.hshift, rect.y0() >> fc.vshift,",
      "             rect.xsize() >> fc.hshift, rect.ysize() >> fc.vshift, fc.w, fc.h);",
      "      if (r.xsize() == 0 || r.ysize() == 0) continue;",
      "      gic++;",
      "    return true;",
      "  if (!ModularGenericDecompress(",
      "          reader, gi, /*header=*/nullptr, stream.ID(frame_dim), &options,",
      "          /*undo_transforms=*/-1, &tree, &code, &context_map))",
      "    return JXL_FAILURE(\"Failed to decode modular group\");",
      "  if (minShift == 0) {",
      "    // Undo global transforms that have been pushed to the group level",
      "    if (!use_full_image) {",
      "      JXL_RETURN_IF_ERROR(ModularImageToDecodedRect(",
      "          gi, dec_state, nullptr, output, rect.Crop(dec_state->decoded)));",
      "      return true;",
      "    }"
    ],
    "added_lines": [
      "    if (zerofill && use_full_image) {",
      "    } else {",
      "      Channel gc(r.xsize(), r.ysize());",
      "      if (zerofill) ZeroFillImage(&gc.plane);",
      "      gc.hshift = fc.hshift;",
      "      gc.vshift = fc.vshift;",
      "      gi.channel.emplace_back(std::move(gc));",
      "  if (zerofill && use_full_image) return true;",
      "  if (!zerofill) {",
      "    if (!ModularGenericDecompress(",
      "            reader, gi, /*header=*/nullptr, stream.ID(frame_dim), &options,",
      "            /*undo_transforms=*/-1, &tree, &code, &context_map)) {",
      "      return JXL_FAILURE(\"Failed to decode modular group\");",
      "    }",
      "  }",
      "  // Undo global transforms that have been pushed to the group level",
      "  if (!use_full_image) {",
      "    JXL_RETURN_IF_ERROR(ModularImageToDecodedRect(",
      "        gi, dec_state, nullptr, output, rect.Crop(dec_state->decoded)));",
      "    return true;",
      "    JXL_ASSERT(use_full_image);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libjxl/libjxl/pull/365",
  "description": {
    "pr_info": {
      "title": "fix use_full_image==false case",
      "number": 365
    },
    "comment": [
      "Some fixes to the case where the full modular image is skipped:\r\n\r\n- don't assume that everything happens at the modular AC group level (`minShift==0`), there can also be upsampling causing channels to have nonzero shift even when there's no Squeeze\r\n- for partial decodes (when `zerofill` is true), don't try to fill the full image when it's not used. Instead initialize the decoded image with zeroes and skip the decoding.",
      "@jonsneyers  please put the PR description in the commit message, you can do so manually when doing \"Squash and merge\" (which also tags the commit with the PR number).",
      "The code this is fixing was introduced in #205 which is not in v0.5.x branch, removing label. (`use_full_image` is not present in v0.5.x)"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses a scenario where `use_full_image` is false by adding checks to handle zerofill correctly. It prevents unnecessary operations and ensures proper initialization, indicating a functional bug fix without security implications.\n\nFinal Classification: Defect Remediation & Feature Upgrades  \nConfidence Score: 0.9"
}