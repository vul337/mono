{
  "cve_id": "CVE-2022-26530",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "swaywm/swaylock",
  "commit_msg": "Add support for ext-session-lock-v1\n\nThis is a new protocol to lock the session [1]. It should be more\nreliable than layer-shell + input-inhibitor.\n\n[1]: https://gitlab.freedesktop.org/wayland/wayland-protocols/-/merge_requests/131",
  "commit_hash": "1d1c75b6316d21933069a9d201f966d84099f6ca",
  "git_url": "https://github.com/swaywm/swaylock/commit/1d1c75b6316d21933069a9d201f966d84099f6ca",
  "file_path": "main.c",
  "func_name": "handle_global",
  "func_before": "static void handle_global(void *data, struct wl_registry *registry,\n\t\tuint32_t name, const char *interface, uint32_t version) {\n\tstruct swaylock_state *state = data;\n\tif (strcmp(interface, wl_compositor_interface.name) == 0) {\n\t\tstate->compositor = wl_registry_bind(registry, name,\n\t\t\t\t&wl_compositor_interface, 4);\n\t} else if (strcmp(interface, wl_subcompositor_interface.name) == 0) {\n\t\tstate->subcompositor = wl_registry_bind(registry, name,\n\t\t\t\t&wl_subcompositor_interface, 1);\n\t} else if (strcmp(interface, wl_shm_interface.name) == 0) {\n\t\tstate->shm = wl_registry_bind(registry, name,\n\t\t\t\t&wl_shm_interface, 1);\n\t} else if (strcmp(interface, wl_seat_interface.name) == 0) {\n\t\tstruct wl_seat *seat = wl_registry_bind(\n\t\t\t\tregistry, name, &wl_seat_interface, 4);\n\t\tstruct swaylock_seat *swaylock_seat =\n\t\t\tcalloc(1, sizeof(struct swaylock_seat));\n\t\tswaylock_seat->state = state;\n\t\twl_seat_add_listener(seat, &seat_listener, swaylock_seat);\n\t} else if (strcmp(interface, zwlr_layer_shell_v1_interface.name) == 0) {\n\t\tstate->layer_shell = wl_registry_bind(\n\t\t\t\tregistry, name, &zwlr_layer_shell_v1_interface, 1);\n\t} else if (strcmp(interface, zwlr_input_inhibit_manager_v1_interface.name) == 0) {\n\t\tstate->input_inhibit_manager = wl_registry_bind(\n\t\t\t\tregistry, name, &zwlr_input_inhibit_manager_v1_interface, 1);\n\t} else if (strcmp(interface, zxdg_output_manager_v1_interface.name) == 0) {\n\t\tstate->zxdg_output_manager = wl_registry_bind(\n\t\t\t\tregistry, name, &zxdg_output_manager_v1_interface, 2);\n\t} else if (strcmp(interface, wl_output_interface.name) == 0) {\n\t\tstruct swaylock_surface *surface =\n\t\t\tcalloc(1, sizeof(struct swaylock_surface));\n\t\tsurface->state = state;\n\t\tsurface->output = wl_registry_bind(registry, name,\n\t\t\t\t&wl_output_interface, 3);\n\t\tsurface->output_global_name = name;\n\t\twl_output_add_listener(surface->output, &_wl_output_listener, surface);\n\t\twl_list_insert(&state->surfaces, &surface->link);\n\n\t\tif (state->run_display) {\n\t\t\tcreate_layer_surface(surface);\n\t\t\twl_display_roundtrip(state->display);\n\t\t}\n\t}\n}",
  "abstract_func_before": "static void handle_global(void *VAR_0, struct wl_registry *VAR_1,\n\t\tuint32_t VAR_2, const char *VAR_3, uint32_t VAR_4) {\n\tstruct swaylock_state *VAR_5 = VAR_0;\n\tif (strcmp(VAR_3, VAR_6.name) == 0) {\n\t\tVAR_5->compositor = wl_registry_bind(VAR_1, VAR_2,\n\t\t\t\t&VAR_6, 4);\n\t} else if (strcmp(VAR_3, VAR_7.name) == 0) {\n\t\tVAR_5->subcompositor = wl_registry_bind(VAR_1, VAR_2,\n\t\t\t\t&VAR_7, 1);\n\t} else if (strcmp(VAR_3, VAR_8.name) == 0) {\n\t\tVAR_5->shm = wl_registry_bind(VAR_1, VAR_2,\n\t\t\t\t&VAR_8, 1);\n\t} else if (strcmp(VAR_3, VAR_9.name) == 0) {\n\t\tstruct wl_seat *VAR_10 = wl_registry_bind(\n\t\t\t\tVAR_1, VAR_2, &VAR_9, 4);\n\t\tstruct swaylock_seat *swaylock_seat =\n\t\t\tcalloc(1, sizeof(struct swaylock_seat));\n\t\tswaylock_seat->state = VAR_5;\n\t\twl_seat_add_listener(VAR_10, &VAR_11, swaylock_seat);\n\t} else if (strcmp(VAR_3, VAR_12.name) == 0) {\n\t\tVAR_5->layer_shell = wl_registry_bind(\n\t\t\t\tVAR_1, VAR_2, &VAR_12, 1);\n\t} else if (strcmp(VAR_3, VAR_13.name) == 0) {\n\t\tVAR_5->input_inhibit_manager = wl_registry_bind(\n\t\t\t\tVAR_1, VAR_2, &VAR_13, 1);\n\t} else if (strcmp(VAR_3, VAR_14.name) == 0) {\n\t\tVAR_5->zxdg_output_manager = wl_registry_bind(\n\t\t\t\tVAR_1, VAR_2, &VAR_14, 2);\n\t} else if (strcmp(VAR_3, VAR_15.name) == 0) {\n\t\tstruct swaylock_surface *VAR_16 =\n\t\t\tcalloc(1, sizeof(struct swaylock_surface));\n\t\tVAR_16->state = VAR_5;\n\t\tVAR_16->output = wl_registry_bind(VAR_1, VAR_2,\n\t\t\t\t&VAR_15, 3);\n\t\tVAR_16->output_global_name = VAR_2;\n\t\twl_output_add_listener(VAR_16->output, &VAR_17, VAR_16);\n\t\twl_list_insert(&VAR_5->surfaces, &VAR_16->link);\n\n\t\tif (VAR_5->run_display) {\n\t\t\tcreate_layer_surface(VAR_16);\n\t\t\twl_display_roundtrip(VAR_5->display);\n\t\t}\n\t}\n}",
  "func_graph_path_before": "swaywm/swaylock/1d1c75b6316d21933069a9d201f966d84099f6ca/main.c/vul/before/0.json",
  "func": "static void handle_global(void *data, struct wl_registry *registry,\n\t\tuint32_t name, const char *interface, uint32_t version) {\n\tstruct swaylock_state *state = data;\n\tif (strcmp(interface, wl_compositor_interface.name) == 0) {\n\t\tstate->compositor = wl_registry_bind(registry, name,\n\t\t\t\t&wl_compositor_interface, 4);\n\t} else if (strcmp(interface, wl_subcompositor_interface.name) == 0) {\n\t\tstate->subcompositor = wl_registry_bind(registry, name,\n\t\t\t\t&wl_subcompositor_interface, 1);\n\t} else if (strcmp(interface, wl_shm_interface.name) == 0) {\n\t\tstate->shm = wl_registry_bind(registry, name,\n\t\t\t\t&wl_shm_interface, 1);\n\t} else if (strcmp(interface, wl_seat_interface.name) == 0) {\n\t\tstruct wl_seat *seat = wl_registry_bind(\n\t\t\t\tregistry, name, &wl_seat_interface, 4);\n\t\tstruct swaylock_seat *swaylock_seat =\n\t\t\tcalloc(1, sizeof(struct swaylock_seat));\n\t\tswaylock_seat->state = state;\n\t\twl_seat_add_listener(seat, &seat_listener, swaylock_seat);\n\t} else if (strcmp(interface, zwlr_layer_shell_v1_interface.name) == 0) {\n\t\tstate->layer_shell = wl_registry_bind(\n\t\t\t\tregistry, name, &zwlr_layer_shell_v1_interface, 1);\n\t} else if (strcmp(interface, zwlr_input_inhibit_manager_v1_interface.name) == 0) {\n\t\tstate->input_inhibit_manager = wl_registry_bind(\n\t\t\t\tregistry, name, &zwlr_input_inhibit_manager_v1_interface, 1);\n\t} else if (strcmp(interface, zxdg_output_manager_v1_interface.name) == 0) {\n\t\tstate->zxdg_output_manager = wl_registry_bind(\n\t\t\t\tregistry, name, &zxdg_output_manager_v1_interface, 2);\n\t} else if (strcmp(interface, wl_output_interface.name) == 0) {\n\t\tstruct swaylock_surface *surface =\n\t\t\tcalloc(1, sizeof(struct swaylock_surface));\n\t\tsurface->state = state;\n\t\tsurface->output = wl_registry_bind(registry, name,\n\t\t\t\t&wl_output_interface, 3);\n\t\tsurface->output_global_name = name;\n\t\twl_output_add_listener(surface->output, &_wl_output_listener, surface);\n\t\twl_list_insert(&state->surfaces, &surface->link);\n\n\t\tif (state->run_display) {\n\t\t\tcreate_surface(surface);\n\t\t\twl_display_roundtrip(state->display);\n\t\t}\n\t} else if (strcmp(interface, ext_session_lock_manager_v1_interface.name) == 0) {\n\t\tstate->ext_session_lock_manager_v1 = wl_registry_bind(registry, name,\n\t\t\t\t&ext_session_lock_manager_v1_interface, 1);\n\t}\n}",
  "abstract_func": "static void handle_global(void *VAR_0, struct wl_registry *VAR_1,\n\t\tuint32_t VAR_2, const char *VAR_3, uint32_t VAR_4) {\n\tstruct swaylock_state *VAR_5 = VAR_0;\n\tif (strcmp(VAR_3, VAR_6.name) == 0) {\n\t\tVAR_5->compositor = wl_registry_bind(VAR_1, VAR_2,\n\t\t\t\t&VAR_6, 4);\n\t} else if (strcmp(VAR_3, VAR_7.name) == 0) {\n\t\tVAR_5->subcompositor = wl_registry_bind(VAR_1, VAR_2,\n\t\t\t\t&VAR_7, 1);\n\t} else if (strcmp(VAR_3, VAR_8.name) == 0) {\n\t\tVAR_5->shm = wl_registry_bind(VAR_1, VAR_2,\n\t\t\t\t&VAR_8, 1);\n\t} else if (strcmp(VAR_3, VAR_9.name) == 0) {\n\t\tstruct wl_seat *VAR_10 = wl_registry_bind(\n\t\t\t\tVAR_1, VAR_2, &VAR_9, 4);\n\t\tstruct swaylock_seat *swaylock_seat =\n\t\t\tcalloc(1, sizeof(struct swaylock_seat));\n\t\tswaylock_seat->state = VAR_5;\n\t\twl_seat_add_listener(VAR_10, &VAR_11, swaylock_seat);\n\t} else if (strcmp(VAR_3, VAR_12.name) == 0) {\n\t\tVAR_5->layer_shell = wl_registry_bind(\n\t\t\t\tVAR_1, VAR_2, &VAR_12, 1);\n\t} else if (strcmp(VAR_3, VAR_13.name) == 0) {\n\t\tVAR_5->input_inhibit_manager = wl_registry_bind(\n\t\t\t\tVAR_1, VAR_2, &VAR_13, 1);\n\t} else if (strcmp(VAR_3, VAR_14.name) == 0) {\n\t\tVAR_5->zxdg_output_manager = wl_registry_bind(\n\t\t\t\tVAR_1, VAR_2, &VAR_14, 2);\n\t} else if (strcmp(VAR_3, VAR_15.name) == 0) {\n\t\tstruct swaylock_surface *VAR_16 =\n\t\t\tcalloc(1, sizeof(struct swaylock_surface));\n\t\tVAR_16->state = VAR_5;\n\t\tVAR_16->output = wl_registry_bind(VAR_1, VAR_2,\n\t\t\t\t&VAR_15, 3);\n\t\tVAR_16->output_global_name = VAR_2;\n\t\twl_output_add_listener(VAR_16->output, &VAR_17, VAR_16);\n\t\twl_list_insert(&VAR_5->surfaces, &VAR_16->link);\n\n\t\tif (VAR_5->run_display) {\n\t\t\tcreate_surface(VAR_16);\n\t\t\twl_display_roundtrip(VAR_5->display);\n\t\t}\n\t} else if (strcmp(VAR_3, VAR_18.name) == 0) {\n\t\tVAR_5->ext_session_lock_manager_v1 = wl_registry_bind(VAR_1, VAR_2,\n\t\t\t\t&VAR_18, 1);\n\t}\n}",
  "func_graph_path": "swaywm/swaylock/1d1c75b6316d21933069a9d201f966d84099f6ca/main.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -37,8 +37,11 @@\n \t\twl_list_insert(&state->surfaces, &surface->link);\n \n \t\tif (state->run_display) {\n-\t\t\tcreate_layer_surface(surface);\n+\t\t\tcreate_surface(surface);\n \t\t\twl_display_roundtrip(state->display);\n \t\t}\n+\t} else if (strcmp(interface, ext_session_lock_manager_v1_interface.name) == 0) {\n+\t\tstate->ext_session_lock_manager_v1 = wl_registry_bind(registry, name,\n+\t\t\t\t&ext_session_lock_manager_v1_interface, 1);\n \t}\n }",
  "diff_line_info": {
    "deleted_lines": [
      "\t\t\tcreate_layer_surface(surface);"
    ],
    "added_lines": [
      "\t\t\tcreate_surface(surface);",
      "\t} else if (strcmp(interface, ext_session_lock_manager_v1_interface.name) == 0) {",
      "\t\tstate->ext_session_lock_manager_v1 = wl_registry_bind(registry, name,",
      "\t\t\t\t&ext_session_lock_manager_v1_interface, 1);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/swaywm/swaylock/pull/219",
  "description": {
    "pr_info": {
      "title": "Add support for ext-session-lock-v1 ",
      "number": 219
    },
    "comment": [
      "This is a new protocol to lock the session [1]. It should be more\r\nreliable than layer-shell + input-inhibitor.\r\n\r\n- [x] Bump wayland-protocols dep version\r\n\r\n[1]: https://gitlab.freedesktop.org/wayland/wayland-protocols/-/merge_requests/131\r\n\r\nTo build locally:\r\n\r\n```sh\r\nmkdir subprojects\r\ngit clone \"git@gitlab.freedesktop.org:ifreund/wayland-protocols.git\" -b ext-lock-v1 subprojects/wayland-protocols\r\nmeson configure build/ --force-fallback-for=wayland-protocols\r\n```",
      "Addressed the comments, thanks for the review!"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.85,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch introduces support for a new session locking protocol, which improves reliability over existing methods. The code changes involve binding to a new interface, indicating a functional update rather than a security fix. No evidence suggests a security vulnerability was addressed.\n\nFinal Classification: Defect Remediation & Feature Upgrades\n\nConfidence Score: 0.85"
}