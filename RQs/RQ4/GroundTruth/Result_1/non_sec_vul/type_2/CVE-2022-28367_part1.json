{
  "cve_id": "CVE-2022-28367",
  "cwe_ids": [
    "CWE-79"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "nahsra/antisamy",
  "commit_msg": "Support multiple children handling on style tags",
  "commit_hash": "0199e7e194dba5e7d7197703f43ebe22401e61ae",
  "git_url": "https://github.com/nahsra/antisamy/commit/0199e7e194dba5e7d7197703f43ebe22401e61ae",
  "file_path": "src/main/java/org/owasp/validator/html/scan/AntiSamyDOMScanner.java",
  "func_name": "processStyleTag",
  "func_before": "private boolean processStyleTag(Element ele, Node parentNode) {\n        /*\n         * Invoke the css parser on this element.\n         */\n        CssScanner styleScanner = new CssScanner(policy, messages, policy.isEmbedStyleSheets());\n\n        try {\n            Node firstChild = ele.getFirstChild();\n            if (firstChild != null) {\n\n                String toScan = firstChild.getNodeValue();\n                CleanResults cr = styleScanner.scanStyleSheet(toScan, policy.getMaxInputSize());\n                errorMessages.addAll(cr.getErrorMessages());\n\n                /*\n                 * If IE gets an empty style tag, i.e. <style/> it will\n                 * break all CSS on the page. I wish I was kidding. So,\n                 * if after validation no CSS properties are left, we\n                 * would normally be left with an empty style tag and\n                 * break all CSS. To prevent that, we have this check.\n                 */\n\n                final String cleanHTML = cr.getCleanHTML();\n\n                if (cleanHTML == null || cleanHTML.equals(\"\")) {\n                    firstChild.setNodeValue(\"/* */\");\n                } else {\n                    firstChild.setNodeValue(cleanHTML);\n                }\n            }\n\n        } catch (DOMException | ScanException | ParseException | NumberFormatException e) {\n\n            /*\n             * ParseException shouldn't be possible anymore, but we'll leave it\n             * here because I (Arshan) am hilariously dumb sometimes.\n             * Batik can throw NumberFormatExceptions (see bug #48).\n             */\n\n            addError(ErrorMessageUtil.ERROR_CSS_TAG_MALFORMED, new Object[]{HTMLEntityEncoder.htmlEntityEncode(ele.getFirstChild().getNodeValue())});\n            parentNode.removeChild(ele);\n            return true;\n        }\n        return false;\n    }",
  "abstract_func_before": "private boolean processStyleTag(Element VAR_0, Node VAR_1) {\n        /* COMMENT_0 */\n                                                 \n           \n        CssScanner VAR_2 = new CssScanner(VAR_3, VAR_4, VAR_3.isEmbedStyleSheets());\n\n        try {\n            Node VAR_5 = VAR_0.getFirstChild();\n            if (VAR_5 != null) {\n\n                String VAR_6 = VAR_5.getNodeValue();\n                CleanResults VAR_7 = VAR_2.scanStyleSheet(VAR_6, VAR_3.getMaxInputSize());\n                VAR_8.addAll(VAR_7.getErrorMessages());\n\n                /* COMMENT_3 */\n                                                                       \n                                                                       \n                                                                     \n                                                                     \n                                                                      \n                   \n\n                final String VAR_9 = VAR_7.getCleanHTML();\n\n                if (VAR_9 == null || VAR_9.equals(\"\")) {\n                    VAR_5.setNodeValue(\"/* */\");\n                } else {\n                    VAR_5.setNodeValue(VAR_9);\n                }\n            }\n\n        } catch (DOMException | ScanException | ParseException | NumberFormatException VAR_10) {\n\n            /* COMMENT_10 */\n                                                                               \n                                                                     \n                                                                    \n               \n\n            addError(VAR_11.ERROR_CSS_TAG_MALFORMED, new Object[]{VAR_12.htmlEntityEncode(VAR_0.getFirstChild().getNodeValue())});\n            VAR_1.removeChild(VAR_0);\n            return true;\n        }\n        return false;\n    }",
  "func_graph_path_before": "nahsra/antisamy/0199e7e194dba5e7d7197703f43ebe22401e61ae/AntiSamyDOMScanner.java/vul/before/0.json",
  "func": "private boolean processStyleTag(Element ele, Node parentNode) {\n        /*\n         * Invoke the css parser on this element.\n         */\n        CssScanner styleScanner = new CssScanner(policy, messages, policy.isEmbedStyleSheets());\n\n        try {\n            if (ele.getChildNodes().getLength() > 0) {\n                String toScan = \"\";\n\n                for (int i = 0; i < ele.getChildNodes().getLength(); i++) {\n                    Node childNode = ele.getChildNodes().item(i);\n                    if (!toScan.isEmpty()){\n                        toScan += \"\\n\";\n                    }\n                    toScan += childNode.getTextContent();\n                }\n\n                CleanResults cr = styleScanner.scanStyleSheet(toScan, policy.getMaxInputSize());\n                errorMessages.addAll(cr.getErrorMessages());\n\n                /*\n                 * If IE gets an empty style tag, i.e. <style/> it will\n                 * break all CSS on the page. I wish I was kidding. So,\n                 * if after validation no CSS properties are left, we\n                 * would normally be left with an empty style tag and\n                 * break all CSS. To prevent that, we have this check.\n                 */\n\n                String cleanHTML = cr.getCleanHTML();\n                cleanHTML = cleanHTML == null || cleanHTML.equals(\"\") ? \"/* */\" : cleanHTML;\n\n                ele.getFirstChild().setNodeValue(cleanHTML);\n                /*\n                 * Remove every other node after cleaning CSS, there will\n                 * be only one node in the end, as it always should have.\n                 */\n                for (int i = 1; i < ele.getChildNodes().getLength(); i++) {\n                    Node childNode = ele.getChildNodes().item(i);\n                    ele.removeChild(childNode);\n                }\n            }\n\n        } catch (DOMException | ScanException | ParseException | NumberFormatException e) {\n\n            /*\n             * ParseException shouldn't be possible anymore, but we'll leave it\n             * here because I (Arshan) am hilariously dumb sometimes.\n             * Batik can throw NumberFormatExceptions (see bug #48).\n             */\n\n            addError(ErrorMessageUtil.ERROR_CSS_TAG_MALFORMED, new Object[]{HTMLEntityEncoder.htmlEntityEncode(ele.getFirstChild().getNodeValue())});\n            parentNode.removeChild(ele);\n            return true;\n        }\n        return false;\n    }",
  "abstract_func": "private boolean processStyleTag(Element VAR_0, Node VAR_1) {\n        /* COMMENT_0 */\n                                                 \n           \n        CssScanner VAR_2 = new CssScanner(VAR_3, VAR_4, VAR_3.isEmbedStyleSheets());\n\n        try {\n            if (VAR_0.getChildNodes().getLength() > 0) {\n                String VAR_5 = \"\";\n\n                for (int VAR_6 = 0; VAR_6 < VAR_0.getChildNodes().getLength(); VAR_6++) {\n                    Node VAR_7 = VAR_0.getChildNodes().item(VAR_6);\n                    if (!VAR_5.isEmpty()){\n                        VAR_5 += \"\\n\";\n                    }\n                    VAR_5 += VAR_7.getTextContent();\n                }\n\n                CleanResults VAR_8 = VAR_2.scanStyleSheet(VAR_5, VAR_3.getMaxInputSize());\n                VAR_9.addAll(VAR_8.getErrorMessages());\n\n                /* COMMENT_3 */\n                                                                       \n                                                                       \n                                                                     \n                                                                     \n                                                                      \n                   \n\n                String VAR_10 = VAR_8.getCleanHTML();\n                VAR_10 = VAR_10 == null || VAR_10.equals(\"\") ? \"/* */\" : VAR_10;\n\n                VAR_0.getFirstChild().setNodeValue(VAR_10);\n                /* COMMENT_10 */\n                                                                         \n                                                                         \n                   \n                for (int VAR_6 = 1; VAR_6 < VAR_0.getChildNodes().getLength(); VAR_6++) {\n                    Node VAR_7 = VAR_0.getChildNodes().item(VAR_6);\n                    VAR_0.removeChild(VAR_7);\n                }\n            }\n\n        } catch (DOMException | ScanException | ParseException | NumberFormatException VAR_11) {\n\n            /* COMMENT_14 */\n                                                                               \n                                                                     \n                                                                    \n               \n\n            addError(VAR_12.ERROR_CSS_TAG_MALFORMED, new Object[]{VAR_13.htmlEntityEncode(VAR_0.getFirstChild().getNodeValue())});\n            VAR_1.removeChild(VAR_0);\n            return true;\n        }\n        return false;\n    }",
  "func_graph_path": "nahsra/antisamy/0199e7e194dba5e7d7197703f43ebe22401e61ae/AntiSamyDOMScanner.java/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -5,10 +5,17 @@\n         CssScanner styleScanner = new CssScanner(policy, messages, policy.isEmbedStyleSheets());\n \n         try {\n-            Node firstChild = ele.getFirstChild();\n-            if (firstChild != null) {\n+            if (ele.getChildNodes().getLength() > 0) {\n+                String toScan = \"\";\n \n-                String toScan = firstChild.getNodeValue();\n+                for (int i = 0; i < ele.getChildNodes().getLength(); i++) {\n+                    Node childNode = ele.getChildNodes().item(i);\n+                    if (!toScan.isEmpty()){\n+                        toScan += \"\\n\";\n+                    }\n+                    toScan += childNode.getTextContent();\n+                }\n+\n                 CleanResults cr = styleScanner.scanStyleSheet(toScan, policy.getMaxInputSize());\n                 errorMessages.addAll(cr.getErrorMessages());\n \n@@ -20,12 +27,17 @@\n                  * break all CSS. To prevent that, we have this check.\n                  */\n \n-                final String cleanHTML = cr.getCleanHTML();\n+                String cleanHTML = cr.getCleanHTML();\n+                cleanHTML = cleanHTML == null || cleanHTML.equals(\"\") ? \"/* */\" : cleanHTML;\n \n-                if (cleanHTML == null || cleanHTML.equals(\"\")) {\n-                    firstChild.setNodeValue(\"/* */\");\n-                } else {\n-                    firstChild.setNodeValue(cleanHTML);\n+                ele.getFirstChild().setNodeValue(cleanHTML);\n+                /*\n+                 * Remove every other node after cleaning CSS, there will\n+                 * be only one node in the end, as it always should have.\n+                 */\n+                for (int i = 1; i < ele.getChildNodes().getLength(); i++) {\n+                    Node childNode = ele.getChildNodes().item(i);\n+                    ele.removeChild(childNode);\n                 }\n             }\n ",
  "diff_line_info": {
    "deleted_lines": [
      "            Node firstChild = ele.getFirstChild();",
      "            if (firstChild != null) {",
      "                String toScan = firstChild.getNodeValue();",
      "                final String cleanHTML = cr.getCleanHTML();",
      "                if (cleanHTML == null || cleanHTML.equals(\"\")) {",
      "                    firstChild.setNodeValue(\"/* */\");",
      "                } else {",
      "                    firstChild.setNodeValue(cleanHTML);"
    ],
    "added_lines": [
      "            if (ele.getChildNodes().getLength() > 0) {",
      "                String toScan = \"\";",
      "                for (int i = 0; i < ele.getChildNodes().getLength(); i++) {",
      "                    Node childNode = ele.getChildNodes().item(i);",
      "                    if (!toScan.isEmpty()){",
      "                        toScan += \"\\n\";",
      "                    }",
      "                    toScan += childNode.getTextContent();",
      "                }",
      "",
      "                String cleanHTML = cr.getCleanHTML();",
      "                cleanHTML = cleanHTML == null || cleanHTML.equals(\"\") ? \"/* */\" : cleanHTML;",
      "                ele.getFirstChild().setNodeValue(cleanHTML);",
      "                /*",
      "                 * Remove every other node after cleaning CSS, there will",
      "                 * be only one node in the end, as it always should have.",
      "                 */",
      "                for (int i = 1; i < ele.getChildNodes().getLength(); i++) {",
      "                    Node childNode = ele.getChildNodes().item(i);",
      "                    ele.removeChild(childNode);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/nahsra/antisamy/pull/162",
  "description": {
    "pr_info": {
      "title": "Changes for 1.6.6 release",
      "number": 162
    },
    "comment": [
      "- Update NekoHTML and other dependencies to work with Java 8.\r\n- Add require-closing-tags to default schema.\r\n- Add deprecated annotations for XHTML.\r\n- Support multiple children handling on `style` tags.\r\n- Improve test coverage.",
      "Yes, it was reported in 1.6.5 for error messages on CSS scans that were not\nappearing in the result. Recent issue.\n\nOn Sat, 2 Apr 2022 at 11:17 Dave Wichers ***@***.***> wrote:\n\n> ***@***.**** commented on this pull request.\n> ------------------------------\n>\n> In src/main/java/org/owasp/validator/css/CssHandler.java\n> <https://github.com/nahsra/antisamy/pull/162#discussion_r841081557>:\n>\n> > @@ -167,7 +167,7 @@ public CssHandler(Policy policy, List<String> errorMessages, ResourceBundle mess\n>  \t *            the tag name associated with this inline style\n>  \t */\n>  \tpublic CssHandler(Policy policy, List<String> errorMessages, ResourceBundle messages, String tagName) {\n> -\t\tthis(policy, null, new ArrayList<String>(), tagName, messages);\n> +\t\tthis(policy, null, errorMessages, tagName, messages);\n>\n> Was this just a bug in AntiSamy 1.6.5 or earlier?\n>\n> â€”\n> Reply to this email directly, view it on GitHub\n> <https://github.com/nahsra/antisamy/pull/162#pullrequestreview-929574745>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AHL3BMKJZSY522FVKX37XGTVDBJGZANCNFSM5SKAQ4FA>\n> .\n> You are receiving this because you authored the thread.Message ID:\n> ***@***.***>\n>\n"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.85,
  "Bug Filter Response": "\n\nThe patch addresses a functional issue in handling multiple child nodes within style tags, which resolved an error in CSS processing. While this could have had security implications, the evidence isn't sufficient to classify it as a security fix.\n\n**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence Score:** 0.85"
}