{
  "cve_id": "CVE-2016-8568",
  "cwe_ids": [
    "CWE-476",
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "libgit2",
  "commit_msg": "commit: always initialize commit message\n\nWhen parsing a commit, we will treat all bytes left after parsing\nthe headers as the commit message. When no bytes are left, we\nleave the commit's message uninitialized. While uncommon to have\na commit without message, this is the right behavior as Git\nunfortunately allows for empty commit messages.\n\nGiven that this scenario is so uncommon, most programs acting on\nthe commit message will never check if the message is actually\nset, which may lead to errors. To work around the error and not\nlay the burden of checking for empty commit messages to the\ndeveloper, initialize the commit message with an empty string\nwhen no commit message is given.",
  "commit_hash": "a719ef5e6d4a1a8ec53469c7914032ed67922772",
  "git_url": "https://github.com/libgit2/libgit2/commit/a719ef5e6d4a1a8ec53469c7914032ed67922772",
  "file_path": "src/commit.c",
  "func_name": "git_commit__parse",
  "func_before": "int git_commit__parse(void *_commit, git_odb_object *odb_obj)\n{\n\tgit_commit *commit = _commit;\n\tconst char *buffer_start = git_odb_object_data(odb_obj), *buffer;\n\tconst char *buffer_end = buffer_start + git_odb_object_size(odb_obj);\n\tgit_oid parent_id;\n\tsize_t header_len;\n\tgit_signature dummy_sig;\n\n\tbuffer = buffer_start;\n\n\t/* Allocate for one, which will allow not to realloc 90% of the time  */\n\tgit_array_init_to_size(commit->parent_ids, 1);\n\tGITERR_CHECK_ARRAY(commit->parent_ids);\n\n\t/* The tree is always the first field */\n\tif (git_oid__parse(&commit->tree_id, &buffer, buffer_end, \"tree \") < 0)\n\t\tgoto bad_buffer;\n\n\t/*\n\t * TODO: commit grafts!\n\t */\n\n\twhile (git_oid__parse(&parent_id, &buffer, buffer_end, \"parent \") == 0) {\n\t\tgit_oid *new_id = git_array_alloc(commit->parent_ids);\n\t\tGITERR_CHECK_ALLOC(new_id);\n\n\t\tgit_oid_cpy(new_id, &parent_id);\n\t}\n\n\tcommit->author = git__malloc(sizeof(git_signature));\n\tGITERR_CHECK_ALLOC(commit->author);\n\n\tif (git_signature__parse(commit->author, &buffer, buffer_end, \"author \", '\\n') < 0)\n\t\treturn -1;\n\n\t/* Some tools create multiple author fields, ignore the extra ones */\n\twhile ((size_t)(buffer_end - buffer) >= strlen(\"author \") && !git__prefixcmp(buffer, \"author \")) {\n\t\tif (git_signature__parse(&dummy_sig, &buffer, buffer_end, \"author \", '\\n') < 0)\n\t\t\treturn -1;\n\n\t\tgit__free(dummy_sig.name);\n\t\tgit__free(dummy_sig.email);\n\t}\n\n\t/* Always parse the committer; we need the commit time */\n\tcommit->committer = git__malloc(sizeof(git_signature));\n\tGITERR_CHECK_ALLOC(commit->committer);\n\n\tif (git_signature__parse(commit->committer, &buffer, buffer_end, \"committer \", '\\n') < 0)\n\t\treturn -1;\n\n\t/* Parse add'l header entries */\n\twhile (buffer < buffer_end) {\n\t\tconst char *eoln = buffer;\n\t\tif (buffer[-1] == '\\n' && buffer[0] == '\\n')\n\t\t\tbreak;\n\n\t\twhile (eoln < buffer_end && *eoln != '\\n')\n\t\t\t++eoln;\n\n\t\tif (git__prefixcmp(buffer, \"encoding \") == 0) {\n\t\t\tbuffer += strlen(\"encoding \");\n\n\t\t\tcommit->message_encoding = git__strndup(buffer, eoln - buffer);\n\t\t\tGITERR_CHECK_ALLOC(commit->message_encoding);\n\t\t}\n\n\t\tif (eoln < buffer_end && *eoln == '\\n')\n\t\t\t++eoln;\n\t\tbuffer = eoln;\n\t}\n\n\theader_len = buffer - buffer_start;\n\tcommit->raw_header = git__strndup(buffer_start, header_len);\n\tGITERR_CHECK_ALLOC(commit->raw_header);\n\n\t/* point \"buffer\" to data after header, +1 for the final LF */\n\tbuffer = buffer_start + header_len + 1;\n\n\t/* extract commit message */\n\tif (buffer <= buffer_end) {\n\t\tcommit->raw_message = git__strndup(buffer, buffer_end - buffer);\n\t\tGITERR_CHECK_ALLOC(commit->raw_message);\n\t}\n\n\treturn 0;\n\nbad_buffer:\n\tgiterr_set(GITERR_OBJECT, \"Failed to parse bad commit object\");\n\treturn -1;\n}",
  "abstract_func_before": "int git_commit__parse(void *VAR_0, git_odb_object *VAR_1)\n{\n\tgit_commit *VAR_2 = VAR_0;\n\tconst char *VAR_3 = git_odb_object_data(VAR_1), *VAR_4;\n\tconst char *VAR_5 = VAR_3 + git_odb_object_size(VAR_1);\n\tgit_oid VAR_6;\n\tsize_t VAR_7;\n\tgit_signature VAR_8;\n\n\tVAR_4 = VAR_3;\n\n\t/* COMMENT_0 */\n\tgit_array_init_to_size(VAR_2->parent_ids, 1);\n\tGITERR_CHECK_ARRAY(VAR_2->parent_ids);\n\n\t/* COMMENT_1 */\n\tif (git_oid__parse(&VAR_2->tree_id, &VAR_4, VAR_5, \"tree \") < 0)\n\t\tgoto bad_buffer;\n\n\t/* COMMENT_2 */\n                        \n    \n\n\twhile (git_oid__parse(&VAR_6, &VAR_4, VAR_5, \"parent \") == 0) {\n\t\tgit_oid *VAR_9 = git_array_alloc(VAR_2->parent_ids);\n\t\tGITERR_CHECK_ALLOC(VAR_9);\n\n\t\tgit_oid_cpy(VAR_9, &VAR_6);\n\t}\n\n\tVAR_2->author = git__malloc(sizeof(git_signature));\n\tGITERR_CHECK_ALLOC(VAR_2->author);\n\n\tif (git_signature__parse(VAR_2->author, &VAR_4, VAR_5, \"author \", '\\n') < 0)\n\t\treturn -1;\n\n\t/* COMMENT_5 */\n\twhile ((size_t)(VAR_5 - VAR_4) >= strlen(\"author \") && !git__prefixcmp(VAR_4, \"author \")) {\n\t\tif (git_signature__parse(&VAR_8, &VAR_4, VAR_5, \"author \", '\\n') < 0)\n\t\t\treturn -1;\n\n\t\tgit__free(VAR_8.name);\n\t\tgit__free(VAR_8.email);\n\t}\n\n\t/* COMMENT_6 */\n\tVAR_2->committer = git__malloc(sizeof(git_signature));\n\tGITERR_CHECK_ALLOC(VAR_2->committer);\n\n\tif (git_signature__parse(VAR_2->committer, &VAR_4, VAR_5, \"committer \", '\\n') < 0)\n\t\treturn -1;\n\n\t/* COMMENT_7 */\n\twhile (VAR_4 < VAR_5) {\n\t\tconst char *VAR_10 = VAR_4;\n\t\tif (VAR_4[-1] == '\\n' && VAR_4[0] == '\\n')\n\t\t\tbreak;\n\n\t\twhile (VAR_10 < VAR_5 && *VAR_10 != '\\n')\n\t\t\t++VAR_10;\n\n\t\tif (git__prefixcmp(VAR_4, \"encoding \") == 0) {\n\t\t\tVAR_4 += strlen(\"encoding \");\n\n\t\t\tVAR_2->message_encoding = git__strndup(VAR_4, VAR_10 - VAR_4);\n\t\t\tGITERR_CHECK_ALLOC(VAR_2->message_encoding);\n\t\t}\n\n\t\tif (VAR_10 < VAR_5 && *VAR_10 == '\\n')\n\t\t\t++VAR_10;\n\t\tVAR_4 = VAR_10;\n\t}\n\n\tVAR_7 = VAR_4 - VAR_3;\n\tVAR_2->raw_header = git__strndup(VAR_3, VAR_7);\n\tGITERR_CHECK_ALLOC(VAR_2->raw_header);\n\n\t/* COMMENT_8 */\n\tVAR_4 = VAR_3 + VAR_7 + 1;\n\n\t/* COMMENT_9 */\n\tif (VAR_4 <= VAR_5) {\n\t\tVAR_2->raw_message = git__strndup(VAR_4, VAR_5 - VAR_4);\n\t\tGITERR_CHECK_ALLOC(VAR_2->raw_message);\n\t}\n\n\treturn 0;\n\nbad_buffer:\n\tgiterr_set(VAR_11, \"Failed to parse bad commit object\");\n\treturn -1;\n}",
  "func_graph_path_before": "libgit2/a719ef5e6d4a1a8ec53469c7914032ed67922772/commit.c/vul/before/0.json",
  "func": "int git_commit__parse(void *_commit, git_odb_object *odb_obj)\n{\n\tgit_commit *commit = _commit;\n\tconst char *buffer_start = git_odb_object_data(odb_obj), *buffer;\n\tconst char *buffer_end = buffer_start + git_odb_object_size(odb_obj);\n\tgit_oid parent_id;\n\tsize_t header_len;\n\tgit_signature dummy_sig;\n\n\tbuffer = buffer_start;\n\n\t/* Allocate for one, which will allow not to realloc 90% of the time  */\n\tgit_array_init_to_size(commit->parent_ids, 1);\n\tGITERR_CHECK_ARRAY(commit->parent_ids);\n\n\t/* The tree is always the first field */\n\tif (git_oid__parse(&commit->tree_id, &buffer, buffer_end, \"tree \") < 0)\n\t\tgoto bad_buffer;\n\n\t/*\n\t * TODO: commit grafts!\n\t */\n\n\twhile (git_oid__parse(&parent_id, &buffer, buffer_end, \"parent \") == 0) {\n\t\tgit_oid *new_id = git_array_alloc(commit->parent_ids);\n\t\tGITERR_CHECK_ALLOC(new_id);\n\n\t\tgit_oid_cpy(new_id, &parent_id);\n\t}\n\n\tcommit->author = git__malloc(sizeof(git_signature));\n\tGITERR_CHECK_ALLOC(commit->author);\n\n\tif (git_signature__parse(commit->author, &buffer, buffer_end, \"author \", '\\n') < 0)\n\t\treturn -1;\n\n\t/* Some tools create multiple author fields, ignore the extra ones */\n\twhile ((size_t)(buffer_end - buffer) >= strlen(\"author \") && !git__prefixcmp(buffer, \"author \")) {\n\t\tif (git_signature__parse(&dummy_sig, &buffer, buffer_end, \"author \", '\\n') < 0)\n\t\t\treturn -1;\n\n\t\tgit__free(dummy_sig.name);\n\t\tgit__free(dummy_sig.email);\n\t}\n\n\t/* Always parse the committer; we need the commit time */\n\tcommit->committer = git__malloc(sizeof(git_signature));\n\tGITERR_CHECK_ALLOC(commit->committer);\n\n\tif (git_signature__parse(commit->committer, &buffer, buffer_end, \"committer \", '\\n') < 0)\n\t\treturn -1;\n\n\t/* Parse add'l header entries */\n\twhile (buffer < buffer_end) {\n\t\tconst char *eoln = buffer;\n\t\tif (buffer[-1] == '\\n' && buffer[0] == '\\n')\n\t\t\tbreak;\n\n\t\twhile (eoln < buffer_end && *eoln != '\\n')\n\t\t\t++eoln;\n\n\t\tif (git__prefixcmp(buffer, \"encoding \") == 0) {\n\t\t\tbuffer += strlen(\"encoding \");\n\n\t\t\tcommit->message_encoding = git__strndup(buffer, eoln - buffer);\n\t\t\tGITERR_CHECK_ALLOC(commit->message_encoding);\n\t\t}\n\n\t\tif (eoln < buffer_end && *eoln == '\\n')\n\t\t\t++eoln;\n\t\tbuffer = eoln;\n\t}\n\n\theader_len = buffer - buffer_start;\n\tcommit->raw_header = git__strndup(buffer_start, header_len);\n\tGITERR_CHECK_ALLOC(commit->raw_header);\n\n\t/* point \"buffer\" to data after header, +1 for the final LF */\n\tbuffer = buffer_start + header_len + 1;\n\n\t/* extract commit message */\n\tif (buffer <= buffer_end)\n\t\tcommit->raw_message = git__strndup(buffer, buffer_end - buffer);\n\telse\n\t\tcommit->raw_message = git__strdup(\"\");\n\tGITERR_CHECK_ALLOC(commit->raw_message);\n\n\treturn 0;\n\nbad_buffer:\n\tgiterr_set(GITERR_OBJECT, \"Failed to parse bad commit object\");\n\treturn -1;\n}",
  "abstract_func": "int git_commit__parse(void *VAR_0, git_odb_object *VAR_1)\n{\n\tgit_commit *VAR_2 = VAR_0;\n\tconst char *VAR_3 = git_odb_object_data(VAR_1), *VAR_4;\n\tconst char *VAR_5 = VAR_3 + git_odb_object_size(VAR_1);\n\tgit_oid VAR_6;\n\tsize_t VAR_7;\n\tgit_signature VAR_8;\n\n\tVAR_4 = VAR_3;\n\n\t/* COMMENT_0 */\n\tgit_array_init_to_size(VAR_2->parent_ids, 1);\n\tGITERR_CHECK_ARRAY(VAR_2->parent_ids);\n\n\t/* COMMENT_1 */\n\tif (git_oid__parse(&VAR_2->tree_id, &VAR_4, VAR_5, \"tree \") < 0)\n\t\tgoto bad_buffer;\n\n\t/* COMMENT_2 */\n                        \n    \n\n\twhile (git_oid__parse(&VAR_6, &VAR_4, VAR_5, \"parent \") == 0) {\n\t\tgit_oid *VAR_9 = git_array_alloc(VAR_2->parent_ids);\n\t\tGITERR_CHECK_ALLOC(VAR_9);\n\n\t\tgit_oid_cpy(VAR_9, &VAR_6);\n\t}\n\n\tVAR_2->author = git__malloc(sizeof(git_signature));\n\tGITERR_CHECK_ALLOC(VAR_2->author);\n\n\tif (git_signature__parse(VAR_2->author, &VAR_4, VAR_5, \"author \", '\\n') < 0)\n\t\treturn -1;\n\n\t/* COMMENT_5 */\n\twhile ((size_t)(VAR_5 - VAR_4) >= strlen(\"author \") && !git__prefixcmp(VAR_4, \"author \")) {\n\t\tif (git_signature__parse(&VAR_8, &VAR_4, VAR_5, \"author \", '\\n') < 0)\n\t\t\treturn -1;\n\n\t\tgit__free(VAR_8.name);\n\t\tgit__free(VAR_8.email);\n\t}\n\n\t/* COMMENT_6 */\n\tVAR_2->committer = git__malloc(sizeof(git_signature));\n\tGITERR_CHECK_ALLOC(VAR_2->committer);\n\n\tif (git_signature__parse(VAR_2->committer, &VAR_4, VAR_5, \"committer \", '\\n') < 0)\n\t\treturn -1;\n\n\t/* COMMENT_7 */\n\twhile (VAR_4 < VAR_5) {\n\t\tconst char *VAR_10 = VAR_4;\n\t\tif (VAR_4[-1] == '\\n' && VAR_4[0] == '\\n')\n\t\t\tbreak;\n\n\t\twhile (VAR_10 < VAR_5 && *VAR_10 != '\\n')\n\t\t\t++VAR_10;\n\n\t\tif (git__prefixcmp(VAR_4, \"encoding \") == 0) {\n\t\t\tVAR_4 += strlen(\"encoding \");\n\n\t\t\tVAR_2->message_encoding = git__strndup(VAR_4, VAR_10 - VAR_4);\n\t\t\tGITERR_CHECK_ALLOC(VAR_2->message_encoding);\n\t\t}\n\n\t\tif (VAR_10 < VAR_5 && *VAR_10 == '\\n')\n\t\t\t++VAR_10;\n\t\tVAR_4 = VAR_10;\n\t}\n\n\tVAR_7 = VAR_4 - VAR_3;\n\tVAR_2->raw_header = git__strndup(VAR_3, VAR_7);\n\tGITERR_CHECK_ALLOC(VAR_2->raw_header);\n\n\t/* COMMENT_8 */\n\tVAR_4 = VAR_3 + VAR_7 + 1;\n\n\t/* COMMENT_9 */\n\tif (VAR_4 <= VAR_5)\n\t\tVAR_2->raw_message = git__strndup(VAR_4, VAR_5 - VAR_4);\n\telse\n\t\tVAR_2->raw_message = git__strdup(\"\");\n\tGITERR_CHECK_ALLOC(VAR_2->raw_message);\n\n\treturn 0;\n\nbad_buffer:\n\tgiterr_set(VAR_11, \"Failed to parse bad commit object\");\n\treturn -1;\n}",
  "func_graph_path": "libgit2/a719ef5e6d4a1a8ec53469c7914032ed67922772/commit.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -79,10 +79,11 @@\n \tbuffer = buffer_start + header_len + 1;\n \n \t/* extract commit message */\n-\tif (buffer <= buffer_end) {\n+\tif (buffer <= buffer_end)\n \t\tcommit->raw_message = git__strndup(buffer, buffer_end - buffer);\n-\t\tGITERR_CHECK_ALLOC(commit->raw_message);\n-\t}\n+\telse\n+\t\tcommit->raw_message = git__strdup(\"\");\n+\tGITERR_CHECK_ALLOC(commit->raw_message);\n \n \treturn 0;\n ",
  "diff_line_info": {
    "deleted_lines": [
      "\tif (buffer <= buffer_end) {",
      "\t\tGITERR_CHECK_ALLOC(commit->raw_message);",
      "\t}"
    ],
    "added_lines": [
      "\tif (buffer <= buffer_end)",
      "\telse",
      "\t\tcommit->raw_message = git__strdup(\"\");",
      "\tGITERR_CHECK_ALLOC(commit->raw_message);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libgit2/libgit2/pull/3956",
  "description": {
    "pr_info": {
      "title": "Object parsing hardening",
      "number": 3956
    },
    "comment": [
      "See the commit messages for more info. These commits fix #3936 and #3937. I bet there are more issues around here which I'd like to find. I think I'll try some more fuzzing with AFL around the object-parsing logic sometimes soon.\n",
      "By the way: is there some test logic for directly parsing raw objects? I didn't spot any while skimming the tests, but obviously it would be nice to  have these fixes backed by some tests.\n",
      "Thanks!\n"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "\n\nThe patch addresses a bug where the commit message wasn't initialized when absent, preventing potential errors. While part of a security hardening effort, the change itself doesn't fix a security vulnerability.\n\n**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence Score:** 0.8"
}