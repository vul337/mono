{
  "cve_id": "CVE-2021-32846",
  "cwe_ids": [
    "CWE-754"
  ],
  "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "moby/hyperkit",
  "commit_msg": "Fix virtio-sock pci_vtsock_proc_tx uninitialized memory use (GHSL-2021-057)\n\nSigned-off-by: Frederic Dalleau <frederic.dalleau@docker.com>",
  "commit_hash": "af5eba2360a7351c08dfd9767d9be863a50ebaba",
  "git_url": "https://github.com/moby/hyperkit/commit/af5eba2360a7351c08dfd9767d9be863a50ebaba",
  "file_path": "src/lib/pci_virtio_sock.c",
  "func_name": "pci_vtsock_proc_tx",
  "func_before": "static void pci_vtsock_proc_tx(struct pci_vtsock_softc *sc,\n\t\t\t       struct vqueue_info *vq)\n{\n\tstruct pci_vtsock_sock *sock;\n\tstruct iovec iov_array[VTSOCK_MAXSEGS], *iov = iov_array;\n\tuint16_t idx, flags[VTSOCK_MAXSEGS];\n\tstruct virtio_sock_hdr hdr;\n\tint iovec_len;\n\tsize_t pulled;\n\n\tiovec_len = vq_getchain(vq, &idx, iov, VTSOCK_MAXSEGS, flags);\n\tassert(iovec_len <= VTSOCK_MAXSEGS);\n\n\tDPRINTF((\"TX: chain with %d buffers at idx %\"PRIx16\"\\n\",\n\t\t iovec_len, idx));\n\tdprint_chain(iov, iovec_len, \"TX\");\n\t//assert(iov[0].iov_len >= sizeof(*hdr));\n\t//hdr = iov[0].iov_base;\n\n\tpulled = iovec_pull(&iov, &iovec_len, &hdr, sizeof(hdr));\n\tassert(pulled == sizeof(hdr));\n\n\tdprint_header(&hdr, 1, \"TX\");\n\n\tdprint_iovec(iov, iovec_len, \"TX\");\n\n\tif (hdr.src_cid != sc->vssc_cfg.guest_cid ||\n\t    hdr.dst_cid != VMADDR_CID_HOST ||\n\t    hdr.type != VIRTIO_VSOCK_TYPE_STREAM) {\n\t\tDPRINTF((\"TX: Bad src/dst address/type\\n\"));\n\t\tsend_response_nosock(sc, VIRTIO_VSOCK_OP_RST,\n\t\t\t\t     hdr.type,\n\t\t\t\t     (struct vsock_addr) {\n\t\t\t\t\t     .cid = hdr.dst_cid,\n\t\t\t\t\t     .port =hdr.dst_port\n\t\t\t\t     },\n\t\t\t\t     (struct vsock_addr) {\n\t\t\t\t\t     .cid = hdr.src_cid,\n\t\t\t\t\t     .port =hdr.src_port\n\t\t\t\t     });\n\t\tvq_relchain(vq, idx, 0);\n\t\treturn;\n\t}\n\n\tsock = lookup_sock(sc, VIRTIO_VSOCK_TYPE_STREAM,\n\t\t\t   (struct vsock_addr) {\n\t\t\t\t   .cid = hdr.dst_cid,\n\t\t\t\t\t   .port =hdr.dst_port\n\t\t\t   },\n\t\t\t   (struct vsock_addr) {\n\t\t\t\t   .cid = hdr.src_cid,\n\t\t\t\t\t   .port =hdr.src_port\n\t\t\t   });\n\n\tif (sock) {\n\t\tsock->peer_buf_alloc = hdr.buf_alloc;\n\t\tsock->peer_fwd_cnt = hdr.fwd_cnt;\n\t}\n\n\tswitch (hdr.op) {\n\tcase VIRTIO_VSOCK_OP_INVALID:\n\t\tPPRINTF((\"TX: => INVALID\\n\"));\n\t\tgoto do_rst;\n\n\tcase VIRTIO_VSOCK_OP_REQUEST:\n\t\t/* Attempt to (re)connect existing sock? Naughty! */\n\t\t/* Or is it -- what are the semantics? */\n\t\tif (sock) {\n\t\t\tPPRINTF((\"TX: Attempt to reconnect sock\\n\"));\n\t\t\tgoto do_rst;\n\t\t}\n\n\t\tif (hdr.dst_cid == sc->vssc_cfg.guest_cid) {\n\t\t\tPPRINTF((\"TX: Attempt to connect back to guest\\n!\"));\n\t\t\tgoto do_rst;\n\t\t}\n\n\t\tsock = connect_sock(sc,\n\t\t\t\t    (struct vsock_addr){\n\t\t\t\t\t    .cid = hdr.dst_cid, .port = hdr.dst_port\n\t\t\t\t    },\n\t\t\t\t    (struct vsock_addr){\n\t\t\t\t\t    .cid = hdr.src_cid, .port = hdr.src_port\n\t\t\t\t    }, hdr.buf_alloc, hdr.fwd_cnt);\n\t\tif (!sock) {\n\t\t\tPPRINTF((\"TX: Failed to open sock\\n\"));\n\t\t\tgoto do_rst;\n\t\t}\n\n\t\tsend_response_sock(sc, VIRTIO_VSOCK_OP_RESPONSE, 0, sock);\n\t\tvq_relchain(vq, idx, 0);\n\t\t/* No rx kick required, send_response_sock did one */\n\t\tbreak;\n\n\tcase VIRTIO_VSOCK_OP_RESPONSE:\n\t\tif (!sock) {\n\t\t\tPPRINTF((\"TX: RESPONSE to non-existent sock\\n\"));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tif (sock->state != SOCK_CONNECTING) {\n\t\t\tPPRINTF((\"TX: RESPONSE to non-connecting sock (state %d)\\n\",\n\t\t\t\t sock->state));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tPPRINTF((\"TX: SOCK connected (%d) \"PRIaddr\" <=> \"PRIaddr\"\\n\",\n\t\t\t sock->fd, FMTADDR(sock->local_addr), FMTADDR(sock->peer_addr)));\n\t\tsock->state = SOCK_CONNECTED;\n\t\tvq_relchain(vq, idx, 0);\n\t\tkick_rx(sc, \"new outgoing sock\");\n\t\tbreak;\n\n\tcase VIRTIO_VSOCK_OP_RST:\n\t\t/* No response */\n\t\tif (!sock)\n\t\t\tPPRINTF((\"TX: RST to non-existent sock\\n\"));\n\t\tclose_sock(sc, sock, \"TX\");\n\t\tvq_relchain(vq, idx, 0);\n\t\tbreak;\n\n\tcase VIRTIO_VSOCK_OP_SHUTDOWN:\n\t\tif (!sock) {\n\t\t\tDPRINTF((\"TX: SHUTDOWN to non-existent sock \"PRIcid\".\"PRIport\"\\n\",\n\t\t\t\t hdr.dst_cid, hdr.dst_port));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tif (sock->state != SOCK_CONNECTED) {\n\t\t\tPPRINTF((\"TX: SHUTDOWN to non-connected sock (state %d)\\n\",\n\t\t\t\t sock->state));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tif (hdr.flags & ~VIRTIO_VSOCK_FLAG_SHUTDOWN_ALL) {\n\t\t\tPPRINTF((\"TX: SHUTDOWN with reserved flags %\"PRIx32\"\\n\",\n\t\t\t\t hdr.flags));\n\t\t\tgoto do_rst; /* ??? */\n\t\t}\n\t\tif (!(hdr.flags & VIRTIO_VSOCK_FLAG_SHUTDOWN_ALL)) {\n\t\t\tPPRINTF((\"TX: SHUTDOWN with no flags %\"PRIx32\"\\n\",\n\t\t\t\t hdr.flags));\n\t\t\tgoto do_rst; /* ??? */\n\t\t}\n\n\t\tshutdown_peer_local_fd(sock, hdr.flags, \"TX\");\n\n\t\t/* If the peer is now SHUTDOWN_ALL then we should send\n\t\t * a RST to the peer to finalise the shutdown.\n\t\t */\n\t\tif (sock->peer_shutdown == VIRTIO_VSOCK_FLAG_SHUTDOWN_ALL)\n\t\t\tgoto do_rst;\n\n\t\tvq_relchain(vq, idx, 0);\n\t\tbreak;\n\n\tcase VIRTIO_VSOCK_OP_RW:\n\t{\n\t\tint rc;\n\n\t\tif (!sock) {\n\t\t\tPPRINTF((\"TX: RW with no sock\\n\"));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tif (sock->state != SOCK_CONNECTED) {\n\t\t\tPPRINTF((\"TX: RW to non-connected sock (state %d)\\n\",\n\t\t\t\t sock->state));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tif (sock->peer_shutdown & VIRTIO_VSOCK_FLAG_SHUTDOWN_TX) {\n\t\t\tPPRINTF((\"TX: RW to socket with peer_shutdown.TX\\n\"));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tif (sock->local_shutdown & VIRTIO_VSOCK_FLAG_SHUTDOWN_RX) {\n\t\t\tPPRINTF((\"TX: RW to socket with local_shutdown.RX\\n\"));\n\t\t\tgoto do_rst;\n\t\t}\n\t\trc = handle_write(sc, sock, hdr.len, iov, iovec_len);\n\t\tif (rc < 0) goto do_rst;\n\t\tvq_relchain(vq, idx, 0);\n\t\tif (rc == 1)\n\t\t\tset_credit_update_required(sc, sock);\n\t\tbreak;\n\t}\n\n\tcase VIRTIO_VSOCK_OP_CREDIT_UPDATE:\n\t\tif (!sock) {\n\t\t\tPPRINTF((\"TX: CREDIT_UPDATE to non-existent sock\\n\"));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tif (sock->state != SOCK_CONNECTED) {\n\t\t\tPPRINTF((\"TX: CREDIT_UPDATE to non-connected sock (state %d)\\n\",\n\t\t\t\t sock->state));\n\t\t\tgoto do_rst;\n\t\t}\n\t\t/* No response needed, we updated above */\n\t\tvq_relchain(vq, idx, 0);\n\t\t/* But kick rx thread to attempt to send more */\n\t\tsc->rx_kick_pending = true;\n\t\tbreak;\n\n\tcase VIRTIO_VSOCK_OP_CREDIT_REQUEST:\n\t\tif (!sock) {\n\t\t\tPPRINTF((\"TX: CREDIT_REQUEST to non-existent sock\\n\"));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tif (sock->state != SOCK_CONNECTED) {\n\t\t\tPPRINTF((\"TX: CREDIT_REQUEST to non-connected sock (state %d)\\n\",\n\t\t\t\t sock->state));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tvq_relchain(vq, idx, 0);\n\t\tset_credit_update_required(sc, sock);\n\t\tbreak;\n\t}\n\n\tif (sock)\n\t\tput_sock(sock);\n\n\treturn;\n\ndo_rst:\n\tif (sock)\n\t\tsend_response_sock(sc, VIRTIO_VSOCK_OP_RST, 0, sock);\n\telse\n\t\tsend_response_nosock(sc, VIRTIO_VSOCK_OP_RST, hdr.type,\n\t\t\t\t     (struct vsock_addr) {\n\t\t\t\t\t     .cid = hdr.dst_cid,\n\t\t\t\t\t     .port =hdr.dst_port\n\t\t\t\t     },\n\t\t\t\t     (struct vsock_addr) {\n\t\t\t\t\t     .cid = hdr.src_cid,\n\t\t\t\t\t     .port =hdr.src_port\n\t\t\t\t     });\n\tvq_relchain(vq, idx, 0);\n\tclose_sock(sc, sock, \"TX\");\n\tif (sock) put_sock(sock);\n\treturn;\n}",
  "abstract_func_before": "static void pci_vtsock_proc_tx(struct pci_vtsock_softc *VAR_0,\n\t\t\t       struct vqueue_info *VAR_1)\n{\n\tstruct pci_vtsock_sock *VAR_2;\n\tstruct iovec VAR_3[VAR_4], *VAR_5 = VAR_3;\n\tuint16_t VAR_6, VAR_7[VAR_4];\n\tstruct virtio_sock_hdr VAR_8;\n\tint VAR_9;\n\tsize_t VAR_10;\n\n\tVAR_9 = vq_getchain(VAR_1, &VAR_6, VAR_5, VAR_4, VAR_7);\n\tassert(VAR_9 <= VAR_4);\n\n\tDPRINTF((\"TX: chain with %d buffers at idx %\"VAR_11\"\\n\",\n\t\t VAR_9, VAR_6));\n\tdprint_chain(VAR_5, VAR_9, \"TX\");\n\t/* COMMENT_0 */\n\t/* COMMENT_1 */\n\n\tVAR_10 = iovec_pull(&VAR_5, &VAR_9, &VAR_8, sizeof(VAR_8));\n\tassert(VAR_10 == sizeof(VAR_8));\n\n\tdprint_header(&VAR_8, 1, \"TX\");\n\n\tdprint_iovec(VAR_5, VAR_9, \"TX\");\n\n\tif (VAR_8.src_cid != VAR_0->vssc_cfg.guest_cid ||\n\t    VAR_8.dst_cid != VAR_12 ||\n\t    VAR_8.type != VAR_13) {\n\t\tDPRINTF((\"TX: Bad src/dst address/type\\n\"));\n\t\tsend_response_nosock(VAR_0, VAR_14,\n\t\t\t\t     VAR_8.type,\n\t\t\t\t     (struct vsock_addr) {\n\t\t\t\t\t     .cid = VAR_8.dst_cid,\n\t\t\t\t\t     .port =VAR_8.dst_port\n\t\t\t\t     },\n\t\t\t\t     (struct vsock_addr) {\n\t\t\t\t\t     .cid = VAR_8.src_cid,\n\t\t\t\t\t     .port =VAR_8.src_port\n\t\t\t\t     });\n\t\tvq_relchain(VAR_1, VAR_6, 0);\n\t\treturn;\n\t}\n\n\tVAR_2 = lookup_sock(VAR_0, VAR_13,\n\t\t\t   (struct vsock_addr) {\n\t\t\t\t   .cid = VAR_8.dst_cid,\n\t\t\t\t\t   .port =VAR_8.dst_port\n\t\t\t   },\n\t\t\t   (struct vsock_addr) {\n\t\t\t\t   .cid = VAR_8.src_cid,\n\t\t\t\t\t   .port =VAR_8.src_port\n\t\t\t   });\n\n\tif (VAR_2) {\n\t\tVAR_2->peer_buf_alloc = VAR_8.buf_alloc;\n\t\tVAR_2->peer_fwd_cnt = VAR_8.fwd_cnt;\n\t}\n\n\tswitch (VAR_8.op) {\n\tcase VAR_15:\n\t\tPPRINTF((\"TX: => INVALID\\n\"));\n\t\tgoto do_rst;\n\n\tcase VAR_16:\n\t\t/* COMMENT_2 */\n\t\t/* COMMENT_3 */\n\t\tif (VAR_2) {\n\t\t\tPPRINTF((\"TX: Attempt to reconnect sock\\n\"));\n\t\t\tgoto do_rst;\n\t\t}\n\n\t\tif (VAR_8.dst_cid == VAR_0->vssc_cfg.guest_cid) {\n\t\t\tPPRINTF((\"TX: Attempt to connect back to guest\\n!\"));\n\t\t\tgoto do_rst;\n\t\t}\n\n\t\tVAR_2 = connect_sock(VAR_0,\n\t\t\t\t    (struct vsock_addr){\n\t\t\t\t\t    .cid = VAR_8.dst_cid, .port = VAR_8.dst_port\n\t\t\t\t    },\n\t\t\t\t    (struct vsock_addr){\n\t\t\t\t\t    .cid = VAR_8.src_cid, .port = VAR_8.src_port\n\t\t\t\t    }, VAR_8.buf_alloc, VAR_8.fwd_cnt);\n\t\tif (!VAR_2) {\n\t\t\tPPRINTF((\"TX: Failed to open sock\\n\"));\n\t\t\tgoto do_rst;\n\t\t}\n\n\t\tsend_response_sock(VAR_0, VAR_17, 0, VAR_2);\n\t\tvq_relchain(VAR_1, VAR_6, 0);\n\t\t/* COMMENT_4 */\n\t\tbreak;\n\n\tcase VAR_17:\n\t\tif (!VAR_2) {\n\t\t\tPPRINTF((\"TX: RESPONSE to non-existent sock\\n\"));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tif (VAR_2->state != VAR_18) {\n\t\t\tPPRINTF((\"TX: RESPONSE to non-connecting sock (state %d)\\n\",\n\t\t\t\t VAR_2->state));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tPPRINTF((\"TX: SOCK connected (%d) \"VAR_19\" <=> \"VAR_19\"\\n\",\n\t\t\t VAR_2->fd, FMTADDR(VAR_2->local_addr), FMTADDR(VAR_2->peer_addr)));\n\t\tVAR_2->state = VAR_20;\n\t\tvq_relchain(VAR_1, VAR_6, 0);\n\t\tkick_rx(VAR_0, \"new outgoing sock\");\n\t\tbreak;\n\n\tcase VAR_14:\n\t\t/* COMMENT_5 */\n\t\tif (!VAR_2)\n\t\t\tPPRINTF((\"TX: RST to non-existent sock\\n\"));\n\t\tclose_sock(VAR_0, VAR_2, \"TX\");\n\t\tvq_relchain(VAR_1, VAR_6, 0);\n\t\tbreak;\n\n\tcase VAR_21:\n\t\tif (!VAR_2) {\n\t\t\tDPRINTF((\"TX: SHUTDOWN to non-existent sock \"VAR_22\".\"VAR_23\"\\n\",\n\t\t\t\t VAR_8.dst_cid, VAR_8.dst_port));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tif (VAR_2->state != VAR_20) {\n\t\t\tPPRINTF((\"TX: SHUTDOWN to non-connected sock (state %d)\\n\",\n\t\t\t\t VAR_2->state));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tif (VAR_8.flags & ~VAR_24) {\n\t\t\tPPRINTF((\"TX: SHUTDOWN with reserved flags %\"VAR_25\"\\n\",\n\t\t\t\t VAR_8.flags));\n\t\t\tgoto do_rst; /* COMMENT_6 */\n\t\t}\n\t\tif (!(VAR_8.flags & VAR_24)) {\n\t\t\tPPRINTF((\"TX: SHUTDOWN with no flags %\"VAR_25\"\\n\",\n\t\t\t\t VAR_8.flags));\n\t\t\tgoto do_rst; /* COMMENT_6 */\n\t\t}\n\n\t\tshutdown_peer_local_fd(VAR_2, VAR_8.flags, \"TX\");\n\n\t\t/* COMMENT_7 */\n                                                \n     \n\t\tif (VAR_2->peer_shutdown == VAR_24)\n\t\t\tgoto do_rst;\n\n\t\tvq_relchain(VAR_1, VAR_6, 0);\n\t\tbreak;\n\n\tcase VAR_26:\n\t{\n\t\tint VAR_27;\n\n\t\tif (!VAR_2) {\n\t\t\tPPRINTF((\"TX: RW with no sock\\n\"));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tif (VAR_2->state != VAR_20) {\n\t\t\tPPRINTF((\"TX: RW to non-connected sock (state %d)\\n\",\n\t\t\t\t VAR_2->state));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tif (VAR_2->peer_shutdown & VAR_28) {\n\t\t\tPPRINTF((\"TX: RW to socket with peer_shutdown.TX\\n\"));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tif (VAR_2->local_shutdown & VAR_29) {\n\t\t\tPPRINTF((\"TX: RW to socket with local_shutdown.RX\\n\"));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tVAR_27 = handle_write(VAR_0, VAR_2, VAR_8.len, VAR_5, VAR_9);\n\t\tif (VAR_27 < 0) goto do_rst;\n\t\tvq_relchain(VAR_1, VAR_6, 0);\n\t\tif (VAR_27 == 1)\n\t\t\tset_credit_update_required(VAR_0, VAR_2);\n\t\tbreak;\n\t}\n\n\tcase VAR_30:\n\t\tif (!VAR_2) {\n\t\t\tPPRINTF((\"TX: CREDIT_UPDATE to non-existent sock\\n\"));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tif (VAR_2->state != VAR_20) {\n\t\t\tPPRINTF((\"TX: CREDIT_UPDATE to non-connected sock (state %d)\\n\",\n\t\t\t\t VAR_2->state));\n\t\t\tgoto do_rst;\n\t\t}\n\t\t/* COMMENT_10 */\n\t\tvq_relchain(VAR_1, VAR_6, 0);\n\t\t/* COMMENT_11 */\n\t\tVAR_0->rx_kick_pending = true;\n\t\tbreak;\n\n\tcase VAR_31:\n\t\tif (!VAR_2) {\n\t\t\tPPRINTF((\"TX: CREDIT_REQUEST to non-existent sock\\n\"));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tif (VAR_2->state != VAR_20) {\n\t\t\tPPRINTF((\"TX: CREDIT_REQUEST to non-connected sock (state %d)\\n\",\n\t\t\t\t VAR_2->state));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tvq_relchain(VAR_1, VAR_6, 0);\n\t\tset_credit_update_required(VAR_0, VAR_2);\n\t\tbreak;\n\t}\n\n\tif (VAR_2)\n\t\tput_sock(VAR_2);\n\n\treturn;\n\ndo_rst:\n\tif (VAR_2)\n\t\tsend_response_sock(VAR_0, VAR_14, 0, VAR_2);\n\telse\n\t\tsend_response_nosock(VAR_0, VAR_14, VAR_8.type,\n\t\t\t\t     (struct vsock_addr) {\n\t\t\t\t\t     .cid = VAR_8.dst_cid,\n\t\t\t\t\t     .port =VAR_8.dst_port\n\t\t\t\t     },\n\t\t\t\t     (struct vsock_addr) {\n\t\t\t\t\t     .cid = VAR_8.src_cid,\n\t\t\t\t\t     .port =VAR_8.src_port\n\t\t\t\t     });\n\tvq_relchain(VAR_1, VAR_6, 0);\n\tclose_sock(VAR_0, VAR_2, \"TX\");\n\tif (VAR_2) put_sock(VAR_2);\n\treturn;\n}",
  "func_graph_path_before": "moby/hyperkit/af5eba2360a7351c08dfd9767d9be863a50ebaba/pci_virtio_sock.c/vul/before/0.json",
  "func": "static void pci_vtsock_proc_tx(struct pci_vtsock_softc *sc,\n\t\t\t       struct vqueue_info *vq)\n{\n\tstruct pci_vtsock_sock *sock;\n\tstruct iovec iov_array[VTSOCK_MAXSEGS], *iov = iov_array;\n\tuint16_t idx, flags[VTSOCK_MAXSEGS];\n\tstruct virtio_sock_hdr hdr;\n\tint iovec_len;\n\tsize_t pulled;\n\n\tiovec_len = vq_getchain(vq, &idx, iov, VTSOCK_MAXSEGS, flags);\n\tif (iovec_len < 0) {\n\t\tfprintf(stderr, \"TX: failed to get chain at idx %\"PRIx16\"\\n\", idx);\n\t\treturn;\n\t}\n\n\tassert(iovec_len <= VTSOCK_MAXSEGS);\n\n\tDPRINTF((\"TX: chain with %d buffers at idx %\"PRIx16\"\\n\",\n\t\t iovec_len, idx));\n\tdprint_chain(iov, iovec_len, \"TX\");\n\t//assert(iov[0].iov_len >= sizeof(*hdr));\n\t//hdr = iov[0].iov_base;\n\n\tpulled = iovec_pull(&iov, &iovec_len, &hdr, sizeof(hdr));\n\tassert(pulled == sizeof(hdr));\n\n\tdprint_header(&hdr, 1, \"TX\");\n\n\tdprint_iovec(iov, iovec_len, \"TX\");\n\n\tif (hdr.src_cid != sc->vssc_cfg.guest_cid ||\n\t    hdr.dst_cid != VMADDR_CID_HOST ||\n\t    hdr.type != VIRTIO_VSOCK_TYPE_STREAM) {\n\t\tDPRINTF((\"TX: Bad src/dst address/type\\n\"));\n\t\tsend_response_nosock(sc, VIRTIO_VSOCK_OP_RST,\n\t\t\t\t     hdr.type,\n\t\t\t\t     (struct vsock_addr) {\n\t\t\t\t\t     .cid = hdr.dst_cid,\n\t\t\t\t\t     .port =hdr.dst_port\n\t\t\t\t     },\n\t\t\t\t     (struct vsock_addr) {\n\t\t\t\t\t     .cid = hdr.src_cid,\n\t\t\t\t\t     .port =hdr.src_port\n\t\t\t\t     });\n\t\tvq_relchain(vq, idx, 0);\n\t\treturn;\n\t}\n\n\tsock = lookup_sock(sc, VIRTIO_VSOCK_TYPE_STREAM,\n\t\t\t   (struct vsock_addr) {\n\t\t\t\t   .cid = hdr.dst_cid,\n\t\t\t\t\t   .port =hdr.dst_port\n\t\t\t   },\n\t\t\t   (struct vsock_addr) {\n\t\t\t\t   .cid = hdr.src_cid,\n\t\t\t\t\t   .port =hdr.src_port\n\t\t\t   });\n\n\tif (sock) {\n\t\tsock->peer_buf_alloc = hdr.buf_alloc;\n\t\tsock->peer_fwd_cnt = hdr.fwd_cnt;\n\t}\n\n\tswitch (hdr.op) {\n\tcase VIRTIO_VSOCK_OP_INVALID:\n\t\tPPRINTF((\"TX: => INVALID\\n\"));\n\t\tgoto do_rst;\n\n\tcase VIRTIO_VSOCK_OP_REQUEST:\n\t\t/* Attempt to (re)connect existing sock? Naughty! */\n\t\t/* Or is it -- what are the semantics? */\n\t\tif (sock) {\n\t\t\tPPRINTF((\"TX: Attempt to reconnect sock\\n\"));\n\t\t\tgoto do_rst;\n\t\t}\n\n\t\tif (hdr.dst_cid == sc->vssc_cfg.guest_cid) {\n\t\t\tPPRINTF((\"TX: Attempt to connect back to guest\\n!\"));\n\t\t\tgoto do_rst;\n\t\t}\n\n\t\tsock = connect_sock(sc,\n\t\t\t\t    (struct vsock_addr){\n\t\t\t\t\t    .cid = hdr.dst_cid, .port = hdr.dst_port\n\t\t\t\t    },\n\t\t\t\t    (struct vsock_addr){\n\t\t\t\t\t    .cid = hdr.src_cid, .port = hdr.src_port\n\t\t\t\t    }, hdr.buf_alloc, hdr.fwd_cnt);\n\t\tif (!sock) {\n\t\t\tPPRINTF((\"TX: Failed to open sock\\n\"));\n\t\t\tgoto do_rst;\n\t\t}\n\n\t\tsend_response_sock(sc, VIRTIO_VSOCK_OP_RESPONSE, 0, sock);\n\t\tvq_relchain(vq, idx, 0);\n\t\t/* No rx kick required, send_response_sock did one */\n\t\tbreak;\n\n\tcase VIRTIO_VSOCK_OP_RESPONSE:\n\t\tif (!sock) {\n\t\t\tPPRINTF((\"TX: RESPONSE to non-existent sock\\n\"));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tif (sock->state != SOCK_CONNECTING) {\n\t\t\tPPRINTF((\"TX: RESPONSE to non-connecting sock (state %d)\\n\",\n\t\t\t\t sock->state));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tPPRINTF((\"TX: SOCK connected (%d) \"PRIaddr\" <=> \"PRIaddr\"\\n\",\n\t\t\t sock->fd, FMTADDR(sock->local_addr), FMTADDR(sock->peer_addr)));\n\t\tsock->state = SOCK_CONNECTED;\n\t\tvq_relchain(vq, idx, 0);\n\t\tkick_rx(sc, \"new outgoing sock\");\n\t\tbreak;\n\n\tcase VIRTIO_VSOCK_OP_RST:\n\t\t/* No response */\n\t\tif (!sock)\n\t\t\tPPRINTF((\"TX: RST to non-existent sock\\n\"));\n\t\tclose_sock(sc, sock, \"TX\");\n\t\tvq_relchain(vq, idx, 0);\n\t\tbreak;\n\n\tcase VIRTIO_VSOCK_OP_SHUTDOWN:\n\t\tif (!sock) {\n\t\t\tDPRINTF((\"TX: SHUTDOWN to non-existent sock \"PRIcid\".\"PRIport\"\\n\",\n\t\t\t\t hdr.dst_cid, hdr.dst_port));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tif (sock->state != SOCK_CONNECTED) {\n\t\t\tPPRINTF((\"TX: SHUTDOWN to non-connected sock (state %d)\\n\",\n\t\t\t\t sock->state));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tif (hdr.flags & ~VIRTIO_VSOCK_FLAG_SHUTDOWN_ALL) {\n\t\t\tPPRINTF((\"TX: SHUTDOWN with reserved flags %\"PRIx32\"\\n\",\n\t\t\t\t hdr.flags));\n\t\t\tgoto do_rst; /* ??? */\n\t\t}\n\t\tif (!(hdr.flags & VIRTIO_VSOCK_FLAG_SHUTDOWN_ALL)) {\n\t\t\tPPRINTF((\"TX: SHUTDOWN with no flags %\"PRIx32\"\\n\",\n\t\t\t\t hdr.flags));\n\t\t\tgoto do_rst; /* ??? */\n\t\t}\n\n\t\tshutdown_peer_local_fd(sock, hdr.flags, \"TX\");\n\n\t\t/* If the peer is now SHUTDOWN_ALL then we should send\n\t\t * a RST to the peer to finalise the shutdown.\n\t\t */\n\t\tif (sock->peer_shutdown == VIRTIO_VSOCK_FLAG_SHUTDOWN_ALL)\n\t\t\tgoto do_rst;\n\n\t\tvq_relchain(vq, idx, 0);\n\t\tbreak;\n\n\tcase VIRTIO_VSOCK_OP_RW:\n\t{\n\t\tint rc;\n\n\t\tif (!sock) {\n\t\t\tPPRINTF((\"TX: RW with no sock\\n\"));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tif (sock->state != SOCK_CONNECTED) {\n\t\t\tPPRINTF((\"TX: RW to non-connected sock (state %d)\\n\",\n\t\t\t\t sock->state));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tif (sock->peer_shutdown & VIRTIO_VSOCK_FLAG_SHUTDOWN_TX) {\n\t\t\tPPRINTF((\"TX: RW to socket with peer_shutdown.TX\\n\"));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tif (sock->local_shutdown & VIRTIO_VSOCK_FLAG_SHUTDOWN_RX) {\n\t\t\tPPRINTF((\"TX: RW to socket with local_shutdown.RX\\n\"));\n\t\t\tgoto do_rst;\n\t\t}\n\t\trc = handle_write(sc, sock, hdr.len, iov, iovec_len);\n\t\tif (rc < 0) goto do_rst;\n\t\tvq_relchain(vq, idx, 0);\n\t\tif (rc == 1)\n\t\t\tset_credit_update_required(sc, sock);\n\t\tbreak;\n\t}\n\n\tcase VIRTIO_VSOCK_OP_CREDIT_UPDATE:\n\t\tif (!sock) {\n\t\t\tPPRINTF((\"TX: CREDIT_UPDATE to non-existent sock\\n\"));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tif (sock->state != SOCK_CONNECTED) {\n\t\t\tPPRINTF((\"TX: CREDIT_UPDATE to non-connected sock (state %d)\\n\",\n\t\t\t\t sock->state));\n\t\t\tgoto do_rst;\n\t\t}\n\t\t/* No response needed, we updated above */\n\t\tvq_relchain(vq, idx, 0);\n\t\t/* But kick rx thread to attempt to send more */\n\t\tsc->rx_kick_pending = true;\n\t\tbreak;\n\n\tcase VIRTIO_VSOCK_OP_CREDIT_REQUEST:\n\t\tif (!sock) {\n\t\t\tPPRINTF((\"TX: CREDIT_REQUEST to non-existent sock\\n\"));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tif (sock->state != SOCK_CONNECTED) {\n\t\t\tPPRINTF((\"TX: CREDIT_REQUEST to non-connected sock (state %d)\\n\",\n\t\t\t\t sock->state));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tvq_relchain(vq, idx, 0);\n\t\tset_credit_update_required(sc, sock);\n\t\tbreak;\n\t}\n\n\tif (sock)\n\t\tput_sock(sock);\n\n\treturn;\n\ndo_rst:\n\tif (sock)\n\t\tsend_response_sock(sc, VIRTIO_VSOCK_OP_RST, 0, sock);\n\telse\n\t\tsend_response_nosock(sc, VIRTIO_VSOCK_OP_RST, hdr.type,\n\t\t\t\t     (struct vsock_addr) {\n\t\t\t\t\t     .cid = hdr.dst_cid,\n\t\t\t\t\t     .port =hdr.dst_port\n\t\t\t\t     },\n\t\t\t\t     (struct vsock_addr) {\n\t\t\t\t\t     .cid = hdr.src_cid,\n\t\t\t\t\t     .port =hdr.src_port\n\t\t\t\t     });\n\tvq_relchain(vq, idx, 0);\n\tclose_sock(sc, sock, \"TX\");\n\tif (sock) put_sock(sock);\n\treturn;\n}",
  "abstract_func": "static void pci_vtsock_proc_tx(struct pci_vtsock_softc *VAR_0,\n\t\t\t       struct vqueue_info *VAR_1)\n{\n\tstruct pci_vtsock_sock *VAR_2;\n\tstruct iovec VAR_3[VAR_4], *VAR_5 = VAR_3;\n\tuint16_t VAR_6, VAR_7[VAR_4];\n\tstruct virtio_sock_hdr VAR_8;\n\tint VAR_9;\n\tsize_t VAR_10;\n\n\tVAR_9 = vq_getchain(VAR_1, &VAR_6, VAR_5, VAR_4, VAR_7);\n\tif (VAR_9 < 0) {\n\t\tfprintf(VAR_11, \"TX: failed to get chain at idx %\"VAR_12\"\\n\", VAR_6);\n\t\treturn;\n\t}\n\n\tassert(VAR_9 <= VAR_4);\n\n\tDPRINTF((\"TX: chain with %d buffers at idx %\"VAR_12\"\\n\",\n\t\t VAR_9, VAR_6));\n\tdprint_chain(VAR_5, VAR_9, \"TX\");\n\t/* COMMENT_0 */\n\t/* COMMENT_1 */\n\n\tVAR_10 = iovec_pull(&VAR_5, &VAR_9, &VAR_8, sizeof(VAR_8));\n\tassert(VAR_10 == sizeof(VAR_8));\n\n\tdprint_header(&VAR_8, 1, \"TX\");\n\n\tdprint_iovec(VAR_5, VAR_9, \"TX\");\n\n\tif (VAR_8.src_cid != VAR_0->vssc_cfg.guest_cid ||\n\t    VAR_8.dst_cid != VAR_13 ||\n\t    VAR_8.type != VAR_14) {\n\t\tDPRINTF((\"TX: Bad src/dst address/type\\n\"));\n\t\tsend_response_nosock(VAR_0, VAR_15,\n\t\t\t\t     VAR_8.type,\n\t\t\t\t     (struct vsock_addr) {\n\t\t\t\t\t     .cid = VAR_8.dst_cid,\n\t\t\t\t\t     .port =VAR_8.dst_port\n\t\t\t\t     },\n\t\t\t\t     (struct vsock_addr) {\n\t\t\t\t\t     .cid = VAR_8.src_cid,\n\t\t\t\t\t     .port =VAR_8.src_port\n\t\t\t\t     });\n\t\tvq_relchain(VAR_1, VAR_6, 0);\n\t\treturn;\n\t}\n\n\tVAR_2 = lookup_sock(VAR_0, VAR_14,\n\t\t\t   (struct vsock_addr) {\n\t\t\t\t   .cid = VAR_8.dst_cid,\n\t\t\t\t\t   .port =VAR_8.dst_port\n\t\t\t   },\n\t\t\t   (struct vsock_addr) {\n\t\t\t\t   .cid = VAR_8.src_cid,\n\t\t\t\t\t   .port =VAR_8.src_port\n\t\t\t   });\n\n\tif (VAR_2) {\n\t\tVAR_2->peer_buf_alloc = VAR_8.buf_alloc;\n\t\tVAR_2->peer_fwd_cnt = VAR_8.fwd_cnt;\n\t}\n\n\tswitch (VAR_8.op) {\n\tcase VAR_16:\n\t\tPPRINTF((\"TX: => INVALID\\n\"));\n\t\tgoto do_rst;\n\n\tcase VAR_17:\n\t\t/* COMMENT_2 */\n\t\t/* COMMENT_3 */\n\t\tif (VAR_2) {\n\t\t\tPPRINTF((\"TX: Attempt to reconnect sock\\n\"));\n\t\t\tgoto do_rst;\n\t\t}\n\n\t\tif (VAR_8.dst_cid == VAR_0->vssc_cfg.guest_cid) {\n\t\t\tPPRINTF((\"TX: Attempt to connect back to guest\\n!\"));\n\t\t\tgoto do_rst;\n\t\t}\n\n\t\tVAR_2 = connect_sock(VAR_0,\n\t\t\t\t    (struct vsock_addr){\n\t\t\t\t\t    .cid = VAR_8.dst_cid, .port = VAR_8.dst_port\n\t\t\t\t    },\n\t\t\t\t    (struct vsock_addr){\n\t\t\t\t\t    .cid = VAR_8.src_cid, .port = VAR_8.src_port\n\t\t\t\t    }, VAR_8.buf_alloc, VAR_8.fwd_cnt);\n\t\tif (!VAR_2) {\n\t\t\tPPRINTF((\"TX: Failed to open sock\\n\"));\n\t\t\tgoto do_rst;\n\t\t}\n\n\t\tsend_response_sock(VAR_0, VAR_18, 0, VAR_2);\n\t\tvq_relchain(VAR_1, VAR_6, 0);\n\t\t/* COMMENT_4 */\n\t\tbreak;\n\n\tcase VAR_18:\n\t\tif (!VAR_2) {\n\t\t\tPPRINTF((\"TX: RESPONSE to non-existent sock\\n\"));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tif (VAR_2->state != VAR_19) {\n\t\t\tPPRINTF((\"TX: RESPONSE to non-connecting sock (state %d)\\n\",\n\t\t\t\t VAR_2->state));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tPPRINTF((\"TX: SOCK connected (%d) \"VAR_20\" <=> \"VAR_20\"\\n\",\n\t\t\t VAR_2->fd, FMTADDR(VAR_2->local_addr), FMTADDR(VAR_2->peer_addr)));\n\t\tVAR_2->state = VAR_21;\n\t\tvq_relchain(VAR_1, VAR_6, 0);\n\t\tkick_rx(VAR_0, \"new outgoing sock\");\n\t\tbreak;\n\n\tcase VAR_15:\n\t\t/* COMMENT_5 */\n\t\tif (!VAR_2)\n\t\t\tPPRINTF((\"TX: RST to non-existent sock\\n\"));\n\t\tclose_sock(VAR_0, VAR_2, \"TX\");\n\t\tvq_relchain(VAR_1, VAR_6, 0);\n\t\tbreak;\n\n\tcase VAR_22:\n\t\tif (!VAR_2) {\n\t\t\tDPRINTF((\"TX: SHUTDOWN to non-existent sock \"VAR_23\".\"VAR_24\"\\n\",\n\t\t\t\t VAR_8.dst_cid, VAR_8.dst_port));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tif (VAR_2->state != VAR_21) {\n\t\t\tPPRINTF((\"TX: SHUTDOWN to non-connected sock (state %d)\\n\",\n\t\t\t\t VAR_2->state));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tif (VAR_8.flags & ~VAR_25) {\n\t\t\tPPRINTF((\"TX: SHUTDOWN with reserved flags %\"VAR_26\"\\n\",\n\t\t\t\t VAR_8.flags));\n\t\t\tgoto do_rst; /* COMMENT_6 */\n\t\t}\n\t\tif (!(VAR_8.flags & VAR_25)) {\n\t\t\tPPRINTF((\"TX: SHUTDOWN with no flags %\"VAR_26\"\\n\",\n\t\t\t\t VAR_8.flags));\n\t\t\tgoto do_rst; /* COMMENT_6 */\n\t\t}\n\n\t\tshutdown_peer_local_fd(VAR_2, VAR_8.flags, \"TX\");\n\n\t\t/* COMMENT_7 */\n                                                \n     \n\t\tif (VAR_2->peer_shutdown == VAR_25)\n\t\t\tgoto do_rst;\n\n\t\tvq_relchain(VAR_1, VAR_6, 0);\n\t\tbreak;\n\n\tcase VAR_27:\n\t{\n\t\tint VAR_28;\n\n\t\tif (!VAR_2) {\n\t\t\tPPRINTF((\"TX: RW with no sock\\n\"));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tif (VAR_2->state != VAR_21) {\n\t\t\tPPRINTF((\"TX: RW to non-connected sock (state %d)\\n\",\n\t\t\t\t VAR_2->state));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tif (VAR_2->peer_shutdown & VAR_29) {\n\t\t\tPPRINTF((\"TX: RW to socket with peer_shutdown.TX\\n\"));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tif (VAR_2->local_shutdown & VAR_30) {\n\t\t\tPPRINTF((\"TX: RW to socket with local_shutdown.RX\\n\"));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tVAR_28 = handle_write(VAR_0, VAR_2, VAR_8.len, VAR_5, VAR_9);\n\t\tif (VAR_28 < 0) goto do_rst;\n\t\tvq_relchain(VAR_1, VAR_6, 0);\n\t\tif (VAR_28 == 1)\n\t\t\tset_credit_update_required(VAR_0, VAR_2);\n\t\tbreak;\n\t}\n\n\tcase VAR_31:\n\t\tif (!VAR_2) {\n\t\t\tPPRINTF((\"TX: CREDIT_UPDATE to non-existent sock\\n\"));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tif (VAR_2->state != VAR_21) {\n\t\t\tPPRINTF((\"TX: CREDIT_UPDATE to non-connected sock (state %d)\\n\",\n\t\t\t\t VAR_2->state));\n\t\t\tgoto do_rst;\n\t\t}\n\t\t/* COMMENT_10 */\n\t\tvq_relchain(VAR_1, VAR_6, 0);\n\t\t/* COMMENT_11 */\n\t\tVAR_0->rx_kick_pending = true;\n\t\tbreak;\n\n\tcase VAR_32:\n\t\tif (!VAR_2) {\n\t\t\tPPRINTF((\"TX: CREDIT_REQUEST to non-existent sock\\n\"));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tif (VAR_2->state != VAR_21) {\n\t\t\tPPRINTF((\"TX: CREDIT_REQUEST to non-connected sock (state %d)\\n\",\n\t\t\t\t VAR_2->state));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tvq_relchain(VAR_1, VAR_6, 0);\n\t\tset_credit_update_required(VAR_0, VAR_2);\n\t\tbreak;\n\t}\n\n\tif (VAR_2)\n\t\tput_sock(VAR_2);\n\n\treturn;\n\ndo_rst:\n\tif (VAR_2)\n\t\tsend_response_sock(VAR_0, VAR_15, 0, VAR_2);\n\telse\n\t\tsend_response_nosock(VAR_0, VAR_15, VAR_8.type,\n\t\t\t\t     (struct vsock_addr) {\n\t\t\t\t\t     .cid = VAR_8.dst_cid,\n\t\t\t\t\t     .port =VAR_8.dst_port\n\t\t\t\t     },\n\t\t\t\t     (struct vsock_addr) {\n\t\t\t\t\t     .cid = VAR_8.src_cid,\n\t\t\t\t\t     .port =VAR_8.src_port\n\t\t\t\t     });\n\tvq_relchain(VAR_1, VAR_6, 0);\n\tclose_sock(VAR_0, VAR_2, \"TX\");\n\tif (VAR_2) put_sock(VAR_2);\n\treturn;\n}",
  "func_graph_path": "moby/hyperkit/af5eba2360a7351c08dfd9767d9be863a50ebaba/pci_virtio_sock.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -9,6 +9,11 @@\n \tsize_t pulled;\n \n \tiovec_len = vq_getchain(vq, &idx, iov, VTSOCK_MAXSEGS, flags);\n+\tif (iovec_len < 0) {\n+\t\tfprintf(stderr, \"TX: failed to get chain at idx %\"PRIx16\"\\n\", idx);\n+\t\treturn;\n+\t}\n+\n \tassert(iovec_len <= VTSOCK_MAXSEGS);\n \n \tDPRINTF((\"TX: chain with %d buffers at idx %\"PRIx16\"\\n\",",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "\tif (iovec_len < 0) {",
      "\t\tfprintf(stderr, \"TX: failed to get chain at idx %\"PRIx16\"\\n\", idx);",
      "\t\treturn;",
      "\t}",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/moby/hyperkit/pull/313",
  "description": {
    "pr_info": {
      "title": "Various fixes",
      "number": 313
    },
    "comment": [
      "This series add some fixes for various cases that have been reported that allow the guest to trigger a crash of the virtual machine.\r\n\r\nThe first two are NULL pointer dereference and are already handled in bhyve.\r\nhttps://cgit.freebsd.org/src/tree/usr.sbin/bhyve/virtio.c#n606\r\nhttps://cgit.freebsd.org/src/tree/usr.sbin/bhyve/virtio.c#n725\r\n\r\nThe other two are unhandled returned errors in vq_getchain. For now, trace and return as in pci_vt9p_notify.\r\n\r\nLet me know what you think."
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.85,
  "Bug Filter Response": "\n\nFinal Output:\nAnalysis: The patch addresses an issue where uninitialized memory was used in the pci_vtsock_proc_tx function. It adds error handling for cases where vq_getchain returns a negative value, preventing potential crashes or undefined behavior. The commit message and context suggest it's part of a series fixing issues that could cause VM crashes, but without explicit mention of exploitability, it's classified as a bug fix.\n\nFinal Classification: Defect Remediation & Feature Upgrades\nConfidence Score: 0.85"
}