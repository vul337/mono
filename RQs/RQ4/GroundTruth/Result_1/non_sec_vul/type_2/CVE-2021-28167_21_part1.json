{
  "cve_id": "CVE-2021-28167",
  "cwe_ids": [
    "CWE-909"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "eclipse-openj9/openj9",
  "commit_msg": "Correctly load/initialize classes when using ConstantPool\n\n- do not load classes in the \"ifLoaded\" calls\n- never intitialize classes in the natives\n- do not update the constant pool when querying from the natives\n\nFixes: #12016\n\n[ci skip]\n\nSigned-off-by: Graham Chapman <graham_chapman@ca.ibm.com>",
  "commit_hash": "840f3af31a5b8d2d395d9367c826ed756e380fb9",
  "git_url": "https://github.com/eclipse-openj9/openj9/commit/840f3af31a5b8d2d395d9367c826ed756e380fb9",
  "file_path": "runtime/vm/resolvesupport.cpp",
  "func_name": "resolveClassRef",
  "func_before": "J9Class *   \nresolveClassRef(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags)\n{\n\tJ9JavaVM *vm = vmStruct->javaVM;\n\tJ9ClassLoader *bootstrapClassLoader = vm->systemClassLoader;\n\tJ9Class *currentClass = NULL;\n\tJ9RAMClassRef *ramClassRefWrapper = NULL;\n\tJ9Class *resolvedClass = NULL;\n\tJ9Class *accessClass = NULL;\n\tJ9UTF8 *classNameWrapper = NULL;\n\tU_16 classNameLength = 0;\n\tU_8 *classNameData = NULL;\n\tJ9ROMStringRef *romStringRef = NULL;\n\tJ9ClassLoader *classLoader = NULL;\n\tbool jitCompileTimeResolve = J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_JIT_COMPILE_TIME);\n\tbool canRunJavaCode = !jitCompileTimeResolve && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_REDEFINE_CLASS);\n\tbool throwException = canRunJavaCode && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);\n\tUDATA lookupOptions = 0;\n\tif (canRunJavaCode) {\n\t\tif (!throwException) {\n\t\t\tlookupOptions = J9_LOOK_NO_THROW;\t\t\t\n\t\t}\n\t} else {\n\t\tlookupOptions = J9_LOOK_NO_JAVA;\n\t}\n\tUDATA findClassFlags = 0;\n\tUDATA accessModifiers = 0;\n\tj9object_t detailString = NULL;\n\tTrc_VM_resolveClassRef_Entry(vmStruct, ramCP, cpIndex, resolveFlags);\n\ntryAgain:\n\tramClassRefWrapper = (J9RAMClassRef *)&ramCP[cpIndex];\n\tresolvedClass = ramClassRefWrapper->value;\n\t/* If resolving for \"new\", check if the class is instantiable */\n\tif ((NULL != resolvedClass) && (J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_INSTANTIABLE) || J9ROMCLASS_ALLOCATES_VIA_NEW(resolvedClass->romClass))) {\n\t\t/* ensure that the caller can safely read the modifiers field if it so desires */\n\t\tissueReadBarrier();\n\t\tgoto done;\n\t}\n\n\tromStringRef = (J9ROMStringRef *)&ramCP->romConstantPool[cpIndex];\n\tclassNameWrapper = J9ROMSTRINGREF_UTF8DATA(romStringRef);\n\tclassNameLength = J9UTF8_LENGTH(classNameWrapper);\n\tclassNameData = J9UTF8_DATA(classNameWrapper);\n\n\tcurrentClass = J9_CLASS_FROM_CP(ramCP);\n\tclassLoader = currentClass->classLoader;\n\tif (NULL == classLoader) {\n\t\tclassLoader = bootstrapClassLoader;\n\t}\n\n\tTrc_VM_resolveClassRef_lookup(vmStruct, classNameLength, classNameData);\n\n\tif (canRunJavaCode) {\n\t\tif (throwException) {\n\t\t\tfindClassFlags = J9_FINDCLASS_FLAG_THROW_ON_FAIL;\n\t\t}\n\t} else {\n\t\tfindClassFlags = J9_FINDCLASS_FLAG_EXISTING_ONLY;\n\t}\n\n\tif (ramClassRefWrapper->modifiers == (UDATA)-1) {\n\t\tif ((findClassFlags & J9_FINDCLASS_FLAG_THROW_ON_FAIL) == J9_FINDCLASS_FLAG_THROW_ON_FAIL) {\n\t\t\tdetailString = vm->memoryManagerFunctions->j9gc_createJavaLangString(vmStruct, classNameData, classNameLength, 0);\n\t\t\tif (throwException) {\n\t\t\t\tif (NULL == vmStruct->currentException) {\n\t\t\t\t\tsetCurrentException(vmStruct, J9VMCONSTANTPOOL_JAVALANGNOCLASSDEFFOUNDERROR, (UDATA *)detailString);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tVM_VMHelpers::clearException(vmStruct);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\n#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n\tif ((';' == *(char *)(classNameData + (classNameLength - 1)))\n\t\t&& ('Q' == *(char *)classNameData)\n\t) {\n\t\t/* we are dealing with signature envelope, extract the name from it */\n\t\tclassNameData += 1;\n\t\tclassNameLength -= 2;\n\t}\n#endif /* defined(J9VM_OPT_VALHALLA_VALUE_TYPES) */\n\n\tresolvedClass = internalFindClassUTF8(vmStruct, classNameData, classNameLength,\n\t\t\tclassLoader, findClassFlags);\n\n\t/* Check for frame pop before permanently invalidating the CP entry */\n\tif (J9_ARE_ANY_BITS_SET(vmStruct->publicFlags, J9_PUBLIC_FLAGS_POP_FRAMES_INTERRUPT)) {\n\t\tgoto bail;\n\t}\n\n\tif (NULL == resolvedClass) {\n\t\tj9object_t exception = vmStruct->currentException;\n\t\t/* Class not found - if NoClassDefFoundError was thrown, mark this ref as permanently unresolveable */\n\t\tif (NULL != exception) {\n\t\t\tif (instanceOfOrCheckCast(J9OBJECT_CLAZZ(vmStruct, exception), J9VMJAVALANGLINKAGEERROR_OR_NULL(vm))) {\n\t\t\t\tramClassRefWrapper->modifiers = -1;\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\n\t/* Perform a package access check from the current class to the resolved class.\n\t * No check is required if any of the following is true:\n\t * \t\t- the current class and resolved class are identical\n\t * \t\t- the current class was loaded by the bootstrap class loader\n\t * \t\t- the current class and resolved class are in same module\n\t */\n\tif ((currentClass != resolvedClass) \n\t\t&& (classLoader != bootstrapClassLoader)\n\t\t&& requirePackageAccessCheck(vm, classLoader, currentClass->module, resolvedClass)\n\t) {\n\t\t/* AOT resolves class refs inside J9Classes which have not yet\n\t\t * had the java/lang/Class associated with them.  canRunJavaCode must be false\n\t\t * in this case.  The protectionDomain object is only used if canRunJavaCode\n\t\t * is true, so don't bother fetching it in the false case.\n\t\t */\n\t\tj9object_t protectionDomain = NULL;\n\t\tif (canRunJavaCode) {\n\t\t\tj9object_t classObject = J9VM_J9CLASS_TO_HEAPCLASS(currentClass);\n\t\t\tAssert_VM_notNull(classObject);\n\t\t\tprotectionDomain = J9VMJAVALANGCLASS_PROTECTIONDOMAIN(vmStruct, classObject);\n\t\t}\n\t\tif (!packageAccessIsLegal(vmStruct, resolvedClass, protectionDomain, canRunJavaCode)) {\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tif (jitCompileTimeResolve) {\n\t\tif (J9_ARE_NO_BITS_SET(resolvedClass->romClass->modifiers, J9AccInterface)) {\n\t\t\tif (J9ClassInitSucceeded != resolvedClass->initializeStatus) {\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* check access permissions */\n\taccessModifiers = resolvedClass->romClass->modifiers;\n\tif (J9ROMCLASS_IS_ARRAY(resolvedClass->romClass)) {\n\t\taccessClass = ((J9ArrayClass *)resolvedClass)->leafComponentType;\n\t\taccessModifiers = accessClass->romClass->modifiers;\n\t} else {\n\t\taccessClass = resolvedClass;\n\t}\n\t{\n\t\tIDATA checkResult = checkVisibility(vmStruct, J9_CLASS_FROM_CP(ramCP), accessClass, accessModifiers, lookupOptions);\n\t\tif (checkResult < J9_VISIBILITY_ALLOWED) {\n\t\t\t/* Check for pending exception for (ie. Nesthost class loading/verify), do not overwrite these exceptions */\n\t\t\tif (canRunJavaCode && (!VM_VMHelpers::exceptionPending(vmStruct))) {\n\t\t\t\tchar *errorMsg = NULL;\n\t\t\t\tPORT_ACCESS_FROM_VMC(vmStruct);\n\t\t\t\tif (J9_VISIBILITY_NON_MODULE_ACCESS_ERROR == checkResult) {\n\t\t\t\t\terrorMsg = illegalAccessMessage(vmStruct, accessModifiers, J9_CLASS_FROM_CP(ramCP), accessClass, J9_VISIBILITY_NON_MODULE_ACCESS_ERROR);\n\t\t\t\t} else {\n\t\t\t\t\terrorMsg = illegalAccessMessage(vmStruct, -1, J9_CLASS_FROM_CP(ramCP), accessClass, checkResult);\n\t\t\t\t}\n\t\t\t\tsetCurrentExceptionUTF(vmStruct, J9VMCONSTANTPOOL_JAVALANGILLEGALACCESSERROR, errorMsg);\n\t\t\t\tj9mem_free_memory(errorMsg);\n\t\t\t}\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\taccessModifiers = resolvedClass->romClass->modifiers;\n\tif (J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_INSTANTIABLE)) {\n\t\tif (!J9ROMCLASS_ALLOCATES_VIA_NEW(resolvedClass->romClass)) {\n\t\t\tif (canRunJavaCode) {\n\t\t\t\tsetCurrentException(vmStruct, J9_EX_CTOR_CLASS + J9VMCONSTANTPOOL_JAVALANGINSTANTIATIONERROR,\n\t\t\t\t\t\t(UDATA *)resolvedClass->classObject);\n\t\t\t}\n\t\t\tgoto bail;\n\t\t}\n\t}\n\t\n\tif (J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_INIT_CLASS)) {\n\t\tUDATA initStatus = resolvedClass->initializeStatus;\n\t\tif ((J9ClassInitSucceeded != initStatus) && ((UDATA)vmStruct != initStatus)) {\n\t\t\tUDATA preCount = vm->hotSwapCount;\n\n\t\t\t/* No need to check for JITCompileTimeResolve, since it wouldn't have got this far\n\t\t\t * if the class weren't already initialized.\n\t\t\t */\n\t\t\tinitializeClass(vmStruct, resolvedClass);\n\t\t\tif (J9_ARE_ANY_BITS_SET(vmStruct->publicFlags, J9_PUBLIC_FLAGS_POP_FRAMES_INTERRUPT)) {\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (NULL != vmStruct->currentException) {\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (preCount != vm->hotSwapCount) {\n\t\t\t\tgoto tryAgain;\n\t\t\t}\n\t\t}\n\t}\n\n\tramClassRefWrapper->value = resolvedClass;\n\tramClassRefWrapper->modifiers = accessModifiers;\n\ndone:\n\tTrc_VM_resolveClassRef_Exit(vmStruct, resolvedClass);\n\treturn resolvedClass; \nbail:\n\tresolvedClass = NULL;\n\tgoto done;\n}",
  "abstract_func_before": "J9Class *   \nresolveClassRef(J9VMThread *VAR_0, J9ConstantPool *VAR_1, UDATA VAR_2, UDATA VAR_3)\n{\n\tJ9JavaVM *VAR_4 = VAR_0->javaVM;\n\tJ9ClassLoader *VAR_5 = VAR_4->systemClassLoader;\n\tJ9Class *VAR_6 = NULL;\n\tJ9RAMClassRef *VAR_7 = NULL;\n\tJ9Class *VAR_8 = NULL;\n\tJ9Class *VAR_9 = NULL;\n\tJ9UTF8 *VAR_10 = NULL;\n\tU_16 VAR_11 = 0;\n\tU_8 *VAR_12 = NULL;\n\tJ9ROMStringRef *VAR_13 = NULL;\n\tJ9ClassLoader *VAR_14 = NULL;\n\tbool VAR_15 = J9_ARE_ANY_BITS_SET(VAR_3, VAR_16);\n\tbool VAR_17 = !VAR_15 && J9_ARE_NO_BITS_SET(VAR_3, VAR_18);\n\tbool VAR_19 = VAR_17 && J9_ARE_NO_BITS_SET(VAR_3, VAR_20);\n\tUDATA VAR_21 = 0;\n\tif (VAR_17) {\n\t\tif (!VAR_19) {\n\t\t\tVAR_21 = VAR_22;\t\t\t\n\t\t}\n\t} else {\n\t\tVAR_21 = VAR_23;\n\t}\n\tUDATA VAR_24 = 0;\n\tUDATA VAR_25 = 0;\n\tj9object_t VAR_26 = NULL;\n\tTrc_VM_resolveClassRef_Entry(VAR_0, VAR_1, VAR_2, VAR_3);\n\ntryAgain:\n\tVAR_7 = (J9RAMClassRef *)&VAR_1[VAR_2];\n\tVAR_8 = VAR_7->value;\n\t/* COMMENT_0 */\n\tif ((NULL != VAR_8) && (J9_ARE_NO_BITS_SET(VAR_3, VAR_27) || J9ROMCLASS_ALLOCATES_VIA_NEW(VAR_8->romClass))) {\n\t\t/* COMMENT_1 */\n\t\tissueReadBarrier();\n\t\tgoto done;\n\t}\n\n\tVAR_13 = (J9ROMStringRef *)&VAR_1->romConstantPool[VAR_2];\n\tVAR_10 = J9ROMSTRINGREF_UTF8DATA(VAR_13);\n\tVAR_11 = J9UTF8_LENGTH(VAR_10);\n\tVAR_12 = J9UTF8_DATA(VAR_10);\n\n\tVAR_6 = J9_CLASS_FROM_CP(VAR_1);\n\tVAR_14 = VAR_6->classLoader;\n\tif (NULL == VAR_14) {\n\t\tVAR_14 = VAR_5;\n\t}\n\n\tTrc_VM_resolveClassRef_lookup(VAR_0, VAR_11, VAR_12);\n\n\tif (VAR_17) {\n\t\tif (VAR_19) {\n\t\t\tVAR_24 = VAR_28;\n\t\t}\n\t} else {\n\t\tVAR_24 = VAR_29;\n\t}\n\n\tif (VAR_7->modifiers == (UDATA)-1) {\n\t\tif ((VAR_24 & VAR_28) == VAR_28) {\n\t\t\tVAR_26 = VAR_4->memoryManagerFunctions->j9gc_createJavaLangString(VAR_0, VAR_12, VAR_11, 0);\n\t\t\tif (VAR_19) {\n\t\t\t\tif (NULL == VAR_0->currentException) {\n\t\t\t\t\tsetCurrentException(VAR_0, VAR_30, (UDATA *)VAR_26);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tVM_VMHelpers::clearException(VAR_0);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\n#if defined(VAR_31)\n\tif ((';' == *(char *)(VAR_12 + (VAR_11 - 1)))\n\t\t&& ('Q' == *(char *)VAR_12)\n\t) {\n\t\t/* COMMENT_2 */\n\t\tVAR_12 += 1;\n\t\tVAR_11 -= 2;\n\t}\n#endif /* COMMENT_3 */\n\n\tVAR_8 = internalFindClassUTF8(VAR_0, VAR_12, VAR_11,\n\t\t\tVAR_14, VAR_24);\n\n\t/* COMMENT_4 */\n\tif (J9_ARE_ANY_BITS_SET(VAR_0->publicFlags, VAR_32)) {\n\t\tgoto bail;\n\t}\n\n\tif (NULL == VAR_8) {\n\t\tj9object_t VAR_33 = VAR_0->currentException;\n\t\t/* COMMENT_5 */\n\t\tif (NULL != VAR_33) {\n\t\t\tif (instanceOfOrCheckCast(J9OBJECT_CLAZZ(VAR_0, VAR_33), J9VMJAVALANGLINKAGEERROR_OR_NULL(VAR_4))) {\n\t\t\t\tVAR_7->modifiers = -1;\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\n\t/* COMMENT_6 */\n                                                         \n                                                          \n                                                                  \n                                                               \n    \n\tif ((VAR_6 != VAR_8) \n\t\t&& (VAR_14 != VAR_5)\n\t\t&& requirePackageAccessCheck(VAR_4, VAR_14, VAR_6->module, VAR_8)\n\t) {\n\t\t/* COMMENT_12 */\n                                                                                \n                                                                              \n                                                            \n     \n\t\tj9object_t VAR_34 = NULL;\n\t\tif (VAR_17) {\n\t\t\tj9object_t VAR_35 = J9VM_J9CLASS_TO_HEAPCLASS(VAR_6);\n\t\t\tAssert_VM_notNull(VAR_35);\n\t\t\tVAR_34 = J9VMJAVALANGCLASS_PROTECTIONDOMAIN(VAR_0, VAR_35);\n\t\t}\n\t\tif (!packageAccessIsLegal(VAR_0, VAR_8, VAR_34, VAR_17)) {\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tif (VAR_15) {\n\t\tif (J9_ARE_NO_BITS_SET(VAR_8->romClass->modifiers, VAR_36)) {\n\t\t\tif (VAR_37 != VAR_8->initializeStatus) {\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* COMMENT_17 */\n\tVAR_25 = VAR_8->romClass->modifiers;\n\tif (J9ROMCLASS_IS_ARRAY(VAR_8->romClass)) {\n\t\tVAR_9 = ((J9ArrayClass *)VAR_8)->leafComponentType;\n\t\tVAR_25 = VAR_9->romClass->modifiers;\n\t} else {\n\t\tVAR_9 = VAR_8;\n\t}\n\t{\n\t\tIDATA VAR_38 = checkVisibility(VAR_0, J9_CLASS_FROM_CP(VAR_1), VAR_9, VAR_25, VAR_21);\n\t\tif (VAR_38 < VAR_39) {\n\t\t\t/* COMMENT_18 */\n\t\t\tif (VAR_17 && (!VM_VMHelpers::exceptionPending(VAR_0))) {\n\t\t\t\tchar *VAR_40 = NULL;\n\t\t\t\tPORT_ACCESS_FROM_VMC(VAR_0);\n\t\t\t\tif (VAR_41 == VAR_38) {\n\t\t\t\t\tVAR_40 = illegalAccessMessage(VAR_0, VAR_25, J9_CLASS_FROM_CP(VAR_1), VAR_9, VAR_41);\n\t\t\t\t} else {\n\t\t\t\t\tVAR_40 = illegalAccessMessage(VAR_0, -1, J9_CLASS_FROM_CP(VAR_1), VAR_9, VAR_38);\n\t\t\t\t}\n\t\t\t\tsetCurrentExceptionUTF(VAR_0, VAR_42, VAR_40);\n\t\t\t\tj9mem_free_memory(VAR_40);\n\t\t\t}\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tVAR_25 = VAR_8->romClass->modifiers;\n\tif (J9_ARE_ANY_BITS_SET(VAR_3, VAR_27)) {\n\t\tif (!J9ROMCLASS_ALLOCATES_VIA_NEW(VAR_8->romClass)) {\n\t\t\tif (VAR_17) {\n\t\t\t\tsetCurrentException(VAR_0, VAR_43 + VAR_44,\n\t\t\t\t\t\t(UDATA *)VAR_8->classObject);\n\t\t\t}\n\t\t\tgoto bail;\n\t\t}\n\t}\n\t\n\tif (J9_ARE_ANY_BITS_SET(VAR_3, VAR_45)) {\n\t\tUDATA VAR_46 = VAR_8->initializeStatus;\n\t\tif ((VAR_37 != VAR_46) && ((UDATA)VAR_0 != VAR_46)) {\n\t\t\tUDATA VAR_47 = VAR_4->hotSwapCount;\n\n\t\t\t/* COMMENT_19 */\n                                               \n      \n\t\t\tinitializeClass(VAR_0, VAR_8);\n\t\t\tif (J9_ARE_ANY_BITS_SET(VAR_0->publicFlags, VAR_32)) {\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (NULL != VAR_0->currentException) {\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (VAR_47 != VAR_4->hotSwapCount) {\n\t\t\t\tgoto tryAgain;\n\t\t\t}\n\t\t}\n\t}\n\n\tVAR_7->value = VAR_8;\n\tVAR_7->modifiers = VAR_25;\n\ndone:\n\tTrc_VM_resolveClassRef_Exit(VAR_0, VAR_8);\n\treturn VAR_8; \nbail:\n\tVAR_8 = NULL;\n\tgoto done;\n}",
  "func_graph_path_before": "eclipse-openj9/openj9/840f3af31a5b8d2d395d9367c826ed756e380fb9/resolvesupport.cpp/vul/before/13.json",
  "func": "J9Class *   \nresolveClassRef(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags)\n{\n\tJ9JavaVM *vm = vmStruct->javaVM;\n\tJ9ClassLoader *bootstrapClassLoader = vm->systemClassLoader;\n\tJ9Class *currentClass = NULL;\n\tJ9RAMClassRef *ramClassRefWrapper = NULL;\n\tJ9Class *resolvedClass = NULL;\n\tJ9Class *accessClass = NULL;\n\tJ9UTF8 *classNameWrapper = NULL;\n\tU_16 classNameLength = 0;\n\tU_8 *classNameData = NULL;\n\tJ9ROMStringRef *romStringRef = NULL;\n\tJ9ClassLoader *classLoader = NULL;\n\tbool jitCompileTimeResolve = J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_JIT_COMPILE_TIME);\n\tbool canRunJavaCode = !jitCompileTimeResolve && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_REDEFINE_CLASS);\n\tbool throwException = canRunJavaCode && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);\n\tUDATA lookupOptions = 0;\n\tif (canRunJavaCode) {\n\t\tif (!throwException) {\n\t\t\tlookupOptions = J9_LOOK_NO_THROW;\t\t\t\n\t\t}\n\t} else {\n\t\tlookupOptions = J9_LOOK_NO_JAVA;\n\t}\n\tUDATA findClassFlags = 0;\n\tUDATA accessModifiers = 0;\n\tj9object_t detailString = NULL;\n\tTrc_VM_resolveClassRef_Entry(vmStruct, ramCP, cpIndex, resolveFlags);\n\ntryAgain:\n\tramClassRefWrapper = (J9RAMClassRef *)&ramCP[cpIndex];\n\tresolvedClass = ramClassRefWrapper->value;\n\t/* If resolving for \"new\", check if the class is instantiable */\n\tif ((NULL != resolvedClass) && (J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_INSTANTIABLE) || J9ROMCLASS_ALLOCATES_VIA_NEW(resolvedClass->romClass))) {\n\t\t/* ensure that the caller can safely read the modifiers field if it so desires */\n\t\tissueReadBarrier();\n\t\tgoto done;\n\t}\n\n\tromStringRef = (J9ROMStringRef *)&ramCP->romConstantPool[cpIndex];\n\tclassNameWrapper = J9ROMSTRINGREF_UTF8DATA(romStringRef);\n\tclassNameLength = J9UTF8_LENGTH(classNameWrapper);\n\tclassNameData = J9UTF8_DATA(classNameWrapper);\n\n\tcurrentClass = J9_CLASS_FROM_CP(ramCP);\n\tclassLoader = currentClass->classLoader;\n\tif (NULL == classLoader) {\n\t\tclassLoader = bootstrapClassLoader;\n\t}\n\n\tTrc_VM_resolveClassRef_lookup(vmStruct, classNameLength, classNameData);\n\n\tif (canRunJavaCode) {\n\t\tif (throwException) {\n\t\t\tfindClassFlags |= J9_FINDCLASS_FLAG_THROW_ON_FAIL;\n\t\t}\n\t\tif (J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CLASS_LOAD)) {\n\t\t\tfindClassFlags |= J9_FINDCLASS_FLAG_EXISTING_ONLY;\t\t\n\t\t}\n\t} else {\n\t\tfindClassFlags |= J9_FINDCLASS_FLAG_EXISTING_ONLY;\n\t}\n\n\tif (ramClassRefWrapper->modifiers == (UDATA)-1) {\n\t\tif ((findClassFlags & J9_FINDCLASS_FLAG_THROW_ON_FAIL) == J9_FINDCLASS_FLAG_THROW_ON_FAIL) {\n\t\t\tdetailString = vm->memoryManagerFunctions->j9gc_createJavaLangString(vmStruct, classNameData, classNameLength, 0);\n\t\t\tif (throwException) {\n\t\t\t\tif (NULL == vmStruct->currentException) {\n\t\t\t\t\tsetCurrentException(vmStruct, J9VMCONSTANTPOOL_JAVALANGNOCLASSDEFFOUNDERROR, (UDATA *)detailString);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tVM_VMHelpers::clearException(vmStruct);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\n#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n\tif ((';' == *(char *)(classNameData + (classNameLength - 1)))\n\t\t&& ('Q' == *(char *)classNameData)\n\t) {\n\t\t/* we are dealing with signature envelope, extract the name from it */\n\t\tclassNameData += 1;\n\t\tclassNameLength -= 2;\n\t}\n#endif /* defined(J9VM_OPT_VALHALLA_VALUE_TYPES) */\n\n\tresolvedClass = internalFindClassUTF8(vmStruct, classNameData, classNameLength,\n\t\t\tclassLoader, findClassFlags);\n\n\t/* Check for frame pop before permanently invalidating the CP entry */\n\tif (J9_ARE_ANY_BITS_SET(vmStruct->publicFlags, J9_PUBLIC_FLAGS_POP_FRAMES_INTERRUPT)) {\n\t\tgoto bail;\n\t}\n\n\tif (NULL == resolvedClass) {\n\t\tif (J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\n\t\t\tj9object_t exception = vmStruct->currentException;\n\t\t\t/* Class not found - if NoClassDefFoundError was thrown, mark this ref as permanently unresolveable */\n\t\t\tif (NULL != exception) {\n\t\t\t\tif (instanceOfOrCheckCast(J9OBJECT_CLAZZ(vmStruct, exception), J9VMJAVALANGLINKAGEERROR_OR_NULL(vm))) {\n\t\t\t\t\tramClassRefWrapper->modifiers = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* Perform a package access check from the current class to the resolved class.\n\t * No check is required if any of the following is true:\n\t * \t\t- the current class and resolved class are identical\n\t * \t\t- the current class was loaded by the bootstrap class loader\n\t * \t\t- the current class and resolved class are in same module\n\t */\n\tif ((currentClass != resolvedClass) \n\t\t&& (classLoader != bootstrapClassLoader)\n\t\t&& requirePackageAccessCheck(vm, classLoader, currentClass->module, resolvedClass)\n\t) {\n\t\t/* AOT resolves class refs inside J9Classes which have not yet\n\t\t * had the java/lang/Class associated with them.  canRunJavaCode must be false\n\t\t * in this case.  The protectionDomain object is only used if canRunJavaCode\n\t\t * is true, so don't bother fetching it in the false case.\n\t\t */\n\t\tj9object_t protectionDomain = NULL;\n\t\tif (canRunJavaCode) {\n\t\t\tj9object_t classObject = J9VM_J9CLASS_TO_HEAPCLASS(currentClass);\n\t\t\tAssert_VM_notNull(classObject);\n\t\t\tprotectionDomain = J9VMJAVALANGCLASS_PROTECTIONDOMAIN(vmStruct, classObject);\n\t\t}\n\t\tif (!packageAccessIsLegal(vmStruct, resolvedClass, protectionDomain, canRunJavaCode)) {\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tif (jitCompileTimeResolve) {\n\t\tif (J9_ARE_NO_BITS_SET(resolvedClass->romClass->modifiers, J9AccInterface)) {\n\t\t\tif (J9ClassInitSucceeded != resolvedClass->initializeStatus) {\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* check access permissions */\n\taccessModifiers = resolvedClass->romClass->modifiers;\n\tif (J9ROMCLASS_IS_ARRAY(resolvedClass->romClass)) {\n\t\taccessClass = ((J9ArrayClass *)resolvedClass)->leafComponentType;\n\t\taccessModifiers = accessClass->romClass->modifiers;\n\t} else {\n\t\taccessClass = resolvedClass;\n\t}\n\t{\n\t\tIDATA checkResult = checkVisibility(vmStruct, J9_CLASS_FROM_CP(ramCP), accessClass, accessModifiers, lookupOptions);\n\t\tif (checkResult < J9_VISIBILITY_ALLOWED) {\n\t\t\t/* Check for pending exception for (ie. Nesthost class loading/verify), do not overwrite these exceptions */\n\t\t\tif (canRunJavaCode && (!VM_VMHelpers::exceptionPending(vmStruct))) {\n\t\t\t\tchar *errorMsg = NULL;\n\t\t\t\tPORT_ACCESS_FROM_VMC(vmStruct);\n\t\t\t\tif (J9_VISIBILITY_NON_MODULE_ACCESS_ERROR == checkResult) {\n\t\t\t\t\terrorMsg = illegalAccessMessage(vmStruct, accessModifiers, J9_CLASS_FROM_CP(ramCP), accessClass, J9_VISIBILITY_NON_MODULE_ACCESS_ERROR);\n\t\t\t\t} else {\n\t\t\t\t\terrorMsg = illegalAccessMessage(vmStruct, -1, J9_CLASS_FROM_CP(ramCP), accessClass, checkResult);\n\t\t\t\t}\n\t\t\t\tsetCurrentExceptionUTF(vmStruct, J9VMCONSTANTPOOL_JAVALANGILLEGALACCESSERROR, errorMsg);\n\t\t\t\tj9mem_free_memory(errorMsg);\n\t\t\t}\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\taccessModifiers = resolvedClass->romClass->modifiers;\n\tif (J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_INSTANTIABLE)) {\n\t\tif (!J9ROMCLASS_ALLOCATES_VIA_NEW(resolvedClass->romClass)) {\n\t\t\tif (canRunJavaCode) {\n\t\t\t\tsetCurrentException(vmStruct, J9_EX_CTOR_CLASS + J9VMCONSTANTPOOL_JAVALANGINSTANTIATIONERROR,\n\t\t\t\t\t\t(UDATA *)resolvedClass->classObject);\n\t\t\t}\n\t\t\tgoto bail;\n\t\t}\n\t}\n\t\n\tif (J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_INIT_CLASS)) {\n\t\tUDATA initStatus = resolvedClass->initializeStatus;\n\t\tif ((J9ClassInitSucceeded != initStatus) && ((UDATA)vmStruct != initStatus)) {\n\t\t\tUDATA preCount = vm->hotSwapCount;\n\n\t\t\t/* No need to check for JITCompileTimeResolve, since it wouldn't have got this far\n\t\t\t * if the class weren't already initialized.\n\t\t\t */\n\t\t\tinitializeClass(vmStruct, resolvedClass);\n\t\t\tif (J9_ARE_ANY_BITS_SET(vmStruct->publicFlags, J9_PUBLIC_FLAGS_POP_FRAMES_INTERRUPT)) {\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (NULL != vmStruct->currentException) {\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (preCount != vm->hotSwapCount) {\n\t\t\t\tgoto tryAgain;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\n\t\tramClassRefWrapper->value = resolvedClass;\n\t\tramClassRefWrapper->modifiers = accessModifiers;\n\t}\n\ndone:\n\tTrc_VM_resolveClassRef_Exit(vmStruct, resolvedClass);\n\treturn resolvedClass; \nbail:\n\tresolvedClass = NULL;\n\tgoto done;\n}",
  "abstract_func": "J9Class *   \nresolveClassRef(J9VMThread *VAR_0, J9ConstantPool *VAR_1, UDATA VAR_2, UDATA VAR_3)\n{\n\tJ9JavaVM *VAR_4 = VAR_0->javaVM;\n\tJ9ClassLoader *VAR_5 = VAR_4->systemClassLoader;\n\tJ9Class *VAR_6 = NULL;\n\tJ9RAMClassRef *VAR_7 = NULL;\n\tJ9Class *VAR_8 = NULL;\n\tJ9Class *VAR_9 = NULL;\n\tJ9UTF8 *VAR_10 = NULL;\n\tU_16 VAR_11 = 0;\n\tU_8 *VAR_12 = NULL;\n\tJ9ROMStringRef *VAR_13 = NULL;\n\tJ9ClassLoader *VAR_14 = NULL;\n\tbool VAR_15 = J9_ARE_ANY_BITS_SET(VAR_3, VAR_16);\n\tbool VAR_17 = !VAR_15 && J9_ARE_NO_BITS_SET(VAR_3, VAR_18);\n\tbool VAR_19 = VAR_17 && J9_ARE_NO_BITS_SET(VAR_3, VAR_20);\n\tUDATA VAR_21 = 0;\n\tif (VAR_17) {\n\t\tif (!VAR_19) {\n\t\t\tVAR_21 = VAR_22;\t\t\t\n\t\t}\n\t} else {\n\t\tVAR_21 = VAR_23;\n\t}\n\tUDATA VAR_24 = 0;\n\tUDATA VAR_25 = 0;\n\tj9object_t VAR_26 = NULL;\n\tTrc_VM_resolveClassRef_Entry(VAR_0, VAR_1, VAR_2, VAR_3);\n\ntryAgain:\n\tVAR_7 = (J9RAMClassRef *)&VAR_1[VAR_2];\n\tVAR_8 = VAR_7->value;\n\t/* COMMENT_0 */\n\tif ((NULL != VAR_8) && (J9_ARE_NO_BITS_SET(VAR_3, VAR_27) || J9ROMCLASS_ALLOCATES_VIA_NEW(VAR_8->romClass))) {\n\t\t/* COMMENT_1 */\n\t\tissueReadBarrier();\n\t\tgoto done;\n\t}\n\n\tVAR_13 = (J9ROMStringRef *)&VAR_1->romConstantPool[VAR_2];\n\tVAR_10 = J9ROMSTRINGREF_UTF8DATA(VAR_13);\n\tVAR_11 = J9UTF8_LENGTH(VAR_10);\n\tVAR_12 = J9UTF8_DATA(VAR_10);\n\n\tVAR_6 = J9_CLASS_FROM_CP(VAR_1);\n\tVAR_14 = VAR_6->classLoader;\n\tif (NULL == VAR_14) {\n\t\tVAR_14 = VAR_5;\n\t}\n\n\tTrc_VM_resolveClassRef_lookup(VAR_0, VAR_11, VAR_12);\n\n\tif (VAR_17) {\n\t\tif (VAR_19) {\n\t\t\tVAR_24 |= VAR_28;\n\t\t}\n\t\tif (J9_ARE_ANY_BITS_SET(VAR_3, VAR_29)) {\n\t\t\tVAR_24 |= VAR_30;\t\t\n\t\t}\n\t} else {\n\t\tVAR_24 |= VAR_30;\n\t}\n\n\tif (VAR_7->modifiers == (UDATA)-1) {\n\t\tif ((VAR_24 & VAR_28) == VAR_28) {\n\t\t\tVAR_26 = VAR_4->memoryManagerFunctions->j9gc_createJavaLangString(VAR_0, VAR_12, VAR_11, 0);\n\t\t\tif (VAR_19) {\n\t\t\t\tif (NULL == VAR_0->currentException) {\n\t\t\t\t\tsetCurrentException(VAR_0, VAR_31, (UDATA *)VAR_26);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tVM_VMHelpers::clearException(VAR_0);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\n#if defined(VAR_32)\n\tif ((';' == *(char *)(VAR_12 + (VAR_11 - 1)))\n\t\t&& ('Q' == *(char *)VAR_12)\n\t) {\n\t\t/* COMMENT_2 */\n\t\tVAR_12 += 1;\n\t\tVAR_11 -= 2;\n\t}\n#endif /* COMMENT_3 */\n\n\tVAR_8 = internalFindClassUTF8(VAR_0, VAR_12, VAR_11,\n\t\t\tVAR_14, VAR_24);\n\n\t/* COMMENT_4 */\n\tif (J9_ARE_ANY_BITS_SET(VAR_0->publicFlags, VAR_33)) {\n\t\tgoto bail;\n\t}\n\n\tif (NULL == VAR_8) {\n\t\tif (J9_ARE_NO_BITS_SET(VAR_3, VAR_34)) {\n\t\t\tj9object_t VAR_35 = VAR_0->currentException;\n\t\t\t/* COMMENT_5 */\n\t\t\tif (NULL != VAR_35) {\n\t\t\t\tif (instanceOfOrCheckCast(J9OBJECT_CLAZZ(VAR_0, VAR_35), J9VMJAVALANGLINKAGEERROR_OR_NULL(VAR_4))) {\n\t\t\t\t\tVAR_7->modifiers = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* COMMENT_6 */\n                                                         \n                                                          \n                                                                  \n                                                               \n    \n\tif ((VAR_6 != VAR_8) \n\t\t&& (VAR_14 != VAR_5)\n\t\t&& requirePackageAccessCheck(VAR_4, VAR_14, VAR_6->module, VAR_8)\n\t) {\n\t\t/* COMMENT_12 */\n                                                                                \n                                                                              \n                                                            \n     \n\t\tj9object_t VAR_36 = NULL;\n\t\tif (VAR_17) {\n\t\t\tj9object_t VAR_37 = J9VM_J9CLASS_TO_HEAPCLASS(VAR_6);\n\t\t\tAssert_VM_notNull(VAR_37);\n\t\t\tVAR_36 = J9VMJAVALANGCLASS_PROTECTIONDOMAIN(VAR_0, VAR_37);\n\t\t}\n\t\tif (!packageAccessIsLegal(VAR_0, VAR_8, VAR_36, VAR_17)) {\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tif (VAR_15) {\n\t\tif (J9_ARE_NO_BITS_SET(VAR_8->romClass->modifiers, VAR_38)) {\n\t\t\tif (VAR_39 != VAR_8->initializeStatus) {\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* COMMENT_17 */\n\tVAR_25 = VAR_8->romClass->modifiers;\n\tif (J9ROMCLASS_IS_ARRAY(VAR_8->romClass)) {\n\t\tVAR_9 = ((J9ArrayClass *)VAR_8)->leafComponentType;\n\t\tVAR_25 = VAR_9->romClass->modifiers;\n\t} else {\n\t\tVAR_9 = VAR_8;\n\t}\n\t{\n\t\tIDATA VAR_40 = checkVisibility(VAR_0, J9_CLASS_FROM_CP(VAR_1), VAR_9, VAR_25, VAR_21);\n\t\tif (VAR_40 < VAR_41) {\n\t\t\t/* COMMENT_18 */\n\t\t\tif (VAR_17 && (!VM_VMHelpers::exceptionPending(VAR_0))) {\n\t\t\t\tchar *VAR_42 = NULL;\n\t\t\t\tPORT_ACCESS_FROM_VMC(VAR_0);\n\t\t\t\tif (VAR_43 == VAR_40) {\n\t\t\t\t\tVAR_42 = illegalAccessMessage(VAR_0, VAR_25, J9_CLASS_FROM_CP(VAR_1), VAR_9, VAR_43);\n\t\t\t\t} else {\n\t\t\t\t\tVAR_42 = illegalAccessMessage(VAR_0, -1, J9_CLASS_FROM_CP(VAR_1), VAR_9, VAR_40);\n\t\t\t\t}\n\t\t\t\tsetCurrentExceptionUTF(VAR_0, VAR_44, VAR_42);\n\t\t\t\tj9mem_free_memory(VAR_42);\n\t\t\t}\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tVAR_25 = VAR_8->romClass->modifiers;\n\tif (J9_ARE_ANY_BITS_SET(VAR_3, VAR_27)) {\n\t\tif (!J9ROMCLASS_ALLOCATES_VIA_NEW(VAR_8->romClass)) {\n\t\t\tif (VAR_17) {\n\t\t\t\tsetCurrentException(VAR_0, VAR_45 + VAR_46,\n\t\t\t\t\t\t(UDATA *)VAR_8->classObject);\n\t\t\t}\n\t\t\tgoto bail;\n\t\t}\n\t}\n\t\n\tif (J9_ARE_ANY_BITS_SET(VAR_3, VAR_47)) {\n\t\tUDATA VAR_48 = VAR_8->initializeStatus;\n\t\tif ((VAR_39 != VAR_48) && ((UDATA)VAR_0 != VAR_48)) {\n\t\t\tUDATA VAR_49 = VAR_4->hotSwapCount;\n\n\t\t\t/* COMMENT_19 */\n                                               \n      \n\t\t\tinitializeClass(VAR_0, VAR_8);\n\t\t\tif (J9_ARE_ANY_BITS_SET(VAR_0->publicFlags, VAR_33)) {\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (NULL != VAR_0->currentException) {\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (VAR_49 != VAR_4->hotSwapCount) {\n\t\t\t\tgoto tryAgain;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (J9_ARE_NO_BITS_SET(VAR_3, VAR_34)) {\n\t\tVAR_7->value = VAR_8;\n\t\tVAR_7->modifiers = VAR_25;\n\t}\n\ndone:\n\tTrc_VM_resolveClassRef_Exit(VAR_0, VAR_8);\n\treturn VAR_8; \nbail:\n\tVAR_8 = NULL;\n\tgoto done;\n}",
  "func_graph_path": "eclipse-openj9/openj9/840f3af31a5b8d2d395d9367c826ed756e380fb9/resolvesupport.cpp/vul/after/13.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -53,10 +53,13 @@\n \n \tif (canRunJavaCode) {\n \t\tif (throwException) {\n-\t\t\tfindClassFlags = J9_FINDCLASS_FLAG_THROW_ON_FAIL;\n+\t\t\tfindClassFlags |= J9_FINDCLASS_FLAG_THROW_ON_FAIL;\n+\t\t}\n+\t\tif (J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CLASS_LOAD)) {\n+\t\t\tfindClassFlags |= J9_FINDCLASS_FLAG_EXISTING_ONLY;\t\t\n \t\t}\n \t} else {\n-\t\tfindClassFlags = J9_FINDCLASS_FLAG_EXISTING_ONLY;\n+\t\tfindClassFlags |= J9_FINDCLASS_FLAG_EXISTING_ONLY;\n \t}\n \n \tif (ramClassRefWrapper->modifiers == (UDATA)-1) {\n@@ -92,14 +95,16 @@\n \t}\n \n \tif (NULL == resolvedClass) {\n-\t\tj9object_t exception = vmStruct->currentException;\n-\t\t/* Class not found - if NoClassDefFoundError was thrown, mark this ref as permanently unresolveable */\n-\t\tif (NULL != exception) {\n-\t\t\tif (instanceOfOrCheckCast(J9OBJECT_CLAZZ(vmStruct, exception), J9VMJAVALANGLINKAGEERROR_OR_NULL(vm))) {\n-\t\t\t\tramClassRefWrapper->modifiers = -1;\n-\t\t\t}\n-\t\t}\n-\t\tgoto done;\n+\t\tif (J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\n+\t\t\tj9object_t exception = vmStruct->currentException;\n+\t\t\t/* Class not found - if NoClassDefFoundError was thrown, mark this ref as permanently unresolveable */\n+\t\t\tif (NULL != exception) {\n+\t\t\t\tif (instanceOfOrCheckCast(J9OBJECT_CLAZZ(vmStruct, exception), J9VMJAVALANGLINKAGEERROR_OR_NULL(vm))) {\n+\t\t\t\t\tramClassRefWrapper->modifiers = -1;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tgoto done;\n+\t\t}\n \t}\n \n \t/* Perform a package access check from the current class to the resolved class.\n@@ -195,8 +200,10 @@\n \t\t}\n \t}\n \n-\tramClassRefWrapper->value = resolvedClass;\n-\tramClassRefWrapper->modifiers = accessModifiers;\n+\tif (J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\n+\t\tramClassRefWrapper->value = resolvedClass;\n+\t\tramClassRefWrapper->modifiers = accessModifiers;\n+\t}\n \n done:\n \tTrc_VM_resolveClassRef_Exit(vmStruct, resolvedClass);",
  "diff_line_info": {
    "deleted_lines": [
      "\t\t\tfindClassFlags = J9_FINDCLASS_FLAG_THROW_ON_FAIL;",
      "\t\tfindClassFlags = J9_FINDCLASS_FLAG_EXISTING_ONLY;",
      "\t\tj9object_t exception = vmStruct->currentException;",
      "\t\t/* Class not found - if NoClassDefFoundError was thrown, mark this ref as permanently unresolveable */",
      "\t\tif (NULL != exception) {",
      "\t\t\tif (instanceOfOrCheckCast(J9OBJECT_CLAZZ(vmStruct, exception), J9VMJAVALANGLINKAGEERROR_OR_NULL(vm))) {",
      "\t\t\t\tramClassRefWrapper->modifiers = -1;",
      "\t\t\t}",
      "\t\t}",
      "\t\tgoto done;",
      "\tramClassRefWrapper->value = resolvedClass;",
      "\tramClassRefWrapper->modifiers = accessModifiers;"
    ],
    "added_lines": [
      "\t\t\tfindClassFlags |= J9_FINDCLASS_FLAG_THROW_ON_FAIL;",
      "\t\t}",
      "\t\tif (J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CLASS_LOAD)) {",
      "\t\t\tfindClassFlags |= J9_FINDCLASS_FLAG_EXISTING_ONLY;\t\t",
      "\t\tfindClassFlags |= J9_FINDCLASS_FLAG_EXISTING_ONLY;",
      "\t\tif (J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {",
      "\t\t\tj9object_t exception = vmStruct->currentException;",
      "\t\t\t/* Class not found - if NoClassDefFoundError was thrown, mark this ref as permanently unresolveable */",
      "\t\t\tif (NULL != exception) {",
      "\t\t\t\tif (instanceOfOrCheckCast(J9OBJECT_CLAZZ(vmStruct, exception), J9VMJAVALANGLINKAGEERROR_OR_NULL(vm))) {",
      "\t\t\t\t\tramClassRefWrapper->modifiers = -1;",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t\tgoto done;",
      "\t\t}",
      "\tif (J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {",
      "\t\tramClassRefWrapper->value = resolvedClass;",
      "\t\tramClassRefWrapper->modifiers = accessModifiers;",
      "\t}"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/eclipse-openj9/openj9/pull/12148",
  "description": {
    "pr_info": {
      "title": "Correctly load/initialize classes when using ConstantPool",
      "number": 12148
    },
    "comment": [
      "- do not load classes in the \"ifLoaded\" calls\r\n- never intitialize classes in the natives\r\n- do not update the constant pool when querying from the natives\r\n\r\nFixes: #12016\r\n\r\n[ci skip]\r\n\r\nSigned-off-by: Graham Chapman <graham_chapman@ca.ibm.com>",
      "jenkins test sanity,extended zlinux jdk11",
      "jenkins compile win jdk8",
      "@gacholio can you please open another PR for the 0.26 stream",
      "https://github.com/eclipse/openj9/pull/12164"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.7,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch modifies class loading and initialization processes to prevent certain operations, addressing a bug without clear security implications.\n\nFinal Classification: Defect Remediation & Feature Upgrades\n\nConfidence Score: 0.7"
}