{
  "cve_id": "CVE-2021-28167",
  "cwe_ids": [
    "CWE-909"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "eclipse-openj9/openj9",
  "commit_msg": "Correctly load/initialize classes when using ConstantPool\n\n- do not load classes in the \"ifLoaded\" calls\n- never intitialize classes in the natives\n- do not update the constant pool when querying from the natives\n\nFixes: #12016\n\n[ci skip]\n\nSigned-off-by: Graham Chapman <graham_chapman@ca.ibm.com>",
  "commit_hash": "840f3af31a5b8d2d395d9367c826ed756e380fb9",
  "git_url": "https://github.com/eclipse-openj9/openj9/commit/840f3af31a5b8d2d395d9367c826ed756e380fb9",
  "file_path": "runtime/vm/resolvesupport.cpp",
  "func_name": "resolveSpecialMethodRefInto",
  "func_before": "J9Method *   \nresolveSpecialMethodRefInto(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags, J9RAMSpecialMethodRef *ramCPEntry)\n{\n\tJ9ROMMethodRef *romMethodRef;\n\tJ9Class *resolvedClass;\n\tJ9Class *currentClass;\n\tJ9ROMNameAndSignature *nameAndSig;\n\tJ9Method *method = NULL;\n\tbool jitCompileTimeResolve = J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_JIT_COMPILE_TIME);\n\tbool canRunJavaCode = !jitCompileTimeResolve && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_REDEFINE_CLASS);\n\tbool throwException = canRunJavaCode && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);\n\tUDATA lookupOptions = 0;\n\tif (canRunJavaCode) {\n\t\tif (!throwException) {\n\t\t\tlookupOptions = J9_LOOK_NO_THROW;\t\t\t\n\t\t}\n\t} else {\n\t\tlookupOptions = J9_LOOK_NO_JAVA;\n\t}\n\n\tTrc_VM_resolveSpecialMethodRef_Entry(vmStruct, ramCP, cpIndex, resolveFlags);\n\n\tromMethodRef = (J9ROMMethodRef *)&ramCP->romConstantPool[cpIndex];\n\n\tcheckForDecompile(vmStruct, romMethodRef, jitCompileTimeResolve);\n\n\t/* Resolve the class. */\n\tresolvedClass = resolveClassRef(vmStruct, ramCP, romMethodRef->classRefCPIndex, resolveFlags);\n\t\n\t/* If resolvedClass is NULL, the exception has already been set. */\n\tif (resolvedClass == NULL) {\n\t\tgoto done;\n\t}\n\n\t/* Find the targetted method. */\n\tcurrentClass = J9_CLASS_FROM_CP(ramCP);\n\t/* Obtain the most recent class version. ramCP->class might be pointing at an old\n\t * class version after a possible HCR in the resolveClassRef above. Reaching for vtable slots in\n\t * the old version will cause bogosity as they are never initialized by fastHCR */\n\tcurrentClass = J9_CURRENT_CLASS(currentClass);\n\tnameAndSig = J9ROMFIELDREF_NAMEANDSIGNATURE(romMethodRef);\n\n\t/* REASON FOR THE J9_LOOK_HANDLE_DEFAULT_METHOD_CONFLICTS:\n\t * Virtual invocation modes may still find a method in the receiver's vtable that resolves the default method conflict.\n\t * If not, the method in the vtable will be a special method for throwing the exception.\n\t *\n\t * Special invocations (defender supersends) will not look at the receiver's vtable, but instead invoke the result of javaLookupMethod.\n\t * Default method conflicts must therefore be handled by the lookup code.\n\t */\n\tlookupOptions |= (J9_LOOK_VIRTUAL | J9_LOOK_ALLOW_FWD | J9_LOOK_HANDLE_DEFAULT_METHOD_CONFLICTS);\n\n\tif ((resolveFlags & J9_RESOLVE_FLAG_JCL_CONSTANT_POOL) != J9_RESOLVE_FLAG_JCL_CONSTANT_POOL) {\n\t\tlookupOptions |= J9_LOOK_CLCONSTRAINTS;\n\t}\n\n\tif (J2SE_VERSION(vmStruct->javaVM) >= J2SE_V11) {\n\t\t/* This check is only required in Java9 and there have been applications that\n\t\t * fail when this check is enabled on Java8.\n\t\t */\n\t\tif (currentClass != NULL) {\n\t\t\tif ((resolvedClass->romClass != NULL) && (currentClass->romClass != NULL)) {\n\t\t\t\t/* Ensure the cpType is taken from the original class.  The cpIndex\n\t\t\t\t * and J9Class must match, even if a redefinition occurs, or the\n\t\t\t\t * check may incorrectly fail.\n\t\t\t\t */\n\t\t\t\tUDATA cpType = J9_CP_TYPE(J9ROMCLASS_CPSHAPEDESCRIPTION(J9_CLASS_FROM_CP(ramCP)->romClass), cpIndex);\n\t\t\t\tif (J9AccInterface == (resolvedClass->romClass->modifiers & J9AccInterface)) {\n\t\t\t\t\tif ((J9CPTYPE_INTERFACE_INSTANCE_METHOD != cpType)\n\t\t\t\t\t&& (J9CPTYPE_INTERFACE_STATIC_METHOD != cpType)\n\t\t\t\t\t&& (J9CPTYPE_INTERFACE_METHOD != cpType)\n\t\t\t\t\t) {\nincompat:\n\t\t\t\t\t\tif (throwException) {\n\t\t\t\t\t\t\tsetCurrentException(vmStruct, J9VMCONSTANTPOOL_JAVALANGINCOMPATIBLECLASSCHANGEERROR, NULL);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ((J9CPTYPE_INTERFACE_INSTANCE_METHOD == cpType)\n\t\t\t\t\t|| (J9CPTYPE_INTERFACE_STATIC_METHOD == cpType)\n\t\t\t\t\t|| (J9CPTYPE_INTERFACE_METHOD == cpType)\n\t\t\t\t\t) {\n\t\t\t\t\t\tgoto incompat;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tmethod = (J9Method *)javaLookupMethod(vmStruct, resolvedClass, nameAndSig, currentClass, lookupOptions);\n\t\n\tTrc_VM_resolveSpecialMethodRef_lookupMethod(vmStruct, method);\n\t\n\tif (method == NULL) {\n\t\tgoto done;\n\t} else {\n\t\t/* JVMS 4.9.2: If resolvedClass is an interface, ensure that it is a DIRECT superinterface\n\t\t * of currentClass (or resolvedClass == currentClass).\n\t\t */\n\t\tif (!isDirectSuperInterface(vmStruct, resolvedClass, currentClass)) {\n\t\t\tif (throwException) {\n\t\t\t\tsetIncompatibleClassChangeErrorInvalidDefenderSupersend(vmStruct, resolvedClass, currentClass);\n\t\t\t}\n\t\t\tmethod = NULL;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* Select the correct method for invocation - ignore visibility in the super send case */\n\tmethod = getMethodForSpecialSend(vmStruct, currentClass, resolvedClass, method, lookupOptions | J9_LOOK_NO_VISIBILITY_CHECK | J9_LOOK_IGNORE_INCOMPATIBLE_METHODS);\n\tif (NULL == method) {\n\t\tgoto done;\n\t}\n\n\tif (NULL != ramCPEntry) {\n\t\tramCPEntry->method = method;\n\t}\n\ndone:\n\tTrc_VM_resolveSpecialMethodRef_Exit(vmStruct, method);\n\treturn method;\n}",
  "abstract_func_before": "J9Method *   \nresolveSpecialMethodRefInto(J9VMThread *VAR_0, J9ConstantPool *VAR_1, UDATA VAR_2, UDATA VAR_3, J9RAMSpecialMethodRef *VAR_4)\n{\n\tJ9ROMMethodRef *VAR_5;\n\tJ9Class *VAR_6;\n\tJ9Class *VAR_7;\n\tJ9ROMNameAndSignature *VAR_8;\n\tJ9Method *VAR_9 = NULL;\n\tbool VAR_10 = J9_ARE_ANY_BITS_SET(VAR_3, VAR_11);\n\tbool VAR_12 = !VAR_10 && J9_ARE_NO_BITS_SET(VAR_3, VAR_13);\n\tbool VAR_14 = VAR_12 && J9_ARE_NO_BITS_SET(VAR_3, VAR_15);\n\tUDATA VAR_16 = 0;\n\tif (VAR_12) {\n\t\tif (!VAR_14) {\n\t\t\tVAR_16 = VAR_17;\t\t\t\n\t\t}\n\t} else {\n\t\tVAR_16 = VAR_18;\n\t}\n\n\tTrc_VM_resolveSpecialMethodRef_Entry(VAR_0, VAR_1, VAR_2, VAR_3);\n\n\tVAR_5 = (J9ROMMethodRef *)&VAR_1->romConstantPool[VAR_2];\n\n\tcheckForDecompile(VAR_0, VAR_5, VAR_10);\n\n\t/* COMMENT_0 */\n\tVAR_6 = resolveClassRef(VAR_0, VAR_1, VAR_5->classRefCPIndex, VAR_3);\n\t\n\t/* COMMENT_1 */\n\tif (VAR_6 == NULL) {\n\t\tgoto done;\n\t}\n\n\t/* COMMENT_2 */\n\tVAR_7 = J9_CLASS_FROM_CP(VAR_1);\n\t/* COMMENT_3 */\n                                                                                                 \n                                                                                   \n\tVAR_7 = J9_CURRENT_CLASS(VAR_7);\n\tVAR_8 = J9ROMFIELDREF_NAMEANDSIGNATURE(VAR_5);\n\n\t/* COMMENT_6 */\n                                                                                                                        \n                                                                                         \n   \n                                                                                                                                        \n                                                                          \n    \n\tVAR_16 |= (VAR_19 | VAR_20 | VAR_21);\n\n\tif ((VAR_3 & VAR_22) != VAR_22) {\n\t\tVAR_16 |= VAR_23;\n\t}\n\n\tif (J2SE_VERSION(VAR_0->javaVM) >= VAR_24) {\n\t\t/* COMMENT_13 */\n                                              \n     \n\t\tif (VAR_7 != NULL) {\n\t\t\tif ((VAR_6->romClass != NULL) && (VAR_7->romClass != NULL)) {\n\t\t\t\t/* COMMENT_16 */\n                                                                    \n                                  \n       \n\t\t\t\tUDATA VAR_25 = J9_CP_TYPE(J9ROMCLASS_CPSHAPEDESCRIPTION(J9_CLASS_FROM_CP(VAR_1)->romClass), VAR_2);\n\t\t\t\tif (VAR_26 == (VAR_6->romClass->modifiers & VAR_26)) {\n\t\t\t\t\tif ((VAR_27 != VAR_25)\n\t\t\t\t\t&& (VAR_28 != VAR_25)\n\t\t\t\t\t&& (VAR_29 != VAR_25)\n\t\t\t\t\t) {\nincompat:\n\t\t\t\t\t\tif (VAR_14) {\n\t\t\t\t\t\t\tsetCurrentException(VAR_0, VAR_30, NULL);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ((VAR_27 == VAR_25)\n\t\t\t\t\t|| (VAR_28 == VAR_25)\n\t\t\t\t\t|| (VAR_29 == VAR_25)\n\t\t\t\t\t) {\n\t\t\t\t\t\tgoto incompat;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tVAR_9 = (J9Method *)javaLookupMethod(VAR_0, VAR_6, VAR_8, VAR_7, VAR_16);\n\t\n\tTrc_VM_resolveSpecialMethodRef_lookupMethod(VAR_0, VAR_9);\n\t\n\tif (VAR_9 == NULL) {\n\t\tgoto done;\n\t} else {\n\t\t/* COMMENT_20 */\n                                                        \n     \n\t\tif (!isDirectSuperInterface(VAR_0, VAR_6, VAR_7)) {\n\t\t\tif (VAR_14) {\n\t\t\t\tsetIncompatibleClassChangeErrorInvalidDefenderSupersend(VAR_0, VAR_6, VAR_7);\n\t\t\t}\n\t\t\tVAR_9 = NULL;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* COMMENT_23 */\n\tVAR_9 = getMethodForSpecialSend(VAR_0, VAR_7, VAR_6, VAR_9, VAR_16 | VAR_31 | VAR_32);\n\tif (NULL == VAR_9) {\n\t\tgoto done;\n\t}\n\n\tif (NULL != VAR_4) {\n\t\tVAR_4->method = VAR_9;\n\t}\n\ndone:\n\tTrc_VM_resolveSpecialMethodRef_Exit(VAR_0, VAR_9);\n\treturn VAR_9;\n}",
  "func_graph_path_before": "eclipse-openj9/openj9/840f3af31a5b8d2d395d9367c826ed756e380fb9/resolvesupport.cpp/vul/before/14.json",
  "func": "J9Method *   \nresolveSpecialMethodRefInto(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags, J9RAMSpecialMethodRef *ramCPEntry)\n{\n\tJ9ROMMethodRef *romMethodRef;\n\tJ9Class *resolvedClass;\n\tJ9Class *currentClass;\n\tJ9ROMNameAndSignature *nameAndSig;\n\tJ9Method *method = NULL;\n\tbool jitCompileTimeResolve = J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_JIT_COMPILE_TIME);\n\tbool canRunJavaCode = !jitCompileTimeResolve && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_REDEFINE_CLASS);\n\tbool throwException = canRunJavaCode && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);\n\tUDATA lookupOptions = 0;\n\tif (canRunJavaCode) {\n\t\tif (!throwException) {\n\t\t\tlookupOptions = J9_LOOK_NO_THROW;\t\t\t\n\t\t}\n\t} else {\n\t\tlookupOptions = J9_LOOK_NO_JAVA;\n\t}\n\n\tTrc_VM_resolveSpecialMethodRef_Entry(vmStruct, ramCP, cpIndex, resolveFlags);\n\n\tromMethodRef = (J9ROMMethodRef *)&ramCP->romConstantPool[cpIndex];\n\n\tcheckForDecompile(vmStruct, romMethodRef, jitCompileTimeResolve);\n\n\t/* Resolve the class. */\n\tresolvedClass = resolveClassRef(vmStruct, ramCP, romMethodRef->classRefCPIndex, resolveFlags);\n\t\n\t/* If resolvedClass is NULL, the exception has already been set. */\n\tif (resolvedClass == NULL) {\n\t\tgoto done;\n\t}\n\n\t/* Find the targetted method. */\n\tcurrentClass = J9_CLASS_FROM_CP(ramCP);\n\t/* Obtain the most recent class version. ramCP->class might be pointing at an old\n\t * class version after a possible HCR in the resolveClassRef above. Reaching for vtable slots in\n\t * the old version will cause bogosity as they are never initialized by fastHCR */\n\tcurrentClass = J9_CURRENT_CLASS(currentClass);\n\tnameAndSig = J9ROMFIELDREF_NAMEANDSIGNATURE(romMethodRef);\n\n\t/* REASON FOR THE J9_LOOK_HANDLE_DEFAULT_METHOD_CONFLICTS:\n\t * Virtual invocation modes may still find a method in the receiver's vtable that resolves the default method conflict.\n\t * If not, the method in the vtable will be a special method for throwing the exception.\n\t *\n\t * Special invocations (defender supersends) will not look at the receiver's vtable, but instead invoke the result of javaLookupMethod.\n\t * Default method conflicts must therefore be handled by the lookup code.\n\t */\n\tlookupOptions |= (J9_LOOK_VIRTUAL | J9_LOOK_ALLOW_FWD | J9_LOOK_HANDLE_DEFAULT_METHOD_CONFLICTS);\n\n\tif ((resolveFlags & J9_RESOLVE_FLAG_JCL_CONSTANT_POOL) != J9_RESOLVE_FLAG_JCL_CONSTANT_POOL) {\n\t\tlookupOptions |= J9_LOOK_CLCONSTRAINTS;\n\t}\n\n\tif (J2SE_VERSION(vmStruct->javaVM) >= J2SE_V11) {\n\t\t/* This check is only required in Java9 and there have been applications that\n\t\t * fail when this check is enabled on Java8.\n\t\t */\n\t\tif (currentClass != NULL) {\n\t\t\tif ((resolvedClass->romClass != NULL) && (currentClass->romClass != NULL)) {\n\t\t\t\t/* Ensure the cpType is taken from the original class.  The cpIndex\n\t\t\t\t * and J9Class must match, even if a redefinition occurs, or the\n\t\t\t\t * check may incorrectly fail.\n\t\t\t\t */\n\t\t\t\tUDATA cpType = J9_CP_TYPE(J9ROMCLASS_CPSHAPEDESCRIPTION(J9_CLASS_FROM_CP(ramCP)->romClass), cpIndex);\n\t\t\t\tif (J9AccInterface == (resolvedClass->romClass->modifiers & J9AccInterface)) {\n\t\t\t\t\tif ((J9CPTYPE_INTERFACE_INSTANCE_METHOD != cpType)\n\t\t\t\t\t&& (J9CPTYPE_INTERFACE_STATIC_METHOD != cpType)\n\t\t\t\t\t&& (J9CPTYPE_INTERFACE_METHOD != cpType)\n\t\t\t\t\t) {\nincompat:\n\t\t\t\t\t\tif (throwException) {\n\t\t\t\t\t\t\tsetCurrentException(vmStruct, J9VMCONSTANTPOOL_JAVALANGINCOMPATIBLECLASSCHANGEERROR, NULL);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ((J9CPTYPE_INTERFACE_INSTANCE_METHOD == cpType)\n\t\t\t\t\t|| (J9CPTYPE_INTERFACE_STATIC_METHOD == cpType)\n\t\t\t\t\t|| (J9CPTYPE_INTERFACE_METHOD == cpType)\n\t\t\t\t\t) {\n\t\t\t\t\t\tgoto incompat;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tmethod = (J9Method *)javaLookupMethod(vmStruct, resolvedClass, nameAndSig, currentClass, lookupOptions);\n\t\n\tTrc_VM_resolveSpecialMethodRef_lookupMethod(vmStruct, method);\n\t\n\tif (method == NULL) {\n\t\tgoto done;\n\t} else {\n\t\t/* JVMS 4.9.2: If resolvedClass is an interface, ensure that it is a DIRECT superinterface\n\t\t * of currentClass (or resolvedClass == currentClass).\n\t\t */\n\t\tif (!isDirectSuperInterface(vmStruct, resolvedClass, currentClass)) {\n\t\t\tif (throwException) {\n\t\t\t\tsetIncompatibleClassChangeErrorInvalidDefenderSupersend(vmStruct, resolvedClass, currentClass);\n\t\t\t}\n\t\t\tmethod = NULL;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* Select the correct method for invocation - ignore visibility in the super send case */\n\tmethod = getMethodForSpecialSend(vmStruct, currentClass, resolvedClass, method, lookupOptions | J9_LOOK_NO_VISIBILITY_CHECK | J9_LOOK_IGNORE_INCOMPATIBLE_METHODS);\n\tif (NULL == method) {\n\t\tgoto done;\n\t}\n\n\tif ((NULL != ramCPEntry) && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\n\t\tramCPEntry->method = method;\n\t}\n\ndone:\n\tTrc_VM_resolveSpecialMethodRef_Exit(vmStruct, method);\n\treturn method;\n}",
  "abstract_func": "J9Method *   \nresolveSpecialMethodRefInto(J9VMThread *VAR_0, J9ConstantPool *VAR_1, UDATA VAR_2, UDATA VAR_3, J9RAMSpecialMethodRef *VAR_4)\n{\n\tJ9ROMMethodRef *VAR_5;\n\tJ9Class *VAR_6;\n\tJ9Class *VAR_7;\n\tJ9ROMNameAndSignature *VAR_8;\n\tJ9Method *VAR_9 = NULL;\n\tbool VAR_10 = J9_ARE_ANY_BITS_SET(VAR_3, VAR_11);\n\tbool VAR_12 = !VAR_10 && J9_ARE_NO_BITS_SET(VAR_3, VAR_13);\n\tbool VAR_14 = VAR_12 && J9_ARE_NO_BITS_SET(VAR_3, VAR_15);\n\tUDATA VAR_16 = 0;\n\tif (VAR_12) {\n\t\tif (!VAR_14) {\n\t\t\tVAR_16 = VAR_17;\t\t\t\n\t\t}\n\t} else {\n\t\tVAR_16 = VAR_18;\n\t}\n\n\tTrc_VM_resolveSpecialMethodRef_Entry(VAR_0, VAR_1, VAR_2, VAR_3);\n\n\tVAR_5 = (J9ROMMethodRef *)&VAR_1->romConstantPool[VAR_2];\n\n\tcheckForDecompile(VAR_0, VAR_5, VAR_10);\n\n\t/* COMMENT_0 */\n\tVAR_6 = resolveClassRef(VAR_0, VAR_1, VAR_5->classRefCPIndex, VAR_3);\n\t\n\t/* COMMENT_1 */\n\tif (VAR_6 == NULL) {\n\t\tgoto done;\n\t}\n\n\t/* COMMENT_2 */\n\tVAR_7 = J9_CLASS_FROM_CP(VAR_1);\n\t/* COMMENT_3 */\n                                                                                                 \n                                                                                   \n\tVAR_7 = J9_CURRENT_CLASS(VAR_7);\n\tVAR_8 = J9ROMFIELDREF_NAMEANDSIGNATURE(VAR_5);\n\n\t/* COMMENT_6 */\n                                                                                                                        \n                                                                                         \n   \n                                                                                                                                        \n                                                                          \n    \n\tVAR_16 |= (VAR_19 | VAR_20 | VAR_21);\n\n\tif ((VAR_3 & VAR_22) != VAR_22) {\n\t\tVAR_16 |= VAR_23;\n\t}\n\n\tif (J2SE_VERSION(VAR_0->javaVM) >= VAR_24) {\n\t\t/* COMMENT_13 */\n                                              \n     \n\t\tif (VAR_7 != NULL) {\n\t\t\tif ((VAR_6->romClass != NULL) && (VAR_7->romClass != NULL)) {\n\t\t\t\t/* COMMENT_16 */\n                                                                    \n                                  \n       \n\t\t\t\tUDATA VAR_25 = J9_CP_TYPE(J9ROMCLASS_CPSHAPEDESCRIPTION(J9_CLASS_FROM_CP(VAR_1)->romClass), VAR_2);\n\t\t\t\tif (VAR_26 == (VAR_6->romClass->modifiers & VAR_26)) {\n\t\t\t\t\tif ((VAR_27 != VAR_25)\n\t\t\t\t\t&& (VAR_28 != VAR_25)\n\t\t\t\t\t&& (VAR_29 != VAR_25)\n\t\t\t\t\t) {\nincompat:\n\t\t\t\t\t\tif (VAR_14) {\n\t\t\t\t\t\t\tsetCurrentException(VAR_0, VAR_30, NULL);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ((VAR_27 == VAR_25)\n\t\t\t\t\t|| (VAR_28 == VAR_25)\n\t\t\t\t\t|| (VAR_29 == VAR_25)\n\t\t\t\t\t) {\n\t\t\t\t\t\tgoto incompat;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tVAR_9 = (J9Method *)javaLookupMethod(VAR_0, VAR_6, VAR_8, VAR_7, VAR_16);\n\t\n\tTrc_VM_resolveSpecialMethodRef_lookupMethod(VAR_0, VAR_9);\n\t\n\tif (VAR_9 == NULL) {\n\t\tgoto done;\n\t} else {\n\t\t/* COMMENT_20 */\n                                                        \n     \n\t\tif (!isDirectSuperInterface(VAR_0, VAR_6, VAR_7)) {\n\t\t\tif (VAR_14) {\n\t\t\t\tsetIncompatibleClassChangeErrorInvalidDefenderSupersend(VAR_0, VAR_6, VAR_7);\n\t\t\t}\n\t\t\tVAR_9 = NULL;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* COMMENT_23 */\n\tVAR_9 = getMethodForSpecialSend(VAR_0, VAR_7, VAR_6, VAR_9, VAR_16 | VAR_31 | VAR_32);\n\tif (NULL == VAR_9) {\n\t\tgoto done;\n\t}\n\n\tif ((NULL != VAR_4) && J9_ARE_NO_BITS_SET(VAR_3, VAR_33)) {\n\t\tVAR_4->method = VAR_9;\n\t}\n\ndone:\n\tTrc_VM_resolveSpecialMethodRef_Exit(VAR_0, VAR_9);\n\treturn VAR_9;\n}",
  "func_graph_path": "eclipse-openj9/openj9/840f3af31a5b8d2d395d9367c826ed756e380fb9/resolvesupport.cpp/vul/after/14.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -112,7 +112,7 @@\n \t\tgoto done;\n \t}\n \n-\tif (NULL != ramCPEntry) {\n+\tif ((NULL != ramCPEntry) && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\n \t\tramCPEntry->method = method;\n \t}\n ",
  "diff_line_info": {
    "deleted_lines": [
      "\tif (NULL != ramCPEntry) {"
    ],
    "added_lines": [
      "\tif ((NULL != ramCPEntry) && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/eclipse-openj9/openj9/pull/12148",
  "description": {
    "pr_info": {
      "title": "Correctly load/initialize classes when using ConstantPool",
      "number": 12148
    },
    "comment": [
      "- do not load classes in the \"ifLoaded\" calls\r\n- never intitialize classes in the natives\r\n- do not update the constant pool when querying from the natives\r\n\r\nFixes: #12016\r\n\r\n[ci skip]\r\n\r\nSigned-off-by: Graham Chapman <graham_chapman@ca.ibm.com>",
      "jenkins test sanity,extended zlinux jdk11",
      "jenkins compile win jdk8",
      "@gacholio can you please open another PR for the 0.26 stream",
      "https://github.com/eclipse/openj9/pull/12164"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.85,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses incorrect class loading and constant pool updates, preventing unintended class initialization. While it improves system correctness, there's no explicit indication of a security exploit being fixed.\n\nFinal Classification: Defect Remediation & Feature Upgrades\n\nConfidence Score: 0.85"
}