{
  "cve_id": "CVE-2020-15266",
  "cwe_ids": [
    "CWE-119"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "tensorflow",
  "commit_msg": "Fix segmentation fault in tf.image.crop_and_resize when boxes is inf or nan\n\nThis fix tries to address the issue raised in 42129 where segmentation fault\nhappened in tf.image.crop_and_resize when boxes is inf or nan.\n\nThis fix adds the check to make sure boxes is not inf or nan (isfinite)\n\nThis fix fixes 42129.\n\nSigned-off-by: Yong Tang <yong.tang.github@outlook.com>",
  "commit_hash": "3ade2efec2e90c6237de32a19680caaa3ebc2845",
  "git_url": "https://github.com/tensorflow/tensorflow/commit/3ade2efec2e90c6237de32a19680caaa3ebc2845",
  "file_path": "tensorflow/core/kernels/image/crop_and_resize_op.cc",
  "func_name": "operator()",
  "func_before": "bool operator()(const OpKernelContext* context,\n                  typename TTypes<T, 4>::ConstTensor image,\n                  typename TTypes<float, 2>::ConstTensor boxes,\n                  typename TTypes<int32, 1>::ConstTensor box_index,\n                  const string& method_name, float extrapolation_value,\n                  typename TTypes<float, 4>::Tensor crops) {\n    const int batch_size = image.dimension(0);\n    const int image_height = image.dimension(1);\n    const int image_width = image.dimension(2);\n\n    const int num_boxes = crops.dimension(0);\n    const int crop_height = crops.dimension(1);\n    const int crop_width = crops.dimension(2);\n    const int depth = crops.dimension(3);\n\n    // Sharding across boxes.\n    auto CropAndResizePerBox = [&](int start_box, int limit_box) {\n      for (int b = start_box; b < limit_box; ++b) {\n        const float y1 = boxes(b, 0);\n        const float x1 = boxes(b, 1);\n        const float y2 = boxes(b, 2);\n        const float x2 = boxes(b, 3);\n\n        const int32 b_in = box_index(b);\n        if (!FastBoundsCheck(b_in, batch_size)) {\n          continue;\n        }\n\n        const float height_scale =\n            (crop_height > 1)\n                ? (y2 - y1) * (image_height - 1) / (crop_height - 1)\n                : 0;\n        const float width_scale =\n            (crop_width > 1) ? (x2 - x1) * (image_width - 1) / (crop_width - 1)\n                             : 0;\n\n        for (int y = 0; y < crop_height; ++y) {\n          const float in_y = (crop_height > 1)\n                                 ? y1 * (image_height - 1) + y * height_scale\n                                 : 0.5 * (y1 + y2) * (image_height - 1);\n          if (in_y < 0 || in_y > image_height - 1) {\n            for (int x = 0; x < crop_width; ++x) {\n              for (int d = 0; d < depth; ++d) {\n                crops(b, y, x, d) = extrapolation_value;\n              }\n            }\n            continue;\n          }\n          if (method_name == \"bilinear\") {\n            const int top_y_index = floorf(in_y);\n            const int bottom_y_index = ceilf(in_y);\n            const float y_lerp = in_y - top_y_index;\n\n            for (int x = 0; x < crop_width; ++x) {\n              const float in_x = (crop_width > 1)\n                                     ? x1 * (image_width - 1) + x * width_scale\n                                     : 0.5 * (x1 + x2) * (image_width - 1);\n              if (in_x < 0 || in_x > image_width - 1) {\n                for (int d = 0; d < depth; ++d) {\n                  crops(b, y, x, d) = extrapolation_value;\n                }\n                continue;\n              }\n              const int left_x_index = floorf(in_x);\n              const int right_x_index = ceilf(in_x);\n              const float x_lerp = in_x - left_x_index;\n\n              for (int d = 0; d < depth; ++d) {\n                const float top_left(static_cast<float>(\n                    image(b_in, top_y_index, left_x_index, d)));\n                const float top_right(static_cast<float>(\n                    image(b_in, top_y_index, right_x_index, d)));\n                const float bottom_left(static_cast<float>(\n                    image(b_in, bottom_y_index, left_x_index, d)));\n                const float bottom_right(static_cast<float>(\n                    image(b_in, bottom_y_index, right_x_index, d)));\n                const float top = top_left + (top_right - top_left) * x_lerp;\n                const float bottom =\n                    bottom_left + (bottom_right - bottom_left) * x_lerp;\n                crops(b, y, x, d) = top + (bottom - top) * y_lerp;\n              }\n            }\n          } else {  // method == \"nearest\"\n            for (int x = 0; x < crop_width; ++x) {\n              const float in_x = (crop_width > 1)\n                                     ? x1 * (image_width - 1) + x * width_scale\n                                     : 0.5 * (x1 + x2) * (image_width - 1);\n              if (in_x < 0 || in_x > image_width - 1) {\n                for (int d = 0; d < depth; ++d) {\n                  crops(b, y, x, d) = extrapolation_value;\n                }\n                continue;\n              }\n              const int closest_x_index = roundf(in_x);\n              const int closest_y_index = roundf(in_y);\n              for (int d = 0; d < depth; ++d) {\n                crops(b, y, x, d) = static_cast<float>(\n                    image(b_in, closest_y_index, closest_x_index, d));\n              }\n            }\n          }\n        }\n      }\n    };\n\n    // A rough estimation of the cost for each cropped box.\n    double cost_per_pixel =\n        depth * (Eigen::TensorOpCost::AddCost<float>() * 6 +\n                 Eigen::TensorOpCost::MulCost<float>() * 3 +\n                 Eigen::TensorOpCost::CastCost<T, float>() * 4) +\n        (Eigen::TensorOpCost::AddCost<float>() * 2 +\n         Eigen::TensorOpCost::AddCost<float>() * 3);\n    if (method_name == \"nearest\") {\n      cost_per_pixel = depth * Eigen::TensorOpCost::CastCost<T, float>() +\n                       Eigen::TensorOpCost::AddCost<float>() * 4 +\n                       Eigen::TensorOpCost::MulCost<float>() * 4;\n    }\n    const double cost_per_box = crop_height * crop_width * cost_per_pixel;\n\n    const DeviceBase::CpuWorkerThreads& worker_threads =\n        *(context->device()->tensorflow_cpu_worker_threads());\n    Shard(worker_threads.num_threads, worker_threads.workers, num_boxes,\n          cost_per_box, CropAndResizePerBox);\n\n    return true;\n  }",
  "abstract_func_before": "bool operator()(const OpKernelContext* VAR_0,\n                  typename TTypes<T, 4>::ConstTensor VAR_1,\n                  typename TTypes<float, 2>::ConstTensor VAR_2,\n                  typename TTypes<int32, 1>::ConstTensor VAR_3,\n                  const string& VAR_4, float VAR_5,\n                  typename TTypes<float, 4>::Tensor VAR_6) {\n    const int VAR_7 = VAR_1.dimension(0);\n    const int VAR_8 = VAR_1.dimension(1);\n    const int VAR_9 = VAR_1.dimension(2);\n\n    const int VAR_10 = VAR_6.dimension(0);\n    const int VAR_11 = VAR_6.dimension(1);\n    const int VAR_12 = VAR_6.dimension(2);\n    const int VAR_13 = VAR_6.dimension(3);\n\n    /* COMMENT_0 */\n    auto VAR_14 = [&](int VAR_15, int VAR_16) {\n      for (int VAR_17 = VAR_15; VAR_17 < VAR_16; ++VAR_17) {\n        const float VAR_18 = VAR_2(VAR_17, 0);\n        const float VAR_19 = VAR_2(VAR_17, 1);\n        const float VAR_20 = VAR_2(VAR_17, 2);\n        const float VAR_21 = VAR_2(VAR_17, 3);\n\n        const int32 VAR_22 = VAR_3(VAR_17);\n        if (!FastBoundsCheck(VAR_22, VAR_7)) {\n          continue;\n        }\n\n        const float VAR_23 =\n            (VAR_11 > 1)\n                ? (VAR_20 - VAR_18) * (VAR_8 - 1) / (VAR_11 - 1)\n                : 0;\n        const float VAR_24 =\n            (VAR_12 > 1) ? (VAR_21 - VAR_19) * (VAR_9 - 1) / (VAR_12 - 1)\n                             : 0;\n\n        for (int VAR_25 = 0; VAR_25 < VAR_11; ++VAR_25) {\n          const float VAR_26 = (VAR_11 > 1)\n                                 ? VAR_18 * (VAR_8 - 1) + VAR_25 * VAR_23\n                                 : 0.5 * (VAR_18 + VAR_20) * (VAR_8 - 1);\n          if (VAR_26 < 0 || VAR_26 > VAR_8 - 1) {\n            for (int VAR_27 = 0; VAR_27 < VAR_12; ++VAR_27) {\n              for (int VAR_28 = 0; VAR_28 < VAR_13; ++VAR_28) {\n                VAR_6(VAR_17, VAR_25, VAR_27, VAR_28) = VAR_5;\n              }\n            }\n            continue;\n          }\n          if (VAR_4 == \"bilinear\") {\n            const int VAR_29 = floorf(VAR_26);\n            const int VAR_30 = ceilf(VAR_26);\n            const float VAR_31 = VAR_26 - VAR_29;\n\n            for (int VAR_27 = 0; VAR_27 < VAR_12; ++VAR_27) {\n              const float VAR_32 = (VAR_12 > 1)\n                                     ? VAR_19 * (VAR_9 - 1) + VAR_27 * VAR_24\n                                     : 0.5 * (VAR_19 + VAR_21) * (VAR_9 - 1);\n              if (VAR_32 < 0 || VAR_32 > VAR_9 - 1) {\n                for (int VAR_28 = 0; VAR_28 < VAR_13; ++VAR_28) {\n                  VAR_6(VAR_17, VAR_25, VAR_27, VAR_28) = VAR_5;\n                }\n                continue;\n              }\n              const int VAR_33 = floorf(VAR_32);\n              const int VAR_34 = ceilf(VAR_32);\n              const float VAR_35 = VAR_32 - VAR_33;\n\n              for (int VAR_28 = 0; VAR_28 < VAR_13; ++VAR_28) {\n                const float top_left(static_cast<float>(\n                    image(b_in, top_y_index, left_x_index, d)));\n                const float top_right(static_cast<float>(\n                    image(b_in, top_y_index, right_x_index, d)));\n                const float bottom_left(static_cast<float>(\n                    image(b_in, bottom_y_index, left_x_index, d)));\n                const float bottom_right(static_cast<float>(\n                    image(b_in, bottom_y_index, right_x_index, d)));\n                const float VAR_36 = VAR_37 + (VAR_38 - VAR_37) * VAR_35;\n                const float VAR_39 =\n                    VAR_40 + (VAR_41 - VAR_40) * VAR_35;\n                VAR_6(VAR_17, VAR_25, VAR_27, d) = VAR_36 + (VAR_39 - VAR_36) * VAR_31;\n              }\n            }\n          } else {  /* COMMENT_1 */\n            for (int VAR_27 = 0; VAR_27 < VAR_12; ++VAR_27) {\n              const float VAR_32 = (VAR_12 > 1)\n                                     ? VAR_19 * (VAR_9 - 1) + VAR_27 * VAR_24\n                                     : 0.5 * (VAR_19 + VAR_21) * (VAR_9 - 1);\n              if (VAR_32 < 0 || VAR_32 > VAR_9 - 1) {\n                for (int d = 0; d < VAR_13; ++d) {\n                  VAR_6(VAR_17, VAR_25, VAR_27, d) = VAR_5;\n                }\n                continue;\n              }\n              const int VAR_42 = roundf(VAR_32);\n              const int VAR_43 = roundf(VAR_26);\n              for (int d = 0; d < VAR_13; ++d) {\n                VAR_6(VAR_17, VAR_25, VAR_27, d) = static_cast<float>(\n                    image(b_in, VAR_43, VAR_42, d));\n              }\n            }\n          }\n        }\n      }\n    };\n\n    /* COMMENT_2 */\n    double VAR_44 =\n        VAR_13 * (Eigen::TensorOpCost::VAR_45<float>() * 6 +\n                 Eigen::TensorOpCost::VAR_46<float>() * 3 +\n                 Eigen::TensorOpCost::VAR_47<T, float>() * 4) +\n        (Eigen::TensorOpCost::VAR_45<float>() * 2 +\n         Eigen::TensorOpCost::VAR_45<float>() * 3);\n    if (VAR_4 == \"nearest\") {\n      VAR_44 = VAR_13 * Eigen::TensorOpCost::VAR_47<T, float>() +\n                       Eigen::TensorOpCost::VAR_45<float>() * 4 +\n                       Eigen::TensorOpCost::VAR_46<float>() * 4;\n    }\n    const double VAR_48 = VAR_11 * VAR_12 * VAR_44;\n\n    const DeviceBase::CpuWorkerThreads& VAR_49 =\n        *(VAR_0->device()->tensorflow_cpu_worker_threads());\n    Shard(VAR_49.num_threads, VAR_49.workers, VAR_10,\n          VAR_48, VAR_14);\n\n    return true;\n  }",
  "func_graph_path_before": "tensorflow/3ade2efec2e90c6237de32a19680caaa3ebc2845/crop_and_resize_op.cc/vul/before/0.json",
  "func": "bool operator()(const OpKernelContext* context,\n                  typename TTypes<T, 4>::ConstTensor image,\n                  typename TTypes<float, 2>::ConstTensor boxes,\n                  typename TTypes<int32, 1>::ConstTensor box_index,\n                  const string& method_name, float extrapolation_value,\n                  typename TTypes<float, 4>::Tensor crops) {\n    const int batch_size = image.dimension(0);\n    const int image_height = image.dimension(1);\n    const int image_width = image.dimension(2);\n\n    const int num_boxes = crops.dimension(0);\n    const int crop_height = crops.dimension(1);\n    const int crop_width = crops.dimension(2);\n    const int depth = crops.dimension(3);\n\n    // Sharding across boxes.\n    auto CropAndResizePerBox = [&](int start_box, int limit_box) {\n      for (int b = start_box; b < limit_box; ++b) {\n        const float y1 = boxes(b, 0);\n        const float x1 = boxes(b, 1);\n        const float y2 = boxes(b, 2);\n        const float x2 = boxes(b, 3);\n\n        const int32 b_in = box_index(b);\n        if (!FastBoundsCheck(b_in, batch_size)) {\n          continue;\n        }\n\n        const float height_scale =\n            (crop_height > 1)\n                ? (y2 - y1) * (image_height - 1) / (crop_height - 1)\n                : 0;\n        const float width_scale =\n            (crop_width > 1) ? (x2 - x1) * (image_width - 1) / (crop_width - 1)\n                             : 0;\n\n        for (int y = 0; y < crop_height; ++y) {\n          const float in_y = (crop_height > 1)\n                                 ? y1 * (image_height - 1) + y * height_scale\n                                 : 0.5 * (y1 + y2) * (image_height - 1);\n          if (in_y < 0 || in_y > image_height - 1) {\n            for (int x = 0; x < crop_width; ++x) {\n              for (int d = 0; d < depth; ++d) {\n                crops(b, y, x, d) = extrapolation_value;\n              }\n            }\n            continue;\n          }\n          if (method_name == \"bilinear\") {\n\n            const int top_y_index = floorf(in_y);\n            const int bottom_y_index = ceilf(in_y);\n            const float y_lerp = in_y - top_y_index;\n\n            for (int x = 0; x < crop_width; ++x) {\n              const float in_x = (crop_width > 1)\n                                     ? x1 * (image_width - 1) + x * width_scale\n                                     : 0.5 * (x1 + x2) * (image_width - 1);\n              if (in_x < 0 || in_x > image_width - 1) {\n                for (int d = 0; d < depth; ++d) {\n                  crops(b, y, x, d) = extrapolation_value;\n                }\n                continue;\n              }\n              const int left_x_index = floorf(in_x);\n              const int right_x_index = ceilf(in_x);\n              const float x_lerp = in_x - left_x_index;\n\n              for (int d = 0; d < depth; ++d) {\n                const float top_left(static_cast<float>(\n                    image(b_in, top_y_index, left_x_index, d)));\n                const float top_right(static_cast<float>(\n                    image(b_in, top_y_index, right_x_index, d)));\n                const float bottom_left(static_cast<float>(\n                    image(b_in, bottom_y_index, left_x_index, d)));\n                const float bottom_right(static_cast<float>(\n                    image(b_in, bottom_y_index, right_x_index, d)));\n                const float top = top_left + (top_right - top_left) * x_lerp;\n                const float bottom =\n                    bottom_left + (bottom_right - bottom_left) * x_lerp;\n                crops(b, y, x, d) = top + (bottom - top) * y_lerp;\n              }\n            }\n          } else {  // method == \"nearest\"\n            for (int x = 0; x < crop_width; ++x) {\n              const float in_x = (crop_width > 1)\n                                     ? x1 * (image_width - 1) + x * width_scale\n                                     : 0.5 * (x1 + x2) * (image_width - 1);\n              if (in_x < 0 || in_x > image_width - 1) {\n                for (int d = 0; d < depth; ++d) {\n                  crops(b, y, x, d) = extrapolation_value;\n                }\n                continue;\n              }\n              const int closest_x_index = roundf(in_x);\n              const int closest_y_index = roundf(in_y);\n              for (int d = 0; d < depth; ++d) {\n                crops(b, y, x, d) = static_cast<float>(\n                    image(b_in, closest_y_index, closest_x_index, d));\n              }\n            }\n          }\n        }\n      }\n    };\n\n    // A rough estimation of the cost for each cropped box.\n    double cost_per_pixel =\n        depth * (Eigen::TensorOpCost::AddCost<float>() * 6 +\n                 Eigen::TensorOpCost::MulCost<float>() * 3 +\n                 Eigen::TensorOpCost::CastCost<T, float>() * 4) +\n        (Eigen::TensorOpCost::AddCost<float>() * 2 +\n         Eigen::TensorOpCost::AddCost<float>() * 3);\n    if (method_name == \"nearest\") {\n      cost_per_pixel = depth * Eigen::TensorOpCost::CastCost<T, float>() +\n                       Eigen::TensorOpCost::AddCost<float>() * 4 +\n                       Eigen::TensorOpCost::MulCost<float>() * 4;\n    }\n    const double cost_per_box = crop_height * crop_width * cost_per_pixel;\n\n    const DeviceBase::CpuWorkerThreads& worker_threads =\n        *(context->device()->tensorflow_cpu_worker_threads());\n    Shard(worker_threads.num_threads, worker_threads.workers, num_boxes,\n          cost_per_box, CropAndResizePerBox);\n\n    return true;\n  }",
  "abstract_func": "bool operator()(const OpKernelContext* VAR_0,\n                  typename TTypes<T, 4>::ConstTensor VAR_1,\n                  typename TTypes<float, 2>::ConstTensor VAR_2,\n                  typename TTypes<int32, 1>::ConstTensor VAR_3,\n                  const string& VAR_4, float VAR_5,\n                  typename TTypes<float, 4>::Tensor VAR_6) {\n    const int VAR_7 = VAR_1.dimension(0);\n    const int VAR_8 = VAR_1.dimension(1);\n    const int VAR_9 = VAR_1.dimension(2);\n\n    const int VAR_10 = VAR_6.dimension(0);\n    const int VAR_11 = VAR_6.dimension(1);\n    const int VAR_12 = VAR_6.dimension(2);\n    const int VAR_13 = VAR_6.dimension(3);\n\n    /* COMMENT_0 */\n    auto VAR_14 = [&](int VAR_15, int VAR_16) {\n      for (int VAR_17 = VAR_15; VAR_17 < VAR_16; ++VAR_17) {\n        const float VAR_18 = VAR_2(VAR_17, 0);\n        const float VAR_19 = VAR_2(VAR_17, 1);\n        const float VAR_20 = VAR_2(VAR_17, 2);\n        const float VAR_21 = VAR_2(VAR_17, 3);\n\n        const int32 VAR_22 = VAR_3(VAR_17);\n        if (!FastBoundsCheck(VAR_22, VAR_7)) {\n          continue;\n        }\n\n        const float VAR_23 =\n            (VAR_11 > 1)\n                ? (VAR_20 - VAR_18) * (VAR_8 - 1) / (VAR_11 - 1)\n                : 0;\n        const float VAR_24 =\n            (VAR_12 > 1) ? (VAR_21 - VAR_19) * (VAR_9 - 1) / (VAR_12 - 1)\n                             : 0;\n\n        for (int VAR_25 = 0; VAR_25 < VAR_11; ++VAR_25) {\n          const float VAR_26 = (VAR_11 > 1)\n                                 ? VAR_18 * (VAR_8 - 1) + VAR_25 * VAR_23\n                                 : 0.5 * (VAR_18 + VAR_20) * (VAR_8 - 1);\n          if (VAR_26 < 0 || VAR_26 > VAR_8 - 1) {\n            for (int VAR_27 = 0; VAR_27 < VAR_12; ++VAR_27) {\n              for (int VAR_28 = 0; VAR_28 < VAR_13; ++VAR_28) {\n                VAR_6(VAR_17, VAR_25, VAR_27, VAR_28) = VAR_5;\n              }\n            }\n            continue;\n          }\n          if (VAR_4 == \"bilinear\") {\n\n            const int VAR_29 = floorf(VAR_26);\n            const int VAR_30 = ceilf(VAR_26);\n            const float VAR_31 = VAR_26 - VAR_29;\n\n            for (int VAR_27 = 0; VAR_27 < VAR_12; ++VAR_27) {\n              const float VAR_32 = (VAR_12 > 1)\n                                     ? VAR_19 * (VAR_9 - 1) + VAR_27 * VAR_24\n                                     : 0.5 * (VAR_19 + VAR_21) * (VAR_9 - 1);\n              if (VAR_32 < 0 || VAR_32 > VAR_9 - 1) {\n                for (int VAR_28 = 0; VAR_28 < VAR_13; ++VAR_28) {\n                  VAR_6(VAR_17, VAR_25, VAR_27, VAR_28) = VAR_5;\n                }\n                continue;\n              }\n              const int VAR_33 = floorf(VAR_32);\n              const int VAR_34 = ceilf(VAR_32);\n              const float VAR_35 = VAR_32 - VAR_33;\n\n              for (int VAR_28 = 0; VAR_28 < VAR_13; ++VAR_28) {\n                const float top_left(static_cast<float>(\n                    image(b_in, top_y_index, left_x_index, d)));\n                const float top_right(static_cast<float>(\n                    image(b_in, top_y_index, right_x_index, d)));\n                const float bottom_left(static_cast<float>(\n                    image(b_in, bottom_y_index, left_x_index, d)));\n                const float bottom_right(static_cast<float>(\n                    image(b_in, bottom_y_index, right_x_index, d)));\n                const float VAR_36 = VAR_37 + (VAR_38 - VAR_37) * VAR_35;\n                const float VAR_39 =\n                    VAR_40 + (VAR_41 - VAR_40) * VAR_35;\n                VAR_6(VAR_17, VAR_25, VAR_27, d) = VAR_36 + (VAR_39 - VAR_36) * VAR_31;\n              }\n            }\n          } else {  /* COMMENT_1 */\n            for (int VAR_27 = 0; VAR_27 < VAR_12; ++VAR_27) {\n              const float VAR_32 = (VAR_12 > 1)\n                                     ? VAR_19 * (VAR_9 - 1) + VAR_27 * VAR_24\n                                     : 0.5 * (VAR_19 + VAR_21) * (VAR_9 - 1);\n              if (VAR_32 < 0 || VAR_32 > VAR_9 - 1) {\n                for (int d = 0; d < VAR_13; ++d) {\n                  VAR_6(VAR_17, VAR_25, VAR_27, d) = VAR_5;\n                }\n                continue;\n              }\n              const int VAR_42 = roundf(VAR_32);\n              const int VAR_43 = roundf(VAR_26);\n              for (int d = 0; d < VAR_13; ++d) {\n                VAR_6(VAR_17, VAR_25, VAR_27, d) = static_cast<float>(\n                    image(b_in, VAR_43, VAR_42, d));\n              }\n            }\n          }\n        }\n      }\n    };\n\n    /* COMMENT_2 */\n    double VAR_44 =\n        VAR_13 * (Eigen::TensorOpCost::VAR_45<float>() * 6 +\n                 Eigen::TensorOpCost::VAR_46<float>() * 3 +\n                 Eigen::TensorOpCost::VAR_47<T, float>() * 4) +\n        (Eigen::TensorOpCost::VAR_45<float>() * 2 +\n         Eigen::TensorOpCost::VAR_45<float>() * 3);\n    if (VAR_4 == \"nearest\") {\n      VAR_44 = VAR_13 * Eigen::TensorOpCost::VAR_47<T, float>() +\n                       Eigen::TensorOpCost::VAR_45<float>() * 4 +\n                       Eigen::TensorOpCost::VAR_46<float>() * 4;\n    }\n    const double VAR_48 = VAR_11 * VAR_12 * VAR_44;\n\n    const DeviceBase::CpuWorkerThreads& VAR_49 =\n        *(VAR_0->device()->tensorflow_cpu_worker_threads());\n    Shard(VAR_49.num_threads, VAR_49.workers, VAR_10,\n          VAR_48, VAR_14);\n\n    return true;\n  }",
  "func_graph_path": "tensorflow/3ade2efec2e90c6237de32a19680caaa3ebc2845/crop_and_resize_op.cc/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -47,6 +47,7 @@\n             continue;\n           }\n           if (method_name == \"bilinear\") {\n+\n             const int top_y_index = floorf(in_y);\n             const int bottom_y_index = ceilf(in_y);\n             const float y_lerp = in_y - top_y_index;",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/tensorflow/tensorflow/pull/42143",
  "description": {
    "pr_info": {
      "title": "Fix segmentation fault in tf.image.crop_and_resize when boxes is inf or nan",
      "number": 42143
    },
    "comment": [
      "This fix tries to address the issue raised in #42129 where segmentation fault\r\nhappened in tf.image.crop_and_resize when boxes is inf or nan.\r\n\r\nThis fix adds the check to make sure boxes is not inf or nan (isfinite)\r\n\r\nThis fix fixes #42129.\r\n\r\nSigned-off-by: Yong Tang <yong.tang.github@outlook.com>",
      "@yongtang Can you please resolve conflicts? Thanks!",
      "@yongtang, Any update on this PR? Please. Thanks!",
      "Due to the way GPU/CPU pipeline works in the kernel, it looks like to do a nan check on GPU is not exactly straightforward. That was causing the GPU test failure.\r\n\r\nLet me take another look and see how to resolve this issue.",
      "@yongtang  Can you please check @sanjoy's comments and keep us posted ? Thanks!",
      "The test added by the PR does not fail in CUDA if I remove the C++ check that causes the segfaults",
      "I think I got this fully fixed internally. Running a full suite of tests and sending for review tomorrow."
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "\n\nThe patch addresses a bug causing a segmentation fault when invalid inputs (inf or nan) are provided. While it improves robustness, there's no indication that the inputs are attacker-controlled, so it's not classified as a security fix.\n\n**Final Output:**\nAnalysis: The patch adds a check to prevent segmentation faults when boxes contain inf or nan values, addressing a crash issue. Without evidence of attacker-controlled inputs, it's a bug fix, not a security vulnerability.\nFinal Classification: Defect Remediation & Feature Upgrades\nConfidence Score: 0.8"
}