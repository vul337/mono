{
  "cve_id": "CVE-2018-19107",
  "cwe_ids": [
    "CWE-835",
    "CWE-190",
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "Exiv2/exiv2",
  "commit_msg": "PSD: enforce Length of image resource section < file size",
  "commit_hash": "e4b3bdd712566ffefeec9809043bdfb843e42f53",
  "git_url": "https://github.com/Exiv2/exiv2/commit/e4b3bdd712566ffefeec9809043bdfb843e42f53",
  "file_path": "src/psdimage.cpp",
  "func_name": "PsdImage::readMetadata",
  "func_before": "void PsdImage::readMetadata()\n    {\n#ifdef DEBUG\n        std::cerr << \"Exiv2::PsdImage::readMetadata: Reading Photoshop file \" << io_->path() << \"\\n\";\n#endif\n        if (io_->open() != 0)\n        {\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        }\n        IoCloser closer(*io_);\n        // Ensure that this is the correct image type\n        if (!isPsdType(*io_, false))\n        {\n            if (io_->error() || io_->eof()) throw Error(kerFailedToReadImageData);\n            throw Error(kerNotAnImage, \"Photoshop\");\n        }\n        clearMetadata();\n\n        /*\n          The Photoshop header goes as follows -- all numbers are in big-endian byte order:\n\n          offset  length   name       description\n          ======  =======  =========  =========\n           0      4 bytes  signature  always '8BPS'\n           4      2 bytes  version    always equal to 1\n           6      6 bytes  reserved   must be zero\n          12      2 bytes  channels   number of channels in the image, including alpha channels (1 to 24)\n          14      4 bytes  rows       the height of the image in pixels\n          18      4 bytes  columns    the width of the image in pixels\n          22      2 bytes  depth      the number of bits per channel\n          24      2 bytes  mode       the color mode of the file; Supported values are: Bitmap=0; Grayscale=1; Indexed=2; RGB=3; CMYK=4; Multichannel=7; Duotone=8; Lab=9\n        */\n        byte buf[26];\n        if (io_->read(buf, 26) != 26)\n        {\n            throw Error(kerNotAnImage, \"Photoshop\");\n        }\n        pixelWidth_ = getLong(buf + 18, bigEndian);\n        pixelHeight_ = getLong(buf + 14, bigEndian);\n\n        // immediately following the image header is the color mode data section,\n        // the first four bytes of which specify the byte size of the whole section\n        if (io_->read(buf, 4) != 4)\n        {\n            throw Error(kerNotAnImage, \"Photoshop\");\n        }\n\n        // skip it\n        uint32_t colorDataLength = getULong(buf, bigEndian);\n        if (io_->seek(colorDataLength, BasicIo::cur))\n        {\n            throw Error(kerNotAnImage, \"Photoshop\");\n        }\n\n        // after the color data section, comes a list of resource blocks, preceded by the total byte size\n        if (io_->read(buf, 4) != 4)\n        {\n            throw Error(kerNotAnImage, \"Photoshop\");\n        }\n        uint32_t resourcesLength = getULong(buf, bigEndian);\n        while (resourcesLength > 0)\n        {\n            if (io_->read(buf, 8) != 8)\n            {\n                throw Error(kerNotAnImage, \"Photoshop\");\n            }\n\n            if (!Photoshop::isIrb(buf, 4))\n            {\n                break; // bad resource type\n            }\n            uint16_t resourceId = getUShort(buf + 4, bigEndian);\n            uint32_t resourceNameLength = buf[6] & ~1;\n\n            // skip the resource name, plus any padding\n            io_->seek(resourceNameLength, BasicIo::cur);\n\n            // read resource size\n            if (io_->read(buf, 4) != 4)\n            {\n                throw Error(kerNotAnImage, \"Photoshop\");\n            }\n            uint32_t resourceSize = getULong(buf, bigEndian);\n            uint32_t curOffset = io_->tell();\n\n#ifdef DEBUG\n        std::cerr << std::hex << \"resourceId: \" << resourceId << std::dec << \" length: \" << resourceSize << std::hex << \"\\n\";\n#endif\n\n            readResourceBlock(resourceId, resourceSize);\n            resourceSize = (resourceSize + 1) & ~1;        // pad to even\n            io_->seek(curOffset + resourceSize, BasicIo::beg);\n            resourcesLength -= Safe::add(Safe::add(static_cast<uint32_t>(12), resourceNameLength),\n                                         resourceSize);\n        }\n\n    }",
  "abstract_func_before": "void PsdImage::readMetadata()\n    {\n#ifdef VAR_0\n        std::cerr << \"Exiv2::PsdImage::readMetadata: Reading Photoshop file \" << VAR_1->path() << \"\\n\";\n#endif\n        if (VAR_1->open() != 0)\n        {\n            throw Error(VAR_2, VAR_1->path(), strError());\n        }\n        IoCloser VAR_3(*VAR_1);\n        /* COMMENT_0 */\n        if (!isPsdType(*VAR_1, false))\n        {\n            if (VAR_1->error() || VAR_1->eof()) throw Error(VAR_4);\n            throw Error(VAR_5, \"Photoshop\");\n        }\n        clearMetadata();\n\n        /* COMMENT_1 */\n                                                                                           \n\n                                                 \n                                               \n                                                   \n                                                       \n                                                  \n                                                                                                         \n                                                                       \n                                                                      \n                                                                    \n                                                                                                                                                                         \n          \n        byte VAR_6[26];\n        if (VAR_1->read(VAR_6, 26) != 26)\n        {\n            throw Error(VAR_5, \"Photoshop\");\n        }\n        VAR_7 = getLong(VAR_6 + 18, VAR_8);\n        VAR_9 = getLong(VAR_6 + 14, VAR_8);\n\n        /* COMMENT_15 */\n        /* COMMENT_16 */\n        if (VAR_1->read(VAR_6, 4) != 4)\n        {\n            throw Error(VAR_5, \"Photoshop\");\n        }\n\n        /* COMMENT_17 */\n        uint32_t VAR_10 = getULong(VAR_6, VAR_8);\n        if (VAR_1->seek(VAR_10, BasicIo::cur))\n        {\n            throw Error(VAR_5, \"Photoshop\");\n        }\n\n        /* COMMENT_18 */\n        if (VAR_1->read(VAR_6, 4) != 4)\n        {\n            throw Error(VAR_5, \"Photoshop\");\n        }\n        uint32_t VAR_11 = getULong(VAR_6, VAR_8);\n        while (VAR_11 > 0)\n        {\n            if (VAR_1->read(VAR_6, 8) != 8)\n            {\n                throw Error(VAR_5, \"Photoshop\");\n            }\n\n            if (!Photoshop::isIrb(VAR_6, 4))\n            {\n                break; /* COMMENT_19 */\n            }\n            uint16_t VAR_12 = getUShort(VAR_6 + 4, VAR_8);\n            uint32_t VAR_13 = VAR_6[6] & ~1;\n\n            /* COMMENT_20 */\n            VAR_1->seek(VAR_13, BasicIo::cur);\n\n            /* COMMENT_21 */\n            if (VAR_1->read(VAR_6, 4) != 4)\n            {\n                throw Error(VAR_5, \"Photoshop\");\n            }\n            uint32_t VAR_14 = getULong(VAR_6, VAR_8);\n            uint32_t VAR_15 = VAR_1->tell();\n\n#ifdef VAR_0\n        std::cerr << std::hex << \"resourceId: \" << VAR_12 << std::dec << \" length: \" << VAR_14 << std::hex << \"\\n\";\n#endif\n\n            readResourceBlock(VAR_12, VAR_14);\n            VAR_14 = (VAR_14 + 1) & ~1;        /* COMMENT_22 */\n            VAR_1->seek(VAR_15 + VAR_14, BasicIo::beg);\n            VAR_11 -= Safe::add(Safe::add(VAR_16<uint32_t>(12), VAR_13),\n                                         VAR_14);\n        }\n\n    }",
  "func_graph_path_before": "Exiv2/exiv2/e4b3bdd712566ffefeec9809043bdfb843e42f53/psdimage.cpp/vul/before/0.json",
  "func": "void PsdImage::readMetadata()\n    {\n#ifdef DEBUG\n        std::cerr << \"Exiv2::PsdImage::readMetadata: Reading Photoshop file \" << io_->path() << \"\\n\";\n#endif\n        if (io_->open() != 0)\n        {\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        }\n        IoCloser closer(*io_);\n        // Ensure that this is the correct image type\n        if (!isPsdType(*io_, false))\n        {\n            if (io_->error() || io_->eof()) throw Error(kerFailedToReadImageData);\n            throw Error(kerNotAnImage, \"Photoshop\");\n        }\n        clearMetadata();\n\n        /*\n          The Photoshop header goes as follows -- all numbers are in big-endian byte order:\n\n          offset  length   name       description\n          ======  =======  =========  =========\n           0      4 bytes  signature  always '8BPS'\n           4      2 bytes  version    always equal to 1\n           6      6 bytes  reserved   must be zero\n          12      2 bytes  channels   number of channels in the image, including alpha channels (1 to 24)\n          14      4 bytes  rows       the height of the image in pixels\n          18      4 bytes  columns    the width of the image in pixels\n          22      2 bytes  depth      the number of bits per channel\n          24      2 bytes  mode       the color mode of the file; Supported values are: Bitmap=0; Grayscale=1; Indexed=2; RGB=3; CMYK=4; Multichannel=7; Duotone=8; Lab=9\n        */\n        byte buf[26];\n        if (io_->read(buf, 26) != 26)\n        {\n            throw Error(kerNotAnImage, \"Photoshop\");\n        }\n        pixelWidth_ = getLong(buf + 18, bigEndian);\n        pixelHeight_ = getLong(buf + 14, bigEndian);\n\n        // immediately following the image header is the color mode data section,\n        // the first four bytes of which specify the byte size of the whole section\n        if (io_->read(buf, 4) != 4)\n        {\n            throw Error(kerNotAnImage, \"Photoshop\");\n        }\n\n        // skip it\n        uint32_t colorDataLength = getULong(buf, bigEndian);\n        if (io_->seek(colorDataLength, BasicIo::cur))\n        {\n            throw Error(kerNotAnImage, \"Photoshop\");\n        }\n\n        // after the color data section, comes a list of resource blocks, preceded by the total byte size\n        if (io_->read(buf, 4) != 4)\n        {\n            throw Error(kerNotAnImage, \"Photoshop\");\n        }\n        uint32_t resourcesLength = getULong(buf, bigEndian);\n        enforce(resourcesLength < io_->size(), Exiv2::kerCorruptedMetadata);\n\n        while (resourcesLength > 0)\n        {\n            if (io_->read(buf, 8) != 8)\n            {\n                throw Error(kerNotAnImage, \"Photoshop\");\n            }\n\n            if (!Photoshop::isIrb(buf, 4))\n            {\n                break; // bad resource type\n            }\n            uint16_t resourceId = getUShort(buf + 4, bigEndian);\n            uint32_t resourceNameLength = buf[6] & ~1;\n\n            // skip the resource name, plus any padding\n            io_->seek(resourceNameLength, BasicIo::cur);\n\n            // read resource size\n            if (io_->read(buf, 4) != 4)\n            {\n                throw Error(kerNotAnImage, \"Photoshop\");\n            }\n            uint32_t resourceSize = getULong(buf, bigEndian);\n            uint32_t curOffset = io_->tell();\n\n#ifdef DEBUG\n        std::cerr << std::hex << \"resourceId: \" << resourceId << std::dec << \" length: \" << resourceSize << std::hex << \"\\n\";\n#endif\n\n            readResourceBlock(resourceId, resourceSize);\n            resourceSize = (resourceSize + 1) & ~1;        // pad to even\n            io_->seek(curOffset + resourceSize, BasicIo::beg);\n            resourcesLength -= Safe::add(Safe::add(static_cast<uint32_t>(12), resourceNameLength),\n                                         resourceSize);\n        }\n\n    }",
  "abstract_func": "void PsdImage::readMetadata()\n    {\n#ifdef VAR_0\n        std::cerr << \"Exiv2::PsdImage::readMetadata: Reading Photoshop file \" << VAR_1->path() << \"\\n\";\n#endif\n        if (VAR_1->open() != 0)\n        {\n            throw Error(VAR_2, VAR_1->path(), strError());\n        }\n        IoCloser VAR_3(*VAR_1);\n        /* COMMENT_0 */\n        if (!isPsdType(*VAR_1, false))\n        {\n            if (VAR_1->error() || VAR_1->eof()) throw Error(VAR_4);\n            throw Error(VAR_5, \"Photoshop\");\n        }\n        clearMetadata();\n\n        /* COMMENT_1 */\n                                                                                           \n\n                                                 \n                                               \n                                                   \n                                                       \n                                                  \n                                                                                                         \n                                                                       \n                                                                      \n                                                                    \n                                                                                                                                                                         \n          \n        byte VAR_6[26];\n        if (VAR_1->read(VAR_6, 26) != 26)\n        {\n            throw Error(VAR_5, \"Photoshop\");\n        }\n        VAR_7 = getLong(VAR_6 + 18, VAR_8);\n        VAR_9 = getLong(VAR_6 + 14, VAR_8);\n\n        /* COMMENT_15 */\n        /* COMMENT_16 */\n        if (VAR_1->read(VAR_6, 4) != 4)\n        {\n            throw Error(VAR_5, \"Photoshop\");\n        }\n\n        /* COMMENT_17 */\n        uint32_t VAR_10 = getULong(VAR_6, VAR_8);\n        if (VAR_1->seek(VAR_10, BasicIo::cur))\n        {\n            throw Error(VAR_5, \"Photoshop\");\n        }\n\n        /* COMMENT_18 */\n        if (VAR_1->read(VAR_6, 4) != 4)\n        {\n            throw Error(VAR_5, \"Photoshop\");\n        }\n        uint32_t VAR_11 = getULong(VAR_6, VAR_8);\n        enforce(VAR_11 < VAR_1->size(), Exiv2::kerCorruptedMetadata);\n\n        while (VAR_11 > 0)\n        {\n            if (VAR_1->read(VAR_6, 8) != 8)\n            {\n                throw Error(VAR_5, \"Photoshop\");\n            }\n\n            if (!Photoshop::isIrb(VAR_6, 4))\n            {\n                break; /* COMMENT_19 */\n            }\n            uint16_t VAR_12 = getUShort(VAR_6 + 4, VAR_8);\n            uint32_t VAR_13 = VAR_6[6] & ~1;\n\n            /* COMMENT_20 */\n            VAR_1->seek(VAR_13, BasicIo::cur);\n\n            /* COMMENT_21 */\n            if (VAR_1->read(VAR_6, 4) != 4)\n            {\n                throw Error(VAR_5, \"Photoshop\");\n            }\n            uint32_t VAR_14 = getULong(VAR_6, VAR_8);\n            uint32_t VAR_15 = VAR_1->tell();\n\n#ifdef VAR_0\n        std::cerr << std::hex << \"resourceId: \" << VAR_12 << std::dec << \" length: \" << VAR_14 << std::hex << \"\\n\";\n#endif\n\n            readResourceBlock(VAR_12, VAR_14);\n            VAR_14 = (VAR_14 + 1) & ~1;        /* COMMENT_22 */\n            VAR_1->seek(VAR_15 + VAR_14, BasicIo::beg);\n            VAR_11 -= Safe::add(Safe::add(VAR_16<uint32_t>(12), VAR_13),\n                                         VAR_14);\n        }\n\n    }",
  "func_graph_path": "Exiv2/exiv2/e4b3bdd712566ffefeec9809043bdfb843e42f53/psdimage.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -58,6 +58,8 @@\n             throw Error(kerNotAnImage, \"Photoshop\");\n         }\n         uint32_t resourcesLength = getULong(buf, bigEndian);\n+        enforce(resourcesLength < io_->size(), Exiv2::kerCorruptedMetadata);\n+\n         while (resourcesLength > 0)\n         {\n             if (io_->read(buf, 8) != 8)",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "        enforce(resourcesLength < io_->size(), Exiv2::kerCorruptedMetadata);",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/Exiv2/exiv2/pull/518",
  "description": {
    "pr_info": {
      "title": "Fix infinite loop in PsdImage::readMetadata ",
      "number": 518
    },
    "comment": [
      "As described in #426 , a fuzzed POC was causing an infinite loop in `PsdImage::readMetadata`. The reason is that an addition operator over the `resourcesLength` variable was causing an overflow. By the addition of the `Safe::add` operator we can detect such situations.\r\n\r\nA regression test has been added. ",
      "This change mades good use of Dan's _safe_ arithmetic.  I'm not sure what a _resourceLength_ is, however presumably if it's bigger that the file size, the file smells.  So, I approve of the _safe_ code and ask you to investigate resourceLength/file-size puzzle.",
      "# [Codecov](https://codecov.io/gh/Exiv2/exiv2/pull/518?src=pr&el=h1) Report\n> Merging [#518](https://codecov.io/gh/Exiv2/exiv2/pull/518?src=pr&el=desc) into [master](https://codecov.io/gh/Exiv2/exiv2/commit/933ce589a6e0a5a236eac7fbb07867fcaddb45e2?src=pr&el=desc) will **not change** coverage.\n> The diff coverage is `100%`.\n\n[![Impacted file tree graph](https://codecov.io/gh/Exiv2/exiv2/pull/518/graphs/tree.svg?width=650&token=O9G7Iswx26&height=150&src=pr)](https://codecov.io/gh/Exiv2/exiv2/pull/518?src=pr&el=tree)\n\n```diff\n@@           Coverage Diff           @@\n##           master     #518   +/-   ##\n=======================================\n  Coverage   63.59%   63.59%           \n=======================================\n  Files         154      154           \n  Lines       20560    20560           \n=======================================\n  Hits        13075    13075           \n  Misses       7485     7485\n```\n\n\n| [Impacted Files](https://codecov.io/gh/Exiv2/exiv2/pull/518?src=pr&el=tree) | Coverage Δ | |\n|---|---|---|\n| [src/psdimage.cpp](https://codecov.io/gh/Exiv2/exiv2/pull/518/diff?src=pr&el=tree#diff-c3JjL3BzZGltYWdlLmNwcA==) | `83.01% <100%> (ø)` | :arrow_up: |\n\n------\n\n[Continue to review full report at Codecov](https://codecov.io/gh/Exiv2/exiv2/pull/518?src=pr&el=continue).\n> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)\n> `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`\n> Powered by [Codecov](https://codecov.io/gh/Exiv2/exiv2/pull/518?src=pr&el=footer). Last update [933ce58...e4b3bdd](https://codecov.io/gh/Exiv2/exiv2/pull/518?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).\n",
      "Can we know the file size at this point? I thought that we were reading it chunk by chunk, and therefore we did not know its total size. ",
      "Great, I have added also that check that makes total sense and adapted the test code. ",
      "Note that these changes are also fixing the bug described in #427. "
    ]
  },
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 0.9",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "\n\n**Final Output:**\nAnalysis: The patch adds a validation check to ensure that the length of the image resource section does not exceed the file size, preventing potential buffer overflow issues that could be exploited.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 0.9"
}