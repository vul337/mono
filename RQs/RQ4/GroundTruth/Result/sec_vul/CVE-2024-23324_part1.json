{
  "cve_id": "CVE-2024-23324",
  "cwe_ids": [
    "CWE-20"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N",
  "cvss_is_v3": true,
  "repo_name": "envoyproxy/envoy",
  "commit_msg": "Proxy protocol: sanitise non utf8 chars in TLVs\n\nFix [CVE-2024-23324](https://github.com/envoyproxy/envoy/security/advisories/GHSA-gq3v-vvhj-96j6)\n\nSigned-off-by: Kateryna Nezdolii <nezdolik@spotify.com>\nSigned-off-by: Ryan Northey <ryan@synca.io>",
  "commit_hash": "29989f6cc8bfd8cd2ffcb7c42711eb02c7a5168a",
  "git_url": "https://github.com/envoyproxy/envoy/commit/29989f6cc8bfd8cd2ffcb7c42711eb02c7a5168a",
  "file_path": "source/extensions/filters/listener/proxy_protocol/proxy_protocol.cc",
  "func_name": "Filter::parseTlvs",
  "func_before": "bool Filter::parseTlvs(const uint8_t* buf, size_t len) {\n  size_t idx{0};\n  while (idx < len) {\n    const uint8_t tlv_type = buf[idx];\n    idx++;\n\n    if ((idx + 1) >= len) {\n      ENVOY_LOG(debug,\n                fmt::format(\"failed to read proxy protocol extension. No bytes for TLV length. \"\n                            \"Extension length is {}, current index is {}, current type is {}.\",\n                            len, idx, tlv_type));\n      return false;\n    }\n\n    const uint8_t tlv_length_upper = buf[idx];\n    const uint8_t tlv_length_lower = buf[idx + 1];\n    const size_t tlv_value_length = (tlv_length_upper << 8) + tlv_length_lower;\n    idx += 2;\n\n    // Get the value.\n    if ((idx + tlv_value_length - 1) >= len) {\n      ENVOY_LOG(\n          debug,\n          fmt::format(\"failed to read proxy protocol extension. No bytes for TLV value. \"\n                      \"Extension length is {}, current index is {}, current type is {}, current \"\n                      \"value length is {}.\",\n                      len, idx, tlv_type, tlv_length_upper));\n      return false;\n    }\n\n    // Only save to dynamic metadata if this type of TLV is needed.\n    absl::string_view tlv_value(reinterpret_cast<char const*>(buf + idx), tlv_value_length);\n    auto key_value_pair = config_->isTlvTypeNeeded(tlv_type);\n    if (nullptr != key_value_pair) {\n      ProtobufWkt::Value metadata_value;\n      metadata_value.set_string_value(tlv_value.data(), tlv_value.size());\n\n      std::string metadata_key = key_value_pair->metadata_namespace().empty()\n                                     ? \"envoy.filters.listener.proxy_protocol\"\n                                     : key_value_pair->metadata_namespace();\n\n      ProtobufWkt::Struct metadata(\n          (*cb_->dynamicMetadata().mutable_filter_metadata())[metadata_key]);\n      metadata.mutable_fields()->insert({key_value_pair->key(), metadata_value});\n      cb_->setDynamicMetadata(metadata_key, metadata);\n    } else {\n      ENVOY_LOG(trace,\n                \"proxy_protocol: Skip TLV of type {} since it's not needed for dynamic metadata\",\n                tlv_type);\n    }\n\n    // Save TLVs to the filter state.\n    if (config_->isPassThroughTlvTypeNeeded(tlv_type)) {\n      ENVOY_LOG(trace, \"proxy_protocol: Storing parsed TLV of type {} to filter state.\", tlv_type);\n      parsed_tlvs_.push_back({tlv_type, {tlv_value.begin(), tlv_value.end()}});\n    }\n\n    idx += tlv_value_length;\n    ASSERT(idx <= len);\n  }\n  return true;\n}",
  "abstract_func_before": "bool Filter::parseTlvs(const uint8_t* VAR_0, size_t VAR_1) {\n  size_t VAR_2{0};\n  while (VAR_2 < VAR_1) {\n    const uint8_t VAR_3 = VAR_0[VAR_2];\n    VAR_2++;\n\n    if ((VAR_2 + 1) >= VAR_1) {\n      ENVOY_LOG(VAR_4,\n                fmt::format(\"failed to read proxy protocol extension. No bytes for TLV length. \"\n                            \"Extension length is {}, current index is {}, current type is {}.\",\n                            VAR_1, VAR_2, VAR_3));\n      return false;\n    }\n\n    const uint8_t VAR_5 = VAR_0[VAR_2];\n    const uint8_t VAR_6 = VAR_0[VAR_2 + 1];\n    const size_t VAR_7 = (VAR_5 << 8) + VAR_6;\n    VAR_2 += 2;\n\n    /* COMMENT_0 */\n    if ((VAR_2 + VAR_7 - 1) >= VAR_1) {\n      ENVOY_LOG(\n          VAR_4,\n          fmt::format(\"failed to read proxy protocol extension. No bytes for TLV value. \"\n                      \"Extension length is {}, current index is {}, current type is {}, current \"\n                      \"value length is {}.\",\n                      VAR_1, VAR_2, VAR_3, VAR_5));\n      return false;\n    }\n\n    /* COMMENT_1 */\n    absl::string_view VAR_8(VAR_9<char const*>(VAR_0 + VAR_2), VAR_7);\n    auto VAR_10 = VAR_11->isTlvTypeNeeded(VAR_3);\n    if (nullptr != VAR_10) {\n      ProtobufWkt::Value VAR_12;\n      VAR_12.set_string_value(VAR_8.data(), VAR_8.size());\n\n      std::string VAR_13 = VAR_10->metadata_namespace().empty()\n                                     ? \"envoy.filters.listener.proxy_protocol\"\n                                     : VAR_10->metadata_namespace();\n\n      ProtobufWkt::Struct VAR_14(\n          (*VAR_15->dynamicMetadata().mutable_filter_metadata())[VAR_13]);\n      VAR_14.mutable_fields()->insert({VAR_10->key(), VAR_12});\n      VAR_15->setDynamicMetadata(VAR_13, VAR_14);\n    } else {\n      ENVOY_LOG(VAR_16,\n                \"proxy_protocol: Skip TLV of type {} since it's not needed for dynamic metadata\",\n                VAR_3);\n    }\n\n    /* COMMENT_2 */\n    if (VAR_11->isPassThroughTlvTypeNeeded(VAR_3)) {\n      ENVOY_LOG(VAR_16, \"proxy_protocol: Storing parsed TLV of type {} to filter state.\", VAR_3);\n      VAR_17.push_back({VAR_3, {VAR_8.begin(), VAR_8.end()}});\n    }\n\n    VAR_2 += VAR_7;\n    ASSERT(VAR_2 <= VAR_1);\n  }\n  return true;\n}",
  "func_graph_path_before": "envoyproxy/envoy/29989f6cc8bfd8cd2ffcb7c42711eb02c7a5168a/proxy_protocol.cc/vul/before/0.json",
  "func": "bool Filter::parseTlvs(const uint8_t* buf, size_t len) {\n  size_t idx{0};\n  while (idx < len) {\n    const uint8_t tlv_type = buf[idx];\n    idx++;\n\n    if ((idx + 1) >= len) {\n      ENVOY_LOG(debug,\n                fmt::format(\"failed to read proxy protocol extension. No bytes for TLV length. \"\n                            \"Extension length is {}, current index is {}, current type is {}.\",\n                            len, idx, tlv_type));\n      return false;\n    }\n\n    const uint8_t tlv_length_upper = buf[idx];\n    const uint8_t tlv_length_lower = buf[idx + 1];\n    const size_t tlv_value_length = (tlv_length_upper << 8) + tlv_length_lower;\n    idx += 2;\n\n    // Get the value.\n    if ((idx + tlv_value_length - 1) >= len) {\n      ENVOY_LOG(\n          debug,\n          fmt::format(\"failed to read proxy protocol extension. No bytes for TLV value. \"\n                      \"Extension length is {}, current index is {}, current type is {}, current \"\n                      \"value length is {}.\",\n                      len, idx, tlv_type, tlv_length_upper));\n      return false;\n    }\n\n    // Only save to dynamic metadata if this type of TLV is needed.\n    absl::string_view tlv_value(reinterpret_cast<char const*>(buf + idx), tlv_value_length);\n    auto key_value_pair = config_->isTlvTypeNeeded(tlv_type);\n    if (nullptr != key_value_pair) {\n      ProtobufWkt::Value metadata_value;\n      // Sanitize any non utf8 characters.\n      auto sanitised_tlv_value = MessageUtil::sanitizeUtf8String(tlv_value);\n      metadata_value.set_string_value(sanitised_tlv_value.data(), sanitised_tlv_value.size());\n\n      std::string metadata_key = key_value_pair->metadata_namespace().empty()\n                                     ? \"envoy.filters.listener.proxy_protocol\"\n                                     : key_value_pair->metadata_namespace();\n\n      ProtobufWkt::Struct metadata(\n          (*cb_->dynamicMetadata().mutable_filter_metadata())[metadata_key]);\n      metadata.mutable_fields()->insert({key_value_pair->key(), metadata_value});\n      cb_->setDynamicMetadata(metadata_key, metadata);\n    } else {\n      ENVOY_LOG(trace,\n                \"proxy_protocol: Skip TLV of type {} since it's not needed for dynamic metadata\",\n                tlv_type);\n    }\n\n    // Save TLVs to the filter state.\n    if (config_->isPassThroughTlvTypeNeeded(tlv_type)) {\n      ENVOY_LOG(trace, \"proxy_protocol: Storing parsed TLV of type {} to filter state.\", tlv_type);\n      parsed_tlvs_.push_back({tlv_type, {tlv_value.begin(), tlv_value.end()}});\n    }\n\n    idx += tlv_value_length;\n    ASSERT(idx <= len);\n  }\n  return true;\n}",
  "abstract_func": "bool Filter::parseTlvs(const uint8_t* VAR_0, size_t VAR_1) {\n  size_t VAR_2{0};\n  while (VAR_2 < VAR_1) {\n    const uint8_t VAR_3 = VAR_0[VAR_2];\n    VAR_2++;\n\n    if ((VAR_2 + 1) >= VAR_1) {\n      ENVOY_LOG(VAR_4,\n                fmt::format(\"failed to read proxy protocol extension. No bytes for TLV length. \"\n                            \"Extension length is {}, current index is {}, current type is {}.\",\n                            VAR_1, VAR_2, VAR_3));\n      return false;\n    }\n\n    const uint8_t VAR_5 = VAR_0[VAR_2];\n    const uint8_t VAR_6 = VAR_0[VAR_2 + 1];\n    const size_t VAR_7 = (VAR_5 << 8) + VAR_6;\n    VAR_2 += 2;\n\n    /* COMMENT_0 */\n    if ((VAR_2 + VAR_7 - 1) >= VAR_1) {\n      ENVOY_LOG(\n          VAR_4,\n          fmt::format(\"failed to read proxy protocol extension. No bytes for TLV value. \"\n                      \"Extension length is {}, current index is {}, current type is {}, current \"\n                      \"value length is {}.\",\n                      VAR_1, VAR_2, VAR_3, VAR_5));\n      return false;\n    }\n\n    /* COMMENT_1 */\n    absl::string_view VAR_8(VAR_9<char const*>(VAR_0 + VAR_2), VAR_7);\n    auto VAR_10 = VAR_11->isTlvTypeNeeded(VAR_3);\n    if (nullptr != VAR_10) {\n      ProtobufWkt::Value VAR_12;\n      /* COMMENT_2 */\n      auto VAR_13 = MessageUtil::sanitizeUtf8String(VAR_8);\n      VAR_12.set_string_value(VAR_13.data(), VAR_13.size());\n\n      std::string VAR_14 = VAR_10->metadata_namespace().empty()\n                                     ? \"envoy.filters.listener.proxy_protocol\"\n                                     : VAR_10->metadata_namespace();\n\n      ProtobufWkt::Struct VAR_15(\n          (*VAR_16->dynamicMetadata().mutable_filter_metadata())[VAR_14]);\n      VAR_15.mutable_fields()->insert({VAR_10->key(), VAR_12});\n      VAR_16->setDynamicMetadata(VAR_14, VAR_15);\n    } else {\n      ENVOY_LOG(VAR_17,\n                \"proxy_protocol: Skip TLV of type {} since it's not needed for dynamic metadata\",\n                VAR_3);\n    }\n\n    /* COMMENT_3 */\n    if (VAR_11->isPassThroughTlvTypeNeeded(VAR_3)) {\n      ENVOY_LOG(VAR_17, \"proxy_protocol: Storing parsed TLV of type {} to filter state.\", VAR_3);\n      VAR_18.push_back({VAR_3, {VAR_8.begin(), VAR_8.end()}});\n    }\n\n    VAR_2 += VAR_7;\n    ASSERT(VAR_2 <= VAR_1);\n  }\n  return true;\n}",
  "func_graph_path": "envoyproxy/envoy/29989f6cc8bfd8cd2ffcb7c42711eb02c7a5168a/proxy_protocol.cc/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -33,7 +33,9 @@\n     auto key_value_pair = config_->isTlvTypeNeeded(tlv_type);\n     if (nullptr != key_value_pair) {\n       ProtobufWkt::Value metadata_value;\n-      metadata_value.set_string_value(tlv_value.data(), tlv_value.size());\n+      // Sanitize any non utf8 characters.\n+      auto sanitised_tlv_value = MessageUtil::sanitizeUtf8String(tlv_value);\n+      metadata_value.set_string_value(sanitised_tlv_value.data(), sanitised_tlv_value.size());\n \n       std::string metadata_key = key_value_pair->metadata_namespace().empty()\n                                      ? \"envoy.filters.listener.proxy_protocol\"",
  "diff_line_info": {
    "deleted_lines": [
      "      metadata_value.set_string_value(tlv_value.data(), tlv_value.size());"
    ],
    "added_lines": [
      "      // Sanitize any non utf8 characters.",
      "      auto sanitised_tlv_value = MessageUtil::sanitizeUtf8String(tlv_value);",
      "      metadata_value.set_string_value(sanitised_tlv_value.data(), sanitised_tlv_value.size());"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/envoyproxy/envoy/pull/32300",
  "description": {
    "pr_info": {
      "title": "repo: Assorted CVE fixes (IMPORTANT!)",
      "number": 32300
    },
    "comment": [
      "Fix crash from AWS NLB healthchecks when proxy protocol is enabled\r\nFix: [CVE-2024-23327](https://github.com/envoyproxy/envoy/security/advisories/GHSA-4h5x-x9vh-m29j)\r\n\r\nCache RE object in uri template matcher. \r\nFix [CVE-2024-23323](https://github.com/envoyproxy/envoy/security/advisories/GHSA-x278-4w4x-r7ch)\r\n\r\nFix crash when idle and request per try timeouts occur within backoff interval\r\nFix [CVE-2024-23322](https://github.com/envoyproxy/envoy/security/advisories/GHSA-6p83-mfmh-qv38)\r\n\r\nFix crash when proxy protocol receives an address type that isn't supported by the operating system\r\nFix [CVE-2024-23325](https://github.com/envoyproxy/envoy/security/advisories/GHSA-5m7c-mrwr-pm26)\r\n\r\nProxy protocol: sanitise non utf8 chars in TLVs\r\nFix [CVE-2024-23324](https://github.com/envoyproxy/envoy/security/advisories/GHSA-gq3v-vvhj-96j6)\r\n",
      "CC @envoyproxy/coverage-shephards: FYI only for changes made to `(test/per_file_coverage.sh)`.\nenvoyproxy/coverage-shephards assignee is @RyanTheOptimist\n\n\n<details>\n\t<summary>:cat:</summary>\n\nCaused by: https://github.com/envoyproxy/envoy/pull/32300 was opened by phlax.\n\nsee: [more](https://github.com/envoyproxy/envoy/pull/32300), [trace](https://prod.repokitteh.app/traces/ui/envoyproxy/envoy/53df9610-c75a-11ee-99e2-8c29c907fa82).\n</details>",
      "> Can we update the PR description to link to the CVEs that this addresses?\r\n\r\ni think we have been here before 8/\r\n\r\nthis PR will be rebased, the commits contain the linked CVEs\r\n\r\nthis is what needs checking @RyanTheOptimist if you could look through that would be appreciated",
      "> > Can we update the PR description to link to the CVEs that this addresses?\r\n> \r\n> i think we have been here before 8/\r\n> \r\n> this PR will be rebased, the commits contain the linked CVEs\r\n> \r\n> this is what needs checking @RyanTheOptimist if you could look through that would be appreciated\r\n\r\nyes, i agree that the code changes look good. It would still be good to copy the links to the CVEs into the PR description so that when we see the commit in git history it has the relevant context.",
      "i already have to copy this information to each commit on each branch - ie 20+ and also to the release summaries\r\n\r\ngiven that the information is there **and needs to be checked** ill leave any further copypasta as an exercise for the reader",
      "I do not believe that \"Assorted CVE fixes (IMPORTANT!)\" meeds the requirements of a PR description from CONTRIBUTING.md. Feel free to get a second opinion from another maintainer.\r\n\r\n```\r\n* Your PR description should have details on what the PR does. If it fixes an existing issue it\r\n  should end with \"Fixes #XXX\".\r\n```",
      "comment updated",
      "I believe [the commit](https://github.com/envoyproxy/envoy/pull/32300/commits/f1cd344edb2775eef8b9d456c76e4a249f1bac8f) to sanitize the proxy protocol values seems wrong. The [sanitizeUtf8String](https://github.com/envoyproxy/envoy/blob/6231a648424d6ae5209d5346960e825a216f95fa/source/common/protobuf/yaml_utility.cc#L341) function used modifies the bytes in a non-recoverable way, but the actual value isn't always meant to be a valid utf8 string. I believe the [proxy protocol spec](https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt) allows for this.\r\n\r\nMaterially, Google's private service connect (PSC) feature encodes a TLV value as a binary encoded int64. With this commit there's no way to recover the original value in most cases. Example value bytes that should be a valid PSC id\r\n`00 22 6b cf 0a 00 00 02` (decodes to `9688686178336770`)\r\n\r\nI think either using set_bytes within `ProtobufWkt::Value` (which doesn't seem to exist today) or escaping the bad bytes in a reverseable way would be necessary.",
      "I think this happened because Envoy is using a protobuf string for both moving data around internally, and sending protobufs flattened over the network. I agree this is an unintended change in behavior. I'm not sure what the best way to fix this is. Can you open an issue for this @fedya-at-db ?",
      "Thanks, I filed an issue [here](https://github.com/envoyproxy/envoy/issues/32718)."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix\n\nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses a security vulnerability by sanitizing non-UTF8 characters in TLVs, referenced by a CVE. The code change ensures proper handling of such characters, preventing potential security issues.\n\nFinal Classification: Security Vulnerability Fix\n\nConfidence Score: 0.95"
}