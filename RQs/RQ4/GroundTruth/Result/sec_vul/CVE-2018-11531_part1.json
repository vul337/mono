{
  "cve_id": "CVE-2018-11531",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "Exiv2/exiv2",
  "commit_msg": "Use index to access buf.pData_",
  "commit_hash": "0330f6bf32e20c18cadf578daada42a343540340",
  "git_url": "https://github.com/Exiv2/exiv2/commit/0330f6bf32e20c18cadf578daada42a343540340",
  "file_path": "src/preview.cpp",
  "func_name": "LoaderTiff::getData",
  "func_before": "DataBuf LoaderTiff::getData() const\n    {\n        const ExifData &exifData = image_.exifData();\n\n        ExifData preview;\n\n        // copy tags\n        for (ExifData::const_iterator pos = exifData.begin(); pos != exifData.end(); ++pos) {\n            if (pos->groupName() == group_) {\n                /*\n                   Write only the necessary TIFF image tags\n                   tags that especially could cause problems are:\n                   \"NewSubfileType\" - the result is no longer a thumbnail, it is a standalone image\n                   \"Orientation\" - this tag typically appears only in the \"Image\" group. Deleting it ensures\n                                   consistent result for all previews, including JPEG\n                */\n                uint16_t tag = pos->tag();\n                if (tag != 0x00fe && tag != 0x00ff && Internal::isTiffImageTag(tag, Internal::ifd0Id)) {\n                    preview.add(ExifKey(tag, \"Image\"), &pos->value());\n                }\n            }\n        }\n\n        Value &dataValue = const_cast<Value&>(preview[\"Exif.Image.\" + offsetTag_].value());\n\n        if (dataValue.sizeDataArea() == 0) {\n            // image data are not available via exifData, read them from image_.io()\n            BasicIo &io = image_.io();\n\n            if (io.open() != 0) {\n                throw Error(kerDataSourceOpenFailed, io.path(), strError());\n            }\n            IoCloser closer(io);\n\n            const Exiv2::byte* base = io.mmap();\n\n            const Value &sizes = preview[\"Exif.Image.\" + sizeTag_].value();\n\n            if (sizes.count() == dataValue.count()) {\n                if (sizes.count() == 1) {\n                    // this saves one copying of the buffer\n                    uint32_t offset = dataValue.toLong(0);\n                    uint32_t size = sizes.toLong(0);\n                    if (offset + size <= static_cast<uint32_t>(io.size()))\n                        dataValue.setDataArea(base + offset, size);\n                }\n                else {\n                    // FIXME: the buffer is probably copied twice, it should be optimized\n                    DataBuf buf(size_);\n                    Exiv2::byte* pos = buf.pData_;\n                    for (int i = 0; i < sizes.count(); i++) {\n                        uint32_t offset = dataValue.toLong(i);\n                        uint32_t size = sizes.toLong(i);\n                        if (size!=0 && offset + size <= static_cast<uint32_t>(io.size()))\n                            memcpy(pos, base + offset, size);\n                        pos += size;\n                    }\n                    dataValue.setDataArea(buf.pData_, buf.size_);\n                }\n            }\n        }\n\n        // Fix compression value in the CR2 IFD2 image\n        if (0 == strcmp(group_, \"Image2\") && image_.mimeType() == \"image/x-canon-cr2\") {\n            preview[\"Exif.Image.Compression\"] = uint16_t(1);\n        }\n\n        // write new image\n        MemIo mio;\n        IptcData emptyIptc;\n        XmpData  emptyXmp;\n        TiffParser::encode(mio, 0, 0, Exiv2::littleEndian, preview, emptyIptc, emptyXmp);\n        return DataBuf(mio.mmap(), (long) mio.size());\n    }",
  "abstract_func_before": "DataBuf LoaderTiff::getData() const\n    {\n        const ExifData &VAR_0 = VAR_1.exifData();\n\n        ExifData VAR_2;\n\n        /* COMMENT_0 */\n        for (ExifData::const_iterator VAR_3 = VAR_0.begin(); VAR_3 != VAR_0.end(); ++VAR_3) {\n            if (VAR_3->groupName() == VAR_4) {\n                /* COMMENT_1 */\n                                                           \n                                                                 \n                                                                                                   \n                                                                                                            \n                                                                                     \n                  \n                uint16_t VAR_5 = VAR_3->tag();\n                if (VAR_5 != 0x00fe && VAR_5 != 0x00ff && Internal::isTiffImageTag(VAR_5, Internal::ifd0Id)) {\n                    VAR_2.add(ExifKey(VAR_5, \"Image\"), &VAR_3->value());\n                }\n            }\n        }\n\n        Value &VAR_6 = VAR_7<Value&>(VAR_2[\"Exif.Image.\" + VAR_8].value());\n\n        if (VAR_6.sizeDataArea() == 0) {\n            /* COMMENT_8 */\n            BasicIo &VAR_9 = VAR_1.io();\n\n            if (VAR_9.open() != 0) {\n                throw Error(VAR_10, VAR_9.path(), strError());\n            }\n            IoCloser closer(io);\n\n            const Exiv2::byte* VAR_11 = io.mmap();\n\n            const Value &VAR_12 = VAR_2[\"Exif.Image.\" + VAR_13].value();\n\n            if (VAR_12.count() == VAR_6.count()) {\n                if (VAR_12.count() == 1) {\n                    /* COMMENT_9 */\n                    uint32_t VAR_14 = VAR_6.toLong(0);\n                    uint32_t VAR_15 = VAR_12.toLong(0);\n                    if (VAR_14 + VAR_15 <= VAR_16<uint32_t>(io.size()))\n                        VAR_6.setDataArea(VAR_11 + VAR_14, VAR_15);\n                }\n                else {\n                    /* COMMENT_10 */\n                    DataBuf buf(size_);\n                    Exiv2::byte* VAR_3 = VAR_17.pData_;\n                    for (int VAR_18 = 0; VAR_18 < VAR_12.count(); VAR_18++) {\n                        uint32_t VAR_14 = VAR_6.toLong(VAR_18);\n                        uint32_t VAR_15 = VAR_12.toLong(VAR_18);\n                        if (VAR_15!=0 && VAR_14 + VAR_15 <= VAR_16<uint32_t>(io.size()))\n                            memcpy(VAR_3, VAR_11 + VAR_14, VAR_15);\n                        VAR_3 += VAR_15;\n                    }\n                    VAR_6.setDataArea(VAR_17.pData_, VAR_17.size_);\n                }\n            }\n        }\n\n        /* COMMENT_11 */\n        if (0 == strcmp(VAR_4, \"Image2\") && VAR_1.mimeType() == \"image/x-canon-cr2\") {\n            VAR_2[\"Exif.Image.Compression\"] = uint16_t(1);\n        }\n\n        /* COMMENT_12 */\n        MemIo VAR_19;\n        IptcData VAR_20;\n        XmpData  VAR_21;\n        TiffParser::encode(VAR_19, 0, 0, Exiv2::littleEndian, VAR_2, VAR_20, VAR_21);\n        return DataBuf(VAR_19.mmap(), (long) VAR_19.size());\n    }",
  "func_graph_path_before": "Exiv2/exiv2/0330f6bf32e20c18cadf578daada42a343540340/preview.cpp/vul/before/0.json",
  "func": "DataBuf LoaderTiff::getData() const\n    {\n        const ExifData &exifData = image_.exifData();\n\n        ExifData preview;\n\n        // copy tags\n        for (ExifData::const_iterator pos = exifData.begin(); pos != exifData.end(); ++pos) {\n            if (pos->groupName() == group_) {\n                /*\n                   Write only the necessary TIFF image tags\n                   tags that especially could cause problems are:\n                   \"NewSubfileType\" - the result is no longer a thumbnail, it is a standalone image\n                   \"Orientation\" - this tag typically appears only in the \"Image\" group. Deleting it ensures\n                                   consistent result for all previews, including JPEG\n                */\n                uint16_t tag = pos->tag();\n                if (tag != 0x00fe && tag != 0x00ff && Internal::isTiffImageTag(tag, Internal::ifd0Id)) {\n                    preview.add(ExifKey(tag, \"Image\"), &pos->value());\n                }\n            }\n        }\n\n        Value &dataValue = const_cast<Value&>(preview[\"Exif.Image.\" + offsetTag_].value());\n\n        if (dataValue.sizeDataArea() == 0) {\n            // image data are not available via exifData, read them from image_.io()\n            BasicIo &io = image_.io();\n\n            if (io.open() != 0) {\n                throw Error(kerDataSourceOpenFailed, io.path(), strError());\n            }\n            IoCloser closer(io);\n\n            const Exiv2::byte* base = io.mmap();\n\n            const Value &sizes = preview[\"Exif.Image.\" + sizeTag_].value();\n\n            if (sizes.count() == dataValue.count()) {\n                if (sizes.count() == 1) {\n                    // this saves one copying of the buffer\n                    uint32_t offset = dataValue.toLong(0);\n                    uint32_t size = sizes.toLong(0);\n                    if (offset + size <= static_cast<uint32_t>(io.size()))\n                        dataValue.setDataArea(base + offset, size);\n                }\n                else {\n                    // FIXME: the buffer is probably copied twice, it should be optimized\n                    DataBuf buf(size_);\n                    uint32_t idxBuf = 0;\n                    for (int i = 0; i < sizes.count(); i++) {\n                        uint32_t offset = dataValue.toLong(i);\n                        uint32_t size = sizes.toLong(i);\n                        if (size!=0 && offset + size <= static_cast<uint32_t>(io.size()))\n                            memcpy(&buf.pData_[idxBuf], base + offset, size);\n                        idxBuf += size;\n                    }\n                    dataValue.setDataArea(buf.pData_, buf.size_);\n                }\n            }\n        }\n\n        // Fix compression value in the CR2 IFD2 image\n        if (0 == strcmp(group_, \"Image2\") && image_.mimeType() == \"image/x-canon-cr2\") {\n            preview[\"Exif.Image.Compression\"] = uint16_t(1);\n        }\n\n        // write new image\n        MemIo mio;\n        IptcData emptyIptc;\n        XmpData  emptyXmp;\n        TiffParser::encode(mio, 0, 0, Exiv2::littleEndian, preview, emptyIptc, emptyXmp);\n        return DataBuf(mio.mmap(), (long) mio.size());\n    }",
  "abstract_func": "DataBuf LoaderTiff::getData() const\n    {\n        const ExifData &VAR_0 = VAR_1.exifData();\n\n        ExifData VAR_2;\n\n        /* COMMENT_0 */\n        for (ExifData::const_iterator VAR_3 = VAR_0.begin(); VAR_3 != VAR_0.end(); ++VAR_3) {\n            if (VAR_3->groupName() == VAR_4) {\n                /* COMMENT_1 */\n                                                           \n                                                                 \n                                                                                                   \n                                                                                                            \n                                                                                     \n                  \n                uint16_t VAR_5 = VAR_3->tag();\n                if (VAR_5 != 0x00fe && VAR_5 != 0x00ff && Internal::isTiffImageTag(VAR_5, Internal::ifd0Id)) {\n                    VAR_2.add(ExifKey(VAR_5, \"Image\"), &VAR_3->value());\n                }\n            }\n        }\n\n        Value &VAR_6 = VAR_7<Value&>(VAR_2[\"Exif.Image.\" + VAR_8].value());\n\n        if (VAR_6.sizeDataArea() == 0) {\n            /* COMMENT_8 */\n            BasicIo &VAR_9 = VAR_1.io();\n\n            if (VAR_9.open() != 0) {\n                throw Error(VAR_10, VAR_9.path(), strError());\n            }\n            IoCloser closer(io);\n\n            const Exiv2::byte* VAR_11 = io.mmap();\n\n            const Value &VAR_12 = VAR_2[\"Exif.Image.\" + VAR_13].value();\n\n            if (VAR_12.count() == VAR_6.count()) {\n                if (VAR_12.count() == 1) {\n                    /* COMMENT_9 */\n                    uint32_t VAR_14 = VAR_6.toLong(0);\n                    uint32_t VAR_15 = VAR_12.toLong(0);\n                    if (VAR_14 + VAR_15 <= VAR_16<uint32_t>(io.size()))\n                        VAR_6.setDataArea(VAR_11 + VAR_14, VAR_15);\n                }\n                else {\n                    /* COMMENT_10 */\n                    DataBuf buf(size_);\n                    uint32_t VAR_17 = 0;\n                    for (int VAR_18 = 0; VAR_18 < VAR_12.count(); VAR_18++) {\n                        uint32_t VAR_14 = VAR_6.toLong(VAR_18);\n                        uint32_t VAR_15 = VAR_12.toLong(VAR_18);\n                        if (VAR_15!=0 && VAR_14 + VAR_15 <= VAR_16<uint32_t>(io.size()))\n                            memcpy(&VAR_19.pData_[VAR_17], VAR_11 + VAR_14, VAR_15);\n                        VAR_17 += VAR_15;\n                    }\n                    VAR_6.setDataArea(VAR_19.pData_, VAR_19.size_);\n                }\n            }\n        }\n\n        /* COMMENT_11 */\n        if (0 == strcmp(VAR_4, \"Image2\") && VAR_1.mimeType() == \"image/x-canon-cr2\") {\n            VAR_2[\"Exif.Image.Compression\"] = uint16_t(1);\n        }\n\n        /* COMMENT_12 */\n        MemIo VAR_20;\n        IptcData VAR_21;\n        XmpData  VAR_22;\n        TiffParser::encode(VAR_20, 0, 0, Exiv2::littleEndian, VAR_2, VAR_21, VAR_22);\n        return DataBuf(VAR_20.mmap(), (long) VAR_20.size());\n    }",
  "func_graph_path": "Exiv2/exiv2/0330f6bf32e20c18cadf578daada42a343540340/preview.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -47,13 +47,13 @@\n                 else {\n                     // FIXME: the buffer is probably copied twice, it should be optimized\n                     DataBuf buf(size_);\n-                    Exiv2::byte* pos = buf.pData_;\n+                    uint32_t idxBuf = 0;\n                     for (int i = 0; i < sizes.count(); i++) {\n                         uint32_t offset = dataValue.toLong(i);\n                         uint32_t size = sizes.toLong(i);\n                         if (size!=0 && offset + size <= static_cast<uint32_t>(io.size()))\n-                            memcpy(pos, base + offset, size);\n-                        pos += size;\n+                            memcpy(&buf.pData_[idxBuf], base + offset, size);\n+                        idxBuf += size;\n                     }\n                     dataValue.setDataArea(buf.pData_, buf.size_);\n                 }",
  "diff_line_info": {
    "deleted_lines": [
      "                    Exiv2::byte* pos = buf.pData_;",
      "                            memcpy(pos, base + offset, size);",
      "                        pos += size;"
    ],
    "added_lines": [
      "                    uint32_t idxBuf = 0;",
      "                            memcpy(&buf.pData_[idxBuf], base + offset, size);",
      "                        idxBuf += size;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/Exiv2/exiv2/pull/327",
  "description": {
    "pr_info": {
      "title": "Fix issue #283",
      "number": 327
    },
    "comment": [
      "This PR should fix #283 by avoiding the write of data out of the bounds of the variable `buf`. For doing that I replaced the **pointer arithmetic** by the usage of and index variable, so that we can prevent the buffer overflow. ",
      "@D4N thanks for your feedback. I implemented the changes you requested."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix\n\nConfidence Score: 0.8",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch changes the method of accessing buffer data from pointer arithmetic to index-based access, which may prevent potential buffer overflow issues. The commit message suggests a code improvement, but the change could mitigate security risks related to buffer access.\n\nFinal Classification: Security Vulnerability Fix\n\nConfidence Score: 0.8"
}