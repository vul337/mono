{
  "cve_id": "CVE-2023-41358",
  "cwe_ids": [
    "CWE-476"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "FRRouting/frr",
  "commit_msg": "bgpd: Do not process NLRIs if the attribute length is zero\n\n```\n3  0x00007f423aa42476 in __GI_raise (sig=sig@entry=11) at ../sysdeps/posix/raise.c:26\n4  0x00007f423aef9740 in core_handler (signo=11, siginfo=0x7fffc414deb0, context=<optimized out>) at lib/sigevent.c:246\n5  <signal handler called>\n6  0x0000564dea2fc71e in route_set_aspath_prepend (rule=0x564debd66d50, prefix=0x7fffc414ea30, object=0x7fffc414e400)\n    at bgpd/bgp_routemap.c:2258\n7  0x00007f423aeec7e0 in route_map_apply_ext (map=<optimized out>, prefix=prefix@entry=0x7fffc414ea30,\n    match_object=match_object@entry=0x7fffc414e400, set_object=set_object@entry=0x7fffc414e400, pref=pref@entry=0x0) at lib/routemap.c:2690\n8  0x0000564dea2d277e in bgp_input_modifier (peer=peer@entry=0x7f4238f59010, p=p@entry=0x7fffc414ea30, attr=attr@entry=0x7fffc414e770,\n    afi=afi@entry=AFI_IP, safi=safi@entry=SAFI_UNICAST, rmap_name=rmap_name@entry=0x0, label=0x0, num_labels=0, dest=0x564debdd5130)\n    at bgpd/bgp_route.c:1772\n9  0x0000564dea2df762 in bgp_update (peer=peer@entry=0x7f4238f59010, p=p@entry=0x7fffc414ea30, addpath_id=addpath_id@entry=0,\n    attr=0x7fffc414eb50, afi=afi@entry=AFI_IP, safi=<optimized out>, safi@entry=SAFI_UNICAST, type=9, sub_type=0, prd=0x0, label=0x0,\n    num_labels=0, soft_reconfig=0, evpn=0x0) at bgpd/bgp_route.c:4374\n10 0x0000564dea2e2047 in bgp_nlri_parse_ip (peer=0x7f4238f59010, attr=attr@entry=0x7fffc414eb50, packet=0x7fffc414eaf0)\n    at bgpd/bgp_route.c:6249\n11 0x0000564dea2c5a58 in bgp_nlri_parse (peer=peer@entry=0x7f4238f59010, attr=attr@entry=0x7fffc414eb50,\n    packet=packet@entry=0x7fffc414eaf0, mp_withdraw=mp_withdraw@entry=false) at bgpd/bgp_packet.c:339\n12 0x0000564dea2c5d66 in bgp_update_receive (peer=peer@entry=0x7f4238f59010, size=size@entry=109) at bgpd/bgp_packet.c:2024\n13 0x0000564dea2c901d in bgp_process_packet (thread=<optimized out>) at bgpd/bgp_packet.c:2933\n14 0x00007f423af0bf71 in event_call (thread=thread@entry=0x7fffc414ee40) at lib/event.c:1995\n15 0x00007f423aebb198 in frr_run (master=0x564deb73c670) at lib/libfrr.c:1213\n16 0x0000564dea261b83 in main (argc=<optimized out>, argv=<optimized out>) at bgpd/bgp_main.c:505\n```\n\nWith the configuration:\n\n```\nfrr version 9.1-dev-MyOwnFRRVersion\nfrr defaults traditional\nhostname ip-172-31-13-140\nlog file /tmp/debug.log\nlog syslog\nservice integrated-vtysh-config\n!\ndebug bgp keepalives\ndebug bgp neighbor-events\ndebug bgp updates in\ndebug bgp updates out\n!\nrouter bgp 100\n bgp router-id 9.9.9.9\n no bgp ebgp-requires-policy\n bgp bestpath aigp\n neighbor 172.31.2.47 remote-as 200\n !\n address-family ipv4 unicast\n  neighbor 172.31.2.47 default-originate\n  neighbor 172.31.2.47 route-map RM_IN in\n exit-address-family\nexit\n!\nroute-map RM_IN permit 10\n set as-path prepend 200\nexit\n!\n```\n\nThe issue is that we try to process NLRIs even if the attribute length is 0.\n\nLater bgp_update() will handle route-maps and a crash occurs because all the\nattributes are NULL, including aspath, where we dereference.\n\nAccording to the RFC 4271:\n\nA value of 0 indicates that neither the Network Layer\n         Reachability Information field nor the Path Attribute field is\n         present in this UPDATE message.\n\nBut with a fuzzed UPDATE message this can be faked. I think it's reasonable\nto skip processing NLRIs if both update_len and attribute_len are 0.\n\nReported-by: Iggy Frankovic <iggyfran@amazon.com>\nSigned-off-by: Donatas Abraitis <donatas@opensourcerouting.org>",
  "commit_hash": "28ccc24d38df1d51ed8a563507e5d6f6171fdd38",
  "git_url": "https://github.com/FRRouting/frr/commit/28ccc24d38df1d51ed8a563507e5d6f6171fdd38",
  "file_path": "bgpd/bgp_packet.c",
  "func_name": "bgp_update_receive",
  "func_before": "static int bgp_update_receive(struct peer *peer, bgp_size_t size)\n{\n\tint ret, nlri_ret;\n\tuint8_t *end;\n\tstruct stream *s;\n\tstruct attr attr;\n\tbgp_size_t attribute_len;\n\tbgp_size_t update_len;\n\tbgp_size_t withdraw_len;\n\tbool restart = false;\n\n\tenum NLRI_TYPES {\n\t\tNLRI_UPDATE,\n\t\tNLRI_WITHDRAW,\n\t\tNLRI_MP_UPDATE,\n\t\tNLRI_MP_WITHDRAW,\n\t\tNLRI_TYPE_MAX\n\t};\n\tstruct bgp_nlri nlris[NLRI_TYPE_MAX];\n\n\t/* Status must be Established. */\n\tif (!peer_established(peer)) {\n\t\tflog_err(EC_BGP_INVALID_STATUS,\n\t\t\t \"%s [FSM] Update packet received under status %s\",\n\t\t\t peer->host,\n\t\t\t lookup_msg(bgp_status_msg, peer->connection->status,\n\t\t\t\t    NULL));\n\t\tbgp_notify_send(peer, BGP_NOTIFY_FSM_ERR,\n\t\t\t\tbgp_fsm_error_subcode(peer->connection->status));\n\t\treturn BGP_Stop;\n\t}\n\n\t/* Set initial values. */\n\tmemset(&attr, 0, sizeof(attr));\n\tattr.label_index = BGP_INVALID_LABEL_INDEX;\n\tattr.label = MPLS_INVALID_LABEL;\n\tmemset(&nlris, 0, sizeof(nlris));\n\tmemset(peer->rcvd_attr_str, 0, BUFSIZ);\n\tpeer->rcvd_attr_printed = 0;\n\n\ts = peer->curr;\n\tend = stream_pnt(s) + size;\n\n\t/* RFC1771 6.3 If the Unfeasible Routes Length or Total Attribute\n\t   Length is too large (i.e., if Unfeasible Routes Length + Total\n\t   Attribute Length + 23 exceeds the message Length), then the Error\n\t   Subcode is set to Malformed Attribute List.  */\n\tif (stream_pnt(s) + 2 > end) {\n\t\tflog_err(EC_BGP_UPDATE_RCV,\n\t\t\t \"%s [Error] Update packet error (packet length is short for unfeasible length)\",\n\t\t\t peer->host);\n\t\tbgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\tBGP_NOTIFY_UPDATE_MAL_ATTR);\n\t\treturn BGP_Stop;\n\t}\n\n\t/* Unfeasible Route Length. */\n\twithdraw_len = stream_getw(s);\n\n\t/* Unfeasible Route Length check. */\n\tif (stream_pnt(s) + withdraw_len > end) {\n\t\tflog_err(EC_BGP_UPDATE_RCV,\n\t\t\t \"%s [Error] Update packet error (packet unfeasible length overflow %d)\",\n\t\t\t peer->host, withdraw_len);\n\t\tbgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\tBGP_NOTIFY_UPDATE_MAL_ATTR);\n\t\treturn BGP_Stop;\n\t}\n\n\t/* Unfeasible Route packet format check. */\n\tif (withdraw_len > 0) {\n\t\tnlris[NLRI_WITHDRAW].afi = AFI_IP;\n\t\tnlris[NLRI_WITHDRAW].safi = SAFI_UNICAST;\n\t\tnlris[NLRI_WITHDRAW].nlri = stream_pnt(s);\n\t\tnlris[NLRI_WITHDRAW].length = withdraw_len;\n\t\tstream_forward_getp(s, withdraw_len);\n\t}\n\n\t/* Attribute total length check. */\n\tif (stream_pnt(s) + 2 > end) {\n\t\tflog_warn(\n\t\t\tEC_BGP_UPDATE_PACKET_SHORT,\n\t\t\t\"%s [Error] Packet Error (update packet is short for attribute length)\",\n\t\t\tpeer->host);\n\t\tbgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\tBGP_NOTIFY_UPDATE_MAL_ATTR);\n\t\treturn BGP_Stop;\n\t}\n\n\t/* Fetch attribute total length. */\n\tattribute_len = stream_getw(s);\n\n\t/* Attribute length check. */\n\tif (stream_pnt(s) + attribute_len > end) {\n\t\tflog_warn(\n\t\t\tEC_BGP_UPDATE_PACKET_LONG,\n\t\t\t\"%s [Error] Packet Error (update packet attribute length overflow %d)\",\n\t\t\tpeer->host, attribute_len);\n\t\tbgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\tBGP_NOTIFY_UPDATE_MAL_ATTR);\n\t\treturn BGP_Stop;\n\t}\n\n\t/* Certain attribute parsing errors should not be considered bad enough\n\t * to reset the session for, most particularly any partial/optional\n\t * attributes that have 'tunneled' over speakers that don't understand\n\t * them. Instead we withdraw only the prefix concerned.\n\t *\n\t * Complicates the flow a little though..\n\t */\n\tenum bgp_attr_parse_ret attr_parse_ret = BGP_ATTR_PARSE_PROCEED;\n/* This define morphs the update case into a withdraw when lower levels\n * have signalled an error condition where this is best.\n */\n#define NLRI_ATTR_ARG (attr_parse_ret != BGP_ATTR_PARSE_WITHDRAW ? &attr : NULL)\n\n\t/* Parse attribute when it exists. */\n\tif (attribute_len) {\n\t\tattr_parse_ret = bgp_attr_parse(peer, &attr, attribute_len,\n\t\t\t\t\t\t&nlris[NLRI_MP_UPDATE],\n\t\t\t\t\t\t&nlris[NLRI_MP_WITHDRAW]);\n\t\tif (attr_parse_ret == BGP_ATTR_PARSE_ERROR) {\n\t\t\tbgp_attr_unintern_sub(&attr);\n\t\t\treturn BGP_Stop;\n\t\t}\n\t}\n\n\t/* Logging the attribute. */\n\tif (attr_parse_ret == BGP_ATTR_PARSE_WITHDRAW\n\t    || BGP_DEBUG(update, UPDATE_IN)\n\t    || BGP_DEBUG(update, UPDATE_PREFIX)) {\n\t\tret = bgp_dump_attr(&attr, peer->rcvd_attr_str,\n\t\t\t\t    sizeof(peer->rcvd_attr_str));\n\n\t\tpeer->stat_upd_7606++;\n\n\t\tif (attr_parse_ret == BGP_ATTR_PARSE_WITHDRAW)\n\t\t\tflog_err(\n\t\t\t\tEC_BGP_UPDATE_RCV,\n\t\t\t\t\"%pBP rcvd UPDATE with errors in attr(s)!! Withdrawing route.\",\n\t\t\t\tpeer);\n\n\t\tif (ret && bgp_debug_update(peer, NULL, NULL, 1)) {\n\t\t\tzlog_debug(\"%pBP rcvd UPDATE w/ attr: %s\", peer,\n\t\t\t\t   peer->rcvd_attr_str);\n\t\t\tpeer->rcvd_attr_printed = 1;\n\t\t}\n\t}\n\n\t/* Network Layer Reachability Information. */\n\tupdate_len = end - stream_pnt(s);\n\n\tif (update_len) {\n\t\t/* Set NLRI portion to structure. */\n\t\tnlris[NLRI_UPDATE].afi = AFI_IP;\n\t\tnlris[NLRI_UPDATE].safi = SAFI_UNICAST;\n\t\tnlris[NLRI_UPDATE].nlri = stream_pnt(s);\n\t\tnlris[NLRI_UPDATE].length = update_len;\n\t\tstream_forward_getp(s, update_len);\n\n\t\tif (CHECK_FLAG(attr.flag, ATTR_FLAG_BIT(BGP_ATTR_MP_REACH_NLRI))) {\n\t\t\t/*\n\t\t\t * We skipped nexthop attribute validation earlier so\n\t\t\t * validate the nexthop now.\n\t\t\t */\n\t\t\tif (bgp_attr_nexthop_valid(peer, &attr) < 0) {\n\t\t\t\tbgp_attr_unintern_sub(&attr);\n\t\t\t\treturn BGP_Stop;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (BGP_DEBUG(update, UPDATE_IN))\n\t\tzlog_debug(\"%pBP rcvd UPDATE wlen %d attrlen %d alen %d\", peer,\n\t\t\t   withdraw_len, attribute_len, update_len);\n\n\t/* Parse any given NLRIs */\n\tfor (int i = NLRI_UPDATE; i < NLRI_TYPE_MAX; i++) {\n\t\tif (!nlris[i].nlri)\n\t\t\tcontinue;\n\n\t\t/* NLRI is processed iff the peer if configured for the specific\n\t\t * afi/safi */\n\t\tif (!peer->afc[nlris[i].afi][nlris[i].safi]) {\n\t\t\tzlog_info(\n\t\t\t\t\"%s [Info] UPDATE for non-enabled AFI/SAFI %u/%u\",\n\t\t\t\tpeer->host, nlris[i].afi, nlris[i].safi);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* EoR handled later */\n\t\tif (nlris[i].length == 0)\n\t\t\tcontinue;\n\n\t\tswitch (i) {\n\t\tcase NLRI_UPDATE:\n\t\tcase NLRI_MP_UPDATE:\n\t\t\tnlri_ret = bgp_nlri_parse(peer, NLRI_ATTR_ARG,\n\t\t\t\t\t\t  &nlris[i], 0);\n\t\t\tbreak;\n\t\tcase NLRI_WITHDRAW:\n\t\tcase NLRI_MP_WITHDRAW:\n\t\t\tnlri_ret = bgp_nlri_parse(peer, NLRI_ATTR_ARG,\n\t\t\t\t\t\t  &nlris[i], 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnlri_ret = BGP_NLRI_PARSE_ERROR;\n\t\t}\n\n\t\tif (nlri_ret < BGP_NLRI_PARSE_OK\n\t\t    && nlri_ret != BGP_NLRI_PARSE_ERROR_PREFIX_OVERFLOW) {\n\t\t\tflog_err(EC_BGP_UPDATE_RCV,\n\t\t\t\t \"%s [Error] Error parsing NLRI\", peer->host);\n\t\t\tif (peer_established(peer))\n\t\t\t\tbgp_notify_send(\n\t\t\t\t\tpeer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\t\ti <= NLRI_WITHDRAW\n\t\t\t\t\t\t? BGP_NOTIFY_UPDATE_INVAL_NETWORK\n\t\t\t\t\t\t: BGP_NOTIFY_UPDATE_OPT_ATTR_ERR);\n\t\t\tbgp_attr_unintern_sub(&attr);\n\t\t\treturn BGP_Stop;\n\t\t}\n\t}\n\n\t/* EoR checks\n\t *\n\t * Non-MP IPv4/Unicast EoR is a completely empty UPDATE\n\t * and MP EoR should have only an empty MP_UNREACH\n\t */\n\tif ((!update_len && !withdraw_len && nlris[NLRI_MP_UPDATE].length == 0)\n\t    || (attr_parse_ret == BGP_ATTR_PARSE_EOR)) {\n\t\tafi_t afi = 0;\n\t\tsafi_t safi;\n\t\tstruct graceful_restart_info *gr_info;\n\n\t\t/* Restarting router */\n\t\tif (BGP_PEER_GRACEFUL_RESTART_CAPABLE(peer)\n\t\t    && BGP_PEER_RESTARTING_MODE(peer))\n\t\t\trestart = true;\n\n\t\t/* Non-MP IPv4/Unicast is a completely emtpy UPDATE - already\n\t\t * checked\n\t\t * update and withdraw NLRI lengths are 0.\n\t\t */\n\t\tif (!attribute_len) {\n\t\t\tafi = AFI_IP;\n\t\t\tsafi = SAFI_UNICAST;\n\t\t} else if (attr.flag & ATTR_FLAG_BIT(BGP_ATTR_MP_UNREACH_NLRI)\n\t\t\t   && nlris[NLRI_MP_WITHDRAW].length == 0) {\n\t\t\tafi = nlris[NLRI_MP_WITHDRAW].afi;\n\t\t\tsafi = nlris[NLRI_MP_WITHDRAW].safi;\n\t\t} else if (attr_parse_ret == BGP_ATTR_PARSE_EOR) {\n\t\t\tafi = nlris[NLRI_MP_UPDATE].afi;\n\t\t\tsafi = nlris[NLRI_MP_UPDATE].safi;\n\t\t}\n\n\t\tif (afi && peer->afc[afi][safi]) {\n\t\t\tstruct vrf *vrf = vrf_lookup_by_id(peer->bgp->vrf_id);\n\n\t\t\t/* End-of-RIB received */\n\t\t\tif (!CHECK_FLAG(peer->af_sflags[afi][safi],\n\t\t\t\t\tPEER_STATUS_EOR_RECEIVED)) {\n\t\t\t\tSET_FLAG(peer->af_sflags[afi][safi],\n\t\t\t\t\t PEER_STATUS_EOR_RECEIVED);\n\t\t\t\tbgp_update_explicit_eors(peer);\n\t\t\t\t/* Update graceful restart information */\n\t\t\t\tgr_info = &(peer->bgp->gr_info[afi][safi]);\n\t\t\t\tif (restart)\n\t\t\t\t\tgr_info->eor_received++;\n\t\t\t\t/* If EOR received from all peers and selection\n\t\t\t\t * deferral timer is running, cancel the timer\n\t\t\t\t * and invoke the best path calculation\n\t\t\t\t */\n\t\t\t\tif (gr_info->eor_required\n\t\t\t\t    == gr_info->eor_received) {\n\t\t\t\t\tif (bgp_debug_neighbor_events(peer))\n\t\t\t\t\t\tzlog_debug(\n\t\t\t\t\t\t\t\"%s %d, %s %d\",\n\t\t\t\t\t\t\t\"EOR REQ\",\n\t\t\t\t\t\t\tgr_info->eor_required,\n\t\t\t\t\t\t\t\"EOR RCV\",\n\t\t\t\t\t\t\tgr_info->eor_received);\n\t\t\t\t\tif (gr_info->t_select_deferral) {\n\t\t\t\t\t\tvoid *info = EVENT_ARG(\n\t\t\t\t\t\t\tgr_info->t_select_deferral);\n\t\t\t\t\t\tXFREE(MTYPE_TMP, info);\n\t\t\t\t\t}\n\t\t\t\t\tEVENT_OFF(gr_info->t_select_deferral);\n\t\t\t\t\tgr_info->eor_required = 0;\n\t\t\t\t\tgr_info->eor_received = 0;\n\t\t\t\t\t/* Best path selection */\n\t\t\t\t\tbgp_best_path_select_defer(peer->bgp,\n\t\t\t\t\t\t\t\t   afi, safi);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* NSF delete stale route */\n\t\t\tif (peer->nsf[afi][safi])\n\t\t\t\tbgp_clear_stale_route(peer, afi, safi);\n\n\t\t\tzlog_info(\n\t\t\t\t\"%s: rcvd End-of-RIB for %s from %s in vrf %s\",\n\t\t\t\t__func__, get_afi_safi_str(afi, safi, false),\n\t\t\t\tpeer->host, vrf ? vrf->name : VRF_DEFAULT_NAME);\n\t\t}\n\t}\n\n\t/* Everything is done.  We unintern temporary structures which\n\t   interned in bgp_attr_parse(). */\n\tbgp_attr_unintern_sub(&attr);\n\n\tpeer->update_time = monotime(NULL);\n\n\t/* Notify BGP Conditional advertisement scanner process */\n\tpeer->advmap_table_change = true;\n\n\treturn Receive_UPDATE_message;\n}",
  "abstract_func_before": "static int bgp_update_receive(struct peer *peer, bgp_size_t VAR_0)\n{\n\tint VAR_1, VAR_2;\n\tuint8_t *VAR_3;\n\tstruct stream *VAR_4;\n\tstruct attr attr;\n\tbgp_size_t VAR_5;\n\tbgp_size_t VAR_6;\n\tbgp_size_t VAR_7;\n\tbool VAR_8 = false;\n\n\tenum NLRI_TYPES {\n\t\tVAR_9,\n\t\tVAR_10,\n\t\tVAR_11,\n\t\tVAR_12,\n\t\tVAR_13\n\t};\n\tstruct bgp_nlri VAR_14[VAR_13];\n\n\t/* COMMENT_0 */\n\tif (!peer_established(peer)) {\n\t\tflog_err(VAR_15,\n\t\t\t \"%s [FSM] Update packet received under status %s\",\n\t\t\t peer->host,\n\t\t\t lookup_msg(VAR_16, peer->connection->status,\n\t\t\t\t    NULL));\n\t\tbgp_notify_send(peer, VAR_17,\n\t\t\t\tbgp_fsm_error_subcode(peer->connection->status));\n\t\treturn VAR_18;\n\t}\n\n\t/* COMMENT_1 */\n\tmemset(&attr, 0, sizeof(attr));\n\tattr.label_index = VAR_19;\n\tattr.label = VAR_20;\n\tmemset(&VAR_14, 0, sizeof(VAR_14));\n\tmemset(peer->rcvd_attr_str, 0, VAR_21);\n\tpeer->rcvd_attr_printed = 0;\n\n\tVAR_4 = peer->curr;\n\tVAR_3 = stream_pnt(VAR_4) + VAR_0;\n\n\t/* COMMENT_2 */\n                                                                  \n                                                                     \n                                                   \n\tif (stream_pnt(VAR_4) + 2 > VAR_3) {\n\t\tflog_err(VAR_22,\n\t\t\t \"%s [Error] Update packet error (packet length is short for unfeasible length)\",\n\t\t\t peer->host);\n\t\tbgp_notify_send(peer, VAR_23,\n\t\t\t\tVAR_24);\n\t\treturn VAR_18;\n\t}\n\n\t/* COMMENT_6 */\n\tVAR_7 = stream_getw(VAR_4);\n\n\t/* COMMENT_7 */\n\tif (stream_pnt(VAR_4) + VAR_7 > VAR_3) {\n\t\tflog_err(VAR_22,\n\t\t\t \"%s [Error] Update packet error (packet unfeasible length overflow %d)\",\n\t\t\t peer->host, VAR_7);\n\t\tbgp_notify_send(peer, VAR_23,\n\t\t\t\tVAR_24);\n\t\treturn VAR_18;\n\t}\n\n\t/* COMMENT_8 */\n\tif (VAR_7 > 0) {\n\t\tVAR_14[VAR_10].afi = VAR_25;\n\t\tVAR_14[VAR_10].safi = VAR_26;\n\t\tVAR_14[VAR_10].nlri = stream_pnt(VAR_4);\n\t\tVAR_14[VAR_10].length = VAR_7;\n\t\tstream_forward_getp(VAR_4, VAR_7);\n\t}\n\n\t/* COMMENT_9 */\n\tif (stream_pnt(VAR_4) + 2 > VAR_3) {\n\t\tflog_warn(\n\t\t\tVAR_27,\n\t\t\t\"%s [Error] Packet Error (update packet is short for attribute length)\",\n\t\t\tpeer->host);\n\t\tbgp_notify_send(peer, VAR_23,\n\t\t\t\tVAR_24);\n\t\treturn VAR_18;\n\t}\n\n\t/* COMMENT_10 */\n\tVAR_5 = stream_getw(VAR_4);\n\n\t/* COMMENT_11 */\n\tif (stream_pnt(VAR_4) + VAR_5 > VAR_3) {\n\t\tflog_warn(\n\t\t\tVAR_28,\n\t\t\t\"%s [Error] Packet Error (update packet attribute length overflow %d)\",\n\t\t\tpeer->host, VAR_5);\n\t\tbgp_notify_send(peer, VAR_23,\n\t\t\t\tVAR_24);\n\t\treturn VAR_18;\n\t}\n\n\t/* COMMENT_12 */\n                                                                    \n                                                                       \n                                                        \n   \n                                          \n    \n\tenum bgp_attr_parse_ret VAR_29 = VAR_30;\n/* COMMENT_19 */\n                                                        \n   \n#define VAR_31 (attr_parse_ret != BGP_ATTR_PARSE_WITHDRAW ? &attr : NULL)\n\n\t/* COMMENT_22 */\n\tif (VAR_5) {\n\t\tVAR_29 = bgp_attr_parse(peer, &attr, VAR_5,\n\t\t\t\t\t\t&VAR_14[VAR_11],\n\t\t\t\t\t\t&VAR_14[VAR_12]);\n\t\tif (VAR_29 == VAR_32) {\n\t\t\tbgp_attr_unintern_sub(&attr);\n\t\t\treturn VAR_18;\n\t\t}\n\t}\n\n\t/* COMMENT_23 */\n\tif (VAR_29 == VAR_33\n\t    || BGP_DEBUG(VAR_34, VAR_35)\n\t    || BGP_DEBUG(VAR_34, VAR_36)) {\n\t\tVAR_1 = bgp_dump_attr(&attr, peer->rcvd_attr_str,\n\t\t\t\t    sizeof(peer->rcvd_attr_str));\n\n\t\tpeer->stat_upd_7606++;\n\n\t\tif (VAR_29 == VAR_33)\n\t\t\tflog_err(\n\t\t\t\tVAR_22,\n\t\t\t\t\"%pBP rcvd UPDATE with errors in attr(s)!! Withdrawing route.\",\n\t\t\t\tpeer);\n\n\t\tif (VAR_1 && bgp_debug_update(peer, NULL, NULL, 1)) {\n\t\t\tzlog_debug(\"%pBP rcvd UPDATE w/ attr: %s\", peer,\n\t\t\t\t   peer->rcvd_attr_str);\n\t\t\tpeer->rcvd_attr_printed = 1;\n\t\t}\n\t}\n\n\t/* COMMENT_24 */\n\tVAR_6 = VAR_3 - stream_pnt(VAR_4);\n\n\tif (VAR_6) {\n\t\t/* COMMENT_25 */\n\t\tVAR_14[VAR_9].afi = VAR_25;\n\t\tVAR_14[VAR_9].safi = VAR_26;\n\t\tVAR_14[VAR_9].nlri = stream_pnt(VAR_4);\n\t\tVAR_14[VAR_9].length = VAR_6;\n\t\tstream_forward_getp(VAR_4, VAR_6);\n\n\t\tif (CHECK_FLAG(attr.flag, ATTR_FLAG_BIT(VAR_37))) {\n\t\t\t/* COMMENT_26 */\n                                                        \n                               \n      \n\t\t\tif (bgp_attr_nexthop_valid(peer, &attr) < 0) {\n\t\t\t\tbgp_attr_unintern_sub(&attr);\n\t\t\t\treturn VAR_18;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (BGP_DEBUG(VAR_34, VAR_35))\n\t\tzlog_debug(\"%pBP rcvd UPDATE wlen %d attrlen %d alen %d\", peer,\n\t\t\t   VAR_7, VAR_5, VAR_6);\n\n\t/* COMMENT_30 */\n\tfor (int VAR_38 = VAR_9; VAR_38 < VAR_13; VAR_38++) {\n\t\tif (!VAR_14[VAR_38].nlri)\n\t\t\tcontinue;\n\n\t\t/* COMMENT_31 */\n                \n\t\tif (!peer->afc[VAR_14[VAR_38].afi][VAR_14[VAR_38].safi]) {\n\t\t\tzlog_info(\n\t\t\t\t\"%s [Info] UPDATE for non-enabled AFI/SAFI %u/%u\",\n\t\t\t\tpeer->host, VAR_14[VAR_38].afi, VAR_14[VAR_38].safi);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* COMMENT_33 */\n\t\tif (VAR_14[VAR_38].length == 0)\n\t\t\tcontinue;\n\n\t\tswitch (VAR_38) {\n\t\tcase VAR_9:\n\t\tcase VAR_11:\n\t\t\tVAR_2 = bgp_nlri_parse(peer, VAR_31,\n\t\t\t\t\t\t  &VAR_14[VAR_38], 0);\n\t\t\tbreak;\n\t\tcase VAR_10:\n\t\tcase VAR_12:\n\t\t\tVAR_2 = bgp_nlri_parse(peer, VAR_31,\n\t\t\t\t\t\t  &VAR_14[VAR_38], 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tVAR_2 = VAR_39;\n\t\t}\n\n\t\tif (VAR_2 < VAR_40\n\t\t    && VAR_2 != VAR_41) {\n\t\t\tflog_err(VAR_22,\n\t\t\t\t \"%s [Error] Error parsing NLRI\", peer->host);\n\t\t\tif (peer_established(peer))\n\t\t\t\tbgp_notify_send(\n\t\t\t\t\tpeer, VAR_23,\n\t\t\t\t\tVAR_38 <= VAR_10\n\t\t\t\t\t\t? VAR_42\n\t\t\t\t\t\t: VAR_43);\n\t\t\tbgp_attr_unintern_sub(&attr);\n\t\t\treturn VAR_18;\n\t\t}\n\t}\n\n\t/* COMMENT_34 */\n   \n                                                        \n                                                   \n    \n\tif ((!VAR_6 && !VAR_7 && VAR_14[VAR_11].length == 0)\n\t    || (VAR_29 == VAR_44)) {\n\t\tafi_t VAR_45 = 0;\n\t\tsafi_t VAR_46;\n\t\tstruct graceful_restart_info *VAR_47;\n\n\t\t/* COMMENT_39 */\n\t\tif (BGP_PEER_GRACEFUL_RESTART_CAPABLE(peer)\n\t\t    && BGP_PEER_RESTARTING_MODE(peer))\n\t\t\tVAR_8 = true;\n\n\t\t/* COMMENT_40 */\n            \n                                            \n     \n\t\tif (!VAR_5) {\n\t\t\tVAR_45 = VAR_25;\n\t\t\tVAR_46 = VAR_26;\n\t\t} else if (attr.flag & ATTR_FLAG_BIT(VAR_48)\n\t\t\t   && VAR_14[VAR_12].length == 0) {\n\t\t\tVAR_45 = VAR_14[VAR_12].afi;\n\t\t\tVAR_46 = VAR_14[VAR_12].safi;\n\t\t} else if (VAR_29 == VAR_44) {\n\t\t\tVAR_45 = VAR_14[VAR_11].afi;\n\t\t\tVAR_46 = VAR_14[VAR_11].safi;\n\t\t}\n\n\t\tif (VAR_45 && peer->afc[VAR_45][VAR_46]) {\n\t\t\tstruct vrf *vrf = vrf_lookup_by_id(peer->bgp->vrf_id);\n\n\t\t\t/* COMMENT_44 */\n\t\t\tif (!CHECK_FLAG(peer->af_sflags[VAR_45][VAR_46],\n\t\t\t\t\tVAR_49)) {\n\t\t\t\tSET_FLAG(peer->af_sflags[VAR_45][VAR_46],\n\t\t\t\t\t VAR_49);\n\t\t\t\tbgp_update_explicit_eors(peer);\n\t\t\t\t/* COMMENT_45 */\n\t\t\t\tVAR_47 = &(peer->bgp->gr_info[VAR_45][VAR_46]);\n\t\t\t\tif (VAR_8)\n\t\t\t\t\tVAR_47->eor_received++;\n\t\t\t\t/* COMMENT_46 */\n                                                  \n                                           \n       \n\t\t\t\tif (VAR_47->eor_required\n\t\t\t\t    == VAR_47->eor_received) {\n\t\t\t\t\tif (bgp_debug_neighbor_events(peer))\n\t\t\t\t\t\tzlog_debug(\n\t\t\t\t\t\t\t\"%s %d, %s %d\",\n\t\t\t\t\t\t\t\"EOR REQ\",\n\t\t\t\t\t\t\tVAR_47->eor_required,\n\t\t\t\t\t\t\t\"EOR RCV\",\n\t\t\t\t\t\t\tVAR_47->eor_received);\n\t\t\t\t\tif (VAR_47->t_select_deferral) {\n\t\t\t\t\t\tvoid *VAR_50 = EVENT_ARG(\n\t\t\t\t\t\t\tVAR_47->t_select_deferral);\n\t\t\t\t\t\tXFREE(VAR_51, VAR_50);\n\t\t\t\t\t}\n\t\t\t\t\tEVENT_OFF(VAR_47->t_select_deferral);\n\t\t\t\t\tVAR_47->eor_required = 0;\n\t\t\t\t\tVAR_47->eor_received = 0;\n\t\t\t\t\t/* COMMENT_50 */\n\t\t\t\t\tbgp_best_path_select_defer(peer->bgp,\n\t\t\t\t\t\t\t\t   VAR_45, VAR_46);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* COMMENT_51 */\n\t\t\tif (peer->nsf[VAR_45][VAR_46])\n\t\t\t\tbgp_clear_stale_route(peer, VAR_45, VAR_46);\n\n\t\t\tzlog_info(\n\t\t\t\t\"%s: rcvd End-of-RIB for %s from %s in vrf %s\",\n\t\t\t\tVAR_52, get_afi_safi_str(VAR_45, VAR_46, false),\n\t\t\t\tpeer->host, vrf ? vrf->name : VAR_53);\n\t\t}\n\t}\n\n\t/* COMMENT_52 */\n                                    \n\tbgp_attr_unintern_sub(&attr);\n\n\tpeer->update_time = monotime(NULL);\n\n\t/* COMMENT_54 */\n\tpeer->advmap_table_change = true;\n\n\treturn VAR_54;\n}",
  "func_graph_path_before": "FRRouting/frr/28ccc24d38df1d51ed8a563507e5d6f6171fdd38/bgp_packet.c/vul/before/0.json",
  "func": "static int bgp_update_receive(struct peer *peer, bgp_size_t size)\n{\n\tint ret, nlri_ret;\n\tuint8_t *end;\n\tstruct stream *s;\n\tstruct attr attr;\n\tbgp_size_t attribute_len;\n\tbgp_size_t update_len;\n\tbgp_size_t withdraw_len;\n\tbool restart = false;\n\n\tenum NLRI_TYPES {\n\t\tNLRI_UPDATE,\n\t\tNLRI_WITHDRAW,\n\t\tNLRI_MP_UPDATE,\n\t\tNLRI_MP_WITHDRAW,\n\t\tNLRI_TYPE_MAX\n\t};\n\tstruct bgp_nlri nlris[NLRI_TYPE_MAX];\n\n\t/* Status must be Established. */\n\tif (!peer_established(peer)) {\n\t\tflog_err(EC_BGP_INVALID_STATUS,\n\t\t\t \"%s [FSM] Update packet received under status %s\",\n\t\t\t peer->host,\n\t\t\t lookup_msg(bgp_status_msg, peer->connection->status,\n\t\t\t\t    NULL));\n\t\tbgp_notify_send(peer, BGP_NOTIFY_FSM_ERR,\n\t\t\t\tbgp_fsm_error_subcode(peer->connection->status));\n\t\treturn BGP_Stop;\n\t}\n\n\t/* Set initial values. */\n\tmemset(&attr, 0, sizeof(attr));\n\tattr.label_index = BGP_INVALID_LABEL_INDEX;\n\tattr.label = MPLS_INVALID_LABEL;\n\tmemset(&nlris, 0, sizeof(nlris));\n\tmemset(peer->rcvd_attr_str, 0, BUFSIZ);\n\tpeer->rcvd_attr_printed = 0;\n\n\ts = peer->curr;\n\tend = stream_pnt(s) + size;\n\n\t/* RFC1771 6.3 If the Unfeasible Routes Length or Total Attribute\n\t   Length is too large (i.e., if Unfeasible Routes Length + Total\n\t   Attribute Length + 23 exceeds the message Length), then the Error\n\t   Subcode is set to Malformed Attribute List.  */\n\tif (stream_pnt(s) + 2 > end) {\n\t\tflog_err(EC_BGP_UPDATE_RCV,\n\t\t\t \"%s [Error] Update packet error (packet length is short for unfeasible length)\",\n\t\t\t peer->host);\n\t\tbgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\tBGP_NOTIFY_UPDATE_MAL_ATTR);\n\t\treturn BGP_Stop;\n\t}\n\n\t/* Unfeasible Route Length. */\n\twithdraw_len = stream_getw(s);\n\n\t/* Unfeasible Route Length check. */\n\tif (stream_pnt(s) + withdraw_len > end) {\n\t\tflog_err(EC_BGP_UPDATE_RCV,\n\t\t\t \"%s [Error] Update packet error (packet unfeasible length overflow %d)\",\n\t\t\t peer->host, withdraw_len);\n\t\tbgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\tBGP_NOTIFY_UPDATE_MAL_ATTR);\n\t\treturn BGP_Stop;\n\t}\n\n\t/* Unfeasible Route packet format check. */\n\tif (withdraw_len > 0) {\n\t\tnlris[NLRI_WITHDRAW].afi = AFI_IP;\n\t\tnlris[NLRI_WITHDRAW].safi = SAFI_UNICAST;\n\t\tnlris[NLRI_WITHDRAW].nlri = stream_pnt(s);\n\t\tnlris[NLRI_WITHDRAW].length = withdraw_len;\n\t\tstream_forward_getp(s, withdraw_len);\n\t}\n\n\t/* Attribute total length check. */\n\tif (stream_pnt(s) + 2 > end) {\n\t\tflog_warn(\n\t\t\tEC_BGP_UPDATE_PACKET_SHORT,\n\t\t\t\"%s [Error] Packet Error (update packet is short for attribute length)\",\n\t\t\tpeer->host);\n\t\tbgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\tBGP_NOTIFY_UPDATE_MAL_ATTR);\n\t\treturn BGP_Stop;\n\t}\n\n\t/* Fetch attribute total length. */\n\tattribute_len = stream_getw(s);\n\n\t/* Attribute length check. */\n\tif (stream_pnt(s) + attribute_len > end) {\n\t\tflog_warn(\n\t\t\tEC_BGP_UPDATE_PACKET_LONG,\n\t\t\t\"%s [Error] Packet Error (update packet attribute length overflow %d)\",\n\t\t\tpeer->host, attribute_len);\n\t\tbgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\tBGP_NOTIFY_UPDATE_MAL_ATTR);\n\t\treturn BGP_Stop;\n\t}\n\n\t/* Certain attribute parsing errors should not be considered bad enough\n\t * to reset the session for, most particularly any partial/optional\n\t * attributes that have 'tunneled' over speakers that don't understand\n\t * them. Instead we withdraw only the prefix concerned.\n\t *\n\t * Complicates the flow a little though..\n\t */\n\tenum bgp_attr_parse_ret attr_parse_ret = BGP_ATTR_PARSE_PROCEED;\n/* This define morphs the update case into a withdraw when lower levels\n * have signalled an error condition where this is best.\n */\n#define NLRI_ATTR_ARG (attr_parse_ret != BGP_ATTR_PARSE_WITHDRAW ? &attr : NULL)\n\n\t/* Parse attribute when it exists. */\n\tif (attribute_len) {\n\t\tattr_parse_ret = bgp_attr_parse(peer, &attr, attribute_len,\n\t\t\t\t\t\t&nlris[NLRI_MP_UPDATE],\n\t\t\t\t\t\t&nlris[NLRI_MP_WITHDRAW]);\n\t\tif (attr_parse_ret == BGP_ATTR_PARSE_ERROR) {\n\t\t\tbgp_attr_unintern_sub(&attr);\n\t\t\treturn BGP_Stop;\n\t\t}\n\t}\n\n\t/* Logging the attribute. */\n\tif (attr_parse_ret == BGP_ATTR_PARSE_WITHDRAW\n\t    || BGP_DEBUG(update, UPDATE_IN)\n\t    || BGP_DEBUG(update, UPDATE_PREFIX)) {\n\t\tret = bgp_dump_attr(&attr, peer->rcvd_attr_str,\n\t\t\t\t    sizeof(peer->rcvd_attr_str));\n\n\t\tpeer->stat_upd_7606++;\n\n\t\tif (attr_parse_ret == BGP_ATTR_PARSE_WITHDRAW)\n\t\t\tflog_err(\n\t\t\t\tEC_BGP_UPDATE_RCV,\n\t\t\t\t\"%pBP rcvd UPDATE with errors in attr(s)!! Withdrawing route.\",\n\t\t\t\tpeer);\n\n\t\tif (ret && bgp_debug_update(peer, NULL, NULL, 1)) {\n\t\t\tzlog_debug(\"%pBP rcvd UPDATE w/ attr: %s\", peer,\n\t\t\t\t   peer->rcvd_attr_str);\n\t\t\tpeer->rcvd_attr_printed = 1;\n\t\t}\n\t}\n\n\t/* Network Layer Reachability Information. */\n\tupdate_len = end - stream_pnt(s);\n\n\tif (update_len && attribute_len) {\n\t\t/* Set NLRI portion to structure. */\n\t\tnlris[NLRI_UPDATE].afi = AFI_IP;\n\t\tnlris[NLRI_UPDATE].safi = SAFI_UNICAST;\n\t\tnlris[NLRI_UPDATE].nlri = stream_pnt(s);\n\t\tnlris[NLRI_UPDATE].length = update_len;\n\t\tstream_forward_getp(s, update_len);\n\n\t\tif (CHECK_FLAG(attr.flag, ATTR_FLAG_BIT(BGP_ATTR_MP_REACH_NLRI))) {\n\t\t\t/*\n\t\t\t * We skipped nexthop attribute validation earlier so\n\t\t\t * validate the nexthop now.\n\t\t\t */\n\t\t\tif (bgp_attr_nexthop_valid(peer, &attr) < 0) {\n\t\t\t\tbgp_attr_unintern_sub(&attr);\n\t\t\t\treturn BGP_Stop;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (BGP_DEBUG(update, UPDATE_IN))\n\t\tzlog_debug(\"%pBP rcvd UPDATE wlen %d attrlen %d alen %d\", peer,\n\t\t\t   withdraw_len, attribute_len, update_len);\n\n\t/* Parse any given NLRIs */\n\tfor (int i = NLRI_UPDATE; i < NLRI_TYPE_MAX; i++) {\n\t\tif (!nlris[i].nlri)\n\t\t\tcontinue;\n\n\t\t/* NLRI is processed iff the peer if configured for the specific\n\t\t * afi/safi */\n\t\tif (!peer->afc[nlris[i].afi][nlris[i].safi]) {\n\t\t\tzlog_info(\n\t\t\t\t\"%s [Info] UPDATE for non-enabled AFI/SAFI %u/%u\",\n\t\t\t\tpeer->host, nlris[i].afi, nlris[i].safi);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* EoR handled later */\n\t\tif (nlris[i].length == 0)\n\t\t\tcontinue;\n\n\t\tswitch (i) {\n\t\tcase NLRI_UPDATE:\n\t\tcase NLRI_MP_UPDATE:\n\t\t\tnlri_ret = bgp_nlri_parse(peer, NLRI_ATTR_ARG,\n\t\t\t\t\t\t  &nlris[i], 0);\n\t\t\tbreak;\n\t\tcase NLRI_WITHDRAW:\n\t\tcase NLRI_MP_WITHDRAW:\n\t\t\tnlri_ret = bgp_nlri_parse(peer, NLRI_ATTR_ARG,\n\t\t\t\t\t\t  &nlris[i], 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnlri_ret = BGP_NLRI_PARSE_ERROR;\n\t\t}\n\n\t\tif (nlri_ret < BGP_NLRI_PARSE_OK\n\t\t    && nlri_ret != BGP_NLRI_PARSE_ERROR_PREFIX_OVERFLOW) {\n\t\t\tflog_err(EC_BGP_UPDATE_RCV,\n\t\t\t\t \"%s [Error] Error parsing NLRI\", peer->host);\n\t\t\tif (peer_established(peer))\n\t\t\t\tbgp_notify_send(\n\t\t\t\t\tpeer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\t\ti <= NLRI_WITHDRAW\n\t\t\t\t\t\t? BGP_NOTIFY_UPDATE_INVAL_NETWORK\n\t\t\t\t\t\t: BGP_NOTIFY_UPDATE_OPT_ATTR_ERR);\n\t\t\tbgp_attr_unintern_sub(&attr);\n\t\t\treturn BGP_Stop;\n\t\t}\n\t}\n\n\t/* EoR checks\n\t *\n\t * Non-MP IPv4/Unicast EoR is a completely empty UPDATE\n\t * and MP EoR should have only an empty MP_UNREACH\n\t */\n\tif ((!update_len && !withdraw_len && nlris[NLRI_MP_UPDATE].length == 0)\n\t    || (attr_parse_ret == BGP_ATTR_PARSE_EOR)) {\n\t\tafi_t afi = 0;\n\t\tsafi_t safi;\n\t\tstruct graceful_restart_info *gr_info;\n\n\t\t/* Restarting router */\n\t\tif (BGP_PEER_GRACEFUL_RESTART_CAPABLE(peer)\n\t\t    && BGP_PEER_RESTARTING_MODE(peer))\n\t\t\trestart = true;\n\n\t\t/* Non-MP IPv4/Unicast is a completely emtpy UPDATE - already\n\t\t * checked\n\t\t * update and withdraw NLRI lengths are 0.\n\t\t */\n\t\tif (!attribute_len) {\n\t\t\tafi = AFI_IP;\n\t\t\tsafi = SAFI_UNICAST;\n\t\t} else if (attr.flag & ATTR_FLAG_BIT(BGP_ATTR_MP_UNREACH_NLRI)\n\t\t\t   && nlris[NLRI_MP_WITHDRAW].length == 0) {\n\t\t\tafi = nlris[NLRI_MP_WITHDRAW].afi;\n\t\t\tsafi = nlris[NLRI_MP_WITHDRAW].safi;\n\t\t} else if (attr_parse_ret == BGP_ATTR_PARSE_EOR) {\n\t\t\tafi = nlris[NLRI_MP_UPDATE].afi;\n\t\t\tsafi = nlris[NLRI_MP_UPDATE].safi;\n\t\t}\n\n\t\tif (afi && peer->afc[afi][safi]) {\n\t\t\tstruct vrf *vrf = vrf_lookup_by_id(peer->bgp->vrf_id);\n\n\t\t\t/* End-of-RIB received */\n\t\t\tif (!CHECK_FLAG(peer->af_sflags[afi][safi],\n\t\t\t\t\tPEER_STATUS_EOR_RECEIVED)) {\n\t\t\t\tSET_FLAG(peer->af_sflags[afi][safi],\n\t\t\t\t\t PEER_STATUS_EOR_RECEIVED);\n\t\t\t\tbgp_update_explicit_eors(peer);\n\t\t\t\t/* Update graceful restart information */\n\t\t\t\tgr_info = &(peer->bgp->gr_info[afi][safi]);\n\t\t\t\tif (restart)\n\t\t\t\t\tgr_info->eor_received++;\n\t\t\t\t/* If EOR received from all peers and selection\n\t\t\t\t * deferral timer is running, cancel the timer\n\t\t\t\t * and invoke the best path calculation\n\t\t\t\t */\n\t\t\t\tif (gr_info->eor_required\n\t\t\t\t    == gr_info->eor_received) {\n\t\t\t\t\tif (bgp_debug_neighbor_events(peer))\n\t\t\t\t\t\tzlog_debug(\n\t\t\t\t\t\t\t\"%s %d, %s %d\",\n\t\t\t\t\t\t\t\"EOR REQ\",\n\t\t\t\t\t\t\tgr_info->eor_required,\n\t\t\t\t\t\t\t\"EOR RCV\",\n\t\t\t\t\t\t\tgr_info->eor_received);\n\t\t\t\t\tif (gr_info->t_select_deferral) {\n\t\t\t\t\t\tvoid *info = EVENT_ARG(\n\t\t\t\t\t\t\tgr_info->t_select_deferral);\n\t\t\t\t\t\tXFREE(MTYPE_TMP, info);\n\t\t\t\t\t}\n\t\t\t\t\tEVENT_OFF(gr_info->t_select_deferral);\n\t\t\t\t\tgr_info->eor_required = 0;\n\t\t\t\t\tgr_info->eor_received = 0;\n\t\t\t\t\t/* Best path selection */\n\t\t\t\t\tbgp_best_path_select_defer(peer->bgp,\n\t\t\t\t\t\t\t\t   afi, safi);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* NSF delete stale route */\n\t\t\tif (peer->nsf[afi][safi])\n\t\t\t\tbgp_clear_stale_route(peer, afi, safi);\n\n\t\t\tzlog_info(\n\t\t\t\t\"%s: rcvd End-of-RIB for %s from %s in vrf %s\",\n\t\t\t\t__func__, get_afi_safi_str(afi, safi, false),\n\t\t\t\tpeer->host, vrf ? vrf->name : VRF_DEFAULT_NAME);\n\t\t}\n\t}\n\n\t/* Everything is done.  We unintern temporary structures which\n\t   interned in bgp_attr_parse(). */\n\tbgp_attr_unintern_sub(&attr);\n\n\tpeer->update_time = monotime(NULL);\n\n\t/* Notify BGP Conditional advertisement scanner process */\n\tpeer->advmap_table_change = true;\n\n\treturn Receive_UPDATE_message;\n}",
  "abstract_func": "static int bgp_update_receive(struct peer *peer, bgp_size_t VAR_0)\n{\n\tint VAR_1, VAR_2;\n\tuint8_t *VAR_3;\n\tstruct stream *VAR_4;\n\tstruct attr attr;\n\tbgp_size_t VAR_5;\n\tbgp_size_t VAR_6;\n\tbgp_size_t VAR_7;\n\tbool VAR_8 = false;\n\n\tenum NLRI_TYPES {\n\t\tVAR_9,\n\t\tVAR_10,\n\t\tVAR_11,\n\t\tVAR_12,\n\t\tVAR_13\n\t};\n\tstruct bgp_nlri VAR_14[VAR_13];\n\n\t/* COMMENT_0 */\n\tif (!peer_established(peer)) {\n\t\tflog_err(VAR_15,\n\t\t\t \"%s [FSM] Update packet received under status %s\",\n\t\t\t peer->host,\n\t\t\t lookup_msg(VAR_16, peer->connection->status,\n\t\t\t\t    NULL));\n\t\tbgp_notify_send(peer, VAR_17,\n\t\t\t\tbgp_fsm_error_subcode(peer->connection->status));\n\t\treturn VAR_18;\n\t}\n\n\t/* COMMENT_1 */\n\tmemset(&attr, 0, sizeof(attr));\n\tattr.label_index = VAR_19;\n\tattr.label = VAR_20;\n\tmemset(&VAR_14, 0, sizeof(VAR_14));\n\tmemset(peer->rcvd_attr_str, 0, VAR_21);\n\tpeer->rcvd_attr_printed = 0;\n\n\tVAR_4 = peer->curr;\n\tVAR_3 = stream_pnt(VAR_4) + VAR_0;\n\n\t/* COMMENT_2 */\n                                                                  \n                                                                     \n                                                   \n\tif (stream_pnt(VAR_4) + 2 > VAR_3) {\n\t\tflog_err(VAR_22,\n\t\t\t \"%s [Error] Update packet error (packet length is short for unfeasible length)\",\n\t\t\t peer->host);\n\t\tbgp_notify_send(peer, VAR_23,\n\t\t\t\tVAR_24);\n\t\treturn VAR_18;\n\t}\n\n\t/* COMMENT_6 */\n\tVAR_7 = stream_getw(VAR_4);\n\n\t/* COMMENT_7 */\n\tif (stream_pnt(VAR_4) + VAR_7 > VAR_3) {\n\t\tflog_err(VAR_22,\n\t\t\t \"%s [Error] Update packet error (packet unfeasible length overflow %d)\",\n\t\t\t peer->host, VAR_7);\n\t\tbgp_notify_send(peer, VAR_23,\n\t\t\t\tVAR_24);\n\t\treturn VAR_18;\n\t}\n\n\t/* COMMENT_8 */\n\tif (VAR_7 > 0) {\n\t\tVAR_14[VAR_10].afi = VAR_25;\n\t\tVAR_14[VAR_10].safi = VAR_26;\n\t\tVAR_14[VAR_10].nlri = stream_pnt(VAR_4);\n\t\tVAR_14[VAR_10].length = VAR_7;\n\t\tstream_forward_getp(VAR_4, VAR_7);\n\t}\n\n\t/* COMMENT_9 */\n\tif (stream_pnt(VAR_4) + 2 > VAR_3) {\n\t\tflog_warn(\n\t\t\tVAR_27,\n\t\t\t\"%s [Error] Packet Error (update packet is short for attribute length)\",\n\t\t\tpeer->host);\n\t\tbgp_notify_send(peer, VAR_23,\n\t\t\t\tVAR_24);\n\t\treturn VAR_18;\n\t}\n\n\t/* COMMENT_10 */\n\tVAR_5 = stream_getw(VAR_4);\n\n\t/* COMMENT_11 */\n\tif (stream_pnt(VAR_4) + VAR_5 > VAR_3) {\n\t\tflog_warn(\n\t\t\tVAR_28,\n\t\t\t\"%s [Error] Packet Error (update packet attribute length overflow %d)\",\n\t\t\tpeer->host, VAR_5);\n\t\tbgp_notify_send(peer, VAR_23,\n\t\t\t\tVAR_24);\n\t\treturn VAR_18;\n\t}\n\n\t/* COMMENT_12 */\n                                                                    \n                                                                       \n                                                        \n   \n                                          \n    \n\tenum bgp_attr_parse_ret VAR_29 = VAR_30;\n/* COMMENT_19 */\n                                                        \n   \n#define VAR_31 (attr_parse_ret != BGP_ATTR_PARSE_WITHDRAW ? &attr : NULL)\n\n\t/* COMMENT_22 */\n\tif (VAR_5) {\n\t\tVAR_29 = bgp_attr_parse(peer, &attr, VAR_5,\n\t\t\t\t\t\t&VAR_14[VAR_11],\n\t\t\t\t\t\t&VAR_14[VAR_12]);\n\t\tif (VAR_29 == VAR_32) {\n\t\t\tbgp_attr_unintern_sub(&attr);\n\t\t\treturn VAR_18;\n\t\t}\n\t}\n\n\t/* COMMENT_23 */\n\tif (VAR_29 == VAR_33\n\t    || BGP_DEBUG(VAR_34, VAR_35)\n\t    || BGP_DEBUG(VAR_34, VAR_36)) {\n\t\tVAR_1 = bgp_dump_attr(&attr, peer->rcvd_attr_str,\n\t\t\t\t    sizeof(peer->rcvd_attr_str));\n\n\t\tpeer->stat_upd_7606++;\n\n\t\tif (VAR_29 == VAR_33)\n\t\t\tflog_err(\n\t\t\t\tVAR_22,\n\t\t\t\t\"%pBP rcvd UPDATE with errors in attr(s)!! Withdrawing route.\",\n\t\t\t\tpeer);\n\n\t\tif (VAR_1 && bgp_debug_update(peer, NULL, NULL, 1)) {\n\t\t\tzlog_debug(\"%pBP rcvd UPDATE w/ attr: %s\", peer,\n\t\t\t\t   peer->rcvd_attr_str);\n\t\t\tpeer->rcvd_attr_printed = 1;\n\t\t}\n\t}\n\n\t/* COMMENT_24 */\n\tVAR_6 = VAR_3 - stream_pnt(VAR_4);\n\n\tif (VAR_6 && VAR_5) {\n\t\t/* COMMENT_25 */\n\t\tVAR_14[VAR_9].afi = VAR_25;\n\t\tVAR_14[VAR_9].safi = VAR_26;\n\t\tVAR_14[VAR_9].nlri = stream_pnt(VAR_4);\n\t\tVAR_14[VAR_9].length = VAR_6;\n\t\tstream_forward_getp(VAR_4, VAR_6);\n\n\t\tif (CHECK_FLAG(attr.flag, ATTR_FLAG_BIT(VAR_37))) {\n\t\t\t/* COMMENT_26 */\n                                                        \n                               \n      \n\t\t\tif (bgp_attr_nexthop_valid(peer, &attr) < 0) {\n\t\t\t\tbgp_attr_unintern_sub(&attr);\n\t\t\t\treturn VAR_18;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (BGP_DEBUG(VAR_34, VAR_35))\n\t\tzlog_debug(\"%pBP rcvd UPDATE wlen %d attrlen %d alen %d\", peer,\n\t\t\t   VAR_7, VAR_5, VAR_6);\n\n\t/* COMMENT_30 */\n\tfor (int VAR_38 = VAR_9; VAR_38 < VAR_13; VAR_38++) {\n\t\tif (!VAR_14[VAR_38].nlri)\n\t\t\tcontinue;\n\n\t\t/* COMMENT_31 */\n                \n\t\tif (!peer->afc[VAR_14[VAR_38].afi][VAR_14[VAR_38].safi]) {\n\t\t\tzlog_info(\n\t\t\t\t\"%s [Info] UPDATE for non-enabled AFI/SAFI %u/%u\",\n\t\t\t\tpeer->host, VAR_14[VAR_38].afi, VAR_14[VAR_38].safi);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* COMMENT_33 */\n\t\tif (VAR_14[VAR_38].length == 0)\n\t\t\tcontinue;\n\n\t\tswitch (VAR_38) {\n\t\tcase VAR_9:\n\t\tcase VAR_11:\n\t\t\tVAR_2 = bgp_nlri_parse(peer, VAR_31,\n\t\t\t\t\t\t  &VAR_14[VAR_38], 0);\n\t\t\tbreak;\n\t\tcase VAR_10:\n\t\tcase VAR_12:\n\t\t\tVAR_2 = bgp_nlri_parse(peer, VAR_31,\n\t\t\t\t\t\t  &VAR_14[VAR_38], 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tVAR_2 = VAR_39;\n\t\t}\n\n\t\tif (VAR_2 < VAR_40\n\t\t    && VAR_2 != VAR_41) {\n\t\t\tflog_err(VAR_22,\n\t\t\t\t \"%s [Error] Error parsing NLRI\", peer->host);\n\t\t\tif (peer_established(peer))\n\t\t\t\tbgp_notify_send(\n\t\t\t\t\tpeer, VAR_23,\n\t\t\t\t\tVAR_38 <= VAR_10\n\t\t\t\t\t\t? VAR_42\n\t\t\t\t\t\t: VAR_43);\n\t\t\tbgp_attr_unintern_sub(&attr);\n\t\t\treturn VAR_18;\n\t\t}\n\t}\n\n\t/* COMMENT_34 */\n   \n                                                        \n                                                   \n    \n\tif ((!VAR_6 && !VAR_7 && VAR_14[VAR_11].length == 0)\n\t    || (VAR_29 == VAR_44)) {\n\t\tafi_t VAR_45 = 0;\n\t\tsafi_t VAR_46;\n\t\tstruct graceful_restart_info *VAR_47;\n\n\t\t/* COMMENT_39 */\n\t\tif (BGP_PEER_GRACEFUL_RESTART_CAPABLE(peer)\n\t\t    && BGP_PEER_RESTARTING_MODE(peer))\n\t\t\tVAR_8 = true;\n\n\t\t/* COMMENT_40 */\n            \n                                            \n     \n\t\tif (!VAR_5) {\n\t\t\tVAR_45 = VAR_25;\n\t\t\tVAR_46 = VAR_26;\n\t\t} else if (attr.flag & ATTR_FLAG_BIT(VAR_48)\n\t\t\t   && VAR_14[VAR_12].length == 0) {\n\t\t\tVAR_45 = VAR_14[VAR_12].afi;\n\t\t\tVAR_46 = VAR_14[VAR_12].safi;\n\t\t} else if (VAR_29 == VAR_44) {\n\t\t\tVAR_45 = VAR_14[VAR_11].afi;\n\t\t\tVAR_46 = VAR_14[VAR_11].safi;\n\t\t}\n\n\t\tif (VAR_45 && peer->afc[VAR_45][VAR_46]) {\n\t\t\tstruct vrf *vrf = vrf_lookup_by_id(peer->bgp->vrf_id);\n\n\t\t\t/* COMMENT_44 */\n\t\t\tif (!CHECK_FLAG(peer->af_sflags[VAR_45][VAR_46],\n\t\t\t\t\tVAR_49)) {\n\t\t\t\tSET_FLAG(peer->af_sflags[VAR_45][VAR_46],\n\t\t\t\t\t VAR_49);\n\t\t\t\tbgp_update_explicit_eors(peer);\n\t\t\t\t/* COMMENT_45 */\n\t\t\t\tVAR_47 = &(peer->bgp->gr_info[VAR_45][VAR_46]);\n\t\t\t\tif (VAR_8)\n\t\t\t\t\tVAR_47->eor_received++;\n\t\t\t\t/* COMMENT_46 */\n                                                  \n                                           \n       \n\t\t\t\tif (VAR_47->eor_required\n\t\t\t\t    == VAR_47->eor_received) {\n\t\t\t\t\tif (bgp_debug_neighbor_events(peer))\n\t\t\t\t\t\tzlog_debug(\n\t\t\t\t\t\t\t\"%s %d, %s %d\",\n\t\t\t\t\t\t\t\"EOR REQ\",\n\t\t\t\t\t\t\tVAR_47->eor_required,\n\t\t\t\t\t\t\t\"EOR RCV\",\n\t\t\t\t\t\t\tVAR_47->eor_received);\n\t\t\t\t\tif (VAR_47->t_select_deferral) {\n\t\t\t\t\t\tvoid *VAR_50 = EVENT_ARG(\n\t\t\t\t\t\t\tVAR_47->t_select_deferral);\n\t\t\t\t\t\tXFREE(VAR_51, VAR_50);\n\t\t\t\t\t}\n\t\t\t\t\tEVENT_OFF(VAR_47->t_select_deferral);\n\t\t\t\t\tVAR_47->eor_required = 0;\n\t\t\t\t\tVAR_47->eor_received = 0;\n\t\t\t\t\t/* COMMENT_50 */\n\t\t\t\t\tbgp_best_path_select_defer(peer->bgp,\n\t\t\t\t\t\t\t\t   VAR_45, VAR_46);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* COMMENT_51 */\n\t\t\tif (peer->nsf[VAR_45][VAR_46])\n\t\t\t\tbgp_clear_stale_route(peer, VAR_45, VAR_46);\n\n\t\t\tzlog_info(\n\t\t\t\t\"%s: rcvd End-of-RIB for %s from %s in vrf %s\",\n\t\t\t\tVAR_52, get_afi_safi_str(VAR_45, VAR_46, false),\n\t\t\t\tpeer->host, vrf ? vrf->name : VAR_53);\n\t\t}\n\t}\n\n\t/* COMMENT_52 */\n                                    \n\tbgp_attr_unintern_sub(&attr);\n\n\tpeer->update_time = monotime(NULL);\n\n\t/* COMMENT_54 */\n\tpeer->advmap_table_change = true;\n\n\treturn VAR_54;\n}",
  "func_graph_path": "FRRouting/frr/28ccc24d38df1d51ed8a563507e5d6f6171fdd38/bgp_packet.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -150,7 +150,7 @@\n \t/* Network Layer Reachability Information. */\n \tupdate_len = end - stream_pnt(s);\n \n-\tif (update_len) {\n+\tif (update_len && attribute_len) {\n \t\t/* Set NLRI portion to structure. */\n \t\tnlris[NLRI_UPDATE].afi = AFI_IP;\n \t\tnlris[NLRI_UPDATE].safi = SAFI_UNICAST;",
  "diff_line_info": {
    "deleted_lines": [
      "\tif (update_len) {"
    ],
    "added_lines": [
      "\tif (update_len && attribute_len) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/FRRouting/frr/pull/14260",
  "description": {
    "pr_info": {
      "title": "bgpd: Do not process NLRIs if the attribute length is zero",
      "number": 14260
    },
    "comment": [
      "```\r\n3  0x00007f423aa42476 in __GI_raise (sig=sig@entry=11) at ../sysdeps/posix/raise.c:26\r\n4  0x00007f423aef9740 in core_handler (signo=11, siginfo=0x7fffc414deb0, context=<optimized out>) at lib/sigevent.c:246\r\n5  <signal handler called>\r\n6  0x0000564dea2fc71e in route_set_aspath_prepend (rule=0x564debd66d50, prefix=0x7fffc414ea30, object=0x7fffc414e400)\r\n    at bgpd/bgp_routemap.c:2258\r\n7  0x00007f423aeec7e0 in route_map_apply_ext (map=<optimized out>, prefix=prefix@entry=0x7fffc414ea30,\r\n    match_object=match_object@entry=0x7fffc414e400, set_object=set_object@entry=0x7fffc414e400, pref=pref@entry=0x0) at lib/routemap.c:2690\r\n8  0x0000564dea2d277e in bgp_input_modifier (peer=peer@entry=0x7f4238f59010, p=p@entry=0x7fffc414ea30, attr=attr@entry=0x7fffc414e770,\r\n    afi=afi@entry=AFI_IP, safi=safi@entry=SAFI_UNICAST, rmap_name=rmap_name@entry=0x0, label=0x0, num_labels=0, dest=0x564debdd5130)\r\n    at bgpd/bgp_route.c:1772\r\n9  0x0000564dea2df762 in bgp_update (peer=peer@entry=0x7f4238f59010, p=p@entry=0x7fffc414ea30, addpath_id=addpath_id@entry=0,\r\n    attr=0x7fffc414eb50, afi=afi@entry=AFI_IP, safi=<optimized out>, safi@entry=SAFI_UNICAST, type=9, sub_type=0, prd=0x0, label=0x0,\r\n    num_labels=0, soft_reconfig=0, evpn=0x0) at bgpd/bgp_route.c:4374\r\n10 0x0000564dea2e2047 in bgp_nlri_parse_ip (peer=0x7f4238f59010, attr=attr@entry=0x7fffc414eb50, packet=0x7fffc414eaf0)\r\n    at bgpd/bgp_route.c:6249\r\n11 0x0000564dea2c5a58 in bgp_nlri_parse (peer=peer@entry=0x7f4238f59010, attr=attr@entry=0x7fffc414eb50,\r\n    packet=packet@entry=0x7fffc414eaf0, mp_withdraw=mp_withdraw@entry=false) at bgpd/bgp_packet.c:339\r\n12 0x0000564dea2c5d66 in bgp_update_receive (peer=peer@entry=0x7f4238f59010, size=size@entry=109) at bgpd/bgp_packet.c:2024\r\n13 0x0000564dea2c901d in bgp_process_packet (thread=<optimized out>) at bgpd/bgp_packet.c:2933\r\n14 0x00007f423af0bf71 in event_call (thread=thread@entry=0x7fffc414ee40) at lib/event.c:1995\r\n15 0x00007f423aebb198 in frr_run (master=0x564deb73c670) at lib/libfrr.c:1213\r\n16 0x0000564dea261b83 in main (argc=<optimized out>, argv=<optimized out>) at bgpd/bgp_main.c:505\r\n```\r\n\r\nWith the configuration:\r\n\r\n```\r\nfrr version 9.1-dev-MyOwnFRRVersion\r\nfrr defaults traditional\r\nhostname ip-172-31-13-140\r\nlog file /tmp/debug.log\r\nlog syslog\r\nservice integrated-vtysh-config\r\n!\r\ndebug bgp keepalives\r\ndebug bgp neighbor-events\r\ndebug bgp updates in\r\ndebug bgp updates out\r\n!\r\nrouter bgp 100\r\n bgp router-id 9.9.9.9\r\n no bgp ebgp-requires-policy\r\n bgp bestpath aigp\r\n neighbor 172.31.2.47 remote-as 200\r\n !\r\n address-family ipv4 unicast\r\n  neighbor 172.31.2.47 default-originate\r\n  neighbor 172.31.2.47 route-map RM_IN in\r\n exit-address-family\r\nexit\r\n!\r\nroute-map RM_IN permit 10\r\n set as-path prepend 200\r\nexit\r\n!\r\n```\r\n\r\nThe issue is that we try to process NLRIs even if the attribute length is 0.\r\n\r\nLater bgp_update() will handle route-maps and a crash occurs because all the attributes are NULL, including aspath, where we dereference.\r\n\r\nAccording to the RFC 4271:\r\n\r\nA value of 0 indicates that neither the Network Layer\r\n         Reachability Information field nor the Path Attribute field is\r\n         present in this UPDATE message.\r\n\r\nBut with a fuzzed UPDATE message this can be faked. I think it's reasonable to skip processing NLRIs if both update_len and attribute_len are 0.\r\n\r\nReported-by: Iggy Frankovic <iggyfran@amazon.com>",
      "# Continuous Integration Result: SUCCESSFUL\n\nCongratulations, this patch passed basic tests\n\nTested-by: NetDEF / OpenSourceRouting.org CI System\n\nCI System Testrun URL: https://ci1.netdef.org/browse/FRR-PULLREQ2-13741/\n\nThis is a comment from an automated CI system.\nFor questions and feedback in regards to this CI system, please feel free to email\nMartin Winter - mwinter (at) opensourcerouting.org.\n\n\n",
      "@Mergifyio backport stable/9.0 stable/8.5",
      "> backport stable/9.0 stable/8.5\n\n#### ✅ Backports have been created\n\n<details>\n\n* [#14269 bgpd: Do not process NLRIs if the attribute length is zero (backport #14260)](https://github.com/FRRouting/frr/pull/14269) has been created for branch `stable/9.0`\n* [#14270 bgpd: Do not process NLRIs if the attribute length is zero (backport #14260)](https://github.com/FRRouting/frr/pull/14270) has been created for branch `stable/8.5`\n\n</details>\n\n\n<!---\nDO NOT EDIT\n-*- Mergify Payload -*-\n{\"command\": \"backport stable/9.0 stable/8.5\", \"conclusion\": \"success\", \"action_is_running\": true}\n-*- Mergify Payload End -*-\n-->",
      "@Mergifyio backport stable/8.4",
      "> backport stable/8.4\n\n#### ✅ Backports have been created\n\n<details>\n\n* [#15931 bgpd: Do not process NLRIs if the attribute length is zero (backport #14260)](https://github.com/FRRouting/frr/pull/15931) has been created for branch `stable/8.4`\n\n</details>\n\n\n<!---\nDO NOT EDIT\n-*- Mergify Payload -*-\n{\"command\": \"backport stable/8.4\", \"conclusion\": \"success\", \"action_is_running\": true}\n-*- Mergify Payload End -*-\n-->"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix\n\nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses a security vulnerability where processing NLRIs with zero attribute length causes a crash. The fix prevents unauthorized access by skipping such processing.\n\nFinal Classification: Security Vulnerability Fix\n\nConfidence Score: 0.95"
}