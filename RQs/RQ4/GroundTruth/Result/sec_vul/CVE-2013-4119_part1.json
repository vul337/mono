{
  "cve_id": "CVE-2013-4119",
  "cwe_ids": [
    "CWE-476"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "FreeRDP",
  "commit_msg": "nla: invalidate sec handle after creation\n\nIf sec pointer isn't invalidated after creation it is not possible\nto check if the upper and lower pointers are valid.\n\nThis fixes a segfault in the server part if the client disconnects before\nthe authentication was finished.",
  "commit_hash": "0773bb9303d24473fe1185d85a424dfe159aff53",
  "git_url": "https://github.com/FreeRDP/FreeRDP/commit/0773bb9303d24473fe1185d85a424dfe159aff53",
  "file_path": "libfreerdp/core/peer.c",
  "func_name": "peer_recv_callback",
  "func_before": "static int peer_recv_callback(rdpTransport* transport, wStream* s, void* extra)\n{\n\tfreerdp_peer* client = (freerdp_peer*) extra;\n\trdpRdp* rdp = client->context->rdp;\n\n\tswitch (rdp->state)\n\t{\n\t\tcase CONNECTION_STATE_INITIAL:\n\t\t\tif (!rdp_server_accept_nego(rdp, s))\n\t\t\t\treturn -1;\n\n\t\t\tif (rdp->nego->selected_protocol & PROTOCOL_NLA)\n\t\t\t{\n\t\t\t\tsspi_CopyAuthIdentity(&client->identity, &(rdp->nego->transport->credssp->identity));\n\t\t\t\tIFCALLRET(client->Logon, client->authenticated, client, &client->identity, TRUE);\n\t\t\t\tcredssp_free(rdp->nego->transport->credssp);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tIFCALLRET(client->Logon, client->authenticated, client, &client->identity, FALSE);\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_NEGO:\n\t\t\tif (!rdp_server_accept_mcs_connect_initial(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_CONNECT:\n\t\t\tif (!rdp_server_accept_mcs_erect_domain_request(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_ERECT_DOMAIN:\n\t\t\tif (!rdp_server_accept_mcs_attach_user_request(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_ATTACH_USER:\n\t\t\tif (!rdp_server_accept_mcs_channel_join_request(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_CHANNEL_JOIN:\n\t\t\tif (rdp->settings->DisableEncryption)\n\t\t\t{\n\t\t\t\tif (!rdp_server_accept_client_keys(rdp, s))\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trdp->state = CONNECTION_STATE_ESTABLISH_KEYS;\n\t\t\t/* FALLTHROUGH */\n\n\t\tcase CONNECTION_STATE_ESTABLISH_KEYS:\n\t\t\tif (!rdp_server_accept_client_info(rdp, s))\n\t\t\t\treturn -1;\n\n\t\t\tIFCALL(client->Capabilities, client);\n\n\t\t\tif (!rdp_send_demand_active(rdp))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_LICENSE:\n\t\t\tif (!rdp_server_accept_confirm_active(rdp, s))\n\t\t\t{\n\t\t\t\t/**\n\t\t\t\t * During reactivation sequence the client might sent some input or channel data\n\t\t\t\t * before receiving the Deactivate All PDU. We need to process them as usual.\n\t\t\t\t */\n\t\t\t\tStream_SetPosition(s, 0);\n\t\t\t\treturn peer_recv_pdu(client, s);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_ACTIVE:\n\t\t\tif (peer_recv_pdu(client, s) < 0)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Invalid state %d\\n\", rdp->state);\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
  "abstract_func_before": "static int peer_recv_callback(rdpTransport* VAR_0, wStream* VAR_1, void* VAR_2)\n{\n\tfreerdp_peer* VAR_3 = (freerdp_peer*) VAR_2;\n\trdpRdp* VAR_4 = VAR_3->context->rdp;\n\n\tswitch (VAR_4->state)\n\t{\n\t\tcase VAR_5:\n\t\t\tif (!rdp_server_accept_nego(VAR_4, VAR_1))\n\t\t\t\treturn -1;\n\n\t\t\tif (VAR_4->nego->selected_protocol & VAR_6)\n\t\t\t{\n\t\t\t\tsspi_CopyAuthIdentity(&VAR_3->identity, &(VAR_4->nego->transport->credssp->identity));\n\t\t\t\tIFCALLRET(VAR_3->Logon, VAR_3->authenticated, VAR_3, &VAR_3->identity, TRUE);\n\t\t\t\tcredssp_free(VAR_4->nego->transport->credssp);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tIFCALLRET(VAR_3->Logon, VAR_3->authenticated, VAR_3, &VAR_3->identity, FALSE);\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase VAR_7:\n\t\t\tif (!rdp_server_accept_mcs_connect_initial(VAR_4, VAR_1))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase VAR_8:\n\t\t\tif (!rdp_server_accept_mcs_erect_domain_request(VAR_4, VAR_1))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase VAR_9:\n\t\t\tif (!rdp_server_accept_mcs_attach_user_request(VAR_4, VAR_1))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase VAR_10:\n\t\t\tif (!rdp_server_accept_mcs_channel_join_request(VAR_4, VAR_1))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase VAR_11:\n\t\t\tif (VAR_4->settings->DisableEncryption)\n\t\t\t{\n\t\t\t\tif (!rdp_server_accept_client_keys(VAR_4, VAR_1))\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tVAR_4->state = VAR_12;\n\t\t\t/* COMMENT_0 */\n\n\t\tcase VAR_12:\n\t\t\tif (!rdp_server_accept_client_info(VAR_4, VAR_1))\n\t\t\t\treturn -1;\n\n\t\t\tIFCALL(VAR_3->Capabilities, VAR_3);\n\n\t\t\tif (!rdp_send_demand_active(VAR_4))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase VAR_13:\n\t\t\tif (!rdp_server_accept_confirm_active(VAR_4, VAR_1))\n\t\t\t{\n\t\t\t\t/* COMMENT_1 */\n                                                                                    \n                                                                                 \n       \n\t\t\t\tStream_SetPosition(VAR_1, 0);\n\t\t\t\treturn peer_recv_pdu(VAR_3, VAR_1);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase VAR_14:\n\t\t\tif (peer_recv_pdu(VAR_3, VAR_1) < 0)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfprintf(VAR_15, \"Invalid state %d\\n\", VAR_4->state);\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
  "func_graph_path_before": "FreeRDP/0773bb9303d24473fe1185d85a424dfe159aff53/peer.c/vul/before/0.json",
  "func": "static int peer_recv_callback(rdpTransport* transport, wStream* s, void* extra)\n{\n\tfreerdp_peer* client = (freerdp_peer*) extra;\n\trdpRdp* rdp = client->context->rdp;\n\n\tswitch (rdp->state)\n\t{\n\t\tcase CONNECTION_STATE_INITIAL:\n\t\t\tif (!rdp_server_accept_nego(rdp, s))\n\t\t\t\treturn -1;\n\n\t\t\tif (rdp->nego->selected_protocol & PROTOCOL_NLA)\n\t\t\t{\n\t\t\t\tsspi_CopyAuthIdentity(&client->identity, &(rdp->nego->transport->credssp->identity));\n\t\t\t\tIFCALLRET(client->Logon, client->authenticated, client, &client->identity, TRUE);\n\t\t\t\tcredssp_free(rdp->nego->transport->credssp);\n\t\t\t\trdp->nego->transport->credssp = NULL;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tIFCALLRET(client->Logon, client->authenticated, client, &client->identity, FALSE);\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_NEGO:\n\t\t\tif (!rdp_server_accept_mcs_connect_initial(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_CONNECT:\n\t\t\tif (!rdp_server_accept_mcs_erect_domain_request(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_ERECT_DOMAIN:\n\t\t\tif (!rdp_server_accept_mcs_attach_user_request(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_ATTACH_USER:\n\t\t\tif (!rdp_server_accept_mcs_channel_join_request(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_CHANNEL_JOIN:\n\t\t\tif (rdp->settings->DisableEncryption)\n\t\t\t{\n\t\t\t\tif (!rdp_server_accept_client_keys(rdp, s))\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trdp->state = CONNECTION_STATE_ESTABLISH_KEYS;\n\t\t\t/* FALLTHROUGH */\n\n\t\tcase CONNECTION_STATE_ESTABLISH_KEYS:\n\t\t\tif (!rdp_server_accept_client_info(rdp, s))\n\t\t\t\treturn -1;\n\n\t\t\tIFCALL(client->Capabilities, client);\n\n\t\t\tif (!rdp_send_demand_active(rdp))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_LICENSE:\n\t\t\tif (!rdp_server_accept_confirm_active(rdp, s))\n\t\t\t{\n\t\t\t\t/**\n\t\t\t\t * During reactivation sequence the client might sent some input or channel data\n\t\t\t\t * before receiving the Deactivate All PDU. We need to process them as usual.\n\t\t\t\t */\n\t\t\t\tStream_SetPosition(s, 0);\n\t\t\t\treturn peer_recv_pdu(client, s);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_ACTIVE:\n\t\t\tif (peer_recv_pdu(client, s) < 0)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Invalid state %d\\n\", rdp->state);\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
  "abstract_func": "static int peer_recv_callback(rdpTransport* VAR_0, wStream* VAR_1, void* VAR_2)\n{\n\tfreerdp_peer* VAR_3 = (freerdp_peer*) VAR_2;\n\trdpRdp* VAR_4 = VAR_3->context->rdp;\n\n\tswitch (VAR_4->state)\n\t{\n\t\tcase VAR_5:\n\t\t\tif (!rdp_server_accept_nego(VAR_4, VAR_1))\n\t\t\t\treturn -1;\n\n\t\t\tif (VAR_4->nego->selected_protocol & VAR_6)\n\t\t\t{\n\t\t\t\tsspi_CopyAuthIdentity(&VAR_3->identity, &(VAR_4->nego->transport->credssp->identity));\n\t\t\t\tIFCALLRET(VAR_3->Logon, VAR_3->authenticated, VAR_3, &VAR_3->identity, TRUE);\n\t\t\t\tcredssp_free(VAR_4->nego->transport->credssp);\n\t\t\t\tVAR_4->nego->transport->credssp = NULL;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tIFCALLRET(VAR_3->Logon, VAR_3->authenticated, VAR_3, &VAR_3->identity, FALSE);\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase VAR_7:\n\t\t\tif (!rdp_server_accept_mcs_connect_initial(VAR_4, VAR_1))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase VAR_8:\n\t\t\tif (!rdp_server_accept_mcs_erect_domain_request(VAR_4, VAR_1))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase VAR_9:\n\t\t\tif (!rdp_server_accept_mcs_attach_user_request(VAR_4, VAR_1))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase VAR_10:\n\t\t\tif (!rdp_server_accept_mcs_channel_join_request(VAR_4, VAR_1))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase VAR_11:\n\t\t\tif (VAR_4->settings->DisableEncryption)\n\t\t\t{\n\t\t\t\tif (!rdp_server_accept_client_keys(VAR_4, VAR_1))\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tVAR_4->state = VAR_12;\n\t\t\t/* COMMENT_0 */\n\n\t\tcase VAR_12:\n\t\t\tif (!rdp_server_accept_client_info(VAR_4, VAR_1))\n\t\t\t\treturn -1;\n\n\t\t\tIFCALL(VAR_3->Capabilities, VAR_3);\n\n\t\t\tif (!rdp_send_demand_active(VAR_4))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase VAR_13:\n\t\t\tif (!rdp_server_accept_confirm_active(VAR_4, VAR_1))\n\t\t\t{\n\t\t\t\t/* COMMENT_1 */\n                                                                                    \n                                                                                 \n       \n\t\t\t\tStream_SetPosition(VAR_1, 0);\n\t\t\t\treturn peer_recv_pdu(VAR_3, VAR_1);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase VAR_14:\n\t\t\tif (peer_recv_pdu(VAR_3, VAR_1) < 0)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfprintf(VAR_15, \"Invalid state %d\\n\", VAR_4->state);\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
  "func_graph_path": "FreeRDP/0773bb9303d24473fe1185d85a424dfe159aff53/peer.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -14,6 +14,7 @@\n \t\t\t\tsspi_CopyAuthIdentity(&client->identity, &(rdp->nego->transport->credssp->identity));\n \t\t\t\tIFCALLRET(client->Logon, client->authenticated, client, &client->identity, TRUE);\n \t\t\t\tcredssp_free(rdp->nego->transport->credssp);\n+\t\t\t\trdp->nego->transport->credssp = NULL;\n \t\t\t}\n \t\t\telse\n \t\t\t{",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "\t\t\t\trdp->nego->transport->credssp = NULL;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/FreeRDP/FreeRDP/pull/1330",
  "description": {
    "pr_info": {
      "title": "Misc fixes",
      "number": 1330
    },
    "comment": [
      "- updated certificate mismatch messages properly fixes #1043\n- fixed a server side segfault if client disconnects before authentication was finished\n",
      "Test PASSed.\nRefer to this link for build results: https://ci.freerdp.com/job/Github%20pull%20request%20tester/140/\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 0.8",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "\n\nThe patch addresses a segfault caused by a dangling pointer in the server, which could be exploited to cause a denial of service. The code change nullifies the pointer after freeing it, preventing the crash. This is classified as a security vulnerability fix.\n\n**Final Output:**\nAnalysis: The patch fixes a segfault by nullifying a pointer after freeing it, preventing a potential DoS attack.  \nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 0.8"
}