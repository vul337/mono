{
  "cve_id": "CVE-2022-4639",
  "cwe_ids": [
    "CWE-134"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "yrutschle/sslh",
  "commit_msg": "fix possible format string exploit if packet dumping enabled\n\nSigned-off-by: Toni Uhlig <matzeton@googlemail.com>",
  "commit_hash": "b19f8a6046b080e4c2e28354a58556bb26040c6f",
  "git_url": "https://github.com/yrutschle/sslh/commit/b19f8a6046b080e4c2e28354a58556bb26040c6f",
  "file_path": "probe.c",
  "func_name": "hexdump",
  "func_before": "void hexdump(msg_info msg_info, const char *mem, unsigned int len)\n{\n    unsigned int i, j;\n    char str[10 + HEXDUMP_COLS * 4 + 2];\n    int c = 0; /* index in str */\n\n    for(i = 0; i < len + ((len % HEXDUMP_COLS) ? (HEXDUMP_COLS - len % HEXDUMP_COLS) : 0); i++)\n    {\n        /* print offset */\n        if(i % HEXDUMP_COLS == 0)\n            c += sprintf(&str[c], \"0x%06x: \", i);\n\n        /* print hex data */\n        if(i < len)\n            c += sprintf(&str[c], \"%02x \", 0xFF & mem[i]);\n        else /* end of block, just aligning for ASCII dump */\n            c+= sprintf(&str[c], \"   \");\n\n        /* print ASCII dump */\n        if(i % HEXDUMP_COLS == (HEXDUMP_COLS - 1)) {\n            for(j = i - (HEXDUMP_COLS - 1); j <= i; j++) {\n                if(j >= len) /* end of block, not really printing */\n                    str[c++] = ' ';\n                else if(isprint(mem[j])) /* printable char */\n                    str[c++] = 0xFF & mem[j];\n                else /* other char */\n                    str[c++] = '.';\n            }\n            str[c++] = '\\n';\n            str[c++] = 0;\n            print_message(msg_info, str);\n            c = 0;\n        }\n    }\n}",
  "abstract_func_before": "void hexdump(msg_info msg_info, const char *VAR_0, unsigned int VAR_1)\n{\n    unsigned int VAR_2, VAR_3;\n    char VAR_4[10 + VAR_5 * 4 + 2];\n    int VAR_6 = 0; /* COMMENT_0 */\n\n    for(VAR_2 = 0; VAR_2 < VAR_1 + ((VAR_1 % VAR_5) ? (VAR_5 - VAR_1 % VAR_5) : 0); VAR_2++)\n    {\n        /* COMMENT_1 */\n        if(VAR_2 % VAR_5 == 0)\n            VAR_6 += sprintf(&VAR_4[VAR_6], \"0x%06x: \", VAR_2);\n\n        /* COMMENT_2 */\n        if(VAR_2 < VAR_1)\n            VAR_6 += sprintf(&VAR_4[VAR_6], \"%02x \", 0xFF & VAR_0[VAR_2]);\n        else /* COMMENT_3 */\n            VAR_6+= sprintf(&VAR_4[VAR_6], \"   \");\n\n        /* COMMENT_4 */\n        if(VAR_2 % VAR_5 == (VAR_5 - 1)) {\n            for(VAR_3 = VAR_2 - (VAR_5 - 1); VAR_3 <= VAR_2; VAR_3++) {\n                if(VAR_3 >= VAR_1) /* COMMENT_5 */\n                    VAR_4[VAR_6++] = ' ';\n                else if(isprint(VAR_0[VAR_3])) /* COMMENT_6 */\n                    VAR_4[VAR_6++] = 0xFF & VAR_0[VAR_3];\n                else /* COMMENT_7 */\n                    VAR_4[VAR_6++] = '.';\n            }\n            VAR_4[VAR_6++] = '\\n';\n            VAR_4[VAR_6++] = 0;\n            print_message(msg_info, VAR_4);\n            VAR_6 = 0;\n        }\n    }\n}",
  "func_graph_path_before": "yrutschle/sslh/b19f8a6046b080e4c2e28354a58556bb26040c6f/probe.c/vul/before/0.json",
  "func": "void hexdump(msg_info msg_info, const char *mem, unsigned int len)\n{\n    unsigned int i, j;\n    char str[10 + HEXDUMP_COLS * 4 + 2];\n    int c = 0; /* index in str */\n\n    for(i = 0; i < len + ((len % HEXDUMP_COLS) ? (HEXDUMP_COLS - len % HEXDUMP_COLS) : 0); i++)\n    {\n        /* print offset */\n        if(i % HEXDUMP_COLS == 0)\n            c += sprintf(&str[c], \"0x%06x: \", i);\n\n        /* print hex data */\n        if(i < len)\n            c += sprintf(&str[c], \"%02x \", 0xFF & mem[i]);\n        else /* end of block, just aligning for ASCII dump */\n            c+= sprintf(&str[c], \"   \");\n\n        /* print ASCII dump */\n        if(i % HEXDUMP_COLS == (HEXDUMP_COLS - 1)) {\n            for(j = i - (HEXDUMP_COLS - 1); j <= i; j++) {\n                if(j >= len) /* end of block, not really printing */\n                    str[c++] = ' ';\n                else if(isprint(mem[j])) /* printable char */\n                    str[c++] = 0xFF & mem[j];\n                else /* other char */\n                    str[c++] = '.';\n            }\n            str[c++] = '\\n';\n            str[c++] = 0;\n            print_message(msg_info, \"%s\", str);\n            c = 0;\n        }\n    }\n}",
  "abstract_func": "void hexdump(msg_info msg_info, const char *VAR_0, unsigned int VAR_1)\n{\n    unsigned int VAR_2, VAR_3;\n    char VAR_4[10 + VAR_5 * 4 + 2];\n    int VAR_6 = 0; /* COMMENT_0 */\n\n    for(VAR_2 = 0; VAR_2 < VAR_1 + ((VAR_1 % VAR_5) ? (VAR_5 - VAR_1 % VAR_5) : 0); VAR_2++)\n    {\n        /* COMMENT_1 */\n        if(VAR_2 % VAR_5 == 0)\n            VAR_6 += sprintf(&VAR_4[VAR_6], \"0x%06x: \", VAR_2);\n\n        /* COMMENT_2 */\n        if(VAR_2 < VAR_1)\n            VAR_6 += sprintf(&VAR_4[VAR_6], \"%02x \", 0xFF & VAR_0[VAR_2]);\n        else /* COMMENT_3 */\n            VAR_6+= sprintf(&VAR_4[VAR_6], \"   \");\n\n        /* COMMENT_4 */\n        if(VAR_2 % VAR_5 == (VAR_5 - 1)) {\n            for(VAR_3 = VAR_2 - (VAR_5 - 1); VAR_3 <= VAR_2; VAR_3++) {\n                if(VAR_3 >= VAR_1) /* COMMENT_5 */\n                    VAR_4[VAR_6++] = ' ';\n                else if(isprint(VAR_0[VAR_3])) /* COMMENT_6 */\n                    VAR_4[VAR_6++] = 0xFF & VAR_0[VAR_3];\n                else /* COMMENT_7 */\n                    VAR_4[VAR_6++] = '.';\n            }\n            VAR_4[VAR_6++] = '\\n';\n            VAR_4[VAR_6++] = 0;\n            print_message(msg_info, \"%s\", VAR_4);\n            VAR_6 = 0;\n        }\n    }\n}",
  "func_graph_path": "yrutschle/sslh/b19f8a6046b080e4c2e28354a58556bb26040c6f/probe.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -28,7 +28,7 @@\n             }\n             str[c++] = '\\n';\n             str[c++] = 0;\n-            print_message(msg_info, str);\n+            print_message(msg_info, \"%s\", str);\n             c = 0;\n         }\n     }",
  "diff_line_info": {
    "deleted_lines": [
      "            print_message(msg_info, str);"
    ],
    "added_lines": [
      "            print_message(msg_info, \"%s\", str);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/yrutschle/sslh/pull/353",
  "description": {
    "pr_info": {
      "title": "fix possible format str vuln",
      "number": 353
    },
    "comment": [
      "This can happen if the packet which get's dumped contains ascii characters like %s,%c,%p,...",
      "thanks for the fix!",
      "Apparently this got assigned [CVE-2022-4639](https://vuldb.com/?id.216497) even though no stable version is affected. Only the release candidate v2.0-rc1 contains the code introduced in https://github.com/yrutschle/sslh/commit/e5f16b93ce9686e54c65c0955bbab6e74becf318.",
      "Thanks for the heads-up. I don't know how to feel about sslh's first CVE...\r\nI'll release a rc2 with the fix (I want to further investigaute https://github.com/yrutschle/sslh/issues/368 before producing an actual release)",
      "Here, it's tagged and published!\r\nhttps://lists.rutschle.net/mailman/archives/sslh/2022-December/000753.html\r\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix\n\nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses a potential format string exploit by modifying how print_message is called, ensuring str is treated as a string without format specifiers, thus preventing security risks.\n\nFinal Classification: Security Vulnerability Fix\n\nConfidence Score: 1.0"
}