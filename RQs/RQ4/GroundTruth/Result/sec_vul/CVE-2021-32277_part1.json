{
  "cve_id": "CVE-2021-32277",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "knik0/faad2",
  "commit_msg": "Restrict SBR frame length to 960 and 1024 samples.\n\nFixes #59 and #60.",
  "commit_hash": "c78251b2b5d41ea840fd61ab9502b3d3036bd747",
  "git_url": "https://github.com/knik0/faad2/commit/c78251b2b5d41ea840fd61ab9502b3d3036bd747",
  "file_path": "libfaad/specrec.c",
  "func_name": "reconstruct_channel_pair",
  "func_before": "uint8_t reconstruct_channel_pair(NeAACDecStruct *hDecoder, ic_stream *ics1, ic_stream *ics2,\n                                 element *cpe, int16_t *spec_data1, int16_t *spec_data2)\n{\n    uint8_t retval;\n    ALIGN real_t spec_coef1[1024];\n    ALIGN real_t spec_coef2[1024];\n\n#ifdef PROFILE\n    int64_t count = faad_get_ts();\n#endif\n    if (hDecoder->element_alloced[hDecoder->fr_ch_ele] != 2)\n    {\n        retval = allocate_channel_pair(hDecoder, cpe->channel, (uint8_t)cpe->paired_channel);\n        if (retval > 0)\n            return retval;\n\n        hDecoder->element_alloced[hDecoder->fr_ch_ele] = 2;\n    }\n\n    /* sanity check, CVE-2018-20199, CVE-2018-20360 */\n    if(!hDecoder->time_out[cpe->channel])\n        return 15;\n\n    /* dequantisation and scaling */\n    retval = quant_to_spec(hDecoder, ics1, spec_data1, spec_coef1, hDecoder->frameLength);\n    if (retval > 0)\n        return retval;\n    retval = quant_to_spec(hDecoder, ics2, spec_data2, spec_coef2, hDecoder->frameLength);\n    if (retval > 0)\n        return retval;\n\n#ifdef PROFILE\n    count = faad_get_ts() - count;\n    hDecoder->requant_cycles += count;\n#endif\n\n    /* pns decoding */\n    if (ics1->ms_mask_present)\n    {\n        pns_decode(ics1, ics2, spec_coef1, spec_coef2, hDecoder->frameLength, 1, hDecoder->object_type,\n            &(hDecoder->__r1), &(hDecoder->__r2));\n    } else {\n        pns_decode(ics1, ics2, spec_coef1, spec_coef2, hDecoder->frameLength, 0, hDecoder->object_type,\n            &(hDecoder->__r1), &(hDecoder->__r2));\n    }\n\n    /* mid/side decoding */\n    ms_decode(ics1, ics2, spec_coef1, spec_coef2, hDecoder->frameLength);\n\n#if 0\n    {\n        int i;\n        for (i = 0; i < 1024; i++)\n        {\n            //printf(\"%d\\n\", spec_coef1[i]);\n            printf(\"0x%.8X\\n\", spec_coef1[i]);\n        }\n        for (i = 0; i < 1024; i++)\n        {\n            //printf(\"%d\\n\", spec_coef2[i]);\n            printf(\"0x%.8X\\n\", spec_coef2[i]);\n        }\n    }\n#endif\n\n    /* intensity stereo decoding */\n    is_decode(ics1, ics2, spec_coef1, spec_coef2, hDecoder->frameLength);\n\n#if 0\n    {\n        int i;\n        for (i = 0; i < 1024; i++)\n        {\n            printf(\"%d\\n\", spec_coef1[i]);\n            //printf(\"0x%.8X\\n\", spec_coef1[i]);\n        }\n        for (i = 0; i < 1024; i++)\n        {\n            printf(\"%d\\n\", spec_coef2[i]);\n            //printf(\"0x%.8X\\n\", spec_coef2[i]);\n        }\n    }\n#endif\n\n#ifdef MAIN_DEC\n    /* MAIN object type prediction */\n    if (hDecoder->object_type == MAIN)\n    {\n        /* intra channel prediction */\n        ic_prediction(ics1, spec_coef1, hDecoder->pred_stat[cpe->channel], hDecoder->frameLength,\n            hDecoder->sf_index);\n        ic_prediction(ics2, spec_coef2, hDecoder->pred_stat[cpe->paired_channel], hDecoder->frameLength,\n            hDecoder->sf_index);\n\n        /* In addition, for scalefactor bands coded by perceptual\n           noise substitution the predictors belonging to the\n           corresponding spectral coefficients are reset.\n        */\n        pns_reset_pred_state(ics1, hDecoder->pred_stat[cpe->channel]);\n        pns_reset_pred_state(ics2, hDecoder->pred_stat[cpe->paired_channel]);\n    }\n#endif\n\n#ifdef LTP_DEC\n    if (is_ltp_ot(hDecoder->object_type))\n    {\n        ltp_info *ltp1 = &(ics1->ltp);\n        ltp_info *ltp2 = (cpe->common_window) ? &(ics2->ltp2) : &(ics2->ltp);\n#ifdef LD_DEC\n        if (hDecoder->object_type == LD)\n        {\n            if (ltp1->data_present)\n            {\n                if (ltp1->lag_update)\n                    hDecoder->ltp_lag[cpe->channel] = ltp1->lag;\n            }\n            ltp1->lag = hDecoder->ltp_lag[cpe->channel];\n            if (ltp2->data_present)\n            {\n                if (ltp2->lag_update)\n                    hDecoder->ltp_lag[cpe->paired_channel] = ltp2->lag;\n            }\n            ltp2->lag = hDecoder->ltp_lag[cpe->paired_channel];\n        }\n#endif\n\n        /* long term prediction */\n        lt_prediction(ics1, ltp1, spec_coef1, hDecoder->lt_pred_stat[cpe->channel], hDecoder->fb,\n            ics1->window_shape, hDecoder->window_shape_prev[cpe->channel],\n            hDecoder->sf_index, hDecoder->object_type, hDecoder->frameLength);\n        lt_prediction(ics2, ltp2, spec_coef2, hDecoder->lt_pred_stat[cpe->paired_channel], hDecoder->fb,\n            ics2->window_shape, hDecoder->window_shape_prev[cpe->paired_channel],\n            hDecoder->sf_index, hDecoder->object_type, hDecoder->frameLength);\n    }\n#endif\n\n    /* tns decoding */\n    tns_decode_frame(ics1, &(ics1->tns), hDecoder->sf_index, hDecoder->object_type,\n        spec_coef1, hDecoder->frameLength);\n    tns_decode_frame(ics2, &(ics2->tns), hDecoder->sf_index, hDecoder->object_type,\n        spec_coef2, hDecoder->frameLength);\n\n    /* drc decoding */\n    if (hDecoder->drc->present)\n    {\n        if (!hDecoder->drc->exclude_mask[cpe->channel] || !hDecoder->drc->excluded_chns_present)\n            drc_decode(hDecoder->drc, spec_coef1);\n        if (!hDecoder->drc->exclude_mask[cpe->paired_channel] || !hDecoder->drc->excluded_chns_present)\n            drc_decode(hDecoder->drc, spec_coef2);\n    }\n\n    /* filter bank */\n#ifdef SSR_DEC\n    if (hDecoder->object_type != SSR)\n    {\n#endif\n        ifilter_bank(hDecoder->fb, ics1->window_sequence, ics1->window_shape,\n            hDecoder->window_shape_prev[cpe->channel], spec_coef1,\n            hDecoder->time_out[cpe->channel], hDecoder->fb_intermed[cpe->channel],\n            hDecoder->object_type, hDecoder->frameLength);\n        ifilter_bank(hDecoder->fb, ics2->window_sequence, ics2->window_shape,\n            hDecoder->window_shape_prev[cpe->paired_channel], spec_coef2,\n            hDecoder->time_out[cpe->paired_channel], hDecoder->fb_intermed[cpe->paired_channel],\n            hDecoder->object_type, hDecoder->frameLength);\n#ifdef SSR_DEC\n    } else {\n        ssr_decode(&(ics1->ssr), hDecoder->fb, ics1->window_sequence, ics1->window_shape,\n            hDecoder->window_shape_prev[cpe->channel], spec_coef1, hDecoder->time_out[cpe->channel],\n            hDecoder->ssr_overlap[cpe->channel], hDecoder->ipqf_buffer[cpe->channel],\n            hDecoder->prev_fmd[cpe->channel], hDecoder->frameLength);\n        ssr_decode(&(ics2->ssr), hDecoder->fb, ics2->window_sequence, ics2->window_shape,\n            hDecoder->window_shape_prev[cpe->paired_channel], spec_coef2, hDecoder->time_out[cpe->paired_channel],\n            hDecoder->ssr_overlap[cpe->paired_channel], hDecoder->ipqf_buffer[cpe->paired_channel],\n            hDecoder->prev_fmd[cpe->paired_channel], hDecoder->frameLength);\n    }\n#endif\n\n    /* save window shape for next frame */\n    hDecoder->window_shape_prev[cpe->channel] = ics1->window_shape;\n    hDecoder->window_shape_prev[cpe->paired_channel] = ics2->window_shape;\n\n#ifdef LTP_DEC\n    if (is_ltp_ot(hDecoder->object_type))\n    {\n        lt_update_state(hDecoder->lt_pred_stat[cpe->channel], hDecoder->time_out[cpe->channel],\n            hDecoder->fb_intermed[cpe->channel], hDecoder->frameLength, hDecoder->object_type);\n        lt_update_state(hDecoder->lt_pred_stat[cpe->paired_channel], hDecoder->time_out[cpe->paired_channel],\n            hDecoder->fb_intermed[cpe->paired_channel], hDecoder->frameLength, hDecoder->object_type);\n    }\n#endif\n\n#ifdef SBR_DEC\n    if (((hDecoder->sbr_present_flag == 1) || (hDecoder->forceUpSampling == 1))\n        && hDecoder->sbr_alloced[hDecoder->fr_ch_ele])\n    {\n        int ele = hDecoder->fr_ch_ele;\n        int ch0 = cpe->channel;\n        int ch1 = cpe->paired_channel;\n\n        /* following case can happen when forceUpSampling == 1 */\n        if (hDecoder->sbr[ele] == NULL)\n        {\n            hDecoder->sbr[ele] = sbrDecodeInit(hDecoder->frameLength,\n                hDecoder->element_id[ele], 2*get_sample_rate(hDecoder->sf_index),\n                hDecoder->downSampledSBR\n#ifdef DRM\n                , 0\n#endif\n                );\n        }\n\n        if (cpe->ics1.window_sequence == EIGHT_SHORT_SEQUENCE)\n            hDecoder->sbr[ele]->maxAACLine = 8*min(cpe->ics1.swb_offset[max(cpe->ics1.max_sfb-1, 0)], cpe->ics1.swb_offset_max);\n        else\n            hDecoder->sbr[ele]->maxAACLine = min(cpe->ics1.swb_offset[max(cpe->ics1.max_sfb-1, 0)], cpe->ics1.swb_offset_max);\n\n        retval = sbrDecodeCoupleFrame(hDecoder->sbr[ele],\n            hDecoder->time_out[ch0], hDecoder->time_out[ch1],\n            hDecoder->postSeekResetFlag, hDecoder->downSampledSBR);\n        if (retval > 0)\n            return retval;\n    } else if (((hDecoder->sbr_present_flag == 1) || (hDecoder->forceUpSampling == 1))\n        && !hDecoder->sbr_alloced[hDecoder->fr_ch_ele])\n    {\n        return 23;\n    }\n#endif\n\n    return 0;\n}",
  "abstract_func_before": "uint8_t reconstruct_channel_pair(NeAACDecStruct *VAR_0, ic_stream *VAR_1, ic_stream *VAR_2,\n                                 element *VAR_3, int16_t *VAR_4, int16_t *VAR_5)\n{\n    uint8_t VAR_6;\n    ALIGN VAR_7 VAR_8[1024];\n    ALIGN VAR_7 VAR_9[1024];\n\n#ifdef VAR_10\n    int64_t VAR_11 = faad_get_ts();\n#endif\n    if (VAR_0->element_alloced[VAR_0->fr_ch_ele] != 2)\n    {\n        VAR_6 = allocate_channel_pair(VAR_0, VAR_3->channel, (uint8_t)VAR_3->paired_channel);\n        if (VAR_6 > 0)\n            return VAR_6;\n\n        VAR_0->element_alloced[VAR_0->fr_ch_ele] = 2;\n    }\n\n    /* COMMENT_0 */\n    if(!VAR_0->time_out[VAR_3->channel])\n        return 15;\n\n    /* COMMENT_1 */\n    VAR_6 = quant_to_spec(VAR_0, VAR_1, VAR_4, VAR_8, VAR_0->frameLength);\n    if (VAR_6 > 0)\n        return VAR_6;\n    VAR_6 = quant_to_spec(VAR_0, VAR_2, VAR_5, VAR_9, VAR_0->frameLength);\n    if (VAR_6 > 0)\n        return VAR_6;\n\n#ifdef VAR_10\n    VAR_11 = faad_get_ts() - VAR_11;\n    VAR_0->requant_cycles += VAR_11;\n#endif\n\n    /* COMMENT_2 */\n    if (VAR_1->ms_mask_present)\n    {\n        pns_decode(VAR_1, VAR_2, VAR_8, VAR_9, VAR_0->frameLength, 1, VAR_0->object_type,\n            &(VAR_0->__r1), &(VAR_0->__r2));\n    } else {\n        pns_decode(VAR_1, VAR_2, VAR_8, VAR_9, VAR_0->frameLength, 0, VAR_0->object_type,\n            &(VAR_0->__r1), &(VAR_0->__r2));\n    }\n\n    /* COMMENT_3 */\n    ms_decode(VAR_1, VAR_2, VAR_8, VAR_9, VAR_0->frameLength);\n\n#if 0\n    {\n        int VAR_12;\n        for (VAR_12 = 0; VAR_12 < 1024; VAR_12++)\n        {\n            /* COMMENT_4 */\n            printf(\"0x%.8X\\n\", VAR_8[VAR_12]);\n        }\n        for (VAR_12 = 0; VAR_12 < 1024; VAR_12++)\n        {\n            /* COMMENT_5 */\n            printf(\"0x%.8X\\n\", VAR_9[VAR_12]);\n        }\n    }\n#endif\n\n    /* COMMENT_6 */\n    is_decode(VAR_1, VAR_2, VAR_8, VAR_9, VAR_0->frameLength);\n\n#if 0\n    {\n        int VAR_12;\n        for (VAR_12 = 0; VAR_12 < 1024; VAR_12++)\n        {\n            printf(\"%d\\n\", VAR_8[VAR_12]);\n            /* COMMENT_7 */\n        }\n        for (VAR_12 = 0; VAR_12 < 1024; VAR_12++)\n        {\n            printf(\"%d\\n\", VAR_9[VAR_12]);\n            /* COMMENT_8 */\n        }\n    }\n#endif\n\n#ifdef VAR_13\n    /* COMMENT_9 */\n    if (VAR_0->object_type == VAR_14)\n    {\n        /* COMMENT_10 */\n        ic_prediction(VAR_1, VAR_8, VAR_0->pred_stat[VAR_3->channel], VAR_0->frameLength,\n            VAR_0->sf_index);\n        ic_prediction(VAR_2, VAR_9, VAR_0->pred_stat[VAR_3->paired_channel], VAR_0->frameLength,\n            VAR_0->sf_index);\n\n        /* COMMENT_11 */\n                                                             \n                                                         \n          \n        pns_reset_pred_state(VAR_1, VAR_0->pred_stat[VAR_3->channel]);\n        pns_reset_pred_state(VAR_2, VAR_0->pred_stat[VAR_3->paired_channel]);\n    }\n#endif\n\n#ifdef VAR_15\n    if (is_ltp_ot(VAR_0->object_type))\n    {\n        ltp_info *VAR_16 = &(VAR_1->ltp);\n        ltp_info *VAR_17 = (VAR_3->common_window) ? &(VAR_2->ltp2) : &(VAR_2->ltp);\n#ifdef VAR_18\n        if (VAR_0->object_type == VAR_19)\n        {\n            if (VAR_16->data_present)\n            {\n                if (VAR_16->lag_update)\n                    VAR_0->ltp_lag[VAR_3->channel] = VAR_16->lag;\n            }\n            VAR_16->lag = VAR_0->ltp_lag[VAR_3->channel];\n            if (VAR_17->data_present)\n            {\n                if (VAR_17->lag_update)\n                    VAR_0->ltp_lag[VAR_3->paired_channel] = VAR_17->lag;\n            }\n            VAR_17->lag = VAR_0->ltp_lag[VAR_3->paired_channel];\n        }\n#endif\n\n        /* COMMENT_15 */\n        lt_prediction(VAR_1, VAR_16, VAR_8, VAR_0->lt_pred_stat[VAR_3->channel], VAR_0->fb,\n            VAR_1->window_shape, VAR_0->window_shape_prev[VAR_3->channel],\n            VAR_0->sf_index, VAR_0->object_type, VAR_0->frameLength);\n        lt_prediction(VAR_2, VAR_17, VAR_9, VAR_0->lt_pred_stat[VAR_3->paired_channel], VAR_0->fb,\n            VAR_2->window_shape, VAR_0->window_shape_prev[VAR_3->paired_channel],\n            VAR_0->sf_index, VAR_0->object_type, VAR_0->frameLength);\n    }\n#endif\n\n    /* COMMENT_16 */\n    tns_decode_frame(VAR_1, &(VAR_1->tns), VAR_0->sf_index, VAR_0->object_type,\n        VAR_8, VAR_0->frameLength);\n    tns_decode_frame(VAR_2, &(VAR_2->tns), VAR_0->sf_index, VAR_0->object_type,\n        VAR_9, VAR_0->frameLength);\n\n    /* COMMENT_17 */\n    if (VAR_0->drc->present)\n    {\n        if (!VAR_0->drc->exclude_mask[VAR_3->channel] || !VAR_0->drc->excluded_chns_present)\n            drc_decode(VAR_0->drc, VAR_8);\n        if (!VAR_0->drc->exclude_mask[VAR_3->paired_channel] || !VAR_0->drc->excluded_chns_present)\n            drc_decode(VAR_0->drc, VAR_9);\n    }\n\n    /* COMMENT_18 */\n#ifdef VAR_20\n    if (VAR_0->object_type != VAR_21)\n    {\n#endif\n        ifilter_bank(hDecoder->fb, ics1->window_sequence, ics1->window_shape,\n            VAR_0->window_shape_prev[VAR_3->channel], VAR_8,\n            VAR_0->time_out[VAR_3->channel], VAR_0->fb_intermed[VAR_3->channel],\n            VAR_0->object_type, VAR_0->frameLength);\n        ifilter_bank(VAR_0->fb, VAR_2->window_sequence, VAR_2->window_shape,\n            VAR_0->window_shape_prev[VAR_3->paired_channel], VAR_9,\n            VAR_0->time_out[VAR_3->paired_channel], VAR_0->fb_intermed[VAR_3->paired_channel],\n            VAR_0->object_type, VAR_0->frameLength);\n#ifdef VAR_20\n    } else {\n        ssr_decode(&(VAR_1->ssr), VAR_0->fb, VAR_1->window_sequence, VAR_1->window_shape,\n            VAR_0->window_shape_prev[VAR_3->channel], VAR_8, VAR_0->time_out[VAR_3->channel],\n            VAR_0->ssr_overlap[VAR_3->channel], VAR_0->ipqf_buffer[VAR_3->channel],\n            VAR_0->prev_fmd[VAR_3->channel], VAR_0->frameLength);\n        ssr_decode(&(VAR_2->ssr), VAR_0->fb, VAR_2->window_sequence, VAR_2->window_shape,\n            VAR_0->window_shape_prev[VAR_3->paired_channel], VAR_9, VAR_0->time_out[VAR_3->paired_channel],\n            VAR_0->ssr_overlap[VAR_3->paired_channel], VAR_0->ipqf_buffer[VAR_3->paired_channel],\n            VAR_0->prev_fmd[VAR_3->paired_channel], VAR_0->frameLength);\n    }\n#endif\n\n    /* COMMENT_19 */\n    VAR_0->window_shape_prev[VAR_3->channel] = VAR_1->window_shape;\n    VAR_0->window_shape_prev[VAR_3->paired_channel] = VAR_2->window_shape;\n\n#ifdef VAR_15\n    if (is_ltp_ot(VAR_0->object_type))\n    {\n        lt_update_state(VAR_0->lt_pred_stat[VAR_3->channel], VAR_0->time_out[VAR_3->channel],\n            VAR_0->fb_intermed[VAR_3->channel], VAR_0->frameLength, VAR_0->object_type);\n        lt_update_state(VAR_0->lt_pred_stat[VAR_3->paired_channel], VAR_0->time_out[VAR_3->paired_channel],\n            VAR_0->fb_intermed[VAR_3->paired_channel], VAR_0->frameLength, VAR_0->object_type);\n    }\n#endif\n\n#ifdef VAR_22\n    if (((VAR_0->sbr_present_flag == 1) || (VAR_0->forceUpSampling == 1))\n        && VAR_0->sbr_alloced[VAR_0->fr_ch_ele])\n    {\n        int VAR_23 = VAR_0->fr_ch_ele;\n        int VAR_24 = VAR_3->channel;\n        int VAR_25 = VAR_3->paired_channel;\n\n        /* COMMENT_20 */\n        if (VAR_0->sbr[VAR_23] == NULL)\n        {\n            VAR_0->sbr[VAR_23] = sbrDecodeInit(VAR_0->frameLength,\n                VAR_0->element_id[VAR_23], 2*get_sample_rate(VAR_0->sf_index),\n                VAR_0->downSampledSBR\n#ifdef VAR_26\n                , 0\n#endif\n                );\n        }\n\n        if (VAR_3->ics1.window_sequence == VAR_27)\n            VAR_0->sbr[VAR_23]->maxAACLine = 8*min(VAR_3->ics1.swb_offset[max(VAR_3->ics1.max_sfb-1, 0)], VAR_3->ics1.swb_offset_max);\n        else\n            VAR_0->sbr[VAR_23]->maxAACLine = min(VAR_3->ics1.swb_offset[max(VAR_3->ics1.max_sfb-1, 0)], VAR_3->ics1.swb_offset_max);\n\n        VAR_6 = sbrDecodeCoupleFrame(VAR_0->sbr[VAR_23],\n            VAR_0->time_out[VAR_24], VAR_0->time_out[VAR_25],\n            VAR_0->postSeekResetFlag, VAR_0->downSampledSBR);\n        if (VAR_6 > 0)\n            return VAR_6;\n    } else if (((VAR_0->sbr_present_flag == 1) || (VAR_0->forceUpSampling == 1))\n        && !VAR_0->sbr_alloced[VAR_0->fr_ch_ele])\n    {\n        return 23;\n    }\n#endif\n\n    return 0;\n}",
  "func_graph_path_before": "knik0/faad2/c78251b2b5d41ea840fd61ab9502b3d3036bd747/specrec.c/vul/before/0.json",
  "func": "uint8_t reconstruct_channel_pair(NeAACDecStruct *hDecoder, ic_stream *ics1, ic_stream *ics2,\n                                 element *cpe, int16_t *spec_data1, int16_t *spec_data2)\n{\n    uint8_t retval;\n    ALIGN real_t spec_coef1[1024];\n    ALIGN real_t spec_coef2[1024];\n\n#ifdef PROFILE\n    int64_t count = faad_get_ts();\n#endif\n    if (hDecoder->element_alloced[hDecoder->fr_ch_ele] != 2)\n    {\n        retval = allocate_channel_pair(hDecoder, cpe->channel, (uint8_t)cpe->paired_channel);\n        if (retval > 0)\n            return retval;\n\n        hDecoder->element_alloced[hDecoder->fr_ch_ele] = 2;\n    }\n\n    /* sanity check, CVE-2018-20199, CVE-2018-20360 */\n    if(!hDecoder->time_out[cpe->channel])\n        return 15;\n\n    /* dequantisation and scaling */\n    retval = quant_to_spec(hDecoder, ics1, spec_data1, spec_coef1, hDecoder->frameLength);\n    if (retval > 0)\n        return retval;\n    retval = quant_to_spec(hDecoder, ics2, spec_data2, spec_coef2, hDecoder->frameLength);\n    if (retval > 0)\n        return retval;\n\n#ifdef PROFILE\n    count = faad_get_ts() - count;\n    hDecoder->requant_cycles += count;\n#endif\n\n    /* pns decoding */\n    if (ics1->ms_mask_present)\n    {\n        pns_decode(ics1, ics2, spec_coef1, spec_coef2, hDecoder->frameLength, 1, hDecoder->object_type,\n            &(hDecoder->__r1), &(hDecoder->__r2));\n    } else {\n        pns_decode(ics1, ics2, spec_coef1, spec_coef2, hDecoder->frameLength, 0, hDecoder->object_type,\n            &(hDecoder->__r1), &(hDecoder->__r2));\n    }\n\n    /* mid/side decoding */\n    ms_decode(ics1, ics2, spec_coef1, spec_coef2, hDecoder->frameLength);\n\n#if 0\n    {\n        int i;\n        for (i = 0; i < 1024; i++)\n        {\n            //printf(\"%d\\n\", spec_coef1[i]);\n            printf(\"0x%.8X\\n\", spec_coef1[i]);\n        }\n        for (i = 0; i < 1024; i++)\n        {\n            //printf(\"%d\\n\", spec_coef2[i]);\n            printf(\"0x%.8X\\n\", spec_coef2[i]);\n        }\n    }\n#endif\n\n    /* intensity stereo decoding */\n    is_decode(ics1, ics2, spec_coef1, spec_coef2, hDecoder->frameLength);\n\n#if 0\n    {\n        int i;\n        for (i = 0; i < 1024; i++)\n        {\n            printf(\"%d\\n\", spec_coef1[i]);\n            //printf(\"0x%.8X\\n\", spec_coef1[i]);\n        }\n        for (i = 0; i < 1024; i++)\n        {\n            printf(\"%d\\n\", spec_coef2[i]);\n            //printf(\"0x%.8X\\n\", spec_coef2[i]);\n        }\n    }\n#endif\n\n#ifdef MAIN_DEC\n    /* MAIN object type prediction */\n    if (hDecoder->object_type == MAIN)\n    {\n        /* intra channel prediction */\n        ic_prediction(ics1, spec_coef1, hDecoder->pred_stat[cpe->channel], hDecoder->frameLength,\n            hDecoder->sf_index);\n        ic_prediction(ics2, spec_coef2, hDecoder->pred_stat[cpe->paired_channel], hDecoder->frameLength,\n            hDecoder->sf_index);\n\n        /* In addition, for scalefactor bands coded by perceptual\n           noise substitution the predictors belonging to the\n           corresponding spectral coefficients are reset.\n        */\n        pns_reset_pred_state(ics1, hDecoder->pred_stat[cpe->channel]);\n        pns_reset_pred_state(ics2, hDecoder->pred_stat[cpe->paired_channel]);\n    }\n#endif\n\n#ifdef LTP_DEC\n    if (is_ltp_ot(hDecoder->object_type))\n    {\n        ltp_info *ltp1 = &(ics1->ltp);\n        ltp_info *ltp2 = (cpe->common_window) ? &(ics2->ltp2) : &(ics2->ltp);\n#ifdef LD_DEC\n        if (hDecoder->object_type == LD)\n        {\n            if (ltp1->data_present)\n            {\n                if (ltp1->lag_update)\n                    hDecoder->ltp_lag[cpe->channel] = ltp1->lag;\n            }\n            ltp1->lag = hDecoder->ltp_lag[cpe->channel];\n            if (ltp2->data_present)\n            {\n                if (ltp2->lag_update)\n                    hDecoder->ltp_lag[cpe->paired_channel] = ltp2->lag;\n            }\n            ltp2->lag = hDecoder->ltp_lag[cpe->paired_channel];\n        }\n#endif\n\n        /* long term prediction */\n        lt_prediction(ics1, ltp1, spec_coef1, hDecoder->lt_pred_stat[cpe->channel], hDecoder->fb,\n            ics1->window_shape, hDecoder->window_shape_prev[cpe->channel],\n            hDecoder->sf_index, hDecoder->object_type, hDecoder->frameLength);\n        lt_prediction(ics2, ltp2, spec_coef2, hDecoder->lt_pred_stat[cpe->paired_channel], hDecoder->fb,\n            ics2->window_shape, hDecoder->window_shape_prev[cpe->paired_channel],\n            hDecoder->sf_index, hDecoder->object_type, hDecoder->frameLength);\n    }\n#endif\n\n    /* tns decoding */\n    tns_decode_frame(ics1, &(ics1->tns), hDecoder->sf_index, hDecoder->object_type,\n        spec_coef1, hDecoder->frameLength);\n    tns_decode_frame(ics2, &(ics2->tns), hDecoder->sf_index, hDecoder->object_type,\n        spec_coef2, hDecoder->frameLength);\n\n    /* drc decoding */\n    if (hDecoder->drc->present)\n    {\n        if (!hDecoder->drc->exclude_mask[cpe->channel] || !hDecoder->drc->excluded_chns_present)\n            drc_decode(hDecoder->drc, spec_coef1);\n        if (!hDecoder->drc->exclude_mask[cpe->paired_channel] || !hDecoder->drc->excluded_chns_present)\n            drc_decode(hDecoder->drc, spec_coef2);\n    }\n\n    /* filter bank */\n#ifdef SSR_DEC\n    if (hDecoder->object_type != SSR)\n    {\n#endif\n        ifilter_bank(hDecoder->fb, ics1->window_sequence, ics1->window_shape,\n            hDecoder->window_shape_prev[cpe->channel], spec_coef1,\n            hDecoder->time_out[cpe->channel], hDecoder->fb_intermed[cpe->channel],\n            hDecoder->object_type, hDecoder->frameLength);\n        ifilter_bank(hDecoder->fb, ics2->window_sequence, ics2->window_shape,\n            hDecoder->window_shape_prev[cpe->paired_channel], spec_coef2,\n            hDecoder->time_out[cpe->paired_channel], hDecoder->fb_intermed[cpe->paired_channel],\n            hDecoder->object_type, hDecoder->frameLength);\n#ifdef SSR_DEC\n    } else {\n        ssr_decode(&(ics1->ssr), hDecoder->fb, ics1->window_sequence, ics1->window_shape,\n            hDecoder->window_shape_prev[cpe->channel], spec_coef1, hDecoder->time_out[cpe->channel],\n            hDecoder->ssr_overlap[cpe->channel], hDecoder->ipqf_buffer[cpe->channel],\n            hDecoder->prev_fmd[cpe->channel], hDecoder->frameLength);\n        ssr_decode(&(ics2->ssr), hDecoder->fb, ics2->window_sequence, ics2->window_shape,\n            hDecoder->window_shape_prev[cpe->paired_channel], spec_coef2, hDecoder->time_out[cpe->paired_channel],\n            hDecoder->ssr_overlap[cpe->paired_channel], hDecoder->ipqf_buffer[cpe->paired_channel],\n            hDecoder->prev_fmd[cpe->paired_channel], hDecoder->frameLength);\n    }\n#endif\n\n    /* save window shape for next frame */\n    hDecoder->window_shape_prev[cpe->channel] = ics1->window_shape;\n    hDecoder->window_shape_prev[cpe->paired_channel] = ics2->window_shape;\n\n#ifdef LTP_DEC\n    if (is_ltp_ot(hDecoder->object_type))\n    {\n        lt_update_state(hDecoder->lt_pred_stat[cpe->channel], hDecoder->time_out[cpe->channel],\n            hDecoder->fb_intermed[cpe->channel], hDecoder->frameLength, hDecoder->object_type);\n        lt_update_state(hDecoder->lt_pred_stat[cpe->paired_channel], hDecoder->time_out[cpe->paired_channel],\n            hDecoder->fb_intermed[cpe->paired_channel], hDecoder->frameLength, hDecoder->object_type);\n    }\n#endif\n\n#ifdef SBR_DEC\n    if (((hDecoder->sbr_present_flag == 1) || (hDecoder->forceUpSampling == 1))\n        && hDecoder->sbr_alloced[hDecoder->fr_ch_ele])\n    {\n        int ele = hDecoder->fr_ch_ele;\n        int ch0 = cpe->channel;\n        int ch1 = cpe->paired_channel;\n\n        /* following case can happen when forceUpSampling == 1 */\n        if (hDecoder->sbr[ele] == NULL)\n        {\n            hDecoder->sbr[ele] = sbrDecodeInit(hDecoder->frameLength,\n                hDecoder->element_id[ele], 2*get_sample_rate(hDecoder->sf_index),\n                hDecoder->downSampledSBR\n#ifdef DRM\n                , 0\n#endif\n                );\n        }\n        if (!hDecoder->sbr[ele])\n            return 19;\n\n        if (cpe->ics1.window_sequence == EIGHT_SHORT_SEQUENCE)\n            hDecoder->sbr[ele]->maxAACLine = 8*min(cpe->ics1.swb_offset[max(cpe->ics1.max_sfb-1, 0)], cpe->ics1.swb_offset_max);\n        else\n            hDecoder->sbr[ele]->maxAACLine = min(cpe->ics1.swb_offset[max(cpe->ics1.max_sfb-1, 0)], cpe->ics1.swb_offset_max);\n\n        retval = sbrDecodeCoupleFrame(hDecoder->sbr[ele],\n            hDecoder->time_out[ch0], hDecoder->time_out[ch1],\n            hDecoder->postSeekResetFlag, hDecoder->downSampledSBR);\n        if (retval > 0)\n            return retval;\n    } else if (((hDecoder->sbr_present_flag == 1) || (hDecoder->forceUpSampling == 1))\n        && !hDecoder->sbr_alloced[hDecoder->fr_ch_ele])\n    {\n        return 23;\n    }\n#endif\n\n    return 0;\n}",
  "abstract_func": "uint8_t reconstruct_channel_pair(NeAACDecStruct *VAR_0, ic_stream *VAR_1, ic_stream *VAR_2,\n                                 element *VAR_3, int16_t *VAR_4, int16_t *VAR_5)\n{\n    uint8_t VAR_6;\n    ALIGN VAR_7 VAR_8[1024];\n    ALIGN VAR_7 VAR_9[1024];\n\n#ifdef VAR_10\n    int64_t VAR_11 = faad_get_ts();\n#endif\n    if (VAR_0->element_alloced[VAR_0->fr_ch_ele] != 2)\n    {\n        VAR_6 = allocate_channel_pair(VAR_0, VAR_3->channel, (uint8_t)VAR_3->paired_channel);\n        if (VAR_6 > 0)\n            return VAR_6;\n\n        VAR_0->element_alloced[VAR_0->fr_ch_ele] = 2;\n    }\n\n    /* COMMENT_0 */\n    if(!VAR_0->time_out[VAR_3->channel])\n        return 15;\n\n    /* COMMENT_1 */\n    VAR_6 = quant_to_spec(VAR_0, VAR_1, VAR_4, VAR_8, VAR_0->frameLength);\n    if (VAR_6 > 0)\n        return VAR_6;\n    VAR_6 = quant_to_spec(VAR_0, VAR_2, VAR_5, VAR_9, VAR_0->frameLength);\n    if (VAR_6 > 0)\n        return VAR_6;\n\n#ifdef VAR_10\n    VAR_11 = faad_get_ts() - VAR_11;\n    VAR_0->requant_cycles += VAR_11;\n#endif\n\n    /* COMMENT_2 */\n    if (VAR_1->ms_mask_present)\n    {\n        pns_decode(VAR_1, VAR_2, VAR_8, VAR_9, VAR_0->frameLength, 1, VAR_0->object_type,\n            &(VAR_0->__r1), &(VAR_0->__r2));\n    } else {\n        pns_decode(VAR_1, VAR_2, VAR_8, VAR_9, VAR_0->frameLength, 0, VAR_0->object_type,\n            &(VAR_0->__r1), &(VAR_0->__r2));\n    }\n\n    /* COMMENT_3 */\n    ms_decode(VAR_1, VAR_2, VAR_8, VAR_9, VAR_0->frameLength);\n\n#if 0\n    {\n        int VAR_12;\n        for (VAR_12 = 0; VAR_12 < 1024; VAR_12++)\n        {\n            /* COMMENT_4 */\n            printf(\"0x%.8X\\n\", VAR_8[VAR_12]);\n        }\n        for (VAR_12 = 0; VAR_12 < 1024; VAR_12++)\n        {\n            /* COMMENT_5 */\n            printf(\"0x%.8X\\n\", VAR_9[VAR_12]);\n        }\n    }\n#endif\n\n    /* COMMENT_6 */\n    is_decode(VAR_1, VAR_2, VAR_8, VAR_9, VAR_0->frameLength);\n\n#if 0\n    {\n        int VAR_12;\n        for (VAR_12 = 0; VAR_12 < 1024; VAR_12++)\n        {\n            printf(\"%d\\n\", VAR_8[VAR_12]);\n            /* COMMENT_7 */\n        }\n        for (VAR_12 = 0; VAR_12 < 1024; VAR_12++)\n        {\n            printf(\"%d\\n\", VAR_9[VAR_12]);\n            /* COMMENT_8 */\n        }\n    }\n#endif\n\n#ifdef VAR_13\n    /* COMMENT_9 */\n    if (VAR_0->object_type == VAR_14)\n    {\n        /* COMMENT_10 */\n        ic_prediction(VAR_1, VAR_8, VAR_0->pred_stat[VAR_3->channel], VAR_0->frameLength,\n            VAR_0->sf_index);\n        ic_prediction(VAR_2, VAR_9, VAR_0->pred_stat[VAR_3->paired_channel], VAR_0->frameLength,\n            VAR_0->sf_index);\n\n        /* COMMENT_11 */\n                                                             \n                                                         \n          \n        pns_reset_pred_state(VAR_1, VAR_0->pred_stat[VAR_3->channel]);\n        pns_reset_pred_state(VAR_2, VAR_0->pred_stat[VAR_3->paired_channel]);\n    }\n#endif\n\n#ifdef VAR_15\n    if (is_ltp_ot(VAR_0->object_type))\n    {\n        ltp_info *VAR_16 = &(VAR_1->ltp);\n        ltp_info *VAR_17 = (VAR_3->common_window) ? &(VAR_2->ltp2) : &(VAR_2->ltp);\n#ifdef VAR_18\n        if (VAR_0->object_type == VAR_19)\n        {\n            if (VAR_16->data_present)\n            {\n                if (VAR_16->lag_update)\n                    VAR_0->ltp_lag[VAR_3->channel] = VAR_16->lag;\n            }\n            VAR_16->lag = VAR_0->ltp_lag[VAR_3->channel];\n            if (VAR_17->data_present)\n            {\n                if (VAR_17->lag_update)\n                    VAR_0->ltp_lag[VAR_3->paired_channel] = VAR_17->lag;\n            }\n            VAR_17->lag = VAR_0->ltp_lag[VAR_3->paired_channel];\n        }\n#endif\n\n        /* COMMENT_15 */\n        lt_prediction(VAR_1, VAR_16, VAR_8, VAR_0->lt_pred_stat[VAR_3->channel], VAR_0->fb,\n            VAR_1->window_shape, VAR_0->window_shape_prev[VAR_3->channel],\n            VAR_0->sf_index, VAR_0->object_type, VAR_0->frameLength);\n        lt_prediction(VAR_2, VAR_17, VAR_9, VAR_0->lt_pred_stat[VAR_3->paired_channel], VAR_0->fb,\n            VAR_2->window_shape, VAR_0->window_shape_prev[VAR_3->paired_channel],\n            VAR_0->sf_index, VAR_0->object_type, VAR_0->frameLength);\n    }\n#endif\n\n    /* COMMENT_16 */\n    tns_decode_frame(VAR_1, &(VAR_1->tns), VAR_0->sf_index, VAR_0->object_type,\n        VAR_8, VAR_0->frameLength);\n    tns_decode_frame(VAR_2, &(VAR_2->tns), VAR_0->sf_index, VAR_0->object_type,\n        VAR_9, VAR_0->frameLength);\n\n    /* COMMENT_17 */\n    if (VAR_0->drc->present)\n    {\n        if (!VAR_0->drc->exclude_mask[VAR_3->channel] || !VAR_0->drc->excluded_chns_present)\n            drc_decode(VAR_0->drc, VAR_8);\n        if (!VAR_0->drc->exclude_mask[VAR_3->paired_channel] || !VAR_0->drc->excluded_chns_present)\n            drc_decode(VAR_0->drc, VAR_9);\n    }\n\n    /* COMMENT_18 */\n#ifdef VAR_20\n    if (VAR_0->object_type != VAR_21)\n    {\n#endif\n        ifilter_bank(hDecoder->fb, ics1->window_sequence, ics1->window_shape,\n            VAR_0->window_shape_prev[VAR_3->channel], VAR_8,\n            VAR_0->time_out[VAR_3->channel], VAR_0->fb_intermed[VAR_3->channel],\n            VAR_0->object_type, VAR_0->frameLength);\n        ifilter_bank(VAR_0->fb, VAR_2->window_sequence, VAR_2->window_shape,\n            VAR_0->window_shape_prev[VAR_3->paired_channel], VAR_9,\n            VAR_0->time_out[VAR_3->paired_channel], VAR_0->fb_intermed[VAR_3->paired_channel],\n            VAR_0->object_type, VAR_0->frameLength);\n#ifdef VAR_20\n    } else {\n        ssr_decode(&(VAR_1->ssr), VAR_0->fb, VAR_1->window_sequence, VAR_1->window_shape,\n            VAR_0->window_shape_prev[VAR_3->channel], VAR_8, VAR_0->time_out[VAR_3->channel],\n            VAR_0->ssr_overlap[VAR_3->channel], VAR_0->ipqf_buffer[VAR_3->channel],\n            VAR_0->prev_fmd[VAR_3->channel], VAR_0->frameLength);\n        ssr_decode(&(VAR_2->ssr), VAR_0->fb, VAR_2->window_sequence, VAR_2->window_shape,\n            VAR_0->window_shape_prev[VAR_3->paired_channel], VAR_9, VAR_0->time_out[VAR_3->paired_channel],\n            VAR_0->ssr_overlap[VAR_3->paired_channel], VAR_0->ipqf_buffer[VAR_3->paired_channel],\n            VAR_0->prev_fmd[VAR_3->paired_channel], VAR_0->frameLength);\n    }\n#endif\n\n    /* COMMENT_19 */\n    VAR_0->window_shape_prev[VAR_3->channel] = VAR_1->window_shape;\n    VAR_0->window_shape_prev[VAR_3->paired_channel] = VAR_2->window_shape;\n\n#ifdef VAR_15\n    if (is_ltp_ot(VAR_0->object_type))\n    {\n        lt_update_state(VAR_0->lt_pred_stat[VAR_3->channel], VAR_0->time_out[VAR_3->channel],\n            VAR_0->fb_intermed[VAR_3->channel], VAR_0->frameLength, VAR_0->object_type);\n        lt_update_state(VAR_0->lt_pred_stat[VAR_3->paired_channel], VAR_0->time_out[VAR_3->paired_channel],\n            VAR_0->fb_intermed[VAR_3->paired_channel], VAR_0->frameLength, VAR_0->object_type);\n    }\n#endif\n\n#ifdef VAR_22\n    if (((VAR_0->sbr_present_flag == 1) || (VAR_0->forceUpSampling == 1))\n        && VAR_0->sbr_alloced[VAR_0->fr_ch_ele])\n    {\n        int VAR_23 = VAR_0->fr_ch_ele;\n        int VAR_24 = VAR_3->channel;\n        int VAR_25 = VAR_3->paired_channel;\n\n        /* COMMENT_20 */\n        if (VAR_0->sbr[VAR_23] == NULL)\n        {\n            VAR_0->sbr[VAR_23] = sbrDecodeInit(VAR_0->frameLength,\n                VAR_0->element_id[VAR_23], 2*get_sample_rate(VAR_0->sf_index),\n                VAR_0->downSampledSBR\n#ifdef VAR_26\n                , 0\n#endif\n                );\n        }\n        if (!VAR_0->sbr[VAR_23])\n            return 19;\n\n        if (VAR_3->ics1.window_sequence == VAR_27)\n            VAR_0->sbr[VAR_23]->maxAACLine = 8*min(VAR_3->ics1.swb_offset[max(VAR_3->ics1.max_sfb-1, 0)], VAR_3->ics1.swb_offset_max);\n        else\n            VAR_0->sbr[VAR_23]->maxAACLine = min(VAR_3->ics1.swb_offset[max(VAR_3->ics1.max_sfb-1, 0)], VAR_3->ics1.swb_offset_max);\n\n        VAR_6 = sbrDecodeCoupleFrame(VAR_0->sbr[VAR_23],\n            VAR_0->time_out[VAR_24], VAR_0->time_out[VAR_25],\n            VAR_0->postSeekResetFlag, VAR_0->downSampledSBR);\n        if (VAR_6 > 0)\n            return VAR_6;\n    } else if (((VAR_0->sbr_present_flag == 1) || (VAR_0->forceUpSampling == 1))\n        && !VAR_0->sbr_alloced[VAR_0->fr_ch_ele])\n    {\n        return 23;\n    }\n#endif\n\n    return 0;\n}",
  "func_graph_path": "knik0/faad2/c78251b2b5d41ea840fd61ab9502b3d3036bd747/specrec.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -208,6 +208,8 @@\n #endif\n                 );\n         }\n+        if (!hDecoder->sbr[ele])\n+            return 19;\n \n         if (cpe->ics1.window_sequence == EIGHT_SHORT_SEQUENCE)\n             hDecoder->sbr[ele]->maxAACLine = 8*min(cpe->ics1.swb_offset[max(cpe->ics1.max_sfb-1, 0)], cpe->ics1.swb_offset_max);",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "        if (!hDecoder->sbr[ele])",
      "            return 19;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/knik0/faad2/pull/63",
  "description": {
    "pr_info": {
      "title": "Fix various issues",
      "number": 63
    },
    "comment": [
      "I tried to fix some of the outstanding issues. Please test and double check if you have time.",
      "Wow, thanks!\r\n\r\n~~Could you please elaborate which \"outstanding issues\" exactly each commit addresses?~~",
      "Never mind, I should have read the commit messages!",
      "I don't have a chance to test all your changes, but they look all reasonable to me. I'll apply them in good faith, thank you very much! ",
      "Since you seem to be knowledgeable of the code and the data format, could you probably have a look at https://github.com/knik0/faad2/commit/466b01d504d7e45f1e9169ac90b3e34ab94aed14 and the linked issues at the mixx bug tracker, please? ",
      "Do you happen to have any more fixes in the line? I'd like to tag the current state as a new release anytime soon but don't want to get in the way if you have more to apply. ",
      "See #65. There is no rush on it though. It sounds like it #64 is more important to get out in the wild since it fixes a regression."
    ]
  },
  "Bug Filter": "** Security Vulnerability Fix  \n**Confidence Score:** 0.9",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "\n\nThe patch addresses a potential security issue by restricting frame lengths and adding a null check to prevent errors. This likely mitigates a security vulnerability.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 0.9"
}