{
  "cve_id": "CVE-2020-8112",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "uclouvain/openjpeg",
  "commit_msg": "opj_tcd_init_tile(): avoid integer overflow\n\nThat could lead to later assertion failures.\n\nFixes #1231 / CVE-2020-8112",
  "commit_hash": "05f9b91e60debda0e83977e5e63b2e66486f7074",
  "git_url": "https://github.com/uclouvain/openjpeg/commit/05f9b91e60debda0e83977e5e63b2e66486f7074",
  "file_path": "src/lib/openjp2/tcd.c",
  "func_name": "opj_tcd_init_tile",
  "func_before": "static INLINE OPJ_BOOL opj_tcd_init_tile(opj_tcd_t *p_tcd, OPJ_UINT32 p_tile_no,\n        OPJ_BOOL isEncoder, OPJ_FLOAT32 fraction, OPJ_SIZE_T sizeof_block,\n        opj_event_mgr_t* manager)\n{\n    OPJ_UINT32(*l_gain_ptr)(OPJ_UINT32) = 00;\n    OPJ_UINT32 compno, resno, bandno, precno, cblkno;\n    opj_tcp_t * l_tcp = 00;\n    opj_cp_t * l_cp = 00;\n    opj_tcd_tile_t * l_tile = 00;\n    opj_tccp_t *l_tccp = 00;\n    opj_tcd_tilecomp_t *l_tilec = 00;\n    opj_image_comp_t * l_image_comp = 00;\n    opj_tcd_resolution_t *l_res = 00;\n    opj_tcd_band_t *l_band = 00;\n    opj_stepsize_t * l_step_size = 00;\n    opj_tcd_precinct_t *l_current_precinct = 00;\n    opj_image_t *l_image = 00;\n    OPJ_UINT32 p, q;\n    OPJ_UINT32 l_level_no;\n    OPJ_UINT32 l_pdx, l_pdy;\n    OPJ_UINT32 l_gain;\n    OPJ_INT32 l_x0b, l_y0b;\n    OPJ_UINT32 l_tx0, l_ty0;\n    /* extent of precincts , top left, bottom right**/\n    OPJ_INT32 l_tl_prc_x_start, l_tl_prc_y_start, l_br_prc_x_end, l_br_prc_y_end;\n    /* number of precinct for a resolution */\n    OPJ_UINT32 l_nb_precincts;\n    /* room needed to store l_nb_precinct precinct for a resolution */\n    OPJ_UINT32 l_nb_precinct_size;\n    /* number of code blocks for a precinct*/\n    OPJ_UINT32 l_nb_code_blocks;\n    /* room needed to store l_nb_code_blocks code blocks for a precinct*/\n    OPJ_UINT32 l_nb_code_blocks_size;\n    /* size of data for a tile */\n    OPJ_UINT32 l_data_size;\n\n    l_cp = p_tcd->cp;\n    l_tcp = &(l_cp->tcps[p_tile_no]);\n    l_tile = p_tcd->tcd_image->tiles;\n    l_tccp = l_tcp->tccps;\n    l_tilec = l_tile->comps;\n    l_image = p_tcd->image;\n    l_image_comp = p_tcd->image->comps;\n\n    p = p_tile_no % l_cp->tw;       /* tile coordinates */\n    q = p_tile_no / l_cp->tw;\n    /*fprintf(stderr, \"Tile coordinate = %d,%d\\n\", p, q);*/\n\n    /* 4 borders of the tile rescale on the image if necessary */\n    l_tx0 = l_cp->tx0 + p *\n            l_cp->tdx; /* can't be greater than l_image->x1 so won't overflow */\n    l_tile->x0 = (OPJ_INT32)opj_uint_max(l_tx0, l_image->x0);\n    l_tile->x1 = (OPJ_INT32)opj_uint_min(opj_uint_adds(l_tx0, l_cp->tdx),\n                                         l_image->x1);\n    /* all those OPJ_UINT32 are casted to OPJ_INT32, let's do some sanity check */\n    if ((l_tile->x0 < 0) || (l_tile->x1 <= l_tile->x0)) {\n        opj_event_msg(manager, EVT_ERROR, \"Tile X coordinates are not supported\\n\");\n        return OPJ_FALSE;\n    }\n    l_ty0 = l_cp->ty0 + q *\n            l_cp->tdy; /* can't be greater than l_image->y1 so won't overflow */\n    l_tile->y0 = (OPJ_INT32)opj_uint_max(l_ty0, l_image->y0);\n    l_tile->y1 = (OPJ_INT32)opj_uint_min(opj_uint_adds(l_ty0, l_cp->tdy),\n                                         l_image->y1);\n    /* all those OPJ_UINT32 are casted to OPJ_INT32, let's do some sanity check */\n    if ((l_tile->y0 < 0) || (l_tile->y1 <= l_tile->y0)) {\n        opj_event_msg(manager, EVT_ERROR, \"Tile Y coordinates are not supported\\n\");\n        return OPJ_FALSE;\n    }\n\n\n    /* testcase 1888.pdf.asan.35.988 */\n    if (l_tccp->numresolutions == 0) {\n        opj_event_msg(manager, EVT_ERROR, \"tiles require at least one resolution\\n\");\n        return OPJ_FALSE;\n    }\n    /*fprintf(stderr, \"Tile border = %d,%d,%d,%d\\n\", l_tile->x0, l_tile->y0,l_tile->x1,l_tile->y1);*/\n\n    /*tile->numcomps = image->numcomps; */\n    for (compno = 0; compno < l_tile->numcomps; ++compno) {\n        /*fprintf(stderr, \"compno = %d/%d\\n\", compno, l_tile->numcomps);*/\n        l_image_comp->resno_decoded = 0;\n        /* border of each l_tile component (global) */\n        l_tilec->x0 = opj_int_ceildiv(l_tile->x0, (OPJ_INT32)l_image_comp->dx);\n        l_tilec->y0 = opj_int_ceildiv(l_tile->y0, (OPJ_INT32)l_image_comp->dy);\n        l_tilec->x1 = opj_int_ceildiv(l_tile->x1, (OPJ_INT32)l_image_comp->dx);\n        l_tilec->y1 = opj_int_ceildiv(l_tile->y1, (OPJ_INT32)l_image_comp->dy);\n        l_tilec->compno = compno;\n        /*fprintf(stderr, \"\\tTile compo border = %d,%d,%d,%d\\n\", l_tilec->x0, l_tilec->y0,l_tilec->x1,l_tilec->y1);*/\n\n        l_tilec->numresolutions = l_tccp->numresolutions;\n        if (l_tccp->numresolutions < l_cp->m_specific_param.m_dec.m_reduce) {\n            l_tilec->minimum_num_resolutions = 1;\n        } else {\n            l_tilec->minimum_num_resolutions = l_tccp->numresolutions -\n                                               l_cp->m_specific_param.m_dec.m_reduce;\n        }\n\n        if (isEncoder) {\n            OPJ_SIZE_T l_tile_data_size;\n\n            /* compute l_data_size with overflow check */\n            OPJ_SIZE_T w = (OPJ_SIZE_T)(l_tilec->x1 - l_tilec->x0);\n            OPJ_SIZE_T h = (OPJ_SIZE_T)(l_tilec->y1 - l_tilec->y0);\n\n            /* issue 733, l_data_size == 0U, probably something wrong should be checked before getting here */\n            if (h > 0 && w > SIZE_MAX / h) {\n                opj_event_msg(manager, EVT_ERROR, \"Size of tile data exceeds system limits\\n\");\n                return OPJ_FALSE;\n            }\n            l_tile_data_size = w * h;\n\n            if (SIZE_MAX / sizeof(OPJ_UINT32) < l_tile_data_size) {\n                opj_event_msg(manager, EVT_ERROR, \"Size of tile data exceeds system limits\\n\");\n                return OPJ_FALSE;\n            }\n            l_tile_data_size = l_tile_data_size * sizeof(OPJ_UINT32);\n\n            l_tilec->data_size_needed = l_tile_data_size;\n        }\n\n        l_data_size = l_tilec->numresolutions * (OPJ_UINT32)sizeof(\n                          opj_tcd_resolution_t);\n\n        opj_image_data_free(l_tilec->data_win);\n        l_tilec->data_win = NULL;\n        l_tilec->win_x0 = 0;\n        l_tilec->win_y0 = 0;\n        l_tilec->win_x1 = 0;\n        l_tilec->win_y1 = 0;\n\n        if (l_tilec->resolutions == 00) {\n            l_tilec->resolutions = (opj_tcd_resolution_t *) opj_malloc(l_data_size);\n            if (! l_tilec->resolutions) {\n                return OPJ_FALSE;\n            }\n            /*fprintf(stderr, \"\\tAllocate resolutions of tilec (opj_tcd_resolution_t): %d\\n\",l_data_size);*/\n            l_tilec->resolutions_size = l_data_size;\n            memset(l_tilec->resolutions, 0, l_data_size);\n        } else if (l_data_size > l_tilec->resolutions_size) {\n            opj_tcd_resolution_t* new_resolutions = (opj_tcd_resolution_t *) opj_realloc(\n                    l_tilec->resolutions, l_data_size);\n            if (! new_resolutions) {\n                opj_event_msg(manager, EVT_ERROR, \"Not enough memory for tile resolutions\\n\");\n                opj_free(l_tilec->resolutions);\n                l_tilec->resolutions = NULL;\n                l_tilec->resolutions_size = 0;\n                return OPJ_FALSE;\n            }\n            l_tilec->resolutions = new_resolutions;\n            /*fprintf(stderr, \"\\tReallocate data of tilec (int): from %d to %d x OPJ_UINT32\\n\", l_tilec->resolutions_size, l_data_size);*/\n            memset(((OPJ_BYTE*) l_tilec->resolutions) + l_tilec->resolutions_size, 0,\n                   l_data_size - l_tilec->resolutions_size);\n            l_tilec->resolutions_size = l_data_size;\n        }\n\n        l_level_no = l_tilec->numresolutions;\n        l_res = l_tilec->resolutions;\n        l_step_size = l_tccp->stepsizes;\n        if (l_tccp->qmfbid == 0) {\n            l_gain_ptr = &opj_dwt_getgain_real;\n        } else {\n            l_gain_ptr  = &opj_dwt_getgain;\n        }\n        /*fprintf(stderr, \"\\tlevel_no=%d\\n\",l_level_no);*/\n\n        for (resno = 0; resno < l_tilec->numresolutions; ++resno) {\n            /*fprintf(stderr, \"\\t\\tresno = %d/%d\\n\", resno, l_tilec->numresolutions);*/\n            OPJ_INT32 tlcbgxstart, tlcbgystart /*, brcbgxend, brcbgyend*/;\n            OPJ_UINT32 cbgwidthexpn, cbgheightexpn;\n            OPJ_UINT32 cblkwidthexpn, cblkheightexpn;\n\n            --l_level_no;\n\n            /* border for each resolution level (global) */\n            l_res->x0 = opj_int_ceildivpow2(l_tilec->x0, (OPJ_INT32)l_level_no);\n            l_res->y0 = opj_int_ceildivpow2(l_tilec->y0, (OPJ_INT32)l_level_no);\n            l_res->x1 = opj_int_ceildivpow2(l_tilec->x1, (OPJ_INT32)l_level_no);\n            l_res->y1 = opj_int_ceildivpow2(l_tilec->y1, (OPJ_INT32)l_level_no);\n\n            /*fprintf(stderr, \"\\t\\t\\tres_x0= %d, res_y0 =%d, res_x1=%d, res_y1=%d\\n\", l_res->x0, l_res->y0, l_res->x1, l_res->y1);*/\n            /* p. 35, table A-23, ISO/IEC FDIS154444-1 : 2000 (18 august 2000) */\n            l_pdx = l_tccp->prcw[resno];\n            l_pdy = l_tccp->prch[resno];\n            /*fprintf(stderr, \"\\t\\t\\tpdx=%d, pdy=%d\\n\", l_pdx, l_pdy);*/\n            /* p. 64, B.6, ISO/IEC FDIS15444-1 : 2000 (18 august 2000)  */\n            l_tl_prc_x_start = opj_int_floordivpow2(l_res->x0, (OPJ_INT32)l_pdx) << l_pdx;\n            l_tl_prc_y_start = opj_int_floordivpow2(l_res->y0, (OPJ_INT32)l_pdy) << l_pdy;\n            l_br_prc_x_end = opj_int_ceildivpow2(l_res->x1, (OPJ_INT32)l_pdx) << l_pdx;\n            l_br_prc_y_end = opj_int_ceildivpow2(l_res->y1, (OPJ_INT32)l_pdy) << l_pdy;\n            /*fprintf(stderr, \"\\t\\t\\tprc_x_start=%d, prc_y_start=%d, br_prc_x_end=%d, br_prc_y_end=%d \\n\", l_tl_prc_x_start, l_tl_prc_y_start, l_br_prc_x_end ,l_br_prc_y_end );*/\n\n            l_res->pw = (l_res->x0 == l_res->x1) ? 0U : (OPJ_UINT32)((\n                            l_br_prc_x_end - l_tl_prc_x_start) >> l_pdx);\n            l_res->ph = (l_res->y0 == l_res->y1) ? 0U : (OPJ_UINT32)((\n                            l_br_prc_y_end - l_tl_prc_y_start) >> l_pdy);\n            /*fprintf(stderr, \"\\t\\t\\tres_pw=%d, res_ph=%d\\n\", l_res->pw, l_res->ph );*/\n\n            if ((l_res->pw != 0U) && ((((OPJ_UINT32) - 1) / l_res->pw) < l_res->ph)) {\n                opj_event_msg(manager, EVT_ERROR, \"Size of tile data exceeds system limits\\n\");\n                return OPJ_FALSE;\n            }\n            l_nb_precincts = l_res->pw * l_res->ph;\n\n            if ((((OPJ_UINT32) - 1) / (OPJ_UINT32)sizeof(opj_tcd_precinct_t)) <\n                    l_nb_precincts) {\n                opj_event_msg(manager, EVT_ERROR, \"Size of tile data exceeds system limits\\n\");\n                return OPJ_FALSE;\n            }\n            l_nb_precinct_size = l_nb_precincts * (OPJ_UINT32)sizeof(opj_tcd_precinct_t);\n\n            if (resno == 0) {\n                tlcbgxstart = l_tl_prc_x_start;\n                tlcbgystart = l_tl_prc_y_start;\n                /*brcbgxend = l_br_prc_x_end;*/\n                /* brcbgyend = l_br_prc_y_end;*/\n                cbgwidthexpn = l_pdx;\n                cbgheightexpn = l_pdy;\n                l_res->numbands = 1;\n            } else {\n                tlcbgxstart = opj_int_ceildivpow2(l_tl_prc_x_start, 1);\n                tlcbgystart = opj_int_ceildivpow2(l_tl_prc_y_start, 1);\n                /*brcbgxend = opj_int_ceildivpow2(l_br_prc_x_end, 1);*/\n                /*brcbgyend = opj_int_ceildivpow2(l_br_prc_y_end, 1);*/\n                cbgwidthexpn = l_pdx - 1;\n                cbgheightexpn = l_pdy - 1;\n                l_res->numbands = 3;\n            }\n\n            cblkwidthexpn = opj_uint_min(l_tccp->cblkw, cbgwidthexpn);\n            cblkheightexpn = opj_uint_min(l_tccp->cblkh, cbgheightexpn);\n            l_band = l_res->bands;\n\n            for (bandno = 0; bandno < l_res->numbands; ++bandno, ++l_band, ++l_step_size) {\n                OPJ_INT32 numbps;\n                /*fprintf(stderr, \"\\t\\t\\tband_no=%d/%d\\n\", bandno, l_res->numbands );*/\n\n                if (resno == 0) {\n                    l_band->bandno = 0 ;\n                    l_band->x0 = opj_int_ceildivpow2(l_tilec->x0, (OPJ_INT32)l_level_no);\n                    l_band->y0 = opj_int_ceildivpow2(l_tilec->y0, (OPJ_INT32)l_level_no);\n                    l_band->x1 = opj_int_ceildivpow2(l_tilec->x1, (OPJ_INT32)l_level_no);\n                    l_band->y1 = opj_int_ceildivpow2(l_tilec->y1, (OPJ_INT32)l_level_no);\n                } else {\n                    l_band->bandno = bandno + 1;\n                    /* x0b = 1 if bandno = 1 or 3 */\n                    l_x0b = l_band->bandno & 1;\n                    /* y0b = 1 if bandno = 2 or 3 */\n                    l_y0b = (OPJ_INT32)((l_band->bandno) >> 1);\n                    /* l_band border (global) */\n                    l_band->x0 = opj_int64_ceildivpow2(l_tilec->x0 - ((OPJ_INT64)l_x0b <<\n                                                       l_level_no), (OPJ_INT32)(l_level_no + 1));\n                    l_band->y0 = opj_int64_ceildivpow2(l_tilec->y0 - ((OPJ_INT64)l_y0b <<\n                                                       l_level_no), (OPJ_INT32)(l_level_no + 1));\n                    l_band->x1 = opj_int64_ceildivpow2(l_tilec->x1 - ((OPJ_INT64)l_x0b <<\n                                                       l_level_no), (OPJ_INT32)(l_level_no + 1));\n                    l_band->y1 = opj_int64_ceildivpow2(l_tilec->y1 - ((OPJ_INT64)l_y0b <<\n                                                       l_level_no), (OPJ_INT32)(l_level_no + 1));\n                }\n\n                if (isEncoder) {\n                    /* Skip empty bands */\n                    if (opj_tcd_is_band_empty(l_band)) {\n                        /* Do not zero l_band->precints to avoid leaks */\n                        /* but make sure we don't use it later, since */\n                        /* it will point to precincts of previous bands... */\n                        continue;\n                    }\n                }\n\n                /** avoid an if with storing function pointer */\n                l_gain = (*l_gain_ptr)(l_band->bandno);\n                numbps = (OPJ_INT32)(l_image_comp->prec + l_gain);\n                l_band->stepsize = (OPJ_FLOAT32)(((1.0 + l_step_size->mant / 2048.0) * pow(2.0,\n                                                  (OPJ_INT32)(numbps - l_step_size->expn)))) * fraction;\n                /* Mb value of Equation E-2 in \"E.1 Inverse quantization\n                 * procedure\" of the standard */\n                l_band->numbps = l_step_size->expn + (OPJ_INT32)l_tccp->numgbits -\n                                 1;\n\n                if (!l_band->precincts && (l_nb_precincts > 0U)) {\n                    l_band->precincts = (opj_tcd_precinct_t *) opj_malloc(/*3 * */\n                                            l_nb_precinct_size);\n                    if (! l_band->precincts) {\n                        opj_event_msg(manager, EVT_ERROR,\n                                      \"Not enough memory to handle band precints\\n\");\n                        return OPJ_FALSE;\n                    }\n                    /*fprintf(stderr, \"\\t\\t\\t\\tAllocate precincts of a band (opj_tcd_precinct_t): %d\\n\",l_nb_precinct_size);     */\n                    memset(l_band->precincts, 0, l_nb_precinct_size);\n                    l_band->precincts_data_size = l_nb_precinct_size;\n                } else if (l_band->precincts_data_size < l_nb_precinct_size) {\n\n                    opj_tcd_precinct_t * new_precincts = (opj_tcd_precinct_t *) opj_realloc(\n                            l_band->precincts,/*3 * */ l_nb_precinct_size);\n                    if (! new_precincts) {\n                        opj_event_msg(manager, EVT_ERROR,\n                                      \"Not enough memory to handle band precints\\n\");\n                        opj_free(l_band->precincts);\n                        l_band->precincts = NULL;\n                        l_band->precincts_data_size = 0;\n                        return OPJ_FALSE;\n                    }\n                    l_band->precincts = new_precincts;\n                    /*fprintf(stderr, \"\\t\\t\\t\\tReallocate precincts of a band (opj_tcd_precinct_t): from %d to %d\\n\",l_band->precincts_data_size, l_nb_precinct_size);*/\n                    memset(((OPJ_BYTE *) l_band->precincts) + l_band->precincts_data_size, 0,\n                           l_nb_precinct_size - l_band->precincts_data_size);\n                    l_band->precincts_data_size = l_nb_precinct_size;\n                }\n\n                l_current_precinct = l_band->precincts;\n                for (precno = 0; precno < l_nb_precincts; ++precno) {\n                    OPJ_INT32 tlcblkxstart, tlcblkystart, brcblkxend, brcblkyend;\n                    OPJ_INT32 cbgxstart = tlcbgxstart + (OPJ_INT32)(precno % l_res->pw) *\n                                          (1 << cbgwidthexpn);\n                    OPJ_INT32 cbgystart = tlcbgystart + (OPJ_INT32)(precno / l_res->pw) *\n                                          (1 << cbgheightexpn);\n                    OPJ_INT32 cbgxend = cbgxstart + (1 << cbgwidthexpn);\n                    OPJ_INT32 cbgyend = cbgystart + (1 << cbgheightexpn);\n                    /*fprintf(stderr, \"\\t precno=%d; bandno=%d, resno=%d; compno=%d\\n\", precno, bandno , resno, compno);*/\n                    /*fprintf(stderr, \"\\t tlcbgxstart(=%d) + (precno(=%d) percent res->pw(=%d)) * (1 << cbgwidthexpn(=%d)) \\n\",tlcbgxstart,precno,l_res->pw,cbgwidthexpn);*/\n\n                    /* precinct size (global) */\n                    /*fprintf(stderr, \"\\t cbgxstart=%d, l_band->x0 = %d \\n\",cbgxstart, l_band->x0);*/\n\n                    l_current_precinct->x0 = opj_int_max(cbgxstart, l_band->x0);\n                    l_current_precinct->y0 = opj_int_max(cbgystart, l_band->y0);\n                    l_current_precinct->x1 = opj_int_min(cbgxend, l_band->x1);\n                    l_current_precinct->y1 = opj_int_min(cbgyend, l_band->y1);\n                    /*fprintf(stderr, \"\\t prc_x0=%d; prc_y0=%d, prc_x1=%d; prc_y1=%d\\n\",l_current_precinct->x0, l_current_precinct->y0 ,l_current_precinct->x1, l_current_precinct->y1);*/\n\n                    tlcblkxstart = opj_int_floordivpow2(l_current_precinct->x0,\n                                                        (OPJ_INT32)cblkwidthexpn) << cblkwidthexpn;\n                    /*fprintf(stderr, \"\\t tlcblkxstart =%d\\n\",tlcblkxstart );*/\n                    tlcblkystart = opj_int_floordivpow2(l_current_precinct->y0,\n                                                        (OPJ_INT32)cblkheightexpn) << cblkheightexpn;\n                    /*fprintf(stderr, \"\\t tlcblkystart =%d\\n\",tlcblkystart );*/\n                    brcblkxend = opj_int_ceildivpow2(l_current_precinct->x1,\n                                                     (OPJ_INT32)cblkwidthexpn) << cblkwidthexpn;\n                    /*fprintf(stderr, \"\\t brcblkxend =%d\\n\",brcblkxend );*/\n                    brcblkyend = opj_int_ceildivpow2(l_current_precinct->y1,\n                                                     (OPJ_INT32)cblkheightexpn) << cblkheightexpn;\n                    /*fprintf(stderr, \"\\t brcblkyend =%d\\n\",brcblkyend );*/\n                    l_current_precinct->cw = (OPJ_UINT32)((brcblkxend - tlcblkxstart) >>\n                                                          cblkwidthexpn);\n                    l_current_precinct->ch = (OPJ_UINT32)((brcblkyend - tlcblkystart) >>\n                                                          cblkheightexpn);\n\n                    l_nb_code_blocks = l_current_precinct->cw * l_current_precinct->ch;\n                    /*fprintf(stderr, \"\\t\\t\\t\\t precinct_cw = %d x recinct_ch = %d\\n\",l_current_precinct->cw, l_current_precinct->ch);      */\n                    if ((((OPJ_UINT32) - 1) / (OPJ_UINT32)sizeof_block) <\n                            l_nb_code_blocks) {\n                        opj_event_msg(manager, EVT_ERROR,\n                                      \"Size of code block data exceeds system limits\\n\");\n                        return OPJ_FALSE;\n                    }\n                    l_nb_code_blocks_size = l_nb_code_blocks * (OPJ_UINT32)sizeof_block;\n\n                    if (!l_current_precinct->cblks.blocks && (l_nb_code_blocks > 0U)) {\n                        l_current_precinct->cblks.blocks = opj_malloc(l_nb_code_blocks_size);\n                        if (! l_current_precinct->cblks.blocks) {\n                            return OPJ_FALSE;\n                        }\n                        /*fprintf(stderr, \"\\t\\t\\t\\tAllocate cblks of a precinct (opj_tcd_cblk_dec_t): %d\\n\",l_nb_code_blocks_size);*/\n\n                        memset(l_current_precinct->cblks.blocks, 0, l_nb_code_blocks_size);\n\n                        l_current_precinct->block_size = l_nb_code_blocks_size;\n                    } else if (l_nb_code_blocks_size > l_current_precinct->block_size) {\n                        void *new_blocks = opj_realloc(l_current_precinct->cblks.blocks,\n                                                       l_nb_code_blocks_size);\n                        if (! new_blocks) {\n                            opj_free(l_current_precinct->cblks.blocks);\n                            l_current_precinct->cblks.blocks = NULL;\n                            l_current_precinct->block_size = 0;\n                            opj_event_msg(manager, EVT_ERROR,\n                                          \"Not enough memory for current precinct codeblock element\\n\");\n                            return OPJ_FALSE;\n                        }\n                        l_current_precinct->cblks.blocks = new_blocks;\n                        /*fprintf(stderr, \"\\t\\t\\t\\tReallocate cblks of a precinct (opj_tcd_cblk_dec_t): from %d to %d\\n\",l_current_precinct->block_size, l_nb_code_blocks_size);     */\n\n                        memset(((OPJ_BYTE *) l_current_precinct->cblks.blocks) +\n                               l_current_precinct->block_size\n                               , 0\n                               , l_nb_code_blocks_size - l_current_precinct->block_size);\n\n                        l_current_precinct->block_size = l_nb_code_blocks_size;\n                    }\n\n                    if (! l_current_precinct->incltree) {\n                        l_current_precinct->incltree = opj_tgt_create(l_current_precinct->cw,\n                                                       l_current_precinct->ch, manager);\n                    } else {\n                        l_current_precinct->incltree = opj_tgt_init(l_current_precinct->incltree,\n                                                       l_current_precinct->cw, l_current_precinct->ch, manager);\n                    }\n\n                    if (! l_current_precinct->imsbtree) {\n                        l_current_precinct->imsbtree = opj_tgt_create(l_current_precinct->cw,\n                                                       l_current_precinct->ch, manager);\n                    } else {\n                        l_current_precinct->imsbtree = opj_tgt_init(l_current_precinct->imsbtree,\n                                                       l_current_precinct->cw, l_current_precinct->ch, manager);\n                    }\n\n                    for (cblkno = 0; cblkno < l_nb_code_blocks; ++cblkno) {\n                        OPJ_INT32 cblkxstart = tlcblkxstart + (OPJ_INT32)(cblkno %\n                                               l_current_precinct->cw) * (1 << cblkwidthexpn);\n                        OPJ_INT32 cblkystart = tlcblkystart + (OPJ_INT32)(cblkno /\n                                               l_current_precinct->cw) * (1 << cblkheightexpn);\n                        OPJ_INT32 cblkxend = cblkxstart + (1 << cblkwidthexpn);\n                        OPJ_INT32 cblkyend = cblkystart + (1 << cblkheightexpn);\n\n                        if (isEncoder) {\n                            opj_tcd_cblk_enc_t* l_code_block = l_current_precinct->cblks.enc + cblkno;\n\n                            if (! opj_tcd_code_block_enc_allocate(l_code_block)) {\n                                return OPJ_FALSE;\n                            }\n                            /* code-block size (global) */\n                            l_code_block->x0 = opj_int_max(cblkxstart, l_current_precinct->x0);\n                            l_code_block->y0 = opj_int_max(cblkystart, l_current_precinct->y0);\n                            l_code_block->x1 = opj_int_min(cblkxend, l_current_precinct->x1);\n                            l_code_block->y1 = opj_int_min(cblkyend, l_current_precinct->y1);\n\n                            if (! opj_tcd_code_block_enc_allocate_data(l_code_block)) {\n                                return OPJ_FALSE;\n                            }\n                        } else {\n                            opj_tcd_cblk_dec_t* l_code_block = l_current_precinct->cblks.dec + cblkno;\n\n                            if (! opj_tcd_code_block_dec_allocate(l_code_block)) {\n                                return OPJ_FALSE;\n                            }\n                            /* code-block size (global) */\n                            l_code_block->x0 = opj_int_max(cblkxstart, l_current_precinct->x0);\n                            l_code_block->y0 = opj_int_max(cblkystart, l_current_precinct->y0);\n                            l_code_block->x1 = opj_int_min(cblkxend, l_current_precinct->x1);\n                            l_code_block->y1 = opj_int_min(cblkyend, l_current_precinct->y1);\n                        }\n                    }\n                    ++l_current_precinct;\n                } /* precno */\n            } /* bandno */\n            ++l_res;\n        } /* resno */\n        ++l_tccp;\n        ++l_tilec;\n        ++l_image_comp;\n    } /* compno */\n    return OPJ_TRUE;\n}",
  "abstract_func_before": "static INLINE VAR_0 opj_tcd_init_tile(opj_tcd_t *VAR_1, OPJ_UINT32 VAR_2,\n        OPJ_BOOL VAR_3, OPJ_FLOAT32 VAR_4, OPJ_SIZE_T VAR_5,\n        opj_event_mgr_t* VAR_6)\n{\n    OPJ_UINT32(*VAR_7)(OPJ_UINT32) = 00;\n    OPJ_UINT32 VAR_8, VAR_9, VAR_10, VAR_11, VAR_12;\n    opj_tcp_t * VAR_13 = 00;\n    opj_cp_t * VAR_14 = 00;\n    opj_tcd_tile_t * VAR_15 = 00;\n    opj_tccp_t *VAR_16 = 00;\n    opj_tcd_tilecomp_t *VAR_17 = 00;\n    opj_image_comp_t * VAR_18 = 00;\n    opj_tcd_resolution_t *VAR_19 = 00;\n    opj_tcd_band_t *VAR_20 = 00;\n    opj_stepsize_t * VAR_21 = 00;\n    opj_tcd_precinct_t *VAR_22 = 00;\n    opj_image_t *VAR_23 = 00;\n    OPJ_UINT32 VAR_24, VAR_25;\n    OPJ_UINT32 VAR_26;\n    OPJ_UINT32 VAR_27, VAR_28;\n    OPJ_UINT32 VAR_29;\n    OPJ_INT32 VAR_30, VAR_31;\n    OPJ_UINT32 VAR_32, VAR_33;\n    /* COMMENT_0 */\n    OPJ_INT32 VAR_34, VAR_35, VAR_36, VAR_37;\n    /* COMMENT_1 */\n    OPJ_UINT32 VAR_38;\n    /* COMMENT_2 */\n    OPJ_UINT32 VAR_39;\n    /* COMMENT_3 */\n    OPJ_UINT32 VAR_40;\n    /* COMMENT_4 */\n    OPJ_UINT32 VAR_41;\n    /* COMMENT_5 */\n    OPJ_UINT32 VAR_42;\n\n    VAR_14 = VAR_1->cp;\n    VAR_13 = &(VAR_14->tcps[VAR_2]);\n    VAR_15 = VAR_1->tcd_image->tiles;\n    VAR_16 = VAR_13->tccps;\n    VAR_17 = VAR_15->comps;\n    VAR_23 = VAR_1->image;\n    VAR_18 = VAR_1->image->comps;\n\n    VAR_24 = VAR_2 % VAR_14->tw;       /* COMMENT_6 */\n    VAR_25 = VAR_2 / VAR_14->tw;\n    /* COMMENT_7 */\n\n    /* COMMENT_8 */\n    VAR_32 = VAR_14->tx0 + VAR_24 *\n            VAR_14->tdx; /* COMMENT_9 */\n    VAR_15->x0 = (OPJ_INT32)opj_uint_max(VAR_32, VAR_23->x0);\n    VAR_15->x1 = (OPJ_INT32)opj_uint_min(opj_uint_adds(VAR_32, VAR_14->tdx),\n                                         VAR_23->x1);\n    /* COMMENT_10 */\n    if ((VAR_15->x0 < 0) || (VAR_15->x1 <= VAR_15->x0)) {\n        opj_event_msg(VAR_6, VAR_43, \"Tile X coordinates are not supported\\n\");\n        return VAR_44;\n    }\n    VAR_33 = VAR_14->ty0 + VAR_25 *\n            VAR_14->tdy; /* COMMENT_11 */\n    VAR_15->y0 = (OPJ_INT32)opj_uint_max(VAR_33, VAR_23->y0);\n    VAR_15->y1 = (OPJ_INT32)opj_uint_min(opj_uint_adds(VAR_33, VAR_14->tdy),\n                                         VAR_23->y1);\n    /* COMMENT_10 */\n    if ((VAR_15->y0 < 0) || (VAR_15->y1 <= VAR_15->y0)) {\n        opj_event_msg(VAR_6, VAR_43, \"Tile Y coordinates are not supported\\n\");\n        return VAR_44;\n    }\n\n\n    /* COMMENT_12 */\n    if (VAR_16->numresolutions == 0) {\n        opj_event_msg(VAR_6, VAR_43, \"tiles require at least one resolution\\n\");\n        return VAR_44;\n    }\n    /* COMMENT_13 */\n\n    /* COMMENT_14 */\n    for (VAR_8 = 0; VAR_8 < VAR_15->numcomps; ++VAR_8) {\n        /* COMMENT_15 */\n        VAR_18->resno_decoded = 0;\n        /* COMMENT_16 */\n        VAR_17->x0 = opj_int_ceildiv(VAR_15->x0, (OPJ_INT32)VAR_18->dx);\n        VAR_17->y0 = opj_int_ceildiv(VAR_15->y0, (OPJ_INT32)VAR_18->dy);\n        VAR_17->x1 = opj_int_ceildiv(VAR_15->x1, (OPJ_INT32)VAR_18->dx);\n        VAR_17->y1 = opj_int_ceildiv(VAR_15->y1, (OPJ_INT32)VAR_18->dy);\n        VAR_17->compno = VAR_8;\n        /* COMMENT_17 */\n\n        VAR_17->numresolutions = VAR_16->numresolutions;\n        if (VAR_16->numresolutions < VAR_14->m_specific_param.m_dec.m_reduce) {\n            VAR_17->minimum_num_resolutions = 1;\n        } else {\n            VAR_17->minimum_num_resolutions = VAR_16->numresolutions -\n                                               VAR_14->m_specific_param.m_dec.m_reduce;\n        }\n\n        if (VAR_3) {\n            OPJ_SIZE_T VAR_45;\n\n            /* COMMENT_18 */\n            OPJ_SIZE_T VAR_46 = (OPJ_SIZE_T)(VAR_17->x1 - VAR_17->x0);\n            OPJ_SIZE_T VAR_47 = (OPJ_SIZE_T)(VAR_17->y1 - VAR_17->y0);\n\n            /* COMMENT_19 */\n            if (VAR_47 > 0 && VAR_46 > VAR_48 / VAR_47) {\n                opj_event_msg(VAR_6, VAR_43, \"Size of tile data exceeds system limits\\n\");\n                return VAR_44;\n            }\n            VAR_45 = VAR_46 * VAR_47;\n\n            if (VAR_48 / sizeof(OPJ_UINT32) < VAR_45) {\n                opj_event_msg(VAR_6, VAR_43, \"Size of tile data exceeds system limits\\n\");\n                return VAR_44;\n            }\n            VAR_45 = VAR_45 * sizeof(OPJ_UINT32);\n\n            VAR_17->data_size_needed = VAR_45;\n        }\n\n        VAR_42 = VAR_17->numresolutions * (OPJ_UINT32)sizeof(\n                          opj_tcd_resolution_t);\n\n        opj_image_data_free(VAR_17->data_win);\n        VAR_17->data_win = NULL;\n        VAR_17->win_x0 = 0;\n        VAR_17->win_y0 = 0;\n        VAR_17->win_x1 = 0;\n        VAR_17->win_y1 = 0;\n\n        if (VAR_17->resolutions == 00) {\n            VAR_17->resolutions = (opj_tcd_resolution_t *) opj_malloc(VAR_42);\n            if (! VAR_17->resolutions) {\n                return VAR_44;\n            }\n            /* COMMENT_20 */\n            VAR_17->resolutions_size = VAR_42;\n            memset(VAR_17->resolutions, 0, VAR_42);\n        } else if (VAR_42 > VAR_17->resolutions_size) {\n            opj_tcd_resolution_t* VAR_49 = (opj_tcd_resolution_t *) opj_realloc(\n                    VAR_17->resolutions, VAR_42);\n            if (! VAR_49) {\n                opj_event_msg(VAR_6, VAR_43, \"Not enough memory for tile resolutions\\n\");\n                opj_free(VAR_17->resolutions);\n                VAR_17->resolutions = NULL;\n                VAR_17->resolutions_size = 0;\n                return VAR_44;\n            }\n            VAR_17->resolutions = VAR_49;\n            /* COMMENT_21 */\n            memset(((OPJ_BYTE*) VAR_17->resolutions) + VAR_17->resolutions_size, 0,\n                   VAR_42 - VAR_17->resolutions_size);\n            VAR_17->resolutions_size = VAR_42;\n        }\n\n        VAR_26 = VAR_17->numresolutions;\n        VAR_19 = VAR_17->resolutions;\n        VAR_21 = VAR_16->stepsizes;\n        if (VAR_16->qmfbid == 0) {\n            VAR_7 = &VAR_50;\n        } else {\n            VAR_7  = &VAR_51;\n        }\n        /* COMMENT_22 */\n\n        for (VAR_9 = 0; VAR_9 < VAR_17->numresolutions; ++VAR_9) {\n            /* COMMENT_23 */\n            OPJ_INT32 VAR_52, VAR_53 /* COMMENT_24 */;\n            OPJ_UINT32 VAR_54, VAR_55;\n            OPJ_UINT32 VAR_56, VAR_57;\n\n            --VAR_26;\n\n            /* COMMENT_25 */\n            VAR_19->x0 = opj_int_ceildivpow2(VAR_17->x0, (OPJ_INT32)VAR_26);\n            VAR_19->y0 = opj_int_ceildivpow2(VAR_17->y0, (OPJ_INT32)VAR_26);\n            VAR_19->x1 = opj_int_ceildivpow2(VAR_17->x1, (OPJ_INT32)VAR_26);\n            VAR_19->y1 = opj_int_ceildivpow2(VAR_17->y1, (OPJ_INT32)VAR_26);\n\n            /* COMMENT_26 */\n            /* COMMENT_27 */\n            VAR_27 = VAR_16->prcw[VAR_9];\n            VAR_28 = VAR_16->prch[VAR_9];\n            /* COMMENT_28 */\n            /* COMMENT_29 */\n            VAR_34 = opj_int_floordivpow2(VAR_19->x0, (OPJ_INT32)VAR_27) << VAR_27;\n            VAR_35 = opj_int_floordivpow2(VAR_19->y0, (OPJ_INT32)VAR_28) << VAR_28;\n            VAR_36 = opj_int_ceildivpow2(VAR_19->x1, (OPJ_INT32)VAR_27) << VAR_27;\n            VAR_37 = opj_int_ceildivpow2(VAR_19->y1, (OPJ_INT32)VAR_28) << VAR_28;\n            /* COMMENT_30 */\n\n            VAR_19->pw = (VAR_19->x0 == VAR_19->x1) ? 0U : (OPJ_UINT32)((\n                            VAR_36 - VAR_34) >> VAR_27);\n            VAR_19->ph = (VAR_19->y0 == VAR_19->y1) ? 0U : (OPJ_UINT32)((\n                            VAR_37 - VAR_35) >> VAR_28);\n            /* COMMENT_31 */\n\n            if ((VAR_19->pw != 0U) && ((((OPJ_UINT32) - 1) / VAR_19->pw) < VAR_19->ph)) {\n                opj_event_msg(VAR_6, VAR_43, \"Size of tile data exceeds system limits\\n\");\n                return VAR_44;\n            }\n            VAR_38 = VAR_19->pw * VAR_19->ph;\n\n            if ((((OPJ_UINT32) - 1) / (OPJ_UINT32)sizeof(opj_tcd_precinct_t)) <\n                    VAR_38) {\n                opj_event_msg(VAR_6, VAR_43, \"Size of tile data exceeds system limits\\n\");\n                return VAR_44;\n            }\n            VAR_39 = VAR_38 * (OPJ_UINT32)sizeof(opj_tcd_precinct_t);\n\n            if (VAR_9 == 0) {\n                VAR_52 = VAR_34;\n                VAR_53 = VAR_35;\n                /* COMMENT_32 */\n                /* COMMENT_33 */\n                VAR_54 = VAR_27;\n                VAR_55 = VAR_28;\n                VAR_19->numbands = 1;\n            } else {\n                VAR_52 = opj_int_ceildivpow2(VAR_34, 1);\n                VAR_53 = opj_int_ceildivpow2(VAR_35, 1);\n                /* COMMENT_34 */\n                /* COMMENT_35 */\n                VAR_54 = VAR_27 - 1;\n                VAR_55 = VAR_28 - 1;\n                VAR_19->numbands = 3;\n            }\n\n            VAR_56 = opj_uint_min(VAR_16->cblkw, VAR_54);\n            VAR_57 = opj_uint_min(VAR_16->cblkh, VAR_55);\n            VAR_20 = VAR_19->bands;\n\n            for (VAR_10 = 0; VAR_10 < VAR_19->numbands; ++VAR_10, ++VAR_20, ++VAR_21) {\n                OPJ_INT32 VAR_58;\n                /* COMMENT_36 */\n\n                if (VAR_9 == 0) {\n                    VAR_20->bandno = 0 ;\n                    VAR_20->x0 = opj_int_ceildivpow2(VAR_17->x0, (OPJ_INT32)VAR_26);\n                    VAR_20->y0 = opj_int_ceildivpow2(VAR_17->y0, (OPJ_INT32)VAR_26);\n                    VAR_20->x1 = opj_int_ceildivpow2(VAR_17->x1, (OPJ_INT32)VAR_26);\n                    VAR_20->y1 = opj_int_ceildivpow2(VAR_17->y1, (OPJ_INT32)VAR_26);\n                } else {\n                    VAR_20->bandno = VAR_10 + 1;\n                    /* COMMENT_37 */\n                    VAR_30 = VAR_20->bandno & 1;\n                    /* COMMENT_38 */\n                    VAR_31 = (OPJ_INT32)((VAR_20->bandno) >> 1);\n                    /* COMMENT_39 */\n                    VAR_20->x0 = opj_int64_ceildivpow2(VAR_17->x0 - ((OPJ_INT64)VAR_30 <<\n                                                       VAR_26), (OPJ_INT32)(VAR_26 + 1));\n                    VAR_20->y0 = opj_int64_ceildivpow2(VAR_17->y0 - ((OPJ_INT64)VAR_31 <<\n                                                       VAR_26), (OPJ_INT32)(VAR_26 + 1));\n                    VAR_20->x1 = opj_int64_ceildivpow2(VAR_17->x1 - ((OPJ_INT64)VAR_30 <<\n                                                       VAR_26), (OPJ_INT32)(VAR_26 + 1));\n                    VAR_20->y1 = opj_int64_ceildivpow2(VAR_17->y1 - ((OPJ_INT64)VAR_31 <<\n                                                       VAR_26), (OPJ_INT32)(VAR_26 + 1));\n                }\n\n                if (VAR_3) {\n                    /* COMMENT_40 */\n                    if (opj_tcd_is_band_empty(VAR_20)) {\n                        /* COMMENT_41 */\n                        /* COMMENT_42 */\n                        /* COMMENT_43 */\n                        continue;\n                    }\n                }\n\n                /* COMMENT_44 */\n                VAR_29 = (*VAR_7)(VAR_20->bandno);\n                VAR_58 = (OPJ_INT32)(VAR_18->prec + VAR_29);\n                VAR_20->stepsize = (OPJ_FLOAT32)(((1.0 + VAR_21->mant / 2048.0) * pow(2.0,\n                                                  (OPJ_INT32)(VAR_58 - VAR_21->expn)))) * VAR_4;\n                /* COMMENT_45 */\n                                                \n                VAR_20->numbps = VAR_21->expn + (OPJ_INT32)VAR_16->numgbits -\n                                 1;\n\n                if (!VAR_20->precincts && (VAR_38 > 0U)) {\n                    VAR_20->precincts = (opj_tcd_precinct_t *) opj_malloc(/* COMMENT_47 */\n                                            VAR_39);\n                    if (! VAR_20->precincts) {\n                        opj_event_msg(VAR_6, VAR_43,\n                                      \"Not enough memory to handle band precints\\n\");\n                        return VAR_44;\n                    }\n                    /* COMMENT_48 */\n                    memset(VAR_20->precincts, 0, VAR_39);\n                    VAR_20->precincts_data_size = VAR_39;\n                } else if (VAR_20->precincts_data_size < VAR_39) {\n\n                    opj_tcd_precinct_t * VAR_59 = (opj_tcd_precinct_t *) opj_realloc(\n                            VAR_20->precincts,/* COMMENT_47 */ VAR_39);\n                    if (! VAR_59) {\n                        opj_event_msg(VAR_6, VAR_43,\n                                      \"Not enough memory to handle band precints\\n\");\n                        opj_free(VAR_20->precincts);\n                        VAR_20->precincts = NULL;\n                        VAR_20->precincts_data_size = 0;\n                        return VAR_44;\n                    }\n                    VAR_20->precincts = VAR_59;\n                    /* COMMENT_49 */\n                    memset(((OPJ_BYTE *) VAR_20->precincts) + VAR_20->precincts_data_size, 0,\n                           VAR_39 - VAR_20->precincts_data_size);\n                    VAR_20->precincts_data_size = VAR_39;\n                }\n\n                VAR_22 = VAR_20->precincts;\n                for (VAR_11 = 0; VAR_11 < VAR_38; ++VAR_11) {\n                    OPJ_INT32 VAR_60, VAR_61, VAR_62, VAR_63;\n                    OPJ_INT32 VAR_64 = VAR_52 + (OPJ_INT32)(VAR_11 % VAR_19->pw) *\n                                          (1 << VAR_54);\n                    OPJ_INT32 VAR_65 = VAR_53 + (OPJ_INT32)(VAR_11 / VAR_19->pw) *\n                                          (1 << VAR_55);\n                    OPJ_INT32 VAR_66 = VAR_64 + (1 << VAR_54);\n                    OPJ_INT32 VAR_67 = VAR_65 + (1 << VAR_55);\n                    /* COMMENT_50 */\n                    /* COMMENT_51 */\n\n                    /* COMMENT_52 */\n                    /* COMMENT_53 */\n\n                    VAR_22->x0 = opj_int_max(VAR_64, VAR_20->x0);\n                    VAR_22->y0 = opj_int_max(VAR_65, VAR_20->y0);\n                    VAR_22->x1 = opj_int_min(VAR_66, VAR_20->x1);\n                    VAR_22->y1 = opj_int_min(VAR_67, VAR_20->y1);\n                    /* COMMENT_54 */\n\n                    VAR_60 = opj_int_floordivpow2(VAR_22->x0,\n                                                        (OPJ_INT32)VAR_56) << VAR_56;\n                    /* COMMENT_55 */\n                    VAR_61 = opj_int_floordivpow2(VAR_22->y0,\n                                                        (OPJ_INT32)VAR_57) << VAR_57;\n                    /* COMMENT_56 */\n                    VAR_62 = opj_int_ceildivpow2(VAR_22->x1,\n                                                     (OPJ_INT32)VAR_56) << VAR_56;\n                    /* COMMENT_57 */\n                    VAR_63 = opj_int_ceildivpow2(VAR_22->y1,\n                                                     (OPJ_INT32)VAR_57) << VAR_57;\n                    /* COMMENT_58 */\n                    VAR_22->cw = (OPJ_UINT32)((VAR_62 - VAR_60) >>\n                                                          VAR_56);\n                    VAR_22->ch = (OPJ_UINT32)((VAR_63 - VAR_61) >>\n                                                          VAR_57);\n\n                    VAR_40 = VAR_22->cw * VAR_22->ch;\n                    /* COMMENT_59 */\n                    if ((((OPJ_UINT32) - 1) / (OPJ_UINT32)VAR_5) <\n                            VAR_40) {\n                        opj_event_msg(VAR_6, VAR_43,\n                                      \"Size of code block data exceeds system limits\\n\");\n                        return VAR_44;\n                    }\n                    VAR_41 = VAR_40 * (OPJ_UINT32)VAR_5;\n\n                    if (!VAR_22->cblks.blocks && (VAR_40 > 0U)) {\n                        VAR_22->cblks.blocks = opj_malloc(VAR_41);\n                        if (! VAR_22->cblks.blocks) {\n                            return VAR_44;\n                        }\n                        /* COMMENT_60 */\n\n                        memset(VAR_22->cblks.blocks, 0, VAR_41);\n\n                        VAR_22->block_size = VAR_41;\n                    } else if (VAR_41 > VAR_22->block_size) {\n                        void *VAR_68 = opj_realloc(VAR_22->cblks.blocks,\n                                                       VAR_41);\n                        if (! VAR_68) {\n                            opj_free(VAR_22->cblks.blocks);\n                            VAR_22->cblks.blocks = NULL;\n                            VAR_22->block_size = 0;\n                            opj_event_msg(VAR_6, VAR_43,\n                                          \"Not enough memory for current precinct codeblock element\\n\");\n                            return VAR_44;\n                        }\n                        VAR_22->cblks.blocks = VAR_68;\n                        /* COMMENT_61 */\n\n                        memset(((OPJ_BYTE *) VAR_22->cblks.blocks) +\n                               VAR_22->block_size\n                               , 0\n                               , VAR_41 - VAR_22->block_size);\n\n                        VAR_22->block_size = VAR_41;\n                    }\n\n                    if (! VAR_22->incltree) {\n                        VAR_22->incltree = opj_tgt_create(VAR_22->cw,\n                                                       VAR_22->ch, VAR_6);\n                    } else {\n                        VAR_22->incltree = opj_tgt_init(VAR_22->incltree,\n                                                       VAR_22->cw, VAR_22->ch, VAR_6);\n                    }\n\n                    if (! VAR_22->imsbtree) {\n                        VAR_22->imsbtree = opj_tgt_create(VAR_22->cw,\n                                                       VAR_22->ch, VAR_6);\n                    } else {\n                        VAR_22->imsbtree = opj_tgt_init(VAR_22->imsbtree,\n                                                       VAR_22->cw, VAR_22->ch, VAR_6);\n                    }\n\n                    for (VAR_12 = 0; VAR_12 < VAR_40; ++VAR_12) {\n                        OPJ_INT32 VAR_69 = VAR_60 + (OPJ_INT32)(VAR_12 %\n                                               VAR_22->cw) * (1 << VAR_56);\n                        OPJ_INT32 VAR_70 = VAR_61 + (OPJ_INT32)(VAR_12 /\n                                               VAR_22->cw) * (1 << VAR_57);\n                        OPJ_INT32 VAR_71 = VAR_69 + (1 << VAR_56);\n                        OPJ_INT32 VAR_72 = VAR_70 + (1 << VAR_57);\n\n                        if (VAR_3) {\n                            opj_tcd_cblk_enc_t* VAR_73 = VAR_22->cblks.enc + VAR_12;\n\n                            if (! opj_tcd_code_block_enc_allocate(VAR_73)) {\n                                return VAR_44;\n                            }\n                            /* COMMENT_62 */\n                            VAR_73->x0 = opj_int_max(VAR_69, VAR_22->x0);\n                            VAR_73->y0 = opj_int_max(VAR_70, VAR_22->y0);\n                            VAR_73->x1 = opj_int_min(VAR_71, VAR_22->x1);\n                            VAR_73->y1 = opj_int_min(VAR_72, VAR_22->y1);\n\n                            if (! opj_tcd_code_block_enc_allocate_data(VAR_73)) {\n                                return VAR_44;\n                            }\n                        } else {\n                            opj_tcd_cblk_dec_t* VAR_73 = VAR_22->cblks.dec + VAR_12;\n\n                            if (! opj_tcd_code_block_dec_allocate(VAR_73)) {\n                                return VAR_44;\n                            }\n                            /* COMMENT_62 */\n                            VAR_73->x0 = opj_int_max(VAR_69, VAR_22->x0);\n                            VAR_73->y0 = opj_int_max(VAR_70, VAR_22->y0);\n                            VAR_73->x1 = opj_int_min(VAR_71, VAR_22->x1);\n                            VAR_73->y1 = opj_int_min(VAR_72, VAR_22->y1);\n                        }\n                    }\n                    ++VAR_22;\n                } /* COMMENT_63 */\n            } /* COMMENT_64 */\n            ++VAR_19;\n        } /* COMMENT_65 */\n        ++VAR_16;\n        ++VAR_17;\n        ++VAR_18;\n    } /* COMMENT_66 */\n    return VAR_74;\n}",
  "func_graph_path_before": null,
  "func": "static INLINE OPJ_BOOL opj_tcd_init_tile(opj_tcd_t *p_tcd, OPJ_UINT32 p_tile_no,\n        OPJ_BOOL isEncoder, OPJ_FLOAT32 fraction, OPJ_SIZE_T sizeof_block,\n        opj_event_mgr_t* manager)\n{\n    OPJ_UINT32(*l_gain_ptr)(OPJ_UINT32) = 00;\n    OPJ_UINT32 compno, resno, bandno, precno, cblkno;\n    opj_tcp_t * l_tcp = 00;\n    opj_cp_t * l_cp = 00;\n    opj_tcd_tile_t * l_tile = 00;\n    opj_tccp_t *l_tccp = 00;\n    opj_tcd_tilecomp_t *l_tilec = 00;\n    opj_image_comp_t * l_image_comp = 00;\n    opj_tcd_resolution_t *l_res = 00;\n    opj_tcd_band_t *l_band = 00;\n    opj_stepsize_t * l_step_size = 00;\n    opj_tcd_precinct_t *l_current_precinct = 00;\n    opj_image_t *l_image = 00;\n    OPJ_UINT32 p, q;\n    OPJ_UINT32 l_level_no;\n    OPJ_UINT32 l_pdx, l_pdy;\n    OPJ_UINT32 l_gain;\n    OPJ_INT32 l_x0b, l_y0b;\n    OPJ_UINT32 l_tx0, l_ty0;\n    /* extent of precincts , top left, bottom right**/\n    OPJ_INT32 l_tl_prc_x_start, l_tl_prc_y_start, l_br_prc_x_end, l_br_prc_y_end;\n    /* number of precinct for a resolution */\n    OPJ_UINT32 l_nb_precincts;\n    /* room needed to store l_nb_precinct precinct for a resolution */\n    OPJ_UINT32 l_nb_precinct_size;\n    /* number of code blocks for a precinct*/\n    OPJ_UINT32 l_nb_code_blocks;\n    /* room needed to store l_nb_code_blocks code blocks for a precinct*/\n    OPJ_UINT32 l_nb_code_blocks_size;\n    /* size of data for a tile */\n    OPJ_UINT32 l_data_size;\n\n    l_cp = p_tcd->cp;\n    l_tcp = &(l_cp->tcps[p_tile_no]);\n    l_tile = p_tcd->tcd_image->tiles;\n    l_tccp = l_tcp->tccps;\n    l_tilec = l_tile->comps;\n    l_image = p_tcd->image;\n    l_image_comp = p_tcd->image->comps;\n\n    p = p_tile_no % l_cp->tw;       /* tile coordinates */\n    q = p_tile_no / l_cp->tw;\n    /*fprintf(stderr, \"Tile coordinate = %d,%d\\n\", p, q);*/\n\n    /* 4 borders of the tile rescale on the image if necessary */\n    l_tx0 = l_cp->tx0 + p *\n            l_cp->tdx; /* can't be greater than l_image->x1 so won't overflow */\n    l_tile->x0 = (OPJ_INT32)opj_uint_max(l_tx0, l_image->x0);\n    l_tile->x1 = (OPJ_INT32)opj_uint_min(opj_uint_adds(l_tx0, l_cp->tdx),\n                                         l_image->x1);\n    /* all those OPJ_UINT32 are casted to OPJ_INT32, let's do some sanity check */\n    if ((l_tile->x0 < 0) || (l_tile->x1 <= l_tile->x0)) {\n        opj_event_msg(manager, EVT_ERROR, \"Tile X coordinates are not supported\\n\");\n        return OPJ_FALSE;\n    }\n    l_ty0 = l_cp->ty0 + q *\n            l_cp->tdy; /* can't be greater than l_image->y1 so won't overflow */\n    l_tile->y0 = (OPJ_INT32)opj_uint_max(l_ty0, l_image->y0);\n    l_tile->y1 = (OPJ_INT32)opj_uint_min(opj_uint_adds(l_ty0, l_cp->tdy),\n                                         l_image->y1);\n    /* all those OPJ_UINT32 are casted to OPJ_INT32, let's do some sanity check */\n    if ((l_tile->y0 < 0) || (l_tile->y1 <= l_tile->y0)) {\n        opj_event_msg(manager, EVT_ERROR, \"Tile Y coordinates are not supported\\n\");\n        return OPJ_FALSE;\n    }\n\n\n    /* testcase 1888.pdf.asan.35.988 */\n    if (l_tccp->numresolutions == 0) {\n        opj_event_msg(manager, EVT_ERROR, \"tiles require at least one resolution\\n\");\n        return OPJ_FALSE;\n    }\n    /*fprintf(stderr, \"Tile border = %d,%d,%d,%d\\n\", l_tile->x0, l_tile->y0,l_tile->x1,l_tile->y1);*/\n\n    /*tile->numcomps = image->numcomps; */\n    for (compno = 0; compno < l_tile->numcomps; ++compno) {\n        /*fprintf(stderr, \"compno = %d/%d\\n\", compno, l_tile->numcomps);*/\n        l_image_comp->resno_decoded = 0;\n        /* border of each l_tile component (global) */\n        l_tilec->x0 = opj_int_ceildiv(l_tile->x0, (OPJ_INT32)l_image_comp->dx);\n        l_tilec->y0 = opj_int_ceildiv(l_tile->y0, (OPJ_INT32)l_image_comp->dy);\n        l_tilec->x1 = opj_int_ceildiv(l_tile->x1, (OPJ_INT32)l_image_comp->dx);\n        l_tilec->y1 = opj_int_ceildiv(l_tile->y1, (OPJ_INT32)l_image_comp->dy);\n        l_tilec->compno = compno;\n        /*fprintf(stderr, \"\\tTile compo border = %d,%d,%d,%d\\n\", l_tilec->x0, l_tilec->y0,l_tilec->x1,l_tilec->y1);*/\n\n        l_tilec->numresolutions = l_tccp->numresolutions;\n        if (l_tccp->numresolutions < l_cp->m_specific_param.m_dec.m_reduce) {\n            l_tilec->minimum_num_resolutions = 1;\n        } else {\n            l_tilec->minimum_num_resolutions = l_tccp->numresolutions -\n                                               l_cp->m_specific_param.m_dec.m_reduce;\n        }\n\n        if (isEncoder) {\n            OPJ_SIZE_T l_tile_data_size;\n\n            /* compute l_data_size with overflow check */\n            OPJ_SIZE_T w = (OPJ_SIZE_T)(l_tilec->x1 - l_tilec->x0);\n            OPJ_SIZE_T h = (OPJ_SIZE_T)(l_tilec->y1 - l_tilec->y0);\n\n            /* issue 733, l_data_size == 0U, probably something wrong should be checked before getting here */\n            if (h > 0 && w > SIZE_MAX / h) {\n                opj_event_msg(manager, EVT_ERROR, \"Size of tile data exceeds system limits\\n\");\n                return OPJ_FALSE;\n            }\n            l_tile_data_size = w * h;\n\n            if (SIZE_MAX / sizeof(OPJ_UINT32) < l_tile_data_size) {\n                opj_event_msg(manager, EVT_ERROR, \"Size of tile data exceeds system limits\\n\");\n                return OPJ_FALSE;\n            }\n            l_tile_data_size = l_tile_data_size * sizeof(OPJ_UINT32);\n\n            l_tilec->data_size_needed = l_tile_data_size;\n        }\n\n        l_data_size = l_tilec->numresolutions * (OPJ_UINT32)sizeof(\n                          opj_tcd_resolution_t);\n\n        opj_image_data_free(l_tilec->data_win);\n        l_tilec->data_win = NULL;\n        l_tilec->win_x0 = 0;\n        l_tilec->win_y0 = 0;\n        l_tilec->win_x1 = 0;\n        l_tilec->win_y1 = 0;\n\n        if (l_tilec->resolutions == 00) {\n            l_tilec->resolutions = (opj_tcd_resolution_t *) opj_malloc(l_data_size);\n            if (! l_tilec->resolutions) {\n                return OPJ_FALSE;\n            }\n            /*fprintf(stderr, \"\\tAllocate resolutions of tilec (opj_tcd_resolution_t): %d\\n\",l_data_size);*/\n            l_tilec->resolutions_size = l_data_size;\n            memset(l_tilec->resolutions, 0, l_data_size);\n        } else if (l_data_size > l_tilec->resolutions_size) {\n            opj_tcd_resolution_t* new_resolutions = (opj_tcd_resolution_t *) opj_realloc(\n                    l_tilec->resolutions, l_data_size);\n            if (! new_resolutions) {\n                opj_event_msg(manager, EVT_ERROR, \"Not enough memory for tile resolutions\\n\");\n                opj_free(l_tilec->resolutions);\n                l_tilec->resolutions = NULL;\n                l_tilec->resolutions_size = 0;\n                return OPJ_FALSE;\n            }\n            l_tilec->resolutions = new_resolutions;\n            /*fprintf(stderr, \"\\tReallocate data of tilec (int): from %d to %d x OPJ_UINT32\\n\", l_tilec->resolutions_size, l_data_size);*/\n            memset(((OPJ_BYTE*) l_tilec->resolutions) + l_tilec->resolutions_size, 0,\n                   l_data_size - l_tilec->resolutions_size);\n            l_tilec->resolutions_size = l_data_size;\n        }\n\n        l_level_no = l_tilec->numresolutions;\n        l_res = l_tilec->resolutions;\n        l_step_size = l_tccp->stepsizes;\n        if (l_tccp->qmfbid == 0) {\n            l_gain_ptr = &opj_dwt_getgain_real;\n        } else {\n            l_gain_ptr  = &opj_dwt_getgain;\n        }\n        /*fprintf(stderr, \"\\tlevel_no=%d\\n\",l_level_no);*/\n\n        for (resno = 0; resno < l_tilec->numresolutions; ++resno) {\n            /*fprintf(stderr, \"\\t\\tresno = %d/%d\\n\", resno, l_tilec->numresolutions);*/\n            OPJ_INT32 tlcbgxstart, tlcbgystart /*, brcbgxend, brcbgyend*/;\n            OPJ_UINT32 cbgwidthexpn, cbgheightexpn;\n            OPJ_UINT32 cblkwidthexpn, cblkheightexpn;\n\n            --l_level_no;\n\n            /* border for each resolution level (global) */\n            l_res->x0 = opj_int_ceildivpow2(l_tilec->x0, (OPJ_INT32)l_level_no);\n            l_res->y0 = opj_int_ceildivpow2(l_tilec->y0, (OPJ_INT32)l_level_no);\n            l_res->x1 = opj_int_ceildivpow2(l_tilec->x1, (OPJ_INT32)l_level_no);\n            l_res->y1 = opj_int_ceildivpow2(l_tilec->y1, (OPJ_INT32)l_level_no);\n\n            /*fprintf(stderr, \"\\t\\t\\tres_x0= %d, res_y0 =%d, res_x1=%d, res_y1=%d\\n\", l_res->x0, l_res->y0, l_res->x1, l_res->y1);*/\n            /* p. 35, table A-23, ISO/IEC FDIS154444-1 : 2000 (18 august 2000) */\n            l_pdx = l_tccp->prcw[resno];\n            l_pdy = l_tccp->prch[resno];\n            /*fprintf(stderr, \"\\t\\t\\tpdx=%d, pdy=%d\\n\", l_pdx, l_pdy);*/\n            /* p. 64, B.6, ISO/IEC FDIS15444-1 : 2000 (18 august 2000)  */\n            l_tl_prc_x_start = opj_int_floordivpow2(l_res->x0, (OPJ_INT32)l_pdx) << l_pdx;\n            l_tl_prc_y_start = opj_int_floordivpow2(l_res->y0, (OPJ_INT32)l_pdy) << l_pdy;\n            {\n                OPJ_UINT32 tmp = ((OPJ_UINT32)opj_int_ceildivpow2(l_res->x1,\n                                  (OPJ_INT32)l_pdx)) << l_pdx;\n                if (tmp > (OPJ_UINT32)INT_MAX) {\n                    opj_event_msg(manager, EVT_ERROR, \"Integer overflow\\n\");\n                    return OPJ_FALSE;\n                }\n                l_br_prc_x_end = (OPJ_INT32)tmp;\n            }\n            {\n                OPJ_UINT32 tmp = ((OPJ_UINT32)opj_int_ceildivpow2(l_res->y1,\n                                  (OPJ_INT32)l_pdy)) << l_pdy;\n                if (tmp > (OPJ_UINT32)INT_MAX) {\n                    opj_event_msg(manager, EVT_ERROR, \"Integer overflow\\n\");\n                    return OPJ_FALSE;\n                }\n                l_br_prc_y_end = (OPJ_INT32)tmp;\n            }\n            /*fprintf(stderr, \"\\t\\t\\tprc_x_start=%d, prc_y_start=%d, br_prc_x_end=%d, br_prc_y_end=%d \\n\", l_tl_prc_x_start, l_tl_prc_y_start, l_br_prc_x_end ,l_br_prc_y_end );*/\n\n            l_res->pw = (l_res->x0 == l_res->x1) ? 0U : (OPJ_UINT32)((\n                            l_br_prc_x_end - l_tl_prc_x_start) >> l_pdx);\n            l_res->ph = (l_res->y0 == l_res->y1) ? 0U : (OPJ_UINT32)((\n                            l_br_prc_y_end - l_tl_prc_y_start) >> l_pdy);\n            /*fprintf(stderr, \"\\t\\t\\tres_pw=%d, res_ph=%d\\n\", l_res->pw, l_res->ph );*/\n\n            if ((l_res->pw != 0U) && ((((OPJ_UINT32) - 1) / l_res->pw) < l_res->ph)) {\n                opj_event_msg(manager, EVT_ERROR, \"Size of tile data exceeds system limits\\n\");\n                return OPJ_FALSE;\n            }\n            l_nb_precincts = l_res->pw * l_res->ph;\n\n            if ((((OPJ_UINT32) - 1) / (OPJ_UINT32)sizeof(opj_tcd_precinct_t)) <\n                    l_nb_precincts) {\n                opj_event_msg(manager, EVT_ERROR, \"Size of tile data exceeds system limits\\n\");\n                return OPJ_FALSE;\n            }\n            l_nb_precinct_size = l_nb_precincts * (OPJ_UINT32)sizeof(opj_tcd_precinct_t);\n\n            if (resno == 0) {\n                tlcbgxstart = l_tl_prc_x_start;\n                tlcbgystart = l_tl_prc_y_start;\n                /*brcbgxend = l_br_prc_x_end;*/\n                /* brcbgyend = l_br_prc_y_end;*/\n                cbgwidthexpn = l_pdx;\n                cbgheightexpn = l_pdy;\n                l_res->numbands = 1;\n            } else {\n                tlcbgxstart = opj_int_ceildivpow2(l_tl_prc_x_start, 1);\n                tlcbgystart = opj_int_ceildivpow2(l_tl_prc_y_start, 1);\n                /*brcbgxend = opj_int_ceildivpow2(l_br_prc_x_end, 1);*/\n                /*brcbgyend = opj_int_ceildivpow2(l_br_prc_y_end, 1);*/\n                cbgwidthexpn = l_pdx - 1;\n                cbgheightexpn = l_pdy - 1;\n                l_res->numbands = 3;\n            }\n\n            cblkwidthexpn = opj_uint_min(l_tccp->cblkw, cbgwidthexpn);\n            cblkheightexpn = opj_uint_min(l_tccp->cblkh, cbgheightexpn);\n            l_band = l_res->bands;\n\n            for (bandno = 0; bandno < l_res->numbands; ++bandno, ++l_band, ++l_step_size) {\n                OPJ_INT32 numbps;\n                /*fprintf(stderr, \"\\t\\t\\tband_no=%d/%d\\n\", bandno, l_res->numbands );*/\n\n                if (resno == 0) {\n                    l_band->bandno = 0 ;\n                    l_band->x0 = opj_int_ceildivpow2(l_tilec->x0, (OPJ_INT32)l_level_no);\n                    l_band->y0 = opj_int_ceildivpow2(l_tilec->y0, (OPJ_INT32)l_level_no);\n                    l_band->x1 = opj_int_ceildivpow2(l_tilec->x1, (OPJ_INT32)l_level_no);\n                    l_band->y1 = opj_int_ceildivpow2(l_tilec->y1, (OPJ_INT32)l_level_no);\n                } else {\n                    l_band->bandno = bandno + 1;\n                    /* x0b = 1 if bandno = 1 or 3 */\n                    l_x0b = l_band->bandno & 1;\n                    /* y0b = 1 if bandno = 2 or 3 */\n                    l_y0b = (OPJ_INT32)((l_band->bandno) >> 1);\n                    /* l_band border (global) */\n                    l_band->x0 = opj_int64_ceildivpow2(l_tilec->x0 - ((OPJ_INT64)l_x0b <<\n                                                       l_level_no), (OPJ_INT32)(l_level_no + 1));\n                    l_band->y0 = opj_int64_ceildivpow2(l_tilec->y0 - ((OPJ_INT64)l_y0b <<\n                                                       l_level_no), (OPJ_INT32)(l_level_no + 1));\n                    l_band->x1 = opj_int64_ceildivpow2(l_tilec->x1 - ((OPJ_INT64)l_x0b <<\n                                                       l_level_no), (OPJ_INT32)(l_level_no + 1));\n                    l_band->y1 = opj_int64_ceildivpow2(l_tilec->y1 - ((OPJ_INT64)l_y0b <<\n                                                       l_level_no), (OPJ_INT32)(l_level_no + 1));\n                }\n\n                if (isEncoder) {\n                    /* Skip empty bands */\n                    if (opj_tcd_is_band_empty(l_band)) {\n                        /* Do not zero l_band->precints to avoid leaks */\n                        /* but make sure we don't use it later, since */\n                        /* it will point to precincts of previous bands... */\n                        continue;\n                    }\n                }\n\n                /** avoid an if with storing function pointer */\n                l_gain = (*l_gain_ptr)(l_band->bandno);\n                numbps = (OPJ_INT32)(l_image_comp->prec + l_gain);\n                l_band->stepsize = (OPJ_FLOAT32)(((1.0 + l_step_size->mant / 2048.0) * pow(2.0,\n                                                  (OPJ_INT32)(numbps - l_step_size->expn)))) * fraction;\n                /* Mb value of Equation E-2 in \"E.1 Inverse quantization\n                 * procedure\" of the standard */\n                l_band->numbps = l_step_size->expn + (OPJ_INT32)l_tccp->numgbits -\n                                 1;\n\n                if (!l_band->precincts && (l_nb_precincts > 0U)) {\n                    l_band->precincts = (opj_tcd_precinct_t *) opj_malloc(/*3 * */\n                                            l_nb_precinct_size);\n                    if (! l_band->precincts) {\n                        opj_event_msg(manager, EVT_ERROR,\n                                      \"Not enough memory to handle band precints\\n\");\n                        return OPJ_FALSE;\n                    }\n                    /*fprintf(stderr, \"\\t\\t\\t\\tAllocate precincts of a band (opj_tcd_precinct_t): %d\\n\",l_nb_precinct_size);     */\n                    memset(l_band->precincts, 0, l_nb_precinct_size);\n                    l_band->precincts_data_size = l_nb_precinct_size;\n                } else if (l_band->precincts_data_size < l_nb_precinct_size) {\n\n                    opj_tcd_precinct_t * new_precincts = (opj_tcd_precinct_t *) opj_realloc(\n                            l_band->precincts,/*3 * */ l_nb_precinct_size);\n                    if (! new_precincts) {\n                        opj_event_msg(manager, EVT_ERROR,\n                                      \"Not enough memory to handle band precints\\n\");\n                        opj_free(l_band->precincts);\n                        l_band->precincts = NULL;\n                        l_band->precincts_data_size = 0;\n                        return OPJ_FALSE;\n                    }\n                    l_band->precincts = new_precincts;\n                    /*fprintf(stderr, \"\\t\\t\\t\\tReallocate precincts of a band (opj_tcd_precinct_t): from %d to %d\\n\",l_band->precincts_data_size, l_nb_precinct_size);*/\n                    memset(((OPJ_BYTE *) l_band->precincts) + l_band->precincts_data_size, 0,\n                           l_nb_precinct_size - l_band->precincts_data_size);\n                    l_band->precincts_data_size = l_nb_precinct_size;\n                }\n\n                l_current_precinct = l_band->precincts;\n                for (precno = 0; precno < l_nb_precincts; ++precno) {\n                    OPJ_INT32 tlcblkxstart, tlcblkystart, brcblkxend, brcblkyend;\n                    OPJ_INT32 cbgxstart = tlcbgxstart + (OPJ_INT32)(precno % l_res->pw) *\n                                          (1 << cbgwidthexpn);\n                    OPJ_INT32 cbgystart = tlcbgystart + (OPJ_INT32)(precno / l_res->pw) *\n                                          (1 << cbgheightexpn);\n                    OPJ_INT32 cbgxend = cbgxstart + (1 << cbgwidthexpn);\n                    OPJ_INT32 cbgyend = cbgystart + (1 << cbgheightexpn);\n                    /*fprintf(stderr, \"\\t precno=%d; bandno=%d, resno=%d; compno=%d\\n\", precno, bandno , resno, compno);*/\n                    /*fprintf(stderr, \"\\t tlcbgxstart(=%d) + (precno(=%d) percent res->pw(=%d)) * (1 << cbgwidthexpn(=%d)) \\n\",tlcbgxstart,precno,l_res->pw,cbgwidthexpn);*/\n\n                    /* precinct size (global) */\n                    /*fprintf(stderr, \"\\t cbgxstart=%d, l_band->x0 = %d \\n\",cbgxstart, l_band->x0);*/\n\n                    l_current_precinct->x0 = opj_int_max(cbgxstart, l_band->x0);\n                    l_current_precinct->y0 = opj_int_max(cbgystart, l_band->y0);\n                    l_current_precinct->x1 = opj_int_min(cbgxend, l_band->x1);\n                    l_current_precinct->y1 = opj_int_min(cbgyend, l_band->y1);\n                    /*fprintf(stderr, \"\\t prc_x0=%d; prc_y0=%d, prc_x1=%d; prc_y1=%d\\n\",l_current_precinct->x0, l_current_precinct->y0 ,l_current_precinct->x1, l_current_precinct->y1);*/\n\n                    tlcblkxstart = opj_int_floordivpow2(l_current_precinct->x0,\n                                                        (OPJ_INT32)cblkwidthexpn) << cblkwidthexpn;\n                    /*fprintf(stderr, \"\\t tlcblkxstart =%d\\n\",tlcblkxstart );*/\n                    tlcblkystart = opj_int_floordivpow2(l_current_precinct->y0,\n                                                        (OPJ_INT32)cblkheightexpn) << cblkheightexpn;\n                    /*fprintf(stderr, \"\\t tlcblkystart =%d\\n\",tlcblkystart );*/\n                    brcblkxend = opj_int_ceildivpow2(l_current_precinct->x1,\n                                                     (OPJ_INT32)cblkwidthexpn) << cblkwidthexpn;\n                    /*fprintf(stderr, \"\\t brcblkxend =%d\\n\",brcblkxend );*/\n                    brcblkyend = opj_int_ceildivpow2(l_current_precinct->y1,\n                                                     (OPJ_INT32)cblkheightexpn) << cblkheightexpn;\n                    /*fprintf(stderr, \"\\t brcblkyend =%d\\n\",brcblkyend );*/\n                    l_current_precinct->cw = (OPJ_UINT32)((brcblkxend - tlcblkxstart) >>\n                                                          cblkwidthexpn);\n                    l_current_precinct->ch = (OPJ_UINT32)((brcblkyend - tlcblkystart) >>\n                                                          cblkheightexpn);\n\n                    l_nb_code_blocks = l_current_precinct->cw * l_current_precinct->ch;\n                    /*fprintf(stderr, \"\\t\\t\\t\\t precinct_cw = %d x recinct_ch = %d\\n\",l_current_precinct->cw, l_current_precinct->ch);      */\n                    if ((((OPJ_UINT32) - 1) / (OPJ_UINT32)sizeof_block) <\n                            l_nb_code_blocks) {\n                        opj_event_msg(manager, EVT_ERROR,\n                                      \"Size of code block data exceeds system limits\\n\");\n                        return OPJ_FALSE;\n                    }\n                    l_nb_code_blocks_size = l_nb_code_blocks * (OPJ_UINT32)sizeof_block;\n\n                    if (!l_current_precinct->cblks.blocks && (l_nb_code_blocks > 0U)) {\n                        l_current_precinct->cblks.blocks = opj_malloc(l_nb_code_blocks_size);\n                        if (! l_current_precinct->cblks.blocks) {\n                            return OPJ_FALSE;\n                        }\n                        /*fprintf(stderr, \"\\t\\t\\t\\tAllocate cblks of a precinct (opj_tcd_cblk_dec_t): %d\\n\",l_nb_code_blocks_size);*/\n\n                        memset(l_current_precinct->cblks.blocks, 0, l_nb_code_blocks_size);\n\n                        l_current_precinct->block_size = l_nb_code_blocks_size;\n                    } else if (l_nb_code_blocks_size > l_current_precinct->block_size) {\n                        void *new_blocks = opj_realloc(l_current_precinct->cblks.blocks,\n                                                       l_nb_code_blocks_size);\n                        if (! new_blocks) {\n                            opj_free(l_current_precinct->cblks.blocks);\n                            l_current_precinct->cblks.blocks = NULL;\n                            l_current_precinct->block_size = 0;\n                            opj_event_msg(manager, EVT_ERROR,\n                                          \"Not enough memory for current precinct codeblock element\\n\");\n                            return OPJ_FALSE;\n                        }\n                        l_current_precinct->cblks.blocks = new_blocks;\n                        /*fprintf(stderr, \"\\t\\t\\t\\tReallocate cblks of a precinct (opj_tcd_cblk_dec_t): from %d to %d\\n\",l_current_precinct->block_size, l_nb_code_blocks_size);     */\n\n                        memset(((OPJ_BYTE *) l_current_precinct->cblks.blocks) +\n                               l_current_precinct->block_size\n                               , 0\n                               , l_nb_code_blocks_size - l_current_precinct->block_size);\n\n                        l_current_precinct->block_size = l_nb_code_blocks_size;\n                    }\n\n                    if (! l_current_precinct->incltree) {\n                        l_current_precinct->incltree = opj_tgt_create(l_current_precinct->cw,\n                                                       l_current_precinct->ch, manager);\n                    } else {\n                        l_current_precinct->incltree = opj_tgt_init(l_current_precinct->incltree,\n                                                       l_current_precinct->cw, l_current_precinct->ch, manager);\n                    }\n\n                    if (! l_current_precinct->imsbtree) {\n                        l_current_precinct->imsbtree = opj_tgt_create(l_current_precinct->cw,\n                                                       l_current_precinct->ch, manager);\n                    } else {\n                        l_current_precinct->imsbtree = opj_tgt_init(l_current_precinct->imsbtree,\n                                                       l_current_precinct->cw, l_current_precinct->ch, manager);\n                    }\n\n                    for (cblkno = 0; cblkno < l_nb_code_blocks; ++cblkno) {\n                        OPJ_INT32 cblkxstart = tlcblkxstart + (OPJ_INT32)(cblkno %\n                                               l_current_precinct->cw) * (1 << cblkwidthexpn);\n                        OPJ_INT32 cblkystart = tlcblkystart + (OPJ_INT32)(cblkno /\n                                               l_current_precinct->cw) * (1 << cblkheightexpn);\n                        OPJ_INT32 cblkxend = cblkxstart + (1 << cblkwidthexpn);\n                        OPJ_INT32 cblkyend = cblkystart + (1 << cblkheightexpn);\n\n                        if (isEncoder) {\n                            opj_tcd_cblk_enc_t* l_code_block = l_current_precinct->cblks.enc + cblkno;\n\n                            if (! opj_tcd_code_block_enc_allocate(l_code_block)) {\n                                return OPJ_FALSE;\n                            }\n                            /* code-block size (global) */\n                            l_code_block->x0 = opj_int_max(cblkxstart, l_current_precinct->x0);\n                            l_code_block->y0 = opj_int_max(cblkystart, l_current_precinct->y0);\n                            l_code_block->x1 = opj_int_min(cblkxend, l_current_precinct->x1);\n                            l_code_block->y1 = opj_int_min(cblkyend, l_current_precinct->y1);\n\n                            if (! opj_tcd_code_block_enc_allocate_data(l_code_block)) {\n                                return OPJ_FALSE;\n                            }\n                        } else {\n                            opj_tcd_cblk_dec_t* l_code_block = l_current_precinct->cblks.dec + cblkno;\n\n                            if (! opj_tcd_code_block_dec_allocate(l_code_block)) {\n                                return OPJ_FALSE;\n                            }\n                            /* code-block size (global) */\n                            l_code_block->x0 = opj_int_max(cblkxstart, l_current_precinct->x0);\n                            l_code_block->y0 = opj_int_max(cblkystart, l_current_precinct->y0);\n                            l_code_block->x1 = opj_int_min(cblkxend, l_current_precinct->x1);\n                            l_code_block->y1 = opj_int_min(cblkyend, l_current_precinct->y1);\n                        }\n                    }\n                    ++l_current_precinct;\n                } /* precno */\n            } /* bandno */\n            ++l_res;\n        } /* resno */\n        ++l_tccp;\n        ++l_tilec;\n        ++l_image_comp;\n    } /* compno */\n    return OPJ_TRUE;\n}",
  "abstract_func": "static INLINE VAR_0 opj_tcd_init_tile(opj_tcd_t *VAR_1, OPJ_UINT32 VAR_2,\n        OPJ_BOOL VAR_3, OPJ_FLOAT32 VAR_4, OPJ_SIZE_T VAR_5,\n        opj_event_mgr_t* VAR_6)\n{\n    OPJ_UINT32(*VAR_7)(OPJ_UINT32) = 00;\n    OPJ_UINT32 VAR_8, VAR_9, VAR_10, VAR_11, VAR_12;\n    opj_tcp_t * VAR_13 = 00;\n    opj_cp_t * VAR_14 = 00;\n    opj_tcd_tile_t * VAR_15 = 00;\n    opj_tccp_t *VAR_16 = 00;\n    opj_tcd_tilecomp_t *VAR_17 = 00;\n    opj_image_comp_t * VAR_18 = 00;\n    opj_tcd_resolution_t *VAR_19 = 00;\n    opj_tcd_band_t *VAR_20 = 00;\n    opj_stepsize_t * VAR_21 = 00;\n    opj_tcd_precinct_t *VAR_22 = 00;\n    opj_image_t *VAR_23 = 00;\n    OPJ_UINT32 VAR_24, VAR_25;\n    OPJ_UINT32 VAR_26;\n    OPJ_UINT32 VAR_27, VAR_28;\n    OPJ_UINT32 VAR_29;\n    OPJ_INT32 VAR_30, VAR_31;\n    OPJ_UINT32 VAR_32, VAR_33;\n    /* COMMENT_0 */\n    OPJ_INT32 VAR_34, VAR_35, VAR_36, VAR_37;\n    /* COMMENT_1 */\n    OPJ_UINT32 VAR_38;\n    /* COMMENT_2 */\n    OPJ_UINT32 VAR_39;\n    /* COMMENT_3 */\n    OPJ_UINT32 VAR_40;\n    /* COMMENT_4 */\n    OPJ_UINT32 VAR_41;\n    /* COMMENT_5 */\n    OPJ_UINT32 VAR_42;\n\n    VAR_14 = VAR_1->cp;\n    VAR_13 = &(VAR_14->tcps[VAR_2]);\n    VAR_15 = VAR_1->tcd_image->tiles;\n    VAR_16 = VAR_13->tccps;\n    VAR_17 = VAR_15->comps;\n    VAR_23 = VAR_1->image;\n    VAR_18 = VAR_1->image->comps;\n\n    VAR_24 = VAR_2 % VAR_14->tw;       /* COMMENT_6 */\n    VAR_25 = VAR_2 / VAR_14->tw;\n    /* COMMENT_7 */\n\n    /* COMMENT_8 */\n    VAR_32 = VAR_14->tx0 + VAR_24 *\n            VAR_14->tdx; /* COMMENT_9 */\n    VAR_15->x0 = (OPJ_INT32)opj_uint_max(VAR_32, VAR_23->x0);\n    VAR_15->x1 = (OPJ_INT32)opj_uint_min(opj_uint_adds(VAR_32, VAR_14->tdx),\n                                         VAR_23->x1);\n    /* COMMENT_10 */\n    if ((VAR_15->x0 < 0) || (VAR_15->x1 <= VAR_15->x0)) {\n        opj_event_msg(VAR_6, VAR_43, \"Tile X coordinates are not supported\\n\");\n        return VAR_44;\n    }\n    VAR_33 = VAR_14->ty0 + VAR_25 *\n            VAR_14->tdy; /* COMMENT_11 */\n    VAR_15->y0 = (OPJ_INT32)opj_uint_max(VAR_33, VAR_23->y0);\n    VAR_15->y1 = (OPJ_INT32)opj_uint_min(opj_uint_adds(VAR_33, VAR_14->tdy),\n                                         VAR_23->y1);\n    /* COMMENT_10 */\n    if ((VAR_15->y0 < 0) || (VAR_15->y1 <= VAR_15->y0)) {\n        opj_event_msg(VAR_6, VAR_43, \"Tile Y coordinates are not supported\\n\");\n        return VAR_44;\n    }\n\n\n    /* COMMENT_12 */\n    if (VAR_16->numresolutions == 0) {\n        opj_event_msg(VAR_6, VAR_43, \"tiles require at least one resolution\\n\");\n        return VAR_44;\n    }\n    /* COMMENT_13 */\n\n    /* COMMENT_14 */\n    for (VAR_8 = 0; VAR_8 < VAR_15->numcomps; ++VAR_8) {\n        /* COMMENT_15 */\n        VAR_18->resno_decoded = 0;\n        /* COMMENT_16 */\n        VAR_17->x0 = opj_int_ceildiv(VAR_15->x0, (OPJ_INT32)VAR_18->dx);\n        VAR_17->y0 = opj_int_ceildiv(VAR_15->y0, (OPJ_INT32)VAR_18->dy);\n        VAR_17->x1 = opj_int_ceildiv(VAR_15->x1, (OPJ_INT32)VAR_18->dx);\n        VAR_17->y1 = opj_int_ceildiv(VAR_15->y1, (OPJ_INT32)VAR_18->dy);\n        VAR_17->compno = VAR_8;\n        /* COMMENT_17 */\n\n        VAR_17->numresolutions = VAR_16->numresolutions;\n        if (VAR_16->numresolutions < VAR_14->m_specific_param.m_dec.m_reduce) {\n            VAR_17->minimum_num_resolutions = 1;\n        } else {\n            VAR_17->minimum_num_resolutions = VAR_16->numresolutions -\n                                               VAR_14->m_specific_param.m_dec.m_reduce;\n        }\n\n        if (VAR_3) {\n            OPJ_SIZE_T VAR_45;\n\n            /* COMMENT_18 */\n            OPJ_SIZE_T VAR_46 = (OPJ_SIZE_T)(VAR_17->x1 - VAR_17->x0);\n            OPJ_SIZE_T VAR_47 = (OPJ_SIZE_T)(VAR_17->y1 - VAR_17->y0);\n\n            /* COMMENT_19 */\n            if (VAR_47 > 0 && VAR_46 > VAR_48 / VAR_47) {\n                opj_event_msg(VAR_6, VAR_43, \"Size of tile data exceeds system limits\\n\");\n                return VAR_44;\n            }\n            VAR_45 = VAR_46 * VAR_47;\n\n            if (VAR_48 / sizeof(OPJ_UINT32) < VAR_45) {\n                opj_event_msg(VAR_6, VAR_43, \"Size of tile data exceeds system limits\\n\");\n                return VAR_44;\n            }\n            VAR_45 = VAR_45 * sizeof(OPJ_UINT32);\n\n            VAR_17->data_size_needed = VAR_45;\n        }\n\n        VAR_42 = VAR_17->numresolutions * (OPJ_UINT32)sizeof(\n                          opj_tcd_resolution_t);\n\n        opj_image_data_free(VAR_17->data_win);\n        VAR_17->data_win = NULL;\n        VAR_17->win_x0 = 0;\n        VAR_17->win_y0 = 0;\n        VAR_17->win_x1 = 0;\n        VAR_17->win_y1 = 0;\n\n        if (VAR_17->resolutions == 00) {\n            VAR_17->resolutions = (opj_tcd_resolution_t *) opj_malloc(VAR_42);\n            if (! VAR_17->resolutions) {\n                return VAR_44;\n            }\n            /* COMMENT_20 */\n            VAR_17->resolutions_size = VAR_42;\n            memset(VAR_17->resolutions, 0, VAR_42);\n        } else if (VAR_42 > VAR_17->resolutions_size) {\n            opj_tcd_resolution_t* VAR_49 = (opj_tcd_resolution_t *) opj_realloc(\n                    VAR_17->resolutions, VAR_42);\n            if (! VAR_49) {\n                opj_event_msg(VAR_6, VAR_43, \"Not enough memory for tile resolutions\\n\");\n                opj_free(VAR_17->resolutions);\n                VAR_17->resolutions = NULL;\n                VAR_17->resolutions_size = 0;\n                return VAR_44;\n            }\n            VAR_17->resolutions = VAR_49;\n            /* COMMENT_21 */\n            memset(((OPJ_BYTE*) VAR_17->resolutions) + VAR_17->resolutions_size, 0,\n                   VAR_42 - VAR_17->resolutions_size);\n            VAR_17->resolutions_size = VAR_42;\n        }\n\n        VAR_26 = VAR_17->numresolutions;\n        VAR_19 = VAR_17->resolutions;\n        VAR_21 = VAR_16->stepsizes;\n        if (VAR_16->qmfbid == 0) {\n            VAR_7 = &VAR_50;\n        } else {\n            VAR_7  = &VAR_51;\n        }\n        /* COMMENT_22 */\n\n        for (VAR_9 = 0; VAR_9 < VAR_17->numresolutions; ++VAR_9) {\n            /* COMMENT_23 */\n            OPJ_INT32 VAR_52, VAR_53 /* COMMENT_24 */;\n            OPJ_UINT32 VAR_54, VAR_55;\n            OPJ_UINT32 VAR_56, VAR_57;\n\n            --VAR_26;\n\n            /* COMMENT_25 */\n            VAR_19->x0 = opj_int_ceildivpow2(VAR_17->x0, (OPJ_INT32)VAR_26);\n            VAR_19->y0 = opj_int_ceildivpow2(VAR_17->y0, (OPJ_INT32)VAR_26);\n            VAR_19->x1 = opj_int_ceildivpow2(VAR_17->x1, (OPJ_INT32)VAR_26);\n            VAR_19->y1 = opj_int_ceildivpow2(VAR_17->y1, (OPJ_INT32)VAR_26);\n\n            /* COMMENT_26 */\n            /* COMMENT_27 */\n            VAR_27 = VAR_16->prcw[VAR_9];\n            VAR_28 = VAR_16->prch[VAR_9];\n            /* COMMENT_28 */\n            /* COMMENT_29 */\n            VAR_34 = opj_int_floordivpow2(VAR_19->x0, (OPJ_INT32)VAR_27) << VAR_27;\n            VAR_35 = opj_int_floordivpow2(VAR_19->y0, (OPJ_INT32)VAR_28) << VAR_28;\n            {\n                OPJ_UINT32 VAR_58 = ((OPJ_UINT32)opj_int_ceildivpow2(VAR_19->x1,\n                                  (OPJ_INT32)VAR_27)) << VAR_27;\n                if (VAR_58 > (OPJ_UINT32)VAR_59) {\n                    opj_event_msg(VAR_6, VAR_43, \"Integer overflow\\n\");\n                    return VAR_44;\n                }\n                VAR_36 = (OPJ_INT32)VAR_58;\n            }\n            {\n                OPJ_UINT32 VAR_58 = ((OPJ_UINT32)opj_int_ceildivpow2(VAR_19->y1,\n                                  (OPJ_INT32)VAR_28)) << VAR_28;\n                if (VAR_58 > (OPJ_UINT32)VAR_59) {\n                    opj_event_msg(VAR_6, VAR_43, \"Integer overflow\\n\");\n                    return VAR_44;\n                }\n                VAR_37 = (OPJ_INT32)VAR_58;\n            }\n            /* COMMENT_30 */\n\n            VAR_19->pw = (VAR_19->x0 == VAR_19->x1) ? 0U : (OPJ_UINT32)((\n                            VAR_36 - VAR_34) >> VAR_27);\n            VAR_19->ph = (VAR_19->y0 == VAR_19->y1) ? 0U : (OPJ_UINT32)((\n                            VAR_37 - VAR_35) >> VAR_28);\n            /* COMMENT_31 */\n\n            if ((VAR_19->pw != 0U) && ((((OPJ_UINT32) - 1) / VAR_19->pw) < VAR_19->ph)) {\n                opj_event_msg(VAR_6, VAR_43, \"Size of tile data exceeds system limits\\n\");\n                return VAR_44;\n            }\n            VAR_38 = VAR_19->pw * VAR_19->ph;\n\n            if ((((OPJ_UINT32) - 1) / (OPJ_UINT32)sizeof(opj_tcd_precinct_t)) <\n                    VAR_38) {\n                opj_event_msg(VAR_6, VAR_43, \"Size of tile data exceeds system limits\\n\");\n                return VAR_44;\n            }\n            VAR_39 = VAR_38 * (OPJ_UINT32)sizeof(opj_tcd_precinct_t);\n\n            if (VAR_9 == 0) {\n                VAR_52 = VAR_34;\n                VAR_53 = VAR_35;\n                /* COMMENT_32 */\n                /* COMMENT_33 */\n                VAR_54 = VAR_27;\n                VAR_55 = VAR_28;\n                VAR_19->numbands = 1;\n            } else {\n                VAR_52 = opj_int_ceildivpow2(VAR_34, 1);\n                VAR_53 = opj_int_ceildivpow2(VAR_35, 1);\n                /* COMMENT_34 */\n                /* COMMENT_35 */\n                VAR_54 = VAR_27 - 1;\n                VAR_55 = VAR_28 - 1;\n                VAR_19->numbands = 3;\n            }\n\n            VAR_56 = opj_uint_min(VAR_16->cblkw, VAR_54);\n            VAR_57 = opj_uint_min(VAR_16->cblkh, VAR_55);\n            VAR_20 = VAR_19->bands;\n\n            for (VAR_10 = 0; VAR_10 < VAR_19->numbands; ++VAR_10, ++VAR_20, ++VAR_21) {\n                OPJ_INT32 VAR_60;\n                /* COMMENT_36 */\n\n                if (VAR_9 == 0) {\n                    VAR_20->bandno = 0 ;\n                    VAR_20->x0 = opj_int_ceildivpow2(VAR_17->x0, (OPJ_INT32)VAR_26);\n                    VAR_20->y0 = opj_int_ceildivpow2(VAR_17->y0, (OPJ_INT32)VAR_26);\n                    VAR_20->x1 = opj_int_ceildivpow2(VAR_17->x1, (OPJ_INT32)VAR_26);\n                    VAR_20->y1 = opj_int_ceildivpow2(VAR_17->y1, (OPJ_INT32)VAR_26);\n                } else {\n                    VAR_20->bandno = VAR_10 + 1;\n                    /* COMMENT_37 */\n                    VAR_30 = VAR_20->bandno & 1;\n                    /* COMMENT_38 */\n                    VAR_31 = (OPJ_INT32)((VAR_20->bandno) >> 1);\n                    /* COMMENT_39 */\n                    VAR_20->x0 = opj_int64_ceildivpow2(VAR_17->x0 - ((OPJ_INT64)VAR_30 <<\n                                                       VAR_26), (OPJ_INT32)(VAR_26 + 1));\n                    VAR_20->y0 = opj_int64_ceildivpow2(VAR_17->y0 - ((OPJ_INT64)VAR_31 <<\n                                                       VAR_26), (OPJ_INT32)(VAR_26 + 1));\n                    VAR_20->x1 = opj_int64_ceildivpow2(VAR_17->x1 - ((OPJ_INT64)VAR_30 <<\n                                                       VAR_26), (OPJ_INT32)(VAR_26 + 1));\n                    VAR_20->y1 = opj_int64_ceildivpow2(VAR_17->y1 - ((OPJ_INT64)VAR_31 <<\n                                                       VAR_26), (OPJ_INT32)(VAR_26 + 1));\n                }\n\n                if (VAR_3) {\n                    /* COMMENT_40 */\n                    if (opj_tcd_is_band_empty(VAR_20)) {\n                        /* COMMENT_41 */\n                        /* COMMENT_42 */\n                        /* COMMENT_43 */\n                        continue;\n                    }\n                }\n\n                /* COMMENT_44 */\n                VAR_29 = (*VAR_7)(VAR_20->bandno);\n                VAR_60 = (OPJ_INT32)(VAR_18->prec + VAR_29);\n                VAR_20->stepsize = (OPJ_FLOAT32)(((1.0 + VAR_21->mant / 2048.0) * pow(2.0,\n                                                  (OPJ_INT32)(VAR_60 - VAR_21->expn)))) * VAR_4;\n                /* COMMENT_45 */\n                                                \n                VAR_20->numbps = VAR_21->expn + (OPJ_INT32)VAR_16->numgbits -\n                                 1;\n\n                if (!VAR_20->precincts && (VAR_38 > 0U)) {\n                    VAR_20->precincts = (opj_tcd_precinct_t *) opj_malloc(/* COMMENT_47 */\n                                            VAR_39);\n                    if (! VAR_20->precincts) {\n                        opj_event_msg(VAR_6, VAR_43,\n                                      \"Not enough memory to handle band precints\\n\");\n                        return VAR_44;\n                    }\n                    /* COMMENT_48 */\n                    memset(VAR_20->precincts, 0, VAR_39);\n                    VAR_20->precincts_data_size = VAR_39;\n                } else if (VAR_20->precincts_data_size < VAR_39) {\n\n                    opj_tcd_precinct_t * VAR_61 = (opj_tcd_precinct_t *) opj_realloc(\n                            VAR_20->precincts,/* COMMENT_47 */ VAR_39);\n                    if (! VAR_61) {\n                        opj_event_msg(VAR_6, VAR_43,\n                                      \"Not enough memory to handle band precints\\n\");\n                        opj_free(VAR_20->precincts);\n                        VAR_20->precincts = NULL;\n                        VAR_20->precincts_data_size = 0;\n                        return VAR_44;\n                    }\n                    VAR_20->precincts = VAR_61;\n                    /* COMMENT_49 */\n                    memset(((OPJ_BYTE *) VAR_20->precincts) + VAR_20->precincts_data_size, 0,\n                           VAR_39 - VAR_20->precincts_data_size);\n                    VAR_20->precincts_data_size = VAR_39;\n                }\n\n                VAR_22 = VAR_20->precincts;\n                for (VAR_11 = 0; VAR_11 < VAR_38; ++VAR_11) {\n                    OPJ_INT32 VAR_62, VAR_63, VAR_64, VAR_65;\n                    OPJ_INT32 VAR_66 = VAR_52 + (OPJ_INT32)(VAR_11 % VAR_19->pw) *\n                                          (1 << VAR_54);\n                    OPJ_INT32 VAR_67 = VAR_53 + (OPJ_INT32)(VAR_11 / VAR_19->pw) *\n                                          (1 << VAR_55);\n                    OPJ_INT32 VAR_68 = VAR_66 + (1 << VAR_54);\n                    OPJ_INT32 VAR_69 = VAR_67 + (1 << VAR_55);\n                    /* COMMENT_50 */\n                    /* COMMENT_51 */\n\n                    /* COMMENT_52 */\n                    /* COMMENT_53 */\n\n                    VAR_22->x0 = opj_int_max(VAR_66, VAR_20->x0);\n                    VAR_22->y0 = opj_int_max(VAR_67, VAR_20->y0);\n                    VAR_22->x1 = opj_int_min(VAR_68, VAR_20->x1);\n                    VAR_22->y1 = opj_int_min(VAR_69, VAR_20->y1);\n                    /* COMMENT_54 */\n\n                    VAR_62 = opj_int_floordivpow2(VAR_22->x0,\n                                                        (OPJ_INT32)VAR_56) << VAR_56;\n                    /* COMMENT_55 */\n                    VAR_63 = opj_int_floordivpow2(VAR_22->y0,\n                                                        (OPJ_INT32)VAR_57) << VAR_57;\n                    /* COMMENT_56 */\n                    VAR_64 = opj_int_ceildivpow2(VAR_22->x1,\n                                                     (OPJ_INT32)VAR_56) << VAR_56;\n                    /* COMMENT_57 */\n                    VAR_65 = opj_int_ceildivpow2(VAR_22->y1,\n                                                     (OPJ_INT32)VAR_57) << VAR_57;\n                    /* COMMENT_58 */\n                    VAR_22->cw = (OPJ_UINT32)((VAR_64 - VAR_62) >>\n                                                          VAR_56);\n                    VAR_22->ch = (OPJ_UINT32)((VAR_65 - VAR_63) >>\n                                                          VAR_57);\n\n                    VAR_40 = VAR_22->cw * VAR_22->ch;\n                    /* COMMENT_59 */\n                    if ((((OPJ_UINT32) - 1) / (OPJ_UINT32)VAR_5) <\n                            VAR_40) {\n                        opj_event_msg(VAR_6, VAR_43,\n                                      \"Size of code block data exceeds system limits\\n\");\n                        return VAR_44;\n                    }\n                    VAR_41 = VAR_40 * (OPJ_UINT32)VAR_5;\n\n                    if (!VAR_22->cblks.blocks && (VAR_40 > 0U)) {\n                        VAR_22->cblks.blocks = opj_malloc(VAR_41);\n                        if (! VAR_22->cblks.blocks) {\n                            return VAR_44;\n                        }\n                        /* COMMENT_60 */\n\n                        memset(VAR_22->cblks.blocks, 0, VAR_41);\n\n                        VAR_22->block_size = VAR_41;\n                    } else if (VAR_41 > VAR_22->block_size) {\n                        void *VAR_70 = opj_realloc(VAR_22->cblks.blocks,\n                                                       VAR_41);\n                        if (! VAR_70) {\n                            opj_free(VAR_22->cblks.blocks);\n                            VAR_22->cblks.blocks = NULL;\n                            VAR_22->block_size = 0;\n                            opj_event_msg(VAR_6, VAR_43,\n                                          \"Not enough memory for current precinct codeblock element\\n\");\n                            return VAR_44;\n                        }\n                        VAR_22->cblks.blocks = VAR_70;\n                        /* COMMENT_61 */\n\n                        memset(((OPJ_BYTE *) VAR_22->cblks.blocks) +\n                               VAR_22->block_size\n                               , 0\n                               , VAR_41 - VAR_22->block_size);\n\n                        VAR_22->block_size = VAR_41;\n                    }\n\n                    if (! VAR_22->incltree) {\n                        VAR_22->incltree = opj_tgt_create(VAR_22->cw,\n                                                       VAR_22->ch, VAR_6);\n                    } else {\n                        VAR_22->incltree = opj_tgt_init(VAR_22->incltree,\n                                                       VAR_22->cw, VAR_22->ch, VAR_6);\n                    }\n\n                    if (! VAR_22->imsbtree) {\n                        VAR_22->imsbtree = opj_tgt_create(VAR_22->cw,\n                                                       VAR_22->ch, VAR_6);\n                    } else {\n                        VAR_22->imsbtree = opj_tgt_init(VAR_22->imsbtree,\n                                                       VAR_22->cw, VAR_22->ch, VAR_6);\n                    }\n\n                    for (VAR_12 = 0; VAR_12 < VAR_40; ++VAR_12) {\n                        OPJ_INT32 VAR_71 = VAR_62 + (OPJ_INT32)(VAR_12 %\n                                               VAR_22->cw) * (1 << VAR_56);\n                        OPJ_INT32 VAR_72 = VAR_63 + (OPJ_INT32)(VAR_12 /\n                                               VAR_22->cw) * (1 << VAR_57);\n                        OPJ_INT32 VAR_73 = VAR_71 + (1 << VAR_56);\n                        OPJ_INT32 VAR_74 = VAR_72 + (1 << VAR_57);\n\n                        if (VAR_3) {\n                            opj_tcd_cblk_enc_t* VAR_75 = VAR_22->cblks.enc + VAR_12;\n\n                            if (! opj_tcd_code_block_enc_allocate(VAR_75)) {\n                                return VAR_44;\n                            }\n                            /* COMMENT_62 */\n                            VAR_75->x0 = opj_int_max(VAR_71, VAR_22->x0);\n                            VAR_75->y0 = opj_int_max(VAR_72, VAR_22->y0);\n                            VAR_75->x1 = opj_int_min(VAR_73, VAR_22->x1);\n                            VAR_75->y1 = opj_int_min(VAR_74, VAR_22->y1);\n\n                            if (! opj_tcd_code_block_enc_allocate_data(VAR_75)) {\n                                return VAR_44;\n                            }\n                        } else {\n                            opj_tcd_cblk_dec_t* VAR_75 = VAR_22->cblks.dec + VAR_12;\n\n                            if (! opj_tcd_code_block_dec_allocate(VAR_75)) {\n                                return VAR_44;\n                            }\n                            /* COMMENT_62 */\n                            VAR_75->x0 = opj_int_max(VAR_71, VAR_22->x0);\n                            VAR_75->y0 = opj_int_max(VAR_72, VAR_22->y0);\n                            VAR_75->x1 = opj_int_min(VAR_73, VAR_22->x1);\n                            VAR_75->y1 = opj_int_min(VAR_74, VAR_22->y1);\n                        }\n                    }\n                    ++VAR_22;\n                } /* COMMENT_63 */\n            } /* COMMENT_64 */\n            ++VAR_19;\n        } /* COMMENT_65 */\n        ++VAR_16;\n        ++VAR_17;\n        ++VAR_18;\n    } /* COMMENT_66 */\n    return VAR_76;\n}",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -186,8 +186,24 @@\n             /* p. 64, B.6, ISO/IEC FDIS15444-1 : 2000 (18 august 2000)  */\n             l_tl_prc_x_start = opj_int_floordivpow2(l_res->x0, (OPJ_INT32)l_pdx) << l_pdx;\n             l_tl_prc_y_start = opj_int_floordivpow2(l_res->y0, (OPJ_INT32)l_pdy) << l_pdy;\n-            l_br_prc_x_end = opj_int_ceildivpow2(l_res->x1, (OPJ_INT32)l_pdx) << l_pdx;\n-            l_br_prc_y_end = opj_int_ceildivpow2(l_res->y1, (OPJ_INT32)l_pdy) << l_pdy;\n+            {\n+                OPJ_UINT32 tmp = ((OPJ_UINT32)opj_int_ceildivpow2(l_res->x1,\n+                                  (OPJ_INT32)l_pdx)) << l_pdx;\n+                if (tmp > (OPJ_UINT32)INT_MAX) {\n+                    opj_event_msg(manager, EVT_ERROR, \"Integer overflow\\n\");\n+                    return OPJ_FALSE;\n+                }\n+                l_br_prc_x_end = (OPJ_INT32)tmp;\n+            }\n+            {\n+                OPJ_UINT32 tmp = ((OPJ_UINT32)opj_int_ceildivpow2(l_res->y1,\n+                                  (OPJ_INT32)l_pdy)) << l_pdy;\n+                if (tmp > (OPJ_UINT32)INT_MAX) {\n+                    opj_event_msg(manager, EVT_ERROR, \"Integer overflow\\n\");\n+                    return OPJ_FALSE;\n+                }\n+                l_br_prc_y_end = (OPJ_INT32)tmp;\n+            }\n             /*fprintf(stderr, \"\\t\\t\\tprc_x_start=%d, prc_y_start=%d, br_prc_x_end=%d, br_prc_y_end=%d \\n\", l_tl_prc_x_start, l_tl_prc_y_start, l_br_prc_x_end ,l_br_prc_y_end );*/\n \n             l_res->pw = (l_res->x0 == l_res->x1) ? 0U : (OPJ_UINT32)((",
  "diff_line_info": {
    "deleted_lines": [
      "            l_br_prc_x_end = opj_int_ceildivpow2(l_res->x1, (OPJ_INT32)l_pdx) << l_pdx;",
      "            l_br_prc_y_end = opj_int_ceildivpow2(l_res->y1, (OPJ_INT32)l_pdy) << l_pdy;"
    ],
    "added_lines": [
      "            {",
      "                OPJ_UINT32 tmp = ((OPJ_UINT32)opj_int_ceildivpow2(l_res->x1,",
      "                                  (OPJ_INT32)l_pdx)) << l_pdx;",
      "                if (tmp > (OPJ_UINT32)INT_MAX) {",
      "                    opj_event_msg(manager, EVT_ERROR, \"Integer overflow\\n\");",
      "                    return OPJ_FALSE;",
      "                }",
      "                l_br_prc_x_end = (OPJ_INT32)tmp;",
      "            }",
      "            {",
      "                OPJ_UINT32 tmp = ((OPJ_UINT32)opj_int_ceildivpow2(l_res->y1,",
      "                                  (OPJ_INT32)l_pdy)) << l_pdy;",
      "                if (tmp > (OPJ_UINT32)INT_MAX) {",
      "                    opj_event_msg(manager, EVT_ERROR, \"Integer overflow\\n\");",
      "                    return OPJ_FALSE;",
      "                }",
      "                l_br_prc_y_end = (OPJ_INT32)tmp;",
      "            }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/uclouvain/openjpeg/pull/1232",
  "description": {
    "pr_info": {
      "title": "opj_tcd_init_tile(): avoid integer overflow",
      "number": 1232
    },
    "comment": [
      "That could lead to later assertion failures.\r\n\r\nFixes #1231 / CVE-2020-8112",
      "I can confirm with makes UBSAN and ASAN happy for the given problematic input."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix\nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\nThe patch addresses an integer overflow issue that could lead to assertion failures, as indicated by the commit message referencing a CVE. The code change introduces checks to prevent overflow, which is a security concern.\n\n**Final Output:**\nAnalysis: The patch fixes an integer overflow vulnerability that could cause assertion failures, as indicated by the CVE reference. The code change adds checks to prevent overflow, which is a security issue.\nFinal Classification: Security Vulnerability Fix\nConfidence Score: 1.0"
}