{
  "cve_id": "CVE-2021-37620",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "Exiv2/exiv2",
  "commit_msg": "Safer std::vector indexing.",
  "commit_hash": "76e313745e813f80e8910aceb2210af3ad8cf897",
  "git_url": "https://github.com/Exiv2/exiv2/commit/76e313745e813f80e8910aceb2210af3ad8cf897",
  "file_path": "src/xmpsidecar.cpp",
  "func_name": "isXmpType",
  "func_before": "bool isXmpType(BasicIo& iIo, bool advance)\n    {\n        /*\n          Check if the file starts with an optional XML declaration followed by\n          either an XMP header (<?xpacket ... ?>) or an <x:xmpmeta> element.\n\n          In addition, in order for empty XmpSidecar objects as created by\n          Exiv2 to pass the test, just an XML header is also considered ok.\n         */\n        const int32_t len = 80;\n        byte buf[len];\n        iIo.read(buf, xmlHdrCnt + 1);\n        if (   iIo.eof()\n            && 0 == strncmp(reinterpret_cast<const char*>(buf), xmlHeader, xmlHdrCnt)) {\n            return true;\n        }\n        if (iIo.error() || iIo.eof()) {\n            return false;\n        }\n        iIo.read(buf + xmlHdrCnt + 1, len - xmlHdrCnt - 1);\n        if (iIo.error() || iIo.eof()) {\n            return false;\n        }\n        // Skip leading BOM\n        int32_t start = 0;\n        if (0 == strncmp(reinterpret_cast<const char*>(buf), \"\\xef\\xbb\\xbf\", 3)) {\n            start = 3;\n        }\n        bool rc = false;\n        std::string head(reinterpret_cast<const char*>(buf + start), len - start);\n        if (head.substr(0, 5)  == \"<?xml\") {\n            // Forward to the next tag\n            for (unsigned i = 5; i < head.size(); ++i) {\n                if (head[i] == '<') {\n                    head = head.substr(i);\n                    break;\n                }\n            }\n        }\n        if (   head.size() > 9\n            && (   head.substr(0, 9)  == \"<?xpacket\"\n                || head.substr(0, 10) == \"<x:xmpmeta\")) {\n            rc = true;\n        }\n        if (!advance || !rc) {\n            iIo.seek(-(len - start), BasicIo::cur); // Swallow the BOM\n        }\n        return rc;\n\n    }",
  "abstract_func_before": "bool isXmpType(BasicIo& VAR_0, bool VAR_1)\n    {\n        /* COMMENT_0 */\n                                                                               \n                                                                            \n\n                                                                          \n                                                                           \n           \n        const int32_t VAR_2 = 80;\n        byte VAR_3[VAR_2];\n        VAR_0.read(VAR_3, VAR_4 + 1);\n        if (   VAR_0.eof()\n            && 0 == strncmp(VAR_5<const char*>(VAR_3), VAR_6, VAR_4)) {\n            return true;\n        }\n        if (VAR_0.error() || VAR_0.eof()) {\n            return false;\n        }\n        VAR_0.read(VAR_3 + VAR_4 + 1, VAR_2 - VAR_4 - 1);\n        if (VAR_0.error() || VAR_0.eof()) {\n            return false;\n        }\n        /* COMMENT_7 */\n        int32_t VAR_7 = 0;\n        if (0 == strncmp(VAR_5<const char*>(VAR_3), \"\\xef\\xbb\\xbf\", 3)) {\n            VAR_7 = 3;\n        }\n        bool VAR_8 = false;\n        std::string VAR_9(VAR_5<const char*>(VAR_3 + VAR_7), VAR_2 - VAR_7);\n        if (VAR_9.substr(0, 5)  == \"<?xml\") {\n            /* COMMENT_8 */\n            for (unsigned VAR_10 = 5; VAR_10 < VAR_9.size(); ++VAR_10) {\n                if (VAR_9[VAR_10] == '<') {\n                    VAR_9 = VAR_9.substr(VAR_10);\n                    break;\n                }\n            }\n        }\n        if (   VAR_9.size() > 9\n            && (   VAR_9.substr(0, 9)  == \"<?xpacket\"\n                || VAR_9.substr(0, 10) == \"<x:xmpmeta\")) {\n            VAR_8 = true;\n        }\n        if (!VAR_1 || !VAR_8) {\n            VAR_0.seek(-(VAR_2 - VAR_7), BasicIo::cur); /* COMMENT_9 */\n        }\n        return VAR_8;\n\n    }",
  "func_graph_path_before": "Exiv2/exiv2/76e313745e813f80e8910aceb2210af3ad8cf897/xmpsidecar.cpp/vul/before/0.json",
  "func": "bool isXmpType(BasicIo& iIo, bool advance)\n    {\n        /*\n          Check if the file starts with an optional XML declaration followed by\n          either an XMP header (<?xpacket ... ?>) or an <x:xmpmeta> element.\n\n          In addition, in order for empty XmpSidecar objects as created by\n          Exiv2 to pass the test, just an XML header is also considered ok.\n         */\n        const int32_t len = 80;\n        byte buf[len];\n        iIo.read(buf, xmlHdrCnt + 1);\n        if (   iIo.eof()\n            && 0 == strncmp(reinterpret_cast<const char*>(buf), xmlHeader, xmlHdrCnt)) {\n            return true;\n        }\n        if (iIo.error() || iIo.eof()) {\n            return false;\n        }\n        iIo.read(buf + xmlHdrCnt + 1, len - xmlHdrCnt - 1);\n        if (iIo.error() || iIo.eof()) {\n            return false;\n        }\n        // Skip leading BOM\n        int32_t start = 0;\n        if (0 == strncmp(reinterpret_cast<const char*>(buf), \"\\xef\\xbb\\xbf\", 3)) {\n            start = 3;\n        }\n        bool rc = false;\n        std::string head(reinterpret_cast<const char*>(buf + start), len - start);\n        if (head.substr(0, 5)  == \"<?xml\") {\n            // Forward to the next tag\n            for (size_t i = 5; i < head.size(); ++i) {\n                if (head[i] == '<') {\n                    head = head.substr(i);\n                    break;\n                }\n            }\n        }\n        if (   head.size() > 9\n            && (   head.substr(0, 9)  == \"<?xpacket\"\n                || head.substr(0, 10) == \"<x:xmpmeta\")) {\n            rc = true;\n        }\n        if (!advance || !rc) {\n            iIo.seek(-(len - start), BasicIo::cur); // Swallow the BOM\n        }\n        return rc;\n\n    }",
  "abstract_func": "bool isXmpType(BasicIo& VAR_0, bool VAR_1)\n    {\n        /* COMMENT_0 */\n                                                                               \n                                                                            \n\n                                                                          \n                                                                           \n           \n        const int32_t VAR_2 = 80;\n        byte VAR_3[VAR_2];\n        VAR_0.read(VAR_3, VAR_4 + 1);\n        if (   VAR_0.eof()\n            && 0 == strncmp(VAR_5<const char*>(VAR_3), VAR_6, VAR_4)) {\n            return true;\n        }\n        if (VAR_0.error() || VAR_0.eof()) {\n            return false;\n        }\n        VAR_0.read(VAR_3 + VAR_4 + 1, VAR_2 - VAR_4 - 1);\n        if (VAR_0.error() || VAR_0.eof()) {\n            return false;\n        }\n        /* COMMENT_7 */\n        int32_t VAR_7 = 0;\n        if (0 == strncmp(VAR_5<const char*>(VAR_3), \"\\xef\\xbb\\xbf\", 3)) {\n            VAR_7 = 3;\n        }\n        bool VAR_8 = false;\n        std::string VAR_9(VAR_5<const char*>(VAR_3 + VAR_7), VAR_2 - VAR_7);\n        if (VAR_9.substr(0, 5)  == \"<?xml\") {\n            /* COMMENT_8 */\n            for (size_t VAR_10 = 5; VAR_10 < VAR_9.size(); ++VAR_10) {\n                if (VAR_9[VAR_10] == '<') {\n                    VAR_9 = VAR_9.substr(VAR_10);\n                    break;\n                }\n            }\n        }\n        if (   VAR_9.size() > 9\n            && (   VAR_9.substr(0, 9)  == \"<?xpacket\"\n                || VAR_9.substr(0, 10) == \"<x:xmpmeta\")) {\n            VAR_8 = true;\n        }\n        if (!VAR_1 || !VAR_8) {\n            VAR_0.seek(-(VAR_2 - VAR_7), BasicIo::cur); /* COMMENT_9 */\n        }\n        return VAR_8;\n\n    }",
  "func_graph_path": "Exiv2/exiv2/76e313745e813f80e8910aceb2210af3ad8cf897/xmpsidecar.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -30,7 +30,7 @@\n         std::string head(reinterpret_cast<const char*>(buf + start), len - start);\n         if (head.substr(0, 5)  == \"<?xml\") {\n             // Forward to the next tag\n-            for (unsigned i = 5; i < head.size(); ++i) {\n+            for (size_t i = 5; i < head.size(); ++i) {\n                 if (head[i] == '<') {\n                     head = head.substr(i);\n                     break;",
  "diff_line_info": {
    "deleted_lines": [
      "            for (unsigned i = 5; i < head.size(); ++i) {"
    ],
    "added_lines": [
      "            for (size_t i = 5; i < head.size(); ++i) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/sridharb1/exiv2/pull/4",
  "description": {
    "pr_info": {
      "title": "0.27 maintenance",
      "number": 4
    },
    "comment": []
  },
  "Bug Filter": "Security Vulnerability Fix\nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\nAnalysis:\nThe patch modifies loop variable type from 'unsigned' to 'size_t' to prevent potential underflow issues, addressing a buffer indexing problem that could lead to security vulnerabilities like buffer overflow.\n\nFinal Classification: Security Vulnerability Fix\nConfidence Score: 0.95"
}