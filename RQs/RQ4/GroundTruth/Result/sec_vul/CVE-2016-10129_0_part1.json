{
  "cve_id": "CVE-2016-10129",
  "cwe_ids": [
    "CWE-476"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "libgit2",
  "commit_msg": "smart_pkt: treat empty packet lines as error\n\nThe Git protocol does not specify what should happen in the case\nof an empty packet line (that is a packet line \"0004\"). We\ncurrently indicate success, but do not return a packet in the\ncase where we hit an empty line. The smart protocol was not\nprepared to handle such packets in all cases, though, resulting\nin a `NULL` pointer dereference.\n\nFix the issue by returning an error instead. As such kind of\npackets is not even specified by upstream, this is the right\nthing to do.",
  "commit_hash": "2fdef641fd0dd2828bd948234ae86de75221a11a",
  "git_url": "https://github.com/libgit2/libgit2/commit/2fdef641fd0dd2828bd948234ae86de75221a11a",
  "file_path": "src/transports/smart_protocol.c",
  "func_name": "parse_report",
  "func_before": "static int parse_report(transport_smart *transport, git_push *push)\n{\n\tgit_pkt *pkt = NULL;\n\tconst char *line_end = NULL;\n\tgitno_buffer *buf = &transport->buffer;\n\tint error, recvd;\n\tgit_buf data_pkt_buf = GIT_BUF_INIT;\n\n\tfor (;;) {\n\t\tif (buf->offset > 0)\n\t\t\terror = git_pkt_parse_line(&pkt, buf->data,\n\t\t\t\t\t\t   &line_end, buf->offset);\n\t\telse\n\t\t\terror = GIT_EBUFS;\n\n\t\tif (error < 0 && error != GIT_EBUFS) {\n\t\t\terror = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (error == GIT_EBUFS) {\n\t\t\tif ((recvd = gitno_recv(buf)) < 0) {\n\t\t\t\terror = recvd;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (recvd == 0) {\n\t\t\t\tgiterr_set(GITERR_NET, \"early EOF\");\n\t\t\t\terror = GIT_EEOF;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tgitno_consume(buf, line_end);\n\n\t\terror = 0;\n\n\t\tif (pkt == NULL)\n\t\t\tcontinue;\n\n\t\tswitch (pkt->type) {\n\t\t\tcase GIT_PKT_DATA:\n\t\t\t\t/* This is a sideband packet which contains other packets */\n\t\t\t\terror = add_push_report_sideband_pkt(push, (git_pkt_data *)pkt, &data_pkt_buf);\n\t\t\t\tbreak;\n\t\t\tcase GIT_PKT_ERR:\n\t\t\t\tgiterr_set(GITERR_NET, \"report-status: Error reported: %s\",\n\t\t\t\t\t((git_pkt_err *)pkt)->error);\n\t\t\t\terror = -1;\n\t\t\t\tbreak;\n\t\t\tcase GIT_PKT_PROGRESS:\n\t\t\t\tif (transport->progress_cb) {\n\t\t\t\t\tgit_pkt_progress *p = (git_pkt_progress *) pkt;\n\t\t\t\t\terror = transport->progress_cb(p->data, p->len, transport->message_cb_payload);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terror = add_push_report_pkt(push, pkt);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tgit_pkt_free(pkt);\n\n\t\t/* add_push_report_pkt returns GIT_ITEROVER when it receives a flush */\n\t\tif (error == GIT_ITEROVER) {\n\t\t\terror = 0;\n\t\t\tif (data_pkt_buf.size > 0) {\n\t\t\t\t/* If there was data remaining in the pack data buffer,\n\t\t\t\t * then the server sent a partial pkt-line */\n\t\t\t\tgiterr_set(GITERR_NET, \"Incomplete pack data pkt-line\");\n\t\t\t\terror = GIT_ERROR;\n\t\t\t}\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (error < 0) {\n\t\t\tgoto done;\n\t\t}\n\t}\ndone:\n\tgit_buf_free(&data_pkt_buf);\n\treturn error;\n}",
  "abstract_func_before": "static int parse_report(transport_smart *VAR_0, git_push *VAR_1)\n{\n\tgit_pkt *VAR_2 = NULL;\n\tconst char *VAR_3 = NULL;\n\tgitno_buffer *VAR_4 = &VAR_0->buffer;\n\tint VAR_5, VAR_6;\n\tgit_buf VAR_7 = VAR_8;\n\n\tfor (;;) {\n\t\tif (VAR_4->offset > 0)\n\t\t\tVAR_5 = git_pkt_parse_line(&VAR_2, VAR_4->data,\n\t\t\t\t\t\t   &VAR_3, VAR_4->offset);\n\t\telse\n\t\t\tVAR_5 = VAR_9;\n\n\t\tif (VAR_5 < 0 && VAR_5 != VAR_9) {\n\t\t\tVAR_5 = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (VAR_5 == VAR_9) {\n\t\t\tif ((VAR_6 = gitno_recv(VAR_4)) < 0) {\n\t\t\t\tVAR_5 = VAR_6;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (VAR_6 == 0) {\n\t\t\t\tgiterr_set(VAR_10, \"early EOF\");\n\t\t\t\tVAR_5 = VAR_11;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tgitno_consume(VAR_4, VAR_3);\n\n\t\tVAR_5 = 0;\n\n\t\tif (VAR_2 == NULL)\n\t\t\tcontinue;\n\n\t\tswitch (VAR_2->type) {\n\t\t\tcase VAR_12:\n\t\t\t\t/* COMMENT_0 */\n\t\t\t\tVAR_5 = add_push_report_sideband_pkt(VAR_1, (git_pkt_data *)VAR_2, &VAR_7);\n\t\t\t\tbreak;\n\t\t\tcase VAR_13:\n\t\t\t\tgiterr_set(VAR_10, \"report-status: Error reported: %s\",\n\t\t\t\t\t((git_pkt_err *)VAR_2)->error);\n\t\t\t\tVAR_5 = -1;\n\t\t\t\tbreak;\n\t\t\tcase VAR_14:\n\t\t\t\tif (VAR_0->progress_cb) {\n\t\t\t\t\tgit_pkt_progress *VAR_15 = (git_pkt_progress *) VAR_2;\n\t\t\t\t\tVAR_5 = VAR_0->progress_cb(VAR_15->data, VAR_15->len, VAR_0->message_cb_payload);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tVAR_5 = add_push_report_pkt(VAR_1, VAR_2);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tgit_pkt_free(VAR_2);\n\n\t\t/* COMMENT_1 */\n\t\tif (VAR_5 == VAR_16) {\n\t\t\tVAR_5 = 0;\n\t\t\tif (VAR_7.size > 0) {\n\t\t\t\t/* COMMENT_2 */\n                                                 \n\t\t\t\tgiterr_set(VAR_10, \"Incomplete pack data pkt-line\");\n\t\t\t\tVAR_5 = VAR_17;\n\t\t\t}\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (VAR_5 < 0) {\n\t\t\tgoto done;\n\t\t}\n\t}\ndone:\n\tgit_buf_free(&VAR_7);\n\treturn VAR_5;\n}",
  "func_graph_path_before": "libgit2/2fdef641fd0dd2828bd948234ae86de75221a11a/smart_protocol.c/vul/before/0.json",
  "func": "static int parse_report(transport_smart *transport, git_push *push)\n{\n\tgit_pkt *pkt = NULL;\n\tconst char *line_end = NULL;\n\tgitno_buffer *buf = &transport->buffer;\n\tint error, recvd;\n\tgit_buf data_pkt_buf = GIT_BUF_INIT;\n\n\tfor (;;) {\n\t\tif (buf->offset > 0)\n\t\t\terror = git_pkt_parse_line(&pkt, buf->data,\n\t\t\t\t\t\t   &line_end, buf->offset);\n\t\telse\n\t\t\terror = GIT_EBUFS;\n\n\t\tif (error < 0 && error != GIT_EBUFS) {\n\t\t\terror = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (error == GIT_EBUFS) {\n\t\t\tif ((recvd = gitno_recv(buf)) < 0) {\n\t\t\t\terror = recvd;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (recvd == 0) {\n\t\t\t\tgiterr_set(GITERR_NET, \"early EOF\");\n\t\t\t\terror = GIT_EEOF;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tgitno_consume(buf, line_end);\n\n\t\terror = 0;\n\n\t\tswitch (pkt->type) {\n\t\t\tcase GIT_PKT_DATA:\n\t\t\t\t/* This is a sideband packet which contains other packets */\n\t\t\t\terror = add_push_report_sideband_pkt(push, (git_pkt_data *)pkt, &data_pkt_buf);\n\t\t\t\tbreak;\n\t\t\tcase GIT_PKT_ERR:\n\t\t\t\tgiterr_set(GITERR_NET, \"report-status: Error reported: %s\",\n\t\t\t\t\t((git_pkt_err *)pkt)->error);\n\t\t\t\terror = -1;\n\t\t\t\tbreak;\n\t\t\tcase GIT_PKT_PROGRESS:\n\t\t\t\tif (transport->progress_cb) {\n\t\t\t\t\tgit_pkt_progress *p = (git_pkt_progress *) pkt;\n\t\t\t\t\terror = transport->progress_cb(p->data, p->len, transport->message_cb_payload);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terror = add_push_report_pkt(push, pkt);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tgit_pkt_free(pkt);\n\n\t\t/* add_push_report_pkt returns GIT_ITEROVER when it receives a flush */\n\t\tif (error == GIT_ITEROVER) {\n\t\t\terror = 0;\n\t\t\tif (data_pkt_buf.size > 0) {\n\t\t\t\t/* If there was data remaining in the pack data buffer,\n\t\t\t\t * then the server sent a partial pkt-line */\n\t\t\t\tgiterr_set(GITERR_NET, \"Incomplete pack data pkt-line\");\n\t\t\t\terror = GIT_ERROR;\n\t\t\t}\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (error < 0) {\n\t\t\tgoto done;\n\t\t}\n\t}\ndone:\n\tgit_buf_free(&data_pkt_buf);\n\treturn error;\n}",
  "abstract_func": "static int parse_report(transport_smart *VAR_0, git_push *VAR_1)\n{\n\tgit_pkt *VAR_2 = NULL;\n\tconst char *VAR_3 = NULL;\n\tgitno_buffer *VAR_4 = &VAR_0->buffer;\n\tint VAR_5, VAR_6;\n\tgit_buf VAR_7 = VAR_8;\n\n\tfor (;;) {\n\t\tif (VAR_4->offset > 0)\n\t\t\tVAR_5 = git_pkt_parse_line(&VAR_2, VAR_4->data,\n\t\t\t\t\t\t   &VAR_3, VAR_4->offset);\n\t\telse\n\t\t\tVAR_5 = VAR_9;\n\n\t\tif (VAR_5 < 0 && VAR_5 != VAR_9) {\n\t\t\tVAR_5 = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (VAR_5 == VAR_9) {\n\t\t\tif ((VAR_6 = gitno_recv(VAR_4)) < 0) {\n\t\t\t\tVAR_5 = VAR_6;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (VAR_6 == 0) {\n\t\t\t\tgiterr_set(VAR_10, \"early EOF\");\n\t\t\t\tVAR_5 = VAR_11;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tgitno_consume(VAR_4, VAR_3);\n\n\t\tVAR_5 = 0;\n\n\t\tswitch (VAR_2->type) {\n\t\t\tcase VAR_12:\n\t\t\t\t/* COMMENT_0 */\n\t\t\t\tVAR_5 = add_push_report_sideband_pkt(VAR_1, (git_pkt_data *)VAR_2, &VAR_7);\n\t\t\t\tbreak;\n\t\t\tcase VAR_13:\n\t\t\t\tgiterr_set(VAR_10, \"report-status: Error reported: %s\",\n\t\t\t\t\t((git_pkt_err *)VAR_2)->error);\n\t\t\t\tVAR_5 = -1;\n\t\t\t\tbreak;\n\t\t\tcase VAR_14:\n\t\t\t\tif (VAR_0->progress_cb) {\n\t\t\t\t\tgit_pkt_progress *VAR_15 = (git_pkt_progress *) VAR_2;\n\t\t\t\t\tVAR_5 = VAR_0->progress_cb(VAR_15->data, VAR_15->len, VAR_0->message_cb_payload);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tVAR_5 = add_push_report_pkt(VAR_1, VAR_2);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tgit_pkt_free(VAR_2);\n\n\t\t/* COMMENT_1 */\n\t\tif (VAR_5 == VAR_16) {\n\t\t\tVAR_5 = 0;\n\t\t\tif (VAR_7.size > 0) {\n\t\t\t\t/* COMMENT_2 */\n                                                 \n\t\t\t\tgiterr_set(VAR_10, \"Incomplete pack data pkt-line\");\n\t\t\t\tVAR_5 = VAR_17;\n\t\t\t}\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (VAR_5 < 0) {\n\t\t\tgoto done;\n\t\t}\n\t}\ndone:\n\tgit_buf_free(&VAR_7);\n\treturn VAR_5;\n}",
  "func_graph_path": "libgit2/2fdef641fd0dd2828bd948234ae86de75221a11a/smart_protocol.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -35,9 +35,6 @@\n \t\tgitno_consume(buf, line_end);\n \n \t\terror = 0;\n-\n-\t\tif (pkt == NULL)\n-\t\t\tcontinue;\n \n \t\tswitch (pkt->type) {\n \t\t\tcase GIT_PKT_DATA:",
  "diff_line_info": {
    "deleted_lines": [
      "",
      "\t\tif (pkt == NULL)",
      "\t\t\tcontinue;"
    ],
    "added_lines": []
  },
  "is_vul": true,
  "pr_url": "https://github.com/libgit2/libgit2/pull/4076",
  "description": {
    "pr_info": {
      "title": "security updates for v0.25",
      "number": 4076
    },
    "comment": [
      "This fixes a buffer boundary check error and a certificate validity check which can be bogus under certain conditions."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix\nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\nAnalysis: The patch addresses a `NULL` pointer dereference caused by empty packet lines in the Git protocol, preventing a potential denial of service. The code change removes the unsafe check, treating such cases as errors.\n\nFinal Classification: Security Vulnerability Fix\nConfidence Score: 0.95"
}