{
  "cve_id": "CVE-2023-25667",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "tensorflow",
  "commit_msg": "Fix integer overflow for multiframe gifs.",
  "commit_hash": "8dc723fcdd1a6127d6c970bd2ecb18b019a1a58d",
  "git_url": "https://github.com/tensorflow/tensorflow/commit/8dc723fcdd1a6127d6c970bd2ecb18b019a1a58d",
  "file_path": "tensorflow/core/lib/gif/gif_io.cc",
  "func_name": "Decode",
  "func_before": "uint8* Decode(const void* srcdata, int datasize,\n              const std::function<uint8*(int, int, int, int)>& allocate_output,\n              string* error_string, bool expand_animations) {\n  int error_code = D_GIF_SUCCEEDED;\n  InputBufferInfo info = {reinterpret_cast<const uint8*>(srcdata), datasize};\n  GifFileType* gif_file =\n      DGifOpen(static_cast<void*>(&info), &input_callback, &error_code);\n  const auto cleanup = gtl::MakeCleanup([gif_file]() {\n    int error_code = D_GIF_SUCCEEDED;\n    if (gif_file && DGifCloseFile(gif_file, &error_code) != GIF_OK) {\n      LOG(WARNING) << \"Fail to close gif file, reason: \"\n                   << GifErrorStringNonNull(error_code);\n    }\n  });\n  if (error_code != D_GIF_SUCCEEDED) {\n    *error_string = absl::StrCat(\"failed to open gif file: \",\n                                 GifErrorStringNonNull(error_code));\n    return nullptr;\n  }\n  if (DGifSlurp(gif_file) != GIF_OK) {\n    *error_string = absl::StrCat(\"failed to slurp gif file: \",\n                                 GifErrorStringNonNull(gif_file->Error));\n    return nullptr;\n  }\n  if (gif_file->ImageCount <= 0) {\n    *error_string = \"gif file does not contain any image\";\n    return nullptr;\n  }\n\n  int target_num_frames = gif_file->ImageCount;\n\n  // Don't request more memory than needed for each frame, preventing OOM\n  int max_frame_width = 0;\n  int max_frame_height = 0;\n  for (int k = 0; k < target_num_frames; k++) {\n    SavedImage* si = &gif_file->SavedImages[k];\n    if (max_frame_height < si->ImageDesc.Height)\n      max_frame_height = si->ImageDesc.Height;\n    if (max_frame_width < si->ImageDesc.Width)\n      max_frame_width = si->ImageDesc.Width;\n  }\n\n  const int width = max_frame_width;\n  const int height = max_frame_height;\n  const int channel = 3;\n  if (!expand_animations) target_num_frames = 1;\n\n  uint8* const dstdata =\n      allocate_output(target_num_frames, width, height, channel);\n  if (!dstdata) return nullptr;\n  for (int k = 0; k < target_num_frames; k++) {\n    uint8* this_dst = dstdata + k * width * channel * height;\n\n    SavedImage* this_image = &gif_file->SavedImages[k];\n    GifImageDesc* img_desc = &this_image->ImageDesc;\n\n    // The Graphics Control Block tells us which index in the color map\n    // correspond to \"transparent color\", i.e. no need to update the pixel\n    // on the canvas. The \"transparent color index\" is specific to each\n    // sub-frame.\n    GraphicsControlBlock gcb;\n    DGifSavedExtensionToGCB(gif_file, k, &gcb);\n\n    int imgLeft = img_desc->Left;\n    int imgTop = img_desc->Top;\n    int imgRight = img_desc->Left + img_desc->Width;\n    int imgBottom = img_desc->Top + img_desc->Height;\n\n    if (k > 0) {\n      uint8* last_dst = dstdata + (k - 1) * width * channel * height;\n      for (int i = 0; i < height; ++i) {\n        uint8* p_dst = this_dst + i * width * channel;\n        uint8* l_dst = last_dst + i * width * channel;\n        for (int j = 0; j < width; ++j) {\n          p_dst[j * channel + 0] = l_dst[j * channel + 0];\n          p_dst[j * channel + 1] = l_dst[j * channel + 1];\n          p_dst[j * channel + 2] = l_dst[j * channel + 2];\n        }\n      }\n    }\n\n    if (img_desc->Left != 0 || img_desc->Top != 0 || img_desc->Width != width ||\n        img_desc->Height != height) {\n      // If the first frame does not fill the entire canvas then fill the\n      // unoccupied canvas with zeros (black).\n      if (k == 0) {\n        for (int i = 0; i < height; ++i) {\n          uint8* p_dst = this_dst + i * width * channel;\n          for (int j = 0; j < width; ++j) {\n            p_dst[j * channel + 0] = 0;\n            p_dst[j * channel + 1] = 0;\n            p_dst[j * channel + 2] = 0;\n          }\n        }\n      }\n\n      imgLeft = std::max(imgLeft, 0);\n      imgTop = std::max(imgTop, 0);\n      imgRight = std::min(imgRight, width);\n      imgBottom = std::min(imgBottom, height);\n    }\n\n    ColorMapObject* color_map = this_image->ImageDesc.ColorMap\n                                    ? this_image->ImageDesc.ColorMap\n                                    : gif_file->SColorMap;\n    if (color_map == nullptr) {\n      *error_string = absl::StrCat(\"missing color map for frame \", k);\n      return nullptr;\n    }\n\n    for (int i = imgTop; i < imgBottom; ++i) {\n      uint8* p_dst = this_dst + i * width * channel;\n      for (int j = imgLeft; j < imgRight; ++j) {\n        GifByteType color_index =\n            this_image->RasterBits[(i - img_desc->Top) * (img_desc->Width) +\n                                   (j - img_desc->Left)];\n\n        if (color_index >= color_map->ColorCount) {\n          *error_string = absl::StrCat(\"found color index \", color_index,\n                                       \" outside of color map range \",\n                                       color_map->ColorCount);\n          return nullptr;\n        }\n\n        if (color_index == gcb.TransparentColor) {\n          // Use the pixel from the previous frame. In other words, no need to\n          // update our canvas for this pixel.\n          continue;\n        }\n\n        const GifColorType& gif_color = color_map->Colors[color_index];\n        p_dst[j * channel + 0] = gif_color.Red;\n        p_dst[j * channel + 1] = gif_color.Green;\n        p_dst[j * channel + 2] = gif_color.Blue;\n      }\n    }\n  }\n\n  return dstdata;\n}",
  "abstract_func_before": "uint8* Decode(const void* VAR_0, int VAR_1,\n              const std::function<uint8*(int, int, int, int)>& VAR_2,\n              string* VAR_3, bool VAR_4) {\n  int VAR_5 = VAR_6;\n  InputBufferInfo VAR_7 = {VAR_8<const uint8*>(VAR_0), VAR_1};\n  GifFileType* VAR_9 =\n      DGifOpen(VAR_10<void*>(&VAR_7), &VAR_11, &VAR_5);\n  const auto VAR_12 = gtl::MakeCleanup([VAR_9]() {\n    int VAR_5 = VAR_6;\n    if (VAR_9 && DGifCloseFile(VAR_9, &VAR_5) != VAR_13) {\n      LOG(VAR_14) << \"Fail to close gif file, reason: \"\n                   << GifErrorStringNonNull(VAR_5);\n    }\n  });\n  if (VAR_5 != VAR_6) {\n    *VAR_3 = absl::StrCat(\"failed to open gif file: \",\n                                 GifErrorStringNonNull(VAR_5));\n    return nullptr;\n  }\n  if (DGifSlurp(VAR_9) != VAR_13) {\n    *VAR_3 = absl::StrCat(\"failed to slurp gif file: \",\n                                 GifErrorStringNonNull(VAR_9->Error));\n    return nullptr;\n  }\n  if (VAR_9->ImageCount <= 0) {\n    *VAR_3 = \"gif file does not contain any image\";\n    return nullptr;\n  }\n\n  int VAR_15 = VAR_9->ImageCount;\n\n  /* COMMENT_0 */\n  int VAR_16 = 0;\n  int VAR_17 = 0;\n  for (int VAR_18 = 0; VAR_18 < VAR_15; VAR_18++) {\n    SavedImage* VAR_19 = &VAR_9->SavedImages[VAR_18];\n    if (VAR_17 < VAR_19->ImageDesc.Height)\n      VAR_17 = VAR_19->ImageDesc.Height;\n    if (VAR_16 < VAR_19->ImageDesc.Width)\n      VAR_16 = VAR_19->ImageDesc.Width;\n  }\n\n  const int VAR_20 = VAR_16;\n  const int VAR_21 = VAR_17;\n  const int VAR_22 = 3;\n  if (!VAR_4) VAR_15 = 1;\n\n  uint8* const VAR_23 =\n      VAR_2(VAR_15, VAR_20, VAR_21, VAR_22);\n  if (!VAR_23) return nullptr;\n  for (int VAR_18 = 0; VAR_18 < VAR_15; VAR_18++) {\n    uint8* VAR_24 = VAR_23 + VAR_18 * VAR_20 * VAR_22 * VAR_21;\n\n    SavedImage* VAR_25 = &VAR_9->SavedImages[VAR_18];\n    GifImageDesc* VAR_26 = &VAR_25->ImageDesc;\n\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n    /* COMMENT_3 */\n    /* COMMENT_4 */\n    GraphicsControlBlock VAR_27;\n    DGifSavedExtensionToGCB(VAR_9, VAR_18, &VAR_27);\n\n    int VAR_28 = VAR_26->Left;\n    int VAR_29 = VAR_26->Top;\n    int VAR_30 = VAR_26->Left + VAR_26->Width;\n    int VAR_31 = VAR_26->Top + VAR_26->Height;\n\n    if (VAR_18 > 0) {\n      uint8* VAR_32 = VAR_23 + (VAR_18 - 1) * VAR_20 * VAR_22 * VAR_21;\n      for (int VAR_33 = 0; VAR_33 < VAR_21; ++VAR_33) {\n        uint8* VAR_34 = VAR_24 + VAR_33 * VAR_20 * VAR_22;\n        uint8* VAR_35 = VAR_32 + VAR_33 * VAR_20 * VAR_22;\n        for (int VAR_36 = 0; VAR_36 < VAR_20; ++VAR_36) {\n          VAR_34[VAR_36 * VAR_22 + 0] = VAR_35[VAR_36 * VAR_22 + 0];\n          VAR_34[VAR_36 * VAR_22 + 1] = VAR_35[VAR_36 * VAR_22 + 1];\n          VAR_34[VAR_36 * VAR_22 + 2] = VAR_35[VAR_36 * VAR_22 + 2];\n        }\n      }\n    }\n\n    if (VAR_26->Left != 0 || VAR_26->Top != 0 || VAR_26->Width != VAR_20 ||\n        VAR_26->Height != VAR_21) {\n      /* COMMENT_5 */\n      /* COMMENT_6 */\n      if (VAR_18 == 0) {\n        for (int VAR_33 = 0; VAR_33 < VAR_21; ++VAR_33) {\n          uint8* VAR_34 = VAR_24 + VAR_33 * VAR_20 * VAR_22;\n          for (int VAR_36 = 0; VAR_36 < VAR_20; ++VAR_36) {\n            VAR_34[VAR_36 * VAR_22 + 0] = 0;\n            VAR_34[VAR_36 * VAR_22 + 1] = 0;\n            VAR_34[VAR_36 * VAR_22 + 2] = 0;\n          }\n        }\n      }\n\n      VAR_28 = std::max(VAR_28, 0);\n      VAR_29 = std::max(VAR_29, 0);\n      VAR_30 = std::min(VAR_30, VAR_20);\n      VAR_31 = std::min(VAR_31, VAR_21);\n    }\n\n    ColorMapObject* VAR_37 = VAR_25->ImageDesc.ColorMap\n                                    ? VAR_25->ImageDesc.ColorMap\n                                    : VAR_9->SColorMap;\n    if (VAR_37 == nullptr) {\n      *VAR_3 = absl::StrCat(\"missing color map for frame \", VAR_18);\n      return nullptr;\n    }\n\n    for (int VAR_33 = VAR_29; VAR_33 < VAR_31; ++VAR_33) {\n      uint8* VAR_34 = VAR_24 + VAR_33 * VAR_20 * VAR_22;\n      for (int VAR_36 = VAR_28; VAR_36 < VAR_30; ++VAR_36) {\n        GifByteType VAR_38 =\n            VAR_25->RasterBits[(VAR_33 - VAR_26->Top) * (VAR_26->Width) +\n                                   (VAR_36 - VAR_26->Left)];\n\n        if (VAR_38 >= VAR_37->ColorCount) {\n          *VAR_3 = absl::StrCat(\"found color index \", VAR_38,\n                                       \" outside of color map range \",\n                                       VAR_37->ColorCount);\n          return nullptr;\n        }\n\n        if (VAR_38 == VAR_27.TransparentColor) {\n          /* COMMENT_7 */\n          /* COMMENT_8 */\n          continue;\n        }\n\n        const GifColorType& VAR_39 = VAR_37->Colors[VAR_38];\n        VAR_34[VAR_36 * VAR_22 + 0] = VAR_39.Red;\n        VAR_34[VAR_36 * VAR_22 + 1] = VAR_39.Green;\n        VAR_34[VAR_36 * VAR_22 + 2] = VAR_39.Blue;\n      }\n    }\n  }\n\n  return VAR_23;\n}",
  "func_graph_path_before": "tensorflow/8dc723fcdd1a6127d6c970bd2ecb18b019a1a58d/gif_io.cc/vul/before/0.json",
  "func": "uint8* Decode(const void* srcdata, int datasize,\n              const std::function<uint8*(int, int, int, int)>& allocate_output,\n              string* error_string, bool expand_animations) {\n  int error_code = D_GIF_SUCCEEDED;\n  InputBufferInfo info = {reinterpret_cast<const uint8*>(srcdata), datasize};\n  GifFileType* gif_file =\n      DGifOpen(static_cast<void*>(&info), &input_callback, &error_code);\n  const auto cleanup = gtl::MakeCleanup([gif_file]() {\n    int error_code = D_GIF_SUCCEEDED;\n    if (gif_file && DGifCloseFile(gif_file, &error_code) != GIF_OK) {\n      LOG(WARNING) << \"Fail to close gif file, reason: \"\n                   << GifErrorStringNonNull(error_code);\n    }\n  });\n  if (error_code != D_GIF_SUCCEEDED) {\n    *error_string = absl::StrCat(\"failed to open gif file: \",\n                                 GifErrorStringNonNull(error_code));\n    return nullptr;\n  }\n  if (DGifSlurp(gif_file) != GIF_OK) {\n    *error_string = absl::StrCat(\"failed to slurp gif file: \",\n                                 GifErrorStringNonNull(gif_file->Error));\n    return nullptr;\n  }\n  if (gif_file->ImageCount <= 0) {\n    *error_string = \"gif file does not contain any image\";\n    return nullptr;\n  }\n\n  int target_num_frames = gif_file->ImageCount;\n\n  // Don't request more memory than needed for each frame, preventing OOM\n  int max_frame_width = 0;\n  int max_frame_height = 0;\n  for (int k = 0; k < target_num_frames; k++) {\n    SavedImage* si = &gif_file->SavedImages[k];\n    if (max_frame_height < si->ImageDesc.Height)\n      max_frame_height = si->ImageDesc.Height;\n    if (max_frame_width < si->ImageDesc.Width)\n      max_frame_width = si->ImageDesc.Width;\n  }\n\n  const int width = max_frame_width;\n  const int height = max_frame_height;\n  const int channel = 3;\n  if (!expand_animations) target_num_frames = 1;\n\n  uint8* const dstdata =\n      allocate_output(target_num_frames, width, height, channel);\n  if (!dstdata) return nullptr;\n  for (ptrdiff_t k = 0; k < target_num_frames; k++) {\n    uint8* this_dst = dstdata + k * width * channel * height;\n\n    SavedImage* this_image = &gif_file->SavedImages[k];\n    GifImageDesc* img_desc = &this_image->ImageDesc;\n\n    // The Graphics Control Block tells us which index in the color map\n    // correspond to \"transparent color\", i.e. no need to update the pixel\n    // on the canvas. The \"transparent color index\" is specific to each\n    // sub-frame.\n    GraphicsControlBlock gcb;\n    DGifSavedExtensionToGCB(gif_file, k, &gcb);\n\n    int imgLeft = img_desc->Left;\n    int imgTop = img_desc->Top;\n    int imgRight = img_desc->Left + img_desc->Width;\n    int imgBottom = img_desc->Top + img_desc->Height;\n\n    if (k > 0) {\n      uint8* last_dst = dstdata + (k - 1) * width * channel * height;\n      for (ptrdiff_t i = 0; i < height; ++i) {\n        uint8* p_dst = this_dst + i * width * channel;\n        uint8* l_dst = last_dst + i * width * channel;\n        for (ptrdiff_t j = 0; j < width; ++j) {\n          p_dst[j * channel + 0] = l_dst[j * channel + 0];\n          p_dst[j * channel + 1] = l_dst[j * channel + 1];\n          p_dst[j * channel + 2] = l_dst[j * channel + 2];\n        }\n      }\n    }\n\n    if (img_desc->Left != 0 || img_desc->Top != 0 || img_desc->Width != width ||\n        img_desc->Height != height) {\n      // If the first frame does not fill the entire canvas then fill the\n      // unoccupied canvas with zeros (black).\n      if (k == 0) {\n        for (ptrdiff_t i = 0; i < height; ++i) {\n          uint8* p_dst = this_dst + i * width * channel;\n          for (ptrdiff_t j = 0; j < width; ++j) {\n            p_dst[j * channel + 0] = 0;\n            p_dst[j * channel + 1] = 0;\n            p_dst[j * channel + 2] = 0;\n          }\n        }\n      }\n\n      imgLeft = std::max(imgLeft, 0);\n      imgTop = std::max(imgTop, 0);\n      imgRight = std::min(imgRight, width);\n      imgBottom = std::min(imgBottom, height);\n    }\n\n    ColorMapObject* color_map = this_image->ImageDesc.ColorMap\n                                    ? this_image->ImageDesc.ColorMap\n                                    : gif_file->SColorMap;\n    if (color_map == nullptr) {\n      *error_string = absl::StrCat(\"missing color map for frame \", k);\n      return nullptr;\n    }\n\n    for (ptrdiff_t i = imgTop; i < imgBottom; ++i) {\n      uint8* p_dst = this_dst + i * width * channel;\n      for (ptrdiff_t j = imgLeft; j < imgRight; ++j) {\n        GifByteType color_index =\n            this_image->RasterBits[(i - img_desc->Top) * (img_desc->Width) +\n                                   (j - img_desc->Left)];\n\n        if (color_index >= color_map->ColorCount) {\n          *error_string = absl::StrCat(\"found color index \", color_index,\n                                       \" outside of color map range \",\n                                       color_map->ColorCount);\n          return nullptr;\n        }\n\n        if (color_index == gcb.TransparentColor) {\n          // Use the pixel from the previous frame. In other words, no need to\n          // update our canvas for this pixel.\n          continue;\n        }\n\n        const GifColorType& gif_color = color_map->Colors[color_index];\n        p_dst[j * channel + 0] = gif_color.Red;\n        p_dst[j * channel + 1] = gif_color.Green;\n        p_dst[j * channel + 2] = gif_color.Blue;\n      }\n    }\n  }\n\n  return dstdata;\n}",
  "abstract_func": "uint8* Decode(const void* VAR_0, int VAR_1,\n              const std::function<uint8*(int, int, int, int)>& VAR_2,\n              string* VAR_3, bool VAR_4) {\n  int VAR_5 = VAR_6;\n  InputBufferInfo VAR_7 = {VAR_8<const uint8*>(VAR_0), VAR_1};\n  GifFileType* VAR_9 =\n      DGifOpen(VAR_10<void*>(&VAR_7), &VAR_11, &VAR_5);\n  const auto VAR_12 = gtl::MakeCleanup([VAR_9]() {\n    int VAR_5 = VAR_6;\n    if (VAR_9 && DGifCloseFile(VAR_9, &VAR_5) != VAR_13) {\n      LOG(VAR_14) << \"Fail to close gif file, reason: \"\n                   << GifErrorStringNonNull(VAR_5);\n    }\n  });\n  if (VAR_5 != VAR_6) {\n    *VAR_3 = absl::StrCat(\"failed to open gif file: \",\n                                 GifErrorStringNonNull(VAR_5));\n    return nullptr;\n  }\n  if (DGifSlurp(VAR_9) != VAR_13) {\n    *VAR_3 = absl::StrCat(\"failed to slurp gif file: \",\n                                 GifErrorStringNonNull(VAR_9->Error));\n    return nullptr;\n  }\n  if (VAR_9->ImageCount <= 0) {\n    *VAR_3 = \"gif file does not contain any image\";\n    return nullptr;\n  }\n\n  int VAR_15 = VAR_9->ImageCount;\n\n  /* COMMENT_0 */\n  int VAR_16 = 0;\n  int VAR_17 = 0;\n  for (int VAR_18 = 0; VAR_18 < VAR_15; VAR_18++) {\n    SavedImage* VAR_19 = &VAR_9->SavedImages[VAR_18];\n    if (VAR_17 < VAR_19->ImageDesc.Height)\n      VAR_17 = VAR_19->ImageDesc.Height;\n    if (VAR_16 < VAR_19->ImageDesc.Width)\n      VAR_16 = VAR_19->ImageDesc.Width;\n  }\n\n  const int VAR_20 = VAR_16;\n  const int VAR_21 = VAR_17;\n  const int VAR_22 = 3;\n  if (!VAR_4) VAR_15 = 1;\n\n  uint8* const VAR_23 =\n      VAR_2(VAR_15, VAR_20, VAR_21, VAR_22);\n  if (!VAR_23) return nullptr;\n  for (ptrdiff_t VAR_18 = 0; VAR_18 < VAR_15; VAR_18++) {\n    uint8* VAR_24 = VAR_23 + VAR_18 * VAR_20 * VAR_22 * VAR_21;\n\n    SavedImage* VAR_25 = &VAR_9->SavedImages[VAR_18];\n    GifImageDesc* VAR_26 = &VAR_25->ImageDesc;\n\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n    /* COMMENT_3 */\n    /* COMMENT_4 */\n    GraphicsControlBlock VAR_27;\n    DGifSavedExtensionToGCB(VAR_9, VAR_18, &VAR_27);\n\n    int VAR_28 = VAR_26->Left;\n    int VAR_29 = VAR_26->Top;\n    int VAR_30 = VAR_26->Left + VAR_26->Width;\n    int VAR_31 = VAR_26->Top + VAR_26->Height;\n\n    if (VAR_18 > 0) {\n      uint8* VAR_32 = VAR_23 + (VAR_18 - 1) * VAR_20 * VAR_22 * VAR_21;\n      for (ptrdiff_t VAR_33 = 0; VAR_33 < VAR_21; ++VAR_33) {\n        uint8* VAR_34 = VAR_24 + VAR_33 * VAR_20 * VAR_22;\n        uint8* VAR_35 = VAR_32 + VAR_33 * VAR_20 * VAR_22;\n        for (ptrdiff_t VAR_36 = 0; VAR_36 < VAR_20; ++VAR_36) {\n          VAR_34[VAR_36 * VAR_22 + 0] = VAR_35[VAR_36 * VAR_22 + 0];\n          VAR_34[VAR_36 * VAR_22 + 1] = VAR_35[VAR_36 * VAR_22 + 1];\n          VAR_34[VAR_36 * VAR_22 + 2] = VAR_35[VAR_36 * VAR_22 + 2];\n        }\n      }\n    }\n\n    if (VAR_26->Left != 0 || VAR_26->Top != 0 || VAR_26->Width != VAR_20 ||\n        VAR_26->Height != VAR_21) {\n      /* COMMENT_5 */\n      /* COMMENT_6 */\n      if (VAR_18 == 0) {\n        for (ptrdiff_t VAR_33 = 0; VAR_33 < VAR_21; ++VAR_33) {\n          uint8* VAR_34 = VAR_24 + VAR_33 * VAR_20 * VAR_22;\n          for (ptrdiff_t VAR_36 = 0; VAR_36 < VAR_20; ++VAR_36) {\n            VAR_34[VAR_36 * VAR_22 + 0] = 0;\n            VAR_34[VAR_36 * VAR_22 + 1] = 0;\n            VAR_34[VAR_36 * VAR_22 + 2] = 0;\n          }\n        }\n      }\n\n      VAR_28 = std::max(VAR_28, 0);\n      VAR_29 = std::max(VAR_29, 0);\n      VAR_30 = std::min(VAR_30, VAR_20);\n      VAR_31 = std::min(VAR_31, VAR_21);\n    }\n\n    ColorMapObject* VAR_37 = VAR_25->ImageDesc.ColorMap\n                                    ? VAR_25->ImageDesc.ColorMap\n                                    : VAR_9->SColorMap;\n    if (VAR_37 == nullptr) {\n      *VAR_3 = absl::StrCat(\"missing color map for frame \", VAR_18);\n      return nullptr;\n    }\n\n    for (ptrdiff_t VAR_33 = VAR_29; VAR_33 < VAR_31; ++VAR_33) {\n      uint8* VAR_34 = VAR_24 + VAR_33 * VAR_20 * VAR_22;\n      for (ptrdiff_t VAR_36 = VAR_28; VAR_36 < VAR_30; ++VAR_36) {\n        GifByteType VAR_38 =\n            VAR_25->RasterBits[(VAR_33 - VAR_26->Top) * (VAR_26->Width) +\n                                   (VAR_36 - VAR_26->Left)];\n\n        if (VAR_38 >= VAR_37->ColorCount) {\n          *VAR_3 = absl::StrCat(\"found color index \", VAR_38,\n                                       \" outside of color map range \",\n                                       VAR_37->ColorCount);\n          return nullptr;\n        }\n\n        if (VAR_38 == VAR_27.TransparentColor) {\n          /* COMMENT_7 */\n          /* COMMENT_8 */\n          continue;\n        }\n\n        const GifColorType& VAR_39 = VAR_37->Colors[VAR_38];\n        VAR_34[VAR_36 * VAR_22 + 0] = VAR_39.Red;\n        VAR_34[VAR_36 * VAR_22 + 1] = VAR_39.Green;\n        VAR_34[VAR_36 * VAR_22 + 2] = VAR_39.Blue;\n      }\n    }\n  }\n\n  return VAR_23;\n}",
  "func_graph_path": "tensorflow/8dc723fcdd1a6127d6c970bd2ecb18b019a1a58d/gif_io.cc/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -48,7 +48,7 @@\n   uint8* const dstdata =\n       allocate_output(target_num_frames, width, height, channel);\n   if (!dstdata) return nullptr;\n-  for (int k = 0; k < target_num_frames; k++) {\n+  for (ptrdiff_t k = 0; k < target_num_frames; k++) {\n     uint8* this_dst = dstdata + k * width * channel * height;\n \n     SavedImage* this_image = &gif_file->SavedImages[k];\n@@ -68,10 +68,10 @@\n \n     if (k > 0) {\n       uint8* last_dst = dstdata + (k - 1) * width * channel * height;\n-      for (int i = 0; i < height; ++i) {\n+      for (ptrdiff_t i = 0; i < height; ++i) {\n         uint8* p_dst = this_dst + i * width * channel;\n         uint8* l_dst = last_dst + i * width * channel;\n-        for (int j = 0; j < width; ++j) {\n+        for (ptrdiff_t j = 0; j < width; ++j) {\n           p_dst[j * channel + 0] = l_dst[j * channel + 0];\n           p_dst[j * channel + 1] = l_dst[j * channel + 1];\n           p_dst[j * channel + 2] = l_dst[j * channel + 2];\n@@ -84,9 +84,9 @@\n       // If the first frame does not fill the entire canvas then fill the\n       // unoccupied canvas with zeros (black).\n       if (k == 0) {\n-        for (int i = 0; i < height; ++i) {\n+        for (ptrdiff_t i = 0; i < height; ++i) {\n           uint8* p_dst = this_dst + i * width * channel;\n-          for (int j = 0; j < width; ++j) {\n+          for (ptrdiff_t j = 0; j < width; ++j) {\n             p_dst[j * channel + 0] = 0;\n             p_dst[j * channel + 1] = 0;\n             p_dst[j * channel + 2] = 0;\n@@ -108,9 +108,9 @@\n       return nullptr;\n     }\n \n-    for (int i = imgTop; i < imgBottom; ++i) {\n+    for (ptrdiff_t i = imgTop; i < imgBottom; ++i) {\n       uint8* p_dst = this_dst + i * width * channel;\n-      for (int j = imgLeft; j < imgRight; ++j) {\n+      for (ptrdiff_t j = imgLeft; j < imgRight; ++j) {\n         GifByteType color_index =\n             this_image->RasterBits[(i - img_desc->Top) * (img_desc->Width) +\n                                    (j - img_desc->Left)];",
  "diff_line_info": {
    "deleted_lines": [
      "  for (int k = 0; k < target_num_frames; k++) {",
      "      for (int i = 0; i < height; ++i) {",
      "        for (int j = 0; j < width; ++j) {",
      "        for (int i = 0; i < height; ++i) {",
      "          for (int j = 0; j < width; ++j) {",
      "    for (int i = imgTop; i < imgBottom; ++i) {",
      "      for (int j = imgLeft; j < imgRight; ++j) {"
    ],
    "added_lines": [
      "  for (ptrdiff_t k = 0; k < target_num_frames; k++) {",
      "      for (ptrdiff_t i = 0; i < height; ++i) {",
      "        for (ptrdiff_t j = 0; j < width; ++j) {",
      "        for (ptrdiff_t i = 0; i < height; ++i) {",
      "          for (ptrdiff_t j = 0; j < width; ++j) {",
      "    for (ptrdiff_t i = imgTop; i < imgBottom; ++i) {",
      "      for (ptrdiff_t j = imgLeft; j < imgRight; ++j) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/tensorflow/tensorflow/pull/58104",
  "description": {
    "pr_info": {
      "title": "Fix segfault for multiframe gifs.",
      "number": 58104
    },
    "comment": [
      "Integer overflow occurs when 2^31 <= num_frames * height * width * channels < 2^32, for example Full HD screencast of at least 346 frames."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix\nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\nAnalysis: The patch addresses an integer overflow issue in processing multiframe GIFs, which could lead to buffer overflow vulnerabilities. The code changes replace int with ptrdiff_t in loops to prevent overflow, indicating a security fix.\nFinal Classification: Security Vulnerability Fix\nConfidence Score: 0.95"
}