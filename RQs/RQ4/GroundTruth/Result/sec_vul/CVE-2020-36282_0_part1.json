{
  "cve_id": "CVE-2020-36282",
  "cwe_ids": [
    "CWE-502"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "rabbitmq/rabbitmq-jms-client",
  "commit_msg": "Use trusted packages in StreamMessage\n\nStreamMessage now uses the same \"white list\" mechanism as\nObjectMessage to avoid some arbitrary code execution on deserialization.\n\nEven though StreamMessage is supposed to handle only primitive types,\nit is still to possible to send a message that contains an arbitrary\nserializable instance. The consuming application application may\nthen execute code from this class on deserialization.\n\nThe fix consists in using the list of trusted packages that can be\nset at the connection factory level.\n\nFixes #135",
  "commit_hash": "f647e5dbfe055a2ca8cbb16dd70f9d50d888b638",
  "git_url": "https://github.com/rabbitmq/rabbitmq-jms-client/commit/f647e5dbfe055a2ca8cbb16dd70f9d50d888b638",
  "file_path": "src/main/java/com/rabbitmq/jms/client/RMQMessage.java",
  "func_name": "instantiateRmqObjectMessageWithTrustedPackages",
  "func_before": "private static RMQObjectMessage instantiateRmqObjectMessageWithTrustedPackages(List<String> trustedPackages) throws RMQJMSException {\n        try {\n            // instantiate the message object with the thread context classloader\n            Class<?> messageClass = Class.forName(RMQObjectMessage.class.getName(), true, Thread.currentThread().getContextClassLoader());\n            Constructor<?> constructor = messageClass.getConstructor(List.class);\n            return (RMQObjectMessage) constructor.newInstance(trustedPackages);\n        } catch (NoSuchMethodException e) {\n            throw new RMQJMSException(e);\n        } catch (InvocationTargetException e) {\n            throw new RMQJMSException(e);\n        } catch (IllegalAccessException e) {\n            throw new RMQJMSException(e);\n        } catch (InstantiationException e) {\n            throw new RMQJMSException(e);\n        } catch (ClassNotFoundException e) {\n            throw new RMQJMSException(e);\n        }\n    }",
  "abstract_func_before": "private static RMQObjectMessage instantiateRmqObjectMessageWithTrustedPackages(List<String> VAR_0) throws RMQJMSException {\n        try {\n            /* COMMENT_0 */\n            Class<?> VAR_1 = VAR_2.forName(RMQObjectMessage.class.getName(), true, VAR_3.currentThread().getContextClassLoader());\n            Constructor<?> VAR_4 = VAR_1.getConstructor(List.class);\n            return (RMQObjectMessage) VAR_4.newInstance(VAR_0);\n        } catch (NoSuchMethodException VAR_5) {\n            throw new RMQJMSException(VAR_5);\n        } catch (InvocationTargetException VAR_5) {\n            throw new RMQJMSException(VAR_5);\n        } catch (IllegalAccessException VAR_5) {\n            throw new RMQJMSException(VAR_5);\n        } catch (InstantiationException VAR_5) {\n            throw new RMQJMSException(VAR_5);\n        } catch (ClassNotFoundException VAR_5) {\n            throw new RMQJMSException(VAR_5);\n        }\n    }",
  "func_graph_path_before": "rabbitmq/rabbitmq-jms-client/f647e5dbfe055a2ca8cbb16dd70f9d50d888b638/RMQMessage.java/vul/before/1.json",
  "func": "private static RMQObjectMessage instantiateRmqObjectMessageWithTrustedPackages(List<String> trustedPackages) throws RMQJMSException {\n        return (RMQObjectMessage) instantiateRmqMessageWithTrustedPackages(RMQObjectMessage.class.getName(), trustedPackages);\n    }",
  "abstract_func": "private static RMQObjectMessage instantiateRmqObjectMessageWithTrustedPackages(List<String> VAR_0) throws RMQJMSException {\n        return (RMQObjectMessage) instantiateRmqMessageWithTrustedPackages(RMQObjectMessage.class.getName(), VAR_0);\n    }",
  "func_graph_path": "rabbitmq/rabbitmq-jms-client/f647e5dbfe055a2ca8cbb16dd70f9d50d888b638/RMQMessage.java/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,18 +1,3 @@\n private static RMQObjectMessage instantiateRmqObjectMessageWithTrustedPackages(List<String> trustedPackages) throws RMQJMSException {\n-        try {\n-            // instantiate the message object with the thread context classloader\n-            Class<?> messageClass = Class.forName(RMQObjectMessage.class.getName(), true, Thread.currentThread().getContextClassLoader());\n-            Constructor<?> constructor = messageClass.getConstructor(List.class);\n-            return (RMQObjectMessage) constructor.newInstance(trustedPackages);\n-        } catch (NoSuchMethodException e) {\n-            throw new RMQJMSException(e);\n-        } catch (InvocationTargetException e) {\n-            throw new RMQJMSException(e);\n-        } catch (IllegalAccessException e) {\n-            throw new RMQJMSException(e);\n-        } catch (InstantiationException e) {\n-            throw new RMQJMSException(e);\n-        } catch (ClassNotFoundException e) {\n-            throw new RMQJMSException(e);\n-        }\n+        return (RMQObjectMessage) instantiateRmqMessageWithTrustedPackages(RMQObjectMessage.class.getName(), trustedPackages);\n     }",
  "diff_line_info": {
    "deleted_lines": [
      "        try {",
      "            // instantiate the message object with the thread context classloader",
      "            Class<?> messageClass = Class.forName(RMQObjectMessage.class.getName(), true, Thread.currentThread().getContextClassLoader());",
      "            Constructor<?> constructor = messageClass.getConstructor(List.class);",
      "            return (RMQObjectMessage) constructor.newInstance(trustedPackages);",
      "        } catch (NoSuchMethodException e) {",
      "            throw new RMQJMSException(e);",
      "        } catch (InvocationTargetException e) {",
      "            throw new RMQJMSException(e);",
      "        } catch (IllegalAccessException e) {",
      "            throw new RMQJMSException(e);",
      "        } catch (InstantiationException e) {",
      "            throw new RMQJMSException(e);",
      "        } catch (ClassNotFoundException e) {",
      "            throw new RMQJMSException(e);",
      "        }"
    ],
    "added_lines": [
      "        return (RMQObjectMessage) instantiateRmqMessageWithTrustedPackages(RMQObjectMessage.class.getName(), trustedPackages);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/rabbitmq/rabbitmq-jms-client/pull/136",
  "description": {
    "pr_info": {
      "title": "Use trusted packages in StreamMessage",
      "number": 136
    },
    "comment": [
      "StreamMessage now uses the same \"white list\" mechanism as\r\nObjectMessage to avoid some arbitrary code execution on deserialization.\r\n\r\nEven though StreamMessage is supposed to handle only primitive types,\r\nit is still to possible to send a message that contains an arbitrary\r\nserializable instance. The consuming application application may\r\nthen execute code from this class on deserialization.\r\n\r\nThe fix consists in using the list of trusted packages that can be\r\nset at the connection factory level.\r\n\r\nFixes #135"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix\n\nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses a deserialization vulnerability in StreamMessage by implementing a whitelist mechanism to prevent arbitrary code execution. The code change replaces reflection-based instantiation with a trusted package check, directly mitigating a security risk.\n\nFinal Classification: Security Vulnerability Fix\n\nConfidence Score: 1.0"
}