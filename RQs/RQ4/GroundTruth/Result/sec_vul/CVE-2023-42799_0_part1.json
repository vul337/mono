{
  "cve_id": "CVE-2023-42799",
  "cwe_ids": [
    "CWE-120"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "moonlight-stream/moonlight-common-c",
  "commit_msg": "Fix buffer overflow in parseUrlAddrFromRtspUrlString (CVE-2023-42799)",
  "commit_hash": "02b7742f4d19631024bd766bd2bb76715780004e",
  "git_url": "https://github.com/moonlight-stream/moonlight-common-c/commit/02b7742f4d19631024bd766bd2bb76715780004e",
  "file_path": "src/RtspConnection.c",
  "func_name": "parseUrlAddrFromRtspUrlString",
  "func_before": "static bool parseUrlAddrFromRtspUrlString(const char* rtspUrlString, char* destination) {\n    char* rtspUrlScratchBuffer;\n    char* portSeparator;\n    char* v6EscapeEndChar;\n    char* urlPathSeparator;\n    int prefixLen;\n\n    // Create a copy that we can modify\n    rtspUrlScratchBuffer = strdup(rtspUrlString);\n    if (rtspUrlScratchBuffer == NULL) {\n        return false;\n    }\n\n    // If we have a v6 address, we want to stop one character after the closing ]\n    // If we have a v4 address, we want to stop at the port separator\n    portSeparator = strrchr(rtspUrlScratchBuffer, ':');\n    v6EscapeEndChar = strchr(rtspUrlScratchBuffer, ']');\n\n    // Count the prefix length to skip past the initial rtsp:// or rtspru:// part\n    for (prefixLen = 2; rtspUrlScratchBuffer[prefixLen - 2] != 0 && (rtspUrlScratchBuffer[prefixLen - 2] != '/' || rtspUrlScratchBuffer[prefixLen - 1] != '/'); prefixLen++);\n\n    // If we hit the end of the string prior to parsing the prefix, we cannot proceed\n    if (rtspUrlScratchBuffer[prefixLen - 2] == 0) {\n        free(rtspUrlScratchBuffer);\n        return false;\n    }\n\n    // Look for a slash at the end of the host portion of the URL (may not be present)\n    urlPathSeparator = strchr(rtspUrlScratchBuffer + prefixLen, '/');\n\n    // Check for a v6 address first since they also have colons\n    if (v6EscapeEndChar) {\n        // Terminate the string at the next character\n        *(v6EscapeEndChar + 1) = 0;\n    }\n    else if (portSeparator) {\n        // Terminate the string prior to the port separator\n        *portSeparator = 0;\n    }\n    else if (urlPathSeparator) {\n        // Terminate the string prior to the path separator\n        *urlPathSeparator = 0;\n    }\n\n    strcpy(destination, rtspUrlScratchBuffer + prefixLen);\n\n    free(rtspUrlScratchBuffer);\n    return true;\n}",
  "abstract_func_before": "static bool parseUrlAddrFromRtspUrlString(const char* VAR_0, char* VAR_1) {\n    char* VAR_2;\n    char* VAR_3;\n    char* VAR_4;\n    char* VAR_5;\n    int VAR_6;\n\n    /* COMMENT_0 */\n    VAR_2 = strdup(VAR_0);\n    if (VAR_2 == NULL) {\n        return false;\n    }\n\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n    VAR_3 = strrchr(VAR_2, ':');\n    VAR_4 = strchr(VAR_2, ']');\n\n    /* COMMENT_3 */\n    for (VAR_6 = 2; VAR_2[VAR_6 - 2] != 0 && (VAR_2[VAR_6 - 2] != '/' || VAR_2[VAR_6 - 1] != '/'); VAR_6++);\n\n    /* COMMENT_4 */\n    if (VAR_2[VAR_6 - 2] == 0) {\n        free(VAR_2);\n        return false;\n    }\n\n    /* COMMENT_5 */\n    VAR_5 = strchr(VAR_2 + VAR_6, '/');\n\n    /* COMMENT_6 */\n    if (VAR_4) {\n        /* COMMENT_7 */\n        *(VAR_4 + 1) = 0;\n    }\n    else if (VAR_3) {\n        /* COMMENT_8 */\n        *VAR_3 = 0;\n    }\n    else if (VAR_5) {\n        /* COMMENT_9 */\n        *VAR_5 = 0;\n    }\n\n    strcpy(VAR_1, VAR_2 + VAR_6);\n\n    free(VAR_2);\n    return true;\n}",
  "func_graph_path_before": "moonlight-stream/moonlight-common-c/02b7742f4d19631024bd766bd2bb76715780004e/RtspConnection.c/vul/before/1.json",
  "func": "static bool parseUrlAddrFromRtspUrlString(const char* rtspUrlString, char* destination, size_t destinationLength) {\n    char* rtspUrlScratchBuffer;\n    char* portSeparator;\n    char* v6EscapeEndChar;\n    char* urlPathSeparator;\n    int prefixLen;\n\n    // Create a copy that we can modify\n    rtspUrlScratchBuffer = strdup(rtspUrlString);\n    if (rtspUrlScratchBuffer == NULL) {\n        return false;\n    }\n\n    // If we have a v6 address, we want to stop one character after the closing ]\n    // If we have a v4 address, we want to stop at the port separator\n    portSeparator = strrchr(rtspUrlScratchBuffer, ':');\n    v6EscapeEndChar = strchr(rtspUrlScratchBuffer, ']');\n\n    // Count the prefix length to skip past the initial rtsp:// or rtspru:// part\n    for (prefixLen = 2; rtspUrlScratchBuffer[prefixLen - 2] != 0 && (rtspUrlScratchBuffer[prefixLen - 2] != '/' || rtspUrlScratchBuffer[prefixLen - 1] != '/'); prefixLen++);\n\n    // If we hit the end of the string prior to parsing the prefix, we cannot proceed\n    if (rtspUrlScratchBuffer[prefixLen - 2] == 0) {\n        free(rtspUrlScratchBuffer);\n        return false;\n    }\n\n    // Look for a slash at the end of the host portion of the URL (may not be present)\n    urlPathSeparator = strchr(rtspUrlScratchBuffer + prefixLen, '/');\n\n    // Check for a v6 address first since they also have colons\n    if (v6EscapeEndChar) {\n        // Terminate the string at the next character\n        *(v6EscapeEndChar + 1) = 0;\n    }\n    else if (portSeparator) {\n        // Terminate the string prior to the port separator\n        *portSeparator = 0;\n    }\n    else if (urlPathSeparator) {\n        // Terminate the string prior to the path separator\n        *urlPathSeparator = 0;\n    }\n\n    PltSafeStrcpy(destination, destinationLength, rtspUrlScratchBuffer + prefixLen);\n    destination[destinationLength - 1] = '\\0';\n\n    free(rtspUrlScratchBuffer);\n    return true;\n}",
  "abstract_func": "static bool parseUrlAddrFromRtspUrlString(const char* VAR_0, char* VAR_1, size_t VAR_2) {\n    char* VAR_3;\n    char* VAR_4;\n    char* VAR_5;\n    char* VAR_6;\n    int VAR_7;\n\n    /* COMMENT_0 */\n    VAR_3 = strdup(VAR_0);\n    if (VAR_3 == NULL) {\n        return false;\n    }\n\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n    VAR_4 = strrchr(VAR_3, ':');\n    VAR_5 = strchr(VAR_3, ']');\n\n    /* COMMENT_3 */\n    for (VAR_7 = 2; VAR_3[VAR_7 - 2] != 0 && (VAR_3[VAR_7 - 2] != '/' || VAR_3[VAR_7 - 1] != '/'); VAR_7++);\n\n    /* COMMENT_4 */\n    if (VAR_3[VAR_7 - 2] == 0) {\n        free(VAR_3);\n        return false;\n    }\n\n    /* COMMENT_5 */\n    VAR_6 = strchr(VAR_3 + VAR_7, '/');\n\n    /* COMMENT_6 */\n    if (VAR_5) {\n        /* COMMENT_7 */\n        *(VAR_5 + 1) = 0;\n    }\n    else if (VAR_4) {\n        /* COMMENT_8 */\n        *VAR_4 = 0;\n    }\n    else if (VAR_6) {\n        /* COMMENT_9 */\n        *VAR_6 = 0;\n    }\n\n    PltSafeStrcpy(VAR_1, VAR_2, VAR_3 + VAR_7);\n    VAR_1[VAR_2 - 1] = '\\0';\n\n    free(VAR_3);\n    return true;\n}",
  "func_graph_path": "moonlight-stream/moonlight-common-c/02b7742f4d19631024bd766bd2bb76715780004e/RtspConnection.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-static bool parseUrlAddrFromRtspUrlString(const char* rtspUrlString, char* destination) {\n+static bool parseUrlAddrFromRtspUrlString(const char* rtspUrlString, char* destination, size_t destinationLength) {\n     char* rtspUrlScratchBuffer;\n     char* portSeparator;\n     char* v6EscapeEndChar;\n@@ -42,7 +42,8 @@\n         *urlPathSeparator = 0;\n     }\n \n-    strcpy(destination, rtspUrlScratchBuffer + prefixLen);\n+    PltSafeStrcpy(destination, destinationLength, rtspUrlScratchBuffer + prefixLen);\n+    destination[destinationLength - 1] = '\\0';\n \n     free(rtspUrlScratchBuffer);\n     return true;",
  "diff_line_info": {
    "deleted_lines": [
      "static bool parseUrlAddrFromRtspUrlString(const char* rtspUrlString, char* destination) {",
      "    strcpy(destination, rtspUrlScratchBuffer + prefixLen);"
    ],
    "added_lines": [
      "static bool parseUrlAddrFromRtspUrlString(const char* rtspUrlString, char* destination, size_t destinationLength) {",
      "    PltSafeStrcpy(destination, destinationLength, rtspUrlScratchBuffer + prefixLen);",
      "    destination[destinationLength - 1] = '\\0';"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/moonlight-stream/moonlight-common-c/pull/83",
  "description": {
    "pr_info": {
      "title": "Fix for buffer overflows in RTSP parsing",
      "number": 83
    },
    "comment": [
      "Fix for CVE-2023-42799 and CVE-2023-42800. Replace calls to `strcpy` with `PltSafeStrcpy`."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix\n\nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch modifies a function to fix a buffer overflow issue, replacing an unsafe string copy function with a safe alternative and adding a null terminator. This addresses a known security vulnerability (CVE-2023-42799), which could lead to unauthorized access or code execution.\n\nFinal Classification: Security Vulnerability Fix\n\nConfidence Score: 1.0"
}