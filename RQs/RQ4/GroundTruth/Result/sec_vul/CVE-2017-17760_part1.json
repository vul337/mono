{
  "cve_id": "CVE-2017-17760",
  "cwe_ids": [
    "CWE-119"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "opencv",
  "commit_msg": "imgcodecs(pxm): fix memcpy size",
  "commit_hash": "7bbe1a53cfc097b82b1589f7915a2120de39274c",
  "git_url": "https://github.com/opencv/opencv/commit/7bbe1a53cfc097b82b1589f7915a2120de39274c",
  "file_path": "modules/imgcodecs/src/grfmt_pxm.cpp",
  "func_name": "PxMDecoder::readData",
  "func_before": "bool PxMDecoder::readData( Mat& img )\n{\n    int color = img.channels() > 1;\n    uchar* data = img.ptr();\n    PaletteEntry palette[256];\n    bool   result = false;\n    const int bit_depth = CV_ELEM_SIZE1(m_type)*8;\n    const int src_pitch = divUp(m_width*m_bpp*(bit_depth/8), 8);\n    int  nch = CV_MAT_CN(m_type);\n    int  width3 = m_width*nch;\n\n    if( m_offset < 0 || !m_strm.isOpened())\n        return false;\n\n    uchar gray_palette[256] = {0};\n\n    // create LUT for converting colors\n    if( bit_depth == 8 )\n    {\n        CV_Assert(m_maxval < 256);\n\n        for (int i = 0; i <= m_maxval; i++)\n            gray_palette[i] = (uchar)((i*255/m_maxval)^(m_bpp == 1 ? 255 : 0));\n\n        FillGrayPalette( palette, m_bpp==1 ? 1 : 8 , m_bpp == 1 );\n    }\n\n    CV_TRY\n    {\n        m_strm.setPos( m_offset );\n\n        switch( m_bpp )\n        {\n        ////////////////////////// 1 BPP /////////////////////////\n        case 1:\n            CV_Assert(CV_MAT_DEPTH(m_type) == CV_8U);\n            if( !m_binary )\n            {\n                AutoBuffer<uchar> _src(m_width);\n                uchar* src = _src;\n\n                for (int y = 0; y < m_height; y++, data += img.step)\n                {\n                    for (int x = 0; x < m_width; x++)\n                        src[x] = ReadNumber(m_strm, 1) != 0;\n\n                    if( color )\n                        FillColorRow8( data, src, m_width, palette );\n                    else\n                        FillGrayRow8( data, src, m_width, gray_palette );\n                }\n            }\n            else\n            {\n                AutoBuffer<uchar> _src(src_pitch);\n                uchar* src = _src;\n\n                for (int y = 0; y < m_height; y++, data += img.step)\n                {\n                    m_strm.getBytes( src, src_pitch );\n\n                    if( color )\n                        FillColorRow1( data, src, m_width, palette );\n                    else\n                        FillGrayRow1( data, src, m_width, gray_palette );\n                }\n            }\n            result = true;\n            break;\n\n        ////////////////////////// 8 BPP /////////////////////////\n        case 8:\n        case 24:\n        {\n            AutoBuffer<uchar> _src(std::max<size_t>(width3*2, src_pitch));\n            uchar* src = _src;\n\n            for (int y = 0; y < m_height; y++, data += img.step)\n            {\n                if( !m_binary )\n                {\n                    for (int x = 0; x < width3; x++)\n                    {\n                        int code = ReadNumber(m_strm);\n                        if( (unsigned)code > (unsigned)m_maxval ) code = m_maxval;\n                        if( bit_depth == 8 )\n                            src[x] = gray_palette[code];\n                        else\n                            ((ushort *)src)[x] = (ushort)code;\n                    }\n                }\n                else\n                {\n                    m_strm.getBytes( src, src_pitch );\n                    if( bit_depth == 16 && !isBigEndian() )\n                    {\n                        for (int x = 0; x < width3; x++)\n                        {\n                            uchar v = src[x * 2];\n                            src[x * 2] = src[x * 2 + 1];\n                            src[x * 2 + 1] = v;\n                        }\n                    }\n                }\n\n                if( img.depth() == CV_8U && bit_depth == 16 )\n                {\n                    for (int x = 0; x < width3; x++)\n                    {\n                        int v = ((ushort *)src)[x];\n                        src[x] = (uchar)(v >> 8);\n                    }\n                }\n\n                if( m_bpp == 8 ) // image has one channel\n                {\n                    if( color )\n                    {\n                        if( img.depth() == CV_8U ) {\n                            uchar *d = data, *s = src, *end = src + m_width;\n                            for( ; s < end; d += 3, s++)\n                                d[0] = d[1] = d[2] = *s;\n                        } else {\n                            ushort *d = (ushort *)data, *s = (ushort *)src, *end = ((ushort *)src) + m_width;\n                            for( ; s < end; s++, d += 3)\n                                d[0] = d[1] = d[2] = *s;\n                        }\n                    }\n                    else\n                        memcpy( data, src, CV_ELEM_SIZE1(m_type)*m_width);\n                }\n                else\n                {\n                    if( color )\n                    {\n                        if( img.depth() == CV_8U )\n                            icvCvt_RGB2BGR_8u_C3R( src, 0, data, 0, cvSize(m_width,1) );\n                        else\n                            icvCvt_RGB2BGR_16u_C3R( (ushort *)src, 0, (ushort *)data, 0, cvSize(m_width,1) );\n                    }\n                    else if( img.depth() == CV_8U )\n                        icvCvt_BGR2Gray_8u_C3C1R( src, 0, data, 0, cvSize(m_width,1), 2 );\n                    else\n                        icvCvt_BGRA2Gray_16u_CnC1R( (ushort *)src, 0, (ushort *)data, 0, cvSize(m_width,1), 3, 2 );\n                }\n            }\n            result = true;\n            break;\n        }\n        default:\n            CV_ErrorNoReturn(Error::StsError, \"m_bpp is not supported\");\n        }\n    }",
  "abstract_func_before": "bool PxMDecoder::readData( Mat& VAR_0 )\n{\n    int VAR_1 = VAR_0.channels() > 1;\n    uchar* VAR_2 = VAR_0.ptr();\n    PaletteEntry VAR_3[256];\n    bool   VAR_4 = false;\n    const int VAR_5 = CV_ELEM_SIZE1(VAR_6)*8;\n    const int VAR_7 = divUp(VAR_8*VAR_9*(VAR_5/8), 8);\n    int  VAR_10 = CV_MAT_CN(VAR_6);\n    int  VAR_11 = VAR_8*VAR_10;\n\n    if( VAR_12 < 0 || !VAR_13.isOpened())\n        return false;\n\n    uchar VAR_14[256] = {0};\n\n    /* COMMENT_0 */\n    if( VAR_5 == 8 )\n    {\n        CV_Assert(VAR_15 < 256);\n\n        for (int VAR_16 = 0; VAR_16 <= VAR_15; VAR_16++)\n            VAR_14[VAR_16] = (uchar)((VAR_16*255/VAR_15)^(VAR_9 == 1 ? 255 : 0));\n\n        FillGrayPalette( VAR_3, VAR_9==1 ? 1 : 8 , VAR_9 == 1 );\n    }\n\n    CV_TRY\n    {\n        VAR_13.setPos( VAR_12 );\n\n        switch( VAR_9 )\n        {\n        /* COMMENT_1 */\n        case 1:\n            CV_Assert(CV_MAT_DEPTH(VAR_6) == VAR_17);\n            if( !VAR_18 )\n            {\n                AutoBuffer<uchar> _src(m_width);\n                uchar* VAR_19 = VAR_20;\n\n                for (int VAR_21 = 0; VAR_21 < VAR_22; VAR_21++, VAR_2 += VAR_0.step)\n                {\n                    for (int VAR_23 = 0; VAR_23 < m_width; VAR_23++)\n                        VAR_19[VAR_23] = ReadNumber(VAR_13, 1) != 0;\n\n                    if( VAR_1 )\n                        FillColorRow8( VAR_2, VAR_19, m_width, VAR_3 );\n                    else\n                        FillGrayRow8( VAR_2, VAR_19, m_width, VAR_14 );\n                }\n            }\n            else\n            {\n                AutoBuffer<uchar> _src(src_pitch);\n                uchar* VAR_19 = VAR_20;\n\n                for (int VAR_21 = 0; VAR_21 < VAR_22; VAR_21++, VAR_2 += VAR_0.step)\n                {\n                    VAR_13.getBytes( VAR_19, src_pitch );\n\n                    if( VAR_1 )\n                        FillColorRow1( VAR_2, VAR_19, m_width, VAR_3 );\n                    else\n                        FillGrayRow1( VAR_2, VAR_19, m_width, VAR_14 );\n                }\n            }\n            VAR_4 = true;\n            break;\n\n        /* COMMENT_2 */\n        case 8:\n        case 24:\n        {\n            AutoBuffer<uchar> VAR_20(std::VAR_24<size_t>(VAR_11*2, src_pitch));\n            uchar* VAR_19 = VAR_20;\n\n            for (int VAR_21 = 0; VAR_21 < VAR_22; VAR_21++, VAR_2 += VAR_0.step)\n            {\n                if( !VAR_18 )\n                {\n                    for (int VAR_23 = 0; VAR_23 < VAR_11; VAR_23++)\n                    {\n                        int VAR_25 = ReadNumber(VAR_13);\n                        if( (unsigned)VAR_25 > (unsigned)VAR_15 ) VAR_25 = VAR_15;\n                        if( VAR_5 == 8 )\n                            VAR_19[VAR_23] = VAR_14[VAR_25];\n                        else\n                            ((ushort *)VAR_19)[VAR_23] = (ushort)VAR_25;\n                    }\n                }\n                else\n                {\n                    VAR_13.getBytes( VAR_19, src_pitch );\n                    if( VAR_5 == 16 && !isBigEndian() )\n                    {\n                        for (int VAR_23 = 0; VAR_23 < VAR_11; VAR_23++)\n                        {\n                            uchar VAR_26 = VAR_19[VAR_23 * 2];\n                            VAR_19[VAR_23 * 2] = VAR_19[VAR_23 * 2 + 1];\n                            VAR_19[VAR_23 * 2 + 1] = VAR_26;\n                        }\n                    }\n                }\n\n                if( VAR_0.depth() == VAR_17 && VAR_5 == 16 )\n                {\n                    for (int VAR_23 = 0; VAR_23 < VAR_11; VAR_23++)\n                    {\n                        int VAR_26 = ((ushort *)VAR_19)[VAR_23];\n                        VAR_19[VAR_23] = (uchar)(VAR_26 >> 8);\n                    }\n                }\n\n                if( VAR_9 == 8 ) /* COMMENT_3 */\n                {\n                    if( VAR_1 )\n                    {\n                        if( VAR_0.depth() == VAR_17 ) {\n                            uchar *VAR_27 = VAR_2, *VAR_28 = VAR_19, *VAR_29 = VAR_19 + m_width;\n                            for( ; VAR_28 < VAR_29; VAR_27 += 3, VAR_28++)\n                                VAR_27[0] = VAR_27[1] = VAR_27[2] = *VAR_28;\n                        } else {\n                            ushort *VAR_27 = (ushort *)VAR_2, *VAR_28 = (ushort *)VAR_19, *VAR_29 = ((ushort *)VAR_19) + m_width;\n                            for( ; VAR_28 < VAR_29; VAR_28++, VAR_27 += 3)\n                                VAR_27[0] = VAR_27[1] = VAR_27[2] = *VAR_28;\n                        }\n                    }\n                    else\n                        memcpy( VAR_2, VAR_19, CV_ELEM_SIZE1(VAR_6)*m_width);\n                }\n                else\n                {\n                    if( VAR_1 )\n                    {\n                        if( VAR_0.depth() == VAR_17 )\n                            icvCvt_RGB2BGR_8u_C3R( VAR_19, 0, VAR_2, 0, cvSize(m_width,1) );\n                        else\n                            icvCvt_RGB2BGR_16u_C3R( (ushort *)VAR_19, 0, (ushort *)VAR_2, 0, cvSize(m_width,1) );\n                    }\n                    else if( VAR_0.depth() == VAR_17 )\n                        icvCvt_BGR2Gray_8u_C3C1R( VAR_19, 0, VAR_2, 0, cvSize(m_width,1), 2 );\n                    else\n                        icvCvt_BGRA2Gray_16u_CnC1R( (ushort *)VAR_19, 0, (ushort *)VAR_2, 0, cvSize(m_width,1), 3, 2 );\n                }\n            }\n            VAR_4 = true;\n            break;\n        }\n        default:\n            CV_ErrorNoReturn(Error::StsError, \"m_bpp is not supported\");\n        }\n    }",
  "func_graph_path_before": null,
  "func": "bool PxMDecoder::readData( Mat& img )\n{\n    int color = img.channels() > 1;\n    uchar* data = img.ptr();\n    PaletteEntry palette[256];\n    bool   result = false;\n    const int bit_depth = CV_ELEM_SIZE1(m_type)*8;\n    const int src_pitch = divUp(m_width*m_bpp*(bit_depth/8), 8);\n    int  nch = CV_MAT_CN(m_type);\n    int  width3 = m_width*nch;\n\n    if( m_offset < 0 || !m_strm.isOpened())\n        return false;\n\n    uchar gray_palette[256] = {0};\n\n    // create LUT for converting colors\n    if( bit_depth == 8 )\n    {\n        CV_Assert(m_maxval < 256);\n\n        for (int i = 0; i <= m_maxval; i++)\n            gray_palette[i] = (uchar)((i*255/m_maxval)^(m_bpp == 1 ? 255 : 0));\n\n        FillGrayPalette( palette, m_bpp==1 ? 1 : 8 , m_bpp == 1 );\n    }\n\n    CV_TRY\n    {\n        m_strm.setPos( m_offset );\n\n        switch( m_bpp )\n        {\n        ////////////////////////// 1 BPP /////////////////////////\n        case 1:\n            CV_Assert(CV_MAT_DEPTH(m_type) == CV_8U);\n            if( !m_binary )\n            {\n                AutoBuffer<uchar> _src(m_width);\n                uchar* src = _src;\n\n                for (int y = 0; y < m_height; y++, data += img.step)\n                {\n                    for (int x = 0; x < m_width; x++)\n                        src[x] = ReadNumber(m_strm, 1) != 0;\n\n                    if( color )\n                        FillColorRow8( data, src, m_width, palette );\n                    else\n                        FillGrayRow8( data, src, m_width, gray_palette );\n                }\n            }\n            else\n            {\n                AutoBuffer<uchar> _src(src_pitch);\n                uchar* src = _src;\n\n                for (int y = 0; y < m_height; y++, data += img.step)\n                {\n                    m_strm.getBytes( src, src_pitch );\n\n                    if( color )\n                        FillColorRow1( data, src, m_width, palette );\n                    else\n                        FillGrayRow1( data, src, m_width, gray_palette );\n                }\n            }\n            result = true;\n            break;\n\n        ////////////////////////// 8 BPP /////////////////////////\n        case 8:\n        case 24:\n        {\n            AutoBuffer<uchar> _src(std::max<size_t>(width3*2, src_pitch));\n            uchar* src = _src;\n\n            for (int y = 0; y < m_height; y++, data += img.step)\n            {\n                if( !m_binary )\n                {\n                    for (int x = 0; x < width3; x++)\n                    {\n                        int code = ReadNumber(m_strm);\n                        if( (unsigned)code > (unsigned)m_maxval ) code = m_maxval;\n                        if( bit_depth == 8 )\n                            src[x] = gray_palette[code];\n                        else\n                            ((ushort *)src)[x] = (ushort)code;\n                    }\n                }\n                else\n                {\n                    m_strm.getBytes( src, src_pitch );\n                    if( bit_depth == 16 && !isBigEndian() )\n                    {\n                        for (int x = 0; x < width3; x++)\n                        {\n                            uchar v = src[x * 2];\n                            src[x * 2] = src[x * 2 + 1];\n                            src[x * 2 + 1] = v;\n                        }\n                    }\n                }\n\n                if( img.depth() == CV_8U && bit_depth == 16 )\n                {\n                    for (int x = 0; x < width3; x++)\n                    {\n                        int v = ((ushort *)src)[x];\n                        src[x] = (uchar)(v >> 8);\n                    }\n                }\n\n                if( m_bpp == 8 ) // image has one channel\n                {\n                    if( color )\n                    {\n                        if( img.depth() == CV_8U ) {\n                            uchar *d = data, *s = src, *end = src + m_width;\n                            for( ; s < end; d += 3, s++)\n                                d[0] = d[1] = d[2] = *s;\n                        } else {\n                            ushort *d = (ushort *)data, *s = (ushort *)src, *end = ((ushort *)src) + m_width;\n                            for( ; s < end; s++, d += 3)\n                                d[0] = d[1] = d[2] = *s;\n                        }\n                    }\n                    else\n                        memcpy(data, src, img.elemSize1()*m_width);\n                }\n                else\n                {\n                    if( color )\n                    {\n                        if( img.depth() == CV_8U )\n                            icvCvt_RGB2BGR_8u_C3R( src, 0, data, 0, cvSize(m_width,1) );\n                        else\n                            icvCvt_RGB2BGR_16u_C3R( (ushort *)src, 0, (ushort *)data, 0, cvSize(m_width,1) );\n                    }\n                    else if( img.depth() == CV_8U )\n                        icvCvt_BGR2Gray_8u_C3C1R( src, 0, data, 0, cvSize(m_width,1), 2 );\n                    else\n                        icvCvt_BGRA2Gray_16u_CnC1R( (ushort *)src, 0, (ushort *)data, 0, cvSize(m_width,1), 3, 2 );\n                }\n            }\n            result = true;\n            break;\n        }\n        default:\n            CV_ErrorNoReturn(Error::StsError, \"m_bpp is not supported\");\n        }\n    }",
  "abstract_func": "bool PxMDecoder::readData( Mat& VAR_0 )\n{\n    int VAR_1 = VAR_0.channels() > 1;\n    uchar* VAR_2 = VAR_0.ptr();\n    PaletteEntry VAR_3[256];\n    bool   VAR_4 = false;\n    const int VAR_5 = CV_ELEM_SIZE1(VAR_6)*8;\n    const int VAR_7 = divUp(VAR_8*VAR_9*(VAR_5/8), 8);\n    int  VAR_10 = CV_MAT_CN(VAR_6);\n    int  VAR_11 = VAR_8*VAR_10;\n\n    if( VAR_12 < 0 || !VAR_13.isOpened())\n        return false;\n\n    uchar VAR_14[256] = {0};\n\n    /* COMMENT_0 */\n    if( VAR_5 == 8 )\n    {\n        CV_Assert(VAR_15 < 256);\n\n        for (int VAR_16 = 0; VAR_16 <= VAR_15; VAR_16++)\n            VAR_14[VAR_16] = (uchar)((VAR_16*255/VAR_15)^(VAR_9 == 1 ? 255 : 0));\n\n        FillGrayPalette( VAR_3, VAR_9==1 ? 1 : 8 , VAR_9 == 1 );\n    }\n\n    CV_TRY\n    {\n        VAR_13.setPos( VAR_12 );\n\n        switch( VAR_9 )\n        {\n        /* COMMENT_1 */\n        case 1:\n            CV_Assert(CV_MAT_DEPTH(VAR_6) == VAR_17);\n            if( !VAR_18 )\n            {\n                AutoBuffer<uchar> _src(m_width);\n                uchar* VAR_19 = VAR_20;\n\n                for (int VAR_21 = 0; VAR_21 < VAR_22; VAR_21++, VAR_2 += VAR_0.step)\n                {\n                    for (int VAR_23 = 0; VAR_23 < m_width; VAR_23++)\n                        VAR_19[VAR_23] = ReadNumber(VAR_13, 1) != 0;\n\n                    if( VAR_1 )\n                        FillColorRow8( VAR_2, VAR_19, m_width, VAR_3 );\n                    else\n                        FillGrayRow8( VAR_2, VAR_19, m_width, VAR_14 );\n                }\n            }\n            else\n            {\n                AutoBuffer<uchar> _src(src_pitch);\n                uchar* VAR_19 = VAR_20;\n\n                for (int VAR_21 = 0; VAR_21 < VAR_22; VAR_21++, VAR_2 += VAR_0.step)\n                {\n                    VAR_13.getBytes( VAR_19, src_pitch );\n\n                    if( VAR_1 )\n                        FillColorRow1( VAR_2, VAR_19, m_width, VAR_3 );\n                    else\n                        FillGrayRow1( VAR_2, VAR_19, m_width, VAR_14 );\n                }\n            }\n            VAR_4 = true;\n            break;\n\n        /* COMMENT_2 */\n        case 8:\n        case 24:\n        {\n            AutoBuffer<uchar> VAR_20(std::VAR_24<size_t>(VAR_11*2, src_pitch));\n            uchar* VAR_19 = VAR_20;\n\n            for (int VAR_21 = 0; VAR_21 < VAR_22; VAR_21++, VAR_2 += VAR_0.step)\n            {\n                if( !VAR_18 )\n                {\n                    for (int VAR_23 = 0; VAR_23 < VAR_11; VAR_23++)\n                    {\n                        int VAR_25 = ReadNumber(VAR_13);\n                        if( (unsigned)VAR_25 > (unsigned)VAR_15 ) VAR_25 = VAR_15;\n                        if( VAR_5 == 8 )\n                            VAR_19[VAR_23] = VAR_14[VAR_25];\n                        else\n                            ((ushort *)VAR_19)[VAR_23] = (ushort)VAR_25;\n                    }\n                }\n                else\n                {\n                    VAR_13.getBytes( VAR_19, src_pitch );\n                    if( VAR_5 == 16 && !isBigEndian() )\n                    {\n                        for (int VAR_23 = 0; VAR_23 < VAR_11; VAR_23++)\n                        {\n                            uchar VAR_26 = VAR_19[VAR_23 * 2];\n                            VAR_19[VAR_23 * 2] = VAR_19[VAR_23 * 2 + 1];\n                            VAR_19[VAR_23 * 2 + 1] = VAR_26;\n                        }\n                    }\n                }\n\n                if( VAR_0.depth() == VAR_17 && VAR_5 == 16 )\n                {\n                    for (int VAR_23 = 0; VAR_23 < VAR_11; VAR_23++)\n                    {\n                        int VAR_26 = ((ushort *)VAR_19)[VAR_23];\n                        VAR_19[VAR_23] = (uchar)(VAR_26 >> 8);\n                    }\n                }\n\n                if( VAR_9 == 8 ) /* COMMENT_3 */\n                {\n                    if( VAR_1 )\n                    {\n                        if( VAR_0.depth() == VAR_17 ) {\n                            uchar *VAR_27 = VAR_2, *VAR_28 = VAR_19, *VAR_29 = VAR_19 + m_width;\n                            for( ; VAR_28 < VAR_29; VAR_27 += 3, VAR_28++)\n                                VAR_27[0] = VAR_27[1] = VAR_27[2] = *VAR_28;\n                        } else {\n                            ushort *VAR_27 = (ushort *)VAR_2, *VAR_28 = (ushort *)VAR_19, *VAR_29 = ((ushort *)VAR_19) + m_width;\n                            for( ; VAR_28 < VAR_29; VAR_28++, VAR_27 += 3)\n                                VAR_27[0] = VAR_27[1] = VAR_27[2] = *VAR_28;\n                        }\n                    }\n                    else\n                        memcpy(VAR_2, VAR_19, VAR_0.elemSize1()*m_width);\n                }\n                else\n                {\n                    if( VAR_1 )\n                    {\n                        if( VAR_0.depth() == VAR_17 )\n                            icvCvt_RGB2BGR_8u_C3R( VAR_19, 0, VAR_2, 0, cvSize(m_width,1) );\n                        else\n                            icvCvt_RGB2BGR_16u_C3R( (ushort *)VAR_19, 0, (ushort *)VAR_2, 0, cvSize(m_width,1) );\n                    }\n                    else if( VAR_0.depth() == VAR_17 )\n                        icvCvt_BGR2Gray_8u_C3C1R( VAR_19, 0, VAR_2, 0, cvSize(m_width,1), 2 );\n                    else\n                        icvCvt_BGRA2Gray_16u_CnC1R( (ushort *)VAR_19, 0, (ushort *)VAR_2, 0, cvSize(m_width,1), 3, 2 );\n                }\n            }\n            VAR_4 = true;\n            break;\n        }\n        default:\n            CV_ErrorNoReturn(Error::StsError, \"m_bpp is not supported\");\n        }\n    }",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -127,7 +127,7 @@\n                         }\n                     }\n                     else\n-                        memcpy( data, src, CV_ELEM_SIZE1(m_type)*m_width);\n+                        memcpy(data, src, img.elemSize1()*m_width);\n                 }\n                 else\n                 {",
  "diff_line_info": {
    "deleted_lines": [
      "                        memcpy( data, src, CV_ELEM_SIZE1(m_type)*m_width);"
    ],
    "added_lines": [
      "                        memcpy(data, src, img.elemSize1()*m_width);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/opencv/opencv/pull/10369",
  "description": {
    "pr_info": {
      "title": "imgcodecs(pxm): fix memcpy size",
      "number": 10369
    },
    "comment": [
      "resolves #10351\r\n\r\nObserved in this case:\r\n- source image type (m_type) is `CV_16U`\r\n- destination image type (with GRAYSCALE flag) is `CV_8U`",
      ":+1:",
      "CVE-2017-17760 issue. any plan for backporting into 2.4?"
    ]
  },
  "Bug Filter": "** Security Vulnerability Fix  \n**Confidence Score:** 0.9",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "\n\nThe patch addresses a potential buffer overflow issue in the image decoding function by correcting the size parameter in memcpy, which could lead to unauthorized access or data corruption.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 0.9"
}