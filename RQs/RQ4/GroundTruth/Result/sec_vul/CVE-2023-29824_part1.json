{
  "cve_id": "CVE-2023-29824",
  "cwe_ids": [
    "CWE-416"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "scipy",
  "commit_msg": "MAINT: Fix use-after-free in Py_FindObjects",
  "commit_hash": "e9fad96517edf7c262122d992cb45439883006f6",
  "git_url": "https://github.com/scipy/scipy/commit/e9fad96517edf7c262122d992cb45439883006f6",
  "file_path": "scipy/ndimage/src/nd_image.c",
  "func_name": "Py_FindObjects",
  "func_before": "static PyObject *Py_FindObjects(PyObject *obj, PyObject *args)\n{\n    PyArrayObject *input = NULL;\n    PyObject *result = NULL, *tuple = NULL, *start = NULL, *end = NULL;\n    PyObject *slc = NULL;\n    int jj;\n    npy_intp max_label;\n    npy_intp ii, *regions = NULL;\n\n    if (!PyArg_ParseTuple(args, \"O&n\",\n                          NI_ObjectToInputArray, &input, &max_label))\n        goto exit;\n\n    if (max_label < 0)\n        max_label = 0;\n    if (max_label > 0) {\n        if (PyArray_NDIM(input) > 0) {\n            regions = (npy_intp*)malloc(2 * max_label * PyArray_NDIM(input) *\n                                        sizeof(npy_intp));\n        } else {\n            regions = (npy_intp*)malloc(max_label * sizeof(npy_intp));\n        }\n        if (!regions) {\n            PyErr_NoMemory();\n            goto exit;\n        }\n    }\n\n    if (!NI_FindObjects(input, max_label, regions))\n        goto exit;\n\n    result = PyList_New(max_label);\n    if (!result) {\n        PyErr_NoMemory();\n        goto exit;\n    }\n\n    for(ii = 0; ii < max_label; ii++) {\n        npy_intp idx =\n                PyArray_NDIM(input) > 0 ? 2 * PyArray_NDIM(input) * ii : ii;\n        if (regions[idx] >= 0) {\n            PyObject *tuple = PyTuple_New(PyArray_NDIM(input));\n            if (!tuple) {\n                PyErr_NoMemory();\n                goto exit;\n            }\n            for(jj = 0; jj < PyArray_NDIM(input); jj++) {\n                start = PyLong_FromSsize_t(regions[idx + jj]);\n                end = PyLong_FromSsize_t(regions[idx + jj +\n                                             PyArray_NDIM(input)]);\n                if (!start || !end) {\n                    PyErr_NoMemory();\n                    goto exit;\n                }\n                slc = PySlice_New(start, end, NULL);\n                if (!slc) {\n                    PyErr_NoMemory();\n                    goto exit;\n                }\n                Py_XDECREF(start);\n                Py_XDECREF(end);\n                start = end = NULL;\n                PyTuple_SetItem(tuple, jj, slc);\n                slc = NULL;\n            }\n            PyList_SetItem(result, ii, tuple);\n            tuple = NULL;\n        } else {\n            Py_INCREF(Py_None);\n            PyList_SetItem(result, ii, Py_None);\n        }\n    }\n\n    Py_INCREF(result);\n\n exit:\n    Py_XDECREF(input);\n    Py_XDECREF(result);\n    Py_XDECREF(tuple);\n    Py_XDECREF(start);\n    Py_XDECREF(end);\n    Py_XDECREF(slc);\n    free(regions);\n    if (PyErr_Occurred()) {\n        Py_XDECREF(result);\n        return NULL;\n    } else {\n        return result;\n    }\n}",
  "abstract_func_before": "static PyObject *Py_FindObjects(PyObject *VAR_0, PyObject *VAR_1)\n{\n    PyArrayObject *VAR_2 = NULL;\n    PyObject *VAR_3 = NULL, *VAR_4 = NULL, *VAR_5 = NULL, *VAR_6 = NULL;\n    PyObject *VAR_7 = NULL;\n    int VAR_8;\n    npy_intp VAR_9;\n    npy_intp VAR_10, *VAR_11 = NULL;\n\n    if (!PyArg_ParseTuple(VAR_1, \"O&n\",\n                          VAR_12, &VAR_2, &VAR_9))\n        goto exit;\n\n    if (VAR_9 < 0)\n        VAR_9 = 0;\n    if (VAR_9 > 0) {\n        if (PyArray_NDIM(VAR_2) > 0) {\n            VAR_11 = (npy_intp*)malloc(2 * VAR_9 * PyArray_NDIM(VAR_2) *\n                                        sizeof(npy_intp));\n        } else {\n            VAR_11 = (npy_intp*)malloc(VAR_9 * sizeof(npy_intp));\n        }\n        if (!VAR_11) {\n            PyErr_NoMemory();\n            goto exit;\n        }\n    }\n\n    if (!NI_FindObjects(VAR_2, VAR_9, VAR_11))\n        goto exit;\n\n    VAR_3 = PyList_New(VAR_9);\n    if (!VAR_3) {\n        PyErr_NoMemory();\n        goto exit;\n    }\n\n    for(VAR_10 = 0; VAR_10 < VAR_9; VAR_10++) {\n        npy_intp VAR_13 =\n                PyArray_NDIM(VAR_2) > 0 ? 2 * PyArray_NDIM(VAR_2) * VAR_10 : VAR_10;\n        if (VAR_11[VAR_13] >= 0) {\n            PyObject *VAR_4 = PyTuple_New(PyArray_NDIM(VAR_2));\n            if (!VAR_4) {\n                PyErr_NoMemory();\n                goto exit;\n            }\n            for(VAR_8 = 0; VAR_8 < PyArray_NDIM(VAR_2); VAR_8++) {\n                VAR_5 = PyLong_FromSsize_t(VAR_11[VAR_13 + VAR_8]);\n                VAR_6 = PyLong_FromSsize_t(VAR_11[VAR_13 + VAR_8 +\n                                             PyArray_NDIM(VAR_2)]);\n                if (!VAR_5 || !VAR_6) {\n                    PyErr_NoMemory();\n                    goto exit;\n                }\n                VAR_7 = PySlice_New(VAR_5, VAR_6, NULL);\n                if (!VAR_7) {\n                    PyErr_NoMemory();\n                    goto exit;\n                }\n                Py_XDECREF(VAR_5);\n                Py_XDECREF(VAR_6);\n                VAR_5 = VAR_6 = NULL;\n                PyTuple_SetItem(VAR_4, VAR_8, VAR_7);\n                VAR_7 = NULL;\n            }\n            PyList_SetItem(VAR_3, VAR_10, VAR_4);\n            VAR_4 = NULL;\n        } else {\n            Py_INCREF(VAR_14);\n            PyList_SetItem(VAR_3, VAR_10, VAR_14);\n        }\n    }\n\n    Py_INCREF(VAR_3);\n\n exit:\n    Py_XDECREF(VAR_2);\n    Py_XDECREF(VAR_3);\n    Py_XDECREF(VAR_4);\n    Py_XDECREF(VAR_5);\n    Py_XDECREF(VAR_6);\n    Py_XDECREF(VAR_7);\n    free(VAR_11);\n    if (PyErr_Occurred()) {\n        Py_XDECREF(VAR_3);\n        return NULL;\n    } else {\n        return VAR_3;\n    }\n}",
  "func_graph_path_before": "scipy/e9fad96517edf7c262122d992cb45439883006f6/nd_image.c/vul/before/0.json",
  "func": "static PyObject *Py_FindObjects(PyObject *obj, PyObject *args)\n{\n    PyArrayObject *input = NULL;\n    PyObject *result = NULL, *tuple = NULL, *start = NULL, *end = NULL;\n    PyObject *slc = NULL;\n    int jj;\n    npy_intp max_label;\n    npy_intp ii, *regions = NULL;\n\n    if (!PyArg_ParseTuple(args, \"O&n\",\n                          NI_ObjectToInputArray, &input, &max_label))\n        goto exit;\n\n    if (max_label < 0)\n        max_label = 0;\n    if (max_label > 0) {\n        if (PyArray_NDIM(input) > 0) {\n            regions = (npy_intp*)malloc(2 * max_label * PyArray_NDIM(input) *\n                                        sizeof(npy_intp));\n        } else {\n            regions = (npy_intp*)malloc(max_label * sizeof(npy_intp));\n        }\n        if (!regions) {\n            PyErr_NoMemory();\n            goto exit;\n        }\n    }\n\n    if (!NI_FindObjects(input, max_label, regions))\n        goto exit;\n\n    result = PyList_New(max_label);\n    if (!result) {\n        PyErr_NoMemory();\n        goto exit;\n    }\n\n    for(ii = 0; ii < max_label; ii++) {\n        npy_intp idx =\n                PyArray_NDIM(input) > 0 ? 2 * PyArray_NDIM(input) * ii : ii;\n        if (regions[idx] >= 0) {\n            PyObject *tuple = PyTuple_New(PyArray_NDIM(input));\n            if (!tuple) {\n                PyErr_NoMemory();\n                goto exit;\n            }\n            for(jj = 0; jj < PyArray_NDIM(input); jj++) {\n                start = PyLong_FromSsize_t(regions[idx + jj]);\n                end = PyLong_FromSsize_t(regions[idx + jj +\n                                             PyArray_NDIM(input)]);\n                if (!start || !end) {\n                    PyErr_NoMemory();\n                    goto exit;\n                }\n                slc = PySlice_New(start, end, NULL);\n                if (!slc) {\n                    PyErr_NoMemory();\n                    goto exit;\n                }\n                Py_XDECREF(start);\n                Py_XDECREF(end);\n                start = end = NULL;\n                PyTuple_SetItem(tuple, jj, slc);\n                slc = NULL;\n            }\n            PyList_SetItem(result, ii, tuple);\n            tuple = NULL;\n        } else {\n            Py_INCREF(Py_None);\n            PyList_SetItem(result, ii, Py_None);\n        }\n    }\n\n    Py_INCREF(result);\n\n exit:\n    Py_XDECREF(input);\n    Py_XDECREF(result);\n    Py_XDECREF(tuple);\n    Py_XDECREF(start);\n    Py_XDECREF(end);\n    Py_XDECREF(slc);\n    free(regions);\n    if (PyErr_Occurred()) {\n        return NULL;\n    } else {\n        return result;\n    }\n}",
  "abstract_func": "static PyObject *Py_FindObjects(PyObject *VAR_0, PyObject *VAR_1)\n{\n    PyArrayObject *VAR_2 = NULL;\n    PyObject *VAR_3 = NULL, *VAR_4 = NULL, *VAR_5 = NULL, *VAR_6 = NULL;\n    PyObject *VAR_7 = NULL;\n    int VAR_8;\n    npy_intp VAR_9;\n    npy_intp VAR_10, *VAR_11 = NULL;\n\n    if (!PyArg_ParseTuple(VAR_1, \"O&n\",\n                          VAR_12, &VAR_2, &VAR_9))\n        goto exit;\n\n    if (VAR_9 < 0)\n        VAR_9 = 0;\n    if (VAR_9 > 0) {\n        if (PyArray_NDIM(VAR_2) > 0) {\n            VAR_11 = (npy_intp*)malloc(2 * VAR_9 * PyArray_NDIM(VAR_2) *\n                                        sizeof(npy_intp));\n        } else {\n            VAR_11 = (npy_intp*)malloc(VAR_9 * sizeof(npy_intp));\n        }\n        if (!VAR_11) {\n            PyErr_NoMemory();\n            goto exit;\n        }\n    }\n\n    if (!NI_FindObjects(VAR_2, VAR_9, VAR_11))\n        goto exit;\n\n    VAR_3 = PyList_New(VAR_9);\n    if (!VAR_3) {\n        PyErr_NoMemory();\n        goto exit;\n    }\n\n    for(VAR_10 = 0; VAR_10 < VAR_9; VAR_10++) {\n        npy_intp VAR_13 =\n                PyArray_NDIM(VAR_2) > 0 ? 2 * PyArray_NDIM(VAR_2) * VAR_10 : VAR_10;\n        if (VAR_11[VAR_13] >= 0) {\n            PyObject *VAR_4 = PyTuple_New(PyArray_NDIM(VAR_2));\n            if (!VAR_4) {\n                PyErr_NoMemory();\n                goto exit;\n            }\n            for(VAR_8 = 0; VAR_8 < PyArray_NDIM(VAR_2); VAR_8++) {\n                VAR_5 = PyLong_FromSsize_t(VAR_11[VAR_13 + VAR_8]);\n                VAR_6 = PyLong_FromSsize_t(VAR_11[VAR_13 + VAR_8 +\n                                             PyArray_NDIM(VAR_2)]);\n                if (!VAR_5 || !VAR_6) {\n                    PyErr_NoMemory();\n                    goto exit;\n                }\n                VAR_7 = PySlice_New(VAR_5, VAR_6, NULL);\n                if (!VAR_7) {\n                    PyErr_NoMemory();\n                    goto exit;\n                }\n                Py_XDECREF(VAR_5);\n                Py_XDECREF(VAR_6);\n                VAR_5 = VAR_6 = NULL;\n                PyTuple_SetItem(VAR_4, VAR_8, VAR_7);\n                VAR_7 = NULL;\n            }\n            PyList_SetItem(VAR_3, VAR_10, VAR_4);\n            VAR_4 = NULL;\n        } else {\n            Py_INCREF(VAR_14);\n            PyList_SetItem(VAR_3, VAR_10, VAR_14);\n        }\n    }\n\n    Py_INCREF(VAR_3);\n\n exit:\n    Py_XDECREF(VAR_2);\n    Py_XDECREF(VAR_3);\n    Py_XDECREF(VAR_4);\n    Py_XDECREF(VAR_5);\n    Py_XDECREF(VAR_6);\n    Py_XDECREF(VAR_7);\n    free(VAR_11);\n    if (PyErr_Occurred()) {\n        return NULL;\n    } else {\n        return VAR_3;\n    }\n}",
  "func_graph_path": "scipy/e9fad96517edf7c262122d992cb45439883006f6/nd_image.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -82,7 +82,6 @@\n     Py_XDECREF(slc);\n     free(regions);\n     if (PyErr_Occurred()) {\n-        Py_XDECREF(result);\n         return NULL;\n     } else {\n         return result;",
  "diff_line_info": {
    "deleted_lines": [
      "        Py_XDECREF(result);"
    ],
    "added_lines": []
  },
  "is_vul": true,
  "pr_url": "https://github.com/scipy/scipy/pull/15013",
  "description": {
    "pr_info": {
      "title": "MAINT: Fix use-after-free bug in Py_FindObjects",
      "number": 15013
    },
    "comment": [
      "#### Reference issue\r\nCloses gh-14713. See the issue for more details.\r\n\r\n#### What does this implement/fix?\r\nRemove the extra reference decrement which is not needed and may cause the ref count to become negative in case of a memory error (though that's not likely).\r\n\r\ncc @tupui @Snape3058\r\n",
      "> My understanding of this was that `Py_XDECREF` would not do anything if there is NULL as opposed to `Py_DECREF`\r\n\r\nYes that is true, but in this case, the result is not NULL if/when the `PyErr_Occurred` holds true. In that case, it is actually a dangling pointer since the ref count has been decremented to zero once and then again the second decrement still goes through (since it is not NULL) making the ref count -1. So we can just remove this extra DECREF which is not required anyway.\r\n\r\nI believe this bug managed to get in at the first place in anticipation to counter the complimentary increment on L920: https://github.com/scipy/scipy/blob/8ef583067438a16e7f3a4bed2e109168f16dfda8/scipy/ndimage/src/nd_image.c#L920\r\n\r\nBut in case of an error (Eg L891), the control is transferred directly to the exit label and that increment is never hit. ",
      "Ok thanks @AnirudhDagar for the precisions. (Failures are not linked)"
    ]
  },
  "Bug Filter": "** The patch resolves a security vulnerability by preventing unauthorized memory access.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Analysis:**\n\n1. **Patch Analysis:** The commit message indicates a maintenance fix for a use-after-free issue in `Py_FindObjects`. The code diff shows the removal of `Py_XDECREF(result);` in the error handling block, preventing a potential memory access after deallocation.\n\n2. **Security Vulnerability Assessment:** The use-after-free issue can lead to undefined behavior or exploitation, affecting system security. The fix addresses a defect impacting availability and integrity.\n\n3. **Classification:** The patch resolves a security vulnerability by preventing unauthorized memory access.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 0.95"
}