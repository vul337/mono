{
  "cve_id": "CVE-2023-4322",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "radareorg/radare2",
  "commit_msg": "Fix 1byte heap oobread in the brainfuck disassembler\n\n* https://huntr.dev/bounties/06e2484c-d6f1-4497-af67-26549be9fffd/\n* Kudos to @7resp4ss for reporting",
  "commit_hash": "ba919adb74ac368bf76b150a00347ded78b572dd",
  "git_url": "https://github.com/radareorg/radare2/commit/ba919adb74ac368bf76b150a00347ded78b572dd",
  "file_path": "libr/arch/p/bf/plugin.c",
  "func_name": "decode",
  "func_before": "static bool decode(RArchSession *as, RAnalOp *op, RArchDecodeMask mask) {\n\tint len = op->size;\n\tconst ut8 *_buf = op->bytes;\n\tconst ut64 addr = op->addr;\n\tif (len < 1) {\n\t\treturn false;\n\t}\n\n\tut8 *buf = (ut8*)_buf; // XXX\n\tut64 dst = 0LL;\n\tif (!op) {\n\t\treturn 1;\n\t}\n\tif (mask & R_ARCH_OP_MASK_DISASM) {\n\t\t(void) disassemble (op, buf, len);\n\t}\n\tr_strbuf_init (&op->esil);\n\top->size = 1;\n\top->id = getid (buf[0]);\n\tswitch (buf[0]) {\n\tcase '[':\n\t\top->type = R_ANAL_OP_TYPE_CJMP;\n\t\t// read ahead to find the ] bracket\n\t\top->jump = dst;\n\t\top->fail = addr + 1;\n\t\tRArch *a = as->arch;\n\t\tRIOReadAt read_at = NULL;\n\t\tRBin *bin = R_UNWRAP2 (a, binb.bin);\n\t\tif (bin && bin->iob.read_at) {\n\t\t\tRIOReadAt read_at = bin->iob.read_at;\n\t\t\tbuf = malloc (0xff);\n\t\t\tread_at (bin->iob.io, op->addr, buf, 0xff);\n\t\t}\n\t\tr_strbuf_set (&op->esil, \"1,pc,-,brk,=[4],4,brk,+=\");\n#if 1\n\t\t{\n\t\t\tconst ut8 *p = buf + 1;\n\t\t\tint lev = 0, i = 1;\n\t\t\tlen--;\n\t\t\twhile (i < len && *p) {\n\t\t\t\tif (*p == '[') {\n\t\t\t\t\tlev++;\n\t\t\t\t}\n\t\t\t\tif (*p == ']') {\n\t\t\t\t\tlev--;\n\t\t\t\t\tif (lev == -1) {\n\t\t\t\t\t\tdst = addr + (size_t)(p - buf) + 1;\n\t\t\t\t\t\top->jump = dst;\n\t\t\t\t\t\tr_strbuf_set (&op->esil, \"1,pc,-,brk,=[4],4,brk,+=,\");\n\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (*p == 0x00 || *p == 0xff) {\n\t\t\t\t\top->type = R_ANAL_OP_TYPE_ILL;\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tif (read_at && i == len - 1) {\n\t\t\t\t\tbreak;\n\t\t\t\t\t// XXX unnecessary just break\n\t\t\t\t\tint new_buf_len = len + 1 + BUFSIZE_INC;\n\t\t\t\t\tut8 *new_buf = calloc (new_buf_len, 1);\n\t\t\t\t\tif (new_buf) {\n\t\t\t\t\t\tfree (buf);\n\t\t\t\t\t\tmemcpy (new_buf, op->bytes, new_buf_len);\n\t\t\t\t\t\tbuf = new_buf;\n\t\t\t\t\t\tread_at (bin->iob.io, op->addr + i, buf + i, 0xff);\n\t\t\t\t\t\tp = buf + i;\n\t\t\t\t\t\tlen += BUFSIZE_INC;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\nbeach:\n\t\tfree (buf);\n#endif\n\t\tbreak;\n\tcase ']':\n\t\top->type = R_ANAL_OP_TYPE_UJMP;\n\t\tr_strbuf_set (&op->esil, \"4,brk,-=,ptr,[1],?{,brk,[4],pc,=,}\");\n\t\tbreak;\n\tcase '>':\n\t\top->type = R_ANAL_OP_TYPE_ADD;\n\t\top->size = countChar (buf, len, '>');\n\t\tr_strbuf_setf (&op->esil, \"%d,ptr,+=\", op->size);\n\t\tbreak;\n\tcase '<':\n\t\top->type = R_ANAL_OP_TYPE_SUB;\n\t\top->size = countChar (buf, len, '<');\n\t\tr_strbuf_setf (&op->esil, \"%d,ptr,-=\", op->size);\n\t\tbreak;\n\tcase '+':\n\t\top->size = countChar (buf, len, '+');\n\t\top->type = R_ANAL_OP_TYPE_ADD;\n\t\tr_strbuf_setf (&op->esil, \"%d,ptr,+=[1]\", op->size);\n\t\tbreak;\n\tcase '-':\n\t\top->type = R_ANAL_OP_TYPE_SUB;\n\t\top->size = countChar (buf, len, '-');\n\t\tr_strbuf_setf (&op->esil, \"%d,ptr,-=[1]\", op->size);\n\t\tbreak;\n\tcase '.':\n\t\t// print element in stack to screen\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\tr_strbuf_set (&op->esil, \"ptr,[1],scr,=[1],1,scr,+=\");\n\t\tbreak;\n\tcase ',':\n\t\top->type = R_ANAL_OP_TYPE_LOAD;\n\t\tr_strbuf_set (&op->esil, \"kbd,[1],ptr,=[1],1,kbd,+=\");\n\t\tbreak;\n\tcase 0x00:\n\tcase 0xff:\n\t\top->type = R_ANAL_OP_TYPE_TRAP;\n\t\tbreak;\n\tdefault:\n\t\top->type = R_ANAL_OP_TYPE_NOP;\n\t\tr_strbuf_set (&op->esil, \",\");\n\t\tbreak;\n\t}\n\treturn op->size;\n}",
  "abstract_func_before": "static bool decode(RArchSession *VAR_0, RAnalOp *VAR_1, RArchDecodeMask VAR_2) {\n\tint VAR_3 = VAR_1->size;\n\tconst ut8 *VAR_4 = VAR_1->bytes;\n\tconst ut64 VAR_5 = VAR_1->addr;\n\tif (VAR_3 < 1) {\n\t\treturn false;\n\t}\n\n\tut8 *VAR_6 = (ut8*)VAR_4; /* COMMENT_0 */\n\tut64 VAR_7 = 0LL;\n\tif (!VAR_1) {\n\t\treturn 1;\n\t}\n\tif (VAR_2 & VAR_8) {\n\t\t(void) disassemble (VAR_1, VAR_6, VAR_3);\n\t}\n\tr_strbuf_init (&VAR_1->esil);\n\tVAR_1->size = 1;\n\tVAR_1->id = getid (VAR_6[0]);\n\tswitch (VAR_6[0]) {\n\tcase '[':\n\t\tVAR_1->type = VAR_9;\n\t\t/* COMMENT_1 */\n\t\tVAR_1->jump = VAR_7;\n\t\tVAR_1->fail = VAR_5 + 1;\n\t\tRArch *VAR_10 = VAR_0->arch;\n\t\tRIOReadAt VAR_11 = NULL;\n\t\tRBin *VAR_12 = R_UNWRAP2 (VAR_10, VAR_13.bin);\n\t\tif (VAR_12 && VAR_12->iob.read_at) {\n\t\t\tRIOReadAt VAR_11 = VAR_12->iob.read_at;\n\t\t\tVAR_6 = malloc (0xff);\n\t\t\tVAR_11 (VAR_12->iob.io, VAR_1->addr, VAR_6, 0xff);\n\t\t}\n\t\tr_strbuf_set (&VAR_1->esil, \"1,pc,-,brk,=[4],4,brk,+=\");\n#if 1\n\t\t{\n\t\t\tconst ut8 *VAR_14 = VAR_6 + 1;\n\t\t\tint VAR_15 = 0, VAR_16 = 1;\n\t\t\tVAR_3--;\n\t\t\twhile (VAR_16 < VAR_3 && *VAR_14) {\n\t\t\t\tif (*VAR_14 == '[') {\n\t\t\t\t\tVAR_15++;\n\t\t\t\t}\n\t\t\t\tif (*VAR_14 == ']') {\n\t\t\t\t\tVAR_15--;\n\t\t\t\t\tif (VAR_15 == -1) {\n\t\t\t\t\t\tVAR_7 = VAR_5 + (size_t)(VAR_14 - VAR_6) + 1;\n\t\t\t\t\t\tVAR_1->jump = VAR_7;\n\t\t\t\t\t\tr_strbuf_set (&VAR_1->esil, \"1,pc,-,brk,=[4],4,brk,+=,\");\n\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (*VAR_14 == 0x00 || *VAR_14 == 0xff) {\n\t\t\t\t\tVAR_1->type = VAR_17;\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tif (VAR_11 && VAR_16 == VAR_3 - 1) {\n\t\t\t\t\tbreak;\n\t\t\t\t\t/* COMMENT_2 */\n\t\t\t\t\tint VAR_18 = VAR_3 + 1 + VAR_19;\n\t\t\t\t\tut8 *VAR_20 = calloc (VAR_18, 1);\n\t\t\t\t\tif (VAR_20) {\n\t\t\t\t\t\tfree (VAR_6);\n\t\t\t\t\t\tmemcpy (VAR_20, VAR_1->bytes, VAR_18);\n\t\t\t\t\t\tVAR_6 = VAR_20;\n\t\t\t\t\t\tVAR_11 (VAR_12->iob.io, VAR_1->addr + VAR_16, VAR_6 + VAR_16, 0xff);\n\t\t\t\t\t\tVAR_14 = VAR_6 + VAR_16;\n\t\t\t\t\t\tVAR_3 += VAR_19;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tVAR_14++;\n\t\t\t\tVAR_16++;\n\t\t\t}\n\t\t}\nbeach:\n\t\tfree (VAR_6);\n#endif\n\t\tbreak;\n\tcase ']':\n\t\tVAR_1->type = VAR_21;\n\t\tr_strbuf_set (&VAR_1->esil, \"4,brk,-=,ptr,[1],?{,brk,[4],pc,=,}\");\n\t\tbreak;\n\tcase '>':\n\t\tVAR_1->type = VAR_22;\n\t\tVAR_1->size = countChar (VAR_6, VAR_3, '>');\n\t\tr_strbuf_setf (&VAR_1->esil, \"%d,ptr,+=\", VAR_1->size);\n\t\tbreak;\n\tcase '<':\n\t\tVAR_1->type = VAR_23;\n\t\tVAR_1->size = countChar (VAR_6, VAR_3, '<');\n\t\tr_strbuf_setf (&VAR_1->esil, \"%d,ptr,-=\", VAR_1->size);\n\t\tbreak;\n\tcase '+':\n\t\tVAR_1->size = countChar (VAR_6, VAR_3, '+');\n\t\tVAR_1->type = VAR_22;\n\t\tr_strbuf_setf (&VAR_1->esil, \"%d,ptr,+=[1]\", VAR_1->size);\n\t\tbreak;\n\tcase '-':\n\t\tVAR_1->type = VAR_23;\n\t\tVAR_1->size = countChar (VAR_6, VAR_3, '-');\n\t\tr_strbuf_setf (&VAR_1->esil, \"%d,ptr,-=[1]\", VAR_1->size);\n\t\tbreak;\n\tcase '.':\n\t\t/* COMMENT_3 */\n\t\tVAR_1->type = VAR_24;\n\t\tr_strbuf_set (&VAR_1->esil, \"ptr,[1],scr,=[1],1,scr,+=\");\n\t\tbreak;\n\tcase ',':\n\t\tVAR_1->type = VAR_25;\n\t\tr_strbuf_set (&VAR_1->esil, \"kbd,[1],ptr,=[1],1,kbd,+=\");\n\t\tbreak;\n\tcase 0x00:\n\tcase 0xff:\n\t\tVAR_1->type = VAR_26;\n\t\tbreak;\n\tdefault:\n\t\tVAR_1->type = VAR_27;\n\t\tr_strbuf_set (&VAR_1->esil, \",\");\n\t\tbreak;\n\t}\n\treturn VAR_1->size;\n}",
  "func_graph_path_before": "radareorg/radare2/ba919adb74ac368bf76b150a00347ded78b572dd/plugin.c/vul/before/1.json",
  "func": "static bool decode(RArchSession *as, RAnalOp *op, RArchDecodeMask mask) {\n\tint len = op->size;\n\tif (len < 1) {\n\t\treturn false;\n\t}\n\tut8 *buf = op->bytes;\n\tconst ut64 addr = op->addr;\n\tut64 dst = 0LL;\n\tif (!op) {\n\t\treturn 1;\n\t}\n\tif (mask & R_ARCH_OP_MASK_DISASM) {\n\t\t(void) disassemble (op, buf, len);\n\t}\n\tr_strbuf_init (&op->esil);\n\top->size = 1;\n\top->id = getid (buf[0]);\n\tswitch (buf[0]) {\n\tcase '[':\n\t\top->type = R_ANAL_OP_TYPE_CJMP;\n\t\t// read ahead to find the ] bracket\n\t\top->jump = dst;\n\t\top->fail = addr + 1;\n\t\tRArch *a = as->arch;\n\t\tRIOReadAt read_at = NULL;\n\t\tRBin *bin = R_UNWRAP2 (a, binb.bin);\n\t\tif (bin && bin->iob.read_at) {\n\t\t\tRIOReadAt read_at = bin->iob.read_at;\n\t\t\tbuf = malloc (0xff);\n\t\t\tread_at (bin->iob.io, op->addr, buf, 0xff);\n\t\t}\n\t\tr_strbuf_set (&op->esil, \"1,pc,-,brk,=[4],4,brk,+=\");\n#if 1\n\t\tif (len > 1) {\n\t\t\tconst ut8 *p = buf + 1;\n\t\t\tint lev = 0, i = 1;\n\t\t\tlen--;\n\t\t\twhile (i < len && *p) {\n\t\t\t\tswitch (*p) {\n\t\t\t\tcase '[':\n\t\t\t\t\tlev++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ']':\n\t\t\t\t\tlev--;\n\t\t\t\t\tif (lev < 1) {\n\t\t\t\t\t\tsize_t delta = p - buf;\n\t\t\t\t\t\tdst = addr + (size_t)delta + 1;\n\t\t\t\t\t\top->jump = dst;\n\t\t\t\t\t\tr_strbuf_set (&op->esil, \"1,pc,-,brk,=[4],4,brk,+=,\");\n\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0:\n\t\t\t\tcase 0xff:\n\t\t\t\t\top->type = R_ANAL_OP_TYPE_ILL;\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tif (read_at && i == len - 1) {\n#if 0\n\t\t\t\t\t// XXX unnecessary just break\n\t\t\t\t\tint new_buf_len = len + 1 + BUFSIZE_INC;\n\t\t\t\t\tut8 *new_buf = calloc (new_buf_len, 1);\n\t\t\t\t\tif (new_buf) {\n\t\t\t\t\t\tfree (buf);\n\t\t\t\t\t\tmemcpy (new_buf, op->bytes, new_buf_len);\n\t\t\t\t\t\tbuf = new_buf;\n\t\t\t\t\t\tread_at (bin->iob.io, op->addr + i, buf + i, 0xff);\n\t\t\t\t\t\tp = buf + i;\n\t\t\t\t\t\tlen += BUFSIZE_INC;\n\t\t\t\t\t}\n#else\n\t\t\t\t\tbreak;\n#endif\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\nbeach:\n\t\tfree (buf);\n#endif\n\t\tbreak;\n\tcase ']':\n\t\top->type = R_ANAL_OP_TYPE_UJMP;\n\t\tr_strbuf_set (&op->esil, \"4,brk,-=,ptr,[1],?{,brk,[4],pc,=,}\");\n\t\tbreak;\n\tcase '>':\n\t\top->type = R_ANAL_OP_TYPE_ADD;\n\t\top->size = countChar (buf, len, '>');\n\t\tr_strbuf_setf (&op->esil, \"%d,ptr,+=\", op->size);\n\t\tbreak;\n\tcase '<':\n\t\top->type = R_ANAL_OP_TYPE_SUB;\n\t\top->size = countChar (buf, len, '<');\n\t\tr_strbuf_setf (&op->esil, \"%d,ptr,-=\", op->size);\n\t\tbreak;\n\tcase '+':\n\t\top->size = countChar (buf, len, '+');\n\t\top->type = R_ANAL_OP_TYPE_ADD;\n\t\tr_strbuf_setf (&op->esil, \"%d,ptr,+=[1]\", op->size);\n\t\tbreak;\n\tcase '-':\n\t\top->type = R_ANAL_OP_TYPE_SUB;\n\t\top->size = countChar (buf, len, '-');\n\t\tr_strbuf_setf (&op->esil, \"%d,ptr,-=[1]\", op->size);\n\t\tbreak;\n\tcase '.':\n\t\t// print element in stack to screen\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\tr_strbuf_set (&op->esil, \"ptr,[1],scr,=[1],1,scr,+=\");\n\t\tbreak;\n\tcase ',':\n\t\top->type = R_ANAL_OP_TYPE_LOAD;\n\t\tr_strbuf_set (&op->esil, \"kbd,[1],ptr,=[1],1,kbd,+=\");\n\t\tbreak;\n\tcase 0x00:\n\tcase 0xff:\n\t\top->type = R_ANAL_OP_TYPE_TRAP;\n\t\tbreak;\n\tdefault:\n\t\top->type = R_ANAL_OP_TYPE_NOP;\n\t\tr_strbuf_set (&op->esil, \",\");\n\t\tbreak;\n\t}\n\treturn op->size;\n}",
  "abstract_func": "static bool decode(RArchSession *VAR_0, RAnalOp *VAR_1, RArchDecodeMask VAR_2) {\n\tint VAR_3 = VAR_1->size;\n\tif (VAR_3 < 1) {\n\t\treturn false;\n\t}\n\tut8 *VAR_4 = VAR_1->bytes;\n\tconst ut64 VAR_5 = VAR_1->addr;\n\tut64 VAR_6 = 0LL;\n\tif (!VAR_1) {\n\t\treturn 1;\n\t}\n\tif (VAR_2 & VAR_7) {\n\t\t(void) disassemble (VAR_1, VAR_4, VAR_3);\n\t}\n\tr_strbuf_init (&VAR_1->esil);\n\tVAR_1->size = 1;\n\tVAR_1->id = getid (VAR_4[0]);\n\tswitch (VAR_4[0]) {\n\tcase '[':\n\t\tVAR_1->type = VAR_8;\n\t\t/* COMMENT_0 */\n\t\tVAR_1->jump = VAR_6;\n\t\tVAR_1->fail = VAR_5 + 1;\n\t\tRArch *VAR_9 = VAR_0->arch;\n\t\tRIOReadAt VAR_10 = NULL;\n\t\tRBin *VAR_11 = R_UNWRAP2 (VAR_9, VAR_12.bin);\n\t\tif (VAR_11 && VAR_11->iob.read_at) {\n\t\t\tRIOReadAt VAR_10 = VAR_11->iob.read_at;\n\t\t\tVAR_4 = malloc (0xff);\n\t\t\tVAR_10 (VAR_11->iob.io, VAR_1->addr, VAR_4, 0xff);\n\t\t}\n\t\tr_strbuf_set (&VAR_1->esil, \"1,pc,-,brk,=[4],4,brk,+=\");\n#if 1\n\t\tif (VAR_3 > 1) {\n\t\t\tconst ut8 *VAR_13 = VAR_4 + 1;\n\t\t\tint VAR_14 = 0, VAR_15 = 1;\n\t\t\tVAR_3--;\n\t\t\twhile (VAR_15 < VAR_3 && *VAR_13) {\n\t\t\t\tswitch (*VAR_13) {\n\t\t\t\tcase '[':\n\t\t\t\t\tVAR_14++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ']':\n\t\t\t\t\tVAR_14--;\n\t\t\t\t\tif (VAR_14 < 1) {\n\t\t\t\t\t\tsize_t VAR_16 = VAR_13 - VAR_4;\n\t\t\t\t\t\tVAR_6 = VAR_5 + (size_t)VAR_16 + 1;\n\t\t\t\t\t\tVAR_1->jump = VAR_6;\n\t\t\t\t\t\tr_strbuf_set (&VAR_1->esil, \"1,pc,-,brk,=[4],4,brk,+=,\");\n\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0:\n\t\t\t\tcase 0xff:\n\t\t\t\t\tVAR_1->type = VAR_17;\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tif (VAR_10 && VAR_15 == VAR_3 - 1) {\n#if 0\n\t\t\t\t\t/* COMMENT_1 */\n\t\t\t\t\tint VAR_18 = VAR_3 + 1 + VAR_19;\n\t\t\t\t\tut8 *VAR_20 = calloc (VAR_18, 1);\n\t\t\t\t\tif (VAR_20) {\n\t\t\t\t\t\tfree (VAR_4);\n\t\t\t\t\t\tmemcpy (VAR_20, VAR_1->bytes, VAR_18);\n\t\t\t\t\t\tVAR_4 = VAR_20;\n\t\t\t\t\t\tVAR_10 (VAR_11->iob.io, VAR_1->addr + VAR_15, VAR_4 + VAR_15, 0xff);\n\t\t\t\t\t\tVAR_13 = VAR_4 + VAR_15;\n\t\t\t\t\t\tVAR_3 += VAR_19;\n\t\t\t\t\t}\n#else\n\t\t\t\t\tbreak;\n#endif\n\t\t\t\t}\n\t\t\t\tVAR_13++;\n\t\t\t\tVAR_15++;\n\t\t\t}\n\t\t}\nbeach:\n\t\tfree (VAR_4);\n#endif\n\t\tbreak;\n\tcase ']':\n\t\tVAR_1->type = VAR_21;\n\t\tr_strbuf_set (&VAR_1->esil, \"4,brk,-=,ptr,[1],?{,brk,[4],pc,=,}\");\n\t\tbreak;\n\tcase '>':\n\t\tVAR_1->type = VAR_22;\n\t\tVAR_1->size = countChar (VAR_4, VAR_3, '>');\n\t\tr_strbuf_setf (&VAR_1->esil, \"%d,ptr,+=\", VAR_1->size);\n\t\tbreak;\n\tcase '<':\n\t\tVAR_1->type = VAR_23;\n\t\tVAR_1->size = countChar (VAR_4, VAR_3, '<');\n\t\tr_strbuf_setf (&VAR_1->esil, \"%d,ptr,-=\", VAR_1->size);\n\t\tbreak;\n\tcase '+':\n\t\tVAR_1->size = countChar (VAR_4, VAR_3, '+');\n\t\tVAR_1->type = VAR_22;\n\t\tr_strbuf_setf (&VAR_1->esil, \"%d,ptr,+=[1]\", VAR_1->size);\n\t\tbreak;\n\tcase '-':\n\t\tVAR_1->type = VAR_23;\n\t\tVAR_1->size = countChar (VAR_4, VAR_3, '-');\n\t\tr_strbuf_setf (&VAR_1->esil, \"%d,ptr,-=[1]\", VAR_1->size);\n\t\tbreak;\n\tcase '.':\n\t\t/* COMMENT_2 */\n\t\tVAR_1->type = VAR_24;\n\t\tr_strbuf_set (&VAR_1->esil, \"ptr,[1],scr,=[1],1,scr,+=\");\n\t\tbreak;\n\tcase ',':\n\t\tVAR_1->type = VAR_25;\n\t\tr_strbuf_set (&VAR_1->esil, \"kbd,[1],ptr,=[1],1,kbd,+=\");\n\t\tbreak;\n\tcase 0x00:\n\tcase 0xff:\n\t\tVAR_1->type = VAR_26;\n\t\tbreak;\n\tdefault:\n\t\tVAR_1->type = VAR_27;\n\t\tr_strbuf_set (&VAR_1->esil, \",\");\n\t\tbreak;\n\t}\n\treturn VAR_1->size;\n}",
  "func_graph_path": "radareorg/radare2/ba919adb74ac368bf76b150a00347ded78b572dd/plugin.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,12 +1,10 @@\n static bool decode(RArchSession *as, RAnalOp *op, RArchDecodeMask mask) {\n \tint len = op->size;\n-\tconst ut8 *_buf = op->bytes;\n-\tconst ut64 addr = op->addr;\n \tif (len < 1) {\n \t\treturn false;\n \t}\n-\n-\tut8 *buf = (ut8*)_buf; // XXX\n+\tut8 *buf = op->bytes;\n+\tconst ut64 addr = op->addr;\n \tut64 dst = 0LL;\n \tif (!op) {\n \t\treturn 1;\n@@ -33,29 +31,32 @@\n \t\t}\n \t\tr_strbuf_set (&op->esil, \"1,pc,-,brk,=[4],4,brk,+=\");\n #if 1\n-\t\t{\n+\t\tif (len > 1) {\n \t\t\tconst ut8 *p = buf + 1;\n \t\t\tint lev = 0, i = 1;\n \t\t\tlen--;\n \t\t\twhile (i < len && *p) {\n-\t\t\t\tif (*p == '[') {\n+\t\t\t\tswitch (*p) {\n+\t\t\t\tcase '[':\n \t\t\t\t\tlev++;\n-\t\t\t\t}\n-\t\t\t\tif (*p == ']') {\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase ']':\n \t\t\t\t\tlev--;\n-\t\t\t\t\tif (lev == -1) {\n-\t\t\t\t\t\tdst = addr + (size_t)(p - buf) + 1;\n+\t\t\t\t\tif (lev < 1) {\n+\t\t\t\t\t\tsize_t delta = p - buf;\n+\t\t\t\t\t\tdst = addr + (size_t)delta + 1;\n \t\t\t\t\t\top->jump = dst;\n \t\t\t\t\t\tr_strbuf_set (&op->esil, \"1,pc,-,brk,=[4],4,brk,+=,\");\n \t\t\t\t\t\tgoto beach;\n \t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tif (*p == 0x00 || *p == 0xff) {\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase 0:\n+\t\t\t\tcase 0xff:\n \t\t\t\t\top->type = R_ANAL_OP_TYPE_ILL;\n \t\t\t\t\tgoto beach;\n \t\t\t\t}\n \t\t\t\tif (read_at && i == len - 1) {\n-\t\t\t\t\tbreak;\n+#if 0\n \t\t\t\t\t// XXX unnecessary just break\n \t\t\t\t\tint new_buf_len = len + 1 + BUFSIZE_INC;\n \t\t\t\t\tut8 *new_buf = calloc (new_buf_len, 1);\n@@ -67,6 +68,9 @@\n \t\t\t\t\t\tp = buf + i;\n \t\t\t\t\t\tlen += BUFSIZE_INC;\n \t\t\t\t\t}\n+#else\n+\t\t\t\t\tbreak;\n+#endif\n \t\t\t\t}\n \t\t\t\tp++;\n \t\t\t\ti++;",
  "diff_line_info": {
    "deleted_lines": [
      "\tconst ut8 *_buf = op->bytes;",
      "\tconst ut64 addr = op->addr;",
      "",
      "\tut8 *buf = (ut8*)_buf; // XXX",
      "\t\t{",
      "\t\t\t\tif (*p == '[') {",
      "\t\t\t\t}",
      "\t\t\t\tif (*p == ']') {",
      "\t\t\t\t\tif (lev == -1) {",
      "\t\t\t\t\t\tdst = addr + (size_t)(p - buf) + 1;",
      "\t\t\t\t}",
      "\t\t\t\tif (*p == 0x00 || *p == 0xff) {",
      "\t\t\t\t\tbreak;"
    ],
    "added_lines": [
      "\tut8 *buf = op->bytes;",
      "\tconst ut64 addr = op->addr;",
      "\t\tif (len > 1) {",
      "\t\t\t\tswitch (*p) {",
      "\t\t\t\tcase '[':",
      "\t\t\t\t\tbreak;",
      "\t\t\t\tcase ']':",
      "\t\t\t\t\tif (lev < 1) {",
      "\t\t\t\t\t\tsize_t delta = p - buf;",
      "\t\t\t\t\t\tdst = addr + (size_t)delta + 1;",
      "\t\t\t\t\tbreak;",
      "\t\t\t\tcase 0:",
      "\t\t\t\tcase 0xff:",
      "#if 0",
      "#else",
      "\t\t\t\t\tbreak;",
      "#endif"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/radareorg/radare2/pull/22154",
  "description": {
    "pr_info": {
      "title": "Fix 1byte heap oobread in the brainfuck disassembler",
      "number": 22154
    },
    "comment": [
      "* https://huntr.dev/bounties/06e2484c-d6f1-4497-af67-26549be9fffd/\r\n* Kudos to @7resp4ss for reporting\r\n\r\n<!--\r\nRead https://github.com/radareorg/radare2/blob/master/DEVELOPERS.md\r\n* PR title must be capitalized, concise and use ##tags\r\n* If the PR is fixing a ticket use 'Fix #1234 - ..' in the commit message\r\n* Follow the coding style, add tests and documentation if necessary\r\n-->\r\n\r\n- [ ] Mark this if you consider it ready to merge\r\n- [ ] I've added tests (optional)\r\n- [ ] I wrote some lines in the [book](https://github.com/radareorg/radare2book) (optional)\r\n\r\n**Description**\r\n\r\n<!-- explain your changes if necessary -->\r\n\r\n**Copilot**\r\n\r\n<!--\r\ncopilot:all\r\n-->\r\n"
    ]
  },
  "Bug Filter": "** Security Vulnerability Fix  \n**Confidence Score:** 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\nThe patch addresses an out-of-bounds read vulnerability in the brainfuck disassembler by adding boundary checks and safer buffer access, which prevents unauthorized memory access.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 0.95"
}