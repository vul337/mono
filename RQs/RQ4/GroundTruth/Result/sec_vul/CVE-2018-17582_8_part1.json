{
  "cve_id": "CVE-2018-17582",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "appneta/tcpreplay",
  "commit_msg": "Bug #484 CVE-2018-17582 Check for corrupt PCAP files\n\n* Check for packets that are larger than 262144 bytes\n* Check for capture lengths that are greater than packet length\n\nExample of a corrupt PCAP file ...\n\nsudo src/tcpreplay -i ens33 --unique-ip -t --loop 4 get_next_paket_01\nsafe_pcap_next ERROR: Invalid packet length in send_packets.c:get_next_packet() line 1054: 8388670 is greater than maximum 262144",
  "commit_hash": "68f67b1a3a4d319543692afb5bd5b191ec984287",
  "git_url": "https://github.com/appneta/tcpreplay/commit/68f67b1a3a4d319543692afb5bd5b191ec984287",
  "file_path": "src/tcpliveplay.c",
  "func_name": "setup_sched",
  "func_before": "int\nsetup_sched(struct tcp_sched* sched){\n\n    input_addr sip, dip;  /* Source & Destination IP */ \n    input_addr local_ip, remote_ip;    /* ip address of client and server*/\n    /*temporary packet buffers*/\n    struct pcap_pkthdr header;  // The header that pcap gives us\n    const u_char *packet;       // The actual packet\n    pcap_t *local_handle;\n    unsigned int pkt_counter=0;\n    ether_hdr *etherhdr = NULL;\n    tcp_hdr *tcphdr = NULL;\n    ipv4_hdr *iphdr = NULL;\n    local_ip.byte1=0; \n    local_ip.byte2=0; \n    local_ip.byte3=0; \n    local_ip.byte4=0; \n\n    remote_ip.byte1=0; \n    remote_ip.byte2=0; \n    remote_ip.byte3=0; \n    remote_ip.byte4=0; \n\n    unsigned int size_ip, i = 0; \n    unsigned int size_tcp; \n    unsigned int size_payload; \n    char errbuf[PCAP_ERRBUF_SIZE];\n    unsigned int flags=0; \n    bool remote = false;    /* flags to test if data is from 'cleint'=local or 'server'=remote */\n    bool local = false; \n\n\n    local_handle = pcap_open_offline(\"newfile.pcap\", errbuf);   /*call pcap library function*/\n\n    if (local_handle == NULL) {\n        fprintf(stderr,\"Couldn't open pcap file %s: %s\\n\", \"newfile.pcap\", errbuf);\n        return(2);\n    }\n\n    /*Before sending any packet, setup the schedule with the proper parameters*/\n    while((packet = pcap_next(local_handle,&header))) {\n        pkt_counter++; /*increment number of packets seen*/\n\n        memcpy(&sched[i].pkthdr, &header, sizeof(struct pcap_pkthdr));\n        //sched[i].len = header.len; \n        //sched[i].caplen = header.caplen; \n        sched[i].packet_ptr = safe_malloc(sched[i].pkthdr.len);\n        memcpy(sched[i].packet_ptr, packet, sched[i].pkthdr.len);\n\n        /* extract necessary data */\n        etherhdr = (ether_hdr*)(sched[i].packet_ptr);\n        iphdr = (ipv4_hdr *)(sched[i].packet_ptr + SIZE_ETHERNET);\n        size_ip = iphdr->ip_hl << 2;\n        if (size_ip < 20) {\n            printf(\"ERROR: Invalid IP header length: %u bytes\\n\", size_ip);\n            return 0;\n        }\n        tcphdr = (tcp_hdr *)(sched[i].packet_ptr + SIZE_ETHERNET + size_ip);\n        size_tcp = tcphdr->th_off*4; \n        if (size_tcp < 20) {\n            printf(\"ERROR: Invalid TCP header length: %u bytes\\n\", size_tcp);\n            return 0;\n        }\n        /* payload = (u_char *)(sched[i].packet_ptr + SIZE_ETHERNET + size_ip + size_tcp); */\n        size_payload = ntohs(iphdr->ip_len) - (size_ip + (size_tcp));\n\n\n        /* Source IP and Destination IP */\n        sip = iphdr->ip_src;\n        dip = iphdr->ip_dst;\n\n        flags = tcphdr->th_flags;\n\n        if (flags == TH_SYN){   /* set IPs who's local and who's remote based on the SYN flag */\n            local_ip = sip;\n            remote_ip = dip;\n        }\n\n        /*Compare IPs to see which packet is this comming from*/\n        if(compip(&local_ip, &remote_ip, &sip)==LOCAL_IP_MATCH){\n            local = true;\n            remote = false;\n        }\n        if(compip(&local_ip, &remote_ip, &sip)==REMOTE_IP_MATCH){\n            local = false;\n            remote = true;\n        }\n\n        /* Setup rest of Schedule, parameter by parameter */\n        /* Refer to header file for details on each of the parameters */\n\n        sched[i].etherhdr = etherhdr; \n        sched[i].iphdr = iphdr; \n        sched[i].tcphdr = tcphdr; \n        sched[i].size_ip = size_ip; \n        sched[i].size_tcp = size_tcp;  \n        sched[i].size_payload = size_payload;\n        sched[i].sent_counter = 0; \n\n        /* Do the following only for the first packet (SYN)*/\n        if(i==0){\n            sched[i].length_last_ldata = 0;\n            sched[i].length_curr_ldata = 0; \n            sched[i].length_last_rdata = 0;\n            sched[i].length_curr_rdata = 0; \n            sched[i].local = true; \n            sched[i].remote = false;\n            sched[i].curr_lseq = ntohl(sched[i].tcphdr->th_seq); \n            sched[i].curr_lack = 0;\n            sched[i].exp_rseq = 0;  /* Keep track of previous remote seq & ack #s*/\n            sched[i].exp_rack = 0;\n\n        } \n\n        /* Local Packet operations */\n        else if(local){\n            sched[i].length_last_ldata = sched[i-1].length_curr_ldata; \n            sched[i].length_curr_ldata = size_payload; \n            sched[i].length_last_rdata = sched[i-1].length_curr_rdata;\n            sched[i].length_curr_rdata = 0; \n            sched[i].local = true; \n            sched[i].remote = false;\n            sched[i].curr_lseq = ntohl(sched[i].tcphdr->th_seq); \n            sched[i].curr_lack = ntohl(sched[i].tcphdr->th_ack);\n            sched[i].exp_rseq = sched[i-1].exp_rseq;    /* Keep track of previous remote seq & ack #s*/\n            sched[i].exp_rack = sched[i-1].exp_rack;\n\n        }\n\n        /* Remote Packet operations */\n        else if(remote){\n            sched[i].length_last_ldata = sched[i-1].length_curr_ldata;\n            sched[i].length_curr_ldata = 0; \n            sched[i].length_last_rdata = sched[i-1].length_curr_rdata;\n            sched[i].length_curr_rdata = size_payload; \n            sched[i].local = false; \n            sched[i].remote = true;\n            sched[i].curr_lseq = sched[i-1].curr_lseq; \n            sched[i].curr_lack = sched[i-1].curr_lack;\n            sched[i].exp_rseq = ntohl(sched[i].tcphdr->th_seq);     /* Keep track of previous remote seq & ack #s*/\n            sched[i].exp_rack = ntohl(sched[i].tcphdr->th_ack);\n            /* Setup global variable where remote FIN-ACK exists*/\n            if(flags == (TH_FIN|TH_ACK)) finack_rindex = i;\n            //printf(\"REMOTE --------%d\\n\",i+1);\n        }\n\n\n        i++; /* increment schedule index */\n\n    } /*end internal loop for reading packets (all in one file)*/\n\n    pcap_close(local_handle);  /*close the pcap file*/\n\n    return pkt_counter; /* Return number of packets scheduled */\n}",
  "abstract_func_before": "int\nsetup_sched(struct tcp_sched* VAR_0){\n\n    input_addr VAR_1, VAR_2;  /* COMMENT_0 */ \n    input_addr VAR_3, VAR_4;    /* COMMENT_1 */\n    /* COMMENT_2 */\n    struct pcap_pkthdr VAR_5;  /* COMMENT_3 */\n    const u_char *VAR_6;       /* COMMENT_4 */\n    pcap_t *VAR_7;\n    unsigned int VAR_8=0;\n    ether_hdr *VAR_9 = NULL;\n    tcp_hdr *VAR_10 = NULL;\n    ipv4_hdr *VAR_11 = NULL;\n    VAR_3.byte1=0; \n    VAR_3.byte2=0; \n    VAR_3.byte3=0; \n    VAR_3.byte4=0; \n\n    VAR_4.byte1=0; \n    VAR_4.byte2=0; \n    VAR_4.byte3=0; \n    VAR_4.byte4=0; \n\n    unsigned int VAR_12, VAR_13 = 0; \n    unsigned int VAR_14; \n    unsigned int VAR_15; \n    char VAR_16[VAR_17];\n    unsigned int VAR_18=0; \n    bool VAR_19 = false;    /* COMMENT_5 */\n    bool VAR_20 = false; \n\n\n    VAR_7 = pcap_open_offline(\"newfile.pcap\", VAR_16);   /* COMMENT_6 */\n\n    if (VAR_7 == NULL) {\n        fprintf(VAR_21,\"Couldn't open pcap file %s: %s\\n\", \"newfile.pcap\", VAR_16);\n        return(2);\n    }\n\n    /* COMMENT_7 */\n    while((VAR_6 = pcap_next(VAR_7,&VAR_5))) {\n        VAR_8++; /* COMMENT_8 */\n\n        memcpy(&VAR_0[VAR_13].pkthdr, &VAR_5, sizeof(struct pcap_pkthdr));\n        /* COMMENT_9 */\n        /* COMMENT_10 */\n        VAR_0[VAR_13].packet_ptr = safe_malloc(VAR_0[VAR_13].pkthdr.len);\n        memcpy(VAR_0[VAR_13].packet_ptr, VAR_6, VAR_0[VAR_13].pkthdr.len);\n\n        /* COMMENT_11 */\n        VAR_9 = (ether_hdr*)(VAR_0[VAR_13].packet_ptr);\n        VAR_11 = (ipv4_hdr *)(VAR_0[VAR_13].packet_ptr + VAR_22);\n        VAR_12 = VAR_11->ip_hl << 2;\n        if (VAR_12 < 20) {\n            printf(\"ERROR: Invalid IP header length: %u bytes\\n\", VAR_12);\n            return 0;\n        }\n        VAR_10 = (tcp_hdr *)(VAR_0[VAR_13].packet_ptr + VAR_22 + VAR_12);\n        VAR_14 = VAR_10->th_off*4; \n        if (VAR_14 < 20) {\n            printf(\"ERROR: Invalid TCP header length: %u bytes\\n\", VAR_14);\n            return 0;\n        }\n        /* COMMENT_12 */\n        VAR_15 = ntohs(VAR_11->ip_len) - (VAR_12 + (VAR_14));\n\n\n        /* COMMENT_13 */\n        VAR_1 = VAR_11->ip_src;\n        VAR_2 = VAR_11->ip_dst;\n\n        VAR_18 = VAR_10->th_flags;\n\n        if (VAR_18 == VAR_23){   /* COMMENT_14 */\n            VAR_3 = VAR_1;\n            VAR_4 = VAR_2;\n        }\n\n        /* COMMENT_15 */\n        if(compip(&VAR_3, &VAR_4, &VAR_1)==VAR_24){\n            VAR_20 = true;\n            VAR_19 = false;\n        }\n        if(compip(&VAR_3, &VAR_4, &VAR_1)==VAR_25){\n            VAR_20 = false;\n            VAR_19 = true;\n        }\n\n        /* COMMENT_16 */\n        /* COMMENT_17 */\n\n        VAR_0[VAR_13].etherhdr = VAR_9; \n        VAR_0[VAR_13].iphdr = VAR_11; \n        VAR_0[VAR_13].tcphdr = VAR_10; \n        VAR_0[VAR_13].size_ip = VAR_12; \n        VAR_0[VAR_13].size_tcp = VAR_14;  \n        VAR_0[VAR_13].size_payload = VAR_15;\n        VAR_0[VAR_13].sent_counter = 0; \n\n        /* COMMENT_18 */\n        if(VAR_13==0){\n            VAR_0[VAR_13].length_last_ldata = 0;\n            VAR_0[VAR_13].length_curr_ldata = 0; \n            VAR_0[VAR_13].length_last_rdata = 0;\n            VAR_0[VAR_13].length_curr_rdata = 0; \n            VAR_0[VAR_13].local = true; \n            VAR_0[VAR_13].remote = false;\n            VAR_0[VAR_13].curr_lseq = ntohl(VAR_0[VAR_13].tcphdr->th_seq); \n            VAR_0[VAR_13].curr_lack = 0;\n            VAR_0[VAR_13].exp_rseq = 0;  /* COMMENT_19 */\n            VAR_0[VAR_13].exp_rack = 0;\n\n        } \n\n        /* COMMENT_20 */\n        else if(VAR_20){\n            VAR_0[VAR_13].length_last_ldata = VAR_0[VAR_13-1].length_curr_ldata; \n            VAR_0[VAR_13].length_curr_ldata = VAR_15; \n            VAR_0[VAR_13].length_last_rdata = VAR_0[VAR_13-1].length_curr_rdata;\n            VAR_0[VAR_13].length_curr_rdata = 0; \n            VAR_0[VAR_13].local = true; \n            VAR_0[VAR_13].remote = false;\n            VAR_0[VAR_13].curr_lseq = ntohl(VAR_0[VAR_13].tcphdr->th_seq); \n            VAR_0[VAR_13].curr_lack = ntohl(VAR_0[VAR_13].tcphdr->th_ack);\n            VAR_0[VAR_13].exp_rseq = VAR_0[VAR_13-1].exp_rseq;    /* COMMENT_19 */\n            VAR_0[VAR_13].exp_rack = VAR_0[VAR_13-1].exp_rack;\n\n        }\n\n        /* COMMENT_21 */\n        else if(VAR_19){\n            VAR_0[VAR_13].length_last_ldata = VAR_0[VAR_13-1].length_curr_ldata;\n            VAR_0[VAR_13].length_curr_ldata = 0; \n            VAR_0[VAR_13].length_last_rdata = VAR_0[VAR_13-1].length_curr_rdata;\n            VAR_0[VAR_13].length_curr_rdata = VAR_15; \n            VAR_0[VAR_13].local = false; \n            VAR_0[VAR_13].remote = true;\n            VAR_0[VAR_13].curr_lseq = VAR_0[VAR_13-1].curr_lseq; \n            VAR_0[VAR_13].curr_lack = VAR_0[VAR_13-1].curr_lack;\n            VAR_0[VAR_13].exp_rseq = ntohl(VAR_0[VAR_13].tcphdr->th_seq);     /* COMMENT_19 */\n            VAR_0[VAR_13].exp_rack = ntohl(VAR_0[VAR_13].tcphdr->th_ack);\n            /* COMMENT_22 */\n            if(VAR_18 == (VAR_26|VAR_27)) VAR_28 = VAR_13;\n            /* COMMENT_23 */\n        }\n\n\n        VAR_13++; /* COMMENT_24 */\n\n    } /* COMMENT_25 */\n\n    pcap_close(VAR_7);  /* COMMENT_26 */\n\n    return VAR_8; /* COMMENT_27 */\n}",
  "func_graph_path_before": "appneta/tcpreplay/68f67b1a3a4d319543692afb5bd5b191ec984287/tcpliveplay.c/vul/before/1.json",
  "func": "int\nsetup_sched(struct tcp_sched* sched){\n\n    input_addr sip, dip;  /* Source & Destination IP */ \n    input_addr local_ip, remote_ip;    /* ip address of client and server*/\n    /*temporary packet buffers*/\n    struct pcap_pkthdr header;  // The header that pcap gives us\n    const u_char *packet;       // The actual packet\n    pcap_t *local_handle;\n    unsigned int pkt_counter=0;\n    ether_hdr *etherhdr = NULL;\n    tcp_hdr *tcphdr = NULL;\n    ipv4_hdr *iphdr = NULL;\n    local_ip.byte1=0; \n    local_ip.byte2=0; \n    local_ip.byte3=0; \n    local_ip.byte4=0; \n\n    remote_ip.byte1=0; \n    remote_ip.byte2=0; \n    remote_ip.byte3=0; \n    remote_ip.byte4=0; \n\n    unsigned int size_ip, i = 0; \n    unsigned int size_tcp; \n    unsigned int size_payload; \n    char errbuf[PCAP_ERRBUF_SIZE];\n    unsigned int flags=0; \n    bool remote = false;    /* flags to test if data is from 'cleint'=local or 'server'=remote */\n    bool local = false; \n\n\n    local_handle = pcap_open_offline(\"newfile.pcap\", errbuf);   /*call pcap library function*/\n\n    if (local_handle == NULL) {\n        fprintf(stderr,\"Couldn't open pcap file %s: %s\\n\", \"newfile.pcap\", errbuf);\n        return(2);\n    }\n\n    /*Before sending any packet, setup the schedule with the proper parameters*/\n    while((packet = safe_pcap_next(local_handle,&header))) {\n        pkt_counter++; /*increment number of packets seen*/\n\n        memcpy(&sched[i].pkthdr, &header, sizeof(struct pcap_pkthdr));\n        //sched[i].len = header.len; \n        //sched[i].caplen = header.caplen; \n        sched[i].packet_ptr = safe_malloc(sched[i].pkthdr.len);\n        memcpy(sched[i].packet_ptr, packet, sched[i].pkthdr.len);\n\n        /* extract necessary data */\n        etherhdr = (ether_hdr*)(sched[i].packet_ptr);\n        iphdr = (ipv4_hdr *)(sched[i].packet_ptr + SIZE_ETHERNET);\n        size_ip = iphdr->ip_hl << 2;\n        if (size_ip < 20) {\n            printf(\"ERROR: Invalid IP header length: %u bytes\\n\", size_ip);\n            return 0;\n        }\n        tcphdr = (tcp_hdr *)(sched[i].packet_ptr + SIZE_ETHERNET + size_ip);\n        size_tcp = tcphdr->th_off*4; \n        if (size_tcp < 20) {\n            printf(\"ERROR: Invalid TCP header length: %u bytes\\n\", size_tcp);\n            return 0;\n        }\n        /* payload = (u_char *)(sched[i].packet_ptr + SIZE_ETHERNET + size_ip + size_tcp); */\n        size_payload = ntohs(iphdr->ip_len) - (size_ip + (size_tcp));\n\n\n        /* Source IP and Destination IP */\n        sip = iphdr->ip_src;\n        dip = iphdr->ip_dst;\n\n        flags = tcphdr->th_flags;\n\n        if (flags == TH_SYN){   /* set IPs who's local and who's remote based on the SYN flag */\n            local_ip = sip;\n            remote_ip = dip;\n        }\n\n        /*Compare IPs to see which packet is this comming from*/\n        if(compip(&local_ip, &remote_ip, &sip)==LOCAL_IP_MATCH){\n            local = true;\n            remote = false;\n        }\n        if(compip(&local_ip, &remote_ip, &sip)==REMOTE_IP_MATCH){\n            local = false;\n            remote = true;\n        }\n\n        /* Setup rest of Schedule, parameter by parameter */\n        /* Refer to header file for details on each of the parameters */\n\n        sched[i].etherhdr = etherhdr; \n        sched[i].iphdr = iphdr; \n        sched[i].tcphdr = tcphdr; \n        sched[i].size_ip = size_ip; \n        sched[i].size_tcp = size_tcp;  \n        sched[i].size_payload = size_payload;\n        sched[i].sent_counter = 0; \n\n        /* Do the following only for the first packet (SYN)*/\n        if(i==0){\n            sched[i].length_last_ldata = 0;\n            sched[i].length_curr_ldata = 0; \n            sched[i].length_last_rdata = 0;\n            sched[i].length_curr_rdata = 0; \n            sched[i].local = true; \n            sched[i].remote = false;\n            sched[i].curr_lseq = ntohl(sched[i].tcphdr->th_seq); \n            sched[i].curr_lack = 0;\n            sched[i].exp_rseq = 0;  /* Keep track of previous remote seq & ack #s*/\n            sched[i].exp_rack = 0;\n\n        } \n\n        /* Local Packet operations */\n        else if(local){\n            sched[i].length_last_ldata = sched[i-1].length_curr_ldata; \n            sched[i].length_curr_ldata = size_payload; \n            sched[i].length_last_rdata = sched[i-1].length_curr_rdata;\n            sched[i].length_curr_rdata = 0; \n            sched[i].local = true; \n            sched[i].remote = false;\n            sched[i].curr_lseq = ntohl(sched[i].tcphdr->th_seq); \n            sched[i].curr_lack = ntohl(sched[i].tcphdr->th_ack);\n            sched[i].exp_rseq = sched[i-1].exp_rseq;    /* Keep track of previous remote seq & ack #s*/\n            sched[i].exp_rack = sched[i-1].exp_rack;\n\n        }\n\n        /* Remote Packet operations */\n        else if(remote){\n            sched[i].length_last_ldata = sched[i-1].length_curr_ldata;\n            sched[i].length_curr_ldata = 0; \n            sched[i].length_last_rdata = sched[i-1].length_curr_rdata;\n            sched[i].length_curr_rdata = size_payload; \n            sched[i].local = false; \n            sched[i].remote = true;\n            sched[i].curr_lseq = sched[i-1].curr_lseq; \n            sched[i].curr_lack = sched[i-1].curr_lack;\n            sched[i].exp_rseq = ntohl(sched[i].tcphdr->th_seq);     /* Keep track of previous remote seq & ack #s*/\n            sched[i].exp_rack = ntohl(sched[i].tcphdr->th_ack);\n            /* Setup global variable where remote FIN-ACK exists*/\n            if(flags == (TH_FIN|TH_ACK)) finack_rindex = i;\n            //printf(\"REMOTE --------%d\\n\",i+1);\n        }\n\n\n        i++; /* increment schedule index */\n\n    } /*end internal loop for reading packets (all in one file)*/\n\n    pcap_close(local_handle);  /*close the pcap file*/\n\n    return pkt_counter; /* Return number of packets scheduled */\n}",
  "abstract_func": "int\nsetup_sched(struct tcp_sched* VAR_0){\n\n    input_addr VAR_1, VAR_2;  /* COMMENT_0 */ \n    input_addr VAR_3, VAR_4;    /* COMMENT_1 */\n    /* COMMENT_2 */\n    struct pcap_pkthdr VAR_5;  /* COMMENT_3 */\n    const u_char *VAR_6;       /* COMMENT_4 */\n    pcap_t *VAR_7;\n    unsigned int VAR_8=0;\n    ether_hdr *VAR_9 = NULL;\n    tcp_hdr *VAR_10 = NULL;\n    ipv4_hdr *VAR_11 = NULL;\n    VAR_3.byte1=0; \n    VAR_3.byte2=0; \n    VAR_3.byte3=0; \n    VAR_3.byte4=0; \n\n    VAR_4.byte1=0; \n    VAR_4.byte2=0; \n    VAR_4.byte3=0; \n    VAR_4.byte4=0; \n\n    unsigned int VAR_12, VAR_13 = 0; \n    unsigned int VAR_14; \n    unsigned int VAR_15; \n    char VAR_16[VAR_17];\n    unsigned int VAR_18=0; \n    bool VAR_19 = false;    /* COMMENT_5 */\n    bool VAR_20 = false; \n\n\n    VAR_7 = pcap_open_offline(\"newfile.pcap\", VAR_16);   /* COMMENT_6 */\n\n    if (VAR_7 == NULL) {\n        fprintf(VAR_21,\"Couldn't open pcap file %s: %s\\n\", \"newfile.pcap\", VAR_16);\n        return(2);\n    }\n\n    /* COMMENT_7 */\n    while((VAR_6 = safe_pcap_next(VAR_7,&VAR_5))) {\n        VAR_8++; /* COMMENT_8 */\n\n        memcpy(&VAR_0[VAR_13].pkthdr, &VAR_5, sizeof(struct pcap_pkthdr));\n        /* COMMENT_9 */\n        /* COMMENT_10 */\n        VAR_0[VAR_13].packet_ptr = safe_malloc(VAR_0[VAR_13].pkthdr.len);\n        memcpy(VAR_0[VAR_13].packet_ptr, VAR_6, VAR_0[VAR_13].pkthdr.len);\n\n        /* COMMENT_11 */\n        VAR_9 = (ether_hdr*)(VAR_0[VAR_13].packet_ptr);\n        VAR_11 = (ipv4_hdr *)(VAR_0[VAR_13].packet_ptr + VAR_22);\n        VAR_12 = VAR_11->ip_hl << 2;\n        if (VAR_12 < 20) {\n            printf(\"ERROR: Invalid IP header length: %u bytes\\n\", VAR_12);\n            return 0;\n        }\n        VAR_10 = (tcp_hdr *)(VAR_0[VAR_13].packet_ptr + VAR_22 + VAR_12);\n        VAR_14 = VAR_10->th_off*4; \n        if (VAR_14 < 20) {\n            printf(\"ERROR: Invalid TCP header length: %u bytes\\n\", VAR_14);\n            return 0;\n        }\n        /* COMMENT_12 */\n        VAR_15 = ntohs(VAR_11->ip_len) - (VAR_12 + (VAR_14));\n\n\n        /* COMMENT_13 */\n        VAR_1 = VAR_11->ip_src;\n        VAR_2 = VAR_11->ip_dst;\n\n        VAR_18 = VAR_10->th_flags;\n\n        if (VAR_18 == VAR_23){   /* COMMENT_14 */\n            VAR_3 = VAR_1;\n            VAR_4 = VAR_2;\n        }\n\n        /* COMMENT_15 */\n        if(compip(&VAR_3, &VAR_4, &VAR_1)==VAR_24){\n            VAR_20 = true;\n            VAR_19 = false;\n        }\n        if(compip(&VAR_3, &VAR_4, &VAR_1)==VAR_25){\n            VAR_20 = false;\n            VAR_19 = true;\n        }\n\n        /* COMMENT_16 */\n        /* COMMENT_17 */\n\n        VAR_0[VAR_13].etherhdr = VAR_9; \n        VAR_0[VAR_13].iphdr = VAR_11; \n        VAR_0[VAR_13].tcphdr = VAR_10; \n        VAR_0[VAR_13].size_ip = VAR_12; \n        VAR_0[VAR_13].size_tcp = VAR_14;  \n        VAR_0[VAR_13].size_payload = VAR_15;\n        VAR_0[VAR_13].sent_counter = 0; \n\n        /* COMMENT_18 */\n        if(VAR_13==0){\n            VAR_0[VAR_13].length_last_ldata = 0;\n            VAR_0[VAR_13].length_curr_ldata = 0; \n            VAR_0[VAR_13].length_last_rdata = 0;\n            VAR_0[VAR_13].length_curr_rdata = 0; \n            VAR_0[VAR_13].local = true; \n            VAR_0[VAR_13].remote = false;\n            VAR_0[VAR_13].curr_lseq = ntohl(VAR_0[VAR_13].tcphdr->th_seq); \n            VAR_0[VAR_13].curr_lack = 0;\n            VAR_0[VAR_13].exp_rseq = 0;  /* COMMENT_19 */\n            VAR_0[VAR_13].exp_rack = 0;\n\n        } \n\n        /* COMMENT_20 */\n        else if(VAR_20){\n            VAR_0[VAR_13].length_last_ldata = VAR_0[VAR_13-1].length_curr_ldata; \n            VAR_0[VAR_13].length_curr_ldata = VAR_15; \n            VAR_0[VAR_13].length_last_rdata = VAR_0[VAR_13-1].length_curr_rdata;\n            VAR_0[VAR_13].length_curr_rdata = 0; \n            VAR_0[VAR_13].local = true; \n            VAR_0[VAR_13].remote = false;\n            VAR_0[VAR_13].curr_lseq = ntohl(VAR_0[VAR_13].tcphdr->th_seq); \n            VAR_0[VAR_13].curr_lack = ntohl(VAR_0[VAR_13].tcphdr->th_ack);\n            VAR_0[VAR_13].exp_rseq = VAR_0[VAR_13-1].exp_rseq;    /* COMMENT_19 */\n            VAR_0[VAR_13].exp_rack = VAR_0[VAR_13-1].exp_rack;\n\n        }\n\n        /* COMMENT_21 */\n        else if(VAR_19){\n            VAR_0[VAR_13].length_last_ldata = VAR_0[VAR_13-1].length_curr_ldata;\n            VAR_0[VAR_13].length_curr_ldata = 0; \n            VAR_0[VAR_13].length_last_rdata = VAR_0[VAR_13-1].length_curr_rdata;\n            VAR_0[VAR_13].length_curr_rdata = VAR_15; \n            VAR_0[VAR_13].local = false; \n            VAR_0[VAR_13].remote = true;\n            VAR_0[VAR_13].curr_lseq = VAR_0[VAR_13-1].curr_lseq; \n            VAR_0[VAR_13].curr_lack = VAR_0[VAR_13-1].curr_lack;\n            VAR_0[VAR_13].exp_rseq = ntohl(VAR_0[VAR_13].tcphdr->th_seq);     /* COMMENT_19 */\n            VAR_0[VAR_13].exp_rack = ntohl(VAR_0[VAR_13].tcphdr->th_ack);\n            /* COMMENT_22 */\n            if(VAR_18 == (VAR_26|VAR_27)) VAR_28 = VAR_13;\n            /* COMMENT_23 */\n        }\n\n\n        VAR_13++; /* COMMENT_24 */\n\n    } /* COMMENT_25 */\n\n    pcap_close(VAR_7);  /* COMMENT_26 */\n\n    return VAR_8; /* COMMENT_27 */\n}",
  "func_graph_path": "appneta/tcpreplay/68f67b1a3a4d319543692afb5bd5b191ec984287/tcpliveplay.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -38,7 +38,7 @@\n     }\n \n     /*Before sending any packet, setup the schedule with the proper parameters*/\n-    while((packet = pcap_next(local_handle,&header))) {\n+    while((packet = safe_pcap_next(local_handle,&header))) {\n         pkt_counter++; /*increment number of packets seen*/\n \n         memcpy(&sched[i].pkthdr, &header, sizeof(struct pcap_pkthdr));",
  "diff_line_info": {
    "deleted_lines": [
      "    while((packet = pcap_next(local_handle,&header))) {"
    ],
    "added_lines": [
      "    while((packet = safe_pcap_next(local_handle,&header))) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/appneta/tcpreplay/pull/491",
  "description": {
    "pr_info": {
      "title": "Bug #484 CVE-2018-17582 Check for corrupt PCAP files",
      "number": 491
    },
    "comment": [
      "* Check for packets that are larger than 262144 bytes\r\n* Check for capture lengths that are greater than packet length\r\n\r\nExample of a corrupt PCAP file ...\r\n\r\nsudo src/tcpreplay -i ens33 --unique-ip -t --loop 4 get_next_paket_01\r\nsafe_pcap_next ERROR: Invalid packet length in send_packets.c:get_next_packet() line 1054: 8388670 is greater than maximum 262144"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 0.95"
}