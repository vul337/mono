{
  "cve_id": "CVE-2022-40761",
  "cwe_ids": [
    "CWE-1284"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "Samsung/mTower",
  "commit_msg": "Fixed CVE-2022-40761\n\nSigned-off-by: Taras Drozdovskyi <t.drozdovsky@samsung.com>",
  "commit_hash": "c5f30c70e48786e1aef8c815f35e406a6c4fb3ae",
  "git_url": "https://github.com/Samsung/mTower/commit/c5f30c70e48786e1aef8c815f35e406a6c4fb3ae",
  "file_path": "tee/tee/tee_svc_cryp.c",
  "func_name": "utee_cryp_state_alloc",
  "func_before": "TEE_Result utee_cryp_state_alloc(unsigned long algo, unsigned long mode,\n\t\t\tunsigned long key1, unsigned long key2,\n\t\t\tuint32_t *state)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o1 = NULL;\n\tstruct tee_obj *o2 = NULL;\n\tstruct user_ta_ctx *utc;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tutc = to_user_ta_ctx(sess->ctx);\n\n\tif (key1 != 0) {\n\t\tres = tee_obj_get(utc, tee_svc_uref_to_vaddr(key1), &o1);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tif (o1->busy)\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\tres = tee_svc_cryp_check_key_type(o1, algo, mode);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\tif (key2 != 0) {\n\t\tres = tee_obj_get(utc, tee_svc_uref_to_vaddr(key2), &o2);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tif (o2->busy)\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\tres = tee_svc_cryp_check_key_type(o2, algo, mode);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\n\tcs = calloc(1, sizeof(struct tee_cryp_state));\n\tif (!cs)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tTAILQ_INSERT_TAIL(&utc->cryp_states, cs, link);\n\tcs->algo = algo;\n\tcs->mode = mode;\n\n\tswitch (TEE_ALG_GET_CLASS(algo)) {\n\tcase TEE_OPERATION_CIPHER:\n\t\tif ((algo == TEE_ALG_AES_XTS && (key1 == 0 || key2 == 0)) ||\n\t\t    (algo != TEE_ALG_AES_XTS && (key1 == 0 || key2 != 0))) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t} else {\n\t\t\tres = crypto_cipher_alloc_ctx(&cs->ctx, algo);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase TEE_OPERATION_AE:\n\t\tif (key1 == 0 || key2 != 0) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t} else {\n//\t\t\tres = crypto_authenc_alloc_ctx(&cs->ctx, algo);\n//\t\t\tif (res != TEE_SUCCESS)\n//\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\tif (key1 == 0 || key2 != 0) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t} else {\n\t\t\tres = crypto_mac_alloc_ctx(&cs->ctx, algo);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase TEE_OPERATION_DIGEST:\n\t\tif (key1 != 0 || key2 != 0) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t} else {\n\t\t\tres = crypto_hash_alloc_ctx(&cs->ctx, algo);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase TEE_OPERATION_ASYMMETRIC_CIPHER:\n\tcase TEE_OPERATION_ASYMMETRIC_SIGNATURE:\n\t\tif (key1 == 0 || key2 != 0)\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tbreak;\n\tcase TEE_OPERATION_KEY_DERIVATION:\n\t\tif (key1 == 0 || key2 != 0)\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tbreak;\n\tdefault:\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t\tbreak;\n\t}\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_svc_copy_kaddr_to_uref(state, cs);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\t/* Register keys */\n\tif (o1 != NULL) {\n\t\to1->busy = true;\n\t\tcs->key1 = (vaddr_t)o1;\n\t}\n\tif (o2 != NULL) {\n\t\to2->busy = true;\n\t\tcs->key2 = (vaddr_t)o2;\n\t}\n\nout:\n\tif (res != TEE_SUCCESS)\n\t\tcryp_state_free(utc, cs);\n\treturn res;\n}",
  "abstract_func_before": "TEE_Result utee_cryp_state_alloc(unsigned long VAR_0, unsigned long VAR_1,\n\t\t\tunsigned long VAR_2, unsigned long VAR_3,\n\t\t\tuint32_t *VAR_4)\n{\n\tTEE_Result VAR_5;\n\tstruct tee_cryp_state *VAR_6;\n\tstruct tee_ta_session *VAR_7;\n\tstruct tee_obj *VAR_8 = NULL;\n\tstruct tee_obj *VAR_9 = NULL;\n\tstruct user_ta_ctx *VAR_10;\n\n\tVAR_5 = tee_ta_get_current_session(&VAR_7);\n\tif (VAR_5 != VAR_11)\n\t\treturn VAR_5;\n\tVAR_10 = to_user_ta_ctx(VAR_7->ctx);\n\n\tif (VAR_2 != 0) {\n\t\tVAR_5 = tee_obj_get(VAR_10, tee_svc_uref_to_vaddr(VAR_2), &VAR_8);\n\t\tif (VAR_5 != VAR_11)\n\t\t\treturn VAR_5;\n\t\tif (VAR_8->busy)\n\t\t\treturn VAR_12;\n\t\tVAR_5 = tee_svc_cryp_check_key_type(VAR_8, VAR_0, VAR_1);\n\t\tif (VAR_5 != VAR_11)\n\t\t\treturn VAR_5;\n\t}\n\tif (VAR_3 != 0) {\n\t\tVAR_5 = tee_obj_get(VAR_10, tee_svc_uref_to_vaddr(VAR_3), &VAR_9);\n\t\tif (VAR_5 != VAR_11)\n\t\t\treturn VAR_5;\n\t\tif (VAR_9->busy)\n\t\t\treturn VAR_12;\n\t\tVAR_5 = tee_svc_cryp_check_key_type(VAR_9, VAR_0, VAR_1);\n\t\tif (VAR_5 != VAR_11)\n\t\t\treturn VAR_5;\n\t}\n\n\tVAR_6 = calloc(1, sizeof(struct tee_cryp_state));\n\tif (!VAR_6)\n\t\treturn VAR_13;\n\tTAILQ_INSERT_TAIL(&VAR_10->cryp_states, VAR_6, VAR_14);\n\tVAR_6->algo = VAR_0;\n\tVAR_6->mode = VAR_1;\n\n\tswitch (TEE_ALG_GET_CLASS(VAR_0)) {\n\tcase VAR_15:\n\t\tif ((VAR_0 == VAR_16 && (VAR_2 == 0 || VAR_3 == 0)) ||\n\t\t    (VAR_0 != VAR_16 && (VAR_2 == 0 || VAR_3 != 0))) {\n\t\t\tVAR_5 = VAR_12;\n\t\t} else {\n\t\t\tVAR_5 = crypto_cipher_alloc_ctx(&VAR_6->ctx, VAR_0);\n\t\t\tif (VAR_5 != VAR_11)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase VAR_17:\n\t\tif (VAR_2 == 0 || VAR_3 != 0) {\n\t\t\tVAR_5 = VAR_12;\n\t\t} else {\n/* COMMENT_0 */\n/* COMMENT_1 */\n/* COMMENT_2 */\n\t\t}\n\t\tbreak;\n\tcase VAR_18:\n\t\tif (VAR_2 == 0 || VAR_3 != 0) {\n\t\t\tVAR_5 = VAR_12;\n\t\t} else {\n\t\t\tVAR_5 = crypto_mac_alloc_ctx(&VAR_6->ctx, VAR_0);\n\t\t\tif (VAR_5 != VAR_11)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase VAR_19:\n\t\tif (VAR_2 != 0 || VAR_3 != 0) {\n\t\t\tVAR_5 = VAR_12;\n\t\t} else {\n\t\t\tVAR_5 = crypto_hash_alloc_ctx(&VAR_6->ctx, VAR_0);\n\t\t\tif (VAR_5 != VAR_11)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase VAR_20:\n\tcase VAR_21:\n\t\tif (VAR_2 == 0 || VAR_3 != 0)\n\t\t\tVAR_5 = VAR_12;\n\t\tbreak;\n\tcase VAR_22:\n\t\tif (VAR_2 == 0 || VAR_3 != 0)\n\t\t\tVAR_5 = VAR_12;\n\t\tbreak;\n\tdefault:\n\t\tVAR_5 = VAR_23;\n\t\tbreak;\n\t}\n\tif (VAR_5 != VAR_11)\n\t\tgoto out;\n\n\tVAR_5 = tee_svc_copy_kaddr_to_uref(VAR_4, VAR_6);\n\tif (VAR_5 != VAR_11)\n\t\tgoto out;\n\n\t/* COMMENT_3 */\n\tif (VAR_8 != NULL) {\n\t\tVAR_8->busy = true;\n\t\tVAR_6->key1 = (vaddr_t)VAR_8;\n\t}\n\tif (VAR_9 != NULL) {\n\t\tVAR_9->busy = true;\n\t\tVAR_6->key2 = (vaddr_t)VAR_9;\n\t}\n\nout:\n\tif (VAR_5 != VAR_11)\n\t\tcryp_state_free(VAR_10, VAR_6);\n\treturn VAR_5;\n}",
  "func_graph_path_before": "Samsung/mTower/c5f30c70e48786e1aef8c815f35e406a6c4fb3ae/tee_svc_cryp.c/vul/before/1.json",
  "func": "TEE_Result utee_cryp_state_alloc(unsigned long algo, unsigned long mode,\n\t\t\tunsigned long key1, unsigned long key2,\n\t\t\tuint32_t *state)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o1 = NULL;\n\tstruct tee_obj *o2 = NULL;\n\tstruct user_ta_ctx *utc;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tutc = to_user_ta_ctx(sess->ctx);\n\n\tif (key1 != 0) {\n\t\tres = tee_obj_get(utc, tee_svc_uref_to_vaddr(key1), &o1);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tif (o1->busy)\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\tres = tee_svc_cryp_check_key_type(o1, algo, mode);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\tif (key2 != 0) {\n\t\tres = tee_obj_get(utc, tee_svc_uref_to_vaddr(key2), &o2);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tif (o2->busy)\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\tres = tee_svc_cryp_check_key_type(o2, algo, mode);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\n\tcs = TEE_Malloc(sizeof(struct tee_cryp_state), TEE_MALLOC_FILL_ZERO);\n\t// cs = calloc(1, sizeof(struct tee_cryp_state));\n\tif (!cs)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tTAILQ_INSERT_TAIL(&utc->cryp_states, cs, link);\n\tcs->algo = algo;\n\tcs->mode = mode;\n\n\tswitch (TEE_ALG_GET_CLASS(algo)) {\n\tcase TEE_OPERATION_CIPHER:\n\t\tif ((algo == TEE_ALG_AES_XTS && (key1 == 0 || key2 == 0)) ||\n\t\t    (algo != TEE_ALG_AES_XTS && (key1 == 0 || key2 != 0))) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t} else {\n\t\t\tres = crypto_cipher_alloc_ctx(&cs->ctx, algo);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase TEE_OPERATION_AE:\n\t\tif (key1 == 0 || key2 != 0) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t} else {\n//\t\t\tres = crypto_authenc_alloc_ctx(&cs->ctx, algo);\n//\t\t\tif (res != TEE_SUCCESS)\n//\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\tif (key1 == 0 || key2 != 0) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t} else {\n\t\t\tres = crypto_mac_alloc_ctx(&cs->ctx, algo);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase TEE_OPERATION_DIGEST:\n\t\tif (key1 != 0 || key2 != 0) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t} else {\n\t\t\tres = crypto_hash_alloc_ctx(&cs->ctx, algo);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase TEE_OPERATION_ASYMMETRIC_CIPHER:\n\tcase TEE_OPERATION_ASYMMETRIC_SIGNATURE:\n\t\tif (key1 == 0 || key2 != 0)\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tbreak;\n\tcase TEE_OPERATION_KEY_DERIVATION:\n\t\tif (key1 == 0 || key2 != 0)\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tbreak;\n\tdefault:\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t\tbreak;\n\t}\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_svc_copy_kaddr_to_uref(state, cs);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\t/* Register keys */\n\tif (o1 != NULL) {\n\t\to1->busy = true;\n\t\tcs->key1 = (vaddr_t)o1;\n\t}\n\tif (o2 != NULL) {\n\t\to2->busy = true;\n\t\tcs->key2 = (vaddr_t)o2;\n\t}\n\nout:\n\tif (res != TEE_SUCCESS)\n\t\tcryp_state_free(utc, cs);\n\treturn res;\n}",
  "abstract_func": "TEE_Result utee_cryp_state_alloc(unsigned long VAR_0, unsigned long VAR_1,\n\t\t\tunsigned long VAR_2, unsigned long VAR_3,\n\t\t\tuint32_t *VAR_4)\n{\n\tTEE_Result VAR_5;\n\tstruct tee_cryp_state *VAR_6;\n\tstruct tee_ta_session *VAR_7;\n\tstruct tee_obj *VAR_8 = NULL;\n\tstruct tee_obj *VAR_9 = NULL;\n\tstruct user_ta_ctx *VAR_10;\n\n\tVAR_5 = tee_ta_get_current_session(&VAR_7);\n\tif (VAR_5 != VAR_11)\n\t\treturn VAR_5;\n\tVAR_10 = to_user_ta_ctx(VAR_7->ctx);\n\n\tif (VAR_2 != 0) {\n\t\tVAR_5 = tee_obj_get(VAR_10, tee_svc_uref_to_vaddr(VAR_2), &VAR_8);\n\t\tif (VAR_5 != VAR_11)\n\t\t\treturn VAR_5;\n\t\tif (VAR_8->busy)\n\t\t\treturn VAR_12;\n\t\tVAR_5 = tee_svc_cryp_check_key_type(VAR_8, VAR_0, VAR_1);\n\t\tif (VAR_5 != VAR_11)\n\t\t\treturn VAR_5;\n\t}\n\tif (VAR_3 != 0) {\n\t\tVAR_5 = tee_obj_get(VAR_10, tee_svc_uref_to_vaddr(VAR_3), &VAR_9);\n\t\tif (VAR_5 != VAR_11)\n\t\t\treturn VAR_5;\n\t\tif (VAR_9->busy)\n\t\t\treturn VAR_12;\n\t\tVAR_5 = tee_svc_cryp_check_key_type(VAR_9, VAR_0, VAR_1);\n\t\tif (VAR_5 != VAR_11)\n\t\t\treturn VAR_5;\n\t}\n\n\tVAR_6 = TEE_Malloc(sizeof(struct tee_cryp_state), VAR_13);\n\t/* COMMENT_0 */\n\tif (!VAR_6)\n\t\treturn VAR_14;\n\tTAILQ_INSERT_TAIL(&VAR_10->cryp_states, VAR_6, VAR_15);\n\tVAR_6->algo = VAR_0;\n\tVAR_6->mode = VAR_1;\n\n\tswitch (TEE_ALG_GET_CLASS(VAR_0)) {\n\tcase VAR_16:\n\t\tif ((VAR_0 == VAR_17 && (VAR_2 == 0 || VAR_3 == 0)) ||\n\t\t    (VAR_0 != VAR_17 && (VAR_2 == 0 || VAR_3 != 0))) {\n\t\t\tVAR_5 = VAR_12;\n\t\t} else {\n\t\t\tVAR_5 = crypto_cipher_alloc_ctx(&VAR_6->ctx, VAR_0);\n\t\t\tif (VAR_5 != VAR_11)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase VAR_18:\n\t\tif (VAR_2 == 0 || VAR_3 != 0) {\n\t\t\tVAR_5 = VAR_12;\n\t\t} else {\n/* COMMENT_1 */\n/* COMMENT_2 */\n/* COMMENT_3 */\n\t\t}\n\t\tbreak;\n\tcase VAR_19:\n\t\tif (VAR_2 == 0 || VAR_3 != 0) {\n\t\t\tVAR_5 = VAR_12;\n\t\t} else {\n\t\t\tVAR_5 = crypto_mac_alloc_ctx(&VAR_6->ctx, VAR_0);\n\t\t\tif (VAR_5 != VAR_11)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase VAR_20:\n\t\tif (VAR_2 != 0 || VAR_3 != 0) {\n\t\t\tVAR_5 = VAR_12;\n\t\t} else {\n\t\t\tVAR_5 = crypto_hash_alloc_ctx(&VAR_6->ctx, VAR_0);\n\t\t\tif (VAR_5 != VAR_11)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase VAR_21:\n\tcase VAR_22:\n\t\tif (VAR_2 == 0 || VAR_3 != 0)\n\t\t\tVAR_5 = VAR_12;\n\t\tbreak;\n\tcase VAR_23:\n\t\tif (VAR_2 == 0 || VAR_3 != 0)\n\t\t\tVAR_5 = VAR_12;\n\t\tbreak;\n\tdefault:\n\t\tVAR_5 = VAR_24;\n\t\tbreak;\n\t}\n\tif (VAR_5 != VAR_11)\n\t\tgoto out;\n\n\tVAR_5 = tee_svc_copy_kaddr_to_uref(VAR_4, VAR_6);\n\tif (VAR_5 != VAR_11)\n\t\tgoto out;\n\n\t/* COMMENT_4 */\n\tif (VAR_8 != NULL) {\n\t\tVAR_8->busy = true;\n\t\tVAR_6->key1 = (vaddr_t)VAR_8;\n\t}\n\tif (VAR_9 != NULL) {\n\t\tVAR_9->busy = true;\n\t\tVAR_6->key2 = (vaddr_t)VAR_9;\n\t}\n\nout:\n\tif (VAR_5 != VAR_11)\n\t\tcryp_state_free(VAR_10, VAR_6);\n\treturn VAR_5;\n}",
  "func_graph_path": "Samsung/mTower/c5f30c70e48786e1aef8c815f35e406a6c4fb3ae/tee_svc_cryp.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -35,7 +35,8 @@\n \t\t\treturn res;\n \t}\n \n-\tcs = calloc(1, sizeof(struct tee_cryp_state));\n+\tcs = TEE_Malloc(sizeof(struct tee_cryp_state), TEE_MALLOC_FILL_ZERO);\n+\t// cs = calloc(1, sizeof(struct tee_cryp_state));\n \tif (!cs)\n \t\treturn TEE_ERROR_OUT_OF_MEMORY;\n \tTAILQ_INSERT_TAIL(&utc->cryp_states, cs, link);",
  "diff_line_info": {
    "deleted_lines": [
      "\tcs = calloc(1, sizeof(struct tee_cryp_state));"
    ],
    "added_lines": [
      "\tcs = TEE_Malloc(sizeof(struct tee_cryp_state), TEE_MALLOC_FILL_ZERO);",
      "\t// cs = calloc(1, sizeof(struct tee_cryp_state));"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/Samsung/mTower/pull/88",
  "description": {
    "pr_info": {
      "title": "Fixed CVE-2022-40761",
      "number": 88
    },
    "comment": [
      "Signed-off-by: Taras Drozdovskyi <t.drozdovsky@samsung.com>\r\n\r\n\r\nFixes #83\r\n\r\n## Type of change\r\n\r\n- [x] Bug fix (non-breaking change which fixes an issue)\r\n\r\n# Checklist:\r\n\r\n- [x] My code follows the style guidelines of this project\r\n- [x] I have performed a self-review of my own code\r\n- [x] I have commented my code, particularly in hard-to-understand areas\r\n- [ ] I have made corresponding changes to the documentation\r\n- [x] My changes generate no new warnings\r\n- [ ] I have added tests that prove my fix is effective or that my feature works\r\n- [x] New and existing unit tests pass locally with my changes\r\n- [ ] Any dependent changes have been merged and published in downstream modules"
    ]
  },
  "Bug Filter": "** Security Vulnerability Fix  \n**Confidence Score:** 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\nThe patch addresses a security vulnerability by changing the memory allocation method to ensure proper zeroing, which prevents potential information leakage. The commit message references a CVE, further confirming the security context.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 0.95"
}