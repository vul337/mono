{
  "cve_id": "CVE-2022-39334",
  "cwe_ids": [
    "CWE-295"
  ],
  "cvss_vector": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:H/A:N",
  "cvss_is_v3": true,
  "repo_name": "nextcloud/desktop",
  "commit_msg": "Command-line client. Do not trust SSL certificates by default, unlss '--trust' option is set.\n\nSigned-off-by: allexzander <blackslayer4@gmail.com>",
  "commit_hash": "49305319496965ecf18963a81bf8a5a69df0d97e",
  "git_url": "https://github.com/nextcloud/desktop/commit/49305319496965ecf18963a81bf8a5a69df0d97e",
  "file_path": "src/cmd/cmd.cpp",
  "func_name": "main",
  "func_before": "int main(int argc, char **argv)\n{\n#ifdef Q_OS_WIN\n    SetDllDirectory(L\"\");\n#endif\n    QCoreApplication app(argc, argv);\n\n#ifdef Q_OS_WIN\n    // Ensure OpenSSL config file is only loaded from app directory\n    QString opensslConf = QCoreApplication::applicationDirPath() + QString(\"/openssl.cnf\");\n    qputenv(\"OPENSSL_CONF\", opensslConf.toLocal8Bit());\n#endif\n\n    CmdOptions options;\n    options.silent = false;\n    options.trustSSL = false;\n    options.useNetrc = false;\n    options.interactive = true;\n    options.ignoreHiddenFiles = false; // Default is to sync hidden files\n    options.restartTimes = 3;\n    options.uplimit = 0;\n    options.downlimit = 0;\n\n    parseOptions(app.arguments(), &options);\n\n    if (options.silent) {\n        qInstallMessageHandler(nullMessageHandler);\n    } else {\n        qSetMessagePattern(\"%{time MM-dd hh:mm:ss:zzz} [ %{type} %{category} ]%{if-debug}\\t[ %{function} ]%{endif}:\\t%{message}\");\n    }\n\n    AccountPtr account = Account::create();\n\n    if (!account) {\n        qFatal(\"Could not initialize account!\");\n        return EXIT_FAILURE;\n    }\n\n    if (options.target_url.contains(\"/webdav\", Qt::CaseInsensitive) || options.target_url.contains(\"/dav\", Qt::CaseInsensitive)) {\n        qWarning(\"Dav or webdav in server URL.\");\n        std::cerr << \"Error! Please specify only the base URL of your host with username and password. Example:\" << std::endl\n                  << \"http(s)://username:password@cloud.example.com\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    QUrl hostUrl = QUrl::fromUserInput((options.target_url.endsWith(QLatin1Char('/')) || options.target_url.endsWith(QLatin1Char('\\\\'))) ? options.target_url.chopped(1) : options.target_url);\n\n    // Order of retrieval attempt (later attempts override earlier ones):\n    // 1. From URL\n    // 2. From options\n    // 3. From netrc (if enabled)\n    // 4. From prompt (if interactive)\n\n    QString user = hostUrl.userName();\n    QString password = hostUrl.password();\n\n    if (!options.user.isEmpty()) {\n        user = options.user;\n    }\n\n    if (!options.password.isEmpty()) {\n        password = options.password;\n    }\n\n    if (options.useNetrc) {\n        NetrcParser parser;\n        if (parser.parse()) {\n            NetrcParser::LoginPair pair = parser.find(hostUrl.host());\n            user = pair.first;\n            password = pair.second;\n        }\n    }\n\n    if (options.interactive) {\n        if (user.isEmpty()) {\n            std::cout << \"Please enter username: \";\n            std::string s;\n            std::getline(std::cin, s);\n            user = QString::fromStdString(s);\n        }\n        if (password.isEmpty()) {\n            password = queryPassword(user);\n        }\n    }\n\n    // Find the folder and the original owncloud url\n\n    hostUrl.setScheme(hostUrl.scheme().replace(\"owncloud\", \"http\"));\n\n    QUrl credentialFreeUrl = hostUrl;\n    credentialFreeUrl.setUserName(QString());\n    credentialFreeUrl.setPassword(QString());\n\n    const QString folder = options.remotePath;\n\n    if (!options.proxy.isNull()) {\n        QString host;\n        int port = 0;\n        bool ok = false;\n\n        QStringList pList = options.proxy.split(':');\n        if (pList.count() == 3) {\n            // http: //192.168.178.23 : 8080\n            //  0            1            2\n            host = pList.at(1);\n            if (host.startsWith(\"//\"))\n                host.remove(0, 2);\n\n            port = pList.at(2).toInt(&ok);\n\n            QNetworkProxyFactory::setUseSystemConfiguration(false);\n            QNetworkProxy::setApplicationProxy(QNetworkProxy(QNetworkProxy::HttpProxy, host, port));\n        } else {\n            qFatal(\"Could not read httpproxy. The proxy should have the format \\\"http://hostname:port\\\".\");\n        }\n    }\n\n    auto *sslErrorHandler = new SimpleSslErrorHandler;\n\n#ifdef TOKEN_AUTH_ONLY\n    auto *cred = new TokenCredentials(user, password, \"\");\n    account->setCredentials(cred);\n#else\n    auto *cred = new HttpCredentialsText(user, password);\n    account->setCredentials(cred);\n    if (options.trustSSL) {\n        cred->setSSLTrusted(true);\n    }\n#endif\n\n    account->setUrl(hostUrl);\n    account->setSslErrorHandler(sslErrorHandler);\n\n    QEventLoop loop;\n    auto *job = new JsonApiJob(account, QLatin1String(\"ocs/v1.php/cloud/capabilities\"));\n    QObject::connect(job, &JsonApiJob::jsonReceived, [&](const QJsonDocument &json) {\n        auto caps = json.object().value(\"ocs\").toObject().value(\"data\").toObject().value(\"capabilities\").toObject();\n        qDebug() << \"Server capabilities\" << caps;\n        account->setCapabilities(caps.toVariantMap());\n        account->setServerVersion(caps[\"core\"].toObject()[\"status\"].toObject()[\"version\"].toString());\n        loop.quit();\n    });\n    job->start();\n    loop.exec();\n\n    if (job->reply()->error() != QNetworkReply::NoError){\n        std::cout<<\"Error connecting to server\\n\";\n        return EXIT_FAILURE;\n    }\n\n    job = new JsonApiJob(account, QLatin1String(\"ocs/v1.php/cloud/user\"));\n    QObject::connect(job, &JsonApiJob::jsonReceived, [&](const QJsonDocument &json) {\n        const QJsonObject data = json.object().value(\"ocs\").toObject().value(\"data\").toObject();\n        account->setDavUser(data.value(\"id\").toString());\n        account->setDavDisplayName(data.value(\"display-name\").toString());\n        loop.quit();\n    });\n    job->start();\n    loop.exec();\n\n    // much lower age than the default since this utility is usually made to be run right after a change in the tests\n    SyncEngine::minimumFileAgeForUpload = std::chrono::milliseconds(0);\n\n    int restartCount = 0;\nrestart_sync:\n\n    opts = &options;\n\n    QStringList selectiveSyncList;\n    if (!options.unsyncedfolders.isEmpty()) {\n        QFile f(options.unsyncedfolders);\n        if (!f.open(QFile::ReadOnly)) {\n            qCritical() << \"Could not open file containing the list of unsynced folders: \" << options.unsyncedfolders;\n        } else {\n            // filter out empty lines and comments\n            selectiveSyncList = QString::fromUtf8(f.readAll()).split('\\n').filter(QRegularExpression(\"\\\\S+\")).filter(QRegularExpression(\"^[^#]\"));\n\n            for (int i = 0; i < selectiveSyncList.count(); ++i) {\n                if (!selectiveSyncList.at(i).endsWith(QLatin1Char('/'))) {\n                    selectiveSyncList[i].append(QLatin1Char('/'));\n                }\n            }\n        }\n    }\n\n    Cmd cmd;\n    QString dbPath = options.source_dir + SyncJournalDb::makeDbName(options.source_dir, credentialFreeUrl, folder, user);\n    SyncJournalDb db(dbPath);\n\n    if (!selectiveSyncList.empty()) {\n        selectiveSyncFixup(&db, selectiveSyncList);\n    }\n\n    SyncOptions opt;\n    opt.fillFromEnvironmentVariables();\n    opt.verifyChunkSizes();\n    SyncEngine engine(account, options.source_dir, opt, folder, &db);\n    engine.setIgnoreHiddenFiles(options.ignoreHiddenFiles);\n    engine.setNetworkLimits(options.uplimit, options.downlimit);\n    QObject::connect(&engine, &SyncEngine::finished,\n        [&app](bool result) { app.exit(result ? EXIT_SUCCESS : EXIT_FAILURE); });\n    QObject::connect(&engine, &SyncEngine::transmissionProgress, &cmd, &Cmd::transmissionProgressSlot);\n    QObject::connect(&engine, &SyncEngine::syncError,\n        [](const QString &error) { qWarning() << \"Sync error:\" << error; });\n\n\n    // Exclude lists\n\n    bool hasUserExcludeFile = !options.exclude.isEmpty();\n    QString systemExcludeFile = ConfigFile::excludeFileFromSystem();\n\n    // Always try to load the user-provided exclude list if one is specified\n    if (hasUserExcludeFile) {\n        engine.excludedFiles().addExcludeFilePath(options.exclude);\n    }\n    // Load the system list if available, or if there's no user-provided list\n    if (!hasUserExcludeFile || QFile::exists(systemExcludeFile)) {\n        engine.excludedFiles().addExcludeFilePath(systemExcludeFile);\n    }\n\n    if (!engine.excludedFiles().reloadExcludeFiles()) {\n        qFatal(\"Cannot load system exclude list or list supplied via --exclude\");\n        return EXIT_FAILURE;\n    }\n\n\n    // Have to be done async, else, an error before exec() does not terminate the event loop.\n    QMetaObject::invokeMethod(&engine, \"startSync\", Qt::QueuedConnection);\n\n    int resultCode = app.exec();\n\n    if (engine.isAnotherSyncNeeded() != NoFollowUpSync) {\n        if (restartCount < options.restartTimes) {\n            restartCount++;\n            qDebug() << \"Restarting Sync, because another sync is needed\" << restartCount;\n            goto restart_sync;\n        }\n        qWarning() << \"Another sync is needed, but not done because restart count is exceeded\" << restartCount;\n    }\n\n    return resultCode;\n}",
  "abstract_func_before": "int main(int VAR_0, char **VAR_1)\n{\n#ifdef VAR_2\n    SetDllDirectory(L\"\");\n#endif\n    QCoreApplication app(argc, argv);\n\n#ifdef VAR_2\n    /* COMMENT_0 */\n    QString VAR_3 = QCoreApplication::applicationDirPath() + QString(\"/openssl.cnf\");\n    qputenv(\"OPENSSL_CONF\", VAR_3.toLocal8Bit());\n#endif\n\n    CmdOptions VAR_4;\n    VAR_4.silent = false;\n    VAR_4.trustSSL = false;\n    VAR_4.useNetrc = false;\n    VAR_4.interactive = true;\n    VAR_4.ignoreHiddenFiles = false; /* COMMENT_1 */\n    VAR_4.restartTimes = 3;\n    VAR_4.uplimit = 0;\n    VAR_4.downlimit = 0;\n\n    parseOptions(VAR_5.arguments(), &VAR_4);\n\n    if (VAR_4.silent) {\n        qInstallMessageHandler(VAR_6);\n    } else {\n        qSetMessagePattern(\"%{time MM-dd hh:mm:ss:zzz} [ %{type} %{category} ]%{if-debug}\\t[ %{function} ]%{endif}:\\t%{message}\");\n    }\n\n    AccountPtr VAR_7 = Account::create();\n\n    if (!VAR_7) {\n        qFatal(\"Could not initialize account!\");\n        return VAR_8;\n    }\n\n    if (VAR_4.target_url.contains(\"/webdav\", Qt::CaseInsensitive) || VAR_4.target_url.contains(\"/dav\", Qt::CaseInsensitive)) {\n        qWarning(\"Dav or webdav in server URL.\");\n        std::cerr << \"Error! Please specify only the base URL of your host with username and password. Example:\" << std::endl\n                  << \"http(s)://username:password@cloud.example.com\" << std::endl;\n        return VAR_8;\n    }\n\n    QUrl VAR_9 = QUrl::fromUserInput((VAR_4.target_url.endsWith(QLatin1Char('/')) || VAR_4.target_url.endsWith(QLatin1Char('\\\\'))) ? VAR_4.target_url.chopped(1) : VAR_4.target_url);\n\n    /* COMMENT_2 */\n    /* COMMENT_3 */\n    /* COMMENT_4 */\n    /* COMMENT_5 */\n    /* COMMENT_6 */\n\n    QString VAR_10 = VAR_9.userName();\n    QString VAR_11 = VAR_9.password();\n\n    if (!VAR_4.user.isEmpty()) {\n        VAR_10 = VAR_4.user;\n    }\n\n    if (!VAR_4.password.isEmpty()) {\n        VAR_11 = VAR_4.password;\n    }\n\n    if (VAR_4.useNetrc) {\n        NetrcParser VAR_12;\n        if (VAR_12.parse()) {\n            NetrcParser::LoginPair VAR_13 = VAR_12.find(VAR_9.host());\n            VAR_10 = VAR_13.first;\n            VAR_11 = VAR_13.second;\n        }\n    }\n\n    if (VAR_4.interactive) {\n        if (VAR_10.isEmpty()) {\n            std::cout << \"Please enter username: \";\n            std::string VAR_14;\n            std::getline(std::cin, VAR_14);\n            VAR_10 = QString::fromStdString(VAR_14);\n        }\n        if (VAR_11.isEmpty()) {\n            VAR_11 = queryPassword(VAR_10);\n        }\n    }\n\n    /* COMMENT_7 */\n\n    VAR_9.setScheme(VAR_9.scheme().replace(\"owncloud\", \"http\"));\n\n    QUrl VAR_15 = VAR_9;\n    VAR_15.setUserName(QString());\n    VAR_15.setPassword(QString());\n\n    const QString VAR_16 = VAR_4.remotePath;\n\n    if (!VAR_4.proxy.isNull()) {\n        QString VAR_17;\n        int VAR_18 = 0;\n        bool VAR_19 = false;\n\n        QStringList VAR_20 = VAR_4.proxy.split(':');\n        if (VAR_20.count() == 3) {\n            /* COMMENT_8 */\n            /* COMMENT_9 */\n            VAR_17 = VAR_20.at(1);\n            if (VAR_17.startsWith(\"//\"))\n                VAR_17.remove(0, 2);\n\n            VAR_18 = VAR_20.at(2).toInt(&VAR_19);\n\n            QNetworkProxyFactory::setUseSystemConfiguration(false);\n            QNetworkProxy::setApplicationProxy(QNetworkProxy(QNetworkProxy::HttpProxy, VAR_17, VAR_18));\n        } else {\n            qFatal(\"Could not read httpproxy. The proxy should have the format \\\"http://hostname:port\\\".\");\n        }\n    }\n\n    auto *VAR_21 = new SimpleSslErrorHandler;\n\n#ifdef VAR_22\n    auto *VAR_23 = new TokenCredentials(VAR_10, VAR_11, \"\");\n    VAR_7->setCredentials(VAR_23);\n#else\n    auto *VAR_23 = new HttpCredentialsText(VAR_10, VAR_11);\n    VAR_7->setCredentials(VAR_23);\n    if (VAR_4.trustSSL) {\n        VAR_23->setSSLTrusted(true);\n    }\n#endif\n\n    VAR_7->setUrl(VAR_9);\n    VAR_7->setSslErrorHandler(VAR_21);\n\n    QEventLoop VAR_24;\n    auto *VAR_25 = new JsonApiJob(VAR_7, QLatin1String(\"ocs/v1.php/cloud/capabilities\"));\n    QObject::connect(VAR_25, &JsonApiJob::jsonReceived, [&](const QJsonDocument &VAR_26) {\n        auto VAR_27 = VAR_26.object().value(\"ocs\").toObject().value(\"data\").toObject().value(\"capabilities\").toObject();\n        qDebug() << \"Server capabilities\" << VAR_27;\n        VAR_7->setCapabilities(VAR_27.toVariantMap());\n        VAR_7->setServerVersion(VAR_27[\"core\"].toObject()[\"status\"].toObject()[\"version\"].toString());\n        VAR_24.quit();\n    });\n    VAR_25->start();\n    VAR_24.exec();\n\n    if (VAR_25->reply()->error() != QNetworkReply::NoError){\n        std::cout<<\"Error connecting to server\\n\";\n        return VAR_8;\n    }\n\n    VAR_25 = new JsonApiJob(VAR_7, QLatin1String(\"ocs/v1.php/cloud/user\"));\n    QObject::connect(VAR_25, &JsonApiJob::jsonReceived, [&](const QJsonDocument &VAR_26) {\n        const QJsonObject VAR_28 = VAR_26.object().value(\"ocs\").toObject().value(\"data\").toObject();\n        VAR_7->setDavUser(VAR_28.value(\"id\").toString());\n        VAR_7->setDavDisplayName(VAR_28.value(\"display-name\").toString());\n        VAR_24.quit();\n    });\n    VAR_25->start();\n    VAR_24.exec();\n\n    /* COMMENT_10 */\n    SyncEngine::minimumFileAgeForUpload = std::chrono::milliseconds(0);\n\n    int VAR_29 = 0;\nrestart_sync:\n\n    VAR_30 = &VAR_4;\n\n    QStringList VAR_31;\n    if (!VAR_4.unsyncedfolders.isEmpty()) {\n        QFile VAR_32(VAR_4.unsyncedfolders);\n        if (!VAR_32.open(QFile::ReadOnly)) {\n            qCritical() << \"Could not open file containing the list of unsynced folders: \" << VAR_4.unsyncedfolders;\n        } else {\n            /* COMMENT_11 */\n            VAR_31 = QString::fromUtf8(VAR_32.readAll()).split('\\n').filter(QRegularExpression(\"\\\\S+\")).filter(QRegularExpression(\"^[^#]\"));\n\n            for (int VAR_33 = 0; VAR_33 < VAR_31.count(); ++VAR_33) {\n                if (!VAR_31.at(VAR_33).endsWith(QLatin1Char('/'))) {\n                    VAR_31[VAR_33].append(QLatin1Char('/'));\n                }\n            }\n        }\n    }\n\n    Cmd VAR_34;\n    QString VAR_35 = VAR_4.source_dir + SyncJournalDb::makeDbName(VAR_4.source_dir, VAR_15, VAR_16, VAR_10);\n    SyncJournalDb db(dbPath);\n\n    if (!VAR_31.empty()) {\n        selectiveSyncFixup(&VAR_36, VAR_31);\n    }\n\n    SyncOptions VAR_37;\n    VAR_37.fillFromEnvironmentVariables();\n    VAR_37.verifyChunkSizes();\n    SyncEngine VAR_38(VAR_7, VAR_4.source_dir, VAR_37, VAR_16, &VAR_36);\n    VAR_38.setIgnoreHiddenFiles(VAR_4.ignoreHiddenFiles);\n    VAR_38.setNetworkLimits(VAR_4.uplimit, VAR_4.downlimit);\n    QObject::connect(&VAR_38, &SyncEngine::finished,\n        [&VAR_5](bool VAR_39) { VAR_5.exit(VAR_39 ? VAR_40 : VAR_8); });\n    QObject::connect(&VAR_38, &SyncEngine::transmissionProgress, &VAR_34, &Cmd::transmissionProgressSlot);\n    QObject::connect(&VAR_38, &SyncEngine::syncError,\n        [](const QString &VAR_41) { qWarning() << \"Sync error:\" << VAR_41; });\n\n\n    /* COMMENT_12 */\n\n    bool VAR_42 = !VAR_4.exclude.isEmpty();\n    QString VAR_43 = ConfigFile::excludeFileFromSystem();\n\n    /* COMMENT_13 */\n    if (VAR_42) {\n        VAR_38.excludedFiles().addExcludeFilePath(VAR_4.exclude);\n    }\n    /* COMMENT_14 */\n    if (!VAR_42 || QFile::exists(VAR_43)) {\n        VAR_38.excludedFiles().addExcludeFilePath(VAR_43);\n    }\n\n    if (!VAR_38.excludedFiles().reloadExcludeFiles()) {\n        qFatal(\"Cannot load system exclude list or list supplied via --exclude\");\n        return VAR_8;\n    }\n\n\n    /* COMMENT_15 */\n    QMetaObject::invokeMethod(&VAR_38, \"startSync\", Qt::QueuedConnection);\n\n    int VAR_44 = VAR_5.exec();\n\n    if (VAR_38.isAnotherSyncNeeded() != VAR_45) {\n        if (VAR_29 < VAR_4.restartTimes) {\n            VAR_29++;\n            qDebug() << \"Restarting Sync, because another sync is needed\" << VAR_29;\n            goto restart_sync;\n        }\n        qWarning() << \"Another sync is needed, but not done because restart count is exceeded\" << VAR_29;\n    }\n\n    return VAR_44;\n}",
  "func_graph_path_before": "nextcloud/desktop/49305319496965ecf18963a81bf8a5a69df0d97e/cmd.cpp/vul/before/0.json",
  "func": "int main(int argc, char **argv)\n{\n#ifdef Q_OS_WIN\n    SetDllDirectory(L\"\");\n#endif\n    QCoreApplication app(argc, argv);\n\n#ifdef Q_OS_WIN\n    // Ensure OpenSSL config file is only loaded from app directory\n    QString opensslConf = QCoreApplication::applicationDirPath() + QString(\"/openssl.cnf\");\n    qputenv(\"OPENSSL_CONF\", opensslConf.toLocal8Bit());\n#endif\n\n    CmdOptions options;\n    options.silent = false;\n    options.trustSSL = false;\n    options.useNetrc = false;\n    options.interactive = true;\n    options.ignoreHiddenFiles = false; // Default is to sync hidden files\n    options.restartTimes = 3;\n    options.uplimit = 0;\n    options.downlimit = 0;\n\n    parseOptions(app.arguments(), &options);\n\n    if (options.silent) {\n        qInstallMessageHandler(nullMessageHandler);\n    } else {\n        qSetMessagePattern(\"%{time MM-dd hh:mm:ss:zzz} [ %{type} %{category} ]%{if-debug}\\t[ %{function} ]%{endif}:\\t%{message}\");\n    }\n\n    AccountPtr account = Account::create();\n\n    if (!account) {\n        qFatal(\"Could not initialize account!\");\n        return EXIT_FAILURE;\n    }\n\n    if (options.target_url.contains(\"/webdav\", Qt::CaseInsensitive) || options.target_url.contains(\"/dav\", Qt::CaseInsensitive)) {\n        qWarning(\"Dav or webdav in server URL.\");\n        std::cerr << \"Error! Please specify only the base URL of your host with username and password. Example:\" << std::endl\n                  << \"http(s)://username:password@cloud.example.com\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    QUrl hostUrl = QUrl::fromUserInput((options.target_url.endsWith(QLatin1Char('/')) || options.target_url.endsWith(QLatin1Char('\\\\'))) ? options.target_url.chopped(1) : options.target_url);\n\n    // Order of retrieval attempt (later attempts override earlier ones):\n    // 1. From URL\n    // 2. From options\n    // 3. From netrc (if enabled)\n    // 4. From prompt (if interactive)\n\n    QString user = hostUrl.userName();\n    QString password = hostUrl.password();\n\n    if (!options.user.isEmpty()) {\n        user = options.user;\n    }\n\n    if (!options.password.isEmpty()) {\n        password = options.password;\n    }\n\n    if (options.useNetrc) {\n        NetrcParser parser;\n        if (parser.parse()) {\n            NetrcParser::LoginPair pair = parser.find(hostUrl.host());\n            user = pair.first;\n            password = pair.second;\n        }\n    }\n\n    if (options.interactive) {\n        if (user.isEmpty()) {\n            std::cout << \"Please enter username: \";\n            std::string s;\n            std::getline(std::cin, s);\n            user = QString::fromStdString(s);\n        }\n        if (password.isEmpty()) {\n            password = queryPassword(user);\n        }\n    }\n\n    // Find the folder and the original owncloud url\n\n    hostUrl.setScheme(hostUrl.scheme().replace(\"owncloud\", \"http\"));\n\n    QUrl credentialFreeUrl = hostUrl;\n    credentialFreeUrl.setUserName(QString());\n    credentialFreeUrl.setPassword(QString());\n\n    const QString folder = options.remotePath;\n\n    if (!options.proxy.isNull()) {\n        QString host;\n        int port = 0;\n        bool ok = false;\n\n        QStringList pList = options.proxy.split(':');\n        if (pList.count() == 3) {\n            // http: //192.168.178.23 : 8080\n            //  0            1            2\n            host = pList.at(1);\n            if (host.startsWith(\"//\"))\n                host.remove(0, 2);\n\n            port = pList.at(2).toInt(&ok);\n\n            QNetworkProxyFactory::setUseSystemConfiguration(false);\n            QNetworkProxy::setApplicationProxy(QNetworkProxy(QNetworkProxy::HttpProxy, host, port));\n        } else {\n            qFatal(\"Could not read httpproxy. The proxy should have the format \\\"http://hostname:port\\\".\");\n        }\n    }\n\n    auto *sslErrorHandler = new SimpleSslErrorHandler;\n\n#ifdef TOKEN_AUTH_ONLY\n    auto *cred = new TokenCredentials(user, password, \"\");\n    account->setCredentials(cred);\n#else\n    auto *cred = new HttpCredentialsText(user, password);\n    account->setCredentials(cred);\n    if (options.trustSSL) {\n        cred->setSSLTrusted(true);\n    }\n#endif\n\n    account->setUrl(hostUrl);\n    account->setSslErrorHandler(sslErrorHandler);\n    account->setTrustCertificates(options.trustSSL);\n\n    QEventLoop loop;\n    auto *job = new JsonApiJob(account, QLatin1String(\"ocs/v1.php/cloud/capabilities\"));\n    QObject::connect(job, &JsonApiJob::jsonReceived, [&](const QJsonDocument &json) {\n        auto caps = json.object().value(\"ocs\").toObject().value(\"data\").toObject().value(\"capabilities\").toObject();\n        qDebug() << \"Server capabilities\" << caps;\n        account->setCapabilities(caps.toVariantMap());\n        account->setServerVersion(caps[\"core\"].toObject()[\"status\"].toObject()[\"version\"].toString());\n        loop.quit();\n    });\n    job->start();\n    loop.exec();\n\n    if (job->reply()->error() != QNetworkReply::NoError){\n        std::cout<<\"Error connecting to server\\n\";\n        return EXIT_FAILURE;\n    }\n\n    job = new JsonApiJob(account, QLatin1String(\"ocs/v1.php/cloud/user\"));\n    QObject::connect(job, &JsonApiJob::jsonReceived, [&](const QJsonDocument &json) {\n        const QJsonObject data = json.object().value(\"ocs\").toObject().value(\"data\").toObject();\n        account->setDavUser(data.value(\"id\").toString());\n        account->setDavDisplayName(data.value(\"display-name\").toString());\n        loop.quit();\n    });\n    job->start();\n    loop.exec();\n\n    // much lower age than the default since this utility is usually made to be run right after a change in the tests\n    SyncEngine::minimumFileAgeForUpload = std::chrono::milliseconds(0);\n\n    int restartCount = 0;\nrestart_sync:\n\n    opts = &options;\n\n    QStringList selectiveSyncList;\n    if (!options.unsyncedfolders.isEmpty()) {\n        QFile f(options.unsyncedfolders);\n        if (!f.open(QFile::ReadOnly)) {\n            qCritical() << \"Could not open file containing the list of unsynced folders: \" << options.unsyncedfolders;\n        } else {\n            // filter out empty lines and comments\n            selectiveSyncList = QString::fromUtf8(f.readAll()).split('\\n').filter(QRegularExpression(\"\\\\S+\")).filter(QRegularExpression(\"^[^#]\"));\n\n            for (int i = 0; i < selectiveSyncList.count(); ++i) {\n                if (!selectiveSyncList.at(i).endsWith(QLatin1Char('/'))) {\n                    selectiveSyncList[i].append(QLatin1Char('/'));\n                }\n            }\n        }\n    }\n\n    Cmd cmd;\n    QString dbPath = options.source_dir + SyncJournalDb::makeDbName(options.source_dir, credentialFreeUrl, folder, user);\n    SyncJournalDb db(dbPath);\n\n    if (!selectiveSyncList.empty()) {\n        selectiveSyncFixup(&db, selectiveSyncList);\n    }\n\n    SyncOptions opt;\n    opt.fillFromEnvironmentVariables();\n    opt.verifyChunkSizes();\n    SyncEngine engine(account, options.source_dir, opt, folder, &db);\n    engine.setIgnoreHiddenFiles(options.ignoreHiddenFiles);\n    engine.setNetworkLimits(options.uplimit, options.downlimit);\n    QObject::connect(&engine, &SyncEngine::finished,\n        [&app](bool result) { app.exit(result ? EXIT_SUCCESS : EXIT_FAILURE); });\n    QObject::connect(&engine, &SyncEngine::transmissionProgress, &cmd, &Cmd::transmissionProgressSlot);\n    QObject::connect(&engine, &SyncEngine::syncError,\n        [](const QString &error) { qWarning() << \"Sync error:\" << error; });\n\n\n    // Exclude lists\n\n    bool hasUserExcludeFile = !options.exclude.isEmpty();\n    QString systemExcludeFile = ConfigFile::excludeFileFromSystem();\n\n    // Always try to load the user-provided exclude list if one is specified\n    if (hasUserExcludeFile) {\n        engine.excludedFiles().addExcludeFilePath(options.exclude);\n    }\n    // Load the system list if available, or if there's no user-provided list\n    if (!hasUserExcludeFile || QFile::exists(systemExcludeFile)) {\n        engine.excludedFiles().addExcludeFilePath(systemExcludeFile);\n    }\n\n    if (!engine.excludedFiles().reloadExcludeFiles()) {\n        qFatal(\"Cannot load system exclude list or list supplied via --exclude\");\n        return EXIT_FAILURE;\n    }\n\n\n    // Have to be done async, else, an error before exec() does not terminate the event loop.\n    QMetaObject::invokeMethod(&engine, \"startSync\", Qt::QueuedConnection);\n\n    int resultCode = app.exec();\n\n    if (engine.isAnotherSyncNeeded() != NoFollowUpSync) {\n        if (restartCount < options.restartTimes) {\n            restartCount++;\n            qDebug() << \"Restarting Sync, because another sync is needed\" << restartCount;\n            goto restart_sync;\n        }\n        qWarning() << \"Another sync is needed, but not done because restart count is exceeded\" << restartCount;\n    }\n\n    return resultCode;\n}",
  "abstract_func": "int main(int VAR_0, char **VAR_1)\n{\n#ifdef VAR_2\n    SetDllDirectory(L\"\");\n#endif\n    QCoreApplication app(argc, argv);\n\n#ifdef VAR_2\n    /* COMMENT_0 */\n    QString VAR_3 = QCoreApplication::applicationDirPath() + QString(\"/openssl.cnf\");\n    qputenv(\"OPENSSL_CONF\", VAR_3.toLocal8Bit());\n#endif\n\n    CmdOptions VAR_4;\n    VAR_4.silent = false;\n    VAR_4.trustSSL = false;\n    VAR_4.useNetrc = false;\n    VAR_4.interactive = true;\n    VAR_4.ignoreHiddenFiles = false; /* COMMENT_1 */\n    VAR_4.restartTimes = 3;\n    VAR_4.uplimit = 0;\n    VAR_4.downlimit = 0;\n\n    parseOptions(VAR_5.arguments(), &VAR_4);\n\n    if (VAR_4.silent) {\n        qInstallMessageHandler(VAR_6);\n    } else {\n        qSetMessagePattern(\"%{time MM-dd hh:mm:ss:zzz} [ %{type} %{category} ]%{if-debug}\\t[ %{function} ]%{endif}:\\t%{message}\");\n    }\n\n    AccountPtr VAR_7 = Account::create();\n\n    if (!VAR_7) {\n        qFatal(\"Could not initialize account!\");\n        return VAR_8;\n    }\n\n    if (VAR_4.target_url.contains(\"/webdav\", Qt::CaseInsensitive) || VAR_4.target_url.contains(\"/dav\", Qt::CaseInsensitive)) {\n        qWarning(\"Dav or webdav in server URL.\");\n        std::cerr << \"Error! Please specify only the base URL of your host with username and password. Example:\" << std::endl\n                  << \"http(s)://username:password@cloud.example.com\" << std::endl;\n        return VAR_8;\n    }\n\n    QUrl VAR_9 = QUrl::fromUserInput((VAR_4.target_url.endsWith(QLatin1Char('/')) || VAR_4.target_url.endsWith(QLatin1Char('\\\\'))) ? VAR_4.target_url.chopped(1) : VAR_4.target_url);\n\n    /* COMMENT_2 */\n    /* COMMENT_3 */\n    /* COMMENT_4 */\n    /* COMMENT_5 */\n    /* COMMENT_6 */\n\n    QString VAR_10 = VAR_9.userName();\n    QString VAR_11 = VAR_9.password();\n\n    if (!VAR_4.user.isEmpty()) {\n        VAR_10 = VAR_4.user;\n    }\n\n    if (!VAR_4.password.isEmpty()) {\n        VAR_11 = VAR_4.password;\n    }\n\n    if (VAR_4.useNetrc) {\n        NetrcParser VAR_12;\n        if (VAR_12.parse()) {\n            NetrcParser::LoginPair VAR_13 = VAR_12.find(VAR_9.host());\n            VAR_10 = VAR_13.first;\n            VAR_11 = VAR_13.second;\n        }\n    }\n\n    if (VAR_4.interactive) {\n        if (VAR_10.isEmpty()) {\n            std::cout << \"Please enter username: \";\n            std::string VAR_14;\n            std::getline(std::cin, VAR_14);\n            VAR_10 = QString::fromStdString(VAR_14);\n        }\n        if (VAR_11.isEmpty()) {\n            VAR_11 = queryPassword(VAR_10);\n        }\n    }\n\n    /* COMMENT_7 */\n\n    VAR_9.setScheme(VAR_9.scheme().replace(\"owncloud\", \"http\"));\n\n    QUrl VAR_15 = VAR_9;\n    VAR_15.setUserName(QString());\n    VAR_15.setPassword(QString());\n\n    const QString VAR_16 = VAR_4.remotePath;\n\n    if (!VAR_4.proxy.isNull()) {\n        QString VAR_17;\n        int VAR_18 = 0;\n        bool VAR_19 = false;\n\n        QStringList VAR_20 = VAR_4.proxy.split(':');\n        if (VAR_20.count() == 3) {\n            /* COMMENT_8 */\n            /* COMMENT_9 */\n            VAR_17 = VAR_20.at(1);\n            if (VAR_17.startsWith(\"//\"))\n                VAR_17.remove(0, 2);\n\n            VAR_18 = VAR_20.at(2).toInt(&VAR_19);\n\n            QNetworkProxyFactory::setUseSystemConfiguration(false);\n            QNetworkProxy::setApplicationProxy(QNetworkProxy(QNetworkProxy::HttpProxy, VAR_17, VAR_18));\n        } else {\n            qFatal(\"Could not read httpproxy. The proxy should have the format \\\"http://hostname:port\\\".\");\n        }\n    }\n\n    auto *VAR_21 = new SimpleSslErrorHandler;\n\n#ifdef VAR_22\n    auto *VAR_23 = new TokenCredentials(VAR_10, VAR_11, \"\");\n    VAR_7->setCredentials(VAR_23);\n#else\n    auto *VAR_23 = new HttpCredentialsText(VAR_10, VAR_11);\n    VAR_7->setCredentials(VAR_23);\n    if (VAR_4.trustSSL) {\n        VAR_23->setSSLTrusted(true);\n    }\n#endif\n\n    VAR_7->setUrl(VAR_9);\n    VAR_7->setSslErrorHandler(VAR_21);\n    VAR_7->setTrustCertificates(VAR_4.trustSSL);\n\n    QEventLoop VAR_24;\n    auto *VAR_25 = new JsonApiJob(VAR_7, QLatin1String(\"ocs/v1.php/cloud/capabilities\"));\n    QObject::connect(VAR_25, &JsonApiJob::jsonReceived, [&](const QJsonDocument &VAR_26) {\n        auto VAR_27 = VAR_26.object().value(\"ocs\").toObject().value(\"data\").toObject().value(\"capabilities\").toObject();\n        qDebug() << \"Server capabilities\" << VAR_27;\n        VAR_7->setCapabilities(VAR_27.toVariantMap());\n        VAR_7->setServerVersion(VAR_27[\"core\"].toObject()[\"status\"].toObject()[\"version\"].toString());\n        VAR_24.quit();\n    });\n    VAR_25->start();\n    VAR_24.exec();\n\n    if (VAR_25->reply()->error() != QNetworkReply::NoError){\n        std::cout<<\"Error connecting to server\\n\";\n        return VAR_8;\n    }\n\n    VAR_25 = new JsonApiJob(VAR_7, QLatin1String(\"ocs/v1.php/cloud/user\"));\n    QObject::connect(VAR_25, &JsonApiJob::jsonReceived, [&](const QJsonDocument &VAR_26) {\n        const QJsonObject VAR_28 = VAR_26.object().value(\"ocs\").toObject().value(\"data\").toObject();\n        VAR_7->setDavUser(VAR_28.value(\"id\").toString());\n        VAR_7->setDavDisplayName(VAR_28.value(\"display-name\").toString());\n        VAR_24.quit();\n    });\n    VAR_25->start();\n    VAR_24.exec();\n\n    /* COMMENT_10 */\n    SyncEngine::minimumFileAgeForUpload = std::chrono::milliseconds(0);\n\n    int VAR_29 = 0;\nrestart_sync:\n\n    VAR_30 = &VAR_4;\n\n    QStringList VAR_31;\n    if (!VAR_4.unsyncedfolders.isEmpty()) {\n        QFile VAR_32(VAR_4.unsyncedfolders);\n        if (!VAR_32.open(QFile::ReadOnly)) {\n            qCritical() << \"Could not open file containing the list of unsynced folders: \" << VAR_4.unsyncedfolders;\n        } else {\n            /* COMMENT_11 */\n            VAR_31 = QString::fromUtf8(VAR_32.readAll()).split('\\n').filter(QRegularExpression(\"\\\\S+\")).filter(QRegularExpression(\"^[^#]\"));\n\n            for (int VAR_33 = 0; VAR_33 < VAR_31.count(); ++VAR_33) {\n                if (!VAR_31.at(VAR_33).endsWith(QLatin1Char('/'))) {\n                    VAR_31[VAR_33].append(QLatin1Char('/'));\n                }\n            }\n        }\n    }\n\n    Cmd VAR_34;\n    QString VAR_35 = VAR_4.source_dir + SyncJournalDb::makeDbName(VAR_4.source_dir, VAR_15, VAR_16, VAR_10);\n    SyncJournalDb db(dbPath);\n\n    if (!VAR_31.empty()) {\n        selectiveSyncFixup(&VAR_36, VAR_31);\n    }\n\n    SyncOptions VAR_37;\n    VAR_37.fillFromEnvironmentVariables();\n    VAR_37.verifyChunkSizes();\n    SyncEngine VAR_38(VAR_7, VAR_4.source_dir, VAR_37, VAR_16, &VAR_36);\n    VAR_38.setIgnoreHiddenFiles(VAR_4.ignoreHiddenFiles);\n    VAR_38.setNetworkLimits(VAR_4.uplimit, VAR_4.downlimit);\n    QObject::connect(&VAR_38, &SyncEngine::finished,\n        [&VAR_5](bool VAR_39) { VAR_5.exit(VAR_39 ? VAR_40 : VAR_8); });\n    QObject::connect(&VAR_38, &SyncEngine::transmissionProgress, &VAR_34, &Cmd::transmissionProgressSlot);\n    QObject::connect(&VAR_38, &SyncEngine::syncError,\n        [](const QString &VAR_41) { qWarning() << \"Sync error:\" << VAR_41; });\n\n\n    /* COMMENT_12 */\n\n    bool VAR_42 = !VAR_4.exclude.isEmpty();\n    QString VAR_43 = ConfigFile::excludeFileFromSystem();\n\n    /* COMMENT_13 */\n    if (VAR_42) {\n        VAR_38.excludedFiles().addExcludeFilePath(VAR_4.exclude);\n    }\n    /* COMMENT_14 */\n    if (!VAR_42 || QFile::exists(VAR_43)) {\n        VAR_38.excludedFiles().addExcludeFilePath(VAR_43);\n    }\n\n    if (!VAR_38.excludedFiles().reloadExcludeFiles()) {\n        qFatal(\"Cannot load system exclude list or list supplied via --exclude\");\n        return VAR_8;\n    }\n\n\n    /* COMMENT_15 */\n    QMetaObject::invokeMethod(&VAR_38, \"startSync\", Qt::QueuedConnection);\n\n    int VAR_44 = VAR_5.exec();\n\n    if (VAR_38.isAnotherSyncNeeded() != VAR_45) {\n        if (VAR_29 < VAR_4.restartTimes) {\n            VAR_29++;\n            qDebug() << \"Restarting Sync, because another sync is needed\" << VAR_29;\n            goto restart_sync;\n        }\n        qWarning() << \"Another sync is needed, but not done because restart count is exceeded\" << VAR_29;\n    }\n\n    return VAR_44;\n}",
  "func_graph_path": "nextcloud/desktop/49305319496965ecf18963a81bf8a5a69df0d97e/cmd.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -130,6 +130,7 @@\n \n     account->setUrl(hostUrl);\n     account->setSslErrorHandler(sslErrorHandler);\n+    account->setTrustCertificates(options.trustSSL);\n \n     QEventLoop loop;\n     auto *job = new JsonApiJob(account, QLatin1String(\"ocs/v1.php/cloud/capabilities\"));",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "    account->setTrustCertificates(options.trustSSL);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/nextcloud/desktop/pull/5022",
  "description": {
    "pr_info": {
      "title": "Command-line client. Do not trust SSL certificates by default, unless '--trust' option is set.",
      "number": 5022
    },
    "comment": [
      "Signed-off-by: allexzander <blackslayer4@gmail.com>\r\n<!-- \r\nThanks for opening a pull request on the Nextcloud desktop client.\r\n\r\nInstead of a Contributor License Agreement (CLA) we use a Developer Certificate of Origin (DCO).\r\nhttps://en.wikipedia.org/wiki/Developer_Certificate_of_Origin\r\n\r\nTo accept that DCO, please make sure that you add a line like\r\nSigned-off-by: Random Developer <random@developer.example.org>\r\nat the end of each commit message.\r\n\r\nThis Signed-off-by trailer can be added automatically by git if you pass --signoff or -s to git commit.\r\nSee also:\r\nhttps://git-scm.com/docs/git-commit#Documentation/git-commit.txt---no-signoff\r\n-->",
      "# [Codecov](https://codecov.io/gh/nextcloud/desktop/pull/5022?src=pr&el=h1&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=nextcloud) Report\n> Merging [#5022](https://codecov.io/gh/nextcloud/desktop/pull/5022?src=pr&el=desc&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=nextcloud) (e721f93) into [master](https://codecov.io/gh/nextcloud/desktop/commit/256aa522020610d41d7fd2e1b6f7a604b42f4fcc?el=desc&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=nextcloud) (256aa52) will **decrease** coverage by `0.12%`.\n> The diff coverage is `14.28%`.\n\n> :exclamation: Current head e721f93 differs from pull request most recent head 564a3ad. Consider uploading reports for the commit 564a3ad to get more accurate results\n\n<details><summary>Additional details and impacted files</summary>\n\n\n```diff\n@@            Coverage Diff             @@\n##           master    #5022      +/-   ##\n==========================================\n- Coverage   57.28%   57.16%   -0.13%     \n==========================================\n  Files         138      138              \n  Lines       17394    17401       +7     \n==========================================\n- Hits         9965     9947      -18     \n- Misses       7429     7454      +25     \n```\n\n\n\n| [Impacted Files](https://codecov.io/gh/nextcloud/desktop/pull/5022?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=nextcloud) | Coverage Δ | |\n|---|---|---|\n| [src/libsync/account.cpp](https://codecov.io/gh/nextcloud/desktop/pull/5022/diff?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=nextcloud#diff-c3JjL2xpYnN5bmMvYWNjb3VudC5jcHA=) | `38.00% <0.00%> (-0.47%)` | :arrow_down: |\n| [src/libsync/account.h](https://codecov.io/gh/nextcloud/desktop/pull/5022/diff?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=nextcloud#diff-c3JjL2xpYnN5bmMvYWNjb3VudC5o) | `33.33% <100.00%> (+3.92%)` | :arrow_up: |\n| [src/libsync/vfs/cfapi/hydrationjob.cpp](https://codecov.io/gh/nextcloud/desktop/pull/5022/diff?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=nextcloud#diff-c3JjL2xpYnN5bmMvdmZzL2NmYXBpL2h5ZHJhdGlvbmpvYi5jcHA=) | `52.38% <0.00%> (-3.71%)` | :arrow_down: |\n| [src/libsync/filesystem.cpp](https://codecov.io/gh/nextcloud/desktop/pull/5022/diff?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=nextcloud#diff-c3JjL2xpYnN5bmMvZmlsZXN5c3RlbS5jcHA=) | `73.11% <0.00%> (-3.23%)` | :arrow_down: |\n| [src/libsync/vfs/cfapi/vfs\\_cfapi.cpp](https://codecov.io/gh/nextcloud/desktop/pull/5022/diff?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=nextcloud#diff-c3JjL2xpYnN5bmMvdmZzL2NmYXBpL3Zmc19jZmFwaS5jcHA=) | `83.39% <0.00%> (-2.38%)` | :arrow_down: |\n| [src/libsync/vfs/cfapi/cfapiwrapper.cpp](https://codecov.io/gh/nextcloud/desktop/pull/5022/diff?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=nextcloud#diff-c3JjL2xpYnN5bmMvdmZzL2NmYXBpL2NmYXBpd3JhcHBlci5jcHA=) | `72.50% <0.00%> (-1.82%)` | :arrow_down: |\n| [src/libsync/syncengine.cpp](https://codecov.io/gh/nextcloud/desktop/pull/5022/diff?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=nextcloud#diff-c3JjL2xpYnN5bmMvc3luY2VuZ2luZS5jcHA=) | `82.88% <0.00%> (-0.46%)` | :arrow_down: |\n| [src/libsync/propagatedownload.cpp](https://codecov.io/gh/nextcloud/desktop/pull/5022/diff?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=nextcloud#diff-c3JjL2xpYnN5bmMvcHJvcGFnYXRlZG93bmxvYWQuY3Bw) | `64.61% <0.00%> (+1.17%)` | :arrow_up: |\n\n</details>",
      "@claucambra I had to fix a small logic error and re-request a review. It does not really affect much but it's best to keep it right.",
      "AppImage file: [nextcloud-PR-5022-564a3ad987a40135c9d6dedd5a1238caf0ce2d52-x86_64.AppImage](https://github.com/nextcloud-desktop-bot/ci-builds/releases/download/PR-5022/nextcloud-PR-5022-564a3ad987a40135c9d6dedd5a1238caf0ce2d52-x86_64.AppImage) <br/><br/>To test this change/fix you can simply download above AppImage file and test it. <br/><br/>Please make sure to quit your existing Nextcloud app and backup your data. ",
      "SonarCloud Quality Gate failed.&nbsp; &nbsp; [![Quality Gate failed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/failed-16px.png 'Quality Gate failed')](https://sonarcloud.io/dashboard?id=nextcloud_desktop&pullRequest=5022)\n\n[![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=nextcloud_desktop&pullRequest=5022&resolved=false&types=BUG) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=nextcloud_desktop&pullRequest=5022&resolved=false&types=BUG) [0 Bugs](https://sonarcloud.io/project/issues?id=nextcloud_desktop&pullRequest=5022&resolved=false&types=BUG)  \n[![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=nextcloud_desktop&pullRequest=5022&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=nextcloud_desktop&pullRequest=5022&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=nextcloud_desktop&pullRequest=5022&resolved=false&types=VULNERABILITY)  \n[![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=nextcloud_desktop&pullRequest=5022&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=nextcloud_desktop&pullRequest=5022&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=nextcloud_desktop&pullRequest=5022&resolved=false&types=SECURITY_HOTSPOT)  \n[![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=nextcloud_desktop&pullRequest=5022&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=nextcloud_desktop&pullRequest=5022&resolved=false&types=CODE_SMELL) [2 Code Smells](https://sonarcloud.io/project/issues?id=nextcloud_desktop&pullRequest=5022&resolved=false&types=CODE_SMELL)\n\n[![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=nextcloud_desktop&pullRequest=5022&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=nextcloud_desktop&pullRequest=5022&metric=new_coverage&view=list)  \n[![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=nextcloud_desktop&pullRequest=5022&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=nextcloud_desktop&pullRequest=5022&metric=new_duplicated_lines_density&view=list)\n\n",
      "/backport to stable-3.6"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix\n\nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch modifies the SSL certificate handling by defaulting to not trusting certificates unless the '--trust' option is set. This addresses a security concern by preventing potential man-in-the-middle attacks.\n\nFinal Classification: Security Vulnerability Fix\n\nConfidence Score: 0.95"
}