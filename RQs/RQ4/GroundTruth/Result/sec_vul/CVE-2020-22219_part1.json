{
  "cve_id": "CVE-2020-22219",
  "cwe_ids": [
    "CWE-120"
  ],
  "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
  "cvss_is_v3": true,
  "repo_name": "xiph/flac",
  "commit_msg": "Add checks that supplied samples are bounded within bits-per-sample\n\nCredit: Oss-Fuzz\nIssue: https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=19758\nIssue: https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=31727",
  "commit_hash": "5a79fb5ce99b4fb7ba01b4ea85a0e5911e82b243",
  "git_url": "https://github.com/xiph/flac/commit/5a79fb5ce99b4fb7ba01b4ea85a0e5911e82b243",
  "file_path": "src/libFLAC/stream_encoder.c",
  "func_name": "FLAC__stream_encoder_process_interleaved",
  "func_before": "FLAC_API FLAC__bool FLAC__stream_encoder_process_interleaved(FLAC__StreamEncoder *encoder, const FLAC__int32 buffer[], uint32_t samples)\n{\n\tuint32_t i, j, k, channel;\n\tFLAC__int32 x, mid, side;\n\tconst uint32_t channels = encoder->protected_->channels, blocksize = encoder->protected_->blocksize;\n\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\tFLAC__ASSERT(encoder->protected_->state == FLAC__STREAM_ENCODER_OK);\n\n\tj = k = 0;\n\t/*\n\t * we have several flavors of the same basic loop, optimized for\n\t * different conditions:\n\t */\n\tif(encoder->protected_->do_mid_side_stereo && channels == 2) {\n\t\t/*\n\t\t * stereo coding: unroll channel loop\n\t\t */\n\t\tdo {\n\t\t\tif(encoder->protected_->verify)\n\t\t\t\tappend_to_verify_fifo_interleaved_(&encoder->private_->verify.input_fifo, buffer, j, channels, flac_min(blocksize+OVERREAD_-encoder->private_->current_sample_number, samples-j));\n\n\t\t\t/* \"i <= blocksize\" to overread 1 sample; see comment in OVERREAD_ decl */\n\t\t\tfor(i = encoder->private_->current_sample_number; i <= blocksize && j < samples; i++, j++) {\n\t\t\t\tencoder->private_->integer_signal[0][i] = mid = side = buffer[k++];\n\t\t\t\tx = buffer[k++];\n\t\t\t\tencoder->private_->integer_signal[1][i] = x;\n\t\t\t\tmid += x;\n\t\t\t\tside -= x;\n\t\t\t\tmid >>= 1; /* NOTE: not the same as 'mid = (left + right) / 2' ! */\n\t\t\t\tencoder->private_->integer_signal_mid_side[1][i] = side;\n\t\t\t\tencoder->private_->integer_signal_mid_side[0][i] = mid;\n\t\t\t}\n\t\t\tencoder->private_->current_sample_number = i;\n\t\t\t/* we only process if we have a full block + 1 extra sample; final block is always handled by FLAC__stream_encoder_finish() */\n\t\t\tif(i > blocksize) {\n\t\t\t\tif(!process_frame_(encoder, /*is_fractional_block=*/false, /*is_last_block=*/false))\n\t\t\t\t\treturn false;\n\t\t\t\t/* move unprocessed overread samples to beginnings of arrays */\n\t\t\t\tFLAC__ASSERT(i == blocksize+OVERREAD_);\n\t\t\t\tFLAC__ASSERT(OVERREAD_ == 1); /* assert we only overread 1 sample which simplifies the rest of the code below */\n\t\t\t\tencoder->private_->integer_signal[0][0] = encoder->private_->integer_signal[0][blocksize];\n\t\t\t\tencoder->private_->integer_signal[1][0] = encoder->private_->integer_signal[1][blocksize];\n\t\t\t\tencoder->private_->integer_signal_mid_side[0][0] = encoder->private_->integer_signal_mid_side[0][blocksize];\n\t\t\t\tencoder->private_->integer_signal_mid_side[1][0] = encoder->private_->integer_signal_mid_side[1][blocksize];\n\t\t\t\tencoder->private_->current_sample_number = 1;\n\t\t\t}\n\t\t} while(j < samples);\n\t}\n\telse {\n\t\t/*\n\t\t * independent channel coding: buffer each channel in inner loop\n\t\t */\n\t\tdo {\n\t\t\tif(encoder->protected_->verify)\n\t\t\t\tappend_to_verify_fifo_interleaved_(&encoder->private_->verify.input_fifo, buffer, j, channels, flac_min(blocksize+OVERREAD_-encoder->private_->current_sample_number, samples-j));\n\n\t\t\t/* \"i <= blocksize\" to overread 1 sample; see comment in OVERREAD_ decl */\n\t\t\tfor(i = encoder->private_->current_sample_number; i <= blocksize && j < samples; i++, j++) {\n\t\t\t\tfor(channel = 0; channel < channels; channel++)\n\t\t\t\t\tencoder->private_->integer_signal[channel][i] = buffer[k++];\n\t\t\t}\n\t\t\tencoder->private_->current_sample_number = i;\n\t\t\t/* we only process if we have a full block + 1 extra sample; final block is always handled by FLAC__stream_encoder_finish() */\n\t\t\tif(i > blocksize) {\n\t\t\t\tif(!process_frame_(encoder, /*is_fractional_block=*/false, /*is_last_block=*/false))\n\t\t\t\t\treturn false;\n\t\t\t\t/* move unprocessed overread samples to beginnings of arrays */\n\t\t\t\tFLAC__ASSERT(i == blocksize+OVERREAD_);\n\t\t\t\tFLAC__ASSERT(OVERREAD_ == 1); /* assert we only overread 1 sample which simplifies the rest of the code below */\n\t\t\t\tfor(channel = 0; channel < channels; channel++)\n\t\t\t\t\tencoder->private_->integer_signal[channel][0] = encoder->private_->integer_signal[channel][blocksize];\n\t\t\t\tencoder->private_->current_sample_number = 1;\n\t\t\t}\n\t\t} while(j < samples);\n\t}\n\n\treturn true;\n}",
  "abstract_func_before": "FLAC_API VAR_0 FLAC__stream_encoder_process_interleaved(FLAC__StreamEncoder *VAR_1, const FLAC__int32 VAR_2[], uint32_t VAR_3)\n{\n\tuint32_t VAR_4, VAR_5, VAR_6, VAR_7;\n\tFLAC__int32 VAR_8, VAR_9, VAR_10;\n\tconst uint32_t VAR_11 = VAR_1->protected_->channels, VAR_12 = VAR_1->protected_->blocksize;\n\n\tFLAC__ASSERT(0 != VAR_1);\n\tFLAC__ASSERT(0 != VAR_1->private_);\n\tFLAC__ASSERT(0 != VAR_1->protected_);\n\tFLAC__ASSERT(VAR_1->protected_->state == VAR_13);\n\n\tVAR_5 = VAR_6 = 0;\n\t/* COMMENT_0 */\n                                                                 \n                         \n    \n\tif(VAR_1->protected_->do_mid_side_stereo && VAR_11 == 2) {\n\t\t/* COMMENT_4 */\n                                       \n     \n\t\tdo {\n\t\t\tif(VAR_1->protected_->verify)\n\t\t\t\tappend_to_verify_fifo_interleaved_(&VAR_1->private_->verify.input_fifo, VAR_2, VAR_5, VAR_11, flac_min(VAR_12+VAR_14-VAR_1->private_->current_sample_number, VAR_3-VAR_5));\n\n\t\t\t/* COMMENT_7 */\n\t\t\tfor(VAR_4 = VAR_1->private_->current_sample_number; VAR_4 <= VAR_12 && VAR_5 < VAR_3; VAR_4++, VAR_5++) {\n\t\t\t\tVAR_1->private_->integer_signal[0][VAR_4] = VAR_9 = VAR_10 = VAR_2[VAR_6++];\n\t\t\t\tVAR_8 = VAR_2[VAR_6++];\n\t\t\t\tVAR_1->private_->integer_signal[1][VAR_4] = VAR_8;\n\t\t\t\tVAR_9 += VAR_8;\n\t\t\t\tVAR_10 -= VAR_8;\n\t\t\t\tVAR_9 >>= 1; /* COMMENT_8 */\n\t\t\t\tVAR_1->private_->integer_signal_mid_side[1][VAR_4] = VAR_10;\n\t\t\t\tVAR_1->private_->integer_signal_mid_side[0][VAR_4] = VAR_9;\n\t\t\t}\n\t\t\tVAR_1->private_->current_sample_number = VAR_4;\n\t\t\t/* COMMENT_9 */\n\t\t\tif(VAR_4 > VAR_12) {\n\t\t\t\tif(!process_frame_(VAR_1, /* COMMENT_10 */false, /* COMMENT_11 */false))\n\t\t\t\t\treturn false;\n\t\t\t\t/* COMMENT_12 */\n\t\t\t\tFLAC__ASSERT(VAR_4 == VAR_12+VAR_14);\n\t\t\t\tFLAC__ASSERT(VAR_14 == 1); /* COMMENT_13 */\n\t\t\t\tVAR_1->private_->integer_signal[0][0] = VAR_1->private_->integer_signal[0][VAR_12];\n\t\t\t\tVAR_1->private_->integer_signal[1][0] = VAR_1->private_->integer_signal[1][VAR_12];\n\t\t\t\tVAR_1->private_->integer_signal_mid_side[0][0] = VAR_1->private_->integer_signal_mid_side[0][VAR_12];\n\t\t\t\tVAR_1->private_->integer_signal_mid_side[1][0] = VAR_1->private_->integer_signal_mid_side[1][VAR_12];\n\t\t\t\tVAR_1->private_->current_sample_number = 1;\n\t\t\t}\n\t\t} while(VAR_5 < VAR_3);\n\t}\n\telse {\n\t\t/* COMMENT_14 */\n                                                                  \n     \n\t\tdo {\n\t\t\tif(VAR_1->protected_->verify)\n\t\t\t\tappend_to_verify_fifo_interleaved_(&VAR_1->private_->verify.input_fifo, VAR_2, VAR_5, VAR_11, flac_min(VAR_12+VAR_14-VAR_1->private_->current_sample_number, VAR_3-VAR_5));\n\n\t\t\t/* COMMENT_7 */\n\t\t\tfor(VAR_4 = VAR_1->private_->current_sample_number; VAR_4 <= VAR_12 && VAR_5 < VAR_3; VAR_4++, VAR_5++) {\n\t\t\t\tfor(VAR_7 = 0; VAR_7 < VAR_11; VAR_7++)\n\t\t\t\t\tVAR_1->private_->integer_signal[VAR_7][VAR_4] = VAR_2[VAR_6++];\n\t\t\t}\n\t\t\tVAR_1->private_->current_sample_number = VAR_4;\n\t\t\t/* COMMENT_9 */\n\t\t\tif(VAR_4 > VAR_12) {\n\t\t\t\tif(!process_frame_(VAR_1, /* COMMENT_10 */false, /* COMMENT_11 */false))\n\t\t\t\t\treturn false;\n\t\t\t\t/* COMMENT_12 */\n\t\t\t\tFLAC__ASSERT(VAR_4 == VAR_12+VAR_14);\n\t\t\t\tFLAC__ASSERT(VAR_14 == 1); /* COMMENT_13 */\n\t\t\t\tfor(VAR_7 = 0; VAR_7 < VAR_11; VAR_7++)\n\t\t\t\t\tVAR_1->private_->integer_signal[VAR_7][0] = VAR_1->private_->integer_signal[VAR_7][VAR_12];\n\t\t\t\tVAR_1->private_->current_sample_number = 1;\n\t\t\t}\n\t\t} while(VAR_5 < VAR_3);\n\t}\n\n\treturn true;\n}",
  "func_graph_path_before": null,
  "func": "FLAC_API FLAC__bool FLAC__stream_encoder_process_interleaved(FLAC__StreamEncoder *encoder, const FLAC__int32 buffer[], uint32_t samples)\n{\n\tuint32_t i, j, k, channel;\n\tFLAC__int32 x, mid, side;\n\tconst uint32_t channels = encoder->protected_->channels, blocksize = encoder->protected_->blocksize;\n\tconst FLAC__int32 sample_max = INT32_MAX >> (32 - encoder->protected_->bits_per_sample);\n\tconst FLAC__int32 sample_min = INT32_MIN >> (32 - encoder->protected_->bits_per_sample);\n\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\tFLAC__ASSERT(encoder->protected_->state == FLAC__STREAM_ENCODER_OK);\n\n\tj = k = 0;\n\t/*\n\t * we have several flavors of the same basic loop, optimized for\n\t * different conditions:\n\t */\n\tif(encoder->protected_->do_mid_side_stereo && channels == 2) {\n\t\t/*\n\t\t * stereo coding: unroll channel loop\n\t\t */\n\t\tdo {\n\t\t\tif(encoder->protected_->verify)\n\t\t\t\tappend_to_verify_fifo_interleaved_(&encoder->private_->verify.input_fifo, buffer, j, channels, flac_min(blocksize+OVERREAD_-encoder->private_->current_sample_number, samples-j));\n\n\t\t\t/* \"i <= blocksize\" to overread 1 sample; see comment in OVERREAD_ decl */\n\t\t\tfor(i = encoder->private_->current_sample_number; i <= blocksize && j < samples; i++, j++) {\n\t\t\t\tif(buffer[k]   < sample_min || buffer[k]   > sample_max ||\n\t\t\t\t   buffer[k+1] < sample_min || buffer[k+1] > sample_max){\n\t\t\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tencoder->private_->integer_signal[0][i] = mid = side = buffer[k++];\n\t\t\t\tx = buffer[k++];\n\t\t\t\tencoder->private_->integer_signal[1][i] = x;\n\t\t\t\tmid += x;\n\t\t\t\tside -= x;\n\t\t\t\tmid >>= 1; /* NOTE: not the same as 'mid = (left + right) / 2' ! */\n\t\t\t\tencoder->private_->integer_signal_mid_side[1][i] = side;\n\t\t\t\tencoder->private_->integer_signal_mid_side[0][i] = mid;\n\t\t\t}\n\t\t\tencoder->private_->current_sample_number = i;\n\t\t\t/* we only process if we have a full block + 1 extra sample; final block is always handled by FLAC__stream_encoder_finish() */\n\t\t\tif(i > blocksize) {\n\t\t\t\tif(!process_frame_(encoder, /*is_fractional_block=*/false, /*is_last_block=*/false))\n\t\t\t\t\treturn false;\n\t\t\t\t/* move unprocessed overread samples to beginnings of arrays */\n\t\t\t\tFLAC__ASSERT(i == blocksize+OVERREAD_);\n\t\t\t\tFLAC__ASSERT(OVERREAD_ == 1); /* assert we only overread 1 sample which simplifies the rest of the code below */\n\t\t\t\tencoder->private_->integer_signal[0][0] = encoder->private_->integer_signal[0][blocksize];\n\t\t\t\tencoder->private_->integer_signal[1][0] = encoder->private_->integer_signal[1][blocksize];\n\t\t\t\tencoder->private_->integer_signal_mid_side[0][0] = encoder->private_->integer_signal_mid_side[0][blocksize];\n\t\t\t\tencoder->private_->integer_signal_mid_side[1][0] = encoder->private_->integer_signal_mid_side[1][blocksize];\n\t\t\t\tencoder->private_->current_sample_number = 1;\n\t\t\t}\n\t\t} while(j < samples);\n\t}\n\telse {\n\t\t/*\n\t\t * independent channel coding: buffer each channel in inner loop\n\t\t */\n\t\tdo {\n\t\t\tif(encoder->protected_->verify)\n\t\t\t\tappend_to_verify_fifo_interleaved_(&encoder->private_->verify.input_fifo, buffer, j, channels, flac_min(blocksize+OVERREAD_-encoder->private_->current_sample_number, samples-j));\n\n\t\t\t/* \"i <= blocksize\" to overread 1 sample; see comment in OVERREAD_ decl */\n\t\t\tfor(i = encoder->private_->current_sample_number; i <= blocksize && j < samples; i++, j++) {\n\t\t\t\tfor(channel = 0; channel < channels; channel++){\n\t\t\t\t\tif(buffer[k] < sample_min || buffer[k] > sample_max){\n\t\t\t\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tencoder->private_->integer_signal[channel][i] = buffer[k++];\n\t\t\t\t}\n\t\t\t}\n\t\t\tencoder->private_->current_sample_number = i;\n\t\t\t/* we only process if we have a full block + 1 extra sample; final block is always handled by FLAC__stream_encoder_finish() */\n\t\t\tif(i > blocksize) {\n\t\t\t\tif(!process_frame_(encoder, /*is_fractional_block=*/false, /*is_last_block=*/false))\n\t\t\t\t\treturn false;\n\t\t\t\t/* move unprocessed overread samples to beginnings of arrays */\n\t\t\t\tFLAC__ASSERT(i == blocksize+OVERREAD_);\n\t\t\t\tFLAC__ASSERT(OVERREAD_ == 1); /* assert we only overread 1 sample which simplifies the rest of the code below */\n\t\t\t\tfor(channel = 0; channel < channels; channel++)\n\t\t\t\t\tencoder->private_->integer_signal[channel][0] = encoder->private_->integer_signal[channel][blocksize];\n\t\t\t\tencoder->private_->current_sample_number = 1;\n\t\t\t}\n\t\t} while(j < samples);\n\t}\n\n\treturn true;\n}",
  "abstract_func": "FLAC_API VAR_0 FLAC__stream_encoder_process_interleaved(FLAC__StreamEncoder *VAR_1, const FLAC__int32 VAR_2[], uint32_t VAR_3)\n{\n\tuint32_t VAR_4, VAR_5, VAR_6, VAR_7;\n\tFLAC__int32 VAR_8, VAR_9, VAR_10;\n\tconst uint32_t VAR_11 = VAR_1->protected_->channels, VAR_12 = VAR_1->protected_->blocksize;\n\tconst FLAC__int32 VAR_13 = VAR_14 >> (32 - VAR_1->protected_->bits_per_sample);\n\tconst FLAC__int32 VAR_15 = VAR_16 >> (32 - VAR_1->protected_->bits_per_sample);\n\n\tFLAC__ASSERT(0 != VAR_1);\n\tFLAC__ASSERT(0 != VAR_1->private_);\n\tFLAC__ASSERT(0 != VAR_1->protected_);\n\tFLAC__ASSERT(VAR_1->protected_->state == VAR_17);\n\n\tVAR_5 = VAR_6 = 0;\n\t/* COMMENT_0 */\n                                                                 \n                         \n    \n\tif(VAR_1->protected_->do_mid_side_stereo && VAR_11 == 2) {\n\t\t/* COMMENT_4 */\n                                       \n     \n\t\tdo {\n\t\t\tif(VAR_1->protected_->verify)\n\t\t\t\tappend_to_verify_fifo_interleaved_(&VAR_1->private_->verify.input_fifo, VAR_2, VAR_5, VAR_11, flac_min(VAR_12+VAR_18-VAR_1->private_->current_sample_number, VAR_3-VAR_5));\n\n\t\t\t/* COMMENT_7 */\n\t\t\tfor(VAR_4 = VAR_1->private_->current_sample_number; VAR_4 <= VAR_12 && VAR_5 < VAR_3; VAR_4++, VAR_5++) {\n\t\t\t\tif(VAR_2[VAR_6]   < VAR_15 || VAR_2[VAR_6]   > VAR_13 ||\n\t\t\t\t   VAR_2[VAR_6+1] < VAR_15 || VAR_2[VAR_6+1] > VAR_13){\n\t\t\t\t\tVAR_1->protected_->state = VAR_19;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tVAR_1->private_->integer_signal[0][VAR_4] = VAR_9 = VAR_10 = VAR_2[VAR_6++];\n\t\t\t\tVAR_8 = VAR_2[VAR_6++];\n\t\t\t\tVAR_1->private_->integer_signal[1][VAR_4] = VAR_8;\n\t\t\t\tVAR_9 += VAR_8;\n\t\t\t\tVAR_10 -= VAR_8;\n\t\t\t\tVAR_9 >>= 1; /* COMMENT_8 */\n\t\t\t\tVAR_1->private_->integer_signal_mid_side[1][VAR_4] = VAR_10;\n\t\t\t\tVAR_1->private_->integer_signal_mid_side[0][VAR_4] = VAR_9;\n\t\t\t}\n\t\t\tVAR_1->private_->current_sample_number = VAR_4;\n\t\t\t/* COMMENT_9 */\n\t\t\tif(VAR_4 > VAR_12) {\n\t\t\t\tif(!process_frame_(VAR_1, /* COMMENT_10 */false, /* COMMENT_11 */false))\n\t\t\t\t\treturn false;\n\t\t\t\t/* COMMENT_12 */\n\t\t\t\tFLAC__ASSERT(VAR_4 == VAR_12+VAR_18);\n\t\t\t\tFLAC__ASSERT(VAR_18 == 1); /* COMMENT_13 */\n\t\t\t\tVAR_1->private_->integer_signal[0][0] = VAR_1->private_->integer_signal[0][VAR_12];\n\t\t\t\tVAR_1->private_->integer_signal[1][0] = VAR_1->private_->integer_signal[1][VAR_12];\n\t\t\t\tVAR_1->private_->integer_signal_mid_side[0][0] = VAR_1->private_->integer_signal_mid_side[0][VAR_12];\n\t\t\t\tVAR_1->private_->integer_signal_mid_side[1][0] = VAR_1->private_->integer_signal_mid_side[1][VAR_12];\n\t\t\t\tVAR_1->private_->current_sample_number = 1;\n\t\t\t}\n\t\t} while(VAR_5 < VAR_3);\n\t}\n\telse {\n\t\t/* COMMENT_14 */\n                                                                  \n     \n\t\tdo {\n\t\t\tif(VAR_1->protected_->verify)\n\t\t\t\tappend_to_verify_fifo_interleaved_(&VAR_1->private_->verify.input_fifo, VAR_2, VAR_5, VAR_11, flac_min(VAR_12+VAR_18-VAR_1->private_->current_sample_number, VAR_3-VAR_5));\n\n\t\t\t/* COMMENT_7 */\n\t\t\tfor(VAR_4 = VAR_1->private_->current_sample_number; VAR_4 <= VAR_12 && VAR_5 < VAR_3; VAR_4++, VAR_5++) {\n\t\t\t\tfor(VAR_7 = 0; VAR_7 < VAR_11; VAR_7++){\n\t\t\t\t\tif(VAR_2[VAR_6] < VAR_15 || VAR_2[VAR_6] > VAR_13){\n\t\t\t\t\t\tVAR_1->protected_->state = VAR_19;\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tVAR_1->private_->integer_signal[VAR_7][VAR_4] = VAR_2[VAR_6++];\n\t\t\t\t}\n\t\t\t}\n\t\t\tVAR_1->private_->current_sample_number = VAR_4;\n\t\t\t/* COMMENT_9 */\n\t\t\tif(VAR_4 > VAR_12) {\n\t\t\t\tif(!process_frame_(VAR_1, /* COMMENT_10 */false, /* COMMENT_11 */false))\n\t\t\t\t\treturn false;\n\t\t\t\t/* COMMENT_12 */\n\t\t\t\tFLAC__ASSERT(VAR_4 == VAR_12+VAR_18);\n\t\t\t\tFLAC__ASSERT(VAR_18 == 1); /* COMMENT_13 */\n\t\t\t\tfor(VAR_7 = 0; VAR_7 < VAR_11; VAR_7++)\n\t\t\t\t\tVAR_1->private_->integer_signal[VAR_7][0] = VAR_1->private_->integer_signal[VAR_7][VAR_12];\n\t\t\t\tVAR_1->private_->current_sample_number = 1;\n\t\t\t}\n\t\t} while(VAR_5 < VAR_3);\n\t}\n\n\treturn true;\n}",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -3,6 +3,8 @@\n \tuint32_t i, j, k, channel;\n \tFLAC__int32 x, mid, side;\n \tconst uint32_t channels = encoder->protected_->channels, blocksize = encoder->protected_->blocksize;\n+\tconst FLAC__int32 sample_max = INT32_MAX >> (32 - encoder->protected_->bits_per_sample);\n+\tconst FLAC__int32 sample_min = INT32_MIN >> (32 - encoder->protected_->bits_per_sample);\n \n \tFLAC__ASSERT(0 != encoder);\n \tFLAC__ASSERT(0 != encoder->private_);\n@@ -24,6 +26,11 @@\n \n \t\t\t/* \"i <= blocksize\" to overread 1 sample; see comment in OVERREAD_ decl */\n \t\t\tfor(i = encoder->private_->current_sample_number; i <= blocksize && j < samples; i++, j++) {\n+\t\t\t\tif(buffer[k]   < sample_min || buffer[k]   > sample_max ||\n+\t\t\t\t   buffer[k+1] < sample_min || buffer[k+1] > sample_max){\n+\t\t\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n \t\t\t\tencoder->private_->integer_signal[0][i] = mid = side = buffer[k++];\n \t\t\t\tx = buffer[k++];\n \t\t\t\tencoder->private_->integer_signal[1][i] = x;\n@@ -59,8 +66,13 @@\n \n \t\t\t/* \"i <= blocksize\" to overread 1 sample; see comment in OVERREAD_ decl */\n \t\t\tfor(i = encoder->private_->current_sample_number; i <= blocksize && j < samples; i++, j++) {\n-\t\t\t\tfor(channel = 0; channel < channels; channel++)\n+\t\t\t\tfor(channel = 0; channel < channels; channel++){\n+\t\t\t\t\tif(buffer[k] < sample_min || buffer[k] > sample_max){\n+\t\t\t\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n \t\t\t\t\tencoder->private_->integer_signal[channel][i] = buffer[k++];\n+\t\t\t\t}\n \t\t\t}\n \t\t\tencoder->private_->current_sample_number = i;\n \t\t\t/* we only process if we have a full block + 1 extra sample; final block is always handled by FLAC__stream_encoder_finish() */",
  "diff_line_info": {
    "deleted_lines": [
      "\t\t\t\tfor(channel = 0; channel < channels; channel++)"
    ],
    "added_lines": [
      "\tconst FLAC__int32 sample_max = INT32_MAX >> (32 - encoder->protected_->bits_per_sample);",
      "\tconst FLAC__int32 sample_min = INT32_MIN >> (32 - encoder->protected_->bits_per_sample);",
      "\t\t\t\tif(buffer[k]   < sample_min || buffer[k]   > sample_max ||",
      "\t\t\t\t   buffer[k+1] < sample_min || buffer[k+1] > sample_max){",
      "\t\t\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;",
      "\t\t\t\t\treturn false;",
      "\t\t\t\t}",
      "\t\t\t\tfor(channel = 0; channel < channels; channel++){",
      "\t\t\t\t\tif(buffer[k] < sample_min || buffer[k] > sample_max){",
      "\t\t\t\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;",
      "\t\t\t\t\t\treturn false;",
      "\t\t\t\t\t}",
      "\t\t\t\t}"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/xiph/flac/pull/273",
  "description": {
    "pr_info": {
      "title": "Fix 2 encoder bugs found by oss-fuzz",
      "number": 273
    },
    "comment": [
      "Commit 5a79fb5 fixes two encoder bugs. The encoder did not check whether samples provided through FLAC__stream_encoder_process or FLAC__stream_encoder_process_interleaved were bounded to fall within the set bits_per_sample (bps). This created all kinds of trouble within the encoder, as there are numerous times where the encoder chooses between different datapaths, data types and encoding strategies based on the set bps.\r\n\r\nThis commit might veil other bugs though. #214 (see also #215) was also trying to address one of these fuzz finds, but in a very different way. Moreover, both fuzz finds seemed to originate from the bitwriter, while this PR is fix at the very start of the encoding process.\r\n\r\n~To better guard against other (similar) bugs, commit d249427 is also added to this PR. That commit in itself also fixes the two oss-fuzz finds by not allowing the bitwriter to grow beyond a certain limit beyond which using a subframe with a residual does not make sense: the limit is set at the point where using a verbatim subframe results in a smaller subframe no matter what input parameters are chosen (i.e. the biggest possible blocksize combined with the highest possible bps). This will further shield libFLAC from crashing (which would pose a security concern) and arrest (future) bugs like #251 and #252 by stopping the encoder instead of it trying to produce bloated and potentially unreadable files.~\r\n\r\nTurns out the second commit only passes the test suite when combined with #251 and #252, so I'm removing it for now.",
      "It turns out in the past, invalid files have been created in which the samples exceed the range offered by the stated bit depth, see https://sourceforge.net/p/flac/bugs/468/ This PR prevents the encoder from creating such files."
    ]
  },
  "Bug Filter": "** Security Vulnerability Fix  \n**Confidence Score:** 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\nThe patch adds bounds checking for input samples to prevent potential overflows, which addresses a security vulnerability. \n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 0.95"
}