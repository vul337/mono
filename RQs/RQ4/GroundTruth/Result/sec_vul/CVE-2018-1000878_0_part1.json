{
  "cve_id": "CVE-2018-1000878",
  "cwe_ids": [
    "CWE-416"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "libarchive",
  "commit_msg": "rar: file split across multi-part archives must match\n\nFuzzing uncovered some UAF and memory overrun bugs where a file in a\nsingle file archive reported that it was split across multiple\nvolumes. This was caused by ppmd7 operations calling\nrar_br_fillup. This would invoke rar_read_ahead, which would in some\nsituations invoke archive_read_format_rar_read_header.  That would\ncheck the new file name against the old file name, and if they didn't\nmatch up it would free the ppmd7 buffer and allocate a new\none. However, because the ppmd7 decoder wasn't actually done with the\nbuffer, it would continue to used the freed buffer. Both reads and\nwrites to the freed region can be observed.\n\nThis is quite tricky to solve: once the buffer has been freed it is\ntoo late, as the ppmd7 decoder functions almost universally assume\nsuccess - there's no way for ppmd_read to signal error, nor are there\ngood ways for functions like Range_Normalise to propagate them. So we\ncan't detect after the fact that we're in an invalid state - e.g. by\nchecking rar->cursor, we have to prevent ourselves from ever ending up\nthere. So, when we are in the dangerous part or rar_read_ahead that\nassumes a valid split, we set a flag force read_header to either go\ndown the path for split files or bail. This means that the ppmd7\ndecoder keeps a valid buffer and just runs out of data.\n\nFound with a combination of AFL, afl-rb and qsym.",
  "commit_hash": "bfcfe6f04ed20db2504db8a254d1f40a1d84eb28",
  "git_url": "https://github.com/libarchive/libarchive/commit/bfcfe6f04ed20db2504db8a254d1f40a1d84eb28",
  "file_path": "libarchive/archive_read_support_format_rar.c",
  "func_name": "read_header",
  "func_before": "static int\nread_header(struct archive_read *a, struct archive_entry *entry,\n            char head_type)\n{\n  const void *h;\n  const char *p, *endp;\n  struct rar *rar;\n  struct rar_header rar_header;\n  struct rar_file_header file_header;\n  int64_t header_size;\n  unsigned filename_size, end;\n  char *filename;\n  char *strp;\n  char packed_size[8];\n  char unp_size[8];\n  int ttime;\n  struct archive_string_conv *sconv, *fn_sconv;\n  unsigned long crc32_val;\n  int ret = (ARCHIVE_OK), ret2;\n\n  rar = (struct rar *)(a->format->data);\n\n  /* Setup a string conversion object for non-rar-unicode filenames. */\n  sconv = rar->opt_sconv;\n  if (sconv == NULL) {\n    if (!rar->init_default_conversion) {\n      rar->sconv_default =\n          archive_string_default_conversion_for_read(\n            &(a->archive));\n      rar->init_default_conversion = 1;\n    }\n    sconv = rar->sconv_default;\n  }\n\n\n  if ((h = __archive_read_ahead(a, 7, NULL)) == NULL)\n    return (ARCHIVE_FATAL);\n  p = h;\n  memcpy(&rar_header, p, sizeof(rar_header));\n  rar->file_flags = archive_le16dec(rar_header.flags);\n  header_size = archive_le16dec(rar_header.size);\n  if (header_size < (int64_t)sizeof(file_header) + 7) {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n      \"Invalid header size\");\n    return (ARCHIVE_FATAL);\n  }\n  crc32_val = crc32(0, (const unsigned char *)p + 2, 7 - 2);\n  __archive_read_consume(a, 7);\n\n  if (!(rar->file_flags & FHD_SOLID))\n  {\n    rar->compression_method = 0;\n    rar->packed_size = 0;\n    rar->unp_size = 0;\n    rar->mtime = 0;\n    rar->ctime = 0;\n    rar->atime = 0;\n    rar->arctime = 0;\n    rar->mode = 0;\n    memset(&rar->salt, 0, sizeof(rar->salt));\n    rar->atime = 0;\n    rar->ansec = 0;\n    rar->ctime = 0;\n    rar->cnsec = 0;\n    rar->mtime = 0;\n    rar->mnsec = 0;\n    rar->arctime = 0;\n    rar->arcnsec = 0;\n  }\n  else\n  {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"RAR solid archive support unavailable.\");\n    return (ARCHIVE_FATAL);\n  }\n\n  if ((h = __archive_read_ahead(a, (size_t)header_size - 7, NULL)) == NULL)\n    return (ARCHIVE_FATAL);\n\n  /* File Header CRC check. */\n  crc32_val = crc32(crc32_val, h, (unsigned)(header_size - 7));\n  if ((crc32_val & 0xffff) != archive_le16dec(rar_header.crc)) {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n      \"Header CRC error\");\n    return (ARCHIVE_FATAL);\n  }\n  /* If no CRC error, Go on parsing File Header. */\n  p = h;\n  endp = p + header_size - 7;\n  memcpy(&file_header, p, sizeof(file_header));\n  p += sizeof(file_header);\n\n  rar->compression_method = file_header.method;\n\n  ttime = archive_le32dec(file_header.file_time);\n  rar->mtime = get_time(ttime);\n\n  rar->file_crc = archive_le32dec(file_header.file_crc);\n\n  if (rar->file_flags & FHD_PASSWORD)\n  {\n\tarchive_entry_set_is_data_encrypted(entry, 1);\n\trar->has_encrypted_entries = 1;\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"RAR encryption support unavailable.\");\n    /* Since it is only the data part itself that is encrypted we can at least\n       extract information about the currently processed entry and don't need\n       to return ARCHIVE_FATAL here. */\n    /*return (ARCHIVE_FATAL);*/\n  }\n\n  if (rar->file_flags & FHD_LARGE)\n  {\n    memcpy(packed_size, file_header.pack_size, 4);\n    memcpy(packed_size + 4, p, 4); /* High pack size */\n    p += 4;\n    memcpy(unp_size, file_header.unp_size, 4);\n    memcpy(unp_size + 4, p, 4); /* High unpack size */\n    p += 4;\n    rar->packed_size = archive_le64dec(&packed_size);\n    rar->unp_size = archive_le64dec(&unp_size);\n  }\n  else\n  {\n    rar->packed_size = archive_le32dec(file_header.pack_size);\n    rar->unp_size = archive_le32dec(file_header.unp_size);\n  }\n\n  if (rar->packed_size < 0 || rar->unp_size < 0)\n  {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"Invalid sizes specified.\");\n    return (ARCHIVE_FATAL);\n  }\n\n  rar->bytes_remaining = rar->packed_size;\n\n  /* TODO: RARv3 subblocks contain comments. For now the complete block is\n   * consumed at the end.\n   */\n  if (head_type == NEWSUB_HEAD) {\n    size_t distance = p - (const char *)h;\n    header_size += rar->packed_size;\n    /* Make sure we have the extended data. */\n    if ((h = __archive_read_ahead(a, (size_t)header_size - 7, NULL)) == NULL)\n        return (ARCHIVE_FATAL);\n    p = h;\n    endp = p + header_size - 7;\n    p += distance;\n  }\n\n  filename_size = archive_le16dec(file_header.name_size);\n  if (p + filename_size > endp) {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n      \"Invalid filename size\");\n    return (ARCHIVE_FATAL);\n  }\n  if (rar->filename_allocated < filename_size * 2 + 2) {\n    char *newptr;\n    size_t newsize = filename_size * 2 + 2;\n    newptr = realloc(rar->filename, newsize);\n    if (newptr == NULL) {\n      archive_set_error(&a->archive, ENOMEM,\n                        \"Couldn't allocate memory.\");\n      return (ARCHIVE_FATAL);\n    }\n    rar->filename = newptr;\n    rar->filename_allocated = newsize;\n  }\n  filename = rar->filename;\n  memcpy(filename, p, filename_size);\n  filename[filename_size] = '\\0';\n  if (rar->file_flags & FHD_UNICODE)\n  {\n    if (filename_size != strlen(filename))\n    {\n      unsigned char highbyte, flagbits, flagbyte;\n      unsigned fn_end, offset;\n\n      end = filename_size;\n      fn_end = filename_size * 2;\n      filename_size = 0;\n      offset = (unsigned)strlen(filename) + 1;\n      highbyte = *(p + offset++);\n      flagbits = 0;\n      flagbyte = 0;\n      while (offset < end && filename_size < fn_end)\n      {\n        if (!flagbits)\n        {\n          flagbyte = *(p + offset++);\n          flagbits = 8;\n        }\n\n        flagbits -= 2;\n        switch((flagbyte >> flagbits) & 3)\n        {\n          case 0:\n            filename[filename_size++] = '\\0';\n            filename[filename_size++] = *(p + offset++);\n            break;\n          case 1:\n            filename[filename_size++] = highbyte;\n            filename[filename_size++] = *(p + offset++);\n            break;\n          case 2:\n            filename[filename_size++] = *(p + offset + 1);\n            filename[filename_size++] = *(p + offset);\n            offset += 2;\n            break;\n          case 3:\n          {\n            char extra, high;\n            uint8_t length = *(p + offset++);\n\n            if (length & 0x80) {\n              extra = *(p + offset++);\n              high = (char)highbyte;\n            } else\n              extra = high = 0;\n            length = (length & 0x7f) + 2;\n            while (length && filename_size < fn_end) {\n              unsigned cp = filename_size >> 1;\n              filename[filename_size++] = high;\n              filename[filename_size++] = p[cp] + extra;\n              length--;\n            }\n          }\n          break;\n        }\n      }\n      if (filename_size > fn_end) {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n          \"Invalid filename\");\n        return (ARCHIVE_FATAL);\n      }\n      filename[filename_size++] = '\\0';\n      /*\n       * Do not increment filename_size here as the computations below\n       * add the space for the terminating NUL explicitly.\n       */\n      filename[filename_size] = '\\0';\n\n      /* Decoded unicode form is UTF-16BE, so we have to update a string\n       * conversion object for it. */\n      if (rar->sconv_utf16be == NULL) {\n        rar->sconv_utf16be = archive_string_conversion_from_charset(\n           &a->archive, \"UTF-16BE\", 1);\n        if (rar->sconv_utf16be == NULL)\n          return (ARCHIVE_FATAL);\n      }\n      fn_sconv = rar->sconv_utf16be;\n\n      strp = filename;\n      while (memcmp(strp, \"\\x00\\x00\", 2))\n      {\n        if (!memcmp(strp, \"\\x00\\\\\", 2))\n          *(strp + 1) = '/';\n        strp += 2;\n      }\n      p += offset;\n    } else {\n      /*\n       * If FHD_UNICODE is set but no unicode data, this file name form\n       * is UTF-8, so we have to update a string conversion object for\n       * it accordingly.\n       */\n      if (rar->sconv_utf8 == NULL) {\n        rar->sconv_utf8 = archive_string_conversion_from_charset(\n           &a->archive, \"UTF-8\", 1);\n        if (rar->sconv_utf8 == NULL)\n          return (ARCHIVE_FATAL);\n      }\n      fn_sconv = rar->sconv_utf8;\n      while ((strp = strchr(filename, '\\\\')) != NULL)\n        *strp = '/';\n      p += filename_size;\n    }\n  }\n  else\n  {\n    fn_sconv = sconv;\n    while ((strp = strchr(filename, '\\\\')) != NULL)\n      *strp = '/';\n    p += filename_size;\n  }\n\n  /* Split file in multivolume RAR. No more need to process header. */\n  if (rar->filename_save &&\n    filename_size == rar->filename_save_size &&\n    !memcmp(rar->filename, rar->filename_save, filename_size + 1))\n  {\n    __archive_read_consume(a, header_size - 7);\n    rar->cursor++;\n    if (rar->cursor >= rar->nodes)\n    {\n      rar->nodes++;\n      if ((rar->dbo =\n        realloc(rar->dbo, sizeof(*rar->dbo) * rar->nodes)) == NULL)\n      {\n        archive_set_error(&a->archive, ENOMEM, \"Couldn't allocate memory.\");\n        return (ARCHIVE_FATAL);\n      }\n      rar->dbo[rar->cursor].header_size = header_size;\n      rar->dbo[rar->cursor].start_offset = -1;\n      rar->dbo[rar->cursor].end_offset = -1;\n    }\n    if (rar->dbo[rar->cursor].start_offset < 0)\n    {\n      rar->dbo[rar->cursor].start_offset = a->filter->position;\n      rar->dbo[rar->cursor].end_offset = rar->dbo[rar->cursor].start_offset +\n        rar->packed_size;\n    }\n    return ret;\n  }\n\n  rar->filename_save = (char*)realloc(rar->filename_save,\n                                      filename_size + 1);\n  memcpy(rar->filename_save, rar->filename, filename_size + 1);\n  rar->filename_save_size = filename_size;\n\n  /* Set info for seeking */\n  free(rar->dbo);\n  if ((rar->dbo = calloc(1, sizeof(*rar->dbo))) == NULL)\n  {\n    archive_set_error(&a->archive, ENOMEM, \"Couldn't allocate memory.\");\n    return (ARCHIVE_FATAL);\n  }\n  rar->dbo[0].header_size = header_size;\n  rar->dbo[0].start_offset = -1;\n  rar->dbo[0].end_offset = -1;\n  rar->cursor = 0;\n  rar->nodes = 1;\n\n  if (rar->file_flags & FHD_SALT)\n  {\n    if (p + 8 > endp) {\n      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n        \"Invalid header size\");\n      return (ARCHIVE_FATAL);\n    }\n    memcpy(rar->salt, p, 8);\n    p += 8;\n  }\n\n  if (rar->file_flags & FHD_EXTTIME) {\n    if (read_exttime(p, rar, endp) < 0) {\n      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n        \"Invalid header size\");\n      return (ARCHIVE_FATAL);\n    }\n  }\n\n  __archive_read_consume(a, header_size - 7);\n  rar->dbo[0].start_offset = a->filter->position;\n  rar->dbo[0].end_offset = rar->dbo[0].start_offset + rar->packed_size;\n\n  switch(file_header.host_os)\n  {\n  case OS_MSDOS:\n  case OS_OS2:\n  case OS_WIN32:\n    rar->mode = archive_le32dec(file_header.file_attr);\n    if (rar->mode & FILE_ATTRIBUTE_DIRECTORY)\n      rar->mode = AE_IFDIR | S_IXUSR | S_IXGRP | S_IXOTH;\n    else\n      rar->mode = AE_IFREG;\n    rar->mode |= S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;\n    break;\n\n  case OS_UNIX:\n  case OS_MAC_OS:\n  case OS_BEOS:\n    rar->mode = archive_le32dec(file_header.file_attr);\n    break;\n\n  default:\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"Unknown file attributes from RAR file's host OS\");\n    return (ARCHIVE_FATAL);\n  }\n\n  rar->bytes_uncopied = rar->bytes_unconsumed = 0;\n  rar->lzss.position = rar->offset = 0;\n  rar->offset_seek = 0;\n  rar->dictionary_size = 0;\n  rar->offset_outgoing = 0;\n  rar->br.cache_avail = 0;\n  rar->br.avail_in = 0;\n  rar->crc_calculated = 0;\n  rar->entry_eof = 0;\n  rar->valid = 1;\n  rar->is_ppmd_block = 0;\n  rar->start_new_table = 1;\n  free(rar->unp_buffer);\n  rar->unp_buffer = NULL;\n  rar->unp_offset = 0;\n  rar->unp_buffer_size = UNP_BUFFER_SIZE;\n  memset(rar->lengthtable, 0, sizeof(rar->lengthtable));\n  __archive_ppmd7_functions.Ppmd7_Free(&rar->ppmd7_context);\n  rar->ppmd_valid = rar->ppmd_eod = 0;\n\n  /* Don't set any archive entries for non-file header types */\n  if (head_type == NEWSUB_HEAD)\n    return ret;\n\n  archive_entry_set_mtime(entry, rar->mtime, rar->mnsec);\n  archive_entry_set_ctime(entry, rar->ctime, rar->cnsec);\n  archive_entry_set_atime(entry, rar->atime, rar->ansec);\n  archive_entry_set_size(entry, rar->unp_size);\n  archive_entry_set_mode(entry, rar->mode);\n\n  if (archive_entry_copy_pathname_l(entry, filename, filename_size, fn_sconv))\n  {\n    if (errno == ENOMEM)\n    {\n      archive_set_error(&a->archive, ENOMEM,\n                        \"Can't allocate memory for Pathname\");\n      return (ARCHIVE_FATAL);\n    }\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"Pathname cannot be converted from %s to current locale.\",\n                      archive_string_conversion_charset_name(fn_sconv));\n    ret = (ARCHIVE_WARN);\n  }\n\n  if (((rar->mode) & AE_IFMT) == AE_IFLNK)\n  {\n    /* Make sure a symbolic-link file does not have its body. */\n    rar->bytes_remaining = 0;\n    archive_entry_set_size(entry, 0);\n\n    /* Read a symbolic-link name. */\n    if ((ret2 = read_symlink_stored(a, entry, sconv)) < (ARCHIVE_WARN))\n      return ret2;\n    if (ret > ret2)\n      ret = ret2;\n  }\n\n  if (rar->bytes_remaining == 0)\n    rar->entry_eof = 1;\n\n  return ret;\n}",
  "abstract_func_before": "static int\nread_header(struct archive_read *VAR_0, struct archive_entry *VAR_1,\n            char VAR_2)\n{\n  const void *VAR_3;\n  const char *VAR_4, *VAR_5;\n  struct rar *rar;\n  struct rar_header rar_header;\n  struct rar_file_header VAR_6;\n  int64_t VAR_7;\n  unsigned VAR_8, VAR_9;\n  char *VAR_10;\n  char *VAR_11;\n  char VAR_12[8];\n  char VAR_13[8];\n  int VAR_14;\n  struct archive_string_conv *VAR_15, *VAR_16;\n  unsigned long VAR_17;\n  int VAR_18 = (VAR_19), VAR_20;\n\n  rar = (struct rar *)(VAR_0->format->data);\n\n  /* COMMENT_0 */\n  VAR_15 = rar->opt_sconv;\n  if (VAR_15 == NULL) {\n    if (!rar->init_default_conversion) {\n      rar->sconv_default =\n          archive_string_default_conversion_for_read(\n            &(VAR_0->archive));\n      rar->init_default_conversion = 1;\n    }\n    VAR_15 = rar->sconv_default;\n  }\n\n\n  if ((VAR_3 = __archive_read_ahead(VAR_0, 7, NULL)) == NULL)\n    return (VAR_21);\n  VAR_4 = VAR_3;\n  memcpy(&rar_header, VAR_4, sizeof(rar_header));\n  rar->file_flags = archive_le16dec(rar_header.flags);\n  VAR_7 = archive_le16dec(rar_header.size);\n  if (VAR_7 < (int64_t)sizeof(VAR_6) + 7) {\n    archive_set_error(&VAR_0->archive, VAR_22,\n      \"Invalid header size\");\n    return (VAR_21);\n  }\n  VAR_17 = crc32(0, (const unsigned char *)VAR_4 + 2, 7 - 2);\n  __archive_read_consume(VAR_0, 7);\n\n  if (!(rar->file_flags & VAR_23))\n  {\n    rar->compression_method = 0;\n    rar->packed_size = 0;\n    rar->unp_size = 0;\n    rar->mtime = 0;\n    rar->ctime = 0;\n    rar->atime = 0;\n    rar->arctime = 0;\n    rar->mode = 0;\n    memset(&rar->salt, 0, sizeof(rar->salt));\n    rar->atime = 0;\n    rar->ansec = 0;\n    rar->ctime = 0;\n    rar->cnsec = 0;\n    rar->mtime = 0;\n    rar->mnsec = 0;\n    rar->arctime = 0;\n    rar->arcnsec = 0;\n  }\n  else\n  {\n    archive_set_error(&VAR_0->archive, VAR_22,\n                      \"RAR solid archive support unavailable.\");\n    return (VAR_21);\n  }\n\n  if ((VAR_3 = __archive_read_ahead(VAR_0, (size_t)VAR_7 - 7, NULL)) == NULL)\n    return (VAR_21);\n\n  /* COMMENT_1 */\n  VAR_17 = crc32(VAR_17, VAR_3, (unsigned)(VAR_7 - 7));\n  if ((VAR_17 & 0xffff) != archive_le16dec(rar_header.crc)) {\n    archive_set_error(&VAR_0->archive, VAR_22,\n      \"Header CRC error\");\n    return (VAR_21);\n  }\n  /* COMMENT_2 */\n  VAR_4 = VAR_3;\n  VAR_5 = VAR_4 + VAR_7 - 7;\n  memcpy(&VAR_6, VAR_4, sizeof(VAR_6));\n  VAR_4 += sizeof(VAR_6);\n\n  rar->compression_method = VAR_6.method;\n\n  VAR_14 = archive_le32dec(VAR_6.file_time);\n  rar->mtime = get_time(VAR_14);\n\n  rar->file_crc = archive_le32dec(VAR_6.file_crc);\n\n  if (rar->file_flags & VAR_24)\n  {\n\tarchive_entry_set_is_data_encrypted(VAR_1, 1);\n\trar->has_encrypted_entries = 1;\n    archive_set_error(&VAR_0->archive, VAR_22,\n                      \"RAR encryption support unavailable.\");\n    /* COMMENT_3 */\n                                                                             \n                                       \n    /* COMMENT_6 */\n  }\n\n  if (rar->file_flags & VAR_25)\n  {\n    memcpy(VAR_12, VAR_6.pack_size, 4);\n    memcpy(VAR_12 + 4, VAR_4, 4); /* COMMENT_7 */\n    VAR_4 += 4;\n    memcpy(VAR_13, VAR_6.unp_size, 4);\n    memcpy(VAR_13 + 4, VAR_4, 4); /* COMMENT_8 */\n    VAR_4 += 4;\n    rar->packed_size = archive_le64dec(&VAR_12);\n    rar->unp_size = archive_le64dec(&VAR_13);\n  }\n  else\n  {\n    rar->packed_size = archive_le32dec(VAR_6.pack_size);\n    rar->unp_size = archive_le32dec(VAR_6.unp_size);\n  }\n\n  if (rar->packed_size < 0 || rar->unp_size < 0)\n  {\n    archive_set_error(&VAR_0->archive, VAR_22,\n                      \"Invalid sizes specified.\");\n    return (VAR_21);\n  }\n\n  rar->bytes_remaining = rar->packed_size;\n\n  /* COMMENT_9 */\n                         \n     \n  if (VAR_2 == VAR_26) {\n    size_t VAR_27 = VAR_4 - (const char *)VAR_3;\n    VAR_7 += rar->packed_size;\n    /* COMMENT_12 */\n    if ((VAR_3 = __archive_read_ahead(VAR_0, (size_t)VAR_7 - 7, NULL)) == NULL)\n        return (VAR_21);\n    VAR_4 = VAR_3;\n    VAR_5 = VAR_4 + VAR_7 - 7;\n    VAR_4 += VAR_27;\n  }\n\n  VAR_8 = archive_le16dec(VAR_6.name_size);\n  if (VAR_4 + VAR_8 > VAR_5) {\n    archive_set_error(&VAR_0->archive, VAR_22,\n      \"Invalid filename size\");\n    return (VAR_21);\n  }\n  if (rar->filename_allocated < VAR_8 * 2 + 2) {\n    char *VAR_28;\n    size_t VAR_29 = VAR_8 * 2 + 2;\n    VAR_28 = realloc(rar->filename, VAR_29);\n    if (VAR_28 == NULL) {\n      archive_set_error(&VAR_0->archive, VAR_30,\n                        \"Couldn't allocate memory.\");\n      return (VAR_21);\n    }\n    rar->filename = VAR_28;\n    rar->filename_allocated = VAR_29;\n  }\n  VAR_10 = rar->filename;\n  memcpy(VAR_10, VAR_4, VAR_8);\n  VAR_10[VAR_8] = '\\0';\n  if (rar->file_flags & VAR_31)\n  {\n    if (VAR_8 != strlen(VAR_10))\n    {\n      unsigned char VAR_32, VAR_33, VAR_34;\n      unsigned VAR_35, VAR_36;\n\n      VAR_9 = VAR_8;\n      VAR_35 = VAR_8 * 2;\n      VAR_8 = 0;\n      VAR_36 = (unsigned)strlen(VAR_10) + 1;\n      VAR_32 = *(VAR_4 + VAR_36++);\n      VAR_33 = 0;\n      VAR_34 = 0;\n      while (VAR_36 < VAR_9 && VAR_8 < VAR_35)\n      {\n        if (!VAR_33)\n        {\n          VAR_34 = *(VAR_4 + VAR_36++);\n          VAR_33 = 8;\n        }\n\n        VAR_33 -= 2;\n        switch((VAR_34 >> VAR_33) & 3)\n        {\n          case 0:\n            VAR_10[VAR_8++] = '\\0';\n            VAR_10[VAR_8++] = *(VAR_4 + VAR_36++);\n            break;\n          case 1:\n            VAR_10[VAR_8++] = VAR_32;\n            VAR_10[VAR_8++] = *(VAR_4 + VAR_36++);\n            break;\n          case 2:\n            VAR_10[VAR_8++] = *(VAR_4 + VAR_36 + 1);\n            VAR_10[VAR_8++] = *(VAR_4 + VAR_36);\n            VAR_36 += 2;\n            break;\n          case 3:\n          {\n            char VAR_37, VAR_38;\n            uint8_t VAR_39 = *(VAR_4 + VAR_36++);\n\n            if (VAR_39 & 0x80) {\n              VAR_37 = *(VAR_4 + VAR_36++);\n              VAR_38 = (char)VAR_32;\n            } else\n              VAR_37 = VAR_38 = 0;\n            VAR_39 = (VAR_39 & 0x7f) + 2;\n            while (VAR_39 && VAR_8 < VAR_35) {\n              unsigned VAR_40 = VAR_8 >> 1;\n              VAR_10[VAR_8++] = VAR_38;\n              VAR_10[VAR_8++] = VAR_4[VAR_40] + VAR_37;\n              VAR_39--;\n            }\n          }\n          break;\n        }\n      }\n      if (VAR_8 > VAR_35) {\n        archive_set_error(&VAR_0->archive, VAR_22,\n          \"Invalid filename\");\n        return (VAR_21);\n      }\n      VAR_10[VAR_8++] = '\\0';\n      /* COMMENT_13 */\n                                                                      \n                                                          \n         \n      VAR_10[VAR_8] = '\\0';\n\n      /* COMMENT_17 */\n                                     \n      if (rar->sconv_utf16be == NULL) {\n        rar->sconv_utf16be = archive_string_conversion_from_charset(\n           &VAR_0->archive, \"UTF-16BE\", 1);\n        if (rar->sconv_utf16be == NULL)\n          return (VAR_21);\n      }\n      VAR_16 = rar->sconv_utf16be;\n\n      VAR_11 = VAR_10;\n      while (memcmp(VAR_11, \"\\x00\\x00\", 2))\n      {\n        if (!memcmp(VAR_11, \"\\x00\\\\\", 2))\n          *(VAR_11 + 1) = '/';\n        VAR_11 += 2;\n      }\n      VAR_4 += VAR_36;\n    } else {\n      /* COMMENT_19 */\n                                                                       \n                                                                      \n                        \n         \n      if (rar->sconv_utf8 == NULL) {\n        rar->sconv_utf8 = archive_string_conversion_from_charset(\n           &VAR_0->archive, \"UTF-8\", 1);\n        if (rar->sconv_utf8 == NULL)\n          return (VAR_21);\n      }\n      VAR_16 = rar->sconv_utf8;\n      while ((VAR_11 = strchr(VAR_10, '\\\\')) != NULL)\n        *VAR_11 = '/';\n      VAR_4 += VAR_8;\n    }\n  }\n  else\n  {\n    VAR_16 = VAR_15;\n    while ((VAR_11 = strchr(VAR_10, '\\\\')) != NULL)\n      *VAR_11 = '/';\n    VAR_4 += VAR_8;\n  }\n\n  /* COMMENT_24 */\n  if (rar->filename_save &&\n    VAR_8 == rar->filename_save_size &&\n    !memcmp(rar->filename, rar->filename_save, VAR_8 + 1))\n  {\n    __archive_read_consume(VAR_0, VAR_7 - 7);\n    rar->cursor++;\n    if (rar->cursor >= rar->nodes)\n    {\n      rar->nodes++;\n      if ((rar->dbo =\n        realloc(rar->dbo, sizeof(*rar->dbo) * rar->nodes)) == NULL)\n      {\n        archive_set_error(&VAR_0->archive, VAR_30, \"Couldn't allocate memory.\");\n        return (VAR_21);\n      }\n      rar->dbo[rar->cursor].header_size = VAR_7;\n      rar->dbo[rar->cursor].start_offset = -1;\n      rar->dbo[rar->cursor].end_offset = -1;\n    }\n    if (rar->dbo[rar->cursor].start_offset < 0)\n    {\n      rar->dbo[rar->cursor].start_offset = VAR_0->filter->position;\n      rar->dbo[rar->cursor].end_offset = rar->dbo[rar->cursor].start_offset +\n        rar->packed_size;\n    }\n    return VAR_18;\n  }\n\n  rar->filename_save = (char*)realloc(rar->filename_save,\n                                      VAR_8 + 1);\n  memcpy(rar->filename_save, rar->filename, VAR_8 + 1);\n  rar->filename_save_size = VAR_8;\n\n  /* COMMENT_25 */\n  free(rar->dbo);\n  if ((rar->dbo = calloc(1, sizeof(*rar->dbo))) == NULL)\n  {\n    archive_set_error(&VAR_0->archive, VAR_30, \"Couldn't allocate memory.\");\n    return (VAR_21);\n  }\n  rar->dbo[0].header_size = VAR_7;\n  rar->dbo[0].start_offset = -1;\n  rar->dbo[0].end_offset = -1;\n  rar->cursor = 0;\n  rar->nodes = 1;\n\n  if (rar->file_flags & VAR_41)\n  {\n    if (VAR_4 + 8 > VAR_5) {\n      archive_set_error(&VAR_0->archive, VAR_22,\n        \"Invalid header size\");\n      return (VAR_21);\n    }\n    memcpy(rar->salt, VAR_4, 8);\n    VAR_4 += 8;\n  }\n\n  if (rar->file_flags & VAR_42) {\n    if (read_exttime(VAR_4, rar, VAR_5) < 0) {\n      archive_set_error(&VAR_0->archive, VAR_22,\n        \"Invalid header size\");\n      return (VAR_21);\n    }\n  }\n\n  __archive_read_consume(VAR_0, VAR_7 - 7);\n  rar->dbo[0].start_offset = VAR_0->filter->position;\n  rar->dbo[0].end_offset = rar->dbo[0].start_offset + rar->packed_size;\n\n  switch(VAR_6.host_os)\n  {\n  case VAR_43:\n  case VAR_44:\n  case VAR_45:\n    rar->mode = archive_le32dec(VAR_6.file_attr);\n    if (rar->mode & VAR_46)\n      rar->mode = VAR_47 | VAR_48 | VAR_49 | VAR_50;\n    else\n      rar->mode = VAR_51;\n    rar->mode |= VAR_52 | VAR_53 | VAR_54 | VAR_55;\n    break;\n\n  case VAR_56:\n  case VAR_57:\n  case VAR_58:\n    rar->mode = archive_le32dec(VAR_6.file_attr);\n    break;\n\n  default:\n    archive_set_error(&VAR_0->archive, VAR_22,\n                      \"Unknown file attributes from RAR file's host OS\");\n    return (VAR_21);\n  }\n\n  rar->bytes_uncopied = rar->bytes_unconsumed = 0;\n  rar->lzss.position = rar->offset = 0;\n  rar->offset_seek = 0;\n  rar->dictionary_size = 0;\n  rar->offset_outgoing = 0;\n  rar->br.cache_avail = 0;\n  rar->br.avail_in = 0;\n  rar->crc_calculated = 0;\n  rar->entry_eof = 0;\n  rar->valid = 1;\n  rar->is_ppmd_block = 0;\n  rar->start_new_table = 1;\n  free(rar->unp_buffer);\n  rar->unp_buffer = NULL;\n  rar->unp_offset = 0;\n  rar->unp_buffer_size = VAR_59;\n  memset(rar->lengthtable, 0, sizeof(rar->lengthtable));\n  VAR_60.Ppmd7_Free(&rar->ppmd7_context);\n  rar->ppmd_valid = rar->ppmd_eod = 0;\n\n  /* COMMENT_26 */\n  if (VAR_2 == VAR_26)\n    return VAR_18;\n\n  archive_entry_set_mtime(VAR_1, rar->mtime, rar->mnsec);\n  archive_entry_set_ctime(VAR_1, rar->ctime, rar->cnsec);\n  archive_entry_set_atime(VAR_1, rar->atime, rar->ansec);\n  archive_entry_set_size(VAR_1, rar->unp_size);\n  archive_entry_set_mode(VAR_1, rar->mode);\n\n  if (archive_entry_copy_pathname_l(VAR_1, VAR_10, VAR_8, VAR_16))\n  {\n    if (VAR_61 == VAR_30)\n    {\n      archive_set_error(&VAR_0->archive, VAR_30,\n                        \"Can't allocate memory for Pathname\");\n      return (VAR_21);\n    }\n    archive_set_error(&VAR_0->archive, VAR_22,\n                      \"Pathname cannot be converted from %s to current locale.\",\n                      archive_string_conversion_charset_name(VAR_16));\n    VAR_18 = (VAR_62);\n  }\n\n  if (((rar->mode) & VAR_63) == VAR_64)\n  {\n    /* COMMENT_27 */\n    rar->bytes_remaining = 0;\n    archive_entry_set_size(VAR_1, 0);\n\n    /* COMMENT_28 */\n    if ((VAR_20 = read_symlink_stored(VAR_0, VAR_1, VAR_15)) < (VAR_62))\n      return VAR_20;\n    if (VAR_18 > VAR_20)\n      VAR_18 = VAR_20;\n  }\n\n  if (rar->bytes_remaining == 0)\n    rar->entry_eof = 1;\n\n  return VAR_18;\n}",
  "func_graph_path_before": "libarchive/bfcfe6f04ed20db2504db8a254d1f40a1d84eb28/archive_read_support_format_rar.c/vul/before/1.json",
  "func": "static int\nread_header(struct archive_read *a, struct archive_entry *entry,\n            char head_type)\n{\n  const void *h;\n  const char *p, *endp;\n  struct rar *rar;\n  struct rar_header rar_header;\n  struct rar_file_header file_header;\n  int64_t header_size;\n  unsigned filename_size, end;\n  char *filename;\n  char *strp;\n  char packed_size[8];\n  char unp_size[8];\n  int ttime;\n  struct archive_string_conv *sconv, *fn_sconv;\n  unsigned long crc32_val;\n  int ret = (ARCHIVE_OK), ret2;\n\n  rar = (struct rar *)(a->format->data);\n\n  /* Setup a string conversion object for non-rar-unicode filenames. */\n  sconv = rar->opt_sconv;\n  if (sconv == NULL) {\n    if (!rar->init_default_conversion) {\n      rar->sconv_default =\n          archive_string_default_conversion_for_read(\n            &(a->archive));\n      rar->init_default_conversion = 1;\n    }\n    sconv = rar->sconv_default;\n  }\n\n\n  if ((h = __archive_read_ahead(a, 7, NULL)) == NULL)\n    return (ARCHIVE_FATAL);\n  p = h;\n  memcpy(&rar_header, p, sizeof(rar_header));\n  rar->file_flags = archive_le16dec(rar_header.flags);\n  header_size = archive_le16dec(rar_header.size);\n  if (header_size < (int64_t)sizeof(file_header) + 7) {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n      \"Invalid header size\");\n    return (ARCHIVE_FATAL);\n  }\n  crc32_val = crc32(0, (const unsigned char *)p + 2, 7 - 2);\n  __archive_read_consume(a, 7);\n\n  if (!(rar->file_flags & FHD_SOLID))\n  {\n    rar->compression_method = 0;\n    rar->packed_size = 0;\n    rar->unp_size = 0;\n    rar->mtime = 0;\n    rar->ctime = 0;\n    rar->atime = 0;\n    rar->arctime = 0;\n    rar->mode = 0;\n    memset(&rar->salt, 0, sizeof(rar->salt));\n    rar->atime = 0;\n    rar->ansec = 0;\n    rar->ctime = 0;\n    rar->cnsec = 0;\n    rar->mtime = 0;\n    rar->mnsec = 0;\n    rar->arctime = 0;\n    rar->arcnsec = 0;\n  }\n  else\n  {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"RAR solid archive support unavailable.\");\n    return (ARCHIVE_FATAL);\n  }\n\n  if ((h = __archive_read_ahead(a, (size_t)header_size - 7, NULL)) == NULL)\n    return (ARCHIVE_FATAL);\n\n  /* File Header CRC check. */\n  crc32_val = crc32(crc32_val, h, (unsigned)(header_size - 7));\n  if ((crc32_val & 0xffff) != archive_le16dec(rar_header.crc)) {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n      \"Header CRC error\");\n    return (ARCHIVE_FATAL);\n  }\n  /* If no CRC error, Go on parsing File Header. */\n  p = h;\n  endp = p + header_size - 7;\n  memcpy(&file_header, p, sizeof(file_header));\n  p += sizeof(file_header);\n\n  rar->compression_method = file_header.method;\n\n  ttime = archive_le32dec(file_header.file_time);\n  rar->mtime = get_time(ttime);\n\n  rar->file_crc = archive_le32dec(file_header.file_crc);\n\n  if (rar->file_flags & FHD_PASSWORD)\n  {\n\tarchive_entry_set_is_data_encrypted(entry, 1);\n\trar->has_encrypted_entries = 1;\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"RAR encryption support unavailable.\");\n    /* Since it is only the data part itself that is encrypted we can at least\n       extract information about the currently processed entry and don't need\n       to return ARCHIVE_FATAL here. */\n    /*return (ARCHIVE_FATAL);*/\n  }\n\n  if (rar->file_flags & FHD_LARGE)\n  {\n    memcpy(packed_size, file_header.pack_size, 4);\n    memcpy(packed_size + 4, p, 4); /* High pack size */\n    p += 4;\n    memcpy(unp_size, file_header.unp_size, 4);\n    memcpy(unp_size + 4, p, 4); /* High unpack size */\n    p += 4;\n    rar->packed_size = archive_le64dec(&packed_size);\n    rar->unp_size = archive_le64dec(&unp_size);\n  }\n  else\n  {\n    rar->packed_size = archive_le32dec(file_header.pack_size);\n    rar->unp_size = archive_le32dec(file_header.unp_size);\n  }\n\n  if (rar->packed_size < 0 || rar->unp_size < 0)\n  {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"Invalid sizes specified.\");\n    return (ARCHIVE_FATAL);\n  }\n\n  rar->bytes_remaining = rar->packed_size;\n\n  /* TODO: RARv3 subblocks contain comments. For now the complete block is\n   * consumed at the end.\n   */\n  if (head_type == NEWSUB_HEAD) {\n    size_t distance = p - (const char *)h;\n    header_size += rar->packed_size;\n    /* Make sure we have the extended data. */\n    if ((h = __archive_read_ahead(a, (size_t)header_size - 7, NULL)) == NULL)\n        return (ARCHIVE_FATAL);\n    p = h;\n    endp = p + header_size - 7;\n    p += distance;\n  }\n\n  filename_size = archive_le16dec(file_header.name_size);\n  if (p + filename_size > endp) {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n      \"Invalid filename size\");\n    return (ARCHIVE_FATAL);\n  }\n  if (rar->filename_allocated < filename_size * 2 + 2) {\n    char *newptr;\n    size_t newsize = filename_size * 2 + 2;\n    newptr = realloc(rar->filename, newsize);\n    if (newptr == NULL) {\n      archive_set_error(&a->archive, ENOMEM,\n                        \"Couldn't allocate memory.\");\n      return (ARCHIVE_FATAL);\n    }\n    rar->filename = newptr;\n    rar->filename_allocated = newsize;\n  }\n  filename = rar->filename;\n  memcpy(filename, p, filename_size);\n  filename[filename_size] = '\\0';\n  if (rar->file_flags & FHD_UNICODE)\n  {\n    if (filename_size != strlen(filename))\n    {\n      unsigned char highbyte, flagbits, flagbyte;\n      unsigned fn_end, offset;\n\n      end = filename_size;\n      fn_end = filename_size * 2;\n      filename_size = 0;\n      offset = (unsigned)strlen(filename) + 1;\n      highbyte = *(p + offset++);\n      flagbits = 0;\n      flagbyte = 0;\n      while (offset < end && filename_size < fn_end)\n      {\n        if (!flagbits)\n        {\n          flagbyte = *(p + offset++);\n          flagbits = 8;\n        }\n\n        flagbits -= 2;\n        switch((flagbyte >> flagbits) & 3)\n        {\n          case 0:\n            filename[filename_size++] = '\\0';\n            filename[filename_size++] = *(p + offset++);\n            break;\n          case 1:\n            filename[filename_size++] = highbyte;\n            filename[filename_size++] = *(p + offset++);\n            break;\n          case 2:\n            filename[filename_size++] = *(p + offset + 1);\n            filename[filename_size++] = *(p + offset);\n            offset += 2;\n            break;\n          case 3:\n          {\n            char extra, high;\n            uint8_t length = *(p + offset++);\n\n            if (length & 0x80) {\n              extra = *(p + offset++);\n              high = (char)highbyte;\n            } else\n              extra = high = 0;\n            length = (length & 0x7f) + 2;\n            while (length && filename_size < fn_end) {\n              unsigned cp = filename_size >> 1;\n              filename[filename_size++] = high;\n              filename[filename_size++] = p[cp] + extra;\n              length--;\n            }\n          }\n          break;\n        }\n      }\n      if (filename_size > fn_end) {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n          \"Invalid filename\");\n        return (ARCHIVE_FATAL);\n      }\n      filename[filename_size++] = '\\0';\n      /*\n       * Do not increment filename_size here as the computations below\n       * add the space for the terminating NUL explicitly.\n       */\n      filename[filename_size] = '\\0';\n\n      /* Decoded unicode form is UTF-16BE, so we have to update a string\n       * conversion object for it. */\n      if (rar->sconv_utf16be == NULL) {\n        rar->sconv_utf16be = archive_string_conversion_from_charset(\n           &a->archive, \"UTF-16BE\", 1);\n        if (rar->sconv_utf16be == NULL)\n          return (ARCHIVE_FATAL);\n      }\n      fn_sconv = rar->sconv_utf16be;\n\n      strp = filename;\n      while (memcmp(strp, \"\\x00\\x00\", 2))\n      {\n        if (!memcmp(strp, \"\\x00\\\\\", 2))\n          *(strp + 1) = '/';\n        strp += 2;\n      }\n      p += offset;\n    } else {\n      /*\n       * If FHD_UNICODE is set but no unicode data, this file name form\n       * is UTF-8, so we have to update a string conversion object for\n       * it accordingly.\n       */\n      if (rar->sconv_utf8 == NULL) {\n        rar->sconv_utf8 = archive_string_conversion_from_charset(\n           &a->archive, \"UTF-8\", 1);\n        if (rar->sconv_utf8 == NULL)\n          return (ARCHIVE_FATAL);\n      }\n      fn_sconv = rar->sconv_utf8;\n      while ((strp = strchr(filename, '\\\\')) != NULL)\n        *strp = '/';\n      p += filename_size;\n    }\n  }\n  else\n  {\n    fn_sconv = sconv;\n    while ((strp = strchr(filename, '\\\\')) != NULL)\n      *strp = '/';\n    p += filename_size;\n  }\n\n  /* Split file in multivolume RAR. No more need to process header. */\n  if (rar->filename_save &&\n    filename_size == rar->filename_save_size &&\n    !memcmp(rar->filename, rar->filename_save, filename_size + 1))\n  {\n    __archive_read_consume(a, header_size - 7);\n    rar->cursor++;\n    if (rar->cursor >= rar->nodes)\n    {\n      rar->nodes++;\n      if ((rar->dbo =\n        realloc(rar->dbo, sizeof(*rar->dbo) * rar->nodes)) == NULL)\n      {\n        archive_set_error(&a->archive, ENOMEM, \"Couldn't allocate memory.\");\n        return (ARCHIVE_FATAL);\n      }\n      rar->dbo[rar->cursor].header_size = header_size;\n      rar->dbo[rar->cursor].start_offset = -1;\n      rar->dbo[rar->cursor].end_offset = -1;\n    }\n    if (rar->dbo[rar->cursor].start_offset < 0)\n    {\n      rar->dbo[rar->cursor].start_offset = a->filter->position;\n      rar->dbo[rar->cursor].end_offset = rar->dbo[rar->cursor].start_offset +\n        rar->packed_size;\n    }\n    return ret;\n  }\n  else if (rar->filename_must_match)\n  {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n      \"Mismatch of file parts split across multi-volume archive\");\n    return (ARCHIVE_FATAL);\n  }\n\n  rar->filename_save = (char*)realloc(rar->filename_save,\n                                      filename_size + 1);\n  memcpy(rar->filename_save, rar->filename, filename_size + 1);\n  rar->filename_save_size = filename_size;\n\n  /* Set info for seeking */\n  free(rar->dbo);\n  if ((rar->dbo = calloc(1, sizeof(*rar->dbo))) == NULL)\n  {\n    archive_set_error(&a->archive, ENOMEM, \"Couldn't allocate memory.\");\n    return (ARCHIVE_FATAL);\n  }\n  rar->dbo[0].header_size = header_size;\n  rar->dbo[0].start_offset = -1;\n  rar->dbo[0].end_offset = -1;\n  rar->cursor = 0;\n  rar->nodes = 1;\n\n  if (rar->file_flags & FHD_SALT)\n  {\n    if (p + 8 > endp) {\n      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n        \"Invalid header size\");\n      return (ARCHIVE_FATAL);\n    }\n    memcpy(rar->salt, p, 8);\n    p += 8;\n  }\n\n  if (rar->file_flags & FHD_EXTTIME) {\n    if (read_exttime(p, rar, endp) < 0) {\n      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n        \"Invalid header size\");\n      return (ARCHIVE_FATAL);\n    }\n  }\n\n  __archive_read_consume(a, header_size - 7);\n  rar->dbo[0].start_offset = a->filter->position;\n  rar->dbo[0].end_offset = rar->dbo[0].start_offset + rar->packed_size;\n\n  switch(file_header.host_os)\n  {\n  case OS_MSDOS:\n  case OS_OS2:\n  case OS_WIN32:\n    rar->mode = archive_le32dec(file_header.file_attr);\n    if (rar->mode & FILE_ATTRIBUTE_DIRECTORY)\n      rar->mode = AE_IFDIR | S_IXUSR | S_IXGRP | S_IXOTH;\n    else\n      rar->mode = AE_IFREG;\n    rar->mode |= S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;\n    break;\n\n  case OS_UNIX:\n  case OS_MAC_OS:\n  case OS_BEOS:\n    rar->mode = archive_le32dec(file_header.file_attr);\n    break;\n\n  default:\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"Unknown file attributes from RAR file's host OS\");\n    return (ARCHIVE_FATAL);\n  }\n\n  rar->bytes_uncopied = rar->bytes_unconsumed = 0;\n  rar->lzss.position = rar->offset = 0;\n  rar->offset_seek = 0;\n  rar->dictionary_size = 0;\n  rar->offset_outgoing = 0;\n  rar->br.cache_avail = 0;\n  rar->br.avail_in = 0;\n  rar->crc_calculated = 0;\n  rar->entry_eof = 0;\n  rar->valid = 1;\n  rar->is_ppmd_block = 0;\n  rar->start_new_table = 1;\n  free(rar->unp_buffer);\n  rar->unp_buffer = NULL;\n  rar->unp_offset = 0;\n  rar->unp_buffer_size = UNP_BUFFER_SIZE;\n  memset(rar->lengthtable, 0, sizeof(rar->lengthtable));\n  __archive_ppmd7_functions.Ppmd7_Free(&rar->ppmd7_context);\n  rar->ppmd_valid = rar->ppmd_eod = 0;\n\n  /* Don't set any archive entries for non-file header types */\n  if (head_type == NEWSUB_HEAD)\n    return ret;\n\n  archive_entry_set_mtime(entry, rar->mtime, rar->mnsec);\n  archive_entry_set_ctime(entry, rar->ctime, rar->cnsec);\n  archive_entry_set_atime(entry, rar->atime, rar->ansec);\n  archive_entry_set_size(entry, rar->unp_size);\n  archive_entry_set_mode(entry, rar->mode);\n\n  if (archive_entry_copy_pathname_l(entry, filename, filename_size, fn_sconv))\n  {\n    if (errno == ENOMEM)\n    {\n      archive_set_error(&a->archive, ENOMEM,\n                        \"Can't allocate memory for Pathname\");\n      return (ARCHIVE_FATAL);\n    }\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"Pathname cannot be converted from %s to current locale.\",\n                      archive_string_conversion_charset_name(fn_sconv));\n    ret = (ARCHIVE_WARN);\n  }\n\n  if (((rar->mode) & AE_IFMT) == AE_IFLNK)\n  {\n    /* Make sure a symbolic-link file does not have its body. */\n    rar->bytes_remaining = 0;\n    archive_entry_set_size(entry, 0);\n\n    /* Read a symbolic-link name. */\n    if ((ret2 = read_symlink_stored(a, entry, sconv)) < (ARCHIVE_WARN))\n      return ret2;\n    if (ret > ret2)\n      ret = ret2;\n  }\n\n  if (rar->bytes_remaining == 0)\n    rar->entry_eof = 1;\n\n  return ret;\n}",
  "abstract_func": "static int\nread_header(struct archive_read *VAR_0, struct archive_entry *VAR_1,\n            char VAR_2)\n{\n  const void *VAR_3;\n  const char *VAR_4, *VAR_5;\n  struct rar *rar;\n  struct rar_header rar_header;\n  struct rar_file_header VAR_6;\n  int64_t VAR_7;\n  unsigned VAR_8, VAR_9;\n  char *VAR_10;\n  char *VAR_11;\n  char VAR_12[8];\n  char VAR_13[8];\n  int VAR_14;\n  struct archive_string_conv *VAR_15, *VAR_16;\n  unsigned long VAR_17;\n  int VAR_18 = (VAR_19), VAR_20;\n\n  rar = (struct rar *)(VAR_0->format->data);\n\n  /* COMMENT_0 */\n  VAR_15 = rar->opt_sconv;\n  if (VAR_15 == NULL) {\n    if (!rar->init_default_conversion) {\n      rar->sconv_default =\n          archive_string_default_conversion_for_read(\n            &(VAR_0->archive));\n      rar->init_default_conversion = 1;\n    }\n    VAR_15 = rar->sconv_default;\n  }\n\n\n  if ((VAR_3 = __archive_read_ahead(VAR_0, 7, NULL)) == NULL)\n    return (VAR_21);\n  VAR_4 = VAR_3;\n  memcpy(&rar_header, VAR_4, sizeof(rar_header));\n  rar->file_flags = archive_le16dec(rar_header.flags);\n  VAR_7 = archive_le16dec(rar_header.size);\n  if (VAR_7 < (int64_t)sizeof(VAR_6) + 7) {\n    archive_set_error(&VAR_0->archive, VAR_22,\n      \"Invalid header size\");\n    return (VAR_21);\n  }\n  VAR_17 = crc32(0, (const unsigned char *)VAR_4 + 2, 7 - 2);\n  __archive_read_consume(VAR_0, 7);\n\n  if (!(rar->file_flags & VAR_23))\n  {\n    rar->compression_method = 0;\n    rar->packed_size = 0;\n    rar->unp_size = 0;\n    rar->mtime = 0;\n    rar->ctime = 0;\n    rar->atime = 0;\n    rar->arctime = 0;\n    rar->mode = 0;\n    memset(&rar->salt, 0, sizeof(rar->salt));\n    rar->atime = 0;\n    rar->ansec = 0;\n    rar->ctime = 0;\n    rar->cnsec = 0;\n    rar->mtime = 0;\n    rar->mnsec = 0;\n    rar->arctime = 0;\n    rar->arcnsec = 0;\n  }\n  else\n  {\n    archive_set_error(&VAR_0->archive, VAR_22,\n                      \"RAR solid archive support unavailable.\");\n    return (VAR_21);\n  }\n\n  if ((VAR_3 = __archive_read_ahead(VAR_0, (size_t)VAR_7 - 7, NULL)) == NULL)\n    return (VAR_21);\n\n  /* COMMENT_1 */\n  VAR_17 = crc32(VAR_17, VAR_3, (unsigned)(VAR_7 - 7));\n  if ((VAR_17 & 0xffff) != archive_le16dec(rar_header.crc)) {\n    archive_set_error(&VAR_0->archive, VAR_22,\n      \"Header CRC error\");\n    return (VAR_21);\n  }\n  /* COMMENT_2 */\n  VAR_4 = VAR_3;\n  VAR_5 = VAR_4 + VAR_7 - 7;\n  memcpy(&VAR_6, VAR_4, sizeof(VAR_6));\n  VAR_4 += sizeof(VAR_6);\n\n  rar->compression_method = VAR_6.method;\n\n  VAR_14 = archive_le32dec(VAR_6.file_time);\n  rar->mtime = get_time(VAR_14);\n\n  rar->file_crc = archive_le32dec(VAR_6.file_crc);\n\n  if (rar->file_flags & VAR_24)\n  {\n\tarchive_entry_set_is_data_encrypted(VAR_1, 1);\n\trar->has_encrypted_entries = 1;\n    archive_set_error(&VAR_0->archive, VAR_22,\n                      \"RAR encryption support unavailable.\");\n    /* COMMENT_3 */\n                                                                             \n                                       \n    /* COMMENT_6 */\n  }\n\n  if (rar->file_flags & VAR_25)\n  {\n    memcpy(VAR_12, VAR_6.pack_size, 4);\n    memcpy(VAR_12 + 4, VAR_4, 4); /* COMMENT_7 */\n    VAR_4 += 4;\n    memcpy(VAR_13, VAR_6.unp_size, 4);\n    memcpy(VAR_13 + 4, VAR_4, 4); /* COMMENT_8 */\n    VAR_4 += 4;\n    rar->packed_size = archive_le64dec(&VAR_12);\n    rar->unp_size = archive_le64dec(&VAR_13);\n  }\n  else\n  {\n    rar->packed_size = archive_le32dec(VAR_6.pack_size);\n    rar->unp_size = archive_le32dec(VAR_6.unp_size);\n  }\n\n  if (rar->packed_size < 0 || rar->unp_size < 0)\n  {\n    archive_set_error(&VAR_0->archive, VAR_22,\n                      \"Invalid sizes specified.\");\n    return (VAR_21);\n  }\n\n  rar->bytes_remaining = rar->packed_size;\n\n  /* COMMENT_9 */\n                         \n     \n  if (VAR_2 == VAR_26) {\n    size_t VAR_27 = VAR_4 - (const char *)VAR_3;\n    VAR_7 += rar->packed_size;\n    /* COMMENT_12 */\n    if ((VAR_3 = __archive_read_ahead(VAR_0, (size_t)VAR_7 - 7, NULL)) == NULL)\n        return (VAR_21);\n    VAR_4 = VAR_3;\n    VAR_5 = VAR_4 + VAR_7 - 7;\n    VAR_4 += VAR_27;\n  }\n\n  VAR_8 = archive_le16dec(VAR_6.name_size);\n  if (VAR_4 + VAR_8 > VAR_5) {\n    archive_set_error(&VAR_0->archive, VAR_22,\n      \"Invalid filename size\");\n    return (VAR_21);\n  }\n  if (rar->filename_allocated < VAR_8 * 2 + 2) {\n    char *VAR_28;\n    size_t VAR_29 = VAR_8 * 2 + 2;\n    VAR_28 = realloc(rar->filename, VAR_29);\n    if (VAR_28 == NULL) {\n      archive_set_error(&VAR_0->archive, VAR_30,\n                        \"Couldn't allocate memory.\");\n      return (VAR_21);\n    }\n    rar->filename = VAR_28;\n    rar->filename_allocated = VAR_29;\n  }\n  VAR_10 = rar->filename;\n  memcpy(VAR_10, VAR_4, VAR_8);\n  VAR_10[VAR_8] = '\\0';\n  if (rar->file_flags & VAR_31)\n  {\n    if (VAR_8 != strlen(VAR_10))\n    {\n      unsigned char VAR_32, VAR_33, VAR_34;\n      unsigned VAR_35, VAR_36;\n\n      VAR_9 = VAR_8;\n      VAR_35 = VAR_8 * 2;\n      VAR_8 = 0;\n      VAR_36 = (unsigned)strlen(VAR_10) + 1;\n      VAR_32 = *(VAR_4 + VAR_36++);\n      VAR_33 = 0;\n      VAR_34 = 0;\n      while (VAR_36 < VAR_9 && VAR_8 < VAR_35)\n      {\n        if (!VAR_33)\n        {\n          VAR_34 = *(VAR_4 + VAR_36++);\n          VAR_33 = 8;\n        }\n\n        VAR_33 -= 2;\n        switch((VAR_34 >> VAR_33) & 3)\n        {\n          case 0:\n            VAR_10[VAR_8++] = '\\0';\n            VAR_10[VAR_8++] = *(VAR_4 + VAR_36++);\n            break;\n          case 1:\n            VAR_10[VAR_8++] = VAR_32;\n            VAR_10[VAR_8++] = *(VAR_4 + VAR_36++);\n            break;\n          case 2:\n            VAR_10[VAR_8++] = *(VAR_4 + VAR_36 + 1);\n            VAR_10[VAR_8++] = *(VAR_4 + VAR_36);\n            VAR_36 += 2;\n            break;\n          case 3:\n          {\n            char VAR_37, VAR_38;\n            uint8_t VAR_39 = *(VAR_4 + VAR_36++);\n\n            if (VAR_39 & 0x80) {\n              VAR_37 = *(VAR_4 + VAR_36++);\n              VAR_38 = (char)VAR_32;\n            } else\n              VAR_37 = VAR_38 = 0;\n            VAR_39 = (VAR_39 & 0x7f) + 2;\n            while (VAR_39 && VAR_8 < VAR_35) {\n              unsigned VAR_40 = VAR_8 >> 1;\n              VAR_10[VAR_8++] = VAR_38;\n              VAR_10[VAR_8++] = VAR_4[VAR_40] + VAR_37;\n              VAR_39--;\n            }\n          }\n          break;\n        }\n      }\n      if (VAR_8 > VAR_35) {\n        archive_set_error(&VAR_0->archive, VAR_22,\n          \"Invalid filename\");\n        return (VAR_21);\n      }\n      VAR_10[VAR_8++] = '\\0';\n      /* COMMENT_13 */\n                                                                      \n                                                          \n         \n      VAR_10[VAR_8] = '\\0';\n\n      /* COMMENT_17 */\n                                     \n      if (rar->sconv_utf16be == NULL) {\n        rar->sconv_utf16be = archive_string_conversion_from_charset(\n           &VAR_0->archive, \"UTF-16BE\", 1);\n        if (rar->sconv_utf16be == NULL)\n          return (VAR_21);\n      }\n      VAR_16 = rar->sconv_utf16be;\n\n      VAR_11 = VAR_10;\n      while (memcmp(VAR_11, \"\\x00\\x00\", 2))\n      {\n        if (!memcmp(VAR_11, \"\\x00\\\\\", 2))\n          *(VAR_11 + 1) = '/';\n        VAR_11 += 2;\n      }\n      VAR_4 += VAR_36;\n    } else {\n      /* COMMENT_19 */\n                                                                       \n                                                                      \n                        \n         \n      if (rar->sconv_utf8 == NULL) {\n        rar->sconv_utf8 = archive_string_conversion_from_charset(\n           &VAR_0->archive, \"UTF-8\", 1);\n        if (rar->sconv_utf8 == NULL)\n          return (VAR_21);\n      }\n      VAR_16 = rar->sconv_utf8;\n      while ((VAR_11 = strchr(VAR_10, '\\\\')) != NULL)\n        *VAR_11 = '/';\n      VAR_4 += VAR_8;\n    }\n  }\n  else\n  {\n    VAR_16 = VAR_15;\n    while ((VAR_11 = strchr(VAR_10, '\\\\')) != NULL)\n      *VAR_11 = '/';\n    VAR_4 += VAR_8;\n  }\n\n  /* COMMENT_24 */\n  if (rar->filename_save &&\n    VAR_8 == rar->filename_save_size &&\n    !memcmp(rar->filename, rar->filename_save, VAR_8 + 1))\n  {\n    __archive_read_consume(VAR_0, VAR_7 - 7);\n    rar->cursor++;\n    if (rar->cursor >= rar->nodes)\n    {\n      rar->nodes++;\n      if ((rar->dbo =\n        realloc(rar->dbo, sizeof(*rar->dbo) * rar->nodes)) == NULL)\n      {\n        archive_set_error(&VAR_0->archive, VAR_30, \"Couldn't allocate memory.\");\n        return (VAR_21);\n      }\n      rar->dbo[rar->cursor].header_size = VAR_7;\n      rar->dbo[rar->cursor].start_offset = -1;\n      rar->dbo[rar->cursor].end_offset = -1;\n    }\n    if (rar->dbo[rar->cursor].start_offset < 0)\n    {\n      rar->dbo[rar->cursor].start_offset = VAR_0->filter->position;\n      rar->dbo[rar->cursor].end_offset = rar->dbo[rar->cursor].start_offset +\n        rar->packed_size;\n    }\n    return VAR_18;\n  }\n  else if (rar->filename_must_match)\n  {\n    archive_set_error(&VAR_0->archive, VAR_22,\n      \"Mismatch of file parts split across multi-volume archive\");\n    return (VAR_21);\n  }\n\n  rar->filename_save = (char*)realloc(rar->filename_save,\n                                      VAR_8 + 1);\n  memcpy(rar->filename_save, rar->filename, VAR_8 + 1);\n  rar->filename_save_size = VAR_8;\n\n  /* COMMENT_25 */\n  free(rar->dbo);\n  if ((rar->dbo = calloc(1, sizeof(*rar->dbo))) == NULL)\n  {\n    archive_set_error(&VAR_0->archive, VAR_30, \"Couldn't allocate memory.\");\n    return (VAR_21);\n  }\n  rar->dbo[0].header_size = VAR_7;\n  rar->dbo[0].start_offset = -1;\n  rar->dbo[0].end_offset = -1;\n  rar->cursor = 0;\n  rar->nodes = 1;\n\n  if (rar->file_flags & VAR_41)\n  {\n    if (VAR_4 + 8 > VAR_5) {\n      archive_set_error(&VAR_0->archive, VAR_22,\n        \"Invalid header size\");\n      return (VAR_21);\n    }\n    memcpy(rar->salt, VAR_4, 8);\n    VAR_4 += 8;\n  }\n\n  if (rar->file_flags & VAR_42) {\n    if (read_exttime(VAR_4, rar, VAR_5) < 0) {\n      archive_set_error(&VAR_0->archive, VAR_22,\n        \"Invalid header size\");\n      return (VAR_21);\n    }\n  }\n\n  __archive_read_consume(VAR_0, VAR_7 - 7);\n  rar->dbo[0].start_offset = VAR_0->filter->position;\n  rar->dbo[0].end_offset = rar->dbo[0].start_offset + rar->packed_size;\n\n  switch(VAR_6.host_os)\n  {\n  case VAR_43:\n  case VAR_44:\n  case VAR_45:\n    rar->mode = archive_le32dec(VAR_6.file_attr);\n    if (rar->mode & VAR_46)\n      rar->mode = VAR_47 | VAR_48 | VAR_49 | VAR_50;\n    else\n      rar->mode = VAR_51;\n    rar->mode |= VAR_52 | VAR_53 | VAR_54 | VAR_55;\n    break;\n\n  case VAR_56:\n  case VAR_57:\n  case VAR_58:\n    rar->mode = archive_le32dec(VAR_6.file_attr);\n    break;\n\n  default:\n    archive_set_error(&VAR_0->archive, VAR_22,\n                      \"Unknown file attributes from RAR file's host OS\");\n    return (VAR_21);\n  }\n\n  rar->bytes_uncopied = rar->bytes_unconsumed = 0;\n  rar->lzss.position = rar->offset = 0;\n  rar->offset_seek = 0;\n  rar->dictionary_size = 0;\n  rar->offset_outgoing = 0;\n  rar->br.cache_avail = 0;\n  rar->br.avail_in = 0;\n  rar->crc_calculated = 0;\n  rar->entry_eof = 0;\n  rar->valid = 1;\n  rar->is_ppmd_block = 0;\n  rar->start_new_table = 1;\n  free(rar->unp_buffer);\n  rar->unp_buffer = NULL;\n  rar->unp_offset = 0;\n  rar->unp_buffer_size = VAR_59;\n  memset(rar->lengthtable, 0, sizeof(rar->lengthtable));\n  VAR_60.Ppmd7_Free(&rar->ppmd7_context);\n  rar->ppmd_valid = rar->ppmd_eod = 0;\n\n  /* COMMENT_26 */\n  if (VAR_2 == VAR_26)\n    return VAR_18;\n\n  archive_entry_set_mtime(VAR_1, rar->mtime, rar->mnsec);\n  archive_entry_set_ctime(VAR_1, rar->ctime, rar->cnsec);\n  archive_entry_set_atime(VAR_1, rar->atime, rar->ansec);\n  archive_entry_set_size(VAR_1, rar->unp_size);\n  archive_entry_set_mode(VAR_1, rar->mode);\n\n  if (archive_entry_copy_pathname_l(VAR_1, VAR_10, VAR_8, VAR_16))\n  {\n    if (VAR_61 == VAR_30)\n    {\n      archive_set_error(&VAR_0->archive, VAR_30,\n                        \"Can't allocate memory for Pathname\");\n      return (VAR_21);\n    }\n    archive_set_error(&VAR_0->archive, VAR_22,\n                      \"Pathname cannot be converted from %s to current locale.\",\n                      archive_string_conversion_charset_name(VAR_16));\n    VAR_18 = (VAR_62);\n  }\n\n  if (((rar->mode) & VAR_63) == VAR_64)\n  {\n    /* COMMENT_27 */\n    rar->bytes_remaining = 0;\n    archive_entry_set_size(VAR_1, 0);\n\n    /* COMMENT_28 */\n    if ((VAR_20 = read_symlink_stored(VAR_0, VAR_1, VAR_15)) < (VAR_62))\n      return VAR_20;\n    if (VAR_18 > VAR_20)\n      VAR_18 = VAR_20;\n  }\n\n  if (rar->bytes_remaining == 0)\n    rar->entry_eof = 1;\n\n  return VAR_18;\n}",
  "func_graph_path": "libarchive/bfcfe6f04ed20db2504db8a254d1f40a1d84eb28/archive_read_support_format_rar.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -313,6 +313,12 @@\n     }\n     return ret;\n   }\n+  else if (rar->filename_must_match)\n+  {\n+    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n+      \"Mismatch of file parts split across multi-volume archive\");\n+    return (ARCHIVE_FATAL);\n+  }\n \n   rar->filename_save = (char*)realloc(rar->filename_save,\n                                       filename_size + 1);",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "  else if (rar->filename_must_match)",
      "  {",
      "    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,",
      "      \"Mismatch of file parts split across multi-volume archive\");",
      "    return (ARCHIVE_FATAL);",
      "  }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libarchive/libarchive/pull/1105",
  "description": {
    "pr_info": {
      "title": "Fix various crash, memory corruption and infinite loop conditions",
      "number": 1105
    },
    "comment": [
      "I have found some hangs, crashes and memory corruption issues in libarchive.\r\n\r\nTwo are in the RAR decoder. The first (patch 1) is a double-free via a `realloc(area, 0)`. This leads to a crash.\r\n\r\nThe second (patch 2) is memory corruption which seems to arise in ppmd7 decoding. The code can be made to read and write to a previously freed ppmd buffer by tricking the read-ahead code around multi-part archives. (This can be done even with a single archive file.) My gut feeling is that someone more skilled than I could cause arbitrary code execution with this, but I cannot say for certain.\r\n\r\nThere is a crash in ACL parsing for tar archives (patch 3). This is a simple NULL dereference leading to a crash.\r\n\r\nThe last of this batch is a quasi-infinite loop in the warc code (patch 4), where data isn't consumed after being written out, so a large Content-Length can be used to consume almost limitless time and space, leading to a DoS condition.\r\n\r\nThese were found with a combination of AFL, afl-rb and qsym.",
      "There are some test cases at https://bugs.launchpad.net/ubuntu/+source/libarchive/+bug/1794909\r\n\r\n",
      "I have requested CVEs for these issues through the Distributed Weakness Filing project.",
      "In case someone else is looking for the CVEs, it looks like the assignments are :\r\n- CVE-2018-1000877 for https://github.com/libarchive/libarchive/commit/021efa522ad729ff0f5806c4ce53e4a6cc1daa31\r\n- CVE-2018-1000878 for https://github.com/libarchive/libarchive/commit/bfcfe6f04ed20db2504db8a254d1f40a1d84eb28\r\n- CVE-2018-1000879 for https://github.com/libarchive/libarchive/commit/15bf44fd2c1ad0e3fd87048b3fcc90c4dcff1175\r\n- CVE-2018-1000880 for https://github.com/libarchive/libarchive/commit/9c84b7426660c09c18cc349f6d70b5f8168b5680"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix\n\nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses a Use After Free (UAF) vulnerability in the handling of multi-part RAR archives. The commit message and code changes indicate that the patch prevents accessing a freed buffer by checking for a filename mismatch, thus mitigating a security flaw.\n\nFinal Classification: Security Vulnerability Fix\n\nConfidence Score: 0.95"
}