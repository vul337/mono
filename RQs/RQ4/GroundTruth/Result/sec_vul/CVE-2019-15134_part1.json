{
  "cve_id": "CVE-2019-15134",
  "cwe_ids": [
    "CWE-401"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:C",
  "cvss_is_v3": false,
  "repo_name": "RIOT-OS/RIOT",
  "commit_msg": "gnrc_tcp: Fix memory leak",
  "commit_hash": "c6df2064aff1ffb4015d4cedbaefb8850cb50aa8",
  "git_url": "https://github.com/RIOT-OS/RIOT/commit/c6df2064aff1ffb4015d4cedbaefb8850cb50aa8",
  "file_path": "sys/net/gnrc/transport_layer/tcp/gnrc_tcp_eventloop.c",
  "func_name": "_receive",
  "func_before": "static int _receive(gnrc_pktsnip_t *pkt)\n{\n    /* NOTE: In receiving direction: pkt = payload, payload->next = tcp, tcp->next = nw */\n    uint16_t ctl = 0;\n    uint16_t src = 0;\n    uint16_t dst = 0;\n    uint8_t hdr_size = 0;\n    uint8_t syn = 0;\n    gnrc_pktsnip_t *ip = NULL;\n    gnrc_pktsnip_t *reset = NULL;\n    gnrc_tcp_tcb_t *tcb = NULL;\n    tcp_hdr_t *hdr;\n\n    /* Get write access to the TCP header */\n    gnrc_pktsnip_t *tcp = gnrc_pktbuf_start_write(pkt);\n    if (tcp == NULL) {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : can't write to packet\\n\");\n        gnrc_pktbuf_release(pkt);\n        return -EACCES;\n    }\n    pkt = tcp;\n\n#ifdef MODULE_GNRC_IPV6\n    /* Get IPv6 header, discard packet if doesn't contain an ip header */\n    LL_SEARCH_SCALAR(pkt, ip, type, GNRC_NETTYPE_IPV6);\n    if (ip == NULL) {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : pkt contains no IP Header\\n\");\n        gnrc_pktbuf_release(pkt);\n        return 0;\n    }\n#endif\n\n    /* Get TCP header */\n    LL_SEARCH_SCALAR(pkt, tcp, type, GNRC_NETTYPE_TCP);\n    if (tcp == NULL) {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : pkt contains no TCP Header\\n\");\n        gnrc_pktbuf_release(pkt);\n        return 0;\n    }\n\n    /* Extract control bits, src and dst ports and check if SYN is set (not SYN+ACK) */\n    hdr = (tcp_hdr_t *)tcp->data;\n    ctl = byteorder_ntohs(hdr->off_ctl);\n    src = byteorder_ntohs(hdr->src_port);\n    dst = byteorder_ntohs(hdr->dst_port);\n    syn = ((ctl & MSK_SYN_ACK) == MSK_SYN);\n\n    /* Validate offset */\n    if (GET_OFFSET(ctl) < TCP_HDR_OFFSET_MIN) {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : unexpected Offset Value\\n\");\n        gnrc_pktbuf_release(pkt);\n        return -ERANGE;\n    }\n\n    /* Calculate TCP header size */\n    hdr_size = GET_OFFSET(ctl) * 4;\n\n    /* Mark TCP header if it contains any payload */\n    if ((pkt->type == GNRC_NETTYPE_TCP) && (pkt->size != hdr_size)) {\n        tcp = gnrc_pktbuf_mark(pkt, hdr_size, GNRC_NETTYPE_TCP);\n        if (tcp == NULL) {\n            DEBUG(\"gnrc_tcp_eventloop.c : _receive() : Header marking failed\\n\");\n            gnrc_pktbuf_release(pkt);\n            return -ENOMSG;\n        }\n        pkt->type = GNRC_NETTYPE_UNDEF;\n    }\n\n    /* Validate checksum */\n    if (byteorder_ntohs(hdr->checksum) != _pkt_calc_csum(tcp, ip, pkt)) {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : Invalid checksum\\n\");\n        gnrc_pktbuf_release(pkt);\n        return -EINVAL;\n    }\n\n    /* Find TCB to for this packet */\n    mutex_lock(&_list_tcb_lock);\n    tcb = _list_tcb_head;\n    while (tcb) {\n#ifdef MODULE_GNRC_IPV6\n        /* Check if current TCB is fitting for the incomming packet */\n        if (ip->type == GNRC_NETTYPE_IPV6 && tcb->address_family == AF_INET6) {\n            /* If SYN is set, a connection is listening on that port ... */\n            ipv6_addr_t *tmp_addr = NULL;\n            if (syn && tcb->local_port == dst && tcb->state == FSM_STATE_LISTEN) {\n                /* ... and local addr is unspec or pre configured */\n                tmp_addr = &((ipv6_hdr_t *)ip->data)->dst;\n                if (ipv6_addr_equal((ipv6_addr_t *) tcb->local_addr, (ipv6_addr_t *) tmp_addr) ||\n                    ipv6_addr_is_unspecified((ipv6_addr_t *) tcb->local_addr)) {\n                    break;\n                }\n            }\n\n            /* If SYN is not set and the ports match ... */\n            if (!syn && tcb->local_port == dst && tcb->peer_port == src) {\n                /* .. and the IPv6 addresses match */\n                tmp_addr = &((ipv6_hdr_t * )ip->data)->src;\n                if (ipv6_addr_equal((ipv6_addr_t *) tcb->peer_addr, (ipv6_addr_t *) tmp_addr)) {\n                    break;\n                }\n            }\n        }\n#else\n        /* Supress compiler warnings if TCP is build without network layer */\n        (void) syn;\n        (void) src;\n        (void) dst;\n#endif\n        tcb = tcb->next;\n    }\n    mutex_unlock(&_list_tcb_lock);\n\n    /* Call FSM with event RCVD_PKT if a fitting TCB was found */\n    if (tcb != NULL) {\n        _fsm(tcb, FSM_EVENT_RCVD_PKT, pkt, NULL, 0);\n    }\n    /* No fitting TCB has been found. Respond with reset */\n    else {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : Can't find fitting tcb\\n\");\n        if ((ctl & MSK_RST) != MSK_RST) {\n            _pkt_build_reset_from_pkt(&reset, pkt);\n            gnrc_netapi_send(gnrc_tcp_pid, reset);\n        }\n        return -ENOTCONN;\n    }\n    gnrc_pktbuf_release(pkt);\n    return 0;\n}",
  "abstract_func_before": "static int _receive(gnrc_pktsnip_t *VAR_0)\n{\n    /* COMMENT_0 */\n    uint16_t VAR_1 = 0;\n    uint16_t VAR_2 = 0;\n    uint16_t VAR_3 = 0;\n    uint8_t VAR_4 = 0;\n    uint8_t VAR_5 = 0;\n    gnrc_pktsnip_t *VAR_6 = NULL;\n    gnrc_pktsnip_t *VAR_7 = NULL;\n    gnrc_tcp_tcb_t *VAR_8 = NULL;\n    tcp_hdr_t *VAR_9;\n\n    /* COMMENT_1 */\n    gnrc_pktsnip_t *VAR_10 = gnrc_pktbuf_start_write(VAR_0);\n    if (VAR_10 == NULL) {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : can't write to packet\\n\");\n        gnrc_pktbuf_release(VAR_0);\n        return -VAR_11;\n    }\n    VAR_0 = VAR_10;\n\n#ifdef VAR_12\n    /* COMMENT_2 */\n    LL_SEARCH_SCALAR(VAR_0, VAR_6, VAR_13, VAR_14);\n    if (VAR_6 == NULL) {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : pkt contains no IP Header\\n\");\n        gnrc_pktbuf_release(VAR_0);\n        return 0;\n    }\n#endif\n\n    /* COMMENT_3 */\n    LL_SEARCH_SCALAR(VAR_0, VAR_10, VAR_13, VAR_15);\n    if (VAR_10 == NULL) {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : pkt contains no TCP Header\\n\");\n        gnrc_pktbuf_release(VAR_0);\n        return 0;\n    }\n\n    /* COMMENT_4 */\n    VAR_9 = (tcp_hdr_t *)VAR_10->data;\n    VAR_1 = byteorder_ntohs(VAR_9->off_ctl);\n    VAR_2 = byteorder_ntohs(VAR_9->src_port);\n    VAR_3 = byteorder_ntohs(VAR_9->dst_port);\n    VAR_5 = ((VAR_1 & VAR_16) == VAR_17);\n\n    /* COMMENT_5 */\n    if (GET_OFFSET(VAR_1) < VAR_18) {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : unexpected Offset Value\\n\");\n        gnrc_pktbuf_release(VAR_0);\n        return -VAR_19;\n    }\n\n    /* COMMENT_6 */\n    VAR_4 = GET_OFFSET(VAR_1) * 4;\n\n    /* COMMENT_7 */\n    if ((VAR_0->type == VAR_15) && (VAR_0->size != VAR_4)) {\n        VAR_10 = gnrc_pktbuf_mark(VAR_0, VAR_4, VAR_15);\n        if (VAR_10 == NULL) {\n            DEBUG(\"gnrc_tcp_eventloop.c : _receive() : Header marking failed\\n\");\n            gnrc_pktbuf_release(VAR_0);\n            return -VAR_20;\n        }\n        VAR_0->type = VAR_21;\n    }\n\n    /* COMMENT_8 */\n    if (byteorder_ntohs(VAR_9->checksum) != _pkt_calc_csum(VAR_10, VAR_6, VAR_0)) {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : Invalid checksum\\n\");\n        gnrc_pktbuf_release(VAR_0);\n        return -VAR_22;\n    }\n\n    /* COMMENT_9 */\n    mutex_lock(&VAR_23);\n    VAR_8 = VAR_24;\n    while (VAR_8) {\n#ifdef VAR_12\n        /* COMMENT_10 */\n        if (VAR_6->type == VAR_14 && VAR_8->address_family == VAR_25) {\n            /* COMMENT_11 */\n            ipv6_addr_t *VAR_26 = NULL;\n            if (VAR_5 && VAR_8->local_port == VAR_3 && VAR_8->state == VAR_27) {\n                /* COMMENT_12 */\n                VAR_26 = &((ipv6_hdr_t *)VAR_6->data)->dst;\n                if (ipv6_addr_equal((ipv6_addr_t *) VAR_8->local_addr, (ipv6_addr_t *) VAR_26) ||\n                    ipv6_addr_is_unspecified((ipv6_addr_t *) VAR_8->local_addr)) {\n                    break;\n                }\n            }\n\n            /* COMMENT_13 */\n            if (!VAR_5 && VAR_8->local_port == VAR_3 && VAR_8->peer_port == VAR_2) {\n                /* COMMENT_14 */\n                VAR_26 = &((ipv6_hdr_t * )VAR_6->data)->src;\n                if (ipv6_addr_equal((ipv6_addr_t *) VAR_8->peer_addr, (ipv6_addr_t *) VAR_26)) {\n                    break;\n                }\n            }\n        }\n#else\n        /* COMMENT_15 */\n        (void) VAR_5;\n        (void) VAR_2;\n        (void) VAR_3;\n#endif\n        VAR_8 = VAR_8->next;\n    }\n    mutex_unlock(&VAR_23);\n\n    /* COMMENT_16 */\n    if (VAR_8 != NULL) {\n        _fsm(VAR_8, VAR_28, VAR_0, NULL, 0);\n    }\n    /* COMMENT_17 */\n    else {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : Can't find fitting tcb\\n\");\n        if ((VAR_1 & VAR_29) != VAR_29) {\n            _pkt_build_reset_from_pkt(&VAR_7, VAR_0);\n            gnrc_netapi_send(VAR_30, VAR_7);\n        }\n        return -VAR_31;\n    }\n    gnrc_pktbuf_release(VAR_0);\n    return 0;\n}",
  "func_graph_path_before": "RIOT-OS/RIOT/c6df2064aff1ffb4015d4cedbaefb8850cb50aa8/gnrc_tcp_eventloop.c/vul/before/0.json",
  "func": "static int _receive(gnrc_pktsnip_t *pkt)\n{\n    /* NOTE: In receiving direction: pkt = payload, payload->next = tcp, tcp->next = nw */\n    uint16_t ctl = 0;\n    uint16_t src = 0;\n    uint16_t dst = 0;\n    uint8_t hdr_size = 0;\n    uint8_t syn = 0;\n    gnrc_pktsnip_t *ip = NULL;\n    gnrc_pktsnip_t *reset = NULL;\n    gnrc_tcp_tcb_t *tcb = NULL;\n    tcp_hdr_t *hdr;\n\n    /* Get write access to the TCP header */\n    gnrc_pktsnip_t *tcp = gnrc_pktbuf_start_write(pkt);\n    if (tcp == NULL) {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : can't write to packet\\n\");\n        gnrc_pktbuf_release(pkt);\n        return -EACCES;\n    }\n    pkt = tcp;\n\n#ifdef MODULE_GNRC_IPV6\n    /* Get IPv6 header, discard packet if doesn't contain an ip header */\n    LL_SEARCH_SCALAR(pkt, ip, type, GNRC_NETTYPE_IPV6);\n    if (ip == NULL) {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : pkt contains no IP Header\\n\");\n        gnrc_pktbuf_release(pkt);\n        return 0;\n    }\n#endif\n\n    /* Get TCP header */\n    LL_SEARCH_SCALAR(pkt, tcp, type, GNRC_NETTYPE_TCP);\n    if (tcp == NULL) {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : pkt contains no TCP Header\\n\");\n        gnrc_pktbuf_release(pkt);\n        return 0;\n    }\n\n    /* Extract control bits, src and dst ports and check if SYN is set (not SYN+ACK) */\n    hdr = (tcp_hdr_t *)tcp->data;\n    ctl = byteorder_ntohs(hdr->off_ctl);\n    src = byteorder_ntohs(hdr->src_port);\n    dst = byteorder_ntohs(hdr->dst_port);\n    syn = ((ctl & MSK_SYN_ACK) == MSK_SYN);\n\n    /* Validate offset */\n    if (GET_OFFSET(ctl) < TCP_HDR_OFFSET_MIN) {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : unexpected Offset Value\\n\");\n        gnrc_pktbuf_release(pkt);\n        return -ERANGE;\n    }\n\n    /* Calculate TCP header size */\n    hdr_size = GET_OFFSET(ctl) * 4;\n\n    /* Mark TCP header if it contains any payload */\n    if ((pkt->type == GNRC_NETTYPE_TCP) && (pkt->size != hdr_size)) {\n        tcp = gnrc_pktbuf_mark(pkt, hdr_size, GNRC_NETTYPE_TCP);\n        if (tcp == NULL) {\n            DEBUG(\"gnrc_tcp_eventloop.c : _receive() : Header marking failed\\n\");\n            gnrc_pktbuf_release(pkt);\n            return -ENOMSG;\n        }\n        pkt->type = GNRC_NETTYPE_UNDEF;\n    }\n\n    /* Validate checksum */\n    if (byteorder_ntohs(hdr->checksum) != _pkt_calc_csum(tcp, ip, pkt)) {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : Invalid checksum\\n\");\n        gnrc_pktbuf_release(pkt);\n        return -EINVAL;\n    }\n\n    /* Find TCB to for this packet */\n    mutex_lock(&_list_tcb_lock);\n    tcb = _list_tcb_head;\n    while (tcb) {\n#ifdef MODULE_GNRC_IPV6\n        /* Check if current TCB is fitting for the incomming packet */\n        if (ip->type == GNRC_NETTYPE_IPV6 && tcb->address_family == AF_INET6) {\n            /* If SYN is set, a connection is listening on that port ... */\n            ipv6_addr_t *tmp_addr = NULL;\n            if (syn && tcb->local_port == dst && tcb->state == FSM_STATE_LISTEN) {\n                /* ... and local addr is unspec or pre configured */\n                tmp_addr = &((ipv6_hdr_t *)ip->data)->dst;\n                if (ipv6_addr_equal((ipv6_addr_t *) tcb->local_addr, (ipv6_addr_t *) tmp_addr) ||\n                    ipv6_addr_is_unspecified((ipv6_addr_t *) tcb->local_addr)) {\n                    break;\n                }\n            }\n\n            /* If SYN is not set and the ports match ... */\n            if (!syn && tcb->local_port == dst && tcb->peer_port == src) {\n                /* .. and the IPv6 addresses match */\n                tmp_addr = &((ipv6_hdr_t * )ip->data)->src;\n                if (ipv6_addr_equal((ipv6_addr_t *) tcb->peer_addr, (ipv6_addr_t *) tmp_addr)) {\n                    break;\n                }\n            }\n        }\n#else\n        /* Supress compiler warnings if TCP is build without network layer */\n        (void) syn;\n        (void) src;\n        (void) dst;\n#endif\n        tcb = tcb->next;\n    }\n    mutex_unlock(&_list_tcb_lock);\n\n    /* Call FSM with event RCVD_PKT if a fitting TCB was found */\n    if (tcb != NULL) {\n        _fsm(tcb, FSM_EVENT_RCVD_PKT, pkt, NULL, 0);\n    }\n    /* No fitting TCB has been found. Respond with reset */\n    else {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : Can't find fitting tcb\\n\");\n        if ((ctl & MSK_RST) != MSK_RST) {\n            _pkt_build_reset_from_pkt(&reset, pkt);\n            gnrc_netapi_send(gnrc_tcp_pid, reset);\n        }\n        gnrc_pktbuf_release(pkt);\n        return -ENOTCONN;\n    }\n    gnrc_pktbuf_release(pkt);\n    return 0;\n}",
  "abstract_func": "static int _receive(gnrc_pktsnip_t *VAR_0)\n{\n    /* COMMENT_0 */\n    uint16_t VAR_1 = 0;\n    uint16_t VAR_2 = 0;\n    uint16_t VAR_3 = 0;\n    uint8_t VAR_4 = 0;\n    uint8_t VAR_5 = 0;\n    gnrc_pktsnip_t *VAR_6 = NULL;\n    gnrc_pktsnip_t *VAR_7 = NULL;\n    gnrc_tcp_tcb_t *VAR_8 = NULL;\n    tcp_hdr_t *VAR_9;\n\n    /* COMMENT_1 */\n    gnrc_pktsnip_t *VAR_10 = gnrc_pktbuf_start_write(VAR_0);\n    if (VAR_10 == NULL) {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : can't write to packet\\n\");\n        gnrc_pktbuf_release(VAR_0);\n        return -VAR_11;\n    }\n    VAR_0 = VAR_10;\n\n#ifdef VAR_12\n    /* COMMENT_2 */\n    LL_SEARCH_SCALAR(VAR_0, VAR_6, VAR_13, VAR_14);\n    if (VAR_6 == NULL) {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : pkt contains no IP Header\\n\");\n        gnrc_pktbuf_release(VAR_0);\n        return 0;\n    }\n#endif\n\n    /* COMMENT_3 */\n    LL_SEARCH_SCALAR(VAR_0, VAR_10, VAR_13, VAR_15);\n    if (VAR_10 == NULL) {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : pkt contains no TCP Header\\n\");\n        gnrc_pktbuf_release(VAR_0);\n        return 0;\n    }\n\n    /* COMMENT_4 */\n    VAR_9 = (tcp_hdr_t *)VAR_10->data;\n    VAR_1 = byteorder_ntohs(VAR_9->off_ctl);\n    VAR_2 = byteorder_ntohs(VAR_9->src_port);\n    VAR_3 = byteorder_ntohs(VAR_9->dst_port);\n    VAR_5 = ((VAR_1 & VAR_16) == VAR_17);\n\n    /* COMMENT_5 */\n    if (GET_OFFSET(VAR_1) < VAR_18) {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : unexpected Offset Value\\n\");\n        gnrc_pktbuf_release(VAR_0);\n        return -VAR_19;\n    }\n\n    /* COMMENT_6 */\n    VAR_4 = GET_OFFSET(VAR_1) * 4;\n\n    /* COMMENT_7 */\n    if ((VAR_0->type == VAR_15) && (VAR_0->size != VAR_4)) {\n        VAR_10 = gnrc_pktbuf_mark(VAR_0, VAR_4, VAR_15);\n        if (VAR_10 == NULL) {\n            DEBUG(\"gnrc_tcp_eventloop.c : _receive() : Header marking failed\\n\");\n            gnrc_pktbuf_release(VAR_0);\n            return -VAR_20;\n        }\n        VAR_0->type = VAR_21;\n    }\n\n    /* COMMENT_8 */\n    if (byteorder_ntohs(VAR_9->checksum) != _pkt_calc_csum(VAR_10, VAR_6, VAR_0)) {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : Invalid checksum\\n\");\n        gnrc_pktbuf_release(VAR_0);\n        return -VAR_22;\n    }\n\n    /* COMMENT_9 */\n    mutex_lock(&VAR_23);\n    VAR_8 = VAR_24;\n    while (VAR_8) {\n#ifdef VAR_12\n        /* COMMENT_10 */\n        if (VAR_6->type == VAR_14 && VAR_8->address_family == VAR_25) {\n            /* COMMENT_11 */\n            ipv6_addr_t *VAR_26 = NULL;\n            if (VAR_5 && VAR_8->local_port == VAR_3 && VAR_8->state == VAR_27) {\n                /* COMMENT_12 */\n                VAR_26 = &((ipv6_hdr_t *)VAR_6->data)->dst;\n                if (ipv6_addr_equal((ipv6_addr_t *) VAR_8->local_addr, (ipv6_addr_t *) VAR_26) ||\n                    ipv6_addr_is_unspecified((ipv6_addr_t *) VAR_8->local_addr)) {\n                    break;\n                }\n            }\n\n            /* COMMENT_13 */\n            if (!VAR_5 && VAR_8->local_port == VAR_3 && VAR_8->peer_port == VAR_2) {\n                /* COMMENT_14 */\n                VAR_26 = &((ipv6_hdr_t * )VAR_6->data)->src;\n                if (ipv6_addr_equal((ipv6_addr_t *) VAR_8->peer_addr, (ipv6_addr_t *) VAR_26)) {\n                    break;\n                }\n            }\n        }\n#else\n        /* COMMENT_15 */\n        (void) VAR_5;\n        (void) VAR_2;\n        (void) VAR_3;\n#endif\n        VAR_8 = VAR_8->next;\n    }\n    mutex_unlock(&VAR_23);\n\n    /* COMMENT_16 */\n    if (VAR_8 != NULL) {\n        _fsm(VAR_8, VAR_28, VAR_0, NULL, 0);\n    }\n    /* COMMENT_17 */\n    else {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : Can't find fitting tcb\\n\");\n        if ((VAR_1 & VAR_29) != VAR_29) {\n            _pkt_build_reset_from_pkt(&VAR_7, VAR_0);\n            gnrc_netapi_send(VAR_30, VAR_7);\n        }\n        gnrc_pktbuf_release(VAR_0);\n        return -VAR_31;\n    }\n    gnrc_pktbuf_release(VAR_0);\n    return 0;\n}",
  "func_graph_path": "RIOT-OS/RIOT/c6df2064aff1ffb4015d4cedbaefb8850cb50aa8/gnrc_tcp_eventloop.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -121,6 +121,7 @@\n             _pkt_build_reset_from_pkt(&reset, pkt);\n             gnrc_netapi_send(gnrc_tcp_pid, reset);\n         }\n+        gnrc_pktbuf_release(pkt);\n         return -ENOTCONN;\n     }\n     gnrc_pktbuf_release(pkt);",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "        gnrc_pktbuf_release(pkt);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/RIOT-OS/RIOT/pull/12001",
  "description": {
    "pr_info": {
      "title": "gnrc_tcp: Fix memory leak, potential DOS",
      "number": 12001
    },
    "comment": [
      "#### Description\r\n\r\nI believe I found a memory leak in `gnrc_tcp` which occurs during a faulty TCP handshake, e.g. by sending an ACK instead of SYN as the first packet.\r\n\r\n#### Steps to reproduce the issue\r\n\r\nThe sample packet used below contains a hard-coded IP address, thus it is important to configure RIOT to use that IP address. Otherwise it will reject the packet. On `native` start `tests/gnrc_tcp_server` as follows:\r\n\r\n1. Make sure the IP address of your TAP interface is `fe80::e87d:b3ff:fe8b:4f01` and make sure RIOT uses `fe80::e87d:b3ff:fe8b:4f02`.\r\n2. Add `USEMODULE += gnrc_pktbuf_malloc` to `tests/gnrc_tcp_server/Makefile`.\r\n3. Compile `gnrc_tcp_server` using: `TCP_SERVER_ADDR=fe80::e87d:b3ff:fe8b:4f02 TCP_SERVER_PORT=4223 make -C tests/gnrc_tcp_server/ all-valgrind`\r\n4. Invoke `gnrc_tcp_server`: `make -C tests/gnrc_tcp_server/`\r\n\r\nUsing `socat` send a packet to the `gnrc_tcp_server`. This will probably require superuser privileges as it creates a raw IP socket:\r\n\r\n```\r\n# echo rwsQf2pekYLaU+exUBBwgPDKAAA= | base64 -d | socat -u STDIN IP6-SENDTO:[fe80::e87d:b3ff:fe8b:4f02%tap0]:6\r\n```\r\n\r\nThis can be repeated multiple times. Afterwards, terminate the `gnrc_tcp_server` application by sending it a SIGINT.\r\n\r\n#### Expected results\r\n\r\nvalgrind shouldn't report any memory leaks.\r\n\r\n#### Actual results\r\n\r\nDepending on how often the aforementioned packet has been send to RIOT valgrind reports a memory leak. For example:\r\n\r\n```\r\n==16184== 420 (60 direct, 360 indirect) bytes in 3 blocks are definitely lost in loss record 6 of 6\r\n==16184==    at 0x483463B: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-x86-linux.so)\r\n==16184==    by 0x110DC3: _create_snip (sys/net/gnrc/pktbuf_malloc/gnrc_pktbuf_malloc.c:276)\r\n==16184==    by 0x1106EC: gnrc_pktbuf_add (sys/net/gnrc/pktbuf_malloc/gnrc_pktbuf_malloc.c:97)\r\n==16184==    by 0x124238: _recv (sys/net/gnrc/netif/ethernet/gnrc_netif_ethernet.c:168)\r\n==16184==    by 0x1100AB: _event_cb (sys/net/gnrc/netif/gnrc_netif.c:1425)\r\n==16184==    by 0x124B8A: _isr (cpu/native/netdev_tap/netdev_tap.c:100)\r\n==16184==    by 0x10FE83: _gnrc_netif_thread (sys/net/gnrc/netif/gnrc_netif.c:1329)\r\n==16184==    by 0x499D53A: makecontext (/build/glibc-Stc26X/glibc-2.28/stdlib/../sysdeps/unix/sysv/linux/i386/makecontext.S:91\r\n```\r\n\r\n#### Impact\r\n\r\nIMHO this is a potential DOS as it allows an attacker to consume all pktbuf memory.\r\n\r\n#### Related Issues\r\n\r\n#11999",
      "> \r\n> \r\n> `pkt` is released in each return path now, that looks right.\r\n\r\nHas this been tested/checked, e.g., with valgrind ? ",
      "> Has this been tested/checked, e.g., with valgrind ?\r\n\r\nThe fix has been tested with valgrind by myself, however, I am by no means familiar with the internals of `gnrc_tcp` and would thus prefer if someone else can confirm this as well.\r\n\r\n> `pkt` is released in each return path now, that looks right.\r\n\r\nDoes this mean that you can confirm the existence of the memory leak?",
      "Maybe @miri64 can give this a final look?",
      "@brummer-simon FYI",
      "I tried to reproduce the issue and failed. \r\n\r\nCould you please add more details on your tap device setup?",
      "> I tried to reproduce the issue and failed.\r\n\r\nCould you provide more details on what failed? If you enable debug in the corresponding files `gnrc_tcp_eventloop.c`, `gnrc_tcp.c`, `gnrc_tcp_fsm.c`, `gnrc_tcp_pkt.c`, … What output do you get? Does the packet get accepted or is it rejected early on? Did you make sure that RIOT uses the correct address (if it doesn't the packet gets rejected to early and doesn't reach the vulnerable code path)? Did you make sure that `gnrc_pktbuf_malloc` instead of `gnrc_pktbuf_static` is being used?\r\n\r\nI also believe that this is fairly obvious simply by looking at the code. Or to rephrase that: Where does gnrc_tcp release the pktbuf memory when no fitting tcb has been found?",
      "> \r\n> \r\n> > I tried to reproduce the issue and failed.\r\n> \r\n> Could you provide more details on what failed? If you enable debug in the corresponding files `gnrc_tcp_eventloop.c`, `gnrc_tcp.c`, `gnrc_tcp_fsm.c`, `gnrc_tcp_pkt.c`, … What output do you get? Does the packet get accepted or is it rejected early on? Did you make sure that RIOT uses the correct address (if it doesn't the packet gets rejected to early and doesn't reach the vulnerable code path)? Did you make sure that `gnrc_pktbuf_malloc` instead of `gnrc_pktbuf_static` is being used?\r\n> \r\n> I also believe that this is fairly obvious simply by looking at the code. Or to rephrase that: Where does gnrc_tcp release the pktbuf memory when no fitting tcb has been found?\r\n\r\nThe final step in the Error reproduction failed on my system:\r\n`echo rwsQf2pekYLaU+exUBBwgPDKAAA= | base64 -d | socat -u STDIN IP6-SENDTO:\r\n[fe80::e87d:b3ff:fe8b:4f02%tap0]:6`\r\n\r\nfailed because socat was not able to resolve [fe80::e87d:b3ff:fe8b:4f02%tap0], although tap0 had inet6 fe80::e87d:b3ff:fe8b:4f01/64 assigned to it. That might be tap-device setup related, I used \r\n`sudo ip tuntap add tap0 mode tap user ${USER}; sudo ip link set tap0 up` to create tap0.\r\n\r\nHow did you setup your Tap Device?\r\n\r\n> I also believe that this is fairly obvious simply by looking at the code. Or to rephrase that: Where does gnrc_tcp release the pktbuf memory when no fitting tcb has been found?\r\n\r\nI think the issue and the fix are obvious, but I still want to reproduce the Issue and test the fix. Again, thanks for finding it.\r\n\r\n\r\n \r\n\r\n",
      "> How did you setup your Tap Device?\r\n\r\n```\r\n# ip tuntap add tap0 mode tap\r\n# ip addr add fe80::e87d:b3ff:fe8b:4f01/64 dev tap0\r\n# ip link set tap0 up\r\n```\r\n\r\n*Though I believe that RIOT itself added that IP address to the interface.*\r\n\r\nMy `ip addr show dev tap0` output looks as follows:\r\n\r\n```\r\n7: tap0: <NO-CARRIER,BROADCAST,UP> mtu 1500 qdisc pfifo_fast state DOWN group default qlen 1000\r\n    link/ether ea:7d:b3:8b:4f:01 brd ff:ff:ff:ff:ff:ff\r\n    inet6 fe80::e87d:b3ff:fe8b:4f01/64 scope link \r\n       valid_lft forever preferred_lft forever\r\n```\r\n\r\nWhat does your `ip addr show dev tap0` output look like?\r\n\r\n> socat was not able to resolve `[fe80::e87d:b3ff:fe8b:4f02%tap0]`,\r\n\r\nWhat's the exact socat output? Is your socat compiled with IPv6 support and support for raw IP sockets?",
      "Output of \"ip addr show dev tap0\":\r\n`3: tap0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000\r\n    link/ether 6a:bf:db:05:c3:5e brd ff:ff:ff:ff:ff:ff\r\n    inet6 fe80::68bf:dbff:fe05:c35e/64 scope link \r\n       valid_lft forever preferred_lft forever\r\n    inet6 fe80::e87d:b3ff:fe8b:4f01/64 scope link \r\n       valid_lft forever preferred_lft forever`\r\n\r\nOutput of \"echo rwsQf2pekYLaU+exUBBwgPDKAAA= | base64 -d | socat -u STDIN IP6-SENDTO:[fe80::e87d:b3ff:fe8b:4f02%tap0]:6:\"\r\n\r\n`2019/08/19 13:34:00 socat[1462] E getaddrinfo(\"fe80::e87d:b3ff:fe8b:4f02%tap0\", \"NULL\", {5,10,2,6}, {}): ai_socktype not supported`\r\n\r\nThe output of socat -V is contains '#define WITH_IP6 1' and '#define WITH_RAWIP 1' so i assume everything required is supported by socat.\r\n",
      "> 2019/08/19 13:34:00 socat[1462] E getaddrinfo(\"fe80::e87d:b3ff:fe8b:4f02%tap0\", \"NULL\", {5,10,2,6}, {}): ai_socktype not supported\r\n\r\nThat's probably a bug in socat. See https://github.com/alpinelinux/aports/pull/10055 didn't think that this would also happen on non-musl-libc based systems. You can either apply the patch linked above to socat or try the following C program which sends the same packet (a bit hacky and not-well tested at all but should work):\r\n\r\n```C\r\n#include <err.h>\r\n#include <assert.h>\r\n#include <string.h>\r\n#include <unistd.h>\r\n#include <stdlib.h>\r\n#include <netdb.h>\r\n\r\n#include <arpa/inet.h>\r\n#include <sys/types.h>\r\n#include <sys/socket.h>\r\n#include <sys/sendfile.h>\r\n\r\nstatic const uint8_t buffer[256] = {\r\n\t0xaf, 0x0b, 0x10, 0x7f, 0x6a, 0x5e, 0x91, 0x82, 0xda, 0x53,\r\n\t0xe7, 0xb1, 0x50, 0x10, 0x70, 0x80, 0xf0, 0xca, 0x00, 0x00,\r\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\r\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\r\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\r\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\r\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\r\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\r\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\r\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\r\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\r\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\r\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\r\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\r\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\r\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\r\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\r\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\r\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\r\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\r\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\r\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\r\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\r\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\r\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\r\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff\r\n};\r\n\r\nint\r\nmain(void)\r\n{\r\n\tint fd, optval;\r\n\tstruct addrinfo hints, *srvinfo;\r\n\r\n\tif ((fd = socket(AF_INET6, SOCK_RAW, IPPROTO_TCP)) == -1)\r\n\t\terr(EXIT_FAILURE, \"socket failed\");\r\n\r\n\toptval = 1;\r\n\tif ((setsockopt(fd, SOL_SOCKET, SO_REUSEPORT, &optval,\r\n\t\t\tsizeof(optval)) == -1))\r\n\t\terr(EXIT_FAILURE, \"setsockopt failed\");\r\n\r\n\tmemset(&hints, 0, sizeof(struct addrinfo));\r\n\thints.ai_family = AF_INET6;\r\n\r\n\tif (getaddrinfo(\"fe80::e87d:b3ff:fe8b:4f02%tap0\", NULL, &hints, &srvinfo) != 0)\r\n\t\terr(EXIT_FAILURE, \"getaddrinfo failed\");\r\n\tassert(srvinfo != NULL);\r\n\r\n\tif (connect(fd, (struct sockaddr *)srvinfo->ai_addr, srvinfo->ai_addrlen) == -1)\r\n\t\terr(EXIT_FAILURE, \"connect failed\");\r\n\tif (write(fd, buffer, sizeof(buffer)) == -1)\r\n\t\terr(EXIT_FAILURE, \"write failed\");\r\n\r\n\treturn EXIT_SUCCESS;\r\n}\r\n```",
      "Your C programm worked. Although a had to apply the fix from #11999 to get the expected Results.\r\n\r\n",
      "As I consider this a critical issue I requested a CVE for it. This request has been granted recently and this has been assigned [CVE-2019-15134](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-15134).",
      "Well, it looks like fixed now. Any reason not to merge?",
      "> Well, it looks like fixed now. Any reason not to merge?\r\n\r\nNot from my side. But I don't have the rights to merge.\r\n",
      "Also needs a backport to the release branch.",
      "> \r\n> \r\n> Also needs a backport to the release branch.\r\n\r\n@MrKevinWeiss how about such backport? This is a security bug.\r\n",
      "Has this been backported yet?",
      "According to our normal procedures, we would expect a backport from @nmeum. In any case, @MrKevinWeiss is aware of the issue and will provide the backport otherwise.",
      "Ah ok, I will look into it then!",
      "@nmeum Many thanks!"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses a memory leak in the TCP receive function by adding a packet buffer release call. This prevents resource exhaustion, mitigating a potential denial of service vulnerability.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 0.95"
}