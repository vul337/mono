{
  "cve_id": "CVE-2014-7203",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "zeromq/libzmq",
  "commit_msg": "Problem: curve messages can be replayed\n\nSolution: ensure message short nonces are strictly increasing and validate them",
  "commit_hash": "0900a489213d74feb86fc0b343308fe7884a2a3c",
  "git_url": "https://github.com/zeromq/libzmq/commit/0900a489213d74feb86fc0b343308fe7884a2a3c",
  "file_path": "src/curve_client.cpp",
  "func_name": "zmq::curve_client_t::produce_hello",
  "func_before": "int zmq::curve_client_t::produce_hello (msg_t *msg_)\n{\n    uint8_t hello_nonce [crypto_box_NONCEBYTES];\n    uint8_t hello_plaintext [crypto_box_ZEROBYTES + 64];\n    uint8_t hello_box [crypto_box_BOXZEROBYTES + 80];\n\n    //  Prepare the full nonce\n    memcpy (hello_nonce, \"CurveZMQHELLO---\", 16);\n    memcpy (hello_nonce + 16, &cn_nonce, 8);\n\n    //  Create Box [64 * %x0](C'->S)\n    memset (hello_plaintext, 0, sizeof hello_plaintext);\n\n    int rc = crypto_box (hello_box, hello_plaintext,\n                         sizeof hello_plaintext,\n                         hello_nonce, server_key, cn_secret);\n    zmq_assert (rc == 0);\n\n    rc = msg_->init_size (200);\n    errno_assert (rc == 0);\n    uint8_t *hello = static_cast <uint8_t *> (msg_->data ());\n\n    memcpy (hello, \"\\x05HELLO\", 6);\n    //  CurveZMQ major and minor version numbers\n    memcpy (hello + 6, \"\\1\\0\", 2);\n    //  Anti-amplification padding\n    memset (hello + 8, 0, 72);\n    //  Client public connection key\n    memcpy (hello + 80, cn_public, crypto_box_PUBLICKEYBYTES);\n    //  Short nonce, prefixed by \"CurveZMQHELLO---\"\n    memcpy (hello + 112, hello_nonce + 16, 8);\n    //  Signature, Box [64 * %x0](C'->S)\n    memcpy (hello + 120, hello_box + crypto_box_BOXZEROBYTES, 80);\n\n    cn_nonce++;\n\n    return 0;\n}",
  "abstract_func_before": "int zmq::curve_client_t::produce_hello (msg_t *VAR_0)\n{\n    uint8_t VAR_1 [VAR_2];\n    uint8_t VAR_3 [VAR_4 + 64];\n    uint8_t VAR_5 [VAR_6 + 80];\n\n    /* COMMENT_0 */\n    memcpy (VAR_1, \"CurveZMQHELLO---\", 16);\n    memcpy (VAR_1 + 16, &VAR_7, 8);\n\n    /* COMMENT_1 */\n    memset (VAR_3, 0, sizeof VAR_3);\n\n    int VAR_8 = crypto_box (VAR_5, VAR_3,\n                         sizeof VAR_3,\n                         VAR_1, VAR_9, VAR_10);\n    zmq_assert (VAR_8 == 0);\n\n    VAR_8 = VAR_0->init_size (200);\n    errno_assert (VAR_8 == 0);\n    uint8_t *VAR_11 = VAR_12 <uint8_t *> (VAR_0->data ());\n\n    memcpy (VAR_11, \"\\x05HELLO\", 6);\n    /* COMMENT_2 */\n    memcpy (VAR_11 + 6, \"\\1\\0\", 2);\n    /* COMMENT_3 */\n    memset (VAR_11 + 8, 0, 72);\n    /* COMMENT_4 */\n    memcpy (VAR_11 + 80, VAR_13, VAR_14);\n    /* COMMENT_5 */\n    memcpy (VAR_11 + 112, VAR_1 + 16, 8);\n    /* COMMENT_6 */\n    memcpy (VAR_11 + 120, VAR_5 + VAR_6, 80);\n\n    VAR_7++;\n\n    return 0;\n}",
  "func_graph_path_before": "zeromq/libzmq/0900a489213d74feb86fc0b343308fe7884a2a3c/curve_client.cpp/vul/before/0.json",
  "func": "int zmq::curve_client_t::produce_hello (msg_t *msg_)\n{\n    uint8_t hello_nonce [crypto_box_NONCEBYTES];\n    uint8_t hello_plaintext [crypto_box_ZEROBYTES + 64];\n    uint8_t hello_box [crypto_box_BOXZEROBYTES + 80];\n\n    //  Prepare the full nonce\n    memcpy (hello_nonce, \"CurveZMQHELLO---\", 16);\n    put_uint64 (hello_nonce + 16, cn_nonce);\n\n    //  Create Box [64 * %x0](C'->S)\n    memset (hello_plaintext, 0, sizeof hello_plaintext);\n\n    int rc = crypto_box (hello_box, hello_plaintext,\n                         sizeof hello_plaintext,\n                         hello_nonce, server_key, cn_secret);\n    zmq_assert (rc == 0);\n\n    rc = msg_->init_size (200);\n    errno_assert (rc == 0);\n    uint8_t *hello = static_cast <uint8_t *> (msg_->data ());\n\n    memcpy (hello, \"\\x05HELLO\", 6);\n    //  CurveZMQ major and minor version numbers\n    memcpy (hello + 6, \"\\1\\0\", 2);\n    //  Anti-amplification padding\n    memset (hello + 8, 0, 72);\n    //  Client public connection key\n    memcpy (hello + 80, cn_public, crypto_box_PUBLICKEYBYTES);\n    //  Short nonce, prefixed by \"CurveZMQHELLO---\"\n    memcpy (hello + 112, hello_nonce + 16, 8);\n    //  Signature, Box [64 * %x0](C'->S)\n    memcpy (hello + 120, hello_box + crypto_box_BOXZEROBYTES, 80);\n\n    cn_nonce++;\n\n    return 0;\n}",
  "abstract_func": "int zmq::curve_client_t::produce_hello (msg_t *VAR_0)\n{\n    uint8_t VAR_1 [VAR_2];\n    uint8_t VAR_3 [VAR_4 + 64];\n    uint8_t VAR_5 [VAR_6 + 80];\n\n    /* COMMENT_0 */\n    memcpy (VAR_1, \"CurveZMQHELLO---\", 16);\n    put_uint64 (VAR_1 + 16, VAR_7);\n\n    /* COMMENT_1 */\n    memset (VAR_3, 0, sizeof VAR_3);\n\n    int VAR_8 = crypto_box (VAR_5, VAR_3,\n                         sizeof VAR_3,\n                         VAR_1, VAR_9, VAR_10);\n    zmq_assert (VAR_8 == 0);\n\n    VAR_8 = VAR_0->init_size (200);\n    errno_assert (VAR_8 == 0);\n    uint8_t *VAR_11 = VAR_12 <uint8_t *> (VAR_0->data ());\n\n    memcpy (VAR_11, \"\\x05HELLO\", 6);\n    /* COMMENT_2 */\n    memcpy (VAR_11 + 6, \"\\1\\0\", 2);\n    /* COMMENT_3 */\n    memset (VAR_11 + 8, 0, 72);\n    /* COMMENT_4 */\n    memcpy (VAR_11 + 80, VAR_13, VAR_14);\n    /* COMMENT_5 */\n    memcpy (VAR_11 + 112, VAR_1 + 16, 8);\n    /* COMMENT_6 */\n    memcpy (VAR_11 + 120, VAR_5 + VAR_6, 80);\n\n    VAR_7++;\n\n    return 0;\n}",
  "func_graph_path": "zeromq/libzmq/0900a489213d74feb86fc0b343308fe7884a2a3c/curve_client.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,7 @@\n \n     //  Prepare the full nonce\n     memcpy (hello_nonce, \"CurveZMQHELLO---\", 16);\n-    memcpy (hello_nonce + 16, &cn_nonce, 8);\n+    put_uint64 (hello_nonce + 16, cn_nonce);\n \n     //  Create Box [64 * %x0](C'->S)\n     memset (hello_plaintext, 0, sizeof hello_plaintext);",
  "diff_line_info": {
    "deleted_lines": [
      "    memcpy (hello_nonce + 16, &cn_nonce, 8);"
    ],
    "added_lines": [
      "    put_uint64 (hello_nonce + 16, cn_nonce);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/zeromq/libzmq/pull/1189",
  "description": {
    "pr_info": {
      "title": "Problem: curve messages can be replayed",
      "number": 1189
    },
    "comment": [
      "Solution: ensure message short nonces are strictly increasing and validate them\n",
      "Fixes #1191.\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix\nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\nThe commit addresses a security issue by preventing replay attacks through proper nonce handling, which is a clear security vulnerability fix.\n\n**Final Output:**\nAnalysis: The patch fixes a security vulnerability by ensuring nonces are strictly increasing to prevent replay attacks.\nFinal Classification: Security Vulnerability Fix\nConfidence Score: 1.0"
}