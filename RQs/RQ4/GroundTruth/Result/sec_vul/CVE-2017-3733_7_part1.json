{
  "cve_id": "CVE-2017-3733",
  "cwe_ids": [
    "CWE-20"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "openssl",
  "commit_msg": "Don't change the state of the ETM flags until CCS processing\n\nChanging the ciphersuite during a renegotiation can result in a crash\nleading to a DoS attack. ETM has not been implemented in 1.1.0 for DTLS\nso this is TLS only.\n\nThe problem is caused by changing the flag indicating whether to use ETM\nor not immediately on negotiation of ETM, rather than at CCS. Therefore,\nduring a renegotiation, if the ETM state is changing (usually due to a\nchange of ciphersuite), then an error/crash will occur.\n\nDue to the fact that there are separate CCS messages for read and write\nwe actually now need two flags to determine whether to use ETM or not.\n\nCVE-2017-3733\n\nReviewed-by: Richard Levitte <levitte@openssl.org>",
  "commit_hash": "4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2",
  "git_url": "https://github.com/openssl/openssl/commit/4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2",
  "file_path": "ssl/record/rec_layer_s3.c",
  "func_name": "do_ssl3_write",
  "func_before": "int do_ssl3_write(SSL *s, int type, const unsigned char *buf,\n                  unsigned int *pipelens, unsigned int numpipes,\n                  int create_empty_fragment)\n{\n    unsigned char *outbuf[SSL_MAX_PIPELINES], *plen[SSL_MAX_PIPELINES];\n    SSL3_RECORD wr[SSL_MAX_PIPELINES];\n    int i, mac_size, clear = 0;\n    int prefix_len = 0;\n    int eivlen;\n    size_t align = 0;\n    SSL3_BUFFER *wb;\n    SSL_SESSION *sess;\n    unsigned int totlen = 0;\n    unsigned int j;\n\n    for (j = 0; j < numpipes; j++)\n        totlen += pipelens[j];\n    /*\n     * first check if there is a SSL3_BUFFER still being written out.  This\n     * will happen with non blocking IO\n     */\n    if (RECORD_LAYER_write_pending(&s->rlayer))\n        return (ssl3_write_pending(s, type, buf, totlen));\n\n    /* If we have an alert to send, lets send it */\n    if (s->s3->alert_dispatch) {\n        i = s->method->ssl_dispatch_alert(s);\n        if (i <= 0)\n            return (i);\n        /* if it went, fall through and send more stuff */\n    }\n\n    if (s->rlayer.numwpipes < numpipes)\n        if (!ssl3_setup_write_buffer(s, numpipes, 0))\n            return -1;\n\n    if (totlen == 0 && !create_empty_fragment)\n        return 0;\n\n    sess = s->session;\n\n    if ((sess == NULL) ||\n        (s->enc_write_ctx == NULL) || (EVP_MD_CTX_md(s->write_hash) == NULL)) {\n        clear = s->enc_write_ctx ? 0 : 1; /* must be AEAD cipher */\n        mac_size = 0;\n    } else {\n        mac_size = EVP_MD_CTX_size(s->write_hash);\n        if (mac_size < 0)\n            goto err;\n    }\n\n    /*\n     * 'create_empty_fragment' is true only when this function calls itself\n     */\n    if (!clear && !create_empty_fragment && !s->s3->empty_fragment_done) {\n        /*\n         * countermeasure against known-IV weakness in CBC ciphersuites (see\n         * http://www.openssl.org/~bodo/tls-cbc.txt)\n         */\n\n        if (s->s3->need_empty_fragments && type == SSL3_RT_APPLICATION_DATA) {\n            /*\n             * recursive function call with 'create_empty_fragment' set; this\n             * prepares and buffers the data for an empty fragment (these\n             * 'prefix_len' bytes are sent out later together with the actual\n             * payload)\n             */\n            unsigned int tmppipelen = 0;\n\n            prefix_len = do_ssl3_write(s, type, buf, &tmppipelen, 1, 1);\n            if (prefix_len <= 0)\n                goto err;\n\n            if (prefix_len >\n                (SSL3_RT_HEADER_LENGTH + SSL3_RT_SEND_MAX_ENCRYPTED_OVERHEAD)) {\n                /* insufficient space */\n                SSLerr(SSL_F_DO_SSL3_WRITE, ERR_R_INTERNAL_ERROR);\n                goto err;\n            }\n        }\n\n        s->s3->empty_fragment_done = 1;\n    }\n\n    if (create_empty_fragment) {\n        wb = &s->rlayer.wbuf[0];\n#if defined(SSL3_ALIGN_PAYLOAD) && SSL3_ALIGN_PAYLOAD!=0\n        /*\n         * extra fragment would be couple of cipher blocks, which would be\n         * multiple of SSL3_ALIGN_PAYLOAD, so if we want to align the real\n         * payload, then we can just pretend we simply have two headers.\n         */\n        align = (size_t)SSL3_BUFFER_get_buf(wb) + 2 * SSL3_RT_HEADER_LENGTH;\n        align = SSL3_ALIGN_PAYLOAD - 1 - ((align - 1) % SSL3_ALIGN_PAYLOAD);\n#endif\n        outbuf[0] = SSL3_BUFFER_get_buf(wb) + align;\n        SSL3_BUFFER_set_offset(wb, align);\n    } else if (prefix_len) {\n        wb = &s->rlayer.wbuf[0];\n        outbuf[0] = SSL3_BUFFER_get_buf(wb) + SSL3_BUFFER_get_offset(wb)\n            + prefix_len;\n    } else {\n        for (j = 0; j < numpipes; j++) {\n            wb = &s->rlayer.wbuf[j];\n#if defined(SSL3_ALIGN_PAYLOAD) && SSL3_ALIGN_PAYLOAD!=0\n            align = (size_t)SSL3_BUFFER_get_buf(wb) + SSL3_RT_HEADER_LENGTH;\n            align = SSL3_ALIGN_PAYLOAD - 1 - ((align - 1) % SSL3_ALIGN_PAYLOAD);\n#endif\n            outbuf[j] = SSL3_BUFFER_get_buf(wb) + align;\n            SSL3_BUFFER_set_offset(wb, align);\n        }\n    }\n\n    /* Explicit IV length, block ciphers appropriate version flag */\n    if (s->enc_write_ctx && SSL_USE_EXPLICIT_IV(s)) {\n        int mode = EVP_CIPHER_CTX_mode(s->enc_write_ctx);\n        if (mode == EVP_CIPH_CBC_MODE) {\n            eivlen = EVP_CIPHER_CTX_iv_length(s->enc_write_ctx);\n            if (eivlen <= 1)\n                eivlen = 0;\n        }\n        /* Need explicit part of IV for GCM mode */\n        else if (mode == EVP_CIPH_GCM_MODE)\n            eivlen = EVP_GCM_TLS_EXPLICIT_IV_LEN;\n        else if (mode == EVP_CIPH_CCM_MODE)\n            eivlen = EVP_CCM_TLS_EXPLICIT_IV_LEN;\n        else\n            eivlen = 0;\n    } else\n        eivlen = 0;\n\n    totlen = 0;\n    /* Clear our SSL3_RECORD structures */\n    memset(wr, 0, sizeof wr);\n    for (j = 0; j < numpipes; j++) {\n        /* write the header */\n        *(outbuf[j]++) = type & 0xff;\n        SSL3_RECORD_set_type(&wr[j], type);\n\n        *(outbuf[j]++) = (s->version >> 8);\n        /*\n         * Some servers hang if initial client hello is larger than 256 bytes\n         * and record version number > TLS 1.0\n         */\n        if (SSL_get_state(s) == TLS_ST_CW_CLNT_HELLO\n            && !s->renegotiate && TLS1_get_version(s) > TLS1_VERSION)\n            *(outbuf[j]++) = 0x1;\n        else\n            *(outbuf[j]++) = s->version & 0xff;\n\n        /* field where we are to write out packet length */\n        plen[j] = outbuf[j];\n        outbuf[j] += 2;\n\n        /* lets setup the record stuff. */\n        SSL3_RECORD_set_data(&wr[j], outbuf[j] + eivlen);\n        SSL3_RECORD_set_length(&wr[j], (int)pipelens[j]);\n        SSL3_RECORD_set_input(&wr[j], (unsigned char *)&buf[totlen]);\n        totlen += pipelens[j];\n\n        /*\n         * we now 'read' from wr->input, wr->length bytes into wr->data\n         */\n\n        /* first we compress */\n        if (s->compress != NULL) {\n            if (!ssl3_do_compress(s, &wr[j])) {\n                SSLerr(SSL_F_DO_SSL3_WRITE, SSL_R_COMPRESSION_FAILURE);\n                goto err;\n            }\n        } else {\n            memcpy(wr[j].data, wr[j].input, wr[j].length);\n            SSL3_RECORD_reset_input(&wr[j]);\n        }\n\n        /*\n         * we should still have the output to wr->data and the input from\n         * wr->input.  Length should be wr->length. wr->data still points in the\n         * wb->buf\n         */\n\n        if (!SSL_USE_ETM(s) && mac_size != 0) {\n            if (s->method->ssl3_enc->mac(s, &wr[j],\n                                         &(outbuf[j][wr[j].length + eivlen]),\n                                         1) < 0)\n                goto err;\n            SSL3_RECORD_add_length(&wr[j], mac_size);\n        }\n\n        SSL3_RECORD_set_data(&wr[j], outbuf[j]);\n        SSL3_RECORD_reset_input(&wr[j]);\n\n        if (eivlen) {\n            /*\n             * if (RAND_pseudo_bytes(p, eivlen) <= 0) goto err;\n             */\n            SSL3_RECORD_add_length(&wr[j], eivlen);\n        }\n    }\n\n    if (s->method->ssl3_enc->enc(s, wr, numpipes, 1) < 1)\n        goto err;\n\n    for (j = 0; j < numpipes; j++) {\n        if (SSL_USE_ETM(s) && mac_size != 0) {\n            if (s->method->ssl3_enc->mac(s, &wr[j],\n                                         outbuf[j] + wr[j].length, 1) < 0)\n                goto err;\n            SSL3_RECORD_add_length(&wr[j], mac_size);\n        }\n\n        /* record length after mac and block padding */\n        s2n(SSL3_RECORD_get_length(&wr[j]), plen[j]);\n\n        if (s->msg_callback)\n            s->msg_callback(1, 0, SSL3_RT_HEADER, plen[j] - 5, 5, s,\n                            s->msg_callback_arg);\n\n        /*\n         * we should now have wr->data pointing to the encrypted data, which is\n         * wr->length long\n         */\n        SSL3_RECORD_set_type(&wr[j], type); /* not needed but helps for\n                                             * debugging */\n        SSL3_RECORD_add_length(&wr[j], SSL3_RT_HEADER_LENGTH);\n\n        if (create_empty_fragment) {\n            /*\n             * we are in a recursive call; just return the length, don't write\n             * out anything here\n             */\n            if (j > 0) {\n                /* We should never be pipelining an empty fragment!! */\n                SSLerr(SSL_F_DO_SSL3_WRITE, ERR_R_INTERNAL_ERROR);\n                goto err;\n            }\n            return SSL3_RECORD_get_length(wr);\n        }\n\n        /* now let's set up wb */\n        SSL3_BUFFER_set_left(&s->rlayer.wbuf[j],\n                             prefix_len + SSL3_RECORD_get_length(&wr[j]));\n    }\n\n    /*\n     * memorize arguments so that ssl3_write_pending can detect bad write\n     * retries later\n     */\n    s->rlayer.wpend_tot = totlen;\n    s->rlayer.wpend_buf = buf;\n    s->rlayer.wpend_type = type;\n    s->rlayer.wpend_ret = totlen;\n\n    /* we now just need to write the buffer */\n    return ssl3_write_pending(s, type, buf, totlen);\n err:\n    return -1;\n}",
  "abstract_func_before": "int do_ssl3_write(SSL *VAR_0, int VAR_1, const unsigned char *VAR_2,\n                  unsigned int *VAR_3, unsigned int VAR_4,\n                  int VAR_5)\n{\n    unsigned char *VAR_6[VAR_7], *VAR_8[VAR_7];\n    SSL3_RECORD VAR_9[VAR_7];\n    int VAR_10, VAR_11, VAR_12 = 0;\n    int VAR_13 = 0;\n    int VAR_14;\n    size_t VAR_15 = 0;\n    SSL3_BUFFER *VAR_16;\n    SSL_SESSION *VAR_17;\n    unsigned int VAR_18 = 0;\n    unsigned int VAR_19;\n\n    for (VAR_19 = 0; VAR_19 < VAR_4; VAR_19++)\n        VAR_18 += VAR_3[VAR_19];\n    /* COMMENT_0 */\n                                                                           \n                                       \n       \n    if (RECORD_LAYER_write_pending(&VAR_0->rlayer))\n        return (ssl3_write_pending(VAR_0, VAR_1, VAR_2, VAR_18));\n\n    /* COMMENT_4 */\n    if (VAR_0->s3->alert_dispatch) {\n        VAR_10 = VAR_0->method->ssl_dispatch_alert(VAR_0);\n        if (VAR_10 <= 0)\n            return (VAR_10);\n        /* COMMENT_5 */\n    }\n\n    if (VAR_0->rlayer.numwpipes < VAR_4)\n        if (!ssl3_setup_write_buffer(VAR_0, VAR_4, 0))\n            return -1;\n\n    if (VAR_18 == 0 && !VAR_5)\n        return 0;\n\n    VAR_17 = VAR_0->session;\n\n    if ((VAR_17 == NULL) ||\n        (VAR_0->enc_write_ctx == NULL) || (EVP_MD_CTX_md(VAR_0->write_hash) == NULL)) {\n        VAR_12 = VAR_0->enc_write_ctx ? 0 : 1; /* COMMENT_6 */\n        VAR_11 = 0;\n    } else {\n        VAR_11 = EVP_MD_CTX_size(VAR_0->write_hash);\n        if (VAR_11 < 0)\n            goto err;\n    }\n\n    /* COMMENT_7 */\n                                                                           \n       \n    if (!VAR_12 && !VAR_5 && !VAR_0->s3->empty_fragment_done) {\n        /* COMMENT_10 */\n                                                                            \n                                                    \n           \n\n        if (VAR_0->s3->need_empty_fragments && VAR_1 == VAR_20) {\n            /* COMMENT_14 */\n                                                                             \n                                                                         \n                                                                             \n                       \n               \n            unsigned int VAR_21 = 0;\n\n            VAR_13 = do_ssl3_write(VAR_0, VAR_1, VAR_2, &VAR_21, 1, 1);\n            if (VAR_13 <= 0)\n                goto err;\n\n            if (VAR_13 >\n                (VAR_22 + VAR_23)) {\n                /* COMMENT_20 */\n                SSLerr(VAR_24, VAR_25);\n                goto err;\n            }\n        }\n\n        VAR_0->s3->empty_fragment_done = 1;\n    }\n\n    if (VAR_5) {\n        VAR_16 = &VAR_0->rlayer.wbuf[0];\n#if defined(VAR_26) && VAR_26!=0\n        /* COMMENT_21 */\n                                                                          \n                                                                          \n                                                                        \n           \n        VAR_15 = (size_t)SSL3_BUFFER_get_buf(VAR_16) + 2 * VAR_22;\n        VAR_15 = VAR_26 - 1 - ((VAR_15 - 1) % VAR_26);\n#endif\n        VAR_6[0] = SSL3_BUFFER_get_buf(VAR_16) + VAR_15;\n        SSL3_BUFFER_set_offset(VAR_16, VAR_15);\n    } else if (VAR_13) {\n        VAR_16 = &VAR_0->rlayer.wbuf[0];\n        VAR_6[0] = SSL3_BUFFER_get_buf(VAR_16) + SSL3_BUFFER_get_offset(VAR_16)\n            + VAR_13;\n    } else {\n        for (VAR_19 = 0; VAR_19 < VAR_4; VAR_19++) {\n            VAR_16 = &VAR_0->rlayer.wbuf[VAR_19];\n#if defined(VAR_26) && VAR_26!=0\n            VAR_15 = (size_t)SSL3_BUFFER_get_buf(VAR_16) + VAR_22;\n            VAR_15 = VAR_26 - 1 - ((VAR_15 - 1) % VAR_26);\n#endif\n            VAR_6[VAR_19] = SSL3_BUFFER_get_buf(VAR_16) + VAR_15;\n            SSL3_BUFFER_set_offset(VAR_16, VAR_15);\n        }\n    }\n\n    /* COMMENT_26 */\n    if (VAR_0->enc_write_ctx && SSL_USE_EXPLICIT_IV(VAR_0)) {\n        int VAR_27 = EVP_CIPHER_CTX_mode(VAR_0->enc_write_ctx);\n        if (VAR_27 == VAR_28) {\n            VAR_14 = EVP_CIPHER_CTX_iv_length(VAR_0->enc_write_ctx);\n            if (VAR_14 <= 1)\n                VAR_14 = 0;\n        }\n        /* COMMENT_27 */\n        else if (VAR_27 == VAR_29)\n            VAR_14 = VAR_30;\n        else if (VAR_27 == VAR_31)\n            VAR_14 = VAR_32;\n        else\n            VAR_14 = 0;\n    } else\n        VAR_14 = 0;\n\n    VAR_18 = 0;\n    /* COMMENT_28 */\n    memset(VAR_9, 0, sizeof VAR_9);\n    for (VAR_19 = 0; VAR_19 < VAR_4; VAR_19++) {\n        /* COMMENT_29 */\n        *(VAR_6[VAR_19]++) = VAR_1 & 0xff;\n        SSL3_RECORD_set_type(&VAR_9[VAR_19], VAR_1);\n\n        *(VAR_6[VAR_19]++) = (VAR_0->version >> 8);\n        /* COMMENT_30 */\n                                                                             \n                                              \n           \n        if (SSL_get_state(VAR_0) == VAR_33\n            && !VAR_0->renegotiate && TLS1_get_version(VAR_0) > VAR_34)\n            *(VAR_6[VAR_19]++) = 0x1;\n        else\n            *(VAR_6[VAR_19]++) = VAR_0->version & 0xff;\n\n        /* COMMENT_34 */\n        VAR_8[VAR_19] = VAR_6[VAR_19];\n        VAR_6[VAR_19] += 2;\n\n        /* COMMENT_35 */\n        SSL3_RECORD_set_data(&VAR_9[VAR_19], VAR_6[VAR_19] + VAR_14);\n        SSL3_RECORD_set_length(&VAR_9[VAR_19], (int)VAR_3[VAR_19]);\n        SSL3_RECORD_set_input(&VAR_9[VAR_19], (unsigned char *)&VAR_2[VAR_18]);\n        VAR_18 += VAR_3[VAR_19];\n\n        /* COMMENT_36 */\n                                                                       \n           \n\n        /* COMMENT_39 */\n        if (VAR_0->compress != NULL) {\n            if (!ssl3_do_compress(VAR_0, &VAR_9[VAR_19])) {\n                SSLerr(VAR_24, VAR_35);\n                goto err;\n            }\n        } else {\n            memcpy(VAR_9[VAR_19].data, VAR_9[VAR_19].input, VAR_9[VAR_19].length);\n            SSL3_RECORD_reset_input(&VAR_9[VAR_19]);\n        }\n\n        /* COMMENT_40 */\n                                                                         \n                                                                                \n                  \n           \n\n        if (!SSL_USE_ETM(VAR_0) && VAR_11 != 0) {\n            if (VAR_0->method->ssl3_enc->mac(VAR_0, &VAR_9[VAR_19],\n                                         &(VAR_6[VAR_19][VAR_9[VAR_19].length + VAR_14]),\n                                         1) < 0)\n                goto err;\n            SSL3_RECORD_add_length(&VAR_9[VAR_19], VAR_11);\n        }\n\n        SSL3_RECORD_set_data(&VAR_9[VAR_19], VAR_6[VAR_19]);\n        SSL3_RECORD_reset_input(&VAR_9[VAR_19]);\n\n        if (VAR_14) {\n            /* COMMENT_45 */\n                                                               \n               \n            SSL3_RECORD_add_length(&VAR_9[VAR_19], VAR_14);\n        }\n    }\n\n    if (VAR_0->method->ssl3_enc->enc(VAR_0, VAR_9, VAR_4, 1) < 1)\n        goto err;\n\n    for (VAR_19 = 0; VAR_19 < VAR_4; VAR_19++) {\n        if (SSL_USE_ETM(VAR_0) && VAR_11 != 0) {\n            if (VAR_0->method->ssl3_enc->mac(VAR_0, &VAR_9[VAR_19],\n                                         VAR_6[VAR_19] + VAR_9[VAR_19].length, 1) < 0)\n                goto err;\n            SSL3_RECORD_add_length(&VAR_9[VAR_19], VAR_11);\n        }\n\n        /* COMMENT_48 */\n        s2n(SSL3_RECORD_get_length(&VAR_9[VAR_19]), VAR_8[VAR_19]);\n\n        if (VAR_0->msg_callback)\n            VAR_0->msg_callback(1, 0, VAR_36, VAR_8[VAR_19] - 5, 5, VAR_0,\n                            VAR_0->msg_callback_arg);\n\n        /* COMMENT_49 */\n                                                                               \n                          \n           \n        SSL3_RECORD_set_type(&VAR_9[VAR_19], VAR_1); /* COMMENT_53 */\n                                                           \n        SSL3_RECORD_add_length(&VAR_9[VAR_19], VAR_22);\n\n        if (VAR_5) {\n            /* COMMENT_55 */\n                                                                              \n                                \n               \n            if (VAR_19 > 0) {\n                /* COMMENT_59 */\n                SSLerr(VAR_24, VAR_25);\n                goto err;\n            }\n            return SSL3_RECORD_get_length(VAR_9);\n        }\n\n        /* COMMENT_60 */\n        SSL3_BUFFER_set_left(&VAR_0->rlayer.wbuf[VAR_19],\n                             VAR_13 + SSL3_RECORD_get_length(&VAR_9[VAR_19]));\n    }\n\n    /* COMMENT_61 */\n                                                                         \n                    \n       \n    VAR_0->rlayer.wpend_tot = VAR_18;\n    VAR_0->rlayer.wpend_buf = VAR_2;\n    VAR_0->rlayer.wpend_type = VAR_1;\n    VAR_0->rlayer.wpend_ret = VAR_18;\n\n    /* COMMENT_65 */\n    return ssl3_write_pending(VAR_0, VAR_1, VAR_2, VAR_18);\n err:\n    return -1;\n}",
  "func_graph_path_before": "openssl/4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2/rec_layer_s3.c/vul/before/0.json",
  "func": "int do_ssl3_write(SSL *s, int type, const unsigned char *buf,\n                  unsigned int *pipelens, unsigned int numpipes,\n                  int create_empty_fragment)\n{\n    unsigned char *outbuf[SSL_MAX_PIPELINES], *plen[SSL_MAX_PIPELINES];\n    SSL3_RECORD wr[SSL_MAX_PIPELINES];\n    int i, mac_size, clear = 0;\n    int prefix_len = 0;\n    int eivlen;\n    size_t align = 0;\n    SSL3_BUFFER *wb;\n    SSL_SESSION *sess;\n    unsigned int totlen = 0;\n    unsigned int j;\n\n    for (j = 0; j < numpipes; j++)\n        totlen += pipelens[j];\n    /*\n     * first check if there is a SSL3_BUFFER still being written out.  This\n     * will happen with non blocking IO\n     */\n    if (RECORD_LAYER_write_pending(&s->rlayer))\n        return (ssl3_write_pending(s, type, buf, totlen));\n\n    /* If we have an alert to send, lets send it */\n    if (s->s3->alert_dispatch) {\n        i = s->method->ssl_dispatch_alert(s);\n        if (i <= 0)\n            return (i);\n        /* if it went, fall through and send more stuff */\n    }\n\n    if (s->rlayer.numwpipes < numpipes)\n        if (!ssl3_setup_write_buffer(s, numpipes, 0))\n            return -1;\n\n    if (totlen == 0 && !create_empty_fragment)\n        return 0;\n\n    sess = s->session;\n\n    if ((sess == NULL) ||\n        (s->enc_write_ctx == NULL) || (EVP_MD_CTX_md(s->write_hash) == NULL)) {\n        clear = s->enc_write_ctx ? 0 : 1; /* must be AEAD cipher */\n        mac_size = 0;\n    } else {\n        mac_size = EVP_MD_CTX_size(s->write_hash);\n        if (mac_size < 0)\n            goto err;\n    }\n\n    /*\n     * 'create_empty_fragment' is true only when this function calls itself\n     */\n    if (!clear && !create_empty_fragment && !s->s3->empty_fragment_done) {\n        /*\n         * countermeasure against known-IV weakness in CBC ciphersuites (see\n         * http://www.openssl.org/~bodo/tls-cbc.txt)\n         */\n\n        if (s->s3->need_empty_fragments && type == SSL3_RT_APPLICATION_DATA) {\n            /*\n             * recursive function call with 'create_empty_fragment' set; this\n             * prepares and buffers the data for an empty fragment (these\n             * 'prefix_len' bytes are sent out later together with the actual\n             * payload)\n             */\n            unsigned int tmppipelen = 0;\n\n            prefix_len = do_ssl3_write(s, type, buf, &tmppipelen, 1, 1);\n            if (prefix_len <= 0)\n                goto err;\n\n            if (prefix_len >\n                (SSL3_RT_HEADER_LENGTH + SSL3_RT_SEND_MAX_ENCRYPTED_OVERHEAD)) {\n                /* insufficient space */\n                SSLerr(SSL_F_DO_SSL3_WRITE, ERR_R_INTERNAL_ERROR);\n                goto err;\n            }\n        }\n\n        s->s3->empty_fragment_done = 1;\n    }\n\n    if (create_empty_fragment) {\n        wb = &s->rlayer.wbuf[0];\n#if defined(SSL3_ALIGN_PAYLOAD) && SSL3_ALIGN_PAYLOAD!=0\n        /*\n         * extra fragment would be couple of cipher blocks, which would be\n         * multiple of SSL3_ALIGN_PAYLOAD, so if we want to align the real\n         * payload, then we can just pretend we simply have two headers.\n         */\n        align = (size_t)SSL3_BUFFER_get_buf(wb) + 2 * SSL3_RT_HEADER_LENGTH;\n        align = SSL3_ALIGN_PAYLOAD - 1 - ((align - 1) % SSL3_ALIGN_PAYLOAD);\n#endif\n        outbuf[0] = SSL3_BUFFER_get_buf(wb) + align;\n        SSL3_BUFFER_set_offset(wb, align);\n    } else if (prefix_len) {\n        wb = &s->rlayer.wbuf[0];\n        outbuf[0] = SSL3_BUFFER_get_buf(wb) + SSL3_BUFFER_get_offset(wb)\n            + prefix_len;\n    } else {\n        for (j = 0; j < numpipes; j++) {\n            wb = &s->rlayer.wbuf[j];\n#if defined(SSL3_ALIGN_PAYLOAD) && SSL3_ALIGN_PAYLOAD!=0\n            align = (size_t)SSL3_BUFFER_get_buf(wb) + SSL3_RT_HEADER_LENGTH;\n            align = SSL3_ALIGN_PAYLOAD - 1 - ((align - 1) % SSL3_ALIGN_PAYLOAD);\n#endif\n            outbuf[j] = SSL3_BUFFER_get_buf(wb) + align;\n            SSL3_BUFFER_set_offset(wb, align);\n        }\n    }\n\n    /* Explicit IV length, block ciphers appropriate version flag */\n    if (s->enc_write_ctx && SSL_USE_EXPLICIT_IV(s)) {\n        int mode = EVP_CIPHER_CTX_mode(s->enc_write_ctx);\n        if (mode == EVP_CIPH_CBC_MODE) {\n            eivlen = EVP_CIPHER_CTX_iv_length(s->enc_write_ctx);\n            if (eivlen <= 1)\n                eivlen = 0;\n        }\n        /* Need explicit part of IV for GCM mode */\n        else if (mode == EVP_CIPH_GCM_MODE)\n            eivlen = EVP_GCM_TLS_EXPLICIT_IV_LEN;\n        else if (mode == EVP_CIPH_CCM_MODE)\n            eivlen = EVP_CCM_TLS_EXPLICIT_IV_LEN;\n        else\n            eivlen = 0;\n    } else\n        eivlen = 0;\n\n    totlen = 0;\n    /* Clear our SSL3_RECORD structures */\n    memset(wr, 0, sizeof wr);\n    for (j = 0; j < numpipes; j++) {\n        /* write the header */\n        *(outbuf[j]++) = type & 0xff;\n        SSL3_RECORD_set_type(&wr[j], type);\n\n        *(outbuf[j]++) = (s->version >> 8);\n        /*\n         * Some servers hang if initial client hello is larger than 256 bytes\n         * and record version number > TLS 1.0\n         */\n        if (SSL_get_state(s) == TLS_ST_CW_CLNT_HELLO\n            && !s->renegotiate && TLS1_get_version(s) > TLS1_VERSION)\n            *(outbuf[j]++) = 0x1;\n        else\n            *(outbuf[j]++) = s->version & 0xff;\n\n        /* field where we are to write out packet length */\n        plen[j] = outbuf[j];\n        outbuf[j] += 2;\n\n        /* lets setup the record stuff. */\n        SSL3_RECORD_set_data(&wr[j], outbuf[j] + eivlen);\n        SSL3_RECORD_set_length(&wr[j], (int)pipelens[j]);\n        SSL3_RECORD_set_input(&wr[j], (unsigned char *)&buf[totlen]);\n        totlen += pipelens[j];\n\n        /*\n         * we now 'read' from wr->input, wr->length bytes into wr->data\n         */\n\n        /* first we compress */\n        if (s->compress != NULL) {\n            if (!ssl3_do_compress(s, &wr[j])) {\n                SSLerr(SSL_F_DO_SSL3_WRITE, SSL_R_COMPRESSION_FAILURE);\n                goto err;\n            }\n        } else {\n            memcpy(wr[j].data, wr[j].input, wr[j].length);\n            SSL3_RECORD_reset_input(&wr[j]);\n        }\n\n        /*\n         * we should still have the output to wr->data and the input from\n         * wr->input.  Length should be wr->length. wr->data still points in the\n         * wb->buf\n         */\n\n        if (!SSL_WRITE_ETM(s) && mac_size != 0) {\n            if (s->method->ssl3_enc->mac(s, &wr[j],\n                                         &(outbuf[j][wr[j].length + eivlen]),\n                                         1) < 0)\n                goto err;\n            SSL3_RECORD_add_length(&wr[j], mac_size);\n        }\n\n        SSL3_RECORD_set_data(&wr[j], outbuf[j]);\n        SSL3_RECORD_reset_input(&wr[j]);\n\n        if (eivlen) {\n            /*\n             * if (RAND_pseudo_bytes(p, eivlen) <= 0) goto err;\n             */\n            SSL3_RECORD_add_length(&wr[j], eivlen);\n        }\n    }\n\n    if (s->method->ssl3_enc->enc(s, wr, numpipes, 1) < 1)\n        goto err;\n\n    for (j = 0; j < numpipes; j++) {\n        if (SSL_WRITE_ETM(s) && mac_size != 0) {\n            if (s->method->ssl3_enc->mac(s, &wr[j],\n                                         outbuf[j] + wr[j].length, 1) < 0)\n                goto err;\n            SSL3_RECORD_add_length(&wr[j], mac_size);\n        }\n\n        /* record length after mac and block padding */\n        s2n(SSL3_RECORD_get_length(&wr[j]), plen[j]);\n\n        if (s->msg_callback)\n            s->msg_callback(1, 0, SSL3_RT_HEADER, plen[j] - 5, 5, s,\n                            s->msg_callback_arg);\n\n        /*\n         * we should now have wr->data pointing to the encrypted data, which is\n         * wr->length long\n         */\n        SSL3_RECORD_set_type(&wr[j], type); /* not needed but helps for\n                                             * debugging */\n        SSL3_RECORD_add_length(&wr[j], SSL3_RT_HEADER_LENGTH);\n\n        if (create_empty_fragment) {\n            /*\n             * we are in a recursive call; just return the length, don't write\n             * out anything here\n             */\n            if (j > 0) {\n                /* We should never be pipelining an empty fragment!! */\n                SSLerr(SSL_F_DO_SSL3_WRITE, ERR_R_INTERNAL_ERROR);\n                goto err;\n            }\n            return SSL3_RECORD_get_length(wr);\n        }\n\n        /* now let's set up wb */\n        SSL3_BUFFER_set_left(&s->rlayer.wbuf[j],\n                             prefix_len + SSL3_RECORD_get_length(&wr[j]));\n    }\n\n    /*\n     * memorize arguments so that ssl3_write_pending can detect bad write\n     * retries later\n     */\n    s->rlayer.wpend_tot = totlen;\n    s->rlayer.wpend_buf = buf;\n    s->rlayer.wpend_type = type;\n    s->rlayer.wpend_ret = totlen;\n\n    /* we now just need to write the buffer */\n    return ssl3_write_pending(s, type, buf, totlen);\n err:\n    return -1;\n}",
  "abstract_func": "int do_ssl3_write(SSL *VAR_0, int VAR_1, const unsigned char *VAR_2,\n                  unsigned int *VAR_3, unsigned int VAR_4,\n                  int VAR_5)\n{\n    unsigned char *VAR_6[VAR_7], *VAR_8[VAR_7];\n    SSL3_RECORD VAR_9[VAR_7];\n    int VAR_10, VAR_11, VAR_12 = 0;\n    int VAR_13 = 0;\n    int VAR_14;\n    size_t VAR_15 = 0;\n    SSL3_BUFFER *VAR_16;\n    SSL_SESSION *VAR_17;\n    unsigned int VAR_18 = 0;\n    unsigned int VAR_19;\n\n    for (VAR_19 = 0; VAR_19 < VAR_4; VAR_19++)\n        VAR_18 += VAR_3[VAR_19];\n    /* COMMENT_0 */\n                                                                           \n                                       \n       \n    if (RECORD_LAYER_write_pending(&VAR_0->rlayer))\n        return (ssl3_write_pending(VAR_0, VAR_1, VAR_2, VAR_18));\n\n    /* COMMENT_4 */\n    if (VAR_0->s3->alert_dispatch) {\n        VAR_10 = VAR_0->method->ssl_dispatch_alert(VAR_0);\n        if (VAR_10 <= 0)\n            return (VAR_10);\n        /* COMMENT_5 */\n    }\n\n    if (VAR_0->rlayer.numwpipes < VAR_4)\n        if (!ssl3_setup_write_buffer(VAR_0, VAR_4, 0))\n            return -1;\n\n    if (VAR_18 == 0 && !VAR_5)\n        return 0;\n\n    VAR_17 = VAR_0->session;\n\n    if ((VAR_17 == NULL) ||\n        (VAR_0->enc_write_ctx == NULL) || (EVP_MD_CTX_md(VAR_0->write_hash) == NULL)) {\n        VAR_12 = VAR_0->enc_write_ctx ? 0 : 1; /* COMMENT_6 */\n        VAR_11 = 0;\n    } else {\n        VAR_11 = EVP_MD_CTX_size(VAR_0->write_hash);\n        if (VAR_11 < 0)\n            goto err;\n    }\n\n    /* COMMENT_7 */\n                                                                           \n       \n    if (!VAR_12 && !VAR_5 && !VAR_0->s3->empty_fragment_done) {\n        /* COMMENT_10 */\n                                                                            \n                                                    \n           \n\n        if (VAR_0->s3->need_empty_fragments && VAR_1 == VAR_20) {\n            /* COMMENT_14 */\n                                                                             \n                                                                         \n                                                                             \n                       \n               \n            unsigned int VAR_21 = 0;\n\n            VAR_13 = do_ssl3_write(VAR_0, VAR_1, VAR_2, &VAR_21, 1, 1);\n            if (VAR_13 <= 0)\n                goto err;\n\n            if (VAR_13 >\n                (VAR_22 + VAR_23)) {\n                /* COMMENT_20 */\n                SSLerr(VAR_24, VAR_25);\n                goto err;\n            }\n        }\n\n        VAR_0->s3->empty_fragment_done = 1;\n    }\n\n    if (VAR_5) {\n        VAR_16 = &VAR_0->rlayer.wbuf[0];\n#if defined(VAR_26) && VAR_26!=0\n        /* COMMENT_21 */\n                                                                          \n                                                                          \n                                                                        \n           \n        VAR_15 = (size_t)SSL3_BUFFER_get_buf(VAR_16) + 2 * VAR_22;\n        VAR_15 = VAR_26 - 1 - ((VAR_15 - 1) % VAR_26);\n#endif\n        VAR_6[0] = SSL3_BUFFER_get_buf(VAR_16) + VAR_15;\n        SSL3_BUFFER_set_offset(VAR_16, VAR_15);\n    } else if (VAR_13) {\n        VAR_16 = &VAR_0->rlayer.wbuf[0];\n        VAR_6[0] = SSL3_BUFFER_get_buf(VAR_16) + SSL3_BUFFER_get_offset(VAR_16)\n            + VAR_13;\n    } else {\n        for (VAR_19 = 0; VAR_19 < VAR_4; VAR_19++) {\n            VAR_16 = &VAR_0->rlayer.wbuf[VAR_19];\n#if defined(VAR_26) && VAR_26!=0\n            VAR_15 = (size_t)SSL3_BUFFER_get_buf(VAR_16) + VAR_22;\n            VAR_15 = VAR_26 - 1 - ((VAR_15 - 1) % VAR_26);\n#endif\n            VAR_6[VAR_19] = SSL3_BUFFER_get_buf(VAR_16) + VAR_15;\n            SSL3_BUFFER_set_offset(VAR_16, VAR_15);\n        }\n    }\n\n    /* COMMENT_26 */\n    if (VAR_0->enc_write_ctx && SSL_USE_EXPLICIT_IV(VAR_0)) {\n        int VAR_27 = EVP_CIPHER_CTX_mode(VAR_0->enc_write_ctx);\n        if (VAR_27 == VAR_28) {\n            VAR_14 = EVP_CIPHER_CTX_iv_length(VAR_0->enc_write_ctx);\n            if (VAR_14 <= 1)\n                VAR_14 = 0;\n        }\n        /* COMMENT_27 */\n        else if (VAR_27 == VAR_29)\n            VAR_14 = VAR_30;\n        else if (VAR_27 == VAR_31)\n            VAR_14 = VAR_32;\n        else\n            VAR_14 = 0;\n    } else\n        VAR_14 = 0;\n\n    VAR_18 = 0;\n    /* COMMENT_28 */\n    memset(VAR_9, 0, sizeof VAR_9);\n    for (VAR_19 = 0; VAR_19 < VAR_4; VAR_19++) {\n        /* COMMENT_29 */\n        *(VAR_6[VAR_19]++) = VAR_1 & 0xff;\n        SSL3_RECORD_set_type(&VAR_9[VAR_19], VAR_1);\n\n        *(VAR_6[VAR_19]++) = (VAR_0->version >> 8);\n        /* COMMENT_30 */\n                                                                             \n                                              \n           \n        if (SSL_get_state(VAR_0) == VAR_33\n            && !VAR_0->renegotiate && TLS1_get_version(VAR_0) > VAR_34)\n            *(VAR_6[VAR_19]++) = 0x1;\n        else\n            *(VAR_6[VAR_19]++) = VAR_0->version & 0xff;\n\n        /* COMMENT_34 */\n        VAR_8[VAR_19] = VAR_6[VAR_19];\n        VAR_6[VAR_19] += 2;\n\n        /* COMMENT_35 */\n        SSL3_RECORD_set_data(&VAR_9[VAR_19], VAR_6[VAR_19] + VAR_14);\n        SSL3_RECORD_set_length(&VAR_9[VAR_19], (int)VAR_3[VAR_19]);\n        SSL3_RECORD_set_input(&VAR_9[VAR_19], (unsigned char *)&VAR_2[VAR_18]);\n        VAR_18 += VAR_3[VAR_19];\n\n        /* COMMENT_36 */\n                                                                       \n           \n\n        /* COMMENT_39 */\n        if (VAR_0->compress != NULL) {\n            if (!ssl3_do_compress(VAR_0, &VAR_9[VAR_19])) {\n                SSLerr(VAR_24, VAR_35);\n                goto err;\n            }\n        } else {\n            memcpy(VAR_9[VAR_19].data, VAR_9[VAR_19].input, VAR_9[VAR_19].length);\n            SSL3_RECORD_reset_input(&VAR_9[VAR_19]);\n        }\n\n        /* COMMENT_40 */\n                                                                         \n                                                                                \n                  \n           \n\n        if (!SSL_WRITE_ETM(VAR_0) && VAR_11 != 0) {\n            if (VAR_0->method->ssl3_enc->mac(VAR_0, &VAR_9[VAR_19],\n                                         &(VAR_6[VAR_19][VAR_9[VAR_19].length + VAR_14]),\n                                         1) < 0)\n                goto err;\n            SSL3_RECORD_add_length(&VAR_9[VAR_19], VAR_11);\n        }\n\n        SSL3_RECORD_set_data(&VAR_9[VAR_19], VAR_6[VAR_19]);\n        SSL3_RECORD_reset_input(&VAR_9[VAR_19]);\n\n        if (VAR_14) {\n            /* COMMENT_45 */\n                                                               \n               \n            SSL3_RECORD_add_length(&VAR_9[VAR_19], VAR_14);\n        }\n    }\n\n    if (VAR_0->method->ssl3_enc->enc(VAR_0, VAR_9, VAR_4, 1) < 1)\n        goto err;\n\n    for (VAR_19 = 0; VAR_19 < VAR_4; VAR_19++) {\n        if (SSL_WRITE_ETM(VAR_0) && VAR_11 != 0) {\n            if (VAR_0->method->ssl3_enc->mac(VAR_0, &VAR_9[VAR_19],\n                                         VAR_6[VAR_19] + VAR_9[VAR_19].length, 1) < 0)\n                goto err;\n            SSL3_RECORD_add_length(&VAR_9[VAR_19], VAR_11);\n        }\n\n        /* COMMENT_48 */\n        s2n(SSL3_RECORD_get_length(&VAR_9[VAR_19]), VAR_8[VAR_19]);\n\n        if (VAR_0->msg_callback)\n            VAR_0->msg_callback(1, 0, VAR_36, VAR_8[VAR_19] - 5, 5, VAR_0,\n                            VAR_0->msg_callback_arg);\n\n        /* COMMENT_49 */\n                                                                               \n                          \n           \n        SSL3_RECORD_set_type(&VAR_9[VAR_19], VAR_1); /* COMMENT_53 */\n                                                           \n        SSL3_RECORD_add_length(&VAR_9[VAR_19], VAR_22);\n\n        if (VAR_5) {\n            /* COMMENT_55 */\n                                                                              \n                                \n               \n            if (VAR_19 > 0) {\n                /* COMMENT_59 */\n                SSLerr(VAR_24, VAR_25);\n                goto err;\n            }\n            return SSL3_RECORD_get_length(VAR_9);\n        }\n\n        /* COMMENT_60 */\n        SSL3_BUFFER_set_left(&VAR_0->rlayer.wbuf[VAR_19],\n                             VAR_13 + SSL3_RECORD_get_length(&VAR_9[VAR_19]));\n    }\n\n    /* COMMENT_61 */\n                                                                         \n                    \n       \n    VAR_0->rlayer.wpend_tot = VAR_18;\n    VAR_0->rlayer.wpend_buf = VAR_2;\n    VAR_0->rlayer.wpend_type = VAR_1;\n    VAR_0->rlayer.wpend_ret = VAR_18;\n\n    /* COMMENT_65 */\n    return ssl3_write_pending(VAR_0, VAR_1, VAR_2, VAR_18);\n err:\n    return -1;\n}",
  "func_graph_path": "openssl/4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2/rec_layer_s3.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -179,7 +179,7 @@\n          * wb->buf\n          */\n \n-        if (!SSL_USE_ETM(s) && mac_size != 0) {\n+        if (!SSL_WRITE_ETM(s) && mac_size != 0) {\n             if (s->method->ssl3_enc->mac(s, &wr[j],\n                                          &(outbuf[j][wr[j].length + eivlen]),\n                                          1) < 0)\n@@ -202,7 +202,7 @@\n         goto err;\n \n     for (j = 0; j < numpipes; j++) {\n-        if (SSL_USE_ETM(s) && mac_size != 0) {\n+        if (SSL_WRITE_ETM(s) && mac_size != 0) {\n             if (s->method->ssl3_enc->mac(s, &wr[j],\n                                          outbuf[j] + wr[j].length, 1) < 0)\n                 goto err;",
  "diff_line_info": {
    "deleted_lines": [
      "        if (!SSL_USE_ETM(s) && mac_size != 0) {",
      "        if (SSL_USE_ETM(s) && mac_size != 0) {"
    ],
    "added_lines": [
      "        if (!SSL_WRITE_ETM(s) && mac_size != 0) {",
      "        if (SSL_WRITE_ETM(s) && mac_size != 0) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/EktapopaT/openssl/pull/1",
  "description": {
    "pr_info": {
      "title": "Open ssl 1 1 0 stable",
      "number": 1
    },
    "comment": [
      "<!--\r\nThank you for your pull request. Please review below requirements.\r\n\r\nContributors guide: https://github.com/openssl/openssl/blob/master/CONTRIBUTING\r\n-->\r\n\r\n##### Checklist\r\n<!-- Remove items that do not apply. For completed items, change [ ] to [x]. -->\r\n- [ ] documentation is added or updated\r\n- [ ] tests are added or updated\r\n- [ ] CLA is signed\r\n\r\n##### Description of change\r\n<!-- Provide a description of the changes.\r\n\r\nIf it fixes a github issue, add Fixes #XXXX.\r\n-->\r\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses a crash during TLS renegotiation caused by improper handling of ETM flags, which could lead to a DoS attack. The code changes modify how ETM is applied during writes, preventing the crash. This resolves a security vulnerability (CVE-2017-3733) impacting availability.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 1.0"
}