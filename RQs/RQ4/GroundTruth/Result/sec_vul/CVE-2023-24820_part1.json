{
  "cve_id": "CVE-2023-24820",
  "cwe_ids": [
    "CWE-787",
    "CWE-191"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "RIOT-OS/RIOT",
  "commit_msg": "gnrc_sixlowpan_iphc: fix integer underflow in gnrc_sixlowpan_iphc_recv()\n\n(cherry picked from commit 2709fbd827b688fe62df2c77c316914f4a3a6d4a)",
  "commit_hash": "d052e2ee166e55bbdfe4c455e65dbd7e3479ebe3",
  "git_url": "https://github.com/RIOT-OS/RIOT/commit/d052e2ee166e55bbdfe4c455e65dbd7e3479ebe3",
  "file_path": "sys/net/gnrc/network_layer/sixlowpan/iphc/gnrc_sixlowpan_iphc.c",
  "func_name": "gnrc_sixlowpan_iphc_recv",
  "func_before": "void gnrc_sixlowpan_iphc_recv(gnrc_pktsnip_t *sixlo, void *rbuf_ptr,\n                              unsigned page)\n{\n    assert(sixlo != NULL);\n    gnrc_pktsnip_t *ipv6, *netif;\n    gnrc_netif_t *iface;\n    ipv6_hdr_t *ipv6_hdr;\n    uint8_t *iphc_hdr = sixlo->data;\n    size_t payload_offset;\n    size_t uncomp_hdr_len = sizeof(ipv6_hdr_t);\n    gnrc_sixlowpan_frag_rb_t *rbuf = rbuf_ptr;\n#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_VRB\n    gnrc_sixlowpan_frag_vrb_t *vrbe = NULL;\n#endif  /* MODULE_GNRC_SIXLOWPAN_FRAG_VRB */\n\n    if (rbuf != NULL) {\n        ipv6 = rbuf->pkt;\n        assert(ipv6 != NULL);\n        if ((ipv6->size < sizeof(ipv6_hdr_t)) &&\n            (gnrc_pktbuf_realloc_data(ipv6, sizeof(ipv6_hdr_t)) != 0)) {\n            DEBUG(\"6lo iphc: no space to decompress IPHC\\n\");\n            _recv_error_release(sixlo, ipv6, rbuf);\n            return;\n        }\n    }\n    else {\n        ipv6 = gnrc_pktbuf_add(NULL, NULL, sizeof(ipv6_hdr_t),\n                               GNRC_NETTYPE_IPV6);\n        if (ipv6 == NULL) {\n            gnrc_pktbuf_release(sixlo);\n            return;\n        }\n    }\n\n    assert(ipv6->size >= sizeof(ipv6_hdr_t));\n\n    netif = gnrc_pktsnip_search_type(sixlo, GNRC_NETTYPE_NETIF);\n    assert(netif != NULL);\n    iface = gnrc_netif_hdr_get_netif(netif->data);\n    payload_offset = _iphc_ipv6_decode(iphc_hdr, netif->data, iface,\n                                       ipv6->data);\n    if (payload_offset == 0) {\n        /* unable to parse IPHC header */\n        _recv_error_release(sixlo, ipv6, rbuf);\n        return;\n    }\n#ifdef MODULE_GNRC_SIXLOWPAN_IPHC_NHC\n    if (iphc_hdr[IPHC1_IDX] & SIXLOWPAN_IPHC1_NH) {\n        bool nhc_header = true;\n        ipv6_hdr = ipv6->data;\n        size_t prev_nh_offset = (&ipv6_hdr->nh) - ((uint8_t *)ipv6->data);\n\n        while (nhc_header) {\n            switch (iphc_hdr[payload_offset] & NHC_ID_MASK) {\n                case NHC_IPV6_EXT_ID:\n                case NHC_IPV6_EXT_ID_ALT:\n                    payload_offset = _iphc_nhc_ipv6_decode(sixlo,\n                                                           payload_offset,\n                                                           rbuf,\n                                                           &prev_nh_offset,\n                                                           ipv6,\n                                                           &uncomp_hdr_len);\n                    if (payload_offset == 0) {\n                        _recv_error_release(sixlo, ipv6, rbuf);\n                        return;\n                    }\n                    /* prev_nh_offset is set to 0 if next header is not\n                     * compressed (== NH flag in compression header not set) */\n                    nhc_header = (prev_nh_offset > 0);\n                    break;\n                case NHC_UDP_ID: {\n                    payload_offset = _iphc_nhc_udp_decode(sixlo,\n                                                          payload_offset,\n                                                          rbuf,\n                                                          prev_nh_offset,\n                                                          ipv6,\n                                                          &uncomp_hdr_len);\n                    if (payload_offset == 0) {\n                        _recv_error_release(sixlo, ipv6, rbuf);\n                        return;\n                    }\n                    /* no NHC after UDP header */\n                    nhc_header = false;\n                    break;\n                }\n                default:\n                    nhc_header = false;\n                    break;\n            }\n        }\n    }\n#endif\n    uint16_t payload_len;\n    if (rbuf != NULL) {\n        /* for a fragmented datagram we know the overall length already */\n        if (_is_rfrag(sixlo)) {\n            DEBUG(\"6lo iphc: calculating payload length for SFR\\n\");\n            DEBUG(\" - rbuf->super.datagram_size: %u\\n\",\n                  rbuf->super.datagram_size);\n            DEBUG(\" - payload_offset: %u\\n\", (unsigned)payload_offset);\n            DEBUG(\" - uncomp_hdr_len: %u\\n\", (unsigned)uncomp_hdr_len);\n            /* set IPv6 header payload length field to the length of whatever is\n             * left after removing the 6LoWPAN header and adding uncompressed\n             * headers */\n            payload_len = (rbuf->super.datagram_size - payload_offset) +\n                          (uncomp_hdr_len - sizeof(ipv6_hdr_t));\n            DEBUG(\"   => %u\\n\", payload_len);\n            /* adapt datagram size for uncompressed datagram */\n#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_SFR\n            /* guard required because SFR-specific field of vrbe is accessed */\n            rbuf->offset_diff += (uncomp_hdr_len - payload_offset);\n            rbuf->super.datagram_size += rbuf->offset_diff;\n#endif  /* MODULE_GNRC_SIXLOWPAN_FRAG_VRB */\n        }\n        else {\n            /* for a fragmented datagram we know the overall length already */\n            payload_len = (uint16_t)(rbuf->super.datagram_size - sizeof(ipv6_hdr_t));\n        }\n#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_VRB\n        DEBUG(\"6lo iphc: VRB present, trying to create entry for dst %s\\n\",\n              ipv6_addr_to_str(addr_str, &ipv6_hdr->dst, sizeof(addr_str)));\n        /* re-assign IPv6 header in case realloc changed the address */\n        ipv6_hdr = ipv6->data;\n        /* only create virtual reassembly buffer entry from IPv6 destination if\n         * the current first fragment is the only received fragment in the\n         * reassembly buffer so far and the hop-limit is larger than 1\n         */\n        if ((rbuf->super.current_size <= sixlo->size) && (ipv6_hdr->hl > 1U) &&\n            /* and there is enough slack for changing compression */\n            (rbuf->super.current_size <= iface->sixlo.max_frag_size) &&\n            (vrbe = gnrc_sixlowpan_frag_vrb_from_route(&rbuf->super, iface,\n                                                       ipv6))) {\n            /* add netif header to `ipv6` so its flags can be used when\n             * forwarding the fragment */\n            sixlo = gnrc_pkt_delete(sixlo, netif);\n            ipv6 = gnrc_pkt_append(ipv6, netif);\n            /* provide space to copy remaining payload */\n            if (gnrc_pktbuf_realloc_data(ipv6, uncomp_hdr_len + sixlo->size -\n                                         payload_offset) != 0) {\n                DEBUG(\"6lo iphc: no space left to copy payload\\n\");\n                gnrc_sixlowpan_frag_vrb_rm(vrbe);\n                _recv_error_release(sixlo, ipv6, rbuf);\n                return;\n            }\n        }\n        /* reallocate to copy complete payload */\n        else if (gnrc_pktbuf_realloc_data(ipv6, rbuf->super.datagram_size) != 0) {\n            DEBUG(\"6lo iphc: no space left to reassemble payload\\n\");\n            _recv_error_release(sixlo, ipv6, rbuf);\n            return;\n        }\n#endif  /* MODULE_GNRC_SIXLOWPAN_FRAG_VRB */\n    }\n    else {\n        /* set IPv6 header payload length field to the length of whatever is left\n         * after removing the 6LoWPAN header and adding uncompressed headers */\n        payload_len = (sixlo->size + uncomp_hdr_len -\n                       payload_offset - sizeof(ipv6_hdr_t));\n    }\n    if (rbuf == NULL) {\n        /* (rbuf == NULL) => forwarding is not affected by this */\n        if (gnrc_pktbuf_realloc_data(ipv6, uncomp_hdr_len + payload_len) != 0) {\n            DEBUG(\"6lo iphc: no space left to copy payload\\n\");\n            _recv_error_release(sixlo, ipv6, rbuf);\n            return;\n        }\n    }\n    else {\n        if (ipv6->size < (uncomp_hdr_len + (sixlo->size - payload_offset))) {\n            DEBUG(\"6lo iphc: not enough space to copy payload.\\n\");\n            DEBUG(\"6lo iphc: potentially malicious datagram size received.\\n\");\n            _recv_error_release(sixlo, ipv6, rbuf);\n            return;\n        }\n    }\n\n    /* re-assign IPv6 header in case realloc changed the address */\n    ipv6_hdr = ipv6->data;\n    ipv6_hdr->len = byteorder_htons(payload_len);\n    memcpy(((uint8_t *)ipv6->data) + uncomp_hdr_len,\n           ((uint8_t *)sixlo->data) + payload_offset,\n           sixlo->size - payload_offset);\n    if (rbuf != NULL) {\n        rbuf->super.current_size += (uncomp_hdr_len - payload_offset);\n#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_VRB\n        if (vrbe != NULL) {\n            int res = -1;\n            DEBUG(\"6lo iphc: found route, trying to forward\\n\");\n            ipv6_hdr->hl--;\n            vrbe->super.current_size = rbuf->super.current_size;\n            if ((ipv6 = _encode_frag_for_forwarding(ipv6, vrbe))) {\n#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_SFR\n                /* guard required because SFR-specific field of vrbe is\n                 * accessed */\n                if (_is_rfrag(sixlo)) {\n                    vrbe->in_netif = iface;\n                    /* calculate offset difference due to compression */\n                    vrbe->offset_diff = ((int)gnrc_pkt_len(ipv6->next)) -\n                                        sixlo->size;\n                }\n#endif  /* MODULE_GNRC_SIXLOWPAN_FRAG_SFR */\n                if ((res = _forward_frag(ipv6, sixlo->next, vrbe, page)) == 0) {\n                    DEBUG(\"6lo iphc: successfully recompressed and forwarded \"\n                          \"1st fragment\\n\");\n                    /* empty list, as it should be in VRB now */\n                    rbuf->super.ints = NULL;\n                }\n            }\n            if ((ipv6 == NULL) || (res < 0)) {\n                /* TODO: There is a potential to fall-back to classic reassembly\n                 * when ipv6 != NULL. However, since `ipv6` was reversed in\n                 * `_encode_frag_for_forwarding`, that step needs to be reversed\n                 * or a version of the old ipv6 needs to be held in the buffer.\n                 * For now, just drop the packet all together in an error case\n                 */\n                gnrc_sixlowpan_frag_vrb_rm(vrbe);\n            }\n            gnrc_pktbuf_release(sixlo);\n            /* don't remove `rbuf->pkt` (aka ipv6) as it was forwarded */\n            gnrc_sixlowpan_frag_rb_remove(rbuf);\n            return;\n        }\n        DEBUG(\"6lo iphc: no route found, reassemble datagram normally\\n\");\n#endif  /* MODULE_GNRC_SIXLOWPAN_FRAG_VRB */\n    }\n    else {\n        sixlo = gnrc_pkt_delete(sixlo, netif);\n        ipv6 = gnrc_pkt_append(ipv6, netif);\n        gnrc_sixlowpan_dispatch_recv(ipv6, NULL, page);\n    }\n    gnrc_pktbuf_release(sixlo);\n    return;\n}",
  "abstract_func_before": "void gnrc_sixlowpan_iphc_recv(gnrc_pktsnip_t *VAR_0, void *VAR_1,\n                              unsigned VAR_2)\n{\n    assert(VAR_0 != NULL);\n    gnrc_pktsnip_t *VAR_3, *VAR_4;\n    gnrc_netif_t *VAR_5;\n    ipv6_hdr_t *VAR_6;\n    uint8_t *VAR_7 = VAR_0->data;\n    size_t VAR_8;\n    size_t VAR_9 = sizeof(ipv6_hdr_t);\n    gnrc_sixlowpan_frag_rb_t *VAR_10 = VAR_1;\n#ifdef VAR_11\n    gnrc_sixlowpan_frag_vrb_t *VAR_12 = NULL;\n#endif  /* COMMENT_0 */\n\n    if (VAR_10 != NULL) {\n        VAR_3 = VAR_10->pkt;\n        assert(VAR_3 != NULL);\n        if ((VAR_3->size < sizeof(ipv6_hdr_t)) &&\n            (gnrc_pktbuf_realloc_data(VAR_3, sizeof(ipv6_hdr_t)) != 0)) {\n            DEBUG(\"6lo iphc: no space to decompress IPHC\\n\");\n            _recv_error_release(VAR_0, VAR_3, VAR_10);\n            return;\n        }\n    }\n    else {\n        VAR_3 = gnrc_pktbuf_add(NULL, NULL, sizeof(ipv6_hdr_t),\n                               VAR_13);\n        if (VAR_3 == NULL) {\n            gnrc_pktbuf_release(VAR_0);\n            return;\n        }\n    }\n\n    assert(VAR_3->size >= sizeof(ipv6_hdr_t));\n\n    VAR_4 = gnrc_pktsnip_search_type(VAR_0, VAR_14);\n    assert(VAR_4 != NULL);\n    VAR_5 = gnrc_netif_hdr_get_netif(VAR_4->data);\n    VAR_8 = _iphc_ipv6_decode(VAR_7, VAR_4->data, VAR_5,\n                                       VAR_3->data);\n    if (VAR_8 == 0) {\n        /* COMMENT_1 */\n        _recv_error_release(VAR_0, VAR_3, VAR_10);\n        return;\n    }\n#ifdef VAR_15\n    if (VAR_7[VAR_16] & VAR_17) {\n        bool VAR_18 = true;\n        VAR_6 = VAR_3->data;\n        size_t VAR_19 = (&VAR_6->nh) - ((uint8_t *)VAR_3->data);\n\n        while (VAR_18) {\n            switch (VAR_7[VAR_8] & VAR_20) {\n                case VAR_21:\n                case VAR_22:\n                    VAR_8 = _iphc_nhc_ipv6_decode(VAR_0,\n                                                           VAR_8,\n                                                           VAR_10,\n                                                           &VAR_19,\n                                                           VAR_3,\n                                                           &VAR_9);\n                    if (VAR_8 == 0) {\n                        _recv_error_release(VAR_0, VAR_3, VAR_10);\n                        return;\n                    }\n                    /* COMMENT_2 */\n                                                                               \n                    VAR_18 = (VAR_19 > 0);\n                    break;\n                case VAR_23: {\n                    VAR_8 = _iphc_nhc_udp_decode(VAR_0,\n                                                          VAR_8,\n                                                          VAR_10,\n                                                          VAR_19,\n                                                          VAR_3,\n                                                          &VAR_9);\n                    if (VAR_8 == 0) {\n                        _recv_error_release(VAR_0, VAR_3, VAR_10);\n                        return;\n                    }\n                    /* COMMENT_4 */\n                    VAR_18 = false;\n                    break;\n                }\n                default:\n                    VAR_18 = false;\n                    break;\n            }\n        }\n    }\n#endif\n    uint16_t VAR_24;\n    if (VAR_10 != NULL) {\n        /* COMMENT_5 */\n        if (_is_rfrag(VAR_0)) {\n            DEBUG(\"6lo iphc: calculating payload length for SFR\\n\");\n            DEBUG(\" - rbuf->super.datagram_size: %u\\n\",\n                  VAR_10->super.datagram_size);\n            DEBUG(\" - payload_offset: %u\\n\", (unsigned)VAR_8);\n            DEBUG(\" - uncomp_hdr_len: %u\\n\", (unsigned)VAR_9);\n            /* COMMENT_6 */\n                                                                             \n                         \n            VAR_24 = (VAR_10->super.datagram_size - VAR_8) +\n                          (VAR_9 - sizeof(ipv6_hdr_t));\n            DEBUG(\"   => %u\\n\", VAR_24);\n            /* COMMENT_9 */\n#ifdef VAR_25\n            /* COMMENT_10 */\n            VAR_10->offset_diff += (VAR_9 - VAR_8);\n            VAR_10->super.datagram_size += VAR_10->offset_diff;\n#endif  /* COMMENT_0 */\n        }\n        else {\n            /* COMMENT_5 */\n            VAR_24 = (uint16_t)(VAR_10->super.datagram_size - sizeof(ipv6_hdr_t));\n        }\n#ifdef VAR_11\n        DEBUG(\"6lo iphc: VRB present, trying to create entry for dst %s\\n\",\n              ipv6_addr_to_str(VAR_26, &VAR_6->dst, sizeof(VAR_26)));\n        /* COMMENT_11 */\n        VAR_6 = VAR_3->data;\n        /* COMMENT_12 */\n                                                                          \n                                                                      \n           \n        if ((VAR_10->super.current_size <= VAR_0->size) && (VAR_6->hl > 1U) &&\n            /* COMMENT_16 */\n            (VAR_10->super.current_size <= VAR_5->sixlo.max_frag_size) &&\n            (VAR_12 = gnrc_sixlowpan_frag_vrb_from_route(&VAR_10->super, VAR_5,\n                                                       VAR_3))) {\n            /* COMMENT_17 */\n                                         \n            VAR_0 = gnrc_pkt_delete(VAR_0, VAR_4);\n            VAR_3 = gnrc_pkt_append(VAR_3, VAR_4);\n            /* COMMENT_19 */\n            if (gnrc_pktbuf_realloc_data(VAR_3, VAR_9 + VAR_0->size -\n                                         VAR_8) != 0) {\n                DEBUG(\"6lo iphc: no space left to copy payload\\n\");\n                gnrc_sixlowpan_frag_vrb_rm(VAR_12);\n                _recv_error_release(VAR_0, VAR_3, VAR_10);\n                return;\n            }\n        }\n        /* COMMENT_20 */\n        else if (gnrc_pktbuf_realloc_data(VAR_3, VAR_10->super.datagram_size) != 0) {\n            DEBUG(\"6lo iphc: no space left to reassemble payload\\n\");\n            _recv_error_release(VAR_0, VAR_3, VAR_10);\n            return;\n        }\n#endif  /* COMMENT_0 */\n    }\n    else {\n        /* COMMENT_21 */\n                                                                               \n        VAR_24 = (VAR_0->size + VAR_9 -\n                       VAR_8 - sizeof(ipv6_hdr_t));\n    }\n    if (VAR_10 == NULL) {\n        /* COMMENT_23 */\n        if (gnrc_pktbuf_realloc_data(VAR_3, VAR_9 + VAR_24) != 0) {\n            DEBUG(\"6lo iphc: no space left to copy payload\\n\");\n            _recv_error_release(VAR_0, VAR_3, VAR_10);\n            return;\n        }\n    }\n    else {\n        if (VAR_3->size < (VAR_9 + (VAR_0->size - VAR_8))) {\n            DEBUG(\"6lo iphc: not enough space to copy payload.\\n\");\n            DEBUG(\"6lo iphc: potentially malicious datagram size received.\\n\");\n            _recv_error_release(VAR_0, VAR_3, VAR_10);\n            return;\n        }\n    }\n\n    /* COMMENT_11 */\n    VAR_6 = VAR_3->data;\n    VAR_6->len = byteorder_htons(VAR_24);\n    memcpy(((uint8_t *)VAR_3->data) + VAR_9,\n           ((uint8_t *)VAR_0->data) + VAR_8,\n           VAR_0->size - VAR_8);\n    if (VAR_10 != NULL) {\n        VAR_10->super.current_size += (VAR_9 - VAR_8);\n#ifdef VAR_11\n        if (VAR_12 != NULL) {\n            int VAR_27 = -1;\n            DEBUG(\"6lo iphc: found route, trying to forward\\n\");\n            VAR_6->hl--;\n            VAR_12->super.current_size = VAR_10->super.current_size;\n            if ((VAR_3 = _encode_frag_for_forwarding(VAR_3, VAR_12))) {\n#ifdef VAR_25\n                /* COMMENT_24 */\n                              \n                if (_is_rfrag(VAR_0)) {\n                    VAR_12->in_netif = VAR_5;\n                    /* COMMENT_26 */\n                    VAR_12->offset_diff = ((int)gnrc_pkt_len(VAR_3->next)) -\n                                        VAR_0->size;\n                }\n#endif  /* COMMENT_27 */\n                if ((VAR_27 = _forward_frag(VAR_3, VAR_0->next, VAR_12, VAR_2)) == 0) {\n                    DEBUG(\"6lo iphc: successfully recompressed and forwarded \"\n                          \"1st fragment\\n\");\n                    /* COMMENT_28 */\n                    VAR_10->super.ints = NULL;\n                }\n            }\n            if ((VAR_3 == NULL) || (VAR_27 < 0)) {\n                /* COMMENT_29 */\n                                                                           \n                                                                                \n                                                                               \n                                                                              \n                   \n                gnrc_sixlowpan_frag_vrb_rm(VAR_12);\n            }\n            gnrc_pktbuf_release(VAR_0);\n            /* COMMENT_35 */\n            gnrc_sixlowpan_frag_rb_remove(VAR_10);\n            return;\n        }\n        DEBUG(\"6lo iphc: no route found, reassemble datagram normally\\n\");\n#endif  /* COMMENT_0 */\n    }\n    else {\n        VAR_0 = gnrc_pkt_delete(VAR_0, VAR_4);\n        VAR_3 = gnrc_pkt_append(VAR_3, VAR_4);\n        gnrc_sixlowpan_dispatch_recv(VAR_3, NULL, VAR_2);\n    }\n    gnrc_pktbuf_release(VAR_0);\n    return;\n}",
  "func_graph_path_before": "RIOT-OS/RIOT/d052e2ee166e55bbdfe4c455e65dbd7e3479ebe3/gnrc_sixlowpan_iphc.c/vul/before/0.json",
  "func": "void gnrc_sixlowpan_iphc_recv(gnrc_pktsnip_t *sixlo, void *rbuf_ptr,\n                              unsigned page)\n{\n    assert(sixlo != NULL);\n    gnrc_pktsnip_t *ipv6, *netif;\n    gnrc_netif_t *iface;\n    ipv6_hdr_t *ipv6_hdr;\n    uint8_t *iphc_hdr = sixlo->data;\n    size_t payload_offset;\n    size_t uncomp_hdr_len = sizeof(ipv6_hdr_t);\n    gnrc_sixlowpan_frag_rb_t *rbuf = rbuf_ptr;\n#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_VRB\n    gnrc_sixlowpan_frag_vrb_t *vrbe = NULL;\n#endif  /* MODULE_GNRC_SIXLOWPAN_FRAG_VRB */\n\n    if (rbuf != NULL) {\n        ipv6 = rbuf->pkt;\n        assert(ipv6 != NULL);\n        if ((ipv6->size < sizeof(ipv6_hdr_t)) &&\n            (gnrc_pktbuf_realloc_data(ipv6, sizeof(ipv6_hdr_t)) != 0)) {\n            DEBUG(\"6lo iphc: no space to decompress IPHC\\n\");\n            _recv_error_release(sixlo, ipv6, rbuf);\n            return;\n        }\n    }\n    else {\n        ipv6 = gnrc_pktbuf_add(NULL, NULL, sizeof(ipv6_hdr_t),\n                               GNRC_NETTYPE_IPV6);\n        if (ipv6 == NULL) {\n            gnrc_pktbuf_release(sixlo);\n            return;\n        }\n    }\n\n    assert(ipv6->size >= sizeof(ipv6_hdr_t));\n\n    netif = gnrc_pktsnip_search_type(sixlo, GNRC_NETTYPE_NETIF);\n    assert(netif != NULL);\n    iface = gnrc_netif_hdr_get_netif(netif->data);\n    payload_offset = _iphc_ipv6_decode(iphc_hdr, netif->data, iface,\n                                       ipv6->data);\n    if ((payload_offset == 0) || (payload_offset > sixlo->size)) {\n        /* unable to parse IPHC header or malicious packet */\n        DEBUG(\"6lo iphc: malformed IPHC header\\n\");\n        _recv_error_release(sixlo, ipv6, rbuf);\n        return;\n    }\n#ifdef MODULE_GNRC_SIXLOWPAN_IPHC_NHC\n    if (iphc_hdr[IPHC1_IDX] & SIXLOWPAN_IPHC1_NH) {\n        bool nhc_header = true;\n        ipv6_hdr = ipv6->data;\n        size_t prev_nh_offset = (&ipv6_hdr->nh) - ((uint8_t *)ipv6->data);\n\n        while (nhc_header) {\n            switch (iphc_hdr[payload_offset] & NHC_ID_MASK) {\n                case NHC_IPV6_EXT_ID:\n                case NHC_IPV6_EXT_ID_ALT:\n                    payload_offset = _iphc_nhc_ipv6_decode(sixlo,\n                                                           payload_offset,\n                                                           rbuf,\n                                                           &prev_nh_offset,\n                                                           ipv6,\n                                                           &uncomp_hdr_len);\n                    if ((payload_offset == 0) || (payload_offset > sixlo->size)) {\n                        /* unable to parse IPHC header or malicious packet */\n                        DEBUG(\"6lo iphc: malformed IPHC NHC IPv6 header\\n\");\n                        _recv_error_release(sixlo, ipv6, rbuf);\n                        return;\n                    }\n                    /* prev_nh_offset is set to 0 if next header is not\n                     * compressed (== NH flag in compression header not set) */\n                    nhc_header = (prev_nh_offset > 0);\n                    break;\n                case NHC_UDP_ID: {\n                    payload_offset = _iphc_nhc_udp_decode(sixlo,\n                                                          payload_offset,\n                                                          rbuf,\n                                                          prev_nh_offset,\n                                                          ipv6,\n                                                          &uncomp_hdr_len);\n                    if ((payload_offset == 0) || (payload_offset > sixlo->size)) {\n                        /* unable to parse IPHC header or malicious packet */\n                        DEBUG(\"6lo iphc: malformed IPHC NHC IPv6 header\\n\");\n                        _recv_error_release(sixlo, ipv6, rbuf);\n                        return;\n                    }\n                    /* no NHC after UDP header */\n                    nhc_header = false;\n                    break;\n                }\n                default:\n                    nhc_header = false;\n                    break;\n            }\n        }\n    }\n#endif\n    uint16_t payload_len;\n    if (rbuf != NULL) {\n        /* for a fragmented datagram we know the overall length already */\n        if (_is_rfrag(sixlo)) {\n            DEBUG(\"6lo iphc: calculating payload length for SFR\\n\");\n            DEBUG(\" - rbuf->super.datagram_size: %u\\n\",\n                  rbuf->super.datagram_size);\n            DEBUG(\" - payload_offset: %u\\n\", (unsigned)payload_offset);\n            DEBUG(\" - uncomp_hdr_len: %u\\n\", (unsigned)uncomp_hdr_len);\n            /* set IPv6 header payload length field to the length of whatever is\n             * left after removing the 6LoWPAN header and adding uncompressed\n             * headers */\n            payload_len = (rbuf->super.datagram_size - payload_offset) +\n                          (uncomp_hdr_len - sizeof(ipv6_hdr_t));\n            DEBUG(\"   => %u\\n\", payload_len);\n            /* adapt datagram size for uncompressed datagram */\n#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_SFR\n            /* guard required because SFR-specific field of vrbe is accessed */\n            rbuf->offset_diff += (uncomp_hdr_len - payload_offset);\n            rbuf->super.datagram_size += rbuf->offset_diff;\n#endif  /* MODULE_GNRC_SIXLOWPAN_FRAG_VRB */\n        }\n        else {\n            /* for a fragmented datagram we know the overall length already */\n            payload_len = (uint16_t)(rbuf->super.datagram_size - sizeof(ipv6_hdr_t));\n        }\n#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_VRB\n        DEBUG(\"6lo iphc: VRB present, trying to create entry for dst %s\\n\",\n              ipv6_addr_to_str(addr_str, &ipv6_hdr->dst, sizeof(addr_str)));\n        /* re-assign IPv6 header in case realloc changed the address */\n        ipv6_hdr = ipv6->data;\n        /* only create virtual reassembly buffer entry from IPv6 destination if\n         * the current first fragment is the only received fragment in the\n         * reassembly buffer so far and the hop-limit is larger than 1\n         */\n        if ((rbuf->super.current_size <= sixlo->size) && (ipv6_hdr->hl > 1U) &&\n            /* and there is enough slack for changing compression */\n            (rbuf->super.current_size <= iface->sixlo.max_frag_size) &&\n            (vrbe = gnrc_sixlowpan_frag_vrb_from_route(&rbuf->super, iface,\n                                                       ipv6))) {\n            /* add netif header to `ipv6` so its flags can be used when\n             * forwarding the fragment */\n            sixlo = gnrc_pkt_delete(sixlo, netif);\n            ipv6 = gnrc_pkt_append(ipv6, netif);\n            /* provide space to copy remaining payload */\n            if (gnrc_pktbuf_realloc_data(ipv6, uncomp_hdr_len + sixlo->size -\n                                         payload_offset) != 0) {\n                DEBUG(\"6lo iphc: no space left to copy payload\\n\");\n                gnrc_sixlowpan_frag_vrb_rm(vrbe);\n                _recv_error_release(sixlo, ipv6, rbuf);\n                return;\n            }\n        }\n        /* reallocate to copy complete payload */\n        else if (gnrc_pktbuf_realloc_data(ipv6, rbuf->super.datagram_size) != 0) {\n            DEBUG(\"6lo iphc: no space left to reassemble payload\\n\");\n            _recv_error_release(sixlo, ipv6, rbuf);\n            return;\n        }\n#endif  /* MODULE_GNRC_SIXLOWPAN_FRAG_VRB */\n    }\n    else {\n        /* set IPv6 header payload length field to the length of whatever is left\n         * after removing the 6LoWPAN header and adding uncompressed headers */\n        payload_len = (sixlo->size + uncomp_hdr_len -\n                       payload_offset - sizeof(ipv6_hdr_t));\n    }\n    if (rbuf == NULL) {\n        /* (rbuf == NULL) => forwarding is not affected by this */\n        if (gnrc_pktbuf_realloc_data(ipv6, uncomp_hdr_len + payload_len) != 0) {\n            DEBUG(\"6lo iphc: no space left to copy payload\\n\");\n            _recv_error_release(sixlo, ipv6, rbuf);\n            return;\n        }\n    }\n    else {\n        if (ipv6->size < (uncomp_hdr_len + (sixlo->size - payload_offset))) {\n            DEBUG(\"6lo iphc: not enough space to copy payload.\\n\");\n            DEBUG(\"6lo iphc: potentially malicious datagram size received.\\n\");\n            _recv_error_release(sixlo, ipv6, rbuf);\n            return;\n        }\n    }\n\n    /* re-assign IPv6 header in case realloc changed the address */\n    ipv6_hdr = ipv6->data;\n    ipv6_hdr->len = byteorder_htons(payload_len);\n    if (sixlo->size > payload_offset) {\n        memcpy(((uint8_t *)ipv6->data) + uncomp_hdr_len,\n               ((uint8_t *)sixlo->data) + payload_offset,\n               sixlo->size - payload_offset);\n    }\n    if (rbuf != NULL) {\n        rbuf->super.current_size += (uncomp_hdr_len - payload_offset);\n#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_VRB\n        if (vrbe != NULL) {\n            int res = -1;\n            DEBUG(\"6lo iphc: found route, trying to forward\\n\");\n            ipv6_hdr->hl--;\n            vrbe->super.current_size = rbuf->super.current_size;\n            if ((ipv6 = _encode_frag_for_forwarding(ipv6, vrbe))) {\n#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_SFR\n                /* guard required because SFR-specific field of vrbe is\n                 * accessed */\n                if (_is_rfrag(sixlo)) {\n                    vrbe->in_netif = iface;\n                    /* calculate offset difference due to compression */\n                    vrbe->offset_diff = ((int)gnrc_pkt_len(ipv6->next)) -\n                                        sixlo->size;\n                }\n#endif  /* MODULE_GNRC_SIXLOWPAN_FRAG_SFR */\n                if ((res = _forward_frag(ipv6, sixlo->next, vrbe, page)) == 0) {\n                    DEBUG(\"6lo iphc: successfully recompressed and forwarded \"\n                          \"1st fragment\\n\");\n                    /* empty list, as it should be in VRB now */\n                    rbuf->super.ints = NULL;\n                }\n            }\n            if ((ipv6 == NULL) || (res < 0)) {\n                /* TODO: There is a potential to fall-back to classic reassembly\n                 * when ipv6 != NULL. However, since `ipv6` was reversed in\n                 * `_encode_frag_for_forwarding`, that step needs to be reversed\n                 * or a version of the old ipv6 needs to be held in the buffer.\n                 * For now, just drop the packet all together in an error case\n                 */\n                gnrc_sixlowpan_frag_vrb_rm(vrbe);\n            }\n            gnrc_pktbuf_release(sixlo);\n            /* don't remove `rbuf->pkt` (aka ipv6) as it was forwarded */\n            gnrc_sixlowpan_frag_rb_remove(rbuf);\n            return;\n        }\n        DEBUG(\"6lo iphc: no route found, reassemble datagram normally\\n\");\n#endif  /* MODULE_GNRC_SIXLOWPAN_FRAG_VRB */\n    }\n    else {\n        sixlo = gnrc_pkt_delete(sixlo, netif);\n        ipv6 = gnrc_pkt_append(ipv6, netif);\n        gnrc_sixlowpan_dispatch_recv(ipv6, NULL, page);\n    }\n    gnrc_pktbuf_release(sixlo);\n    return;\n}",
  "abstract_func": "void gnrc_sixlowpan_iphc_recv(gnrc_pktsnip_t *VAR_0, void *VAR_1,\n                              unsigned VAR_2)\n{\n    assert(VAR_0 != NULL);\n    gnrc_pktsnip_t *VAR_3, *VAR_4;\n    gnrc_netif_t *VAR_5;\n    ipv6_hdr_t *VAR_6;\n    uint8_t *VAR_7 = VAR_0->data;\n    size_t VAR_8;\n    size_t VAR_9 = sizeof(ipv6_hdr_t);\n    gnrc_sixlowpan_frag_rb_t *VAR_10 = VAR_1;\n#ifdef VAR_11\n    gnrc_sixlowpan_frag_vrb_t *VAR_12 = NULL;\n#endif  /* COMMENT_0 */\n\n    if (VAR_10 != NULL) {\n        VAR_3 = VAR_10->pkt;\n        assert(VAR_3 != NULL);\n        if ((VAR_3->size < sizeof(ipv6_hdr_t)) &&\n            (gnrc_pktbuf_realloc_data(VAR_3, sizeof(ipv6_hdr_t)) != 0)) {\n            DEBUG(\"6lo iphc: no space to decompress IPHC\\n\");\n            _recv_error_release(VAR_0, VAR_3, VAR_10);\n            return;\n        }\n    }\n    else {\n        VAR_3 = gnrc_pktbuf_add(NULL, NULL, sizeof(ipv6_hdr_t),\n                               VAR_13);\n        if (VAR_3 == NULL) {\n            gnrc_pktbuf_release(VAR_0);\n            return;\n        }\n    }\n\n    assert(VAR_3->size >= sizeof(ipv6_hdr_t));\n\n    VAR_4 = gnrc_pktsnip_search_type(VAR_0, VAR_14);\n    assert(VAR_4 != NULL);\n    VAR_5 = gnrc_netif_hdr_get_netif(VAR_4->data);\n    VAR_8 = _iphc_ipv6_decode(VAR_7, VAR_4->data, VAR_5,\n                                       VAR_3->data);\n    if ((VAR_8 == 0) || (VAR_8 > VAR_0->size)) {\n        /* COMMENT_1 */\n        DEBUG(\"6lo iphc: malformed IPHC header\\n\");\n        _recv_error_release(VAR_0, VAR_3, VAR_10);\n        return;\n    }\n#ifdef VAR_15\n    if (VAR_7[VAR_16] & VAR_17) {\n        bool VAR_18 = true;\n        VAR_6 = VAR_3->data;\n        size_t VAR_19 = (&VAR_6->nh) - ((uint8_t *)VAR_3->data);\n\n        while (VAR_18) {\n            switch (VAR_7[VAR_8] & VAR_20) {\n                case VAR_21:\n                case VAR_22:\n                    VAR_8 = _iphc_nhc_ipv6_decode(VAR_0,\n                                                           VAR_8,\n                                                           VAR_10,\n                                                           &VAR_19,\n                                                           VAR_3,\n                                                           &VAR_9);\n                    if ((VAR_8 == 0) || (VAR_8 > VAR_0->size)) {\n                        /* COMMENT_1 */\n                        DEBUG(\"6lo iphc: malformed IPHC NHC IPv6 header\\n\");\n                        _recv_error_release(VAR_0, VAR_3, VAR_10);\n                        return;\n                    }\n                    /* COMMENT_2 */\n                                                                               \n                    VAR_18 = (VAR_19 > 0);\n                    break;\n                case VAR_23: {\n                    VAR_8 = _iphc_nhc_udp_decode(VAR_0,\n                                                          VAR_8,\n                                                          VAR_10,\n                                                          VAR_19,\n                                                          VAR_3,\n                                                          &VAR_9);\n                    if ((VAR_8 == 0) || (VAR_8 > VAR_0->size)) {\n                        /* COMMENT_1 */\n                        DEBUG(\"6lo iphc: malformed IPHC NHC IPv6 header\\n\");\n                        _recv_error_release(VAR_0, VAR_3, VAR_10);\n                        return;\n                    }\n                    /* COMMENT_4 */\n                    VAR_18 = false;\n                    break;\n                }\n                default:\n                    VAR_18 = false;\n                    break;\n            }\n        }\n    }\n#endif\n    uint16_t VAR_24;\n    if (VAR_10 != NULL) {\n        /* COMMENT_5 */\n        if (_is_rfrag(VAR_0)) {\n            DEBUG(\"6lo iphc: calculating payload length for SFR\\n\");\n            DEBUG(\" - rbuf->super.datagram_size: %u\\n\",\n                  VAR_10->super.datagram_size);\n            DEBUG(\" - payload_offset: %u\\n\", (unsigned)VAR_8);\n            DEBUG(\" - uncomp_hdr_len: %u\\n\", (unsigned)VAR_9);\n            /* COMMENT_6 */\n                                                                             \n                         \n            VAR_24 = (VAR_10->super.datagram_size - VAR_8) +\n                          (VAR_9 - sizeof(ipv6_hdr_t));\n            DEBUG(\"   => %u\\n\", VAR_24);\n            /* COMMENT_9 */\n#ifdef VAR_25\n            /* COMMENT_10 */\n            VAR_10->offset_diff += (VAR_9 - VAR_8);\n            VAR_10->super.datagram_size += VAR_10->offset_diff;\n#endif  /* COMMENT_0 */\n        }\n        else {\n            /* COMMENT_5 */\n            VAR_24 = (uint16_t)(VAR_10->super.datagram_size - sizeof(ipv6_hdr_t));\n        }\n#ifdef VAR_11\n        DEBUG(\"6lo iphc: VRB present, trying to create entry for dst %s\\n\",\n              ipv6_addr_to_str(VAR_26, &VAR_6->dst, sizeof(VAR_26)));\n        /* COMMENT_11 */\n        VAR_6 = VAR_3->data;\n        /* COMMENT_12 */\n                                                                          \n                                                                      \n           \n        if ((VAR_10->super.current_size <= VAR_0->size) && (VAR_6->hl > 1U) &&\n            /* COMMENT_16 */\n            (VAR_10->super.current_size <= VAR_5->sixlo.max_frag_size) &&\n            (VAR_12 = gnrc_sixlowpan_frag_vrb_from_route(&VAR_10->super, VAR_5,\n                                                       VAR_3))) {\n            /* COMMENT_17 */\n                                         \n            VAR_0 = gnrc_pkt_delete(VAR_0, VAR_4);\n            VAR_3 = gnrc_pkt_append(VAR_3, VAR_4);\n            /* COMMENT_19 */\n            if (gnrc_pktbuf_realloc_data(VAR_3, VAR_9 + VAR_0->size -\n                                         VAR_8) != 0) {\n                DEBUG(\"6lo iphc: no space left to copy payload\\n\");\n                gnrc_sixlowpan_frag_vrb_rm(VAR_12);\n                _recv_error_release(VAR_0, VAR_3, VAR_10);\n                return;\n            }\n        }\n        /* COMMENT_20 */\n        else if (gnrc_pktbuf_realloc_data(VAR_3, VAR_10->super.datagram_size) != 0) {\n            DEBUG(\"6lo iphc: no space left to reassemble payload\\n\");\n            _recv_error_release(VAR_0, VAR_3, VAR_10);\n            return;\n        }\n#endif  /* COMMENT_0 */\n    }\n    else {\n        /* COMMENT_21 */\n                                                                               \n        VAR_24 = (VAR_0->size + VAR_9 -\n                       VAR_8 - sizeof(ipv6_hdr_t));\n    }\n    if (VAR_10 == NULL) {\n        /* COMMENT_23 */\n        if (gnrc_pktbuf_realloc_data(VAR_3, VAR_9 + VAR_24) != 0) {\n            DEBUG(\"6lo iphc: no space left to copy payload\\n\");\n            _recv_error_release(VAR_0, VAR_3, VAR_10);\n            return;\n        }\n    }\n    else {\n        if (VAR_3->size < (VAR_9 + (VAR_0->size - VAR_8))) {\n            DEBUG(\"6lo iphc: not enough space to copy payload.\\n\");\n            DEBUG(\"6lo iphc: potentially malicious datagram size received.\\n\");\n            _recv_error_release(VAR_0, VAR_3, VAR_10);\n            return;\n        }\n    }\n\n    /* COMMENT_11 */\n    VAR_6 = VAR_3->data;\n    VAR_6->len = byteorder_htons(VAR_24);\n    if (VAR_0->size > VAR_8) {\n        memcpy(((uint8_t *)VAR_3->data) + VAR_9,\n               ((uint8_t *)VAR_0->data) + VAR_8,\n               VAR_0->size - VAR_8);\n    }\n    if (VAR_10 != NULL) {\n        VAR_10->super.current_size += (VAR_9 - VAR_8);\n#ifdef VAR_11\n        if (VAR_12 != NULL) {\n            int VAR_27 = -1;\n            DEBUG(\"6lo iphc: found route, trying to forward\\n\");\n            VAR_6->hl--;\n            VAR_12->super.current_size = VAR_10->super.current_size;\n            if ((VAR_3 = _encode_frag_for_forwarding(VAR_3, VAR_12))) {\n#ifdef VAR_25\n                /* COMMENT_24 */\n                              \n                if (_is_rfrag(VAR_0)) {\n                    VAR_12->in_netif = VAR_5;\n                    /* COMMENT_26 */\n                    VAR_12->offset_diff = ((int)gnrc_pkt_len(VAR_3->next)) -\n                                        VAR_0->size;\n                }\n#endif  /* COMMENT_27 */\n                if ((VAR_27 = _forward_frag(VAR_3, VAR_0->next, VAR_12, VAR_2)) == 0) {\n                    DEBUG(\"6lo iphc: successfully recompressed and forwarded \"\n                          \"1st fragment\\n\");\n                    /* COMMENT_28 */\n                    VAR_10->super.ints = NULL;\n                }\n            }\n            if ((VAR_3 == NULL) || (VAR_27 < 0)) {\n                /* COMMENT_29 */\n                                                                           \n                                                                                \n                                                                               \n                                                                              \n                   \n                gnrc_sixlowpan_frag_vrb_rm(VAR_12);\n            }\n            gnrc_pktbuf_release(VAR_0);\n            /* COMMENT_35 */\n            gnrc_sixlowpan_frag_rb_remove(VAR_10);\n            return;\n        }\n        DEBUG(\"6lo iphc: no route found, reassemble datagram normally\\n\");\n#endif  /* COMMENT_0 */\n    }\n    else {\n        VAR_0 = gnrc_pkt_delete(VAR_0, VAR_4);\n        VAR_3 = gnrc_pkt_append(VAR_3, VAR_4);\n        gnrc_sixlowpan_dispatch_recv(VAR_3, NULL, VAR_2);\n    }\n    gnrc_pktbuf_release(VAR_0);\n    return;\n}",
  "func_graph_path": "RIOT-OS/RIOT/d052e2ee166e55bbdfe4c455e65dbd7e3479ebe3/gnrc_sixlowpan_iphc.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -39,8 +39,9 @@\n     iface = gnrc_netif_hdr_get_netif(netif->data);\n     payload_offset = _iphc_ipv6_decode(iphc_hdr, netif->data, iface,\n                                        ipv6->data);\n-    if (payload_offset == 0) {\n-        /* unable to parse IPHC header */\n+    if ((payload_offset == 0) || (payload_offset > sixlo->size)) {\n+        /* unable to parse IPHC header or malicious packet */\n+        DEBUG(\"6lo iphc: malformed IPHC header\\n\");\n         _recv_error_release(sixlo, ipv6, rbuf);\n         return;\n     }\n@@ -60,7 +61,9 @@\n                                                            &prev_nh_offset,\n                                                            ipv6,\n                                                            &uncomp_hdr_len);\n-                    if (payload_offset == 0) {\n+                    if ((payload_offset == 0) || (payload_offset > sixlo->size)) {\n+                        /* unable to parse IPHC header or malicious packet */\n+                        DEBUG(\"6lo iphc: malformed IPHC NHC IPv6 header\\n\");\n                         _recv_error_release(sixlo, ipv6, rbuf);\n                         return;\n                     }\n@@ -75,7 +78,9 @@\n                                                           prev_nh_offset,\n                                                           ipv6,\n                                                           &uncomp_hdr_len);\n-                    if (payload_offset == 0) {\n+                    if ((payload_offset == 0) || (payload_offset > sixlo->size)) {\n+                        /* unable to parse IPHC header or malicious packet */\n+                        DEBUG(\"6lo iphc: malformed IPHC NHC IPv6 header\\n\");\n                         _recv_error_release(sixlo, ipv6, rbuf);\n                         return;\n                     }\n@@ -177,9 +182,11 @@\n     /* re-assign IPv6 header in case realloc changed the address */\n     ipv6_hdr = ipv6->data;\n     ipv6_hdr->len = byteorder_htons(payload_len);\n-    memcpy(((uint8_t *)ipv6->data) + uncomp_hdr_len,\n-           ((uint8_t *)sixlo->data) + payload_offset,\n-           sixlo->size - payload_offset);\n+    if (sixlo->size > payload_offset) {\n+        memcpy(((uint8_t *)ipv6->data) + uncomp_hdr_len,\n+               ((uint8_t *)sixlo->data) + payload_offset,\n+               sixlo->size - payload_offset);\n+    }\n     if (rbuf != NULL) {\n         rbuf->super.current_size += (uncomp_hdr_len - payload_offset);\n #ifdef MODULE_GNRC_SIXLOWPAN_FRAG_VRB",
  "diff_line_info": {
    "deleted_lines": [
      "    if (payload_offset == 0) {",
      "        /* unable to parse IPHC header */",
      "                    if (payload_offset == 0) {",
      "                    if (payload_offset == 0) {",
      "    memcpy(((uint8_t *)ipv6->data) + uncomp_hdr_len,",
      "           ((uint8_t *)sixlo->data) + payload_offset,",
      "           sixlo->size - payload_offset);"
    ],
    "added_lines": [
      "    if ((payload_offset == 0) || (payload_offset > sixlo->size)) {",
      "        /* unable to parse IPHC header or malicious packet */",
      "        DEBUG(\"6lo iphc: malformed IPHC header\\n\");",
      "                    if ((payload_offset == 0) || (payload_offset > sixlo->size)) {",
      "                        /* unable to parse IPHC header or malicious packet */",
      "                        DEBUG(\"6lo iphc: malformed IPHC NHC IPv6 header\\n\");",
      "                    if ((payload_offset == 0) || (payload_offset > sixlo->size)) {",
      "                        /* unable to parse IPHC header or malicious packet */",
      "                        DEBUG(\"6lo iphc: malformed IPHC NHC IPv6 header\\n\");",
      "    if (sixlo->size > payload_offset) {",
      "        memcpy(((uint8_t *)ipv6->data) + uncomp_hdr_len,",
      "               ((uint8_t *)sixlo->data) + payload_offset,",
      "               sixlo->size - payload_offset);",
      "    }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/RIOT-OS/RIOT/pull/18820",
  "description": {
    "pr_info": {
      "title": "gnrc_sixlowpan: Various hardening fixes [backport 2022.10]",
      "number": 18820
    },
    "comment": [
      "# Backport of #18817\n\n<!--\r\nThe RIOT community cares a lot about code quality.\r\nTherefore, before describing what your contribution is about, we would like\r\nyou to make sure that your modifications are compliant with the RIOT\r\ncoding conventions, see https://github.com/RIOT-OS/RIOT/blob/master/CODING_CONVENTIONS.md.\r\n-->\r\n\r\n### Contribution description\r\nTitle says everything\r\n<!--\r\nPut here the description of your contribution:\r\n- describe which part(s) of RIOT is (are) involved\r\n- if it's a bug fix, describe the bug that it solves and how it is solved\r\n- you can also give more information to reviewers about how to test your changes\r\n-->\r\n\r\n\r\n### Testing procedure\r\nFragmentation and header compression (e.g. as outlined in Release Specs 4 and 6) should still work.\r\n<!--\r\nDetails steps to test your contribution:\r\n- which test/example to compile for which board and is there a 'test' command\r\n- how to know that it was not working/available in master\r\n- the expected success test output\r\n-->\r\n\r\n\r\n### Issues/PRs references\r\n\r\n<!--\r\nExamples: Fixes #1234. See also #5678. Depends on PR #9876.\r\n\r\nPlease use keywords (e.g., fixes, resolve) with the links to the issues you\r\nresolved, this way they will be automatically closed when your pull request\r\nis merged. See https://help.github.com/articles/closing-issues-using-keywords/.\r\n-->\r\n",
      "### Murdock results\n\n:heavy_check_mark: [PASSED](https://ci-prod.riot-os.org/details/269929bb39cb48648e9091595a754f80)\n\ne82cab6a94fa7865162bb7ac3705d5a461b1207d tests/unittests: fix get_frame_hdr_len tests for hardened parsing\n\n|  Success  |  Failures  |  Total  |  Runtime  |\n| :-------: | :--------: | :-----: | :-------: |\n| 2006 | 0 | 2006 | 07m:46s |\n\n\n#### Artifacts\n- [Documentation preview](https://ci-prod.riot-os.org/results/269929bb39cb48648e9091595a754f80/doc-preview/)\n\n**This only reflects a subset of all builds from https://ci-prod.riot-os.org. Please refer to https://ci.riot-os.org for a complete build for now.**\n\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix\n\nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\nThe patch addresses an integer underflow vulnerability by adding checks to prevent processing malformed packets, thus mitigating potential security risks.\n\n**Final Output:**\n\nAnalysis: The patch modifies the function to check for invalid payload_offset values, preventing integer underflow and potential buffer overflow attacks. It adds error handling and validation, indicating a security fix.\n\nFinal Classification: Security Vulnerability Fix\n\nConfidence Score: 0.95"
}