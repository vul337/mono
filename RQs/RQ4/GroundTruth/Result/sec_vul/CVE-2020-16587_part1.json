{
  "cve_id": "CVE-2020-16587",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "AcademySoftwareFoundation/openexr",
  "commit_msg": "Fix #491, issue with part number range check reconstructing chunk offset table\n\nThe chunk offset was incorrectly testing for a part number that was the\nsame size (i.e. an invalid index)\n\nSigned-off-by: Kimball Thurston <kdt3rd@gmail.com>",
  "commit_hash": "8b5370c688a7362673c3a5256d93695617a4cd9a",
  "git_url": "https://github.com/AcademySoftwareFoundation/openexr/commit/8b5370c688a7362673c3a5256d93695617a4cd9a",
  "file_path": "OpenEXR/IlmImf/ImfMultiPartInputFile.cpp",
  "func_name": "MultiPartInputFile::Data::chunkOffsetReconstruction",
  "func_before": "void\nMultiPartInputFile::Data::chunkOffsetReconstruction(OPENEXR_IMF_INTERNAL_NAMESPACE::IStream& is, const vector<InputPartData*>& parts)\n{\n    //\n    // Reconstruct broken chunk offset tables. Stop once we received any exception.\n    //\n\n    Int64 position = is.tellg();\n\n    \n    //\n    // check we understand all the parts available: if not, we cannot continue\n    // exceptions thrown here should trickle back up to the constructor\n    //\n    \n    for (size_t i = 0; i < parts.size(); i++)\n    {\n        Header& header=parts[i]->header;\n        \n        //\n        // do we have a valid type entry?\n        // we only need them for true multipart files or single part non-image (deep) files\n        //\n        if(!header.hasType() && (isMultiPart(version) || isNonImage(version)))\n        {\n            throw IEX_NAMESPACE::ArgExc(\"cannot reconstruct incomplete file: part with missing type\");\n        }\n        if(!isSupportedType(header.type()))\n        {\n            throw IEX_NAMESPACE::ArgExc(\"cannot reconstruct incomplete file: part with unknown type \"+header.type());\n        }\n    }\n    \n    \n    // how many chunks should we read? We should stop when we reach the end\n    size_t total_chunks = 0;\n        \n    // for tiled-based parts, array of (pointers to) tileOffsets objects\n    // to create mapping between tile coordinates and chunk table indices\n    \n    \n    vector<TileOffsets*> tileOffsets(parts.size());\n    \n    // for scanline-based parts, number of scanlines in each chunk\n    vector<int> rowsizes(parts.size());\n        \n    for(size_t i = 0 ; i < parts.size() ; i++)\n    {\n        total_chunks += parts[i]->chunkOffsets.size();\n        if (isTiled(parts[i]->header.type()))\n        {\n            tileOffsets[i] = createTileOffsets(parts[i]->header);\n        }else{\n            tileOffsets[i] = NULL;\n            // (TODO) fix this so that it doesn't need to be revised for future compression types.\n            switch(parts[i]->header.compression())\n            {\n                case DWAB_COMPRESSION :\n                    rowsizes[i] = 256;\n                    break;\n                case PIZ_COMPRESSION :\n                case B44_COMPRESSION :\n                case B44A_COMPRESSION :\n                case DWAA_COMPRESSION :\n                    rowsizes[i]=32;\n                    break;\n                case ZIP_COMPRESSION :\n                case PXR24_COMPRESSION :\n                    rowsizes[i]=16;\n                    break;\n                case ZIPS_COMPRESSION :\n                case RLE_COMPRESSION :\n                case NO_COMPRESSION :\n                    rowsizes[i]=1;\n                    break;\n                default :\n                    throw(IEX_NAMESPACE::ArgExc(\"Unknown compression method in chunk offset reconstruction\"));\n            }\n        }\n     }\n        \n     try\n     {\n            \n        //\n        // \n        //\n        \n        Int64 chunk_start = position;\n        for (size_t i = 0; i < total_chunks ; i++)\n        {\n            //\n            // do we have a part number?\n            //\n            \n            int partNumber = 0;\n            if(isMultiPart(version))\n            {\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, partNumber);\n            }\n            \n            \n            \n            if(partNumber<0 || partNumber> static_cast<int>(parts.size()))\n            {\n                throw IEX_NAMESPACE::IoExc(\"part number out of range\");\n            }\n            \n            Header& header = parts[partNumber]->header;\n\n            // size of chunk NOT including multipart field\n            \n            Int64 size_of_chunk=0;\n\n            if (isTiled(header.type()))\n            {\n                //\n                // \n                //\n                int tilex,tiley,levelx,levely;\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, tilex);\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, tiley);\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, levelx);\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, levely);\n                \n                //std::cout << \"chunk_start for \" << tilex <<',' << tiley << ',' << levelx << ' ' << levely << ':' << chunk_start << std::endl;\n                    \n                \n                if(!tileOffsets[partNumber])\n                {\n                    // this shouldn't actually happen - we should have allocated a valid\n                    // tileOffsets for any part which isTiled\n                    throw IEX_NAMESPACE::IoExc(\"part not tiled\");\n                    \n                }\n                \n                if(!tileOffsets[partNumber]->isValidTile(tilex,tiley,levelx,levely))\n                {\n                    throw IEX_NAMESPACE::IoExc(\"invalid tile coordinates\");\n                }\n                \n                (*tileOffsets[partNumber])(tilex,tiley,levelx,levely)=chunk_start;\n                \n                // compute chunk sizes - different procedure for deep tiles and regular\n                // ones\n                if(header.type()==DEEPTILE)\n                {\n                    Int64 packed_offset;\n                    Int64 packed_sample;\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, packed_offset);\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, packed_sample);\n                    \n                    //add 40 byte header to packed sizes (tile coordinates, packed sizes, unpacked size)\n                    size_of_chunk=packed_offset+packed_sample+40;\n                }\n                else\n                {\n                    \n                    // regular image has 20 bytes of header, 4 byte chunksize;\n                    int chunksize;\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, chunksize);\n                    size_of_chunk=chunksize+20;\n                }\n            }\n            else\n            {\n                int y_coordinate;\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, y_coordinate);\n                \n                \n                if(y_coordinate < header.dataWindow().min.y || y_coordinate > header.dataWindow().max.y)\n                {\n                   throw IEX_NAMESPACE::IoExc(\"y out of range\");\n                }\n                y_coordinate -= header.dataWindow().min.y;\n                y_coordinate /= rowsizes[partNumber];   \n                \n                if(y_coordinate < 0 || y_coordinate >= int(parts[partNumber]->chunkOffsets.size()))\n                {\n                   throw IEX_NAMESPACE::IoExc(\"chunk index out of range\");\n                }\n                \n                parts[partNumber]->chunkOffsets[y_coordinate]=chunk_start;\n                \n                if(header.type()==DEEPSCANLINE)\n                {\n                    Int64 packed_offset;\n                    Int64 packed_sample;\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, packed_offset);\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, packed_sample);\n                    \n                    \n                    size_of_chunk=packed_offset+packed_sample+28;\n                }\n                else\n                {\n                    int chunksize;\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, chunksize);   \n                    size_of_chunk=chunksize+8;\n                }\n                \n            }\n            \n            if(isMultiPart(version))\n            {\n                chunk_start+=4;\n            }\n            \n            chunk_start+=size_of_chunk;\n            \n            is.seekg(chunk_start);\n            \n        }\n        \n    }\n    catch (...)\n    {\n        //\n        // Suppress all exceptions.  This functions is\n        // called only to reconstruct the line offset\n        // table for incomplete files, and exceptions\n        // are likely.\n        //\n    }\n\n    // copy tiled part data back to chunk offsets\n    \n    for(size_t partNumber=0;partNumber<parts.size();partNumber++)\n    {\n        if(tileOffsets[partNumber])\n        {\n            size_t pos=0;\n            vector<vector<vector <Int64> > > offsets = tileOffsets[partNumber]->getOffsets();\n            for (size_t l = 0; l < offsets.size(); l++)\n                for (size_t y = 0; y < offsets[l].size(); y++)\n                    for (size_t x = 0; x < offsets[l][y].size(); x++)\n                    {\n                        parts[ partNumber ]->chunkOffsets[pos] = offsets[l][y][x];\n                        pos++;\n                    }\n           delete tileOffsets[partNumber];\n        }\n    }\n\n    is.clear();\n    is.seekg (position);\n}",
  "abstract_func_before": "void\nMultiPartInputFile::Data::chunkOffsetReconstruction(OPENEXR_IMF_INTERNAL_NAMESPACE::IStream& VAR_0, const vector<InputPartData*>& VAR_1)\n{\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n    /* COMMENT_0 */\n\n    Int64 VAR_2 = VAR_0.tellg();\n\n    \n    /* COMMENT_0 */\n    /* COMMENT_2 */\n    /* COMMENT_3 */\n    /* COMMENT_0 */\n    \n    for (size_t VAR_3 = 0; VAR_3 < VAR_1.size(); VAR_3++)\n    {\n        Header& VAR_4=VAR_1[VAR_3]->header;\n        \n        /* COMMENT_0 */\n        /* COMMENT_4 */\n        /* COMMENT_5 */\n        /* COMMENT_0 */\n        if(!VAR_4.hasType() && (isMultiPart(VAR_5) || isNonImage(VAR_5)))\n        {\n            throw IEX_NAMESPACE::ArgExc(\"cannot reconstruct incomplete file: part with missing type\");\n        }\n        if(!isSupportedType(VAR_4.type()))\n        {\n            throw IEX_NAMESPACE::ArgExc(\"cannot reconstruct incomplete file: part with unknown type \"+VAR_4.type());\n        }\n    }\n    \n    \n    /* COMMENT_6 */\n    size_t VAR_6 = 0;\n        \n    /* COMMENT_7 */\n    /* COMMENT_8 */\n    \n    \n    vector<TileOffsets*> VAR_7(VAR_1.size());\n    \n    /* COMMENT_9 */\n    vector<int> VAR_8(VAR_1.size());\n        \n    for(size_t VAR_3 = 0 ; VAR_3 < VAR_1.size() ; VAR_3++)\n    {\n        VAR_6 += VAR_1[VAR_3]->chunkOffsets.size();\n        if (isTiled(VAR_1[VAR_3]->header.type()))\n        {\n            VAR_7[VAR_3] = createTileOffsets(VAR_1[VAR_3]->header);\n        }else{\n            VAR_7[VAR_3] = NULL;\n            /* COMMENT_10 */\n            switch(VAR_1[VAR_3]->header.compression())\n            {\n                case VAR_9 :\n                    VAR_8[VAR_3] = 256;\n                    break;\n                case VAR_10 :\n                case VAR_11 :\n                case VAR_12 :\n                case VAR_13 :\n                    VAR_8[VAR_3]=32;\n                    break;\n                case VAR_14 :\n                case VAR_15 :\n                    VAR_8[VAR_3]=16;\n                    break;\n                case VAR_16 :\n                case VAR_17 :\n                case VAR_18 :\n                    VAR_8[VAR_3]=1;\n                    break;\n                default :\n                    throw(IEX_NAMESPACE::ArgExc(\"Unknown compression method in chunk offset reconstruction\"));\n            }\n        }\n     }\n        \n     try\n     {\n            \n        /* COMMENT_0 */\n        /* COMMENT_11 */\n        /* COMMENT_0 */\n        \n        Int64 VAR_19 = VAR_2;\n        for (size_t VAR_3 = 0; VAR_3 < VAR_6 ; VAR_3++)\n        {\n            /* COMMENT_0 */\n            /* COMMENT_12 */\n            /* COMMENT_0 */\n            \n            int VAR_20 = 0;\n            if(isMultiPart(VAR_5))\n            {\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::VAR_21 <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (VAR_0, VAR_20);\n            }\n            \n            \n            \n            if(VAR_20<0 || VAR_20> VAR_22<int>(VAR_1.size()))\n            {\n                throw IEX_NAMESPACE::IoExc(\"part number out of range\");\n            }\n            \n            Header& VAR_4 = VAR_1[VAR_20]->header;\n\n            /* COMMENT_13 */\n            \n            Int64 VAR_23=0;\n\n            if (isTiled(VAR_4.type()))\n            {\n                /* COMMENT_0 */\n                /* COMMENT_11 */\n                /* COMMENT_0 */\n                int VAR_24,VAR_25,VAR_26,VAR_27;\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::VAR_21 <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (VAR_0, VAR_24);\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::VAR_21 <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (VAR_0, VAR_25);\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::VAR_21 <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (VAR_0, VAR_26);\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::VAR_21 <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (VAR_0, VAR_27);\n                \n                /* COMMENT_14 */\n                    \n                \n                if(!VAR_7[VAR_20])\n                {\n                    /* COMMENT_15 */\n                    /* COMMENT_16 */\n                    throw IEX_NAMESPACE::IoExc(\"part not tiled\");\n                    \n                }\n                \n                if(!VAR_7[VAR_20]->isValidTile(VAR_24,VAR_25,VAR_26,VAR_27))\n                {\n                    throw IEX_NAMESPACE::IoExc(\"invalid tile coordinates\");\n                }\n                \n                (*VAR_7[VAR_20])(VAR_24,VAR_25,VAR_26,VAR_27)=VAR_19;\n                \n                /* COMMENT_17 */\n                /* COMMENT_18 */\n                if(VAR_4.type()==VAR_28)\n                {\n                    Int64 VAR_29;\n                    Int64 VAR_30;\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::VAR_21 <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (VAR_0, VAR_29);\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::VAR_21 <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (VAR_0, VAR_30);\n                    \n                    /* COMMENT_19 */\n                    VAR_23=VAR_29+VAR_30+40;\n                }\n                else\n                {\n                    \n                    /* COMMENT_20 */\n                    int VAR_31;\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::VAR_21 <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (VAR_0, VAR_31);\n                    VAR_23=VAR_31+20;\n                }\n            }\n            else\n            {\n                int VAR_32;\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::VAR_21 <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (VAR_0, VAR_32);\n                \n                \n                if(VAR_32 < VAR_4.dataWindow().min.y || VAR_32 > VAR_4.dataWindow().max.y)\n                {\n                   throw IEX_NAMESPACE::IoExc(\"y out of range\");\n                }\n                VAR_32 -= VAR_4.dataWindow().min.y;\n                VAR_32 /= VAR_8[VAR_20];   \n                \n                if(VAR_32 < 0 || VAR_32 >= int(VAR_1[VAR_20]->chunkOffsets.size()))\n                {\n                   throw IEX_NAMESPACE::IoExc(\"chunk index out of range\");\n                }\n                \n                VAR_1[VAR_20]->chunkOffsets[VAR_32]=VAR_19;\n                \n                if(VAR_4.type()==VAR_33)\n                {\n                    Int64 VAR_29;\n                    Int64 VAR_30;\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::VAR_21 <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (VAR_0, VAR_29);\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::VAR_21 <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (VAR_0, VAR_30);\n                    \n                    \n                    VAR_23=VAR_29+VAR_30+28;\n                }\n                else\n                {\n                    int VAR_31;\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::VAR_21 <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (VAR_0, VAR_31);   \n                    VAR_23=VAR_31+8;\n                }\n                \n            }\n            \n            if(isMultiPart(VAR_5))\n            {\n                VAR_19+=4;\n            }\n            \n            VAR_19+=VAR_23;\n            \n            VAR_0.seekg(VAR_19);\n            \n        }\n        \n    }\n    catch (...)\n    {\n        /* COMMENT_0 */\n        /* COMMENT_21 */\n        /* COMMENT_22 */\n        /* COMMENT_23 */\n        /* COMMENT_24 */\n        /* COMMENT_0 */\n    }\n\n    /* COMMENT_25 */\n    \n    for(size_t VAR_20=0;VAR_20<VAR_1.size();VAR_20++)\n    {\n        if(VAR_7[VAR_20])\n        {\n            size_t VAR_34=0;\n            vector<vector<vector <Int64> > > VAR_35 = VAR_7[VAR_20]->getOffsets();\n            for (size_t VAR_36 = 0; VAR_36 < VAR_35.size(); VAR_36++)\n                for (size_t VAR_37 = 0; VAR_37 < VAR_35[VAR_36].size(); VAR_37++)\n                    for (size_t VAR_38 = 0; VAR_38 < VAR_35[VAR_36][VAR_37].size(); VAR_38++)\n                    {\n                        VAR_1[ VAR_20 ]->chunkOffsets[VAR_34] = VAR_35[VAR_36][VAR_37][VAR_38];\n                        VAR_34++;\n                    }\n           delete VAR_7[VAR_20];\n        }\n    }\n\n    VAR_0.clear();\n    VAR_0.seekg (VAR_2);\n}",
  "func_graph_path_before": null,
  "func": "void\nMultiPartInputFile::Data::chunkOffsetReconstruction(OPENEXR_IMF_INTERNAL_NAMESPACE::IStream& is, const vector<InputPartData*>& parts)\n{\n    //\n    // Reconstruct broken chunk offset tables. Stop once we received any exception.\n    //\n\n    Int64 position = is.tellg();\n\n    \n    //\n    // check we understand all the parts available: if not, we cannot continue\n    // exceptions thrown here should trickle back up to the constructor\n    //\n    \n    for (size_t i = 0; i < parts.size(); i++)\n    {\n        Header& header=parts[i]->header;\n        \n        //\n        // do we have a valid type entry?\n        // we only need them for true multipart files or single part non-image (deep) files\n        //\n        if(!header.hasType() && (isMultiPart(version) || isNonImage(version)))\n        {\n            throw IEX_NAMESPACE::ArgExc(\"cannot reconstruct incomplete file: part with missing type\");\n        }\n        if(!isSupportedType(header.type()))\n        {\n            throw IEX_NAMESPACE::ArgExc(\"cannot reconstruct incomplete file: part with unknown type \"+header.type());\n        }\n    }\n    \n    \n    // how many chunks should we read? We should stop when we reach the end\n    size_t total_chunks = 0;\n        \n    // for tiled-based parts, array of (pointers to) tileOffsets objects\n    // to create mapping between tile coordinates and chunk table indices\n    \n    \n    vector<TileOffsets*> tileOffsets(parts.size());\n    \n    // for scanline-based parts, number of scanlines in each chunk\n    vector<int> rowsizes(parts.size());\n        \n    for(size_t i = 0 ; i < parts.size() ; i++)\n    {\n        total_chunks += parts[i]->chunkOffsets.size();\n        if (isTiled(parts[i]->header.type()))\n        {\n            tileOffsets[i] = createTileOffsets(parts[i]->header);\n        }else{\n            tileOffsets[i] = NULL;\n            // (TODO) fix this so that it doesn't need to be revised for future compression types.\n            switch(parts[i]->header.compression())\n            {\n                case DWAB_COMPRESSION :\n                    rowsizes[i] = 256;\n                    break;\n                case PIZ_COMPRESSION :\n                case B44_COMPRESSION :\n                case B44A_COMPRESSION :\n                case DWAA_COMPRESSION :\n                    rowsizes[i]=32;\n                    break;\n                case ZIP_COMPRESSION :\n                case PXR24_COMPRESSION :\n                    rowsizes[i]=16;\n                    break;\n                case ZIPS_COMPRESSION :\n                case RLE_COMPRESSION :\n                case NO_COMPRESSION :\n                    rowsizes[i]=1;\n                    break;\n                default :\n                    throw(IEX_NAMESPACE::ArgExc(\"Unknown compression method in chunk offset reconstruction\"));\n            }\n        }\n     }\n        \n     try\n     {\n            \n        //\n        // \n        //\n        \n        Int64 chunk_start = position;\n        for (size_t i = 0; i < total_chunks ; i++)\n        {\n            //\n            // do we have a part number?\n            //\n            \n            int partNumber = 0;\n            if(isMultiPart(version))\n            {\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, partNumber);\n            }\n            \n            \n            \n            if(partNumber<0 || partNumber>= static_cast<int>(parts.size()))\n            {\n                throw IEX_NAMESPACE::IoExc(\"part number out of range\");\n            }\n            \n            Header& header = parts[partNumber]->header;\n\n            // size of chunk NOT including multipart field\n            \n            Int64 size_of_chunk=0;\n\n            if (isTiled(header.type()))\n            {\n                //\n                // \n                //\n                int tilex,tiley,levelx,levely;\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, tilex);\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, tiley);\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, levelx);\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, levely);\n                \n                //std::cout << \"chunk_start for \" << tilex <<',' << tiley << ',' << levelx << ' ' << levely << ':' << chunk_start << std::endl;\n                    \n                \n                if(!tileOffsets[partNumber])\n                {\n                    // this shouldn't actually happen - we should have allocated a valid\n                    // tileOffsets for any part which isTiled\n                    throw IEX_NAMESPACE::IoExc(\"part not tiled\");\n                    \n                }\n                \n                if(!tileOffsets[partNumber]->isValidTile(tilex,tiley,levelx,levely))\n                {\n                    throw IEX_NAMESPACE::IoExc(\"invalid tile coordinates\");\n                }\n                \n                (*tileOffsets[partNumber])(tilex,tiley,levelx,levely)=chunk_start;\n                \n                // compute chunk sizes - different procedure for deep tiles and regular\n                // ones\n                if(header.type()==DEEPTILE)\n                {\n                    Int64 packed_offset;\n                    Int64 packed_sample;\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, packed_offset);\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, packed_sample);\n                    \n                    //add 40 byte header to packed sizes (tile coordinates, packed sizes, unpacked size)\n                    size_of_chunk=packed_offset+packed_sample+40;\n                }\n                else\n                {\n                    \n                    // regular image has 20 bytes of header, 4 byte chunksize;\n                    int chunksize;\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, chunksize);\n                    size_of_chunk=chunksize+20;\n                }\n            }\n            else\n            {\n                int y_coordinate;\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, y_coordinate);\n                \n                \n                if(y_coordinate < header.dataWindow().min.y || y_coordinate > header.dataWindow().max.y)\n                {\n                   throw IEX_NAMESPACE::IoExc(\"y out of range\");\n                }\n                y_coordinate -= header.dataWindow().min.y;\n                y_coordinate /= rowsizes[partNumber];   \n                \n                if(y_coordinate < 0 || y_coordinate >= int(parts[partNumber]->chunkOffsets.size()))\n                {\n                   throw IEX_NAMESPACE::IoExc(\"chunk index out of range\");\n                }\n                \n                parts[partNumber]->chunkOffsets[y_coordinate]=chunk_start;\n                \n                if(header.type()==DEEPSCANLINE)\n                {\n                    Int64 packed_offset;\n                    Int64 packed_sample;\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, packed_offset);\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, packed_sample);\n                    \n                    \n                    size_of_chunk=packed_offset+packed_sample+28;\n                }\n                else\n                {\n                    int chunksize;\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, chunksize);   \n                    size_of_chunk=chunksize+8;\n                }\n                \n            }\n            \n            if(isMultiPart(version))\n            {\n                chunk_start+=4;\n            }\n            \n            chunk_start+=size_of_chunk;\n            \n            is.seekg(chunk_start);\n            \n        }\n        \n    }\n    catch (...)\n    {\n        //\n        // Suppress all exceptions.  This functions is\n        // called only to reconstruct the line offset\n        // table for incomplete files, and exceptions\n        // are likely.\n        //\n    }\n\n    // copy tiled part data back to chunk offsets\n    \n    for(size_t partNumber=0;partNumber<parts.size();partNumber++)\n    {\n        if(tileOffsets[partNumber])\n        {\n            size_t pos=0;\n            vector<vector<vector <Int64> > > offsets = tileOffsets[partNumber]->getOffsets();\n            for (size_t l = 0; l < offsets.size(); l++)\n                for (size_t y = 0; y < offsets[l].size(); y++)\n                    for (size_t x = 0; x < offsets[l][y].size(); x++)\n                    {\n                        parts[ partNumber ]->chunkOffsets[pos] = offsets[l][y][x];\n                        pos++;\n                    }\n           delete tileOffsets[partNumber];\n        }\n    }\n\n    is.clear();\n    is.seekg (position);\n}",
  "abstract_func": "void\nMultiPartInputFile::Data::chunkOffsetReconstruction(OPENEXR_IMF_INTERNAL_NAMESPACE::IStream& VAR_0, const vector<InputPartData*>& VAR_1)\n{\n    /* COMMENT_0 */\n    /* COMMENT_1 */\n    /* COMMENT_0 */\n\n    Int64 VAR_2 = VAR_0.tellg();\n\n    \n    /* COMMENT_0 */\n    /* COMMENT_2 */\n    /* COMMENT_3 */\n    /* COMMENT_0 */\n    \n    for (size_t VAR_3 = 0; VAR_3 < VAR_1.size(); VAR_3++)\n    {\n        Header& VAR_4=VAR_1[VAR_3]->header;\n        \n        /* COMMENT_0 */\n        /* COMMENT_4 */\n        /* COMMENT_5 */\n        /* COMMENT_0 */\n        if(!VAR_4.hasType() && (isMultiPart(VAR_5) || isNonImage(VAR_5)))\n        {\n            throw IEX_NAMESPACE::ArgExc(\"cannot reconstruct incomplete file: part with missing type\");\n        }\n        if(!isSupportedType(VAR_4.type()))\n        {\n            throw IEX_NAMESPACE::ArgExc(\"cannot reconstruct incomplete file: part with unknown type \"+VAR_4.type());\n        }\n    }\n    \n    \n    /* COMMENT_6 */\n    size_t VAR_6 = 0;\n        \n    /* COMMENT_7 */\n    /* COMMENT_8 */\n    \n    \n    vector<TileOffsets*> VAR_7(VAR_1.size());\n    \n    /* COMMENT_9 */\n    vector<int> VAR_8(VAR_1.size());\n        \n    for(size_t VAR_3 = 0 ; VAR_3 < VAR_1.size() ; VAR_3++)\n    {\n        VAR_6 += VAR_1[VAR_3]->chunkOffsets.size();\n        if (isTiled(VAR_1[VAR_3]->header.type()))\n        {\n            VAR_7[VAR_3] = createTileOffsets(VAR_1[VAR_3]->header);\n        }else{\n            VAR_7[VAR_3] = NULL;\n            /* COMMENT_10 */\n            switch(VAR_1[VAR_3]->header.compression())\n            {\n                case VAR_9 :\n                    VAR_8[VAR_3] = 256;\n                    break;\n                case VAR_10 :\n                case VAR_11 :\n                case VAR_12 :\n                case VAR_13 :\n                    VAR_8[VAR_3]=32;\n                    break;\n                case VAR_14 :\n                case VAR_15 :\n                    VAR_8[VAR_3]=16;\n                    break;\n                case VAR_16 :\n                case VAR_17 :\n                case VAR_18 :\n                    VAR_8[VAR_3]=1;\n                    break;\n                default :\n                    throw(IEX_NAMESPACE::ArgExc(\"Unknown compression method in chunk offset reconstruction\"));\n            }\n        }\n     }\n        \n     try\n     {\n            \n        /* COMMENT_0 */\n        /* COMMENT_11 */\n        /* COMMENT_0 */\n        \n        Int64 VAR_19 = VAR_2;\n        for (size_t VAR_3 = 0; VAR_3 < VAR_6 ; VAR_3++)\n        {\n            /* COMMENT_0 */\n            /* COMMENT_12 */\n            /* COMMENT_0 */\n            \n            int VAR_20 = 0;\n            if(isMultiPart(VAR_5))\n            {\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::VAR_21 <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (VAR_0, VAR_20);\n            }\n            \n            \n            \n            if(VAR_20<0 || VAR_20>= VAR_22<int>(VAR_1.size()))\n            {\n                throw IEX_NAMESPACE::IoExc(\"part number out of range\");\n            }\n            \n            Header& VAR_4 = VAR_1[VAR_20]->header;\n\n            /* COMMENT_13 */\n            \n            Int64 VAR_23=0;\n\n            if (isTiled(VAR_4.type()))\n            {\n                /* COMMENT_0 */\n                /* COMMENT_11 */\n                /* COMMENT_0 */\n                int VAR_24,VAR_25,VAR_26,VAR_27;\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::VAR_21 <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (VAR_0, VAR_24);\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::VAR_21 <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (VAR_0, VAR_25);\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::VAR_21 <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (VAR_0, VAR_26);\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::VAR_21 <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (VAR_0, VAR_27);\n                \n                /* COMMENT_14 */\n                    \n                \n                if(!VAR_7[VAR_20])\n                {\n                    /* COMMENT_15 */\n                    /* COMMENT_16 */\n                    throw IEX_NAMESPACE::IoExc(\"part not tiled\");\n                    \n                }\n                \n                if(!VAR_7[VAR_20]->isValidTile(VAR_24,VAR_25,VAR_26,VAR_27))\n                {\n                    throw IEX_NAMESPACE::IoExc(\"invalid tile coordinates\");\n                }\n                \n                (*VAR_7[VAR_20])(VAR_24,VAR_25,VAR_26,VAR_27)=VAR_19;\n                \n                /* COMMENT_17 */\n                /* COMMENT_18 */\n                if(VAR_4.type()==VAR_28)\n                {\n                    Int64 VAR_29;\n                    Int64 VAR_30;\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::VAR_21 <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (VAR_0, VAR_29);\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::VAR_21 <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (VAR_0, VAR_30);\n                    \n                    /* COMMENT_19 */\n                    VAR_23=VAR_29+VAR_30+40;\n                }\n                else\n                {\n                    \n                    /* COMMENT_20 */\n                    int VAR_31;\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::VAR_21 <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (VAR_0, VAR_31);\n                    VAR_23=VAR_31+20;\n                }\n            }\n            else\n            {\n                int VAR_32;\n                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::VAR_21 <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (VAR_0, VAR_32);\n                \n                \n                if(VAR_32 < VAR_4.dataWindow().min.y || VAR_32 > VAR_4.dataWindow().max.y)\n                {\n                   throw IEX_NAMESPACE::IoExc(\"y out of range\");\n                }\n                VAR_32 -= VAR_4.dataWindow().min.y;\n                VAR_32 /= VAR_8[VAR_20];   \n                \n                if(VAR_32 < 0 || VAR_32 >= int(VAR_1[VAR_20]->chunkOffsets.size()))\n                {\n                   throw IEX_NAMESPACE::IoExc(\"chunk index out of range\");\n                }\n                \n                VAR_1[VAR_20]->chunkOffsets[VAR_32]=VAR_19;\n                \n                if(VAR_4.type()==VAR_33)\n                {\n                    Int64 VAR_29;\n                    Int64 VAR_30;\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::VAR_21 <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (VAR_0, VAR_29);\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::VAR_21 <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (VAR_0, VAR_30);\n                    \n                    \n                    VAR_23=VAR_29+VAR_30+28;\n                }\n                else\n                {\n                    int VAR_31;\n                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::VAR_21 <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (VAR_0, VAR_31);   \n                    VAR_23=VAR_31+8;\n                }\n                \n            }\n            \n            if(isMultiPart(VAR_5))\n            {\n                VAR_19+=4;\n            }\n            \n            VAR_19+=VAR_23;\n            \n            VAR_0.seekg(VAR_19);\n            \n        }\n        \n    }\n    catch (...)\n    {\n        /* COMMENT_0 */\n        /* COMMENT_21 */\n        /* COMMENT_22 */\n        /* COMMENT_23 */\n        /* COMMENT_24 */\n        /* COMMENT_0 */\n    }\n\n    /* COMMENT_25 */\n    \n    for(size_t VAR_20=0;VAR_20<VAR_1.size();VAR_20++)\n    {\n        if(VAR_7[VAR_20])\n        {\n            size_t VAR_34=0;\n            vector<vector<vector <Int64> > > VAR_35 = VAR_7[VAR_20]->getOffsets();\n            for (size_t VAR_36 = 0; VAR_36 < VAR_35.size(); VAR_36++)\n                for (size_t VAR_37 = 0; VAR_37 < VAR_35[VAR_36].size(); VAR_37++)\n                    for (size_t VAR_38 = 0; VAR_38 < VAR_35[VAR_36][VAR_37].size(); VAR_38++)\n                    {\n                        VAR_1[ VAR_20 ]->chunkOffsets[VAR_34] = VAR_35[VAR_36][VAR_37][VAR_38];\n                        VAR_34++;\n                    }\n           delete VAR_7[VAR_20];\n        }\n    }\n\n    VAR_0.clear();\n    VAR_0.seekg (VAR_2);\n}",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -101,7 +101,7 @@\n             \n             \n             \n-            if(partNumber<0 || partNumber> static_cast<int>(parts.size()))\n+            if(partNumber<0 || partNumber>= static_cast<int>(parts.size()))\n             {\n                 throw IEX_NAMESPACE::IoExc(\"part number out of range\");\n             }",
  "diff_line_info": {
    "deleted_lines": [
      "            if(partNumber<0 || partNumber> static_cast<int>(parts.size()))"
    ],
    "added_lines": [
      "            if(partNumber<0 || partNumber>= static_cast<int>(parts.size()))"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/AcademySoftwareFoundation/openexr/pull/498",
  "description": {
    "pr_info": {
      "title": "Fix #491, issue with part number range check reconstructing chunk off…",
      "number": 498
    },
    "comment": [
      "…set table\r\n\r\nThe chunk offset was incorrectly testing for a part number that was the\r\nsame size (i.e. an invalid index)\r\n\r\nSigned-off-by: Kimball Thurston <kdt3rd@gmail.com>"
    ]
  },
  "Bug Filter": "** Security Vulnerability Fix  \n**Confidence Score:** 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\nThe patch corrects a bounds-checking issue in the part number validation, preventing potential buffer overflow. This addresses a security vulnerability by ensuring invalid indices are rejected.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 0.95"
}