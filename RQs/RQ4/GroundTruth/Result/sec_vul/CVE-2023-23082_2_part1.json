{
  "cve_id": "CVE-2023-23082",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "CVSS:3.1/AV:P/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "xbmc",
  "commit_msg": "ExifParse: Don't run outside exif information\n\nWhen parsing exif information the number of entries could be tainted. Make\nsure to not run behind the exif data by properly checking out of bounds.\n\nUpstream? fix: https://android.googlesource.com/platform/external/jhead/+/34a2564d3268a5ca1472c5076675782fbaf724d6",
  "commit_hash": "00fec1dbdd1df827872c7b55ad93059636dfc076",
  "git_url": "https://github.com/xbmc/xbmc/commit/00fec1dbdd1df827872c7b55ad93059636dfc076",
  "file_path": "xbmc/pictures/ExifParse.cpp",
  "func_name": "CExifParse::ProcessGpsInfo",
  "func_before": "void CExifParse::ProcessGpsInfo(\n                    const unsigned char* const DirStart,\n                    int ByteCountUnused,\n                    const unsigned char* const OffsetBase,\n                    unsigned ExifLength)\n{\n  int NumDirEntries = Get16(DirStart, m_MotorolaOrder);\n\n  for (int de=0;de<NumDirEntries;de++)\n  {\n    const unsigned char* DirEntry = DIR_ENTRY_ADDR(DirStart, de);\n\n    unsigned Tag        = Get16(DirEntry, m_MotorolaOrder);\n    unsigned Format     = Get16(DirEntry+2, m_MotorolaOrder);\n    unsigned Components = (unsigned)Get32(DirEntry+4, m_MotorolaOrder);\n    if (Format == 0 || Format > NUM_FORMATS)\n    {\n      ErrNonfatal(\"Illegal number format %d for tag %04x\", Format, Tag);\n      continue;\n    }\n\n    unsigned ComponentSize = BytesPerFormat[Format - 1];\n    unsigned ByteCount = Components * ComponentSize;\n\n    const unsigned char* ValuePtr;\n\n    if (ByteCount > 4)\n    {\n      unsigned OffsetVal = (unsigned)Get32(DirEntry+8, m_MotorolaOrder);\n      // If its bigger than 4 bytes, the dir entry contains an offset.\n      if (OffsetVal+ByteCount > ExifLength)\n      {\n        // Bogus pointer offset and / or bytecount value\n        ErrNonfatal(\"Illegal value pointer for tag %04x\", Tag,0);\n        continue;\n      }\n      ValuePtr = OffsetBase+OffsetVal;\n    }\n    else\n    {\n      // 4 bytes or less and value is in the dir entry itself\n      ValuePtr = DirEntry+8;\n    }\n\n    switch(Tag)\n    {\n      case TAG_GPS_LAT_REF:\n        m_ExifInfo->GpsLat[0] = ValuePtr[0];\n        m_ExifInfo->GpsLat[1] = 0;\n      break;\n\n      case TAG_GPS_LONG_REF:\n        m_ExifInfo->GpsLong[0] = ValuePtr[0];\n        m_ExifInfo->GpsLong[1] = 0;\n      break;\n\n      case TAG_GPS_LAT:\n        GetLatLong(Format, ValuePtr, ComponentSize, m_ExifInfo->GpsLat);\n      break;\n      case TAG_GPS_LONG:\n        GetLatLong(Format, ValuePtr, ComponentSize, m_ExifInfo->GpsLong);\n      break;\n\n      case TAG_GPS_ALT_REF:\n        if (ValuePtr[0] != 0)\n          m_ExifInfo->GpsAlt[0] = '-';\n        m_ExifInfo->GpsAlt[1] = 0;\n      break;\n\n      case TAG_GPS_ALT:\n        {\n          char temp[18];\n          sprintf(temp, \"%.2fm\", static_cast<double>(ConvertAnyFormat(ValuePtr, Format)));\n          strcat(m_ExifInfo->GpsAlt, temp);\n        }\n      break;\n    }\n  }\n}",
  "abstract_func_before": "void CExifParse::ProcessGpsInfo(\n                    const unsigned char* const VAR_0,\n                    int VAR_1,\n                    const unsigned char* const VAR_2,\n                    unsigned VAR_3)\n{\n  int VAR_4 = Get16(VAR_0, VAR_5);\n\n  for (int VAR_6=0;VAR_6<VAR_4;VAR_6++)\n  {\n    const unsigned char* VAR_7 = DIR_ENTRY_ADDR(VAR_0, VAR_6);\n\n    unsigned VAR_8        = Get16(VAR_7, VAR_5);\n    unsigned VAR_9     = Get16(VAR_7+2, VAR_5);\n    unsigned VAR_10 = (unsigned)Get32(VAR_7+4, VAR_5);\n    if (VAR_9 == 0 || VAR_9 > VAR_11)\n    {\n      ErrNonfatal(\"Illegal number format %d for tag %04x\", VAR_9, VAR_8);\n      continue;\n    }\n\n    unsigned VAR_12 = VAR_13[VAR_9 - 1];\n    unsigned VAR_14 = VAR_10 * VAR_12;\n\n    const unsigned char* VAR_15;\n\n    if (VAR_14 > 4)\n    {\n      unsigned VAR_16 = (unsigned)Get32(VAR_7+8, VAR_5);\n      /* COMMENT_0 */\n      if (VAR_16+VAR_14 > VAR_3)\n      {\n        /* COMMENT_1 */\n        ErrNonfatal(\"Illegal value pointer for tag %04x\", VAR_8,0);\n        continue;\n      }\n      VAR_15 = VAR_2+VAR_16;\n    }\n    else\n    {\n      /* COMMENT_2 */\n      VAR_15 = VAR_7+8;\n    }\n\n    switch(VAR_8)\n    {\n      case VAR_17:\n        VAR_18->GpsLat[0] = VAR_15[0];\n        VAR_18->GpsLat[1] = 0;\n      break;\n\n      case VAR_19:\n        VAR_18->GpsLong[0] = VAR_15[0];\n        VAR_18->GpsLong[1] = 0;\n      break;\n\n      case VAR_20:\n        GetLatLong(VAR_9, VAR_15, VAR_12, VAR_18->GpsLat);\n      break;\n      case VAR_21:\n        GetLatLong(VAR_9, VAR_15, VAR_12, VAR_18->GpsLong);\n      break;\n\n      case VAR_22:\n        if (VAR_15[0] != 0)\n          VAR_18->GpsAlt[0] = '-';\n        VAR_18->GpsAlt[1] = 0;\n      break;\n\n      case VAR_23:\n        {\n          char VAR_24[18];\n          sprintf(VAR_24, \"%.2fm\", VAR_25<double>(ConvertAnyFormat(VAR_15, VAR_9)));\n          strcat(VAR_18->GpsAlt, VAR_24);\n        }\n      break;\n    }\n  }\n}",
  "func_graph_path_before": "xbmc/00fec1dbdd1df827872c7b55ad93059636dfc076/ExifParse.cpp/vul/before/0.json",
  "func": "void CExifParse::ProcessGpsInfo(\n                    const unsigned char* const DirStart,\n                    int ByteCountUnused,\n                    const unsigned char* const OffsetBase,\n                    unsigned ExifLength)\n{\n  int NumDirEntries = Get16(DirStart, m_MotorolaOrder);\n\n  for (int de=0;de<NumDirEntries;de++)\n  {\n    const unsigned char* DirEntry = DIR_ENTRY_ADDR(DirStart, de);\n\n    // Fix from aosp 34a2564d3268a5ca1472c5076675782fbaf724d6\n    if (DirEntry + 12 > OffsetBase + ExifLength)\n    {\n      ErrNonfatal(\"GPS info directory goes past end of exif\", 0, 0);\n      return;\n    }\n\n    unsigned Tag        = Get16(DirEntry, m_MotorolaOrder);\n    unsigned Format     = Get16(DirEntry+2, m_MotorolaOrder);\n    unsigned Components = (unsigned)Get32(DirEntry+4, m_MotorolaOrder);\n    if (Format == 0 || Format > NUM_FORMATS)\n    {\n      ErrNonfatal(\"Illegal number format %d for tag %04x\", Format, Tag);\n      continue;\n    }\n\n    unsigned ComponentSize = BytesPerFormat[Format - 1];\n    unsigned ByteCount = Components * ComponentSize;\n\n    const unsigned char* ValuePtr;\n\n    if (ByteCount > 4)\n    {\n      unsigned OffsetVal = (unsigned)Get32(DirEntry+8, m_MotorolaOrder);\n      // If its bigger than 4 bytes, the dir entry contains an offset.\n      if (OffsetVal+ByteCount > ExifLength)\n      {\n        // Bogus pointer offset and / or bytecount value\n        ErrNonfatal(\"Illegal value pointer for tag %04x\", Tag,0);\n        continue;\n      }\n      ValuePtr = OffsetBase+OffsetVal;\n    }\n    else\n    {\n      // 4 bytes or less and value is in the dir entry itself\n      ValuePtr = DirEntry+8;\n    }\n\n    switch(Tag)\n    {\n      case TAG_GPS_LAT_REF:\n        m_ExifInfo->GpsLat[0] = ValuePtr[0];\n        m_ExifInfo->GpsLat[1] = 0;\n      break;\n\n      case TAG_GPS_LONG_REF:\n        m_ExifInfo->GpsLong[0] = ValuePtr[0];\n        m_ExifInfo->GpsLong[1] = 0;\n      break;\n\n      case TAG_GPS_LAT:\n        GetLatLong(Format, ValuePtr, ComponentSize, m_ExifInfo->GpsLat);\n      break;\n      case TAG_GPS_LONG:\n        GetLatLong(Format, ValuePtr, ComponentSize, m_ExifInfo->GpsLong);\n      break;\n\n      case TAG_GPS_ALT_REF:\n        if (ValuePtr[0] != 0)\n          m_ExifInfo->GpsAlt[0] = '-';\n        m_ExifInfo->GpsAlt[1] = 0;\n      break;\n\n      case TAG_GPS_ALT:\n        {\n          char temp[18];\n          sprintf(temp, \"%.2fm\", static_cast<double>(ConvertAnyFormat(ValuePtr, Format)));\n          strcat(m_ExifInfo->GpsAlt, temp);\n        }\n      break;\n    }\n  }\n}",
  "abstract_func": "void CExifParse::ProcessGpsInfo(\n                    const unsigned char* const VAR_0,\n                    int VAR_1,\n                    const unsigned char* const VAR_2,\n                    unsigned VAR_3)\n{\n  int VAR_4 = Get16(VAR_0, VAR_5);\n\n  for (int VAR_6=0;VAR_6<VAR_4;VAR_6++)\n  {\n    const unsigned char* VAR_7 = DIR_ENTRY_ADDR(VAR_0, VAR_6);\n\n    /* COMMENT_0 */\n    if (VAR_7 + 12 > VAR_2 + VAR_3)\n    {\n      ErrNonfatal(\"GPS info directory goes past end of exif\", 0, 0);\n      return;\n    }\n\n    unsigned VAR_8        = Get16(VAR_7, VAR_5);\n    unsigned VAR_9     = Get16(VAR_7+2, VAR_5);\n    unsigned VAR_10 = (unsigned)Get32(VAR_7+4, VAR_5);\n    if (VAR_9 == 0 || VAR_9 > VAR_11)\n    {\n      ErrNonfatal(\"Illegal number format %d for tag %04x\", VAR_9, VAR_8);\n      continue;\n    }\n\n    unsigned VAR_12 = VAR_13[VAR_9 - 1];\n    unsigned VAR_14 = VAR_10 * VAR_12;\n\n    const unsigned char* VAR_15;\n\n    if (VAR_14 > 4)\n    {\n      unsigned VAR_16 = (unsigned)Get32(VAR_7+8, VAR_5);\n      /* COMMENT_1 */\n      if (VAR_16+VAR_14 > VAR_3)\n      {\n        /* COMMENT_2 */\n        ErrNonfatal(\"Illegal value pointer for tag %04x\", VAR_8,0);\n        continue;\n      }\n      VAR_15 = VAR_2+VAR_16;\n    }\n    else\n    {\n      /* COMMENT_3 */\n      VAR_15 = VAR_7+8;\n    }\n\n    switch(VAR_8)\n    {\n      case VAR_17:\n        VAR_18->GpsLat[0] = VAR_15[0];\n        VAR_18->GpsLat[1] = 0;\n      break;\n\n      case VAR_19:\n        VAR_18->GpsLong[0] = VAR_15[0];\n        VAR_18->GpsLong[1] = 0;\n      break;\n\n      case VAR_20:\n        GetLatLong(VAR_9, VAR_15, VAR_12, VAR_18->GpsLat);\n      break;\n      case VAR_21:\n        GetLatLong(VAR_9, VAR_15, VAR_12, VAR_18->GpsLong);\n      break;\n\n      case VAR_22:\n        if (VAR_15[0] != 0)\n          VAR_18->GpsAlt[0] = '-';\n        VAR_18->GpsAlt[1] = 0;\n      break;\n\n      case VAR_23:\n        {\n          char VAR_24[18];\n          sprintf(VAR_24, \"%.2fm\", VAR_25<double>(ConvertAnyFormat(VAR_15, VAR_9)));\n          strcat(VAR_18->GpsAlt, VAR_24);\n        }\n      break;\n    }\n  }\n}",
  "func_graph_path": "xbmc/00fec1dbdd1df827872c7b55ad93059636dfc076/ExifParse.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -9,6 +9,13 @@\n   for (int de=0;de<NumDirEntries;de++)\n   {\n     const unsigned char* DirEntry = DIR_ENTRY_ADDR(DirStart, de);\n+\n+    // Fix from aosp 34a2564d3268a5ca1472c5076675782fbaf724d6\n+    if (DirEntry + 12 > OffsetBase + ExifLength)\n+    {\n+      ErrNonfatal(\"GPS info directory goes past end of exif\", 0, 0);\n+      return;\n+    }\n \n     unsigned Tag        = Get16(DirEntry, m_MotorolaOrder);\n     unsigned Format     = Get16(DirEntry+2, m_MotorolaOrder);",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "",
      "    // Fix from aosp 34a2564d3268a5ca1472c5076675782fbaf724d6",
      "    if (DirEntry + 12 > OffsetBase + ExifLength)",
      "    {",
      "      ErrNonfatal(\"GPS info directory goes past end of exif\", 0, 0);",
      "      return;",
      "    }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/xbmc/xbmc/pull/22380",
  "description": {
    "pr_info": {
      "title": "ExifParser: Fix several out of bounds accesses while parsing exif information",
      "number": 22380
    },
    "comment": [
      "Several drafted images could crash kodi. This was tested with memory, address sanitizers enabled.\r\ncmake -DENABLE_VAAPI=1 -DCORE_PLATFORM_NAME=wayland -DCMAKE_BUILD_TYPE=Debug -DAPP_RENDER_SYSTEM=gl -DECM_ENABLE_SANITIZERS=address,memory\r\n\r\nExample Output:\r\nSUMMARY: AddressSanitizer: heap-buffer-overflow (/home/fritsch/Desktop/xbmc-fritsch/xbmc/build/kodi-wayland+0x3dca321) in CExifParse::Get32(void const*, bool)\r\nShadow bytes around the buggy address:\r\n  0x0c3c8004e070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\r\n  0x0c3c8004e080: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\r\n  0x0c3c8004e090: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\r\n  0x0c3c8004e0a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\r\n  0x0c3c8004e0b0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\r\n=>0x0c3c8004e0c0: 00 00 00 00 00[04]fa fa fa fa fa fa fa fa fa fa\r\n  0x0c3c8004e0d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\r\n  0x0c3c8004e0e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\r\n  0x0c3c8004e0f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\r\n  0x0c3c8004e100: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\r\n  0x0c3c8004e110: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\r\nShadow byte legend (one shadow byte represents 8 application bytes):\r\n  Addressable:           00\r\n  Partially addressable: 01 02 03 04 05 06 07 \r\n  Heap left redzone:       fa\r\n  Freed heap region:       fd\r\n  Stack left redzone:      f1\r\n  Stack mid redzone:       f2\r\n  Stack right redzone:     f3\r\n  Stack after return:      f5\r\n  Stack use after scope:   f8\r\n  Global redzone:          f9\r\n  Global init order:       f6\r\n  Poisoned by user:        f7\r\n  Container overflow:      fc\r\n  Array cookie:            ac\r\n  Intra object redzone:    bb\r\n  ASan internal:           fe\r\n  Left alloca redzone:     ca\r\n  Right alloca redzone:    cb\r\n  Shadow gap:              cc\r\n==824657==ABORTING\r\n\r\nvia: https://paste.kodi.tv/kagukejefa.kodi\r\n\r\nThe issues were long fixed upstream: https://android.googlesource.com/platform/external/jhead/+/2a4c12f5e5808e309b9ba04fe8b1539debf466d1\r\n\r\nKodi should remove the copied libexif code and use jhead directly.\r\n\r\nThis fixes: #22377 "
    ]
  },
  "Bug Filter": "** Security Vulnerability Fix  \n**Confidence Score:** 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\nThe patch adds a bounds check to prevent out-of-bounds access in an EXIF parser, addressing a potential buffer overflow vulnerability. This fix is crucial for preventing unauthorized access and data corruption, aligning with the criteria for a security vulnerability fix.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 0.95"
}