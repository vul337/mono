{
  "cve_id": "CVE-2022-4773",
  "cwe_ids": [
    "CWE-22"
  ],
  "cvss_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N",
  "cvss_is_v3": true,
  "repo_name": "HolgerHees/cloudsync",
  "commit_msg": "vuln-fix: Partial Path Traversal Vulnerability\n\nThis fixes a partial path traversal vulnerability.\n\nReplaces `dir.getCanonicalPath().startsWith(parent.getCanonicalPath())`, which is vulnerable to partial path traversal attacks, with the more secure `dir.getCanonicalFile().toPath().startsWith(parent.getCanonicalFile().toPath())`.\n\nTo demonstrate this vulnerability, consider `\"/usr/outnot\".startsWith(\"/usr/out\")`.\nThe check is bypassed although `/outnot` is not under the `/out` directory.\nIt's important to understand that the terminating slash may be removed when using various `String` representations of the `File` object.\nFor example, on Linux, `println(new File(\"/var\"))` will print `/var`, but `println(new File(\"/var\", \"/\")` will print `/var/`;\nhowever, `println(new File(\"/var\", \"/\").getCanonicalPath())` will print `/var`.\n\nWeakness: CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nSeverity: Medium\nCVSSS: 6.1\nDetection: CodeQL & OpenRewrite (https://public.moderne.io/recipes/org.openrewrite.java.security.PartialPathTraversalVulnerability)\n\nReported-by: Jonathan Leitschuh <Jonathan.Leitschuh@gmail.com>\nSigned-off-by: Jonathan Leitschuh <Jonathan.Leitschuh@gmail.com>\n\nBug-tracker: https://github.com/JLLeitschuh/security-research/issues/13\n\nCo-authored-by: Moderne <team@moderne.io>",
  "commit_hash": "3ad796833398af257c28e0ebeade68518e0e612a",
  "git_url": "https://github.com/HolgerHees/cloudsync/commit/3ad796833398af257c28e0ebeade68518e0e612a",
  "file_path": "src/main/java/cloudsync/connector/LocalFilesystemConnector.java",
  "func_name": "getItem",
  "func_before": "public Item getItem(File file, final FollowLinkType followlinks, List<String> followedLinkPaths ) throws FileIOException\n\t{\n\t\ttry\n\t\t{\n\t\t\tPath path = file.toPath();\n\n\t\t\tItemType type;\n\t\t\t\n\t\t\tif (Files.isSymbolicLink(path))\n\t\t\t{\n\t\t\t\tString target;\n\t\t\t\ttarget = Files.readSymbolicLink(path).toString();\n\t\t\t\tfinal String firstChar = target.substring(0, 1);\n\t\t\t\tif (!firstChar.equals(Item.SEPARATOR))\n\t\t\t\t{\n\t\t\t\t\tif (!firstChar.equals(\".\"))\n\t\t\t\t\t{\n\t\t\t\t\t\ttarget = \".\" + Item.SEPARATOR + target;\n\t\t\t\t\t}\n\t\t\t\t\ttarget = path.toString() + Item.SEPARATOR + target;\n\t\t\t\t}\n\t\t\t\ttarget = Paths.get(target).toFile().getCanonicalPath();\n\n                if (!followlinks.equals(FollowLinkType.NONE) && followlinks.equals(FollowLinkType.EXTERNAL) && !target.startsWith(localPath + Item.SEPARATOR) )\n\t\t\t\t{\n                    boolean foundLink = false;\n                    for( String followedLinkPath: followedLinkPaths )\n                    {\n                        // 1. if the link target is a child of a already followed link, then there is no need to follow again\n                        // 2. and the target should not be equal with a already followed link. Otherwise we are requesting the same item again. So we have to follow.\n                        if( target.startsWith(followedLinkPath) && !target.equals(followedLinkPath) )\n                        {\n                            foundLink = true;\n                            break;\n                        }\n                    }\n                    \n                    if( !foundLink )\n                    {\n                        final Path targetPath = Paths.get(target);\n                        if (Files.exists(targetPath, LinkOption.NOFOLLOW_LINKS))\n                        {\n                            path = targetPath;\n                            followedLinkPaths.add(target);\n                        }\n                    }\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tBasicFileAttributes basic_attr = Files.readAttributes(path, BasicFileAttributes.class, LinkOption.NOFOLLOW_LINKS);\n\t\t\tfinal Long filesize = basic_attr.size();\n\t\t\tfinal FileTime creationTime = basic_attr.creationTime();\n\t\t\tfinal FileTime modifyTime = basic_attr.lastModifiedTime();\n\t\t\tfinal FileTime accessTime = basic_attr.lastAccessTime();\n\n\t\t\tif (basic_attr.isDirectory())\n\t\t\t{\n\t\t\t\ttype = ItemType.FOLDER;\n\t\t\t}\n\t\t\telse if (basic_attr.isRegularFile())\n\t\t\t{\n\t\t\t\ttype = ItemType.FILE;\n\t\t\t}\n\t\t\telse if (basic_attr.isSymbolicLink())\n\t\t\t{\n\t\t\t\ttype = ItemType.LINK;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttype = ItemType.UNKNOWN;\n\t\t\t}\n\n\t\t\tMap<String, String[]> attributes = new HashMap<>();\n\n\t\t\tPosixFileAttributeView posixView = Files.getFileAttributeView(path, PosixFileAttributeView.class, LinkOption.NOFOLLOW_LINKS);\n\t\t\tif (posixView != null)\n\t\t\t{\n\t\t\t\tfinal PosixFileAttributes attr = posixView.readAttributes();\n\t\t\t\tif (type.equals(ItemType.LINK))\n\t\t\t\t{\n\t\t\t\t\tattributes.put(Item.ATTRIBUTE_POSIX, new String[] { attr.group().getName(), attr.owner().getName() });\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tattributes.put(Item.ATTRIBUTE_POSIX, new String[] { attr.group().getName(), attr.owner().getName(),\n\t\t\t\t\t\t\tfromPermissions(attr.permissions()).toString() });\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDosFileAttributeView dosView = Files.getFileAttributeView(path, DosFileAttributeView.class, LinkOption.NOFOLLOW_LINKS);\n\t\t\t\tif (dosView != null)\n\t\t\t\t{\n\t\t\t\t\tfinal DosFileAttributes attr = dosView.readAttributes();\n\t\t\t\t\tattributes.put(Item.ATTRIBUTE_DOS, new String[] { attr.isArchive() ? \"1\" : \"0\", attr.isHidden() ? \"1\" : \"0\", attr.isReadOnly() ? \"1\" : \"0\",\n\t\t\t\t\t\t\tattr.isSystem() ? \"1\" : \"0\" });\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!type.equals(ItemType.LINK))\n\t\t\t{\n\t\t\t\tAclFileAttributeView aclView = Files.getFileAttributeView(path, AclFileAttributeView.class, LinkOption.NOFOLLOW_LINKS);\n\t\t\t\tif (aclView != null)\n\t\t\t\t{\n\t\t\t\t\tif (!attributes.containsKey(Item.ATTRIBUTE_POSIX)) attributes.put(Item.ATTRIBUTE_OWNER, new String[] { aclView.getOwner().getName() });\n\n\t\t\t\t\tAclFileAttributeView parentAclView = Files.getFileAttributeView(path.getParent(), AclFileAttributeView.class, LinkOption.NOFOLLOW_LINKS);\n\n\t\t\t\t\tList<AclEntry> aclList = getLocalAclEntries(type, parentAclView.getAcl(), aclView.getAcl());\n\t\t\t\t\tif (aclList.size() > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tList<String> aclData = new ArrayList<>();\n\t\t\t\t\t\tfor (AclEntry acl : aclList)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tList<String> flags = new ArrayList<>();\n\t\t\t\t\t\t\tfor (AclEntryFlag flag : acl.flags())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tflags.add(flag.name());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tList<String> permissions = new ArrayList<>();\n\t\t\t\t\t\t\tfor (AclEntryPermission permission : acl.permissions())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpermissions.add(permission.name());\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\taclData.add(acl.type().name());\n\t\t\t\t\t\t\taclData.add(acl.principal().getName());\n\t\t\t\t\t\t\taclData.add(StringUtils.join(flags, \",\"));\n\t\t\t\t\t\t\taclData.add(StringUtils.join(permissions, \",\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tString[] arr = new String[aclData.size()];\n\t\t\t\t\t\tarr = aclData.toArray(arr);\n\t\t\t\t\t\tattributes.put(Item.ATTRIBUTE_ACL, arr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (!attributes.containsKey(Item.ATTRIBUTE_POSIX))\n\t\t\t\t{\n\t\t\t\t\tFileOwnerAttributeView ownerView = Files.getFileAttributeView(path, FileOwnerAttributeView.class, LinkOption.NOFOLLOW_LINKS);\n\t\t\t\t\tif (ownerView != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tattributes.put(Item.ATTRIBUTE_OWNER, new String[] { ownerView.getOwner().getName() });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn Item.fromLocalData(file.getName(), type, filesize, creationTime, modifyTime, accessTime, attributes);\n\t\t}\n\t\tcatch (final IOException e)\n\t\t{\n\t\t\tthrow new FileIOException(\"Can't read attributes of '\" + file.getAbsolutePath() + \"'\", e);\n\t\t}\n\t}",
  "abstract_func_before": "public Item getItem(File VAR_0, final FollowLinkType VAR_1, List<String> VAR_2 ) throws FileIOException\n\t{\n\t\ttry\n\t\t{\n\t\t\tPath VAR_3 = VAR_0.toPath();\n\n\t\t\tItemType VAR_4;\n\t\t\t\n\t\t\tif (VAR_5.isSymbolicLink(VAR_3))\n\t\t\t{\n\t\t\t\tString VAR_6;\n\t\t\t\tVAR_6 = VAR_5.readSymbolicLink(VAR_3).toString();\n\t\t\t\tfinal String VAR_7 = VAR_6.substring(0, 1);\n\t\t\t\tif (!VAR_7.equals(VAR_8.SEPARATOR))\n\t\t\t\t{\n\t\t\t\t\tif (!VAR_7.equals(\".\"))\n\t\t\t\t\t{\n\t\t\t\t\t\tVAR_6 = \".\" + VAR_8.SEPARATOR + VAR_6;\n\t\t\t\t\t}\n\t\t\t\t\tVAR_6 = VAR_3.toString() + VAR_8.SEPARATOR + VAR_6;\n\t\t\t\t}\n\t\t\t\tVAR_6 = VAR_9.get(VAR_6).toFile().getCanonicalPath();\n\n                if (!VAR_1.equals(VAR_10.NONE) && VAR_1.equals(VAR_10.EXTERNAL) && !VAR_6.startsWith(VAR_11 + VAR_8.SEPARATOR) )\n\t\t\t\t{\n                    boolean VAR_12 = false;\n                    for( String VAR_13: VAR_2 )\n                    {\n                        /* COMMENT_0 */\n                        /* COMMENT_1 */\n                        if( VAR_6.startsWith(VAR_13) && !VAR_6.equals(VAR_13) )\n                        {\n                            VAR_12 = true;\n                            break;\n                        }\n                    }\n                    \n                    if( !VAR_12 )\n                    {\n                        final Path VAR_14 = VAR_9.get(VAR_6);\n                        if (VAR_5.exists(VAR_14, VAR_15.NOFOLLOW_LINKS))\n                        {\n                            VAR_3 = VAR_14;\n                            VAR_2.add(VAR_6);\n                        }\n                    }\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tBasicFileAttributes VAR_16 = VAR_5.readAttributes(VAR_3, BasicFileAttributes.class, VAR_15.NOFOLLOW_LINKS);\n\t\t\tfinal Long VAR_17 = VAR_16.size();\n\t\t\tfinal FileTime VAR_18 = VAR_16.creationTime();\n\t\t\tfinal FileTime VAR_19 = VAR_16.lastModifiedTime();\n\t\t\tfinal FileTime VAR_20 = VAR_16.lastAccessTime();\n\n\t\t\tif (VAR_16.isDirectory())\n\t\t\t{\n\t\t\t\tVAR_4 = VAR_21.FOLDER;\n\t\t\t}\n\t\t\telse if (VAR_16.isRegularFile())\n\t\t\t{\n\t\t\t\tVAR_4 = VAR_21.FILE;\n\t\t\t}\n\t\t\telse if (VAR_16.isSymbolicLink())\n\t\t\t{\n\t\t\t\tVAR_4 = VAR_21.LINK;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tVAR_4 = VAR_21.UNKNOWN;\n\t\t\t}\n\n\t\t\tMap<String, String[]> VAR_22 = new HashMap<>();\n\n\t\t\tPosixFileAttributeView VAR_23 = VAR_5.getFileAttributeView(VAR_3, PosixFileAttributeView.class, VAR_15.NOFOLLOW_LINKS);\n\t\t\tif (VAR_23 != null)\n\t\t\t{\n\t\t\t\tfinal PosixFileAttributes VAR_24 = VAR_23.readAttributes();\n\t\t\t\tif (VAR_4.equals(VAR_21.LINK))\n\t\t\t\t{\n\t\t\t\t\tVAR_22.put(VAR_8.ATTRIBUTE_POSIX, new String[] { VAR_24.group().getName(), VAR_24.owner().getName() });\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tVAR_22.put(VAR_8.ATTRIBUTE_POSIX, new String[] { VAR_24.group().getName(), VAR_24.owner().getName(),\n\t\t\t\t\t\t\tfromPermissions(VAR_24.permissions()).toString() });\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDosFileAttributeView VAR_25 = VAR_5.getFileAttributeView(VAR_3, DosFileAttributeView.class, VAR_15.NOFOLLOW_LINKS);\n\t\t\t\tif (VAR_25 != null)\n\t\t\t\t{\n\t\t\t\t\tfinal DosFileAttributes VAR_24 = VAR_25.readAttributes();\n\t\t\t\t\tVAR_22.put(VAR_8.ATTRIBUTE_DOS, new String[] { VAR_24.isArchive() ? \"1\" : \"0\", VAR_24.isHidden() ? \"1\" : \"0\", VAR_24.isReadOnly() ? \"1\" : \"0\",\n\t\t\t\t\t\t\tVAR_24.isSystem() ? \"1\" : \"0\" });\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!VAR_4.equals(VAR_21.LINK))\n\t\t\t{\n\t\t\t\tAclFileAttributeView VAR_26 = VAR_5.getFileAttributeView(VAR_3, AclFileAttributeView.class, VAR_15.NOFOLLOW_LINKS);\n\t\t\t\tif (VAR_26 != null)\n\t\t\t\t{\n\t\t\t\t\tif (!VAR_22.containsKey(VAR_8.ATTRIBUTE_POSIX)) VAR_22.put(VAR_8.ATTRIBUTE_OWNER, new String[] { VAR_26.getOwner().getName() });\n\n\t\t\t\t\tAclFileAttributeView VAR_27 = VAR_5.getFileAttributeView(VAR_3.getParent(), AclFileAttributeView.class, VAR_15.NOFOLLOW_LINKS);\n\n\t\t\t\t\tList<AclEntry> VAR_28 = getLocalAclEntries(VAR_4, VAR_27.getAcl(), VAR_26.getAcl());\n\t\t\t\t\tif (VAR_28.size() > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tList<String> VAR_29 = new ArrayList<>();\n\t\t\t\t\t\tfor (AclEntry VAR_30 : VAR_28)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tList<String> VAR_31 = new ArrayList<>();\n\t\t\t\t\t\t\tfor (AclEntryFlag VAR_32 : VAR_30.flags())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tVAR_31.add(VAR_32.name());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tList<String> VAR_33 = new ArrayList<>();\n\t\t\t\t\t\t\tfor (AclEntryPermission VAR_34 : VAR_30.permissions())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tVAR_33.add(VAR_34.name());\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tVAR_29.add(VAR_30.type().name());\n\t\t\t\t\t\t\tVAR_29.add(VAR_30.principal().getName());\n\t\t\t\t\t\t\tVAR_29.add(VAR_35.join(VAR_31, \",\"));\n\t\t\t\t\t\t\tVAR_29.add(VAR_35.join(VAR_33, \",\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tString[] VAR_36 = new String[VAR_29.size()];\n\t\t\t\t\t\tVAR_36 = VAR_29.toArray(VAR_36);\n\t\t\t\t\t\tVAR_22.put(VAR_8.ATTRIBUTE_ACL, VAR_36);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (!VAR_22.containsKey(VAR_8.ATTRIBUTE_POSIX))\n\t\t\t\t{\n\t\t\t\t\tFileOwnerAttributeView VAR_37 = VAR_5.getFileAttributeView(VAR_3, FileOwnerAttributeView.class, VAR_15.NOFOLLOW_LINKS);\n\t\t\t\t\tif (VAR_37 != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tVAR_22.put(VAR_8.ATTRIBUTE_OWNER, new String[] { VAR_37.getOwner().getName() });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn VAR_8.fromLocalData(VAR_0.getName(), VAR_4, VAR_17, VAR_18, VAR_19, VAR_20, VAR_22);\n\t\t}\n\t\tcatch (final IOException VAR_38)\n\t\t{\n\t\t\tthrow new FileIOException(\"Can't read attributes of '\" + VAR_0.getAbsolutePath() + \"'\", VAR_38);\n\t\t}\n\t}",
  "func_graph_path_before": "HolgerHees/cloudsync/3ad796833398af257c28e0ebeade68518e0e612a/LocalFilesystemConnector.java/vul/before/0.json",
  "func": "public Item getItem(File file, final FollowLinkType followlinks, List<String> followedLinkPaths ) throws FileIOException\n\t{\n\t\ttry\n\t\t{\n\t\t\tPath path = file.toPath();\n\n\t\t\tItemType type;\n\t\t\t\n\t\t\tif (Files.isSymbolicLink(path))\n\t\t\t{\n\t\t\t\tString target;\n\t\t\t\ttarget = Files.readSymbolicLink(path).toString();\n\t\t\t\tfinal String firstChar = target.substring(0, 1);\n\t\t\t\tif (!firstChar.equals(Item.SEPARATOR))\n\t\t\t\t{\n\t\t\t\t\tif (!firstChar.equals(\".\"))\n\t\t\t\t\t{\n\t\t\t\t\t\ttarget = \".\" + Item.SEPARATOR + target;\n\t\t\t\t\t}\n\t\t\t\t\ttarget = path.toString() + Item.SEPARATOR + target;\n\t\t\t\t}\n\t\t\t\ttarget = Paths.get(target).toFile().getCanonicalPath();\n\n                if (!followlinks.equals(FollowLinkType.NONE) && followlinks.equals(FollowLinkType.EXTERNAL) && !Paths.get(target).toFile().getCanonicalFile().toPath().startsWith(localPath + Item.SEPARATOR) )\n\t\t\t\t{\n                    boolean foundLink = false;\n                    for( String followedLinkPath: followedLinkPaths )\n                    {\n                        // 1. if the link target is a child of a already followed link, then there is no need to follow again\n                        // 2. and the target should not be equal with a already followed link. Otherwise we are requesting the same item again. So we have to follow.\n                        if( target.startsWith(followedLinkPath) && !target.equals(followedLinkPath) )\n                        {\n                            foundLink = true;\n                            break;\n                        }\n                    }\n                    \n                    if( !foundLink )\n                    {\n                        final Path targetPath = Paths.get(target);\n                        if (Files.exists(targetPath, LinkOption.NOFOLLOW_LINKS))\n                        {\n                            path = targetPath;\n                            followedLinkPaths.add(target);\n                        }\n                    }\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tBasicFileAttributes basic_attr = Files.readAttributes(path, BasicFileAttributes.class, LinkOption.NOFOLLOW_LINKS);\n\t\t\tfinal Long filesize = basic_attr.size();\n\t\t\tfinal FileTime creationTime = basic_attr.creationTime();\n\t\t\tfinal FileTime modifyTime = basic_attr.lastModifiedTime();\n\t\t\tfinal FileTime accessTime = basic_attr.lastAccessTime();\n\n\t\t\tif (basic_attr.isDirectory())\n\t\t\t{\n\t\t\t\ttype = ItemType.FOLDER;\n\t\t\t}\n\t\t\telse if (basic_attr.isRegularFile())\n\t\t\t{\n\t\t\t\ttype = ItemType.FILE;\n\t\t\t}\n\t\t\telse if (basic_attr.isSymbolicLink())\n\t\t\t{\n\t\t\t\ttype = ItemType.LINK;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttype = ItemType.UNKNOWN;\n\t\t\t}\n\n\t\t\tMap<String, String[]> attributes = new HashMap<>();\n\n\t\t\tPosixFileAttributeView posixView = Files.getFileAttributeView(path, PosixFileAttributeView.class, LinkOption.NOFOLLOW_LINKS);\n\t\t\tif (posixView != null)\n\t\t\t{\n\t\t\t\tfinal PosixFileAttributes attr = posixView.readAttributes();\n\t\t\t\tif (type.equals(ItemType.LINK))\n\t\t\t\t{\n\t\t\t\t\tattributes.put(Item.ATTRIBUTE_POSIX, new String[] { attr.group().getName(), attr.owner().getName() });\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tattributes.put(Item.ATTRIBUTE_POSIX, new String[] { attr.group().getName(), attr.owner().getName(),\n\t\t\t\t\t\t\tfromPermissions(attr.permissions()).toString() });\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDosFileAttributeView dosView = Files.getFileAttributeView(path, DosFileAttributeView.class, LinkOption.NOFOLLOW_LINKS);\n\t\t\t\tif (dosView != null)\n\t\t\t\t{\n\t\t\t\t\tfinal DosFileAttributes attr = dosView.readAttributes();\n\t\t\t\t\tattributes.put(Item.ATTRIBUTE_DOS, new String[] { attr.isArchive() ? \"1\" : \"0\", attr.isHidden() ? \"1\" : \"0\", attr.isReadOnly() ? \"1\" : \"0\",\n\t\t\t\t\t\t\tattr.isSystem() ? \"1\" : \"0\" });\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!type.equals(ItemType.LINK))\n\t\t\t{\n\t\t\t\tAclFileAttributeView aclView = Files.getFileAttributeView(path, AclFileAttributeView.class, LinkOption.NOFOLLOW_LINKS);\n\t\t\t\tif (aclView != null)\n\t\t\t\t{\n\t\t\t\t\tif (!attributes.containsKey(Item.ATTRIBUTE_POSIX)) attributes.put(Item.ATTRIBUTE_OWNER, new String[] { aclView.getOwner().getName() });\n\n\t\t\t\t\tAclFileAttributeView parentAclView = Files.getFileAttributeView(path.getParent(), AclFileAttributeView.class, LinkOption.NOFOLLOW_LINKS);\n\n\t\t\t\t\tList<AclEntry> aclList = getLocalAclEntries(type, parentAclView.getAcl(), aclView.getAcl());\n\t\t\t\t\tif (aclList.size() > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tList<String> aclData = new ArrayList<>();\n\t\t\t\t\t\tfor (AclEntry acl : aclList)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tList<String> flags = new ArrayList<>();\n\t\t\t\t\t\t\tfor (AclEntryFlag flag : acl.flags())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tflags.add(flag.name());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tList<String> permissions = new ArrayList<>();\n\t\t\t\t\t\t\tfor (AclEntryPermission permission : acl.permissions())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpermissions.add(permission.name());\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\taclData.add(acl.type().name());\n\t\t\t\t\t\t\taclData.add(acl.principal().getName());\n\t\t\t\t\t\t\taclData.add(StringUtils.join(flags, \",\"));\n\t\t\t\t\t\t\taclData.add(StringUtils.join(permissions, \",\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tString[] arr = new String[aclData.size()];\n\t\t\t\t\t\tarr = aclData.toArray(arr);\n\t\t\t\t\t\tattributes.put(Item.ATTRIBUTE_ACL, arr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (!attributes.containsKey(Item.ATTRIBUTE_POSIX))\n\t\t\t\t{\n\t\t\t\t\tFileOwnerAttributeView ownerView = Files.getFileAttributeView(path, FileOwnerAttributeView.class, LinkOption.NOFOLLOW_LINKS);\n\t\t\t\t\tif (ownerView != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tattributes.put(Item.ATTRIBUTE_OWNER, new String[] { ownerView.getOwner().getName() });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn Item.fromLocalData(file.getName(), type, filesize, creationTime, modifyTime, accessTime, attributes);\n\t\t}\n\t\tcatch (final IOException e)\n\t\t{\n\t\t\tthrow new FileIOException(\"Can't read attributes of '\" + file.getAbsolutePath() + \"'\", e);\n\t\t}\n\t}",
  "abstract_func": "public Item getItem(File VAR_0, final FollowLinkType VAR_1, List<String> VAR_2 ) throws FileIOException\n\t{\n\t\ttry\n\t\t{\n\t\t\tPath VAR_3 = VAR_0.toPath();\n\n\t\t\tItemType VAR_4;\n\t\t\t\n\t\t\tif (VAR_5.isSymbolicLink(VAR_3))\n\t\t\t{\n\t\t\t\tString VAR_6;\n\t\t\t\tVAR_6 = VAR_5.readSymbolicLink(VAR_3).toString();\n\t\t\t\tfinal String VAR_7 = VAR_6.substring(0, 1);\n\t\t\t\tif (!VAR_7.equals(VAR_8.SEPARATOR))\n\t\t\t\t{\n\t\t\t\t\tif (!VAR_7.equals(\".\"))\n\t\t\t\t\t{\n\t\t\t\t\t\tVAR_6 = \".\" + VAR_8.SEPARATOR + VAR_6;\n\t\t\t\t\t}\n\t\t\t\t\tVAR_6 = VAR_3.toString() + VAR_8.SEPARATOR + VAR_6;\n\t\t\t\t}\n\t\t\t\tVAR_6 = VAR_9.get(VAR_6).toFile().getCanonicalPath();\n\n                if (!VAR_1.equals(VAR_10.NONE) && VAR_1.equals(VAR_10.EXTERNAL) && !VAR_9.get(VAR_6).toFile().getCanonicalFile().toPath().startsWith(VAR_11 + VAR_8.SEPARATOR) )\n\t\t\t\t{\n                    boolean VAR_12 = false;\n                    for( String VAR_13: VAR_2 )\n                    {\n                        /* COMMENT_0 */\n                        /* COMMENT_1 */\n                        if( VAR_6.startsWith(VAR_13) && !VAR_6.equals(VAR_13) )\n                        {\n                            VAR_12 = true;\n                            break;\n                        }\n                    }\n                    \n                    if( !VAR_12 )\n                    {\n                        final Path VAR_14 = VAR_9.get(VAR_6);\n                        if (VAR_5.exists(VAR_14, VAR_15.NOFOLLOW_LINKS))\n                        {\n                            VAR_3 = VAR_14;\n                            VAR_2.add(VAR_6);\n                        }\n                    }\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tBasicFileAttributes VAR_16 = VAR_5.readAttributes(VAR_3, BasicFileAttributes.class, VAR_15.NOFOLLOW_LINKS);\n\t\t\tfinal Long VAR_17 = VAR_16.size();\n\t\t\tfinal FileTime VAR_18 = VAR_16.creationTime();\n\t\t\tfinal FileTime VAR_19 = VAR_16.lastModifiedTime();\n\t\t\tfinal FileTime VAR_20 = VAR_16.lastAccessTime();\n\n\t\t\tif (VAR_16.isDirectory())\n\t\t\t{\n\t\t\t\tVAR_4 = VAR_21.FOLDER;\n\t\t\t}\n\t\t\telse if (VAR_16.isRegularFile())\n\t\t\t{\n\t\t\t\tVAR_4 = VAR_21.FILE;\n\t\t\t}\n\t\t\telse if (VAR_16.isSymbolicLink())\n\t\t\t{\n\t\t\t\tVAR_4 = VAR_21.LINK;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tVAR_4 = VAR_21.UNKNOWN;\n\t\t\t}\n\n\t\t\tMap<String, String[]> VAR_22 = new HashMap<>();\n\n\t\t\tPosixFileAttributeView VAR_23 = VAR_5.getFileAttributeView(VAR_3, PosixFileAttributeView.class, VAR_15.NOFOLLOW_LINKS);\n\t\t\tif (VAR_23 != null)\n\t\t\t{\n\t\t\t\tfinal PosixFileAttributes VAR_24 = VAR_23.readAttributes();\n\t\t\t\tif (VAR_4.equals(VAR_21.LINK))\n\t\t\t\t{\n\t\t\t\t\tVAR_22.put(VAR_8.ATTRIBUTE_POSIX, new String[] { VAR_24.group().getName(), VAR_24.owner().getName() });\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tVAR_22.put(VAR_8.ATTRIBUTE_POSIX, new String[] { VAR_24.group().getName(), VAR_24.owner().getName(),\n\t\t\t\t\t\t\tfromPermissions(VAR_24.permissions()).toString() });\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDosFileAttributeView VAR_25 = VAR_5.getFileAttributeView(VAR_3, DosFileAttributeView.class, VAR_15.NOFOLLOW_LINKS);\n\t\t\t\tif (VAR_25 != null)\n\t\t\t\t{\n\t\t\t\t\tfinal DosFileAttributes VAR_24 = VAR_25.readAttributes();\n\t\t\t\t\tVAR_22.put(VAR_8.ATTRIBUTE_DOS, new String[] { VAR_24.isArchive() ? \"1\" : \"0\", VAR_24.isHidden() ? \"1\" : \"0\", VAR_24.isReadOnly() ? \"1\" : \"0\",\n\t\t\t\t\t\t\tVAR_24.isSystem() ? \"1\" : \"0\" });\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!VAR_4.equals(VAR_21.LINK))\n\t\t\t{\n\t\t\t\tAclFileAttributeView VAR_26 = VAR_5.getFileAttributeView(VAR_3, AclFileAttributeView.class, VAR_15.NOFOLLOW_LINKS);\n\t\t\t\tif (VAR_26 != null)\n\t\t\t\t{\n\t\t\t\t\tif (!VAR_22.containsKey(VAR_8.ATTRIBUTE_POSIX)) VAR_22.put(VAR_8.ATTRIBUTE_OWNER, new String[] { VAR_26.getOwner().getName() });\n\n\t\t\t\t\tAclFileAttributeView VAR_27 = VAR_5.getFileAttributeView(VAR_3.getParent(), AclFileAttributeView.class, VAR_15.NOFOLLOW_LINKS);\n\n\t\t\t\t\tList<AclEntry> VAR_28 = getLocalAclEntries(VAR_4, VAR_27.getAcl(), VAR_26.getAcl());\n\t\t\t\t\tif (VAR_28.size() > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tList<String> VAR_29 = new ArrayList<>();\n\t\t\t\t\t\tfor (AclEntry VAR_30 : VAR_28)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tList<String> VAR_31 = new ArrayList<>();\n\t\t\t\t\t\t\tfor (AclEntryFlag VAR_32 : VAR_30.flags())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tVAR_31.add(VAR_32.name());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tList<String> VAR_33 = new ArrayList<>();\n\t\t\t\t\t\t\tfor (AclEntryPermission VAR_34 : VAR_30.permissions())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tVAR_33.add(VAR_34.name());\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tVAR_29.add(VAR_30.type().name());\n\t\t\t\t\t\t\tVAR_29.add(VAR_30.principal().getName());\n\t\t\t\t\t\t\tVAR_29.add(VAR_35.join(VAR_31, \",\"));\n\t\t\t\t\t\t\tVAR_29.add(VAR_35.join(VAR_33, \",\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tString[] VAR_36 = new String[VAR_29.size()];\n\t\t\t\t\t\tVAR_36 = VAR_29.toArray(VAR_36);\n\t\t\t\t\t\tVAR_22.put(VAR_8.ATTRIBUTE_ACL, VAR_36);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (!VAR_22.containsKey(VAR_8.ATTRIBUTE_POSIX))\n\t\t\t\t{\n\t\t\t\t\tFileOwnerAttributeView VAR_37 = VAR_5.getFileAttributeView(VAR_3, FileOwnerAttributeView.class, VAR_15.NOFOLLOW_LINKS);\n\t\t\t\t\tif (VAR_37 != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tVAR_22.put(VAR_8.ATTRIBUTE_OWNER, new String[] { VAR_37.getOwner().getName() });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn VAR_8.fromLocalData(VAR_0.getName(), VAR_4, VAR_17, VAR_18, VAR_19, VAR_20, VAR_22);\n\t\t}\n\t\tcatch (final IOException VAR_38)\n\t\t{\n\t\t\tthrow new FileIOException(\"Can't read attributes of '\" + VAR_0.getAbsolutePath() + \"'\", VAR_38);\n\t\t}\n\t}",
  "func_graph_path": "HolgerHees/cloudsync/3ad796833398af257c28e0ebeade68518e0e612a/LocalFilesystemConnector.java/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -21,7 +21,7 @@\n \t\t\t\t}\n \t\t\t\ttarget = Paths.get(target).toFile().getCanonicalPath();\n \n-                if (!followlinks.equals(FollowLinkType.NONE) && followlinks.equals(FollowLinkType.EXTERNAL) && !target.startsWith(localPath + Item.SEPARATOR) )\n+                if (!followlinks.equals(FollowLinkType.NONE) && followlinks.equals(FollowLinkType.EXTERNAL) && !Paths.get(target).toFile().getCanonicalFile().toPath().startsWith(localPath + Item.SEPARATOR) )\n \t\t\t\t{\n                     boolean foundLink = false;\n                     for( String followedLinkPath: followedLinkPaths )",
  "diff_line_info": {
    "deleted_lines": [
      "                if (!followlinks.equals(FollowLinkType.NONE) && followlinks.equals(FollowLinkType.EXTERNAL) && !target.startsWith(localPath + Item.SEPARATOR) )"
    ],
    "added_lines": [
      "                if (!followlinks.equals(FollowLinkType.NONE) && followlinks.equals(FollowLinkType.EXTERNAL) && !Paths.get(target).toFile().getCanonicalFile().toPath().startsWith(localPath + Item.SEPARATOR) )"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/HolgerHees/cloudsync/pull/46",
  "description": {
    "pr_info": {
      "title": "[SECURITY] Fix Partial Path Traversal Vulnerability",
      "number": 46
    },
    "comment": [
      "# Security Vulnerability Fix\n\nThis pull request fixes a partial-path traversal vulnerability due to an insufficient path traversal guard.\n\nEven if you deem, as the maintainer of this project, this is not necessarily fixing a security vulnerability, it is still a valid security hardening.\n\n## Preamble\n\n### Impact\n\nThis issue allows a malicious actor to potentially break out of the expected directory. The impact is limited to sibling directories. For example, `userControlled.getCanonicalPath().startsWith(\"/usr/out\")` will allow an attacker to access a directory with a name like `/usr/outnot`. \n\n### Why?\n\nTo demonstrate this vulnerability, consider `\"/usr/outnot\".startsWith(\"/usr/out\")`.\nThe check is bypassed although `/outnot` is not under the `/out` directory.\nIt's important to understand that the terminating slash may be removed when using various `String` representations of the `File` object.\nFor example, on Linux, `println(new File(\"/var\"))` will print `/var`, but `println(new File(\"/var\", \"/\")` will print `/var/`;\nhowever, `println(new File(\"/var\", \"/\").getCanonicalPath())` will print `/var`.\n\n### The Fix\n\nComparing paths with the `java.nio.files.Path#startsWith` will adequately protect againts this vulnerability.\n\nFor example: `file.getCanonicalFile().toPath().startsWith(BASE_DIRECTORY)` or `file.getCanonicalFile().toPath().startsWith(BASE_DIRECTORY_FILE.getCanonicalFile().toPath())`\n\n### Other Examples\n\n - [CVE-2022-31159](https://github.com/aws/aws-sdk-java/security/advisories/GHSA-c28r-hw5m-5gv3) - aws/aws-sdk-java\n - [CVE-2022-23457](https://securitylab.github.com/advisories/GHSL-2022-008_The_OWASP_Enterprise_Security_API/) - ESAPI/esapi-java-legacy\n\n# :arrow_right: Vulnerability Disclosure :arrow_left:\n\n:wave: Vulnerability disclosure is a super important part of the vulnerability handling process and should not be skipped! This may be completely new to you, and that's okay, I'm here to assist!\n\nFirst question, do we need to perform vulnerability disclosure? It depends!\n\n 1. Is the vulnerable code only in tests or example code? No disclosure required!\n 2. Is the vulnerable code in code shipped to your end users? Vulnerability disclosure is probably required!\n\nFor partial path traversal, consider if user-supplied input could ever flow to this logic. If user supplied input could reach this conditional, it's  insufficient and, as such, most likely a vulnerability.\n\n## Vulnerability Disclosure How-To\n\nYou have a few options options to perform vulnerability disclosure. However, I'd like to suggest the following 2 options:\n\n 1. Request a CVE number from GitHub by creating a repository-level [GitHub Security Advisory](https://docs.github.com/en/code-security/repository-security-advisories/creating-a-repository-security-advisory). This has the advantage that, if you provide sufficient information, GitHub will automatically generate Dependabot alerts for your downstream consumers, resolving this vulnerability more quickly.\n 2. Reach out to the team at Snyk to assist with CVE issuance. They can be reached at the [Snyk's Disclosure Email](mailto:report@snyk.io). Note: Please include `JLLeitschuh Disclosure` in the subject of your email so it is not missed.\n\n## Detecting this and Future Vulnerabilities\n\nYou can automatically detect future vulnerabilities like this by enabling the free (for open-source) [GitHub Action](https://github.com/github/codeql-action).\n\nI'm not an employee of GitHub, I'm simply an open-source security researcher.\n\n## Source\n\nThis contribution was automatically generated with an [OpenRewrite](https://github.com/openrewrite/rewrite) [refactoring recipe](https://docs.openrewrite.org/), which was lovingly hand crafted to bring this security fix to your repository.\n\nThe source code that generated this PR can be found here:\n[PartialPathTraversalVulnerability](https://github.com/openrewrite/rewrite-java-security/blob/main/src/main/java/org/openrewrite/java/security/PartialPathTraversalVulnerability.java)\n\n## Why didn't you disclose privately (ie. coordinated disclosure)?\n\nThis PR was automatically generated, in-bulk, and sent to this project as well as many others, all at the same time.\n\nThis is technically what is called a \"Full Disclosure\" in vulnerability disclosure, and I agree it's less than ideal. If GitHub offered a way to create private pull requests to submit pull requests, I'd leverage it, but that infrastructure, sadly, doesn't exist yet.\n\nThe problem is that as an open source software security researcher, I (exactly like open source maintainers), I only have so much time in a day. I'm able to find vulnerabilities impacting hundreds, or sometimes thousands of open source projects with tools like GitHub Code Search and CodeQL. The problem is that my knowledge of vulnerabilities doesn't scale very well.\n\nIndividualized vulnerability disclosure takes time and care. It's a long and tedious process, and I have a significant amount of experience with it (I have over 50 CVEs to my name). Even tracking down the reporting channel (email, Jira, ect..) can take time and isn't automatable. Unfortunately, when facing prblems of this scale, individual reporting doesn't work well either.\n\nAdditionally, if I just spam out emails or issues, I'll just overwhelm already over taxed maintainers, I don't want to do this either.\n\nBy creating a pull request, I am aiming to provide maintainers something highly actionable to actually fix the identified vulnerability; a pull request.\n\nThere's a larger discussion on this topic that can be found here:  https://github.com/JLLeitschuh/security-research/discussions/12\n\n## Opting-Out\n\nIf you'd like to opt-out of future automated security vulnerability fixes like this, please consider adding a file called\n`.github/GH-ROBOTS.txt` to your repository with the line:\n\n```\nUser-agent: JLLeitschuh/security-research\nDisallow: *\n```\n\nThis bot will respect the [ROBOTS.txt](https://moz.com/learn/seo/robotstxt) format for future contributions.\n\nAlternatively, if this project is no longer actively maintained, consider [archiving](https://help.github.com/en/github/creating-cloning-and-archiving-repositories/about-archiving-repositories) the repository.\n\n## CLA Requirements\n\n_This section is only relevant if your project requires contributors to sign a Contributor License Agreement (CLA) for external contributions._\n\nIt is unlikely that I'll be able to directly sign CLAs. However, all contributed commits are already automatically signed-off.\n\n> The meaning of a signoff depends on the project, but it typically certifies that committer has the rights to submit this work under the same license and agrees to a Developer Certificate of Origin \n> (see [https://developercertificate.org/](https://developercertificate.org/) for more information).\n>\n> \\- [Git Commit Signoff documentation](https://developercertificate.org/)\n\nIf signing your organization's CLA is a strict-requirement for merging this contribution, please feel free to close this PR.\n\n## Sponsorship & Support\n\nThis contribution is sponsored by HUMAN Security Inc. and the new Dan Kaminsky Fellowship, a fellowship created to celebrate Dan's memory and legacy by funding open-source work that makes the world a better (and more secure) place.\n\nThis PR was generated by [Moderne](https://www.moderne.io/), a free-for-open source SaaS offering that uses format-preserving AST transformations to fix bugs, standardize code style, apply best practices, migrate library versions, and fix common security vulnerabilities at scale.\n\n## Tracking\n\nAll PR's generated as part of this fix are tracked here: https://github.com/JLLeitschuh/security-research/issues/13"
    ]
  },
  "Bug Filter": "** Security Vulnerability Fix  \n**Confidence Score:** 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\nThe patch addresses a security vulnerability by fixing a path traversal issue, ensuring that file access is properly restricted.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 1.0"
}