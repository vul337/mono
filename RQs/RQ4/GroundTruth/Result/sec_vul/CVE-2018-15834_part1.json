{
  "cve_id": "CVE-2018-15834",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "radareorg/radare2",
  "commit_msg": "fix #11274 attempt.\n\nbasically with the given name function section size\nwas way above, we consider as faulty even though\nthe sample sig file seems legit ?",
  "commit_hash": "ee1727f272d69d904cc84e4d368ece8c260f5ead",
  "git_url": "https://github.com/radareorg/radare2/commit/ee1727f272d69d904cc84e4d368ece8c260f5ead",
  "file_path": "libr/anal/flirt.c",
  "func_name": "read_module_referenced_functions",
  "func_before": "static ut8 read_module_referenced_functions(RFlirtModule *module, RBuffer *b) {\n\t/*parses a module referenced functions*/\n\t/*returns false on parsing error*/\n\tint i, j;\n\tut8 number_of_referenced_functions;\n\tut32 ref_function_name_length;\n\tRFlirtFunction *ref_function = NULL;\n\n\tmodule->referenced_functions = r_list_new ();\n\n\tif (version >= 8) { // this counter was introduced in version 8\n\t\tnumber_of_referenced_functions = read_byte (b); // XXX are we sure it's not read_multiple_bytes?\n\t\tif (buf_eof || buf_err) {\n\t\t\tgoto err_exit;\n\t\t}\n\t} else { // suppose there's only one\n\t\tnumber_of_referenced_functions = 1;\n\t}\n\n\tfor (i = 0; i < number_of_referenced_functions; i++) {\n\t\tref_function = R_NEW0 (RFlirtFunction);\n\t\tif (!ref_function) {\n\t\t\tgoto err_exit;\n\t\t}\n\t\tif (version >= 9) {\n\t\t\tref_function->offset = read_multiple_bytes (b);\n\t\t\tif (buf_eof || buf_err) {\n\t\t\t\tgoto err_exit;\n\t\t\t}\n\t\t} else {\n\t\t\tref_function->offset = read_max_2_bytes (b);\n\t\t\tif (buf_eof || buf_err) {\n\t\t\t\tgoto err_exit;\n\t\t\t}\n\t\t}\n\t\tref_function_name_length = read_byte (b);\n\t\tif (buf_eof || buf_err) {\n\t\t\tgoto err_exit;\n\t\t}\n\t\tif (!ref_function_name_length) {\n\t\t\t// not sure why it's not read_multiple_bytes() in the first place\n\t\t\tref_function_name_length = read_multiple_bytes (b); // XXX might be read_max_2_bytes, need more data\n\t\t\tif (buf_eof || buf_err) {\n\t\t\t\tgoto err_exit;\n\t\t\t}\n\t\t}\n\t\tif ((int) ref_function_name_length < 0) {\n\t\t\tgoto err_exit;\n\t\t}\n\t\tfor (j = 0; j < ref_function_name_length; j++) {\n\t\t\tref_function->name[j] = read_byte (b);\n\t\t\tif (buf_eof || buf_err) {\n\t\t\t\tgoto err_exit;\n\t\t\t}\n\t\t}\n\t\tif (!ref_function->name[ref_function_name_length]) {\n\t\t\t// if the last byte of the name is 0, it means the offset is negative\n\t\t\tref_function->negative_offset = true;\n\t\t} else {\n\t\t\tref_function->name[ref_function_name_length] = '\\0';\n\t\t}\n\t\tr_list_append (module->referenced_functions, ref_function);\n#if DEBUG\n\t\teprintf (\"(REF: %04X: %s)\\n\", ref_function->offset, ref_function->name);\n#endif\n\t}\n\n\treturn true;\n\nerr_exit:\n\tfree (ref_function);\n\treturn false;\n}",
  "abstract_func_before": "static ut8 read_module_referenced_functions(RFlirtModule *VAR_0, RBuffer *VAR_1) {\n\t/* COMMENT_0 */\n\t/* COMMENT_1 */\n\tint VAR_2, VAR_3;\n\tut8 VAR_4;\n\tut32 VAR_5;\n\tRFlirtFunction *VAR_6 = NULL;\n\n\tVAR_0->referenced_functions = r_list_new ();\n\n\tif (VAR_7 >= 8) { /* COMMENT_2 */\n\t\tVAR_4 = read_byte (VAR_1); /* COMMENT_3 */\n\t\tif (VAR_8 || VAR_9) {\n\t\t\tgoto err_exit;\n\t\t}\n\t} else { /* COMMENT_4 */\n\t\tVAR_4 = 1;\n\t}\n\n\tfor (VAR_2 = 0; VAR_2 < VAR_4; VAR_2++) {\n\t\tVAR_6 = R_NEW0 (RFlirtFunction);\n\t\tif (!VAR_6) {\n\t\t\tgoto err_exit;\n\t\t}\n\t\tif (VAR_7 >= 9) {\n\t\t\tVAR_6->offset = read_multiple_bytes (VAR_1);\n\t\t\tif (VAR_8 || VAR_9) {\n\t\t\t\tgoto err_exit;\n\t\t\t}\n\t\t} else {\n\t\t\tVAR_6->offset = read_max_2_bytes (VAR_1);\n\t\t\tif (VAR_8 || VAR_9) {\n\t\t\t\tgoto err_exit;\n\t\t\t}\n\t\t}\n\t\tVAR_5 = read_byte (VAR_1);\n\t\tif (VAR_8 || VAR_9) {\n\t\t\tgoto err_exit;\n\t\t}\n\t\tif (!VAR_5) {\n\t\t\t/* COMMENT_5 */\n\t\t\tVAR_5 = read_multiple_bytes (VAR_1); /* COMMENT_6 */\n\t\t\tif (VAR_8 || VAR_9) {\n\t\t\t\tgoto err_exit;\n\t\t\t}\n\t\t}\n\t\tif ((int) VAR_5 < 0) {\n\t\t\tgoto err_exit;\n\t\t}\n\t\tfor (VAR_3 = 0; VAR_3 < VAR_5; VAR_3++) {\n\t\t\tVAR_6->name[VAR_3] = read_byte (VAR_1);\n\t\t\tif (VAR_8 || VAR_9) {\n\t\t\t\tgoto err_exit;\n\t\t\t}\n\t\t}\n\t\tif (!VAR_6->name[VAR_5]) {\n\t\t\t/* COMMENT_7 */\n\t\t\tVAR_6->negative_offset = true;\n\t\t} else {\n\t\t\tVAR_6->name[VAR_5] = '\\0';\n\t\t}\n\t\tr_list_append (VAR_0->referenced_functions, VAR_6);\n#if VAR_10\n\t\teprintf (\"(REF: %04X: %s)\\n\", VAR_6->offset, VAR_6->name);\n#endif\n\t}\n\n\treturn true;\n\nerr_exit:\n\tfree (VAR_6);\n\treturn false;\n}",
  "func_graph_path_before": "radareorg/radare2/ee1727f272d69d904cc84e4d368ece8c260f5ead/flirt.c/vul/before/0.json",
  "func": "static ut8 read_module_referenced_functions(RFlirtModule *module, RBuffer *b) {\n\t/*parses a module referenced functions*/\n\t/*returns false on parsing error*/\n\tint i, j;\n\tut8 number_of_referenced_functions;\n\tut32 ref_function_name_length;\n\tRFlirtFunction *ref_function = NULL;\n\n\tmodule->referenced_functions = r_list_new ();\n\n\tif (version >= 8) { // this counter was introduced in version 8\n\t\tnumber_of_referenced_functions = read_byte (b); // XXX are we sure it's not read_multiple_bytes?\n\t\tif (buf_eof || buf_err) {\n\t\t\tgoto err_exit;\n\t\t}\n\t} else { // suppose there's only one\n\t\tnumber_of_referenced_functions = 1;\n\t}\n\n\tfor (i = 0; i < number_of_referenced_functions; i++) {\n\t\tref_function = R_NEW0 (RFlirtFunction);\n\t\tif (!ref_function) {\n\t\t\tgoto err_exit;\n\t\t}\n\t\tif (version >= 9) {\n\t\t\tref_function->offset = read_multiple_bytes (b);\n\t\t\tif (buf_eof || buf_err) {\n\t\t\t\tgoto err_exit;\n\t\t\t}\n\t\t} else {\n\t\t\tref_function->offset = read_max_2_bytes (b);\n\t\t\tif (buf_eof || buf_err) {\n\t\t\t\tgoto err_exit;\n\t\t\t}\n\t\t}\n\t\tref_function_name_length = read_byte (b);\n\t\tif (buf_eof || buf_err) {\n\t\t\tgoto err_exit;\n\t\t}\n\t\tif (!ref_function_name_length) {\n\t\t\t// not sure why it's not read_multiple_bytes() in the first place\n\t\t\tref_function_name_length = read_multiple_bytes (b); // XXX might be read_max_2_bytes, need more data\n\t\t\tif (buf_eof || buf_err) {\n\t\t\t\tgoto err_exit;\n\t\t\t}\n\t\t}\n\t\tif ((int) ref_function_name_length < 0 || ref_function_name_length > R_FLIRT_NAME_MAX) {\n\t\t\tgoto err_exit;\n\t\t}\n\t\tfor (j = 0; j < ref_function_name_length; j++) {\n\t\t\tref_function->name[j] = read_byte (b);\n\t\t\tif (buf_eof || buf_err) {\n\t\t\t\tgoto err_exit;\n\t\t\t}\n\t\t}\n\t\tif (!ref_function->name[ref_function_name_length]) {\n\t\t\t// if the last byte of the name is 0, it means the offset is negative\n\t\t\tref_function->negative_offset = true;\n\t\t} else {\n\t\t\tref_function->name[ref_function_name_length] = '\\0';\n\t\t}\n\t\tr_list_append (module->referenced_functions, ref_function);\n#if DEBUG\n\t\teprintf (\"(REF: %04X: %s)\\n\", ref_function->offset, ref_function->name);\n#endif\n\t}\n\n\treturn true;\n\nerr_exit:\n\tfree (ref_function);\n\treturn false;\n}",
  "abstract_func": "static ut8 read_module_referenced_functions(RFlirtModule *VAR_0, RBuffer *VAR_1) {\n\t/* COMMENT_0 */\n\t/* COMMENT_1 */\n\tint VAR_2, VAR_3;\n\tut8 VAR_4;\n\tut32 VAR_5;\n\tRFlirtFunction *VAR_6 = NULL;\n\n\tVAR_0->referenced_functions = r_list_new ();\n\n\tif (VAR_7 >= 8) { /* COMMENT_2 */\n\t\tVAR_4 = read_byte (VAR_1); /* COMMENT_3 */\n\t\tif (VAR_8 || VAR_9) {\n\t\t\tgoto err_exit;\n\t\t}\n\t} else { /* COMMENT_4 */\n\t\tVAR_4 = 1;\n\t}\n\n\tfor (VAR_2 = 0; VAR_2 < VAR_4; VAR_2++) {\n\t\tVAR_6 = R_NEW0 (RFlirtFunction);\n\t\tif (!VAR_6) {\n\t\t\tgoto err_exit;\n\t\t}\n\t\tif (VAR_7 >= 9) {\n\t\t\tVAR_6->offset = read_multiple_bytes (VAR_1);\n\t\t\tif (VAR_8 || VAR_9) {\n\t\t\t\tgoto err_exit;\n\t\t\t}\n\t\t} else {\n\t\t\tVAR_6->offset = read_max_2_bytes (VAR_1);\n\t\t\tif (VAR_8 || VAR_9) {\n\t\t\t\tgoto err_exit;\n\t\t\t}\n\t\t}\n\t\tVAR_5 = read_byte (VAR_1);\n\t\tif (VAR_8 || VAR_9) {\n\t\t\tgoto err_exit;\n\t\t}\n\t\tif (!VAR_5) {\n\t\t\t/* COMMENT_5 */\n\t\t\tVAR_5 = read_multiple_bytes (VAR_1); /* COMMENT_6 */\n\t\t\tif (VAR_8 || VAR_9) {\n\t\t\t\tgoto err_exit;\n\t\t\t}\n\t\t}\n\t\tif ((int) VAR_5 < 0 || VAR_5 > VAR_10) {\n\t\t\tgoto err_exit;\n\t\t}\n\t\tfor (VAR_3 = 0; VAR_3 < VAR_5; VAR_3++) {\n\t\t\tVAR_6->name[VAR_3] = read_byte (VAR_1);\n\t\t\tif (VAR_8 || VAR_9) {\n\t\t\t\tgoto err_exit;\n\t\t\t}\n\t\t}\n\t\tif (!VAR_6->name[VAR_5]) {\n\t\t\t/* COMMENT_7 */\n\t\t\tVAR_6->negative_offset = true;\n\t\t} else {\n\t\t\tVAR_6->name[VAR_5] = '\\0';\n\t\t}\n\t\tr_list_append (VAR_0->referenced_functions, VAR_6);\n#if VAR_11\n\t\teprintf (\"(REF: %04X: %s)\\n\", VAR_6->offset, VAR_6->name);\n#endif\n\t}\n\n\treturn true;\n\nerr_exit:\n\tfree (VAR_6);\n\treturn false;\n}",
  "func_graph_path": "radareorg/radare2/ee1727f272d69d904cc84e4d368ece8c260f5ead/flirt.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -44,7 +44,7 @@\n \t\t\t\tgoto err_exit;\n \t\t\t}\n \t\t}\n-\t\tif ((int) ref_function_name_length < 0) {\n+\t\tif ((int) ref_function_name_length < 0 || ref_function_name_length > R_FLIRT_NAME_MAX) {\n \t\t\tgoto err_exit;\n \t\t}\n \t\tfor (j = 0; j < ref_function_name_length; j++) {",
  "diff_line_info": {
    "deleted_lines": [
      "\t\tif ((int) ref_function_name_length < 0) {"
    ],
    "added_lines": [
      "\t\tif ((int) ref_function_name_length < 0 || ref_function_name_length > R_FLIRT_NAME_MAX) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/radareorg/radare2/pull/11300",
  "description": {
    "pr_info": {
      "title": "fix #11274 attempt.",
      "number": 11300
    },
    "comment": [
      "basically with the given name function section size\r\nwas way above, we consider as faulty even though\r\nthe sample sig file seems legit ?",
      "this was assigned the CVE ID: `CVE-2018-15834`"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix\n\nConfidence Score: 0.9",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch modifies a function to add an upper bound check on a variable, preventing potential buffer overflow issues. This addresses a security concern by ensuring data doesn't exceed safe limits.\n\nFinal Classification: Security Vulnerability Fix\n\nConfidence Score: 0.9"
}