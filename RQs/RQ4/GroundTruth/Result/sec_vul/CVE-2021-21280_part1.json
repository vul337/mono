{
  "cve_id": "CVE-2021-21280",
  "cwe_ids": [
    "CWE-787"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "contiki-ng",
  "commit_msg": "Check that there is enough room in the buffer to write an external header.",
  "commit_hash": "b88e5c303db21578799e5083bda9580922dc17b4",
  "git_url": "https://github.com/contiki-ng/contiki-ng/commit/b88e5c303db21578799e5083bda9580922dc17b4",
  "file_path": "os/net/ipv6/sicslowpan.c",
  "func_name": "input",
  "func_before": "static void\ninput(void)\n{\n  /* size of the IP packet (read from fragment) */\n  uint16_t frag_size = 0;\n  /* offset of the fragment in the IP packet */\n  uint8_t frag_offset = 0;\n  uint8_t *buffer;\n\n#if SICSLOWPAN_CONF_FRAG\n  uint8_t is_fragment = 0;\n  int8_t frag_context = 0;\n\n  /* tag of the fragment */\n  uint16_t frag_tag = 0;\n  uint8_t first_fragment = 0, last_fragment = 0;\n#endif /*SICSLOWPAN_CONF_FRAG*/\n\n  /* Update link statistics */\n  link_stats_input_callback(packetbuf_addr(PACKETBUF_ADDR_SENDER));\n\n  /* init */\n  uncomp_hdr_len = 0;\n  packetbuf_hdr_len = 0;\n\n  /* The MAC puts the 15.4 payload inside the packetbuf data buffer */\n  packetbuf_ptr = packetbuf_dataptr();\n\n  if(packetbuf_datalen() == 0) {\n    LOG_WARN(\"input: empty packet\\n\");\n    return;\n  }\n\n  /* Clear uipbuf and set default attributes */\n  uipbuf_clear();\n\n  /* This is default uip_buf since we assume that this is not fragmented */\n  buffer = (uint8_t *)UIP_IP_BUF;\n\n  /* Save the RSSI of the incoming packet in case the upper layer will\n     want to query us for it later. */\n  last_rssi = (signed short)packetbuf_attr(PACKETBUF_ATTR_RSSI);\n\n#if SICSLOWPAN_CONF_FRAG\n\n  /*\n   * Since we don't support the mesh and broadcast header, the first header\n   * we look for is the fragmentation header\n   */\n  switch((GET16(PACKETBUF_FRAG_PTR, PACKETBUF_FRAG_DISPATCH_SIZE) >> 8) & SICSLOWPAN_DISPATCH_FRAG_MASK) {\n    case SICSLOWPAN_DISPATCH_FRAG1:\n      frag_offset = 0;\n      frag_size = GET16(PACKETBUF_FRAG_PTR, PACKETBUF_FRAG_DISPATCH_SIZE) & 0x07ff;\n      frag_tag = GET16(PACKETBUF_FRAG_PTR, PACKETBUF_FRAG_TAG);\n      packetbuf_hdr_len += SICSLOWPAN_FRAG1_HDR_LEN;\n      first_fragment = 1;\n      is_fragment = 1;\n\n      LOG_INFO(\"input: received first element of a fragmented packet (tag %d, len %d)\\n\",\n             frag_tag, frag_size);\n\n      /* Add the fragment to the fragmentation context */\n      frag_context = add_fragment(frag_tag, frag_size, frag_offset);\n\n      if(frag_context == -1) {\n        LOG_ERR(\"input: failed to allocate new reassembly context\\n\");\n        return;\n      }\n\n      buffer = frag_info[frag_context].first_frag;\n      break;\n    case SICSLOWPAN_DISPATCH_FRAGN:\n      /*\n       * set offset, tag, size\n       * Offset is in units of 8 bytes\n       */\n      frag_offset = PACKETBUF_FRAG_PTR[PACKETBUF_FRAG_OFFSET];\n      frag_tag = GET16(PACKETBUF_FRAG_PTR, PACKETBUF_FRAG_TAG);\n      frag_size = GET16(PACKETBUF_FRAG_PTR, PACKETBUF_FRAG_DISPATCH_SIZE) & 0x07ff;\n      packetbuf_hdr_len += SICSLOWPAN_FRAGN_HDR_LEN;\n\n      /* Add the fragment to the fragmentation context (this will also\n         copy the payload) */\n      frag_context = add_fragment(frag_tag, frag_size, frag_offset);\n\n      if(frag_context == -1) {\n        LOG_ERR(\"input: reassembly context not found (tag %d)\\n\", frag_tag);\n        return;\n      }\n\n      /* Ok - add_fragment will store the fragment automatically - so\n         we should not store more */\n      buffer = NULL;\n\n      if(frag_info[frag_context].reassembled_len >= frag_size) {\n        last_fragment = 1;\n      }\n      is_fragment = 1;\n      break;\n    default:\n      break;\n  }\n\n  if(is_fragment && !first_fragment) {\n    /* this is a FRAGN, skip the header compression dispatch section */\n    goto copypayload;\n  }\n#endif /* SICSLOWPAN_CONF_FRAG */\n\n  /* First, process 6LoRH headers */\n  curr_page = 0;\n  digest_paging_dispatch();\n  if(curr_page == 1) {\n    LOG_INFO(\"input: page 1, 6LoRH\\n\");\n    digest_6lorh_hdr();\n  } else if (curr_page > 1) {\n    LOG_ERR(\"input: page %u not supported\\n\", curr_page);\n    return;\n  }\n\n  /* Process next dispatch and headers */\n  if(SICSLOWPAN_COMPRESSION > SICSLOWPAN_COMPRESSION_IPV6 &&\n     (PACKETBUF_6LO_PTR[PACKETBUF_6LO_DISPATCH] & SICSLOWPAN_DISPATCH_IPHC_MASK) == SICSLOWPAN_DISPATCH_IPHC) {\n    LOG_DBG(\"uncompression: IPHC dispatch\\n\");\n    uncompress_hdr_iphc(buffer, frag_size);\n  } else if(PACKETBUF_6LO_PTR[PACKETBUF_6LO_DISPATCH] == SICSLOWPAN_DISPATCH_IPV6) {\n    LOG_DBG(\"uncompression: IPV6 dispatch\\n\");\n    packetbuf_hdr_len += SICSLOWPAN_IPV6_HDR_LEN;\n\n    /* Put uncompressed IP header in sicslowpan_buf. */\n    memcpy(buffer, packetbuf_ptr + packetbuf_hdr_len, UIP_IPH_LEN);\n\n    /* Update uncomp_hdr_len and packetbuf_hdr_len. */\n    packetbuf_hdr_len += UIP_IPH_LEN;\n    uncomp_hdr_len += UIP_IPH_LEN;\n  } else {\n    LOG_ERR(\"uncompression: unknown dispatch: 0x%02x, or IPHC disabled\\n\",\n             PACKETBUF_6LO_PTR[PACKETBUF_6LO_DISPATCH] & SICSLOWPAN_DISPATCH_IPHC_MASK);\n    return;\n  }\n\n#if SICSLOWPAN_CONF_FRAG\n copypayload:\n#endif /*SICSLOWPAN_CONF_FRAG*/\n  /*\n   * copy \"payload\" from the packetbuf buffer to the sicslowpan_buf\n   * if this is a first fragment or not fragmented packet,\n   * we have already copied the compressed headers, uncomp_hdr_len\n   * and packetbuf_hdr_len are non 0, frag_offset is.\n   * If this is a subsequent fragment, this is the contrary.\n   */\n  if(packetbuf_datalen() < packetbuf_hdr_len) {\n    LOG_ERR(\"input: packet dropped due to header > total packet\\n\");\n    return;\n  }\n  packetbuf_payload_len = packetbuf_datalen() - packetbuf_hdr_len;\n\n#if SICSLOWPAN_CONF_FRAG\n  if(is_fragment) {\n    LOG_INFO(\"input: fragment (tag %d, payload %d, offset %d) -- %u %u\\n\",\n         frag_tag, packetbuf_payload_len, frag_offset << 3, packetbuf_datalen(), packetbuf_hdr_len);\n  }\n#endif /*SICSLOWPAN_CONF_FRAG*/\n\n  /* Sanity-check size of incoming packet to avoid buffer overflow */\n  {\n    int req_size = uncomp_hdr_len + (uint16_t)(frag_offset << 3)\n        + packetbuf_payload_len;\n    if(req_size > sizeof(uip_buf)) {\n#if SICSLOWPAN_CONF_FRAG\n      LOG_ERR(\n          \"input: packet and fragment context %u dropped, minimum required IP_BUF size: %d+%d+%d=%d (current size: %u)\\n\",\n          frag_context,\n          uncomp_hdr_len, (uint16_t)(frag_offset << 3),\n          packetbuf_payload_len, req_size, (unsigned)sizeof(uip_buf));\n      /* Discard all fragments for this contex, as reassembling this particular fragment would\n       * cause an overflow in uipbuf */\n      clear_fragments(frag_context);\n#endif /* SICSLOWPAN_CONF_FRAG */\n      return;\n    }\n  }\n\n  /* copy the payload if buffer is non-null - which is only the case with first fragment\n     or packets that are non fragmented */\n  if(buffer != NULL) {\n    memcpy((uint8_t *)buffer + uncomp_hdr_len, packetbuf_ptr + packetbuf_hdr_len, packetbuf_payload_len);\n  }\n\n  /* update processed_ip_in_len if fragment, sicslowpan_len otherwise */\n\n#if SICSLOWPAN_CONF_FRAG\n  if(frag_size > 0) {\n    /* Add the size of the header only for the first fragment. */\n    if(first_fragment != 0) {\n      frag_info[frag_context].reassembled_len = uncomp_hdr_len + packetbuf_payload_len;\n      frag_info[frag_context].first_frag_len = uncomp_hdr_len + packetbuf_payload_len;\n    }\n    /* For the last fragment, we are OK if there is extrenous bytes at\n       the end of the packet. */\n    if(last_fragment != 0) {\n      frag_info[frag_context].reassembled_len = frag_size;\n      /* copy to uip */\n      if(!copy_frags2uip(frag_context)) {\n        return;\n      }\n    }\n  }\n\n  /*\n   * If we have a full IP packet in sicslowpan_buf, deliver it to\n   * the IP stack\n   */\n  if(!is_fragment || last_fragment) {\n    /* packet is in uip already - just set length */\n    if(is_fragment != 0 && last_fragment != 0) {\n      uip_len = frag_size;\n    } else {\n      uip_len = packetbuf_payload_len + uncomp_hdr_len;\n    }\n#else\n    uip_len = packetbuf_payload_len + uncomp_hdr_len;\n#endif /* SICSLOWPAN_CONF_FRAG */\n    LOG_INFO(\"input: received IPv6 packet with len %d\\n\",\n             uip_len);\n\n    if(LOG_DBG_ENABLED) {\n      uint16_t ndx;\n      LOG_DBG(\"uncompression: after (%u):\", UIP_IP_BUF->len[1]);\n      for (ndx = 0; ndx < UIP_IP_BUF->len[1] + 40; ndx++) {\n        uint8_t data = ((uint8_t *) (UIP_IP_BUF))[ndx];\n        LOG_DBG_(\"%02x\", data);\n      }\n      LOG_DBG_(\"\\n\");\n    }\n\n    /* if callback is set then set attributes and call */\n    if(callback) {\n      set_packet_attrs();\n      callback->input_callback();\n    }\n\n#if LLSEC802154_USES_AUX_HEADER\n    /*\n     * Assuming that the last packet in packetbuf is containing\n     *  the LLSEC state so that it can be copied to uipbuf.\n     */\n    uipbuf_set_attr(UIPBUF_ATTR_LLSEC_LEVEL,\n      packetbuf_attr(PACKETBUF_ATTR_SECURITY_LEVEL));\n#if LLSEC802154_USES_EXPLICIT_KEYS\n    uipbuf_set_attr(UIPBUF_ATTR_LLSEC_KEY_ID,\n      packetbuf_attr(PACKETBUF_ATTR_KEY_INDEX));\n#endif /* LLSEC802154_USES_EXPLICIT_KEYS */\n#endif /*  LLSEC802154_USES_AUX_HEADER */\n\n    tcpip_input();\n#if SICSLOWPAN_CONF_FRAG\n  }\n#endif /* SICSLOWPAN_CONF_FRAG */\n}",
  "abstract_func_before": "static void\ninput(void)\n{\n  /* COMMENT_0 */\n  uint16_t VAR_0 = 0;\n  /* COMMENT_1 */\n  uint8_t VAR_1 = 0;\n  uint8_t *VAR_2;\n\n#if VAR_3\n  uint8_t VAR_4 = 0;\n  int8_t VAR_5 = 0;\n\n  /* COMMENT_2 */\n  uint16_t VAR_6 = 0;\n  uint8_t VAR_7 = 0, VAR_8 = 0;\n#endif /* COMMENT_3 */\n\n  /* COMMENT_4 */\n  link_stats_input_callback(packetbuf_addr(VAR_9));\n\n  /* COMMENT_5 */\n  VAR_10 = 0;\n  VAR_11 = 0;\n\n  /* COMMENT_6 */\n  VAR_12 = packetbuf_dataptr();\n\n  if(packetbuf_datalen() == 0) {\n    LOG_WARN(\"input: empty packet\\n\");\n    return;\n  }\n\n  /* COMMENT_7 */\n  uipbuf_clear();\n\n  /* COMMENT_8 */\n  VAR_2 = (uint8_t *)VAR_13;\n\n  /* COMMENT_9 */\n                                      \n  VAR_14 = (signed short)packetbuf_attr(VAR_15);\n\n#if VAR_3\n\n  /* COMMENT_11 */\n                                                                           \n                                            \n     \n  switch((GET16(VAR_16, VAR_17) >> 8) & VAR_18) {\n    case VAR_19:\n      VAR_1 = 0;\n      VAR_0 = GET16(VAR_16, VAR_17) & 0x07ff;\n      VAR_6 = GET16(VAR_16, VAR_20);\n      VAR_11 += VAR_21;\n      VAR_7 = 1;\n      VAR_4 = 1;\n\n      LOG_INFO(\"input: received first element of a fragmented packet (tag %d, len %d)\\n\",\n             VAR_6, VAR_0);\n\n      /* COMMENT_15 */\n      VAR_5 = add_fragment(VAR_6, VAR_0, VAR_1);\n\n      if(VAR_5 == -1) {\n        LOG_ERR(\"input: failed to allocate new reassembly context\\n\");\n        return;\n      }\n\n      VAR_2 = VAR_22[VAR_5].first_frag;\n      break;\n    case VAR_23:\n      /* COMMENT_16 */\n                              \n                                      \n         \n      VAR_1 = VAR_16[VAR_24];\n      VAR_6 = GET16(VAR_16, VAR_20);\n      VAR_0 = GET16(VAR_16, VAR_17) & 0x07ff;\n      VAR_11 += VAR_25;\n\n      /* COMMENT_20 */\n                             \n      VAR_5 = add_fragment(VAR_6, VAR_0, VAR_1);\n\n      if(VAR_5 == -1) {\n        LOG_ERR(\"input: reassembly context not found (tag %d)\\n\", VAR_6);\n        return;\n      }\n\n      /* COMMENT_22 */\n                                    \n      VAR_2 = NULL;\n\n      if(VAR_22[VAR_5].reassembled_len >= VAR_0) {\n        VAR_8 = 1;\n      }\n      VAR_4 = 1;\n      break;\n    default:\n      break;\n  }\n\n  if(VAR_4 && !VAR_7) {\n    /* COMMENT_24 */\n    goto copypayload;\n  }\n#endif /* COMMENT_25 */\n\n  /* COMMENT_26 */\n  VAR_26 = 0;\n  digest_paging_dispatch();\n  if(VAR_26 == 1) {\n    LOG_INFO(\"input: page 1, 6LoRH\\n\");\n    digest_6lorh_hdr();\n  } else if (VAR_26 > 1) {\n    LOG_ERR(\"input: page %u not supported\\n\", VAR_26);\n    return;\n  }\n\n  /* COMMENT_27 */\n  if(VAR_27 > VAR_28 &&\n     (VAR_29[VAR_30] & VAR_31) == VAR_32) {\n    LOG_DBG(\"uncompression: IPHC dispatch\\n\");\n    uncompress_hdr_iphc(VAR_2, VAR_0);\n  } else if(VAR_29[VAR_30] == VAR_33) {\n    LOG_DBG(\"uncompression: IPV6 dispatch\\n\");\n    VAR_11 += VAR_34;\n\n    /* COMMENT_28 */\n    memcpy(VAR_2, VAR_12 + VAR_11, VAR_35);\n\n    /* COMMENT_29 */\n    VAR_11 += VAR_35;\n    VAR_10 += VAR_35;\n  } else {\n    LOG_ERR(\"uncompression: unknown dispatch: 0x%02x, or IPHC disabled\\n\",\n             VAR_29[VAR_30] & VAR_31);\n    return;\n  }\n\n#if VAR_3\n copypayload:\n#endif /* COMMENT_3 */\n  /* COMMENT_30 */\n                                                                   \n                                                          \n                                                                  \n                                                     \n                                                            \n     \n  if(packetbuf_datalen() < VAR_11) {\n    LOG_ERR(\"input: packet dropped due to header > total packet\\n\");\n    return;\n  }\n  VAR_36 = packetbuf_datalen() - VAR_11;\n\n#if VAR_3\n  if(VAR_4) {\n    LOG_INFO(\"input: fragment (tag %d, payload %d, offset %d) -- %u %u\\n\",\n         VAR_6, VAR_36, VAR_1 << 3, packetbuf_datalen(), VAR_11);\n  }\n#endif /* COMMENT_3 */\n\n  /* COMMENT_37 */\n  {\n    int VAR_37 = VAR_10 + (uint16_t)(VAR_1 << 3)\n        + VAR_36;\n    if(VAR_37 > sizeof(VAR_38)) {\n#if VAR_3\n      LOG_ERR(\n          \"input: packet and fragment context %u dropped, minimum required IP_BUF size: %d+%d+%d=%d (current size: %u)\\n\",\n          VAR_5,\n          VAR_10, (uint16_t)(VAR_1 << 3),\n          VAR_36, VAR_37, (unsigned)sizeof(VAR_38));\n      /* COMMENT_38 */\n                                       \n      clear_fragments(VAR_5);\n#endif /* COMMENT_25 */\n      return;\n    }\n  }\n\n  /* COMMENT_40 */\n                                          \n  if(VAR_2 != NULL) {\n    memcpy((uint8_t *)VAR_2 + VAR_10, VAR_12 + VAR_11, VAR_36);\n  }\n\n  /* COMMENT_42 */\n\n#if VAR_3\n  if(VAR_0 > 0) {\n    /* COMMENT_43 */\n    if(VAR_7 != 0) {\n      VAR_22[VAR_5].reassembled_len = VAR_10 + VAR_36;\n      VAR_22[VAR_5].first_frag_len = VAR_10 + VAR_36;\n    }\n    /* COMMENT_44 */\n                                \n    if(VAR_8 != 0) {\n      VAR_22[VAR_5].reassembled_len = VAR_0;\n      /* COMMENT_46 */\n      if(!copy_frags2uip(VAR_5)) {\n        return;\n      }\n    }\n  }\n\n  /* COMMENT_47 */\n                                                                 \n                 \n     \n  if(!VAR_4 || VAR_8) {\n    /* COMMENT_51 */\n    if(VAR_4 != 0 && VAR_8 != 0) {\n      VAR_39 = VAR_0;\n    } else {\n      VAR_39 = VAR_36 + VAR_10;\n    }\n#else\n    uip_len = packetbuf_payload_len + uncomp_hdr_len;\n#endif/* COMMENT_52 */\n    LOG_INFO(\"input: received IPv6 packet with len %d\\n\",\n             VAR_39);\n\n    if(VAR_40) {\n      uint16_t VAR_41;\n      LOG_DBG(\"uncompression: after (%u):\", VAR_13->len[1]);\n      for (VAR_41 = 0; VAR_41 < VAR_13->len[1] + 40; VAR_41++) {\n        uint8_t VAR_42 = ((uint8_t *) (VAR_13))[VAR_41];\n        LOG_DBG_(\"%02x\", VAR_42);\n      }\n      LOG_DBG_(\"\\n\");\n    }\n\n    /* COMMENT_53 */\n    if(VAR_43) {\n      set_packet_attrs();\n      VAR_43->input_callback();\n    }\n\n#if VAR_44\n    /* COMMENT_54 */\n                                                               \n                                                           \n       \n    uipbuf_set_attr(VAR_45,\n      packetbuf_attr(VAR_46));\n#if VAR_47\n    uipbuf_set_attr(VAR_48,\n      packetbuf_attr(VAR_49));\n#endif /* COMMENT_58 */\n#endif /* COMMENT_59 */\n\n    tcpip_input();\n#if VAR_3\n  }\n#endif /* COMMENT_25 */\n}",
  "func_graph_path_before": "contiki-ng/b88e5c303db21578799e5083bda9580922dc17b4/sicslowpan.c/vul/before/0.json",
  "func": "static void\ninput(void)\n{\n  /* size of the IP packet (read from fragment) */\n  uint16_t frag_size = 0;\n  /* offset of the fragment in the IP packet */\n  uint8_t frag_offset = 0;\n  uint8_t *buffer;\n  uint16_t buffer_size;\n\n#if SICSLOWPAN_CONF_FRAG\n  uint8_t is_fragment = 0;\n  int8_t frag_context = 0;\n\n  /* tag of the fragment */\n  uint16_t frag_tag = 0;\n  uint8_t first_fragment = 0, last_fragment = 0;\n#endif /*SICSLOWPAN_CONF_FRAG*/\n\n  /* Update link statistics */\n  link_stats_input_callback(packetbuf_addr(PACKETBUF_ADDR_SENDER));\n\n  /* init */\n  uncomp_hdr_len = 0;\n  packetbuf_hdr_len = 0;\n\n  /* The MAC puts the 15.4 payload inside the packetbuf data buffer */\n  packetbuf_ptr = packetbuf_dataptr();\n\n  if(packetbuf_datalen() == 0) {\n    LOG_WARN(\"input: empty packet\\n\");\n    return;\n  }\n\n  /* Clear uipbuf and set default attributes */\n  uipbuf_clear();\n\n  /* This is default uip_buf since we assume that this is not fragmented */\n  buffer = (uint8_t *)UIP_IP_BUF;\n  buffer_size = UIP_BUFSIZE;\n\n  /* Save the RSSI of the incoming packet in case the upper layer will\n     want to query us for it later. */\n  last_rssi = (signed short)packetbuf_attr(PACKETBUF_ATTR_RSSI);\n\n#if SICSLOWPAN_CONF_FRAG\n\n  /*\n   * Since we don't support the mesh and broadcast header, the first header\n   * we look for is the fragmentation header\n   */\n  switch((GET16(PACKETBUF_FRAG_PTR, PACKETBUF_FRAG_DISPATCH_SIZE) >> 8) & SICSLOWPAN_DISPATCH_FRAG_MASK) {\n    case SICSLOWPAN_DISPATCH_FRAG1:\n      frag_offset = 0;\n      frag_size = GET16(PACKETBUF_FRAG_PTR, PACKETBUF_FRAG_DISPATCH_SIZE) & 0x07ff;\n      frag_tag = GET16(PACKETBUF_FRAG_PTR, PACKETBUF_FRAG_TAG);\n      packetbuf_hdr_len += SICSLOWPAN_FRAG1_HDR_LEN;\n      first_fragment = 1;\n      is_fragment = 1;\n\n      LOG_INFO(\"input: received first element of a fragmented packet (tag %d, len %d)\\n\",\n             frag_tag, frag_size);\n\n      /* Add the fragment to the fragmentation context */\n      frag_context = add_fragment(frag_tag, frag_size, frag_offset);\n\n      if(frag_context == -1) {\n        LOG_ERR(\"input: failed to allocate new reassembly context\\n\");\n        return;\n      }\n\n      buffer = frag_info[frag_context].first_frag;\n      buffer_size = SICSLOWPAN_FIRST_FRAGMENT_SIZE;\n      break;\n    case SICSLOWPAN_DISPATCH_FRAGN:\n      /*\n       * set offset, tag, size\n       * Offset is in units of 8 bytes\n       */\n      frag_offset = PACKETBUF_FRAG_PTR[PACKETBUF_FRAG_OFFSET];\n      frag_tag = GET16(PACKETBUF_FRAG_PTR, PACKETBUF_FRAG_TAG);\n      frag_size = GET16(PACKETBUF_FRAG_PTR, PACKETBUF_FRAG_DISPATCH_SIZE) & 0x07ff;\n      packetbuf_hdr_len += SICSLOWPAN_FRAGN_HDR_LEN;\n\n      /* Add the fragment to the fragmentation context (this will also\n         copy the payload) */\n      frag_context = add_fragment(frag_tag, frag_size, frag_offset);\n\n      if(frag_context == -1) {\n        LOG_ERR(\"input: reassembly context not found (tag %d)\\n\", frag_tag);\n        return;\n      }\n\n      /* Ok - add_fragment will store the fragment automatically - so\n         we should not store more */\n      buffer = NULL;\n\n      if(frag_info[frag_context].reassembled_len >= frag_size) {\n        last_fragment = 1;\n      }\n      is_fragment = 1;\n      break;\n    default:\n      break;\n  }\n\n  if(is_fragment && !first_fragment) {\n    /* this is a FRAGN, skip the header compression dispatch section */\n    goto copypayload;\n  }\n#endif /* SICSLOWPAN_CONF_FRAG */\n\n  /* First, process 6LoRH headers */\n  curr_page = 0;\n  digest_paging_dispatch();\n  if(curr_page == 1) {\n    LOG_INFO(\"input: page 1, 6LoRH\\n\");\n    digest_6lorh_hdr();\n  } else if (curr_page > 1) {\n    LOG_ERR(\"input: page %u not supported\\n\", curr_page);\n    return;\n  }\n\n  /* Process next dispatch and headers */\n  if(SICSLOWPAN_COMPRESSION > SICSLOWPAN_COMPRESSION_IPV6 &&\n     (PACKETBUF_6LO_PTR[PACKETBUF_6LO_DISPATCH] & SICSLOWPAN_DISPATCH_IPHC_MASK) == SICSLOWPAN_DISPATCH_IPHC) {\n    LOG_DBG(\"uncompression: IPHC dispatch\\n\");\n    uncompress_hdr_iphc(buffer, buffer_size, frag_size);\n  } else if(PACKETBUF_6LO_PTR[PACKETBUF_6LO_DISPATCH] == SICSLOWPAN_DISPATCH_IPV6) {\n    LOG_DBG(\"uncompression: IPV6 dispatch\\n\");\n    packetbuf_hdr_len += SICSLOWPAN_IPV6_HDR_LEN;\n\n    /* Put uncompressed IP header in sicslowpan_buf. */\n    memcpy(buffer, packetbuf_ptr + packetbuf_hdr_len, UIP_IPH_LEN);\n\n    /* Update uncomp_hdr_len and packetbuf_hdr_len. */\n    packetbuf_hdr_len += UIP_IPH_LEN;\n    uncomp_hdr_len += UIP_IPH_LEN;\n  } else {\n    LOG_ERR(\"uncompression: unknown dispatch: 0x%02x, or IPHC disabled\\n\",\n             PACKETBUF_6LO_PTR[PACKETBUF_6LO_DISPATCH] & SICSLOWPAN_DISPATCH_IPHC_MASK);\n    return;\n  }\n\n#if SICSLOWPAN_CONF_FRAG\n copypayload:\n#endif /*SICSLOWPAN_CONF_FRAG*/\n  /*\n   * copy \"payload\" from the packetbuf buffer to the sicslowpan_buf\n   * if this is a first fragment or not fragmented packet,\n   * we have already copied the compressed headers, uncomp_hdr_len\n   * and packetbuf_hdr_len are non 0, frag_offset is.\n   * If this is a subsequent fragment, this is the contrary.\n   */\n  if(packetbuf_datalen() < packetbuf_hdr_len) {\n    LOG_ERR(\"input: packet dropped due to header > total packet\\n\");\n    return;\n  }\n  packetbuf_payload_len = packetbuf_datalen() - packetbuf_hdr_len;\n\n#if SICSLOWPAN_CONF_FRAG\n  if(is_fragment) {\n    LOG_INFO(\"input: fragment (tag %d, payload %d, offset %d) -- %u %u\\n\",\n         frag_tag, packetbuf_payload_len, frag_offset << 3, packetbuf_datalen(), packetbuf_hdr_len);\n  }\n#endif /*SICSLOWPAN_CONF_FRAG*/\n\n  /* Sanity-check size of incoming packet to avoid buffer overflow */\n  {\n    int req_size = uncomp_hdr_len + (uint16_t)(frag_offset << 3)\n        + packetbuf_payload_len;\n    if(req_size > sizeof(uip_buf)) {\n#if SICSLOWPAN_CONF_FRAG\n      LOG_ERR(\n          \"input: packet and fragment context %u dropped, minimum required IP_BUF size: %d+%d+%d=%d (current size: %u)\\n\",\n          frag_context,\n          uncomp_hdr_len, (uint16_t)(frag_offset << 3),\n          packetbuf_payload_len, req_size, (unsigned)sizeof(uip_buf));\n      /* Discard all fragments for this contex, as reassembling this particular fragment would\n       * cause an overflow in uipbuf */\n      clear_fragments(frag_context);\n#endif /* SICSLOWPAN_CONF_FRAG */\n      return;\n    }\n  }\n\n  /* copy the payload if buffer is non-null - which is only the case with first fragment\n     or packets that are non fragmented */\n  if(buffer != NULL) {\n    memcpy((uint8_t *)buffer + uncomp_hdr_len, packetbuf_ptr + packetbuf_hdr_len, packetbuf_payload_len);\n  }\n\n  /* update processed_ip_in_len if fragment, sicslowpan_len otherwise */\n\n#if SICSLOWPAN_CONF_FRAG\n  if(frag_size > 0) {\n    /* Add the size of the header only for the first fragment. */\n    if(first_fragment != 0) {\n      frag_info[frag_context].reassembled_len = uncomp_hdr_len + packetbuf_payload_len;\n      frag_info[frag_context].first_frag_len = uncomp_hdr_len + packetbuf_payload_len;\n    }\n    /* For the last fragment, we are OK if there is extrenous bytes at\n       the end of the packet. */\n    if(last_fragment != 0) {\n      frag_info[frag_context].reassembled_len = frag_size;\n      /* copy to uip */\n      if(!copy_frags2uip(frag_context)) {\n        return;\n      }\n    }\n  }\n\n  /*\n   * If we have a full IP packet in sicslowpan_buf, deliver it to\n   * the IP stack\n   */\n  if(!is_fragment || last_fragment) {\n    /* packet is in uip already - just set length */\n    if(is_fragment != 0 && last_fragment != 0) {\n      uip_len = frag_size;\n    } else {\n      uip_len = packetbuf_payload_len + uncomp_hdr_len;\n    }\n#else\n    uip_len = packetbuf_payload_len + uncomp_hdr_len;\n#endif /* SICSLOWPAN_CONF_FRAG */\n    LOG_INFO(\"input: received IPv6 packet with len %d\\n\",\n             uip_len);\n\n    if(LOG_DBG_ENABLED) {\n      uint16_t ndx;\n      LOG_DBG(\"uncompression: after (%u):\", UIP_IP_BUF->len[1]);\n      for (ndx = 0; ndx < UIP_IP_BUF->len[1] + 40; ndx++) {\n        uint8_t data = ((uint8_t *) (UIP_IP_BUF))[ndx];\n        LOG_DBG_(\"%02x\", data);\n      }\n      LOG_DBG_(\"\\n\");\n    }\n\n    /* if callback is set then set attributes and call */\n    if(callback) {\n      set_packet_attrs();\n      callback->input_callback();\n    }\n\n#if LLSEC802154_USES_AUX_HEADER\n    /*\n     * Assuming that the last packet in packetbuf is containing\n     *  the LLSEC state so that it can be copied to uipbuf.\n     */\n    uipbuf_set_attr(UIPBUF_ATTR_LLSEC_LEVEL,\n      packetbuf_attr(PACKETBUF_ATTR_SECURITY_LEVEL));\n#if LLSEC802154_USES_EXPLICIT_KEYS\n    uipbuf_set_attr(UIPBUF_ATTR_LLSEC_KEY_ID,\n      packetbuf_attr(PACKETBUF_ATTR_KEY_INDEX));\n#endif /* LLSEC802154_USES_EXPLICIT_KEYS */\n#endif /*  LLSEC802154_USES_AUX_HEADER */\n\n    tcpip_input();\n#if SICSLOWPAN_CONF_FRAG\n  }\n#endif /* SICSLOWPAN_CONF_FRAG */\n}",
  "abstract_func": "static void\ninput(void)\n{\n  /* COMMENT_0 */\n  uint16_t VAR_0 = 0;\n  /* COMMENT_1 */\n  uint8_t VAR_1 = 0;\n  uint8_t *VAR_2;\n  uint16_t VAR_3;\n\n#if VAR_4\n  uint8_t VAR_5 = 0;\n  int8_t VAR_6 = 0;\n\n  /* COMMENT_2 */\n  uint16_t VAR_7 = 0;\n  uint8_t VAR_8 = 0, VAR_9 = 0;\n#endif /* COMMENT_3 */\n\n  /* COMMENT_4 */\n  link_stats_input_callback(packetbuf_addr(VAR_10));\n\n  /* COMMENT_5 */\n  VAR_11 = 0;\n  VAR_12 = 0;\n\n  /* COMMENT_6 */\n  VAR_13 = packetbuf_dataptr();\n\n  if(packetbuf_datalen() == 0) {\n    LOG_WARN(\"input: empty packet\\n\");\n    return;\n  }\n\n  /* COMMENT_7 */\n  uipbuf_clear();\n\n  /* COMMENT_8 */\n  VAR_2 = (uint8_t *)VAR_14;\n  VAR_3 = VAR_15;\n\n  /* COMMENT_9 */\n                                      \n  VAR_16 = (signed short)packetbuf_attr(VAR_17);\n\n#if VAR_4\n\n  /* COMMENT_11 */\n                                                                           \n                                            \n     \n  switch((GET16(VAR_18, VAR_19) >> 8) & VAR_20) {\n    case VAR_21:\n      VAR_1 = 0;\n      VAR_0 = GET16(VAR_18, VAR_19) & 0x07ff;\n      VAR_7 = GET16(VAR_18, VAR_22);\n      VAR_12 += VAR_23;\n      VAR_8 = 1;\n      VAR_5 = 1;\n\n      LOG_INFO(\"input: received first element of a fragmented packet (tag %d, len %d)\\n\",\n             VAR_7, VAR_0);\n\n      /* COMMENT_15 */\n      VAR_6 = add_fragment(VAR_7, VAR_0, VAR_1);\n\n      if(VAR_6 == -1) {\n        LOG_ERR(\"input: failed to allocate new reassembly context\\n\");\n        return;\n      }\n\n      VAR_2 = VAR_24[VAR_6].first_frag;\n      VAR_3 = VAR_25;\n      break;\n    case VAR_26:\n      /* COMMENT_16 */\n                              \n                                      \n         \n      VAR_1 = VAR_18[VAR_27];\n      VAR_7 = GET16(VAR_18, VAR_22);\n      VAR_0 = GET16(VAR_18, VAR_19) & 0x07ff;\n      VAR_12 += VAR_28;\n\n      /* COMMENT_20 */\n                             \n      VAR_6 = add_fragment(VAR_7, VAR_0, VAR_1);\n\n      if(VAR_6 == -1) {\n        LOG_ERR(\"input: reassembly context not found (tag %d)\\n\", VAR_7);\n        return;\n      }\n\n      /* COMMENT_22 */\n                                    \n      VAR_2 = NULL;\n\n      if(VAR_24[VAR_6].reassembled_len >= VAR_0) {\n        VAR_9 = 1;\n      }\n      VAR_5 = 1;\n      break;\n    default:\n      break;\n  }\n\n  if(VAR_5 && !VAR_8) {\n    /* COMMENT_24 */\n    goto copypayload;\n  }\n#endif /* COMMENT_25 */\n\n  /* COMMENT_26 */\n  VAR_29 = 0;\n  digest_paging_dispatch();\n  if(VAR_29 == 1) {\n    LOG_INFO(\"input: page 1, 6LoRH\\n\");\n    digest_6lorh_hdr();\n  } else if (VAR_29 > 1) {\n    LOG_ERR(\"input: page %u not supported\\n\", VAR_29);\n    return;\n  }\n\n  /* COMMENT_27 */\n  if(VAR_30 > VAR_31 &&\n     (VAR_32[VAR_33] & VAR_34) == VAR_35) {\n    LOG_DBG(\"uncompression: IPHC dispatch\\n\");\n    uncompress_hdr_iphc(VAR_2, VAR_3, VAR_0);\n  } else if(VAR_32[VAR_33] == VAR_36) {\n    LOG_DBG(\"uncompression: IPV6 dispatch\\n\");\n    VAR_12 += VAR_37;\n\n    /* COMMENT_28 */\n    memcpy(VAR_2, VAR_13 + VAR_12, VAR_38);\n\n    /* COMMENT_29 */\n    VAR_12 += VAR_38;\n    VAR_11 += VAR_38;\n  } else {\n    LOG_ERR(\"uncompression: unknown dispatch: 0x%02x, or IPHC disabled\\n\",\n             VAR_32[VAR_33] & VAR_34);\n    return;\n  }\n\n#if VAR_4\n copypayload:\n#endif /* COMMENT_3 */\n  /* COMMENT_30 */\n                                                                   \n                                                          \n                                                                  \n                                                     \n                                                            \n     \n  if(packetbuf_datalen() < VAR_12) {\n    LOG_ERR(\"input: packet dropped due to header > total packet\\n\");\n    return;\n  }\n  VAR_39 = packetbuf_datalen() - VAR_12;\n\n#if VAR_4\n  if(VAR_5) {\n    LOG_INFO(\"input: fragment (tag %d, payload %d, offset %d) -- %u %u\\n\",\n         VAR_7, VAR_39, VAR_1 << 3, packetbuf_datalen(), VAR_12);\n  }\n#endif /* COMMENT_3 */\n\n  /* COMMENT_37 */\n  {\n    int VAR_40 = VAR_11 + (uint16_t)(VAR_1 << 3)\n        + VAR_39;\n    if(VAR_40 > sizeof(VAR_41)) {\n#if VAR_4\n      LOG_ERR(\n          \"input: packet and fragment context %u dropped, minimum required IP_BUF size: %d+%d+%d=%d (current size: %u)\\n\",\n          VAR_6,\n          VAR_11, (uint16_t)(VAR_1 << 3),\n          VAR_39, VAR_40, (unsigned)sizeof(VAR_41));\n      /* COMMENT_38 */\n                                       \n      clear_fragments(VAR_6);\n#endif /* COMMENT_25 */\n      return;\n    }\n  }\n\n  /* COMMENT_40 */\n                                          \n  if(VAR_2 != NULL) {\n    memcpy((uint8_t *)VAR_2 + VAR_11, VAR_13 + VAR_12, VAR_39);\n  }\n\n  /* COMMENT_42 */\n\n#if VAR_4\n  if(VAR_0 > 0) {\n    /* COMMENT_43 */\n    if(VAR_8 != 0) {\n      VAR_24[VAR_6].reassembled_len = VAR_11 + VAR_39;\n      VAR_24[VAR_6].first_frag_len = VAR_11 + VAR_39;\n    }\n    /* COMMENT_44 */\n                                \n    if(VAR_9 != 0) {\n      VAR_24[VAR_6].reassembled_len = VAR_0;\n      /* COMMENT_46 */\n      if(!copy_frags2uip(VAR_6)) {\n        return;\n      }\n    }\n  }\n\n  /* COMMENT_47 */\n                                                                 \n                 \n     \n  if(!VAR_5 || VAR_9) {\n    /* COMMENT_51 */\n    if(VAR_5 != 0 && VAR_9 != 0) {\n      VAR_42 = VAR_0;\n    } else {\n      VAR_42 = VAR_39 + VAR_11;\n    }\n#else\n    uip_len = packetbuf_payload_len + uncomp_hdr_len;\n#endif/* COMMENT_52 */\n    LOG_INFO(\"input: received IPv6 packet with len %d\\n\",\n             VAR_42);\n\n    if(VAR_43) {\n      uint16_t VAR_44;\n      LOG_DBG(\"uncompression: after (%u):\", VAR_14->len[1]);\n      for (VAR_44 = 0; VAR_44 < VAR_14->len[1] + 40; VAR_44++) {\n        uint8_t VAR_45 = ((uint8_t *) (VAR_14))[VAR_44];\n        LOG_DBG_(\"%02x\", VAR_45);\n      }\n      LOG_DBG_(\"\\n\");\n    }\n\n    /* COMMENT_53 */\n    if(VAR_46) {\n      set_packet_attrs();\n      VAR_46->input_callback();\n    }\n\n#if VAR_47\n    /* COMMENT_54 */\n                                                               \n                                                           \n       \n    uipbuf_set_attr(VAR_48,\n      packetbuf_attr(VAR_49));\n#if VAR_50\n    uipbuf_set_attr(VAR_51,\n      packetbuf_attr(VAR_52));\n#endif /* COMMENT_58 */\n#endif /* COMMENT_59 */\n\n    tcpip_input();\n#if VAR_4\n  }\n#endif /* COMMENT_25 */\n}",
  "func_graph_path": "contiki-ng/b88e5c303db21578799e5083bda9580922dc17b4/sicslowpan.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -6,6 +6,7 @@\n   /* offset of the fragment in the IP packet */\n   uint8_t frag_offset = 0;\n   uint8_t *buffer;\n+  uint16_t buffer_size;\n \n #if SICSLOWPAN_CONF_FRAG\n   uint8_t is_fragment = 0;\n@@ -36,6 +37,7 @@\n \n   /* This is default uip_buf since we assume that this is not fragmented */\n   buffer = (uint8_t *)UIP_IP_BUF;\n+  buffer_size = UIP_BUFSIZE;\n \n   /* Save the RSSI of the incoming packet in case the upper layer will\n      want to query us for it later. */\n@@ -68,6 +70,7 @@\n       }\n \n       buffer = frag_info[frag_context].first_frag;\n+      buffer_size = SICSLOWPAN_FIRST_FRAGMENT_SIZE;\n       break;\n     case SICSLOWPAN_DISPATCH_FRAGN:\n       /*\n@@ -122,7 +125,7 @@\n   if(SICSLOWPAN_COMPRESSION > SICSLOWPAN_COMPRESSION_IPV6 &&\n      (PACKETBUF_6LO_PTR[PACKETBUF_6LO_DISPATCH] & SICSLOWPAN_DISPATCH_IPHC_MASK) == SICSLOWPAN_DISPATCH_IPHC) {\n     LOG_DBG(\"uncompression: IPHC dispatch\\n\");\n-    uncompress_hdr_iphc(buffer, frag_size);\n+    uncompress_hdr_iphc(buffer, buffer_size, frag_size);\n   } else if(PACKETBUF_6LO_PTR[PACKETBUF_6LO_DISPATCH] == SICSLOWPAN_DISPATCH_IPV6) {\n     LOG_DBG(\"uncompression: IPV6 dispatch\\n\");\n     packetbuf_hdr_len += SICSLOWPAN_IPV6_HDR_LEN;",
  "diff_line_info": {
    "deleted_lines": [
      "    uncompress_hdr_iphc(buffer, frag_size);"
    ],
    "added_lines": [
      "  uint16_t buffer_size;",
      "  buffer_size = UIP_BUFSIZE;",
      "      buffer_size = SICSLOWPAN_FIRST_FRAGMENT_SIZE;",
      "    uncompress_hdr_iphc(buffer, buffer_size, frag_size);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/contiki-ng/contiki-ng/pull/1409",
  "description": {
    "pr_info": {
      "title": "Prevent out-of-bounds write when processing external headers in sicslowpan",
      "number": 1409
    },
    "comment": [
      "When processing external headers in sicslowpan, a long chain of headers could possibly overflow the uip_buf variable.\r\n\r\nIn the code below, which follows the now inserted check, the writes to the exthdr struct could result in an out-of-bounds write.\r\nexthdr = (struct uip_ext_hdr *)ip_payload; exthdr->len = (2 + len) / 8 - 1; exthdr->next = next;\r\n\r\nA packet test that should trigger the bug is included in the PR."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix\nConfidence Score: 0.95\n\n---\n\n**Step-by-Step Explanation:**\n\n1. **Patch Analysis:**\n   - The commit message indicates a buffer check for external header writing.\n   - Code changes introduce `buffer_size` variable and pass it to `uncompress_hdr_iphc`, suggesting a size validation.\n\n2. **Security Assessment:**\n   - The change prevents buffer overflow by validating space, a common security flaw.\n   - This addresses a defect that could lead to unauthorized access or system compromise.\n\n3. **Classification:**\n   - The fix is a security vulnerability fix as it mitigates a buffer overflow risk.\n\n4. **Confidence:**\n   - High confidence due to clear buffer management correction, indicating a security concern.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\nThe patch introduces a buffer size check to prevent potential buffer overflow, indicating a security fix.\n\n**Final Output:**\nAnalysis: The patch adds a buffer size check, preventing potential overflow by ensuring sufficient space. This addresses a security vulnerability.\nFinal Classification: Security Vulnerability Fix\nConfidence Score: 0.95\n\n---\n\n**Step-by-Step Explanation:**\n\n1. **Patch Analysis:**\n   - The commit message indicates a buffer check for external header writing.\n   - Code changes introduce `buffer_size` variable and pass it to `uncompress_hdr_iphc`, suggesting a size validation.\n\n2. **Security Assessment:**\n   - The change prevents buffer overflow by validating space, a common security flaw.\n   - This addresses a defect that could lead to unauthorized access or system compromise.\n\n3. **Classification:**\n   - The fix is a security vulnerability fix as it mitigates a buffer overflow risk.\n\n4. **Confidence:**\n   - High confidence due to clear buffer management correction, indicating a security concern.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 0.95"
}