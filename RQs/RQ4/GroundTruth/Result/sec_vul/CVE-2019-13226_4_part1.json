{
  "cve_id": "CVE-2019-13226",
  "cwe_ids": [
    "CWE-362",
    "CWE-59"
  ],
  "cvss_vector": "AV:L/AC:M/Au:N/C:C/I:C/A:C",
  "cvss_is_v3": false,
  "repo_name": "linuxdeepin/deepin-clone",
  "commit_msg": "fix: Do not use the \"/tmp\" directory\n\nhttps://github.com/linuxdeepin/deepin-clone/issues/16\nhttps://bugzilla.opensuse.org/show_bug.cgi?id=1130388",
  "commit_hash": "e079f3e2712b4f8c28e3e63e71ba1a1f90fce1ab",
  "git_url": "https://github.com/linuxdeepin/deepin-clone/commit/e079f3e2712b4f8c28e3e63e71ba1a1f90fce1ab",
  "file_path": "app/src/fixboot/bootdoctor.cpp",
  "func_name": "BootDoctor::fix",
  "func_before": "bool BootDoctor::fix(const QString &partDevice)\n{\n    m_lastErrorString.clear();\n\n    DDevicePartInfo part_info(partDevice);\n    const QString part_old_uuid = part_info.uuid();\n\n    if (Helper::processExec(\"lsblk -s -d -n -o UUID\") == 0) {\n        if (Helper::lastProcessStandardOutput().contains(part_old_uuid.toLatin1())) {\n            // reset uuid\n            if (Helper::resetPartUUID(part_info)) {\n                QThread::sleep(1);\n                part_info.refresh();\n\n                qDebug() << part_old_uuid << part_info.uuid();\n            } else {\n                dCWarning(\"Failed to reset uuid\");\n            }\n        }\n    }\n\n    bool device_is_mounted = Helper::isMounted(partDevice);\n    const QString &mount_root = Helper::temporaryMountDevice(partDevice, QFileInfo(partDevice).fileName());\n\n    if (mount_root.isEmpty()) {\n        m_lastErrorString = QObject::tr(\"Failed to mount partition \\\"%1\\\"\").arg(partDevice);\n        goto failed;\n    }\n\n    {\n        const QStringList &tmp_paths = QStandardPaths::standardLocations(QStandardPaths::TempLocation);\n        const QString tmp_dir = (tmp_paths.isEmpty() ? \"/tmp\" : tmp_paths.first()) + \"/.deepin-clone\";\n\n        if (!QDir::current().mkpath(tmp_dir)) {\n            dCError(\"mkpath \\\"%s\\\" failed\", qPrintable(tmp_dir));\n            goto failed;\n        }\n\n        const QString &repo_path = tmp_dir + \"/repo.iso\";\n\n        if (!QFile::exists(repo_path)\n                && !QFile::copy(QString(\":/repo_%1.iso\").arg(HOST_ARCH), repo_path)) {\n            dCError(\"copy file failed, new name: %s\", qPrintable(repo_path));\n            goto failed;\n        }\n\n        bool ok = false;\n\n        const QString &repo_mount_point = mount_root + \"/deepin-clone\";\n        QFile file_boot_fix(mount_root + \"/boot_fix.sh\");\n\n        do {\n            if (!QDir(mount_root).exists(\"deepin-clone\") && !QDir(mount_root).mkdir(\"deepin-clone\")) {\n                dCError(\"Create \\\"deepin-clone\\\" dir failed(\\\"%s\\\")\", qPrintable(mount_root));\n                break;\n            }\n\n            if (!Helper::mountDevice(repo_path, repo_mount_point, true)) {\n                m_lastErrorString = QObject::tr(\"Failed to mount partition \\\"%1\\\"\").arg(repo_path);\n                break;\n            }\n\n            if (file_boot_fix.exists()) {\n                file_boot_fix.remove();\n            }\n\n            if (!QFile::copy(QString(\":/scripts/boot_fix_%1.sh\").arg(\n                     #if defined(HOST_ARCH_x86_64) || defined(HOST_ARCH_i386) || defined(HOST_ARCH_i686)\n                                 \"x86\"\n                     #elif defined(HOST_ARCH_mips64) || defined(HOST_ARCH_mips32)\n                                 \"mips\"\n                     #elif defined(HOST_ARCH_sw_64)\n                                 \"sw_64\"\n                     #elif defined(HOST_ARCH_aarch64)\n                                 \"aarch64\"\n                     #else\n                     #pragma message \"Machine: \" HOST_ARCH\n                                \"unknow\"\n                     #endif\n                                 ), file_boot_fix.fileName())) {\n                dCError(\"copy file failed, new name: %s\", qPrintable(file_boot_fix.fileName()));\n                break;\n            }\n\n            if (!file_boot_fix.setPermissions(file_boot_fix.permissions() | QFile::ExeUser)) {\n                dCError(\"Set \\\"%s\\\" permissions failed\", qPrintable(file_boot_fix.fileName()));\n                break;\n            }\n\n            if (Helper::processExec(QString(\"mount --bind -v --bind /dev %1/dev\").arg(mount_root)) != 0) {\n                dCError(\"Failed to bind /dev\");\n                break;\n            }\n\n            if (Helper::processExec(QString(\"mount --bind -v --bind /dev/pts %1/dev/pts\").arg(mount_root)) != 0) {\n                dCError(\"Failed to bind /dev/pts\");\n                break;\n            }\n\n            if (Helper::processExec(QString(\"mount --bind -v --bind /proc %1/proc\").arg(mount_root)) != 0) {\n                dCError(\"Failed to bind /proc\");\n                break;\n            }\n\n            if (Helper::processExec(QString(\"mount --bind -v --bind /sys %1/sys\").arg(mount_root)) != 0) {\n                dCError(\"Failed to bind /sys\");\n                break;\n            }\n\n            ok = true;\n        } while (0);\n\n        QProcess process;\n\n        if (ok) {\n            const QString &parent_device = Helper::parentDevice(partDevice);\n\n            bool is_efi = false;\n\n            if (!parent_device.isEmpty()) {\n                DDeviceDiskInfo info(parent_device);\n\n                dCDebug(\"Disk partition table type: %d\", info.ptType());\n\n                if (info.ptType() == DDeviceDiskInfo::GPT) {\n                    for (const DPartInfo &part : info.childrenPartList()) {\n                        if (part.guidType() == DPartInfo::EFI_SP_None) {\n                            const QString &efi_path = mount_root + \"/boot/efi\";\n\n                            QDir::current().mkpath(efi_path);\n\n                            if (Helper::processExec(QString(\"mount %1 %2\").arg(part.filePath()).arg(efi_path)) != 0) {\n                                dCError(\"Failed to mount EFI partition\");\n                                m_lastErrorString = QObject::tr(\"Failed to mount partition \\\"%1\\\"\").arg(part.filePath());\n                                ok = false;\n                                break;\n                            }\n\n                            is_efi = true;\n\n                            break;\n                        }\n                    }\n\n                    if (!is_efi && m_lastErrorString.isEmpty()) {\n                        m_lastErrorString = QObject::tr(\"EFI partition not found\");\n                        ok = false;\n                    }\n                } else if (info.ptType() == DDeviceDiskInfo::Unknow) {\n                    m_lastErrorString = QObject::tr(\"Unknown partition style\");\n                    ok = false;\n                }\n            }\n\n            if (ok) {\n                process.setProcessChannelMode(QProcess::MergedChannels);\n                process.start(QString(\"chroot %1 ./boot_fix.sh %2 %3 /deepin-clone\")\n                              .arg(mount_root)\n                              .arg(parent_device)\n                              .arg(is_efi ? \"true\" : \"false\"));\n\n                while (process.waitForReadyRead()) {\n                    const QByteArray &data = process.readAll().simplified().constData();\n\n                    dCDebug(data.constData());\n                }\n\n                process.waitForFinished(-1);\n\n                switch (process.exitCode()) {\n                case 1:\n                    m_lastErrorString = QObject::tr(\"Boot for install system failed\");\n                    break;\n                case 2:\n                    m_lastErrorString = QObject::tr(\"Boot for update system failed\");\n                    break;\n                default:\n                    break;\n                }\n            }\n        }\n\n        // clear\n        Helper::processExec(\"umount \" + repo_mount_point);\n        QDir(mount_root).rmdir(\"deepin-clone\");\n        file_boot_fix.remove();\n        Helper::processExec(\"umount \" + mount_root + \"/dev/pts\");\n        Helper::processExec(\"umount \" + mount_root + \"/dev\");\n        Helper::processExec(\"umount \" + mount_root + \"/proc\");\n        Helper::processExec(\"umount \" + mount_root + \"/sys\");\n        Helper::processExec(\"umount \" + mount_root + \"/boot/efi\");\n\n        if (ok && process.exitCode() == 0) {\n            if (part_old_uuid != part_info.uuid()) {\n                dCDebug(\"Reset the uuid from \\\"%s\\\" to \\\"%s\\\"\", qPrintable(part_old_uuid), qPrintable(part_info.uuid()));\n\n                // update /etc/fstab\n                QFile file(mount_root + \"/etc/fstab\");\n\n                if (file.exists() && file.open(QIODevice::ReadWrite)) {\n                    QByteArray data = file.readAll();\n\n                    if (file.seek(0)) {\n                        file.write(data.replace(part_old_uuid.toLatin1(), part_info.uuid().toLatin1()));\n                    }\n\n                    file.close();\n                } else {\n                    dCWarning(\"Failed to update /etc/fstab, error: %s\", qPrintable(file.errorString()));\n                }\n\n                file.setFileName(mount_root + \"/etc/crypttab\");\n\n                if (file.exists() && file.open(QIODevice::ReadWrite)) {\n                    QByteArray data = file.readAll();\n\n                    if (file.seek(0)) {\n                        file.write(data.replace(part_old_uuid.toLatin1(), part_info.uuid().toLatin1()));\n                    }\n\n                    file.close();\n                } else {\n                    dCWarning(\"Failed to update /etc/crypttab, error: %s\", qPrintable(file.errorString()));\n                }\n            }\n\n            if (!device_is_mounted)\n                Helper::umountDevice(partDevice);\n\n            return true;\n        }\n    }\n\nfailed:\n    if (!device_is_mounted)\n        Helper::umountDevice(partDevice);\n\n    if (m_lastErrorString.isEmpty())\n        m_lastErrorString = QObject::tr(\"Boot for repair system failed\");\n\n    dCDebug(\"Restore partition uuid\");\n\n    if (!Helper::resetPartUUID(part_info, part_old_uuid.toLatin1())) {\n        dCWarning(\"Failed to restore partition uuid, part: %s, uuid: %s\", qPrintable(partDevice), qPrintable(part_old_uuid));\n    }\n\n    return false;\n}",
  "abstract_func_before": "bool BootDoctor::fix(const QString &VAR_0)\n{\n    VAR_1.clear();\n\n    DDevicePartInfo part_info(partDevice);\n    const QString VAR_2 = VAR_3.uuid();\n\n    if (Helper::processExec(\"lsblk -s -d -n -o UUID\") == 0) {\n        if (Helper::lastProcessStandardOutput().contains(VAR_2.toLatin1())) {\n            /* COMMENT_0 */\n            if (Helper::resetPartUUID(VAR_3)) {\n                QThread::sleep(1);\n                VAR_3.refresh();\n\n                qDebug() << VAR_2 << VAR_3.uuid();\n            } else {\n                dCWarning(\"Failed to reset uuid\");\n            }\n        }\n    }\n\n    bool VAR_4 = Helper::isMounted(partDevice);\n    const QString &VAR_5 = Helper::temporaryMountDevice(partDevice, QFileInfo(partDevice).fileName());\n\n    if (VAR_5.isEmpty()) {\n        VAR_1 = QObject::tr(\"Failed to mount partition \\\"%1\\\"\").arg(partDevice);\n        goto failed;\n    }\n\n    {\n        const QStringList &VAR_6 = QStandardPaths::standardLocations(QStandardPaths::TempLocation);\n        const QString VAR_7 = (VAR_6.isEmpty() ? \"/tmp\" : VAR_6.first()) + \"/.deepin-clone\";\n\n        if (!QDir::current().mkpath(VAR_7)) {\n            dCError(\"mkpath \\\"%s\\\" failed\", qPrintable(VAR_7));\n            goto failed;\n        }\n\n        const QString &VAR_8 = VAR_7 + \"/repo.iso\";\n\n        if (!QFile::exists(VAR_8)\n                && !QFile::copy(QString(\":/repo_%1.iso\").arg(VAR_9), VAR_8)) {\n            dCError(\"copy file failed, new name: %s\", qPrintable(VAR_8));\n            goto failed;\n        }\n\n        bool VAR_10 = false;\n\n        const QString &VAR_11 = VAR_5 + \"/deepin-clone\";\n        QFile VAR_12(VAR_5 + \"/boot_fix.sh\");\n\n        do {\n            if (!QDir(VAR_5).exists(\"deepin-clone\") && !QDir(VAR_5).mkdir(\"deepin-clone\")) {\n                dCError(\"Create \\\"deepin-clone\\\" dir failed(\\\"%s\\\")\", qPrintable(VAR_5));\n                break;\n            }\n\n            if (!Helper::mountDevice(VAR_8, VAR_11, true)) {\n                VAR_1 = QObject::tr(\"Failed to mount partition \\\"%1\\\"\").arg(VAR_8);\n                break;\n            }\n\n            if (VAR_12.exists()) {\n                VAR_12.remove();\n            }\n\n            if (!QFile::copy(QString(\":/scripts/boot_fix_%1.sh\").arg(\n                     #if defined(VAR_13) || defined(VAR_14) || defined(VAR_15)\n                                 \"x86\"\n                     #elif defined(VAR_16) || defined(VAR_17)\n                                 \"mips\"\n                     #elif defined(VAR_18)\n                                 \"sw_64\"\n                     #elif defined(VAR_19)\n                                 \"aarch64\"\n                     #else\n                     #pragma VAR_20 \"VAR_21: \" HOST_ARCH\n                                \"unknow\"\n                     #endif\n                                 ), VAR_12.fileName())) {\n                dCError(\"copy file failed, new name: %s\", qPrintable(VAR_12.fileName()));\n                break;\n            }\n\n            if (!VAR_12.setPermissions(VAR_12.permissions() | QFile::ExeUser)) {\n                dCError(\"Set \\\"%s\\\" permissions failed\", qPrintable(VAR_12.fileName()));\n                break;\n            }\n\n            if (Helper::processExec(QString(\"mount --bind -v --bind /dev %1/dev\").arg(VAR_5)) != 0) {\n                dCError(\"Failed to bind /dev\");\n                break;\n            }\n\n            if (Helper::processExec(QString(\"mount --bind -v --bind /dev/pts %1/dev/pts\").arg(VAR_5)) != 0) {\n                dCError(\"Failed to bind /dev/pts\");\n                break;\n            }\n\n            if (Helper::processExec(QString(\"mount --bind -v --bind /proc %1/proc\").arg(VAR_5)) != 0) {\n                dCError(\"Failed to bind /proc\");\n                break;\n            }\n\n            if (Helper::processExec(QString(\"mount --bind -v --bind /sys %1/sys\").arg(VAR_5)) != 0) {\n                dCError(\"Failed to bind /sys\");\n                break;\n            }\n\n            VAR_10 = true;\n        } while (0);\n\n        QProcess VAR_22;\n\n        if (VAR_10) {\n            const QString &VAR_23 = Helper::parentDevice(partDevice);\n\n            bool VAR_24 = false;\n\n            if (!VAR_23.isEmpty()) {\n                DDeviceDiskInfo info(parent_device);\n\n                dCDebug(\"Disk partition table type: %d\", VAR_25.ptType());\n\n                if (VAR_25.ptType() == DDeviceDiskInfo::GPT) {\n                    for (const DPartInfo &VAR_26 : VAR_25.childrenPartList()) {\n                        if (VAR_26.guidType() == DPartInfo::EFI_SP_None) {\n                            const QString &VAR_27 = VAR_5 + \"/boot/efi\";\n\n                            QDir::current().mkpath(VAR_27);\n\n                            if (Helper::processExec(QString(\"mount %1 %2\").arg(VAR_26.filePath()).arg(VAR_27)) != 0) {\n                                dCError(\"Failed to mount EFI partition\");\n                                VAR_1 = QObject::tr(\"Failed to mount partition \\\"%1\\\"\").arg(VAR_26.filePath());\n                                VAR_10 = false;\n                                break;\n                            }\n\n                            VAR_24 = true;\n\n                            break;\n                        }\n                    }\n\n                    if (!VAR_24 && VAR_1.isEmpty()) {\n                        VAR_1 = QObject::tr(\"EFI partition not found\");\n                        VAR_10 = false;\n                    }\n                } else if (VAR_25.ptType() == DDeviceDiskInfo::Unknow) {\n                    VAR_1 = QObject::tr(\"Unknown partition style\");\n                    VAR_10 = false;\n                }\n            }\n\n            if (VAR_10) {\n                VAR_22.setProcessChannelMode(QProcess::MergedChannels);\n                VAR_22.start(QString(\"chroot %1 ./boot_fix.sh %2 %3 /deepin-clone\")\n                              .arg(VAR_5)\n                              .arg(parent_device)\n                              .arg(VAR_24 ? \"true\" : \"false\"));\n\n                while (VAR_22.waitForReadyRead()) {\n                    const QByteArray &VAR_28 = VAR_22.readAll().simplified().constData();\n\n                    dCDebug(VAR_28.constData());\n                }\n\n                VAR_22.waitForFinished(-1);\n\n                switch (VAR_22.exitCode()) {\n                case 1:\n                    VAR_1 = QObject::tr(\"Boot for install system failed\");\n                    break;\n                case 2:\n                    VAR_1 = QObject::tr(\"Boot for update system failed\");\n                    break;\n                default:\n                    break;\n                }\n            }\n        }\n\n        /* COMMENT_1 */\n        Helper::processExec(\"umount \" + VAR_11);\n        QDir(VAR_5).rmdir(\"deepin-clone\");\n        VAR_12.remove();\n        Helper::processExec(\"umount \" + VAR_5 + \"/dev/pts\");\n        Helper::processExec(\"umount \" + VAR_5 + \"/dev\");\n        Helper::processExec(\"umount \" + VAR_5 + \"/proc\");\n        Helper::processExec(\"umount \" + VAR_5 + \"/sys\");\n        Helper::processExec(\"umount \" + VAR_5 + \"/boot/efi\");\n\n        if (VAR_10 && VAR_22.exitCode() == 0) {\n            if (VAR_2 != VAR_3.uuid()) {\n                dCDebug(\"Reset the uuid from \\\"%s\\\" to \\\"%s\\\"\", qPrintable(VAR_2), qPrintable(VAR_3.uuid()));\n\n                /* COMMENT_2 */\n                QFile VAR_29(VAR_5 + \"/etc/fstab\");\n\n                if (VAR_29.exists() && VAR_29.open(QIODevice::ReadWrite)) {\n                    QByteArray VAR_28 = VAR_29.readAll();\n\n                    if (VAR_29.seek(0)) {\n                        VAR_29.write(VAR_28.replace(VAR_2.toLatin1(), VAR_3.uuid().toLatin1()));\n                    }\n\n                    VAR_29.close();\n                } else {\n                    dCWarning(\"Failed to update /etc/fstab, error: %s\", qPrintable(VAR_29.errorString()));\n                }\n\n                VAR_29.setFileName(VAR_5 + \"/etc/crypttab\");\n\n                if (VAR_29.exists() && VAR_29.open(QIODevice::ReadWrite)) {\n                    QByteArray VAR_28 = VAR_29.readAll();\n\n                    if (VAR_29.seek(0)) {\n                        VAR_29.write(VAR_28.replace(VAR_2.toLatin1(), VAR_3.uuid().toLatin1()));\n                    }\n\n                    VAR_29.close();\n                } else {\n                    dCWarning(\"Failed to update /etc/crypttab, error: %s\", qPrintable(VAR_29.errorString()));\n                }\n            }\n\n            if (!VAR_4)\n                Helper::umountDevice(partDevice);\n\n            return true;\n        }\n    }\n\nfailed:\n    if (!VAR_4)\n        Helper::umountDevice(partDevice);\n\n    if (VAR_1.isEmpty())\n        VAR_1 = QObject::tr(\"Boot for repair system failed\");\n\n    dCDebug(\"Restore partition uuid\");\n\n    if (!Helper::resetPartUUID(VAR_3, VAR_2.toLatin1())) {\n        dCWarning(\"Failed to restore partition uuid, part: %s, uuid: %s\", qPrintable(partDevice), qPrintable(VAR_2));\n    }\n\n    return false;\n}",
  "func_graph_path_before": "linuxdeepin/deepin-clone/e079f3e2712b4f8c28e3e63e71ba1a1f90fce1ab/bootdoctor.cpp/vul/before/0.json",
  "func": "bool BootDoctor::fix(const QString &partDevice)\n{\n    m_lastErrorString.clear();\n\n    DDevicePartInfo part_info(partDevice);\n    const QString part_old_uuid = part_info.uuid();\n\n    if (Helper::processExec(\"lsblk -s -d -n -o UUID\") == 0) {\n        if (Helper::lastProcessStandardOutput().contains(part_old_uuid.toLatin1())) {\n            // reset uuid\n            if (Helper::resetPartUUID(part_info)) {\n                QThread::sleep(1);\n                part_info.refresh();\n\n                qDebug() << part_old_uuid << part_info.uuid();\n            } else {\n                dCWarning(\"Failed to reset uuid\");\n            }\n        }\n    }\n\n    bool device_is_mounted = Helper::isMounted(partDevice);\n    const QString &mount_root = Helper::temporaryMountDevice(partDevice, QFileInfo(partDevice).fileName());\n\n    if (mount_root.isEmpty()) {\n        m_lastErrorString = QObject::tr(\"Failed to mount partition \\\"%1\\\"\").arg(partDevice);\n        goto failed;\n    }\n\n    {\n        const QString tmp_dir = \"/var/cache/deepin-clone\";\n\n        if (!QDir::current().mkpath(tmp_dir)) {\n            dCError(\"mkpath \\\"%s\\\" failed\", qPrintable(tmp_dir));\n            goto failed;\n        }\n\n        const QString &repo_path = tmp_dir + \"/repo.iso\";\n\n        if (!QFile::exists(repo_path)\n                && !QFile::copy(QString(\":/repo_%1.iso\").arg(HOST_ARCH), repo_path)) {\n            dCError(\"copy file failed, new name: %s\", qPrintable(repo_path));\n            goto failed;\n        }\n\n        bool ok = false;\n\n        const QString &repo_mount_point = mount_root + \"/deepin-clone\";\n        QFile file_boot_fix(mount_root + \"/boot_fix.sh\");\n\n        do {\n            if (!QDir(mount_root).exists(\"deepin-clone\") && !QDir(mount_root).mkdir(\"deepin-clone\")) {\n                dCError(\"Create \\\"deepin-clone\\\" dir failed(\\\"%s\\\")\", qPrintable(mount_root));\n                break;\n            }\n\n            if (!Helper::mountDevice(repo_path, repo_mount_point, true)) {\n                m_lastErrorString = QObject::tr(\"Failed to mount partition \\\"%1\\\"\").arg(repo_path);\n                break;\n            }\n\n            if (file_boot_fix.exists()) {\n                file_boot_fix.remove();\n            }\n\n            if (!QFile::copy(QString(\":/scripts/boot_fix_%1.sh\").arg(\n                     #if defined(HOST_ARCH_x86_64) || defined(HOST_ARCH_i386) || defined(HOST_ARCH_i686)\n                                 \"x86\"\n                     #elif defined(HOST_ARCH_mips64) || defined(HOST_ARCH_mips32)\n                                 \"mips\"\n                     #elif defined(HOST_ARCH_sw_64)\n                                 \"sw_64\"\n                     #elif defined(HOST_ARCH_aarch64)\n                                 \"aarch64\"\n                     #else\n                     #pragma message \"Machine: \" HOST_ARCH\n                                \"unknow\"\n                     #endif\n                                 ), file_boot_fix.fileName())) {\n                dCError(\"copy file failed, new name: %s\", qPrintable(file_boot_fix.fileName()));\n                break;\n            }\n\n            if (!file_boot_fix.setPermissions(file_boot_fix.permissions() | QFile::ExeUser)) {\n                dCError(\"Set \\\"%s\\\" permissions failed\", qPrintable(file_boot_fix.fileName()));\n                break;\n            }\n\n            if (Helper::processExec(QString(\"mount --bind -v --bind /dev %1/dev\").arg(mount_root)) != 0) {\n                dCError(\"Failed to bind /dev\");\n                break;\n            }\n\n            if (Helper::processExec(QString(\"mount --bind -v --bind /dev/pts %1/dev/pts\").arg(mount_root)) != 0) {\n                dCError(\"Failed to bind /dev/pts\");\n                break;\n            }\n\n            if (Helper::processExec(QString(\"mount --bind -v --bind /proc %1/proc\").arg(mount_root)) != 0) {\n                dCError(\"Failed to bind /proc\");\n                break;\n            }\n\n            if (Helper::processExec(QString(\"mount --bind -v --bind /sys %1/sys\").arg(mount_root)) != 0) {\n                dCError(\"Failed to bind /sys\");\n                break;\n            }\n\n            ok = true;\n        } while (0);\n\n        QProcess process;\n\n        if (ok) {\n            const QString &parent_device = Helper::parentDevice(partDevice);\n\n            bool is_efi = false;\n\n            if (!parent_device.isEmpty()) {\n                DDeviceDiskInfo info(parent_device);\n\n                dCDebug(\"Disk partition table type: %d\", info.ptType());\n\n                if (info.ptType() == DDeviceDiskInfo::GPT) {\n                    for (const DPartInfo &part : info.childrenPartList()) {\n                        if (part.guidType() == DPartInfo::EFI_SP_None) {\n                            const QString &efi_path = mount_root + \"/boot/efi\";\n\n                            QDir::current().mkpath(efi_path);\n\n                            if (Helper::processExec(QString(\"mount %1 %2\").arg(part.filePath()).arg(efi_path)) != 0) {\n                                dCError(\"Failed to mount EFI partition\");\n                                m_lastErrorString = QObject::tr(\"Failed to mount partition \\\"%1\\\"\").arg(part.filePath());\n                                ok = false;\n                                break;\n                            }\n\n                            is_efi = true;\n\n                            break;\n                        }\n                    }\n\n                    if (!is_efi && m_lastErrorString.isEmpty()) {\n                        m_lastErrorString = QObject::tr(\"EFI partition not found\");\n                        ok = false;\n                    }\n                } else if (info.ptType() == DDeviceDiskInfo::Unknow) {\n                    m_lastErrorString = QObject::tr(\"Unknown partition style\");\n                    ok = false;\n                }\n            }\n\n            if (ok) {\n                process.setProcessChannelMode(QProcess::MergedChannels);\n                process.start(QString(\"chroot %1 ./boot_fix.sh %2 %3 /deepin-clone\")\n                              .arg(mount_root)\n                              .arg(parent_device)\n                              .arg(is_efi ? \"true\" : \"false\"));\n\n                while (process.waitForReadyRead()) {\n                    const QByteArray &data = process.readAll().simplified().constData();\n\n                    dCDebug(data.constData());\n                }\n\n                process.waitForFinished(-1);\n\n                switch (process.exitCode()) {\n                case 1:\n                    m_lastErrorString = QObject::tr(\"Boot for install system failed\");\n                    break;\n                case 2:\n                    m_lastErrorString = QObject::tr(\"Boot for update system failed\");\n                    break;\n                default:\n                    break;\n                }\n            }\n        }\n\n        // clear\n        Helper::processExec(\"umount \" + repo_mount_point);\n        QDir(mount_root).rmdir(\"deepin-clone\");\n        file_boot_fix.remove();\n        Helper::processExec(\"umount \" + mount_root + \"/dev/pts\");\n        Helper::processExec(\"umount \" + mount_root + \"/dev\");\n        Helper::processExec(\"umount \" + mount_root + \"/proc\");\n        Helper::processExec(\"umount \" + mount_root + \"/sys\");\n        Helper::processExec(\"umount \" + mount_root + \"/boot/efi\");\n\n        if (ok && process.exitCode() == 0) {\n            if (part_old_uuid != part_info.uuid()) {\n                dCDebug(\"Reset the uuid from \\\"%s\\\" to \\\"%s\\\"\", qPrintable(part_old_uuid), qPrintable(part_info.uuid()));\n\n                // update /etc/fstab\n                QFile file(mount_root + \"/etc/fstab\");\n\n                if (file.exists() && file.open(QIODevice::ReadWrite)) {\n                    QByteArray data = file.readAll();\n\n                    if (file.seek(0)) {\n                        file.write(data.replace(part_old_uuid.toLatin1(), part_info.uuid().toLatin1()));\n                    }\n\n                    file.close();\n                } else {\n                    dCWarning(\"Failed to update /etc/fstab, error: %s\", qPrintable(file.errorString()));\n                }\n\n                file.setFileName(mount_root + \"/etc/crypttab\");\n\n                if (file.exists() && file.open(QIODevice::ReadWrite)) {\n                    QByteArray data = file.readAll();\n\n                    if (file.seek(0)) {\n                        file.write(data.replace(part_old_uuid.toLatin1(), part_info.uuid().toLatin1()));\n                    }\n\n                    file.close();\n                } else {\n                    dCWarning(\"Failed to update /etc/crypttab, error: %s\", qPrintable(file.errorString()));\n                }\n            }\n\n            if (!device_is_mounted)\n                Helper::umountDevice(partDevice);\n\n            return true;\n        }\n    }\n\nfailed:\n    if (!device_is_mounted)\n        Helper::umountDevice(partDevice);\n\n    if (m_lastErrorString.isEmpty())\n        m_lastErrorString = QObject::tr(\"Boot for repair system failed\");\n\n    dCDebug(\"Restore partition uuid\");\n\n    if (!Helper::resetPartUUID(part_info, part_old_uuid.toLatin1())) {\n        dCWarning(\"Failed to restore partition uuid, part: %s, uuid: %s\", qPrintable(partDevice), qPrintable(part_old_uuid));\n    }\n\n    return false;\n}",
  "abstract_func": "bool BootDoctor::fix(const QString &VAR_0)\n{\n    VAR_1.clear();\n\n    DDevicePartInfo part_info(partDevice);\n    const QString VAR_2 = VAR_3.uuid();\n\n    if (Helper::processExec(\"lsblk -s -d -n -o UUID\") == 0) {\n        if (Helper::lastProcessStandardOutput().contains(VAR_2.toLatin1())) {\n            /* COMMENT_0 */\n            if (Helper::resetPartUUID(VAR_3)) {\n                QThread::sleep(1);\n                VAR_3.refresh();\n\n                qDebug() << VAR_2 << VAR_3.uuid();\n            } else {\n                dCWarning(\"Failed to reset uuid\");\n            }\n        }\n    }\n\n    bool VAR_4 = Helper::isMounted(partDevice);\n    const QString &VAR_5 = Helper::temporaryMountDevice(partDevice, QFileInfo(partDevice).fileName());\n\n    if (VAR_5.isEmpty()) {\n        VAR_1 = QObject::tr(\"Failed to mount partition \\\"%1\\\"\").arg(partDevice);\n        goto failed;\n    }\n\n    {\n        const QString VAR_6 = \"/var/cache/deepin-clone\";\n\n        if (!QDir::current().mkpath(VAR_6)) {\n            dCError(\"mkpath \\\"%s\\\" failed\", qPrintable(VAR_6));\n            goto failed;\n        }\n\n        const QString &VAR_7 = VAR_6 + \"/repo.iso\";\n\n        if (!QFile::exists(VAR_7)\n                && !QFile::copy(QString(\":/repo_%1.iso\").arg(VAR_8), VAR_7)) {\n            dCError(\"copy file failed, new name: %s\", qPrintable(VAR_7));\n            goto failed;\n        }\n\n        bool VAR_9 = false;\n\n        const QString &VAR_10 = VAR_5 + \"/deepin-clone\";\n        QFile VAR_11(VAR_5 + \"/boot_fix.sh\");\n\n        do {\n            if (!QDir(VAR_5).exists(\"deepin-clone\") && !QDir(VAR_5).mkdir(\"deepin-clone\")) {\n                dCError(\"Create \\\"deepin-clone\\\" dir failed(\\\"%s\\\")\", qPrintable(VAR_5));\n                break;\n            }\n\n            if (!Helper::mountDevice(VAR_7, VAR_10, true)) {\n                VAR_1 = QObject::tr(\"Failed to mount partition \\\"%1\\\"\").arg(VAR_7);\n                break;\n            }\n\n            if (VAR_11.exists()) {\n                VAR_11.remove();\n            }\n\n            if (!QFile::copy(QString(\":/scripts/boot_fix_%1.sh\").arg(\n                     #if defined(VAR_12) || defined(VAR_13) || defined(VAR_14)\n                                 \"x86\"\n                     #elif defined(VAR_15) || defined(VAR_16)\n                                 \"mips\"\n                     #elif defined(VAR_17)\n                                 \"sw_64\"\n                     #elif defined(VAR_18)\n                                 \"aarch64\"\n                     #else\n                     #pragma VAR_19 \"VAR_20: \" HOST_ARCH\n                                \"unknow\"\n                     #endif\n                                 ), VAR_11.fileName())) {\n                dCError(\"copy file failed, new name: %s\", qPrintable(VAR_11.fileName()));\n                break;\n            }\n\n            if (!VAR_11.setPermissions(VAR_11.permissions() | QFile::ExeUser)) {\n                dCError(\"Set \\\"%s\\\" permissions failed\", qPrintable(VAR_11.fileName()));\n                break;\n            }\n\n            if (Helper::processExec(QString(\"mount --bind -v --bind /dev %1/dev\").arg(VAR_5)) != 0) {\n                dCError(\"Failed to bind /dev\");\n                break;\n            }\n\n            if (Helper::processExec(QString(\"mount --bind -v --bind /dev/pts %1/dev/pts\").arg(VAR_5)) != 0) {\n                dCError(\"Failed to bind /dev/pts\");\n                break;\n            }\n\n            if (Helper::processExec(QString(\"mount --bind -v --bind /proc %1/proc\").arg(VAR_5)) != 0) {\n                dCError(\"Failed to bind /proc\");\n                break;\n            }\n\n            if (Helper::processExec(QString(\"mount --bind -v --bind /sys %1/sys\").arg(VAR_5)) != 0) {\n                dCError(\"Failed to bind /sys\");\n                break;\n            }\n\n            VAR_9 = true;\n        } while (0);\n\n        QProcess VAR_21;\n\n        if (VAR_9) {\n            const QString &VAR_22 = Helper::parentDevice(partDevice);\n\n            bool VAR_23 = false;\n\n            if (!VAR_22.isEmpty()) {\n                DDeviceDiskInfo info(parent_device);\n\n                dCDebug(\"Disk partition table type: %d\", VAR_24.ptType());\n\n                if (VAR_24.ptType() == DDeviceDiskInfo::GPT) {\n                    for (const DPartInfo &VAR_25 : VAR_24.childrenPartList()) {\n                        if (VAR_25.guidType() == DPartInfo::EFI_SP_None) {\n                            const QString &VAR_26 = VAR_5 + \"/boot/efi\";\n\n                            QDir::current().mkpath(VAR_26);\n\n                            if (Helper::processExec(QString(\"mount %1 %2\").arg(VAR_25.filePath()).arg(VAR_26)) != 0) {\n                                dCError(\"Failed to mount EFI partition\");\n                                VAR_1 = QObject::tr(\"Failed to mount partition \\\"%1\\\"\").arg(VAR_25.filePath());\n                                VAR_9 = false;\n                                break;\n                            }\n\n                            VAR_23 = true;\n\n                            break;\n                        }\n                    }\n\n                    if (!VAR_23 && VAR_1.isEmpty()) {\n                        VAR_1 = QObject::tr(\"EFI partition not found\");\n                        VAR_9 = false;\n                    }\n                } else if (VAR_24.ptType() == DDeviceDiskInfo::Unknow) {\n                    VAR_1 = QObject::tr(\"Unknown partition style\");\n                    VAR_9 = false;\n                }\n            }\n\n            if (VAR_9) {\n                VAR_21.setProcessChannelMode(QProcess::MergedChannels);\n                VAR_21.start(QString(\"chroot %1 ./boot_fix.sh %2 %3 /deepin-clone\")\n                              .arg(VAR_5)\n                              .arg(parent_device)\n                              .arg(VAR_23 ? \"true\" : \"false\"));\n\n                while (VAR_21.waitForReadyRead()) {\n                    const QByteArray &VAR_27 = VAR_21.readAll().simplified().constData();\n\n                    dCDebug(VAR_27.constData());\n                }\n\n                VAR_21.waitForFinished(-1);\n\n                switch (VAR_21.exitCode()) {\n                case 1:\n                    VAR_1 = QObject::tr(\"Boot for install system failed\");\n                    break;\n                case 2:\n                    VAR_1 = QObject::tr(\"Boot for update system failed\");\n                    break;\n                default:\n                    break;\n                }\n            }\n        }\n\n        /* COMMENT_1 */\n        Helper::processExec(\"umount \" + VAR_10);\n        QDir(VAR_5).rmdir(\"deepin-clone\");\n        VAR_11.remove();\n        Helper::processExec(\"umount \" + VAR_5 + \"/dev/pts\");\n        Helper::processExec(\"umount \" + VAR_5 + \"/dev\");\n        Helper::processExec(\"umount \" + VAR_5 + \"/proc\");\n        Helper::processExec(\"umount \" + VAR_5 + \"/sys\");\n        Helper::processExec(\"umount \" + VAR_5 + \"/boot/efi\");\n\n        if (VAR_9 && VAR_21.exitCode() == 0) {\n            if (VAR_2 != VAR_3.uuid()) {\n                dCDebug(\"Reset the uuid from \\\"%s\\\" to \\\"%s\\\"\", qPrintable(VAR_2), qPrintable(VAR_3.uuid()));\n\n                /* COMMENT_2 */\n                QFile VAR_28(VAR_5 + \"/etc/fstab\");\n\n                if (VAR_28.exists() && VAR_28.open(QIODevice::ReadWrite)) {\n                    QByteArray VAR_27 = VAR_28.readAll();\n\n                    if (VAR_28.seek(0)) {\n                        VAR_28.write(VAR_27.replace(VAR_2.toLatin1(), VAR_3.uuid().toLatin1()));\n                    }\n\n                    VAR_28.close();\n                } else {\n                    dCWarning(\"Failed to update /etc/fstab, error: %s\", qPrintable(VAR_28.errorString()));\n                }\n\n                VAR_28.setFileName(VAR_5 + \"/etc/crypttab\");\n\n                if (VAR_28.exists() && VAR_28.open(QIODevice::ReadWrite)) {\n                    QByteArray VAR_27 = VAR_28.readAll();\n\n                    if (VAR_28.seek(0)) {\n                        VAR_28.write(VAR_27.replace(VAR_2.toLatin1(), VAR_3.uuid().toLatin1()));\n                    }\n\n                    VAR_28.close();\n                } else {\n                    dCWarning(\"Failed to update /etc/crypttab, error: %s\", qPrintable(VAR_28.errorString()));\n                }\n            }\n\n            if (!VAR_4)\n                Helper::umountDevice(partDevice);\n\n            return true;\n        }\n    }\n\nfailed:\n    if (!VAR_4)\n        Helper::umountDevice(partDevice);\n\n    if (VAR_1.isEmpty())\n        VAR_1 = QObject::tr(\"Boot for repair system failed\");\n\n    dCDebug(\"Restore partition uuid\");\n\n    if (!Helper::resetPartUUID(VAR_3, VAR_2.toLatin1())) {\n        dCWarning(\"Failed to restore partition uuid, part: %s, uuid: %s\", qPrintable(partDevice), qPrintable(VAR_2));\n    }\n\n    return false;\n}",
  "func_graph_path": "linuxdeepin/deepin-clone/e079f3e2712b4f8c28e3e63e71ba1a1f90fce1ab/bootdoctor.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -28,8 +28,7 @@\n     }\n \n     {\n-        const QStringList &tmp_paths = QStandardPaths::standardLocations(QStandardPaths::TempLocation);\n-        const QString tmp_dir = (tmp_paths.isEmpty() ? \"/tmp\" : tmp_paths.first()) + \"/.deepin-clone\";\n+        const QString tmp_dir = \"/var/cache/deepin-clone\";\n \n         if (!QDir::current().mkpath(tmp_dir)) {\n             dCError(\"mkpath \\\"%s\\\" failed\", qPrintable(tmp_dir));",
  "diff_line_info": {
    "deleted_lines": [
      "        const QStringList &tmp_paths = QStandardPaths::standardLocations(QStandardPaths::TempLocation);",
      "        const QString tmp_dir = (tmp_paths.isEmpty() ? \"/tmp\" : tmp_paths.first()) + \"/.deepin-clone\";"
    ],
    "added_lines": [
      "        const QString tmp_dir = \"/var/cache/deepin-clone\";"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/linuxdeepin/deepin-clone/pull/18",
  "description": {
    "pr_info": {
      "title": "修复隐藏的安全隐患",
      "number": 18
    },
    "comment": [
      "任何位置都不在使用 /tmp 目录\r\n所有的命令调用都把命令和参数分开传递给QProcess\n\n<!-- Reviewable:start -->\n---\nThis change is [<img src=\"https://reviewable.io/review_button.svg\" height=\"34\" align=\"absmiddle\" alt=\"Reviewable\"/>](https://reviewable.io/reviews/linuxdeepin/deepin-clone/18)\n<!-- Reviewable:end -->\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch modifies the temporary directory used by the application, changing from an insecure \"/tmp\" to a more secure \"/var/cache/deepin-clone\". This addresses a potential security vulnerability by mitigating risks associated with using a world-writable directory.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 0.95"
}