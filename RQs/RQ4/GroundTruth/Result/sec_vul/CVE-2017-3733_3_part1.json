{
  "cve_id": "CVE-2017-3733",
  "cwe_ids": [
    "CWE-20"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "openssl",
  "commit_msg": "Don't change the state of the ETM flags until CCS processing\n\nChanging the ciphersuite during a renegotiation can result in a crash\nleading to a DoS attack. ETM has not been implemented in 1.1.0 for DTLS\nso this is TLS only.\n\nThe problem is caused by changing the flag indicating whether to use ETM\nor not immediately on negotiation of ETM, rather than at CCS. Therefore,\nduring a renegotiation, if the ETM state is changing (usually due to a\nchange of ciphersuite), then an error/crash will occur.\n\nDue to the fact that there are separate CCS messages for read and write\nwe actually now need two flags to determine whether to use ETM or not.\n\nCVE-2017-3733\n\nReviewed-by: Richard Levitte <levitte@openssl.org>",
  "commit_hash": "4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2",
  "git_url": "https://github.com/openssl/openssl/commit/4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2",
  "file_path": "ssl/t1_enc.c",
  "func_name": "tls1_change_cipher_state",
  "func_before": "int tls1_change_cipher_state(SSL *s, int which)\n{\n    unsigned char *p, *mac_secret;\n    unsigned char tmp1[EVP_MAX_KEY_LENGTH];\n    unsigned char tmp2[EVP_MAX_KEY_LENGTH];\n    unsigned char iv1[EVP_MAX_IV_LENGTH * 2];\n    unsigned char iv2[EVP_MAX_IV_LENGTH * 2];\n    unsigned char *ms, *key, *iv;\n    EVP_CIPHER_CTX *dd;\n    const EVP_CIPHER *c;\n#ifndef OPENSSL_NO_COMP\n    const SSL_COMP *comp;\n#endif\n    const EVP_MD *m;\n    int mac_type;\n    int *mac_secret_size;\n    EVP_MD_CTX *mac_ctx;\n    EVP_PKEY *mac_key;\n    int n, i, j, k, cl;\n    int reuse_dd = 0;\n\n    c = s->s3->tmp.new_sym_enc;\n    m = s->s3->tmp.new_hash;\n    mac_type = s->s3->tmp.new_mac_pkey_type;\n#ifndef OPENSSL_NO_COMP\n    comp = s->s3->tmp.new_compression;\n#endif\n\n    if (which & SSL3_CC_READ) {\n        if (s->s3->tmp.new_cipher->algorithm2 & TLS1_STREAM_MAC)\n            s->mac_flags |= SSL_MAC_FLAG_READ_MAC_STREAM;\n        else\n            s->mac_flags &= ~SSL_MAC_FLAG_READ_MAC_STREAM;\n\n        if (s->enc_read_ctx != NULL)\n            reuse_dd = 1;\n        else if ((s->enc_read_ctx = EVP_CIPHER_CTX_new()) == NULL)\n            goto err;\n        else\n            /*\n             * make sure it's initialised in case we exit later with an error\n             */\n            EVP_CIPHER_CTX_reset(s->enc_read_ctx);\n        dd = s->enc_read_ctx;\n        mac_ctx = ssl_replace_hash(&s->read_hash, NULL);\n        if (mac_ctx == NULL)\n            goto err;\n#ifndef OPENSSL_NO_COMP\n        COMP_CTX_free(s->expand);\n        s->expand = NULL;\n        if (comp != NULL) {\n            s->expand = COMP_CTX_new(comp->method);\n            if (s->expand == NULL) {\n                SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,\n                       SSL_R_COMPRESSION_LIBRARY_ERROR);\n                goto err2;\n            }\n        }\n#endif\n        /*\n         * this is done by dtls1_reset_seq_numbers for DTLS\n         */\n        if (!SSL_IS_DTLS(s))\n            RECORD_LAYER_reset_read_sequence(&s->rlayer);\n        mac_secret = &(s->s3->read_mac_secret[0]);\n        mac_secret_size = &(s->s3->read_mac_secret_size);\n    } else {\n        if (s->s3->tmp.new_cipher->algorithm2 & TLS1_STREAM_MAC)\n            s->mac_flags |= SSL_MAC_FLAG_WRITE_MAC_STREAM;\n        else\n            s->mac_flags &= ~SSL_MAC_FLAG_WRITE_MAC_STREAM;\n        if (s->enc_write_ctx != NULL && !SSL_IS_DTLS(s))\n            reuse_dd = 1;\n        else if ((s->enc_write_ctx = EVP_CIPHER_CTX_new()) == NULL)\n            goto err;\n        dd = s->enc_write_ctx;\n        if (SSL_IS_DTLS(s)) {\n            mac_ctx = EVP_MD_CTX_new();\n            if (mac_ctx == NULL)\n                goto err;\n            s->write_hash = mac_ctx;\n        } else {\n            mac_ctx = ssl_replace_hash(&s->write_hash, NULL);\n            if (mac_ctx == NULL)\n                goto err;\n        }\n#ifndef OPENSSL_NO_COMP\n        COMP_CTX_free(s->compress);\n        s->compress = NULL;\n        if (comp != NULL) {\n            s->compress = COMP_CTX_new(comp->method);\n            if (s->compress == NULL) {\n                SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,\n                       SSL_R_COMPRESSION_LIBRARY_ERROR);\n                goto err2;\n            }\n        }\n#endif\n        /*\n         * this is done by dtls1_reset_seq_numbers for DTLS\n         */\n        if (!SSL_IS_DTLS(s))\n            RECORD_LAYER_reset_write_sequence(&s->rlayer);\n        mac_secret = &(s->s3->write_mac_secret[0]);\n        mac_secret_size = &(s->s3->write_mac_secret_size);\n    }\n\n    if (reuse_dd)\n        EVP_CIPHER_CTX_reset(dd);\n\n    p = s->s3->tmp.key_block;\n    i = *mac_secret_size = s->s3->tmp.new_mac_secret_size;\n\n    cl = EVP_CIPHER_key_length(c);\n    j = cl;\n    /* Was j=(exp)?5:EVP_CIPHER_key_length(c); */\n    /* If GCM/CCM mode only part of IV comes from PRF */\n    if (EVP_CIPHER_mode(c) == EVP_CIPH_GCM_MODE)\n        k = EVP_GCM_TLS_FIXED_IV_LEN;\n    else if (EVP_CIPHER_mode(c) == EVP_CIPH_CCM_MODE)\n        k = EVP_CCM_TLS_FIXED_IV_LEN;\n    else\n        k = EVP_CIPHER_iv_length(c);\n    if ((which == SSL3_CHANGE_CIPHER_CLIENT_WRITE) ||\n        (which == SSL3_CHANGE_CIPHER_SERVER_READ)) {\n        ms = &(p[0]);\n        n = i + i;\n        key = &(p[n]);\n        n += j + j;\n        iv = &(p[n]);\n        n += k + k;\n    } else {\n        n = i;\n        ms = &(p[n]);\n        n += i + j;\n        key = &(p[n]);\n        n += j + k;\n        iv = &(p[n]);\n        n += k;\n    }\n\n    if (n > s->s3->tmp.key_block_length) {\n        SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR);\n        goto err2;\n    }\n\n    memcpy(mac_secret, ms, i);\n\n    if (!(EVP_CIPHER_flags(c) & EVP_CIPH_FLAG_AEAD_CIPHER)) {\n        mac_key = EVP_PKEY_new_mac_key(mac_type, NULL,\n                                       mac_secret, *mac_secret_size);\n        if (mac_key == NULL\n            || EVP_DigestSignInit(mac_ctx, NULL, m, NULL, mac_key) <= 0) {\n            EVP_PKEY_free(mac_key);\n            SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR);\n            goto err2;\n        }\n        EVP_PKEY_free(mac_key);\n    }\n#ifdef SSL_DEBUG\n    printf(\"which = %04X\\nmac key=\", which);\n    {\n        int z;\n        for (z = 0; z < i; z++)\n            printf(\"%02X%c\", ms[z], ((z + 1) % 16) ? ' ' : '\\n');\n    }\n#endif\n\n    if (EVP_CIPHER_mode(c) == EVP_CIPH_GCM_MODE) {\n        if (!EVP_CipherInit_ex(dd, c, NULL, key, NULL, (which & SSL3_CC_WRITE))\n            || !EVP_CIPHER_CTX_ctrl(dd, EVP_CTRL_GCM_SET_IV_FIXED, k, iv)) {\n            SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR);\n            goto err2;\n        }\n    } else if (EVP_CIPHER_mode(c) == EVP_CIPH_CCM_MODE) {\n        int taglen;\n        if (s->s3->tmp.\n            new_cipher->algorithm_enc & (SSL_AES128CCM8 | SSL_AES256CCM8))\n            taglen = 8;\n        else\n            taglen = 16;\n        if (!EVP_CipherInit_ex(dd, c, NULL, NULL, NULL, (which & SSL3_CC_WRITE))\n            || !EVP_CIPHER_CTX_ctrl(dd, EVP_CTRL_AEAD_SET_IVLEN, 12, NULL)\n            || !EVP_CIPHER_CTX_ctrl(dd, EVP_CTRL_AEAD_SET_TAG, taglen, NULL)\n            || !EVP_CIPHER_CTX_ctrl(dd, EVP_CTRL_CCM_SET_IV_FIXED, k, iv)\n            || !EVP_CipherInit_ex(dd, NULL, NULL, key, NULL, -1)) {\n            SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR);\n            goto err2;\n        }\n    } else {\n        if (!EVP_CipherInit_ex(dd, c, NULL, key, iv, (which & SSL3_CC_WRITE))) {\n            SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR);\n            goto err2;\n        }\n    }\n    /* Needed for \"composite\" AEADs, such as RC4-HMAC-MD5 */\n    if ((EVP_CIPHER_flags(c) & EVP_CIPH_FLAG_AEAD_CIPHER) && *mac_secret_size\n        && !EVP_CIPHER_CTX_ctrl(dd, EVP_CTRL_AEAD_SET_MAC_KEY,\n                                *mac_secret_size, mac_secret)) {\n        SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR);\n        goto err2;\n    }\n#ifdef OPENSSL_SSL_TRACE_CRYPTO\n    if (s->msg_callback) {\n        int wh = which & SSL3_CC_WRITE ? TLS1_RT_CRYPTO_WRITE : 0;\n        if (*mac_secret_size)\n            s->msg_callback(2, s->version, wh | TLS1_RT_CRYPTO_MAC,\n                            mac_secret, *mac_secret_size,\n                            s, s->msg_callback_arg);\n        if (c->key_len)\n            s->msg_callback(2, s->version, wh | TLS1_RT_CRYPTO_KEY,\n                            key, c->key_len, s, s->msg_callback_arg);\n        if (k) {\n            if (EVP_CIPHER_mode(c) == EVP_CIPH_GCM_MODE)\n                wh |= TLS1_RT_CRYPTO_FIXED_IV;\n            else\n                wh |= TLS1_RT_CRYPTO_IV;\n            s->msg_callback(2, s->version, wh, iv, k, s, s->msg_callback_arg);\n        }\n    }\n#endif\n\n#ifdef SSL_DEBUG\n    printf(\"which = %04X\\nkey=\", which);\n    {\n        int z;\n        for (z = 0; z < EVP_CIPHER_key_length(c); z++)\n            printf(\"%02X%c\", key[z], ((z + 1) % 16) ? ' ' : '\\n');\n    }\n    printf(\"\\niv=\");\n    {\n        int z;\n        for (z = 0; z < k; z++)\n            printf(\"%02X%c\", iv[z], ((z + 1) % 16) ? ' ' : '\\n');\n    }\n    printf(\"\\n\");\n#endif\n\n    OPENSSL_cleanse(tmp1, sizeof(tmp1));\n    OPENSSL_cleanse(tmp2, sizeof(tmp1));\n    OPENSSL_cleanse(iv1, sizeof(iv1));\n    OPENSSL_cleanse(iv2, sizeof(iv2));\n    return (1);\n err:\n    SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE, ERR_R_MALLOC_FAILURE);\n err2:\n    OPENSSL_cleanse(tmp1, sizeof(tmp1));\n    OPENSSL_cleanse(tmp2, sizeof(tmp1));\n    OPENSSL_cleanse(iv1, sizeof(iv1));\n    OPENSSL_cleanse(iv2, sizeof(iv2));\n    return (0);\n}",
  "abstract_func_before": "int tls1_change_cipher_state(SSL *VAR_0, int VAR_1)\n{\n    unsigned char *VAR_2, *VAR_3;\n    unsigned char VAR_4[VAR_5];\n    unsigned char VAR_6[VAR_5];\n    unsigned char VAR_7[VAR_8 * 2];\n    unsigned char VAR_9[VAR_8 * 2];\n    unsigned char *VAR_10, *VAR_11, *VAR_12;\n    EVP_CIPHER_CTX *VAR_13;\n    const EVP_CIPHER *VAR_14;\n#ifndef VAR_15\n    const SSL_COMP *VAR_16;\n#endif\n    const EVP_MD *VAR_17;\n    int VAR_18;\n    int *VAR_19;\n    EVP_MD_CTX *VAR_20;\n    EVP_PKEY *VAR_21;\n    int VAR_22, VAR_23, VAR_24, VAR_25, VAR_26;\n    int VAR_27 = 0;\n\n    VAR_14 = VAR_0->s3->tmp.new_sym_enc;\n    VAR_17 = VAR_0->s3->tmp.new_hash;\n    VAR_18 = VAR_0->s3->tmp.new_mac_pkey_type;\n#ifndef VAR_15\n    VAR_16 = VAR_0->s3->tmp.new_compression;\n#endif\n\n    if (VAR_1 & VAR_28) {\n        if (VAR_0->s3->tmp.new_cipher->algorithm2 & VAR_29)\n            VAR_0->mac_flags |= VAR_30;\n        else\n            VAR_0->mac_flags &= ~VAR_30;\n\n        if (VAR_0->enc_read_ctx != NULL)\n            VAR_27 = 1;\n        else if ((VAR_0->enc_read_ctx = EVP_CIPHER_CTX_new()) == NULL)\n            goto err;\n        else\n            /* COMMENT_0 */\n                                                                             \n               \n            EVP_CIPHER_CTX_reset(VAR_0->enc_read_ctx);\n        VAR_13 = VAR_0->enc_read_ctx;\n        VAR_20 = ssl_replace_hash(&VAR_0->read_hash, NULL);\n        if (VAR_20 == NULL)\n            goto err;\n#ifndef VAR_15\n        COMP_CTX_free(VAR_0->expand);\n        VAR_0->expand = NULL;\n        if (VAR_16 != NULL) {\n            VAR_0->expand = COMP_CTX_new(VAR_16->method);\n            if (VAR_0->expand == NULL) {\n                SSLerr(VAR_31,\n                       VAR_32);\n                goto err2;\n            }\n        }\n#endif\n        /* COMMENT_3 */\n                                                           \n           \n        if (!SSL_IS_DTLS(VAR_0))\n            RECORD_LAYER_reset_read_sequence(&VAR_0->rlayer);\n        VAR_3 = &(VAR_0->s3->read_mac_secret[0]);\n        VAR_19 = &(VAR_0->s3->read_mac_secret_size);\n    } else {\n        if (VAR_0->s3->tmp.new_cipher->algorithm2 & VAR_29)\n            VAR_0->mac_flags |= VAR_33;\n        else\n            VAR_0->mac_flags &= ~VAR_33;\n        if (VAR_0->enc_write_ctx != NULL && !SSL_IS_DTLS(VAR_0))\n            VAR_27 = 1;\n        else if ((VAR_0->enc_write_ctx = EVP_CIPHER_CTX_new()) == NULL)\n            goto err;\n        VAR_13 = VAR_0->enc_write_ctx;\n        if (SSL_IS_DTLS(VAR_0)) {\n            VAR_20 = EVP_MD_CTX_new();\n            if (VAR_20 == NULL)\n                goto err;\n            VAR_0->write_hash = VAR_20;\n        } else {\n            VAR_20 = ssl_replace_hash(&VAR_0->write_hash, NULL);\n            if (VAR_20 == NULL)\n                goto err;\n        }\n#ifndef VAR_15\n        COMP_CTX_free(VAR_0->compress);\n        VAR_0->compress = NULL;\n        if (VAR_16 != NULL) {\n            VAR_0->compress = COMP_CTX_new(VAR_16->method);\n            if (VAR_0->compress == NULL) {\n                SSLerr(VAR_31,\n                       VAR_32);\n                goto err2;\n            }\n        }\n#endif\n        /* COMMENT_6 */\n                                                           \n           \n        if (!SSL_IS_DTLS(VAR_0))\n            RECORD_LAYER_reset_write_sequence(&VAR_0->rlayer);\n        VAR_3 = &(VAR_0->s3->write_mac_secret[0]);\n        VAR_19 = &(VAR_0->s3->write_mac_secret_size);\n    }\n\n    if (VAR_27)\n        EVP_CIPHER_CTX_reset(VAR_13);\n\n    VAR_2 = VAR_0->s3->tmp.key_block;\n    VAR_23 = *VAR_19 = VAR_0->s3->tmp.new_mac_secret_size;\n\n    VAR_26 = EVP_CIPHER_key_length(VAR_14);\n    VAR_24 = VAR_26;\n    /* COMMENT_9 */\n    /* COMMENT_10 */\n    if (EVP_CIPHER_mode(VAR_14) == VAR_34)\n        VAR_25 = VAR_35;\n    else if (EVP_CIPHER_mode(VAR_14) == VAR_36)\n        VAR_25 = VAR_37;\n    else\n        VAR_25 = EVP_CIPHER_iv_length(VAR_14);\n    if ((VAR_1 == VAR_38) ||\n        (VAR_1 == VAR_39)) {\n        VAR_10 = &(VAR_2[0]);\n        VAR_22 = VAR_23 + VAR_23;\n        VAR_11 = &(VAR_2[VAR_22]);\n        VAR_22 += VAR_24 + VAR_24;\n        VAR_12 = &(VAR_2[VAR_22]);\n        VAR_22 += VAR_25 + VAR_25;\n    } else {\n        VAR_22 = VAR_23;\n        VAR_10 = &(VAR_2[VAR_22]);\n        VAR_22 += VAR_23 + VAR_24;\n        VAR_11 = &(VAR_2[VAR_22]);\n        VAR_22 += VAR_24 + VAR_25;\n        VAR_12 = &(VAR_2[VAR_22]);\n        VAR_22 += VAR_25;\n    }\n\n    if (VAR_22 > VAR_0->s3->tmp.key_block_length) {\n        SSLerr(VAR_31, VAR_40);\n        goto err2;\n    }\n\n    memcpy(VAR_3, VAR_10, VAR_23);\n\n    if (!(EVP_CIPHER_flags(VAR_14) & VAR_41)) {\n        VAR_21 = EVP_PKEY_new_mac_key(VAR_18, NULL,\n                                       VAR_3, *VAR_19);\n        if (VAR_21 == NULL\n            || EVP_DigestSignInit(VAR_20, NULL, VAR_17, NULL, VAR_21) <= 0) {\n            EVP_PKEY_free(VAR_21);\n            SSLerr(VAR_31, VAR_40);\n            goto err2;\n        }\n        EVP_PKEY_free(VAR_21);\n    }\n#ifdef VAR_42\n    printf(\"which = %04X\\nmac key=\", VAR_1);\n    {\n        int VAR_43;\n        for (VAR_43 = 0; VAR_43 < VAR_23; VAR_43++)\n            printf(\"%02X%c\", VAR_10[VAR_43], ((VAR_43 + 1) % 16) ? ' ' : '\\n');\n    }\n#endif\n\n    if (EVP_CIPHER_mode(VAR_14) == VAR_34) {\n        if (!EVP_CipherInit_ex(VAR_13, VAR_14, NULL, VAR_11, NULL, (VAR_1 & VAR_44))\n            || !EVP_CIPHER_CTX_ctrl(VAR_13, VAR_45, VAR_25, VAR_12)) {\n            SSLerr(VAR_31, VAR_40);\n            goto err2;\n        }\n    } else if (EVP_CIPHER_mode(VAR_14) == VAR_36) {\n        int VAR_46;\n        if (VAR_0->s3->tmp.\n            new_cipher->algorithm_enc & (VAR_47 | VAR_48))\n            VAR_46 = 8;\n        else\n            VAR_46 = 16;\n        if (!EVP_CipherInit_ex(VAR_13, VAR_14, NULL, NULL, NULL, (VAR_1 & VAR_44))\n            || !EVP_CIPHER_CTX_ctrl(VAR_13, VAR_49, 12, NULL)\n            || !EVP_CIPHER_CTX_ctrl(VAR_13, VAR_50, VAR_46, NULL)\n            || !EVP_CIPHER_CTX_ctrl(VAR_13, VAR_51, VAR_25, VAR_12)\n            || !EVP_CipherInit_ex(VAR_13, NULL, NULL, VAR_11, NULL, -1)) {\n            SSLerr(VAR_31, VAR_40);\n            goto err2;\n        }\n    } else {\n        if (!EVP_CipherInit_ex(VAR_13, VAR_14, NULL, VAR_11, VAR_12, (VAR_1 & VAR_44))) {\n            SSLerr(VAR_31, VAR_40);\n            goto err2;\n        }\n    }\n    /* COMMENT_11 */\n    if ((EVP_CIPHER_flags(VAR_14) & VAR_41) && *VAR_19\n        && !EVP_CIPHER_CTX_ctrl(VAR_13, VAR_52,\n                                *VAR_19, VAR_3)) {\n        SSLerr(VAR_31, VAR_40);\n        goto err2;\n    }\n#ifdef VAR_53\n    if (VAR_0->msg_callback) {\n        int VAR_54 = VAR_1 & VAR_44 ? VAR_55 : 0;\n        if (*VAR_19)\n            VAR_0->msg_callback(2, VAR_0->version, VAR_54 | VAR_56,\n                            VAR_3, *VAR_19,\n                            VAR_0, VAR_0->msg_callback_arg);\n        if (VAR_14->key_len)\n            VAR_0->msg_callback(2, VAR_0->version, VAR_54 | VAR_57,\n                            VAR_11, VAR_14->key_len, VAR_0, VAR_0->msg_callback_arg);\n        if (VAR_25) {\n            if (EVP_CIPHER_mode(VAR_14) == VAR_34)\n                VAR_54 |= VAR_58;\n            else\n                VAR_54 |= VAR_59;\n            VAR_0->msg_callback(2, VAR_0->version, VAR_54, VAR_12, VAR_25, VAR_0, VAR_0->msg_callback_arg);\n        }\n    }\n#endif\n\n#ifdef VAR_42\n    printf(\"which = %04X\\nkey=\", VAR_1);\n    {\n        int VAR_43;\n        for (VAR_43 = 0; VAR_43 < EVP_CIPHER_key_length(VAR_14); VAR_43++)\n            printf(\"%02X%c\", VAR_11[VAR_43], ((VAR_43 + 1) % 16) ? ' ' : '\\n');\n    }\n    printf(\"\\niv=\");\n    {\n        int VAR_43;\n        for (VAR_43 = 0; VAR_43 < VAR_25; VAR_43++)\n            printf(\"%02X%c\", VAR_12[VAR_43], ((VAR_43 + 1) % 16) ? ' ' : '\\n');\n    }\n    printf(\"\\n\");\n#endif\n\n    OPENSSL_cleanse(VAR_4, sizeof(VAR_4));\n    OPENSSL_cleanse(VAR_6, sizeof(VAR_4));\n    OPENSSL_cleanse(VAR_7, sizeof(VAR_7));\n    OPENSSL_cleanse(VAR_9, sizeof(VAR_9));\n    return (1);\n err:\n    SSLerr(VAR_31, VAR_60);\n err2:\n    OPENSSL_cleanse(VAR_4, sizeof(VAR_4));\n    OPENSSL_cleanse(VAR_6, sizeof(VAR_4));\n    OPENSSL_cleanse(VAR_7, sizeof(VAR_7));\n    OPENSSL_cleanse(VAR_9, sizeof(VAR_9));\n    return (0);\n}",
  "func_graph_path_before": "openssl/4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2/t1_enc.c/vul/before/1.json",
  "func": "int tls1_change_cipher_state(SSL *s, int which)\n{\n    unsigned char *p, *mac_secret;\n    unsigned char tmp1[EVP_MAX_KEY_LENGTH];\n    unsigned char tmp2[EVP_MAX_KEY_LENGTH];\n    unsigned char iv1[EVP_MAX_IV_LENGTH * 2];\n    unsigned char iv2[EVP_MAX_IV_LENGTH * 2];\n    unsigned char *ms, *key, *iv;\n    EVP_CIPHER_CTX *dd;\n    const EVP_CIPHER *c;\n#ifndef OPENSSL_NO_COMP\n    const SSL_COMP *comp;\n#endif\n    const EVP_MD *m;\n    int mac_type;\n    int *mac_secret_size;\n    EVP_MD_CTX *mac_ctx;\n    EVP_PKEY *mac_key;\n    int n, i, j, k, cl;\n    int reuse_dd = 0;\n\n    c = s->s3->tmp.new_sym_enc;\n    m = s->s3->tmp.new_hash;\n    mac_type = s->s3->tmp.new_mac_pkey_type;\n#ifndef OPENSSL_NO_COMP\n    comp = s->s3->tmp.new_compression;\n#endif\n\n    if (which & SSL3_CC_READ) {\n        if (s->tlsext_use_etm)\n            s->s3->flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC_READ;\n        else\n            s->s3->flags &= ~TLS1_FLAGS_ENCRYPT_THEN_MAC_READ;\n\n        if (s->s3->tmp.new_cipher->algorithm2 & TLS1_STREAM_MAC)\n            s->mac_flags |= SSL_MAC_FLAG_READ_MAC_STREAM;\n        else\n            s->mac_flags &= ~SSL_MAC_FLAG_READ_MAC_STREAM;\n\n        if (s->enc_read_ctx != NULL)\n            reuse_dd = 1;\n        else if ((s->enc_read_ctx = EVP_CIPHER_CTX_new()) == NULL)\n            goto err;\n        else\n            /*\n             * make sure it's initialised in case we exit later with an error\n             */\n            EVP_CIPHER_CTX_reset(s->enc_read_ctx);\n        dd = s->enc_read_ctx;\n        mac_ctx = ssl_replace_hash(&s->read_hash, NULL);\n        if (mac_ctx == NULL)\n            goto err;\n#ifndef OPENSSL_NO_COMP\n        COMP_CTX_free(s->expand);\n        s->expand = NULL;\n        if (comp != NULL) {\n            s->expand = COMP_CTX_new(comp->method);\n            if (s->expand == NULL) {\n                SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,\n                       SSL_R_COMPRESSION_LIBRARY_ERROR);\n                goto err2;\n            }\n        }\n#endif\n        /*\n         * this is done by dtls1_reset_seq_numbers for DTLS\n         */\n        if (!SSL_IS_DTLS(s))\n            RECORD_LAYER_reset_read_sequence(&s->rlayer);\n        mac_secret = &(s->s3->read_mac_secret[0]);\n        mac_secret_size = &(s->s3->read_mac_secret_size);\n    } else {\n        if (s->tlsext_use_etm)\n            s->s3->flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC_WRITE;\n        else\n            s->s3->flags &= ~TLS1_FLAGS_ENCRYPT_THEN_MAC_WRITE;\n\n        if (s->s3->tmp.new_cipher->algorithm2 & TLS1_STREAM_MAC)\n            s->mac_flags |= SSL_MAC_FLAG_WRITE_MAC_STREAM;\n        else\n            s->mac_flags &= ~SSL_MAC_FLAG_WRITE_MAC_STREAM;\n        if (s->enc_write_ctx != NULL && !SSL_IS_DTLS(s))\n            reuse_dd = 1;\n        else if ((s->enc_write_ctx = EVP_CIPHER_CTX_new()) == NULL)\n            goto err;\n        dd = s->enc_write_ctx;\n        if (SSL_IS_DTLS(s)) {\n            mac_ctx = EVP_MD_CTX_new();\n            if (mac_ctx == NULL)\n                goto err;\n            s->write_hash = mac_ctx;\n        } else {\n            mac_ctx = ssl_replace_hash(&s->write_hash, NULL);\n            if (mac_ctx == NULL)\n                goto err;\n        }\n#ifndef OPENSSL_NO_COMP\n        COMP_CTX_free(s->compress);\n        s->compress = NULL;\n        if (comp != NULL) {\n            s->compress = COMP_CTX_new(comp->method);\n            if (s->compress == NULL) {\n                SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,\n                       SSL_R_COMPRESSION_LIBRARY_ERROR);\n                goto err2;\n            }\n        }\n#endif\n        /*\n         * this is done by dtls1_reset_seq_numbers for DTLS\n         */\n        if (!SSL_IS_DTLS(s))\n            RECORD_LAYER_reset_write_sequence(&s->rlayer);\n        mac_secret = &(s->s3->write_mac_secret[0]);\n        mac_secret_size = &(s->s3->write_mac_secret_size);\n    }\n\n    if (reuse_dd)\n        EVP_CIPHER_CTX_reset(dd);\n\n    p = s->s3->tmp.key_block;\n    i = *mac_secret_size = s->s3->tmp.new_mac_secret_size;\n\n    cl = EVP_CIPHER_key_length(c);\n    j = cl;\n    /* Was j=(exp)?5:EVP_CIPHER_key_length(c); */\n    /* If GCM/CCM mode only part of IV comes from PRF */\n    if (EVP_CIPHER_mode(c) == EVP_CIPH_GCM_MODE)\n        k = EVP_GCM_TLS_FIXED_IV_LEN;\n    else if (EVP_CIPHER_mode(c) == EVP_CIPH_CCM_MODE)\n        k = EVP_CCM_TLS_FIXED_IV_LEN;\n    else\n        k = EVP_CIPHER_iv_length(c);\n    if ((which == SSL3_CHANGE_CIPHER_CLIENT_WRITE) ||\n        (which == SSL3_CHANGE_CIPHER_SERVER_READ)) {\n        ms = &(p[0]);\n        n = i + i;\n        key = &(p[n]);\n        n += j + j;\n        iv = &(p[n]);\n        n += k + k;\n    } else {\n        n = i;\n        ms = &(p[n]);\n        n += i + j;\n        key = &(p[n]);\n        n += j + k;\n        iv = &(p[n]);\n        n += k;\n    }\n\n    if (n > s->s3->tmp.key_block_length) {\n        SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR);\n        goto err2;\n    }\n\n    memcpy(mac_secret, ms, i);\n\n    if (!(EVP_CIPHER_flags(c) & EVP_CIPH_FLAG_AEAD_CIPHER)) {\n        mac_key = EVP_PKEY_new_mac_key(mac_type, NULL,\n                                       mac_secret, *mac_secret_size);\n        if (mac_key == NULL\n            || EVP_DigestSignInit(mac_ctx, NULL, m, NULL, mac_key) <= 0) {\n            EVP_PKEY_free(mac_key);\n            SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR);\n            goto err2;\n        }\n        EVP_PKEY_free(mac_key);\n    }\n#ifdef SSL_DEBUG\n    printf(\"which = %04X\\nmac key=\", which);\n    {\n        int z;\n        for (z = 0; z < i; z++)\n            printf(\"%02X%c\", ms[z], ((z + 1) % 16) ? ' ' : '\\n');\n    }\n#endif\n\n    if (EVP_CIPHER_mode(c) == EVP_CIPH_GCM_MODE) {\n        if (!EVP_CipherInit_ex(dd, c, NULL, key, NULL, (which & SSL3_CC_WRITE))\n            || !EVP_CIPHER_CTX_ctrl(dd, EVP_CTRL_GCM_SET_IV_FIXED, k, iv)) {\n            SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR);\n            goto err2;\n        }\n    } else if (EVP_CIPHER_mode(c) == EVP_CIPH_CCM_MODE) {\n        int taglen;\n        if (s->s3->tmp.\n            new_cipher->algorithm_enc & (SSL_AES128CCM8 | SSL_AES256CCM8))\n            taglen = 8;\n        else\n            taglen = 16;\n        if (!EVP_CipherInit_ex(dd, c, NULL, NULL, NULL, (which & SSL3_CC_WRITE))\n            || !EVP_CIPHER_CTX_ctrl(dd, EVP_CTRL_AEAD_SET_IVLEN, 12, NULL)\n            || !EVP_CIPHER_CTX_ctrl(dd, EVP_CTRL_AEAD_SET_TAG, taglen, NULL)\n            || !EVP_CIPHER_CTX_ctrl(dd, EVP_CTRL_CCM_SET_IV_FIXED, k, iv)\n            || !EVP_CipherInit_ex(dd, NULL, NULL, key, NULL, -1)) {\n            SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR);\n            goto err2;\n        }\n    } else {\n        if (!EVP_CipherInit_ex(dd, c, NULL, key, iv, (which & SSL3_CC_WRITE))) {\n            SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR);\n            goto err2;\n        }\n    }\n    /* Needed for \"composite\" AEADs, such as RC4-HMAC-MD5 */\n    if ((EVP_CIPHER_flags(c) & EVP_CIPH_FLAG_AEAD_CIPHER) && *mac_secret_size\n        && !EVP_CIPHER_CTX_ctrl(dd, EVP_CTRL_AEAD_SET_MAC_KEY,\n                                *mac_secret_size, mac_secret)) {\n        SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR);\n        goto err2;\n    }\n#ifdef OPENSSL_SSL_TRACE_CRYPTO\n    if (s->msg_callback) {\n        int wh = which & SSL3_CC_WRITE ? TLS1_RT_CRYPTO_WRITE : 0;\n        if (*mac_secret_size)\n            s->msg_callback(2, s->version, wh | TLS1_RT_CRYPTO_MAC,\n                            mac_secret, *mac_secret_size,\n                            s, s->msg_callback_arg);\n        if (c->key_len)\n            s->msg_callback(2, s->version, wh | TLS1_RT_CRYPTO_KEY,\n                            key, c->key_len, s, s->msg_callback_arg);\n        if (k) {\n            if (EVP_CIPHER_mode(c) == EVP_CIPH_GCM_MODE)\n                wh |= TLS1_RT_CRYPTO_FIXED_IV;\n            else\n                wh |= TLS1_RT_CRYPTO_IV;\n            s->msg_callback(2, s->version, wh, iv, k, s, s->msg_callback_arg);\n        }\n    }\n#endif\n\n#ifdef SSL_DEBUG\n    printf(\"which = %04X\\nkey=\", which);\n    {\n        int z;\n        for (z = 0; z < EVP_CIPHER_key_length(c); z++)\n            printf(\"%02X%c\", key[z], ((z + 1) % 16) ? ' ' : '\\n');\n    }\n    printf(\"\\niv=\");\n    {\n        int z;\n        for (z = 0; z < k; z++)\n            printf(\"%02X%c\", iv[z], ((z + 1) % 16) ? ' ' : '\\n');\n    }\n    printf(\"\\n\");\n#endif\n\n    OPENSSL_cleanse(tmp1, sizeof(tmp1));\n    OPENSSL_cleanse(tmp2, sizeof(tmp1));\n    OPENSSL_cleanse(iv1, sizeof(iv1));\n    OPENSSL_cleanse(iv2, sizeof(iv2));\n    return (1);\n err:\n    SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE, ERR_R_MALLOC_FAILURE);\n err2:\n    OPENSSL_cleanse(tmp1, sizeof(tmp1));\n    OPENSSL_cleanse(tmp2, sizeof(tmp1));\n    OPENSSL_cleanse(iv1, sizeof(iv1));\n    OPENSSL_cleanse(iv2, sizeof(iv2));\n    return (0);\n}",
  "abstract_func": "int tls1_change_cipher_state(SSL *VAR_0, int VAR_1)\n{\n    unsigned char *VAR_2, *VAR_3;\n    unsigned char VAR_4[VAR_5];\n    unsigned char VAR_6[VAR_5];\n    unsigned char VAR_7[VAR_8 * 2];\n    unsigned char VAR_9[VAR_8 * 2];\n    unsigned char *VAR_10, *VAR_11, *VAR_12;\n    EVP_CIPHER_CTX *VAR_13;\n    const EVP_CIPHER *VAR_14;\n#ifndef VAR_15\n    const SSL_COMP *VAR_16;\n#endif\n    const EVP_MD *VAR_17;\n    int VAR_18;\n    int *VAR_19;\n    EVP_MD_CTX *VAR_20;\n    EVP_PKEY *VAR_21;\n    int VAR_22, VAR_23, VAR_24, VAR_25, VAR_26;\n    int VAR_27 = 0;\n\n    VAR_14 = VAR_0->s3->tmp.new_sym_enc;\n    VAR_17 = VAR_0->s3->tmp.new_hash;\n    VAR_18 = VAR_0->s3->tmp.new_mac_pkey_type;\n#ifndef VAR_15\n    VAR_16 = VAR_0->s3->tmp.new_compression;\n#endif\n\n    if (VAR_1 & VAR_28) {\n        if (VAR_0->tlsext_use_etm)\n            VAR_0->s3->flags |= VAR_29;\n        else\n            VAR_0->s3->flags &= ~VAR_29;\n\n        if (VAR_0->s3->tmp.new_cipher->algorithm2 & VAR_30)\n            VAR_0->mac_flags |= VAR_31;\n        else\n            VAR_0->mac_flags &= ~VAR_31;\n\n        if (VAR_0->enc_read_ctx != NULL)\n            VAR_27 = 1;\n        else if ((VAR_0->enc_read_ctx = EVP_CIPHER_CTX_new()) == NULL)\n            goto err;\n        else\n            /* COMMENT_0 */\n                                                                             \n               \n            EVP_CIPHER_CTX_reset(VAR_0->enc_read_ctx);\n        VAR_13 = VAR_0->enc_read_ctx;\n        VAR_20 = ssl_replace_hash(&VAR_0->read_hash, NULL);\n        if (VAR_20 == NULL)\n            goto err;\n#ifndef VAR_15\n        COMP_CTX_free(VAR_0->expand);\n        VAR_0->expand = NULL;\n        if (VAR_16 != NULL) {\n            VAR_0->expand = COMP_CTX_new(VAR_16->method);\n            if (VAR_0->expand == NULL) {\n                SSLerr(VAR_32,\n                       VAR_33);\n                goto err2;\n            }\n        }\n#endif\n        /* COMMENT_3 */\n                                                           \n           \n        if (!SSL_IS_DTLS(VAR_0))\n            RECORD_LAYER_reset_read_sequence(&VAR_0->rlayer);\n        VAR_3 = &(VAR_0->s3->read_mac_secret[0]);\n        VAR_19 = &(VAR_0->s3->read_mac_secret_size);\n    } else {\n        if (VAR_0->tlsext_use_etm)\n            VAR_0->s3->flags |= VAR_34;\n        else\n            VAR_0->s3->flags &= ~VAR_34;\n\n        if (VAR_0->s3->tmp.new_cipher->algorithm2 & VAR_30)\n            VAR_0->mac_flags |= VAR_35;\n        else\n            VAR_0->mac_flags &= ~VAR_35;\n        if (VAR_0->enc_write_ctx != NULL && !SSL_IS_DTLS(VAR_0))\n            VAR_27 = 1;\n        else if ((VAR_0->enc_write_ctx = EVP_CIPHER_CTX_new()) == NULL)\n            goto err;\n        VAR_13 = VAR_0->enc_write_ctx;\n        if (SSL_IS_DTLS(VAR_0)) {\n            VAR_20 = EVP_MD_CTX_new();\n            if (VAR_20 == NULL)\n                goto err;\n            VAR_0->write_hash = VAR_20;\n        } else {\n            VAR_20 = ssl_replace_hash(&VAR_0->write_hash, NULL);\n            if (VAR_20 == NULL)\n                goto err;\n        }\n#ifndef VAR_15\n        COMP_CTX_free(VAR_0->compress);\n        VAR_0->compress = NULL;\n        if (VAR_16 != NULL) {\n            VAR_0->compress = COMP_CTX_new(VAR_16->method);\n            if (VAR_0->compress == NULL) {\n                SSLerr(VAR_32,\n                       VAR_33);\n                goto err2;\n            }\n        }\n#endif\n        /* COMMENT_6 */\n                                                           \n           \n        if (!SSL_IS_DTLS(VAR_0))\n            RECORD_LAYER_reset_write_sequence(&VAR_0->rlayer);\n        VAR_3 = &(VAR_0->s3->write_mac_secret[0]);\n        VAR_19 = &(VAR_0->s3->write_mac_secret_size);\n    }\n\n    if (VAR_27)\n        EVP_CIPHER_CTX_reset(VAR_13);\n\n    VAR_2 = VAR_0->s3->tmp.key_block;\n    VAR_23 = *VAR_19 = VAR_0->s3->tmp.new_mac_secret_size;\n\n    VAR_26 = EVP_CIPHER_key_length(VAR_14);\n    VAR_24 = VAR_26;\n    /* COMMENT_9 */\n    /* COMMENT_10 */\n    if (EVP_CIPHER_mode(VAR_14) == VAR_36)\n        VAR_25 = VAR_37;\n    else if (EVP_CIPHER_mode(VAR_14) == VAR_38)\n        VAR_25 = VAR_39;\n    else\n        VAR_25 = EVP_CIPHER_iv_length(VAR_14);\n    if ((VAR_1 == VAR_40) ||\n        (VAR_1 == VAR_41)) {\n        VAR_10 = &(VAR_2[0]);\n        VAR_22 = VAR_23 + VAR_23;\n        VAR_11 = &(VAR_2[VAR_22]);\n        VAR_22 += VAR_24 + VAR_24;\n        VAR_12 = &(VAR_2[VAR_22]);\n        VAR_22 += VAR_25 + VAR_25;\n    } else {\n        VAR_22 = VAR_23;\n        VAR_10 = &(VAR_2[VAR_22]);\n        VAR_22 += VAR_23 + VAR_24;\n        VAR_11 = &(VAR_2[VAR_22]);\n        VAR_22 += VAR_24 + VAR_25;\n        VAR_12 = &(VAR_2[VAR_22]);\n        VAR_22 += VAR_25;\n    }\n\n    if (VAR_22 > VAR_0->s3->tmp.key_block_length) {\n        SSLerr(VAR_32, VAR_42);\n        goto err2;\n    }\n\n    memcpy(VAR_3, VAR_10, VAR_23);\n\n    if (!(EVP_CIPHER_flags(VAR_14) & VAR_43)) {\n        VAR_21 = EVP_PKEY_new_mac_key(VAR_18, NULL,\n                                       VAR_3, *VAR_19);\n        if (VAR_21 == NULL\n            || EVP_DigestSignInit(VAR_20, NULL, VAR_17, NULL, VAR_21) <= 0) {\n            EVP_PKEY_free(VAR_21);\n            SSLerr(VAR_32, VAR_42);\n            goto err2;\n        }\n        EVP_PKEY_free(VAR_21);\n    }\n#ifdef VAR_44\n    printf(\"which = %04X\\nmac key=\", VAR_1);\n    {\n        int VAR_45;\n        for (VAR_45 = 0; VAR_45 < VAR_23; VAR_45++)\n            printf(\"%02X%c\", VAR_10[VAR_45], ((VAR_45 + 1) % 16) ? ' ' : '\\n');\n    }\n#endif\n\n    if (EVP_CIPHER_mode(VAR_14) == VAR_36) {\n        if (!EVP_CipherInit_ex(VAR_13, VAR_14, NULL, VAR_11, NULL, (VAR_1 & VAR_46))\n            || !EVP_CIPHER_CTX_ctrl(VAR_13, VAR_47, VAR_25, VAR_12)) {\n            SSLerr(VAR_32, VAR_42);\n            goto err2;\n        }\n    } else if (EVP_CIPHER_mode(VAR_14) == VAR_38) {\n        int VAR_48;\n        if (VAR_0->s3->tmp.\n            new_cipher->algorithm_enc & (VAR_49 | VAR_50))\n            VAR_48 = 8;\n        else\n            VAR_48 = 16;\n        if (!EVP_CipherInit_ex(VAR_13, VAR_14, NULL, NULL, NULL, (VAR_1 & VAR_46))\n            || !EVP_CIPHER_CTX_ctrl(VAR_13, VAR_51, 12, NULL)\n            || !EVP_CIPHER_CTX_ctrl(VAR_13, VAR_52, VAR_48, NULL)\n            || !EVP_CIPHER_CTX_ctrl(VAR_13, VAR_53, VAR_25, VAR_12)\n            || !EVP_CipherInit_ex(VAR_13, NULL, NULL, VAR_11, NULL, -1)) {\n            SSLerr(VAR_32, VAR_42);\n            goto err2;\n        }\n    } else {\n        if (!EVP_CipherInit_ex(VAR_13, VAR_14, NULL, VAR_11, VAR_12, (VAR_1 & VAR_46))) {\n            SSLerr(VAR_32, VAR_42);\n            goto err2;\n        }\n    }\n    /* COMMENT_11 */\n    if ((EVP_CIPHER_flags(VAR_14) & VAR_43) && *VAR_19\n        && !EVP_CIPHER_CTX_ctrl(VAR_13, VAR_54,\n                                *VAR_19, VAR_3)) {\n        SSLerr(VAR_32, VAR_42);\n        goto err2;\n    }\n#ifdef VAR_55\n    if (VAR_0->msg_callback) {\n        int VAR_56 = VAR_1 & VAR_46 ? VAR_57 : 0;\n        if (*VAR_19)\n            VAR_0->msg_callback(2, VAR_0->version, VAR_56 | VAR_58,\n                            VAR_3, *VAR_19,\n                            VAR_0, VAR_0->msg_callback_arg);\n        if (VAR_14->key_len)\n            VAR_0->msg_callback(2, VAR_0->version, VAR_56 | VAR_59,\n                            VAR_11, VAR_14->key_len, VAR_0, VAR_0->msg_callback_arg);\n        if (VAR_25) {\n            if (EVP_CIPHER_mode(VAR_14) == VAR_36)\n                VAR_56 |= VAR_60;\n            else\n                VAR_56 |= VAR_61;\n            VAR_0->msg_callback(2, VAR_0->version, VAR_56, VAR_12, VAR_25, VAR_0, VAR_0->msg_callback_arg);\n        }\n    }\n#endif\n\n#ifdef VAR_44\n    printf(\"which = %04X\\nkey=\", VAR_1);\n    {\n        int VAR_45;\n        for (VAR_45 = 0; VAR_45 < EVP_CIPHER_key_length(VAR_14); VAR_45++)\n            printf(\"%02X%c\", VAR_11[VAR_45], ((VAR_45 + 1) % 16) ? ' ' : '\\n');\n    }\n    printf(\"\\niv=\");\n    {\n        int VAR_45;\n        for (VAR_45 = 0; VAR_45 < VAR_25; VAR_45++)\n            printf(\"%02X%c\", VAR_12[VAR_45], ((VAR_45 + 1) % 16) ? ' ' : '\\n');\n    }\n    printf(\"\\n\");\n#endif\n\n    OPENSSL_cleanse(VAR_4, sizeof(VAR_4));\n    OPENSSL_cleanse(VAR_6, sizeof(VAR_4));\n    OPENSSL_cleanse(VAR_7, sizeof(VAR_7));\n    OPENSSL_cleanse(VAR_9, sizeof(VAR_9));\n    return (1);\n err:\n    SSLerr(VAR_32, VAR_62);\n err2:\n    OPENSSL_cleanse(VAR_4, sizeof(VAR_4));\n    OPENSSL_cleanse(VAR_6, sizeof(VAR_4));\n    OPENSSL_cleanse(VAR_7, sizeof(VAR_7));\n    OPENSSL_cleanse(VAR_9, sizeof(VAR_9));\n    return (0);\n}",
  "func_graph_path": "openssl/4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2/t1_enc.c/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -27,6 +27,11 @@\n #endif\n \n     if (which & SSL3_CC_READ) {\n+        if (s->tlsext_use_etm)\n+            s->s3->flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC_READ;\n+        else\n+            s->s3->flags &= ~TLS1_FLAGS_ENCRYPT_THEN_MAC_READ;\n+\n         if (s->s3->tmp.new_cipher->algorithm2 & TLS1_STREAM_MAC)\n             s->mac_flags |= SSL_MAC_FLAG_READ_MAC_STREAM;\n         else\n@@ -65,6 +70,11 @@\n         mac_secret = &(s->s3->read_mac_secret[0]);\n         mac_secret_size = &(s->s3->read_mac_secret_size);\n     } else {\n+        if (s->tlsext_use_etm)\n+            s->s3->flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC_WRITE;\n+        else\n+            s->s3->flags &= ~TLS1_FLAGS_ENCRYPT_THEN_MAC_WRITE;\n+\n         if (s->s3->tmp.new_cipher->algorithm2 & TLS1_STREAM_MAC)\n             s->mac_flags |= SSL_MAC_FLAG_WRITE_MAC_STREAM;\n         else",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "        if (s->tlsext_use_etm)",
      "            s->s3->flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC_READ;",
      "        else",
      "            s->s3->flags &= ~TLS1_FLAGS_ENCRYPT_THEN_MAC_READ;",
      "",
      "        if (s->tlsext_use_etm)",
      "            s->s3->flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC_WRITE;",
      "        else",
      "            s->s3->flags &= ~TLS1_FLAGS_ENCRYPT_THEN_MAC_WRITE;",
      ""
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/EktapopaT/openssl/pull/1",
  "description": {
    "pr_info": {
      "title": "Open ssl 1 1 0 stable",
      "number": 1
    },
    "comment": [
      "<!--\r\nThank you for your pull request. Please review below requirements.\r\n\r\nContributors guide: https://github.com/openssl/openssl/blob/master/CONTRIBUTING\r\n-->\r\n\r\n##### Checklist\r\n<!-- Remove items that do not apply. For completed items, change [ ] to [x]. -->\r\n- [ ] documentation is added or updated\r\n- [ ] tests are added or updated\r\n- [ ] CLA is signed\r\n\r\n##### Description of change\r\n<!-- Provide a description of the changes.\r\n\r\nIf it fixes a github issue, add Fixes #XXXX.\r\n-->\r\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\n**Final Output:**\nAnalysis: The patch addresses a crash during TLS renegotiation, which could be exploited for a DoS attack. The code changes ensure ETM flags are updated correctly, preventing the crash. This resolves a security vulnerability.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 1.0"
}