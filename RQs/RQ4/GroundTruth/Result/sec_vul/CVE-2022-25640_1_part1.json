{
  "cve_id": "CVE-2022-25640",
  "cwe_ids": [
    "CWE-295"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "wolfSSL/wolfssl",
  "commit_msg": "Include the `havePeerCert` argument in the check.",
  "commit_hash": "b60d2dccce9110fd2b985d99063e524e39bdf6f7",
  "git_url": "https://github.com/wolfSSL/wolfssl/commit/b60d2dccce9110fd2b985d99063e524e39bdf6f7",
  "file_path": "src/tls13.c",
  "func_name": "DoTls13Finished",
  "func_before": "int DoTls13Finished(WOLFSSL* ssl, const byte* input, word32* inOutIdx,\n                           word32 size, word32 totalSz, int sniff)\n{\n    int    ret;\n    word32 finishedSz = 0;\n    byte*  secret;\n    byte   mac[WC_MAX_DIGEST_SIZE];\n\n    WOLFSSL_START(WC_FUNC_FINISHED_DO);\n    WOLFSSL_ENTER(\"DoTls13Finished\");\n\n#if !defined(NO_CERTS) && !defined(WOLFSSL_NO_CLIENT_AUTH)\n    /* verify the client sent certificate if required */\n    if (ssl->options.side == WOLFSSL_SERVER_END &&\n            (ssl->options.mutualAuth || ssl->options.failNoCert)) {\n        if (!ssl->options.havePeerVerify && !ssl->options.resuming) {\n            ret = NO_PEER_CERT;\n            DoCertFatalAlert(ssl, ret);\n            return ret;\n        }\n    }\n#endif\n\n    /* check against totalSz */\n    if (*inOutIdx + size + ssl->keys.padSz > totalSz)\n        return BUFFER_E;\n\n    if (ssl->options.handShakeDone) {\n        ret = DeriveFinishedSecret(ssl, ssl->clientSecret,\n                                   ssl->keys.client_write_MAC_secret);\n        if (ret != 0)\n            return ret;\n\n        secret = ssl->keys.client_write_MAC_secret;\n    }\n    else if (ssl->options.side == WOLFSSL_CLIENT_END) {\n        /* All the handshake messages have been received to calculate\n         * client and server finished keys.\n         */\n        ret = DeriveFinishedSecret(ssl, ssl->clientSecret,\n                                   ssl->keys.client_write_MAC_secret);\n        if (ret != 0)\n            return ret;\n\n        ret = DeriveFinishedSecret(ssl, ssl->serverSecret,\n                                   ssl->keys.server_write_MAC_secret);\n        if (ret != 0)\n            return ret;\n\n        secret = ssl->keys.server_write_MAC_secret;\n    }\n    else {\n        secret = ssl->keys.client_write_MAC_secret;\n    }\n\n    if (sniff == NO_SNIFF) {\n        ret = BuildTls13HandshakeHmac(ssl, secret, mac, &finishedSz);\n    #if defined(OPENSSL_ALL) || defined(WOLFSSL_HAPROXY) || defined(WOLFSSL_WPAS)\n        if (ssl->options.side == WOLFSSL_CLIENT_END) {\n            XMEMCPY(ssl->serverFinished, mac, finishedSz);\n            ssl->serverFinished_len = finishedSz;\n        }\n        else {\n            XMEMCPY(ssl->clientFinished, mac, finishedSz);\n            ssl->clientFinished_len = finishedSz;\n        }\n    #endif\n        if (ret != 0)\n            return ret;\n        if (size != finishedSz)\n            return BUFFER_ERROR;\n    }\n\n#ifdef WOLFSSL_CALLBACKS\n    if (ssl->hsInfoOn) AddPacketName(ssl, \"Finished\");\n    if (ssl->toInfoOn) AddLateName(\"Finished\", &ssl->timeoutInfo);\n#endif\n\n    if (sniff == NO_SNIFF) {\n        /* Actually check verify data. */\n        if (XMEMCMP(input + *inOutIdx, mac, size) != 0){\n            WOLFSSL_MSG(\"Verify finished error on hashes\");\n            SendAlert(ssl, alert_fatal, decrypt_error);\n            return VERIFY_FINISHED_ERROR;\n        }\n    }\n\n    /* Force input exhaustion at ProcessReply by consuming padSz. */\n    *inOutIdx += size + ssl->keys.padSz;\n\n    if (ssl->options.side == WOLFSSL_SERVER_END &&\n                                                  !ssl->options.handShakeDone) {\n#ifdef WOLFSSL_EARLY_DATA\n        if (ssl->earlyData != no_early_data) {\n            if ((ret = DeriveTls13Keys(ssl, no_key, DECRYPT_SIDE_ONLY, 1)) != 0)\n                return ret;\n        }\n#endif\n        /* Setup keys for application data messages from client. */\n        if ((ret = SetKeysSide(ssl, DECRYPT_SIDE_ONLY)) != 0)\n            return ret;\n    }\n\n#ifndef NO_WOLFSSL_CLIENT\n    if (ssl->options.side == WOLFSSL_CLIENT_END)\n        ssl->options.serverState = SERVER_FINISHED_COMPLETE;\n#endif\n#ifndef NO_WOLFSSL_SERVER\n    if (ssl->options.side == WOLFSSL_SERVER_END) {\n        ssl->options.clientState = CLIENT_FINISHED_COMPLETE;\n        ssl->options.handShakeState = HANDSHAKE_DONE;\n        ssl->options.handShakeDone  = 1;\n    }\n#endif\n\n    WOLFSSL_LEAVE(\"DoTls13Finished\", 0);\n    WOLFSSL_END(WC_FUNC_FINISHED_DO);\n\n    return 0;\n}",
  "abstract_func_before": "int DoTls13Finished(WOLFSSL* VAR_0, const byte* VAR_1, word32* VAR_2,\n                           word32 VAR_3, word32 VAR_4, int VAR_5)\n{\n    int    VAR_6;\n    word32 VAR_7 = 0;\n    byte*  VAR_8;\n    byte   VAR_9[VAR_10];\n\n    WOLFSSL_START(VAR_11);\n    WOLFSSL_ENTER(\"DoTls13Finished\");\n\n#if !defined(VAR_12) && !defined(VAR_13)\n    /* COMMENT_0 */\n    if (VAR_0->options.side == VAR_14 &&\n            (VAR_0->options.mutualAuth || VAR_0->options.failNoCert)) {\n        if (!VAR_0->options.havePeerVerify && !VAR_0->options.resuming) {\n            VAR_6 = VAR_15;\n            DoCertFatalAlert(VAR_0, VAR_6);\n            return VAR_6;\n        }\n    }\n#endif\n\n    /* COMMENT_1 */\n    if (*VAR_2 + VAR_3 + VAR_0->keys.padSz > VAR_4)\n        return VAR_16;\n\n    if (VAR_0->options.handShakeDone) {\n        VAR_6 = DeriveFinishedSecret(VAR_0, VAR_0->clientSecret,\n                                   VAR_0->keys.client_write_MAC_secret);\n        if (VAR_6 != 0)\n            return VAR_6;\n\n        VAR_8 = VAR_0->keys.client_write_MAC_secret;\n    }\n    else if (VAR_0->options.side == VAR_17) {\n        /* COMMENT_2 */\n                                           \n           \n        VAR_6 = DeriveFinishedSecret(VAR_0, VAR_0->clientSecret,\n                                   VAR_0->keys.client_write_MAC_secret);\n        if (VAR_6 != 0)\n            return VAR_6;\n\n        VAR_6 = DeriveFinishedSecret(VAR_0, VAR_0->serverSecret,\n                                   VAR_0->keys.server_write_MAC_secret);\n        if (VAR_6 != 0)\n            return VAR_6;\n\n        VAR_8 = VAR_0->keys.server_write_MAC_secret;\n    }\n    else {\n        VAR_8 = VAR_0->keys.client_write_MAC_secret;\n    }\n\n    if (VAR_5 == VAR_18) {\n        VAR_6 = BuildTls13HandshakeHmac(VAR_0, VAR_8, VAR_9, &VAR_7);\n    #if defined(VAR_19) || defined(VAR_20) || defined(VAR_21)\n        if (VAR_0->options.side == VAR_17) {\n            XMEMCPY(VAR_0->serverFinished, VAR_9, VAR_7);\n            VAR_0->serverFinished_len = VAR_7;\n        }\n        else {\n            XMEMCPY(VAR_0->clientFinished, VAR_9, VAR_7);\n            VAR_0->clientFinished_len = VAR_7;\n        }\n    #endif\n        if (VAR_6 != 0)\n            return VAR_6;\n        if (VAR_3 != VAR_7)\n            return VAR_22;\n    }\n\n#ifdef VAR_23\n    if (VAR_0->hsInfoOn) AddPacketName(VAR_0, \"Finished\");\n    if (VAR_0->toInfoOn) AddLateName(\"Finished\", &VAR_0->timeoutInfo);\n#endif\n\n    if (VAR_5 == VAR_18) {\n        /* COMMENT_5 */\n        if (XMEMCMP(VAR_1 + *VAR_2, VAR_9, VAR_3) != 0){\n            WOLFSSL_MSG(\"Verify finished error on hashes\");\n            SendAlert(VAR_0, VAR_24, VAR_25);\n            return VAR_26;\n        }\n    }\n\n    /* COMMENT_6 */\n    *VAR_2 += VAR_3 + VAR_0->keys.padSz;\n\n    if (VAR_0->options.side == VAR_14 &&\n                                                  !VAR_0->options.handShakeDone) {\n#ifdef VAR_27\n        if (VAR_0->earlyData != VAR_28) {\n            if ((VAR_6 = DeriveTls13Keys(VAR_0, VAR_29, VAR_30, 1)) != 0)\n                return VAR_6;\n        }\n#endif\n        /* COMMENT_7 */\n        if ((VAR_6 = SetKeysSide(VAR_0, VAR_30)) != 0)\n            return VAR_6;\n    }\n\n#ifndef VAR_31\n    if (VAR_0->options.side == VAR_17)\n        VAR_0->options.serverState = VAR_32;\n#endif\n#ifndef VAR_33\n    if (VAR_0->options.side == VAR_14) {\n        VAR_0->options.clientState = VAR_34;\n        VAR_0->options.handShakeState = VAR_35;\n        VAR_0->options.handShakeDone  = 1;\n    }\n#endif\n\n    WOLFSSL_LEAVE(\"DoTls13Finished\", 0);\n    WOLFSSL_END(VAR_11);\n\n    return 0;\n}",
  "func_graph_path_before": "wolfSSL/wolfssl/b60d2dccce9110fd2b985d99063e524e39bdf6f7/tls13.c/vul/before/0.json",
  "func": "int DoTls13Finished(WOLFSSL* ssl, const byte* input, word32* inOutIdx,\n                           word32 size, word32 totalSz, int sniff)\n{\n    int    ret;\n    word32 finishedSz = 0;\n    byte*  secret;\n    byte   mac[WC_MAX_DIGEST_SIZE];\n\n    WOLFSSL_START(WC_FUNC_FINISHED_DO);\n    WOLFSSL_ENTER(\"DoTls13Finished\");\n\n#if !defined(NO_CERTS) && !defined(WOLFSSL_NO_CLIENT_AUTH)\n    /* verify the client sent certificate if required */\n    if (ssl->options.side == WOLFSSL_SERVER_END && !ssl->options.resuming &&\n            (ssl->options.mutualAuth || ssl->options.failNoCert)) {\n        if (!ssl->options.havePeerCert || !ssl->options.havePeerVerify) {\n            ret = NO_PEER_CERT; /* NO_PEER_VERIFY */\n            WOLFSSL_MSG(\"TLS v1.3 client did not present peer cert\");\n            DoCertFatalAlert(ssl, ret);\n            return ret;\n        }\n    }\n#endif\n\n    /* check against totalSz */\n    if (*inOutIdx + size + ssl->keys.padSz > totalSz)\n        return BUFFER_E;\n\n    if (ssl->options.handShakeDone) {\n        ret = DeriveFinishedSecret(ssl, ssl->clientSecret,\n                                   ssl->keys.client_write_MAC_secret);\n        if (ret != 0)\n            return ret;\n\n        secret = ssl->keys.client_write_MAC_secret;\n    }\n    else if (ssl->options.side == WOLFSSL_CLIENT_END) {\n        /* All the handshake messages have been received to calculate\n         * client and server finished keys.\n         */\n        ret = DeriveFinishedSecret(ssl, ssl->clientSecret,\n                                   ssl->keys.client_write_MAC_secret);\n        if (ret != 0)\n            return ret;\n\n        ret = DeriveFinishedSecret(ssl, ssl->serverSecret,\n                                   ssl->keys.server_write_MAC_secret);\n        if (ret != 0)\n            return ret;\n\n        secret = ssl->keys.server_write_MAC_secret;\n    }\n    else {\n        secret = ssl->keys.client_write_MAC_secret;\n    }\n\n    if (sniff == NO_SNIFF) {\n        ret = BuildTls13HandshakeHmac(ssl, secret, mac, &finishedSz);\n    #if defined(OPENSSL_ALL) || defined(WOLFSSL_HAPROXY) || defined(WOLFSSL_WPAS)\n        if (ssl->options.side == WOLFSSL_CLIENT_END) {\n            XMEMCPY(ssl->serverFinished, mac, finishedSz);\n            ssl->serverFinished_len = finishedSz;\n        }\n        else {\n            XMEMCPY(ssl->clientFinished, mac, finishedSz);\n            ssl->clientFinished_len = finishedSz;\n        }\n    #endif\n        if (ret != 0)\n            return ret;\n        if (size != finishedSz)\n            return BUFFER_ERROR;\n    }\n\n#ifdef WOLFSSL_CALLBACKS\n    if (ssl->hsInfoOn) AddPacketName(ssl, \"Finished\");\n    if (ssl->toInfoOn) AddLateName(\"Finished\", &ssl->timeoutInfo);\n#endif\n\n    if (sniff == NO_SNIFF) {\n        /* Actually check verify data. */\n        if (XMEMCMP(input + *inOutIdx, mac, size) != 0){\n            WOLFSSL_MSG(\"Verify finished error on hashes\");\n            SendAlert(ssl, alert_fatal, decrypt_error);\n            return VERIFY_FINISHED_ERROR;\n        }\n    }\n\n    /* Force input exhaustion at ProcessReply by consuming padSz. */\n    *inOutIdx += size + ssl->keys.padSz;\n\n    if (ssl->options.side == WOLFSSL_SERVER_END &&\n                                                  !ssl->options.handShakeDone) {\n#ifdef WOLFSSL_EARLY_DATA\n        if (ssl->earlyData != no_early_data) {\n            if ((ret = DeriveTls13Keys(ssl, no_key, DECRYPT_SIDE_ONLY, 1)) != 0)\n                return ret;\n        }\n#endif\n        /* Setup keys for application data messages from client. */\n        if ((ret = SetKeysSide(ssl, DECRYPT_SIDE_ONLY)) != 0)\n            return ret;\n    }\n\n#ifndef NO_WOLFSSL_CLIENT\n    if (ssl->options.side == WOLFSSL_CLIENT_END)\n        ssl->options.serverState = SERVER_FINISHED_COMPLETE;\n#endif\n#ifndef NO_WOLFSSL_SERVER\n    if (ssl->options.side == WOLFSSL_SERVER_END) {\n        ssl->options.clientState = CLIENT_FINISHED_COMPLETE;\n        ssl->options.handShakeState = HANDSHAKE_DONE;\n        ssl->options.handShakeDone  = 1;\n    }\n#endif\n\n    WOLFSSL_LEAVE(\"DoTls13Finished\", 0);\n    WOLFSSL_END(WC_FUNC_FINISHED_DO);\n\n    return 0;\n}",
  "abstract_func": "int DoTls13Finished(WOLFSSL* VAR_0, const byte* VAR_1, word32* VAR_2,\n                           word32 VAR_3, word32 VAR_4, int VAR_5)\n{\n    int    VAR_6;\n    word32 VAR_7 = 0;\n    byte*  VAR_8;\n    byte   VAR_9[VAR_10];\n\n    WOLFSSL_START(VAR_11);\n    WOLFSSL_ENTER(\"DoTls13Finished\");\n\n#if !defined(VAR_12) && !defined(VAR_13)\n    /* COMMENT_0 */\n    if (VAR_0->options.side == VAR_14 && !VAR_0->options.resuming &&\n            (VAR_0->options.mutualAuth || VAR_0->options.failNoCert)) {\n        if (!VAR_0->options.havePeerCert || !VAR_0->options.havePeerVerify) {\n            VAR_6 = VAR_15; /* COMMENT_1 */\n            WOLFSSL_MSG(\"TLS v1.3 client did not present peer cert\");\n            DoCertFatalAlert(VAR_0, VAR_6);\n            return VAR_6;\n        }\n    }\n#endif\n\n    /* COMMENT_2 */\n    if (*VAR_2 + VAR_3 + VAR_0->keys.padSz > VAR_4)\n        return VAR_16;\n\n    if (VAR_0->options.handShakeDone) {\n        VAR_6 = DeriveFinishedSecret(VAR_0, VAR_0->clientSecret,\n                                   VAR_0->keys.client_write_MAC_secret);\n        if (VAR_6 != 0)\n            return VAR_6;\n\n        VAR_8 = VAR_0->keys.client_write_MAC_secret;\n    }\n    else if (VAR_0->options.side == VAR_17) {\n        /* COMMENT_3 */\n                                           \n           \n        VAR_6 = DeriveFinishedSecret(VAR_0, VAR_0->clientSecret,\n                                   VAR_0->keys.client_write_MAC_secret);\n        if (VAR_6 != 0)\n            return VAR_6;\n\n        VAR_6 = DeriveFinishedSecret(VAR_0, VAR_0->serverSecret,\n                                   VAR_0->keys.server_write_MAC_secret);\n        if (VAR_6 != 0)\n            return VAR_6;\n\n        VAR_8 = VAR_0->keys.server_write_MAC_secret;\n    }\n    else {\n        VAR_8 = VAR_0->keys.client_write_MAC_secret;\n    }\n\n    if (VAR_5 == VAR_18) {\n        VAR_6 = BuildTls13HandshakeHmac(VAR_0, VAR_8, VAR_9, &VAR_7);\n    #if defined(VAR_19) || defined(VAR_20) || defined(VAR_21)\n        if (VAR_0->options.side == VAR_17) {\n            XMEMCPY(VAR_0->serverFinished, VAR_9, VAR_7);\n            VAR_0->serverFinished_len = VAR_7;\n        }\n        else {\n            XMEMCPY(VAR_0->clientFinished, VAR_9, VAR_7);\n            VAR_0->clientFinished_len = VAR_7;\n        }\n    #endif\n        if (VAR_6 != 0)\n            return VAR_6;\n        if (VAR_3 != VAR_7)\n            return VAR_22;\n    }\n\n#ifdef VAR_23\n    if (VAR_0->hsInfoOn) AddPacketName(VAR_0, \"Finished\");\n    if (VAR_0->toInfoOn) AddLateName(\"Finished\", &VAR_0->timeoutInfo);\n#endif\n\n    if (VAR_5 == VAR_18) {\n        /* COMMENT_6 */\n        if (XMEMCMP(VAR_1 + *VAR_2, VAR_9, VAR_3) != 0){\n            WOLFSSL_MSG(\"Verify finished error on hashes\");\n            SendAlert(VAR_0, VAR_24, VAR_25);\n            return VAR_26;\n        }\n    }\n\n    /* COMMENT_7 */\n    *VAR_2 += VAR_3 + VAR_0->keys.padSz;\n\n    if (VAR_0->options.side == VAR_14 &&\n                                                  !VAR_0->options.handShakeDone) {\n#ifdef VAR_27\n        if (VAR_0->earlyData != VAR_28) {\n            if ((VAR_6 = DeriveTls13Keys(VAR_0, VAR_29, VAR_30, 1)) != 0)\n                return VAR_6;\n        }\n#endif\n        /* COMMENT_8 */\n        if ((VAR_6 = SetKeysSide(VAR_0, VAR_30)) != 0)\n            return VAR_6;\n    }\n\n#ifndef VAR_31\n    if (VAR_0->options.side == VAR_17)\n        VAR_0->options.serverState = VAR_32;\n#endif\n#ifndef VAR_33\n    if (VAR_0->options.side == VAR_14) {\n        VAR_0->options.clientState = VAR_34;\n        VAR_0->options.handShakeState = VAR_35;\n        VAR_0->options.handShakeDone  = 1;\n    }\n#endif\n\n    WOLFSSL_LEAVE(\"DoTls13Finished\", 0);\n    WOLFSSL_END(VAR_11);\n\n    return 0;\n}",
  "func_graph_path": "wolfSSL/wolfssl/b60d2dccce9110fd2b985d99063e524e39bdf6f7/tls13.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -11,10 +11,11 @@\n \n #if !defined(NO_CERTS) && !defined(WOLFSSL_NO_CLIENT_AUTH)\n     /* verify the client sent certificate if required */\n-    if (ssl->options.side == WOLFSSL_SERVER_END &&\n+    if (ssl->options.side == WOLFSSL_SERVER_END && !ssl->options.resuming &&\n             (ssl->options.mutualAuth || ssl->options.failNoCert)) {\n-        if (!ssl->options.havePeerVerify && !ssl->options.resuming) {\n-            ret = NO_PEER_CERT;\n+        if (!ssl->options.havePeerCert || !ssl->options.havePeerVerify) {\n+            ret = NO_PEER_CERT; /* NO_PEER_VERIFY */\n+            WOLFSSL_MSG(\"TLS v1.3 client did not present peer cert\");\n             DoCertFatalAlert(ssl, ret);\n             return ret;\n         }",
  "diff_line_info": {
    "deleted_lines": [
      "    if (ssl->options.side == WOLFSSL_SERVER_END &&",
      "        if (!ssl->options.havePeerVerify && !ssl->options.resuming) {",
      "            ret = NO_PEER_CERT;"
    ],
    "added_lines": [
      "    if (ssl->options.side == WOLFSSL_SERVER_END && !ssl->options.resuming &&",
      "        if (!ssl->options.havePeerCert || !ssl->options.havePeerVerify) {",
      "            ret = NO_PEER_CERT; /* NO_PEER_VERIFY */",
      "            WOLFSSL_MSG(\"TLS v1.3 client did not present peer cert\");"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/wolfSSL/wolfssl/pull/4831",
  "description": {
    "pr_info": {
      "title": "Improve the client certificate checking logic",
      "number": 4831
    },
    "comment": [
      "# Description\r\n\r\nImprove client certificate checking. Make sure wolfSSL_CTX_mutual_auth` is also checked.\r\n\r\nFixes zd13571\r\n\r\n# Testing\r\n\r\nNew test cases to come later.\r\n\r\n# Checklist\r\n\r\n - [ ] added tests\r\n - [ ] updated/added doxygen\r\n - [ ] updated appropriate READMEs\r\n - [ ] Updated manual and documentation\r\n"
    ]
  },
  "Bug Filter": "** Security Vulnerability Fix  \n**Confidence Score:** 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\nThe patch modifies the TLS 1.3 handshake process to correctly check for client certificates, preventing potential unauthorized access. This addresses a security issue where the server might not enforce certificate verification properly.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 0.95"
}