{
  "cve_id": "CVE-2017-9780",
  "cwe_ids": [
    "CWE-732"
  ],
  "cvss_vector": "AV:L/AC:L/Au:N/C:C/I:C/A:C",
  "cvss_is_v3": false,
  "repo_name": "flatpak",
  "commit_msg": "Use new libostree APIs to reject world-writable/suid content\n\nThis uses the new libostree APIs that landed recently to ensure\nthat we reject any files with mode outside of `0775` for system\nhelper pulls, and we also mask directory modes during checkout.\n\nHowever, this does *not* fix up any already downloaded content.\nFor that, one could uninstall/reinstall; or a future patch could\ndo a one-time fixup pass.\n\nNote that I am not aware of a way for flatpak applications to escalate their\nprivileges directly with this flaw; the bubblewrap `PR_SET_NO_NEW_PRIVS` turns\nof setuid. However, in combination with code execution on the host via another\nmechanism (e.g. unsandboxed app), a setuid app injected could be used to gain\nfull host privileges.\n\nAt this time we're not aware of any flatpak content exploiting this issue.\n\nCloses: https://github.com/flatpak/flatpak/issues/845",
  "commit_hash": "aed5d0919830c02e490f669fc36bd9af42e632d6",
  "git_url": "https://github.com/flatpak/flatpak/commit/aed5d0919830c02e490f669fc36bd9af42e632d6",
  "file_path": "common/flatpak-dir.c",
  "func_name": "flatpak_dir_deploy",
  "func_before": "gboolean\nflatpak_dir_deploy (FlatpakDir          *self,\n                    const char          *origin,\n                    const char          *ref,\n                    const char          *checksum_or_latest,\n                    const char * const * subpaths,\n                    GVariant            *old_deploy_data,\n                    GCancellable        *cancellable,\n                    GError             **error)\n{\n  g_autofree char *resolved_ref = NULL;\n\n  g_autoptr(GFile) root = NULL;\n  g_autoptr(GFile) deploy_base = NULL;\n  g_autoptr(GFile) checkoutdir = NULL;\n  g_autofree char *checkoutdirpath = NULL;\n  g_autoptr(GFile) real_checkoutdir = NULL;\n  g_autoptr(GFile) dotref = NULL;\n  g_autoptr(GFile) files_etc = NULL;\n  g_autoptr(GFile) metadata = NULL;\n  g_autoptr(GFile) deploy_data_file = NULL;\n  g_autoptr(GVariant) deploy_data = NULL;\n  g_autoptr(GFile) export = NULL;\n  g_autoptr(GFile) extradir = NULL;\n  g_autoptr(GKeyFile) keyfile = NULL;\n  guint64 installed_size = 0;\n  OstreeRepoCheckoutAtOptions options = { 0, };\n  const char *checksum;\n  glnx_fd_close int checkoutdir_dfd = -1;\n  g_autoptr(GFile) tmp_dir_template = NULL;\n  g_autoptr(GVariant) commit_data = NULL;\n  g_autofree char *tmp_dir_path = NULL;\n  g_autofree char *alt_id = NULL;\n  const char *xa_metadata = NULL;\n  const char *xa_ref = NULL;\n  g_autofree char *checkout_basename = NULL;\n  gboolean created_extra_data = FALSE;\n  g_autoptr(GVariant) commit_metadata = NULL;\n  GVariantBuilder metadata_builder;\n\n  if (!flatpak_dir_ensure_repo (self, cancellable, error))\n    return FALSE;\n\n  deploy_base = flatpak_dir_get_deploy_dir (self, ref);\n\n  if (checksum_or_latest == NULL)\n    {\n      g_debug (\"No checksum specified, getting tip of %s\", ref);\n\n      resolved_ref = flatpak_dir_read_latest (self, origin, ref, NULL, cancellable, error);\n      if (resolved_ref == NULL)\n        {\n          g_prefix_error (error, _(\"While trying to resolve ref %s: \"), ref);\n          return FALSE;\n        }\n\n      checksum = resolved_ref;\n      g_debug (\"tip resolved to: %s\", checksum);\n    }\n  else\n    {\n      g_autoptr(GFile) root = NULL;\n      g_autofree char *commit = NULL;\n\n      checksum = checksum_or_latest;\n      g_debug (\"Looking for checksum %s in local repo\", checksum);\n      if (!ostree_repo_read_commit (self->repo, checksum, &root, &commit, cancellable, NULL))\n        return flatpak_fail (error, _(\"%s is not available\"), ref);\n    }\n\n  if (!ostree_repo_load_commit (self->repo, checksum, &commit_data, NULL, error))\n    return FALSE;\n\n  commit_metadata = g_variant_get_child_value (commit_data, 0);\n  g_variant_lookup (commit_metadata, \"xa.alt-id\", \"s\", &alt_id);\n\n  if (subpaths == NULL || *subpaths == NULL)\n    checkout_basename = g_strdup (checksum);\n  else\n    {\n      GString *str = g_string_new (checksum);\n      int i;\n      for (i = 0; subpaths[i] != NULL; i++)\n        {\n          const char *s = subpaths[i];\n          g_string_append_c (str, '-');\n          while (*s)\n            {\n              if (*s != '/')\n                g_string_append_c (str, *s);\n              s++;\n            }\n        }\n      checkout_basename = g_string_free (str, FALSE);\n    }\n\n  real_checkoutdir = g_file_get_child (deploy_base, checkout_basename);\n  if (g_file_query_exists (real_checkoutdir, cancellable))\n    {\n      g_set_error (error, FLATPAK_ERROR, FLATPAK_ERROR_ALREADY_INSTALLED,\n                   _(\"%s branch %s already installed\"), ref, checksum);\n      return FALSE;\n    }\n\n  g_autofree char *template = g_strdup_printf (\".%s-XXXXXX\", checkout_basename);\n  tmp_dir_template = g_file_get_child (deploy_base, template);\n  tmp_dir_path = g_file_get_path (tmp_dir_template);\n\n  if (g_mkdtemp_full (tmp_dir_path, 0755) == NULL)\n    {\n      g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_FAILED,\n                           _(\"Can't create deploy directory\"));\n      return FALSE;\n    }\n\n  checkoutdir = g_file_new_for_path (tmp_dir_path);\n\n  if (!ostree_repo_read_commit (self->repo, checksum, &root, NULL, cancellable, error))\n    {\n      g_prefix_error (error, _(\"Failed to read commit %s: \"), checksum);\n      return FALSE;\n    }\n\n  if (!flatpak_repo_collect_sizes (self->repo, root, &installed_size, NULL, cancellable, error))\n    return FALSE;\n\n  options.mode = OSTREE_REPO_CHECKOUT_MODE_USER;\n  options.overwrite_mode = OSTREE_REPO_CHECKOUT_OVERWRITE_UNION_FILES;\n  options.enable_fsync = FALSE; /* We checkout to a temp dir and sync before moving it in place */\n  checkoutdirpath = g_file_get_path (checkoutdir);\n\n  if (subpaths == NULL || *subpaths == NULL)\n    {\n      if (!ostree_repo_checkout_at (self->repo, &options,\n                                    AT_FDCWD, checkoutdirpath,\n                                    checksum,\n                                    cancellable, error))\n        {\n          g_prefix_error (error, _(\"While trying to checkout %s into %s: \"), checksum, checkoutdirpath);\n          return FALSE;\n        }\n    }\n  else\n    {\n      g_autofree char *checkoutdirpath = g_file_get_path (checkoutdir);\n      g_autoptr(GFile) files = g_file_get_child (checkoutdir, \"files\");\n      g_autoptr(GFile) root = NULL;\n      g_autofree char *commit = NULL;\n      int i;\n\n      if (!g_file_make_directory_with_parents (files, cancellable, error))\n        return FALSE;\n\n      options.subpath = \"/metadata\";\n\n      if (!ostree_repo_read_commit (self->repo, checksum, &root,  &commit, cancellable, error))\n        return FALSE;\n\n      if (!ostree_repo_checkout_at (self->repo, &options,\n                                    AT_FDCWD, checkoutdirpath,\n                                    checksum,\n                                    cancellable, error))\n        {\n          g_prefix_error (error, _(\"While trying to checkout metadata subpath: \"));\n          return FALSE;\n        }\n\n      for (i = 0; subpaths[i] != NULL; i++)\n        {\n          g_autofree char *subpath = g_build_filename (\"/files\", subpaths[i], NULL);\n          g_autofree char *dstpath = g_build_filename (checkoutdirpath, \"/files\", subpaths[i], NULL);\n          g_autofree char *dstpath_parent = g_path_get_dirname (dstpath);\n          g_autoptr(GFile) child = NULL;\n\n          child = g_file_resolve_relative_path (root, subpath);\n\n          if (!g_file_query_exists (child, cancellable))\n            {\n              g_debug (\"subpath %s not in tree\", subpaths[i]);\n              continue;\n            }\n\n          if (g_mkdir_with_parents (dstpath_parent, 0755))\n            {\n              glnx_set_error_from_errno (error);\n              return FALSE;\n            }\n\n          options.subpath = subpath;\n          if (!ostree_repo_checkout_at (self->repo, &options,\n                                        AT_FDCWD, dstpath,\n                                        checksum,\n                                        cancellable, error))\n            {\n              g_prefix_error (error, _(\"While trying to checkout metadata subpath: \"));\n              return FALSE;\n            }\n        }\n    }\n\n  /* Extract any extra data */\n  extradir = g_file_resolve_relative_path (checkoutdir, \"files/extra\");\n  if (!flatpak_rm_rf (extradir, cancellable, error))\n    {\n      g_prefix_error (error, _(\"While trying to remove existing extra dir: \"));\n      return FALSE;\n    }\n\n  if (!extract_extra_data (self, checksum, extradir, &created_extra_data, cancellable, error))\n    return FALSE;\n\n  if (created_extra_data)\n    {\n      if (!apply_extra_data (self, checkoutdir, cancellable, error))\n        {\n          g_prefix_error (error, _(\"While trying to apply extra data: \"));\n          return FALSE;\n        }\n    }\n\n  g_variant_lookup (commit_metadata, \"xa.ref\", \"s\", &xa_ref);\n  if (xa_ref != NULL)\n    {\n      if (strcmp (ref, xa_ref) != 0)\n        {\n          g_set_error (error, G_IO_ERROR, G_IO_ERROR_PERMISSION_DENIED,\n                       _(\"Deployed ref %s does not match commit (%s)\"), ref, xa_ref);\n          return FALSE;\n        }\n    }\n\n  /* Check the metadata in the commit to make sure it matches the actual\n     deployed metadata, in case we relied on the one in the commit for\n     a decision */\n  g_variant_lookup (commit_metadata, \"xa.metadata\", \"s\", &xa_metadata);\n  if (xa_metadata != NULL)\n    {\n      g_autoptr(GFile) metadata_file = g_file_resolve_relative_path (checkoutdir, \"metadata\");\n      char *metadata_contents;\n\n      if (!g_file_load_contents (metadata_file, NULL,\n                                 &metadata_contents, NULL, NULL, NULL) ||\n          strcmp (metadata_contents, xa_metadata) != 0)\n        {\n          g_set_error (error, G_IO_ERROR, G_IO_ERROR_PERMISSION_DENIED,\n                       _(\"Deployed metadata does not match commit\"));\n          return FALSE;\n        }\n    }\n\n  dotref = g_file_resolve_relative_path (checkoutdir, \"files/.ref\");\n  if (!g_file_replace_contents (dotref, \"\", 0, NULL, FALSE,\n                                G_FILE_CREATE_REPLACE_DESTINATION, NULL, cancellable, error))\n    return TRUE;\n\n  /* Ensure that various files exists as regular files in /usr/etc, as we\n     want to bind-mount over them */\n  files_etc = g_file_resolve_relative_path (checkoutdir, \"files/etc\");\n  if (g_file_query_exists (files_etc, cancellable))\n    {\n      char *etcfiles[] = {\"passwd\", \"group\", \"machine-id\" };\n      g_autoptr(GFile) etc_resolve_conf = g_file_get_child (files_etc, \"resolv.conf\");\n      int i;\n      for (i = 0; i < G_N_ELEMENTS (etcfiles); i++)\n        {\n          g_autoptr(GFile) etc_file = g_file_get_child (files_etc, etcfiles[i]);\n          GFileType type;\n\n          type = g_file_query_file_type (etc_file, G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                         cancellable);\n          if (type == G_FILE_TYPE_REGULAR)\n            continue;\n\n          if (type != G_FILE_TYPE_UNKNOWN)\n            {\n              /* Already exists, but not regular, probably symlink. Remove it */\n              if (!g_file_delete (etc_file, cancellable, error))\n                return FALSE;\n            }\n\n          if (!g_file_replace_contents (etc_file, \"\", 0, NULL, FALSE,\n                                        G_FILE_CREATE_REPLACE_DESTINATION,\n                                        NULL, cancellable, error))\n            return FALSE;\n        }\n\n      if (g_file_query_exists (etc_resolve_conf, cancellable) &&\n          !g_file_delete (etc_resolve_conf, cancellable, error))\n        return TRUE;\n\n      if (!g_file_make_symbolic_link (etc_resolve_conf,\n                                      \"/run/host/monitor/resolv.conf\",\n                                      cancellable, error))\n        return FALSE;\n    }\n\n  keyfile = g_key_file_new ();\n  metadata = g_file_get_child (checkoutdir, \"metadata\");\n  if (g_file_query_exists (metadata, cancellable))\n    {\n      g_autofree char *path = g_file_get_path (metadata);\n\n      if (!g_key_file_load_from_file (keyfile, path, G_KEY_FILE_NONE, error))\n        return FALSE;\n    }\n\n  export = g_file_get_child (checkoutdir, \"export\");\n  if (g_file_query_exists (export, cancellable))\n    {\n      g_auto(GStrv) ref_parts = NULL;\n\n      ref_parts = g_strsplit (ref, \"/\", -1);\n\n      if (!flatpak_rewrite_export_dir (ref_parts[1], ref_parts[3], ref_parts[2],\n                                       keyfile, export,\n                                       cancellable,\n                                       error))\n        return FALSE;\n    }\n\n  g_variant_builder_init (&metadata_builder, G_VARIANT_TYPE (\"a{sv}\"));\n  if (alt_id)\n    g_variant_builder_add (&metadata_builder, \"{s@v}\", \"alt-id\",\n                           g_variant_new_variant (g_variant_new_string (alt_id)));\n\n  deploy_data = flatpak_dir_new_deploy_data (origin,\n                                             checksum,\n                                             (char **) subpaths,\n                                             installed_size,\n                                             g_variant_builder_end (&metadata_builder));\n\n  deploy_data_file = g_file_get_child (checkoutdir, \"deploy\");\n  if (!flatpak_variant_save (deploy_data_file, deploy_data, cancellable, error))\n    return FALSE;\n\n  if (!glnx_opendirat (AT_FDCWD, checkoutdirpath, TRUE, &checkoutdir_dfd, error))\n    return FALSE;\n\n  if (syncfs (checkoutdir_dfd) != 0)\n    {\n      glnx_set_error_from_errno (error);\n      return FALSE;\n    }\n\n  if (!g_file_move (checkoutdir, real_checkoutdir, G_FILE_COPY_NO_FALLBACK_FOR_MOVE,\n                    cancellable, NULL, NULL, error))\n    return FALSE;\n\n  if (!flatpak_dir_set_active (self, ref, checkout_basename, cancellable, error))\n    return FALSE;\n\n  return TRUE;\n}",
  "abstract_func_before": "gboolean\nflatpak_dir_deploy (FlatpakDir          *VAR_0,\n                    const char          *VAR_1,\n                    const char          *VAR_2,\n                    const char          *VAR_3,\n                    const char * const * VAR_4,\n                    GVariant            *VAR_5,\n                    GCancellable        *VAR_6,\n                    GError             **VAR_7)\n{\n  g_autofree char *VAR_8 = NULL;\n\n  VAR_9(GFile) VAR_10 = NULL;\n  VAR_9(GFile) VAR_11 = NULL;\n  VAR_9(GFile) VAR_12 = NULL;\n  g_autofree char *VAR_13 = NULL;\n  VAR_9(GFile) VAR_14 = NULL;\n  VAR_9(GFile) VAR_15 = NULL;\n  VAR_9(GFile) VAR_16 = NULL;\n  VAR_9(GFile) VAR_17 = NULL;\n  VAR_9(GFile) VAR_18 = NULL;\n  VAR_9(GVariant) VAR_19 = NULL;\n  VAR_9(GFile) VAR_20 = NULL;\n  VAR_9(GFile) VAR_21 = NULL;\n  VAR_9(GKeyFile) VAR_22 = NULL;\n  guint64 VAR_23 = 0;\n  OstreeRepoCheckoutAtOptions VAR_24 = { 0, };\n  const char *VAR_25;\n  glnx_fd_close VAR_26 VAR_27 = -1;\n  VAR_9(GFile) VAR_28 = NULL;\n  VAR_9(GVariant) VAR_29 = NULL;\n  g_autofree char *VAR_30 = NULL;\n  g_autofree char *VAR_31 = NULL;\n  const char *VAR_32 = NULL;\n  const char *VAR_33 = NULL;\n  g_autofree char *VAR_34 = NULL;\n  gboolean VAR_35 = FALSE;\n  VAR_9(GVariant) VAR_36 = NULL;\n  GVariantBuilder VAR_37;\n\n  if (!flatpak_dir_ensure_repo (VAR_0, VAR_6, VAR_7))\n    return FALSE;\n\n  VAR_11 = flatpak_dir_get_deploy_dir (VAR_0, VAR_2);\n\n  if (VAR_3 == NULL)\n    {\n      g_debug (\"No checksum specified, getting tip of %s\", VAR_2);\n\n      VAR_8 = flatpak_dir_read_latest (VAR_0, VAR_1, VAR_2, NULL, VAR_6, VAR_7);\n      if (VAR_8 == NULL)\n        {\n          g_prefix_error (VAR_7, _(\"While trying to resolve ref %s: \"), VAR_2);\n          return FALSE;\n        }\n\n      VAR_25 = VAR_8;\n      g_debug (\"tip resolved to: %s\", VAR_25);\n    }\n  else\n    {\n      VAR_9(GFile) VAR_10 = NULL;\n      g_autofree char *VAR_38 = NULL;\n\n      VAR_25 = VAR_3;\n      g_debug (\"Looking for checksum %s in local repo\", VAR_25);\n      if (!ostree_repo_read_commit (VAR_0->repo, VAR_25, &VAR_10, &VAR_38, VAR_6, NULL))\n        return flatpak_fail (VAR_7, _(\"%s is not available\"), VAR_2);\n    }\n\n  if (!ostree_repo_load_commit (VAR_0->repo, VAR_25, &VAR_29, NULL, VAR_7))\n    return FALSE;\n\n  VAR_36 = g_variant_get_child_value (VAR_29, 0);\n  g_variant_lookup (VAR_36, \"xa.alt-id\", \"s\", &VAR_31);\n\n  if (VAR_4 == NULL || *VAR_4 == NULL)\n    VAR_34 = g_strdup (VAR_25);\n  else\n    {\n      GString *VAR_39 = g_string_new (VAR_25);\n      int VAR_40;\n      for (VAR_40 = 0; VAR_4[VAR_40] != NULL; VAR_40++)\n        {\n          const char *VAR_41 = VAR_4[VAR_40];\n          g_string_append_c (VAR_39, '-');\n          while (*VAR_41)\n            {\n              if (*VAR_41 != '/')\n                g_string_append_c (VAR_39, *VAR_41);\n              VAR_41++;\n            }\n        }\n      VAR_34 = g_string_free (VAR_39, FALSE);\n    }\n\n  VAR_14 = g_file_get_child (VAR_11, VAR_34);\n  if (g_file_query_exists (VAR_14, VAR_6))\n    {\n      g_set_error (VAR_7, VAR_42, VAR_43,\n                   _(\"%s branch %s already installed\"), VAR_2, VAR_25);\n      return FALSE;\n    }\n\n  g_autofree char *VAR_44 = g_strdup_printf (\".%s-XXXXXX\", VAR_34);\n  VAR_28 = g_file_get_child (VAR_11, VAR_44);\n  VAR_30 = g_file_get_path (VAR_28);\n\n  if (g_mkdtemp_full (VAR_30, 0755) == NULL)\n    {\n      g_set_error_literal (VAR_7, VAR_45, VAR_46,\n                           _(\"Can't create deploy directory\"));\n      return FALSE;\n    }\n\n  VAR_12 = g_file_new_for_path (VAR_30);\n\n  if (!ostree_repo_read_commit (VAR_0->repo, VAR_25, &VAR_10, NULL, VAR_6, VAR_7))\n    {\n      g_prefix_error (VAR_7, _(\"Failed to read commit %s: \"), VAR_25);\n      return FALSE;\n    }\n\n  if (!flatpak_repo_collect_sizes (VAR_0->repo, VAR_10, &VAR_23, NULL, VAR_6, VAR_7))\n    return FALSE;\n\n  VAR_24.mode = VAR_47;\n  VAR_24.overwrite_mode = VAR_48;\n  VAR_24.enable_fsync = FALSE; /* COMMENT_0 */\n  VAR_13 = g_file_get_path (VAR_12);\n\n  if (VAR_4 == NULL || *VAR_4 == NULL)\n    {\n      if (!ostree_repo_checkout_at (VAR_0->repo, &VAR_24,\n                                    VAR_49, VAR_13,\n                                    VAR_25,\n                                    VAR_6, VAR_7))\n        {\n          g_prefix_error (VAR_7, _(\"While trying to checkout %s into %s: \"), VAR_25, VAR_13);\n          return FALSE;\n        }\n    }\n  else\n    {\n      g_autofree char *VAR_13 = g_file_get_path (VAR_12);\n      VAR_9(GFile) VAR_50 = g_file_get_child (VAR_12, \"files\");\n      VAR_9(GFile) VAR_10 = NULL;\n      g_autofree char *VAR_38 = NULL;\n      int VAR_40;\n\n      if (!g_file_make_directory_with_parents (VAR_50, VAR_6, VAR_7))\n        return FALSE;\n\n      VAR_24.subpath = \"/metadata\";\n\n      if (!ostree_repo_read_commit (VAR_0->repo, VAR_25, &VAR_10,  &VAR_38, VAR_6, VAR_7))\n        return FALSE;\n\n      if (!ostree_repo_checkout_at (VAR_0->repo, &VAR_24,\n                                    VAR_49, VAR_13,\n                                    VAR_25,\n                                    VAR_6, VAR_7))\n        {\n          g_prefix_error (VAR_7, _(\"While trying to checkout metadata subpath: \"));\n          return FALSE;\n        }\n\n      for (VAR_40 = 0; VAR_4[VAR_40] != NULL; VAR_40++)\n        {\n          g_autofree char *VAR_51 = g_build_filename (\"/files\", VAR_4[VAR_40], NULL);\n          g_autofree char *VAR_52 = g_build_filename (VAR_13, \"/files\", VAR_4[VAR_40], NULL);\n          g_autofree char *VAR_53 = g_path_get_dirname (VAR_52);\n          VAR_9(GFile) VAR_54 = NULL;\n\n          VAR_54 = g_file_resolve_relative_path (VAR_10, VAR_51);\n\n          if (!g_file_query_exists (VAR_54, VAR_6))\n            {\n              g_debug (\"subpath %s not in tree\", VAR_4[VAR_40]);\n              continue;\n            }\n\n          if (g_mkdir_with_parents (VAR_53, 0755))\n            {\n              glnx_set_error_from_errno (VAR_7);\n              return FALSE;\n            }\n\n          VAR_24.subpath = VAR_51;\n          if (!ostree_repo_checkout_at (VAR_0->repo, &VAR_24,\n                                        VAR_49, VAR_52,\n                                        VAR_25,\n                                        VAR_6, VAR_7))\n            {\n              g_prefix_error (VAR_7, _(\"While trying to checkout metadata subpath: \"));\n              return FALSE;\n            }\n        }\n    }\n\n  /* COMMENT_1 */\n  VAR_21 = g_file_resolve_relative_path (VAR_12, \"files/extra\");\n  if (!flatpak_rm_rf (VAR_21, VAR_6, VAR_7))\n    {\n      g_prefix_error (VAR_7, _(\"While trying to remove existing extra dir: \"));\n      return FALSE;\n    }\n\n  if (!extract_extra_data (VAR_0, VAR_25, VAR_21, &VAR_35, VAR_6, VAR_7))\n    return FALSE;\n\n  if (VAR_35)\n    {\n      if (!apply_extra_data (VAR_0, VAR_12, VAR_6, VAR_7))\n        {\n          g_prefix_error (VAR_7, _(\"While trying to apply extra data: \"));\n          return FALSE;\n        }\n    }\n\n  g_variant_lookup (VAR_36, \"xa.ref\", \"s\", &VAR_33);\n  if (VAR_33 != NULL)\n    {\n      if (strcmp (VAR_2, VAR_33) != 0)\n        {\n          g_set_error (VAR_7, VAR_45, VAR_55,\n                       _(\"Deployed ref %s does not match commit (%s)\"), VAR_2, VAR_33);\n          return FALSE;\n        }\n    }\n\n  /* COMMENT_2 */\n                                                                      \n                  \n  g_variant_lookup (VAR_36, \"xa.metadata\", \"s\", &VAR_32);\n  if (VAR_32 != NULL)\n    {\n      VAR_9(GFile) VAR_56 = g_file_resolve_relative_path (VAR_12, \"metadata\");\n      char *VAR_57;\n\n      if (!g_file_load_contents (VAR_56, NULL,\n                                 &VAR_57, NULL, NULL, NULL) ||\n          strcmp (VAR_57, VAR_32) != 0)\n        {\n          g_set_error (VAR_7, VAR_45, VAR_55,\n                       _(\"Deployed metadata does not match commit\"));\n          return FALSE;\n        }\n    }\n\n  VAR_15 = g_file_resolve_relative_path (VAR_12, \"files/.ref\");\n  if (!g_file_replace_contents (VAR_15, \"\", 0, NULL, FALSE,\n                                VAR_58, NULL, VAR_6, VAR_7))\n    return TRUE;\n\n  /* COMMENT_5 */\n                                    \n  VAR_16 = g_file_resolve_relative_path (VAR_12, \"files/etc\");\n  if (g_file_query_exists (VAR_16, VAR_6))\n    {\n      char *VAR_59[] = {\"passwd\", \"group\", \"machine-id\" };\n      VAR_9(GFile) VAR_60 = g_file_get_child (VAR_16, \"resolv.conf\");\n      int VAR_40;\n      for (VAR_40 = 0; VAR_40 < G_N_ELEMENTS (VAR_59); VAR_40++)\n        {\n          VAR_9(GFile) VAR_61 = g_file_get_child (VAR_16, VAR_59[VAR_40]);\n          GFileType VAR_62;\n\n          VAR_62 = g_file_query_file_type (VAR_61, VAR_63,\n                                         VAR_6);\n          if (VAR_62 == VAR_64)\n            continue;\n\n          if (VAR_62 != VAR_65)\n            {\n              /* COMMENT_7 */\n              if (!g_file_delete (VAR_61, VAR_6, VAR_7))\n                return FALSE;\n            }\n\n          if (!g_file_replace_contents (VAR_61, \"\", 0, NULL, FALSE,\n                                        VAR_58,\n                                        NULL, VAR_6, VAR_7))\n            return FALSE;\n        }\n\n      if (g_file_query_exists (VAR_60, VAR_6) &&\n          !g_file_delete (VAR_60, VAR_6, VAR_7))\n        return TRUE;\n\n      if (!g_file_make_symbolic_link (VAR_60,\n                                      \"/run/host/monitor/resolv.conf\",\n                                      VAR_6, VAR_7))\n        return FALSE;\n    }\n\n  VAR_22 = g_key_file_new ();\n  VAR_17 = g_file_get_child (VAR_12, \"metadata\");\n  if (g_file_query_exists (VAR_17, VAR_6))\n    {\n      g_autofree char *VAR_66 = g_file_get_path (VAR_17);\n\n      if (!g_key_file_load_from_file (VAR_22, VAR_66, VAR_67, VAR_7))\n        return FALSE;\n    }\n\n  VAR_20 = g_file_get_child (VAR_12, \"export\");\n  if (g_file_query_exists (VAR_20, VAR_6))\n    {\n      VAR_68(GStrv) VAR_69 = NULL;\n\n      VAR_69 = g_strsplit (VAR_2, \"/\", -1);\n\n      if (!flatpak_rewrite_export_dir (VAR_69[1], VAR_69[3], VAR_69[2],\n                                       VAR_22, VAR_20,\n                                       VAR_6,\n                                       VAR_7))\n        return FALSE;\n    }\n\n  g_variant_builder_init (&VAR_37, G_VARIANT_TYPE (\"a{sv}\"));\n  if (VAR_31)\n    g_variant_builder_add (&VAR_37, \"{s@v}\", \"alt-id\",\n                           g_variant_new_variant (g_variant_new_string (VAR_31)));\n\n  VAR_19 = flatpak_dir_new_deploy_data (VAR_1,\n                                             VAR_25,\n                                             (char **) VAR_4,\n                                             VAR_23,\n                                             g_variant_builder_end (&VAR_37));\n\n  VAR_18 = g_file_get_child (VAR_12, \"deploy\");\n  if (!flatpak_variant_save (VAR_18, VAR_19, VAR_6, VAR_7))\n    return FALSE;\n\n  if (!glnx_opendirat (VAR_49, VAR_13, TRUE, &VAR_27, VAR_7))\n    return FALSE;\n\n  if (syncfs (VAR_27) != 0)\n    {\n      glnx_set_error_from_errno (VAR_7);\n      return FALSE;\n    }\n\n  if (!g_file_move (VAR_12, VAR_14, VAR_70,\n                    VAR_6, NULL, NULL, VAR_7))\n    return FALSE;\n\n  if (!flatpak_dir_set_active (VAR_0, VAR_2, VAR_34, VAR_6, VAR_7))\n    return FALSE;\n\n  return TRUE;\n}",
  "func_graph_path_before": "flatpak/aed5d0919830c02e490f669fc36bd9af42e632d6/flatpak-dir.c/vul/before/3.json",
  "func": "gboolean\nflatpak_dir_deploy (FlatpakDir          *self,\n                    const char          *origin,\n                    const char          *ref,\n                    const char          *checksum_or_latest,\n                    const char * const * subpaths,\n                    GVariant            *old_deploy_data,\n                    GCancellable        *cancellable,\n                    GError             **error)\n{\n  g_autofree char *resolved_ref = NULL;\n\n  g_autoptr(GFile) root = NULL;\n  g_autoptr(GFile) deploy_base = NULL;\n  g_autoptr(GFile) checkoutdir = NULL;\n  g_autofree char *checkoutdirpath = NULL;\n  g_autoptr(GFile) real_checkoutdir = NULL;\n  g_autoptr(GFile) dotref = NULL;\n  g_autoptr(GFile) files_etc = NULL;\n  g_autoptr(GFile) metadata = NULL;\n  g_autoptr(GFile) deploy_data_file = NULL;\n  g_autoptr(GVariant) deploy_data = NULL;\n  g_autoptr(GFile) export = NULL;\n  g_autoptr(GFile) extradir = NULL;\n  g_autoptr(GKeyFile) keyfile = NULL;\n  guint64 installed_size = 0;\n  OstreeRepoCheckoutAtOptions options = { 0, };\n  const char *checksum;\n  glnx_fd_close int checkoutdir_dfd = -1;\n  g_autoptr(GFile) tmp_dir_template = NULL;\n  g_autoptr(GVariant) commit_data = NULL;\n  g_autofree char *tmp_dir_path = NULL;\n  g_autofree char *alt_id = NULL;\n  const char *xa_metadata = NULL;\n  const char *xa_ref = NULL;\n  g_autofree char *checkout_basename = NULL;\n  gboolean created_extra_data = FALSE;\n  g_autoptr(GVariant) commit_metadata = NULL;\n  GVariantBuilder metadata_builder;\n\n  if (!flatpak_dir_ensure_repo (self, cancellable, error))\n    return FALSE;\n\n  deploy_base = flatpak_dir_get_deploy_dir (self, ref);\n\n  if (checksum_or_latest == NULL)\n    {\n      g_debug (\"No checksum specified, getting tip of %s\", ref);\n\n      resolved_ref = flatpak_dir_read_latest (self, origin, ref, NULL, cancellable, error);\n      if (resolved_ref == NULL)\n        {\n          g_prefix_error (error, _(\"While trying to resolve ref %s: \"), ref);\n          return FALSE;\n        }\n\n      checksum = resolved_ref;\n      g_debug (\"tip resolved to: %s\", checksum);\n    }\n  else\n    {\n      g_autoptr(GFile) root = NULL;\n      g_autofree char *commit = NULL;\n\n      checksum = checksum_or_latest;\n      g_debug (\"Looking for checksum %s in local repo\", checksum);\n      if (!ostree_repo_read_commit (self->repo, checksum, &root, &commit, cancellable, NULL))\n        return flatpak_fail (error, _(\"%s is not available\"), ref);\n    }\n\n  if (!ostree_repo_load_commit (self->repo, checksum, &commit_data, NULL, error))\n    return FALSE;\n\n  commit_metadata = g_variant_get_child_value (commit_data, 0);\n  g_variant_lookup (commit_metadata, \"xa.alt-id\", \"s\", &alt_id);\n\n  if (subpaths == NULL || *subpaths == NULL)\n    checkout_basename = g_strdup (checksum);\n  else\n    {\n      GString *str = g_string_new (checksum);\n      int i;\n      for (i = 0; subpaths[i] != NULL; i++)\n        {\n          const char *s = subpaths[i];\n          g_string_append_c (str, '-');\n          while (*s)\n            {\n              if (*s != '/')\n                g_string_append_c (str, *s);\n              s++;\n            }\n        }\n      checkout_basename = g_string_free (str, FALSE);\n    }\n\n  real_checkoutdir = g_file_get_child (deploy_base, checkout_basename);\n  if (g_file_query_exists (real_checkoutdir, cancellable))\n    {\n      g_set_error (error, FLATPAK_ERROR, FLATPAK_ERROR_ALREADY_INSTALLED,\n                   _(\"%s branch %s already installed\"), ref, checksum);\n      return FALSE;\n    }\n\n  g_autofree char *template = g_strdup_printf (\".%s-XXXXXX\", checkout_basename);\n  tmp_dir_template = g_file_get_child (deploy_base, template);\n  tmp_dir_path = g_file_get_path (tmp_dir_template);\n\n  if (g_mkdtemp_full (tmp_dir_path, 0755) == NULL)\n    {\n      g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_FAILED,\n                           _(\"Can't create deploy directory\"));\n      return FALSE;\n    }\n\n  checkoutdir = g_file_new_for_path (tmp_dir_path);\n\n  if (!ostree_repo_read_commit (self->repo, checksum, &root, NULL, cancellable, error))\n    {\n      g_prefix_error (error, _(\"Failed to read commit %s: \"), checksum);\n      return FALSE;\n    }\n\n  if (!flatpak_repo_collect_sizes (self->repo, root, &installed_size, NULL, cancellable, error))\n    return FALSE;\n\n  options.mode = OSTREE_REPO_CHECKOUT_MODE_USER;\n  options.overwrite_mode = OSTREE_REPO_CHECKOUT_OVERWRITE_UNION_FILES;\n  options.enable_fsync = FALSE; /* We checkout to a temp dir and sync before moving it in place */\n  options.bareuseronly_dirs = TRUE; /* https://github.com/ostreedev/ostree/pull/927 */\n  checkoutdirpath = g_file_get_path (checkoutdir);\n\n  if (subpaths == NULL || *subpaths == NULL)\n    {\n      if (!ostree_repo_checkout_at (self->repo, &options,\n                                    AT_FDCWD, checkoutdirpath,\n                                    checksum,\n                                    cancellable, error))\n        {\n          g_prefix_error (error, _(\"While trying to checkout %s into %s: \"), checksum, checkoutdirpath);\n          return FALSE;\n        }\n    }\n  else\n    {\n      g_autofree char *checkoutdirpath = g_file_get_path (checkoutdir);\n      g_autoptr(GFile) files = g_file_get_child (checkoutdir, \"files\");\n      g_autoptr(GFile) root = NULL;\n      g_autofree char *commit = NULL;\n      int i;\n\n      if (!g_file_make_directory_with_parents (files, cancellable, error))\n        return FALSE;\n\n      options.subpath = \"/metadata\";\n\n      if (!ostree_repo_read_commit (self->repo, checksum, &root,  &commit, cancellable, error))\n        return FALSE;\n\n      if (!ostree_repo_checkout_at (self->repo, &options,\n                                    AT_FDCWD, checkoutdirpath,\n                                    checksum,\n                                    cancellable, error))\n        {\n          g_prefix_error (error, _(\"While trying to checkout metadata subpath: \"));\n          return FALSE;\n        }\n\n      for (i = 0; subpaths[i] != NULL; i++)\n        {\n          g_autofree char *subpath = g_build_filename (\"/files\", subpaths[i], NULL);\n          g_autofree char *dstpath = g_build_filename (checkoutdirpath, \"/files\", subpaths[i], NULL);\n          g_autofree char *dstpath_parent = g_path_get_dirname (dstpath);\n          g_autoptr(GFile) child = NULL;\n\n          child = g_file_resolve_relative_path (root, subpath);\n\n          if (!g_file_query_exists (child, cancellable))\n            {\n              g_debug (\"subpath %s not in tree\", subpaths[i]);\n              continue;\n            }\n\n          if (g_mkdir_with_parents (dstpath_parent, 0755))\n            {\n              glnx_set_error_from_errno (error);\n              return FALSE;\n            }\n\n          options.subpath = subpath;\n          if (!ostree_repo_checkout_at (self->repo, &options,\n                                        AT_FDCWD, dstpath,\n                                        checksum,\n                                        cancellable, error))\n            {\n              g_prefix_error (error, _(\"While trying to checkout metadata subpath: \"));\n              return FALSE;\n            }\n        }\n    }\n\n  /* Extract any extra data */\n  extradir = g_file_resolve_relative_path (checkoutdir, \"files/extra\");\n  if (!flatpak_rm_rf (extradir, cancellable, error))\n    {\n      g_prefix_error (error, _(\"While trying to remove existing extra dir: \"));\n      return FALSE;\n    }\n\n  if (!extract_extra_data (self, checksum, extradir, &created_extra_data, cancellable, error))\n    return FALSE;\n\n  if (created_extra_data)\n    {\n      if (!apply_extra_data (self, checkoutdir, cancellable, error))\n        {\n          g_prefix_error (error, _(\"While trying to apply extra data: \"));\n          return FALSE;\n        }\n    }\n\n  g_variant_lookup (commit_metadata, \"xa.ref\", \"s\", &xa_ref);\n  if (xa_ref != NULL)\n    {\n      if (strcmp (ref, xa_ref) != 0)\n        {\n          g_set_error (error, G_IO_ERROR, G_IO_ERROR_PERMISSION_DENIED,\n                       _(\"Deployed ref %s does not match commit (%s)\"), ref, xa_ref);\n          return FALSE;\n        }\n    }\n\n  /* Check the metadata in the commit to make sure it matches the actual\n     deployed metadata, in case we relied on the one in the commit for\n     a decision */\n  g_variant_lookup (commit_metadata, \"xa.metadata\", \"s\", &xa_metadata);\n  if (xa_metadata != NULL)\n    {\n      g_autoptr(GFile) metadata_file = g_file_resolve_relative_path (checkoutdir, \"metadata\");\n      char *metadata_contents;\n\n      if (!g_file_load_contents (metadata_file, NULL,\n                                 &metadata_contents, NULL, NULL, NULL) ||\n          strcmp (metadata_contents, xa_metadata) != 0)\n        {\n          g_set_error (error, G_IO_ERROR, G_IO_ERROR_PERMISSION_DENIED,\n                       _(\"Deployed metadata does not match commit\"));\n          return FALSE;\n        }\n    }\n\n  dotref = g_file_resolve_relative_path (checkoutdir, \"files/.ref\");\n  if (!g_file_replace_contents (dotref, \"\", 0, NULL, FALSE,\n                                G_FILE_CREATE_REPLACE_DESTINATION, NULL, cancellable, error))\n    return TRUE;\n\n  /* Ensure that various files exists as regular files in /usr/etc, as we\n     want to bind-mount over them */\n  files_etc = g_file_resolve_relative_path (checkoutdir, \"files/etc\");\n  if (g_file_query_exists (files_etc, cancellable))\n    {\n      char *etcfiles[] = {\"passwd\", \"group\", \"machine-id\" };\n      g_autoptr(GFile) etc_resolve_conf = g_file_get_child (files_etc, \"resolv.conf\");\n      int i;\n      for (i = 0; i < G_N_ELEMENTS (etcfiles); i++)\n        {\n          g_autoptr(GFile) etc_file = g_file_get_child (files_etc, etcfiles[i]);\n          GFileType type;\n\n          type = g_file_query_file_type (etc_file, G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                         cancellable);\n          if (type == G_FILE_TYPE_REGULAR)\n            continue;\n\n          if (type != G_FILE_TYPE_UNKNOWN)\n            {\n              /* Already exists, but not regular, probably symlink. Remove it */\n              if (!g_file_delete (etc_file, cancellable, error))\n                return FALSE;\n            }\n\n          if (!g_file_replace_contents (etc_file, \"\", 0, NULL, FALSE,\n                                        G_FILE_CREATE_REPLACE_DESTINATION,\n                                        NULL, cancellable, error))\n            return FALSE;\n        }\n\n      if (g_file_query_exists (etc_resolve_conf, cancellable) &&\n          !g_file_delete (etc_resolve_conf, cancellable, error))\n        return TRUE;\n\n      if (!g_file_make_symbolic_link (etc_resolve_conf,\n                                      \"/run/host/monitor/resolv.conf\",\n                                      cancellable, error))\n        return FALSE;\n    }\n\n  keyfile = g_key_file_new ();\n  metadata = g_file_get_child (checkoutdir, \"metadata\");\n  if (g_file_query_exists (metadata, cancellable))\n    {\n      g_autofree char *path = g_file_get_path (metadata);\n\n      if (!g_key_file_load_from_file (keyfile, path, G_KEY_FILE_NONE, error))\n        return FALSE;\n    }\n\n  export = g_file_get_child (checkoutdir, \"export\");\n  if (g_file_query_exists (export, cancellable))\n    {\n      g_auto(GStrv) ref_parts = NULL;\n\n      ref_parts = g_strsplit (ref, \"/\", -1);\n\n      if (!flatpak_rewrite_export_dir (ref_parts[1], ref_parts[3], ref_parts[2],\n                                       keyfile, export,\n                                       cancellable,\n                                       error))\n        return FALSE;\n    }\n\n  g_variant_builder_init (&metadata_builder, G_VARIANT_TYPE (\"a{sv}\"));\n  if (alt_id)\n    g_variant_builder_add (&metadata_builder, \"{s@v}\", \"alt-id\",\n                           g_variant_new_variant (g_variant_new_string (alt_id)));\n\n  deploy_data = flatpak_dir_new_deploy_data (origin,\n                                             checksum,\n                                             (char **) subpaths,\n                                             installed_size,\n                                             g_variant_builder_end (&metadata_builder));\n\n  deploy_data_file = g_file_get_child (checkoutdir, \"deploy\");\n  if (!flatpak_variant_save (deploy_data_file, deploy_data, cancellable, error))\n    return FALSE;\n\n  if (!glnx_opendirat (AT_FDCWD, checkoutdirpath, TRUE, &checkoutdir_dfd, error))\n    return FALSE;\n\n  if (syncfs (checkoutdir_dfd) != 0)\n    {\n      glnx_set_error_from_errno (error);\n      return FALSE;\n    }\n\n  if (!g_file_move (checkoutdir, real_checkoutdir, G_FILE_COPY_NO_FALLBACK_FOR_MOVE,\n                    cancellable, NULL, NULL, error))\n    return FALSE;\n\n  if (!flatpak_dir_set_active (self, ref, checkout_basename, cancellable, error))\n    return FALSE;\n\n  return TRUE;\n}",
  "abstract_func": "gboolean\nflatpak_dir_deploy (FlatpakDir          *VAR_0,\n                    const char          *VAR_1,\n                    const char          *VAR_2,\n                    const char          *VAR_3,\n                    const char * const * VAR_4,\n                    GVariant            *VAR_5,\n                    GCancellable        *VAR_6,\n                    GError             **VAR_7)\n{\n  g_autofree char *VAR_8 = NULL;\n\n  VAR_9(GFile) VAR_10 = NULL;\n  VAR_9(GFile) VAR_11 = NULL;\n  VAR_9(GFile) VAR_12 = NULL;\n  g_autofree char *VAR_13 = NULL;\n  VAR_9(GFile) VAR_14 = NULL;\n  VAR_9(GFile) VAR_15 = NULL;\n  VAR_9(GFile) VAR_16 = NULL;\n  VAR_9(GFile) VAR_17 = NULL;\n  VAR_9(GFile) VAR_18 = NULL;\n  VAR_9(GVariant) VAR_19 = NULL;\n  VAR_9(GFile) VAR_20 = NULL;\n  VAR_9(GFile) VAR_21 = NULL;\n  VAR_9(GKeyFile) VAR_22 = NULL;\n  guint64 VAR_23 = 0;\n  OstreeRepoCheckoutAtOptions VAR_24 = { 0, };\n  const char *VAR_25;\n  glnx_fd_close VAR_26 VAR_27 = -1;\n  VAR_9(GFile) VAR_28 = NULL;\n  VAR_9(GVariant) VAR_29 = NULL;\n  g_autofree char *VAR_30 = NULL;\n  g_autofree char *VAR_31 = NULL;\n  const char *VAR_32 = NULL;\n  const char *VAR_33 = NULL;\n  g_autofree char *VAR_34 = NULL;\n  gboolean VAR_35 = FALSE;\n  VAR_9(GVariant) VAR_36 = NULL;\n  GVariantBuilder VAR_37;\n\n  if (!flatpak_dir_ensure_repo (VAR_0, VAR_6, VAR_7))\n    return FALSE;\n\n  VAR_11 = flatpak_dir_get_deploy_dir (VAR_0, VAR_2);\n\n  if (VAR_3 == NULL)\n    {\n      g_debug (\"No checksum specified, getting tip of %s\", VAR_2);\n\n      VAR_8 = flatpak_dir_read_latest (VAR_0, VAR_1, VAR_2, NULL, VAR_6, VAR_7);\n      if (VAR_8 == NULL)\n        {\n          g_prefix_error (VAR_7, _(\"While trying to resolve ref %s: \"), VAR_2);\n          return FALSE;\n        }\n\n      VAR_25 = VAR_8;\n      g_debug (\"tip resolved to: %s\", VAR_25);\n    }\n  else\n    {\n      VAR_9(GFile) VAR_10 = NULL;\n      g_autofree char *VAR_38 = NULL;\n\n      VAR_25 = VAR_3;\n      g_debug (\"Looking for checksum %s in local repo\", VAR_25);\n      if (!ostree_repo_read_commit (VAR_0->repo, VAR_25, &VAR_10, &VAR_38, VAR_6, NULL))\n        return flatpak_fail (VAR_7, _(\"%s is not available\"), VAR_2);\n    }\n\n  if (!ostree_repo_load_commit (VAR_0->repo, VAR_25, &VAR_29, NULL, VAR_7))\n    return FALSE;\n\n  VAR_36 = g_variant_get_child_value (VAR_29, 0);\n  g_variant_lookup (VAR_36, \"xa.alt-id\", \"s\", &VAR_31);\n\n  if (VAR_4 == NULL || *VAR_4 == NULL)\n    VAR_34 = g_strdup (VAR_25);\n  else\n    {\n      GString *VAR_39 = g_string_new (VAR_25);\n      int VAR_40;\n      for (VAR_40 = 0; VAR_4[VAR_40] != NULL; VAR_40++)\n        {\n          const char *VAR_41 = VAR_4[VAR_40];\n          g_string_append_c (VAR_39, '-');\n          while (*VAR_41)\n            {\n              if (*VAR_41 != '/')\n                g_string_append_c (VAR_39, *VAR_41);\n              VAR_41++;\n            }\n        }\n      VAR_34 = g_string_free (VAR_39, FALSE);\n    }\n\n  VAR_14 = g_file_get_child (VAR_11, VAR_34);\n  if (g_file_query_exists (VAR_14, VAR_6))\n    {\n      g_set_error (VAR_7, VAR_42, VAR_43,\n                   _(\"%s branch %s already installed\"), VAR_2, VAR_25);\n      return FALSE;\n    }\n\n  g_autofree char *VAR_44 = g_strdup_printf (\".%s-XXXXXX\", VAR_34);\n  VAR_28 = g_file_get_child (VAR_11, VAR_44);\n  VAR_30 = g_file_get_path (VAR_28);\n\n  if (g_mkdtemp_full (VAR_30, 0755) == NULL)\n    {\n      g_set_error_literal (VAR_7, VAR_45, VAR_46,\n                           _(\"Can't create deploy directory\"));\n      return FALSE;\n    }\n\n  VAR_12 = g_file_new_for_path (VAR_30);\n\n  if (!ostree_repo_read_commit (VAR_0->repo, VAR_25, &VAR_10, NULL, VAR_6, VAR_7))\n    {\n      g_prefix_error (VAR_7, _(\"Failed to read commit %s: \"), VAR_25);\n      return FALSE;\n    }\n\n  if (!flatpak_repo_collect_sizes (VAR_0->repo, VAR_10, &VAR_23, NULL, VAR_6, VAR_7))\n    return FALSE;\n\n  VAR_24.mode = VAR_47;\n  VAR_24.overwrite_mode = VAR_48;\n  VAR_24.enable_fsync = FALSE; /* COMMENT_0 */\n  VAR_24.bareuseronly_dirs = TRUE; /* COMMENT_1 */\n  VAR_13 = g_file_get_path (VAR_12);\n\n  if (VAR_4 == NULL || *VAR_4 == NULL)\n    {\n      if (!ostree_repo_checkout_at (VAR_0->repo, &VAR_24,\n                                    VAR_49, VAR_13,\n                                    VAR_25,\n                                    VAR_6, VAR_7))\n        {\n          g_prefix_error (VAR_7, _(\"While trying to checkout %s into %s: \"), VAR_25, VAR_13);\n          return FALSE;\n        }\n    }\n  else\n    {\n      g_autofree char *VAR_13 = g_file_get_path (VAR_12);\n      VAR_9(GFile) VAR_50 = g_file_get_child (VAR_12, \"files\");\n      VAR_9(GFile) VAR_10 = NULL;\n      g_autofree char *VAR_38 = NULL;\n      int VAR_40;\n\n      if (!g_file_make_directory_with_parents (VAR_50, VAR_6, VAR_7))\n        return FALSE;\n\n      VAR_24.subpath = \"/metadata\";\n\n      if (!ostree_repo_read_commit (VAR_0->repo, VAR_25, &VAR_10,  &VAR_38, VAR_6, VAR_7))\n        return FALSE;\n\n      if (!ostree_repo_checkout_at (VAR_0->repo, &VAR_24,\n                                    VAR_49, VAR_13,\n                                    VAR_25,\n                                    VAR_6, VAR_7))\n        {\n          g_prefix_error (VAR_7, _(\"While trying to checkout metadata subpath: \"));\n          return FALSE;\n        }\n\n      for (VAR_40 = 0; VAR_4[VAR_40] != NULL; VAR_40++)\n        {\n          g_autofree char *VAR_51 = g_build_filename (\"/files\", VAR_4[VAR_40], NULL);\n          g_autofree char *VAR_52 = g_build_filename (VAR_13, \"/files\", VAR_4[VAR_40], NULL);\n          g_autofree char *VAR_53 = g_path_get_dirname (VAR_52);\n          VAR_9(GFile) VAR_54 = NULL;\n\n          VAR_54 = g_file_resolve_relative_path (VAR_10, VAR_51);\n\n          if (!g_file_query_exists (VAR_54, VAR_6))\n            {\n              g_debug (\"subpath %s not in tree\", VAR_4[VAR_40]);\n              continue;\n            }\n\n          if (g_mkdir_with_parents (VAR_53, 0755))\n            {\n              glnx_set_error_from_errno (VAR_7);\n              return FALSE;\n            }\n\n          VAR_24.subpath = VAR_51;\n          if (!ostree_repo_checkout_at (VAR_0->repo, &VAR_24,\n                                        VAR_49, VAR_52,\n                                        VAR_25,\n                                        VAR_6, VAR_7))\n            {\n              g_prefix_error (VAR_7, _(\"While trying to checkout metadata subpath: \"));\n              return FALSE;\n            }\n        }\n    }\n\n  /* COMMENT_2 */\n  VAR_21 = g_file_resolve_relative_path (VAR_12, \"files/extra\");\n  if (!flatpak_rm_rf (VAR_21, VAR_6, VAR_7))\n    {\n      g_prefix_error (VAR_7, _(\"While trying to remove existing extra dir: \"));\n      return FALSE;\n    }\n\n  if (!extract_extra_data (VAR_0, VAR_25, VAR_21, &VAR_35, VAR_6, VAR_7))\n    return FALSE;\n\n  if (VAR_35)\n    {\n      if (!apply_extra_data (VAR_0, VAR_12, VAR_6, VAR_7))\n        {\n          g_prefix_error (VAR_7, _(\"While trying to apply extra data: \"));\n          return FALSE;\n        }\n    }\n\n  g_variant_lookup (VAR_36, \"xa.ref\", \"s\", &VAR_33);\n  if (VAR_33 != NULL)\n    {\n      if (strcmp (VAR_2, VAR_33) != 0)\n        {\n          g_set_error (VAR_7, VAR_45, VAR_55,\n                       _(\"Deployed ref %s does not match commit (%s)\"), VAR_2, VAR_33);\n          return FALSE;\n        }\n    }\n\n  /* COMMENT_3 */\n                                                                      \n                  \n  g_variant_lookup (VAR_36, \"xa.metadata\", \"s\", &VAR_32);\n  if (VAR_32 != NULL)\n    {\n      VAR_9(GFile) VAR_56 = g_file_resolve_relative_path (VAR_12, \"metadata\");\n      char *VAR_57;\n\n      if (!g_file_load_contents (VAR_56, NULL,\n                                 &VAR_57, NULL, NULL, NULL) ||\n          strcmp (VAR_57, VAR_32) != 0)\n        {\n          g_set_error (VAR_7, VAR_45, VAR_55,\n                       _(\"Deployed metadata does not match commit\"));\n          return FALSE;\n        }\n    }\n\n  VAR_15 = g_file_resolve_relative_path (VAR_12, \"files/.ref\");\n  if (!g_file_replace_contents (VAR_15, \"\", 0, NULL, FALSE,\n                                VAR_58, NULL, VAR_6, VAR_7))\n    return TRUE;\n\n  /* COMMENT_6 */\n                                    \n  VAR_16 = g_file_resolve_relative_path (VAR_12, \"files/etc\");\n  if (g_file_query_exists (VAR_16, VAR_6))\n    {\n      char *VAR_59[] = {\"passwd\", \"group\", \"machine-id\" };\n      VAR_9(GFile) VAR_60 = g_file_get_child (VAR_16, \"resolv.conf\");\n      int VAR_40;\n      for (VAR_40 = 0; VAR_40 < G_N_ELEMENTS (VAR_59); VAR_40++)\n        {\n          VAR_9(GFile) VAR_61 = g_file_get_child (VAR_16, VAR_59[VAR_40]);\n          GFileType VAR_62;\n\n          VAR_62 = g_file_query_file_type (VAR_61, VAR_63,\n                                         VAR_6);\n          if (VAR_62 == VAR_64)\n            continue;\n\n          if (VAR_62 != VAR_65)\n            {\n              /* COMMENT_8 */\n              if (!g_file_delete (VAR_61, VAR_6, VAR_7))\n                return FALSE;\n            }\n\n          if (!g_file_replace_contents (VAR_61, \"\", 0, NULL, FALSE,\n                                        VAR_58,\n                                        NULL, VAR_6, VAR_7))\n            return FALSE;\n        }\n\n      if (g_file_query_exists (VAR_60, VAR_6) &&\n          !g_file_delete (VAR_60, VAR_6, VAR_7))\n        return TRUE;\n\n      if (!g_file_make_symbolic_link (VAR_60,\n                                      \"/run/host/monitor/resolv.conf\",\n                                      VAR_6, VAR_7))\n        return FALSE;\n    }\n\n  VAR_22 = g_key_file_new ();\n  VAR_17 = g_file_get_child (VAR_12, \"metadata\");\n  if (g_file_query_exists (VAR_17, VAR_6))\n    {\n      g_autofree char *VAR_66 = g_file_get_path (VAR_17);\n\n      if (!g_key_file_load_from_file (VAR_22, VAR_66, VAR_67, VAR_7))\n        return FALSE;\n    }\n\n  VAR_20 = g_file_get_child (VAR_12, \"export\");\n  if (g_file_query_exists (VAR_20, VAR_6))\n    {\n      VAR_68(GStrv) VAR_69 = NULL;\n\n      VAR_69 = g_strsplit (VAR_2, \"/\", -1);\n\n      if (!flatpak_rewrite_export_dir (VAR_69[1], VAR_69[3], VAR_69[2],\n                                       VAR_22, VAR_20,\n                                       VAR_6,\n                                       VAR_7))\n        return FALSE;\n    }\n\n  g_variant_builder_init (&VAR_37, G_VARIANT_TYPE (\"a{sv}\"));\n  if (VAR_31)\n    g_variant_builder_add (&VAR_37, \"{s@v}\", \"alt-id\",\n                           g_variant_new_variant (g_variant_new_string (VAR_31)));\n\n  VAR_19 = flatpak_dir_new_deploy_data (VAR_1,\n                                             VAR_25,\n                                             (char **) VAR_4,\n                                             VAR_23,\n                                             g_variant_builder_end (&VAR_37));\n\n  VAR_18 = g_file_get_child (VAR_12, \"deploy\");\n  if (!flatpak_variant_save (VAR_18, VAR_19, VAR_6, VAR_7))\n    return FALSE;\n\n  if (!glnx_opendirat (VAR_49, VAR_13, TRUE, &VAR_27, VAR_7))\n    return FALSE;\n\n  if (syncfs (VAR_27) != 0)\n    {\n      glnx_set_error_from_errno (VAR_7);\n      return FALSE;\n    }\n\n  if (!g_file_move (VAR_12, VAR_14, VAR_70,\n                    VAR_6, NULL, NULL, VAR_7))\n    return FALSE;\n\n  if (!flatpak_dir_set_active (VAR_0, VAR_2, VAR_34, VAR_6, VAR_7))\n    return FALSE;\n\n  return TRUE;\n}",
  "func_graph_path": "flatpak/aed5d0919830c02e490f669fc36bd9af42e632d6/flatpak-dir.c/vul/after/3.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -127,6 +127,7 @@\n   options.mode = OSTREE_REPO_CHECKOUT_MODE_USER;\n   options.overwrite_mode = OSTREE_REPO_CHECKOUT_OVERWRITE_UNION_FILES;\n   options.enable_fsync = FALSE; /* We checkout to a temp dir and sync before moving it in place */\n+  options.bareuseronly_dirs = TRUE; /* https://github.com/ostreedev/ostree/pull/927 */\n   checkoutdirpath = g_file_get_path (checkoutdir);\n \n   if (subpaths == NULL || *subpaths == NULL)",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "  options.bareuseronly_dirs = TRUE; /* https://github.com/ostreedev/ostree/pull/927 */"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/flatpak/flatpak/pull/848",
  "description": {
    "pr_info": {
      "title": "system-helper: Use new ostree APIs to reject world-writable/suid content",
      "number": 848
    },
    "comment": [
      "This uses the new libostree APIs that landed recently to ensure\r\nthat we reject any files with mode outside of `0775` for system\r\nhelper pulls, and we also neuter directories during checkout.\r\n\r\nHowever, this does *not* fix up any already downloaded content.\r\nFor that, one could uninstall/reinstall; or a future patch could\r\ndo a one-time fixup pass.\r\n\r\nCloses: https://github.com/flatpak/flatpak/issues/845",
      "Side note; I found it double plus confusing that the system helper path actually wasn't using `flatpak_dir_pull_untrusted_local()`...why does the code try to distinguish between \"local repo\" and `file:///` URI?  In libostree they should be the same thing.",
      "Also something I'm not entirely sure of is the appstream stuff; we appear to be doing pulls for that too that go through separate paths? ",
      "It *is* using flatpak_dir_pull_untrusted_local(). There are two codepaths here. \r\n\r\nOne is the case where the system repo has a remote configured with a file: uri. In this case we just do the pull entierly in the system helper. This is the codepath your current patch has implemented.\r\n\r\nThe other case is where the remote has a non-local uri, but the app already downloaded this to a separate local directory, which is specified with arg_repo_path. In this case we're using flatpak_dir_pull_untrusted_local(). The current patch doesn't handle this case.\r\n\r\nThese are not the same, because in one case the sysadmin defined a pathname as \"trusted\" by configuring a remote at that location. In the second case the caller (who is untrusted) passes in the directory in which to read the files from, and we have to be much more careful about what we pull from this. \r\n\r\nFor the appstream we're pulling in the same way as for app, but the deploy is different (because the checkout is to a different location). This looks fine in the patch.",
      "Ah, and because I was testing this with a \"local\" remote from a locally built app I ended up in the other path.  OK.\r\n\r\nI actually did patch `flatpak_dir_pull_untrusted_local()` though.  That's what I tried first and was really confused when it didn't work.\r\n",
      "Or in other words, the patch is correct?",
      "Oh, lemme check.\r\nIt needs a configure check for the new ostree version though.",
      "Ah, yes. It is correct. However, i would like you to also pass that flag in repo_pull_one_dir, so we get nice warnings about this earlier in the process (and for --user installs).",
      "Let's land https://github.com/flatpak/flatpak/pull/849 first.",
      "Like that :arrow_up:  ?",
      "> error: Can't use bareuseronly-files with non-local origin repo\r\n\r\nAh, yes.  Mrm.  I had originally designed this only for the system helper but perhaps it's better to support it for HTTP pulls too.  Will make a change in libostree.\r\n",
      "Now depends on https://github.com/ostreedev/ostree/pull/930",
      "I guess you can rebase this on master now.",
      "Done. :surfing_man: ",
      "OK, let's give things a day or two at least in git master and do releases?"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch modifies the deployment process to enforce stricter file permissions, preventing world-writable and suid files, which are security risks. The commit message highlights potential exploitation and the fix's intent to mitigate such risks.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 0.95"
}