{
  "cve_id": "CVE-2023-40012",
  "cwe_ids": [
    "CWE-325",
    "CWE-347"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N",
  "cvss_is_v3": true,
  "repo_name": "trailofbits/uthenticode",
  "commit_msg": "src: bump OpenSSL, EKU check (#78)\n\n* src: bump OpenSSL, EKU check\r\n\r\nSigned-off-by: William Woodruff <william@trailofbits.com>\r\n\r\n* README: bump OpenSSL\r\n\r\nSigned-off-by: William Woodruff <william@trailofbits.com>\r\n\r\n* test: EKU test, testcase\r\n\r\nSigned-off-by: William Woodruff <william@trailofbits.com>\r\n\r\n---------\r\n\r\nSigned-off-by: William Woodruff <william@trailofbits.com>",
  "commit_hash": "caeb1eb62412605f71bd96ce9bb9420644b6db53",
  "git_url": "https://github.com/trailofbits/uthenticode/commit/caeb1eb62412605f71bd96ce9bb9420644b6db53",
  "file_path": "src/uthenticode.cpp",
  "func_name": "SignedData::verify_signature",
  "func_before": "bool SignedData::verify_signature() const {\n  STACK_OF(X509) *certs = nullptr;\n  switch (OBJ_obj2nid(p7_->type)) {\n    case NID_pkcs7_signed: {\n      certs = p7_->d.sign->cert;\n      break;\n    }\n    /* NOTE(ww): I'm pretty sure Authenticode signatures are always SignedData and never\n     * SignedAndEnvelopedData, but it doesn't hurt us to handle the latter as well.\n     */\n    case NID_pkcs7_signedAndEnveloped: {\n      certs = p7_->d.signed_and_enveloped->cert;\n      break;\n    }\n  }\n\n  if (certs == nullptr) {\n    return false;\n  }\n\n  /* NOTE(ww): What happens below is a bit dumb: we convert our SpcIndirectDataContent back\n   * into DER form so that we can unwrap its ASN.1 sequence and pass the underlying data\n   * to PKCS7_verify for verification. This displays our intent a little more clearly than\n   * our previous approach, which was to walk the PKCS#7 structure manually.\n   */\n  std::uint8_t *indirect_data_buf = nullptr;\n  auto buf_size = impl::i2d_Authenticode_SpcIndirectDataContent(indirect_data_, &indirect_data_buf);\n  if (buf_size < 0 || indirect_data_buf == nullptr) {\n    return false;\n  }\n  auto indirect_data_ptr =\n      impl::OpenSSL_ptr(reinterpret_cast<char *>(indirect_data_buf), impl::OpenSSL_free);\n\n  const auto *signed_data_seq = reinterpret_cast<std::uint8_t *>(indirect_data_ptr.get());\n  long length = 0;\n  int tag = 0, tag_class = 0;\n  ASN1_get_object(&signed_data_seq, &length, &tag, &tag_class, buf_size);\n  if (tag != V_ASN1_SEQUENCE) {\n    return false;\n  }\n\n  auto *signed_data_ptr = BIO_new_mem_buf(signed_data_seq, length);\n  if (signed_data_ptr == nullptr) {\n    return false;\n  }\n  impl::BIO_ptr signed_data(signed_data_ptr, BIO_free);\n\n  /* Our actual verification happens here.\n   *\n   * We pass `certs` explicitly, but (experimentally) we don't have to -- the function correctly\n   * extracts then from the SignedData in `p7_`.\n   *\n   * We pass `nullptr` for the X509_STORE, since we don't do full-chain verification\n   * (we can't, since we don't have access to Windows's Trusted Publishers store on non-Windows).\n   */\n  auto status = PKCS7_verify(p7_, certs, nullptr, signed_data.get(), nullptr, PKCS7_NOVERIFY);\n\n  return status == 1;\n}",
  "abstract_func_before": "bool SignedData::verify_signature() const {\n  STACK_OF(VAR_0) *VAR_1 = nullptr;\n  switch (OBJ_obj2nid(VAR_2->type)) {\n    case VAR_3: {\n      VAR_1 = VAR_2->d.sign->cert;\n      break;\n    }\n    /* COMMENT_0 */\n                                                                                   \n       \n    case VAR_4: {\n      VAR_1 = VAR_2->d.signed_and_enveloped->cert;\n      break;\n    }\n  }\n\n  if (VAR_1 == nullptr) {\n    return false;\n  }\n\n  /* COMMENT_3 */\n                                                                                        \n                                                                                          \n                                                                            \n     \n  std::uint8_t *VAR_5 = nullptr;\n  auto VAR_6 = impl::i2d_Authenticode_SpcIndirectDataContent(VAR_7, &VAR_5);\n  if (VAR_6 < 0 || VAR_5 == nullptr) {\n    return false;\n  }\n  auto VAR_8 =\n      impl::OpenSSL_ptr(VAR_9<char *>(VAR_5), impl::OpenSSL_free);\n\n  const auto *VAR_10 = VAR_9<std::uint8_t *>(VAR_8.get());\n  long VAR_11 = 0;\n  int VAR_12 = 0, VAR_13 = 0;\n  ASN1_get_object(&VAR_10, &VAR_11, &VAR_12, &VAR_13, VAR_6);\n  if (VAR_12 != VAR_14) {\n    return false;\n  }\n\n  auto *VAR_15 = BIO_new_mem_buf(VAR_10, VAR_11);\n  if (VAR_15 == nullptr) {\n    return false;\n  }\n  impl::BIO_ptr signed_data(signed_data_ptr, BIO_free);\n\n  /* COMMENT_8 */\n    \n                                                                                                \n                                                \n    \n                                                                                    \n                                                                                                 \n     \n  auto VAR_16 = PKCS7_verify(VAR_2, VAR_1, nullptr, VAR_17.get(), nullptr, VAR_18);\n\n  return VAR_16 == 1;\n}",
  "func_graph_path_before": "trailofbits/uthenticode/caeb1eb62412605f71bd96ce9bb9420644b6db53/uthenticode.cpp/vul/before/0.json",
  "func": "bool SignedData::verify_signature() const {\n  STACK_OF(X509) *certs = nullptr;\n  switch (OBJ_obj2nid(p7_->type)) {\n    case NID_pkcs7_signed: {\n      certs = p7_->d.sign->cert;\n      break;\n    }\n    /* NOTE(ww): I'm pretty sure Authenticode signatures are always SignedData and never\n     * SignedAndEnvelopedData, but it doesn't hurt us to handle the latter as well.\n     */\n    case NID_pkcs7_signedAndEnveloped: {\n      certs = p7_->d.signed_and_enveloped->cert;\n      break;\n    }\n  }\n\n  if (certs == nullptr) {\n    return false;\n  }\n\n  auto *signers_stack_ptr = PKCS7_get0_signers(p7_, nullptr, 0);\n  if (signers_stack_ptr == nullptr) {\n    return false;\n  }\n  auto signers_stack = impl::STACK_OF_X509_ptr(signers_stack_ptr, impl::SK_X509_free);\n\n  /* NOTE(ww): Authenticode specification, page 13: the signer must have the\n   * codeSigning EKU, **or** no member of the signer's chain may have it.\n   *\n   * The check below is more strict than that: **every** signer must have\n   * the codeSigning EKU, and we don't check the embedded chain (since\n   * we can't do full chain verification anyways).\n   */\n  for (auto i = 0; i < sk_X509_num(signers_stack.get()); ++i) {\n    auto *signer = sk_X509_value(signers_stack.get(), i);\n\n    /* NOTE(ww): Ths should really be X509_check_purpose with\n     * X509_PURPOSE_CODE_SIGN, but this is inexplicably not present\n     * in even the latest releases of OpenSSL as of 2023-05.\n     */\n    auto xku_flags = X509_get_extended_key_usage(signer);\n    if (!(xku_flags & XKU_CODE_SIGN)) {\n      return false;\n    }\n  }\n\n  /* NOTE(ww): What happens below is a bit dumb: we convert our SpcIndirectDataContent back\n   * into DER form so that we can unwrap its ASN.1 sequence and pass the underlying data\n   * to PKCS7_verify for verification. This displays our intent a little more clearly than\n   * our previous approach, which was to walk the PKCS#7 structure manually.\n   */\n  std::uint8_t *indirect_data_buf = nullptr;\n  auto buf_size = impl::i2d_Authenticode_SpcIndirectDataContent(indirect_data_, &indirect_data_buf);\n  if (buf_size < 0 || indirect_data_buf == nullptr) {\n    return false;\n  }\n  auto indirect_data_ptr =\n      impl::OpenSSL_ptr(reinterpret_cast<char *>(indirect_data_buf), impl::OpenSSL_free);\n\n  const auto *signed_data_seq = reinterpret_cast<std::uint8_t *>(indirect_data_ptr.get());\n  long length = 0;\n  int tag = 0, tag_class = 0;\n  ASN1_get_object(&signed_data_seq, &length, &tag, &tag_class, buf_size);\n  if (tag != V_ASN1_SEQUENCE) {\n    return false;\n  }\n\n  auto *signed_data_ptr = BIO_new_mem_buf(signed_data_seq, length);\n  if (signed_data_ptr == nullptr) {\n    return false;\n  }\n  impl::BIO_ptr signed_data(signed_data_ptr, BIO_free);\n\n  /* Our actual verification happens here.\n   *\n   * We pass `certs` explicitly, but (experimentally) we don't have to -- the function correctly\n   * extracts then from the SignedData in `p7_`.\n   *\n   * We pass `nullptr` for the X509_STORE, since we don't do full-chain verification\n   * (we can't, since we don't have access to Windows's Trusted Publishers store on non-Windows).\n   */\n  auto status = PKCS7_verify(p7_, certs, nullptr, signed_data.get(), nullptr, PKCS7_NOVERIFY);\n\n  return status == 1;\n}",
  "abstract_func": "bool SignedData::verify_signature() const {\n  STACK_OF(VAR_0) *VAR_1 = nullptr;\n  switch (OBJ_obj2nid(VAR_2->type)) {\n    case VAR_3: {\n      VAR_1 = VAR_2->d.sign->cert;\n      break;\n    }\n    /* COMMENT_0 */\n                                                                                   \n       \n    case VAR_4: {\n      VAR_1 = VAR_2->d.signed_and_enveloped->cert;\n      break;\n    }\n  }\n\n  if (VAR_1 == nullptr) {\n    return false;\n  }\n\n  auto *VAR_5 = PKCS7_get0_signers(VAR_2, nullptr, 0);\n  if (VAR_5 == nullptr) {\n    return false;\n  }\n  auto VAR_6 = impl::STACK_OF_X509_ptr(VAR_5, impl::SK_X509_free);\n\n  /* COMMENT_3 */\n                                                                         \n    \n                                                                         \n                                                                      \n                                                  \n     \n  for (auto VAR_7 = 0; VAR_7 < sk_X509_num(VAR_6.get()); ++VAR_7) {\n    auto *VAR_8 = sk_X509_value(VAR_6.get(), VAR_7);\n\n    /* COMMENT_10 */\n                                                                   \n                                                            \n       \n    auto VAR_9 = X509_get_extended_key_usage(VAR_8);\n    if (!(VAR_9 & VAR_10)) {\n      return false;\n    }\n  }\n\n  /* COMMENT_14 */\n                                                                                        \n                                                                                          \n                                                                            \n     \n  std::uint8_t *VAR_11 = nullptr;\n  auto VAR_12 = impl::i2d_Authenticode_SpcIndirectDataContent(VAR_13, &VAR_11);\n  if (VAR_12 < 0 || VAR_11 == nullptr) {\n    return false;\n  }\n  auto VAR_14 =\n      impl::OpenSSL_ptr(VAR_15<char *>(VAR_11), impl::OpenSSL_free);\n\n  const auto *VAR_16 = VAR_15<std::uint8_t *>(VAR_14.get());\n  long VAR_17 = 0;\n  int VAR_18 = 0, VAR_19 = 0;\n  ASN1_get_object(&VAR_16, &VAR_17, &VAR_18, &VAR_19, VAR_12);\n  if (VAR_18 != VAR_20) {\n    return false;\n  }\n\n  auto *VAR_21 = BIO_new_mem_buf(VAR_16, VAR_17);\n  if (VAR_21 == nullptr) {\n    return false;\n  }\n  impl::BIO_ptr signed_data(signed_data_ptr, BIO_free);\n\n  /* COMMENT_19 */\n    \n                                                                                                \n                                                \n    \n                                                                                    \n                                                                                                 \n     \n  auto VAR_22 = PKCS7_verify(VAR_2, VAR_1, nullptr, VAR_23.get(), nullptr, VAR_24);\n\n  return VAR_22 == 1;\n}",
  "func_graph_path": "trailofbits/uthenticode/caeb1eb62412605f71bd96ce9bb9420644b6db53/uthenticode.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -16,6 +16,32 @@\n \n   if (certs == nullptr) {\n     return false;\n+  }\n+\n+  auto *signers_stack_ptr = PKCS7_get0_signers(p7_, nullptr, 0);\n+  if (signers_stack_ptr == nullptr) {\n+    return false;\n+  }\n+  auto signers_stack = impl::STACK_OF_X509_ptr(signers_stack_ptr, impl::SK_X509_free);\n+\n+  /* NOTE(ww): Authenticode specification, page 13: the signer must have the\n+   * codeSigning EKU, **or** no member of the signer's chain may have it.\n+   *\n+   * The check below is more strict than that: **every** signer must have\n+   * the codeSigning EKU, and we don't check the embedded chain (since\n+   * we can't do full chain verification anyways).\n+   */\n+  for (auto i = 0; i < sk_X509_num(signers_stack.get()); ++i) {\n+    auto *signer = sk_X509_value(signers_stack.get(), i);\n+\n+    /* NOTE(ww): Ths should really be X509_check_purpose with\n+     * X509_PURPOSE_CODE_SIGN, but this is inexplicably not present\n+     * in even the latest releases of OpenSSL as of 2023-05.\n+     */\n+    auto xku_flags = X509_get_extended_key_usage(signer);\n+    if (!(xku_flags & XKU_CODE_SIGN)) {\n+      return false;\n+    }\n   }\n \n   /* NOTE(ww): What happens below is a bit dumb: we convert our SpcIndirectDataContent back",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "  }",
      "",
      "  auto *signers_stack_ptr = PKCS7_get0_signers(p7_, nullptr, 0);",
      "  if (signers_stack_ptr == nullptr) {",
      "    return false;",
      "  }",
      "  auto signers_stack = impl::STACK_OF_X509_ptr(signers_stack_ptr, impl::SK_X509_free);",
      "",
      "  /* NOTE(ww): Authenticode specification, page 13: the signer must have the",
      "   * codeSigning EKU, **or** no member of the signer's chain may have it.",
      "   *",
      "   * The check below is more strict than that: **every** signer must have",
      "   * the codeSigning EKU, and we don't check the embedded chain (since",
      "   * we can't do full chain verification anyways).",
      "   */",
      "  for (auto i = 0; i < sk_X509_num(signers_stack.get()); ++i) {",
      "    auto *signer = sk_X509_value(signers_stack.get(), i);",
      "",
      "    /* NOTE(ww): Ths should really be X509_check_purpose with",
      "     * X509_PURPOSE_CODE_SIGN, but this is inexplicably not present",
      "     * in even the latest releases of OpenSSL as of 2023-05.",
      "     */",
      "    auto xku_flags = X509_get_extended_key_usage(signer);",
      "    if (!(xku_flags & XKU_CODE_SIGN)) {",
      "      return false;",
      "    }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/trailofbits/uthenticode/pull/78",
  "description": {
    "pr_info": {
      "title": "src: bump OpenSSL, EKU check",
      "number": 78
    },
    "comment": [
      "We now use OpenSSL 3.0 or higher.\r\n\r\nThis also (partially) fixes a gap in our Authenticode compliance: we now reject signer certificates that lack the `codeSigning` EKU. This is a superset of Authenticode's specified behavior, as we lack the context (a full chain) needed to accept some certificates that don't have the `codeSigning` EKU. In practice, this shouldn't be a concern: most Authenticode CAs should be issuing EE certs with this EKU.",
      "~~N.B.: This needs a unit test before merging.~~"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix\n\nConfidence Score: 0.9",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch updates the verification process to check for the Extended Key Usage (EKU) extension, ensuring that certificates used for signing have the code signing EKU. This addresses a potential security issue where improper certificates could be used, enhancing security.\n\nFinal Classification: Security Vulnerability Fix\n\nConfidence Score: 0.9"
}