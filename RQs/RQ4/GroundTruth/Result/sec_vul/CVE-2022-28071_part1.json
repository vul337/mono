{
  "cve_id": "CVE-2022-28071",
  "cwe_ids": [
    "CWE-416"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "radareorg/radare2",
  "commit_msg": "Fix UAF in aaft (tests_64923) ##crash\n\nReported by giantbranch of NSFOCUS TIANJI Lab",
  "commit_hash": "65448811e5b9582a19cf631e03cfcaa025a92ef5",
  "git_url": "https://github.com/radareorg/radare2/commit/65448811e5b9582a19cf631e03cfcaa025a92ef5",
  "file_path": "libr/core/anal_tp.c",
  "func_name": "r_core_anal_type_match",
  "func_before": "R_API void r_core_anal_type_match(RCore *core, RAnalFunction *fcn) {\n\tRAnalBlock *bb;\n\tRListIter *it;\n\tRAnalOp aop = {0};\n\tbool resolved = false;\n\n\tr_return_if_fail (core && core->anal && fcn);\n\n\tif (!core->anal->esil) {\n\t\teprintf (\"Please run aeim\\n\");\n\t\treturn;\n\t}\n\n\tRAnal *anal = core->anal;\n\tSdb *TDB = anal->sdb_types;\n\tbool chk_constraint = r_config_get_i (core->config, \"anal.types.constraint\");\n\tint ret, bsize = R_MAX (64, core->blocksize);\n\tconst int mininstrsz = r_anal_archinfo (anal, R_ANAL_ARCHINFO_MIN_OP_SIZE);\n\tconst int minopcode = R_MAX (1, mininstrsz);\n\tint cur_idx , prev_idx = 0;\n\tRConfigHold *hc = r_config_hold_new (core->config);\n\tif (!hc) {\n\t\treturn;\n\t}\n\tRDebugTrace *dt = NULL;\n\tRAnalEsilTrace *et = NULL;\n\tif (!anal_emul_init (core, hc, &dt, &et) || !fcn) {\n\t\tanal_emul_restore (core, hc, dt, et);\n\t\treturn;\n\t}\n\tut8 *buf = malloc (bsize);\n\tif (!buf) {\n\t\tanal_emul_restore (core, hc, dt, et);\n\t\treturn;\n\t}\n\n\t// Reserve bigger ht to avoid rehashing\n\tSdb *etracedb = core->anal->esil->trace->db;\n\tHtPPOptions opt = etracedb->ht->opt;\n\tht_pp_free (etracedb->ht);\n\tetracedb->ht = ht_pp_new_size (fcn->ninstr * 0xf, opt.dupvalue, opt.freefn, opt.calcsizeV);\n\tetracedb->ht->opt = opt;\n\tRDebugTrace *dtrace = core->dbg->trace;\n\topt = dtrace->ht->opt;\n\tht_pp_free (dtrace->ht);\n\tdtrace->ht = ht_pp_new_size (fcn->ninstr, opt.dupvalue, opt.freefn, opt.calcsizeV);\n\tdtrace->ht->opt = opt;\n\n\tchar *fcn_name = NULL;\n\tchar *ret_type = NULL;\n\tbool str_flag = false;\n\tbool prop = false;\n\tbool prev_var = false;\n\tchar prev_type[256] = {0};\n\tconst char *prev_dest = NULL;\n\tchar *ret_reg = NULL;\n\tconst char *pc = r_reg_get_name (core->dbg->reg, R_REG_NAME_PC);\n\tif (!pc) {\n        free (buf);\n\t\treturn;\n\t}\n\tRRegItem *r = r_reg_get (core->dbg->reg, pc, -1);\n\tif (!r) {\n\t\tfree (buf);\n\t\treturn;\n\t}\n\tr_cons_break_push (NULL, NULL);\n\tr_list_sort (fcn->bbs, bb_cmpaddr); // TODO: The algorithm can be more accurate if blocks are followed by their jmp/fail, not just by address\n\tr_list_foreach (fcn->bbs, it, bb) {\n\t\tut64 addr = bb->addr;\n\t\tint i = 0;\n\t\tr_reg_set_value (core->dbg->reg, r, addr);\n\t\twhile (1) {\n\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\tgoto out_function;\n\t\t\t}\n\t\t\tif (i >= (bsize - 32)) {\n\t\t\t\ti = 0;\n\t\t\t}\n\t\t\tut64 pcval = r_reg_getv (anal->reg, pc);\n\t\t\tif ((addr >= bb->addr + bb->size) || (addr < bb->addr) || pcval != addr) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!i) {\n\t\t\t\tr_io_read_at (core->io, addr, buf, bsize);\n\t\t\t}\n\t\t\tret = r_anal_op (anal, &aop, addr, buf + i, bsize - i, R_ANAL_OP_MASK_BASIC | R_ANAL_OP_MASK_VAL);\n\t\t\tif (ret <= 0) {\n\t\t\t\ti += minopcode;\n\t\t\t\taddr += minopcode;\n\t\t\t\tr_anal_op_fini (&aop);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint loop_count = sdb_num_get (anal->esil->trace->db, sdb_fmt (\"0x%\"PFMT64x\".count\", addr), 0);\n\t\t\tif (loop_count > LOOP_MAX || aop.type == R_ANAL_OP_TYPE_RET) {\n\t\t\t\tr_anal_op_fini (&aop);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsdb_num_set (anal->esil->trace->db, sdb_fmt (\"0x%\"PFMT64x\".count\", addr), loop_count + 1, 0);\n\t\t\tif (r_anal_op_nonlinear (aop.type)) {   // skip the instr\n\t\t\t\tr_reg_set_value (core->dbg->reg, r, addr + ret);\n\t\t\t} else {\n\t\t\t\tr_core_esil_step (core, UT64_MAX, NULL, NULL, false);\n\t\t\t}\n\t\t\tbool userfnc = false;\n\t\t\tSdb *trace = anal->esil->trace->db;\n\t\t\tcur_idx = sdb_num_get (trace, \"idx\", 0);\n\t\t\tRAnalVar *var = r_anal_get_used_function_var (anal, aop.addr);\n\t\t\tRAnalOp *next_op = r_core_anal_op (core, addr + ret, R_ANAL_OP_MASK_BASIC); // | _VAL ?\n\t\t\tut32 type = aop.type & R_ANAL_OP_TYPE_MASK;\n\t\t\tif (aop.type == R_ANAL_OP_TYPE_CALL || aop.type & R_ANAL_OP_TYPE_UCALL) {\n\t\t\t\tchar *full_name = NULL;\n\t\t\t\tut64 callee_addr;\n\t\t\t\tif (aop.type == R_ANAL_OP_TYPE_CALL) {\n\t\t\t\t\tRAnalFunction *fcn_call = r_anal_get_fcn_in (anal, aop.jump, -1);\n\t\t\t\t\tif (fcn_call) {\n\t\t\t\t\t\tfull_name = fcn_call->name;\n\t\t\t\t\t\tcallee_addr = fcn_call->addr;\n\t\t\t\t\t}\n\t\t\t\t} else if (aop.ptr != UT64_MAX) {\n\t\t\t\t\tRFlagItem *flag = r_flag_get_by_spaces (core->flags, aop.ptr, R_FLAGS_FS_IMPORTS, NULL);\n\t\t\t\t\tif (flag && flag->realname) {\n\t\t\t\t\t\tfull_name = flag->realname;\n\t\t\t\t\t\tcallee_addr = aop.ptr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (full_name) {\n\t\t\t\t\tif (r_type_func_exist (TDB, full_name)) {\n\t\t\t\t\t\tfcn_name = strdup (full_name);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfcn_name = r_type_func_guess (TDB, full_name);\n\t\t\t\t\t}\n\t\t\t\t\tif (!fcn_name) {\n\t\t\t\t\t\tfcn_name = strdup (full_name);\n\t\t\t\t\t\tuserfnc = true;\n\t\t\t\t\t}\n\t\t\t\t\tconst char* Cc = r_anal_cc_func (anal, fcn_name);\n\t\t\t\t\tif (Cc && r_anal_cc_exist (anal, Cc)) {\n\t\t\t\t\t\tchar *cc = strdup (Cc);\n\t\t\t\t\t\ttype_match (core, fcn_name, addr, bb->addr, cc, prev_idx, userfnc, callee_addr);\n\t\t\t\t\t\tprev_idx = cur_idx;\n\t\t\t\t\t\tR_FREE (ret_type);\n\t\t\t\t\t\tconst char *rt = r_type_func_ret (TDB, fcn_name);\n\t\t\t\t\t\tif (rt) {\n\t\t\t\t\t\t\tret_type = strdup (rt);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tR_FREE (ret_reg);\n\t\t\t\t\t\tconst char *rr = r_anal_cc_ret (anal, cc);\n\t\t\t\t\t\tif (rr) {\n\t\t\t\t\t\t\tret_reg = strdup (rr);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresolved = false;\n\t\t\t\t\t\tfree (cc);\n\t\t\t\t\t}\n\t\t\t\t\tif (!strcmp (fcn_name, \"__stack_chk_fail\")) {\n\t\t\t\t\t\tconst char *query = sdb_fmt (\"%d.addr\", cur_idx - 1);\n\t\t\t\t\t\tut64 mov_addr = sdb_num_get (trace, query, 0);\n\t\t\t\t\t\tRAnalOp *mop = r_core_anal_op (core, mov_addr, R_ANAL_OP_MASK_VAL | R_ANAL_OP_MASK_BASIC);\n\t\t\t\t\t\tif (mop) {\n\t\t\t\t\t\t\tRAnalVar *mopvar = r_anal_get_used_function_var (anal, mop->addr);\n\t\t\t\t\t\t\tut32 type = mop->type & R_ANAL_OP_TYPE_MASK;\n\t\t\t\t\t\t\tif (type == R_ANAL_OP_TYPE_MOV) {\n\t\t\t\t\t\t\t\t__var_rename (anal, mopvar, \"canary\", addr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_anal_op_free (mop);\n\t\t\t\t\t}\n\t\t\t\t\tfree (fcn_name);\n\t\t\t\t}\n\t\t\t} else if (!resolved && ret_type && ret_reg) {\n\t\t\t\t// Forward propgation of function return type\n\t\t\t\tchar src[REGNAME_SIZE] = {0};\n\t\t\t\tconst char *query = sdb_fmt (\"%d.reg.write\", cur_idx);\n\t\t\t\tconst char *cur_dest = sdb_const_get (trace, query, 0);\n\t\t\t\tget_src_regname (core, aop.addr, src, sizeof (src));\n\t\t\t\tif (ret_reg && *src && strstr (ret_reg, src)) {\n\t\t\t\t\tif (var && aop.direction == R_ANAL_OP_DIR_WRITE) {\n\t\t\t\t\t\t__var_retype (anal, var, NULL, ret_type, false, false);\n\t\t\t\t\t\tresolved = true;\n\t\t\t\t\t} else if (type == R_ANAL_OP_TYPE_MOV) {\n\t\t\t\t\t\tR_FREE (ret_reg);\n\t\t\t\t\t\tif (cur_dest) {\n\t\t\t\t\t\t\tret_reg = strdup (cur_dest);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (cur_dest) {\n\t\t\t\t\tchar *foo = strdup (cur_dest);\n\t\t\t\t\tchar *tmp = strchr (foo, ',');\n\t\t\t\t\tif (tmp) {\n\t\t\t\t\t\t*tmp++ = '\\0';\n\t\t\t\t\t}\n\t\t\t\t\tif (ret_reg && (strstr (ret_reg, foo) || (tmp && strstr (ret_reg, tmp)))) {\n\t\t\t\t\t\tresolved = true;\n\t\t\t\t\t} else if (type == R_ANAL_OP_TYPE_MOV &&\n\t\t\t\t\t\t\t(next_op && next_op->type == R_ANAL_OP_TYPE_MOV)){\n\t\t\t\t\t\t// Progate return type passed using pointer\n\t\t\t\t\t\t// int *ret; *ret = strlen(s);\n\t\t\t\t\t\t// TODO: memref check , dest and next src match\n\t\t\t\t\t\tchar nsrc[REGNAME_SIZE] = {0};\n\t\t\t\t\t\tget_src_regname (core, next_op->addr, nsrc, sizeof (nsrc));\n\t\t\t\t\t\tif (ret_reg && *nsrc && strstr (ret_reg, nsrc) && var &&\n\t\t\t\t\t\t\t\taop.direction == R_ANAL_OP_DIR_READ) {\n\t\t\t\t\t\t\t__var_retype (anal, var, NULL, ret_type, true, false);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree (foo);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Type propagation using instruction access pattern\n\t\t\tif (var) {\n\t\t\t\tbool sign = false;\n\t\t\t\tif ((type == R_ANAL_OP_TYPE_CMP) && next_op) {\n\t\t\t\t\tif (next_op->sign) {\n\t\t\t\t\t\tsign = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// cmp [local_ch], rax ; jb\n\t\t\t\t\t\t__var_retype (anal, var, NULL, \"unsigned\", false, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// cmp [local_ch], rax ; jge\n\t\t\t\tif (sign || aop.sign) {\n\t\t\t\t\t__var_retype (anal, var, NULL, \"signed\", false, true);\n\t\t\t\t}\n\t\t\t\t// lea rax , str.hello  ; mov [local_ch], rax;\n\t\t\t\t// mov rdx , [local_4h] ; mov [local_8h], rdx;\n\t\t\t\tif (prev_dest && (type == R_ANAL_OP_TYPE_MOV || type == R_ANAL_OP_TYPE_STORE)) {\n\t\t\t\t\tchar reg[REGNAME_SIZE] = {0};\n\t\t\t\t\tget_src_regname (core, addr, reg, sizeof (reg));\n\t\t\t\t\tbool match = strstr (prev_dest, reg) != NULL;\n\t\t\t\t\tif (str_flag && match) {\n\t\t\t\t\t\t__var_retype (anal, var, NULL, \"const char *\", false, false);\n\t\t\t\t\t}\n\t\t\t\t\tif (prop && match && prev_var) {\n\t\t\t\t\t\t__var_retype (anal, var, NULL, prev_type, false, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (chk_constraint && var && (type == R_ANAL_OP_TYPE_CMP && aop.disp != UT64_MAX)\n\t\t\t\t\t\t&& next_op && next_op->type == R_ANAL_OP_TYPE_CJMP) {\n\t\t\t\t\tbool jmp = false;\n\t\t\t\t\tRAnalOp *jmp_op = {0};\n\t\t\t\t\tut64 jmp_addr = next_op->jump;\n\t\t\t\t\tRAnalBlock *jmpbb = r_anal_fcn_bbget_in (anal, fcn, jmp_addr);\n\n\t\t\t\t\t// Check exit status of jmp branch\n\t\t\t\t\tfor (i = 0; i < MAX_INSTR ; i++) {\n\t\t\t\t\t\tjmp_op = r_core_anal_op (core, jmp_addr, R_ANAL_OP_MASK_BASIC);\n\t\t\t\t\t\tif (!jmp_op) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ((jmp_op->type == R_ANAL_OP_TYPE_RET && r_anal_block_contains (jmpbb, jmp_addr))\n\t\t\t\t\t\t\t\t|| jmp_op->type == R_ANAL_OP_TYPE_CJMP) {\n\t\t\t\t\t\t\tjmp = true;\n\t\t\t\t\t\t\tr_anal_op_free (jmp_op);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tjmp_addr += jmp_op->size;\n\t\t\t\t\t\tr_anal_op_free (jmp_op);\n\t\t\t\t\t}\n\t\t\t\t\tRAnalVarConstraint constr = {\n\t\t\t\t\t\t.cond = jmp? cond_invert (anal, next_op->cond): next_op->cond,\n\t\t\t\t\t\t.val = aop.val\n\t\t\t\t\t};\n\t\t\t\t\tr_anal_var_add_constraint (var, &constr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprev_var = (var && aop.direction == R_ANAL_OP_DIR_READ);\n\t\t\tstr_flag = false;\n\t\t\tprop = false;\n\t\t\tprev_dest = NULL;\n\t\t\tswitch (type) {\n\t\t\tcase R_ANAL_OP_TYPE_MOV:\n\t\t\tcase R_ANAL_OP_TYPE_LEA:\n\t\t\tcase R_ANAL_OP_TYPE_LOAD:\n\t\t\t\tif (aop.ptr && aop.refptr && aop.ptr != UT64_MAX) {\n\t\t\t\t\tif (type == R_ANAL_OP_TYPE_LOAD) {\n\t\t\t\t\t\tut8 buf[256] = {0};\n\t\t\t\t\t\tr_io_read_at (core->io, aop.ptr, buf, sizeof (buf) - 1);\n\t\t\t\t\t\tut64 ptr = r_read_ble (buf, core->print->big_endian, aop.refptr * 8);\n\t\t\t\t\t\tif (ptr && ptr != UT64_MAX) {\n\t\t\t\t\t\t\tRFlagItem *f = r_flag_get_by_spaces (core->flags, ptr, R_FLAGS_FS_STRINGS, NULL);\n\t\t\t\t\t\t\tif (f) {\n\t\t\t\t\t\t\t\tstr_flag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (r_flag_exist_at (core->flags, \"str\", 3, aop.ptr)) {\n\t\t\t\t\t\tstr_flag = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// mov dword [local_4h], str.hello;\n\t\t\t\tif (var && str_flag) {\n\t\t\t\t\t__var_retype (anal, var, NULL, \"const char *\", false, false);\n\t\t\t\t}\n\t\t\t\tconst char *query = sdb_fmt (\"%d.reg.write\", cur_idx);\n\t\t\t\tprev_dest = sdb_const_get (trace, query, 0);\n\t\t\t\tif (var) {\n\t\t\t\t\tstrncpy (prev_type, var->type, sizeof (prev_type) - 1);\n\t\t\t\t\tprop = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti += ret;\n\t\t\taddr += ret;\n\t\t\tr_anal_op_free (next_op);\n\t\t\tr_anal_op_fini (&aop);\n\n\t\t}\n\t}\n\t// Type propgation for register based args\n\tRList *list = r_anal_var_list (anal, fcn, R_ANAL_VAR_KIND_REG);\n\tRAnalVar *rvar;\n\tRListIter *iter;\n\tr_list_foreach (list, iter, rvar) {\n\t\tRAnalVar *lvar = r_anal_var_get_dst_var (rvar);\n\t\tRRegItem *i = r_reg_index_get (anal->reg, rvar->delta);\n\t\tif (!i) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (lvar) {\n\t\t\t// Propagate local var type = to => register-based var\n\t\t\t__var_retype (anal, rvar, NULL, lvar->type, false, false);\n\t\t\t// Propagate local var type <= from = register-based var\n\t\t\t__var_retype (anal, lvar, NULL, rvar->type, false, false);\n\t\t}\n\t}\n\tr_list_free (list);\nout_function:\n\tR_FREE (ret_reg);\n\tR_FREE (ret_type);\n\tfree (buf);\n\tr_cons_break_pop();\n\tanal_emul_restore (core, hc, dt, et);\n}",
  "abstract_func_before": "R_API void r_core_anal_type_match(RCore *VAR_0, RAnalFunction *VAR_1) {\n\tRAnalBlock *VAR_2;\n\tRListIter *VAR_3;\n\tRAnalOp VAR_4 = {0};\n\tbool VAR_5 = false;\n\n\tr_return_if_fail (VAR_0 && VAR_0->anal && VAR_1);\n\n\tif (!VAR_0->anal->esil) {\n\t\teprintf (\"Please run aeim\\n\");\n\t\treturn;\n\t}\n\n\tRAnal *VAR_6 = VAR_0->anal;\n\tSdb *VAR_7 = VAR_6->sdb_types;\n\tbool VAR_8 = r_config_get_i (VAR_0->config, \"anal.types.constraint\");\n\tint VAR_9, VAR_10 = R_MAX (64, VAR_0->blocksize);\n\tconst int VAR_11 = r_anal_archinfo (VAR_6, VAR_12);\n\tconst int VAR_13 = R_MAX (1, VAR_11);\n\tint VAR_14 , VAR_15 = 0;\n\tRConfigHold *VAR_16 = r_config_hold_new (VAR_0->config);\n\tif (!VAR_16) {\n\t\treturn;\n\t}\n\tRDebugTrace *VAR_17 = NULL;\n\tRAnalEsilTrace *VAR_18 = NULL;\n\tif (!anal_emul_init (VAR_0, VAR_16, &VAR_17, &VAR_18) || !VAR_1) {\n\t\tanal_emul_restore (VAR_0, VAR_16, VAR_17, VAR_18);\n\t\treturn;\n\t}\n\tut8 *VAR_19 = malloc (VAR_10);\n\tif (!VAR_19) {\n\t\tanal_emul_restore (VAR_0, VAR_16, VAR_17, VAR_18);\n\t\treturn;\n\t}\n\n\t/* COMMENT_0 */\n\tSdb *VAR_20 = VAR_0->anal->esil->trace->db;\n\tHtPPOptions VAR_21 = VAR_20->ht->opt;\n\tht_pp_free (VAR_20->ht);\n\tVAR_20->ht = ht_pp_new_size (VAR_1->ninstr * 0xf, VAR_21.dupvalue, VAR_21.freefn, VAR_21.calcsizeV);\n\tVAR_20->ht->opt = VAR_21;\n\tRDebugTrace *VAR_22 = VAR_0->dbg->trace;\n\tVAR_21 = VAR_22->ht->opt;\n\tht_pp_free (VAR_22->ht);\n\tVAR_22->ht = ht_pp_new_size (VAR_1->ninstr, VAR_21.dupvalue, VAR_21.freefn, VAR_21.calcsizeV);\n\tVAR_22->ht->opt = VAR_21;\n\n\tchar *VAR_23 = NULL;\n\tchar *VAR_24 = NULL;\n\tbool VAR_25 = false;\n\tbool VAR_26 = false;\n\tbool VAR_27 = false;\n\tchar VAR_28[256] = {0};\n\tconst char *VAR_29 = NULL;\n\tchar *VAR_30 = NULL;\n\tconst char *VAR_31 = r_reg_get_name (VAR_0->dbg->reg, VAR_32);\n\tif (!VAR_31) {\n        free (VAR_19);\n\t\treturn;\n\t}\n\tRRegItem *VAR_33 = r_reg_get (VAR_0->dbg->reg, VAR_31, -1);\n\tif (!VAR_33) {\n\t\tfree (VAR_19);\n\t\treturn;\n\t}\n\tr_cons_break_push (NULL, NULL);\n\tr_list_sort (VAR_1->bbs, VAR_34); /* COMMENT_1 */\n\tr_list_foreach (VAR_1->bbs, VAR_3, VAR_2) {\n\t\tut64 VAR_35 = VAR_2->addr;\n\t\tint VAR_36 = 0;\n\t\tr_reg_set_value (VAR_0->dbg->reg, VAR_33, VAR_35);\n\t\twhile (1) {\n\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\tgoto out_function;\n\t\t\t}\n\t\t\tif (VAR_36 >= (VAR_10 - 32)) {\n\t\t\t\tVAR_36 = 0;\n\t\t\t}\n\t\t\tut64 VAR_37 = r_reg_getv (VAR_6->reg, VAR_31);\n\t\t\tif ((VAR_35 >= VAR_2->addr + VAR_2->size) || (VAR_35 < VAR_2->addr) || VAR_37 != VAR_35) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!VAR_36) {\n\t\t\t\tr_io_read_at (VAR_0->io, VAR_35, VAR_19, VAR_10);\n\t\t\t}\n\t\t\tVAR_9 = r_anal_op (VAR_6, &VAR_4, VAR_35, VAR_19 + VAR_36, VAR_10 - VAR_36, VAR_38 | VAR_39);\n\t\t\tif (VAR_9 <= 0) {\n\t\t\t\tVAR_36 += VAR_13;\n\t\t\t\tVAR_35 += VAR_13;\n\t\t\t\tr_anal_op_fini (&VAR_4);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint VAR_40 = sdb_num_get (VAR_6->esil->trace->db, sdb_fmt (\"0x%\"VAR_41\".count\", VAR_35), 0);\n\t\t\tif (VAR_40 > VAR_42 || VAR_4.type == VAR_43) {\n\t\t\t\tr_anal_op_fini (&VAR_4);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsdb_num_set (VAR_6->esil->trace->db, sdb_fmt (\"0x%\"VAR_41\".count\", VAR_35), VAR_40 + 1, 0);\n\t\t\tif (r_anal_op_nonlinear (VAR_4.type)) {   /* COMMENT_2 */\n\t\t\t\tr_reg_set_value (VAR_0->dbg->reg, VAR_33, VAR_35 + VAR_9);\n\t\t\t} else {\n\t\t\t\tr_core_esil_step (VAR_0, VAR_44, NULL, NULL, false);\n\t\t\t}\n\t\t\tbool VAR_45 = false;\n\t\t\tSdb *VAR_46 = VAR_6->esil->trace->db;\n\t\t\tVAR_14 = sdb_num_get (VAR_46, \"idx\", 0);\n\t\t\tRAnalVar *VAR_47 = r_anal_get_used_function_var (VAR_6, VAR_4.addr);\n\t\t\tRAnalOp *VAR_48 = r_core_anal_op (VAR_0, VAR_35 + VAR_9, VAR_38); /* COMMENT_3 */\n\t\t\tut32 VAR_49 = VAR_4.type & VAR_50;\n\t\t\tif (VAR_4.type == VAR_51 || VAR_4.type & VAR_52) {\n\t\t\t\tchar *VAR_53 = NULL;\n\t\t\t\tut64 VAR_54;\n\t\t\t\tif (VAR_4.type == VAR_51) {\n\t\t\t\t\tRAnalFunction *VAR_55 = r_anal_get_fcn_in (VAR_6, VAR_4.jump, -1);\n\t\t\t\t\tif (VAR_55) {\n\t\t\t\t\t\tVAR_53 = VAR_55->name;\n\t\t\t\t\t\tVAR_54 = VAR_55->addr;\n\t\t\t\t\t}\n\t\t\t\t} else if (VAR_4.ptr != VAR_44) {\n\t\t\t\t\tRFlagItem *VAR_56 = r_flag_get_by_spaces (VAR_0->flags, VAR_4.ptr, VAR_57, NULL);\n\t\t\t\t\tif (VAR_56 && VAR_56->realname) {\n\t\t\t\t\t\tVAR_53 = VAR_56->realname;\n\t\t\t\t\t\tVAR_54 = VAR_4.ptr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (VAR_53) {\n\t\t\t\t\tif (r_type_func_exist (VAR_7, VAR_53)) {\n\t\t\t\t\t\tVAR_23 = strdup (VAR_53);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tVAR_23 = r_type_func_guess (VAR_7, VAR_53);\n\t\t\t\t\t}\n\t\t\t\t\tif (!VAR_23) {\n\t\t\t\t\t\tVAR_23 = strdup (VAR_53);\n\t\t\t\t\t\tVAR_45 = true;\n\t\t\t\t\t}\n\t\t\t\t\tconst char* VAR_58 = r_anal_cc_func (VAR_6, VAR_23);\n\t\t\t\t\tif (VAR_58 && r_anal_cc_exist (VAR_6, VAR_58)) {\n\t\t\t\t\t\tchar *VAR_59 = strdup (VAR_58);\n\t\t\t\t\t\ttype_match (VAR_0, VAR_23, VAR_35, VAR_2->addr, VAR_59, VAR_15, VAR_45, VAR_54);\n\t\t\t\t\t\tVAR_15 = VAR_14;\n\t\t\t\t\t\tR_FREE (VAR_24);\n\t\t\t\t\t\tconst char *VAR_60 = r_type_func_ret (VAR_7, VAR_23);\n\t\t\t\t\t\tif (VAR_60) {\n\t\t\t\t\t\t\tVAR_24 = strdup (VAR_60);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tR_FREE (VAR_30);\n\t\t\t\t\t\tconst char *VAR_61 = r_anal_cc_ret (VAR_6, VAR_59);\n\t\t\t\t\t\tif (VAR_61) {\n\t\t\t\t\t\t\tVAR_30 = strdup (VAR_61);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tVAR_5 = false;\n\t\t\t\t\t\tfree (VAR_59);\n\t\t\t\t\t}\n\t\t\t\t\tif (!strcmp (VAR_23, \"__stack_chk_fail\")) {\n\t\t\t\t\t\tconst char *VAR_62 = sdb_fmt (\"%d.addr\", VAR_14 - 1);\n\t\t\t\t\t\tut64 VAR_63 = sdb_num_get (VAR_46, VAR_62, 0);\n\t\t\t\t\t\tRAnalOp *VAR_64 = r_core_anal_op (VAR_0, VAR_63, VAR_39 | VAR_38);\n\t\t\t\t\t\tif (VAR_64) {\n\t\t\t\t\t\t\tRAnalVar *VAR_65 = r_anal_get_used_function_var (VAR_6, VAR_64->addr);\n\t\t\t\t\t\t\tut32 VAR_49 = VAR_64->type & VAR_50;\n\t\t\t\t\t\t\tif (VAR_49 == VAR_66) {\n\t\t\t\t\t\t\t\t__var_rename (VAR_6, VAR_65, \"canary\", VAR_35);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_anal_op_free (VAR_64);\n\t\t\t\t\t}\n\t\t\t\t\tfree (VAR_23);\n\t\t\t\t}\n\t\t\t} else if (!VAR_5 && VAR_24 && VAR_30) {\n\t\t\t\t/* COMMENT_4 */\n\t\t\t\tchar VAR_67[VAR_68] = {0};\n\t\t\t\tconst char *VAR_62 = sdb_fmt (\"%d.reg.write\", VAR_14);\n\t\t\t\tconst char *VAR_69 = sdb_const_get (VAR_46, VAR_62, 0);\n\t\t\t\tget_src_regname (VAR_0, VAR_4.addr, VAR_67, sizeof (VAR_67));\n\t\t\t\tif (VAR_30 && *VAR_67 && strstr (VAR_30, VAR_67)) {\n\t\t\t\t\tif (VAR_47 && VAR_4.direction == VAR_70) {\n\t\t\t\t\t\t__var_retype (VAR_6, VAR_47, NULL, VAR_24, false, false);\n\t\t\t\t\t\tVAR_5 = true;\n\t\t\t\t\t} else if (VAR_49 == VAR_66) {\n\t\t\t\t\t\tR_FREE (VAR_30);\n\t\t\t\t\t\tif (VAR_69) {\n\t\t\t\t\t\t\tVAR_30 = strdup (VAR_69);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (VAR_69) {\n\t\t\t\t\tchar *VAR_71 = strdup (VAR_69);\n\t\t\t\t\tchar *VAR_72 = strchr (VAR_71, ',');\n\t\t\t\t\tif (VAR_72) {\n\t\t\t\t\t\t*VAR_72++ = '\\0';\n\t\t\t\t\t}\n\t\t\t\t\tif (VAR_30 && (strstr (VAR_30, VAR_71) || (VAR_72 && strstr (VAR_30, VAR_72)))) {\n\t\t\t\t\t\tVAR_5 = true;\n\t\t\t\t\t} else if (VAR_49 == VAR_66 &&\n\t\t\t\t\t\t\t(VAR_48 && VAR_48->type == VAR_66)){\n\t\t\t\t\t\t/* COMMENT_5 */\n\t\t\t\t\t\t/* COMMENT_6 */\n\t\t\t\t\t\t/* COMMENT_7 */\n\t\t\t\t\t\tchar VAR_73[VAR_68] = {0};\n\t\t\t\t\t\tget_src_regname (VAR_0, VAR_48->addr, VAR_73, sizeof (VAR_73));\n\t\t\t\t\t\tif (VAR_30 && *VAR_73 && strstr (VAR_30, VAR_73) && VAR_47 &&\n\t\t\t\t\t\t\t\tVAR_4.direction == VAR_74) {\n\t\t\t\t\t\t\t__var_retype (VAR_6, VAR_47, NULL, VAR_24, true, false);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree (VAR_71);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* COMMENT_8 */\n\t\t\tif (VAR_47) {\n\t\t\t\tbool VAR_75 = false;\n\t\t\t\tif ((VAR_49 == VAR_76) && VAR_48) {\n\t\t\t\t\tif (VAR_48->sign) {\n\t\t\t\t\t\tVAR_75 = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* COMMENT_9 */\n\t\t\t\t\t\t__var_retype (VAR_6, VAR_47, NULL, \"unsigned\", false, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* COMMENT_10 */\n\t\t\t\tif (VAR_75 || VAR_4.sign) {\n\t\t\t\t\t__var_retype (VAR_6, VAR_47, NULL, \"signed\", false, true);\n\t\t\t\t}\n\t\t\t\t/* COMMENT_11 */\n\t\t\t\t/* COMMENT_12 */\n\t\t\t\tif (VAR_29 && (VAR_49 == VAR_66 || VAR_49 == VAR_77)) {\n\t\t\t\t\tchar VAR_78[VAR_68] = {0};\n\t\t\t\t\tget_src_regname (VAR_0, VAR_35, VAR_78, sizeof (VAR_78));\n\t\t\t\t\tbool VAR_79 = strstr (VAR_29, VAR_78) != NULL;\n\t\t\t\t\tif (VAR_25 && VAR_79) {\n\t\t\t\t\t\t__var_retype (VAR_6, VAR_47, NULL, \"const char *\", false, false);\n\t\t\t\t\t}\n\t\t\t\t\tif (VAR_26 && VAR_79 && VAR_27) {\n\t\t\t\t\t\t__var_retype (VAR_6, VAR_47, NULL, VAR_28, false, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (VAR_8 && VAR_47 && (VAR_49 == VAR_76 && VAR_4.disp != VAR_44)\n\t\t\t\t\t\t&& VAR_48 && VAR_48->type == VAR_80) {\n\t\t\t\t\tbool VAR_81 = false;\n\t\t\t\t\tRAnalOp *VAR_82 = {0};\n\t\t\t\t\tut64 VAR_83 = VAR_48->jump;\n\t\t\t\t\tRAnalBlock *VAR_84 = r_anal_fcn_bbget_in (VAR_6, VAR_1, VAR_83);\n\n\t\t\t\t\t/* COMMENT_13 */\n\t\t\t\t\tfor (VAR_36 = 0; VAR_36 < VAR_85 ; VAR_36++) {\n\t\t\t\t\t\tVAR_82 = r_core_anal_op (VAR_0, VAR_83, VAR_38);\n\t\t\t\t\t\tif (!VAR_82) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ((VAR_82->type == VAR_43 && r_anal_block_contains (VAR_84, VAR_83))\n\t\t\t\t\t\t\t\t|| VAR_82->type == VAR_80) {\n\t\t\t\t\t\t\tVAR_81 = true;\n\t\t\t\t\t\t\tr_anal_op_free (VAR_82);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tVAR_83 += VAR_82->size;\n\t\t\t\t\t\tr_anal_op_free (VAR_82);\n\t\t\t\t\t}\n\t\t\t\t\tRAnalVarConstraint VAR_86 = {\n\t\t\t\t\t\t.cond = VAR_81? cond_invert (VAR_6, VAR_48->cond): VAR_48->cond,\n\t\t\t\t\t\t.val = VAR_4.val\n\t\t\t\t\t};\n\t\t\t\t\tr_anal_var_add_constraint (VAR_47, &VAR_86);\n\t\t\t\t}\n\t\t\t}\n\t\t\tVAR_27 = (VAR_47 && VAR_4.direction == VAR_74);\n\t\t\tVAR_25 = false;\n\t\t\tVAR_26 = false;\n\t\t\tVAR_29 = NULL;\n\t\t\tswitch (VAR_49) {\n\t\t\tcase VAR_66:\n\t\t\tcase VAR_87:\n\t\t\tcase VAR_88:\n\t\t\t\tif (VAR_4.ptr && VAR_4.refptr && VAR_4.ptr != VAR_44) {\n\t\t\t\t\tif (VAR_49 == VAR_88) {\n\t\t\t\t\t\tut8 VAR_19[256] = {0};\n\t\t\t\t\t\tr_io_read_at (VAR_0->io, VAR_4.ptr, VAR_19, sizeof (VAR_19) - 1);\n\t\t\t\t\t\tut64 VAR_89 = r_read_ble (VAR_19, VAR_0->print->big_endian, VAR_4.refptr * 8);\n\t\t\t\t\t\tif (VAR_89 && VAR_89 != VAR_44) {\n\t\t\t\t\t\t\tRFlagItem *VAR_90 = r_flag_get_by_spaces (VAR_0->flags, VAR_89, VAR_91, NULL);\n\t\t\t\t\t\t\tif (VAR_90) {\n\t\t\t\t\t\t\t\tVAR_25 = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (r_flag_exist_at (VAR_0->flags, \"str\", 3, VAR_4.ptr)) {\n\t\t\t\t\t\tVAR_25 = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* COMMENT_14 */\n\t\t\t\tif (VAR_47 && VAR_25) {\n\t\t\t\t\t__var_retype (VAR_6, VAR_47, NULL, \"const char *\", false, false);\n\t\t\t\t}\n\t\t\t\tconst char *VAR_62 = sdb_fmt (\"%d.reg.write\", VAR_14);\n\t\t\t\tVAR_29 = sdb_const_get (VAR_46, VAR_62, 0);\n\t\t\t\tif (VAR_47) {\n\t\t\t\t\tstrncpy (VAR_28, VAR_47->type, sizeof (VAR_28) - 1);\n\t\t\t\t\tVAR_26 = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tVAR_36 += VAR_9;\n\t\t\tVAR_35 += VAR_9;\n\t\t\tr_anal_op_free (VAR_48);\n\t\t\tr_anal_op_fini (&VAR_4);\n\n\t\t}\n\t}\n\t/* COMMENT_15 */\n\tRList *VAR_92 = r_anal_var_list (VAR_6, VAR_1, VAR_93);\n\tRAnalVar *VAR_94;\n\tRListIter *VAR_95;\n\tr_list_foreach (VAR_92, VAR_95, VAR_94) {\n\t\tRAnalVar *VAR_96 = r_anal_var_get_dst_var (VAR_94);\n\t\tRRegItem *VAR_36 = r_reg_index_get (VAR_6->reg, VAR_94->delta);\n\t\tif (!VAR_36) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (VAR_96) {\n\t\t\t/* COMMENT_16 */\n\t\t\t__var_retype (VAR_6, VAR_94, NULL, VAR_96->type, false, false);\n\t\t\t/* COMMENT_17 */\n\t\t\t__var_retype (VAR_6, VAR_96, NULL, VAR_94->type, false, false);\n\t\t}\n\t}\n\tr_list_free (VAR_92);\nout_function:\n\tR_FREE (VAR_30);\n\tR_FREE (VAR_24);\n\tfree (VAR_19);\n\tr_cons_break_pop();\n\tanal_emul_restore (VAR_0, VAR_16, VAR_17, VAR_18);\n}",
  "func_graph_path_before": null,
  "func": "R_API void r_core_anal_type_match(RCore *core, RAnalFunction *fcn) {\n\tRAnalBlock *bb;\n\tRListIter *it;\n\tRAnalOp aop = {0};\n\tbool resolved = false;\n\n\tr_return_if_fail (core && core->anal && fcn);\n\n\tif (!core->anal->esil) {\n\t\teprintf (\"Please run aeim\\n\");\n\t\treturn;\n\t}\n\n\tRAnal *anal = core->anal;\n\tSdb *TDB = anal->sdb_types;\n\tbool chk_constraint = r_config_get_i (core->config, \"anal.types.constraint\");\n\tint ret, bsize = R_MAX (64, core->blocksize);\n\tconst int mininstrsz = r_anal_archinfo (anal, R_ANAL_ARCHINFO_MIN_OP_SIZE);\n\tconst int minopcode = R_MAX (1, mininstrsz);\n\tint cur_idx , prev_idx = 0;\n\tRConfigHold *hc = r_config_hold_new (core->config);\n\tif (!hc) {\n\t\treturn;\n\t}\n\tRDebugTrace *dt = NULL;\n\tRAnalEsilTrace *et = NULL;\n\tif (!anal_emul_init (core, hc, &dt, &et) || !fcn) {\n\t\tanal_emul_restore (core, hc, dt, et);\n\t\treturn;\n\t}\n\tut8 *buf = malloc (bsize);\n\tif (!buf) {\n\t\tanal_emul_restore (core, hc, dt, et);\n\t\treturn;\n\t}\n\n\t// Reserve bigger ht to avoid rehashing\n\tSdb *etracedb = core->anal->esil->trace->db;\n\tHtPPOptions opt = etracedb->ht->opt;\n\tht_pp_free (etracedb->ht);\n\tetracedb->ht = ht_pp_new_size (fcn->ninstr * 0xf, opt.dupvalue, opt.freefn, opt.calcsizeV);\n\tetracedb->ht->opt = opt;\n\tRDebugTrace *dtrace = core->dbg->trace;\n\topt = dtrace->ht->opt;\n\tht_pp_free (dtrace->ht);\n\tdtrace->ht = ht_pp_new_size (fcn->ninstr, opt.dupvalue, opt.freefn, opt.calcsizeV);\n\tdtrace->ht->opt = opt;\n\n\tchar *fcn_name = NULL;\n\tchar *ret_type = NULL;\n\tbool str_flag = false;\n\tbool prop = false;\n\tbool prev_var = false;\n\tchar prev_type[256] = {0};\n\tconst char *prev_dest = NULL;\n\tchar *ret_reg = NULL;\n\tconst char *_pc = r_reg_get_name (core->dbg->reg, R_REG_NAME_PC);\n\tif (!_pc) {\n\t\tfree (buf);\n\t\treturn;\n\t}\n\tchar *pc = strdup (_pc);\n\tRRegItem *r = r_reg_get (core->dbg->reg, pc, -1);\n\tif (!r) {\n\t\tfree (buf);\n\t\treturn;\n\t}\n\tr_cons_break_push (NULL, NULL);\n\tr_list_sort (fcn->bbs, bb_cmpaddr); // TODO: The algorithm can be more accurate if blocks are followed by their jmp/fail, not just by address\n\tr_list_foreach (fcn->bbs, it, bb) {\n\t\tut64 addr = bb->addr;\n\t\tint i = 0;\n\t\tr_reg_set_value (core->dbg->reg, r, addr);\n\t\twhile (1) {\n\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\tgoto out_function;\n\t\t\t}\n\t\t\tif (i >= (bsize - 32)) {\n\t\t\t\ti = 0;\n\t\t\t}\n\t\t\tut64 pcval = r_reg_getv (anal->reg, pc);\n\t\t\tif ((addr >= bb->addr + bb->size) || (addr < bb->addr) || pcval != addr) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!i) {\n\t\t\t\tr_io_read_at (core->io, addr, buf, bsize);\n\t\t\t}\n\t\t\tret = r_anal_op (anal, &aop, addr, buf + i, bsize - i, R_ANAL_OP_MASK_BASIC | R_ANAL_OP_MASK_VAL);\n\t\t\tif (ret <= 0) {\n\t\t\t\ti += minopcode;\n\t\t\t\taddr += minopcode;\n\t\t\t\tr_anal_op_fini (&aop);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint loop_count = sdb_num_get (anal->esil->trace->db, sdb_fmt (\"0x%\"PFMT64x\".count\", addr), 0);\n\t\t\tif (loop_count > LOOP_MAX || aop.type == R_ANAL_OP_TYPE_RET) {\n\t\t\t\tr_anal_op_fini (&aop);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsdb_num_set (anal->esil->trace->db, sdb_fmt (\"0x%\"PFMT64x\".count\", addr), loop_count + 1, 0);\n\t\t\tif (r_anal_op_nonlinear (aop.type)) {   // skip the instr\n\t\t\t\tr_reg_set_value (core->dbg->reg, r, addr + ret);\n\t\t\t} else {\n\t\t\t\tr_core_esil_step (core, UT64_MAX, NULL, NULL, false);\n\t\t\t}\n\t\t\tbool userfnc = false;\n\t\t\tSdb *trace = anal->esil->trace->db;\n\t\t\tcur_idx = sdb_num_get (trace, \"idx\", 0);\n\t\t\tRAnalVar *var = r_anal_get_used_function_var (anal, aop.addr);\n\t\t\tRAnalOp *next_op = r_core_anal_op (core, addr + ret, R_ANAL_OP_MASK_BASIC); // | _VAL ?\n\t\t\tut32 type = aop.type & R_ANAL_OP_TYPE_MASK;\n\t\t\tif (aop.type == R_ANAL_OP_TYPE_CALL || aop.type & R_ANAL_OP_TYPE_UCALL) {\n\t\t\t\tchar *full_name = NULL;\n\t\t\t\tut64 callee_addr;\n\t\t\t\tif (aop.type == R_ANAL_OP_TYPE_CALL) {\n\t\t\t\t\tRAnalFunction *fcn_call = r_anal_get_fcn_in (anal, aop.jump, -1);\n\t\t\t\t\tif (fcn_call) {\n\t\t\t\t\t\tfull_name = fcn_call->name;\n\t\t\t\t\t\tcallee_addr = fcn_call->addr;\n\t\t\t\t\t}\n\t\t\t\t} else if (aop.ptr != UT64_MAX) {\n\t\t\t\t\tRFlagItem *flag = r_flag_get_by_spaces (core->flags, aop.ptr, R_FLAGS_FS_IMPORTS, NULL);\n\t\t\t\t\tif (flag && flag->realname) {\n\t\t\t\t\t\tfull_name = flag->realname;\n\t\t\t\t\t\tcallee_addr = aop.ptr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (full_name) {\n\t\t\t\t\tif (r_type_func_exist (TDB, full_name)) {\n\t\t\t\t\t\tfcn_name = strdup (full_name);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfcn_name = r_type_func_guess (TDB, full_name);\n\t\t\t\t\t}\n\t\t\t\t\tif (!fcn_name) {\n\t\t\t\t\t\tfcn_name = strdup (full_name);\n\t\t\t\t\t\tuserfnc = true;\n\t\t\t\t\t}\n\t\t\t\t\tconst char* Cc = r_anal_cc_func (anal, fcn_name);\n\t\t\t\t\tif (Cc && r_anal_cc_exist (anal, Cc)) {\n\t\t\t\t\t\tchar *cc = strdup (Cc);\n\t\t\t\t\t\ttype_match (core, fcn_name, addr, bb->addr, cc, prev_idx, userfnc, callee_addr);\n\t\t\t\t\t\tprev_idx = cur_idx;\n\t\t\t\t\t\tR_FREE (ret_type);\n\t\t\t\t\t\tconst char *rt = r_type_func_ret (TDB, fcn_name);\n\t\t\t\t\t\tif (rt) {\n\t\t\t\t\t\t\tret_type = strdup (rt);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tR_FREE (ret_reg);\n\t\t\t\t\t\tconst char *rr = r_anal_cc_ret (anal, cc);\n\t\t\t\t\t\tif (rr) {\n\t\t\t\t\t\t\tret_reg = strdup (rr);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresolved = false;\n\t\t\t\t\t\tfree (cc);\n\t\t\t\t\t}\n\t\t\t\t\tif (!strcmp (fcn_name, \"__stack_chk_fail\")) {\n\t\t\t\t\t\tconst char *query = sdb_fmt (\"%d.addr\", cur_idx - 1);\n\t\t\t\t\t\tut64 mov_addr = sdb_num_get (trace, query, 0);\n\t\t\t\t\t\tRAnalOp *mop = r_core_anal_op (core, mov_addr, R_ANAL_OP_MASK_VAL | R_ANAL_OP_MASK_BASIC);\n\t\t\t\t\t\tif (mop) {\n\t\t\t\t\t\t\tRAnalVar *mopvar = r_anal_get_used_function_var (anal, mop->addr);\n\t\t\t\t\t\t\tut32 type = mop->type & R_ANAL_OP_TYPE_MASK;\n\t\t\t\t\t\t\tif (type == R_ANAL_OP_TYPE_MOV) {\n\t\t\t\t\t\t\t\t__var_rename (anal, mopvar, \"canary\", addr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_anal_op_free (mop);\n\t\t\t\t\t}\n\t\t\t\t\tfree (fcn_name);\n\t\t\t\t}\n\t\t\t} else if (!resolved && ret_type && ret_reg) {\n\t\t\t\t// Forward propgation of function return type\n\t\t\t\tchar src[REGNAME_SIZE] = {0};\n\t\t\t\tconst char *query = sdb_fmt (\"%d.reg.write\", cur_idx);\n\t\t\t\tconst char *cur_dest = sdb_const_get (trace, query, 0);\n\t\t\t\tget_src_regname (core, aop.addr, src, sizeof (src));\n\t\t\t\tif (ret_reg && *src && strstr (ret_reg, src)) {\n\t\t\t\t\tif (var && aop.direction == R_ANAL_OP_DIR_WRITE) {\n\t\t\t\t\t\t__var_retype (anal, var, NULL, ret_type, false, false);\n\t\t\t\t\t\tresolved = true;\n\t\t\t\t\t} else if (type == R_ANAL_OP_TYPE_MOV) {\n\t\t\t\t\t\tR_FREE (ret_reg);\n\t\t\t\t\t\tif (cur_dest) {\n\t\t\t\t\t\t\tret_reg = strdup (cur_dest);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (cur_dest) {\n\t\t\t\t\tchar *foo = strdup (cur_dest);\n\t\t\t\t\tchar *tmp = strchr (foo, ',');\n\t\t\t\t\tif (tmp) {\n\t\t\t\t\t\t*tmp++ = '\\0';\n\t\t\t\t\t}\n\t\t\t\t\tif (ret_reg && (strstr (ret_reg, foo) || (tmp && strstr (ret_reg, tmp)))) {\n\t\t\t\t\t\tresolved = true;\n\t\t\t\t\t} else if (type == R_ANAL_OP_TYPE_MOV &&\n\t\t\t\t\t\t\t(next_op && next_op->type == R_ANAL_OP_TYPE_MOV)){\n\t\t\t\t\t\t// Progate return type passed using pointer\n\t\t\t\t\t\t// int *ret; *ret = strlen(s);\n\t\t\t\t\t\t// TODO: memref check , dest and next src match\n\t\t\t\t\t\tchar nsrc[REGNAME_SIZE] = {0};\n\t\t\t\t\t\tget_src_regname (core, next_op->addr, nsrc, sizeof (nsrc));\n\t\t\t\t\t\tif (ret_reg && *nsrc && strstr (ret_reg, nsrc) && var &&\n\t\t\t\t\t\t\t\taop.direction == R_ANAL_OP_DIR_READ) {\n\t\t\t\t\t\t\t__var_retype (anal, var, NULL, ret_type, true, false);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree (foo);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Type propagation using instruction access pattern\n\t\t\tif (var) {\n\t\t\t\tbool sign = false;\n\t\t\t\tif ((type == R_ANAL_OP_TYPE_CMP) && next_op) {\n\t\t\t\t\tif (next_op->sign) {\n\t\t\t\t\t\tsign = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// cmp [local_ch], rax ; jb\n\t\t\t\t\t\t__var_retype (anal, var, NULL, \"unsigned\", false, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// cmp [local_ch], rax ; jge\n\t\t\t\tif (sign || aop.sign) {\n\t\t\t\t\t__var_retype (anal, var, NULL, \"signed\", false, true);\n\t\t\t\t}\n\t\t\t\t// lea rax , str.hello  ; mov [local_ch], rax;\n\t\t\t\t// mov rdx , [local_4h] ; mov [local_8h], rdx;\n\t\t\t\tif (prev_dest && (type == R_ANAL_OP_TYPE_MOV || type == R_ANAL_OP_TYPE_STORE)) {\n\t\t\t\t\tchar reg[REGNAME_SIZE] = {0};\n\t\t\t\t\tget_src_regname (core, addr, reg, sizeof (reg));\n\t\t\t\t\tbool match = strstr (prev_dest, reg) != NULL;\n\t\t\t\t\tif (str_flag && match) {\n\t\t\t\t\t\t__var_retype (anal, var, NULL, \"const char *\", false, false);\n\t\t\t\t\t}\n\t\t\t\t\tif (prop && match && prev_var) {\n\t\t\t\t\t\t__var_retype (anal, var, NULL, prev_type, false, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (chk_constraint && var && (type == R_ANAL_OP_TYPE_CMP && aop.disp != UT64_MAX)\n\t\t\t\t\t\t&& next_op && next_op->type == R_ANAL_OP_TYPE_CJMP) {\n\t\t\t\t\tbool jmp = false;\n\t\t\t\t\tRAnalOp *jmp_op = {0};\n\t\t\t\t\tut64 jmp_addr = next_op->jump;\n\t\t\t\t\tRAnalBlock *jmpbb = r_anal_fcn_bbget_in (anal, fcn, jmp_addr);\n\n\t\t\t\t\t// Check exit status of jmp branch\n\t\t\t\t\tfor (i = 0; i < MAX_INSTR ; i++) {\n\t\t\t\t\t\tjmp_op = r_core_anal_op (core, jmp_addr, R_ANAL_OP_MASK_BASIC);\n\t\t\t\t\t\tif (!jmp_op) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ((jmp_op->type == R_ANAL_OP_TYPE_RET && r_anal_block_contains (jmpbb, jmp_addr))\n\t\t\t\t\t\t\t\t|| jmp_op->type == R_ANAL_OP_TYPE_CJMP) {\n\t\t\t\t\t\t\tjmp = true;\n\t\t\t\t\t\t\tr_anal_op_free (jmp_op);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tjmp_addr += jmp_op->size;\n\t\t\t\t\t\tr_anal_op_free (jmp_op);\n\t\t\t\t\t}\n\t\t\t\t\tRAnalVarConstraint constr = {\n\t\t\t\t\t\t.cond = jmp? cond_invert (anal, next_op->cond): next_op->cond,\n\t\t\t\t\t\t.val = aop.val\n\t\t\t\t\t};\n\t\t\t\t\tr_anal_var_add_constraint (var, &constr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprev_var = (var && aop.direction == R_ANAL_OP_DIR_READ);\n\t\t\tstr_flag = false;\n\t\t\tprop = false;\n\t\t\tprev_dest = NULL;\n\t\t\tswitch (type) {\n\t\t\tcase R_ANAL_OP_TYPE_MOV:\n\t\t\tcase R_ANAL_OP_TYPE_LEA:\n\t\t\tcase R_ANAL_OP_TYPE_LOAD:\n\t\t\t\tif (aop.ptr && aop.refptr && aop.ptr != UT64_MAX) {\n\t\t\t\t\tif (type == R_ANAL_OP_TYPE_LOAD) {\n\t\t\t\t\t\tut8 buf[256] = {0};\n\t\t\t\t\t\tr_io_read_at (core->io, aop.ptr, buf, sizeof (buf) - 1);\n\t\t\t\t\t\tut64 ptr = r_read_ble (buf, core->print->big_endian, aop.refptr * 8);\n\t\t\t\t\t\tif (ptr && ptr != UT64_MAX) {\n\t\t\t\t\t\t\tRFlagItem *f = r_flag_get_by_spaces (core->flags, ptr, R_FLAGS_FS_STRINGS, NULL);\n\t\t\t\t\t\t\tif (f) {\n\t\t\t\t\t\t\t\tstr_flag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (r_flag_exist_at (core->flags, \"str\", 3, aop.ptr)) {\n\t\t\t\t\t\tstr_flag = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// mov dword [local_4h], str.hello;\n\t\t\t\tif (var && str_flag) {\n\t\t\t\t\t__var_retype (anal, var, NULL, \"const char *\", false, false);\n\t\t\t\t}\n\t\t\t\tconst char *query = sdb_fmt (\"%d.reg.write\", cur_idx);\n\t\t\t\tprev_dest = sdb_const_get (trace, query, 0);\n\t\t\t\tif (var) {\n\t\t\t\t\tstrncpy (prev_type, var->type, sizeof (prev_type) - 1);\n\t\t\t\t\tprop = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti += ret;\n\t\t\taddr += ret;\n\t\t\tr_anal_op_free (next_op);\n\t\t\tr_anal_op_fini (&aop);\n\n\t\t}\n\t}\n\t// Type propgation for register based args\n\tRList *list = r_anal_var_list (anal, fcn, R_ANAL_VAR_KIND_REG);\n\tRAnalVar *rvar;\n\tRListIter *iter;\n\tr_list_foreach (list, iter, rvar) {\n\t\tRAnalVar *lvar = r_anal_var_get_dst_var (rvar);\n\t\tRRegItem *i = r_reg_index_get (anal->reg, rvar->delta);\n\t\tif (!i) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (lvar) {\n\t\t\t// Propagate local var type = to => register-based var\n\t\t\t__var_retype (anal, rvar, NULL, lvar->type, false, false);\n\t\t\t// Propagate local var type <= from = register-based var\n\t\t\t__var_retype (anal, lvar, NULL, rvar->type, false, false);\n\t\t}\n\t}\n\tr_list_free (list);\nout_function:\n\tR_FREE (ret_reg);\n\tR_FREE (ret_type);\n\tfree (buf);\n\tr_cons_break_pop();\n\tanal_emul_restore (core, hc, dt, et);\n\tfree (pc);\n}",
  "abstract_func": "R_API void r_core_anal_type_match(RCore *VAR_0, RAnalFunction *VAR_1) {\n\tRAnalBlock *VAR_2;\n\tRListIter *VAR_3;\n\tRAnalOp VAR_4 = {0};\n\tbool VAR_5 = false;\n\n\tr_return_if_fail (VAR_0 && VAR_0->anal && VAR_1);\n\n\tif (!VAR_0->anal->esil) {\n\t\teprintf (\"Please run aeim\\n\");\n\t\treturn;\n\t}\n\n\tRAnal *VAR_6 = VAR_0->anal;\n\tSdb *VAR_7 = VAR_6->sdb_types;\n\tbool VAR_8 = r_config_get_i (VAR_0->config, \"anal.types.constraint\");\n\tint VAR_9, VAR_10 = R_MAX (64, VAR_0->blocksize);\n\tconst int VAR_11 = r_anal_archinfo (VAR_6, VAR_12);\n\tconst int VAR_13 = R_MAX (1, VAR_11);\n\tint VAR_14 , VAR_15 = 0;\n\tRConfigHold *VAR_16 = r_config_hold_new (VAR_0->config);\n\tif (!VAR_16) {\n\t\treturn;\n\t}\n\tRDebugTrace *VAR_17 = NULL;\n\tRAnalEsilTrace *VAR_18 = NULL;\n\tif (!anal_emul_init (VAR_0, VAR_16, &VAR_17, &VAR_18) || !VAR_1) {\n\t\tanal_emul_restore (VAR_0, VAR_16, VAR_17, VAR_18);\n\t\treturn;\n\t}\n\tut8 *VAR_19 = malloc (VAR_10);\n\tif (!VAR_19) {\n\t\tanal_emul_restore (VAR_0, VAR_16, VAR_17, VAR_18);\n\t\treturn;\n\t}\n\n\t/* COMMENT_0 */\n\tSdb *VAR_20 = VAR_0->anal->esil->trace->db;\n\tHtPPOptions VAR_21 = VAR_20->ht->opt;\n\tht_pp_free (VAR_20->ht);\n\tVAR_20->ht = ht_pp_new_size (VAR_1->ninstr * 0xf, VAR_21.dupvalue, VAR_21.freefn, VAR_21.calcsizeV);\n\tVAR_20->ht->opt = VAR_21;\n\tRDebugTrace *VAR_22 = VAR_0->dbg->trace;\n\tVAR_21 = VAR_22->ht->opt;\n\tht_pp_free (VAR_22->ht);\n\tVAR_22->ht = ht_pp_new_size (VAR_1->ninstr, VAR_21.dupvalue, VAR_21.freefn, VAR_21.calcsizeV);\n\tVAR_22->ht->opt = VAR_21;\n\n\tchar *VAR_23 = NULL;\n\tchar *VAR_24 = NULL;\n\tbool VAR_25 = false;\n\tbool VAR_26 = false;\n\tbool VAR_27 = false;\n\tchar VAR_28[256] = {0};\n\tconst char *VAR_29 = NULL;\n\tchar *VAR_30 = NULL;\n\tconst char *VAR_31 = r_reg_get_name (VAR_0->dbg->reg, VAR_32);\n\tif (!VAR_31) {\n\t\tfree (VAR_19);\n\t\treturn;\n\t}\n\tchar *VAR_33 = strdup (VAR_31);\n\tRRegItem *VAR_34 = r_reg_get (VAR_0->dbg->reg, VAR_33, -1);\n\tif (!VAR_34) {\n\t\tfree (VAR_19);\n\t\treturn;\n\t}\n\tr_cons_break_push (NULL, NULL);\n\tr_list_sort (VAR_1->bbs, VAR_35); /* COMMENT_1 */\n\tr_list_foreach (VAR_1->bbs, VAR_3, VAR_2) {\n\t\tut64 VAR_36 = VAR_2->addr;\n\t\tint VAR_37 = 0;\n\t\tr_reg_set_value (VAR_0->dbg->reg, VAR_34, VAR_36);\n\t\twhile (1) {\n\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\tgoto out_function;\n\t\t\t}\n\t\t\tif (VAR_37 >= (VAR_10 - 32)) {\n\t\t\t\tVAR_37 = 0;\n\t\t\t}\n\t\t\tut64 VAR_38 = r_reg_getv (VAR_6->reg, VAR_33);\n\t\t\tif ((VAR_36 >= VAR_2->addr + VAR_2->size) || (VAR_36 < VAR_2->addr) || VAR_38 != VAR_36) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!VAR_37) {\n\t\t\t\tr_io_read_at (VAR_0->io, VAR_36, VAR_19, VAR_10);\n\t\t\t}\n\t\t\tVAR_9 = r_anal_op (VAR_6, &VAR_4, VAR_36, VAR_19 + VAR_37, VAR_10 - VAR_37, VAR_39 | VAR_40);\n\t\t\tif (VAR_9 <= 0) {\n\t\t\t\tVAR_37 += VAR_13;\n\t\t\t\tVAR_36 += VAR_13;\n\t\t\t\tr_anal_op_fini (&VAR_4);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint VAR_41 = sdb_num_get (VAR_6->esil->trace->db, sdb_fmt (\"0x%\"VAR_42\".count\", VAR_36), 0);\n\t\t\tif (VAR_41 > VAR_43 || VAR_4.type == VAR_44) {\n\t\t\t\tr_anal_op_fini (&VAR_4);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsdb_num_set (VAR_6->esil->trace->db, sdb_fmt (\"0x%\"VAR_42\".count\", VAR_36), VAR_41 + 1, 0);\n\t\t\tif (r_anal_op_nonlinear (VAR_4.type)) {   /* COMMENT_2 */\n\t\t\t\tr_reg_set_value (VAR_0->dbg->reg, VAR_34, VAR_36 + VAR_9);\n\t\t\t} else {\n\t\t\t\tr_core_esil_step (VAR_0, VAR_45, NULL, NULL, false);\n\t\t\t}\n\t\t\tbool VAR_46 = false;\n\t\t\tSdb *VAR_47 = VAR_6->esil->trace->db;\n\t\t\tVAR_14 = sdb_num_get (VAR_47, \"idx\", 0);\n\t\t\tRAnalVar *VAR_48 = r_anal_get_used_function_var (VAR_6, VAR_4.addr);\n\t\t\tRAnalOp *VAR_49 = r_core_anal_op (VAR_0, VAR_36 + VAR_9, VAR_39); /* COMMENT_3 */\n\t\t\tut32 VAR_50 = VAR_4.type & VAR_51;\n\t\t\tif (VAR_4.type == VAR_52 || VAR_4.type & VAR_53) {\n\t\t\t\tchar *VAR_54 = NULL;\n\t\t\t\tut64 VAR_55;\n\t\t\t\tif (VAR_4.type == VAR_52) {\n\t\t\t\t\tRAnalFunction *VAR_56 = r_anal_get_fcn_in (VAR_6, VAR_4.jump, -1);\n\t\t\t\t\tif (VAR_56) {\n\t\t\t\t\t\tVAR_54 = VAR_56->name;\n\t\t\t\t\t\tVAR_55 = VAR_56->addr;\n\t\t\t\t\t}\n\t\t\t\t} else if (VAR_4.ptr != VAR_45) {\n\t\t\t\t\tRFlagItem *VAR_57 = r_flag_get_by_spaces (VAR_0->flags, VAR_4.ptr, VAR_58, NULL);\n\t\t\t\t\tif (VAR_57 && VAR_57->realname) {\n\t\t\t\t\t\tVAR_54 = VAR_57->realname;\n\t\t\t\t\t\tVAR_55 = VAR_4.ptr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (VAR_54) {\n\t\t\t\t\tif (r_type_func_exist (VAR_7, VAR_54)) {\n\t\t\t\t\t\tVAR_23 = strdup (VAR_54);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tVAR_23 = r_type_func_guess (VAR_7, VAR_54);\n\t\t\t\t\t}\n\t\t\t\t\tif (!VAR_23) {\n\t\t\t\t\t\tVAR_23 = strdup (VAR_54);\n\t\t\t\t\t\tVAR_46 = true;\n\t\t\t\t\t}\n\t\t\t\t\tconst char* VAR_59 = r_anal_cc_func (VAR_6, VAR_23);\n\t\t\t\t\tif (VAR_59 && r_anal_cc_exist (VAR_6, VAR_59)) {\n\t\t\t\t\t\tchar *VAR_60 = strdup (VAR_59);\n\t\t\t\t\t\ttype_match (VAR_0, VAR_23, VAR_36, VAR_2->addr, VAR_60, VAR_15, VAR_46, VAR_55);\n\t\t\t\t\t\tVAR_15 = VAR_14;\n\t\t\t\t\t\tR_FREE (VAR_24);\n\t\t\t\t\t\tconst char *VAR_61 = r_type_func_ret (VAR_7, VAR_23);\n\t\t\t\t\t\tif (VAR_61) {\n\t\t\t\t\t\t\tVAR_24 = strdup (VAR_61);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tR_FREE (VAR_30);\n\t\t\t\t\t\tconst char *VAR_62 = r_anal_cc_ret (VAR_6, VAR_60);\n\t\t\t\t\t\tif (VAR_62) {\n\t\t\t\t\t\t\tVAR_30 = strdup (VAR_62);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tVAR_5 = false;\n\t\t\t\t\t\tfree (VAR_60);\n\t\t\t\t\t}\n\t\t\t\t\tif (!strcmp (VAR_23, \"__stack_chk_fail\")) {\n\t\t\t\t\t\tconst char *VAR_63 = sdb_fmt (\"%d.addr\", VAR_14 - 1);\n\t\t\t\t\t\tut64 VAR_64 = sdb_num_get (VAR_47, VAR_63, 0);\n\t\t\t\t\t\tRAnalOp *VAR_65 = r_core_anal_op (VAR_0, VAR_64, VAR_40 | VAR_39);\n\t\t\t\t\t\tif (VAR_65) {\n\t\t\t\t\t\t\tRAnalVar *VAR_66 = r_anal_get_used_function_var (VAR_6, VAR_65->addr);\n\t\t\t\t\t\t\tut32 VAR_50 = VAR_65->type & VAR_51;\n\t\t\t\t\t\t\tif (VAR_50 == VAR_67) {\n\t\t\t\t\t\t\t\t__var_rename (VAR_6, VAR_66, \"canary\", VAR_36);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_anal_op_free (VAR_65);\n\t\t\t\t\t}\n\t\t\t\t\tfree (VAR_23);\n\t\t\t\t}\n\t\t\t} else if (!VAR_5 && VAR_24 && VAR_30) {\n\t\t\t\t/* COMMENT_4 */\n\t\t\t\tchar VAR_68[VAR_69] = {0};\n\t\t\t\tconst char *VAR_63 = sdb_fmt (\"%d.reg.write\", VAR_14);\n\t\t\t\tconst char *VAR_70 = sdb_const_get (VAR_47, VAR_63, 0);\n\t\t\t\tget_src_regname (VAR_0, VAR_4.addr, VAR_68, sizeof (VAR_68));\n\t\t\t\tif (VAR_30 && *VAR_68 && strstr (VAR_30, VAR_68)) {\n\t\t\t\t\tif (VAR_48 && VAR_4.direction == VAR_71) {\n\t\t\t\t\t\t__var_retype (VAR_6, VAR_48, NULL, VAR_24, false, false);\n\t\t\t\t\t\tVAR_5 = true;\n\t\t\t\t\t} else if (VAR_50 == VAR_67) {\n\t\t\t\t\t\tR_FREE (VAR_30);\n\t\t\t\t\t\tif (VAR_70) {\n\t\t\t\t\t\t\tVAR_30 = strdup (VAR_70);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (VAR_70) {\n\t\t\t\t\tchar *VAR_72 = strdup (VAR_70);\n\t\t\t\t\tchar *VAR_73 = strchr (VAR_72, ',');\n\t\t\t\t\tif (VAR_73) {\n\t\t\t\t\t\t*VAR_73++ = '\\0';\n\t\t\t\t\t}\n\t\t\t\t\tif (VAR_30 && (strstr (VAR_30, VAR_72) || (VAR_73 && strstr (VAR_30, VAR_73)))) {\n\t\t\t\t\t\tVAR_5 = true;\n\t\t\t\t\t} else if (VAR_50 == VAR_67 &&\n\t\t\t\t\t\t\t(VAR_49 && VAR_49->type == VAR_67)){\n\t\t\t\t\t\t/* COMMENT_5 */\n\t\t\t\t\t\t/* COMMENT_6 */\n\t\t\t\t\t\t/* COMMENT_7 */\n\t\t\t\t\t\tchar VAR_74[VAR_69] = {0};\n\t\t\t\t\t\tget_src_regname (VAR_0, VAR_49->addr, VAR_74, sizeof (VAR_74));\n\t\t\t\t\t\tif (VAR_30 && *VAR_74 && strstr (VAR_30, VAR_74) && VAR_48 &&\n\t\t\t\t\t\t\t\tVAR_4.direction == VAR_75) {\n\t\t\t\t\t\t\t__var_retype (VAR_6, VAR_48, NULL, VAR_24, true, false);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree (VAR_72);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* COMMENT_8 */\n\t\t\tif (VAR_48) {\n\t\t\t\tbool VAR_76 = false;\n\t\t\t\tif ((VAR_50 == VAR_77) && VAR_49) {\n\t\t\t\t\tif (VAR_49->sign) {\n\t\t\t\t\t\tVAR_76 = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* COMMENT_9 */\n\t\t\t\t\t\t__var_retype (VAR_6, VAR_48, NULL, \"unsigned\", false, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* COMMENT_10 */\n\t\t\t\tif (VAR_76 || VAR_4.sign) {\n\t\t\t\t\t__var_retype (VAR_6, VAR_48, NULL, \"signed\", false, true);\n\t\t\t\t}\n\t\t\t\t/* COMMENT_11 */\n\t\t\t\t/* COMMENT_12 */\n\t\t\t\tif (VAR_29 && (VAR_50 == VAR_67 || VAR_50 == VAR_78)) {\n\t\t\t\t\tchar VAR_79[VAR_69] = {0};\n\t\t\t\t\tget_src_regname (VAR_0, VAR_36, VAR_79, sizeof (VAR_79));\n\t\t\t\t\tbool VAR_80 = strstr (VAR_29, VAR_79) != NULL;\n\t\t\t\t\tif (VAR_25 && VAR_80) {\n\t\t\t\t\t\t__var_retype (VAR_6, VAR_48, NULL, \"const char *\", false, false);\n\t\t\t\t\t}\n\t\t\t\t\tif (VAR_26 && VAR_80 && VAR_27) {\n\t\t\t\t\t\t__var_retype (VAR_6, VAR_48, NULL, VAR_28, false, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (VAR_8 && VAR_48 && (VAR_50 == VAR_77 && VAR_4.disp != VAR_45)\n\t\t\t\t\t\t&& VAR_49 && VAR_49->type == VAR_81) {\n\t\t\t\t\tbool VAR_82 = false;\n\t\t\t\t\tRAnalOp *VAR_83 = {0};\n\t\t\t\t\tut64 VAR_84 = VAR_49->jump;\n\t\t\t\t\tRAnalBlock *VAR_85 = r_anal_fcn_bbget_in (VAR_6, VAR_1, VAR_84);\n\n\t\t\t\t\t/* COMMENT_13 */\n\t\t\t\t\tfor (VAR_37 = 0; VAR_37 < VAR_86 ; VAR_37++) {\n\t\t\t\t\t\tVAR_83 = r_core_anal_op (VAR_0, VAR_84, VAR_39);\n\t\t\t\t\t\tif (!VAR_83) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ((VAR_83->type == VAR_44 && r_anal_block_contains (VAR_85, VAR_84))\n\t\t\t\t\t\t\t\t|| VAR_83->type == VAR_81) {\n\t\t\t\t\t\t\tVAR_82 = true;\n\t\t\t\t\t\t\tr_anal_op_free (VAR_83);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tVAR_84 += VAR_83->size;\n\t\t\t\t\t\tr_anal_op_free (VAR_83);\n\t\t\t\t\t}\n\t\t\t\t\tRAnalVarConstraint VAR_87 = {\n\t\t\t\t\t\t.cond = VAR_82? cond_invert (VAR_6, VAR_49->cond): VAR_49->cond,\n\t\t\t\t\t\t.val = VAR_4.val\n\t\t\t\t\t};\n\t\t\t\t\tr_anal_var_add_constraint (VAR_48, &VAR_87);\n\t\t\t\t}\n\t\t\t}\n\t\t\tVAR_27 = (VAR_48 && VAR_4.direction == VAR_75);\n\t\t\tVAR_25 = false;\n\t\t\tVAR_26 = false;\n\t\t\tVAR_29 = NULL;\n\t\t\tswitch (VAR_50) {\n\t\t\tcase VAR_67:\n\t\t\tcase VAR_88:\n\t\t\tcase VAR_89:\n\t\t\t\tif (VAR_4.ptr && VAR_4.refptr && VAR_4.ptr != VAR_45) {\n\t\t\t\t\tif (VAR_50 == VAR_89) {\n\t\t\t\t\t\tut8 VAR_19[256] = {0};\n\t\t\t\t\t\tr_io_read_at (VAR_0->io, VAR_4.ptr, VAR_19, sizeof (VAR_19) - 1);\n\t\t\t\t\t\tut64 VAR_90 = r_read_ble (VAR_19, VAR_0->print->big_endian, VAR_4.refptr * 8);\n\t\t\t\t\t\tif (VAR_90 && VAR_90 != VAR_45) {\n\t\t\t\t\t\t\tRFlagItem *VAR_91 = r_flag_get_by_spaces (VAR_0->flags, VAR_90, VAR_92, NULL);\n\t\t\t\t\t\t\tif (VAR_91) {\n\t\t\t\t\t\t\t\tVAR_25 = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (r_flag_exist_at (VAR_0->flags, \"str\", 3, VAR_4.ptr)) {\n\t\t\t\t\t\tVAR_25 = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* COMMENT_14 */\n\t\t\t\tif (VAR_48 && VAR_25) {\n\t\t\t\t\t__var_retype (VAR_6, VAR_48, NULL, \"const char *\", false, false);\n\t\t\t\t}\n\t\t\t\tconst char *VAR_63 = sdb_fmt (\"%d.reg.write\", VAR_14);\n\t\t\t\tVAR_29 = sdb_const_get (VAR_47, VAR_63, 0);\n\t\t\t\tif (VAR_48) {\n\t\t\t\t\tstrncpy (VAR_28, VAR_48->type, sizeof (VAR_28) - 1);\n\t\t\t\t\tVAR_26 = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tVAR_37 += VAR_9;\n\t\t\tVAR_36 += VAR_9;\n\t\t\tr_anal_op_free (VAR_49);\n\t\t\tr_anal_op_fini (&VAR_4);\n\n\t\t}\n\t}\n\t/* COMMENT_15 */\n\tRList *VAR_93 = r_anal_var_list (VAR_6, VAR_1, VAR_94);\n\tRAnalVar *VAR_95;\n\tRListIter *VAR_96;\n\tr_list_foreach (VAR_93, VAR_96, VAR_95) {\n\t\tRAnalVar *VAR_97 = r_anal_var_get_dst_var (VAR_95);\n\t\tRRegItem *VAR_37 = r_reg_index_get (VAR_6->reg, VAR_95->delta);\n\t\tif (!VAR_37) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (VAR_97) {\n\t\t\t/* COMMENT_16 */\n\t\t\t__var_retype (VAR_6, VAR_95, NULL, VAR_97->type, false, false);\n\t\t\t/* COMMENT_17 */\n\t\t\t__var_retype (VAR_6, VAR_97, NULL, VAR_95->type, false, false);\n\t\t}\n\t}\n\tr_list_free (VAR_93);\nout_function:\n\tR_FREE (VAR_30);\n\tR_FREE (VAR_24);\n\tfree (VAR_19);\n\tr_cons_break_pop();\n\tanal_emul_restore (VAR_0, VAR_16, VAR_17, VAR_18);\n\tfree (VAR_33);\n}",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -54,11 +54,12 @@\n \tchar prev_type[256] = {0};\n \tconst char *prev_dest = NULL;\n \tchar *ret_reg = NULL;\n-\tconst char *pc = r_reg_get_name (core->dbg->reg, R_REG_NAME_PC);\n-\tif (!pc) {\n-        free (buf);\n-\t\treturn;\n-\t}\n+\tconst char *_pc = r_reg_get_name (core->dbg->reg, R_REG_NAME_PC);\n+\tif (!_pc) {\n+\t\tfree (buf);\n+\t\treturn;\n+\t}\n+\tchar *pc = strdup (_pc);\n \tRRegItem *r = r_reg_get (core->dbg->reg, pc, -1);\n \tif (!r) {\n \t\tfree (buf);\n@@ -328,4 +329,5 @@\n \tfree (buf);\n \tr_cons_break_pop();\n \tanal_emul_restore (core, hc, dt, et);\n+\tfree (pc);\n }",
  "diff_line_info": {
    "deleted_lines": [
      "\tconst char *pc = r_reg_get_name (core->dbg->reg, R_REG_NAME_PC);",
      "\tif (!pc) {",
      "        free (buf);",
      "\t\treturn;",
      "\t}"
    ],
    "added_lines": [
      "\tconst char *_pc = r_reg_get_name (core->dbg->reg, R_REG_NAME_PC);",
      "\tif (!_pc) {",
      "\t\tfree (buf);",
      "\t\treturn;",
      "\t}",
      "\tchar *pc = strdup (_pc);",
      "\tfree (pc);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/radareorg/radare2/pull/19342",
  "description": {
    "pr_info": {
      "title": "Soft crashfixes",
      "number": 19342
    },
    "comment": [
      "<!-- Please read the contributing guidelines:\r\n* https://github.com/radareorg/radare2/blob/master/DEVELOPERS.md\r\nIn short:\r\n* PR title must be capitalized, concise and use ##tags\r\n* Follow the coding style, add tests and documentation if necessary\r\n-->\r\n\r\n**Checklist**\r\n\r\n- [ ] Closing issues: #issue\r\n- [ ] Mark this if you consider it ready to merge\r\n- [ ] I've added tests (optional)\r\n- [ ] I wrote some lines in the [radare2book](https://github.com/radareorg/radare2book)\r\n\r\n**Description**\r\n\r\n<!-- Explain the **details** to understand the purpose of this contribution, with enough information to help us understand better the changes. -->\r\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix\nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\nThe patch addresses a Use-After-Free (UAF) vulnerability by ensuring proper memory management, preventing potential security exploits.\n\n**Final Output:**\nAnalysis: The patch fixes a Use-After-Free vulnerability by correctly allocating and freeing memory, preventing potential security exploits.\nFinal Classification: Security Vulnerability Fix\nConfidence Score: 1.0"
}