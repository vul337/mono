{
  "cve_id": "CVE-2019-15534",
  "cwe_ids": [
    "CWE-89"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "folio-org/raml-module-builder",
  "commit_msg": "RMB-200: Single quote SQL Injection in PostgresClient.update(table, updateSection, ...)",
  "commit_hash": "b7ef741133e57add40aa4cb19430a0065f378a94",
  "git_url": "https://github.com/folio-org/raml-module-builder/commit/b7ef741133e57add40aa4cb19430a0065f378a94",
  "file_path": "domain-models-runtime/src/main/java/org/folio/rest/persist/PostgresClient.java",
  "func_name": "update",
  "func_before": "public void update(String table, UpdateSection section, Criterion when, boolean returnUpdatedIdsCount,\n      Handler<AsyncResult<UpdateResult>> replyHandler) {\n    long start = System.nanoTime();\n    vertx.runOnContext(v -> {\n      client.getConnection(res -> {\n        if (res.succeeded()) {\n          SQLConnection connection = res.result();\n          StringBuilder sb = new StringBuilder();\n          if (when != null) {\n            sb.append(when.toString());\n          }\n          StringBuilder returning = new StringBuilder();\n          if (returnUpdatedIdsCount) {\n            returning.append(RETURNING_ID);\n          }\n          try {\n            String q = UPDATE + schemaName + DOT + table + SET + DEFAULT_JSONB_FIELD_NAME + \" = jsonb_set(\" + DEFAULT_JSONB_FIELD_NAME + \",\"\n                + section.getFieldsString() + \", '\" + section.getValue() + \"', false) \" + sb.toString() + SPACE + returning;\n            log.debug(\"update query = \" + q);\n            connection.update(q, query -> {\n              connection.close();\n              if (query.failed()) {\n                log.error(query.cause().getMessage(), query.cause());\n                replyHandler.handle(Future.failedFuture(query.cause()));\n              } else {\n                replyHandler.handle(Future.succeededFuture(query.result()));\n              }\n              statsTracker(UPDATE_STAT_METHOD, table, start);\n            });\n          } catch (Exception e) {\n            if(connection != null){\n              connection.close();\n            }\n            log.error(e.getMessage(), e);\n            replyHandler.handle(Future.failedFuture(e));\n          }\n        } else {\n          log.error(res.cause().getMessage(), res.cause());\n          replyHandler.handle(Future.failedFuture(res.cause()));\n        }\n      });\n    });\n  }",
  "abstract_func_before": "public void update(String VAR_0, UpdateSection VAR_1, Criterion VAR_2, boolean VAR_3,\n      Handler<AsyncResult<UpdateResult>> VAR_4) {\n    long VAR_5 = VAR_6.nanoTime();\n    VAR_7.runOnContext(VAR_8 -> {\n      VAR_9.getConnection(VAR_10 -> {\n        if (VAR_10.succeeded()) {\n          SQLConnection VAR_11 = VAR_10.result();\n          StringBuilder VAR_12 = new StringBuilder();\n          if (VAR_2 != null) {\n            VAR_12.append(VAR_2.toString());\n          }\n          StringBuilder VAR_13 = new StringBuilder();\n          if (VAR_3) {\n            VAR_13.append(VAR_14);\n          }\n          try {\n            String VAR_15 = VAR_16 + VAR_17 + VAR_18 + VAR_0 + VAR_19 + VAR_20 + \" = jsonb_set(\" + VAR_20 + \",\"\n                + VAR_1.getFieldsString() + \", '\" + VAR_1.getValue() + \"', false) \" + VAR_12.toString() + VAR_21 + VAR_13;\n            VAR_22.debug(\"update query = \" + VAR_15);\n            VAR_11.update(VAR_15, VAR_23 -> {\n              VAR_11.close();\n              if (VAR_23.failed()) {\n                VAR_22.error(VAR_23.cause().getMessage(), VAR_23.cause());\n                VAR_4.handle(VAR_24.failedFuture(VAR_23.cause()));\n              } else {\n                VAR_4.handle(VAR_24.succeededFuture(VAR_23.result()));\n              }\n              statsTracker(VAR_25, VAR_0, VAR_5);\n            });\n          } catch (Exception VAR_26) {\n            if(VAR_11 != null){\n              VAR_11.close();\n            }\n            VAR_22.error(VAR_26.getMessage(), VAR_26);\n            VAR_4.handle(VAR_24.failedFuture(VAR_26));\n          }\n        } else {\n          VAR_22.error(VAR_10.cause().getMessage(), VAR_10.cause());\n          VAR_4.handle(VAR_24.failedFuture(VAR_10.cause()));\n        }\n      });\n    });\n  }",
  "func_graph_path_before": "folio-org/raml-module-builder/b7ef741133e57add40aa4cb19430a0065f378a94/PostgresClient.java/vul/before/0.json",
  "func": "public void update(String table, UpdateSection section, Criterion when, boolean returnUpdatedIdsCount,\n      Handler<AsyncResult<UpdateResult>> replyHandler) {\n    long start = System.nanoTime();\n    vertx.runOnContext(v -> {\n      client.getConnection(res -> {\n        if (res.succeeded()) {\n          SQLConnection connection = res.result();\n          try {\n            String value = section.getValue().replace(\"'\", \"''\");\n            String where = when == null ? \"\" : when.toString();\n            String returning = returnUpdatedIdsCount ? RETURNING_ID : \"\";\n            String q = UPDATE + schemaName + DOT + table + SET + DEFAULT_JSONB_FIELD_NAME\n                + \" = jsonb_set(\" + DEFAULT_JSONB_FIELD_NAME + \",\"\n                + section.getFieldsString() + \", '\" + value + \"', false) \" + where + returning;\n            log.debug(\"update query = \" + q);\n            connection.update(q, query -> {\n              connection.close();\n              if (query.failed()) {\n                log.error(query.cause().getMessage(), query.cause());\n                replyHandler.handle(Future.failedFuture(query.cause()));\n              } else {\n                replyHandler.handle(Future.succeededFuture(query.result()));\n              }\n              statsTracker(UPDATE_STAT_METHOD, table, start);\n            });\n          } catch (Exception e) {\n            if(connection != null){\n              connection.close();\n            }\n            log.error(e.getMessage(), e);\n            replyHandler.handle(Future.failedFuture(e));\n          }\n        } else {\n          log.error(res.cause().getMessage(), res.cause());\n          replyHandler.handle(Future.failedFuture(res.cause()));\n        }\n      });\n    });\n  }",
  "abstract_func": "public void update(String VAR_0, UpdateSection VAR_1, Criterion VAR_2, boolean VAR_3,\n      Handler<AsyncResult<UpdateResult>> VAR_4) {\n    long VAR_5 = VAR_6.nanoTime();\n    VAR_7.runOnContext(VAR_8 -> {\n      VAR_9.getConnection(VAR_10 -> {\n        if (VAR_10.succeeded()) {\n          SQLConnection VAR_11 = VAR_10.result();\n          try {\n            String VAR_12 = VAR_1.getValue().replace(\"'\", \"''\");\n            String VAR_13 = VAR_2 == null ? \"\" : VAR_2.toString();\n            String VAR_14 = VAR_3 ? VAR_15 : \"\";\n            String VAR_16 = VAR_17 + VAR_18 + VAR_19 + VAR_0 + VAR_20 + VAR_21\n                + \" = jsonb_set(\" + VAR_21 + \",\"\n                + VAR_1.getFieldsString() + \", '\" + VAR_12 + \"', false) \" + VAR_13 + VAR_14;\n            VAR_22.debug(\"update query = \" + VAR_16);\n            VAR_11.update(VAR_16, VAR_23 -> {\n              VAR_11.close();\n              if (VAR_23.failed()) {\n                VAR_22.error(VAR_23.cause().getMessage(), VAR_23.cause());\n                VAR_4.handle(VAR_24.failedFuture(VAR_23.cause()));\n              } else {\n                VAR_4.handle(VAR_24.succeededFuture(VAR_23.result()));\n              }\n              statsTracker(VAR_25, VAR_0, VAR_5);\n            });\n          } catch (Exception VAR_26) {\n            if(VAR_11 != null){\n              VAR_11.close();\n            }\n            VAR_22.error(VAR_26.getMessage(), VAR_26);\n            VAR_4.handle(VAR_24.failedFuture(VAR_26));\n          }\n        } else {\n          VAR_22.error(VAR_10.cause().getMessage(), VAR_10.cause());\n          VAR_4.handle(VAR_24.failedFuture(VAR_10.cause()));\n        }\n      });\n    });\n  }",
  "func_graph_path": "folio-org/raml-module-builder/b7ef741133e57add40aa4cb19430a0065f378a94/PostgresClient.java/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -5,17 +5,13 @@\n       client.getConnection(res -> {\n         if (res.succeeded()) {\n           SQLConnection connection = res.result();\n-          StringBuilder sb = new StringBuilder();\n-          if (when != null) {\n-            sb.append(when.toString());\n-          }\n-          StringBuilder returning = new StringBuilder();\n-          if (returnUpdatedIdsCount) {\n-            returning.append(RETURNING_ID);\n-          }\n           try {\n-            String q = UPDATE + schemaName + DOT + table + SET + DEFAULT_JSONB_FIELD_NAME + \" = jsonb_set(\" + DEFAULT_JSONB_FIELD_NAME + \",\"\n-                + section.getFieldsString() + \", '\" + section.getValue() + \"', false) \" + sb.toString() + SPACE + returning;\n+            String value = section.getValue().replace(\"'\", \"''\");\n+            String where = when == null ? \"\" : when.toString();\n+            String returning = returnUpdatedIdsCount ? RETURNING_ID : \"\";\n+            String q = UPDATE + schemaName + DOT + table + SET + DEFAULT_JSONB_FIELD_NAME\n+                + \" = jsonb_set(\" + DEFAULT_JSONB_FIELD_NAME + \",\"\n+                + section.getFieldsString() + \", '\" + value + \"', false) \" + where + returning;\n             log.debug(\"update query = \" + q);\n             connection.update(q, query -> {\n               connection.close();",
  "diff_line_info": {
    "deleted_lines": [
      "          StringBuilder sb = new StringBuilder();",
      "          if (when != null) {",
      "            sb.append(when.toString());",
      "          }",
      "          StringBuilder returning = new StringBuilder();",
      "          if (returnUpdatedIdsCount) {",
      "            returning.append(RETURNING_ID);",
      "          }",
      "            String q = UPDATE + schemaName + DOT + table + SET + DEFAULT_JSONB_FIELD_NAME + \" = jsonb_set(\" + DEFAULT_JSONB_FIELD_NAME + \",\"",
      "                + section.getFieldsString() + \", '\" + section.getValue() + \"', false) \" + sb.toString() + SPACE + returning;"
    ],
    "added_lines": [
      "            String value = section.getValue().replace(\"'\", \"''\");",
      "            String where = when == null ? \"\" : when.toString();",
      "            String returning = returnUpdatedIdsCount ? RETURNING_ID : \"\";",
      "            String q = UPDATE + schemaName + DOT + table + SET + DEFAULT_JSONB_FIELD_NAME",
      "                + \" = jsonb_set(\" + DEFAULT_JSONB_FIELD_NAME + \",\"",
      "                + section.getFieldsString() + \", '\" + value + \"', false) \" + where + returning;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/folio-org/raml-module-builder/pull/501",
  "description": {
    "pr_info": {
      "title": "RMB-200: Single quote SQL Injection in PostgresClient.update with updateSection",
      "number": 501
    },
    "comment": [
      "CVE-2019-15534 has been assigned to this vulnerability: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-15534\r\n\r\nLink to our issue tracker: https://issues.folio.org/browse/RMB-200\r\n\r\nAffected versions: All below 27.0.0.",
      "Everything seems fine with this change."
    ]
  },
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses a SQL injection vulnerability by sanitizing user input. The code before the patch did not properly handle single quotes, allowing potential SQL injection. The fix escapes single quotes, preventing malicious SQL execution.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 1.0"
}