{
  "cve_id": "CVE-2021-37620",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "Exiv2/exiv2",
  "commit_msg": "Safer std::vector indexing.",
  "commit_hash": "76e313745e813f80e8910aceb2210af3ad8cf897",
  "git_url": "https://github.com/Exiv2/exiv2/commit/76e313745e813f80e8910aceb2210af3ad8cf897",
  "file_path": "src/basicio.cpp",
  "func_name": "FileIo::Impl::switchMode",
  "func_before": "int FileIo::Impl::switchMode(OpMode opMode)\n    {\n        assert(fp_ != 0);\n        if (opMode_ == opMode) return 0;\n        OpMode oldOpMode = opMode_;\n        opMode_ = opMode;\n\n        bool reopen = true;\n        switch(opMode) {\n        case opRead:\n            // Flush if current mode allows reading, else reopen (in mode \"r+b\"\n            // as in this case we know that we can write to the file)\n            if (openMode_[0] == 'r' || openMode_[1] == '+') reopen = false;\n            break;\n        case opWrite:\n            // Flush if current mode allows writing, else reopen\n            if (openMode_[0] != 'r' || openMode_[1] == '+') reopen = false;\n            break;\n        case opSeek:\n            reopen = false;\n            break;\n        }\n\n        if (!reopen) {\n            // Don't do anything when switching _from_ opSeek mode; we\n            // flush when switching _to_ opSeek.\n            if (oldOpMode == opSeek) return 0;\n\n            // Flush. On msvcrt fflush does not do the job\n            std::fseek(fp_, 0, SEEK_CUR);\n            return 0;\n        }\n\n        // Reopen the file\n        long offset = std::ftell(fp_);\n        if (offset == -1) return -1;\n        // 'Manual' open(\"r+b\") to avoid munmap()\n        if (fp_ != 0) {\n            std::fclose(fp_);\n            fp_= 0;\n        }\n        openMode_ = \"r+b\";\n        opMode_ = opSeek;\n#ifdef EXV_UNICODE_PATH\n        if (wpMode_ == wpUnicode) {\n            fp_ = ::_wfopen(wpath_.c_str(), s2ws(openMode_).c_str());\n        }\n        else\n#endif\n        {\n            fp_ = std::fopen(path_.c_str(), openMode_.c_str());\n        }\n        if (!fp_) return 1;\n        return std::fseek(fp_, offset, SEEK_SET);\n    }",
  "abstract_func_before": "int FileIo::Impl::switchMode(OpMode VAR_0)\n    {\n        assert(VAR_1 != 0);\n        if (VAR_2 == VAR_0) return 0;\n        OpMode VAR_3 = VAR_2;\n        VAR_2 = VAR_0;\n\n        bool VAR_4 = true;\n        switch(VAR_0) {\n        case VAR_5:\n            /* COMMENT_0 */\n            /* COMMENT_1 */\n            if (VAR_6[0] == 'r' || VAR_6[1] == '+') VAR_4 = false;\n            break;\n        case VAR_7:\n            /* COMMENT_2 */\n            if (VAR_6[0] != 'r' || VAR_6[1] == '+') VAR_4 = false;\n            break;\n        case VAR_8:\n            VAR_4 = false;\n            break;\n        }\n\n        if (!VAR_4) {\n            /* COMMENT_3 */\n            /* COMMENT_4 */\n            if (VAR_3 == VAR_8) return 0;\n\n            /* COMMENT_5 */\n            std::fseek(VAR_1, 0, VAR_9);\n            return 0;\n        }\n\n        /* COMMENT_6 */\n        long VAR_10 = std::ftell(VAR_1);\n        if (VAR_10 == -1) return -1;\n        /* COMMENT_7 */\n        if (VAR_1 != 0) {\n            std::fclose(VAR_1);\n            VAR_1= 0;\n        }\n        VAR_6 = \"r+b\";\n        VAR_2 = VAR_8;\n#ifdef VAR_11\n        if (VAR_12 == VAR_13) {\n            VAR_1 = ::_wfopen(VAR_14.c_str(), s2ws(VAR_6).c_str());\n        }\n        else\n#endif\n        {\n            VAR_1 = std::fopen(VAR_15.c_str(), VAR_6.c_str());\n        }\n        if (!VAR_1) return 1;\n        return std::fseek(VAR_1, VAR_10, VAR_16);\n    }",
  "func_graph_path_before": "Exiv2/exiv2/76e313745e813f80e8910aceb2210af3ad8cf897/basicio.cpp/vul/before/1.json",
  "func": "int FileIo::Impl::switchMode(OpMode opMode)\n    {\n        assert(fp_ != 0);\n        if (opMode_ == opMode) return 0;\n        OpMode oldOpMode = opMode_;\n        opMode_ = opMode;\n\n        bool reopen = true;\n        switch(opMode) {\n        case opRead:\n            // Flush if current mode allows reading, else reopen (in mode \"r+b\"\n            // as in this case we know that we can write to the file)\n            if (openMode_.at(0) == 'r' || openMode_.at(1) == '+') reopen = false;\n            break;\n        case opWrite:\n            // Flush if current mode allows writing, else reopen\n            if (openMode_.at(0) != 'r' || openMode_.at(1) == '+') reopen = false;\n            break;\n        case opSeek:\n            reopen = false;\n            break;\n        }\n\n        if (!reopen) {\n            // Don't do anything when switching _from_ opSeek mode; we\n            // flush when switching _to_ opSeek.\n            if (oldOpMode == opSeek) return 0;\n\n            // Flush. On msvcrt fflush does not do the job\n            std::fseek(fp_, 0, SEEK_CUR);\n            return 0;\n        }\n\n        // Reopen the file\n        long offset = std::ftell(fp_);\n        if (offset == -1) return -1;\n        // 'Manual' open(\"r+b\") to avoid munmap()\n        if (fp_ != 0) {\n            std::fclose(fp_);\n            fp_= 0;\n        }\n        openMode_ = \"r+b\";\n        opMode_ = opSeek;\n#ifdef EXV_UNICODE_PATH\n        if (wpMode_ == wpUnicode) {\n            fp_ = ::_wfopen(wpath_.c_str(), s2ws(openMode_).c_str());\n        }\n        else\n#endif\n        {\n            fp_ = std::fopen(path_.c_str(), openMode_.c_str());\n        }\n        if (!fp_) return 1;\n        return std::fseek(fp_, offset, SEEK_SET);\n    }",
  "abstract_func": "int FileIo::Impl::switchMode(OpMode VAR_0)\n    {\n        assert(VAR_1 != 0);\n        if (VAR_2 == VAR_0) return 0;\n        OpMode VAR_3 = VAR_2;\n        VAR_2 = VAR_0;\n\n        bool VAR_4 = true;\n        switch(VAR_0) {\n        case VAR_5:\n            /* COMMENT_0 */\n            /* COMMENT_1 */\n            if (VAR_6.at(0) == 'r' || VAR_6.at(1) == '+') VAR_4 = false;\n            break;\n        case VAR_7:\n            /* COMMENT_2 */\n            if (VAR_6.at(0) != 'r' || VAR_6.at(1) == '+') VAR_4 = false;\n            break;\n        case VAR_8:\n            VAR_4 = false;\n            break;\n        }\n\n        if (!VAR_4) {\n            /* COMMENT_3 */\n            /* COMMENT_4 */\n            if (VAR_3 == VAR_8) return 0;\n\n            /* COMMENT_5 */\n            std::fseek(VAR_1, 0, VAR_9);\n            return 0;\n        }\n\n        /* COMMENT_6 */\n        long VAR_10 = std::ftell(VAR_1);\n        if (VAR_10 == -1) return -1;\n        /* COMMENT_7 */\n        if (VAR_1 != 0) {\n            std::fclose(VAR_1);\n            VAR_1= 0;\n        }\n        VAR_6 = \"r+b\";\n        VAR_2 = VAR_8;\n#ifdef VAR_11\n        if (VAR_12 == VAR_13) {\n            VAR_1 = ::_wfopen(VAR_14.c_str(), s2ws(VAR_6).c_str());\n        }\n        else\n#endif\n        {\n            VAR_1 = std::fopen(VAR_15.c_str(), VAR_6.c_str());\n        }\n        if (!VAR_1) return 1;\n        return std::fseek(VAR_1, VAR_10, VAR_16);\n    }",
  "func_graph_path": "Exiv2/exiv2/76e313745e813f80e8910aceb2210af3ad8cf897/basicio.cpp/vul/after/1.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -10,11 +10,11 @@\n         case opRead:\n             // Flush if current mode allows reading, else reopen (in mode \"r+b\"\n             // as in this case we know that we can write to the file)\n-            if (openMode_[0] == 'r' || openMode_[1] == '+') reopen = false;\n+            if (openMode_.at(0) == 'r' || openMode_.at(1) == '+') reopen = false;\n             break;\n         case opWrite:\n             // Flush if current mode allows writing, else reopen\n-            if (openMode_[0] != 'r' || openMode_[1] == '+') reopen = false;\n+            if (openMode_.at(0) != 'r' || openMode_.at(1) == '+') reopen = false;\n             break;\n         case opSeek:\n             reopen = false;",
  "diff_line_info": {
    "deleted_lines": [
      "            if (openMode_[0] == 'r' || openMode_[1] == '+') reopen = false;",
      "            if (openMode_[0] != 'r' || openMode_[1] == '+') reopen = false;"
    ],
    "added_lines": [
      "            if (openMode_.at(0) == 'r' || openMode_.at(1) == '+') reopen = false;",
      "            if (openMode_.at(0) != 'r' || openMode_.at(1) == '+') reopen = false;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/sridharb1/exiv2/pull/4",
  "description": {
    "pr_info": {
      "title": "0.27 maintenance",
      "number": 4
    },
    "comment": []
  },
  "Bug Filter": "** Security Vulnerability Fix  \n**Confidence Score:** 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\nThe patch changes array access to use `at()`, preventing potential buffer overflows, which is a security improvement.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 0.95"
}