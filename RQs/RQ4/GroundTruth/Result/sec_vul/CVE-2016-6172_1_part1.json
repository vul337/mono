{
  "cve_id": "CVE-2016-6172",
  "cwe_ids": [
    "CWE-400"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:C",
  "cvss_is_v3": false,
  "repo_name": "PowerDNS/pdns",
  "commit_msg": "Add limits to the size of received AXFR, in megabytes\n\nThis prevents resource exhaustion in case the master is sending a\nvery large amount of data in an update.",
  "commit_hash": "a014f4c224a7b21f1c648257d1fd1128413129aa",
  "git_url": "https://github.com/PowerDNS/pdns/commit/a014f4c224a7b21f1c648257d1fd1128413129aa",
  "file_path": "pdns/resolver.cc",
  "func_name": "AXFRRetriever::AXFRRetriever",
  "func_before": "AXFRRetriever::AXFRRetriever(const ComboAddress& remote,\n        const string& domain,\n        const string& tsigkeyname,\n        const string& tsigalgorithm, \n        const string& tsigsecret,\n        const ComboAddress* laddr)\n: d_tsigkeyname(tsigkeyname), d_tsigsecret(tsigsecret), d_tsigPos(0), d_nonSignedMessages(0)\n{\n  ComboAddress local;\n  if (laddr != NULL) {\n    local = (ComboAddress) (*laddr);\n  } else {\n    if(remote.sin4.sin_family == AF_INET)\n      local=ComboAddress(::arg()[\"query-local-address\"]);\n    else if(!::arg()[\"query-local-address6\"].empty())\n      local=ComboAddress(::arg()[\"query-local-address6\"]);\n    else\n      local=ComboAddress(\"::\");\n  }\n  d_sock = -1;\n  try {\n    d_sock = makeQuerySocket(local, false); // make a TCP socket\n    d_buf = shared_array<char>(new char[65536]);\n    d_remote = remote; // mostly for error reporting\n    this->connect();\n    d_soacount = 0;\n  \n    vector<uint8_t> packet;\n    DNSPacketWriter pw(packet, domain, QType::AXFR);\n    pw.getHeader()->id = dns_random(0xffff);\n  \n    if(!tsigkeyname.empty()) {\n      if (tsigalgorithm == \"hmac-md5\")\n        d_trc.d_algoName = tsigalgorithm + \".sig-alg.reg.int.\";\n      else\n        d_trc.d_algoName = tsigalgorithm;\n      d_trc.d_time = time(0);\n      d_trc.d_fudge = 300;\n      d_trc.d_origID=ntohs(pw.getHeader()->id);\n      d_trc.d_eRcode=0;\n      addTSIG(pw, &d_trc, tsigkeyname, tsigsecret, \"\", false);\n    }\n  \n    uint16_t replen=htons(packet.size());\n    Utility::iovec iov[2];\n    iov[0].iov_base=(char*)&replen;\n    iov[0].iov_len=2;\n    iov[1].iov_base=(char*)&packet[0];\n    iov[1].iov_len=packet.size();\n  \n    int ret=Utility::writev(d_sock, iov, 2);\n    if(ret < 0)\n      throw ResolverException(\"Error sending question to \"+d_remote.toStringWithPort()+\": \"+stringerror());\n    if(ret != (int)(2+packet.size())) {\n      throw ResolverException(\"Partial write on AXFR request to \"+d_remote.toStringWithPort());\n    }\n  \n    int res = waitForData(d_sock, 10, 0);\n    \n    if(!res)\n      throw ResolverException(\"Timeout waiting for answer from \"+d_remote.toStringWithPort()+\" during AXFR\");\n    if(res<0)\n      throw ResolverException(\"Error waiting for answer from \"+d_remote.toStringWithPort()+\": \"+stringerror());\n  }\n  catch(...) {\n    if(d_sock >= 0)\n      close(d_sock);\n    throw;\n  }\n}",
  "abstract_func_before": "AXFRRetriever::AXFRRetriever(const ComboAddress& VAR_0,\n        const string& VAR_1,\n        const string& VAR_2,\n        const string& VAR_3, \n        const string& VAR_4,\n        const ComboAddress* VAR_5)\n: d_tsigkeyname(VAR_2), d_tsigsecret(VAR_4), d_tsigPos(0), d_nonSignedMessages(0)\n{\n  ComboAddress VAR_6;\n  if (VAR_5 != NULL) {\n    VAR_6 = (ComboAddress) (*VAR_5);\n  } else {\n    if(VAR_0.sin4.sin_family == VAR_7)\n      VAR_6=ComboAddress(::arg()[\"query-local-address\"]);\n    else if(!::arg()[\"query-local-address6\"].empty())\n      VAR_6=ComboAddress(::arg()[\"query-local-address6\"]);\n    else\n      VAR_6=ComboAddress(\"::\");\n  }\n  VAR_8 = -1;\n  try {\n    VAR_8 = makeQuerySocket(VAR_6, false); /* COMMENT_0 */\n    VAR_9 = VAR_10<char>(new char[65536]);\n    VAR_11 = VAR_0; /* COMMENT_1 */\n    this->connect();\n    VAR_12 = 0;\n  \n    vector<uint8_t> VAR_13;\n    DNSPacketWriter pw(packet, domain, QType::AXFR);\n    VAR_14.getHeader()->id = dns_random(0xffff);\n  \n    if(!VAR_2.empty()) {\n      if (VAR_3 == \"hmac-md5\")\n        VAR_15.d_algoName = VAR_3 + \".sig-alg.reg.int.\";\n      else\n        VAR_15.d_algoName = VAR_3;\n      VAR_15.d_time = time(0);\n      VAR_15.d_fudge = 300;\n      VAR_15.d_origID=ntohs(VAR_14.getHeader()->id);\n      VAR_15.d_eRcode=0;\n      addTSIG(VAR_14, &VAR_15, VAR_2, VAR_4, \"\", false);\n    }\n  \n    uint16_t VAR_16=htons(packet.size());\n    Utility::iovec VAR_17[2];\n    VAR_17[0].iov_base=(char*)&VAR_16;\n    VAR_17[0].iov_len=2;\n    VAR_17[1].iov_base=(char*)&packet[0];\n    VAR_17[1].iov_len=packet.size();\n  \n    int VAR_18=Utility::writev(VAR_8, VAR_17, 2);\n    if(VAR_18 < 0)\n      throw ResolverException(\"Error sending question to \"+VAR_11.toStringWithPort()+\": \"+stringerror());\n    if(VAR_18 != (int)(2+packet.size())) {\n      throw ResolverException(\"Partial write on AXFR request to \"+VAR_11.toStringWithPort());\n    }\n  \n    int VAR_19 = waitForData(VAR_8, 10, 0);\n    \n    if(!VAR_19)\n      throw ResolverException(\"Timeout waiting for answer from \"+VAR_11.toStringWithPort()+\" during AXFR\");\n    if(VAR_19<0)\n      throw ResolverException(\"Error waiting for answer from \"+VAR_11.toStringWithPort()+\": \"+stringerror());\n  }\n  catch(...) {\n    if(VAR_8 >= 0)\n      close(VAR_8);\n    throw;\n  }\n}",
  "func_graph_path_before": null,
  "func": "AXFRRetriever::AXFRRetriever(const ComboAddress& remote,\n        const string& domain,\n        const string& tsigkeyname,\n        const string& tsigalgorithm, \n        const string& tsigsecret,\n        const ComboAddress* laddr,\n        size_t maxReceivedBytes)\n  : d_tsigkeyname(tsigkeyname), d_tsigsecret(tsigsecret), d_receivedBytes(0), d_maxReceivedBytes(maxReceivedBytes), d_tsigPos(0), d_nonSignedMessages(0)\n{\n  ComboAddress local;\n  if (laddr != NULL) {\n    local = (ComboAddress) (*laddr);\n  } else {\n    if(remote.sin4.sin_family == AF_INET)\n      local=ComboAddress(::arg()[\"query-local-address\"]);\n    else if(!::arg()[\"query-local-address6\"].empty())\n      local=ComboAddress(::arg()[\"query-local-address6\"]);\n    else\n      local=ComboAddress(\"::\");\n  }\n  d_sock = -1;\n  try {\n    d_sock = makeQuerySocket(local, false); // make a TCP socket\n    d_buf = shared_array<char>(new char[65536]);\n    d_remote = remote; // mostly for error reporting\n    this->connect();\n    d_soacount = 0;\n  \n    vector<uint8_t> packet;\n    DNSPacketWriter pw(packet, domain, QType::AXFR);\n    pw.getHeader()->id = dns_random(0xffff);\n  \n    if(!tsigkeyname.empty()) {\n      if (tsigalgorithm == \"hmac-md5\")\n        d_trc.d_algoName = tsigalgorithm + \".sig-alg.reg.int.\";\n      else\n        d_trc.d_algoName = tsigalgorithm;\n      d_trc.d_time = time(0);\n      d_trc.d_fudge = 300;\n      d_trc.d_origID=ntohs(pw.getHeader()->id);\n      d_trc.d_eRcode=0;\n      addTSIG(pw, &d_trc, tsigkeyname, tsigsecret, \"\", false);\n    }\n  \n    uint16_t replen=htons(packet.size());\n    Utility::iovec iov[2];\n    iov[0].iov_base=(char*)&replen;\n    iov[0].iov_len=2;\n    iov[1].iov_base=(char*)&packet[0];\n    iov[1].iov_len=packet.size();\n  \n    int ret=Utility::writev(d_sock, iov, 2);\n    if(ret < 0)\n      throw ResolverException(\"Error sending question to \"+d_remote.toStringWithPort()+\": \"+stringerror());\n    if(ret != (int)(2+packet.size())) {\n      throw ResolverException(\"Partial write on AXFR request to \"+d_remote.toStringWithPort());\n    }\n  \n    int res = waitForData(d_sock, 10, 0);\n    \n    if(!res)\n      throw ResolverException(\"Timeout waiting for answer from \"+d_remote.toStringWithPort()+\" during AXFR\");\n    if(res<0)\n      throw ResolverException(\"Error waiting for answer from \"+d_remote.toStringWithPort()+\": \"+stringerror());\n  }\n  catch(...) {\n    if(d_sock >= 0)\n      close(d_sock);\n    throw;\n  }\n}",
  "abstract_func": "AXFRRetriever::AXFRRetriever(const ComboAddress& VAR_0,\n        const string& VAR_1,\n        const string& VAR_2,\n        const string& VAR_3, \n        const string& VAR_4,\n        const ComboAddress* VAR_5,\n        size_t VAR_6)\n  : d_tsigkeyname(VAR_2), d_tsigsecret(VAR_4), d_receivedBytes(0), d_maxReceivedBytes(VAR_6), d_tsigPos(0), d_nonSignedMessages(0)\n{\n  ComboAddress VAR_7;\n  if (VAR_5 != NULL) {\n    VAR_7 = (ComboAddress) (*VAR_5);\n  } else {\n    if(VAR_0.sin4.sin_family == VAR_8)\n      VAR_7=ComboAddress(::arg()[\"query-local-address\"]);\n    else if(!::arg()[\"query-local-address6\"].empty())\n      VAR_7=ComboAddress(::arg()[\"query-local-address6\"]);\n    else\n      VAR_7=ComboAddress(\"::\");\n  }\n  VAR_9 = -1;\n  try {\n    VAR_9 = makeQuerySocket(VAR_7, false); /* COMMENT_0 */\n    VAR_10 = VAR_11<char>(new char[65536]);\n    VAR_12 = VAR_0; /* COMMENT_1 */\n    this->connect();\n    VAR_13 = 0;\n  \n    vector<uint8_t> VAR_14;\n    DNSPacketWriter pw(packet, domain, QType::AXFR);\n    VAR_15.getHeader()->id = dns_random(0xffff);\n  \n    if(!VAR_2.empty()) {\n      if (VAR_3 == \"hmac-md5\")\n        VAR_16.d_algoName = VAR_3 + \".sig-alg.reg.int.\";\n      else\n        VAR_16.d_algoName = VAR_3;\n      VAR_16.d_time = time(0);\n      VAR_16.d_fudge = 300;\n      VAR_16.d_origID=ntohs(VAR_15.getHeader()->id);\n      VAR_16.d_eRcode=0;\n      addTSIG(VAR_15, &VAR_16, VAR_2, VAR_4, \"\", false);\n    }\n  \n    uint16_t VAR_17=htons(packet.size());\n    Utility::iovec VAR_18[2];\n    VAR_18[0].iov_base=(char*)&VAR_17;\n    VAR_18[0].iov_len=2;\n    VAR_18[1].iov_base=(char*)&packet[0];\n    VAR_18[1].iov_len=packet.size();\n  \n    int VAR_19=Utility::writev(VAR_9, VAR_18, 2);\n    if(VAR_19 < 0)\n      throw ResolverException(\"Error sending question to \"+VAR_12.toStringWithPort()+\": \"+stringerror());\n    if(VAR_19 != (int)(2+packet.size())) {\n      throw ResolverException(\"Partial write on AXFR request to \"+VAR_12.toStringWithPort());\n    }\n  \n    int VAR_20 = waitForData(VAR_9, 10, 0);\n    \n    if(!VAR_20)\n      throw ResolverException(\"Timeout waiting for answer from \"+VAR_12.toStringWithPort()+\" during AXFR\");\n    if(VAR_20<0)\n      throw ResolverException(\"Error waiting for answer from \"+VAR_12.toStringWithPort()+\": \"+stringerror());\n  }\n  catch(...) {\n    if(VAR_9 >= 0)\n      close(VAR_9);\n    throw;\n  }\n}",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -3,8 +3,9 @@\n         const string& tsigkeyname,\n         const string& tsigalgorithm, \n         const string& tsigsecret,\n-        const ComboAddress* laddr)\n-: d_tsigkeyname(tsigkeyname), d_tsigsecret(tsigsecret), d_tsigPos(0), d_nonSignedMessages(0)\n+        const ComboAddress* laddr,\n+        size_t maxReceivedBytes)\n+  : d_tsigkeyname(tsigkeyname), d_tsigsecret(tsigsecret), d_receivedBytes(0), d_maxReceivedBytes(maxReceivedBytes), d_tsigPos(0), d_nonSignedMessages(0)\n {\n   ComboAddress local;\n   if (laddr != NULL) {",
  "diff_line_info": {
    "deleted_lines": [
      "        const ComboAddress* laddr)",
      ": d_tsigkeyname(tsigkeyname), d_tsigsecret(tsigsecret), d_tsigPos(0), d_nonSignedMessages(0)"
    ],
    "added_lines": [
      "        const ComboAddress* laddr,",
      "        size_t maxReceivedBytes)",
      "  : d_tsigkeyname(tsigkeyname), d_tsigsecret(tsigsecret), d_receivedBytes(0), d_maxReceivedBytes(maxReceivedBytes), d_tsigPos(0), d_nonSignedMessages(0)"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/PowerDNS/pdns/pull/4134",
  "description": {
    "pr_info": {
      "title": "Add limits to the size of received AXFR, in megabytes",
      "number": 4134
    },
    "comment": [
      "This prevents resource exhaustion in case the master is sending a\nvery large amount of data in an update.\n",
      "Fixes #4128 for 3.4.x.\n",
      "LGTM. pdns.xml edit is useless, 3.x docs are built from markdown on the docs-3X branch.\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch introduces a size limit for received AXFR data to prevent resource exhaustion, a security issue impacting availability.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 0.95"
}