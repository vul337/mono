{
  "cve_id": "CVE-2021-37620",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "Exiv2/exiv2",
  "commit_msg": "Safer std::vector indexing.",
  "commit_hash": "76e313745e813f80e8910aceb2210af3ad8cf897",
  "git_url": "https://github.com/Exiv2/exiv2/commit/76e313745e813f80e8910aceb2210af3ad8cf897",
  "file_path": "src/properties.cpp",
  "func_name": "XmpProperties::propertyInfo",
  "func_before": "const XmpPropertyInfo* XmpProperties::propertyInfo(const XmpKey& key)\n    {\n        std::string prefix = key.groupName();\n        std::string property = key.tagName();\n        // If property is a path for a nested property, determines the innermost element\n        std::string::size_type i = property.find_last_of('/');\n        if (i != std::string::npos) {\n            for (; i != std::string::npos && !isalpha(property[i]); ++i) {}\n            property = property.substr(i);\n            i = property.find_first_of(':');\n            if (i != std::string::npos) {\n                prefix = property.substr(0, i);\n                property = property.substr(i+1);\n            }\n#ifdef EXIV2_DEBUG_MESSAGES\n            std::cout << \"Nested key: \" << key.key() << \", prefix: \" << prefix\n                      << \", property: \" << property << \"\\n\";\n#endif\n        }\n        const XmpPropertyInfo* pl = propertyList(prefix);\n        if (!pl) return 0;\n        const XmpPropertyInfo* pi = 0;\n        for (int j = 0; pl[j].name_ != 0; ++j) {\n            if (0 == strcmp(pl[j].name_, property.c_str())) {\n                pi = pl + j;\n                break;\n            }\n        }\n        return pi;\n    }",
  "abstract_func_before": "const XmpPropertyInfo* XmpProperties::propertyInfo(const XmpKey& VAR_0)\n    {\n        std::string VAR_1 = VAR_0.groupName();\n        std::string VAR_2 = VAR_0.tagName();\n        /* COMMENT_0 */\n        std::string::size_type VAR_3 = VAR_2.find_last_of('/');\n        if (VAR_3 != std::string::npos) {\n            for (; VAR_3 != std::string::npos && !isalpha(VAR_2[VAR_3]); ++VAR_3) {}\n            VAR_2 = VAR_2.substr(VAR_3);\n            VAR_3 = VAR_2.find_first_of(':');\n            if (VAR_3 != std::string::npos) {\n                VAR_1 = VAR_2.substr(0, VAR_3);\n                VAR_2 = VAR_2.substr(VAR_3+1);\n            }\n#ifdef VAR_4\n            std::cout << \"Nested key: \" << VAR_0.key() << \", prefix: \" << VAR_1\n                      << \", property: \" << VAR_2 << \"\\n\";\n#endif\n        }\n        const XmpPropertyInfo* VAR_5 = propertyList(VAR_1);\n        if (!VAR_5) return 0;\n        const XmpPropertyInfo* VAR_6 = 0;\n        for (int VAR_7 = 0; VAR_5[VAR_7].name_ != 0; ++VAR_7) {\n            if (0 == strcmp(VAR_5[VAR_7].name_, VAR_2.c_str())) {\n                VAR_6 = VAR_5 + VAR_7;\n                break;\n            }\n        }\n        return VAR_6;\n    }",
  "func_graph_path_before": "Exiv2/exiv2/76e313745e813f80e8910aceb2210af3ad8cf897/properties.cpp/vul/before/0.json",
  "func": "const XmpPropertyInfo* XmpProperties::propertyInfo(const XmpKey& key)\n    {\n        std::string prefix = key.groupName();\n        std::string property = key.tagName();\n        // If property is a path for a nested property, determines the innermost element\n        std::string::size_type i = property.find_last_of('/');\n        if (i != std::string::npos) {\n            for (; i != std::string::npos && !isalpha(property.at(i)); ++i) {}\n            property = property.substr(i);\n            i = property.find_first_of(':');\n            if (i != std::string::npos) {\n                prefix = property.substr(0, i);\n                property = property.substr(i+1);\n            }\n#ifdef EXIV2_DEBUG_MESSAGES\n            std::cout << \"Nested key: \" << key.key() << \", prefix: \" << prefix\n                      << \", property: \" << property << \"\\n\";\n#endif\n        }\n        const XmpPropertyInfo* pl = propertyList(prefix);\n        if (!pl) return 0;\n        const XmpPropertyInfo* pi = 0;\n        for (int j = 0; pl[j].name_ != 0; ++j) {\n            if (0 == strcmp(pl[j].name_, property.c_str())) {\n                pi = pl + j;\n                break;\n            }\n        }\n        return pi;\n    }",
  "abstract_func": "const XmpPropertyInfo* XmpProperties::propertyInfo(const XmpKey& VAR_0)\n    {\n        std::string VAR_1 = VAR_0.groupName();\n        std::string VAR_2 = VAR_0.tagName();\n        /* COMMENT_0 */\n        std::string::size_type VAR_3 = VAR_2.find_last_of('/');\n        if (VAR_3 != std::string::npos) {\n            for (; VAR_3 != std::string::npos && !isalpha(VAR_2.at(VAR_3)); ++VAR_3) {}\n            VAR_2 = VAR_2.substr(VAR_3);\n            VAR_3 = VAR_2.find_first_of(':');\n            if (VAR_3 != std::string::npos) {\n                VAR_1 = VAR_2.substr(0, VAR_3);\n                VAR_2 = VAR_2.substr(VAR_3+1);\n            }\n#ifdef VAR_4\n            std::cout << \"Nested key: \" << VAR_0.key() << \", prefix: \" << VAR_1\n                      << \", property: \" << VAR_2 << \"\\n\";\n#endif\n        }\n        const XmpPropertyInfo* VAR_5 = propertyList(VAR_1);\n        if (!VAR_5) return 0;\n        const XmpPropertyInfo* VAR_6 = 0;\n        for (int VAR_7 = 0; VAR_5[VAR_7].name_ != 0; ++VAR_7) {\n            if (0 == strcmp(VAR_5[VAR_7].name_, VAR_2.c_str())) {\n                VAR_6 = VAR_5 + VAR_7;\n                break;\n            }\n        }\n        return VAR_6;\n    }",
  "func_graph_path": "Exiv2/exiv2/76e313745e813f80e8910aceb2210af3ad8cf897/properties.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,7 @@\n         // If property is a path for a nested property, determines the innermost element\n         std::string::size_type i = property.find_last_of('/');\n         if (i != std::string::npos) {\n-            for (; i != std::string::npos && !isalpha(property[i]); ++i) {}\n+            for (; i != std::string::npos && !isalpha(property.at(i)); ++i) {}\n             property = property.substr(i);\n             i = property.find_first_of(':');\n             if (i != std::string::npos) {",
  "diff_line_info": {
    "deleted_lines": [
      "            for (; i != std::string::npos && !isalpha(property[i]); ++i) {}"
    ],
    "added_lines": [
      "            for (; i != std::string::npos && !isalpha(property.at(i)); ++i) {}"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/sridharb1/exiv2/pull/4",
  "description": {
    "pr_info": {
      "title": "0.27 maintenance",
      "number": 4
    },
    "comment": []
  },
  "Bug Filter": "** Security Vulnerability Fix  \n**Confidence Score:** 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\nThe patch replaces unsafe direct indexing with a bounds-checked method, addressing a potential security vulnerability.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 0.95"
}