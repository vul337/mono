{
  "cve_id": "CVE-2021-37620",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "Exiv2/exiv2",
  "commit_msg": "Safer std::vector indexing.",
  "commit_hash": "76e313745e813f80e8910aceb2210af3ad8cf897",
  "git_url": "https://github.com/Exiv2/exiv2/commit/76e313745e813f80e8910aceb2210af3ad8cf897",
  "file_path": "samples/exiv2json.cpp",
  "func_name": "getToken",
  "func_before": "bool getToken(std::string& in,Token& token,Exiv2::StringSet* pNS=NULL)\n{\n    bool result = false;\n    bool ns     = false;\n\n    token.n = \"\"    ;\n    token.a = false ;\n    token.i = 0     ;\n\n    while ( !result && in.length() ) {\n        std::string c = in.substr(0,1);\n        char        C = c[0];\n        in            = in.substr(1,std::string::npos);\n        if ( in.length() == 0 && C != ']' ) token.n += c;\n        if ( C == '/' || C == '[' || C == ':' || C == '.' || C == ']' || in.length() == 0 ) {\n            ns        |= C == '/' ;\n            token.a    = C == '[' ;\n            if (         C == ']' ) token.i = std::atoi(token.n.c_str()); // encoded string first index == 1\n            result     = token.n.length() > 0 ;\n        }  else {\n            token.n   += c;\n        }\n    }\n    if (ns && pNS) pNS->insert(token.n);\n\n    return result;\n}",
  "abstract_func_before": "bool getToken(std::string& VAR_0,Token& VAR_1,Exiv2::StringSet* VAR_2=NULL)\n{\n    bool VAR_3 = false;\n    bool VAR_4     = false;\n\n    VAR_1.n = \"\"    ;\n    VAR_1.a = false ;\n    VAR_1.i = 0     ;\n\n    while ( !VAR_3 && VAR_0.length() ) {\n        std::string VAR_5 = VAR_0.substr(0,1);\n        char        VAR_6 = VAR_5[0];\n        VAR_0            = VAR_0.substr(1,std::string::npos);\n        if ( VAR_0.length() == 0 && VAR_6 != ']' ) VAR_1.n += VAR_5;\n        if ( VAR_6 == '/' || VAR_6 == '[' || VAR_6 == ':' || VAR_6 == '.' || VAR_6 == ']' || VAR_0.length() == 0 ) {\n            VAR_4        |= VAR_6 == '/' ;\n            VAR_1.a    = VAR_6 == '[' ;\n            if (         VAR_6 == ']' ) VAR_1.i = std::atoi(VAR_1.n.c_str()); /* COMMENT_0 */\n            VAR_3     = VAR_1.n.length() > 0 ;\n        }  else {\n            VAR_1.n   += VAR_5;\n        }\n    }\n    if (VAR_4 && VAR_2) VAR_2->insert(VAR_1.n);\n\n    return VAR_3;\n}",
  "func_graph_path_before": "Exiv2/exiv2/76e313745e813f80e8910aceb2210af3ad8cf897/exiv2json.cpp/vul/before/0.json",
  "func": "bool getToken(std::string& in,Token& token,Exiv2::StringSet* pNS=NULL)\n{\n    bool result = false;\n    bool ns     = false;\n\n    token.n = \"\"    ;\n    token.a = false ;\n    token.i = 0     ;\n\n    while ( !result && in.length() ) {\n        std::string c = in.substr(0,1);\n        char        C = c.at(0);\n        in            = in.substr(1,std::string::npos);\n        if ( in.length() == 0 && C != ']' ) token.n += c;\n        if ( C == '/' || C == '[' || C == ':' || C == '.' || C == ']' || in.length() == 0 ) {\n            ns        |= C == '/' ;\n            token.a    = C == '[' ;\n            if (         C == ']' ) token.i = std::atoi(token.n.c_str()); // encoded string first index == 1\n            result     = token.n.length() > 0 ;\n        }  else {\n            token.n   += c;\n        }\n    }\n    if (ns && pNS) pNS->insert(token.n);\n\n    return result;\n}",
  "abstract_func": "bool getToken(std::string& VAR_0,Token& VAR_1,Exiv2::StringSet* VAR_2=NULL)\n{\n    bool VAR_3 = false;\n    bool VAR_4     = false;\n\n    VAR_1.n = \"\"    ;\n    VAR_1.a = false ;\n    VAR_1.i = 0     ;\n\n    while ( !VAR_3 && VAR_0.length() ) {\n        std::string VAR_5 = VAR_0.substr(0,1);\n        char        VAR_6 = VAR_5.at(0);\n        VAR_0            = VAR_0.substr(1,std::string::npos);\n        if ( VAR_0.length() == 0 && VAR_6 != ']' ) VAR_1.n += VAR_5;\n        if ( VAR_6 == '/' || VAR_6 == '[' || VAR_6 == ':' || VAR_6 == '.' || VAR_6 == ']' || VAR_0.length() == 0 ) {\n            VAR_4        |= VAR_6 == '/' ;\n            VAR_1.a    = VAR_6 == '[' ;\n            if (         VAR_6 == ']' ) VAR_1.i = std::atoi(VAR_1.n.c_str()); /* COMMENT_0 */\n            VAR_3     = VAR_1.n.length() > 0 ;\n        }  else {\n            VAR_1.n   += VAR_5;\n        }\n    }\n    if (VAR_4 && VAR_2) VAR_2->insert(VAR_1.n);\n\n    return VAR_3;\n}",
  "func_graph_path": "Exiv2/exiv2/76e313745e813f80e8910aceb2210af3ad8cf897/exiv2json.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -9,7 +9,7 @@\n \n     while ( !result && in.length() ) {\n         std::string c = in.substr(0,1);\n-        char        C = c[0];\n+        char        C = c.at(0);\n         in            = in.substr(1,std::string::npos);\n         if ( in.length() == 0 && C != ']' ) token.n += c;\n         if ( C == '/' || C == '[' || C == ':' || C == '.' || C == ']' || in.length() == 0 ) {",
  "diff_line_info": {
    "deleted_lines": [
      "        char        C = c[0];"
    ],
    "added_lines": [
      "        char        C = c.at(0);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/sridharb1/exiv2/pull/4",
  "description": {
    "pr_info": {
      "title": "0.27 maintenance",
      "number": 4
    },
    "comment": []
  },
  "Bug Filter": "**\n   - Not applicable; the change directly addresses a security issue.\n\n**Final Classification:**\nSecurity Vulnerability Fix\n\n**Confidence Score:**\n0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Analysis:**\n\n1. **Patch Analysis:**\n   - The commit message indicates a focus on safer indexing, suggesting a security concern.\n   - The code change replaces `c[0]` with `c.at(0)`, which adds bounds checking.\n\n2. **Security Vulnerability Assessment:**\n   - The original code could cause undefined behavior with an empty string, a potential security risk.\n   - The fix prevents this by throwing an exception, enhancing security.\n\n3. **Non-Security Classification:**\n   - Not applicable; the change directly addresses a security issue.\n\n**Final Classification:**\nSecurity Vulnerability Fix\n\n**Confidence Score:**\n0.95"
}