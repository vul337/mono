{
  "cve_id": "CVE-2018-18928",
  "cwe_ids": [
    "CWE-190"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "unicode-org/icu",
  "commit_msg": "ICU-20246 Fixing another integer overflow in number parsing.",
  "commit_hash": "53d8c8f3d181d87a6aa925b449b51c4a2c922a51",
  "git_url": "https://github.com/unicode-org/icu/commit/53d8c8f3d181d87a6aa925b449b51c4a2c922a51",
  "file_path": "icu4c/source/i18n/fmtable.cpp",
  "func_name": "Formattable::internalGetCharString",
  "func_before": "CharString *Formattable::internalGetCharString(UErrorCode &status) {\n    if(fDecimalStr == NULL) {\n      if (fDecimalQuantity == NULL) {\n        // No decimal number for the formattable yet.  Which means the value was\n        // set directly by the user as an int, int64 or double.  If the value came\n        // from parsing, or from the user setting a decimal number, fDecimalNum\n        // would already be set.\n        //\n        LocalPointer<DecimalQuantity> dq(new DecimalQuantity(), status);\n        if (U_FAILURE(status)) { return nullptr; }\n        populateDecimalQuantity(*dq, status);\n        if (U_FAILURE(status)) { return nullptr; }\n        fDecimalQuantity = dq.orphan();\n      }\n\n      fDecimalStr = new CharString();\n      if (fDecimalStr == NULL) {\n        status = U_MEMORY_ALLOCATION_ERROR;\n        return NULL;\n      }\n      // Older ICUs called uprv_decNumberToString here, which is not exactly the same as\n      // DecimalQuantity::toScientificString(). The biggest difference is that uprv_decNumberToString does\n      // not print scientific notation for magnitudes greater than -5 and smaller than some amount (+5?).\n      if (fDecimalQuantity->isZero()) {\n        fDecimalStr->append(\"0\", -1, status);\n      } else if (std::abs(fDecimalQuantity->getMagnitude()) < 5) {\n        fDecimalStr->appendInvariantChars(fDecimalQuantity->toPlainString(), status);\n      } else {\n        fDecimalStr->appendInvariantChars(fDecimalQuantity->toScientificString(), status);\n      }\n    }\n    return fDecimalStr;\n}",
  "abstract_func_before": "CharString *Formattable::internalGetCharString(UErrorCode &VAR_0) {\n    if(VAR_1 == NULL) {\n      if (VAR_2 == NULL) {\n        /* COMMENT_0 */\n        /* COMMENT_1 */\n        /* COMMENT_2 */\n        /* COMMENT_3 */\n        /* COMMENT_4 */\n        LocalPointer<DecimalQuantity> VAR_3(new DecimalQuantity(), VAR_0);\n        if (U_FAILURE(VAR_0)) { return nullptr; }\n        populateDecimalQuantity(*VAR_3, VAR_0);\n        if (U_FAILURE(VAR_0)) { return nullptr; }\n        VAR_2 = VAR_3.orphan();\n      }\n\n      VAR_1 = new CharString();\n      if (VAR_1 == NULL) {\n        VAR_0 = VAR_4;\n        return NULL;\n      }\n      /* COMMENT_5 */\n      /* COMMENT_6 */\n      /* COMMENT_7 */\n      if (VAR_2->isZero()) {\n        VAR_1->append(\"0\", -1, VAR_0);\n      } else if (std::abs(VAR_2->getMagnitude()) < 5) {\n        VAR_1->appendInvariantChars(VAR_2->toPlainString(), VAR_0);\n      } else {\n        VAR_1->appendInvariantChars(VAR_2->toScientificString(), VAR_0);\n      }\n    }\n    return VAR_1;\n}",
  "func_graph_path_before": "unicode-org/icu/53d8c8f3d181d87a6aa925b449b51c4a2c922a51/fmtable.cpp/vul/before/0.json",
  "func": "CharString *Formattable::internalGetCharString(UErrorCode &status) {\n    if(fDecimalStr == NULL) {\n      if (fDecimalQuantity == NULL) {\n        // No decimal number for the formattable yet.  Which means the value was\n        // set directly by the user as an int, int64 or double.  If the value came\n        // from parsing, or from the user setting a decimal number, fDecimalNum\n        // would already be set.\n        //\n        LocalPointer<DecimalQuantity> dq(new DecimalQuantity(), status);\n        if (U_FAILURE(status)) { return nullptr; }\n        populateDecimalQuantity(*dq, status);\n        if (U_FAILURE(status)) { return nullptr; }\n        fDecimalQuantity = dq.orphan();\n      }\n\n      fDecimalStr = new CharString();\n      if (fDecimalStr == NULL) {\n        status = U_MEMORY_ALLOCATION_ERROR;\n        return NULL;\n      }\n      // Older ICUs called uprv_decNumberToString here, which is not exactly the same as\n      // DecimalQuantity::toScientificString(). The biggest difference is that uprv_decNumberToString does\n      // not print scientific notation for magnitudes greater than -5 and smaller than some amount (+5?).\n      if (fDecimalQuantity->isZero()) {\n        fDecimalStr->append(\"0\", -1, status);\n      } else if (fDecimalQuantity->getMagnitude() != INT32_MIN && std::abs(fDecimalQuantity->getMagnitude()) < 5) {\n        fDecimalStr->appendInvariantChars(fDecimalQuantity->toPlainString(), status);\n      } else {\n        fDecimalStr->appendInvariantChars(fDecimalQuantity->toScientificString(), status);\n      }\n    }\n    return fDecimalStr;\n}",
  "abstract_func": "CharString *Formattable::internalGetCharString(UErrorCode &VAR_0) {\n    if(VAR_1 == NULL) {\n      if (VAR_2 == NULL) {\n        /* COMMENT_0 */\n        /* COMMENT_1 */\n        /* COMMENT_2 */\n        /* COMMENT_3 */\n        /* COMMENT_4 */\n        LocalPointer<DecimalQuantity> VAR_3(new DecimalQuantity(), VAR_0);\n        if (U_FAILURE(VAR_0)) { return nullptr; }\n        populateDecimalQuantity(*VAR_3, VAR_0);\n        if (U_FAILURE(VAR_0)) { return nullptr; }\n        VAR_2 = VAR_3.orphan();\n      }\n\n      VAR_1 = new CharString();\n      if (VAR_1 == NULL) {\n        VAR_0 = VAR_4;\n        return NULL;\n      }\n      /* COMMENT_5 */\n      /* COMMENT_6 */\n      /* COMMENT_7 */\n      if (VAR_2->isZero()) {\n        VAR_1->append(\"0\", -1, VAR_0);\n      } else if (VAR_2->getMagnitude() != VAR_5 && std::abs(VAR_2->getMagnitude()) < 5) {\n        VAR_1->appendInvariantChars(VAR_2->toPlainString(), VAR_0);\n      } else {\n        VAR_1->appendInvariantChars(VAR_2->toScientificString(), VAR_0);\n      }\n    }\n    return VAR_1;\n}",
  "func_graph_path": "unicode-org/icu/53d8c8f3d181d87a6aa925b449b51c4a2c922a51/fmtable.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -23,7 +23,7 @@\n       // not print scientific notation for magnitudes greater than -5 and smaller than some amount (+5?).\n       if (fDecimalQuantity->isZero()) {\n         fDecimalStr->append(\"0\", -1, status);\n-      } else if (std::abs(fDecimalQuantity->getMagnitude()) < 5) {\n+      } else if (fDecimalQuantity->getMagnitude() != INT32_MIN && std::abs(fDecimalQuantity->getMagnitude()) < 5) {\n         fDecimalStr->appendInvariantChars(fDecimalQuantity->toPlainString(), status);\n       } else {\n         fDecimalStr->appendInvariantChars(fDecimalQuantity->toScientificString(), status);",
  "diff_line_info": {
    "deleted_lines": [
      "      } else if (std::abs(fDecimalQuantity->getMagnitude()) < 5) {"
    ],
    "added_lines": [
      "      } else if (fDecimalQuantity->getMagnitude() != INT32_MIN && std::abs(fDecimalQuantity->getMagnitude()) < 5) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/unicode-org/icu/pull/253",
  "description": {
    "pr_info": {
      "title": "ICU-20246 Fixing another integer overflow in number parsing.",
      "number": 253
    },
    "comment": [
      "<!--\r\nThank you for your pull request.\r\nPlease see http://site.icu-project.org/processes/contribute for general\r\ninformation on contributing to ICU.\r\n\r\nYou will be automatically asked to sign the contributors license before the PR is accepted.\r\n- sign: https://cla-assistant.io/unicode-org/icu\r\n- license: http://www.unicode.org/copyright.html#License\r\n-->\r\n\r\n##### Checklist\r\n\r\n- [x] Issue filed: https://unicode-org.atlassian.net/browse/ICU-20246\r\n- [x] Updated PR title and link in previous line to include Issue number\r\n- [ ] Issue accepted\r\n- [x] Tests included\r\n- [ ] Documentation is changed or added\r\n\r\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix\n\nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses an integer overflow issue in number parsing, which could lead to security vulnerabilities. The code change checks for `INT32_MIN` to prevent overflow when calculating the absolute value, mitigating a potential exploit.\n\nFinal Classification: Security Vulnerability Fix\n\nConfidence Score: 0.95"
}