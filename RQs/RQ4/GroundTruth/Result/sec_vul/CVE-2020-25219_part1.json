{
  "cve_id": "CVE-2020-25219",
  "cwe_ids": [
    "CWE-674"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "libproxy",
  "commit_msg": "Rewrite url::recvline to be nonrecursive\n\nThis function processes network input. It's semi-trusted, because the\nPAC ought to be trusted. But we still shouldn't allow it to control how\nfar we recurse. A malicious PAC can cause us to overflow the stack by\nsending a sufficiently-long line without any '\\n' character.\n\nAlso, this function failed to properly handle EINTR, so let's fix that\ntoo, for good measure.\n\nFixes #134",
  "commit_hash": "a83dae404feac517695c23ff43ce1e116e2bfbe0",
  "git_url": "https://github.com/libproxy/libproxy/commit/a83dae404feac517695c23ff43ce1e116e2bfbe0",
  "file_path": "libproxy/url.cpp",
  "func_name": "recvline",
  "func_before": "static inline string recvline(int fd) {\n\t// Read a character.\n\t// If we don't get a character, return empty string.\n\t// If we are at the end of the line, return empty string.\n\tchar c = '\\0';\n\t\n\tif (recv(fd, &c, 1, 0) != 1 || c == '\\n')\n\t\treturn \"\";\n\n\treturn string(1, c) + recvline(fd);\n}",
  "abstract_func_before": "static inline string recvline(int VAR_0) {\n\t/* COMMENT_0 */\n\t/* COMMENT_1 */\n\t/* COMMENT_2 */\n\tchar VAR_1 = '\\0';\n\t\n\tif (recv(VAR_0, &VAR_1, 1, 0) != 1 || VAR_1 == '\\n')\n\t\treturn \"\";\n\n\treturn string(1, VAR_1) + recvline(VAR_0);\n}",
  "func_graph_path_before": "libproxy/a83dae404feac517695c23ff43ce1e116e2bfbe0/url.cpp/vul/before/0.json",
  "func": "static string recvline(int fd) {\n\tstring line;\n\tint ret;\n\n\t// Reserve arbitrary amount of space to avoid small memory reallocations.\n\tline.reserve(128);\n\n\tdo {\n\t\tchar c;\n\t\tret = recv(fd, &c, 1, 0);\n\t\tif (ret == 1) {\n\t\t\tif (c == '\\n')\n\t\t\t\treturn line;\n\t\t\tline += c;\n\t\t}\n\t} while (ret == 1 || (ret == -1 && errno == EINTR));\n\n\treturn line;\n}",
  "abstract_func": "static string recvline(int VAR_0) {\n\tstring VAR_1;\n\tint VAR_2;\n\n\t/* COMMENT_0 */\n\tVAR_1.reserve(128);\n\n\tdo {\n\t\tchar VAR_3;\n\t\tVAR_2 = recv(VAR_0, &VAR_3, 1, 0);\n\t\tif (VAR_2 == 1) {\n\t\t\tif (VAR_3 == '\\n')\n\t\t\t\treturn VAR_1;\n\t\t\tVAR_1 += VAR_3;\n\t\t}\n\t} while (VAR_2 == 1 || (VAR_2 == -1 && VAR_4 == VAR_5));\n\n\treturn VAR_1;\n}",
  "func_graph_path": "libproxy/a83dae404feac517695c23ff43ce1e116e2bfbe0/url.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -1,11 +1,19 @@\n-static inline string recvline(int fd) {\n-\t// Read a character.\n-\t// If we don't get a character, return empty string.\n-\t// If we are at the end of the line, return empty string.\n-\tchar c = '\\0';\n-\t\n-\tif (recv(fd, &c, 1, 0) != 1 || c == '\\n')\n-\t\treturn \"\";\n+static string recvline(int fd) {\n+\tstring line;\n+\tint ret;\n \n-\treturn string(1, c) + recvline(fd);\n+\t// Reserve arbitrary amount of space to avoid small memory reallocations.\n+\tline.reserve(128);\n+\n+\tdo {\n+\t\tchar c;\n+\t\tret = recv(fd, &c, 1, 0);\n+\t\tif (ret == 1) {\n+\t\t\tif (c == '\\n')\n+\t\t\t\treturn line;\n+\t\t\tline += c;\n+\t\t}\n+\t} while (ret == 1 || (ret == -1 && errno == EINTR));\n+\n+\treturn line;\n }",
  "diff_line_info": {
    "deleted_lines": [
      "static inline string recvline(int fd) {",
      "\t// Read a character.",
      "\t// If we don't get a character, return empty string.",
      "\t// If we are at the end of the line, return empty string.",
      "\tchar c = '\\0';",
      "\t",
      "\tif (recv(fd, &c, 1, 0) != 1 || c == '\\n')",
      "\t\treturn \"\";",
      "\treturn string(1, c) + recvline(fd);"
    ],
    "added_lines": [
      "static string recvline(int fd) {",
      "\tstring line;",
      "\tint ret;",
      "\t// Reserve arbitrary amount of space to avoid small memory reallocations.",
      "\tline.reserve(128);",
      "",
      "\tdo {",
      "\t\tchar c;",
      "\t\tret = recv(fd, &c, 1, 0);",
      "\t\tif (ret == 1) {",
      "\t\t\tif (c == '\\n')",
      "\t\t\t\treturn line;",
      "\t\t\tline += c;",
      "\t\t}",
      "\t} while (ret == 1 || (ret == -1 && errno == EINTR));",
      "",
      "\treturn line;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libproxy/libproxy/pull/136",
  "description": {
    "pr_info": {
      "title": "Rewrite url::recvline to be nonrecursive",
      "number": 136
    },
    "comment": [
      "This function processes network input. It's semi-trusted, because the\r\nPAC ought to be trusted. But we still shouldn't allow it to control how\r\nfar we recurse. A malicious PAC can cause us to overflow the stack by\r\nsending a sufficiently-long line without any '\\n' character.\r\n\r\nAlso, this function failed to properly handle EINTR, so let's fix that\r\ntoo, for good measure.\r\n\r\nFixes #134"
    ]
  },
  "Bug Filter": "** Security Vulnerability Fix  \n**Confidence Score:** 1.0",
  "Bug Filter Confidence": 1.0,
  "Bug Filter Response": "\n\nThe patch addresses a security vulnerability by preventing stack overflow and handling EINTR correctly.\n\n**Final Classification:** Security Vulnerability Fix  \n**Confidence Score:** 1.0"
}