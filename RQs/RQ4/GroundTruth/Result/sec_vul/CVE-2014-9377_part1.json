{
  "cve_id": "CVE-2014-9377",
  "cwe_ids": [
    "CWE-119"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
  "cvss_is_v3": false,
  "repo_name": "Ettercap/ettercap",
  "commit_msg": "Fix nbns arbitary length heap overflow",
  "commit_hash": "3f0c582826095c722ab6fbf91518282a765a0b68",
  "git_url": "https://github.com/Ettercap/ettercap/commit/3f0c582826095c722ab6fbf91518282a765a0b68",
  "file_path": "plug-ins/nbns_spoof/nbns_spoof.c",
  "func_name": "nbns_spoof",
  "func_before": "static void nbns_spoof(struct packet_object *po)\n{\n\tstruct nbns_query *nbns;\n\tstruct nbns_header *header;\n\tchar name[NBNS_DECODED_NAME_LEN];\n\n\t//header = (struct nbns_header *)po->DATA.data;\n\tnbns =  (struct nbns_query *)po->DATA.data;\n\theader = (struct nbns_header *)&nbns->header;\n\n\tif (header->response) {\n\t\t/* We only want queries */\n\t\treturn;\n\t}\n\n\tif (ntohs(nbns->class) != CLASS_IN || ntohs(nbns->type) != TYPE_NB) {\n\t\t/* We only handle internet class and NB type */\n\t\treturn;\n\t}\n\n\n\tmemset(name, '\\0', NBNS_DECODED_NAME_LEN);\n\tnbns_expand(nbns->question, name);\n\n\tstruct ip_addr *reply;\n\tchar tmp[MAX_ASCII_ADDR_LEN];\n\n\tif (get_spoofed_nbns(name, &reply) != E_SUCCESS)\n\t\treturn;\n\n\tu_char *response;\n\n\tSAFE_CALLOC(response, NBNS_MSGLEN_QUERY_RESPONSE, sizeof(u_char));\n\n\tmemset(response, 0, NBNS_MSGLEN_QUERY_RESPONSE);\n\n\tmemcpy(response, po->DATA.data, po->DATA.len);\n\n\tstruct nbns_header *hdr = (struct nbns_header*)response;\n\n\thdr->response = 1;\n\thdr->opcode = ntohs(OPCODE_R+OPCODE_QUERY);\n\thdr->rcode = ntohs(0);\n\thdr->broadcast = ntohs(0);\n\thdr->an_count = ntohs(1);\n\thdr->qd_count = ntohs(0);\n\thdr->ra = 0;\n\thdr->rd = 0;\n\thdr->tc = 0;\n\thdr->aa = 1;\n\thdr->ns_count = ntohs(0);\n\thdr->ar_count = ntohs(0); \n\thdr->transactid = header->transactid;\n\n\tu_int16 *ttl1 = (u_int16*)(response+NBNS_TTL_POS);\n\tu_int16 *ttl2 = (u_int16*)(response+NBNS_TTL_POS+2);\n\n\t*ttl1 = ntohs(0);\n\t*ttl2 = ntohs(0);\n\n\tstruct nbns_rdata *rdata = (struct nbns_rdata *) (response+NBNS_RDATA_POS);\n\n\trdata->len = ntohs(2+sizeof(u_int32));\n\trdata->nbflags = ntohs(0x0000);\n\trdata->addr = *reply->addr32;\n\t\n\t/* send fake reply */\n\tsend_udp(&GBL_IFACE->ip, &po->L3.src, po->L2.src, po->L4.dst, po->L4.src, response, NBNS_MSGLEN_QUERY_RESPONSE);\n\tUSER_MSG(\"nbns_spoof: Query [%s] spoofed to [%s]\\n\", name, ip_addr_ntoa(reply, tmp));\n\n\t/* Do not forward request */\n\tpo->flags |= PO_DROPPED;\n\n\tSAFE_FREE(response);\n\t\n}",
  "abstract_func_before": "static void nbns_spoof(struct packet_object *VAR_0)\n{\n\tstruct nbns_query *VAR_1;\n\tstruct nbns_header *VAR_2;\n\tchar VAR_3[VAR_4];\n\n\t/* COMMENT_0 */\n\tVAR_1 =  (struct nbns_query *)VAR_0->DATA.data;\n\tVAR_2 = (struct nbns_header *)&VAR_1->header;\n\n\tif (VAR_2->response) {\n\t\t/* COMMENT_1 */\n\t\treturn;\n\t}\n\n\tif (ntohs(VAR_1->class) != VAR_5 || ntohs(VAR_1->type) != VAR_6) {\n\t\t/* COMMENT_2 */\n\t\treturn;\n\t}\n\n\n\tmemset(VAR_3, '\\0', VAR_4);\n\tnbns_expand(VAR_1->question, VAR_3);\n\n\tstruct ip_addr *VAR_7;\n\tchar VAR_8[VAR_9];\n\n\tif (get_spoofed_nbns(VAR_3, &VAR_7) != VAR_10)\n\t\treturn;\n\n\tu_char *VAR_11;\n\n\tSAFE_CALLOC(VAR_11, VAR_12, sizeof(u_char));\n\n\tmemset(VAR_11, 0, VAR_12);\n\n\tmemcpy(VAR_11, VAR_0->DATA.data, VAR_0->DATA.len);\n\n\tstruct nbns_header *VAR_13 = (struct nbns_header*)VAR_11;\n\n\tVAR_13->response = 1;\n\tVAR_13->opcode = ntohs(VAR_14+VAR_15);\n\tVAR_13->rcode = ntohs(0);\n\tVAR_13->broadcast = ntohs(0);\n\tVAR_13->an_count = ntohs(1);\n\tVAR_13->qd_count = ntohs(0);\n\tVAR_13->ra = 0;\n\tVAR_13->rd = 0;\n\tVAR_13->tc = 0;\n\tVAR_13->aa = 1;\n\tVAR_13->ns_count = ntohs(0);\n\tVAR_13->ar_count = ntohs(0); \n\tVAR_13->transactid = VAR_2->transactid;\n\n\tu_int16 *VAR_16 = (u_int16*)(VAR_11+VAR_17);\n\tu_int16 *VAR_18 = (u_int16*)(VAR_11+VAR_17+2);\n\n\t*VAR_16 = ntohs(0);\n\t*VAR_18 = ntohs(0);\n\n\tstruct nbns_rdata *VAR_19 = (struct nbns_rdata *) (VAR_11+VAR_20);\n\n\tVAR_19->len = ntohs(2+sizeof(VAR_21));\n\tVAR_19->nbflags = ntohs(0x0000);\n\tVAR_19->addr = *VAR_7->addr32;\n\t\n\t/* COMMENT_3 */\n\tsend_udp(&VAR_22->ip, &VAR_0->L3.src, VAR_0->L2.src, VAR_0->L4.dst, VAR_0->L4.src, VAR_11, VAR_12);\n\tUSER_MSG(\"nbns_spoof: Query [%s] spoofed to [%s]\\n\", VAR_3, ip_addr_ntoa(VAR_7, VAR_8));\n\n\t/* COMMENT_4 */\n\tVAR_0->flags |= VAR_23;\n\n\tSAFE_FREE(VAR_11);\n\t\n}",
  "func_graph_path_before": "Ettercap/ettercap/3f0c582826095c722ab6fbf91518282a765a0b68/nbns_spoof.c/vul/before/0.json",
  "func": "static void nbns_spoof(struct packet_object *po)\n{\n\tstruct nbns_query *nbns;\n\tstruct nbns_header *header;\n\tchar name[NBNS_DECODED_NAME_LEN];\n\n\t//header = (struct nbns_header *)po->DATA.data;\n\tnbns =  (struct nbns_query *)po->DATA.data;\n\theader = (struct nbns_header *)&nbns->header;\n\n\tif (header->response) {\n\t\t/* We only want queries */\n\t\treturn;\n\t}\n\n\tif (ntohs(nbns->class) != CLASS_IN || ntohs(nbns->type) != TYPE_NB) {\n\t\t/* We only handle internet class and NB type */\n\t\treturn;\n\t}\n\n\n\tmemset(name, '\\0', NBNS_DECODED_NAME_LEN);\n\tnbns_expand(nbns->question, name);\n\n\tstruct ip_addr *reply;\n\tchar tmp[MAX_ASCII_ADDR_LEN];\n\n\tif (get_spoofed_nbns(name, &reply) != E_SUCCESS)\n\t\treturn;\n\n\tu_char *response;\n\n\tSAFE_CALLOC(response, NBNS_MSGLEN_QUERY_RESPONSE, sizeof(u_char));\n\n   if (po->DATA.len > 70) {\n       SAFE_FREE(response);\n       return;\n   }\n\tmemset(response, 0, NBNS_MSGLEN_QUERY_RESPONSE);\n\n\tmemcpy(response, po->DATA.data, po->DATA.len);\n\n\tstruct nbns_header *hdr = (struct nbns_header*)response;\n\n\thdr->response = 1;\n\thdr->opcode = ntohs(OPCODE_R+OPCODE_QUERY);\n\thdr->rcode = ntohs(0);\n\thdr->broadcast = ntohs(0);\n\thdr->an_count = ntohs(1);\n\thdr->qd_count = ntohs(0);\n\thdr->ra = 0;\n\thdr->rd = 0;\n\thdr->tc = 0;\n\thdr->aa = 1;\n\thdr->ns_count = ntohs(0);\n\thdr->ar_count = ntohs(0); \n\thdr->transactid = header->transactid;\n\n\tu_int16 *ttl1 = (u_int16*)(response+NBNS_TTL_POS);\n\tu_int16 *ttl2 = (u_int16*)(response+NBNS_TTL_POS+2);\n\n\t*ttl1 = ntohs(0);\n\t*ttl2 = ntohs(0);\n\n\tstruct nbns_rdata *rdata = (struct nbns_rdata *) (response+NBNS_RDATA_POS);\n\n\trdata->len = ntohs(2+sizeof(u_int32));\n\trdata->nbflags = ntohs(0x0000);\n\trdata->addr = *reply->addr32;\n\t\n\t/* send fake reply */\n\tsend_udp(&GBL_IFACE->ip, &po->L3.src, po->L2.src, po->L4.dst, po->L4.src, response, NBNS_MSGLEN_QUERY_RESPONSE);\n\tUSER_MSG(\"nbns_spoof: Query [%s] spoofed to [%s]\\n\", name, ip_addr_ntoa(reply, tmp));\n\n\t/* Do not forward request */\n\tpo->flags |= PO_DROPPED;\n\n\tSAFE_FREE(response);\n\t\n}",
  "abstract_func": "static void nbns_spoof(struct packet_object *VAR_0)\n{\n\tstruct nbns_query *VAR_1;\n\tstruct nbns_header *VAR_2;\n\tchar VAR_3[VAR_4];\n\n\t/* COMMENT_0 */\n\tVAR_1 =  (struct nbns_query *)VAR_0->DATA.data;\n\tVAR_2 = (struct nbns_header *)&VAR_1->header;\n\n\tif (VAR_2->response) {\n\t\t/* COMMENT_1 */\n\t\treturn;\n\t}\n\n\tif (ntohs(VAR_1->class) != VAR_5 || ntohs(VAR_1->type) != VAR_6) {\n\t\t/* COMMENT_2 */\n\t\treturn;\n\t}\n\n\n\tmemset(VAR_3, '\\0', VAR_4);\n\tnbns_expand(VAR_1->question, VAR_3);\n\n\tstruct ip_addr *VAR_7;\n\tchar VAR_8[VAR_9];\n\n\tif (get_spoofed_nbns(VAR_3, &VAR_7) != VAR_10)\n\t\treturn;\n\n\tu_char *VAR_11;\n\n\tSAFE_CALLOC(VAR_11, VAR_12, sizeof(u_char));\n\n   if (VAR_0->DATA.len > 70) {\n       SAFE_FREE(VAR_11);\n       return;\n   }\n\tmemset(VAR_11, 0, VAR_12);\n\n\tmemcpy(VAR_11, VAR_0->DATA.data, VAR_0->DATA.len);\n\n\tstruct nbns_header *VAR_13 = (struct nbns_header*)VAR_11;\n\n\tVAR_13->response = 1;\n\tVAR_13->opcode = ntohs(VAR_14+VAR_15);\n\tVAR_13->rcode = ntohs(0);\n\tVAR_13->broadcast = ntohs(0);\n\tVAR_13->an_count = ntohs(1);\n\tVAR_13->qd_count = ntohs(0);\n\tVAR_13->ra = 0;\n\tVAR_13->rd = 0;\n\tVAR_13->tc = 0;\n\tVAR_13->aa = 1;\n\tVAR_13->ns_count = ntohs(0);\n\tVAR_13->ar_count = ntohs(0); \n\tVAR_13->transactid = VAR_2->transactid;\n\n\tu_int16 *VAR_16 = (u_int16*)(VAR_11+VAR_17);\n\tu_int16 *VAR_18 = (u_int16*)(VAR_11+VAR_17+2);\n\n\t*VAR_16 = ntohs(0);\n\t*VAR_18 = ntohs(0);\n\n\tstruct nbns_rdata *VAR_19 = (struct nbns_rdata *) (VAR_11+VAR_20);\n\n\tVAR_19->len = ntohs(2+sizeof(VAR_21));\n\tVAR_19->nbflags = ntohs(0x0000);\n\tVAR_19->addr = *VAR_7->addr32;\n\t\n\t/* COMMENT_3 */\n\tsend_udp(&VAR_22->ip, &VAR_0->L3.src, VAR_0->L2.src, VAR_0->L4.dst, VAR_0->L4.src, VAR_11, VAR_12);\n\tUSER_MSG(\"nbns_spoof: Query [%s] spoofed to [%s]\\n\", VAR_3, ip_addr_ntoa(VAR_7, VAR_8));\n\n\t/* COMMENT_4 */\n\tVAR_0->flags |= VAR_23;\n\n\tSAFE_FREE(VAR_11);\n\t\n}",
  "func_graph_path": "Ettercap/ettercap/3f0c582826095c722ab6fbf91518282a765a0b68/nbns_spoof.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -32,6 +32,10 @@\n \n \tSAFE_CALLOC(response, NBNS_MSGLEN_QUERY_RESPONSE, sizeof(u_char));\n \n+   if (po->DATA.len > 70) {\n+       SAFE_FREE(response);\n+       return;\n+   }\n \tmemset(response, 0, NBNS_MSGLEN_QUERY_RESPONSE);\n \n \tmemcpy(response, po->DATA.data, po->DATA.len);",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "   if (po->DATA.len > 70) {",
      "       SAFE_FREE(response);",
      "       return;",
      "   }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/Ettercap/ettercap/pull/603",
  "description": {
    "pr_info": {
      "title": "Fix nbns arbitary length heap overflow",
      "number": 603
    },
    "comment": [
      "nbns_spoof plugin is vulnerable to heap overflow attack, because the length of netbios packet is used as parameter in memcpy\n"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses a buffer overflow vulnerability in the nbns_spoof function by adding a check to prevent copying data beyond the allocated buffer size, thus mitigating a potential heap overflow.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 0.95"
}