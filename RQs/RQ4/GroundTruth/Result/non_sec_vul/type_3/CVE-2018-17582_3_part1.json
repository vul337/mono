{
  "cve_id": "CVE-2018-17582",
  "cwe_ids": [
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:P/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "appneta/tcpreplay",
  "commit_msg": "Bug #484 CVE-2018-17582 Check for corrupt PCAP files\n\n* Check for packets that are larger than 262144 bytes\n* Check for capture lengths that are greater than packet length\n\nExample of a corrupt PCAP file ...\n\nsudo src/tcpreplay -i ens33 --unique-ip -t --loop 4 get_next_paket_01\nsafe_pcap_next ERROR: Invalid packet length in send_packets.c:get_next_packet() line 1054: 8388670 is greater than maximum 262144",
  "commit_hash": "68f67b1a3a4d319543692afb5bd5b191ec984287",
  "git_url": "https://github.com/appneta/tcpreplay/commit/68f67b1a3a4d319543692afb5bd5b191ec984287",
  "file_path": "src/common/utils.c",
  "func_name": "_our_safe_malloc",
  "func_before": "void *\n_our_safe_malloc(size_t len, const char *funcname, const int line, const char *file)\n{\n    u_char *ptr;\n\n    if ((ptr = malloc(len)) == NULL) {\n        fprintf(stderr, \"ERROR in %s:%s() line %d: Unable to malloc() %zu bytes\", file, funcname, line, len);\n        exit(-1);\n    }\n\n    /* zero memory */\n    memset(ptr, 0, len);\n\n    /* wrapped inside an #ifdef for better performance */\n    dbgx(5, \"Malloc'd %zu bytes in %s:%s() line %d\", len, file, funcname, line);\n\n    return (void *)ptr;\n}",
  "abstract_func_before": "void *\n_our_safe_malloc(size_t VAR_0, const char *VAR_1, const int VAR_2, const char *VAR_3)\n{\n    u_char *VAR_4;\n\n    if ((VAR_4 = malloc(VAR_0)) == NULL) {\n        fprintf(VAR_5, \"ERROR in %s:%s() line %d: Unable to malloc() %zu bytes\", VAR_3, VAR_1, VAR_2, VAR_0);\n        exit(-1);\n    }\n\n    /* COMMENT_0 */\n    memset(VAR_4, 0, VAR_0);\n\n    /* COMMENT_1 */\n    dbgx(5, \"Malloc'd %zu bytes in %s:%s() line %d\", VAR_0, VAR_3, VAR_1, VAR_2);\n\n    return (void *)VAR_4;\n}",
  "func_graph_path_before": "appneta/tcpreplay/68f67b1a3a4d319543692afb5bd5b191ec984287/utils.c/vul/before/0.json",
  "func": "void *\n_our_safe_malloc(size_t len, const char *funcname, const int line, const char *file)\n{\n    u_char *ptr;\n\n    if ((ptr = malloc(len)) == NULL) {\n        fprintf(stderr, \"ERROR in %s:%s() line %d: Unable to malloc() %zu bytes/n\",\n                file, funcname, line, len);\n        exit(-1);\n    }\n\n    /* zero memory */\n    memset(ptr, 0, len);\n\n    /* wrapped inside an #ifdef for better performance */\n    dbgx(5, \"Malloc'd %zu bytes in %s:%s() line %d\", len, file, funcname, line);\n\n    return (void *)ptr;\n}",
  "abstract_func": "void *\n_our_safe_malloc(size_t VAR_0, const char *VAR_1, const int VAR_2, const char *VAR_3)\n{\n    u_char *VAR_4;\n\n    if ((VAR_4 = malloc(VAR_0)) == NULL) {\n        fprintf(VAR_5, \"ERROR in %s:%s() line %d: Unable to malloc() %zu bytes/n\",\n                VAR_3, VAR_1, VAR_2, VAR_0);\n        exit(-1);\n    }\n\n    /* COMMENT_0 */\n    memset(VAR_4, 0, VAR_0);\n\n    /* COMMENT_1 */\n    dbgx(5, \"Malloc'd %zu bytes in %s:%s() line %d\", VAR_0, VAR_3, VAR_1, VAR_2);\n\n    return (void *)VAR_4;\n}",
  "func_graph_path": "appneta/tcpreplay/68f67b1a3a4d319543692afb5bd5b191ec984287/utils.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -4,7 +4,8 @@\n     u_char *ptr;\n \n     if ((ptr = malloc(len)) == NULL) {\n-        fprintf(stderr, \"ERROR in %s:%s() line %d: Unable to malloc() %zu bytes\", file, funcname, line, len);\n+        fprintf(stderr, \"ERROR in %s:%s() line %d: Unable to malloc() %zu bytes/n\",\n+                file, funcname, line, len);\n         exit(-1);\n     }\n ",
  "diff_line_info": {
    "deleted_lines": [
      "        fprintf(stderr, \"ERROR in %s:%s() line %d: Unable to malloc() %zu bytes\", file, funcname, line, len);"
    ],
    "added_lines": [
      "        fprintf(stderr, \"ERROR in %s:%s() line %d: Unable to malloc() %zu bytes/n\",",
      "                file, funcname, line, len);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/appneta/tcpreplay/pull/491",
  "description": {
    "pr_info": {
      "title": "Bug #484 CVE-2018-17582 Check for corrupt PCAP files",
      "number": 491
    },
    "comment": [
      "* Check for packets that are larger than 262144 bytes\r\n* Check for capture lengths that are greater than packet length\r\n\r\nExample of a corrupt PCAP file ...\r\n\r\nsudo src/tcpreplay -i ens33 --unique-ip -t --loop 4 get_next_paket_01\r\nsafe_pcap_next ERROR: Invalid packet length in send_packets.c:get_next_packet() line 1054: 8388670 is greater than maximum 262144"
    ]
  },
  "Bug Filter": "Supporting & Non-Core Improvements",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "\n\nThe patch modifies error message formatting without adding security checks, despite the commit message suggesting a security fix. It doesn't address a security vulnerability.\n\n**Final Classification:** Supporting & Non-Core Improvements  \n**Confidence Score:** 0.9"
}