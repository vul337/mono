{
  "cve_id": "CVE-2022-21700",
  "cwe_ids": [
    "CWE-400"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "micronaut-projects/micronaut-core",
  "commit_msg": "Use ConversionContext constants where possible instead of class (#2356)\n\nChanges\r\n-------\r\n * Added ArgumentConversionContext constants in ConversionContext\r\n * Replaced Argument.of and use of argument classes with\r\nConversionContext constants where possible\r\n * Added getFirst method in ConvertibleMultiValues that accepts\r\nArgumentConversionContent parameter\r\n\r\nPartially addresses issue #2355",
  "commit_hash": "b8ec32c311689667c69ae7d9f9c3b3a8abc96fe3",
  "git_url": "https://github.com/micronaut-projects/micronaut-core/commit/b8ec32c311689667c69ae7d9f9c3b3a8abc96fe3",
  "file_path": "runtime/src/main/java/io/micronaut/cache/interceptor/CacheInterceptor.java",
  "func_name": "buildCacheablePublisher",
  "func_before": "private Publisher<Object> buildCacheablePublisher(\n            MethodInvocationContext<Object, Object> context,\n            ReturnType returnTypeObject,\n            CacheOperation cacheOperation,\n            AnnotationValue<Cacheable> cacheable) {\n        AsyncCache<?> asyncCache = cacheManager.getCache(cacheOperation.cacheableCacheName).async();\n        CacheKeyGenerator keyGenerator = resolveKeyGenerator(cacheOperation.defaultKeyGenerator, cacheable);\n        Object[] params = resolveParams(context, cacheable.get(MEMBER_PARAMETERS, String[].class, StringUtils.EMPTY_STRING_ARRAY));\n        Object key = keyGenerator.generateKey(context, params);\n        Argument<?> firstTypeVariable = returnTypeObject.getFirstTypeVariable().orElse(Argument.of(Object.class));\n\n        Maybe<Object> maybe = Maybe.create(emitter -> {\n            asyncCache.get(key, firstTypeVariable).whenComplete((opt, throwable) -> {\n               if (throwable != null) {\n                   if (errorHandler.handleLoadError(asyncCache, key, asRuntimeException(throwable))) {\n                       emitter.onError(throwable);\n                   } else {\n                       emitter.onComplete();\n                   }\n                   emitter.onError(throwable);\n               } else if (opt.isPresent()) {\n                   if (LOG.isDebugEnabled()) {\n                       LOG.debug(\"Value found in cache [\" + asyncCache.getName() + \"] for invocation: \" + context);\n                   }\n                   emitter.onSuccess(opt.get());\n               } else {\n                   emitter.onComplete();\n               }\n            });\n        });\n\n        return maybe.isEmpty().flatMapPublisher(empty -> {\n            if (empty) {\n               return Publishers.convertPublisher(\n                       context.proceed(), Flowable.class)\n                       .flatMap(o -> {\n                           return Single.create(emitter -> {\n                               asyncCache.put(key, o).whenComplete((aBoolean, throwable1) -> {\n                                   if (throwable1 == null) {\n                                       emitter.onSuccess(o);\n                                   } else {\n                                       if (errorHandler.handleLoadError(asyncCache, key, asRuntimeException(throwable1))) {\n\n                                           emitter.onError(throwable1);\n                                       } else {\n                                           emitter.onSuccess(o);\n                                       }\n                                   }\n                               });\n                           }).toFlowable();\n                       });\n            } else {\n                return maybe.toFlowable();\n            }\n        });\n    }",
  "abstract_func_before": "private Publisher<Object> buildCacheablePublisher(\n            MethodInvocationContext<Object, Object> VAR_0,\n            ReturnType VAR_1,\n            CacheOperation VAR_2,\n            AnnotationValue<Cacheable> VAR_3) {\n        AsyncCache<?> VAR_4 = VAR_5.getCache(VAR_2.cacheableCacheName).async();\n        CacheKeyGenerator VAR_6 = resolveKeyGenerator(VAR_2.defaultKeyGenerator, VAR_3);\n        Object[] VAR_7 = resolveParams(VAR_0, VAR_3.get(VAR_8, String[].class, VAR_9.EMPTY_STRING_ARRAY));\n        Object VAR_10 = VAR_6.generateKey(VAR_0, VAR_7);\n        Argument<?> VAR_11 = VAR_1.getFirstTypeVariable().orElse(VAR_12.of(Object.class));\n\n        Maybe<Object> VAR_13 = VAR_14.create(VAR_15 -> {\n            VAR_4.get(VAR_10, VAR_11).whenComplete((VAR_16, VAR_17) -> {\n               if (VAR_17 != null) {\n                   if (VAR_18.handleLoadError(VAR_4, VAR_10, asRuntimeException(VAR_17))) {\n                       VAR_15.onError(VAR_17);\n                   } else {\n                       VAR_15.onComplete();\n                   }\n                   VAR_15.onError(VAR_17);\n               } else if (VAR_16.isPresent()) {\n                   if (VAR_19.isDebugEnabled()) {\n                       VAR_19.debug(\"Value found in cache [\" + VAR_4.getName() + \"] for invocation: \" + VAR_0);\n                   }\n                   VAR_15.onSuccess(VAR_16.get());\n               } else {\n                   VAR_15.onComplete();\n               }\n            });\n        });\n\n        return VAR_13.isEmpty().flatMapPublisher(VAR_20 -> {\n            if (VAR_20) {\n               return VAR_21.convertPublisher(\n                       VAR_0.proceed(), Flowable.class)\n                       .flatMap(VAR_22 -> {\n                           return VAR_23.create(VAR_15 -> {\n                               VAR_4.put(VAR_10, VAR_22).whenComplete((VAR_24, VAR_25) -> {\n                                   if (VAR_25 == null) {\n                                       VAR_15.onSuccess(VAR_22);\n                                   } else {\n                                       if (VAR_18.handleLoadError(VAR_4, VAR_10, asRuntimeException(VAR_25))) {\n\n                                           VAR_15.onError(VAR_25);\n                                       } else {\n                                           VAR_15.onSuccess(VAR_22);\n                                       }\n                                   }\n                               });\n                           }).toFlowable();\n                       });\n            } else {\n                return VAR_13.toFlowable();\n            }\n        });\n    }",
  "func_graph_path_before": "micronaut-projects/micronaut-core/b8ec32c311689667c69ae7d9f9c3b3a8abc96fe3/CacheInterceptor.java/vul/before/0.json",
  "func": "private Publisher<Object> buildCacheablePublisher(\n            MethodInvocationContext<Object, Object> context,\n            ReturnType returnTypeObject,\n            CacheOperation cacheOperation,\n            AnnotationValue<Cacheable> cacheable) {\n        AsyncCache<?> asyncCache = cacheManager.getCache(cacheOperation.cacheableCacheName).async();\n        CacheKeyGenerator keyGenerator = resolveKeyGenerator(cacheOperation.defaultKeyGenerator, cacheable);\n        Object[] params = resolveParams(context, cacheable.get(MEMBER_PARAMETERS, String[].class, StringUtils.EMPTY_STRING_ARRAY));\n        Object key = keyGenerator.generateKey(context, params);\n        Argument<?> firstTypeVariable = returnTypeObject.getFirstTypeVariable().orElse(Argument.OBJECT_ARGUMENT);\n\n        Maybe<Object> maybe = Maybe.create(emitter -> {\n            asyncCache.get(key, firstTypeVariable).whenComplete((opt, throwable) -> {\n               if (throwable != null) {\n                   if (errorHandler.handleLoadError(asyncCache, key, asRuntimeException(throwable))) {\n                       emitter.onError(throwable);\n                   } else {\n                       emitter.onComplete();\n                   }\n                   emitter.onError(throwable);\n               } else if (opt.isPresent()) {\n                   if (LOG.isDebugEnabled()) {\n                       LOG.debug(\"Value found in cache [\" + asyncCache.getName() + \"] for invocation: \" + context);\n                   }\n                   emitter.onSuccess(opt.get());\n               } else {\n                   emitter.onComplete();\n               }\n            });\n        });\n\n        return maybe.isEmpty().flatMapPublisher(empty -> {\n            if (empty) {\n               return Publishers.convertPublisher(\n                       context.proceed(), Flowable.class)\n                       .flatMap(o -> {\n                           return Single.create(emitter -> {\n                               asyncCache.put(key, o).whenComplete((aBoolean, throwable1) -> {\n                                   if (throwable1 == null) {\n                                       emitter.onSuccess(o);\n                                   } else {\n                                       if (errorHandler.handleLoadError(asyncCache, key, asRuntimeException(throwable1))) {\n\n                                           emitter.onError(throwable1);\n                                       } else {\n                                           emitter.onSuccess(o);\n                                       }\n                                   }\n                               });\n                           }).toFlowable();\n                       });\n            } else {\n                return maybe.toFlowable();\n            }\n        });\n    }",
  "abstract_func": "private Publisher<Object> buildCacheablePublisher(\n            MethodInvocationContext<Object, Object> VAR_0,\n            ReturnType VAR_1,\n            CacheOperation VAR_2,\n            AnnotationValue<Cacheable> VAR_3) {\n        AsyncCache<?> VAR_4 = VAR_5.getCache(VAR_2.cacheableCacheName).async();\n        CacheKeyGenerator VAR_6 = resolveKeyGenerator(VAR_2.defaultKeyGenerator, VAR_3);\n        Object[] VAR_7 = resolveParams(VAR_0, VAR_3.get(VAR_8, String[].class, VAR_9.EMPTY_STRING_ARRAY));\n        Object VAR_10 = VAR_6.generateKey(VAR_0, VAR_7);\n        Argument<?> VAR_11 = VAR_1.getFirstTypeVariable().orElse(VAR_12.OBJECT_ARGUMENT);\n\n        Maybe<Object> VAR_13 = VAR_14.create(VAR_15 -> {\n            VAR_4.get(VAR_10, VAR_11).whenComplete((VAR_16, VAR_17) -> {\n               if (VAR_17 != null) {\n                   if (VAR_18.handleLoadError(VAR_4, VAR_10, asRuntimeException(VAR_17))) {\n                       VAR_15.onError(VAR_17);\n                   } else {\n                       VAR_15.onComplete();\n                   }\n                   VAR_15.onError(VAR_17);\n               } else if (VAR_16.isPresent()) {\n                   if (VAR_19.isDebugEnabled()) {\n                       VAR_19.debug(\"Value found in cache [\" + VAR_4.getName() + \"] for invocation: \" + VAR_0);\n                   }\n                   VAR_15.onSuccess(VAR_16.get());\n               } else {\n                   VAR_15.onComplete();\n               }\n            });\n        });\n\n        return VAR_13.isEmpty().flatMapPublisher(VAR_20 -> {\n            if (VAR_20) {\n               return VAR_21.convertPublisher(\n                       VAR_0.proceed(), Flowable.class)\n                       .flatMap(VAR_22 -> {\n                           return VAR_23.create(VAR_15 -> {\n                               VAR_4.put(VAR_10, VAR_22).whenComplete((VAR_24, VAR_25) -> {\n                                   if (VAR_25 == null) {\n                                       VAR_15.onSuccess(VAR_22);\n                                   } else {\n                                       if (VAR_18.handleLoadError(VAR_4, VAR_10, asRuntimeException(VAR_25))) {\n\n                                           VAR_15.onError(VAR_25);\n                                       } else {\n                                           VAR_15.onSuccess(VAR_22);\n                                       }\n                                   }\n                               });\n                           }).toFlowable();\n                       });\n            } else {\n                return VAR_13.toFlowable();\n            }\n        });\n    }",
  "func_graph_path": "micronaut-projects/micronaut-core/b8ec32c311689667c69ae7d9f9c3b3a8abc96fe3/CacheInterceptor.java/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -7,7 +7,7 @@\n         CacheKeyGenerator keyGenerator = resolveKeyGenerator(cacheOperation.defaultKeyGenerator, cacheable);\n         Object[] params = resolveParams(context, cacheable.get(MEMBER_PARAMETERS, String[].class, StringUtils.EMPTY_STRING_ARRAY));\n         Object key = keyGenerator.generateKey(context, params);\n-        Argument<?> firstTypeVariable = returnTypeObject.getFirstTypeVariable().orElse(Argument.of(Object.class));\n+        Argument<?> firstTypeVariable = returnTypeObject.getFirstTypeVariable().orElse(Argument.OBJECT_ARGUMENT);\n \n         Maybe<Object> maybe = Maybe.create(emitter -> {\n             asyncCache.get(key, firstTypeVariable).whenComplete((opt, throwable) -> {",
  "diff_line_info": {
    "deleted_lines": [
      "        Argument<?> firstTypeVariable = returnTypeObject.getFirstTypeVariable().orElse(Argument.of(Object.class));"
    ],
    "added_lines": [
      "        Argument<?> firstTypeVariable = returnTypeObject.getFirstTypeVariable().orElse(Argument.OBJECT_ARGUMENT);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/micronaut-projects/micronaut-core/pull/2356",
  "description": {
    "pr_info": {
      "title": "Use Argument constants where possible instead of class",
      "number": 2356
    },
    "comment": [
      "Changes\r\n-------\r\n * Added ArgumentConversionContext constants in ConversionContext\r\n * Replaced Argument.of and use of argument classes with\r\nConversionContext constants where possible\r\n * Added getFirst method in ConvertibleMultiValues that accepts\r\nArgumentConversionContent parameter\r\n\r\nPartially addresses issue #2355",
      "Nice progress"
    ]
  },
  "Bug Filter": "Supporting & Non-Core Improvements",
  "Bug Filter Confidence": 0.95,
  "Bug Filter Response": "\n\n**Final Output:**\nAnalysis: The patch involves refactoring code to use constants instead of direct method calls, improving code readability and maintainability without addressing any security issues or functional defects. The changes are non-functional and aimed at code structure improvements.\n\nFinal Classification: Supporting & Non-Core Improvements  \nConfidence Score: 0.95"
}