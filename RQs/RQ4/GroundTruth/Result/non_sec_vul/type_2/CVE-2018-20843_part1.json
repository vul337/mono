{
  "cve_id": "CVE-2018-20843",
  "cwe_ids": [
    "CWE-611"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:C",
  "cvss_is_v3": false,
  "repo_name": "libexpat",
  "commit_msg": "xmlparse.c: Fix extraction of namespace prefix from XML name (#186)",
  "commit_hash": "11f8838bf99ea0a6f0b76f9760c43704d00c4ff6",
  "git_url": "https://github.com/libexpat/libexpat/commit/11f8838bf99ea0a6f0b76f9760c43704d00c4ff6",
  "file_path": "expat/lib/xmlparse.c",
  "func_name": "setElementTypePrefix",
  "func_before": "static int\nsetElementTypePrefix(XML_Parser parser, ELEMENT_TYPE *elementType)\n{\n  DTD * const dtd = parser->m_dtd;  /* save one level of indirection */\n  const XML_Char *name;\n  for (name = elementType->name; *name; name++) {\n    if (*name == XML_T(ASCII_COLON)) {\n      PREFIX *prefix;\n      const XML_Char *s;\n      for (s = elementType->name; s != name; s++) {\n        if (!poolAppendChar(&dtd->pool, *s))\n          return 0;\n      }\n      if (!poolAppendChar(&dtd->pool, XML_T('\\0')))\n        return 0;\n      prefix = (PREFIX *)lookup(parser, &dtd->prefixes, poolStart(&dtd->pool),\n                                sizeof(PREFIX));\n      if (!prefix)\n        return 0;\n      if (prefix->name == poolStart(&dtd->pool))\n        poolFinish(&dtd->pool);\n      else\n        poolDiscard(&dtd->pool);\n      elementType->prefix = prefix;\n\n    }\n  }\n  return 1;\n}",
  "abstract_func_before": "static int\nsetElementTypePrefix(XML_Parser VAR_0, ELEMENT_TYPE *VAR_1)\n{\n  DTD * const VAR_2 = VAR_0->m_dtd;  /* COMMENT_0 */\n  const XML_Char *VAR_3;\n  for (VAR_3 = VAR_1->name; *VAR_3; VAR_3++) {\n    if (*VAR_3 == XML_T(VAR_4)) {\n      PREFIX *VAR_5;\n      const XML_Char *VAR_6;\n      for (VAR_6 = VAR_1->name; VAR_6 != VAR_3; VAR_6++) {\n        if (!poolAppendChar(&VAR_2->pool, *VAR_6))\n          return 0;\n      }\n      if (!poolAppendChar(&VAR_2->pool, XML_T('\\0')))\n        return 0;\n      VAR_5 = (PREFIX *)lookup(VAR_0, &VAR_2->prefixes, poolStart(&VAR_2->pool),\n                                sizeof(PREFIX));\n      if (!VAR_5)\n        return 0;\n      if (VAR_5->name == poolStart(&VAR_2->pool))\n        poolFinish(&VAR_2->pool);\n      else\n        poolDiscard(&VAR_2->pool);\n      VAR_1->prefix = VAR_5;\n\n    }\n  }\n  return 1;\n}",
  "func_graph_path_before": "libexpat/11f8838bf99ea0a6f0b76f9760c43704d00c4ff6/xmlparse.c/vul/before/0.json",
  "func": "static int\nsetElementTypePrefix(XML_Parser parser, ELEMENT_TYPE *elementType)\n{\n  DTD * const dtd = parser->m_dtd;  /* save one level of indirection */\n  const XML_Char *name;\n  for (name = elementType->name; *name; name++) {\n    if (*name == XML_T(ASCII_COLON)) {\n      PREFIX *prefix;\n      const XML_Char *s;\n      for (s = elementType->name; s != name; s++) {\n        if (!poolAppendChar(&dtd->pool, *s))\n          return 0;\n      }\n      if (!poolAppendChar(&dtd->pool, XML_T('\\0')))\n        return 0;\n      prefix = (PREFIX *)lookup(parser, &dtd->prefixes, poolStart(&dtd->pool),\n                                sizeof(PREFIX));\n      if (!prefix)\n        return 0;\n      if (prefix->name == poolStart(&dtd->pool))\n        poolFinish(&dtd->pool);\n      else\n        poolDiscard(&dtd->pool);\n      elementType->prefix = prefix;\n      break;\n    }\n  }\n  return 1;\n}",
  "abstract_func": "static int\nsetElementTypePrefix(XML_Parser VAR_0, ELEMENT_TYPE *VAR_1)\n{\n  DTD * const VAR_2 = VAR_0->m_dtd;  /* COMMENT_0 */\n  const XML_Char *VAR_3;\n  for (VAR_3 = VAR_1->name; *VAR_3; VAR_3++) {\n    if (*VAR_3 == XML_T(VAR_4)) {\n      PREFIX *VAR_5;\n      const XML_Char *VAR_6;\n      for (VAR_6 = VAR_1->name; VAR_6 != VAR_3; VAR_6++) {\n        if (!poolAppendChar(&VAR_2->pool, *VAR_6))\n          return 0;\n      }\n      if (!poolAppendChar(&VAR_2->pool, XML_T('\\0')))\n        return 0;\n      VAR_5 = (PREFIX *)lookup(VAR_0, &VAR_2->prefixes, poolStart(&VAR_2->pool),\n                                sizeof(PREFIX));\n      if (!VAR_5)\n        return 0;\n      if (VAR_5->name == poolStart(&VAR_2->pool))\n        poolFinish(&VAR_2->pool);\n      else\n        poolDiscard(&VAR_2->pool);\n      VAR_1->prefix = VAR_5;\n      break;\n    }\n  }\n  return 1;\n}",
  "func_graph_path": "libexpat/11f8838bf99ea0a6f0b76f9760c43704d00c4ff6/xmlparse.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -22,7 +22,7 @@\n       else\n         poolDiscard(&dtd->pool);\n       elementType->prefix = prefix;\n-\n+      break;\n     }\n   }\n   return 1;",
  "diff_line_info": {
    "deleted_lines": [
      ""
    ],
    "added_lines": [
      "      break;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libexpat/libexpat/pull/262",
  "description": {
    "pr_info": {
      "title": "xmlparse.c: Fix extraction of namespace prefix from XML name (#186)",
      "number": 262
    },
    "comment": [
      "My impression is that function `setElementTypePrefix` extracts the XML namespace prefix from an XML name and puts it into `elementType->prefix` if it was able find a registered prefix for that namespace:\r\n\r\nhttps://github.com/libexpat/libexpat/blob/7f3291057bfc499933eddeb980ba67b9fb87834e/expat/lib/xmlparse.c#L6050-L6078\r\n\r\nNow according to this quote …\r\n\r\n>  [4] NCName ::= Name - (Char* ':' Char*) /* An XML Name, minus the \":\" */\r\n\r\n… from [Namespaces in XML 1.0 (Third Edition)](https://www.w3.org/TR/REC-xml-names/#NT-NCName) namespace prefixes cannot contain a colon.\r\n\r\nIt also seems that colons *should* be used in XML names for namespaces only, but do not render the name malformed if used otherwise they way I read [this](https://www.w3.org/TR/2006/REC-xml-20060816/#dt-name):\r\n\r\n> The Namespaces in XML Recommendation [XML Names] assigns a meaning to names containing colon characters. Therefore, authors should not use the colon in XML names except for namespace purposes, but XML processors must accept the colon as a name character.\r\n\r\nTo conclude from those two, my understanding is that we should treat all text before the first colon (if any) as a namespace prefix and treat the remainder as a name from (or relative to) that namespace, containing further colons or not.\r\n\r\nTo me, the \"right\" fix seems to be be to just add a `break` statement to the end if the inner `if`-block to stop after the first time we handled a colon. In my test, this patch does defuse the case of the [file attached](https://github.com/libexpat/libexpat/files/1664546/clusterfuzz-testcase-4543406568112128.txt) to issue #186 while keeping the test suite happy.\r\n\r\nReview welcome and appreciated!\r\n\r\n----\r\nRelated:\r\n- issue #186\r\n- pull request #261",
      "I feel a bit uneasy about the \"fix\" and even more so about the explanation. It is right, that in \"bare\" (namespace agnostic) XML documents colons (:) are allowed in element (and also) attribute names. That is: parser created with XML_ParserCreate() should accept documents with such names (and they did and do, as far as I'm aware).\r\n\r\nNow, if you want a parser, that accepts documents which are compliant not only to the w3c XML recommendation but also to the w3c XML namespaces recommendation the rules are a little bit adjusted. For expat this are the parsers created with XML_ParserCreateNS().\r\n\r\nFor such documents at max _one_ colon per element (or attribute) name is possible. The productions only a few lines below the place (https://www.w3.org/TR/xml-names/#NT-QName) cited by hartwork are cristal clear in this regard (if one need a confirming look into the spec for such a basic fact about XML). More than colon is a well-formedness error in this case.\r\n\r\nSo, either the parser is a \"bare\" XML rec parser then any number of colons (not as start char, but otherwise) in an element or attribute name is OK and there is no special meaning to them. So there is no point in looking them up with SetElementTypePrefix().\r\n\r\nOr the parser is an XML and XML namespaces aware parser. Then SetElementTypePrefix() should simply return parsing error at the second colon in a name.",
      "I have not been following this issue, just noticed it now. But it seems\nRolf Ade's comment is correct.\n\n Can't go really look at the code change as I am on vacation and only have\nmy phone at hand.\n\nOn Mon., Jul. 8, 2019, 1:04 a.m. Rolf Ade, <notifications@github.com> wrote:\n\n> I feel a bit uneasy about the \"fix\" and even more so about the\n> explanation. It is right, that in \"bare\" (namespace agnostic) XML documents\n> colons (:) are allowed in element (and also) attribute names. That is:\n> parser created with XML_ParserCreate() should accept documents with such\n> names (and they did and do, as far as I'm aware).\n>\n> Now, if you want a parser, that accepts documents which are compliant not\n> only to the w3c XML recommendation but also to the w3c XML namespaces\n> recommendation the rules are a little bit adjusted. For expat this are the\n> parsers created with XML_ParserCreateNS().\n>\n> For such documents at max *one* colon per element (or attribute) name is\n> possible. The productions only a few lines below the place (\n> https://www.w3.org/TR/xml-names/#NT-QName) cited by hartwork are cristal\n> clear in this regard (if one need a confirming look into the spec for such\n> a basic fact about XML). More than colon is a well-formedness error in this\n> case.\n>\n> So, either the parser is a \"bare\" XML rec parser then any number of colons\n> (not as start char, but otherwise) in an element or attribute name is OK\n> and there is no special meaning to them. So there is no point in looking\n> them up with SetElementTypePrefix().\n>\n> Or the parser is an XML and XML namespaces aware parser. Then\n> SetElementTypePrefix() should simply return parsing error at the second\n> colon in a name.\n>\n> —\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/libexpat/libexpat/pull/262?email_source=notifications&email_token=AAFABKUYA3J7PD4C7RTPPETP6JY65A5CNFSM4HX5H6QKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGODZLUYSI#issuecomment-509037641>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AAFABKX6EK2KSEWJMXNF6ALP6JY65ANCNFSM4HX5H6QA>\n> .\n>\n",
      "Hi @pointsman and @kwaclaw ,\r\n\r\nI appreciate the review and feedback. I would like to clearly separate the two topics that we might be about to mix here: (1) Whether the fix in this pull request made things better and/or worse and (2) if we can and should reject multiple colons and under what circumstances.\r\n\r\nFor (1) the security issue is fixed — that's better — and the name prefix extracted eventually now contains the the text up to but excluding the first colon rather than the last one.  Given that a name prefix *cannot* contain a colon by the spec, that seems also better than before to me. Is if there is anything off in that evaluation for (1) so far?\r\n\r\nFor (2) I am happy to team up on improving the situation further. The way I read …\r\n\r\n> All element and attribute names contain either zero or one colon;\r\n\r\n… at [7 Conformance of Documents](https://www.w3.org/TR/xml-names/#Conformance) supports @pointsman's argument.  If enabling namespace support flips Expat from reporting about XML well-formedness to reporting about [namespace-well-formed](https://www.w3.org/TR/xml-names/#Conformance) I guess we need to error out with a parse error in future releases indeed.\r\n\r\nLet me know what you think!"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "\n\nThe patch addresses a bug in XML namespace prefix extraction by adding a break statement, likely correcting loop behavior. The commit message doesn't indicate security issues, and the change doesn't directly address a vulnerability.\n\n**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence Score:** 0.9"
}