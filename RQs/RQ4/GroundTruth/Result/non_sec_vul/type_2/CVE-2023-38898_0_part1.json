{
  "cve_id": "CVE-2023-38898",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N",
  "cvss_is_v3": true,
  "repo_name": "python/cpython",
  "commit_msg": "gh-105987: Fix reference counting issue in '_asyncio._swap_current_task'\n\n'_PyDict_GetItem_KnownHash' returns borrowed reference to previous task object, so consequent calls to '_PyDict_DelItem_KnownHash'/'_PyDict_SetItem_KnownHash' can deallocate it before it will be returned from 'swap_current_task' function",
  "commit_hash": "586cd0d12f978341877ce1f817ea708ccb6dba9e",
  "git_url": "https://github.com/python/cpython/commit/586cd0d12f978341877ce1f817ea708ccb6dba9e",
  "file_path": "Modules/_asynciomodule.c",
  "func_name": "swap_current_task",
  "func_before": "static PyObject *\nswap_current_task(asyncio_state *state, PyObject *loop, PyObject *task)\n{\n    PyObject *prev_task;\n    Py_hash_t hash;\n    hash = PyObject_Hash(loop);\n    if (hash == -1) {\n        return NULL;\n    }\n\n    prev_task = _PyDict_GetItem_KnownHash(state->current_tasks, loop, hash);\n    if (prev_task == NULL) {\n        if (PyErr_Occurred()) {\n            return NULL;\n        }\n        prev_task = Py_None;\n    }\n\n    if (task == Py_None) {\n        if (_PyDict_DelItem_KnownHash(state->current_tasks, loop, hash) == -1) {\n            return NULL;\n        }\n    } else {\n        if (_PyDict_SetItem_KnownHash(state->current_tasks, loop, task, hash) == -1) {\n            return NULL;\n        }\n    }\n\n    Py_INCREF(prev_task);\n\n    return prev_task;\n}",
  "abstract_func_before": "static PyObject *\nswap_current_task(asyncio_state *VAR_0, PyObject *VAR_1, PyObject *VAR_2)\n{\n    PyObject *VAR_3;\n    Py_hash_t VAR_4;\n    VAR_4 = PyObject_Hash(VAR_1);\n    if (VAR_4 == -1) {\n        return NULL;\n    }\n\n    VAR_3 = _PyDict_GetItem_KnownHash(VAR_0->current_tasks, VAR_1, VAR_4);\n    if (VAR_3 == NULL) {\n        if (PyErr_Occurred()) {\n            return NULL;\n        }\n        VAR_3 = VAR_5;\n    }\n\n    if (VAR_2 == VAR_5) {\n        if (_PyDict_DelItem_KnownHash(VAR_0->current_tasks, VAR_1, VAR_4) == -1) {\n            return NULL;\n        }\n    } else {\n        if (_PyDict_SetItem_KnownHash(VAR_0->current_tasks, VAR_1, VAR_2, VAR_4) == -1) {\n            return NULL;\n        }\n    }\n\n    Py_INCREF(VAR_3);\n\n    return VAR_3;\n}",
  "func_graph_path_before": "python/cpython/586cd0d12f978341877ce1f817ea708ccb6dba9e/_asynciomodule.c/vul/before/0.json",
  "func": "static PyObject *\nswap_current_task(asyncio_state *state, PyObject *loop, PyObject *task)\n{\n    PyObject *prev_task;\n    Py_hash_t hash;\n    hash = PyObject_Hash(loop);\n    if (hash == -1) {\n        return NULL;\n    }\n\n    prev_task = Py_XNewRef(_PyDict_GetItem_KnownHash(state->current_tasks, loop, hash));\n    if (prev_task == NULL) {\n        if (PyErr_Occurred()) {\n            return NULL;\n        }\n        prev_task = Py_None;\n    }\n\n    if (task == Py_None) {\n        if (_PyDict_DelItem_KnownHash(state->current_tasks, loop, hash) == -1) {\n            goto error;\n        }\n    } else {\n        if (_PyDict_SetItem_KnownHash(state->current_tasks, loop, task, hash) == -1) {\n            goto error;\n        }\n    }\n\n    return prev_task;\n\nerror:\n    Py_DECREF(prev_task);\n    return NULL;\n}",
  "abstract_func": "static PyObject *\nswap_current_task(asyncio_state *VAR_0, PyObject *VAR_1, PyObject *VAR_2)\n{\n    PyObject *VAR_3;\n    Py_hash_t VAR_4;\n    VAR_4 = PyObject_Hash(VAR_1);\n    if (VAR_4 == -1) {\n        return NULL;\n    }\n\n    VAR_3 = Py_XNewRef(_PyDict_GetItem_KnownHash(VAR_0->current_tasks, VAR_1, VAR_4));\n    if (VAR_3 == NULL) {\n        if (PyErr_Occurred()) {\n            return NULL;\n        }\n        VAR_3 = VAR_5;\n    }\n\n    if (VAR_2 == VAR_5) {\n        if (_PyDict_DelItem_KnownHash(VAR_0->current_tasks, VAR_1, VAR_4) == -1) {\n            goto error;\n        }\n    } else {\n        if (_PyDict_SetItem_KnownHash(VAR_0->current_tasks, VAR_1, VAR_2, VAR_4) == -1) {\n            goto error;\n        }\n    }\n\n    return VAR_3;\n\nerror:\n    Py_DECREF(VAR_3);\n    return NULL;\n}",
  "func_graph_path": "python/cpython/586cd0d12f978341877ce1f817ea708ccb6dba9e/_asynciomodule.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -8,7 +8,7 @@\n         return NULL;\n     }\n \n-    prev_task = _PyDict_GetItem_KnownHash(state->current_tasks, loop, hash);\n+    prev_task = Py_XNewRef(_PyDict_GetItem_KnownHash(state->current_tasks, loop, hash));\n     if (prev_task == NULL) {\n         if (PyErr_Occurred()) {\n             return NULL;\n@@ -18,15 +18,17 @@\n \n     if (task == Py_None) {\n         if (_PyDict_DelItem_KnownHash(state->current_tasks, loop, hash) == -1) {\n-            return NULL;\n+            goto error;\n         }\n     } else {\n         if (_PyDict_SetItem_KnownHash(state->current_tasks, loop, task, hash) == -1) {\n-            return NULL;\n+            goto error;\n         }\n     }\n \n-    Py_INCREF(prev_task);\n+    return prev_task;\n \n-    return prev_task;\n+error:\n+    Py_DECREF(prev_task);\n+    return NULL;\n }",
  "diff_line_info": {
    "deleted_lines": [
      "    prev_task = _PyDict_GetItem_KnownHash(state->current_tasks, loop, hash);",
      "            return NULL;",
      "            return NULL;",
      "    Py_INCREF(prev_task);",
      "    return prev_task;"
    ],
    "added_lines": [
      "    prev_task = Py_XNewRef(_PyDict_GetItem_KnownHash(state->current_tasks, loop, hash));",
      "            goto error;",
      "            goto error;",
      "    return prev_task;",
      "error:",
      "    Py_DECREF(prev_task);",
      "    return NULL;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/python/cpython/pull/105989",
  "description": {
    "pr_info": {
      "title": "gh-105987: Fix reference counting issue in `_asyncio._swap_current_task`",
      "number": 105989
    },
    "comment": [
      "Fixes #105987 \r\n\r\n`_PyDict_GetItem_KnownHash` returns borrowed reference to previous task object, so call to `_PyDict_DelItem_KnownHash`/`_PyDict_SetItem_KnownHash` can deallocate it before it will be returned from `swap_current_task` function\r\n\n\n<!-- gh-issue-number: gh-105987 -->\n* Issue: gh-105987\n<!-- /gh-issue-number -->\n",
      "@carljm If you're uncomfortable merging this, can you ask @kumaraditya303 for a review?",
      "> uncomfortable merging this\r\n\r\nI wasn't, was just waiting for CI signal. But glad to have @kumaraditya303 's review!",
      "Thanks @chgnrdv for the PR, and @kumaraditya303 for merging it üåÆüéâ.. I'm working now to backport this PR to: 3.12.\nüêçüçí‚õèü§ñ I'm not a witch! I'm not a witch!",
      "Sorry, @chgnrdv and @kumaraditya303, I could not cleanly backport this to `3.12` due to a conflict. \n                                Please backport using [cherry_picker](https://pypi.org/project/cherry-picker/) on command line.\n                                ```\n                                cherry_picker d2cbb6e918d9ea39f0dd44acb53270f2dac07454 3.12\n                                ```\n                                ",
      "[GH-106099](https://github.com/python/cpython/pull/106099) is a backport of this pull request to the [3.12 branch](https://github.com/python/cpython/tree/3.12)."
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses a reference counting issue in the asyncio module. The changes ensure proper reference management, preventing premature object deallocation which could cause crashes. This is a functional bug fix, not a security vulnerability.\n\nFinal Classification: Defect Remediation & Feature Upgrades\n\nConfidence Score: 0.9"
}