{
  "cve_id": "CVE-2021-32276",
  "cwe_ids": [
    "CWE-476"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "knik0/faad2",
  "commit_msg": "Check for error after each channel decode.\n\nhInfo->error is reset within the decode_* functions. This caused the decoder\nto ignore errors for some channels in the error resilience (ER) code path.\n\nFixes #58.",
  "commit_hash": "b58840121d1827b4b6c7617e2431589af1776ddc",
  "git_url": "https://github.com/knik0/faad2/commit/b58840121d1827b4b6c7617e2431589af1776ddc",
  "file_path": "libfaad/syntax.c",
  "func_name": "raw_data_block",
  "func_before": "void raw_data_block(NeAACDecStruct *hDecoder, NeAACDecFrameInfo *hInfo,\n                    bitfile *ld, program_config *pce, drc_info *drc)\n{\n    uint8_t id_syn_ele;\n    uint8_t ele_this_frame = 0;\n\n    hDecoder->fr_channels = 0;\n    hDecoder->fr_ch_ele = 0;\n    hDecoder->first_syn_ele = 25;\n    hDecoder->has_lfe = 0;\n\n#ifdef ERROR_RESILIENCE\n    if (hDecoder->object_type < ER_OBJECT_START)\n    {\n#endif\n        /* Table 4.4.3: raw_data_block() */\n        while ((id_syn_ele = (uint8_t)faad_getbits(ld, LEN_SE_ID\n            DEBUGVAR(1,4,\"NeAACDecDecode(): id_syn_ele\"))) != ID_END)\n        {\n            switch (id_syn_ele) {\n            case ID_SCE:\n                ele_this_frame++;\n                if (hDecoder->first_syn_ele == 25) hDecoder->first_syn_ele = id_syn_ele;\n                decode_sce_lfe(hDecoder, hInfo, ld, id_syn_ele);\n                if (hInfo->error > 0)\n                    return;\n                break;\n            case ID_CPE:\n                ele_this_frame++;\n                if (hDecoder->first_syn_ele == 25) hDecoder->first_syn_ele = id_syn_ele;\n                decode_cpe(hDecoder, hInfo, ld, id_syn_ele);\n                if (hInfo->error > 0)\n                    return;\n                break;\n            case ID_LFE:\n#ifdef DRM\n                hInfo->error = 32;\n#else\n                ele_this_frame++;\n                hDecoder->has_lfe++;\n                decode_sce_lfe(hDecoder, hInfo, ld, id_syn_ele);\n#endif\n                if (hInfo->error > 0)\n                    return;\n                break;\n            case ID_CCE: /* not implemented yet, but skip the bits */\n#ifdef DRM\n                hInfo->error = 32;\n#else\n                ele_this_frame++;\n#ifdef COUPLING_DEC\n                hInfo->error = coupling_channel_element(hDecoder, ld);\n#else\n                hInfo->error = 6;\n#endif\n#endif\n                if (hInfo->error > 0)\n                    return;\n                break;\n            case ID_DSE:\n                ele_this_frame++;\n                data_stream_element(hDecoder, ld);\n                break;\n            case ID_PCE:\n                if (ele_this_frame != 0)\n                {\n                    hInfo->error = 31;\n                    return;\n                }\n                ele_this_frame++;\n                /* 14496-4: 5.6.4.1.2.1.3: */\n                /* program_configuration_element()'s in access units shall be ignored */\n                program_config_element(pce, ld);\n                //if ((hInfo->error = program_config_element(pce, ld)) > 0)\n                //    return;\n                //hDecoder->pce_set = 1;\n                break;\n            case ID_FIL:\n                ele_this_frame++;\n                /* one sbr_info describes a channel_element not a channel! */\n                /* if we encounter SBR data here: error */\n                /* SBR data will be read directly in the SCE/LFE/CPE element */\n                if ((hInfo->error = fill_element(hDecoder, ld, drc\n#ifdef SBR_DEC\n                    , INVALID_SBR_ELEMENT\n#endif\n                    )) > 0)\n                    return;\n                break;\n            }\n        }\n#ifdef ERROR_RESILIENCE\n    } else {\n        /* Table 262: er_raw_data_block() */\n        switch (hDecoder->channelConfiguration)\n        {\n        case 1:\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 2:\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 3:\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 4:\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 5:\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 6:\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_LFE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 7: /* 8 channels */\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_LFE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        default:\n            hInfo->error = 7;\n            return;\n        }\n#if 0\n        cnt = bits_to_decode() / 8;\n        while (cnt >= 1)\n        {\n            cnt -= extension_payload(cnt);\n        }\n#endif\n    }\n#endif\n\n    /* new in corrigendum 14496-3:2002 */\n#ifdef DRM\n    if (hDecoder->object_type != DRM_ER_LC\n#if 0\n        && !hDecoder->latm_header_present\n#endif\n        )\n#endif\n    {\n        faad_byte_align(ld);\n    }\n\n    return;\n}",
  "abstract_func_before": "void raw_data_block(NeAACDecStruct *VAR_0, NeAACDecFrameInfo *VAR_1,\n                    bitfile *VAR_2, program_config *VAR_3, drc_info *VAR_4)\n{\n    uint8_t VAR_5;\n    uint8_t VAR_6 = 0;\n\n    VAR_0->fr_channels = 0;\n    VAR_0->fr_ch_ele = 0;\n    VAR_0->first_syn_ele = 25;\n    VAR_0->has_lfe = 0;\n\n#ifdef VAR_7\n    if (VAR_0->object_type < VAR_8)\n    {\n#endif/* COMMENT_0 */\n                                           \n        while ((id_syn_ele = (uint8_t)faad_getbits(ld, LEN_SE_ID\n            DEBUGVAR(1,4,\"NeAACDecDecode(): id_syn_ele\"))) != VAR_9)\n        {\n            switch (VAR_5) {\n            case VAR_10:\n                VAR_6++;\n                if (VAR_0->first_syn_ele == 25) VAR_0->first_syn_ele = VAR_5;\n                decode_sce_lfe(VAR_0, VAR_1, VAR_2, VAR_5);\n                if (VAR_1->error > 0)\n                    return;\n                break;\n            case VAR_11:\n                VAR_6++;\n                if (VAR_0->first_syn_ele == 25) VAR_0->first_syn_ele = VAR_5;\n                decode_cpe(VAR_0, VAR_1, VAR_2, VAR_5);\n                if (VAR_1->error > 0)\n                    return;\n                break;\n            case VAR_12:\n#ifdef VAR_13\n                VAR_1->error = 32;\n#else\n                VAR_6++;\n                VAR_0->has_lfe++;\n                decode_sce_lfe(VAR_0, VAR_1, VAR_2, VAR_5);\n#endif\n                if (VAR_1->error > 0)\n                    return;\n                break;\n            case VAR_14: /* COMMENT_2 */\n#ifdef VAR_13\n                VAR_1->error = 32;\n#else\n                VAR_6++;\n#ifdef VAR_15\n                VAR_1->error = coupling_channel_element(VAR_0, VAR_2);\n#else\n                VAR_1->error = 6;\n#endif\n#endif\n                if (VAR_1->error > 0)\n                    return;\n                break;\n            case VAR_16:\n                VAR_6++;\n                data_stream_element(VAR_0, VAR_2);\n                break;\n            case VAR_17:\n                if (VAR_6 != 0)\n                {\n                    VAR_1->error = 31;\n                    return;\n                }\n                VAR_6++;\n                /* COMMENT_3 */\n                /* COMMENT_4 */\n                program_config_element(VAR_3, VAR_2);\n                /* COMMENT_5 */\n                /* COMMENT_6 */\n                /* COMMENT_7 */\n                break;\n            case VAR_18:\n                VAR_6++;\n                /* COMMENT_8 */\n                /* COMMENT_9 */\n                /* COMMENT_10 */\n                if ((VAR_1->error = fill_element(VAR_0, VAR_2, VAR_4\n#ifdef VAR_19\n                    , VAR_20\n#endif\n                    )) > 0)\n                    return;\n                break;\n            }\n        }\n#ifdef VAR_7\n    } else {\n        /* COMMENT_11 */\n        switch (VAR_0->channelConfiguration)\n        {\n        case 1:\n            decode_sce_lfe(VAR_0, VAR_1, VAR_2, VAR_10);\n            if (VAR_1->error > 0)\n                return;\n            break;\n        case 2:\n            decode_cpe(VAR_0, VAR_1, VAR_2, VAR_11);\n            if (VAR_1->error > 0)\n                return;\n            break;\n        case 3:\n            decode_sce_lfe(VAR_0, VAR_1, VAR_2, VAR_10);\n            decode_cpe(VAR_0, VAR_1, VAR_2, VAR_11);\n            if (VAR_1->error > 0)\n                return;\n            break;\n        case 4:\n            decode_sce_lfe(VAR_0, VAR_1, VAR_2, VAR_10);\n            decode_cpe(VAR_0, VAR_1, VAR_2, VAR_11);\n            decode_sce_lfe(VAR_0, VAR_1, VAR_2, VAR_10);\n            if (VAR_1->error > 0)\n                return;\n            break;\n        case 5:\n            decode_sce_lfe(VAR_0, VAR_1, VAR_2, VAR_10);\n            decode_cpe(VAR_0, VAR_1, VAR_2, VAR_11);\n            decode_cpe(VAR_0, VAR_1, VAR_2, VAR_11);\n            if (VAR_1->error > 0)\n                return;\n            break;\n        case 6:\n            decode_sce_lfe(VAR_0, VAR_1, VAR_2, VAR_10);\n            decode_cpe(VAR_0, VAR_1, VAR_2, VAR_11);\n            decode_cpe(VAR_0, VAR_1, VAR_2, VAR_11);\n            decode_sce_lfe(VAR_0, VAR_1, VAR_2, VAR_12);\n            if (VAR_1->error > 0)\n                return;\n            break;\n        case 7: /* COMMENT_12 */\n            decode_sce_lfe(VAR_0, VAR_1, VAR_2, VAR_10);\n            decode_cpe(VAR_0, VAR_1, VAR_2, VAR_11);\n            decode_cpe(VAR_0, VAR_1, VAR_2, VAR_11);\n            decode_cpe(VAR_0, VAR_1, VAR_2, VAR_11);\n            decode_sce_lfe(VAR_0, VAR_1, VAR_2, VAR_12);\n            if (VAR_1->error > 0)\n                return;\n            break;\n        default:\n            VAR_1->error = 7;\n            return;\n        }\n#if 0\n        VAR_21 = bits_to_decode() / 8;\n        while (VAR_21 >= 1)\n        {\n            VAR_21 -= extension_payload(VAR_21);\n        }\n#endif\n    }\n#endif\n\n    /* COMMENT_13 */\n#ifdef VAR_13\n    if (VAR_0->object_type != VAR_22\n#if 0\n        && !VAR_0->latm_header_present\n#endif\n        )\n#endif\n    {\n        faad_byte_align(VAR_2);\n    }\n\n    return;\n}",
  "func_graph_path_before": "knik0/faad2/b58840121d1827b4b6c7617e2431589af1776ddc/syntax.c/vul/before/0.json",
  "func": "void raw_data_block(NeAACDecStruct *hDecoder, NeAACDecFrameInfo *hInfo,\n                    bitfile *ld, program_config *pce, drc_info *drc)\n{\n    uint8_t id_syn_ele;\n    uint8_t ele_this_frame = 0;\n\n    hDecoder->fr_channels = 0;\n    hDecoder->fr_ch_ele = 0;\n    hDecoder->first_syn_ele = 25;\n    hDecoder->has_lfe = 0;\n\n#ifdef ERROR_RESILIENCE\n    if (hDecoder->object_type < ER_OBJECT_START)\n    {\n#endif\n        /* Table 4.4.3: raw_data_block() */\n        while ((id_syn_ele = (uint8_t)faad_getbits(ld, LEN_SE_ID\n            DEBUGVAR(1,4,\"NeAACDecDecode(): id_syn_ele\"))) != ID_END)\n        {\n            switch (id_syn_ele) {\n            case ID_SCE:\n                ele_this_frame++;\n                if (hDecoder->first_syn_ele == 25) hDecoder->first_syn_ele = id_syn_ele;\n                decode_sce_lfe(hDecoder, hInfo, ld, id_syn_ele);\n                if (hInfo->error > 0)\n                    return;\n                break;\n            case ID_CPE:\n                ele_this_frame++;\n                if (hDecoder->first_syn_ele == 25) hDecoder->first_syn_ele = id_syn_ele;\n                decode_cpe(hDecoder, hInfo, ld, id_syn_ele);\n                if (hInfo->error > 0)\n                    return;\n                break;\n            case ID_LFE:\n#ifdef DRM\n                hInfo->error = 32;\n#else\n                ele_this_frame++;\n                hDecoder->has_lfe++;\n                decode_sce_lfe(hDecoder, hInfo, ld, id_syn_ele);\n#endif\n                if (hInfo->error > 0)\n                    return;\n                break;\n            case ID_CCE: /* not implemented yet, but skip the bits */\n#ifdef DRM\n                hInfo->error = 32;\n#else\n                ele_this_frame++;\n#ifdef COUPLING_DEC\n                hInfo->error = coupling_channel_element(hDecoder, ld);\n#else\n                hInfo->error = 6;\n#endif\n#endif\n                if (hInfo->error > 0)\n                    return;\n                break;\n            case ID_DSE:\n                ele_this_frame++;\n                data_stream_element(hDecoder, ld);\n                break;\n            case ID_PCE:\n                if (ele_this_frame != 0)\n                {\n                    hInfo->error = 31;\n                    return;\n                }\n                ele_this_frame++;\n                /* 14496-4: 5.6.4.1.2.1.3: */\n                /* program_configuration_element()'s in access units shall be ignored */\n                program_config_element(pce, ld);\n                //if ((hInfo->error = program_config_element(pce, ld)) > 0)\n                //    return;\n                //hDecoder->pce_set = 1;\n                break;\n            case ID_FIL:\n                ele_this_frame++;\n                /* one sbr_info describes a channel_element not a channel! */\n                /* if we encounter SBR data here: error */\n                /* SBR data will be read directly in the SCE/LFE/CPE element */\n                if ((hInfo->error = fill_element(hDecoder, ld, drc\n#ifdef SBR_DEC\n                    , INVALID_SBR_ELEMENT\n#endif\n                    )) > 0)\n                    return;\n                break;\n            }\n        }\n#ifdef ERROR_RESILIENCE\n    } else {\n        /* Table 262: er_raw_data_block() */\n        switch (hDecoder->channelConfiguration)\n        {\n        case 1:\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 2:\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 3:\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            if (hInfo->error > 0)\n                return;\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 4:\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            if (hInfo->error > 0)\n                return;\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 5:\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            if (hInfo->error > 0)\n                return;\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 6:\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            if (hInfo->error > 0)\n                return;\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_LFE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 7: /* 8 channels */\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            if (hInfo->error > 0)\n                return;\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_LFE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        default:\n            hInfo->error = 7;\n            return;\n        }\n#if 0\n        cnt = bits_to_decode() / 8;\n        while (cnt >= 1)\n        {\n            cnt -= extension_payload(cnt);\n        }\n#endif\n    }\n#endif\n\n    /* new in corrigendum 14496-3:2002 */\n#ifdef DRM\n    if (hDecoder->object_type != DRM_ER_LC\n#if 0\n        && !hDecoder->latm_header_present\n#endif\n        )\n#endif\n    {\n        faad_byte_align(ld);\n    }\n\n    return;\n}",
  "abstract_func": "void raw_data_block(NeAACDecStruct *VAR_0, NeAACDecFrameInfo *VAR_1,\n                    bitfile *VAR_2, program_config *VAR_3, drc_info *VAR_4)\n{\n    uint8_t VAR_5;\n    uint8_t VAR_6 = 0;\n\n    VAR_0->fr_channels = 0;\n    VAR_0->fr_ch_ele = 0;\n    VAR_0->first_syn_ele = 25;\n    VAR_0->has_lfe = 0;\n\n#ifdef VAR_7\n    if (VAR_0->object_type < VAR_8)\n    {\n#endif/* COMMENT_0 */\n                                           \n        while ((id_syn_ele = (uint8_t)faad_getbits(ld, LEN_SE_ID\n            DEBUGVAR(1,4,\"NeAACDecDecode(): id_syn_ele\"))) != VAR_9)\n        {\n            switch (VAR_5) {\n            case VAR_10:\n                VAR_6++;\n                if (VAR_0->first_syn_ele == 25) VAR_0->first_syn_ele = VAR_5;\n                decode_sce_lfe(VAR_0, VAR_1, VAR_2, VAR_5);\n                if (VAR_1->error > 0)\n                    return;\n                break;\n            case VAR_11:\n                VAR_6++;\n                if (VAR_0->first_syn_ele == 25) VAR_0->first_syn_ele = VAR_5;\n                decode_cpe(VAR_0, VAR_1, VAR_2, VAR_5);\n                if (VAR_1->error > 0)\n                    return;\n                break;\n            case VAR_12:\n#ifdef VAR_13\n                VAR_1->error = 32;\n#else\n                VAR_6++;\n                VAR_0->has_lfe++;\n                decode_sce_lfe(VAR_0, VAR_1, VAR_2, VAR_5);\n#endif\n                if (VAR_1->error > 0)\n                    return;\n                break;\n            case VAR_14: /* COMMENT_2 */\n#ifdef VAR_13\n                VAR_1->error = 32;\n#else\n                VAR_6++;\n#ifdef VAR_15\n                VAR_1->error = coupling_channel_element(VAR_0, VAR_2);\n#else\n                VAR_1->error = 6;\n#endif\n#endif\n                if (VAR_1->error > 0)\n                    return;\n                break;\n            case VAR_16:\n                VAR_6++;\n                data_stream_element(VAR_0, VAR_2);\n                break;\n            case VAR_17:\n                if (VAR_6 != 0)\n                {\n                    VAR_1->error = 31;\n                    return;\n                }\n                VAR_6++;\n                /* COMMENT_3 */\n                /* COMMENT_4 */\n                program_config_element(VAR_3, VAR_2);\n                /* COMMENT_5 */\n                /* COMMENT_6 */\n                /* COMMENT_7 */\n                break;\n            case VAR_18:\n                VAR_6++;\n                /* COMMENT_8 */\n                /* COMMENT_9 */\n                /* COMMENT_10 */\n                if ((VAR_1->error = fill_element(VAR_0, VAR_2, VAR_4\n#ifdef VAR_19\n                    , VAR_20\n#endif\n                    )) > 0)\n                    return;\n                break;\n            }\n        }\n#ifdef VAR_7\n    } else {\n        /* COMMENT_11 */\n        switch (VAR_0->channelConfiguration)\n        {\n        case 1:\n            decode_sce_lfe(VAR_0, VAR_1, VAR_2, VAR_10);\n            if (VAR_1->error > 0)\n                return;\n            break;\n        case 2:\n            decode_cpe(VAR_0, VAR_1, VAR_2, VAR_11);\n            if (VAR_1->error > 0)\n                return;\n            break;\n        case 3:\n            decode_sce_lfe(VAR_0, VAR_1, VAR_2, VAR_10);\n            if (VAR_1->error > 0)\n                return;\n            decode_cpe(VAR_0, VAR_1, VAR_2, VAR_11);\n            if (VAR_1->error > 0)\n                return;\n            break;\n        case 4:\n            decode_sce_lfe(VAR_0, VAR_1, VAR_2, VAR_10);\n            if (VAR_1->error > 0)\n                return;\n            decode_cpe(VAR_0, VAR_1, VAR_2, VAR_11);\n            if (VAR_1->error > 0)\n                return;\n            decode_sce_lfe(VAR_0, VAR_1, VAR_2, VAR_10);\n            if (VAR_1->error > 0)\n                return;\n            break;\n        case 5:\n            decode_sce_lfe(VAR_0, VAR_1, VAR_2, VAR_10);\n            if (VAR_1->error > 0)\n                return;\n            decode_cpe(VAR_0, VAR_1, VAR_2, VAR_11);\n            if (VAR_1->error > 0)\n                return;\n            decode_cpe(VAR_0, VAR_1, VAR_2, VAR_11);\n            if (VAR_1->error > 0)\n                return;\n            break;\n        case 6:\n            decode_sce_lfe(VAR_0, VAR_1, VAR_2, VAR_10);\n            if (VAR_1->error > 0)\n                return;\n            decode_cpe(VAR_0, VAR_1, VAR_2, VAR_11);\n            if (VAR_1->error > 0)\n                return;\n            decode_cpe(VAR_0, VAR_1, VAR_2, VAR_11);\n            if (VAR_1->error > 0)\n                return;\n            decode_sce_lfe(VAR_0, VAR_1, VAR_2, VAR_12);\n            if (VAR_1->error > 0)\n                return;\n            break;\n        case 7: /* COMMENT_12 */\n            decode_sce_lfe(VAR_0, VAR_1, VAR_2, VAR_10);\n            if (VAR_1->error > 0)\n                return;\n            decode_cpe(VAR_0, VAR_1, VAR_2, VAR_11);\n            if (VAR_1->error > 0)\n                return;\n            decode_cpe(VAR_0, VAR_1, VAR_2, VAR_11);\n            if (VAR_1->error > 0)\n                return;\n            decode_cpe(VAR_0, VAR_1, VAR_2, VAR_11);\n            if (VAR_1->error > 0)\n                return;\n            decode_sce_lfe(VAR_0, VAR_1, VAR_2, VAR_12);\n            if (VAR_1->error > 0)\n                return;\n            break;\n        default:\n            VAR_1->error = 7;\n            return;\n        }\n#if 0\n        VAR_21 = bits_to_decode() / 8;\n        while (VAR_21 >= 1)\n        {\n            VAR_21 -= extension_payload(VAR_21);\n        }\n#endif\n    }\n#endif\n\n    /* COMMENT_13 */\n#ifdef VAR_13\n    if (VAR_0->object_type != VAR_22\n#if 0\n        && !VAR_0->latm_header_present\n#endif\n        )\n#endif\n    {\n        faad_byte_align(VAR_2);\n    }\n\n    return;\n}",
  "func_graph_path": "knik0/faad2/b58840121d1827b4b6c7617e2431589af1776ddc/syntax.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -106,37 +106,61 @@\n             break;\n         case 3:\n             decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n+            if (hInfo->error > 0)\n+                return;\n             decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n             if (hInfo->error > 0)\n                 return;\n             break;\n         case 4:\n             decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n+            if (hInfo->error > 0)\n+                return;\n             decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n+            if (hInfo->error > 0)\n+                return;\n             decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n             if (hInfo->error > 0)\n                 return;\n             break;\n         case 5:\n             decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n+            if (hInfo->error > 0)\n+                return;\n             decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n+            if (hInfo->error > 0)\n+                return;\n             decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n             if (hInfo->error > 0)\n                 return;\n             break;\n         case 6:\n             decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n+            if (hInfo->error > 0)\n+                return;\n             decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n+            if (hInfo->error > 0)\n+                return;\n             decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n+            if (hInfo->error > 0)\n+                return;\n             decode_sce_lfe(hDecoder, hInfo, ld, ID_LFE);\n             if (hInfo->error > 0)\n                 return;\n             break;\n         case 7: /* 8 channels */\n             decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n+            if (hInfo->error > 0)\n+                return;\n             decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n+            if (hInfo->error > 0)\n+                return;\n             decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n+            if (hInfo->error > 0)\n+                return;\n             decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n+            if (hInfo->error > 0)\n+                return;\n             decode_sce_lfe(hDecoder, hInfo, ld, ID_LFE);\n             if (hInfo->error > 0)\n                 return;",
  "diff_line_info": {
    "deleted_lines": [],
    "added_lines": [
      "            if (hInfo->error > 0)",
      "                return;",
      "            if (hInfo->error > 0)",
      "                return;",
      "            if (hInfo->error > 0)",
      "                return;",
      "            if (hInfo->error > 0)",
      "                return;",
      "            if (hInfo->error > 0)",
      "                return;",
      "            if (hInfo->error > 0)",
      "                return;",
      "            if (hInfo->error > 0)",
      "                return;",
      "            if (hInfo->error > 0)",
      "                return;",
      "            if (hInfo->error > 0)",
      "                return;",
      "            if (hInfo->error > 0)",
      "                return;",
      "            if (hInfo->error > 0)",
      "                return;",
      "            if (hInfo->error > 0)",
      "                return;"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/knik0/faad2/pull/66",
  "description": {
    "pr_info": {
      "title": "Fix additional crashes.",
      "number": 66
    },
    "comment": [
      "Fixes #58 and an additional crash found with afl-fuzz.\r\n\r\nI'm not a huge fan of the either fix in terms of elegance, but they should are simple and straight forward to understand.",
      "Thank you very much for this!"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "\n\nAnalysis: The patch adds error checks after each decode operation to prevent ignoring errors, improving error handling and functionality without addressing a security exploit.\n\nFinal Classification: Defect Remediation & Feature Upgrades\n\nConfidence Score: 0.9"
}