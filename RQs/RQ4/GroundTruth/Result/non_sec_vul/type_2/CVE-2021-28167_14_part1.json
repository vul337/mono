{
  "cve_id": "CVE-2021-28167",
  "cwe_ids": [
    "CWE-909"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:P/I:P/A:N",
  "cvss_is_v3": false,
  "repo_name": "eclipse-openj9/openj9",
  "commit_msg": "Correctly load/initialize classes when using ConstantPool\n\n- do not load classes in the \"ifLoaded\" calls\n- never intitialize classes in the natives\n- do not update the constant pool when querying from the natives\n\nFixes: #12016\n\n[ci skip]\n\nSigned-off-by: Graham Chapman <graham_chapman@ca.ibm.com>",
  "commit_hash": "840f3af31a5b8d2d395d9367c826ed756e380fb9",
  "git_url": "https://github.com/eclipse-openj9/openj9/commit/840f3af31a5b8d2d395d9367c826ed756e380fb9",
  "file_path": "runtime/vm/resolvesupport.cpp",
  "func_name": "resolveStringRef",
  "func_before": "j9object_t   \nresolveStringRef(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags)\n{\n\tJ9UTF8 *utf8Wrapper;\n\tj9object_t stringRef;\n\tJ9ROMStringRef *romStringRef;\n\n\tTrc_VM_resolveStringRef_Entry(vmStruct, cpIndex, ramCP);\n\n\tromStringRef = (J9ROMStringRef *)&ramCP->romConstantPool[cpIndex];\n\tutf8Wrapper = J9ROMSTRINGREF_UTF8DATA(romStringRef);\n\t\n\tTrc_VM_resolveStringRef_utf8(vmStruct, &utf8Wrapper, J9UTF8_LENGTH(utf8Wrapper), J9UTF8_DATA(utf8Wrapper));\n\n\t/* Create a new string */\n\tstringRef = vmStruct->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(vmStruct, J9UTF8_DATA(utf8Wrapper), J9UTF8_LENGTH(utf8Wrapper), J9_STR_TENURE | J9_STR_INTERN);\n\t\n\t/* If stringRef is NULL, the exception has already been set. */\n\tif (stringRef != NULL) {\n\t\tJ9Class *clazz = J9_CLASS_FROM_CP(ramCP);\n\t\tJ9RAMStringRef *ramStringRef = (J9RAMStringRef *)&ramCP[cpIndex];\n\t\tj9object_t *stringObjectP = &ramStringRef->stringObject;\n\t\t/* Overwriting NULL with an immortal pointer, so no exception can occur */\n\t\tJ9STATIC_OBJECT_STORE(vmStruct, clazz, stringObjectP, stringRef);\n\t}\n\n\tTrc_VM_resolveStringRef_Exit(vmStruct, stringRef);\n\n\treturn stringRef;\n}",
  "abstract_func_before": "j9object_t   \nresolveStringRef(J9VMThread *VAR_0, J9ConstantPool *VAR_1, UDATA VAR_2, UDATA VAR_3)\n{\n\tJ9UTF8 *VAR_4;\n\tj9object_t VAR_5;\n\tJ9ROMStringRef *VAR_6;\n\n\tTrc_VM_resolveStringRef_Entry(VAR_0, VAR_2, VAR_1);\n\n\tVAR_6 = (J9ROMStringRef *)&VAR_1->romConstantPool[VAR_2];\n\tVAR_4 = J9ROMSTRINGREF_UTF8DATA(VAR_6);\n\t\n\tTrc_VM_resolveStringRef_utf8(VAR_0, &VAR_4, J9UTF8_LENGTH(VAR_4), J9UTF8_DATA(VAR_4));\n\n\t/* COMMENT_0 */\n\tVAR_5 = VAR_0->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(VAR_0, J9UTF8_DATA(VAR_4), J9UTF8_LENGTH(VAR_4), VAR_7 | VAR_8);\n\t\n\t/* COMMENT_1 */\n\tif (VAR_5 != NULL) {\n\t\tJ9Class *VAR_9 = J9_CLASS_FROM_CP(VAR_1);\n\t\tJ9RAMStringRef *VAR_10 = (J9RAMStringRef *)&VAR_1[VAR_2];\n\t\tj9object_t *VAR_11 = &VAR_10->stringObject;\n\t\t/* COMMENT_2 */\n\t\tJ9STATIC_OBJECT_STORE(VAR_0, VAR_9, VAR_11, VAR_5);\n\t}\n\n\tTrc_VM_resolveStringRef_Exit(VAR_0, VAR_5);\n\n\treturn VAR_5;\n}",
  "func_graph_path_before": "eclipse-openj9/openj9/840f3af31a5b8d2d395d9367c826ed756e380fb9/resolvesupport.cpp/vul/before/6.json",
  "func": "j9object_t   \nresolveStringRef(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags)\n{\n\tJ9UTF8 *utf8Wrapper;\n\tj9object_t stringRef;\n\tJ9ROMStringRef *romStringRef;\n\n\tTrc_VM_resolveStringRef_Entry(vmStruct, cpIndex, ramCP);\n\n\tromStringRef = (J9ROMStringRef *)&ramCP->romConstantPool[cpIndex];\n\tutf8Wrapper = J9ROMSTRINGREF_UTF8DATA(romStringRef);\n\t\n\tTrc_VM_resolveStringRef_utf8(vmStruct, &utf8Wrapper, J9UTF8_LENGTH(utf8Wrapper), J9UTF8_DATA(utf8Wrapper));\n\n\t/* Create a new string */\n\tstringRef = vmStruct->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(vmStruct, J9UTF8_DATA(utf8Wrapper), J9UTF8_LENGTH(utf8Wrapper), J9_STR_TENURE | J9_STR_INTERN);\n\t\n\t/* If stringRef is NULL, the exception has already been set. */\n\tif ((NULL != stringRef) && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\n\t\tJ9Class *clazz = J9_CLASS_FROM_CP(ramCP);\n\t\tJ9RAMStringRef *ramStringRef = (J9RAMStringRef *)&ramCP[cpIndex];\n\t\tj9object_t *stringObjectP = &ramStringRef->stringObject;\n\t\t/* Overwriting NULL with an immortal pointer, so no exception can occur */\n\t\tJ9STATIC_OBJECT_STORE(vmStruct, clazz, stringObjectP, stringRef);\n\t}\n\n\tTrc_VM_resolveStringRef_Exit(vmStruct, stringRef);\n\n\treturn stringRef;\n}",
  "abstract_func": "j9object_t   \nresolveStringRef(J9VMThread *VAR_0, J9ConstantPool *VAR_1, UDATA VAR_2, UDATA VAR_3)\n{\n\tJ9UTF8 *VAR_4;\n\tj9object_t VAR_5;\n\tJ9ROMStringRef *VAR_6;\n\n\tTrc_VM_resolveStringRef_Entry(VAR_0, VAR_2, VAR_1);\n\n\tVAR_6 = (J9ROMStringRef *)&VAR_1->romConstantPool[VAR_2];\n\tVAR_4 = J9ROMSTRINGREF_UTF8DATA(VAR_6);\n\t\n\tTrc_VM_resolveStringRef_utf8(VAR_0, &VAR_4, J9UTF8_LENGTH(VAR_4), J9UTF8_DATA(VAR_4));\n\n\t/* COMMENT_0 */\n\tVAR_5 = VAR_0->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(VAR_0, J9UTF8_DATA(VAR_4), J9UTF8_LENGTH(VAR_4), VAR_7 | VAR_8);\n\t\n\t/* COMMENT_1 */\n\tif ((NULL != VAR_5) && J9_ARE_NO_BITS_SET(VAR_3, VAR_9)) {\n\t\tJ9Class *VAR_10 = J9_CLASS_FROM_CP(VAR_1);\n\t\tJ9RAMStringRef *VAR_11 = (J9RAMStringRef *)&VAR_1[VAR_2];\n\t\tj9object_t *VAR_12 = &VAR_11->stringObject;\n\t\t/* COMMENT_2 */\n\t\tJ9STATIC_OBJECT_STORE(VAR_0, VAR_10, VAR_12, VAR_5);\n\t}\n\n\tTrc_VM_resolveStringRef_Exit(VAR_0, VAR_5);\n\n\treturn VAR_5;\n}",
  "func_graph_path": "eclipse-openj9/openj9/840f3af31a5b8d2d395d9367c826ed756e380fb9/resolvesupport.cpp/vul/after/6.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -16,7 +16,7 @@\n \tstringRef = vmStruct->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(vmStruct, J9UTF8_DATA(utf8Wrapper), J9UTF8_LENGTH(utf8Wrapper), J9_STR_TENURE | J9_STR_INTERN);\n \t\n \t/* If stringRef is NULL, the exception has already been set. */\n-\tif (stringRef != NULL) {\n+\tif ((NULL != stringRef) && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\n \t\tJ9Class *clazz = J9_CLASS_FROM_CP(ramCP);\n \t\tJ9RAMStringRef *ramStringRef = (J9RAMStringRef *)&ramCP[cpIndex];\n \t\tj9object_t *stringObjectP = &ramStringRef->stringObject;",
  "diff_line_info": {
    "deleted_lines": [
      "\tif (stringRef != NULL) {"
    ],
    "added_lines": [
      "\tif ((NULL != stringRef) && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/eclipse-openj9/openj9/pull/12148",
  "description": {
    "pr_info": {
      "title": "Correctly load/initialize classes when using ConstantPool",
      "number": 12148
    },
    "comment": [
      "- do not load classes in the \"ifLoaded\" calls\r\n- never intitialize classes in the natives\r\n- do not update the constant pool when querying from the natives\r\n\r\nFixes: #12016\r\n\r\n[ci skip]\r\n\r\nSigned-off-by: Graham Chapman <graham_chapman@ca.ibm.com>",
      "jenkins test sanity,extended zlinux jdk11",
      "jenkins compile win jdk8",
      "@gacholio can you please open another PR for the 0.26 stream",
      "https://github.com/eclipse/openj9/pull/12164"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch addresses class loading and initialization issues, preventing unintended class loading and constant pool updates. While it improves system correctness, there's no explicit indication of security implications.\n\nFinal Classification: Defect Remediation & Feature Upgrades\n\nConfidence Score: 0.8"
}