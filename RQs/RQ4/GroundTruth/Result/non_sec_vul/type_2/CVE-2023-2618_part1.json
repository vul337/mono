{
  "cve_id": "CVE-2023-2618",
  "cwe_ids": [
    "CWE-401"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "opencv/opencv_contrib",
  "commit_msg": "fix(wechat_qrcode): fixed memory leaks",
  "commit_hash": "2b62ff6181163eea029ed1cab11363b4996e9cd6",
  "git_url": "https://github.com/opencv/opencv_contrib/commit/2b62ff6181163eea029ed1cab11363b4996e9cd6",
  "file_path": "modules/wechat_qrcode/src/zxing/qrcode/decoder/decoded_bit_stream_parser.cpp",
  "func_name": "DecodedBitStreamParser::decodeHanziSegment",
  "func_before": "void DecodedBitStreamParser::decodeHanziSegment(Ref<BitSource> bits_, string& result, int count,\n                                                ErrorHandler& err_handler) {\n    BitSource& bits(*bits_);\n    // Don't crash trying to read more bits than we have available.\n    if (count * 13 > bits.available()) {\n        err_handler = zxing::FormatErrorHandler(\"decodeKanjiSegment\");\n        return;\n    }\n\n    // Each character will require 2 bytes. Read the characters as 2-byte pairs\n    // and decode as GB2312 afterwards\n    size_t nBytes = 2 * count;\n    char* buffer = new char[nBytes];\n    int offset = 0;\n    while (count > 0) {\n        // Each 13 bits encodes a 2-byte character\n        int twoBytes = bits.readBits(13, err_handler);\n        if (err_handler.ErrCode()) return;\n        int assembledTwoBytes = ((twoBytes / 0x060) << 8) | (twoBytes % 0x060);\n        if (assembledTwoBytes < 0x003BF) {\n            // In the 0xA1A1 to 0xAAFE range\n            assembledTwoBytes += 0x0A1A1;\n        } else {\n            // In the 0xB0A1 to 0xFAFE range\n            assembledTwoBytes += 0x0A6A1;\n        }\n        buffer[offset] = (char)((assembledTwoBytes >> 8) & 0xFF);\n        buffer[offset + 1] = (char)(assembledTwoBytes & 0xFF);\n        offset += 2;\n        count--;\n    }\n    // for(int i=0;i<nBytes;i++)\n    // cout<<buffer[i]<<endl;\n    append(result, buffer, nBytes, err_handler);\n    if (err_handler.ErrCode()) {\n        delete[] buffer;\n        return;\n    }\n\n    delete[] buffer;\n}",
  "abstract_func_before": "void DecodedBitStreamParser::decodeHanziSegment(Ref<BitSource> VAR_0, string& VAR_1, int VAR_2,\n                                                ErrorHandler& VAR_3) {\n    BitSource& bits(*VAR_0);\n    /* COMMENT_0 */\n    if (VAR_2 * 13 > VAR_4.available()) {\n        VAR_3 = zxing::FormatErrorHandler(\"decodeKanjiSegment\");\n        return;\n    }\n\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n    size_t VAR_5 = 2 * VAR_2;\n    char* VAR_6 = new char[VAR_5];\n    int VAR_7 = 0;\n    while (VAR_2 > 0) {\n        /* COMMENT_3 */\n        int VAR_8 = VAR_4.readBits(13, VAR_3);\n        if (VAR_3.ErrCode()) return;\n        int VAR_9 = ((VAR_8 / 0x060) << 8) | (VAR_8 % 0x060);\n        if (VAR_9 < 0x003BF) {\n            /* COMMENT_4 */\n            VAR_9 += 0x0A1A1;\n        } else {\n            /* COMMENT_5 */\n            VAR_9 += 0x0A6A1;\n        }\n        VAR_6[VAR_7] = (char)((VAR_9 >> 8) & 0xFF);\n        VAR_6[VAR_7 + 1] = (char)(VAR_9 & 0xFF);\n        VAR_7 += 2;\n        VAR_2--;\n    }\n    /* COMMENT_6 */\n    /* COMMENT_7 */\n    append(VAR_1, VAR_6, VAR_5, VAR_3);\n    if (VAR_3.ErrCode()) {\n        delete[] VAR_6;\n        return;\n    }\n\n    delete[] VAR_6;\n}",
  "func_graph_path_before": "opencv/opencv_contrib/2b62ff6181163eea029ed1cab11363b4996e9cd6/decoded_bit_stream_parser.cpp/vul/before/0.json",
  "func": "void DecodedBitStreamParser::decodeHanziSegment(Ref<BitSource> bits_, string& result, int count,\n                                                ErrorHandler& err_handler) {\n    BitSource& bits(*bits_);\n    // Don't crash trying to read more bits than we have available.\n    if (count * 13 > bits.available()) {\n        err_handler = zxing::FormatErrorHandler(\"decodeKanjiSegment\");\n        return;\n    }\n\n    // Each character will require 2 bytes. Read the characters as 2-byte pairs\n    // and decode as GB2312 afterwards\n    size_t nBytes = 2 * count;\n    char* buffer = new char[nBytes];\n    int offset = 0;\n    while (count > 0) {\n        // Each 13 bits encodes a 2-byte character\n        int twoBytes = bits.readBits(13, err_handler);\n        if (err_handler.ErrCode()) {\n            delete[] buffer;\n            return;\n        }\n        int assembledTwoBytes = ((twoBytes / 0x060) << 8) | (twoBytes % 0x060);\n        if (assembledTwoBytes < 0x003BF) {\n            // In the 0xA1A1 to 0xAAFE range\n            assembledTwoBytes += 0x0A1A1;\n        } else {\n            // In the 0xB0A1 to 0xFAFE range\n            assembledTwoBytes += 0x0A6A1;\n        }\n        buffer[offset] = (char)((assembledTwoBytes >> 8) & 0xFF);\n        buffer[offset + 1] = (char)(assembledTwoBytes & 0xFF);\n        offset += 2;\n        count--;\n    }\n    // for(int i=0;i<nBytes;i++)\n    // cout<<buffer[i]<<endl;\n    append(result, buffer, nBytes, err_handler);\n    if (err_handler.ErrCode()) {\n        delete[] buffer;\n        return;\n    }\n\n    delete[] buffer;\n}",
  "abstract_func": "void DecodedBitStreamParser::decodeHanziSegment(Ref<BitSource> VAR_0, string& VAR_1, int VAR_2,\n                                                ErrorHandler& VAR_3) {\n    BitSource& bits(*VAR_0);\n    /* COMMENT_0 */\n    if (VAR_2 * 13 > VAR_4.available()) {\n        VAR_3 = zxing::FormatErrorHandler(\"decodeKanjiSegment\");\n        return;\n    }\n\n    /* COMMENT_1 */\n    /* COMMENT_2 */\n    size_t VAR_5 = 2 * VAR_2;\n    char* VAR_6 = new char[VAR_5];\n    int VAR_7 = 0;\n    while (VAR_2 > 0) {\n        /* COMMENT_3 */\n        int VAR_8 = VAR_4.readBits(13, VAR_3);\n        if (VAR_3.ErrCode()) {\n            delete[] VAR_6;\n            return;\n        }\n        int VAR_9 = ((VAR_8 / 0x060) << 8) | (VAR_8 % 0x060);\n        if (VAR_9 < 0x003BF) {\n            /* COMMENT_4 */\n            VAR_9 += 0x0A1A1;\n        } else {\n            /* COMMENT_5 */\n            VAR_9 += 0x0A6A1;\n        }\n        VAR_6[VAR_7] = (char)((VAR_9 >> 8) & 0xFF);\n        VAR_6[VAR_7 + 1] = (char)(VAR_9 & 0xFF);\n        VAR_7 += 2;\n        VAR_2--;\n    }\n    /* COMMENT_6 */\n    /* COMMENT_7 */\n    append(VAR_1, VAR_6, VAR_5, VAR_3);\n    if (VAR_3.ErrCode()) {\n        delete[] VAR_6;\n        return;\n    }\n\n    delete[] VAR_6;\n}",
  "func_graph_path": "opencv/opencv_contrib/2b62ff6181163eea029ed1cab11363b4996e9cd6/decoded_bit_stream_parser.cpp/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -15,7 +15,10 @@\n     while (count > 0) {\n         // Each 13 bits encodes a 2-byte character\n         int twoBytes = bits.readBits(13, err_handler);\n-        if (err_handler.ErrCode()) return;\n+        if (err_handler.ErrCode()) {\n+            delete[] buffer;\n+            return;\n+        }\n         int assembledTwoBytes = ((twoBytes / 0x060) << 8) | (twoBytes % 0x060);\n         if (assembledTwoBytes < 0x003BF) {\n             // In the 0xA1A1 to 0xAAFE range",
  "diff_line_info": {
    "deleted_lines": [
      "        if (err_handler.ErrCode()) return;"
    ],
    "added_lines": [
      "        if (err_handler.ErrCode()) {",
      "            delete[] buffer;",
      "            return;",
      "        }"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/opencv/opencv_contrib/pull/3484",
  "description": {
    "pr_info": {
      "title": "fix(wechat_qrcode): fixed memory leaks",
      "number": 3484
    },
    "comment": [
      "### Pull Request Readiness Checklist\r\n\r\nSee details at https://github.com/opencv/opencv/wiki/How_to_contribute#making-a-good-pull-request\r\n\r\n- [x] I agree to contribute to the project under Apache 2 License.\r\n- [x] To the best of my knowledge, the proposed patch is not based on a code under GPL or another license that is incompatible with OpenCV\r\n- [x] The PR is proposed to the proper branch\r\n- [x] There is a reference to the original bug report and related work\r\n- [x] There is accuracy test, performance test and test data in opencv_extra repository, if applicable\r\n      Patch to opencv_extra has the same branch name.\r\n- [x] The feature is well documented and sample code can be built with the project CMake\r\n",
      "Marked as CVE-2023-2618"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "\n\nThe patch addresses a memory leak in the QR code decoding function, which is a resource management issue. It prevents buffer allocation without freeing, improving stability rather than securing against attacks.\n\n**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence Score:** 0.9"
}