{
  "cve_id": "CVE-2017-15377",
  "cwe_ids": [
    "CWE-Other"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "OISF/suricata",
  "commit_msg": "detect: avoid needless recursive scanning\n\nDon't recursively inspect a detect list if the recursion\ndoesn't increase chance of success.",
  "commit_hash": "b9579fbe7dd408200ef03cbe20efddb624b73885",
  "git_url": "https://github.com/OISF/suricata/commit/b9579fbe7dd408200ef03cbe20efddb624b73885",
  "file_path": "src/detect-engine-content-inspection.c",
  "func_name": "DetectEngineContentInspection",
  "func_before": "int DetectEngineContentInspection(DetectEngineCtx *de_ctx, DetectEngineThreadCtx *det_ctx,\n                                  const Signature *s, const SigMatchData *smd,\n                                  Flow *f,\n                                  uint8_t *buffer, uint32_t buffer_len,\n                                  uint32_t stream_start_offset,\n                                  uint8_t inspection_mode, void *data)\n{\n    SCEnter();\n    KEYWORD_PROFILING_START;\n\n    det_ctx->inspection_recursion_counter++;\n\n    if (det_ctx->inspection_recursion_counter == de_ctx->inspection_recursion_limit) {\n        det_ctx->discontinue_matching = 1;\n        KEYWORD_PROFILING_END(det_ctx, smd->type, 0);\n        SCReturnInt(0);\n    }\n\n    if (smd == NULL || buffer_len == 0) {\n        KEYWORD_PROFILING_END(det_ctx, smd->type, 0);\n        SCReturnInt(0);\n    }\n\n    /* \\todo unify this which is phase 2 of payload inspection unification */\n    if (smd->type == DETECT_CONTENT) {\n\n        DetectContentData *cd = (DetectContentData *)smd->ctx;\n        SCLogDebug(\"inspecting content %\"PRIu32\" buffer_len %\"PRIu32, cd->id, buffer_len);\n\n        /* we might have already have this content matched by the mpm.\n         * (if there is any other reason why we'd want to avoid checking\n         *  it here, please fill it in) */\n        //if (cd->flags & DETECT_CONTENT_NO_DOUBLE_INSPECTION_REQUIRED) {\n        //    goto match;\n        //}\n\n        /* rule parsers should take care of this */\n#ifdef DEBUG\n        BUG_ON(cd->depth != 0 && cd->depth <= cd->offset);\n#endif\n\n        /* search for our pattern, checking the matches recursively.\n         * if we match we look for the next SigMatch as well */\n        uint8_t *found = NULL;\n        uint32_t offset = 0;\n        uint32_t depth = buffer_len;\n        uint32_t prev_offset = 0; /**< used in recursive searching */\n        uint32_t prev_buffer_offset = det_ctx->buffer_offset;\n\n        do {\n            if ((cd->flags & DETECT_CONTENT_DISTANCE) ||\n                (cd->flags & DETECT_CONTENT_WITHIN)) {\n                SCLogDebug(\"det_ctx->buffer_offset %\"PRIu32, det_ctx->buffer_offset);\n\n                offset = prev_buffer_offset;\n                depth = buffer_len;\n\n                int distance = cd->distance;\n                if (cd->flags & DETECT_CONTENT_DISTANCE) {\n                    if (cd->flags & DETECT_CONTENT_DISTANCE_BE) {\n                        distance = det_ctx->bj_values[cd->distance];\n                    }\n                    if (distance < 0 && (uint32_t)(abs(distance)) > offset)\n                        offset = 0;\n                    else\n                        offset += distance;\n\n                    SCLogDebug(\"cd->distance %\"PRIi32\", offset %\"PRIu32\", depth %\"PRIu32,\n                               distance, offset, depth);\n                }\n\n                if (cd->flags & DETECT_CONTENT_WITHIN) {\n                    if (cd->flags & DETECT_CONTENT_WITHIN_BE) {\n                        if ((int32_t)depth > (int32_t)(prev_buffer_offset + det_ctx->bj_values[cd->within] + distance)) {\n                            depth = prev_buffer_offset + det_ctx->bj_values[cd->within] + distance;\n                        }\n                    } else {\n                        if ((int32_t)depth > (int32_t)(prev_buffer_offset + cd->within + distance)) {\n                            depth = prev_buffer_offset + cd->within + distance;\n                        }\n\n                        SCLogDebug(\"cd->within %\"PRIi32\", det_ctx->buffer_offset %\"PRIu32\", depth %\"PRIu32,\n                                   cd->within, prev_buffer_offset, depth);\n                    }\n\n                    if (stream_start_offset != 0 && prev_buffer_offset == 0) {\n                        if (depth <= stream_start_offset) {\n                            goto no_match;\n                        } else if (depth >= (stream_start_offset + buffer_len)) {\n                            ;\n                        } else {\n                            depth = depth - stream_start_offset;\n                        }\n                    }\n                }\n\n                if (cd->flags & DETECT_CONTENT_DEPTH_BE) {\n                    if ((det_ctx->bj_values[cd->depth] + prev_buffer_offset) < depth) {\n                        depth = prev_buffer_offset + det_ctx->bj_values[cd->depth];\n                    }\n                } else {\n                    if (cd->depth != 0) {\n                        if ((cd->depth + prev_buffer_offset) < depth) {\n                            depth = prev_buffer_offset + cd->depth;\n                        }\n\n                        SCLogDebug(\"cd->depth %\"PRIu32\", depth %\"PRIu32, cd->depth, depth);\n                    }\n                }\n\n                if (cd->flags & DETECT_CONTENT_OFFSET_BE) {\n                    if (det_ctx->bj_values[cd->offset] > offset)\n                        offset = det_ctx->bj_values[cd->offset];\n                } else {\n                    if (cd->offset > offset) {\n                        offset = cd->offset;\n                        SCLogDebug(\"setting offset %\"PRIu32, offset);\n                    }\n                }\n            } else { /* implied no relative matches */\n                /* set depth */\n                if (cd->flags & DETECT_CONTENT_DEPTH_BE) {\n                    depth = det_ctx->bj_values[cd->depth];\n                } else {\n                    if (cd->depth != 0) {\n                        depth = cd->depth;\n                    }\n                }\n\n                if (stream_start_offset != 0 && cd->flags & DETECT_CONTENT_DEPTH) {\n                    if (depth <= stream_start_offset) {\n                        goto no_match;\n                    } else if (depth >= (stream_start_offset + buffer_len)) {\n                        ;\n                    } else {\n                        depth = depth - stream_start_offset;\n                    }\n                }\n\n                /* set offset */\n                if (cd->flags & DETECT_CONTENT_OFFSET_BE)\n                    offset = det_ctx->bj_values[cd->offset];\n                else\n                    offset = cd->offset;\n                prev_buffer_offset = 0;\n            }\n\n            /* update offset with prev_offset if we're searching for\n             * matches after the first occurence. */\n            SCLogDebug(\"offset %\"PRIu32\", prev_offset %\"PRIu32, offset, prev_offset);\n            if (prev_offset != 0)\n                offset = prev_offset;\n\n            SCLogDebug(\"offset %\"PRIu32\", depth %\"PRIu32, offset, depth);\n\n            if (depth > buffer_len)\n                depth = buffer_len;\n\n            /* if offset is bigger than depth we can never match on a pattern.\n             * We can however, \"match\" on a negated pattern. */\n            if (offset > depth || depth == 0) {\n                if (cd->flags & DETECT_CONTENT_NEGATED) {\n                    goto match;\n                } else {\n                    goto no_match;\n                }\n            }\n\n            uint8_t *sbuffer = buffer + offset;\n            uint32_t sbuffer_len = depth - offset;\n            uint32_t match_offset = 0;\n            SCLogDebug(\"sbuffer_len %\"PRIu32, sbuffer_len);\n#ifdef DEBUG\n            BUG_ON(sbuffer_len > buffer_len);\n#endif\n\n            /* \\todo Add another optimization here.  If cd->content_len is\n             * greater than sbuffer_len found is anyways NULL */\n\n            /* do the actual search */\n            found = SpmScan(cd->spm_ctx, det_ctx->spm_thread_ctx, sbuffer,\n                            sbuffer_len);\n\n            /* next we evaluate the result in combination with the\n             * negation flag. */\n            SCLogDebug(\"found %p cd negated %s\", found, cd->flags & DETECT_CONTENT_NEGATED ? \"true\" : \"false\");\n\n            if (found == NULL && !(cd->flags & DETECT_CONTENT_NEGATED)) {\n                goto no_match;\n            } else if (found == NULL && (cd->flags & DETECT_CONTENT_NEGATED)) {\n                goto match;\n            } else if (found != NULL && (cd->flags & DETECT_CONTENT_NEGATED)) {\n                SCLogDebug(\"content %\"PRIu32\" matched at offset %\"PRIu32\", but negated so no match\", cd->id, match_offset);\n                /* don't bother carrying recursive matches now, for preceding\n                 * relative keywords */\n                if (DETECT_CONTENT_IS_SINGLE(cd))\n                    det_ctx->discontinue_matching = 1;\n                goto no_match;\n            } else {\n                match_offset = (uint32_t)((found - buffer) + cd->content_len);\n                SCLogDebug(\"content %\"PRIu32\" matched at offset %\"PRIu32\"\", cd->id, match_offset);\n                det_ctx->buffer_offset = match_offset;\n\n                /* Match branch, add replace to the list if needed */\n                if (cd->flags & DETECT_CONTENT_REPLACE) {\n                    if (inspection_mode == DETECT_ENGINE_CONTENT_INSPECTION_MODE_PAYLOAD) {\n                        /* we will need to replace content if match is confirmed */\n                        det_ctx->replist = DetectReplaceAddToList(det_ctx->replist, found, cd);\n                    } else {\n                        SCLogWarning(SC_ERR_INVALID_VALUE, \"Can't modify payload without packet\");\n                    }\n                }\n                if (!(cd->flags & DETECT_CONTENT_RELATIVE_NEXT)) {\n                    SCLogDebug(\"no relative match coming up, so this is a match\");\n                    goto match;\n                }\n\n                /* bail out if we have no next match. Technically this is an\n                 * error, as the current cd has the DETECT_CONTENT_RELATIVE_NEXT\n                 * flag set. */\n                if (smd->is_last) {\n                    goto no_match;\n                }\n\n                SCLogDebug(\"content %\"PRIu32, cd->id);\n                KEYWORD_PROFILING_END(det_ctx, smd->type, 1);\n\n                /* see if the next buffer keywords match. If not, we will\n                 * search for another occurence of this content and see\n                 * if the others match then until we run out of matches */\n                int r = DetectEngineContentInspection(de_ctx, det_ctx, s, smd+1,\n                        f, buffer, buffer_len, stream_start_offset, inspection_mode, data);\n                if (r == 1) {\n                    SCReturnInt(1);\n                }\n\n                if (det_ctx->discontinue_matching)\n                    goto no_match;\n\n                /* set the previous match offset to the start of this match + 1 */\n                prev_offset = (match_offset - (cd->content_len - 1));\n                SCLogDebug(\"trying to see if there is another match after prev_offset %\"PRIu32, prev_offset);\n            }\n\n        } while(1);\n\n    } else if (smd->type == DETECT_ISDATAAT) {\n        SCLogDebug(\"inspecting isdataat\");\n\n        DetectIsdataatData *id = (DetectIsdataatData *)smd->ctx;\n        if (id->flags & ISDATAAT_RELATIVE) {\n            if (det_ctx->buffer_offset + id->dataat > buffer_len) {\n                SCLogDebug(\"det_ctx->buffer_offset + id->dataat %\"PRIu32\" > %\"PRIu32, det_ctx->buffer_offset + id->dataat, buffer_len);\n                if (id->flags & ISDATAAT_NEGATED)\n                    goto match;\n                goto no_match;\n            } else {\n                SCLogDebug(\"relative isdataat match\");\n                if (id->flags & ISDATAAT_NEGATED)\n                    goto no_match;\n                goto match;\n            }\n        } else {\n            if (id->dataat < buffer_len) {\n                SCLogDebug(\"absolute isdataat match\");\n                if (id->flags & ISDATAAT_NEGATED)\n                    goto no_match;\n                goto match;\n            } else {\n                SCLogDebug(\"absolute isdataat mismatch, id->isdataat %\"PRIu32\", buffer_len %\"PRIu32\"\", id->dataat, buffer_len);\n                if (id->flags & ISDATAAT_NEGATED)\n                    goto match;\n                goto no_match;\n            }\n        }\n\n    } else if (smd->type == DETECT_PCRE) {\n        SCLogDebug(\"inspecting pcre\");\n        DetectPcreData *pe = (DetectPcreData *)smd->ctx;\n        uint32_t prev_buffer_offset = det_ctx->buffer_offset;\n        uint32_t prev_offset = 0;\n        int r = 0;\n\n        det_ctx->pcre_match_start_offset = 0;\n        do {\n            Packet *p = NULL;\n            if (inspection_mode == DETECT_ENGINE_CONTENT_INSPECTION_MODE_PAYLOAD)\n                p = (Packet *)data;\n            r = DetectPcrePayloadMatch(det_ctx, s, smd, p, f,\n                                       buffer, buffer_len);\n            if (r == 0) {\n                goto no_match;\n            }\n\n            if (!(pe->flags & DETECT_PCRE_RELATIVE_NEXT)) {\n                SCLogDebug(\"no relative match coming up, so this is a match\");\n                goto match;\n            }\n            KEYWORD_PROFILING_END(det_ctx, smd->type, 1);\n\n            /* save it, in case we need to do a pcre match once again */\n            prev_offset = det_ctx->pcre_match_start_offset;\n\n            /* see if the next payload keywords match. If not, we will\n             * search for another occurence of this pcre and see\n             * if the others match, until we run out of matches */\n            r = DetectEngineContentInspection(de_ctx, det_ctx, s, smd+1,\n                    f, buffer, buffer_len, stream_start_offset, inspection_mode, data);\n            if (r == 1) {\n                SCReturnInt(1);\n            }\n\n            if (det_ctx->discontinue_matching)\n                goto no_match;\n\n            det_ctx->buffer_offset = prev_buffer_offset;\n            det_ctx->pcre_match_start_offset = prev_offset;\n        } while (1);\n\n    } else if (smd->type == DETECT_BYTETEST) {\n        DetectBytetestData *btd = (DetectBytetestData *)smd->ctx;\n        uint8_t flags = btd->flags;\n        int32_t offset = btd->offset;\n        uint64_t value = btd->value;\n        if (flags & DETECT_BYTETEST_OFFSET_BE) {\n            offset = det_ctx->bj_values[offset];\n        }\n        if (flags & DETECT_BYTETEST_VALUE_BE) {\n            value = det_ctx->bj_values[value];\n        }\n\n        /* if we have dce enabled we will have to use the endianness\n         * specified by the dce header */\n        if (flags & DETECT_BYTETEST_DCE && data != NULL) {\n            DCERPCState *dcerpc_state = (DCERPCState *)data;\n            /* enable the endianness flag temporarily.  once we are done\n             * processing we reset the flags to the original value*/\n            flags |= ((dcerpc_state->dcerpc.dcerpchdr.packed_drep[0] & 0x10) ?\n                      DETECT_BYTETEST_LITTLE: 0);\n        }\n\n        if (DetectBytetestDoMatch(det_ctx, s, smd->ctx, buffer, buffer_len, flags,\n                                  offset, value) != 1) {\n            goto no_match;\n        }\n\n        goto match;\n\n    } else if (smd->type == DETECT_BYTEJUMP) {\n        DetectBytejumpData *bjd = (DetectBytejumpData *)smd->ctx;\n        uint8_t flags = bjd->flags;\n        int32_t offset = bjd->offset;\n\n        if (flags & DETECT_BYTEJUMP_OFFSET_BE) {\n            offset = det_ctx->bj_values[offset];\n        }\n\n        /* if we have dce enabled we will have to use the endianness\n         * specified by the dce header */\n        if (flags & DETECT_BYTEJUMP_DCE && data != NULL) {\n            DCERPCState *dcerpc_state = (DCERPCState *)data;\n            /* enable the endianness flag temporarily.  once we are done\n             * processing we reset the flags to the original value*/\n            flags |= ((dcerpc_state->dcerpc.dcerpchdr.packed_drep[0] & 0x10) ?\n                      DETECT_BYTEJUMP_LITTLE: 0);\n        }\n\n        if (DetectBytejumpDoMatch(det_ctx, s, smd->ctx, buffer, buffer_len,\n                                  flags, offset) != 1) {\n            goto no_match;\n        }\n\n        goto match;\n\n    } else if (smd->type == DETECT_BYTE_EXTRACT) {\n\n        DetectByteExtractData *bed = (DetectByteExtractData *)smd->ctx;\n        uint8_t endian = bed->endian;\n\n        /* if we have dce enabled we will have to use the endianness\n         * specified by the dce header */\n        if ((bed->flags & DETECT_BYTE_EXTRACT_FLAG_ENDIAN) &&\n            endian == DETECT_BYTE_EXTRACT_ENDIAN_DCE && data != NULL) {\n\n            DCERPCState *dcerpc_state = (DCERPCState *)data;\n            /* enable the endianness flag temporarily.  once we are done\n             * processing we reset the flags to the original value*/\n            endian |= ((dcerpc_state->dcerpc.dcerpchdr.packed_drep[0] == 0x10) ?\n                       DETECT_BYTE_EXTRACT_ENDIAN_LITTLE : DETECT_BYTE_EXTRACT_ENDIAN_BIG);\n        }\n\n        if (DetectByteExtractDoMatch(det_ctx, smd, s, buffer,\n                                     buffer_len,\n                                     &det_ctx->bj_values[bed->local_id],\n                                     endian) != 1) {\n            goto no_match;\n        }\n\n        goto match;\n\n        /* we should never get here, but bail out just in case */\n    } else if (smd->type == DETECT_AL_URILEN) {\n        SCLogDebug(\"inspecting uri len\");\n\n        int r = 0;\n        DetectUrilenData *urilend = (DetectUrilenData *) smd->ctx;\n\n        switch (urilend->mode) {\n            case DETECT_URILEN_EQ:\n                if (buffer_len == urilend->urilen1)\n                    r = 1;\n                break;\n            case DETECT_URILEN_LT:\n                if (buffer_len < urilend->urilen1)\n                    r = 1;\n                break;\n            case DETECT_URILEN_GT:\n                if (buffer_len > urilend->urilen1)\n                    r = 1;\n                break;\n            case DETECT_URILEN_RA:\n                if (buffer_len > urilend->urilen1 &&\n                    buffer_len < urilend->urilen2) {\n                    r = 1;\n                }\n                break;\n        }\n\n        if (r == 1) {\n            goto match;\n        }\n\n        det_ctx->discontinue_matching = 0;\n\n        goto no_match;\n#ifdef HAVE_LUA\n    }\n    else if (smd->type == DETECT_LUA) {\n        SCLogDebug(\"lua starting\");\n\n        if (DetectLuaMatchBuffer(det_ctx, s, smd, buffer, buffer_len,\n                    det_ctx->buffer_offset, f) != 1)\n        {\n            SCLogDebug(\"lua no_match\");\n            goto no_match;\n        }\n        SCLogDebug(\"lua match\");\n        goto match;\n#endif /* HAVE_LUA */\n    } else if (smd->type == DETECT_BASE64_DECODE) {\n        if (DetectBase64DecodeDoMatch(det_ctx, s, smd, buffer, buffer_len)) {\n            if (s->sm_arrays[DETECT_SM_LIST_BASE64_DATA] != NULL) {\n                KEYWORD_PROFILING_END(det_ctx, smd->type, 1);\n                if (DetectBase64DataDoMatch(de_ctx, det_ctx, s, f)) {\n                    /* Base64 is a terminal list. */\n                    goto final_match;\n                }\n            }\n        }\n    } else {\n        SCLogDebug(\"sm->type %u\", smd->type);\n#ifdef DEBUG\n        BUG_ON(1);\n#endif\n    }\n\nno_match:\n    KEYWORD_PROFILING_END(det_ctx, smd->type, 0);\n    SCReturnInt(0);\n\nmatch:\n    /* this sigmatch matched, inspect the next one. If it was the last,\n     * the buffer portion of the signature matched. */\n    if (!smd->is_last) {\n        KEYWORD_PROFILING_END(det_ctx, smd->type, 1);\n        int r = DetectEngineContentInspection(de_ctx, det_ctx, s, smd+1,\n                f, buffer, buffer_len, stream_start_offset, inspection_mode, data);\n        SCReturnInt(r);\n    }\nfinal_match:\n    KEYWORD_PROFILING_END(det_ctx, smd->type, 1);\n    SCReturnInt(1);\n}",
  "abstract_func_before": "int DetectEngineContentInspection(DetectEngineCtx *VAR_0, DetectEngineThreadCtx *VAR_1,\n                                  const Signature *VAR_2, const SigMatchData *VAR_3,\n                                  Flow *VAR_4,\n                                  uint8_t *VAR_5, uint32_t VAR_6,\n                                  uint32_t VAR_7,\n                                  uint8_t VAR_8, void *VAR_9)\n{\n    SCEnter();\n    VAR_10;\n\n    VAR_1->inspection_recursion_counter++;\n\n    if (VAR_1->inspection_recursion_counter == VAR_0->inspection_recursion_limit) {\n        VAR_1->discontinue_matching = 1;\n        KEYWORD_PROFILING_END(VAR_1, VAR_3->type, 0);\n        SCReturnInt(0);\n    }\n\n    if (VAR_3 == NULL || VAR_6 == 0) {\n        KEYWORD_PROFILING_END(VAR_1, VAR_3->type, 0);\n        SCReturnInt(0);\n    }\n\n    /* COMMENT_0 */\n    if (VAR_3->type == VAR_11) {\n\n        DetectContentData *VAR_12 = (DetectContentData *)VAR_3->ctx;\n        SCLogDebug(\"inspecting content %\"VAR_13\" buffer_len %\"VAR_13, VAR_12->id, VAR_6);\n\n        /* COMMENT_1 */\n                                                                        \n                                          \n        /* COMMENT_4 */\n        /* COMMENT_5 */\n        /* COMMENT_6 */\n\n        /* COMMENT_7 */\n#ifdef VAR_14\n        BUG_ON(VAR_12->depth != 0 && VAR_12->depth <= VAR_12->offset);\n#endif\n\n        /* COMMENT_8 */\n                                                               \n        uint8_t *VAR_15 = NULL;\n        uint32_t VAR_16 = 0;\n        uint32_t VAR_17 = VAR_6;\n        uint32_t VAR_18 = 0; /* COMMENT_10 */\n        uint32_t VAR_19 = VAR_1->buffer_offset;\n\n        do {\n            if ((VAR_12->flags & VAR_20) ||\n                (VAR_12->flags & VAR_21)) {\n                SCLogDebug(\"det_ctx->buffer_offset %\"VAR_13, VAR_1->buffer_offset);\n\n                VAR_16 = VAR_19;\n                VAR_17 = VAR_6;\n\n                int VAR_22 = VAR_12->distance;\n                if (VAR_12->flags & VAR_20) {\n                    if (VAR_12->flags & VAR_23) {\n                        VAR_22 = VAR_1->bj_values[VAR_12->distance];\n                    }\n                    if (VAR_22 < 0 && (uint32_t)(abs(VAR_22)) > VAR_16)\n                        VAR_16 = 0;\n                    else\n                        VAR_16 += VAR_22;\n\n                    SCLogDebug(\"cd->distance %\"VAR_24\", offset %\"VAR_13\", depth %\"VAR_13,\n                               VAR_22, VAR_16, VAR_17);\n                }\n\n                if (VAR_12->flags & VAR_21) {\n                    if (VAR_12->flags & VAR_25) {\n                        if ((int32_t)VAR_17 > (int32_t)(VAR_19 + VAR_1->bj_values[VAR_12->within] + VAR_22)) {\n                            VAR_17 = VAR_19 + VAR_1->bj_values[VAR_12->within] + VAR_22;\n                        }\n                    } else {\n                        if ((int32_t)VAR_17 > (int32_t)(VAR_19 + VAR_12->within + VAR_22)) {\n                            VAR_17 = VAR_19 + VAR_12->within + VAR_22;\n                        }\n\n                        SCLogDebug(\"cd->within %\"VAR_24\", det_ctx->buffer_offset %\"VAR_13\", depth %\"VAR_13,\n                                   VAR_12->within, VAR_19, VAR_17);\n                    }\n\n                    if (VAR_7 != 0 && VAR_19 == 0) {\n                        if (VAR_17 <= VAR_7) {\n                            goto no_match;\n                        } else if (VAR_17 >= (VAR_7 + VAR_6)) {\n                            ;\n                        } else {\n                            VAR_17 = VAR_17 - VAR_7;\n                        }\n                    }\n                }\n\n                if (VAR_12->flags & VAR_26) {\n                    if ((VAR_1->bj_values[VAR_12->depth] + VAR_19) < VAR_17) {\n                        VAR_17 = VAR_19 + VAR_1->bj_values[VAR_12->depth];\n                    }\n                } else {\n                    if (VAR_12->depth != 0) {\n                        if ((VAR_12->depth + VAR_19) < VAR_17) {\n                            VAR_17 = VAR_19 + VAR_12->depth;\n                        }\n\n                        SCLogDebug(\"cd->depth %\"VAR_13\", depth %\"VAR_13, VAR_12->depth, VAR_17);\n                    }\n                }\n\n                if (VAR_12->flags & VAR_27) {\n                    if (VAR_1->bj_values[VAR_12->offset] > VAR_16)\n                        VAR_16 = VAR_1->bj_values[VAR_12->offset];\n                } else {\n                    if (VAR_12->offset > VAR_16) {\n                        VAR_16 = VAR_12->offset;\n                        SCLogDebug(\"setting offset %\"VAR_13, VAR_16);\n                    }\n                }\n            } else { /* COMMENT_11 */\n                /* COMMENT_12 */\n                if (VAR_12->flags & VAR_26) {\n                    VAR_17 = VAR_1->bj_values[VAR_12->depth];\n                } else {\n                    if (VAR_12->depth != 0) {\n                        VAR_17 = VAR_12->depth;\n                    }\n                }\n\n                if (VAR_7 != 0 && VAR_12->flags & VAR_28) {\n                    if (VAR_17 <= VAR_7) {\n                        goto no_match;\n                    } else if (VAR_17 >= (VAR_7 + VAR_6)) {\n                        ;\n                    } else {\n                        VAR_17 = VAR_17 - VAR_7;\n                    }\n                }\n\n                /* COMMENT_13 */\n                if (VAR_12->flags & VAR_27)\n                    VAR_16 = VAR_1->bj_values[VAR_12->offset];\n                else\n                    VAR_16 = VAR_12->offset;\n                VAR_19 = 0;\n            }\n\n            /* COMMENT_14 */\n                                                    \n            SCLogDebug(\"offset %\"VAR_13\", prev_offset %\"VAR_13, VAR_16, VAR_18);\n            if (VAR_18 != 0)\n                VAR_16 = VAR_18;\n\n            SCLogDebug(\"offset %\"VAR_13\", depth %\"VAR_13, VAR_16, VAR_17);\n\n            if (VAR_17 > VAR_6)\n                VAR_17 = VAR_6;\n\n            /* COMMENT_16 */\n                                                               \n            if (VAR_16 > VAR_17 || VAR_17 == 0) {\n                if (VAR_12->flags & VAR_29) {\n                    goto match;\n                } else {\n                    goto no_match;\n                }\n            }\n\n            uint8_t *VAR_30 = VAR_5 + VAR_16;\n            uint32_t VAR_31 = VAR_17 - VAR_16;\n            uint32_t VAR_32 = 0;\n            SCLogDebug(\"sbuffer_len %\"VAR_13, VAR_31);\n#ifdef VAR_14\n            BUG_ON(VAR_31 > VAR_6);\n#endif\n\n            /* COMMENT_18 */\n                                                                \n\n            /* COMMENT_20 */\n            VAR_15 = SpmScan(VAR_12->spm_ctx, VAR_1->spm_thread_ctx, VAR_30,\n                            VAR_31);\n\n            /* COMMENT_21 */\n                                \n            SCLogDebug(\"found %p cd negated %s\", VAR_15, VAR_12->flags & VAR_29 ? \"true\" : \"false\");\n\n            if (VAR_15 == NULL && !(VAR_12->flags & VAR_29)) {\n                goto no_match;\n            } else if (VAR_15 == NULL && (VAR_12->flags & VAR_29)) {\n                goto match;\n            } else if (VAR_15 != NULL && (VAR_12->flags & VAR_29)) {\n                SCLogDebug(\"content %\"VAR_13\" matched at offset %\"VAR_13\", but negated so no match\", VAR_12->id, VAR_32);\n                /* COMMENT_23 */\n                                       \n                if (DETECT_CONTENT_IS_SINGLE(VAR_12))\n                    VAR_1->discontinue_matching = 1;\n                goto no_match;\n            } else {\n                VAR_32 = (uint32_t)((VAR_15 - VAR_5) + VAR_12->content_len);\n                SCLogDebug(\"content %\"VAR_13\" matched at offset %\"VAR_13\"\", VAR_12->id, VAR_32);\n                VAR_1->buffer_offset = VAR_32;\n\n                /* COMMENT_25 */\n                if (VAR_12->flags & VAR_33) {\n                    if (VAR_8 == VAR_34) {\n                        /* COMMENT_26 */\n                        VAR_1->replist = DetectReplaceAddToList(VAR_1->replist, VAR_15, VAR_12);\n                    } else {\n                        SCLogWarning(VAR_35, \"Can't modify payload without packet\");\n                    }\n                }\n                if (!(VAR_12->flags & VAR_36)) {\n                    SCLogDebug(\"no relative match coming up, so this is a match\");\n                    goto match;\n                }\n\n                /* COMMENT_27 */\n                                                                                \n                               \n                if (VAR_3->is_last) {\n                    goto no_match;\n                }\n\n                SCLogDebug(\"content %\"VAR_13, VAR_12->id);\n                KEYWORD_PROFILING_END(VAR_1, VAR_3->type, 1);\n\n                /* COMMENT_30 */\n                                                                       \n                                                                          \n                int VAR_37 = DetectEngineContentInspection(VAR_0, VAR_1, VAR_2, VAR_3+1,\n                        VAR_4, VAR_5, VAR_6, VAR_7, VAR_8, VAR_9);\n                if (VAR_37 == 1) {\n                    SCReturnInt(1);\n                }\n\n                if (VAR_1->discontinue_matching)\n                    goto no_match;\n\n                /* COMMENT_33 */\n                VAR_18 = (VAR_32 - (VAR_12->content_len - 1));\n                SCLogDebug(\"trying to see if there is another match after prev_offset %\"VAR_13, VAR_18);\n            }\n\n        } while(1);\n\n    } else if (VAR_3->type == VAR_38) {\n        SCLogDebug(\"inspecting isdataat\");\n\n        DetectIsdataatData *VAR_39 = (DetectIsdataatData *)VAR_3->ctx;\n        if (VAR_39->flags & VAR_40) {\n            if (VAR_1->buffer_offset + VAR_39->dataat > VAR_6) {\n                SCLogDebug(\"det_ctx->buffer_offset + id->dataat %\"VAR_13\" > %\"VAR_13, VAR_1->buffer_offset + VAR_39->dataat, VAR_6);\n                if (VAR_39->flags & VAR_41)\n                    goto match;\n                goto no_match;\n            } else {\n                SCLogDebug(\"relative isdataat match\");\n                if (VAR_39->flags & VAR_41)\n                    goto no_match;\n                goto match;\n            }\n        } else {\n            if (VAR_39->dataat < VAR_6) {\n                SCLogDebug(\"absolute isdataat match\");\n                if (VAR_39->flags & VAR_41)\n                    goto no_match;\n                goto match;\n            } else {\n                SCLogDebug(\"absolute isdataat mismatch, id->isdataat %\"VAR_13\", buffer_len %\"VAR_13\"\", VAR_39->dataat, VAR_6);\n                if (VAR_39->flags & VAR_41)\n                    goto match;\n                goto no_match;\n            }\n        }\n\n    } else if (VAR_3->type == VAR_42) {\n        SCLogDebug(\"inspecting pcre\");\n        DetectPcreData *VAR_43 = (DetectPcreData *)VAR_3->ctx;\n        uint32_t VAR_19 = VAR_1->buffer_offset;\n        uint32_t VAR_18 = 0;\n        int VAR_37 = 0;\n\n        VAR_1->pcre_match_start_offset = 0;\n        do {\n            Packet *VAR_44 = NULL;\n            if (VAR_8 == VAR_34)\n                VAR_44 = (Packet *)VAR_9;\n            VAR_37 = DetectPcrePayloadMatch(VAR_1, VAR_2, VAR_3, VAR_44, VAR_4,\n                                       VAR_5, VAR_6);\n            if (VAR_37 == 0) {\n                goto no_match;\n            }\n\n            if (!(VAR_43->flags & VAR_45)) {\n                SCLogDebug(\"no relative match coming up, so this is a match\");\n                goto match;\n            }\n            KEYWORD_PROFILING_END(VAR_1, VAR_3->type, 1);\n\n            /* COMMENT_34 */\n            VAR_18 = VAR_1->pcre_match_start_offset;\n\n            /* COMMENT_35 */\n                                                                \n                                                                  \n            VAR_37 = DetectEngineContentInspection(VAR_0, VAR_1, VAR_2, VAR_3+1,\n                    VAR_4, VAR_5, VAR_6, VAR_7, VAR_8, VAR_9);\n            if (VAR_37 == 1) {\n                SCReturnInt(1);\n            }\n\n            if (VAR_1->discontinue_matching)\n                goto no_match;\n\n            VAR_1->buffer_offset = VAR_19;\n            VAR_1->pcre_match_start_offset = VAR_18;\n        } while (1);\n\n    } else if (VAR_3->type == VAR_46) {\n        DetectBytetestData *VAR_47 = (DetectBytetestData *)VAR_3->ctx;\n        uint8_t VAR_48 = VAR_47->flags;\n        int32_t VAR_16 = VAR_47->offset;\n        uint64_t VAR_49 = VAR_47->value;\n        if (VAR_48 & VAR_50) {\n            VAR_16 = VAR_1->bj_values[VAR_16];\n        }\n        if (VAR_48 & VAR_51) {\n            VAR_49 = VAR_1->bj_values[VAR_49];\n        }\n\n        /* COMMENT_38 */\n                                         \n        if (VAR_48 & VAR_52 && VAR_9 != NULL) {\n            DCERPCState *VAR_53 = (DCERPCState *)VAR_9;\n            /* COMMENT_40 */\n                                                                    \n            VAR_48 |= ((VAR_53->dcerpc.dcerpchdr.packed_drep[0] & 0x10) ?\n                      VAR_54: 0);\n        }\n\n        if (DetectBytetestDoMatch(VAR_1, VAR_2, VAR_3->ctx, VAR_5, VAR_6, VAR_48,\n                                  VAR_16, VAR_49) != 1) {\n            goto no_match;\n        }\n\n        goto match;\n\n    } else if (VAR_3->type == VAR_55) {\n        DetectBytejumpData *VAR_56 = (DetectBytejumpData *)VAR_3->ctx;\n        uint8_t VAR_48 = VAR_56->flags;\n        int32_t VAR_16 = VAR_56->offset;\n\n        if (VAR_48 & VAR_57) {\n            VAR_16 = VAR_1->bj_values[VAR_16];\n        }\n\n        /* COMMENT_42 */\n                                         \n        if (VAR_48 & VAR_58 && VAR_9 != NULL) {\n            DCERPCState *VAR_53 = (DCERPCState *)VAR_9;\n            /* COMMENT_44 */\n                                                                    \n            VAR_48 |= ((VAR_53->dcerpc.dcerpchdr.packed_drep[0] & 0x10) ?\n                      VAR_59: 0);\n        }\n\n        if (DetectBytejumpDoMatch(VAR_1, VAR_2, VAR_3->ctx, VAR_5, VAR_6,\n                                  VAR_48, VAR_16) != 1) {\n            goto no_match;\n        }\n\n        goto match;\n\n    } else if (VAR_3->type == VAR_60) {\n\n        DetectByteExtractData *VAR_61 = (DetectByteExtractData *)VAR_3->ctx;\n        uint8_t VAR_62 = VAR_61->endian;\n\n        /* COMMENT_46 */\n                                         \n        if ((VAR_61->flags & VAR_63) &&\n            VAR_62 == VAR_64 && VAR_9 != NULL) {\n\n            DCERPCState *VAR_53 = (DCERPCState *)VAR_9;\n            /* COMMENT_48 */\n                                                                    \n            VAR_62 |= ((VAR_53->dcerpc.dcerpchdr.packed_drep[0] == 0x10) ?\n                       VAR_65 : VAR_66);\n        }\n\n        if (DetectByteExtractDoMatch(VAR_1, VAR_3, VAR_2, VAR_5,\n                                     VAR_6,\n                                     &VAR_1->bj_values[VAR_61->local_id],\n                                     VAR_62) != 1) {\n            goto no_match;\n        }\n\n        goto match;\n\n        /* COMMENT_50 */\n    } else if (VAR_3->type == VAR_67) {\n        SCLogDebug(\"inspecting uri len\");\n\n        int VAR_37 = 0;\n        DetectUrilenData *VAR_68 = (DetectUrilenData *) VAR_3->ctx;\n\n        switch (VAR_68->mode) {\n            case VAR_69:\n                if (VAR_6 == VAR_68->urilen1)\n                    VAR_37 = 1;\n                break;\n            case VAR_70:\n                if (VAR_6 < VAR_68->urilen1)\n                    VAR_37 = 1;\n                break;\n            case VAR_71:\n                if (VAR_6 > VAR_68->urilen1)\n                    VAR_37 = 1;\n                break;\n            case VAR_72:\n                if (VAR_6 > VAR_68->urilen1 &&\n                    VAR_6 < VAR_68->urilen2) {\n                    VAR_37 = 1;\n                }\n                break;\n        }\n\n        if (VAR_37 == 1) {\n            goto match;\n        }\n\n        VAR_1->discontinue_matching = 0;\n\n        goto no_match;\n#ifdef VAR_73\n    }\n    else if (VAR_3->type == VAR_74) {\n        SCLogDebug(\"lua starting\");\n\n        if (DetectLuaMatchBuffer(VAR_1, VAR_2, VAR_3, VAR_5, VAR_6,\n                    VAR_1->buffer_offset, VAR_4) != 1)\n        {\n            SCLogDebug(\"lua no_match\");\n            goto no_match;\n        }\n        SCLogDebug(\"lua match\");\n        goto match;\n#endif/* COMMENT_51 */\n    } else if (smd->type == DETECT_BASE64_DECODE) {\n        if (DetectBase64DecodeDoMatch(VAR_1, VAR_2, VAR_3, VAR_5, VAR_6)) {\n            if (VAR_2->sm_arrays[VAR_75] != NULL) {\n                KEYWORD_PROFILING_END(VAR_1, VAR_3->type, 1);\n                if (DetectBase64DataDoMatch(VAR_0, VAR_1, VAR_2, VAR_4)) {\n                    /* COMMENT_52 */\n                    goto final_match;\n                }\n            }\n        }\n    } else {\n        SCLogDebug(\"sm->type %u\", VAR_3->type);\n#ifdef VAR_14\n        BUG_ON(1);\n#endif\n    }\n\nno_match:\n    KEYWORD_PROFILING_END(VAR_1, VAR_3->type, 0);\n    SCReturnInt(0);\n\nmatch:\n    /* COMMENT_53 */\n                                                      \n    if (!VAR_3->is_last) {\n        KEYWORD_PROFILING_END(VAR_1, VAR_3->type, 1);\n        int VAR_37 = DetectEngineContentInspection(VAR_0, VAR_1, VAR_2, VAR_3+1,\n                VAR_4, VAR_5, VAR_6, VAR_7, VAR_8, VAR_9);\n        SCReturnInt(VAR_37);\n    }\nfinal_match:\n    KEYWORD_PROFILING_END(VAR_1, VAR_3->type, 1);\n    SCReturnInt(1);\n}",
  "func_graph_path_before": "OISF/suricata/b9579fbe7dd408200ef03cbe20efddb624b73885/detect-engine-content-inspection.c/vul/before/0.json",
  "func": "int DetectEngineContentInspection(DetectEngineCtx *de_ctx, DetectEngineThreadCtx *det_ctx,\n                                  const Signature *s, const SigMatchData *smd,\n                                  Flow *f,\n                                  uint8_t *buffer, uint32_t buffer_len,\n                                  uint32_t stream_start_offset,\n                                  uint8_t inspection_mode, void *data)\n{\n    SCEnter();\n    KEYWORD_PROFILING_START;\n\n    det_ctx->inspection_recursion_counter++;\n\n    if (det_ctx->inspection_recursion_counter == de_ctx->inspection_recursion_limit) {\n        det_ctx->discontinue_matching = 1;\n        KEYWORD_PROFILING_END(det_ctx, smd->type, 0);\n        SCReturnInt(0);\n    }\n\n    if (smd == NULL || buffer_len == 0) {\n        KEYWORD_PROFILING_END(det_ctx, smd->type, 0);\n        SCReturnInt(0);\n    }\n\n    /* \\todo unify this which is phase 2 of payload inspection unification */\n    if (smd->type == DETECT_CONTENT) {\n\n        DetectContentData *cd = (DetectContentData *)smd->ctx;\n        SCLogDebug(\"inspecting content %\"PRIu32\" buffer_len %\"PRIu32, cd->id, buffer_len);\n\n        /* we might have already have this content matched by the mpm.\n         * (if there is any other reason why we'd want to avoid checking\n         *  it here, please fill it in) */\n        //if (cd->flags & DETECT_CONTENT_NO_DOUBLE_INSPECTION_REQUIRED) {\n        //    goto match;\n        //}\n\n        /* rule parsers should take care of this */\n#ifdef DEBUG\n        BUG_ON(cd->depth != 0 && cd->depth <= cd->offset);\n#endif\n\n        /* search for our pattern, checking the matches recursively.\n         * if we match we look for the next SigMatch as well */\n        uint8_t *found = NULL;\n        uint32_t offset = 0;\n        uint32_t depth = buffer_len;\n        uint32_t prev_offset = 0; /**< used in recursive searching */\n        uint32_t prev_buffer_offset = det_ctx->buffer_offset;\n\n        do {\n            if ((cd->flags & DETECT_CONTENT_DISTANCE) ||\n                (cd->flags & DETECT_CONTENT_WITHIN)) {\n                SCLogDebug(\"det_ctx->buffer_offset %\"PRIu32, det_ctx->buffer_offset);\n\n                offset = prev_buffer_offset;\n                depth = buffer_len;\n\n                int distance = cd->distance;\n                if (cd->flags & DETECT_CONTENT_DISTANCE) {\n                    if (cd->flags & DETECT_CONTENT_DISTANCE_BE) {\n                        distance = det_ctx->bj_values[cd->distance];\n                    }\n                    if (distance < 0 && (uint32_t)(abs(distance)) > offset)\n                        offset = 0;\n                    else\n                        offset += distance;\n\n                    SCLogDebug(\"cd->distance %\"PRIi32\", offset %\"PRIu32\", depth %\"PRIu32,\n                               distance, offset, depth);\n                }\n\n                if (cd->flags & DETECT_CONTENT_WITHIN) {\n                    if (cd->flags & DETECT_CONTENT_WITHIN_BE) {\n                        if ((int32_t)depth > (int32_t)(prev_buffer_offset + det_ctx->bj_values[cd->within] + distance)) {\n                            depth = prev_buffer_offset + det_ctx->bj_values[cd->within] + distance;\n                        }\n                    } else {\n                        if ((int32_t)depth > (int32_t)(prev_buffer_offset + cd->within + distance)) {\n                            depth = prev_buffer_offset + cd->within + distance;\n                        }\n\n                        SCLogDebug(\"cd->within %\"PRIi32\", det_ctx->buffer_offset %\"PRIu32\", depth %\"PRIu32,\n                                   cd->within, prev_buffer_offset, depth);\n                    }\n\n                    if (stream_start_offset != 0 && prev_buffer_offset == 0) {\n                        if (depth <= stream_start_offset) {\n                            goto no_match;\n                        } else if (depth >= (stream_start_offset + buffer_len)) {\n                            ;\n                        } else {\n                            depth = depth - stream_start_offset;\n                        }\n                    }\n                }\n\n                if (cd->flags & DETECT_CONTENT_DEPTH_BE) {\n                    if ((det_ctx->bj_values[cd->depth] + prev_buffer_offset) < depth) {\n                        depth = prev_buffer_offset + det_ctx->bj_values[cd->depth];\n                    }\n                } else {\n                    if (cd->depth != 0) {\n                        if ((cd->depth + prev_buffer_offset) < depth) {\n                            depth = prev_buffer_offset + cd->depth;\n                        }\n\n                        SCLogDebug(\"cd->depth %\"PRIu32\", depth %\"PRIu32, cd->depth, depth);\n                    }\n                }\n\n                if (cd->flags & DETECT_CONTENT_OFFSET_BE) {\n                    if (det_ctx->bj_values[cd->offset] > offset)\n                        offset = det_ctx->bj_values[cd->offset];\n                } else {\n                    if (cd->offset > offset) {\n                        offset = cd->offset;\n                        SCLogDebug(\"setting offset %\"PRIu32, offset);\n                    }\n                }\n            } else { /* implied no relative matches */\n                /* set depth */\n                if (cd->flags & DETECT_CONTENT_DEPTH_BE) {\n                    depth = det_ctx->bj_values[cd->depth];\n                } else {\n                    if (cd->depth != 0) {\n                        depth = cd->depth;\n                    }\n                }\n\n                if (stream_start_offset != 0 && cd->flags & DETECT_CONTENT_DEPTH) {\n                    if (depth <= stream_start_offset) {\n                        goto no_match;\n                    } else if (depth >= (stream_start_offset + buffer_len)) {\n                        ;\n                    } else {\n                        depth = depth - stream_start_offset;\n                    }\n                }\n\n                /* set offset */\n                if (cd->flags & DETECT_CONTENT_OFFSET_BE)\n                    offset = det_ctx->bj_values[cd->offset];\n                else\n                    offset = cd->offset;\n                prev_buffer_offset = 0;\n            }\n\n            /* update offset with prev_offset if we're searching for\n             * matches after the first occurence. */\n            SCLogDebug(\"offset %\"PRIu32\", prev_offset %\"PRIu32, offset, prev_offset);\n            if (prev_offset != 0)\n                offset = prev_offset;\n\n            SCLogDebug(\"offset %\"PRIu32\", depth %\"PRIu32, offset, depth);\n\n            if (depth > buffer_len)\n                depth = buffer_len;\n\n            /* if offset is bigger than depth we can never match on a pattern.\n             * We can however, \"match\" on a negated pattern. */\n            if (offset > depth || depth == 0) {\n                if (cd->flags & DETECT_CONTENT_NEGATED) {\n                    goto match;\n                } else {\n                    goto no_match;\n                }\n            }\n\n            uint8_t *sbuffer = buffer + offset;\n            uint32_t sbuffer_len = depth - offset;\n            uint32_t match_offset = 0;\n            SCLogDebug(\"sbuffer_len %\"PRIu32, sbuffer_len);\n#ifdef DEBUG\n            BUG_ON(sbuffer_len > buffer_len);\n#endif\n\n            /* \\todo Add another optimization here.  If cd->content_len is\n             * greater than sbuffer_len found is anyways NULL */\n\n            /* do the actual search */\n            found = SpmScan(cd->spm_ctx, det_ctx->spm_thread_ctx, sbuffer,\n                            sbuffer_len);\n\n            /* next we evaluate the result in combination with the\n             * negation flag. */\n            SCLogDebug(\"found %p cd negated %s\", found, cd->flags & DETECT_CONTENT_NEGATED ? \"true\" : \"false\");\n\n            if (found == NULL && !(cd->flags & DETECT_CONTENT_NEGATED)) {\n                if ((cd->flags & (DETECT_CONTENT_DISTANCE|DETECT_CONTENT_WITHIN)) == 0) {\n                    /* independent match from previous matches, so failure is fatal */\n                    det_ctx->discontinue_matching = 1;\n                }\n\n                goto no_match;\n            } else if (found == NULL && (cd->flags & DETECT_CONTENT_NEGATED)) {\n                goto match;\n            } else if (found != NULL && (cd->flags & DETECT_CONTENT_NEGATED)) {\n                SCLogDebug(\"content %\"PRIu32\" matched at offset %\"PRIu32\", but negated so no match\", cd->id, match_offset);\n                /* don't bother carrying recursive matches now, for preceding\n                 * relative keywords */\n                if (DETECT_CONTENT_IS_SINGLE(cd))\n                    det_ctx->discontinue_matching = 1;\n                goto no_match;\n            } else {\n                match_offset = (uint32_t)((found - buffer) + cd->content_len);\n                SCLogDebug(\"content %\"PRIu32\" matched at offset %\"PRIu32\"\", cd->id, match_offset);\n                det_ctx->buffer_offset = match_offset;\n\n                /* Match branch, add replace to the list if needed */\n                if (cd->flags & DETECT_CONTENT_REPLACE) {\n                    if (inspection_mode == DETECT_ENGINE_CONTENT_INSPECTION_MODE_PAYLOAD) {\n                        /* we will need to replace content if match is confirmed */\n                        det_ctx->replist = DetectReplaceAddToList(det_ctx->replist, found, cd);\n                    } else {\n                        SCLogWarning(SC_ERR_INVALID_VALUE, \"Can't modify payload without packet\");\n                    }\n                }\n\n                /* if this is the last match we're done */\n                if (smd->is_last) {\n                    goto match;\n                }\n\n                SCLogDebug(\"content %\"PRIu32, cd->id);\n                KEYWORD_PROFILING_END(det_ctx, smd->type, 1);\n\n                /* see if the next buffer keywords match. If not, we will\n                 * search for another occurence of this content and see\n                 * if the others match then until we run out of matches */\n                int r = DetectEngineContentInspection(de_ctx, det_ctx, s, smd+1,\n                        f, buffer, buffer_len, stream_start_offset, inspection_mode, data);\n                if (r == 1) {\n                    SCReturnInt(1);\n                }\n                SCLogDebug(\"no match for 'next sm'\");\n\n                if (det_ctx->discontinue_matching) {\n                    SCLogDebug(\"'next sm' said to discontinue this right now\");\n                    goto no_match;\n                }\n\n                /* no match and no reason to look for another instance */\n                if ((cd->flags & DETECT_CONTENT_RELATIVE_NEXT) == 0) {\n                    SCLogDebug(\"'next sm' does not depend on me, so we can give up\");\n                    det_ctx->discontinue_matching = 1;\n                    goto no_match;\n                }\n\n                SCLogDebug(\"'next sm' depends on me %p, lets see what we can do (flags %u)\", cd, cd->flags);\n\n                /* set the previous match offset to the start of this match + 1 */\n                prev_offset = (match_offset - (cd->content_len - 1));\n                SCLogDebug(\"trying to see if there is another match after prev_offset %\"PRIu32, prev_offset);\n            }\n\n        } while(1);\n\n    } else if (smd->type == DETECT_ISDATAAT) {\n        SCLogDebug(\"inspecting isdataat\");\n\n        DetectIsdataatData *id = (DetectIsdataatData *)smd->ctx;\n        if (id->flags & ISDATAAT_RELATIVE) {\n            if (det_ctx->buffer_offset + id->dataat > buffer_len) {\n                SCLogDebug(\"det_ctx->buffer_offset + id->dataat %\"PRIu32\" > %\"PRIu32, det_ctx->buffer_offset + id->dataat, buffer_len);\n                if (id->flags & ISDATAAT_NEGATED)\n                    goto match;\n                goto no_match;\n            } else {\n                SCLogDebug(\"relative isdataat match\");\n                if (id->flags & ISDATAAT_NEGATED)\n                    goto no_match;\n                goto match;\n            }\n        } else {\n            if (id->dataat < buffer_len) {\n                SCLogDebug(\"absolute isdataat match\");\n                if (id->flags & ISDATAAT_NEGATED)\n                    goto no_match;\n                goto match;\n            } else {\n                SCLogDebug(\"absolute isdataat mismatch, id->isdataat %\"PRIu32\", buffer_len %\"PRIu32\"\", id->dataat, buffer_len);\n                if (id->flags & ISDATAAT_NEGATED)\n                    goto match;\n                goto no_match;\n            }\n        }\n\n    } else if (smd->type == DETECT_PCRE) {\n        SCLogDebug(\"inspecting pcre\");\n        DetectPcreData *pe = (DetectPcreData *)smd->ctx;\n        uint32_t prev_buffer_offset = det_ctx->buffer_offset;\n        uint32_t prev_offset = 0;\n        int r = 0;\n\n        det_ctx->pcre_match_start_offset = 0;\n        do {\n            Packet *p = NULL;\n            if (inspection_mode == DETECT_ENGINE_CONTENT_INSPECTION_MODE_PAYLOAD)\n                p = (Packet *)data;\n            r = DetectPcrePayloadMatch(det_ctx, s, smd, p, f,\n                                       buffer, buffer_len);\n            if (r == 0) {\n                goto no_match;\n            }\n\n            if (!(pe->flags & DETECT_PCRE_RELATIVE_NEXT)) {\n                SCLogDebug(\"no relative match coming up, so this is a match\");\n                goto match;\n            }\n            KEYWORD_PROFILING_END(det_ctx, smd->type, 1);\n\n            /* save it, in case we need to do a pcre match once again */\n            prev_offset = det_ctx->pcre_match_start_offset;\n\n            /* see if the next payload keywords match. If not, we will\n             * search for another occurence of this pcre and see\n             * if the others match, until we run out of matches */\n            r = DetectEngineContentInspection(de_ctx, det_ctx, s, smd+1,\n                    f, buffer, buffer_len, stream_start_offset, inspection_mode, data);\n            if (r == 1) {\n                SCReturnInt(1);\n            }\n\n            if (det_ctx->discontinue_matching)\n                goto no_match;\n\n            det_ctx->buffer_offset = prev_buffer_offset;\n            det_ctx->pcre_match_start_offset = prev_offset;\n        } while (1);\n\n    } else if (smd->type == DETECT_BYTETEST) {\n        DetectBytetestData *btd = (DetectBytetestData *)smd->ctx;\n        uint8_t flags = btd->flags;\n        int32_t offset = btd->offset;\n        uint64_t value = btd->value;\n        if (flags & DETECT_BYTETEST_OFFSET_BE) {\n            offset = det_ctx->bj_values[offset];\n        }\n        if (flags & DETECT_BYTETEST_VALUE_BE) {\n            value = det_ctx->bj_values[value];\n        }\n\n        /* if we have dce enabled we will have to use the endianness\n         * specified by the dce header */\n        if (flags & DETECT_BYTETEST_DCE && data != NULL) {\n            DCERPCState *dcerpc_state = (DCERPCState *)data;\n            /* enable the endianness flag temporarily.  once we are done\n             * processing we reset the flags to the original value*/\n            flags |= ((dcerpc_state->dcerpc.dcerpchdr.packed_drep[0] & 0x10) ?\n                      DETECT_BYTETEST_LITTLE: 0);\n        }\n\n        if (DetectBytetestDoMatch(det_ctx, s, smd->ctx, buffer, buffer_len, flags,\n                                  offset, value) != 1) {\n            goto no_match;\n        }\n\n        goto match;\n\n    } else if (smd->type == DETECT_BYTEJUMP) {\n        DetectBytejumpData *bjd = (DetectBytejumpData *)smd->ctx;\n        uint8_t flags = bjd->flags;\n        int32_t offset = bjd->offset;\n\n        if (flags & DETECT_BYTEJUMP_OFFSET_BE) {\n            offset = det_ctx->bj_values[offset];\n        }\n\n        /* if we have dce enabled we will have to use the endianness\n         * specified by the dce header */\n        if (flags & DETECT_BYTEJUMP_DCE && data != NULL) {\n            DCERPCState *dcerpc_state = (DCERPCState *)data;\n            /* enable the endianness flag temporarily.  once we are done\n             * processing we reset the flags to the original value*/\n            flags |= ((dcerpc_state->dcerpc.dcerpchdr.packed_drep[0] & 0x10) ?\n                      DETECT_BYTEJUMP_LITTLE: 0);\n        }\n\n        if (DetectBytejumpDoMatch(det_ctx, s, smd->ctx, buffer, buffer_len,\n                                  flags, offset) != 1) {\n            goto no_match;\n        }\n\n        goto match;\n\n    } else if (smd->type == DETECT_BYTE_EXTRACT) {\n\n        DetectByteExtractData *bed = (DetectByteExtractData *)smd->ctx;\n        uint8_t endian = bed->endian;\n\n        /* if we have dce enabled we will have to use the endianness\n         * specified by the dce header */\n        if ((bed->flags & DETECT_BYTE_EXTRACT_FLAG_ENDIAN) &&\n            endian == DETECT_BYTE_EXTRACT_ENDIAN_DCE && data != NULL) {\n\n            DCERPCState *dcerpc_state = (DCERPCState *)data;\n            /* enable the endianness flag temporarily.  once we are done\n             * processing we reset the flags to the original value*/\n            endian |= ((dcerpc_state->dcerpc.dcerpchdr.packed_drep[0] == 0x10) ?\n                       DETECT_BYTE_EXTRACT_ENDIAN_LITTLE : DETECT_BYTE_EXTRACT_ENDIAN_BIG);\n        }\n\n        if (DetectByteExtractDoMatch(det_ctx, smd, s, buffer,\n                                     buffer_len,\n                                     &det_ctx->bj_values[bed->local_id],\n                                     endian) != 1) {\n            goto no_match;\n        }\n\n        goto match;\n\n        /* we should never get here, but bail out just in case */\n    } else if (smd->type == DETECT_AL_URILEN) {\n        SCLogDebug(\"inspecting uri len\");\n\n        int r = 0;\n        DetectUrilenData *urilend = (DetectUrilenData *) smd->ctx;\n\n        switch (urilend->mode) {\n            case DETECT_URILEN_EQ:\n                if (buffer_len == urilend->urilen1)\n                    r = 1;\n                break;\n            case DETECT_URILEN_LT:\n                if (buffer_len < urilend->urilen1)\n                    r = 1;\n                break;\n            case DETECT_URILEN_GT:\n                if (buffer_len > urilend->urilen1)\n                    r = 1;\n                break;\n            case DETECT_URILEN_RA:\n                if (buffer_len > urilend->urilen1 &&\n                    buffer_len < urilend->urilen2) {\n                    r = 1;\n                }\n                break;\n        }\n\n        if (r == 1) {\n            goto match;\n        }\n\n        det_ctx->discontinue_matching = 0;\n\n        goto no_match;\n#ifdef HAVE_LUA\n    }\n    else if (smd->type == DETECT_LUA) {\n        SCLogDebug(\"lua starting\");\n\n        if (DetectLuaMatchBuffer(det_ctx, s, smd, buffer, buffer_len,\n                    det_ctx->buffer_offset, f) != 1)\n        {\n            SCLogDebug(\"lua no_match\");\n            goto no_match;\n        }\n        SCLogDebug(\"lua match\");\n        goto match;\n#endif /* HAVE_LUA */\n    } else if (smd->type == DETECT_BASE64_DECODE) {\n        if (DetectBase64DecodeDoMatch(det_ctx, s, smd, buffer, buffer_len)) {\n            if (s->sm_arrays[DETECT_SM_LIST_BASE64_DATA] != NULL) {\n                KEYWORD_PROFILING_END(det_ctx, smd->type, 1);\n                if (DetectBase64DataDoMatch(de_ctx, det_ctx, s, f)) {\n                    /* Base64 is a terminal list. */\n                    goto final_match;\n                }\n            }\n        }\n    } else {\n        SCLogDebug(\"sm->type %u\", smd->type);\n#ifdef DEBUG\n        BUG_ON(1);\n#endif\n    }\n\nno_match:\n    KEYWORD_PROFILING_END(det_ctx, smd->type, 0);\n    SCReturnInt(0);\n\nmatch:\n    /* this sigmatch matched, inspect the next one. If it was the last,\n     * the buffer portion of the signature matched. */\n    if (!smd->is_last) {\n        KEYWORD_PROFILING_END(det_ctx, smd->type, 1);\n        int r = DetectEngineContentInspection(de_ctx, det_ctx, s, smd+1,\n                f, buffer, buffer_len, stream_start_offset, inspection_mode, data);\n        SCReturnInt(r);\n    }\nfinal_match:\n    KEYWORD_PROFILING_END(det_ctx, smd->type, 1);\n    SCReturnInt(1);\n}",
  "abstract_func": "int DetectEngineContentInspection(DetectEngineCtx *VAR_0, DetectEngineThreadCtx *VAR_1,\n                                  const Signature *VAR_2, const SigMatchData *VAR_3,\n                                  Flow *VAR_4,\n                                  uint8_t *VAR_5, uint32_t VAR_6,\n                                  uint32_t VAR_7,\n                                  uint8_t VAR_8, void *VAR_9)\n{\n    SCEnter();\n    VAR_10;\n\n    VAR_1->inspection_recursion_counter++;\n\n    if (VAR_1->inspection_recursion_counter == VAR_0->inspection_recursion_limit) {\n        VAR_1->discontinue_matching = 1;\n        KEYWORD_PROFILING_END(VAR_1, VAR_3->type, 0);\n        SCReturnInt(0);\n    }\n\n    if (VAR_3 == NULL || VAR_6 == 0) {\n        KEYWORD_PROFILING_END(VAR_1, VAR_3->type, 0);\n        SCReturnInt(0);\n    }\n\n    /* COMMENT_0 */\n    if (VAR_3->type == VAR_11) {\n\n        DetectContentData *VAR_12 = (DetectContentData *)VAR_3->ctx;\n        SCLogDebug(\"inspecting content %\"VAR_13\" buffer_len %\"VAR_13, VAR_12->id, VAR_6);\n\n        /* COMMENT_1 */\n                                                                        \n                                          \n        /* COMMENT_4 */\n        /* COMMENT_5 */\n        /* COMMENT_6 */\n\n        /* COMMENT_7 */\n#ifdef VAR_14\n        BUG_ON(VAR_12->depth != 0 && VAR_12->depth <= VAR_12->offset);\n#endif\n\n        /* COMMENT_8 */\n                                                               \n        uint8_t *VAR_15 = NULL;\n        uint32_t VAR_16 = 0;\n        uint32_t VAR_17 = VAR_6;\n        uint32_t VAR_18 = 0; /* COMMENT_10 */\n        uint32_t VAR_19 = VAR_1->buffer_offset;\n\n        do {\n            if ((VAR_12->flags & VAR_20) ||\n                (VAR_12->flags & VAR_21)) {\n                SCLogDebug(\"det_ctx->buffer_offset %\"VAR_13, VAR_1->buffer_offset);\n\n                VAR_16 = VAR_19;\n                VAR_17 = VAR_6;\n\n                int VAR_22 = VAR_12->distance;\n                if (VAR_12->flags & VAR_20) {\n                    if (VAR_12->flags & VAR_23) {\n                        VAR_22 = VAR_1->bj_values[VAR_12->distance];\n                    }\n                    if (VAR_22 < 0 && (uint32_t)(abs(VAR_22)) > VAR_16)\n                        VAR_16 = 0;\n                    else\n                        VAR_16 += VAR_22;\n\n                    SCLogDebug(\"cd->distance %\"VAR_24\", offset %\"VAR_13\", depth %\"VAR_13,\n                               VAR_22, VAR_16, VAR_17);\n                }\n\n                if (VAR_12->flags & VAR_21) {\n                    if (VAR_12->flags & VAR_25) {\n                        if ((int32_t)VAR_17 > (int32_t)(VAR_19 + VAR_1->bj_values[VAR_12->within] + VAR_22)) {\n                            VAR_17 = VAR_19 + VAR_1->bj_values[VAR_12->within] + VAR_22;\n                        }\n                    } else {\n                        if ((int32_t)VAR_17 > (int32_t)(VAR_19 + VAR_12->within + VAR_22)) {\n                            VAR_17 = VAR_19 + VAR_12->within + VAR_22;\n                        }\n\n                        SCLogDebug(\"cd->within %\"VAR_24\", det_ctx->buffer_offset %\"VAR_13\", depth %\"VAR_13,\n                                   VAR_12->within, VAR_19, VAR_17);\n                    }\n\n                    if (VAR_7 != 0 && VAR_19 == 0) {\n                        if (VAR_17 <= VAR_7) {\n                            goto no_match;\n                        } else if (VAR_17 >= (VAR_7 + VAR_6)) {\n                            ;\n                        } else {\n                            VAR_17 = VAR_17 - VAR_7;\n                        }\n                    }\n                }\n\n                if (VAR_12->flags & VAR_26) {\n                    if ((VAR_1->bj_values[VAR_12->depth] + VAR_19) < VAR_17) {\n                        VAR_17 = VAR_19 + VAR_1->bj_values[VAR_12->depth];\n                    }\n                } else {\n                    if (VAR_12->depth != 0) {\n                        if ((VAR_12->depth + VAR_19) < VAR_17) {\n                            VAR_17 = VAR_19 + VAR_12->depth;\n                        }\n\n                        SCLogDebug(\"cd->depth %\"VAR_13\", depth %\"VAR_13, VAR_12->depth, VAR_17);\n                    }\n                }\n\n                if (VAR_12->flags & VAR_27) {\n                    if (VAR_1->bj_values[VAR_12->offset] > VAR_16)\n                        VAR_16 = VAR_1->bj_values[VAR_12->offset];\n                } else {\n                    if (VAR_12->offset > VAR_16) {\n                        VAR_16 = VAR_12->offset;\n                        SCLogDebug(\"setting offset %\"VAR_13, VAR_16);\n                    }\n                }\n            } else { /* COMMENT_11 */\n                /* COMMENT_12 */\n                if (VAR_12->flags & VAR_26) {\n                    VAR_17 = VAR_1->bj_values[VAR_12->depth];\n                } else {\n                    if (VAR_12->depth != 0) {\n                        VAR_17 = VAR_12->depth;\n                    }\n                }\n\n                if (VAR_7 != 0 && VAR_12->flags & VAR_28) {\n                    if (VAR_17 <= VAR_7) {\n                        goto no_match;\n                    } else if (VAR_17 >= (VAR_7 + VAR_6)) {\n                        ;\n                    } else {\n                        VAR_17 = VAR_17 - VAR_7;\n                    }\n                }\n\n                /* COMMENT_13 */\n                if (VAR_12->flags & VAR_27)\n                    VAR_16 = VAR_1->bj_values[VAR_12->offset];\n                else\n                    VAR_16 = VAR_12->offset;\n                VAR_19 = 0;\n            }\n\n            /* COMMENT_14 */\n                                                    \n            SCLogDebug(\"offset %\"VAR_13\", prev_offset %\"VAR_13, VAR_16, VAR_18);\n            if (VAR_18 != 0)\n                VAR_16 = VAR_18;\n\n            SCLogDebug(\"offset %\"VAR_13\", depth %\"VAR_13, VAR_16, VAR_17);\n\n            if (VAR_17 > VAR_6)\n                VAR_17 = VAR_6;\n\n            /* COMMENT_16 */\n                                                               \n            if (VAR_16 > VAR_17 || VAR_17 == 0) {\n                if (VAR_12->flags & VAR_29) {\n                    goto match;\n                } else {\n                    goto no_match;\n                }\n            }\n\n            uint8_t *VAR_30 = VAR_5 + VAR_16;\n            uint32_t VAR_31 = VAR_17 - VAR_16;\n            uint32_t VAR_32 = 0;\n            SCLogDebug(\"sbuffer_len %\"VAR_13, VAR_31);\n#ifdef VAR_14\n            BUG_ON(VAR_31 > VAR_6);\n#endif\n\n            /* COMMENT_18 */\n                                                                \n\n            /* COMMENT_20 */\n            VAR_15 = SpmScan(VAR_12->spm_ctx, VAR_1->spm_thread_ctx, VAR_30,\n                            VAR_31);\n\n            /* COMMENT_21 */\n                                \n            SCLogDebug(\"found %p cd negated %s\", VAR_15, VAR_12->flags & VAR_29 ? \"true\" : \"false\");\n\n            if (VAR_15 == NULL && !(VAR_12->flags & VAR_29)) {\n                if ((VAR_12->flags & (VAR_20|VAR_21)) == 0) {\n                    /* COMMENT_23 */\n                    VAR_1->discontinue_matching = 1;\n                }\n\n                goto no_match;\n            } else if (VAR_15 == NULL && (VAR_12->flags & VAR_29)) {\n                goto match;\n            } else if (VAR_15 != NULL && (VAR_12->flags & VAR_29)) {\n                SCLogDebug(\"content %\"VAR_13\" matched at offset %\"VAR_13\", but negated so no match\", VAR_12->id, VAR_32);\n                /* COMMENT_24 */\n                                       \n                if (DETECT_CONTENT_IS_SINGLE(VAR_12))\n                    VAR_1->discontinue_matching = 1;\n                goto no_match;\n            } else {\n                VAR_32 = (uint32_t)((VAR_15 - VAR_5) + VAR_12->content_len);\n                SCLogDebug(\"content %\"VAR_13\" matched at offset %\"VAR_13\"\", VAR_12->id, VAR_32);\n                VAR_1->buffer_offset = VAR_32;\n\n                /* COMMENT_26 */\n                if (VAR_12->flags & VAR_33) {\n                    if (VAR_8 == VAR_34) {\n                        /* COMMENT_27 */\n                        VAR_1->replist = DetectReplaceAddToList(VAR_1->replist, VAR_15, VAR_12);\n                    } else {\n                        SCLogWarning(VAR_35, \"Can't modify payload without packet\");\n                    }\n                }\n\n                /* COMMENT_28 */\n                if (VAR_3->is_last) {\n                    goto match;\n                }\n\n                SCLogDebug(\"content %\"VAR_13, VAR_12->id);\n                KEYWORD_PROFILING_END(VAR_1, VAR_3->type, 1);\n\n                /* COMMENT_29 */\n                                                                       \n                                                                          \n                int VAR_36 = DetectEngineContentInspection(VAR_0, VAR_1, VAR_2, VAR_3+1,\n                        VAR_4, VAR_5, VAR_6, VAR_7, VAR_8, VAR_9);\n                if (VAR_36 == 1) {\n                    SCReturnInt(1);\n                }\n                SCLogDebug(\"no match for 'next sm'\");\n\n                if (VAR_1->discontinue_matching) {\n                    SCLogDebug(\"'next sm' said to discontinue this right now\");\n                    goto no_match;\n                }\n\n                /* COMMENT_32 */\n                if ((VAR_12->flags & VAR_37) == 0) {\n                    SCLogDebug(\"'next sm' does not depend on me, so we can give up\");\n                    VAR_1->discontinue_matching = 1;\n                    goto no_match;\n                }\n\n                SCLogDebug(\"'next sm' depends on me %p, lets see what we can do (flags %u)\", VAR_12, VAR_12->flags);\n\n                /* COMMENT_33 */\n                VAR_18 = (VAR_32 - (VAR_12->content_len - 1));\n                SCLogDebug(\"trying to see if there is another match after prev_offset %\"VAR_13, VAR_18);\n            }\n\n        } while(1);\n\n    } else if (VAR_3->type == VAR_38) {\n        SCLogDebug(\"inspecting isdataat\");\n\n        DetectIsdataatData *VAR_39 = (DetectIsdataatData *)VAR_3->ctx;\n        if (VAR_39->flags & VAR_40) {\n            if (VAR_1->buffer_offset + VAR_39->dataat > VAR_6) {\n                SCLogDebug(\"det_ctx->buffer_offset + id->dataat %\"VAR_13\" > %\"VAR_13, VAR_1->buffer_offset + VAR_39->dataat, VAR_6);\n                if (VAR_39->flags & VAR_41)\n                    goto match;\n                goto no_match;\n            } else {\n                SCLogDebug(\"relative isdataat match\");\n                if (VAR_39->flags & VAR_41)\n                    goto no_match;\n                goto match;\n            }\n        } else {\n            if (VAR_39->dataat < VAR_6) {\n                SCLogDebug(\"absolute isdataat match\");\n                if (VAR_39->flags & VAR_41)\n                    goto no_match;\n                goto match;\n            } else {\n                SCLogDebug(\"absolute isdataat mismatch, id->isdataat %\"VAR_13\", buffer_len %\"VAR_13\"\", VAR_39->dataat, VAR_6);\n                if (VAR_39->flags & VAR_41)\n                    goto match;\n                goto no_match;\n            }\n        }\n\n    } else if (VAR_3->type == VAR_42) {\n        SCLogDebug(\"inspecting pcre\");\n        DetectPcreData *VAR_43 = (DetectPcreData *)VAR_3->ctx;\n        uint32_t VAR_19 = VAR_1->buffer_offset;\n        uint32_t VAR_18 = 0;\n        int VAR_36 = 0;\n\n        VAR_1->pcre_match_start_offset = 0;\n        do {\n            Packet *VAR_44 = NULL;\n            if (VAR_8 == VAR_34)\n                VAR_44 = (Packet *)VAR_9;\n            VAR_36 = DetectPcrePayloadMatch(VAR_1, VAR_2, VAR_3, VAR_44, VAR_4,\n                                       VAR_5, VAR_6);\n            if (VAR_36 == 0) {\n                goto no_match;\n            }\n\n            if (!(VAR_43->flags & VAR_45)) {\n                SCLogDebug(\"no relative match coming up, so this is a match\");\n                goto match;\n            }\n            KEYWORD_PROFILING_END(VAR_1, VAR_3->type, 1);\n\n            /* COMMENT_34 */\n            VAR_18 = VAR_1->pcre_match_start_offset;\n\n            /* COMMENT_35 */\n                                                                \n                                                                  \n            VAR_36 = DetectEngineContentInspection(VAR_0, VAR_1, VAR_2, VAR_3+1,\n                    VAR_4, VAR_5, VAR_6, VAR_7, VAR_8, VAR_9);\n            if (VAR_36 == 1) {\n                SCReturnInt(1);\n            }\n\n            if (VAR_1->discontinue_matching)\n                goto no_match;\n\n            VAR_1->buffer_offset = VAR_19;\n            VAR_1->pcre_match_start_offset = VAR_18;\n        } while (1);\n\n    } else if (VAR_3->type == VAR_46) {\n        DetectBytetestData *VAR_47 = (DetectBytetestData *)VAR_3->ctx;\n        uint8_t VAR_48 = VAR_47->flags;\n        int32_t VAR_16 = VAR_47->offset;\n        uint64_t VAR_49 = VAR_47->value;\n        if (VAR_48 & VAR_50) {\n            VAR_16 = VAR_1->bj_values[VAR_16];\n        }\n        if (VAR_48 & VAR_51) {\n            VAR_49 = VAR_1->bj_values[VAR_49];\n        }\n\n        /* COMMENT_38 */\n                                         \n        if (VAR_48 & VAR_52 && VAR_9 != NULL) {\n            DCERPCState *VAR_53 = (DCERPCState *)VAR_9;\n            /* COMMENT_40 */\n                                                                    \n            VAR_48 |= ((VAR_53->dcerpc.dcerpchdr.packed_drep[0] & 0x10) ?\n                      VAR_54: 0);\n        }\n\n        if (DetectBytetestDoMatch(VAR_1, VAR_2, VAR_3->ctx, VAR_5, VAR_6, VAR_48,\n                                  VAR_16, VAR_49) != 1) {\n            goto no_match;\n        }\n\n        goto match;\n\n    } else if (VAR_3->type == VAR_55) {\n        DetectBytejumpData *VAR_56 = (DetectBytejumpData *)VAR_3->ctx;\n        uint8_t VAR_48 = VAR_56->flags;\n        int32_t VAR_16 = VAR_56->offset;\n\n        if (VAR_48 & VAR_57) {\n            VAR_16 = VAR_1->bj_values[VAR_16];\n        }\n\n        /* COMMENT_42 */\n                                         \n        if (VAR_48 & VAR_58 && VAR_9 != NULL) {\n            DCERPCState *VAR_53 = (DCERPCState *)VAR_9;\n            /* COMMENT_44 */\n                                                                    \n            VAR_48 |= ((VAR_53->dcerpc.dcerpchdr.packed_drep[0] & 0x10) ?\n                      VAR_59: 0);\n        }\n\n        if (DetectBytejumpDoMatch(VAR_1, VAR_2, VAR_3->ctx, VAR_5, VAR_6,\n                                  VAR_48, VAR_16) != 1) {\n            goto no_match;\n        }\n\n        goto match;\n\n    } else if (VAR_3->type == VAR_60) {\n\n        DetectByteExtractData *VAR_61 = (DetectByteExtractData *)VAR_3->ctx;\n        uint8_t VAR_62 = VAR_61->endian;\n\n        /* COMMENT_46 */\n                                         \n        if ((VAR_61->flags & VAR_63) &&\n            VAR_62 == VAR_64 && VAR_9 != NULL) {\n\n            DCERPCState *VAR_53 = (DCERPCState *)VAR_9;\n            /* COMMENT_48 */\n                                                                    \n            VAR_62 |= ((VAR_53->dcerpc.dcerpchdr.packed_drep[0] == 0x10) ?\n                       VAR_65 : VAR_66);\n        }\n\n        if (DetectByteExtractDoMatch(VAR_1, VAR_3, VAR_2, VAR_5,\n                                     VAR_6,\n                                     &VAR_1->bj_values[VAR_61->local_id],\n                                     VAR_62) != 1) {\n            goto no_match;\n        }\n\n        goto match;\n\n        /* COMMENT_50 */\n    } else if (VAR_3->type == VAR_67) {\n        SCLogDebug(\"inspecting uri len\");\n\n        int VAR_36 = 0;\n        DetectUrilenData *VAR_68 = (DetectUrilenData *) VAR_3->ctx;\n\n        switch (VAR_68->mode) {\n            case VAR_69:\n                if (VAR_6 == VAR_68->urilen1)\n                    VAR_36 = 1;\n                break;\n            case VAR_70:\n                if (VAR_6 < VAR_68->urilen1)\n                    VAR_36 = 1;\n                break;\n            case VAR_71:\n                if (VAR_6 > VAR_68->urilen1)\n                    VAR_36 = 1;\n                break;\n            case VAR_72:\n                if (VAR_6 > VAR_68->urilen1 &&\n                    VAR_6 < VAR_68->urilen2) {\n                    VAR_36 = 1;\n                }\n                break;\n        }\n\n        if (VAR_36 == 1) {\n            goto match;\n        }\n\n        VAR_1->discontinue_matching = 0;\n\n        goto no_match;\n#ifdef VAR_73\n    }\n    else if (VAR_3->type == VAR_74) {\n        SCLogDebug(\"lua starting\");\n\n        if (DetectLuaMatchBuffer(VAR_1, VAR_2, VAR_3, VAR_5, VAR_6,\n                    VAR_1->buffer_offset, VAR_4) != 1)\n        {\n            SCLogDebug(\"lua no_match\");\n            goto no_match;\n        }\n        SCLogDebug(\"lua match\");\n        goto match;\n#endif/* COMMENT_51 */\n    } else if (smd->type == DETECT_BASE64_DECODE) {\n        if (DetectBase64DecodeDoMatch(VAR_1, VAR_2, VAR_3, VAR_5, VAR_6)) {\n            if (VAR_2->sm_arrays[VAR_75] != NULL) {\n                KEYWORD_PROFILING_END(VAR_1, VAR_3->type, 1);\n                if (DetectBase64DataDoMatch(VAR_0, VAR_1, VAR_2, VAR_4)) {\n                    /* COMMENT_52 */\n                    goto final_match;\n                }\n            }\n        }\n    } else {\n        SCLogDebug(\"sm->type %u\", VAR_3->type);\n#ifdef VAR_14\n        BUG_ON(1);\n#endif\n    }\n\nno_match:\n    KEYWORD_PROFILING_END(VAR_1, VAR_3->type, 0);\n    SCReturnInt(0);\n\nmatch:\n    /* COMMENT_53 */\n                                                      \n    if (!VAR_3->is_last) {\n        KEYWORD_PROFILING_END(VAR_1, VAR_3->type, 1);\n        int VAR_36 = DetectEngineContentInspection(VAR_0, VAR_1, VAR_2, VAR_3+1,\n                VAR_4, VAR_5, VAR_6, VAR_7, VAR_8, VAR_9);\n        SCReturnInt(VAR_36);\n    }\nfinal_match:\n    KEYWORD_PROFILING_END(VAR_1, VAR_3->type, 1);\n    SCReturnInt(1);\n}",
  "func_graph_path": "OISF/suricata/b9579fbe7dd408200ef03cbe20efddb624b73885/detect-engine-content-inspection.c/vul/after/0.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -186,6 +186,11 @@\n             SCLogDebug(\"found %p cd negated %s\", found, cd->flags & DETECT_CONTENT_NEGATED ? \"true\" : \"false\");\n \n             if (found == NULL && !(cd->flags & DETECT_CONTENT_NEGATED)) {\n+                if ((cd->flags & (DETECT_CONTENT_DISTANCE|DETECT_CONTENT_WITHIN)) == 0) {\n+                    /* independent match from previous matches, so failure is fatal */\n+                    det_ctx->discontinue_matching = 1;\n+                }\n+\n                 goto no_match;\n             } else if (found == NULL && (cd->flags & DETECT_CONTENT_NEGATED)) {\n                 goto match;\n@@ -210,16 +215,10 @@\n                         SCLogWarning(SC_ERR_INVALID_VALUE, \"Can't modify payload without packet\");\n                     }\n                 }\n-                if (!(cd->flags & DETECT_CONTENT_RELATIVE_NEXT)) {\n-                    SCLogDebug(\"no relative match coming up, so this is a match\");\n+\n+                /* if this is the last match we're done */\n+                if (smd->is_last) {\n                     goto match;\n-                }\n-\n-                /* bail out if we have no next match. Technically this is an\n-                 * error, as the current cd has the DETECT_CONTENT_RELATIVE_NEXT\n-                 * flag set. */\n-                if (smd->is_last) {\n-                    goto no_match;\n                 }\n \n                 SCLogDebug(\"content %\"PRIu32, cd->id);\n@@ -233,9 +232,21 @@\n                 if (r == 1) {\n                     SCReturnInt(1);\n                 }\n-\n-                if (det_ctx->discontinue_matching)\n+                SCLogDebug(\"no match for 'next sm'\");\n+\n+                if (det_ctx->discontinue_matching) {\n+                    SCLogDebug(\"'next sm' said to discontinue this right now\");\n                     goto no_match;\n+                }\n+\n+                /* no match and no reason to look for another instance */\n+                if ((cd->flags & DETECT_CONTENT_RELATIVE_NEXT) == 0) {\n+                    SCLogDebug(\"'next sm' does not depend on me, so we can give up\");\n+                    det_ctx->discontinue_matching = 1;\n+                    goto no_match;\n+                }\n+\n+                SCLogDebug(\"'next sm' depends on me %p, lets see what we can do (flags %u)\", cd, cd->flags);\n \n                 /* set the previous match offset to the start of this match + 1 */\n                 prev_offset = (match_offset - (cd->content_len - 1));",
  "diff_line_info": {
    "deleted_lines": [
      "                if (!(cd->flags & DETECT_CONTENT_RELATIVE_NEXT)) {",
      "                    SCLogDebug(\"no relative match coming up, so this is a match\");",
      "                }",
      "",
      "                /* bail out if we have no next match. Technically this is an",
      "                 * error, as the current cd has the DETECT_CONTENT_RELATIVE_NEXT",
      "                 * flag set. */",
      "                if (smd->is_last) {",
      "                    goto no_match;",
      "",
      "                if (det_ctx->discontinue_matching)"
    ],
    "added_lines": [
      "                if ((cd->flags & (DETECT_CONTENT_DISTANCE|DETECT_CONTENT_WITHIN)) == 0) {",
      "                    /* independent match from previous matches, so failure is fatal */",
      "                    det_ctx->discontinue_matching = 1;",
      "                }",
      "",
      "",
      "                /* if this is the last match we're done */",
      "                if (smd->is_last) {",
      "                SCLogDebug(\"no match for 'next sm'\");",
      "",
      "                if (det_ctx->discontinue_matching) {",
      "                    SCLogDebug(\"'next sm' said to discontinue this right now\");",
      "                }",
      "",
      "                /* no match and no reason to look for another instance */",
      "                if ((cd->flags & DETECT_CONTENT_RELATIVE_NEXT) == 0) {",
      "                    SCLogDebug(\"'next sm' does not depend on me, so we can give up\");",
      "                    det_ctx->discontinue_matching = 1;",
      "                    goto no_match;",
      "                }",
      "",
      "                SCLogDebug(\"'next sm' depends on me %p, lets see what we can do (flags %u)\", cd, cd->flags);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/OISF/suricata/pull/2681",
  "description": {
    "pr_info": {
      "title": "Next/20170501/v2",
      "number": 2681
    },
    "comment": [
      "Merging #2679 and #2680 \r\n\r\nPrscript:\r\n- PR inliniac-pcap: https://buildbot.openinfosecfoundation.org/builders/inliniac-pcap/builds/97\r\n- PR inliniac: https://buildbot.openinfosecfoundation.org/builders/inliniac/builds/605"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.9,
  "Bug Filter Response": "\n\nThe patch optimizes the detection process by preventing unnecessary recursion, which improves efficiency without addressing security vulnerabilities.\n\n**Final Output:**\n\nAnalysis: The patch modifies the detection logic to avoid recursive scanning when it's not beneficial, focusing on performance rather than security. The code changes don't address any security issues, as they aim to optimize rather than fix vulnerabilities.\n\nFinal Classification: Defect Remediation & Feature Upgrades\n\nConfidence Score: 0.9"
}