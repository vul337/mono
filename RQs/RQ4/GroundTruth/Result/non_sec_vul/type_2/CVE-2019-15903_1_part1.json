{
  "cve_id": "CVE-2019-15903",
  "cwe_ids": [
    "CWE-776",
    "CWE-125"
  ],
  "cvss_vector": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "libexpat",
  "commit_msg": "xmlparse.c: Deny internal entities closing the doctype",
  "commit_hash": "c20b758c332d9a13afbbb276d30db1d183a85d43",
  "git_url": "https://github.com/libexpat/libexpat/commit/c20b758c332d9a13afbbb276d30db1d183a85d43",
  "file_path": "expat/lib/xmlparse.c",
  "func_name": "processInternalEntity",
  "func_before": "static enum XML_Error\nprocessInternalEntity(XML_Parser parser, ENTITY *entity, XML_Bool betweenDecl) {\n  const char *textStart, *textEnd;\n  const char *next;\n  enum XML_Error result;\n  OPEN_INTERNAL_ENTITY *openEntity;\n\n  if (parser->m_freeInternalEntities) {\n    openEntity = parser->m_freeInternalEntities;\n    parser->m_freeInternalEntities = openEntity->next;\n  } else {\n    openEntity\n        = (OPEN_INTERNAL_ENTITY *)MALLOC(parser, sizeof(OPEN_INTERNAL_ENTITY));\n    if (! openEntity)\n      return XML_ERROR_NO_MEMORY;\n  }\n  entity->open = XML_TRUE;\n  entity->processed = 0;\n  openEntity->next = parser->m_openInternalEntities;\n  parser->m_openInternalEntities = openEntity;\n  openEntity->entity = entity;\n  openEntity->startTagLevel = parser->m_tagLevel;\n  openEntity->betweenDecl = betweenDecl;\n  openEntity->internalEventPtr = NULL;\n  openEntity->internalEventEndPtr = NULL;\n  textStart = (char *)entity->textPtr;\n  textEnd = (char *)(entity->textPtr + entity->textLen);\n  /* Set a safe default value in case 'next' does not get set */\n  next = textStart;\n\n#ifdef XML_DTD\n  if (entity->is_param) {\n    int tok\n        = XmlPrologTok(parser->m_internalEncoding, textStart, textEnd, &next);\n    result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd,\n                      tok, next, &next, XML_FALSE);\n  } else\n#endif /* XML_DTD */\n    result = doContent(parser, parser->m_tagLevel, parser->m_internalEncoding,\n                       textStart, textEnd, &next, XML_FALSE);\n\n  if (result == XML_ERROR_NONE) {\n    if (textEnd != next && parser->m_parsingStatus.parsing == XML_SUSPENDED) {\n      entity->processed = (int)(next - textStart);\n      parser->m_processor = internalEntityProcessor;\n    } else {\n      entity->open = XML_FALSE;\n      parser->m_openInternalEntities = openEntity->next;\n      /* put openEntity back in list of free instances */\n      openEntity->next = parser->m_freeInternalEntities;\n      parser->m_freeInternalEntities = openEntity;\n    }\n  }\n  return result;\n}",
  "abstract_func_before": "static enum XML_Error\nprocessInternalEntity(XML_Parser VAR_0, ENTITY *VAR_1, XML_Bool VAR_2) {\n  const char *VAR_3, *VAR_4;\n  const char *VAR_5;\n  enum XML_Error VAR_6;\n  OPEN_INTERNAL_ENTITY *VAR_7;\n\n  if (VAR_0->m_freeInternalEntities) {\n    VAR_7 = VAR_0->m_freeInternalEntities;\n    VAR_0->m_freeInternalEntities = VAR_7->next;\n  } else {\n    VAR_7\n        = (OPEN_INTERNAL_ENTITY *)MALLOC(VAR_0, sizeof(OPEN_INTERNAL_ENTITY));\n    if (! VAR_7)\n      return VAR_8;\n  }\n  VAR_1->open = VAR_9;\n  VAR_1->processed = 0;\n  VAR_7->next = VAR_0->m_openInternalEntities;\n  VAR_0->m_openInternalEntities = VAR_7;\n  VAR_7->entity = VAR_1;\n  VAR_7->startTagLevel = VAR_0->m_tagLevel;\n  VAR_7->betweenDecl = VAR_2;\n  VAR_7->internalEventPtr = NULL;\n  VAR_7->internalEventEndPtr = NULL;\n  VAR_3 = (char *)VAR_1->textPtr;\n  VAR_4 = (char *)(VAR_1->textPtr + VAR_1->textLen);\n  /* COMMENT_0 */\n  VAR_5 = VAR_3;\n\n#ifdef VAR_10\n  if (VAR_1->is_param) {\n    int VAR_11\n        = XmlPrologTok(VAR_0->m_internalEncoding, VAR_3, VAR_4, &VAR_5);\n    VAR_6 = doProlog(VAR_0, VAR_0->m_internalEncoding, VAR_3, VAR_4,\n                      VAR_11, VAR_5, &VAR_5, VAR_12);\n  } else\n#endif /* COMMENT_1 */\n    VAR_6 = doContent(VAR_0, VAR_0->m_tagLevel, VAR_0->m_internalEncoding,\n                       VAR_3, VAR_4, &VAR_5, VAR_12);\n\n  if (VAR_6 == VAR_13) {\n    if (VAR_4 != VAR_5 && VAR_0->m_parsingStatus.parsing == VAR_14) {\n      VAR_1->processed = (int)(VAR_5 - VAR_3);\n      VAR_0->m_processor = VAR_15;\n    } else {\n      VAR_1->open = VAR_12;\n      VAR_0->m_openInternalEntities = VAR_7->next;\n      /* COMMENT_2 */\n      VAR_7->next = VAR_0->m_freeInternalEntities;\n      VAR_0->m_freeInternalEntities = VAR_7;\n    }\n  }\n  return VAR_6;\n}",
  "func_graph_path_before": "libexpat/c20b758c332d9a13afbbb276d30db1d183a85d43/xmlparse.c/vul/before/2.json",
  "func": "static enum XML_Error\nprocessInternalEntity(XML_Parser parser, ENTITY *entity, XML_Bool betweenDecl) {\n  const char *textStart, *textEnd;\n  const char *next;\n  enum XML_Error result;\n  OPEN_INTERNAL_ENTITY *openEntity;\n\n  if (parser->m_freeInternalEntities) {\n    openEntity = parser->m_freeInternalEntities;\n    parser->m_freeInternalEntities = openEntity->next;\n  } else {\n    openEntity\n        = (OPEN_INTERNAL_ENTITY *)MALLOC(parser, sizeof(OPEN_INTERNAL_ENTITY));\n    if (! openEntity)\n      return XML_ERROR_NO_MEMORY;\n  }\n  entity->open = XML_TRUE;\n  entity->processed = 0;\n  openEntity->next = parser->m_openInternalEntities;\n  parser->m_openInternalEntities = openEntity;\n  openEntity->entity = entity;\n  openEntity->startTagLevel = parser->m_tagLevel;\n  openEntity->betweenDecl = betweenDecl;\n  openEntity->internalEventPtr = NULL;\n  openEntity->internalEventEndPtr = NULL;\n  textStart = (char *)entity->textPtr;\n  textEnd = (char *)(entity->textPtr + entity->textLen);\n  /* Set a safe default value in case 'next' does not get set */\n  next = textStart;\n\n#ifdef XML_DTD\n  if (entity->is_param) {\n    int tok\n        = XmlPrologTok(parser->m_internalEncoding, textStart, textEnd, &next);\n    result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd,\n                      tok, next, &next, XML_FALSE, XML_FALSE);\n  } else\n#endif /* XML_DTD */\n    result = doContent(parser, parser->m_tagLevel, parser->m_internalEncoding,\n                       textStart, textEnd, &next, XML_FALSE);\n\n  if (result == XML_ERROR_NONE) {\n    if (textEnd != next && parser->m_parsingStatus.parsing == XML_SUSPENDED) {\n      entity->processed = (int)(next - textStart);\n      parser->m_processor = internalEntityProcessor;\n    } else {\n      entity->open = XML_FALSE;\n      parser->m_openInternalEntities = openEntity->next;\n      /* put openEntity back in list of free instances */\n      openEntity->next = parser->m_freeInternalEntities;\n      parser->m_freeInternalEntities = openEntity;\n    }\n  }\n  return result;\n}",
  "abstract_func": "static enum XML_Error\nprocessInternalEntity(XML_Parser VAR_0, ENTITY *VAR_1, XML_Bool VAR_2) {\n  const char *VAR_3, *VAR_4;\n  const char *VAR_5;\n  enum XML_Error VAR_6;\n  OPEN_INTERNAL_ENTITY *VAR_7;\n\n  if (VAR_0->m_freeInternalEntities) {\n    VAR_7 = VAR_0->m_freeInternalEntities;\n    VAR_0->m_freeInternalEntities = VAR_7->next;\n  } else {\n    VAR_7\n        = (OPEN_INTERNAL_ENTITY *)MALLOC(VAR_0, sizeof(OPEN_INTERNAL_ENTITY));\n    if (! VAR_7)\n      return VAR_8;\n  }\n  VAR_1->open = VAR_9;\n  VAR_1->processed = 0;\n  VAR_7->next = VAR_0->m_openInternalEntities;\n  VAR_0->m_openInternalEntities = VAR_7;\n  VAR_7->entity = VAR_1;\n  VAR_7->startTagLevel = VAR_0->m_tagLevel;\n  VAR_7->betweenDecl = VAR_2;\n  VAR_7->internalEventPtr = NULL;\n  VAR_7->internalEventEndPtr = NULL;\n  VAR_3 = (char *)VAR_1->textPtr;\n  VAR_4 = (char *)(VAR_1->textPtr + VAR_1->textLen);\n  /* COMMENT_0 */\n  VAR_5 = VAR_3;\n\n#ifdef VAR_10\n  if (VAR_1->is_param) {\n    int VAR_11\n        = XmlPrologTok(VAR_0->m_internalEncoding, VAR_3, VAR_4, &VAR_5);\n    VAR_6 = doProlog(VAR_0, VAR_0->m_internalEncoding, VAR_3, VAR_4,\n                      VAR_11, VAR_5, &VAR_5, VAR_12, VAR_12);\n  } else\n#endif /* COMMENT_1 */\n    VAR_6 = doContent(VAR_0, VAR_0->m_tagLevel, VAR_0->m_internalEncoding,\n                       VAR_3, VAR_4, &VAR_5, VAR_12);\n\n  if (VAR_6 == VAR_13) {\n    if (VAR_4 != VAR_5 && VAR_0->m_parsingStatus.parsing == VAR_14) {\n      VAR_1->processed = (int)(VAR_5 - VAR_3);\n      VAR_0->m_processor = VAR_15;\n    } else {\n      VAR_1->open = VAR_12;\n      VAR_0->m_openInternalEntities = VAR_7->next;\n      /* COMMENT_2 */\n      VAR_7->next = VAR_0->m_freeInternalEntities;\n      VAR_0->m_freeInternalEntities = VAR_7;\n    }\n  }\n  return VAR_6;\n}",
  "func_graph_path": "libexpat/c20b758c332d9a13afbbb276d30db1d183a85d43/xmlparse.c/vul/after/2.json",
  "diff_func": "--- func_before\n+++ func_after\n@@ -33,7 +33,7 @@\n     int tok\n         = XmlPrologTok(parser->m_internalEncoding, textStart, textEnd, &next);\n     result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd,\n-                      tok, next, &next, XML_FALSE);\n+                      tok, next, &next, XML_FALSE, XML_FALSE);\n   } else\n #endif /* XML_DTD */\n     result = doContent(parser, parser->m_tagLevel, parser->m_internalEncoding,",
  "diff_line_info": {
    "deleted_lines": [
      "                      tok, next, &next, XML_FALSE);"
    ],
    "added_lines": [
      "                      tok, next, &next, XML_FALSE, XML_FALSE);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/libexpat/libexpat/pull/318",
  "description": {
    "pr_info": {
      "title": "[CVE-2019-15903] Deny internal entities closing the doctype (for #317)",
      "number": 318
    },
    "comment": [
      "Related to #317, work in progress.\r\n\r\nReview wanted!\r\n\r\nCC @yuweol @RMJ10 @DerDakon",
      "Unless someone hits the brakes, I'm aiming to merge at Tuesday 2019-09-03 evening, then requesting a CVE, waiting for the CVE request reply, then making a new release.",
      "That looks eminently sensible to me.  Is there anything else we should be disallowing from internal entities that we currently allow?  I don't think so, but I haven't looked very hard.",
      "Rhodri, thanks for the review!"
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.8,
  "Bug Filter Response": "\n\nThe patch modifies the handling of internal entities in an XML parser by adding a parameter to prevent them from closing the doctype. This change addresses a functional bug rather than a security vulnerability.\n\n**Final Classification:** Defect Remediation & Feature Upgrades  \n**Confidence Score:** 0.8"
}