{
  "cve_id": "CVE-2021-45429",
  "cwe_ids": [
    "CWE-120"
  ],
  "cvss_vector": "AV:N/AC:M/Au:N/C:N/I:N/A:P",
  "cvss_is_v3": false,
  "repo_name": "VirusTotal/yara",
  "commit_msg": "Fix issue #1616\n\nThis is a more comprehensive fix than #1617, it adds new functions to the API for getting/setting uint32 and uint64 settings.  Using these functions is preferable over calling `yr_(get|set)_configuration` directly.",
  "commit_hash": "b34b7e74c862c129b801832b6b85401fbada2b01",
  "git_url": "https://github.com/VirusTotal/yara/commit/b34b7e74c862c129b801832b6b85401fbada2b01",
  "file_path": "libyara/proc/mach.c",
  "func_name": "yr_process_get_next_memory_block",
  "func_before": "YR_API YR_MEMORY_BLOCK* yr_process_get_next_memory_block(\n    YR_MEMORY_BLOCK_ITERATOR* iterator)\n{\n  YR_PROC_ITERATOR_CTX* context = (YR_PROC_ITERATOR_CTX*) iterator->context;\n  YR_PROC_INFO* proc_info = context->proc_info;\n\n  kern_return_t kr;\n  mach_msg_type_number_t info_count;\n  mach_port_t object;\n  vm_region_basic_info_data_64_t info;\n  vm_size_t size = 0;\n\n  uint64_t current_begin = (vm_address_t) context->current_block.base +\n                           context->current_block.size;\n  vm_address_t address = current_begin;\n  uint64_t max_process_memory_chunk;\n\n  yr_get_configuration(\n      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, (void*) &max_process_memory_chunk);\n\n  iterator->last_error = ERROR_SUCCESS;\n\n  do\n  {\n    info_count = VM_REGION_BASIC_INFO_COUNT_64;\n\n    kr = vm_region_64(\n        proc_info->task,\n        &address,\n        &size,\n        VM_REGION_BASIC_INFO,\n        (vm_region_info_t) &info,\n        &info_count,\n        &object);\n\n    if (kr == KERN_SUCCESS)\n    {\n      size_t chunk_size = size - (size_t) (current_begin - address);\n\n      if (((uint64_t) chunk_size) > max_process_memory_chunk)\n      {\n        chunk_size = (size_t) max_process_memory_chunk;\n      }\n\n      context->current_block.base = (size_t) current_begin;\n      context->current_block.size = chunk_size;\n\n      return &context->current_block;\n    }\n\n    current_begin = address;\n\n  } while (kr != KERN_INVALID_ADDRESS);\n\n  return NULL;\n}",
  "abstract_func_before": "YR_API VAR_0* yr_process_get_next_memory_block(\n    YR_MEMORY_BLOCK_ITERATOR* VAR_1)\n{\n  YR_PROC_ITERATOR_CTX* VAR_2 = (YR_PROC_ITERATOR_CTX*) VAR_1->context;\n  YR_PROC_INFO* VAR_3 = VAR_2->proc_info;\n\n  kern_return_t VAR_4;\n  mach_msg_type_number_t VAR_5;\n  mach_port_t VAR_6;\n  vm_region_basic_info_data_64_t VAR_7;\n  vm_size_t VAR_8 = 0;\n\n  uint64_t VAR_9 = (vm_address_t) VAR_2->current_block.base +\n                           VAR_2->current_block.size;\n  vm_address_t VAR_10 = VAR_9;\n  uint64_t VAR_11;\n\n  yr_get_configuration(\n      VAR_12, (void*) &VAR_11);\n\n  VAR_1->last_error = VAR_13;\n\n  do\n  {\n    VAR_5 = VAR_14;\n\n    VAR_4 = vm_region_64(\n        VAR_3->task,\n        &VAR_10,\n        &VAR_8,\n        VAR_15,\n        (VAR_16) &VAR_7,\n        &VAR_5,\n        &VAR_6);\n\n    if (VAR_4 == VAR_17)\n    {\n      size_t VAR_18 = VAR_8 - (size_t) (VAR_9 - VAR_10);\n\n      if (((uint64_t) VAR_18) > VAR_11)\n      {\n        VAR_18 = (size_t) VAR_11;\n      }\n\n      VAR_2->current_block.base = (size_t) VAR_9;\n      VAR_2->current_block.size = VAR_18;\n\n      return &VAR_2->current_block;\n    }\n\n    VAR_9 = VAR_10;\n\n  } while (VAR_4 != VAR_19);\n\n  return NULL;\n}",
  "func_graph_path_before": null,
  "func": "YR_API YR_MEMORY_BLOCK* yr_process_get_next_memory_block(\n    YR_MEMORY_BLOCK_ITERATOR* iterator)\n{\n  YR_PROC_ITERATOR_CTX* context = (YR_PROC_ITERATOR_CTX*) iterator->context;\n  YR_PROC_INFO* proc_info = context->proc_info;\n\n  kern_return_t kr;\n  mach_msg_type_number_t info_count;\n  mach_port_t object;\n  vm_region_basic_info_data_64_t info;\n  vm_size_t size = 0;\n\n  uint64_t current_begin = (vm_address_t) context->current_block.base +\n                           context->current_block.size;\n  vm_address_t address = current_begin;\n  uint64_t max_process_memory_chunk;\n\n  yr_get_configuration_uint64(\n      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, &max_process_memory_chunk);\n\n  iterator->last_error = ERROR_SUCCESS;\n\n  do\n  {\n    info_count = VM_REGION_BASIC_INFO_COUNT_64;\n\n    kr = vm_region_64(\n        proc_info->task,\n        &address,\n        &size,\n        VM_REGION_BASIC_INFO,\n        (vm_region_info_t) &info,\n        &info_count,\n        &object);\n\n    if (kr == KERN_SUCCESS)\n    {\n      size_t chunk_size = size - (size_t) (current_begin - address);\n\n      if (((uint64_t) chunk_size) > max_process_memory_chunk)\n      {\n        chunk_size = (size_t) max_process_memory_chunk;\n      }\n\n      context->current_block.base = (size_t) current_begin;\n      context->current_block.size = chunk_size;\n\n      return &context->current_block;\n    }\n\n    current_begin = address;\n\n  } while (kr != KERN_INVALID_ADDRESS);\n\n  return NULL;\n}",
  "abstract_func": "YR_API VAR_0* yr_process_get_next_memory_block(\n    YR_MEMORY_BLOCK_ITERATOR* VAR_1)\n{\n  YR_PROC_ITERATOR_CTX* VAR_2 = (YR_PROC_ITERATOR_CTX*) VAR_1->context;\n  YR_PROC_INFO* VAR_3 = VAR_2->proc_info;\n\n  kern_return_t VAR_4;\n  mach_msg_type_number_t VAR_5;\n  mach_port_t VAR_6;\n  vm_region_basic_info_data_64_t VAR_7;\n  vm_size_t VAR_8 = 0;\n\n  uint64_t VAR_9 = (vm_address_t) VAR_2->current_block.base +\n                           VAR_2->current_block.size;\n  vm_address_t VAR_10 = VAR_9;\n  uint64_t VAR_11;\n\n  yr_get_configuration_uint64(\n      VAR_12, &VAR_11);\n\n  VAR_1->last_error = VAR_13;\n\n  do\n  {\n    VAR_5 = VAR_14;\n\n    VAR_4 = vm_region_64(\n        VAR_3->task,\n        &VAR_10,\n        &VAR_8,\n        VAR_15,\n        (VAR_16) &VAR_7,\n        &VAR_5,\n        &VAR_6);\n\n    if (VAR_4 == VAR_17)\n    {\n      size_t VAR_18 = VAR_8 - (size_t) (VAR_9 - VAR_10);\n\n      if (((uint64_t) VAR_18) > VAR_11)\n      {\n        VAR_18 = (size_t) VAR_11;\n      }\n\n      VAR_2->current_block.base = (size_t) VAR_9;\n      VAR_2->current_block.size = VAR_18;\n\n      return &VAR_2->current_block;\n    }\n\n    VAR_9 = VAR_10;\n\n  } while (VAR_4 != VAR_19);\n\n  return NULL;\n}",
  "func_graph_path": null,
  "diff_func": "--- func_before\n+++ func_after\n@@ -15,8 +15,8 @@\n   vm_address_t address = current_begin;\n   uint64_t max_process_memory_chunk;\n \n-  yr_get_configuration(\n-      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, (void*) &max_process_memory_chunk);\n+  yr_get_configuration_uint64(\n+      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, &max_process_memory_chunk);\n \n   iterator->last_error = ERROR_SUCCESS;\n ",
  "diff_line_info": {
    "deleted_lines": [
      "  yr_get_configuration(",
      "      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, (void*) &max_process_memory_chunk);"
    ],
    "added_lines": [
      "  yr_get_configuration_uint64(",
      "      YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK, &max_process_memory_chunk);"
    ]
  },
  "is_vul": true,
  "pr_url": "https://github.com/VirusTotal/yara/pull/1621",
  "description": {
    "pr_info": {
      "title": "Fix issue #1616",
      "number": 1621
    },
    "comment": [
      "This is a more comprehensive fix than #1617, it adds new functions to the API for getting/setting uint32 and uint64 settings.  Using these functions is preferable over calling `yr_(get|set)_configuration` directly."
    ]
  },
  "Bug Filter": "Defect Remediation & Feature Upgrades",
  "Bug Filter Confidence": 0.85,
  "Bug Filter Response": "\n\n**Final Output:**\n\nAnalysis: The patch introduces new API functions for handling uint32 and uint64 settings, replacing direct calls to `yr_get_configuration`. The code change enhances type safety by using a specific uint64 function, avoiding void pointers. While this improves code safety, it doesn't address a security exploit or vulnerability.\n\nFinal Classification: Defect Remediation & Feature Upgrades\n\nConfidence Score: 0.85"
}